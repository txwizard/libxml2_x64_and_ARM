; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xmlschemas.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@ ; `string'
PUBLIC	??_C@_0CK@FAJBIKFJ@http?3?1?1www?4w3?4org?12001?1XMLSchem@ ; `string'
PUBLIC	??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@ ; `string'
_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
;	COMDAT ??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@
CONST	SEGMENT
??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@ DB 'http://www.'
	DB	'w3.org/2000/xmlns/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FAJBIKFJ@http?3?1?1www?4w3?4org?12001?1XMLSchem@
CONST	SEGMENT
??_C@_0CK@FAJBIKFJ@http?3?1?1www?4w3?4org?12001?1XMLSchem@ DB 'http://www'
	DB	'.w3.org/2001/XMLSchema-instance', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
CONST	SEGMENT
??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@ DB 'http://www'
	DB	'.w3.org/2001/XMLSchema', 00H		; `string'
CONST	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__7C094509_xmlschemas@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_snprintf
PUBLIC	_xmlSchemaNewParserCtxt
PUBLIC	_xmlSchemaNewMemParserCtxt
PUBLIC	_xmlSchemaNewDocParserCtxt
PUBLIC	_xmlSchemaFreeParserCtxt
PUBLIC	_xmlSchemaSetParserErrors
PUBLIC	_xmlSchemaSetParserStructuredErrors
PUBLIC	_xmlSchemaGetParserErrors
PUBLIC	_xmlSchemaIsValid
PUBLIC	_xmlSchemaParse
PUBLIC	_xmlSchemaFree
PUBLIC	_xmlSchemaDump
PUBLIC	_xmlSchemaSetValidErrors
PUBLIC	_xmlSchemaSetValidStructuredErrors
PUBLIC	_xmlSchemaGetValidErrors
PUBLIC	_xmlSchemaSetValidOptions
PUBLIC	_xmlSchemaValidateSetFilename
PUBLIC	_xmlSchemaValidCtxtGetOptions
PUBLIC	_xmlSchemaNewValidCtxt
PUBLIC	_xmlSchemaFreeValidCtxt
PUBLIC	_xmlSchemaValidateDoc
PUBLIC	_xmlSchemaValidateOneElement
PUBLIC	_xmlSchemaValidateStream
PUBLIC	_xmlSchemaValidateFile
PUBLIC	_xmlSchemaValidCtxtGetParserCtxt
PUBLIC	_xmlSchemaSAXPlug
PUBLIC	_xmlSchemaSAXUnplug
PUBLIC	_xmlSchemaValidateSetLocator
PUBLIC	_xmlSchemaFreeType
PUBLIC	_xmlSchemaFreeWildcard
PUBLIC	_xmlSchemaNewFacet
PUBLIC	_xmlSchemaCheckFacet
PUBLIC	_xmlSchemaFreeFacet
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BH@BIKOCJPH@simple?5type?5definition@	; `string'
PUBLIC	??_C@_0BI@MHGDJJNC@complex?5type?5definition@	; `string'
PUBLIC	??_C@_0BE@GNKEMAII@element?5declaration@	; `string'
PUBLIC	??_C@_0O@OMANOKDA@attribute?5use@		; `string'
PUBLIC	??_C@_0BG@EDIHLHKC@attribute?5declaration@	; `string'
PUBLIC	??_C@_0BH@MMBLGEHA@model?5group?5definition@	; `string'
PUBLIC	??_C@_0BL@LEHHANJP@attribute?5group?5definition@ ; `string'
PUBLIC	??_C@_0BF@JHGFINH@notation?5declaration@	; `string'
PUBLIC	??_C@_0BH@EJHDDDLA@model?5group?5?$CIsequence?$CJ@ ; `string'
PUBLIC	??_C@_0BF@DBPJFANL@model?5group?5?$CIchoice?$CJ@ ; `string'
PUBLIC	??_C@_0BC@IIBLBPCH@model?5group?5?$CIall?$CJ@	; `string'
PUBLIC	??_C@_08PKKGOGAD@particle@			; `string'
PUBLIC	??_C@_0BL@NFCPOJDK@unique?5identity?9constraint@ ; `string'
PUBLIC	??_C@_0BI@LJCGFAMF@key?5identity?9constraint@	; `string'
PUBLIC	??_C@_0BL@GKPNKMCM@keyref?5identity?9constraint@ ; `string'
PUBLIC	??_C@_0P@BBIPBLEO@wildcard?5?$CIany?$CJ@	; `string'
PUBLIC	??_C@_0CD@GEFKFDJJ@?$FLhelper?5component?$FN?5QName?5refere@ ; `string'
PUBLIC	??_C@_0CN@OAJJPDIM@?$FLhelper?5component?$FN?5attribute?5us@ ; `string'
PUBLIC	??_C@_0BH@CAFJLKIN@Not?5a?5schema?5component@	; `string'
PUBLIC	??_C@_01HCONENDN@?$HL@				; `string'
PUBLIC	??_C@_01CELHOKLL@?$HN@				; `string'
PUBLIC	??_C@_06LHGEHABH@?$CINULL?$CJ@			; `string'
PUBLIC	??_C@_02OCDGNCGI@?5?8@				; `string'
PUBLIC	??_C@_01GEODFPGF@?8@				; `string'
PUBLIC	??_C@_04DLBGLKG@skip@				; `string'
PUBLIC	??_C@_03BLIDKLB@lax@				; `string'
PUBLIC	??_C@_06OLFOGHEN@strict@			; `string'
PUBLIC	??_C@_0BJ@IEOMLCDH@invalid?5process?5contents@	; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_0BB@MLAHCBJL@atomic?5type?5?8xs?3@	; `string'
PUBLIC	??_C@_0P@NECGJBPP@list?5type?5?8xs?3@		; `string'
PUBLIC	??_C@_0BA@CKGFBMGP@union?5type?5?8xs?3@		; `string'
PUBLIC	??_C@_0BB@GMNLLPLD@simple?5type?5?8xs?3@	; `string'
PUBLIC	??_C@_06FOGGDAIC@local?5@			; `string'
PUBLIC	??_C@_0M@NAKOLHPN@atomic?5type@			; `string'
PUBLIC	??_C@_09EMCEHNFO@list?5type@			; `string'
PUBLIC	??_C@_0L@KHBDGNKM@union?5type@			; `string'
PUBLIC	??_C@_0M@CHKFADBH@simple?5type@			; `string'
PUBLIC	??_C@_0N@NIBELLIN@complex?5type@		; `string'
PUBLIC	??_C@_0P@LDLBBJOE@attribute?5use?5@		; `string'
PUBLIC	??_C@_09GPGAJHPD@?$CIunknown?$CJ@		; `string'
PUBLIC	??_C@_0BA@NHBCAGDA@attribute?5decl?4@		; `string'
PUBLIC	??_C@_0O@HMOECBPO@element?5decl?4@		; `string'
PUBLIC	??_C@_08GHLBJEBL@unique?5?8@			; `string'
PUBLIC	??_C@_05IJGDECGL@key?5?8@			; `string'
PUBLIC	??_C@_08MKGKMCJE@keyRef?5?8@			; `string'
PUBLIC	??_C@_09NMNBGFGO@?5wildcard@			; `string'
PUBLIC	??_C@_07HIPPIIHM@facet?5?8@			; `string'
PUBLIC	??_C@_0BB@IMEONDPK@model?5group?5def?4@		; `string'
PUBLIC	??_C@_09NEDFDOKM@Element?5?8@			; `string'
PUBLIC	??_C@_0O@MMBACEAK@?0?5attribute?5?8@		; `string'
PUBLIC	??_C@_0CN@FICFNABL@compute?5the?5canonical?5lexical?5r@ ; `string'
PUBLIC	??_C@_0BM@OEBNECHE@xmlSchemaFormatFacetEnumSet@	; `string'
PUBLIC	??_C@_03NGNHMEOA@?0?5?8@			; `string'
PUBLIC	??_C@_0GM@IJCDLDON@c?3?2users?2dag?2documents?2_clients@ ; `string'
PUBLIC	??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ ; `string'
PUBLIC	??_C@_03EHINCMEC@?8?0?5@			; `string'
PUBLIC	??_C@_0M@DCJBDJKC@attribute?5?8@		; `string'
PUBLIC	??_C@_03FPCGPDIA@?8?3?5@			; `string'
PUBLIC	??_C@_0BF@EFOKBLAL@Internal?5error?3?5?$CFs?0?5@ ; `string'
PUBLIC	??_C@_02MIICKFIN@?4?6@				; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_C@_0P@KFJAHJM@Element?5?8?$CFs?8?3?5@	; `string'
PUBLIC	??_C@_0BO@ONHLDAAN@?8?$CFs?8?5is?5not?5a?5valid?5value?5of?5@ ; `string'
PUBLIC	??_C@_0CP@NNGHIIKI@The?5character?5content?5is?5not?5a?5@ ; `string'
PUBLIC	??_C@_0L@MLMEJNFI@the?5local?5@			; `string'
PUBLIC	??_C@_04BAIFLMGI@the?5@				; `string'
PUBLIC	??_C@_03DCOKAOA@xs?3@				; `string'
PUBLIC	??_C@_0CE@FELNOPMA@The?5attribute?5?8?$CFs?8?5is?5not?5allow@ ; `string'
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
PUBLIC	??_C@_0BH@JGKEPFCF@?5Expected?5is?5one?5of?5?$CI?5@ ; `string'
PUBLIC	??_C@_0BA@HCJBOGK@?5Expected?5is?5?$CI?5@	; `string'
PUBLIC	??_C@_07ELAGFAPB@?$CD?$CDother@			; `string'
PUBLIC	??_C@_01NBENCBCI@?$CK@				; `string'
PUBLIC	??_C@_03MNMOMDPD@?$HL?$CK?$HN@			; `string'
PUBLIC	??_C@_09OEHCBIBE@?$HL?$CD?$CDother?3@		; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5@				; `string'
PUBLIC	??_C@_04ONBKEEDC@?5?$CJ?4?6@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_01OHGJGJJP@?$FL@				; `string'
PUBLIC	??_C@_03BCLOCOCF@?8?$FN?5@			; `string'
PUBLIC	??_C@_0CG@GNANNDNL@The?5value?5?8?$CFs?8?5has?5a?5length?5of?5@ ; `string'
PUBLIC	??_C@_0CB@KPGCMBDK@The?5value?5has?5a?5length?5of?5?8?$CFs?8?$DL@ ; `string'
PUBLIC	??_C@_03FKNCMABI@?$CFlu@			; `string'
PUBLIC	??_C@_0CP@IEDJOHDN@this?5differs?5from?5the?5allowed?5l@ ; `string'
PUBLIC	??_C@_0DC@OJNJPCCF@this?5exceeds?5the?5allowed?5maximu@ ; `string'
PUBLIC	??_C@_0DE@PEKKBPHG@this?5underruns?5the?5allowed?5mini@ ; `string'
PUBLIC	??_C@_0DD@DOBLIGCG@The?5value?5?8?$CFs?8?5is?5not?5an?5elemen@ ; `string'
PUBLIC	??_C@_0DF@NEKJCLEF@The?5value?5?8?$CFs?8?5is?5not?5accepted?5@ ; `string'
PUBLIC	??_C@_0DP@JKCFEDLM@The?5value?5?8?$CFs?8?5is?5less?5than?5the@ ; `string'
PUBLIC	??_C@_0EC@ODIEFLC@The?5value?5?8?$CFs?8?5is?5greater?5than?5@ ; `string'
PUBLIC	??_C@_0CL@CEDGHCDN@The?5value?5?8?$CFs?8?5must?5be?5greater?5@ ; `string'
PUBLIC	??_C@_0CI@DMBEGLJK@The?5value?5?8?$CFs?8?5must?5be?5less?5tha@ ; `string'
PUBLIC	??_C@_0DJ@CHBCAGLC@The?5value?5?8?$CFs?8?5has?5more?5digits?5@ ; `string'
PUBLIC	??_C@_0EE@PPGDNELD@The?5value?5?8?$CFs?8?5has?5more?5fractio@ ; `string'
PUBLIC	??_C@_0CE@HKFPHOBG@The?5value?5?8?$CFs?8?5is?5not?5facet?9val@ ; `string'
PUBLIC	??_C@_0BP@CKLMMNCB@The?5value?5is?5not?5facet?9valid?4?6@ ; `string'
PUBLIC	??_C@_08EAGHGJIC@?$CFs?3?5?$CFs?4?6@		; `string'
PUBLIC	??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@ ; `string'
PUBLIC	??_C@_0EH@GOOOKJLI@?$CFs?0?5attribute?5?8?$CFs?8?3?5The?5QName?5v@ ; `string'
PUBLIC	??_C@_07NBCGADJA@Unknown@			; `string'
PUBLIC	??_C@_0BJ@EDCPEHIM@?$CFs?0?5attribute?5?8?$CFs?8?3?5?$CFs?4?6@ ; `string'
PUBLIC	??_C@_0CG@GPHLIIIG@?$CFsThe?5attribute?5?8?$CFs?8?5is?5not?5all@ ; `string'
PUBLIC	??_C@_04PFAOODAA@?$CFs?3?5@			; `string'
PUBLIC	??_C@_0EG@LINCPIFE@?$CFs?3?5The?5facet?5?8?$CFs?8?5is?5not?5allow@ ; `string'
PUBLIC	??_C@_0CE@OEIFIFDF@?$CFs?3?5The?5facet?5?8?$CFs?8?5is?5not?5allow@ ; `string'
PUBLIC	??_C@_0DK@HPMJEOHA@?$CFs?3?5The?5attributes?5?8?$CFs?8?5and?5?8?$CFs@ ; `string'
PUBLIC	??_C@_02DGLLHPKE@?8?4@				; `string'
PUBLIC	??_C@_0BN@HAAPLFMH@The?5value?5?8?$CFs?8?5is?5not?5valid?4@ ; `string'
PUBLIC	??_C@_0CE@BMFBGFDE@The?5character?5content?5is?5not?5va@ ; `string'
PUBLIC	??_C@_0P@PICMEPAD@?5Expected?5is?5?8@		; `string'
PUBLIC	??_C@_03CLGCDEAE@?8?4?6@			; `string'
PUBLIC	??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@ ; `string'
PUBLIC	??_C@_0BP@IENIKLPP@?$CFs?3?5The?5content?5is?5not?5valid?4?6@ ; `string'
PUBLIC	??_C@_0BC@BFLACGOA@allocating?5schema@		; `string'
PUBLIC	??_C@_0BG@ICNGEPGO@allocating?5annotation@	; `string'
PUBLIC	??_C@_0CC@BAFOADOL@allocating?5an?5item?5list?5structu@ ; `string'
PUBLIC	??_C@_0BJ@JABJNCPJ@allocating?5new?5item?5list@	; `string'
PUBLIC	??_C@_0BC@PKMEEMHP@growing?5item?5list@		; `string'
PUBLIC	??_C@_0DH@PONCBEFB@Internal?5error?3?5xmlSchemaItemLi@ ; `string'
PUBLIC	??_C@_0BO@PGEEMOLL@no?5main?5schema?5on?5constructor@ ; `string'
PUBLIC	??_C@_0BG@KOPDJPPO@xmlSchemaBucketCreate@	; `string'
PUBLIC	??_C@_0BJ@CMBPIEML@allocating?5schema?5bucket@	; `string'
PUBLIC	??_C@_0CN@IEDLEJJH@first?5bucket?5but?5it?8s?5an?5includ@ ; `string'
PUBLIC	??_C@_0CH@KFOKDOIL@main?5bucket?5but?5it?8s?5not?5the?5fi@ ; `string'
PUBLIC	??_C@_02IEBMKJDF@?$CD?$CD@			; `string'
PUBLIC	??_C@_0CM@PPHBJHEG@failed?5to?5add?5the?5schema?5bucket@ ; `string'
PUBLIC	??_C@_0EM@EBPFONFN@Internal?5error?3?5xmlSchemaCompon@ ; `string'
PUBLIC	??_C@_07ILMPLKHC@Element@			; `string'
PUBLIC	??_C@_09GAHIJPLK@?5?$CIglobal?$CJ@		; `string'
PUBLIC	??_C@_07IDOJLIPA@?3?5?8?$CFs?8?5@		; `string'
PUBLIC	??_C@_07ONOPJFOL@ns?5?8?$CFs?8@			; `string'
PUBLIC	??_C@_09MDPMFALO@?5?5props?3?5@			; `string'
PUBLIC	??_C@_08BCFMBKHE@?$FLfixed?$FN?5@		; `string'
PUBLIC	??_C@_0L@CIMKDCEL@?$FLdefault?$FN?5@		; `string'
PUBLIC	??_C@_0M@BPMPIELH@?$FLabstract?$FN?5@		; `string'
PUBLIC	??_C@_0M@BCKHHPGO@?$FLnillable?$FN?5@		; `string'
PUBLIC	??_C@_0P@OOGOODOG@?5?5value?3?5?8?$CFs?8?6@	; `string'
PUBLIC	??_C@_0O@LPELKPN@?5?5type?3?5?8?$CFs?8?5@	; `string'
PUBLIC	??_C@_08MNNKDMOP@ns?5?8?$CFs?8?6@		; `string'
PUBLIC	??_C@_0BL@GHPOMFG@?5?5substitutionGroup?3?5?8?$CFs?8?5@ ; `string'
PUBLIC	??_C@_0N@FJPFKNMF@?5?5Annot?3?5?$CFs?6@		; `string'
PUBLIC	??_C@_0BA@MKDNPCKH@?5?5Annot?3?5empty?6@	; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0BH@DPNPBLLK@MISSING?5particle?5term?6@	; `string'
PUBLIC	??_C@_09HHDCLOAM@ELEM?5?8?$CFs?8@		; `string'
PUBLIC	??_C@_08POLPFBMC@SEQUENCE@			; `string'
PUBLIC	??_C@_06DHBGJHJC@CHOICE@			; `string'
PUBLIC	??_C@_03NIFPGLBG@ALL@				; `string'
PUBLIC	??_C@_03OMGOFJGM@ANY@				; `string'
PUBLIC	??_C@_08GCOIMFOL@UNKNOWN?6@			; `string'
PUBLIC	??_C@_08IIINJODF@?5min?3?5?$CFd@		; `string'
PUBLIC	??_C@_0BA@NODJHFHO@?5max?3?5unbounded@		; `string'
PUBLIC	??_C@_08GOONDBNE@?5max?3?5?$CFd@		; `string'
PUBLIC	??_C@_0P@JCEFCIDL@?5?5attributes?3?6@		; `string'
PUBLIC	??_C@_0BB@EJJDJFMI@?5?5?$FLprohibition?$FN?5@	; `string'
PUBLIC	??_C@_0P@IGLOKPCJ@?5?5?$FLreference?$FN?5@	; `string'
PUBLIC	??_C@_08FLCGCOPE@?5?5?$FLuse?$FN?5@		; `string'
PUBLIC	??_C@_05ODNCHMDL@?8?$CFs?8?6@			; `string'
PUBLIC	??_C@_0M@JCDJFDMD@Type?3?5NULL?6@		; `string'
PUBLIC	??_C@_06NAHGBCDG@Type?3?5@			; `string'
PUBLIC	??_C@_05IMLJLABD@?8?$CFs?8?5@			; `string'
PUBLIC	??_C@_0L@MKMGDOCG@?$CIno?5name?$CJ?5@		; `string'
PUBLIC	??_C@_08KCLBPAMH@ns?5?8?$CFs?8?5@		; `string'
PUBLIC	??_C@_08JHBJHPJC@?$FLbasic?$FN?5@		; `string'
PUBLIC	??_C@_09BLJCIKGO@?$FLsimple?$FN?5@		; `string'
PUBLIC	??_C@_0L@KAOEKGBK@?$FLcomplex?$FN?5@		; `string'
PUBLIC	??_C@_0M@FCFPOKLD@?$FLsequence?$FN?5@		; `string'
PUBLIC	??_C@_09EKOOBNCK@?$FLchoice?$FN?5@		; `string'
PUBLIC	??_C@_06FMDLAKIF@?$FLall?$FN?5@			; `string'
PUBLIC	??_C@_05CJJADIIB@?$FLur?$FN?5@			; `string'
PUBLIC	??_C@_0P@CHAMEEEB@?$FLrestriction?$FN?5@	; `string'
PUBLIC	??_C@_0N@FOPKHEI@?$FLextension?$FN?5@		; `string'
PUBLIC	??_C@_0BD@MFKKFECO@?$FLunknown?5type?5?$CFd?$FN?5@ ; `string'
PUBLIC	??_C@_09FOCHAENE@content?3?5@			; `string'
PUBLIC	??_C@_0L@IFGHBDON@?$FLunknown?$FN?5@		; `string'
PUBLIC	??_C@_08HLDMIKJJ@?$FLempty?$FN?5@		; `string'
PUBLIC	??_C@_0L@FLJCNDEC@?$FLelement?$FN?5@		; `string'
PUBLIC	??_C@_08EPDGAGCC@?$FLmixed?$FN?5@		; `string'
PUBLIC	??_C@_06EBDMPOEI@?$FLany?$FN?5@			; `string'
PUBLIC	??_C@_0BC@HMAJHNML@?5?5base?5type?3?5?8?$CFs?8@	; `string'
PUBLIC	??_C@_09IHAEEDOH@?5ns?5?8?$CFs?8?6@		; `string'
PUBLIC	??_C@_0P@IDICKHMO@Schemas?3?5NULL?6@		; `string'
PUBLIC	??_C@_09CEPCMGAA@Schemas?3?5@			; `string'
PUBLIC	??_C@_04ONKFDMMC@?$CFs?0?5@			; `string'
PUBLIC	??_C@_09HIFPELMF@no?5name?0?5@			; `string'
PUBLIC	??_C@_0BE@HFGDBOPE@no?5target?5namespace@	; `string'
PUBLIC	??_C@_0P@HKPLIAHO@add?5annotation@		; `string'
PUBLIC	??_C@_0BF@IGICPFC@allocating?5attribute@	; `string'
PUBLIC	??_C@_0BN@DCKEMFJK@allocating?5redefinition?5info@ ; `string'
PUBLIC	??_C@_0BL@LFEIBOLE@allocating?5attribute?5group@ ; `string'
PUBLIC	??_C@_0BD@OFNGJBCE@allocating?5element@		; `string'
PUBLIC	??_C@_0BA@BHDLCLLG@allocating?5type@		; `string'
PUBLIC	??_C@_0CA@BENLLJIB@allocating?5QName?5reference?5item@ ; `string'
PUBLIC	??_C@_0CF@BKCCIOBM@allocating?5attribute?5use?5prohib@ ; `string'
PUBLIC	??_C@_0CB@MIJFJDPK@allocating?5model?5group?5componen@ ; `string'
PUBLIC	??_C@_0BO@IIFFCFND@allocating?5particle?5component@ ; `string'
PUBLIC	??_C@_0N@MMNEFFIM@adding?5group@		; `string'
PUBLIC	??_C@_0CH@KLLMMGAA@creating?5wildcard?5namespace?5con@ ; `string'
PUBLIC	??_C@_0CN@LEONOKAC@allocating?5an?5identity?9constrai@ ; `string'
PUBLIC	??_C@_0BA@CIBAJGPC@adding?5wildcard@		; `string'
PUBLIC	??_C@_0CK@NKPACKCN@allocating?5a?5substitution?5group@ ; `string'
PUBLIC	??_C@_0CL@JADHFAI@failed?5to?5add?5a?5new?5substitutio@ ; `string'
PUBLIC	??_C@_0BH@CHMIFAPN@xmlSchemaSubstGroupAdd@	; `string'
PUBLIC	??_C@_0FN@NHMNMJGI@The?5value?5?8?$CFs?8?5of?5simple?5type?5?8@ ; `string'
PUBLIC	??_C@_0CM@OMFMFEA@Duplicate?5value?5?8?$CFs?8?5of?5simple?5@ ; `string'
PUBLIC	??_C@_0EB@BMJNLDB@The?5value?5?8?$CFs?8?5of?5simple?5type?5?8@ ; `string'
PUBLIC	??_C@_09OBPGLENH@maxOccurs@			; `string'
PUBLIC	??_C@_09PBKAIKML@unbounded@			; `string'
PUBLIC	??_C@_09OAPKCOGD@minOccurs@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_0CG@JADIGFME@the?5given?5type?5is?5not?5a?5built?9i@ ; `string'
PUBLIC	??_C@_0BL@CNLGMFJP@xmlSchemaPValAttrNodeValue@	; `string'
PUBLIC	??_C@_0EI@OLDONBHK@validation?5using?5the?5given?5type@ ; `string'
PUBLIC	??_C@_0CM@DLDNHDND@failed?5to?5validate?5a?5schema?5att@ ; `string'
PUBLIC	??_C@_0FA@OJBBBDML@Internal?5error?3?5xmlSchemaPValAt@ ; `string'
PUBLIC	??_C@_0HG@LIIBNHFM@References?5from?5this?5schema?5to?5@ ; `string'
PUBLIC	??_C@_0HM@PFGFDKAG@References?5from?5this?5schema?5to?5@ ; `string'
PUBLIC	??_C@_09HGIEBAJ@attribute@			; `string'
PUBLIC	??_C@_0P@KIDCOMBF@attributeGroup@		; `string'
PUBLIC	??_C@_02EGCJHIOB@id@				; `string'
PUBLIC	??_C@_07IADCAIKP@appinfo@			; `string'
PUBLIC	??_C@_06OEKOLKIL@source@			; `string'
PUBLIC	??_C@_0O@JMIFCMPP@documentation@		; `string'
PUBLIC	??_C@_04IOHABJIC@lang@				; `string'
PUBLIC	??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ ; `string'
PUBLIC	??_C@_0BL@CHHJOIII@?$CIappinfo?5?$HM?5documentation?$CJ?$CK@ ; `string'
PUBLIC	??_C@_0BB@DFGEBGMC@allocating?5facet@		; `string'
PUBLIC	??_C@_05MFEJDJP@value@				; `string'
PUBLIC	??_C@_0BH@LAHCBIKA@Facet?5?$CFs?5has?5no?5value?6@ ; `string'
PUBLIC	??_C@_0N@BDECKIL@minInclusive@			; `string'
PUBLIC	??_C@_0N@MENCPBPO@minExclusive@			; `string'
PUBLIC	??_C@_0N@EBHLFCPN@maxInclusive@			; `string'
PUBLIC	??_C@_0N@IEJNIJII@maxExclusive@			; `string'
PUBLIC	??_C@_0M@PGNNBCIB@totalDigits@			; `string'
PUBLIC	??_C@_0P@EPJLKDGA@fractionDigits@		; `string'
PUBLIC	??_C@_07CHFOACKJ@pattern@			; `string'
PUBLIC	??_C@_0M@FJOIDAAJ@enumeration@			; `string'
PUBLIC	??_C@_0L@CCEMGGFL@whiteSpace@			; `string'
PUBLIC	??_C@_06IJDLPEM@length@				; `string'
PUBLIC	??_C@_09KJHMKBNK@maxLength@			; `string'
PUBLIC	??_C@_09KIHADLGO@minLength@			; `string'
PUBLIC	??_C@_0BH@JGDFLELF@Unknown?5facet?5type?5?$CFs?6@ ; `string'
PUBLIC	??_C@_05OFLEIIDM@fixed@				; `string'
PUBLIC	??_C@_0L@HOGAMHHM@annotation@			; `string'
PUBLIC	??_C@_0CH@KGEOIBLP@Facet?5?$CFs?5has?5unexpected?5child?5c@ ; `string'
PUBLIC	??_C@_0BA@LJOIJHLO@processContents@		; `string'
PUBLIC	??_C@_0BG@JONDLOPH@?$CIstrict?5?$HM?5skip?5?$HM?5lax?$CJ@ ; `string'
PUBLIC	??_C@_09KPMGAFNI@namespace@			; `string'
PUBLIC	??_C@_05HGEKMIOD@?$CD?$CDany@			; `string'
PUBLIC	??_C@_0EK@HAPJOCKP@?$CI?$CI?$CD?$CDany?5?$HM?5?$CD?$CDother?$CJ?5?$HM?5List?5of?5?$CIx@ ; `string'
PUBLIC	??_C@_0BC@NIOKFNAN@?$CD?$CDtargetNamespace@	; `string'
PUBLIC	??_C@_07NOOLJEMO@?$CD?$CDlocal@			; `string'
PUBLIC	??_C@_0CN@HPDJBJNO@The?5value?5must?5be?5greater?5than?5@ ; `string'
PUBLIC	??_C@_0DM@MJPPLMBN@The?5value?5must?5not?5be?5greater?5t@ ; `string'
PUBLIC	??_C@_0CE@BEMOBFLH@?$CIxs?3nonNegativeInteger?5?$HM?5unboun@ ; `string'
PUBLIC	??_C@_0BG@FKFDAFPO@xs?3nonNegativeInteger@	; `string'
PUBLIC	??_C@_0O@MNAJHLGE@?$CIannotation?$DP?$CJ@	; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_0BG@DHBIDCLH@Notation?5has?5no?5name?6@	; `string'
PUBLIC	??_C@_03GCDGINBO@ref@				; `string'
PUBLIC	??_C@_04GPMDFGEJ@type@				; `string'
PUBLIC	??_C@_04MLMMMEIO@form@				; `string'
PUBLIC	??_C@_09NPLHLKJP@qualified@			; `string'
PUBLIC	??_C@_0M@PJKDFPFM@unqualified@			; `string'
PUBLIC	??_C@_0BK@IDHDHMBC@?$CIqualified?5?$HM?5unqualified?$CJ@ ; `string'
PUBLIC	??_C@_03MMGHDJKG@use@				; `string'
PUBLIC	??_C@_08EBGGHLAO@optional@			; `string'
PUBLIC	??_C@_0L@HMNCJOMG@prohibited@			; `string'
PUBLIC	??_C@_08FEMBDDHD@required@			; `string'
PUBLIC	??_C@_0CD@MEKFLEMO@?$CIoptional?5?$HM?5prohibited?5?$HM?5requir@ ; `string'
PUBLIC	??_C@_07DLHCIBDH@default@			; `string'
PUBLIC	??_C@_0FK@JMMMCAKL@The?5value?5of?5the?5attribute?5?8use@ ; `string'
PUBLIC	??_C@_0CJ@KHJHCHGN@The?5target?5namespace?5must?5not?5m@ ; `string'
PUBLIC	??_C@_05PPEFOGKI@xmlns@				; `string'
PUBLIC	??_C@_0DC@IMLKIPJD@The?5value?5of?5the?5attribute?5must@ ; `string'
PUBLIC	??_C@_0FF@PAOOKLLP@Skipping?5attribute?5use?5prohibit@ ; `string'
PUBLIC	??_C@_0FA@EKEFODDF@Skipping?5attribute?5use?5prohibit@ ; `string'
PUBLIC	??_C@_0DC@LIPHNCMP@Skipping?5duplicate?5attribute?5us@ ; `string'
PUBLIC	??_C@_0L@FMMGGLOP@simpleType@			; `string'
PUBLIC	??_C@_0EH@BAMMFMJA@The?5attribute?5?8type?8?5and?5the?5?$DMs@ ; `string'
PUBLIC	??_C@_0BL@LABGHPL@?$CIannotation?$DP?0?5simpleType?$DP?$CJ@ ; `string'
PUBLIC	??_C@_0HE@EDEMIIKM@The?5redefining?5attribute?5group?5@ ; `string'
PUBLIC	??_C@_0N@DDKCLMJG@anyAttribute@			; `string'
PUBLIC	??_C@_0DO@PEEJHPPG@?$CIannotation?$DP?0?5?$CI?$CIattribute?5?$HM?5att@ ; `string'
PUBLIC	??_C@_04LEKDNLLP@?$CDall@			; `string'
PUBLIC	??_C@_09ODADEDNA@extension@			; `string'
PUBLIC	??_C@_0M@FBFLGGFO@restriction@			; `string'
PUBLIC	??_C@_0N@INDADLAA@substitution@			; `string'
PUBLIC	??_C@_04DONFEANM@list@				; `string'
PUBLIC	??_C@_05MNALHJLP@union@				; `string'
PUBLIC	??_C@_0EO@EIAADIEO@Internal?5error?3?5xmlSchemaCheckC@ ; `string'
PUBLIC	??_C@_0DC@LABDBLHI@The?5XPath?5expression?5of?5the?5sel@ ; `string'
PUBLIC	??_C@_0BN@LCFJGAGM@allocating?5a?5namespace?5array@ ; `string'
PUBLIC	??_C@_0DA@MEAKINLE@The?5XPath?5expression?5?8?$CFs?8?5could@ ; `string'
PUBLIC	??_C@_0FF@CNICCNGM@Internal?5error?3?5xmlSchemaAddAnn@ ; `string'
PUBLIC	??_C@_05CNNIIAHK@xpath@				; `string'
PUBLIC	??_C@_0DN@GFJDOCKM@allocating?5a?5?8selector?8?5of?5an?5i@ ; `string'
PUBLIC	??_C@_0GH@EOECGLHE@Internal?5error?3?5xmlSchemaParseI@ ; `string'
PUBLIC	??_C@_05BEFNLAML@refer@				; `string'
PUBLIC	??_C@_0CC@DEBKGIBF@?$CIannotation?$DP?0?5?$CIselector?0?5field?$CL@ ; `string'
PUBLIC	??_C@_0BL@HDFCKCKI@A?5child?5element?5is?5missing@ ; `string'
PUBLIC	??_C@_08DILBKPNJ@selector@			; `string'
PUBLIC	??_C@_05EIBGDMPB@field@				; `string'
PUBLIC	??_C@_0FH@LFNFLK@Only?5the?5attributes?5?8minOccurs?8@ ; `string'
PUBLIC	??_C@_05PIBOEKAB@block@				; `string'
PUBLIC	??_C@_08BNOJCPJE@nillable@			; `string'
PUBLIC	??_C@_05FPBGKCKL@final@				; `string'
PUBLIC	??_C@_08IMFJLGFD@abstract@			; `string'
PUBLIC	??_C@_0BC@CGDMBFF@substitutionGroup@		; `string'
PUBLIC	??_C@_0CL@KNGCEGAB@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@ ; `string'
PUBLIC	??_C@_0DK@DDAOLEFB@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@ ; `string'
PUBLIC	??_C@_0M@OCBEIBDG@complexType@			; `string'
PUBLIC	??_C@_0EI@DDMHFMFF@The?5attribute?5?8type?8?5and?5the?5?$DMc@ ; `string'
PUBLIC	??_C@_06ODCMFGLL@unique@			; `string'
PUBLIC	??_C@_03ICHNJLJF@key@				; `string'
PUBLIC	??_C@_06PLFEIJDE@keyref@			; `string'
PUBLIC	??_C@_0EH@NHLOCELP@?$CIannotation?$DP?0?5?$CI?$CIsimpleType?5?$HM?5co@ ; `string'
PUBLIC	??_C@_0M@OEMIGMAO@memberTypes@			; `string'
PUBLIC	??_C@_0CM@CGPNFFK@xmlSchemaParseUnion?0?5allocating@ ; `string'
PUBLIC	??_C@_0BL@BBOMAGGA@?$CIannotation?$DP?0?5simpleType?$CK?$CJ@ ; `string'
PUBLIC	??_C@_0FG@HHPGDCB@Either?5the?5attribute?5?8memberTyp@ ; `string'
PUBLIC	??_C@_08DLBHENKN@itemType@			; `string'
PUBLIC	??_C@_0EL@LEHAHIHI@The?5attribute?5?8itemType?8?5and?5th@ ; `string'
PUBLIC	??_C@_0EK@BDPJPAFM@Either?5the?5attribute?5?8itemType?8@ ; `string'
PUBLIC	??_C@_0DH@OIPDFCAL@Redefinition?5of?5built?9in?5simple@ ; `string'
PUBLIC	??_C@_0CN@IJLHAKIE@?$CI?$CDall?5?$HM?5List?5of?5?$CIlist?5?$HM?5union?5?$HM@ ; `string'
PUBLIC	??_C@_0CM@MDINDAN@?$CIannotation?$DP?0?5?$CIrestriction?5?$HM?5li@ ; `string'
PUBLIC	??_C@_0EO@JDMIJKLB@This?5is?5a?5redefinition?0?5thus?5th@ ; `string'
PUBLIC	??_C@_03NFKEKGGK@all@				; `string'
PUBLIC	??_C@_06DDDNEJEA@choice@			; `string'
PUBLIC	??_C@_08IBBDGPOF@sequence@			; `string'
PUBLIC	??_C@_0CK@IMPEKNJM@?$CIannotation?$DP?0?5?$CIall?5?$HM?5choice?5?$HM?5s@ ; `string'
PUBLIC	??_C@_0BA@JJLDNFDJ@targetNamespace@		; `string'
PUBLIC	??_C@_0BD@GLAKFDIM@elementFormDefault@		; `string'
PUBLIC	??_C@_0BF@PMHAPIPB@attributeFormDefault@	; `string'
PUBLIC	??_C@_0N@DFGPIJFA@finalDefault@			; `string'
PUBLIC	??_C@_0DK@JHFKOEOC@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@ ; `string'
PUBLIC	??_C@_0N@MMGPPGOC@blockDefault@			; `string'
PUBLIC	??_C@_07FHOHOHLG@include@			; `string'
PUBLIC	??_C@_06EOGGDCGF@import@			; `string'
PUBLIC	??_C@_08HCPHBLGO@redefine@			; `string'
PUBLIC	??_C@_07HCLJNICE@element@			; `string'
PUBLIC	??_C@_05MGJOOGAJ@group@				; `string'
PUBLIC	??_C@_08KNJKBPAF@notation@			; `string'
PUBLIC	??_C@_0JG@PPPAGMJA@?$CI?$CIinclude?5?$HM?5import?5?$HM?5redefine?5?$HM@ ; `string'
PUBLIC	??_C@_0BL@CHFLODC@allocating?5schema?5relation@	; `string'
PUBLIC	??_C@_0CH@HOMALJAM@allocating?5schema?5construction?5@ ; `string'
PUBLIC	??_C@_0CC@KNCAMKIP@allocating?5list?5of?5schema?5bucke@ ; `string'
PUBLIC	??_C@_0CN@MGLOMDJH@allocating?5list?5of?5pending?5glob@ ; `string'
PUBLIC	??_C@_0CB@NCMLFNIB@allocating?5schema?5parser?5contex@ ; `string'
PUBLIC	??_C@_0CI@GJEMMNOJ@failed?5to?5create?5a?5temp?4?5parser@ ; `string'
PUBLIC	??_C@_0BM@OJEBCMPM@xmlSchemaCreatePCtxtOnVCtxt@	; `string'
PUBLIC	??_C@_0BH@IFNOMMON@reparsing?5a?5schema?5doc@	; `string'
PUBLIC	??_C@_0BF@DMMABNCK@xmlSchemaParseNewDoc@	; `string'
PUBLIC	??_C@_0CJ@PEPIDOML@parsing?5a?5schema?5doc?0?5but?5there@ ; `string'
PUBLIC	??_C@_0P@BIPJKJFE@no?5constructor@		; `string'
PUBLIC	??_C@_0DD@JJBMBON@The?5schema?5must?5not?5import?1incl@ ; `string'
PUBLIC	??_C@_0BB@IEONCAEH@in_memory_buffer@		; `string'
PUBLIC	??_C@_0FI@DLHCDBDL@The?5schema?5document?5?8?$CFs?8?5cannot@ ; `string'
PUBLIC	??_C@_0FI@DIIKKJHP@The?5schema?5document?5?8?$CFs?8?5cannot@ ; `string'
PUBLIC	??_C@_0IM@HCCFLAGC@Skipping?5import?5of?5schema?5locat@ ; `string'
PUBLIC	??_C@_0FA@FCNDNFNE@trying?5to?5load?5a?5schema?5doc?0?5bu@ ; `string'
PUBLIC	??_C@_0BG@PEDNHGDB@xmlSchemaAddSchemaDoc@	; `string'
PUBLIC	??_C@_0CN@KMMHPBMO@xmlSchemaGetDoc?0?5allocating?5a?5p@ ; `string'
PUBLIC	??_C@_0CG@MKFNOEJC@Failed?5to?5parse?5the?5XML?5resourc@ ; `string'
PUBLIC	??_C@_0EP@KKBODFED@No?5information?5for?5parsing?5was?5@ ; `string'
PUBLIC	??_C@_0CK@LEAJAMEE@The?5document?5?8?$CFs?8?5has?5no?5docume@ ; `string'
PUBLIC	??_C@_06KICAKOOL@schema@			; `string'
PUBLIC	??_C@_0CP@HFPALNHL@The?5XML?5document?5?8?$CFs?8?5is?5not?5a?5@ ; `string'
PUBLIC	??_C@_0P@DEMHLMFE@schemaLocation@		; `string'
PUBLIC	??_C@_0GI@OLOMMMCB@The?5value?5of?5the?5attribute?5?8nam@ ; `string'
PUBLIC	??_C@_0FL@GDFMFMFB@The?5attribute?5?8namespace?8?5must?5@ ; `string'
PUBLIC	??_C@_0EA@NKOOPGEC@Failed?5to?5locate?5a?5schema?5at?5lo@ ; `string'
PUBLIC	??_C@_0CP@EKIECFJN@could?5not?5build?5an?5URI?5from?5the@ ; `string'
PUBLIC	??_C@_0CA@NKMDDHKI@xmlSchemaParseIncludeOrRedefine@ ; `string'
PUBLIC	??_C@_0DB@IGEPJIPN@The?5schema?5document?5?8?$CFs?8?5cannot@ ; `string'
PUBLIC	??_C@_0DA@JGHKIBFN@The?5schema?5document?5?8?$CFs?8?5cannot@ ; `string'
PUBLIC	??_C@_0CP@PKPHBKIC@Failed?5to?5load?5the?5document?5?8?$CFs@ ; `string'
PUBLIC	??_C@_0DC@DJHEKCBE@Failed?5to?5load?5the?5document?5?8?$CFs@ ; `string'
PUBLIC	??_C@_0IL@MIGJBHGC@The?5target?5namespace?5of?5the?5inc@ ; `string'
PUBLIC	??_C@_0HF@NFPCCAHE@The?5target?5namespace?5?8?$CFs?8?5of?5th@ ; `string'
PUBLIC	??_C@_0EE@OHBEFOEM@?$CIannotation?5?$HM?5?$CIsimpleType?5?$HM?5com@ ; `string'
PUBLIC	??_C@_07OCHOELKN@?$CI0?5?$HM?51?$CJ@		; `string'
PUBLIC	??_C@_0CN@GPAMDNEI@Invalid?5value?5for?5minOccurs?5?$CImu@ ; `string'
PUBLIC	??_C@_0CN@JOJFLDM@Invalid?5value?5for?5maxOccurs?5?$CImu@ ; `string'
PUBLIC	??_C@_0CG@DCDFMCOM@?$CIannotation?$DP?0?5?$CIannotation?$DP?0?5ele@ ; `string'
PUBLIC	??_C@_03OBJFJEBA@any@				; `string'
PUBLIC	??_C@_0HA@PEPECPEK@The?5redefining?5model?5group?5defi@ ; `string'
PUBLIC	??_C@_0IM@HPEJBILG@The?5redefining?5model?5group?5defi@ ; `string'
PUBLIC	??_C@_0DM@EMLAMPJB@?$CIannotation?$DP?0?5?$CIelement?5?$HM?5group?5@ ; `string'
PUBLIC	??_C@_04BHIIPFEC@base@				; `string'
PUBLIC	??_C@_0HE@HDNCABHM@This?5is?5a?5redefinition?0?5but?5the@ ; `string'
PUBLIC	??_C@_0EH@NLLIFAIL@The?5attribute?5?8base?8?5and?5the?5?$DMs@ ; `string'
PUBLIC	??_C@_0EE@KBNCPLAN@Either?5the?5attribute?5?8base?8?5or?5@ ; `string'
PUBLIC	??_C@_0BI@BKMOEBCP@allocating?5a?5facet?5link@	; `string'
PUBLIC	??_C@_0GB@CPHLEAHN@annotation?$DP?0?5?$CIgroup?5?$HM?5all?5?$HM?5cho@ ; `string'
PUBLIC	??_C@_0PB@MMDBBLJD@?$CIannotation?$DP?0?5?$CIsimpleType?$DP?0?5?$CImi@ ; `string'
PUBLIC	??_C@_0MA@MDLOJGLL@?$CIannotation?$DP?0?5?$CIsimpleType?$DP?0?5?$CImi@ ; `string'
PUBLIC	??_C@_0GE@NILNJLFH@?$CIannotation?$DP?0?5?$CI?$CIgroup?5?$HM?5all?5?$HM?5c@ ; `string'
PUBLIC	??_C@_0CJ@BJCOBFBF@?$CIannotation?$DP?0?5?$CIrestriction?5?$HM?5ex@ ; `string'
PUBLIC	??_C@_05IPHDHIPP@mixed@				; `string'
PUBLIC	??_C@_0CM@OCCOHGHC@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@ ; `string'
PUBLIC	??_C@_0O@EFHOFDNO@simpleContent@		; `string'
PUBLIC	??_C@_0P@LGKPFEB@complexContent@		; `string'
PUBLIC	??_C@_0IH@OBLFEMHP@?$CIannotation?$DP?0?5?$CIsimpleContent?5?$HM?5@ ; `string'
PUBLIC	??_C@_0GE@BCLPNLHN@This?5is?5a?5redefinition?0?5thus?5th@ ; `string'
PUBLIC	??_C@_0HK@IHMHBPHC@Internal?5error?3?5xmlSchemaBuildC@ ; `string'
PUBLIC	??_C@_0BB@IKBLLFGH@particle?5is?5NULL@		; `string'
PUBLIC	??_C@_0BM@HHPDPMCK@xmlSchemaBuildAContentModel@	; `string'
PUBLIC	??_C@_0BP@LJGCIBKB@?$DMelement?$DO?5particle?5has?5no?5term@ ; `string'
PUBLIC	??_C@_0DE@JHALJFOD@found?5unexpected?5term?5of?5type?5?8@ ; `string'
PUBLIC	??_C@_0CM@ONMINIGJ@Cannot?5create?5automata?5for?5comp@ ; `string'
PUBLIC	??_C@_0CE@GNJHIDLA@Failed?5to?5compile?5the?5content?5m@ ; `string'
PUBLIC	??_C@_0CF@FHONPKDJ@The?5content?5model?5is?5not?5determ@ ; `string'
PUBLIC	??_C@_0BA@LIFKLDKP@type?5definition@		; `string'
PUBLIC	??_C@_0BH@ENHIIAOL@allocating?5a?5type?5link@	; `string'
PUBLIC	??_C@_0CO@HFHAKEB@The?5union?5of?5the?5wilcard?5is?5not@ ; `string'
PUBLIC	??_C@_0DF@DJLMCEFH@The?5intersection?5of?5the?5wilcard@ ; `string'
PUBLIC	??_C@_09KLOJBFOH@redefined@			; `string'
PUBLIC	??_C@_0GK@JGCEGOAB@The?5?8optional?8?5attribute?5use?5is@ ; `string'
PUBLIC	??_C@_0HK@BBMHJBAP@The?5attribute?5declaration?8s?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0GI@OJPOJNKC@The?5effective?5value?5constraint?5@ ; `string'
PUBLIC	??_C@_0EO@EJIDKJHC@Neither?5a?5matching?5attribute?5us@ ; `string'
PUBLIC	??_C@_0EH@JCFCIHDB@A?5matching?5attribute?5use?5for?5th@ ; `string'
PUBLIC	??_C@_0EH@LKDIOLEM@The?5?$CFs?5has?5an?5attribute?5wildcar@ ; `string'
PUBLIC	??_C@_0EP@KINLKDD@The?5attribute?5wildcard?5is?5not?5a@ ; `string'
PUBLIC	??_C@_0FK@HDNJNNIO@The?5?$HLprocess?5contents?$HN?5of?5the?5a@ ; `string'
PUBLIC	??_C@_0N@OMCNPMDL@no?5base?5type@		; `string'
PUBLIC	??_C@_0CA@OFHPNPHI@xmlSchemaFixupTypeAttributeUses@ ; `string'
PUBLIC	??_C@_0BM@FJOPIFJN@failed?5to?5expand?5attributes@ ; `string'
PUBLIC	??_C@_0BL@KGAFCIDP@The?5definition?5is?5circular@ ; `string'
PUBLIC	??_C@_0CG@FDHFJMFM@The?5union?5type?5definition?5is?5ci@ ; `string'
PUBLIC	??_C@_0FM@NJGNMMEM@The?5particle?8s?5?$HLmax?5occurs?$HN?5mus@ ; `string'
PUBLIC	??_C@_0BG@PPOHGOMN@No?5base?5type?5existent@	; `string'
PUBLIC	??_C@_0CI@BABCEAKF@The?5base?5type?5?8?$CFs?8?5is?5not?5a?5sim@ ; `string'
PUBLIC	??_C@_0GB@OJPAIDNO@A?5type?0?5derived?5by?5list?5or?5unio@ ; `string'
PUBLIC	??_C@_0BG@NAEJKMEI@The?5variety?5is?5absent@	; `string'
PUBLIC	??_C@_0EB@JOOLHCHD@The?5?8final?8?5of?5its?5base?5type?5?8?$CF@ ; `string'
PUBLIC	??_C@_0CM@LMHOOJIC@given?5type?5is?5not?5a?5user?9derive@ ; `string'
PUBLIC	??_C@_0BN@JGCJPHDI@xmlSchemaCheckCOSSTRestricts@ ; `string'
PUBLIC	??_C@_0DA@BHMFPHHO@The?5base?5type?5?8?$CFs?8?5is?5not?5an?5at@ ; `string'
PUBLIC	??_C@_0DP@KJOCHNDL@The?5final?5of?5its?5base?5type?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_0BN@KLLNOLEJ@failed?5to?5get?5primitive?5type@ ; `string'
PUBLIC	??_C@_0CB@HJDIBIBN@failed?5to?5evaluate?5the?5item?5typ@ ; `string'
PUBLIC	??_C@_0DO@CNOGHMHL@The?5item?5type?5?8?$CFs?8?5does?5not?5hav@ ; `string'
PUBLIC	??_C@_0FI@NONGNEND@The?5item?5type?5is?5a?5union?5type?0?5@ ; `string'
PUBLIC	??_C@_0DI@HJPNFIBB@The?5final?5of?5its?5item?5type?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_0CH@GNOCMONM@The?5base?5type?5?8?$CFs?8?5must?5be?5a?5li@ ; `string'
PUBLIC	??_C@_0EB@DKPMMCLA@The?5?8final?8?5of?5the?5base?5type?5?8?$CF@ ; `string'
PUBLIC	??_C@_0CM@CKGJJDPM@failed?5to?5eval?5the?5item?5type?5of@ ; `string'
PUBLIC	??_C@_0FI@JBMOEDMD@The?5item?5type?5?8?$CFs?8?5is?5not?5valid@ ; `string'
PUBLIC	??_C@_0DL@JIAIGPPB@The?5member?5type?5?8?$CFs?8?5is?5neither@ ; `string'
PUBLIC	??_C@_0DB@GMGLNPMG@The?5?8final?8?5of?5member?5type?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_0BC@LHNABEDG@No?5facets?5allowed@		; `string'
PUBLIC	??_C@_0CH@MIGLCPEH@The?5base?5type?5?8?$CFs?8?5is?5not?5a?5uni@ ; `string'
PUBLIC	??_C@_0CJ@HOHKAHOI@different?5number?5of?5member?5type@ ; `string'
PUBLIC	??_C@_0GE@MIEEABNE@The?5member?5type?5?$CFs?5is?5not?5valid@ ; `string'
PUBLIC	??_C@_0FL@FMHFMMBK@Internal?5error?3?5xmlSchemaCreate@ ; `string'
PUBLIC	??_C@_0IM@DDPGDFGG@For?5a?5string?5to?5be?5a?5valid?5defa@ ; `string'
PUBLIC	??_C@_0CH@HOPMNJDI@calling?5xmlSchemaVCheckCVCSimpl@ ; `string'
PUBLIC	??_C@_0CD@MOGOJILI@xmlSchemaParseCheckCOSValidDefa@ ; `string'
PUBLIC	??_C@_0EN@DHFNNJDJ@If?5the?5base?5type?5is?5a?5simple?5ty@ ; `string'
PUBLIC	??_C@_0N@NMANGDLF@Duplicate?5?$CFs@		; `string'
PUBLIC	??_C@_0IE@LIFNGLDM@There?5must?5not?5exist?5more?5than?5@ ; `string'
PUBLIC	??_C@_0DN@CKGKOKMC@The?5?8final?8?5of?5the?5base?5type?5de@ ; `string'
PUBLIC	??_C@_0CJ@LMFNPNPH@The?5content?5type?5must?5specify?5a@ ; `string'
PUBLIC	??_C@_0FM@GPKINKDA@The?5content?5type?5of?5both?0?5the?5t@ ; `string'
PUBLIC	??_C@_0CO@EGFIFAEL@The?5content?5type?5must?5be?5the?5si@ ; `string'
PUBLIC	??_C@_0CF@JAJFEDFA@The?5base?5type?5must?5be?5a?5complex@ ; `string'
PUBLIC	??_C@_0DP@BNGFOOBI@The?5?8final?8?5of?5the?5base?5type?5de@ ; `string'
PUBLIC	??_C@_0FE@IHCAKODH@The?5?$HLcontent?5type?$HN?5?$CFs?5is?5not?5va@ ; `string'
PUBLIC	??_C@_0GE@JDFDINMM@The?5content?5type?5of?5the?5base?5ty@ ; `string'
PUBLIC	??_C@_0HB@BKHGHMKG@The?5content?5type?5of?5the?5base?5ty@ ; `string'
PUBLIC	??_C@_0FM@PFEADGDA@If?5the?5content?5type?5is?5?8mixed?8?0@ ; `string'
PUBLIC	??_C@_0DF@LCGEMILI@The?5type?5is?5not?5a?5valid?5restric@ ; `string'
PUBLIC	??_C@_0GP@CNIJIED@If?5using?5?$DMcomplexContent?$DO?0?5the?5@ ; `string'
PUBLIC	??_C@_0HG@OCMJPANJ@If?5using?5?$DMsimpleContent?$DO?5and?5?$DMr@ ; `string'
PUBLIC	??_C@_0EJ@MGOOHGBI@Internal?5error?3?5xmlSchemaCheckS@ ; `string'
PUBLIC	??_C@_0IE@LDPFNCJG@A?5?$DMsimpleType?$DO?5is?5expected?5amon@ ; `string'
PUBLIC	??_C@_0LD@GJIEKEIE@If?5?$DMsimpleContent?$DO?5and?5?$DMrestric@ ; `string'
PUBLIC	??_C@_0HG@CLNEKDGF@If?5?$DMsimpleContent?$DO?5and?5?$DMextensi@ ; `string'
PUBLIC	??_C@_0M@HCGPHKGF@?8?5has?5to?5be@		; `string'
PUBLIC	??_C@_09BFLDGAFJ@?5equal?5to@			; `string'
PUBLIC	??_C@_0O@EOMDOOFG@?5greater?5than@		; `string'
PUBLIC	??_C@_0L@HHJDMGPP@?5less?5than@			; `string'
PUBLIC	??_C@_0N@LGLLBNBD@?5or?5equal?5to@		; `string'
PUBLIC	??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@	; `string'
PUBLIC	??_C@_0HG@KJDGAKFE@It?5is?5an?5error?5for?5both?5?8length@ ; `string'
PUBLIC	??_C@_0FC@EFACGABJ@It?5is?5an?5error?5for?5both?5?8?$CFs?8?5an@ ; `string'
PUBLIC	??_C@_0EB@JECLPMKG@The?5base?5type?8s?5facet?5is?5?8fixed@ ; `string'
PUBLIC	??_C@_0GD@BCLDHCAD@The?5?8whitespace?8?5value?5has?5to?5b@ ; `string'
PUBLIC	??_C@_0CH@NFDGHLNP@deriving?5facets?0?5creating?5a?5fac@ ; `string'
PUBLIC	??_C@_0BC@JHOAJLMF@an?5error?5occurred@		; `string'
PUBLIC	??_C@_0CB@LPIBFCGM@xmlSchemaDeriveAndValidateFacet@ ; `string'
PUBLIC	??_C@_0CE@OOLPDECC@list?5type?5has?5no?5item?9type?5assi@ ; `string'
PUBLIC	??_C@_0CB@LJIHOMAE@xmlSchemaFixupSimpleTypeStageOn@ ; `string'
PUBLIC	??_C@_0CI@HMJDLBFH@union?5type?5has?5no?5member?9types?5@ ; `string'
PUBLIC	??_C@_0BP@EGJFJLNK@type?5has?5no?5base?9type?5assigned@ ; `string'
PUBLIC	??_C@_0BB@DAFLJMHA@missing?5baseType@		; `string'
PUBLIC	??_C@_0CB@NHIHEMOP@xmlSchemaFixupSimpleTypeStageTw@ ; `string'
PUBLIC	??_C@_0BK@JMGNNAEE@xmlSchemaFixupComplexType@	; `string'
PUBLIC	??_C@_0KG@MFOLBCHA@Internal?5error?3?5xmlSchemaTypeFi@ ; `string'
PUBLIC	??_C@_0IB@IICIOIAO@Internal?5error?3?5xmlSchemaTypeFi@ ; `string'
PUBLIC	??_C@_0GG@NFAALECG@Internal?5error?3?5xmlSchemaTypeFi@ ; `string'
PUBLIC	??_C@_0BAF@GMDKHDD@The?5type?5has?5an?5?8all?8?5model?5gro@ ; `string'
PUBLIC	??_C@_0BAD@EONAGGAE@A?5type?5cannot?5be?5derived?5by?5ext@ ; `string'
PUBLIC	??_C@_0CF@EHENJODP@this?5function?5needs?5a?5parser?5co@ ; `string'
PUBLIC	??_C@_0BD@JIKEDLJK@xmlSchemaTypeFixup@		; `string'
PUBLIC	??_C@_0CK@KJAODNIP@a?5type?5user?5derived?5type?5has?5no@ ; `string'
PUBLIC	??_C@_0BE@GOHHCECA@xmlSchemaCheckFacet@		; `string'
PUBLIC	??_C@_0GP@JDEDDDKD@Internal?5error?3?5xmlSchemaCheckF@ ; `string'
PUBLIC	??_C@_0EJ@BAMFGHGG@The?5value?5?8?$CFs?8?5of?5the?5facet?5doe@ ; `string'
PUBLIC	??_C@_0BH@DKKABPAP@value?5was?5not?5computed@	; `string'
PUBLIC	??_C@_0EI@FMIFFGFN@The?5value?5?8?$CFs?8?5of?5the?5facet?5?8pa@ ; `string'
PUBLIC	??_C@_0BH@ODKMLHFB@validating?5facet?5value@	; `string'
PUBLIC	??_C@_0BD@IEOLADAC@nonNegativeInteger@		; `string'
PUBLIC	??_C@_0BA@PNFEGAHG@positiveInteger@		; `string'
PUBLIC	??_C@_0DF@HPIINFD@The?5value?5?8?$CFs?8?5of?5the?5facet?5?8?$CFs@ ; `string'
PUBLIC	??_C@_08ILAKLJGO@preserve@			; `string'
PUBLIC	??_C@_07CLEHDIEJ@replace@			; `string'
PUBLIC	??_C@_08MHKDLKBN@collapse@			; `string'
PUBLIC	??_C@_0DG@BFJCEJH@The?5value?5?8?$CFs?8?5of?5the?5facet?5?8wh@ ; `string'
PUBLIC	??_C@_0DO@EEBKKJHN@Circular?5reference?5to?5the?5model@ ; `string'
PUBLIC	??_C@_0DH@FDECNJHO@Circular?5reference?5to?5the?5attri@ ; `string'
PUBLIC	??_C@_0CC@JIEJECEC@unexpected?5attr?5prohibition?5fou@ ; `string'
PUBLIC	??_C@_0CC@NLBCMGHN@xmlSchemaExpandAttributeGroupRe@ ; `string'
PUBLIC	??_C@_0HN@PJGMJAIH@Skipping?5pointless?5attribute?5us@ ; `string'
PUBLIC	??_C@_0FF@JBDCKHFC@Value?5constraints?5are?5not?5allow@ ; `string'
PUBLIC	??_C@_0BP@KEKKKHHB@xmlSchemaCheckAttrPropsCorrect@ ; `string'
PUBLIC	??_C@_0CP@DMDDKJIO@The?5value?5of?5the?5value?5constrai@ ; `string'
PUBLIC	??_C@_0EL@CIIJKFO@Only?5global?5element?5declaration@ ; `string'
PUBLIC	??_C@_0FP@ECMLFAOK@The?5element?5declaration?5?8?$CFs?8?5de@ ; `string'
PUBLIC	??_C@_0IO@OBKDAHJI@The?5type?5definition?5?8?$CFs?8?5was?5ei@ ; `string'
PUBLIC	??_C@_0JP@GPCAONIJ@The?5type?5definition?5?$CIor?5type?5de@ ; `string'
PUBLIC	??_C@_0GP@ONEJGEGK@Internal?5error?3?5xmlSchemaCheckE@ ; `string'
PUBLIC	??_C@_0EC@IFGBKADH@failed?5to?5validate?5the?5value?5co@ ; `string'
PUBLIC	??_C@_0BM@INOHADNA@xmlSchemaElemCheckValConstr@	; `string'
PUBLIC	??_C@_0HI@HIFFMALD@A?5model?5group?5definition?5is?5ref@ ; `string'
PUBLIC	??_C@_0HM@EHFKHNMB@The?5attribute?5declaration?5has?5a@ ; `string'
PUBLIC	??_C@_0CC@FBIHIMFL@xmlSchemaCheckAttrUsePropsCorre@ ; `string'
PUBLIC	??_C@_0GP@GLBEFPEK@The?5?8fixed?8?5value?5constraint?5of@ ; `string'
PUBLIC	??_C@_0BP@JCIFOLN@The?5keyref?5references?5a?5keyref@ ; `string'
PUBLIC	??_C@_0FN@FJLAHNCH@The?5cardinality?5of?5the?5keyref?5d@ ; `string'
PUBLIC	??_C@_0EH@DMAILEC@The?5?$CFs?5?8?$CFs?8?5to?5be?5redefined?5cou@ ; `string'
PUBLIC	??_C@_0CE@NJALEOMP@Unexpected?5redefined?5component?5@ ; `string'
PUBLIC	??_C@_0CA@MJPJGEAA@xmlSchemaResolveRedefReferences@ ; `string'
PUBLIC	??_C@_0GG@OLGKEPPA@The?5referenced?5?$CFs?5was?5already?5r@ ; `string'
PUBLIC	??_C@_0CB@EHOCOMPJ@Unexpected?5global?5component?5typ@ ; `string'
PUBLIC	??_C@_0BH@KEIDDOOE@xmlSchemaAddComponents@	; `string'
PUBLIC	??_C@_0CI@HOKAKPAF@failed?5to?5create?5a?5component?5ha@ ; `string'
PUBLIC	??_C@_0CE@NEPGNBMH@A?5global?5?$CFs?5?8?$CFs?8?5does?5already?5e@ ; `string'
PUBLIC	??_C@_0DC@HKCNLJOG@Failed?5to?5locate?5the?5main?5schem@ ; `string'
PUBLIC	??_C@_0CK@PCIDMOBP@Failed?5to?5locate?5the?5main?5schem@ ; `string'
PUBLIC	??_C@_0BL@KBEKBABO@An?5internal?5error?5occurred@ ; `string'
PUBLIC	??_C@_0P@FJHIALID@xmlSchemaParse@		; `string'
PUBLIC	??_C@_0P@DAONFGNJ@Internal?5Error@		; `string'
PUBLIC	??_C@_0BM@JLNHNHFO@no?5parser?5context?5available@ ; `string'
PUBLIC	??_C@_0BM@IPNOOOA@xmlSchemaAssembleByLocation@	; `string'
PUBLIC	??_C@_0DE@OFHLHGBG@The?5document?5at?5location?5?8?$CFs?8?5c@ ; `string'
PUBLIC	??_C@_0FD@KDOLAGPK@The?5value?5must?5consist?5of?5tuple@ ; `string'
PUBLIC	??_C@_0BE@HNFEMNKO@assembling?5schemata@	; `string'
PUBLIC	??_C@_0BH@DHODCNOI@xmlSchemaAssembleByXSI@	; `string'
PUBLIC	??_C@_0CA@LAIFBHAE@no?5node?5or?5node?8s?5doc?5avaliable@ ; `string'
PUBLIC	??_C@_0BJ@NLHBOILD@xmlSchemaLookupNamespace@	; `string'
PUBLIC	??_C@_0CN@LAHJCGKC@a?5schema?5is?5needed?5on?5the?5valid@ ; `string'
PUBLIC	??_C@_0BK@IMJIJGNM@xmlSchemaValidateNotation@	; `string'
PUBLIC	??_C@_0DM@CAHAFNJE@xmlSchemaAugmentIDC?3?5allocating@ ; `string'
PUBLIC	??_C@_0CD@HDBDLPGB@allocating?5a?5PSVI?5IDC?5binding?5i@ ; `string'
PUBLIC	??_C@_0CI@MOGKDPMG@allocating?5the?5IDC?5node?5table?5i@ ; `string'
PUBLIC	??_C@_0CL@PFEMPGNK@re?9allocating?5the?5IDC?5node?5tabl@ ; `string'
PUBLIC	??_C@_0CE@CCLJMNGF@allocating?5the?5IDC?5key?5storage?5@ ; `string'
PUBLIC	??_C@_0CH@OEOHKDEB@re?9allocating?5the?5IDC?5key?5stora@ ; `string'
PUBLIC	??_C@_0CM@BBNGODJA@allocating?5an?5array?5of?5IDC?5node@ ; `string'
PUBLIC	??_C@_0CP@OHLCMMHI@re?9allocating?5an?5array?5of?5IDC?5n@ ; `string'
PUBLIC	??_C@_0BP@KMMMKNDG@allocating?5an?5IDC?5state?5object@ ; `string'
PUBLIC	??_C@_0CN@MKAMKJFE@failed?5to?5create?5an?5XPath?5valid@ ; `string'
PUBLIC	??_C@_0BL@EMBGPHEI@xmlSchemaIDCAddStateObject@	; `string'
PUBLIC	??_C@_0BI@EPLNDPKO@calling?5xmlStreamPush?$CI?$CJ@ ; `string'
PUBLIC	??_C@_0BH@BGCDIJOO@xmlSchemaXPathEvaluate@	; `string'
PUBLIC	??_C@_0CE@OEKMEEHF@allocating?5the?5state?5object?5his@ ; `string'
PUBLIC	??_C@_0CH@CCPCCKFB@re?9allocating?5the?5state?5object?5@ ; `string'
PUBLIC	??_C@_0CE@HGOJGLAG@failed?5to?5compute?5a?5canonical?5v@ ; `string'
PUBLIC	??_C@_0BO@COPGMMIK@xmlSchemaFormatIDCKeySequence@ ; `string'
PUBLIC	??_C@_03BBKEAIF@?$DP?$DP?$DP@			; `string'
PUBLIC	??_C@_01LBDDMOBJ@?$FN@				; `string'
PUBLIC	??_C@_0BH@HBBLPIID@calling?5xmlStreamPop?$CI?$CJ@ ; `string'
PUBLIC	??_C@_0BN@CBHGMMP@xmlSchemaXPathProcessHistory@	; `string'
PUBLIC	??_C@_0FD@MADPFADD@field?5resolves?5to?5a?5CT?5with?5sim@ ; `string'
PUBLIC	??_C@_0EL@FLEKOJFE@The?5XPath?5?8?$CFs?8?5of?5a?5field?5of?5?$CFs@ ; `string'
PUBLIC	??_C@_0GD@IKFFNPGA@Warning?3?5No?5precomputed?5value?5a@ ; `string'
PUBLIC	??_C@_0CF@MLBGNEED@allocating?5an?5array?5of?5key?9sequ@ ; `string'
PUBLIC	??_C@_0CH@LFFCCCHC@reallocating?5an?5array?5of?5key?9se@ ; `string'
PUBLIC	??_C@_0FC@LNIGGAMO@The?5XPath?5?8?$CFs?8?5of?5a?5field?5of?5?$CFs@ ; `string'
PUBLIC	??_C@_0BP@BFFMOABM@allocating?5an?5IDC?5key?9sequence@ ; `string'
PUBLIC	??_C@_0BF@DNPMHACD@allocating?5a?5IDC?5key@	; `string'
PUBLIC	??_C@_0CA@LMIOLKEE@Duplicate?5key?9sequence?5?$CFs?5in?5?$CFs@ ; `string'
PUBLIC	??_C@_0CC@HMFENHHC@allocating?5an?5IDC?5node?9table?5it@ ; `string'
PUBLIC	??_C@_0CI@LOGANEIF@Not?5all?5fields?5of?5?$CFs?5evaluate?5t@ ; `string'
PUBLIC	??_C@_0DM@JEDCDBII@The?5state?5object?5to?5be?5removed?5@ ; `string'
PUBLIC	??_C@_0DC@BCHPJJHO@The?5chain?5of?5IDC?5matchers?5is?5ex@ ; `string'
PUBLIC	??_C@_0BN@FHFHOILP@xmlSchemaIDCRegisterMatchers@ ; `string'
PUBLIC	??_C@_0DL@HKBGOKJP@Could?5not?5find?5an?5augmented?5IDC@ ; `string'
PUBLIC	??_C@_0BK@INNNDFEE@allocating?5an?5IDC?5matcher@ ; `string'
PUBLIC	??_C@_0CI@JFHKHDCD@allocating?5IDC?5list?5of?5node?9tab@ ; `string'
PUBLIC	??_C@_0CL@KOFMLKDP@re?9allocating?5IDC?5list?5of?5node?9@ ; `string'
PUBLIC	??_C@_0DN@GJPPLNCJ@More?5than?5one?5match?5found?5for?5k@ ; `string'
PUBLIC	??_C@_0DC@DKEGLJJH@No?5match?5found?5for?5key?9sequence@ ; `string'
PUBLIC	??_C@_0BP@IEFJMMAN@allocating?5attribute?5info?5list@ ; `string'
PUBLIC	??_C@_0CC@BAMAMEME@re?9allocating?5attribute?5info?5li@ ; `string'
PUBLIC	??_C@_0BG@PFNFPHPM@attr?5info?5not?5cleared@	; `string'
PUBLIC	??_C@_0BK@LKOCBHBB@xmlSchemaGetFreshAttrInfo@	; `string'
PUBLIC	??_C@_0BM@BOOKJCLG@creating?5new?5attribute?5info@ ; `string'
PUBLIC	??_C@_0CE@JCDDMGJO@calling?5xmlSchemaGetFreshAttrIn@ ; `string'
PUBLIC	??_C@_0BH@MIDCNBN@xmlSchemaPushAttribute@	; `string'
PUBLIC	??_C@_03ILAMHENH@nil@				; `string'
PUBLIC	??_C@_0BK@PJGHNDDL@noNamespaceSchemaLocation@	; `string'
PUBLIC	??_C@_0BP@KBPFIFIK@inconsistent?5depth?5encountered@ ; `string'
PUBLIC	??_C@_0BK@HLHJELLH@xmlSchemaGetFreshElemInfo@	; `string'
PUBLIC	??_C@_0CC@CMDKBIBJ@allocating?5the?5element?5info?5arr@ ; `string'
PUBLIC	??_C@_0CF@PDEOBEKK@re?9allocating?5the?5element?5info?5@ ; `string'
PUBLIC	??_C@_0BL@LLLHNEDD@allocating?5an?5element?5info@ ; `string'
PUBLIC	??_C@_0BP@FKKNFHGK@elem?5info?5has?5not?5been?5cleared@ ; `string'
PUBLIC	??_C@_0CH@MOGKKGIH@validating?5against?5a?5atomic?5typ@ ; `string'
PUBLIC	??_C@_0BI@NHJMGMIL@xmlSchemaValidateFacets@	; `string'
PUBLIC	??_C@_0CF@IGJENPFO@validating?5against?5a?5list?5type?5@ ; `string'
PUBLIC	??_C@_0CI@BDJMPJNK@validating?5against?5an?5enumerati@ ; `string'
PUBLIC	??_C@_0CD@GIDABGCK@validating?5against?5a?5pattern?5fa@ ; `string'
PUBLIC	??_C@_0BL@JAPCPOMD@calling?5xmlValidateQName?$CI?$CJ@ ; `string'
PUBLIC	??_C@_0BH@PCDDHFLC@xmlSchemaValidateQName@	; `string'
PUBLIC	??_C@_0EJ@KJCHOIHD@The?5QName?5value?5?8?$CFs?8?5has?5no?5cor@ ; `string'
PUBLIC	??_C@_0CA@NBJHIEJL@could?5not?5get?5the?5built?9in?5type@ ; `string'
PUBLIC	??_C@_0BN@DBANEELH@xmlSchemaVCheckCVCSimpleType@ ; `string'
PUBLIC	??_C@_0CD@GBDHIMIE@validating?5against?5a?5built?9in?5t@ ; `string'
PUBLIC	??_C@_0CI@LPLEHNN@validating?5facets?5of?5atomic?5sim@ ; `string'
PUBLIC	??_C@_0CH@JGMIFPNF@validating?5an?5item?5of?5list?5simp@ ; `string'
PUBLIC	??_C@_0CG@LKPAEBKB@validating?5facets?5of?5list?5simpl@ ; `string'
PUBLIC	??_C@_0CG@NCCHNOHC@union?5simple?5type?5has?5no?5member@ ; `string'
PUBLIC	??_C@_0CI@MOMFK@validating?5members?5of?5union?5sim@ ; `string'
PUBLIC	??_C@_0CH@DGPHKMDI@validating?5facets?5of?5union?5simp@ ; `string'
PUBLIC	??_C@_0EE@GLDMHPJF@calling?5xmlSchemaQNameExpand?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0CG@PKILICAE@xmlSchemaValidateElementByDecla@ ; `string'
PUBLIC	??_C@_0FF@GCDILCEF@The?5QName?5value?5?8?$CFs?8?5of?5the?5xsi@ ; `string'
PUBLIC	??_C@_0IH@GEMBEHDJ@The?5type?5definition?5?8?$CFs?8?0?5speci@ ; `string'
PUBLIC	??_C@_0CC@POINHACG@No?5matching?5declaration?5availab@ ; `string'
PUBLIC	??_C@_0CE@FKPBKJME@The?5element?5declaration?5is?5abst@ ; `string'
PUBLIC	??_C@_0BO@GOBNMKOB@The?5type?5definition?5is?5absent@ ; `string'
PUBLIC	??_C@_0EL@BODABIJH@calling?5xmlSchemaVCheckCVCSimpl@ ; `string'
PUBLIC	??_C@_0BK@OGPCMEDL@xmlSchemaValidateElemDecl@	; `string'
PUBLIC	??_C@_0BO@NGOMKCIG@The?5element?5is?5not?5?8nillable?8@ ; `string'
PUBLIC	??_C@_0FI@EHNCBIIJ@The?5element?5cannot?5be?5?8nilled?8?5@ ; `string'
PUBLIC	??_C@_0EG@NIGOCKPL@calling?5xmlSchemaProcessXSIType@ ; `string'
PUBLIC	??_C@_0BM@CHGONAOC@xmlSchemaVAttributesComplex@	; `string'
PUBLIC	??_C@_0CB@OAMKHEAF@calling?5xmlSchemaXPathEvaluate?$CI@ ; `string'
PUBLIC	??_C@_0DM@OLDNNBOE@default?1fixed?5value?5on?5an?5attri@ ; `string'
PUBLIC	??_C@_0BN@NBKJGHAJ@calling?5xmlSchemaCopyValue?$CI?$CJ@ ; `string'
PUBLIC	??_C@_0BF@NILPJKHF@calling?5xmlNewProp?$CI?$CJ@	; `string'
PUBLIC	??_C@_03IKJDKKNH@p?$CFd@			; `string'
PUBLIC	??_C@_0DM@GNILNNDD@could?5not?5compute?5a?5ns?5prefix?5f@ ; `string'
PUBLIC	??_C@_0DB@JPKGGAFI@calling?5xmlSchemaStreamValidate@ ; `string'
PUBLIC	??_C@_0CL@GFEDJBGB@The?5attribute?5?8?$CFs?8?5is?5required?5@ ; `string'
PUBLIC	??_C@_0DO@GPMMNIJO@The?5value?5?8?$CFs?8?5does?5not?5match?5t@ ; `string'
PUBLIC	??_C@_0FI@JBNMNHPF@No?5matching?5global?5attribute?5de@ ; `string'
PUBLIC	??_C@_0O@NAPPEKME@bad?5arguments@		; `string'
PUBLIC	??_C@_0BO@NHKJDFH@xmlSchemaValidateElemWildcard@ ; `string'
PUBLIC	??_C@_0FG@DIJLLKJP@No?5matching?5global?5element?5decl@ ; `string'
PUBLIC	??_C@_0EF@GLDBDLOM@calling?5xmlSchemaProcessXSIType@ ; `string'
PUBLIC	??_C@_0JO@LAEFOCFG@For?5a?5string?5to?5be?5a?5valid?5defa@ ; `string'
PUBLIC	??_C@_0BO@FJAHODBA@xmlSchemaCheckCOSValidDefault@ ; `string'
PUBLIC	??_C@_0CE@ILDABLF@calling?5xmlSchemaGetFreshElemIn@ ; `string'
PUBLIC	??_C@_0BL@GMHMOLCB@xmlSchemaValidatorPushElem@	; `string'
PUBLIC	??_C@_0CB@GNCACIIF@failed?5to?5create?5a?5regex?5contex@ ; `string'
PUBLIC	??_C@_0BK@CPCENKBJ@xmlSchemaValidatorPopElem@	; `string'
PUBLIC	??_C@_0BJ@GMMIGBBG@Missing?5child?5element?$CIs?$CJ@ ; `string'
PUBLIC	??_C@_0CI@FBAKNAMG@calling?5xmlSchemaCheckCOSValidD@ ; `string'
PUBLIC	??_C@_0BF@GPIBFAIA@calling?5xmlNewText?$CI?$CJ@	; `string'
PUBLIC	??_C@_0FE@OJCHDPJF@The?5content?5must?5not?5containt?5e@ ; `string'
PUBLIC	??_C@_0EG@LHINEJAD@The?5initial?5value?5?8?$CFs?8?5does?5not@ ; `string'
PUBLIC	??_C@_0EF@OEHLJDGK@The?5actual?5value?5?8?$CFs?8?5does?5not?5@ ; `string'
PUBLIC	??_C@_0CF@GNGFKIEN@not?5intended?5for?5the?5validation@ ; `string'
PUBLIC	??_C@_0BL@FBELDAFB@xmlSchemaValidateChildElem@	; `string'
PUBLIC	??_C@_0FD@PPFLCKNL@Neither?5character?5nor?5element?5c@ ; `string'
PUBLIC	??_C@_0EC@KOBHHIFI@Element?5content?5is?5not?5allowed?0@ ; `string'
PUBLIC	??_C@_0CL@MKLADNOP@type?5has?5elem?5content?5but?5no?5co@ ; `string'
PUBLIC	??_C@_0DF@OBNAIIEI@validating?5elem?0?5but?5elem?5conte@ ; `string'
PUBLIC	??_C@_0CA@OAIJEHME@calling?5xmlRegExecPushString2?$CI?$CJ@ ; `string'
PUBLIC	??_C@_0BN@MPLEFMDA@This?5element?5is?5not?5expected@ ; `string'
PUBLIC	??_C@_0FF@IENAPLLP@Element?5content?5is?5not?5allowed?0@ ; `string'
PUBLIC	??_C@_0EG@PMDFJIHB@Element?5content?5is?5not?5allowed?0@ ; `string'
PUBLIC	??_C@_0FB@HDMHOBND@Neither?5character?5nor?5element?5c@ ; `string'
PUBLIC	??_C@_0EE@EDDPNAMO@Character?5content?5is?5not?5allowe@ ; `string'
PUBLIC	??_C@_0GC@MDHGDDOF@Character?5content?5other?5than?5wh@ ; `string'
PUBLIC	??_C@_0O@BFNKDIGJ@in?5skip?9state@		; `string'
PUBLIC	??_C@_0BG@PEPPJHKP@xmlSchemaValidateElem@	; `string'
PUBLIC	??_C@_0CO@IEJMJHPB@calling?5xmlSchemaStreamValidate@ ; `string'
PUBLIC	??_C@_0EN@IOLJEJKJ@the?5child?5element?5was?5valid?5but@ ; `string'
PUBLIC	??_C@_0EB@OKNNKHOB@No?5matching?5global?5declaration?5@ ; `string'
PUBLIC	??_C@_0CI@LODHCMEF@calling?5xmlSchemaValidateElemWi@ ; `string'
PUBLIC	??_C@_0CE@OCICNFMI@calling?5xmlSchemaValidateElemDe@ ; `string'
PUBLIC	??_C@_0CA@DHELECIF@The?5type?5definition?5is?5abstract@ ; `string'
PUBLIC	??_C@_0BO@EFEFIODN@calling?5attributes?5validation@ ; `string'
PUBLIC	??_C@_0BN@NAKBGNNM@calling?5xmlSchemaVPushText?$CI?$CJ@ ; `string'
PUBLIC	??_C@_0BP@DDCACDGG@xmlSchemaSAXHandleCDataSection@ ; `string'
PUBLIC	??_C@_0CF@NKADHDNI@calling?5xmlSchemaValidatorPushE@ ; `string'
PUBLIC	??_C@_0CB@PHMCNLEA@xmlSchemaSAXHandleStartElementN@ ; `string'
PUBLIC	??_C@_0DB@LKIJJHFH@allocating?5namespace?5bindings?5f@ ; `string'
PUBLIC	??_C@_0DE@FHEEIBOG@re?9allocating?5namespace?5binding@ ; `string'
PUBLIC	??_C@_0CI@BHABMMOD@allocating?5string?5for?5decoded?5a@ ; `string'
PUBLIC	??_C@_0CK@JPNOGHKO@calling?5xmlSchemaValidatorPushA@ ; `string'
PUBLIC	??_C@_0CA@HCDKBLLH@calling?5xmlSchemaValidateElem?$CI?$CJ@ ; `string'
PUBLIC	??_C@_0BC@LAPBJBJD@elem?5pop?5mismatch@		; `string'
PUBLIC	??_C@_0BP@IODONKBL@xmlSchemaSAXHandleEndElementNs@ ; `string'
PUBLIC	??_C@_0CE@LPDPGHFN@calling?5xmlSchemaValidatorPopEl@ ; `string'
PUBLIC	??_C@_0BO@JGCBGKGF@allocating?5validation?5context@ ; `string'
PUBLIC	??_C@_0CF@IJEICDHG@The?5document?5has?5no?5document?5el@ ; `string'
PUBLIC	??_C@_0BB@JLNPEAHB@xmlSchemaDocWalk@		; `string'
PUBLIC	??_C@_0BC@GLFJEMA@xmlSchemaVDocWalk@		; `string'
PUBLIC	??_C@_0MP@HCAOIGI@there?5is?5at?5least?5one?5entity?5re@ ; `string'
PUBLIC	??_C@_0BK@MHAMFOBD@element?5position?5mismatch@	; `string'
PUBLIC	??_C@_0BI@BPKAPLGE@no?5instance?5to?5validate@	; `string'
PUBLIC	??_C@_0BA@HJOAFKLO@xmlSchemaVStart@		; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlCharStrdup:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlStrcat:PROC
EXTRN	_xmlStrncat:PROC
EXTRN	_xmlStrncatNew:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_xmlEscapeFormatString:PROC
EXTRN	_strchr:PROC
EXTRN	_xmlDictCreate:PROC
EXTRN	_xmlDictReference:PROC
EXTRN	_xmlDictFree:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlRegexpCompile:PROC
EXTRN	_xmlRegFreeRegexp:PROC
EXTRN	_xmlRegexpExec:PROC
EXTRN	_xmlRegexpIsDeterminist:PROC
EXTRN	_xmlRegNewExecCtxt:PROC
EXTRN	_xmlRegFreeExecCtxt:PROC
EXTRN	_xmlRegExecPushString:PROC
EXTRN	_xmlRegExecPushString2:PROC
EXTRN	_xmlRegExecNextValues:PROC
EXTRN	_xmlRegExecErrInfo:PROC
EXTRN	_xmlValidateNCName:PROC
EXTRN	_xmlValidateQName:PROC
EXTRN	_xmlSplitQName2:PROC
EXTRN	_xmlSplitQName3:PROC
EXTRN	_xmlNewNs:PROC
EXTRN	_xmlFreeDoc:PROC
EXTRN	_xmlNewProp:PROC
EXTRN	_xmlNewNsProp:PROC
EXTRN	_xmlNewText:PROC
EXTRN	_xmlDocGetRootElement:PROC
EXTRN	_xmlAddChild:PROC
EXTRN	_xmlUnlinkNode:PROC
EXTRN	_xmlFreeNode:PROC
EXTRN	_xmlSearchNs:PROC
EXTRN	_xmlSearchNsByHref:PROC
EXTRN	_xmlGetNsList:PROC
EXTRN	_xmlGetNoNsProp:PROC
EXTRN	_xmlHasProp:PROC
EXTRN	_xmlNodeListGetString:PROC
EXTRN	_xmlNodeGetContent:PROC
EXTRN	_xmlNodeGetSpacePreserve:PROC
EXTRN	_xmlNodeGetBase:PROC
EXTRN	_xmlHashCreateDict:PROC
EXTRN	_xmlHashFree:PROC
EXTRN	_xmlHashAddEntry:PROC
EXTRN	_xmlHashAddEntry2:PROC
EXTRN	_xmlHashLookup:PROC
EXTRN	_xmlHashLookup2:PROC
EXTRN	_xmlHashSize:PROC
EXTRN	_xmlHashScan:PROC
EXTRN	_xmlHashScanFull:PROC
EXTRN	_xmlGetLastError:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	_xmlNewAutomata:PROC
EXTRN	_xmlFreeAutomata:PROC
EXTRN	_xmlAutomataGetInitState:PROC
EXTRN	_xmlAutomataSetFinalState:PROC
EXTRN	_xmlAutomataNewState:PROC
EXTRN	_xmlAutomataNewTransition2:PROC
EXTRN	_xmlAutomataNewNegTrans:PROC
EXTRN	_xmlAutomataNewCountTrans2:PROC
EXTRN	_xmlAutomataNewOnceTrans2:PROC
EXTRN	_xmlAutomataNewAllTrans:PROC
EXTRN	_xmlAutomataNewEpsilon:PROC
EXTRN	_xmlAutomataNewCountedTrans:PROC
EXTRN	_xmlAutomataNewCounterTrans:PROC
EXTRN	_xmlAutomataNewCounter:PROC
EXTRN	_xmlAutomataCompile:PROC
EXTRN	_xmlFreeEnumeration:PROC
EXTRN	_xmlAddID:PROC
EXTRN	_xmlParserInputBufferCreateFilename:PROC
EXTRN	_xmlStopParser:PROC
EXTRN	_xmlParseDocument:PROC
EXTRN	_xmlNewParserCtxt:PROC
EXTRN	_xmlFreeParserCtxt:PROC
EXTRN	_xmlNewIOInputStream:PROC
EXTRN	_xmlCtxtReadFile:PROC
EXTRN	_xmlCtxtReadMemory:PROC
EXTRN	_xmlSAX2GetLineNumber:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	_inputPush:PROC
EXTRN	_xmlBuildURI:PROC
EXTRN	_xmlSchemaInitTypes:PROC
EXTRN	_xmlSchemaGetPredefinedType:PROC
EXTRN	_xmlSchemaValidatePredefinedType:PROC
EXTRN	_xmlSchemaValPredefTypeNode:PROC
EXTRN	_xmlSchemaValidateFacetWhtsp:PROC
EXTRN	_xmlSchemaFreeValue:PROC
EXTRN	_xmlSchemaCompareValues:PROC
EXTRN	_xmlSchemaValidateListSimpleTypeFacet:PROC
EXTRN	_xmlSchemaGetBuiltInType:PROC
EXTRN	_xmlSchemaIsBuiltInTypeFacet:PROC
EXTRN	_xmlSchemaCollapseString:PROC
EXTRN	_xmlSchemaWhiteSpaceReplace:PROC
EXTRN	_xmlSchemaGetFacetValueAsULong:PROC
EXTRN	_xmlSchemaValidateLengthFacetWhtsp:PROC
EXTRN	_xmlSchemaValPredefTypeNodeNoNorm:PROC
EXTRN	_xmlSchemaGetCanonValue:PROC
EXTRN	_xmlSchemaValueAppend:PROC
EXTRN	_xmlSchemaValueGetNext:PROC
EXTRN	_xmlSchemaValueGetAsString:PROC
EXTRN	_xmlSchemaValueGetAsBoolean:PROC
EXTRN	_xmlSchemaNewNOTATIONValue:PROC
EXTRN	_xmlSchemaNewQNameValue:PROC
EXTRN	_xmlSchemaCompareValuesWhtsp:PROC
EXTRN	_xmlSchemaCopyValue:PROC
EXTRN	_xmlSchemaGetValType:PROC
EXTRN	_xmlFreePattern:PROC
EXTRN	_xmlPatterncompile:PROC
EXTRN	_xmlPatternGetStreamCtxt:PROC
EXTRN	_xmlFreeStreamCtxt:PROC
EXTRN	_xmlStreamPush:PROC
EXTRN	_xmlStreamPushAttr:PROC
EXTRN	_xmlStreamPop:PROC
EXTRN	_xmlTextReaderLookupNamespace:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT ??_C@_0BA@HJOAFKLO@xmlSchemaVStart@
CONST	SEGMENT
??_C@_0BA@HJOAFKLO@xmlSchemaVStart@ DB 'xmlSchemaVStart', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BPKAPLGE@no?5instance?5to?5validate@
CONST	SEGMENT
??_C@_0BI@BPKAPLGE@no?5instance?5to?5validate@ DB 'no instance to validat'
	DB	'e', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MHAMFOBD@element?5position?5mismatch@
CONST	SEGMENT
??_C@_0BK@MHAMFOBD@element?5position?5mismatch@ DB 'element position mism'
	DB	'atch', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0MP@HCAOIGI@there?5is?5at?5least?5one?5entity?5re@
CONST	SEGMENT
??_C@_0MP@HCAOIGI@there?5is?5at?5least?5one?5entity?5re@ DB 'there is at '
	DB	'least one entity reference in the node-tree currently being v'
	DB	'alidated. Processing of entities with this XML Schema process'
	DB	'or is not supported (yet). Please substitute entities before '
	DB	'validation.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GLFJEMA@xmlSchemaVDocWalk@
CONST	SEGMENT
??_C@_0BC@GLFJEMA@xmlSchemaVDocWalk@ DB 'xmlSchemaVDocWalk', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JLNPEAHB@xmlSchemaDocWalk@
CONST	SEGMENT
??_C@_0BB@JLNPEAHB@xmlSchemaDocWalk@ DB 'xmlSchemaDocWalk', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IJEICDHG@The?5document?5has?5no?5document?5el@
CONST	SEGMENT
??_C@_0CF@IJEICDHG@The?5document?5has?5no?5document?5el@ DB 'The document'
	DB	' has no document element', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JGCBGKGF@allocating?5validation?5context@
CONST	SEGMENT
??_C@_0BO@JGCBGKGF@allocating?5validation?5context@ DB 'allocating valida'
	DB	'tion context', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LPDPGHFN@calling?5xmlSchemaValidatorPopEl@
CONST	SEGMENT
??_C@_0CE@LPDPGHFN@calling?5xmlSchemaValidatorPopEl@ DB 'calling xmlSchem'
	DB	'aValidatorPopElem()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IODONKBL@xmlSchemaSAXHandleEndElementNs@
CONST	SEGMENT
??_C@_0BP@IODONKBL@xmlSchemaSAXHandleEndElementNs@ DB 'xmlSchemaSAXHandle'
	DB	'EndElementNs', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LAPBJBJD@elem?5pop?5mismatch@
CONST	SEGMENT
??_C@_0BC@LAPBJBJD@elem?5pop?5mismatch@ DB 'elem pop mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HCDKBLLH@calling?5xmlSchemaValidateElem?$CI?$CJ@
CONST	SEGMENT
??_C@_0CA@HCDKBLLH@calling?5xmlSchemaValidateElem?$CI?$CJ@ DB 'calling xm'
	DB	'lSchemaValidateElem()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JPNOGHKO@calling?5xmlSchemaValidatorPushA@
CONST	SEGMENT
??_C@_0CK@JPNOGHKO@calling?5xmlSchemaValidatorPushA@ DB 'calling xmlSchem'
	DB	'aValidatorPushAttribute()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BHABMMOD@allocating?5string?5for?5decoded?5a@
CONST	SEGMENT
??_C@_0CI@BHABMMOD@allocating?5string?5for?5decoded?5a@ DB 'allocating st'
	DB	'ring for decoded attribute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FHEEIBOG@re?9allocating?5namespace?5binding@
CONST	SEGMENT
??_C@_0DE@FHEEIBOG@re?9allocating?5namespace?5binding@ DB 're-allocating '
	DB	'namespace bindings for SAX validation', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LKIJJHFH@allocating?5namespace?5bindings?5f@
CONST	SEGMENT
??_C@_0DB@LKIJJHFH@allocating?5namespace?5bindings?5f@ DB 'allocating nam'
	DB	'espace bindings for SAX validation', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PHMCNLEA@xmlSchemaSAXHandleStartElementN@
CONST	SEGMENT
??_C@_0CB@PHMCNLEA@xmlSchemaSAXHandleStartElementN@ DB 'xmlSchemaSAXHandl'
	DB	'eStartElementNs', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NKADHDNI@calling?5xmlSchemaValidatorPushE@
CONST	SEGMENT
??_C@_0CF@NKADHDNI@calling?5xmlSchemaValidatorPushE@ DB 'calling xmlSchem'
	DB	'aValidatorPushElem()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DDCACDGG@xmlSchemaSAXHandleCDataSection@
CONST	SEGMENT
??_C@_0BP@DDCACDGG@xmlSchemaSAXHandleCDataSection@ DB 'xmlSchemaSAXHandle'
	DB	'CDataSection', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NAKBGNNM@calling?5xmlSchemaVPushText?$CI?$CJ@
CONST	SEGMENT
??_C@_0BN@NAKBGNNM@calling?5xmlSchemaVPushText?$CI?$CJ@ DB 'calling xmlSc'
	DB	'hemaVPushText()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EFEFIODN@calling?5attributes?5validation@
CONST	SEGMENT
??_C@_0BO@EFEFIODN@calling?5attributes?5validation@ DB 'calling attribute'
	DB	's validation', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DHELECIF@The?5type?5definition?5is?5abstract@
CONST	SEGMENT
??_C@_0CA@DHELECIF@The?5type?5definition?5is?5abstract@ DB 'The type defi'
	DB	'nition is abstract', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OCICNFMI@calling?5xmlSchemaValidateElemDe@
CONST	SEGMENT
??_C@_0CE@OCICNFMI@calling?5xmlSchemaValidateElemDe@ DB 'calling xmlSchem'
	DB	'aValidateElemDecl()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LODHCMEF@calling?5xmlSchemaValidateElemWi@
CONST	SEGMENT
??_C@_0CI@LODHCMEF@calling?5xmlSchemaValidateElemWi@ DB 'calling xmlSchem'
	DB	'aValidateElemWildcard()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@OKNNKHOB@No?5matching?5global?5declaration?5@
CONST	SEGMENT
??_C@_0EB@OKNNKHOB@No?5matching?5global?5declaration?5@ DB 'No matching g'
	DB	'lobal declaration available for the validation root', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@IOLJEJKJ@the?5child?5element?5was?5valid?5but@
CONST	SEGMENT
??_C@_0EN@IOLJEJKJ@the?5child?5element?5was?5valid?5but@ DB 'the child el'
	DB	'ement was valid but neither the declaration nor the type was '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IEJMJHPB@calling?5xmlSchemaStreamValidate@
CONST	SEGMENT
??_C@_0CO@IEJMJHPB@calling?5xmlSchemaStreamValidate@ DB 'calling xmlSchem'
	DB	'aStreamValidateChildElement()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PEPPJHKP@xmlSchemaValidateElem@
CONST	SEGMENT
??_C@_0BG@PEPPJHKP@xmlSchemaValidateElem@ DB 'xmlSchemaValidateElem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BFNKDIGJ@in?5skip?9state@
CONST	SEGMENT
??_C@_0O@BFNKDIGJ@in?5skip?9state@ DB 'in skip-state', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@MDHGDDOF@Character?5content?5other?5than?5wh@
CONST	SEGMENT
??_C@_0GC@MDHGDDOF@Character?5content?5other?5than?5wh@ DB 'Character con'
	DB	'tent other than whitespace is not allowed because the content'
	DB	' type is ''element-only''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@EDDPNAMO@Character?5content?5is?5not?5allowe@
CONST	SEGMENT
??_C@_0EE@EDDPNAMO@Character?5content?5is?5not?5allowe@ DB 'Character con'
	DB	'tent is not allowed, because the content type is empty', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@HDMHOBND@Neither?5character?5nor?5element?5c@
CONST	SEGMENT
??_C@_0FB@HDMHOBND@Neither?5character?5nor?5element?5c@ DB 'Neither chara'
	DB	'cter nor element content is allowed because the element is '''
	DB	'nilled''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@PMDFJIHB@Element?5content?5is?5not?5allowed?0@
CONST	SEGMENT
??_C@_0EG@PMDFJIHB@Element?5content?5is?5not?5allowed?0@ DB 'Element cont'
	DB	'ent is not allowed, because the type definition is simple', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@IENAPLLP@Element?5content?5is?5not?5allowed?0@
CONST	SEGMENT
??_C@_0FF@IENAPLLP@Element?5content?5is?5not?5allowed?0@ DB 'Element cont'
	DB	'ent is not allowed, because the content type is a simple type'
	DB	' definition', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MPLEFMDA@This?5element?5is?5not?5expected@
CONST	SEGMENT
??_C@_0BN@MPLEFMDA@This?5element?5is?5not?5expected@ DB 'This element is '
	DB	'not expected', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OAIJEHME@calling?5xmlRegExecPushString2?$CI?$CJ@
CONST	SEGMENT
??_C@_0CA@OAIJEHME@calling?5xmlRegExecPushString2?$CI?$CJ@ DB 'calling xm'
	DB	'lRegExecPushString2()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@OBNAIIEI@validating?5elem?0?5but?5elem?5conte@
CONST	SEGMENT
??_C@_0DF@OBNAIIEI@validating?5elem?0?5but?5elem?5conte@ DB 'validating e'
	DB	'lem, but elem content is already invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MKLADNOP@type?5has?5elem?5content?5but?5no?5co@
CONST	SEGMENT
??_C@_0CL@MKLADNOP@type?5has?5elem?5content?5but?5no?5co@ DB 'type has el'
	DB	'em content but no content model', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@KOBHHIFI@Element?5content?5is?5not?5allowed?0@
CONST	SEGMENT
??_C@_0EC@KOBHHIFI@Element?5content?5is?5not?5allowed?0@ DB 'Element cont'
	DB	'ent is not allowed, because the content type is empty', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@PPFLCKNL@Neither?5character?5nor?5element?5c@
CONST	SEGMENT
??_C@_0FD@PPFLCKNL@Neither?5character?5nor?5element?5c@ DB 'Neither chara'
	DB	'cter nor element content is allowed, because the element was '
	DB	'''nilled''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FBELDAFB@xmlSchemaValidateChildElem@
CONST	SEGMENT
??_C@_0BL@FBELDAFB@xmlSchemaValidateChildElem@ DB 'xmlSchemaValidateChild'
	DB	'Elem', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GNGFKIEN@not?5intended?5for?5the?5validation@
CONST	SEGMENT
??_C@_0CF@GNGFKIEN@not?5intended?5for?5the?5validation@ DB 'not intended '
	DB	'for the validation root', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@OEHLJDGK@The?5actual?5value?5?8?$CFs?8?5does?5not?5@
CONST	SEGMENT
??_C@_0EF@OEHLJDGK@The?5actual?5value?5?8?$CFs?8?5does?5not?5@ DB 'The ac'
	DB	'tual value ''%s'' does not match the fixed value constraint '''
	DB	'%s''', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@LHINEJAD@The?5initial?5value?5?8?$CFs?8?5does?5not@
CONST	SEGMENT
??_C@_0EG@LHINEJAD@The?5initial?5value?5?8?$CFs?8?5does?5not@ DB 'The ini'
	DB	'tial value ''%s'' does not match the fixed value constraint '''
	DB	'%s''', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@OJCHDPJF@The?5content?5must?5not?5containt?5e@
CONST	SEGMENT
??_C@_0FE@OJCHDPJF@The?5content?5must?5not?5containt?5e@ DB 'The content '
	DB	'must not containt element nodes since there is a fixed value '
	DB	'constraint', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GPIBFAIA@calling?5xmlNewText?$CI?$CJ@
CONST	SEGMENT
??_C@_0BF@GPIBFAIA@calling?5xmlNewText?$CI?$CJ@ DB 'calling xmlNewText()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FBAKNAMG@calling?5xmlSchemaCheckCOSValidD@
CONST	SEGMENT
??_C@_0CI@FBAKNAMG@calling?5xmlSchemaCheckCOSValidD@ DB 'calling xmlSchem'
	DB	'aCheckCOSValidDefault()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GMMIGBBG@Missing?5child?5element?$CIs?$CJ@
CONST	SEGMENT
??_C@_0BJ@GMMIGBBG@Missing?5child?5element?$CIs?$CJ@ DB 'Missing child el'
	DB	'ement(s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CPCENKBJ@xmlSchemaValidatorPopElem@
CONST	SEGMENT
??_C@_0BK@CPCENKBJ@xmlSchemaValidatorPopElem@ DB 'xmlSchemaValidatorPopEl'
	DB	'em', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GNCACIIF@failed?5to?5create?5a?5regex?5contex@
CONST	SEGMENT
??_C@_0CB@GNCACIIF@failed?5to?5create?5a?5regex?5contex@ DB 'failed to cr'
	DB	'eate a regex context', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GMHMOLCB@xmlSchemaValidatorPushElem@
CONST	SEGMENT
??_C@_0BL@GMHMOLCB@xmlSchemaValidatorPushElem@ DB 'xmlSchemaValidatorPush'
	DB	'Elem', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@ILDABLF@calling?5xmlSchemaGetFreshElemIn@
CONST	SEGMENT
??_C@_0CE@ILDABLF@calling?5xmlSchemaGetFreshElemIn@ DB 'calling xmlSchema'
	DB	'GetFreshElemInfo()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FJAHODBA@xmlSchemaCheckCOSValidDefault@
CONST	SEGMENT
??_C@_0BO@FJAHODBA@xmlSchemaCheckCOSValidDefault@ DB 'xmlSchemaCheckCOSVa'
	DB	'lidDefault', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0JO@LAEFOCFG@For?5a?5string?5to?5be?5a?5valid?5defa@
CONST	SEGMENT
??_C@_0JO@LAEFOCFG@For?5a?5string?5to?5be?5a?5valid?5defa@ DB 'For a stri'
	DB	'ng to be a valid default, the type definition must be a simpl'
	DB	'e type or a complex type with simple content or mixed content'
	DB	' and a particle emptiable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@GLDBDLOM@calling?5xmlSchemaProcessXSIType@
CONST	SEGMENT
??_C@_0EF@GLDBDLOM@calling?5xmlSchemaProcessXSIType@ DB 'calling xmlSchem'
	DB	'aProcessXSIType() to process the attribute ''xsi:nil''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@DIJLLKJP@No?5matching?5global?5element?5decl@
CONST	SEGMENT
??_C@_0FG@DIJLLKJP@No?5matching?5global?5element?5decl@ DB 'No matching g'
	DB	'lobal element declaration available, but demanded by the stri'
	DB	'ct wildcard', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NHKJDFH@xmlSchemaValidateElemWildcard@
CONST	SEGMENT
??_C@_0BO@NHKJDFH@xmlSchemaValidateElemWildcard@ DB 'xmlSchemaValidateEle'
	DB	'mWildcard', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NAPPEKME@bad?5arguments@
CONST	SEGMENT
??_C@_0O@NAPPEKME@bad?5arguments@ DB 'bad arguments', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@JBNMNHPF@No?5matching?5global?5attribute?5de@
CONST	SEGMENT
??_C@_0FI@JBNMNHPF@No?5matching?5global?5attribute?5de@ DB 'No matching g'
	DB	'lobal attribute declaration available, but demanded by the st'
	DB	'rict wildcard', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@GPMMNIJO@The?5value?5?8?$CFs?8?5does?5not?5match?5t@
CONST	SEGMENT
??_C@_0DO@GPMMNIJO@The?5value?5?8?$CFs?8?5does?5not?5match?5t@ DB 'The va'
	DB	'lue ''%s'' does not match the fixed value constraint ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GFEDJBGB@The?5attribute?5?8?$CFs?8?5is?5required?5@
CONST	SEGMENT
??_C@_0CL@GFEDJBGB@The?5attribute?5?8?$CFs?8?5is?5required?5@ DB 'The att'
	DB	'ribute ''%s'' is required but missing', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JPKGGAFI@calling?5xmlSchemaStreamValidate@
CONST	SEGMENT
??_C@_0DB@JPKGGAFI@calling?5xmlSchemaStreamValidate@ DB 'calling xmlSchem'
	DB	'aStreamValidateSimpleTypeValue()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@GNILNNDD@could?5not?5compute?5a?5ns?5prefix?5f@
CONST	SEGMENT
??_C@_0DM@GNILNNDD@could?5not?5compute?5a?5ns?5prefix?5f@ DB 'could not c'
	DB	'ompute a ns prefix for a default/fixed attribute', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03IKJDKKNH@p?$CFd@
CONST	SEGMENT
??_C@_03IKJDKKNH@p?$CFd@ DB 'p%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NILPJKHF@calling?5xmlNewProp?$CI?$CJ@
CONST	SEGMENT
??_C@_0BF@NILPJKHF@calling?5xmlNewProp?$CI?$CJ@ DB 'calling xmlNewProp()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NBKJGHAJ@calling?5xmlSchemaCopyValue?$CI?$CJ@
CONST	SEGMENT
??_C@_0BN@NBKJGHAJ@calling?5xmlSchemaCopyValue?$CI?$CJ@ DB 'calling xmlSc'
	DB	'hemaCopyValue()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@OLDNNBOE@default?1fixed?5value?5on?5an?5attri@
CONST	SEGMENT
??_C@_0DM@OLDNNBOE@default?1fixed?5value?5on?5an?5attri@ DB 'default/fixe'
	DB	'd value on an attribute use was not precomputed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OAMKHEAF@calling?5xmlSchemaXPathEvaluate?$CI@
CONST	SEGMENT
??_C@_0CB@OAMKHEAF@calling?5xmlSchemaXPathEvaluate?$CI@ DB 'calling xmlSc'
	DB	'hemaXPathEvaluate()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CHGONAOC@xmlSchemaVAttributesComplex@
CONST	SEGMENT
??_C@_0BM@CHGONAOC@xmlSchemaVAttributesComplex@ DB 'xmlSchemaVAttributesC'
	DB	'omplex', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@NIGOCKPL@calling?5xmlSchemaProcessXSIType@
CONST	SEGMENT
??_C@_0EG@NIGOCKPL@calling?5xmlSchemaProcessXSIType@ DB 'calling xmlSchem'
	DB	'aProcessXSIType() to process the attribute ''xsi:type''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@EHNCBIIJ@The?5element?5cannot?5be?5?8nilled?8?5@
CONST	SEGMENT
??_C@_0FI@EHNCBIIJ@The?5element?5cannot?5be?5?8nilled?8?5@ DB 'The elemen'
	DB	't cannot be ''nilled'' because there is a fixed value constra'
	DB	'int defined for it', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NGOMKCIG@The?5element?5is?5not?5?8nillable?8@
CONST	SEGMENT
??_C@_0BO@NGOMKCIG@The?5element?5is?5not?5?8nillable?8@ DB 'The element i'
	DB	's not ''nillable''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OGPCMEDL@xmlSchemaValidateElemDecl@
CONST	SEGMENT
??_C@_0BK@OGPCMEDL@xmlSchemaValidateElemDecl@ DB 'xmlSchemaValidateElemDe'
	DB	'cl', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@BODABIJH@calling?5xmlSchemaVCheckCVCSimpl@
CONST	SEGMENT
??_C@_0EL@BODABIJH@calling?5xmlSchemaVCheckCVCSimpl@ DB 'calling xmlSchem'
	DB	'aVCheckCVCSimpleType() to validate the attribute ''xsi:nil''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GOBNMKOB@The?5type?5definition?5is?5absent@
CONST	SEGMENT
??_C@_0BO@GOBNMKOB@The?5type?5definition?5is?5absent@ DB 'The type defini'
	DB	'tion is absent', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FKPBKJME@The?5element?5declaration?5is?5abst@
CONST	SEGMENT
??_C@_0CE@FKPBKJME@The?5element?5declaration?5is?5abst@ DB 'The element d'
	DB	'eclaration is abstract', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@POINHACG@No?5matching?5declaration?5availab@
CONST	SEGMENT
??_C@_0CC@POINHACG@No?5matching?5declaration?5availab@ DB 'No matching de'
	DB	'claration available', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0IH@GEMBEHDJ@The?5type?5definition?5?8?$CFs?8?0?5speci@
CONST	SEGMENT
??_C@_0IH@GEMBEHDJ@The?5type?5definition?5?8?$CFs?8?0?5speci@ DB 'The typ'
	DB	'e definition ''%s'', specified by xsi:type, is blocked or not'
	DB	' validly derived from the type definition of the element decl'
	DB	'aration', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@GCDILCEF@The?5QName?5value?5?8?$CFs?8?5of?5the?5xsi@
CONST	SEGMENT
??_C@_0FF@GCDILCEF@The?5QName?5value?5?8?$CFs?8?5of?5the?5xsi@ DB 'The QN'
	DB	'ame value ''%s'' of the xsi:type attribute does not resolve t'
	DB	'o a type definition', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PKILICAE@xmlSchemaValidateElementByDecla@
CONST	SEGMENT
??_C@_0CG@PKILICAE@xmlSchemaValidateElementByDecla@ DB 'xmlSchemaValidate'
	DB	'ElementByDeclaration', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@GLDMHPJF@calling?5xmlSchemaQNameExpand?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0EE@GLDMHPJF@calling?5xmlSchemaQNameExpand?$CI?$CJ?5@ DB 'calling x'
	DB	'mlSchemaQNameExpand() to validate the attribute ''xsi:type''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DGPHKMDI@validating?5facets?5of?5union?5simp@
CONST	SEGMENT
??_C@_0CH@DGPHKMDI@validating?5facets?5of?5union?5simp@ DB 'validating fa'
	DB	'cets of union simple type', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MOMFK@validating?5members?5of?5union?5sim@
CONST	SEGMENT
??_C@_0CI@MOMFK@validating?5members?5of?5union?5sim@ DB 'validating membe'
	DB	'rs of union simple type', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NCCHNOHC@union?5simple?5type?5has?5no?5member@
CONST	SEGMENT
??_C@_0CG@NCCHNOHC@union?5simple?5type?5has?5no?5member@ DB 'union simple'
	DB	' type has no member types', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LKPAEBKB@validating?5facets?5of?5list?5simpl@
CONST	SEGMENT
??_C@_0CG@LKPAEBKB@validating?5facets?5of?5list?5simpl@ DB 'validating fa'
	DB	'cets of list simple type', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JGMIFPNF@validating?5an?5item?5of?5list?5simp@
CONST	SEGMENT
??_C@_0CH@JGMIFPNF@validating?5an?5item?5of?5list?5simp@ DB 'validating a'
	DB	'n item of list simple type', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LPLEHNN@validating?5facets?5of?5atomic?5sim@
CONST	SEGMENT
??_C@_0CI@LPLEHNN@validating?5facets?5of?5atomic?5sim@ DB 'validating fac'
	DB	'ets of atomic simple type', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GBDHIMIE@validating?5against?5a?5built?9in?5t@
CONST	SEGMENT
??_C@_0CD@GBDHIMIE@validating?5against?5a?5built?9in?5t@ DB 'validating a'
	DB	'gainst a built-in type', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DBANEELH@xmlSchemaVCheckCVCSimpleType@
CONST	SEGMENT
??_C@_0BN@DBANEELH@xmlSchemaVCheckCVCSimpleType@ DB 'xmlSchemaVCheckCVCSi'
	DB	'mpleType', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NBJHIEJL@could?5not?5get?5the?5built?9in?5type@
CONST	SEGMENT
??_C@_0CA@NBJHIEJL@could?5not?5get?5the?5built?9in?5type@ DB 'could not g'
	DB	'et the built-in type', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@KJCHOIHD@The?5QName?5value?5?8?$CFs?8?5has?5no?5cor@
CONST	SEGMENT
??_C@_0EJ@KJCHOIHD@The?5QName?5value?5?8?$CFs?8?5has?5no?5cor@ DB 'The QN'
	DB	'ame value ''%s'' has no corresponding namespace declaration i'
	DB	'n scope', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PCDDHFLC@xmlSchemaValidateQName@
CONST	SEGMENT
??_C@_0BH@PCDDHFLC@xmlSchemaValidateQName@ DB 'xmlSchemaValidateQName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JAPCPOMD@calling?5xmlValidateQName?$CI?$CJ@
CONST	SEGMENT
??_C@_0BL@JAPCPOMD@calling?5xmlValidateQName?$CI?$CJ@ DB 'calling xmlVali'
	DB	'dateQName()', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GIDABGCK@validating?5against?5a?5pattern?5fa@
CONST	SEGMENT
??_C@_0CD@GIDABGCK@validating?5against?5a?5pattern?5fa@ DB 'validating ag'
	DB	'ainst a pattern facet', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BDJMPJNK@validating?5against?5an?5enumerati@
CONST	SEGMENT
??_C@_0CI@BDJMPJNK@validating?5against?5an?5enumerati@ DB 'validating aga'
	DB	'inst an enumeration facet', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IGJENPFO@validating?5against?5a?5list?5type?5@
CONST	SEGMENT
??_C@_0CF@IGJENPFO@validating?5against?5a?5list?5type?5@ DB 'validating a'
	DB	'gainst a list type facet', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NHJMGMIL@xmlSchemaValidateFacets@
CONST	SEGMENT
??_C@_0BI@NHJMGMIL@xmlSchemaValidateFacets@ DB 'xmlSchemaValidateFacets', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MOGKKGIH@validating?5against?5a?5atomic?5typ@
CONST	SEGMENT
??_C@_0CH@MOGKKGIH@validating?5against?5a?5atomic?5typ@ DB 'validating ag'
	DB	'ainst a atomic type facet', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FKKNFHGK@elem?5info?5has?5not?5been?5cleared@
CONST	SEGMENT
??_C@_0BP@FKKNFHGK@elem?5info?5has?5not?5been?5cleared@ DB 'elem info has'
	DB	' not been cleared', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LLLHNEDD@allocating?5an?5element?5info@
CONST	SEGMENT
??_C@_0BL@LLLHNEDD@allocating?5an?5element?5info@ DB 'allocating an eleme'
	DB	'nt info', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PDEOBEKK@re?9allocating?5the?5element?5info?5@
CONST	SEGMENT
??_C@_0CF@PDEOBEKK@re?9allocating?5the?5element?5info?5@ DB 're-allocatin'
	DB	'g the element info array', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CMDKBIBJ@allocating?5the?5element?5info?5arr@
CONST	SEGMENT
??_C@_0CC@CMDKBIBJ@allocating?5the?5element?5info?5arr@ DB 'allocating th'
	DB	'e element info array', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HLHJELLH@xmlSchemaGetFreshElemInfo@
CONST	SEGMENT
??_C@_0BK@HLHJELLH@xmlSchemaGetFreshElemInfo@ DB 'xmlSchemaGetFreshElemIn'
	DB	'fo', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KBPFIFIK@inconsistent?5depth?5encountered@
CONST	SEGMENT
??_C@_0BP@KBPFIFIK@inconsistent?5depth?5encountered@ DB 'inconsistent dep'
	DB	'th encountered', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PJGHNDDL@noNamespaceSchemaLocation@
CONST	SEGMENT
??_C@_0BK@PJGHNDDL@noNamespaceSchemaLocation@ DB 'noNamespaceSchemaLocati'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03ILAMHENH@nil@
CONST	SEGMENT
??_C@_03ILAMHENH@nil@ DB 'nil', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MIDCNBN@xmlSchemaPushAttribute@
CONST	SEGMENT
??_C@_0BH@MIDCNBN@xmlSchemaPushAttribute@ DB 'xmlSchemaPushAttribute', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JCDDMGJO@calling?5xmlSchemaGetFreshAttrIn@
CONST	SEGMENT
??_C@_0CE@JCDDMGJO@calling?5xmlSchemaGetFreshAttrIn@ DB 'calling xmlSchem'
	DB	'aGetFreshAttrInfo()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BOOKJCLG@creating?5new?5attribute?5info@
CONST	SEGMENT
??_C@_0BM@BOOKJCLG@creating?5new?5attribute?5info@ DB 'creating new attri'
	DB	'bute info', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LKOCBHBB@xmlSchemaGetFreshAttrInfo@
CONST	SEGMENT
??_C@_0BK@LKOCBHBB@xmlSchemaGetFreshAttrInfo@ DB 'xmlSchemaGetFreshAttrIn'
	DB	'fo', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PFNFPHPM@attr?5info?5not?5cleared@
CONST	SEGMENT
??_C@_0BG@PFNFPHPM@attr?5info?5not?5cleared@ DB 'attr info not cleared', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BAMAMEME@re?9allocating?5attribute?5info?5li@
CONST	SEGMENT
??_C@_0CC@BAMAMEME@re?9allocating?5attribute?5info?5li@ DB 're-allocating'
	DB	' attribute info list', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IEFJMMAN@allocating?5attribute?5info?5list@
CONST	SEGMENT
??_C@_0BP@IEFJMMAN@allocating?5attribute?5info?5list@ DB 'allocating attr'
	DB	'ibute info list', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DKEGLJJH@No?5match?5found?5for?5key?9sequence@
CONST	SEGMENT
??_C@_0DC@DKEGLJJH@No?5match?5found?5for?5key?9sequence@ DB 'No match fou'
	DB	'nd for key-sequence %s of keyref ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@GJPPLNCJ@More?5than?5one?5match?5found?5for?5k@
CONST	SEGMENT
??_C@_0DN@GJPPLNCJ@More?5than?5one?5match?5found?5for?5k@ DB 'More than o'
	DB	'ne match found for key-sequence %s of keyref ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KOFMLKDP@re?9allocating?5IDC?5list?5of?5node?9@
CONST	SEGMENT
??_C@_0CL@KOFMLKDP@re?9allocating?5IDC?5list?5of?5node?9@ DB 're-allocati'
	DB	'ng IDC list of node-table items', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JFHKHDCD@allocating?5IDC?5list?5of?5node?9tab@
CONST	SEGMENT
??_C@_0CI@JFHKHDCD@allocating?5IDC?5list?5of?5node?9tab@ DB 'allocating I'
	DB	'DC list of node-table items', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@INNNDFEE@allocating?5an?5IDC?5matcher@
CONST	SEGMENT
??_C@_0BK@INNNDFEE@allocating?5an?5IDC?5matcher@ DB 'allocating an IDC ma'
	DB	'tcher', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@HKBGOKJP@Could?5not?5find?5an?5augmented?5IDC@
CONST	SEGMENT
??_C@_0DL@HKBGOKJP@Could?5not?5find?5an?5augmented?5IDC@ DB 'Could not fi'
	DB	'nd an augmented IDC item for an IDC definition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FHFHOILP@xmlSchemaIDCRegisterMatchers@
CONST	SEGMENT
??_C@_0BN@FHFHOILP@xmlSchemaIDCRegisterMatchers@ DB 'xmlSchemaIDCRegister'
	DB	'Matchers', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@BCHPJJHO@The?5chain?5of?5IDC?5matchers?5is?5ex@
CONST	SEGMENT
??_C@_0DC@BCHPJJHO@The?5chain?5of?5IDC?5matchers?5is?5ex@ DB 'The chain o'
	DB	'f IDC matchers is expected to be empty', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@JEDCDBII@The?5state?5object?5to?5be?5removed?5@
CONST	SEGMENT
??_C@_0DM@JEDCDBII@The?5state?5object?5to?5be?5removed?5@ DB 'The state o'
	DB	'bject to be removed is not the first in the list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LOGANEIF@Not?5all?5fields?5of?5?$CFs?5evaluate?5t@
CONST	SEGMENT
??_C@_0CI@LOGANEIF@Not?5all?5fields?5of?5?$CFs?5evaluate?5t@ DB 'Not all '
	DB	'fields of %s evaluate to a node', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HMFENHHC@allocating?5an?5IDC?5node?9table?5it@
CONST	SEGMENT
??_C@_0CC@HMFENHHC@allocating?5an?5IDC?5node?9table?5it@ DB 'allocating a'
	DB	'n IDC node-table item', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LMIOLKEE@Duplicate?5key?9sequence?5?$CFs?5in?5?$CFs@
CONST	SEGMENT
??_C@_0CA@LMIOLKEE@Duplicate?5key?9sequence?5?$CFs?5in?5?$CFs@ DB 'Duplic'
	DB	'ate key-sequence %s in %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DNPMHACD@allocating?5a?5IDC?5key@
CONST	SEGMENT
??_C@_0BF@DNPMHACD@allocating?5a?5IDC?5key@ DB 'allocating a IDC key', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BFFMOABM@allocating?5an?5IDC?5key?9sequence@
CONST	SEGMENT
??_C@_0BP@BFFMOABM@allocating?5an?5IDC?5key?9sequence@ DB 'allocating an '
	DB	'IDC key-sequence', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@LNIGGAMO@The?5XPath?5?8?$CFs?8?5of?5a?5field?5of?5?$CFs@
CONST	SEGMENT
??_C@_0FC@LNIGGAMO@The?5XPath?5?8?$CFs?8?5of?5a?5field?5of?5?$CFs@ DB 'Th'
	DB	'e XPath ''%s'' of a field of %s evaluates to a node-set with '
	DB	'more than one member', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LFFCCCHC@reallocating?5an?5array?5of?5key?9se@
CONST	SEGMENT
??_C@_0CH@LFFCCCHC@reallocating?5an?5array?5of?5key?9se@ DB 'reallocating'
	DB	' an array of key-sequences', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MLBGNEED@allocating?5an?5array?5of?5key?9sequ@
CONST	SEGMENT
??_C@_0CF@MLBGNEED@allocating?5an?5array?5of?5key?9sequ@ DB 'allocating a'
	DB	'n array of key-sequences', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@IKFFNPGA@Warning?3?5No?5precomputed?5value?5a@
CONST	SEGMENT
??_C@_0GD@IKFFNPGA@Warning?3?5No?5precomputed?5value?5a@ DB 'Warning: No '
	DB	'precomputed value available, the value was either invalid or '
	DB	'something strange happend', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@FLEKOJFE@The?5XPath?5?8?$CFs?8?5of?5a?5field?5of?5?$CFs@
CONST	SEGMENT
??_C@_0EL@FLEKOJFE@The?5XPath?5?8?$CFs?8?5of?5a?5field?5of?5?$CFs@ DB 'Th'
	DB	'e XPath ''%s'' of a field of %s does evaluate to a node of no'
	DB	'n-simple type', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@MADPFADD@field?5resolves?5to?5a?5CT?5with?5sim@
CONST	SEGMENT
??_C@_0FD@MADPFADD@field?5resolves?5to?5a?5CT?5with?5sim@ DB 'field resol'
	DB	'ves to a CT with simple content but the CT is missing the ST '
	DB	'definition', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CBHGMMP@xmlSchemaXPathProcessHistory@
CONST	SEGMENT
??_C@_0BN@CBHGMMP@xmlSchemaXPathProcessHistory@ DB 'xmlSchemaXPathProcess'
	DB	'History', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HBBLPIID@calling?5xmlStreamPop?$CI?$CJ@
CONST	SEGMENT
??_C@_0BH@HBBLPIID@calling?5xmlStreamPop?$CI?$CJ@ DB 'calling xmlStreamPo'
	DB	'p()', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BBKEAIF@?$DP?$DP?$DP@
CONST	SEGMENT
??_C@_03BBKEAIF@?$DP?$DP?$DP@ DB '???', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@COPGMMIK@xmlSchemaFormatIDCKeySequence@
CONST	SEGMENT
??_C@_0BO@COPGMMIK@xmlSchemaFormatIDCKeySequence@ DB 'xmlSchemaFormatIDCK'
	DB	'eySequence', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HGOJGLAG@failed?5to?5compute?5a?5canonical?5v@
CONST	SEGMENT
??_C@_0CE@HGOJGLAG@failed?5to?5compute?5a?5canonical?5v@ DB 'failed to co'
	DB	'mpute a canonical value', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CCPCCKFB@re?9allocating?5the?5state?5object?5@
CONST	SEGMENT
??_C@_0CH@CCPCCKFB@re?9allocating?5the?5state?5object?5@ DB 're-allocatin'
	DB	'g the state object history', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OEKMEEHF@allocating?5the?5state?5object?5his@
CONST	SEGMENT
??_C@_0CE@OEKMEEHF@allocating?5the?5state?5object?5his@ DB 'allocating th'
	DB	'e state object history', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BGCDIJOO@xmlSchemaXPathEvaluate@
CONST	SEGMENT
??_C@_0BH@BGCDIJOO@xmlSchemaXPathEvaluate@ DB 'xmlSchemaXPathEvaluate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EPLNDPKO@calling?5xmlStreamPush?$CI?$CJ@
CONST	SEGMENT
??_C@_0BI@EPLNDPKO@calling?5xmlStreamPush?$CI?$CJ@ DB 'calling xmlStreamP'
	DB	'ush()', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EMBGPHEI@xmlSchemaIDCAddStateObject@
CONST	SEGMENT
??_C@_0BL@EMBGPHEI@xmlSchemaIDCAddStateObject@ DB 'xmlSchemaIDCAddStateOb'
	DB	'ject', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@MKAMKJFE@failed?5to?5create?5an?5XPath?5valid@
CONST	SEGMENT
??_C@_0CN@MKAMKJFE@failed?5to?5create?5an?5XPath?5valid@ DB 'failed to cr'
	DB	'eate an XPath validation context', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KMMMKNDG@allocating?5an?5IDC?5state?5object@
CONST	SEGMENT
??_C@_0BP@KMMMKNDG@allocating?5an?5IDC?5state?5object@ DB 'allocating an '
	DB	'IDC state object', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@OHLCMMHI@re?9allocating?5an?5array?5of?5IDC?5n@
CONST	SEGMENT
??_C@_0CP@OHLCMMHI@re?9allocating?5an?5array?5of?5IDC?5n@ DB 're-allocati'
	DB	'ng an array of IDC node-table items', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BBNGODJA@allocating?5an?5array?5of?5IDC?5node@
CONST	SEGMENT
??_C@_0CM@BBNGODJA@allocating?5an?5array?5of?5IDC?5node@ DB 'allocating a'
	DB	'n array of IDC node-table items', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OEOHKDEB@re?9allocating?5the?5IDC?5key?5stora@
CONST	SEGMENT
??_C@_0CH@OEOHKDEB@re?9allocating?5the?5IDC?5key?5stora@ DB 're-allocatin'
	DB	'g the IDC key storage list', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CCLJMNGF@allocating?5the?5IDC?5key?5storage?5@
CONST	SEGMENT
??_C@_0CE@CCLJMNGF@allocating?5the?5IDC?5key?5storage?5@ DB 'allocating t'
	DB	'he IDC key storage list', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PFEMPGNK@re?9allocating?5the?5IDC?5node?5tabl@
CONST	SEGMENT
??_C@_0CL@PFEMPGNK@re?9allocating?5the?5IDC?5node?5tabl@ DB 're-allocatin'
	DB	'g the IDC node table item list', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MOGKDPMG@allocating?5the?5IDC?5node?5table?5i@
CONST	SEGMENT
??_C@_0CI@MOGKDPMG@allocating?5the?5IDC?5node?5table?5i@ DB 'allocating t'
	DB	'he IDC node table item list', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDBDLPGB@allocating?5a?5PSVI?5IDC?5binding?5i@
CONST	SEGMENT
??_C@_0CD@HDBDLPGB@allocating?5a?5PSVI?5IDC?5binding?5i@ DB 'allocating a'
	DB	' PSVI IDC binding item', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@CAHAFNJE@xmlSchemaAugmentIDC?3?5allocating@
CONST	SEGMENT
??_C@_0DM@CAHAFNJE@xmlSchemaAugmentIDC?3?5allocating@ DB 'xmlSchemaAugmen'
	DB	'tIDC: allocating an augmented IDC definition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IMJIJGNM@xmlSchemaValidateNotation@
CONST	SEGMENT
??_C@_0BK@IMJIJGNM@xmlSchemaValidateNotation@ DB 'xmlSchemaValidateNotati'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LAHJCGKC@a?5schema?5is?5needed?5on?5the?5valid@
CONST	SEGMENT
??_C@_0CN@LAHJCGKC@a?5schema?5is?5needed?5on?5the?5valid@ DB 'a schema is'
	DB	' needed on the validation context', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NLHBOILD@xmlSchemaLookupNamespace@
CONST	SEGMENT
??_C@_0BJ@NLHBOILD@xmlSchemaLookupNamespace@ DB 'xmlSchemaLookupNamespace'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LAIFBHAE@no?5node?5or?5node?8s?5doc?5avaliable@
CONST	SEGMENT
??_C@_0CA@LAIFBHAE@no?5node?5or?5node?8s?5doc?5avaliable@ DB 'no node or '
	DB	'node''s doc avaliable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DHODCNOI@xmlSchemaAssembleByXSI@
CONST	SEGMENT
??_C@_0BH@DHODCNOI@xmlSchemaAssembleByXSI@ DB 'xmlSchemaAssembleByXSI', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HNFEMNKO@assembling?5schemata@
CONST	SEGMENT
??_C@_0BE@HNFEMNKO@assembling?5schemata@ DB 'assembling schemata', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@KDOLAGPK@The?5value?5must?5consist?5of?5tuple@
CONST	SEGMENT
??_C@_0FD@KDOLAGPK@The?5value?5must?5consist?5of?5tuple@ DB 'The value mu'
	DB	'st consist of tuples: the target namespace name and the docum'
	DB	'ent''s URI', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@OFHLHGBG@The?5document?5at?5location?5?8?$CFs?8?5c@
CONST	SEGMENT
??_C@_0DE@OFHLHGBG@The?5document?5at?5location?5?8?$CFs?8?5c@ DB 'The doc'
	DB	'ument at location ''%s'' could not be acquired', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IPNOOOA@xmlSchemaAssembleByLocation@
CONST	SEGMENT
??_C@_0BM@IPNOOOA@xmlSchemaAssembleByLocation@ DB 'xmlSchemaAssembleByLoc'
	DB	'ation', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JLNHNHFO@no?5parser?5context?5available@
CONST	SEGMENT
??_C@_0BM@JLNHNHFO@no?5parser?5context?5available@ DB 'no parser context '
	DB	'available', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DAONFGNJ@Internal?5Error@
CONST	SEGMENT
??_C@_0P@DAONFGNJ@Internal?5Error@ DB 'Internal Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FJHIALID@xmlSchemaParse@
CONST	SEGMENT
??_C@_0P@FJHIALID@xmlSchemaParse@ DB 'xmlSchemaParse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KBEKBABO@An?5internal?5error?5occurred@
CONST	SEGMENT
??_C@_0BL@KBEKBABO@An?5internal?5error?5occurred@ DB 'An internal error o'
	DB	'ccurred', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PCIDMOBP@Failed?5to?5locate?5the?5main?5schem@
CONST	SEGMENT
??_C@_0CK@PCIDMOBP@Failed?5to?5locate?5the?5main?5schem@ DB 'Failed to lo'
	DB	'cate the main schema resource', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HKCNLJOG@Failed?5to?5locate?5the?5main?5schem@
CONST	SEGMENT
??_C@_0DC@HKCNLJOG@Failed?5to?5locate?5the?5main?5schem@ DB 'Failed to lo'
	DB	'cate the main schema resource at ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NEPGNBMH@A?5global?5?$CFs?5?8?$CFs?8?5does?5already?5e@
CONST	SEGMENT
??_C@_0CE@NEPGNBMH@A?5global?5?$CFs?5?8?$CFs?8?5does?5already?5e@ DB 'A g'
	DB	'lobal %s ''%s'' does already exist', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HOKAKPAF@failed?5to?5create?5a?5component?5ha@
CONST	SEGMENT
??_C@_0CI@HOKAKPAF@failed?5to?5create?5a?5component?5ha@ DB 'failed to cr'
	DB	'eate a component hash table', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KEIDDOOE@xmlSchemaAddComponents@
CONST	SEGMENT
??_C@_0BH@KEIDDOOE@xmlSchemaAddComponents@ DB 'xmlSchemaAddComponents', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EHOCOMPJ@Unexpected?5global?5component?5typ@
CONST	SEGMENT
??_C@_0CB@EHOCOMPJ@Unexpected?5global?5component?5typ@ DB 'Unexpected glo'
	DB	'bal component type', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@OLGKEPPA@The?5referenced?5?$CFs?5was?5already?5r@
CONST	SEGMENT
??_C@_0GG@OLGKEPPA@The?5referenced?5?$CFs?5was?5already?5r@ DB 'The refer'
	DB	'enced %s was already redefined. Multiple redefinition of the '
	DB	'same component is not supported', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MJPJGEAA@xmlSchemaResolveRedefReferences@
CONST	SEGMENT
??_C@_0CA@MJPJGEAA@xmlSchemaResolveRedefReferences@ DB 'xmlSchemaResolveR'
	DB	'edefReferences', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NJALEOMP@Unexpected?5redefined?5component?5@
CONST	SEGMENT
??_C@_0CE@NJALEOMP@Unexpected?5redefined?5component?5@ DB 'Unexpected red'
	DB	'efined component type', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@DMAILEC@The?5?$CFs?5?8?$CFs?8?5to?5be?5redefined?5cou@
CONST	SEGMENT
??_C@_0EH@DMAILEC@The?5?$CFs?5?8?$CFs?8?5to?5be?5redefined?5cou@ DB 'The '
	DB	'%s ''%s'' to be redefined could not be found in the redefined'
	DB	' schema', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@FJLAHNCH@The?5cardinality?5of?5the?5keyref?5d@
CONST	SEGMENT
??_C@_0FN@FJLAHNCH@The?5cardinality?5of?5the?5keyref?5d@ DB 'The cardinal'
	DB	'ity of the keyref differs from the cardinality of the referen'
	DB	'ced key/unique ''%s''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JCIFOLN@The?5keyref?5references?5a?5keyref@
CONST	SEGMENT
??_C@_0BP@JCIFOLN@The?5keyref?5references?5a?5keyref@ DB 'The keyref refe'
	DB	'rences a keyref', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GP@GLBEFPEK@The?5?8fixed?8?5value?5constraint?5of@
CONST	SEGMENT
??_C@_0GP@GLBEFPEK@The?5?8fixed?8?5value?5constraint?5of@ DB 'The ''fixed'
	DB	''' value constraint of the attribute use must match the attri'
	DB	'bute declaration''s value constraint ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FBIHIMFL@xmlSchemaCheckAttrUsePropsCorre@
CONST	SEGMENT
??_C@_0CC@FBIHIMFL@xmlSchemaCheckAttrUsePropsCorre@ DB 'xmlSchemaCheckAtt'
	DB	'rUsePropsCorrect', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HM@EHFKHNMB@The?5attribute?5declaration?5has?5a@
CONST	SEGMENT
??_C@_0HM@EHFKHNMB@The?5attribute?5declaration?5has?5a@ DB 'The attribute'
	DB	' declaration has a ''fixed'' value constraint , thus the attr'
	DB	'ibute use must also have a ''fixed'' value constraint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HI@HIFFMALD@A?5model?5group?5definition?5is?5ref@
CONST	SEGMENT
??_C@_0HI@HIFFMALD@A?5model?5group?5definition?5is?5ref@ DB 'A model grou'
	DB	'p definition is referenced, but it contains an ''all'' model '
	DB	'group, which cannot be contained by model groups', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@INOHADNA@xmlSchemaElemCheckValConstr@
CONST	SEGMENT
??_C@_0BM@INOHADNA@xmlSchemaElemCheckValConstr@ DB 'xmlSchemaElemCheckVal'
	DB	'Constr', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@IFGBKADH@failed?5to?5validate?5the?5value?5co@
CONST	SEGMENT
??_C@_0EC@IFGBKADH@failed?5to?5validate?5the?5value?5co@ DB 'failed to va'
	DB	'lidate the value constraint of an element declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GP@ONEJGEGK@Internal?5error?3?5xmlSchemaCheckE@
CONST	SEGMENT
??_C@_0GP@ONEJGEGK@Internal?5error?3?5xmlSchemaCheckE@ DB 'Internal error'
	DB	': xmlSchemaCheckElemPropsCorrect, type is missing... skipping'
	DB	' validation of the value constraint', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0JP@GPCAONIJ@The?5type?5definition?5?$CIor?5type?5de@
CONST	SEGMENT
??_C@_0JP@GPCAONIJ@The?5type?5definition?5?$CIor?5type?5de@ DB 'The type '
	DB	'definition (or type definition''s content type) is or is deri'
	DB	'ved from ID; value constraints are not allowed in conjunction'
	DB	' with such a type definition', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IO@OBKDAHJI@The?5type?5definition?5?8?$CFs?8?5was?5ei@
CONST	SEGMENT
??_C@_0IO@OBKDAHJI@The?5type?5definition?5?8?$CFs?8?5was?5ei@ DB 'The typ'
	DB	'e definition ''%s'' was either rejected by the substitution g'
	DB	'roup affiliation ''%s'', or not validly derived from its type'
	DB	' definition ''%s''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FP@ECMLFAOK@The?5element?5declaration?5?8?$CFs?8?5de@
CONST	SEGMENT
??_C@_0FP@ECMLFAOK@The?5element?5declaration?5?8?$CFs?8?5de@ DB 'The elem'
	DB	'ent declaration ''%s'' defines a circular substitution group '
	DB	'to element declaration ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@CIIJKFO@Only?5global?5element?5declaration@
CONST	SEGMENT
??_C@_0EL@CIIJKFO@Only?5global?5element?5declaration@ DB 'Only global ele'
	DB	'ment declarations can have a substitution group affiliation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@DMDDKJIO@The?5value?5of?5the?5value?5constrai@
CONST	SEGMENT
??_C@_0CP@DMDDKJIO@The?5value?5of?5the?5value?5constrai@ DB 'The value of'
	DB	' the value constraint is not valid', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KEKKKHHB@xmlSchemaCheckAttrPropsCorrect@
CONST	SEGMENT
??_C@_0BP@KEKKKHHB@xmlSchemaCheckAttrPropsCorrect@ DB 'xmlSchemaCheckAttr'
	DB	'PropsCorrect', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@JBDCKHFC@Value?5constraints?5are?5not?5allow@
CONST	SEGMENT
??_C@_0FF@JBDCKHFC@Value?5constraints?5are?5not?5allow@ DB 'Value constra'
	DB	'ints are not allowed if the type definition is or is derived '
	DB	'from xs:ID', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0HN@PJGMJAIH@Skipping?5pointless?5attribute?5us@
CONST	SEGMENT
??_C@_0HN@PJGMJAIH@Skipping?5pointless?5attribute?5us@ DB 'Skipping point'
	DB	'less attribute use prohibition ''%s'', since a corresponding '
	DB	'attribute use exists already in the type definition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NLBCMGHN@xmlSchemaExpandAttributeGroupRe@
CONST	SEGMENT
??_C@_0CC@NLBCMGHN@xmlSchemaExpandAttributeGroupRe@ DB 'xmlSchemaExpandAt'
	DB	'tributeGroupRefs', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JIEJECEC@unexpected?5attr?5prohibition?5fou@
CONST	SEGMENT
??_C@_0CC@JIEJECEC@unexpected?5attr?5prohibition?5fou@ DB 'unexpected att'
	DB	'r prohibition found', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@FDECNJHO@Circular?5reference?5to?5the?5attri@
CONST	SEGMENT
??_C@_0DH@FDECNJHO@Circular?5reference?5to?5the?5attri@ DB 'Circular refe'
	DB	'rence to the attribute group ''%s'' defined', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@EEBKKJHN@Circular?5reference?5to?5the?5model@
CONST	SEGMENT
??_C@_0DO@EEBKKJHN@Circular?5reference?5to?5the?5model@ DB 'Circular refe'
	DB	'rence to the model group definition ''%s'' defined', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@BFJCEJH@The?5value?5?8?$CFs?8?5of?5the?5facet?5?8wh@
CONST	SEGMENT
??_C@_0DG@BFJCEJH@The?5value?5?8?$CFs?8?5of?5the?5facet?5?8wh@ DB 'The va'
	DB	'lue ''%s'' of the facet ''whitespace'' is not valid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MHKDLKBN@collapse@
CONST	SEGMENT
??_C@_08MHKDLKBN@collapse@ DB 'collapse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CLEHDIEJ@replace@
CONST	SEGMENT
??_C@_07CLEHDIEJ@replace@ DB 'replace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08ILAKLJGO@preserve@
CONST	SEGMENT
??_C@_08ILAKLJGO@preserve@ DB 'preserve', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HPIINFD@The?5value?5?8?$CFs?8?5of?5the?5facet?5?8?$CFs@
CONST	SEGMENT
??_C@_0DF@HPIINFD@The?5value?5?8?$CFs?8?5of?5the?5facet?5?8?$CFs@ DB 'The'
	DB	' value ''%s'' of the facet ''%s'' is not a valid ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PNFEGAHG@positiveInteger@
CONST	SEGMENT
??_C@_0BA@PNFEGAHG@positiveInteger@ DB 'positiveInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IEOLADAC@nonNegativeInteger@
CONST	SEGMENT
??_C@_0BD@IEOLADAC@nonNegativeInteger@ DB 'nonNegativeInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ODKMLHFB@validating?5facet?5value@
CONST	SEGMENT
??_C@_0BH@ODKMLHFB@validating?5facet?5value@ DB 'validating facet value', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@FMIFFGFN@The?5value?5?8?$CFs?8?5of?5the?5facet?5?8pa@
CONST	SEGMENT
??_C@_0EI@FMIFFGFN@The?5value?5?8?$CFs?8?5of?5the?5facet?5?8pa@ DB 'The v'
	DB	'alue ''%s'' of the facet ''pattern'' is not a valid regular e'
	DB	'xpression', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DKKABPAP@value?5was?5not?5computed@
CONST	SEGMENT
??_C@_0BH@DKKABPAP@value?5was?5not?5computed@ DB 'value was not computed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@BAMFGHGG@The?5value?5?8?$CFs?8?5of?5the?5facet?5doe@
CONST	SEGMENT
??_C@_0EJ@BAMFGHGG@The?5value?5?8?$CFs?8?5of?5the?5facet?5doe@ DB 'The va'
	DB	'lue ''%s'' of the facet does not validate against the base ty'
	DB	'pe ''%s''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GP@JDEDDDKD@Internal?5error?3?5xmlSchemaCheckF@
CONST	SEGMENT
??_C@_0GP@JDEDDDKD@Internal?5error?3?5xmlSchemaCheckF@ DB 'Internal error'
	DB	': xmlSchemaCheckFacet, failed to validate the value ''%s'' of'
	DB	' the facet ''%s'' against the base type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GOHHCECA@xmlSchemaCheckFacet@
CONST	SEGMENT
??_C@_0BE@GOHHCECA@xmlSchemaCheckFacet@ DB 'xmlSchemaCheckFacet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KJAODNIP@a?5type?5user?5derived?5type?5has?5no@
CONST	SEGMENT
??_C@_0CK@KJAODNIP@a?5type?5user?5derived?5type?5has?5no@ DB 'a type user'
	DB	' derived type has no base type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JIKEDLJK@xmlSchemaTypeFixup@
CONST	SEGMENT
??_C@_0BD@JIKEDLJK@xmlSchemaTypeFixup@ DB 'xmlSchemaTypeFixup', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@EHENJODP@this?5function?5needs?5a?5parser?5co@
CONST	SEGMENT
??_C@_0CF@EHENJODP@this?5function?5needs?5a?5parser?5co@ DB 'this functio'
	DB	'n needs a parser context', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BAD@EONAGGAE@A?5type?5cannot?5be?5derived?5by?5ext@
CONST	SEGMENT
??_C@_0BAD@EONAGGAE@A?5type?5cannot?5be?5derived?5by?5ext@ DB 'A type can'
	DB	'not be derived by extension from a type which has an ''all'' '
	DB	'model group in its {content type}, since this would produce a'
	DB	' ''sequence'' model group containing the ''all'' model group;'
	DB	' ''all'' model groups are not allowed to appear inside other '
	DB	'model groups', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BAF@GMDKHDD@The?5type?5has?5an?5?8all?8?5model?5gro@
CONST	SEGMENT
??_C@_0BAF@GMDKHDD@The?5type?5has?5an?5?8all?8?5model?5gro@ DB 'The type '
	DB	'has an ''all'' model group in its {content type} and thus can'
	DB	'not be derived from a non-empty type, since this would produc'
	DB	'e a ''sequence'' model group containing the ''all'' model gro'
	DB	'up; ''all'' model groups are not allowed to appear inside oth'
	DB	'er model groups', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@NFAALECG@Internal?5error?3?5xmlSchemaTypeFi@
CONST	SEGMENT
??_C@_0GG@NFAALECG@Internal?5error?3?5xmlSchemaTypeFi@ DB 'Internal error'
	DB	': xmlSchemaTypeFixup, complex type ''%s'' with <simpleContent'
	DB	'>: unhandled derivation case', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IB@IICIOIAO@Internal?5error?3?5xmlSchemaTypeFi@
CONST	SEGMENT
??_C@_0IB@IICIOIAO@Internal?5error?3?5xmlSchemaTypeFi@ DB 'Internal error'
	DB	': xmlSchemaTypeFixup, complex type ''%s'': the <extension>ed '
	DB	'base type is a complex type with no simple content type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0KG@MFOLBCHA@Internal?5error?3?5xmlSchemaTypeFi@
CONST	SEGMENT
??_C@_0KG@MFOLBCHA@Internal?5error?3?5xmlSchemaTypeFi@ DB 'Internal error'
	DB	': xmlSchemaTypeFixup, complex type ''%s'': the <simpleContent'
	DB	'><restriction> is missing a <simpleType> child, but was not c'
	DB	'atched by xmlSchemaCheckSRCCT()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JMGNNAEE@xmlSchemaFixupComplexType@
CONST	SEGMENT
??_C@_0BK@JMGNNAEE@xmlSchemaFixupComplexType@ DB 'xmlSchemaFixupComplexTy'
	DB	'pe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NHIHEMOP@xmlSchemaFixupSimpleTypeStageTw@
CONST	SEGMENT
??_C@_0CB@NHIHEMOP@xmlSchemaFixupSimpleTypeStageTw@ DB 'xmlSchemaFixupSim'
	DB	'pleTypeStageTwo', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DAFLJMHA@missing?5baseType@
CONST	SEGMENT
??_C@_0BB@DAFLJMHA@missing?5baseType@ DB 'missing baseType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EGJFJLNK@type?5has?5no?5base?9type?5assigned@
CONST	SEGMENT
??_C@_0BP@EGJFJLNK@type?5has?5no?5base?9type?5assigned@ DB 'type has no b'
	DB	'ase-type assigned', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HMJDLBFH@union?5type?5has?5no?5member?9types?5@
CONST	SEGMENT
??_C@_0CI@HMJDLBFH@union?5type?5has?5no?5member?9types?5@ DB 'union type '
	DB	'has no member-types assigned', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LJIHOMAE@xmlSchemaFixupSimpleTypeStageOn@
CONST	SEGMENT
??_C@_0CB@LJIHOMAE@xmlSchemaFixupSimpleTypeStageOn@ DB 'xmlSchemaFixupSim'
	DB	'pleTypeStageOne', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OOLPDECC@list?5type?5has?5no?5item?9type?5assi@
CONST	SEGMENT
??_C@_0CE@OOLPDECC@list?5type?5has?5no?5item?9type?5assi@ DB 'list type h'
	DB	'as no item-type assigned', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LPIBFCGM@xmlSchemaDeriveAndValidateFacet@
CONST	SEGMENT
??_C@_0CB@LPIBFCGM@xmlSchemaDeriveAndValidateFacet@ DB 'xmlSchemaDeriveAn'
	DB	'dValidateFacets', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JHOAJLMF@an?5error?5occurred@
CONST	SEGMENT
??_C@_0BC@JHOAJLMF@an?5error?5occurred@ DB 'an error occurred', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NFDGHLNP@deriving?5facets?0?5creating?5a?5fac@
CONST	SEGMENT
??_C@_0CH@NFDGHLNP@deriving?5facets?0?5creating?5a?5fac@ DB 'deriving fac'
	DB	'ets, creating a facet link', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@BCLDHCAD@The?5?8whitespace?8?5value?5has?5to?5b@
CONST	SEGMENT
??_C@_0GD@BCLDHCAD@The?5?8whitespace?8?5value?5has?5to?5b@ DB 'The ''whit'
	DB	'espace'' value has to be equal to or stronger than the ''whit'
	DB	'espace'' value of the base type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@JECLPMKG@The?5base?5type?8s?5facet?5is?5?8fixed@
CONST	SEGMENT
??_C@_0EB@JECLPMKG@The?5base?5type?8s?5facet?5is?5?8fixed@ DB 'The base t'
	DB	'ype''s facet is ''fixed'', thus the value must not differ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@EFACGABJ@It?5is?5an?5error?5for?5both?5?8?$CFs?8?5an@
CONST	SEGMENT
??_C@_0FC@EFACGABJ@It?5is?5an?5error?5for?5both?5?8?$CFs?8?5an@ DB 'It is'
	DB	' an error for both ''%s'' and ''%s'' to be specified on the s'
	DB	'ame type definition', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HG@KJDGAKFE@It?5is?5an?5error?5for?5both?5?8length@
CONST	SEGMENT
??_C@_0HG@KJDGAKFE@It?5is?5an?5error?5for?5both?5?8length@ DB 'It is an e'
	DB	'rror for both ''length'' and either of ''minLength'' or ''max'
	DB	'Length'' to be specified on the same type definition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
CONST	SEGMENT
??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@ DB ''' of the base type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
CONST	SEGMENT
??_C@_0N@LGLLBNBD@?5or?5equal?5to@ DB ' or equal to', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HHJDMGPP@?5less?5than@
CONST	SEGMENT
??_C@_0L@HHJDMGPP@?5less?5than@ DB ' less than', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EOMDOOFG@?5greater?5than@
CONST	SEGMENT
??_C@_0O@EOMDOOFG@?5greater?5than@ DB ' greater than', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BFLDGAFJ@?5equal?5to@
CONST	SEGMENT
??_C@_09BFLDGAFJ@?5equal?5to@ DB ' equal to', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
CONST	SEGMENT
??_C@_0M@HCGPHKGF@?8?5has?5to?5be@ DB ''' has to be', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HG@CLNEKDGF@If?5?$DMsimpleContent?$DO?5and?5?$DMextensi@
CONST	SEGMENT
??_C@_0HG@CLNEKDGF@If?5?$DMsimpleContent?$DO?5and?5?$DMextensi@ DB 'If <s'
	DB	'impleContent> and <extension> is used, the base type must be '
	DB	'a simple type. The base type ''%s'' is a complex type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0LD@GJIEKEIE@If?5?$DMsimpleContent?$DO?5and?5?$DMrestric@
CONST	SEGMENT
??_C@_0LD@GJIEKEIE@If?5?$DMsimpleContent?$DO?5and?5?$DMrestric@ DB 'If <s'
	DB	'impleContent> and <restriction> is used, the base type must b'
	DB	'e a simple type or a complex type with mixed content and part'
	DB	'icle emptiable. The base type ''%s'' is none of those', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IE@LDPFNCJG@A?5?$DMsimpleType?$DO?5is?5expected?5amon@
CONST	SEGMENT
??_C@_0IE@LDPFNCJG@A?5?$DMsimpleType?$DO?5is?5expected?5amon@ DB 'A <simp'
	DB	'leType> is expected among the children of <restriction>, if <'
	DB	'simpleContent> is used and the base type ''%s'' is a complex '
	DB	'type', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@MGOOHGBI@Internal?5error?3?5xmlSchemaCheckS@
CONST	SEGMENT
??_C@_0EJ@MGOOHGBI@Internal?5error?3?5xmlSchemaCheckS@ DB 'Internal error'
	DB	': xmlSchemaCheckSRCCT, ''%s'', base type has no content type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HG@OCMJPANJ@If?5using?5?$DMsimpleContent?$DO?5and?5?$DMr@
CONST	SEGMENT
??_C@_0HG@OCMJPANJ@If?5using?5?$DMsimpleContent?$DO?5and?5?$DMr@ DB 'If u'
	DB	'sing <simpleContent> and <restriction>, the base type must be'
	DB	' a complex type. The base type ''%s'' is a simple type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GP@CNIJIED@If?5using?5?$DMcomplexContent?$DO?0?5the?5@
CONST	SEGMENT
??_C@_0GP@CNIJIED@If?5using?5?$DMcomplexContent?$DO?0?5the?5@ DB 'If usin'
	DB	'g <complexContent>, the base type is expected to be a complex'
	DB	' type. The base type ''%s'' is a simple type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LCGEMILI@The?5type?5is?5not?5a?5valid?5restric@
CONST	SEGMENT
??_C@_0DF@LCGEMILI@The?5type?5is?5not?5a?5valid?5restric@ DB 'The type is'
	DB	' not a valid restriction of its base type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@PFEADGDA@If?5the?5content?5type?5is?5?8mixed?8?0@
CONST	SEGMENT
??_C@_0FM@PFEADGDA@If?5the?5content?5type?5is?5?8mixed?8?0@ DB 'If the co'
	DB	'ntent type is ''mixed'', then the content type of the base ty'
	DB	'pe must also be ''mixed''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HB@BKHGHMKG@The?5content?5type?5of?5the?5base?5ty@
CONST	SEGMENT
??_C@_0HB@BKHGHMKG@The?5content?5type?5of?5the?5base?5ty@ DB 'The content'
	DB	' type of the base type must be either empty or ''mixed'' (or '
	DB	'''elements-only'') and an emptiable particle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@JDFDINMM@The?5content?5type?5of?5the?5base?5ty@
CONST	SEGMENT
??_C@_0GE@JDFDINMM@The?5content?5type?5of?5the?5base?5ty@ DB 'The content'
	DB	' type of the base type must be either a simple type or ''mixe'
	DB	'd'' and an emptiable particle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@IHCAKODH@The?5?$HLcontent?5type?$HN?5?$CFs?5is?5not?5va@
CONST	SEGMENT
??_C@_0FE@IHCAKODH@The?5?$HLcontent?5type?$HN?5?$CFs?5is?5not?5va@ DB 'Th'
	DB	'e {content type} %s is not validly derived from the base type'
	DB	'''s {content type} %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@BNGFOOBI@The?5?8final?8?5of?5the?5base?5type?5de@
CONST	SEGMENT
??_C@_0DP@BNGFOOBI@The?5?8final?8?5of?5the?5base?5type?5de@ DB 'The ''fin'
	DB	'al'' of the base type definition contains ''restriction''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JAJFEDFA@The?5base?5type?5must?5be?5a?5complex@
CONST	SEGMENT
??_C@_0CF@JAJFEDFA@The?5base?5type?5must?5be?5a?5complex@ DB 'The base ty'
	DB	'pe must be a complex type', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@EGFIFAEL@The?5content?5type?5must?5be?5the?5si@
CONST	SEGMENT
??_C@_0CO@EGFIFAEL@The?5content?5type?5must?5be?5the?5si@ DB 'The content'
	DB	' type must be the simple base type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@GPKINKDA@The?5content?5type?5of?5both?0?5the?5t@
CONST	SEGMENT
??_C@_0FM@GPKINKDA@The?5content?5type?5of?5both?0?5the?5t@ DB 'The conten'
	DB	't type of both, the type and its base type, must either ''mix'
	DB	'ed'' or ''element-only''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@LMFNPNPH@The?5content?5type?5must?5specify?5a@
CONST	SEGMENT
??_C@_0CJ@LMFNPNPH@The?5content?5type?5must?5specify?5a@ DB 'The content '
	DB	'type must specify a particle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@CKGKOKMC@The?5?8final?8?5of?5the?5base?5type?5de@
CONST	SEGMENT
??_C@_0DN@CKGKOKMC@The?5?8final?8?5of?5the?5base?5type?5de@ DB 'The ''fin'
	DB	'al'' of the base type definition contains ''extension''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IE@LIFNGLDM@There?5must?5not?5exist?5more?5than?5@
CONST	SEGMENT
??_C@_0IE@LIFNGLDM@There?5must?5not?5exist?5more?5than?5@ DB 'There must '
	DB	'not exist more than one attribute declaration of type ''xs:ID'
	DB	''' (or derived from ''xs:ID''). The %s violates this constrai'
	DB	'nt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NMANGDLF@Duplicate?5?$CFs@
CONST	SEGMENT
??_C@_0N@NMANGDLF@Duplicate?5?$CFs@ DB 'Duplicate %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@DHFNNJDJ@If?5the?5base?5type?5is?5a?5simple?5ty@
CONST	SEGMENT
??_C@_0EN@DHFNNJDJ@If?5the?5base?5type?5is?5a?5simple?5ty@ DB 'If the bas'
	DB	'e type is a simple type, the derivation method must be ''exte'
	DB	'nsion''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MOGOJILI@xmlSchemaParseCheckCOSValidDefa@
CONST	SEGMENT
??_C@_0CD@MOGOJILI@xmlSchemaParseCheckCOSValidDefa@ DB 'xmlSchemaParseChe'
	DB	'ckCOSValidDefault', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HOPMNJDI@calling?5xmlSchemaVCheckCVCSimpl@
CONST	SEGMENT
??_C@_0CH@HOPMNJDI@calling?5xmlSchemaVCheckCVCSimpl@ DB 'calling xmlSchem'
	DB	'aVCheckCVCSimpleType()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IM@DDPGDFGG@For?5a?5string?5to?5be?5a?5valid?5defa@
CONST	SEGMENT
??_C@_0IM@DDPGDFGG@For?5a?5string?5to?5be?5a?5valid?5defa@ DB 'For a stri'
	DB	'ng to be a valid default, the type definition must be a simpl'
	DB	'e type or a complex type with mixed content and a particle em'
	DB	'ptiable', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@FMHFMMBK@Internal?5error?3?5xmlSchemaCreate@
CONST	SEGMENT
??_C@_0FL@FMHFMMBK@Internal?5error?3?5xmlSchemaCreate@ DB 'Internal error'
	DB	': xmlSchemaCreateVCtxtOnPCtxt, failed to create a temp. valid'
	DB	'ation context.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@MIEEABNE@The?5member?5type?5?$CFs?5is?5not?5valid@
CONST	SEGMENT
??_C@_0GE@MIEEABNE@The?5member?5type?5?$CFs?5is?5not?5valid@ DB 'The memb'
	DB	'er type %s is not validly derived from its corresponding memb'
	DB	'er type %s of the base type %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HOHKAHOI@different?5number?5of?5member?5type@
CONST	SEGMENT
??_C@_0CJ@HOHKAHOI@different?5number?5of?5member?5type@ DB 'different num'
	DB	'ber of member types in base', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MIGLCPEH@The?5base?5type?5?8?$CFs?8?5is?5not?5a?5uni@
CONST	SEGMENT
??_C@_0CH@MIGLCPEH@The?5base?5type?5?8?$CFs?8?5is?5not?5a?5uni@ DB 'The b'
	DB	'ase type ''%s'' is not a union type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LHNABEDG@No?5facets?5allowed@
CONST	SEGMENT
??_C@_0BC@LHNABEDG@No?5facets?5allowed@ DB 'No facets allowed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GMGLNPMG@The?5?8final?8?5of?5member?5type?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0DB@GMGLNPMG@The?5?8final?8?5of?5member?5type?5?8?$CFs?8@ DB 'The '''
	DB	'final'' of member type ''%s'' contains ''union''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@JIAIGPPB@The?5member?5type?5?8?$CFs?8?5is?5neither@
CONST	SEGMENT
??_C@_0DL@JIAIGPPB@The?5member?5type?5?8?$CFs?8?5is?5neither@ DB 'The mem'
	DB	'ber type ''%s'' is neither an atomic, nor a list type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@JBMOEDMD@The?5item?5type?5?8?$CFs?8?5is?5not?5valid@
CONST	SEGMENT
??_C@_0FI@JBMOEDMD@The?5item?5type?5?8?$CFs?8?5is?5not?5valid@ DB 'The it'
	DB	'em type ''%s'' is not validly derived from the item type ''%s'
	DB	''' of the base type ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CKGJJDPM@failed?5to?5eval?5the?5item?5type?5of@
CONST	SEGMENT
??_C@_0CM@CKGJJDPM@failed?5to?5eval?5the?5item?5type?5of@ DB 'failed to e'
	DB	'val the item type of a base type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@DKPMMCLA@The?5?8final?8?5of?5the?5base?5type?5?8?$CF@
CONST	SEGMENT
??_C@_0EB@DKPMMCLA@The?5?8final?8?5of?5the?5base?5type?5?8?$CF@ DB 'The '''
	DB	'final'' of the base type ''%s'' must not contain ''restrictio'
	DB	'n''', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GNOCMONM@The?5base?5type?5?8?$CFs?8?5must?5be?5a?5li@
CONST	SEGMENT
??_C@_0CH@GNOCMONM@The?5base?5type?5?8?$CFs?8?5must?5be?5a?5li@ DB 'The b'
	DB	'ase type ''%s'' must be a list type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@HJPNFIBB@The?5final?5of?5its?5item?5type?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0DI@HJPNFIBB@The?5final?5of?5its?5item?5type?5?8?$CFs?8@ DB 'The fi'
	DB	'nal of its item type ''%s'' must not contain ''list''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@NONGNEND@The?5item?5type?5is?5a?5union?5type?0?5@
CONST	SEGMENT
??_C@_0FI@NONGNEND@The?5item?5type?5is?5a?5union?5type?0?5@ DB 'The item '
	DB	'type is a union type, but the member type ''%s'' of this item'
	DB	' type is not atomic', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@CNOGHMHL@The?5item?5type?5?8?$CFs?8?5does?5not?5hav@
CONST	SEGMENT
??_C@_0DO@CNOGHMHL@The?5item?5type?5?8?$CFs?8?5does?5not?5hav@ DB 'The it'
	DB	'em type ''%s'' does not have a variety of atomic or union', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HJDIBIBN@failed?5to?5evaluate?5the?5item?5typ@
CONST	SEGMENT
??_C@_0CB@HJDIBIBN@failed?5to?5evaluate?5the?5item?5typ@ DB 'failed to ev'
	DB	'aluate the item type', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KLLNOLEJ@failed?5to?5get?5primitive?5type@
CONST	SEGMENT
??_C@_0BN@KLLNOLEJ@failed?5to?5get?5primitive?5type@ DB 'failed to get pr'
	DB	'imitive type', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KJOCHNDL@The?5final?5of?5its?5base?5type?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0DP@KJOCHNDL@The?5final?5of?5its?5base?5type?5?8?$CFs?8@ DB 'The fi'
	DB	'nal of its base type ''%s'' must not contain ''restriction''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BHMFPHHO@The?5base?5type?5?8?$CFs?8?5is?5not?5an?5at@
CONST	SEGMENT
??_C@_0DA@BHMFPHHO@The?5base?5type?5?8?$CFs?8?5is?5not?5an?5at@ DB 'The b'
	DB	'ase type ''%s'' is not an atomic simple type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JGCJPHDI@xmlSchemaCheckCOSSTRestricts@
CONST	SEGMENT
??_C@_0BN@JGCJPHDI@xmlSchemaCheckCOSSTRestricts@ DB 'xmlSchemaCheckCOSSTR'
	DB	'estricts', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LMHOOJIC@given?5type?5is?5not?5a?5user?9derive@
CONST	SEGMENT
??_C@_0CM@LMHOOJIC@given?5type?5is?5not?5a?5user?9derive@ DB 'given type '
	DB	'is not a user-derived simpleType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@JOOLHCHD@The?5?8final?8?5of?5its?5base?5type?5?8?$CF@
CONST	SEGMENT
??_C@_0EB@JOOLHCHD@The?5?8final?8?5of?5its?5base?5type?5?8?$CF@ DB 'The '''
	DB	'final'' of its base type ''%s'' must not contain ''restrictio'
	DB	'n''', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NAEJKMEI@The?5variety?5is?5absent@
CONST	SEGMENT
??_C@_0BG@NAEJKMEI@The?5variety?5is?5absent@ DB 'The variety is absent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@OJPAIDNO@A?5type?0?5derived?5by?5list?5or?5unio@
CONST	SEGMENT
??_C@_0GB@OJPAIDNO@A?5type?0?5derived?5by?5list?5or?5unio@ DB 'A type, de'
	DB	'rived by list or union, must have the simple ur-type definiti'
	DB	'on as base type, not ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BABCEAKF@The?5base?5type?5?8?$CFs?8?5is?5not?5a?5sim@
CONST	SEGMENT
??_C@_0CI@BABCEAKF@The?5base?5type?5?8?$CFs?8?5is?5not?5a?5sim@ DB 'The b'
	DB	'ase type ''%s'' is not a simple type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PPOHGOMN@No?5base?5type?5existent@
CONST	SEGMENT
??_C@_0BG@PPOHGOMN@No?5base?5type?5existent@ DB 'No base type existent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@NJGNMMEM@The?5particle?8s?5?$HLmax?5occurs?$HN?5mus@
CONST	SEGMENT
??_C@_0FM@NJGNMMEM@The?5particle?8s?5?$HLmax?5occurs?$HN?5mus@ DB 'The pa'
	DB	'rticle''s {max occurs} must be 1, since the reference resolve'
	DB	's to an ''all'' model group', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FDHFJMFM@The?5union?5type?5definition?5is?5ci@
CONST	SEGMENT
??_C@_0CG@FDHFJMFM@The?5union?5type?5definition?5is?5ci@ DB 'The union ty'
	DB	'pe definition is circular', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KGAFCIDP@The?5definition?5is?5circular@
CONST	SEGMENT
??_C@_0BL@KGAFCIDP@The?5definition?5is?5circular@ DB 'The definition is c'
	DB	'ircular', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FJOPIFJN@failed?5to?5expand?5attributes@
CONST	SEGMENT
??_C@_0BM@FJOPIFJN@failed?5to?5expand?5attributes@ DB 'failed to expand a'
	DB	'ttributes', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OFHPNPHI@xmlSchemaFixupTypeAttributeUses@
CONST	SEGMENT
??_C@_0CA@OFHPNPHI@xmlSchemaFixupTypeAttributeUses@ DB 'xmlSchemaFixupTyp'
	DB	'eAttributeUses', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OMCNPMDL@no?5base?5type@
CONST	SEGMENT
??_C@_0N@OMCNPMDL@no?5base?5type@ DB 'no base type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@HDNJNNIO@The?5?$HLprocess?5contents?$HN?5of?5the?5a@
CONST	SEGMENT
??_C@_0FK@HDNJNNIO@The?5?$HLprocess?5contents?$HN?5of?5the?5a@ DB 'The {p'
	DB	'rocess contents} of the attribute wildcard is weaker than the'
	DB	' one in the %s %s ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@KINLKDD@The?5attribute?5wildcard?5is?5not?5a@
CONST	SEGMENT
??_C@_0EP@KINLKDD@The?5attribute?5wildcard?5is?5not?5a@ DB 'The attribute'
	DB	' wildcard is not a valid subset of the wildcard in the %s %s '
	DB	'''%s''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@LKDIOLEM@The?5?$CFs?5has?5an?5attribute?5wildcar@
CONST	SEGMENT
??_C@_0EH@LKDIOLEM@The?5?$CFs?5has?5an?5attribute?5wildcar@ DB 'The %s ha'
	DB	's an attribute wildcard, but the %s %s ''%s'' does not have o'
	DB	'ne', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@JCFCIHDB@A?5matching?5attribute?5use?5for?5th@
CONST	SEGMENT
??_C@_0EH@JCFCIHDB@A?5matching?5attribute?5use?5for?5th@ DB 'A matching a'
	DB	'ttribute use for the ''required'' %s of the %s %s is missing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@EJIDKJHC@Neither?5a?5matching?5attribute?5us@
CONST	SEGMENT
??_C@_0EO@EJIDKJHC@Neither?5a?5matching?5attribute?5us@ DB 'Neither a mat'
	DB	'ching attribute use, nor a matching wildcard exists in the %s'
	DB	' %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@OJPOJNKC@The?5effective?5value?5constraint?5@
CONST	SEGMENT
??_C@_0GI@OJPOJNKC@The?5effective?5value?5constraint?5@ DB 'The effective'
	DB	' value constraint of the attribute use is inconsistent with i'
	DB	'ts correspondent in the %s %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HK@BBMHJBAP@The?5attribute?5declaration?8s?5?$CFs?5@
CONST	SEGMENT
??_C@_0HK@BBMHJBAP@The?5attribute?5declaration?8s?5?$CFs?5@ DB 'The attri'
	DB	'bute declaration''s %s is not validly derived from the corres'
	DB	'ponding %s of the attribute declaration in the %s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@JGCEGOAB@The?5?8optional?8?5attribute?5use?5is@
CONST	SEGMENT
??_C@_0GK@JGCEGOAB@The?5?8optional?8?5attribute?5use?5is@ DB 'The ''optio'
	DB	'nal'' attribute use is inconsistent with the corresponding '''
	DB	'required'' attribute use of the %s %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KLOJBFOH@redefined@
CONST	SEGMENT
??_C@_09KLOJBFOH@redefined@ DB 'redefined', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@DJLMCEFH@The?5intersection?5of?5the?5wilcard@
CONST	SEGMENT
??_C@_0DF@DJLMCEFH@The?5intersection?5of?5the?5wilcard@ DB 'The intersect'
	DB	'ion of the wilcard is not expressible.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HFHAKEB@The?5union?5of?5the?5wilcard?5is?5not@
CONST	SEGMENT
??_C@_0CO@HFHAKEB@The?5union?5of?5the?5wilcard?5is?5not@ DB 'The union of'
	DB	' the wilcard is not expressible.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ENHIIAOL@allocating?5a?5type?5link@
CONST	SEGMENT
??_C@_0BH@ENHIIAOL@allocating?5a?5type?5link@ DB 'allocating a type link', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LIFKLDKP@type?5definition@
CONST	SEGMENT
??_C@_0BA@LIFKLDKP@type?5definition@ DB 'type definition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FHONPKDJ@The?5content?5model?5is?5not?5determ@
CONST	SEGMENT
??_C@_0CF@FHONPKDJ@The?5content?5model?5is?5not?5determ@ DB 'The content '
	DB	'model is not determinist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GNJHIDLA@Failed?5to?5compile?5the?5content?5m@
CONST	SEGMENT
??_C@_0CE@GNJHIDLA@Failed?5to?5compile?5the?5content?5m@ DB 'Failed to co'
	DB	'mpile the content model', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@ONMINIGJ@Cannot?5create?5automata?5for?5comp@
CONST	SEGMENT
??_C@_0CM@ONMINIGJ@Cannot?5create?5automata?5for?5comp@ DB 'Cannot create'
	DB	' automata for complex type %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@JHALJFOD@found?5unexpected?5term?5of?5type?5?8@
CONST	SEGMENT
??_C@_0DE@JHALJFOD@found?5unexpected?5term?5of?5type?5?8@ DB 'found unexp'
	DB	'ected term of type ''%s'' in content model', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LJGCIBKB@?$DMelement?$DO?5particle?5has?5no?5term@
CONST	SEGMENT
??_C@_0BP@LJGCIBKB@?$DMelement?$DO?5particle?5has?5no?5term@ DB '<element'
	DB	'> particle has no term', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HHPDPMCK@xmlSchemaBuildAContentModel@
CONST	SEGMENT
??_C@_0BM@HHPDPMCK@xmlSchemaBuildAContentModel@ DB 'xmlSchemaBuildAConten'
	DB	'tModel', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IKBLLFGH@particle?5is?5NULL@
CONST	SEGMENT
??_C@_0BB@IKBLLFGH@particle?5is?5NULL@ DB 'particle is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HK@IHMHBPHC@Internal?5error?3?5xmlSchemaBuildC@
CONST	SEGMENT
??_C@_0HK@IHMHBPHC@Internal?5error?3?5xmlSchemaBuildC@ DB 'Internal error'
	DB	': xmlSchemaBuildContentModelForSubstGroup, declaration is mar'
	DB	'ked having a subst. group but none available.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@BCLPNLHN@This?5is?5a?5redefinition?0?5thus?5th@
CONST	SEGMENT
??_C@_0GE@BCLPNLHN@This?5is?5a?5redefinition?0?5thus?5th@ DB 'This is a r'
	DB	'edefinition, thus the <complexType> must have a <restriction>'
	DB	' or <extension> grand-child', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IH@OBLFEMHP@?$CIannotation?$DP?0?5?$CIsimpleContent?5?$HM?5@
CONST	SEGMENT
??_C@_0IH@OBLFEMHP@?$CIannotation?$DP?0?5?$CIsimpleContent?5?$HM?5@ DB '('
	DB	'annotation?, (simpleContent | complexContent | ((group | all '
	DB	'| choice | sequence)?, ((attribute | attributeGroup)*, anyAtt'
	DB	'ribute?))))', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LGKPFEB@complexContent@
CONST	SEGMENT
??_C@_0P@LGKPFEB@complexContent@ DB 'complexContent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EFHOFDNO@simpleContent@
CONST	SEGMENT
??_C@_0O@EFHOFDNO@simpleContent@ DB 'simpleContent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OCCOHGHC@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@
CONST	SEGMENT
??_C@_0CM@OCCOHGHC@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@ DB '('
	DB	'#all | List of (extension | restriction)) ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05IPHDHIPP@mixed@
CONST	SEGMENT
??_C@_05IPHDHIPP@mixed@ DB 'mixed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BJCOBFBF@?$CIannotation?$DP?0?5?$CIrestriction?5?$HM?5ex@
CONST	SEGMENT
??_C@_0CJ@BJCOBFBF@?$CIannotation?$DP?0?5?$CIrestriction?5?$HM?5ex@ DB '('
	DB	'annotation?, (restriction | extension))', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@NILNJLFH@?$CIannotation?$DP?0?5?$CI?$CIgroup?5?$HM?5all?5?$HM?5c@
CONST	SEGMENT
??_C@_0GE@NILNJLFH@?$CIannotation?$DP?0?5?$CI?$CIgroup?5?$HM?5all?5?$HM?5c@ DB '('
	DB	'annotation?, ((group | all | choice | sequence)?, ((attribute'
	DB	' | attributeGroup)*, anyAttribute?)))', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0MA@MDLOJGLL@?$CIannotation?$DP?0?5?$CIsimpleType?$DP?0?5?$CImi@
CONST	SEGMENT
??_C@_0MA@MDLOJGLL@?$CIannotation?$DP?0?5?$CIsimpleType?$DP?0?5?$CImi@ DB '('
	DB	'annotation?, (simpleType?, (minExclusive | minInclusive | max'
	DB	'Exclusive | maxInclusive | totalDigits | fractionDigits | len'
	DB	'gth | minLength | maxLength | enumeration | whiteSpace | patt'
	DB	'ern)*))', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0PB@MMDBBLJD@?$CIannotation?$DP?0?5?$CIsimpleType?$DP?0?5?$CImi@
CONST	SEGMENT
??_C@_0PB@MMDBBLJD@?$CIannotation?$DP?0?5?$CIsimpleType?$DP?0?5?$CImi@ DB '('
	DB	'annotation?, (simpleType?, (minExclusive | minInclusive | max'
	DB	'Exclusive | maxInclusive | totalDigits | fractionDigits | len'
	DB	'gth | minLength | maxLength | enumeration | whiteSpace | patt'
	DB	'ern)*)?, ((attribute | attributeGroup)*, anyAttribute?))', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@CPHLEAHN@annotation?$DP?0?5?$CIgroup?5?$HM?5all?5?$HM?5cho@
CONST	SEGMENT
??_C@_0GB@CPHLEAHN@annotation?$DP?0?5?$CIgroup?5?$HM?5all?5?$HM?5cho@ DB 'a'
	DB	'nnotation?, (group | all | choice | sequence)?, ((attribute |'
	DB	' attributeGroup)*, anyAttribute?))', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BKMOEBCP@allocating?5a?5facet?5link@
CONST	SEGMENT
??_C@_0BI@BKMOEBCP@allocating?5a?5facet?5link@ DB 'allocating a facet lin'
	DB	'k', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@KBNCPLAN@Either?5the?5attribute?5?8base?8?5or?5@
CONST	SEGMENT
??_C@_0EE@KBNCPLAN@Either?5the?5attribute?5?8base?8?5or?5@ DB 'Either the'
	DB	' attribute ''base'' or a <simpleType> child must be present', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@NLLIFAIL@The?5attribute?5?8base?8?5and?5the?5?$DMs@
CONST	SEGMENT
??_C@_0EH@NLLIFAIL@The?5attribute?5?8base?8?5and?5the?5?$DMs@ DB 'The att'
	DB	'ribute ''base'' and the <simpleType> child are mutually exclu'
	DB	'sive', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0HE@HDNCABHM@This?5is?5a?5redefinition?0?5but?5the@
CONST	SEGMENT
??_C@_0HE@HDNCABHM@This?5is?5a?5redefinition?0?5but?5the@ DB 'This is a r'
	DB	'edefinition, but the QName value ''%s'' of the ''base'' attri'
	DB	'bute does not match the type''s designation ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BHIIPFEC@base@
CONST	SEGMENT
??_C@_04BHIIPFEC@base@ DB 'base', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@EMLAMPJB@?$CIannotation?$DP?0?5?$CIelement?5?$HM?5group?5@
CONST	SEGMENT
??_C@_0DM@EMLAMPJB@?$CIannotation?$DP?0?5?$CIelement?5?$HM?5group?5@ DB '('
	DB	'annotation?, (element | group | choice | sequence | any)*)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IM@HPEJBILG@The?5redefining?5model?5group?5defi@
CONST	SEGMENT
??_C@_0IM@HPEJBILG@The?5redefining?5model?5group?5defi@ DB 'The redefinin'
	DB	'g model group definition ''%s'' must not contain a reference '
	DB	'to the redefined definition with a maxOccurs/minOccurs other '
	DB	'than 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0HA@PEPECPEK@The?5redefining?5model?5group?5defi@
CONST	SEGMENT
??_C@_0HA@PEPECPEK@The?5redefining?5model?5group?5defi@ DB 'The redefinin'
	DB	'g model group definition ''%s'' must not contain more than on'
	DB	'e reference to the redefined definition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OBJFJEBA@any@
CONST	SEGMENT
??_C@_03OBJFJEBA@any@ DB 'any', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DCDFMCOM@?$CIannotation?$DP?0?5?$CIannotation?$DP?0?5ele@
CONST	SEGMENT
??_C@_0CG@DCDFMCOM@?$CIannotation?$DP?0?5?$CIannotation?$DP?0?5ele@ DB '('
	DB	'annotation?, (annotation?, element*)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JOJFLDM@Invalid?5value?5for?5maxOccurs?5?$CImu@
CONST	SEGMENT
??_C@_0CN@JOJFLDM@Invalid?5value?5for?5maxOccurs?5?$CImu@ DB 'Invalid val'
	DB	'ue for maxOccurs (must be 0 or 1)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GPAMDNEI@Invalid?5value?5for?5minOccurs?5?$CImu@
CONST	SEGMENT
??_C@_0CN@GPAMDNEI@Invalid?5value?5for?5minOccurs?5?$CImu@ DB 'Invalid va'
	DB	'lue for minOccurs (must be 0 or 1)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OCHOELKN@?$CI0?5?$HM?51?$CJ@
CONST	SEGMENT
??_C@_07OCHOELKN@?$CI0?5?$HM?51?$CJ@ DB '(0 | 1)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@OHBEFOEM@?$CIannotation?5?$HM?5?$CIsimpleType?5?$HM?5com@
CONST	SEGMENT
??_C@_0EE@OHBEFOEM@?$CIannotation?5?$HM?5?$CIsimpleType?5?$HM?5com@ DB '('
	DB	'annotation | (simpleType | complexType | group | attributeGro'
	DB	'up))*', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0HF@NFPCCAHE@The?5target?5namespace?5?8?$CFs?8?5of?5th@
CONST	SEGMENT
??_C@_0HF@NFPCCAHE@The?5target?5namespace?5?8?$CFs?8?5of?5th@ DB 'The tar'
	DB	'get namespace ''%s'' of the included/redefined schema ''%s'' '
	DB	'differs from ''%s'' of the including/redefining schema', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IL@MIGJBHGC@The?5target?5namespace?5of?5the?5inc@
CONST	SEGMENT
??_C@_0IL@MIGJBHGC@The?5target?5namespace?5of?5the?5inc@ DB 'The target n'
	DB	'amespace of the included/redefined schema ''%s'' has to be ab'
	DB	'sent, since the including/redefining schema has no target nam'
	DB	'espace', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DJHEKCBE@Failed?5to?5load?5the?5document?5?8?$CFs@
CONST	SEGMENT
??_C@_0DC@DJHEKCBE@Failed?5to?5load?5the?5document?5?8?$CFs@ DB 'Failed t'
	DB	'o load the document ''%s'' for redefinition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@PKPHBKIC@Failed?5to?5load?5the?5document?5?8?$CFs@
CONST	SEGMENT
??_C@_0CP@PKPHBKIC@Failed?5to?5load?5the?5document?5?8?$CFs@ DB 'Failed t'
	DB	'o load the document ''%s'' for inclusion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@JGHKIBFN@The?5schema?5document?5?8?$CFs?8?5cannot@
CONST	SEGMENT
??_C@_0DA@JGHKIBFN@The?5schema?5document?5?8?$CFs?8?5cannot@ DB 'The sche'
	DB	'ma document ''%s'' cannot include itself.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@IGEPJIPN@The?5schema?5document?5?8?$CFs?8?5cannot@
CONST	SEGMENT
??_C@_0DB@IGEPJIPN@The?5schema?5document?5?8?$CFs?8?5cannot@ DB 'The sche'
	DB	'ma document ''%s'' cannot redefine itself.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NKMDDHKI@xmlSchemaParseIncludeOrRedefine@
CONST	SEGMENT
??_C@_0CA@NKMDDHKI@xmlSchemaParseIncludeOrRedefine@ DB 'xmlSchemaParseInc'
	DB	'ludeOrRedefine', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@EKIECFJN@could?5not?5build?5an?5URI?5from?5the@
CONST	SEGMENT
??_C@_0CP@EKIECFJN@could?5not?5build?5an?5URI?5from?5the@ DB 'could not b'
	DB	'uild an URI from the schemaLocation', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@NKOOPGEC@Failed?5to?5locate?5a?5schema?5at?5lo@
CONST	SEGMENT
??_C@_0EA@NKOOPGEC@Failed?5to?5locate?5a?5schema?5at?5lo@ DB 'Failed to l'
	DB	'ocate a schema at location ''%s''. Skipping the import', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@GDFMFMFB@The?5attribute?5?8namespace?8?5must?5@
CONST	SEGMENT
??_C@_0FL@GDFMFMFB@The?5attribute?5?8namespace?8?5must?5@ DB 'The attribu'
	DB	'te ''namespace'' must be existent if the importing schema has'
	DB	' no target namespace', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@OLOMMMCB@The?5value?5of?5the?5attribute?5?8nam@
CONST	SEGMENT
??_C@_0GI@OLOMMMCB@The?5value?5of?5the?5attribute?5?8nam@ DB 'The value o'
	DB	'f the attribute ''namespace'' must not match the target names'
	DB	'pace ''%s'' of the importing schema', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DEMHLMFE@schemaLocation@
CONST	SEGMENT
??_C@_0P@DEMHLMFE@schemaLocation@ DB 'schemaLocation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HFPALNHL@The?5XML?5document?5?8?$CFs?8?5is?5not?5a?5@
CONST	SEGMENT
??_C@_0CP@HFPALNHL@The?5XML?5document?5?8?$CFs?8?5is?5not?5a?5@ DB 'The X'
	DB	'ML document ''%s'' is not a schema document', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06KICAKOOL@schema@
CONST	SEGMENT
??_C@_06KICAKOOL@schema@ DB 'schema', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LEAJAMEE@The?5document?5?8?$CFs?8?5has?5no?5docume@
CONST	SEGMENT
??_C@_0CK@LEAJAMEE@The?5document?5?8?$CFs?8?5has?5no?5docume@ DB 'The doc'
	DB	'ument ''%s'' has no document element', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@KKBODFED@No?5information?5for?5parsing?5was?5@
CONST	SEGMENT
??_C@_0EP@KKBODFED@No?5information?5for?5parsing?5was?5@ DB 'No informati'
	DB	'on for parsing was provided with the given schema parser cont'
	DB	'ext.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MKFNOEJC@Failed?5to?5parse?5the?5XML?5resourc@
CONST	SEGMENT
??_C@_0CG@MKFNOEJC@Failed?5to?5parse?5the?5XML?5resourc@ DB 'Failed to pa'
	DB	'rse the XML resource ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KMMHPBMO@xmlSchemaGetDoc?0?5allocating?5a?5p@
CONST	SEGMENT
??_C@_0CN@KMMHPBMO@xmlSchemaGetDoc?0?5allocating?5a?5p@ DB 'xmlSchemaGetD'
	DB	'oc, allocating a parser context', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PEDNHGDB@xmlSchemaAddSchemaDoc@
CONST	SEGMENT
??_C@_0BG@PEDNHGDB@xmlSchemaAddSchemaDoc@ DB 'xmlSchemaAddSchemaDoc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@FCNDNFNE@trying?5to?5load?5a?5schema?5doc?0?5bu@
CONST	SEGMENT
??_C@_0FA@FCNDNFNE@trying?5to?5load?5a?5schema?5doc?0?5bu@ DB 'trying to '
	DB	'load a schema doc, but a doc is already assigned to the schem'
	DB	'a bucket', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0IM@HCCFLAGC@Skipping?5import?5of?5schema?5locat@
CONST	SEGMENT
??_C@_0IM@HCCFLAGC@Skipping?5import?5of?5schema?5locat@ DB 'Skipping impo'
	DB	'rt of schema located at ''%s'' for the namespace ''%s'', sinc'
	DB	'e this namespace was already imported with the schema located'
	DB	' at ''%s''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@DIIKKJHP@The?5schema?5document?5?8?$CFs?8?5cannot@
CONST	SEGMENT
??_C@_0FI@DIIKKJHP@The?5schema?5document?5?8?$CFs?8?5cannot@ DB 'The sche'
	DB	'ma document ''%s'' cannot be included or redefined, since it '
	DB	'was already imported', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@DLHCDBDL@The?5schema?5document?5?8?$CFs?8?5cannot@
CONST	SEGMENT
??_C@_0FI@DLHCDBDL@The?5schema?5document?5?8?$CFs?8?5cannot@ DB 'The sche'
	DB	'ma document ''%s'' cannot be imported, since it was already i'
	DB	'ncluded or redefined', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IEONCAEH@in_memory_buffer@
CONST	SEGMENT
??_C@_0BB@IEONCAEH@in_memory_buffer@ DB 'in_memory_buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JJBMBON@The?5schema?5must?5not?5import?1incl@
CONST	SEGMENT
??_C@_0DD@JJBMBON@The?5schema?5must?5not?5import?1incl@ DB 'The schema mu'
	DB	'st not import/include/redefine itself', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BIPJKJFE@no?5constructor@
CONST	SEGMENT
??_C@_0P@BIPJKJFE@no?5constructor@ DB 'no constructor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PEPIDOML@parsing?5a?5schema?5doc?0?5but?5there@
CONST	SEGMENT
??_C@_0CJ@PEPIDOML@parsing?5a?5schema?5doc?0?5but?5there@ DB 'parsing a s'
	DB	'chema doc, but there''s no doc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DMMABNCK@xmlSchemaParseNewDoc@
CONST	SEGMENT
??_C@_0BF@DMMABNCK@xmlSchemaParseNewDoc@ DB 'xmlSchemaParseNewDoc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IFNOMMON@reparsing?5a?5schema?5doc@
CONST	SEGMENT
??_C@_0BH@IFNOMMON@reparsing?5a?5schema?5doc@ DB 'reparsing a schema doc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OJEBCMPM@xmlSchemaCreatePCtxtOnVCtxt@
CONST	SEGMENT
??_C@_0BM@OJEBCMPM@xmlSchemaCreatePCtxtOnVCtxt@ DB 'xmlSchemaCreatePCtxtO'
	DB	'nVCtxt', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GJEMMNOJ@failed?5to?5create?5a?5temp?4?5parser@
CONST	SEGMENT
??_C@_0CI@GJEMMNOJ@failed?5to?5create?5a?5temp?4?5parser@ DB 'failed to c'
	DB	'reate a temp. parser context', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NCMLFNIB@allocating?5schema?5parser?5contex@
CONST	SEGMENT
??_C@_0CB@NCMLFNIB@allocating?5schema?5parser?5contex@ DB 'allocating sch'
	DB	'ema parser context', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@MGLOMDJH@allocating?5list?5of?5pending?5glob@
CONST	SEGMENT
??_C@_0CN@MGLOMDJH@allocating?5list?5of?5pending?5glob@ DB 'allocating li'
	DB	'st of pending global components', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KNCAMKIP@allocating?5list?5of?5schema?5bucke@
CONST	SEGMENT
??_C@_0CC@KNCAMKIP@allocating?5list?5of?5schema?5bucke@ DB 'allocating li'
	DB	'st of schema buckets', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HOMALJAM@allocating?5schema?5construction?5@
CONST	SEGMENT
??_C@_0CH@HOMALJAM@allocating?5schema?5construction?5@ DB 'allocating sch'
	DB	'ema construction context', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CHFLODC@allocating?5schema?5relation@
CONST	SEGMENT
??_C@_0BL@CHFLODC@allocating?5schema?5relation@ DB 'allocating schema rel'
	DB	'ation', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0JG@PPPAGMJA@?$CI?$CIinclude?5?$HM?5import?5?$HM?5redefine?5?$HM@
CONST	SEGMENT
??_C@_0JG@PPPAGMJA@?$CI?$CIinclude?5?$HM?5import?5?$HM?5redefine?5?$HM@ DB '('
	DB	'(include | import | redefine | annotation)*, (((simpleType | '
	DB	'complexType | group | attributeGroup) | element | attribute |'
	DB	' notation), annotation*)*)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KNJKBPAF@notation@
CONST	SEGMENT
??_C@_08KNJKBPAF@notation@ DB 'notation', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MGJOOGAJ@group@
CONST	SEGMENT
??_C@_05MGJOOGAJ@group@ DB 'group', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07HCLJNICE@element@
CONST	SEGMENT
??_C@_07HCLJNICE@element@ DB 'element', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HCPHBLGO@redefine@
CONST	SEGMENT
??_C@_08HCPHBLGO@redefine@ DB 'redefine', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EOGGDCGF@import@
CONST	SEGMENT
??_C@_06EOGGDCGF@import@ DB 'import', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FHOHOHLG@include@
CONST	SEGMENT
??_C@_07FHOHOHLG@include@ DB 'include', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MMGPPGOC@blockDefault@
CONST	SEGMENT
??_C@_0N@MMGPPGOC@blockDefault@ DB 'blockDefault', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@JHFKOEOC@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@
CONST	SEGMENT
??_C@_0DK@JHFKOEOC@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@ DB '('
	DB	'#all | List of (extension | restriction | list | union))', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DFGPIJFA@finalDefault@
CONST	SEGMENT
??_C@_0N@DFGPIJFA@finalDefault@ DB 'finalDefault', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PMHAPIPB@attributeFormDefault@
CONST	SEGMENT
??_C@_0BF@PMHAPIPB@attributeFormDefault@ DB 'attributeFormDefault', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GLAKFDIM@elementFormDefault@
CONST	SEGMENT
??_C@_0BD@GLAKFDIM@elementFormDefault@ DB 'elementFormDefault', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JJLDNFDJ@targetNamespace@
CONST	SEGMENT
??_C@_0BA@JJLDNFDJ@targetNamespace@ DB 'targetNamespace', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IMPEKNJM@?$CIannotation?$DP?0?5?$CIall?5?$HM?5choice?5?$HM?5s@
CONST	SEGMENT
??_C@_0CK@IMPEKNJM@?$CIannotation?$DP?0?5?$CIall?5?$HM?5choice?5?$HM?5s@ DB '('
	DB	'annotation?, (all | choice | sequence)?)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBBDGPOF@sequence@
CONST	SEGMENT
??_C@_08IBBDGPOF@sequence@ DB 'sequence', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DDDNEJEA@choice@
CONST	SEGMENT
??_C@_06DDDNEJEA@choice@ DB 'choice', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NFKEKGGK@all@
CONST	SEGMENT
??_C@_03NFKEKGGK@all@ DB 'all', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@JDMIJKLB@This?5is?5a?5redefinition?0?5thus?5th@
CONST	SEGMENT
??_C@_0EO@JDMIJKLB@This?5is?5a?5redefinition?0?5thus?5th@ DB 'This is a r'
	DB	'edefinition, thus the <simpleType> must have a <restriction> '
	DB	'child', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MDINDAN@?$CIannotation?$DP?0?5?$CIrestriction?5?$HM?5li@
CONST	SEGMENT
??_C@_0CM@MDINDAN@?$CIannotation?$DP?0?5?$CIrestriction?5?$HM?5li@ DB '(a'
	DB	'nnotation?, (restriction | list | union))', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IJLHAKIE@?$CI?$CDall?5?$HM?5List?5of?5?$CIlist?5?$HM?5union?5?$HM@
CONST	SEGMENT
??_C@_0CN@IJLHAKIE@?$CI?$CDall?5?$HM?5List?5of?5?$CIlist?5?$HM?5union?5?$HM@ DB '('
	DB	'#all | List of (list | union | restriction)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@OIPDFCAL@Redefinition?5of?5built?9in?5simple@
CONST	SEGMENT
??_C@_0DH@OIPDFCAL@Redefinition?5of?5built?9in?5simple@ DB 'Redefinition '
	DB	'of built-in simple types is not supported', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@BDPJPAFM@Either?5the?5attribute?5?8itemType?8@
CONST	SEGMENT
??_C@_0EK@BDPJPAFM@Either?5the?5attribute?5?8itemType?8@ DB 'Either the a'
	DB	'ttribute ''itemType'' or the <simpleType> child must be prese'
	DB	'nt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@LEHAHIHI@The?5attribute?5?8itemType?8?5and?5th@
CONST	SEGMENT
??_C@_0EL@LEHAHIHI@The?5attribute?5?8itemType?8?5and?5th@ DB 'The attribu'
	DB	'te ''itemType'' and the <simpleType> child are mutually exclu'
	DB	'sive', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08DLBHENKN@itemType@
CONST	SEGMENT
??_C@_08DLBHENKN@itemType@ DB 'itemType', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@HHPGDCB@Either?5the?5attribute?5?8memberTyp@
CONST	SEGMENT
??_C@_0FG@HHPGDCB@Either?5the?5attribute?5?8memberTyp@ DB 'Either the att'
	DB	'ribute ''memberTypes'' or at least one <simpleType> child mus'
	DB	't be present', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BBOMAGGA@?$CIannotation?$DP?0?5simpleType?$CK?$CJ@
CONST	SEGMENT
??_C@_0BL@BBOMAGGA@?$CIannotation?$DP?0?5simpleType?$CK?$CJ@ DB '(annotat'
	DB	'ion?, simpleType*)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CGPNFFK@xmlSchemaParseUnion?0?5allocating@
CONST	SEGMENT
??_C@_0CM@CGPNFFK@xmlSchemaParseUnion?0?5allocating@ DB 'xmlSchemaParseUn'
	DB	'ion, allocating a type link', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OEMIGMAO@memberTypes@
CONST	SEGMENT
??_C@_0M@OEMIGMAO@memberTypes@ DB 'memberTypes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@NHLOCELP@?$CIannotation?$DP?0?5?$CI?$CIsimpleType?5?$HM?5co@
CONST	SEGMENT
??_C@_0EH@NHLOCELP@?$CIannotation?$DP?0?5?$CI?$CIsimpleType?5?$HM?5co@ DB '('
	DB	'annotation?, ((simpleType | complexType)?, (unique | key | ke'
	DB	'yref)*))', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06PLFEIJDE@keyref@
CONST	SEGMENT
??_C@_06PLFEIJDE@keyref@ DB 'keyref', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICHNJLJF@key@
CONST	SEGMENT
??_C@_03ICHNJLJF@key@ DB 'key', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06ODCMFGLL@unique@
CONST	SEGMENT
??_C@_06ODCMFGLL@unique@ DB 'unique', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@DDMHFMFF@The?5attribute?5?8type?8?5and?5the?5?$DMc@
CONST	SEGMENT
??_C@_0EI@DDMHFMFF@The?5attribute?5?8type?8?5and?5the?5?$DMc@ DB 'The att'
	DB	'ribute ''type'' and the <complexType> child are mutually excl'
	DB	'usive', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OCBEIBDG@complexType@
CONST	SEGMENT
??_C@_0M@OCBEIBDG@complexType@ DB 'complexType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@DDAOLEFB@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@
CONST	SEGMENT
??_C@_0DK@DDAOLEFB@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@ DB '('
	DB	'#all | List of (extension | restriction | substitution))', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KNGCEGAB@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@
CONST	SEGMENT
??_C@_0CL@KNGCEGAB@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@ DB '('
	DB	'#all | List of (extension | restriction))', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CGDMBFF@substitutionGroup@
CONST	SEGMENT
??_C@_0BC@CGDMBFF@substitutionGroup@ DB 'substitutionGroup', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IMFJLGFD@abstract@
CONST	SEGMENT
??_C@_08IMFJLGFD@abstract@ DB 'abstract', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FPBGKCKL@final@
CONST	SEGMENT
??_C@_05FPBGKCKL@final@ DB 'final', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08BNOJCPJE@nillable@
CONST	SEGMENT
??_C@_08BNOJCPJE@nillable@ DB 'nillable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PIBOEKAB@block@
CONST	SEGMENT
??_C@_05PIBOEKAB@block@ DB 'block', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@LFNFLK@Only?5the?5attributes?5?8minOccurs?8@
CONST	SEGMENT
??_C@_0FH@LFNFLK@Only?5the?5attributes?5?8minOccurs?8@ DB 'Only the attri'
	DB	'butes ''minOccurs'', ''maxOccurs'' and ''id'' are allowed in '
	DB	'addition to ''ref''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05EIBGDMPB@field@
CONST	SEGMENT
??_C@_05EIBGDMPB@field@ DB 'field', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DILBKPNJ@selector@
CONST	SEGMENT
??_C@_08DILBKPNJ@selector@ DB 'selector', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HDFCKCKI@A?5child?5element?5is?5missing@
CONST	SEGMENT
??_C@_0BL@HDFCKCKI@A?5child?5element?5is?5missing@ DB 'A child element is'
	DB	' missing', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DEBKGIBF@?$CIannotation?$DP?0?5?$CIselector?0?5field?$CL@
CONST	SEGMENT
??_C@_0CC@DEBKGIBF@?$CIannotation?$DP?0?5?$CIselector?0?5field?$CL@ DB '('
	DB	'annotation?, (selector, field+))', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05BEFNLAML@refer@
CONST	SEGMENT
??_C@_05BEFNLAML@refer@ DB 'refer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@EOECGLHE@Internal?5error?3?5xmlSchemaParseI@
CONST	SEGMENT
??_C@_0GH@EOECGLHE@Internal?5error?3?5xmlSchemaParseI@ DB 'Internal error'
	DB	': xmlSchemaParseIDCSelectorAndField, validating the XPath exp'
	DB	'ression of a IDC selector.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@GFJDOCKM@allocating?5a?5?8selector?8?5of?5an?5i@
CONST	SEGMENT
??_C@_0DN@GFJDOCKM@allocating?5a?5?8selector?8?5of?5an?5i@ DB 'allocating'
	DB	' a ''selector'' of an identity-constraint definition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05CNNIIAHK@xpath@
CONST	SEGMENT
??_C@_05CNNIIAHK@xpath@ DB 'xpath', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@CNICCNGM@Internal?5error?3?5xmlSchemaAddAnn@
CONST	SEGMENT
??_C@_0FF@CNICCNGM@Internal?5error?3?5xmlSchemaAddAnn@ DB 'Internal error'
	DB	': xmlSchemaAddAnnotation, The item is not a annotated schema '
	DB	'component', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@MEAKINLE@The?5XPath?5expression?5?8?$CFs?8?5could@
CONST	SEGMENT
??_C@_0DA@MEAKINLE@The?5XPath?5expression?5?8?$CFs?8?5could@ DB 'The XPat'
	DB	'h expression ''%s'' could not be compiled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LCFJGAGM@allocating?5a?5namespace?5array@
CONST	SEGMENT
??_C@_0BN@LCFJGAGM@allocating?5a?5namespace?5array@ DB 'allocating a name'
	DB	'space array', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LABDBLHI@The?5XPath?5expression?5of?5the?5sel@
CONST	SEGMENT
??_C@_0DC@LABDBLHI@The?5XPath?5expression?5of?5the?5sel@ DB 'The XPath ex'
	DB	'pression of the selector is not valid', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@EIAADIEO@Internal?5error?3?5xmlSchemaCheckC@
CONST	SEGMENT
??_C@_0EO@EIAADIEO@Internal?5error?3?5xmlSchemaCheckC@ DB 'Internal error'
	DB	': xmlSchemaCheckCSelectorXPath, the selector is not specified'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05MNALHJLP@union@
CONST	SEGMENT
??_C@_05MNALHJLP@union@ DB 'union', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DONFEANM@list@
CONST	SEGMENT
??_C@_04DONFEANM@list@ DB 'list', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@INDADLAA@substitution@
CONST	SEGMENT
??_C@_0N@INDADLAA@substitution@ DB 'substitution', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FBFLGGFO@restriction@
CONST	SEGMENT
??_C@_0M@FBFLGGFO@restriction@ DB 'restriction', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ODADEDNA@extension@
CONST	SEGMENT
??_C@_09ODADEDNA@extension@ DB 'extension', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LEKDNLLP@?$CDall@
CONST	SEGMENT
??_C@_04LEKDNLLP@?$CDall@ DB '#all', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@PEEJHPPG@?$CIannotation?$DP?0?5?$CI?$CIattribute?5?$HM?5att@
CONST	SEGMENT
??_C@_0DO@PEEJHPPG@?$CIannotation?$DP?0?5?$CI?$CIattribute?5?$HM?5att@ DB '('
	DB	'annotation?, ((attribute | attributeGroup)*, anyAttribute?))', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DDKCLMJG@anyAttribute@
CONST	SEGMENT
??_C@_0N@DDKCLMJG@anyAttribute@ DB 'anyAttribute', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0HE@EDEMIIKM@The?5redefining?5attribute?5group?5@
CONST	SEGMENT
??_C@_0HE@EDEMIIKM@The?5redefining?5attribute?5group?5@ DB 'The redefinin'
	DB	'g attribute group definition ''%s'' must not contain more tha'
	DB	'n one reference to the redefined definition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LABGHPL@?$CIannotation?$DP?0?5simpleType?$DP?$CJ@
CONST	SEGMENT
??_C@_0BL@LABGHPL@?$CIannotation?$DP?0?5simpleType?$DP?$CJ@ DB '(annotati'
	DB	'on?, simpleType?)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@BAMMFMJA@The?5attribute?5?8type?8?5and?5the?5?$DMs@
CONST	SEGMENT
??_C@_0EH@BAMMFMJA@The?5attribute?5?8type?8?5and?5the?5?$DMs@ DB 'The att'
	DB	'ribute ''type'' and the <simpleType> child are mutually exclu'
	DB	'sive', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FMMGGLOP@simpleType@
CONST	SEGMENT
??_C@_0L@FMMGGLOP@simpleType@ DB 'simpleType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LIPHNCMP@Skipping?5duplicate?5attribute?5us@
CONST	SEGMENT
??_C@_0DC@LIPHNCMP@Skipping?5duplicate?5attribute?5us@ DB 'Skipping dupli'
	DB	'cate attribute use prohibition ''%s''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@EKEFODDF@Skipping?5attribute?5use?5prohibit@
CONST	SEGMENT
??_C@_0FA@EKEFODDF@Skipping?5attribute?5use?5prohibit@ DB 'Skipping attri'
	DB	'bute use prohibition, since it is pointless when extending a '
	DB	'type', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@PAOOKLLP@Skipping?5attribute?5use?5prohibit@
CONST	SEGMENT
??_C@_0FF@PAOOKLLP@Skipping?5attribute?5use?5prohibit@ DB 'Skipping attri'
	DB	'bute use prohibition, since it is pointless inside an <attrib'
	DB	'uteGroup>', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@IMLKIPJD@The?5value?5of?5the?5attribute?5must@
CONST	SEGMENT
??_C@_0DC@IMLKIPJD@The?5value?5of?5the?5attribute?5must@ DB 'The value of'
	DB	' the attribute must not match ''xmlns''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPEFOGKI@xmlns@
CONST	SEGMENT
??_C@_05PPEFOGKI@xmlns@ DB 'xmlns', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KHJHCHGN@The?5target?5namespace?5must?5not?5m@
CONST	SEGMENT
??_C@_0CJ@KHJHCHGN@The?5target?5namespace?5must?5not?5m@ DB 'The target n'
	DB	'amespace must not match ''%s''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@JMMMCAKL@The?5value?5of?5the?5attribute?5?8use@
CONST	SEGMENT
??_C@_0FK@JMMMCAKL@The?5value?5of?5the?5attribute?5?8use@ DB 'The value o'
	DB	'f the attribute ''use'' must be ''optional'' if the attribute'
	DB	' ''default'' is present', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DLHCIBDH@default@
CONST	SEGMENT
??_C@_07DLHCIBDH@default@ DB 'default', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MEKFLEMO@?$CIoptional?5?$HM?5prohibited?5?$HM?5requir@
CONST	SEGMENT
??_C@_0CD@MEKFLEMO@?$CIoptional?5?$HM?5prohibited?5?$HM?5requir@ DB '(opt'
	DB	'ional | prohibited | required)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FEMBDDHD@required@
CONST	SEGMENT
??_C@_08FEMBDDHD@required@ DB 'required', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HMNCJOMG@prohibited@
CONST	SEGMENT
??_C@_0L@HMNCJOMG@prohibited@ DB 'prohibited', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EBGGHLAO@optional@
CONST	SEGMENT
??_C@_08EBGGHLAO@optional@ DB 'optional', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MMGHDJKG@use@
CONST	SEGMENT
??_C@_03MMGHDJKG@use@ DB 'use', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IDHDHMBC@?$CIqualified?5?$HM?5unqualified?$CJ@
CONST	SEGMENT
??_C@_0BK@IDHDHMBC@?$CIqualified?5?$HM?5unqualified?$CJ@ DB '(qualified |'
	DB	' unqualified)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PJKDFPFM@unqualified@
CONST	SEGMENT
??_C@_0M@PJKDFPFM@unqualified@ DB 'unqualified', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NPLHLKJP@qualified@
CONST	SEGMENT
??_C@_09NPLHLKJP@qualified@ DB 'qualified', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLMMMEIO@form@
CONST	SEGMENT
??_C@_04MLMMMEIO@form@ DB 'form', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GPMDFGEJ@type@
CONST	SEGMENT
??_C@_04GPMDFGEJ@type@ DB 'type', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GCDGINBO@ref@
CONST	SEGMENT
??_C@_03GCDGINBO@ref@ DB 'ref', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DHBIDCLH@Notation?5has?5no?5name?6@
CONST	SEGMENT
??_C@_0BG@DHBIDCLH@Notation?5has?5no?5name?6@ DB 'Notation has no name', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MNAJHLGE@?$CIannotation?$DP?$CJ@
CONST	SEGMENT
??_C@_0O@MNAJHLGE@?$CIannotation?$DP?$CJ@ DB '(annotation?)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FKFDAFPO@xs?3nonNegativeInteger@
CONST	SEGMENT
??_C@_0BG@FKFDAFPO@xs?3nonNegativeInteger@ DB 'xs:nonNegativeInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BEMOBFLH@?$CIxs?3nonNegativeInteger?5?$HM?5unboun@
CONST	SEGMENT
??_C@_0CE@BEMOBFLH@?$CIxs?3nonNegativeInteger?5?$HM?5unboun@ DB '(xs:nonN'
	DB	'egativeInteger | unbounded)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@MJPPLMBN@The?5value?5must?5not?5be?5greater?5t@
CONST	SEGMENT
??_C@_0DM@MJPPLMBN@The?5value?5must?5not?5be?5greater?5t@ DB 'The value m'
	DB	'ust not be greater than the value of ''maxOccurs''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HPDJBJNO@The?5value?5must?5be?5greater?5than?5@
CONST	SEGMENT
??_C@_0CN@HPDJBJNO@The?5value?5must?5be?5greater?5than?5@ DB 'The value m'
	DB	'ust be greater than or equal to 1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NOOLJEMO@?$CD?$CDlocal@
CONST	SEGMENT
??_C@_07NOOLJEMO@?$CD?$CDlocal@ DB '##local', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NIOKFNAN@?$CD?$CDtargetNamespace@
CONST	SEGMENT
??_C@_0BC@NIOKFNAN@?$CD?$CDtargetNamespace@ DB '##targetNamespace', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@HAPJOCKP@?$CI?$CI?$CD?$CDany?5?$HM?5?$CD?$CDother?$CJ?5?$HM?5List?5of?5?$CIx@
CONST	SEGMENT
??_C@_0EK@HAPJOCKP@?$CI?$CI?$CD?$CDany?5?$HM?5?$CD?$CDother?$CJ?5?$HM?5List?5of?5?$CIx@ DB '('
	DB	'(##any | ##other) | List of (xs:anyURI | (##targetNamespace |'
	DB	' ##local)))', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05HGEKMIOD@?$CD?$CDany@
CONST	SEGMENT
??_C@_05HGEKMIOD@?$CD?$CDany@ DB '##any', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KPMGAFNI@namespace@
CONST	SEGMENT
??_C@_09KPMGAFNI@namespace@ DB 'namespace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JONDLOPH@?$CIstrict?5?$HM?5skip?5?$HM?5lax?$CJ@
CONST	SEGMENT
??_C@_0BG@JONDLOPH@?$CIstrict?5?$HM?5skip?5?$HM?5lax?$CJ@ DB '(strict | s'
	DB	'kip | lax)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LJOIJHLO@processContents@
CONST	SEGMENT
??_C@_0BA@LJOIJHLO@processContents@ DB 'processContents', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KGEOIBLP@Facet?5?$CFs?5has?5unexpected?5child?5c@
CONST	SEGMENT
??_C@_0CH@KGEOIBLP@Facet?5?$CFs?5has?5unexpected?5child?5c@ DB 'Facet %s '
	DB	'has unexpected child content', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGAMHHM@annotation@
CONST	SEGMENT
??_C@_0L@HOGAMHHM@annotation@ DB 'annotation', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05OFLEIIDM@fixed@
CONST	SEGMENT
??_C@_05OFLEIIDM@fixed@ DB 'fixed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JGDFLELF@Unknown?5facet?5type?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@JGDFLELF@Unknown?5facet?5type?5?$CFs?6@ DB 'Unknown facet type '
	DB	'%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09KIHADLGO@minLength@
CONST	SEGMENT
??_C@_09KIHADLGO@minLength@ DB 'minLength', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KJHMKBNK@maxLength@
CONST	SEGMENT
??_C@_09KJHMKBNK@maxLength@ DB 'maxLength', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IJDLPEM@length@
CONST	SEGMENT
??_C@_06IJDLPEM@length@ DB 'length', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CCEMGGFL@whiteSpace@
CONST	SEGMENT
??_C@_0L@CCEMGGFL@whiteSpace@ DB 'whiteSpace', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FJOIDAAJ@enumeration@
CONST	SEGMENT
??_C@_0M@FJOIDAAJ@enumeration@ DB 'enumeration', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CHFOACKJ@pattern@
CONST	SEGMENT
??_C@_07CHFOACKJ@pattern@ DB 'pattern', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EPJLKDGA@fractionDigits@
CONST	SEGMENT
??_C@_0P@EPJLKDGA@fractionDigits@ DB 'fractionDigits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PGNNBCIB@totalDigits@
CONST	SEGMENT
??_C@_0M@PGNNBCIB@totalDigits@ DB 'totalDigits', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IEJNIJII@maxExclusive@
CONST	SEGMENT
??_C@_0N@IEJNIJII@maxExclusive@ DB 'maxExclusive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EBHLFCPN@maxInclusive@
CONST	SEGMENT
??_C@_0N@EBHLFCPN@maxInclusive@ DB 'maxInclusive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MENCPBPO@minExclusive@
CONST	SEGMENT
??_C@_0N@MENCPBPO@minExclusive@ DB 'minExclusive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BDECKIL@minInclusive@
CONST	SEGMENT
??_C@_0N@BDECKIL@minInclusive@ DB 'minInclusive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LAHCBIKA@Facet?5?$CFs?5has?5no?5value?6@
CONST	SEGMENT
??_C@_0BH@LAHCBIKA@Facet?5?$CFs?5has?5no?5value?6@ DB 'Facet %s has no va'
	DB	'lue', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05MFEJDJP@value@
CONST	SEGMENT
??_C@_05MFEJDJP@value@ DB 'value', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DFGEBGMC@allocating?5facet@
CONST	SEGMENT
??_C@_0BB@DFGEBGMC@allocating?5facet@ DB 'allocating facet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CHHJOIII@?$CIappinfo?5?$HM?5documentation?$CJ?$CK@
CONST	SEGMENT
??_C@_0BL@CHHJOIII@?$CIappinfo?5?$HM?5documentation?$CJ?$CK@ DB '(appinfo'
	DB	' | documentation)*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
CONST	SEGMENT
??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ DB 'http://ww'
	DB	'w.w3.org/XML/1998/namespace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IOHABJIC@lang@
CONST	SEGMENT
??_C@_04IOHABJIC@lang@ DB 'lang', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JMIFCMPP@documentation@
CONST	SEGMENT
??_C@_0O@JMIFCMPP@documentation@ DB 'documentation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OEKOLKIL@source@
CONST	SEGMENT
??_C@_06OEKOLKIL@source@ DB 'source', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IADCAIKP@appinfo@
CONST	SEGMENT
??_C@_07IADCAIKP@appinfo@ DB 'appinfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGCJHIOB@id@
CONST	SEGMENT
??_C@_02EGCJHIOB@id@ DB 'id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KIDCOMBF@attributeGroup@
CONST	SEGMENT
??_C@_0P@KIDCOMBF@attributeGroup@ DB 'attributeGroup', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HGIEBAJ@attribute@
CONST	SEGMENT
??_C@_09HGIEBAJ@attribute@ DB 'attribute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HM@PFGFDKAG@References?5from?5this?5schema?5to?5@
CONST	SEGMENT
??_C@_0HM@PFGFDKAG@References?5from?5this?5schema?5to?5@ DB 'References f'
	DB	'rom this schema to components in the namespace ''%s'' are not'
	DB	' allowed, since not indicated by an import statement', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HG@LIIBNHFM@References?5from?5this?5schema?5to?5@
CONST	SEGMENT
??_C@_0HG@LIIBNHFM@References?5from?5this?5schema?5to?5@ DB 'References f'
	DB	'rom this schema to components in no namespace are not allowed'
	DB	', since not indicated by an import statement', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@OJBBBDML@Internal?5error?3?5xmlSchemaPValAt@
CONST	SEGMENT
??_C@_0FA@OJBBBDML@Internal?5error?3?5xmlSchemaPValAt@ DB 'Internal error'
	DB	': xmlSchemaPValAttr, the given type ''%s'' is not a built-in '
	DB	'type.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DLDNHDND@failed?5to?5validate?5a?5schema?5att@
CONST	SEGMENT
??_C@_0CM@DLDNHDND@failed?5to?5validate?5a?5schema?5att@ DB 'failed to va'
	DB	'lidate a schema attribute value', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@OLDONBHK@validation?5using?5the?5given?5type@
CONST	SEGMENT
??_C@_0EI@OLDONBHK@validation?5using?5the?5given?5type@ DB 'validation us'
	DB	'ing the given type is not supported while parsing a schema', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CNLGMFJP@xmlSchemaPValAttrNodeValue@
CONST	SEGMENT
??_C@_0BL@CNLGMFJP@xmlSchemaPValAttrNodeValue@ DB 'xmlSchemaPValAttrNodeV'
	DB	'alue', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JADIGFME@the?5given?5type?5is?5not?5a?5built?9i@
CONST	SEGMENT
??_C@_0CG@JADIGFME@the?5given?5type?5is?5not?5a?5built?9i@ DB 'the given '
	DB	'type is not a built-in type', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09OAPKCOGD@minOccurs@
CONST	SEGMENT
??_C@_09OAPKCOGD@minOccurs@ DB 'minOccurs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PBKAIKML@unbounded@
CONST	SEGMENT
??_C@_09PBKAIKML@unbounded@ DB 'unbounded', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OBPGLENH@maxOccurs@
CONST	SEGMENT
??_C@_09OBPGLENH@maxOccurs@ DB 'maxOccurs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@BMJNLDB@The?5value?5?8?$CFs?8?5of?5simple?5type?5?8@
CONST	SEGMENT
??_C@_0EB@BMJNLDB@The?5value?5?8?$CFs?8?5of?5simple?5type?5?8@ DB 'The va'
	DB	'lue ''%s'' of simple type ''xs:ID'' is not a valid ''xs:NCNam'
	DB	'e''', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OMFMFEA@Duplicate?5value?5?8?$CFs?8?5of?5simple?5@
CONST	SEGMENT
??_C@_0CM@OMFMFEA@Duplicate?5value?5?8?$CFs?8?5of?5simple?5@ DB 'Duplicat'
	DB	'e value ''%s'' of simple type ''xs:ID''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@NHMNMJGI@The?5value?5?8?$CFs?8?5of?5simple?5type?5?8@
CONST	SEGMENT
??_C@_0FN@NHMNMJGI@The?5value?5?8?$CFs?8?5of?5simple?5type?5?8@ DB 'The v'
	DB	'alue ''%s'' of simple type ''xs:QName'' has no corresponding '
	DB	'namespace declaration in scope', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CHMIFAPN@xmlSchemaSubstGroupAdd@
CONST	SEGMENT
??_C@_0BH@CHMIFAPN@xmlSchemaSubstGroupAdd@ DB 'xmlSchemaSubstGroupAdd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JADHFAI@failed?5to?5add?5a?5new?5substitutio@
CONST	SEGMENT
??_C@_0CL@JADHFAI@failed?5to?5add?5a?5new?5substitutio@ DB 'failed to add'
	DB	' a new substitution container', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NKPACKCN@allocating?5a?5substitution?5group@
CONST	SEGMENT
??_C@_0CK@NKPACKCN@allocating?5a?5substitution?5group@ DB 'allocating a s'
	DB	'ubstitution group container', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CIBAJGPC@adding?5wildcard@
CONST	SEGMENT
??_C@_0BA@CIBAJGPC@adding?5wildcard@ DB 'adding wildcard', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LEONOKAC@allocating?5an?5identity?9constrai@
CONST	SEGMENT
??_C@_0CN@LEONOKAC@allocating?5an?5identity?9constrai@ DB 'allocating an '
	DB	'identity-constraint definition', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KLLMMGAA@creating?5wildcard?5namespace?5con@
CONST	SEGMENT
??_C@_0CH@KLLMMGAA@creating?5wildcard?5namespace?5con@ DB 'creating wildc'
	DB	'ard namespace constraint', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MMNEFFIM@adding?5group@
CONST	SEGMENT
??_C@_0N@MMNEFFIM@adding?5group@ DB 'adding group', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IIFFCFND@allocating?5particle?5component@
CONST	SEGMENT
??_C@_0BO@IIFFCFND@allocating?5particle?5component@ DB 'allocating partic'
	DB	'le component', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MIJFJDPK@allocating?5model?5group?5componen@
CONST	SEGMENT
??_C@_0CB@MIJFJDPK@allocating?5model?5group?5componen@ DB 'allocating mod'
	DB	'el group component', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BKCCIOBM@allocating?5attribute?5use?5prohib@
CONST	SEGMENT
??_C@_0CF@BKCCIOBM@allocating?5attribute?5use?5prohib@ DB 'allocating att'
	DB	'ribute use prohibition', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BENLLJIB@allocating?5QName?5reference?5item@
CONST	SEGMENT
??_C@_0CA@BENLLJIB@allocating?5QName?5reference?5item@ DB 'allocating QNa'
	DB	'me reference item', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BHDLCLLG@allocating?5type@
CONST	SEGMENT
??_C@_0BA@BHDLCLLG@allocating?5type@ DB 'allocating type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OFNGJBCE@allocating?5element@
CONST	SEGMENT
??_C@_0BD@OFNGJBCE@allocating?5element@ DB 'allocating element', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LFEIBOLE@allocating?5attribute?5group@
CONST	SEGMENT
??_C@_0BL@LFEIBOLE@allocating?5attribute?5group@ DB 'allocating attribute'
	DB	' group', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DCKEMFJK@allocating?5redefinition?5info@
CONST	SEGMENT
??_C@_0BN@DCKEMFJK@allocating?5redefinition?5info@ DB 'allocating redefin'
	DB	'ition info', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IGICPFC@allocating?5attribute@
CONST	SEGMENT
??_C@_0BF@IGICPFC@allocating?5attribute@ DB 'allocating attribute', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HKPLIAHO@add?5annotation@
CONST	SEGMENT
??_C@_0P@HKPLIAHO@add?5annotation@ DB 'add annotation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HFGDBOPE@no?5target?5namespace@
CONST	SEGMENT
??_C@_0BE@HFGDBOPE@no?5target?5namespace@ DB 'no target namespace', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HIFPELMF@no?5name?0?5@
CONST	SEGMENT
??_C@_09HIFPELMF@no?5name?0?5@ DB 'no name, ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04ONKFDMMC@?$CFs?0?5@
CONST	SEGMENT
??_C@_04ONKFDMMC@?$CFs?0?5@ DB '%s, ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09CEPCMGAA@Schemas?3?5@
CONST	SEGMENT
??_C@_09CEPCMGAA@Schemas?3?5@ DB 'Schemas: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IDICKHMO@Schemas?3?5NULL?6@
CONST	SEGMENT
??_C@_0P@IDICKHMO@Schemas?3?5NULL?6@ DB 'Schemas: NULL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IHAEEDOH@?5ns?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_09IHAEEDOH@?5ns?5?8?$CFs?8?6@ DB ' ns ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HMAJHNML@?5?5base?5type?3?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0BC@HMAJHNML@?5?5base?5type?3?5?8?$CFs?8@ DB '  base type: ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EBDMPOEI@?$FLany?$FN?5@
CONST	SEGMENT
??_C@_06EBDMPOEI@?$FLany?$FN?5@ DB '[any] ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPDGAGCC@?$FLmixed?$FN?5@
CONST	SEGMENT
??_C@_08EPDGAGCC@?$FLmixed?$FN?5@ DB '[mixed] ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FLJCNDEC@?$FLelement?$FN?5@
CONST	SEGMENT
??_C@_0L@FLJCNDEC@?$FLelement?$FN?5@ DB '[element] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HLDMIKJJ@?$FLempty?$FN?5@
CONST	SEGMENT
??_C@_08HLDMIKJJ@?$FLempty?$FN?5@ DB '[empty] ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IFGHBDON@?$FLunknown?$FN?5@
CONST	SEGMENT
??_C@_0L@IFGHBDON@?$FLunknown?$FN?5@ DB '[unknown] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FOCHAENE@content?3?5@
CONST	SEGMENT
??_C@_09FOCHAENE@content?3?5@ DB 'content: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MFKKFECO@?$FLunknown?5type?5?$CFd?$FN?5@
CONST	SEGMENT
??_C@_0BD@MFKKFECO@?$FLunknown?5type?5?$CFd?$FN?5@ DB '[unknown type %d] '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FOPKHEI@?$FLextension?$FN?5@
CONST	SEGMENT
??_C@_0N@FOPKHEI@?$FLextension?$FN?5@ DB '[extension] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CHAMEEEB@?$FLrestriction?$FN?5@
CONST	SEGMENT
??_C@_0P@CHAMEEEB@?$FLrestriction?$FN?5@ DB '[restriction] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05CJJADIIB@?$FLur?$FN?5@
CONST	SEGMENT
??_C@_05CJJADIIB@?$FLur?$FN?5@ DB '[ur] ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FMDLAKIF@?$FLall?$FN?5@
CONST	SEGMENT
??_C@_06FMDLAKIF@?$FLall?$FN?5@ DB '[all] ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EKOOBNCK@?$FLchoice?$FN?5@
CONST	SEGMENT
??_C@_09EKOOBNCK@?$FLchoice?$FN?5@ DB '[choice] ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FCFPOKLD@?$FLsequence?$FN?5@
CONST	SEGMENT
??_C@_0M@FCFPOKLD@?$FLsequence?$FN?5@ DB '[sequence] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KAOEKGBK@?$FLcomplex?$FN?5@
CONST	SEGMENT
??_C@_0L@KAOEKGBK@?$FLcomplex?$FN?5@ DB '[complex] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BLJCIKGO@?$FLsimple?$FN?5@
CONST	SEGMENT
??_C@_09BLJCIKGO@?$FLsimple?$FN?5@ DB '[simple] ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JHBJHPJC@?$FLbasic?$FN?5@
CONST	SEGMENT
??_C@_08JHBJHPJC@?$FLbasic?$FN?5@ DB '[basic] ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KCLBPAMH@ns?5?8?$CFs?8?5@
CONST	SEGMENT
??_C@_08KCLBPAMH@ns?5?8?$CFs?8?5@ DB 'ns ''%s'' ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MKMGDOCG@?$CIno?5name?$CJ?5@
CONST	SEGMENT
??_C@_0L@MKMGDOCG@?$CIno?5name?$CJ?5@ DB '(no name) ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05IMLJLABD@?8?$CFs?8?5@
CONST	SEGMENT
??_C@_05IMLJLABD@?8?$CFs?8?5@ DB '''%s'' ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NAHGBCDG@Type?3?5@
CONST	SEGMENT
??_C@_06NAHGBCDG@Type?3?5@ DB 'Type: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JCDJFDMD@Type?3?5NULL?6@
CONST	SEGMENT
??_C@_0M@JCDJFDMD@Type?3?5NULL?6@ DB 'Type: NULL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05ODNCHMDL@?8?$CFs?8?6@
CONST	SEGMENT
??_C@_05ODNCHMDL@?8?$CFs?8?6@ DB '''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FLCGCOPE@?5?5?$FLuse?$FN?5@
CONST	SEGMENT
??_C@_08FLCGCOPE@?5?5?$FLuse?$FN?5@ DB '  [use] ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IGLOKPCJ@?5?5?$FLreference?$FN?5@
CONST	SEGMENT
??_C@_0P@IGLOKPCJ@?5?5?$FLreference?$FN?5@ DB '  [reference] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EJJDJFMI@?5?5?$FLprohibition?$FN?5@
CONST	SEGMENT
??_C@_0BB@EJJDJFMI@?5?5?$FLprohibition?$FN?5@ DB '  [prohibition] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JCEFCIDL@?5?5attributes?3?6@
CONST	SEGMENT
??_C@_0P@JCEFCIDL@?5?5attributes?3?6@ DB '  attributes:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GOONDBNE@?5max?3?5?$CFd@
CONST	SEGMENT
??_C@_08GOONDBNE@?5max?3?5?$CFd@ DB ' max: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NODJHFHO@?5max?3?5unbounded@
CONST	SEGMENT
??_C@_0BA@NODJHFHO@?5max?3?5unbounded@ DB ' max: unbounded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IIINJODF@?5min?3?5?$CFd@
CONST	SEGMENT
??_C@_08IIINJODF@?5min?3?5?$CFd@ DB ' min: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GCOIMFOL@UNKNOWN?6@
CONST	SEGMENT
??_C@_08GCOIMFOL@UNKNOWN?6@ DB 'UNKNOWN', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03OMGOFJGM@ANY@
CONST	SEGMENT
??_C@_03OMGOFJGM@ANY@ DB 'ANY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NIFPGLBG@ALL@
CONST	SEGMENT
??_C@_03NIFPGLBG@ALL@ DB 'ALL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DHBGJHJC@CHOICE@
CONST	SEGMENT
??_C@_06DHBGJHJC@CHOICE@ DB 'CHOICE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08POLPFBMC@SEQUENCE@
CONST	SEGMENT
??_C@_08POLPFBMC@SEQUENCE@ DB 'SEQUENCE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HHDCLOAM@ELEM?5?8?$CFs?8@
CONST	SEGMENT
??_C@_09HHDCLOAM@ELEM?5?8?$CFs?8@ DB 'ELEM ''%s''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DPNPBLLK@MISSING?5particle?5term?6@
CONST	SEGMENT
??_C@_0BH@DPNPBLLK@MISSING?5particle?5term?6@ DB 'MISSING particle term', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MKDNPCKH@?5?5Annot?3?5empty?6@
CONST	SEGMENT
??_C@_0BA@MKDNPCKH@?5?5Annot?3?5empty?6@ DB '  Annot: empty', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FJPFKNMF@?5?5Annot?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0N@FJPFKNMF@?5?5Annot?3?5?$CFs?6@ DB '  Annot: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GHPOMFG@?5?5substitutionGroup?3?5?8?$CFs?8?5@
CONST	SEGMENT
??_C@_0BL@GHPOMFG@?5?5substitutionGroup?3?5?8?$CFs?8?5@ DB '  substitutio'
	DB	'nGroup: ''%s'' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08MNNKDMOP@ns?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_08MNNKDMOP@ns?5?8?$CFs?8?6@ DB 'ns ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LPELKPN@?5?5type?3?5?8?$CFs?8?5@
CONST	SEGMENT
??_C@_0O@LPELKPN@?5?5type?3?5?8?$CFs?8?5@ DB '  type: ''%s'' ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OOGOODOG@?5?5value?3?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0P@OOGOODOG@?5?5value?3?5?8?$CFs?8?6@ DB '  value: ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BCKHHPGO@?$FLnillable?$FN?5@
CONST	SEGMENT
??_C@_0M@BCKHHPGO@?$FLnillable?$FN?5@ DB '[nillable] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BPMPIELH@?$FLabstract?$FN?5@
CONST	SEGMENT
??_C@_0M@BPMPIELH@?$FLabstract?$FN?5@ DB '[abstract] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CIMKDCEL@?$FLdefault?$FN?5@
CONST	SEGMENT
??_C@_0L@CIMKDCEL@?$FLdefault?$FN?5@ DB '[default] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BCFMBKHE@?$FLfixed?$FN?5@
CONST	SEGMENT
??_C@_08BCFMBKHE@?$FLfixed?$FN?5@ DB '[fixed] ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MDPMFALO@?5?5props?3?5@
CONST	SEGMENT
??_C@_09MDPMFALO@?5?5props?3?5@ DB '  props: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07ONOPJFOL@ns?5?8?$CFs?8@
CONST	SEGMENT
??_C@_07ONOPJFOL@ns?5?8?$CFs?8@ DB 'ns ''%s''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IDOJLIPA@?3?5?8?$CFs?8?5@
CONST	SEGMENT
??_C@_07IDOJLIPA@?3?5?8?$CFs?8?5@ DB ': ''%s'' ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GAHIJPLK@?5?$CIglobal?$CJ@
CONST	SEGMENT
??_C@_09GAHIJPLK@?5?$CIglobal?$CJ@ DB ' (global)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07ILMPLKHC@Element@
CONST	SEGMENT
??_C@_07ILMPLKHC@Element@ DB 'Element', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@EBPFONFN@Internal?5error?3?5xmlSchemaCompon@
CONST	SEGMENT
??_C@_0EM@EBPFONFN@Internal?5error?3?5xmlSchemaCompon@ DB 'Internal error'
	DB	': xmlSchemaComponentListFree, unexpected component type ''%s'''
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PPHBJHEG@failed?5to?5add?5the?5schema?5bucket@
CONST	SEGMENT
??_C@_0CM@PPHBJHEG@failed?5to?5add?5the?5schema?5bucket@ DB 'failed to ad'
	DB	'd the schema bucket to the hash', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02IEBMKJDF@?$CD?$CD@
CONST	SEGMENT
??_C@_02IEBMKJDF@?$CD?$CD@ DB '##', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KFOKDOIL@main?5bucket?5but?5it?8s?5not?5the?5fi@
CONST	SEGMENT
??_C@_0CH@KFOKDOIL@main?5bucket?5but?5it?8s?5not?5the?5fi@ DB 'main bucke'
	DB	't but it''s not the first one', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IEDLEJJH@first?5bucket?5but?5it?8s?5an?5includ@
CONST	SEGMENT
??_C@_0CN@IEDLEJJH@first?5bucket?5but?5it?8s?5an?5includ@ DB 'first bucke'
	DB	't but it''s an include or redefine', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CMBPIEML@allocating?5schema?5bucket@
CONST	SEGMENT
??_C@_0BJ@CMBPIEML@allocating?5schema?5bucket@ DB 'allocating schema buck'
	DB	'et', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KOPDJPPO@xmlSchemaBucketCreate@
CONST	SEGMENT
??_C@_0BG@KOPDJPPO@xmlSchemaBucketCreate@ DB 'xmlSchemaBucketCreate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PGEEMOLL@no?5main?5schema?5on?5constructor@
CONST	SEGMENT
??_C@_0BO@PGEEMOLL@no?5main?5schema?5on?5constructor@ DB 'no main schema '
	DB	'on constructor', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@PONCBEFB@Internal?5error?3?5xmlSchemaItemLi@
CONST	SEGMENT
??_C@_0DH@PONCBEFB@Internal?5error?3?5xmlSchemaItemLi@ DB 'Internal error'
	DB	': xmlSchemaItemListRemove, index error.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PKMEEMHP@growing?5item?5list@
CONST	SEGMENT
??_C@_0BC@PKMEEMHP@growing?5item?5list@ DB 'growing item list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JABJNCPJ@allocating?5new?5item?5list@
CONST	SEGMENT
??_C@_0BJ@JABJNCPJ@allocating?5new?5item?5list@ DB 'allocating new item l'
	DB	'ist', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BAFOADOL@allocating?5an?5item?5list?5structu@
CONST	SEGMENT
??_C@_0CC@BAFOADOL@allocating?5an?5item?5list?5structu@ DB 'allocating an'
	DB	' item list structure', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ICNGEPGO@allocating?5annotation@
CONST	SEGMENT
??_C@_0BG@ICNGEPGO@allocating?5annotation@ DB 'allocating annotation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BFLACGOA@allocating?5schema@
CONST	SEGMENT
??_C@_0BC@BFLACGOA@allocating?5schema@ DB 'allocating schema', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IENIKLPP@?$CFs?3?5The?5content?5is?5not?5valid?4?6@
CONST	SEGMENT
??_C@_0BP@IENIKLPP@?$CFs?3?5The?5content?5is?5not?5valid?4?6@ DB '%s: The'
	DB	' content is not valid.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
CONST	SEGMENT
??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@ DB '%s: Th'
	DB	'e content is not valid. Expected is %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03CLGCDEAE@?8?4?6@
CONST	SEGMENT
??_C@_03CLGCDEAE@?8?4?6@ DB '''.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PICMEPAD@?5Expected?5is?5?8@
CONST	SEGMENT
??_C@_0P@PICMEPAD@?5Expected?5is?5?8@ DB ' Expected is ''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BMFBGFDE@The?5character?5content?5is?5not?5va@
CONST	SEGMENT
??_C@_0CE@BMFBGFDE@The?5character?5content?5is?5not?5va@ DB 'The characte'
	DB	'r content is not valid.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HAAPLFMH@The?5value?5?8?$CFs?8?5is?5not?5valid?4@
CONST	SEGMENT
??_C@_0BN@HAAPLFMH@The?5value?5?8?$CFs?8?5is?5not?5valid?4@ DB 'The value'
	DB	' ''%s'' is not valid.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DGLLHPKE@?8?4@
CONST	SEGMENT
??_C@_02DGLLHPKE@?8?4@ DB '''.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HPMJEOHA@?$CFs?3?5The?5attributes?5?8?$CFs?8?5and?5?8?$CFs@
CONST	SEGMENT
??_C@_0DK@HPMJEOHA@?$CFs?3?5The?5attributes?5?8?$CFs?8?5and?5?8?$CFs@ DB '%'
	DB	's: The attributes ''%s'' and ''%s'' are mutually exclusive.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OEIFIFDF@?$CFs?3?5The?5facet?5?8?$CFs?8?5is?5not?5allow@
CONST	SEGMENT
??_C@_0CE@OEIFIFDF@?$CFs?3?5The?5facet?5?8?$CFs?8?5is?5not?5allow@ DB '%s'
	DB	': The facet ''%s'' is not allowed.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@LINCPIFE@?$CFs?3?5The?5facet?5?8?$CFs?8?5is?5not?5allow@
CONST	SEGMENT
??_C@_0EG@LINCPIFE@?$CFs?3?5The?5facet?5?8?$CFs?8?5is?5not?5allow@ DB '%s'
	DB	': The facet ''%s'' is not allowed on types derived from the t'
	DB	'ype %s.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFAOODAA@?$CFs?3?5@
CONST	SEGMENT
??_C@_04PFAOODAA@?$CFs?3?5@ DB '%s: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GPHLIIIG@?$CFsThe?5attribute?5?8?$CFs?8?5is?5not?5all@
CONST	SEGMENT
??_C@_0CG@GPHLIIIG@?$CFsThe?5attribute?5?8?$CFs?8?5is?5not?5all@ DB '%sTh'
	DB	'e attribute ''%s'' is not allowed.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EDCPEHIM@?$CFs?0?5attribute?5?8?$CFs?8?3?5?$CFs?4?6@
CONST	SEGMENT
??_C@_0BJ@EDCPEHIM@?$CFs?0?5attribute?5?8?$CFs?8?3?5?$CFs?4?6@ DB '%s, at'
	DB	'tribute ''%s'': %s.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown@ DB 'Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@GOOOKJLI@?$CFs?0?5attribute?5?8?$CFs?8?3?5The?5QName?5v@
CONST	SEGMENT
??_C@_0EH@GOOOKJLI@?$CFs?0?5attribute?5?8?$CFs?8?3?5The?5QName?5v@ DB '%s'
	DB	', attribute ''%s'': The QName value ''%s'' does not resolve t'
	DB	'o a(n) %s.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@
CONST	SEGMENT
??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@ DB '%s:'
	DB	' The attribute ''%s'' is required but missing.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EAGHGJIC@?$CFs?3?5?$CFs?4?6@
CONST	SEGMENT
??_C@_08EAGHGJIC@?$CFs?3?5?$CFs?4?6@ DB '%s: %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CKLMMNCB@The?5value?5is?5not?5facet?9valid?4?6@
CONST	SEGMENT
??_C@_0BP@CKLMMNCB@The?5value?5is?5not?5facet?9valid?4?6@ DB 'The value i'
	DB	's not facet-valid.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HKFPHOBG@The?5value?5?8?$CFs?8?5is?5not?5facet?9val@
CONST	SEGMENT
??_C@_0CE@HKFPHOBG@The?5value?5?8?$CFs?8?5is?5not?5facet?9val@ DB 'The va'
	DB	'lue ''%s'' is not facet-valid.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@PPGDNELD@The?5value?5?8?$CFs?8?5has?5more?5fractio@
CONST	SEGMENT
??_C@_0EE@PPGDNELD@The?5value?5?8?$CFs?8?5has?5more?5fractio@ DB 'The val'
	DB	'ue ''%s'' has more fractional digits than are allowed (''%s'''
	DB	').', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@CHBCAGLC@The?5value?5?8?$CFs?8?5has?5more?5digits?5@
CONST	SEGMENT
??_C@_0DJ@CHBCAGLC@The?5value?5?8?$CFs?8?5has?5more?5digits?5@ DB 'The va'
	DB	'lue ''%s'' has more digits than are allowed (''%s'').', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DMBEGLJK@The?5value?5?8?$CFs?8?5must?5be?5less?5tha@
CONST	SEGMENT
??_C@_0CI@DMBEGLJK@The?5value?5?8?$CFs?8?5must?5be?5less?5tha@ DB 'The va'
	DB	'lue ''%s'' must be less than ''%s''.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CEDGHCDN@The?5value?5?8?$CFs?8?5must?5be?5greater?5@
CONST	SEGMENT
??_C@_0CL@CEDGHCDN@The?5value?5?8?$CFs?8?5must?5be?5greater?5@ DB 'The va'
	DB	'lue ''%s'' must be greater than ''%s''.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@ODIEFLC@The?5value?5?8?$CFs?8?5is?5greater?5than?5@
CONST	SEGMENT
??_C@_0EC@ODIEFLC@The?5value?5?8?$CFs?8?5is?5greater?5than?5@ DB 'The val'
	DB	'ue ''%s'' is greater than the maximum value allowed (''%s'').'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@JKCFEDLM@The?5value?5?8?$CFs?8?5is?5less?5than?5the@
CONST	SEGMENT
??_C@_0DP@JKCFEDLM@The?5value?5?8?$CFs?8?5is?5less?5than?5the@ DB 'The va'
	DB	'lue ''%s'' is less than the minimum value allowed (''%s'').', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@NEKJCLEF@The?5value?5?8?$CFs?8?5is?5not?5accepted?5@
CONST	SEGMENT
??_C@_0DF@NEKJCLEF@The?5value?5?8?$CFs?8?5is?5not?5accepted?5@ DB 'The va'
	DB	'lue ''%s'' is not accepted by the pattern ''%s''.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@DOBLIGCG@The?5value?5?8?$CFs?8?5is?5not?5an?5elemen@
CONST	SEGMENT
??_C@_0DD@DOBLIGCG@The?5value?5?8?$CFs?8?5is?5not?5an?5elemen@ DB 'The va'
	DB	'lue ''%s'' is not an element of the set {%s}.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PEKKBPHG@this?5underruns?5the?5allowed?5mini@
CONST	SEGMENT
??_C@_0DE@PEKKBPHG@this?5underruns?5the?5allowed?5mini@ DB 'this underrun'
	DB	's the allowed minimum length of ''%s''.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@OJNJPCCF@this?5exceeds?5the?5allowed?5maximu@
CONST	SEGMENT
??_C@_0DC@OJNJPCCF@this?5exceeds?5the?5allowed?5maximu@ DB 'this exceeds '
	DB	'the allowed maximum length of ''%s''.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@IEDJOHDN@this?5differs?5from?5the?5allowed?5l@
CONST	SEGMENT
??_C@_0CP@IEDJOHDN@this?5differs?5from?5the?5allowed?5l@ DB 'this differs'
	DB	' from the allowed length of ''%s''.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03FKNCMABI@?$CFlu@
CONST	SEGMENT
??_C@_03FKNCMABI@?$CFlu@ DB '%lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KPGCMBDK@The?5value?5has?5a?5length?5of?5?8?$CFs?8?$DL@
CONST	SEGMENT
??_C@_0CB@KPGCMBDK@The?5value?5has?5a?5length?5of?5?8?$CFs?8?$DL@ DB 'The'
	DB	' value has a length of ''%s''; ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GNANNDNL@The?5value?5?8?$CFs?8?5has?5a?5length?5of?5@
CONST	SEGMENT
??_C@_0CG@GNANNDNL@The?5value?5?8?$CFs?8?5has?5a?5length?5of?5@ DB 'The v'
	DB	'alue ''%s'' has a length of ''%s''; ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03BCLOCOCF@?8?$FN?5@
CONST	SEGMENT
??_C@_03BCLOCOCF@?8?$FN?5@ DB '''] ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL@
CONST	SEGMENT
??_C@_01OHGJGJJP@?$FL@ DB '[', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04ONBKEEDC@?5?$CJ?4?6@
CONST	SEGMENT
??_C@_04ONBKEEDC@?5?$CJ?4?6@ DB ' ).', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09OEHCBIBE@?$HL?$CD?$CDother?3@
CONST	SEGMENT
??_C@_09OEHCBIBE@?$HL?$CD?$CDother?3@ DB '{##other:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03MNMOMDPD@?$HL?$CK?$HN@
CONST	SEGMENT
??_C@_03MNMOMDPD@?$HL?$CK?$HN@ DB '{*}', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07ELAGFAPB@?$CD?$CDother@
CONST	SEGMENT
??_C@_07ELAGFAPB@?$CD?$CDother@ DB '##other', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HCJBOGK@?5Expected?5is?5?$CI?5@
CONST	SEGMENT
??_C@_0BA@HCJBOGK@?5Expected?5is?5?$CI?5@ DB ' Expected is ( ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JGKEPFCF@?5Expected?5is?5one?5of?5?$CI?5@
CONST	SEGMENT
??_C@_0BH@JGKEPFCF@?5Expected?5is?5one?5of?5?$CI?5@ DB ' Expected is one '
	DB	'of ( ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FELNOPMA@The?5attribute?5?8?$CFs?8?5is?5not?5allow@
CONST	SEGMENT
??_C@_0CE@FELNOPMA@The?5attribute?5?8?$CFs?8?5is?5not?5allow@ DB 'The att'
	DB	'ribute ''%s'' is not allowed.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03DCOKAOA@xs?3@
CONST	SEGMENT
??_C@_03DCOKAOA@xs?3@ DB 'xs:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BAIFLMGI@the?5@
CONST	SEGMENT
??_C@_04BAIFLMGI@the?5@ DB 'the ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MLMEJNFI@the?5local?5@
CONST	SEGMENT
??_C@_0L@MLMEJNFI@the?5local?5@ DB 'the local ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@NNGHIIKI@The?5character?5content?5is?5not?5a?5@
CONST	SEGMENT
??_C@_0CP@NNGHIIKI@The?5character?5content?5is?5not?5a?5@ DB 'The charact'
	DB	'er content is not a valid value of ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ONHLDAAN@?8?$CFs?8?5is?5not?5a?5valid?5value?5of?5@
CONST	SEGMENT
??_C@_0BO@ONHLDAAN@?8?$CFs?8?5is?5not?5a?5valid?5value?5of?5@ DB '''%s'' '
	DB	'is not a valid value of ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KFJAHJM@Element?5?8?$CFs?8?3?5@
CONST	SEGMENT
??_C@_0P@KFJAHJM@Element?5?8?$CFs?8?3?5@ DB 'Element ''%s'': ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MIICKFIN@?4?6@
CONST	SEGMENT
??_C@_02MIICKFIN@?4?6@ DB '.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EFOKBLAL@Internal?5error?3?5?$CFs?0?5@
CONST	SEGMENT
??_C@_0BF@EFOKBLAL@Internal?5error?3?5?$CFs?0?5@ DB 'Internal error: %s, '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03FPCGPDIA@?8?3?5@
CONST	SEGMENT
??_C@_03FPCGPDIA@?8?3?5@ DB ''': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DCJBDJKC@attribute?5?8@
CONST	SEGMENT
??_C@_0M@DCJBDJKC@attribute?5?8@ DB 'attribute ''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03EHINCMEC@?8?0?5@
CONST	SEGMENT
??_C@_03EHINCMEC@?8?0?5@ DB ''', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
CONST	SEGMENT
??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ DB 'Unimplem'
	DB	'ented block at %s:%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GM@IJCDLDON@c?3?2users?2dag?2documents?2_clients@
CONST	SEGMENT
??_C@_0GM@IJCDLDON@c?3?2users?2dag?2documents?2_clients@ DB 'c:\users\dag'
	DB	'\documents\_clients\codeproject authors group\windows on arm\'
	DB	'libxml2\libxml2-2.9.9\xmlschemas.c', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03NGNHMEOA@?0?5?8@
CONST	SEGMENT
??_C@_03NGNHMEOA@?0?5?8@ DB ', ''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OEBNECHE@xmlSchemaFormatFacetEnumSet@
CONST	SEGMENT
??_C@_0BM@OEBNECHE@xmlSchemaFormatFacetEnumSet@ DB 'xmlSchemaFormatFacetE'
	DB	'numSet', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FICFNABL@compute?5the?5canonical?5lexical?5r@
CONST	SEGMENT
??_C@_0CN@FICFNABL@compute?5the?5canonical?5lexical?5r@ DB 'compute the c'
	DB	'anonical lexical representation', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MMBACEAK@?0?5attribute?5?8@
CONST	SEGMENT
??_C@_0O@MMBACEAK@?0?5attribute?5?8@ DB ', attribute ''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NEDFDOKM@Element?5?8@
CONST	SEGMENT
??_C@_09NEDFDOKM@Element?5?8@ DB 'Element ''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IMEONDPK@model?5group?5def?4@
CONST	SEGMENT
??_C@_0BB@IMEONDPK@model?5group?5def?4@ DB 'model group def.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HIPPIIHM@facet?5?8@
CONST	SEGMENT
??_C@_07HIPPIIHM@facet?5?8@ DB 'facet ''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NMNBGFGO@?5wildcard@
CONST	SEGMENT
??_C@_09NMNBGFGO@?5wildcard@ DB ' wildcard', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MKGKMCJE@keyRef?5?8@
CONST	SEGMENT
??_C@_08MKGKMCJE@keyRef?5?8@ DB 'keyRef ''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05IJGDECGL@key?5?8@
CONST	SEGMENT
??_C@_05IJGDECGL@key?5?8@ DB 'key ''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GHLBJEBL@unique?5?8@
CONST	SEGMENT
??_C@_08GHLBJEBL@unique?5?8@ DB 'unique ''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HMOECBPO@element?5decl?4@
CONST	SEGMENT
??_C@_0O@HMOECBPO@element?5decl?4@ DB 'element decl.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NHBCAGDA@attribute?5decl?4@
CONST	SEGMENT
??_C@_0BA@NHBCAGDA@attribute?5decl?4@ DB 'attribute decl.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GPGAJHPD@?$CIunknown?$CJ@
CONST	SEGMENT
??_C@_09GPGAJHPD@?$CIunknown?$CJ@ DB '(unknown)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LDLBBJOE@attribute?5use?5@
CONST	SEGMENT
??_C@_0P@LDLBBJOE@attribute?5use?5@ DB 'attribute use ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NIBELLIN@complex?5type@
CONST	SEGMENT
??_C@_0N@NIBELLIN@complex?5type@ DB 'complex type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CHKFADBH@simple?5type@
CONST	SEGMENT
??_C@_0M@CHKFADBH@simple?5type@ DB 'simple type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KHBDGNKM@union?5type@
CONST	SEGMENT
??_C@_0L@KHBDGNKM@union?5type@ DB 'union type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EMCEHNFO@list?5type@
CONST	SEGMENT
??_C@_09EMCEHNFO@list?5type@ DB 'list type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NAKOLHPN@atomic?5type@
CONST	SEGMENT
??_C@_0M@NAKOLHPN@atomic?5type@ DB 'atomic type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FOGGDAIC@local?5@
CONST	SEGMENT
??_C@_06FOGGDAIC@local?5@ DB 'local ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GMNLLPLD@simple?5type?5?8xs?3@
CONST	SEGMENT
??_C@_0BB@GMNLLPLD@simple?5type?5?8xs?3@ DB 'simple type ''xs:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CKGFBMGP@union?5type?5?8xs?3@
CONST	SEGMENT
??_C@_0BA@CKGFBMGP@union?5type?5?8xs?3@ DB 'union type ''xs:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NECGJBPP@list?5type?5?8xs?3@
CONST	SEGMENT
??_C@_0P@NECGJBPP@list?5type?5?8xs?3@ DB 'list type ''xs:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MLAHCBJL@atomic?5type?5?8xs?3@
CONST	SEGMENT
??_C@_0BB@MLAHCBJL@atomic?5type?5?8xs?3@ DB 'atomic type ''xs:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IEOMLCDH@invalid?5process?5contents@
CONST	SEGMENT
??_C@_0BJ@IEOMLCDH@invalid?5process?5contents@ DB 'invalid process conten'
	DB	'ts', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06OLFOGHEN@strict@
CONST	SEGMENT
??_C@_06OLFOGHEN@strict@ DB 'strict', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BLIDKLB@lax@
CONST	SEGMENT
??_C@_03BLIDKLB@lax@ DB 'lax', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DLBGLKG@skip@
CONST	SEGMENT
??_C@_04DLBGLKG@skip@ DB 'skip', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8@
CONST	SEGMENT
??_C@_01GEODFPGF@?8@ DB '''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OCDGNCGI@?5?8@
CONST	SEGMENT
??_C@_02OCDGNCGI@?5?8@ DB ' ''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06LHGEHABH@?$CINULL?$CJ@
CONST	SEGMENT
??_C@_06LHGEHABH@?$CINULL?$CJ@ DB '(NULL)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL@
CONST	SEGMENT
??_C@_01HCONENDN@?$HL@ DB '{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CAFJLKIN@Not?5a?5schema?5component@
CONST	SEGMENT
??_C@_0BH@CAFJLKIN@Not?5a?5schema?5component@ DB 'Not a schema component', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@OAJJPDIM@?$FLhelper?5component?$FN?5attribute?5us@
CONST	SEGMENT
??_C@_0CN@OAJJPDIM@?$FLhelper?5component?$FN?5attribute?5us@ DB '[helper '
	DB	'component] attribute use prohibition', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GEFKFDJJ@?$FLhelper?5component?$FN?5QName?5refere@
CONST	SEGMENT
??_C@_0CD@GEFKFDJJ@?$FLhelper?5component?$FN?5QName?5refere@ DB '[helper '
	DB	'component] QName reference', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BBIPBLEO@wildcard?5?$CIany?$CJ@
CONST	SEGMENT
??_C@_0P@BBIPBLEO@wildcard?5?$CIany?$CJ@ DB 'wildcard (any)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GKPNKMCM@keyref?5identity?9constraint@
CONST	SEGMENT
??_C@_0BL@GKPNKMCM@keyref?5identity?9constraint@ DB 'keyref identity-cons'
	DB	'traint', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LJCGFAMF@key?5identity?9constraint@
CONST	SEGMENT
??_C@_0BI@LJCGFAMF@key?5identity?9constraint@ DB 'key identity-constraint'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NFCPOJDK@unique?5identity?9constraint@
CONST	SEGMENT
??_C@_0BL@NFCPOJDK@unique?5identity?9constraint@ DB 'unique identity-cons'
	DB	'traint', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08PKKGOGAD@particle@
CONST	SEGMENT
??_C@_08PKKGOGAD@particle@ DB 'particle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IIBLBPCH@model?5group?5?$CIall?$CJ@
CONST	SEGMENT
??_C@_0BC@IIBLBPCH@model?5group?5?$CIall?$CJ@ DB 'model group (all)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DBPJFANL@model?5group?5?$CIchoice?$CJ@
CONST	SEGMENT
??_C@_0BF@DBPJFANL@model?5group?5?$CIchoice?$CJ@ DB 'model group (choice)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EJHDDDLA@model?5group?5?$CIsequence?$CJ@
CONST	SEGMENT
??_C@_0BH@EJHDDDLA@model?5group?5?$CIsequence?$CJ@ DB 'model group (seque'
	DB	'nce)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JHGFINH@notation?5declaration@
CONST	SEGMENT
??_C@_0BF@JHGFINH@notation?5declaration@ DB 'notation declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LEHHANJP@attribute?5group?5definition@
CONST	SEGMENT
??_C@_0BL@LEHHANJP@attribute?5group?5definition@ DB 'attribute group defi'
	DB	'nition', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MMBLGEHA@model?5group?5definition@
CONST	SEGMENT
??_C@_0BH@MMBLGEHA@model?5group?5definition@ DB 'model group definition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EDIHLHKC@attribute?5declaration@
CONST	SEGMENT
??_C@_0BG@EDIHLHKC@attribute?5declaration@ DB 'attribute declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OMANOKDA@attribute?5use@
CONST	SEGMENT
??_C@_0O@OMANOKDA@attribute?5use@ DB 'attribute use', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GNKEMAII@element?5declaration@
CONST	SEGMENT
??_C@_0BE@GNKEMAII@element?5declaration@ DB 'element declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MHGDJJNC@complex?5type?5definition@
CONST	SEGMENT
??_C@_0BI@MHGDJJNC@complex?5type?5definition@ DB 'complex type definition'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BIKOCJPH@simple?5type?5definition@
CONST	SEGMENT
??_C@_0BH@BIKOCJPH@simple?5type?5definition@ DB 'simple type definition', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_xmlSchemaNs DD	FLAT:??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
_xmlSchemaInstanceNs DD FLAT:??_C@_0CK@FAJBIKFJ@http?3?1?1www?4w3?4org?12001?1XMLSchem@
_xmlNamespaceNs DD FLAT:??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidateStreamLocator
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_file$ = 12						; size = 4
_line$ = 16						; size = 4
_xmlSchemaValidateStreamLocator PROC			; COMDAT

; 28826:                                unsigned long *line) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaV

; 28827:     xmlParserCtxtPtr ctxt;
; 28828: 
; 28829:     if ((ctx == NULL) || ((file == NULL) && (line == NULL)))

	mov	edx, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _line$[ebp]
	test	edx, edx
	jne	SHORT $LN10@xmlSchemaV
	test	ecx, ecx
	jne	SHORT $LN11@xmlSchemaV
$LN3@xmlSchemaV:

; 28830:         return(-1);

	or	eax, -1
	pop	esi

; 28844:     }
; 28845:     return(-1);
; 28846: }

	pop	ebp
	ret	0
$LN10@xmlSchemaV:

; 28831: 
; 28832:     if (file != NULL)
; 28833:         *file = NULL;

	mov	DWORD PTR [edx], 0

; 28834:     if (line != NULL)

	test	ecx, ecx
	je	SHORT $LN5@xmlSchemaV
$LN11@xmlSchemaV:

; 28835:         *line = 0;

	mov	DWORD PTR [ecx], 0
$LN5@xmlSchemaV:

; 28836: 
; 28837:     ctxt = (xmlParserCtxtPtr) ctx;
; 28838:     if (ctxt->input != NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaV

; 28839:        if (file != NULL)

	test	edx, edx
	je	SHORT $LN7@xmlSchemaV

; 28840:            *file = ctxt->input->filename;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx], eax
$LN7@xmlSchemaV:

; 28841:        if (line != NULL)

	test	ecx, ecx
	je	SHORT $LN8@xmlSchemaV

; 28842:            *line = ctxt->input->line;

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx], eax
$LN8@xmlSchemaV:

; 28843:        return(0);

	xor	eax, eax
	pop	esi

; 28844:     }
; 28845:     return(-1);
; 28846: }

	pop	ebp
	ret	0
_xmlSchemaValidateStreamLocator ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _endElementNsSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_localname$ = 12					; size = 4
_prefix$ = 16						; size = 4
_URI$ = 20						; size = 4
_endElementNsSplit PROC					; COMDAT

; 28601: 		    const xmlChar * prefix, const xmlChar * URI) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	SHORT $LN4@endElement

; 28602:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28603:     if (ctxt == NULL)
; 28604:         return;
; 28605:     if ((ctxt->user_sax != NULL) &&

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _localname$[ebp]
	test	eax, eax
	je	SHORT $LN3@endElement
	mov	eax, DWORD PTR [eax+120]
	test	eax, eax
	je	SHORT $LN3@endElement

; 28606:         (ctxt->user_sax->endElementNs != NULL))
; 28607: 	ctxt->user_sax->endElementNs(ctxt->user_data, localname, prefix, URI);

	push	DWORD PTR _URI$[ebp]
	push	DWORD PTR _prefix$[ebp]
	push	ecx
	push	DWORD PTR [esi+16]
	call	eax
	mov	ecx, DWORD PTR _localname$[ebp]
	add	esp, 16					; 00000010H
$LN3@endElement:

; 28608:     if (ctxt->ctxt != NULL)

	mov	eax, DWORD PTR [esi+148]
	test	eax, eax
	je	SHORT $LN4@endElement
	pop	esi

; 28609: 	xmlSchemaSAXHandleEndElementNs(ctxt->ctxt, localname, prefix, URI);

	mov	DWORD PTR _localname$[ebp], ecx
	mov	DWORD PTR _ctx$[ebp], eax

; 28610: }

	pop	ebp

; 28609: 	xmlSchemaSAXHandleEndElementNs(ctxt->ctxt, localname, prefix, URI);

	jmp	_xmlSchemaSAXHandleEndElementNs
$LN4@endElement:
	pop	esi

; 28610: }

	pop	ebp
	ret	0
_endElementNsSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _startElementNsSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_localname$ = 12					; size = 4
_prefix$ = 16						; size = 4
_URI$ = 20						; size = 4
_nb_namespaces$ = 24					; size = 4
_namespaces$ = 28					; size = 4
_nb_attributes$ = 32					; size = 4
_nb_defaulted$ = 36					; size = 4
_attributes$ = 40					; size = 4
_startElementNsSplit PROC				; COMDAT

; 28582: 		    const xmlChar ** attributes) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	SHORT $LN4@startEleme

; 28583:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28584:     if (ctxt == NULL)
; 28585:         return;
; 28586:     if ((ctxt->user_sax != NULL) &&

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _nb_attributes$[ebp]
	mov	edx, DWORD PTR _namespaces$[ebp]
	test	eax, eax
	je	SHORT $LN3@startEleme
	mov	eax, DWORD PTR [eax+116]
	test	eax, eax
	je	SHORT $LN3@startEleme

; 28587:         (ctxt->user_sax->startElementNs != NULL))
; 28588: 	ctxt->user_sax->startElementNs(ctxt->user_data, localname, prefix,

	push	DWORD PTR _attributes$[ebp]
	push	DWORD PTR _nb_defaulted$[ebp]
	push	ecx
	push	edx
	push	DWORD PTR _nb_namespaces$[ebp]
	push	DWORD PTR _URI$[ebp]
	push	DWORD PTR _prefix$[ebp]
	push	DWORD PTR _localname$[ebp]
	push	DWORD PTR [esi+16]
	call	eax
	mov	ecx, DWORD PTR _nb_attributes$[ebp]
	add	esp, 36					; 00000024H
	mov	edx, DWORD PTR _namespaces$[ebp]
$LN3@startEleme:

; 28589: 	                               URI, nb_namespaces, namespaces,
; 28590: 				       nb_attributes, nb_defaulted,
; 28591: 				       attributes);
; 28592:     if (ctxt->ctxt != NULL)

	mov	eax, DWORD PTR [esi+148]
	test	eax, eax
	je	SHORT $LN4@startEleme
	pop	esi

; 28593: 	xmlSchemaSAXHandleStartElementNs(ctxt->ctxt, localname, prefix,

	mov	DWORD PTR _nb_attributes$[ebp], ecx
	mov	DWORD PTR _namespaces$[ebp], edx
	mov	DWORD PTR _ctx$[ebp], eax

; 28594: 	                                 URI, nb_namespaces, namespaces,
; 28595: 					 nb_attributes, nb_defaulted,
; 28596: 					 attributes);
; 28597: }

	pop	ebp

; 28593: 	xmlSchemaSAXHandleStartElementNs(ctxt->ctxt, localname, prefix,

	jmp	_xmlSchemaSAXHandleStartElementNs
$LN4@startEleme:
	pop	esi

; 28594: 	                                 URI, nb_namespaces, namespaces,
; 28595: 					 nb_attributes, nb_defaulted,
; 28596: 					 attributes);
; 28597: }

	pop	ebp
	ret	0
_startElementNsSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _referenceSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_referenceSplit PROC					; COMDAT

; 28566: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	SHORT $LN4@referenceS

; 28567:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28568:     if (ctxt == NULL)
; 28569:         return;
; 28570:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@referenceS
	mov	eax, DWORD PTR [eax+64]
	test	eax, eax
	je	SHORT $LN3@referenceS

; 28571:         (ctxt->user_sax->reference != NULL))
; 28572: 	ctxt->user_sax->reference(ctxt->user_data, name);

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [esi+16]
	call	eax
	add	esp, 8
$LN3@referenceS:

; 28573:     if (ctxt->ctxt != NULL)

	cmp	DWORD PTR [esi+148], 0
	je	SHORT $LN4@referenceS

; 28574:         xmlSchemaSAXHandleReference(ctxt->user_data, name);

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [esi+16]
	call	_xmlSchemaSAXHandleReference
	add	esp, 8
$LN4@referenceS:
	pop	esi

; 28575: }

	pop	ebp
	ret	0
_referenceSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _cdataBlockSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_value$ = 12						; size = 4
_len$ = 16						; size = 4
_cdataBlockSplit PROC					; COMDAT

; 28553: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	SHORT $LN4@cdataBlock

; 28554:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28555:     if (ctxt == NULL)
; 28556:         return;
; 28557:     if ((ctxt->user_sax != NULL) &&

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@cdataBlock
	mov	eax, DWORD PTR [eax+100]
	test	eax, eax
	je	SHORT $LN3@cdataBlock

; 28558:         (ctxt->user_sax->cdataBlock != NULL))
; 28559: 	ctxt->user_sax->cdataBlock(ctxt->user_data, value, len);

	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR [esi+16]
	call	eax
	add	esp, 12					; 0000000cH
$LN3@cdataBlock:

; 28560:     if (ctxt->ctxt != NULL)

	mov	eax, DWORD PTR [esi+148]
	test	eax, eax
	je	SHORT $LN4@cdataBlock
	pop	esi

; 28561: 	xmlSchemaSAXHandleCDataSection(ctxt->ctxt, value, len);

	mov	DWORD PTR _ctx$[ebp], eax

; 28562: }

	pop	ebp

; 28561: 	xmlSchemaSAXHandleCDataSection(ctxt->ctxt, value, len);

	jmp	_xmlSchemaSAXHandleCDataSection
$LN4@cdataBlock:
	pop	esi

; 28562: }

	pop	ebp
	ret	0
_cdataBlockSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _ignorableWhitespaceSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_ch$ = 12						; size = 4
_len$ = 16						; size = 4
_ignorableWhitespaceSplit PROC				; COMDAT

; 28540: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	SHORT $LN4@ignorableW

; 28541:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28542:     if (ctxt == NULL)
; 28543:         return;
; 28544:     if ((ctxt->user_sax != NULL) &&

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@ignorableW
	mov	eax, DWORD PTR [eax+72]
	test	eax, eax
	je	SHORT $LN3@ignorableW

; 28545:         (ctxt->user_sax->ignorableWhitespace != NULL))
; 28546: 	ctxt->user_sax->ignorableWhitespace(ctxt->user_data, ch, len);

	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _ch$[ebp]
	push	DWORD PTR [esi+16]
	call	eax
	add	esp, 12					; 0000000cH
$LN3@ignorableW:

; 28547:     if (ctxt->ctxt != NULL)

	mov	eax, DWORD PTR [esi+148]
	test	eax, eax
	je	SHORT $LN4@ignorableW
	pop	esi

; 28548: 	xmlSchemaSAXHandleText(ctxt->ctxt, ch, len);

	mov	DWORD PTR _ctx$[ebp], eax

; 28549: }

	pop	ebp

; 28548: 	xmlSchemaSAXHandleText(ctxt->ctxt, ch, len);

	jmp	_xmlSchemaSAXHandleText
$LN4@ignorableW:
	pop	esi

; 28549: }

	pop	ebp
	ret	0
_ignorableWhitespaceSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _charactersSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_ch$ = 12						; size = 4
_len$ = 16						; size = 4
_charactersSplit PROC					; COMDAT

; 28528: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	SHORT $LN4@characters

; 28529:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28530:     if (ctxt == NULL)
; 28531:         return;
; 28532:     if ((ctxt->user_sax != NULL) && (ctxt->user_sax->characters != NULL))

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@characters
	mov	eax, DWORD PTR [eax+68]
	test	eax, eax
	je	SHORT $LN3@characters

; 28533: 	ctxt->user_sax->characters(ctxt->user_data, ch, len);

	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _ch$[ebp]
	push	DWORD PTR [esi+16]
	call	eax
	add	esp, 12					; 0000000cH
$LN3@characters:

; 28534:     if (ctxt->ctxt != NULL)

	mov	eax, DWORD PTR [esi+148]
	test	eax, eax
	je	SHORT $LN4@characters
	pop	esi

; 28535: 	xmlSchemaSAXHandleText(ctxt->ctxt, ch, len);

	mov	DWORD PTR _ctx$[ebp], eax

; 28536: }

	pop	ebp

; 28535: 	xmlSchemaSAXHandleText(ctxt->ctxt, ch, len);

	jmp	_xmlSchemaSAXHandleText
$LN4@characters:
	pop	esi

; 28536: }

	pop	ebp
	ret	0
_charactersSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _fatalErrorSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_msg$ = 12						; size = 4
_fatalErrorSplit PROC					; COMDAT

; 28514: fatalErrorSplit(void *ctx, const char *msg ATTRIBUTE_UNUSED, ...) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@fatalError

; 28515:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28516:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN2@fatalError
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN2@fatalError

; 28517:         (ctxt->user_sax->fatalError != NULL)) {
; 28518: 	TODO

	push	esi
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	28518					; 00006f66H
	push	OFFSET ??_C@_0GM@IJCDLDON@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	pop	esi
$LN2@fatalError:

; 28519:     }
; 28520: }

	pop	ebp
	ret	0
_fatalErrorSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _errorSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_msg$ = 12						; size = 4
_errorSplit PROC					; COMDAT

; 28506: errorSplit(void *ctx, const char *msg ATTRIBUTE_UNUSED, ...) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@errorSplit

; 28507:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28508:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN2@errorSplit
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $LN2@errorSplit

; 28509:         (ctxt->user_sax->error != NULL)) {
; 28510: 	TODO

	push	esi
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	28510					; 00006f5eH
	push	OFFSET ??_C@_0GM@IJCDLDON@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	pop	esi
$LN2@errorSplit:

; 28511:     }
; 28512: }

	pop	ebp
	ret	0
_errorSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _warningSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_msg$ = 12						; size = 4
_warningSplit PROC					; COMDAT

; 28498: warningSplit(void *ctx, const char *msg ATTRIBUTE_UNUSED, ...) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@warningSpl

; 28499:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28500:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN2@warningSpl
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN2@warningSpl

; 28501:         (ctxt->user_sax->warning != NULL)) {
; 28502: 	TODO

	push	esi
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	28502					; 00006f56H
	push	OFFSET ??_C@_0GM@IJCDLDON@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	pop	esi
$LN2@warningSpl:

; 28503:     }
; 28504: }

	pop	ebp
	ret	0
_warningSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _commentSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_value$ = 12						; size = 4
_commentSplit PROC					; COMDAT

; 28486: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@commentSpl

; 28487:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28488:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@commentSpl
	mov	ecx, DWORD PTR [ecx+80]
	test	ecx, ecx
	je	SHORT $LN2@commentSpl

; 28489:         (ctxt->user_sax->comment != NULL))
; 28490: 	ctxt->user_sax->comment(ctxt->user_data, value);

	push	DWORD PTR _value$[ebp]
	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 8
$LN2@commentSpl:

; 28491: }

	pop	ebp
	ret	0
_commentSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _processingInstructionSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_target$ = 12						; size = 4
_data$ = 16						; size = 4
_processingInstructionSplit PROC			; COMDAT

; 28477: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@processing

; 28478:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28479:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@processing
	mov	ecx, DWORD PTR [ecx+76]
	test	ecx, ecx
	je	SHORT $LN2@processing

; 28480:         (ctxt->user_sax->processingInstruction != NULL))
; 28481: 	ctxt->user_sax->processingInstruction(ctxt->user_data, target, data);

	push	DWORD PTR _data$[ebp]
	push	DWORD PTR _target$[ebp]
	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 12					; 0000000cH
$LN2@processing:

; 28482: }

	pop	ebp
	ret	0
_processingInstructionSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _endDocumentSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_endDocumentSplit PROC					; COMDAT

; 28467: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@endDocumen

; 28468:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28469:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@endDocumen
	mov	ecx, DWORD PTR [ecx+52]
	test	ecx, ecx
	je	SHORT $LN2@endDocumen

; 28470:         (ctxt->user_sax->endDocument != NULL))
; 28471: 	ctxt->user_sax->endDocument(ctxt->user_data);

	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 4
$LN2@endDocumen:

; 28472: }

	pop	ebp
	ret	0
_endDocumentSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _startDocumentSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_startDocumentSplit PROC				; COMDAT

; 28458: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@startDocum

; 28459:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28460:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@startDocum
	mov	ecx, DWORD PTR [ecx+48]
	test	ecx, ecx
	je	SHORT $LN2@startDocum

; 28461:         (ctxt->user_sax->startDocument != NULL))
; 28462: 	ctxt->user_sax->startDocument(ctxt->user_data);

	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 4
$LN2@startDocum:

; 28463: }

	pop	ebp
	ret	0
_startDocumentSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _setDocumentLocatorSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_loc$ = 12						; size = 4
_setDocumentLocatorSplit PROC				; COMDAT

; 28449: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@setDocumen

; 28450:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28451:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@setDocumen
	mov	ecx, DWORD PTR [ecx+44]
	test	ecx, ecx
	je	SHORT $LN2@setDocumen

; 28452:         (ctxt->user_sax->setDocumentLocator != NULL))
; 28453: 	ctxt->user_sax->setDocumentLocator(ctxt->user_data, loc);

	push	DWORD PTR _loc$[ebp]
	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 8
$LN2@setDocumen:

; 28454: }

	pop	ebp
	ret	0
_setDocumentLocatorSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _unparsedEntityDeclSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_publicId$ = 16						; size = 4
_systemId$ = 20						; size = 4
_notationName$ = 24					; size = 4
_unparsedEntityDeclSplit PROC				; COMDAT

; 28439: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@unparsedEn

; 28440:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28441:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@unparsedEn
	mov	ecx, DWORD PTR [ecx+40]
	test	ecx, ecx
	je	SHORT $LN2@unparsedEn

; 28442:         (ctxt->user_sax->unparsedEntityDecl != NULL))
; 28443: 	ctxt->user_sax->unparsedEntityDecl(ctxt->user_data, name, publicId,

	push	DWORD PTR _notationName$[ebp]
	push	DWORD PTR _systemId$[ebp]
	push	DWORD PTR _publicId$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 20					; 00000014H
$LN2@unparsedEn:

; 28444: 	                                   systemId, notationName);
; 28445: }

	pop	ebp
	ret	0
_unparsedEntityDeclSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _notationDeclSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_publicId$ = 16						; size = 4
_systemId$ = 20						; size = 4
_notationDeclSplit PROC					; COMDAT

; 28427: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@notationDe

; 28428:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28429:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@notationDe
	mov	ecx, DWORD PTR [ecx+28]
	test	ecx, ecx
	je	SHORT $LN2@notationDe

; 28430:         (ctxt->user_sax->notationDecl != NULL))
; 28431: 	ctxt->user_sax->notationDecl(ctxt->user_data, name, publicId,

	push	DWORD PTR _systemId$[ebp]
	push	DWORD PTR _publicId$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 16					; 00000010H
$LN2@notationDe:

; 28432: 	                             systemId);
; 28433: }

	pop	ebp
	ret	0
_notationDeclSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _elementDeclSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_type$ = 16						; size = 4
_content$ = 20						; size = 4
_elementDeclSplit PROC					; COMDAT

; 28417: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@elementDec

; 28418:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28419:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@elementDec
	mov	ecx, DWORD PTR [ecx+36]
	test	ecx, ecx
	je	SHORT $LN2@elementDec

; 28420:         (ctxt->user_sax->elementDecl != NULL))
; 28421: 	ctxt->user_sax->elementDecl(ctxt->user_data, name, type, content);

	push	DWORD PTR _content$[ebp]
	push	DWORD PTR _type$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 16					; 00000010H
$LN2@elementDec:

; 28422: }

	pop	ebp
	ret	0
_elementDeclSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _attributeDeclSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_elem$ = 12						; size = 4
_name$ = 16						; size = 4
_type$ = 20						; size = 4
_def$ = 24						; size = 4
_defaultValue$ = 28					; size = 4
_tree$ = 32						; size = 4
_attributeDeclSplit PROC				; COMDAT

; 28403: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@attributeD

; 28404:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28405:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@attributeD
	mov	ecx, DWORD PTR [ecx+32]
	test	ecx, ecx
	je	SHORT $LN2@attributeD

; 28406:         (ctxt->user_sax->attributeDecl != NULL)) {
; 28407: 	ctxt->user_sax->attributeDecl(ctxt->user_data, elem, name, type,

	push	DWORD PTR _tree$[ebp]
	push	DWORD PTR _defaultValue$[ebp]
	push	DWORD PTR _def$[ebp]
	push	DWORD PTR _type$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _elem$[ebp]
	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 28					; 0000001cH

; 28411:     }
; 28412: }

	pop	ebp
	ret	0
$LN2@attributeD:

; 28408: 	                              def, defaultValue, tree);
; 28409:     } else {
; 28410: 	xmlFreeEnumeration(tree);

	push	DWORD PTR _tree$[ebp]
	call	_xmlFreeEnumeration
	add	esp, 4

; 28411:     }
; 28412: }

	pop	ebp
	ret	0
_attributeDeclSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _entityDeclSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_type$ = 16						; size = 4
_publicId$ = 20						; size = 4
_systemId$ = 24						; size = 4
_content$ = 28						; size = 4
_entityDeclSplit PROC					; COMDAT

; 28391: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@entityDecl

; 28392:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28393:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@entityDecl
	mov	ecx, DWORD PTR [ecx+24]
	test	ecx, ecx
	je	SHORT $LN2@entityDecl

; 28394:         (ctxt->user_sax->entityDecl != NULL))
; 28395: 	ctxt->user_sax->entityDecl(ctxt->user_data, name, type, publicId,

	push	DWORD PTR _content$[ebp]
	push	DWORD PTR _systemId$[ebp]
	push	DWORD PTR _publicId$[ebp]
	push	DWORD PTR _type$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 24					; 00000018H
$LN2@entityDecl:

; 28396: 	                           systemId, content);
; 28397: }

	pop	ebp
	ret	0
_entityDeclSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _getParameterEntitySplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_getParameterEntitySplit PROC				; COMDAT

; 28379: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@getParamet

; 28380:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28381:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@getParamet
	mov	ecx, DWORD PTR [ecx+96]
	test	ecx, ecx
	je	SHORT $LN2@getParamet

; 28382:         (ctxt->user_sax->getParameterEntity != NULL))
; 28383: 	return(ctxt->user_sax->getParameterEntity(ctxt->user_data, name));

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 8

; 28385: }

	pop	ebp
	ret	0
$LN2@getParamet:

; 28384:     return(NULL);

	xor	eax, eax

; 28385: }

	pop	ebp
	ret	0
_getParameterEntitySplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _getEntitySplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_getEntitySplit PROC					; COMDAT

; 28369: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@getEntityS

; 28370:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28371:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@getEntityS
	mov	ecx, DWORD PTR [ecx+20]
	test	ecx, ecx
	je	SHORT $LN2@getEntityS

; 28372:         (ctxt->user_sax->getEntity != NULL))
; 28373: 	return(ctxt->user_sax->getEntity(ctxt->user_data, name));

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 8

; 28375: }

	pop	ebp
	ret	0
$LN2@getEntityS:

; 28374:     return(NULL);

	xor	eax, eax

; 28375: }

	pop	ebp
	ret	0
_getEntitySplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _resolveEntitySplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_publicId$ = 12						; size = 4
_systemId$ = 16						; size = 4
_resolveEntitySplit PROC				; COMDAT

; 28358: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@resolveEnt

; 28359:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28360:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@resolveEnt
	mov	ecx, DWORD PTR [ecx+16]
	test	ecx, ecx
	je	SHORT $LN2@resolveEnt

; 28361:         (ctxt->user_sax->resolveEntity != NULL))
; 28362: 	return(ctxt->user_sax->resolveEntity(ctxt->user_data, publicId,

	push	DWORD PTR _systemId$[ebp]
	push	DWORD PTR _publicId$[ebp]
	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 12					; 0000000cH

; 28365: }

	pop	ebp
	ret	0
$LN2@resolveEnt:

; 28363: 	                                     systemId));
; 28364:     return(NULL);

	xor	eax, eax

; 28365: }

	pop	ebp
	ret	0
_resolveEntitySplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _externalSubsetSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_ExternalID$ = 16					; size = 4
_SystemID$ = 20						; size = 4
_externalSubsetSplit PROC				; COMDAT

; 28348: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@externalSu

; 28349:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28350:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@externalSu
	mov	ecx, DWORD PTR [ecx+104]
	test	ecx, ecx
	je	SHORT $LN2@externalSu

; 28351:         (ctxt->user_sax->externalSubset != NULL))
; 28352: 	ctxt->user_sax->externalSubset(ctxt->user_data, name, ExternalID,

	push	DWORD PTR _SystemID$[ebp]
	push	DWORD PTR _ExternalID$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 16					; 00000010H
$LN2@externalSu:

; 28353: 	                               SystemID);
; 28354: }

	pop	ebp
	ret	0
_externalSubsetSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _hasExternalSubsetSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_hasExternalSubsetSplit PROC				; COMDAT

; 28337: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@hasExterna

; 28338:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28339:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@hasExterna
	mov	ecx, DWORD PTR [ecx+12]
	test	ecx, ecx
	je	SHORT $LN2@hasExterna

; 28340:         (ctxt->user_sax->hasExternalSubset != NULL))
; 28341: 	return(ctxt->user_sax->hasExternalSubset(ctxt->user_data));

	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 4

; 28343: }

	pop	ebp
	ret	0
$LN2@hasExterna:

; 28342:     return(0);

	xor	eax, eax

; 28343: }

	pop	ebp
	ret	0
_hasExternalSubsetSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _hasInternalSubsetSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_hasInternalSubsetSplit PROC				; COMDAT

; 28327: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@hasInterna

; 28328:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28329:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@hasInterna
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@hasInterna

; 28330:         (ctxt->user_sax->hasInternalSubset != NULL))
; 28331: 	return(ctxt->user_sax->hasInternalSubset(ctxt->user_data));

	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 4

; 28333: }

	pop	ebp
	ret	0
$LN2@hasInterna:

; 28332:     return(0);

	xor	eax, eax

; 28333: }

	pop	ebp
	ret	0
_hasInternalSubsetSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _isStandaloneSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_isStandaloneSplit PROC					; COMDAT

; 28317: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@isStandalo

; 28318:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28319:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@isStandalo
	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	je	SHORT $LN2@isStandalo

; 28320:         (ctxt->user_sax->isStandalone != NULL))
; 28321: 	return(ctxt->user_sax->isStandalone(ctxt->user_data));

	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 4

; 28323: }

	pop	ebp
	ret	0
$LN2@isStandalo:

; 28322:     return(0);

	xor	eax, eax

; 28323: }

	pop	ebp
	ret	0
_isStandaloneSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _internalSubsetSplit
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_ExternalID$ = 16					; size = 4
_SystemID$ = 20						; size = 4
_internalSubsetSplit PROC				; COMDAT

; 28307: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN2@internalSu

; 28308:     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
; 28309:     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@internalSu
	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@internalSu

; 28310:         (ctxt->user_sax->internalSubset != NULL))
; 28311: 	ctxt->user_sax->internalSubset(ctxt->user_data, name, ExternalID,

	push	DWORD PTR _SystemID$[ebp]
	push	DWORD PTR _ExternalID$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [eax+16]
	call	ecx
	add	esp, 16					; 00000010H
$LN2@internalSu:

; 28312: 	                               SystemID);
; 28313: }

	pop	ebp
	ret	0
_internalSubsetSplit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaVStart
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_xmlSchemaVStart PROC					; COMDAT

; 28180: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _vctxt$[ebp]
	xor	edi, edi
	push	esi
	call	_xmlSchemaPreRun
	add	esp, 4
	test	eax, eax
	jns	SHORT $LN2@xmlSchemaV

; 28181:     int ret = 0;
; 28182: 
; 28183:     if (xmlSchemaPreRun(vctxt) < 0)
; 28184:         return(-1);

	pop	edi
	or	eax, -1

; 28215: }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlSchemaV:

; 28185: 
; 28186:     if (vctxt->doc != NULL) {

	cmp	DWORD PTR [esi+24], edi
	je	SHORT $LN3@xmlSchemaV

; 28187: 	/*
; 28188: 	 * Tree validation.
; 28189: 	 */
; 28190: 	ret = xmlSchemaVDocWalk(vctxt);

	push	esi
	call	_xmlSchemaVDocWalk
	add	esp, 4
	mov	edi, eax
	jmp	SHORT $LN8@xmlSchemaV
$LN3@xmlSchemaV:

; 28191: #ifdef LIBXML_READER_ENABLED
; 28192:     } else if (vctxt->reader != NULL) {

	cmp	DWORD PTR [esi+160], edi
	jne	SHORT $LN8@xmlSchemaV

; 28193: 	/*
; 28194: 	 * XML Reader validation.
; 28195: 	 */
; 28196: #ifdef XML_SCHEMA_READER_ENABLED
; 28197: 	ret = xmlSchemaVReaderWalk(vctxt);
; 28198: #endif
; 28199: #endif
; 28200:     } else if ((vctxt->sax != NULL) && (vctxt->parserCtxt != NULL)) {

	cmp	DWORD PTR [esi+36], edi
	je	SHORT $LN7@xmlSchemaV
	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN7@xmlSchemaV

; 28201: 	/*
; 28202: 	 * SAX validation.
; 28203: 	 */
; 28204: 	ret = xmlParseDocument(vctxt->parserCtxt);

	push	eax
	call	_xmlParseDocument
	add	esp, 4
	mov	edi, eax

; 28205:     } else {

	jmp	SHORT $LN8@xmlSchemaV
$LN7@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BI@BPKAPLGE@no?5instance?5to?5validate@
	push	OFFSET ??_C@_0BA@HJOAFKLO@xmlSchemaVStart@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 28206: 	VERROR_INT("xmlSchemaVStart",
; 28207: 	    "no instance to validate");
; 28208: 	ret = -1;

	or	edi, -1
$LN8@xmlSchemaV:

; 28169:     if (vctxt->xsiAssemble) {

	cmp	DWORD PTR [esi+92], 0
	je	SHORT $LN15@xmlSchemaV

; 28170: 	if (vctxt->schema != NULL) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN15@xmlSchemaV

; 28171: 	    xmlSchemaFree(vctxt->schema);

	push	eax
	call	_xmlSchemaFree
	add	esp, 4

; 28172: 	    vctxt->schema = NULL;

	mov	DWORD PTR [esi+20], 0
$LN15@xmlSchemaV:

; 28173: 	}
; 28174:     }
; 28175:     xmlSchemaClearValidCtxt(vctxt);

	push	esi
	call	_xmlSchemaClearValidCtxt
	add	esp, 4

; 28209:     }
; 28210: 
; 28211:     xmlSchemaPostRun(vctxt);
; 28212:     if (ret == 0)

	test	edi, edi
	jne	SHORT $LN9@xmlSchemaV

; 28213: 	ret = vctxt->err;

	mov	edi, DWORD PTR [esi+52]
$LN9@xmlSchemaV:

; 28214:     return (ret);

	mov	eax, edi
	pop	edi

; 28215: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaVStart ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPostRun
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_xmlSchemaPostRun PROC					; COMDAT

; 28168: xmlSchemaPostRun(xmlSchemaValidCtxtPtr vctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _vctxt$[ebp]
	cmp	DWORD PTR [esi+92], 0
	je	SHORT $LN3@xmlSchemaP

; 28169:     if (vctxt->xsiAssemble) {
; 28170: 	if (vctxt->schema != NULL) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaP

; 28171: 	    xmlSchemaFree(vctxt->schema);

	push	eax
	call	_xmlSchemaFree
	add	esp, 4

; 28172: 	    vctxt->schema = NULL;

	mov	DWORD PTR [esi+20], 0
$LN3@xmlSchemaP:

; 28173: 	}
; 28174:     }
; 28175:     xmlSchemaClearValidCtxt(vctxt);

	push	esi
	call	_xmlSchemaClearValidCtxt
	add	esp, 4
	pop	esi

; 28176: }

	pop	ebp
	ret	0
_xmlSchemaPostRun ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPreRun
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_xmlSchemaPreRun PROC					; COMDAT

; 28106: xmlSchemaPreRun(xmlSchemaValidCtxtPtr vctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _vctxt$[ebp]
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+96], -1
	mov	DWORD PTR [esi+176], -1
	mov	DWORD PTR [esi+92], 0
	mov	DWORD PTR [esi+184], 0
	mov	DWORD PTR [esi+188], 0
	test	eax, eax
	jne	$LN2@xmlSchemaP

; 28107:     /*
; 28108:     * Some initialization.
; 28109:     */
; 28110:     vctxt->err = 0;
; 28111:     vctxt->nberrors = 0;
; 28112:     vctxt->depth = -1;
; 28113:     vctxt->skipDepth = -1;
; 28114:     vctxt->xsiAssemble = 0;
; 28115:     vctxt->hasKeyrefs = 0;
; 28116: #ifdef ENABLE_IDC_NODE_TABLES_TEST
; 28117:     vctxt->createIDCNodeTables = 1;
; 28118: #else
; 28119:     vctxt->createIDCNodeTables = 0;
; 28120: #endif
; 28121:     /*
; 28122:     * Create a schema + parser if necessary.
; 28123:     */
; 28124:     if (vctxt->schema == NULL) {
; 28125: 	xmlSchemaParserCtxtPtr pctxt;
; 28126: 
; 28127: 	vctxt->xsiAssemble = 1;

	mov	edi, DWORD PTR [esi+88]
	mov	DWORD PTR [esi+92], 1

; 28128: 	/*
; 28129: 	* If not schema was given then we will create a schema
; 28130: 	* dynamically using XSI schema locations.
; 28131: 	*
; 28132: 	* Create the schema parser context.
; 28133: 	*/
; 28134: 	if ((vctxt->pctxt == NULL) &&

	test	edi, edi
	jne	$LN31@xmlSchemaP

; 12494:     ret = xmlSchemaParserCtxtCreate();

	call	_xmlSchemaParserCtxtCreate
	mov	edi, eax

; 12495:     if (ret == NULL)

	test	edi, edi
	je	SHORT $LN17@xmlSchemaP
$LN19@xmlSchemaP:

; 12496: 	return(NULL);
; 12497:     ret->dict = xmlDictCreate();

	call	_xmlDictCreate

; 12498:     ret->URL = xmlDictLookup(ret->dict, (const xmlChar *) URL, -1);

	push	-1
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	push	eax
	mov	DWORD PTR [edi+80], eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+44], eax
$LN17@xmlSchemaP:

; 10035: 	if (vctxt->pctxt == NULL) {

	mov	DWORD PTR [esi+88], edi
	test	edi, edi
	jne	SHORT $LN11@xmlSchemaP

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	edi
	push	edi
	push	OFFSET ??_C@_0CI@GJEMMNOJ@failed?5to?5create?5a?5temp?4?5parser@
	push	OFFSET ??_C@_0BM@OJEBCMPM@xmlSchemaCreatePCtxtOnVCtxt@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$LN33@xmlSchemaP:
	pop	edi

; 28150: 	    return(-1);

	or	eax, -1

; 28165: }

	pop	esi
	pop	ebp
	ret	0
$LN11@xmlSchemaP:

; 10041: 	xmlSchemaSetParserErrors(vctxt->pctxt, vctxt->error,

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+8]

; 21460:     if (ctxt == NULL)

	test	eax, eax
	je	SHORT $LN25@xmlSchemaP

; 21461:         return;
; 21462:     ctxt->error = err;

	mov	DWORD PTR [eax+8], edi

; 21463:     ctxt->warning = warn;

	mov	DWORD PTR [eax+12], edx

; 21464:     ctxt->errCtxt = ctx;

	mov	DWORD PTR [eax+4], ecx

; 21465:     if (ctxt->vctxt != NULL)

	mov	eax, DWORD PTR [eax+92]
	test	eax, eax
	je	SHORT $LN25@xmlSchemaP

; 21466: 	xmlSchemaSetValidErrors(ctxt->vctxt, err, warn, ctx);

	push	ecx
	push	edx
	push	edi
	push	eax
	call	_xmlSchemaSetValidErrors
	add	esp, 16					; 00000010H
$LN25@xmlSchemaP:

; 10043: 	xmlSchemaSetParserStructuredErrors(vctxt->pctxt, vctxt->serror,

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+16]

; 21482:     if (ctxt == NULL)

	test	eax, eax
	je	SHORT $LN29@xmlSchemaP

; 21483: 	return;
; 21484:     ctxt->serror = serror;

	mov	DWORD PTR [eax+24], edx

; 21485:     ctxt->errCtxt = ctx;

	mov	DWORD PTR [eax+4], ecx

; 21486:     if (ctxt->vctxt != NULL)

	mov	eax, DWORD PTR [eax+92]
	test	eax, eax
	je	SHORT $LN29@xmlSchemaP

; 21487: 	xmlSchemaSetValidStructuredErrors(ctxt->vctxt, serror, ctx);

	push	ecx
	push	edx
	push	eax
	call	_xmlSchemaSetValidStructuredErrors
	add	esp, 12					; 0000000cH
$LN29@xmlSchemaP:

; 28128: 	/*
; 28129: 	* If not schema was given then we will create a schema
; 28130: 	* dynamically using XSI schema locations.
; 28131: 	*
; 28132: 	* Create the schema parser context.
; 28133: 	*/
; 28134: 	if ((vctxt->pctxt == NULL) &&

	mov	edi, DWORD PTR [esi+88]
$LN31@xmlSchemaP:

; 28135: 	   (xmlSchemaCreatePCtxtOnVCtxt(vctxt) == -1))
; 28136: 	   return (-1);
; 28137: 	pctxt = vctxt->pctxt;
; 28138: 	pctxt->xsiAssemble = 1;
; 28139: 	/*
; 28140: 	* Create the schema.
; 28141: 	*/
; 28142: 	vctxt->schema = xmlSchemaNewSchema(pctxt);

	push	edi
	mov	DWORD PTR [edi+104], 1
	call	_xmlSchemaNewSchema
	add	esp, 4
	mov	DWORD PTR [esi+20], eax

; 28143: 	if (vctxt->schema == NULL)

	test	eax, eax
	je	SHORT $LN33@xmlSchemaP

; 28144: 	    return (-1);
; 28145: 	/*
; 28146: 	* Create the schema construction context.
; 28147: 	*/
; 28148: 	pctxt->constructor = xmlSchemaConstructionCtxtCreate(pctxt->dict);

	push	DWORD PTR [edi+80]
	call	_xmlSchemaConstructionCtxtCreate
	add	esp, 4
	mov	DWORD PTR [edi+28], eax

; 28149: 	if (pctxt->constructor == NULL)

	test	eax, eax
	je	$LN33@xmlSchemaP

; 28151: 	pctxt->constructor->mainSchema = vctxt->schema;

	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [eax], ecx

; 28152: 	/*
; 28153: 	* Take ownership of the constructor to be able to free it.
; 28154: 	*/
; 28155: 	pctxt->ownsConstructor = 1;

	mov	DWORD PTR [edi+32], 1
	mov	eax, DWORD PTR [esi+20]
$LN2@xmlSchemaP:

; 28156:     }
; 28157:     /*
; 28158:     * Augment the IDC definitions for the main schema and all imported ones
; 28159:     * NOTE: main schema if the first in the imported list
; 28160:     */
; 28161:     xmlHashScan(vctxt->schema->schemasImports, xmlSchemaAugmentImportedIDC,

	push	esi
	push	OFFSET _xmlSchemaAugmentImportedIDC
	push	DWORD PTR [eax+48]
	call	_xmlHashScan
	add	esp, 12					; 0000000cH

; 28162:                 vctxt);
; 28163: 
; 28164:     return(0);

	xor	eax, eax
	pop	edi

; 28165: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaPreRun ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaVDocWalk
_TEXT	SEGMENT
_valRoot$1$ = -8					; size = 4
_nsName$1$ = -4						; size = 4
_msg$1 = 8						; size = 4
_ielem$1$ = 8						; size = 4
_vctxt$ = 8						; size = 4
_xmlSchemaVDocWalk PROC					; COMDAT

; 27940: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR _vctxt$[ebp]
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR [ebx+84]
	xor	ecx, ecx
	xor	edi, edi
	mov	DWORD PTR _ielem$1$[ebp], ecx
	mov	DWORD PTR _valRoot$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaV

; 27941:     xmlAttrPtr attr;
; 27942:     int ret = 0;
; 27943:     xmlSchemaNodeInfoPtr ielem = NULL;
; 27944:     xmlNodePtr node, valRoot;
; 27945:     const xmlChar *nsName;
; 27946: 
; 27947:     /* DOC VAL TODO: Move this to the start function. */
; 27948:     if (vctxt->validationRoot != NULL)
; 27949:         valRoot = vctxt->validationRoot;
; 27950:     else
; 27951: 	valRoot = xmlDocGetRootElement(vctxt->doc);

	push	DWORD PTR [ebx+24]
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _valRoot$1$[ebp], eax
	xor	ecx, ecx

; 27952:     if (valRoot == NULL) {

	test	eax, eax
	jne	SHORT $LN9@xmlSchemaV

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	ecx
	lea	eax, DWORD PTR _msg$1[ebp]
	mov	DWORD PTR _msg$1[ebp], edi
	push	ebx
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0CF@IJEICDHG@The?5document?5has?5no?5document?5el@
	push	DWORD PTR _msg$1[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	edi
	push	edi
	push	edi
	push	edi
	push	eax
	push	edi
	push	edi
	push	1
	push	2
	push	ebx

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$1[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$1[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 68					; 00000044H

; 2352 :     FREE_AND_NULL(msg)

	test	eax, eax
	je	SHORT $LN44@xmlSchemaV
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN44@xmlSchemaV:
	pop	edi

; 27953: 	/* VAL TODO: Error code? */
; 27954: 	VERROR(1, NULL, "The document has no document element");
; 27955: 	return (1);

	mov	eax, 1

; 28103: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlSchemaV:
	push	esi

; 27956:     }
; 27957:     vctxt->depth = -1;

	mov	DWORD PTR [ebx+96], -1

; 27958:     vctxt->validationRoot = valRoot;

	mov	DWORD PTR [ebx+84], eax
$LN90@xmlSchemaV:

; 27959:     node = valRoot;
; 27960:     while (node != NULL) {

	mov	esi, eax
	test	esi, esi
	je	$exit$93

; 27961: 	if ((vctxt->skipDepth != -1) && (vctxt->depth >= vctxt->skipDepth))

	mov	eax, DWORD PTR [ebx+176]
	cmp	eax, -1
	je	SHORT $LN87@xmlSchemaV
	cmp	DWORD PTR [ebx+96], eax
	jge	$next_sibling$94
$LN87@xmlSchemaV:

; 27962: 	    goto next_sibling;
; 27963: 	if (node->type == XML_ELEMENT_NODE) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	jne	$LN11@xmlSchemaV

; 27964: 
; 27965: 	    /*
; 27966: 	    * Init the node-info.
; 27967: 	    */
; 27968: 	    vctxt->depth++;

	inc	DWORD PTR [ebx+96]

; 26020:     vctxt->inode = xmlSchemaGetFreshElemInfo(vctxt);

	push	ebx
	call	_xmlSchemaGetFreshElemInfo
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _ielem$1$[ebp], ecx
	mov	DWORD PTR [ebx+108], ecx

; 26021:     if (vctxt->inode == NULL) {

	test	ecx, ecx
	je	$LN85@xmlSchemaV

; 26022: 	VERROR_INT("xmlSchemaValidatorPushElem",
; 26023: 	    "calling xmlSchemaGetFreshElemInfo()");
; 26024: 	return (-1);
; 26025:     }
; 26026:     vctxt->nbAttrInfos = 0;

	mov	DWORD PTR [ebx+168], 0

; 27971: 	    ielem = vctxt->inode;
; 27972: 	    ielem->node = node;

	mov	DWORD PTR [ecx+4], esi

; 27973: 	    ielem->nodeLine = node->line;

	movzx	eax, WORD PTR [esi+56]
	mov	DWORD PTR [ecx+8], eax

; 27974: 	    ielem->localName = node->name;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+12], eax

; 27975: 	    if (node->ns != NULL)

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN14@xmlSchemaV

; 27976: 		ielem->nsName = node->ns->href;

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+16], eax
$LN14@xmlSchemaV:

; 27977: 	    ielem->flags |= XML_SCHEMA_ELEM_INFO_EMPTY;

	or	DWORD PTR [ecx+32], 32			; 00000020H

; 27978: 	    /*
; 27979: 	    * Register attributes.
; 27980: 	    * DOC VAL TODO: We do not register namespace declaration
; 27981: 	    * attributes yet.
; 27982: 	    */
; 27983: 	    vctxt->nbAttrInfos = 0;

	mov	DWORD PTR [ebx+168], 0

; 27984: 	    if (node->properties != NULL) {

	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $LN5@xmlSchemaV
$LL6@xmlSchemaV:

; 27985: 		attr = node->properties;
; 27986: 		do {
; 27987: 		    if (attr->ns != NULL)

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN16@xmlSchemaV

; 27988: 			nsName = attr->ns->href;

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _nsName$1$[ebp], eax
	jmp	SHORT $LN17@xmlSchemaV
$LN16@xmlSchemaV:

; 27989: 		    else
; 27990: 			nsName = NULL;

	mov	DWORD PTR _nsName$1$[ebp], 0
$LN17@xmlSchemaV:

; 27991: 		    ret = xmlSchemaValidatorPushAttribute(vctxt,

	push	1
	push	1
	push	DWORD PTR [edi+12]
	push	DWORD PTR [edi+32]
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	push	eax
	mov	eax, DWORD PTR _ielem$1$[ebp]
	push	0
	push	DWORD PTR _nsName$1$[ebp]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [eax+8]
	push	edi
	push	ebx
	call	_xmlSchemaValidatorPushAttribute
	add	esp, 32					; 00000020H

; 27992: 			(xmlNodePtr) attr,
; 27993: 			/*
; 27994: 			* Note that we give it the line number of the
; 27995: 			* parent element.
; 27996: 			*/
; 27997: 			ielem->nodeLine,
; 27998: 			attr->name, nsName, 0,
; 27999: 			xmlNodeListGetString(attr->doc, attr->children, 1), 1);
; 28000: 		    if (ret == -1) {

	cmp	eax, -1
	je	$LN69@xmlSchemaV

; 28004: 		    }
; 28005: 		    attr = attr->next;

	mov	edi, DWORD PTR [edi+24]

; 28006: 		} while (attr);

	test	edi, edi
	jne	SHORT $LL6@xmlSchemaV
$LN5@xmlSchemaV:

; 28007: 	    }
; 28008: 	    /*
; 28009: 	    * Validate the element.
; 28010: 	    */
; 28011: 	    ret = xmlSchemaValidateElem(vctxt);

	push	ebx
	call	_xmlSchemaValidateElem
	mov	edi, eax
	add	esp, 4

; 28012: 	    if (ret != 0) {

	test	edi, edi
	je	SHORT $LN19@xmlSchemaV

; 28013: 		if (ret == -1) {

	cmp	edi, -1
	je	$LN75@xmlSchemaV
$leave_node$95:

; 28066: 	    node = node->children;
; 28067: 	    continue;
; 28068: 	}
; 28069: leave_node:
; 28070: 	if (node->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $next_sibling$94

; 28071: 	    /*
; 28072: 	    * Leaving the scope of an element.
; 28073: 	    */
; 28074: 	    if (node != vctxt->inode->node) {

	mov	eax, DWORD PTR [ebx+108]
	cmp	esi, DWORD PTR [eax+4]
	jne	$LN70@xmlSchemaV

; 28078: 	    }
; 28079: 	    ret = xmlSchemaValidatorPopElem(vctxt);

	push	ebx
	call	_xmlSchemaValidatorPopElem
	mov	edi, eax
	add	esp, 4

; 28080: 	    if (ret != 0) {

	test	edi, edi
	je	SHORT $LN34@xmlSchemaV

; 28081: 		if (ret < 0) {

	js	$LN71@xmlSchemaV
$LN34@xmlSchemaV:

; 28082: 		    VERROR_INT("xmlSchemaVDocWalk",
; 28083: 			"calling xmlSchemaValidatorPopElem()");
; 28084: 		    goto internal_error;
; 28085: 		}
; 28086: 	    }
; 28087: 	    if (node == valRoot)

	cmp	esi, DWORD PTR _valRoot$1$[ebp]
	je	$exit$93
$next_sibling$94:

; 28088: 		goto exit;
; 28089: 	}
; 28090: next_sibling:
; 28091: 	if (node->next != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LN73@xmlSchemaV

; 28092: 	    node = node->next;
; 28093: 	else {
; 28094: 	    node = node->parent;

	mov	esi, DWORD PTR [esi+20]

; 28095: 	    goto leave_node;

	jmp	SHORT $leave_node$95
$LN19@xmlSchemaV:

; 28017: 		}
; 28018: 		/*
; 28019: 		* Don't stop validation; just skip the content
; 28020: 		* of this element.
; 28021: 		*/
; 28022: 		goto leave_node;
; 28023: 	    }
; 28024: 	    if ((vctxt->skipDepth != -1) &&

	mov	eax, DWORD PTR [ebx+176]
	cmp	eax, -1
	je	SHORT $LN26@xmlSchemaV
	cmp	DWORD PTR [ebx+96], eax
	jge	SHORT $leave_node$95
	jmp	SHORT $LN26@xmlSchemaV
$LN11@xmlSchemaV:

; 28025: 		(vctxt->depth >= vctxt->skipDepth))
; 28026: 		goto leave_node;
; 28027: 	} else if ((node->type == XML_TEXT_NODE) ||

	cmp	eax, 3
	je	SHORT $LN24@xmlSchemaV
	cmp	eax, 4
	je	SHORT $LN24@xmlSchemaV

; 28037: 		VERROR_INT("xmlSchemaVDocWalk",
; 28038: 		    "calling xmlSchemaVPushText()");
; 28039: 		goto internal_error;
; 28040: 	    }
; 28041: 	    /*
; 28042: 	    * DOC VAL TODO: Should we skip further validation of the
; 28043: 	    * element content here?
; 28044: 	    */
; 28045: 	} else if ((node->type == XML_ENTITY_NODE) ||

	cmp	eax, 6
	je	SHORT $LN76@xmlSchemaV
	cmp	eax, 5
	jne	SHORT $leave_node$95
$LN76@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	mov	ecx, OFFSET ??_C@_0MP@HCAOIGI@there?5is?5at?5least?5one?5entity?5re@

; 28046: 	    (node->type == XML_ENTITY_REF_NODE)) {
; 28047: 	    /*
; 28048: 	    * DOC VAL TODO: What to do with entities?
; 28049: 	    */
; 28050: 	    VERROR_INT("xmlSchemaVDocWalk",
; 28051: 		"there is at least one entity reference in the node-tree "
; 28052: 		"currently being validated. Processing of entities with "
; 28053: 		"this XML Schema processor is not supported (yet). Please "
; 28054: 		"substitute entities before validation.");
; 28055: 	    goto internal_error;

	jmp	SHORT $LN91@xmlSchemaV
$LN24@xmlSchemaV:

; 28028: 	    (node->type == XML_CDATA_SECTION_NODE)) {
; 28029: 	    /*
; 28030: 	    * Process character content.
; 28031: 	    */
; 28032: 	    if ((ielem != NULL) && (ielem->flags & XML_SCHEMA_ELEM_INFO_EMPTY))

	test	ecx, ecx
	je	SHORT $LN25@xmlSchemaV
	mov	edx, DWORD PTR [ecx+32]
	test	dl, 32					; 00000020H
	je	SHORT $LN25@xmlSchemaV

; 28033: 		ielem->flags ^= XML_SCHEMA_ELEM_INFO_EMPTY;

	xor	edx, 32					; 00000020H
	mov	DWORD PTR [ecx+32], edx
	mov	eax, DWORD PTR [esi+4]
$LN25@xmlSchemaV:

; 28034: 	    ret = xmlSchemaVPushText(vctxt, node->type, node->content,

	push	0
	push	1
	push	-1
	push	DWORD PTR [esi+40]
	push	eax
	push	ebx
	call	_xmlSchemaVPushText
	mov	edi, eax
	add	esp, 24					; 00000018H

; 28035: 		-1, XML_SCHEMA_PUSH_TEXT_PERSIST, NULL);
; 28036: 	    if (ret < 0) {

	test	edi, edi
	js	SHORT $LN77@xmlSchemaV
$LN26@xmlSchemaV:

; 28056: 	} else {
; 28057: 	    goto leave_node;
; 28058: 	    /*
; 28059: 	    * DOC VAL TODO: XInclude nodes, etc.
; 28060: 	    */
; 28061: 	}
; 28062: 	/*
; 28063: 	* Walk the doc.
; 28064: 	*/
; 28065: 	if (node->children != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	$leave_node$95
$LN73@xmlSchemaV:

; 27959:     node = valRoot;
; 27960:     while (node != NULL) {

	mov	ecx, DWORD PTR _ielem$1$[ebp]
	jmp	$LN90@xmlSchemaV
$LN69@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	mov	eax, OFFSET ??_C@_0BB@JLNPEAHB@xmlSchemaDocWalk@
	mov	ecx, OFFSET ??_C@_0CK@JPNOGHKO@calling?5xmlSchemaValidatorPushA@

; 28001: 			VERROR_INT("xmlSchemaDocWalk",
; 28002: 			    "calling xmlSchemaValidatorPushAttribute()");
; 28003: 			goto internal_error;

	jmp	SHORT $internal_error$96
$LN75@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	mov	eax, OFFSET ??_C@_0BB@JLNPEAHB@xmlSchemaDocWalk@
	mov	ecx, OFFSET ??_C@_0CA@HCDKBLLH@calling?5xmlSchemaValidateElem?$CI?$CJ@

; 28014: 		    VERROR_INT("xmlSchemaDocWalk",
; 28015: 			"calling xmlSchemaValidateElem()");
; 28016: 		    goto internal_error;

	jmp	SHORT $internal_error$96
$LN85@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	mov	eax, OFFSET ??_C@_0BL@GMHMOLCB@xmlSchemaValidatorPushElem@
	mov	ecx, OFFSET ??_C@_0CE@ILDABLF@calling?5xmlSchemaGetFreshElemIn@

; 27969: 	    if (xmlSchemaValidatorPushElem(vctxt) == -1)
; 27970: 		goto internal_error;

	jmp	SHORT $internal_error$96
$LN71@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	mov	ecx, OFFSET ??_C@_0CE@LPDPGHFN@calling?5xmlSchemaValidatorPopEl@
	jmp	SHORT $LN91@xmlSchemaV
$LN70@xmlSchemaV:
	mov	ecx, OFFSET ??_C@_0BK@MHAMFOBD@element?5position?5mismatch@

; 28075: 		VERROR_INT("xmlSchemaVDocWalk",
; 28076: 		    "element position mismatch");
; 28077: 		goto internal_error;

	jmp	SHORT $LN91@xmlSchemaV
$LN77@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	mov	ecx, OFFSET ??_C@_0BN@NAKBGNNM@calling?5xmlSchemaVPushText?$CI?$CJ@
$LN91@xmlSchemaV:

; 28101: internal_error:
; 28102:     return (-1);

	mov	eax, OFFSET ??_C@_0BC@GLFJEMA@xmlSchemaVDocWalk@
$internal_error$96:
	push	0
	push	0
	push	ecx
	push	eax
	push	ebx
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
	or	eax, -1
	pop	esi
	pop	edi

; 28103: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$exit$93:
	pop	esi

; 28096: 	}
; 28097:     }
; 28098: 
; 28099: exit:
; 28100:     return (ret);

	mov	eax, edi
	pop	edi

; 28103: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaVDocWalk ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSAXHandleEndElementNs
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_localname$ = 12					; size = 4
_prefix$ = 16						; size = 4
_URI$ = 20						; size = 4
_xmlSchemaSAXHandleEndElementNs PROC			; COMDAT

; 27497: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [esi+176]
	cmp	eax, -1
	je	SHORT $LN4@xmlSchemaS

; 27498:     xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) ctx;
; 27499:     int res;
; 27500: 
; 27501:     /*
; 27502:     * Skip elements if inside a "skip" wildcard or if invalid.
; 27503:     */
; 27504:     if (vctxt->skipDepth != -1) {
; 27505: 	if (vctxt->depth > vctxt->skipDepth) {

	mov	ecx, DWORD PTR [esi+96]
	cmp	ecx, eax
	jle	SHORT $LN3@xmlSchemaS

; 27506: 	    vctxt->depth--;

	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR [esi+96], eax
	pop	esi

; 27533:     return;
; 27534: }

	pop	ebp
	ret	0
$LN3@xmlSchemaS:

; 27507: 	    return;
; 27508: 	} else
; 27509: 	    vctxt->skipDepth = -1;

	mov	DWORD PTR [esi+176], -1
$LN4@xmlSchemaS:

; 27510:     }
; 27511:     /*
; 27512:     * SAX VAL TODO: Just a temporary check.
; 27513:     */
; 27514:     if ((!xmlStrEqual(vctxt->inode->localName, localname)) ||

	mov	eax, DWORD PTR [esi+108]
	push	DWORD PTR _localname$[ebp]
	push	DWORD PTR [eax+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlSchemaS
	mov	eax, DWORD PTR [esi+108]
	push	DWORD PTR _URI$[ebp]
	push	DWORD PTR [eax+16]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@xmlSchemaS
$LN6@xmlSchemaS:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BC@LAPBJBJD@elem?5pop?5mismatch@
	push	OFFSET ??_C@_0BP@IODONKBL@xmlSchemaSAXHandleEndElementNs@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$LN10@xmlSchemaS:

; 27515: 	(!xmlStrEqual(vctxt->inode->nsName, URI))) {
; 27516: 	VERROR_INT("xmlSchemaSAXHandleEndElementNs",
; 27517: 	    "elem pop mismatch");
; 27518:     }
; 27519:     res = xmlSchemaValidatorPopElem(vctxt);

	push	esi
	call	_xmlSchemaValidatorPopElem
	add	esp, 4

; 27520:     if (res != 0) {

	test	eax, eax
	je	SHORT $exit$15

; 27521: 	if (res < 0) {

	jns	SHORT $exit$15

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CE@LPDPGHFN@calling?5xmlSchemaValidatorPopEl@
	push	OFFSET ??_C@_0BP@IODONKBL@xmlSchemaSAXHandleEndElementNs@
	push	esi
	call	_xmlSchemaInternalErr2
$internal_error$16:

; 27522: 	    VERROR_INT("xmlSchemaSAXHandleEndElementNs",
; 27523: 		"calling xmlSchemaValidatorPopElem()");
; 27524: 	    goto internal_error;
; 27525: 	}
; 27526: 	goto exit;
; 27527:     }
; 27528: exit:
; 27529:     return;
; 27530: internal_error:
; 27531:     vctxt->err = -1;
; 27532:     xmlStopParser(vctxt->parserCtxt);

	push	DWORD PTR [esi+40]
	mov	DWORD PTR [esi+52], -1
	call	_xmlStopParser
	add	esp, 24					; 00000018H
$exit$15:
	pop	esi

; 27533:     return;
; 27534: }

	pop	ebp
	ret	0
_xmlSchemaSAXHandleEndElementNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSAXHandleStartElementNs
_TEXT	SEGMENT
_ielem$1$ = -20						; size = 4
_i$2$ = -16						; size = 4
_value$1$ = -12						; size = 4
_l$1$ = -8						; size = 4
_i$1$ = -8						; size = 4
tv1070 = -4						; size = 4
_valueLen$1$ = -4					; size = 4
_ctx$ = 8						; size = 4
_localname$ = 12					; size = 4
_prefix$ = 16						; size = 4
_URI$ = 20						; size = 4
_nb_namespaces$ = 24					; size = 4
_namespaces$ = 28					; size = 4
_nb_attributes$ = 32					; size = 4
_nb_defaulted$ = 36					; size = 4
_attributes$ = 40					; size = 4
_xmlSchemaSAXHandleStartElementNs PROC			; COMDAT

; 27336: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	ebx
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [ebx+96]
	mov	ecx, DWORD PTR [ebx+176]
	inc	eax
	mov	DWORD PTR [ebx+96], eax
	cmp	ecx, -1
	je	SHORT $LN11@xmlSchemaS

; 27337:     xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) ctx;
; 27338:     int ret;
; 27339:     xmlSchemaNodeInfoPtr ielem;
; 27340:     int i, j;
; 27341: 
; 27342:     /*
; 27343:     * SAX VAL TODO: What to do with nb_defaulted?
; 27344:     */
; 27345:     /*
; 27346:     * Skip elements if inside a "skip" wildcard or invalid.
; 27347:     */
; 27348:     vctxt->depth++;
; 27349:     if ((vctxt->skipDepth != -1) && (vctxt->depth >= vctxt->skipDepth))

	cmp	eax, ecx
	jge	$exit$72
$LN11@xmlSchemaS:
	push	esi
	push	edi

; 26020:     vctxt->inode = xmlSchemaGetFreshElemInfo(vctxt);

	push	ebx
	call	_xmlSchemaGetFreshElemInfo
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _ielem$1$[ebp], edi
	mov	DWORD PTR [ebx+108], edi

; 26021:     if (vctxt->inode == NULL) {

	test	edi, edi
	jne	SHORT $LN30@xmlSchemaS

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	eax
	push	eax
	push	OFFSET ??_C@_0CE@ILDABLF@calling?5xmlSchemaGetFreshElemIn@
	push	OFFSET ??_C@_0BL@GMHMOLCB@xmlSchemaValidatorPushElem@
	push	ebx
	call	_xmlSchemaInternalErr2
	push	edi
	push	edi
	push	OFFSET ??_C@_0CF@NKADHDNI@calling?5xmlSchemaValidatorPushE@
	push	OFFSET ??_C@_0CB@PHMCNLEA@xmlSchemaSAXHandleStartElementN@
	push	ebx
	call	_xmlSchemaInternalErr2
	add	esp, 40					; 00000028H

; 27350: 	return;
; 27351:     /*
; 27352:     * Push the element.
; 27353:     */
; 27354:     if (xmlSchemaValidatorPushElem(vctxt) == -1) {
; 27355: 	VERROR_INT("xmlSchemaSAXHandleStartElementNs",
; 27356: 	    "calling xmlSchemaValidatorPushElem()");
; 27357: 	goto internal_error;

	jmp	$internal_error$73
$LN30@xmlSchemaS:

; 27358:     }
; 27359:     ielem = vctxt->inode;
; 27360:     /*
; 27361:     * TODO: Is this OK?
; 27362:     */
; 27363:     ielem->nodeLine = xmlSAX2GetLineNumber(vctxt->parserCtxt);

	push	DWORD PTR [ebx+40]

; 26026:     vctxt->nbAttrInfos = 0;

	mov	DWORD PTR [ebx+168], 0

; 27358:     }
; 27359:     ielem = vctxt->inode;
; 27360:     /*
; 27361:     * TODO: Is this OK?
; 27362:     */
; 27363:     ielem->nodeLine = xmlSAX2GetLineNumber(vctxt->parserCtxt);

	call	_xmlSAX2GetLineNumber

; 27364:     ielem->localName = localname;
; 27365:     ielem->nsName = URI;
; 27366:     ielem->flags |= XML_SCHEMA_ELEM_INFO_EMPTY;

	or	DWORD PTR [edi+32], 32			; 00000020H
	add	esp, 4
	mov	DWORD PTR [edi+8], eax
	mov	eax, DWORD PTR _localname$[ebp]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR _URI$[ebp]
	mov	DWORD PTR [edi+16], eax

; 27367:     /*
; 27368:     * Register namespaces on the elem info.
; 27369:     */
; 27370:     if (nb_namespaces != 0) {

	mov	eax, DWORD PTR _nb_namespaces$[ebp]
	test	eax, eax
	je	$LN66@xmlSchemaS

; 27371: 	/*
; 27372: 	* Although the parser builds its own namespace list,
; 27373: 	* we have no access to it, so we'll use an own one.
; 27374: 	*/
; 27375:         for (i = 0, j = 0; i < nb_namespaces; i++, j += 2) {

	mov	DWORD PTR _i$1$[ebp], 0
	jle	$LN66@xmlSchemaS
	mov	eax, DWORD PTR _namespaces$[ebp]
	mov	DWORD PTR tv1070[ebp], eax
$LL4@xmlSchemaS:

; 27376: 	    /*
; 27377: 	    * Store prefix and namespace name.
; 27378: 	    */
; 27379: 	    if (ielem->nsBindings == NULL) {

	mov	edx, DWORD PTR [edi+64]
	test	edx, edx
	jne	SHORT $LN14@xmlSchemaS

; 27380: 		ielem->nsBindings =

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR [edi+64], edx

; 27381: 		    (const xmlChar **) xmlMalloc(10 *
; 27382: 			sizeof(const xmlChar *));
; 27383: 		if (ielem->nsBindings == NULL) {

	test	edx, edx
	je	$LN52@xmlSchemaS

; 27388: 		}
; 27389: 		ielem->nbNsBindings = 0;

	mov	DWORD PTR [edi+68], 0

; 27390: 		ielem->sizeNsBindings = 5;

	mov	DWORD PTR [edi+72], 5
	jmp	SHORT $LN18@xmlSchemaS
$LN14@xmlSchemaS:

; 27391: 	    } else if (ielem->sizeNsBindings <= ielem->nbNsBindings) {

	mov	eax, DWORD PTR [edi+72]
	cmp	eax, DWORD PTR [edi+68]
	jg	SHORT $LN18@xmlSchemaS

; 27392: 		ielem->sizeNsBindings *= 2;

	add	eax, eax
	mov	DWORD PTR [edi+72], eax

; 27393: 		ielem->nsBindings =

	shl	eax, 3
	push	eax
	push	edx
	call	DWORD PTR _xmlRealloc
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR [edi+64], edx

; 27394: 		    (const xmlChar **) xmlRealloc(
; 27395: 			(void *) ielem->nsBindings,
; 27396: 			ielem->sizeNsBindings * 2 * sizeof(const xmlChar *));
; 27397: 		if (ielem->nsBindings == NULL) {

	test	edx, edx
	je	$LN53@xmlSchemaS
$LN18@xmlSchemaS:

; 27402: 		}
; 27403: 	    }
; 27404: 
; 27405: 	    ielem->nsBindings[ielem->nbNsBindings * 2] = namespaces[j];

	mov	ecx, DWORD PTR [edi+68]
	mov	eax, DWORD PTR tv1070[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+ecx*8], eax

; 27406: 	    if (namespaces[j+1][0] == 0) {
; 27407: 		/*
; 27408: 		* Handle xmlns="".
; 27409: 		*/
; 27410: 		ielem->nsBindings[ielem->nbNsBindings * 2 + 1] = NULL;
; 27411: 	    } else
; 27412: 		ielem->nsBindings[ielem->nbNsBindings * 2 + 1] =
; 27413: 		    namespaces[j+1];
; 27414: 	    ielem->nbNsBindings++;

	xor	edx, edx
	mov	eax, DWORD PTR tv1070[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edi+64]
	cmp	BYTE PTR [ecx], dl
	cmovne	edx, ecx
	mov	ecx, DWORD PTR [edi+68]
	add	DWORD PTR tv1070[ebp], 8
	mov	DWORD PTR [eax+ecx*8+4], edx
	mov	ecx, DWORD PTR _i$1$[ebp]
	inc	DWORD PTR [edi+68]
	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	ecx, DWORD PTR _nb_namespaces$[ebp]
	jl	$LL4@xmlSchemaS
$LN66@xmlSchemaS:

; 27415: 	}
; 27416:     }
; 27417:     /*
; 27418:     * Register attributes.
; 27419:     * SAX VAL TODO: We are not adding namespace declaration
; 27420:     * attributes yet.
; 27421:     */
; 27422:     if (nb_attributes != 0) {

	mov	eax, DWORD PTR _nb_attributes$[ebp]
	test	eax, eax
	je	$LN6@xmlSchemaS

; 27423: 	int valueLen, k, l;
; 27424: 	xmlChar *value;
; 27425: 
; 27426:         for (j = 0, i = 0; i < nb_attributes; i++, j += 5) {

	mov	DWORD PTR _i$2$[ebp], 0
	jle	$LN6@xmlSchemaS
	mov	esi, DWORD PTR _attributes$[ebp]
	add	esi, 12					; 0000000cH
$LL7@xmlSchemaS:

; 27427: 	    /*
; 27428: 	    * Duplicate the value, changing any &#38; to a literal ampersand.
; 27429: 	    *
; 27430: 	    * libxml2 differs from normal SAX here in that it escapes all ampersands
; 27431: 	    * as &#38; instead of delivering the raw converted string. Changing the
; 27432: 	    * behavior at this point would break applications that use this API, so
; 27433: 	    * we are forced to work around it.
; 27434: 	    */
; 27435: 	    valueLen = attributes[j+4] - attributes[j+3];

	mov	eax, DWORD PTR [esi+4]
	sub	eax, DWORD PTR [esi]
	mov	DWORD PTR _valueLen$1$[ebp], eax

; 27436: 	    value = xmlMallocAtomic(valueLen + 1);

	inc	eax
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR _value$1$[ebp], eax

; 27437: 	    if (value == NULL) {

	test	eax, eax
	je	$LN54@xmlSchemaS

; 27442: 	    }
; 27443: 	    for (k = 0, l = 0; k < valueLen; l++) {

	mov	eax, DWORD PTR _valueLen$1$[ebp]
	xor	edx, edx
	xor	ecx, ecx
	mov	DWORD PTR _l$1$[ebp], edx
	test	eax, eax
	jle	$LN9@xmlSchemaS
	mov	ebx, DWORD PTR _value$1$[ebp]
	lea	edi, DWORD PTR [eax-4]
	npad	5
$LL10@xmlSchemaS:

; 27444: 		if (k < valueLen - 4 &&
; 27445: 		    attributes[j+3][k+0] == '&' &&
; 27446: 		    attributes[j+3][k+1] == '#' &&
; 27447: 		    attributes[j+3][k+2] == '3' &&
; 27448: 		    attributes[j+3][k+3] == '8' &&

	cmp	ecx, edi
	jge	SHORT $LN23@xmlSchemaS
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [ecx+eax], 38			; 00000026H
	jne	SHORT $LN23@xmlSchemaS
	cmp	BYTE PTR [ecx+eax+1], 35		; 00000023H
	jne	SHORT $LN23@xmlSchemaS
	cmp	BYTE PTR [ecx+eax+2], 51		; 00000033H
	jne	SHORT $LN23@xmlSchemaS
	cmp	BYTE PTR [ecx+eax+3], 56		; 00000038H
	jne	SHORT $LN23@xmlSchemaS
	cmp	BYTE PTR [ecx+eax+4], 59		; 0000003bH
	jne	SHORT $LN23@xmlSchemaS

; 27449: 		    attributes[j+3][k+4] == ';') {
; 27450: 		    value[l] = '&';
; 27451: 		    k += 5;

	mov	al, 38					; 00000026H
	mov	edx, 5

; 27452: 		} else {

	jmp	SHORT $LN8@xmlSchemaS
$LN52@xmlSchemaS:

; 2007 :         ctxt->nberrors++;

	inc	DWORD PTR [ebx+56]

; 2008 :         ctxt->err = XML_SCHEMAV_INTERNAL;
; 2009 :     }
; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0DB@LKIJJHFH@allocating?5namespace?5bindings?5f@
	push	0
	push	0
	push	2
	push	17					; 00000011H
	mov	DWORD PTR [ebx+52], 1818		; 0000071aH
	call	___xmlSimpleError

; 27384: 		    xmlSchemaVErrMemory(vctxt,
; 27385: 			"allocating namespace bindings for SAX validation",
; 27386: 			NULL);
; 27387: 		    goto internal_error;

	jmp	$LN69@xmlSchemaS
$LN53@xmlSchemaS:

; 2007 :         ctxt->nberrors++;

	inc	DWORD PTR [ebx+56]

; 2008 :         ctxt->err = XML_SCHEMAV_INTERNAL;
; 2009 :     }
; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0DE@FHEEIBOG@re?9allocating?5namespace?5binding@
	push	0
	push	0
	push	2
	push	17					; 00000011H
	mov	DWORD PTR [ebx+52], 1818		; 0000071aH
	call	___xmlSimpleError

; 27398: 		    xmlSchemaVErrMemory(vctxt,
; 27399: 			"re-allocating namespace bindings for SAX validation",
; 27400: 			NULL);
; 27401: 		    goto internal_error;

	jmp	$LN69@xmlSchemaS
$LN23@xmlSchemaS:

; 27453: 		    value[l] = attributes[j+3][k];
; 27454: 		    k++;

	mov	eax, DWORD PTR [esi]
	mov	edx, 1
	mov	al, BYTE PTR [ecx+eax]
$LN8@xmlSchemaS:

; 27442: 	    }
; 27443: 	    for (k = 0, l = 0; k < valueLen; l++) {

	add	ecx, edx
	mov	edx, DWORD PTR _l$1$[ebp]
	mov	BYTE PTR [ebx+edx], al
	inc	edx
	mov	DWORD PTR _l$1$[ebp], edx
	cmp	ecx, DWORD PTR _valueLen$1$[ebp]
	jl	$LL10@xmlSchemaS
	mov	edi, DWORD PTR _ielem$1$[ebp]
	mov	ebx, DWORD PTR _ctx$[ebp]
$LN9@xmlSchemaS:

; 27455: 		}
; 27456: 	    }
; 27457: 	    value[l] = '\0';

	mov	eax, DWORD PTR _value$1$[ebp]

; 27458: 	    /*
; 27459: 	    * TODO: Set the node line.
; 27460: 	    */
; 27461: 	    ret = xmlSchemaValidatorPushAttribute(vctxt,

	push	1
	push	eax
	push	0
	mov	BYTE PTR [edx+eax], 0
	push	DWORD PTR [esi-4]
	push	DWORD PTR [esi-12]
	push	DWORD PTR [edi+8]
	push	0
	push	ebx
	call	_xmlSchemaValidatorPushAttribute
	add	esp, 32					; 00000020H

; 27462: 		NULL, ielem->nodeLine, attributes[j], attributes[j+2], 0,
; 27463: 		value, 1);
; 27464: 	    if (ret == -1) {

	cmp	eax, -1
	je	SHORT $LN55@xmlSchemaS

; 27423: 	int valueLen, k, l;
; 27424: 	xmlChar *value;
; 27425: 
; 27426:         for (j = 0, i = 0; i < nb_attributes; i++, j += 5) {

	mov	eax, DWORD PTR _i$2$[ebp]
	add	esi, 20					; 00000014H
	inc	eax
	mov	DWORD PTR _i$2$[ebp], eax
	cmp	eax, DWORD PTR _nb_attributes$[ebp]
	jl	$LL7@xmlSchemaS
$LN6@xmlSchemaS:

; 27468: 	    }
; 27469: 	}
; 27470:     }
; 27471:     /*
; 27472:     * Validate the element.
; 27473:     */
; 27474:     ret = xmlSchemaValidateElem(vctxt);

	push	ebx
	call	_xmlSchemaValidateElem
	add	esp, 4

; 27475:     if (ret != 0) {

	test	eax, eax
	je	SHORT $LN67@xmlSchemaS

; 27476: 	if (ret == -1) {

	cmp	eax, -1
	jne	SHORT $LN67@xmlSchemaS

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CA@HCDKBLLH@calling?5xmlSchemaValidateElem?$CI?$CJ@
$LN70@xmlSchemaS:

; 27477: 	    VERROR_INT("xmlSchemaSAXHandleStartElementNs",
; 27478: 		"calling xmlSchemaValidateElem()");
; 27479: 	    goto internal_error;
; 27480: 	}
; 27481: 	goto exit;
; 27482:     }
; 27483: 
; 27484: exit:
; 27485:     return;
; 27486: internal_error:
; 27487:     vctxt->err = -1;

	push	OFFSET ??_C@_0CB@PHMCNLEA@xmlSchemaSAXHandleStartElementN@
	push	ebx
	call	_xmlSchemaInternalErr2
$LN69@xmlSchemaS:
	add	esp, 20					; 00000014H
$internal_error$73:

; 27488:     xmlStopParser(vctxt->parserCtxt);

	push	DWORD PTR [ebx+40]
	mov	DWORD PTR [ebx+52], -1
	call	_xmlStopParser
	add	esp, 4
$LN67@xmlSchemaS:
	pop	edi
	pop	esi
$exit$72:
	pop	ebx

; 27489:     return;
; 27490: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN55@xmlSchemaS:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CK@JPNOGHKO@calling?5xmlSchemaValidatorPushA@

; 27465: 		VERROR_INT("xmlSchemaSAXHandleStartElementNs",
; 27466: 		    "calling xmlSchemaValidatorPushAttribute()");
; 27467: 		goto internal_error;

	jmp	SHORT $LN70@xmlSchemaS
$LN54@xmlSchemaS:

; 2007 :         ctxt->nberrors++;

	inc	DWORD PTR [ebx+56]

; 2008 :         ctxt->err = XML_SCHEMAV_INTERNAL;
; 2009 :     }
; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CI@BHABMMOD@allocating?5string?5for?5decoded?5a@
	push	0
	push	0
	push	2
	push	17					; 00000011H
	mov	DWORD PTR [ebx+52], 1818		; 0000071aH
	call	___xmlSimpleError

; 27438: 		xmlSchemaVErrMemory(vctxt,
; 27439: 		    "allocating string for decoded attribute",
; 27440: 		    NULL);
; 27441: 		goto internal_error;

	jmp	SHORT $LN69@xmlSchemaS
_xmlSchemaSAXHandleStartElementNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSAXHandleReference
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlSchemaSAXHandleReference PROC			; COMDAT

; 27315: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	test	ecx, ecx
	js	SHORT $LN1@xmlSchemaS

; 27316:     xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) ctx;
; 27317: 
; 27318:     if (vctxt->depth < 0)
; 27319: 	return;
; 27320:     if ((vctxt->skipDepth != -1) && (vctxt->depth >= vctxt->skipDepth))

	mov	eax, DWORD PTR [eax+176]
	cmp	eax, -1
	je	SHORT $LN3@xmlSchemaS
	cmp	ecx, eax
	jge	SHORT $LN1@xmlSchemaS
$LN3@xmlSchemaS:
	push	esi

; 27321: 	return;
; 27322:     /* SAX VAL TODO: What to do here? */
; 27323:     TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	27323					; 00006abbH
	push	OFFSET ??_C@_0GM@IJCDLDON@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	pop	esi
$LN1@xmlSchemaS:

; 27324: }

	pop	ebp
	ret	0
_xmlSchemaSAXHandleReference ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSAXHandleCDataSection
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_ch$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlSchemaSAXHandleCDataSection PROC			; COMDAT

; 27294: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR [esi+96]
	test	ecx, ecx
	js	SHORT $LN5@xmlSchemaS

; 27295:     xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) ctx;
; 27296: 
; 27297:     if (vctxt->depth < 0)
; 27298: 	return;
; 27299:     if ((vctxt->skipDepth != -1) && (vctxt->depth >= vctxt->skipDepth))

	mov	eax, DWORD PTR [esi+176]
	cmp	eax, -1
	je	SHORT $LN3@xmlSchemaS
	cmp	ecx, eax
	jge	SHORT $LN5@xmlSchemaS
$LN3@xmlSchemaS:

; 27300: 	return;
; 27301:     if (vctxt->inode->flags & XML_SCHEMA_ELEM_INFO_EMPTY)

	mov	ecx, DWORD PTR [esi+108]
	mov	eax, DWORD PTR [ecx+32]
	test	al, 32					; 00000020H
	je	SHORT $LN4@xmlSchemaS

; 27302: 	vctxt->inode->flags ^= XML_SCHEMA_ELEM_INFO_EMPTY;

	xor	eax, 32					; 00000020H
	mov	DWORD PTR [ecx+32], eax
$LN4@xmlSchemaS:

; 27303:     if (xmlSchemaVPushText(vctxt, XML_CDATA_SECTION_NODE, ch, len,
; 27304: 	XML_SCHEMA_PUSH_TEXT_VOLATILE, NULL) == -1) {

	push	0
	push	3
	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _ch$[ebp]
	push	4
	push	esi
	call	_xmlSchemaVPushText
	add	esp, 24					; 00000018H
	cmp	eax, -1
	jne	SHORT $LN5@xmlSchemaS

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BN@NAKBGNNM@calling?5xmlSchemaVPushText?$CI?$CJ@
	push	OFFSET ??_C@_0BP@DDCACDGG@xmlSchemaSAXHandleCDataSection@
	push	esi
	call	_xmlSchemaInternalErr2

; 27305: 	VERROR_INT("xmlSchemaSAXHandleCDataSection",
; 27306: 	    "calling xmlSchemaVPushText()");
; 27307: 	vctxt->err = -1;
; 27308: 	xmlStopParser(vctxt->parserCtxt);

	push	DWORD PTR [esi+40]
	mov	DWORD PTR [esi+52], -1
	call	_xmlStopParser
	add	esp, 24					; 00000018H
$LN5@xmlSchemaS:
	pop	esi

; 27309:     }
; 27310: }

	pop	ebp
	ret	0
_xmlSchemaSAXHandleCDataSection ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSAXHandleText
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_ch$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlSchemaSAXHandleText PROC				; COMDAT

; 27269: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR [esi+96]
	test	ecx, ecx
	js	SHORT $LN5@xmlSchemaS

; 27270:     xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) ctx;
; 27271: 
; 27272:     if (vctxt->depth < 0)
; 27273: 	return;
; 27274:     if ((vctxt->skipDepth != -1) && (vctxt->depth >= vctxt->skipDepth))

	mov	eax, DWORD PTR [esi+176]
	cmp	eax, -1
	je	SHORT $LN3@xmlSchemaS
	cmp	ecx, eax
	jge	SHORT $LN5@xmlSchemaS
$LN3@xmlSchemaS:

; 27275: 	return;
; 27276:     if (vctxt->inode->flags & XML_SCHEMA_ELEM_INFO_EMPTY)

	mov	ecx, DWORD PTR [esi+108]
	mov	eax, DWORD PTR [ecx+32]
	test	al, 32					; 00000020H
	je	SHORT $LN4@xmlSchemaS

; 27277: 	vctxt->inode->flags ^= XML_SCHEMA_ELEM_INFO_EMPTY;

	xor	eax, 32					; 00000020H
	mov	DWORD PTR [ecx+32], eax
$LN4@xmlSchemaS:

; 27278:     if (xmlSchemaVPushText(vctxt, XML_TEXT_NODE, ch, len,
; 27279: 	XML_SCHEMA_PUSH_TEXT_VOLATILE, NULL) == -1) {

	push	0
	push	3
	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _ch$[ebp]
	push	3
	push	esi
	call	_xmlSchemaVPushText
	add	esp, 24					; 00000018H
	cmp	eax, -1
	jne	SHORT $LN5@xmlSchemaS

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BN@NAKBGNNM@calling?5xmlSchemaVPushText?$CI?$CJ@
	push	OFFSET ??_C@_0BP@DDCACDGG@xmlSchemaSAXHandleCDataSection@
	push	esi
	call	_xmlSchemaInternalErr2

; 27280: 	VERROR_INT("xmlSchemaSAXHandleCDataSection",
; 27281: 	    "calling xmlSchemaVPushText()");
; 27282: 	vctxt->err = -1;
; 27283: 	xmlStopParser(vctxt->parserCtxt);

	push	DWORD PTR [esi+40]
	mov	DWORD PTR [esi+52], -1
	call	_xmlStopParser
	add	esp, 24					; 00000018H
$LN5@xmlSchemaS:
	pop	esi

; 27284:     }
; 27285: }

	pop	ebp
	ret	0
_xmlSchemaSAXHandleText ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidateElem
_TEXT	SEGMENT
_msg$1 = 8						; size = 4
_msg$2 = 8						; size = 4
_msg$3 = 8						; size = 4
_msg$4 = 8						; size = 4
_vctxt$ = 8						; size = 4
_xmlSchemaValidateElem PROC				; COMDAT

; 26876: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _vctxt$[ebp]
	xor	edi, edi
	mov	eax, DWORD PTR [esi+176]
	cmp	eax, -1
	je	SHORT $LN104@xmlSchemaV

; 26877:     int ret = 0;
; 26878: 
; 26879:     if ((vctxt->skipDepth != -1) &&

	cmp	DWORD PTR [esi+96], eax
	jl	SHORT $LN104@xmlSchemaV

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	edi
	push	edi
	push	OFFSET ??_C@_0O@BFNKDIGJ@in?5skip?9state@
	push	OFFSET ??_C@_0BG@PEPPJHKP@xmlSchemaValidateElem@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 27059: internal_error:
; 27060:     return (-1);

	or	eax, -1
	pop	edi

; 27061: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN104@xmlSchemaV:

; 26880: 	(vctxt->depth >= vctxt->skipDepth)) {
; 26881: 	VERROR_INT("xmlSchemaValidateElem",
; 26882: 	    "in skip-state");
; 26883: 	goto internal_error;
; 26884:     }
; 26885:     if (vctxt->xsiAssemble) {

	cmp	DWORD PTR [esi+92], edi
	je	SHORT $LN3@xmlSchemaV

; 26886: 	/*
; 26887: 	* We will stop validation if there was an error during
; 26888: 	* dynamic schema construction.
; 26889: 	* Note that we simply set @skipDepth to 0, this could
; 26890: 	* mean that a streaming document via SAX would be
; 26891: 	* still read to the end but it won't be validated any more.
; 26892: 	* TODO: If we are sure how to stop the validation at once
; 26893: 	*   for all input scenarios, then this should be changed to
; 26894: 	*   instantly stop the validation.
; 26895: 	*/
; 26896: 	ret = xmlSchemaAssembleByXSI(vctxt);

	push	esi
	call	_xmlSchemaAssembleByXSI
	mov	edi, eax
	add	esp, 4

; 26897: 	if (ret != 0) {

	test	edi, edi
	je	SHORT $LN4@xmlSchemaV

; 26898: 	    if (ret == -1)

	cmp	edi, -1
	je	$internal_error$114

; 26899: 		goto internal_error;
; 26900: 	    vctxt->skipDepth = 0;

	pop	edi
	mov	DWORD PTR [esi+176], 0

; 27061: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlSchemaV:

; 26901: 	    return(ret);
; 26902: 	}
; 26903:         /*
; 26904:          * Augment the IDC definitions for the main schema and all imported ones
; 26905:          * NOTE: main schema is the first in the imported list
; 26906:          */
; 26907:         xmlHashScan(vctxt->schema->schemasImports, xmlSchemaAugmentImportedIDC,

	mov	eax, DWORD PTR [esi+20]
	push	esi
	push	OFFSET _xmlSchemaAugmentImportedIDC
	push	DWORD PTR [eax+48]
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN3@xmlSchemaV:

; 26908:                     vctxt);
; 26909:     }
; 26910:     if (vctxt->depth > 0) {

	cmp	DWORD PTR [esi+96], 0
	jle	SHORT $LN6@xmlSchemaV

; 26911: 	/*
; 26912: 	* Validate this element against the content model
; 26913: 	* of the parent.
; 26914: 	*/
; 26915: 	ret = xmlSchemaValidateChildElem(vctxt);

	push	esi
	call	_xmlSchemaValidateChildElem
	mov	edi, eax
	add	esp, 4

; 26916: 	if (ret != 0) {

	test	edi, edi
	je	SHORT $LN8@xmlSchemaV

; 26917: 	    if (ret < 0) {

	jns	$exit$115

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CO@IEJMJHPB@calling?5xmlSchemaStreamValidate@
	push	OFFSET ??_C@_0BG@PEPPJHKP@xmlSchemaValidateElem@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 27059: internal_error:
; 27060:     return (-1);

	or	eax, -1
	pop	edi

; 27061: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlSchemaV:

; 26918: 		VERROR_INT("xmlSchemaValidateElem",
; 26919: 		    "calling xmlSchemaStreamValidateChildElement()");
; 26920: 		goto internal_error;
; 26921: 	    }
; 26922: 	    goto exit;
; 26923: 	}
; 26924: 	if (vctxt->depth == vctxt->skipDepth)

	mov	eax, DWORD PTR [esi+96]
	cmp	eax, DWORD PTR [esi+176]
	je	$LN33@xmlSchemaV

; 26925: 	    goto exit;
; 26926: 	if ((vctxt->inode->decl == NULL) &&

	mov	eax, DWORD PTR [esi+108]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN105@xmlSchemaV
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN105@xmlSchemaV

; 26927: 	    (vctxt->inode->typeDef == NULL)) {
; 26928: 	    VERROR_INT("xmlSchemaValidateElem",

	push	OFFSET ??_C@_0EN@IOLJEJKJ@the?5child?5element?5was?5valid?5but@

; 26929: 		"the child element was valid but neither the "
; 26930: 		"declaration nor the type was set");
; 26931: 	    goto internal_error;

	jmp	$LN107@xmlSchemaV
$LN6@xmlSchemaV:

; 26932: 	}
; 26933:     } else {
; 26934: 	/*
; 26935: 	* Get the declaration of the validation root.
; 26936: 	*/
; 26937: 	vctxt->inode->decl = xmlSchemaGetElem(vctxt->schema,

	mov	eax, DWORD PTR [esi+108]
	push	DWORD PTR [eax+16]
	push	DWORD PTR [eax+12]
	push	DWORD PTR [esi+20]
	call	_xmlSchemaGetElem
	mov	ecx, DWORD PTR [esi+108]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+44], eax

; 26938: 	    vctxt->inode->localName,
; 26939: 	    vctxt->inode->nsName);
; 26940: 	if (vctxt->inode->decl == NULL) {

	mov	eax, DWORD PTR [esi+108]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN105@xmlSchemaV

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$4[ebp]
	mov	DWORD PTR _msg$4[ebp], 0
	push	esi
	push	eax

; 26941: 	    ret = XML_SCHEMAV_CVC_ELT_1;

	mov	edi, 1845				; 00000735H

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0EB@OKNNKHOB@No?5matching?5global?5declaration?5@
	push	DWORD PTR _msg$4[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$4[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	edi

; 26942: 	    VERROR(ret, NULL,
; 26943: 		"No matching global declaration available "
; 26944: 		"for the validation root");
; 26945: 	    goto exit;

	jmp	$LN109@xmlSchemaV
$LN105@xmlSchemaV:

; 26946: 	}
; 26947:     }
; 26948: 
; 26949:     if (vctxt->inode->decl == NULL)

	mov	ebx, DWORD PTR [eax+44]
	test	ebx, ebx
	je	$type_validation$116

; 26950: 	goto type_validation;
; 26951: 
; 26952:     if (vctxt->inode->decl->type == XML_SCHEMA_TYPE_ANY) {

	cmp	DWORD PTR [ebx], 2
	jne	$LN18@xmlSchemaV

; 25858:     if (wild->processContents == XML_SCHEMAS_ANY_SKIP) {

	cmp	DWORD PTR [ebx+24], 1
	jne	SHORT $LN51@xmlSchemaV

; 26963: 	    }
; 26964: 	    goto exit;
; 26965: 	}
; 26966: 	if (skip) {
; 26967: 	    vctxt->skipDepth = vctxt->depth;

	mov	eax, DWORD PTR [esi+96]
	mov	DWORD PTR [esi+176], eax
$LN32@xmlSchemaV:

; 27058:     return (ret);

	xor	edi, edi
$LN33@xmlSchemaV:
	mov	eax, edi
	pop	edi

; 27061: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN51@xmlSchemaV:

; 25869: 	decl = xmlSchemaGetElem(vctxt->schema,

	push	DWORD PTR [eax+16]
	push	DWORD PTR [eax+12]
	push	DWORD PTR [esi+20]
	call	_xmlSchemaGetElem
	add	esp, 12					; 0000000cH

; 25870: 	    vctxt->inode->localName, vctxt->inode->nsName);
; 25871: 	if (decl != NULL) {

	test	eax, eax
	je	SHORT $LN52@xmlSchemaV

; 25872: 	    vctxt->inode->decl = decl;

	mov	ecx, DWORD PTR [esi+108]
	mov	DWORD PTR [ecx+44], eax

; 25873: 	    return (0);

	jmp	$LN110@xmlSchemaV
$LN52@xmlSchemaV:

; 25874: 	}
; 25875:     }
; 25876:     if (wild->processContents == XML_SCHEMAS_ANY_STRICT) {

	cmp	DWORD PTR [ebx+24], 3
	jne	SHORT $LN53@xmlSchemaV

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$2[ebp]
	mov	DWORD PTR _msg$2[ebp], 0
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0FG@DIJLLKJP@No?5matching?5global?5element?5decl@
	push	DWORD PTR _msg$2[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$2[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	1845					; 00000735H
	push	2
	push	esi

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$2[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$2[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 68					; 00000044H

; 2352 :     FREE_AND_NULL(msg)

	test	eax, eax
	je	SHORT $LN65@xmlSchemaV
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN65@xmlSchemaV:

; 25881: 	return (vctxt->err);

	mov	edi, DWORD PTR [esi+52]

; 26953: 	int skip;
; 26954: 	/*
; 26955: 	* Wildcards.
; 26956: 	*/
; 26957: 	ret = xmlSchemaValidateElemWildcard(vctxt, &skip);
; 26958: 	if (ret != 0) {

	test	edi, edi
	je	SHORT $LN17@xmlSchemaV

; 26959: 	    if (ret < 0) {

	jns	$exit$115

; 26960: 		VERROR_INT("xmlSchemaValidateElem",

	push	OFFSET ??_C@_0CI@LODHCMEF@calling?5xmlSchemaValidateElemWi@

; 26961: 		    "calling xmlSchemaValidateElemWildcard()");
; 26962: 		goto internal_error;

	jmp	$LN107@xmlSchemaV
$LN53@xmlSchemaV:

; 25883:     if (vctxt->nbAttrInfos != 0) {

	cmp	DWORD PTR [esi+168], 0
	je	SHORT $LN55@xmlSchemaV

; 25884: 	xmlSchemaAttrInfoPtr iattr;
; 25885: 	/*
; 25886: 	* SPEC Validation Rule: Schema-Validity Assessment (Element)
; 25887: 	* (1.2.1.2.1) - (1.2.1.2.3 )
; 25888: 	*
; 25889: 	* Use the xsi:type attribute for the type definition.
; 25890: 	*/
; 25891: 	iattr = xmlSchemaGetMetaAttrInfo(vctxt,

	push	1
	push	esi
	call	_xmlSchemaGetMetaAttrInfo
	add	esp, 8

; 25892: 	    XML_SCHEMA_ATTR_INFO_META_XSI_TYPE);
; 25893: 	if (iattr != NULL) {

	test	eax, eax
	je	SHORT $LN55@xmlSchemaV

; 25894: 	    if (xmlSchemaProcessXSIType(vctxt, iattr,
; 25895: 		&(vctxt->inode->typeDef), NULL) == -1) {

	mov	ecx, DWORD PTR [esi+108]
	push	0
	add	ecx, 28					; 0000001cH
	push	ecx
	push	eax
	push	esi
	call	_xmlSchemaProcessXSIType
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	SHORT $LN110@xmlSchemaV

; 25896: 		VERROR_INT("xmlSchemaValidateElemWildcard",

	push	OFFSET ??_C@_0EF@GLDBDLOM@calling?5xmlSchemaProcessXSIType@
	push	OFFSET ??_C@_0BO@NHKJDFH@xmlSchemaValidateElemWildcard@
	push	esi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH

; 26960: 		VERROR_INT("xmlSchemaValidateElem",

	push	OFFSET ??_C@_0CI@LODHCMEF@calling?5xmlSchemaValidateElemWi@

; 26961: 		    "calling xmlSchemaValidateElemWildcard()");
; 26962: 		goto internal_error;

	jmp	$LN107@xmlSchemaV
$LN55@xmlSchemaV:

; 25912:     vctxt->inode->typeDef =

	push	45					; 0000002dH
	call	_xmlSchemaGetBuiltInType
	mov	ecx, DWORD PTR [esi+108]
	add	esp, 4
	mov	DWORD PTR [ecx+28], eax
$LN110@xmlSchemaV:

; 26968: 	    goto exit;
; 26969: 	}
; 26970: 	/*
; 26971: 	* The declaration might be set by the wildcard validation,
; 26972: 	* when the processContents is "lax" or "strict".
; 26973: 	*/
; 26974: 	if (vctxt->inode->decl->type != XML_SCHEMA_TYPE_ELEMENT) {

	xor	edi, edi
$LN17@xmlSchemaV:
	mov	ecx, DWORD PTR [esi+108]
	mov	eax, DWORD PTR [ecx+44]
	cmp	DWORD PTR [eax], 14			; 0000000eH
	je	SHORT $LN18@xmlSchemaV

; 26975: 	    /*
; 26976: 	    * Clear the "decl" field to not confuse further processing.
; 26977: 	    */
; 26978: 	    vctxt->inode->decl = NULL;

	mov	DWORD PTR [ecx+44], 0
$type_validation$116:

; 26991: 	}
; 26992: 	goto exit;
; 26993:     }
; 26994:     /*
; 26995:     * Validate against the type definition.
; 26996:     */
; 26997: type_validation:
; 26998: 
; 26999:     if (vctxt->inode->typeDef == NULL) {

	mov	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [eax+28]
	test	ecx, ecx
	jne	SHORT $LN21@xmlSchemaV

; 27000: 	vctxt->inode->flags |= XML_SCHEMA_NODE_INFO_ERR_BAD_TYPE;

	or	DWORD PTR [eax+32], 1024		; 00000400H

; 27001: 	ret = XML_SCHEMAV_CVC_TYPE_1;

	mov	edi, 1875				; 00000753H

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	ecx
	lea	eax, DWORD PTR _msg$3[ebp]
	mov	DWORD PTR _msg$3[ebp], ecx
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0BO@GOBNMKOB@The?5type?5definition?5is?5absent@
	push	DWORD PTR _msg$3[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$3[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	edi

; 27002: 	VERROR(ret, NULL,
; 27003: 	    "The type definition is absent");
; 27004: 	goto exit;

	jmp	SHORT $LN109@xmlSchemaV
$LN18@xmlSchemaV:

; 26979: 	    goto type_validation;
; 26980: 	}
; 26981:     }
; 26982:     /*
; 26983:     * Validate against the declaration.
; 26984:     */
; 26985:     ret = xmlSchemaValidateElemDecl(vctxt);

	push	esi
	call	_xmlSchemaValidateElemDecl
	mov	edi, eax
	add	esp, 4

; 26986:     if (ret != 0) {

	test	edi, edi
	je	SHORT $type_validation$116

; 26987: 	if (ret < 0) {

	jns	SHORT $exit$115

; 26988: 	    VERROR_INT("xmlSchemaValidateElem",

	push	OFFSET ??_C@_0CE@OCICNFMI@calling?5xmlSchemaValidateElemDe@

; 26989: 		"calling xmlSchemaValidateElemDecl()");
; 26990: 	    goto internal_error;

	jmp	$LN107@xmlSchemaV
$LN21@xmlSchemaV:

; 27005:     }
; 27006:     if (vctxt->inode->typeDef->flags & XML_SCHEMAS_TYPE_ABSTRACT) {

	test	DWORD PTR [ecx+48], 1048576		; 00100000H
	je	SHORT $LN22@xmlSchemaV

; 27007: 	vctxt->inode->flags |= XML_SCHEMA_NODE_INFO_ERR_BAD_TYPE;

	or	DWORD PTR [eax+32], 1024		; 00000400H

; 27008: 	ret = XML_SCHEMAV_CVC_TYPE_2;

	mov	edi, 1876				; 00000754H

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$1[ebp]
	mov	DWORD PTR _msg$1[ebp], 0
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0CA@DHELECIF@The?5type?5definition?5is?5abstract@
	push	DWORD PTR _msg$1[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	edi
$LN109@xmlSchemaV:

; 27047: 	    "calling attributes validation");
; 27048: 	goto internal_error;
; 27049:     }
; 27050:     /*
; 27051:     * Don't return an error if attributes are invalid on purpose.
; 27052:     */
; 27053:     ret = 0;
; 27054: 
; 27055: exit:
; 27056:     if (ret != 0)
; 27057: 	vctxt->skipDepth = vctxt->depth;

	push	2
	push	esi
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlSchemaErr4Line
	mov	eax, DWORD PTR _msg$1[ebp]
	add	esp, 68					; 00000044H
	test	eax, eax
	je	SHORT $exit$115
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$exit$115:
	mov	eax, DWORD PTR [esi+96]
	mov	DWORD PTR [esi+176], eax

; 27058:     return (ret);

	mov	eax, edi
	pop	edi

; 27061: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN22@xmlSchemaV:

; 27009: 	    VERROR(ret, NULL,
; 27010: 	    "The type definition is abstract");
; 27011: 	goto exit;
; 27012:     }
; 27013:     /*
; 27014:     * Evaluate IDCs. Do it here, since new IDC matchers are registered
; 27015:     * during validation against the declaration. This must be done
; 27016:     * _before_ attribute validation.
; 27017:     */
; 27018:     if (vctxt->xpathStates != NULL) {

	cmp	DWORD PTR [esi+116], 0
	je	SHORT $LN106@xmlSchemaV

; 27019: 	ret = xmlSchemaXPathEvaluate(vctxt, XML_ELEMENT_NODE);

	push	1
	push	esi
	call	_xmlSchemaXPathEvaluate
	mov	edi, eax
	add	esp, 8

; 27020: 	vctxt->inode->appliedXPath = 1;

	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [eax+80], 1

; 27021: 	if (ret == -1) {

	cmp	edi, -1
	jne	SHORT $LN106@xmlSchemaV

; 27022: 	    VERROR_INT("xmlSchemaValidateElem",

	push	OFFSET ??_C@_0CB@OAMKHEAF@calling?5xmlSchemaXPathEvaluate?$CI@

; 27023: 		"calling xmlSchemaXPathEvaluate()");
; 27024: 	    goto internal_error;

	jmp	$LN107@xmlSchemaV
$LN106@xmlSchemaV:

; 27025: 	}
; 27026:     }
; 27027:     /*
; 27028:     * Validate attributes.
; 27029:     */
; 27030:     if (WXS_IS_COMPLEX(vctxt->inode->typeDef)) {

	mov	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx], 5
	je	SHORT $LN27@xmlSchemaV
	cmp	DWORD PTR [ecx+88], 45			; 0000002dH
	je	SHORT $LN27@xmlSchemaV

; 27035: 	}
; 27036:     } else if (vctxt->nbAttrInfos != 0) {

	mov	eax, DWORD PTR [esi+168]
	test	eax, eax
	je	SHORT $LN31@xmlSchemaV

; 25171:     int ret = 0, i;

	xor	edi, edi

; 25172: 
; 25173:     /*
; 25174:     * SPEC cvc-type (3.1.1)
; 25175:     * "The attributes of must be empty, excepting those whose namespace
; 25176:     * name is identical to http://www.w3.org/2001/XMLSchema-instance and
; 25177:     * whose local name is one of type, nil, schemaLocation or
; 25178:     * noNamespaceSchemaLocation."
; 25179:     */
; 25180:     if (vctxt->nbAttrInfos == 0)
; 25181: 	return (0);
; 25182:     for (i = 0; i < vctxt->nbAttrInfos; i++) {

	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN89@xmlSchemaV
	npad	1
$LL90@xmlSchemaV:

; 25183: 	iattr = vctxt->attrInfos[i];

	mov	eax, DWORD PTR [esi+164]
	mov	eax, DWORD PTR [eax+ebx*4]

; 25184: 	if (! iattr->metaType) {

	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN88@xmlSchemaV

; 25185: 	    ACTIVATE_ATTRIBUTE(iattr)
; 25186: 	    xmlSchemaIllegalAttrErr(ACTXT_CAST vctxt,

	push	0
	push	eax
	push	1827					; 00000723H
	push	esi
	mov	DWORD PTR [esi+108], eax
	call	_xmlSchemaIllegalAttrErr
	add	esp, 16					; 00000010H

; 25187: 		XML_SCHEMAV_CVC_TYPE_3_1_1, iattr, NULL);
; 25188: 	    ret = XML_SCHEMAV_CVC_TYPE_3_1_1;

	mov	edi, 1827				; 00000723H
$LN88@xmlSchemaV:

; 25172: 
; 25173:     /*
; 25174:     * SPEC cvc-type (3.1.1)
; 25175:     * "The attributes of must be empty, excepting those whose namespace
; 25176:     * name is identical to http://www.w3.org/2001/XMLSchema-instance and
; 25177:     * whose local name is one of type, nil, schemaLocation or
; 25178:     * noNamespaceSchemaLocation."
; 25179:     */
; 25180:     if (vctxt->nbAttrInfos == 0)
; 25181: 	return (0);
; 25182:     for (i = 0; i < vctxt->nbAttrInfos; i++) {

	inc	ebx
	cmp	ebx, DWORD PTR [esi+168]
	jl	SHORT $LL90@xmlSchemaV
$LN89@xmlSchemaV:

; 25189:         }
; 25190:     }
; 25191:     ACTIVATE_ELEM

	mov	ecx, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [esi+100]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+108], eax

; 25192:     return (ret);

	jmp	SHORT $LN112@xmlSchemaV
$LN27@xmlSchemaV:

; 27031: 	if ((vctxt->nbAttrInfos != 0) ||

	mov	eax, DWORD PTR [esi+168]
	test	eax, eax
	jne	SHORT $LN29@xmlSchemaV
	cmp	DWORD PTR [ecx+116], eax
	je	SHORT $LN28@xmlSchemaV
$LN29@xmlSchemaV:

; 27032: 	    (vctxt->inode->typeDef->attrUses != NULL)) {
; 27033: 
; 27034: 	    ret = xmlSchemaVAttributesComplex(vctxt);

	push	esi
	call	_xmlSchemaVAttributesComplex
	add	esp, 4
	mov	edi, eax
$LN112@xmlSchemaV:

; 27037: 
; 27038: 	ret = xmlSchemaVAttributesSimple(vctxt);
; 27039:     }
; 27040:     /*
; 27041:     * Clear registered attributes.
; 27042:     */
; 27043:     if (vctxt->nbAttrInfos != 0)

	mov	eax, DWORD PTR [esi+168]
$LN28@xmlSchemaV:
	test	eax, eax
	je	SHORT $LN31@xmlSchemaV

; 27044: 	xmlSchemaClearAttrInfos(vctxt);

	push	esi
	call	_xmlSchemaClearAttrInfos
	add	esp, 4
$LN31@xmlSchemaV:

; 27045:     if (ret == -1) {

	cmp	edi, -1
	jne	$LN32@xmlSchemaV

; 27046: 	VERROR_INT("xmlSchemaValidateElem",

	push	OFFSET ??_C@_0BO@EFEFIODN@calling?5attributes?5validation@
$LN107@xmlSchemaV:

; 27059: internal_error:
; 27060:     return (-1);

	push	OFFSET ??_C@_0BG@PEPPJHKP@xmlSchemaValidateElem@
	push	esi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH
$internal_error$114:

; 27061: }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaValidateElem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaVPushText
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_nodeType$ = 12						; size = 4
_value$ = 16						; size = 4
_len$ = 20						; size = 4
_mode$ = 24						; size = 4
_msg$1 = 28						; size = 4
_msg$2 = 28						; size = 4
_msg$3 = 28						; size = 4
_consumed$ = 28						; size = 4
_xmlSchemaVPushText PROC				; COMDAT

; 26750: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _consumed$[ebp]
	test	edx, edx
	je	SHORT $LN4@xmlSchemaV

; 26751:     /*
; 26752:     * Unfortunately we have to duplicate the text sometimes.
; 26753:     * OPTIMIZE: Maybe we could skip it, if:
; 26754:     *   1. content type is simple
; 26755:     *   2. whitespace is "collapse"
; 26756:     *   3. it consists of whitespace only
; 26757:     *
; 26758:     * Process character content.
; 26759:     */
; 26760:     if (consumed != NULL)
; 26761: 	*consumed = 0;

	mov	DWORD PTR [edx], 0
$LN4@xmlSchemaV:
	push	esi

; 26762:     if (INODE_NILLED(vctxt->inode)) {

	mov	esi, DWORD PTR _vctxt$[ebp]
	mov	ecx, DWORD PTR [esi+108]
	test	BYTE PTR [ecx+32], 4
	je	SHORT $LN5@xmlSchemaV

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$3[ebp]
	mov	DWORD PTR _msg$3[ebp], 0
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0FB@HDMHOBND@Neither?5character?5nor?5element?5c@
	push	DWORD PTR _msg$3[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$3[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	1848					; 00000738H
$LN57@xmlSchemaV:

; 26868: 	}
; 26869:     }
; 26870: 
; 26871:     return (0);
; 26872: }

	push	2
	push	esi
	mov	DWORD PTR _msg$3[ebp], eax
	call	_xmlSchemaErr4Line
	mov	eax, DWORD PTR _msg$3[ebp]
	add	esp, 68					; 00000044H
	test	eax, eax
	je	SHORT $LN32@xmlSchemaV
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN32@xmlSchemaV:
	mov	eax, DWORD PTR [esi+52]
	pop	esi
	pop	ebp
	ret	0
$LN5@xmlSchemaV:

; 26763: 	/*
; 26764: 	* SPEC cvc-elt (3.3.4 - 3.2.1)
; 26765: 	* "The element information item must have no character or
; 26766: 	* element information item [children]."
; 26767: 	*/
; 26768: 	VERROR(XML_SCHEMAV_CVC_ELT_3_2_1, NULL,
; 26769: 	    "Neither character nor element content is allowed "
; 26770: 	    "because the element is 'nilled'");
; 26771: 	return (vctxt->err);
; 26772:     }
; 26773:     /*
; 26774:     * SPEC (2.1) "If the {content type} is empty, then the
; 26775:     * element information item has no character or element
; 26776:     * information item [children]."
; 26777:     */
; 26778:     if (vctxt->inode->typeDef->contentType ==

	mov	eax, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [eax+52]
	cmp	eax, 1
	jne	SHORT $LN6@xmlSchemaV

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$2[ebp]
	mov	DWORD PTR _msg$2[ebp], 0
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0EE@EDDPNAMO@Character?5content?5is?5not?5allowe@
	push	DWORD PTR _msg$2[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$2[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	1841					; 00000731H

; 26779: 	    XML_SCHEMA_CONTENT_EMPTY) {
; 26780: 	VERROR(XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1, NULL,
; 26781: 	    "Character content is not allowed, "
; 26782: 	    "because the content type is empty");
; 26783: 	return (vctxt->err);

	jmp	SHORT $LN57@xmlSchemaV
$LN6@xmlSchemaV:

; 26784:     }
; 26785: 
; 26786:     if (vctxt->inode->typeDef->contentType ==

	cmp	eax, 2
	jne	SHORT $LN7@xmlSchemaV

; 26787: 	    XML_SCHEMA_CONTENT_ELEMENTS) {
; 26788: 	if ((nodeType != XML_TEXT_NODE) ||

	cmp	DWORD PTR _nodeType$[ebp], 3
	jne	SHORT $LN9@xmlSchemaV
	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _value$[ebp]
	call	_xmlSchemaIsBlank
	add	esp, 8
	test	eax, eax
	jne	$LN11@xmlSchemaV
$LN9@xmlSchemaV:

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$1[ebp]
	mov	DWORD PTR _msg$1[ebp], 0
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0GC@MDHGDDOF@Character?5content?5other?5than?5wh@
	push	DWORD PTR _msg$1[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	1843					; 00000733H

; 26789: 	    (! xmlSchemaIsBlank((xmlChar *) value, len))) {
; 26790: 	    /*
; 26791: 	    * SPEC cvc-complex-type (2.3)
; 26792: 	    * "If the {content type} is element-only, then the
; 26793: 	    * element information item has no character information
; 26794: 	    * item [children] other than those whose [character
; 26795: 	    * code] is defined as a white space in [XML 1.0 (Second
; 26796: 	    * Edition)]."
; 26797: 	    */
; 26798: 	    VERROR(XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3, NULL,
; 26799: 		"Character content other than whitespace is not allowed "
; 26800: 		"because the content type is 'element-only'");
; 26801: 	    return (vctxt->err);

	jmp	$LN57@xmlSchemaV
$LN7@xmlSchemaV:
	push	edi

; 26802: 	}
; 26803: 	return (0);
; 26804:     }
; 26805: 
; 26806:     if ((value == NULL) || (value[0] == 0))

	mov	edi, DWORD PTR _value$[ebp]
	test	edi, edi
	je	$LN54@xmlSchemaV
	cmp	BYTE PTR [edi], 0
	je	$LN54@xmlSchemaV

; 26808:     /*
; 26809:     * Save the value.
; 26810:     * NOTE that even if the content type is *mixed*, we need the
; 26811:     * *initial value* for default/fixed value constraints.
; 26812:     */
; 26813:     if ((vctxt->inode->typeDef->contentType == XML_SCHEMA_CONTENT_MIXED) &&

	cmp	eax, 3
	jne	SHORT $LN12@xmlSchemaV
	mov	eax, DWORD PTR [ecx+44]
	test	eax, eax
	je	$LN54@xmlSchemaV
	cmp	DWORD PTR [eax+76], 0
	je	$LN54@xmlSchemaV
$LN12@xmlSchemaV:

; 26814: 	((vctxt->inode->decl == NULL) ||
; 26815: 	(vctxt->inode->decl->value == NULL)))
; 26816: 	return (0);
; 26817: 
; 26818:     if (vctxt->inode->value == NULL) {

	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN14@xmlSchemaV

; 26819: 	/*
; 26820: 	* Set the value.
; 26821: 	*/
; 26822: 	switch (mode) {

	mov	eax, DWORD PTR _mode$[ebp]
	sub	eax, 1
	je	SHORT $LN16@xmlSchemaV
	sub	eax, 1
	je	SHORT $LN17@xmlSchemaV
	sub	eax, 1
	jne	$LN54@xmlSchemaV

; 26837: 		vctxt->inode->flags |=
; 26838: 		    XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES;
; 26839: 		break;
; 26840: 	    case XML_SCHEMA_PUSH_TEXT_VOLATILE:
; 26841: 		/*
; 26842: 		* When working with SAX.
; 26843: 		* The value will be freed by the element info.
; 26844: 		*/
; 26845: 		if (len != -1)

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, -1
	je	SHORT $LN20@xmlSchemaV

; 26846: 		    vctxt->inode->value = BAD_CAST xmlStrndup(value, len);

	push	eax
	push	edi
	call	_xmlStrndup

; 26863: 		(xmlChar *) vctxt->inode->value, value, len);
; 26864: 	} else {
; 26865: 	    vctxt->inode->value =

	mov	ecx, DWORD PTR [esi+108]
	add	esp, 8
	mov	DWORD PTR [ecx+20], eax

; 26866: 		BAD_CAST xmlStrncatNew(vctxt->inode->value, value, len);
; 26867: 	    vctxt->inode->flags |= XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES;

	mov	eax, DWORD PTR [esi+108]
	pop	edi
	pop	esi
	or	DWORD PTR [eax+32], 2
	xor	eax, eax

; 26868: 	}
; 26869:     }
; 26870: 
; 26871:     return (0);
; 26872: }

	pop	ebp
	ret	0
$LN20@xmlSchemaV:

; 26847: 		else
; 26848: 		    vctxt->inode->value = BAD_CAST xmlStrdup(value);

	push	edi
	call	_xmlStrdup

; 26863: 		(xmlChar *) vctxt->inode->value, value, len);
; 26864: 	} else {
; 26865: 	    vctxt->inode->value =

	mov	ecx, DWORD PTR [esi+108]
	add	esp, 4
	mov	DWORD PTR [ecx+20], eax

; 26866: 		BAD_CAST xmlStrncatNew(vctxt->inode->value, value, len);
; 26867: 	    vctxt->inode->flags |= XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES;

	mov	eax, DWORD PTR [esi+108]
	pop	edi
	pop	esi
	or	DWORD PTR [eax+32], 2
	xor	eax, eax

; 26868: 	}
; 26869:     }
; 26870: 
; 26871:     return (0);
; 26872: }

	pop	ebp
	ret	0
$LN17@xmlSchemaV:

; 26828: 		break;
; 26829: 	    case XML_SCHEMA_PUSH_TEXT_CREATED:
; 26830: 		/*
; 26831: 		* When working with the reader.
; 26832: 		* The value will be freed by the element info.
; 26833: 		*/
; 26834: 		vctxt->inode->value = value;

	mov	DWORD PTR [ecx+20], edi

; 26835: 		if (consumed != NULL)

	test	edx, edx
	je	SHORT $LN18@xmlSchemaV

; 26836: 		    *consumed = 1;

	mov	DWORD PTR [edx], 1

; 26866: 		BAD_CAST xmlStrncatNew(vctxt->inode->value, value, len);
; 26867: 	    vctxt->inode->flags |= XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES;

	mov	eax, DWORD PTR [esi+108]
	pop	edi
	pop	esi
	or	DWORD PTR [eax+32], 2
	xor	eax, eax

; 26868: 	}
; 26869:     }
; 26870: 
; 26871:     return (0);
; 26872: }

	pop	ebp
	ret	0
$LN16@xmlSchemaV:

; 26823: 	    case XML_SCHEMA_PUSH_TEXT_PERSIST:
; 26824: 		/*
; 26825: 		* When working on a tree.
; 26826: 		*/
; 26827: 		vctxt->inode->value = value;

	mov	DWORD PTR [ecx+20], edi
	xor	eax, eax
	pop	edi
	pop	esi

; 26868: 	}
; 26869:     }
; 26870: 
; 26871:     return (0);
; 26872: }

	pop	ebp
	ret	0
$LN14@xmlSchemaV:

; 26849: 		vctxt->inode->flags |=
; 26850: 		    XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES;
; 26851: 		break;
; 26852: 	    default:
; 26853: 		break;
; 26854: 	}
; 26855:     } else {
; 26856: 	if (len < 0)

	mov	eax, DWORD PTR _len$[ebp]
	test	eax, eax
	jns	SHORT $LN23@xmlSchemaV

; 26857: 	    len = xmlStrlen(value);

	push	edi
	call	_xmlStrlen
	mov	ecx, DWORD PTR [esi+108]
	add	esp, 4
$LN23@xmlSchemaV:

; 26858: 	/*
; 26859: 	* Concat the value.
; 26860: 	*/
; 26861: 	if (vctxt->inode->flags & XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES) {

	test	BYTE PTR [ecx+32], 2
	mov	edx, DWORD PTR [ecx+20]
	push	eax
	push	edi
	push	edx
	je	SHORT $LN24@xmlSchemaV

; 26862: 	    vctxt->inode->value = BAD_CAST xmlStrncat(

	call	_xmlStrncat
	mov	ecx, DWORD PTR [esi+108]
	add	esp, 12					; 0000000cH
	pop	edi
	mov	DWORD PTR [ecx+20], eax
	xor	eax, eax
	pop	esi

; 26868: 	}
; 26869:     }
; 26870: 
; 26871:     return (0);
; 26872: }

	pop	ebp
	ret	0
$LN24@xmlSchemaV:

; 26863: 		(xmlChar *) vctxt->inode->value, value, len);
; 26864: 	} else {
; 26865: 	    vctxt->inode->value =

	call	_xmlStrncatNew
	mov	ecx, DWORD PTR [esi+108]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+20], eax
$LN18@xmlSchemaV:

; 26866: 		BAD_CAST xmlStrncatNew(vctxt->inode->value, value, len);
; 26867: 	    vctxt->inode->flags |= XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES;

	mov	eax, DWORD PTR [esi+108]
	or	DWORD PTR [eax+32], 2
$LN54@xmlSchemaV:
	pop	edi
$LN11@xmlSchemaV:

; 26807: 	return (0);

	xor	eax, eax
	pop	esi

; 26868: 	}
; 26869:     }
; 26870: 
; 26871:     return (0);
; 26872: }

	pop	ebp
	ret	0
_xmlSchemaVPushText ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidateChildElem
_TEXT	SEGMENT
_values$1 = -48						; size = 40
_terminal$2 = -8					; size = 4
_nbneg$3 = -4						; size = 4
_msg$4 = 8						; size = 4
_msg$5 = 8						; size = 4
_msg$6 = 8						; size = 4
_msg$7 = 8						; size = 4
_nbval$8 = 8						; size = 4
_vctxt$ = 8						; size = 4
_xmlSchemaValidateChildElem PROC			; COMDAT

; 26523: {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	ebx
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _vctxt$[ebp]
	mov	ebx, DWORD PTR [esi+96]
	test	ebx, ebx
	jg	SHORT $LN4@xmlSchemaV

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CF@GNGFKIEN@not?5intended?5for?5the?5validation@
	push	OFFSET ??_C@_0BL@FBELDAFB@xmlSchemaValidateChildElem@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 26524:     xmlSchemaNodeInfoPtr pielem;
; 26525:     xmlSchemaTypePtr ptype;
; 26526:     int ret = 0;
; 26527: 
; 26528:     if (vctxt->depth <= 0) {
; 26529: 	VERROR_INT("xmlSchemaValidateChildElem",
; 26530: 	    "not intended for the validation root");
; 26531: 	return (-1);

	or	eax, -1
	pop	esi

; 26740: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlSchemaV:

; 26532:     }
; 26533:     pielem = vctxt->elemInfos[vctxt->depth -1];

	mov	eax, DWORD PTR [esi+100]
	mov	ebx, DWORD PTR [eax+ebx*4-4]

; 26534:     if (pielem->flags & XML_SCHEMA_ELEM_INFO_EMPTY)

	mov	ecx, DWORD PTR [ebx+32]
	test	cl, 32					; 00000020H
	je	SHORT $LN5@xmlSchemaV

; 26535: 	pielem->flags ^= XML_SCHEMA_ELEM_INFO_EMPTY;

	xor	ecx, 32					; 00000020H
	mov	DWORD PTR [ebx+32], ecx
$LN5@xmlSchemaV:

; 26536:     /*
; 26537:     * Handle 'nilled' elements.
; 26538:     */
; 26539:     if (INODE_NILLED(pielem)) {

	push	edi
	test	cl, 4
	je	SHORT $LN6@xmlSchemaV

; 26540: 	/*
; 26541: 	* SPEC (cvc-elt) (3.3.4) : (3.2.1)
; 26542: 	*/
; 26543: 	ACTIVATE_PARENT_ELEM;

	mov	ecx, DWORD PTR [esi+96]

; 26544: 	ret = XML_SCHEMAV_CVC_ELT_3_2_1;

	mov	edi, 1848				; 00000738H
	mov	eax, DWORD PTR [esi+100]

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	push	esi
	mov	DWORD PTR _msg$7[ebp], 0

; 26540: 	/*
; 26541: 	* SPEC (cvc-elt) (3.3.4) : (3.2.1)
; 26542: 	*/
; 26543: 	ACTIVATE_PARENT_ELEM;

	mov	eax, DWORD PTR [eax+ecx*4-4]
	mov	DWORD PTR [esi+108], eax

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	lea	eax, DWORD PTR _msg$7[ebp]
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0FD@PPFLCKNL@Neither?5character?5nor?5element?5c@
	push	DWORD PTR _msg$7[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$7[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	edi
$LN71@xmlSchemaV:

; 26731: unexpected_elem:
; 26732:     /*
; 26733:     * Pop this element and set the skipDepth to skip
; 26734:     * all further content of the parent element.
; 26735:     */
; 26736:     vctxt->skipDepth = vctxt->depth;

	push	2
	push	esi
	mov	DWORD PTR _msg$7[ebp], eax
	call	_xmlSchemaErr4Line
	mov	eax, DWORD PTR _msg$7[ebp]
	add	esp, 68					; 00000044H
	test	eax, eax
	je	$LN35@xmlSchemaV
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	jmp	$LN35@xmlSchemaV
$LN6@xmlSchemaV:

; 26545: 	VERROR(ret, NULL,
; 26546: 	    "Neither character nor element content is allowed, "
; 26547: 	    "because the element was 'nilled'");
; 26548: 	ACTIVATE_ELEM;
; 26549: 	goto unexpected_elem;
; 26550:     }
; 26551: 
; 26552:     ptype = pielem->typeDef;

	mov	edx, DWORD PTR [ebx+28]

; 26553: 
; 26554:     if (ptype->builtInType == XML_SCHEMAS_ANYTYPE) {

	cmp	DWORD PTR [edx+88], 45			; 0000002dH
	jne	SHORT $LN7@xmlSchemaV

; 26555: 	/*
; 26556: 	* Workaround for "anyType": we have currently no content model
; 26557: 	* assigned for "anyType", so handle it explicitely.
; 26558: 	* "anyType" has an unbounded, lax "any" wildcard.
; 26559: 	*/
; 26560: 	vctxt->inode->decl = xmlSchemaGetElem(vctxt->schema,

	mov	eax, DWORD PTR [esi+108]
	push	DWORD PTR [eax+16]
	push	DWORD PTR [eax+12]
	push	DWORD PTR [esi+20]
	call	_xmlSchemaGetElem
	mov	ecx, DWORD PTR [esi+108]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+44], eax

; 26561: 	    vctxt->inode->localName,
; 26562: 	    vctxt->inode->nsName);
; 26563: 
; 26564: 	if (vctxt->inode->decl == NULL) {

	mov	eax, DWORD PTR [esi+108]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN26@xmlSchemaV

; 26565: 	    xmlSchemaAttrInfoPtr iattr;
; 26566: 	    /*
; 26567: 	    * Process "xsi:type".
; 26568: 	    * SPEC (cvc-assess-elt) (1.2.1.2.1) - (1.2.1.2.3)
; 26569: 	    */
; 26570: 	    iattr = xmlSchemaGetMetaAttrInfo(vctxt,

	push	1
	push	esi
	call	_xmlSchemaGetMetaAttrInfo
	mov	ecx, eax
	add	esp, 8

; 26571: 		XML_SCHEMA_ATTR_INFO_META_XSI_TYPE);
; 26572: 	    if (iattr != NULL) {

	test	ecx, ecx
	je	SHORT $LN9@xmlSchemaV

; 26573: 		ret = xmlSchemaProcessXSIType(vctxt, iattr,

	mov	eax, DWORD PTR [esi+108]
	push	0
	add	eax, 28					; 0000001cH
	push	eax
	push	ecx
	push	esi
	call	_xmlSchemaProcessXSIType
	add	esp, 16					; 00000010H

; 26574: 		    &(vctxt->inode->typeDef), NULL);
; 26575: 		if (ret != 0) {

	test	eax, eax
	je	SHORT $LN26@xmlSchemaV

; 26576: 		    if (ret == -1) {

	cmp	eax, -1
	jne	SHORT $LN66@xmlSchemaV

; 26577: 			VERROR_INT("xmlSchemaValidateChildElem",

	push	OFFSET ??_C@_0EF@GLDBDLOM@calling?5xmlSchemaProcessXSIType@

; 26578: 			    "calling xmlSchemaProcessXSIType() to "
; 26579: 			    "process the attribute 'xsi:nil'");
; 26580: 			return (-1);

	jmp	$LN70@xmlSchemaV
$LN9@xmlSchemaV:

; 26581: 		    }
; 26582: 		    return (ret);
; 26583: 		}
; 26584: 	    } else {
; 26585: 		 /*
; 26586: 		 * Fallback to "anyType".
; 26587: 		 *
; 26588: 		 * SPEC (cvc-assess-elt)
; 26589: 		 * "If the item cannot be `strictly assessed`, [...]
; 26590: 		 * an element information item's schema validity may be laxly
; 26591: 		 * assessed if its `context-determined declaration` is not
; 26592: 		 * skip by `validating` with respect to the `ur-type
; 26593: 		 * definition` as per Element Locally Valid (Type) ($3.3.4)."
; 26594: 		*/
; 26595: 		vctxt->inode->typeDef =

	push	45					; 0000002dH
	call	_xmlSchemaGetBuiltInType
	mov	ecx, DWORD PTR [esi+108]
	add	esp, 4
	mov	DWORD PTR [ecx+28], eax
$LN26@xmlSchemaV:

; 26724: 	    goto unexpected_elem;
; 26725: 	    break;
; 26726: 
; 26727: 	default:
; 26728: 	    break;
; 26729:     }
; 26730:     return (ret);

	xor	eax, eax
$LN66@xmlSchemaV:
	pop	edi
	pop	esi

; 26740: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlSchemaV:

; 26596: 		    xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
; 26597: 	    }
; 26598: 	}
; 26599: 	return (0);
; 26600:     }
; 26601: 
; 26602:     switch (ptype->contentType) {

	mov	eax, DWORD PTR [edx+52]
	dec	eax
	cmp	eax, 5
	ja	SHORT $LN26@xmlSchemaV
	jmp	DWORD PTR $LN73@xmlSchemaV[eax*4]
$LN13@xmlSchemaV:

; 26603: 	case XML_SCHEMA_CONTENT_EMPTY:
; 26604: 	    /*
; 26605: 	    * SPEC (2.1) "If the {content type} is empty, then the
; 26606: 	    * element information item has no character or element
; 26607: 	    * information item [children]."
; 26608: 	    */
; 26609: 	    ACTIVATE_PARENT_ELEM

	mov	ecx, DWORD PTR [esi+96]

; 26610: 	    ret = XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1;

	mov	edi, 1841				; 00000731H
	mov	eax, DWORD PTR [esi+100]

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	push	esi
	mov	DWORD PTR _msg$6[ebp], 0

; 26603: 	case XML_SCHEMA_CONTENT_EMPTY:
; 26604: 	    /*
; 26605: 	    * SPEC (2.1) "If the {content type} is empty, then the
; 26606: 	    * element information item has no character or element
; 26607: 	    * information item [children]."
; 26608: 	    */
; 26609: 	    ACTIVATE_PARENT_ELEM

	mov	eax, DWORD PTR [eax+ecx*4-4]
	mov	DWORD PTR [esi+108], eax

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	lea	eax, DWORD PTR _msg$6[ebp]
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0EC@KOBHHIFI@Element?5content?5is?5not?5allowed?0@
	push	DWORD PTR _msg$6[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$6[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	edi

; 26611: 	    VERROR(ret, NULL,
; 26612: 		"Element content is not allowed, "
; 26613: 		"because the content type is empty");
; 26614: 	    ACTIVATE_ELEM
; 26615: 	    goto unexpected_elem;

	jmp	$LN71@xmlSchemaV
$LN14@xmlSchemaV:

; 26616: 	    break;
; 26617: 
; 26618: 	case XML_SCHEMA_CONTENT_MIXED:
; 26619:         case XML_SCHEMA_CONTENT_ELEMENTS: {
; 26620: 	    xmlRegExecCtxtPtr regexCtxt;
; 26621: 	    xmlChar *values[10];
; 26622: 	    int terminal, nbval = 10, nbneg;
; 26623: 
; 26624: 	    /* VAL TODO: Optimized "anyType" validation.*/
; 26625: 
; 26626: 	    if (ptype->contModel == NULL) {

	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR _nbval$8[ebp], 10		; 0000000aH
	test	eax, eax
	jne	SHORT $LN15@xmlSchemaV

; 26627: 		VERROR_INT("xmlSchemaValidateChildElem",

	push	OFFSET ??_C@_0CL@MKLADNOP@type?5has?5elem?5content?5but?5no?5co@

; 26628: 		    "type has elem content but no content model");
; 26629: 		return (-1);

	jmp	SHORT $LN70@xmlSchemaV
$LN15@xmlSchemaV:

; 26630: 	    }
; 26631: 	    /*
; 26632: 	    * Safety belf for evaluation if the cont. model was already
; 26633: 	    * examined to be invalid.
; 26634: 	    */
; 26635: 	    if (pielem->flags & XML_SCHEMA_ELEM_INFO_ERR_BAD_CONTENT) {

	test	ecx, 256				; 00000100H
	je	SHORT $LN16@xmlSchemaV

; 26636: 		VERROR_INT("xmlSchemaValidateChildElem",

	push	OFFSET ??_C@_0DF@OBNAIIEI@validating?5elem?0?5but?5elem?5conte@

; 26637: 		    "validating elem, but elem content is already invalid");
; 26638: 		return (-1);

	jmp	SHORT $LN70@xmlSchemaV
$LN16@xmlSchemaV:

; 26639: 	    }
; 26640: 
; 26641: 	    regexCtxt = pielem->regexCtxt;

	mov	edi, DWORD PTR [ebx+60]

; 26642: 	    if (regexCtxt == NULL) {

	test	edi, edi
	jne	SHORT $LN17@xmlSchemaV

; 26643: 		/*
; 26644: 		* Create the regex context.
; 26645: 		*/
; 26646: 		regexCtxt = xmlRegNewExecCtxt(ptype->contModel,

	push	esi
	push	OFFSET _xmlSchemaVContentModelCallback
	push	eax
	call	_xmlRegNewExecCtxt
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 26647: 		    xmlSchemaVContentModelCallback, vctxt);
; 26648: 		if (regexCtxt == NULL) {

	test	edi, edi
	jne	SHORT $LN18@xmlSchemaV

; 26649: 		    VERROR_INT("xmlSchemaValidateChildElem",

	push	OFFSET ??_C@_0CB@GNCACIIF@failed?5to?5create?5a?5regex?5contex@

; 26650: 			"failed to create a regex context");
; 26651: 		    return (-1);

	jmp	SHORT $LN70@xmlSchemaV
$LN18@xmlSchemaV:

; 26652: 		}
; 26653: 		pielem->regexCtxt = regexCtxt;

	mov	DWORD PTR [ebx+60], edi
$LN17@xmlSchemaV:

; 26654: #ifdef DEBUG_AUTOMATA
; 26655: 		xmlGenericError(xmlGenericErrorContext, "AUTOMATA create on '%s'\n",
; 26656: 		    pielem->localName);
; 26657: #endif
; 26658: 	    }
; 26659: 
; 26660: 	    /*
; 26661: 	    * SPEC (2.4) "If the {content type} is element-only or mixed,
; 26662: 	    * then the sequence of the element information item's
; 26663: 	    * element information item [children], if any, taken in
; 26664: 	    * order, is `valid` with respect to the {content type}'s
; 26665: 	    * particle, as defined in Element Sequence Locally Valid
; 26666: 	    * (Particle) ($3.9.4)."
; 26667: 	    */
; 26668: 	    ret = xmlRegExecPushString2(regexCtxt,

	mov	eax, DWORD PTR [esi+108]
	push	eax
	push	DWORD PTR [eax+16]
	push	DWORD PTR [eax+12]
	push	edi
	call	_xmlRegExecPushString2
	add	esp, 16					; 00000010H

; 26669: 		vctxt->inode->localName,
; 26670: 		vctxt->inode->nsName,
; 26671: 		vctxt->inode);
; 26672: #ifdef DEBUG_AUTOMATA
; 26673: 	    if (ret < 0)
; 26674: 		xmlGenericError(xmlGenericErrorContext,
; 26675: 		"AUTOMATON push ERROR for '%s' on '%s'\n",
; 26676: 		vctxt->inode->localName, pielem->localName);
; 26677: 	    else
; 26678: 		xmlGenericError(xmlGenericErrorContext,
; 26679: 		"AUTOMATON push OK for '%s' on '%s'\n",
; 26680: 		vctxt->inode->localName, pielem->localName);
; 26681: #endif
; 26682: 	    if (vctxt->err == XML_SCHEMAV_INTERNAL) {

	cmp	DWORD PTR [esi+52], 1818		; 0000071aH
	jne	SHORT $LN19@xmlSchemaV

; 26683: 		VERROR_INT("xmlSchemaValidateChildElem",

	push	OFFSET ??_C@_0CA@OAIJEHME@calling?5xmlRegExecPushString2?$CI?$CJ@
$LN70@xmlSchemaV:
	push	OFFSET ??_C@_0BL@FBELDAFB@xmlSchemaValidateChildElem@
	push	esi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH

; 26684: 		    "calling xmlRegExecPushString2()");
; 26685: 		return (-1);

	or	eax, -1
	pop	edi
	pop	esi

; 26740: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlSchemaV:

; 26686: 	    }
; 26687: 	    if (ret < 0) {

	test	eax, eax
	jns	$LN26@xmlSchemaV

; 26688: 		xmlRegExecErrInfo(regexCtxt, NULL, &nbval, &nbneg,

	lea	eax, DWORD PTR _terminal$2[ebp]
	push	eax
	lea	eax, DWORD PTR _values$1[ebp]
	push	eax
	lea	eax, DWORD PTR _nbneg$3[ebp]
	push	eax
	lea	eax, DWORD PTR _nbval$8[ebp]
	push	eax
	push	0
	push	edi
	call	_xmlRegExecErrInfo

; 26689: 		    &values[0], &terminal);
; 26690: 		xmlSchemaComplexTypeErr(ACTXT_CAST vctxt,

	lea	eax, DWORD PTR _values$1[ebp]
	push	eax
	push	DWORD PTR _nbneg$3[ebp]
	push	DWORD PTR _nbval$8[ebp]
	push	OFFSET ??_C@_0BN@MPLEFMDA@This?5element?5is?5not?5expected@
	push	0
	push	0
	push	1871					; 0000074fH
	push	esi
	call	_xmlSchemaComplexTypeErr

; 26691: 		    XML_SCHEMAV_ELEMENT_CONTENT, NULL,NULL,
; 26692: 		    "This element is not expected",
; 26693: 		    nbval, nbneg, values);
; 26694: 		ret = vctxt->err;

	mov	edi, DWORD PTR [esi+52]
	add	esp, 56					; 00000038H
	mov	ecx, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [esi+108]

; 26695: 		goto unexpected_elem;

	jmp	$unexpected_elem$74
$LN22@xmlSchemaV:

; 26696: 	    } else
; 26697: 		ret = 0;
; 26698: 	}
; 26699: 	    break;
; 26700: 	case XML_SCHEMA_CONTENT_SIMPLE:
; 26701: 	case XML_SCHEMA_CONTENT_BASIC:
; 26702: 	    ACTIVATE_PARENT_ELEM

	mov	ecx, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [esi+100]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	mov	DWORD PTR [esi+108], eax

; 26703: 	    if (WXS_IS_COMPLEX(ptype)) {

	cmp	DWORD PTR [edx], 5
	je	SHORT $LN25@xmlSchemaV
	cmp	DWORD PTR [edx+88], 45			; 0000002dH
	je	SHORT $LN25@xmlSchemaV

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$4[ebp]
	mov	DWORD PTR _msg$4[ebp], 0
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0EG@PMDFJIHB@Element?5content?5is?5not?5allowed?0@
	push	DWORD PTR _msg$4[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$4[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	1828					; 00000724H

; 2352 :     FREE_AND_NULL(msg)

	jmp	SHORT $LN68@xmlSchemaV
$LN25@xmlSchemaV:

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$5[ebp]
	mov	DWORD PTR _msg$5[ebp], 0
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0FF@IENAPLLP@Element?5content?5is?5not?5allowed?0@
	push	DWORD PTR _msg$5[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$5[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	1842					; 00000732H
$LN68@xmlSchemaV:

; 26704: 		/*
; 26705: 		* SPEC (cvc-complex-type) (2.2)
; 26706: 		* "If the {content type} is a simple type definition, then
; 26707: 		* the element information item has no element information
; 26708: 		* item [children], ..."
; 26709: 		*/
; 26710: 		ret = XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2;
; 26711: 		VERROR(ret, NULL, "Element content is not allowed, "
; 26712: 		    "because the content type is a simple type definition");
; 26713: 	    } else {
; 26714: 		/*
; 26715: 		* SPEC (cvc-type) (3.1.2) "The element information item must
; 26716: 		* have no element information item [children]."
; 26717: 		*/
; 26718: 		ret = XML_SCHEMAV_CVC_TYPE_3_1_2;
; 26719: 		VERROR(ret, NULL, "Element content is not allowed, "
; 26720: 		    "because the type definition is simple");
; 26721: 	    }
; 26722: 	    ACTIVATE_ELEM
; 26723: 	    ret = vctxt->err;

	push	2
	push	esi
	mov	DWORD PTR _msg$5[ebp], eax
	call	_xmlSchemaErr4Line
	mov	eax, DWORD PTR _msg$5[ebp]
	add	esp, 68					; 00000044H
	test	eax, eax
	je	SHORT $LN53@xmlSchemaV
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN53@xmlSchemaV:
	mov	edi, DWORD PTR [esi+52]
$LN35@xmlSchemaV:

; 26731: unexpected_elem:
; 26732:     /*
; 26733:     * Pop this element and set the skipDepth to skip
; 26734:     * all further content of the parent element.
; 26735:     */
; 26736:     vctxt->skipDepth = vctxt->depth;

	mov	ecx, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [esi+100]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+108], eax
$unexpected_elem$74:
	mov	DWORD PTR [esi+176], ecx

; 26737:     vctxt->inode->flags |= XML_SCHEMA_NODE_INFO_ERR_NOT_EXPECTED;

	or	DWORD PTR [eax+32], 512			; 00000200H

; 26738:     pielem->flags |= XML_SCHEMA_ELEM_INFO_ERR_BAD_CONTENT;
; 26739:     return (ret);

	mov	eax, edi
	or	DWORD PTR [ebx+32], 256			; 00000100H
	pop	edi
	pop	esi

; 26740: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN73@xmlSchemaV:
	DD	$LN13@xmlSchemaV
	DD	$LN14@xmlSchemaV
	DD	$LN14@xmlSchemaV
	DD	$LN22@xmlSchemaV
	DD	$LN26@xmlSchemaV
	DD	$LN22@xmlSchemaV
_xmlSchemaValidateChildElem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidatorPopElem
_TEXT	SEGMENT
_values$1 = -48						; size = 40
_terminal$2 = -8					; size = 4
_inode$1$ = -4						; size = 4
_textChild$1$ = -4					; size = 4
_nbneg$3 = -4						; size = 4
tv1489 = 8						; size = 4
_msg$4 = 8						; size = 4
_msg$5 = 8						; size = 4
_normValue$1$ = 8					; size = 4
_nbval$6 = 8						; size = 4
_vctxt$ = 8						; size = 4
_xmlSchemaValidatorPopElem PROC				; COMDAT

; 26053: {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	ebx
	push	esi
	mov	esi, DWORD PTR _vctxt$[ebp]
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR [esi+108]
	xor	ebx, ebx
	cmp	DWORD PTR [esi+168], ebx
	je	SHORT $LN5@xmlSchemaV

; 26054:     int ret = 0;
; 26055:     xmlSchemaNodeInfoPtr inode = vctxt->inode;
; 26056: 
; 26057:     if (vctxt->nbAttrInfos != 0)
; 26058: 	xmlSchemaClearAttrInfos(vctxt);

	push	esi
	call	_xmlSchemaClearAttrInfos
	add	esp, 4
$LN5@xmlSchemaV:

; 26059:     if (inode->flags & XML_SCHEMA_NODE_INFO_ERR_NOT_EXPECTED) {

	mov	eax, DWORD PTR [edi+32]
	test	eax, 512				; 00000200H
	je	SHORT $LN6@xmlSchemaV

; 26060: 	/*
; 26061: 	* This element was not expected;
; 26062: 	* we will not validate child elements of broken parents.
; 26063: 	* Skip validation of all content of the parent.
; 26064: 	*/
; 26065: 	vctxt->skipDepth = vctxt->depth -1;

	mov	eax, DWORD PTR [esi+96]
	dec	eax
	mov	DWORD PTR [esi+176], eax

; 26066: 	goto end_elem;

	jmp	$end_elem$135
$LN6@xmlSchemaV:

; 26067:     }
; 26068:     if ((inode->typeDef == NULL) ||

	mov	edx, DWORD PTR [edi+28]
	test	edx, edx
	je	$end_elem$135
	test	eax, 1024				; 00000400H
	jne	$end_elem$135

; 26069: 	(inode->flags & XML_SCHEMA_NODE_INFO_ERR_BAD_TYPE)) {
; 26070: 	/*
; 26071: 	* 1. the type definition might be missing if the element was
; 26072: 	*    error prone
; 26073: 	* 2. it might be abstract.
; 26074: 	*/
; 26075: 	goto end_elem;
; 26076:     }
; 26077:     /*
; 26078:     * Check the content model.
; 26079:     */
; 26080:     if ((inode->typeDef->contentType == XML_SCHEMA_CONTENT_MIXED) ||

	mov	ecx, DWORD PTR [edx+52]
	cmp	ecx, 3
	je	SHORT $LN10@xmlSchemaV
	cmp	ecx, 2
	jne	$skip_nilled$136
$LN10@xmlSchemaV:

; 26081: 	(inode->typeDef->contentType == XML_SCHEMA_CONTENT_ELEMENTS)) {
; 26082: 
; 26083: 	/*
; 26084: 	* Workaround for "anyType".
; 26085: 	*/
; 26086: 	if (inode->typeDef->builtInType == XML_SCHEMAS_ANYTYPE)

	cmp	DWORD PTR [edx+88], 45			; 0000002dH
	je	$character_content$137

; 26087: 	    goto character_content;
; 26088: 
; 26089: 	if ((inode->flags & XML_SCHEMA_ELEM_INFO_ERR_BAD_CONTENT) == 0) {

	test	eax, 256				; 00000100H
	jne	$skip_nilled$136

; 26090: 	    xmlChar *values[10];
; 26091: 	    int terminal, nbval = 10, nbneg;
; 26092: 
; 26093: 	    if (inode->regexCtxt == NULL) {

	mov	ecx, DWORD PTR [edi+60]
	mov	DWORD PTR _nbval$6[ebp], 10		; 0000000aH
	test	ecx, ecx
	jne	SHORT $LN14@xmlSchemaV

; 26094: 		/*
; 26095: 		* Create the regex context.
; 26096: 		*/
; 26097: 		inode->regexCtxt =

	push	esi
	push	OFFSET _xmlSchemaVContentModelCallback
	push	DWORD PTR [edx+108]
	call	_xmlRegNewExecCtxt
	mov	ecx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+60], ecx

; 26098: 		    xmlRegNewExecCtxt(inode->typeDef->contModel,
; 26099: 		    xmlSchemaVContentModelCallback, vctxt);
; 26100: 		if (inode->regexCtxt == NULL) {

	test	ecx, ecx
	jne	SHORT $LN112@xmlSchemaV

; 26101: 		    VERROR_INT("xmlSchemaValidatorPopElem",

	push	OFFSET ??_C@_0CB@GNCACIIF@failed?5to?5create?5a?5regex?5contex@
	push	OFFSET ??_C@_0BK@CPCENKBJ@xmlSchemaValidatorPopElem@
	push	esi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH

; 26511: 
; 26512: internal_error:
; 26513:     vctxt->err = -1;

	mov	DWORD PTR [esi+52], -1

; 26514:     return (-1);

	or	eax, -1
	pop	edi

; 26515: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN112@xmlSchemaV:
	mov	eax, DWORD PTR [edi+32]
$LN14@xmlSchemaV:

; 26102: 			"failed to create a regex context");
; 26103: 		    goto internal_error;
; 26104: 		}
; 26105: #ifdef DEBUG_AUTOMATA
; 26106: 		xmlGenericError(xmlGenericErrorContext,
; 26107: 		    "AUTOMATON create on '%s'\n", inode->localName);
; 26108: #endif
; 26109: 	    }
; 26110: 
; 26111: 	    /*
; 26112: 	     * Do not check further content if the node has been nilled
; 26113: 	     */
; 26114: 	    if (INODE_NILLED(inode)) {

	test	al, 4
	je	SHORT $LN15@xmlSchemaV

; 26115: 		ret = 0;

	xor	ebx, ebx

; 26116: #ifdef DEBUG_AUTOMATA
; 26117: 		xmlGenericError(xmlGenericErrorContext,
; 26118: 		    "AUTOMATON succeeded on nilled '%s'\n",
; 26119: 		    inode->localName);
; 26120: #endif
; 26121:                 goto skip_nilled;

	jmp	SHORT $skip_nilled$136
$LN15@xmlSchemaV:

; 26122: 	    }
; 26123: 
; 26124: 	    /*
; 26125: 	    * Get hold of the still expected content, since a further
; 26126: 	    * call to xmlRegExecPushString() will lose this information.
; 26127: 	    */
; 26128: 	    xmlRegExecNextValues(inode->regexCtxt,

	lea	eax, DWORD PTR _terminal$2[ebp]
	push	eax
	lea	eax, DWORD PTR _values$1[ebp]
	push	eax
	lea	eax, DWORD PTR _nbneg$3[ebp]
	push	eax
	lea	eax, DWORD PTR _nbval$6[ebp]
	push	eax
	push	ecx
	call	_xmlRegExecNextValues

; 26129: 		&nbval, &nbneg, &values[0], &terminal);
; 26130: 	    ret = xmlRegExecPushString(inode->regexCtxt, NULL, NULL);

	push	0
	push	0
	push	DWORD PTR [edi+60]
	call	_xmlRegExecPushString
	add	esp, 32					; 00000020H

; 26131: 	    if ((ret<0) || ((ret==0) && (!INODE_NILLED(inode)))) {

	test	eax, eax
	js	SHORT $LN120@xmlSchemaV
	jne	SHORT $LN121@xmlSchemaV
	test	BYTE PTR [edi+32], 4
	je	SHORT $LN120@xmlSchemaV
$LN121@xmlSchemaV:

; 26139: 		    XML_SCHEMAV_ELEMENT_CONTENT, NULL, NULL,
; 26140: 		    "Missing child element(s)",
; 26141: 		    nbval, nbneg, values);
; 26142: #ifdef DEBUG_AUTOMATA
; 26143: 		xmlGenericError(xmlGenericErrorContext,
; 26144: 		    "AUTOMATON missing ERROR on '%s'\n",
; 26145: 		    inode->localName);
; 26146: #endif
; 26147: 	    } else {
; 26148: 		/*
; 26149: 		* Content model is satisfied.
; 26150: 		*/
; 26151: 		ret = 0;

	xor	ebx, ebx
	jmp	SHORT $skip_nilled$136
$LN120@xmlSchemaV:

; 26132: 		/*
; 26133: 		* Still missing something.
; 26134: 		*/
; 26135: 		ret = 1;
; 26136: 		inode->flags |=

	or	DWORD PTR [edi+32], 256			; 00000100H

; 26137: 		    XML_SCHEMA_ELEM_INFO_ERR_BAD_CONTENT;
; 26138: 		xmlSchemaComplexTypeErr(ACTXT_CAST vctxt,

	lea	eax, DWORD PTR _values$1[ebp]
	push	eax
	push	DWORD PTR _nbneg$3[ebp]
	mov	ebx, 1
	push	DWORD PTR _nbval$6[ebp]
	push	OFFSET ??_C@_0BJ@GMMIGBBG@Missing?5child?5element?$CIs?$CJ@
	push	0
	push	0
	push	1871					; 0000074fH
	push	esi
	call	_xmlSchemaComplexTypeErr
	add	esp, 32					; 00000020H
$skip_nilled$136:

; 26152: #ifdef DEBUG_AUTOMATA
; 26153: 		xmlGenericError(xmlGenericErrorContext,
; 26154: 		    "AUTOMATON succeeded on '%s'\n",
; 26155: 		    inode->localName);
; 26156: #endif
; 26157: 	    }
; 26158: 
; 26159: 	}
; 26160:     }
; 26161: 
; 26162: skip_nilled:
; 26163: 
; 26164:     if (inode->typeDef->contentType == XML_SCHEMA_CONTENT_ELEMENTS)

	mov	eax, DWORD PTR [edi+28]
	cmp	DWORD PTR [eax+52], 2
	je	$end_elem$135
$character_content$137:

; 26165: 	goto end_elem;
; 26166: 
; 26167: character_content:
; 26168: 
; 26169:     if (vctxt->value != NULL) {

	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	je	SHORT $LN20@xmlSchemaV

; 26170: 	xmlSchemaFreeValue(vctxt->value);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4

; 26171: 	vctxt->value = NULL;

	mov	DWORD PTR [esi+72], 0
$LN20@xmlSchemaV:

; 26172:     }
; 26173:     /*
; 26174:     * Check character content.
; 26175:     */
; 26176:     if (inode->decl == NULL) {

	mov	eax, DWORD PTR [edi+44]
	test	eax, eax
	jne	SHORT $LN21@xmlSchemaV

; 26177: 	/*
; 26178: 	* Speedup if no declaration exists.
; 26179: 	*/
; 26180: 	if (WXS_IS_SIMPLE(inode->typeDef)) {

	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	SHORT $LN24@xmlSchemaV
	cmp	ecx, 1
	jne	SHORT $LN22@xmlSchemaV
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	jne	SHORT $LN24@xmlSchemaV
$LN22@xmlSchemaV:

; 26182: 		inode, inode->typeDef, inode->value);
; 26183: 	} else if (WXS_HAS_SIMPLE_CONTENT(inode->typeDef)) {

	mov	ecx, DWORD PTR [eax+52]
	cmp	ecx, 4
	je	SHORT $LN26@xmlSchemaV
	cmp	ecx, 6
	jne	$LN25@xmlSchemaV
$LN26@xmlSchemaV:

; 26184: 	    ret = xmlSchemaVCheckINodeDataType(vctxt,

	push	DWORD PTR [edi+20]
	push	DWORD PTR [eax+104]

; 26185: 		inode, inode->typeDef->contentTypeDef,
; 26186: 		inode->value);
; 26187: 	}
; 26188: 	if (ret < 0) {

	push	edi
	push	esi
	call	_xmlSchemaVCheckINodeDataType
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 26494: 		/*
; 26495: 		* A 'keyrefDepth' of a key/unique IDC matches the current
; 26496: 		* depth, this means that we are leaving the scope of the
; 26497: 		* top-most keyref IDC which refers to this IDC.
; 26498: 		*/
; 26499: 		aidc->keyrefDepth = -1;

	jmp	$LN25@xmlSchemaV
$LN24@xmlSchemaV:

; 26181: 	    ret = xmlSchemaVCheckINodeDataType(vctxt,

	push	DWORD PTR [edi+20]
	push	eax

; 26185: 		inode, inode->typeDef->contentTypeDef,
; 26186: 		inode->value);
; 26187: 	}
; 26188: 	if (ret < 0) {

	push	edi
	push	esi
	call	_xmlSchemaVCheckINodeDataType
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 26494: 		/*
; 26495: 		* A 'keyrefDepth' of a key/unique IDC matches the current
; 26496: 		* depth, this means that we are leaving the scope of the
; 26497: 		* top-most keyref IDC which refers to this IDC.
; 26498: 		*/
; 26499: 		aidc->keyrefDepth = -1;

	jmp	$LN25@xmlSchemaV
$LN21@xmlSchemaV:

; 26189: 	    VERROR_INT("xmlSchemaValidatorPopElem",
; 26190: 		"calling xmlSchemaVCheckCVCSimpleType()");
; 26191: 	    goto internal_error;
; 26192: 	}
; 26193: 	goto end_elem;
; 26194:     }
; 26195:     /*
; 26196:     * cvc-elt (3.3.4) : 5
; 26197:     * The appropriate case among the following must be true:
; 26198:     */
; 26199:     /*
; 26200:     * cvc-elt (3.3.4) : 5.1
; 26201:     * If the declaration has a {value constraint},
; 26202:     * the item has neither element nor character [children] and
; 26203:     * clause 3.2 has not applied, then all of the following must be true:
; 26204:     */
; 26205:     if ((inode->decl->value != NULL) &&
; 26206: 	(inode->flags & XML_SCHEMA_ELEM_INFO_EMPTY) &&

	mov	edx, DWORD PTR [eax+76]
	mov	DWORD PTR tv1489[ebp], edx
	test	edx, edx
	je	$LN122@xmlSchemaV
	mov	ecx, DWORD PTR [edi+32]
	mov	eax, ecx
	and	al, 36					; 00000024H
	cmp	al, 32					; 00000020H
	jne	$LN122@xmlSchemaV

; 26207: 	(! INODE_NILLED(inode))) {
; 26208: 	/*
; 26209: 	* cvc-elt (3.3.4) : 5.1.1
; 26210: 	* If the `actual type definition` is a `local type definition`
; 26211: 	* then the canonical lexical representation of the {value constraint}
; 26212: 	* value must be a valid default for the `actual type definition` as
; 26213: 	* defined in Element Default Valid (Immediate) ($3.3.6).
; 26214: 	*/
; 26215: 	/*
; 26216: 	* NOTE: 'local' above means types acquired by xsi:type.
; 26217: 	* NOTE: Although the *canonical* value is stated, it is not
; 26218: 	* relevant if canonical or not. Additionally XML Schema 1.1
; 26219: 	* will removed this requirement as well.
; 26220: 	*/
; 26221: 	if (inode->flags & XML_SCHEMA_ELEM_INFO_LOCAL_TYPE) {

	test	cl, 8
	je	$LN30@xmlSchemaV

; 25930:     xmlSchemaNodeInfoPtr inode = vctxt->inode;

	mov	eax, DWORD PTR [esi+108]
	xor	ebx, ebx
	mov	DWORD PTR _inode$1$[ebp], eax

; 25931: 
; 25932:     /*
; 25933:     * cos-valid-default:
; 25934:     * Schema Component Constraint: Element Default Valid (Immediate)
; 25935:     * For a string to be a valid default with respect to a type
; 25936:     * definition the appropriate case among the following must be true:
; 25937:     */
; 25938:     if WXS_IS_COMPLEX(inode->typeDef) {

	mov	eax, DWORD PTR [eax+28]
	cmp	DWORD PTR [eax], 5
	je	SHORT $LN80@xmlSchemaV
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	jne	$LN81@xmlSchemaV
$LN80@xmlSchemaV:

; 25939: 	/*
; 25940: 	* Complex type.
; 25941: 	*
; 25942: 	* SPEC (2.1) "its {content type} must be a simple type definition
; 25943: 	* or mixed."
; 25944: 	* SPEC (2.2.2) "If the {content type} is mixed, then the {content
; 25945: 	* type}'s particle must be `emptiable` as defined by
; 25946: 	* Particle Emptiable ($3.9.6)."
; 25947: 	*/
; 25948: 	if ((! WXS_HAS_SIMPLE_CONTENT(inode->typeDef)) &&

	mov	ecx, DWORD PTR [eax+52]
	cmp	ecx, 4
	je	$LN81@xmlSchemaV
	cmp	ecx, 6
	je	SHORT $LN81@xmlSchemaV
	cmp	ecx, 3
	jne	SHORT $LN82@xmlSchemaV
	push	DWORD PTR [eax+28]
	call	_xmlSchemaIsParticleEmptiable
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN126@xmlSchemaV
$LN82@xmlSchemaV:

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$5[ebp]
	mov	DWORD PTR _msg$5[ebp], ebx
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0JO@LAEFOCFG@For?5a?5string?5to?5be?5a?5valid?5defa@
	push	DWORD PTR _msg$5[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$5[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	3059					; 00000bf3H
	push	2
	push	esi

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$5[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$5[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 68					; 00000044H

; 2352 :     FREE_AND_NULL(msg)

	test	eax, eax
	je	SHORT $LN95@xmlSchemaV
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN95@xmlSchemaV:

; 25957: 	    return(ret);

	mov	ebx, 3059				; 00000bf3H
	jmp	$end_elem$135
$LN126@xmlSchemaV:

; 25939: 	/*
; 25940: 	* Complex type.
; 25941: 	*
; 25942: 	* SPEC (2.1) "its {content type} must be a simple type definition
; 25943: 	* or mixed."
; 25944: 	* SPEC (2.2.2) "If the {content type} is mixed, then the {content
; 25945: 	* type}'s particle must be `emptiable` as defined by
; 25946: 	* Particle Emptiable ($3.9.6)."
; 25947: 	*/
; 25948: 	if ((! WXS_HAS_SIMPLE_CONTENT(inode->typeDef)) &&

	mov	edx, DWORD PTR tv1489[ebp]
$LN81@xmlSchemaV:

; 25958: 	}
; 25959:     }
; 25960:     /*
; 25961:     * 1 If the type definition is a simple type definition, then the string
; 25962:     * must be `valid` with respect to that definition as defined by String
; 25963:     * Valid ($3.14.4).
; 25964:     *
; 25965:     * AND
; 25966:     *
; 25967:     * 2.2.1 If the {content type} is a simple type definition, then the
; 25968:     * string must be `valid` with respect to that simple type definition
; 25969:     * as defined by String Valid ($3.14.4).
; 25970:     */
; 25971:     if (WXS_IS_SIMPLE(inode->typeDef)) {

	mov	eax, DWORD PTR _inode$1$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	SHORT $LN85@xmlSchemaV
	cmp	ecx, 1
	jne	SHORT $LN83@xmlSchemaV
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	jne	SHORT $LN85@xmlSchemaV
$LN83@xmlSchemaV:

; 25972: 
; 25973: 	ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST vctxt,
; 25974: 	    NULL, inode->typeDef, value, val, 1, 1, 0);
; 25975: 
; 25976:     } else if (WXS_HAS_SIMPLE_CONTENT(inode->typeDef)) {

	mov	ecx, DWORD PTR [eax+52]
	cmp	ecx, 4
	je	SHORT $LN87@xmlSchemaV
	cmp	ecx, 6
	jne	SHORT $LN99@xmlSchemaV
$LN87@xmlSchemaV:

; 25977: 
; 25978: 	ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST vctxt,

	mov	eax, DWORD PTR [eax+104]
$LN85@xmlSchemaV:

; 25979: 	    NULL, inode->typeDef->contentTypeDef, value, val, 1, 1, 0);
; 25980:     }
; 25981:     if (ret < 0) {

	push	0
	push	1
	push	1
	lea	ecx, DWORD PTR [edi+24]
	push	ecx
	push	edx
	push	eax
	push	0
	push	esi
	call	_xmlSchemaVCheckCVCSimpleType
	mov	ebx, eax
	add	esp, 32					; 00000020H
	test	ebx, ebx
	jns	SHORT $LN129@xmlSchemaV

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CH@HOPMNJDI@calling?5xmlSchemaVCheckCVCSimpl@
	push	OFFSET ??_C@_0BO@FJAHODBA@xmlSchemaCheckCOSValidDefault@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$LN99@xmlSchemaV:

; 26222: 
; 26223: 	    ret = xmlSchemaCheckCOSValidDefault(vctxt,
; 26224: 		inode->decl->value, &(inode->val));
; 26225: 	    if (ret != 0) {

	test	ebx, ebx
$LN129@xmlSchemaV:
	je	SHORT $default_psvi$138

; 26226: 		if (ret < 0) {

	test	ebx, ebx
	jns	$end_elem$135

; 26227: 		    VERROR_INT("xmlSchemaValidatorPopElem",

	push	OFFSET ??_C@_0CI@FBAKNAMG@calling?5xmlSchemaCheckCOSValidD@
	push	OFFSET ??_C@_0BK@CPCENKBJ@xmlSchemaValidatorPopElem@
	push	esi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH

; 26511: 
; 26512: internal_error:
; 26513:     vctxt->err = -1;

	mov	DWORD PTR [esi+52], -1

; 26514:     return (-1);

	or	eax, -1
	pop	edi

; 26515: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@xmlSchemaV:

; 26228: 			"calling xmlSchemaCheckCOSValidDefault()");
; 26229: 		    goto internal_error;
; 26230: 		}
; 26231: 		goto end_elem;
; 26232: 	    }
; 26233: 	    /*
; 26234: 	    * Stop here, to avoid redundant validation of the value
; 26235: 	    * (see following).
; 26236: 	    */
; 26237: 	    goto default_psvi;
; 26238: 	}
; 26239: 	/*
; 26240: 	* cvc-elt (3.3.4) : 5.1.2
; 26241: 	* The element information item with the canonical lexical
; 26242: 	* representation of the {value constraint} value used as its
; 26243: 	* `normalized value` must be `valid` with respect to the
; 26244: 	* `actual type definition` as defined by Element Locally Valid (Type)
; 26245: 	* ($3.3.4).
; 26246: 	*/
; 26247: 	if (WXS_IS_SIMPLE(inode->typeDef)) {

	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	SHORT $LN35@xmlSchemaV
	cmp	ecx, 1
	jne	SHORT $LN33@xmlSchemaV
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	jne	SHORT $LN35@xmlSchemaV
$LN33@xmlSchemaV:

; 26249: 		inode, inode->typeDef, inode->decl->value);
; 26250: 	} else if (WXS_HAS_SIMPLE_CONTENT(inode->typeDef)) {

	mov	ecx, DWORD PTR [eax+52]
	cmp	ecx, 4
	je	SHORT $LN37@xmlSchemaV
	cmp	ecx, 6
	jne	SHORT $LN36@xmlSchemaV
$LN37@xmlSchemaV:

; 26251: 	    ret = xmlSchemaVCheckINodeDataType(vctxt,

	push	edx
	push	DWORD PTR [eax+104]
	jmp	SHORT $LN130@xmlSchemaV
$LN35@xmlSchemaV:

; 26248: 	    ret = xmlSchemaVCheckINodeDataType(vctxt,

	push	edx
	push	eax
$LN130@xmlSchemaV:

; 26252: 		inode, inode->typeDef->contentTypeDef,
; 26253: 		inode->decl->value);
; 26254: 	}
; 26255: 	if (ret != 0) {

	push	edi
	push	esi
	call	_xmlSchemaVCheckINodeDataType
	mov	ebx, eax
	add	esp, 16					; 00000010H
$LN36@xmlSchemaV:
	test	ebx, ebx
	jne	$LN128@xmlSchemaV
$default_psvi$138:

; 26256: 	    if (ret < 0) {
; 26257: 		VERROR_INT("xmlSchemaValidatorPopElem",
; 26258: 		    "calling xmlSchemaVCheckCVCSimpleType()");
; 26259: 		goto internal_error;
; 26260: 	    }
; 26261: 	    goto end_elem;
; 26262: 	}
; 26263: 
; 26264: default_psvi:
; 26265: 	/*
; 26266: 	* PSVI: Create a text node on the instance element.
; 26267: 	*/
; 26268: 	if ((vctxt->options & XML_SCHEMA_VAL_VC_I_CREATE) &&

	test	BYTE PTR [esi+80], 1
	je	$end_elem$135
	cmp	DWORD PTR [edi+4], 0
	je	$end_elem$135

; 26269: 	    (inode->node != NULL)) {
; 26270: 	    xmlNodePtr textChild;
; 26271: 	    xmlChar *normValue;
; 26272: 	    /*
; 26273: 	    * VAL TODO: Normalize the value.
; 26274: 	    */
; 26275: 	    normValue = xmlSchemaNormalizeValue(inode->typeDef,

	mov	eax, DWORD PTR [edi+44]
	push	DWORD PTR [eax+76]
	push	DWORD PTR [edi+28]
	call	_xmlSchemaNormalizeValue
	add	esp, 8
	mov	DWORD PTR _normValue$1$[ebp], eax

; 26276: 		inode->decl->value);
; 26277: 	    if (normValue != NULL) {

	test	eax, eax
	je	SHORT $LN41@xmlSchemaV

; 26278: 		textChild = xmlNewText(BAD_CAST normValue);

	push	eax
	call	_xmlNewText

; 26279: 		xmlFree(normValue);

	push	DWORD PTR _normValue$1$[ebp]
	mov	DWORD PTR _textChild$1$[ebp], eax
	call	DWORD PTR _xmlFree

; 26280: 	    } else

	mov	eax, DWORD PTR _textChild$1$[ebp]
	add	esp, 8
	jmp	SHORT $LN42@xmlSchemaV
$LN41@xmlSchemaV:

; 26281: 		textChild = xmlNewText(inode->decl->value);

	mov	eax, DWORD PTR [edi+44]
	push	DWORD PTR [eax+76]
	call	_xmlNewText
	add	esp, 4
$LN42@xmlSchemaV:

; 26282: 	    if (textChild == NULL) {

	test	eax, eax
	jne	SHORT $LN43@xmlSchemaV

; 26283: 		VERROR_INT("xmlSchemaValidatorPopElem",

	push	OFFSET ??_C@_0BF@GPIBFAIA@calling?5xmlNewText?$CI?$CJ@
	push	OFFSET ??_C@_0BK@CPCENKBJ@xmlSchemaValidatorPopElem@
	push	esi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH

; 26511: 
; 26512: internal_error:
; 26513:     vctxt->err = -1;

	mov	DWORD PTR [esi+52], -1

; 26514:     return (-1);

	or	eax, -1
	pop	edi

; 26515: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@xmlSchemaV:

; 26284: 		    "calling xmlNewText()");
; 26285: 		goto internal_error;
; 26286: 	    } else
; 26287: 		xmlAddChild(inode->node, textChild);

	push	eax
	push	DWORD PTR [edi+4]
	call	_xmlAddChild
	add	esp, 8

; 26288: 	}

	jmp	$end_elem$135
$LN122@xmlSchemaV:

; 26289: 
; 26290:     } else if (! INODE_NILLED(inode)) {

	test	BYTE PTR [edi+32], 4
	jne	$end_elem$135

; 26291: 	/*
; 26292: 	* 5.2.1 The element information item must be `valid` with respect
; 26293: 	* to the `actual type definition` as defined by Element Locally
; 26294: 	* Valid (Type) ($3.3.4).
; 26295: 	*/
; 26296: 	if (WXS_IS_SIMPLE(inode->typeDef)) {

	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	SHORT $LN48@xmlSchemaV
	cmp	ecx, 1
	jne	SHORT $LN46@xmlSchemaV
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	jne	SHORT $LN48@xmlSchemaV
$LN46@xmlSchemaV:

; 26306: 		    inode, inode->typeDef, inode->value);
; 26307: 	} else if (WXS_HAS_SIMPLE_CONTENT(inode->typeDef)) {

	mov	ecx, DWORD PTR [eax+52]
	cmp	ecx, 4
	je	SHORT $LN50@xmlSchemaV
	cmp	ecx, 6
	jne	SHORT $LN49@xmlSchemaV
$LN50@xmlSchemaV:

; 26308: 	    /*
; 26309: 	    * SPEC (cvc-type) (3.2) "If the type definition is a complex type
; 26310: 	    * definition, then the element information item must be
; 26311: 	    * `valid` with respect to the type definition as per
; 26312: 	    * Element Locally Valid (Complex Type) ($3.4.4);"
; 26313: 	    *
; 26314: 	    * SPEC (cvc-complex-type) (2.2)
; 26315: 	    * "If the {content type} is a simple type definition, ...
; 26316: 	    * the `normalized value` of the element information item is
; 26317: 	    * `valid` with respect to that simple type definition as
; 26318: 	    * defined by String Valid ($3.14.4)."
; 26319: 	    */
; 26320: 	    ret = xmlSchemaVCheckINodeDataType(vctxt,

	push	DWORD PTR [edi+20]
	push	DWORD PTR [eax+104]
	jmp	SHORT $LN131@xmlSchemaV
$LN48@xmlSchemaV:

; 26297: 	     /*
; 26298: 	    * SPEC (cvc-type) (3.1)
; 26299: 	    * "If the type definition is a simple type definition, ..."
; 26300: 	    * (3.1.3) "If clause 3.2 of Element Locally Valid
; 26301: 	    * (Element) ($3.3.4) did not apply, then the `normalized value`
; 26302: 	    * must be `valid` with respect to the type definition as defined
; 26303: 	    * by String Valid ($3.14.4).
; 26304: 	    */
; 26305: 	    ret = xmlSchemaVCheckINodeDataType(vctxt,

	push	DWORD PTR [edi+20]
	push	eax
$LN131@xmlSchemaV:

; 26321: 		inode, inode->typeDef->contentTypeDef, inode->value);
; 26322: 	}
; 26323: 	if (ret != 0) {

	push	edi
	push	esi
	call	_xmlSchemaVCheckINodeDataType
	mov	ebx, eax
	add	esp, 16					; 00000010H
$LN49@xmlSchemaV:
	test	ebx, ebx
	je	SHORT $LN51@xmlSchemaV
$LN25@xmlSchemaV:

; 26324: 	    if (ret < 0) {
; 26325: 		VERROR_INT("xmlSchemaValidatorPopElem",

	test	ebx, ebx
$LN128@xmlSchemaV:
	jns	$end_elem$135
	push	OFFSET ??_C@_0CH@HOPMNJDI@calling?5xmlSchemaVCheckCVCSimpl@
	push	OFFSET ??_C@_0BK@CPCENKBJ@xmlSchemaValidatorPopElem@
	push	esi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH

; 26511: 
; 26512: internal_error:
; 26513:     vctxt->err = -1;

	mov	DWORD PTR [esi+52], -1

; 26514:     return (-1);

	or	eax, -1
	pop	edi

; 26515: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@xmlSchemaV:

; 26326: 		    "calling xmlSchemaVCheckCVCSimpleType()");
; 26327: 		goto internal_error;
; 26328: 	    }
; 26329: 	    goto end_elem;
; 26330: 	}
; 26331: 	/*
; 26332: 	* 5.2.2 If there is a fixed {value constraint} and clause 3.2 has
; 26333: 	* not applied, all of the following must be true:
; 26334: 	*/
; 26335: 	if ((inode->decl->value != NULL) &&

	mov	eax, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR [eax+76]
	test	ecx, ecx
	je	$end_elem$135
	test	BYTE PTR [eax+48], 8
	je	$end_elem$135

; 26336: 	    (inode->decl->flags & XML_SCHEMAS_ELEM_FIXED)) {
; 26337: 
; 26338: 	    /*
; 26339: 	    * TODO: We will need a computed value, when comparison is
; 26340: 	    * done on computed values.
; 26341: 	    */
; 26342: 	    /*
; 26343: 	    * 5.2.2.1 The element information item must have no element
; 26344: 	    * information item [children].
; 26345: 	    */
; 26346: 	    if (inode->flags &

	test	BYTE PTR [edi+32], 128			; 00000080H
	je	SHORT $LN54@xmlSchemaV

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$4[ebp]
	mov	DWORD PTR _msg$4[ebp], 0
	push	esi
	push	eax

; 26347: 		    XML_SCHEMA_ELEM_INFO_HAS_ELEM_CONTENT) {
; 26348: 		ret = XML_SCHEMAV_CVC_ELT_5_2_2_1;

	mov	ebx, 1856				; 00000740H

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0FE@OJCHDPJF@The?5content?5must?5not?5containt?5e@
	push	DWORD PTR _msg$4[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$4[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	ebx
	push	2
	push	esi

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$4[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$4[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 68					; 00000044H

; 2352 :     FREE_AND_NULL(msg)

	test	eax, eax
	je	SHORT $end_elem$135
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 26349: 		VERROR(ret, NULL,
; 26350: 		    "The content must not containt element nodes since "
; 26351: 		    "there is a fixed value constraint");
; 26352: 		goto end_elem;

	jmp	SHORT $end_elem$135
$LN54@xmlSchemaV:

; 26353: 	    } else {
; 26354: 		/*
; 26355: 		* 5.2.2.2 The appropriate case among the following must
; 26356: 		* be true:
; 26357: 		*/
; 26358: 		if (WXS_HAS_MIXED_CONTENT(inode->typeDef)) {

	mov	eax, DWORD PTR [edi+28]
	mov	eax, DWORD PTR [eax+52]
	cmp	eax, 3
	jne	SHORT $LN56@xmlSchemaV

; 26359: 		    /*
; 26360: 		    * 5.2.2.2.1 If the {content type} of the `actual type
; 26361: 		    * definition` is mixed, then the *initial value* of the
; 26362: 		    * item must match the canonical lexical representation
; 26363: 		    * of the {value constraint} value.
; 26364: 		    *
; 26365: 		    * ... the *initial value* of an element information
; 26366: 		    * item is the string composed of, in order, the
; 26367: 		    * [character code] of each character information item in
; 26368: 		    * the [children] of that element information item.
; 26369: 		    */
; 26370: 		    if (! xmlStrEqual(inode->value, inode->decl->value)){

	push	ecx
	push	DWORD PTR [edi+20]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $end_elem$135

; 26371: 			/*
; 26372: 			* VAL TODO: Report invalid & expected values as well.
; 26373: 			* VAL TODO: Implement the canonical stuff.
; 26374: 			*/
; 26375: 			ret = XML_SCHEMAV_CVC_ELT_5_2_2_2_1;
; 26376: 			xmlSchemaCustomErr(ACTXT_CAST vctxt,

	mov	eax, DWORD PTR [edi+44]
	mov	ebx, 1857				; 00000741H
	push	DWORD PTR [eax+76]
	push	DWORD PTR [edi+20]
	push	OFFSET ??_C@_0EG@LHINEJAD@The?5initial?5value?5?8?$CFs?8?5does?5not@
	push	0
	push	0
	push	ebx

; 26377: 			    ret, NULL, NULL,
; 26378: 			    "The initial value '%s' does not match the fixed "
; 26379: 			    "value constraint '%s'",
; 26380: 			    inode->value, inode->decl->value);
; 26381: 			goto end_elem;

	jmp	SHORT $LN132@xmlSchemaV
$LN56@xmlSchemaV:

; 26382: 		    }
; 26383: 		} else if (WXS_HAS_SIMPLE_CONTENT(inode->typeDef)) {

	cmp	eax, 4
	je	SHORT $LN60@xmlSchemaV
	cmp	eax, 6
	jne	SHORT $end_elem$135
$LN60@xmlSchemaV:

; 26384: 		    /*
; 26385: 		    * 5.2.2.2.2 If the {content type} of the `actual type
; 26386: 		    * definition` is a simple type definition, then the
; 26387: 		    * *actual value* of the item must match the canonical
; 26388: 		    * lexical representation of the {value constraint} value.
; 26389: 		    */
; 26390: 		    /*
; 26391: 		    * VAL TODO: *actual value* is the normalized value, impl.
; 26392: 		    *           this.
; 26393: 		    * VAL TODO: Report invalid & expected values as well.
; 26394: 		    * VAL TODO: Implement a comparison with the computed values.
; 26395: 		    */
; 26396: 		    if (! xmlStrEqual(inode->value,

	push	ecx
	push	DWORD PTR [edi+20]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $end_elem$135

; 26397: 			    inode->decl->value)) {
; 26398: 			ret = XML_SCHEMAV_CVC_ELT_5_2_2_2_2;
; 26399: 			xmlSchemaCustomErr(ACTXT_CAST vctxt,

	mov	eax, DWORD PTR [edi+44]
	mov	ebx, 1858				; 00000742H
	push	DWORD PTR [eax+76]
	push	DWORD PTR [edi+20]
	push	OFFSET ??_C@_0EF@OEHLJDGK@The?5actual?5value?5?8?$CFs?8?5does?5not?5@
	push	0
	push	0
	push	ebx
$LN132@xmlSchemaV:

; 26400: 			    ret, NULL, NULL,
; 26401: 			    "The actual value '%s' does not match the fixed "
; 26402: 			    "value constraint '%s'",
; 26403: 			    inode->value,
; 26404: 			    inode->decl->value);
; 26405: 			goto end_elem;
; 26406: 		    }
; 26407: 		}
; 26408: 	    }
; 26409: 	}
; 26410:     }
; 26411: 
; 26412: end_elem:
; 26413:     if (vctxt->depth < 0) {

	push	esi
	call	_xmlSchemaCustomErr
	add	esp, 28					; 0000001cH
$end_elem$135:
	mov	eax, DWORD PTR [esi+96]
	test	eax, eax
	js	$LN133@xmlSchemaV

; 26414: 	/* TODO: raise error? */
; 26415: 	return (0);
; 26416:     }
; 26417:     if (vctxt->depth == vctxt->skipDepth)

	cmp	eax, DWORD PTR [esi+176]
	jne	SHORT $LN63@xmlSchemaV

; 26418: 	vctxt->skipDepth = -1;

	mov	DWORD PTR [esi+176], -1
$LN63@xmlSchemaV:

; 26419:     /*
; 26420:     * Evaluate the history of XPath state objects.
; 26421:     */
; 26422:     if (inode->appliedXPath &&

	cmp	DWORD PTR [edi+80], 0
	je	SHORT $LN64@xmlSchemaV
	push	eax
	push	esi
	call	_xmlSchemaXPathProcessHistory
	add	esp, 8
	cmp	eax, -1
	je	SHORT $internal_error$139
$LN64@xmlSchemaV:

; 26423: 	(xmlSchemaXPathProcessHistory(vctxt, vctxt->depth) == -1))
; 26424: 	goto internal_error;
; 26425:     /*
; 26426:     * MAYBE TODO:
; 26427:     * SPEC (6) "The element information item must be `valid` with
; 26428:     * respect to each of the {identity-constraint definitions} as per
; 26429:     * Identity-constraint Satisfied ($3.11.4)."
; 26430:     */
; 26431:     /*
; 26432:     * PSVI TODO: If we expose IDC node-tables via PSVI then the tables
; 26433:     *   need to be built in any case.
; 26434:     *   We will currently build IDC node-tables and bubble them only if
; 26435:     *   keyrefs do exist.
; 26436:     */
; 26437: 
; 26438:     /*
; 26439:     * Add the current IDC target-nodes to the IDC node-tables.
; 26440:     */
; 26441:     if ((inode->idcMatchers != NULL) &&

	cmp	DWORD PTR [edi+56], 0
	je	SHORT $LN67@xmlSchemaV
	cmp	DWORD PTR [esi+184], 0
	jne	SHORT $LN123@xmlSchemaV
	cmp	DWORD PTR [esi+188], 0
	je	SHORT $LN67@xmlSchemaV
$LN123@xmlSchemaV:

; 26442: 	(vctxt->hasKeyrefs || vctxt->createIDCNodeTables))
; 26443:     {
; 26444: 	if (xmlSchemaIDCFillNodeTables(vctxt, inode) == -1)

	push	edi
	push	esi
	call	_xmlSchemaIDCFillNodeTables
	add	esp, 8
	cmp	eax, -1
	je	SHORT $internal_error$139
$LN67@xmlSchemaV:

; 26445: 	    goto internal_error;
; 26446:     }
; 26447:     /*
; 26448:     * Validate IDC keyrefs.
; 26449:     */
; 26450:     if (vctxt->inode->hasKeyrefs)

	mov	eax, DWORD PTR [esi+108]
	cmp	DWORD PTR [eax+76], 0
	je	SHORT $LN69@xmlSchemaV

; 26451: 	if (xmlSchemaCheckCVCIDCKeyRef(vctxt) == -1)

	push	esi
	call	_xmlSchemaCheckCVCIDCKeyRef
	add	esp, 4
	cmp	eax, -1
	je	SHORT $internal_error$139
$LN69@xmlSchemaV:

; 26452: 	    goto internal_error;
; 26453:     /*
; 26454:     * Merge/free the IDC table.
; 26455:     */
; 26456:     if (inode->idcTable != NULL) {

	cmp	DWORD PTR [edi+52], 0
	je	SHORT $LN73@xmlSchemaV

; 26457: #ifdef DEBUG_IDC_NODE_TABLE
; 26458: 	xmlSchemaDebugDumpIDCTable(stdout,
; 26459: 	    inode->nsName,
; 26460: 	    inode->localName,
; 26461: 	    inode->idcTable);
; 26462: #endif
; 26463: 	if ((vctxt->depth > 0) &&

	cmp	DWORD PTR [esi+96], 0
	jle	SHORT $LN73@xmlSchemaV
	cmp	DWORD PTR [esi+184], 0
	jne	SHORT $LN72@xmlSchemaV
	cmp	DWORD PTR [esi+188], 0
	je	SHORT $LN73@xmlSchemaV
$LN72@xmlSchemaV:

; 26464: 	    (vctxt->hasKeyrefs || vctxt->createIDCNodeTables))
; 26465: 	{
; 26466: 	    /*
; 26467: 	    * Merge the IDC node table with the table of the parent node.
; 26468: 	    */
; 26469: 	    if (xmlSchemaBubbleIDCNodeTables(vctxt) == -1)

	push	esi
	call	_xmlSchemaBubbleIDCNodeTables
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN73@xmlSchemaV
$internal_error$139:
	pop	edi

; 26511: 
; 26512: internal_error:
; 26513:     vctxt->err = -1;

	mov	DWORD PTR [esi+52], -1

; 26514:     return (-1);

	or	eax, -1

; 26515: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN73@xmlSchemaV:

; 26470: 		goto internal_error;
; 26471: 	}
; 26472:     }
; 26473:     /*
; 26474:     * Clear the current ielem.
; 26475:     * VAL TODO: Don't free the PSVI IDC tables if they are
; 26476:     * requested for the PSVI.
; 26477:     */
; 26478:     xmlSchemaClearElemInfo(vctxt, inode);

	push	edi
	push	esi
	call	_xmlSchemaClearElemInfo

; 26479:     /*
; 26480:     * Skip further processing if we are on the validation root.
; 26481:     */
; 26482:     if (vctxt->depth == 0) {

	mov	eax, DWORD PTR [esi+96]
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN74@xmlSchemaV

; 26483: 	vctxt->depth--;

	mov	DWORD PTR [esi+96], -1

; 26484: 	vctxt->inode = NULL;

	mov	DWORD PTR [esi+108], eax
$LN133@xmlSchemaV:

; 26515: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@xmlSchemaV:

; 26485: 	return (0);
; 26486:     }
; 26487:     /*
; 26488:     * Reset the keyrefDepth if needed.
; 26489:     */
; 26490:     if (vctxt->aidcs != NULL) {

	mov	ecx, DWORD PTR [esi+112]
	test	ecx, ecx
	je	SHORT $LN3@xmlSchemaV
$LL4@xmlSchemaV:

; 26491: 	xmlSchemaIDCAugPtr aidc = vctxt->aidcs;
; 26492: 	do {
; 26493: 	    if (aidc->keyrefDepth == vctxt->depth) {

	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [esi+96]
	jne	SHORT $LN124@xmlSchemaV

; 26494: 		/*
; 26495: 		* A 'keyrefDepth' of a key/unique IDC matches the current
; 26496: 		* depth, this means that we are leaving the scope of the
; 26497: 		* top-most keyref IDC which refers to this IDC.
; 26498: 		*/
; 26499: 		aidc->keyrefDepth = -1;

	mov	DWORD PTR [ecx+8], -1
$LN124@xmlSchemaV:

; 26500: 	    }
; 26501: 	    aidc = aidc->next;

	mov	ecx, DWORD PTR [ecx]

; 26502: 	} while (aidc != NULL);

	test	ecx, ecx
	jne	SHORT $LL4@xmlSchemaV

; 26494: 		/*
; 26495: 		* A 'keyrefDepth' of a key/unique IDC matches the current
; 26496: 		* depth, this means that we are leaving the scope of the
; 26497: 		* top-most keyref IDC which refers to this IDC.
; 26498: 		*/
; 26499: 		aidc->keyrefDepth = -1;

	mov	eax, DWORD PTR [esi+96]
$LN3@xmlSchemaV:

; 26503:     }
; 26504:     vctxt->depth--;

	lea	ecx, DWORD PTR [eax-1]

; 26505:     vctxt->inode = vctxt->elemInfos[vctxt->depth];

	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR [esi+96], ecx
	pop	edi
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+108], eax

; 26506:     /*
; 26507:     * VAL TODO: 7 If the element information item is the `validation root`, it must be
; 26508:     * `valid` per Validation Root Valid (ID/IDREF) ($3.3.4).
; 26509:     */
; 26510:     return (ret);

	mov	eax, ebx

; 26515: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaValidatorPopElem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaVCheckINodeDataType
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_inode$ = 12						; size = 4
_type$ = 16						; size = 4
_value$ = 20						; size = 4
_xmlSchemaVCheckINodeDataType PROC			; COMDAT

; 26035: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _inode$[ebp]
	push	0
	test	BYTE PTR [eax+32], 16			; 00000010H
	je	SHORT $LN2@xmlSchemaV

; 26036:     if (inode->flags & XML_SCHEMA_NODE_INFO_VALUE_NEEDED)
; 26037: 	return (xmlSchemaVCheckCVCSimpleType(

	push	1
	push	1
	add	eax, 24					; 00000018H
	push	eax
	jmp	SHORT $LN5@xmlSchemaV
$LN2@xmlSchemaV:

; 26038: 	    ACTXT_CAST vctxt, NULL,
; 26039: 	    type, value, &(inode->val), 1, 1, 0));
; 26040:     else
; 26041: 	return (xmlSchemaVCheckCVCSimpleType(

	push	0
	push	1
	push	0
$LN5@xmlSchemaV:

; 26042: 	    ACTXT_CAST vctxt, NULL,
; 26043: 	    type, value, NULL, 1, 0, 0));
; 26044: }

	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _type$[ebp]
	push	0
	push	DWORD PTR _vctxt$[ebp]
	call	_xmlSchemaVCheckCVCSimpleType
	add	esp, 32					; 00000020H
	pop	ebp
	ret	0
_xmlSchemaVCheckINodeDataType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidatorPushElem
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_xmlSchemaValidatorPushElem PROC			; COMDAT

; 26019: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _vctxt$[ebp]
	push	esi
	call	_xmlSchemaGetFreshElemInfo
	add	esp, 4
	mov	DWORD PTR [esi+108], eax
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaV

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	eax
	push	eax
	push	OFFSET ??_C@_0CE@ILDABLF@calling?5xmlSchemaGetFreshElemIn@
	push	OFFSET ??_C@_0BL@GMHMOLCB@xmlSchemaValidatorPushElem@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 26020:     vctxt->inode = xmlSchemaGetFreshElemInfo(vctxt);
; 26021:     if (vctxt->inode == NULL) {
; 26022: 	VERROR_INT("xmlSchemaValidatorPushElem",
; 26023: 	    "calling xmlSchemaGetFreshElemInfo()");
; 26024: 	return (-1);

	or	eax, -1
	pop	esi

; 26028: }

	pop	ebp
	ret	0
$LN2@xmlSchemaV:

; 26025:     }
; 26026:     vctxt->nbAttrInfos = 0;

	mov	DWORD PTR [esi+168], 0

; 26027:     return (0);

	xor	eax, eax
	pop	esi

; 26028: }

	pop	ebp
	ret	0
_xmlSchemaValidatorPushElem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaVContentModelCallback
_TEXT	SEGMENT
_exec$ = 8						; size = 4
_name$ = 12						; size = 4
_transdata$ = 16					; size = 4
_inputdata$ = 20					; size = 4
_xmlSchemaVContentModelCallback PROC			; COMDAT

; 25992: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _inputdata$[ebp]
	mov	eax, DWORD PTR _transdata$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 25993:     xmlSchemaElementPtr item = (xmlSchemaElementPtr) transdata;
; 25994:     xmlSchemaNodeInfoPtr inode = (xmlSchemaNodeInfoPtr) inputdata;
; 25995:     inode->decl = item;
; 25996: #ifdef DEBUG_CONTENT
; 25997:     {
; 25998: 	xmlChar *str = NULL;
; 25999: 
; 26000: 	if (item->type == XML_SCHEMA_TYPE_ELEMENT) {
; 26001: 	    xmlGenericError(xmlGenericErrorContext,
; 26002: 		"AUTOMATON callback for '%s' [declaration]\n",
; 26003: 		xmlSchemaFormatQName(&str,
; 26004: 		inode->localName, inode->nsName));
; 26005: 	} else {
; 26006: 	    xmlGenericError(xmlGenericErrorContext,
; 26007: 		    "AUTOMATON callback for '%s' [wildcard]\n",
; 26008: 		    xmlSchemaFormatQName(&str,
; 26009: 		    inode->localName, inode->nsName));
; 26010: 
; 26011: 	}
; 26012: 	FREE_AND_NULL(str)
; 26013:     }
; 26014: #endif
; 26015: }

	pop	ebp
	ret	0
_xmlSchemaVContentModelCallback ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckCOSValidDefault
_TEXT	SEGMENT
_msg$1 = 8						; size = 4
_vctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_val$ = 16						; size = 4
_xmlSchemaCheckCOSValidDefault PROC			; COMDAT

; 25928: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _vctxt$[ebp]
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR [edi+108]
	xor	esi, esi
	mov	eax, DWORD PTR [ebx+28]
	cmp	DWORD PTR [eax], 5
	je	SHORT $LN3@xmlSchemaC

; 25929:     int ret = 0;
; 25930:     xmlSchemaNodeInfoPtr inode = vctxt->inode;
; 25931: 
; 25932:     /*
; 25933:     * cos-valid-default:
; 25934:     * Schema Component Constraint: Element Default Valid (Immediate)
; 25935:     * For a string to be a valid default with respect to a type
; 25936:     * definition the appropriate case among the following must be true:
; 25937:     */
; 25938:     if WXS_IS_COMPLEX(inode->typeDef) {

	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	jne	$LN4@xmlSchemaC
$LN3@xmlSchemaC:

; 25939: 	/*
; 25940: 	* Complex type.
; 25941: 	*
; 25942: 	* SPEC (2.1) "its {content type} must be a simple type definition
; 25943: 	* or mixed."
; 25944: 	* SPEC (2.2.2) "If the {content type} is mixed, then the {content
; 25945: 	* type}'s particle must be `emptiable` as defined by
; 25946: 	* Particle Emptiable ($3.9.6)."
; 25947: 	*/
; 25948: 	if ((! WXS_HAS_SIMPLE_CONTENT(inode->typeDef)) &&

	mov	ecx, DWORD PTR [eax+52]
	cmp	ecx, 4
	je	SHORT $LN4@xmlSchemaC
	cmp	ecx, 6
	je	SHORT $LN4@xmlSchemaC
	cmp	ecx, 3
	jne	SHORT $LN5@xmlSchemaC
	push	DWORD PTR [eax+28]
	call	_xmlSchemaIsParticleEmptiable
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@xmlSchemaC
$LN5@xmlSchemaC:

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$1[ebp]
	mov	DWORD PTR _msg$1[ebp], esi
	push	edi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0JO@LAEFOCFG@For?5a?5string?5to?5be?5a?5valid?5defa@
	push	DWORD PTR _msg$1[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	3059					; 00000bf3H
	push	2
	push	edi

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$1[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$1[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 68					; 00000044H

; 2352 :     FREE_AND_NULL(msg)

	test	eax, eax
	je	SHORT $LN18@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN18@xmlSchemaC:
	pop	edi

; 25986: }

	pop	esi
	mov	eax, 3059				; 00000bf3H
	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlSchemaC:

; 25949: 	    ((! WXS_HAS_MIXED_CONTENT(inode->typeDef)) ||
; 25950: 	     (! WXS_EMPTIABLE(inode->typeDef)))) {
; 25951: 	    ret = XML_SCHEMAP_COS_VALID_DEFAULT_2_1;
; 25952: 	    /* NOTE that this covers (2.2.2) as well. */
; 25953: 	    VERROR(ret, NULL,
; 25954: 		"For a string to be a valid default, the type definition "
; 25955: 		"must be a simple type or a complex type with simple content "
; 25956: 		"or mixed content and a particle emptiable");
; 25957: 	    return(ret);
; 25958: 	}
; 25959:     }
; 25960:     /*
; 25961:     * 1 If the type definition is a simple type definition, then the string
; 25962:     * must be `valid` with respect to that definition as defined by String
; 25963:     * Valid ($3.14.4).
; 25964:     *
; 25965:     * AND
; 25966:     *
; 25967:     * 2.2.1 If the {content type} is a simple type definition, then the
; 25968:     * string must be `valid` with respect to that simple type definition
; 25969:     * as defined by String Valid ($3.14.4).
; 25970:     */
; 25971:     if (WXS_IS_SIMPLE(inode->typeDef)) {

	mov	eax, DWORD PTR [ebx+28]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	SHORT $LN8@xmlSchemaC
	cmp	ecx, 1
	jne	SHORT $LN6@xmlSchemaC
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	jne	SHORT $LN8@xmlSchemaC
$LN6@xmlSchemaC:

; 25972: 
; 25973: 	ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST vctxt,
; 25974: 	    NULL, inode->typeDef, value, val, 1, 1, 0);
; 25975: 
; 25976:     } else if (WXS_HAS_SIMPLE_CONTENT(inode->typeDef)) {

	mov	ecx, DWORD PTR [eax+52]
	cmp	ecx, 4
	je	SHORT $LN10@xmlSchemaC
	cmp	ecx, 6
	jne	SHORT $LN22@xmlSchemaC
$LN10@xmlSchemaC:

; 25977: 
; 25978: 	ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST vctxt,

	mov	eax, DWORD PTR [eax+104]
$LN8@xmlSchemaC:

; 25979: 	    NULL, inode->typeDef->contentTypeDef, value, val, 1, 1, 0);
; 25980:     }
; 25981:     if (ret < 0) {

	push	0
	push	1
	push	1
	push	DWORD PTR _val$[ebp]
	push	DWORD PTR _value$[ebp]
	push	eax
	push	0
	push	edi
	call	_xmlSchemaVCheckCVCSimpleType
	mov	esi, eax
	add	esp, 32					; 00000020H
	test	esi, esi
	jns	SHORT $LN22@xmlSchemaC

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CH@HOPMNJDI@calling?5xmlSchemaVCheckCVCSimpl@
	push	OFFSET ??_C@_0BO@FJAHODBA@xmlSchemaCheckCOSValidDefault@
	push	edi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$LN22@xmlSchemaC:
	pop	edi

; 25982: 	VERROR_INT("xmlSchemaCheckCOSValidDefault",
; 25983: 	    "calling xmlSchemaVCheckCVCSimpleType()");
; 25984:     }
; 25985:     return (ret);

	mov	eax, esi

; 25986: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaCheckCOSValidDefault ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidateElemWildcard
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_msg$1 = 12						; size = 4
_skip$ = 12						; size = 4
_xmlSchemaValidateElemWildcard PROC			; COMDAT

; 25845: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _skip$[ebp]
	mov	esi, DWORD PTR _vctxt$[ebp]
	test	ecx, ecx
	je	$LN3@xmlSchemaV

; 25846:     xmlSchemaWildcardPtr wild = (xmlSchemaWildcardPtr) vctxt->inode->decl;

	mov	eax, DWORD PTR [esi+108]
	mov	edi, DWORD PTR [eax+44]

; 25847:     /*
; 25848:     * The namespace of the element was already identified to be
; 25849:     * matching the wildcard.
; 25850:     */
; 25851:     if ((skip == NULL) || (wild == NULL) ||

	test	edi, edi
	je	$LN3@xmlSchemaV
	cmp	DWORD PTR [edi], 2
	jne	$LN3@xmlSchemaV

; 25852: 	(wild->type != XML_SCHEMA_TYPE_ANY)) {
; 25853: 	VERROR_INT("xmlSchemaValidateElemWildcard",
; 25854: 	    "bad arguments");
; 25855: 	return (-1);
; 25856:     }
; 25857:     *skip = 0;

	mov	DWORD PTR [ecx], 0

; 25858:     if (wild->processContents == XML_SCHEMAS_ANY_SKIP) {

	cmp	DWORD PTR [edi+24], 1
	jne	SHORT $LN4@xmlSchemaV

; 25859: 	/*
; 25860: 	* URGENT VAL TODO: Either we need to position the stream to the
; 25861: 	* next sibling, or walk the whole subtree.
; 25862: 	*/
; 25863: 	*skip = 1;

	mov	DWORD PTR [ecx], 1
$LN9@xmlSchemaV:
	pop	edi

; 25915: }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlSchemaV:

; 25864: 	return (0);
; 25865:     }
; 25866:     {
; 25867: 	xmlSchemaElementPtr decl = NULL;
; 25868: 
; 25869: 	decl = xmlSchemaGetElem(vctxt->schema,

	mov	eax, DWORD PTR [esi+108]
	push	DWORD PTR [eax+16]
	push	DWORD PTR [eax+12]
	push	DWORD PTR [esi+20]
	call	_xmlSchemaGetElem
	mov	ecx, eax
	add	esp, 12					; 0000000cH

; 25870: 	    vctxt->inode->localName, vctxt->inode->nsName);
; 25871: 	if (decl != NULL) {

	test	ecx, ecx
	je	SHORT $LN5@xmlSchemaV

; 25872: 	    vctxt->inode->decl = decl;

	mov	eax, DWORD PTR [esi+108]
	pop	edi

; 25915: }

	pop	esi
	mov	DWORD PTR [eax+44], ecx
	xor	eax, eax
	pop	ebp
	ret	0
$LN5@xmlSchemaV:

; 25873: 	    return (0);
; 25874: 	}
; 25875:     }
; 25876:     if (wild->processContents == XML_SCHEMAS_ANY_STRICT) {

	cmp	DWORD PTR [edi+24], 3
	jne	SHORT $LN6@xmlSchemaV

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$1[ebp]
	mov	DWORD PTR _msg$1[ebp], 0
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0FG@DIJLLKJP@No?5matching?5global?5element?5decl@
	push	DWORD PTR _msg$1[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	1845					; 00000735H
	push	2
	push	esi

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$1[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	ecx, DWORD PTR _msg$1[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 68					; 00000044H

; 2352 :     FREE_AND_NULL(msg)

	test	ecx, ecx
	je	SHORT $LN18@xmlSchemaV
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN18@xmlSchemaV:

; 25877: 	/* VAL TODO: Change to proper error code. */
; 25878: 	VERROR(XML_SCHEMAV_CVC_ELT_1, NULL, /* WXS_BASIC_CAST wild */
; 25879: 	    "No matching global element declaration available, but "
; 25880: 	    "demanded by the strict wildcard");
; 25881: 	return (vctxt->err);

	mov	eax, DWORD PTR [esi+52]
	pop	edi

; 25915: }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlSchemaV:

; 25882:     }
; 25883:     if (vctxt->nbAttrInfos != 0) {

	cmp	DWORD PTR [esi+168], 0
	je	SHORT $LN8@xmlSchemaV

; 25884: 	xmlSchemaAttrInfoPtr iattr;
; 25885: 	/*
; 25886: 	* SPEC Validation Rule: Schema-Validity Assessment (Element)
; 25887: 	* (1.2.1.2.1) - (1.2.1.2.3 )
; 25888: 	*
; 25889: 	* Use the xsi:type attribute for the type definition.
; 25890: 	*/
; 25891: 	iattr = xmlSchemaGetMetaAttrInfo(vctxt,

	push	1
	push	esi
	call	_xmlSchemaGetMetaAttrInfo
	add	esp, 8

; 25892: 	    XML_SCHEMA_ATTR_INFO_META_XSI_TYPE);
; 25893: 	if (iattr != NULL) {

	test	eax, eax
	je	SHORT $LN8@xmlSchemaV

; 25894: 	    if (xmlSchemaProcessXSIType(vctxt, iattr,
; 25895: 		&(vctxt->inode->typeDef), NULL) == -1) {

	mov	ecx, DWORD PTR [esi+108]
	push	0
	add	ecx, 28					; 0000001cH
	push	ecx
	push	eax
	push	esi
	call	_xmlSchemaProcessXSIType
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	$LN9@xmlSchemaV

; 25896: 		VERROR_INT("xmlSchemaValidateElemWildcard",

	push	OFFSET ??_C@_0EF@GLDBDLOM@calling?5xmlSchemaProcessXSIType@
	push	OFFSET ??_C@_0BO@NHKJDFH@xmlSchemaValidateElemWildcard@
	push	esi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH

; 25915: }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN8@xmlSchemaV:

; 25897: 		    "calling xmlSchemaProcessXSIType() to "
; 25898: 		    "process the attribute 'xsi:nil'");
; 25899: 		return (-1);
; 25900: 	    }
; 25901: 	    /*
; 25902: 	    * Don't return an error on purpose.
; 25903: 	    */
; 25904: 	    return (0);
; 25905: 	}
; 25906:     }
; 25907:     /*
; 25908:     * SPEC Validation Rule: Schema-Validity Assessment (Element)
; 25909:     *
; 25910:     * Fallback to "anyType".
; 25911:     */
; 25912:     vctxt->inode->typeDef =

	push	45					; 0000002dH
	call	_xmlSchemaGetBuiltInType
	mov	ecx, DWORD PTR [esi+108]
	add	esp, 4
	pop	edi
	mov	DWORD PTR [ecx+28], eax

; 25913: 	xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
; 25914:     return (0);

	xor	eax, eax

; 25915: }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0O@NAPPEKME@bad?5arguments@
	push	OFFSET ??_C@_0BO@NHKJDFH@xmlSchemaValidateElemWildcard@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 25915: }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlSchemaValidateElemWildcard ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaVAttributesComplex
_TEXT	SEGMENT
_prefix$1 = -44						; size = 12
tv1994 = -32						; size = 4
$T2 = -32						; size = 4
_value$1$ = -32						; size = 4
_wildIDs$1$ = -32					; size = 4
_str$3 = -32						; size = 4
_nbUses$1$ = -28					; size = 4
_i$1$ = -24						; size = 4
_i$4$ = -20						; size = 4
_attrUseList$1$ = -20					; size = 4
_xpathRes$1$ = -20					; size = 4
_normValue$1$ = -16					; size = 4
_nbAttrs$1$ = -16					; size = 4
_attrUse$1$ = -12					; size = 4
_type$1$ = -8						; size = 4
_defAttrOwnerElem$1$ = -4				; size = 4
_msg$4 = 8						; size = 4
_msg$5 = 8						; size = 4
_i$3$ = 8						; size = 4
_msg$6 = 8						; size = 4
_i$2$ = 8						; size = 4
_msg$7 = 8						; size = 4
_attrDecl$1$ = 8					; size = 4
_vctxt$ = 8						; size = 4
_xmlSchemaVAttributesComplex PROC			; COMDAT

; 25239: {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _vctxt$[ebp]
	mov	DWORD PTR _wildIDs$1$[ebp], 0
	mov	DWORD PTR _defAttrOwnerElem$1$[ebp], 0
	mov	eax, DWORD PTR [ebx+108]
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR _type$1$[ebp], eax
	mov	ecx, DWORD PTR [eax+116]
	mov	eax, DWORD PTR [ebx+168]
	mov	DWORD PTR _attrUseList$1$[ebp], ecx
	mov	DWORD PTR _nbAttrs$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN25@xmlSchemaV

; 25240:     xmlSchemaTypePtr type = vctxt->inode->typeDef;
; 25241:     xmlSchemaItemListPtr attrUseList;
; 25242:     xmlSchemaAttributeUsePtr attrUse = NULL;
; 25243:     xmlSchemaAttributePtr attrDecl = NULL;
; 25244:     xmlSchemaAttrInfoPtr iattr, tmpiattr;
; 25245:     int i, j, found, nbAttrs, nbUses;
; 25246:     int xpathRes = 0, res, wildIDs = 0, fixed;
; 25247:     xmlNodePtr defAttrOwnerElem = NULL;
; 25248: 
; 25249:     /*
; 25250:     * SPEC (cvc-attribute)
; 25251:     * (1) "The declaration must not be `absent` (see Missing
; 25252:     * Sub-components ($5.3) for how this can fail to be
; 25253:     * the case)."
; 25254:     * (2) "Its {type definition} must not be absent."
; 25255:     *
; 25256:     * NOTE (1) + (2): This is not handled here, since we currently do not
; 25257:     * allow validation against schemas which have missing sub-components.
; 25258:     *
; 25259:     * SPEC (cvc-complex-type)
; 25260:     * (3) "For each attribute information item in the element information
; 25261:     * item's [attributes] excepting those whose [namespace name] is
; 25262:     * identical to http://www.w3.org/2001/XMLSchema-instance and whose
; 25263:     * [local name] is one of type, nil, schemaLocation or
; 25264:     * noNamespaceSchemaLocation, the appropriate case among the following
; 25265:     * must be true:
; 25266:     *
; 25267:     */
; 25268:     attrUseList = (xmlSchemaItemListPtr) type->attrUses;
; 25269:     /*
; 25270:     * @nbAttrs is the number of attributes present in the instance.
; 25271:     */
; 25272:     nbAttrs = vctxt->nbAttrInfos;
; 25273:     if (attrUseList != NULL)
; 25274: 	nbUses = attrUseList->nbItems;

	mov	edi, DWORD PTR [ecx+4]
	jmp	SHORT $LN236@xmlSchemaV
$LN25@xmlSchemaV:

; 25275:     else
; 25276: 	nbUses = 0;

	xor	edi, edi
$LN236@xmlSchemaV:

; 25277:     for (i = 0; i < nbUses; i++) {

	xor	esi, esi
	mov	DWORD PTR _nbUses$1$[ebp], edi
	mov	DWORD PTR _i$1$[ebp], esi
	mov	edx, eax
	test	edi, edi
	jle	$LN3@xmlSchemaV
	npad	7
$LL4@xmlSchemaV:

; 25278:         found = 0;
; 25279: 	attrUse = attrUseList->items[i];

	mov	eax, DWORD PTR [ecx]

; 25280: 	attrDecl = WXS_ATTRUSE_DECL(attrUse);
; 25281:         for (j = 0; j < nbAttrs; j++) {

	xor	edi, edi
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	DWORD PTR _attrUse$1$[ebp], ecx
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR _attrDecl$1$[ebp], esi
	cmp	DWORD PTR _nbAttrs$1$[ebp], edi
	jle	SHORT $LN225@xmlSchemaV
	npad	11
$LL7@xmlSchemaV:

; 25282: 	    iattr = vctxt->attrInfos[j];

	mov	eax, DWORD PTR [ebx+164]
	mov	esi, DWORD PTR [eax+edi*4]

; 25283: 	    /*
; 25284: 	    * SPEC (cvc-complex-type) (3)
; 25285: 	    * Skip meta attributes.
; 25286: 	    */
; 25287: 	    if (iattr->metaType)

	cmp	DWORD PTR [esi+48], 0
	jne	SHORT $LN5@xmlSchemaV

; 25288: 		continue;
; 25289: 	    if (iattr->localName[0] != attrDecl->name[0])

	mov	eax, DWORD PTR _attrDecl$1$[ebp]
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax+8]
	mov	al, BYTE PTR [ecx]
	cmp	al, BYTE PTR [edx]
	jne	SHORT $LN5@xmlSchemaV

; 25290: 		continue;
; 25291: 	    if (!xmlStrEqual(iattr->localName, attrDecl->name))

	push	edx
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlSchemaV

; 25292: 		continue;
; 25293: 	    if (!xmlStrEqual(iattr->nsName, attrDecl->targetNamespace))

	mov	eax, DWORD PTR _attrDecl$1$[ebp]
	push	DWORD PTR [eax+56]
	push	DWORD PTR [esi+16]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@xmlSchemaV
$LN5@xmlSchemaV:

; 25280: 	attrDecl = WXS_ATTRUSE_DECL(attrUse);
; 25281:         for (j = 0; j < nbAttrs; j++) {

	inc	edi
	cmp	edi, DWORD PTR _nbAttrs$1$[ebp]
	jl	SHORT $LL7@xmlSchemaV
	mov	esi, DWORD PTR _attrDecl$1$[ebp]
	mov	ecx, DWORD PTR _attrUse$1$[ebp]
$LN225@xmlSchemaV:

; 25323: 	    continue;
; 25324: 
; 25325: 	if (attrUse->occurs == XML_SCHEMAS_ATTR_USE_REQUIRED) {

	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, 1
	jne	SHORT $LN32@xmlSchemaV

; 25326: 	    /*
; 25327: 	    * Handle non-existent, required attributes.
; 25328: 	    *
; 25329: 	    * SPEC (cvc-complex-type)
; 25330: 	    * (4) "The {attribute declaration} of each attribute use in
; 25331: 	    * the {attribute uses} whose {required} is true matches one
; 25332: 	    * of the attribute information items in the element information
; 25333: 	    * item's [attributes] as per clause 3.1 above."
; 25334: 	    */
; 25335: 	    tmpiattr = xmlSchemaGetFreshAttrInfo(vctxt);

	push	ebx
	call	_xmlSchemaGetFreshAttrInfo
	add	esp, 4

; 25336: 	    if (tmpiattr == NULL) {

	test	eax, eax
	je	$LN186@xmlSchemaV

; 25337: 		VERROR_INT(
; 25338: 		    "xmlSchemaVAttributesComplex",
; 25339: 		    "calling xmlSchemaGetFreshAttrInfo()");
; 25340: 		return (-1);
; 25341: 	    }
; 25342: 	    tmpiattr->state = XML_SCHEMAS_ATTR_ERR_MISSING;
; 25343: 	    tmpiattr->use = attrUse;

	mov	ecx, DWORD PTR _attrUse$1$[ebp]
	mov	DWORD PTR [eax+44], 4
	mov	DWORD PTR [eax+40], ecx

; 25344: 	    tmpiattr->decl = attrDecl;

	mov	DWORD PTR [eax+36], esi
	jmp	SHORT $LN2@xmlSchemaV
$LN30@xmlSchemaV:

; 25294: 		continue;
; 25295: 	    found = 1;
; 25296: 	    /*
; 25297: 	    * SPEC (cvc-complex-type)
; 25298: 	    * (3.1) "If there is among the {attribute uses} an attribute
; 25299: 	    * use with an {attribute declaration} whose {name} matches
; 25300: 	    * the attribute information item's [local name] and whose
; 25301: 	    * {target namespace} is identical to the attribute information
; 25302: 	    * item's [namespace name] (where an `absent` {target namespace}
; 25303: 	    * is taken to be identical to a [namespace name] with no value),
; 25304: 	    * then the attribute information must be `valid` with respect
; 25305: 	    * to that attribute use as per Attribute Locally Valid (Use)
; 25306: 	    * ($3.5.4). In this case the {attribute declaration} of that
; 25307: 	    * attribute use is the `context-determined declaration` for the
; 25308: 	    * attribute information item with respect to Schema-Validity
; 25309: 	    * Assessment (Attribute) ($3.2.4) and
; 25310: 	    * Assessment Outcome (Attribute) ($3.2.5).
; 25311: 	    */
; 25312: 	    iattr->state = XML_SCHEMAS_ATTR_ASSESSED;
; 25313: 	    iattr->use = attrUse;
; 25314: 	    /*
; 25315: 	    * Context-determined declaration.
; 25316: 	    */
; 25317: 	    iattr->decl = attrDecl;

	mov	eax, DWORD PTR _attrDecl$1$[ebp]
	mov	ecx, DWORD PTR _attrUse$1$[ebp]
	mov	DWORD PTR [esi+44], 2
	mov	DWORD PTR [esi+40], ecx
	mov	DWORD PTR [esi+36], eax

; 25318: 	    iattr->typeDef = attrDecl->subtypes;

	mov	eax, DWORD PTR [eax+48]
	mov	DWORD PTR [esi+28], eax

; 25319: 	    break;
; 25320: 	}
; 25321: 
; 25322: 	if (found)

	jmp	SHORT $LN2@xmlSchemaV
$LN32@xmlSchemaV:

; 25345: 	} else if ((attrUse->occurs == XML_SCHEMAS_ATTR_USE_OPTIONAL) &&

	cmp	eax, 2
	jne	SHORT $LN2@xmlSchemaV
	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $LN36@xmlSchemaV
	cmp	DWORD PTR [esi+44], 0
	je	SHORT $LN2@xmlSchemaV
$LN36@xmlSchemaV:

; 25346: 	    ((attrUse->defValue != NULL) ||
; 25347: 	     (attrDecl->defValue != NULL))) {
; 25348: 	    /*
; 25349: 	    * Handle non-existent, optional, default/fixed attributes.
; 25350: 	    */
; 25351: 	    tmpiattr = xmlSchemaGetFreshAttrInfo(vctxt);

	push	ebx
	call	_xmlSchemaGetFreshAttrInfo
	mov	edx, eax
	add	esp, 4

; 25352: 	    if (tmpiattr == NULL) {

	test	edx, edx
	je	SHORT $LN186@xmlSchemaV

; 25357: 	    }
; 25358: 	    tmpiattr->state = XML_SCHEMAS_ATTR_DEFAULT;
; 25359: 	    tmpiattr->use = attrUse;

	mov	ecx, DWORD PTR _attrUse$1$[ebp]
	mov	DWORD PTR [edx+44], 8
	mov	DWORD PTR [edx+40], ecx

; 25360: 	    tmpiattr->decl = attrDecl;

	mov	DWORD PTR [edx+36], esi

; 25361: 	    tmpiattr->typeDef = attrDecl->subtypes;

	mov	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [edx+28], ecx

; 25362: 	    tmpiattr->localName = attrDecl->name;

	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [edx+12], ecx

; 25363: 	    tmpiattr->nsName = attrDecl->targetNamespace;

	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR [edx+16], eax
$LN2@xmlSchemaV:

; 25277:     for (i = 0; i < nbUses; i++) {

	mov	esi, DWORD PTR _i$1$[ebp]
	inc	esi
	mov	DWORD PTR _i$1$[ebp], esi
	cmp	esi, DWORD PTR _nbUses$1$[ebp]
	jge	SHORT $LN226@xmlSchemaV
	mov	ecx, DWORD PTR _attrUseList$1$[ebp]
	jmp	$LL4@xmlSchemaV
$LN186@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CE@JCDDMGJO@calling?5xmlSchemaGetFreshAttrIn@
	push	OFFSET ??_C@_0BM@CHGONAOC@xmlSchemaVAttributesComplex@
	push	ebx
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 25353: 		VERROR_INT(
; 25354: 		    "xmlSchemaVAttributesComplex",
; 25355: 		    "calling xmlSchemaGetFreshAttrInfo()");
; 25356: 		return (-1);

	or	eax, -1
	pop	edi

; 25840: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN226@xmlSchemaV:

; 25764: 	    if (xmlSchemaXPathProcessHistory(vctxt,
; 25765: 		vctxt->depth +1) == -1) {

	mov	edx, DWORD PTR [ebx+168]
	mov	eax, DWORD PTR _nbAttrs$1$[ebp]
$LN3@xmlSchemaV:

; 25364: 	}
; 25365:     }
; 25366: 
; 25367:     if (vctxt->nbAttrInfos == 0)

	test	edx, edx
	je	$LN224@xmlSchemaV

; 25368: 	return (0);
; 25369:     /*
; 25370:     * Validate against the wildcard.
; 25371:     */
; 25372:     if (type->attributeWildcard != NULL) {

	mov	esi, DWORD PTR _type$1$[ebp]
	cmp	DWORD PTR [esi+84], 0
	je	$LN9@xmlSchemaV

; 25373: 	/*
; 25374: 	* SPEC (cvc-complex-type)
; 25375: 	* (3.2.1) "There must be an {attribute wildcard}."
; 25376: 	*/
; 25377: 	for (i = 0; i < nbAttrs; i++) {

	xor	edi, edi
	mov	DWORD PTR _i$2$[ebp], edi
	test	eax, eax
	jle	$LN9@xmlSchemaV
	npad	11
$LL10@xmlSchemaV:

; 25378: 	    iattr = vctxt->attrInfos[i];

	mov	eax, DWORD PTR [ebx+164]
	mov	edi, DWORD PTR [eax+edi*4]

; 25379: 	    /*
; 25380: 	    * SPEC (cvc-complex-type) (3)
; 25381: 	    * Skip meta attributes.
; 25382: 	    */
; 25383: 	    if (iattr->state != XML_SCHEMAS_ATTR_UNKNOWN)

	cmp	DWORD PTR [edi+44], 1
	jne	$LN8@xmlSchemaV

; 25384: 		continue;
; 25385: 	    /*
; 25386: 	    * SPEC (cvc-complex-type)
; 25387: 	    * (3.2.2) "The attribute information item must be `valid` with
; 25388: 	    * respect to it as defined in Item Valid (Wildcard) ($3.10.4)."
; 25389: 	    *
; 25390: 	    * SPEC Item Valid (Wildcard) (cvc-wildcard)
; 25391: 	    * "... its [namespace name] must be `valid` with respect to
; 25392: 	    * the wildcard constraint, as defined in Wildcard allows
; 25393: 	    * Namespace Name ($3.10.4)."
; 25394: 	    */
; 25395: 	    if (xmlSchemaCheckCVCWildcardNamespace(type->attributeWildcard,
; 25396: 		    iattr->nsName) == 0) {

	push	DWORD PTR [edi+16]
	push	DWORD PTR [esi+84]
	call	_xmlSchemaCheckCVCWildcardNamespace
	add	esp, 8
	test	eax, eax
	jne	$LN8@xmlSchemaV

; 25397: 		/*
; 25398: 		* Handle processContents.
; 25399: 		*
; 25400: 		* SPEC (cvc-wildcard):
; 25401: 		* processContents | context-determined declaration:
; 25402: 		* "strict"          "mustFind"
; 25403: 		* "lax"             "none"
; 25404: 		* "skip"            "skip"
; 25405: 		*/
; 25406: 		if (type->attributeWildcard->processContents ==

	mov	eax, DWORD PTR [esi+84]
	cmp	DWORD PTR [eax+24], 1
	jne	SHORT $LN42@xmlSchemaV

; 25407: 		    XML_SCHEMAS_ANY_SKIP) {
; 25408: 		     /*
; 25409: 		    * context-determined declaration = "skip"
; 25410: 		    *
; 25411: 		    * SPEC PSVI Assessment Outcome (Attribute)
; 25412: 		    * [validity] = "notKnown"
; 25413: 		    * [validation attempted] = "none"
; 25414: 		    */
; 25415: 		    iattr->state = XML_SCHEMAS_ATTR_WILD_SKIP;

	mov	DWORD PTR [edi+44], 13			; 0000000dH

; 25416: 		    continue;

	jmp	SHORT $LN8@xmlSchemaV
$LN42@xmlSchemaV:

; 25417: 		}
; 25418: 		/*
; 25419: 		* Find an attribute declaration.
; 25420: 		*/
; 25421: 		iattr->decl = xmlSchemaGetAttributeDecl(vctxt->schema,

	push	DWORD PTR [edi+16]
	push	DWORD PTR [edi+12]
	push	DWORD PTR [ebx+20]
	call	_xmlSchemaGetAttributeDecl
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+36], eax

; 25422: 		    iattr->localName, iattr->nsName);
; 25423: 		if (iattr->decl != NULL) {

	test	eax, eax
	je	$LN43@xmlSchemaV

; 25424: 		    iattr->state = XML_SCHEMAS_ATTR_ASSESSED;

	mov	DWORD PTR [edi+44], 2

; 25425: 		    /*
; 25426: 		    * SPEC (cvc-complex-type)
; 25427: 		    * (5) "Let [Definition:]  the wild IDs be the set of
; 25428: 		    * all attribute information item to which clause 3.2
; 25429: 		    * applied and whose `validation` resulted in a
; 25430: 		    * `context-determined declaration` of mustFind or no
; 25431: 		    * `context-determined declaration` at all, and whose
; 25432: 		    * [local name] and [namespace name] resolve (as
; 25433: 		    * defined by QName resolution (Instance) ($3.15.4)) to
; 25434: 		    * an attribute declaration whose {type definition} is
; 25435: 		    * or is derived from ID. Then all of the following
; 25436: 		    * must be true:"
; 25437: 		    */
; 25438: 		    iattr->typeDef = WXS_ATTR_TYPEDEF(iattr->decl);

	mov	eax, DWORD PTR [eax+48]

; 25439: 		    if (xmlSchemaIsDerivedFromBuiltInType(

	push	23					; 00000017H
	push	eax
	mov	DWORD PTR [edi+28], eax
	call	_xmlSchemaIsDerivedFromBuiltInType
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlSchemaV

; 25440: 			iattr->typeDef, XML_SCHEMAS_ID)) {
; 25441: 			/*
; 25442: 			* SPEC (5.1) "There must be no more than one
; 25443: 			* item in `wild IDs`."
; 25444: 			*/
; 25445: 			if (wildIDs != 0) {

	cmp	DWORD PTR _wildIDs$1$[ebp], 0
	je	$LN46@xmlSchemaV

; 25446: 			    /* VAL TODO */
; 25447: 			    iattr->state = XML_SCHEMAS_ATTR_ERR_WILD_DUPLICATE_ID;

	mov	DWORD PTR [edi+44], 15			; 0000000fH

; 25448: 			    TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	25448					; 00006368H
$LN237@xmlSchemaV:

; 25373: 	/*
; 25374: 	* SPEC (cvc-complex-type)
; 25375: 	* (3.2.1) "There must be an {attribute wildcard}."
; 25376: 	*/
; 25377: 	for (i = 0; i < nbAttrs; i++) {

	push	OFFSET ??_C@_0GM@IJCDLDON@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN235@xmlSchemaV:
	mov	esi, DWORD PTR _type$1$[ebp]
$LN8@xmlSchemaV:
	mov	edi, DWORD PTR _i$2$[ebp]
	inc	edi
	mov	DWORD PTR _i$2$[ebp], edi
	cmp	edi, DWORD PTR _nbAttrs$1$[ebp]
	jl	$LL10@xmlSchemaV
	mov	edx, DWORD PTR [ebx+168]
$LN9@xmlSchemaV:

; 25473: 		    XML_SCHEMAS_ANY_LAX) {
; 25474: 		    iattr->state = XML_SCHEMAS_ATTR_WILD_LAX_NO_DECL;
; 25475: 		    /*
; 25476: 		    * SPEC PSVI Assessment Outcome (Attribute)
; 25477: 		    * [validity] = "notKnown"
; 25478: 		    * [validation attempted] = "none"
; 25479: 		    */
; 25480: 		} else {
; 25481: 		    iattr->state = XML_SCHEMAS_ATTR_ERR_WILD_STRICT_NO_DECL;
; 25482: 		}
; 25483: 	    }
; 25484: 	}
; 25485:     }
; 25486: 
; 25487:     if (vctxt->nbAttrInfos == 0)

	test	edx, edx
	je	$LN224@xmlSchemaV

; 25488: 	return (0);
; 25489: 
; 25490:     /*
; 25491:     * Get the owner element; needed for creation of default attributes.
; 25492:     * This fixes bug #341337, reported by David Grohmann.
; 25493:     */
; 25494:     if (vctxt->options & XML_SCHEMA_VAL_VC_I_CREATE) {

	test	BYTE PTR [ebx+80], 1
	je	SHORT $LN53@xmlSchemaV

; 25495: 	xmlSchemaNodeInfoPtr ielem = vctxt->elemInfos[vctxt->depth];

	mov	ecx, DWORD PTR [ebx+96]
	mov	eax, DWORD PTR [ebx+100]
	mov	eax, DWORD PTR [eax+ecx*4]

; 25496: 	if (ielem && ielem->node && ielem->node->doc)

	test	eax, eax
	je	SHORT $LN53@xmlSchemaV
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN53@xmlSchemaV
	xor	ecx, ecx
	cmp	DWORD PTR [eax+32], ecx
	cmovne	ecx, eax
	mov	DWORD PTR _defAttrOwnerElem$1$[ebp], ecx
$LN53@xmlSchemaV:

; 25497: 	    defAttrOwnerElem = ielem->node;
; 25498:     }
; 25499:     /*
; 25500:     * Validate values, create default attributes, evaluate IDCs.
; 25501:     */
; 25502:     for (i = 0; i < vctxt->nbAttrInfos; i++) {

	xor	edi, edi
	mov	DWORD PTR _i$3$[ebp], edi
	test	edx, edx
	jle	$LN227@xmlSchemaV
	npad	5
$LL16@xmlSchemaV:

; 25503: 	iattr = vctxt->attrInfos[i];

	mov	eax, DWORD PTR [ebx+164]
	mov	esi, DWORD PTR [eax+edi*4]

; 25504: 	/*
; 25505: 	* VAL TODO: Note that we won't try to resolve IDCs to
; 25506: 	* "lax" and "skip" validated attributes. Check what to
; 25507: 	* do in this case.
; 25508: 	*/
; 25509: 	if ((iattr->state != XML_SCHEMAS_ATTR_ASSESSED) &&

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 2
	je	SHORT $LN54@xmlSchemaV
	cmp	eax, 8
	jne	$LN14@xmlSchemaV
$LN54@xmlSchemaV:

; 25510: 	    (iattr->state != XML_SCHEMAS_ATTR_DEFAULT))
; 25511: 	    continue;
; 25512: 	/*
; 25513: 	* VAL TODO: What to do if the type definition is missing?
; 25514: 	*/
; 25515: 	if (iattr->typeDef == NULL) {

	cmp	DWORD PTR [esi+28], 0
	jne	$LN55@xmlSchemaV

; 25516: 	    iattr->state = XML_SCHEMAS_ATTR_ERR_NO_TYPE;

	mov	DWORD PTR [esi+44], 6

; 25517: 	    continue;

	jmp	$LN14@xmlSchemaV
$LN46@xmlSchemaV:

; 25449: 			    continue;
; 25450: 			}
; 25451: 			wildIDs++;
; 25452: 			/*
; 25453: 			* SPEC (cvc-complex-type)
; 25454: 			* (5.2) "If `wild IDs` is non-empty, there must not
; 25455: 			* be any attribute uses among the {attribute uses}
; 25456: 			* whose {attribute declaration}'s {type definition}
; 25457: 			* is or is derived from ID."
; 25458: 			*/
; 25459:                         if (attrUseList != NULL) {

	mov	ecx, DWORD PTR _attrUseList$1$[ebp]
	mov	DWORD PTR _wildIDs$1$[ebp], 1
	test	ecx, ecx
	je	$LN8@xmlSchemaV

; 25460:                             for (j = 0; j < attrUseList->nbItems; j++) {

	xor	esi, esi
	cmp	DWORD PTR [ecx+4], esi
	jle	$LN235@xmlSchemaV
	npad	3
$LL13@xmlSchemaV:

; 25461:                                 if (xmlSchemaIsDerivedFromBuiltInType(

	mov	eax, DWORD PTR [ecx]
	push	23					; 00000017H
	mov	eax, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [eax+12]
	push	DWORD PTR [eax+48]
	call	_xmlSchemaIsDerivedFromBuiltInType
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN187@xmlSchemaV

; 25460:                             for (j = 0; j < attrUseList->nbItems; j++) {

	mov	ecx, DWORD PTR _attrUseList$1$[ebp]
	inc	esi
	cmp	esi, DWORD PTR [ecx+4]
	jl	SHORT $LL13@xmlSchemaV

; 25764: 	    if (xmlSchemaXPathProcessHistory(vctxt,
; 25765: 		vctxt->depth +1) == -1) {

	jmp	$LN235@xmlSchemaV
$LN187@xmlSchemaV:

; 25462:                                     WXS_ATTRUSE_TYPEDEF(attrUseList->items[j]),
; 25463:                                     XML_SCHEMAS_ID)) {
; 25464:                                     /* URGENT VAL TODO: implement */
; 25465:                             iattr->state = XML_SCHEMAS_ATTR_ERR_WILD_AND_USE_ID;

	mov	DWORD PTR [edi+44], 16			; 00000010H

; 25466:                                     TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	25466					; 0000637aH

; 25467:                                     break;
; 25468:                                 }
; 25469:                             }
; 25470:                         }
; 25471: 		    }

	jmp	$LN237@xmlSchemaV
$LN43@xmlSchemaV:

; 25472: 		} else if (type->attributeWildcard->processContents ==

	mov	eax, DWORD PTR [esi+84]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+24], 2
	sete	cl
	lea	ecx, DWORD PTR [ecx*4+10]
	mov	DWORD PTR [edi+44], ecx
	jmp	$LN8@xmlSchemaV
$LN55@xmlSchemaV:

; 25518: 	}
; 25519: 
; 25520: 	ACTIVATE_ATTRIBUTE(iattr);
; 25521: 	fixed = 0;
; 25522: 	xpathRes = 0;

	xor	eax, eax
	mov	DWORD PTR [ebx+108], esi
	mov	DWORD PTR _xpathRes$1$[ebp], eax

; 25523: 
; 25524: 	if (vctxt->xpathStates != NULL) {

	cmp	DWORD PTR [ebx+116], eax
	je	SHORT $LN57@xmlSchemaV

; 25525: 	    /*
; 25526: 	    * Evaluate IDCs.
; 25527: 	    */
; 25528: 	    xpathRes = xmlSchemaXPathEvaluate(vctxt,

	push	2
	push	ebx
	call	_xmlSchemaXPathEvaluate
	add	esp, 8
	mov	DWORD PTR _xpathRes$1$[ebp], eax

; 25529: 		XML_ATTRIBUTE_NODE);
; 25530: 	    if (xpathRes == -1) {

	cmp	eax, -1
	je	$LN196@xmlSchemaV
$LN57@xmlSchemaV:

; 25531: 		VERROR_INT("xmlSchemaVAttributesComplex",
; 25532: 		    "calling xmlSchemaXPathEvaluate()");
; 25533: 		goto internal_error;
; 25534: 	    }
; 25535: 	}
; 25536: 
; 25537: 	if (iattr->state == XML_SCHEMAS_ATTR_DEFAULT) {

	cmp	DWORD PTR [esi+44], 8
	jne	$LN58@xmlSchemaV

; 25538: 	    /*
; 25539: 	    * Default/fixed attributes.
; 25540: 	    * We need the value only if we need to resolve IDCs or
; 25541: 	    * will create default attributes.
; 25542: 	    */
; 25543: 	    if ((xpathRes) || (defAttrOwnerElem)) {

	test	eax, eax
	jne	SHORT $LN60@xmlSchemaV
	cmp	DWORD PTR _defAttrOwnerElem$1$[ebp], eax
	je	$LN221@xmlSchemaV
$LN60@xmlSchemaV:

; 25544: 		if (iattr->use->defValue != NULL) {

	mov	eax, DWORD PTR [esi+40]
	mov	ecx, DWORD PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LN61@xmlSchemaV

; 25545: 		    iattr->value = (xmlChar *) iattr->use->defValue;

	mov	DWORD PTR [esi+20], ecx

; 25546: 		    iattr->val = iattr->use->defVal;

	mov	eax, DWORD PTR [eax+32]

; 25547: 		} else {

	jmp	SHORT $LN62@xmlSchemaV
$LN61@xmlSchemaV:

; 25548: 		    iattr->value = (xmlChar *) iattr->decl->defValue;

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [esi+20], eax

; 25549: 		    iattr->val = iattr->decl->defVal;

	mov	eax, DWORD PTR [ecx+68]
$LN62@xmlSchemaV:

; 25550: 		}
; 25551: 		/*
; 25552: 		* IDCs will consume the precomputed default value,
; 25553: 		* so we need to clone it.
; 25554: 		*/
; 25555: 		if (iattr->val == NULL) {

	mov	DWORD PTR [esi+24], eax
	test	eax, eax
	je	$LN192@xmlSchemaV

; 25560: 		}
; 25561: 		iattr->val = xmlSchemaCopyValue(iattr->val);

	push	eax
	call	_xmlSchemaCopyValue
	add	esp, 4
	mov	DWORD PTR [esi+24], eax

; 25562: 		if (iattr->val == NULL) {

	test	eax, eax
	je	$LN193@xmlSchemaV

; 25566: 		}
; 25567: 	    }
; 25568: 	    /*
; 25569: 	    * PSVI: Add the default attribute to the current element.
; 25570: 	    * VAL TODO: Should we use the *normalized* value? This currently
; 25571: 	    *   uses the *initial* value.
; 25572: 	    */
; 25573: 
; 25574: 	    if (defAttrOwnerElem) {

	cmp	DWORD PTR _defAttrOwnerElem$1$[ebp], 0
	je	$eval_idcs$244

; 25575: 		xmlChar *normValue;
; 25576: 		const xmlChar *value;
; 25577: 
; 25578: 		value = iattr->value;

	mov	edi, DWORD PTR [esi+20]

; 24432:     switch (xmlSchemaGetWhiteSpaceFacetValue(type)) {

	push	DWORD PTR [esi+28]

; 25575: 		xmlChar *normValue;
; 25576: 		const xmlChar *value;
; 25577: 
; 25578: 		value = iattr->value;

	mov	DWORD PTR _value$1$[ebp], edi

; 24432:     switch (xmlSchemaGetWhiteSpaceFacetValue(type)) {

	call	_xmlSchemaGetWhiteSpaceFacetValue
	add	esp, 4
	sub	eax, 2
	je	SHORT $LN123@xmlSchemaV
	sub	eax, 1
	je	SHORT $LN122@xmlSchemaV

; 24437: 	default:
; 24438: 	    return (NULL);

	xor	edi, edi
	mov	DWORD PTR _normValue$1$[ebp], edi
	jmp	SHORT $LN119@xmlSchemaV
$LN122@xmlSchemaV:

; 24433: 	case XML_SCHEMA_WHITESPACE_COLLAPSE:
; 24434: 	    return (xmlSchemaCollapseString(value));

	push	edi
	call	_xmlSchemaCollapseString
	mov	edi, eax
	mov	DWORD PTR _normValue$1$[ebp], edi
	jmp	SHORT $LN238@xmlSchemaV
$LN123@xmlSchemaV:

; 24435: 	case XML_SCHEMA_WHITESPACE_REPLACE:
; 24436: 	    return (xmlSchemaWhiteSpaceReplace(value));

	push	edi
	call	_xmlSchemaWhiteSpaceReplace
	mov	edi, eax
	mov	DWORD PTR _normValue$1$[ebp], eax
$LN238@xmlSchemaV:

; 25579: 		/*
; 25580: 		* Normalize the value.
; 25581: 		*/
; 25582: 		normValue = xmlSchemaNormalizeValue(iattr->typeDef,
; 25583: 		    iattr->value);
; 25584: 		if (normValue != NULL)
; 25585: 		    value = BAD_CAST normValue;
; 25586: 
; 25587: 		if (iattr->nsName == NULL) {

	add	esp, 4
$LN119@xmlSchemaV:
	mov	ecx, DWORD PTR [esi+16]
	test	edi, edi
	mov	eax, edi
	cmove	eax, DWORD PTR _value$1$[ebp]
	mov	DWORD PTR tv1994[ebp], eax
	test	ecx, ecx
	jne	SHORT $LN67@xmlSchemaV

; 25588: 		    if (xmlNewProp(defAttrOwnerElem,
; 25589: 			iattr->localName, value) == NULL) {

	push	eax
	push	DWORD PTR [esi+12]
	push	DWORD PTR _defAttrOwnerElem$1$[ebp]
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN68@xmlSchemaV

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	eax
	push	eax
	push	OFFSET ??_C@_0BF@NILPJKHF@calling?5xmlNewProp?$CI?$CJ@
	push	OFFSET ??_C@_0BM@CHGONAOC@xmlSchemaVAttributesComplex@
	push	ebx
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 25590: 			VERROR_INT("xmlSchemaVAttributesComplex",
; 25591: 			    "calling xmlNewProp()");
; 25592: 			if (normValue != NULL)

	test	edi, edi
	je	$internal_error$245

; 25593: 			    xmlFree(normValue);

	push	edi
	call	DWORD PTR _xmlFree

; 25836:     return (0);
; 25837: internal_error:
; 25838:     ACTIVATE_ELEM;

	mov	ecx, DWORD PTR [ebx+96]
	add	esp, 4
	mov	eax, DWORD PTR [ebx+100]
	pop	edi
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [ebx+108], eax

; 25839:     return (-1);

	or	eax, -1

; 25840: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN67@xmlSchemaV:

; 25594: 			goto internal_error;
; 25595: 		    }
; 25596: 		} else {
; 25597: 		    xmlNsPtr ns;
; 25598: 
; 25599: 		    ns = xmlSearchNsByHref(defAttrOwnerElem->doc,

	mov	eax, DWORD PTR _defAttrOwnerElem$1$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [eax+32]
	call	_xmlSearchNsByHref
	add	esp, 12					; 0000000cH

; 25600: 			defAttrOwnerElem, iattr->nsName);
; 25601: 		    if (ns == NULL) {

	test	eax, eax
	jne	SHORT $LN71@xmlSchemaV

; 25602: 			xmlChar prefix[12];
; 25603: 			int counter = 0;

	xor	edi, edi
	npad	6
$LL19@xmlSchemaV:

; 25604: 
; 25605: 			/*
; 25606: 			* Create a namespace declaration on the validation
; 25607: 			* root node if no namespace declaration is in scope.
; 25608: 			*/
; 25609: 			do {
; 25610: 			    snprintf((char *) prefix, 12, "p%d", counter++);

	push	edi
	push	OFFSET ??_C@_03IKJDKKNH@p?$CFd@
	lea	eax, DWORD PTR _prefix$1[ebp]
	push	12					; 0000000cH
	push	eax
	call	_snprintf

; 25611: 			    ns = xmlSearchNs(defAttrOwnerElem->doc,

	lea	eax, DWORD PTR _prefix$1[ebp]
	inc	edi
	push	eax
	mov	eax, DWORD PTR _defAttrOwnerElem$1$[ebp]
	push	eax
	push	DWORD PTR [eax+32]
	call	_xmlSearchNs
	add	esp, 28					; 0000001cH

; 25612: 				defAttrOwnerElem, BAD_CAST prefix);
; 25613: 			    if (counter > 1000) {

	cmp	edi, 1000				; 000003e8H
	jg	$LN188@xmlSchemaV

; 25621: 			    }
; 25622: 			} while (ns != NULL);

	test	eax, eax
	jne	SHORT $LL19@xmlSchemaV

; 25623: 			ns = xmlNewNs(vctxt->validationRoot,

	lea	eax, DWORD PTR _prefix$1[ebp]
	push	eax
	push	DWORD PTR [esi+16]
	push	DWORD PTR [ebx+84]
	call	_xmlNewNs
	mov	edi, DWORD PTR _normValue$1$[ebp]
	add	esp, 12					; 0000000cH
$LN71@xmlSchemaV:

; 25624: 			    iattr->nsName, BAD_CAST prefix);
; 25625: 		    }
; 25626: 		    /*
; 25627: 		    * TODO:
; 25628: 		    * http://lists.w3.org/Archives/Public/www-xml-schema-comments/2005JulSep/0406.html
; 25629: 		    * If we have QNames: do we need to ensure there's a
; 25630: 		    * prefix defined for the QName?
; 25631: 		    */
; 25632: 		    xmlNewNsProp(defAttrOwnerElem, ns, iattr->localName, value);

	push	DWORD PTR tv1994[ebp]
	push	DWORD PTR [esi+12]
	push	eax
	push	DWORD PTR _defAttrOwnerElem$1$[ebp]
	call	_xmlNewNsProp
	add	esp, 16					; 00000010H
$LN68@xmlSchemaV:

; 25633: 		}
; 25634: 		if (normValue != NULL)

	test	edi, edi
	je	$LN234@xmlSchemaV

; 25635: 		    xmlFree(normValue);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 25636: 	    }
; 25637: 	    /*
; 25638: 	    * Go directly to IDC evaluation.
; 25639: 	    */
; 25640: 	    goto eval_idcs;

	jmp	$LN234@xmlSchemaV
$LN58@xmlSchemaV:

; 25641: 	}
; 25642: 	/*
; 25643: 	* Validate the value.
; 25644: 	*/
; 25645: 	if (vctxt->value != NULL) {

	mov	eax, DWORD PTR [ebx+72]
	test	eax, eax
	je	SHORT $LN75@xmlSchemaV

; 25646: 	    /*
; 25647: 	    * Free last computed value; just for safety reasons.
; 25648: 	    */
; 25649: 	    xmlSchemaFreeValue(vctxt->value);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4

; 25650: 	    vctxt->value = NULL;

	mov	DWORD PTR [ebx+72], 0
$LN75@xmlSchemaV:

; 25651: 	}
; 25652: 	/*
; 25653: 	* Note that the attribute *use* can be unavailable, if
; 25654: 	* the attribute was a wild attribute.
; 25655: 	*/
; 25656: 	if ((iattr->decl->flags & XML_SCHEMAS_ATTR_FIXED) ||

	mov	eax, DWORD PTR [esi+36]
	test	DWORD PTR [eax+60], 512			; 00000200H
	jne	SHORT $LN222@xmlSchemaV
	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN76@xmlSchemaV
	test	DWORD PTR [eax+16], 512			; 00000200H
	jne	SHORT $LN222@xmlSchemaV
$LN76@xmlSchemaV:

; 25660: 	else
; 25661: 	    fixed = 0;

	xor	edi, edi
	jmp	SHORT $LN77@xmlSchemaV
$LN222@xmlSchemaV:

; 25657: 	    ((iattr->use != NULL) &&
; 25658: 	     (iattr->use->flags & XML_SCHEMAS_ATTR_FIXED)))
; 25659: 	    fixed = 1;

	mov	edi, 1
$LN77@xmlSchemaV:

; 25662: 	/*
; 25663: 	* SPEC (cvc-attribute)
; 25664: 	* (3) "The item's `normalized value` must be locally `valid`
; 25665: 	* with respect to that {type definition} as per
; 25666: 	* String Valid ($3.14.4)."
; 25667: 	*
; 25668: 	* VAL TODO: Do we already have the
; 25669: 	* "normalized attribute value" here?
; 25670: 	*/
; 25671: 	if (xpathRes || fixed) {

	cmp	DWORD PTR _xpathRes$1$[ebp], 0
	jne	SHORT $LN81@xmlSchemaV
	test	edi, edi
	jne	SHORT $LN81@xmlSchemaV

; 25677: 		ACTXT_CAST vctxt,
; 25678: 		iattr->node, iattr->typeDef, iattr->value, &(iattr->val),
; 25679: 		1, 1, 0);
; 25680: 	} else {
; 25681: 	    res = xmlSchemaVCheckCVCSimpleType(

	xor	edx, edx
	mov	DWORD PTR $T2[ebp], edx
	jmp	SHORT $LN80@xmlSchemaV
$LN81@xmlSchemaV:

; 25672: 	    iattr->flags |= XML_SCHEMA_NODE_INFO_VALUE_NEEDED;

	or	DWORD PTR [esi+32], 16			; 00000010H

; 25673: 	    /*
; 25674: 	    * Request a computed value.
; 25675: 	    */
; 25676: 	    res = xmlSchemaVCheckCVCSimpleType(

	lea	edx, DWORD PTR [esi+24]
	mov	DWORD PTR $T2[ebp], 1
$LN80@xmlSchemaV:

; 25682: 		ACTXT_CAST vctxt,
; 25683: 		iattr->node, iattr->typeDef, iattr->value, NULL,
; 25684: 		1, 0, 0);
; 25685: 	}
; 25686: 
; 25687: 	if (res != 0) {

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+28]
	push	0
	push	DWORD PTR $T2[ebp]
	push	1
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	push	eax
	push	ebx
	call	_xmlSchemaVCheckCVCSimpleType
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN82@xmlSchemaV

; 25688: 	    if (res == -1) {

	cmp	eax, -1
	je	$LN195@xmlSchemaV

; 25692: 	    }
; 25693: 	    iattr->state = XML_SCHEMAS_ATTR_INVALID_VALUE;

	mov	DWORD PTR [esi+44], 5

; 25694: 	    /*
; 25695: 	    * SPEC PSVI Assessment Outcome (Attribute)
; 25696: 	    * [validity] = "invalid"
; 25697: 	    */
; 25698: 	    goto eval_idcs;

	jmp	$LN234@xmlSchemaV
$LN82@xmlSchemaV:

; 25699: 	}
; 25700: 
; 25701: 	if (fixed) {

	test	edi, edi
	je	$LN234@xmlSchemaV

; 25702: 	    /*
; 25703: 	    * SPEC Attribute Locally Valid (Use) (cvc-au)
; 25704: 	    * "For an attribute information item to be `valid`
; 25705: 	    * with respect to an attribute use its *normalized*
; 25706: 	    * value must match the *canonical* lexical
; 25707: 	    * representation of the attribute use's {value
; 25708: 	    * constraint}value, if it is present and fixed."
; 25709: 	    *
; 25710: 	    * VAL TODO: The requirement for the *canonical* value
; 25711: 	    * will be removed in XML Schema 1.1.
; 25712: 	    */
; 25713: 	    /*
; 25714: 	    * SPEC Attribute Locally Valid (cvc-attribute)
; 25715: 	    * (4) "The item's *actual* value must match the *value* of
; 25716: 	    * the {value constraint}, if it is present and fixed."
; 25717: 	    */
; 25718: 	    if (iattr->val == NULL) {

	mov	edx, DWORD PTR [esi+24]
	test	edx, edx
	jne	SHORT $LN85@xmlSchemaV

; 25719: 		/* VAL TODO: A value was not precomputed. */
; 25720: 		TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	25720					; 00006478H
$LN239@xmlSchemaV:

; 25754: 	    }
; 25755: 	    /*
; 25756: 	    * [validity] = "valid"
; 25757: 	    */
; 25758: 	}
; 25759: eval_idcs:
; 25760: 	/*
; 25761: 	* Evaluate IDCs.
; 25762: 	*/
; 25763: 	if (xpathRes) {

	push	OFFSET ??_C@_0GM@IJCDLDON@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	jmp	$LN234@xmlSchemaV
$LN85@xmlSchemaV:

; 25721: 		goto eval_idcs;
; 25722: 	    }
; 25723: 	    if ((iattr->use != NULL) &&

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN86@xmlSchemaV
	mov	ecx, DWORD PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LN86@xmlSchemaV

; 25724: 		(iattr->use->defValue != NULL)) {
; 25725: 		if (iattr->use->defVal == NULL) {

	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN88@xmlSchemaV

; 25726: 		    /* VAL TODO: A default value was not precomputed. */
; 25727: 		    TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	25727					; 0000647fH

; 25728: 		    goto eval_idcs;

	jmp	SHORT $LN239@xmlSchemaV
$LN88@xmlSchemaV:

; 25729: 		}
; 25730: 		iattr->vcValue = iattr->use->defValue;

	mov	DWORD PTR [esi+52], ecx

; 25731: 		/*
; 25732: 		if (xmlSchemaCompareValuesWhtsp(attr->val,
; 25733: 		    (xmlSchemaWhitespaceValueType) ws,
; 25734: 		    attr->use->defVal,
; 25735: 		    (xmlSchemaWhitespaceValueType) ws) != 0) {
; 25736: 		*/
; 25737: 		if (! xmlSchemaAreValuesEqual(iattr->val, iattr->use->defVal))

	push	DWORD PTR [eax+32]
	push	edx
	call	_xmlSchemaAreValuesEqual
	mov	edi, DWORD PTR _i$3$[ebp]
	add	esp, 8
	test	eax, eax
	jne	SHORT $eval_idcs$244

; 25738: 		    iattr->state = XML_SCHEMAS_ATTR_ERR_FIXED_VALUE;

	mov	DWORD PTR [esi+44], 7

; 25739: 	    } else {

	jmp	SHORT $eval_idcs$244
$LN86@xmlSchemaV:

; 25740: 		if (iattr->decl->defVal == NULL) {

	mov	ecx, DWORD PTR [esi+36]
	cmp	DWORD PTR [ecx+68], 0
	jne	SHORT $LN90@xmlSchemaV

; 25741: 		    /* VAL TODO: A default value was not precomputed. */
; 25742: 		    TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	25742					; 0000648eH

; 25743: 		    goto eval_idcs;

	jmp	SHORT $LN239@xmlSchemaV
$LN90@xmlSchemaV:

; 25744: 		}
; 25745: 		iattr->vcValue = iattr->decl->defValue;

	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [esi+52], eax

; 25746: 		/*
; 25747: 		if (xmlSchemaCompareValuesWhtsp(attr->val,
; 25748: 		    (xmlSchemaWhitespaceValueType) ws,
; 25749: 		    attrDecl->defVal,
; 25750: 		    (xmlSchemaWhitespaceValueType) ws) != 0) {
; 25751: 		*/
; 25752: 		if (! xmlSchemaAreValuesEqual(iattr->val, iattr->decl->defVal))

	push	DWORD PTR [ecx+68]
	push	edx
	call	_xmlSchemaAreValuesEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN234@xmlSchemaV

; 25753: 		    iattr->state = XML_SCHEMAS_ATTR_ERR_FIXED_VALUE;

	mov	DWORD PTR [esi+44], 7
$LN234@xmlSchemaV:

; 25754: 	    }
; 25755: 	    /*
; 25756: 	    * [validity] = "valid"
; 25757: 	    */
; 25758: 	}
; 25759: eval_idcs:
; 25760: 	/*
; 25761: 	* Evaluate IDCs.
; 25762: 	*/
; 25763: 	if (xpathRes) {

	mov	edi, DWORD PTR _i$3$[ebp]
$eval_idcs$244:
	cmp	DWORD PTR _xpathRes$1$[ebp], 0
	je	SHORT $LN221@xmlSchemaV

; 25764: 	    if (xmlSchemaXPathProcessHistory(vctxt,
; 25765: 		vctxt->depth +1) == -1) {

	mov	eax, DWORD PTR [ebx+96]
	inc	eax
	push	eax
	push	ebx
	call	_xmlSchemaXPathProcessHistory
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN14@xmlSchemaV
$LN196@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CB@OAMKHEAF@calling?5xmlSchemaXPathEvaluate?$CI@
$LN240@xmlSchemaV:

; 25836:     return (0);
; 25837: internal_error:
; 25838:     ACTIVATE_ELEM;

	push	OFFSET ??_C@_0BM@CHGONAOC@xmlSchemaVAttributesComplex@
	push	ebx
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$internal_error$245:
	mov	ecx, DWORD PTR [ebx+96]
	mov	eax, DWORD PTR [ebx+100]
	pop	edi

; 25840: }

	pop	esi
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [ebx+108], eax
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN221@xmlSchemaV:

; 25766: 		VERROR_INT("xmlSchemaVAttributesComplex",
; 25767: 		    "calling xmlSchemaXPathEvaluate()");
; 25768: 		goto internal_error;
; 25769: 	    }
; 25770: 	} else if (vctxt->xpathStates != NULL)

	mov	esi, DWORD PTR [ebx+116]
	test	esi, esi
	je	SHORT $LN14@xmlSchemaV
	npad	5
$LL137@xmlSchemaV:

; 22689: 	res = xmlStreamPop((xmlStreamCtxtPtr) sto->xpathCtxt);

	push	DWORD PTR [esi+32]
	call	_xmlStreamPop
	add	esp, 4

; 22690: 	if (res == -1)

	cmp	eax, -1
	je	SHORT $LN14@xmlSchemaV

; 22691: 	    return (-1);
; 22692: 	sto = sto->next;

	mov	esi, DWORD PTR [esi+4]

; 22693:     } while (sto != NULL);

	test	esi, esi
	jne	SHORT $LL137@xmlSchemaV
$LN14@xmlSchemaV:

; 25497: 	    defAttrOwnerElem = ielem->node;
; 25498:     }
; 25499:     /*
; 25500:     * Validate values, create default attributes, evaluate IDCs.
; 25501:     */
; 25502:     for (i = 0; i < vctxt->nbAttrInfos; i++) {

	mov	edx, DWORD PTR [ebx+168]
	inc	edi
	mov	DWORD PTR _i$3$[ebp], edi
	cmp	edi, edx
	jl	$LL16@xmlSchemaV
$LN227@xmlSchemaV:

; 25771: 	    xmlSchemaXPathPop(vctxt);
; 25772:     }
; 25773: 
; 25774:     /*
; 25775:     * Report errors.
; 25776:     */
; 25777:     for (i = 0; i < vctxt->nbAttrInfos; i++) {

	xor	edi, edi
	mov	DWORD PTR _i$4$[ebp], edi
	test	edx, edx
	jle	$LN21@xmlSchemaV
	npad	10
$LL22@xmlSchemaV:

; 25778: 	iattr = vctxt->attrInfos[i];

	mov	eax, DWORD PTR [ebx+164]
	mov	edx, DWORD PTR [eax+edi*4]

; 25779: 	if ((iattr->state == XML_SCHEMAS_ATTR_META) ||
; 25780: 	    (iattr->state == XML_SCHEMAS_ATTR_ASSESSED) ||
; 25781: 	    (iattr->state == XML_SCHEMAS_ATTR_WILD_SKIP) ||

	mov	eax, DWORD PTR [edx+44]
	cmp	eax, 17					; 00000011H
	je	$LN20@xmlSchemaV
	cmp	eax, 2
	je	$LN20@xmlSchemaV
	cmp	eax, 13					; 0000000dH
	je	$LN20@xmlSchemaV
	cmp	eax, 14					; 0000000eH
	je	$LN20@xmlSchemaV

; 25782: 	    (iattr->state == XML_SCHEMAS_ATTR_WILD_LAX_NO_DECL))
; 25783: 	    continue;
; 25784: 	ACTIVATE_ATTRIBUTE(iattr);

	mov	DWORD PTR [ebx+108], edx

; 25785: 	switch (iattr->state) {

	mov	eax, DWORD PTR [edx+44]
	dec	eax
	cmp	eax, 9
	ja	$LN20@xmlSchemaV
	jmp	DWORD PTR $LN243@xmlSchemaV[eax*4]
$LN188@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0DM@GNILNNDD@could?5not?5compute?5a?5ns?5prefix?5f@
	push	OFFSET ??_C@_0BM@CHGONAOC@xmlSchemaVAttributesComplex@
	push	ebx
	call	_xmlSchemaInternalErr2

; 25614: 				VERROR_INT(
; 25615: 				    "xmlSchemaVAttributesComplex",
; 25616: 				    "could not compute a ns prefix for a "
; 25617: 				    "default/fixed attribute");
; 25618: 				if (normValue != NULL)

	mov	eax, DWORD PTR _normValue$1$[ebp]

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	add	esp, 20					; 00000014H

; 25614: 				VERROR_INT(
; 25615: 				    "xmlSchemaVAttributesComplex",
; 25616: 				    "could not compute a ns prefix for a "
; 25617: 				    "default/fixed attribute");
; 25618: 				if (normValue != NULL)

	test	eax, eax
	je	$internal_error$245

; 25619: 				    xmlFree(normValue);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 25620: 				goto internal_error;

	jmp	$internal_error$245
$LN193@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BN@NBKJGHAJ@calling?5xmlSchemaCopyValue?$CI?$CJ@

; 25563: 		    VERROR_INT("xmlSchemaVAttributesComplex",
; 25564: 			"calling xmlSchemaCopyValue()");
; 25565: 		    goto internal_error;

	jmp	$LN240@xmlSchemaV
$LN192@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0DM@OLDNNBOE@default?1fixed?5value?5on?5an?5attri@

; 25556: 		    VERROR_INT("xmlSchemaVAttributesComplex",
; 25557: 			"default/fixed value on an attribute use was "
; 25558: 			"not precomputed");
; 25559: 		    goto internal_error;

	jmp	$LN240@xmlSchemaV
$LN195@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0DB@JPKGGAFI@calling?5xmlSchemaStreamValidate@

; 25689: 		VERROR_INT("xmlSchemaVAttributesComplex",
; 25690: 		    "calling xmlSchemaStreamValidateSimpleTypeValue()");
; 25691: 		goto internal_error;

	jmp	$LN240@xmlSchemaV
$LN98@xmlSchemaV:

; 25786: 	    case XML_SCHEMAS_ATTR_ERR_MISSING: {
; 25787: 		    xmlChar *str = NULL;
; 25788: 		    ACTIVATE_ELEM;

	mov	ecx, DWORD PTR [ebx+96]
	mov	eax, DWORD PTR [ebx+100]
	mov	DWORD PTR _str$3[ebp], 0
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [ebx+108], eax

; 25789: 		    xmlSchemaCustomErr(ACTXT_CAST vctxt,

	mov	eax, DWORD PTR [edx+36]
	push	DWORD PTR [eax+8]
	push	DWORD PTR [eax+56]
	lea	eax, DWORD PTR _str$3[ebp]
	push	eax
	call	_xmlSchemaFormatQName

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0

; 25789: 		    xmlSchemaCustomErr(ACTXT_CAST vctxt,

	mov	esi, eax

; 2339 :     xmlChar *msg = NULL;

	mov	DWORD PTR _msg$7[ebp], 0

; 2340 : 
; 2341 :     if ((node == NULL) && (item != NULL) &&
; 2342 : 	(actxt->type == XML_SCHEMA_CTXT_PARSER)) {
; 2343 : 	node = WXS_ITEM_NODE(item);
; 2344 : 	xmlSchemaFormatItemForReport(&msg, NULL, item, NULL);
; 2345 : 	msg = xmlStrcat(msg, BAD_CAST ": ");
; 2346 :     } else
; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	lea	eax, DWORD PTR _msg$7[ebp]
	push	ebx
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0CL@GFEDJBGB@The?5attribute?5?8?$CFs?8?5is?5required?5@
	push	DWORD PTR _msg$7[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$7[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	esi
	push	eax
	push	0
	push	0
	push	1868					; 0000074cH
	push	2
	push	ebx

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$7[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$7[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 80					; 00000050H

; 2352 :     FREE_AND_NULL(msg)

	test	eax, eax
	je	SHORT $LN146@xmlSchemaV
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN146@xmlSchemaV:

; 25790: 			XML_SCHEMAV_CVC_COMPLEX_TYPE_4, NULL, NULL,
; 25791: 			"The attribute '%s' is required but missing",
; 25792: 			xmlSchemaFormatQName(&str,
; 25793: 			    iattr->decl->targetNamespace,
; 25794: 			    iattr->decl->name),
; 25795: 			NULL);
; 25796: 		    FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$3[ebp]
$LN241@xmlSchemaV:

; 25771: 	    xmlSchemaXPathPop(vctxt);
; 25772:     }
; 25773: 
; 25774:     /*
; 25775:     * Report errors.
; 25776:     */
; 25777:     for (i = 0; i < vctxt->nbAttrInfos; i++) {

	test	eax, eax
	je	$LN20@xmlSchemaV
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	jmp	$LN20@xmlSchemaV
$LN100@xmlSchemaV:

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$6[ebp]
	mov	DWORD PTR _msg$6[ebp], 0
	push	ebx
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0BO@GOBNMKOB@The?5type?5definition?5is?5absent@
	push	DWORD PTR _msg$6[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$6[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	1862					; 00000746H
	push	2
	push	ebx

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$6[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$6[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 68					; 00000044H

; 25797: 		    break;
; 25798: 		}
; 25799: 	    case XML_SCHEMAS_ATTR_ERR_NO_TYPE:
; 25800: 		VERROR(XML_SCHEMAV_CVC_ATTRIBUTE_2, NULL,
; 25801: 		    "The type definition is absent");
; 25802: 		break;

	jmp	SHORT $LN241@xmlSchemaV
$LN101@xmlSchemaV:

; 25803: 	    case XML_SCHEMAS_ATTR_ERR_FIXED_VALUE:
; 25804: 		xmlSchemaCustomErr(ACTXT_CAST vctxt,

	mov	esi, DWORD PTR [edx+52]

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	lea	eax, DWORD PTR _msg$5[ebp]

; 25803: 	    case XML_SCHEMAS_ATTR_ERR_FIXED_VALUE:
; 25804: 		xmlSchemaCustomErr(ACTXT_CAST vctxt,

	mov	edi, DWORD PTR [edx+20]

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	push	ebx
	push	eax
	mov	DWORD PTR _msg$5[ebp], 0
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0DO@GPMMNIJO@The?5value?5?8?$CFs?8?5does?5not?5match?5t@
	push	DWORD PTR _msg$5[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$5[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	esi
	push	edi
	push	eax
	push	0
	push	0
	push	1874					; 00000752H
	push	2
	push	ebx

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$5[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$5[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 68					; 00000044H

; 2352 :     FREE_AND_NULL(msg)

	test	eax, eax
	je	SHORT $LN230@xmlSchemaV
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN230@xmlSchemaV:

; 25771: 	    xmlSchemaXPathPop(vctxt);
; 25772:     }
; 25773: 
; 25774:     /*
; 25775:     * Report errors.
; 25776:     */
; 25777:     for (i = 0; i < vctxt->nbAttrInfos; i++) {

	mov	edi, DWORD PTR _i$4$[ebp]
$LN20@xmlSchemaV:
	inc	edi
	mov	DWORD PTR _i$4$[ebp], edi
	cmp	edi, DWORD PTR [ebx+168]
	jl	$LL22@xmlSchemaV
$LN21@xmlSchemaV:

; 25827: 			XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2, iattr, NULL);
; 25828: 		}
; 25829: 		break;
; 25830: 	    default:
; 25831: 		break;
; 25832: 	}
; 25833:     }
; 25834: 
; 25835:     ACTIVATE_ELEM;

	mov	ecx, DWORD PTR [ebx+96]
	mov	eax, DWORD PTR [ebx+100]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [ebx+108], eax
$LN224@xmlSchemaV:

; 25840: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN102@xmlSchemaV:

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$4[ebp]
	mov	DWORD PTR _msg$4[ebp], 0
	push	ebx
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0FI@JBNMNHPF@No?5matching?5global?5attribute?5de@
	push	DWORD PTR _msg$4[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$4[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	1878					; 00000756H
	push	2
	push	ebx

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$4[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$4[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 68					; 00000044H

; 25805: 		    XML_SCHEMAV_CVC_AU, NULL, NULL,
; 25806: 		    "The value '%s' does not match the fixed "
; 25807: 		    "value constraint '%s'",
; 25808: 		    iattr->value, iattr->vcValue);
; 25809: 		break;
; 25810: 	    case XML_SCHEMAS_ATTR_ERR_WILD_STRICT_NO_DECL:
; 25811: 		VERROR(XML_SCHEMAV_CVC_WILDCARD, NULL,
; 25812: 		    "No matching global attribute declaration available, but "
; 25813: 		    "demanded by the strict wildcard");
; 25814: 		break;

	jmp	$LN241@xmlSchemaV
$LN103@xmlSchemaV:

; 25815: 	    case XML_SCHEMAS_ATTR_UNKNOWN:
; 25816: 		if (iattr->metaType)

	cmp	DWORD PTR [edx+48], 0
	jne	$LN20@xmlSchemaV

; 25817: 		    break;
; 25818: 		/*
; 25819: 		* MAYBE VAL TODO: One might report different error messages
; 25820: 		* for the following errors.
; 25821: 		*/
; 25822: 		if (type->attributeWildcard == NULL) {

	mov	eax, DWORD PTR _type$1$[ebp]
	push	0
	push	edx
	cmp	DWORD PTR [eax+84], 0
	jne	SHORT $LN105@xmlSchemaV

; 25823: 		    xmlSchemaIllegalAttrErr(ACTXT_CAST vctxt,

	push	1866					; 0000074aH
	push	ebx
	call	_xmlSchemaIllegalAttrErr
	add	esp, 16					; 00000010H

; 25824: 			XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1, iattr, NULL);
; 25825: 		} else {

	jmp	$LN20@xmlSchemaV
$LN105@xmlSchemaV:

; 25826: 		    xmlSchemaIllegalAttrErr(ACTXT_CAST vctxt,

	push	1867					; 0000074bH
	push	ebx
	call	_xmlSchemaIllegalAttrErr
	add	esp, 16					; 00000010H

; 2352 :     FREE_AND_NULL(msg)

	jmp	$LN20@xmlSchemaV
	npad	3
$LN243@xmlSchemaV:

; 25840: }

	DD	$LN103@xmlSchemaV
	DD	$LN20@xmlSchemaV
	DD	$LN20@xmlSchemaV
	DD	$LN98@xmlSchemaV
	DD	$LN20@xmlSchemaV
	DD	$LN100@xmlSchemaV
	DD	$LN101@xmlSchemaV
	DD	$LN20@xmlSchemaV
	DD	$LN20@xmlSchemaV
	DD	$LN102@xmlSchemaV
_xmlSchemaVAttributesComplex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaClearAttrInfos
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_xmlSchemaClearAttrInfos PROC				; COMDAT

; 25200: {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _vctxt$[ebp]
	mov	eax, DWORD PTR [ebx+168]
	test	eax, eax
	je	$LN1@xmlSchemaC

; 25201:     int i;
; 25202:     xmlSchemaAttrInfoPtr attr;
; 25203: 
; 25204:     if (vctxt->nbAttrInfos == 0)
; 25205: 	return;
; 25206:     for (i = 0; i < vctxt->nbAttrInfos; i++) {

	push	edi
	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN3@xmlSchemaC
	push	esi
	npad	9
$LL4@xmlSchemaC:

; 25207: 	attr = vctxt->attrInfos[i];

	mov	eax, DWORD PTR [ebx+164]
	mov	esi, DWORD PTR [eax+edi*4]

; 25208: 	if (attr->flags & XML_SCHEMA_NODE_INFO_FLAG_OWNED_NAMES) {

	test	BYTE PTR [esi+32], 1
	je	SHORT $LN8@xmlSchemaC

; 25209: 	    if (attr->localName != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN7@xmlSchemaC

; 25210: 		xmlFree((xmlChar *) attr->localName);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlSchemaC:

; 25211: 	    if (attr->nsName != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN8@xmlSchemaC

; 25212: 		xmlFree((xmlChar *) attr->nsName);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlSchemaC:

; 25213: 	}
; 25214: 	if (attr->flags & XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES) {

	test	BYTE PTR [esi+32], 2
	je	SHORT $LN10@xmlSchemaC

; 25215: 	    if (attr->value != NULL)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN10@xmlSchemaC

; 25216: 		xmlFree((xmlChar *) attr->value);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlSchemaC:

; 25217: 	}
; 25218: 	if (attr->val != NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN18@xmlSchemaC

; 25219: 	    xmlSchemaFreeValue(attr->val);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN18@xmlSchemaC:

; 25220: 	    attr->val = NULL;
; 25221: 	}
; 25222: 	memset(attr, 0, sizeof(xmlSchemaAttrInfo));

	push	60					; 0000003cH
	push	0
	push	esi
	call	_memset
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, DWORD PTR [ebx+168]
	jl	SHORT $LL4@xmlSchemaC
	pop	esi
$LN3@xmlSchemaC:

; 25223:     }
; 25224:     vctxt->nbAttrInfos = 0;

	mov	DWORD PTR [ebx+168], 0
	pop	edi
$LN1@xmlSchemaC:
	pop	ebx

; 25225: }

	pop	ebp
	ret	0
_xmlSchemaClearAttrInfos ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaVAttributesSimple
_TEXT	SEGMENT
_str$1 = -4						; size = 4
_ret$1$ = -4						; size = 4
_msg$2 = 8						; size = 4
_vctxt$ = 8						; size = 4
_xmlSchemaVAttributesSimple PROC			; COMDAT

; 25169: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _vctxt$[ebp]
	xor	eax, eax
	mov	DWORD PTR _ret$1$[ebp], eax
	mov	ecx, DWORD PTR [edi+168]
	test	ecx, ecx
	jne	SHORT $LN5@xmlSchemaV
	pop	edi

; 25193: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlSchemaV:
	push	esi

; 25170:     xmlSchemaAttrInfoPtr iattr;
; 25171:     int ret = 0, i;
; 25172: 
; 25173:     /*
; 25174:     * SPEC cvc-type (3.1.1)
; 25175:     * "The attributes of must be empty, excepting those whose namespace
; 25176:     * name is identical to http://www.w3.org/2001/XMLSchema-instance and
; 25177:     * whose local name is one of type, nil, schemaLocation or
; 25178:     * noNamespaceSchemaLocation."
; 25179:     */
; 25180:     if (vctxt->nbAttrInfos == 0)
; 25181: 	return (0);
; 25182:     for (i = 0; i < vctxt->nbAttrInfos; i++) {

	xor	esi, esi
	test	ecx, ecx
	jle	$LN3@xmlSchemaV
	push	ebx
$LL4@xmlSchemaV:

; 25183: 	iattr = vctxt->attrInfos[i];

	mov	eax, DWORD PTR [edi+164]
	mov	ebx, DWORD PTR [eax+esi*4]

; 25184: 	if (! iattr->metaType) {

	cmp	DWORD PTR [ebx+48], 0
	jne	$LN34@xmlSchemaV

; 2537 :     xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$2[ebp]

; 25185: 	    ACTIVATE_ATTRIBUTE(iattr)

	mov	DWORD PTR [edi+108], ebx

; 2537 :     xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	edi
	push	eax
	mov	DWORD PTR _msg$2[ebp], 0
	mov	DWORD PTR _str$1[ebp], 0
	call	_xmlSchemaFormatNodeForError

; 2538 :     msg = xmlStrcat(msg, BAD_CAST "The attribute '%s' is not allowed.\n");

	push	OFFSET ??_C@_0CE@FELNOPMA@The?5attribute?5?8?$CFs?8?5is?5not?5allow@
	push	DWORD PTR _msg$2[ebp]
	call	_xmlStrcat

; 2525 : 	return (xmlSchemaFormatQName(str, ni->nsName, ni->localName));

	push	DWORD PTR [ebx+12]

; 2538 :     msg = xmlStrcat(msg, BAD_CAST "The attribute '%s' is not allowed.\n");

	mov	DWORD PTR _msg$2[ebp], eax

; 2525 : 	return (xmlSchemaFormatQName(str, ni->nsName, ni->localName));

	lea	eax, DWORD PTR _str$1[ebp]
	push	DWORD PTR [ebx+16]
	push	eax
	call	_xmlSchemaFormatQName

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	eax
	push	DWORD PTR _msg$2[ebp]
	push	0
	push	0
	push	1827					; 00000723H
	push	2
	push	edi
	call	_xmlSchemaErr4Line

; 2542 :     FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$1[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 72					; 00000048H

; 2542 :     FREE_AND_NULL(str)

	test	eax, eax
	je	SHORT $LN9@xmlSchemaV
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlSchemaV:

; 2543 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$2[ebp]
	test	eax, eax
	je	SHORT $LN10@xmlSchemaV
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlSchemaV:

; 25186: 	    xmlSchemaIllegalAttrErr(ACTXT_CAST vctxt,
; 25187: 		XML_SCHEMAV_CVC_TYPE_3_1_1, iattr, NULL);
; 25188: 	    ret = XML_SCHEMAV_CVC_TYPE_3_1_1;

	mov	eax, 1827				; 00000723H
	mov	DWORD PTR _ret$1$[ebp], eax
	jmp	SHORT $LN2@xmlSchemaV
$LN34@xmlSchemaV:

; 25184: 	if (! iattr->metaType) {

	mov	eax, DWORD PTR _ret$1$[ebp]
$LN2@xmlSchemaV:

; 25170:     xmlSchemaAttrInfoPtr iattr;
; 25171:     int ret = 0, i;
; 25172: 
; 25173:     /*
; 25174:     * SPEC cvc-type (3.1.1)
; 25175:     * "The attributes of must be empty, excepting those whose namespace
; 25176:     * name is identical to http://www.w3.org/2001/XMLSchema-instance and
; 25177:     * whose local name is one of type, nil, schemaLocation or
; 25178:     * noNamespaceSchemaLocation."
; 25179:     */
; 25180:     if (vctxt->nbAttrInfos == 0)
; 25181: 	return (0);
; 25182:     for (i = 0; i < vctxt->nbAttrInfos; i++) {

	inc	esi
	cmp	esi, DWORD PTR [edi+168]
	jl	$LL4@xmlSchemaV
	pop	ebx
$LN3@xmlSchemaV:

; 25189:         }
; 25190:     }
; 25191:     ACTIVATE_ELEM

	mov	edx, DWORD PTR [edi+96]
	mov	ecx, DWORD PTR [edi+100]

; 25192:     return (ret);

	pop	esi
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edi+108], ecx
	pop	edi

; 25193: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaVAttributesSimple ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidateElemDecl
_TEXT	SEGMENT
tv549 = 8						; size = 4
_msg$1 = 8						; size = 4
_msg$2 = 8						; size = 4
_msg$3 = 8						; size = 4
_msg$4 = 8						; size = 4
_msg$5 = 8						; size = 4
_localType$6 = 8					; size = 4
_vctxt$ = 8						; size = 4
_xmlSchemaValidateElemDecl PROC				; COMDAT

; 25041: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _vctxt$[ebp]
	mov	eax, DWORD PTR [esi+108]
	mov	edi, DWORD PTR [eax+44]
	test	edi, edi
	jne	SHORT $LN2@xmlSchemaV

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	edi
	lea	eax, DWORD PTR _msg$5[ebp]
	mov	DWORD PTR _msg$5[ebp], edi
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0CC@POINHACG@No?5matching?5declaration?5availab@
	push	DWORD PTR _msg$5[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$5[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	edi
	push	edi
	push	edi
	push	edi
	push	eax
	push	edi
	push	edi
	push	1845					; 00000735H
	push	2
	push	esi

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$5[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$5[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 68					; 00000044H

; 2352 :     FREE_AND_NULL(msg)

	test	eax, eax
	je	SHORT $LN26@xmlSchemaV
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN26@xmlSchemaV:

; 25042:     xmlSchemaElementPtr elemDecl = vctxt->inode->decl;
; 25043:     xmlSchemaTypePtr actualType;
; 25044: 
; 25045:     /*
; 25046:     * cvc-elt (3.3.4) : 1
; 25047:     */
; 25048:     if (elemDecl == NULL) {
; 25049: 	VERROR(XML_SCHEMAV_CVC_ELT_1, NULL,
; 25050: 	    "No matching declaration available");
; 25051:         return (vctxt->err);

	mov	eax, DWORD PTR [esi+52]
	pop	edi

; 25165: }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlSchemaV:

; 25052:     }
; 25053:     actualType = WXS_ELEM_TYPEDEF(elemDecl);
; 25054:     /*
; 25055:     * cvc-elt (3.3.4) : 2
; 25056:     */
; 25057:     if (elemDecl->flags & XML_SCHEMAS_ELEM_ABSTRACT) {

	test	BYTE PTR [edi+48], 16			; 00000010H
	push	ebx
	mov	ebx, DWORD PTR [edi+28]
	je	SHORT $LN3@xmlSchemaV

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$4[ebp]
	mov	DWORD PTR _msg$4[ebp], 0
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0CE@FKPBKJME@The?5element?5declaration?5is?5abst@
	push	DWORD PTR _msg$4[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$4[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	1846					; 00000736H
	push	2
	push	esi

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$4[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$4[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 68					; 00000044H

; 2352 :     FREE_AND_NULL(msg)

	test	eax, eax
	je	SHORT $LN35@xmlSchemaV
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN35@xmlSchemaV:

; 25058: 	VERROR(XML_SCHEMAV_CVC_ELT_2, NULL,
; 25059: 	    "The element declaration is abstract");
; 25060:         return (vctxt->err);

	mov	eax, DWORD PTR [esi+52]
	pop	ebx
	pop	edi

; 25165: }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlSchemaV:

; 25061:     }
; 25062:     if (actualType == NULL) {

	test	ebx, ebx
	je	$LN77@xmlSchemaV

; 25063: 	VERROR(XML_SCHEMAV_CVC_TYPE_1, NULL,
; 25064: 	    "The type definition is absent");
; 25065: 	return (XML_SCHEMAV_CVC_TYPE_1);
; 25066:     }
; 25067:     if (vctxt->nbAttrInfos != 0) {

	cmp	DWORD PTR [esi+168], 0
	je	$LN17@xmlSchemaV

; 25068: 	int ret;
; 25069: 	xmlSchemaAttrInfoPtr iattr;
; 25070: 	/*
; 25071: 	* cvc-elt (3.3.4) : 3
; 25072: 	* Handle 'xsi:nil'.
; 25073: 	*/
; 25074: 	iattr = xmlSchemaGetMetaAttrInfo(vctxt,

	push	2
	push	esi
	call	_xmlSchemaGetMetaAttrInfo
	add	esp, 8

; 25075: 	    XML_SCHEMA_ATTR_INFO_META_XSI_NIL);
; 25076: 	if (iattr) {

	test	eax, eax
	je	$LN13@xmlSchemaV

; 25077: 	    ACTIVATE_ATTRIBUTE(iattr);
; 25078: 	    /*
; 25079: 	    * Validate the value.
; 25080: 	    */
; 25081: 	    ret = xmlSchemaVCheckCVCSimpleType(

	push	0
	push	0
	lea	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [esi+108], eax
	push	1
	push	ecx
	push	DWORD PTR [eax+20]
	mov	DWORD PTR tv549[ebp], ecx
	push	15					; 0000000fH
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	push	eax
	push	0
	push	esi
	call	_xmlSchemaVCheckCVCSimpleType

; 25082: 		ACTXT_CAST vctxt, NULL,
; 25083: 		xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
; 25084: 		iattr->value, &(iattr->val), 1, 0, 0);
; 25085: 	    ACTIVATE_ELEM;

	mov	edx, DWORD PTR [esi+96]
	add	esp, 32					; 00000020H
	mov	ecx, DWORD PTR [esi+100]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [esi+108], ecx

; 25086: 	    if (ret < 0) {

	test	eax, eax
	jns	SHORT $LN78@xmlSchemaV

; 25087: 		VERROR_INT("xmlSchemaValidateElemDecl",

	push	OFFSET ??_C@_0EL@BODABIJH@calling?5xmlSchemaVCheckCVCSimpl@

; 25088: 		    "calling xmlSchemaVCheckCVCSimpleType() to "
; 25089: 		    "validate the attribute 'xsi:nil'");
; 25090: 		return (-1);

	jmp	$LN81@xmlSchemaV
$LN78@xmlSchemaV:

; 25091: 	    }
; 25092: 	    if (ret == 0) {

	jne	$LN13@xmlSchemaV

; 25093: 		if ((elemDecl->flags & XML_SCHEMAS_ELEM_NILLABLE) == 0) {

	test	BYTE PTR [edi+48], 1
	jne	SHORT $LN9@xmlSchemaV

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$3[ebp]
	mov	DWORD PTR _msg$3[ebp], 0
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0BO@NGOMKCIG@The?5element?5is?5not?5?8nillable?8@
	push	DWORD PTR _msg$3[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$3[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	1847					; 00000737H

; 25094: 		    /*
; 25095: 		    * cvc-elt (3.3.4) : 3.1
; 25096: 		    */
; 25097: 		    VERROR(XML_SCHEMAV_CVC_ELT_3_1, NULL,
; 25098: 			"The element is not 'nillable'");
; 25099: 		    /* Does not return an error on purpose. */
; 25100: 		} else {

	jmp	SHORT $LN82@xmlSchemaV
$LN9@xmlSchemaV:

; 25101: 		    if (xmlSchemaValueGetAsBoolean(iattr->val)) {

	mov	eax, DWORD PTR tv549[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaValueGetAsBoolean
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@xmlSchemaV

; 25102: 			/*
; 25103: 			* cvc-elt (3.3.4) : 3.2.2
; 25104: 			*/
; 25105: 			if ((elemDecl->flags & XML_SCHEMAS_ELEM_FIXED) &&

	test	BYTE PTR [edi+48], 8
	je	SHORT $LN12@xmlSchemaV
	cmp	DWORD PTR [edi+76], 0
	je	SHORT $LN12@xmlSchemaV

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$2[ebp]
	mov	DWORD PTR _msg$2[ebp], 0
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0FI@EHNCBIIJ@The?5element?5cannot?5be?5?8nilled?8?5@
	push	DWORD PTR _msg$2[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$2[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	1849					; 00000739H
$LN82@xmlSchemaV:

; 25114: 				XML_SCHEMA_ELEM_INFO_NILLED;
; 25115: 		    }
; 25116: 		}
; 25117: 	    }
; 25118: 	}
; 25119: 	/*
; 25120: 	* cvc-elt (3.3.4) : 4
; 25121: 	* Handle 'xsi:type'.
; 25122: 	*/
; 25123: 	iattr = xmlSchemaGetMetaAttrInfo(vctxt,

	push	2
	push	esi
	mov	DWORD PTR _msg$2[ebp], eax
	call	_xmlSchemaErr4Line
	mov	eax, DWORD PTR _msg$2[ebp]
	add	esp, 68					; 00000044H
	test	eax, eax
	je	SHORT $LN13@xmlSchemaV
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	jmp	SHORT $LN13@xmlSchemaV
$LN12@xmlSchemaV:

; 25106: 			    (elemDecl->value != NULL)) {
; 25107: 			    VERROR(XML_SCHEMAV_CVC_ELT_3_2_2, NULL,
; 25108: 				"The element cannot be 'nilled' because "
; 25109: 				"there is a fixed value constraint defined "
; 25110: 				"for it");
; 25111: 			     /* Does not return an error on purpose. */
; 25112: 			} else
; 25113: 			    vctxt->inode->flags |=

	mov	eax, DWORD PTR [esi+108]
	or	DWORD PTR [eax+32], 4
$LN13@xmlSchemaV:

; 25114: 				XML_SCHEMA_ELEM_INFO_NILLED;
; 25115: 		    }
; 25116: 		}
; 25117: 	    }
; 25118: 	}
; 25119: 	/*
; 25120: 	* cvc-elt (3.3.4) : 4
; 25121: 	* Handle 'xsi:type'.
; 25122: 	*/
; 25123: 	iattr = xmlSchemaGetMetaAttrInfo(vctxt,

	push	1
	push	esi
	call	_xmlSchemaGetMetaAttrInfo
	add	esp, 8

; 25124: 	    XML_SCHEMA_ATTR_INFO_META_XSI_TYPE);
; 25125: 	if (iattr) {

	test	eax, eax
	je	SHORT $LN17@xmlSchemaV

; 25126: 	    xmlSchemaTypePtr localType = NULL;
; 25127: 
; 25128: 	    ret = xmlSchemaProcessXSIType(vctxt, iattr, &localType,

	push	edi
	lea	ecx, DWORD PTR _localType$6[ebp]
	mov	DWORD PTR _localType$6[ebp], 0
	push	ecx
	push	eax
	push	esi
	call	_xmlSchemaProcessXSIType
	add	esp, 16					; 00000010H

; 25129: 		elemDecl);
; 25130: 	    if (ret != 0) {

	test	eax, eax
	je	SHORT $LN16@xmlSchemaV

; 25131: 		if (ret == -1) {

	cmp	eax, -1
	jne	SHORT $LN16@xmlSchemaV

; 25132: 		    VERROR_INT("xmlSchemaValidateElemDecl",

	push	OFFSET ??_C@_0EG@NIGOCKPL@calling?5xmlSchemaProcessXSIType@
$LN81@xmlSchemaV:
	push	OFFSET ??_C@_0BK@OGPCMEDL@xmlSchemaValidateElemDecl@
	push	esi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH
$LN80@xmlSchemaV:

; 25133: 			"calling xmlSchemaProcessXSIType() to "
; 25134: 			"process the attribute 'xsi:type'");
; 25135: 		    return (-1);

	pop	ebx
	pop	edi
	or	eax, -1

; 25165: }

	pop	esi
	pop	ebp
	ret	0
$LN16@xmlSchemaV:

; 25136: 		}
; 25137: 		/* Does not return an error on purpose. */
; 25138: 	    }
; 25139: 	    if (localType != NULL) {

	mov	ecx, DWORD PTR _localType$6[ebp]
	test	ecx, ecx
	je	SHORT $LN17@xmlSchemaV

; 25140: 		vctxt->inode->flags |= XML_SCHEMA_ELEM_INFO_LOCAL_TYPE;

	mov	eax, DWORD PTR [esi+108]

; 25141: 		actualType = localType;

	mov	ebx, ecx
	or	DWORD PTR [eax+32], 8
$LN17@xmlSchemaV:

; 25142: 	    }
; 25143: 	}
; 25144:     }
; 25145:     /*
; 25146:     * IDC: Register identity-constraint XPath matchers.
; 25147:     */
; 25148:     if ((elemDecl->idcs != NULL) &&

	cmp	DWORD PTR [edi+100], 0
	je	SHORT $LN18@xmlSchemaV
	push	edi
	push	esi
	call	_xmlSchemaIDCRegisterMatchers
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN80@xmlSchemaV
$LN18@xmlSchemaV:

; 25149: 	(xmlSchemaIDCRegisterMatchers(vctxt, elemDecl) == -1))
; 25150: 	    return (-1);
; 25151:     /*
; 25152:     * No actual type definition.
; 25153:     */
; 25154:     if (actualType == NULL) {

	test	ebx, ebx
	jne	SHORT $LN19@xmlSchemaV
$LN77@xmlSchemaV:

; 25155: 	VERROR(XML_SCHEMAV_CVC_TYPE_1, NULL,
; 25156: 	    "The type definition is absent");
; 25157: 	return (XML_SCHEMAV_CVC_TYPE_1);

	push	0
	lea	eax, DWORD PTR _msg$1[ebp]
	mov	DWORD PTR _msg$1[ebp], 0
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError
	push	OFFSET ??_C@_0BO@GOBNMKOB@The?5type?5definition?5is?5absent@
	push	DWORD PTR _msg$1[ebp]
	call	_xmlStrcat
	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlStrcat
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	1875					; 00000753H
	push	2
	push	esi
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlSchemaErr4Line
	mov	eax, DWORD PTR _msg$1[ebp]
	add	esp, 68					; 00000044H
	test	eax, eax
	je	SHORT $LN71@xmlSchemaV
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN71@xmlSchemaV:
	pop	ebx
	pop	edi
	mov	eax, 1875				; 00000753H

; 25165: }

	pop	esi
	pop	ebp
	ret	0
$LN19@xmlSchemaV:

; 25158:     }
; 25159:     /*
; 25160:     * Remember the actual type definition.
; 25161:     */
; 25162:     vctxt->inode->typeDef = actualType;

	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [eax+28], ebx

; 25163: 
; 25164:     return (0);

	xor	eax, eax
	pop	ebx
	pop	edi

; 25165: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaValidateElemDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaProcessXSIType
_TEXT	SEGMENT
tv528 = -12						; size = 4
_local$1$ = -12						; size = 4
_nsName$1$ = -12					; size = 4
_str$1 = -12						; size = 4
_prefix$2 = -8						; size = 4
_local$1$ = -4						; size = 4
_vctxt$ = 8						; size = 4
_iattr$ = 12						; size = 4
_msg$3 = 16						; size = 4
_str$4 = 16						; size = 4
_localType$ = 16					; size = 4
_elemDecl$ = 20						; size = 4
_xmlSchemaProcessXSIType PROC				; COMDAT

; 24914: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	ebx
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _localType$[ebp]
	test	ebx, ebx
	jne	SHORT $LN2@xmlSchemaP

; 24915:     int ret = 0;
; 24916:     /*
; 24917:     * cvc-elt (3.3.4) : (4)
; 24918:     * AND
; 24919:     * Schema-Validity Assessment (Element) (cvc-assess-elt)
; 24920:     *   (1.2.1.2.1) - (1.2.1.2.4)
; 24921:     * Handle 'xsi:type'.
; 24922:     */
; 24923:     if (localType == NULL)
; 24924: 	return (-1);

	or	eax, -1
	pop	ebx

; 25037: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlSchemaP:
	push	esi

; 24925:     *localType = NULL;
; 24926:     if (iattr == NULL)

	mov	esi, DWORD PTR _iattr$[ebp]
	mov	DWORD PTR [ebx], 0
	test	esi, esi
	jne	SHORT $LN3@xmlSchemaP

; 24927: 	return (0);

	pop	esi
	xor	eax, eax
	pop	ebx

; 25037: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlSchemaP:
	push	edi

; 24928:     else {
; 24929: 	const xmlChar *nsName = NULL, *local = NULL;
; 24930: 	/*
; 24931: 	* TODO: We should report a *warning* that the type was overriden
; 24932: 	* by the instance.
; 24933: 	*/
; 24934: 	ACTIVATE_ATTRIBUTE(iattr);

	mov	edi, DWORD PTR _vctxt$[ebp]

; 24863:     ret = xmlValidateQName(value, 1);

	push	1

; 24928:     else {
; 24929: 	const xmlChar *nsName = NULL, *local = NULL;
; 24930: 	/*
; 24931: 	* TODO: We should report a *warning* that the type was overriden
; 24932: 	* by the instance.
; 24933: 	*/
; 24934: 	ACTIVATE_ATTRIBUTE(iattr);

	mov	DWORD PTR [edi+108], esi

; 24935: 	/*
; 24936: 	* (cvc-elt) (3.3.4) : (4.1)
; 24937: 	* (cvc-assess-elt) (1.2.1.2.2)
; 24938: 	*/
; 24939: 	ret = xmlSchemaVExpandQName(vctxt, iattr->value,

	mov	esi, DWORD PTR [esi+20]

; 24863:     ret = xmlValidateQName(value, 1);

	push	esi
	call	_xmlValidateQName
	add	esp, 8

; 24864:     if (ret == -1)

	cmp	eax, -1
	je	$LN43@xmlSchemaP

; 24865: 	return (-1);
; 24866:     if (ret > 0) {

	test	eax, eax
	jle	SHORT $LN21@xmlSchemaP

; 24867: 	xmlSchemaSimpleTypeErr(ACTXT_CAST vctxt,

	push	1
	push	21					; 00000015H
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	push	eax
	push	esi
	push	0
	push	1824					; 00000720H
	push	edi
	call	_xmlSchemaSimpleTypeErr

; 25028: 	    }
; 25029: 	}
; 25030:     }
; 25031: exit:
; 25032:     ACTIVATE_ELEM;

	mov	edx, DWORD PTR [edi+96]

; 24867: 	xmlSchemaSimpleTypeErr(ACTXT_CAST vctxt,

	add	esp, 24					; 00000018H

; 25028: 	    }
; 25029: 	}
; 25030:     }
; 25031: exit:
; 25032:     ACTIVATE_ELEM;

	mov	ecx, DWORD PTR [edi+100]

; 24870: 	return (1);

	mov	esi, 1

; 25033:     return (ret);

	mov	eax, esi
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edi+108], ecx
	pop	edi
	pop	esi
	pop	ebx

; 25037: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlSchemaP:

; 24880: 	local = xmlSplitQName2(value, &prefix);

	lea	eax, DWORD PTR _prefix$2[ebp]
	push	eax
	push	esi
	call	_xmlSplitQName2
	mov	ecx, DWORD PTR [edi+156]
	add	esp, 8
	mov	DWORD PTR _local$1$[ebp], eax

; 24881: 	if (local == NULL)

	push	-1
	test	eax, eax
	jne	SHORT $LN22@xmlSchemaP

; 24882: 	    *localName = xmlDictLookup(vctxt->dict, value, -1);

	push	esi
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _local$1$[ebp], eax
	jmp	SHORT $LN23@xmlSchemaP
$LN22@xmlSchemaP:

; 24883: 	else {
; 24884: 	    *localName = xmlDictLookup(vctxt->dict, local, -1);

	push	eax
	push	ecx
	call	_xmlDictLookup

; 24885: 	    xmlFree(local);

	push	DWORD PTR _local$1$[ebp]
	mov	DWORD PTR _local$1$[ebp], eax
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H
$LN23@xmlSchemaP:

; 24886: 	}
; 24887: 
; 24888: 	*nsName = xmlSchemaLookupNamespace(vctxt, prefix);

	push	DWORD PTR _prefix$2[ebp]
	push	edi
	call	_xmlSchemaLookupNamespace

; 24889: 
; 24890: 	if (prefix != NULL) {

	mov	ecx, DWORD PTR _prefix$2[ebp]
	add	esp, 8
	mov	DWORD PTR _nsName$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN25@xmlSchemaP

; 24891: 	    xmlFree(prefix);

	push	ecx
	call	DWORD PTR _xmlFree

; 24892: 	    /*
; 24893: 	    * A namespace must be found if the prefix is NOT NULL.
; 24894: 	    */
; 24895: 	    if (*nsName == NULL) {

	mov	eax, DWORD PTR _nsName$1$[ebp]
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN25@xmlSchemaP

; 24896: 		xmlSchemaCustomErr(ACTXT_CAST vctxt,

	push	eax
	push	esi
	push	OFFSET ??_C@_0EJ@KJCHOIHD@The?5QName?5value?5?8?$CFs?8?5has?5no?5cor@
	push	21					; 00000015H
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	push	eax
	push	0
	push	1824					; 00000720H
	push	edi
	call	_xmlSchemaCustomErr

; 25028: 	    }
; 25029: 	}
; 25030:     }
; 25031: exit:
; 25032:     ACTIVATE_ELEM;

	mov	edx, DWORD PTR [edi+96]

; 24896: 		xmlSchemaCustomErr(ACTXT_CAST vctxt,

	add	esp, 28					; 0000001cH

; 25028: 	    }
; 25029: 	}
; 25030:     }
; 25031: exit:
; 25032:     ACTIVATE_ELEM;

	mov	ecx, DWORD PTR [edi+100]

; 24902: 		return (2);

	mov	esi, 2

; 25033:     return (ret);

	mov	eax, esi
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edi+108], ecx
	pop	edi
	pop	esi
	pop	ebx

; 25037: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlSchemaP:

; 24940: 	    &nsName, &local);
; 24941: 	if (ret != 0) {
; 24942: 	    if (ret < 0) {
; 24943: 		VERROR_INT("xmlSchemaValidateElementByDeclaration",
; 24944: 		    "calling xmlSchemaQNameExpand() to validate the "
; 24945: 		    "attribute 'xsi:type'");
; 24946: 		goto internal_error;
; 24947: 	    }
; 24948: 	    goto exit;
; 24949: 	}
; 24950: 	/*
; 24951: 	* (cvc-elt) (3.3.4) : (4.2)
; 24952: 	* (cvc-assess-elt) (1.2.1.2.3)
; 24953: 	*/
; 24954: 	*localType = xmlSchemaGetType(vctxt->schema, local, nsName);

	push	eax
	push	DWORD PTR _local$1$[ebp]

; 24906:     return (0);

	xor	esi, esi

; 24940: 	    &nsName, &local);
; 24941: 	if (ret != 0) {
; 24942: 	    if (ret < 0) {
; 24943: 		VERROR_INT("xmlSchemaValidateElementByDeclaration",
; 24944: 		    "calling xmlSchemaQNameExpand() to validate the "
; 24945: 		    "attribute 'xsi:type'");
; 24946: 		goto internal_error;
; 24947: 	    }
; 24948: 	    goto exit;
; 24949: 	}
; 24950: 	/*
; 24951: 	* (cvc-elt) (3.3.4) : (4.2)
; 24952: 	* (cvc-assess-elt) (1.2.1.2.3)
; 24953: 	*/
; 24954: 	*localType = xmlSchemaGetType(vctxt->schema, local, nsName);

	push	DWORD PTR [edi+20]
	call	_xmlSchemaGetType
	mov	edx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebx], edx

; 24955: 	if (*localType == NULL) {

	test	edx, edx
	jne	SHORT $LN7@xmlSchemaP

; 24956: 	    xmlChar *str = NULL;
; 24957: 
; 24958: 	    xmlSchemaCustomErr(ACTXT_CAST vctxt,

	push	DWORD PTR _local$1$[ebp]
	lea	eax, DWORD PTR _str$4[ebp]
	mov	DWORD PTR _str$4[ebp], esi
	push	DWORD PTR _nsName$1$[ebp]
	push	eax
	call	_xmlSchemaFormatQName
	push	21					; 00000015H
	mov	esi, eax
	call	_xmlSchemaGetBuiltInType

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	0
	push	0
	push	0
	push	esi
	push	OFFSET ??_C@_0FF@GCDILCEF@The?5QName?5value?5?8?$CFs?8?5of?5the?5xsi@
	push	eax
	push	0
	push	1851					; 0000073bH
	push	edi
	call	_xmlSchemaCustomErr4

; 24959: 		XML_SCHEMAV_CVC_ELT_4_2, NULL,
; 24960: 		WXS_BASIC_CAST xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),
; 24961: 		"The QName value '%s' of the xsi:type attribute does not "
; 24962: 		"resolve to a type definition",
; 24963: 		xmlSchemaFormatQName(&str, nsName, local), NULL);
; 24964: 	    FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$4[ebp]

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	add	esp, 52					; 00000034H

; 24959: 		XML_SCHEMAV_CVC_ELT_4_2, NULL,
; 24960: 		WXS_BASIC_CAST xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),
; 24961: 		"The QName value '%s' of the xsi:type attribute does not "
; 24962: 		"resolve to a type definition",
; 24963: 		xmlSchemaFormatQName(&str, nsName, local), NULL);
; 24964: 	    FREE_AND_NULL(str);

	test	eax, eax
	je	SHORT $LN8@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlSchemaP:

; 25028: 	    }
; 25029: 	}
; 25030:     }
; 25031: exit:
; 25032:     ACTIVATE_ELEM;

	mov	edx, DWORD PTR [edi+96]
	mov	ecx, DWORD PTR [edi+100]
	mov	esi, DWORD PTR [edi+52]

; 25033:     return (ret);

	mov	eax, esi
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edi+108], ecx
	pop	edi
	pop	esi
	pop	ebx

; 25037: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlSchemaP:

; 24965: 	    ret = vctxt->err;
; 24966: 	    goto exit;
; 24967: 	}
; 24968: 	if (elemDecl != NULL) {

	mov	ecx, DWORD PTR _elemDecl$[ebp]
	test	ecx, ecx
	je	$exit$47

; 24969: 	    int set = 0;
; 24970: 
; 24971: 	    /*
; 24972: 	    * SPEC cvc-elt (3.3.4) : (4.3) (Type Derivation OK)
; 24973: 	    * "The `local type definition` must be validly
; 24974: 	    * derived from the {type definition} given the union of
; 24975: 	    * the {disallowed substitutions} and the {type definition}'s
; 24976: 	    * {prohibited substitutions}, as defined in
; 24977: 	    * Type Derivation OK (Complex) ($3.4.6)
; 24978: 	    * (if it is a complex type definition),
; 24979: 	    * or given {disallowed substitutions} as defined in Type
; 24980: 	    * Derivation OK (Simple) ($3.14.6) (if it is a simple type
; 24981: 	    * definition)."
; 24982: 	    *
; 24983: 	    * {disallowed substitutions}: the "block" on the element decl.
; 24984: 	    * {prohibited substitutions}: the "block" on the type def.
; 24985: 	    */
; 24986: 	    /*
; 24987: 	    * OPTIMIZE TODO: We could map types already evaluated
; 24988: 	    * to be validly derived from other types to avoid checking
; 24989: 	    * this over and over for the same types.
; 24990: 	    */
; 24991: 	    if ((elemDecl->flags & XML_SCHEMAS_ELEM_BLOCK_EXTENSION) ||

	mov	ebx, DWORD PTR [ecx+48]
	xor	eax, eax
	mov	ecx, DWORD PTR [ecx+28]
	test	ebx, 2048				; 00000800H
	mov	DWORD PTR tv528[ebp], ebx
	mov	ebx, DWORD PTR _localType$[ebp]
	jne	SHORT $LN40@xmlSchemaP
	test	DWORD PTR [ecx+48], 262144		; 00040000H
	je	SHORT $LN10@xmlSchemaP
$LN40@xmlSchemaP:

; 24992: 		(elemDecl->subtypes->flags &
; 24993: 		    XML_SCHEMAS_TYPE_BLOCK_EXTENSION))
; 24994: 		set |= SUBSET_EXTENSION;

	mov	eax, 2
$LN10@xmlSchemaP:

; 24995: 
; 24996: 	    if ((elemDecl->flags & XML_SCHEMAS_ELEM_BLOCK_RESTRICTION) ||

	test	DWORD PTR tv528[ebp], 4096		; 00001000H
	jne	SHORT $LN13@xmlSchemaP
	test	DWORD PTR [ecx+48], 524288		; 00080000H
	je	SHORT $LN12@xmlSchemaP
$LN13@xmlSchemaP:

; 24997: 		(elemDecl->subtypes->flags &
; 24998: 		    XML_SCHEMAS_TYPE_BLOCK_RESTRICTION))
; 24999: 		set |= SUBSET_RESTRICTION;

	or	eax, 1
$LN12@xmlSchemaP:

; 25000: 
; 25001: 	    /*
; 25002: 	    * REMOVED and CHANGED since this produced a parser context
; 25003: 	    * which adds to the string dict of the schema. So this would
; 25004: 	    * change the schema and we don't want this. We don't need
; 25005: 	    * the parser context anymore.
; 25006: 	    *
; 25007: 	    * if ((vctxt->pctxt == NULL) &&
; 25008: 	    *	(xmlSchemaCreatePCtxtOnVCtxt(vctxt) == -1))
; 25009: 	    *	    return (-1);
; 25010: 	    */
; 25011: 
; 25012: 	    if (xmlSchemaCheckCOSDerivedOK(ACTXT_CAST vctxt, *localType,
; 25013: 		elemDecl->subtypes, set) != 0) {

	push	eax
	push	ecx
	push	edx
	push	edi
	call	_xmlSchemaCheckCOSDerivedOK
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$exit$47

; 25014: 		xmlChar *str = NULL;
; 25015: 
; 25016: 		xmlSchemaCustomErr(ACTXT_CAST vctxt,

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR _str$1[ebp], esi
	push	DWORD PTR [eax+8]
	push	DWORD PTR [eax+112]
	lea	eax, DWORD PTR _str$1[ebp]
	push	eax
	call	_xmlSchemaFormatQName

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0

; 25014: 		xmlChar *str = NULL;
; 25015: 
; 25016: 		xmlSchemaCustomErr(ACTXT_CAST vctxt,

	mov	esi, eax

; 2339 :     xmlChar *msg = NULL;

	mov	DWORD PTR _msg$3[ebp], 0

; 2340 : 
; 2341 :     if ((node == NULL) && (item != NULL) &&
; 2342 : 	(actxt->type == XML_SCHEMA_CTXT_PARSER)) {
; 2343 : 	node = WXS_ITEM_NODE(item);
; 2344 : 	xmlSchemaFormatItemForReport(&msg, NULL, item, NULL);
; 2345 : 	msg = xmlStrcat(msg, BAD_CAST ": ");
; 2346 :     } else
; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	lea	eax, DWORD PTR _msg$3[ebp]
	push	edi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0IH@GEMBEHDJ@The?5type?5definition?5?8?$CFs?8?0?5speci@
	push	DWORD PTR _msg$3[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$3[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	esi
	push	eax
	push	0
	push	0
	push	1852					; 0000073cH
	push	2
	push	edi

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$3[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$3[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 80					; 00000050H

; 2352 :     FREE_AND_NULL(msg)

	test	eax, eax
	je	SHORT $LN36@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN36@xmlSchemaP:

; 25017: 		    XML_SCHEMAV_CVC_ELT_4_3, NULL, NULL,
; 25018: 		    "The type definition '%s', specified by xsi:type, is "
; 25019: 		    "blocked or not validly derived from the type definition "
; 25020: 		    "of the element declaration",
; 25021: 		    xmlSchemaFormatQName(&str,
; 25022: 			(*localType)->targetNamespace,
; 25023: 			(*localType)->name),
; 25024: 		    NULL);
; 25025: 		FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$1[ebp]
	test	eax, eax
	je	SHORT $LN15@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlSchemaP:

; 25026: 		ret = vctxt->err;

	mov	esi, DWORD PTR [edi+52]

; 25027: 		*localType = NULL;

	mov	DWORD PTR [ebx], 0
$exit$47:

; 25028: 	    }
; 25029: 	}
; 25030:     }
; 25031: exit:
; 25032:     ACTIVATE_ELEM;

	mov	edx, DWORD PTR [edi+96]

; 25033:     return (ret);

	mov	eax, esi
	mov	ecx, DWORD PTR [edi+100]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edi+108], ecx
	pop	edi
	pop	esi
	pop	ebx

; 25037: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@xmlSchemaP:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0EE@GLDMHPJF@calling?5xmlSchemaQNameExpand?$CI?$CJ?5@
	push	OFFSET ??_C@_0CG@PKILICAE@xmlSchemaValidateElementByDecla@
	push	edi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$internal_error$48:

; 25034: internal_error:
; 25035:     ACTIVATE_ELEM;

	mov	ecx, DWORD PTR [edi+96]
	mov	eax, DWORD PTR [edi+100]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+108], eax

; 25036:     return (-1);

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx

; 25037: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaProcessXSIType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaVExpandQName
_TEXT	SEGMENT
_local$1$ = -4						; size = 4
_vctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_prefix$1 = 16						; size = 4
_nsName$ = 16						; size = 4
_localName$ = 20					; size = 4
_xmlSchemaVExpandQName PROC				; COMDAT

; 24855: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _nsName$[ebp]
	test	esi, esi
	je	$LN3@xmlSchemaV

; 24856:     int ret = 0;
; 24857: 
; 24858:     if ((nsName == NULL) || (localName == NULL))

	mov	ebx, DWORD PTR _localName$[ebp]
	test	ebx, ebx
	je	$LN3@xmlSchemaV

; 24859: 	return (-1);
; 24860:     *nsName = NULL;
; 24861:     *localName = NULL;
; 24862: 
; 24863:     ret = xmlValidateQName(value, 1);

	mov	edi, DWORD PTR _value$[ebp]
	push	1
	mov	DWORD PTR [esi], 0
	push	edi
	mov	DWORD PTR [ebx], 0
	call	_xmlValidateQName
	add	esp, 8

; 24864:     if (ret == -1)

	cmp	eax, -1
	je	$LN3@xmlSchemaV

; 24865: 	return (-1);
; 24866:     if (ret > 0) {

	test	eax, eax
	jle	SHORT $LN5@xmlSchemaV

; 24867: 	xmlSchemaSimpleTypeErr(ACTXT_CAST vctxt,

	push	1
	push	21					; 00000015H
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	push	eax
	push	edi
	push	0
	push	1824					; 00000720H
	push	DWORD PTR _vctxt$[ebp]
	call	_xmlSchemaSimpleTypeErr
	add	esp, 24					; 00000018H

; 24868: 	    XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1, NULL,
; 24869: 	    value, xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME), 1);
; 24870: 	return (1);

	mov	eax, 1
	pop	edi

; 24903: 	    }
; 24904: 	}
; 24905:     }
; 24906:     return (0);
; 24907: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlSchemaV:

; 24871:     }
; 24872:     {
; 24873: 	xmlChar *local = NULL;
; 24874: 	xmlChar *prefix;
; 24875: 
; 24876: 	/*
; 24877: 	* NOTE: xmlSplitQName2 will return a duplicated
; 24878: 	* string.
; 24879: 	*/
; 24880: 	local = xmlSplitQName2(value, &prefix);

	lea	eax, DWORD PTR _prefix$1[ebp]
	push	eax
	push	edi
	call	_xmlSplitQName2
	mov	ecx, DWORD PTR _vctxt$[ebp]
	add	esp, 8
	mov	DWORD PTR _local$1$[ebp], eax
	mov	ecx, DWORD PTR [ecx+156]

; 24881: 	if (local == NULL)

	push	-1
	test	eax, eax
	jne	SHORT $LN6@xmlSchemaV

; 24882: 	    *localName = xmlDictLookup(vctxt->dict, value, -1);

	push	edi
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebx], eax
	jmp	SHORT $LN7@xmlSchemaV
$LN6@xmlSchemaV:

; 24883: 	else {
; 24884: 	    *localName = xmlDictLookup(vctxt->dict, local, -1);

	push	eax
	push	ecx
	call	_xmlDictLookup

; 24885: 	    xmlFree(local);

	push	DWORD PTR _local$1$[ebp]
	mov	DWORD PTR [ebx], eax
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H
$LN7@xmlSchemaV:

; 24886: 	}
; 24887: 
; 24888: 	*nsName = xmlSchemaLookupNamespace(vctxt, prefix);

	push	DWORD PTR _prefix$1[ebp]
	mov	ebx, DWORD PTR _vctxt$[ebp]
	push	ebx
	call	_xmlSchemaLookupNamespace
	mov	DWORD PTR [esi], eax
	add	esp, 8

; 24889: 
; 24890: 	if (prefix != NULL) {

	mov	eax, DWORD PTR _prefix$1[ebp]
	test	eax, eax
	je	SHORT $LN9@xmlSchemaV

; 24891: 	    xmlFree(prefix);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 24892: 	    /*
; 24893: 	    * A namespace must be found if the prefix is NOT NULL.
; 24894: 	    */
; 24895: 	    if (*nsName == NULL) {

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN9@xmlSchemaV

; 24896: 		xmlSchemaCustomErr(ACTXT_CAST vctxt,

	push	0
	push	edi
	push	OFFSET ??_C@_0EJ@KJCHOIHD@The?5QName?5value?5?8?$CFs?8?5has?5no?5cor@
	push	21					; 00000015H
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	push	eax
	push	0
	push	1824					; 00000720H
	push	ebx
	call	_xmlSchemaCustomErr
	add	esp, 28					; 0000001cH

; 24897: 		    XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1, NULL,
; 24898: 		    WXS_BASIC_CAST xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),
; 24899: 		    "The QName value '%s' has no "
; 24900: 		    "corresponding namespace declaration in scope",
; 24901: 		    value, NULL);
; 24902: 		return (2);

	mov	eax, 2
	pop	edi

; 24903: 	    }
; 24904: 	}
; 24905:     }
; 24906:     return (0);
; 24907: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlSchemaV:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlSchemaV:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaVExpandQName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidateQName
_TEXT	SEGMENT
_prefix$ = -4						; size = 4
_vctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_val$ = 16						; size = 4
_valNeeded$ = 20					; size = 4
_xmlSchemaValidateQName PROC				; COMDAT

; 24447: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _value$[ebp]
	push	1
	push	edi
	mov	DWORD PTR _prefix$[ebp], 0
	call	_xmlValidateQName
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@xmlSchemaV

; 24448:     int ret;
; 24449:     const xmlChar *nsName;
; 24450:     xmlChar *local, *prefix = NULL;
; 24451: 
; 24452:     ret = xmlValidateQName(value, 1);
; 24453:     if (ret != 0) {
; 24454: 	if (ret == -1) {

	cmp	eax, -1
	jne	$LN7@xmlSchemaV

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BL@JAPCPOMD@calling?5xmlValidateQName?$CI?$CJ@
	push	OFFSET ??_C@_0BH@PCDDHFLC@xmlSchemaValidateQName@
	push	DWORD PTR _vctxt$[ebp]
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 24455: 	    VERROR_INT("xmlSchemaValidateQName",
; 24456: 		"calling xmlValidateQName()");
; 24457: 	    return (-1);

	or	eax, -1
	pop	edi

; 24503: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlSchemaV:

; 24458: 	}
; 24459: 	return( XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1);
; 24460:     }
; 24461:     /*
; 24462:     * NOTE: xmlSplitQName2 will always return a duplicated
; 24463:     * strings.
; 24464:     */
; 24465:     local = xmlSplitQName2(value, &prefix);

	lea	eax, DWORD PTR _prefix$[ebp]
	push	eax
	push	edi
	call	_xmlSplitQName2
	mov	esi, eax
	add	esp, 8

; 24466:     if (local == NULL)

	test	esi, esi
	jne	SHORT $LN4@xmlSchemaV

; 24467: 	local = xmlStrdup(value);

	push	edi
	call	_xmlStrdup
	add	esp, 4
	mov	esi, eax
$LN4@xmlSchemaV:

; 24468:     /*
; 24469:     * OPTIMIZE TODO: Use flags for:
; 24470:     *  - is there any namespace binding?
; 24471:     *  - is there a default namespace?
; 24472:     */
; 24473:     nsName = xmlSchemaLookupNamespace(vctxt, prefix);

	push	DWORD PTR _prefix$[ebp]
	push	DWORD PTR _vctxt$[ebp]
	call	_xmlSchemaLookupNamespace
	mov	ebx, eax
	add	esp, 8

; 24474: 
; 24475:     if (prefix != NULL) {

	mov	eax, DWORD PTR _prefix$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlSchemaV

; 24476: 	xmlFree(prefix);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 24477: 	/*
; 24478: 	* A namespace must be found if the prefix is
; 24479: 	* NOT NULL.
; 24480: 	*/
; 24481: 	if (nsName == NULL) {

	test	ebx, ebx
	jne	SHORT $LN6@xmlSchemaV

; 24482: 	    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1;
; 24483: 	    xmlSchemaCustomErr(ACTXT_CAST vctxt, ret, NULL,

	push	21					; 00000015H
	call	_xmlSchemaGetBuiltInType

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	ebx
	push	ebx
	push	ebx
	push	edi
	push	OFFSET ??_C@_0EJ@KJCHOIHD@The?5QName?5value?5?8?$CFs?8?5has?5no?5cor@
	push	eax
	push	ebx
	push	1824					; 00000720H
	push	DWORD PTR _vctxt$[ebp]
	call	_xmlSchemaCustomErr4
	add	esp, 40					; 00000028H

; 24484: 		WXS_BASIC_CAST xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),
; 24485: 		"The QName value '%s' has no "
; 24486: 		"corresponding namespace declaration in "
; 24487: 		"scope", value, NULL);
; 24488: 	    if (local != NULL)

	test	esi, esi
	je	SHORT $LN7@xmlSchemaV

; 24489: 		xmlFree(local);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlSchemaV:

; 24503: }

	pop	edi
	pop	esi
	mov	eax, 1824				; 00000720H
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlSchemaV:

; 24490: 	    return (ret);
; 24491: 	}
; 24492:     }
; 24493:     if (valNeeded && val) {

	cmp	DWORD PTR _valNeeded$[ebp], 0
	je	SHORT $LN8@xmlSchemaV
	mov	edi, DWORD PTR _val$[ebp]
	test	edi, edi
	je	SHORT $LN8@xmlSchemaV

; 24494: 	if (nsName != NULL)

	test	ebx, ebx
	je	SHORT $LN10@xmlSchemaV

; 24495: 	    *val = xmlSchemaNewQNameValue(

	push	ebx
	call	_xmlStrdup
	add	esp, 4

; 24499: 		BAD_CAST local);
; 24500:     } else

	push	esi
	push	eax
	call	_xmlSchemaNewQNameValue
	add	esp, 8
	mov	DWORD PTR [edi], eax

; 24502:     return (0);

	xor	eax, eax
	pop	edi

; 24503: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlSchemaV:

; 24496: 		BAD_CAST xmlStrdup(nsName), BAD_CAST local);
; 24497: 	else
; 24498: 	    *val = xmlSchemaNewQNameValue(NULL,

	xor	eax, eax

; 24499: 		BAD_CAST local);
; 24500:     } else

	push	esi
	push	eax
	call	_xmlSchemaNewQNameValue
	add	esp, 8
	mov	DWORD PTR [edi], eax

; 24502:     return (0);

	xor	eax, eax
	pop	edi

; 24503: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlSchemaV:

; 24501: 	xmlFree(local);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 24502:     return (0);

	xor	eax, eax
	pop	edi

; 24503: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaValidateQName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaNormalizeValue
_TEXT	SEGMENT
_type$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlSchemaNormalizeValue PROC				; COMDAT

; 24431: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _type$[ebp]
	call	_xmlSchemaGetWhiteSpaceFacetValue
	add	esp, 4
	sub	eax, 2
	je	SHORT $LN5@xmlSchemaN

; 24432:     switch (xmlSchemaGetWhiteSpaceFacetValue(type)) {

	sub	eax, 1
	je	SHORT $LN4@xmlSchemaN

; 24437: 	default:
; 24438: 	    return (NULL);

	xor	eax, eax

; 24439:     }
; 24440: }

	pop	ebp
	ret	0
$LN4@xmlSchemaN:

; 24433: 	case XML_SCHEMA_WHITESPACE_COLLAPSE:
; 24434: 	    return (xmlSchemaCollapseString(value));

	push	DWORD PTR _value$[ebp]
	call	_xmlSchemaCollapseString

; 24439:     }
; 24440: }

	add	esp, 4
	pop	ebp
	ret	0
$LN5@xmlSchemaN:

; 24435: 	case XML_SCHEMA_WHITESPACE_REPLACE:
; 24436: 	    return (xmlSchemaWhiteSpaceReplace(value));

	push	DWORD PTR _value$[ebp]
	call	_xmlSchemaWhiteSpaceReplace

; 24439:     }
; 24440: }

	add	esp, 4
	pop	ebp
	ret	0
_xmlSchemaNormalizeValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidateFacets
_TEXT	SEGMENT
_facet$2$ = -16						; size = 4
_found$1$ = -12						; size = 4
_found$1$ = -12						; size = 4
_valType$1$ = -12					; size = 4
_len$ = -8						; size = 4
_error$1$ = -4						; size = 4
_actxt$ = 8						; size = 4
_node$ = 12						; size = 4
_type$ = 16						; size = 4
_valType$ = 20						; size = 4
_value$ = 24						; size = 4
_val$ = 28						; size = 4
_length$ = 32						; size = 4
_fireErrors$ = 36					; size = 4
_xmlSchemaValidateFacets PROC				; COMDAT

; 24202: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _type$[ebp]
	xor	edx, edx
	mov	DWORD PTR _error$1$[ebp], edx
	mov	DWORD PTR _len$[ebp], edx
	cmp	DWORD PTR [ebx], 1
	jne	SHORT $LN24@xmlSchemaV

; 24203:     int ret, error = 0;
; 24204: 
; 24205:     xmlSchemaTypePtr tmpType;
; 24206:     xmlSchemaFacetLinkPtr facetLink;
; 24207:     xmlSchemaFacetPtr facet;
; 24208:     unsigned long len = 0;
; 24209:     xmlSchemaWhitespaceValueType ws;
; 24210: 
; 24211:     /*
; 24212:     * In Libxml2, derived built-in types have currently no explicit facets.
; 24213:     */
; 24214:     if (type->type == XML_SCHEMA_TYPE_BASIC)
; 24215: 	return (0);

	xor	eax, eax
	pop	ebx

; 24426: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlSchemaV:

; 24216: 
; 24217:     /*
; 24218:     * NOTE: Do not jump away, if the facetSet of the given type is
; 24219:     * empty: until now, "pattern" and "enumeration" facets of the
; 24220:     * *base types* need to be checked as well.
; 24221:     */
; 24222:     if (type->facetSet == NULL)

	mov	ecx, DWORD PTR _val$[ebp]
	push	esi
	mov	esi, DWORD PTR _value$[ebp]
	push	edi
	cmp	DWORD PTR [ebx+96], edx
	je	$LN127@xmlSchemaV

; 24223: 	goto pattern_and_enum;
; 24224: 
; 24225:     if (! WXS_IS_ATOMIC(type)) {

	mov	eax, DWORD PTR [ebx+48]
	test	eax, 256				; 00000100H
	jne	SHORT $LN28@xmlSchemaV

; 24226: 	if (WXS_IS_LIST(type))

	test	al, 64					; 00000040H
	jne	$WXS_IS_LIST$153

; 24227: 	    goto WXS_IS_LIST;
; 24228: 	else
; 24229: 	    goto pattern_and_enum;

	jmp	$LN127@xmlSchemaV
$LN28@xmlSchemaV:

; 24230:     }
; 24231: 
; 24232:     /*
; 24233:     * Whitespace handling is only of importance for string-based
; 24234:     * types.
; 24235:     */
; 24236:     tmpType = xmlSchemaGetPrimitiveType(type);

	push	ebx
	call	_xmlSchemaGetPrimitiveType
	add	esp, 4

; 24237:     if ((tmpType->builtInType == XML_SCHEMAS_STRING) ||

	mov	ecx, DWORD PTR [eax+88]
	cmp	ecx, 1
	je	SHORT $LN31@xmlSchemaV
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN29@xmlSchemaV
	cmp	ecx, 46					; 0000002eH
	je	SHORT $LN31@xmlSchemaV
$LN29@xmlSchemaV:

; 24240:     } else
; 24241: 	ws = XML_SCHEMA_WHITESPACE_COLLAPSE;

	mov	ebx, 3
	jmp	SHORT $LN30@xmlSchemaV
$LN31@xmlSchemaV:

; 24238: 	WXS_IS_ANY_SIMPLE_TYPE(tmpType)) {
; 24239: 	ws = xmlSchemaGetWhiteSpaceFacetValue(type);

	push	ebx
	call	_xmlSchemaGetWhiteSpaceFacetValue
	add	esp, 4
	mov	ebx, eax
$LN30@xmlSchemaV:

; 24242: 
; 24243:     /*
; 24244:     * If the value was not computed (for string or
; 24245:     * anySimpleType based types), then use the provided
; 24246:     * type.
; 24247:     */
; 24248:     if (val != NULL)

	mov	ecx, DWORD PTR _val$[ebp]
	test	ecx, ecx
	je	SHORT $LN138@xmlSchemaV

; 24249: 	valType = xmlSchemaGetValType(val);

	push	ecx
	call	_xmlSchemaGetValType
	add	esp, 4
	mov	DWORD PTR _valType$1$[ebp], eax
	mov	edx, eax
	jmp	SHORT $LN32@xmlSchemaV
$LN138@xmlSchemaV:

; 24242: 
; 24243:     /*
; 24244:     * If the value was not computed (for string or
; 24245:     * anySimpleType based types), then use the provided
; 24246:     * type.
; 24247:     */
; 24248:     if (val != NULL)

	mov	edx, DWORD PTR _valType$[ebp]
	mov	DWORD PTR _valType$1$[ebp], edx
$LN32@xmlSchemaV:

; 24250: 
; 24251:     ret = 0;
; 24252:     for (facetLink = type->facetSet; facetLink != NULL;

	mov	edi, DWORD PTR _type$[ebp]
	mov	edi, DWORD PTR [edi+96]
	test	edi, edi
	je	$LN141@xmlSchemaV
	npad	8
$LL4@xmlSchemaV:

; 24254: 	/*
; 24255: 	* Skip the pattern "whiteSpace": it is used to
; 24256: 	* format the character content beforehand.
; 24257: 	*/
; 24258: 	switch (facetLink->facet->type) {

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [ecx]
	add	eax, -1006				; fffffc12H
	cmp	eax, 5
	ja	SHORT $LN35@xmlSchemaV
	jmp	DWORD PTR $LN152@xmlSchemaV[eax*4]
$LN34@xmlSchemaV:

; 24259: 	    case XML_SCHEMA_FACET_WHITESPACE:
; 24260: 	    case XML_SCHEMA_FACET_PATTERN:
; 24261: 	    case XML_SCHEMA_FACET_ENUMERATION:
; 24262: 		continue;
; 24263: 	    case XML_SCHEMA_FACET_LENGTH:
; 24264: 	    case XML_SCHEMA_FACET_MINLENGTH:
; 24265: 	    case XML_SCHEMA_FACET_MAXLENGTH:
; 24266: 		ret = xmlSchemaValidateLengthFacetWhtsp(facetLink->facet,

	push	ebx
	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	DWORD PTR _val$[ebp]
	push	esi
	push	edx
	push	ecx
	call	_xmlSchemaValidateLengthFacetWhtsp

; 24267: 		    valType, value, val, &len, ws);
; 24268: 		break;

	jmp	SHORT $LN147@xmlSchemaV
$LN35@xmlSchemaV:

; 24269: 	    default:
; 24270: 		ret = xmlSchemaValidateFacetWhtsp(facetLink->facet, ws,

	push	ebx
	push	DWORD PTR _val$[ebp]
	push	esi
	push	edx
	push	ebx
	push	ecx
	call	_xmlSchemaValidateFacetWhtsp
$LN147@xmlSchemaV:

; 24271: 		    valType, value, val, ws);
; 24272: 		break;
; 24273: 	}
; 24274: 	if (ret < 0) {

	mov	esi, eax
	add	esp, 24					; 00000018H
	test	esi, esi
	js	SHORT $LN100@xmlSchemaV

; 24278: 	} else if (ret > 0) {

	jle	SHORT $LN143@xmlSchemaV

; 24279: 	    if (fireErrors)

	cmp	DWORD PTR _fireErrors$[ebp], 0
	je	SHORT $LN39@xmlSchemaV

; 24280: 		xmlSchemaFacetErr(actxt, ret, node,

	push	0
	push	0
	push	0
	push	DWORD PTR [edi+4]
	push	DWORD PTR _type$[ebp]
	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _node$[ebp]
	push	esi
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaFacetErr

; 24284: 	    if (error == 0)

	mov	edx, DWORD PTR _error$1$[ebp]
	add	esp, 40					; 00000028H
	test	edx, edx
	cmove	edx, esi
	mov	DWORD PTR _error$1$[ebp], edx
	jmp	SHORT $LN148@xmlSchemaV
$LN142@xmlSchemaV:

; 24254: 	/*
; 24255: 	* Skip the pattern "whiteSpace": it is used to
; 24256: 	* format the character content beforehand.
; 24257: 	*/
; 24258: 	switch (facetLink->facet->type) {

	mov	edx, DWORD PTR _error$1$[ebp]
	jmp	SHORT $LN2@xmlSchemaV
$LN143@xmlSchemaV:

; 24278: 	} else if (ret > 0) {

	mov	edx, DWORD PTR _error$1$[ebp]
$LN148@xmlSchemaV:

; 24253: 	facetLink = facetLink->next) {

	mov	esi, DWORD PTR _value$[ebp]
$LN2@xmlSchemaV:
	mov	edi, DWORD PTR [edi]
	test	edi, edi
	je	SHORT $LN134@xmlSchemaV

; 24250: 
; 24251:     ret = 0;
; 24252:     for (facetLink = type->facetSet; facetLink != NULL;

	mov	edx, DWORD PTR _valType$1$[ebp]
	jmp	$LL4@xmlSchemaV
$LN39@xmlSchemaV:
	pop	edi

; 24281: 		value, len, type, facetLink->facet, NULL, NULL, NULL);
; 24282: 	    else
; 24283: 		return (ret);

	mov	eax, esi
	pop	esi
	pop	ebx

; 24426: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN100@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CH@MOGKKGIH@validating?5against?5a?5atomic?5typ@

; 24275: 	    AERROR_INT("xmlSchemaValidateFacets",
; 24276: 		"validating against a atomic type facet");
; 24277: 	    return (-1);

	jmp	$LN150@xmlSchemaV
$LN141@xmlSchemaV:

; 24250: 
; 24251:     ret = 0;
; 24252:     for (facetLink = type->facetSet; facetLink != NULL;

	xor	edx, edx
$LN134@xmlSchemaV:

; 24285: 		error = ret;
; 24286: 	}
; 24287: 	ret = 0;
; 24288:     }
; 24289: 
; 24290: WXS_IS_LIST:
; 24291:     if (! WXS_IS_LIST(type))

	mov	ebx, DWORD PTR _type$[ebp]
$WXS_IS_LIST$153:
	test	BYTE PTR [ebx+48], 64			; 00000040H
	je	SHORT $pattern_and_enum$154

; 24292: 	goto pattern_and_enum;
; 24293:     /*
; 24294:     * "length", "minLength" and "maxLength" of list types.
; 24295:     */
; 24296:     ret = 0;
; 24297:     for (facetLink = type->facetSet; facetLink != NULL;

	mov	esi, DWORD PTR [ebx+96]
	test	esi, esi
	je	SHORT $pattern_and_enum$154
	mov	ebx, DWORD PTR _length$[ebp]
	npad	7
$LL9@xmlSchemaV:

; 24299: 
; 24300: 	switch (facetLink->facet->type) {

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx]
	add	eax, -1009				; fffffc0fH
	cmp	eax, 2
	ja	SHORT $LN7@xmlSchemaV

; 24301: 	    case XML_SCHEMA_FACET_LENGTH:
; 24302: 	    case XML_SCHEMA_FACET_MINLENGTH:
; 24303: 	    case XML_SCHEMA_FACET_MAXLENGTH:
; 24304: 		ret = xmlSchemaValidateListSimpleTypeFacet(facetLink->facet,

	push	0
	push	ebx
	push	DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlSchemaValidateListSimpleTypeFacet
	mov	edi, eax
	add	esp, 16					; 00000010H

; 24305: 		    value, length, NULL);
; 24306: 		break;
; 24307: 	    default:
; 24308: 		continue;
; 24309: 	}
; 24310: 	if (ret < 0) {

	test	edi, edi
	js	$LN101@xmlSchemaV

; 24314: 	} else if (ret > 0) {

	jle	SHORT $LN140@xmlSchemaV

; 24315: 	    if (fireErrors)

	cmp	DWORD PTR _fireErrors$[ebp], 0
	je	$LN60@xmlSchemaV

; 24316: 		xmlSchemaFacetErr(actxt, ret, node,

	push	0
	push	0
	push	0
	push	DWORD PTR [esi+4]
	push	DWORD PTR _type$[ebp]
	push	ebx
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _node$[ebp]
	push	edi
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaFacetErr

; 24317: 		value, length, type, facetLink->facet, NULL, NULL, NULL);
; 24318: 	    else
; 24319: 		return (ret);
; 24320: 	    if (error == 0)

	mov	edx, DWORD PTR _error$1$[ebp]
	add	esp, 40					; 00000028H
	test	edx, edx
	cmove	edx, edi
	mov	DWORD PTR _error$1$[ebp], edx
	jmp	SHORT $LN7@xmlSchemaV
$LN140@xmlSchemaV:

; 24314: 	} else if (ret > 0) {

	mov	edx, DWORD PTR _error$1$[ebp]
$LN7@xmlSchemaV:

; 24298: 	facetLink = facetLink->next) {

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL9@xmlSchemaV

; 24292: 	goto pattern_and_enum;
; 24293:     /*
; 24294:     * "length", "minLength" and "maxLength" of list types.
; 24295:     */
; 24296:     ret = 0;
; 24297:     for (facetLink = type->facetSet; facetLink != NULL;

	mov	ebx, DWORD PTR _type$[ebp]
$pattern_and_enum$154:

; 24321: 		error = ret;
; 24322: 	}
; 24323: 	ret = 0;
; 24324:     }
; 24325: 
; 24326: pattern_and_enum:
; 24327:     if (error >= 0) {

	test	edx, edx
	js	$LN19@xmlSchemaV
	mov	ecx, DWORD PTR _val$[ebp]
$LN127@xmlSchemaV:

; 24328: 	int found = 0;

	xor	eax, eax

; 24329: 	/*
; 24330: 	* Process enumerations. Facet values are in the value space
; 24331: 	* of the defining type's base type. This seems to be a bug in the
; 24332: 	* XML Schema 1.0 spec. Use the whitespace type of the base type.
; 24333: 	* Only the first set of enumerations in the ancestor-or-self axis
; 24334: 	* is used for validation.
; 24335: 	*/
; 24336: 	ret = 0;

	xor	edi, edi
	mov	DWORD PTR _found$1$[ebp], eax
	npad	2
$LL14@xmlSchemaV:

; 24337: 	tmpType = type;
; 24338: 	do {
; 24339: 	    for (facet = tmpType->facets; facet != NULL; facet = facet->next) {

	mov	esi, DWORD PTR [ebx+68]
	test	esi, esi
	je	SHORT $LN129@xmlSchemaV
$LL17@xmlSchemaV:

; 24340: 		if (facet->type != XML_SCHEMA_FACET_ENUMERATION)

	cmp	DWORD PTR [esi], 1007			; 000003efH
	jne	SHORT $LN15@xmlSchemaV

; 24341: 		    continue;
; 24342: 		found = 1;
; 24343: 		ret = xmlSchemaAreValuesEqual(facet->val, val);

	push	ecx
	push	DWORD PTR [esi+32]
	mov	DWORD PTR _found$1$[ebp], 1
	call	_xmlSchemaAreValuesEqual
	mov	edi, eax
	add	esp, 8

; 24344: 		if (ret == 1)

	cmp	edi, 1
	je	SHORT $LN102@xmlSchemaV

; 24345: 		    break;
; 24346: 		else if (ret < 0) {

	test	edi, edi
	js	SHORT $LN103@xmlSchemaV
$LN15@xmlSchemaV:

; 24337: 	tmpType = type;
; 24338: 	do {
; 24339: 	    for (facet = tmpType->facets; facet != NULL; facet = facet->next) {

	mov	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _val$[ebp]
	test	esi, esi
	jne	SHORT $LL17@xmlSchemaV
$LN102@xmlSchemaV:

; 24350: 		}
; 24351: 	    }
; 24352: 	    if (ret != 0)

	test	edi, edi
	jne	SHORT $LN62@xmlSchemaV

; 24353: 		break;
; 24354: 	    /*
; 24355: 	    * Break on the first set of enumerations. Any additional
; 24356: 	    *  enumerations which might be existent on the ancestors
; 24357: 	    *  of the current type are restricted by this set; thus
; 24358: 	    *  *must* *not* be taken into account.
; 24359: 	    */
; 24360: 	    if (found)

	cmp	DWORD PTR _found$1$[ebp], edi
	jne	SHORT $LN130@xmlSchemaV
$LN129@xmlSchemaV:

; 24361: 		break;
; 24362: 	    tmpType = tmpType->baseType;

	mov	ebx, DWORD PTR [ebx+64]

; 24363: 	} while ((tmpType != NULL) &&

	test	ebx, ebx
	je	SHORT $LN62@xmlSchemaV
	cmp	DWORD PTR [ebx], 1
	je	SHORT $LN62@xmlSchemaV
	mov	ecx, DWORD PTR _val$[ebp]
	jmp	SHORT $LL14@xmlSchemaV
$LN101@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CF@IGJENPFO@validating?5against?5a?5list?5type?5@

; 24311: 	    AERROR_INT("xmlSchemaValidateFacets",
; 24312: 		"validating against a list type facet");
; 24313: 	    return (-1);

	jmp	SHORT $LN150@xmlSchemaV
$LN103@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CI@BDJMPJNK@validating?5against?5an?5enumerati@
$LN150@xmlSchemaV:
	push	OFFSET ??_C@_0BI@NHJMGMIL@xmlSchemaValidateFacets@
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 24347: 		    AERROR_INT("xmlSchemaValidateFacets",
; 24348: 			"validating against an enumeration facet");
; 24349: 		    return (-1);

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx

; 24426: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN130@xmlSchemaV:

; 24364: 	    (tmpType->type != XML_SCHEMA_TYPE_BASIC));
; 24365: 	if (found && (ret == 0)) {
; 24366: 	    ret = XML_SCHEMAV_CVC_ENUMERATION_VALID;
; 24367: 	    if (fireErrors) {

	cmp	DWORD PTR _fireErrors$[ebp], 0
	mov	edi, 1840				; 00000730H
	je	$LN60@xmlSchemaV

; 24368: 		xmlSchemaFacetErr(actxt, ret, node,

	push	0
	push	0
	push	0
	push	0
	push	DWORD PTR _type$[ebp]
	push	0
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _node$[ebp]
	push	edi
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaFacetErr
	add	esp, 40					; 00000028H

; 24372: 	    if (error == 0)

	cmp	DWORD PTR _error$1$[ebp], 0
	jne	SHORT $LN62@xmlSchemaV

; 24373: 		error = ret;

	mov	eax, edi
	mov	DWORD PTR _error$1$[ebp], eax
$LN62@xmlSchemaV:

; 24374: 	}
; 24375:     }
; 24376: 
; 24377:     if (error >= 0) {
; 24378: 	int found;
; 24379: 	/*
; 24380: 	* Process patters. Pattern facets are ORed at type level
; 24381: 	* and ANDed if derived. Walk the base type axis.
; 24382: 	*/
; 24383: 	tmpType = type;

	mov	ebx, DWORD PTR _type$[ebp]

; 24384: 	facet = NULL;

	xor	eax, eax
	mov	DWORD PTR _facet$2$[ebp], eax
$LL20@xmlSchemaV:

; 24385: 	do {
; 24386: 	    found = 0;
; 24387: 	    for (facetLink = tmpType->facetSet; facetLink != NULL;

	mov	esi, DWORD PTR [ebx+96]
	xor	eax, eax
	mov	DWORD PTR _found$1$[ebp], eax
	test	esi, esi
	je	SHORT $LN69@xmlSchemaV
	npad	4
$LL23@xmlSchemaV:

; 24388: 		facetLink = facetLink->next) {
; 24389: 		if (facetLink->facet->type != XML_SCHEMA_FACET_PATTERN)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax], 1006			; 000003eeH
	jne	SHORT $LN21@xmlSchemaV

; 24390: 		    continue;
; 24391: 		found = 1;
; 24392: 		/*
; 24393: 		* NOTE that for patterns, @value needs to be the
; 24394: 		* normalized vaule.
; 24395: 		*/
; 24396: 		ret = xmlRegexpExec(facetLink->facet->regexp, value);

	push	DWORD PTR _value$[ebp]
	mov	DWORD PTR _found$1$[ebp], 1
	push	DWORD PTR [eax+36]
	call	_xmlRegexpExec
	mov	edi, eax
	add	esp, 8

; 24397: 		if (ret == 1)

	cmp	edi, 1
	je	SHORT $LN69@xmlSchemaV

; 24398: 		    break;
; 24399: 		else if (ret < 0) {

	test	edi, edi
	js	SHORT $LN107@xmlSchemaV

; 24403: 		} else {
; 24404: 		    /*
; 24405: 		    * Save the last non-validating facet.
; 24406: 		    */
; 24407: 		    facet = facetLink->facet;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _facet$2$[ebp], ecx
$LN21@xmlSchemaV:

; 24385: 	do {
; 24386: 	    found = 0;
; 24387: 	    for (facetLink = tmpType->facetSet; facetLink != NULL;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL23@xmlSchemaV

; 24408: 		}
; 24409: 	    }
; 24410: 	    if (found && (ret != 1)) {

	cmp	DWORD PTR _found$1$[ebp], esi
	je	SHORT $LN69@xmlSchemaV
	cmp	edi, 1
	jne	$LN108@xmlSchemaV
$LN69@xmlSchemaV:

; 24419: 		break;
; 24420: 	    }
; 24421: 	    tmpType = tmpType->baseType;

	mov	ebx, DWORD PTR [ebx+64]

; 24422: 	} while ((tmpType != NULL) && (tmpType->type != XML_SCHEMA_TYPE_BASIC));

	test	ebx, ebx
	je	SHORT $LN73@xmlSchemaV
	cmp	DWORD PTR [ebx], 1
	jne	SHORT $LL20@xmlSchemaV
$LN73@xmlSchemaV:
	mov	edx, DWORD PTR _error$1$[ebp]
$LN19@xmlSchemaV:
	pop	edi
	pop	esi

; 24423:     }
; 24424: 
; 24425:     return (error);

	mov	eax, edx
	pop	ebx

; 24426: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN60@xmlSchemaV:

; 24369: 		    value, 0, type, NULL, NULL, NULL, NULL);
; 24370: 	    } else
; 24371: 		return (ret);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 24426: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN107@xmlSchemaV:

; 2293 :     if (actxt == NULL)

	mov	ebx, DWORD PTR _actxt$[ebp]
	test	ebx, ebx
	je	SHORT $LN88@xmlSchemaV

; 2294 :         return;
; 2295 :     msg = xmlStrdup(BAD_CAST "Internal error: %s, ");

	push	OFFSET ??_C@_0BF@EFOKBLAL@Internal?5error?3?5?$CFs?0?5@
	call	_xmlStrdup

; 2296 :     msg = xmlStrcat(msg, BAD_CAST message);

	push	OFFSET ??_C@_0CD@GIDABGCK@validating?5against?5a?5pattern?5fa@
	push	eax
	call	_xmlStrcat

; 2297 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	call	_xmlStrcat
	mov	esi, eax
	add	esp, 20					; 00000014H

; 2298 : 
; 2299 :     if (actxt->type == XML_SCHEMA_CTXT_VALIDATOR)

	mov	eax, DWORD PTR [ebx]
	cmp	eax, 2
	jne	SHORT $LN85@xmlSchemaV

; 2159 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BI@NHJMGMIL@xmlSchemaValidateFacets@
	push	esi
	push	0
	push	0
	push	1818					; 0000071aH

; 2300 : 	xmlSchemaErr3(actxt, XML_SCHEMAV_INTERNAL, NULL,

	jmp	SHORT $LN149@xmlSchemaV
$LN85@xmlSchemaV:

; 2301 : 	    (const char *) msg, (const xmlChar *) funcName, str1, str2);
; 2302 :     else if (actxt->type == XML_SCHEMA_CTXT_PARSER)

	cmp	eax, 1
	jne	SHORT $LN92@xmlSchemaV

; 2159 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BI@NHJMGMIL@xmlSchemaValidateFacets@
	push	esi
	push	0
	push	0
	push	3069					; 00000bfdH
$LN149@xmlSchemaV:

; 2306 :     FREE_AND_NULL(msg)

	push	2
	push	ebx
	call	_xmlSchemaErr4Line
	add	esp, 40					; 00000028H
$LN92@xmlSchemaV:
	test	esi, esi
	je	SHORT $LN88@xmlSchemaV
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN88@xmlSchemaV:
	pop	edi
	pop	esi

; 24400: 		    AERROR_INT("xmlSchemaValidateFacets",
; 24401: 			"validating against a pattern facet");
; 24402: 		    return (-1);

	or	eax, -1
	pop	ebx

; 24426: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN108@xmlSchemaV:

; 24411: 		ret = XML_SCHEMAV_CVC_PATTERN_VALID;
; 24412: 		if (fireErrors) {

	cmp	DWORD PTR _fireErrors$[ebp], 0
	je	SHORT $LN70@xmlSchemaV

; 24413: 		    xmlSchemaFacetErr(actxt, ret, node,

	mov	eax, DWORD PTR _facet$2$[ebp]
	push	0
	push	0
	push	0
	push	eax
	push	DWORD PTR _type$[ebp]
	push	0
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _node$[ebp]
	push	1839					; 0000072fH
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaFacetErr

; 24417: 		if (error == 0)

	mov	edx, DWORD PTR _error$1$[ebp]
	add	esp, 40					; 00000028H
	test	edx, edx
	jne	$LN19@xmlSchemaV

; 24418: 		    error = ret;

	pop	edi
	mov	edx, 1839				; 0000072fH
	pop	esi

; 24423:     }
; 24424: 
; 24425:     return (error);

	mov	eax, edx
	pop	ebx

; 24426: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN70@xmlSchemaV:
	pop	edi
	pop	esi

; 24414: 			value, 0, type, facet, NULL, NULL, NULL);
; 24415: 		} else
; 24416: 		    return (ret);

	mov	eax, 1839				; 0000072fH
	pop	ebx

; 24426: }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN152@xmlSchemaV:
	DD	$LN142@xmlSchemaV
	DD	$LN142@xmlSchemaV
	DD	$LN142@xmlSchemaV
	DD	$LN34@xmlSchemaV
	DD	$LN34@xmlSchemaV
	DD	$LN34@xmlSchemaV
_xmlSchemaValidateFacets ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetFreshElemInfo
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_xmlSchemaGetFreshElemInfo PROC				; COMDAT

; 24127: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _vctxt$[ebp]
	mov	eax, DWORD PTR [esi+96]
	mov	edi, DWORD PTR [esi+104]
	cmp	eax, edi
	jle	SHORT $LN5@xmlSchemaG

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BP@KBPFIFIK@inconsistent?5depth?5encountered@

; 24187: }

	push	OFFSET ??_C@_0BK@HLHJELLH@xmlSchemaGetFreshElemInfo@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN5@xmlSchemaG:

; 24128:     xmlSchemaNodeInfoPtr info = NULL;
; 24129: 
; 24130:     if (vctxt->depth > vctxt->sizeElemInfos) {
; 24131: 	VERROR_INT("xmlSchemaGetFreshElemInfo",
; 24132: 	    "inconsistent depth encountered");
; 24133: 	return (NULL);
; 24134:     }
; 24135:     if (vctxt->elemInfos == NULL) {

	mov	ecx, DWORD PTR [esi+100]
	test	ecx, ecx
	jne	SHORT $LN6@xmlSchemaG

; 24136: 	vctxt->elemInfos = (xmlSchemaNodeInfoPtr *)

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+100], eax

; 24137: 	    xmlMalloc(10 * sizeof(xmlSchemaNodeInfoPtr));
; 24138: 	if (vctxt->elemInfos == NULL) {

	test	eax, eax
	jne	SHORT $LN8@xmlSchemaG

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@CMDKBIBJ@allocating?5the?5element?5info?5arr@
$LN34@xmlSchemaG:

; 24187: }

	inc	DWORD PTR [esi+56]
	push	0
	push	0
	push	2
	push	17					; 00000011H
	mov	DWORD PTR [esi+52], 1818		; 0000071aH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN8@xmlSchemaG:
	xorps	xmm0, xmm0

; 24139: 	    xmlSchemaVErrMemory(vctxt,
; 24140: 		"allocating the element info array", NULL);
; 24141: 	    return (NULL);
; 24142: 	}
; 24143: 	memset(vctxt->elemInfos, 0, 10 * sizeof(xmlSchemaNodeInfoPtr));

	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0

; 24144: 	vctxt->sizeElemInfos = 10;

	mov	DWORD PTR [esi+104], 10			; 0000000aH
	jmp	SHORT $LN31@xmlSchemaG
$LN6@xmlSchemaG:

; 24145:     } else if (vctxt->sizeElemInfos <= vctxt->depth) {

	cmp	edi, eax
	jg	SHORT $LN9@xmlSchemaG

; 24146: 	int i = vctxt->sizeElemInfos;
; 24147: 
; 24148: 	vctxt->sizeElemInfos *= 2;

	lea	eax, DWORD PTR [edi+edi]
	mov	DWORD PTR [esi+104], eax

; 24149: 	vctxt->elemInfos = (xmlSchemaNodeInfoPtr *)

	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	DWORD PTR [esi+100], eax

; 24150: 	    xmlRealloc(vctxt->elemInfos, vctxt->sizeElemInfos *
; 24151: 	    sizeof(xmlSchemaNodeInfoPtr));
; 24152: 	if (vctxt->elemInfos == NULL) {

	test	eax, eax
	jne	SHORT $LN11@xmlSchemaG

; 24153: 	    xmlSchemaVErrMemory(vctxt,

	push	eax
	push	OFFSET ??_C@_0CF@PDEOBEKK@re?9allocating?5the?5element?5info?5@
	push	esi
	call	_xmlSchemaVErrMemory
	add	esp, 12					; 0000000cH

; 24154: 		"re-allocating the element info array", NULL);
; 24155: 	    return (NULL);

	xor	eax, eax
	pop	edi

; 24187: }

	pop	esi
	pop	ebp
	ret	0
$LN11@xmlSchemaG:

; 24156: 	}
; 24157: 	/*
; 24158: 	* We need the new memory to be NULLed.
; 24159: 	* TODO: Use memset instead?
; 24160: 	*/
; 24161: 	for (; i < vctxt->sizeElemInfos; i++)

	cmp	edi, DWORD PTR [esi+104]
	jge	SHORT $LN31@xmlSchemaG
	npad	8
$LL4@xmlSchemaG:

; 24162: 	    vctxt->elemInfos[i] = NULL;

	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR [eax+edi*4], 0
	inc	edi
	cmp	edi, DWORD PTR [esi+104]
	jl	SHORT $LL4@xmlSchemaG
	jmp	SHORT $LN31@xmlSchemaG
$LN9@xmlSchemaG:

; 24163:     } else
; 24164: 	info = vctxt->elemInfos[vctxt->depth];

	mov	edi, DWORD PTR [ecx+eax*4]

; 24165: 
; 24166:     if (info == NULL) {

	test	edi, edi
	jne	SHORT $LN12@xmlSchemaG
$LN31@xmlSchemaG:

; 24167: 	info = (xmlSchemaNodeInfoPtr)

	push	84					; 00000054H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 24168: 	    xmlMalloc(sizeof(xmlSchemaNodeInfo));
; 24169: 	if (info == NULL) {

	test	edi, edi
	jne	SHORT $LN14@xmlSchemaG

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BL@LLLHNEDD@allocating?5an?5element?5info@

; 24170: 	    xmlSchemaVErrMemory(vctxt,
; 24171: 		"allocating an element info", NULL);
; 24172: 	    return (NULL);

	jmp	$LN34@xmlSchemaG
$LN14@xmlSchemaG:

; 24173: 	}
; 24174: 	vctxt->elemInfos[vctxt->depth] = info;

	mov	ecx, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR [eax+ecx*4], edi
$LN15@xmlSchemaG:

; 24177: 	    VERROR_INT("xmlSchemaGetFreshElemInfo",
; 24178: 		"elem info has not been cleared");
; 24179: 	    return (NULL);
; 24180: 	}
; 24181:     }
; 24182:     memset(info, 0, sizeof(xmlSchemaNodeInfo));

	push	80					; 00000050H
	lea	eax, DWORD PTR [edi+4]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 24183:     info->nodeType = XML_ELEMENT_NODE;

	mov	DWORD PTR [edi], 1

; 24184:     info->depth = vctxt->depth;

	mov	eax, DWORD PTR [esi+96]
	mov	DWORD PTR [edi+48], eax

; 24185: 
; 24186:     return (info);

	mov	eax, edi
	pop	edi

; 24187: }

	pop	esi
	pop	ebp
	ret	0
$LN12@xmlSchemaG:

; 24175:     } else {
; 24176: 	if (info->localName != NULL) {

	cmp	DWORD PTR [edi+12], 0
	je	SHORT $LN15@xmlSchemaG

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BP@FKKNFHGK@elem?5info?5has?5not?5been?5cleared@

; 24187: }

	push	OFFSET ??_C@_0BK@HLHJELLH@xmlSchemaGetFreshElemInfo@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlSchemaGetFreshElemInfo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaClearElemInfo
_TEXT	SEGMENT
_next$1$ = -4						; size = 4
_vctxt$ = 8						; size = 4
_ielem$ = 12						; size = 4
_xmlSchemaClearElemInfo PROC				; COMDAT

; 24063: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ielem$[ebp]
	test	BYTE PTR [ebx+32], 1
	mov	DWORD PTR [ebx+76], 0
	mov	DWORD PTR [ebx+80], 0
	je	SHORT $LN2@xmlSchemaC

; 24064:     ielem->hasKeyrefs = 0;
; 24065:     ielem->appliedXPath = 0;
; 24066:     if (ielem->flags & XML_SCHEMA_NODE_INFO_FLAG_OWNED_NAMES) {
; 24067: 	FREE_AND_NULL(ielem->localName);

	mov	eax, DWORD PTR [ebx+12]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	DWORD PTR [ebx+12], 0
$LN4@xmlSchemaC:

; 24068: 	FREE_AND_NULL(ielem->nsName);

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 24069:     } else {

	jmp	SHORT $LN65@xmlSchemaC
$LN2@xmlSchemaC:

; 24070: 	ielem->localName = NULL;

	mov	DWORD PTR [ebx+12], 0
$LN65@xmlSchemaC:

; 24071: 	ielem->nsName = NULL;
; 24072:     }
; 24073:     if (ielem->flags & XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES) {

	mov	DWORD PTR [ebx+16], 0
$LN3@xmlSchemaC:
	test	BYTE PTR [ebx+32], 2
	je	SHORT $LN6@xmlSchemaC

; 24074: 	FREE_AND_NULL(ielem->value);

	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	je	SHORT $LN7@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlSchemaC:

; 24075:     } else {
; 24076: 	ielem->value = NULL;
; 24077:     }
; 24078:     if (ielem->val != NULL) {

	mov	DWORD PTR [ebx+20], 0
$LN7@xmlSchemaC:
	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN9@xmlSchemaC

; 24079: 	/*
; 24080: 	* PSVI TODO: Be careful not to free it when the value is
; 24081: 	* exposed via PSVI.
; 24082: 	*/
; 24083: 	xmlSchemaFreeValue(ielem->val);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4

; 24084: 	ielem->val = NULL;

	mov	DWORD PTR [ebx+24], 0
$LN9@xmlSchemaC:

; 24085:     }
; 24086:     if (ielem->idcMatchers != NULL) {

	push	esi
	mov	esi, DWORD PTR [ebx+56]
	push	edi
	test	esi, esi
	je	$LN10@xmlSchemaC
$LL16@xmlSchemaC:

; 22372: 	if (matcher->keySeqs != NULL) {

	cmp	DWORD PTR [esi+24], 0
	mov	ebx, DWORD PTR [esi+8]
	mov	DWORD PTR _next$1$[ebp], ebx
	je	SHORT $LN19@xmlSchemaC

; 22373: 	    int i;
; 22374: 	    /*
; 22375: 	    * Don't free the array, but only the content.
; 22376: 	    */
; 22377: 	    for (i = 0; i < matcher->sizeKeySeqs; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+28], edi
	jle	SHORT $LN19@xmlSchemaC
$LL20@xmlSchemaC:

; 22378: 		if (matcher->keySeqs[i] != NULL) {

	mov	eax, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [eax+edi*4]
	test	eax, eax
	je	SHORT $LN18@xmlSchemaC

; 22379: 		    xmlFree(matcher->keySeqs[i]);

	push	eax
	call	DWORD PTR _xmlFree

; 22380: 		    matcher->keySeqs[i] = NULL;

	mov	eax, DWORD PTR [esi+24]
	add	esp, 4
	mov	DWORD PTR [eax+edi*4], 0
$LN18@xmlSchemaC:

; 22373: 	    int i;
; 22374: 	    /*
; 22375: 	    * Don't free the array, but only the content.
; 22376: 	    */
; 22377: 	    for (i = 0; i < matcher->sizeKeySeqs; i++)

	inc	edi
	cmp	edi, DWORD PTR [esi+28]
	jl	SHORT $LL20@xmlSchemaC
$LN19@xmlSchemaC:

; 22381: 		}
; 22382: 	}
; 22383: 	if (matcher->targets) {

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN63@xmlSchemaC

; 22384: 	    if (matcher->idcType == XML_SCHEMA_TYPE_IDC_KEYREF) {

	cmp	DWORD PTR [esi+20], 24			; 00000018H
	mov	edi, eax
	jne	SHORT $LN22@xmlSchemaC

; 22385: 		int i;
; 22386: 		xmlSchemaPSVIIDCNodePtr idcNode;
; 22387: 		/*
; 22388: 		* Node-table items for keyrefs are not stored globally
; 22389: 		* to the validation context, since they are not bubbled.
; 22390: 		* We need to free them here.
; 22391: 		*/
; 22392: 		for (i = 0; i < matcher->targets->nbItems; i++) {

	xor	ebx, ebx
	cmp	DWORD PTR [eax+4], ebx
	jle	SHORT $LN64@xmlSchemaC
	npad	2
$LL23@xmlSchemaC:

; 22393: 		    idcNode =

	mov	eax, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+ebx*4]

; 22394: 			(xmlSchemaPSVIIDCNodePtr) matcher->targets->items[i];
; 22395: 		    xmlFree(idcNode->keys);

	push	DWORD PTR [edi+4]
	call	DWORD PTR _xmlFree

; 22396: 		    xmlFree(idcNode);

	push	edi
	call	DWORD PTR _xmlFree
	mov	edi, DWORD PTR [esi+32]
	inc	ebx
	add	esp, 8
	cmp	ebx, DWORD PTR [edi+4]
	jl	SHORT $LL23@xmlSchemaC
$LN64@xmlSchemaC:

; 3530 :     if (list == NULL)

	mov	ebx, DWORD PTR _next$1$[ebp]
$LN22@xmlSchemaC:
	test	edi, edi
	je	SHORT $LN30@xmlSchemaC

; 3531 : 	return;
; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN32@xmlSchemaC

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN32@xmlSchemaC:

; 3534 :     xmlFree(list);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN30@xmlSchemaC:

; 22400: 	    matcher->targets = NULL;

	mov	DWORD PTR [esi+32], 0
$LN63@xmlSchemaC:

; 22401: 	}
; 22402: 	matcher->next = NULL;
; 22403: 	/*
; 22404: 	* Cache the matcher.
; 22405: 	*/
; 22406: 	if (vctxt->idcMatcherCache != NULL)

	mov	ecx, DWORD PTR _vctxt$[ebp]
	mov	DWORD PTR [esi+8], 0
	mov	eax, DWORD PTR [ecx+124]
	test	eax, eax
	je	SHORT $LN28@xmlSchemaC

; 22407: 	    matcher->nextCached = vctxt->idcMatcherCache;

	mov	DWORD PTR [esi+12], eax
$LN28@xmlSchemaC:

; 22408: 	vctxt->idcMatcherCache = matcher;

	mov	DWORD PTR [ecx+124], esi

; 22409: 
; 22410: 	matcher = next;

	mov	esi, ebx
	test	ebx, ebx
	jne	$LL16@xmlSchemaC

; 24087: 	/*
; 24088: 	* REVISIT OPTIMIZE TODO: Use a pool of IDC matchers.
; 24089: 	*   Does it work?
; 24090: 	*/
; 24091: 	xmlSchemaIDCReleaseMatcherList(vctxt, ielem->idcMatchers);
; 24092: #if 0
; 24093: 	xmlSchemaIDCFreeMatcherList(ielem->idcMatchers);
; 24094: #endif
; 24095: 	ielem->idcMatchers = NULL;

	mov	ebx, DWORD PTR _ielem$[ebp]
	mov	DWORD PTR [ebx+56], esi
$LN10@xmlSchemaC:

; 24096:     }
; 24097:     if (ielem->idcTable != NULL) {

	mov	esi, DWORD PTR [ebx+52]
	test	esi, esi
	je	SHORT $LN11@xmlSchemaC
	npad	6
$LL35@xmlSchemaC:

; 22308: 	prev = bind;

	mov	edi, esi

; 22309: 	bind = bind->next;

	mov	esi, DWORD PTR [esi]

; 22289:     if (bind->nodeTable != NULL)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN39@xmlSchemaC

; 22290: 	xmlFree(bind->nodeTable);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN39@xmlSchemaC:

; 22291:     if (bind->dupls != NULL)

	mov	ebx, DWORD PTR [edi+20]
	test	ebx, ebx
	je	SHORT $LN42@xmlSchemaC

; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN44@xmlSchemaC

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN44@xmlSchemaC:

; 3534 :     xmlFree(list);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN42@xmlSchemaC:

; 22293:     xmlFree(bind);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 22307:     while (bind != NULL) {

	test	esi, esi
	jne	SHORT $LL35@xmlSchemaC

; 24098: 	/*
; 24099: 	* OPTIMIZE TODO: Use a pool of IDC tables??.
; 24100: 	*/
; 24101: 	xmlSchemaIDCFreeIDCTable(ielem->idcTable);
; 24102: 	ielem->idcTable = NULL;

	mov	ebx, DWORD PTR _ielem$[ebp]
	mov	DWORD PTR [ebx+52], esi
$LN11@xmlSchemaC:

; 24103:     }
; 24104:     if (ielem->regexCtxt != NULL) {

	mov	eax, DWORD PTR [ebx+60]
	pop	edi
	pop	esi
	test	eax, eax
	je	SHORT $LN12@xmlSchemaC

; 24105: 	xmlRegFreeExecCtxt(ielem->regexCtxt);

	push	eax
	call	_xmlRegFreeExecCtxt
	add	esp, 4

; 24106: 	ielem->regexCtxt = NULL;

	mov	DWORD PTR [ebx+60], 0
$LN12@xmlSchemaC:

; 24107:     }
; 24108:     if (ielem->nsBindings != NULL) {

	mov	eax, DWORD PTR [ebx+64]
	test	eax, eax
	je	SHORT $LN13@xmlSchemaC

; 24109: 	xmlFree((xmlChar **)ielem->nsBindings);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 24110: 	ielem->nsBindings = NULL;

	mov	DWORD PTR [ebx+64], 0

; 24111: 	ielem->nbNsBindings = 0;

	mov	DWORD PTR [ebx+68], 0

; 24112: 	ielem->sizeNsBindings = 0;

	mov	DWORD PTR [ebx+72], 0
$LN13@xmlSchemaC:
	pop	ebx

; 24113:     }
; 24114: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaClearElemInfo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidatorPushAttribute
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_attrNode$ = 12						; size = 4
_nodeLine$ = 16						; size = 4
_localName$ = 20					; size = 4
_nsName$ = 24						; size = 4
_ownedNames$ = 28					; size = 4
_value$ = 32						; size = 4
_ownedValue$ = 36					; size = 4
_xmlSchemaValidatorPushAttribute PROC			; COMDAT

; 24007: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _vctxt$[ebp]
	push	edi
	call	_xmlSchemaGetFreshAttrInfo
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlSchemaV

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	eax
	push	eax
	push	OFFSET ??_C@_0CE@JCDDMGJO@calling?5xmlSchemaGetFreshAttrIn@
	push	OFFSET ??_C@_0BH@MIDCNBN@xmlSchemaPushAttribute@
	push	edi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 24008:     xmlSchemaAttrInfoPtr attr;
; 24009: 
; 24010:     attr = xmlSchemaGetFreshAttrInfo(vctxt);
; 24011:     if (attr == NULL) {
; 24012: 	VERROR_INT("xmlSchemaPushAttribute",
; 24013: 	    "calling xmlSchemaGetFreshAttrInfo()");
; 24014: 	return (-1);

	or	eax, -1
	pop	edi

; 24053: }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlSchemaV:

; 24015:     }
; 24016:     attr->node = attrNode;
; 24017:     attr->nodeLine = nodeLine;
; 24018:     attr->state = XML_SCHEMAS_ATTR_UNKNOWN;
; 24019:     attr->localName = localName;
; 24020:     attr->nsName = nsName;
; 24021:     if (ownedNames)

	cmp	DWORD PTR _ownedNames$[ebp], 0
	mov	eax, DWORD PTR _attrNode$[ebp]
	mov	edi, DWORD PTR _localName$[ebp]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR _nodeLine$[ebp]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR _nsName$[ebp]
	mov	DWORD PTR [esi+44], 1
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], eax
	je	SHORT $LN25@xmlSchemaV

; 24022: 	attr->flags |= XML_SCHEMA_NODE_INFO_FLAG_OWNED_NAMES;

	or	DWORD PTR [esi+32], 1
$LN25@xmlSchemaV:

; 24023:     /*
; 24024:     * Evaluate if it's an XSI attribute.
; 24025:     */
; 24026:     if (nsName != NULL) {

	test	eax, eax
	je	$LN17@xmlSchemaV

; 24027: 	if (xmlStrEqual(localName, BAD_CAST "nil")) {

	push	OFFSET ??_C@_03ILAMHENH@nil@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlSchemaV

; 24028: 	    if (xmlStrEqual(attr->nsName, xmlSchemaInstanceNs)) {

	push	DWORD PTR _xmlSchemaInstanceNs
	push	DWORD PTR [esi+16]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN17@xmlSchemaV

; 24029: 		attr->metaType = XML_SCHEMA_ATTR_INFO_META_XSI_NIL;

	mov	DWORD PTR [esi+48], 2

; 24030: 	    }

	jmp	$LN17@xmlSchemaV
$LN5@xmlSchemaV:

; 24031: 	} else if (xmlStrEqual(localName, BAD_CAST "type")) {

	push	OFFSET ??_C@_04GPMDFGEJ@type@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlSchemaV

; 24032: 	    if (xmlStrEqual(attr->nsName, xmlSchemaInstanceNs)) {

	push	DWORD PTR _xmlSchemaInstanceNs
	push	DWORD PTR [esi+16]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN17@xmlSchemaV

; 24033: 		attr->metaType = XML_SCHEMA_ATTR_INFO_META_XSI_TYPE;

	mov	DWORD PTR [esi+48], 1

; 24034: 	    }

	jmp	SHORT $LN17@xmlSchemaV
$LN8@xmlSchemaV:

; 24035: 	} else if (xmlStrEqual(localName, BAD_CAST "schemaLocation")) {

	push	OFFSET ??_C@_0P@DEMHLMFE@schemaLocation@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlSchemaV

; 24036: 	    if (xmlStrEqual(attr->nsName, xmlSchemaInstanceNs)) {

	push	DWORD PTR _xmlSchemaInstanceNs
	push	DWORD PTR [esi+16]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlSchemaV

; 24037: 		attr->metaType = XML_SCHEMA_ATTR_INFO_META_XSI_SCHEMA_LOC;

	mov	DWORD PTR [esi+48], 3

; 24038: 	    }

	jmp	SHORT $LN17@xmlSchemaV
$LN11@xmlSchemaV:

; 24039: 	} else if (xmlStrEqual(localName, BAD_CAST "noNamespaceSchemaLocation")) {

	push	OFFSET ??_C@_0BK@PJGHNDDL@noNamespaceSchemaLocation@
	push	edi
	call	_xmlStrEqual
	mov	ecx, DWORD PTR [esi+16]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlSchemaV

; 24040: 	    if (xmlStrEqual(attr->nsName, xmlSchemaInstanceNs)) {

	push	DWORD PTR _xmlSchemaInstanceNs
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlSchemaV

; 24041: 		attr->metaType = XML_SCHEMA_ATTR_INFO_META_XSI_NO_NS_SCHEMA_LOC;

	mov	DWORD PTR [esi+48], 4
	jmp	SHORT $LN17@xmlSchemaV
$LN14@xmlSchemaV:

; 24042: 	    }
; 24043: 	} else if (xmlStrEqual(attr->nsName, xmlNamespaceNs)) {

	push	DWORD PTR _xmlNamespaceNs
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlSchemaV

; 24044: 	    attr->metaType = XML_SCHEMA_ATTR_INFO_META_XMLNS;

	mov	DWORD PTR [esi+48], 5
$LN17@xmlSchemaV:

; 24045: 	}
; 24046:     }
; 24047:     attr->value = value;
; 24048:     if (ownedValue)

	cmp	DWORD PTR _ownedValue$[ebp], 0
	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [esi+20], eax
	je	SHORT $LN18@xmlSchemaV

; 24049: 	attr->flags |= XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES;

	or	DWORD PTR [esi+32], 2
$LN18@xmlSchemaV:

; 24050:     if (attr->metaType != 0)

	cmp	DWORD PTR [esi+48], 0
	je	SHORT $LN19@xmlSchemaV

; 24051: 	attr->state = XML_SCHEMAS_ATTR_META;

	mov	DWORD PTR [esi+44], 17			; 00000011H
$LN19@xmlSchemaV:
	pop	edi

; 24052:     return (0);

	xor	eax, eax

; 24053: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaValidatorPushAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetFreshAttrInfo
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_xmlSchemaGetFreshAttrInfo PROC				; COMDAT

; 23948: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _vctxt$[ebp]
	mov	ecx, DWORD PTR [esi+164]
	test	ecx, ecx
	jne	SHORT $LN2@xmlSchemaG

; 23949:     xmlSchemaAttrInfoPtr iattr;
; 23950:     /*
; 23951:     * Grow/create list of attribute infos.
; 23952:     */
; 23953:     if (vctxt->attrInfos == NULL) {
; 23954: 	vctxt->attrInfos = (xmlSchemaAttrInfoPtr *)

	push	4
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+164], eax

; 23955: 	    xmlMalloc(sizeof(xmlSchemaAttrInfoPtr));
; 23956: 	vctxt->sizeAttrInfos = 1;

	mov	DWORD PTR [esi+172], 1

; 23957: 	if (vctxt->attrInfos == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlSchemaG

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BP@IEFJMMAN@allocating?5attribute?5info?5list@
$LN24@xmlSchemaG:

; 23994: 
; 23995:     return (iattr);
; 23996: }

	inc	DWORD PTR [esi+56]
	push	0
	push	0
	push	2
	push	17					; 00000011H
	mov	DWORD PTR [esi+52], 1818		; 0000071aH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN2@xmlSchemaG:

; 23958: 	    xmlSchemaVErrMemory(vctxt,
; 23959: 		"allocating attribute info list", NULL);
; 23960: 	    return (NULL);
; 23961: 	}
; 23962:     } else if (vctxt->sizeAttrInfos <= vctxt->nbAttrInfos) {

	mov	edx, DWORD PTR [esi+172]
	mov	eax, DWORD PTR [esi+168]
	cmp	edx, eax
	jg	$LN5@xmlSchemaG

; 23963: 	vctxt->sizeAttrInfos++;

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [esi+172], eax

; 23964: 	vctxt->attrInfos = (xmlSchemaAttrInfoPtr *)

	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	DWORD PTR [esi+164], eax

; 23965: 	    xmlRealloc(vctxt->attrInfos,
; 23966: 		vctxt->sizeAttrInfos * sizeof(xmlSchemaAttrInfoPtr));
; 23967: 	if (vctxt->attrInfos == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlSchemaG

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@BAMAMEME@re?9allocating?5attribute?5info?5li@

; 23968: 	    xmlSchemaVErrMemory(vctxt,
; 23969: 		"re-allocating attribute info list", NULL);
; 23970: 	    return (NULL);

	jmp	SHORT $LN24@xmlSchemaG
$LN7@xmlSchemaG:

; 23981:     }
; 23982:     /*
; 23983:     * Create an attribute info.
; 23984:     */
; 23985:     iattr = (xmlSchemaAttrInfoPtr)

	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 23986: 	xmlMalloc(sizeof(xmlSchemaAttrInfo));
; 23987:     if (iattr == NULL) {

	test	eax, eax
	jne	SHORT $LN9@xmlSchemaG

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BM@BOOKJCLG@creating?5new?5attribute?5info@

; 23988: 	xmlSchemaVErrMemory(vctxt, "creating new attribute info", NULL);
; 23989: 	return (NULL);

	jmp	SHORT $LN24@xmlSchemaG
$LN9@xmlSchemaG:

; 23990:     }
; 23991:     memset(iattr, 0, sizeof(xmlSchemaAttrInfo));

	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0
	mov	DWORD PTR [eax+48], 0
	mov	DWORD PTR [eax+52], 0
	mov	DWORD PTR [eax+56], 0

; 23992:     iattr->nodeType = XML_ATTRIBUTE_NODE;

	mov	DWORD PTR [eax], 2

; 23993:     vctxt->attrInfos[vctxt->nbAttrInfos++] = iattr;

	mov	edx, DWORD PTR [esi+168]
	mov	ecx, DWORD PTR [esi+164]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	DWORD PTR [esi+168]
	pop	esi

; 23994: 
; 23995:     return (iattr);
; 23996: }

	pop	ebp
	ret	0
$LN5@xmlSchemaG:

; 23971: 	}
; 23972:     } else {
; 23973: 	iattr = vctxt->attrInfos[vctxt->nbAttrInfos++];

	mov	ecx, DWORD PTR [ecx+eax*4]
	inc	eax
	mov	DWORD PTR [esi+168], eax

; 23974: 	if (iattr->localName != NULL) {

	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN8@xmlSchemaG

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BG@PFNFPHPM@attr?5info?5not?5cleared@
	push	OFFSET ??_C@_0BK@LKOCBHBB@xmlSchemaGetFreshAttrInfo@
	push	esi
	call	_xmlSchemaInternalErr2

; 23994: 
; 23995:     return (iattr);
; 23996: }

	add	esp, 20					; 00000014H
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN8@xmlSchemaG:

; 23975: 	    VERROR_INT("xmlSchemaGetFreshAttrInfo",
; 23976: 		"attr info not cleared");
; 23977: 	    return (NULL);
; 23978: 	}
; 23979: 	iattr->nodeType = XML_ATTRIBUTE_NODE;

	mov	DWORD PTR [ecx], 2

; 23980: 	return (iattr);

	mov	eax, ecx
	pop	esi

; 23994: 
; 23995:     return (iattr);
; 23996: }

	pop	ebp
	ret	0
_xmlSchemaGetFreshAttrInfo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckCVCIDCKeyRef
_TEXT	SEGMENT
tv955 = -36						; size = 4
_i$1$ = -32						; size = 4
_refNode$1$ = -28					; size = 4
_namespaceName$1$ = -24					; size = 4
_namespaceName$1$ = -24					; size = 4
tv951 = -24						; size = 4
_hasDupls$1$ = -20					; size = 4
_nbFields$1$ = -16					; size = 4
_j$2$ = -12						; size = 4
_j$1$ = -12						; size = 4
_str$1 = -12						; size = 4
_str$2 = -12						; size = 4
_matcher$1$ = -8					; size = 4
_bind$1$ = -4						; size = 4
_vctxt$ = 8						; size = 4
_xmlSchemaCheckCVCIDCKeyRef PROC			; COMDAT

; 23826: {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _vctxt$[ebp]
	mov	eax, DWORD PTR [edi+108]
	mov	eax, DWORD PTR [eax+56]
	mov	DWORD PTR _matcher$1$[ebp], eax
	test	eax, eax
	je	$LN97@xmlSchemaC
	npad	9
$LL2@xmlSchemaC:

; 23827:     xmlSchemaIDCMatcherPtr matcher;
; 23828:     xmlSchemaPSVIIDCBindingPtr bind;
; 23829: 
; 23830:     matcher = vctxt->inode->idcMatchers;
; 23831:     /*
; 23832:     * Find a keyref.
; 23833:     */
; 23834:     while (matcher != NULL) {
; 23835: 	if ((matcher->idcType == XML_SCHEMA_TYPE_IDC_KEYREF) &&
; 23836: 	    matcher->targets &&

	cmp	DWORD PTR [eax+20], 24			; 00000018H
	jne	$LN7@xmlSchemaC
	mov	ecx, DWORD PTR [eax+32]
	test	ecx, ecx
	je	$LN7@xmlSchemaC
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	$LN7@xmlSchemaC

; 23837: 	    matcher->targets->nbItems)
; 23838: 	{
; 23839: 	    int i, j, k, res, nbFields, hasDupls;
; 23840: 	    xmlSchemaPSVIIDCKeyPtr *refKeys, *keys;
; 23841: 	    xmlSchemaPSVIIDCNodePtr refNode = NULL;
; 23842: 
; 23843: 	    nbFields = matcher->aidc->def->nbFields;

	mov	eax, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [eax+4]

; 23844: 
; 23845: 	    /*
; 23846: 	    * Find the IDC node-table for the referenced IDC key/unique.
; 23847: 	    */
; 23848: 	    bind = vctxt->inode->idcTable;

	mov	eax, DWORD PTR [edi+108]
	mov	ebx, DWORD PTR [edx+32]
	mov	edi, DWORD PTR [eax+52]
	mov	DWORD PTR _nbFields$1$[ebp], ebx
	mov	DWORD PTR _bind$1$[ebp], edi

; 23849: 	    while (bind != NULL) {

	test	edi, edi
	je	SHORT $LN39@xmlSchemaC

; 23850: 		if ((xmlSchemaIDCPtr) matcher->aidc->def->ref->item ==

	mov	eax, DWORD PTR [edx+36]
	mov	eax, DWORD PTR [eax+4]
	npad	1
$LL4@xmlSchemaC:
	cmp	eax, DWORD PTR [edi+4]
	je	SHORT $LN66@xmlSchemaC

; 23851: 		    bind->definition)
; 23852: 		    break;
; 23853: 		bind = bind->next;

	mov	edi, DWORD PTR [edi]
	mov	DWORD PTR _bind$1$[ebp], edi
	test	edi, edi
	jne	SHORT $LL4@xmlSchemaC

; 23854: 	    }
; 23855: 	    hasDupls = (bind && bind->dupls && bind->dupls->nbItems) ? 1 : 0;

	jmp	SHORT $LN39@xmlSchemaC
$LN66@xmlSchemaC:
	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN39@xmlSchemaC
	cmp	DWORD PTR [eax+4], 0
	mov	DWORD PTR _hasDupls$1$[ebp], 1
	jne	SHORT $LN40@xmlSchemaC
$LN39@xmlSchemaC:
	mov	DWORD PTR _hasDupls$1$[ebp], 0
$LN40@xmlSchemaC:

; 23856: 	    /*
; 23857: 	    * Search for a matching key-sequences.
; 23858: 	    */
; 23859: 	    for (i = 0; i < matcher->targets->nbItems; i++) {

	xor	edx, edx
	mov	DWORD PTR _i$1$[ebp], edx
	test	esi, esi
	jle	$LN106@xmlSchemaC
$LL8@xmlSchemaC:

; 23860: 		res = 0;
; 23861: 		refNode = matcher->targets->items[i];

	mov	ecx, DWORD PTR [ecx]
	xor	eax, eax
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _refNode$1$[ebp], ecx

; 23862: 		if (bind != NULL) {

	test	edi, edi
	je	$LN94@xmlSchemaC

; 23863: 		    refKeys = refNode->keys;

	mov	ecx, DWORD PTR [ecx+4]

; 23864: 		    for (j = 0; j < bind->nbNodes; j++) {

	xor	edx, edx
	mov	DWORD PTR tv951[ebp], ecx
	mov	DWORD PTR _j$1$[ebp], edx
	cmp	DWORD PTR [edi+12], eax
	jle	SHORT $LN95@xmlSchemaC
	npad	6
$LL11@xmlSchemaC:

; 23865: 			keys = bind->nodeTable[j]->keys;

	mov	ecx, DWORD PTR [edi+8]

; 23866: 			for (k = 0; k < nbFields; k++) {

	xor	edi, edi
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	esi, DWORD PTR [ecx+4]
	test	ebx, ebx
	jle	SHORT $LN67@xmlSchemaC

; 23865: 			keys = bind->nodeTable[j]->keys;

	mov	ecx, DWORD PTR tv951[ebp]
	sub	ecx, esi
	mov	DWORD PTR tv955[ebp], ecx
$LL14@xmlSchemaC:

; 23867: 			    res = xmlSchemaAreValuesEqual(keys[k]->val,

	mov	eax, DWORD PTR [esi+ecx]
	push	DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+4]
	call	_xmlSchemaAreValuesEqual
	add	esp, 8

; 23868: 				refKeys[k]->val);
; 23869: 			    if (res == 0)

	test	eax, eax
	je	SHORT $LN102@xmlSchemaC

; 23870: 				break;
; 23871: 			    else if (res == -1) {

	cmp	eax, -1
	je	$LN71@xmlSchemaC

; 23866: 			for (k = 0; k < nbFields; k++) {

	mov	ecx, DWORD PTR tv955[ebp]
	inc	edi
	add	esi, 4
	cmp	edi, ebx
	jl	SHORT $LL14@xmlSchemaC
$LN102@xmlSchemaC:

; 23872: 				return (-1);
; 23873: 			    }
; 23874: 			}
; 23875: 			if (res == 1) {

	mov	edx, DWORD PTR _j$1$[ebp]
$LN67@xmlSchemaC:
	mov	edi, DWORD PTR _bind$1$[ebp]
	cmp	eax, 1
	je	SHORT $LN69@xmlSchemaC

; 23864: 		    for (j = 0; j < bind->nbNodes; j++) {

	inc	edx
	mov	DWORD PTR _j$1$[ebp], edx
	cmp	edx, DWORD PTR [edi+12]
	jl	SHORT $LL11@xmlSchemaC
$LN69@xmlSchemaC:

; 23876: 			    /*
; 23877: 			    * Match found.
; 23878: 			    */
; 23879: 			    break;
; 23880: 			}
; 23881: 		    }
; 23882: 		    if ((res == 0) && hasDupls) {

	test	eax, eax
	jne	$LN6@xmlSchemaC
$LN95@xmlSchemaC:
	cmp	DWORD PTR _hasDupls$1$[ebp], 0
	je	SHORT $LN94@xmlSchemaC

; 23883: 			/*
; 23884: 			* Search in duplicates
; 23885: 			*/
; 23886: 			for (j = 0; j < bind->dupls->nbItems; j++) {

	mov	ecx, DWORD PTR [edi+20]
	xor	edx, edx
	mov	DWORD PTR _j$2$[ebp], edx
	cmp	DWORD PTR [ecx+4], edx
	jle	SHORT $LN94@xmlSchemaC
$LL17@xmlSchemaC:

; 23887: 			    keys = ((xmlSchemaPSVIIDCNodePtr)

	mov	ecx, DWORD PTR [ecx]

; 23888: 				bind->dupls->items[j])->keys;
; 23889: 			    for (k = 0; k < nbFields; k++) {

	xor	edi, edi
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	esi, DWORD PTR [ecx+4]
	test	ebx, ebx
	jle	SHORT $LN70@xmlSchemaC

; 23887: 			    keys = ((xmlSchemaPSVIIDCNodePtr)

	mov	ebx, DWORD PTR tv951[ebp]
	sub	ebx, esi
$LL20@xmlSchemaC:

; 23890: 				res = xmlSchemaAreValuesEqual(keys[k]->val,

	mov	eax, DWORD PTR [esi+ebx]
	push	DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+4]
	call	_xmlSchemaAreValuesEqual
	add	esp, 8

; 23891: 				    refKeys[k]->val);
; 23892: 				if (res == 0)

	test	eax, eax
	je	SHORT $LN101@xmlSchemaC

; 23893: 				    break;
; 23894: 				else if (res == -1) {

	cmp	eax, -1
	je	$LN71@xmlSchemaC

; 23888: 				bind->dupls->items[j])->keys;
; 23889: 			    for (k = 0; k < nbFields; k++) {

	inc	edi
	add	esi, 4
	cmp	edi, DWORD PTR _nbFields$1$[ebp]
	jl	SHORT $LL20@xmlSchemaC
$LN101@xmlSchemaC:

; 23895: 				    return (-1);
; 23896: 				}
; 23897: 			    }
; 23898: 			    if (res == 1) {

	mov	edx, DWORD PTR _j$2$[ebp]
	mov	ebx, DWORD PTR _nbFields$1$[ebp]
$LN70@xmlSchemaC:
	cmp	eax, 1
	je	SHORT $LN72@xmlSchemaC

; 23883: 			/*
; 23884: 			* Search in duplicates
; 23885: 			*/
; 23886: 			for (j = 0; j < bind->dupls->nbItems; j++) {

	mov	edi, DWORD PTR _bind$1$[ebp]
	inc	edx
	mov	DWORD PTR _j$2$[ebp], edx
	mov	ecx, DWORD PTR [edi+20]
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LL17@xmlSchemaC

; 23904: 				    XML_SCHEMAV_CVC_IDC, refNode,
; 23905: 				    (xmlSchemaTypePtr) matcher->aidc->def,
; 23906: 				    "More than one match found for "
; 23907: 				    "key-sequence %s of keyref '%s'",
; 23908: 				    xmlSchemaFormatIDCKeySequence(vctxt, &str,
; 23909: 					refNode->keys, nbFields),
; 23910: 				    xmlSchemaGetComponentQName(&strB,
; 23911: 					matcher->aidc->def));
; 23912: 				FREE_AND_NULL(str);
; 23913: 				FREE_AND_NULL(strB);
; 23914: 				break;
; 23915: 			    }
; 23916: 			}
; 23917: 		    }
; 23918: 		}
; 23919: 
; 23920: 		if (res == 0) {

	test	eax, eax
	jne	$LN6@xmlSchemaC
$LN94@xmlSchemaC:

; 23921: 		    xmlChar *str = NULL, *strB = NULL;
; 23922: 		    xmlSchemaKeyrefErr(vctxt,

	mov	eax, DWORD PTR _matcher$1$[ebp]
	mov	DWORD PTR _str$1[ebp], 0
	mov	eax, DWORD PTR [eax+16]
	mov	esi, DWORD PTR [eax+4]

; 1429 :     return (xmlSchemaFormatQName(buf,

	push	esi
	call	_xmlSchemaGetComponentName
	push	esi
	mov	edi, eax
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 8
	mov	DWORD PTR _namespaceName$1$[ebp], eax

; 1305 :     if (namespaceName != NULL) {

	xor	esi, esi
	test	eax, eax
	je	SHORT $LN54@xmlSchemaC

; 1306 : 	*buf = xmlStrdup(BAD_CAST "{");

	push	OFFSET ??_C@_01HCONENDN@?$HL@
	call	_xmlStrdup

; 1307 : 	*buf = xmlStrcat(*buf, namespaceName);

	push	DWORD PTR _namespaceName$1$[ebp]
	push	eax
	call	_xmlStrcat

; 1308 : 	*buf = xmlStrcat(*buf, BAD_CAST "}");

	push	OFFSET ??_C@_01CELHOKLL@?$HN@
	push	eax
	call	_xmlStrcat
	mov	esi, eax
	add	esp, 20					; 00000014H
	mov	eax, DWORD PTR _namespaceName$1$[ebp]
$LN54@xmlSchemaC:

; 1309 :     }
; 1310 :     if (localName != NULL) {

	test	edi, edi
	je	$LN55@xmlSchemaC

; 1311 : 	if (namespaceName == NULL)

	test	eax, eax
	je	$LN52@xmlSchemaC

; 1312 : 	    return(localName);
; 1313 : 	*buf = xmlStrcat(*buf, localName);
; 1314 :     } else {

	jmp	$LN56@xmlSchemaC
$LN72@xmlSchemaC:

; 23899: 				/*
; 23900: 				* Match in duplicates found.
; 23901: 				*/
; 23902: 				xmlChar *str = NULL, *strB = NULL;
; 23903: 				xmlSchemaKeyrefErr(vctxt,

	mov	eax, DWORD PTR _matcher$1$[ebp]
	mov	DWORD PTR _str$2[ebp], 0
	mov	eax, DWORD PTR [eax+16]
	mov	esi, DWORD PTR [eax+4]

; 1429 :     return (xmlSchemaFormatQName(buf,

	push	esi
	call	_xmlSchemaGetComponentName
	push	esi
	mov	edi, eax
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 8
	mov	DWORD PTR _namespaceName$1$[ebp], eax

; 1305 :     if (namespaceName != NULL) {

	xor	esi, esi
	test	eax, eax
	je	SHORT $LN45@xmlSchemaC

; 1306 : 	*buf = xmlStrdup(BAD_CAST "{");

	push	OFFSET ??_C@_01HCONENDN@?$HL@
	call	_xmlStrdup

; 1307 : 	*buf = xmlStrcat(*buf, namespaceName);

	push	DWORD PTR _namespaceName$1$[ebp]
	push	eax
	call	_xmlStrcat

; 1308 : 	*buf = xmlStrcat(*buf, BAD_CAST "}");

	push	OFFSET ??_C@_01CELHOKLL@?$HN@
	push	eax
	call	_xmlStrcat
	mov	esi, eax
	add	esp, 20					; 00000014H
	mov	eax, DWORD PTR _namespaceName$1$[ebp]
$LN45@xmlSchemaC:

; 1309 :     }
; 1310 :     if (localName != NULL) {

	test	edi, edi
	je	SHORT $LN46@xmlSchemaC

; 1311 : 	if (namespaceName == NULL)

	test	eax, eax
	je	SHORT $LN43@xmlSchemaC

; 1312 : 	    return(localName);
; 1313 : 	*buf = xmlStrcat(*buf, localName);
; 1314 :     } else {

	jmp	SHORT $LN47@xmlSchemaC
$LN46@xmlSchemaC:

; 1315 : 	*buf = xmlStrcat(*buf, BAD_CAST "(NULL)");

	mov	edi, OFFSET ??_C@_06LHGEHABH@?$CINULL?$CJ@
$LN47@xmlSchemaC:

; 1316 :     }
; 1317 :     return ((const xmlChar *) *buf);

	push	edi
	push	esi
	call	_xmlStrcat
	mov	esi, eax
	add	esp, 8
	mov	edi, esi
$LN43@xmlSchemaC:

; 23899: 				/*
; 23900: 				* Match in duplicates found.
; 23901: 				*/
; 23902: 				xmlChar *str = NULL, *strB = NULL;
; 23903: 				xmlSchemaKeyrefErr(vctxt,

	push	edi
	mov	edi, DWORD PTR _refNode$1$[ebp]
	lea	eax, DWORD PTR _str$2[ebp]
	push	ebx
	push	DWORD PTR [edi+4]
	push	eax
	push	DWORD PTR _vctxt$[ebp]
	call	_xmlSchemaFormatIDCKeySequence
	add	esp, 16					; 00000010H
	push	eax
	push	OFFSET ??_C@_0DN@GJPPLNCJ@More?5than?5one?5match?5found?5for?5k@

; 23904: 				    XML_SCHEMAV_CVC_IDC, refNode,
; 23905: 				    (xmlSchemaTypePtr) matcher->aidc->def,
; 23906: 				    "More than one match found for "
; 23907: 				    "key-sequence %s of keyref '%s'",
; 23908: 				    xmlSchemaFormatIDCKeySequence(vctxt, &str,
; 23909: 					refNode->keys, nbFields),
; 23910: 				    xmlSchemaGetComponentQName(&strB,
; 23911: 					matcher->aidc->def));
; 23912: 				FREE_AND_NULL(str);
; 23913: 				FREE_AND_NULL(strB);
; 23914: 				break;
; 23915: 			    }
; 23916: 			}
; 23917: 		    }
; 23918: 		}
; 23919: 
; 23920: 		if (res == 0) {

	jmp	SHORT $LN111@xmlSchemaC
$LN55@xmlSchemaC:

; 1315 : 	*buf = xmlStrcat(*buf, BAD_CAST "(NULL)");

	mov	edi, OFFSET ??_C@_06LHGEHABH@?$CINULL?$CJ@
$LN56@xmlSchemaC:

; 1316 :     }
; 1317 :     return ((const xmlChar *) *buf);

	push	edi
	push	esi
	call	_xmlStrcat
	mov	esi, eax
	add	esp, 8
	mov	edi, esi
$LN52@xmlSchemaC:

; 23921: 		    xmlChar *str = NULL, *strB = NULL;
; 23922: 		    xmlSchemaKeyrefErr(vctxt,

	push	edi
	mov	edi, DWORD PTR _refNode$1$[ebp]
	lea	eax, DWORD PTR _str$1[ebp]
	push	ebx
	push	DWORD PTR [edi+4]
	push	eax
	push	DWORD PTR _vctxt$[ebp]
	call	_xmlSchemaFormatIDCKeySequence
	add	esp, 16					; 00000010H
	push	eax
	push	OFFSET ??_C@_0DC@DKEGLJJH@No?5match?5found?5for?5key?9sequence@
$LN111@xmlSchemaC:

; 23856: 	    /*
; 23857: 	    * Search for a matching key-sequences.
; 23858: 	    */
; 23859: 	    for (i = 0; i < matcher->targets->nbItems; i++) {

	mov	eax, DWORD PTR _matcher$1$[ebp]
	mov	eax, DWORD PTR [eax+16]
	push	DWORD PTR [eax+4]
	push	edi
	push	1877					; 00000755H
	push	DWORD PTR _vctxt$[ebp]
	call	_xmlSchemaKeyrefErr
	mov	eax, DWORD PTR _str$1[ebp]
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	SHORT $LN36@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN36@xmlSchemaC:
	test	esi, esi
	je	SHORT $LN104@xmlSchemaC
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN104@xmlSchemaC:
	mov	edi, DWORD PTR _bind$1$[ebp]
$LN6@xmlSchemaC:
	mov	eax, DWORD PTR _matcher$1$[ebp]
	mov	edx, DWORD PTR _i$1$[ebp]
	inc	edx
	mov	DWORD PTR _i$1$[ebp], edx
	mov	ecx, DWORD PTR [eax+32]
	cmp	edx, DWORD PTR [ecx+4]
	jl	$LL8@xmlSchemaC
	jmp	SHORT $LN107@xmlSchemaC
$LN106@xmlSchemaC:
	mov	eax, DWORD PTR _matcher$1$[ebp]
$LN107@xmlSchemaC:

; 23923: 			XML_SCHEMAV_CVC_IDC, refNode,
; 23924: 			(xmlSchemaTypePtr) matcher->aidc->def,
; 23925: 			"No match found for key-sequence %s of keyref '%s'",
; 23926: 			xmlSchemaFormatIDCKeySequence(vctxt, &str,
; 23927: 			    refNode->keys, nbFields),
; 23928: 			xmlSchemaGetComponentQName(&strB, matcher->aidc->def));
; 23929: 		    FREE_AND_NULL(str);
; 23930: 		    FREE_AND_NULL(strB);
; 23931: 		}
; 23932: 	    }
; 23933: 	}
; 23934: 	matcher = matcher->next;

	mov	edi, DWORD PTR _vctxt$[ebp]
$LN7@xmlSchemaC:
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _matcher$1$[ebp], eax
	test	eax, eax
	jne	$LL2@xmlSchemaC
$LN97@xmlSchemaC:
	pop	edi

; 23935:     }
; 23936:     /* TODO: Return an error if any error encountered. */
; 23937:     return (0);
; 23938: }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@xmlSchemaC:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCheckCVCIDCKeyRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaBubbleIDCNodeTables
_TEXT	SEGMENT
_i$1$ = -44						; size = 4
_dupls$1$ = -40						; size = 4
_j$2$ = -36						; size = 4
_j$1$ = -36						; size = 4
_parNodes$1$ = -32					; size = 4
_parNode$1$ = -28					; size = 4
_bind$1$ = -24						; size = 4
_node$1$ = -20						; size = 4
_oldNum$1$ = -16					; size = 4
_oldDupls$1$ = -12					; size = 4
_parTable$1$ = -8					; size = 4
_parBind$1$ = -4					; size = 4
_vctxt$ = 8						; size = 4
_xmlSchemaBubbleIDCNodeTables PROC			; COMDAT

; 23531: {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _vctxt$[ebp]
	xor	edi, edi
	xor	esi, esi
	mov	DWORD PTR _parBind$1$[ebp], edi
	mov	DWORD PTR _parNode$1$[ebp], edi
	mov	eax, DWORD PTR [edx+108]
	mov	ebx, DWORD PTR [eax+52]
	mov	DWORD PTR _bind$1$[ebp], ebx
	test	ebx, ebx
	je	$LN3@xmlSchemaB

; 23532:     xmlSchemaPSVIIDCBindingPtr bind; /* IDC bindings of the current node. */
; 23533:     xmlSchemaPSVIIDCBindingPtr *parTable, parBind = NULL; /* parent IDC bindings. */
; 23534:     xmlSchemaPSVIIDCNodePtr node, parNode = NULL, *dupls, *parNodes; /* node-table entries. */
; 23535:     xmlSchemaIDCAugPtr aidc;
; 23536:     int i, j, k, ret = 0, nbFields, oldNum, oldDupls;
; 23537: 
; 23538:     bind = vctxt->inode->idcTable;
; 23539:     if (bind == NULL) {
; 23540: 	/* Fine, no table, no bubbles. */
; 23541: 	return (0);
; 23542:     }
; 23543: 
; 23544:     parTable = &(vctxt->elemInfos[vctxt->depth -1]->idcTable);

	mov	ecx, DWORD PTR [edx+96]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR [eax+ecx*4-4]
	add	ecx, 52					; 00000034H
	mov	DWORD PTR _parTable$1$[ebp], ecx
$LL2@xmlSchemaB:

; 23545:     /*
; 23546:     * Walk all bindings; create new or add to existing bindings.
; 23547:     * Remove duplicate key-sequences.
; 23548:     */
; 23549:     while (bind != NULL) {
; 23550: 
; 23551: 	if ((bind->nbNodes == 0) && WXS_ILIST_IS_EMPTY(bind->dupls))

	mov	edx, DWORD PTR [ebx+12]
	test	edx, edx
	jne	SHORT $LN149@xmlSchemaB
	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	je	$next_binding$169
	cmp	DWORD PTR [eax+4], edx
	je	$next_binding$169
$LN149@xmlSchemaB:

; 23552: 	    goto next_binding;
; 23553: 	/*
; 23554: 	* Check if the key/unique IDC table needs to be bubbled.
; 23555: 	*/
; 23556: 	if (! vctxt->createIDCNodeTables) {

	mov	eax, DWORD PTR _vctxt$[ebp]
	cmp	DWORD PTR [eax+188], 0
	jne	SHORT $LN5@xmlSchemaB

; 23557: 	    aidc = vctxt->aidcs;

	mov	eax, DWORD PTR [eax+112]

; 23558: 	    do {
; 23559: 		if (aidc->def == bind->definition) {

	mov	ecx, DWORD PTR [ebx+4]
	npad	2
$LL6@xmlSchemaB:
	cmp	DWORD PTR [eax+4], ecx
	je	$LN105@xmlSchemaB

; 23561: 			(aidc->keyrefDepth >= vctxt->depth)) {
; 23562: 			goto next_binding;
; 23563: 		    }
; 23564: 		    break;
; 23565: 		}
; 23566: 		aidc = aidc->next;

	mov	eax, DWORD PTR [eax]

; 23567: 	    } while (aidc != NULL);

	test	eax, eax
	jne	SHORT $LL6@xmlSchemaB
	mov	ecx, DWORD PTR _parTable$1$[ebp]
$LN5@xmlSchemaB:

; 23568: 	}
; 23569: 
; 23570: 	if (parTable != NULL)

	test	ecx, ecx
	je	SHORT $LN150@xmlSchemaB

; 23571: 	    parBind = *parTable;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR _parBind$1$[ebp], edi
$LN150@xmlSchemaB:

; 23572: 	/*
; 23573: 	* Search a matching parent binding for the
; 23574: 	* IDC definition.
; 23575: 	*/
; 23576: 	while (parBind != NULL) {

	test	edi, edi
	je	SHORT $LN31@xmlSchemaB

; 23577: 	    if (parBind->definition == bind->definition)

	mov	ebx, DWORD PTR [ebx+4]
$LL7@xmlSchemaB:
	cmp	DWORD PTR [edi+4], ebx
	je	$LN106@xmlSchemaB

; 23578: 		break;
; 23579: 	    parBind = parBind->next;

	mov	edi, DWORD PTR [edi]
	mov	DWORD PTR _parBind$1$[ebp], edi
	test	edi, edi
	jne	SHORT $LL7@xmlSchemaB

; 23580: 	}
; 23581: 
; 23582: 	if (parBind != NULL) {

	mov	ebx, DWORD PTR _bind$1$[ebp]
$LN31@xmlSchemaB:

; 23734: 		    }
; 23735: 
; 23736: 		}
; 23737: 
; 23738: 	    }
; 23739: 	} else {
; 23740: 	    /*
; 23741: 	    * No binding for the IDC was found: create a new one and
; 23742: 	    * copy all node-tables.
; 23743: 	    */
; 23744: 	    parBind = xmlSchemaIDCNewBinding(bind->definition);

	mov	edi, DWORD PTR [ebx+4]

; 22081:     ret = (xmlSchemaPSVIIDCBindingPtr) xmlMalloc(

	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _parBind$1$[ebp], eax

; 22082: 	    sizeof(xmlSchemaPSVIIDCBinding));
; 22083:     if (ret == NULL) {

	test	eax, eax
	je	$LN146@xmlSchemaB
	xorps	xmm0, xmm0

; 22084: 	xmlSchemaVErrMemory(NULL,
; 22085: 	    "allocating a PSVI IDC binding item", NULL);
; 22086: 	return (NULL);
; 22087:     }
; 22088:     memset(ret, 0, sizeof(xmlSchemaPSVIIDCBinding));

	movups	XMMWORD PTR [eax], xmm0
	movq	QWORD PTR [eax+16], xmm0

; 22089:     ret->definition = idcDef;

	mov	DWORD PTR [eax+4], edi

; 23745: 	    if (parBind == NULL)
; 23746: 		goto internal_error;
; 23747: 
; 23748: 	    /*
; 23749: 	    * TODO: Hmm, how to optimize the initial number of
; 23750: 	    * allocated entries?
; 23751: 	    */
; 23752: 	    if (bind->nbNodes != 0) {

	mov	eax, DWORD PTR [ebx+12]
	test	eax, eax
	je	$LN158@xmlSchemaB

; 23753: 		/*
; 23754: 		* Add all IDC node-table entries.
; 23755: 		*/
; 23756: 		if (! vctxt->psviExposeIDCNodeTables) {

	mov	ecx, DWORD PTR _vctxt$[ebp]
	cmp	DWORD PTR [ecx+192], 0
	jne	$LN65@xmlSchemaB

; 23757: 		    /*
; 23758: 		    * Just move the entries.
; 23759: 		    * NOTE: this is quite save here, since
; 23760: 		    * all the keyref lookups have already been
; 23761: 		    * performed.
; 23762: 		    */
; 23763: 		    parBind->nodeTable = bind->nodeTable;

	mov	edi, DWORD PTR _parBind$1$[ebp]
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [edi+8], eax

; 23764: 		    bind->nodeTable = NULL;
; 23765: 		    parBind->sizeNodes = bind->sizeNodes;

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [edi+16], eax

; 23766: 		    bind->sizeNodes = 0;
; 23767: 		    parBind->nbNodes = bind->nbNodes;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [ebx+16], 0
	mov	DWORD PTR [edi+12], eax

; 23768: 		    bind->nbNodes = 0;

	mov	DWORD PTR [ebx+12], 0

; 23769: 		} else {

	jmp	$LN66@xmlSchemaB
$LN105@xmlSchemaB:

; 23560: 		    if ((aidc->keyrefDepth == -1) ||

	mov	eax, DWORD PTR [eax+8]
	cmp	eax, -1
	je	$LN164@xmlSchemaB
	mov	ecx, DWORD PTR _vctxt$[ebp]
	cmp	eax, DWORD PTR [ecx+96]
	mov	ecx, DWORD PTR _parTable$1$[ebp]
	jge	$next_binding$169

; 23567: 	    } while (aidc != NULL);

	jmp	$LN5@xmlSchemaB
$LN106@xmlSchemaB:

; 23583: 	    /*
; 23584: 	    * Compare every node-table entry of the child node,
; 23585: 	    * i.e. the key-sequence within, ...
; 23586: 	    */
; 23587: 	    oldNum = parBind->nbNodes; /* Skip newly added items. */

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR _oldNum$1$[ebp], eax

; 23588: 
; 23589: 	    if (! WXS_ILIST_IS_EMPTY(parBind->dupls)) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN33@xmlSchemaB
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _oldDupls$1$[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN33@xmlSchemaB

; 23590: 		oldDupls = parBind->dupls->nbItems;
; 23591: 		dupls = (xmlSchemaPSVIIDCNodePtr *) parBind->dupls->items;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _dupls$1$[ebp], eax

; 23592: 	    } else {

	jmp	SHORT $LN34@xmlSchemaB
$LN33@xmlSchemaB:

; 23593: 		dupls = NULL;
; 23594: 		oldDupls = 0;

	xor	ecx, ecx
	mov	DWORD PTR _dupls$1$[ebp], 0
	mov	DWORD PTR _oldDupls$1$[ebp], ecx
$LN34@xmlSchemaB:

; 23595: 	    }
; 23596: 
; 23597: 	    parNodes = parBind->nodeTable;

	mov	eax, DWORD PTR [edi+8]

; 23598: 	    nbFields = bind->definition->nbFields;
; 23599: 
; 23600: 	    for (i = 0; i < bind->nbNodes; i++) {

	xor	ecx, ecx
	mov	ebx, DWORD PTR [ebx+32]
	mov	DWORD PTR _parNodes$1$[ebp], eax
	mov	DWORD PTR _i$1$[ebp], ecx
	test	edx, edx
	jle	$LN161@xmlSchemaB
	mov	eax, DWORD PTR _bind$1$[ebp]
	npad	5
$LL11@xmlSchemaB:

; 23601: 		node = bind->nodeTable[i];

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _node$1$[ebp], ecx

; 23602: 		if (node == NULL)

	test	ecx, ecx
	je	$LN9@xmlSchemaB

; 23603: 		    continue;
; 23604: 		/*
; 23605: 		* ...with every key-sequence of the parent node, already
; 23606: 		* evaluated to be a duplicate key-sequence.
; 23607: 		*/
; 23608: 		if (oldDupls) {

	mov	edx, DWORD PTR _oldDupls$1$[ebp]
	test	edx, edx
	je	$LN44@xmlSchemaB

; 23609: 		    j = 0;

	xor	edi, edi
	mov	DWORD PTR _j$1$[ebp], edi

; 23610: 		    while (j < oldDupls) {

	test	edx, edx
	jle	$LN110@xmlSchemaB
	npad	7
$LL12@xmlSchemaB:

; 23611: 			if (nbFields == 1) {

	mov	eax, DWORD PTR _dupls$1$[ebp]
	mov	eax, DWORD PTR [eax+edi*4]
	cmp	ebx, 1
	jne	SHORT $LN37@xmlSchemaB

; 23612: 			    ret = xmlSchemaAreValuesEqual(

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	call	_xmlSchemaAreValuesEqual
	mov	esi, eax
	add	esp, 8

; 23613: 				node->keys[0]->val,
; 23614: 				dupls[j]->keys[0]->val);
; 23615: 			    if (ret == -1)

	cmp	esi, -1
	je	$internal_error$170

; 23616: 				goto internal_error;
; 23617: 			    if (ret == 0) {

	mov	edx, DWORD PTR _oldDupls$1$[ebp]
	test	esi, esi
	je	SHORT $LN122@xmlSchemaB

; 23618: 				j++;
; 23619: 				continue;
; 23620: 			    }
; 23621: 			} else {

	jmp	SHORT $LN108@xmlSchemaB
$LN37@xmlSchemaB:

; 23622: 			    parNode = dupls[j];
; 23623: 			    for (k = 0; k < nbFields; k++) {

	xor	edi, edi
	mov	DWORD PTR _parNode$1$[ebp], eax
	test	ebx, ebx
	jle	SHORT $LN156@xmlSchemaB
$LL16@xmlSchemaB:

; 23624: 				ret = xmlSchemaAreValuesEqual(

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+edi*4]
	push	DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+edi*4]
	push	DWORD PTR [eax+4]
	call	_xmlSchemaAreValuesEqual
	mov	esi, eax
	add	esp, 8

; 23625: 				    node->keys[k]->val,
; 23626: 				    parNode->keys[k]->val);
; 23627: 				if (ret == -1)

	cmp	esi, -1
	je	$internal_error$170

; 23628: 				    goto internal_error;
; 23629: 				if (ret == 0)

	test	esi, esi
	je	SHORT $LN157@xmlSchemaB

; 23622: 			    parNode = dupls[j];
; 23623: 			    for (k = 0; k < nbFields; k++) {

	mov	eax, DWORD PTR _parNode$1$[ebp]
	inc	edi
	mov	ecx, DWORD PTR _node$1$[ebp]
	cmp	edi, ebx
	jl	SHORT $LL16@xmlSchemaB
$LN157@xmlSchemaB:

; 23630: 				    break;
; 23631: 			    }
; 23632: 			}
; 23633: 			if (ret == 1)

	mov	edx, DWORD PTR _oldDupls$1$[ebp]
$LN156@xmlSchemaB:
	mov	edi, DWORD PTR _j$1$[ebp]
$LN108@xmlSchemaB:
	cmp	esi, 1
	je	SHORT $LN110@xmlSchemaB
$LN122@xmlSchemaB:

; 23610: 		    while (j < oldDupls) {

	mov	ecx, DWORD PTR _node$1$[ebp]
	inc	edi
	mov	DWORD PTR _j$1$[ebp], edi
	cmp	edi, edx
	jl	$LL12@xmlSchemaB
$LN110@xmlSchemaB:

; 23634: 			    /* Duplicate found. */
; 23635: 			    break;
; 23636: 			j++;
; 23637: 		    }
; 23638: 		    if (j != oldDupls) {

	cmp	edi, edx
	mov	edi, DWORD PTR _parBind$1$[ebp]
	jne	$LN9@xmlSchemaB
	mov	ecx, DWORD PTR _node$1$[ebp]
$LN44@xmlSchemaB:

; 23639: 			/* Duplicate found. Skip this entry. */
; 23640: 			continue;
; 23641: 		    }
; 23642: 		}
; 23643: 		/*
; 23644: 		* ... and with every key-sequence of the parent node.
; 23645: 		*/
; 23646: 		if (oldNum) {

	mov	edx, DWORD PTR _oldNum$1$[ebp]
	test	edx, edx
	je	$LN9@xmlSchemaB

; 23647: 		    j = 0;

	xor	edi, edi
	mov	DWORD PTR _j$2$[ebp], edi

; 23648: 		    while (j < oldNum) {

	test	edx, edx
	jle	$LN114@xmlSchemaB
$LL17@xmlSchemaB:

; 23649: 			parNode = parNodes[j];

	mov	eax, DWORD PTR _parNodes$1$[ebp]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR _parNode$1$[ebp], eax

; 23650: 			if (nbFields == 1) {

	cmp	ebx, 1
	jne	SHORT $LN46@xmlSchemaB

; 23651: 			    ret = xmlSchemaAreValuesEqual(

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	call	_xmlSchemaAreValuesEqual
	mov	esi, eax
	add	esp, 8

; 23652: 				node->keys[0]->val,
; 23653: 				parNode->keys[0]->val);
; 23654: 			    if (ret == -1)

	cmp	esi, -1
	je	$internal_error$170

; 23655: 				goto internal_error;
; 23656: 			    if (ret == 0) {

	mov	edx, DWORD PTR _oldNum$1$[ebp]
	test	esi, esi
	je	SHORT $LN124@xmlSchemaB

; 23657: 				j++;
; 23658: 				continue;
; 23659: 			    }
; 23660: 			} else {

	jmp	SHORT $LN112@xmlSchemaB
$LN46@xmlSchemaB:

; 23661: 			    for (k = 0; k < nbFields; k++) {

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN154@xmlSchemaB
$LL21@xmlSchemaB:

; 23662: 				ret = xmlSchemaAreValuesEqual(

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+edi*4]
	push	DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+edi*4]
	push	DWORD PTR [eax+4]
	call	_xmlSchemaAreValuesEqual
	mov	esi, eax
	add	esp, 8

; 23663: 				    node->keys[k]->val,
; 23664: 				    parNode->keys[k]->val);
; 23665: 				if (ret == -1)

	cmp	esi, -1
	je	$internal_error$170

; 23666: 				    goto internal_error;
; 23667: 				if (ret == 0)

	test	esi, esi
	je	SHORT $LN155@xmlSchemaB

; 23661: 			    for (k = 0; k < nbFields; k++) {

	mov	eax, DWORD PTR _parNode$1$[ebp]
	inc	edi
	mov	ecx, DWORD PTR _node$1$[ebp]
	cmp	edi, ebx
	jl	SHORT $LL21@xmlSchemaB
$LN155@xmlSchemaB:

; 23668: 				    break;
; 23669: 			    }
; 23670: 			}
; 23671: 			if (ret == 1)

	mov	edx, DWORD PTR _oldNum$1$[ebp]
$LN154@xmlSchemaB:
	mov	edi, DWORD PTR _j$2$[ebp]
$LN112@xmlSchemaB:
	cmp	esi, 1
	je	SHORT $LN114@xmlSchemaB
$LN124@xmlSchemaB:

; 23648: 		    while (j < oldNum) {

	mov	ecx, DWORD PTR _node$1$[ebp]
	inc	edi
	mov	DWORD PTR _j$2$[ebp], edi
	cmp	edi, edx
	jl	$LL17@xmlSchemaB
$LN114@xmlSchemaB:

; 23672: 			    /* Duplicate found. */
; 23673: 			    break;
; 23674: 			j++;
; 23675: 		    }
; 23676: 		    if (j != oldNum) {

	cmp	edi, edx
	je	SHORT $LN53@xmlSchemaB

; 23677: 			/*
; 23678: 			* Handle duplicates. Move the duplicate in
; 23679: 			* the parent's node-table to the list of
; 23680: 			* duplicates.
; 23681: 			*/
; 23682: 			oldNum--;
; 23683: 			parBind->nbNodes--;

	mov	eax, DWORD PTR _parBind$1$[ebp]
	dec	edx

; 23684: 			/*
; 23685: 			* Move last old item to pos of duplicate.
; 23686: 			*/
; 23687: 			parNodes[j] = parNodes[oldNum];

	mov	ecx, DWORD PTR _parNodes$1$[ebp]
	mov	DWORD PTR _oldNum$1$[ebp], edx
	dec	DWORD PTR [eax+12]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ecx+edi*4], eax

; 23688: 
; 23689: 			if (parBind->nbNodes != oldNum) {

	mov	edi, DWORD PTR _parBind$1$[ebp]
	mov	eax, DWORD PTR [edi+12]
	cmp	eax, edx
	je	SHORT $LN55@xmlSchemaB

; 23690: 			    /*
; 23691: 			    * If new items exist, move last new item to
; 23692: 			    * last of old items.
; 23693: 			    */
; 23694: 			    parNodes[oldNum] =

	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx+edx*4], eax
$LN55@xmlSchemaB:

; 23695: 				parNodes[parBind->nbNodes];
; 23696: 			}
; 23697: 			if (parBind->dupls == NULL) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	jne	SHORT $LN57@xmlSchemaB

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 3342 :     if (ret == NULL) {

	test	eax, eax
	je	$LN148@xmlSchemaB
	xorps	xmm0, xmm0

; 3343 : 	xmlSchemaPErrMemory(NULL,
; 3344 : 	    "allocating an item list structure", NULL);
; 3345 : 	return (NULL);
; 3346 :     }
; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));

	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], 0

; 23698: 			    parBind->dupls = xmlSchemaItemListCreate();

	mov	DWORD PTR [edi+20], eax
$LN57@xmlSchemaB:

; 23699: 			    if (parBind->dupls == NULL)
; 23700: 				goto internal_error;
; 23701: 			}
; 23702: 			xmlSchemaItemListAdd(parBind->dupls, parNode);

	push	DWORD PTR _parNode$1$[ebp]
	push	eax
	call	_xmlSchemaItemListAdd
	add	esp, 8

; 23703: 		    } else {

	jmp	SHORT $LN9@xmlSchemaB
$LN53@xmlSchemaB:

; 23704: 			/*
; 23705: 			* Add the node-table entry (node and key-sequence) of
; 23706: 			* the child node to the node table of the parent node.
; 23707: 			*/
; 23708: 			if (parBind->nodeTable == NULL) {

	mov	edi, DWORD PTR _parBind$1$[ebp]
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR _parNodes$1$[ebp], edx
	test	edx, edx
	jne	SHORT $LN58@xmlSchemaB

; 23709: 			    parBind->nodeTable = (xmlSchemaPSVIIDCNodePtr *)

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR _parNodes$1$[ebp], edx
	mov	DWORD PTR [edi+8], edx

; 23710: 				xmlMalloc(10 * sizeof(xmlSchemaPSVIIDCNodePtr));
; 23711: 			    if (parBind->nodeTable == NULL) {

	test	edx, edx
	je	$LN116@xmlSchemaB

; 23715: 			    }
; 23716: 			    parBind->sizeNodes = 1;

	mov	DWORD PTR [edi+16], 1
	jmp	SHORT $LN62@xmlSchemaB
$LN58@xmlSchemaB:

; 23717: 			} else if (parBind->nbNodes >= parBind->sizeNodes) {

	mov	eax, DWORD PTR [edi+16]
	cmp	DWORD PTR [edi+12], eax
	jl	SHORT $LN62@xmlSchemaB

; 23718: 			    parBind->sizeNodes *= 2;

	add	eax, eax
	mov	DWORD PTR [edi+16], eax

; 23719: 			    parBind->nodeTable = (xmlSchemaPSVIIDCNodePtr *)

	shl	eax, 2
	push	eax
	push	edx
	call	DWORD PTR _xmlRealloc
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR _parNodes$1$[ebp], edx
	mov	DWORD PTR [edi+8], edx

; 23720: 				xmlRealloc(parBind->nodeTable, parBind->sizeNodes *
; 23721: 				sizeof(xmlSchemaPSVIIDCNodePtr));
; 23722: 			    if (parBind->nodeTable == NULL) {

	test	edx, edx
	je	$LN117@xmlSchemaB
$LN62@xmlSchemaB:

; 23726: 			    }
; 23727: 			}
; 23728: 			parNodes = parBind->nodeTable;
; 23729: 			/*
; 23730: 			* Append the new node-table entry to the 'new node-table
; 23731: 			* entries' section.
; 23732: 			*/
; 23733: 			parNodes[parBind->nbNodes++] = node;

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR _node$1$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
	inc	DWORD PTR [edi+12]
$LN9@xmlSchemaB:

; 23598: 	    nbFields = bind->definition->nbFields;
; 23599: 
; 23600: 	    for (i = 0; i < bind->nbNodes; i++) {

	mov	ecx, DWORD PTR _i$1$[ebp]
	mov	eax, DWORD PTR _bind$1$[ebp]
	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	ecx, DWORD PTR [eax+12]
	jl	$LL11@xmlSchemaB
$LN161@xmlSchemaB:

; 23804:                 }
; 23805:             }
; 23806: 	}
; 23807: 
; 23808: next_binding:
; 23809: 	bind = bind->next;

	mov	ebx, DWORD PTR _bind$1$[ebp]
$LN164@xmlSchemaB:
	mov	ecx, DWORD PTR _parTable$1$[ebp]
$next_binding$169:
	mov	ebx, DWORD PTR [ebx]
	mov	DWORD PTR _bind$1$[ebp], ebx
	test	ebx, ebx
	jne	$LL2@xmlSchemaB
$LN3@xmlSchemaB:
	pop	edi

; 23815: }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN65@xmlSchemaB:

; 23770: 		    /*
; 23771: 		    * Copy the entries.
; 23772: 		    */
; 23773: 		    parBind->nodeTable = (xmlSchemaPSVIIDCNodePtr *)

	shl	eax, 2
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	edi, DWORD PTR _parBind$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [edi+8], eax

; 23774: 			xmlMalloc(bind->nbNodes *
; 23775: 			sizeof(xmlSchemaPSVIIDCNodePtr));
; 23776: 		    if (parBind->nodeTable == NULL) {

	test	eax, eax
	je	$LN119@xmlSchemaB

; 23781: 			goto internal_error;
; 23782: 		    }
; 23783: 		    parBind->sizeNodes = bind->nbNodes;

	mov	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR [edi+16], ecx

; 23784: 		    parBind->nbNodes = bind->nbNodes;

	mov	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR [edi+12], ecx

; 23785: 		    memcpy(parBind->nodeTable, bind->nodeTable,

	mov	ecx, DWORD PTR [ebx+12]
	shl	ecx, 2
	push	ecx
	push	DWORD PTR [ebx+8]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN66@xmlSchemaB
$LN158@xmlSchemaB:

; 23745: 	    if (parBind == NULL)
; 23746: 		goto internal_error;
; 23747: 
; 23748: 	    /*
; 23749: 	    * TODO: Hmm, how to optimize the initial number of
; 23750: 	    * allocated entries?
; 23751: 	    */
; 23752: 	    if (bind->nbNodes != 0) {

	mov	edi, DWORD PTR _parBind$1$[ebp]
$LN66@xmlSchemaB:

; 23786: 			bind->nbNodes * sizeof(xmlSchemaPSVIIDCNodePtr));
; 23787: 		}
; 23788: 	    }
; 23789: 	    if (bind->dupls) {

	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	je	SHORT $LN68@xmlSchemaB

; 23790: 		/*
; 23791: 		* Move the duplicates.
; 23792: 		*/
; 23793: 		if (parBind->dupls != NULL)

	mov	ecx, DWORD PTR [edi+20]
	test	ecx, ecx
	je	SHORT $LN69@xmlSchemaB

; 23794: 		    xmlSchemaItemListFree(parBind->dupls);

	push	ecx
	call	_xmlSchemaItemListFree
	mov	eax, DWORD PTR [ebx+20]
	add	esp, 4
$LN69@xmlSchemaB:

; 23795: 		parBind->dupls = bind->dupls;

	mov	DWORD PTR [edi+20], eax

; 23796: 		bind->dupls = NULL;

	mov	DWORD PTR [ebx+20], 0
$LN68@xmlSchemaB:

; 23797: 	    }
; 23798:             if (parTable != NULL) {

	mov	ecx, DWORD PTR _parTable$1$[ebp]
	test	ecx, ecx
	je	SHORT $next_binding$169

; 23799:                 if (*parTable == NULL)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN71@xmlSchemaB

; 23800:                     *parTable = parBind;

	mov	DWORD PTR [ecx], edi
	jmp	$next_binding$169
$LN71@xmlSchemaB:

; 23801:                 else {
; 23802:                     parBind->next = *parTable;

	mov	DWORD PTR [edi], eax

; 23803:                     *parTable = parBind;

	mov	DWORD PTR [ecx], edi
	jmp	$next_binding$169
$LN148@xmlSchemaB:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@BAFOADOL@allocating?5an?5item?5list?5structu@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError

; 23810:     }
; 23811:     return (0);
; 23812: 
; 23813: internal_error:
; 23814:     return(-1);

	add	esp, 20					; 00000014H
	mov	DWORD PTR [edi+20], 0
	or	eax, -1
	pop	edi

; 23815: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN116@xmlSchemaB:

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CI@JFHKHDCD@allocating?5IDC?5list?5of?5node?9tab@

; 23712: 				xmlSchemaVErrMemory(NULL,
; 23713: 				    "allocating IDC list of node-table items", NULL);
; 23714: 				goto internal_error;

	jmp	SHORT $LN167@xmlSchemaB
$LN117@xmlSchemaB:

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CL@KOFMLKDP@re?9allocating?5IDC?5list?5of?5node?9@

; 23723: 				xmlSchemaVErrMemory(NULL,
; 23724: 				    "re-allocating IDC list of node-table items", NULL);
; 23725: 				goto internal_error;

	jmp	SHORT $LN167@xmlSchemaB
$LN119@xmlSchemaB:

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CM@BBNGODJA@allocating?5an?5array?5of?5IDC?5node@
	push	0
	push	0
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError

; 23777: 			xmlSchemaVErrMemory(NULL,
; 23778: 			    "allocating an array of IDC node-table "
; 23779: 			    "items", NULL);
; 23780: 			xmlSchemaIDCFreeBinding(parBind);

	push	edi
	call	_xmlSchemaIDCFreeBinding
	add	esp, 24					; 00000018H

; 23810:     }
; 23811:     return (0);
; 23812: 
; 23813: internal_error:
; 23814:     return(-1);

	or	eax, -1
	pop	edi

; 23815: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN146@xmlSchemaB:

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CD@HDBDLPGB@allocating?5a?5PSVI?5IDC?5binding?5i@
$LN167@xmlSchemaB:

; 23810:     }
; 23811:     return (0);
; 23812: 
; 23813: internal_error:
; 23814:     return(-1);

	push	0
	push	0
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
$internal_error$170:

; 23815: }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaBubbleIDCNodeTables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIDCFillNodeTables
_TEXT	SEGMENT
_nbTargets$1$ = -44					; size = 4
tv1333 = -40						; size = 4
_targets$1$ = -36					; size = 4
_i$1$ = -32						; size = 4
_nbDupls$1$ = -28					; size = 4
_j$2$ = -24						; size = 4
_j$1$ = -24						; size = 4
_keys$1$ = -20						; size = 4
_nbNodeTable$1$ = -16					; size = 4
_matcher$1$ = -12					; size = 4
_dupls$1$ = -8						; size = 4
_nbFields$1$ = -4					; size = 4
_vctxt$ = 8						; size = 4
_bind$1$ = 12						; size = 4
_ielem$ = 12						; size = 4
_xmlSchemaIDCFillNodeTables PROC			; COMDAT

; 23336: {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ielem$[ebp]
	mov	edx, DWORD PTR [eax+56]
	mov	DWORD PTR _matcher$1$[ebp], edx
	test	edx, edx
	je	$LN3@xmlSchemaI
$LL2@xmlSchemaI:

; 23345: 	/*
; 23346: 	* Skip keyref IDCs and empty IDC target-lists.
; 23347: 	*/
; 23348: 	if ((matcher->aidc->def->type == XML_SCHEMA_TYPE_IDC_KEYREF) ||

	mov	eax, DWORD PTR [edx+16]
	mov	edi, DWORD PTR [eax+4]
	cmp	DWORD PTR [edi], 24			; 00000018H
	je	$LN5@xmlSchemaI
	mov	ecx, DWORD PTR [edx+32]
	test	ecx, ecx
	je	$LN5@xmlSchemaI
	cmp	DWORD PTR [ecx+4], 0
	je	$LN5@xmlSchemaI

; 23349: 	    WXS_ILIST_IS_EMPTY(matcher->targets))
; 23350: 	{
; 23351: 	    matcher = matcher->next;
; 23352: 	    continue;
; 23353: 	}
; 23354: 	/*
; 23355: 	* If we _want_ the IDC node-table to be created in any case
; 23356: 	* then do so. Otherwise create them only if keyrefs need them.
; 23357: 	*/
; 23358: 	if ((! vctxt->createIDCNodeTables) &&

	mov	ebx, DWORD PTR _vctxt$[ebp]
	cmp	DWORD PTR [ebx+188], 0
	jne	SHORT $LN22@xmlSchemaI
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, -1
	je	$LN5@xmlSchemaI
	cmp	eax, DWORD PTR [ebx+96]
	jg	$LN5@xmlSchemaI
$LN22@xmlSchemaI:

; 22231:     ielem = vctxt->elemInfos[matcher->depth];

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ebx+100]
	mov	ebx, DWORD PTR [eax+ecx*4]

; 22232: 
; 22233:     if (ielem->idcTable == NULL) {

	mov	esi, DWORD PTR [ebx+52]
	test	esi, esi
	jne	SHORT $LL53@xmlSchemaI

; 22081:     ret = (xmlSchemaPSVIIDCBindingPtr) xmlMalloc(

	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _bind$1$[ebp], eax

; 22082: 	    sizeof(xmlSchemaPSVIIDCBinding));
; 22083:     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN62@xmlSchemaI

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CD@HDBDLPGB@allocating?5a?5PSVI?5IDC?5binding?5i@
	push	eax
	push	eax
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError

; 22237: 	return(ielem->idcTable);

	mov	edx, DWORD PTR _matcher$1$[ebp]

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	add	esp, 20					; 00000014H

; 22086: 	return (NULL);

	xor	edi, edi
	mov	DWORD PTR _bind$1$[ebp], edi

; 22234: 	ielem->idcTable = xmlSchemaIDCNewBinding(matcher->aidc->def);

	mov	DWORD PTR [ebx+52], edi

; 22235: 	if (ielem->idcTable == NULL)
; 22236: 	    return (NULL);
; 22237: 	return(ielem->idcTable);

	jmp	SHORT $LN50@xmlSchemaI
$LN62@xmlSchemaI:
	mov	edx, DWORD PTR _matcher$1$[ebp]
	xorps	xmm0, xmm0

; 22088:     memset(ret, 0, sizeof(xmlSchemaPSVIIDCBinding));

	movups	XMMWORD PTR [eax], xmm0
	movq	QWORD PTR [eax+16], xmm0

; 22089:     ret->definition = idcDef;

	mov	DWORD PTR [eax+4], edi
	mov	edi, DWORD PTR _bind$1$[ebp]

; 22234: 	ielem->idcTable = xmlSchemaIDCNewBinding(matcher->aidc->def);

	mov	DWORD PTR [ebx+52], edi

; 22235: 	if (ielem->idcTable == NULL)
; 22236: 	    return (NULL);
; 22237: 	return(ielem->idcTable);

	jmp	SHORT $LN50@xmlSchemaI
$LL53@xmlSchemaI:

; 22238:     } else {
; 22239: 	xmlSchemaPSVIIDCBindingPtr bind = NULL;
; 22240: 
; 22241: 	bind = ielem->idcTable;
; 22242: 	do {
; 22243: 	    if (bind->definition == matcher->aidc->def)

	cmp	DWORD PTR [esi+4], edi
	je	SHORT $LN96@xmlSchemaI

; 22245: 	    if (bind->next == NULL) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN97@xmlSchemaI

; 22250: 	    }
; 22251: 	    bind = bind->next;

	mov	esi, eax

; 22252: 	} while (bind != NULL);

	test	esi, esi
	jne	SHORT $LL53@xmlSchemaI

; 22253:     }
; 22254:     return (NULL);

	xor	edi, edi
	jmp	SHORT $LN146@xmlSchemaI
$LN97@xmlSchemaI:

; 22246: 		bind->next = xmlSchemaIDCNewBinding(matcher->aidc->def);

	push	edi
	call	_xmlSchemaIDCNewBinding

; 22247: 		if (bind->next == NULL)
; 22248: 		    return (NULL);
; 22249: 		return(bind->next);

	mov	edx, DWORD PTR _matcher$1$[ebp]
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR [esi], edi
	jmp	SHORT $LN146@xmlSchemaI
$LN96@xmlSchemaI:

; 22244: 		return(bind);

	mov	edi, esi
$LN146@xmlSchemaI:

; 23359: 	    ((matcher->aidc->keyrefDepth == -1) ||
; 23360: 	     (matcher->aidc->keyrefDepth > vctxt->depth)))
; 23361: 	{
; 23362: 	    matcher = matcher->next;
; 23363: 	    continue;
; 23364: 	}
; 23365: 	/*
; 23366: 	* Get/create the IDC binding on this element for the IDC definition.
; 23367: 	*/
; 23368: 	bind = xmlSchemaIDCAcquireBinding(vctxt, matcher);
; 23369: 
; 23370: 	if (! WXS_ILIST_IS_EMPTY(bind->dupls)) {

	mov	DWORD PTR _bind$1$[ebp], edi
$LN50@xmlSchemaI:
	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN24@xmlSchemaI
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR _nbDupls$1$[ebp], ebx
	test	ebx, ebx
	je	SHORT $LN24@xmlSchemaI

; 23371: 	    dupls = (xmlSchemaPSVIIDCNodePtr *) bind->dupls->items;

	mov	esi, DWORD PTR [eax]

; 23372: 	    nbDupls = bind->dupls->nbItems;
; 23373: 	} else {

	jmp	SHORT $LN147@xmlSchemaI
$LN24@xmlSchemaI:

; 23374: 	    dupls = NULL;

	xor	esi, esi

; 23375: 	    nbDupls = 0;

	xor	ebx, ebx
	mov	DWORD PTR _nbDupls$1$[ebp], ebx
$LN147@xmlSchemaI:

; 23376: 	}
; 23377: 	if (bind->nodeTable != NULL) {

	cmp	DWORD PTR [edi+8], 0
	mov	DWORD PTR _dupls$1$[ebp], esi
	je	$LN26@xmlSchemaI

; 23378: 	    nbNodeTable = bind->nbNodes;

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR _nbNodeTable$1$[ebp], eax

; 23381: 	}
; 23382: 
; 23383: 	if ((nbNodeTable == 0) && (nbDupls == 0)) {

	test	eax, eax
	je	SHORT $LN128@xmlSchemaI
$LN134@xmlSchemaI:

; 23396: 	    /*
; 23397: 	    * Compare the key-sequences and add to the IDC node-table.
; 23398: 	    */
; 23399: 	    nbTargets = matcher->targets->nbItems;

	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+4]

; 23400: 	    targets = (xmlSchemaPSVIIDCNodePtr *) matcher->targets->items;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _targets$1$[ebp], eax

; 23401: 	    nbFields = matcher->aidc->def->nbFields;

	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _nbTargets$1$[ebp], ecx
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+32]

; 23402: 	    i = 0;

	xor	eax, eax
	mov	DWORD PTR _nbFields$1$[ebp], ecx
	mov	DWORD PTR _i$1$[ebp], eax
$LL6@xmlSchemaI:

; 23403: 	    do {
; 23404: 		keys = targets[i]->keys;

	mov	edx, DWORD PTR _targets$1$[ebp]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv1333[ebp], eax
	mov	eax, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _keys$1$[ebp], edx

; 23405: 		if (nbDupls) {

	test	ebx, ebx
	je	$LN8@xmlSchemaI

; 23406: 		    /*
; 23407: 		    * Search in already found duplicates first.
; 23408: 		    */
; 23409: 		    j = 0;

	xor	eax, eax
	mov	DWORD PTR _j$1$[ebp], eax
$LL9@xmlSchemaI:

; 23410: 		    do {
; 23411: 			if (nbFields == 1) {

	mov	eax, DWORD PTR [esi+eax*4]
	mov	ebx, DWORD PTR [eax+4]
	cmp	ecx, 1
	jne	SHORT $LN31@xmlSchemaI

; 23412: 			    res = xmlSchemaAreValuesEqual(keys[0]->val,

	mov	eax, DWORD PTR [ebx]
	push	DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx]
	push	DWORD PTR [eax+4]
	call	_xmlSchemaAreValuesEqual
	add	esp, 8

; 23413: 				dupls[j]->keys[0]->val);
; 23414: 			    if (res == -1)

	cmp	eax, -1
	je	$internal_error$152

; 23415: 				goto internal_error;
; 23416: 			    if (res == 1) {

	cmp	eax, 1
	je	$LN139@xmlSchemaI

; 23417: 				/*
; 23418: 				* Equal key-sequence.
; 23419: 				*/
; 23420: 				goto next_target;
; 23421: 			    }
; 23422: 			} else {

	mov	ecx, DWORD PTR _nbFields$1$[ebp]
	jmp	$LN148@xmlSchemaI
$LN26@xmlSchemaI:

; 23379: 	} else {
; 23380: 	    nbNodeTable = 0;

	mov	DWORD PTR _nbNodeTable$1$[ebp], 0
$LN128@xmlSchemaI:

; 23381: 	}
; 23382: 
; 23383: 	if ((nbNodeTable == 0) && (nbDupls == 0)) {

	test	ebx, ebx
	jne	$LN134@xmlSchemaI

; 23384: 	    /*
; 23385: 	    * Transfer all IDC target-nodes to the IDC node-table.
; 23386: 	    */
; 23387: 	    bind->nodeTable =

	mov	eax, DWORD PTR [edx+32]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edi+8], eax

; 23388: 		(xmlSchemaPSVIIDCNodePtr *) matcher->targets->items;
; 23389: 	    bind->sizeNodes = matcher->targets->sizeItems;

	mov	eax, DWORD PTR [edx+32]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edi+16], eax

; 23390: 	    bind->nbNodes = matcher->targets->nbItems;

	mov	eax, DWORD PTR [edx+32]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+12], eax

; 23391: 
; 23392: 	    matcher->targets->items = NULL;

	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [eax], ebx

; 23393: 	    matcher->targets->sizeItems = 0;

	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [eax+8], ebx

; 23394: 	    matcher->targets->nbItems = 0;

	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [eax+4], ebx

; 23395: 	} else {

	jmp	$LN5@xmlSchemaI
$LN31@xmlSchemaI:

; 23425: 			    for (k = 0; k < nbFields; k++) {

	xor	edi, edi
	test	ecx, ecx
	jle	SHORT $LN37@xmlSchemaI

; 23423: 			    res = 0;
; 23424: 			    ntkeys = dupls[j]->keys;

	mov	esi, edx
	sub	ebx, edx
$LL12@xmlSchemaI:

; 23426: 				res = xmlSchemaAreValuesEqual(keys[k]->val,

	mov	eax, DWORD PTR [ebx+esi]
	push	DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+4]
	call	_xmlSchemaAreValuesEqual
	add	esp, 8

; 23427: 				    ntkeys[k]->val);
; 23428: 				if (res == -1)

	cmp	eax, -1
	je	$internal_error$152

; 23429: 				    goto internal_error;
; 23430: 				if (res == 0) {

	mov	ecx, DWORD PTR _nbFields$1$[ebp]
	test	eax, eax
	je	SHORT $LN99@xmlSchemaI

; 23425: 			    for (k = 0; k < nbFields; k++) {

	inc	edi
	add	esi, 4
	cmp	edi, ecx
	jl	SHORT $LL12@xmlSchemaI
$LN99@xmlSchemaI:

; 23431: 				    /*
; 23432: 				    * One of the keys differs.
; 23433: 				    */
; 23434: 				    break;
; 23435: 				}
; 23436: 			    }
; 23437: 			    if (res == 1) {

	mov	esi, DWORD PTR _dupls$1$[ebp]
	cmp	eax, 1
	je	$LN139@xmlSchemaI
$LN148@xmlSchemaI:

; 23438: 				/*
; 23439: 				* Equal key-sequence found.
; 23440: 				*/
; 23441: 				goto next_target;
; 23442: 			    }
; 23443: 			}
; 23444: 			j++;

	mov	edx, DWORD PTR _keys$1$[ebp]
$LN37@xmlSchemaI:
	mov	eax, DWORD PTR _j$1$[ebp]
	inc	eax
	mov	DWORD PTR _j$1$[ebp], eax

; 23445: 		    } while (j < nbDupls);

	cmp	eax, DWORD PTR _nbDupls$1$[ebp]
	jl	$LL9@xmlSchemaI
	mov	edi, DWORD PTR _bind$1$[ebp]
$LN8@xmlSchemaI:

; 23446: 		}
; 23447: 		if (nbNodeTable) {

	cmp	DWORD PTR _nbNodeTable$1$[ebp], 0
	je	$LN14@xmlSchemaI

; 23448: 		    j = 0;

	xor	esi, esi
	mov	DWORD PTR _j$2$[ebp], esi
	npad	4
$LL15@xmlSchemaI:

; 23449: 		    do {
; 23450: 			if (nbFields == 1) {

	mov	eax, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	ebx, DWORD PTR [eax+4]
	cmp	ecx, 1
	jne	SHORT $LN39@xmlSchemaI

; 23451: 			    res = xmlSchemaAreValuesEqual(keys[0]->val,

	mov	eax, DWORD PTR [ebx]
	push	DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx]
	push	DWORD PTR [eax+4]
	call	_xmlSchemaAreValuesEqual
	add	esp, 8

; 23452: 				bind->nodeTable[j]->keys[0]->val);
; 23453: 			    if (res == -1)

	cmp	eax, -1
	je	$internal_error$152

; 23454: 				goto internal_error;
; 23455: 			    if (res == 0) {

	test	eax, eax
	jne	SHORT $LN17@xmlSchemaI

; 23456: 				/*
; 23457: 				* The key-sequence differs.
; 23458: 				*/
; 23459: 				goto next_node_table_entry;

	jmp	SHORT $next_node_table_entry$153
$LN39@xmlSchemaI:

; 23460: 			    }
; 23461: 			} else {
; 23462: 			    res = 0;
; 23463: 			    ntkeys = bind->nodeTable[j]->keys;
; 23464: 			    for (k = 0; k < nbFields; k++) {

	xor	esi, esi
	mov	edi, edx
	sub	ebx, edx
$LL18@xmlSchemaI:
	cmp	esi, ecx
	jge	SHORT $LN136@xmlSchemaI

; 23465: 				res = xmlSchemaAreValuesEqual(keys[k]->val,

	mov	eax, DWORD PTR [edi+ebx]
	push	DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edi]
	push	DWORD PTR [eax+4]
	call	_xmlSchemaAreValuesEqual
	add	esp, 8

; 23466: 				    ntkeys[k]->val);
; 23467: 				if (res == -1)

	cmp	eax, -1
	je	$internal_error$152

; 23468: 				    goto internal_error;
; 23469: 				if (res == 0) {

	test	eax, eax
	je	SHORT $LN137@xmlSchemaI

; 23460: 			    }
; 23461: 			} else {
; 23462: 			    res = 0;
; 23463: 			    ntkeys = bind->nodeTable[j]->keys;
; 23464: 			    for (k = 0; k < nbFields; k++) {

	mov	ecx, DWORD PTR _nbFields$1$[ebp]
	inc	esi
	add	edi, 4
	jmp	SHORT $LL18@xmlSchemaI
$LN137@xmlSchemaI:

; 23468: 				    goto internal_error;
; 23469: 				if (res == 0) {

	mov	esi, DWORD PTR _j$2$[ebp]
	mov	edi, DWORD PTR _bind$1$[ebp]
$next_node_table_entry$153:

; 23494: 
; 23495: next_node_table_entry:
; 23496: 			j++;

	inc	esi
	mov	DWORD PTR _j$2$[ebp], esi

; 23497: 		    } while (j < nbNodeTable);

	cmp	esi, DWORD PTR _nbNodeTable$1$[ebp]
	jge	SHORT $LN14@xmlSchemaI

; 23345: 	/*
; 23346: 	* Skip keyref IDCs and empty IDC target-lists.
; 23347: 	*/
; 23348: 	if ((matcher->aidc->def->type == XML_SCHEMA_TYPE_IDC_KEYREF) ||

	mov	ecx, DWORD PTR _nbFields$1$[ebp]
	mov	edx, DWORD PTR _keys$1$[ebp]
	jmp	SHORT $LL15@xmlSchemaI
$LN136@xmlSchemaI:

; 23460: 			    }
; 23461: 			} else {
; 23462: 			    res = 0;
; 23463: 			    ntkeys = bind->nodeTable[j]->keys;
; 23464: 			    for (k = 0; k < nbFields; k++) {

	mov	esi, DWORD PTR _j$2$[ebp]
	mov	edi, DWORD PTR _bind$1$[ebp]
$LN17@xmlSchemaI:

; 23470: 				    /*
; 23471: 				    * One of the keys differs.
; 23472: 				    */
; 23473: 				    goto next_node_table_entry;
; 23474: 				}
; 23475: 			    }
; 23476: 			}
; 23477: 			/*
; 23478: 			* Add the duplicate to the list of duplicates.
; 23479: 			*/
; 23480: 			if (bind->dupls == NULL) {

	mov	ecx, DWORD PTR [edi+20]
	test	ecx, ecx
	jne	SHORT $LN46@xmlSchemaI

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4

; 3342 :     if (ret == NULL) {

	test	ecx, ecx
	je	$LN132@xmlSchemaI
	xorps	xmm0, xmm0

; 3343 : 	xmlSchemaPErrMemory(NULL,
; 3344 : 	    "allocating an item list structure", NULL);
; 3345 : 	return (NULL);
; 3346 :     }
; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));

	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], 0

; 23481: 			    bind->dupls = xmlSchemaItemListCreate();

	mov	DWORD PTR [edi+20], ecx
$LN46@xmlSchemaI:

; 23482: 			    if (bind->dupls == NULL)
; 23483: 				goto internal_error;
; 23484: 			}
; 23485: 			if (xmlSchemaItemListAdd(bind->dupls, bind->nodeTable[j]) == -1)

	mov	eax, DWORD PTR [edi+8]
	push	DWORD PTR [eax+esi*4]
	push	ecx
	call	_xmlSchemaItemListAdd
	add	esp, 8
	cmp	eax, -1
	je	$internal_error$152

; 23486: 			    goto internal_error;
; 23487: 			/*
; 23488: 			* Remove the duplicate entry from the IDC node-table.
; 23489: 			*/
; 23490: 			bind->nodeTable[j] = bind->nodeTable[bind->nbNodes -1];

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [ecx+eax*4-4]
	mov	DWORD PTR [ecx+esi*4], eax

; 23491: 			bind->nbNodes--;

	dec	DWORD PTR [edi+12]

; 23492: 
; 23493: 			goto next_target;

	mov	esi, DWORD PTR _dupls$1$[ebp]
	jmp	SHORT $next_target$154
$LN14@xmlSchemaI:

; 23498: 		}
; 23499: 		/*
; 23500: 		* If everything is fine, then add the IDC target-node to
; 23501: 		* the IDC node-table.
; 23502: 		*/
; 23503: 		if (xmlSchemaIDCAppendNodeTableItem(bind, targets[i]) == -1)

	mov	esi, DWORD PTR tv1333[ebp]

; 22190:     if (bind->nodeTable == NULL) {

	mov	ecx, DWORD PTR [edi+8]

; 23498: 		}
; 23499: 		/*
; 23500: 		* If everything is fine, then add the IDC target-node to
; 23501: 		* the IDC node-table.
; 23502: 		*/
; 23503: 		if (xmlSchemaIDCAppendNodeTableItem(bind, targets[i]) == -1)

	mov	esi, DWORD PTR [esi]

; 22190:     if (bind->nodeTable == NULL) {

	test	ecx, ecx
	jne	SHORT $LN74@xmlSchemaI

; 22191: 	bind->sizeNodes = 10;
; 22192: 	bind->nodeTable = (xmlSchemaPSVIIDCNodePtr *)

	push	40					; 00000028H
	mov	DWORD PTR [edi+16], 10			; 0000000aH
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [edi+8], ecx

; 22193: 	    xmlMalloc(10 * sizeof(xmlSchemaPSVIIDCNodePtr));
; 22194: 	if (bind->nodeTable == NULL) {

	test	ecx, ecx
	jne	SHORT $LN78@xmlSchemaI

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CM@BBNGODJA@allocating?5an?5array?5of?5IDC?5node@

; 22197: 	    return(-1);

	jmp	$LN150@xmlSchemaI
$LN74@xmlSchemaI:

; 22198: 	}
; 22199:     } else if (bind->sizeNodes <= bind->nbNodes) {

	mov	eax, DWORD PTR [edi+16]
	cmp	eax, DWORD PTR [edi+12]
	jg	SHORT $LN78@xmlSchemaI

; 22200: 	bind->sizeNodes *= 2;

	add	eax, eax
	mov	DWORD PTR [edi+16], eax

; 22201: 	bind->nodeTable = (xmlSchemaPSVIIDCNodePtr *)

	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR [edi+8], ecx

; 22202: 	    xmlRealloc(bind->nodeTable, bind->sizeNodes *
; 22203: 		sizeof(xmlSchemaPSVIIDCNodePtr));
; 22204: 	if (bind->nodeTable == NULL) {

	test	ecx, ecx
	je	SHORT $LN130@xmlSchemaI
$LN78@xmlSchemaI:

; 22205: 	    xmlSchemaVErrMemory(NULL,
; 22206: 		"re-allocating an array of IDC node-table items", NULL);
; 22207: 	    return(-1);
; 22208: 	}
; 22209:     }
; 22210:     bind->nodeTable[bind->nbNodes++] = ntItem;

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [ecx+eax*4], esi
	inc	DWORD PTR [edi+12]

; 23431: 				    /*
; 23432: 				    * One of the keys differs.
; 23433: 				    */
; 23434: 				    break;
; 23435: 				}
; 23436: 			    }
; 23437: 			    if (res == 1) {

	mov	esi, DWORD PTR _dupls$1$[ebp]
	jmp	SHORT $next_target$154
$LN139@xmlSchemaI:

; 23504: 		    goto internal_error;
; 23505: 
; 23506: next_target:
; 23507: 		i++;

	mov	edi, DWORD PTR _bind$1$[ebp]
$next_target$154:
	mov	eax, DWORD PTR _i$1$[ebp]

; 23508: 	    } while (i < nbTargets);

	mov	ecx, DWORD PTR _nbFields$1$[ebp]
	inc	eax
	mov	ebx, DWORD PTR _nbDupls$1$[ebp]
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, DWORD PTR _nbTargets$1$[ebp]
	jl	$LL6@xmlSchemaI
	mov	edx, DWORD PTR _matcher$1$[ebp]
$LN5@xmlSchemaI:

; 23337:     xmlSchemaPSVIIDCBindingPtr bind;
; 23338:     int res, i, j, k, nbTargets, nbFields, nbDupls, nbNodeTable;
; 23339:     xmlSchemaPSVIIDCKeyPtr *keys, *ntkeys;
; 23340:     xmlSchemaPSVIIDCNodePtr *targets, *dupls;
; 23341: 
; 23342:     xmlSchemaIDCMatcherPtr matcher = ielem->idcMatchers;
; 23343:     /* vctxt->createIDCNodeTables */
; 23344:     while (matcher != NULL) {

	mov	eax, DWORD PTR [edx+8]
	mov	edx, eax
	mov	DWORD PTR _matcher$1$[ebp], eax
	test	eax, eax
	jne	$LL2@xmlSchemaI
$LN3@xmlSchemaI:
	pop	edi

; 23516: }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN132@xmlSchemaI:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@BAFOADOL@allocating?5an?5item?5list?5structu@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError

; 23509: 	}
; 23510: 	matcher = matcher->next;
; 23511:     }
; 23512:     return(0);
; 23513: 
; 23514: internal_error:
; 23515:     return(-1);

	add	esp, 20					; 00000014H
	mov	DWORD PTR [edi+20], 0
	or	eax, -1
	pop	edi

; 23516: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN130@xmlSchemaI:

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CP@OHLCMMHI@re?9allocating?5an?5array?5of?5IDC?5n@
$LN150@xmlSchemaI:

; 23509: 	}
; 23510: 	matcher = matcher->next;
; 23511:     }
; 23512:     return(0);
; 23513: 
; 23514: internal_error:
; 23515:     return(-1);

	push	0
	push	0
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
$internal_error$152:

; 23516: }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaIDCFillNodeTables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIDCRegisterMatchers
_TEXT	SEGMENT
_last$1$ = -4						; size = 4
_vctxt$ = 8						; size = 4
_elemDecl$ = 12						; size = 4
_xmlSchemaIDCRegisterMatchers PROC			; COMDAT

; 23215: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _elemDecl$[ebp]
	mov	DWORD PTR _last$1$[ebp], 0
	mov	edi, DWORD PTR [eax+100]
	test	edi, edi
	je	$LN38@xmlSchemaI

; 23216:     xmlSchemaIDCMatcherPtr matcher, last = NULL;
; 23217:     xmlSchemaIDCPtr idc, refIdc;
; 23218:     xmlSchemaIDCAugPtr aidc;
; 23219: 
; 23220:     idc = (xmlSchemaIDCPtr) elemDecl->idcs;
; 23221:     if (idc == NULL)
; 23222: 	return (0);
; 23223: 
; 23224: #ifdef DEBUG_IDC
; 23225:     {
; 23226: 	xmlChar *str = NULL;
; 23227: 	xmlGenericError(xmlGenericErrorContext,
; 23228: 	    "IDC: REGISTER on %s, depth %d\n",
; 23229: 	    (char *) xmlSchemaFormatQName(&str, vctxt->inode->nsName,
; 23230: 		vctxt->inode->localName), vctxt->depth);
; 23231: 	FREE_AND_NULL(str)
; 23232:     }
; 23233: #endif
; 23234:     if (vctxt->inode->idcMatchers != NULL) {

	mov	ebx, DWORD PTR _vctxt$[ebp]
	mov	eax, DWORD PTR [ebx+108]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LL4@xmlSchemaI

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0DC@BCHPJJHO@The?5chain?5of?5IDC?5matchers?5is?5ex@
$LN84@xmlSchemaI:

; 23330:     return (0);
; 23331: }

	push	OFFSET ??_C@_0BN@FHFHOILP@xmlSchemaIDCRegisterMatchers@
	push	ebx
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$LN85@xmlSchemaI:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LL4@xmlSchemaI:

; 23235: 	VERROR_INT("xmlSchemaIDCRegisterMatchers",
; 23236: 	    "The chain of IDC matchers is expected to be empty");
; 23237: 	return (-1);
; 23238:     }
; 23239:     do {
; 23240: 	if (idc->type == XML_SCHEMA_TYPE_IDC_KEYREF) {

	cmp	DWORD PTR [edi], 24			; 00000018H
	jne	SHORT $LN15@xmlSchemaI

; 23241: 	    /*
; 23242: 	    * Since IDCs bubbles are expensive we need to know the
; 23243: 	    * depth at which the bubbles should stop; this will be
; 23244: 	    * the depth of the top-most keyref IDC. If no keyref
; 23245: 	    * references a key/unique IDC, the keyrefDepth will
; 23246: 	    * be -1, indicating that no bubbles are needed.
; 23247: 	    */
; 23248: 	    refIdc = (xmlSchemaIDCPtr) idc->ref->item;

	mov	eax, DWORD PTR [edi+36]
	mov	edx, DWORD PTR [eax+4]

; 23249: 	    if (refIdc != NULL) {

	test	edx, edx
	je	SHORT $LN15@xmlSchemaI

; 23250: 		/*
; 23251: 		* Remember that we have keyrefs on this node.
; 23252: 		*/
; 23253: 		vctxt->inode->hasKeyrefs = 1;

	mov	eax, DWORD PTR [ebx+108]
	mov	DWORD PTR [eax+76], 1

; 23254: 		/*
; 23255: 		* Lookup the referenced augmented IDC info.
; 23256: 		*/
; 23257: 		aidc = vctxt->aidcs;

	mov	ecx, DWORD PTR [ebx+112]

; 23258: 		while (aidc != NULL) {

	test	ecx, ecx
	je	SHORT $LN39@xmlSchemaI
$LL5@xmlSchemaI:

; 23259: 		    if (aidc->def == refIdc)

	cmp	DWORD PTR [ecx+4], edx
	je	SHORT $LN35@xmlSchemaI

; 23260: 			break;
; 23261: 		    aidc = aidc->next;

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $LL5@xmlSchemaI
$LN39@xmlSchemaI:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0DL@HKBGOKJP@Could?5not?5find?5an?5augmented?5IDC@

; 23282: 	}
; 23283: 	if (aidc == NULL) {
; 23284: 	    VERROR_INT("xmlSchemaIDCRegisterMatchers",
; 23285: 		"Could not find an augmented IDC item for an IDC definition");
; 23286: 	    return (-1);

	jmp	SHORT $LN84@xmlSchemaI
$LN35@xmlSchemaI:

; 23262: 		}
; 23263: 		if (aidc == NULL) {
; 23264: 		    VERROR_INT("xmlSchemaIDCRegisterMatchers",
; 23265: 			"Could not find an augmented IDC item for an IDC "
; 23266: 			"definition");
; 23267: 		    return (-1);
; 23268: 		}
; 23269: 		if ((aidc->keyrefDepth == -1) ||

	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, -1
	je	SHORT $LN65@xmlSchemaI
	cmp	DWORD PTR [ebx+96], eax
	jge	SHORT $LN15@xmlSchemaI
$LN65@xmlSchemaI:

; 23270: 		    (vctxt->depth < aidc->keyrefDepth))
; 23271: 		    aidc->keyrefDepth = vctxt->depth;

	mov	eax, DWORD PTR [ebx+96]
	mov	DWORD PTR [ecx+8], eax
$LN15@xmlSchemaI:

; 23272: 	    }
; 23273: 	}
; 23274: 	/*
; 23275: 	* Lookup the augmented IDC item for the IDC definition.
; 23276: 	*/
; 23277: 	aidc = vctxt->aidcs;

	mov	esi, DWORD PTR [ebx+112]

; 23278: 	while (aidc != NULL) {

	test	esi, esi
	je	SHORT $LN39@xmlSchemaI
$LL7@xmlSchemaI:

; 23279: 	    if (aidc->def == idc)

	cmp	DWORD PTR [esi+4], edi
	je	SHORT $LN36@xmlSchemaI

; 23280: 		break;
; 23281: 	    aidc = aidc->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL7@xmlSchemaI

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	esi
	push	esi
	push	OFFSET ??_C@_0DL@HKBGOKJP@Could?5not?5find?5an?5augmented?5IDC@

; 23282: 	}
; 23283: 	if (aidc == NULL) {
; 23284: 	    VERROR_INT("xmlSchemaIDCRegisterMatchers",
; 23285: 		"Could not find an augmented IDC item for an IDC definition");
; 23286: 	    return (-1);

	jmp	SHORT $LN84@xmlSchemaI
$LN36@xmlSchemaI:

; 23287: 	}
; 23288: 	/*
; 23289: 	* Create an IDC matcher for every IDC definition.
; 23290: 	*/
; 23291: 	if (vctxt->idcMatcherCache != NULL) {

	mov	ecx, DWORD PTR [ebx+124]
	test	ecx, ecx
	je	SHORT $LN19@xmlSchemaI

; 23292: 	    /*
; 23293: 	    * Reuse a cached matcher.
; 23294: 	    */
; 23295: 	    matcher = vctxt->idcMatcherCache;
; 23296: 	    vctxt->idcMatcherCache = matcher->nextCached;

	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [ebx+124], eax

; 23297: 	    matcher->nextCached = NULL;

	mov	DWORD PTR [ecx+12], 0

; 23298: 	} else {

	jmp	SHORT $LN20@xmlSchemaI
$LN19@xmlSchemaI:

; 23299: 	    matcher = (xmlSchemaIDCMatcherPtr)

	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4

; 23300: 		xmlMalloc(sizeof(xmlSchemaIDCMatcher));
; 23301: 	    if (matcher == NULL) {

	test	ecx, ecx
	je	SHORT $LN40@xmlSchemaI

; 23303: 		    "allocating an IDC matcher", NULL);
; 23304: 		return (-1);
; 23305: 	    }
; 23306: 	    memset(matcher, 0, sizeof(xmlSchemaIDCMatcher));

	xorps	xmm0, xmm0
	movups	XMMWORD PTR [ecx], xmm0
	movups	XMMWORD PTR [ecx+16], xmm0
	mov	DWORD PTR [ecx+32], 0
$LN20@xmlSchemaI:

; 23307: 	}
; 23308: 	if (last == NULL)

	mov	eax, DWORD PTR _last$1$[ebp]
	test	eax, eax
	jne	SHORT $LN22@xmlSchemaI

; 23309: 	    vctxt->inode->idcMatchers = matcher;

	mov	eax, DWORD PTR [ebx+108]
	mov	DWORD PTR [eax+56], ecx
	jmp	SHORT $LN23@xmlSchemaI
$LN22@xmlSchemaI:

; 23310: 	else
; 23311: 	    last->next = matcher;

	mov	DWORD PTR [eax+8], ecx
$LN23@xmlSchemaI:

; 23312: 	last = matcher;
; 23313: 
; 23314: 	matcher->type = IDC_MATCHER;

	mov	DWORD PTR [ecx], 0

; 23315: 	matcher->depth = vctxt->depth;

	mov	eax, DWORD PTR [ebx+96]
	mov	DWORD PTR [ecx+4], eax

; 23316: 	matcher->aidc = aidc;

	mov	DWORD PTR [ecx+16], esi

; 23317: 	matcher->idcType = aidc->def->type;

	mov	eax, DWORD PTR [esi+4]

; 23318: #ifdef DEBUG_IDC
; 23319: 	xmlGenericError(xmlGenericErrorContext, "IDC:   register matcher\n");
; 23320: #endif
; 23321: 	/*
; 23322: 	* Init the automaton state object.
; 23323: 	*/
; 23324: 	if (xmlSchemaIDCAddStateObject(vctxt, matcher,
; 23325: 	    idc->selector, XPATH_STATE_OBJ_TYPE_IDC_SELECTOR) == -1)

	push	1
	mov	DWORD PTR _last$1$[ebp], ecx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+20], eax
	push	DWORD PTR [edi+24]
	push	ecx
	push	ebx
	call	_xmlSchemaIDCAddStateObject
	add	esp, 16					; 00000010H
	cmp	eax, -1
	je	$LN85@xmlSchemaI

; 23326: 	    return (-1);
; 23327: 
; 23328: 	idc = idc->next;

	mov	edi, DWORD PTR [edi+8]

; 23329:     } while (idc != NULL);

	test	edi, edi
	jne	$LL4@xmlSchemaI
$LN38@xmlSchemaI:
	pop	edi

; 23330:     return (0);
; 23331: }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@xmlSchemaI:

; 23302: 		xmlSchemaVErrMemory(vctxt,

	push	0
	push	OFFSET ??_C@_0BK@INNNDFEE@allocating?5an?5IDC?5matcher@
	push	ebx
	call	_xmlSchemaVErrMemory
	add	esp, 12					; 0000000cH

; 23330:     return (0);
; 23331: }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaIDCRegisterMatchers ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaXPathProcessHistory
_TEXT	SEGMENT
_type$1$ = -28						; size = 4
_bkeySeq$1$ = -24					; size = 4
tv1903 = -24						; size = 4
tv1881 = -24						; size = 4
_str$1 = -24						; size = 4
_lname$2$ = -20						; size = 4
_i$2$ = -20						; size = 4
_simpleType$1$ = -20					; size = 4
_str$2 = -20						; size = 4
_nsname$1$ = -16					; size = 4
_nbKeys$1$ = -16					; size = 4
_pos$1$ = -16						; size = 4
$T3 = -12						; size = 4
_idx$1$ = -12						; size = 4
_strB$4 = -12						; size = 4
_key$1$ = -8						; size = 4
_keySeq$1$ = -4						; size = 4
_idc$1$ = 8						; size = 4
_keySeq$1$ = 8						; size = 4
_i$1$ = 8						; size = 4
_str$5 = 8						; size = 4
_str$6 = 8						; size = 4
_vctxt$ = 8						; size = 4
_depth$ = 12						; size = 4
_xmlSchemaXPathProcessHistory PROC			; COMDAT

; 22711: {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _vctxt$[ebp]
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR [edi+108]
	xor	esi, esi
	mov	ebx, DWORD PTR [edi+116]
	mov	DWORD PTR _key$1$[ebp], esi
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR _type$1$[ebp], eax
	test	ebx, ebx
	je	$LN3@xmlSchemaX
	npad	1
$LL2@xmlSchemaX:

; 22735: 	res = xmlStreamPop((xmlStreamCtxtPtr) sto->xpathCtxt);

	push	DWORD PTR [ebx+32]
	call	_xmlStreamPop
	add	esp, 4

; 22736: 	if (res == -1) {

	cmp	eax, -1
	je	$LN173@xmlSchemaX

; 22737: 	    VERROR_INT("xmlSchemaXPathProcessHistory",
; 22738: 		"calling xmlStreamPop()");
; 22739: 	    return (-1);
; 22740: 	}
; 22741: #ifdef DEBUG_IDC
; 22742: 	xmlGenericError(xmlGenericErrorContext, "IDC:   stream pop '%s'\n",
; 22743: 	    sto->sel->xpath);
; 22744: #endif
; 22745: 	if (sto->nbHistory == 0)

	mov	ecx, DWORD PTR [ebx+16]
	test	ecx, ecx
	je	$LN217@xmlSchemaX

; 22746: 	    goto deregister_check;
; 22747: 
; 22748: 	matchDepth = sto->history[sto->nbHistory -1];
; 22749: 
; 22750: 	/*
; 22751: 	* Only matches at the current depth are of interest.
; 22752: 	*/
; 22753: 	if (matchDepth != depth) {

	mov	eax, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR _depth$[ebp]
	cmp	DWORD PTR [eax+ecx*4-4], edx
	jne	$LN218@xmlSchemaX

; 22754: 	    sto = sto->next;
; 22755: 	    continue;
; 22756: 	}
; 22757: 	if (sto->type == XPATH_STATE_OBJ_TYPE_IDC_FIELD) {

	mov	eax, DWORD PTR [ebx]
	cmp	eax, 2
	jne	$LN20@xmlSchemaX

; 22758: 	    /*
; 22759: 	    * NOTE: According to
; 22760: 	    *   http://www.w3.org/Bugs/Public/show_bug.cgi?id=2198
; 22761: 	    *   ... the simple-content of complex types is also allowed.
; 22762: 	    */
; 22763: 
; 22764: 	    if (WXS_IS_COMPLEX(type)) {

	mov	ecx, DWORD PTR _type$1$[ebp]
	cmp	DWORD PTR [ecx], 5
	je	SHORT $LN24@xmlSchemaX
	cmp	DWORD PTR [ecx+88], 45			; 0000002dH
	je	SHORT $LN24@xmlSchemaX

; 22775: 		    }
; 22776: 		} else
; 22777: 		    simpleType = NULL;
; 22778: 	    } else
; 22779: 		simpleType = type;

	mov	DWORD PTR _simpleType$1$[ebp], ecx
	jmp	SHORT $LN29@xmlSchemaX
$LN24@xmlSchemaX:

; 22765: 		if (WXS_HAS_SIMPLE_CONTENT(type)) {

	mov	eax, DWORD PTR [ecx+52]
	cmp	eax, 4
	je	SHORT $LN27@xmlSchemaX
	cmp	eax, 6
	je	SHORT $LN27@xmlSchemaX

; 22780: 	    if (simpleType == NULL) {
; 22781: 		xmlChar *str = NULL;
; 22782: 
; 22783: 		/*
; 22784: 		* Not qualified if the field resolves to a node of non
; 22785: 		* simple type.
; 22786: 		*/
; 22787: 		xmlSchemaCustomErr(ACTXT_CAST vctxt,

	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR _str$6[ebp], 0
	mov	eax, DWORD PTR [eax+16]

; 1451 :     return(xmlSchemaGetComponentDesignation(buf, idc));

	push	DWORD PTR [eax+4]
	lea	eax, DWORD PTR _str$6[ebp]
	push	eax
	call	_xmlSchemaGetComponentDesignation

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR [ebx+28]
	push	DWORD PTR [eax+12]
	mov	eax, DWORD PTR [ebx+24]
	push	OFFSET ??_C@_0EL@FLEKOJFE@The?5XPath?5?8?$CFs?8?5of?5a?5field?5of?5?$CFs@
	mov	eax, DWORD PTR [eax+16]
	push	DWORD PTR [eax+4]
	push	0
	push	1877					; 00000755H
	push	edi
	call	_xmlSchemaCustomErr4
	add	esp, 44					; 0000002cH
$LN222@xmlSchemaX:

; 23166: 	    }
; 23167: 	} /* if selector */
; 23168: 
; 23169: 	sto->nbHistory--;
; 23170: 
; 23171: deregister_check:
; 23172: 	/*
; 23173: 	* Deregister state objects if they reach the depth of creation.
; 23174: 	*/
; 23175: 	if ((sto->nbHistory == 0) && (sto->depth == depth)) {

	mov	eax, DWORD PTR _str$6[ebp]
	test	eax, eax
	je	$LN75@xmlSchemaX
	push	eax
	call	DWORD PTR _xmlFree
	jmp	$LN219@xmlSchemaX
$LN27@xmlSchemaX:

; 22766: 		    /*
; 22767: 		    * Sanity check for complex types with simple content.
; 22768: 		    */
; 22769: 		    simpleType = type->contentTypeDef;

	mov	eax, DWORD PTR [ecx+104]
	mov	DWORD PTR _simpleType$1$[ebp], eax

; 22770: 		    if (simpleType == NULL) {

	test	eax, eax
	je	$LN174@xmlSchemaX
$LN29@xmlSchemaX:

; 22788: 		    XML_SCHEMAV_CVC_IDC, NULL,
; 22789: 		    WXS_BASIC_CAST sto->matcher->aidc->def,
; 22790: 		    "The XPath '%s' of a field of %s does evaluate to a node of "
; 22791: 		    "non-simple type",
; 22792: 		    sto->sel->xpath,
; 22793: 		    xmlSchemaGetIDCDesignation(&str, sto->matcher->aidc->def));
; 22794: 		FREE_AND_NULL(str);
; 22795: 		sto->nbHistory--;
; 22796: 		goto deregister_check;
; 22797: 	    }
; 22798: 
; 22799: 	    if ((key == NULL) && (vctxt->inode->val == NULL)) {

	test	esi, esi
	jne	SHORT $LN209@xmlSchemaX
	mov	eax, DWORD PTR [edi+108]
	cmp	DWORD PTR [eax+24], esi
	jne	SHORT $LN209@xmlSchemaX

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	mov	eax, DWORD PTR [ebx+24]
	push	esi
	push	esi
	push	esi
	mov	eax, DWORD PTR [eax+16]
	push	esi
	push	OFFSET ??_C@_0GD@IKFFNPGA@Warning?3?5No?5precomputed?5value?5a@
	push	DWORD PTR [eax+4]
	push	esi
	push	1877					; 00000755H
	push	edi
	call	_xmlSchemaCustomErr4
	add	esp, 36					; 00000024H

; 22800: 		/*
; 22801: 		* Failed to provide the normalized value; maybe
; 22802: 		* the value was invalid.
; 22803: 		*/
; 22804: 		VERROR(XML_SCHEMAV_CVC_IDC,
; 22805: 		    WXS_BASIC_CAST sto->matcher->aidc->def,
; 22806: 		    "Warning: No precomputed value available, the value "
; 22807: 		    "was either invalid or something strange happend");
; 22808: 		sto->nbHistory--;
; 22809: 		goto deregister_check;

	jmp	$LN75@xmlSchemaX
$LN209@xmlSchemaX:

; 22810: 	    } else {
; 22811: 		xmlSchemaIDCMatcherPtr matcher = sto->matcher;

	mov	esi, DWORD PTR [ebx+24]

; 22812: 		xmlSchemaPSVIIDCKeyPtr *keySeq;
; 22813: 		int pos, idx;
; 22814: 
; 22815: 		/*
; 22816: 		* The key will be anchored on the matcher's list of
; 22817: 		* key-sequences. The position in this list is determined
; 22818: 		* by the target node's depth relative to the matcher's
; 22819: 		* depth of creation (i.e. the depth of the scope element).
; 22820: 		*
; 22821: 		* Element        Depth    Pos   List-entries
; 22822: 		* <scope>          0              NULL
; 22823: 		*   <bar>          1              NULL
; 22824: 		*     <target/>    2       2      target
; 22825: 		*   <bar>
; 22826:                 * </scope>
; 22827: 		*
; 22828: 		* The size of the list is only dependant on the depth of
; 22829: 		* the tree.
; 22830: 		* An entry will be NULLed in selector_leave, i.e. when
; 22831: 		* we hit the target's
; 22832: 		*/
; 22833: 		pos = sto->depth - matcher->depth;
; 22834: 		idx = sto->sel->index;

	mov	eax, DWORD PTR [ebx+28]
	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, DWORD PTR [esi+4]

; 22835: 
; 22836: 		/*
; 22837: 		* Create/grow the array of key-sequences.
; 22838: 		*/
; 22839: 		if (matcher->keySeqs == NULL) {

	mov	edx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _pos$1$[ebp], ecx
	mov	DWORD PTR _idx$1$[ebp], eax
	test	edx, edx
	jne	SHORT $LN33@xmlSchemaX

; 22840: 		    if (pos > 9)
; 22841: 			matcher->sizeKeySeqs = pos * 2;

	lea	eax, DWORD PTR [ecx+ecx]
	cmp	ecx, 9
	jg	SHORT $LN36@xmlSchemaX

; 22842: 		    else
; 22843: 			matcher->sizeKeySeqs = 10;

	mov	eax, 10					; 0000000aH
$LN36@xmlSchemaX:

; 22844: 		    matcher->keySeqs = (xmlSchemaPSVIIDCKeyPtr **)

	mov	DWORD PTR [esi+28], eax
	shl	eax, 2
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [esi+24], ecx

; 22845: 			xmlMalloc(matcher->sizeKeySeqs *
; 22846: 			sizeof(xmlSchemaPSVIIDCKeyPtr *));
; 22847: 		    if (matcher->keySeqs == NULL) {

	test	ecx, ecx
	je	$LN175@xmlSchemaX

; 22848: 			xmlSchemaVErrMemory(NULL,
; 22849: 			    "allocating an array of key-sequences",
; 22850: 			    NULL);
; 22851: 			return(-1);
; 22852: 		    }
; 22853: 		    memset(matcher->keySeqs, 0,

	mov	eax, DWORD PTR [esi+28]
	shl	eax, 2
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN214@xmlSchemaX
$LN33@xmlSchemaX:

; 22854: 			matcher->sizeKeySeqs *
; 22855: 			sizeof(xmlSchemaPSVIIDCKeyPtr *));
; 22856: 		} else if (pos >= matcher->sizeKeySeqs) {

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	ecx, eax
	jl	SHORT $LN5@xmlSchemaX

; 22857: 		    int i = matcher->sizeKeySeqs;
; 22858: 
; 22859: 		    matcher->sizeKeySeqs *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+28], eax

; 22860: 		    matcher->keySeqs = (xmlSchemaPSVIIDCKeyPtr **)

	shl	eax, 2
	push	eax
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	DWORD PTR [esi+24], eax

; 22861: 			xmlRealloc(matcher->keySeqs,
; 22862: 			matcher->sizeKeySeqs *
; 22863: 			sizeof(xmlSchemaPSVIIDCKeyPtr *));
; 22864: 		    if (matcher->keySeqs == NULL) {

	test	eax, eax
	je	$LN176@xmlSchemaX

; 22865: 			xmlSchemaVErrMemory(NULL,
; 22866: 			    "reallocating an array of key-sequences",
; 22867: 			    NULL);
; 22868: 			return (-1);
; 22869: 		    }
; 22870: 		    /*
; 22871: 		    * The array needs to be NULLed.
; 22872: 		    * TODO: Use memset?
; 22873: 		    */
; 22874: 		    for (; i < matcher->sizeKeySeqs; i++)

	mov	ecx, DWORD PTR _i$1$[ebp]
	cmp	ecx, DWORD PTR [esi+28]
	jge	SHORT $LN214@xmlSchemaX
	npad	3
$LL6@xmlSchemaX:

; 22875: 			matcher->keySeqs[i] = NULL;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+ecx*4], 0
	inc	ecx
	cmp	ecx, DWORD PTR [esi+28]
	jl	SHORT $LL6@xmlSchemaX
$LN214@xmlSchemaX:

; 22876: 		}
; 22877: 
; 22878: 		/*
; 22879: 		* Get/create the key-sequence.
; 22880: 		*/
; 22881: 		keySeq = matcher->keySeqs[pos];

	mov	ecx, DWORD PTR _pos$1$[ebp]
$LN5@xmlSchemaX:
	mov	eax, DWORD PTR [esi+24]
	shl	ecx, 2
	mov	DWORD PTR tv1881[ebp], ecx
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _keySeq$1$[ebp], eax

; 22882: 		if (keySeq == NULL) {

	test	eax, eax
	jne	$LN40@xmlSchemaX
$create_sequence$229:

; 22906: 		} else
; 22907: 		    goto create_key;
; 22908: 
; 22909: create_sequence:
; 22910: 		/*
; 22911: 		* Create a key-sequence.
; 22912: 		*/
; 22913: 		keySeq = (xmlSchemaPSVIIDCKeyPtr *) xmlMalloc(

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+32]
	shl	eax, 2
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _keySeq$1$[ebp], ecx

; 22914: 		    matcher->aidc->def->nbFields *
; 22915: 		    sizeof(xmlSchemaPSVIIDCKeyPtr));
; 22916: 		if (keySeq == NULL) {

	test	ecx, ecx
	je	$LN177@xmlSchemaX

; 22917: 		    xmlSchemaVErrMemory(NULL,
; 22918: 			"allocating an IDC key-sequence", NULL);
; 22919: 		    return(-1);
; 22920: 		}
; 22921: 		memset(keySeq, 0, matcher->aidc->def->nbFields *

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+32]
	shl	eax, 2
	push	eax
	push	0
	push	ecx
	call	_memset

; 22922: 		    sizeof(xmlSchemaPSVIIDCKeyPtr));
; 22923: 		matcher->keySeqs[pos] = keySeq;

	mov	eax, DWORD PTR [esi+24]
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR tv1881[ebp]
	mov	ecx, DWORD PTR _keySeq$1$[ebp]
	mov	DWORD PTR [edx+eax], ecx
$create_key$230:

; 22924: create_key:
; 22925: 		/*
; 22926: 		* Create a key once per node only.
; 22927: 		*/
; 22928: 		if (key == NULL) {

	cmp	DWORD PTR _key$1$[ebp], 0
	jne	$LN215@xmlSchemaX

; 22929: 		    key = (xmlSchemaPSVIIDCKeyPtr) xmlMalloc(

	push	8
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _key$1$[ebp], eax

; 22930: 			sizeof(xmlSchemaPSVIIDCKey));
; 22931: 		    if (key == NULL) {

	test	eax, eax
	je	$LN178@xmlSchemaX

; 22936: 			return(-1);
; 22937: 		    }
; 22938: 		    /*
; 22939: 		    * Consume the compiled value.
; 22940: 		    */
; 22941: 		    key->type = simpleType;

	mov	ecx, DWORD PTR _simpleType$1$[ebp]
	mov	DWORD PTR [eax], ecx

; 22942: 		    key->val = vctxt->inode->val;

	mov	ecx, DWORD PTR [edi+108]
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+4], ecx

; 22943: 		    vctxt->inode->val = NULL;

	mov	ecx, DWORD PTR [edi+108]
	mov	DWORD PTR [ecx+24], 0

; 22152:     if (vctxt->idcKeys == NULL) {

	mov	ecx, DWORD PTR [edi+140]
	test	ecx, ecx
	jne	SHORT $LN105@xmlSchemaX

; 22153: 	vctxt->idcKeys = (xmlSchemaPSVIIDCKeyPtr *)

	push	160					; 000000a0H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [edi+140], ecx

; 22154: 	    xmlMalloc(40 * sizeof(xmlSchemaPSVIIDCKeyPtr));
; 22155: 	if (vctxt->idcKeys == NULL) {

	test	ecx, ecx
	je	$LN204@xmlSchemaX

; 22159: 	}
; 22160: 	vctxt->sizeIdcKeys = 40;

	mov	DWORD PTR [edi+148], 40			; 00000028H
	jmp	SHORT $LN109@xmlSchemaX
$LN40@xmlSchemaX:

; 22883: 		    goto create_sequence;
; 22884: 		} else if (keySeq[idx] != NULL) {

	mov	ecx, DWORD PTR _idx$1$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $create_key$230

; 22885: 		    xmlChar *str = NULL;
; 22886: 		    /*
; 22887: 		    * cvc-identity-constraint:
; 22888: 		    * 3 For each node in the `target node set` all
; 22889: 		    * of the {fields}, with that node as the context
; 22890: 		    * node, evaluate to either an empty node-set or
; 22891: 		    * a node-set with exactly one member, which must
; 22892: 		    * have a simple type.
; 22893: 		    *
; 22894: 		    * The key was already set; report an error.
; 22895: 		    */
; 22896: 		    xmlSchemaCustomErr(ACTXT_CAST vctxt,

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR _str$5[ebp], 0

; 1451 :     return(xmlSchemaGetComponentDesignation(buf, idc));

	push	DWORD PTR [eax+4]
	lea	eax, DWORD PTR _str$5[ebp]
	push	eax
	call	_xmlSchemaGetComponentDesignation

; 22885: 		    xmlChar *str = NULL;
; 22886: 		    /*
; 22887: 		    * cvc-identity-constraint:
; 22888: 		    * 3 For each node in the `target node set` all
; 22889: 		    * of the {fields}, with that node as the context
; 22890: 		    * node, evaluate to either an empty node-set or
; 22891: 		    * a node-set with exactly one member, which must
; 22892: 		    * have a simple type.
; 22893: 		    *
; 22894: 		    * The key was already set; report an error.
; 22895: 		    */
; 22896: 		    xmlSchemaCustomErr(ACTXT_CAST vctxt,

	push	eax
	mov	eax, DWORD PTR [ebx+28]
	push	DWORD PTR [eax+12]
	mov	eax, DWORD PTR [esi+16]
	push	OFFSET ??_C@_0FC@LNIGGAMO@The?5XPath?5?8?$CFs?8?5of?5a?5field?5of?5?$CFs@
	push	DWORD PTR [eax+4]
	push	0
	push	1877					; 00000755H
	push	edi
	call	_xmlSchemaCustomErr
	add	esp, 36					; 00000024H

; 22897: 			XML_SCHEMAV_CVC_IDC, NULL,
; 22898: 			WXS_BASIC_CAST matcher->aidc->def,
; 22899: 			"The XPath '%s' of a field of %s evaluates to a "
; 22900: 			"node-set with more than one member",
; 22901: 			sto->sel->xpath,
; 22902: 			xmlSchemaGetIDCDesignation(&str, matcher->aidc->def));
; 22903: 		    FREE_AND_NULL(str);
; 22904: 		    sto->nbHistory--;
; 22905: 		    goto deregister_check;

	jmp	$LN222@xmlSchemaX
$LN105@xmlSchemaX:

; 22161:     } else if (vctxt->sizeIdcKeys <= vctxt->nbIdcKeys) {

	mov	eax, DWORD PTR [edi+148]
	cmp	eax, DWORD PTR [edi+144]
	jg	SHORT $LN109@xmlSchemaX

; 22162: 	vctxt->sizeIdcKeys *= 2;

	add	eax, eax
	mov	DWORD PTR [edi+148], eax

; 22163: 	vctxt->idcKeys = (xmlSchemaPSVIIDCKeyPtr *)

	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR [edi+140], ecx

; 22164: 	    xmlRealloc(vctxt->idcKeys, vctxt->sizeIdcKeys *
; 22165: 	    sizeof(xmlSchemaPSVIIDCKeyPtr));
; 22166: 	if (vctxt->idcKeys == NULL) {

	test	ecx, ecx
	je	$LN206@xmlSchemaX
$LN109@xmlSchemaX:

; 22167: 	    xmlSchemaVErrMemory(vctxt,
; 22168: 		"re-allocating the IDC key storage list", NULL);
; 22169: 	    return (-1);
; 22170: 	}
; 22171:     }
; 22172:     vctxt->idcKeys[vctxt->nbIdcKeys++] = key;

	mov	eax, DWORD PTR [edi+144]
	mov	esi, DWORD PTR _key$1$[ebp]
	mov	DWORD PTR [ecx+eax*4], esi

; 22949: 			return (-1);
; 22950: 		    }
; 22951: 		}
; 22952: 		keySeq[idx] = key;

	mov	eax, DWORD PTR _keySeq$1$[ebp]
	mov	ecx, DWORD PTR _idx$1$[ebp]

; 22172:     vctxt->idcKeys[vctxt->nbIdcKeys++] = key;

	inc	DWORD PTR [edi+144]

; 22949: 			return (-1);
; 22950: 		    }
; 22951: 		}
; 22952: 		keySeq[idx] = key;

	mov	DWORD PTR [eax+ecx*4], esi

; 22953: 	    }

	jmp	$LN75@xmlSchemaX
$LN215@xmlSchemaX:

; 22949: 			return (-1);
; 22950: 		    }
; 22951: 		}
; 22952: 		keySeq[idx] = key;

	mov	eax, DWORD PTR _keySeq$1$[ebp]
	mov	ecx, DWORD PTR _idx$1$[ebp]
	mov	esi, DWORD PTR _key$1$[ebp]
	mov	DWORD PTR [eax+ecx*4], esi

; 22953: 	    }

	jmp	$LN75@xmlSchemaX
$LN20@xmlSchemaX:

; 22954: 	} else if (sto->type == XPATH_STATE_OBJ_TYPE_IDC_SELECTOR) {

	cmp	eax, 1
	jne	$LN75@xmlSchemaX

; 22955: 
; 22956: 	    xmlSchemaPSVIIDCKeyPtr **keySeq = NULL;
; 22957: 	    /* xmlSchemaPSVIIDCBindingPtr bind; */
; 22958: 	    xmlSchemaPSVIIDCNodePtr ntItem;
; 22959: 	    xmlSchemaIDCMatcherPtr matcher;
; 22960: 	    xmlSchemaIDCPtr idc;
; 22961: 	    xmlSchemaItemListPtr targets;
; 22962: 	    int pos, i, j, nbKeys;
; 22963: 	    /*
; 22964: 	    * Here we have the following scenario:
; 22965: 	    * An IDC 'selector' state object resolved to a target node,
; 22966: 	    * during the time this target node was in the
; 22967: 	    * ancestor-or-self axis, the 'field' state object(s) looked
; 22968: 	    * out for matching nodes to create a key-sequence for this
; 22969: 	    * target node. Now we are back to this target node and need
; 22970: 	    * to put the key-sequence, together with the target node
; 22971: 	    * itself, into the node-table of the corresponding IDC
; 22972: 	    * binding.
; 22973: 	    */
; 22974: 	    matcher = sto->matcher;

	mov	esi, DWORD PTR [ebx+24]
	mov	DWORD PTR _keySeq$1$[ebp], 0

; 22975: 	    idc = matcher->aidc->def;

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _idc$1$[ebp], ecx

; 22976: 	    nbKeys = idc->nbFields;

	mov	edx, DWORD PTR [ecx+32]

; 22978: 	    /*
; 22979: 	    * Check if the matcher has any key-sequences at all, plus
; 22980: 	    * if it has a key-sequence for the current target node.
; 22981: 	    */
; 22982: 	    if ((matcher->keySeqs == NULL) ||

	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR _nbKeys$1$[ebp], edx
	test	ecx, ecx
	je	$LN51@xmlSchemaX

; 22977: 	    pos = depth - matcher->depth;

	mov	eax, DWORD PTR _depth$[ebp]
	sub	eax, DWORD PTR [esi+4]

; 22978: 	    /*
; 22979: 	    * Check if the matcher has any key-sequences at all, plus
; 22980: 	    * if it has a key-sequence for the current target node.
; 22981: 	    */
; 22982: 	    if ((matcher->keySeqs == NULL) ||

	cmp	DWORD PTR [esi+28], eax
	jle	$LN51@xmlSchemaX

; 22985: 		    goto selector_key_error;
; 22986: 		else
; 22987: 		    goto selector_leave;
; 22988: 	    }
; 22989: 
; 22990: 	    keySeq = &(matcher->keySeqs[pos]);

	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _keySeq$1$[ebp], eax

; 22991: 	    if (*keySeq == NULL) {

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LN56@xmlSchemaX
$LN168@xmlSchemaX:

; 23158: 	    }
; 23159: selector_leave:
; 23160: 	    /*
; 23161: 	    * Free the key-sequence if not added to the IDC table.
; 23162: 	    */
; 23163: 	    if ((keySeq != NULL) && (*keySeq != NULL)) {

	mov	ecx, DWORD PTR _idc$1$[ebp]
	cmp	DWORD PTR [ecx], 23			; 00000017H
	je	$selector_key_error$231
	jmp	$selector_leave$232
$LN56@xmlSchemaX:

; 22992: 		if (idc->type == XML_SCHEMA_TYPE_IDC_KEY)
; 22993: 		    goto selector_key_error;
; 22994: 		else
; 22995: 		    goto selector_leave;
; 22996: 	    }
; 22997: 
; 22998: 	    for (i = 0; i < nbKeys; i++) {

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN8@xmlSchemaX
$LL9@xmlSchemaX:

; 22999: 		if ((*keySeq)[i] == NULL) {

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN168@xmlSchemaX

; 22992: 		if (idc->type == XML_SCHEMA_TYPE_IDC_KEY)
; 22993: 		    goto selector_key_error;
; 22994: 		else
; 22995: 		    goto selector_leave;
; 22996: 	    }
; 22997: 
; 22998: 	    for (i = 0; i < nbKeys; i++) {

	inc	ecx
	add	eax, 4
	cmp	ecx, edx
	jl	SHORT $LL9@xmlSchemaX
$LN8@xmlSchemaX:

; 22261:     if (matcher->targets == NULL)

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR $T3[ebp], eax
	test	eax, eax
	jne	SHORT $LN118@xmlSchemaX

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax

; 3342 :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN121@xmlSchemaX

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@BAFOADOL@allocating?5an?5item?5list?5structu@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3345 : 	return (NULL);

	xor	eax, eax
	mov	DWORD PTR $T3[ebp], eax
	jmp	SHORT $LN120@xmlSchemaX
$LN121@xmlSchemaX:
	xorps	xmm0, xmm0

; 3346 :     }
; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));

	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], 0
$LN120@xmlSchemaX:
	mov	edx, DWORD PTR _nbKeys$1$[ebp]

; 22262: 	matcher->targets = xmlSchemaItemListCreate();

	mov	DWORD PTR [esi+32], eax
$LN118@xmlSchemaX:

; 23000: 		    /*
; 23001: 		    * Not qualified, if not all fields did resolve.
; 23002: 		    */
; 23003: 		    if (idc->type == XML_SCHEMA_TYPE_IDC_KEY) {
; 23004: 			/*
; 23005: 			* All fields of a "key" IDC must resolve.
; 23006: 			*/
; 23007: 			goto selector_key_error;
; 23008: 		    }
; 23009: 		    goto selector_leave;
; 23010: 		}
; 23011: 	    }
; 23012: 	    /*
; 23013: 	    * All fields did resolve.
; 23014: 	    */
; 23015: 
; 23016: 	    /*
; 23017: 	    * 4.1 If the {identity-constraint category} is unique(/key),
; 23018: 	    * then no two members of the `qualified node set` have
; 23019: 	    * `key-sequences` whose members are pairwise equal, as
; 23020: 	    * defined by Equal in [XML Schemas: Datatypes].
; 23021: 	    *
; 23022: 	    * Get the IDC binding from the matcher and check for
; 23023: 	    * duplicate key-sequences.
; 23024: 	    */
; 23025: #if 0
; 23026: 	    bind = xmlSchemaIDCAcquireBinding(vctxt, matcher);
; 23027: #endif
; 23028: 	    targets = xmlSchemaIDCAcquireTargetList(vctxt, matcher);
; 23029: 	    if ((idc->type != XML_SCHEMA_TYPE_IDC_KEYREF) &&

	mov	ecx, DWORD PTR _idc$1$[ebp]
	cmp	DWORD PTR [ecx], 24			; 00000018H
	je	$LN64@xmlSchemaX
	cmp	DWORD PTR [eax+4], 0
	je	$LN64@xmlSchemaX

; 23030: 		(targets->nbItems != 0)) {
; 23031: 		xmlSchemaPSVIIDCKeyPtr ckey, bkey, *bkeySeq;
; 23032: 
; 23033: 		i = 0;

	xor	esi, esi

; 23034: 		res = 0;

	xor	ecx, ecx
	mov	DWORD PTR _i$2$[ebp], esi
	npad	5
$LL12@xmlSchemaX:

; 23035: 		/*
; 23036: 		* Compare the key-sequences, key by key.
; 23037: 		*/
; 23038: 		do {
; 23039: 		    bkeySeq =

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+esi*4]

; 23040: 			((xmlSchemaPSVIIDCNodePtr) targets->items[i])->keys;
; 23041: 		    for (j = 0; j < nbKeys; j++) {

	xor	esi, esi
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _bkeySeq$1$[ebp], eax
	test	edx, edx
	jle	SHORT $LN170@xmlSchemaX
$LL15@xmlSchemaX:

; 23042: 			ckey = (*keySeq)[j];

	mov	eax, DWORD PTR _keySeq$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+esi*4]

; 23043: 			bkey = bkeySeq[j];

	mov	eax, DWORD PTR _bkeySeq$1$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]

; 23044: 			res = xmlSchemaAreValuesEqual(ckey->val, bkey->val);

	push	DWORD PTR [eax+4]
	push	DWORD PTR [ecx+4]
	call	_xmlSchemaAreValuesEqual
	mov	ecx, eax
	add	esp, 8

; 23045: 			if (res == -1) {

	cmp	ecx, -1
	je	$LN227@xmlSchemaX

; 23046: 			    return (-1);
; 23047: 			} else if (res == 0) {

	mov	edx, DWORD PTR _nbKeys$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN170@xmlSchemaX

; 23040: 			((xmlSchemaPSVIIDCNodePtr) targets->items[i])->keys;
; 23041: 		    for (j = 0; j < nbKeys; j++) {

	inc	esi
	cmp	esi, edx
	jl	SHORT $LL15@xmlSchemaX
$LN170@xmlSchemaX:

; 23048: 			    /*
; 23049: 			    * One of the keys differs, so the key-sequence
; 23050: 			    * won't be equal; get out.
; 23051: 			    */
; 23052: 			    break;
; 23053: 			}
; 23054: 		    }
; 23055: 		    if (res == 1) {

	mov	esi, DWORD PTR _i$2$[ebp]
	mov	eax, DWORD PTR $T3[ebp]
	cmp	ecx, 1
	je	SHORT $LN11@xmlSchemaX

; 23056: 			/*
; 23057: 			* Duplicate key-sequence found.
; 23058: 			*/
; 23059: 			break;
; 23060: 		    }
; 23061: 		    i++;

	inc	esi
	mov	DWORD PTR _i$2$[ebp], esi

; 23062: 		} while (i < targets->nbItems);

	cmp	esi, DWORD PTR [eax+4]
	jl	SHORT $LL12@xmlSchemaX
$LN11@xmlSchemaX:

; 23063: 		if (i != targets->nbItems) {

	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN64@xmlSchemaX

; 1451 :     return(xmlSchemaGetComponentDesignation(buf, idc));

	push	DWORD PTR _idc$1$[ebp]
	lea	eax, DWORD PTR _strB$4[ebp]

; 23064: 		    xmlChar *str = NULL, *strB = NULL;

	mov	DWORD PTR _str$2[ebp], 0

; 1451 :     return(xmlSchemaGetComponentDesignation(buf, idc));

	push	eax

; 23064: 		    xmlChar *str = NULL, *strB = NULL;

	mov	DWORD PTR _strB$4[ebp], 0

; 1451 :     return(xmlSchemaGetComponentDesignation(buf, idc));

	call	_xmlSchemaGetComponentDesignation

; 23065: 		    /*
; 23066: 		    * TODO: Try to report the key-sequence.
; 23067: 		    */
; 23068: 		    xmlSchemaCustomErr(ACTXT_CAST vctxt,

	push	DWORD PTR _nbKeys$1$[ebp]

; 1451 :     return(xmlSchemaGetComponentDesignation(buf, idc));

	mov	esi, eax

; 23065: 		    /*
; 23066: 		    * TODO: Try to report the key-sequence.
; 23067: 		    */
; 23068: 		    xmlSchemaCustomErr(ACTXT_CAST vctxt,

	mov	eax, DWORD PTR _keySeq$1$[ebp]
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _str$2[ebp]
	push	eax
	push	edi
	call	_xmlSchemaFormatIDCKeySequence

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	0
	push	0
	push	esi
	push	eax
	push	OFFSET ??_C@_0CA@LMIOLKEE@Duplicate?5key?9sequence?5?$CFs?5in?5?$CFs@
	push	DWORD PTR _idc$1$[ebp]
	push	0
	push	1877					; 00000755H
	push	edi
	call	_xmlSchemaCustomErr4

; 23069: 			XML_SCHEMAV_CVC_IDC, NULL,
; 23070: 			WXS_BASIC_CAST idc,
; 23071: 			"Duplicate key-sequence %s in %s",
; 23072: 			xmlSchemaFormatIDCKeySequence(vctxt, &str,
; 23073: 			    (*keySeq), nbKeys),
; 23074: 			xmlSchemaGetIDCDesignation(&strB, idc));
; 23075: 		    FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$2[ebp]

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	add	esp, 60					; 0000003cH

; 23069: 			XML_SCHEMAV_CVC_IDC, NULL,
; 23070: 			WXS_BASIC_CAST idc,
; 23071: 			"Duplicate key-sequence %s in %s",
; 23072: 			xmlSchemaFormatIDCKeySequence(vctxt, &str,
; 23073: 			    (*keySeq), nbKeys),
; 23074: 			xmlSchemaGetIDCDesignation(&strB, idc));
; 23075: 		    FREE_AND_NULL(str);

	test	eax, eax
	je	SHORT $LN65@xmlSchemaX
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN65@xmlSchemaX:

; 23076: 		    FREE_AND_NULL(strB);

	mov	eax, DWORD PTR _strB$4[ebp]

; 23077: 		    goto selector_leave;

	jmp	$LN221@xmlSchemaX
$LN64@xmlSchemaX:

; 23078: 		}
; 23079: 	    }
; 23080: 	    /*
; 23081: 	    * Add a node-table item to the IDC binding.
; 23082: 	    */
; 23083: 	    ntItem = (xmlSchemaPSVIIDCNodePtr) xmlMalloc(

	push	16					; 00000010H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 23084: 		sizeof(xmlSchemaPSVIIDCNode));
; 23085: 	    if (ntItem == NULL) {

	test	esi, esi
	je	$LN180@xmlSchemaX

; 23090: 		return(-1);
; 23091: 	    }
; 23092: 	    memset(ntItem, 0, sizeof(xmlSchemaPSVIIDCNode));
; 23093: 
; 23094: 	    /*
; 23095: 	    * Store the node-table item in a global list.
; 23096: 	    */
; 23097: 	    if (idc->type != XML_SCHEMA_TYPE_IDC_KEYREF) {

	mov	eax, DWORD PTR _idc$1$[ebp]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [esi], xmm0
	cmp	DWORD PTR [eax], 24			; 00000018H
	je	$LN68@xmlSchemaX

; 22111:     if (vctxt->idcNodes == NULL) {

	mov	ecx, DWORD PTR [edi+128]
	test	ecx, ecx
	jne	SHORT $LN134@xmlSchemaX

; 22112: 	vctxt->idcNodes = (xmlSchemaPSVIIDCNodePtr *)

	push	80					; 00000050H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [edi+128], ecx

; 22113: 	    xmlMalloc(20 * sizeof(xmlSchemaPSVIIDCNodePtr));
; 22114: 	if (vctxt->idcNodes == NULL) {

	test	ecx, ecx
	je	$LN207@xmlSchemaX

; 22118: 	}
; 22119: 	vctxt->sizeIdcNodes = 20;

	mov	DWORD PTR [edi+136], 20			; 00000014H
	jmp	SHORT $LN138@xmlSchemaX
$LN134@xmlSchemaX:

; 22120:     } else if (vctxt->sizeIdcNodes <= vctxt->nbIdcNodes) {

	mov	eax, DWORD PTR [edi+136]
	cmp	eax, DWORD PTR [edi+132]
	jg	SHORT $LN138@xmlSchemaX

; 22121: 	vctxt->sizeIdcNodes *= 2;

	add	eax, eax
	mov	DWORD PTR [edi+136], eax

; 22122: 	vctxt->idcNodes = (xmlSchemaPSVIIDCNodePtr *)

	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR [edi+128], ecx

; 22123: 	    xmlRealloc(vctxt->idcNodes, vctxt->sizeIdcNodes *
; 22124: 	    sizeof(xmlSchemaPSVIIDCNodePtr));
; 22125: 	if (vctxt->idcNodes == NULL) {

	test	ecx, ecx
	je	$LN208@xmlSchemaX
$LN138@xmlSchemaX:

; 22126: 	    xmlSchemaVErrMemory(vctxt,
; 22127: 		"re-allocating the IDC node table item list", NULL);
; 22128: 	    return (-1);
; 22129: 	}
; 22130:     }
; 22131:     vctxt->idcNodes[vctxt->nbIdcNodes++] = item;

	mov	eax, DWORD PTR [edi+132]
	mov	DWORD PTR [ecx+eax*4], esi
	inc	DWORD PTR [edi+132]

; 23102: 		    return (-1);
; 23103: 		}
; 23104: 		ntItem->nodeQNameID = -1;

	mov	DWORD PTR [esi+12], -1

; 23105: 	    } else {

	jmp	$LN71@xmlSchemaX
$LN68@xmlSchemaX:

; 23106: 		/*
; 23107: 		* Save a cached QName for this node on the IDC node, to be
; 23108: 		* able to report it, even if the node is not saved.
; 23109: 		*/
; 23110: 		ntItem->nodeQNameID = xmlSchemaVAddNodeQName(vctxt,

	mov	eax, DWORD PTR [edi+108]

; 21985:     lname = xmlDictLookup(vctxt->dict, lname, -1);

	push	-1
	push	DWORD PTR [eax+12]

; 23106: 		/*
; 23107: 		* Save a cached QName for this node on the IDC node, to be
; 23108: 		* able to report it, even if the node is not saved.
; 23109: 		*/
; 23110: 		ntItem->nodeQNameID = xmlSchemaVAddNodeQName(vctxt,

	mov	ecx, DWORD PTR [eax+16]

; 21985:     lname = xmlDictLookup(vctxt->dict, lname, -1);

	push	DWORD PTR [edi+156]

; 23106: 		/*
; 23107: 		* Save a cached QName for this node on the IDC node, to be
; 23108: 		* able to report it, even if the node is not saved.
; 23109: 		*/
; 23110: 		ntItem->nodeQNameID = xmlSchemaVAddNodeQName(vctxt,

	mov	DWORD PTR _nsname$1$[ebp], ecx

; 21985:     lname = xmlDictLookup(vctxt->dict, lname, -1);

	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lname$2$[ebp], eax

; 21986:     if (lname == NULL)

	test	eax, eax
	jne	SHORT $LN150@xmlSchemaX

; 21987: 	return(-1);

	or	eax, -1
	jmp	$LN146@xmlSchemaX
$LN150@xmlSchemaX:

; 21988:     if (nsname != NULL) {

	mov	ecx, DWORD PTR _nsname$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN152@xmlSchemaX

; 21989: 	nsname = xmlDictLookup(vctxt->dict, nsname, -1);

	push	-1
	push	ecx
	push	DWORD PTR [edi+156]
	call	_xmlDictLookup
	mov	ecx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _nsname$1$[ebp], ecx

; 21990: 	if (nsname == NULL)

	test	ecx, ecx
	jne	SHORT $LN152@xmlSchemaX

; 21991: 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN146@xmlSchemaX
$LN152@xmlSchemaX:

; 21992:     }
; 21993:     for (i = 0; i < vctxt->nodeQNames->nbItems; i += 2) {

	mov	edx, DWORD PTR [edi+180]
	xor	eax, eax
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR tv1903[ebp], edx
	test	edx, edx
	jle	SHORT $LN211@xmlSchemaX

; 21994: 	if ((vctxt->nodeQNames->items [i] == lname) &&

	mov	edx, DWORD PTR [edi+180]
	mov	edx, DWORD PTR [edx]
$LL149@xmlSchemaX:
	mov	ecx, DWORD PTR _lname$2$[ebp]
	cmp	DWORD PTR [edx+eax*4], ecx
	mov	ecx, DWORD PTR _nsname$1$[ebp]
	jne	SHORT $LN147@xmlSchemaX
	cmp	DWORD PTR [edx+eax*4+4], ecx
	je	SHORT $LN146@xmlSchemaX
$LN147@xmlSchemaX:

; 21992:     }
; 21993:     for (i = 0; i < vctxt->nodeQNames->nbItems; i += 2) {

	add	eax, 2
	cmp	eax, DWORD PTR tv1903[ebp]
	jl	SHORT $LL149@xmlSchemaX
$LN211@xmlSchemaX:

; 21995: 	    (vctxt->nodeQNames->items[i +1] == nsname))
; 21996: 	    /* Already there */
; 21997: 	    return(i);
; 21998:     }
; 21999:     /* Add new entry. */
; 22000:     i = vctxt->nodeQNames->nbItems;
; 22001:     xmlSchemaItemListAdd(vctxt->nodeQNames, (void *) lname);

	push	DWORD PTR _lname$2$[ebp]
	mov	eax, DWORD PTR [edi+180]
	push	eax
	call	_xmlSchemaItemListAdd

; 22002:     xmlSchemaItemListAdd(vctxt->nodeQNames, (void *) nsname);

	mov	ecx, DWORD PTR _nsname$1$[ebp]
	push	ecx
	push	DWORD PTR [edi+180]
	call	_xmlSchemaItemListAdd

; 22003:     return(i);

	mov	eax, DWORD PTR tv1903[ebp]
	add	esp, 16					; 00000010H
$LN146@xmlSchemaX:

; 23106: 		/*
; 23107: 		* Save a cached QName for this node on the IDC node, to be
; 23108: 		* able to report it, even if the node is not saved.
; 23109: 		*/
; 23110: 		ntItem->nodeQNameID = xmlSchemaVAddNodeQName(vctxt,

	mov	DWORD PTR [esi+12], eax

; 23111: 		    vctxt->inode->localName, vctxt->inode->nsName);
; 23112: 		if (ntItem->nodeQNameID == -1) {

	cmp	eax, -1
	je	$LN182@xmlSchemaX
$LN71@xmlSchemaX:

; 23116: 		    return (-1);
; 23117: 		}
; 23118: 	    }
; 23119: 	    /*
; 23120: 	    * Init the node-table item: Save the node, position and
; 23121: 	    * consume the key-sequence.
; 23122: 	    */
; 23123: 	    ntItem->node = vctxt->node;

	mov	eax, DWORD PTR [edi+60]

; 23124: 	    ntItem->nodeLine = vctxt->inode->nodeLine;
; 23125: 	    ntItem->keys = *keySeq;

	mov	ecx, DWORD PTR _keySeq$1$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+108]

; 23126: 	    *keySeq = NULL;
; 23127: #if 0
; 23128: 	    if (xmlSchemaIDCAppendNodeTableItem(bind, ntItem) == -1)
; 23129: #endif
; 23130: 	    if (xmlSchemaItemListAdd(targets, ntItem) == -1) {

	push	esi
	push	DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [ecx], 0
	call	_xmlSchemaItemListAdd
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $selector_leave$232

; 23131: 		if (idc->type == XML_SCHEMA_TYPE_IDC_KEYREF) {

	mov	eax, DWORD PTR _idc$1$[ebp]
	cmp	DWORD PTR [eax], 24			; 00000018H
	jne	$LN227@xmlSchemaX

; 23132: 		    /*
; 23133: 		    * Free the item, since keyref items won't be
; 23134: 		    * put on a global list.
; 23135: 		    */
; 23136: 		    xmlFree(ntItem->keys);

	push	DWORD PTR [esi+4]
	call	DWORD PTR _xmlFree

; 23137: 		    xmlFree(ntItem);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 8

; 23197: 	    sto = sto->next;
; 23198:     } /* while (sto != NULL) */
; 23199:     return (0);
; 23200: }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@xmlSchemaX:

; 22983: 		(matcher->sizeKeySeqs <= pos)) {
; 22984: 		if (idc->type == XML_SCHEMA_TYPE_IDC_KEY)

	mov	ecx, DWORD PTR _idc$1$[ebp]
	cmp	DWORD PTR [ecx], 23			; 00000017H
	jne	SHORT $LN75@xmlSchemaX
$selector_key_error$231:

; 1451 :     return(xmlSchemaGetComponentDesignation(buf, idc));

	push	ecx
	lea	eax, DWORD PTR _str$1[ebp]

; 23138: 		}
; 23139: 		return (-1);
; 23140: 	    }
; 23141: 
; 23142: 	    goto selector_leave;
; 23143: selector_key_error:
; 23144: 	    {
; 23145: 		xmlChar *str = NULL;

	mov	DWORD PTR _str$1[ebp], 0

; 1451 :     return(xmlSchemaGetComponentDesignation(buf, idc));

	push	eax
	call	_xmlSchemaGetComponentDesignation

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	0
	push	0
	push	0
	push	eax
	push	OFFSET ??_C@_0CI@LOGANEIF@Not?5all?5fields?5of?5?$CFs?5evaluate?5t@
	push	DWORD PTR _idc$1$[ebp]
	push	0
	push	1877					; 00000755H
	push	edi
	call	_xmlSchemaCustomErr4

; 23146: 		/*
; 23147: 		* 4.2.1 (KEY) The `target node set` and the
; 23148: 		* `qualified node set` are equal, that is, every
; 23149: 		* member of the `target node set` is also a member
; 23150: 		* of the `qualified node set` and vice versa.
; 23151: 		*/
; 23152: 		xmlSchemaCustomErr(ACTXT_CAST vctxt,
; 23153: 		    XML_SCHEMAV_CVC_IDC, NULL,
; 23154: 		    WXS_BASIC_CAST idc,
; 23155: 		    "Not all fields of %s evaluate to a node",
; 23156: 		    xmlSchemaGetIDCDesignation(&str, idc), NULL);
; 23157: 		FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$1[ebp]

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	add	esp, 44					; 0000002cH
$LN221@xmlSchemaX:

; 23158: 	    }
; 23159: selector_leave:
; 23160: 	    /*
; 23161: 	    * Free the key-sequence if not added to the IDC table.
; 23162: 	    */
; 23163: 	    if ((keySeq != NULL) && (*keySeq != NULL)) {

	test	eax, eax
	je	SHORT $selector_leave$232
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$selector_leave$232:
	mov	esi, DWORD PTR _keySeq$1$[ebp]
	test	esi, esi
	je	SHORT $LN75@xmlSchemaX
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN75@xmlSchemaX

; 23164: 		xmlFree(*keySeq);

	push	eax
	call	DWORD PTR _xmlFree

; 23165: 		*keySeq = NULL;

	mov	DWORD PTR [esi], 0
$LN219@xmlSchemaX:

; 23166: 	    }
; 23167: 	} /* if selector */
; 23168: 
; 23169: 	sto->nbHistory--;
; 23170: 
; 23171: deregister_check:
; 23172: 	/*
; 23173: 	* Deregister state objects if they reach the depth of creation.
; 23174: 	*/
; 23175: 	if ((sto->nbHistory == 0) && (sto->depth == depth)) {

	add	esp, 4
$LN75@xmlSchemaX:
	dec	DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [ebx+16]
$deregister_check$233:
	test	ecx, ecx
	jne	SHORT $LN76@xmlSchemaX
$LN217@xmlSchemaX:
	mov	eax, DWORD PTR _depth$[ebp]
	cmp	DWORD PTR [ebx+8], eax
	jne	SHORT $LN76@xmlSchemaX

; 23176: #ifdef DEBUG_IDC
; 23177: 	    xmlGenericError(xmlGenericErrorContext, "IDC:   STO pop '%s'\n",
; 23178: 		sto->sel->xpath);
; 23179: #endif
; 23180: 	    if (vctxt->xpathStates != sto) {

	cmp	DWORD PTR [edi+116], ebx
	je	SHORT $LN159@xmlSchemaX

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0DM@JEDCDBII@The?5state?5object?5to?5be?5removed?5@
	push	OFFSET ??_C@_0BN@CBHGMMP@xmlSchemaXPathProcessHistory@
	push	edi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$LN159@xmlSchemaX:

; 23181: 		VERROR_INT("xmlSchemaXPathProcessHistory",
; 23182: 		    "The state object to be removed is not the first "
; 23183: 		    "in the list");
; 23184: 	    }
; 23185: 	    nextsto = sto->next;

	mov	ecx, DWORD PTR [ebx+4]

; 23186: 	    /*
; 23187: 	    * Unlink from the list of active XPath state objects.
; 23188: 	    */
; 23189: 	    vctxt->xpathStates = sto->next;
; 23190: 	    sto->next = vctxt->xpathStatePool;

	mov	eax, DWORD PTR [edi+120]

; 23191: 	    /*
; 23192: 	    * Link it to the pool of reusable state objects.
; 23193: 	    */
; 23194: 	    vctxt->xpathStatePool = sto;
; 23195: 	    sto = nextsto;
; 23196: 	} else

	mov	esi, DWORD PTR _key$1$[ebp]
	mov	DWORD PTR [edi+116], ecx
	mov	DWORD PTR [ebx+4], eax
	mov	DWORD PTR [edi+120], ebx
	mov	ebx, ecx
	jmp	SHORT $LN77@xmlSchemaX
$LN76@xmlSchemaX:
	mov	esi, DWORD PTR _key$1$[ebp]
$LN218@xmlSchemaX:

; 22712:     xmlSchemaIDCStateObjPtr sto, nextsto;
; 22713:     int res, matchDepth;
; 22714:     xmlSchemaPSVIIDCKeyPtr key = NULL;
; 22715:     xmlSchemaTypePtr type = vctxt->inode->typeDef, simpleType = NULL;
; 22716: 
; 22717:     if (vctxt->xpathStates == NULL)
; 22718: 	return (0);
; 22719:     sto = vctxt->xpathStates;
; 22720: 
; 22721: #ifdef DEBUG_IDC
; 22722:     {
; 22723: 	xmlChar *str = NULL;
; 22724: 	xmlGenericError(xmlGenericErrorContext,
; 22725: 	    "IDC: BACK on %s, depth %d\n",
; 22726: 	    xmlSchemaFormatQName(&str, vctxt->inode->nsName,
; 22727: 		vctxt->inode->localName), vctxt->depth);
; 22728: 	FREE_AND_NULL(str)
; 22729:     }
; 22730: #endif
; 22731:     /*
; 22732:     * Evaluate the state objects.
; 22733:     */
; 22734:     while (sto != NULL) {

	mov	ebx, DWORD PTR [ebx+4]
$LN77@xmlSchemaX:
	test	ebx, ebx
	jne	$LL2@xmlSchemaX
$LN3@xmlSchemaX:
	pop	edi

; 23197: 	    sto = sto->next;
; 23198:     } /* while (sto != NULL) */
; 23199:     return (0);
; 23200: }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN175@xmlSchemaX:

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CF@MLBGNEED@allocating?5an?5array?5of?5key?9sequ@
	push	0
	push	0
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError

; 23197: 	    sto = sto->next;
; 23198:     } /* while (sto != NULL) */
; 23199:     return (0);
; 23200: }

	add	esp, 20					; 00000014H
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN176@xmlSchemaX:

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CH@LFFCCCHC@reallocating?5an?5array?5of?5key?9se@
	push	0
	push	0
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError

; 23197: 	    sto = sto->next;
; 23198:     } /* while (sto != NULL) */
; 23199:     return (0);
; 23200: }

	add	esp, 20					; 00000014H
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN177@xmlSchemaX:

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BP@BFFMOABM@allocating?5an?5IDC?5key?9sequence@
	push	0
	push	0
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError

; 23197: 	    sto = sto->next;
; 23198:     } /* while (sto != NULL) */
; 23199:     return (0);
; 23200: }

	add	esp, 20					; 00000014H
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN204@xmlSchemaX:

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	mov	eax, OFFSET ??_C@_0CE@CCLJMNGF@allocating?5the?5IDC?5key?5storage?5@

; 22158: 	    return (-1);

	jmp	SHORT $LN223@xmlSchemaX
$LN206@xmlSchemaX:

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	mov	eax, OFFSET ??_C@_0CH@OEOHKDEB@re?9allocating?5the?5IDC?5key?5stora@
$LN223@xmlSchemaX:

; 22944: 		    /*
; 22945: 		    * Store the key in a global list.
; 22946: 		    */
; 22947: 		    if (xmlSchemaIDCStoreKey(vctxt, key) == -1) {
; 22948: 			xmlSchemaIDCFreeKey(key);

	inc	DWORD PTR [edi+56]
	push	eax
	push	0
	push	0
	push	2
	push	17					; 00000011H
	mov	DWORD PTR [edi+52], 1818		; 0000071aH
	call	___xmlSimpleError
	push	DWORD PTR _key$1$[ebp]
	call	_xmlSchemaIDCFreeKey
	add	esp, 24					; 00000018H

; 23197: 	    sto = sto->next;
; 23198:     } /* while (sto != NULL) */
; 23199:     return (0);
; 23200: }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN178@xmlSchemaX:

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BF@DNPMHACD@allocating?5a?5IDC?5key@
	push	0
	push	0
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError

; 22932: 			xmlSchemaVErrMemory(NULL,
; 22933: 			    "allocating a IDC key", NULL);
; 22934: 			xmlFree(keySeq);

	push	DWORD PTR _keySeq$1$[ebp]
	call	DWORD PTR _xmlFree

; 22935: 			matcher->keySeqs[pos] = NULL;

	mov	eax, DWORD PTR [esi+24]
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _pos$1$[ebp]
	pop	edi

; 23197: 	    sto = sto->next;
; 23198:     } /* while (sto != NULL) */
; 23199:     return (0);
; 23200: }

	pop	esi
	mov	DWORD PTR [eax+ecx*4], 0
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN174@xmlSchemaX:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0FD@MADPFADD@field?5resolves?5to?5a?5CT?5with?5sim@

; 22771: 			VERROR_INT("xmlSchemaXPathProcessHistory",
; 22772: 			    "field resolves to a CT with simple content "
; 22773: 			    "but the CT is missing the ST definition");
; 22774: 			return (-1);

	jmp	$LN225@xmlSchemaX
$LN207@xmlSchemaX:

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	mov	eax, OFFSET ??_C@_0CI@MOGKDPMG@allocating?5the?5IDC?5node?5table?5i@

; 22117: 	    return (-1);

	jmp	SHORT $LN224@xmlSchemaX
$LN208@xmlSchemaX:

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	mov	eax, OFFSET ??_C@_0CL@PFEMPGNK@re?9allocating?5the?5IDC?5node?5tabl@
$LN224@xmlSchemaX:

; 23098: 		if (xmlSchemaIDCStoreNodeTableItem(vctxt, ntItem) == -1) {
; 23099: 		    xmlFree(ntItem);

	inc	DWORD PTR [edi+56]
	push	eax
	push	0
	push	0
	push	2
	push	17					; 00000011H
	mov	DWORD PTR [edi+52], 1818		; 0000071aH
	call	___xmlSimpleError
	push	esi
	call	DWORD PTR _xmlFree

; 23100: 		    xmlFree(*keySeq);

	mov	ebx, DWORD PTR _keySeq$1$[ebp]
	push	DWORD PTR [ebx]
	call	DWORD PTR _xmlFree
	add	esp, 28					; 0000001cH

; 23101: 		    *keySeq = NULL;

	mov	DWORD PTR [ebx], 0

; 23197: 	    sto = sto->next;
; 23198:     } /* while (sto != NULL) */
; 23199:     return (0);
; 23200: }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN182@xmlSchemaX:

; 23113: 		    xmlFree(ntItem);

	push	esi
	call	DWORD PTR _xmlFree

; 23114: 		    xmlFree(*keySeq);

	mov	ebx, DWORD PTR _keySeq$1$[ebp]
	push	DWORD PTR [ebx]
	call	DWORD PTR _xmlFree
	add	esp, 8

; 23115: 		    *keySeq = NULL;

	mov	DWORD PTR [ebx], 0

; 23197: 	    sto = sto->next;
; 23198:     } /* while (sto != NULL) */
; 23199:     return (0);
; 23200: }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN180@xmlSchemaX:

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@HMFENHHC@allocating?5an?5IDC?5node?9table?5it@
	push	0
	push	0
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError

; 23086: 		xmlSchemaVErrMemory(NULL,
; 23087: 		    "allocating an IDC node-table item", NULL);
; 23088: 		xmlFree(*keySeq);

	mov	ebx, DWORD PTR _keySeq$1$[ebp]
	push	DWORD PTR [ebx]
	call	DWORD PTR _xmlFree
	add	esp, 24					; 00000018H

; 23089: 		*keySeq = NULL;

	mov	DWORD PTR [ebx], 0

; 23197: 	    sto = sto->next;
; 23198:     } /* while (sto != NULL) */
; 23199:     return (0);
; 23200: }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN173@xmlSchemaX:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BH@HBBLPIID@calling?5xmlStreamPop?$CI?$CJ@
$LN225@xmlSchemaX:

; 23197: 	    sto = sto->next;
; 23198:     } /* while (sto != NULL) */
; 23199:     return (0);
; 23200: }

	push	OFFSET ??_C@_0BN@CBHGMMP@xmlSchemaXPathProcessHistory@
	push	edi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$LN227@xmlSchemaX:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaXPathProcessHistory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaXPathPop
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_xmlSchemaXPathPop PROC					; COMDAT

; 22681: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _vctxt$[ebp]
	mov	esi, DWORD PTR [esi+116]
	test	esi, esi
	je	SHORT $LN10@xmlSchemaX
$LL4@xmlSchemaX:

; 22682:     xmlSchemaIDCStateObjPtr sto;
; 22683:     int res;
; 22684: 
; 22685:     if (vctxt->xpathStates == NULL)
; 22686: 	return(0);
; 22687:     sto = vctxt->xpathStates;
; 22688:     do {
; 22689: 	res = xmlStreamPop((xmlStreamCtxtPtr) sto->xpathCtxt);

	push	DWORD PTR [esi+32]
	call	_xmlStreamPop
	add	esp, 4

; 22690: 	if (res == -1)

	cmp	eax, -1
	je	SHORT $LN9@xmlSchemaX

; 22692: 	sto = sto->next;

	mov	esi, DWORD PTR [esi+4]

; 22693:     } while (sto != NULL);

	test	esi, esi
	jne	SHORT $LL4@xmlSchemaX
$LN10@xmlSchemaX:

; 22694:     return(0);

	xor	eax, eax
	pop	esi

; 22695: }

	pop	ebp
	ret	0
$LN9@xmlSchemaX:

; 22691: 	    return (-1);

	or	eax, -1
	pop	esi

; 22695: }

	pop	ebp
	ret	0
_xmlSchemaXPathPop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFormatIDCKeySequence
_TEXT	SEGMENT
_value$ = -4						; size = 4
_vctxt$ = 8						; size = 4
tv396 = 12						; size = 4
_buf$ = 12						; size = 4
_seq$ = 16						; size = 4
_count$ = 20						; size = 4
_xmlSchemaFormatIDCKeySequence PROC			; COMDAT

; 22640: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	OFFSET ??_C@_01OHGJGJJP@?$FL@
	mov	DWORD PTR _value$[ebp], 0
	call	_xmlStrdup
	mov	esi, DWORD PTR _buf$[ebp]
	add	esp, 4
	xor	ebx, ebx
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _count$[ebp]
	test	eax, eax
	jle	$LN3@xmlSchemaF
	dec	eax
	push	edi
	mov	edi, DWORD PTR _seq$[ebp]
	mov	DWORD PTR tv396[ebp], eax
	npad	2
$LL4@xmlSchemaF:

; 22646: 	*buf = xmlStrcat(*buf, BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	DWORD PTR [esi]
	call	_xmlStrcat
	mov	DWORD PTR [esi], eax
	add	esp, 8

; 22647: 	res = xmlSchemaGetCanonValueWhtspExt(seq[i]->val,

	mov	edx, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [edx]

; 21567:     if (type->type == XML_SCHEMA_TYPE_BASIC) {

	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN12@xmlSchemaF

; 21568: 	/*
; 21569: 	* Note that we assume a whitespace of preserve for anySimpleType.
; 21570: 	*/
; 21571: 	if ((type->builtInType == XML_SCHEMAS_STRING) ||

	mov	ecx, DWORD PTR [eax+88]
	cmp	ecx, 1
	je	SHORT $LN34@xmlSchemaF
	cmp	ecx, 46					; 0000002eH
	je	SHORT $LN34@xmlSchemaF

; 21572: 	    (type->builtInType == XML_SCHEMAS_ANYSIMPLETYPE))
; 21573: 	    return(XML_SCHEMA_WHITESPACE_PRESERVE);
; 21574: 	else if (type->builtInType == XML_SCHEMAS_NORMSTRING)

	xor	eax, eax
	cmp	ecx, 2
	setne	al
	add	eax, 2

; 21575: 	    return(XML_SCHEMA_WHITESPACE_REPLACE);
; 21576: 	else {
; 21577: 	    /*
; 21578: 	    * For all `atomic` datatypes other than string (and types `derived`
; 21579: 	    * by `restriction` from it) the value of whiteSpace is fixed to
; 21580: 	    * collapse
; 21581: 	    * Note that this includes built-in list datatypes.
; 21582: 	    */
; 21583: 	    return(XML_SCHEMA_WHITESPACE_COLLAPSE);

	jmp	SHORT $LN11@xmlSchemaF
$LN12@xmlSchemaF:

; 21584: 	}
; 21585:     } else if (WXS_IS_LIST(type)) {

	mov	eax, DWORD PTR [eax+48]
	test	al, 64					; 00000040H
	je	SHORT $LN19@xmlSchemaF

; 21586: 	/*
; 21587: 	* For list types the facet "whiteSpace" is fixed to "collapse".
; 21588: 	*/
; 21589: 	return (XML_SCHEMA_WHITESPACE_COLLAPSE);

	mov	eax, 3
	jmp	SHORT $LN11@xmlSchemaF
$LN19@xmlSchemaF:

; 21590:     } else if (WXS_IS_UNION(type)) {

	test	al, al
	jns	SHORT $LN21@xmlSchemaF

; 21591: 	return (XML_SCHEMA_WHITESPACE_UNKNOWN);

	xor	eax, eax
	jmp	SHORT $LN11@xmlSchemaF
$LN21@xmlSchemaF:

; 21592:     } else if (WXS_IS_ATOMIC(type)) {

	test	eax, 256				; 00000100H
	je	SHORT $LN27@xmlSchemaF

; 21593: 	if (type->flags & XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE)

	test	eax, 16777216				; 01000000H
	je	SHORT $LN24@xmlSchemaF
$LN34@xmlSchemaF:

; 22647: 	res = xmlSchemaGetCanonValueWhtspExt(seq[i]->val,

	mov	eax, 1
	jmp	SHORT $LN11@xmlSchemaF
$LN24@xmlSchemaF:

; 21595: 	else if (type->flags & XML_SCHEMAS_TYPE_WHITESPACE_REPLACE)

	shr	eax, 25					; 00000019H
	not	eax
	and	eax, 1
	or	eax, 2

; 21596: 	    return (XML_SCHEMA_WHITESPACE_REPLACE);
; 21597: 	else
; 21598: 	    return (XML_SCHEMA_WHITESPACE_COLLAPSE);

	jmp	SHORT $LN11@xmlSchemaF
$LN27@xmlSchemaF:

; 21599:     }
; 21600:     return (-1);

	or	eax, -1
$LN11@xmlSchemaF:

; 22647: 	res = xmlSchemaGetCanonValueWhtspExt(seq[i]->val,

	lea	ecx, DWORD PTR _value$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [edx+4]
	call	_xmlSchemaGetCanonValueWhtspExt

; 22648: 	    xmlSchemaGetWhiteSpaceFacetValue(seq[i]->type),
; 22649: 	    &value);
; 22650: 	if (res == 0)

	mov	edi, DWORD PTR _value$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@xmlSchemaF

; 22651: 	    *buf = xmlStrcat(*buf, BAD_CAST value);

	push	edi
	push	DWORD PTR [esi]
	call	_xmlStrcat
	add	esp, 8
	jmp	SHORT $LN36@xmlSchemaF
$LN5@xmlSchemaF:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CE@HGOJGLAG@failed?5to?5compute?5a?5canonical?5v@
	push	OFFSET ??_C@_0BO@COPGMMIK@xmlSchemaFormatIDCKeySequence@
	push	DWORD PTR _vctxt$[ebp]
	call	_xmlSchemaInternalErr2

; 22652: 	else {
; 22653: 	    VERROR_INT("xmlSchemaFormatIDCKeySequence",
; 22654: 		"failed to compute a canonical value");
; 22655: 	    *buf = xmlStrcat(*buf, BAD_CAST "???");

	push	OFFSET ??_C@_03BBKEAIF@?$DP?$DP?$DP@
	push	DWORD PTR [esi]
	call	_xmlStrcat
	add	esp, 28					; 0000001cH
$LN36@xmlSchemaF:

; 22656: 	}
; 22657: 	if (i < count -1)
; 22658: 	    *buf = xmlStrcat(*buf, BAD_CAST "', ");
; 22659: 	else
; 22660: 	    *buf = xmlStrcat(*buf, BAD_CAST "'");
; 22661: 	if (value != NULL) {

	cmp	ebx, DWORD PTR tv396[ebp]
	mov	ecx, eax
	mov	edx, OFFSET ??_C@_03EHINCMEC@?8?0?5@
	mov	DWORD PTR [esi], ecx
	mov	eax, OFFSET ??_C@_01GEODFPGF@?8@
	cmovl	eax, edx
	push	eax
	push	ecx
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR [esi], eax
	test	edi, edi
	je	SHORT $LN2@xmlSchemaF

; 22662: 	    xmlFree(value);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 22663: 	    value = NULL;

	mov	DWORD PTR _value$[ebp], 0
$LN2@xmlSchemaF:

; 22641:     int i, res;
; 22642:     xmlChar *value = NULL;
; 22643: 
; 22644:     *buf = xmlStrdup(BAD_CAST "[");
; 22645:     for (i = 0; i < count; i++) {

	mov	edi, DWORD PTR _seq$[ebp]
	inc	ebx
	cmp	ebx, DWORD PTR _count$[ebp]
	jl	$LL4@xmlSchemaF
	pop	edi
$LN3@xmlSchemaF:

; 22664: 	}
; 22665:     }
; 22666:     *buf = xmlStrcat(*buf, BAD_CAST "]");

	push	OFFSET ??_C@_01LBDDMOBJ@?$FN@
	push	DWORD PTR [esi]
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR [esi], eax

; 22667: 
; 22668:     return (BAD_CAST *buf);

	pop	esi
	pop	ebx

; 22669: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaFormatIDCKeySequence ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaXPathEvaluate
_TEXT	SEGMENT
tv578 = -12						; size = 4
_head$1$ = -8						; size = 4
_resolved$1$ = -4					; size = 4
tv577 = 8						; size = 4
_vctxt$ = 8						; size = 4
_nodeType$ = 12						; size = 4
_xmlSchemaXPathEvaluate PROC				; COMDAT

; 22504: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _vctxt$[ebp]
	xor	edi, edi
	mov	DWORD PTR _head$1$[ebp], 0
	mov	DWORD PTR _resolved$1$[ebp], edi
	mov	ecx, DWORD PTR [ebx+116]
	mov	eax, DWORD PTR [ebx+96]
	mov	DWORD PTR tv578[ebp], ecx
	test	ecx, ecx
	jne	SHORT $LN6@xmlSchemaX

; 22505:     xmlSchemaIDCStateObjPtr sto, head = NULL, first;
; 22506:     int res, resolved = 0, depth = vctxt->depth;
; 22507: 
; 22508:     if (vctxt->xpathStates == NULL)
; 22509: 	return (0);

	pop	edi
	xor	eax, eax

; 22633: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlSchemaX:

; 22510: 
; 22511:     if (nodeType == XML_ATTRIBUTE_NODE)
; 22512: 	depth++;
; 22513: #ifdef DEBUG_IDC
; 22514:     {
; 22515: 	xmlChar *str = NULL;
; 22516: 	xmlGenericError(xmlGenericErrorContext,
; 22517: 	    "IDC: EVAL on %s, depth %d, type %d\n",
; 22518: 	    xmlSchemaFormatQName(&str, vctxt->inode->nsName,
; 22519: 		vctxt->inode->localName), depth, nodeType);
; 22520: 	FREE_AND_NULL(str)
; 22521:     }
; 22522: #endif
; 22523:     /*
; 22524:     * Process all active XPath state objects.
; 22525:     */
; 22526:     first = vctxt->xpathStates;

	cmp	DWORD PTR _nodeType$[ebp], 2
	lea	edx, DWORD PTR [eax+1]
	push	esi
	cmovne	edx, eax

; 22527:     sto = first;

	mov	esi, ecx
	mov	DWORD PTR tv577[ebp], edx
$LL2@xmlSchemaX:

; 22529: #ifdef DEBUG_IDC
; 22530: 	if (sto->type == XPATH_STATE_OBJ_TYPE_IDC_SELECTOR)
; 22531: 	    xmlGenericError(xmlGenericErrorContext, "IDC:   ['%s'] selector '%s'\n",
; 22532: 		sto->matcher->aidc->def->name, sto->sel->xpath);
; 22533: 	else
; 22534: 	    xmlGenericError(xmlGenericErrorContext, "IDC:   ['%s'] field '%s'\n",
; 22535: 		sto->matcher->aidc->def->name, sto->sel->xpath);
; 22536: #endif
; 22537: 	if (nodeType == XML_ELEMENT_NODE)

	cmp	DWORD PTR _nodeType$[ebp], 1
	mov	eax, DWORD PTR [ebx+108]
	mov	edx, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+12]
	push	ecx
	push	eax
	push	edx
	jne	SHORT $LN8@xmlSchemaX

; 22538: 	    res = xmlStreamPush((xmlStreamCtxtPtr) sto->xpathCtxt,

	call	_xmlStreamPush
	jmp	SHORT $LN48@xmlSchemaX
$LN8@xmlSchemaX:

; 22539: 		vctxt->inode->localName, vctxt->inode->nsName);
; 22540: 	else
; 22541: 	    res = xmlStreamPushAttr((xmlStreamCtxtPtr) sto->xpathCtxt,

	call	_xmlStreamPushAttr
$LN48@xmlSchemaX:

; 22542: 		vctxt->inode->localName, vctxt->inode->nsName);
; 22543: 
; 22544: 	if (res == -1) {

	add	esp, 12					; 0000000cH
	cmp	eax, -1
	je	$LN37@xmlSchemaX

; 22548: 	}
; 22549: 	if (res == 0)

	test	eax, eax
	je	$next_sto$51

; 22550: 	    goto next_sto;
; 22551: 	/*
; 22552: 	* Full match.
; 22553: 	*/
; 22554: #ifdef DEBUG_IDC
; 22555: 	xmlGenericError(xmlGenericErrorContext, "IDC:     "
; 22556: 	    "MATCH\n");
; 22557: #endif
; 22558: 	/*
; 22559: 	* Register a match in the state object history.
; 22560: 	*/
; 22561: 	if (sto->history == NULL) {

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN12@xmlSchemaX

; 22562: 	    sto->history = (int *) xmlMalloc(5 * sizeof(int));

	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [esi+12], ecx

; 22563: 	    if (sto->history == NULL) {

	test	ecx, ecx
	je	$LN38@xmlSchemaX

; 22564: 		xmlSchemaVErrMemory(NULL,
; 22565: 		    "allocating the state object history", NULL);
; 22566: 		return(-1);
; 22567: 	    }
; 22568: 	    sto->sizeHistory = 5;

	mov	DWORD PTR [esi+20], 5
	jmp	SHORT $LN16@xmlSchemaX
$LN12@xmlSchemaX:

; 22569: 	} else if (sto->sizeHistory <= sto->nbHistory) {

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, DWORD PTR [esi+16]
	jg	SHORT $LN16@xmlSchemaX

; 22570: 	    sto->sizeHistory *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+20], eax

; 22571: 	    sto->history = (int *) xmlRealloc(sto->history,

	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR [esi+12], ecx

; 22572: 		sto->sizeHistory * sizeof(int));
; 22573: 	    if (sto->history == NULL) {

	test	ecx, ecx
	je	$LN39@xmlSchemaX
$LN16@xmlSchemaX:

; 22574: 		xmlSchemaVErrMemory(NULL,
; 22575: 		    "re-allocating the state object history", NULL);
; 22576: 		return(-1);
; 22577: 	    }
; 22578: 	}
; 22579: 	sto->history[sto->nbHistory++] = depth;

	mov	eax, DWORD PTR [esi+16]
	mov	edx, DWORD PTR tv577[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	inc	DWORD PTR [esi+16]

; 22580: 
; 22581: #ifdef DEBUG_IDC
; 22582: 	xmlGenericError(xmlGenericErrorContext, "IDC:       push match '%d'\n",
; 22583: 	    vctxt->depth);
; 22584: #endif
; 22585: 
; 22586: 	if (sto->type == XPATH_STATE_OBJ_TYPE_IDC_SELECTOR) {

	mov	eax, DWORD PTR [esi]
	cmp	eax, 1
	jne	SHORT $LN17@xmlSchemaX

; 22587: 	    xmlSchemaIDCSelectPtr sel;
; 22588: 	    /*
; 22589: 	    * Activate state objects for the IDC fields of
; 22590: 	    * the IDC selector.
; 22591: 	    */
; 22592: #ifdef DEBUG_IDC
; 22593: 	    xmlGenericError(xmlGenericErrorContext, "IDC:     "
; 22594: 		"activating field states\n");
; 22595: #endif
; 22596: 	    sel = sto->matcher->aidc->def->fields;

	mov	eax, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+28]

; 22597: 	    while (sel != NULL) {

	test	edi, edi
	je	SHORT $LN46@xmlSchemaX
	npad	2
$LL4@xmlSchemaX:

; 22598: 		if (xmlSchemaIDCAddStateObject(vctxt, sto->matcher,
; 22599: 		    sel, XPATH_STATE_OBJ_TYPE_IDC_FIELD) == -1)

	push	2
	push	edi
	push	DWORD PTR [esi+24]
	push	ebx
	call	_xmlSchemaIDCAddStateObject
	add	esp, 16					; 00000010H
	cmp	eax, -1
	je	$LN36@xmlSchemaX

; 22600: 		    return (-1);
; 22601: 		sel = sel->next;

	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	SHORT $LL4@xmlSchemaX
$LN46@xmlSchemaX:

; 22621: 	}
; 22622: next_sto:
; 22623: 	if (sto->next == NULL) {

	mov	edi, DWORD PTR _resolved$1$[ebp]
$next_sto$51:
	mov	esi, DWORD PTR [esi+4]
	mov	ecx, esi
	test	esi, esi
	jne	SHORT $LN23@xmlSchemaX

; 22624: 	    /*
; 22625: 	    * Evaluate field state objects created on this node as well.
; 22626: 	    */
; 22627: 	    head = first;
; 22628: 	    sto = vctxt->xpathStates;

	mov	esi, DWORD PTR [ebx+116]
$LN23@xmlSchemaX:

; 22528:     while (sto != head) {

	mov	eax, DWORD PTR tv578[ebp]
	test	ecx, ecx
	cmovne	eax, DWORD PTR _head$1$[ebp]
	mov	DWORD PTR _head$1$[ebp], eax
	cmp	esi, eax
	jne	$LL2@xmlSchemaX

; 22629: 	} else
; 22630: 	    sto = sto->next;
; 22631:     }
; 22632:     return (resolved);

	pop	esi
	mov	eax, edi
	pop	edi

; 22633: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlSchemaX:

; 22602: 	    }
; 22603: 	} else if (sto->type == XPATH_STATE_OBJ_TYPE_IDC_FIELD) {

	cmp	eax, 2
	jne	SHORT $next_sto$51

; 22604: 	    /*
; 22605: 	    * An IDC key node was found by the IDC field.
; 22606: 	    */
; 22607: #ifdef DEBUG_IDC
; 22608: 	    xmlGenericError(xmlGenericErrorContext,
; 22609: 		"IDC:     key found\n");
; 22610: #endif
; 22611: 	    /*
; 22612: 	    * Notify that the character value of this node is
; 22613: 	    * needed.
; 22614: 	    */
; 22615: 	    if (resolved == 0) {

	test	edi, edi
	jne	SHORT $LN22@xmlSchemaX

; 22616: 		if ((vctxt->inode->flags &
; 22617: 		    XML_SCHEMA_NODE_INFO_VALUE_NEEDED) == 0)

	mov	ecx, DWORD PTR [ebx+108]
	mov	eax, DWORD PTR [ecx+32]
	test	al, 16					; 00000010H
	jne	SHORT $LN22@xmlSchemaX

; 22618: 		vctxt->inode->flags |= XML_SCHEMA_NODE_INFO_VALUE_NEEDED;

	or	eax, 16					; 00000010H
	mov	DWORD PTR [ecx+32], eax
$LN22@xmlSchemaX:

; 22619: 	    }
; 22620: 	    resolved++;

	inc	edi
	mov	DWORD PTR _resolved$1$[ebp], edi
	jmp	SHORT $next_sto$51
$LN38@xmlSchemaX:

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CE@OEKMEEHF@allocating?5the?5state?5object?5his@
	push	0
	push	0
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	add	esp, 20					; 00000014H

; 22545: 	    VERROR_INT("xmlSchemaXPathEvaluate",
; 22546: 		"calling xmlStreamPush()");
; 22547: 	    return (-1);

	or	eax, -1
	pop	esi
	pop	edi

; 22633: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@xmlSchemaX:

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CH@CCPCCKFB@re?9allocating?5the?5state?5object?5@
	push	0
	push	0
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	add	esp, 20					; 00000014H

; 22545: 	    VERROR_INT("xmlSchemaXPathEvaluate",
; 22546: 		"calling xmlStreamPush()");
; 22547: 	    return (-1);

	or	eax, -1
	pop	esi
	pop	edi

; 22633: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@xmlSchemaX:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BI@EPLNDPKO@calling?5xmlStreamPush?$CI?$CJ@
	push	OFFSET ??_C@_0BH@BGCDIJOO@xmlSchemaXPathEvaluate@
	push	ebx
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$LN36@xmlSchemaX:
	pop	esi
	pop	edi

; 22545: 	    VERROR_INT("xmlSchemaXPathEvaluate",
; 22546: 		"calling xmlStreamPush()");
; 22547: 	    return (-1);

	or	eax, -1

; 22633: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaXPathEvaluate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIDCAddStateObject
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_matcher$ = 12						; size = 4
_sel$ = 16						; size = 4
_type$ = 20						; size = 4
_xmlSchemaIDCAddStateObject PROC			; COMDAT

; 22433: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _vctxt$[ebp]
	mov	esi, DWORD PTR [edi+120]
	test	esi, esi
	je	SHORT $LN2@xmlSchemaI

; 22434:     xmlSchemaIDCStateObjPtr sto;
; 22435: 
; 22436:     /*
; 22437:     * Reuse the state objects from the pool.
; 22438:     */
; 22439:     if (vctxt->xpathStatePool != NULL) {
; 22440: 	sto = vctxt->xpathStatePool;
; 22441: 	vctxt->xpathStatePool = sto->next;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+120], eax

; 22442: 	sto->next = NULL;

	mov	DWORD PTR [esi+4], 0

; 22443:     } else {

	jmp	SHORT $LN3@xmlSchemaI
$LN2@xmlSchemaI:

; 22444: 	/*
; 22445: 	* Create a new state object.
; 22446: 	*/
; 22447: 	sto = (xmlSchemaIDCStateObjPtr) xmlMalloc(sizeof(xmlSchemaIDCStateObj));

	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 22448: 	if (sto == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlSchemaI

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BP@KMMMKNDG@allocating?5an?5IDC?5state?5object@
	push	eax
	push	eax
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 22449: 	    xmlSchemaVErrMemory(NULL,
; 22450: 		"allocating an IDC state object", NULL);
; 22451: 	    return (-1);

	or	eax, -1
	pop	edi

; 22489: }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlSchemaI:
	xorps	xmm0, xmm0

; 22452: 	}
; 22453: 	memset(sto, 0, sizeof(xmlSchemaIDCStateObj));

	movups	XMMWORD PTR [esi], xmm0
	movups	XMMWORD PTR [esi+16], xmm0
	mov	DWORD PTR [esi+32], 0
$LN3@xmlSchemaI:

; 22454:     }
; 22455:     /*
; 22456:     * Add to global list.
; 22457:     */
; 22458:     if (vctxt->xpathStates != NULL)

	mov	eax, DWORD PTR [edi+116]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaI

; 22459: 	sto->next = vctxt->xpathStates;

	mov	DWORD PTR [esi+4], eax
$LN5@xmlSchemaI:

; 22460:     vctxt->xpathStates = sto;

	mov	DWORD PTR [edi+116], esi

; 22461: 
; 22462:     /*
; 22463:     * Free the old xpath validation context.
; 22464:     */
; 22465:     if (sto->xpathCtxt != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN6@xmlSchemaI

; 22466: 	xmlFreeStreamCtxt((xmlStreamCtxtPtr) sto->xpathCtxt);

	push	eax
	call	_xmlFreeStreamCtxt
	add	esp, 4
$LN6@xmlSchemaI:

; 22467: 
; 22468:     /*
; 22469:     * Create a new XPath (pattern) validation context.
; 22470:     */
; 22471:     sto->xpathCtxt = (void *) xmlPatternGetStreamCtxt(

	push	ebx
	mov	ebx, DWORD PTR _sel$[ebp]
	push	DWORD PTR [ebx+16]
	call	_xmlPatternGetStreamCtxt
	add	esp, 4
	mov	DWORD PTR [esi+32], eax

; 22472: 	(xmlPatternPtr) sel->xpathComp);
; 22473:     if (sto->xpathCtxt == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlSchemaI

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	eax
	push	eax
	push	OFFSET ??_C@_0CN@MKAMKJFE@failed?5to?5create?5an?5XPath?5valid@
	push	OFFSET ??_C@_0BL@EMBGPHEI@xmlSchemaIDCAddStateObject@
	push	edi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 22474: 	VERROR_INT("xmlSchemaIDCAddStateObject",
; 22475: 	    "failed to create an XPath validation context");
; 22476: 	return (-1);

	or	eax, -1
	pop	ebx
	pop	edi

; 22489: }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlSchemaI:

; 22477:     }
; 22478:     sto->type = type;

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [esi], eax

; 22479:     sto->depth = vctxt->depth;

	mov	eax, DWORD PTR [edi+96]

; 22480:     sto->matcher = matcher;
; 22481:     sto->sel = sel;

	mov	DWORD PTR [esi+28], ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR _matcher$[ebp]
	pop	ebx
	mov	DWORD PTR [esi+24], eax

; 22482:     sto->nbHistory = 0;
; 22483: 
; 22484: #ifdef DEBUG_IDC
; 22485:     xmlGenericError(xmlGenericErrorContext, "IDC:   STO push '%s'\n",
; 22486: 	sto->sel->xpath);
; 22487: #endif
; 22488:     return (0);

	xor	eax, eax
	pop	edi
	mov	DWORD PTR [esi+16], 0

; 22489: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaIDCAddStateObject ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIDCReleaseMatcherList
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_next$1$ = 12						; size = 4
_matcher$ = 12						; size = 4
_xmlSchemaIDCReleaseMatcherList PROC			; COMDAT

; 22367: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _matcher$[ebp]
	test	esi, esi
	je	$LN3@xmlSchemaI
	push	ebx
	push	edi
	npad	5
$LL2@xmlSchemaI:

; 22368:     xmlSchemaIDCMatcherPtr next;
; 22369: 
; 22370:     while (matcher != NULL) {
; 22371: 	next = matcher->next;
; 22372: 	if (matcher->keySeqs != NULL) {

	cmp	DWORD PTR [esi+24], 0
	mov	ebx, DWORD PTR [esi+8]
	mov	DWORD PTR _next$1$[ebp], ebx
	je	SHORT $LN5@xmlSchemaI

; 22373: 	    int i;
; 22374: 	    /*
; 22375: 	    * Don't free the array, but only the content.
; 22376: 	    */
; 22377: 	    for (i = 0; i < matcher->sizeKeySeqs; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+28], edi
	jle	SHORT $LN5@xmlSchemaI
$LL6@xmlSchemaI:

; 22378: 		if (matcher->keySeqs[i] != NULL) {

	mov	eax, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [eax+edi*4]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaI

; 22379: 		    xmlFree(matcher->keySeqs[i]);

	push	eax
	call	DWORD PTR _xmlFree

; 22380: 		    matcher->keySeqs[i] = NULL;

	mov	eax, DWORD PTR [esi+24]
	add	esp, 4
	mov	DWORD PTR [eax+edi*4], 0
$LN4@xmlSchemaI:

; 22373: 	    int i;
; 22374: 	    /*
; 22375: 	    * Don't free the array, but only the content.
; 22376: 	    */
; 22377: 	    for (i = 0; i < matcher->sizeKeySeqs; i++)

	inc	edi
	cmp	edi, DWORD PTR [esi+28]
	jl	SHORT $LL6@xmlSchemaI
$LN5@xmlSchemaI:

; 22381: 		}
; 22382: 	}
; 22383: 	if (matcher->targets) {

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN33@xmlSchemaI

; 22384: 	    if (matcher->idcType == XML_SCHEMA_TYPE_IDC_KEYREF) {

	cmp	DWORD PTR [esi+20], 24			; 00000018H
	mov	edi, eax
	jne	SHORT $LN8@xmlSchemaI

; 22385: 		int i;
; 22386: 		xmlSchemaPSVIIDCNodePtr idcNode;
; 22387: 		/*
; 22388: 		* Node-table items for keyrefs are not stored globally
; 22389: 		* to the validation context, since they are not bubbled.
; 22390: 		* We need to free them here.
; 22391: 		*/
; 22392: 		for (i = 0; i < matcher->targets->nbItems; i++) {

	xor	ebx, ebx
	cmp	DWORD PTR [eax+4], ebx
	jle	SHORT $LN34@xmlSchemaI
	npad	3
$LL9@xmlSchemaI:

; 22393: 		    idcNode =

	mov	eax, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+ebx*4]

; 22394: 			(xmlSchemaPSVIIDCNodePtr) matcher->targets->items[i];
; 22395: 		    xmlFree(idcNode->keys);

	push	DWORD PTR [edi+4]
	call	DWORD PTR _xmlFree

; 22396: 		    xmlFree(idcNode);

	push	edi
	call	DWORD PTR _xmlFree
	mov	edi, DWORD PTR [esi+32]
	inc	ebx
	add	esp, 8
	cmp	ebx, DWORD PTR [edi+4]
	jl	SHORT $LL9@xmlSchemaI
$LN34@xmlSchemaI:

; 3530 :     if (list == NULL)

	mov	ebx, DWORD PTR _next$1$[ebp]
$LN8@xmlSchemaI:
	test	edi, edi
	je	SHORT $LN16@xmlSchemaI

; 3531 : 	return;
; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN18@xmlSchemaI

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN18@xmlSchemaI:

; 3534 :     xmlFree(list);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlSchemaI:

; 22397: 		}
; 22398: 	    }
; 22399: 	    xmlSchemaItemListFree(matcher->targets);
; 22400: 	    matcher->targets = NULL;

	mov	DWORD PTR [esi+32], 0
$LN33@xmlSchemaI:

; 22401: 	}
; 22402: 	matcher->next = NULL;
; 22403: 	/*
; 22404: 	* Cache the matcher.
; 22405: 	*/
; 22406: 	if (vctxt->idcMatcherCache != NULL)

	mov	ecx, DWORD PTR _vctxt$[ebp]
	mov	DWORD PTR [esi+8], 0
	mov	eax, DWORD PTR [ecx+124]
	test	eax, eax
	je	SHORT $LN14@xmlSchemaI

; 22407: 	    matcher->nextCached = vctxt->idcMatcherCache;

	mov	DWORD PTR [esi+12], eax
$LN14@xmlSchemaI:

; 22408: 	vctxt->idcMatcherCache = matcher;

	mov	DWORD PTR [ecx+124], esi

; 22409: 
; 22410: 	matcher = next;

	mov	esi, ebx
	test	ebx, ebx
	jne	$LL2@xmlSchemaI
	pop	edi
	pop	ebx
$LN3@xmlSchemaI:
	pop	esi

; 22411:     }
; 22412: }

	pop	ebp
	ret	0
_xmlSchemaIDCReleaseMatcherList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIDCFreeMatcherList
_TEXT	SEGMENT
_next$1$ = 8						; size = 4
_matcher$ = 8						; size = 4
_xmlSchemaIDCFreeMatcherList PROC			; COMDAT

; 22322: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _matcher$[ebp]
	test	esi, esi
	je	$LN3@xmlSchemaI
	push	ebx
	push	edi
	npad	5
$LL2@xmlSchemaI:

; 22323:     xmlSchemaIDCMatcherPtr next;
; 22324: 
; 22325:     while (matcher != NULL) {
; 22326: 	next = matcher->next;
; 22327: 	if (matcher->keySeqs != NULL) {

	mov	eax, DWORD PTR [esi+24]
	mov	ebx, DWORD PTR [esi+8]
	mov	DWORD PTR _next$1$[ebp], ebx
	test	eax, eax
	je	SHORT $LN10@xmlSchemaI

; 22328: 	    int i;
; 22329: 	    for (i = 0; i < matcher->sizeKeySeqs; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+28], edi
	jle	SHORT $LN5@xmlSchemaI

; 22330: 		if (matcher->keySeqs[i] != NULL)

	mov	edx, eax
$LL6@xmlSchemaI:
	mov	ecx, DWORD PTR [eax+edi*4]
	test	ecx, ecx
	je	SHORT $LN4@xmlSchemaI

; 22331: 		    xmlFree(matcher->keySeqs[i]);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [esi+24]
	add	esp, 4
	mov	edx, eax
$LN4@xmlSchemaI:

; 22328: 	    int i;
; 22329: 	    for (i = 0; i < matcher->sizeKeySeqs; i++)

	inc	edi
	cmp	edi, DWORD PTR [esi+28]
	jl	SHORT $LL6@xmlSchemaI
	mov	eax, edx
$LN5@xmlSchemaI:

; 22332: 	    xmlFree(matcher->keySeqs);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlSchemaI:

; 22333: 	}
; 22334: 	if (matcher->targets != NULL) {

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN15@xmlSchemaI

; 22335: 	    if (matcher->idcType == XML_SCHEMA_TYPE_IDC_KEYREF) {

	cmp	DWORD PTR [esi+20], 24			; 00000018H
	mov	edi, eax
	jne	SHORT $LN8@xmlSchemaI

; 22336: 		int i;
; 22337: 		xmlSchemaPSVIIDCNodePtr idcNode;
; 22338: 		/*
; 22339: 		* Node-table items for keyrefs are not stored globally
; 22340: 		* to the validation context, since they are not bubbled.
; 22341: 		* We need to free them here.
; 22342: 		*/
; 22343: 		for (i = 0; i < matcher->targets->nbItems; i++) {

	xor	ebx, ebx
	cmp	DWORD PTR [eax+4], ebx
	jle	SHORT $LN32@xmlSchemaI
$LL9@xmlSchemaI:

; 22344: 		    idcNode =

	mov	eax, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+ebx*4]

; 22345: 			(xmlSchemaPSVIIDCNodePtr) matcher->targets->items[i];
; 22346: 		    xmlFree(idcNode->keys);

	push	DWORD PTR [edi+4]
	call	DWORD PTR _xmlFree

; 22347: 		    xmlFree(idcNode);

	push	edi
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [esi+32]
	inc	ebx
	add	esp, 8
	cmp	ebx, DWORD PTR [eax+4]
	jl	SHORT $LL9@xmlSchemaI
	mov	edi, eax
$LN32@xmlSchemaI:

; 3530 :     if (list == NULL)

	mov	ebx, DWORD PTR _next$1$[ebp]
$LN8@xmlSchemaI:
	test	edi, edi
	je	SHORT $LN15@xmlSchemaI

; 3531 : 	return;
; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN17@xmlSchemaI

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlSchemaI:

; 3534 :     xmlFree(list);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlSchemaI:

; 22348: 		}
; 22349: 	    }
; 22350: 	    xmlSchemaItemListFree(matcher->targets);
; 22351: 	}
; 22352: 	xmlFree(matcher);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 22353: 	matcher = next;

	mov	esi, ebx
	test	ebx, ebx
	jne	$LL2@xmlSchemaI
	pop	edi
	pop	ebx
$LN3@xmlSchemaI:
	pop	esi

; 22354:     }
; 22355: }

	pop	ebp
	ret	0
_xmlSchemaIDCFreeMatcherList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIDCFreeIDCTable
_TEXT	SEGMENT
_bind$ = 8						; size = 4
_xmlSchemaIDCFreeIDCTable PROC				; COMDAT

; 22304: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _bind$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaI
	push	ebx
	push	edi
$LL2@xmlSchemaI:

; 22308: 	prev = bind;

	mov	edi, esi

; 22309: 	bind = bind->next;

	mov	esi, DWORD PTR [esi]

; 22289:     if (bind->nodeTable != NULL)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN6@xmlSchemaI

; 22290: 	xmlFree(bind->nodeTable);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlSchemaI:

; 22291:     if (bind->dupls != NULL)

	mov	ebx, DWORD PTR [edi+20]
	test	ebx, ebx
	je	SHORT $LN9@xmlSchemaI

; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN11@xmlSchemaI

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlSchemaI:

; 3534 :     xmlFree(list);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlSchemaI:

; 22293:     xmlFree(bind);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 22305:     xmlSchemaPSVIIDCBindingPtr prev;
; 22306: 
; 22307:     while (bind != NULL) {

	test	esi, esi
	jne	SHORT $LL2@xmlSchemaI
	pop	edi
	pop	ebx
$LN3@xmlSchemaI:
	pop	esi

; 22310: 	xmlSchemaIDCFreeBinding(prev);
; 22311:     }
; 22312: }

	pop	ebp
	ret	0
_xmlSchemaIDCFreeIDCTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIDCFreeBinding
_TEXT	SEGMENT
_bind$ = 8						; size = 4
_xmlSchemaIDCFreeBinding PROC				; COMDAT

; 22288: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _bind$[ebp]
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@xmlSchemaI

; 22289:     if (bind->nodeTable != NULL)
; 22290: 	xmlFree(bind->nodeTable);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlSchemaI:

; 22291:     if (bind->dupls != NULL)

	mov	edi, DWORD PTR [esi+20]
	test	edi, edi
	je	SHORT $LN5@xmlSchemaI

; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN7@xmlSchemaI

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlSchemaI:

; 3534 :     xmlFree(list);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlSchemaI:

; 22292: 	xmlSchemaItemListFree(bind->dupls);
; 22293:     xmlFree(bind);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
	pop	esi

; 22294: }

	pop	ebp
	ret	0
_xmlSchemaIDCFreeBinding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIDCFreeKey
_TEXT	SEGMENT
_key$ = 8						; size = 4
_xmlSchemaIDCFreeKey PROC				; COMDAT

; 22274: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _key$[ebp]
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN2@xmlSchemaI

; 22275:     if (key->val != NULL)
; 22276: 	xmlSchemaFreeValue(key->val);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN2@xmlSchemaI:

; 22277:     xmlFree(key);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi

; 22278: }

	pop	ebp
	ret	0
_xmlSchemaIDCFreeKey ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIDCAcquireTargetList
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_matcher$ = 12						; size = 4
_xmlSchemaIDCAcquireTargetList PROC			; COMDAT

; 22260: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _matcher$[ebp]
	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaI

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 3342 :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlSchemaI

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@BAFOADOL@allocating?5an?5item?5list?5structu@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3345 : 	return (NULL);

	xor	eax, eax

; 22261:     if (matcher->targets == NULL)
; 22262: 	matcher->targets = xmlSchemaItemListCreate();

	mov	DWORD PTR [esi+32], eax
	pop	esi

; 22263:     return(matcher->targets);
; 22264: }

	pop	ebp
	ret	0
$LN5@xmlSchemaI:
	xorps	xmm0, xmm0

; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));

	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], 0

; 22261:     if (matcher->targets == NULL)
; 22262: 	matcher->targets = xmlSchemaItemListCreate();

	mov	DWORD PTR [esi+32], eax
$LN2@xmlSchemaI:
	pop	esi

; 22263:     return(matcher->targets);
; 22264: }

	pop	ebp
	ret	0
_xmlSchemaIDCAcquireTargetList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIDCAcquireBinding
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_matcher$ = 12						; size = 4
_xmlSchemaIDCAcquireBinding PROC			; COMDAT

; 22228: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _matcher$[ebp]
	mov	eax, DWORD PTR _vctxt$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [eax+100]
	mov	edi, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+16]
	mov	esi, DWORD PTR [edi+52]
	test	esi, esi
	jne	SHORT $LN5@xmlSchemaI

; 22229:     xmlSchemaNodeInfoPtr ielem;
; 22230: 
; 22231:     ielem = vctxt->elemInfos[matcher->depth];
; 22232: 
; 22233:     if (ielem->idcTable == NULL) {
; 22234: 	ielem->idcTable = xmlSchemaIDCNewBinding(matcher->aidc->def);

	mov	esi, DWORD PTR [ecx+4]

; 22081:     ret = (xmlSchemaPSVIIDCBindingPtr) xmlMalloc(

	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 22082: 	    sizeof(xmlSchemaPSVIIDCBinding));
; 22083:     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN13@xmlSchemaI

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CD@HDBDLPGB@allocating?5a?5PSVI?5IDC?5binding?5i@
	push	eax
	push	eax
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 22086: 	return (NULL);

	xor	eax, eax
	jmp	SHORT $LN12@xmlSchemaI
$LN13@xmlSchemaI:
	xorps	xmm0, xmm0

; 22087:     }
; 22088:     memset(ret, 0, sizeof(xmlSchemaPSVIIDCBinding));

	movups	XMMWORD PTR [eax], xmm0
	movq	QWORD PTR [eax+16], xmm0

; 22089:     ret->definition = idcDef;

	mov	DWORD PTR [eax+4], esi
$LN12@xmlSchemaI:

; 22229:     xmlSchemaNodeInfoPtr ielem;
; 22230: 
; 22231:     ielem = vctxt->elemInfos[matcher->depth];
; 22232: 
; 22233:     if (ielem->idcTable == NULL) {
; 22234: 	ielem->idcTable = xmlSchemaIDCNewBinding(matcher->aidc->def);

	mov	DWORD PTR [edi+52], eax

; 22235: 	if (ielem->idcTable == NULL)

	test	eax, eax
	je	SHORT $LN3@xmlSchemaI

; 22255: }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN5@xmlSchemaI:

; 22236: 	    return (NULL);
; 22237: 	return(ielem->idcTable);
; 22238:     } else {
; 22239: 	xmlSchemaPSVIIDCBindingPtr bind = NULL;
; 22240: 
; 22241: 	bind = ielem->idcTable;
; 22242: 	do {
; 22243: 	    if (bind->definition == matcher->aidc->def)

	mov	ecx, DWORD PTR [ecx+4]
	npad	3
$LL4@xmlSchemaI:
	cmp	DWORD PTR [esi+4], ecx
	je	SHORT $LN19@xmlSchemaI

; 22245: 	    if (bind->next == NULL) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN20@xmlSchemaI

; 22248: 		    return (NULL);
; 22249: 		return(bind->next);
; 22250: 	    }
; 22251: 	    bind = bind->next;

	mov	esi, eax

; 22252: 	} while (bind != NULL);

	test	esi, esi
	jne	SHORT $LL4@xmlSchemaI

; 22255: }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN20@xmlSchemaI:

; 22246: 		bind->next = xmlSchemaIDCNewBinding(matcher->aidc->def);

	push	ecx
	call	_xmlSchemaIDCNewBinding
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 22247: 		if (bind->next == NULL)

	test	eax, eax
	jne	SHORT $LN1@xmlSchemaI
$LN3@xmlSchemaI:
	pop	edi

; 22253:     }
; 22254:     return (NULL);

	xor	eax, eax

; 22255: }

	pop	esi
	pop	ebp
	ret	0
$LN19@xmlSchemaI:

; 22244: 		return(bind);

	mov	eax, esi
$LN1@xmlSchemaI:
	pop	edi

; 22255: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaIDCAcquireBinding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIDCAppendNodeTableItem
_TEXT	SEGMENT
_bind$ = 8						; size = 4
_ntItem$ = 12						; size = 4
_xmlSchemaIDCAppendNodeTableItem PROC			; COMDAT

; 22189: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _bind$[ebp]
	mov	edx, DWORD PTR [esi+8]
	test	edx, edx
	jne	SHORT $LN2@xmlSchemaI

; 22190:     if (bind->nodeTable == NULL) {
; 22191: 	bind->sizeNodes = 10;

	push	40					; 00000028H
	mov	DWORD PTR [esi+16], 10			; 0000000aH

; 22192: 	bind->nodeTable = (xmlSchemaPSVIIDCNodePtr *)

	call	DWORD PTR _xmlMalloc
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR [esi+8], edx

; 22193: 	    xmlMalloc(10 * sizeof(xmlSchemaPSVIIDCNodePtr));
; 22194: 	if (bind->nodeTable == NULL) {

	test	edx, edx
	jne	SHORT $LN6@xmlSchemaI

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CM@BBNGODJA@allocating?5an?5array?5of?5IDC?5node@
$LN14@xmlSchemaI:

; 22212: }

	push	0
	push	0
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN2@xmlSchemaI:

; 22195: 	    xmlSchemaVErrMemory(NULL,
; 22196: 		"allocating an array of IDC node-table items", NULL);
; 22197: 	    return(-1);
; 22198: 	}
; 22199:     } else if (bind->sizeNodes <= bind->nbNodes) {

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, DWORD PTR [esi+12]
	jg	SHORT $LN6@xmlSchemaI

; 22200: 	bind->sizeNodes *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+16], eax

; 22201: 	bind->nodeTable = (xmlSchemaPSVIIDCNodePtr *)

	shl	eax, 2
	push	eax
	push	edx
	call	DWORD PTR _xmlRealloc
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR [esi+8], edx

; 22202: 	    xmlRealloc(bind->nodeTable, bind->sizeNodes *
; 22203: 		sizeof(xmlSchemaPSVIIDCNodePtr));
; 22204: 	if (bind->nodeTable == NULL) {

	test	edx, edx
	jne	SHORT $LN6@xmlSchemaI

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CP@OHLCMMHI@re?9allocating?5an?5array?5of?5IDC?5n@

; 22205: 	    xmlSchemaVErrMemory(NULL,
; 22206: 		"re-allocating an array of IDC node-table items", NULL);
; 22207: 	    return(-1);

	jmp	SHORT $LN14@xmlSchemaI
$LN6@xmlSchemaI:

; 22208: 	}
; 22209:     }
; 22210:     bind->nodeTable[bind->nbNodes++] = ntItem;

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR _ntItem$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	inc	DWORD PTR [esi+12]

; 22211:     return(0);

	xor	eax, eax
	pop	esi

; 22212: }

	pop	ebp
	ret	0
_xmlSchemaIDCAppendNodeTableItem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIDCStoreKey
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_key$ = 12						; size = 4
_xmlSchemaIDCStoreKey PROC				; COMDAT

; 22148: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _vctxt$[ebp]
	mov	edx, DWORD PTR [esi+140]
	test	edx, edx
	jne	SHORT $LN2@xmlSchemaI

; 22149:     /*
; 22150:     * Add to gobal list.
; 22151:     */
; 22152:     if (vctxt->idcKeys == NULL) {
; 22153: 	vctxt->idcKeys = (xmlSchemaPSVIIDCKeyPtr *)

	push	160					; 000000a0H
	call	DWORD PTR _xmlMalloc
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR [esi+140], edx

; 22154: 	    xmlMalloc(40 * sizeof(xmlSchemaPSVIIDCKeyPtr));
; 22155: 	if (vctxt->idcKeys == NULL) {

	test	edx, edx
	jne	SHORT $LN4@xmlSchemaI

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CE@CCLJMNGF@allocating?5the?5IDC?5key?5storage?5@
$LN15@xmlSchemaI:

; 22175: }

	inc	DWORD PTR [esi+56]
	push	0
	push	0
	push	2
	push	17					; 00000011H
	mov	DWORD PTR [esi+52], 1818		; 0000071aH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlSchemaI:

; 22156: 	    xmlSchemaVErrMemory(vctxt,
; 22157: 		"allocating the IDC key storage list", NULL);
; 22158: 	    return (-1);
; 22159: 	}
; 22160: 	vctxt->sizeIdcKeys = 40;

	mov	DWORD PTR [esi+148], 40			; 00000028H
$LN6@xmlSchemaI:

; 22170: 	}
; 22171:     }
; 22172:     vctxt->idcKeys[vctxt->nbIdcKeys++] = key;

	mov	ecx, DWORD PTR [esi+144]
	mov	eax, DWORD PTR _key$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	inc	DWORD PTR [esi+144]

; 22173: 
; 22174:     return (0);

	xor	eax, eax
	pop	esi

; 22175: }

	pop	ebp
	ret	0
$LN2@xmlSchemaI:

; 22161:     } else if (vctxt->sizeIdcKeys <= vctxt->nbIdcKeys) {

	mov	eax, DWORD PTR [esi+148]
	cmp	eax, DWORD PTR [esi+144]
	jg	SHORT $LN6@xmlSchemaI

; 22162: 	vctxt->sizeIdcKeys *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+148], eax

; 22163: 	vctxt->idcKeys = (xmlSchemaPSVIIDCKeyPtr *)

	shl	eax, 2
	push	eax
	push	edx
	call	DWORD PTR _xmlRealloc
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR [esi+140], edx

; 22164: 	    xmlRealloc(vctxt->idcKeys, vctxt->sizeIdcKeys *
; 22165: 	    sizeof(xmlSchemaPSVIIDCKeyPtr));
; 22166: 	if (vctxt->idcKeys == NULL) {

	test	edx, edx
	jne	SHORT $LN6@xmlSchemaI

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CH@OEOHKDEB@re?9allocating?5the?5IDC?5key?5stora@

; 22167: 	    xmlSchemaVErrMemory(vctxt,
; 22168: 		"re-allocating the IDC key storage list", NULL);
; 22169: 	    return (-1);

	jmp	SHORT $LN15@xmlSchemaI
_xmlSchemaIDCStoreKey ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIDCStoreNodeTableItem
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_item$ = 12						; size = 4
_xmlSchemaIDCStoreNodeTableItem PROC			; COMDAT

; 22107: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _vctxt$[ebp]
	mov	edx, DWORD PTR [esi+128]
	test	edx, edx
	jne	SHORT $LN2@xmlSchemaI

; 22108:     /*
; 22109:     * Add to gobal list.
; 22110:     */
; 22111:     if (vctxt->idcNodes == NULL) {
; 22112: 	vctxt->idcNodes = (xmlSchemaPSVIIDCNodePtr *)

	push	80					; 00000050H
	call	DWORD PTR _xmlMalloc
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR [esi+128], edx

; 22113: 	    xmlMalloc(20 * sizeof(xmlSchemaPSVIIDCNodePtr));
; 22114: 	if (vctxt->idcNodes == NULL) {

	test	edx, edx
	jne	SHORT $LN4@xmlSchemaI

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CI@MOGKDPMG@allocating?5the?5IDC?5node?5table?5i@
$LN15@xmlSchemaI:

; 22134: }

	inc	DWORD PTR [esi+56]
	push	0
	push	0
	push	2
	push	17					; 00000011H
	mov	DWORD PTR [esi+52], 1818		; 0000071aH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlSchemaI:

; 22115: 	    xmlSchemaVErrMemory(vctxt,
; 22116: 		"allocating the IDC node table item list", NULL);
; 22117: 	    return (-1);
; 22118: 	}
; 22119: 	vctxt->sizeIdcNodes = 20;

	mov	DWORD PTR [esi+136], 20			; 00000014H
$LN6@xmlSchemaI:

; 22129: 	}
; 22130:     }
; 22131:     vctxt->idcNodes[vctxt->nbIdcNodes++] = item;

	mov	ecx, DWORD PTR [esi+132]
	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	inc	DWORD PTR [esi+132]

; 22132: 
; 22133:     return (0);

	xor	eax, eax
	pop	esi

; 22134: }

	pop	ebp
	ret	0
$LN2@xmlSchemaI:

; 22120:     } else if (vctxt->sizeIdcNodes <= vctxt->nbIdcNodes) {

	mov	eax, DWORD PTR [esi+136]
	cmp	eax, DWORD PTR [esi+132]
	jg	SHORT $LN6@xmlSchemaI

; 22121: 	vctxt->sizeIdcNodes *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+136], eax

; 22122: 	vctxt->idcNodes = (xmlSchemaPSVIIDCNodePtr *)

	shl	eax, 2
	push	eax
	push	edx
	call	DWORD PTR _xmlRealloc
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR [esi+128], edx

; 22123: 	    xmlRealloc(vctxt->idcNodes, vctxt->sizeIdcNodes *
; 22124: 	    sizeof(xmlSchemaPSVIIDCNodePtr));
; 22125: 	if (vctxt->idcNodes == NULL) {

	test	edx, edx
	jne	SHORT $LN6@xmlSchemaI

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CL@PFEMPGNK@re?9allocating?5the?5IDC?5node?5tabl@

; 22126: 	    xmlSchemaVErrMemory(vctxt,
; 22127: 		"re-allocating the IDC node table item list", NULL);
; 22128: 	    return (-1);

	jmp	SHORT $LN15@xmlSchemaI
_xmlSchemaIDCStoreNodeTableItem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIDCNewBinding
_TEXT	SEGMENT
_idcDef$ = 8						; size = 4
_xmlSchemaIDCNewBinding PROC				; COMDAT

; 22078: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	test	ecx, ecx
	jne	SHORT $LN2@xmlSchemaI

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CD@HDBDLPGB@allocating?5a?5PSVI?5IDC?5binding?5i@
	push	eax
	push	eax
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 22079:     xmlSchemaPSVIIDCBindingPtr ret;
; 22080: 
; 22081:     ret = (xmlSchemaPSVIIDCBindingPtr) xmlMalloc(
; 22082: 	    sizeof(xmlSchemaPSVIIDCBinding));
; 22083:     if (ret == NULL) {
; 22084: 	xmlSchemaVErrMemory(NULL,
; 22085: 	    "allocating a PSVI IDC binding item", NULL);
; 22086: 	return (NULL);

	xor	eax, eax

; 22091: }

	pop	ebp
	ret	0
$LN2@xmlSchemaI:

; 22087:     }
; 22088:     memset(ret, 0, sizeof(xmlSchemaPSVIIDCBinding));
; 22089:     ret->definition = idcDef;

	mov	eax, DWORD PTR _idcDef$[ebp]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [ecx], xmm0
	movq	QWORD PTR [ecx+16], xmm0
	mov	DWORD PTR [ecx+4], eax

; 22090:     return (ret);

	mov	eax, ecx

; 22091: }

	pop	ebp
	ret	0
_xmlSchemaIDCNewBinding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAugmentImportedIDC
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlSchemaAugmentImportedIDC PROC			; COMDAT

; 22060:                             const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _payload$[ebp]
	mov	eax, DWORD PTR [eax+52]
	mov	eax, DWORD PTR [eax+76]
	test	eax, eax
	je	SHORT $LN2@xmlSchemaA

; 22061:     xmlSchemaImportPtr imported = (xmlSchemaImportPtr) payload;
; 22062:     xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) data;
; 22063:     if (imported->schema->idcDef != NULL) {
; 22064: 	    xmlHashScan(imported->schema->idcDef, xmlSchemaAugmentIDC, vctxt);

	push	DWORD PTR _data$[ebp]
	push	OFFSET _xmlSchemaAugmentIDC
	push	eax
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN2@xmlSchemaA:

; 22065:     }
; 22066: }

	pop	ebp
	ret	0
_xmlSchemaAugmentImportedIDC ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAugmentIDC
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlSchemaAugmentIDC PROC				; COMDAT

; 22023: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaA

; 2006 :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _data$[ebp]
	test	eax, eax
	je	SHORT $LN8@xmlSchemaA

; 2007 :         ctxt->nberrors++;

	inc	DWORD PTR [eax+56]

; 2008 :         ctxt->err = XML_SCHEMAV_INTERNAL;

	mov	DWORD PTR [eax+52], 1818		; 0000071aH
$LN8@xmlSchemaA:

; 2009 :     }
; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0DM@CAHAFNJE@xmlSchemaAugmentIDC?3?5allocating@
	push	0
	push	0
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 22050: }

	pop	ebp
	ret	0
$LN2@xmlSchemaA:

; 22024:     xmlSchemaIDCPtr idcDef = (xmlSchemaIDCPtr) payload;
; 22025:     xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) data;
; 22026:     xmlSchemaIDCAugPtr aidc;
; 22027: 
; 22028:     aidc = (xmlSchemaIDCAugPtr) xmlMalloc(sizeof(xmlSchemaIDCAug));
; 22029:     if (aidc == NULL) {
; 22030: 	xmlSchemaVErrMemory(vctxt,
; 22031: 	    "xmlSchemaAugmentIDC: allocating an augmented IDC definition",
; 22032: 	    NULL);
; 22033: 	return;
; 22034:     }
; 22035:     aidc->keyrefDepth = -1;
; 22036:     aidc->def = idcDef;
; 22037:     aidc->next = NULL;
; 22038:     if (vctxt->aidcs == NULL)

	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR _payload$[ebp]
	push	esi
	mov	DWORD PTR [eax+8], -1
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], 0
	mov	esi, DWORD PTR [ecx+112]
	test	esi, esi
	je	SHORT $LN4@xmlSchemaA

; 22039: 	vctxt->aidcs = aidc;
; 22040:     else {
; 22041: 	aidc->next = vctxt->aidcs;

	mov	DWORD PTR [eax], esi
$LN4@xmlSchemaA:

; 22042: 	vctxt->aidcs = aidc;
; 22043:     }
; 22044:     /*
; 22045:     * Save if we have keyrefs at all.
; 22046:     */
; 22047:     if ((vctxt->hasKeyrefs == 0) &&

	mov	DWORD PTR [ecx+112], eax
	cmp	DWORD PTR [ecx+184], 0
	pop	esi
	jne	SHORT $LN5@xmlSchemaA
	cmp	DWORD PTR [edx], 24			; 00000018H
	jne	SHORT $LN5@xmlSchemaA

; 22048: 	(idcDef->type == XML_SCHEMA_TYPE_IDC_KEYREF))
; 22049: 	vctxt->hasKeyrefs = 1;

	mov	DWORD PTR [ecx+184], 1
$LN5@xmlSchemaA:

; 22050: }

	pop	ebp
	ret	0
_xmlSchemaAugmentIDC ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaVAddNodeQName
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_lname$1$ = 12						; size = 4
_lname$ = 12						; size = 4
_nsname$ = 16						; size = 4
_xmlSchemaVAddNodeQName PROC				; COMDAT

; 21982: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _vctxt$[ebp]
	push	-1
	push	DWORD PTR _lname$[ebp]
	push	DWORD PTR [ebx+156]
	call	_xmlDictLookup
	mov	edx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lname$1$[ebp], edx
	test	edx, edx
	je	$LN28@xmlSchemaV

; 21983:     int i;
; 21984: 
; 21985:     lname = xmlDictLookup(vctxt->dict, lname, -1);
; 21986:     if (lname == NULL)
; 21987: 	return(-1);
; 21988:     if (nsname != NULL) {

	mov	edi, DWORD PTR _nsname$[ebp]
	test	edi, edi
	je	SHORT $LN7@xmlSchemaV

; 21989: 	nsname = xmlDictLookup(vctxt->dict, nsname, -1);

	push	-1
	push	edi
	push	DWORD PTR [ebx+156]
	call	_xmlDictLookup
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 21990: 	if (nsname == NULL)

	test	edi, edi
	je	$LN28@xmlSchemaV
	mov	edx, DWORD PTR _lname$1$[ebp]
$LN7@xmlSchemaV:
	push	esi

; 21992:     }
; 21993:     for (i = 0; i < vctxt->nodeQNames->nbItems; i += 2) {

	mov	esi, DWORD PTR [ebx+180]
	xor	eax, eax
	mov	ebx, DWORD PTR [esi+4]
	test	ebx, ebx
	jle	SHORT $LN29@xmlSchemaV

; 21994: 	if ((vctxt->nodeQNames->items [i] == lname) &&

	mov	ecx, DWORD PTR [esi]
	npad	7
$LL4@xmlSchemaV:
	cmp	DWORD PTR [ecx+eax*4], edx
	jne	SHORT $LN2@xmlSchemaV
	cmp	DWORD PTR [ecx+eax*4+4], edi
	je	SHORT $LN30@xmlSchemaV
$LN2@xmlSchemaV:

; 21992:     }
; 21993:     for (i = 0; i < vctxt->nodeQNames->nbItems; i += 2) {

	add	eax, 2
	cmp	eax, ebx
	jl	SHORT $LL4@xmlSchemaV
$LN29@xmlSchemaV:

; 3365 :     if (list->items == NULL) {

	mov	edx, DWORD PTR [esi]
	test	edx, edx
	jne	SHORT $LN11@xmlSchemaV

; 3366 : 	list->items = (void **) xmlMalloc(

	push	80					; 00000050H
	call	DWORD PTR _xmlMalloc
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR [esi], edx

; 3367 : 	    20 * sizeof(void *));
; 3368 : 	if (list->items == NULL) {

	test	edx, edx
	jne	SHORT $LN13@xmlSchemaV

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BJ@JABJNCPJ@allocating?5new?5item?5list@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3370 : 	    return(-1);

	jmp	SHORT $LN10@xmlSchemaV
$LN13@xmlSchemaV:

; 3371 : 	}
; 3372 : 	list->sizeItems = 20;

	mov	DWORD PTR [esi+8], 20			; 00000014H
$LN15@xmlSchemaV:

; 3381 : 	}
; 3382 :     }
; 3383 :     list->items[list->nbItems++] = item;

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR _lname$1$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	inc	DWORD PTR [esi+4]
$LN10@xmlSchemaV:

; 21995: 	    (vctxt->nodeQNames->items[i +1] == nsname))
; 21996: 	    /* Already there */
; 21997: 	    return(i);
; 21998:     }
; 21999:     /* Add new entry. */
; 22000:     i = vctxt->nodeQNames->nbItems;
; 22001:     xmlSchemaItemListAdd(vctxt->nodeQNames, (void *) lname);
; 22002:     xmlSchemaItemListAdd(vctxt->nodeQNames, (void *) nsname);

	mov	eax, DWORD PTR _vctxt$[ebp]
	push	edi
	push	DWORD PTR [eax+180]
	call	_xmlSchemaItemListAdd
	add	esp, 8

; 22003:     return(i);

	mov	eax, ebx
$LN30@xmlSchemaV:

; 22004: }

	pop	esi
	pop	edi
	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlSchemaV:

; 3373 :     } else if (list->sizeItems <= list->nbItems) {

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, ebx
	jg	SHORT $LN15@xmlSchemaV

; 3374 : 	list->sizeItems *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+8], eax

; 3375 : 	list->items = (void **) xmlRealloc(list->items,

	shl	eax, 2
	push	eax
	push	edx
	call	DWORD PTR _xmlRealloc
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR [esi], edx

; 3376 : 	    list->sizeItems * sizeof(void *));
; 3377 : 	if (list->items == NULL) {

	test	edx, edx
	jne	SHORT $LN15@xmlSchemaV

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BC@PKMEEMHP@growing?5item?5list@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3379 : 	    list->sizeItems = 0;

	mov	DWORD PTR [esi+8], 0

; 3380 : 	    return(-1);

	jmp	SHORT $LN10@xmlSchemaV
$LN28@xmlSchemaV:
	pop	edi

; 21991: 	    return(-1);

	or	eax, -1

; 22004: }

	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaVAddNodeQName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidateNotation
_TEXT	SEGMENT
_prefix$1 = 8						; size = 4
_vctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_value$ = 20						; size = 4
_val$ = 24						; size = 4
_valNeeded$ = 28					; size = 4
_xmlSchemaValidateNotation PROC				; COMDAT

; 21917: {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _vctxt$[ebp]
	test	edi, edi
	je	SHORT $LN2@xmlSchemaV

; 21918:     int ret;
; 21919: 
; 21920:     if (vctxt && (vctxt->schema == NULL)) {

	cmp	DWORD PTR [edi+20], 0
	jne	SHORT $LN2@xmlSchemaV

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CN@LAHJCGKC@a?5schema?5is?5needed?5on?5the?5valid@
	push	OFFSET ??_C@_0BK@IMJIJGNM@xmlSchemaValidateNotation@
	push	edi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 21921: 	VERROR_INT("xmlSchemaValidateNotation",
; 21922: 	    "a schema is needed on the validation context");
; 21923: 	return (-1);

	or	eax, -1
	pop	edi

; 21976: }

	pop	ebp
	ret	0
$LN2@xmlSchemaV:
	push	ebx

; 21924:     }
; 21925:     ret = xmlValidateQName(value, 1);

	mov	ebx, DWORD PTR _value$[ebp]
	push	esi
	push	1
	push	ebx
	call	_xmlValidateQName
	mov	esi, eax
	add	esp, 8

; 21926:     if (ret != 0)

	test	esi, esi
	jne	$LN24@xmlSchemaV

; 21927: 	return (ret);
; 21928:     {
; 21929: 	xmlChar *localName = NULL;
; 21930: 	xmlChar *prefix = NULL;

	mov	DWORD PTR _prefix$1[ebp], eax

; 21931: 
; 21932: 	localName = xmlSplitQName2(value, &prefix);

	lea	eax, DWORD PTR _prefix$1[ebp]
	push	eax
	push	ebx
	call	_xmlSplitQName2
	mov	ebx, eax
	add	esp, 8

; 21933: 	if (prefix != NULL) {

	mov	eax, DWORD PTR _prefix$1[ebp]
	test	eax, eax
	je	$LN4@xmlSchemaV

; 21934: 	    const xmlChar *nsName = NULL;
; 21935: 
; 21936: 	    if (vctxt != NULL)

	push	eax
	test	edi, edi
	je	SHORT $LN6@xmlSchemaV

; 21937: 		nsName = xmlSchemaLookupNamespace(vctxt, BAD_CAST prefix);

	push	edi
	call	_xmlSchemaLookupNamespace
	add	esp, 8
	mov	edi, eax
	jmp	SHORT $LN10@xmlSchemaV
$LN6@xmlSchemaV:

; 21938: 	    else if (node != NULL) {

	mov	ecx, DWORD PTR _node$[ebp]
	test	ecx, ecx
	je	$LN8@xmlSchemaV

; 21939: 		xmlNsPtr ns = xmlSearchNs(node->doc, node, prefix);

	push	ecx
	push	DWORD PTR [ecx+32]
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH

; 21940: 		if (ns != NULL)

	test	eax, eax
	je	SHORT $LN23@xmlSchemaV

; 21941: 		    nsName = ns->href;

	mov	edi, DWORD PTR [eax+8]
$LN10@xmlSchemaV:

; 21942: 	    } else {
; 21943: 		xmlFree(prefix);
; 21944: 		xmlFree(localName);
; 21945: 		return (1);
; 21946: 	    }
; 21947: 	    if (nsName == NULL) {

	test	edi, edi
	je	SHORT $LN23@xmlSchemaV

; 21949: 		xmlFree(localName);
; 21950: 		return (1);
; 21951: 	    }
; 21952: 	    if (xmlSchemaGetNotation(schema, localName, nsName) != NULL) {

	push	edi
	push	ebx
	push	DWORD PTR _schema$[ebp]
	call	_xmlSchemaGetNotation
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN12@xmlSchemaV

; 21953: 		if ((valNeeded) && (val != NULL)) {

	cmp	DWORD PTR _valNeeded$[ebp], 0
	je	SHORT $LN13@xmlSchemaV
	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN13@xmlSchemaV

; 21954: 		    (*val) = xmlSchemaNewNOTATIONValue(xmlStrdup(localName),

	push	edi
	call	_xmlStrdup
	add	esp, 4
	push	eax
	push	ebx
	call	_xmlStrdup
	add	esp, 4
	push	eax
	call	_xmlSchemaNewNOTATIONValue
	mov	ecx, DWORD PTR _val$[ebp]
	add	esp, 8
	mov	DWORD PTR [ecx], eax

; 21955: 						       xmlStrdup(nsName));
; 21956: 		    if (*val == NULL)

	test	eax, eax
	jne	SHORT $LN13@xmlSchemaV

; 21957: 			ret = -1;

	or	esi, -1

; 21958: 		}
; 21959: 	    } else

	jmp	SHORT $LN13@xmlSchemaV
$LN12@xmlSchemaV:

; 21960: 		ret = 1;

	mov	esi, 1
$LN13@xmlSchemaV:

; 21961: 	    xmlFree(prefix);

	push	DWORD PTR _prefix$1[ebp]
	call	DWORD PTR _xmlFree

; 21962: 	    xmlFree(localName);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 8

; 21973: 	}
; 21974:     }
; 21975:     return (ret);

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 21976: }

	pop	ebp
	ret	0
$LN23@xmlSchemaV:

; 21948: 		xmlFree(prefix);

	push	DWORD PTR _prefix$1[ebp]
$LN8@xmlSchemaV:

; 21969: 			ret = -1;
; 21970: 		}
; 21971: 	    } else
; 21972: 		return (1);

	call	DWORD PTR _xmlFree
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 8
$LN16@xmlSchemaV:
	mov	eax, 1
$LN24@xmlSchemaV:
	pop	esi
	pop	ebx
	pop	edi

; 21976: }

	pop	ebp
	ret	0
$LN4@xmlSchemaV:

; 21963: 	} else {
; 21964: 	    if (xmlSchemaGetNotation(schema, value, NULL) != NULL) {

	mov	edi, DWORD PTR _value$[ebp]
	push	0
	push	edi
	push	DWORD PTR _schema$[ebp]
	call	_xmlSchemaGetNotation
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN16@xmlSchemaV

; 21965: 		if (valNeeded && (val != NULL)) {

	cmp	DWORD PTR _valNeeded$[ebp], 0
	je	SHORT $LN19@xmlSchemaV
	mov	ebx, DWORD PTR _val$[ebp]
	test	ebx, ebx
	je	SHORT $LN19@xmlSchemaV

; 21966: 		    (*val) = xmlSchemaNewNOTATIONValue(

	push	0
	push	edi
	call	_xmlStrdup
	add	esp, 4
	push	eax
	call	_xmlSchemaNewNOTATIONValue

; 21967: 			BAD_CAST xmlStrdup(value), NULL);
; 21968: 		    if (*val == NULL)

	or	ecx, -1
	mov	DWORD PTR [ebx], eax
	add	esp, 8
	test	eax, eax
	cmove	esi, ecx
$LN19@xmlSchemaV:

; 21973: 	}
; 21974:     }
; 21975:     return (ret);

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 21976: }

	pop	ebp
	ret	0
_xmlSchemaValidateNotation ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaLookupNamespace
_TEXT	SEGMENT
_i$1$ = -4						; size = 4
_vctxt$ = 8						; size = 4
_prefix$ = 12						; size = 4
_xmlSchemaLookupNamespace PROC				; COMDAT

; 21852: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _vctxt$[ebp]
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN8@xmlSchemaL

; 21853:     if (vctxt->sax != NULL) {
; 21854: 	int i, j;
; 21855: 	xmlSchemaNodeInfoPtr inode;
; 21856: 
; 21857: 	for (i = vctxt->depth; i >= 0; i--) {

	mov	ecx, DWORD PTR [esi+96]
	mov	DWORD PTR _i$1$[ebp], ecx
	test	ecx, ecx
	js	$LN20@xmlSchemaL
	mov	ebx, DWORD PTR _prefix$[ebp]
	npad	5
$LL4@xmlSchemaL:

; 21858: 	    if (vctxt->elemInfos[i]->nbNsBindings != 0) {

	mov	eax, DWORD PTR [esi+100]
	mov	edi, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edi+68]
	test	eax, eax
	je	SHORT $LN2@xmlSchemaL

; 21859: 		inode = vctxt->elemInfos[i];
; 21860: 		for (j = 0; j < inode->nbNsBindings * 2; j += 2) {

	add	eax, eax
	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN37@xmlSchemaL
$LL7@xmlSchemaL:

; 21861: 		    if (((prefix == NULL) &&
; 21862: 			    (inode->nsBindings[j] == NULL)) ||

	mov	eax, DWORD PTR [edi+64]
	test	ebx, ebx
	jne	SHORT $LN34@xmlSchemaL
	cmp	DWORD PTR [eax+esi*4], ebx
	jne	SHORT $LN5@xmlSchemaL
$LN35@xmlSchemaL:

; 21863: 			((prefix != NULL) && xmlStrEqual(prefix,
; 21864: 			    inode->nsBindings[j]))) {
; 21865: 
; 21866: 			/*
; 21867: 			* Note that the namespace bindings are already
; 21868: 			* in a string dict.
; 21869: 			*/
; 21870: 			return (inode->nsBindings[j+1]);

	mov	eax, DWORD PTR [edi+64]
	pop	edi
	mov	eax, DWORD PTR [eax+esi*4+4]

; 21903: 	return (NULL);
; 21904:     }
; 21905: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xmlSchemaL:

; 21861: 		    if (((prefix == NULL) &&
; 21862: 			    (inode->nsBindings[j] == NULL)) ||

	push	DWORD PTR [eax+esi*4]
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN35@xmlSchemaL
$LN5@xmlSchemaL:

; 21859: 		inode = vctxt->elemInfos[i];
; 21860: 		for (j = 0; j < inode->nbNsBindings * 2; j += 2) {

	mov	eax, DWORD PTR [edi+68]
	add	esi, 2
	add	eax, eax
	cmp	esi, eax
	jl	SHORT $LL7@xmlSchemaL
	mov	ecx, DWORD PTR _i$1$[ebp]
$LN37@xmlSchemaL:

; 21853:     if (vctxt->sax != NULL) {
; 21854: 	int i, j;
; 21855: 	xmlSchemaNodeInfoPtr inode;
; 21856: 
; 21857: 	for (i = vctxt->depth; i >= 0; i--) {

	mov	esi, DWORD PTR _vctxt$[ebp]
$LN2@xmlSchemaL:
	sub	ecx, 1
	mov	DWORD PTR _i$1$[ebp], ecx
	jns	SHORT $LL4@xmlSchemaL

; 21903: 	return (NULL);
; 21904:     }
; 21905: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlSchemaL:

; 21871: 		    }
; 21872: 		}
; 21873: 	    }
; 21874: 	}
; 21875: 	return (NULL);
; 21876: #ifdef LIBXML_READER_ENABLED
; 21877:     } else if (vctxt->reader != NULL) {

	mov	eax, DWORD PTR [esi+160]
	test	eax, eax
	je	SHORT $LN14@xmlSchemaL

; 21878: 	xmlChar *nsName;
; 21879: 
; 21880: 	nsName = xmlTextReaderLookupNamespace(vctxt->reader, prefix);

	push	DWORD PTR _prefix$[ebp]
	push	eax
	call	_xmlTextReaderLookupNamespace
	mov	edi, eax
	add	esp, 8

; 21881: 	if (nsName != NULL) {

	test	edi, edi
	je	SHORT $LN20@xmlSchemaL

; 21882: 	    const xmlChar *ret;
; 21883: 
; 21884: 	    ret = xmlDictLookup(vctxt->dict, nsName, -1);

	push	-1
	push	edi
	push	DWORD PTR [esi+156]
	call	_xmlDictLookup

; 21885: 	    xmlFree(nsName);

	push	edi
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H

; 21886: 	    return (ret);

	mov	eax, esi
	pop	edi

; 21903: 	return (NULL);
; 21904:     }
; 21905: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlSchemaL:

; 21887: 	} else
; 21888: 	    return (NULL);
; 21889: #endif
; 21890:     } else {
; 21891: 	xmlNsPtr ns;
; 21892: 
; 21893: 	if ((vctxt->inode->node == NULL) ||

	mov	eax, DWORD PTR [esi+108]
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN19@xmlSchemaL
	mov	ecx, DWORD PTR [eax+32]
	test	ecx, ecx
	je	SHORT $LN19@xmlSchemaL

; 21894: 	    (vctxt->inode->node->doc == NULL)) {
; 21895: 	    VERROR_INT("xmlSchemaLookupNamespace",
; 21896: 		"no node or node's doc avaliable");
; 21897: 	    return (NULL);
; 21898: 	}
; 21899: 	ns = xmlSearchNs(vctxt->inode->node->doc,

	push	DWORD PTR _prefix$[ebp]
	push	eax
	push	ecx
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH

; 21900: 	    vctxt->inode->node, prefix);
; 21901: 	if (ns != NULL)

	test	eax, eax
	je	SHORT $LN20@xmlSchemaL

; 21902: 	    return (ns->href);

	mov	eax, DWORD PTR [eax+8]
	pop	edi

; 21903: 	return (NULL);
; 21904:     }
; 21905: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlSchemaL:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CA@LAIFBHAE@no?5node?5or?5node?8s?5doc?5avaliable@
	push	OFFSET ??_C@_0BJ@NLHBOILD@xmlSchemaLookupNamespace@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$LN20@xmlSchemaL:
	pop	edi

; 21903: 	return (NULL);
; 21904:     }
; 21905: }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaLookupNamespace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAssembleByXSI
_TEXT	SEGMENT
_ret$1$ = -8						; size = 4
_iattr$1$ = -4						; size = 4
_vctxt$ = 8						; size = 4
_xmlSchemaAssembleByXSI PROC				; COMDAT

; 21770: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _vctxt$[ebp]
	xor	eax, eax
	push	3
	push	esi
	xor	ebx, ebx
	mov	DWORD PTR _ret$1$[ebp], eax
	call	_xmlSchemaGetMetaAttrInfo
	add	esp, 8
	mov	DWORD PTR _iattr$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LN14@xmlSchemaA

; 21771:     const xmlChar *cur, *end;
; 21772:     const xmlChar *nsname = NULL, *location;
; 21773:     int count = 0;
; 21774:     int ret = 0;
; 21775:     xmlSchemaAttrInfoPtr iattr;
; 21776: 
; 21777:     /*
; 21778:     * Parse the value; we will assume an even number of values
; 21779:     * to be given (this is how Xerces and XSV work).
; 21780:     *
; 21781:     * URGENT TODO: !! This needs to work for both
; 21782:     * @noNamespaceSchemaLocation AND @schemaLocation on the same
; 21783:     * element !!
; 21784:     */
; 21785:     iattr = xmlSchemaGetMetaAttrInfo(vctxt,
; 21786: 	XML_SCHEMA_ATTR_INFO_META_XSI_SCHEMA_LOC);
; 21787:     if (iattr == NULL)
; 21788: 	iattr = xmlSchemaGetMetaAttrInfo(vctxt,

	push	4
	push	esi
	call	_xmlSchemaGetMetaAttrInfo
	add	esp, 8
	mov	DWORD PTR _iattr$1$[ebp], eax

; 21789: 	XML_SCHEMA_ATTR_INFO_META_XSI_NO_NS_SCHEMA_LOC);
; 21790:     if (iattr == NULL)

	test	eax, eax
	jne	SHORT $LN14@xmlSchemaA

; 21847: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlSchemaA:

; 21791: 	return (0);
; 21792:     cur = iattr->value;

	mov	esi, DWORD PTR [eax+20]
	push	edi
	npad	6
$LL4@xmlSchemaA:

; 21793:     do {
; 21794: 	/*
; 21795: 	* TODO: Move the string parsing mechanism away from here.
; 21796: 	*/
; 21797: 	if (iattr->metaType == XML_SCHEMA_ATTR_INFO_META_XSI_SCHEMA_LOC) {

	cmp	DWORD PTR [eax+48], 3
	jne	SHORT $LL9@xmlSchemaA
$LL5@xmlSchemaA:

; 21798: 	    /*
; 21799: 	    * Get the namespace name.
; 21800: 	    */
; 21801: 	    while (IS_BLANK_CH(*cur))

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN16@xmlSchemaA
	cmp	al, 9
	jb	SHORT $LN17@xmlSchemaA
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN16@xmlSchemaA
$LN17@xmlSchemaA:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN6@xmlSchemaA
$LN16@xmlSchemaA:

; 21802: 		cur++;

	inc	esi
	jmp	SHORT $LL5@xmlSchemaA
$LN6@xmlSchemaA:

; 21803: 	    end = cur;

	mov	edi, esi

; 21804: 	    while ((*end != 0) && (!(IS_BLANK_CH(*end))))

	test	al, al
	je	$LN3@xmlSchemaA
$LL7@xmlSchemaA:
	cmp	al, 32					; 00000020H
	je	SHORT $LN8@xmlSchemaA
	cmp	al, 9
	jb	SHORT $LN18@xmlSchemaA
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN8@xmlSchemaA
$LN18@xmlSchemaA:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN8@xmlSchemaA
	mov	al, BYTE PTR [edi+1]

; 21805: 		end++;

	inc	edi
	test	al, al
	jne	SHORT $LL7@xmlSchemaA
$LN8@xmlSchemaA:

; 21806: 	    if (end == cur)

	cmp	edi, esi
	je	$LN3@xmlSchemaA

; 21807: 		break;
; 21808: 	    count++; /* TODO: Don't use the schema's dict. */
; 21809: 	    nsname = xmlDictLookup(vctxt->schema->dict, cur, end - cur);

	mov	eax, edi
	sub	eax, esi
	push	eax
	mov	eax, DWORD PTR _vctxt$[ebp]
	push	esi
	mov	eax, DWORD PTR [eax+20]
	push	DWORD PTR [eax+60]
	call	_xmlDictLookup
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _iattr$1$[ebp]

; 21810: 	    cur = end;

	mov	esi, edi
$LL9@xmlSchemaA:

; 21811: 	}
; 21812: 	/*
; 21813: 	* Get the URI.
; 21814: 	*/
; 21815: 	while (IS_BLANK_CH(*cur))

	mov	cl, BYTE PTR [esi]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN20@xmlSchemaA
	cmp	cl, 9
	jb	SHORT $LN21@xmlSchemaA
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN20@xmlSchemaA
$LN21@xmlSchemaA:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN10@xmlSchemaA
$LN20@xmlSchemaA:

; 21816: 	    cur++;

	inc	esi
	jmp	SHORT $LL9@xmlSchemaA
$LN10@xmlSchemaA:

; 21817: 	end = cur;

	mov	edi, esi

; 21818: 	while ((*end != 0) && (!(IS_BLANK_CH(*end))))

	test	cl, cl
	je	$LN37@xmlSchemaA
$LL11@xmlSchemaA:
	cmp	cl, 32					; 00000020H
	je	SHORT $LN12@xmlSchemaA
	cmp	cl, 9
	jb	SHORT $LN22@xmlSchemaA
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN12@xmlSchemaA
$LN22@xmlSchemaA:
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN12@xmlSchemaA
	mov	cl, BYTE PTR [edi+1]

; 21819: 	    end++;

	inc	edi
	test	cl, cl
	jne	SHORT $LL11@xmlSchemaA
$LN12@xmlSchemaA:

; 21820: 	if (end == cur) {

	cmp	edi, esi
	je	SHORT $LN37@xmlSchemaA

; 21829: 		    iattr->node, NULL,
; 21830: 		    "The value must consist of tuples: the target namespace "
; 21831: 		    "name and the document's URI", NULL, NULL, NULL);
; 21832: 	    }
; 21833: 	    break;
; 21834: 	}
; 21835: 	count++; /* TODO: Don't use the schema's dict. */
; 21836: 	location = xmlDictLookup(vctxt->schema->dict, cur, end - cur);

	mov	eax, edi
	sub	eax, esi
	push	eax
	mov	eax, DWORD PTR _vctxt$[ebp]
	push	esi
	mov	eax, DWORD PTR [eax+20]
	push	DWORD PTR [eax+60]
	call	_xmlDictLookup

; 21837: 	cur = end;
; 21838: 	ret = xmlSchemaAssembleByLocation(vctxt, vctxt->schema,

	push	eax
	mov	eax, DWORD PTR _iattr$1$[ebp]
	mov	esi, edi
	push	ebx
	push	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _vctxt$[ebp]
	push	DWORD PTR [eax+20]
	push	eax
	call	_xmlSchemaAssembleByLocation
	mov	ecx, eax
	add	esp, 32					; 00000020H
	mov	DWORD PTR _ret$1$[ebp], ecx

; 21839: 	    iattr->node, nsname, location);
; 21840: 	if (ret == -1) {

	cmp	ecx, -1
	je	SHORT $LN38@xmlSchemaA

; 21844: 	}
; 21845:     } while (*cur != 0);

	cmp	BYTE PTR [edi], 0
	je	SHORT $LN3@xmlSchemaA

; 21846:     return (ret);

	mov	eax, DWORD PTR _iattr$1$[ebp]
	jmp	$LL4@xmlSchemaA
$LN38@xmlSchemaA:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BE@HNFEMNKO@assembling?5schemata@
	push	OFFSET ??_C@_0BH@DHODCNOI@xmlSchemaAssembleByXSI@
	push	DWORD PTR _vctxt$[ebp]
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 21841: 	    VERROR_INT("xmlSchemaAssembleByXSI",
; 21842: 		"assembling schemata");
; 21843: 	    return (-1);

	or	eax, -1
	pop	edi
	pop	esi

; 21847: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@xmlSchemaA:

; 21821: 	    if (iattr->metaType ==

	cmp	DWORD PTR [eax+48], 3
	jne	SHORT $LN3@xmlSchemaA

; 21822: 		XML_SCHEMA_ATTR_INFO_META_XSI_SCHEMA_LOC)
; 21823: 	    {
; 21824: 		/*
; 21825: 		* If using @schemaLocation then tuples are expected.
; 21826: 		* I.e. the namespace name *and* the document's URI.
; 21827: 		*/
; 21828: 		xmlSchemaCustomWarning(ACTXT_CAST vctxt, XML_SCHEMAV_MISC,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0FD@KDOLAGPK@The?5value?5must?5consist?5of?5tuple@
	push	0
	push	DWORD PTR [eax+4]
	push	1879					; 00000757H
	push	DWORD PTR _vctxt$[ebp]
	call	_xmlSchemaCustomWarning
	add	esp, 32					; 00000020H
$LN3@xmlSchemaA:

; 21846:     return (ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi
	pop	esi

; 21847: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaAssembleByXSI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetMetaAttrInfo
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_metaType$ = 12						; size = 4
_xmlSchemaGetMetaAttrInfo PROC				; COMDAT

; 21739: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _vctxt$[ebp]
	mov	esi, DWORD PTR [ecx+168]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaG

; 21740:     if (vctxt->nbAttrInfos == 0)
; 21741: 	return (NULL);
; 21742:     {
; 21743: 	int i;
; 21744: 	xmlSchemaAttrInfoPtr iattr;
; 21745: 
; 21746: 	for (i = 0; i < vctxt->nbAttrInfos; i++) {

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN3@xmlSchemaG

; 21747: 	    iattr = vctxt->attrInfos[i];

	mov	ecx, DWORD PTR [ecx+164]
	mov	edi, DWORD PTR _metaType$[ebp]
	npad	5
$LL4@xmlSchemaG:
	mov	edx, DWORD PTR [ecx]

; 21748: 	    if (iattr->metaType == metaType)

	cmp	DWORD PTR [edx+48], edi
	je	SHORT $LN9@xmlSchemaG

; 21740:     if (vctxt->nbAttrInfos == 0)
; 21741: 	return (NULL);
; 21742:     {
; 21743: 	int i;
; 21744: 	xmlSchemaAttrInfoPtr iattr;
; 21745: 
; 21746: 	for (i = 0; i < vctxt->nbAttrInfos; i++) {

	inc	eax
	add	ecx, 4
	cmp	eax, esi
	jl	SHORT $LL4@xmlSchemaG
$LN3@xmlSchemaG:
	pop	edi

; 21750: 	}
; 21751: 
; 21752:     }
; 21753:     return (NULL);

	xor	eax, eax

; 21754: }

	pop	esi
	pop	ebp
	ret	0
$LN9@xmlSchemaG:
	pop	edi

; 21749: 		return (iattr);

	mov	eax, edx

; 21754: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaGetMetaAttrInfo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAssembleByLocation
_TEXT	SEGMENT
_bucket$ = -4						; size = 4
_location$1$ = 8					; size = 4
_vctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_nsName$ = 20						; size = 4
_location$ = 24						; size = 4
_xmlSchemaAssembleByLocation PROC			; COMDAT

; 21636: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _vctxt$[ebp]
	mov	DWORD PTR _bucket$[ebp], 0
	test	edi, edi
	je	$LN3@xmlSchemaA

; 21637:     int ret = 0;
; 21638:     xmlSchemaParserCtxtPtr pctxt;
; 21639:     xmlSchemaBucketPtr bucket = NULL;
; 21640: 
; 21641:     if ((vctxt == NULL) || (schema == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	$LN3@xmlSchemaA

; 21643: 
; 21644:     if (vctxt->pctxt == NULL) {

	push	esi
	mov	esi, DWORD PTR [edi+88]
	test	esi, esi
	jne	SHORT $LN4@xmlSchemaA

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	esi
	push	esi
	push	OFFSET ??_C@_0BM@JLNHNHFO@no?5parser?5context?5available@
	push	OFFSET ??_C@_0BM@IPNOOOA@xmlSchemaAssembleByLocation@
	push	edi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 21645: 	VERROR_INT("xmlSchemaAssembleByLocation",
; 21646: 	    "no parser context available");
; 21647: 	return(-1);

	or	eax, -1
	pop	esi
	pop	edi

; 21734: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlSchemaA:

; 21648:     }
; 21649:     pctxt = vctxt->pctxt;
; 21650:     if (pctxt->constructor == NULL) {

	cmp	DWORD PTR [esi+28], 0
	jne	SHORT $LN5@xmlSchemaA

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0P@BIPJKJFE@no?5constructor@
	push	OFFSET ??_C@_0BM@IPNOOOA@xmlSchemaAssembleByLocation@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 21651: 	PERROR_INT("xmlSchemaAssembleByLocation",
; 21652: 	    "no constructor");
; 21653: 	return(-1);

	or	eax, -1
	pop	esi
	pop	edi

; 21734: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlSchemaA:
	push	ebx

; 21654:     }
; 21655:     /*
; 21656:     * Acquire the schema document.
; 21657:     */
; 21658:     location = xmlSchemaBuildAbsoluteURI(pctxt->dict,

	mov	ebx, DWORD PTR _node$[ebp]
	push	ebx
	push	DWORD PTR _location$[ebp]
	push	DWORD PTR [esi+80]
	call	_xmlSchemaBuildAbsoluteURI

; 21659: 	location, node);
; 21660:     /*
; 21661:     * Note that we pass XML_SCHEMA_SCHEMA_IMPORT here;
; 21662:     * the process will automatically change this to
; 21663:     * XML_SCHEMA_SCHEMA_MAIN if it is the first schema document.
; 21664:     */
; 21665:     ret = xmlSchemaAddSchemaDoc(pctxt, XML_SCHEMA_SCHEMA_IMPORT,

	lea	ecx, DWORD PTR _bucket$[ebp]
	mov	DWORD PTR _location$1$[ebp], eax
	push	ecx
	push	DWORD PTR _nsName$[ebp]
	push	0
	push	ebx
	push	0
	push	0
	push	0
	push	eax
	push	1
	push	esi
	call	_xmlSchemaAddSchemaDoc
	add	esp, 52					; 00000034H

; 21666: 	location, NULL, NULL, 0, node, NULL, nsName,
; 21667: 	&bucket);
; 21668:     if (ret != 0)

	test	eax, eax
	jne	SHORT $LN24@xmlSchemaA

; 21669: 	return(ret);
; 21670:     if (bucket == NULL) {

	mov	ebx, DWORD PTR _bucket$[ebp]
	test	ebx, ebx
	jne	SHORT $LN22@xmlSchemaA

; 21671: 	/*
; 21672: 	* Generate a warning that the document could not be located.
; 21673: 	*/
; 21674: 	xmlSchemaCustomWarning(ACTXT_CAST vctxt, XML_SCHEMAV_MISC,

	push	ebx
	push	ebx
	push	DWORD PTR _location$1$[ebp]
	push	OFFSET ??_C@_0DE@OFHLHGBG@The?5document?5at?5location?5?8?$CFs?8?5c@
	push	ebx
	push	DWORD PTR _node$[ebp]
	push	1879					; 00000757H
	push	edi
	call	_xmlSchemaCustomWarning
	add	esp, 32					; 00000020H
$LN11@xmlSchemaA:

; 21675: 	    node, NULL,
; 21676: 	    "The document at location '%s' could not be acquired",
; 21677: 	    location, NULL, NULL);
; 21678: 	return(ret);

	xor	eax, eax
$LN24@xmlSchemaA:
	pop	ebx
	pop	esi
	pop	edi

; 21734: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@xmlSchemaA:

; 21679:     }
; 21680:     /*
; 21681:     * The first located schema will be handled as if all other
; 21682:     * schemas imported by XSI were imported by this first schema.
; 21683:     */
; 21684:     if ((bucket != NULL) &&

	mov	eax, DWORD PTR [esi+28]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN8@xmlSchemaA

; 21685: 	(WXS_CONSTRUCTOR(pctxt)->bucket == NULL))
; 21686: 	WXS_CONSTRUCTOR(pctxt)->bucket = bucket;

	mov	DWORD PTR [eax+16], ebx
$LN8@xmlSchemaA:

; 21687:     /*
; 21688:     * TODO: Is this handled like an import? I.e. is it not an error
; 21689:     * if the schema cannot be located?
; 21690:     */
; 21691:     if ((bucket == NULL) || (! CAN_PARSE_SCHEMA(bucket)))

	cmp	DWORD PTR [ebx+20], 0
	je	SHORT $LN11@xmlSchemaA
	cmp	DWORD PTR [ebx+32], 0
	jne	SHORT $LN11@xmlSchemaA

; 21692: 	return(0);
; 21693:     /*
; 21694:     * We will reuse the parser context for every schema imported
; 21695:     * directly via XSI. So reset the context.
; 21696:     */
; 21697:     pctxt->nberrors = 0;
; 21698:     pctxt->err = 0;
; 21699:     pctxt->doc = bucket->doc;
; 21700: 
; 21701:     ret = xmlSchemaParseNewDocWithContext(pctxt, schema, bucket);

	push	ebx
	push	DWORD PTR _schema$[ebp]
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+16], 0
	mov	eax, DWORD PTR [ebx+20]
	push	esi
	mov	DWORD PTR [esi+48], eax
	call	_xmlSchemaParseNewDocWithContext
	mov	ecx, eax
	add	esp, 12					; 0000000cH

; 21702:     if (ret == -1) {

	cmp	ecx, -1
	jne	SHORT $LN12@xmlSchemaA
$exit_failure$26:
	pop	ebx

; 21731: exit_failure:
; 21732:     pctxt->doc = NULL;

	mov	DWORD PTR [esi+48], 0

; 21733:     return (-1);

	or	eax, eax
	pop	esi
	pop	edi

; 21734: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlSchemaA:

; 21703: 	pctxt->doc = NULL;
; 21704: 	goto exit_failure;
; 21705:     }
; 21706:     /* Paranoid error channelling. */
; 21707:     if ((ret == 0) && (pctxt->nberrors != 0))

	test	ecx, ecx
	jne	SHORT $LN13@xmlSchemaA
	cmp	DWORD PTR [esi+20], ecx
	je	SHORT $LN13@xmlSchemaA

; 21708: 	ret = pctxt->err;

	mov	ecx, DWORD PTR [esi+16]
$LN13@xmlSchemaA:

; 21709:     if (pctxt->nberrors == 0) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	jne	SHORT $LN14@xmlSchemaA

; 21710: 	/*
; 21711: 	* Only bother to fixup pending components, if there was
; 21712: 	* no error yet.
; 21713: 	* For every XSI acquired schema (and its sub-schemata) we will
; 21714: 	* fixup the components.
; 21715: 	*/
; 21716: 	xmlSchemaFixupComponents(pctxt, bucket);

	push	ebx
	push	esi
	call	_xmlSchemaFixupComponents

; 21717: 	ret = pctxt->err;

	mov	ecx, DWORD PTR [esi+16]
	add	esp, 8

; 21718: 	/*
; 21719: 	* Not nice, but we need somehow to channel the schema parser
; 21720: 	* error to the validation context.
; 21721: 	*/
; 21722: 	if ((ret != 0) && (vctxt->err == 0))

	test	ecx, ecx
	je	SHORT $LN16@xmlSchemaA
	cmp	DWORD PTR [edi+52], 0
	jne	SHORT $LN16@xmlSchemaA

; 21723: 	    vctxt->err = ret;

	mov	DWORD PTR [edi+52], ecx
$LN16@xmlSchemaA:

; 21724: 	vctxt->nberrors += pctxt->nberrors;

	mov	eax, DWORD PTR [esi+20]
$LN14@xmlSchemaA:

; 21725:     } else {
; 21726: 	/* Add to validation error sum. */
; 21727: 	vctxt->nberrors += pctxt->nberrors;
; 21728:     }
; 21729:     pctxt->doc = NULL;

	add	DWORD PTR [edi+56], eax

; 21730:     return(ret);

	mov	eax, ecx
	pop	ebx
	mov	DWORD PTR [esi+48], 0
	pop	esi
	pop	edi

; 21734: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlSchemaA:

; 21642: 	return (-1);

	or	eax, -1
	pop	edi

; 21734: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaAssembleByLocation ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFixupComponents
_TEXT	SEGMENT
_oldbucket$1$ = -28					; size = 4
_nsName$1$ = -24					; size = 4
_node$1$ = -20						; size = 4
_node$1$ = -20						; size = 4
_i$13$ = -20						; size = 4
_i$1$ = -20						; size = 4
_str$1 = -20						; size = 4
_str$2 = -20						; size = 4
_circ$1$ = -16						; size = 4
_circ$1$ = -16						; size = 4
_name$1$ = -16						; size = 4
_con$1$ = -12						; size = 4
_schema$1$ = -8						; size = 4
_msg$3 = -8						; size = 4
_msg$4 = -8						; size = 4
_items$2$ = -8						; size = 4
_msg$5 = -8						; size = 4
_items$1$ = -4						; size = 4
_nbItems$2$ = 8						; size = 4
_nbItems$1$ = 8						; size = 4
_pctxt$ = 8						; size = 4
_rootBucket$ = 12					; size = 4
_xmlSchemaFixupComponents PROC				; COMDAT

; 20863: {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _pctxt$[ebp]
	mov	ebx, DWORD PTR [esi+28]
	mov	DWORD PTR _con$1$[ebp], ebx
	mov	eax, DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [ebx+16]
	mov	DWORD PTR _oldbucket$1$[ebp], ecx
	test	eax, eax
	je	$LN68@xmlSchemaF

; 20864:     xmlSchemaConstructionCtxtPtr con = pctxt->constructor;
; 20865:     xmlSchemaTreeItemPtr item, *items;
; 20866:     int nbItems, i, ret = 0;
; 20867:     xmlSchemaBucketPtr oldbucket = con->bucket;
; 20868:     xmlSchemaElementPtr elemDecl;
; 20869: 
; 20870: #define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;
; 20871: 
; 20872:     if ((con->pending == NULL) ||

	cmp	DWORD PTR [eax+4], 0
	je	$LN68@xmlSchemaF

; 20875: 
; 20876:     /*
; 20877:     * Since xmlSchemaFixupComplexType() will create new particles
; 20878:     * (local components), and those particle components need a bucket
; 20879:     * on the constructor, we'll assure here that the constructor has
; 20880:     * a bucket.
; 20881:     * TODO: Think about storing locals _only_ on the main bucket.
; 20882:     */
; 20883:     if (con->bucket == NULL)

	push	edi
	mov	edi, DWORD PTR _rootBucket$[ebp]
	test	ecx, ecx
	jne	SHORT $LN69@xmlSchemaF

; 20884: 	con->bucket = rootBucket;

	mov	DWORD PTR [ebx+16], edi
$LN69@xmlSchemaF:

; 20885: 
; 20886:     /* TODO:
; 20887:     * SPEC (src-redefine):
; 20888:     * (6.2) "If it has no such self-reference, then all of the
; 20889:     * following must be true:"
; 20890: 
; 20891:     * (6.2.2) The {model group} of the model group definition which
; 20892:     * corresponds to it per XML Representation of Model Group
; 20893:     * Definition Schema Components ($3.7.2) must be a `valid
; 20894:     * restriction` of the {model group} of that model group definition
; 20895:     * in I, as defined in Particle Valid (Restriction) ($3.9.6)."
; 20896:     */
; 20897:     xmlSchemaCheckSRCRedefineFirst(pctxt);

	push	esi
	call	_xmlSchemaCheckSRCRedefineFirst

; 20898: 
; 20899:     /*
; 20900:     * Add global components to the schemata's hash tables.
; 20901:     */
; 20902:     xmlSchemaAddComponents(pctxt, rootBucket);

	push	edi
	push	esi
	call	_xmlSchemaAddComponents

; 20903: 
; 20904:     pctxt->ctxtType = NULL;

	mov	DWORD PTR [esi+84], 0
	add	esp, 12					; 0000000cH

; 20905:     items = (xmlSchemaTreeItemPtr *) con->pending->items;

	mov	eax, DWORD PTR [ebx+20]

; 20906:     nbItems = con->pending->nbItems;

	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]

; 20907:     /*
; 20908:     * Now that we have parsed *all* the schema document(s) and converted
; 20909:     * them to schema components, we can resolve references, apply component
; 20910:     * constraints, create the FSA from the content model, etc.
; 20911:     */
; 20912:     /*
; 20913:     * Resolve references of..
; 20914:     *
; 20915:     * 1. element declarations:
; 20916:     *   - the type definition
; 20917:     *   - the substitution group affiliation
; 20918:     * 2. simple/complex types:
; 20919:     *   - the base type definition
; 20920:     *   - the memberTypes of union types
; 20921:     *   - the itemType of list types
; 20922:     * 3. attributes declarations and attribute uses:
; 20923:     *   - the type definition
; 20924:     *   - if an attribute use, then the attribute declaration
; 20925:     * 4. attribute group references:
; 20926:     *   - the attribute group definition
; 20927:     * 5. particles:
; 20928:     *   - the term of the particle (e.g. a model group)
; 20929:     * 6. IDC key-references:
; 20930:     *   - the referenced IDC 'key' or 'unique' definition
; 20931:     * 7. Attribute prohibitions which had a "ref" attribute.
; 20932:     */
; 20933:     for (i = 0; i < nbItems; i++) {

	xor	eax, eax
	mov	DWORD PTR _items$1$[ebp], ecx
	mov	DWORD PTR _nbItems$1$[ebp], edx
	mov	DWORD PTR _i$1$[ebp], eax
	test	edx, edx
	jle	$LN3@xmlSchemaF
$LL4@xmlSchemaF:

; 20934: 	item = items[i];

	mov	edi, DWORD PTR [ecx+eax*4]

; 20935: 	switch (item->type) {

	mov	eax, DWORD PTR [edi]
	cmp	eax, 24					; 00000018H
	jg	$LN155@xmlSchemaF
	cmp	eax, 22					; 00000016H
	jge	$LN83@xmlSchemaF
	sub	eax, 4
	cmp	eax, 11					; 0000000bH
	ja	$LN2@xmlSchemaF
	movzx	eax, BYTE PTR $LN423@xmlSchemaF[eax]
	jmp	DWORD PTR $LN450@xmlSchemaF[eax*4]
$LN70@xmlSchemaF:

; 20936: 	    case XML_SCHEMA_TYPE_ELEMENT:
; 20937: 		xmlSchemaResolveElementReferences(

	push	esi
	push	edi
	call	_xmlSchemaResolveElementReferences
$LN440@xmlSchemaF:

; 20907:     /*
; 20908:     * Now that we have parsed *all* the schema document(s) and converted
; 20909:     * them to schema components, we can resolve references, apply component
; 20910:     * constraints, create the FSA from the content model, etc.
; 20911:     */
; 20912:     /*
; 20913:     * Resolve references of..
; 20914:     *
; 20915:     * 1. element declarations:
; 20916:     *   - the type definition
; 20917:     *   - the substitution group affiliation
; 20918:     * 2. simple/complex types:
; 20919:     *   - the base type definition
; 20920:     *   - the memberTypes of union types
; 20921:     *   - the itemType of list types
; 20922:     * 3. attributes declarations and attribute uses:
; 20923:     *   - the type definition
; 20924:     *   - if an attribute use, then the attribute declaration
; 20925:     * 4. attribute group references:
; 20926:     *   - the attribute group definition
; 20927:     * 5. particles:
; 20928:     *   - the term of the particle (e.g. a model group)
; 20929:     * 6. IDC key-references:
; 20930:     *   - the referenced IDC 'key' or 'unique' definition
; 20931:     * 7. Attribute prohibitions which had a "ref" attribute.
; 20932:     */
; 20933:     for (i = 0; i < nbItems; i++) {

	add	esp, 8
$LN209@xmlSchemaF:
	cmp	DWORD PTR [esi+16], 3069		; 00000bfdH
	je	$exit_failure$452
	mov	edx, DWORD PTR _nbItems$1$[ebp]
	jmp	$LN2@xmlSchemaF
$LN72@xmlSchemaF:

; 20938: 		    (xmlSchemaElementPtr) item, pctxt);
; 20939: 		FIXHFAILURE;
; 20940: 		break;
; 20941: 	    case XML_SCHEMA_TYPE_COMPLEX:
; 20942: 	    case XML_SCHEMA_TYPE_SIMPLE:
; 20943: 		xmlSchemaResolveTypeReferences(

	push	esi
	push	edi
	call	_xmlSchemaResolveTypeReferences

; 20944: 		    (xmlSchemaTypePtr) item, pctxt);
; 20945: 		FIXHFAILURE;
; 20946: 		break;

	jmp	SHORT $LN440@xmlSchemaF
$LN74@xmlSchemaF:

; 20363:     if (item->flags & XML_SCHEMAS_ATTR_INTERNAL_RESOLVED)

	mov	eax, DWORD PTR [edi+60]
	test	eax, 256				; 00000100H
	jne	$LN170@xmlSchemaF

; 20364: 	return(0);
; 20365:     item->flags |= XML_SCHEMAS_ATTR_INTERNAL_RESOLVED;

	or	eax, 256				; 00000100H

; 20366:     if (item->subtypes != NULL)

	cmp	DWORD PTR [edi+48], 0
	mov	DWORD PTR [edi+60], eax
	jne	$LN170@xmlSchemaF

; 20367:         return(0);
; 20368:     if (item->typeName != NULL) {

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN159@xmlSchemaF

; 20369:         xmlSchemaTypePtr type;
; 20370: 
; 20371: 	type = xmlSchemaGetType(ctxt->schema, item->typeName,

	push	DWORD PTR [edi+28]
	push	eax
	push	DWORD PTR [esi+36]
	call	_xmlSchemaGetType
	add	esp, 12					; 0000000cH

; 20372: 	    item->typeNs);
; 20373: 	if ((type == NULL) || (! WXS_IS_SIMPLE(type))) {

	test	eax, eax
	je	SHORT $LN164@xmlSchemaF
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	SHORT $LN161@xmlSchemaF
	cmp	ecx, 1
	jne	SHORT $LN164@xmlSchemaF
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	jne	SHORT $LN161@xmlSchemaF
$LN164@xmlSchemaF:

; 20374: 	    xmlSchemaPResCompAttrErr(ctxt,

	push	0
	push	4
	push	DWORD PTR [edi+28]
	push	DWORD PTR [edi+24]
	push	OFFSET ??_C@_04GPMDFGEJ@type@
	push	DWORD PTR [edi+52]

; 20375: 		XML_SCHEMAP_SRC_RESOLVE,
; 20376: 		WXS_BASIC_CAST item, item->node,
; 20377: 		"type", item->typeName, item->typeNs,
; 20378: 		XML_SCHEMA_TYPE_SIMPLE, NULL);
; 20379: 	    return(ctxt->err);

	jmp	$LN444@xmlSchemaF
$LN159@xmlSchemaF:

; 20380: 	} else
; 20381: 	    item->subtypes = type;
; 20382: 
; 20383:     } else {
; 20384: 	/*
; 20385: 	* The type defaults to the xs:anySimpleType.
; 20386: 	*/
; 20387: 	item->subtypes = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);

	push	46					; 0000002eH
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
$LN161@xmlSchemaF:

; 20947: 	    case XML_SCHEMA_TYPE_ATTRIBUTE:
; 20948: 		xmlSchemaResolveAttrTypeReferences(
; 20949: 		    (xmlSchemaAttributePtr) item, pctxt);
; 20950: 		FIXHFAILURE;

	mov	DWORD PTR [edi+48], eax

; 20951: 		break;

	jmp	$LN432@xmlSchemaF
$LN81@xmlSchemaF:

; 20061:     xmlSchemaParticlePtr particle = WXS_MODELGROUP_PARTICLE(mg);

	mov	ebx, DWORD PTR [edi+12]

; 20062:     xmlSchemaQNameRefPtr ref;
; 20063:     xmlSchemaBasicItemPtr refItem;
; 20064: 
; 20065:     /*
; 20066:     * URGENT TODO: Test this.
; 20067:     */
; 20068:     while (particle != NULL) {

	test	ebx, ebx
	je	$LN170@xmlSchemaF
	npad	4
$LL189@xmlSchemaF:

; 20069: 	if ((WXS_PARTICLE_TERM(particle) == NULL) ||

	mov	edi, DWORD PTR [ebx+12]
	test	edi, edi
	je	$next_particle$453
	cmp	DWORD PTR [edi], 2000			; 000007d0H
	jne	$next_particle$453

; 20070: 	    ((WXS_PARTICLE_TERM(particle))->type !=
; 20071: 		XML_SCHEMA_EXTRA_QNAMEREF))
; 20072: 	{
; 20073: 	    goto next_particle;
; 20074: 	}
; 20075: 	ref = WXS_QNAME_CAST WXS_PARTICLE_TERM(particle);
; 20076: 	/*
; 20077: 	* Resolve the reference.
; 20078: 	* NULL the {term} by default.
; 20079: 	*/
; 20080: 	particle->children = NULL;

	mov	DWORD PTR [ebx+12], 0

; 20081: 
; 20082: 	refItem = xmlSchemaGetNamedComponent(ctxt->schema,

	push	DWORD PTR [edi+16]
	push	DWORD PTR [edi+12]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [esi+36]
	call	_xmlSchemaGetNamedComponent
	add	esp, 16					; 00000010H

; 20083: 	    ref->itemType, ref->name, ref->targetNamespace);
; 20084: 	if (refItem == NULL) {

	test	eax, eax
	jne	SHORT $LN193@xmlSchemaF

; 20085: 	    xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,

	push	eax
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+16]
	push	DWORD PTR [edi+12]
	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	ebx
	call	_xmlSchemaGetComponentNode
	add	esp, 4
	push	eax
	push	0
	push	3004					; 00000bbcH
	push	esi
	call	_xmlSchemaPResCompAttrErr
	add	esp, 36					; 00000024H

; 20086: 		NULL, WXS_ITEM_NODE(particle), "ref", ref->name,
; 20087: 		ref->targetNamespace, ref->itemType, NULL);
; 20088: 	    /* TODO: remove the particle. */
; 20089: 	    goto next_particle;

	jmp	SHORT $next_particle$453
$LN193@xmlSchemaF:

; 20090: 	}
; 20091: 	if (refItem->type == XML_SCHEMA_TYPE_GROUP) {

	cmp	DWORD PTR [eax], 17			; 00000011H
	jne	SHORT $LN194@xmlSchemaF

; 20092: 	    if (WXS_MODELGROUPDEF_MODEL(refItem) == NULL)

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $next_particle$453

; 20093: 		/* TODO: remove the particle. */
; 20094: 		goto next_particle;
; 20095: 	    /*
; 20096: 	    * NOTE that we will assign the model group definition
; 20097: 	    * itself to the "term" of the particle. This will ease
; 20098: 	    * the check for circular model group definitions. After
; 20099: 	    * that the "term" will be assigned the model group of the
; 20100: 	    * model group definition.
; 20101: 	    */
; 20102: 	    if ((WXS_MODELGROUPDEF_MODEL(refItem))->type ==

	cmp	DWORD PTR [ecx], 8
	jne	SHORT $LN194@xmlSchemaF

; 20103: 		    XML_SCHEMA_TYPE_ALL) {
; 20104: 		/*
; 20105: 		* SPEC cos-all-limited (1)
; 20106: 		* SPEC cos-all-limited (1.2)
; 20107: 		* "It appears only as the value of one or both of the
; 20108: 		* following properties:"
; 20109: 		* (1.1) "the {model group} property of a model group
; 20110: 		*        definition."
; 20111: 		* (1.2) "the {term} property of a particle [... of] the "
; 20112: 		* {content type} of a complex type definition."
; 20113: 		*/
; 20114: 		xmlSchemaCustomErr(ACTXT_CAST ctxt,

	push	ebx
	call	_xmlSchemaGetComponentNode

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	mov	edi, eax

; 2339 :     xmlChar *msg = NULL;

	mov	DWORD PTR _msg$5[ebp], 0

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	edi
	lea	eax, DWORD PTR _msg$5[ebp]
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0HI@HIFFMALD@A?5model?5group?5definition?5is?5ref@
	push	DWORD PTR _msg$5[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$5[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	edi
	push	3091					; 00000c13H
	push	2
	push	esi

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$5[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$5[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 72					; 00000048H

; 2352 :     FREE_AND_NULL(msg)

	test	eax, eax
	je	SHORT $next_particle$453
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 20123: 		goto next_particle;

	jmp	SHORT $next_particle$453
$LN194@xmlSchemaF:

; 20124: 	    }
; 20125: 	    particle->children = (xmlSchemaTreeItemPtr) refItem;
; 20126: 	} else {
; 20127: 	    /*
; 20128: 	    * TODO: Are referenced element declarations the only
; 20129: 	    * other components we expect here?
; 20130: 	    */
; 20131: 	    particle->children = (xmlSchemaTreeItemPtr) refItem;

	mov	DWORD PTR [ebx+12], eax
$next_particle$453:

; 20132: 	}
; 20133: next_particle:
; 20134: 	particle = WXS_PTC_CAST particle->next;

	mov	ebx, DWORD PTR [ebx+8]
	test	ebx, ebx
	jne	$LL189@xmlSchemaF

; 20966: 	    case XML_SCHEMA_TYPE_SEQUENCE:
; 20967: 	    case XML_SCHEMA_TYPE_CHOICE:
; 20968: 	    case XML_SCHEMA_TYPE_ALL:
; 20969: 		xmlSchemaResolveModelGroupParticleReferences(pctxt,
; 20970: 		    WXS_MODEL_GROUP_CAST item);
; 20971: 		FIXHFAILURE;
; 20972: 		break;

	jmp	$LN432@xmlSchemaF
$LN83@xmlSchemaF:

; 20973: 	    case XML_SCHEMA_TYPE_IDC_KEY:
; 20974: 	    case XML_SCHEMA_TYPE_IDC_UNIQUE:
; 20975: 	    case XML_SCHEMA_TYPE_IDC_KEYREF:
; 20976: 		xmlSchemaResolveIDCKeyReferences(

	push	esi
	push	edi
	call	_xmlSchemaResolveIDCKeyReferences

; 20977: 		    (xmlSchemaIDCPtr) item, pctxt);
; 20978: 		FIXHFAILURE;
; 20979: 		break;

	jmp	$LN440@xmlSchemaF
$LN155@xmlSchemaF:

; 20935: 	switch (item->type) {

	sub	eax, 26					; 0000001aH
	je	$LN76@xmlSchemaF
	sub	eax, 1974				; 000007b6H
	je	SHORT $LN78@xmlSchemaF
	sub	eax, 1
	jne	$LN2@xmlSchemaF

; 20469: 	prohib->targetNamespace) == NULL) {

	push	DWORD PTR [edi+12]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [esi+36]
	call	_xmlSchemaGetAttributeDecl
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN209@xmlSchemaF

; 20470: 
; 20471: 	xmlSchemaPResCompAttrErr(pctxt,

	push	eax
	push	15					; 0000000fH
	push	DWORD PTR [edi+12]
	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	DWORD PTR [edi+4]
	push	eax
	push	3004					; 00000bbcH
	push	esi
	call	_xmlSchemaPResCompAttrErr
	add	esp, 36					; 00000024H

; 20980: 	    case XML_SCHEMA_EXTRA_ATTR_USE_PROHIB:
; 20981: 		/*
; 20982: 		* Handle attribue prohibition which had a
; 20983: 		* "ref" attribute.
; 20984: 		*/
; 20985: 		xmlSchemaResolveAttrUseProhibReferences(
; 20986: 		    WXS_ATTR_PROHIB_CAST item, pctxt);
; 20987: 		FIXHFAILURE;
; 20988: 		break;

	jmp	$LN209@xmlSchemaF
$LN78@xmlSchemaF:

; 20952: 	    case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
; 20953: 		xmlSchemaResolveAttrUseReferences(
; 20954: 		    (xmlSchemaAttributeUsePtr) item, pctxt);
; 20955: 		FIXHFAILURE;
; 20956: 		break;
; 20957: 	    case XML_SCHEMA_EXTRA_QNAMEREF:
; 20958: 		if ((WXS_QNAME_CAST item)->itemType ==

	cmp	DWORD PTR [edi+8], 16			; 00000010H
	jne	$LN170@xmlSchemaF

; 19495:     if (ref->item != NULL)

	cmp	DWORD PTR [edi+4], 0
	jne	$LN170@xmlSchemaF

; 19496:         return(0);
; 19497:     group = xmlSchemaGetAttributeGroup(ctxt->schema,

	mov	ecx, DWORD PTR [edi+12]

; 4901 :     xmlSchemaAttributeGroupPtr ret = NULL;

	xor	ebx, ebx

; 19497:     group = xmlSchemaGetAttributeGroup(ctxt->schema,

	mov	edx, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR _nsName$1$[ebp], edx
	mov	DWORD PTR _name$1$[ebp], ecx
	mov	DWORD PTR _schema$1$[ebp], eax

; 4903 :     if ((name == NULL) || (schema == NULL))

	test	ecx, ecx
	je	SHORT $LN409@xmlSchemaF
	test	eax, eax
	je	SHORT $LN409@xmlSchemaF

; 4904 :         return (NULL);
; 4905 :     if (schema != NULL) {
; 4906 : 	WXS_FIND_GLOBAL_ITEM(attrgrpDecl)

	push	DWORD PTR [eax+4]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN182@xmlSchemaF
	mov	eax, DWORD PTR _schema$1$[ebp]
	push	DWORD PTR _name$1$[ebp]
	push	DWORD PTR [eax+36]
	call	_xmlHashLookup
	mov	ebx, eax
	add	esp, 8
	test	ebx, ebx
	jne	SHORT $LN175@xmlSchemaF
$LN182@xmlSchemaF:
	mov	eax, DWORD PTR _schema$1$[ebp]
	push	DWORD PTR [eax+48]
	call	_xmlHashSize
	add	esp, 4
	cmp	eax, 1
	jle	SHORT $exit$454
	mov	ecx, DWORD PTR _nsName$1$[ebp]
	mov	eax, OFFSET ??_C@_02IEBMKJDF@?$CD?$CD@
	test	ecx, ecx
	cmovne	eax, ecx
	push	eax
	mov	eax, DWORD PTR _schema$1$[ebp]
	mov	eax, DWORD PTR [eax+48]
	push	eax
	call	_xmlHashLookup
	add	esp, 8
	test	eax, eax
	je	SHORT $exit$454
	mov	eax, DWORD PTR [eax+52]
	push	DWORD PTR _name$1$[ebp]
	push	DWORD PTR [eax+36]
	call	_xmlHashLookup
	add	esp, 8
	mov	ebx, eax
$exit$454:

; 19500:     if (group == NULL) {

	test	ebx, ebx
	je	SHORT $LN409@xmlSchemaF
$LN175@xmlSchemaF:

; 19502: 	    XML_SCHEMAP_SRC_RESOLVE,
; 19503: 	    NULL, ref->node,
; 19504: 	    "ref", ref->name, ref->targetNamespace,
; 19505: 	    ref->itemType, NULL);
; 19506: 	return(ctxt->err);
; 19507:     }
; 19508:     ref->item = WXS_BASIC_CAST group;

	mov	DWORD PTR [edi+4], ebx
	jmp	SHORT $LN432@xmlSchemaF
$LN409@xmlSchemaF:

; 19501: 	xmlSchemaPResCompAttrErr(ctxt,

	push	0
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+16]
	push	DWORD PTR [edi+12]
	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	DWORD PTR [edi+20]
	push	0

; 20959: 		    XML_SCHEMA_TYPE_ATTRIBUTEGROUP)
; 20960: 		{
; 20961: 		    xmlSchemaResolveAttrGroupReferences(
; 20962: 			WXS_QNAME_CAST item, pctxt);
; 20963: 		}
; 20964: 		FIXHFAILURE;
; 20965: 		break;

	jmp	SHORT $LN445@xmlSchemaF
$LN76@xmlSchemaF:

; 20210:     if ((ause->attrDecl == NULL) ||

	mov	ebx, DWORD PTR [edi+12]
	test	ebx, ebx
	je	SHORT $LN170@xmlSchemaF
	cmp	DWORD PTR [ebx], 2000			; 000007d0H
	jne	SHORT $LN170@xmlSchemaF

; 20211: 	(ause->attrDecl->type != XML_SCHEMA_EXTRA_QNAMEREF))
; 20212: 	return(0);
; 20213: 
; 20214:     {
; 20215: 	xmlSchemaQNameRefPtr ref = WXS_QNAME_CAST ause->attrDecl;
; 20216: 
; 20217: 	/*
; 20218: 	* TODO: Evaluate, what errors could occur if the declaration is not
; 20219: 	* found.
; 20220: 	*/
; 20221: 	ause->attrDecl = xmlSchemaGetAttributeDecl(ctxt->schema,

	push	DWORD PTR [ebx+16]
	push	DWORD PTR [ebx+12]
	push	DWORD PTR [esi+36]
	call	_xmlSchemaGetAttributeDecl
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+12], eax

; 20222: 	    ref->name, ref->targetNamespace);
; 20223:         if (ause->attrDecl == NULL) {

	test	eax, eax
	jne	SHORT $LN432@xmlSchemaF

; 20224: 	    xmlSchemaPResCompAttrErr(ctxt,

	push	eax
	push	15					; 0000000fH
	push	DWORD PTR [ebx+16]
	push	DWORD PTR [ebx+12]
	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	DWORD PTR [edi+20]
$LN444@xmlSchemaF:

; 20907:     /*
; 20908:     * Now that we have parsed *all* the schema document(s) and converted
; 20909:     * them to schema components, we can resolve references, apply component
; 20910:     * constraints, create the FSA from the content model, etc.
; 20911:     */
; 20912:     /*
; 20913:     * Resolve references of..
; 20914:     *
; 20915:     * 1. element declarations:
; 20916:     *   - the type definition
; 20917:     *   - the substitution group affiliation
; 20918:     * 2. simple/complex types:
; 20919:     *   - the base type definition
; 20920:     *   - the memberTypes of union types
; 20921:     *   - the itemType of list types
; 20922:     * 3. attributes declarations and attribute uses:
; 20923:     *   - the type definition
; 20924:     *   - if an attribute use, then the attribute declaration
; 20925:     * 4. attribute group references:
; 20926:     *   - the attribute group definition
; 20927:     * 5. particles:
; 20928:     *   - the term of the particle (e.g. a model group)
; 20929:     * 6. IDC key-references:
; 20930:     *   - the referenced IDC 'key' or 'unique' definition
; 20931:     * 7. Attribute prohibitions which had a "ref" attribute.
; 20932:     */
; 20933:     for (i = 0; i < nbItems; i++) {

	push	edi
$LN445@xmlSchemaF:
	push	3004					; 00000bbcH
	push	esi
	call	_xmlSchemaPResCompAttrErr
	add	esp, 36					; 00000024H
$LN432@xmlSchemaF:
	mov	edx, DWORD PTR _nbItems$1$[ebp]
$LN170@xmlSchemaF:
	cmp	DWORD PTR [esi+16], 3069		; 00000bfdH
	je	$exit_failure$452
$LN2@xmlSchemaF:
	mov	eax, DWORD PTR _i$1$[ebp]
	mov	ecx, DWORD PTR _items$1$[ebp]
	inc	eax
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, edx
	jl	$LL4@xmlSchemaF
$LN3@xmlSchemaF:

; 20989: 	    default:
; 20990: 		break;
; 20991: 	}
; 20992:     }
; 20993:     if (pctxt->nberrors != 0)

	cmp	DWORD PTR [esi+20], 0
	jne	$exit_error$455

; 20994: 	goto exit_error;
; 20995: 
; 20996:     /*
; 20997:     * Now that all references are resolved we
; 20998:     * can check for circularity of...
; 20999:     * 1. the base axis of type definitions
; 21000:     * 2. nested model group definitions
; 21001:     * 3. nested attribute group definitions
; 21002:     * TODO: check for circual substitution groups.
; 21003:     */
; 21004:     for (i = 0; i < nbItems; i++) {

	xor	ebx, ebx
	test	edx, edx
	jle	$LN410@xmlSchemaF
	npad	6
$LL9@xmlSchemaF:

; 21005: 	item = items[i];

	mov	edi, DWORD PTR [ecx+ebx*4]

; 21006: 	/*
; 21007: 	* Let's better stop on the first error here.
; 21008: 	*/
; 21009: 	switch (item->type) {

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx-4]
	cmp	eax, 13					; 0000000dH
	ja	$LN7@xmlSchemaF
	movzx	eax, BYTE PTR $LN424@xmlSchemaF[eax]
	jmp	DWORD PTR $LN451@xmlSchemaF[eax*4]
$LN89@xmlSchemaF:

; 14983: 	(item->type == XML_SCHEMA_TYPE_BASIC) ||

	cmp	ecx, 1
	je	$LN228@xmlSchemaF
	mov	eax, DWORD PTR [edi+64]
	test	eax, eax
	je	$LN228@xmlSchemaF

; 14984: 	(item->baseType == NULL))
; 14985: 	return;
; 14986:     xmlSchemaCheckTypeDefCircularInternal(ctxt, item,

	push	eax
	push	edi
	push	esi
	call	_xmlSchemaCheckTypeDefCircularInternal
	add	esp, 12					; 0000000cH

; 21010: 	    case XML_SCHEMA_TYPE_COMPLEX:
; 21011: 	    case XML_SCHEMA_TYPE_SIMPLE:
; 21012: 		xmlSchemaCheckTypeDefCircular(
; 21013: 		    (xmlSchemaTypePtr) item, pctxt);
; 21014: 		FIXHFAILURE;
; 21015: 		if (pctxt->nberrors != 0)
; 21016: 		    goto exit_error;
; 21017: 		break;

	jmp	$LN430@xmlSchemaF
$LN92@xmlSchemaF:

; 18989: 	(item->type != XML_SCHEMA_TYPE_GROUP) ||

	cmp	ecx, 17					; 00000011H
	jne	$LN228@xmlSchemaF
	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	$LN228@xmlSchemaF

; 18990: 	(item->children == NULL))
; 18991: 	return;
; 18992:     {
; 18993: 	xmlSchemaTreeItemPtr circ;
; 18994: 
; 18995: 	circ = xmlSchemaGetCircModelGrDefRef(item, item->children->children);

	push	DWORD PTR [eax+12]
	push	edi
	call	_xmlSchemaGetCircModelGrDefRef
	add	esp, 8
	mov	DWORD PTR _circ$1$[ebp], eax

; 18996: 	if (circ != NULL) {

	test	eax, eax
	je	$LN430@xmlSchemaF

; 18997: 	    xmlChar *str = NULL;
; 18998: 	    /*
; 18999: 	    * TODO: The error report is not adequate: this constraint
; 19000: 	    * is defined for model groups but not definitions, but since
; 19001: 	    * there cannot be any circular model groups without a model group
; 19002: 	    * definition (if not using a construction API), we check those
; 19003: 	    * defintions only.
; 19004: 	    */
; 19005: 	    xmlSchemaPCustomErr(ctxt,

	push	DWORD PTR [edi+16]
	lea	eax, DWORD PTR _str$2[ebp]
	mov	DWORD PTR _str$2[ebp], 0
	push	DWORD PTR [edi+20]
	push	eax
	call	_xmlSchemaFormatQName
	push	DWORD PTR _circ$1$[ebp]
	mov	edi, eax
	call	_xmlSchemaGetComponentNode

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	edi
	push	OFFSET ??_C@_0DO@EEBKKJHN@Circular?5reference?5to?5the?5model@
	push	eax
	push	0
	push	3075					; 00000c03H
	push	esi
	call	_xmlSchemaPCustomErrExt

; 19011: 	    FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$2[ebp]

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	add	esp, 48					; 00000030H

; 19011: 	    FREE_AND_NULL(str)

	test	eax, eax
	je	SHORT $LN219@xmlSchemaF
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN219@xmlSchemaF:

; 19012: 	    /*
; 19013: 	    * NOTE: We will cut the reference to avoid further
; 19014: 	    * confusion of the processor. This is a fatal error.
; 19015: 	    */
; 19016: 	    circ->children = NULL;

	mov	eax, DWORD PTR _circ$1$[ebp]
	mov	DWORD PTR [eax+12], 0

; 21018: 	    case XML_SCHEMA_TYPE_GROUP:
; 21019: 		xmlSchemaCheckGroupDefCircular(
; 21020: 		    (xmlSchemaModelGroupDefPtr) item, pctxt);
; 21021: 		FIXHFAILURE;
; 21022: 		if (pctxt->nberrors != 0)
; 21023: 		    goto exit_error;
; 21024: 		break;

	jmp	$LN430@xmlSchemaF
$LN95@xmlSchemaF:

; 19146:     if (attrGr->attrUses == NULL)

	mov	eax, DWORD PTR [edi+56]
	test	eax, eax
	je	SHORT $LN228@xmlSchemaF

; 19147: 	return(0);
; 19148:     else if ((attrGr->flags & XML_SCHEMAS_ATTRGROUP_HAS_REFS) == 0)

	test	BYTE PTR [edi+36], 16			; 00000010H
	je	SHORT $LN228@xmlSchemaF

; 19149: 	return(0);
; 19150:     else {
; 19151: 	xmlSchemaQNameRefPtr circ;
; 19152: 
; 19153: 	circ = xmlSchemaCheckAttrGroupCircularRecur(attrGr,

	push	eax
	push	edi
	call	_xmlSchemaCheckAttrGroupCircularRecur
	add	esp, 8
	mov	DWORD PTR _circ$1$[ebp], eax

; 19154: 	    (xmlSchemaItemListPtr) attrGr->attrUses);
; 19155: 	if (circ != NULL) {

	test	eax, eax
	je	SHORT $LN430@xmlSchemaF

; 1429 :     return (xmlSchemaFormatQName(buf,

	push	edi

; 19156: 	    xmlChar *str = NULL;

	mov	DWORD PTR _str$1[ebp], 0

; 1429 :     return (xmlSchemaFormatQName(buf,

	call	_xmlSchemaGetComponentName
	add	esp, 4
	push	eax
	push	edi
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _str$1[ebp]
	push	eax
	call	_xmlSchemaFormatQName

; 19160: 	    xmlSchemaPCustomErr(ctxt,

	push	DWORD PTR _circ$1$[ebp]

; 1429 :     return (xmlSchemaFormatQName(buf,

	mov	edi, eax

; 19160: 	    xmlSchemaPCustomErr(ctxt,

	call	_xmlSchemaGetComponentNode

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	edi
	push	OFFSET ??_C@_0DH@FDECNJHO@Circular?5reference?5to?5the?5attri@
	push	eax
	push	0
	push	3073					; 00000c01H
	push	esi
	call	_xmlSchemaPCustomErrExt

; 19165: 	    FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$1[ebp]

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	add	esp, 48					; 00000030H

; 19165: 	    FREE_AND_NULL(str);

	test	eax, eax
	je	SHORT $LN229@xmlSchemaF
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN229@xmlSchemaF:

; 19166: 	    /*
; 19167: 	    * NOTE: We will cut the reference to avoid further
; 19168: 	    * confusion of the processor.
; 19169: 	    * BADSPEC TODO: The spec should define how to process in this case.
; 19170: 	    */
; 19171: 	    circ->item = NULL;

	mov	eax, DWORD PTR _circ$1$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN430@xmlSchemaF:

; 20994: 	goto exit_error;
; 20995: 
; 20996:     /*
; 20997:     * Now that all references are resolved we
; 20998:     * can check for circularity of...
; 20999:     * 1. the base axis of type definitions
; 21000:     * 2. nested model group definitions
; 21001:     * 3. nested attribute group definitions
; 21002:     * TODO: check for circual substitution groups.
; 21003:     */
; 21004:     for (i = 0; i < nbItems; i++) {

	mov	edx, DWORD PTR _nbItems$1$[ebp]
$LN228@xmlSchemaF:
	cmp	DWORD PTR [esi+16], 3069		; 00000bfdH
	je	$exit_failure$452
	cmp	DWORD PTR [esi+20], 0
	jne	$exit_error$455
$LN7@xmlSchemaF:
	mov	ecx, DWORD PTR _items$1$[ebp]
	inc	ebx
	cmp	ebx, edx
	jl	$LL9@xmlSchemaF

; 21025: 	    case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 21026: 		xmlSchemaCheckAttrGroupCircular(
; 21027: 		    (xmlSchemaAttributeGroupPtr) item, pctxt);
; 21028: 		FIXHFAILURE;
; 21029: 		if (pctxt->nberrors != 0)
; 21030: 		    goto exit_error;
; 21031: 		break;
; 21032: 	    default:
; 21033: 		break;
; 21034: 	}
; 21035:     }
; 21036:     if (pctxt->nberrors != 0)

	cmp	DWORD PTR [esi+20], 0
	jne	$exit_error$455
$LN410@xmlSchemaF:

; 21037: 	goto exit_error;
; 21038:     /*
; 21039:     * Model group definition references:
; 21040:     * Such a reference is reflected by a particle at the component
; 21041:     * level. Until now the 'term' of such particles pointed
; 21042:     * to the model group definition; this was done, in order to
; 21043:     * ease circularity checks. Now we need to set the 'term' of
; 21044:     * such particles to the model group of the model group definition.
; 21045:     */
; 21046:     for (i = 0; i < nbItems; i++) {

	mov	ebx, DWORD PTR _nbItems$1$[ebp]
	xor	edx, edx
	test	ebx, ebx
	jle	SHORT $LN411@xmlSchemaF
	mov	edi, DWORD PTR _items$1$[ebp]
$LL14@xmlSchemaF:

; 21047: 	item = items[i];

	mov	ecx, DWORD PTR [edi+edx*4]

; 21048: 	switch (item->type) {

	mov	eax, DWORD PTR [ecx]
	add	eax, -6					; fffffffaH
	cmp	eax, 1
	ja	SHORT $LN12@xmlSchemaF

; 19040:     xmlSchemaParticlePtr particle = WXS_MODELGROUP_PARTICLE(mg);

	mov	ecx, DWORD PTR [ecx+12]

; 19041: 
; 19042:     while (particle != NULL) {

	test	ecx, ecx
	je	SHORT $LN12@xmlSchemaF
	npad	5
$LL236@xmlSchemaF:

; 19043: 	if ((WXS_PARTICLE_TERM(particle) == NULL) ||

	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	je	SHORT $LN240@xmlSchemaF
	cmp	DWORD PTR [eax], 17			; 00000011H
	jne	SHORT $LN240@xmlSchemaF

; 19044: 	    ((WXS_PARTICLE_TERM(particle))->type !=
; 19045: 		XML_SCHEMA_TYPE_GROUP))
; 19046: 	{
; 19047: 	    particle = WXS_PTC_CAST particle->next;
; 19048: 	    continue;
; 19049: 	}
; 19050: 	if (WXS_MODELGROUPDEF_MODEL(WXS_PARTICLE_TERM(particle)) == NULL) {

	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
$LN240@xmlSchemaF:

; 19041: 
; 19042:     while (particle != NULL) {

	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	jne	SHORT $LL236@xmlSchemaF
$LN12@xmlSchemaF:

; 21037: 	goto exit_error;
; 21038:     /*
; 21039:     * Model group definition references:
; 21040:     * Such a reference is reflected by a particle at the component
; 21041:     * level. Until now the 'term' of such particles pointed
; 21042:     * to the model group definition; this was done, in order to
; 21043:     * ease circularity checks. Now we need to set the 'term' of
; 21044:     * such particles to the model group of the model group definition.
; 21045:     */
; 21046:     for (i = 0; i < nbItems; i++) {

	inc	edx
	cmp	edx, ebx
	jl	SHORT $LL14@xmlSchemaF

; 21049: 	    case XML_SCHEMA_TYPE_SEQUENCE:
; 21050: 	    case XML_SCHEMA_TYPE_CHOICE:
; 21051: 		xmlSchemaModelGroupToModelGroupDefFixup(pctxt,
; 21052: 		    WXS_MODEL_GROUP_CAST item);
; 21053: 		break;
; 21054: 	    default:
; 21055: 		break;
; 21056: 	}
; 21057:     }
; 21058:     if (pctxt->nberrors != 0)

	cmp	DWORD PTR [esi+20], 0
	jne	$exit_error$455
$LN411@xmlSchemaF:

; 21059: 	goto exit_error;
; 21060:     /*
; 21061:     * Expand attribute group references of attribute group definitions.
; 21062:     */
; 21063:     for (i = 0; i < nbItems; i++) {

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN412@xmlSchemaF
	mov	eax, DWORD PTR _items$1$[ebp]
$LL19@xmlSchemaF:

; 21064: 	item = items[i];

	mov	ecx, DWORD PTR [eax+edi*4]

; 21065: 	switch (item->type) {

	cmp	DWORD PTR [ecx], 16			; 00000010H
	jne	SHORT $LN17@xmlSchemaF

; 21066:             case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 21067: 		if ((! WXS_ATTR_GROUP_EXPANDED(item)) &&

	mov	eax, DWORD PTR [ecx+36]
	test	al, 1
	jne	SHORT $LN434@xmlSchemaF
	test	al, 16					; 00000010H
	je	SHORT $LN434@xmlSchemaF

; 19370:     if ((attrGr->attrUses == NULL) ||

	mov	edx, DWORD PTR [ecx+56]
	test	edx, edx
	je	SHORT $LN244@xmlSchemaF

; 19371: 	(attrGr->flags & XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED))
; 19372: 	return(0);
; 19373: 
; 19374:     attrGr->flags |= XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED;

	or	eax, 1

; 19375:     if (xmlSchemaExpandAttributeGroupRefs(pctxt, WXS_BASIC_CAST attrGr,
; 19376: 	&(attrGr->attributeWildcard), attrGr->attrUses, NULL) == -1)

	push	0
	push	edx
	mov	DWORD PTR [ecx+36], eax
	lea	eax, DWORD PTR [ecx+40]
	push	eax
	push	ecx
	push	esi
	call	_xmlSchemaExpandAttributeGroupRefs
	add	esp, 20					; 00000014H
$LN244@xmlSchemaF:

; 21068: 		    WXS_ATTR_GROUP_HAS_REFS(item))
; 21069: 		{
; 21070: 		    xmlSchemaAttributeGroupExpandRefs(pctxt,
; 21071: 			WXS_ATTR_GROUP_CAST item);
; 21072: 		    FIXHFAILURE;

	cmp	DWORD PTR [esi+16], 3069		; 00000bfdH
	je	$exit_failure$452
$LN434@xmlSchemaF:

; 21059: 	goto exit_error;
; 21060:     /*
; 21061:     * Expand attribute group references of attribute group definitions.
; 21062:     */
; 21063:     for (i = 0; i < nbItems; i++) {

	mov	eax, DWORD PTR _items$1$[ebp]
$LN17@xmlSchemaF:
	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL19@xmlSchemaF

; 21073: 		}
; 21074: 		break;
; 21075: 	    default:
; 21076: 		break;
; 21077: 	}
; 21078:     }
; 21079:     if (pctxt->nberrors != 0)

	cmp	DWORD PTR [esi+20], 0
	jne	$exit_error$455
$LN412@xmlSchemaF:

; 21080: 	goto exit_error;
; 21081:     /*
; 21082:     * First compute the variety of simple types. This is needed as
; 21083:     * a seperate step, since otherwise we won't be able to detect
; 21084:     * circular union types in all cases.
; 21085:     */
; 21086:     for (i = 0; i < nbItems; i++) {

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN413@xmlSchemaF
$LL24@xmlSchemaF:

; 21087: 	item = items[i];

	mov	eax, DWORD PTR _items$1$[ebp]
	mov	eax, DWORD PTR [eax+edi*4]

; 21088: 	switch (item->type) {

	cmp	DWORD PTR [eax], 4
	jne	SHORT $LN22@xmlSchemaF

; 21089:             case XML_SCHEMA_TYPE_SIMPLE:
; 21090: 		if (WXS_IS_TYPE_NOT_FIXED_1((xmlSchemaTypePtr) item)) {

	test	DWORD PTR [eax+48], 536870912		; 20000000H
	jne	SHORT $LN22@xmlSchemaF

; 21091: 		    xmlSchemaFixupSimpleTypeStageOne(pctxt,

	push	eax
	push	esi
	call	_xmlSchemaFixupSimpleTypeStageOne
	add	esp, 8

; 21092: 			(xmlSchemaTypePtr) item);
; 21093: 		    FIXHFAILURE;

	cmp	DWORD PTR [esi+16], 3069		; 00000bfdH
	je	$exit_failure$452
$LN22@xmlSchemaF:

; 21080: 	goto exit_error;
; 21081:     /*
; 21082:     * First compute the variety of simple types. This is needed as
; 21083:     * a seperate step, since otherwise we won't be able to detect
; 21084:     * circular union types in all cases.
; 21085:     */
; 21086:     for (i = 0; i < nbItems; i++) {

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL24@xmlSchemaF

; 21094: 		}
; 21095: 		break;
; 21096: 	    default:
; 21097: 		break;
; 21098: 	}
; 21099:     }
; 21100:     if (pctxt->nberrors != 0)

	cmp	DWORD PTR [esi+20], 0
	jne	$exit_error$455
$LN413@xmlSchemaF:

; 21101: 	goto exit_error;
; 21102:     /*
; 21103:     * Detect circular union types. Note that this needs the variety to
; 21104:     * be already computed.
; 21105:     */
; 21106:     for (i = 0; i < nbItems; i++) {

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN414@xmlSchemaF
$LL29@xmlSchemaF:

; 21107: 	item = items[i];

	mov	eax, DWORD PTR _items$1$[ebp]
	mov	eax, DWORD PTR [eax+edi*4]

; 21108: 	switch (item->type) {

	cmp	DWORD PTR [eax], 4
	jne	SHORT $LN27@xmlSchemaF

; 21109:             case XML_SCHEMA_TYPE_SIMPLE:
; 21110: 		if (((xmlSchemaTypePtr) item)->memberTypes != NULL) {

	mov	ecx, DWORD PTR [eax+92]
	test	ecx, ecx
	je	SHORT $LN27@xmlSchemaF

; 15046:     if (! WXS_IS_UNION(type))

	test	BYTE PTR [eax+48], 128			; 00000080H
	je	SHORT $LN247@xmlSchemaF

; 15047: 	return(0);
; 15048:     return(xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, type,

	push	ecx
	push	eax
	push	esi
	call	_xmlSchemaCheckUnionTypeDefCircularRecur
	add	esp, 12					; 0000000cH
$LN247@xmlSchemaF:

; 21111: 		    xmlSchemaCheckUnionTypeDefCircular(pctxt,
; 21112: 			(xmlSchemaTypePtr) item);
; 21113: 		    FIXHFAILURE;

	cmp	DWORD PTR [esi+16], 3069		; 00000bfdH
	je	$exit_failure$452
$LN27@xmlSchemaF:

; 21101: 	goto exit_error;
; 21102:     /*
; 21103:     * Detect circular union types. Note that this needs the variety to
; 21104:     * be already computed.
; 21105:     */
; 21106:     for (i = 0; i < nbItems; i++) {

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL29@xmlSchemaF

; 21114: 		}
; 21115: 		break;
; 21116: 	    default:
; 21117: 		break;
; 21118: 	}
; 21119:     }
; 21120:     if (pctxt->nberrors != 0)

	cmp	DWORD PTR [esi+20], 0
	jne	$exit_error$455
$LN414@xmlSchemaF:

; 21121: 	goto exit_error;
; 21122: 
; 21123:     /*
; 21124:     * Do the complete type fixup for simple types.
; 21125:     */
; 21126:     for (i = 0; i < nbItems; i++) {

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN415@xmlSchemaF
	npad	4
$LL34@xmlSchemaF:

; 21127: 	item = items[i];

	mov	eax, DWORD PTR _items$1$[ebp]
	mov	eax, DWORD PTR [eax+edi*4]

; 21128: 	switch (item->type) {

	cmp	DWORD PTR [eax], 4
	jne	SHORT $LN32@xmlSchemaF

; 21129:             case XML_SCHEMA_TYPE_SIMPLE:
; 21130: 		if (WXS_IS_TYPE_NOT_FIXED(WXS_TYPE_CAST item)) {

	test	DWORD PTR [eax+48], 4194304		; 00400000H
	jne	SHORT $LN32@xmlSchemaF

; 21131: 		    xmlSchemaFixupSimpleTypeStageTwo(pctxt, WXS_TYPE_CAST item);

	push	eax
	push	esi
	call	_xmlSchemaFixupSimpleTypeStageTwo
	add	esp, 8

; 21132: 		    FIXHFAILURE;

	cmp	DWORD PTR [esi+16], 3069		; 00000bfdH
	je	$exit_failure$452
$LN32@xmlSchemaF:

; 21121: 	goto exit_error;
; 21122: 
; 21123:     /*
; 21124:     * Do the complete type fixup for simple types.
; 21125:     */
; 21126:     for (i = 0; i < nbItems; i++) {

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL34@xmlSchemaF

; 21133: 		}
; 21134: 		break;
; 21135: 	    default:
; 21136: 		break;
; 21137: 	}
; 21138:     }
; 21139:     if (pctxt->nberrors != 0)

	cmp	DWORD PTR [esi+20], 0
	jne	$exit_error$455
$LN415@xmlSchemaF:

; 21140: 	goto exit_error;
; 21141:     /*
; 21142:     * At this point we need build and check all simple types.
; 21143:     */
; 21144:     /*
; 21145:     * Apply contraints for attribute declarations.
; 21146:     */
; 21147:     for (i = 0; i < nbItems; i++) {

	mov	ecx, DWORD PTR _nbItems$1$[ebp]
	xor	ebx, ebx
	test	ecx, ecx
	jle	$LN416@xmlSchemaF
	mov	eax, DWORD PTR _items$1$[ebp]
	npad	6
$LL39@xmlSchemaF:

; 21148: 	item = items[i];

	mov	edi, DWORD PTR [eax+ebx*4]

; 21149: 	switch (item->type) {

	cmp	DWORD PTR [edi], 15			; 0000000fH
	jne	$LN37@xmlSchemaF

; 19539:     if (WXS_ATTR_TYPEDEF(attr) == NULL)

	mov	eax, DWORD PTR [edi+48]
	test	eax, eax
	je	$LN273@xmlSchemaF

; 19540: 	return(0);
; 19541: 
; 19542:     if (attr->defValue != NULL) {

	cmp	DWORD PTR [edi+44], 0
	je	$LN273@xmlSchemaF

; 19543: 	int ret;
; 19544: 
; 19545: 	/*
; 19546: 	* SPEC a-props-correct (3)
; 19547: 	* "If the {type definition} is or is derived from ID then there
; 19548: 	* must not be a {value constraint}."
; 19549: 	*/
; 19550: 	if (xmlSchemaIsDerivedFromBuiltInType(

	push	23					; 00000017H
	push	eax
	call	_xmlSchemaIsDerivedFromBuiltInType
	add	esp, 8
	test	eax, eax
	je	$LN253@xmlSchemaF

; 2341 :     if ((node == NULL) && (item != NULL) &&

	cmp	DWORD PTR [esi], 1

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	mov	DWORD PTR _node$1$[ebp], 0

; 2339 :     xmlChar *msg = NULL;

	mov	DWORD PTR _msg$4[ebp], 0

; 2340 : 
; 2341 :     if ((node == NULL) && (item != NULL) &&

	jne	SHORT $LN260@xmlSchemaF

; 2342 : 	(actxt->type == XML_SCHEMA_CTXT_PARSER)) {
; 2343 : 	node = WXS_ITEM_NODE(item);

	push	edi
	call	_xmlSchemaGetComponentNode

; 2344 : 	xmlSchemaFormatItemForReport(&msg, NULL, item, NULL);

	push	0
	push	edi
	mov	DWORD PTR _node$1$[ebp], eax
	lea	eax, DWORD PTR _msg$4[ebp]
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 2345 : 	msg = xmlStrcat(msg, BAD_CAST ": ");

	push	OFFSET ??_C@_02LMMGGCAJ@?3?5@
	push	DWORD PTR _msg$4[ebp]
	call	_xmlStrcat
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _msg$4[ebp], eax

; 2346 :     } else

	jmp	SHORT $LN261@xmlSchemaF
$LN260@xmlSchemaF:

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$4[ebp]
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError
	mov	eax, DWORD PTR _msg$4[ebp]
	add	esp, 12					; 0000000cH
$LN261@xmlSchemaF:

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0FF@JBDCKHFC@Value?5constraints?5are?5not?5allow@
	push	eax
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$4[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	DWORD PTR _node$1$[ebp]
	push	3090					; 00000c12H

; 19559: 	    return(pctxt->err);

	jmp	$LN447@xmlSchemaF
$LN253@xmlSchemaF:

; 19560: 	}
; 19561: 	/*
; 19562: 	* SPEC a-props-correct (2)
; 19563: 	* "if there is a {value constraint}, the canonical lexical
; 19564: 	* representation of its value must be `valid` with respect
; 19565: 	* to the {type definition} as defined in String Valid ($3.14.4)."
; 19566: 	* TODO: Don't care about the *canonical* stuff here, this requirement
; 19567: 	* will be removed in WXS 1.1 anyway.
; 19568: 	*/
; 19569: 	ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST pctxt,

	push	0
	push	1
	push	1
	lea	eax, DWORD PTR [edi+68]
	push	eax
	push	DWORD PTR [edi+44]
	push	DWORD PTR [edi+48]
	push	DWORD PTR [edi+52]
	push	esi
	call	_xmlSchemaVCheckCVCSimpleType
	add	esp, 32					; 00000020H

; 19570: 	    attr->node, WXS_ATTR_TYPEDEF(attr),
; 19571: 	    attr->defValue, &(attr->defVal),
; 19572: 	    1, 1, 0);
; 19573: 	if (ret != 0) {

	test	eax, eax
	je	$LN429@xmlSchemaF

; 19574: 	    if (ret < 0) {

	jns	SHORT $LN255@xmlSchemaF

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CH@HOPMNJDI@calling?5xmlSchemaVCheckCVCSimpl@
	push	OFFSET ??_C@_0BP@KEKKKHHB@xmlSchemaCheckAttrPropsCorrect@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 19577: 		return(-1);

	jmp	$LN429@xmlSchemaF
$LN255@xmlSchemaF:

; 2341 :     if ((node == NULL) && (item != NULL) &&

	cmp	DWORD PTR [esi], 1

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	mov	DWORD PTR _node$1$[ebp], 0

; 2339 :     xmlChar *msg = NULL;

	mov	DWORD PTR _msg$3[ebp], 0

; 2340 : 
; 2341 :     if ((node == NULL) && (item != NULL) &&

	jne	SHORT $LN271@xmlSchemaF

; 2342 : 	(actxt->type == XML_SCHEMA_CTXT_PARSER)) {
; 2343 : 	node = WXS_ITEM_NODE(item);

	push	edi
	call	_xmlSchemaGetComponentNode

; 2344 : 	xmlSchemaFormatItemForReport(&msg, NULL, item, NULL);

	push	0
	push	edi
	mov	DWORD PTR _node$1$[ebp], eax
	lea	eax, DWORD PTR _msg$3[ebp]
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 2345 : 	msg = xmlStrcat(msg, BAD_CAST ": ");

	push	OFFSET ??_C@_02LMMGGCAJ@?3?5@
	push	DWORD PTR _msg$3[ebp]
	call	_xmlStrcat
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _msg$3[ebp], eax

; 2346 :     } else

	jmp	SHORT $LN272@xmlSchemaF
$LN271@xmlSchemaF:

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	lea	eax, DWORD PTR _msg$3[ebp]
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError
	mov	eax, DWORD PTR _msg$3[ebp]
	add	esp, 12					; 0000000cH
$LN272@xmlSchemaF:

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0CP@DMDDKJIO@The?5value?5of?5the?5value?5constrai@
	push	eax
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$3[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	DWORD PTR _node$1$[ebp]
	push	3079					; 00000c07H
$LN447@xmlSchemaF:

; 21150: 	    case XML_SCHEMA_TYPE_ATTRIBUTE:
; 21151: 		xmlSchemaCheckAttrPropsCorrect(pctxt, WXS_ATTR_CAST item);
; 21152: 		FIXHFAILURE;

	push	2
	push	esi
	mov	DWORD PTR _msg$3[ebp], eax
	call	_xmlSchemaErr4Line
	mov	eax, DWORD PTR _msg$3[ebp]
	add	esp, 56					; 00000038H
	test	eax, eax
	je	SHORT $LN429@xmlSchemaF
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN429@xmlSchemaF:
	mov	ecx, DWORD PTR _nbItems$1$[ebp]
$LN273@xmlSchemaF:
	cmp	DWORD PTR [esi+16], 3069		; 00000bfdH
	je	$exit_failure$452
	mov	eax, DWORD PTR _items$1$[ebp]
$LN37@xmlSchemaF:

; 21140: 	goto exit_error;
; 21141:     /*
; 21142:     * At this point we need build and check all simple types.
; 21143:     */
; 21144:     /*
; 21145:     * Apply contraints for attribute declarations.
; 21146:     */
; 21147:     for (i = 0; i < nbItems; i++) {

	inc	ebx
	cmp	ebx, ecx
	jl	$LL39@xmlSchemaF

; 21153: 		break;
; 21154: 	    default:
; 21155: 		break;
; 21156: 	}
; 21157:     }
; 21158:     if (pctxt->nberrors != 0)

	cmp	DWORD PTR [esi+20], 0
	jne	$exit_error$455
$LN416@xmlSchemaF:

; 21159: 	goto exit_error;
; 21160:     /*
; 21161:     * Apply constraints for attribute uses.
; 21162:     */
; 21163:     for (i = 0; i < nbItems; i++) {

	mov	ebx, DWORD PTR _nbItems$1$[ebp]
	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN417@xmlSchemaF
$LL44@xmlSchemaF:

; 21164: 	item = items[i];

	mov	eax, DWORD PTR _items$1$[ebp]
	mov	eax, DWORD PTR [eax+edi*4]

; 21165: 	switch (item->type) {

	cmp	DWORD PTR [eax], 26			; 0000001aH
	jne	SHORT $LN42@xmlSchemaF

; 21166: 	    case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
; 21167: 		if (((xmlSchemaAttributeUsePtr)item)->defValue != NULL) {

	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN42@xmlSchemaF

; 21168: 		    xmlSchemaCheckAttrUsePropsCorrect(pctxt,

	push	eax
	push	esi
	call	_xmlSchemaCheckAttrUsePropsCorrect
	add	esp, 8

; 21169: 			WXS_ATTR_USE_CAST item);
; 21170: 		    FIXHFAILURE;

	cmp	DWORD PTR [esi+16], 3069		; 00000bfdH
	je	$exit_failure$452
$LN42@xmlSchemaF:

; 21159: 	goto exit_error;
; 21160:     /*
; 21161:     * Apply constraints for attribute uses.
; 21162:     */
; 21163:     for (i = 0; i < nbItems; i++) {

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL44@xmlSchemaF

; 21171: 		}
; 21172: 		break;
; 21173: 	    default:
; 21174: 		break;
; 21175: 	}
; 21176:     }
; 21177:     if (pctxt->nberrors != 0)

	cmp	DWORD PTR [esi+20], 0
	jne	$exit_error$455
$LN417@xmlSchemaF:

; 21178: 	goto exit_error;
; 21179: 
; 21180:     /*
; 21181:     * Apply constraints for attribute group definitions.
; 21182:     */
; 21183:     for (i = 0; i < nbItems; i++) {

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN418@xmlSchemaF
$LL49@xmlSchemaF:

; 21184: 	item = items[i];

	mov	eax, DWORD PTR _items$1$[ebp]
	mov	eax, DWORD PTR [eax+edi*4]

; 21185: 	switch (item->type) {

	cmp	DWORD PTR [eax], 16			; 00000010H
	jne	SHORT $LN47@xmlSchemaF

; 21186: 	case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 21187: 	    if (( (WXS_ATTR_GROUP_CAST item)->attrUses != NULL) &&

	mov	ecx, DWORD PTR [eax+56]
	test	ecx, ecx
	je	SHORT $LN47@xmlSchemaF
	cmp	DWORD PTR [ecx+4], 1
	jle	SHORT $LN47@xmlSchemaF

; 21188: 		( (WXS_LIST_CAST (WXS_ATTR_GROUP_CAST item)->attrUses)->nbItems > 1))
; 21189: 	    {
; 21190: 		xmlSchemaCheckAGPropsCorrect(pctxt, WXS_ATTR_GROUP_CAST item);

	push	eax
	push	esi
	call	_xmlSchemaCheckAGPropsCorrect
	add	esp, 8

; 21191: 		FIXHFAILURE;

	cmp	DWORD PTR [esi+16], 3069		; 00000bfdH
	je	$exit_failure$452
$LN47@xmlSchemaF:

; 21178: 	goto exit_error;
; 21179: 
; 21180:     /*
; 21181:     * Apply constraints for attribute group definitions.
; 21182:     */
; 21183:     for (i = 0; i < nbItems; i++) {

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL49@xmlSchemaF

; 21192: 	    }
; 21193: 	    break;
; 21194: 	default:
; 21195: 	    break;
; 21196: 	}
; 21197:     }
; 21198:     if (pctxt->nberrors != 0)

	cmp	DWORD PTR [esi+20], 0
	jne	$exit_error$455
$LN418@xmlSchemaF:

; 21199: 	goto exit_error;
; 21200: 
; 21201:     /*
; 21202:     * Apply constraints for redefinitions.
; 21203:     */
; 21204:     if (WXS_CONSTRUCTOR(pctxt)->redefs != NULL)

	mov	eax, DWORD PTR [esi+28]
	mov	edi, DWORD PTR [eax+28]
	test	edi, edi
	je	SHORT $LN279@xmlSchemaF
$LL280@xmlSchemaF:

; 20676: 	if (redef->target == NULL) {

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN289@xmlSchemaF

; 20677: 	    redef = redef->next;
; 20678: 	    continue;
; 20679: 	}
; 20680: 	item = redef->item;

	mov	ecx, DWORD PTR [edi+4]

; 20681: 
; 20682: 	switch (item->type) {

	mov	edx, DWORD PTR [ecx]
	cmp	edx, 4
	jl	SHORT $LN289@xmlSchemaF
	cmp	edx, 5
	jle	SHORT $LN285@xmlSchemaF
	cmp	edx, 16					; 00000010H
	jne	SHORT $LN289@xmlSchemaF

; 20690: 
; 20691: 		/*
; 20692: 		* TODO: Seems like there's nothing more to do. The normal
; 20693: 		* inheritance mechanism is used. But not 100% sure.
; 20694: 		*/
; 20695: 		break;
; 20696: 	    case XML_SCHEMA_TYPE_GROUP:
; 20697: 		/*
; 20698: 		* URGENT TODO:
; 20699: 		* SPEC src-redefine:
; 20700: 		* (6.2.2) "The {model group} of the model group definition
; 20701: 		* which corresponds to it per XML Representation of Model
; 20702: 		* Group Definition Schema Components ($3.7.2) must be a
; 20703: 		* `valid restriction` of the {model group} of that model
; 20704: 		* group definition in I, as defined in Particle Valid
; 20705: 		* (Restriction) ($3.9.6)."
; 20706: 		*/
; 20707: 		break;
; 20708: 	    case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 20709: 		/*
; 20710: 		* SPEC src-redefine:
; 20711: 		* (7.2.2) "The {attribute uses} and {attribute wildcard} of
; 20712: 		* the attribute group definition which corresponds to it
; 20713: 		* per XML Representation of Attribute Group Definition Schema
; 20714: 		* Components ($3.6.2) must be `valid restrictions` of the
; 20715: 		* {attribute uses} and {attribute wildcard} of that attribute
; 20716: 		* group definition in I, as defined in clause 2, clause 3 and
; 20717: 		* clause 4 of Derivation Valid (Restriction, Complex)
; 20718: 		* ($3.4.6) (where references to the base type definition are
; 20719: 		* understood as references to the attribute group definition
; 20720: 		* in I)."
; 20721: 		*/
; 20722: 		err = xmlSchemaCheckDerivationOKRestriction2to4(pctxt,

	push	DWORD PTR [eax+40]
	push	DWORD PTR [ecx+40]
	push	DWORD PTR [eax+56]
	push	DWORD PTR [ecx+56]
	push	eax
	push	ecx
	push	1
	push	esi
	call	_xmlSchemaCheckDerivationOKRestriction2to4
	add	esp, 32					; 00000020H

; 20723: 		    XML_SCHEMA_ACTION_REDEFINE,
; 20724: 		    item, redef->target,
; 20725: 		    (WXS_ATTR_GROUP_CAST item)->attrUses,
; 20726: 		    (WXS_ATTR_GROUP_CAST redef->target)->attrUses,
; 20727: 		    (WXS_ATTR_GROUP_CAST item)->attributeWildcard,
; 20728: 		    (WXS_ATTR_GROUP_CAST redef->target)->attributeWildcard);
; 20729: 		if (err == -1)

	cmp	eax, -1
	je	SHORT $LN279@xmlSchemaF

; 20730: 		    return(-1);
; 20731: 		break;

	jmp	SHORT $LN289@xmlSchemaF
$LN285@xmlSchemaF:

; 20683: 	    case XML_SCHEMA_TYPE_SIMPLE:
; 20684: 	    case XML_SCHEMA_TYPE_COMPLEX:
; 20685: 		/*
; 20686: 		* Since the spec wants the {name} of the redefined
; 20687: 		* type to be 'absent', we'll NULL it.
; 20688: 		*/
; 20689: 		(WXS_TYPE_CAST redef->target)->name = NULL;

	mov	DWORD PTR [eax+8], 0
$LN289@xmlSchemaF:

; 20732: 	    default:
; 20733: 		break;
; 20734: 	}
; 20735: 	redef = redef->next;
; 20736:     } while (redef != NULL);

	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	SHORT $LL280@xmlSchemaF
$LN279@xmlSchemaF:

; 21205: 	xmlSchemaCheckSRCRedefineSecond(pctxt);
; 21206:     if (pctxt->nberrors != 0)

	cmp	DWORD PTR [esi+20], 0
	jne	$exit_error$455

; 21207: 	goto exit_error;
; 21208: 
; 21209:     /*
; 21210:     * Complex types are builded and checked.
; 21211:     */
; 21212:     for (i = 0; i < nbItems; i++) {

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN419@xmlSchemaF
$LL54@xmlSchemaF:

; 21213: 	item = con->pending->items[i];

	mov	eax, DWORD PTR _con$1$[ebp]
	mov	eax, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+edi*4]

; 21214: 	switch (item->type) {

	cmp	DWORD PTR [eax], 5
	jne	SHORT $LN52@xmlSchemaF

; 21215: 	    case XML_SCHEMA_TYPE_COMPLEX:
; 21216: 		if (WXS_IS_TYPE_NOT_FIXED(WXS_TYPE_CAST item)) {

	test	DWORD PTR [eax+48], 4194304		; 00400000H
	jne	SHORT $LN52@xmlSchemaF

; 21217: 		    xmlSchemaFixupComplexType(pctxt, WXS_TYPE_CAST item);

	push	eax
	push	esi
	call	_xmlSchemaFixupComplexType
	add	esp, 8

; 21218: 		    FIXHFAILURE;

	cmp	DWORD PTR [esi+16], 3069		; 00000bfdH
	je	$exit_failure$452
$LN52@xmlSchemaF:

; 21207: 	goto exit_error;
; 21208: 
; 21209:     /*
; 21210:     * Complex types are builded and checked.
; 21211:     */
; 21212:     for (i = 0; i < nbItems; i++) {

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL54@xmlSchemaF

; 21219: 		}
; 21220: 		break;
; 21221: 	    default:
; 21222: 		break;
; 21223: 	}
; 21224:     }
; 21225:     if (pctxt->nberrors != 0)

	cmp	DWORD PTR [esi+20], 0
	jne	$exit_error$455
$LN419@xmlSchemaF:

; 21226: 	goto exit_error;
; 21227: 
; 21228:     /*
; 21229:     * The list could have changed, since xmlSchemaFixupComplexType()
; 21230:     * will create particles and model groups in some cases.
; 21231:     */
; 21232:     items = (xmlSchemaTreeItemPtr *) con->pending->items;

	mov	eax, DWORD PTR _con$1$[ebp]

; 21233:     nbItems = con->pending->nbItems;
; 21234: 
; 21235:     /*
; 21236:     * Apply some constraints for element declarations.
; 21237:     */
; 21238:     for (i = 0; i < nbItems; i++) {

	xor	ebx, ebx
	mov	eax, DWORD PTR [eax+20]
	mov	edi, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _items$2$[ebp], ecx
	mov	DWORD PTR _nbItems$2$[ebp], edi
	test	edi, edi
	jle	SHORT $LN420@xmlSchemaF
$LL59@xmlSchemaF:

; 21239: 	item = items[i];

	mov	edi, DWORD PTR [ecx+ebx*4]

; 21240: 	switch (item->type) {

	cmp	DWORD PTR [edi], 14			; 0000000eH
	jne	SHORT $LN57@xmlSchemaF

; 21241: 	    case XML_SCHEMA_TYPE_ELEMENT:
; 21242: 		elemDecl = (xmlSchemaElementPtr) item;
; 21243: 
; 21244: 		if ((elemDecl->flags & XML_SCHEMAS_ELEM_INTERNAL_CHECKED) == 0)

	mov	eax, DWORD PTR [edi+48]
	test	eax, 262144				; 00040000H
	jne	SHORT $LN57@xmlSchemaF

; 20039:     elemDecl->flags |= XML_SCHEMAS_ELEM_INTERNAL_CHECKED;

	or	eax, 262144				; 00040000H

; 20040:     if (xmlSchemaCheckElemPropsCorrect(ctxt, elemDecl) == 0) {

	push	edi
	push	esi
	mov	DWORD PTR [edi+48], eax
	call	_xmlSchemaCheckElemPropsCorrect
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN294@xmlSchemaF

; 20041: 	/*
; 20042: 	* Adds substitution group members.
; 20043: 	*/
; 20044: 	xmlSchemaCheckElemSubstGroup(ctxt, elemDecl);

	push	edi
	push	esi
	call	_xmlSchemaCheckElemSubstGroup
	add	esp, 8
$LN294@xmlSchemaF:

; 21245: 		{
; 21246: 		    xmlSchemaCheckElementDeclComponent(
; 21247: 			(xmlSchemaElementPtr) elemDecl, pctxt);
; 21248: 		    FIXHFAILURE;

	cmp	DWORD PTR [esi+16], 3069		; 00000bfdH
	je	$exit_failure$452
	mov	ecx, DWORD PTR _items$2$[ebp]
$LN57@xmlSchemaF:

; 21233:     nbItems = con->pending->nbItems;
; 21234: 
; 21235:     /*
; 21236:     * Apply some constraints for element declarations.
; 21237:     */
; 21238:     for (i = 0; i < nbItems; i++) {

	mov	edi, DWORD PTR _nbItems$2$[ebp]
	inc	ebx
	cmp	ebx, edi
	jl	SHORT $LL59@xmlSchemaF

; 21249: 		}
; 21250: 
; 21251: #ifdef WXS_ELEM_DECL_CONS_ENABLED
; 21252: 		/*
; 21253: 		* Schema Component Constraint: Element Declarations Consistent
; 21254: 		* Apply this constraint to local types of element declarations.
; 21255: 		*/
; 21256: 		if ((WXS_ELEM_TYPEDEF(elemDecl) != NULL) &&
; 21257: 		    (WXS_IS_COMPLEX(WXS_ELEM_TYPEDEF(elemDecl))) &&
; 21258: 		    (WXS_TYPE_IS_LOCAL(WXS_ELEM_TYPEDEF(elemDecl))))
; 21259: 		{
; 21260: 		    xmlSchemaCheckElementDeclConsistent(pctxt,
; 21261: 			WXS_BASIC_CAST elemDecl,
; 21262: 			WXS_TYPE_PARTICLE(WXS_ELEM_TYPEDEF(elemDecl)),
; 21263: 			NULL, NULL, 0);
; 21264: 		}
; 21265: #endif
; 21266: 		break;
; 21267: 	    default:
; 21268: 		break;
; 21269: 	}
; 21270:     }
; 21271:     if (pctxt->nberrors != 0)

	cmp	DWORD PTR [esi+20], 0
	jne	$exit_error$455
$LN420@xmlSchemaF:

; 21272: 	goto exit_error;
; 21273: 
; 21274:     /*
; 21275:     * Finally we can build the automaton from the content model of
; 21276:     * complex types.
; 21277:     */
; 21278: 
; 21279:     for (i = 0; i < nbItems; i++) {

	xor	ebx, ebx
	mov	DWORD PTR _i$13$[ebp], ebx
	test	edi, edi
	jle	$LN436@xmlSchemaF
	mov	eax, DWORD PTR _nbItems$2$[ebp]
	npad	6
$LL64@xmlSchemaF:

; 21280: 	item = items[i];

	mov	edi, DWORD PTR [ecx+ebx*4]

; 21281: 	switch (item->type) {

	cmp	DWORD PTR [edi], 5
	jne	$LN62@xmlSchemaF

; 13187: 	(type->contModel != NULL) ||

	cmp	DWORD PTR [edi+108], 0
	jne	$LN62@xmlSchemaF
	mov	eax, DWORD PTR [edi+52]
	cmp	eax, 2
	je	SHORT $LN391@xmlSchemaF
	cmp	eax, 3
	jne	$LN426@xmlSchemaF
$LN391@xmlSchemaF:

; 13188: 	((type->contentType != XML_SCHEMA_CONTENT_ELEMENTS) &&
; 13189: 	(type->contentType != XML_SCHEMA_CONTENT_MIXED)))
; 13190: 	return;
; 13191: 
; 13192: #ifdef DEBUG_CONTENT
; 13193:     xmlGenericError(xmlGenericErrorContext,
; 13194:                     "Building content model for %s\n", name);
; 13195: #endif
; 13196:     ctxt->am = NULL;

	mov	DWORD PTR [esi+64], 0

; 13197:     ctxt->am = xmlNewAutomata();

	call	_xmlNewAutomata
	mov	DWORD PTR [esi+64], eax

; 13198:     if (ctxt->am == NULL) {

	test	eax, eax
	jne	SHORT $LN299@xmlSchemaF

; 13199:         xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, DWORD PTR [edi+8]
	mov	ebx, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0CM@ONMINIGJ@Cannot?5create?5automata?5for?5comp@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx]
	call	eax

; 13200: 	    "Cannot create automata for complex type %s\n", type->name);
; 13201:         return;

	mov	ebx, DWORD PTR _i$13$[ebp]
	add	esp, 12					; 0000000cH
	jmp	$LN448@xmlSchemaF
$exit_failure$452:

; 21299:     goto exit;
; 21300: 
; 21301: exit_failure:
; 21302:     ret = -1;

	or	edi, -1
	jmp	$exit$456
$LN299@xmlSchemaF:

; 13203:     ctxt->state = xmlAutomataGetInitState(ctxt->am);

	push	eax
	call	_xmlAutomataGetInitState
	mov	DWORD PTR [esi+76], eax

; 13204:     /*
; 13205:     * Build the automaton.
; 13206:     */
; 13207:     xmlSchemaBuildAContentModel(ctxt, WXS_TYPE_PARTICLE(type));

	push	DWORD PTR [edi+28]
	push	esi
	call	_xmlSchemaBuildAContentModel

; 13208:     xmlAutomataSetFinalState(ctxt->am, ctxt->state);

	push	DWORD PTR [esi+76]
	push	DWORD PTR [esi+64]
	call	_xmlAutomataSetFinalState

; 13209:     type->contModel = xmlAutomataCompile(ctxt->am);

	push	DWORD PTR [esi+64]
	call	_xmlAutomataCompile
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+108], eax

; 13210:     if (type->contModel == NULL) {

	test	eax, eax
	jne	SHORT $LN300@xmlSchemaF

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0CE@GNJHIDLA@Failed?5to?5compile?5the?5content?5m@
	push	DWORD PTR [edi+36]
	push	edi
	push	3069					; 00000bfdH

; 2982 : 	str1, NULL, NULL);
; 2983 : }

	jmp	SHORT $LN443@xmlSchemaF
$LN300@xmlSchemaF:

; 13215:     } else if (xmlRegexpIsDeterminist(type->contModel) != 1) {

	push	eax
	call	_xmlRegexpIsDeterminist
	add	esp, 4
	cmp	eax, 1
	je	SHORT $LN302@xmlSchemaF

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CF@FHONPKDJ@The?5content?5model?5is?5not?5determ@
	push	DWORD PTR [edi+36]
	push	edi
	push	3070					; 00000bfeH
$LN443@xmlSchemaF:

; 13228:     ctxt->state = NULL;

	push	esi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
$LN302@xmlSchemaF:

; 13229:     xmlFreeAutomata(ctxt->am);

	push	DWORD PTR [esi+64]
	mov	DWORD PTR [esi+76], 0
	call	_xmlFreeAutomata
	add	esp, 4

; 13230:     ctxt->am = NULL;

	mov	DWORD PTR [esi+64], 0
$LN448@xmlSchemaF:

; 21272: 	goto exit_error;
; 21273: 
; 21274:     /*
; 21275:     * Finally we can build the automaton from the content model of
; 21276:     * complex types.
; 21277:     */
; 21278: 
; 21279:     for (i = 0; i < nbItems; i++) {

	mov	ecx, DWORD PTR _items$2$[ebp]
$LN426@xmlSchemaF:
	mov	eax, DWORD PTR _nbItems$2$[ebp]
$LN62@xmlSchemaF:
	inc	ebx
	mov	DWORD PTR _i$13$[ebp], ebx
	cmp	ebx, eax
	jl	$LL64@xmlSchemaF

; 21282: 	    case XML_SCHEMA_TYPE_COMPLEX:
; 21283: 		xmlSchemaBuildContentModel((xmlSchemaTypePtr) item, pctxt);
; 21284: 		/* FIXHFAILURE; */
; 21285: 		break;
; 21286: 	    default:
; 21287: 		break;
; 21288: 	}
; 21289:     }
; 21290:     if (pctxt->nberrors != 0)

	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN436@xmlSchemaF
$exit_error$455:

; 21291: 	goto exit_error;
; 21292:     /*
; 21293:     * URGENT TODO: cos-element-consistent
; 21294:     */
; 21295:     goto exit;
; 21296: 
; 21297: exit_error:
; 21298:     ret = pctxt->err;

	mov	edi, DWORD PTR [esi+16]
	jmp	SHORT $exit$456
$LN436@xmlSchemaF:

; 21303: 
; 21304: exit:
; 21305:     /*
; 21306:     * Reset the constructor. This is needed for XSI acquisition, since
; 21307:     * those items will be processed over and over again for every XSI
; 21308:     * if not cleared here.
; 21309:     */
; 21310:     con->bucket = oldbucket;

	xor	edi, edi
$exit$456:
	mov	ebx, DWORD PTR _con$1$[ebp]
	mov	eax, DWORD PTR _oldbucket$1$[ebp]
	mov	DWORD PTR [ebx+16], eax

; 21311:     con->pending->nbItems = 0;

	mov	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR [eax+4], 0

; 21312:     if (con->substGroups != NULL) {

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN152@xmlSchemaF

; 21313: 	xmlHashFree(con->substGroups, xmlSchemaSubstGroupFreeEntry);

	push	OFFSET _xmlSchemaSubstGroupFreeEntry
	push	eax
	call	_xmlHashFree
	add	esp, 8

; 21314: 	con->substGroups = NULL;

	mov	DWORD PTR [ebx+24], 0
$LN152@xmlSchemaF:

; 21315:     }
; 21316:     if (con->redefs != NULL) {

	mov	esi, DWORD PTR [ebx+28]
	test	esi, esi
	je	SHORT $LN153@xmlSchemaF
$LL310@xmlSchemaF:

; 9921 : 	xmlFree(prev);

	push	esi
	mov	esi, DWORD PTR [esi]
	call	DWORD PTR _xmlFree
	add	esp, 4
	test	esi, esi
	jne	SHORT $LL310@xmlSchemaF

; 21317: 	xmlSchemaRedefListFree(con->redefs);
; 21318: 	con->redefs = NULL;

	mov	DWORD PTR [ebx+28], esi
$LN153@xmlSchemaF:

; 21319:     }
; 21320:     return(ret);

	mov	eax, edi
	pop	edi
	pop	esi

; 21321: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN68@xmlSchemaF:
	pop	esi

; 20873: 	(con->pending->nbItems == 0))
; 20874: 	return(0);

	xor	eax, eax

; 21321: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN450@xmlSchemaF:
	DD	$LN72@xmlSchemaF
	DD	$LN81@xmlSchemaF
	DD	$LN70@xmlSchemaF
	DD	$LN74@xmlSchemaF
	DD	$LN2@xmlSchemaF
$LN423@xmlSchemaF:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	3
$LN451@xmlSchemaF:
	DD	$LN89@xmlSchemaF
	DD	$LN95@xmlSchemaF
	DD	$LN92@xmlSchemaF
	DD	$LN7@xmlSchemaF
$LN424@xmlSchemaF:
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	2
_xmlSchemaFixupComponents ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddComponents
_TEXT	SEGMENT
_i$1$ = -8						; size = 4
_item$1$ = -4						; size = 4
_pctxt$ = 8						; size = 4
_name$1$ = 12						; size = 4
_str$1 = 12						; size = 4
_bucket$ = 12						; size = 4
_xmlSchemaAddComponents PROC				; COMDAT

; 20744: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _bucket$[ebp]
	test	ebx, ebx
	je	$LN63@xmlSchemaA

; 20745:     xmlSchemaBasicItemPtr item;
; 20746:     int err;
; 20747:     xmlHashTablePtr *table;
; 20748:     const xmlChar *name;
; 20749:     int i;
; 20750: 
; 20751: #define WXS_GET_GLOBAL_HASH(c, slot) { \
; 20752:     if (WXS_IS_BUCKET_IMPMAIN((c)->type)) \
; 20753: 	table = &(WXS_IMPBUCKET((c))->schema->slot); \
; 20754:     else \
; 20755: 	table = &(WXS_INCBUCKET((c))->ownerImport->schema->slot); }
; 20756: 
; 20757:     /*
; 20758:     * Add global components to the schema's hash tables.
; 20759:     * This is the place where duplicate components will be
; 20760:     * detected.
; 20761:     * TODO: I think normally we should support imports of the
; 20762:     *   same namespace from multiple locations. We don't do currently,
; 20763:     *   but if we do then according to:
; 20764:     *   http://www.w3.org/Bugs/Public/show_bug.cgi?id=2224
; 20765:     *   we would need, if imported directly, to import redefined
; 20766:     *   components as well to be able to catch clashing components.
; 20767:     *   (I hope I'll still know what this means after some months :-()
; 20768:     */
; 20769:     if (bucket == NULL)
; 20770: 	return(-1);
; 20771:     if (bucket->flags & XML_SCHEMA_BUCKET_COMPS_ADDED)

	mov	eax, DWORD PTR [ebx+4]
	test	al, 2
	jne	$LN8@xmlSchemaA

; 20772: 	return(0);
; 20773:     bucket->flags |= XML_SCHEMA_BUCKET_COMPS_ADDED;

	or	eax, 2

; 20774: 
; 20775:     for (i = 0; i < bucket->globals->nbItems; i++) {

	xor	esi, esi
	mov	DWORD PTR [ebx+4], eax
	mov	eax, DWORD PTR [ebx+44]
	mov	DWORD PTR _i$1$[ebp], esi
	cmp	DWORD PTR [eax+4], esi
	jle	$LN70@xmlSchemaA
$LL4@xmlSchemaA:

; 20776: 	item = bucket->globals->items[i];

	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+esi*4]
	mov	DWORD PTR _item$1$[ebp], esi

; 20777: 	table = NULL;
; 20778: 	switch (item->type) {

	mov	eax, DWORD PTR [esi]
	add	eax, -4					; fffffffcH
	cmp	eax, 20					; 00000014H
	ja	$LN43@xmlSchemaA
	movzx	eax, BYTE PTR $LN71@xmlSchemaA[eax]
	jmp	DWORD PTR $LN74@xmlSchemaA[eax*4]
$LN12@xmlSchemaA:

; 20779: 	    case XML_SCHEMA_TYPE_COMPLEX:
; 20780: 	    case XML_SCHEMA_TYPE_SIMPLE:
; 20781: 		if (WXS_REDEFINED_TYPE(item))

	test	DWORD PTR [esi+48], 1073741824		; 40000000H
	jne	$LN2@xmlSchemaA

; 20782: 		    continue;
; 20783: 		name = (WXS_TYPE_CAST item)->name;
; 20784: 		WXS_GET_GLOBAL_HASH(bucket, typeDecl)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR _name$1$[ebp], ecx
	test	eax, eax
	je	SHORT $LN16@xmlSchemaA
	cmp	eax, 1
	je	SHORT $LN16@xmlSchemaA
	mov	eax, DWORD PTR [ebx+52]
	mov	edi, DWORD PTR [eax+52]

; 20785: 		break;

	add	edi, 28					; 0000001cH
	jmp	$LN41@xmlSchemaA
$LN16@xmlSchemaA:

; 20782: 		    continue;
; 20783: 		name = (WXS_TYPE_CAST item)->name;
; 20784: 		WXS_GET_GLOBAL_HASH(bucket, typeDecl)

	mov	edi, DWORD PTR [ebx+52]

; 20785: 		break;

	add	edi, 28					; 0000001cH
	jmp	$LN41@xmlSchemaA
$LN17@xmlSchemaA:

; 20786: 	    case XML_SCHEMA_TYPE_ELEMENT:
; 20787: 		name = (WXS_ELEM_CAST item)->name;
; 20788: 		WXS_GET_GLOBAL_HASH(bucket, elemDecl)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR _name$1$[ebp], ecx
	test	eax, eax
	je	SHORT $LN20@xmlSchemaA
	cmp	eax, 1
	je	SHORT $LN20@xmlSchemaA
	mov	eax, DWORD PTR [ebx+52]
	mov	edi, DWORD PTR [eax+52]

; 20789: 		break;

	add	edi, 40					; 00000028H
	jmp	$LN41@xmlSchemaA
$LN20@xmlSchemaA:

; 20786: 	    case XML_SCHEMA_TYPE_ELEMENT:
; 20787: 		name = (WXS_ELEM_CAST item)->name;
; 20788: 		WXS_GET_GLOBAL_HASH(bucket, elemDecl)

	mov	edi, DWORD PTR [ebx+52]

; 20789: 		break;

	add	edi, 40					; 00000028H
	jmp	$LN41@xmlSchemaA
$LN21@xmlSchemaA:

; 20790: 	    case XML_SCHEMA_TYPE_ATTRIBUTE:
; 20791: 		name = (WXS_ATTR_CAST item)->name;
; 20792: 		WXS_GET_GLOBAL_HASH(bucket, attrDecl)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR _name$1$[ebp], ecx
	test	eax, eax
	je	SHORT $LN24@xmlSchemaA
	cmp	eax, 1
	je	SHORT $LN24@xmlSchemaA
	mov	eax, DWORD PTR [ebx+52]
	mov	edi, DWORD PTR [eax+52]

; 20793: 		break;

	add	edi, 32					; 00000020H
	jmp	$LN41@xmlSchemaA
$LN24@xmlSchemaA:

; 20790: 	    case XML_SCHEMA_TYPE_ATTRIBUTE:
; 20791: 		name = (WXS_ATTR_CAST item)->name;
; 20792: 		WXS_GET_GLOBAL_HASH(bucket, attrDecl)

	mov	edi, DWORD PTR [ebx+52]

; 20793: 		break;

	add	edi, 32					; 00000020H
	jmp	$LN41@xmlSchemaA
$LN25@xmlSchemaA:

; 20794: 	    case XML_SCHEMA_TYPE_GROUP:
; 20795: 		if (WXS_REDEFINED_MODEL_GROUP_DEF(item))

	test	BYTE PTR [esi+28], 2
	jne	$LN2@xmlSchemaA

; 20796: 		    continue;
; 20797: 		name = (WXS_MODEL_GROUPDEF_CAST item)->name;
; 20798: 		WXS_GET_GLOBAL_HASH(bucket, groupDecl)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR _name$1$[ebp], ecx
	test	eax, eax
	je	SHORT $LN29@xmlSchemaA
	cmp	eax, 1
	je	SHORT $LN29@xmlSchemaA
	mov	eax, DWORD PTR [ebx+52]
	mov	edi, DWORD PTR [eax+52]

; 20799: 		break;

	add	edi, 56					; 00000038H
	jmp	SHORT $LN41@xmlSchemaA
$LN29@xmlSchemaA:

; 20796: 		    continue;
; 20797: 		name = (WXS_MODEL_GROUPDEF_CAST item)->name;
; 20798: 		WXS_GET_GLOBAL_HASH(bucket, groupDecl)

	mov	edi, DWORD PTR [ebx+52]

; 20799: 		break;

	add	edi, 56					; 00000038H
	jmp	SHORT $LN41@xmlSchemaA
$LN30@xmlSchemaA:

; 20800: 	    case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 20801: 		if (WXS_REDEFINED_ATTR_GROUP(item))

	test	BYTE PTR [esi+36], 8
	jne	$LN2@xmlSchemaA

; 20802: 		    continue;
; 20803: 		name = (WXS_ATTR_GROUP_CAST item)->name;
; 20804: 		WXS_GET_GLOBAL_HASH(bucket, attrgrpDecl)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR _name$1$[ebp], ecx
	test	eax, eax
	je	SHORT $LN34@xmlSchemaA
	cmp	eax, 1
	je	SHORT $LN34@xmlSchemaA
	mov	eax, DWORD PTR [ebx+52]
	mov	edi, DWORD PTR [eax+52]

; 20805: 		break;

	add	edi, 36					; 00000024H
	jmp	SHORT $LN41@xmlSchemaA
$LN34@xmlSchemaA:

; 20802: 		    continue;
; 20803: 		name = (WXS_ATTR_GROUP_CAST item)->name;
; 20804: 		WXS_GET_GLOBAL_HASH(bucket, attrgrpDecl)

	mov	edi, DWORD PTR [ebx+52]

; 20805: 		break;

	add	edi, 36					; 00000024H
	jmp	SHORT $LN41@xmlSchemaA
$LN35@xmlSchemaA:

; 20806: 	    case XML_SCHEMA_TYPE_IDC_KEY:
; 20807: 	    case XML_SCHEMA_TYPE_IDC_UNIQUE:
; 20808: 	    case XML_SCHEMA_TYPE_IDC_KEYREF:
; 20809: 		name = (WXS_IDC_CAST item)->name;
; 20810: 		WXS_GET_GLOBAL_HASH(bucket, idcDef)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR _name$1$[ebp], ecx
	test	eax, eax
	je	SHORT $LN38@xmlSchemaA
	cmp	eax, 1
	je	SHORT $LN38@xmlSchemaA
	mov	eax, DWORD PTR [ebx+52]
	mov	edi, DWORD PTR [eax+52]

; 20811: 		break;

	add	edi, 76					; 0000004cH
	jmp	SHORT $LN41@xmlSchemaA
$LN38@xmlSchemaA:

; 20806: 	    case XML_SCHEMA_TYPE_IDC_KEY:
; 20807: 	    case XML_SCHEMA_TYPE_IDC_UNIQUE:
; 20808: 	    case XML_SCHEMA_TYPE_IDC_KEYREF:
; 20809: 		name = (WXS_IDC_CAST item)->name;
; 20810: 		WXS_GET_GLOBAL_HASH(bucket, idcDef)

	mov	edi, DWORD PTR [ebx+52]

; 20811: 		break;

	add	edi, 76					; 0000004cH
	jmp	SHORT $LN41@xmlSchemaA
$LN39@xmlSchemaA:

; 20812: 	    case XML_SCHEMA_TYPE_NOTATION:
; 20813: 		name = ((xmlSchemaNotationPtr) item)->name;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _name$1$[ebp], eax

; 20814: 		WXS_GET_GLOBAL_HASH(bucket, notaDecl)

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN42@xmlSchemaA
	cmp	eax, 1
	je	SHORT $LN42@xmlSchemaA
	mov	eax, DWORD PTR [ebx+52]
	mov	edi, DWORD PTR [eax+52]
	jmp	SHORT $LN72@xmlSchemaA
$LN42@xmlSchemaA:
	mov	edi, DWORD PTR [ebx+52]
$LN72@xmlSchemaA:

; 20815: 		break;
; 20816: 	    default:
; 20817: 		PERROR_INT("xmlSchemaAddComponents",
; 20818: 		    "Unexpected global component type");
; 20819: 		continue;
; 20820: 	}
; 20821: 	if (*table == NULL) {

	add	edi, 44					; 0000002cH
$LN41@xmlSchemaA:
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN67@xmlSchemaA

; 20822: 	    *table = xmlHashCreateDict(10, pctxt->dict);

	mov	eax, DWORD PTR _pctxt$[ebp]
	push	DWORD PTR [eax+80]
	push	10					; 0000000aH
	call	_xmlHashCreateDict
	add	esp, 8
	mov	DWORD PTR [edi], eax

; 20823: 	    if (*table == NULL) {

	test	eax, eax
	je	$LN62@xmlSchemaA
$LN67@xmlSchemaA:

; 20824: 		PERROR_INT("xmlSchemaAddComponents",
; 20825: 		    "failed to create a component hash table");
; 20826: 		return(-1);
; 20827: 	    }
; 20828: 	}
; 20829: 	err = xmlHashAddEntry(*table, name, item);

	push	esi
	push	DWORD PTR _name$1$[ebp]
	push	eax
	call	_xmlHashAddEntry
	add	esp, 12					; 0000000cH

; 20830: 	if (err != 0) {

	test	eax, eax
	je	$LN2@xmlSchemaA

; 1429 :     return (xmlSchemaFormatQName(buf,

	push	esi

; 20831: 	    xmlChar *str = NULL;

	mov	DWORD PTR _str$1[ebp], 0

; 1429 :     return (xmlSchemaFormatQName(buf,

	call	_xmlSchemaGetComponentName
	add	esp, 4
	push	eax
	push	esi
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _str$1[ebp]
	push	eax
	call	_xmlSchemaFormatQName

; 20832: 
; 20833: 	    xmlSchemaCustomErr(ACTXT_CAST pctxt,

	push	esi

; 1429 :     return (xmlSchemaFormatQName(buf,

	mov	edi, eax

; 20832: 
; 20833: 	    xmlSchemaCustomErr(ACTXT_CAST pctxt,

	call	_xmlSchemaGetComponentTypeStr
	push	DWORD PTR _item$1$[ebp]
	mov	esi, eax
	call	_xmlSchemaGetComponentNode

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	0
	push	0
	push	edi
	push	esi
	push	OFFSET ??_C@_0CE@NEPGNBMH@A?5global?5?$CFs?5?8?$CFs?8?5does?5already?5e@
	push	DWORD PTR _item$1$[ebp]
	push	eax
	push	1761					; 000006e1H
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaCustomErr4

; 20834: 		XML_SCHEMAP_REDEFINED_TYPE,
; 20835: 		WXS_ITEM_NODE(item),
; 20836: 		WXS_BASIC_CAST item,
; 20837: 		"A global %s '%s' does already exist",
; 20838: 		WXS_ITEM_TYPE_NAME(item),
; 20839: 		xmlSchemaGetComponentQName(&str, item));
; 20840: 	    FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$1[ebp]

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	add	esp, 56					; 00000038H

; 20834: 		XML_SCHEMAP_REDEFINED_TYPE,
; 20835: 		WXS_ITEM_NODE(item),
; 20836: 		WXS_BASIC_CAST item,
; 20837: 		"A global %s '%s' does already exist",
; 20838: 		WXS_ITEM_TYPE_NAME(item),
; 20839: 		xmlSchemaGetComponentQName(&str, item));
; 20840: 	    FREE_AND_NULL(str);

	test	eax, eax
	je	SHORT $LN2@xmlSchemaA
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 20841: 	}
; 20842:     }

	jmp	SHORT $LN2@xmlSchemaA
$LN43@xmlSchemaA:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CB@EHOCOMPJ@Unexpected?5global?5component?5typ@
	push	OFFSET ??_C@_0BH@KEIDDOOE@xmlSchemaAddComponents@
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$LN2@xmlSchemaA:

; 20774: 
; 20775:     for (i = 0; i < bucket->globals->nbItems; i++) {

	mov	esi, DWORD PTR _i$1$[ebp]
	mov	eax, DWORD PTR [ebx+44]
	inc	esi
	mov	DWORD PTR _i$1$[ebp], esi
	cmp	esi, DWORD PTR [eax+4]
	jl	$LL4@xmlSchemaA
$LN70@xmlSchemaA:

; 20843:     /*
; 20844:     * Process imported/included schemas.
; 20845:     */
; 20846:     if (bucket->relations != NULL) {

	mov	esi, DWORD PTR [ebx+24]
	test	esi, esi
	je	SHORT $LN8@xmlSchemaA
	npad	2
$LL9@xmlSchemaA:

; 20847: 	xmlSchemaSchemaRelationPtr rel = bucket->relations;
; 20848: 	do {
; 20849: 	    if ((rel->bucket != NULL) &&

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN50@xmlSchemaA
	test	BYTE PTR [eax+4], 2
	jne	SHORT $LN50@xmlSchemaA

; 20850: 		((rel->bucket->flags & XML_SCHEMA_BUCKET_COMPS_ADDED) == 0)) {
; 20851: 		if (xmlSchemaAddComponents(pctxt, rel->bucket) == -1)

	push	eax
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaAddComponents
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN63@xmlSchemaA
$LN50@xmlSchemaA:

; 20852: 		    return(-1);
; 20853: 	    }
; 20854: 	    rel = rel->next;

	mov	esi, DWORD PTR [esi]

; 20855: 	} while (rel != NULL);

	test	esi, esi
	jne	SHORT $LL9@xmlSchemaA
$LN8@xmlSchemaA:
	pop	edi

; 20856:     }
; 20857:     return(0);
; 20858: }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN62@xmlSchemaA:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CI@HOKAKPAF@failed?5to?5create?5a?5component?5ha@
	push	OFFSET ??_C@_0BH@KEIDDOOE@xmlSchemaAddComponents@
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$LN63@xmlSchemaA:
	pop	edi

; 20856:     }
; 20857:     return(0);
; 20858: }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@xmlSchemaA:
	DD	$LN12@xmlSchemaA
	DD	$LN17@xmlSchemaA
	DD	$LN21@xmlSchemaA
	DD	$LN30@xmlSchemaA
	DD	$LN25@xmlSchemaA
	DD	$LN39@xmlSchemaA
	DD	$LN35@xmlSchemaA
	DD	$LN43@xmlSchemaA
$LN71@xmlSchemaA:
	DB	0
	DB	0
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	7
	DB	7
	DB	7
	DB	6
	DB	6
	DB	6
_xmlSchemaAddComponents ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckSRCRedefineSecond
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_xmlSchemaCheckSRCRedefineSecond PROC			; COMDAT

; 20667: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pctxt$[ebp]
	mov	esi, DWORD PTR [edi+28]
	mov	esi, DWORD PTR [esi+28]
	test	esi, esi
	je	SHORT $LN17@xmlSchemaC
	npad	4
$LL4@xmlSchemaC:

; 20668:     int err = 0;
; 20669:     xmlSchemaRedefPtr redef = WXS_CONSTRUCTOR(pctxt)->redefs;
; 20670:     xmlSchemaBasicItemPtr item;
; 20671: 
; 20672:     if (redef == NULL)
; 20673: 	return(0);
; 20674: 
; 20675:     do {
; 20676: 	if (redef->target == NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN13@xmlSchemaC

; 20677: 	    redef = redef->next;
; 20678: 	    continue;
; 20679: 	}
; 20680: 	item = redef->item;

	mov	edx, DWORD PTR [esi+4]

; 20681: 
; 20682: 	switch (item->type) {

	mov	ecx, DWORD PTR [edx]
	cmp	ecx, 4
	jl	SHORT $LN13@xmlSchemaC
	cmp	ecx, 5
	jle	SHORT $LN9@xmlSchemaC
	cmp	ecx, 16					; 00000010H
	jne	SHORT $LN13@xmlSchemaC

; 20690: 
; 20691: 		/*
; 20692: 		* TODO: Seems like there's nothing more to do. The normal
; 20693: 		* inheritance mechanism is used. But not 100% sure.
; 20694: 		*/
; 20695: 		break;
; 20696: 	    case XML_SCHEMA_TYPE_GROUP:
; 20697: 		/*
; 20698: 		* URGENT TODO:
; 20699: 		* SPEC src-redefine:
; 20700: 		* (6.2.2) "The {model group} of the model group definition
; 20701: 		* which corresponds to it per XML Representation of Model
; 20702: 		* Group Definition Schema Components ($3.7.2) must be a
; 20703: 		* `valid restriction` of the {model group} of that model
; 20704: 		* group definition in I, as defined in Particle Valid
; 20705: 		* (Restriction) ($3.9.6)."
; 20706: 		*/
; 20707: 		break;
; 20708: 	    case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 20709: 		/*
; 20710: 		* SPEC src-redefine:
; 20711: 		* (7.2.2) "The {attribute uses} and {attribute wildcard} of
; 20712: 		* the attribute group definition which corresponds to it
; 20713: 		* per XML Representation of Attribute Group Definition Schema
; 20714: 		* Components ($3.6.2) must be `valid restrictions` of the
; 20715: 		* {attribute uses} and {attribute wildcard} of that attribute
; 20716: 		* group definition in I, as defined in clause 2, clause 3 and
; 20717: 		* clause 4 of Derivation Valid (Restriction, Complex)
; 20718: 		* ($3.4.6) (where references to the base type definition are
; 20719: 		* understood as references to the attribute group definition
; 20720: 		* in I)."
; 20721: 		*/
; 20722: 		err = xmlSchemaCheckDerivationOKRestriction2to4(pctxt,

	push	DWORD PTR [eax+40]
	push	DWORD PTR [edx+40]
	push	DWORD PTR [eax+56]
	push	DWORD PTR [edx+56]
	push	eax
	push	edx
	push	1
	push	edi
	call	_xmlSchemaCheckDerivationOKRestriction2to4
	add	esp, 32					; 00000020H

; 20723: 		    XML_SCHEMA_ACTION_REDEFINE,
; 20724: 		    item, redef->target,
; 20725: 		    (WXS_ATTR_GROUP_CAST item)->attrUses,
; 20726: 		    (WXS_ATTR_GROUP_CAST redef->target)->attrUses,
; 20727: 		    (WXS_ATTR_GROUP_CAST item)->attributeWildcard,
; 20728: 		    (WXS_ATTR_GROUP_CAST redef->target)->attributeWildcard);
; 20729: 		if (err == -1)

	cmp	eax, -1
	jne	SHORT $LN13@xmlSchemaC

; 20730: 		    return(-1);

	pop	edi
	or	eax, eax

; 20738: }

	pop	esi
	pop	ebp
	ret	0
$LN9@xmlSchemaC:

; 20683: 	    case XML_SCHEMA_TYPE_SIMPLE:
; 20684: 	    case XML_SCHEMA_TYPE_COMPLEX:
; 20685: 		/*
; 20686: 		* Since the spec wants the {name} of the redefined
; 20687: 		* type to be 'absent', we'll NULL it.
; 20688: 		*/
; 20689: 		(WXS_TYPE_CAST redef->target)->name = NULL;

	mov	DWORD PTR [eax+8], 0
$LN13@xmlSchemaC:

; 20731: 		break;
; 20732: 	    default:
; 20733: 		break;
; 20734: 	}
; 20735: 	redef = redef->next;
; 20736:     } while (redef != NULL);

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL4@xmlSchemaC
$LN17@xmlSchemaC:
	pop	edi

; 20737:     return(0);

	xor	eax, eax

; 20738: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaCheckSRCRedefineSecond ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckSRCRedefineFirst
_TEXT	SEGMENT
_str$1 = -12						; size = 4
_str$2 = -12						; size = 4
_node$1$ = -8						; size = 4
_prev$1$ = -8						; size = 4
_msg$3 = -4						; size = 4
_msg$4 = -4						; size = 4
_err$1$ = -4						; size = 4
_pctxt$ = 8						; size = 4
_xmlSchemaCheckSRCRedefineFirst PROC			; COMDAT

; 20492: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _pctxt$[ebp]
	mov	DWORD PTR _err$1$[ebp], 0
	mov	esi, DWORD PTR [ebx+28]
	mov	esi, DWORD PTR [esi+28]
	test	esi, esi
	jne	SHORT $LN67@xmlSchemaC

; 20493:     int err = 0;
; 20494:     xmlSchemaRedefPtr redef = WXS_CONSTRUCTOR(pctxt)->redefs;
; 20495:     xmlSchemaBasicItemPtr prev, item;
; 20496:     int wasRedefined;
; 20497: 
; 20498:     if (redef == NULL)
; 20499: 	return(0);

	pop	esi
	xor	eax, eax

; 20661: 
; 20662:     return(err);
; 20663: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN67@xmlSchemaC:
	push	edi
	npad	1
$LL4@xmlSchemaC:

; 20500: 
; 20501:     do {
; 20502: 	item = redef->item;
; 20503: 	/*
; 20504: 	* First try to locate the redefined component in the
; 20505: 	* schema graph starting with the redefined schema.
; 20506: 	* NOTE: According to this schema bug entry:
; 20507: 	*   http://lists.w3.org/Archives/Public/www-xml-schema-comments/2005OctDec/0019.html
; 20508: 	*   it's not clear if the referenced component needs to originate
; 20509: 	*   from the <redefine>d schema _document_ or the schema; the latter
; 20510: 	*   would include all imported and included sub-schemas of the
; 20511: 	*   <redefine>d schema. Currenlty we latter approach is used.
; 20512: 	*   SUPPLEMENT: It seems that the WG moves towards the latter
; 20513: 	*   approach, so we are doing it right.
; 20514: 	*
; 20515: 	*/
; 20516: 	prev = xmlSchemaFindRedefCompInGraph(

	push	DWORD PTR [esi+20]
	mov	edi, DWORD PTR [esi+4]
	push	DWORD PTR [esi+16]
	push	DWORD PTR [edi]
	push	DWORD PTR [esi+24]
	call	_xmlSchemaFindRedefCompInGraph
	mov	ecx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _prev$1$[ebp], ecx

; 20517: 	    redef->targetBucket, item->type,
; 20518: 	    redef->refName, redef->refTargetNs);
; 20519: 	if (prev == NULL) {

	test	ecx, ecx
	jne	$LN8@xmlSchemaC

; 20520: 	    xmlChar *str = NULL;

	mov	DWORD PTR _str$2[ebp], eax

; 20521: 	    xmlNodePtr node;
; 20522: 
; 20523: 	    /*
; 20524: 	    * SPEC src-redefine:
; 20525: 	    * (6.2.1) "The `actual value` of its own name attribute plus
; 20526: 	    * target namespace must successfully `resolve` to a model
; 20527: 	    * group definition in I."
; 20528: 	    * (7.2.1) "The `actual value` of its own name attribute plus
; 20529: 	    * target namespace must successfully `resolve` to an attribute
; 20530: 	    * group definition in I."
; 20531: 
; 20532: 	    *
; 20533: 	    * Note that, if we are redefining with the use of references
; 20534: 	    * to components, the spec assumes the src-resolve to be used;
; 20535: 	    * but this won't assure that we search only *inside* the
; 20536: 	    * redefined schema.
; 20537: 	    */
; 20538: 	    if (redef->reference)

	mov	ecx, edi
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	cmovne	ecx, eax

; 1183 :     switch (item->type) {

	push	ecx
	call	_xmlSchemaGetComponentNode
	mov	ecx, DWORD PTR [edi]
	add	esp, 4
	mov	DWORD PTR _node$1$[ebp], eax
	mov	eax, ecx
	sub	eax, 1
	je	SHORT $LN30@xmlSchemaC

; 1186 : 		return(BAD_CAST "complex type definition");
; 1187 : 	    else
; 1188 : 		return(BAD_CAST "simple type definition");
; 1189 : 	default:
; 1190 : 	    return(xmlSchemaItemTypeToStr(item->type));

	push	ecx
	call	_xmlSchemaItemTypeToStr
	add	esp, 4
	mov	ebx, eax
	jmp	SHORT $LN33@xmlSchemaC
$LN30@xmlSchemaC:

; 1184 : 	case XML_SCHEMA_TYPE_BASIC:
; 1185 : 	    if (WXS_IS_COMPLEX(WXS_TYPE_CAST item))

	cmp	DWORD PTR [edi+88], 45			; 0000002dH
	mov	ebx, OFFSET ??_C@_0BH@BIKOCJPH@simple?5type?5definition@
	mov	eax, OFFSET ??_C@_0BI@MHGDJJNC@complex?5type?5definition@
	cmove	ebx, eax
$LN33@xmlSchemaC:

; 20539: 		node = WXS_ITEM_NODE(redef->reference);
; 20540: 	    else
; 20541: 		node = WXS_ITEM_NODE(item);
; 20542: 	    xmlSchemaCustomErr(ACTXT_CAST pctxt,

	push	DWORD PTR [esi+16]
	lea	eax, DWORD PTR _str$2[ebp]
	push	DWORD PTR [esi+20]
	push	eax
	call	_xmlSchemaFormatQName

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	DWORD PTR _node$1$[ebp]

; 20539: 		node = WXS_ITEM_NODE(redef->reference);
; 20540: 	    else
; 20541: 		node = WXS_ITEM_NODE(item);
; 20542: 	    xmlSchemaCustomErr(ACTXT_CAST pctxt,

	mov	edi, eax

; 2339 :     xmlChar *msg = NULL;

	mov	DWORD PTR _msg$4[ebp], 0

; 2340 : 
; 2341 :     if ((node == NULL) && (item != NULL) &&
; 2342 : 	(actxt->type == XML_SCHEMA_CTXT_PARSER)) {
; 2343 : 	node = WXS_ITEM_NODE(item);
; 2344 : 	xmlSchemaFormatItemForReport(&msg, NULL, item, NULL);
; 2345 : 	msg = xmlStrcat(msg, BAD_CAST ": ");
; 2346 :     } else
; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	DWORD PTR _pctxt$[ebp]
	lea	eax, DWORD PTR _msg$4[ebp]
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0EH@DMAILEC@The?5?$CFs?5?8?$CFs?8?5to?5be?5redefined?5cou@
	push	DWORD PTR _msg$4[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$4[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	edi
	push	ebx
	push	eax
	push	0
	push	DWORD PTR _node$1$[ebp]

; 20543: 		/*
; 20544: 		* TODO: error code.
; 20545: 		* Probably XML_SCHEMAP_SRC_RESOLVE, if this is using the
; 20546: 		* reference kind.
; 20547: 		*/
; 20548: 		XML_SCHEMAP_SRC_REDEFINE, node, NULL,
; 20549: 		"The %s '%s' to be redefined could not be found in "
; 20550: 		"the redefined schema",
; 20551: 		WXS_ITEM_TYPE_NAME(item),
; 20552: 		xmlSchemaFormatQName(&str, redef->refTargetNs,
; 20553: 		    redef->refName));
; 20554: 	    FREE_AND_NULL(str);
; 20555: 	    err = pctxt->err;
; 20556: 	    redef = redef->next;
; 20557: 	    continue;

	jmp	$LN73@xmlSchemaC
$LN8@xmlSchemaC:

; 20558: 	}
; 20559: 	/*
; 20560: 	* TODO: Obtaining and setting the redefinition state is really
; 20561: 	* clumsy.
; 20562: 	*/
; 20563: 	wasRedefined = 0;
; 20564: 	switch (item->type) {

	mov	eax, DWORD PTR [edi]
	add	eax, -4					; fffffffcH
	cmp	eax, 13					; 0000000dH
	ja	$LN21@xmlSchemaC
	movzx	eax, BYTE PTR $LN64@xmlSchemaC[eax]
	jmp	DWORD PTR $LN76@xmlSchemaC[eax*4]
$LN12@xmlSchemaC:

; 20565: 	    case XML_SCHEMA_TYPE_COMPLEX:
; 20566: 	    case XML_SCHEMA_TYPE_SIMPLE:
; 20567: 		if ((WXS_TYPE_CAST prev)->flags &

	mov	eax, DWORD PTR [ecx+48]
	test	eax, 1073741824				; 40000000H
	jne	SHORT $LN61@xmlSchemaC

; 20568: 		    XML_SCHEMAS_TYPE_REDEFINED)
; 20569: 		{
; 20570: 		    wasRedefined = 1;
; 20571: 		    break;
; 20572: 		}
; 20573: 		/* Mark it as redefined. */
; 20574: 		(WXS_TYPE_CAST prev)->flags |= XML_SCHEMAS_TYPE_REDEFINED;

	or	eax, 1073741824				; 40000000H
	mov	DWORD PTR [ecx+48], eax

; 20647: 		/* TODO: error code. */
; 20648: 		XML_SCHEMAP_SRC_REDEFINE,
; 20649: 		node, NULL,
; 20650: 		"The referenced %s was already redefined. Multiple "
; 20651: 		"redefinition of the same component is not supported",
; 20652: 		xmlSchemaGetComponentDesignation(&str, prev),
; 20653: 		NULL);
; 20654: 	    FREE_AND_NULL(str)
; 20655: 	    err = pctxt->err;
; 20656: 	    redef = redef->next;
; 20657: 	    continue;
; 20658: 	}
; 20659: 	redef = redef->next;

	mov	eax, DWORD PTR _err$1$[ebp]
	mov	DWORD PTR [edi+64], ecx
	jmp	$LN74@xmlSchemaC
$LN14@xmlSchemaC:

; 20575: 		/*
; 20576: 		* Assign the redefined type to the
; 20577: 		* base type of the redefining type.
; 20578: 		* TODO: How
; 20579: 		*/
; 20580: 		((xmlSchemaTypePtr) item)->baseType =
; 20581: 		    (xmlSchemaTypePtr) prev;
; 20582: 		break;
; 20583: 	    case XML_SCHEMA_TYPE_GROUP:
; 20584: 		if ((WXS_MODEL_GROUPDEF_CAST prev)->flags &

	mov	eax, DWORD PTR [ecx+28]
	test	al, 2
	jne	SHORT $LN61@xmlSchemaC

; 20585: 		    XML_SCHEMA_MODEL_GROUP_DEF_REDEFINED)
; 20586: 		{
; 20587: 		    wasRedefined = 1;
; 20588: 		    break;
; 20589: 		}
; 20590: 		/* Mark it as redefined. */
; 20591: 		(WXS_MODEL_GROUPDEF_CAST prev)->flags |=

	or	eax, 2
	mov	DWORD PTR [ecx+28], eax

; 20592: 		    XML_SCHEMA_MODEL_GROUP_DEF_REDEFINED;
; 20593: 		if (redef->reference != NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN19@xmlSchemaC

; 20594: 		    /*
; 20595: 		    * Overwrite the QName-reference with the
; 20596: 		    * referenced model group def.
; 20597: 		    */
; 20598: 		    (WXS_PTC_CAST redef->reference)->children =

	mov	DWORD PTR [eax+12], ecx
$LN19@xmlSchemaC:

; 20647: 		/* TODO: error code. */
; 20648: 		XML_SCHEMAP_SRC_REDEFINE,
; 20649: 		node, NULL,
; 20650: 		"The referenced %s was already redefined. Multiple "
; 20651: 		"redefinition of the same component is not supported",
; 20652: 		xmlSchemaGetComponentDesignation(&str, prev),
; 20653: 		NULL);
; 20654: 	    FREE_AND_NULL(str)
; 20655: 	    err = pctxt->err;
; 20656: 	    redef = redef->next;
; 20657: 	    continue;
; 20658: 	}
; 20659: 	redef = redef->next;

	mov	eax, DWORD PTR _err$1$[ebp]
	mov	DWORD PTR [esi+12], ecx
	jmp	$LN74@xmlSchemaC
$LN17@xmlSchemaC:

; 20599: 			WXS_TREE_CAST prev;
; 20600: 		}
; 20601: 		redef->target = prev;
; 20602: 		break;
; 20603: 	    case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 20604: 		if ((WXS_ATTR_GROUP_CAST prev)->flags &

	mov	eax, DWORD PTR [ecx+36]
	test	al, 8
	jne	SHORT $LN61@xmlSchemaC

; 20605: 		    XML_SCHEMAS_ATTRGROUP_REDEFINED)
; 20606: 		{
; 20607: 		    wasRedefined = 1;
; 20608: 		    break;
; 20609: 		}
; 20610: 		(WXS_ATTR_GROUP_CAST prev)->flags |=

	or	eax, 8
	mov	DWORD PTR [ecx+36], eax

; 20611: 		    XML_SCHEMAS_ATTRGROUP_REDEFINED;
; 20612: 		if (redef->reference != NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN19@xmlSchemaC

; 20613: 		    /*
; 20614: 		    * Assign the redefined attribute group to the
; 20615: 		    * QName-reference component.
; 20616: 		    * This is the easy case, since we will just
; 20617: 		    * expand the redefined group.
; 20618: 		    */
; 20619: 		    (WXS_QNAME_CAST redef->reference)->item = prev;

	mov	DWORD PTR [eax+4], ecx

; 20647: 		/* TODO: error code. */
; 20648: 		XML_SCHEMAP_SRC_REDEFINE,
; 20649: 		node, NULL,
; 20650: 		"The referenced %s was already redefined. Multiple "
; 20651: 		"redefinition of the same component is not supported",
; 20652: 		xmlSchemaGetComponentDesignation(&str, prev),
; 20653: 		NULL);
; 20654: 	    FREE_AND_NULL(str)
; 20655: 	    err = pctxt->err;
; 20656: 	    redef = redef->next;
; 20657: 	    continue;
; 20658: 	}
; 20659: 	redef = redef->next;

	mov	eax, DWORD PTR _err$1$[ebp]
	mov	DWORD PTR [esi+12], 0
	jmp	$LN74@xmlSchemaC
$LN61@xmlSchemaC:

; 20636: 	}
; 20637: 	if (wasRedefined) {
; 20638: 	    xmlChar *str = NULL;
; 20639: 	    xmlNodePtr node;
; 20640: 
; 20641: 	    if (redef->reference)

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _str$1[ebp], 0
	test	eax, eax
	jne	SHORT $LN24@xmlSchemaC

; 20642: 		node = WXS_ITEM_NODE(redef->reference);
; 20643: 	    else
; 20644: 		node = WXS_ITEM_NODE(redef->item);

	mov	eax, DWORD PTR [esi+4]
$LN24@xmlSchemaC:

; 20645: 
; 20646: 	    xmlSchemaCustomErr(ACTXT_CAST pctxt,

	push	eax
	call	_xmlSchemaGetComponentNode
	push	DWORD PTR _prev$1$[ebp]
	mov	ebx, eax
	lea	eax, DWORD PTR _str$1[ebp]
	push	eax
	call	_xmlSchemaGetComponentDesignation

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	ebx
	push	DWORD PTR _pctxt$[ebp]

; 20645: 
; 20646: 	    xmlSchemaCustomErr(ACTXT_CAST pctxt,

	mov	edi, eax

; 2339 :     xmlChar *msg = NULL;

	mov	DWORD PTR _msg$3[ebp], 0

; 2340 : 
; 2341 :     if ((node == NULL) && (item != NULL) &&
; 2342 : 	(actxt->type == XML_SCHEMA_CTXT_PARSER)) {
; 2343 : 	node = WXS_ITEM_NODE(item);
; 2344 : 	xmlSchemaFormatItemForReport(&msg, NULL, item, NULL);
; 2345 : 	msg = xmlStrcat(msg, BAD_CAST ": ");
; 2346 :     } else
; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	lea	eax, DWORD PTR _msg$3[ebp]
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0GG@OLGKEPPA@The?5referenced?5?$CFs?5was?5already?5r@
	push	DWORD PTR _msg$3[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$3[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	edi
	push	eax
	push	0
	push	ebx
$LN73@xmlSchemaC:

; 20660:     } while (redef != NULL);

	mov	ebx, DWORD PTR _pctxt$[ebp]
	push	3081					; 00000c09H
	push	2
	push	ebx
	mov	DWORD PTR _msg$3[ebp], eax
	call	_xmlSchemaErr4Line
	mov	eax, DWORD PTR _msg$3[ebp]
	add	esp, 80					; 00000050H
	test	eax, eax
	je	SHORT $LN52@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN52@xmlSchemaC:
	mov	eax, DWORD PTR _str$1[ebp]
	test	eax, eax
	je	SHORT $LN25@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN25@xmlSchemaC:
	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR _err$1$[ebp], eax
$LN74@xmlSchemaC:
	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	$LL4@xmlSchemaC

; 20661: 
; 20662:     return(err);
; 20663: }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlSchemaC:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CE@NJALEOMP@Unexpected?5redefined?5component?5@
	push	OFFSET ??_C@_0CA@MJPJGEAA@xmlSchemaResolveRedefReferences@
	push	ebx
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 20620: 		    redef->target = NULL;
; 20621: 		} else {
; 20622: 		    /*
; 20623: 		    * This is the complicated case: we need
; 20624: 		    * to apply src-redefine (7.2.2) at a later
; 20625: 		    * stage, i.e. when attribute group references
; 20626: 		    * have beed expanded and simple types have
; 20627: 		    * beed fixed.
; 20628: 		    */
; 20629: 		    redef->target = prev;
; 20630: 		}
; 20631: 		break;
; 20632: 	    default:
; 20633: 		PERROR_INT("xmlSchemaResolveRedefReferences",
; 20634: 		    "Unexpected redefined component type");
; 20635: 		return(-1);

	or	eax, -1
	pop	edi
	pop	esi

; 20661: 
; 20662:     return(err);
; 20663: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN76@xmlSchemaC:
	DD	$LN12@xmlSchemaC
	DD	$LN17@xmlSchemaC
	DD	$LN14@xmlSchemaC
	DD	$LN21@xmlSchemaC
$LN64@xmlSchemaC:
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	2
_xmlSchemaCheckSRCRedefineFirst ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaResolveAttrUseProhibReferences
_TEXT	SEGMENT
_prohib$ = 8						; size = 4
_pctxt$ = 12						; size = 4
_xmlSchemaResolveAttrUseProhibReferences PROC		; COMDAT

; 20467: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _prohib$[ebp]
	mov	edi, DWORD PTR _pctxt$[ebp]
	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [edi+36]
	call	_xmlSchemaGetAttributeDecl
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaR

; 20468:     if (xmlSchemaGetAttributeDecl(pctxt->schema, prohib->name,
; 20469: 	prohib->targetNamespace) == NULL) {
; 20470: 
; 20471: 	xmlSchemaPResCompAttrErr(pctxt,

	push	eax
	push	15					; 0000000fH
	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	DWORD PTR [esi+4]
	push	eax
	push	3004					; 00000bbcH
	push	edi
	call	_xmlSchemaPResCompAttrErr
	add	esp, 36					; 00000024H

; 20472: 	    XML_SCHEMAP_SRC_RESOLVE,
; 20473: 	    NULL, prohib->node,
; 20474: 	    "ref", prohib->name, prohib->targetNamespace,
; 20475: 	    XML_SCHEMA_TYPE_ATTRIBUTE, NULL);
; 20476: 	return(XML_SCHEMAP_SRC_RESOLVE);

	mov	eax, 3004				; 00000bbcH
	pop	edi

; 20479: }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlSchemaR:
	pop	edi

; 20477:     }
; 20478:     return(0);

	xor	eax, eax

; 20479: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaResolveAttrUseProhibReferences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaResolveIDCKeyReferences
_TEXT	SEGMENT
_nsName$1$ = -8						; size = 4
_name$1$ = -4						; size = 4
_schema$1$ = 8						; size = 4
_str$1 = 8						; size = 4
_idc$ = 8						; size = 4
_pctxt$ = 12						; size = 4
_xmlSchemaResolveIDCKeyReferences PROC			; COMDAT

; 20405: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _idc$[ebp]
	cmp	DWORD PTR [esi], 24			; 00000018H
	jne	$LN8@xmlSchemaR

; 20406:     if (idc->type != XML_SCHEMA_TYPE_IDC_KEYREF)
; 20407:         return(0);
; 20408:     if (idc->ref->name != NULL) {

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _name$1$[ebp], ecx
	test	ecx, ecx
	je	$LN8@xmlSchemaR

; 20409: 	idc->ref->item = (xmlSchemaBasicItemPtr)

	mov	edi, DWORD PTR _pctxt$[ebp]
	mov	edx, DWORD PTR [eax+16]
	push	ebx

; 4983 :     xmlSchemaIDCPtr ret = NULL;

	xor	ebx, ebx

; 20409: 	idc->ref->item = (xmlSchemaBasicItemPtr)

	mov	DWORD PTR _nsName$1$[ebp], edx
	mov	ecx, DWORD PTR [edi+36]
	mov	DWORD PTR _schema$1$[ebp], ecx

; 4985 :     if ((name == NULL) || (schema == NULL))

	test	ecx, ecx
	je	SHORT $LN13@xmlSchemaR

; 4987 :     if (schema != NULL) {
; 4988 : 	WXS_FIND_GLOBAL_ITEM(idcDef)

	push	DWORD PTR [ecx+4]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlSchemaR
	mov	eax, DWORD PTR _schema$1$[ebp]
	push	DWORD PTR _name$1$[ebp]
	push	DWORD PTR [eax+76]
	call	_xmlHashLookup
	mov	ebx, eax
	add	esp, 8
	test	ebx, ebx
	jne	SHORT $exit$25
$LN16@xmlSchemaR:
	mov	eax, DWORD PTR _schema$1$[ebp]
	push	DWORD PTR [eax+48]
	call	_xmlHashSize
	add	esp, 4
	cmp	eax, 1
	jle	SHORT $exit$25
	mov	ecx, DWORD PTR _nsName$1$[ebp]
	mov	eax, OFFSET ??_C@_02IEBMKJDF@?$CD?$CD@
	test	ecx, ecx
	cmovne	eax, ecx
	push	eax
	mov	eax, DWORD PTR _schema$1$[ebp]
	push	DWORD PTR [eax+48]
	call	_xmlHashLookup
	add	esp, 8
	test	eax, eax
	je	SHORT $exit$25
	mov	eax, DWORD PTR [eax+52]
	push	DWORD PTR _name$1$[ebp]
	push	DWORD PTR [eax+76]
	call	_xmlHashLookup
	add	esp, 8
	mov	ebx, eax
$exit$25:

; 4989 :     }
; 4990 : exit:
; 4991 :     return (ret);

	mov	eax, DWORD PTR [esi+36]
	jmp	SHORT $LN11@xmlSchemaR
$LN13@xmlSchemaR:

; 4986 :         return (NULL);

	xor	ebx, ebx
$LN11@xmlSchemaR:

; 20409: 	idc->ref->item = (xmlSchemaBasicItemPtr)

	mov	DWORD PTR [eax+4], ebx

; 20410: 	    xmlSchemaGetIDC(pctxt->schema, idc->ref->name,
; 20411: 		idc->ref->targetNamespace);
; 20412:         if (idc->ref->item == NULL) {

	mov	edx, DWORD PTR [esi+36]
	pop	ebx
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	jne	SHORT $LN4@xmlSchemaR

; 20413: 	    /*
; 20414: 	    * TODO: It is actually not an error to fail to resolve
; 20415: 	    * at this stage. BUT we need to be that strict!
; 20416: 	    */
; 20417: 	    xmlSchemaPResCompAttrErr(pctxt,

	push	ecx
	push	23					; 00000017H
	push	DWORD PTR [edx+16]
	push	DWORD PTR [edx+12]
	push	OFFSET ??_C@_05BEFNLAML@refer@
	push	DWORD PTR [esi+12]
	push	esi
	push	3004					; 00000bbcH
	push	edi
	call	_xmlSchemaPResCompAttrErr

; 20418: 		XML_SCHEMAP_SRC_RESOLVE,
; 20419: 		WXS_BASIC_CAST idc, idc->node,
; 20420: 		"refer", idc->ref->name,
; 20421: 		idc->ref->targetNamespace,
; 20422: 		XML_SCHEMA_TYPE_IDC_KEY, NULL);
; 20423:             return(pctxt->err);

	mov	eax, DWORD PTR [edi+16]
	add	esp, 36					; 00000024H
	pop	edi

; 20462: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlSchemaR:

; 20424: 	} else if (idc->ref->item->type == XML_SCHEMA_TYPE_IDC_KEYREF) {

	cmp	DWORD PTR [ecx], 24			; 00000018H
	jne	SHORT $LN6@xmlSchemaR

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BP@JCIFOLN@The?5keyref?5references?5a?5keyref@
	push	esi
	push	0
	push	3080					; 00000c08H
	push	edi
	call	_xmlSchemaCustomErr4

; 20425: 	    /*
; 20426: 	    * SPEC c-props-correct (1)
; 20427: 	    */
; 20428: 	    xmlSchemaCustomErr(ACTXT_CAST pctxt,
; 20429: 		XML_SCHEMAP_C_PROPS_CORRECT,
; 20430: 		NULL, WXS_BASIC_CAST idc,
; 20431: 		"The keyref references a keyref",
; 20432: 		NULL, NULL);
; 20433: 	    idc->ref->item = NULL;

	mov	eax, DWORD PTR [esi+36]

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	add	esp, 36					; 00000024H

; 20425: 	    /*
; 20426: 	    * SPEC c-props-correct (1)
; 20427: 	    */
; 20428: 	    xmlSchemaCustomErr(ACTXT_CAST pctxt,
; 20429: 		XML_SCHEMAP_C_PROPS_CORRECT,
; 20430: 		NULL, WXS_BASIC_CAST idc,
; 20431: 		"The keyref references a keyref",
; 20432: 		NULL, NULL);
; 20433: 	    idc->ref->item = NULL;

	mov	DWORD PTR [eax+4], 0

; 20434: 	    return(pctxt->err);

	mov	eax, DWORD PTR [edi+16]
	pop	edi

; 20462: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlSchemaR:

; 20435: 	} else {
; 20436: 	    if (idc->nbFields !=

	mov	eax, DWORD PTR [esi+32]
	cmp	eax, DWORD PTR [ecx+32]
	je	SHORT $LN8@xmlSchemaR

; 20437: 		((xmlSchemaIDCPtr) idc->ref->item)->nbFields) {
; 20438: 		xmlChar *str = NULL;
; 20439: 		xmlSchemaIDCPtr refer;
; 20440: 
; 20441: 		refer = (xmlSchemaIDCPtr) idc->ref->item;
; 20442: 		/*
; 20443: 		* SPEC c-props-correct(2)
; 20444: 		* "If the {identity-constraint category} is keyref,
; 20445: 		* the cardinality of the {fields} must equal that of
; 20446: 		* the {fields} of the {referenced key}.
; 20447: 		*/
; 20448: 		xmlSchemaCustomErr(ACTXT_CAST pctxt,

	push	0
	push	DWORD PTR [ecx+16]
	lea	eax, DWORD PTR _str$1[ebp]
	mov	DWORD PTR _str$1[ebp], 0
	push	DWORD PTR [ecx+20]
	push	eax
	call	_xmlSchemaFormatQName
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0FN@FJLAHNCH@The?5cardinality?5of?5the?5keyref?5d@
	push	esi
	push	0
	push	3080					; 00000c08H
	push	edi
	call	_xmlSchemaCustomErr

; 20449: 		    XML_SCHEMAP_C_PROPS_CORRECT,
; 20450: 		    NULL, WXS_BASIC_CAST idc,
; 20451: 		    "The cardinality of the keyref differs from the "
; 20452: 		    "cardinality of the referenced key/unique '%s'",
; 20453: 		    xmlSchemaFormatQName(&str, refer->targetNamespace,
; 20454: 			refer->name),
; 20455: 		    NULL);
; 20456: 		FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$1[ebp]
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	SHORT $LN9@xmlSchemaR
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlSchemaR:

; 20457: 		return(pctxt->err);

	mov	eax, DWORD PTR [edi+16]
	pop	edi

; 20462: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlSchemaR:
	pop	edi

; 20458: 	    }
; 20459: 	}
; 20460:     }
; 20461:     return(0);

	xor	eax, eax

; 20462: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaResolveIDCKeyReferences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaResolveAttrTypeReferences
_TEXT	SEGMENT
_item$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_xmlSchemaResolveAttrTypeReferences PROC		; COMDAT

; 20356: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [esi+60]
	test	eax, 256				; 00000100H
	jne	SHORT $LN11@xmlSchemaR

; 20357:     /*
; 20358:     * The simple type definition corresponding to the <simpleType> element
; 20359:     * information item in the [children], if present, otherwise the simple
; 20360:     * type definition `resolved` to by the `actual value` of the type
; 20361:     * [attribute], if present, otherwise the `simple ur-type definition`.
; 20362:     */
; 20363:     if (item->flags & XML_SCHEMAS_ATTR_INTERNAL_RESOLVED)
; 20364: 	return(0);
; 20365:     item->flags |= XML_SCHEMAS_ATTR_INTERNAL_RESOLVED;
; 20366:     if (item->subtypes != NULL)

	or	eax, 256				; 00000100H
	cmp	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+60], eax
	jne	SHORT $LN11@xmlSchemaR

; 20368:     if (item->typeName != NULL) {

	mov	eax, DWORD PTR [esi+24]
	push	edi
	test	eax, eax
	je	SHORT $LN4@xmlSchemaR

; 20369:         xmlSchemaTypePtr type;
; 20370: 
; 20371: 	type = xmlSchemaGetType(ctxt->schema, item->typeName,

	push	DWORD PTR [esi+28]
	mov	edi, DWORD PTR _ctxt$[ebp]
	push	eax
	push	DWORD PTR [edi+36]
	call	_xmlSchemaGetType
	add	esp, 12					; 0000000cH

; 20372: 	    item->typeNs);
; 20373: 	if ((type == NULL) || (! WXS_IS_SIMPLE(type))) {

	test	eax, eax
	je	SHORT $LN9@xmlSchemaR
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	SHORT $LN5@xmlSchemaR
	cmp	ecx, 1
	jne	SHORT $LN9@xmlSchemaR
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	jne	SHORT $LN5@xmlSchemaR
$LN9@xmlSchemaR:

; 20374: 	    xmlSchemaPResCompAttrErr(ctxt,

	push	0
	push	4
	push	DWORD PTR [esi+28]
	push	DWORD PTR [esi+24]
	push	OFFSET ??_C@_04GPMDFGEJ@type@
	push	DWORD PTR [esi+52]
	push	esi
	push	3004					; 00000bbcH
	push	edi
	call	_xmlSchemaPResCompAttrErr

; 20375: 		XML_SCHEMAP_SRC_RESOLVE,
; 20376: 		WXS_BASIC_CAST item, item->node,
; 20377: 		"type", item->typeName, item->typeNs,
; 20378: 		XML_SCHEMA_TYPE_SIMPLE, NULL);
; 20379: 	    return(ctxt->err);

	mov	eax, DWORD PTR [edi+16]
	add	esp, 36					; 00000024H
	pop	edi
	pop	esi

; 20390: }

	pop	ebp
	ret	0
$LN4@xmlSchemaR:

; 20380: 	} else
; 20381: 	    item->subtypes = type;
; 20382: 
; 20383:     } else {
; 20384: 	/*
; 20385: 	* The type defaults to the xs:anySimpleType.
; 20386: 	*/
; 20387: 	item->subtypes = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);

	push	46					; 0000002eH
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
$LN5@xmlSchemaR:

; 20388:     }
; 20389:     return(0);

	mov	DWORD PTR [esi+48], eax
	xor	eax, eax
	pop	edi
	pop	esi

; 20390: }

	pop	ebp
	ret	0
$LN11@xmlSchemaR:

; 20367:         return(0);

	xor	eax, eax
	pop	esi

; 20390: }

	pop	ebp
	ret	0
_xmlSchemaResolveAttrTypeReferences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckAttrUsePropsCorrect
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_use$ = 12						; size = 4
_xmlSchemaCheckAttrUsePropsCorrect PROC			; COMDAT

; 20247: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN3@xmlSchemaC

; 20248:     if ((ctxt == NULL) || (use == NULL))

	mov	esi, DWORD PTR _use$[ebp]
	test	esi, esi
	je	$LN3@xmlSchemaC

; 20250:     if ((use->defValue == NULL) || (WXS_ATTRUSE_DECL(use) == NULL) ||

	cmp	DWORD PTR [esi+28], 0
	je	$LN5@xmlSchemaC
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	$LN5@xmlSchemaC
	cmp	DWORD PTR [eax], 15			; 0000000fH
	jne	$LN5@xmlSchemaC

; 20253: 
; 20254:     /*
; 20255:     * SPEC au-props-correct (1)
; 20256:     * "The values of the properties of an attribute use must be as
; 20257:     * described in the property tableau in The Attribute Use Schema
; 20258:     * Component ($3.5.1), modulo the impact of Missing
; 20259:     * Sub-components ($5.3)."
; 20260:     */
; 20261: 
; 20262:     if (((WXS_ATTRUSE_DECL(use))->defValue != NULL) &&
; 20263: 	((WXS_ATTRUSE_DECL(use))->flags & XML_SCHEMAS_ATTR_FIXED) &&

	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN6@xmlSchemaC
	test	DWORD PTR [eax+60], 512			; 00000200H
	je	SHORT $LN6@xmlSchemaC
	test	BYTE PTR [esi+16], 1
	jne	SHORT $LN6@xmlSchemaC

; 20264:         ((use->flags & XML_SCHEMA_ATTR_USE_FIXED) == 0))
; 20265:     {
; 20266: 	xmlSchemaPCustomErr(ctxt,

	push	0
	push	OFFSET ??_C@_0HM@EHFKHNMB@The?5attribute?5declaration?5has?5a@
	push	0
	push	esi
	push	3078					; 00000c06H
	push	edi
	call	_xmlSchemaPCustomErr

; 20267: 	    XML_SCHEMAP_AU_PROPS_CORRECT_2,
; 20268: 	    WXS_BASIC_CAST use, NULL,
; 20269: 	    "The attribute declaration has a 'fixed' value constraint "
; 20270: 	    ", thus the attribute use must also have a 'fixed' value "
; 20271: 	    "constraint",
; 20272: 	    NULL);
; 20273: 	return(ctxt->err);

	mov	eax, DWORD PTR [edi+16]
	add	esp, 24					; 00000018H
	pop	edi

; 20341: }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlSchemaC:

; 20274:     }
; 20275:     /*
; 20276:     * Compute and check the value constraint's value.
; 20277:     */
; 20278:     if ((use->defVal != NULL) && (WXS_ATTRUSE_TYPEDEF(use) != NULL)) {

	cmp	DWORD PTR [esi+32], 0
	push	ebx
	lea	ebx, DWORD PTR [esi+32]
	je	$LN9@xmlSchemaC
	mov	eax, DWORD PTR [eax+48]
	test	eax, eax
	je	SHORT $LN9@xmlSchemaC

; 20279: 	int ret;
; 20280: 	/*
; 20281: 	* TODO: The spec seems to be missing a check of the
; 20282: 	* value constraint of the attribute use. We will do it here.
; 20283: 	*/
; 20284: 	/*
; 20285: 	* SPEC a-props-correct (3)
; 20286: 	*/
; 20287: 	if (xmlSchemaIsDerivedFromBuiltInType(

	push	23					; 00000017H
	push	eax
	call	_xmlSchemaIsDerivedFromBuiltInType
	add	esp, 8
	push	0
	test	eax, eax
	je	SHORT $LN8@xmlSchemaC

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0FF@JBDCKHFC@Value?5constraints?5are?5not?5allow@

; 20288: 	    WXS_ATTRUSE_TYPEDEF(use), XML_SCHEMAS_ID))
; 20289: 	{
; 20290: 	    xmlSchemaCustomErr(ACTXT_CAST ctxt,
; 20291: 		XML_SCHEMAP_AU_PROPS_CORRECT,
; 20292: 		NULL, WXS_BASIC_CAST use,
; 20293: 		"Value constraints are not allowed if the type definition "
; 20294: 		"is or is derived from xs:ID",
; 20295: 		NULL, NULL);
; 20296: 	    return(ctxt->err);

	jmp	SHORT $LN19@xmlSchemaC
$LN8@xmlSchemaC:

; 20297: 	}
; 20298: 
; 20299: 	ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST ctxt,

	mov	eax, DWORD PTR [esi+12]
	push	1
	push	1
	push	ebx
	push	DWORD PTR [esi+28]
	push	DWORD PTR [eax+48]
	push	DWORD PTR [esi+20]
	push	edi
	call	_xmlSchemaVCheckCVCSimpleType
	add	esp, 32					; 00000020H

; 20300: 	    use->node, WXS_ATTRUSE_TYPEDEF(use),
; 20301: 	    use->defValue, &(use->defVal),
; 20302: 	    1, 1, 0);
; 20303: 	if (ret != 0) {

	test	eax, eax
	je	SHORT $LN9@xmlSchemaC

; 20304: 	    if (ret < 0) {

	jns	SHORT $LN10@xmlSchemaC

; 20305: 		PERROR_INT2("xmlSchemaCheckAttrUsePropsCorrect",

	push	OFFSET ??_C@_0CH@HOPMNJDI@calling?5xmlSchemaVCheckCVCSimpl@
	push	OFFSET ??_C@_0CC@FBIHIMFL@xmlSchemaCheckAttrUsePropsCorre@
	push	edi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH

; 20306: 		    "calling xmlSchemaVCheckCVCSimpleType()");
; 20307: 		return(-1);

	or	eax, -1
	pop	ebx
	pop	edi

; 20341: }

	pop	esi
	pop	ebp
	ret	0
$LN10@xmlSchemaC:

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CP@DMDDKJIO@The?5value?5of?5the?5value?5constrai@
$LN19@xmlSchemaC:

; 20308: 	    }
; 20309: 	    xmlSchemaCustomErr(ACTXT_CAST ctxt,
; 20310: 		XML_SCHEMAP_AU_PROPS_CORRECT,
; 20311: 		NULL, WXS_BASIC_CAST use,
; 20312: 		"The value of the value constraint is not valid",
; 20313: 		NULL, NULL);
; 20314: 	    return(ctxt->err);

	push	esi
	push	0
	push	3089					; 00000c11H
	push	edi
	call	_xmlSchemaCustomErr4
	add	esp, 36					; 00000024H
$LN12@xmlSchemaC:
	mov	eax, DWORD PTR [edi+16]
	pop	ebx
	pop	edi

; 20341: }

	pop	esi
	pop	ebp
	ret	0
$LN9@xmlSchemaC:

; 20315: 	}
; 20316:     }
; 20317:     /*
; 20318:     * SPEC au-props-correct (2)
; 20319:     * "If the {attribute declaration} has a fixed
; 20320:     * {value constraint}, then if the attribute use itself has a
; 20321:     * {value constraint}, it must also be fixed and its value must match
; 20322:     * that of the {attribute declaration}'s {value constraint}."
; 20323:     */
; 20324:     if (((WXS_ATTRUSE_DECL(use))->defVal != NULL) &&

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [eax+68]
	test	ecx, ecx
	je	SHORT $LN11@xmlSchemaC
	test	BYTE PTR [eax+60], 1
	jne	SHORT $LN11@xmlSchemaC

; 20325: 	(((WXS_ATTRUSE_DECL(use))->flags & XML_SCHEMA_ATTR_USE_FIXED) == 0))
; 20326:     {
; 20327: 	if (! xmlSchemaAreValuesEqual(use->defVal,

	push	ecx
	push	DWORD PTR [ebx]
	call	_xmlSchemaAreValuesEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlSchemaC

; 20328: 		(WXS_ATTRUSE_DECL(use))->defVal))
; 20329: 	{
; 20330: 	    xmlSchemaPCustomErr(ctxt,

	mov	eax, DWORD PTR [esi+12]
	push	DWORD PTR [eax+44]
	push	OFFSET ??_C@_0GP@GLBEFPEK@The?5?8fixed?8?5value?5constraint?5of@
	push	0
	push	esi
	push	3078					; 00000c06H
	push	edi
	call	_xmlSchemaPCustomErr
	mov	eax, DWORD PTR [edi+16]
	add	esp, 24					; 00000018H
	pop	ebx
	pop	edi

; 20341: }

	pop	esi
	pop	ebp
	ret	0
$LN11@xmlSchemaC:
	pop	ebx
	pop	edi

; 20331: 		XML_SCHEMAP_AU_PROPS_CORRECT_2,
; 20332: 		WXS_BASIC_CAST use, NULL,
; 20333: 		"The 'fixed' value constraint of the attribute use "
; 20334: 		"must match the attribute declaration's value "
; 20335: 		"constraint '%s'",
; 20336: 		(WXS_ATTRUSE_DECL(use))->defValue);
; 20337: 	}
; 20338: 	return(ctxt->err);
; 20339:     }
; 20340:     return(0);

	xor	eax, eax

; 20341: }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlSchemaC:
	pop	edi

; 20251: 	((WXS_ATTRUSE_DECL(use))->type != XML_SCHEMA_TYPE_ATTRIBUTE))
; 20252: 	return(0);

	xor	eax, eax

; 20341: }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlSchemaC:
	pop	edi

; 20249: 	return(-1);

	or	eax, -1

; 20341: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaCheckAttrUsePropsCorrect ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaResolveAttrUseReferences
_TEXT	SEGMENT
_ause$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_xmlSchemaResolveAttrUseReferences PROC			; COMDAT

; 20207: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@xmlSchemaR

; 20208:     if ((ctxt == NULL) || (ause == NULL))

	mov	edi, DWORD PTR _ause$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlSchemaR

; 20210:     if ((ause->attrDecl == NULL) ||

	push	esi
	mov	esi, DWORD PTR [edi+12]
	test	esi, esi
	je	SHORT $LN5@xmlSchemaR
	cmp	DWORD PTR [esi], 2000			; 000007d0H
	jne	SHORT $LN5@xmlSchemaR

; 20213: 
; 20214:     {
; 20215: 	xmlSchemaQNameRefPtr ref = WXS_QNAME_CAST ause->attrDecl;
; 20216: 
; 20217: 	/*
; 20218: 	* TODO: Evaluate, what errors could occur if the declaration is not
; 20219: 	* found.
; 20220: 	*/
; 20221: 	ause->attrDecl = xmlSchemaGetAttributeDecl(ctxt->schema,

	push	DWORD PTR [esi+16]
	push	DWORD PTR [esi+12]
	push	DWORD PTR [ebx+36]
	call	_xmlSchemaGetAttributeDecl
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+12], eax

; 20222: 	    ref->name, ref->targetNamespace);
; 20223:         if (ause->attrDecl == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlSchemaR

; 20224: 	    xmlSchemaPResCompAttrErr(ctxt,

	push	eax
	push	15					; 0000000fH
	push	DWORD PTR [esi+16]
	push	DWORD PTR [esi+12]
	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	DWORD PTR [edi+20]
	push	edi
	push	3004					; 00000bbcH
	push	ebx
	call	_xmlSchemaPResCompAttrErr

; 20225: 		XML_SCHEMAP_SRC_RESOLVE,
; 20226: 		WXS_BASIC_CAST ause, ause->node,
; 20227: 		"ref", ref->name, ref->targetNamespace,
; 20228: 		XML_SCHEMA_TYPE_ATTRIBUTE, NULL);
; 20229:             return(ctxt->err);;

	mov	eax, DWORD PTR [ebx+16]
	add	esp, 36					; 00000024H
	pop	esi
	pop	edi

; 20230:         }
; 20231:     }
; 20232:     return(0);
; 20233: }

	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlSchemaR:
	pop	esi
	pop	edi

; 20211: 	(ause->attrDecl->type != XML_SCHEMA_EXTRA_QNAMEREF))
; 20212: 	return(0);

	xor	eax, eax

; 20230:         }
; 20231:     }
; 20232:     return(0);
; 20233: }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemaR:
	pop	edi

; 20209: 	return(-1);

	or	eax, -1

; 20230:         }
; 20231:     }
; 20232:     return(0);
; 20233: }

	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaResolveAttrUseReferences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAreValuesEqual
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xmlSchemaAreValuesEqual PROC				; COMDAT

; 20141: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _x$[ebp]
	test	ebx, ebx
	je	$LN3@xmlSchemaA
	mov	edi, DWORD PTR _y$[ebp]
	npad	2
$LL2@xmlSchemaA:

; 20142:     xmlSchemaTypePtr tx, ty, ptx, pty;
; 20143:     int ret;
; 20144: 
; 20145:     while (x != NULL) {
; 20146: 	/* Same types. */
; 20147: 	tx = xmlSchemaGetBuiltInType(xmlSchemaGetValType(x));

	push	ebx
	call	_xmlSchemaGetValType
	push	eax
	call	_xmlSchemaGetBuiltInType

; 20148: 	ty = xmlSchemaGetBuiltInType(xmlSchemaGetValType(y));

	push	edi
	mov	esi, eax
	call	_xmlSchemaGetValType
	push	eax
	call	_xmlSchemaGetBuiltInType
	add	esp, 16					; 00000010H

; 13471:     while (type != NULL) {

	test	esi, esi
	je	SHORT $LN19@xmlSchemaA
$LL18@xmlSchemaA:

; 13472: 	/*
; 13473: 	* Note that anySimpleType is actually not a primitive type
; 13474: 	* but we need that here.
; 13475: 	*/
; 13476: 	if ((type->builtInType == XML_SCHEMAS_ANYSIMPLETYPE) ||

	cmp	DWORD PTR [esi+88], 46			; 0000002eH
	je	SHORT $LN17@xmlSchemaA
	test	DWORD PTR [esi+48], 16384		; 00004000H
	jne	SHORT $LN17@xmlSchemaA

; 13477: 	   (type->flags & XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE))
; 13478: 	    return (type);
; 13479: 	type = type->baseType;

	mov	esi, DWORD PTR [esi+64]
	test	esi, esi
	jne	SHORT $LL18@xmlSchemaA
$LN19@xmlSchemaA:

; 13480:     }
; 13481: 
; 13482:     return (NULL);

	xor	esi, esi
$LN17@xmlSchemaA:

; 13471:     while (type != NULL) {

	test	eax, eax
	je	SHORT $LN25@xmlSchemaA
	npad	3
$LL24@xmlSchemaA:

; 13472: 	/*
; 13473: 	* Note that anySimpleType is actually not a primitive type
; 13474: 	* but we need that here.
; 13475: 	*/
; 13476: 	if ((type->builtInType == XML_SCHEMAS_ANYSIMPLETYPE) ||

	cmp	DWORD PTR [eax+88], 46			; 0000002eH
	je	SHORT $LN23@xmlSchemaA
	test	DWORD PTR [eax+48], 16384		; 00004000H
	jne	SHORT $LN23@xmlSchemaA

; 13477: 	   (type->flags & XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE))
; 13478: 	    return (type);
; 13479: 	type = type->baseType;

	mov	eax, DWORD PTR [eax+64]
	test	eax, eax
	jne	SHORT $LL24@xmlSchemaA
$LN25@xmlSchemaA:

; 13480:     }
; 13481: 
; 13482:     return (NULL);

	xor	eax, eax
$LN23@xmlSchemaA:

; 20149: 	ptx = xmlSchemaGetPrimitiveType(tx);
; 20150: 	pty = xmlSchemaGetPrimitiveType(ty);
; 20151: 	/*
; 20152: 	* (1) if a datatype T' is `derived` by `restriction` from an
; 20153: 	* atomic datatype T then the `value space` of T' is a subset of
; 20154: 	* the `value space` of T. */
; 20155: 	/*
; 20156: 	* (2) if datatypes T' and T'' are `derived` by `restriction`
; 20157: 	* from a common atomic ancestor T then the `value space`s of T'
; 20158: 	* and T'' may overlap.
; 20159: 	*/
; 20160: 	if (ptx != pty)

	cmp	esi, eax
	jne	SHORT $LN3@xmlSchemaA

; 20161: 	    return(0);
; 20162: 	/*
; 20163: 	* We assume computed values to be normalized, so do a fast
; 20164: 	* string comparison for string based types.
; 20165: 	*/
; 20166: 	if ((ptx->builtInType == XML_SCHEMAS_STRING) ||

	mov	eax, DWORD PTR [esi+88]
	cmp	eax, 1
	je	SHORT $LN7@xmlSchemaA
	cmp	DWORD PTR [esi], 1
	jne	SHORT $LN5@xmlSchemaA
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN7@xmlSchemaA
$LN5@xmlSchemaA:

; 20169: 		xmlSchemaValueGetAsString(x),
; 20170: 		xmlSchemaValueGetAsString(y)))
; 20171: 		return (0);
; 20172: 	} else {
; 20173: 	    ret = xmlSchemaCompareValuesWhtsp(

	push	1
	push	edi
	push	1
	push	ebx
	call	_xmlSchemaCompareValuesWhtsp
	add	esp, 16					; 00000010H

; 20174: 		x, XML_SCHEMA_WHITESPACE_PRESERVE,
; 20175: 		y, XML_SCHEMA_WHITESPACE_PRESERVE);
; 20176: 	    if (ret == -2)

	cmp	eax, -2					; fffffffeH
	je	SHORT $LN35@xmlSchemaA

; 20177: 		return(-1);
; 20178: 	    if (ret != 0)

	test	eax, eax
	je	SHORT $LN8@xmlSchemaA
$LN3@xmlSchemaA:
	pop	edi

; 20193:     }
; 20194:     return (0);
; 20195: }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlSchemaA:

; 20167: 	    WXS_IS_ANY_SIMPLE_TYPE(ptx)) {
; 20168: 	    if (! xmlStrEqual(

	push	edi
	call	_xmlSchemaValueGetAsString
	add	esp, 4
	push	eax
	push	ebx
	call	_xmlSchemaValueGetAsString
	add	esp, 4
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@xmlSchemaA
$LN8@xmlSchemaA:

; 20179: 		return(0);
; 20180: 	}
; 20181: 	/*
; 20182: 	* Lists.
; 20183: 	*/
; 20184: 	x = xmlSchemaValueGetNext(x);

	push	ebx
	call	_xmlSchemaValueGetNext
	push	edi
	mov	ebx, eax
	call	_xmlSchemaValueGetNext
	add	esp, 8
	mov	edi, eax

; 20185: 	if (x != NULL) {

	test	ebx, ebx
	je	SHORT $LN11@xmlSchemaA

; 20186: 	    y = xmlSchemaValueGetNext(y);
; 20187: 	    if (y == NULL)

	test	edi, edi
	jne	$LL2@xmlSchemaA

; 20193:     }
; 20194:     return (0);
; 20195: }

	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN35@xmlSchemaA:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlSchemaA:

; 20188: 		return (0);
; 20189: 	} else if (xmlSchemaValueGetNext(y) != NULL)

	test	edi, edi
	jne	SHORT $LN3@xmlSchemaA

; 20190: 	    return (0);
; 20191: 	else
; 20192: 	    return (1);

	lea	eax, DWORD PTR [edi+1]
	pop	edi

; 20193:     }
; 20194:     return (0);
; 20195: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaAreValuesEqual ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaResolveModelGroupParticleReferences
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_msg$1 = 12						; size = 4
_mg$ = 12						; size = 4
_xmlSchemaResolveModelGroupParticleReferences PROC	; COMDAT

; 20060: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _mg$[ebp]
	mov	esi, DWORD PTR [esi+12]
	test	esi, esi
	je	$LN3@xmlSchemaR
	push	ebx
	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	edi
$LL2@xmlSchemaR:

; 20061:     xmlSchemaParticlePtr particle = WXS_MODELGROUP_PARTICLE(mg);
; 20062:     xmlSchemaQNameRefPtr ref;
; 20063:     xmlSchemaBasicItemPtr refItem;
; 20064: 
; 20065:     /*
; 20066:     * URGENT TODO: Test this.
; 20067:     */
; 20068:     while (particle != NULL) {
; 20069: 	if ((WXS_PARTICLE_TERM(particle) == NULL) ||

	mov	edi, DWORD PTR [esi+12]
	test	edi, edi
	je	$next_particle$26
	cmp	DWORD PTR [edi], 2000			; 000007d0H
	jne	$next_particle$26

; 20070: 	    ((WXS_PARTICLE_TERM(particle))->type !=
; 20071: 		XML_SCHEMA_EXTRA_QNAMEREF))
; 20072: 	{
; 20073: 	    goto next_particle;
; 20074: 	}
; 20075: 	ref = WXS_QNAME_CAST WXS_PARTICLE_TERM(particle);
; 20076: 	/*
; 20077: 	* Resolve the reference.
; 20078: 	* NULL the {term} by default.
; 20079: 	*/
; 20080: 	particle->children = NULL;

	mov	DWORD PTR [esi+12], 0

; 20081: 
; 20082: 	refItem = xmlSchemaGetNamedComponent(ctxt->schema,

	push	DWORD PTR [edi+16]
	push	DWORD PTR [edi+12]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [ebx+36]
	call	_xmlSchemaGetNamedComponent
	add	esp, 16					; 00000010H

; 20083: 	    ref->itemType, ref->name, ref->targetNamespace);
; 20084: 	if (refItem == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlSchemaR

; 20085: 	    xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,

	push	eax
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+16]
	push	DWORD PTR [edi+12]
	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	esi
	call	_xmlSchemaGetComponentNode
	add	esp, 4
	push	eax
	push	0
	push	3004					; 00000bbcH
	push	ebx
	call	_xmlSchemaPResCompAttrErr
	add	esp, 36					; 00000024H

; 20086: 		NULL, WXS_ITEM_NODE(particle), "ref", ref->name,
; 20087: 		ref->targetNamespace, ref->itemType, NULL);
; 20088: 	    /* TODO: remove the particle. */
; 20089: 	    goto next_particle;

	jmp	SHORT $next_particle$26
$LN6@xmlSchemaR:

; 20090: 	}
; 20091: 	if (refItem->type == XML_SCHEMA_TYPE_GROUP) {

	cmp	DWORD PTR [eax], 17			; 00000011H
	jne	SHORT $LN7@xmlSchemaR

; 20092: 	    if (WXS_MODELGROUPDEF_MODEL(refItem) == NULL)

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $next_particle$26

; 20093: 		/* TODO: remove the particle. */
; 20094: 		goto next_particle;
; 20095: 	    /*
; 20096: 	    * NOTE that we will assign the model group definition
; 20097: 	    * itself to the "term" of the particle. This will ease
; 20098: 	    * the check for circular model group definitions. After
; 20099: 	    * that the "term" will be assigned the model group of the
; 20100: 	    * model group definition.
; 20101: 	    */
; 20102: 	    if ((WXS_MODELGROUPDEF_MODEL(refItem))->type ==

	cmp	DWORD PTR [ecx], 8
	jne	SHORT $LN7@xmlSchemaR

; 20103: 		    XML_SCHEMA_TYPE_ALL) {
; 20104: 		/*
; 20105: 		* SPEC cos-all-limited (1)
; 20106: 		* SPEC cos-all-limited (1.2)
; 20107: 		* "It appears only as the value of one or both of the
; 20108: 		* following properties:"
; 20109: 		* (1.1) "the {model group} property of a model group
; 20110: 		*        definition."
; 20111: 		* (1.2) "the {term} property of a particle [... of] the "
; 20112: 		* {content type} of a complex type definition."
; 20113: 		*/
; 20114: 		xmlSchemaCustomErr(ACTXT_CAST ctxt,

	push	esi
	call	_xmlSchemaGetComponentNode

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	mov	edi, eax

; 2339 :     xmlChar *msg = NULL;

	mov	DWORD PTR _msg$1[ebp], 0

; 2340 : 
; 2341 :     if ((node == NULL) && (item != NULL) &&
; 2342 : 	(actxt->type == XML_SCHEMA_CTXT_PARSER)) {
; 2343 : 	node = WXS_ITEM_NODE(item);
; 2344 : 	xmlSchemaFormatItemForReport(&msg, NULL, item, NULL);
; 2345 : 	msg = xmlStrcat(msg, BAD_CAST ": ");
; 2346 :     } else
; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	edi
	lea	eax, DWORD PTR _msg$1[ebp]
	push	ebx
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0HI@HIFFMALD@A?5model?5group?5definition?5is?5ref@
	push	DWORD PTR _msg$1[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	edi
	push	3091					; 00000c13H
	push	2
	push	ebx

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$1[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$1[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 72					; 00000048H

; 2352 :     FREE_AND_NULL(msg)

	test	eax, eax
	je	SHORT $next_particle$26
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 20115: 		    /* TODO: error code */
; 20116: 		    XML_SCHEMAP_COS_ALL_LIMITED,
; 20117: 		    WXS_ITEM_NODE(particle), NULL,
; 20118: 		    "A model group definition is referenced, but "
; 20119: 		    "it contains an 'all' model group, which "
; 20120: 		    "cannot be contained by model groups",
; 20121: 		    NULL, NULL);
; 20122: 		/* TODO: remove the particle. */
; 20123: 		goto next_particle;

	jmp	SHORT $next_particle$26
$LN7@xmlSchemaR:

; 20124: 	    }
; 20125: 	    particle->children = (xmlSchemaTreeItemPtr) refItem;
; 20126: 	} else {
; 20127: 	    /*
; 20128: 	    * TODO: Are referenced element declarations the only
; 20129: 	    * other components we expect here?
; 20130: 	    */
; 20131: 	    particle->children = (xmlSchemaTreeItemPtr) refItem;

	mov	DWORD PTR [esi+12], eax
$next_particle$26:

; 20132: 	}
; 20133: next_particle:
; 20134: 	particle = WXS_PTC_CAST particle->next;

	mov	esi, DWORD PTR [esi+8]
	test	esi, esi
	jne	$LL2@xmlSchemaR
	pop	edi
	pop	ebx
$LN3@xmlSchemaR:
	pop	esi

; 20135:     }
; 20136: }

	pop	ebp
	ret	0
_xmlSchemaResolveModelGroupParticleReferences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckElemSubstGroup
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_elemDecl$ = 12						; size = 4
_xmlSchemaCheckElemSubstGroup PROC			; COMDAT

; 19809: {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _elemDecl$[ebp]
	mov	edi, DWORD PTR [eax+80]
	test	edi, edi
	je	$LN10@xmlSchemaC

; 19810:     if ((WXS_SUBST_HEAD(elemDecl) == NULL) ||

	test	BYTE PTR [eax+48], 16			; 00000010H
	jne	$LN10@xmlSchemaC
	push	ebx
	push	esi
	npad	8
$LL4@xmlSchemaC:

; 19825: 	    set = 0;
; 19826: 	    methSet = 0;
; 19827: 	    /*
; 19828: 	    * The blocking constraints.
; 19829: 	    */
; 19830: 	    if (head->flags & XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION)

	mov	ebx, DWORD PTR [edi+48]
	xor	edx, edx
	test	ebx, 8192				; 00002000H
	jne	$LN2@xmlSchemaC

; 19831: 		continue;
; 19832: 	    headType = head->subtypes;
; 19833: 	    type = elemDecl->subtypes;

	mov	esi, DWORD PTR [eax+28]

; 19834: 	    if (headType == type)

	cmp	DWORD PTR [edi+28], esi
	je	$add_member$74

; 19835: 		goto add_member;
; 19836: 	    if (head->flags & XML_SCHEMAS_ELEM_BLOCK_RESTRICTION)

	mov	eax, ebx
	and	eax, 4096				; 00001000H
	shl	eax, 7

; 19837: 		set |= XML_SCHEMAS_TYPE_BLOCK_RESTRICTION;
; 19838: 	    if (head->flags & XML_SCHEMAS_ELEM_BLOCK_EXTENSION)
; 19839: 		set |= XML_SCHEMAS_TYPE_BLOCK_EXTENSION;
; 19840: 	    /*
; 19841: 	    * SPEC: Substitution Group OK (Transitive) (2.3)
; 19842: 	    * "The set of all {derivation method}s involved in the
; 19843: 	    * derivation of D's {type definition} from C's {type definition}
; 19844: 	    * does not intersect with the union of the blocking constraint,
; 19845: 	    * C's {prohibited substitutions} (if C is complex, otherwise the
; 19846: 	    * empty set) and the {prohibited substitutions} (respectively the
; 19847: 	    * empty set) of any intermediate {type definition}s in the
; 19848: 	    * derivation of D's {type definition} from C's {type definition}."
; 19849: 	    */
; 19850: 	    /*
; 19851: 	    * OPTIMIZE TODO: Optimize this a bit, since, if traversing the
; 19852: 	    * subst.head axis, the methSet does not need to be computed for
; 19853: 	    * the full depth over and over.
; 19854: 	    */
; 19855: 	    /*
; 19856: 	    * The set of all {derivation method}s involved in the derivation
; 19857: 	    */
; 19858: 	    while ((type != NULL) && (type != headType)) {

	mov	ecx, eax
	or	ecx, 262144				; 00040000H
	and	ebx, 2048				; 00000800H
	mov	ebx, DWORD PTR [edi+28]
	cmove	ecx, eax
	test	esi, esi
	je	SHORT $LN6@xmlSchemaC
	npad	1
$LL5@xmlSchemaC:
	cmp	esi, ebx
	je	SHORT $LN6@xmlSchemaC

; 19859: 		if ((WXS_IS_EXTENSION(type)) &&

	mov	eax, DWORD PTR [esi+48]
	test	al, 2
	je	SHORT $LN15@xmlSchemaC
	test	edx, 524288				; 00080000H
	jne	SHORT $LN15@xmlSchemaC

; 19860: 		    ((methSet & XML_SCHEMAS_TYPE_BLOCK_RESTRICTION) == 0))
; 19861: 		    methSet |= XML_SCHEMAS_TYPE_BLOCK_EXTENSION;

	or	edx, 262144				; 00040000H
$LN15@xmlSchemaC:

; 19862: 
; 19863: 		if (WXS_IS_RESTRICTION(type) &&

	test	al, 4
	je	SHORT $LN16@xmlSchemaC
	test	edx, 524288				; 00080000H
	jne	SHORT $LN16@xmlSchemaC

; 19864: 		    ((methSet & XML_SCHEMAS_TYPE_BLOCK_RESTRICTION) == 0))
; 19865: 		    methSet |= XML_SCHEMAS_TYPE_BLOCK_RESTRICTION;

	or	edx, 524288				; 00080000H
$LN16@xmlSchemaC:

; 19866: 
; 19867: 		type = type->baseType;

	mov	esi, DWORD PTR [esi+64]
	test	esi, esi
	jne	SHORT $LL5@xmlSchemaC
$LN6@xmlSchemaC:

; 19868: 	    }
; 19869: 	    /*
; 19870: 	    * The {prohibited substitutions} of all intermediate types +
; 19871: 	    * the head's type.
; 19872: 	    */
; 19873: 	    type = elemDecl->subtypes->baseType;

	mov	esi, DWORD PTR _elemDecl$[ebp]
	mov	eax, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [eax+64]

; 19874: 	    while (type != NULL) {

	test	eax, eax
	je	SHORT $LN68@xmlSchemaC
	npad	1
$LL7@xmlSchemaC:

; 19875: 		if (WXS_IS_COMPLEX(type)) {

	cmp	DWORD PTR [eax], 5
	je	SHORT $LN19@xmlSchemaC
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	jne	SHORT $LN68@xmlSchemaC
$LN19@xmlSchemaC:

; 19876: 		    if ((type->flags &
; 19877: 			    XML_SCHEMAS_TYPE_BLOCK_EXTENSION) &&

	mov	esi, DWORD PTR [eax+48]
	test	esi, 262144				; 00040000H
	je	SHORT $LN20@xmlSchemaC
	test	ecx, 262144				; 00040000H
	jne	SHORT $LN20@xmlSchemaC

; 19878: 			((set & XML_SCHEMAS_TYPE_BLOCK_EXTENSION) == 0))
; 19879: 		    set |= XML_SCHEMAS_TYPE_BLOCK_EXTENSION;

	or	ecx, 262144				; 00040000H
$LN20@xmlSchemaC:

; 19880: 		    if ((type->flags &
; 19881: 			    XML_SCHEMAS_TYPE_BLOCK_RESTRICTION) &&

	test	esi, 524288				; 00080000H
	je	SHORT $LN21@xmlSchemaC
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN21@xmlSchemaC

; 19882: 			((set & XML_SCHEMAS_TYPE_BLOCK_RESTRICTION) == 0))
; 19883: 		    set |= XML_SCHEMAS_TYPE_BLOCK_RESTRICTION;

	or	ecx, 524288				; 00080000H
$LN21@xmlSchemaC:

; 19884: 		} else
; 19885: 		    break;
; 19886: 		if (type == headType)

	cmp	eax, ebx
	je	SHORT $LN68@xmlSchemaC

; 19887: 		    break;
; 19888: 		type = type->baseType;

	mov	eax, DWORD PTR [eax+64]
	test	eax, eax
	jne	SHORT $LL7@xmlSchemaC
$LN68@xmlSchemaC:

; 19889: 	    }
; 19890: 	    if ((set != 0) &&

	test	ecx, ecx
	je	SHORT $add_member$74
	and	edx, ecx
	bt	edx, 18					; 00000012H
	jb	$LN72@xmlSchemaC
	bt	edx, 19					; 00000013H
	jb	$LN72@xmlSchemaC
$add_member$74:

; 5793 :     if ((pctxt == NULL) || (head == NULL) || (member == NULL))

	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	je	$LN30@xmlSchemaC

; 5794 : 	return (-1);
; 5795 : 
; 5796 :     substGroup = xmlSchemaSubstGroupGet(pctxt, head);

	push	edi
	push	ebx
	call	_xmlSchemaSubstGroupGet
	mov	esi, eax
	add	esp, 8

; 5797 :     if (substGroup == NULL)

	test	esi, esi
	jne	$LN40@xmlSchemaC

; 5734 :     if (WXS_SUBST_GROUPS(pctxt) == NULL) {

	mov	eax, DWORD PTR [ebx+28]
	cmp	DWORD PTR [eax+24], esi
	jne	SHORT $LN37@xmlSchemaC

; 5735 : 	WXS_SUBST_GROUPS(pctxt) = xmlHashCreateDict(10, pctxt->dict);

	push	DWORD PTR [ebx+80]
	push	10					; 0000000aH
	call	_xmlHashCreateDict
	mov	ecx, DWORD PTR [ebx+28]
	add	esp, 8
	mov	DWORD PTR [ecx+24], eax

; 5736 : 	if (WXS_SUBST_GROUPS(pctxt) == NULL)

	mov	eax, DWORD PTR [ebx+28]
	cmp	DWORD PTR [eax+24], esi
	je	$LN30@xmlSchemaC
$LN37@xmlSchemaC:

; 5737 : 	    return(NULL);
; 5738 :     }
; 5739 :     /* Create a new substitution group. */
; 5740 :     ret = (xmlSchemaSubstGroupPtr) xmlMalloc(sizeof(xmlSchemaSubstGroup));

	push	8
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5741 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN38@xmlSchemaC

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CK@NKPACKCN@allocating?5a?5substitution?5group@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 5744 : 	return(NULL);

	jmp	$LN30@xmlSchemaC
$LN38@xmlSchemaC:
	xorps	xmm0, xmm0

; 5745 :     }
; 5746 :     memset(ret, 0, sizeof(xmlSchemaSubstGroup));

	movq	QWORD PTR [esi], xmm0

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	push	12					; 0000000cH

; 5747 :     ret->head = head;

	mov	DWORD PTR [esi], edi

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 3342 :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN46@xmlSchemaC

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@BAFOADOL@allocating?5an?5item?5list?5structu@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3345 : 	return (NULL);

	xor	eax, eax
	jmp	SHORT $LN45@xmlSchemaC
$LN46@xmlSchemaC:
	xorps	xmm0, xmm0

; 3346 :     }
; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));

	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], 0
$LN45@xmlSchemaC:

; 5749 :     ret->members = xmlSchemaItemListCreate();

	mov	DWORD PTR [esi+4], eax

; 5750 :     if (ret->members == NULL) {

	push	esi
	test	eax, eax
	jne	SHORT $LN39@xmlSchemaC

; 5751 : 	xmlSchemaSubstGroupFree(ret);

	call	_xmlSchemaSubstGroupFree
	add	esp, 4

; 5752 : 	return(NULL);

	jmp	SHORT $LN30@xmlSchemaC
$LN39@xmlSchemaC:

; 5753 :     }
; 5754 :     /* Add subst group to hash. */
; 5755 :     if (xmlHashAddEntry2(WXS_SUBST_GROUPS(pctxt),
; 5756 : 	head->name, head->targetNamespace, ret) != 0) {

	push	DWORD PTR [edi+52]
	mov	eax, DWORD PTR [ebx+28]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [eax+24]
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN40@xmlSchemaC

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CL@JADHFAI@failed?5to?5add?5a?5new?5substitutio@
	push	OFFSET ??_C@_0BH@CHMIFAPN@xmlSchemaSubstGroupAdd@
	push	ebx
	call	_xmlSchemaInternalErr2

; 5759 : 	xmlSchemaSubstGroupFree(ret);

	push	esi
	call	_xmlSchemaSubstGroupFree
	add	esp, 24					; 00000018H

; 5760 : 	return(NULL);

	jmp	SHORT $LN30@xmlSchemaC
$LN40@xmlSchemaC:

; 5801 :     if (xmlSchemaItemListAdd(substGroup->members, member) == -1)

	push	DWORD PTR _elemDecl$[ebp]
	push	DWORD PTR [esi+4]
	call	_xmlSchemaItemListAdd
	add	esp, 8
$LN30@xmlSchemaC:

; 19891: 		(((set & XML_SCHEMAS_TYPE_BLOCK_EXTENSION) &&
; 19892: 		(methSet & XML_SCHEMAS_TYPE_BLOCK_EXTENSION)) ||
; 19893: 		((set & XML_SCHEMAS_TYPE_BLOCK_RESTRICTION) &&
; 19894: 		(methSet & XML_SCHEMAS_TYPE_BLOCK_RESTRICTION)))) {
; 19895: 		continue;
; 19896: 	    }
; 19897: add_member:
; 19898: 	    xmlSchemaAddElementSubstitutionMember(ctxt, head, elemDecl);
; 19899: 	    if ((head->flags & XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD) == 0)

	mov	eax, DWORD PTR [edi+48]
	test	eax, 131072				; 00020000H
	jne	SHORT $LN72@xmlSchemaC

; 19900: 		head->flags |= XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD;

	or	eax, 131072				; 00020000H
	mov	DWORD PTR [edi+48], eax
$LN72@xmlSchemaC:

; 19811: 	/* SPEC (1) "Its {abstract} is false." */
; 19812: 	(elemDecl->flags & XML_SCHEMAS_ELEM_ABSTRACT))
; 19813: 	return;
; 19814:     {
; 19815: 	xmlSchemaElementPtr head;
; 19816: 	xmlSchemaTypePtr headType, type;
; 19817: 	int set, methSet;
; 19818: 	/*
; 19819: 	* SPEC (2) "It is validly substitutable for HEAD subject to HEAD's
; 19820: 	* {disallowed substitutions} as the blocking constraint, as defined in
; 19821: 	* Substitution Group OK (Transitive) ($3.3.6)."
; 19822: 	*/
; 19823: 	for (head = WXS_SUBST_HEAD(elemDecl); head != NULL;
; 19824: 	    head = WXS_SUBST_HEAD(head)) {

	mov	eax, DWORD PTR _elemDecl$[ebp]
$LN2@xmlSchemaC:
	mov	edi, DWORD PTR [edi+80]
	test	edi, edi
	jne	$LL4@xmlSchemaC
	pop	esi
	pop	ebx
$LN10@xmlSchemaC:
	pop	edi

; 19901: 	}
; 19902:     }
; 19903: }

	pop	ebp
	ret	0
_xmlSchemaCheckElemSubstGroup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckElemPropsCorrect
_TEXT	SEGMENT
tv742 = -16						; size = 4
_strC$1 = -16						; size = 4
_strA$2 = -12						; size = 4
_strB$3 = -12						; size = 4
tv738 = -8						; size = 4
_circ$1$ = -8						; size = 4
_strB$4 = -8						; size = 4
_ret$1$ = -4						; size = 4
_strA$5 = -4						; size = 4
_pctxt$ = 8						; size = 4
_node$1$ = 12						; size = 4
_head$1$ = 12						; size = 4
_elemDecl$ = 12						; size = 4
_xmlSchemaCheckElemPropsCorrect PROC			; COMDAT

; 19627: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _elemDecl$[ebp]
	mov	esi, DWORD PTR _pctxt$[ebp]
	mov	DWORD PTR _ret$1$[ebp], 0
	mov	eax, DWORD PTR [ebx+80]
	mov	edi, DWORD PTR [ebx+28]
	mov	DWORD PTR _head$1$[ebp], eax
	test	eax, eax
	je	$LN17@xmlSchemaC

; 19628:     int ret = 0;
; 19629:     xmlSchemaTypePtr typeDef = WXS_ELEM_TYPEDEF(elemDecl);
; 19630:     /*
; 19631:     * SPEC (1) "The values of the properties of an element declaration
; 19632:     * must be as described in the property tableau in The Element
; 19633:     * Declaration Schema Component ($3.3.1), modulo the impact of Missing
; 19634:     * Sub-components ($5.3)."
; 19635:     */
; 19636:     if (WXS_SUBST_HEAD(elemDecl) != NULL) {
; 19637: 	xmlSchemaElementPtr head = WXS_SUBST_HEAD(elemDecl), circ;
; 19638: 
; 19639: 	xmlSchemaCheckElementDeclComponent(head, pctxt);

	push	esi
	push	eax
	call	_xmlSchemaCheckElementDeclComponent
	add	esp, 8

; 19640: 	/*
; 19641: 	* SPEC (3) "If there is a non-`absent` {substitution group
; 19642: 	* affiliation}, then {scope} must be global."
; 19643: 	*/
; 19644: 	if ((elemDecl->flags & XML_SCHEMAS_ELEM_GLOBAL) == 0) {

	test	BYTE PTR [ebx+48], 2
	jne	SHORT $LN3@xmlSchemaC

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0EL@CIIJKFO@Only?5global?5element?5declaration@
	push	0
	push	ebx
	push	3046					; 00000be6H
	push	esi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 19645: 	    xmlSchemaPCustomErr(pctxt,
; 19646: 		XML_SCHEMAP_E_PROPS_CORRECT_3,
; 19647: 		WXS_BASIC_CAST elemDecl, NULL,
; 19648: 		"Only global element declarations can have a "
; 19649: 		"substitution group affiliation", NULL);
; 19650: 	    ret = XML_SCHEMAP_E_PROPS_CORRECT_3;

	mov	DWORD PTR _ret$1$[ebp], 3046		; 00000be6H
$LN3@xmlSchemaC:

; 19651: 	}
; 19652: 	/*
; 19653: 	* TODO: SPEC (6) "Circular substitution groups are disallowed.
; 19654: 	* That is, it must not be possible to return to an element declaration
; 19655: 	* by repeatedly following the {substitution group affiliation}
; 19656: 	* property."
; 19657: 	*/
; 19658: 	if (head == elemDecl)

	mov	eax, DWORD PTR _head$1$[ebp]
	cmp	eax, ebx
	jne	SHORT $LN4@xmlSchemaC

; 19659: 	    circ = head;

	mov	ecx, eax
	jmp	SHORT $LN86@xmlSchemaC
$LN4@xmlSchemaC:

; 19660: 	else if (WXS_SUBST_HEAD(head) != NULL)

	cmp	DWORD PTR [eax+80], 0
	je	$LN8@xmlSchemaC

; 19661: 	    circ = xmlSchemaCheckSubstGroupCircular(head, head);

	push	eax
	push	eax
	call	_xmlSchemaCheckSubstGroupCircular
	mov	ecx, eax
	add	esp, 8
	mov	eax, DWORD PTR _head$1$[ebp]
$LN86@xmlSchemaC:

; 19662: 	else
; 19663: 	    circ = NULL;
; 19664: 	if (circ != NULL) {

	mov	DWORD PTR _circ$1$[ebp], ecx
	test	ecx, ecx
	je	$LN8@xmlSchemaC

; 1429 :     return (xmlSchemaFormatQName(buf,

	push	eax

; 19665: 	    xmlChar *strA = NULL, *strB = NULL;

	mov	DWORD PTR _strA$5[ebp], 0
	mov	DWORD PTR _strB$3[ebp], 0

; 1429 :     return (xmlSchemaFormatQName(buf,

	call	_xmlSchemaGetComponentName
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _head$1$[ebp]
	push	eax
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _strB$3[ebp]
	push	eax
	call	_xmlSchemaFormatQName
	add	esp, 12					; 0000000cH

; 19666: 
; 19667: 	    xmlSchemaPCustomErrExt(pctxt,

	push	0
	push	eax

; 1429 :     return (xmlSchemaFormatQName(buf,

	push	DWORD PTR _circ$1$[ebp]
	call	_xmlSchemaGetComponentName
	add	esp, 4
	push	eax
	push	DWORD PTR _circ$1$[ebp]
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _strA$5[ebp]
	push	eax
	call	_xmlSchemaFormatQName
	add	esp, 12					; 0000000cH

; 19666: 
; 19667: 	    xmlSchemaPCustomErrExt(pctxt,

	push	eax
	push	OFFSET ??_C@_0FP@ECMLFAOK@The?5element?5declaration?5?8?$CFs?8?5de@
	push	0
	push	DWORD PTR _circ$1$[ebp]
	push	3049					; 00000be9H
	push	esi
	call	_xmlSchemaPCustomErrExt

; 19668: 		XML_SCHEMAP_E_PROPS_CORRECT_6,
; 19669: 		WXS_BASIC_CAST circ, NULL,
; 19670: 		"The element declaration '%s' defines a circular "
; 19671: 		"substitution group to element declaration '%s'",
; 19672: 		xmlSchemaGetComponentQName(&strA, circ),
; 19673: 		xmlSchemaGetComponentQName(&strB, head),
; 19674: 		NULL);
; 19675: 	    FREE_AND_NULL(strA)

	mov	eax, DWORD PTR _strA$5[ebp]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN9@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlSchemaC:

; 19676: 	    FREE_AND_NULL(strB)

	mov	eax, DWORD PTR _strB$3[ebp]
	test	eax, eax
	je	SHORT $LN10@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlSchemaC:

; 19677: 	    ret = XML_SCHEMAP_E_PROPS_CORRECT_6;

	mov	DWORD PTR _ret$1$[ebp], 3049		; 00000be9H
$LN8@xmlSchemaC:

; 19678: 	}
; 19679: 	/*
; 19680: 	* SPEC (4) "If there is a {substitution group affiliation},
; 19681: 	* the {type definition}
; 19682: 	* of the element declaration must be validly derived from the {type
; 19683: 	* definition} of the {substitution group affiliation}, given the value
; 19684: 	* of the {substitution group exclusions} of the {substitution group
; 19685: 	* affiliation}, as defined in Type Derivation OK (Complex) ($3.4.6)
; 19686: 	* (if the {type definition} is complex) or as defined in
; 19687: 	* Type Derivation OK (Simple) ($3.14.6) (if the {type definition} is
; 19688: 	* simple)."
; 19689: 	*
; 19690: 	* NOTE: {substitution group exclusions} means the values of the
; 19691: 	* attribute "final".
; 19692: 	*/
; 19693: 
; 19694: 	if (typeDef != WXS_ELEM_TYPEDEF(WXS_SUBST_HEAD(elemDecl))) {

	mov	eax, DWORD PTR [ebx+80]
	cmp	edi, DWORD PTR [eax+28]
	je	$LN17@xmlSchemaC

; 19695: 	    int set = 0;
; 19696: 
; 19697: 	    if (head->flags & XML_SCHEMAS_ELEM_FINAL_EXTENSION)

	mov	edx, DWORD PTR _head$1$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	mov	eax, ecx
	shr	eax, 14					; 0000000eH
	and	eax, 2

; 19698: 		set |= SUBSET_EXTENSION;
; 19699: 	    if (head->flags & XML_SCHEMAS_ELEM_FINAL_RESTRICTION)
; 19700: 		set |= SUBSET_RESTRICTION;
; 19701: 
; 19702: 	    if (xmlSchemaCheckCOSDerivedOK(ACTXT_CAST pctxt, typeDef,
; 19703: 		WXS_ELEM_TYPEDEF(head), set) != 0) {

	mov	DWORD PTR tv738[ebp], eax
	or	DWORD PTR tv738[ebp], 1
	and	ecx, 65536				; 00010000H
	mov	ecx, DWORD PTR tv738[ebp]
	cmove	ecx, eax
	mov	eax, DWORD PTR [edx+28]

; 16145:     if (WXS_IS_SIMPLE(type))

	mov	edx, DWORD PTR [edi]
	cmp	edx, 4
	je	SHORT $LN82@xmlSchemaC
	cmp	edx, 1
	jne	SHORT $LN81@xmlSchemaC
	cmp	DWORD PTR [edi+88], 45			; 0000002dH
	jne	SHORT $LN82@xmlSchemaC
$LN81@xmlSchemaC:

; 16147:     else
; 16148: 	return (xmlSchemaCheckCOSCTDerivedOK(actxt, type, baseType, set));

	push	ecx
	push	eax
	push	edi
	push	esi
	call	_xmlSchemaCheckCOSCTDerivedOK
	jmp	SHORT $LN87@xmlSchemaC
$LN82@xmlSchemaC:

; 16146: 	return (xmlSchemaCheckCOSSTDerivedOK(actxt, type, baseType, set));

	push	ecx
	push	eax
	push	edi
	push	esi
	call	_xmlSchemaCheckCOSSTDerivedOK
$LN87@xmlSchemaC:

; 19698: 		set |= SUBSET_EXTENSION;
; 19699: 	    if (head->flags & XML_SCHEMAS_ELEM_FINAL_RESTRICTION)
; 19700: 		set |= SUBSET_RESTRICTION;
; 19701: 
; 19702: 	    if (xmlSchemaCheckCOSDerivedOK(ACTXT_CAST pctxt, typeDef,
; 19703: 		WXS_ELEM_TYPEDEF(head), set) != 0) {

	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN17@xmlSchemaC

; 19707: 		xmlSchemaPCustomErrExt(pctxt,

	mov	eax, DWORD PTR _head$1$[ebp]
	mov	DWORD PTR _strA$2[ebp], 0
	mov	DWORD PTR _strB$4[ebp], 0
	mov	DWORD PTR _strC$1[ebp], 0
	mov	esi, DWORD PTR [eax+28]

; 1429 :     return (xmlSchemaFormatQName(buf,

	push	esi

; 19704: 		xmlChar *strA = NULL, *strB = NULL, *strC = NULL;
; 19705: 
; 19706: 		ret = XML_SCHEMAP_E_PROPS_CORRECT_4;

	mov	DWORD PTR _ret$1$[ebp], 3047		; 00000be7H

; 1429 :     return (xmlSchemaFormatQName(buf,

	call	_xmlSchemaGetComponentName
	add	esp, 4
	push	eax
	push	esi
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _strC$1[ebp]
	push	eax
	call	_xmlSchemaFormatQName
	push	DWORD PTR _head$1$[ebp]
	mov	esi, eax
	call	_xmlSchemaGetComponentName
	add	esp, 16					; 00000010H
	push	eax
	push	DWORD PTR _head$1$[ebp]
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _strB$4[ebp]
	push	eax
	call	_xmlSchemaFormatQName
	add	esp, 12					; 0000000cH

; 19707: 		xmlSchemaPCustomErrExt(pctxt,

	push	esi
	push	eax

; 1429 :     return (xmlSchemaFormatQName(buf,

	push	edi
	call	_xmlSchemaGetComponentName
	add	esp, 4
	push	eax
	push	edi
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _strA$2[ebp]
	push	eax
	call	_xmlSchemaFormatQName

; 19707: 		xmlSchemaPCustomErrExt(pctxt,

	mov	esi, DWORD PTR _pctxt$[ebp]

; 1429 :     return (xmlSchemaFormatQName(buf,

	add	esp, 12					; 0000000cH

; 19707: 		xmlSchemaPCustomErrExt(pctxt,

	push	eax
	push	OFFSET ??_C@_0IO@OBKDAHJI@The?5type?5definition?5?8?$CFs?8?5was?5ei@
	push	0
	push	ebx
	push	3047					; 00000be7H
	push	esi
	call	_xmlSchemaPCustomErrExt

; 19708: 		    XML_SCHEMAP_E_PROPS_CORRECT_4,
; 19709: 		    WXS_BASIC_CAST elemDecl, NULL,
; 19710: 		    "The type definition '%s' was "
; 19711: 		    "either rejected by the substitution group "
; 19712: 		    "affiliation '%s', or not validly derived from its type "
; 19713: 		    "definition '%s'",
; 19714: 		    xmlSchemaGetComponentQName(&strA, typeDef),
; 19715: 		    xmlSchemaGetComponentQName(&strB, head),
; 19716: 		    xmlSchemaGetComponentQName(&strC, WXS_ELEM_TYPEDEF(head)));
; 19717: 		FREE_AND_NULL(strA)

	mov	eax, DWORD PTR _strA$2[ebp]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN15@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlSchemaC:

; 19718: 		FREE_AND_NULL(strB)

	mov	eax, DWORD PTR _strB$4[ebp]
	test	eax, eax
	je	SHORT $LN16@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlSchemaC:

; 19719: 		FREE_AND_NULL(strC)

	mov	eax, DWORD PTR _strC$1[ebp]
	test	eax, eax
	je	SHORT $LN17@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlSchemaC:

; 19720: 	    }
; 19721: 	}
; 19722:     }
; 19723:     /*
; 19724:     * SPEC (5) "If the {type definition} or {type definition}'s
; 19725:     * {content type}
; 19726:     * is or is derived from ID then there must not be a {value constraint}.
; 19727:     * Note: The use of ID as a type definition for elements goes beyond
; 19728:     * XML 1.0, and should be avoided if backwards compatibility is desired"
; 19729:     */
; 19730:     if ((elemDecl->value != NULL) &&

	cmp	DWORD PTR [ebx+76], 0
	je	SHORT $LN30@xmlSchemaC
	mov	eax, DWORD PTR [edi]
	cmp	eax, 4
	je	SHORT $LN22@xmlSchemaC
	cmp	eax, 1
	jne	SHORT $LN21@xmlSchemaC
	cmp	DWORD PTR [edi+88], 45			; 0000002dH
	je	SHORT $LN21@xmlSchemaC
$LN22@xmlSchemaC:
	push	23					; 00000017H
	push	edi
	call	_xmlSchemaIsDerivedFromBuiltInType
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@xmlSchemaC
$LN21@xmlSchemaC:
	cmp	DWORD PTR [edi], 5
	je	SHORT $LN83@xmlSchemaC
	cmp	DWORD PTR [edi+88], 45			; 0000002dH
	jne	SHORT $LN18@xmlSchemaC
$LN83@xmlSchemaC:
	mov	eax, DWORD PTR [edi+52]
	cmp	eax, 4
	je	SHORT $LN24@xmlSchemaC
	cmp	eax, 6
	jne	SHORT $LN18@xmlSchemaC
$LN24@xmlSchemaC:
	push	23					; 00000017H
	push	DWORD PTR [edi+104]
	call	_xmlSchemaIsDerivedFromBuiltInType
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlSchemaC
$LN20@xmlSchemaC:

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0JP@GPCAONIJ@The?5type?5definition?5?$CIor?5type?5de@
	push	0
	push	ebx
	push	3048					; 00000be8H
	push	esi

; 19731: 	((WXS_IS_SIMPLE(typeDef) &&
; 19732: 	  xmlSchemaIsDerivedFromBuiltInType(typeDef, XML_SCHEMAS_ID)) ||
; 19733: 	 (WXS_IS_COMPLEX(typeDef) &&
; 19734: 	  WXS_HAS_SIMPLE_CONTENT(typeDef) &&
; 19735: 	  xmlSchemaIsDerivedFromBuiltInType(typeDef->contentTypeDef,
; 19736: 	    XML_SCHEMAS_ID)))) {
; 19737: 
; 19738: 	ret = XML_SCHEMAP_E_PROPS_CORRECT_5;

	mov	DWORD PTR _ret$1$[ebp], 3048		; 00000be8H

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
$LN30@xmlSchemaC:

; 19781: 	}
; 19782:     }
; 19783: 
; 19784:     return (ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 19785: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlSchemaC:

; 19739: 	xmlSchemaPCustomErr(pctxt,
; 19740: 	    XML_SCHEMAP_E_PROPS_CORRECT_5,
; 19741: 	    WXS_BASIC_CAST elemDecl, NULL,
; 19742: 	    "The type definition (or type definition's content type) is or "
; 19743: 	    "is derived from ID; value constraints are not allowed in "
; 19744: 	    "conjunction with such a type definition", NULL);
; 19745:     } else if (elemDecl->value != NULL) {

	cmp	DWORD PTR [ebx+76], 0
	je	SHORT $LN30@xmlSchemaC

; 19746: 	int vcret;
; 19747: 	xmlNodePtr node = NULL;

	mov	DWORD PTR _node$1$[ebp], 0

; 19748: 
; 19749: 	/*
; 19750: 	* SPEC (2) "If there is a {value constraint}, the canonical lexical
; 19751: 	* representation of its value must be `valid` with respect to the
; 19752: 	* {type definition} as defined in Element Default Valid (Immediate)
; 19753: 	* ($3.3.6)."
; 19754: 	*/
; 19755: 	if (typeDef == NULL) {

	test	edi, edi
	jne	SHORT $LN26@xmlSchemaC

; 19756: 	    xmlSchemaPErr(pctxt, elemDecl->node,

	push	edi
	push	edi
	push	OFFSET ??_C@_0GP@ONEJGEGK@Internal?5error?3?5xmlSchemaCheckE@
	push	3069					; 00000bfdH
	push	DWORD PTR [ebx+36]
	push	esi
	call	_xmlSchemaPErr
	add	esp, 24					; 00000018H

; 19757: 		XML_SCHEMAP_INTERNAL,
; 19758: 		"Internal error: xmlSchemaCheckElemPropsCorrect, "
; 19759: 		"type is missing... skipping validation of "
; 19760: 		"the value constraint", NULL, NULL);
; 19761: 	    return (-1);

	or	eax, -1
	pop	edi

; 19785: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlSchemaC:

; 19762: 	}
; 19763: 	if (elemDecl->node != NULL) {

	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	je	SHORT $LN29@xmlSchemaC

; 19764: 	    if (elemDecl->flags & XML_SCHEMAS_ELEM_FIXED)

	test	BYTE PTR [ebx+48], 8
	je	SHORT $LN28@xmlSchemaC

; 19765: 		node = (xmlNodePtr) xmlHasProp(elemDecl->node,

	push	OFFSET ??_C@_05OFLEIIDM@fixed@
	jmp	SHORT $LN89@xmlSchemaC
$LN28@xmlSchemaC:

; 19766: 		    BAD_CAST "fixed");
; 19767: 	    else
; 19768: 		node = (xmlNodePtr) xmlHasProp(elemDecl->node,

	push	OFFSET ??_C@_07DLHCIBDH@default@
$LN89@xmlSchemaC:

; 19769: 		    BAD_CAST "default");
; 19770: 	}
; 19771: 	vcret = xmlSchemaParseCheckCOSValidDefault(pctxt, node,

	push	eax
	call	_xmlHasProp
	mov	DWORD PTR _node$1$[ebp], eax
	add	esp, 8
$LN29@xmlSchemaC:

; 15858:     if WXS_IS_COMPLEX(type) {

	cmp	DWORD PTR [edi], 5

; 19769: 		    BAD_CAST "default");
; 19770: 	}
; 19771: 	vcret = xmlSchemaParseCheckCOSValidDefault(pctxt, node,

	lea	ecx, DWORD PTR [ebx+96]
	mov	ebx, DWORD PTR [ebx+76]
	mov	DWORD PTR tv742[ebp], ecx

; 15858:     if WXS_IS_COMPLEX(type) {

	je	SHORT $LN84@xmlSchemaC
	cmp	DWORD PTR [edi+88], 45			; 0000002dH
	jne	SHORT $LN60@xmlSchemaC
$LN84@xmlSchemaC:

; 15859: 	/*
; 15860: 	* Complex type.
; 15861: 	*
; 15862: 	* SPEC (2.1) "its {content type} must be a simple type definition
; 15863: 	* or mixed."
; 15864: 	* SPEC (2.2.2) "If the {content type} is mixed, then the {content
; 15865: 	* type}'s particle must be `emptiable` as defined by
; 15866: 	* Particle Emptiable ($3.9.6)."
; 15867: 	*/
; 15868: 	if ((! WXS_HAS_SIMPLE_CONTENT(type)) &&

	mov	eax, DWORD PTR [edi+52]
	cmp	eax, 4
	je	SHORT $LN60@xmlSchemaC
	cmp	eax, 6
	je	SHORT $LN60@xmlSchemaC
	cmp	eax, 3
	jne	SHORT $LN61@xmlSchemaC
	push	DWORD PTR [edi+28]
	call	_xmlSchemaIsParticleEmptiable
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN85@xmlSchemaC
$LN61@xmlSchemaC:

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0IM@DDPGDFGG@For?5a?5string?5to?5be?5a?5valid?5defa@
	push	DWORD PTR [edi+36]
	push	edi
	push	3059					; 00000bf3H
	push	esi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 15877: 	    return(XML_SCHEMAP_COS_VALID_DEFAULT_2_1);

	mov	edi, 3059				; 00000bf3H
$LN31@xmlSchemaC:

; 19779: 	    }
; 19780: 	    return (vcret);

	mov	eax, edi
	pop	edi

; 19785: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN85@xmlSchemaC:

; 15868: 	if ((! WXS_HAS_SIMPLE_CONTENT(type)) &&

	mov	ecx, DWORD PTR tv742[ebp]
$LN60@xmlSchemaC:

; 15878: 	}
; 15879:     }
; 15880:     /*
; 15881:     * 1 If the type definition is a simple type definition, then the string
; 15882:     * must be `valid` with respect to that definition as defined by String
; 15883:     * Valid ($3.14.4).
; 15884:     *
; 15885:     * AND
; 15886:     *
; 15887:     * 2.2.1 If the {content type} is a simple type definition, then the
; 15888:     * string must be `valid` with respect to that simple type definition
; 15889:     * as defined by String Valid ($3.14.4).
; 15890:     */
; 15891:     if (WXS_IS_SIMPLE(type))

	mov	eax, DWORD PTR [edi]
	cmp	eax, 4
	je	SHORT $LN64@xmlSchemaC
	cmp	eax, 1
	jne	SHORT $LN62@xmlSchemaC
	cmp	DWORD PTR [edi+88], 45			; 0000002dH
	jne	SHORT $LN64@xmlSchemaC
$LN62@xmlSchemaC:

; 15892: 	ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST pctxt, node,
; 15893: 	    type, value, val, 1, 1, 0);
; 15894:     else if (WXS_HAS_SIMPLE_CONTENT(type))

	mov	eax, DWORD PTR [edi+52]
	cmp	eax, 4
	je	SHORT $LN67@xmlSchemaC
	cmp	eax, 6
	jne	$LN30@xmlSchemaC
$LN67@xmlSchemaC:

; 15895: 	ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST pctxt, node,

	mov	edi, DWORD PTR [edi+104]
$LN64@xmlSchemaC:

; 15896: 	    type->contentTypeDef, value, val, 1, 1, 0);
; 15897:     else
; 15898: 	return (ret);
; 15899: 
; 15900:     if (ret < 0) {

	push	0
	push	1
	push	1
	push	ecx
	push	ebx
	push	edi
	push	DWORD PTR _node$1$[ebp]
	push	esi
	call	_xmlSchemaVCheckCVCSimpleType
	mov	edi, eax
	add	esp, 32					; 00000020H
	test	edi, edi
	jns	SHORT $LN90@xmlSchemaC

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CH@HOPMNJDI@calling?5xmlSchemaVCheckCVCSimpl@
	push	OFFSET ??_C@_0CD@MOGOJILI@xmlSchemaParseCheckCOSValidDefa@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 19772: 	    typeDef, elemDecl->value, &(elemDecl->defVal));
; 19773: 	if (vcret != 0) {

	test	edi, edi
$LN90@xmlSchemaC:
	je	$LN30@xmlSchemaC

; 19774: 	    if (vcret < 0) {

	test	edi, edi
	jns	SHORT $LN31@xmlSchemaC

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0EC@IFGBKADH@failed?5to?5validate?5the?5value?5co@
	push	OFFSET ??_C@_0BM@INOHADNA@xmlSchemaElemCheckValConstr@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 19775: 		PERROR_INT("xmlSchemaElemCheckValConstr",
; 19776: 		    "failed to validate the value constraint of an "
; 19777: 		    "element declaration");
; 19778: 		return (-1);

	or	eax, -1
	pop	edi

; 19785: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCheckElemPropsCorrect ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckSubstGroupCircular
_TEXT	SEGMENT
_elemDecl$ = 8						; size = 4
_ancestor$ = 12						; size = 4
_xmlSchemaCheckSubstGroupCircular PROC			; COMDAT

; 19594: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ancestor$[ebp]
	mov	ecx, DWORD PTR [esi+80]
	test	ecx, ecx
	je	SHORT $LN6@xmlSchemaC

; 19595:     xmlSchemaElementPtr ret;
; 19596: 
; 19597:     if (WXS_SUBST_HEAD(ancestor) == NULL)
; 19598: 	return (NULL);
; 19599:     if (WXS_SUBST_HEAD(ancestor) == elemDecl)

	mov	edx, DWORD PTR _elemDecl$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN3@xmlSchemaC

; 19600: 	return (ancestor);

	mov	eax, esi
	pop	esi

; 19608: 
; 19609:     return (ret);
; 19610: }

	pop	ebp
	ret	0
$LN3@xmlSchemaC:

; 19601: 
; 19602:     if (WXS_SUBST_HEAD(ancestor)->flags & XML_SCHEMAS_ELEM_CIRCULAR)

	mov	eax, DWORD PTR [ecx+48]
	test	eax, 512				; 00000200H
	jne	SHORT $LN6@xmlSchemaC

; 19604:     WXS_SUBST_HEAD(ancestor)->flags |= XML_SCHEMAS_ELEM_CIRCULAR;

	or	eax, 512				; 00000200H
	mov	DWORD PTR [ecx+48], eax

; 19605:     ret = xmlSchemaCheckSubstGroupCircular(elemDecl,

	push	DWORD PTR [esi+80]
	push	edx
	call	_xmlSchemaCheckSubstGroupCircular

; 19606: 	WXS_SUBST_HEAD(ancestor));
; 19607:     WXS_SUBST_HEAD(ancestor)->flags ^= XML_SCHEMAS_ELEM_CIRCULAR;

	mov	ecx, DWORD PTR [esi+80]
	add	esp, 8
	xor	DWORD PTR [ecx+48], 512			; 00000200H
	pop	esi

; 19608: 
; 19609:     return (ret);
; 19610: }

	pop	ebp
	ret	0
$LN6@xmlSchemaC:

; 19603: 	return (NULL);

	xor	eax, eax
	pop	esi

; 19608: 
; 19609:     return (ret);
; 19610: }

	pop	ebp
	ret	0
_xmlSchemaCheckSubstGroupCircular ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckAttrPropsCorrect
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_attr$ = 12						; size = 4
_xmlSchemaCheckAttrPropsCorrect PROC			; COMDAT

; 19529: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _attr$[ebp]
	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	$LN5@xmlSchemaC

; 19530: 
; 19531:     /*
; 19532:     * SPEC a-props-correct (1)
; 19533:     * "The values of the properties of an attribute declaration must
; 19534:     * be as described in the property tableau in The Attribute
; 19535:     * Declaration Schema Component ($3.2.1), modulo the impact of
; 19536:     * Missing Sub-components ($5.3)."
; 19537:     */
; 19538: 
; 19539:     if (WXS_ATTR_TYPEDEF(attr) == NULL)
; 19540: 	return(0);
; 19541: 
; 19542:     if (attr->defValue != NULL) {

	cmp	DWORD PTR [esi+44], 0
	je	$LN5@xmlSchemaC

; 19543: 	int ret;
; 19544: 
; 19545: 	/*
; 19546: 	* SPEC a-props-correct (3)
; 19547: 	* "If the {type definition} is or is derived from ID then there
; 19548: 	* must not be a {value constraint}."
; 19549: 	*/
; 19550: 	if (xmlSchemaIsDerivedFromBuiltInType(

	push	23					; 00000017H
	push	eax
	call	_xmlSchemaIsDerivedFromBuiltInType
	add	esp, 8
	push	0
	test	eax, eax
	je	SHORT $LN4@xmlSchemaC

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0FF@JBDCKHFC@Value?5constraints?5are?5not?5allow@
	push	esi
	mov	esi, DWORD PTR _pctxt$[ebp]
	push	0
	push	3090					; 00000c12H
	push	esi
	call	_xmlSchemaCustomErr4

; 19551: 	    WXS_ATTR_TYPEDEF(attr), XML_SCHEMAS_ID))
; 19552: 	{
; 19553: 	    xmlSchemaCustomErr(ACTXT_CAST pctxt,
; 19554: 		XML_SCHEMAP_A_PROPS_CORRECT_3,
; 19555: 		NULL, WXS_BASIC_CAST attr,
; 19556: 		"Value constraints are not allowed if the type definition "
; 19557: 		"is or is derived from xs:ID",
; 19558: 		NULL, NULL);
; 19559: 	    return(pctxt->err);

	mov	eax, DWORD PTR [esi+16]

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	add	esp, 36					; 00000024H
	pop	edi

; 19589: }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlSchemaC:

; 19560: 	}
; 19561: 	/*
; 19562: 	* SPEC a-props-correct (2)
; 19563: 	* "if there is a {value constraint}, the canonical lexical
; 19564: 	* representation of its value must be `valid` with respect
; 19565: 	* to the {type definition} as defined in String Valid ($3.14.4)."
; 19566: 	* TODO: Don't care about the *canonical* stuff here, this requirement
; 19567: 	* will be removed in WXS 1.1 anyway.
; 19568: 	*/
; 19569: 	ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST pctxt,

	mov	edi, DWORD PTR _pctxt$[ebp]
	lea	eax, DWORD PTR [esi+68]
	push	1
	push	1
	push	eax
	push	DWORD PTR [esi+44]
	push	DWORD PTR [esi+48]
	push	DWORD PTR [esi+52]
	push	edi
	call	_xmlSchemaVCheckCVCSimpleType
	add	esp, 32					; 00000020H

; 19570: 	    attr->node, WXS_ATTR_TYPEDEF(attr),
; 19571: 	    attr->defValue, &(attr->defVal),
; 19572: 	    1, 1, 0);
; 19573: 	if (ret != 0) {

	test	eax, eax
	je	SHORT $LN5@xmlSchemaC

; 19574: 	    if (ret < 0) {

	jns	SHORT $LN6@xmlSchemaC

; 19575: 		PERROR_INT("xmlSchemaCheckAttrPropsCorrect",

	push	OFFSET ??_C@_0CH@HOPMNJDI@calling?5xmlSchemaVCheckCVCSimpl@
	push	OFFSET ??_C@_0BP@KEKKKHHB@xmlSchemaCheckAttrPropsCorrect@
	push	edi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH

; 19576: 		    "calling xmlSchemaVCheckCVCSimpleType()");
; 19577: 		return(-1);

	or	eax, -1
	pop	edi

; 19589: }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlSchemaC:

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CP@DMDDKJIO@The?5value?5of?5the?5value?5constrai@
	push	esi
	push	0
	push	3079					; 00000c07H
	push	edi
	call	_xmlSchemaCustomErr4

; 19578: 	    }
; 19579: 	    xmlSchemaCustomErr(ACTXT_CAST pctxt,
; 19580: 		XML_SCHEMAP_A_PROPS_CORRECT_2,
; 19581: 		NULL, WXS_BASIC_CAST attr,
; 19582: 		"The value of the value constraint is not valid",
; 19583: 		NULL, NULL);
; 19584: 	    return(pctxt->err);

	mov	eax, DWORD PTR [edi+16]

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	add	esp, 36					; 00000024H
	pop	edi

; 19589: }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlSchemaC:
	pop	edi

; 19585: 	}
; 19586:     }
; 19587: 
; 19588:     return(0);

	xor	eax, eax

; 19589: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaCheckAttrPropsCorrect ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaResolveAttrGroupReferences
_TEXT	SEGMENT
_nsName$1$ = -4						; size = 4
_name$1$ = 8						; size = 4
_ref$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_xmlSchemaResolveAttrGroupReferences PROC		; COMDAT

; 19492: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN2@xmlSchemaR

; 19493:     xmlSchemaAttributeGroupPtr group;
; 19494: 
; 19495:     if (ref->item != NULL)
; 19496:         return(0);

	xor	eax, eax
	pop	esi

; 19510: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlSchemaR:

; 19497:     group = xmlSchemaGetAttributeGroup(ctxt->schema,

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+16]
	push	ebx
	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	edi

; 4901 :     xmlSchemaAttributeGroupPtr ret = NULL;

	xor	edi, edi

; 19497:     group = xmlSchemaGetAttributeGroup(ctxt->schema,

	mov	DWORD PTR _nsName$1$[ebp], ecx
	mov	DWORD PTR _name$1$[ebp], eax
	mov	ebx, DWORD PTR [ebx+36]

; 4903 :     if ((name == NULL) || (schema == NULL))

	test	eax, eax
	je	SHORT $LN16@xmlSchemaR
	test	ebx, ebx
	je	SHORT $LN16@xmlSchemaR

; 4904 :         return (NULL);
; 4905 :     if (schema != NULL) {
; 4906 : 	WXS_FIND_GLOBAL_ITEM(attrgrpDecl)

	push	DWORD PTR [ebx+4]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlSchemaR
	push	DWORD PTR _name$1$[ebp]
	push	DWORD PTR [ebx+36]
	call	_xmlHashLookup
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	jne	SHORT $LN3@xmlSchemaR
$LN10@xmlSchemaR:
	push	DWORD PTR [ebx+48]
	call	_xmlHashSize
	add	esp, 4
	cmp	eax, 1
	jle	SHORT $exit$20
	mov	ecx, DWORD PTR _nsName$1$[ebp]
	mov	eax, OFFSET ??_C@_02IEBMKJDF@?$CD?$CD@
	test	ecx, ecx
	cmovne	eax, ecx
	push	eax
	mov	eax, DWORD PTR [ebx+48]
	push	eax
	call	_xmlHashLookup
	add	esp, 8
	test	eax, eax
	je	SHORT $exit$20
	mov	eax, DWORD PTR [eax+52]
	push	DWORD PTR _name$1$[ebp]
	push	DWORD PTR [eax+36]
	call	_xmlHashLookup
	add	esp, 8
	mov	edi, eax
$exit$20:

; 19498: 	ref->name,
; 19499: 	ref->targetNamespace);
; 19500:     if (group == NULL) {

	test	edi, edi
	je	SHORT $LN16@xmlSchemaR
$LN3@xmlSchemaR:

; 19507:     }
; 19508:     ref->item = WXS_BASIC_CAST group;

	mov	DWORD PTR [esi+4], edi

; 19509:     return(0);

	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 19510: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlSchemaR:

; 19501: 	xmlSchemaPResCompAttrErr(ctxt,

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	0
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+16]
	push	DWORD PTR [esi+12]
	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	DWORD PTR [esi+20]
	push	0
	push	3004					; 00000bbcH
	push	ebx
	call	_xmlSchemaPResCompAttrErr

; 19502: 	    XML_SCHEMAP_SRC_RESOLVE,
; 19503: 	    NULL, ref->node,
; 19504: 	    "ref", ref->name, ref->targetNamespace,
; 19505: 	    ref->itemType, NULL);
; 19506: 	return(ctxt->err);

	mov	eax, DWORD PTR [ebx+16]
	add	esp, 36					; 00000024H
	pop	edi
	pop	ebx
	pop	esi

; 19510: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaResolveAttrGroupReferences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckAGPropsCorrect
_TEXT	SEGMENT
_hasId$1$ = -16						; size = 4
_uses$1$ = -12						; size = 4
_use$1$ = -8						; size = 4
_str$1 = -8						; size = 4
_str$2 = -4						; size = 4
_pctxt$ = 8						; size = 4
_attrGr$ = 12						; size = 4
_xmlSchemaCheckAGPropsCorrect PROC			; COMDAT

; 19395: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _attrGr$[ebp]
	mov	esi, DWORD PTR [esi+56]
	mov	DWORD PTR _uses$1$[ebp], esi
	test	esi, esi
	je	$LN36@xmlSchemaC

; 19396:     /*
; 19397:     * SPEC ag-props-correct
; 19398:     * (1) "The values of the properties of an attribute group definition
; 19399:     * must be as described in the property tableau in The Attribute
; 19400:     * Group Definition Schema Component ($3.6.1), modulo the impact of
; 19401:     * Missing Sub-components ($5.3);"
; 19402:     */
; 19403: 
; 19404:     if ((attrGr->attrUses != NULL) &&

	mov	edi, DWORD PTR [esi+4]
	cmp	edi, 1
	jle	$LN36@xmlSchemaC

; 19405: 	(WXS_LIST_CAST attrGr->attrUses)->nbItems > 1)
; 19406:     {
; 19407: 	xmlSchemaItemListPtr uses = WXS_LIST_CAST attrGr->attrUses;
; 19408: 	xmlSchemaAttributeUsePtr use, tmp;
; 19409: 	int i, j, hasId = 0;
; 19410: 
; 19411: 	for (i = uses->nbItems -1; i >= 0; i--) {

	add	edi, -1
	mov	DWORD PTR _hasId$1$[ebp], 0
	js	$LN36@xmlSchemaC
$LL4@xmlSchemaC:

; 19412: 	    use = uses->items[i];

	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR _use$1$[ebp], ebx

; 19413: 	    /*
; 19414: 	    * SPEC ag-props-correct
; 19415: 	    * (2) "Two distinct members of the {attribute uses} must not have
; 19416: 	    * {attribute declaration}s both of whose {name}s match and whose
; 19417: 	    * {target namespace}s are identical."
; 19418: 	    */
; 19419: 	    if (i > 0) {

	test	edi, edi
	jle	SHORT $LN35@xmlSchemaC

; 19420: 		for (j = i -1; j >= 0; j--) {

	lea	ecx, DWORD PTR [edi-1]
	cmp	edi, 1
	jl	SHORT $LN35@xmlSchemaC

; 19421: 		    tmp = uses->items[j];
; 19422: 		    if ((WXS_ATTRUSE_DECL_NAME(use) ==
; 19423: 			WXS_ATTRUSE_DECL_NAME(tmp)) &&

	mov	ebx, DWORD PTR [ebx+12]
	lea	edx, DWORD PTR [edi-1]
	lea	edx, DWORD PTR [eax+edx*4]
	npad	3
$LL7@xmlSchemaC:
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [ebx+8]
	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN5@xmlSchemaC
	mov	eax, DWORD PTR [ebx+56]
	cmp	eax, DWORD PTR [esi+56]
	je	$LN25@xmlSchemaC
$LN5@xmlSchemaC:

; 19420: 		for (j = i -1; j >= 0; j--) {

	sub	edx, 4
	sub	ecx, 1
	jns	SHORT $LL7@xmlSchemaC
	mov	ebx, DWORD PTR _use$1$[ebp]
	mov	esi, DWORD PTR _uses$1$[ebp]
$LN35@xmlSchemaC:

; 19440: 			    return(-1);
; 19441: 			goto next_use;
; 19442: 		    }
; 19443: 		}
; 19444: 	    }
; 19445: 	    /*
; 19446: 	    * SPEC ag-props-correct
; 19447: 	    * (3) "Two distinct members of the {attribute uses} must not have
; 19448: 	    * {attribute declaration}s both of whose {type definition}s are or
; 19449: 	    * are derived from ID."
; 19450: 	    * TODO: Does 'derived' include member-types of unions?
; 19451: 	    */
; 19452: 	    if (WXS_ATTRUSE_TYPEDEF(use) != NULL) {

	mov	eax, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [eax+48]
	test	eax, eax
	je	SHORT $next_use$39

; 19453: 		if (xmlSchemaIsDerivedFromBuiltInType(

	push	23					; 00000017H
	push	eax
	call	_xmlSchemaIsDerivedFromBuiltInType
	add	esp, 8
	test	eax, eax
	je	SHORT $next_use$39

; 19454: 		    WXS_ATTRUSE_TYPEDEF(use), XML_SCHEMAS_ID))
; 19455: 		{
; 19456: 		    if (hasId) {

	cmp	DWORD PTR _hasId$1$[ebp], 0
	je	SHORT $LN17@xmlSchemaC

; 19457: 			xmlChar *str = NULL;
; 19458: 
; 19459: 			xmlSchemaCustomErr(ACTXT_CAST pctxt,

	lea	eax, DWORD PTR _str$1[ebp]
	mov	DWORD PTR _str$1[ebp], 0
	push	ebx
	push	eax
	call	_xmlSchemaGetComponentDesignation

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR _attrGr$[ebp]
	push	OFFSET ??_C@_0IE@LIFNGLDM@There?5must?5not?5exist?5more?5than?5@
	push	eax
	push	DWORD PTR [eax+32]
	push	3087					; 00000c0fH
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaCustomErr4

; 19460: 			    XML_SCHEMAP_AG_PROPS_CORRECT,
; 19461: 			    attrGr->node, WXS_BASIC_CAST attrGr,
; 19462: 			    "There must not exist more than one attribute "
; 19463: 			    "declaration of type 'xs:ID' "
; 19464: 			    "(or derived from 'xs:ID'). The %s violates this "
; 19465: 			    "constraint",
; 19466: 			    xmlSchemaGetComponentDesignation(&str, use),
; 19467: 			    NULL);
; 19468: 			FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$1[ebp]

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	add	esp, 44					; 0000002cH

; 19460: 			    XML_SCHEMAP_AG_PROPS_CORRECT,
; 19461: 			    attrGr->node, WXS_BASIC_CAST attrGr,
; 19462: 			    "There must not exist more than one attribute "
; 19463: 			    "declaration of type 'xs:ID' "
; 19464: 			    "(or derived from 'xs:ID'). The %s violates this "
; 19465: 			    "constraint",
; 19466: 			    xmlSchemaGetComponentDesignation(&str, use),
; 19467: 			    NULL);
; 19468: 			FREE_AND_NULL(str);

	test	eax, eax
	je	SHORT $LN16@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlSchemaC:

; 19469: 			if (xmlSchemaItemListRemove(uses, i) == -1)

	push	edi
	push	esi
	call	_xmlSchemaItemListRemove
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN27@xmlSchemaC
$LN17@xmlSchemaC:

; 19470: 			    return(-1);
; 19471: 		    }
; 19472: 		    hasId = 1;

	mov	DWORD PTR _hasId$1$[ebp], 1
$next_use$39:

; 19405: 	(WXS_LIST_CAST attrGr->attrUses)->nbItems > 1)
; 19406:     {
; 19407: 	xmlSchemaItemListPtr uses = WXS_LIST_CAST attrGr->attrUses;
; 19408: 	xmlSchemaAttributeUsePtr use, tmp;
; 19409: 	int i, j, hasId = 0;
; 19410: 
; 19411: 	for (i = uses->nbItems -1; i >= 0; i--) {

	sub	edi, 1
	jns	$LL4@xmlSchemaC
$LN36@xmlSchemaC:
	pop	edi

; 19473: 		}
; 19474: 	    }
; 19475: next_use: {}
; 19476: 	}
; 19477:     }
; 19478:     return(0);
; 19479: }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlSchemaC:

; 19424: 			(WXS_ATTRUSE_DECL_TNS(use) ==
; 19425: 			WXS_ATTRUSE_DECL_TNS(tmp)))
; 19426: 		    {
; 19427: 			xmlChar *str = NULL;
; 19428: 
; 19429: 			xmlSchemaCustomErr(ACTXT_CAST pctxt,

	push	DWORD PTR _use$1$[ebp]
	lea	eax, DWORD PTR _str$2[ebp]
	mov	DWORD PTR _str$2[ebp], 0
	push	eax
	call	_xmlSchemaGetComponentDesignation

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	mov	ebx, DWORD PTR _attrGr$[ebp]
	push	0
	push	0
	push	0
	push	eax
	push	OFFSET ??_C@_0N@NMANGDLF@Duplicate?5?$CFs@
	push	ebx
	push	DWORD PTR [ebx+32]
	push	3087					; 00000c0fH
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaCustomErr4

; 19430: 			    XML_SCHEMAP_AG_PROPS_CORRECT,
; 19431: 			    attrGr->node, WXS_BASIC_CAST attrGr,
; 19432: 			    "Duplicate %s",
; 19433: 			    xmlSchemaGetComponentDesignation(&str, use),
; 19434: 			    NULL);
; 19435: 			FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$2[ebp]

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	add	esp, 44					; 0000002cH

; 19430: 			    XML_SCHEMAP_AG_PROPS_CORRECT,
; 19431: 			    attrGr->node, WXS_BASIC_CAST attrGr,
; 19432: 			    "Duplicate %s",
; 19433: 			    xmlSchemaGetComponentDesignation(&str, use),
; 19434: 			    NULL);
; 19435: 			FREE_AND_NULL(str);

	test	eax, eax
	je	SHORT $LN11@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlSchemaC:

; 19436: 			/*
; 19437: 			* Remove the duplicate.
; 19438: 			*/
; 19439: 			if (xmlSchemaItemListRemove(uses, i) == -1)

	mov	esi, DWORD PTR _uses$1$[ebp]
	push	edi
	push	esi
	call	_xmlSchemaItemListRemove
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $next_use$39
$LN27@xmlSchemaC:
	pop	edi

; 19473: 		}
; 19474: 	    }
; 19475: next_use: {}
; 19476: 	}
; 19477:     }
; 19478:     return(0);
; 19479: }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCheckAGPropsCorrect ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAttributeGroupExpandRefs
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_attrGr$ = 12						; size = 4
_xmlSchemaAttributeGroupExpandRefs PROC			; COMDAT

; 19369: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _attrGr$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	test	edx, edx
	je	SHORT $LN3@xmlSchemaA

; 19370:     if ((attrGr->attrUses == NULL) ||

	mov	eax, DWORD PTR [ecx+36]
	test	al, 1
	jne	SHORT $LN3@xmlSchemaA

; 19373: 
; 19374:     attrGr->flags |= XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED;

	or	eax, 1

; 19375:     if (xmlSchemaExpandAttributeGroupRefs(pctxt, WXS_BASIC_CAST attrGr,
; 19376: 	&(attrGr->attributeWildcard), attrGr->attrUses, NULL) == -1)

	push	0
	push	edx
	mov	DWORD PTR [ecx+36], eax
	lea	eax, DWORD PTR [ecx+40]
	push	eax
	push	ecx
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaExpandAttributeGroupRefs
	add	esp, 20					; 00000014H
	cmp	eax, -1
	jne	SHORT $LN3@xmlSchemaA

; 19377: 	return(-1);

	or	eax, eax

; 19378:     return(0);
; 19379: }

	pop	ebp
	ret	0
$LN3@xmlSchemaA:

; 19371: 	(attrGr->flags & XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED))
; 19372: 	return(0);

	xor	eax, eax

; 19378:     return(0);
; 19379: }

	pop	ebp
	ret	0
_xmlSchemaAttributeGroupExpandRefs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckAttrGroupCircular
_TEXT	SEGMENT
_str$1 = 8						; size = 4
_attrGr$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_xmlSchemaCheckAttrGroupCircular PROC			; COMDAT

; 19131: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _attrGr$[ebp]
	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN6@xmlSchemaC

; 19132:     /*
; 19133:     * Schema Representation Constraint:
; 19134:     * Attribute Group Definition Representation OK
; 19135:     * 3 Circular group reference is disallowed outside <redefine>.
; 19136:     * That is, unless this element information item's parent is
; 19137:     * <redefine>, then among the [children], if any, there must
; 19138:     * not be an <attributeGroup> with ref [attribute] which resolves
; 19139:     * to the component corresponding to this <attributeGroup>. Indirect
; 19140:     * circularity is also ruled out. That is, when QName resolution
; 19141:     * (Schema Document) ($3.15.3) is applied to a `QName` arising from
; 19142:     * any <attributeGroup>s with a ref [attribute] among the [children],
; 19143:     * it must not be the case that a `QName` is encountered at any depth
; 19144:     * which resolves to the component corresponding to this <attributeGroup>.
; 19145:     */
; 19146:     if (attrGr->attrUses == NULL)
; 19147: 	return(0);
; 19148:     else if ((attrGr->flags & XML_SCHEMAS_ATTRGROUP_HAS_REFS) == 0)

	test	BYTE PTR [esi+36], 16			; 00000010H
	je	SHORT $LN6@xmlSchemaC

; 19149: 	return(0);
; 19150:     else {
; 19151: 	xmlSchemaQNameRefPtr circ;
; 19152: 
; 19153: 	circ = xmlSchemaCheckAttrGroupCircularRecur(attrGr,

	push	eax
	push	esi
	call	_xmlSchemaCheckAttrGroupCircularRecur
	mov	edi, eax
	add	esp, 8

; 19154: 	    (xmlSchemaItemListPtr) attrGr->attrUses);
; 19155: 	if (circ != NULL) {

	test	edi, edi
	je	SHORT $LN6@xmlSchemaC

; 1429 :     return (xmlSchemaFormatQName(buf,

	push	esi

; 19156: 	    xmlChar *str = NULL;

	mov	DWORD PTR _str$1[ebp], 0

; 1429 :     return (xmlSchemaFormatQName(buf,

	call	_xmlSchemaGetComponentName
	add	esp, 4
	push	eax
	push	esi
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _str$1[ebp]
	push	eax
	call	_xmlSchemaFormatQName

; 19157: 	    /*
; 19158: 	    * TODO: Report the referenced attr group as QName.
; 19159: 	    */
; 19160: 	    xmlSchemaPCustomErr(ctxt,

	push	edi

; 1429 :     return (xmlSchemaFormatQName(buf,

	mov	esi, eax

; 19157: 	    /*
; 19158: 	    * TODO: Report the referenced attr group as QName.
; 19159: 	    */
; 19160: 	    xmlSchemaPCustomErr(ctxt,

	call	_xmlSchemaGetComponentNode

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	OFFSET ??_C@_0DH@FDECNJHO@Circular?5reference?5to?5the?5attri@
	push	eax
	push	0
	push	3073					; 00000c01H
	push	esi
	call	_xmlSchemaPCustomErrExt

; 19161: 		XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3,
; 19162: 		NULL, WXS_ITEM_NODE(WXS_BASIC_CAST circ),
; 19163: 		"Circular reference to the attribute group '%s' "
; 19164: 		"defined", xmlSchemaGetComponentQName(&str, attrGr));
; 19165: 	    FREE_AND_NULL(str);

	mov	ecx, DWORD PTR _str$1[ebp]

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	add	esp, 48					; 00000030H

; 19161: 		XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3,
; 19162: 		NULL, WXS_ITEM_NODE(WXS_BASIC_CAST circ),
; 19163: 		"Circular reference to the attribute group '%s' "
; 19164: 		"defined", xmlSchemaGetComponentQName(&str, attrGr));
; 19165: 	    FREE_AND_NULL(str);

	test	ecx, ecx
	je	SHORT $LN7@xmlSchemaC
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlSchemaC:

; 19166: 	    /*
; 19167: 	    * NOTE: We will cut the reference to avoid further
; 19168: 	    * confusion of the processor.
; 19169: 	    * BADSPEC TODO: The spec should define how to process in this case.
; 19170: 	    */
; 19171: 	    circ->item = NULL;

	mov	DWORD PTR [edi+4], 0

; 19172: 	    return(ctxt->err);

	mov	eax, DWORD PTR [esi+16]
	pop	edi

; 19176: }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlSchemaC:
	pop	edi

; 19173: 	}
; 19174:     }
; 19175:     return(0);

	xor	eax, eax

; 19176: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaCheckAttrGroupCircular ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckAttrGroupCircularRecur
_TEXT	SEGMENT
_ctxtGr$ = 8						; size = 4
_list$ = 12						; size = 4
_xmlSchemaCheckAttrGroupCircularRecur PROC		; COMDAT

; 19081: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _list$[ebp]
	xor	edi, edi
	cmp	DWORD PTR [ebx+4], edi
	jle	SHORT $LN17@xmlSchemaC
	mov	edx, DWORD PTR _ctxtGr$[ebp]
	npad	3
$LL4@xmlSchemaC:

; 19090: 	ref = list->items[i];

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+edi*4]

; 19091: 	if ((ref->type == XML_SCHEMA_EXTRA_QNAMEREF) &&
; 19092: 	    (ref->itemType == XML_SCHEMA_TYPE_ATTRIBUTEGROUP) &&

	cmp	DWORD PTR [eax], 2000			; 000007d0H
	jne	SHORT $LN2@xmlSchemaC
	cmp	DWORD PTR [eax+8], 16			; 00000010H
	jne	SHORT $LN2@xmlSchemaC
	mov	esi, DWORD PTR [eax+4]
	test	esi, esi
	je	SHORT $LN2@xmlSchemaC

; 19093: 	    (ref->item != NULL))
; 19094: 	{
; 19095: 	    gr = WXS_ATTR_GROUP_CAST ref->item;
; 19096: 	    if (gr == ctxtGr)

	cmp	esi, edx
	je	SHORT $LN1@xmlSchemaC

; 19097: 		return(ref);
; 19098: 	    if (gr->flags & XML_SCHEMAS_ATTRGROUP_MARKED)

	mov	eax, DWORD PTR [esi+36]
	test	al, 4
	jne	SHORT $LN2@xmlSchemaC

; 19099: 		continue;
; 19100: 	    /*
; 19101: 	    * Mark as visited to avoid infinite recursion on
; 19102: 	    * circular references not yet examined.
; 19103: 	    */
; 19104: 	    if ((gr->attrUses) &&

	mov	ecx, DWORD PTR [esi+56]
	test	ecx, ecx
	je	SHORT $LN2@xmlSchemaC
	test	al, 16					; 00000010H
	je	SHORT $LN2@xmlSchemaC

; 19105: 		(gr->flags & XML_SCHEMAS_ATTRGROUP_HAS_REFS))
; 19106: 	    {
; 19107: 		gr->flags |= XML_SCHEMAS_ATTRGROUP_MARKED;
; 19108: 		circ = xmlSchemaCheckAttrGroupCircularRecur(ctxtGr,

	push	ecx
	or	eax, 4
	push	edx
	mov	DWORD PTR [esi+36], eax
	call	_xmlSchemaCheckAttrGroupCircularRecur

; 19109: 		    (xmlSchemaItemListPtr) gr->attrUses);
; 19110: 		gr->flags ^= XML_SCHEMAS_ATTRGROUP_MARKED;

	xor	DWORD PTR [esi+36], 4
	add	esp, 8

; 19111: 		if (circ != NULL)

	test	eax, eax
	jne	SHORT $LN1@xmlSchemaC
	mov	edx, DWORD PTR _ctxtGr$[ebp]
$LN2@xmlSchemaC:

; 19082:     xmlSchemaAttributeGroupPtr gr;
; 19083:     xmlSchemaQNameRefPtr ref, circ;
; 19084:     int i;
; 19085:     /*
; 19086:     * We will search for an attribute group reference which
; 19087:     * references the context attribute group.
; 19088:     */
; 19089:     for (i = 0; i < list->nbItems; i++) {

	inc	edi
	cmp	edi, DWORD PTR [ebx+4]
	jl	SHORT $LL4@xmlSchemaC
$LN17@xmlSchemaC:

; 19112: 		    return (circ);
; 19113: 	    }
; 19114: 
; 19115: 	}
; 19116:     }
; 19117:     return (NULL);

	xor	eax, eax
$LN1@xmlSchemaC:
	pop	edi

; 19118: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaCheckAttrGroupCircularRecur ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaModelGroupToModelGroupDefFixup
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_mg$ = 12						; size = 4
_xmlSchemaModelGroupToModelGroupDefFixup PROC		; COMDAT

; 19039: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _mg$[ebp]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaM
$LL2@xmlSchemaM:

; 19043: 	if ((WXS_PARTICLE_TERM(particle) == NULL) ||

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN6@xmlSchemaM
	cmp	DWORD PTR [ecx], 17			; 00000011H
	jne	SHORT $LN6@xmlSchemaM

; 19044: 	    ((WXS_PARTICLE_TERM(particle))->type !=
; 19045: 		XML_SCHEMA_TYPE_GROUP))
; 19046: 	{
; 19047: 	    particle = WXS_PTC_CAST particle->next;
; 19048: 	    continue;
; 19049: 	}
; 19050: 	if (WXS_MODELGROUPDEF_MODEL(WXS_PARTICLE_TERM(particle)) == NULL) {

	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN6@xmlSchemaM:

; 19040:     xmlSchemaParticlePtr particle = WXS_MODELGROUP_PARTICLE(mg);
; 19041: 
; 19042:     while (particle != NULL) {

	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	jne	SHORT $LL2@xmlSchemaM
$LN3@xmlSchemaM:

; 19051: 	    /*
; 19052: 	    * TODO: Remove the particle.
; 19053: 	    */
; 19054: 	    WXS_PARTICLE_TERM(particle) = NULL;
; 19055: 	    particle = WXS_PTC_CAST particle->next;
; 19056: 	    continue;
; 19057: 	}
; 19058: 	/*
; 19059: 	* Assign the model group to the {term} of the particle.
; 19060: 	*/
; 19061: 	WXS_PARTICLE_TERM(particle) =
; 19062: 	    WXS_TREE_CAST WXS_MODELGROUPDEF_MODEL(WXS_PARTICLE_TERM(particle));
; 19063: 
; 19064: 	particle = WXS_PTC_CAST particle->next;
; 19065:     }
; 19066: }

	pop	ebp
	ret	0
_xmlSchemaModelGroupToModelGroupDefFixup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckGroupDefCircular
_TEXT	SEGMENT
_str$1 = 8						; size = 4
_item$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_xmlSchemaCheckGroupDefCircular PROC			; COMDAT

; 18981: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _item$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaC

; 18982:     /*
; 18983:     * Schema Component Constraint: Model Group Correct
; 18984:     * 2 Circular groups are disallowed. That is, within the {particles}
; 18985:     * of a group there must not be at any depth a particle whose {term}
; 18986:     * is the group itself.
; 18987:     */
; 18988:     if ((item == NULL) ||
; 18989: 	(item->type != XML_SCHEMA_TYPE_GROUP) ||

	cmp	DWORD PTR [esi], 17			; 00000011H
	jne	SHORT $LN3@xmlSchemaC
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaC

; 18990: 	(item->children == NULL))
; 18991: 	return;
; 18992:     {
; 18993: 	xmlSchemaTreeItemPtr circ;
; 18994: 
; 18995: 	circ = xmlSchemaGetCircModelGrDefRef(item, item->children->children);

	push	edi
	push	DWORD PTR [eax+12]
	push	esi
	call	_xmlSchemaGetCircModelGrDefRef
	mov	edi, eax
	add	esp, 8

; 18996: 	if (circ != NULL) {

	test	edi, edi
	je	SHORT $LN9@xmlSchemaC

; 18997: 	    xmlChar *str = NULL;
; 18998: 	    /*
; 18999: 	    * TODO: The error report is not adequate: this constraint
; 19000: 	    * is defined for model groups but not definitions, but since
; 19001: 	    * there cannot be any circular model groups without a model group
; 19002: 	    * definition (if not using a construction API), we check those
; 19003: 	    * defintions only.
; 19004: 	    */
; 19005: 	    xmlSchemaPCustomErr(ctxt,

	push	DWORD PTR [esi+16]
	lea	eax, DWORD PTR _str$1[ebp]
	mov	DWORD PTR _str$1[ebp], 0
	push	DWORD PTR [esi+20]
	push	eax
	call	_xmlSchemaFormatQName
	push	edi
	mov	esi, eax
	call	_xmlSchemaGetComponentNode

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	esi
	push	OFFSET ??_C@_0DO@EEBKKJHN@Circular?5reference?5to?5the?5model@
	push	eax
	push	0
	push	3075					; 00000c03H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPCustomErrExt

; 19006: 		XML_SCHEMAP_MG_PROPS_CORRECT_2,
; 19007: 		NULL, WXS_ITEM_NODE(circ),
; 19008: 		"Circular reference to the model group definition '%s' "
; 19009: 		"defined", xmlSchemaFormatQName(&str,
; 19010: 		    item->targetNamespace, item->name));
; 19011: 	    FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$1[ebp]

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	add	esp, 48					; 00000030H

; 19006: 		XML_SCHEMAP_MG_PROPS_CORRECT_2,
; 19007: 		NULL, WXS_ITEM_NODE(circ),
; 19008: 		"Circular reference to the model group definition '%s' "
; 19009: 		"defined", xmlSchemaFormatQName(&str,
; 19010: 		    item->targetNamespace, item->name));
; 19011: 	    FREE_AND_NULL(str)

	test	eax, eax
	je	SHORT $LN5@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlSchemaC:

; 19012: 	    /*
; 19013: 	    * NOTE: We will cut the reference to avoid further
; 19014: 	    * confusion of the processor. This is a fatal error.
; 19015: 	    */
; 19016: 	    circ->children = NULL;

	mov	DWORD PTR [edi+12], 0
$LN9@xmlSchemaC:
	pop	edi
$LN3@xmlSchemaC:
	pop	esi

; 19017: 	}
; 19018:     }
; 19019: }

	pop	ebp
	ret	0
_xmlSchemaCheckGroupDefCircular ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetCircModelGrDefRef
_TEXT	SEGMENT
_groupDef$ = 8						; size = 4
_particle$ = 12						; size = 4
_xmlSchemaGetCircModelGrDefRef PROC			; COMDAT

; 18927: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _particle$[ebp]
	test	edi, edi
	je	SHORT $LN24@xmlSchemaG
	mov	ebx, DWORD PTR _groupDef$[ebp]
	npad	6
$LL4@xmlSchemaG:

; 18933: 	term = particle->children;

	mov	esi, DWORD PTR [edi+12]

; 18934: 	if (term == NULL)

	test	esi, esi
	je	SHORT $LN2@xmlSchemaG

; 18935: 	    continue;
; 18936: 	switch (term->type) {

	mov	eax, DWORD PTR [esi]
	cmp	eax, 6
	jl	SHORT $LN2@xmlSchemaG
	cmp	eax, 8
	jle	SHORT $LN13@xmlSchemaG
	cmp	eax, 17					; 00000011H
	jne	SHORT $LN2@xmlSchemaG

; 18937: 	    case XML_SCHEMA_TYPE_GROUP:
; 18938: 		gdef = (xmlSchemaModelGroupDefPtr) term;
; 18939: 		if (gdef == groupDef)

	cmp	esi, ebx
	je	SHORT $LN18@xmlSchemaG

; 18941: 		/*
; 18942: 		* Mark this model group definition to avoid infinite
; 18943: 		* recursion on circular references not yet examined.
; 18944: 		*/
; 18945: 		if (gdef->flags & XML_SCHEMA_MODEL_GROUP_DEF_MARKED)

	mov	eax, DWORD PTR [esi+28]
	test	al, 1
	jne	SHORT $LN2@xmlSchemaG

; 18946: 		    continue;
; 18947: 		if (gdef->children != NULL) {

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $LN2@xmlSchemaG

; 18948: 		    gdef->flags |= XML_SCHEMA_MODEL_GROUP_DEF_MARKED;

	or	eax, 1
	mov	DWORD PTR [esi+28], eax

; 18949: 		    circ = xmlSchemaGetCircModelGrDefRef(groupDef,

	push	DWORD PTR [ecx+12]
	push	ebx
	call	_xmlSchemaGetCircModelGrDefRef

; 18950: 			gdef->children->children);
; 18951: 		    gdef->flags ^= XML_SCHEMA_MODEL_GROUP_DEF_MARKED;

	xor	DWORD PTR [esi+28], 1

; 18952: 		    if (circ != NULL)
; 18953: 			return (circ);
; 18954: 		}
; 18955: 		break;

	jmp	SHORT $LN26@xmlSchemaG
$LN13@xmlSchemaG:

; 18956: 	    case XML_SCHEMA_TYPE_SEQUENCE:
; 18957: 	    case XML_SCHEMA_TYPE_CHOICE:
; 18958: 	    case XML_SCHEMA_TYPE_ALL:
; 18959: 		circ = xmlSchemaGetCircModelGrDefRef(groupDef, term->children);

	push	DWORD PTR [esi+12]
	push	ebx
	call	_xmlSchemaGetCircModelGrDefRef
$LN26@xmlSchemaG:

; 18928:     xmlSchemaTreeItemPtr circ = NULL;
; 18929:     xmlSchemaTreeItemPtr term;
; 18930:     xmlSchemaModelGroupDefPtr gdef;
; 18931: 
; 18932:     for (; particle != NULL; particle = particle->next) {

	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@xmlSchemaG
$LN2@xmlSchemaG:
	mov	edi, DWORD PTR [edi+8]
	test	edi, edi
	jne	SHORT $LL4@xmlSchemaG
$LN24@xmlSchemaG:

; 18960: 		if (circ != NULL)
; 18961: 		    return (circ);
; 18962: 		break;
; 18963: 	    default:
; 18964: 		break;
; 18965: 	}
; 18966:     }
; 18967:     return (NULL);

	xor	eax, eax
$LN1@xmlSchemaG:
	pop	edi

; 18968: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN18@xmlSchemaG:

; 18940: 		    return (particle);

	mov	eax, edi
	pop	edi

; 18968: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaGetCircModelGrDefRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFixupComplexType
_TEXT	SEGMENT
_olderrs$1$ = -8					; size = 4
_dummySequence$1$ = -4					; size = 4
_msg$1 = 8						; size = 4
_particle$1$ = 8					; size = 4
_msg$2 = 8						; size = 4
_contentBase$1$ = 8					; size = 4
_pctxt$ = 8						; size = 4
tv1096 = 12						; size = 4
tv1080 = 12						; size = 4
_particle$3$ = 12					; size = 4
_type$ = 12						; size = 4
_xmlSchemaFixupComplexType PROC				; COMDAT

; 18189: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _type$[ebp]
	mov	ebx, DWORD PTR _pctxt$[ebp]
	cmp	DWORD PTR [edi], 1
	mov	eax, DWORD PTR [ebx+20]
	mov	esi, DWORD PTR [edi+64]
	mov	DWORD PTR _olderrs$1$[ebp], eax
	je	$LN3@xmlSchemaF

; 18190:     int res = 0, olderrs = pctxt->nberrors;
; 18191:     xmlSchemaTypePtr baseType = type->baseType;
; 18192: 
; 18193:     if (! WXS_IS_TYPE_NOT_FIXED(type))

	mov	eax, DWORD PTR [edi+48]
	test	eax, 4194304				; 00400000H
	jne	$LN3@xmlSchemaF

; 18194: 	return(0);
; 18195:     type->flags |= XML_SCHEMAS_TYPE_INTERNAL_RESOLVED;

	or	eax, 4194304				; 00400000H
	mov	DWORD PTR [edi+48], eax

; 18196:     if (baseType == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlSchemaF

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	esi
	push	esi
	push	OFFSET ??_C@_0BB@DAFLJMHA@missing?5baseType@
	push	OFFSET ??_C@_0BK@JMGNNAEE@xmlSchemaFixupComplexType@
	push	ebx
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$exit_failure$129:

; 18618: 
; 18619: exit_failure:
; 18620:     type->flags |= XML_SCHEMAS_TYPE_INTERNAL_INVALID;

	or	DWORD PTR [edi+48], 8388608		; 00800000H

; 18621: #ifdef DEBUG_TYPE
; 18622:     xmlSchemaDebugFixedType(pctxt, type);
; 18623: #endif
; 18624:     return(-1);

	or	eax, -1
	pop	edi

; 18625: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlSchemaF:

; 18197: 	PERROR_INT("xmlSchemaFixupComplexType",
; 18198: 	    "missing baseType");
; 18199: 	goto exit_failure;
; 18200:     }
; 18201:     /*
; 18202:     * Fixup the base type.
; 18203:     */
; 18204:     if (WXS_IS_TYPE_NOT_FIXED(baseType))

	cmp	DWORD PTR [esi], 1
	je	SHORT $LN5@xmlSchemaF
	test	DWORD PTR [esi+48], 4194304		; 00400000H
	jne	SHORT $LN5@xmlSchemaF

; 18205: 	xmlSchemaTypeFixup(baseType, ACTXT_CAST pctxt);

	push	ebx
	push	esi
	call	_xmlSchemaTypeFixup
	add	esp, 8
$LN5@xmlSchemaF:

; 18206:     if (baseType->flags & XML_SCHEMAS_TYPE_INTERNAL_INVALID) {

	test	DWORD PTR [esi+48], 8388608		; 00800000H
	jne	$LN3@xmlSchemaF

; 18207: 	/*
; 18208: 	* Skip fixup if the base type is invalid.
; 18209: 	* TODO: Generate a warning!
; 18210: 	*/
; 18211: 	return(0);
; 18212:     }
; 18213:     /*
; 18214:     * This basically checks if the base type can be derived.
; 18215:     */
; 18216:     res = xmlSchemaCheckSRCCT(pctxt, type);

	push	edi
	push	ebx
	call	_xmlSchemaCheckSRCCT
	add	esp, 8

; 18217:     HFAILURE HERROR

	cmp	eax, -1
	je	SHORT $exit_failure$129
	test	eax, eax
	jne	$exit_error$130

; 18218:     /*
; 18219:     * Fixup the content type.
; 18220:     */
; 18221:     if (type->contentType == XML_SCHEMA_CONTENT_SIMPLE) {

	cmp	DWORD PTR [edi+52], 4
	jne	$LN9@xmlSchemaF

; 18222: 	/*
; 18223: 	* Corresponds to <complexType><simpleContent>...
; 18224: 	*/
; 18225: 	if ((WXS_IS_COMPLEX(baseType)) &&
; 18226: 	    (baseType->contentTypeDef != NULL) &&

	mov	eax, DWORD PTR [esi]
	cmp	eax, 5
	je	SHORT $LN119@xmlSchemaF
	cmp	DWORD PTR [esi+88], 45			; 0000002dH
	jne	$LN11@xmlSchemaF
$LN119@xmlSchemaF:
	mov	ecx, DWORD PTR [esi+104]
	test	ecx, ecx
	je	$LN11@xmlSchemaF
	test	BYTE PTR [edi+48], 4
	je	$LN11@xmlSchemaF

; 18227: 	    (WXS_IS_RESTRICTION(type))) {
; 18228: 	    xmlSchemaTypePtr contentBase, content;
; 18229: #ifdef ENABLE_NAMED_LOCALS
; 18230: 	    char buf[30];
; 18231: 	    const xmlChar *tmpname;
; 18232: #endif
; 18233: 	    /*
; 18234: 	    * SPEC (1) If <restriction> + base type is <complexType>,
; 18235: 	    * "whose own {content type} is a simple type..."
; 18236: 	    */
; 18237: 	    if (type->contentTypeDef != NULL) {

	mov	eax, DWORD PTR [edi+104]
	mov	DWORD PTR _contentBase$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN14@xmlSchemaF

; 18238: 		/*
; 18239: 		* SPEC (1.1) "the simple type definition corresponding to the
; 18240: 		* <simpleType> among the [children] of <restriction> if there
; 18241: 		* is one;"
; 18242: 		* Note that this "<simpleType> among the [children]" was put
; 18243: 		* into ->contentTypeDef during parsing.
; 18244: 		*/
; 18245: 		contentBase = type->contentTypeDef;
; 18246: 		type->contentTypeDef = NULL;

	mov	DWORD PTR [edi+104], 0

; 18247: 	    } else {

	jmp	SHORT $LN15@xmlSchemaF
$LN14@xmlSchemaF:

; 18248: 		/*
; 18249: 		* (1.2) "...otherwise (<restriction> has no <simpleType>
; 18250: 		* among its [children]), the simple type definition which
; 18251: 		* is the {content type} of the ... base type."
; 18252: 		*/
; 18253: 		contentBase = baseType->contentTypeDef;

	mov	DWORD PTR _contentBase$1$[ebp], ecx
$LN15@xmlSchemaF:

; 18254: 	    }
; 18255: 	    /*
; 18256: 	    * SPEC
; 18257: 	    * "... a simple type definition which restricts the simple
; 18258: 	    * type definition identified in clause 1.1 or clause 1.2
; 18259: 	    * with a set of facet components"
; 18260: 	    *
; 18261: 	    * Create the anonymous simple type, which will be the content
; 18262: 	    * type of the complex type.
; 18263: 	    */
; 18264: #ifdef ENABLE_NAMED_LOCALS
; 18265: 	    snprintf(buf, 29, "#scST%d", ++(pctxt->counter));
; 18266: 	    tmpname = xmlDictLookup(pctxt->dict, BAD_CAST buf, -1);
; 18267: 	    content = xmlSchemaAddType(pctxt, pctxt->schema,
; 18268: 		XML_SCHEMA_TYPE_SIMPLE, tmpname, type->targetNamespace,
; 18269: 		type->node, 0);
; 18270: #else
; 18271: 	    content = xmlSchemaAddType(pctxt, pctxt->schema,

	push	0
	push	DWORD PTR [edi+36]
	push	DWORD PTR [edi+112]
	push	0
	push	4
	push	DWORD PTR [ebx+36]
	push	ebx
	call	_xmlSchemaAddType
	mov	esi, eax
	add	esp, 28					; 0000001cH

; 18272: 		XML_SCHEMA_TYPE_SIMPLE, NULL, type->targetNamespace,
; 18273: 		type->node, 0);
; 18274: #endif
; 18275: 	    if (content == NULL)

	test	esi, esi
	je	$exit_failure$129

; 18276: 		goto exit_failure;
; 18277: 	    /*
; 18278: 	    * We will use the same node as for the <complexType>
; 18279: 	    * to have it somehow anchored in the schema doc.
; 18280: 	    */
; 18281: 	    content->type = XML_SCHEMA_TYPE_SIMPLE;
; 18282: 	    content->baseType = contentBase;

	mov	ecx, DWORD PTR _contentBase$1$[ebp]
	mov	DWORD PTR [esi], 4
	mov	DWORD PTR [esi+64], ecx

; 18283: 	    /*
; 18284: 	    * Move the facets, previously anchored on the
; 18285: 	    * complexType during parsing.
; 18286: 	    */
; 18287: 	    content->facets = type->facets;

	mov	eax, DWORD PTR [edi+68]
	mov	DWORD PTR [esi+68], eax

; 18288: 	    type->facets = NULL;
; 18289: 	    content->facetSet = type->facetSet;

	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [edi+68], 0
	mov	DWORD PTR [esi+96], eax

; 18290: 	    type->facetSet = NULL;

	mov	DWORD PTR [edi+96], 0

; 18291: 
; 18292: 	    type->contentTypeDef = content;

	mov	DWORD PTR [edi+104], esi

; 18293: 	    if (WXS_IS_TYPE_NOT_FIXED(contentBase))

	cmp	DWORD PTR [ecx], 1
	je	SHORT $LN17@xmlSchemaF
	test	DWORD PTR [ecx+48], 4194304		; 00400000H
	jne	SHORT $LN17@xmlSchemaF

; 18294: 		xmlSchemaTypeFixup(contentBase, ACTXT_CAST pctxt);

	push	ebx
	push	ecx
	call	_xmlSchemaTypeFixup
	add	esp, 8
$LN17@xmlSchemaF:

; 18295: 	    /*
; 18296: 	    * Fixup the newly created type. We don't need to check
; 18297: 	    * for circularity here.
; 18298: 	    */
; 18299: 	    res = xmlSchemaFixupSimpleTypeStageOne(pctxt, content);

	push	esi
	push	ebx
	call	_xmlSchemaFixupSimpleTypeStageOne
	add	esp, 8

; 18300: 	    HFAILURE HERROR

	cmp	eax, -1
	je	$exit_failure$129
	test	eax, eax
	jne	SHORT $exit_error$130

; 18301: 	    res = xmlSchemaFixupSimpleTypeStageTwo(pctxt, content);

	push	esi
	push	ebx
	call	_xmlSchemaFixupSimpleTypeStageTwo
	add	esp, 8

; 18302: 	    HFAILURE HERROR

	cmp	eax, -1
	je	$exit_failure$129
	test	eax, eax
	je	$LN59@xmlSchemaF
$exit_error$130:

; 18609:     else
; 18610: 	return(0);
; 18611: 
; 18612: exit_error:
; 18613:     type->flags |= XML_SCHEMAS_TYPE_INTERNAL_INVALID;

	or	DWORD PTR [edi+48], 8388608		; 00800000H

; 18614: #ifdef DEBUG_TYPE
; 18615:     xmlSchemaDebugFixedType(pctxt, type);
; 18616: #endif
; 18617:     return(pctxt->err);

	mov	eax, DWORD PTR [ebx+16]
	pop	edi

; 18625: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlSchemaF:

; 18303: 
; 18304: 	} else if ((WXS_IS_COMPLEX(baseType)) &&
; 18305: 	    (baseType->contentType == XML_SCHEMA_CONTENT_MIXED) &&

	cmp	eax, 5
	je	SHORT $LN120@xmlSchemaF
	cmp	DWORD PTR [esi+88], 45			; 0000002dH
	jne	SHORT $LN22@xmlSchemaF
$LN120@xmlSchemaF:
	cmp	DWORD PTR [esi+52], 3
	jne	SHORT $LN22@xmlSchemaF
	test	BYTE PTR [edi+48], 4
	je	SHORT $LN22@xmlSchemaF

; 18306: 	    (WXS_IS_RESTRICTION(type))) {
; 18307: 	    /*
; 18308: 	    * SPEC (2) If <restriction> + base is a mixed <complexType> with
; 18309: 	    * an emptiable particle, then a simple type definition which
; 18310: 	    * restricts the <restriction>'s <simpleType> child.
; 18311: 	    */
; 18312: 	    if ((type->contentTypeDef == NULL) ||

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	je	SHORT $LN26@xmlSchemaF
	cmp	DWORD PTR [eax+64], 0
	jne	$LN59@xmlSchemaF
$LN26@xmlSchemaF:

; 18313: 		(type->contentTypeDef->baseType == NULL)) {
; 18314: 		/*
; 18315: 		* TODO: Check if this ever happens.
; 18316: 		*/
; 18317: 		xmlSchemaPCustomErr(pctxt,

	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_0KG@MFOLBCHA@Internal?5error?3?5xmlSchemaTypeFi@
$LN127@xmlSchemaF:

; 18618: 
; 18619: exit_failure:
; 18620:     type->flags |= XML_SCHEMAS_TYPE_INTERNAL_INVALID;

	push	0
	push	edi
	push	3069					; 00000bfdH
	push	ebx
	call	_xmlSchemaPCustomErr
	or	DWORD PTR [edi+48], 8388608		; 00800000H
	add	esp, 24					; 00000018H

; 18621: #ifdef DEBUG_TYPE
; 18622:     xmlSchemaDebugFixedType(pctxt, type);
; 18623: #endif
; 18624:     return(-1);

	or	eax, -1
	pop	edi

; 18625: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@xmlSchemaF:

; 18318: 		    XML_SCHEMAP_INTERNAL,
; 18319: 		    WXS_BASIC_CAST type, NULL,
; 18320: 		    "Internal error: xmlSchemaTypeFixup, "
; 18321: 		    "complex type '%s': the <simpleContent><restriction> "
; 18322: 		    "is missing a <simpleType> child, but was not catched "
; 18323: 		    "by xmlSchemaCheckSRCCT()", type->name);
; 18324: 		goto exit_failure;
; 18325: 	    }
; 18326: 	} else if ((WXS_IS_COMPLEX(baseType)) && WXS_IS_EXTENSION(type)) {

	cmp	eax, 5
	je	SHORT $LN121@xmlSchemaF
	cmp	DWORD PTR [esi+88], 45			; 0000002dH
	jne	SHORT $LN123@xmlSchemaF
$LN121@xmlSchemaF:
	test	BYTE PTR [edi+48], 2
	je	SHORT $LN123@xmlSchemaF

; 18327: 	    /*
; 18328: 	    * SPEC (3) If <extension> + base is <complexType> with
; 18329: 	    * <simpleType> content, "...then the {content type} of that
; 18330: 	    * complex type definition"
; 18331: 	    */
; 18332: 	    if (baseType->contentTypeDef == NULL) {

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jne	$LN30@xmlSchemaF

; 18333: 		/*
; 18334: 		* TODO: Check if this ever happens. xmlSchemaCheckSRCCT
; 18335: 		* should have catched this already.
; 18336: 		*/
; 18337: 		xmlSchemaPCustomErr(pctxt,

	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_0IB@IICIOIAO@Internal?5error?3?5xmlSchemaTypeFi@

; 18338: 		    XML_SCHEMAP_INTERNAL,
; 18339: 		    WXS_BASIC_CAST type, NULL,
; 18340: 		    "Internal error: xmlSchemaTypeFixup, "
; 18341: 		    "complex type '%s': the <extension>ed base type is "
; 18342: 		    "a complex type with no simple content type",
; 18343: 		    type->name);
; 18344: 		goto exit_failure;

	jmp	SHORT $LN127@xmlSchemaF
$LN123@xmlSchemaF:

; 18345: 	    }
; 18346: 	    type->contentTypeDef = baseType->contentTypeDef;
; 18347: 	} else if ((WXS_IS_SIMPLE(baseType)) && WXS_IS_EXTENSION(type)) {

	cmp	eax, 4
	je	SHORT $LN33@xmlSchemaF
	cmp	eax, 1
	jne	SHORT $LN31@xmlSchemaF
	cmp	DWORD PTR [esi+88], 45			; 0000002dH
	je	SHORT $LN31@xmlSchemaF
$LN33@xmlSchemaF:
	test	BYTE PTR [edi+48], 2
	je	SHORT $LN31@xmlSchemaF

; 18348: 	    /*
; 18349: 	    * SPEC (4) <extension> + base is <simpleType>
; 18350: 	    * "... then that simple type definition"
; 18351: 	    */
; 18352: 	    type->contentTypeDef = baseType;

	mov	DWORD PTR [edi+104], esi

; 18364: 	}
; 18365:     } else {

	jmp	$LN59@xmlSchemaF
$LN31@xmlSchemaF:

; 18353: 	} else {
; 18354: 	    /*
; 18355: 	    * TODO: Check if this ever happens.
; 18356: 	    */
; 18357: 	    xmlSchemaPCustomErr(pctxt,

	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_0GG@NFAALECG@Internal?5error?3?5xmlSchemaTypeFi@

; 18358: 		XML_SCHEMAP_INTERNAL,
; 18359: 		WXS_BASIC_CAST type, NULL,
; 18360: 		"Internal error: xmlSchemaTypeFixup, "
; 18361: 		"complex type '%s' with <simpleContent>: unhandled "
; 18362: 		"derivation case", type->name);
; 18363: 	    goto exit_failure;

	jmp	SHORT $LN127@xmlSchemaF
$LN9@xmlSchemaF:

; 18366: 	int dummySequence = 0;
; 18367: 	xmlSchemaParticlePtr particle =

	mov	ecx, DWORD PTR [edi+28]
	mov	DWORD PTR _dummySequence$1$[ebp], 0

; 18368: 	    (xmlSchemaParticlePtr) type->subtypes;
; 18369: 	/*
; 18370: 	* Corresponds to <complexType><complexContent>...
; 18371: 	*
; 18372: 	* NOTE that the effective mixed was already set during parsing of
; 18373: 	* <complexType> and <complexContent>; its flag value is
; 18374: 	* XML_SCHEMAS_TYPE_MIXED.
; 18375: 	*
; 18376: 	* Compute the "effective content":
; 18377: 	* (2.1.1) + (2.1.2) + (2.1.3)
; 18378: 	*/
; 18379: 	if ((particle == NULL) ||

	test	ecx, ecx
	je	SHORT $LN124@xmlSchemaF
	cmp	DWORD PTR [ecx], 25			; 00000019H
	jne	SHORT $LN34@xmlSchemaF
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx]
	cmp	eax, 8
	je	SHORT $LN37@xmlSchemaF
	cmp	eax, 6
	je	SHORT $LN37@xmlSchemaF
	cmp	eax, 7
	jne	SHORT $LN34@xmlSchemaF
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN34@xmlSchemaF
$LN37@xmlSchemaF:
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN124@xmlSchemaF
$LN34@xmlSchemaF:

; 18423: 	    }
; 18424: 	} else {
; 18425: 	    /*
; 18426: 	    * SPEC (2.2) "otherwise the particle corresponding to the
; 18427: 	    * <all>, <choice>, <group> or <sequence> among the
; 18428: 	    * [children]."
; 18429: 	    */
; 18430: 	    type->contentType = XML_SCHEMA_CONTENT_ELEMENTS;

	mov	DWORD PTR [edi+52], 2
	mov	edx, 2
	jmp	SHORT $LN39@xmlSchemaF
$LN124@xmlSchemaF:

; 18380: 	    ((particle->type == XML_SCHEMA_TYPE_PARTICLE) &&
; 18381: 	    ((particle->children->type == XML_SCHEMA_TYPE_ALL) ||
; 18382: 	    (particle->children->type == XML_SCHEMA_TYPE_SEQUENCE) ||
; 18383: 	    ((particle->children->type == XML_SCHEMA_TYPE_CHOICE) &&
; 18384: 	    (particle->minOccurs == 0))) &&
; 18385: 	    ( ((xmlSchemaTreeItemPtr) particle->children)->children == NULL))) {
; 18386: 	    if (type->flags & XML_SCHEMAS_TYPE_MIXED) {

	test	BYTE PTR [edi+48], 1
	je	SHORT $LN38@xmlSchemaF

; 18387: 		/*
; 18388: 		* SPEC (2.1.4) "If the `effective mixed` is true, then
; 18389: 		* a particle whose properties are as follows:..."
; 18390: 		*
; 18391: 		* Empty sequence model group with
; 18392: 		* minOccurs/maxOccurs = 1 (i.e. a "particle emptiable").
; 18393: 		* NOTE that we sill assign it the <complexType> node to
; 18394: 		* somehow anchor it in the doc.
; 18395: 		*/
; 18396: 		if ((particle == NULL) ||

	test	ecx, ecx
	je	SHORT $LN41@xmlSchemaF
	mov	eax, DWORD PTR [ecx+12]
	cmp	DWORD PTR [eax], 6
	je	SHORT $LN125@xmlSchemaF
$LN41@xmlSchemaF:

; 18397: 		    (particle->children->type != XML_SCHEMA_TYPE_SEQUENCE)) {
; 18398: 		    /*
; 18399: 		    * Create the particle.
; 18400: 		    */
; 18401: 		    particle = xmlSchemaAddParticle(pctxt,

	push	1
	push	1
	push	DWORD PTR [edi+36]
	push	ebx
	call	_xmlSchemaAddParticle
	add	esp, 16					; 00000010H
	mov	DWORD PTR _particle$3$[ebp], eax

; 18402: 			type->node, 1, 1);
; 18403: 		    if (particle == NULL)

	test	eax, eax
	je	$exit_failure$129

; 18404: 			goto exit_failure;
; 18405: 		    /*
; 18406: 		    * Create the model group.
; 18407: 		    */ /* URGENT TODO: avoid adding to pending items. */
; 18408: 		    particle->children = (xmlSchemaTreeItemPtr)

	push	DWORD PTR [edi+36]
	push	6
	push	DWORD PTR [ebx+36]
	push	ebx
	call	_xmlSchemaAddModelGroup
	mov	ecx, DWORD PTR _particle$3$[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx+12], eax

; 18409: 			xmlSchemaAddModelGroup(pctxt, pctxt->schema,
; 18410: 			XML_SCHEMA_TYPE_SEQUENCE, type->node);
; 18411: 		    if (particle->children == NULL)

	test	eax, eax
	je	$exit_failure$129

; 18412: 			goto exit_failure;
; 18413: 
; 18414: 		    type->subtypes = (xmlSchemaTypePtr) particle;

	mov	DWORD PTR [edi+28], ecx
$LN125@xmlSchemaF:

; 18415: 		}
; 18416: 		dummySequence = 1;

	mov	DWORD PTR _dummySequence$1$[ebp], 1

; 18417: 		type->contentType = XML_SCHEMA_CONTENT_ELEMENTS;

	mov	edx, 2
	mov	DWORD PTR [edi+52], 2

; 18418: 	    } else {

	jmp	SHORT $LN39@xmlSchemaF
$LN38@xmlSchemaF:

; 18419: 		/*
; 18420: 		* SPEC (2.1.5) "otherwise empty"
; 18421: 		*/
; 18422: 		type->contentType = XML_SCHEMA_CONTENT_EMPTY;

	mov	DWORD PTR [edi+52], 1
	mov	edx, 1
$LN39@xmlSchemaF:

; 18431: 	}
; 18432: 	/*
; 18433: 	* Compute the "content type".
; 18434: 	*/
; 18435: 	if (WXS_IS_RESTRICTION(type)) {

	mov	eax, DWORD PTR [edi+48]
	test	al, 4
	je	SHORT $LN44@xmlSchemaF

; 18436: 	    /*
; 18437: 	    * SPEC (3.1) "If <restriction>..."
; 18438: 	    * (3.1.1) + (3.1.2) */
; 18439: 	    if (type->contentType != XML_SCHEMA_CONTENT_EMPTY) {

	cmp	edx, 1
	je	$LN59@xmlSchemaF

; 18440: 		if (type->flags & XML_SCHEMAS_TYPE_MIXED)

	test	al, 1
	je	$LN59@xmlSchemaF

; 18441: 		    type->contentType = XML_SCHEMA_CONTENT_MIXED;

	mov	DWORD PTR [edi+52], 3

; 18442: 	    }
; 18443: 	} else {

	jmp	$LN59@xmlSchemaF
$LN44@xmlSchemaF:

; 18444: 	    /*
; 18445: 	    * SPEC (3.2) "If <extension>..."
; 18446: 	    */
; 18447: 	    if (type->contentType == XML_SCHEMA_CONTENT_EMPTY) {

	mov	ebx, DWORD PTR [esi+52]
	mov	DWORD PTR tv1080[ebp], ebx
	mov	ebx, DWORD PTR _pctxt$[ebp]
	cmp	edx, 1
	jne	SHORT $LN48@xmlSchemaF

; 18448: 		/*
; 18449: 		* SPEC (3.2.1)
; 18450: 		* "If the `effective content` is empty, then the
; 18451: 		*  {content type} of the [...] base ..."
; 18452: 		*/
; 18453: 		type->contentType = baseType->contentType;

	mov	eax, DWORD PTR tv1080[ebp]
	mov	DWORD PTR [edi+52], eax

; 18454: 		type->subtypes = baseType->subtypes;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [edi+28], eax

; 18455: 		/*
; 18456: 		* Fixes bug #347316:
; 18457: 		* This is the case when the base type has a simple
; 18458: 		* type definition as content.
; 18459: 		*/
; 18460: 		type->contentTypeDef = baseType->contentTypeDef;

	mov	eax, DWORD PTR [esi+104]
$LN30@xmlSchemaF:

; 18581: 			(xmlSchemaTreeItemPtr) baseType->subtypes;
; 18582: 		}
; 18583: 	    }
; 18584: 	}
; 18585:     }
; 18586:     /*
; 18587:     * Now fixup attribute uses:
; 18588:     *   - expand attr. group references
; 18589:     *     - intersect attribute wildcards
; 18590:     *   - inherit attribute uses of the base type
; 18591:     *   - inherit or union attr. wildcards if extending
; 18592:     *   - apply attr. use prohibitions if restricting
; 18593:     */
; 18594:     res = xmlSchemaFixupTypeAttributeUses(pctxt, type);

	mov	DWORD PTR [edi+104], eax
	jmp	$LN59@xmlSchemaF
$LN48@xmlSchemaF:

; 18461: 		/*
; 18462: 		* NOTE that the effective mixed is ignored here.
; 18463: 		*/
; 18464: 	    } else if (baseType->contentType == XML_SCHEMA_CONTENT_EMPTY) {

	and	eax, 1
	cmp	DWORD PTR tv1080[ebp], 1
	jne	SHORT $LN50@xmlSchemaF

; 18465: 		/*
; 18466: 		* SPEC (3.2.2)
; 18467: 		*/
; 18468: 		if (type->flags & XML_SCHEMAS_TYPE_MIXED)

	test	eax, eax
	je	$LN59@xmlSchemaF

; 18469: 		    type->contentType = XML_SCHEMA_CONTENT_MIXED;

	mov	DWORD PTR [edi+52], 3

; 18470: 	    } else {

	jmp	$LN59@xmlSchemaF
$LN50@xmlSchemaF:

; 18471: 		/*
; 18472: 		* SPEC (3.2.3)
; 18473: 		*/
; 18474: 		if (type->flags & XML_SCHEMAS_TYPE_MIXED)

	test	eax, eax
	je	SHORT $LN53@xmlSchemaF

; 18475: 		    type->contentType = XML_SCHEMA_CONTENT_MIXED;

	mov	DWORD PTR [edi+52], 3
$LN53@xmlSchemaF:

; 18476: 		    /*
; 18477: 		    * "A model group whose {compositor} is sequence and whose
; 18478: 		    * {particles} are..."
; 18479: 		    */
; 18480: 		if ((WXS_TYPE_PARTICLE(type) != NULL) &&
; 18481: 		    (WXS_TYPE_PARTICLE_TERM(type) != NULL) &&

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR tv1096[ebp], eax
	test	eax, eax
	je	SHORT $LN54@xmlSchemaF
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN54@xmlSchemaF
	cmp	DWORD PTR [eax], 8
	jne	SHORT $LN54@xmlSchemaF

; 18482: 		    ((WXS_TYPE_PARTICLE_TERM(type))->type ==
; 18483: 			XML_SCHEMA_TYPE_ALL))
; 18484: 		{
; 18485: 		    /*
; 18486: 		    * SPEC cos-all-limited (1)
; 18487: 		    */
; 18488: 		    xmlSchemaCustomErr(ACTXT_CAST pctxt,

	push	edi
	call	_xmlSchemaGetComponentNode

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	mov	esi, eax

; 2339 :     xmlChar *msg = NULL;

	mov	DWORD PTR _msg$2[ebp], 0

; 2340 : 
; 2341 :     if ((node == NULL) && (item != NULL) &&
; 2342 : 	(actxt->type == XML_SCHEMA_CTXT_PARSER)) {
; 2343 : 	node = WXS_ITEM_NODE(item);
; 2344 : 	xmlSchemaFormatItemForReport(&msg, NULL, item, NULL);
; 2345 : 	msg = xmlStrcat(msg, BAD_CAST ": ");
; 2346 :     } else
; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	esi
	lea	eax, DWORD PTR _msg$2[ebp]
	push	ebx
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0BAF@GMDKHDD@The?5type?5has?5an?5?8all?8?5model?5gro@

; 18489: 			/* TODO: error code */
; 18490: 			XML_SCHEMAP_COS_ALL_LIMITED,
; 18491: 			WXS_ITEM_NODE(type), NULL,
; 18492: 			"The type has an 'all' model group in its "
; 18493: 			"{content type} and thus cannot be derived from "
; 18494: 			"a non-empty type, since this would produce a "
; 18495: 			"'sequence' model group containing the 'all' "
; 18496: 			"model group; 'all' model groups are not "
; 18497: 			"allowed to appear inside other model groups",
; 18498: 			NULL, NULL);
; 18499: 
; 18500: 		} else if ((WXS_TYPE_PARTICLE(baseType) != NULL) &&

	jmp	SHORT $LN126@xmlSchemaF
$LN54@xmlSchemaF:

; 18501: 		    (WXS_TYPE_PARTICLE_TERM(baseType) != NULL) &&

	mov	edx, DWORD PTR [esi+28]
	test	edx, edx
	je	SHORT $LN56@xmlSchemaF
	mov	eax, DWORD PTR [edx+12]
	test	eax, eax
	je	SHORT $LN56@xmlSchemaF
	cmp	DWORD PTR [eax], 8
	jne	SHORT $LN56@xmlSchemaF

; 18502: 		    ((WXS_TYPE_PARTICLE_TERM(baseType))->type ==
; 18503: 			XML_SCHEMA_TYPE_ALL))
; 18504: 		{
; 18505: 		    /*
; 18506: 		    * SPEC cos-all-limited (1)
; 18507: 		    */
; 18508: 		    xmlSchemaCustomErr(ACTXT_CAST pctxt,

	push	edi
	call	_xmlSchemaGetComponentNode

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	mov	esi, eax

; 2339 :     xmlChar *msg = NULL;

	mov	DWORD PTR _msg$1[ebp], 0

; 2340 : 
; 2341 :     if ((node == NULL) && (item != NULL) &&
; 2342 : 	(actxt->type == XML_SCHEMA_CTXT_PARSER)) {
; 2343 : 	node = WXS_ITEM_NODE(item);
; 2344 : 	xmlSchemaFormatItemForReport(&msg, NULL, item, NULL);
; 2345 : 	msg = xmlStrcat(msg, BAD_CAST ": ");
; 2346 :     } else
; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	esi
	lea	eax, DWORD PTR _msg$1[ebp]
	push	ebx
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0BAD@EONAGGAE@A?5type?5cannot?5be?5derived?5by?5ext@
$LN126@xmlSchemaF:

; 18581: 			(xmlSchemaTreeItemPtr) baseType->subtypes;
; 18582: 		}
; 18583: 	    }
; 18584: 	}
; 18585:     }
; 18586:     /*
; 18587:     * Now fixup attribute uses:
; 18588:     *   - expand attr. group references
; 18589:     *     - intersect attribute wildcards
; 18590:     *   - inherit attribute uses of the base type
; 18591:     *   - inherit or union attr. wildcards if extending
; 18592:     *   - apply attr. use prohibitions if restricting
; 18593:     */
; 18594:     res = xmlSchemaFixupTypeAttributeUses(pctxt, type);

	push	DWORD PTR _msg$1[ebp]
	call	_xmlStrcat
	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlStrcat
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	esi
	push	3091					; 00000c13H
	push	2
	push	ebx
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlSchemaErr4Line
	mov	eax, DWORD PTR _msg$1[ebp]
	add	esp, 72					; 00000048H
	test	eax, eax
	je	$LN59@xmlSchemaF
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	jmp	$LN59@xmlSchemaF
$LN56@xmlSchemaF:

; 18509: 			/* TODO: error code */
; 18510: 			XML_SCHEMAP_COS_ALL_LIMITED,
; 18511: 			WXS_ITEM_NODE(type), NULL,
; 18512: 			"A type cannot be derived by extension from a type "
; 18513: 			"which has an 'all' model group in its "
; 18514: 			"{content type}, since this would produce a "
; 18515: 			"'sequence' model group containing the 'all' "
; 18516: 			"model group; 'all' model groups are not "
; 18517: 			"allowed to appear inside other model groups",
; 18518: 			NULL, NULL);
; 18519: 
; 18520: 		} else if (! dummySequence) {

	cmp	DWORD PTR _dummySequence$1$[ebp], 0
	jne	SHORT $LN58@xmlSchemaF

; 18521: 		    xmlSchemaTreeItemPtr effectiveContent =
; 18522: 			(xmlSchemaTreeItemPtr) type->subtypes;
; 18523: 		    /*
; 18524: 		    * Create the particle.
; 18525: 		    */
; 18526: 		    particle = xmlSchemaAddParticle(pctxt,

	push	1
	push	1
	push	DWORD PTR [edi+36]
	push	ebx
	call	_xmlSchemaAddParticle
	add	esp, 16					; 00000010H
	mov	DWORD PTR _particle$1$[ebp], eax

; 18527: 			type->node, 1, 1);
; 18528: 		    if (particle == NULL)

	test	eax, eax
	je	$exit_failure$129

; 18529: 			goto exit_failure;
; 18530: 		    /*
; 18531: 		    * Create the "sequence" model group.
; 18532: 		    */
; 18533: 		    particle->children = (xmlSchemaTreeItemPtr)

	push	DWORD PTR [edi+36]
	push	6
	push	DWORD PTR [ebx+36]
	push	ebx
	call	_xmlSchemaAddModelGroup
	mov	ecx, DWORD PTR _particle$1$[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx+12], eax

; 18534: 			xmlSchemaAddModelGroup(pctxt, pctxt->schema,
; 18535: 			XML_SCHEMA_TYPE_SEQUENCE, type->node);
; 18536: 		    if (particle->children == NULL)

	test	eax, eax
	je	$exit_failure$129

; 18537: 			goto exit_failure;
; 18538: 		    WXS_TYPE_CONTENTTYPE(type) = (xmlSchemaTypePtr) particle;

	mov	DWORD PTR [edi+28], ecx

; 18539: 		    /*
; 18540: 		    * SPEC "the particle of the {content type} of
; 18541: 		    * the ... base ..."
; 18542: 		    * Create a duplicate of the base type's particle
; 18543: 		    * and assign its "term" to it.
; 18544: 		    */
; 18545: 		    particle->children->children =

	mov	eax, DWORD PTR [esi+28]
	push	DWORD PTR [eax+20]
	push	DWORD PTR [eax+16]
	push	DWORD PTR [edi+36]
	push	ebx
	call	_xmlSchemaAddParticle
	mov	edx, DWORD PTR _particle$1$[ebp]
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax

; 18546: 			(xmlSchemaTreeItemPtr) xmlSchemaAddParticle(pctxt,
; 18547: 			type->node,
; 18548: 			((xmlSchemaParticlePtr) baseType->subtypes)->minOccurs,
; 18549: 			((xmlSchemaParticlePtr) baseType->subtypes)->maxOccurs);
; 18550: 		    if (particle->children->children == NULL)

	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	$exit_failure$129

; 18551: 			goto exit_failure;
; 18552: 		    particle = (xmlSchemaParticlePtr)
; 18553: 			particle->children->children;
; 18554: 		    particle->children =

	mov	eax, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 18555: 			((xmlSchemaParticlePtr) baseType->subtypes)->children;
; 18556: 		    /*
; 18557: 		    * SPEC "followed by the `effective content`."
; 18558: 		    */
; 18559: 		    particle->next = effectiveContent;

	mov	eax, DWORD PTR tv1096[ebp]
	mov	DWORD PTR [ecx+8], eax

; 18560: 		    /*
; 18561: 		    * This all will result in:
; 18562: 		    * new-particle
; 18563: 		    *   --> new-sequence(
; 18564: 		    *         new-particle
; 18565: 		    *           --> base-model,
; 18566: 		    *         this-particle
; 18567: 		    *	        --> this-model
; 18568: 		    *	    )
; 18569: 		    */
; 18570: 		} else {

	jmp	SHORT $LN59@xmlSchemaF
$LN58@xmlSchemaF:

; 18571: 		    /*
; 18572: 		    * This is the case when there is already an empty
; 18573: 		    * <sequence> with minOccurs==maxOccurs==1.
; 18574: 		    * Just add the base types's content type.
; 18575: 		    * NOTE that, although we miss to add an intermediate
; 18576: 		    * <sequence>, this should produce no difference to
; 18577: 		    * neither the regex compilation of the content model,
; 18578: 		    * nor to the complex type contraints.
; 18579: 		    */
; 18580: 		    particle->children->children =

	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
$LN59@xmlSchemaF:

; 18581: 			(xmlSchemaTreeItemPtr) baseType->subtypes;
; 18582: 		}
; 18583: 	    }
; 18584: 	}
; 18585:     }
; 18586:     /*
; 18587:     * Now fixup attribute uses:
; 18588:     *   - expand attr. group references
; 18589:     *     - intersect attribute wildcards
; 18590:     *   - inherit attribute uses of the base type
; 18591:     *   - inherit or union attr. wildcards if extending
; 18592:     *   - apply attr. use prohibitions if restricting
; 18593:     */
; 18594:     res = xmlSchemaFixupTypeAttributeUses(pctxt, type);

	push	edi
	push	ebx
	call	_xmlSchemaFixupTypeAttributeUses
	add	esp, 8

; 18595:     HFAILURE HERROR

	cmp	eax, -1
	je	$exit_failure$129
	test	eax, eax
	jne	$exit_error$130

; 18596:     /*
; 18597:     * Apply the complex type component constraints; this will not
; 18598:     * check attributes, since this is done in
; 18599:     * xmlSchemaFixupTypeAttributeUses().
; 18600:     */
; 18601:     res = xmlSchemaCheckCTComponent(pctxt, type);

	push	edi
	push	ebx
	call	_xmlSchemaCheckCTComponent
	add	esp, 8

; 18602:     HFAILURE HERROR

	cmp	eax, -1
	je	$exit_failure$129
	test	eax, eax
	jne	$exit_error$130

; 18603: 
; 18604: #ifdef DEBUG_TYPE
; 18605:     xmlSchemaDebugFixedType(pctxt, type);
; 18606: #endif
; 18607:     if (olderrs != pctxt->nberrors)

	mov	eax, DWORD PTR _olderrs$1$[ebp]
	cmp	eax, DWORD PTR [ebx+20]
	je	SHORT $LN3@xmlSchemaF

; 18608: 	return(pctxt->err);

	mov	eax, DWORD PTR [ebx+16]
	pop	edi

; 18625: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlSchemaF:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaFixupComplexType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFixupSimpleTypeStageTwo
_TEXT	SEGMENT
_olderrs$1$ = -12					; size = 4
_olderrs$1$ = -8					; size = 4
_lastLink$1$ = -8					; size = 4
_prevLink$1$ = -4					; size = 4
_needVal$1$ = 8						; size = 4
_name$1$ = 8						; size = 4
_pctxt$ = 8						; size = 4
tv1155 = 12						; size = 4
_type$ = 12						; size = 4
_xmlSchemaFixupSimpleTypeStageTwo PROC			; COMDAT

; 18096: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _pctxt$[ebp]
	mov	edi, DWORD PTR _type$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cmp	DWORD PTR [edi], 4
	mov	DWORD PTR _olderrs$1$[ebp], eax
	jne	SHORT $LN171@xmlSchemaF

; 18097:     int res, olderrs = pctxt->nberrors;
; 18098: 
; 18099:     if (type->type != XML_SCHEMA_TYPE_SIMPLE)
; 18100: 	return(-1);
; 18101: 
; 18102:     if (! WXS_IS_TYPE_NOT_FIXED(type))

	mov	eax, DWORD PTR [edi+48]
	lea	ecx, DWORD PTR [edi+48]
	mov	DWORD PTR tv1155[ebp], ecx
	test	eax, 4194304				; 00400000H
	jne	$LN4@xmlSchemaF

; 18103: 	return(0);
; 18104: 
; 18105:     type->flags |= XML_SCHEMAS_TYPE_INTERNAL_RESOLVED;

	or	eax, 4194304				; 00400000H

; 18106:     type->contentType = XML_SCHEMA_CONTENT_SIMPLE;

	mov	DWORD PTR [edi+52], 4
	mov	DWORD PTR [ecx], eax

; 18107: 
; 18108:     if (type->baseType == NULL) {

	mov	eax, DWORD PTR [edi+64]
	test	eax, eax
	jne	SHORT $LN5@xmlSchemaF

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	eax
	push	eax
	push	OFFSET ??_C@_0BB@DAFLJMHA@missing?5baseType@
	push	OFFSET ??_C@_0CB@NHIHEMOP@xmlSchemaFixupSimpleTypeStageTw@
	push	edx
	call	_xmlSchemaInternalErr2

; 18177:     return(0);
; 18178: 
; 18179: exit_failure:
; 18180: #ifdef DEBUG_TYPE
; 18181:     xmlSchemaDebugFixedType(pctxt, type);
; 18182: #endif
; 18183:     return(-1);
; 18184: }

	add	esp, 20					; 00000014H
$LN171@xmlSchemaF:
$exit_failure$185:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlSchemaF:

; 18109: 	PERROR_INT("xmlSchemaFixupSimpleTypeStageTwo",
; 18110: 	    "missing baseType");
; 18111: 	goto exit_failure;
; 18112:     }
; 18113:     if (WXS_IS_TYPE_NOT_FIXED(type->baseType))

	cmp	DWORD PTR [eax], 1
	je	SHORT $LN6@xmlSchemaF
	test	DWORD PTR [eax+48], 4194304		; 00400000H
	jne	SHORT $LN6@xmlSchemaF

; 18114: 	xmlSchemaTypeFixup(type->baseType, ACTXT_CAST pctxt);

	push	edx
	push	eax
	call	_xmlSchemaTypeFixup
	mov	edx, DWORD PTR _pctxt$[ebp]
	add	esp, 8
$LN6@xmlSchemaF:

; 18115:     /*
; 18116:     * If a member type of a union is a union itself, we need to substitute
; 18117:     * that member type for its member types.
; 18118:     * NOTE that this might change in WXS 1.1; i.e. we will keep the union
; 18119:     * types in WXS 1.1.
; 18120:     */
; 18121:     if ((type->memberTypes != NULL) &&

	mov	ebx, DWORD PTR [edi+92]
	test	ebx, ebx
	je	$LN179@xmlSchemaF
$LL36@xmlSchemaF:

; 17814: 	if (WXS_IS_TYPE_NOT_FIXED(link->type))

	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, ecx
	cmp	DWORD PTR [ecx], 1
	je	SHORT $LN40@xmlSchemaF
	test	DWORD PTR [ecx+48], 4194304		; 00400000H
	jne	SHORT $LN40@xmlSchemaF

; 17815: 	    xmlSchemaTypeFixup(link->type, ACTXT_CAST pctxt);

	push	edx
	push	ecx
	call	_xmlSchemaTypeFixup
	mov	eax, DWORD PTR [ebx+4]
	add	esp, 8
$LN40@xmlSchemaF:

; 17816: 
; 17817: 	if (WXS_IS_UNION(link->type)) {

	test	BYTE PTR [eax+48], 128			; 00000080H
	je	SHORT $LN39@xmlSchemaF
$LL58@xmlSchemaF:

; 14670:     while ((type != NULL) && (type->type == XML_SCHEMA_TYPE_SIMPLE)) {

	cmp	DWORD PTR [eax], 4
	jne	SHORT $LN39@xmlSchemaF

; 14671: 	if (type->memberTypes != NULL)

	mov	esi, DWORD PTR [eax+92]
	test	esi, esi
	jne	SHORT $LN136@xmlSchemaF

; 14672: 	    return (type->memberTypes);
; 14673: 	else
; 14674: 	    type = type->baseType;

	mov	eax, DWORD PTR [eax+64]
	test	eax, eax
	jne	SHORT $LL58@xmlSchemaF

; 13476: 	if ((type->builtInType == XML_SCHEMAS_ANYSIMPLETYPE) ||

	jmp	SHORT $LN39@xmlSchemaF
$LN136@xmlSchemaF:

; 17820: 		link->type = subLink->type;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ebx+4], eax

; 17821: 		if (subLink->next != NULL) {

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	je	SHORT $LN39@xmlSchemaF

; 17822: 		    lastLink = link->next;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR _lastLink$1$[ebp], eax

; 17823: 		    subLink = subLink->next;
; 17824: 		    prevLink = link;

	mov	DWORD PTR _prevLink$1$[ebp], ebx
$LL38@xmlSchemaF:

; 17825: 		    while (subLink != NULL) {
; 17826: 			newLink = (xmlSchemaTypeLinkPtr)

	push	8
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4

; 17827: 			    xmlMalloc(sizeof(xmlSchemaTypeLink));
; 17828: 			if (newLink == NULL) {

	test	ecx, ecx
	je	SHORT $LN137@xmlSchemaF

; 17829: 			    xmlSchemaPErrMemory(pctxt, "allocating a type link",
; 17830: 				NULL);
; 17831: 			    return (-1);
; 17832: 			}
; 17833: 			newLink->type = subLink->type;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax

; 17834: 			prevLink->next = newLink;

	mov	eax, DWORD PTR _prevLink$1$[ebp]

; 17835: 			prevLink = newLink;

	mov	DWORD PTR _prevLink$1$[ebp], ecx
	mov	DWORD PTR [eax], ecx

; 17836: 			newLink->next = lastLink;

	mov	eax, DWORD PTR _lastLink$1$[ebp]
	mov	DWORD PTR [ecx], eax

; 17837: 
; 17838: 			subLink = subLink->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL38@xmlSchemaF
$LN39@xmlSchemaF:

; 17839: 		    }
; 17840: 		}
; 17841: 	    }
; 17842: 	}
; 17843: 	link = link->next;

	mov	ebx, DWORD PTR [ebx]
	test	ebx, ebx
	je	SHORT $LN179@xmlSchemaF

; 15812: 	    ctxt->serror, ctxt->errCtxt);
; 15813:     }
; 15814:     return (0);
; 15815: }
; 15816: 
; 15817: static int
; 15818: xmlSchemaVCheckCVCSimpleType(xmlSchemaAbstractCtxtPtr actxt,
; 15819: 			     xmlNodePtr node,
; 15820: 			     xmlSchemaTypePtr type,
; 15821: 			     const xmlChar *value,
; 15822: 			     xmlSchemaValPtr *retVal,
; 15823: 			     int fireErrors,
; 15824: 			     int normalize,
; 15825: 			     int isNormalized);
; 15826: 
; 15827: /**
; 15828:  * xmlSchemaParseCheckCOSValidDefault:
; 15829:  * @pctxt:  the schema parser context
; 15830:  * @type:  the simple type definition
; 15831:  * @value: the default value
; 15832:  * @node: an optional node (the holder of the value)
; 15833:  *
; 15834:  * Schema Component Constraint: Element Default Valid (Immediate)
; 15835:  * (cos-valid-default)
; 15836:  * This will be used by the parser only. For the validator there's
; 15837:  * an other version.
; 15838:  *
; 15839:  * Returns 0 if the constraints are satisfied,
; 15840:  * if not, a positive error code and -1 on internal
; 15841:  * errors.
; 15842:  */
; 15843: static int
; 15844: xmlSchemaParseCheckCOSValidDefault(xmlSchemaParserCtxtPtr pctxt,
; 15845: 				   xmlNodePtr node,
; 15846: 				   xmlSchemaTypePtr type,
; 15847: 				   const xmlChar *value,
; 15848: 				   xmlSchemaValPtr *val)
; 15849: {
; 15850:     int ret = 0;
; 15851: 
; 15852:     /*
; 15853:     * cos-valid-default:
; 15854:     * Schema Component Constraint: Element Default Valid (Immediate)
; 15855:     * For a string to be a valid default with respect to a type
; 15856:     * definition the appropriate case among the following must be true:
; 15857:     */
; 15858:     if WXS_IS_COMPLEX(type) {
; 15859: 	/*
; 15860: 	* Complex type.
; 15861: 	*
; 15862: 	* SPEC (2.1) "its {content type} must be a simple type definition
; 15863: 	* or mixed."
; 15864: 	* SPEC (2.2.2) "If the {content type} is mixed, then the {content
; 15865: 	* type}'s particle must be `emptiable` as defined by
; 15866: 	* Particle Emptiable ($3.9.6)."
; 15867: 	*/
; 15868: 	if ((! WXS_HAS_SIMPLE_CONTENT(type)) &&
; 15869: 	    ((! WXS_HAS_MIXED_CONTENT(type)) || (! WXS_EMPTIABLE(type)))) {
; 15870: 	    /* NOTE that this covers (2.2.2) as well. */
; 15871: 	    xmlSchemaPCustomErr(pctxt,
; 15872: 		XML_SCHEMAP_COS_VALID_DEFAULT_2_1,
; 15873: 		WXS_BASIC_CAST type, type->node,
; 15874: 		"For a string to be a valid default, the type definition "
; 15875: 		"must be a simple type or a complex type with mixed content "
; 15876: 		"and a particle emptiable", NULL);
; 15877: 	    return(XML_SCHEMAP_COS_VALID_DEFAULT_2_1);
; 15878: 	}
; 15879:     }
; 15880:     /*
; 15881:     * 1 If the type definition is a simple type definition, then the string
; 15882:     * must be `valid` with respect to that definition as defined by String
; 15883:     * Valid ($3.14.4).
; 15884:     *
; 15885:     * AND
; 15886:     *
; 15887:     * 2.2.1 If the {content type} is a simple type definition, then the
; 15888:     * string must be `valid` with respect to that simple type definition
; 15889:     * as defined by String Valid ($3.14.4).
; 15890:     */
; 15891:     if (WXS_IS_SIMPLE(type))
; 15892: 	ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST pctxt, node,
; 15893: 	    type, value, val, 1, 1, 0);
; 15894:     else if (WXS_HAS_SIMPLE_CONTENT(type))
; 15895: 	ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST pctxt, node,
; 15896: 	    type->contentTypeDef, value, val, 1, 1, 0);
; 15897:     else
; 15898: 	return (ret);
; 15899: 
; 15900:     if (ret < 0) {
; 15901: 	PERROR_INT("xmlSchemaParseCheckCOSValidDefault",
; 15902: 	    "calling xmlSchemaVCheckCVCSimpleType()");
; 15903:     }
; 15904: 
; 15905:     return (ret);
; 15906: }
; 15907: 
; 15908: /**
; 15909:  * xmlSchemaCheckCTPropsCorrect:
; 15910:  * @ctxt:  the schema parser context
; 15911:  * @type:  the complex type definition
; 15912:  *
; 15913:  *.(4.6) Constraints on Complex Type Definition Schema Components
; 15914:  * Schema Component Constraint:
; 15915:  * Complex Type Definition Properties Correct (ct-props-correct)
; 15916:  * STATUS: (seems) complete
; 15917:  *
; 15918:  * Returns 0 if the constraints are satisfied, a positive
; 15919:  * error code if not and -1 if an internal error occurred.
; 15920:  */
; 15921: static int
; 15922: xmlSchemaCheckCTPropsCorrect(xmlSchemaParserCtxtPtr pctxt,
; 15923: 			     xmlSchemaTypePtr type)
; 15924: {
; 15925:     /*
; 15926:     * TODO: Correct the error code; XML_SCHEMAP_SRC_CT_1 is used temporarily.
; 15927:     *
; 15928:     * SPEC (1) "The values of the properties of a complex type definition must
; 15929:     * be as described in the property tableau in The Complex Type Definition
; 15930:     * Schema Component ($3.4.1), modulo the impact of Missing
; 15931:     * Sub-components ($5.3)."
; 15932:     */
; 15933:     if ((type->baseType != NULL) &&
; 15934: 	(WXS_IS_SIMPLE(type->baseType)) &&
; 15935: 	(WXS_IS_EXTENSION(type) == 0)) {
; 15936: 	/*
; 15937: 	* SPEC (2) "If the {base type definition} is a simple type definition,
; 15938: 	* the {derivation method} must be extension."
; 15939: 	*/
; 15940: 	xmlSchemaCustomErr(ACTXT_CAST pctxt,
; 15941: 	    XML_SCHEMAP_SRC_CT_1,
; 15942: 	    NULL, WXS_BASIC_CAST type,
; 15943: 	    "If the base type is a simple type, the derivation method must be "
; 15944: 	    "'extension'", NULL, NULL);
; 15945: 	return (XML_SCHEMAP_SRC_CT_1);
; 15946:     }
; 15947:     /*
; 15948:     * SPEC (3) "Circular definitions are disallowed, except for the `ur-type
; 15949:     * definition`. That is, it must be possible to reach the `ur-type
; 15950:     * definition` by repeatedly following the {base type definition}."
; 15951:     *
; 15952:     * NOTE (3) is done in xmlSchemaCheckTypeDefCircular().
; 15953:     */
; 15954:     /*
; 15955:     * NOTE that (4) and (5) need the following:
; 15956:     *   - attribute uses need to be already inherited (apply attr. prohibitions)
; 15957:     *   - attribute group references need to be expanded already
; 15958:     *   - simple types need to be typefixed already
; 15959:     */
; 15960:     if (type->attrUses &&
; 15961: 	(((xmlSchemaItemListPtr) type->attrUses)->nbItems > 1))
; 15962:     {
; 15963: 	xmlSchemaItemListPtr uses = (xmlSchemaItemListPtr) type->attrUses;
; 15964: 	xmlSchemaAttributeUsePtr use, tmp;
; 15965: 	int i, j, hasId = 0;
; 15966: 
; 15967: 	for (i = uses->nbItems -1; i >= 0; i--) {
; 15968: 	    use = uses->items[i];
; 15969: 
; 15970: 	    /*
; 15971: 	    * SPEC ct-props-correct
; 15972: 	    * (4) "Two distinct attribute declarations in the
; 15973: 	    * {attribute uses} must not have identical {name}s and
; 15974: 	    * {target namespace}s."
; 15975: 	    */
; 15976: 	    if (i > 0) {
; 15977: 		for (j = i -1; j >= 0; j--) {
; 15978: 		    tmp = uses->items[j];
; 15979: 		    if ((WXS_ATTRUSE_DECL_NAME(use) ==
; 15980: 			WXS_ATTRUSE_DECL_NAME(tmp)) &&
; 15981: 			(WXS_ATTRUSE_DECL_TNS(use) ==
; 15982: 			WXS_ATTRUSE_DECL_TNS(tmp)))
; 15983: 		    {
; 15984: 			xmlChar *str = NULL;
; 15985: 
; 15986: 			xmlSchemaCustomErr(ACTXT_CAST pctxt,
; 15987: 			    XML_SCHEMAP_AG_PROPS_CORRECT,
; 15988: 			    NULL, WXS_BASIC_CAST type,
; 15989: 			    "Duplicate %s",
; 15990: 			    xmlSchemaGetComponentDesignation(&str, use),
; 15991: 			    NULL);
; 15992: 			FREE_AND_NULL(str);
; 15993: 			/*
; 15994: 			* Remove the duplicate.
; 15995: 			*/
; 15996: 			if (xmlSchemaItemListRemove(uses, i) == -1)
; 15997: 			    goto exit_failure;
; 15998: 			goto next_use;
; 15999: 		    }
; 16000: 		}
; 16001: 	    }
; 16002: 	    /*
; 16003: 	    * SPEC ct-props-correct
; 16004: 	    * (5) "Two distinct attribute declarations in the
; 16005: 	    * {attribute uses} must not have {type definition}s which
; 16006: 	    * are or are derived from ID."
; 16007: 	    */
; 16008: 	    if (WXS_ATTRUSE_TYPEDEF(use) != NULL) {
; 16009: 		if (xmlSchemaIsDerivedFromBuiltInType(
; 16010: 		    WXS_ATTRUSE_TYPEDEF(use), XML_SCHEMAS_ID))
; 16011: 		{
; 16012: 		    if (hasId) {
; 16013: 			xmlChar *str = NULL;
; 16014: 
; 16015: 			xmlSchemaCustomErr(ACTXT_CAST pctxt,
; 16016: 			    XML_SCHEMAP_AG_PROPS_CORRECT,
; 16017: 			    NULL, WXS_BASIC_CAST type,
; 16018: 			    "There must not exist more than one attribute "
; 16019: 			    "declaration of type 'xs:ID' "
; 16020: 			    "(or derived from 'xs:ID'). The %s violates this "
; 16021: 			    "constraint",
; 16022: 			    xmlSchemaGetComponentDesignation(&str, use),
; 16023: 			    NULL);
; 16024: 			FREE_AND_NULL(str);
; 16025: 			if (xmlSchemaItemListRemove(uses, i) == -1)
; 16026: 			    goto exit_failure;
; 16027: 		    }
; 16028: 
; 16029: 		    hasId = 1;
; 16030: 		}
; 16031: 	    }
; 16032: next_use: {}
; 16033: 	}
; 16034:     }
; 16035:     return (0);
; 16036: exit_failure:
; 16037:     return(-1);
; 16038: }
; 16039: 
; 16040: static int
; 16041: xmlSchemaAreEqualTypes(xmlSchemaTypePtr typeA,
; 16042: 		       xmlSchemaTypePtr typeB)
; 16043: {
; 16044:     /*
; 16045:     * TODO: This should implement component-identity
; 16046:     * in the future.
; 16047:     */
; 16048:     if ((typeA == NULL) || (typeB == NULL))
; 16049: 	return (0);
; 16050:     return (typeA == typeB);
; 16051: }
; 16052: 
; 16053: /**
; 16054:  * xmlSchemaCheckCOSCTDerivedOK:
; 16055:  * @ctxt:  the schema parser context
; 16056:  * @type:  the to-be derived complex type definition
; 16057:  * @baseType:  the base complex type definition
; 16058:  * @set: the given set
; 16059:  *
; 16060:  * Schema Component Constraint:
; 16061:  * Type Derivation OK (Complex) (cos-ct-derived-ok)
; 16062:  *
; 16063:  * STATUS: completed
; 16064:  *
; 16065:  * Returns 0 if the constraints are satisfied, or 1
; 16066:  * if not.
; 16067:  */
; 16068: static int
; 16069: xmlSchemaCheckCOSCTDerivedOK(xmlSchemaAbstractCtxtPtr actxt,
; 16070: 			     xmlSchemaTypePtr type,
; 16071: 			     xmlSchemaTypePtr baseType,
; 16072: 			     int set)
; 16073: {
; 16074:     int equal = xmlSchemaAreEqualTypes(type, baseType);
; 16075:     /* TODO: Error codes. */
; 16076:     /*
; 16077:     * SPEC "For a complex type definition (call it D, for derived)
; 16078:     * to be validly derived from a type definition (call this
; 16079:     * B, for base) given a subset of {extension, restriction}
; 16080:     * all of the following must be true:"
; 16081:     */
; 16082:     if (! equal) {
; 16083: 	/*
; 16084: 	* SPEC (1) "If B and D are not the same type definition, then the
; 16085: 	* {derivation method} of D must not be in the subset."
; 16086: 	*/
; 16087: 	if (((set & SUBSET_EXTENSION) && (WXS_IS_EXTENSION(type))) ||
; 16088: 	    ((set & SUBSET_RESTRICTION) && (WXS_IS_RESTRICTION(type))))
; 16089: 	    return (1);
; 16090:     } else {
; 16091: 	/*
; 16092: 	* SPEC (2.1) "B and D must be the same type definition."
; 16093: 	*/
; 16094: 	return (0);
; 16095:     }
; 16096:     /*
; 16097:     * SPEC (2.2) "B must be D's {base type definition}."
; 16098:     */
; 16099:     if (type->baseType == baseType)
; 16100: 	return (0);
; 16101:     /*
; 16102:     * SPEC (2.3.1) "D's {base type definition} must not be the `ur-type
; 16103:     * definition`."
; 16104:     */
; 16105:     if (WXS_IS_ANYTYPE(type->baseType))
; 16106: 	return (1);
; 16107: 
; 16108:     if (WXS_IS_COMPLEX(type->baseType)) {
; 16109: 	/*
; 16110: 	* SPEC (2.3.2.1) "If D's {base type definition} is complex, then it
; 16111: 	* must be validly derived from B given the subset as defined by this
; 16112: 	* constraint."
; 16113: 	*/
; 16114: 	return (xmlSchemaCheckCOSCTDerivedOK(actxt, type->baseType,
; 16115: 	    baseType, set));
; 16116:     } else {
; 16117: 	/*
; 16118: 	* SPEC (2.3.2.2) "If D's {base type definition} is simple, then it
; 16119: 	* must be validly derived from B given the subset as defined in Type
; 16120: 	* Derivation OK (Simple) ($3.14.6).
; 16121: 	*/
; 16122: 	return (xmlSchemaCheckCOSSTDerivedOK(actxt, type->baseType,
; 16123: 	    baseType, set));
; 16124:     }
; 16125: }
; 16126: 
; 16127: /**
; 16128:  * xmlSchemaCheckCOSDerivedOK:
; 16129:  * @type:  the derived simple type definition
; 16130:  * @baseType:  the base type definition
; 16131:  *
; 16132:  * Calls:
; 16133:  * Type Derivation OK (Simple) AND Type Derivation OK (Complex)
; 16134:  *
; 16135:  * Checks wheter @type can be validly derived from @baseType.
; 16136:  *
; 16137:  * Returns 0 on success, an positive error code otherwise.
; 16138:  */
; 16139: static int
; 16140: xmlSchemaCheckCOSDerivedOK(xmlSchemaAbstractCtxtPtr actxt,
; 16141: 			   xmlSchemaTypePtr type,
; 16142: 			   xmlSchemaTypePtr baseType,
; 16143: 			   int set)
; 16144: {
; 16145:     if (WXS_IS_SIMPLE(type))
; 16146: 	return (xmlSchemaCheckCOSSTDerivedOK(actxt, type, baseType, set));
; 16147:     else
; 16148: 	return (xmlSchemaCheckCOSCTDerivedOK(actxt, type, baseType, set));
; 16149: }
; 16150: 
; 16151: /**
; 16152:  * xmlSchemaCheckCOSCTExtends:
; 16153:  * @ctxt:  the schema parser context
; 16154:  * @type:  the complex type definition
; 16155:  *
; 16156:  * (3.4.6) Constraints on Complex Type Definition Schema Components
; 16157:  * Schema Component Constraint:
; 16158:  * Derivation Valid (Extension) (cos-ct-extends)
; 16159:  *
; 16160:  * STATUS:
; 16161:  *   missing:
; 16162:  *     (1.5)
; 16163:  *     (1.4.3.2.2.2) "Particle Valid (Extension)"
; 16164:  *
; 16165:  * Returns 0 if the constraints are satisfied, a positive
; 16166:  * error code if not and -1 if an internal error occurred.
; 16167:  */
; 16168: static int
; 16169: xmlSchemaCheckCOSCTExtends(xmlSchemaParserCtxtPtr ctxt,
; 16170: 			   xmlSchemaTypePtr type)
; 16171: {
; 16172:     xmlSchemaTypePtr base = type->baseType;
; 16173:     /*
; 16174:     * TODO: Correct the error code; XML_SCHEMAP_COS_CT_EXTENDS_1_1 is used
; 16175:     * temporarily only.
; 16176:     */
; 16177:     /*
; 16178:     * SPEC (1) "If the {base type definition} is a complex type definition,
; 16179:     * then all of the following must be true:"
; 16180:     */
; 16181:     if (WXS_IS_COMPLEX(base)) {
; 16182: 	/*
; 16183: 	* SPEC (1.1) "The {final} of the {base type definition} must not
; 16184: 	* contain extension."
; 16185: 	*/
; 16186: 	if (base->flags & XML_SCHEMAS_TYPE_FINAL_EXTENSION) {
; 16187: 	    xmlSchemaPCustomErr(ctxt,
; 16188: 		XML_SCHEMAP_COS_CT_EXTENDS_1_1,
; 16189: 		WXS_BASIC_CAST type, NULL,
; 16190: 		"The 'final' of the base type definition "
; 16191: 		"contains 'extension'", NULL);
; 16192: 	    return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);
; 16193: 	}
; 16194: 
; 16195: 	/*
; 16196: 	* ATTENTION: The constrains (1.2) and (1.3) are not applied,
; 16197: 	* since they are automatically satisfied through the
; 16198: 	* inheriting mechanism.
; 16199: 	* Note that even if redefining components, the inheriting mechanism
; 16200: 	* is used.
; 16201: 	*/
; 16202: #if 0
; 16203: 	/*
; 16204: 	* SPEC (1.2) "Its {attribute uses} must be a subset of the {attribute
; 16205: 	* uses}
; 16206: 	* of the complex type definition itself, that is, for every attribute
; 16207: 	* use in the {attribute uses} of the {base type definition}, there
; 16208: 	* must be an attribute use in the {attribute uses} of the complex
; 16209: 	* type definition itself whose {attribute declaration} has the same
; 16210: 	* {name}, {target namespace} and {type definition} as its attribute
; 16211: 	* declaration"
; 16212: 	*/
; 16213: 	if (base->attrUses != NULL) {
; 16214: 	    int i, j, found;
; 16215: 	    xmlSchemaAttributeUsePtr use, buse;
; 16216: 
; 16217: 	    for (i = 0; i < (WXS_LIST_CAST base->attrUses)->nbItems; i ++) {
; 16218: 		buse = (WXS_LIST_CAST base->attrUses)->items[i];
; 16219: 		found = 0;
; 16220: 		if (type->attrUses != NULL) {
; 16221: 		    use = (WXS_LIST_CAST type->attrUses)->items[j];
; 16222: 		    for (j = 0; j < (WXS_LIST_CAST type->attrUses)->nbItems; j ++)
; 16223: 		    {
; 16224: 			if ((WXS_ATTRUSE_DECL_NAME(use) ==
; 16225: 				WXS_ATTRUSE_DECL_NAME(buse)) &&
; 16226: 			    (WXS_ATTRUSE_DECL_TNS(use) ==
; 16227: 				WXS_ATTRUSE_DECL_TNS(buse)) &&
; 16228: 			    (WXS_ATTRUSE_TYPEDEF(use) ==
; 16229: 				WXS_ATTRUSE_TYPEDEF(buse))
; 16230: 			{
; 16231: 			    found = 1;
; 16232: 			    break;
; 16233: 			}
; 16234: 		    }
; 16235: 		}
; 16236: 		if (! found) {
; 16237: 		    xmlChar *str = NULL;
; 16238: 
; 16239: 		    xmlSchemaCustomErr(ACTXT_CAST ctxt,
; 16240: 			XML_SCHEMAP_COS_CT_EXTENDS_1_2,
; 16241: 			NULL, WXS_BASIC_CAST type,
; 16242: 			/*
; 16243: 			* TODO: The report does not indicate that also the
; 16244: 			* type needs to be the same.
; 16245: 			*/
; 16246: 			"This type is missing a matching correspondent "
; 16247: 			"for its {base type}'s %s in its {attribute uses}",
; 16248: 			xmlSchemaGetComponentDesignation(&str,
; 16249: 			    buse->children),
; 16250: 			NULL);
; 16251: 		    FREE_AND_NULL(str)
; 16252: 		}
; 16253: 	    }
; 16254: 	}
; 16255: 	/*
; 16256: 	* SPEC (1.3) "If it has an {attribute wildcard}, the complex type
; 16257: 	* definition must also have one, and the base type definition's
; 16258: 	* {attribute  wildcard}'s {namespace constraint} must be a subset
; 16259: 	* of the complex  type definition's {attribute wildcard}'s {namespace
; 16260: 	* constraint}, as defined by Wildcard Subset ($3.10.6)."
; 16261: 	*/
; 16262: 
; 16263: 	/*
; 16264: 	* MAYBE TODO: Enable if ever needed. But this will be needed only
; 16265: 	* if created the type via a schema construction API.
; 16266: 	*/
; 16267: 	if (base->attributeWildcard != NULL) {
; 16268: 	    if (type->attributeWilcard == NULL) {
; 16269: 		xmlChar *str = NULL;
; 16270: 
; 16271: 		xmlSchemaCustomErr(ACTXT_CAST pctxt,
; 16272: 		    XML_SCHEMAP_COS_CT_EXTENDS_1_3,
; 16273: 		    NULL, type,
; 16274: 		    "The base %s has an attribute wildcard, "
; 16275: 		    "but this type is missing an attribute wildcard",
; 16276: 		    xmlSchemaGetComponentDesignation(&str, base));
; 16277: 		FREE_AND_NULL(str)
; 16278: 
; 16279: 	    } else if (xmlSchemaCheckCOSNSSubset(
; 16280: 		base->attributeWildcard, type->attributeWildcard))
; 16281: 	    {
; 16282: 		xmlChar *str = NULL;
; 16283: 
; 16284: 		xmlSchemaCustomErr(ACTXT_CAST pctxt,
; 16285: 		    XML_SCHEMAP_COS_CT_EXTENDS_1_3,
; 16286: 		    NULL, type,
; 16287: 		    "The attribute wildcard is not a valid "
; 16288: 		    "superset of the one in the base %s",
; 16289: 		    xmlSchemaGetComponentDesignation(&str, base));
; 16290: 		FREE_AND_NULL(str)
; 16291: 	    }
; 16292: 	}
; 16293: #endif
; 16294: 	/*
; 16295: 	* SPEC (1.4) "One of the following must be true:"
; 16296: 	*/
; 16297: 	if ((type->contentTypeDef != NULL) &&
; 16298: 	    (type->contentTypeDef == base->contentTypeDef)) {
; 16299: 	    /*
; 16300: 	    * SPEC (1.4.1) "The {content type} of the {base type definition}
; 16301: 	    * and the {content type} of the complex type definition itself
; 16302: 	    * must be the same simple type definition"
; 16303: 	    * PASS
; 16304: 	    */
; 16305: 	} else if ((type->contentType == XML_SCHEMA_CONTENT_EMPTY) &&
; 16306: 	    (base->contentType == XML_SCHEMA_CONTENT_EMPTY) ) {
; 16307: 	    /*
; 16308: 	    * SPEC (1.4.2) "The {content type} of both the {base type
; 16309: 	    * definition} and the complex type definition itself must
; 16310: 	    * be empty."
; 16311: 	    * PASS
; 16312: 	    */
; 16313: 	} else {
; 16314: 	    /*
; 16315: 	    * SPEC (1.4.3) "All of the following must be true:"
; 16316: 	    */
; 16317: 	    if (type->subtypes == NULL) {
; 16318: 		/*
; 16319: 		* SPEC 1.4.3.1 The {content type} of the complex type
; 16320: 		* definition itself must specify a particle.
; 16321: 		*/
; 16322: 		xmlSchemaPCustomErr(ctxt,
; 16323: 		    XML_SCHEMAP_COS_CT_EXTENDS_1_1,
; 16324: 		    WXS_BASIC_CAST type, NULL,
; 16325: 		    "The content type must specify a particle", NULL);
; 16326: 		return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);
; 16327: 	    }
; 16328: 	    /*
; 16329: 	    * SPEC (1.4.3.2) "One of the following must be true:"
; 16330: 	    */
; 16331: 	    if (base->contentType == XML_SCHEMA_CONTENT_EMPTY) {
; 16332: 		/*
; 16333: 		* SPEC (1.4.3.2.1) "The {content type} of the {base type
; 16334: 		* definition} must be empty.
; 16335: 		* PASS
; 16336: 		*/
; 16337: 	    } else {
; 16338: 		/*
; 16339: 		* SPEC (1.4.3.2.2) "All of the following must be true:"
; 16340: 		*/
; 16341: 		if ((type->contentType != base->contentType) ||
; 16342: 		    ((type->contentType != XML_SCHEMA_CONTENT_MIXED) &&
; 16343: 		    (type->contentType != XML_SCHEMA_CONTENT_ELEMENTS))) {
; 16344: 		    /*
; 16345: 		    * SPEC (1.4.3.2.2.1) "Both {content type}s must be mixed
; 16346: 		    * or both must be element-only."
; 16347: 		    */
; 16348: 		    xmlSchemaPCustomErr(ctxt,
; 16349: 			XML_SCHEMAP_COS_CT_EXTENDS_1_1,
; 16350: 			WXS_BASIC_CAST type, NULL,
; 16351: 			"The content type of both, the type and its base "
; 16352: 			"type, must either 'mixed' or 'element-only'", NULL);
; 16353: 		    return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);
; 16354: 		}
; 16355: 		/*
; 16356: 		* URGENT TODO SPEC (1.4.3.2.2.2) "The particle of the
; 16357: 		* complex type definition must be a `valid extension`
; 16358: 		* of the {base type definition}'s particle, as defined
; 16359: 		* in Particle Valid (Extension) ($3.9.6)."
; 16360: 		*
; 16361: 		* NOTE that we won't check "Particle Valid (Extension)",
; 16362: 		* since it is ensured by the derivation process in
; 16363: 		* xmlSchemaTypeFixup(). We need to implement this when heading
; 16364: 		* for a construction API
; 16365: 		* TODO: !! This is needed to be checked if redefining a type !!
; 16366: 		*/
; 16367: 	    }
; 16368: 	    /*
; 16369: 	    * URGENT TODO (1.5)
; 16370: 	    */
; 16371: 	}
; 16372:     } else {
; 16373: 	/*
; 16374: 	* SPEC (2) "If the {base type definition} is a simple type definition,
; 16375: 	* then all of the following must be true:"
; 16376: 	*/
; 16377: 	if (type->contentTypeDef != base) {
; 16378: 	    /*
; 16379: 	    * SPEC (2.1) "The {content type} must be the same simple type
; 16380: 	    * definition."
; 16381: 	    */
; 16382: 	    xmlSchemaPCustomErr(ctxt,
; 16383: 		XML_SCHEMAP_COS_CT_EXTENDS_1_1,
; 16384: 		WXS_BASIC_CAST type, NULL,
; 16385: 		"The content type must be the simple base type", NULL);
; 16386: 	    return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);
; 16387: 	}
; 16388: 	if (base->flags & XML_SCHEMAS_TYPE_FINAL_EXTENSION) {
; 16389: 	    /*
; 16390: 	    * SPEC (2.2) "The {final} of the {base type definition} must not
; 16391: 	    * contain extension"
; 16392: 	    * NOTE that this is the same as (1.1).
; 16393: 	    */
; 16394: 	    xmlSchemaPCustomErr(ctxt,
; 16395: 		XML_SCHEMAP_COS_CT_EXTENDS_1_1,
; 16396: 		WXS_BASIC_CAST type, NULL,
; 16397: 		"The 'final' of the base type definition "
; 16398: 		"contains 'extension'", NULL);
; 16399: 	    return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);
; 16400: 	}
; 16401:     }
; 16402:     return (0);
; 16403: }
; 16404: 
; 16405: /**
; 16406:  * xmlSchemaCheckDerivationOKRestriction:
; 16407:  * @ctxt:  the schema parser context
; 16408:  * @type:  the complex type definition
; 16409:  *
; 16410:  * (3.4.6) Constraints on Complex Type Definition Schema Components
; 16411:  * Schema Component Constraint:
; 16412:  * Derivation Valid (Restriction, Complex) (derivation-ok-restriction)
; 16413:  *
; 16414:  * STATUS:
; 16415:  *   missing:
; 16416:  *     (5.4.2) ???
; 16417:  *
; 16418:  * ATTENTION:
; 16419:  * In XML Schema 1.1 this will be:
; 16420:  * Validation Rule: Checking complex type subsumption
; 16421:  *
; 16422:  * Returns 0 if the constraints are satisfied, a positive
; 16423:  * error code if not and -1 if an internal error occurred.
; 16424:  */
; 16425: static int
; 16426: xmlSchemaCheckDerivationOKRestriction(xmlSchemaParserCtxtPtr ctxt,
; 16427: 				      xmlSchemaTypePtr type)
; 16428: {
; 16429:     xmlSchemaTypePtr base;
; 16430: 
; 16431:     /*
; 16432:     * TODO: Correct the error code; XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1 is used
; 16433:     * temporarily only.
; 16434:     */
; 16435:     base = type->baseType;
; 16436:     if (! WXS_IS_COMPLEX(base)) {
; 16437: 	xmlSchemaCustomErr(ACTXT_CAST ctxt,
; 16438: 	    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
; 16439: 	    type->node, WXS_BASIC_CAST type,
; 16440: 	    "The base type must be a complex type", NULL, NULL);
; 16441: 	return(ctxt->err);
; 16442:     }
; 16443:     if (base->flags & XML_SCHEMAS_TYPE_FINAL_RESTRICTION) {
; 16444: 	/*
; 16445: 	* SPEC (1) "The {base type definition} must be a complex type
; 16446: 	* definition whose {final} does not contain restriction."
; 16447: 	*/
; 16448: 	xmlSchemaCustomErr(ACTXT_CAST ctxt,
; 16449: 	    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
; 16450: 	    type->node, WXS_BASIC_CAST type,
; 16451: 	    "The 'final' of the base type definition "
; 16452: 	    "contains 'restriction'", NULL, NULL);
; 16453: 	return (ctxt->err);
; 16454:     }
; 16455:     /*
; 16456:     * SPEC (2), (3) and (4)
; 16457:     * Those are handled in a separate function, since the
; 16458:     * same constraints are needed for redefinition of
; 16459:     * attribute groups as well.
; 16460:     */
; 16461:     if (xmlSchemaCheckDerivationOKRestriction2to4(ctxt,
; 16462: 	XML_SCHEMA_ACTION_DERIVE,
; 16463: 	WXS_BASIC_CAST type, WXS_BASIC_CAST base,
; 16464: 	type->attrUses, base->attrUses,
; 16465: 	type->attributeWildcard,
; 16466: 	base->attributeWildcard) == -1)
; 16467:     {
; 16468: 	return(-1);
; 16469:     }
; 16470:     /*
; 16471:     * SPEC (5) "One of the following must be true:"
; 16472:     */
; 16473:     if (base->builtInType == XML_SCHEMAS_ANYTYPE) {
; 16474: 	/*
; 16475: 	* SPEC (5.1) "The {base type definition} must be the
; 16476: 	* `ur-type definition`."
; 16477: 	* PASS
; 16478: 	*/
; 16479:     } else if ((type->contentType == XML_SCHEMA_CONTENT_SIMPLE) ||
; 16480: 	    (type->contentType == XML_SCHEMA_CONTENT_BASIC)) {
; 16481: 	/*
; 16482: 	* SPEC (5.2.1) "The {content type} of the complex type definition
; 16483: 	* must be a simple type definition"
; 16484: 	*
; 16485: 	* SPEC (5.2.2) "One of the following must be true:"
; 16486: 	*/
; 16487: 	if ((base->contentType == XML_SCHEMA_CONTENT_SIMPLE) ||
; 16488: 	    (base->contentType == XML_SCHEMA_CONTENT_BASIC))
; 16489: 	{
; 16490: 	    int err;
; 16491: 	    /*
; 16492: 	    * SPEC (5.2.2.1) "The {content type} of the {base type
; 16493: 	    * definition} must be a simple type definition from which
; 16494: 	    * the {content type} is validly derived given the empty
; 16495: 	    * set as defined in Type Derivation OK (Simple) ($3.14.6)."
; 16496: 	    *
; 16497: 	    * ATTENTION TODO: This seems not needed if the type implicitely
; 16498: 	    * derived from the base type.
; 16499: 	    *
; 16500: 	    */
; 16501: 	    err = xmlSchemaCheckCOSSTDerivedOK(ACTXT_CAST ctxt,
; 16502: 		type->contentTypeDef, base->contentTypeDef, 0);
; 16503: 	    if (err != 0) {
; 16504: 		xmlChar *strA = NULL, *strB = NULL;
; 16505: 
; 16506: 		if (err == -1)
; 16507: 		    return(-1);
; 16508: 		xmlSchemaCustomErr(ACTXT_CAST ctxt,
; 16509: 		    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
; 16510: 		    NULL, WXS_BASIC_CAST type,
; 16511: 		    "The {content type} %s is not validly derived from the "
; 16512: 		    "base type's {content type} %s",
; 16513: 		    xmlSchemaGetComponentDesignation(&strA,
; 16514: 			type->contentTypeDef),
; 16515: 		    xmlSchemaGetComponentDesignation(&strB,
; 16516: 			base->contentTypeDef));
; 16517: 		FREE_AND_NULL(strA);
; 16518: 		FREE_AND_NULL(strB);
; 16519: 		return(ctxt->err);
; 16520: 	    }
; 16521: 	} else if ((base->contentType == XML_SCHEMA_CONTENT_MIXED) &&
; 16522: 	    (xmlSchemaIsParticleEmptiable(
; 16523: 		(xmlSchemaParticlePtr) base->subtypes))) {
; 16524: 	    /*
; 16525: 	    * SPEC (5.2.2.2) "The {base type definition} must be mixed
; 16526: 	    * and have a particle which is `emptiable` as defined in
; 16527: 	    * Particle Emptiable ($3.9.6)."
; 16528: 	    * PASS
; 16529: 	    */
; 16530: 	} else {
; 16531: 	    xmlSchemaPCustomErr(ctxt,
; 16532: 		XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
; 16533: 		WXS_BASIC_CAST type, NULL,
; 16534: 		"The content type of the base type must be either "
; 16535: 		"a simple type or 'mixed' and an emptiable particle", NULL);
; 16536: 	    return (ctxt->err);
; 16537: 	}
; 16538:     } else if (type->contentType == XML_SCHEMA_CONTENT_EMPTY) {
; 16539: 	/*
; 16540: 	* SPEC (5.3.1) "The {content type} of the complex type itself must
; 16541: 	* be empty"
; 16542: 	*/
; 16543: 	if (base->contentType == XML_SCHEMA_CONTENT_EMPTY) {
; 16544: 	    /*
; 16545: 	    * SPEC (5.3.2.1) "The {content type} of the {base type
; 16546: 	    * definition} must also be empty."
; 16547: 	    * PASS
; 16548: 	    */
; 16549: 	} else if (((base->contentType == XML_SCHEMA_CONTENT_ELEMENTS) ||
; 16550: 	    (base->contentType == XML_SCHEMA_CONTENT_MIXED)) &&
; 16551: 	    xmlSchemaIsParticleEmptiable(
; 16552: 		(xmlSchemaParticlePtr) base->subtypes)) {
; 16553: 	    /*
; 16554: 	    * SPEC (5.3.2.2) "The {content type} of the {base type
; 16555: 	    * definition} must be elementOnly or mixed and have a particle
; 16556: 	    * which is `emptiable` as defined in Particle Emptiable ($3.9.6)."
; 16557: 	    * PASS
; 16558: 	    */
; 16559: 	} else {
; 16560: 	    xmlSchemaPCustomErr(ctxt,
; 16561: 		XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
; 16562: 		WXS_BASIC_CAST type, NULL,
; 16563: 		"The content type of the base type must be either "
; 16564: 		"empty or 'mixed' (or 'elements-only') and an emptiable "
; 16565: 		"particle", NULL);
; 16566: 	    return (ctxt->err);
; 16567: 	}
; 16568:     } else if ((type->contentType == XML_SCHEMA_CONTENT_ELEMENTS) ||
; 16569: 	WXS_HAS_MIXED_CONTENT(type)) {
; 16570: 	/*
; 16571: 	* SPEC (5.4.1.1) "The {content type} of the complex type definition
; 16572: 	* itself must be element-only"
; 16573: 	*/
; 16574: 	if (WXS_HAS_MIXED_CONTENT(type) && (! WXS_HAS_MIXED_CONTENT(base))) {
; 16575: 	    /*
; 16576: 	    * SPEC (5.4.1.2) "The {content type} of the complex type
; 16577: 	    * definition itself and of the {base type definition} must be
; 16578: 	    * mixed"
; 16579: 	    */
; 16580: 	    xmlSchemaPCustomErr(ctxt,
; 16581: 		XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
; 16582: 		WXS_BASIC_CAST type, NULL,
; 16583: 		"If the content type is 'mixed', then the content type of the "
; 16584: 		"base type must also be 'mixed'", NULL);
; 16585: 	    return (ctxt->err);
; 16586: 	}
; 16587: 	/*
; 16588: 	* SPEC (5.4.2) "The particle of the complex type definition itself
; 16589: 	* must be a `valid restriction` of the particle of the {content
; 16590: 	* type} of the {base type definition} as defined in Particle Valid
; 16591: 	* (Restriction) ($3.9.6).
; 16592: 	*
; 16593: 	* URGENT TODO: (5.4.2)
; 16594: 	*/
; 16595:     } else {
; 16596: 	xmlSchemaPCustomErr(ctxt,
; 16597: 	    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
; 16598: 	    WXS_BASIC_CAST type, NULL,
; 16599: 	    "The type is not a valid restriction of its base type", NULL);
; 16600: 	return (ctxt->err);
; 16601:     }
; 16602:     return (0);
; 16603: }
; 16604: 
; 16605: /**
; 16606:  * xmlSchemaCheckCTComponent:
; 16607:  * @ctxt:  the schema parser context
; 16608:  * @type:  the complex type definition
; 16609:  *
; 16610:  * (3.4.6) Constraints on Complex Type Definition Schema Components
; 16611:  *
; 16612:  * Returns 0 if the constraints are satisfied, a positive
; 16613:  * error code if not and -1 if an internal error occurred.
; 16614:  */
; 16615: static int
; 16616: xmlSchemaCheckCTComponent(xmlSchemaParserCtxtPtr ctxt,
; 16617: 			  xmlSchemaTypePtr type)
; 16618: {
; 16619:     int ret;
; 16620:     /*
; 16621:     * Complex Type Definition Properties Correct
; 16622:     */
; 16623:     ret = xmlSchemaCheckCTPropsCorrect(ctxt, type);
; 16624:     if (ret != 0)
; 16625: 	return (ret);
; 16626:     if (WXS_IS_EXTENSION(type))
; 16627: 	ret = xmlSchemaCheckCOSCTExtends(ctxt, type);
; 16628:     else
; 16629: 	ret = xmlSchemaCheckDerivationOKRestriction(ctxt, type);
; 16630:     return (ret);
; 16631: }
; 16632: 
; 16633: /**
; 16634:  * xmlSchemaCheckSRCCT:
; 16635:  * @ctxt:  the schema parser context
; 16636:  * @type:  the complex type definition
; 16637:  *
; 16638:  * (3.4.3) Constraints on XML Representations of Complex Type Definitions:
; 16639:  * Schema Representation Constraint:
; 16640:  * Complex Type Definition Representation OK (src-ct)
; 16641:  *
; 16642:  * Returns 0 if the constraints are satisfied, a positive
; 16643:  * error code if not and -1 if an internal error occurred.
; 16644:  */
; 16645: static int
; 16646: xmlSchemaCheckSRCCT(xmlSchemaParserCtxtPtr ctxt,
; 16647: 		    xmlSchemaTypePtr type)
; 16648: {
; 16649:     xmlSchemaTypePtr base;
; 16650:     int ret = 0;
; 16651: 
; 16652:     /*
; 16653:     * TODO: Adjust the error codes here, as I used
; 16654:     * XML_SCHEMAP_SRC_CT_1 only yet.
; 16655:     */
; 16656:     base = type->baseType;
; 16657:     if (! WXS_HAS_SIMPLE_CONTENT(type)) {
; 16658: 	/*
; 16659: 	* 1 If the <complexContent> alternative is chosen, the type definition
; 16660: 	* `resolved` to by the `actual value` of the base [attribute]
; 16661: 	* must be a complex type definition;
; 16662: 	*/
; 16663: 	if (! WXS_IS_COMPLEX(base)) {
; 16664: 	    xmlChar *str = NULL;
; 16665: 	    xmlSchemaPCustomErr(ctxt,
; 16666: 		XML_SCHEMAP_SRC_CT_1,
; 16667: 		WXS_BASIC_CAST type, type->node,
; 16668: 		"If using <complexContent>, the base type is expected to be "
; 16669: 		"a complex type. The base type '%s' is a simple type",
; 16670: 		xmlSchemaFormatQName(&str, base->targetNamespace,
; 16671: 		base->name));
; 16672: 	    FREE_AND_NULL(str)
; 16673: 	    return (XML_SCHEMAP_SRC_CT_1);
; 16674: 	}
; 16675:     } else {
; 16676: 	/*
; 16677: 	* SPEC
; 16678: 	* 2 If the <simpleContent> alternative is chosen, all of the
; 16679: 	* following must be true:
; 16680: 	* 2.1 The type definition `resolved` to by the `actual value` of the
; 16681: 	* base [attribute] must be one of the following:
; 16682: 	*/
; 16683: 	if (WXS_IS_SIMPLE(base)) {
; 16684: 	    if (WXS_IS_EXTENSION(type) == 0) {
; 16685: 		xmlChar *str = NULL;
; 16686: 		/*
; 16687: 		* 2.1.3 only if the <extension> alternative is also
; 16688: 		* chosen, a simple type definition.
; 16689: 		*/
; 16690: 		/* TODO: Change error code to ..._SRC_CT_2_1_3. */
; 16691: 		xmlSchemaPCustomErr(ctxt,
; 16692: 		    XML_SCHEMAP_SRC_CT_1,
; 16693: 		    WXS_BASIC_CAST type, NULL,
; 16694: 		    "If using <simpleContent> and <restriction>, the base "
; 16695: 		    "type must be a complex type. The base type '%s' is "
; 16696: 		    "a simple type",
; 16697: 		    xmlSchemaFormatQName(&str, base->targetNamespace,
; 16698: 			base->name));
; 16699: 		FREE_AND_NULL(str)
; 16700: 		return (XML_SCHEMAP_SRC_CT_1);
; 16701: 	    }
; 16702: 	} else {
; 16703: 	    /* Base type is a complex type. */
; 16704: 	    if ((base->contentType == XML_SCHEMA_CONTENT_SIMPLE) ||
; 16705: 		(base->contentType == XML_SCHEMA_CONTENT_BASIC)) {
; 16706: 		/*
; 16707: 		* 2.1.1 a complex type definition whose {content type} is a
; 16708: 		* simple type definition;
; 16709: 		* PASS
; 16710: 		*/
; 16711: 		if (base->contentTypeDef == NULL) {
; 16712: 		    xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_INTERNAL,
; 16713: 			WXS_BASIC_CAST type, NULL,
; 16714: 			"Internal error: xmlSchemaCheckSRCCT, "
; 16715: 			"'%s', base type has no content type",
; 16716: 			type->name);
; 16717: 		    return (-1);
; 16718: 		}
; 16719: 	    } else if ((base->contentType == XML_SCHEMA_CONTENT_MIXED) &&
; 16720: 		(WXS_IS_RESTRICTION(type))) {
; 16721: 
; 16722: 		/*
; 16723: 		* 2.1.2 only if the <restriction> alternative is also
; 16724: 		* chosen, a complex type definition whose {content type}
; 16725: 		* is mixed and a particle emptiable.
; 16726: 		*/
; 16727: 		if (! xmlSchemaIsParticleEmptiable(
; 16728: 		    (xmlSchemaParticlePtr) base->subtypes)) {
; 16729: 		    ret = XML_SCHEMAP_SRC_CT_1;
; 16730: 		} else
; 16731: 		    /*
; 16732: 		    * Attention: at this point the <simpleType> child is in
; 16733: 		    * ->contentTypeDef (put there during parsing).
; 16734: 		    */
; 16735: 		    if (type->contentTypeDef == NULL) {
; 16736: 		    xmlChar *str = NULL;
; 16737: 		    /*
; 16738: 		    * 2.2 If clause 2.1.2 above is satisfied, then there
; 16739: 		    * must be a <simpleType> among the [children] of
; 16740: 		    * <restriction>.
; 16741: 		    */
; 16742: 		    /* TODO: Change error code to ..._SRC_CT_2_2. */
; 16743: 		    xmlSchemaPCustomErr(ctxt,
; 16744: 			XML_SCHEMAP_SRC_CT_1,
; 16745: 			WXS_BASIC_CAST type, NULL,
; 16746: 			"A <simpleType> is expected among the children "
; 16747: 			"of <restriction>, if <simpleContent> is used and "
; 16748: 			"the base type '%s' is a complex type",
; 16749: 			xmlSchemaFormatQName(&str, base->targetNamespace,
; 16750: 			base->name));
; 16751: 		    FREE_AND_NULL(str)
; 16752: 		    return (XML_SCHEMAP_SRC_CT_1);
; 16753: 		}
; 16754: 	    } else {
; 16755: 		ret = XML_SCHEMAP_SRC_CT_1;
; 16756: 	    }
; 16757: 	}
; 16758: 	if (ret > 0) {
; 16759: 	    xmlChar *str = NULL;
; 16760: 	    if (WXS_IS_RESTRICTION(type)) {
; 16761: 		xmlSchemaPCustomErr(ctxt,
; 16762: 		    XML_SCHEMAP_SRC_CT_1,
; 16763: 		    WXS_BASIC_CAST type, NULL,
; 16764: 		    "If <simpleContent> and <restriction> is used, the "
; 16765: 		    "base type must be a simple type or a complex type with "
; 16766: 		    "mixed content and particle emptiable. The base type "
; 16767: 		    "'%s' is none of those",
; 16768: 		    xmlSchemaFormatQName(&str, base->targetNamespace,
; 16769: 		    base->name));
; 16770: 	    } else {
; 16771: 		xmlSchemaPCustomErr(ctxt,
; 16772: 		    XML_SCHEMAP_SRC_CT_1,
; 16773: 		    WXS_BASIC_CAST type, NULL,
; 16774: 		    "If <simpleContent> and <extension> is used, the "
; 16775: 		    "base type must be a simple type. The base type '%s' "
; 16776: 		    "is a complex type",
; 16777: 		    xmlSchemaFormatQName(&str, base->targetNamespace,
; 16778: 		    base->name));
; 16779: 	    }
; 16780: 	    FREE_AND_NULL(str)
; 16781: 	}
; 16782:     }
; 16783:     /*
; 16784:     * SPEC (3) "The corresponding complex type definition component must
; 16785:     * satisfy the conditions set out in Constraints on Complex Type
; 16786:     * Definition Schema Components ($3.4.6);"
; 16787:     * NOTE (3) will be done in xmlSchemaTypeFixup().
; 16788:     */
; 16789:     /*
; 16790:     * SPEC (4) If clause 2.2.1 or clause 2.2.2 in the correspondence specification
; 16791:     * above for {attribute wildcard} is satisfied, the intensional
; 16792:     * intersection must be expressible, as defined in Attribute Wildcard
; 16793:     * Intersection ($3.10.6).
; 16794:     * NOTE (4) is done in xmlSchemaFixupTypeAttributeUses().
; 16795:     */
; 16796:     return (ret);
; 16797: }
; 16798: 
; 16799: #ifdef ENABLE_PARTICLE_RESTRICTION
; 16800: /**
; 16801:  * xmlSchemaCheckParticleRangeOK:
; 16802:  * @ctxt:  the schema parser context
; 16803:  * @type:  the complex type definition
; 16804:  *
; 16805:  * (3.9.6) Constraints on Particle Schema Components
; 16806:  * Schema Component Constraint:
; 16807:  * Occurrence Range OK (range-ok)
; 16808:  *
; 16809:  * STATUS: complete
; 16810:  *
; 16811:  * Returns 0 if the constraints are satisfied, a positive
; 16812:  * error code if not and -1 if an internal error occurred.
; 16813:  */
; 16814: static int
; 16815: xmlSchemaCheckParticleRangeOK(int rmin, int rmax,
; 16816: 			      int bmin, int bmax)
; 16817: {
; 16818:     if (rmin < bmin)
; 16819: 	return (1);
; 16820:     if ((bmax != UNBOUNDED) &&
; 16821: 	(rmax > bmax))
; 16822: 	return (1);
; 16823:     return (0);
; 16824: }
; 16825: 
; 16826: /**
; 16827:  * xmlSchemaCheckRCaseNameAndTypeOK:
; 16828:  * @ctxt:  the schema parser context
; 16829:  * @r: the restricting element declaration particle
; 16830:  * @b: the base element declaration particle
; 16831:  *
; 16832:  * (3.9.6) Constraints on Particle Schema Components
; 16833:  * Schema Component Constraint:
; 16834:  * Particle Restriction OK (Elt:Elt -- NameAndTypeOK)
; 16835:  * (rcase-NameAndTypeOK)
; 16836:  *
; 16837:  * STATUS:
; 16838:  *   MISSING (3.2.3)
; 16839:  *   CLARIFY: (3.2.2)
; 16840:  *
; 16841:  * Returns 0 if the constraints are satisfied, a positive
; 16842:  * error code if not and -1 if an internal error occurred.
; 16843:  */
; 16844: static int
; 16845: xmlSchemaCheckRCaseNameAndTypeOK(xmlSchemaParserCtxtPtr ctxt,
; 16846: 				 xmlSchemaParticlePtr r,
; 16847: 				 xmlSchemaParticlePtr b)
; 16848: {
; 16849:     xmlSchemaElementPtr elemR, elemB;
; 16850: 
; 16851:     /* TODO: Error codes (rcase-NameAndTypeOK). */
; 16852:     elemR = (xmlSchemaElementPtr) r->children;
; 16853:     elemB = (xmlSchemaElementPtr) b->children;
; 16854:     /*
; 16855:     * SPEC (1) "The declarations' {name}s and {target namespace}s are
; 16856:     * the same."
; 16857:     */
; 16858:     if ((elemR != elemB) &&
; 16859: 	((! xmlStrEqual(elemR->name, elemB->name)) ||
; 16860: 	(! xmlStrEqual(elemR->targetNamespace, elemB->targetNamespace))))
; 16861: 	return (1);
; 16862:     /*
; 16863:     * SPEC (2) "R's occurrence range is a valid restriction of B's
; 16864:     * occurrence range as defined by Occurrence Range OK ($3.9.6)."
; 16865:     */
; 16866:     if (xmlSchemaCheckParticleRangeOK(r->minOccurs, r->maxOccurs,
; 16867: 	    b->minOccurs, b->maxOccurs) != 0)
; 16868: 	return (1);
; 16869:     /*
; 16870:     * SPEC (3.1) "Both B's declaration's {scope} and R's declaration's
; 16871:     * {scope} are global."
; 16872:     */
; 16873:     if (elemR == elemB)
; 16874: 	return (0);
; 16875:     /*
; 16876:     * SPEC (3.2.1) "Either B's {nillable} is true or R's {nillable} is false."
; 16877:     */
; 16878:     if (((elemB->flags & XML_SCHEMAS_ELEM_NILLABLE) == 0) &&
; 16879: 	(elemR->flags & XML_SCHEMAS_ELEM_NILLABLE))
; 16880: 	 return (1);
; 16881:     /*
; 16882:     * SPEC (3.2.2) "either B's declaration's {value constraint} is absent,
; 16883:     * or is not fixed, or R's declaration's {value constraint} is fixed
; 16884:     * with the same value."
; 16885:     */
; 16886:     if ((elemB->value != NULL) && (elemB->flags & XML_SCHEMAS_ELEM_FIXED) &&
; 16887: 	((elemR->value == NULL) ||
; 16888: 	 ((elemR->flags & XML_SCHEMAS_ELEM_FIXED) == 0) ||
; 16889: 	 /* TODO: Equality of the initial value or normalized or canonical? */
; 16890: 	 (! xmlStrEqual(elemR->value, elemB->value))))
; 16891: 	 return (1);
; 16892:     /*
; 16893:     * TODO: SPEC (3.2.3) "R's declaration's {identity-constraint
; 16894:     * definitions} is a subset of B's declaration's {identity-constraint
; 16895:     * definitions}, if any."
; 16896:     */
; 16897:     if (elemB->idcs != NULL) {
; 16898: 	/* TODO */
; 16899:     }
; 16900:     /*
; 16901:     * SPEC (3.2.4) "R's declaration's {disallowed substitutions} is a
; 16902:     * superset of B's declaration's {disallowed substitutions}."
; 16903:     */
; 16904:     if (((elemB->flags & XML_SCHEMAS_ELEM_BLOCK_EXTENSION) &&
; 16905: 	 ((elemR->flags & XML_SCHEMAS_ELEM_BLOCK_EXTENSION) == 0)) ||
; 16906: 	((elemB->flags & XML_SCHEMAS_ELEM_BLOCK_RESTRICTION) &&
; 16907: 	 ((elemR->flags & XML_SCHEMAS_ELEM_BLOCK_RESTRICTION) == 0)) ||
; 16908: 	((elemB->flags & XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION) &&
; 16909: 	 ((elemR->flags & XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION) == 0)))
; 16910: 	 return (1);
; 16911:     /*
; 16912:     * SPEC (3.2.5) "R's {type definition} is validly derived given
; 16913:     * {extension, list, union} from B's {type definition}"
; 16914:     *
; 16915:     * BADSPEC TODO: What's the point of adding "list" and "union" to the
; 16916:     * set, if the corresponding constraints handle "restriction" and
; 16917:     * "extension" only?
; 16918:     *
; 16919:     */
; 16920:     {
; 16921: 	int set = 0;
; 16922: 
; 16923: 	set |= SUBSET_EXTENSION;
; 16924: 	set |= SUBSET_LIST;
; 16925: 	set |= SUBSET_UNION;
; 16926: 	if (xmlSchemaCheckCOSDerivedOK(ACTXT_CAST ctxt, elemR->subtypes,
; 16927: 	    elemB->subtypes, set) != 0)
; 16928: 	    return (1);
; 16929:     }
; 16930:     return (0);
; 16931: }
; 16932: 
; 16933: /**
; 16934:  * xmlSchemaCheckRCaseNSCompat:
; 16935:  * @ctxt:  the schema parser context
; 16936:  * @r: the restricting element declaration particle
; 16937:  * @b: the base wildcard particle
; 16938:  *
; 16939:  * (3.9.6) Constraints on Particle Schema Components
; 16940:  * Schema Component Constraint:
; 16941:  * Particle Derivation OK (Elt:Any -- NSCompat)
; 16942:  * (rcase-NSCompat)
; 16943:  *
; 16944:  * STATUS: complete
; 16945:  *
; 16946:  * Returns 0 if the constraints are satisfied, a positive
; 16947:  * error code if not and -1 if an internal error occurred.
; 16948:  */
; 16949: static int
; 16950: xmlSchemaCheckRCaseNSCompat(xmlSchemaParserCtxtPtr ctxt,
; 16951: 			    xmlSchemaParticlePtr r,
; 16952: 			    xmlSchemaParticlePtr b)
; 16953: {
; 16954:     /* TODO:Error codes (rcase-NSCompat). */
; 16955:     /*
; 16956:     * SPEC "For an element declaration particle to be a `valid restriction`
; 16957:     * of a wildcard particle all of the following must be true:"
; 16958:     *
; 16959:     * SPEC (1) "The element declaration's {target namespace} is `valid`
; 16960:     * with respect to the wildcard's {namespace constraint} as defined by
; 16961:     * Wildcard allows Namespace Name ($3.10.4)."
; 16962:     */
; 16963:     if (xmlSchemaCheckCVCWildcardNamespace((xmlSchemaWildcardPtr) b->children,
; 16964: 	((xmlSchemaElementPtr) r->children)->targetNamespace) != 0)
; 16965: 	return (1);
; 16966:     /*
; 16967:     * SPEC (2) "R's occurrence range is a valid restriction of B's
; 16968:     * occurrence range as defined by Occurrence Range OK ($3.9.6)."
; 16969:     */
; 16970:     if (xmlSchemaCheckParticleRangeOK(r->minOccurs, r->maxOccurs,
; 16971: 	    b->minOccurs, b->maxOccurs) != 0)
; 16972: 	return (1);
; 16973: 
; 16974:     return (0);
; 16975: }
; 16976: 
; 16977: /**
; 16978:  * xmlSchemaCheckRCaseRecurseAsIfGroup:
; 16979:  * @ctxt:  the schema parser context
; 16980:  * @r: the restricting element declaration particle
; 16981:  * @b: the base model group particle
; 16982:  *
; 16983:  * (3.9.6) Constraints on Particle Schema Components
; 16984:  * Schema Component Constraint:
; 16985:  * Particle Derivation OK (Elt:All/Choice/Sequence -- RecurseAsIfGroup)
; 16986:  * (rcase-RecurseAsIfGroup)
; 16987:  *
; 16988:  * STATUS: TODO
; 16989:  *
; 16990:  * Returns 0 if the constraints are satisfied, a positive
; 16991:  * error code if not and -1 if an internal error occurred.
; 16992:  */
; 16993: static int
; 16994: xmlSchemaCheckRCaseRecurseAsIfGroup(xmlSchemaParserCtxtPtr ctxt,
; 16995: 				    xmlSchemaParticlePtr r,
; 16996: 				    xmlSchemaParticlePtr b)
; 16997: {
; 16998:     /* TODO: Error codes (rcase-RecurseAsIfGroup). */
; 16999:     TODO
; 17000:     return (0);
; 17001: }
; 17002: 
; 17003: /**
; 17004:  * xmlSchemaCheckRCaseNSSubset:
; 17005:  * @ctxt:  the schema parser context
; 17006:  * @r: the restricting wildcard particle
; 17007:  * @b: the base wildcard particle
; 17008:  *
; 17009:  * (3.9.6) Constraints on Particle Schema Components
; 17010:  * Schema Component Constraint:
; 17011:  * Particle Derivation OK (Any:Any -- NSSubset)
; 17012:  * (rcase-NSSubset)
; 17013:  *
; 17014:  * STATUS: complete
; 17015:  *
; 17016:  * Returns 0 if the constraints are satisfied, a positive
; 17017:  * error code if not and -1 if an internal error occurred.
; 17018:  */
; 17019: static int
; 17020: xmlSchemaCheckRCaseNSSubset(xmlSchemaParserCtxtPtr ctxt,
; 17021: 				    xmlSchemaParticlePtr r,
; 17022: 				    xmlSchemaParticlePtr b,
; 17023: 				    int isAnyTypeBase)
; 17024: {
; 17025:     /* TODO: Error codes (rcase-NSSubset). */
; 17026:     /*
; 17027:     * SPEC (1) "R's occurrence range is a valid restriction of B's
; 17028:     * occurrence range as defined by Occurrence Range OK ($3.9.6)."
; 17029:     */
; 17030:     if (xmlSchemaCheckParticleRangeOK(r->minOccurs, r->maxOccurs,
; 17031: 	    b->minOccurs, b->maxOccurs))
; 17032: 	return (1);
; 17033:     /*
; 17034:     * SPEC (2) "R's {namespace constraint} must be an intensional subset
; 17035:     * of B's {namespace constraint} as defined by Wildcard Subset ($3.10.6)."
; 17036:     */
; 17037:     if (xmlSchemaCheckCOSNSSubset((xmlSchemaWildcardPtr) r->children,
; 17038: 	(xmlSchemaWildcardPtr) b->children))
; 17039: 	return (1);
; 17040:     /*
; 17041:     * SPEC (3) "Unless B is the content model wildcard of the `ur-type
; 17042:     * definition`, R's {process contents} must be identical to or stronger
; 17043:     * than B's {process contents}, where strict is stronger than lax is
; 17044:     * stronger than skip."
; 17045:     */
; 17046:     if (! isAnyTypeBase) {
; 17047: 	if ( ((xmlSchemaWildcardPtr) r->children)->processContents <
; 17048: 	    ((xmlSchemaWildcardPtr) b->children)->processContents)
; 17049: 	    return (1);
; 17050:     }
; 17051: 
; 17052:     return (0);
; 17053: }
; 17054: 
; 17055: /**
; 17056:  * xmlSchemaCheckCOSParticleRestrict:
; 17057:  * @ctxt:  the schema parser context
; 17058:  * @type:  the complex type definition
; 17059:  *
; 17060:  * (3.9.6) Constraints on Particle Schema Components
; 17061:  * Schema Component Constraint:
; 17062:  * Particle Valid (Restriction) (cos-particle-restrict)
; 17063:  *
; 17064:  * STATUS: TODO
; 17065:  *
; 17066:  * Returns 0 if the constraints are satisfied, a positive
; 17067:  * error code if not and -1 if an internal error occurred.
; 17068:  */
; 17069: static int
; 17070: xmlSchemaCheckCOSParticleRestrict(xmlSchemaParserCtxtPtr ctxt,
; 17071: 				  xmlSchemaParticlePtr r,
; 17072: 				  xmlSchemaParticlePtr b)
; 17073: {
; 17074:     int ret = 0;
; 17075: 
; 17076:     /*part = WXS_TYPE_PARTICLE(type);
; 17077:     basePart = WXS_TYPE_PARTICLE(base);
; 17078:     */
; 17079: 
; 17080:     TODO
; 17081: 
; 17082:     /*
; 17083:     * SPEC (1) "They are the same particle."
; 17084:     */
; 17085:     if (r == b)
; 17086: 	return (0);
; 17087: 
; 17088: 
; 17089:     return (0);
; 17090: }
; 17091: 
; 17092: #if 0
; 17093: /**
; 17094:  * xmlSchemaCheckRCaseNSRecurseCheckCardinality:
; 17095:  * @ctxt:  the schema parser context
; 17096:  * @r: the model group particle
; 17097:  * @b: the base wildcard particle
; 17098:  *
; 17099:  * (3.9.6) Constraints on Particle Schema Components
; 17100:  * Schema Component Constraint:
; 17101:  * Particle Derivation OK (All/Choice/Sequence:Any --
; 17102:  *                         NSRecurseCheckCardinality)
; 17103:  * (rcase-NSRecurseCheckCardinality)
; 17104:  *
; 17105:  * STATUS: TODO: subst-groups
; 17106:  *
; 17107:  * Returns 0 if the constraints are satisfied, a positive
; 17108:  * error code if not and -1 if an internal error occurred.
; 17109:  */
; 17110: static int
; 17111: xmlSchemaCheckRCaseNSRecurseCheckCardinality(xmlSchemaParserCtxtPtr ctxt,
; 17112: 					     xmlSchemaParticlePtr r,
; 17113: 					     xmlSchemaParticlePtr b)
; 17114: {
; 17115:     xmlSchemaParticlePtr part;
; 17116:     /* TODO: Error codes (rcase-NSRecurseCheckCardinality). */
; 17117:     if ((r->children == NULL) || (r->children->children == NULL))
; 17118: 	return (-1);
; 17119:     /*
; 17120:     * SPEC "For a group particle to be a `valid restriction` of a
; 17121:     * wildcard particle..."
; 17122:     *
; 17123:     * SPEC (1) "Every member of the {particles} of the group is a `valid
; 17124:     * restriction` of the wildcard as defined by
; 17125:     * Particle Valid (Restriction) ($3.9.6)."
; 17126:     */
; 17127:     part = (xmlSchemaParticlePtr) r->children->children;
; 17128:     do {
; 17129: 	if (xmlSchemaCheckCOSParticleRestrict(ctxt, part, b))
; 17130: 	    return (1);
; 17131: 	part = (xmlSchemaParticlePtr) part->next;
; 17132:     } while (part != NULL);
; 17133:     /*
; 17134:     * SPEC (2) "The effective total range of the group [...] is a
; 17135:     * valid restriction of B's occurrence range as defined by
; 17136:     * Occurrence Range OK ($3.9.6)."
; 17137:     */
; 17138:     if (xmlSchemaCheckParticleRangeOK(
; 17139: 	    xmlSchemaGetParticleTotalRangeMin(r),
; 17140: 	    xmlSchemaGetParticleTotalRangeMax(r),
; 17141: 	    b->minOccurs, b->maxOccurs) != 0)
; 17142: 	return (1);
; 17143:     return (0);
; 17144: }
; 17145: #endif
; 17146: 
; 17147: /**
; 17148:  * xmlSchemaCheckRCaseRecurse:
; 17149:  * @ctxt:  the schema parser context
; 17150:  * @r: the <all> or <sequence> model group particle
; 17151:  * @b: the base <all> or <sequence> model group particle
; 17152:  *
; 17153:  * (3.9.6) Constraints on Particle Schema Components
; 17154:  * Schema Component Constraint:
; 17155:  * Particle Derivation OK (All:All,Sequence:Sequence --
; 17156:                            Recurse)
; 17157:  * (rcase-Recurse)
; 17158:  *
; 17159:  * STATUS:  ?
; 17160:  * TODO: subst-groups
; 17161:  *
; 17162:  * Returns 0 if the constraints are satisfied, a positive
; 17163:  * error code if not and -1 if an internal error occurred.
; 17164:  */
; 17165: static int
; 17166: xmlSchemaCheckRCaseRecurse(xmlSchemaParserCtxtPtr ctxt,
; 17167: 			   xmlSchemaParticlePtr r,
; 17168: 			   xmlSchemaParticlePtr b)
; 17169: {
; 17170:     /* xmlSchemaParticlePtr part; */
; 17171:     /* TODO: Error codes (rcase-Recurse). */
; 17172:     if ((r->children == NULL) || (b->children == NULL) ||
; 17173: 	(r->children->type != b->children->type))
; 17174: 	return (-1);
; 17175:     /*
; 17176:     * SPEC "For an all or sequence group particle to be a `valid
; 17177:     * restriction` of another group particle with the same {compositor}..."
; 17178:     *
; 17179:     * SPEC (1) "R's occurrence range is a valid restriction of B's
; 17180:     * occurrence range as defined by Occurrence Range OK ($3.9.6)."
; 17181:     */
; 17182:     if (xmlSchemaCheckParticleRangeOK(r->minOccurs, r->maxOccurs,
; 17183: 	    b->minOccurs, b->maxOccurs))
; 17184: 	return (1);
; 17185: 
; 17186: 
; 17187:     return (0);
; 17188: }
; 17189: 
; 17190: #endif
; 17191: 
; 17192: #define FACET_RESTR_MUTUAL_ERR(fac1, fac2) \
; 17193:     xmlSchemaPCustomErrExt(pctxt,      \
; 17194: 	XML_SCHEMAP_INVALID_FACET_VALUE, \
; 17195: 	WXS_BASIC_CAST fac1, fac1->node, \
; 17196: 	"It is an error for both '%s' and '%s' to be specified on the "\
; 17197: 	"same type definition", \
; 17198: 	BAD_CAST xmlSchemaFacetTypeToString(fac1->type), \
; 17199: 	BAD_CAST xmlSchemaFacetTypeToString(fac2->type), NULL);
; 17200: 
; 17201: #define FACET_RESTR_ERR(fac1, msg) \
; 17202:     xmlSchemaPCustomErr(pctxt,      \
; 17203: 	XML_SCHEMAP_INVALID_FACET_VALUE, \
; 17204: 	WXS_BASIC_CAST fac1, fac1->node, \
; 17205: 	msg, NULL);
; 17206: 
; 17207: #define FACET_RESTR_FIXED_ERR(fac) \
; 17208:     xmlSchemaPCustomErr(pctxt, \
; 17209: 	XML_SCHEMAP_INVALID_FACET_VALUE, \
; 17210: 	WXS_BASIC_CAST fac, fac->node, \
; 17211: 	"The base type's facet is 'fixed', thus the value must not " \
; 17212: 	"differ", NULL);
; 17213: 
; 17214: static void
; 17215: xmlSchemaDeriveFacetErr(xmlSchemaParserCtxtPtr pctxt,
; 17216: 			xmlSchemaFacetPtr facet1,
; 17217: 			xmlSchemaFacetPtr facet2,
; 17218: 			int lessGreater,
; 17219: 			int orEqual,
; 17220: 			int ofBase)
; 17221: {
; 17222:     xmlChar *msg = NULL;
; 17223: 
; 17224:     msg = xmlStrdup(BAD_CAST "'");
; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));
; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");
; 17227:     if (lessGreater == 0)
; 17228: 	msg = xmlStrcat(msg, BAD_CAST " equal to");
; 17229:     if (lessGreater == 1)
; 17230: 	msg = xmlStrcat(msg, BAD_CAST " greater than");
; 17231:     else
; 17232: 	msg = xmlStrcat(msg, BAD_CAST " less than");
; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");
; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");
; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));
; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");
; 17240:     else
; 17241: 	msg = xmlStrcat(msg, BAD_CAST "'");
; 17242: 
; 17243:     xmlSchemaPCustomErr(pctxt,
; 17244: 	XML_SCHEMAP_INVALID_FACET_VALUE,
; 17245: 	WXS_BASIC_CAST facet1, NULL,
; 17246: 	(const char *) msg, NULL);
; 17247: 
; 17248:     if (msg != NULL)
; 17249: 	xmlFree(msg);
; 17250: }
; 17251: 
; 17252: /*
; 17253: * xmlSchemaDeriveAndValidateFacets:
; 17254: *
; 17255: * Schema Component Constraint: Simple Type Restriction (Facets)
; 17256: * (st-restrict-facets)
; 17257: */
; 17258: static int
; 17259: xmlSchemaDeriveAndValidateFacets(xmlSchemaParserCtxtPtr pctxt,
; 17260: 				 xmlSchemaTypePtr type)
; 17261: {
; 17262:     xmlSchemaTypePtr base = type->baseType;
; 17263:     xmlSchemaFacetLinkPtr link, cur, last = NULL;
; 17264:     xmlSchemaFacetPtr facet, bfacet,
; 17265: 	flength = NULL, ftotdig = NULL, ffracdig = NULL,
; 17266: 	fmaxlen = NULL, fminlen = NULL, /* facets of the current type */
; 17267: 	fmininc = NULL, fmaxinc = NULL,
; 17268: 	fminexc = NULL, fmaxexc = NULL,
; 17269: 	bflength = NULL, bftotdig = NULL, bffracdig = NULL,
; 17270: 	bfmaxlen = NULL, bfminlen = NULL, /* facets of the base type */
; 17271: 	bfmininc = NULL, bfmaxinc = NULL,
; 17272: 	bfminexc = NULL, bfmaxexc = NULL;
; 17273:     int res; /* err = 0, fixedErr; */
; 17274: 
; 17275:     /*
; 17276:     * SPEC st-restrict-facets 1:
; 17277:     * "The {variety} of R is the same as that of B."
; 17278:     */
; 17279:     /*
; 17280:     * SPEC st-restrict-facets 2:
; 17281:     * "If {variety} is atomic, the {primitive type definition}
; 17282:     * of R is the same as that of B."
; 17283:     *
; 17284:     * NOTE: we leave 1 & 2 out for now, since this will be
; 17285:     * satisfied by the derivation process.
; 17286:     * CONSTRUCTION TODO: Maybe needed if using a construction API.
; 17287:     */
; 17288:     /*
; 17289:     * SPEC st-restrict-facets 3:
; 17290:     * "The {facets} of R are the union of S and the {facets}
; 17291:     * of B, eliminating duplicates. To eliminate duplicates,
; 17292:     * when a facet of the same kind occurs in both S and the
; 17293:     * {facets} of B, the one in the {facets} of B is not
; 17294:     * included, with the exception of enumeration and pattern
; 17295:     * facets, for which multiple occurrences with distinct values
; 17296:     * are allowed."
; 17297:     */
; 17298: 
; 17299:     if ((type->facetSet == NULL) && (base->facetSet == NULL))
; 17300: 	return (0);
; 17301: 
; 17302:     last = type->facetSet;
; 17303:     if (last != NULL)
; 17304: 	while (last->next != NULL)
; 17305: 	    last = last->next;
; 17306: 
; 17307:     for (cur = type->facetSet; cur != NULL; cur = cur->next) {
; 17308: 	facet = cur->facet;
; 17309: 	switch (facet->type) {
; 17310: 	    case XML_SCHEMA_FACET_LENGTH:
; 17311: 		flength = facet; break;
; 17312: 	    case XML_SCHEMA_FACET_MINLENGTH:
; 17313: 		fminlen = facet; break;
; 17314: 	    case XML_SCHEMA_FACET_MININCLUSIVE:
; 17315: 		fmininc = facet; break;
; 17316: 	    case XML_SCHEMA_FACET_MINEXCLUSIVE:
; 17317: 		fminexc = facet; break;
; 17318: 	    case XML_SCHEMA_FACET_MAXLENGTH:
; 17319: 		fmaxlen = facet; break;
; 17320: 	    case XML_SCHEMA_FACET_MAXINCLUSIVE:
; 17321: 		fmaxinc = facet; break;
; 17322: 	    case XML_SCHEMA_FACET_MAXEXCLUSIVE:
; 17323: 		fmaxexc = facet; break;
; 17324: 	    case XML_SCHEMA_FACET_TOTALDIGITS:
; 17325: 		ftotdig = facet; break;
; 17326: 	    case XML_SCHEMA_FACET_FRACTIONDIGITS:
; 17327: 		ffracdig = facet; break;
; 17328: 	    default:
; 17329: 		break;
; 17330: 	}
; 17331:     }
; 17332:     for (cur = base->facetSet; cur != NULL; cur = cur->next) {
; 17333: 	facet = cur->facet;
; 17334: 	switch (facet->type) {
; 17335: 	    case XML_SCHEMA_FACET_LENGTH:
; 17336: 		bflength = facet; break;
; 17337: 	    case XML_SCHEMA_FACET_MINLENGTH:
; 17338: 		bfminlen = facet; break;
; 17339: 	    case XML_SCHEMA_FACET_MININCLUSIVE:
; 17340: 		bfmininc = facet; break;
; 17341: 	    case XML_SCHEMA_FACET_MINEXCLUSIVE:
; 17342: 		bfminexc = facet; break;
; 17343: 	    case XML_SCHEMA_FACET_MAXLENGTH:
; 17344: 		bfmaxlen = facet; break;
; 17345: 	    case XML_SCHEMA_FACET_MAXINCLUSIVE:
; 17346: 		bfmaxinc = facet; break;
; 17347: 	    case XML_SCHEMA_FACET_MAXEXCLUSIVE:
; 17348: 		bfmaxexc = facet; break;
; 17349: 	    case XML_SCHEMA_FACET_TOTALDIGITS:
; 17350: 		bftotdig = facet; break;
; 17351: 	    case XML_SCHEMA_FACET_FRACTIONDIGITS:
; 17352: 		bffracdig = facet; break;
; 17353: 	    default:
; 17354: 		break;
; 17355: 	}
; 17356:     }
; 17357:     /*
; 17358:     * length and minLength or maxLength (2.2) + (3.2)
; 17359:     */
; 17360:     if (flength && (fminlen || fmaxlen)) {
; 17361: 	FACET_RESTR_ERR(flength, "It is an error for both 'length' and "
; 17362: 	    "either of 'minLength' or 'maxLength' to be specified on "
; 17363: 	    "the same type definition")
; 17364:     }
; 17365:     /*
; 17366:     * Mutual exclusions in the same derivation step.
; 17367:     */
; 17368:     if ((fmaxinc) && (fmaxexc)) {
; 17369: 	/*
; 17370: 	* SCC "maxInclusive and maxExclusive"
; 17371: 	*/
; 17372: 	FACET_RESTR_MUTUAL_ERR(fmaxinc, fmaxexc)
; 17373:     }
; 17374:     if ((fmininc) && (fminexc)) {
; 17375: 	/*
; 17376: 	* SCC "minInclusive and minExclusive"
; 17377: 	*/
; 17378: 	FACET_RESTR_MUTUAL_ERR(fmininc, fminexc)
; 17379:     }
; 17380: 
; 17381:     if (flength && bflength) {
; 17382: 	/*
; 17383: 	* SCC "length valid restriction"
; 17384: 	* The values have to be equal.
; 17385: 	*/
; 17386: 	res = xmlSchemaCompareValues(flength->val, bflength->val);
; 17387: 	if (res == -2)
; 17388: 	    goto internal_error;
; 17389: 	if (res != 0)
; 17390: 	    xmlSchemaDeriveFacetErr(pctxt, flength, bflength, 0, 0, 1);
; 17391: 	if ((res != 0) && (bflength->fixed)) {
; 17392: 	    FACET_RESTR_FIXED_ERR(flength)
; 17393: 	}
; 17394: 
; 17395:     }
; 17396:     if (fminlen && bfminlen) {
; 17397: 	/*
; 17398: 	* SCC "minLength valid restriction"
; 17399: 	* minLength >= BASE minLength
; 17400: 	*/
; 17401: 	res = xmlSchemaCompareValues(fminlen->val, bfminlen->val);
; 17402: 	if (res == -2)
; 17403: 	    goto internal_error;
; 17404: 	if (res == -1)
; 17405: 	    xmlSchemaDeriveFacetErr(pctxt, fminlen, bfminlen, 1, 1, 1);
; 17406: 	if ((res != 0) && (bfminlen->fixed)) {
; 17407: 	    FACET_RESTR_FIXED_ERR(fminlen)
; 17408: 	}
; 17409:     }
; 17410:     if (fmaxlen && bfmaxlen) {
; 17411: 	/*
; 17412: 	* SCC "maxLength valid restriction"
; 17413: 	* maxLength <= BASE minLength
; 17414: 	*/
; 17415: 	res = xmlSchemaCompareValues(fmaxlen->val, bfmaxlen->val);
; 17416: 	if (res == -2)
; 17417: 	    goto internal_error;
; 17418: 	if (res == 1)
; 17419: 	    xmlSchemaDeriveFacetErr(pctxt, fmaxlen, bfmaxlen, -1, 1, 1);
; 17420: 	if ((res != 0) && (bfmaxlen->fixed)) {
; 17421: 	    FACET_RESTR_FIXED_ERR(fmaxlen)
; 17422: 	}
; 17423:     }
; 17424:     /*
; 17425:     * SCC "length and minLength or maxLength"
; 17426:     */
; 17427:     if (! flength)
; 17428: 	flength = bflength;
; 17429:     if (flength) {
; 17430: 	if (! fminlen)
; 17431: 	    fminlen = bfminlen;
; 17432: 	if (fminlen) {
; 17433: 	    /* (1.1) length >= minLength */
; 17434: 	    res = xmlSchemaCompareValues(flength->val, fminlen->val);
; 17435: 	    if (res == -2)
; 17436: 		goto internal_error;
; 17437: 	    if (res == -1)
; 17438: 		xmlSchemaDeriveFacetErr(pctxt, flength, fminlen, 1, 1, 0);
; 17439: 	}
; 17440: 	if (! fmaxlen)
; 17441: 	    fmaxlen = bfmaxlen;
; 17442: 	if (fmaxlen) {
; 17443: 	    /* (2.1) length <= maxLength */
; 17444: 	    res = xmlSchemaCompareValues(flength->val, fmaxlen->val);
; 17445: 	    if (res == -2)
; 17446: 		goto internal_error;
; 17447: 	    if (res == 1)
; 17448: 		xmlSchemaDeriveFacetErr(pctxt, flength, fmaxlen, -1, 1, 0);
; 17449: 	}
; 17450:     }
; 17451:     if (fmaxinc) {
; 17452: 	/*
; 17453: 	* "maxInclusive"
; 17454: 	*/
; 17455: 	if (fmininc) {
; 17456: 	    /* SCC "maxInclusive >= minInclusive" */
; 17457: 	    res = xmlSchemaCompareValues(fmaxinc->val, fmininc->val);
; 17458: 	    if (res == -2)
; 17459: 		goto internal_error;
; 17460: 	    if (res == -1) {
; 17461: 		xmlSchemaDeriveFacetErr(pctxt, fmaxinc, fmininc, 1, 1, 0);
; 17462: 	    }
; 17463: 	}
; 17464: 	/*
; 17465: 	* SCC "maxInclusive valid restriction"
; 17466: 	*/
; 17467: 	if (bfmaxinc) {
; 17468: 	    /* maxInclusive <= BASE maxInclusive */
; 17469: 	    res = xmlSchemaCompareValues(fmaxinc->val, bfmaxinc->val);
; 17470: 	    if (res == -2)
; 17471: 		goto internal_error;
; 17472: 	    if (res == 1)
; 17473: 		xmlSchemaDeriveFacetErr(pctxt, fmaxinc, bfmaxinc, -1, 1, 1);
; 17474: 	    if ((res != 0) && (bfmaxinc->fixed)) {
; 17475: 		FACET_RESTR_FIXED_ERR(fmaxinc)
; 17476: 	    }
; 17477: 	}
; 17478: 	if (bfmaxexc) {
; 17479: 	    /* maxInclusive < BASE maxExclusive */
; 17480: 	    res = xmlSchemaCompareValues(fmaxinc->val, bfmaxexc->val);
; 17481: 	    if (res == -2)
; 17482: 		goto internal_error;
; 17483: 	    if (res != -1) {
; 17484: 		xmlSchemaDeriveFacetErr(pctxt, fmaxinc, bfmaxexc, -1, 0, 1);
; 17485: 	    }
; 17486: 	}
; 17487: 	if (bfmininc) {
; 17488: 	    /* maxInclusive >= BASE minInclusive */
; 17489: 	    res = xmlSchemaCompareValues(fmaxinc->val, bfmininc->val);
; 17490: 	    if (res == -2)
; 17491: 		goto internal_error;
; 17492: 	    if (res == -1) {
; 17493: 		xmlSchemaDeriveFacetErr(pctxt, fmaxinc, bfmininc, 1, 1, 1);
; 17494: 	    }
; 17495: 	}
; 17496: 	if (bfminexc) {
; 17497: 	    /* maxInclusive > BASE minExclusive */
; 17498: 	    res = xmlSchemaCompareValues(fmaxinc->val, bfminexc->val);
; 17499: 	    if (res == -2)
; 17500: 		goto internal_error;
; 17501: 	    if (res != 1) {
; 17502: 		xmlSchemaDeriveFacetErr(pctxt, fmaxinc, bfminexc, 1, 0, 1);
; 17503: 	    }
; 17504: 	}
; 17505:     }
; 17506:     if (fmaxexc) {
; 17507: 	/*
; 17508: 	* "maxExclusive >= minExclusive"
; 17509: 	*/
; 17510: 	if (fminexc) {
; 17511: 	    res = xmlSchemaCompareValues(fmaxexc->val, fminexc->val);
; 17512: 	    if (res == -2)
; 17513: 		goto internal_error;
; 17514: 	    if (res == -1) {
; 17515: 		xmlSchemaDeriveFacetErr(pctxt, fmaxexc, fminexc, 1, 1, 0);
; 17516: 	    }
; 17517: 	}
; 17518: 	/*
; 17519: 	* "maxExclusive valid restriction"
; 17520: 	*/
; 17521: 	if (bfmaxexc) {
; 17522: 	    /* maxExclusive <= BASE maxExclusive */
; 17523: 	    res = xmlSchemaCompareValues(fmaxexc->val, bfmaxexc->val);
; 17524: 	    if (res == -2)
; 17525: 		goto internal_error;
; 17526: 	    if (res == 1) {
; 17527: 		xmlSchemaDeriveFacetErr(pctxt, fmaxexc, bfmaxexc, -1, 1, 1);
; 17528: 	    }
; 17529: 	    if ((res != 0) && (bfmaxexc->fixed)) {
; 17530: 		FACET_RESTR_FIXED_ERR(fmaxexc)
; 17531: 	    }
; 17532: 	}
; 17533: 	if (bfmaxinc) {
; 17534: 	    /* maxExclusive <= BASE maxInclusive */
; 17535: 	    res = xmlSchemaCompareValues(fmaxexc->val, bfmaxinc->val);
; 17536: 	    if (res == -2)
; 17537: 		goto internal_error;
; 17538: 	    if (res == 1) {
; 17539: 		xmlSchemaDeriveFacetErr(pctxt, fmaxexc, bfmaxinc, -1, 1, 1);
; 17540: 	    }
; 17541: 	}
; 17542: 	if (bfmininc) {
; 17543: 	    /* maxExclusive > BASE minInclusive */
; 17544: 	    res = xmlSchemaCompareValues(fmaxexc->val, bfmininc->val);
; 17545: 	    if (res == -2)
; 17546: 		goto internal_error;
; 17547: 	    if (res != 1) {
; 17548: 		xmlSchemaDeriveFacetErr(pctxt, fmaxexc, bfmininc, 1, 0, 1);
; 17549: 	    }
; 17550: 	}
; 17551: 	if (bfminexc) {
; 17552: 	    /* maxExclusive > BASE minExclusive */
; 17553: 	    res = xmlSchemaCompareValues(fmaxexc->val, bfminexc->val);
; 17554: 	    if (res == -2)
; 17555: 		goto internal_error;
; 17556: 	    if (res != 1) {
; 17557: 		xmlSchemaDeriveFacetErr(pctxt, fmaxexc, bfminexc, 1, 0, 1);
; 17558: 	    }
; 17559: 	}
; 17560:     }
; 17561:     if (fminexc) {
; 17562: 	/*
; 17563: 	* "minExclusive < maxInclusive"
; 17564: 	*/
; 17565: 	if (fmaxinc) {
; 17566: 	    res = xmlSchemaCompareValues(fminexc->val, fmaxinc->val);
; 17567: 	    if (res == -2)
; 17568: 		goto internal_error;
; 17569: 	    if (res != -1) {
; 17570: 		xmlSchemaDeriveFacetErr(pctxt, fminexc, fmaxinc, -1, 0, 0);
; 17571: 	    }
; 17572: 	}
; 17573: 	/*
; 17574: 	* "minExclusive valid restriction"
; 17575: 	*/
; 17576: 	if (bfminexc) {
; 17577: 	    /* minExclusive >= BASE minExclusive */
; 17578: 	    res = xmlSchemaCompareValues(fminexc->val, bfminexc->val);
; 17579: 	    if (res == -2)
; 17580: 		goto internal_error;
; 17581: 	    if (res == -1) {
; 17582: 		xmlSchemaDeriveFacetErr(pctxt, fminexc, bfminexc, 1, 1, 1);
; 17583: 	    }
; 17584: 	    if ((res != 0) && (bfminexc->fixed)) {
; 17585: 		FACET_RESTR_FIXED_ERR(fminexc)
; 17586: 	    }
; 17587: 	}
; 17588: 	if (bfmaxinc) {
; 17589: 	    /* minExclusive <= BASE maxInclusive */
; 17590: 	    res = xmlSchemaCompareValues(fminexc->val, bfmaxinc->val);
; 17591: 	    if (res == -2)
; 17592: 		goto internal_error;
; 17593: 	    if (res == 1) {
; 17594: 		xmlSchemaDeriveFacetErr(pctxt, fminexc, bfmaxinc, -1, 1, 1);
; 17595: 	    }
; 17596: 	}
; 17597: 	if (bfmininc) {
; 17598: 	    /* minExclusive >= BASE minInclusive */
; 17599: 	    res = xmlSchemaCompareValues(fminexc->val, bfmininc->val);
; 17600: 	    if (res == -2)
; 17601: 		goto internal_error;
; 17602: 	    if (res == -1) {
; 17603: 		xmlSchemaDeriveFacetErr(pctxt, fminexc, bfmininc, 1, 1, 1);
; 17604: 	    }
; 17605: 	}
; 17606: 	if (bfmaxexc) {
; 17607: 	    /* minExclusive < BASE maxExclusive */
; 17608: 	    res = xmlSchemaCompareValues(fminexc->val, bfmaxexc->val);
; 17609: 	    if (res == -2)
; 17610: 		goto internal_error;
; 17611: 	    if (res != -1) {
; 17612: 		xmlSchemaDeriveFacetErr(pctxt, fminexc, bfmaxexc, -1, 0, 1);
; 17613: 	    }
; 17614: 	}
; 17615:     }
; 17616:     if (fmininc) {
; 17617: 	/*
; 17618: 	* "minInclusive < maxExclusive"
; 17619: 	*/
; 17620: 	if (fmaxexc) {
; 17621: 	    res = xmlSchemaCompareValues(fmininc->val, fmaxexc->val);
; 17622: 	    if (res == -2)
; 17623: 		goto internal_error;
; 17624: 	    if (res != -1) {
; 17625: 		xmlSchemaDeriveFacetErr(pctxt, fmininc, fmaxexc, -1, 0, 0);
; 17626: 	    }
; 17627: 	}
; 17628: 	/*
; 17629: 	* "minExclusive valid restriction"
; 17630: 	*/
; 17631: 	if (bfmininc) {
; 17632: 	    /* minInclusive >= BASE minInclusive */
; 17633: 	    res = xmlSchemaCompareValues(fmininc->val, bfmininc->val);
; 17634: 	    if (res == -2)
; 17635: 		goto internal_error;
; 17636: 	    if (res == -1) {
; 17637: 		xmlSchemaDeriveFacetErr(pctxt, fmininc, bfmininc, 1, 1, 1);
; 17638: 	    }
; 17639: 	    if ((res != 0) && (bfmininc->fixed)) {
; 17640: 		FACET_RESTR_FIXED_ERR(fmininc)
; 17641: 	    }
; 17642: 	}
; 17643: 	if (bfmaxinc) {
; 17644: 	    /* minInclusive <= BASE maxInclusive */
; 17645: 	    res = xmlSchemaCompareValues(fmininc->val, bfmaxinc->val);
; 17646: 	    if (res == -2)
; 17647: 		goto internal_error;
; 17648: 	    if (res == 1) {
; 17649: 		xmlSchemaDeriveFacetErr(pctxt, fmininc, bfmaxinc, -1, 1, 1);
; 17650: 	    }
; 17651: 	}
; 17652: 	if (bfminexc) {
; 17653: 	    /* minInclusive > BASE minExclusive */
; 17654: 	    res = xmlSchemaCompareValues(fmininc->val, bfminexc->val);
; 17655: 	    if (res == -2)
; 17656: 		goto internal_error;
; 17657: 	    if (res != 1)
; 17658: 		xmlSchemaDeriveFacetErr(pctxt, fmininc, bfminexc, 1, 0, 1);
; 17659: 	}
; 17660: 	if (bfmaxexc) {
; 17661: 	    /* minInclusive < BASE maxExclusive */
; 17662: 	    res = xmlSchemaCompareValues(fmininc->val, bfmaxexc->val);
; 17663: 	    if (res == -2)
; 17664: 		goto internal_error;
; 17665: 	    if (res != -1)
; 17666: 		xmlSchemaDeriveFacetErr(pctxt, fmininc, bfmaxexc, -1, 0, 1);
; 17667: 	}
; 17668:     }
; 17669:     if (ftotdig && bftotdig) {
; 17670: 	/*
; 17671: 	* SCC " totalDigits valid restriction"
; 17672: 	* totalDigits <= BASE totalDigits
; 17673: 	*/
; 17674: 	res = xmlSchemaCompareValues(ftotdig->val, bftotdig->val);
; 17675: 	if (res == -2)
; 17676: 	    goto internal_error;
; 17677: 	if (res == 1)
; 17678: 	    xmlSchemaDeriveFacetErr(pctxt, ftotdig, bftotdig,
; 17679: 	    -1, 1, 1);
; 17680: 	if ((res != 0) && (bftotdig->fixed)) {
; 17681: 	    FACET_RESTR_FIXED_ERR(ftotdig)
; 17682: 	}
; 17683:     }
; 17684:     if (ffracdig && bffracdig) {
; 17685: 	/*
; 17686: 	* SCC  "fractionDigits valid restriction"
; 17687: 	* fractionDigits <= BASE fractionDigits
; 17688: 	*/
; 17689: 	res = xmlSchemaCompareValues(ffracdig->val, bffracdig->val);
; 17690: 	if (res == -2)
; 17691: 	    goto internal_error;
; 17692: 	if (res == 1)
; 17693: 	    xmlSchemaDeriveFacetErr(pctxt, ffracdig, bffracdig,
; 17694: 	    -1, 1, 1);
; 17695: 	if ((res != 0) && (bffracdig->fixed)) {
; 17696: 	    FACET_RESTR_FIXED_ERR(ffracdig)
; 17697: 	}
; 17698:     }
; 17699:     /*
; 17700:     * SCC "fractionDigits less than or equal to totalDigits"
; 17701:     */
; 17702:     if (! ftotdig)
; 17703: 	ftotdig = bftotdig;
; 17704:     if (! ffracdig)
; 17705: 	ffracdig = bffracdig;
; 17706:     if (ftotdig && ffracdig) {
; 17707: 	res = xmlSchemaCompareValues(ffracdig->val, ftotdig->val);
; 17708: 	if (res == -2)
; 17709: 	    goto internal_error;
; 17710: 	if (res == 1)
; 17711: 	    xmlSchemaDeriveFacetErr(pctxt, ffracdig, ftotdig,
; 17712: 		-1, 1, 0);
; 17713:     }
; 17714:     /*
; 17715:     * *Enumerations* won' be added here, since only the first set
; 17716:     * of enumerations in the ancestor-or-self axis is used
; 17717:     * for validation, plus we need to use the base type of those
; 17718:     * enumerations for whitespace.
; 17719:     *
; 17720:     * *Patterns*: won't be add here, since they are ORed at
; 17721:     * type level and ANDed at ancestor level. This will
; 17722:     * happed during validation by walking the base axis
; 17723:     * of the type.
; 17724:     */
; 17725:     for (cur = base->facetSet; cur != NULL; cur = cur->next) {
; 17726: 	bfacet = cur->facet;
; 17727: 	/*
; 17728: 	* Special handling of enumerations and patterns.
; 17729: 	* TODO: hmm, they should not appear in the set, so remove this.
; 17730: 	*/
; 17731: 	if ((bfacet->type == XML_SCHEMA_FACET_PATTERN) ||
; 17732: 	    (bfacet->type == XML_SCHEMA_FACET_ENUMERATION))
; 17733: 	    continue;
; 17734: 	/*
; 17735: 	* Search for a duplicate facet in the current type.
; 17736: 	*/
; 17737: 	link = type->facetSet;
; 17738: 	/* err = 0; */
; 17739: 	/* fixedErr = 0; */
; 17740: 	while (link != NULL) {
; 17741: 	    facet = link->facet;
; 17742: 	    if (facet->type == bfacet->type) {
; 17743: 		switch (facet->type) {
; 17744: 		    case XML_SCHEMA_FACET_WHITESPACE:
; 17745: 			/*
; 17746: 			* The whitespace must be stronger.
; 17747: 			*/
; 17748: 			if (facet->whitespace < bfacet->whitespace) {
; 17749: 			    FACET_RESTR_ERR(facet,
; 17750: 				"The 'whitespace' value has to be equal to "
; 17751: 				"or stronger than the 'whitespace' value of "
; 17752: 				"the base type")
; 17753: 			}
; 17754: 			if ((bfacet->fixed) &&
; 17755: 			    (facet->whitespace != bfacet->whitespace)) {
; 17756: 			    FACET_RESTR_FIXED_ERR(facet)
; 17757: 			}
; 17758: 			break;
; 17759: 		    default:
; 17760: 			break;
; 17761: 		}
; 17762: 		/* Duplicate found. */
; 17763: 		break;
; 17764: 	    }
; 17765: 	    link = link->next;
; 17766: 	}
; 17767: 	/*
; 17768: 	* If no duplicate was found: add the base types's facet
; 17769: 	* to the set.
; 17770: 	*/
; 17771: 	if (link == NULL) {
; 17772: 	    link = (xmlSchemaFacetLinkPtr)
; 17773: 		xmlMalloc(sizeof(xmlSchemaFacetLink));
; 17774: 	    if (link == NULL) {
; 17775: 		xmlSchemaPErrMemory(pctxt,
; 17776: 		    "deriving facets, creating a facet link", NULL);
; 17777: 		return (-1);
; 17778: 	    }
; 17779: 	    link->facet = cur->facet;
; 17780: 	    link->next = NULL;
; 17781: 	    if (last == NULL)
; 17782: 		type->facetSet = link;
; 17783: 	    else
; 17784: 		last->next = link;
; 17785: 	    last = link;
; 17786: 	}
; 17787: 
; 17788:     }
; 17789: 
; 17790:     return (0);
; 17791: internal_error:
; 17792:     PERROR_INT("xmlSchemaDeriveAndValidateFacets",
; 17793: 	"an error occurred");
; 17794:     return (-1);
; 17795: }
; 17796: 
; 17797: static int
; 17798: xmlSchemaFinishMemberTypeDefinitionsProperty(xmlSchemaParserCtxtPtr pctxt,
; 17799: 					     xmlSchemaTypePtr type)
; 17800: {
; 17801:     xmlSchemaTypeLinkPtr link, lastLink, prevLink, subLink, newLink;
; 17802:     /*
; 17803:     * The actual value is then formed by replacing any union type
; 17804:     * definition in the `explicit members` with the members of their
; 17805:     * {member type definitions}, in order.
; 17806:     *
; 17807:     * TODO: There's a bug entry at
; 17808:     * "http://lists.w3.org/Archives/Public/www-xml-schema-comments/2005JulSep/0287.html"
; 17809:     * which indicates that we'll keep the union types the future.
; 17810:     */
; 17811:     link = type->memberTypes;
; 17812:     while (link != NULL) {

	mov	edx, DWORD PTR _pctxt$[ebp]
	jmp	$LL36@xmlSchemaF
$LN137@xmlSchemaF:

; 1885 :         ctxt->nberrors++;

	mov	eax, DWORD PTR _pctxt$[ebp]

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BH@ENHIIAOL@allocating?5a?5type?5link@
	push	0
	push	0
	inc	DWORD PTR [eax+20]
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError

; 18177:     return(0);
; 18178: 
; 18179: exit_failure:
; 18180: #ifdef DEBUG_TYPE
; 18181:     xmlSchemaDebugFixedType(pctxt, type);
; 18182: #endif
; 18183:     return(-1);
; 18184: }

	add	esp, 20					; 00000014H
$exit_failure_1$186:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN179@xmlSchemaF:

; 18122: 	(xmlSchemaFinishMemberTypeDefinitionsProperty(pctxt, type) == -1))
; 18123: 	return(-1);
; 18124:     /*
; 18125:     * SPEC src-simple-type 1
; 18126:     * "The corresponding simple type definition, if any, must satisfy
; 18127:     * the conditions set out in Constraints on Simple Type Definition
; 18128:     * Schema Components ($3.14.6)."
; 18129:     */
; 18130:     /*
; 18131:     * Schema Component Constraint: Simple Type Definition Properties Correct
; 18132:     * (st-props-correct)
; 18133:     */
; 18134:     res = xmlSchemaCheckSTPropsCorrect(pctxt, type);

	mov	ebx, DWORD PTR _pctxt$[ebp]
	push	edi
	push	ebx
	call	_xmlSchemaCheckSTPropsCorrect
	add	esp, 8

; 18135:     HFAILURE HERROR

	cmp	eax, -1
	je	$LN171@xmlSchemaF
	test	eax, eax
	jne	$exit_error$187

; 18136:     /*
; 18137:     * Schema Component Constraint: Derivation Valid (Restriction, Simple)
; 18138:     * (cos-st-restricts)
; 18139:     */
; 18140:     res = xmlSchemaCheckCOSSTRestricts(pctxt, type);

	push	edi
	push	ebx
	call	_xmlSchemaCheckCOSSTRestricts
	add	esp, 8

; 18141:     HFAILURE HERROR

	cmp	eax, -1
	je	$LN171@xmlSchemaF
	test	eax, eax
	jne	$exit_error$187

; 18886:     if (typeDecl->facets != NULL) {

	mov	esi, DWORD PTR [edi+68]
	mov	eax, DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR _olderrs$1$[ebp], eax
	mov	DWORD PTR _name$1$[ebp], ecx
	test	esi, esi
	je	$LN69@xmlSchemaF

; 18887: 	xmlSchemaFacetPtr facet = typeDecl->facets;
; 18888: 
; 18889: 	/*
; 18890: 	* Temporarily assign the "schema" to the validation context
; 18891: 	* of the parser context. This is needed for NOTATION validation.
; 18892: 	*/
; 18893: 	if (pctxt->vctxt == NULL) {

	mov	edx, DWORD PTR [ebx+92]
	test	edx, edx
	jne	SHORT $LN158@xmlSchemaF

; 15799: 	ctxt->vctxt = xmlSchemaNewValidCtxt(NULL);

	push	edx
	call	_xmlSchemaNewValidCtxt
	add	esp, 4
	mov	DWORD PTR [ebx+92], eax

; 15800: 	if (ctxt->vctxt == NULL) {

	test	eax, eax
	jne	SHORT $LN77@xmlSchemaF

; 15801: 	    xmlSchemaPErr(ctxt, NULL,

	push	eax
	push	eax
	push	OFFSET ??_C@_0FL@FMHFMMBK@Internal?5error?3?5xmlSchemaCreate@
	push	3069					; 00000bfdH
	push	eax
	push	ebx
	call	_xmlSchemaPErr
	add	esp, 24					; 00000018H
$exit_failure_2$188:
	pop	edi

; 18177:     return(0);
; 18178: 
; 18179: exit_failure:
; 18180: #ifdef DEBUG_TYPE
; 18181:     xmlSchemaDebugFixedType(pctxt, type);
; 18182: #endif
; 18183:     return(-1);
; 18184: }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN77@xmlSchemaF:

; 15809: 	xmlSchemaSetValidErrors(ctxt->vctxt,

	push	DWORD PTR [ebx+4]
	push	DWORD PTR [ebx+12]
	push	DWORD PTR [ebx+8]
	push	eax
	call	_xmlSchemaSetValidErrors

; 15810: 	    ctxt->error, ctxt->warning, ctxt->errCtxt);
; 15811: 	xmlSchemaSetValidStructuredErrors(ctxt->vctxt,

	push	DWORD PTR [ebx+4]
	push	DWORD PTR [ebx+24]
	push	DWORD PTR [ebx+92]
	call	_xmlSchemaSetValidStructuredErrors
	mov	edx, DWORD PTR [ebx+92]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR _name$1$[ebp]
$LN158@xmlSchemaF:

; 18897: 	pctxt->vctxt->schema = pctxt->schema;

	mov	eax, DWORD PTR [ebx+36]
	mov	DWORD PTR [edx+20], eax

; 18898: 	while (facet != NULL) {

	test	esi, esi
	je	SHORT $LN68@xmlSchemaF
$LL67@xmlSchemaF:

; 18899: 	    res = xmlSchemaCheckFacet(facet, typeDecl, pctxt, name);

	push	ecx
	push	ebx
	push	edi
	push	esi
	call	_xmlSchemaCheckFacet
	add	esp, 16					; 00000010H

; 18900: 	    HFAILURE

	cmp	eax, -1
	je	$LN171@xmlSchemaF

; 18901: 	    facet = facet->next;

	mov	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _name$1$[ebp]
	test	esi, esi
	jne	SHORT $LL67@xmlSchemaF
$LN68@xmlSchemaF:

; 18902: 	}
; 18903: 	pctxt->vctxt->schema = NULL;

	mov	eax, DWORD PTR [ebx+92]
	mov	DWORD PTR [eax+20], 0
	mov	eax, DWORD PTR [ebx+20]
$LN69@xmlSchemaF:

; 18904:     }
; 18905:     if (olderrs != pctxt->nberrors)

	cmp	DWORD PTR _olderrs$1$[ebp], eax
	je	SHORT $LN174@xmlSchemaF

; 18906: 	return(pctxt->err);

	mov	eax, DWORD PTR [ebx+16]

; 18142:     /*
; 18143:     * TODO: Removed the error report, since it got annoying to get an
; 18144:     * extra error report, if anything failed until now.
; 18145:     * Enable this if needed.
; 18146:     *
; 18147:     * xmlSchemaPErr(ctxt, type->node,
; 18148:     *    XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
; 18149:     *    "Simple type '%s' does not satisfy the constraints "
; 18150:     *    "on simple type definitions.\n",
; 18151:     *    type->name, NULL);
; 18152:     */
; 18153:     /*
; 18154:     * Schema Component Constraint: Simple Type Restriction (Facets)
; 18155:     * (st-restrict-facets)
; 18156:     */
; 18157:     res = xmlSchemaCheckFacetValues(type, pctxt);
; 18158:     HFAILURE HERROR

	cmp	eax, -1
	je	$LN171@xmlSchemaF
	test	eax, eax
	jne	$exit_error$187
$LN174@xmlSchemaF:

; 18159:     if ((type->facetSet != NULL) ||

	cmp	DWORD PTR [edi+96], 0
	jne	SHORT $LN176@xmlSchemaF
	mov	eax, DWORD PTR [edi+64]
	cmp	DWORD PTR [eax+96], 0
	je	SHORT $LN17@xmlSchemaF
$LN176@xmlSchemaF:

; 18160: 	(type->baseType->facetSet != NULL)) {
; 18161: 	res = xmlSchemaDeriveAndValidateFacets(pctxt, type);

	push	edi
	push	ebx
	call	_xmlSchemaDeriveAndValidateFacets
	add	esp, 8

; 18162: 	HFAILURE HERROR

	cmp	eax, -1
	je	$LN171@xmlSchemaF
	test	eax, eax
	jne	$exit_error$187
$LN17@xmlSchemaF:

; 17909:     if (WXS_IS_LIST(type)) {

	mov	esi, DWORD PTR tv1155[ebp]
	mov	ecx, DWORD PTR [esi]
	test	cl, 64					; 00000040H
	je	SHORT $LN88@xmlSchemaF

; 17910: 	type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;

	or	ecx, 67108864				; 04000000H

; 17911: 	return (0);

	jmp	$LN181@xmlSchemaF
$LN88@xmlSchemaF:

; 17912:     } else if (WXS_IS_UNION(type))

	test	cl, cl
	js	$LN175@xmlSchemaF

; 17913: 	return (0);
; 17914: 
; 17915:     if (type->facetSet != NULL) {

	mov	eax, DWORD PTR [edi+96]
	test	eax, eax
	je	SHORT $LN81@xmlSchemaF
	npad	8
$LL82@xmlSchemaF:

; 17919: 	    if (lin->facet->type == XML_SCHEMA_FACET_WHITESPACE) {

	mov	edx, DWORD PTR [eax+4]
	cmp	DWORD PTR [edx], 1008			; 000003f0H
	je	SHORT $LN139@xmlSchemaF

; 17916: 	xmlSchemaFacetLinkPtr lin;
; 17917: 
; 17918: 	for (lin = type->facetSet; lin != NULL; lin = lin->next) {

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL82@xmlSchemaF
$LN81@xmlSchemaF:

; 17934: 	    }
; 17935: 	}
; 17936:     }
; 17937:     /*
; 17938:     * For all `atomic` datatypes other than string (and types `derived`
; 17939:     * by `restriction` from it) the value of whiteSpace is fixed to
; 17940:     * collapse
; 17941:     */
; 17942:     {
; 17943: 	xmlSchemaTypePtr anc;
; 17944: 
; 17945: 	for (anc = type->baseType; anc != NULL &&

	mov	eax, DWORD PTR [edi+64]
	test	eax, eax
	je	SHORT $LN175@xmlSchemaF
$LL87@xmlSchemaF:
	mov	edx, DWORD PTR [eax+88]
	cmp	edx, 45					; 0000002dH
	je	SHORT $LN175@xmlSchemaF

; 17946: 		anc->builtInType != XML_SCHEMAS_ANYTYPE;
; 17947: 		anc = anc->baseType) {
; 17948: 
; 17949: 	    if (anc->type == XML_SCHEMA_TYPE_BASIC) {

	cmp	DWORD PTR [eax], 1
	je	SHORT $LN140@xmlSchemaF

; 17934: 	    }
; 17935: 	}
; 17936:     }
; 17937:     /*
; 17938:     * For all `atomic` datatypes other than string (and types `derived`
; 17939:     * by `restriction` from it) the value of whiteSpace is fixed to
; 17940:     * collapse
; 17941:     */
; 17942:     {
; 17943: 	xmlSchemaTypePtr anc;
; 17944: 
; 17945: 	for (anc = type->baseType; anc != NULL &&

	mov	eax, DWORD PTR [eax+64]
	test	eax, eax
	jne	SHORT $LL87@xmlSchemaF

; 13476: 	if ((type->builtInType == XML_SCHEMAS_ANYSIMPLETYPE) ||

	jmp	SHORT $LN175@xmlSchemaF
$LN139@xmlSchemaF:

; 17920: 		switch (lin->facet->whitespace) {

	mov	eax, DWORD PTR [edx+28]
	sub	eax, 1
	je	SHORT $LN93@xmlSchemaF
	sub	eax, 1
	je	SHORT $LN94@xmlSchemaF
	sub	eax, 1
	jne	$LN171@xmlSchemaF

; 17926: 		    break;
; 17927: 		case XML_SCHEMAS_FACET_COLLAPSE:
; 17928: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;

	mov	eax, 67108864				; 04000000H

; 17929: 		    break;
; 17930: 		default:
; 17931: 		    return (-1);
; 17932: 		}
; 17933: 		return (0);

	or	ecx, eax
	jmp	SHORT $LN181@xmlSchemaF
$LN94@xmlSchemaF:

; 17923: 		    break;
; 17924: 		case XML_SCHEMAS_FACET_REPLACE:
; 17925: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_REPLACE;

	mov	eax, 33554432				; 02000000H

; 17929: 		    break;
; 17930: 		default:
; 17931: 		    return (-1);
; 17932: 		}
; 17933: 		return (0);

	or	ecx, eax
	jmp	SHORT $LN181@xmlSchemaF
$LN93@xmlSchemaF:

; 17921: 		case XML_SCHEMAS_FACET_PRESERVE:
; 17922: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE;

	mov	eax, 16777216				; 01000000H

; 17929: 		    break;
; 17930: 		default:
; 17931: 		    return (-1);
; 17932: 		}
; 17933: 		return (0);

	or	ecx, eax
	jmp	SHORT $LN181@xmlSchemaF
$LN140@xmlSchemaF:

; 17950: 		if (anc->builtInType == XML_SCHEMAS_NORMSTRING) {

	cmp	edx, 2
	jne	SHORT $LN98@xmlSchemaF

; 17951: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_REPLACE;

	or	ecx, 33554432				; 02000000H
	jmp	SHORT $LN181@xmlSchemaF
$LN98@xmlSchemaF:

; 17952: 
; 17953: 		} else if ((anc->builtInType == XML_SCHEMAS_STRING) ||

	cmp	edx, 1
	je	SHORT $LN102@xmlSchemaF
	cmp	edx, 46					; 0000002eH
	je	SHORT $LN102@xmlSchemaF

; 17956: 
; 17957: 		} else
; 17958: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;

	or	ecx, 67108864				; 04000000H
	jmp	SHORT $LN181@xmlSchemaF
$LN102@xmlSchemaF:

; 17954: 		    (anc->builtInType == XML_SCHEMAS_ANYSIMPLETYPE)) {
; 17955: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE;

	or	ecx, 16777216				; 01000000H
$LN181@xmlSchemaF:

; 17851:     int has = 0, needVal = 0, normVal = 0;

	mov	DWORD PTR [esi], ecx
$LN175@xmlSchemaF:

; 17852: 
; 17853:     has	= (type->baseType->flags & XML_SCHEMAS_TYPE_HAS_FACETS) ? 1 : 0;

	mov	eax, DWORD PTR [edi+64]
	xor	esi, esi
	mov	DWORD PTR _needVal$1$[ebp], 0
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, ecx
	shr	edx, 27					; 0000001bH
	and	edx, 1

; 17854:     if (has) {

	je	SHORT $LN110@xmlSchemaF

; 17855: 	needVal = (type->baseType->flags &

	mov	eax, ecx

; 17856: 	    XML_SCHEMAS_TYPE_FACETSNEEDVALUE) ? 1 : 0;
; 17857: 	normVal = (type->baseType->flags &

	mov	esi, ecx
	shr	eax, 21					; 00000015H
	and	eax, 1
	shr	esi, 28					; 0000001cH
	mov	DWORD PTR _needVal$1$[ebp], eax
	and	esi, 1
$LN110@xmlSchemaF:

; 17858: 	    XML_SCHEMAS_TYPE_NORMVALUENEEDED) ? 1 : 0;
; 17859:     }
; 17860:     if (type->facets != NULL) {

	mov	ecx, DWORD PTR [edi+68]
	test	ecx, ecx
	je	SHORT $LN106@xmlSchemaF
	npad	7
$LL107@xmlSchemaF:

; 17864: 	    switch (fac->type) {

	mov	eax, DWORD PTR [ecx]
	sub	eax, 1006				; 000003eeH
	je	SHORT $LN113@xmlSchemaF
	sub	eax, 1
	je	SHORT $LN114@xmlSchemaF
	sub	eax, 1
	je	SHORT $LN105@xmlSchemaF

; 17873: 		    normVal = 1;
; 17874: 		    has = 1;
; 17875: 		    break;
; 17876: 		default:
; 17877: 		    has = 1;

	mov	edx, 1
	jmp	SHORT $LN105@xmlSchemaF
$LN114@xmlSchemaF:

; 17865: 		case XML_SCHEMA_FACET_WHITESPACE:
; 17866: 		    break;
; 17867: 		case XML_SCHEMA_FACET_PATTERN:
; 17868: 		    normVal = 1;
; 17869: 		    has = 1;
; 17870: 		    break;
; 17871: 		case XML_SCHEMA_FACET_ENUMERATION:
; 17872: 		    needVal = 1;

	mov	DWORD PTR _needVal$1$[ebp], 1
$LN113@xmlSchemaF:

; 17861: 	xmlSchemaFacetPtr fac;
; 17862: 
; 17863: 	for (fac = type->facets; fac != NULL; fac = fac->next) {

	mov	esi, 1
	mov	edx, esi
$LN105@xmlSchemaF:
	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	jne	SHORT $LL107@xmlSchemaF
$LN106@xmlSchemaF:

; 17878: 		    break;
; 17879: 	    }
; 17880: 	}
; 17881:     }
; 17882:     if (normVal)

	test	esi, esi
	mov	esi, DWORD PTR tv1155[ebp]
	je	SHORT $LN177@xmlSchemaF

; 17883: 	type->flags |= XML_SCHEMAS_TYPE_NORMVALUENEEDED;

	or	DWORD PTR [esi], 268435456		; 10000000H
$LN177@xmlSchemaF:

; 17884:     if (needVal)

	mov	eax, DWORD PTR _needVal$1$[ebp]
	test	eax, eax
	je	SHORT $LN178@xmlSchemaF

; 17885: 	type->flags |= XML_SCHEMAS_TYPE_FACETSNEEDVALUE;

	or	DWORD PTR [esi], 2097152		; 00200000H
$LN178@xmlSchemaF:

; 17886:     if (has)

	test	edx, edx
	je	SHORT $exit_error$187

; 17887: 	type->flags |= XML_SCHEMAS_TYPE_HAS_FACETS;

	or	DWORD PTR [esi], 134217728		; 08000000H
	mov	ecx, DWORD PTR [esi]

; 17888: 
; 17889:     if (has && (! needVal) && WXS_IS_ATOMIC(type)) {

	test	eax, eax
	jne	SHORT $exit_error$187
	test	ecx, 256				; 00000100H
	je	SHORT $exit_error$187
$LL123@xmlSchemaF:

; 13476: 	if ((type->builtInType == XML_SCHEMAS_ANYSIMPLETYPE) ||

	cmp	DWORD PTR [edi+88], 46			; 0000002eH
	je	SHORT $LN141@xmlSchemaF
	test	DWORD PTR [edi+48], 16384		; 00004000H
	jne	SHORT $LN141@xmlSchemaF

; 13477: 	   (type->flags & XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE))
; 13478: 	    return (type);
; 13479: 	type = type->baseType;

	mov	edi, DWORD PTR [edi+64]
	test	edi, edi
	jne	SHORT $LL123@xmlSchemaF
$LN141@xmlSchemaF:

; 17894: 	if ((prim->builtInType != XML_SCHEMAS_ANYSIMPLETYPE) &&

	mov	eax, DWORD PTR [edi+88]
	cmp	eax, 46					; 0000002eH
	je	SHORT $exit_error$187
	cmp	eax, 1
	je	SHORT $exit_error$187

; 17895: 	    (prim->builtInType != XML_SCHEMAS_STRING)) {
; 17896: 	    type->flags |= XML_SCHEMAS_TYPE_FACETSNEEDVALUE;

	or	ecx, 2097152				; 00200000H
	mov	DWORD PTR [esi], ecx
$exit_error$187:

; 18163:     }
; 18164:     /*
; 18165:     * Whitespace value.
; 18166:     */
; 18167:     res = xmlSchemaTypeFixupWhitespace(type);
; 18168:     HFAILURE HERROR
; 18169:     xmlSchemaTypeFixupOptimFacets(type);
; 18170: 
; 18171: exit_error:
; 18172: #ifdef DEBUG_TYPE
; 18173:     xmlSchemaDebugFixedType(pctxt, type);
; 18174: #endif
; 18175:     if (olderrs != pctxt->nberrors)

	mov	eax, DWORD PTR _olderrs$1$[ebp]
	cmp	eax, DWORD PTR [ebx+20]
	je	SHORT $LN4@xmlSchemaF

; 18176: 	return(pctxt->err);

	mov	eax, DWORD PTR [ebx+16]
	pop	edi

; 18177:     return(0);
; 18178: 
; 18179: exit_failure:
; 18180: #ifdef DEBUG_TYPE
; 18181:     xmlSchemaDebugFixedType(pctxt, type);
; 18182: #endif
; 18183:     return(-1);
; 18184: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlSchemaF:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaFixupSimpleTypeStageTwo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFixupSimpleTypeStageOne
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlSchemaFixupSimpleTypeStageOne PROC			; COMDAT

; 17969: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [esi], 4
	jne	$LN4@xmlSchemaF

; 17970:     if (type->type != XML_SCHEMA_TYPE_SIMPLE)
; 17971: 	return(0);
; 17972:     if (! WXS_IS_TYPE_NOT_FIXED_1(type))

	mov	eax, DWORD PTR [esi+48]
	test	eax, 536870912				; 20000000H
	jne	$LN4@xmlSchemaF

; 17974:     type->flags |= XML_SCHEMAS_TYPE_FIXUP_1;

	or	eax, 536870912				; 20000000H
	mov	DWORD PTR [esi+48], eax

; 17975: 
; 17976:     if (WXS_IS_LIST(type)) {

	test	al, 64					; 00000040H
	je	SHORT $LN5@xmlSchemaF

; 17977: 	/*
; 17978: 	* Corresponds to <simpleType><list>...
; 17979: 	*/
; 17980: 	if (type->subtypes == NULL) {

	cmp	DWORD PTR [esi+28], 0
	jne	$LN4@xmlSchemaF

; 17981: 	    /*
; 17982: 	    * This one is really needed, so get out.
; 17983: 	    */
; 17984: 	    PERROR_INT("xmlSchemaFixupSimpleTypeStageOne",

	push	OFFSET ??_C@_0CE@OOLPDECC@list?5type?5has?5no?5item?9type?5assi@
$LN20@xmlSchemaF:

; 18027: 	    /*
; 18028: 	    * NOTE that we won't assign the memberTypes of the base,
; 18029: 	    * since this will make trouble when freeing them; we will
; 18030: 	    * use a lookup function to access them instead.
; 18031: 	    */
; 18032: 	}
; 18033:     }
; 18034:     return(0);
; 18035: }

	push	OFFSET ??_C@_0CB@LJIHOMAE@xmlSchemaFixupSimpleTypeStageOn@
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH
$LN21@xmlSchemaF:
	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN5@xmlSchemaF:

; 17985: 		"list type has no item-type assigned");
; 17986: 	    return(-1);
; 17987: 	}
; 17988:     } else if (WXS_IS_UNION(type)) {

	test	al, al
	jns	SHORT $LN8@xmlSchemaF

; 17989: 	/*
; 17990: 	* Corresponds to <simpleType><union>...
; 17991: 	*/
; 17992: 	if (type->memberTypes == NULL) {

	cmp	DWORD PTR [esi+92], 0
	jne	SHORT $LN4@xmlSchemaF

; 17993: 	    /*
; 17994: 	    * This one is really needed, so get out.
; 17995: 	    */
; 17996: 	    PERROR_INT("xmlSchemaFixupSimpleTypeStageOne",

	push	OFFSET ??_C@_0CI@HMJDLBFH@union?5type?5has?5no?5member?9types?5@

; 17997: 		"union type has no member-types assigned");
; 17998: 	    return(-1);

	jmp	SHORT $LN20@xmlSchemaF
$LN8@xmlSchemaF:

; 17999: 	}
; 18000:     } else {
; 18001: 	/*
; 18002: 	* Corresponds to <simpleType><restriction>...
; 18003: 	*/
; 18004: 	if (type->baseType == NULL) {

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	jne	SHORT $LN11@xmlSchemaF

; 18005: 	    PERROR_INT("xmlSchemaFixupSimpleTypeStageOne",

	push	OFFSET ??_C@_0BP@EGJFJLNK@type?5has?5no?5base?9type?5assigned@

; 18006: 		"type has no base-type assigned");
; 18007: 	    return(-1);

	jmp	SHORT $LN20@xmlSchemaF
$LN11@xmlSchemaF:

; 18008: 	}
; 18009: 	if (WXS_IS_TYPE_NOT_FIXED_1(type->baseType))

	cmp	DWORD PTR [eax], 1
	je	SHORT $LN13@xmlSchemaF
	test	DWORD PTR [eax+48], 536870912		; 20000000H
	jne	SHORT $LN13@xmlSchemaF

; 18010: 	    if (xmlSchemaFixupSimpleTypeStageOne(pctxt, type->baseType) == -1)

	push	eax
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaFixupSimpleTypeStageOne
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN21@xmlSchemaF
$LN13@xmlSchemaF:

; 18011: 		return(-1);
; 18012: 	/*
; 18013: 	* Variety
; 18014: 	* If the <restriction> alternative is chosen, then the
; 18015: 	* {variety} of the {base type definition}.
; 18016: 	*/
; 18017: 	if (WXS_IS_ATOMIC(type->baseType))

	mov	ecx, DWORD PTR [esi+64]
	mov	eax, DWORD PTR [ecx+48]
	test	eax, 256				; 00000100H
	je	SHORT $LN14@xmlSchemaF

; 18018: 	    type->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 256			; 00000100H
	xor	eax, eax
	pop	esi

; 18027: 	    /*
; 18028: 	    * NOTE that we won't assign the memberTypes of the base,
; 18029: 	    * since this will make trouble when freeing them; we will
; 18030: 	    * use a lookup function to access them instead.
; 18031: 	    */
; 18032: 	}
; 18033:     }
; 18034:     return(0);
; 18035: }

	pop	ebp
	ret	0
$LN14@xmlSchemaF:

; 18019: 	else if (WXS_IS_LIST(type->baseType)) {

	test	al, 64					; 00000040H
	je	SHORT $LN16@xmlSchemaF

; 18020: 	    type->flags |= XML_SCHEMAS_TYPE_VARIETY_LIST;

	or	DWORD PTR [esi+48], 64			; 00000040H

; 18021: 	    /*
; 18022: 	    * Inherit the itemType.
; 18023: 	    */
; 18024: 	    type->subtypes = type->baseType->subtypes;

	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR [esi+28], eax
	xor	eax, eax
	pop	esi

; 18027: 	    /*
; 18028: 	    * NOTE that we won't assign the memberTypes of the base,
; 18029: 	    * since this will make trouble when freeing them; we will
; 18030: 	    * use a lookup function to access them instead.
; 18031: 	    */
; 18032: 	}
; 18033:     }
; 18034:     return(0);
; 18035: }

	pop	ebp
	ret	0
$LN16@xmlSchemaF:

; 18025: 	} else if (WXS_IS_UNION(type->baseType)) {

	test	al, al
	jns	SHORT $LN4@xmlSchemaF

; 18026: 	    type->flags |= XML_SCHEMAS_TYPE_VARIETY_UNION;

	or	DWORD PTR [esi+48], 128			; 00000080H
$LN4@xmlSchemaF:

; 17973: 	return(0);

	xor	eax, eax
	pop	esi

; 18027: 	    /*
; 18028: 	    * NOTE that we won't assign the memberTypes of the base,
; 18029: 	    * since this will make trouble when freeing them; we will
; 18030: 	    * use a lookup function to access them instead.
; 18031: 	    */
; 18032: 	}
; 18033:     }
; 18034:     return(0);
; 18035: }

	pop	ebp
	ret	0
_xmlSchemaFixupSimpleTypeStageOne ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaTypeFixupWhitespace
_TEXT	SEGMENT
_type$ = 8						; size = 4
_xmlSchemaTypeFixupWhitespace PROC			; COMDAT

; 17903: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR [esi+48]
	test	cl, 64					; 00000040H
	je	SHORT $LN10@xmlSchemaT
$LN37@xmlSchemaT:

; 17956: 
; 17957: 		} else
; 17958: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;
; 17959: 		break;
; 17960: 	    }
; 17961: 	}
; 17962:     }
; 17963:     return (0);
; 17964: }

	or	ecx, 67108864				; 04000000H
	xor	eax, eax
	mov	DWORD PTR [esi+48], ecx
	pop	esi
	pop	ebp
	ret	0
$LN10@xmlSchemaT:

; 17904: 
; 17905: 
; 17906:     /*
; 17907:     * Evaluate the whitespace-facet value.
; 17908:     */
; 17909:     if (WXS_IS_LIST(type)) {
; 17910: 	type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;
; 17911: 	return (0);
; 17912:     } else if (WXS_IS_UNION(type))

	test	cl, cl
	js	$LN23@xmlSchemaT

; 17913: 	return (0);
; 17914: 
; 17915:     if (type->facetSet != NULL) {

	mov	eax, DWORD PTR [esi+96]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaT
	npad	10
$LL4@xmlSchemaT:

; 17919: 	    if (lin->facet->type == XML_SCHEMA_FACET_WHITESPACE) {

	mov	edx, DWORD PTR [eax+4]
	cmp	DWORD PTR [edx], 1008			; 000003f0H
	je	SHORT $LN28@xmlSchemaT

; 17916: 	xmlSchemaFacetLinkPtr lin;
; 17917: 
; 17918: 	for (lin = type->facetSet; lin != NULL; lin = lin->next) {

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL4@xmlSchemaT
$LN3@xmlSchemaT:

; 17934: 	    }
; 17935: 	}
; 17936:     }
; 17937:     /*
; 17938:     * For all `atomic` datatypes other than string (and types `derived`
; 17939:     * by `restriction` from it) the value of whiteSpace is fixed to
; 17940:     * collapse
; 17941:     */
; 17942:     {
; 17943: 	xmlSchemaTypePtr anc;
; 17944: 
; 17945: 	for (anc = type->baseType; anc != NULL &&

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	$LN23@xmlSchemaT
	npad	4
$LL9@xmlSchemaT:
	mov	edx, DWORD PTR [eax+88]
	cmp	edx, 45					; 0000002dH
	je	SHORT $LN23@xmlSchemaT

; 17946: 		anc->builtInType != XML_SCHEMAS_ANYTYPE;
; 17947: 		anc = anc->baseType) {
; 17948: 
; 17949: 	    if (anc->type == XML_SCHEMA_TYPE_BASIC) {

	cmp	DWORD PTR [eax], 1
	je	SHORT $LN29@xmlSchemaT

; 17934: 	    }
; 17935: 	}
; 17936:     }
; 17937:     /*
; 17938:     * For all `atomic` datatypes other than string (and types `derived`
; 17939:     * by `restriction` from it) the value of whiteSpace is fixed to
; 17940:     * collapse
; 17941:     */
; 17942:     {
; 17943: 	xmlSchemaTypePtr anc;
; 17944: 
; 17945: 	for (anc = type->baseType; anc != NULL &&

	mov	eax, DWORD PTR [eax+64]
	test	eax, eax
	jne	SHORT $LL9@xmlSchemaT
	pop	esi

; 17956: 
; 17957: 		} else
; 17958: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;
; 17959: 		break;
; 17960: 	    }
; 17961: 	}
; 17962:     }
; 17963:     return (0);
; 17964: }

	pop	ebp
	ret	0
$LN28@xmlSchemaT:

; 17920: 		switch (lin->facet->whitespace) {

	mov	eax, DWORD PTR [edx+28]
	sub	eax, 1
	je	SHORT $LN15@xmlSchemaT
	sub	eax, 1
	je	SHORT $LN16@xmlSchemaT
	sub	eax, 1
	je	SHORT $LN17@xmlSchemaT

; 17929: 		    break;
; 17930: 		default:
; 17931: 		    return (-1);

	or	eax, -1
	pop	esi

; 17956: 
; 17957: 		} else
; 17958: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;
; 17959: 		break;
; 17960: 	    }
; 17961: 	}
; 17962:     }
; 17963:     return (0);
; 17964: }

	pop	ebp
	ret	0
$LN17@xmlSchemaT:

; 17926: 		    break;
; 17927: 		case XML_SCHEMAS_FACET_COLLAPSE:
; 17928: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;

	mov	eax, 67108864				; 04000000H

; 17932: 		}
; 17933: 		return (0);

	or	ecx, eax

; 17956: 
; 17957: 		} else
; 17958: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;
; 17959: 		break;
; 17960: 	    }
; 17961: 	}
; 17962:     }
; 17963:     return (0);
; 17964: }

	xor	eax, eax
	mov	DWORD PTR [esi+48], ecx
	pop	esi
	pop	ebp
	ret	0
$LN16@xmlSchemaT:

; 17923: 		    break;
; 17924: 		case XML_SCHEMAS_FACET_REPLACE:
; 17925: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_REPLACE;

	mov	eax, 33554432				; 02000000H

; 17932: 		}
; 17933: 		return (0);

	or	ecx, eax

; 17956: 
; 17957: 		} else
; 17958: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;
; 17959: 		break;
; 17960: 	    }
; 17961: 	}
; 17962:     }
; 17963:     return (0);
; 17964: }

	xor	eax, eax
	mov	DWORD PTR [esi+48], ecx
	pop	esi
	pop	ebp
	ret	0
$LN15@xmlSchemaT:

; 17921: 		case XML_SCHEMAS_FACET_PRESERVE:
; 17922: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE;

	mov	eax, 16777216				; 01000000H

; 17932: 		}
; 17933: 		return (0);

	or	ecx, eax

; 17956: 
; 17957: 		} else
; 17958: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;
; 17959: 		break;
; 17960: 	    }
; 17961: 	}
; 17962:     }
; 17963:     return (0);
; 17964: }

	xor	eax, eax
	mov	DWORD PTR [esi+48], ecx
	pop	esi
	pop	ebp
	ret	0
$LN29@xmlSchemaT:

; 17950: 		if (anc->builtInType == XML_SCHEMAS_NORMSTRING) {

	cmp	edx, 2
	jne	SHORT $LN20@xmlSchemaT

; 17951: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_REPLACE;

	or	ecx, 33554432				; 02000000H

; 17956: 
; 17957: 		} else
; 17958: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;
; 17959: 		break;
; 17960: 	    }
; 17961: 	}
; 17962:     }
; 17963:     return (0);
; 17964: }

	xor	eax, eax
	mov	DWORD PTR [esi+48], ecx
	pop	esi
	pop	ebp
	ret	0
$LN20@xmlSchemaT:

; 17952: 
; 17953: 		} else if ((anc->builtInType == XML_SCHEMAS_STRING) ||

	cmp	edx, 1
	je	SHORT $LN24@xmlSchemaT
	cmp	edx, 46					; 0000002eH
	jne	$LN37@xmlSchemaT
$LN24@xmlSchemaT:

; 17954: 		    (anc->builtInType == XML_SCHEMAS_ANYSIMPLETYPE)) {
; 17955: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE;

	or	ecx, 16777216				; 01000000H

; 17956: 
; 17957: 		} else
; 17958: 		    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;
; 17959: 		break;
; 17960: 	    }
; 17961: 	}
; 17962:     }
; 17963:     return (0);
; 17964: }

	mov	DWORD PTR [esi+48], ecx
$LN23@xmlSchemaT:
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
_xmlSchemaTypeFixupWhitespace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaTypeFixupOptimFacets
_TEXT	SEGMENT
_type$ = 8						; size = 4
_xmlSchemaTypeFixupOptimFacets PROC			; COMDAT

; 17850: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _type$[ebp]
	xor	ebx, ebx
	xor	edi, edi
	mov	eax, DWORD PTR [ecx+64]
	mov	eax, DWORD PTR [eax+48]
	mov	esi, eax
	shr	esi, 27					; 0000001bH
	and	esi, 1
	je	SHORT $LN7@xmlSchemaT

; 17851:     int has = 0, needVal = 0, normVal = 0;
; 17852: 
; 17853:     has	= (type->baseType->flags & XML_SCHEMAS_TYPE_HAS_FACETS) ? 1 : 0;
; 17854:     if (has) {
; 17855: 	needVal = (type->baseType->flags &
; 17856: 	    XML_SCHEMAS_TYPE_FACETSNEEDVALUE) ? 1 : 0;
; 17857: 	normVal = (type->baseType->flags &

	mov	ebx, eax
	mov	edi, eax
	shr	ebx, 21					; 00000015H
	shr	edi, 28					; 0000001cH
	and	ebx, 1
	and	edi, 1
$LN7@xmlSchemaT:

; 17858: 	    XML_SCHEMAS_TYPE_NORMVALUENEEDED) ? 1 : 0;
; 17859:     }
; 17860:     if (type->facets != NULL) {

	mov	edx, DWORD PTR [ecx+68]
	test	edx, edx
	je	SHORT $LN3@xmlSchemaT
	npad	2
$LL4@xmlSchemaT:

; 17864: 	    switch (fac->type) {

	mov	eax, DWORD PTR [edx]
	sub	eax, 1006				; 000003eeH
	je	SHORT $LN10@xmlSchemaT
	sub	eax, 1
	je	SHORT $LN11@xmlSchemaT
	sub	eax, 1
	je	SHORT $LN2@xmlSchemaT

; 17876: 		default:
; 17877: 		    has = 1;

	mov	esi, 1
	jmp	SHORT $LN2@xmlSchemaT
$LN11@xmlSchemaT:

; 17870: 		    break;
; 17871: 		case XML_SCHEMA_FACET_ENUMERATION:
; 17872: 		    needVal = 1;

	mov	ebx, 1

; 17873: 		    normVal = 1;

	mov	edi, ebx

; 17874: 		    has = 1;

	mov	esi, ebx

; 17875: 		    break;

	jmp	SHORT $LN2@xmlSchemaT
$LN10@xmlSchemaT:

; 17865: 		case XML_SCHEMA_FACET_WHITESPACE:
; 17866: 		    break;
; 17867: 		case XML_SCHEMA_FACET_PATTERN:
; 17868: 		    normVal = 1;

	mov	edi, 1

; 17869: 		    has = 1;

	mov	esi, edi
$LN2@xmlSchemaT:

; 17861: 	xmlSchemaFacetPtr fac;
; 17862: 
; 17863: 	for (fac = type->facets; fac != NULL; fac = fac->next) {

	mov	edx, DWORD PTR [edx+4]
	test	edx, edx
	jne	SHORT $LL4@xmlSchemaT
$LN3@xmlSchemaT:

; 17878: 		    break;
; 17879: 	    }
; 17880: 	}
; 17881:     }
; 17882:     if (normVal)

	test	edi, edi
	je	SHORT $LN37@xmlSchemaT

; 17883: 	type->flags |= XML_SCHEMAS_TYPE_NORMVALUENEEDED;

	or	DWORD PTR [ecx+48], 268435456		; 10000000H
$LN37@xmlSchemaT:

; 17884:     if (needVal)

	test	ebx, ebx
	je	SHORT $LN38@xmlSchemaT

; 17885: 	type->flags |= XML_SCHEMAS_TYPE_FACETSNEEDVALUE;

	or	DWORD PTR [ecx+48], 2097152		; 00200000H
$LN38@xmlSchemaT:

; 17886:     if (has)

	test	esi, esi
	je	SHORT $LN17@xmlSchemaT

; 17887: 	type->flags |= XML_SCHEMAS_TYPE_HAS_FACETS;

	or	DWORD PTR [ecx+48], 134217728		; 08000000H
	lea	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]

; 17888: 
; 17889:     if (has && (! needVal) && WXS_IS_ATOMIC(type)) {

	test	ebx, ebx
	jne	SHORT $LN17@xmlSchemaT
	test	eax, 256				; 00000100H
	je	SHORT $LN17@xmlSchemaT
$LL20@xmlSchemaT:

; 13476: 	if ((type->builtInType == XML_SCHEMAS_ANYSIMPLETYPE) ||

	cmp	DWORD PTR [ecx+88], 46			; 0000002eH
	je	SHORT $LN27@xmlSchemaT
	test	DWORD PTR [ecx+48], 16384		; 00004000H
	jne	SHORT $LN27@xmlSchemaT

; 13477: 	   (type->flags & XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE))
; 13478: 	    return (type);
; 13479: 	type = type->baseType;

	mov	ecx, DWORD PTR [ecx+64]
	test	ecx, ecx
	jne	SHORT $LL20@xmlSchemaT
$LN27@xmlSchemaT:

; 17890: 	xmlSchemaTypePtr prim = xmlSchemaGetPrimitiveType(type);
; 17891: 	/*
; 17892: 	* OPTIMIZE VAL TODO: Some facets need a computed value.
; 17893: 	*/
; 17894: 	if ((prim->builtInType != XML_SCHEMAS_ANYSIMPLETYPE) &&

	mov	ecx, DWORD PTR [ecx+88]
	cmp	ecx, 46					; 0000002eH
	je	SHORT $LN17@xmlSchemaT
	cmp	ecx, 1
	je	SHORT $LN17@xmlSchemaT

; 17895: 	    (prim->builtInType != XML_SCHEMAS_STRING)) {
; 17896: 	    type->flags |= XML_SCHEMAS_TYPE_FACETSNEEDVALUE;

	or	eax, 2097152				; 00200000H
	mov	DWORD PTR [edx], eax
$LN17@xmlSchemaT:

; 17897: 	}
; 17898:     }
; 17899: }

	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaTypeFixupOptimFacets ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFinishMemberTypeDefinitionsProperty
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_lastLink$1$ = 12					; size = 4
_type$ = 12						; size = 4
_xmlSchemaFinishMemberTypeDefinitionsProperty PROC	; COMDAT

; 17800: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	mov	edi, DWORD PTR [eax+92]
	test	edi, edi
	je	$LN68@xmlSchemaF
	npad	2
$LL2@xmlSchemaF:

; 17801:     xmlSchemaTypeLinkPtr link, lastLink, prevLink, subLink, newLink;
; 17802:     /*
; 17803:     * The actual value is then formed by replacing any union type
; 17804:     * definition in the `explicit members` with the members of their
; 17805:     * {member type definitions}, in order.
; 17806:     *
; 17807:     * TODO: There's a bug entry at
; 17808:     * "http://lists.w3.org/Archives/Public/www-xml-schema-comments/2005JulSep/0287.html"
; 17809:     * which indicates that we'll keep the union types the future.
; 17810:     */
; 17811:     link = type->memberTypes;
; 17812:     while (link != NULL) {
; 17813: 
; 17814: 	if (WXS_IS_TYPE_NOT_FIXED(link->type))

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, ecx
	cmp	DWORD PTR [ecx], 1
	je	SHORT $LN6@xmlSchemaF
	test	DWORD PTR [ecx+48], 4194304		; 00400000H
	jne	SHORT $LN6@xmlSchemaF

; 17815: 	    xmlSchemaTypeFixup(link->type, ACTXT_CAST pctxt);

	push	DWORD PTR _pctxt$[ebp]
	push	ecx
	call	_xmlSchemaTypeFixup
	mov	eax, DWORD PTR [edi+4]
	add	esp, 8
$LN6@xmlSchemaF:

; 17816: 
; 17817: 	if (WXS_IS_UNION(link->type)) {

	test	BYTE PTR [eax+48], 128			; 00000080H
	je	SHORT $LN5@xmlSchemaF
$LL47@xmlSchemaF:

; 14670:     while ((type != NULL) && (type->type == XML_SCHEMA_TYPE_SIMPLE)) {

	cmp	DWORD PTR [eax], 4
	jne	SHORT $LN5@xmlSchemaF

; 14671: 	if (type->memberTypes != NULL)

	mov	esi, DWORD PTR [eax+92]
	test	esi, esi
	jne	SHORT $LN58@xmlSchemaF

; 14672: 	    return (type->memberTypes);
; 14673: 	else
; 14674: 	    type = type->baseType;

	mov	eax, DWORD PTR [eax+64]
	test	eax, eax
	jne	SHORT $LL47@xmlSchemaF

; 17827: 			    xmlMalloc(sizeof(xmlSchemaTypeLink));
; 17828: 			if (newLink == NULL) {

	jmp	SHORT $LN5@xmlSchemaF
$LN58@xmlSchemaF:

; 17818: 	    subLink = xmlSchemaGetUnionSimpleTypeMemberTypes(link->type);
; 17819: 	    if (subLink != NULL) {
; 17820: 		link->type = subLink->type;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], eax

; 17821: 		if (subLink->next != NULL) {

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	je	SHORT $LN5@xmlSchemaF

; 17822: 		    lastLink = link->next;

	mov	eax, DWORD PTR [edi]

; 17823: 		    subLink = subLink->next;
; 17824: 		    prevLink = link;

	mov	ebx, edi
	mov	DWORD PTR _lastLink$1$[ebp], eax
$LL4@xmlSchemaF:

; 17825: 		    while (subLink != NULL) {
; 17826: 			newLink = (xmlSchemaTypeLinkPtr)

	push	8
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 17827: 			    xmlMalloc(sizeof(xmlSchemaTypeLink));
; 17828: 			if (newLink == NULL) {

	test	eax, eax
	je	SHORT $LN59@xmlSchemaF

; 17832: 			}
; 17833: 			newLink->type = subLink->type;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx

; 17834: 			prevLink->next = newLink;
; 17835: 			prevLink = newLink;
; 17836: 			newLink->next = lastLink;

	mov	ecx, DWORD PTR _lastLink$1$[ebp]
	mov	DWORD PTR [ebx], eax
	mov	ebx, eax
	mov	DWORD PTR [eax], ecx

; 17837: 
; 17838: 			subLink = subLink->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL4@xmlSchemaF
$LN5@xmlSchemaF:

; 17839: 		    }
; 17840: 		}
; 17841: 	    }
; 17842: 	}
; 17843: 	link = link->next;

	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	SHORT $LL2@xmlSchemaF
$LN68@xmlSchemaF:
	pop	edi

; 17844:     }
; 17845:     return (0);
; 17846: }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN59@xmlSchemaF:

; 1884 :     if (ctxt != NULL)

	mov	eax, DWORD PTR _pctxt$[ebp]
	test	eax, eax
	je	SHORT $LN53@xmlSchemaF

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [eax+20]
$LN53@xmlSchemaF:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BH@ENHIIAOL@allocating?5a?5type?5link@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 17829: 			    xmlSchemaPErrMemory(pctxt, "allocating a type link",
; 17830: 				NULL);
; 17831: 			    return (-1);

	or	eax, -1
	pop	edi

; 17844:     }
; 17845:     return (0);
; 17846: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaFinishMemberTypeDefinitionsProperty ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaDeriveAndValidateFacets
_TEXT	SEGMENT
_bfacet$1$ = -76					; size = 4
_base$1$ = -76						; size = 4
_last$1$ = -72						; size = 4
_bftotdig$1$ = -68					; size = 4
_bffracdig$1$ = -64					; size = 4
_fmininc$1$ = -60					; size = 4
_ffracdig$1$ = -56					; size = 4
_ftotdig$1$ = -52					; size = 4
_bfmaxlen$1$ = -48					; size = 4
_bfminlen$1$ = -44					; size = 4
_flength$1$ = -40					; size = 4
_fmaxlen$1$ = -36					; size = 4
_fminlen$1$ = -32					; size = 4
_fminexc$1$ = -28					; size = 4
_bfmaxexc$1$ = -24					; size = 4
_bfminexc$1$ = -20					; size = 4
_bfmaxinc$1$ = -16					; size = 4
_bfmininc$1$ = -12					; size = 4
_bflength$1$ = -8					; size = 4
_fmaxexc$1$ = -4					; size = 4
_pctxt$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlSchemaDeriveAndValidateFacets PROC			; COMDAT

; 17261: {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _type$[ebp]
	xor	edx, edx
	xor	edi, edi
	mov	DWORD PTR _fmininc$1$[ebp], edx
	xor	ebx, ebx
	mov	DWORD PTR _flength$1$[ebp], edi
	mov	DWORD PTR _ftotdig$1$[ebp], edi
	mov	eax, DWORD PTR [esi+64]
	mov	esi, DWORD PTR [esi+96]
	mov	DWORD PTR _base$1$[ebp], eax
	mov	DWORD PTR _ffracdig$1$[ebp], edi
	mov	DWORD PTR _fmaxlen$1$[ebp], edi
	mov	DWORD PTR _fminlen$1$[ebp], edi
	mov	DWORD PTR _fminexc$1$[ebp], edx
	mov	DWORD PTR _fmaxexc$1$[ebp], edx
	mov	DWORD PTR _bflength$1$[ebp], edx
	mov	DWORD PTR _bftotdig$1$[ebp], edx
	mov	DWORD PTR _bffracdig$1$[ebp], edx
	mov	DWORD PTR _bfmaxlen$1$[ebp], edx
	mov	DWORD PTR _bfminlen$1$[ebp], edx
	mov	DWORD PTR _bfmininc$1$[ebp], edx
	mov	DWORD PTR _bfmaxinc$1$[ebp], edx
	mov	DWORD PTR _bfminexc$1$[ebp], edx
	mov	DWORD PTR _bfmaxexc$1$[ebp], edx
	test	esi, esi
	jne	SHORT $LN529@xmlSchemaD

; 17262:     xmlSchemaTypePtr base = type->baseType;
; 17263:     xmlSchemaFacetLinkPtr link, cur, last = NULL;
; 17264:     xmlSchemaFacetPtr facet, bfacet,
; 17265: 	flength = NULL, ftotdig = NULL, ffracdig = NULL,
; 17266: 	fmaxlen = NULL, fminlen = NULL, /* facets of the current type */
; 17267: 	fmininc = NULL, fmaxinc = NULL,
; 17268: 	fminexc = NULL, fmaxexc = NULL,
; 17269: 	bflength = NULL, bftotdig = NULL, bffracdig = NULL,
; 17270: 	bfmaxlen = NULL, bfminlen = NULL, /* facets of the base type */
; 17271: 	bfmininc = NULL, bfmaxinc = NULL,
; 17272: 	bfminexc = NULL, bfmaxexc = NULL;
; 17273:     int res; /* err = 0, fixedErr; */
; 17274: 
; 17275:     /*
; 17276:     * SPEC st-restrict-facets 1:
; 17277:     * "The {variety} of R is the same as that of B."
; 17278:     */
; 17279:     /*
; 17280:     * SPEC st-restrict-facets 2:
; 17281:     * "If {variety} is atomic, the {primitive type definition}
; 17282:     * of R is the same as that of B."
; 17283:     *
; 17284:     * NOTE: we leave 1 & 2 out for now, since this will be
; 17285:     * satisfied by the derivation process.
; 17286:     * CONSTRUCTION TODO: Maybe needed if using a construction API.
; 17287:     */
; 17288:     /*
; 17289:     * SPEC st-restrict-facets 3:
; 17290:     * "The {facets} of R are the union of S and the {facets}
; 17291:     * of B, eliminating duplicates. To eliminate duplicates,
; 17292:     * when a facet of the same kind occurs in both S and the
; 17293:     * {facets} of B, the one in the {facets} of B is not
; 17294:     * included, with the exception of enumeration and pattern
; 17295:     * facets, for which multiple occurrences with distinct values
; 17296:     * are allowed."
; 17297:     */
; 17298: 
; 17299:     if ((type->facetSet == NULL) && (base->facetSet == NULL))

	cmp	DWORD PTR [eax+96], edx
	je	$LN530@xmlSchemaD
$LN529@xmlSchemaD:

; 17300: 	return (0);
; 17301: 
; 17302:     last = type->facetSet;

	mov	edx, esi
	mov	ecx, esi
	mov	DWORD PTR _last$1$[ebp], edx

; 17303:     if (last != NULL)

	test	edx, edx
	je	SHORT $LN3@xmlSchemaD

; 17304: 	while (last->next != NULL)

	mov	edx, DWORD PTR [edx]
	test	edx, edx
	je	SHORT $LN3@xmlSchemaD
$LL2@xmlSchemaD:
	mov	eax, DWORD PTR [edx]

; 17305: 	    last = last->next;

	mov	DWORD PTR _last$1$[ebp], edx
	mov	edx, eax
	test	eax, eax
	jne	SHORT $LL2@xmlSchemaD
$LN3@xmlSchemaD:

; 17306: 
; 17307:     for (cur = type->facetSet; cur != NULL; cur = cur->next) {

	test	ecx, ecx
	je	SHORT $LN5@xmlSchemaD
$LL6@xmlSchemaD:

; 17308: 	facet = cur->facet;

	mov	edx, DWORD PTR [ecx+4]

; 17309: 	switch (facet->type) {

	mov	eax, DWORD PTR [edx]
	add	eax, -1000				; fffffc18H
	cmp	eax, 11					; 0000000bH
	ja	SHORT $LN4@xmlSchemaD
	jmp	DWORD PTR $LN546@xmlSchemaD[eax*4]
$LN23@xmlSchemaD:

; 17310: 	    case XML_SCHEMA_FACET_LENGTH:
; 17311: 		flength = facet; break;

	mov	edi, edx
	jmp	SHORT $LN4@xmlSchemaD
$LN24@xmlSchemaD:

; 17312: 	    case XML_SCHEMA_FACET_MINLENGTH:
; 17313: 		fminlen = facet; break;

	mov	DWORD PTR _fminlen$1$[ebp], edx
	jmp	SHORT $LN4@xmlSchemaD
$LN25@xmlSchemaD:

; 17314: 	    case XML_SCHEMA_FACET_MININCLUSIVE:
; 17315: 		fmininc = facet; break;

	mov	DWORD PTR _fmininc$1$[ebp], edx
	jmp	SHORT $LN4@xmlSchemaD
$LN26@xmlSchemaD:

; 17316: 	    case XML_SCHEMA_FACET_MINEXCLUSIVE:
; 17317: 		fminexc = facet; break;

	mov	DWORD PTR _fminexc$1$[ebp], edx
	jmp	SHORT $LN4@xmlSchemaD
$LN27@xmlSchemaD:

; 17318: 	    case XML_SCHEMA_FACET_MAXLENGTH:
; 17319: 		fmaxlen = facet; break;

	mov	DWORD PTR _fmaxlen$1$[ebp], edx
	jmp	SHORT $LN4@xmlSchemaD
$LN28@xmlSchemaD:

; 17320: 	    case XML_SCHEMA_FACET_MAXINCLUSIVE:
; 17321: 		fmaxinc = facet; break;

	mov	ebx, edx
	jmp	SHORT $LN4@xmlSchemaD
$LN29@xmlSchemaD:

; 17322: 	    case XML_SCHEMA_FACET_MAXEXCLUSIVE:
; 17323: 		fmaxexc = facet; break;

	mov	DWORD PTR _fmaxexc$1$[ebp], edx
	jmp	SHORT $LN4@xmlSchemaD
$LN30@xmlSchemaD:

; 17324: 	    case XML_SCHEMA_FACET_TOTALDIGITS:
; 17325: 		ftotdig = facet; break;

	mov	DWORD PTR _ftotdig$1$[ebp], edx
	jmp	SHORT $LN4@xmlSchemaD
$LN31@xmlSchemaD:

; 17326: 	    case XML_SCHEMA_FACET_FRACTIONDIGITS:
; 17327: 		ffracdig = facet; break;

	mov	DWORD PTR _ffracdig$1$[ebp], edx
$LN4@xmlSchemaD:

; 17306: 
; 17307:     for (cur = type->facetSet; cur != NULL; cur = cur->next) {

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $LL6@xmlSchemaD
	mov	DWORD PTR _flength$1$[ebp], edi
$LN5@xmlSchemaD:

; 17328: 	    default:
; 17329: 		break;
; 17330: 	}
; 17331:     }
; 17332:     for (cur = base->facetSet; cur != NULL; cur = cur->next) {

	mov	ecx, DWORD PTR _base$1$[ebp]
	mov	ecx, DWORD PTR [ecx+96]
	test	ecx, ecx
	je	SHORT $LN10@xmlSchemaD
	npad	9
$LL11@xmlSchemaD:

; 17333: 	facet = cur->facet;

	mov	edx, DWORD PTR [ecx+4]

; 17334: 	switch (facet->type) {

	mov	eax, DWORD PTR [edx]
	add	eax, -1000				; fffffc18H
	cmp	eax, 11					; 0000000bH
	ja	SHORT $LN9@xmlSchemaD
	jmp	DWORD PTR $LN547@xmlSchemaD[eax*4]
$LN33@xmlSchemaD:

; 17335: 	    case XML_SCHEMA_FACET_LENGTH:
; 17336: 		bflength = facet; break;

	mov	DWORD PTR _bflength$1$[ebp], edx
	jmp	SHORT $LN9@xmlSchemaD
$LN34@xmlSchemaD:

; 17337: 	    case XML_SCHEMA_FACET_MINLENGTH:
; 17338: 		bfminlen = facet; break;

	mov	DWORD PTR _bfminlen$1$[ebp], edx
	jmp	SHORT $LN9@xmlSchemaD
$LN35@xmlSchemaD:

; 17339: 	    case XML_SCHEMA_FACET_MININCLUSIVE:
; 17340: 		bfmininc = facet; break;

	mov	DWORD PTR _bfmininc$1$[ebp], edx
	jmp	SHORT $LN9@xmlSchemaD
$LN36@xmlSchemaD:

; 17341: 	    case XML_SCHEMA_FACET_MINEXCLUSIVE:
; 17342: 		bfminexc = facet; break;

	mov	DWORD PTR _bfminexc$1$[ebp], edx
	jmp	SHORT $LN9@xmlSchemaD
$LN37@xmlSchemaD:

; 17343: 	    case XML_SCHEMA_FACET_MAXLENGTH:
; 17344: 		bfmaxlen = facet; break;

	mov	DWORD PTR _bfmaxlen$1$[ebp], edx
	jmp	SHORT $LN9@xmlSchemaD
$LN38@xmlSchemaD:

; 17345: 	    case XML_SCHEMA_FACET_MAXINCLUSIVE:
; 17346: 		bfmaxinc = facet; break;

	mov	DWORD PTR _bfmaxinc$1$[ebp], edx
	jmp	SHORT $LN9@xmlSchemaD
$LN39@xmlSchemaD:

; 17347: 	    case XML_SCHEMA_FACET_MAXEXCLUSIVE:
; 17348: 		bfmaxexc = facet; break;

	mov	DWORD PTR _bfmaxexc$1$[ebp], edx
	jmp	SHORT $LN9@xmlSchemaD
$LN40@xmlSchemaD:

; 17349: 	    case XML_SCHEMA_FACET_TOTALDIGITS:
; 17350: 		bftotdig = facet; break;

	mov	DWORD PTR _bftotdig$1$[ebp], edx
	jmp	SHORT $LN9@xmlSchemaD
$LN41@xmlSchemaD:

; 17351: 	    case XML_SCHEMA_FACET_FRACTIONDIGITS:
; 17352: 		bffracdig = facet; break;

	mov	DWORD PTR _bffracdig$1$[ebp], edx
$LN9@xmlSchemaD:

; 17328: 	    default:
; 17329: 		break;
; 17330: 	}
; 17331:     }
; 17332:     for (cur = base->facetSet; cur != NULL; cur = cur->next) {

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $LL11@xmlSchemaD
$LN10@xmlSchemaD:

; 17353: 	    default:
; 17354: 		break;
; 17355: 	}
; 17356:     }
; 17357:     /*
; 17358:     * length and minLength or maxLength (2.2) + (3.2)
; 17359:     */
; 17360:     if (flength && (fminlen || fmaxlen)) {

	test	edi, edi
	mov	edi, DWORD PTR _pctxt$[ebp]
	je	SHORT $LN162@xmlSchemaD
	cmp	DWORD PTR _fminlen$1$[ebp], 0
	jne	SHORT $LN44@xmlSchemaD
	cmp	DWORD PTR _fmaxlen$1$[ebp], 0
	je	SHORT $LN162@xmlSchemaD
$LN44@xmlSchemaD:

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	mov	eax, DWORD PTR _flength$1$[ebp]
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0HG@KJDGAKFE@It?5is?5an?5error?5for?5both?5?8length@
	push	DWORD PTR [eax+20]
	push	eax
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
$LN162@xmlSchemaD:

; 17361: 	FACET_RESTR_ERR(flength, "It is an error for both 'length' and "
; 17362: 	    "either of 'minLength' or 'maxLength' to be specified on "
; 17363: 	    "the same type definition")
; 17364:     }
; 17365:     /*
; 17366:     * Mutual exclusions in the same derivation step.
; 17367:     */
; 17368:     if ((fmaxinc) && (fmaxexc)) {

	test	ebx, ebx
	je	SHORT $LN45@xmlSchemaD
	mov	eax, DWORD PTR _fmaxexc$1$[ebp]
	test	eax, eax
	je	SHORT $LN45@xmlSchemaD

; 17369: 	/*
; 17370: 	* SCC "maxInclusive and maxExclusive"
; 17371: 	*/
; 17372: 	FACET_RESTR_MUTUAL_ERR(fmaxinc, fmaxexc)

	push	0
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	add	esp, 4
	push	eax
	push	DWORD PTR [ebx]
	call	_xmlSchemaFacetTypeToString
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0FC@EFACGABJ@It?5is?5an?5error?5for?5both?5?8?$CFs?8?5an@
	push	DWORD PTR [ebx+20]
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
$LN45@xmlSchemaD:

; 17373:     }
; 17374:     if ((fmininc) && (fminexc)) {

	mov	esi, DWORD PTR _fmininc$1$[ebp]
	test	esi, esi
	je	SHORT $LN46@xmlSchemaD
	mov	eax, DWORD PTR _fminexc$1$[ebp]
	test	eax, eax
	je	SHORT $LN46@xmlSchemaD

; 17375: 	/*
; 17376: 	* SCC "minInclusive and minExclusive"
; 17377: 	*/
; 17378: 	FACET_RESTR_MUTUAL_ERR(fmininc, fminexc)

	push	0
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	add	esp, 4
	push	eax
	push	DWORD PTR [esi]
	call	_xmlSchemaFacetTypeToString
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0FC@EFACGABJ@It?5is?5an?5error?5for?5both?5?8?$CFs?8?5an@
	push	DWORD PTR [esi+20]
	push	esi
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
$LN46@xmlSchemaD:

; 17379:     }
; 17380: 
; 17381:     if (flength && bflength) {

	mov	esi, DWORD PTR _flength$1$[ebp]
	test	esi, esi
	je	$LN175@xmlSchemaD
	mov	eax, DWORD PTR _bflength$1$[ebp]
	test	eax, eax
	je	$LN175@xmlSchemaD

; 17382: 	/*
; 17383: 	* SCC "length valid restriction"
; 17384: 	* The values have to be equal.
; 17385: 	*/
; 17386: 	res = xmlSchemaCompareValues(flength->val, bflength->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [esi+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17387: 	if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17388: 	    goto internal_error;
; 17389: 	if (res != 0)

	test	eax, eax
	je	$LN175@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup
	mov	esi, eax

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	mov	eax, DWORD PTR _flength$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17227:     if (lessGreater == 0)
; 17228: 	msg = xmlStrcat(msg, BAD_CAST " equal to");

	push	OFFSET ??_C@_09BFLDGAFJ@?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17231:     else
; 17232: 	msg = xmlStrcat(msg, BAD_CAST " less than");

	push	OFFSET ??_C@_0L@HHJDMGPP@?5less?5than@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bflength$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	DWORD PTR _flength$1$[ebp]
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN171@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN171@xmlSchemaD:

; 17390: 	    xmlSchemaDeriveFacetErr(pctxt, flength, bflength, 0, 0, 1);
; 17391: 	if ((res != 0) && (bflength->fixed)) {

	mov	eax, DWORD PTR _bflength$1$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN175@xmlSchemaD

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	mov	esi, DWORD PTR _flength$1$[ebp]
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0EB@JECLPMKG@The?5base?5type?8s?5facet?5is?5?8fixed@
	push	DWORD PTR [esi+20]
	push	esi
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
$LN175@xmlSchemaD:

; 17392: 	    FACET_RESTR_FIXED_ERR(flength)
; 17393: 	}
; 17394: 
; 17395:     }
; 17396:     if (fminlen && bfminlen) {

	mov	esi, DWORD PTR _fminlen$1$[ebp]
	test	esi, esi
	je	$LN188@xmlSchemaD
	mov	eax, DWORD PTR _bfminlen$1$[ebp]
	test	eax, eax
	je	$LN188@xmlSchemaD

; 17397: 	/*
; 17398: 	* SCC "minLength valid restriction"
; 17399: 	* minLength >= BASE minLength
; 17400: 	*/
; 17401: 	res = xmlSchemaCompareValues(fminlen->val, bfminlen->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [esi+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17402: 	if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17403: 	    goto internal_error;
; 17404: 	if (res == -1)

	cmp	eax, -1
	jne	$LN184@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup
	mov	esi, eax

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	mov	eax, DWORD PTR _fminlen$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17229:     if (lessGreater == 1)
; 17230: 	msg = xmlStrcat(msg, BAD_CAST " greater than");

	push	OFFSET ??_C@_0O@EOMDOOFG@?5greater?5than@
	push	eax
	call	_xmlStrcat

; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfminlen$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	DWORD PTR _fminlen$1$[ebp]
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN539@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN539@xmlSchemaD:

; 17405: 	    xmlSchemaDeriveFacetErr(pctxt, fminlen, bfminlen, 1, 1, 1);
; 17406: 	if ((res != 0) && (bfminlen->fixed)) {

	mov	esi, DWORD PTR _fminlen$1$[ebp]
$LN521@xmlSchemaD:
	mov	eax, DWORD PTR _bfminlen$1$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN188@xmlSchemaD

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0EB@JECLPMKG@The?5base?5type?8s?5facet?5is?5?8fixed@
	push	DWORD PTR [esi+20]
	push	esi
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
$LN188@xmlSchemaD:

; 17407: 	    FACET_RESTR_FIXED_ERR(fminlen)
; 17408: 	}
; 17409:     }
; 17410:     if (fmaxlen && bfmaxlen) {

	mov	esi, DWORD PTR _fmaxlen$1$[ebp]
	test	esi, esi
	je	$LN201@xmlSchemaD
	mov	eax, DWORD PTR _bfmaxlen$1$[ebp]
	test	eax, eax
	je	$LN201@xmlSchemaD

; 17411: 	/*
; 17412: 	* SCC "maxLength valid restriction"
; 17413: 	* maxLength <= BASE minLength
; 17414: 	*/
; 17415: 	res = xmlSchemaCompareValues(fmaxlen->val, bfmaxlen->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [esi+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17416: 	if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17417: 	    goto internal_error;
; 17418: 	if (res == 1)

	cmp	eax, 1
	jne	$LN197@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup
	mov	esi, eax

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	mov	eax, DWORD PTR _fmaxlen$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17231:     else
; 17232: 	msg = xmlStrcat(msg, BAD_CAST " less than");

	push	OFFSET ??_C@_0L@HHJDMGPP@?5less?5than@
	push	eax
	call	_xmlStrcat

; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfmaxlen$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	DWORD PTR _fmaxlen$1$[ebp]
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN540@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN540@xmlSchemaD:

; 17419: 	    xmlSchemaDeriveFacetErr(pctxt, fmaxlen, bfmaxlen, -1, 1, 1);
; 17420: 	if ((res != 0) && (bfmaxlen->fixed)) {

	mov	esi, DWORD PTR _fmaxlen$1$[ebp]
$LN522@xmlSchemaD:
	mov	eax, DWORD PTR _bfmaxlen$1$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN201@xmlSchemaD

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0EB@JECLPMKG@The?5base?5type?8s?5facet?5is?5?8fixed@
	push	DWORD PTR [esi+20]
	push	esi
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
$LN201@xmlSchemaD:

; 17421: 	    FACET_RESTR_FIXED_ERR(fmaxlen)
; 17422: 	}
; 17423:     }
; 17424:     /*
; 17425:     * SCC "length and minLength or maxLength"
; 17426:     */
; 17427:     if (! flength)
; 17428: 	flength = bflength;
; 17429:     if (flength) {

	mov	eax, DWORD PTR _flength$1$[ebp]
	test	eax, eax
	mov	ecx, DWORD PTR _bflength$1$[ebp]
	cmovne	ecx, eax
	mov	DWORD PTR _bflength$1$[ebp], ecx
	test	ecx, ecx
	je	$LN221@xmlSchemaD

; 17430: 	if (! fminlen)
; 17431: 	    fminlen = bfminlen;
; 17432: 	if (fminlen) {

	mov	eax, DWORD PTR _fminlen$1$[ebp]
	test	eax, eax
	mov	edx, DWORD PTR _bfminlen$1$[ebp]
	cmovne	edx, eax
	mov	DWORD PTR _bfminlen$1$[ebp], edx
	test	edx, edx
	je	$LN210@xmlSchemaD

; 17433: 	    /* (1.1) length >= minLength */
; 17434: 	    res = xmlSchemaCompareValues(flength->val, fminlen->val);

	push	DWORD PTR [edx+32]
	push	DWORD PTR [ecx+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17435: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17436: 		goto internal_error;
; 17437: 	    if (res == -1)

	cmp	eax, -1
	jne	$LN538@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup
	mov	esi, eax

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	mov	eax, DWORD PTR _bflength$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17229:     if (lessGreater == 1)
; 17230: 	msg = xmlStrcat(msg, BAD_CAST " greater than");

	push	OFFSET ??_C@_0O@EOMDOOFG@?5greater?5than@
	push	eax
	call	_xmlStrcat

; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfminlen$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17240:     else
; 17241: 	msg = xmlStrcat(msg, BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	DWORD PTR _bflength$1$[ebp]
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN538@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN538@xmlSchemaD:

; 17438: 		xmlSchemaDeriveFacetErr(pctxt, flength, fminlen, 1, 1, 0);
; 17439: 	}
; 17440: 	if (! fmaxlen)
; 17441: 	    fmaxlen = bfmaxlen;
; 17442: 	if (fmaxlen) {

	mov	ecx, DWORD PTR _bflength$1$[ebp]
$LN210@xmlSchemaD:
	mov	edx, DWORD PTR _fmaxlen$1$[ebp]
	test	edx, edx
	mov	eax, DWORD PTR _bfmaxlen$1$[ebp]
	cmovne	eax, edx
	mov	DWORD PTR _bfmaxlen$1$[ebp], eax
	test	eax, eax
	je	$LN221@xmlSchemaD

; 17443: 	    /* (2.1) length <= maxLength */
; 17444: 	    res = xmlSchemaCompareValues(flength->val, fmaxlen->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [ecx+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17445: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17446: 		goto internal_error;
; 17447: 	    if (res == 1)

	cmp	eax, 1
	jne	$LN221@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup
	mov	esi, eax

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	mov	eax, DWORD PTR _bflength$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17231:     else
; 17232: 	msg = xmlStrcat(msg, BAD_CAST " less than");

	push	OFFSET ??_C@_0L@HHJDMGPP@?5less?5than@
	push	eax
	call	_xmlStrcat

; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfmaxlen$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17240:     else
; 17241: 	msg = xmlStrcat(msg, BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	DWORD PTR _bflength$1$[ebp]
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN221@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN221@xmlSchemaD:

; 17448: 		xmlSchemaDeriveFacetErr(pctxt, flength, fmaxlen, -1, 1, 0);
; 17449: 	}
; 17450:     }
; 17451:     if (fmaxinc) {

	test	ebx, ebx
	je	$LN278@xmlSchemaD

; 17452: 	/*
; 17453: 	* "maxInclusive"
; 17454: 	*/
; 17455: 	if (fmininc) {

	mov	eax, DWORD PTR _fmininc$1$[ebp]
	test	eax, eax
	je	$LN232@xmlSchemaD

; 17456: 	    /* SCC "maxInclusive >= minInclusive" */
; 17457: 	    res = xmlSchemaCompareValues(fmaxinc->val, fmininc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [ebx+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17458: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17459: 		goto internal_error;
; 17460: 	    if (res == -1) {

	cmp	eax, -1
	jne	$LN232@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	push	DWORD PTR [ebx]
	mov	esi, eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17229:     if (lessGreater == 1)
; 17230: 	msg = xmlStrcat(msg, BAD_CAST " greater than");

	push	OFFSET ??_C@_0O@EOMDOOFG@?5greater?5than@
	push	eax
	call	_xmlStrcat

; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	edx, DWORD PTR _fmininc$1$[ebp]
	mov	esi, eax
	push	DWORD PTR [edx]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17240:     else
; 17241: 	msg = xmlStrcat(msg, BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN232@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN232@xmlSchemaD:

; 17461: 		xmlSchemaDeriveFacetErr(pctxt, fmaxinc, fmininc, 1, 1, 0);
; 17462: 	    }
; 17463: 	}
; 17464: 	/*
; 17465: 	* SCC "maxInclusive valid restriction"
; 17466: 	*/
; 17467: 	if (bfmaxinc) {

	mov	eax, DWORD PTR _bfmaxinc$1$[ebp]
	test	eax, eax
	je	$LN247@xmlSchemaD

; 17468: 	    /* maxInclusive <= BASE maxInclusive */
; 17469: 	    res = xmlSchemaCompareValues(fmaxinc->val, bfmaxinc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [ebx+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17470: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17471: 		goto internal_error;
; 17472: 	    if (res == 1)

	cmp	eax, 1
	jne	$LN243@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	push	DWORD PTR [ebx]
	mov	esi, eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17231:     else
; 17232: 	msg = xmlStrcat(msg, BAD_CAST " less than");

	push	OFFSET ??_C@_0L@HHJDMGPP@?5less?5than@
	push	eax
	call	_xmlStrcat

; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfmaxinc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN523@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 17473: 		xmlSchemaDeriveFacetErr(pctxt, fmaxinc, bfmaxinc, -1, 1, 1);
; 17474: 	    if ((res != 0) && (bfmaxinc->fixed)) {

	jmp	SHORT $LN523@xmlSchemaD
$LN184@xmlSchemaD:

; 17405: 	    xmlSchemaDeriveFacetErr(pctxt, fminlen, bfminlen, 1, 1, 1);
; 17406: 	if ((res != 0) && (bfminlen->fixed)) {

	test	eax, eax
	je	$LN188@xmlSchemaD

; 17248:     if (msg != NULL)

	jmp	$LN521@xmlSchemaD
$LN197@xmlSchemaD:

; 17419: 	    xmlSchemaDeriveFacetErr(pctxt, fmaxlen, bfmaxlen, -1, 1, 1);
; 17420: 	if ((res != 0) && (bfmaxlen->fixed)) {

	test	eax, eax
	je	$LN201@xmlSchemaD

; 17248:     if (msg != NULL)

	jmp	$LN522@xmlSchemaD
$LN243@xmlSchemaD:

; 17473: 		xmlSchemaDeriveFacetErr(pctxt, fmaxinc, bfmaxinc, -1, 1, 1);
; 17474: 	    if ((res != 0) && (bfmaxinc->fixed)) {

	test	eax, eax
	je	SHORT $LN247@xmlSchemaD
$LN523@xmlSchemaD:
	mov	eax, DWORD PTR _bfmaxinc$1$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN247@xmlSchemaD

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0EB@JECLPMKG@The?5base?5type?8s?5facet?5is?5?8fixed@
	push	DWORD PTR [ebx+20]
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
$LN247@xmlSchemaD:

; 17475: 		FACET_RESTR_FIXED_ERR(fmaxinc)
; 17476: 	    }
; 17477: 	}
; 17478: 	if (bfmaxexc) {

	mov	eax, DWORD PTR _bfmaxexc$1$[ebp]
	test	eax, eax
	je	$LN256@xmlSchemaD

; 17479: 	    /* maxInclusive < BASE maxExclusive */
; 17480: 	    res = xmlSchemaCompareValues(fmaxinc->val, bfmaxexc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [ebx+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17481: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17482: 		goto internal_error;
; 17483: 	    if (res != -1) {

	cmp	eax, -1
	je	$LN256@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	push	DWORD PTR [ebx]
	mov	esi, eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17231:     else
; 17232: 	msg = xmlStrcat(msg, BAD_CAST " less than");

	push	OFFSET ??_C@_0L@HHJDMGPP@?5less?5than@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfmaxexc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0

; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	esi
	push	0
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 92					; 0000005cH

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN256@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN256@xmlSchemaD:

; 17484: 		xmlSchemaDeriveFacetErr(pctxt, fmaxinc, bfmaxexc, -1, 0, 1);
; 17485: 	    }
; 17486: 	}
; 17487: 	if (bfmininc) {

	mov	eax, DWORD PTR _bfmininc$1$[ebp]
	test	eax, eax
	je	$LN267@xmlSchemaD

; 17488: 	    /* maxInclusive >= BASE minInclusive */
; 17489: 	    res = xmlSchemaCompareValues(fmaxinc->val, bfmininc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [ebx+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17490: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17491: 		goto internal_error;
; 17492: 	    if (res == -1) {

	cmp	eax, -1
	jne	$LN267@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	push	DWORD PTR [ebx]
	mov	esi, eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17229:     if (lessGreater == 1)
; 17230: 	msg = xmlStrcat(msg, BAD_CAST " greater than");

	push	OFFSET ??_C@_0O@EOMDOOFG@?5greater?5than@
	push	eax
	call	_xmlStrcat

; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfmininc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN267@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN267@xmlSchemaD:

; 17493: 		xmlSchemaDeriveFacetErr(pctxt, fmaxinc, bfmininc, 1, 1, 1);
; 17494: 	    }
; 17495: 	}
; 17496: 	if (bfminexc) {

	mov	eax, DWORD PTR _bfminexc$1$[ebp]
	test	eax, eax
	je	$LN278@xmlSchemaD

; 17497: 	    /* maxInclusive > BASE minExclusive */
; 17498: 	    res = xmlSchemaCompareValues(fmaxinc->val, bfminexc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [ebx+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17499: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17500: 		goto internal_error;
; 17501: 	    if (res != 1) {

	cmp	eax, 1
	je	$LN278@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	push	DWORD PTR [ebx]
	mov	esi, eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17229:     if (lessGreater == 1)
; 17230: 	msg = xmlStrcat(msg, BAD_CAST " greater than");

	push	OFFSET ??_C@_0O@EOMDOOFG@?5greater?5than@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfminexc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0

; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	esi
	push	0
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 92					; 0000005cH

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN278@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN278@xmlSchemaD:

; 17502: 		xmlSchemaDeriveFacetErr(pctxt, fmaxinc, bfminexc, 1, 0, 1);
; 17503: 	    }
; 17504: 	}
; 17505:     }
; 17506:     if (fmaxexc) {

	mov	esi, DWORD PTR _fmaxexc$1$[ebp]
	test	esi, esi
	je	$LN335@xmlSchemaD

; 17507: 	/*
; 17508: 	* "maxExclusive >= minExclusive"
; 17509: 	*/
; 17510: 	if (fminexc) {

	mov	eax, DWORD PTR _fminexc$1$[ebp]
	test	eax, eax
	je	$LN289@xmlSchemaD

; 17511: 	    res = xmlSchemaCompareValues(fmaxexc->val, fminexc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [esi+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17512: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17513: 		goto internal_error;
; 17514: 	    if (res == -1) {

	cmp	eax, -1
	jne	$LN289@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup
	mov	esi, eax

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	mov	eax, DWORD PTR _fmaxexc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17229:     if (lessGreater == 1)
; 17230: 	msg = xmlStrcat(msg, BAD_CAST " greater than");

	push	OFFSET ??_C@_0O@EOMDOOFG@?5greater?5than@
	push	eax
	call	_xmlStrcat

; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	edx, DWORD PTR _fminexc$1$[ebp]
	mov	esi, eax
	push	DWORD PTR [edx]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17240:     else
; 17241: 	msg = xmlStrcat(msg, BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	DWORD PTR _fmaxexc$1$[ebp]
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN536@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN536@xmlSchemaD:

; 17515: 		xmlSchemaDeriveFacetErr(pctxt, fmaxexc, fminexc, 1, 1, 0);
; 17516: 	    }
; 17517: 	}
; 17518: 	/*
; 17519: 	* "maxExclusive valid restriction"
; 17520: 	*/
; 17521: 	if (bfmaxexc) {

	mov	esi, DWORD PTR _fmaxexc$1$[ebp]
$LN289@xmlSchemaD:
	mov	eax, DWORD PTR _bfmaxexc$1$[ebp]
	test	eax, eax
	je	$LN304@xmlSchemaD

; 17522: 	    /* maxExclusive <= BASE maxExclusive */
; 17523: 	    res = xmlSchemaCompareValues(fmaxexc->val, bfmaxexc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [esi+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17524: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17525: 		goto internal_error;
; 17526: 	    if (res == 1) {

	cmp	eax, 1
	jne	$LN300@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup
	mov	esi, eax

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	mov	eax, DWORD PTR _fmaxexc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17231:     else
; 17232: 	msg = xmlStrcat(msg, BAD_CAST " less than");

	push	OFFSET ??_C@_0L@HHJDMGPP@?5less?5than@
	push	eax
	call	_xmlStrcat

; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfmaxexc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	DWORD PTR _fmaxexc$1$[ebp]
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN535@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN535@xmlSchemaD:

; 17527: 		xmlSchemaDeriveFacetErr(pctxt, fmaxexc, bfmaxexc, -1, 1, 1);
; 17528: 	    }
; 17529: 	    if ((res != 0) && (bfmaxexc->fixed)) {

	mov	esi, DWORD PTR _fmaxexc$1$[ebp]
$LN524@xmlSchemaD:
	mov	eax, DWORD PTR _bfmaxexc$1$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN304@xmlSchemaD

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0EB@JECLPMKG@The?5base?5type?8s?5facet?5is?5?8fixed@
	push	DWORD PTR [esi+20]
	push	esi
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
$LN304@xmlSchemaD:

; 17530: 		FACET_RESTR_FIXED_ERR(fmaxexc)
; 17531: 	    }
; 17532: 	}
; 17533: 	if (bfmaxinc) {

	mov	eax, DWORD PTR _bfmaxinc$1$[ebp]
	test	eax, eax
	je	$LN313@xmlSchemaD

; 17534: 	    /* maxExclusive <= BASE maxInclusive */
; 17535: 	    res = xmlSchemaCompareValues(fmaxexc->val, bfmaxinc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [esi+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17536: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17537: 		goto internal_error;
; 17538: 	    if (res == 1) {

	cmp	eax, 1
	jne	$LN313@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup
	mov	esi, eax

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	mov	eax, DWORD PTR _fmaxexc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17231:     else
; 17232: 	msg = xmlStrcat(msg, BAD_CAST " less than");

	push	OFFSET ??_C@_0L@HHJDMGPP@?5less?5than@
	push	eax
	call	_xmlStrcat

; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfmaxinc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	DWORD PTR _fmaxexc$1$[ebp]
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN313@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN313@xmlSchemaD:

; 17539: 		xmlSchemaDeriveFacetErr(pctxt, fmaxexc, bfmaxinc, -1, 1, 1);
; 17540: 	    }
; 17541: 	}
; 17542: 	if (bfmininc) {

	mov	eax, DWORD PTR _bfmininc$1$[ebp]
	mov	esi, DWORD PTR _fmaxexc$1$[ebp]
	test	eax, eax
	je	$LN324@xmlSchemaD

; 17543: 	    /* maxExclusive > BASE minInclusive */
; 17544: 	    res = xmlSchemaCompareValues(fmaxexc->val, bfmininc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [esi+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17545: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17546: 		goto internal_error;
; 17547: 	    if (res != 1) {

	cmp	eax, 1
	je	$LN324@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup
	mov	esi, eax

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	mov	eax, DWORD PTR _fmaxexc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17229:     if (lessGreater == 1)
; 17230: 	msg = xmlStrcat(msg, BAD_CAST " greater than");

	push	OFFSET ??_C@_0O@EOMDOOFG@?5greater?5than@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfmininc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0

; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	esi
	push	0
	push	DWORD PTR _fmaxexc$1$[ebp]
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 92					; 0000005cH

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN534@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN534@xmlSchemaD:

; 17548: 		xmlSchemaDeriveFacetErr(pctxt, fmaxexc, bfmininc, 1, 0, 1);
; 17549: 	    }
; 17550: 	}
; 17551: 	if (bfminexc) {

	mov	esi, DWORD PTR _fmaxexc$1$[ebp]
$LN324@xmlSchemaD:
	mov	eax, DWORD PTR _bfminexc$1$[ebp]
	test	eax, eax
	je	$LN335@xmlSchemaD

; 17552: 	    /* maxExclusive > BASE minExclusive */
; 17553: 	    res = xmlSchemaCompareValues(fmaxexc->val, bfminexc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [esi+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17554: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17555: 		goto internal_error;
; 17556: 	    if (res != 1) {

	cmp	eax, 1
	je	$LN335@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup
	mov	esi, eax

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	mov	eax, DWORD PTR _fmaxexc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17229:     if (lessGreater == 1)
; 17230: 	msg = xmlStrcat(msg, BAD_CAST " greater than");

	push	OFFSET ??_C@_0O@EOMDOOFG@?5greater?5than@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfminexc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0

; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	esi
	push	0
	push	DWORD PTR _fmaxexc$1$[ebp]
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 92					; 0000005cH

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN335@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN335@xmlSchemaD:

; 17557: 		xmlSchemaDeriveFacetErr(pctxt, fmaxexc, bfminexc, 1, 0, 1);
; 17558: 	    }
; 17559: 	}
; 17560:     }
; 17561:     if (fminexc) {

	mov	eax, DWORD PTR _fminexc$1$[ebp]
	test	eax, eax
	je	$LN392@xmlSchemaD

; 17562: 	/*
; 17563: 	* "minExclusive < maxInclusive"
; 17564: 	*/
; 17565: 	if (fmaxinc) {

	test	ebx, ebx
	je	$LN532@xmlSchemaD

; 17566: 	    res = xmlSchemaCompareValues(fminexc->val, fmaxinc->val);

	push	DWORD PTR [ebx+32]
	push	DWORD PTR [eax+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17567: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17568: 		goto internal_error;
; 17569: 	    if (res != -1) {

	cmp	eax, -1
	je	$LN532@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	mov	edx, DWORD PTR _fminexc$1$[ebp]
	mov	esi, eax
	push	DWORD PTR [edx]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17231:     else
; 17232: 	msg = xmlStrcat(msg, BAD_CAST " less than");

	push	OFFSET ??_C@_0L@HHJDMGPP@?5less?5than@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	push	DWORD PTR [ebx]
	mov	esi, eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17240:     else
; 17241: 	msg = xmlStrcat(msg, BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	eax
	call	_xmlStrcat

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	mov	ebx, DWORD PTR _fminexc$1$[ebp]

; 17241: 	msg = xmlStrcat(msg, BAD_CAST "'");

	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 92					; 0000005cH

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN346@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 17562: 	/*
; 17563: 	* "minExclusive < maxInclusive"
; 17564: 	*/
; 17565: 	if (fmaxinc) {

	jmp	SHORT $LN346@xmlSchemaD
$LN300@xmlSchemaD:

; 17527: 		xmlSchemaDeriveFacetErr(pctxt, fmaxexc, bfmaxexc, -1, 1, 1);
; 17528: 	    }
; 17529: 	    if ((res != 0) && (bfmaxexc->fixed)) {

	test	eax, eax
	je	$LN304@xmlSchemaD

; 17248:     if (msg != NULL)

	jmp	$LN524@xmlSchemaD
$LN532@xmlSchemaD:

; 17570: 		xmlSchemaDeriveFacetErr(pctxt, fminexc, fmaxinc, -1, 0, 0);
; 17571: 	    }
; 17572: 	}
; 17573: 	/*
; 17574: 	* "minExclusive valid restriction"
; 17575: 	*/
; 17576: 	if (bfminexc) {

	mov	ebx, DWORD PTR _fminexc$1$[ebp]
$LN346@xmlSchemaD:
	mov	eax, DWORD PTR _bfminexc$1$[ebp]
	test	eax, eax
	je	$LN361@xmlSchemaD

; 17577: 	    /* minExclusive >= BASE minExclusive */
; 17578: 	    res = xmlSchemaCompareValues(fminexc->val, bfminexc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [ebx+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17579: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17580: 		goto internal_error;
; 17581: 	    if (res == -1) {

	cmp	eax, -1
	jne	$LN357@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	push	DWORD PTR [ebx]
	mov	esi, eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17229:     if (lessGreater == 1)
; 17230: 	msg = xmlStrcat(msg, BAD_CAST " greater than");

	push	OFFSET ??_C@_0O@EOMDOOFG@?5greater?5than@
	push	eax
	call	_xmlStrcat

; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfminexc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN525@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 17582: 		xmlSchemaDeriveFacetErr(pctxt, fminexc, bfminexc, 1, 1, 1);
; 17583: 	    }
; 17584: 	    if ((res != 0) && (bfminexc->fixed)) {

	jmp	SHORT $LN525@xmlSchemaD
$LN357@xmlSchemaD:
	test	eax, eax
	je	SHORT $LN361@xmlSchemaD
$LN525@xmlSchemaD:
	mov	eax, DWORD PTR _bfminexc$1$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN361@xmlSchemaD

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0EB@JECLPMKG@The?5base?5type?8s?5facet?5is?5?8fixed@
	push	DWORD PTR [ebx+20]
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
$LN361@xmlSchemaD:

; 17585: 		FACET_RESTR_FIXED_ERR(fminexc)
; 17586: 	    }
; 17587: 	}
; 17588: 	if (bfmaxinc) {

	mov	eax, DWORD PTR _bfmaxinc$1$[ebp]
	test	eax, eax
	je	$LN370@xmlSchemaD

; 17589: 	    /* minExclusive <= BASE maxInclusive */
; 17590: 	    res = xmlSchemaCompareValues(fminexc->val, bfmaxinc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [ebx+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17591: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17592: 		goto internal_error;
; 17593: 	    if (res == 1) {

	cmp	eax, 1
	jne	$LN370@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	push	DWORD PTR [ebx]
	mov	esi, eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17231:     else
; 17232: 	msg = xmlStrcat(msg, BAD_CAST " less than");

	push	OFFSET ??_C@_0L@HHJDMGPP@?5less?5than@
	push	eax
	call	_xmlStrcat

; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfmaxinc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN370@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN370@xmlSchemaD:

; 17594: 		xmlSchemaDeriveFacetErr(pctxt, fminexc, bfmaxinc, -1, 1, 1);
; 17595: 	    }
; 17596: 	}
; 17597: 	if (bfmininc) {

	mov	eax, DWORD PTR _bfmininc$1$[ebp]
	test	eax, eax
	je	$LN381@xmlSchemaD

; 17598: 	    /* minExclusive >= BASE minInclusive */
; 17599: 	    res = xmlSchemaCompareValues(fminexc->val, bfmininc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [ebx+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17600: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17601: 		goto internal_error;
; 17602: 	    if (res == -1) {

	cmp	eax, -1
	jne	$LN381@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	push	DWORD PTR [ebx]
	mov	esi, eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17229:     if (lessGreater == 1)
; 17230: 	msg = xmlStrcat(msg, BAD_CAST " greater than");

	push	OFFSET ??_C@_0O@EOMDOOFG@?5greater?5than@
	push	eax
	call	_xmlStrcat

; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfmininc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN381@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN381@xmlSchemaD:

; 17603: 		xmlSchemaDeriveFacetErr(pctxt, fminexc, bfmininc, 1, 1, 1);
; 17604: 	    }
; 17605: 	}
; 17606: 	if (bfmaxexc) {

	mov	eax, DWORD PTR _bfmaxexc$1$[ebp]
	test	eax, eax
	je	$LN392@xmlSchemaD

; 17607: 	    /* minExclusive < BASE maxExclusive */
; 17608: 	    res = xmlSchemaCompareValues(fminexc->val, bfmaxexc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [ebx+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17609: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17610: 		goto internal_error;
; 17611: 	    if (res != -1) {

	cmp	eax, -1
	je	$LN392@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	push	DWORD PTR [ebx]
	mov	esi, eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17231:     else
; 17232: 	msg = xmlStrcat(msg, BAD_CAST " less than");

	push	OFFSET ??_C@_0L@HHJDMGPP@?5less?5than@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfmaxexc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0

; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	esi
	push	0
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 92					; 0000005cH

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN392@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN392@xmlSchemaD:

; 17612: 		xmlSchemaDeriveFacetErr(pctxt, fminexc, bfmaxexc, -1, 0, 1);
; 17613: 	    }
; 17614: 	}
; 17615:     }
; 17616:     if (fmininc) {

	mov	ebx, DWORD PTR _fmininc$1$[ebp]
	test	ebx, ebx
	je	$LN449@xmlSchemaD

; 17617: 	/*
; 17618: 	* "minInclusive < maxExclusive"
; 17619: 	*/
; 17620: 	if (fmaxexc) {

	mov	eax, DWORD PTR _fmaxexc$1$[ebp]
	test	eax, eax
	je	$LN403@xmlSchemaD

; 17621: 	    res = xmlSchemaCompareValues(fmininc->val, fmaxexc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [ebx+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17622: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17623: 		goto internal_error;
; 17624: 	    if (res != -1) {

	cmp	eax, -1
	je	$LN403@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	push	DWORD PTR [ebx]
	mov	esi, eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17231:     else
; 17232: 	msg = xmlStrcat(msg, BAD_CAST " less than");

	push	OFFSET ??_C@_0L@HHJDMGPP@?5less?5than@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _fmaxexc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17240:     else
; 17241: 	msg = xmlStrcat(msg, BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	eax
	call	_xmlStrcat

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0

; 17241: 	msg = xmlStrcat(msg, BAD_CAST "'");

	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	esi
	push	0
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 92					; 0000005cH

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN403@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN403@xmlSchemaD:

; 17625: 		xmlSchemaDeriveFacetErr(pctxt, fmininc, fmaxexc, -1, 0, 0);
; 17626: 	    }
; 17627: 	}
; 17628: 	/*
; 17629: 	* "minExclusive valid restriction"
; 17630: 	*/
; 17631: 	if (bfmininc) {

	mov	eax, DWORD PTR _bfmininc$1$[ebp]
	test	eax, eax
	je	$LN418@xmlSchemaD

; 17632: 	    /* minInclusive >= BASE minInclusive */
; 17633: 	    res = xmlSchemaCompareValues(fmininc->val, bfmininc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [ebx+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17634: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17635: 		goto internal_error;
; 17636: 	    if (res == -1) {

	cmp	eax, -1
	jne	$LN414@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	push	DWORD PTR [ebx]
	mov	esi, eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17229:     if (lessGreater == 1)
; 17230: 	msg = xmlStrcat(msg, BAD_CAST " greater than");

	push	OFFSET ??_C@_0O@EOMDOOFG@?5greater?5than@
	push	eax
	call	_xmlStrcat

; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfmininc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN526@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 17637: 		xmlSchemaDeriveFacetErr(pctxt, fmininc, bfmininc, 1, 1, 1);
; 17638: 	    }
; 17639: 	    if ((res != 0) && (bfmininc->fixed)) {

	jmp	SHORT $LN526@xmlSchemaD
$LN414@xmlSchemaD:
	test	eax, eax
	je	SHORT $LN418@xmlSchemaD
$LN526@xmlSchemaD:
	mov	eax, DWORD PTR _bfmininc$1$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN418@xmlSchemaD

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0EB@JECLPMKG@The?5base?5type?8s?5facet?5is?5?8fixed@
	push	DWORD PTR [ebx+20]
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
$LN418@xmlSchemaD:

; 17640: 		FACET_RESTR_FIXED_ERR(fmininc)
; 17641: 	    }
; 17642: 	}
; 17643: 	if (bfmaxinc) {

	mov	eax, DWORD PTR _bfmaxinc$1$[ebp]
	test	eax, eax
	je	$LN427@xmlSchemaD

; 17644: 	    /* minInclusive <= BASE maxInclusive */
; 17645: 	    res = xmlSchemaCompareValues(fmininc->val, bfmaxinc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [ebx+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17646: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17647: 		goto internal_error;
; 17648: 	    if (res == 1) {

	cmp	eax, 1
	jne	$LN427@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	push	DWORD PTR [ebx]
	mov	esi, eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17231:     else
; 17232: 	msg = xmlStrcat(msg, BAD_CAST " less than");

	push	OFFSET ??_C@_0L@HHJDMGPP@?5less?5than@
	push	eax
	call	_xmlStrcat

; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfmaxinc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN427@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN427@xmlSchemaD:

; 17649: 		xmlSchemaDeriveFacetErr(pctxt, fmininc, bfmaxinc, -1, 1, 1);
; 17650: 	    }
; 17651: 	}
; 17652: 	if (bfminexc) {

	mov	eax, DWORD PTR _bfminexc$1$[ebp]
	test	eax, eax
	je	$LN438@xmlSchemaD

; 17653: 	    /* minInclusive > BASE minExclusive */
; 17654: 	    res = xmlSchemaCompareValues(fmininc->val, bfminexc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [ebx+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17655: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17656: 		goto internal_error;
; 17657: 	    if (res != 1)

	cmp	eax, 1
	je	$LN438@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	push	DWORD PTR [ebx]
	mov	esi, eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17229:     if (lessGreater == 1)
; 17230: 	msg = xmlStrcat(msg, BAD_CAST " greater than");

	push	OFFSET ??_C@_0O@EOMDOOFG@?5greater?5than@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfminexc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0

; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	esi
	push	0
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 92					; 0000005cH

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN438@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN438@xmlSchemaD:

; 17658: 		xmlSchemaDeriveFacetErr(pctxt, fmininc, bfminexc, 1, 0, 1);
; 17659: 	}
; 17660: 	if (bfmaxexc) {

	mov	eax, DWORD PTR _bfmaxexc$1$[ebp]
	test	eax, eax
	je	$LN449@xmlSchemaD

; 17661: 	    /* minInclusive < BASE maxExclusive */
; 17662: 	    res = xmlSchemaCompareValues(fmininc->val, bfmaxexc->val);

	push	DWORD PTR [eax+32]
	push	DWORD PTR [ebx+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17663: 	    if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17664: 		goto internal_error;
; 17665: 	    if (res != -1)

	cmp	eax, -1
	je	$LN449@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	push	DWORD PTR [ebx]
	mov	esi, eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17231:     else
; 17232: 	msg = xmlStrcat(msg, BAD_CAST " less than");

	push	OFFSET ??_C@_0L@HHJDMGPP@?5less?5than@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	eax, DWORD PTR _bfmaxexc$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0

; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	esi
	push	0
	push	ebx
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 92					; 0000005cH

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN449@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN449@xmlSchemaD:

; 17666: 		xmlSchemaDeriveFacetErr(pctxt, fmininc, bfmaxexc, -1, 0, 1);
; 17667: 	}
; 17668:     }
; 17669:     if (ftotdig && bftotdig) {

	mov	esi, DWORD PTR _ftotdig$1$[ebp]
	test	esi, esi
	je	$LN464@xmlSchemaD
	mov	ebx, DWORD PTR _bftotdig$1$[ebp]
	test	ebx, ebx
	je	$LN464@xmlSchemaD

; 17670: 	/*
; 17671: 	* SCC " totalDigits valid restriction"
; 17672: 	* totalDigits <= BASE totalDigits
; 17673: 	*/
; 17674: 	res = xmlSchemaCompareValues(ftotdig->val, bftotdig->val);

	push	DWORD PTR [ebx+32]
	push	DWORD PTR [esi+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17675: 	if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17676: 	    goto internal_error;
; 17677: 	if (res == 1)

	cmp	eax, 1
	jne	$LN460@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup
	mov	esi, eax

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	mov	eax, DWORD PTR _ftotdig$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17231:     else
; 17232: 	msg = xmlStrcat(msg, BAD_CAST " less than");

	push	OFFSET ??_C@_0L@HHJDMGPP@?5less?5than@
	push	eax
	call	_xmlStrcat

; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	push	DWORD PTR [ebx]
	mov	esi, eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	DWORD PTR _ftotdig$1$[ebp]
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN542@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN542@xmlSchemaD:

; 17678: 	    xmlSchemaDeriveFacetErr(pctxt, ftotdig, bftotdig,
; 17679: 	    -1, 1, 1);
; 17680: 	if ((res != 0) && (bftotdig->fixed)) {

	mov	esi, DWORD PTR _ftotdig$1$[ebp]
$LN527@xmlSchemaD:
	cmp	DWORD PTR [ebx+24], 0
	je	SHORT $LN464@xmlSchemaD

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0EB@JECLPMKG@The?5base?5type?8s?5facet?5is?5?8fixed@
	push	DWORD PTR [esi+20]
	push	esi
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
$LN464@xmlSchemaD:

; 17681: 	    FACET_RESTR_FIXED_ERR(ftotdig)
; 17682: 	}
; 17683:     }
; 17684:     if (ffracdig && bffracdig) {

	mov	esi, DWORD PTR _ffracdig$1$[ebp]
	mov	ebx, DWORD PTR _bffracdig$1$[ebp]
	test	esi, esi
	je	$LN144@xmlSchemaD
	test	ebx, ebx
	je	$LN144@xmlSchemaD

; 17685: 	/*
; 17686: 	* SCC  "fractionDigits valid restriction"
; 17687: 	* fractionDigits <= BASE fractionDigits
; 17688: 	*/
; 17689: 	res = xmlSchemaCompareValues(ffracdig->val, bffracdig->val);

	push	DWORD PTR [ebx+32]
	push	DWORD PTR [esi+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17690: 	if (res == -2)

	cmp	eax, -2					; fffffffeH
	je	$internal_error$548

; 17691: 	    goto internal_error;
; 17692: 	if (res == 1)

	cmp	eax, 1
	jne	$LN473@xmlSchemaD

; 17224:     msg = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup
	mov	esi, eax

; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));

	mov	eax, DWORD PTR _ffracdig$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");

	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat

; 17231:     else
; 17232: 	msg = xmlStrcat(msg, BAD_CAST " less than");

	push	OFFSET ??_C@_0L@HHJDMGPP@?5less?5than@
	push	eax
	call	_xmlStrcat

; 17233: 
; 17234:     if (orEqual)
; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	push	DWORD PTR [ebx]
	mov	esi, eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");

	push	OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	push	eax
	call	_xmlStrcat
	add	esp, 68					; 00000044H
	mov	esi, eax

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	DWORD PTR _ffracdig$1$[ebp]
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN543@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN543@xmlSchemaD:

; 17693: 	    xmlSchemaDeriveFacetErr(pctxt, ffracdig, bffracdig,
; 17694: 	    -1, 1, 1);
; 17695: 	if ((res != 0) && (bffracdig->fixed)) {

	mov	esi, DWORD PTR _ffracdig$1$[ebp]
$LN528@xmlSchemaD:
	cmp	DWORD PTR [ebx+24], 0
	je	SHORT $LN144@xmlSchemaD

; 17696: 	    FACET_RESTR_FIXED_ERR(ffracdig)

	push	0
	push	OFFSET ??_C@_0EB@JECLPMKG@The?5base?5type?8s?5facet?5is?5?8fixed@
	push	DWORD PTR [esi+20]
	push	esi
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErr
	add	esp, 24					; 00000018H
$LN144@xmlSchemaD:

; 17697: 	}
; 17698:     }
; 17699:     /*
; 17700:     * SCC "fractionDigits less than or equal to totalDigits"
; 17701:     */
; 17702:     if (! ftotdig)
; 17703: 	ftotdig = bftotdig;
; 17704:     if (! ffracdig)

	mov	eax, DWORD PTR _ftotdig$1$[ebp]
	test	eax, eax
	mov	esi, DWORD PTR _bftotdig$1$[ebp]
	cmovne	esi, eax

; 17705: 	ffracdig = bffracdig;
; 17706:     if (ftotdig && ffracdig) {

	mov	eax, DWORD PTR _ffracdig$1$[ebp]
	test	eax, eax
	cmovne	ebx, eax
	test	esi, esi
	je	$LN149@xmlSchemaD
	test	ebx, ebx
	je	$LN149@xmlSchemaD

; 17707: 	res = xmlSchemaCompareValues(ffracdig->val, ftotdig->val);

	push	DWORD PTR [esi+32]
	push	DWORD PTR [ebx+32]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 17708: 	if (res == -2)

	cmp	eax, -2					; fffffffeH
	jne	$LN148@xmlSchemaD
$internal_error$548:

; 2293 :     if (actxt == NULL)

	test	edi, edi
	je	$LN491@xmlSchemaD

; 2294 :         return;
; 2295 :     msg = xmlStrdup(BAD_CAST "Internal error: %s, ");

	push	OFFSET ??_C@_0BF@EFOKBLAL@Internal?5error?3?5?$CFs?0?5@
	call	_xmlStrdup

; 2296 :     msg = xmlStrcat(msg, BAD_CAST message);

	push	OFFSET ??_C@_0BC@JHOAJLMF@an?5error?5occurred@
	push	eax
	call	_xmlStrcat

; 2297 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	call	_xmlStrcat
	mov	esi, eax
	add	esp, 20					; 00000014H

; 2298 : 
; 2299 :     if (actxt->type == XML_SCHEMA_CTXT_VALIDATOR)

	mov	eax, DWORD PTR [edi]
	cmp	eax, 2
	jne	SHORT $LN488@xmlSchemaD

; 2159 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CB@LPIBFCGM@xmlSchemaDeriveAndValidateFacet@
	push	esi
	push	0
	push	0
	push	1818					; 0000071aH

; 2300 : 	xmlSchemaErr3(actxt, XML_SCHEMAV_INTERNAL, NULL,

	jmp	SHORT $LN544@xmlSchemaD
$LN460@xmlSchemaD:

; 17678: 	    xmlSchemaDeriveFacetErr(pctxt, ftotdig, bftotdig,
; 17679: 	    -1, 1, 1);
; 17680: 	if ((res != 0) && (bftotdig->fixed)) {

	test	eax, eax
	je	$LN464@xmlSchemaD

; 17248:     if (msg != NULL)

	jmp	$LN527@xmlSchemaD
$LN473@xmlSchemaD:

; 17693: 	    xmlSchemaDeriveFacetErr(pctxt, ffracdig, bffracdig,
; 17694: 	    -1, 1, 1);
; 17695: 	if ((res != 0) && (bffracdig->fixed)) {

	test	eax, eax
	je	$LN144@xmlSchemaD

; 17248:     if (msg != NULL)

	jmp	$LN528@xmlSchemaD
$LN488@xmlSchemaD:

; 2302 :     else if (actxt->type == XML_SCHEMA_CTXT_PARSER)

	cmp	eax, 1
	jne	SHORT $LN495@xmlSchemaD

; 2159 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CB@LPIBFCGM@xmlSchemaDeriveAndValidateFacet@
	push	esi
	push	0
	push	0
	push	3069					; 00000bfdH
$LN544@xmlSchemaD:

; 2306 :     FREE_AND_NULL(msg)

	push	2
	push	edi
	call	_xmlSchemaErr4Line
	add	esp, 40					; 00000028H
$LN495@xmlSchemaD:
	test	esi, esi
	je	SHORT $LN491@xmlSchemaD
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN491@xmlSchemaD:
	pop	edi

; 17786: 	}
; 17787: 
; 17788:     }
; 17789: 
; 17790:     return (0);
; 17791: internal_error:
; 17792:     PERROR_INT("xmlSchemaDeriveAndValidateFacets",
; 17793: 	"an error occurred");
; 17794:     return (-1);
; 17795: }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN148@xmlSchemaD:

; 17709: 	    goto internal_error;
; 17710: 	if (res == 1)

	cmp	eax, 1
	jne	SHORT $LN149@xmlSchemaD

; 17711: 	    xmlSchemaDeriveFacetErr(pctxt, ffracdig, ftotdig,

	push	0
	push	eax
	push	-1
	push	esi
	push	ebx
	push	edi
	call	_xmlSchemaDeriveFacetErr
	add	esp, 24					; 00000018H
$LN149@xmlSchemaD:

; 17712: 		-1, 1, 0);
; 17713:     }
; 17714:     /*
; 17715:     * *Enumerations* won' be added here, since only the first set
; 17716:     * of enumerations in the ancestor-or-self axis is used
; 17717:     * for validation, plus we need to use the base type of those
; 17718:     * enumerations for whitespace.
; 17719:     *
; 17720:     * *Patterns*: won't be add here, since they are ORed at
; 17721:     * type level and ANDed at ancestor level. This will
; 17722:     * happed during validation by walking the base axis
; 17723:     * of the type.
; 17724:     */
; 17725:     for (cur = base->facetSet; cur != NULL; cur = cur->next) {

	mov	eax, DWORD PTR _base$1$[ebp]
	mov	ebx, DWORD PTR [eax+96]
	test	ebx, ebx
	je	$LN530@xmlSchemaD
	npad	7
$LL16@xmlSchemaD:

; 17726: 	bfacet = cur->facet;

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR _bfacet$1$[ebp], eax

; 17727: 	/*
; 17728: 	* Special handling of enumerations and patterns.
; 17729: 	* TODO: hmm, they should not appear in the set, so remove this.
; 17730: 	*/
; 17731: 	if ((bfacet->type == XML_SCHEMA_FACET_PATTERN) ||

	mov	edx, DWORD PTR [eax]
	cmp	edx, 1006				; 000003eeH
	je	$LN14@xmlSchemaD
	cmp	edx, 1007				; 000003efH
	je	$LN14@xmlSchemaD

; 17732: 	    (bfacet->type == XML_SCHEMA_FACET_ENUMERATION))
; 17733: 	    continue;
; 17734: 	/*
; 17735: 	* Search for a duplicate facet in the current type.
; 17736: 	*/
; 17737: 	link = type->facetSet;

	mov	esi, DWORD PTR _type$[ebp]
	mov	eax, DWORD PTR [esi+96]

; 17738: 	/* err = 0; */
; 17739: 	/* fixedErr = 0; */
; 17740: 	while (link != NULL) {

	test	eax, eax
	je	SHORT $LN520@xmlSchemaD
	npad	6
$LL17@xmlSchemaD:

; 17741: 	    facet = link->facet;

	mov	esi, DWORD PTR [eax+4]

; 17742: 	    if (facet->type == bfacet->type) {

	mov	ecx, DWORD PTR [esi]
	cmp	ecx, edx
	je	SHORT $LN502@xmlSchemaD

; 17755: 			    (facet->whitespace != bfacet->whitespace)) {
; 17756: 			    FACET_RESTR_FIXED_ERR(facet)
; 17757: 			}
; 17758: 			break;
; 17759: 		    default:
; 17760: 			break;
; 17761: 		}
; 17762: 		/* Duplicate found. */
; 17763: 		break;
; 17764: 	    }
; 17765: 	    link = link->next;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL17@xmlSchemaD

; 17773: 		xmlMalloc(sizeof(xmlSchemaFacetLink));
; 17774: 	    if (link == NULL) {

	mov	esi, DWORD PTR _type$[ebp]
$LN520@xmlSchemaD:

; 17772: 	    link = (xmlSchemaFacetLinkPtr)

	push	8
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 17773: 		xmlMalloc(sizeof(xmlSchemaFacetLink));
; 17774: 	    if (link == NULL) {

	test	eax, eax
	je	$LN503@xmlSchemaD

; 17778: 	    }
; 17779: 	    link->facet = cur->facet;

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ecx

; 17780: 	    link->next = NULL;
; 17781: 	    if (last == NULL)

	mov	ecx, DWORD PTR _last$1$[ebp]
	mov	DWORD PTR [eax], 0
	test	ecx, ecx
	jne	SHORT $LN159@xmlSchemaD

; 17782: 		type->facetSet = link;

	mov	DWORD PTR [esi+96], eax
	jmp	SHORT $LN160@xmlSchemaD
$LN502@xmlSchemaD:

; 17743: 		switch (facet->type) {

	cmp	ecx, 1008				; 000003f0H
	jne	SHORT $LN14@xmlSchemaD

; 17744: 		    case XML_SCHEMA_FACET_WHITESPACE:
; 17745: 			/*
; 17746: 			* The whitespace must be stronger.
; 17747: 			*/
; 17748: 			if (facet->whitespace < bfacet->whitespace) {

	mov	ecx, DWORD PTR _bfacet$1$[ebp]
	mov	eax, DWORD PTR [esi+28]
	cmp	eax, DWORD PTR [ecx+28]
	jge	SHORT $LN477@xmlSchemaD

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0GD@BCLDHCAD@The?5?8whitespace?8?5value?5has?5to?5b@
	push	DWORD PTR [esi+20]
	push	esi
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	mov	ecx, DWORD PTR _bfacet$1$[ebp]
	add	esp, 32					; 00000020H
$LN477@xmlSchemaD:

; 17749: 			    FACET_RESTR_ERR(facet,
; 17750: 				"The 'whitespace' value has to be equal to "
; 17751: 				"or stronger than the 'whitespace' value of "
; 17752: 				"the base type")
; 17753: 			}
; 17754: 			if ((bfacet->fixed) &&

	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN14@xmlSchemaD
	mov	eax, DWORD PTR [esi+28]
	cmp	eax, DWORD PTR [ecx+28]
	je	SHORT $LN14@xmlSchemaD

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0EB@JECLPMKG@The?5base?5type?8s?5facet?5is?5?8fixed@
	push	DWORD PTR [esi+20]
	push	esi
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 17766: 	}
; 17767: 	/*
; 17768: 	* If no duplicate was found: add the base types's facet
; 17769: 	* to the set.
; 17770: 	*/
; 17771: 	if (link == NULL) {

	jmp	SHORT $LN14@xmlSchemaD
$LN159@xmlSchemaD:

; 17783: 	    else
; 17784: 		last->next = link;

	mov	DWORD PTR [ecx], eax
$LN160@xmlSchemaD:

; 17785: 	    last = link;

	mov	DWORD PTR _last$1$[ebp], eax
$LN14@xmlSchemaD:

; 17712: 		-1, 1, 0);
; 17713:     }
; 17714:     /*
; 17715:     * *Enumerations* won' be added here, since only the first set
; 17716:     * of enumerations in the ancestor-or-self axis is used
; 17717:     * for validation, plus we need to use the base type of those
; 17718:     * enumerations for whitespace.
; 17719:     *
; 17720:     * *Patterns*: won't be add here, since they are ORed at
; 17721:     * type level and ANDed at ancestor level. This will
; 17722:     * happed during validation by walking the base axis
; 17723:     * of the type.
; 17724:     */
; 17725:     for (cur = base->facetSet; cur != NULL; cur = cur->next) {

	mov	ebx, DWORD PTR [ebx]
	test	ebx, ebx
	jne	$LL16@xmlSchemaD
$LN530@xmlSchemaD:
	pop	edi

; 17786: 	}
; 17787: 
; 17788:     }
; 17789: 
; 17790:     return (0);
; 17791: internal_error:
; 17792:     PERROR_INT("xmlSchemaDeriveAndValidateFacets",
; 17793: 	"an error occurred");
; 17794:     return (-1);
; 17795: }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN503@xmlSchemaD:

; 1884 :     if (ctxt != NULL)

	test	edi, edi
	je	SHORT $LN482@xmlSchemaD

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [edi+20]
$LN482@xmlSchemaD:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CH@NFDGHLNP@deriving?5facets?0?5creating?5a?5fac@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 17775: 		xmlSchemaPErrMemory(pctxt,
; 17776: 		    "deriving facets, creating a facet link", NULL);
; 17777: 		return (-1);

	or	eax, -1
	pop	edi

; 17786: 	}
; 17787: 
; 17788:     }
; 17789: 
; 17790:     return (0);
; 17791: internal_error:
; 17792:     PERROR_INT("xmlSchemaDeriveAndValidateFacets",
; 17793: 	"an error occurred");
; 17794:     return (-1);
; 17795: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN546@xmlSchemaD:
	DD	$LN25@xmlSchemaD
	DD	$LN26@xmlSchemaD
	DD	$LN28@xmlSchemaD
	DD	$LN29@xmlSchemaD
	DD	$LN30@xmlSchemaD
	DD	$LN31@xmlSchemaD
	DD	$LN4@xmlSchemaD
	DD	$LN4@xmlSchemaD
	DD	$LN4@xmlSchemaD
	DD	$LN23@xmlSchemaD
	DD	$LN27@xmlSchemaD
	DD	$LN24@xmlSchemaD
$LN547@xmlSchemaD:
	DD	$LN35@xmlSchemaD
	DD	$LN36@xmlSchemaD
	DD	$LN38@xmlSchemaD
	DD	$LN39@xmlSchemaD
	DD	$LN40@xmlSchemaD
	DD	$LN41@xmlSchemaD
	DD	$LN9@xmlSchemaD
	DD	$LN9@xmlSchemaD
	DD	$LN9@xmlSchemaD
	DD	$LN33@xmlSchemaD
	DD	$LN37@xmlSchemaD
	DD	$LN34@xmlSchemaD
_xmlSchemaDeriveAndValidateFacets ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaDeriveFacetErr
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_facet1$ = 12						; size = 4
_facet2$ = 16						; size = 4
_lessGreater$ = 20					; size = 4
_orEqual$ = 24						; size = 4
_ofBase$ = 28						; size = 4
_xmlSchemaDeriveFacetErr PROC				; COMDAT

; 17221: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup
	mov	edi, DWORD PTR _facet1$[ebp]
	mov	esi, eax
	push	DWORD PTR [edi]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat
	push	OFFSET ??_C@_0M@HCGPHKGF@?8?5has?5to?5be@
	push	eax
	call	_xmlStrcat
	mov	esi, DWORD PTR _lessGreater$[ebp]
	add	esp, 24					; 00000018H
	mov	ecx, eax
	test	esi, esi
	jne	SHORT $LN2@xmlSchemaD

; 17222:     xmlChar *msg = NULL;
; 17223: 
; 17224:     msg = xmlStrdup(BAD_CAST "'");
; 17225:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));
; 17226:     msg = xmlStrcat(msg, BAD_CAST "' has to be");
; 17227:     if (lessGreater == 0)
; 17228: 	msg = xmlStrcat(msg, BAD_CAST " equal to");

	push	OFFSET ??_C@_09BFLDGAFJ@?5equal?5to@
	push	ecx
	call	_xmlStrcat
	add	esp, 8
	mov	ecx, eax
$LN2@xmlSchemaD:

; 17229:     if (lessGreater == 1)
; 17230: 	msg = xmlStrcat(msg, BAD_CAST " greater than");
; 17231:     else
; 17232: 	msg = xmlStrcat(msg, BAD_CAST " less than");
; 17233: 
; 17234:     if (orEqual)

	mov	edx, OFFSET ??_C@_0O@EOMDOOFG@?5greater?5than@
	cmp	esi, 1
	mov	eax, OFFSET ??_C@_0L@HHJDMGPP@?5less?5than@
	cmove	eax, edx
	push	eax
	push	ecx
	call	_xmlStrcat
	add	esp, 8
	cmp	DWORD PTR _orEqual$[ebp], 0
	je	SHORT $LN5@xmlSchemaD

; 17235: 	msg = xmlStrcat(msg, BAD_CAST " or equal to");

	push	OFFSET ??_C@_0N@LGLLBNBD@?5or?5equal?5to@
	push	eax
	call	_xmlStrcat
	add	esp, 8
$LN5@xmlSchemaD:

; 17236:     msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat

; 17237:     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));

	mov	ecx, DWORD PTR _facet2$[ebp]
	mov	esi, eax
	push	DWORD PTR [ecx]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	esi
	call	_xmlStrcat

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	cmp	DWORD PTR _ofBase$[ebp], 0
	mov	edx, OFFSET ??_C@_0BD@OGMOIDHN@?8?5of?5the?5base?5type@
	mov	ecx, OFFSET ??_C@_01GEODFPGF@?8@
	cmovne	ecx, edx
	push	ecx
	push	eax
	call	_xmlStrcat
	push	0
	push	0
	push	0
	mov	esi, eax
	push	esi
	push	0
	push	edi
	push	1717					; 000006b5H
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaPCustomErrExt
	add	esp, 60					; 0000003cH

; 17238:     if (ofBase)
; 17239: 	msg = xmlStrcat(msg, BAD_CAST "' of the base type");
; 17240:     else
; 17241: 	msg = xmlStrcat(msg, BAD_CAST "'");
; 17242: 
; 17243:     xmlSchemaPCustomErr(pctxt,
; 17244: 	XML_SCHEMAP_INVALID_FACET_VALUE,
; 17245: 	WXS_BASIC_CAST facet1, NULL,
; 17246: 	(const char *) msg, NULL);
; 17247: 
; 17248:     if (msg != NULL)

	test	esi, esi
	je	SHORT $LN8@xmlSchemaD

; 17249: 	xmlFree(msg);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlSchemaD:

; 17250: }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlSchemaDeriveFacetErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckSRCCT
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_str$1 = 12						; size = 4
_str$2 = 12						; size = 4
_str$3 = 12						; size = 4
_str$4 = 12						; size = 4
_type$ = 12						; size = 4
_xmlSchemaCheckSRCCT PROC				; COMDAT

; 16648: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _type$[ebp]
	xor	ebx, ebx
	mov	eax, DWORD PTR [edi+52]
	mov	esi, DWORD PTR [edi+64]
	cmp	eax, 4
	je	SHORT $LN2@xmlSchemaC

; 16649:     xmlSchemaTypePtr base;
; 16650:     int ret = 0;
; 16651: 
; 16652:     /*
; 16653:     * TODO: Adjust the error codes here, as I used
; 16654:     * XML_SCHEMAP_SRC_CT_1 only yet.
; 16655:     */
; 16656:     base = type->baseType;
; 16657:     if (! WXS_HAS_SIMPLE_CONTENT(type)) {

	cmp	eax, 6
	je	SHORT $LN2@xmlSchemaC

; 16658: 	/*
; 16659: 	* 1 If the <complexContent> alternative is chosen, the type definition
; 16660: 	* `resolved` to by the `actual value` of the base [attribute]
; 16661: 	* must be a complex type definition;
; 16662: 	*/
; 16663: 	if (! WXS_IS_COMPLEX(base)) {

	cmp	DWORD PTR [esi], 5
	je	$LN24@xmlSchemaC
	cmp	DWORD PTR [esi+88], 45			; 0000002dH
	je	$LN24@xmlSchemaC

; 16664: 	    xmlChar *str = NULL;
; 16665: 	    xmlSchemaPCustomErr(ctxt,

	push	DWORD PTR [esi+8]
	lea	eax, DWORD PTR _str$4[ebp]
	mov	DWORD PTR _str$4[ebp], ebx
	push	DWORD PTR [esi+112]
	push	eax
	call	_xmlSchemaFormatQName

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	ebx
	push	ebx
	push	eax
	push	OFFSET ??_C@_0GP@CNIJIED@If?5using?5?$DMcomplexContent?$DO?0?5the?5@
	push	DWORD PTR [edi+36]
	jmp	$LN40@xmlSchemaC
$LN2@xmlSchemaC:

; 16666: 		XML_SCHEMAP_SRC_CT_1,
; 16667: 		WXS_BASIC_CAST type, type->node,
; 16668: 		"If using <complexContent>, the base type is expected to be "
; 16669: 		"a complex type. The base type '%s' is a simple type",
; 16670: 		xmlSchemaFormatQName(&str, base->targetNamespace,
; 16671: 		base->name));
; 16672: 	    FREE_AND_NULL(str)
; 16673: 	    return (XML_SCHEMAP_SRC_CT_1);
; 16674: 	}
; 16675:     } else {
; 16676: 	/*
; 16677: 	* SPEC
; 16678: 	* 2 If the <simpleContent> alternative is chosen, all of the
; 16679: 	* following must be true:
; 16680: 	* 2.1 The type definition `resolved` to by the `actual value` of the
; 16681: 	* base [attribute] must be one of the following:
; 16682: 	*/
; 16683: 	if (WXS_IS_SIMPLE(base)) {

	mov	eax, DWORD PTR [esi]
	cmp	eax, 4
	je	$LN8@xmlSchemaC
	cmp	eax, 1
	jne	SHORT $LN6@xmlSchemaC
	cmp	DWORD PTR [esi+88], 45			; 0000002dH
	jne	$LN8@xmlSchemaC
$LN6@xmlSchemaC:

; 16701: 	    }
; 16702: 	} else {
; 16703: 	    /* Base type is a complex type. */
; 16704: 	    if ((base->contentType == XML_SCHEMA_CONTENT_SIMPLE) ||

	mov	eax, DWORD PTR [esi+52]
	cmp	eax, 4
	je	$LN13@xmlSchemaC
	cmp	eax, 6
	je	$LN13@xmlSchemaC

; 16718: 		}
; 16719: 	    } else if ((base->contentType == XML_SCHEMA_CONTENT_MIXED) &&

	cmp	eax, 3
	jne	SHORT $LN37@xmlSchemaC
	test	BYTE PTR [edi+48], 4
	je	SHORT $LN37@xmlSchemaC

; 16720: 		(WXS_IS_RESTRICTION(type))) {
; 16721: 
; 16722: 		/*
; 16723: 		* 2.1.2 only if the <restriction> alternative is also
; 16724: 		* chosen, a complex type definition whose {content type}
; 16725: 		* is mixed and a particle emptiable.
; 16726: 		*/
; 16727: 		if (! xmlSchemaIsParticleEmptiable(

	push	DWORD PTR [esi+28]
	call	_xmlSchemaIsParticleEmptiable
	add	esp, 4
	test	eax, eax
	je	SHORT $LN37@xmlSchemaC

; 16728: 		    (xmlSchemaParticlePtr) base->subtypes)) {
; 16729: 		    ret = XML_SCHEMAP_SRC_CT_1;
; 16730: 		} else
; 16731: 		    /*
; 16732: 		    * Attention: at this point the <simpleType> child is in
; 16733: 		    * ->contentTypeDef (put there during parsing).
; 16734: 		    */
; 16735: 		    if (type->contentTypeDef == NULL) {

	cmp	DWORD PTR [edi+104], ebx
	jne	$LN24@xmlSchemaC

; 16736: 		    xmlChar *str = NULL;
; 16737: 		    /*
; 16738: 		    * 2.2 If clause 2.1.2 above is satisfied, then there
; 16739: 		    * must be a <simpleType> among the [children] of
; 16740: 		    * <restriction>.
; 16741: 		    */
; 16742: 		    /* TODO: Change error code to ..._SRC_CT_2_2. */
; 16743: 		    xmlSchemaPCustomErr(ctxt,

	push	DWORD PTR [esi+8]
	lea	eax, DWORD PTR _str$2[ebp]
	mov	DWORD PTR _str$2[ebp], ebx
	push	DWORD PTR [esi+112]
	push	eax
	call	_xmlSchemaFormatQName
	push	eax
	push	OFFSET ??_C@_0IE@LDPFNCJG@A?5?$DMsimpleType?$DO?5is?5expected?5amon@
	push	0
	push	edi
	push	3076					; 00000c04H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPCustomErr
	add	esp, 36					; 00000024H
	jmp	$LN41@xmlSchemaC
$LN37@xmlSchemaC:

; 16744: 			XML_SCHEMAP_SRC_CT_1,
; 16745: 			WXS_BASIC_CAST type, NULL,
; 16746: 			"A <simpleType> is expected among the children "
; 16747: 			"of <restriction>, if <simpleContent> is used and "
; 16748: 			"the base type '%s' is a complex type",
; 16749: 			xmlSchemaFormatQName(&str, base->targetNamespace,
; 16750: 			base->name));
; 16751: 		    FREE_AND_NULL(str)
; 16752: 		    return (XML_SCHEMAP_SRC_CT_1);
; 16753: 		}
; 16754: 	    } else {
; 16755: 		ret = XML_SCHEMAP_SRC_CT_1;
; 16756: 	    }
; 16757: 	}
; 16758: 	if (ret > 0) {
; 16759: 	    xmlChar *str = NULL;
; 16760: 	    if (WXS_IS_RESTRICTION(type)) {
; 16761: 		xmlSchemaPCustomErr(ctxt,
; 16762: 		    XML_SCHEMAP_SRC_CT_1,
; 16763: 		    WXS_BASIC_CAST type, NULL,
; 16764: 		    "If <simpleContent> and <restriction> is used, the "
; 16765: 		    "base type must be a simple type or a complex type with "
; 16766: 		    "mixed content and particle emptiable. The base type "
; 16767: 		    "'%s' is none of those",
; 16768: 		    xmlSchemaFormatQName(&str, base->targetNamespace,
; 16769: 		    base->name));
; 16770: 	    } else {
; 16771: 		xmlSchemaPCustomErr(ctxt,
; 16772: 		    XML_SCHEMAP_SRC_CT_1,
; 16773: 		    WXS_BASIC_CAST type, NULL,
; 16774: 		    "If <simpleContent> and <extension> is used, the "
; 16775: 		    "base type must be a simple type. The base type '%s' "
; 16776: 		    "is a complex type",
; 16777: 		    xmlSchemaFormatQName(&str, base->targetNamespace,
; 16778: 		    base->name));
; 16779: 	    }
; 16780: 	    FREE_AND_NULL(str)

	push	DWORD PTR [esi+8]
	lea	eax, DWORD PTR _str$1[ebp]
	mov	DWORD PTR _str$1[ebp], ebx
	push	DWORD PTR [esi+112]
	mov	ebx, DWORD PTR [edi+48]
	push	eax
	call	_xmlSchemaFormatQName
	push	0
	push	0
	push	eax
	test	bl, 4
	mov	ecx, OFFSET ??_C@_0LD@GJIEKEIE@If?5?$DMsimpleContent?$DO?5and?5?$DMrestric@
	mov	eax, OFFSET ??_C@_0HG@CLNEKDGF@If?5?$DMsimpleContent?$DO?5and?5?$DMextensi@
	cmovne	eax, ecx
	push	eax
	push	0
	push	edi
	push	3076					; 00000c04H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPCustomErrExt
	mov	eax, DWORD PTR _str$1[ebp]
	add	esp, 44					; 0000002cH
	mov	ebx, 3076				; 00000c04H
	test	eax, eax
	je	SHORT $LN24@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN24@xmlSchemaC:

; 16781: 	}
; 16782:     }
; 16783:     /*
; 16784:     * SPEC (3) "The corresponding complex type definition component must
; 16785:     * satisfy the conditions set out in Constraints on Complex Type
; 16786:     * Definition Schema Components ($3.4.6);"
; 16787:     * NOTE (3) will be done in xmlSchemaTypeFixup().
; 16788:     */
; 16789:     /*
; 16790:     * SPEC (4) If clause 2.2.1 or clause 2.2.2 in the correspondence specification
; 16791:     * above for {attribute wildcard} is satisfied, the intensional
; 16792:     * intersection must be expressible, as defined in Attribute Wildcard
; 16793:     * Intersection ($3.10.6).
; 16794:     * NOTE (4) is done in xmlSchemaFixupTypeAttributeUses().
; 16795:     */
; 16796:     return (ret);
; 16797: }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	0
$LN13@xmlSchemaC:

; 16705: 		(base->contentType == XML_SCHEMA_CONTENT_BASIC)) {
; 16706: 		/*
; 16707: 		* 2.1.1 a complex type definition whose {content type} is a
; 16708: 		* simple type definition;
; 16709: 		* PASS
; 16710: 		*/
; 16711: 		if (base->contentTypeDef == NULL) {

	cmp	DWORD PTR [esi+104], ebx
	jne	SHORT $LN24@xmlSchemaC

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_0EJ@MGOOHGBI@Internal?5error?3?5xmlSchemaCheckS@
	push	0
	push	edi
	push	3069					; 00000bfdH
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 16712: 		    xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_INTERNAL,
; 16713: 			WXS_BASIC_CAST type, NULL,
; 16714: 			"Internal error: xmlSchemaCheckSRCCT, "
; 16715: 			"'%s', base type has no content type",
; 16716: 			type->name);
; 16717: 		    return (-1);

	or	eax, -1
	pop	edi

; 16781: 	}
; 16782:     }
; 16783:     /*
; 16784:     * SPEC (3) "The corresponding complex type definition component must
; 16785:     * satisfy the conditions set out in Constraints on Complex Type
; 16786:     * Definition Schema Components ($3.4.6);"
; 16787:     * NOTE (3) will be done in xmlSchemaTypeFixup().
; 16788:     */
; 16789:     /*
; 16790:     * SPEC (4) If clause 2.2.1 or clause 2.2.2 in the correspondence specification
; 16791:     * above for {attribute wildcard} is satisfied, the intensional
; 16792:     * intersection must be expressible, as defined in Attribute Wildcard
; 16793:     * Intersection ($3.10.6).
; 16794:     * NOTE (4) is done in xmlSchemaFixupTypeAttributeUses().
; 16795:     */
; 16796:     return (ret);
; 16797: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlSchemaC:

; 16684: 	    if (WXS_IS_EXTENSION(type) == 0) {

	test	BYTE PTR [edi+48], 2
	jne	SHORT $LN24@xmlSchemaC

; 16685: 		xmlChar *str = NULL;
; 16686: 		/*
; 16687: 		* 2.1.3 only if the <extension> alternative is also
; 16688: 		* chosen, a simple type definition.
; 16689: 		*/
; 16690: 		/* TODO: Change error code to ..._SRC_CT_2_1_3. */
; 16691: 		xmlSchemaPCustomErr(ctxt,

	push	DWORD PTR [esi+8]
	lea	eax, DWORD PTR _str$3[ebp]
	mov	DWORD PTR _str$3[ebp], ebx
	push	DWORD PTR [esi+112]
	push	eax
	call	_xmlSchemaFormatQName

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	eax
	push	OFFSET ??_C@_0HG@OCMJPANJ@If?5using?5?$DMsimpleContent?$DO?5and?5?$DMr@
	push	0
$LN40@xmlSchemaC:

; 16692: 		    XML_SCHEMAP_SRC_CT_1,
; 16693: 		    WXS_BASIC_CAST type, NULL,
; 16694: 		    "If using <simpleContent> and <restriction>, the base "
; 16695: 		    "type must be a complex type. The base type '%s' is "
; 16696: 		    "a simple type",
; 16697: 		    xmlSchemaFormatQName(&str, base->targetNamespace,
; 16698: 			base->name));
; 16699: 		FREE_AND_NULL(str)
; 16700: 		return (XML_SCHEMAP_SRC_CT_1);

	push	edi
	push	3076					; 00000c04H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPCustomErrExt
	add	esp, 44					; 0000002cH
$LN41@xmlSchemaC:
	mov	eax, DWORD PTR _str$3[ebp]
	test	eax, eax
	je	SHORT $LN10@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlSchemaC:

; 16781: 	}
; 16782:     }
; 16783:     /*
; 16784:     * SPEC (3) "The corresponding complex type definition component must
; 16785:     * satisfy the conditions set out in Constraints on Complex Type
; 16786:     * Definition Schema Components ($3.4.6);"
; 16787:     * NOTE (3) will be done in xmlSchemaTypeFixup().
; 16788:     */
; 16789:     /*
; 16790:     * SPEC (4) If clause 2.2.1 or clause 2.2.2 in the correspondence specification
; 16791:     * above for {attribute wildcard} is satisfied, the intensional
; 16792:     * intersection must be expressible, as defined in Attribute Wildcard
; 16793:     * Intersection ($3.10.6).
; 16794:     * NOTE (4) is done in xmlSchemaFixupTypeAttributeUses().
; 16795:     */
; 16796:     return (ret);
; 16797: }

	pop	edi
	pop	esi
	mov	eax, 3076				; 00000c04H
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaCheckSRCCT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckCTComponent
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlSchemaCheckCTComponent PROC				; COMDAT

; 16618: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _type$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	push	esi
	push	edi
	call	_xmlSchemaCheckCTPropsCorrect
	add	esp, 8
	test	eax, eax
	jne	$LN1@xmlSchemaC

; 16619:     int ret;
; 16620:     /*
; 16621:     * Complex Type Definition Properties Correct
; 16622:     */
; 16623:     ret = xmlSchemaCheckCTPropsCorrect(ctxt, type);
; 16624:     if (ret != 0)
; 16625: 	return (ret);
; 16626:     if (WXS_IS_EXTENSION(type))

	test	BYTE PTR [esi+48], 2
	je	$LN3@xmlSchemaC

; 16172:     xmlSchemaTypePtr base = type->baseType;

	mov	eax, DWORD PTR [esi+64]

; 16173:     /*
; 16174:     * TODO: Correct the error code; XML_SCHEMAP_COS_CT_EXTENDS_1_1 is used
; 16175:     * temporarily only.
; 16176:     */
; 16177:     /*
; 16178:     * SPEC (1) "If the {base type definition} is a complex type definition,
; 16179:     * then all of the following must be true:"
; 16180:     */
; 16181:     if (WXS_IS_COMPLEX(base)) {

	cmp	DWORD PTR [eax], 5
	je	SHORT $LN9@xmlSchemaC
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	je	SHORT $LN9@xmlSchemaC

; 16342: 		    ((type->contentType != XML_SCHEMA_CONTENT_MIXED) &&
; 16343: 		    (type->contentType != XML_SCHEMA_CONTENT_ELEMENTS))) {
; 16344: 		    /*
; 16345: 		    * SPEC (1.4.3.2.2.1) "Both {content type}s must be mixed
; 16346: 		    * or both must be element-only."
; 16347: 		    */
; 16348: 		    xmlSchemaPCustomErr(ctxt,
; 16349: 			XML_SCHEMAP_COS_CT_EXTENDS_1_1,
; 16350: 			WXS_BASIC_CAST type, NULL,
; 16351: 			"The content type of both, the type and its base "
; 16352: 			"type, must either 'mixed' or 'element-only'", NULL);
; 16353: 		    return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);
; 16354: 		}
; 16355: 		/*
; 16356: 		* URGENT TODO SPEC (1.4.3.2.2.2) "The particle of the
; 16357: 		* complex type definition must be a `valid extension`
; 16358: 		* of the {base type definition}'s particle, as defined
; 16359: 		* in Particle Valid (Extension) ($3.9.6)."
; 16360: 		*
; 16361: 		* NOTE that we won't check "Particle Valid (Extension)",
; 16362: 		* since it is ensured by the derivation process in
; 16363: 		* xmlSchemaTypeFixup(). We need to implement this when heading
; 16364: 		* for a construction API
; 16365: 		* TODO: !! This is needed to be checked if redefining a type !!
; 16366: 		*/
; 16367: 	    }
; 16368: 	    /*
; 16369: 	    * URGENT TODO (1.5)
; 16370: 	    */
; 16371: 	}
; 16372:     } else {
; 16373: 	/*
; 16374: 	* SPEC (2) "If the {base type definition} is a simple type definition,
; 16375: 	* then all of the following must be true:"
; 16376: 	*/
; 16377: 	if (type->contentTypeDef != base) {

	cmp	DWORD PTR [esi+104], eax
	je	SHORT $LN20@xmlSchemaC

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CO@EGFIFAEL@The?5content?5type?5must?5be?5the?5si@

; 16386: 	    return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);

	jmp	SHORT $LN35@xmlSchemaC
$LN20@xmlSchemaC:

; 16387: 	}
; 16388: 	if (base->flags & XML_SCHEMAS_TYPE_FINAL_EXTENSION) {

	test	DWORD PTR [eax+48], 512			; 00000200H
	je	SHORT $LN18@xmlSchemaC
$LN36@xmlSchemaC:

; 16630:     return (ret);
; 16631: }

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0DN@CKGKOKMC@The?5?8final?8?5of?5the?5base?5type?5de@
	jmp	SHORT $LN35@xmlSchemaC
$LN9@xmlSchemaC:

; 16186: 	if (base->flags & XML_SCHEMAS_TYPE_FINAL_EXTENSION) {

	test	DWORD PTR [eax+48], 512			; 00000200H
	jne	SHORT $LN36@xmlSchemaC

; 16187: 	    xmlSchemaPCustomErr(ctxt,
; 16188: 		XML_SCHEMAP_COS_CT_EXTENDS_1_1,
; 16189: 		WXS_BASIC_CAST type, NULL,
; 16190: 		"The 'final' of the base type definition "
; 16191: 		"contains 'extension'", NULL);
; 16192: 	    return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);
; 16193: 	}
; 16194: 
; 16195: 	/*
; 16196: 	* ATTENTION: The constrains (1.2) and (1.3) are not applied,
; 16197: 	* since they are automatically satisfied through the
; 16198: 	* inheriting mechanism.
; 16199: 	* Note that even if redefining components, the inheriting mechanism
; 16200: 	* is used.
; 16201: 	*/
; 16202: #if 0
; 16203: 	/*
; 16204: 	* SPEC (1.2) "Its {attribute uses} must be a subset of the {attribute
; 16205: 	* uses}
; 16206: 	* of the complex type definition itself, that is, for every attribute
; 16207: 	* use in the {attribute uses} of the {base type definition}, there
; 16208: 	* must be an attribute use in the {attribute uses} of the complex
; 16209: 	* type definition itself whose {attribute declaration} has the same
; 16210: 	* {name}, {target namespace} and {type definition} as its attribute
; 16211: 	* declaration"
; 16212: 	*/
; 16213: 	if (base->attrUses != NULL) {
; 16214: 	    int i, j, found;
; 16215: 	    xmlSchemaAttributeUsePtr use, buse;
; 16216: 
; 16217: 	    for (i = 0; i < (WXS_LIST_CAST base->attrUses)->nbItems; i ++) {
; 16218: 		buse = (WXS_LIST_CAST base->attrUses)->items[i];
; 16219: 		found = 0;
; 16220: 		if (type->attrUses != NULL) {
; 16221: 		    use = (WXS_LIST_CAST type->attrUses)->items[j];
; 16222: 		    for (j = 0; j < (WXS_LIST_CAST type->attrUses)->nbItems; j ++)
; 16223: 		    {
; 16224: 			if ((WXS_ATTRUSE_DECL_NAME(use) ==
; 16225: 				WXS_ATTRUSE_DECL_NAME(buse)) &&
; 16226: 			    (WXS_ATTRUSE_DECL_TNS(use) ==
; 16227: 				WXS_ATTRUSE_DECL_TNS(buse)) &&
; 16228: 			    (WXS_ATTRUSE_TYPEDEF(use) ==
; 16229: 				WXS_ATTRUSE_TYPEDEF(buse))
; 16230: 			{
; 16231: 			    found = 1;
; 16232: 			    break;
; 16233: 			}
; 16234: 		    }
; 16235: 		}
; 16236: 		if (! found) {
; 16237: 		    xmlChar *str = NULL;
; 16238: 
; 16239: 		    xmlSchemaCustomErr(ACTXT_CAST ctxt,
; 16240: 			XML_SCHEMAP_COS_CT_EXTENDS_1_2,
; 16241: 			NULL, WXS_BASIC_CAST type,
; 16242: 			/*
; 16243: 			* TODO: The report does not indicate that also the
; 16244: 			* type needs to be the same.
; 16245: 			*/
; 16246: 			"This type is missing a matching correspondent "
; 16247: 			"for its {base type}'s %s in its {attribute uses}",
; 16248: 			xmlSchemaGetComponentDesignation(&str,
; 16249: 			    buse->children),
; 16250: 			NULL);
; 16251: 		    FREE_AND_NULL(str)
; 16252: 		}
; 16253: 	    }
; 16254: 	}
; 16255: 	/*
; 16256: 	* SPEC (1.3) "If it has an {attribute wildcard}, the complex type
; 16257: 	* definition must also have one, and the base type definition's
; 16258: 	* {attribute  wildcard}'s {namespace constraint} must be a subset
; 16259: 	* of the complex  type definition's {attribute wildcard}'s {namespace
; 16260: 	* constraint}, as defined by Wildcard Subset ($3.10.6)."
; 16261: 	*/
; 16262: 
; 16263: 	/*
; 16264: 	* MAYBE TODO: Enable if ever needed. But this will be needed only
; 16265: 	* if created the type via a schema construction API.
; 16266: 	*/
; 16267: 	if (base->attributeWildcard != NULL) {
; 16268: 	    if (type->attributeWilcard == NULL) {
; 16269: 		xmlChar *str = NULL;
; 16270: 
; 16271: 		xmlSchemaCustomErr(ACTXT_CAST pctxt,
; 16272: 		    XML_SCHEMAP_COS_CT_EXTENDS_1_3,
; 16273: 		    NULL, type,
; 16274: 		    "The base %s has an attribute wildcard, "
; 16275: 		    "but this type is missing an attribute wildcard",
; 16276: 		    xmlSchemaGetComponentDesignation(&str, base));
; 16277: 		FREE_AND_NULL(str)
; 16278: 
; 16279: 	    } else if (xmlSchemaCheckCOSNSSubset(
; 16280: 		base->attributeWildcard, type->attributeWildcard))
; 16281: 	    {
; 16282: 		xmlChar *str = NULL;
; 16283: 
; 16284: 		xmlSchemaCustomErr(ACTXT_CAST pctxt,
; 16285: 		    XML_SCHEMAP_COS_CT_EXTENDS_1_3,
; 16286: 		    NULL, type,
; 16287: 		    "The attribute wildcard is not a valid "
; 16288: 		    "superset of the one in the base %s",
; 16289: 		    xmlSchemaGetComponentDesignation(&str, base));
; 16290: 		FREE_AND_NULL(str)
; 16291: 	    }
; 16292: 	}
; 16293: #endif
; 16294: 	/*
; 16295: 	* SPEC (1.4) "One of the following must be true:"
; 16296: 	*/
; 16297: 	if ((type->contentTypeDef != NULL) &&

	mov	ecx, DWORD PTR [esi+104]
	test	ecx, ecx
	je	SHORT $LN11@xmlSchemaC
	cmp	ecx, DWORD PTR [eax+104]
	je	SHORT $LN18@xmlSchemaC
$LN11@xmlSchemaC:

; 16298: 	    (type->contentTypeDef == base->contentTypeDef)) {
; 16299: 	    /*
; 16300: 	    * SPEC (1.4.1) "The {content type} of the {base type definition}
; 16301: 	    * and the {content type} of the complex type definition itself
; 16302: 	    * must be the same simple type definition"
; 16303: 	    * PASS
; 16304: 	    */
; 16305: 	} else if ((type->contentType == XML_SCHEMA_CONTENT_EMPTY) &&

	mov	ecx, DWORD PTR [esi+52]
	cmp	ecx, 1
	jne	SHORT $LN34@xmlSchemaC
	cmp	DWORD PTR [eax+52], ecx
	je	SHORT $LN18@xmlSchemaC
$LN34@xmlSchemaC:

; 16306: 	    (base->contentType == XML_SCHEMA_CONTENT_EMPTY) ) {
; 16307: 	    /*
; 16308: 	    * SPEC (1.4.2) "The {content type} of both the {base type
; 16309: 	    * definition} and the complex type definition itself must
; 16310: 	    * be empty."
; 16311: 	    * PASS
; 16312: 	    */
; 16313: 	} else {
; 16314: 	    /*
; 16315: 	    * SPEC (1.4.3) "All of the following must be true:"
; 16316: 	    */
; 16317: 	    if (type->subtypes == NULL) {

	cmp	DWORD PTR [esi+28], 0
	jne	SHORT $LN15@xmlSchemaC

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CJ@LMFNPNPH@The?5content?5type?5must?5specify?5a@

; 16326: 		return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);

	jmp	SHORT $LN35@xmlSchemaC
$LN15@xmlSchemaC:

; 16327: 	    }
; 16328: 	    /*
; 16329: 	    * SPEC (1.4.3.2) "One of the following must be true:"
; 16330: 	    */
; 16331: 	    if (base->contentType == XML_SCHEMA_CONTENT_EMPTY) {

	mov	eax, DWORD PTR [eax+52]
	cmp	eax, 1
	je	SHORT $LN18@xmlSchemaC

; 16332: 		/*
; 16333: 		* SPEC (1.4.3.2.1) "The {content type} of the {base type
; 16334: 		* definition} must be empty.
; 16335: 		* PASS
; 16336: 		*/
; 16337: 	    } else {
; 16338: 		/*
; 16339: 		* SPEC (1.4.3.2.2) "All of the following must be true:"
; 16340: 		*/
; 16341: 		if ((type->contentType != base->contentType) ||

	cmp	ecx, eax
	jne	SHORT $LN19@xmlSchemaC
	cmp	ecx, 3
	je	SHORT $LN18@xmlSchemaC
	cmp	ecx, 2
	je	SHORT $LN18@xmlSchemaC
$LN19@xmlSchemaC:

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0FM@GPKINKDA@The?5content?5type?5of?5both?0?5the?5t@
$LN35@xmlSchemaC:

; 16630:     return (ret);
; 16631: }

	push	0
	push	esi
	push	3063					; 00000bf7H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
	mov	eax, 3063				; 00000bf7H
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN18@xmlSchemaC:
	pop	edi

; 16402:     return (0);

	xor	eax, eax

; 16630:     return (ret);
; 16631: }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlSchemaC:

; 16627: 	ret = xmlSchemaCheckCOSCTExtends(ctxt, type);
; 16628:     else
; 16629: 	ret = xmlSchemaCheckDerivationOKRestriction(ctxt, type);

	push	esi
	push	edi
	call	_xmlSchemaCheckDerivationOKRestriction
	add	esp, 8
$LN1@xmlSchemaC:

; 16630:     return (ret);
; 16631: }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlSchemaCheckCTComponent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckDerivationOKRestriction
_TEXT	SEGMENT
_strB$1 = -4						; size = 4
_ctxt$ = 8						; size = 4
_strA$2 = 12						; size = 4
_type$ = 12						; size = 4
_xmlSchemaCheckDerivationOKRestriction PROC		; COMDAT

; 16428: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _type$[ebp]
	mov	edi, DWORD PTR [esi+64]
	cmp	DWORD PTR [edi], 5
	je	SHORT $LN73@xmlSchemaC

; 16429:     xmlSchemaTypePtr base;
; 16430: 
; 16431:     /*
; 16432:     * TODO: Correct the error code; XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1 is used
; 16433:     * temporarily only.
; 16434:     */
; 16435:     base = type->baseType;
; 16436:     if (! WXS_IS_COMPLEX(base)) {

	cmp	DWORD PTR [edi+88], 45			; 0000002dH
	je	SHORT $LN73@xmlSchemaC

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CF@JAJFEDFA@The?5base?5type?5must?5be?5a?5complex@
$LN76@xmlSchemaC:

; 16603: }

	push	esi
	push	DWORD PTR [esi+36]
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	1787					; 000006fbH
	push	esi
	call	_xmlSchemaCustomErr4
	mov	eax, DWORD PTR [esi+16]
	add	esp, 36					; 00000024H
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN73@xmlSchemaC:

; 16437: 	xmlSchemaCustomErr(ACTXT_CAST ctxt,
; 16438: 	    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
; 16439: 	    type->node, WXS_BASIC_CAST type,
; 16440: 	    "The base type must be a complex type", NULL, NULL);
; 16441: 	return(ctxt->err);
; 16442:     }
; 16443:     if (base->flags & XML_SCHEMAS_TYPE_FINAL_RESTRICTION) {

	test	DWORD PTR [edi+48], 1024		; 00000400H
	je	SHORT $LN3@xmlSchemaC

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0DP@BNGFOOBI@The?5?8final?8?5of?5the?5base?5type?5de@

; 16444: 	/*
; 16445: 	* SPEC (1) "The {base type definition} must be a complex type
; 16446: 	* definition whose {final} does not contain restriction."
; 16447: 	*/
; 16448: 	xmlSchemaCustomErr(ACTXT_CAST ctxt,
; 16449: 	    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
; 16450: 	    type->node, WXS_BASIC_CAST type,
; 16451: 	    "The 'final' of the base type definition "
; 16452: 	    "contains 'restriction'", NULL, NULL);
; 16453: 	return (ctxt->err);

	jmp	SHORT $LN76@xmlSchemaC
$LN3@xmlSchemaC:
	push	ebx

; 16454:     }
; 16455:     /*
; 16456:     * SPEC (2), (3) and (4)
; 16457:     * Those are handled in a separate function, since the
; 16458:     * same constraints are needed for redefinition of
; 16459:     * attribute groups as well.
; 16460:     */
; 16461:     if (xmlSchemaCheckDerivationOKRestriction2to4(ctxt,
; 16462: 	XML_SCHEMA_ACTION_DERIVE,
; 16463: 	WXS_BASIC_CAST type, WXS_BASIC_CAST base,
; 16464: 	type->attrUses, base->attrUses,
; 16465: 	type->attributeWildcard,
; 16466: 	base->attributeWildcard) == -1)

	push	DWORD PTR [edi+84]
	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [esi+84]
	push	DWORD PTR [edi+116]
	push	DWORD PTR [esi+116]
	push	edi
	push	esi
	push	0
	push	ebx
	call	_xmlSchemaCheckDerivationOKRestriction2to4
	add	esp, 32					; 00000020H
	cmp	eax, -1
	je	$LN74@xmlSchemaC

; 16467:     {
; 16468: 	return(-1);
; 16469:     }
; 16470:     /*
; 16471:     * SPEC (5) "One of the following must be true:"
; 16472:     */
; 16473:     if (base->builtInType == XML_SCHEMAS_ANYTYPE) {

	cmp	DWORD PTR [edi+88], 45			; 0000002dH
	je	$LN13@xmlSchemaC

; 16474: 	/*
; 16475: 	* SPEC (5.1) "The {base type definition} must be the
; 16476: 	* `ur-type definition`."
; 16477: 	* PASS
; 16478: 	*/
; 16479:     } else if ((type->contentType == XML_SCHEMA_CONTENT_SIMPLE) ||

	mov	eax, DWORD PTR [esi+52]
	cmp	eax, 4
	je	$LN9@xmlSchemaC
	cmp	eax, 6
	je	$LN9@xmlSchemaC

; 16537: 	}
; 16538:     } else if (type->contentType == XML_SCHEMA_CONTENT_EMPTY) {

	cmp	eax, 1
	jne	SHORT $LN19@xmlSchemaC

; 16539: 	/*
; 16540: 	* SPEC (5.3.1) "The {content type} of the complex type itself must
; 16541: 	* be empty"
; 16542: 	*/
; 16543: 	if (base->contentType == XML_SCHEMA_CONTENT_EMPTY) {

	mov	eax, DWORD PTR [edi+52]
	cmp	eax, 1
	je	$LN13@xmlSchemaC

; 16544: 	    /*
; 16545: 	    * SPEC (5.3.2.1) "The {content type} of the {base type
; 16546: 	    * definition} must also be empty."
; 16547: 	    * PASS
; 16548: 	    */
; 16549: 	} else if (((base->contentType == XML_SCHEMA_CONTENT_ELEMENTS) ||
; 16550: 	    (base->contentType == XML_SCHEMA_CONTENT_MIXED)) &&

	cmp	eax, 2
	je	SHORT $LN25@xmlSchemaC
	cmp	eax, 3
	jne	SHORT $LN23@xmlSchemaC
$LN25@xmlSchemaC:
	push	DWORD PTR [edi+28]
	call	_xmlSchemaIsParticleEmptiable
	add	esp, 4
	test	eax, eax
	jne	$LN13@xmlSchemaC
$LN23@xmlSchemaC:

; 16551: 	    xmlSchemaIsParticleEmptiable(
; 16552: 		(xmlSchemaParticlePtr) base->subtypes)) {
; 16553: 	    /*
; 16554: 	    * SPEC (5.3.2.2) "The {content type} of the {base type
; 16555: 	    * definition} must be elementOnly or mixed and have a particle
; 16556: 	    * which is `emptiable` as defined in Particle Emptiable ($3.9.6)."
; 16557: 	    * PASS
; 16558: 	    */
; 16559: 	} else {
; 16560: 	    xmlSchemaPCustomErr(ctxt,

	push	0
	push	OFFSET ??_C@_0HB@BKHGHMKG@The?5content?5type?5of?5the?5base?5ty@
	push	0
	push	esi
	push	1787					; 000006fbH
	push	ebx
	call	_xmlSchemaPCustomErr

; 16561: 		XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
; 16562: 		WXS_BASIC_CAST type, NULL,
; 16563: 		"The content type of the base type must be either "
; 16564: 		"empty or 'mixed' (or 'elements-only') and an emptiable "
; 16565: 		"particle", NULL);
; 16566: 	    return (ctxt->err);

	mov	eax, DWORD PTR [ebx+16]
	add	esp, 24					; 00000018H
	pop	ebx
	pop	edi

; 16603: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlSchemaC:

; 16567: 	}
; 16568:     } else if ((type->contentType == XML_SCHEMA_CONTENT_ELEMENTS) ||

	cmp	eax, 2
	je	$LN13@xmlSchemaC
	cmp	eax, 3
	je	SHORT $LN72@xmlSchemaC

; 16586: 	}
; 16587: 	/*
; 16588: 	* SPEC (5.4.2) "The particle of the complex type definition itself
; 16589: 	* must be a `valid restriction` of the particle of the {content
; 16590: 	* type} of the {base type definition} as defined in Particle Valid
; 16591: 	* (Restriction) ($3.9.6).
; 16592: 	*
; 16593: 	* URGENT TODO: (5.4.2)
; 16594: 	*/
; 16595:     } else {
; 16596: 	xmlSchemaPCustomErr(ctxt,

	push	0
	push	OFFSET ??_C@_0DF@LCGEMILI@The?5type?5is?5not?5a?5valid?5restric@
	push	0
	push	esi
	push	1787					; 000006fbH
	push	ebx
	call	_xmlSchemaPCustomErr

; 16597: 	    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
; 16598: 	    WXS_BASIC_CAST type, NULL,
; 16599: 	    "The type is not a valid restriction of its base type", NULL);
; 16600: 	return (ctxt->err);

	mov	eax, DWORD PTR [ebx+16]
	add	esp, 24					; 00000018H
	pop	ebx
	pop	edi

; 16603: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN72@xmlSchemaC:

; 16569: 	WXS_HAS_MIXED_CONTENT(type)) {
; 16570: 	/*
; 16571: 	* SPEC (5.4.1.1) "The {content type} of the complex type definition
; 16572: 	* itself must be element-only"
; 16573: 	*/
; 16574: 	if (WXS_HAS_MIXED_CONTENT(type) && (! WXS_HAS_MIXED_CONTENT(base))) {

	cmp	DWORD PTR [edi+52], 3
	je	$LN13@xmlSchemaC

; 16575: 	    /*
; 16576: 	    * SPEC (5.4.1.2) "The {content type} of the complex type
; 16577: 	    * definition itself and of the {base type definition} must be
; 16578: 	    * mixed"
; 16579: 	    */
; 16580: 	    xmlSchemaPCustomErr(ctxt,

	push	0
	push	OFFSET ??_C@_0FM@PFEADGDA@If?5the?5content?5type?5is?5?8mixed?8?0@
	push	0
	push	esi
	push	1787					; 000006fbH
	push	ebx
	call	_xmlSchemaPCustomErr

; 16581: 		XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
; 16582: 		WXS_BASIC_CAST type, NULL,
; 16583: 		"If the content type is 'mixed', then the content type of the "
; 16584: 		"base type must also be 'mixed'", NULL);
; 16585: 	    return (ctxt->err);

	mov	eax, DWORD PTR [ebx+16]
	add	esp, 24					; 00000018H
	pop	ebx
	pop	edi

; 16603: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlSchemaC:

; 16480: 	    (type->contentType == XML_SCHEMA_CONTENT_BASIC)) {
; 16481: 	/*
; 16482: 	* SPEC (5.2.1) "The {content type} of the complex type definition
; 16483: 	* must be a simple type definition"
; 16484: 	*
; 16485: 	* SPEC (5.2.2) "One of the following must be true:"
; 16486: 	*/
; 16487: 	if ((base->contentType == XML_SCHEMA_CONTENT_SIMPLE) ||

	mov	eax, DWORD PTR [edi+52]
	cmp	eax, 4
	je	SHORT $LN12@xmlSchemaC
	cmp	eax, 6
	je	SHORT $LN12@xmlSchemaC

; 16520: 	    }
; 16521: 	} else if ((base->contentType == XML_SCHEMA_CONTENT_MIXED) &&

	cmp	eax, 3
	jne	SHORT $LN17@xmlSchemaC
	push	DWORD PTR [edi+28]
	call	_xmlSchemaIsParticleEmptiable
	add	esp, 4
	test	eax, eax
	jne	$LN13@xmlSchemaC
$LN17@xmlSchemaC:

; 16522: 	    (xmlSchemaIsParticleEmptiable(
; 16523: 		(xmlSchemaParticlePtr) base->subtypes))) {
; 16524: 	    /*
; 16525: 	    * SPEC (5.2.2.2) "The {base type definition} must be mixed
; 16526: 	    * and have a particle which is `emptiable` as defined in
; 16527: 	    * Particle Emptiable ($3.9.6)."
; 16528: 	    * PASS
; 16529: 	    */
; 16530: 	} else {
; 16531: 	    xmlSchemaPCustomErr(ctxt,

	push	0
	push	OFFSET ??_C@_0GE@JDFDINMM@The?5content?5type?5of?5the?5base?5ty@
	push	0
	push	esi
	push	1787					; 000006fbH
	push	ebx
	call	_xmlSchemaPCustomErr

; 16532: 		XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
; 16533: 		WXS_BASIC_CAST type, NULL,
; 16534: 		"The content type of the base type must be either "
; 16535: 		"a simple type or 'mixed' and an emptiable particle", NULL);
; 16536: 	    return (ctxt->err);

	mov	eax, DWORD PTR [ebx+16]
	add	esp, 24					; 00000018H
	pop	ebx
	pop	edi

; 16603: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlSchemaC:

; 16488: 	    (base->contentType == XML_SCHEMA_CONTENT_BASIC))
; 16489: 	{
; 16490: 	    int err;
; 16491: 	    /*
; 16492: 	    * SPEC (5.2.2.1) "The {content type} of the {base type
; 16493: 	    * definition} must be a simple type definition from which
; 16494: 	    * the {content type} is validly derived given the empty
; 16495: 	    * set as defined in Type Derivation OK (Simple) ($3.14.6)."
; 16496: 	    *
; 16497: 	    * ATTENTION TODO: This seems not needed if the type implicitely
; 16498: 	    * derived from the base type.
; 16499: 	    *
; 16500: 	    */
; 16501: 	    err = xmlSchemaCheckCOSSTDerivedOK(ACTXT_CAST ctxt,

	push	0
	push	DWORD PTR [edi+104]
	push	DWORD PTR [esi+104]
	push	ebx
	call	_xmlSchemaCheckCOSSTDerivedOK
	add	esp, 16					; 00000010H

; 16502: 		type->contentTypeDef, base->contentTypeDef, 0);
; 16503: 	    if (err != 0) {

	test	eax, eax
	je	SHORT $LN13@xmlSchemaC

; 16504: 		xmlChar *strA = NULL, *strB = NULL;

	mov	DWORD PTR _strA$2[ebp], 0
	mov	DWORD PTR _strB$1[ebp], 0

; 16505: 
; 16506: 		if (err == -1)

	cmp	eax, -1
	je	SHORT $LN74@xmlSchemaC

; 16508: 		xmlSchemaCustomErr(ACTXT_CAST ctxt,

	push	DWORD PTR [edi+104]
	lea	eax, DWORD PTR _strB$1[ebp]
	push	eax
	call	_xmlSchemaGetComponentDesignation
	add	esp, 8
	push	eax
	push	DWORD PTR [esi+104]
	lea	eax, DWORD PTR _strA$2[ebp]
	push	eax
	call	_xmlSchemaGetComponentDesignation
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0FE@IHCAKODH@The?5?$HLcontent?5type?$HN?5?$CFs?5is?5not?5va@
	push	esi
	push	0
	push	1787					; 000006fbH
	push	ebx
	call	_xmlSchemaCustomErr

; 16509: 		    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
; 16510: 		    NULL, WXS_BASIC_CAST type,
; 16511: 		    "The {content type} %s is not validly derived from the "
; 16512: 		    "base type's {content type} %s",
; 16513: 		    xmlSchemaGetComponentDesignation(&strA,
; 16514: 			type->contentTypeDef),
; 16515: 		    xmlSchemaGetComponentDesignation(&strB,
; 16516: 			base->contentTypeDef));
; 16517: 		FREE_AND_NULL(strA);

	mov	eax, DWORD PTR _strA$2[ebp]
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	SHORT $LN15@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlSchemaC:

; 16518: 		FREE_AND_NULL(strB);

	mov	eax, DWORD PTR _strB$1[ebp]
	test	eax, eax
	je	SHORT $LN16@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlSchemaC:

; 16519: 		return(ctxt->err);

	mov	eax, DWORD PTR [ebx+16]
	pop	ebx
	pop	edi

; 16603: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlSchemaC:
	pop	ebx
	pop	edi

; 16601:     }
; 16602:     return (0);

	xor	eax, eax

; 16603: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@xmlSchemaC:
	pop	ebx
	pop	edi

; 16507: 		    return(-1);

	or	eax, -1

; 16603: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCheckDerivationOKRestriction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckCOSCTExtends
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlSchemaCheckCOSCTExtends PROC			; COMDAT

; 16171: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	cmp	DWORD PTR [ecx], 5
	je	SHORT $LN4@xmlSchemaC

; 16172:     xmlSchemaTypePtr base = type->baseType;
; 16173:     /*
; 16174:     * TODO: Correct the error code; XML_SCHEMAP_COS_CT_EXTENDS_1_1 is used
; 16175:     * temporarily only.
; 16176:     */
; 16177:     /*
; 16178:     * SPEC (1) "If the {base type definition} is a complex type definition,
; 16179:     * then all of the following must be true:"
; 16180:     */
; 16181:     if (WXS_IS_COMPLEX(base)) {

	cmp	DWORD PTR [ecx+88], 45			; 0000002dH
	je	SHORT $LN4@xmlSchemaC

; 16354: 		}
; 16355: 		/*
; 16356: 		* URGENT TODO SPEC (1.4.3.2.2.2) "The particle of the
; 16357: 		* complex type definition must be a `valid extension`
; 16358: 		* of the {base type definition}'s particle, as defined
; 16359: 		* in Particle Valid (Extension) ($3.9.6)."
; 16360: 		*
; 16361: 		* NOTE that we won't check "Particle Valid (Extension)",
; 16362: 		* since it is ensured by the derivation process in
; 16363: 		* xmlSchemaTypeFixup(). We need to implement this when heading
; 16364: 		* for a construction API
; 16365: 		* TODO: !! This is needed to be checked if redefining a type !!
; 16366: 		*/
; 16367: 	    }
; 16368: 	    /*
; 16369: 	    * URGENT TODO (1.5)
; 16370: 	    */
; 16371: 	}
; 16372:     } else {
; 16373: 	/*
; 16374: 	* SPEC (2) "If the {base type definition} is a simple type definition,
; 16375: 	* then all of the following must be true:"
; 16376: 	*/
; 16377: 	if (type->contentTypeDef != base) {

	cmp	DWORD PTR [eax+104], ecx
	je	SHORT $LN15@xmlSchemaC

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CO@EGFIFAEL@The?5content?5type?5must?5be?5the?5si@

; 16378: 	    /*
; 16379: 	    * SPEC (2.1) "The {content type} must be the same simple type
; 16380: 	    * definition."
; 16381: 	    */
; 16382: 	    xmlSchemaPCustomErr(ctxt,
; 16383: 		XML_SCHEMAP_COS_CT_EXTENDS_1_1,
; 16384: 		WXS_BASIC_CAST type, NULL,
; 16385: 		"The content type must be the simple base type", NULL);
; 16386: 	    return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);

	jmp	SHORT $LN31@xmlSchemaC
$LN15@xmlSchemaC:

; 16387: 	}
; 16388: 	if (base->flags & XML_SCHEMAS_TYPE_FINAL_EXTENSION) {

	test	DWORD PTR [ecx+48], 512			; 00000200H
	jne	SHORT $LN30@xmlSchemaC
$LN13@xmlSchemaC:

; 16389: 	    /*
; 16390: 	    * SPEC (2.2) "The {final} of the {base type definition} must not
; 16391: 	    * contain extension"
; 16392: 	    * NOTE that this is the same as (1.1).
; 16393: 	    */
; 16394: 	    xmlSchemaPCustomErr(ctxt,
; 16395: 		XML_SCHEMAP_COS_CT_EXTENDS_1_1,
; 16396: 		WXS_BASIC_CAST type, NULL,
; 16397: 		"The 'final' of the base type definition "
; 16398: 		"contains 'extension'", NULL);
; 16399: 	    return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);
; 16400: 	}
; 16401:     }
; 16402:     return (0);

	xor	eax, eax

; 16403: }

	pop	ebp
	ret	0
$LN4@xmlSchemaC:

; 16182: 	/*
; 16183: 	* SPEC (1.1) "The {final} of the {base type definition} must not
; 16184: 	* contain extension."
; 16185: 	*/
; 16186: 	if (base->flags & XML_SCHEMAS_TYPE_FINAL_EXTENSION) {

	test	DWORD PTR [ecx+48], 512			; 00000200H
	je	SHORT $LN5@xmlSchemaC
$LN30@xmlSchemaC:

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0DN@CKGKOKMC@The?5?8final?8?5of?5the?5base?5type?5de@
$LN31@xmlSchemaC:

; 16403: }

	push	0
	push	eax
	push	3063					; 00000bf7H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
	mov	eax, 3063				; 00000bf7H
	pop	ebp
	ret	0
$LN5@xmlSchemaC:

; 16187: 	    xmlSchemaPCustomErr(ctxt,
; 16188: 		XML_SCHEMAP_COS_CT_EXTENDS_1_1,
; 16189: 		WXS_BASIC_CAST type, NULL,
; 16190: 		"The 'final' of the base type definition "
; 16191: 		"contains 'extension'", NULL);
; 16192: 	    return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);
; 16193: 	}
; 16194: 
; 16195: 	/*
; 16196: 	* ATTENTION: The constrains (1.2) and (1.3) are not applied,
; 16197: 	* since they are automatically satisfied through the
; 16198: 	* inheriting mechanism.
; 16199: 	* Note that even if redefining components, the inheriting mechanism
; 16200: 	* is used.
; 16201: 	*/
; 16202: #if 0
; 16203: 	/*
; 16204: 	* SPEC (1.2) "Its {attribute uses} must be a subset of the {attribute
; 16205: 	* uses}
; 16206: 	* of the complex type definition itself, that is, for every attribute
; 16207: 	* use in the {attribute uses} of the {base type definition}, there
; 16208: 	* must be an attribute use in the {attribute uses} of the complex
; 16209: 	* type definition itself whose {attribute declaration} has the same
; 16210: 	* {name}, {target namespace} and {type definition} as its attribute
; 16211: 	* declaration"
; 16212: 	*/
; 16213: 	if (base->attrUses != NULL) {
; 16214: 	    int i, j, found;
; 16215: 	    xmlSchemaAttributeUsePtr use, buse;
; 16216: 
; 16217: 	    for (i = 0; i < (WXS_LIST_CAST base->attrUses)->nbItems; i ++) {
; 16218: 		buse = (WXS_LIST_CAST base->attrUses)->items[i];
; 16219: 		found = 0;
; 16220: 		if (type->attrUses != NULL) {
; 16221: 		    use = (WXS_LIST_CAST type->attrUses)->items[j];
; 16222: 		    for (j = 0; j < (WXS_LIST_CAST type->attrUses)->nbItems; j ++)
; 16223: 		    {
; 16224: 			if ((WXS_ATTRUSE_DECL_NAME(use) ==
; 16225: 				WXS_ATTRUSE_DECL_NAME(buse)) &&
; 16226: 			    (WXS_ATTRUSE_DECL_TNS(use) ==
; 16227: 				WXS_ATTRUSE_DECL_TNS(buse)) &&
; 16228: 			    (WXS_ATTRUSE_TYPEDEF(use) ==
; 16229: 				WXS_ATTRUSE_TYPEDEF(buse))
; 16230: 			{
; 16231: 			    found = 1;
; 16232: 			    break;
; 16233: 			}
; 16234: 		    }
; 16235: 		}
; 16236: 		if (! found) {
; 16237: 		    xmlChar *str = NULL;
; 16238: 
; 16239: 		    xmlSchemaCustomErr(ACTXT_CAST ctxt,
; 16240: 			XML_SCHEMAP_COS_CT_EXTENDS_1_2,
; 16241: 			NULL, WXS_BASIC_CAST type,
; 16242: 			/*
; 16243: 			* TODO: The report does not indicate that also the
; 16244: 			* type needs to be the same.
; 16245: 			*/
; 16246: 			"This type is missing a matching correspondent "
; 16247: 			"for its {base type}'s %s in its {attribute uses}",
; 16248: 			xmlSchemaGetComponentDesignation(&str,
; 16249: 			    buse->children),
; 16250: 			NULL);
; 16251: 		    FREE_AND_NULL(str)
; 16252: 		}
; 16253: 	    }
; 16254: 	}
; 16255: 	/*
; 16256: 	* SPEC (1.3) "If it has an {attribute wildcard}, the complex type
; 16257: 	* definition must also have one, and the base type definition's
; 16258: 	* {attribute  wildcard}'s {namespace constraint} must be a subset
; 16259: 	* of the complex  type definition's {attribute wildcard}'s {namespace
; 16260: 	* constraint}, as defined by Wildcard Subset ($3.10.6)."
; 16261: 	*/
; 16262: 
; 16263: 	/*
; 16264: 	* MAYBE TODO: Enable if ever needed. But this will be needed only
; 16265: 	* if created the type via a schema construction API.
; 16266: 	*/
; 16267: 	if (base->attributeWildcard != NULL) {
; 16268: 	    if (type->attributeWilcard == NULL) {
; 16269: 		xmlChar *str = NULL;
; 16270: 
; 16271: 		xmlSchemaCustomErr(ACTXT_CAST pctxt,
; 16272: 		    XML_SCHEMAP_COS_CT_EXTENDS_1_3,
; 16273: 		    NULL, type,
; 16274: 		    "The base %s has an attribute wildcard, "
; 16275: 		    "but this type is missing an attribute wildcard",
; 16276: 		    xmlSchemaGetComponentDesignation(&str, base));
; 16277: 		FREE_AND_NULL(str)
; 16278: 
; 16279: 	    } else if (xmlSchemaCheckCOSNSSubset(
; 16280: 		base->attributeWildcard, type->attributeWildcard))
; 16281: 	    {
; 16282: 		xmlChar *str = NULL;
; 16283: 
; 16284: 		xmlSchemaCustomErr(ACTXT_CAST pctxt,
; 16285: 		    XML_SCHEMAP_COS_CT_EXTENDS_1_3,
; 16286: 		    NULL, type,
; 16287: 		    "The attribute wildcard is not a valid "
; 16288: 		    "superset of the one in the base %s",
; 16289: 		    xmlSchemaGetComponentDesignation(&str, base));
; 16290: 		FREE_AND_NULL(str)
; 16291: 	    }
; 16292: 	}
; 16293: #endif
; 16294: 	/*
; 16295: 	* SPEC (1.4) "One of the following must be true:"
; 16296: 	*/
; 16297: 	if ((type->contentTypeDef != NULL) &&

	mov	edx, DWORD PTR [eax+104]
	test	edx, edx
	je	SHORT $LN6@xmlSchemaC
	cmp	edx, DWORD PTR [ecx+104]
	je	SHORT $LN13@xmlSchemaC
$LN6@xmlSchemaC:

; 16298: 	    (type->contentTypeDef == base->contentTypeDef)) {
; 16299: 	    /*
; 16300: 	    * SPEC (1.4.1) "The {content type} of the {base type definition}
; 16301: 	    * and the {content type} of the complex type definition itself
; 16302: 	    * must be the same simple type definition"
; 16303: 	    * PASS
; 16304: 	    */
; 16305: 	} else if ((type->contentType == XML_SCHEMA_CONTENT_EMPTY) &&

	mov	edx, DWORD PTR [eax+52]
	cmp	edx, 1
	jne	SHORT $LN29@xmlSchemaC
	cmp	DWORD PTR [ecx+52], edx
	je	SHORT $LN13@xmlSchemaC
$LN29@xmlSchemaC:

; 16306: 	    (base->contentType == XML_SCHEMA_CONTENT_EMPTY) ) {
; 16307: 	    /*
; 16308: 	    * SPEC (1.4.2) "The {content type} of both the {base type
; 16309: 	    * definition} and the complex type definition itself must
; 16310: 	    * be empty."
; 16311: 	    * PASS
; 16312: 	    */
; 16313: 	} else {
; 16314: 	    /*
; 16315: 	    * SPEC (1.4.3) "All of the following must be true:"
; 16316: 	    */
; 16317: 	    if (type->subtypes == NULL) {

	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN10@xmlSchemaC

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CJ@LMFNPNPH@The?5content?5type?5must?5specify?5a@

; 16318: 		/*
; 16319: 		* SPEC 1.4.3.1 The {content type} of the complex type
; 16320: 		* definition itself must specify a particle.
; 16321: 		*/
; 16322: 		xmlSchemaPCustomErr(ctxt,
; 16323: 		    XML_SCHEMAP_COS_CT_EXTENDS_1_1,
; 16324: 		    WXS_BASIC_CAST type, NULL,
; 16325: 		    "The content type must specify a particle", NULL);
; 16326: 		return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);

	jmp	SHORT $LN31@xmlSchemaC
$LN10@xmlSchemaC:

; 16327: 	    }
; 16328: 	    /*
; 16329: 	    * SPEC (1.4.3.2) "One of the following must be true:"
; 16330: 	    */
; 16331: 	    if (base->contentType == XML_SCHEMA_CONTENT_EMPTY) {

	mov	ecx, DWORD PTR [ecx+52]
	cmp	ecx, 1
	je	SHORT $LN13@xmlSchemaC

; 16332: 		/*
; 16333: 		* SPEC (1.4.3.2.1) "The {content type} of the {base type
; 16334: 		* definition} must be empty.
; 16335: 		* PASS
; 16336: 		*/
; 16337: 	    } else {
; 16338: 		/*
; 16339: 		* SPEC (1.4.3.2.2) "All of the following must be true:"
; 16340: 		*/
; 16341: 		if ((type->contentType != base->contentType) ||

	cmp	edx, ecx
	jne	SHORT $LN14@xmlSchemaC
	cmp	edx, 3
	je	SHORT $LN13@xmlSchemaC
	cmp	edx, 2
	je	SHORT $LN13@xmlSchemaC
$LN14@xmlSchemaC:

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0FM@GPKINKDA@The?5content?5type?5of?5both?0?5the?5t@

; 16342: 		    ((type->contentType != XML_SCHEMA_CONTENT_MIXED) &&
; 16343: 		    (type->contentType != XML_SCHEMA_CONTENT_ELEMENTS))) {
; 16344: 		    /*
; 16345: 		    * SPEC (1.4.3.2.2.1) "Both {content type}s must be mixed
; 16346: 		    * or both must be element-only."
; 16347: 		    */
; 16348: 		    xmlSchemaPCustomErr(ctxt,
; 16349: 			XML_SCHEMAP_COS_CT_EXTENDS_1_1,
; 16350: 			WXS_BASIC_CAST type, NULL,
; 16351: 			"The content type of both, the type and its base "
; 16352: 			"type, must either 'mixed' or 'element-only'", NULL);
; 16353: 		    return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);

	jmp	SHORT $LN31@xmlSchemaC
_xmlSchemaCheckCOSCTExtends ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckCOSDerivedOK
_TEXT	SEGMENT
_actxt$ = 8						; size = 4
_type$ = 12						; size = 4
_baseType$ = 16						; size = 4
_set$ = 20						; size = 4
_xmlSchemaCheckCOSDerivedOK PROC			; COMDAT

; 16144: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	SHORT $LN4@xmlSchemaC

; 16145:     if (WXS_IS_SIMPLE(type))

	cmp	ecx, 1
	jne	SHORT $LN2@xmlSchemaC
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	jne	SHORT $LN4@xmlSchemaC
$LN2@xmlSchemaC:

; 16147:     else
; 16148: 	return (xmlSchemaCheckCOSCTDerivedOK(actxt, type, baseType, set));

	mov	DWORD PTR _type$[ebp], eax

; 16149: }

	pop	ebp

; 16147:     else
; 16148: 	return (xmlSchemaCheckCOSCTDerivedOK(actxt, type, baseType, set));

	jmp	_xmlSchemaCheckCOSCTDerivedOK
$LN4@xmlSchemaC:

; 16146: 	return (xmlSchemaCheckCOSSTDerivedOK(actxt, type, baseType, set));

	mov	DWORD PTR _type$[ebp], eax

; 16149: }

	pop	ebp

; 16146: 	return (xmlSchemaCheckCOSSTDerivedOK(actxt, type, baseType, set));

	jmp	_xmlSchemaCheckCOSSTDerivedOK
_xmlSchemaCheckCOSDerivedOK ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckCOSCTDerivedOK
_TEXT	SEGMENT
_actxt$ = 8						; size = 4
_type$ = 12						; size = 4
_baseType$ = 16						; size = 4
_set$ = 20						; size = 4
_xmlSchemaCheckCOSCTDerivedOK PROC			; COMDAT

; 16073: {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR _set$[ebp]
	push	esi
	mov	esi, DWORD PTR _type$[ebp]
	push	edi
	mov	edi, DWORD PTR _baseType$[ebp]
	npad	1
$LL17@xmlSchemaC:
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4

; 16048:     if ((typeA == NULL) || (typeB == NULL))

	test	esi, esi
	je	SHORT $LN25@xmlSchemaC
	test	edi, edi
	je	SHORT $LN25@xmlSchemaC

; 16074:     int equal = xmlSchemaAreEqualTypes(type, baseType);
; 16075:     /* TODO: Error codes. */
; 16076:     /*
; 16077:     * SPEC "For a complex type definition (call it D, for derived)
; 16078:     * to be validly derived from a type definition (call this
; 16079:     * B, for base) given a subset of {extension, restriction}
; 16080:     * all of the following must be true:"
; 16081:     */
; 16082:     if (! equal) {

	cmp	esi, edi
	je	SHORT $LN2@xmlSchemaC
$LN25@xmlSchemaC:

; 16083: 	/*
; 16084: 	* SPEC (1) "If B and D are not the same type definition, then the
; 16085: 	* {derivation method} of D must not be in the subset."
; 16086: 	*/
; 16087: 	if (((set & SUBSET_EXTENSION) && (WXS_IS_EXTENSION(type))) ||

	test	bl, 2
	je	SHORT $LN27@xmlSchemaC
	test	BYTE PTR [esi+48], 2
	jne	SHORT $LN20@xmlSchemaC
$LN27@xmlSchemaC:
	test	bl, 1
	je	SHORT $LN26@xmlSchemaC
	test	BYTE PTR [esi+48], 4
	jne	SHORT $LN20@xmlSchemaC
$LN26@xmlSchemaC:

; 16088: 	    ((set & SUBSET_RESTRICTION) && (WXS_IS_RESTRICTION(type))))
; 16089: 	    return (1);
; 16090:     } else {
; 16091: 	/*
; 16092: 	* SPEC (2.1) "B and D must be the same type definition."
; 16093: 	*/
; 16094: 	return (0);
; 16095:     }
; 16096:     /*
; 16097:     * SPEC (2.2) "B must be D's {base type definition}."
; 16098:     */
; 16099:     if (type->baseType == baseType)

	mov	esi, DWORD PTR [esi+64]
	cmp	esi, edi
	je	SHORT $LN2@xmlSchemaC

; 16100: 	return (0);
; 16101:     /*
; 16102:     * SPEC (2.3.1) "D's {base type definition} must not be the `ur-type
; 16103:     * definition`."
; 16104:     */
; 16105:     if (WXS_IS_ANYTYPE(type->baseType))

	mov	eax, DWORD PTR [esi]
	cmp	eax, 1
	jne	SHORT $LN28@xmlSchemaC
	cmp	DWORD PTR [esi+88], 45			; 0000002dH
	je	SHORT $LN20@xmlSchemaC
$LN28@xmlSchemaC:

; 16106: 	return (1);
; 16107: 
; 16108:     if (WXS_IS_COMPLEX(type->baseType)) {

	cmp	eax, 5
	je	SHORT $LL17@xmlSchemaC
	cmp	DWORD PTR [esi+88], 45			; 0000002dH
	je	SHORT $LL17@xmlSchemaC

; 16109: 	/*
; 16110: 	* SPEC (2.3.2.1) "If D's {base type definition} is complex, then it
; 16111: 	* must be validly derived from B given the subset as defined by this
; 16112: 	* constraint."
; 16113: 	*/
; 16114: 	return (xmlSchemaCheckCOSCTDerivedOK(actxt, type->baseType,
; 16115: 	    baseType, set));
; 16116:     } else {
; 16117: 	/*
; 16118: 	* SPEC (2.3.2.2) "If D's {base type definition} is simple, then it
; 16119: 	* must be validly derived from B given the subset as defined in Type
; 16120: 	* Derivation OK (Simple) ($3.14.6).
; 16121: 	*/
; 16122: 	return (xmlSchemaCheckCOSSTDerivedOK(actxt, type->baseType,

	push	ebx
	push	edi
	push	esi
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaCheckCOSSTDerivedOK
	add	esp, 16					; 00000010H
	pop	edi

; 16123: 	    baseType, set));
; 16124:     }
; 16125: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN20@xmlSchemaC:
	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	pop	ebp
	ret	0
$LN2@xmlSchemaC:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaCheckCOSCTDerivedOK ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAreEqualTypes
_TEXT	SEGMENT
_typeA$ = 8						; size = 4
_typeB$ = 12						; size = 4
_xmlSchemaAreEqualTypes PROC				; COMDAT

; 16043: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _typeA$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlSchemaA

; 16044:     /*
; 16045:     * TODO: This should implement component-identity
; 16046:     * in the future.
; 16047:     */
; 16048:     if ((typeA == NULL) || (typeB == NULL))

	mov	ecx, DWORD PTR _typeB$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlSchemaA

; 16050:     return (typeA == typeB);

	xor	eax, eax
	cmp	edx, ecx
	sete	al

; 16051: }

	pop	ebp
	ret	0
$LN3@xmlSchemaA:

; 16049: 	return (0);

	xor	eax, eax

; 16051: }

	pop	ebp
	ret	0
_xmlSchemaAreEqualTypes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckCTPropsCorrect
_TEXT	SEGMENT
_hasId$1$ = -16						; size = 4
_uses$1$ = -12						; size = 4
_use$1$ = -8						; size = 4
_str$1 = -8						; size = 4
_str$2 = -4						; size = 4
_pctxt$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlSchemaCheckCTPropsCorrect PROC			; COMDAT

; 15924: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _type$[ebp]
	mov	eax, DWORD PTR [edx+64]
	test	eax, eax
	je	SHORT $LN8@xmlSchemaC

; 15925:     /*
; 15926:     * TODO: Correct the error code; XML_SCHEMAP_SRC_CT_1 is used temporarily.
; 15927:     *
; 15928:     * SPEC (1) "The values of the properties of a complex type definition must
; 15929:     * be as described in the property tableau in The Complex Type Definition
; 15930:     * Schema Component ($3.4.1), modulo the impact of Missing
; 15931:     * Sub-components ($5.3)."
; 15932:     */
; 15933:     if ((type->baseType != NULL) &&
; 15934: 	(WXS_IS_SIMPLE(type->baseType)) &&

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	SHORT $LN9@xmlSchemaC
	cmp	ecx, 1
	jne	SHORT $LN8@xmlSchemaC
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	je	SHORT $LN8@xmlSchemaC
$LN9@xmlSchemaC:
	test	BYTE PTR [edx+48], 2
	jne	SHORT $LN8@xmlSchemaC

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0EN@DHFNNJDJ@If?5the?5base?5type?5is?5a?5simple?5ty@
	push	edx
	push	0
	push	3076					; 00000c04H
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaCustomErr4
	add	esp, 36					; 00000024H

; 15935: 	(WXS_IS_EXTENSION(type) == 0)) {
; 15936: 	/*
; 15937: 	* SPEC (2) "If the {base type definition} is a simple type definition,
; 15938: 	* the {derivation method} must be extension."
; 15939: 	*/
; 15940: 	xmlSchemaCustomErr(ACTXT_CAST pctxt,
; 15941: 	    XML_SCHEMAP_SRC_CT_1,
; 15942: 	    NULL, WXS_BASIC_CAST type,
; 15943: 	    "If the base type is a simple type, the derivation method must be "
; 15944: 	    "'extension'", NULL, NULL);
; 15945: 	return (XML_SCHEMAP_SRC_CT_1);

	mov	eax, 3076				; 00000c04H

; 16038: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlSchemaC:
	push	ebx
	push	esi

; 15946:     }
; 15947:     /*
; 15948:     * SPEC (3) "Circular definitions are disallowed, except for the `ur-type
; 15949:     * definition`. That is, it must be possible to reach the `ur-type
; 15950:     * definition` by repeatedly following the {base type definition}."
; 15951:     *
; 15952:     * NOTE (3) is done in xmlSchemaCheckTypeDefCircular().
; 15953:     */
; 15954:     /*
; 15955:     * NOTE that (4) and (5) need the following:
; 15956:     *   - attribute uses need to be already inherited (apply attr. prohibitions)
; 15957:     *   - attribute group references need to be expanded already
; 15958:     *   - simple types need to be typefixed already
; 15959:     */
; 15960:     if (type->attrUses &&

	mov	esi, DWORD PTR [edx+116]
	mov	DWORD PTR _uses$1$[ebp], esi
	push	edi
	test	esi, esi
	je	$LN40@xmlSchemaC
	mov	edi, DWORD PTR [esi+4]
	cmp	edi, 1
	jle	$LN40@xmlSchemaC

; 15961: 	(((xmlSchemaItemListPtr) type->attrUses)->nbItems > 1))
; 15962:     {
; 15963: 	xmlSchemaItemListPtr uses = (xmlSchemaItemListPtr) type->attrUses;
; 15964: 	xmlSchemaAttributeUsePtr use, tmp;
; 15965: 	int i, j, hasId = 0;
; 15966: 
; 15967: 	for (i = uses->nbItems -1; i >= 0; i--) {

	add	edi, -1
	mov	DWORD PTR _hasId$1$[ebp], 0
	js	$LN40@xmlSchemaC
$LL4@xmlSchemaC:

; 15968: 	    use = uses->items[i];

	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR _use$1$[ebp], ebx

; 15969: 
; 15970: 	    /*
; 15971: 	    * SPEC ct-props-correct
; 15972: 	    * (4) "Two distinct attribute declarations in the
; 15973: 	    * {attribute uses} must not have identical {name}s and
; 15974: 	    * {target namespace}s."
; 15975: 	    */
; 15976: 	    if (i > 0) {

	test	edi, edi
	jle	SHORT $LN39@xmlSchemaC

; 15977: 		for (j = i -1; j >= 0; j--) {

	lea	ecx, DWORD PTR [edi-1]
	cmp	edi, 1
	jl	SHORT $LN39@xmlSchemaC

; 15978: 		    tmp = uses->items[j];
; 15979: 		    if ((WXS_ATTRUSE_DECL_NAME(use) ==
; 15980: 			WXS_ATTRUSE_DECL_NAME(tmp)) &&

	mov	ebx, DWORD PTR [ebx+12]
	lea	edx, DWORD PTR [edi-1]
	lea	edx, DWORD PTR [eax+edx*4]
$LL7@xmlSchemaC:
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [ebx+8]
	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN5@xmlSchemaC
	mov	eax, DWORD PTR [ebx+56]
	cmp	eax, DWORD PTR [esi+56]
	je	$LN29@xmlSchemaC
$LN5@xmlSchemaC:

; 15977: 		for (j = i -1; j >= 0; j--) {

	sub	edx, 4
	sub	ecx, 1
	jns	SHORT $LL7@xmlSchemaC
	mov	ebx, DWORD PTR _use$1$[ebp]
	mov	esi, DWORD PTR _uses$1$[ebp]
$LN39@xmlSchemaC:

; 15997: 			    goto exit_failure;
; 15998: 			goto next_use;
; 15999: 		    }
; 16000: 		}
; 16001: 	    }
; 16002: 	    /*
; 16003: 	    * SPEC ct-props-correct
; 16004: 	    * (5) "Two distinct attribute declarations in the
; 16005: 	    * {attribute uses} must not have {type definition}s which
; 16006: 	    * are or are derived from ID."
; 16007: 	    */
; 16008: 	    if (WXS_ATTRUSE_TYPEDEF(use) != NULL) {

	mov	eax, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [eax+48]
	test	eax, eax
	je	SHORT $next_use$46

; 16009: 		if (xmlSchemaIsDerivedFromBuiltInType(

	push	23					; 00000017H
	push	eax
	call	_xmlSchemaIsDerivedFromBuiltInType
	add	esp, 8
	test	eax, eax
	je	SHORT $next_use$46

; 16010: 		    WXS_ATTRUSE_TYPEDEF(use), XML_SCHEMAS_ID))
; 16011: 		{
; 16012: 		    if (hasId) {

	cmp	DWORD PTR _hasId$1$[ebp], 0
	je	SHORT $LN19@xmlSchemaC

; 16013: 			xmlChar *str = NULL;
; 16014: 
; 16015: 			xmlSchemaCustomErr(ACTXT_CAST pctxt,

	lea	eax, DWORD PTR _str$1[ebp]
	mov	DWORD PTR _str$1[ebp], 0
	push	ebx
	push	eax
	call	_xmlSchemaGetComponentDesignation

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	0
	push	0
	push	0
	push	eax
	push	OFFSET ??_C@_0IE@LIFNGLDM@There?5must?5not?5exist?5more?5than?5@
	push	DWORD PTR _type$[ebp]
	push	0
	push	3087					; 00000c0fH
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaCustomErr4

; 16016: 			    XML_SCHEMAP_AG_PROPS_CORRECT,
; 16017: 			    NULL, WXS_BASIC_CAST type,
; 16018: 			    "There must not exist more than one attribute "
; 16019: 			    "declaration of type 'xs:ID' "
; 16020: 			    "(or derived from 'xs:ID'). The %s violates this "
; 16021: 			    "constraint",
; 16022: 			    xmlSchemaGetComponentDesignation(&str, use),
; 16023: 			    NULL);
; 16024: 			FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$1[ebp]

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	add	esp, 44					; 0000002cH

; 16016: 			    XML_SCHEMAP_AG_PROPS_CORRECT,
; 16017: 			    NULL, WXS_BASIC_CAST type,
; 16018: 			    "There must not exist more than one attribute "
; 16019: 			    "declaration of type 'xs:ID' "
; 16020: 			    "(or derived from 'xs:ID'). The %s violates this "
; 16021: 			    "constraint",
; 16022: 			    xmlSchemaGetComponentDesignation(&str, use),
; 16023: 			    NULL);
; 16024: 			FREE_AND_NULL(str);

	test	eax, eax
	je	SHORT $LN18@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN18@xmlSchemaC:

; 16025: 			if (xmlSchemaItemListRemove(uses, i) == -1)

	push	edi
	push	esi
	call	_xmlSchemaItemListRemove
	add	esp, 8
	cmp	eax, -1
	je	SHORT $exit_failure$47
$LN19@xmlSchemaC:

; 16026: 			    goto exit_failure;
; 16027: 		    }
; 16028: 
; 16029: 		    hasId = 1;

	mov	DWORD PTR _hasId$1$[ebp], 1
$next_use$46:

; 15961: 	(((xmlSchemaItemListPtr) type->attrUses)->nbItems > 1))
; 15962:     {
; 15963: 	xmlSchemaItemListPtr uses = (xmlSchemaItemListPtr) type->attrUses;
; 15964: 	xmlSchemaAttributeUsePtr use, tmp;
; 15965: 	int i, j, hasId = 0;
; 15966: 
; 15967: 	for (i = uses->nbItems -1; i >= 0; i--) {

	sub	edi, 1
	jns	$LL4@xmlSchemaC
$LN40@xmlSchemaC:
	pop	edi
	pop	esi

; 16030: 		}
; 16031: 	    }
; 16032: next_use: {}
; 16033: 	}
; 16034:     }
; 16035:     return (0);

	xor	eax, eax
	pop	ebx

; 16038: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlSchemaC:

; 15981: 			(WXS_ATTRUSE_DECL_TNS(use) ==
; 15982: 			WXS_ATTRUSE_DECL_TNS(tmp)))
; 15983: 		    {
; 15984: 			xmlChar *str = NULL;
; 15985: 
; 15986: 			xmlSchemaCustomErr(ACTXT_CAST pctxt,

	push	DWORD PTR _use$1$[ebp]
	lea	eax, DWORD PTR _str$2[ebp]
	mov	DWORD PTR _str$2[ebp], 0
	push	eax
	call	_xmlSchemaGetComponentDesignation

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	0
	push	0
	push	0
	push	eax
	push	OFFSET ??_C@_0N@NMANGDLF@Duplicate?5?$CFs@
	push	DWORD PTR _type$[ebp]
	push	0
	push	3087					; 00000c0fH
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaCustomErr4

; 15987: 			    XML_SCHEMAP_AG_PROPS_CORRECT,
; 15988: 			    NULL, WXS_BASIC_CAST type,
; 15989: 			    "Duplicate %s",
; 15990: 			    xmlSchemaGetComponentDesignation(&str, use),
; 15991: 			    NULL);
; 15992: 			FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$2[ebp]

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	add	esp, 44					; 0000002cH

; 15987: 			    XML_SCHEMAP_AG_PROPS_CORRECT,
; 15988: 			    NULL, WXS_BASIC_CAST type,
; 15989: 			    "Duplicate %s",
; 15990: 			    xmlSchemaGetComponentDesignation(&str, use),
; 15991: 			    NULL);
; 15992: 			FREE_AND_NULL(str);

	test	eax, eax
	je	SHORT $LN13@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlSchemaC:

; 15993: 			/*
; 15994: 			* Remove the duplicate.
; 15995: 			*/
; 15996: 			if (xmlSchemaItemListRemove(uses, i) == -1)

	mov	esi, DWORD PTR _uses$1$[ebp]
	push	edi
	push	esi
	call	_xmlSchemaItemListRemove
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $next_use$46
$exit_failure$47:
	pop	edi
	pop	esi

; 16036: exit_failure:
; 16037:     return(-1);

	or	eax, -1
	pop	ebx

; 16038: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCheckCTPropsCorrect ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseCheckCOSValidDefault
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_type$ = 16						; size = 4
_value$ = 20						; size = 4
_val$ = 24						; size = 4
_xmlSchemaParseCheckCOSValidDefault PROC		; COMDAT

; 15849: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [esi], 5
	je	SHORT $LN19@xmlSchemaP

; 15850:     int ret = 0;
; 15851: 
; 15852:     /*
; 15853:     * cos-valid-default:
; 15854:     * Schema Component Constraint: Element Default Valid (Immediate)
; 15855:     * For a string to be a valid default with respect to a type
; 15856:     * definition the appropriate case among the following must be true:
; 15857:     */
; 15858:     if WXS_IS_COMPLEX(type) {

	cmp	DWORD PTR [esi+88], 45			; 0000002dH
	jne	SHORT $LN4@xmlSchemaP
$LN19@xmlSchemaP:

; 15859: 	/*
; 15860: 	* Complex type.
; 15861: 	*
; 15862: 	* SPEC (2.1) "its {content type} must be a simple type definition
; 15863: 	* or mixed."
; 15864: 	* SPEC (2.2.2) "If the {content type} is mixed, then the {content
; 15865: 	* type}'s particle must be `emptiable` as defined by
; 15866: 	* Particle Emptiable ($3.9.6)."
; 15867: 	*/
; 15868: 	if ((! WXS_HAS_SIMPLE_CONTENT(type)) &&

	mov	eax, DWORD PTR [esi+52]
	cmp	eax, 4
	je	SHORT $LN4@xmlSchemaP
	cmp	eax, 6
	je	SHORT $LN4@xmlSchemaP
	cmp	eax, 3
	jne	SHORT $LN5@xmlSchemaP
	push	DWORD PTR [esi+28]
	call	_xmlSchemaIsParticleEmptiable
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@xmlSchemaP
$LN5@xmlSchemaP:

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0IM@DDPGDFGG@For?5a?5string?5to?5be?5a?5valid?5defa@
	push	DWORD PTR [esi+36]
	push	esi
	push	3059					; 00000bf3H
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 15869: 	    ((! WXS_HAS_MIXED_CONTENT(type)) || (! WXS_EMPTIABLE(type)))) {
; 15870: 	    /* NOTE that this covers (2.2.2) as well. */
; 15871: 	    xmlSchemaPCustomErr(pctxt,
; 15872: 		XML_SCHEMAP_COS_VALID_DEFAULT_2_1,
; 15873: 		WXS_BASIC_CAST type, type->node,
; 15874: 		"For a string to be a valid default, the type definition "
; 15875: 		"must be a simple type or a complex type with mixed content "
; 15876: 		"and a particle emptiable", NULL);
; 15877: 	    return(XML_SCHEMAP_COS_VALID_DEFAULT_2_1);

	mov	eax, 3059				; 00000bf3H
	pop	esi

; 15906: }

	pop	ebp
	ret	0
$LN4@xmlSchemaP:

; 15878: 	}
; 15879:     }
; 15880:     /*
; 15881:     * 1 If the type definition is a simple type definition, then the string
; 15882:     * must be `valid` with respect to that definition as defined by String
; 15883:     * Valid ($3.14.4).
; 15884:     *
; 15885:     * AND
; 15886:     *
; 15887:     * 2.2.1 If the {content type} is a simple type definition, then the
; 15888:     * string must be `valid` with respect to that simple type definition
; 15889:     * as defined by String Valid ($3.14.4).
; 15890:     */
; 15891:     if (WXS_IS_SIMPLE(type))

	mov	eax, DWORD PTR [esi]
	cmp	eax, 4
	je	SHORT $LN8@xmlSchemaP
	cmp	eax, 1
	jne	SHORT $LN6@xmlSchemaP
	cmp	DWORD PTR [esi+88], 45			; 0000002dH
	jne	SHORT $LN8@xmlSchemaP
$LN6@xmlSchemaP:

; 15892: 	ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST pctxt, node,
; 15893: 	    type, value, val, 1, 1, 0);
; 15894:     else if (WXS_HAS_SIMPLE_CONTENT(type))

	mov	eax, DWORD PTR [esi+52]
	cmp	eax, 4
	je	SHORT $LN11@xmlSchemaP
	cmp	eax, 6
	je	SHORT $LN11@xmlSchemaP

; 15896: 	    type->contentTypeDef, value, val, 1, 1, 0);
; 15897:     else
; 15898: 	return (ret);

	xor	eax, eax
	pop	esi

; 15906: }

	pop	ebp
	ret	0
$LN11@xmlSchemaP:

; 15895: 	ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST pctxt, node,

	mov	esi, DWORD PTR [esi+104]
$LN8@xmlSchemaP:
	push	edi

; 15899: 
; 15900:     if (ret < 0) {

	push	0
	push	1
	push	1
	push	DWORD PTR _val$[ebp]
	push	DWORD PTR _value$[ebp]
	push	esi
	push	DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR _pctxt$[ebp]
	push	esi
	call	_xmlSchemaVCheckCVCSimpleType
	mov	edi, eax
	add	esp, 32					; 00000020H
	test	edi, edi
	jns	SHORT $LN16@xmlSchemaP

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CH@HOPMNJDI@calling?5xmlSchemaVCheckCVCSimpl@
	push	OFFSET ??_C@_0CD@MOGOJILI@xmlSchemaParseCheckCOSValidDefa@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$LN16@xmlSchemaP:

; 15901: 	PERROR_INT("xmlSchemaParseCheckCOSValidDefault",
; 15902: 	    "calling xmlSchemaVCheckCVCSimpleType()");
; 15903:     }
; 15904: 
; 15905:     return (ret);

	mov	eax, edi
	pop	edi
	pop	esi

; 15906: }

	pop	ebp
	ret	0
_xmlSchemaParseCheckCOSValidDefault ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaVCheckCVCSimpleType
_TEXT	SEGMENT
tv1237 = -32						; size = 4
_nsName$1$ = -28					; size = 4
_isNormalized$1$ = -28					; size = 4
_prevVal$1$ = -24					; size = 4
_len$1$ = -20						; size = 4
_tmpValue$1$ = -16					; size = 4
_prefix$1 = -16						; size = 4
_normValue$1$ = -12					; size = 4
_valNeeded$1$ = -8					; size = 4
_val$ = -4						; size = 4
_actxt$ = 8						; size = 4
_node$ = 12						; size = 4
_value$5$ = 16						; size = 4
_type$ = 16						; size = 4
tv1224 = 20						; size = 4
_local$1$ = 20						; size = 4
_value$7$ = 20						; size = 4
_curVal$2 = 20						; size = 4
_value$ = 20						; size = 4
_retVal$ = 24						; size = 4
_fireErrors$ = 28					; size = 4
_normalize$ = 32					; size = 4
_isNormalized$ = 36					; size = 4
_xmlSchemaVCheckCVCSimpleType PROC			; COMDAT

; 24517: {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _retVal$[ebp]
	xor	esi, esi
	xor	eax, eax
	mov	DWORD PTR _val$[ebp], esi
	test	ebx, ebx
	mov	DWORD PTR _normValue$1$[ebp], esi
	setne	al
	mov	DWORD PTR _valNeeded$1$[ebp], eax
	test	ebx, ebx
	je	SHORT $LN149@xmlSchemaV

; 24518:     int ret = 0, valNeeded = (retVal) ? 1 : 0;
; 24519:     xmlSchemaValPtr val = NULL;
; 24520:     /* xmlSchemaWhitespaceValueType ws; */
; 24521:     xmlChar *normValue = NULL;
; 24522: 
; 24523: #define NORMALIZE(atype) \
; 24524:     if ((! isNormalized) && \
; 24525:     (normalize || (type->flags & XML_SCHEMAS_TYPE_NORMVALUENEEDED))) { \
; 24526: 	normValue = xmlSchemaNormalizeValue(atype, value); \
; 24527: 	if (normValue != NULL) \
; 24528: 	    value = normValue; \
; 24529: 	isNormalized = 1; \
; 24530:     }
; 24531: 
; 24532:     if ((retVal != NULL) && (*retVal != NULL)) {

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN171@xmlSchemaV

; 24533: 	xmlSchemaFreeValue(*retVal);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4

; 24534: 	*retVal = NULL;

	mov	DWORD PTR [ebx], esi
$LN171@xmlSchemaV:

; 24559: 	valNeeded = 1;
; 24560:     if (value == NULL)
; 24561: 	value = BAD_CAST "";
; 24562:     if (WXS_IS_ANY_SIMPLE_TYPE(type) || WXS_IS_ATOMIC(type)) {

	mov	ebx, DWORD PTR _type$[ebp]
$LN18@xmlSchemaV:
	mov	eax, DWORD PTR _value$[ebp]
	mov	edi, OFFSET ??_C@_00CNPNBAHC@@
	test	eax, eax
	cmovne	edi, eax
	cmp	DWORD PTR [ebx], 1
	jne	SHORT $LN23@xmlSchemaV
	cmp	DWORD PTR [ebx+88], 46			; 0000002eH
	je	SHORT $LN154@xmlSchemaV
$LN23@xmlSchemaV:
	mov	eax, DWORD PTR [ebx+48]
	test	eax, 256				; 00000100H
	je	$LN20@xmlSchemaV
$LN154@xmlSchemaV:

; 24563: 	xmlSchemaTypePtr biType; /* The built-in type. */
; 24564: 	/*
; 24565: 	* SPEC (1.2.1) "if {variety} is `atomic` then the string must `match`
; 24566: 	* a literal in the `lexical space` of {base type definition}"
; 24567: 	*/
; 24568: 	/*
; 24569: 	* Whitespace-normalize.
; 24570: 	*/
; 24571: 	NORMALIZE(type);

	mov	ebx, edi
	cmp	DWORD PTR _isNormalized$[ebp], esi
	jne	SHORT $LN168@xmlSchemaV
	cmp	DWORD PTR _normalize$[ebp], esi
	mov	esi, DWORD PTR _type$[ebp]
	jne	SHORT $LN155@xmlSchemaV
	test	DWORD PTR [esi+48], 268435456		; 10000000H
	je	SHORT $LN26@xmlSchemaV
$LN155@xmlSchemaV:
	push	edi
	push	esi
	call	_xmlSchemaNormalizeValue
	mov	edx, eax
	add	esp, 8
	test	edx, edx
	mov	DWORD PTR _normValue$1$[ebp], edx
	mov	ebx, edi
	cmovne	ebx, edx
	jmp	SHORT $LN26@xmlSchemaV
$LN149@xmlSchemaV:

; 24535:     }
; 24536:     /*
; 24537:     * 3.14.4 Simple Type Definition Validation Rules
; 24538:     * Validation Rule: String Valid
; 24539:     */
; 24540:     /*
; 24541:     * 1 It is schema-valid with respect to that definition as defined
; 24542:     * by Datatype Valid in [XML Schemas: Datatypes].
; 24543:     */
; 24544:     /*
; 24545:     * 2.1 If The definition is ENTITY or is validly derived from ENTITY given
; 24546:     * the empty set, as defined in Type Derivation OK (Simple) ($3.14.6), then
; 24547:     * the string must be a `declared entity name`.
; 24548:     */
; 24549:     /*
; 24550:     * 2.2 If The definition is ENTITIES or is validly derived from ENTITIES
; 24551:     * given the empty set, as defined in Type Derivation OK (Simple) ($3.14.6),
; 24552:     * then every whitespace-delimited substring of the string must be a `declared
; 24553:     * entity name`.
; 24554:     */
; 24555:     /*
; 24556:     * 2.3 otherwise no further condition applies.
; 24557:     */
; 24558:     if ((! valNeeded) && (type->flags & XML_SCHEMAS_TYPE_FACETSNEEDVALUE))

	mov	ebx, DWORD PTR _type$[ebp]
	mov	ecx, 1
	test	DWORD PTR [ebx+48], 2097152		; 00200000H
	cmovne	eax, ecx
	mov	DWORD PTR _valNeeded$1$[ebp], eax
	jmp	SHORT $LN18@xmlSchemaV
$LN168@xmlSchemaV:

; 24563: 	xmlSchemaTypePtr biType; /* The built-in type. */
; 24564: 	/*
; 24565: 	* SPEC (1.2.1) "if {variety} is `atomic` then the string must `match`
; 24566: 	* a literal in the `lexical space` of {base type definition}"
; 24567: 	*/
; 24568: 	/*
; 24569: 	* Whitespace-normalize.
; 24570: 	*/
; 24571: 	NORMALIZE(type);

	mov	esi, DWORD PTR _type$[ebp]
$LN26@xmlSchemaV:

; 24572: 	if (type->type != XML_SCHEMA_TYPE_BASIC) {

	cmp	DWORD PTR [esi], 1
	je	SHORT $LN27@xmlSchemaV

; 24573: 	    /*
; 24574: 	    * Get the built-in type.
; 24575: 	    */
; 24576: 	    biType = type->baseType;

	mov	edi, DWORD PTR [esi+64]

; 24577: 	    while ((biType != NULL) &&

	test	edi, edi
	je	SHORT $LN148@xmlSchemaV
	npad	4
$LL2@xmlSchemaV:
	cmp	DWORD PTR [edi], 1
	je	SHORT $LN28@xmlSchemaV

; 24578: 		(biType->type != XML_SCHEMA_TYPE_BASIC))
; 24579: 		biType = biType->baseType;

	mov	edi, DWORD PTR [edi+64]
	test	edi, edi
	jne	SHORT $LL2@xmlSchemaV
$LN148@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CA@NBJHIEJL@could?5not?5get?5the?5built?9in?5type@
	push	OFFSET ??_C@_0BN@DBANEELH@xmlSchemaVCheckCVCSimpleType@
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 24580: 
; 24581: 	    if (biType == NULL) {
; 24582: 		AERROR_INT("xmlSchemaVCheckCVCSimpleType",
; 24583: 		    "could not get the built-in type");
; 24584: 		goto internal_error;

	jmp	$internal_error$185
$LN27@xmlSchemaV:

; 24585: 	    }
; 24586: 	} else
; 24587: 	    biType = type;

	mov	edi, esi
$LN28@xmlSchemaV:

; 24588: 	/*
; 24589: 	* NOTATIONs need to be processed here, since they need
; 24590: 	* to lookup in the hashtable of NOTATION declarations of the schema.
; 24591: 	*/
; 24592: 	if (actxt->type == XML_SCHEMA_CTXT_VALIDATOR) {

	mov	esi, DWORD PTR _actxt$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, 2
	jne	$LN30@xmlSchemaV

; 24593: 	    switch (biType->builtInType) {

	mov	ecx, DWORD PTR [edi+88]
	cmp	ecx, 21					; 00000015H
	je	SHORT $LN33@xmlSchemaV
	cmp	ecx, 28					; 0000001cH
	je	SHORT $LN32@xmlSchemaV
$LN176@xmlSchemaV:

; 24637: 	}
; 24638: 	if (ret != 0) {

	cmp	DWORD PTR _valNeeded$1$[ebp], 0
	push	eax
	je	SHORT $LN35@xmlSchemaV
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	push	ebx
	push	edi
	call	_xmlSchemaValPredefTypeNodeNoNorm
	add	esp, 16					; 00000010H
	jmp	$LN174@xmlSchemaV
$LN35@xmlSchemaV:
	push	0
	push	ebx
	push	edi
	call	_xmlSchemaValPredefTypeNodeNoNorm
	add	esp, 16					; 00000010H
	jmp	$LN174@xmlSchemaV
$LN32@xmlSchemaV:

; 24594: 		case XML_SCHEMAS_NOTATION:
; 24595: 		    ret = xmlSchemaValidateNotation(

	push	DWORD PTR _valNeeded$1$[ebp]
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	push	ebx
	push	0
	push	DWORD PTR [esi+20]
	push	esi

; 24596: 			(xmlSchemaValidCtxtPtr) actxt,
; 24597: 			((xmlSchemaValidCtxtPtr) actxt)->schema,
; 24598: 			NULL, value, &val, valNeeded);
; 24599: 		    break;

	jmp	$LN175@xmlSchemaV
$LN33@xmlSchemaV:

; 24452:     ret = xmlValidateQName(value, 1);

	push	1
	push	ebx
	mov	DWORD PTR _prefix$1[ebp], 0
	call	_xmlValidateQName
	add	esp, 8

; 24453:     if (ret != 0) {

	test	eax, eax
	je	SHORT $LN105@xmlSchemaV

; 24454: 	if (ret == -1) {

	cmp	eax, -1
	jne	$LN44@xmlSchemaV

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BL@JAPCPOMD@calling?5xmlValidateQName?$CI?$CJ@
	push	OFFSET ??_C@_0BH@PCDDHFLC@xmlSchemaValidateQName@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 24457: 	    return (-1);

	jmp	$LN151@xmlSchemaV
$LN105@xmlSchemaV:

; 24458: 	}
; 24459: 	return( XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1);
; 24460:     }
; 24461:     /*
; 24462:     * NOTE: xmlSplitQName2 will always return a duplicated
; 24463:     * strings.
; 24464:     */
; 24465:     local = xmlSplitQName2(value, &prefix);

	lea	eax, DWORD PTR _prefix$1[ebp]
	push	eax
	push	ebx
	call	_xmlSplitQName2
	add	esp, 8
	mov	DWORD PTR _local$1$[ebp], eax

; 24466:     if (local == NULL)

	test	eax, eax
	jne	SHORT $LN107@xmlSchemaV

; 24467: 	local = xmlStrdup(value);

	push	ebx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _local$1$[ebp], eax
$LN107@xmlSchemaV:

; 24468:     /*
; 24469:     * OPTIMIZE TODO: Use flags for:
; 24470:     *  - is there any namespace binding?
; 24471:     *  - is there a default namespace?
; 24472:     */
; 24473:     nsName = xmlSchemaLookupNamespace(vctxt, prefix);

	push	DWORD PTR _prefix$1[ebp]
	push	esi
	call	_xmlSchemaLookupNamespace

; 24474: 
; 24475:     if (prefix != NULL) {

	mov	ecx, DWORD PTR _prefix$1[ebp]
	add	esp, 8
	mov	DWORD PTR _nsName$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN109@xmlSchemaV

; 24476: 	xmlFree(prefix);

	push	ecx
	call	DWORD PTR _xmlFree

; 24477: 	/*
; 24478: 	* A namespace must be found if the prefix is
; 24479: 	* NOT NULL.
; 24480: 	*/
; 24481: 	if (nsName == NULL) {

	mov	eax, DWORD PTR _nsName$1$[ebp]
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN109@xmlSchemaV

; 24482: 	    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1;
; 24483: 	    xmlSchemaCustomErr(ACTXT_CAST vctxt, ret, NULL,

	push	21					; 00000015H
	call	_xmlSchemaGetBuiltInType

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	push	0
	push	0
	push	0
	push	ebx
	push	OFFSET ??_C@_0EJ@KJCHOIHD@The?5QName?5value?5?8?$CFs?8?5has?5no?5cor@
	push	eax
	push	0
	push	1824					; 00000720H
	push	esi
	call	_xmlSchemaCustomErr4

; 24488: 	    if (local != NULL)

	mov	eax, DWORD PTR _local$1$[ebp]

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	add	esp, 40					; 00000028H

; 24488: 	    if (local != NULL)

	test	eax, eax
	je	SHORT $LN44@xmlSchemaV

; 24489: 		xmlFree(local);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN44@xmlSchemaV:

; 24643: 	    }
; 24644: 	    if (WXS_IS_LIST(type))

	mov	eax, DWORD PTR _type$[ebp]
	movzx	esi, BYTE PTR [eax+48]
	shr	esi, 6
	and	esi, 1
	or	esi, 1824				; 00000720H
$LN164@xmlSchemaV:

; 24663: 		    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2;
; 24664: 		else
; 24665: 		    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1;
; 24666: 	    }
; 24667: 	}
; 24668: 	if (fireErrors && (ret > 0))

	mov	edi, DWORD PTR _actxt$[ebp]
	jmp	$LN159@xmlSchemaV
$LN109@xmlSchemaV:

; 24493:     if (valNeeded && val) {

	cmp	DWORD PTR _valNeeded$1$[ebp], 0
	je	SHORT $LN111@xmlSchemaV

; 24494: 	if (nsName != NULL)

	test	eax, eax
	je	SHORT $LN113@xmlSchemaV

; 24495: 	    *val = xmlSchemaNewQNameValue(

	push	eax
	call	_xmlStrdup
	add	esp, 4

; 24496: 		BAD_CAST xmlStrdup(nsName), BAD_CAST local);
; 24497: 	else
; 24498: 	    *val = xmlSchemaNewQNameValue(NULL,
; 24499: 		BAD_CAST local);
; 24500:     } else

	push	DWORD PTR _local$1$[ebp]
	push	eax
	call	_xmlSchemaNewQNameValue
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax
	jmp	SHORT $LN112@xmlSchemaV
$LN113@xmlSchemaV:
	push	DWORD PTR _local$1$[ebp]
	xor	eax, eax
	push	eax
	call	_xmlSchemaNewQNameValue
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax
	jmp	SHORT $LN112@xmlSchemaV
$LN111@xmlSchemaV:

; 24501: 	xmlFree(local);

	push	DWORD PTR _local$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN112@xmlSchemaV:

; 24502:     return (0);

	xor	esi, esi
$LN158@xmlSchemaV:

; 24645: 		ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2;
; 24646: 	    else
; 24647: 		ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1;
; 24648: 	}
; 24649: 	if ((ret == 0) && (type->flags & XML_SCHEMAS_TYPE_HAS_FACETS)) {

	mov	eax, DWORD PTR _type$[ebp]
	test	DWORD PTR [eax+48], 134217728		; 08000000H
	je	SHORT $LN164@xmlSchemaV

; 24650: 	    /*
; 24651: 	    * Check facets.
; 24652: 	    */
; 24653: 	    ret = xmlSchemaValidateFacets(actxt, node, type,

	push	DWORD PTR _fireErrors$[ebp]
	push	0
	push	DWORD PTR _val$[ebp]
	push	ebx
	push	DWORD PTR [edi+88]
	mov	edi, DWORD PTR _actxt$[ebp]
	push	eax
	push	DWORD PTR _node$[ebp]
	push	edi
	call	_xmlSchemaValidateFacets
	mov	esi, eax
	add	esp, 32					; 00000020H

; 24654: 		(xmlSchemaValType) biType->builtInType, value, val,
; 24655: 		0, fireErrors);
; 24656: 	    if (ret != 0) {

	test	esi, esi
	je	SHORT $LN170@xmlSchemaV

; 24657: 		if (ret < 0) {

	jns	SHORT $LN49@xmlSchemaV

; 24658: 		    AERROR_INT("xmlSchemaVCheckCVCSimpleType",

	push	OFFSET ??_C@_0CI@LPLEHNN@validating?5facets?5of?5atomic?5sim@

; 24659: 			"validating facets of atomic simple type");
; 24660: 		    goto internal_error;

	jmp	$LN177@xmlSchemaV
$LN30@xmlSchemaV:

; 24600: 		case XML_SCHEMAS_QNAME:
; 24601: 		    ret = xmlSchemaValidateQName((xmlSchemaValidCtxtPtr) actxt,
; 24602: 			value, &val, valNeeded);
; 24603: 		    break;
; 24604: 		default:
; 24605: 		    /* ws = xmlSchemaGetWhiteSpaceFacetValue(type); */
; 24606: 		    if (valNeeded)
; 24607: 			ret = xmlSchemaValPredefTypeNodeNoNorm(biType,
; 24608: 			    value, &val, node);
; 24609: 		    else
; 24610: 			ret = xmlSchemaValPredefTypeNodeNoNorm(biType,
; 24611: 			    value, NULL, node);
; 24612: 		    break;
; 24613: 	    }
; 24614: 	} else if (actxt->type == XML_SCHEMA_CTXT_PARSER) {

	cmp	ecx, 1
	jne	$LN37@xmlSchemaV

; 24615: 	    switch (biType->builtInType) {

	cmp	DWORD PTR [edi+88], 28			; 0000001cH
	jne	$LN176@xmlSchemaV

; 24616: 		case XML_SCHEMAS_NOTATION:
; 24617: 		    ret = xmlSchemaValidateNotation(NULL,

	push	DWORD PTR _valNeeded$1$[ebp]
	lea	ecx, DWORD PTR _val$[ebp]
	push	ecx
	push	ebx
	push	eax
	push	DWORD PTR [esi+36]
	push	0
$LN175@xmlSchemaV:

; 24637: 	}
; 24638: 	if (ret != 0) {

	call	_xmlSchemaValidateNotation
	add	esp, 24					; 00000018H
$LN174@xmlSchemaV:
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN158@xmlSchemaV

; 24639: 	    if (ret < 0) {

	jns	$LN44@xmlSchemaV
	mov	esi, DWORD PTR _actxt$[ebp]
$LN151@xmlSchemaV:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CD@GBDHIMIE@validating?5against?5a?5built?9in?5t@
	push	OFFSET ??_C@_0BN@DBANEELH@xmlSchemaVCheckCVCSimpleType@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 24640: 		AERROR_INT("xmlSchemaVCheckCVCSimpleType",
; 24641: 		    "validating against a built-in type");
; 24642: 		goto internal_error;

	jmp	$internal_error$185
$LN49@xmlSchemaV:

; 24661: 		}
; 24662: 		if (WXS_IS_LIST(type))

	mov	eax, DWORD PTR _type$[ebp]
	movzx	esi, BYTE PTR [eax+48]
	shr	esi, 6
	and	esi, 1
	or	esi, 1824				; 00000720H
	jmp	SHORT $LN159@xmlSchemaV
$LN170@xmlSchemaV:

; 24654: 		(xmlSchemaValType) biType->builtInType, value, val,
; 24655: 		0, fireErrors);
; 24656: 	    if (ret != 0) {

	mov	eax, DWORD PTR _type$[ebp]
$LN159@xmlSchemaV:

; 24663: 		    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2;
; 24664: 		else
; 24665: 		    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1;
; 24666: 	    }
; 24667: 	}
; 24668: 	if (fireErrors && (ret > 0))

	cmp	DWORD PTR _fireErrors$[ebp], 0
	je	$LN162@xmlSchemaV
	test	esi, esi
	jle	$LN162@xmlSchemaV

; 24669: 	    xmlSchemaSimpleTypeErr(actxt, ret, node, value, type, 1);

	push	1
	push	eax
	push	ebx
	push	DWORD PTR _node$[ebp]

; 24670:     } else if (WXS_IS_LIST(type)) {

	jmp	$LN178@xmlSchemaV
$LN37@xmlSchemaV:

; 24618: 			((xmlSchemaParserCtxtPtr) actxt)->schema, node,
; 24619: 			value, &val, valNeeded);
; 24620: 		    break;
; 24621: 		default:
; 24622: 		    /* ws = xmlSchemaGetWhiteSpaceFacetValue(type); */
; 24623: 		    if (valNeeded)
; 24624: 			ret = xmlSchemaValPredefTypeNodeNoNorm(biType,
; 24625: 			    value, &val, node);
; 24626: 		    else
; 24627: 			ret = xmlSchemaValPredefTypeNodeNoNorm(biType,
; 24628: 			    value, NULL, node);
; 24629: 		    break;
; 24630: 	    }
; 24631: 	} else {
; 24632: 	    /*
; 24633: 	    * Validation via a public API is not implemented yet.
; 24634: 	    */
; 24635: 	    TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	24635					; 0000603bH
	push	OFFSET ??_C@_0GM@IJCDLDON@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H

; 24636: 	    goto internal_error;

	jmp	$internal_error$185
$LN20@xmlSchemaV:

; 24670:     } else if (WXS_IS_LIST(type)) {

	test	al, 64					; 00000040H
	je	$LN53@xmlSchemaV

; 24671: 
; 24672: 	xmlSchemaTypePtr itemType;
; 24673: 	const xmlChar *cur, *end;
; 24674: 	xmlChar *tmpValue = NULL;
; 24675: 	unsigned long len = 0;
; 24676: 	xmlSchemaValPtr prevVal = NULL, curVal = NULL;
; 24677: 	/* 1.2.2 if {variety} is `list` then the string must be a sequence
; 24678: 	* of white space separated tokens, each of which `match`es a literal
; 24679: 	* in the `lexical space` of {item type definition}
; 24680: 	*/
; 24681: 	/*
; 24682: 	* Note that XML_SCHEMAS_TYPE_NORMVALUENEEDED will be set if
; 24683: 	* the list type has an enum or pattern facet.
; 24684: 	*/
; 24685: 	NORMALIZE(type);

	mov	edx, DWORD PTR _isNormalized$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _tmpValue$1$[ebp], ecx
	xor	esi, esi
	mov	DWORD PTR _prevVal$1$[ebp], ecx
	mov	DWORD PTR _curVal$2[ebp], ecx
	mov	ecx, edi
	mov	DWORD PTR _len$1$[ebp], esi
	mov	DWORD PTR _value$5$[ebp], ecx
	mov	DWORD PTR _isNormalized$1$[ebp], edx
	test	edx, edx
	jne	SHORT $LN55@xmlSchemaV
	cmp	DWORD PTR _normalize$[ebp], esi
	jne	SHORT $LN56@xmlSchemaV
	mov	DWORD PTR _value$5$[ebp], ecx
	test	eax, 268435456				; 10000000H
	je	SHORT $LN55@xmlSchemaV
$LN56@xmlSchemaV:
	push	edi
	push	ebx
	call	_xmlSchemaNormalizeValue
	mov	edx, eax
	mov	DWORD PTR _isNormalized$1$[ebp], 1
	add	esp, 8
	mov	DWORD PTR _normValue$1$[ebp], edx
	test	edx, edx
	mov	ecx, edi
	cmovne	ecx, edx
	mov	DWORD PTR _value$5$[ebp], ecx
$LN55@xmlSchemaV:

; 24686: 	/*
; 24687: 	* VAL TODO: Optimize validation of empty values.
; 24688: 	* VAL TODO: We do not have computed values for lists.
; 24689: 	*/
; 24690: 	itemType = WXS_LIST_ITEMTYPE(type);

	mov	eax, DWORD PTR [ebx+28]
	mov	DWORD PTR tv1237[ebp], eax
$LL11@xmlSchemaV:

; 24691: 	cur = value;
; 24692: 	do {
; 24693: 	    while (IS_BLANK_CH(*cur))

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN58@xmlSchemaV
	cmp	al, 9
	jb	SHORT $LN59@xmlSchemaV
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN58@xmlSchemaV
$LN59@xmlSchemaV:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN12@xmlSchemaV
$LN58@xmlSchemaV:

; 24694: 		cur++;

	inc	ecx
	jmp	SHORT $LL11@xmlSchemaV
$LN12@xmlSchemaV:

; 24695: 	    end = cur;

	mov	edi, ecx

; 24696: 	    while ((*end != 0) && (!(IS_BLANK_CH(*end))))

	test	al, al
	je	$LN130@xmlSchemaV
$LL13@xmlSchemaV:
	cmp	al, 32					; 00000020H
	je	SHORT $LN14@xmlSchemaV
	cmp	al, 9
	jb	SHORT $LN60@xmlSchemaV
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN14@xmlSchemaV
$LN60@xmlSchemaV:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN14@xmlSchemaV
	mov	al, BYTE PTR [edi+1]

; 24697: 		end++;

	inc	edi
	test	al, al
	jne	SHORT $LL13@xmlSchemaV
$LN14@xmlSchemaV:

; 24698: 	    if (end == cur)

	cmp	edi, ecx
	je	$LN130@xmlSchemaV

; 24700: 	    tmpValue = xmlStrndup(cur, end - cur);

	mov	eax, edi
	sub	eax, ecx
	push	eax
	push	ecx
	call	_xmlStrndup

; 24701: 	    len++;
; 24702: 
; 24703: 	    if (valNeeded)
; 24704: 		ret = xmlSchemaVCheckCVCSimpleType(actxt, node, itemType,
; 24705: 		    tmpValue, &curVal, fireErrors, 0, 1);
; 24706: 	    else
; 24707: 		ret = xmlSchemaVCheckCVCSimpleType(actxt, node, itemType,
; 24708: 		    tmpValue, NULL, fireErrors, 0, 1);
; 24709: 	    FREE_AND_NULL(tmpValue);

	push	1
	push	0
	push	DWORD PTR _fireErrors$[ebp]
	xor	edx, edx
	mov	DWORD PTR _tmpValue$1$[ebp], eax
	inc	esi
	lea	ecx, DWORD PTR _curVal$2[ebp]
	cmp	DWORD PTR _valNeeded$1$[ebp], edx
	mov	DWORD PTR _len$1$[ebp], esi
	cmove	ecx, edx
	push	ecx
	push	eax
	push	DWORD PTR tv1237[ebp]
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaVCheckCVCSimpleType
	mov	ecx, DWORD PTR _tmpValue$1$[ebp]
	add	esp, 40					; 00000028H
	mov	esi, eax
	test	ecx, ecx
	je	SHORT $LN64@xmlSchemaV
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	DWORD PTR _tmpValue$1$[ebp], 0
$LN64@xmlSchemaV:

; 24710: 	    if (curVal != NULL) {

	mov	eax, DWORD PTR _curVal$2[ebp]
	test	eax, eax
	je	SHORT $LN160@xmlSchemaV

; 24711: 		/*
; 24712: 		* Add to list of computed values.
; 24713: 		*/
; 24714: 		if (val == NULL)

	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN66@xmlSchemaV

; 24715: 		    val = curVal;

	mov	DWORD PTR _val$[ebp], eax
	jmp	SHORT $LN67@xmlSchemaV
$LN66@xmlSchemaV:

; 24716: 		else
; 24717: 		    xmlSchemaValueAppend(prevVal, curVal);

	push	eax
	push	DWORD PTR _prevVal$1$[ebp]
	call	_xmlSchemaValueAppend
	mov	eax, DWORD PTR _curVal$2[ebp]
	add	esp, 8
$LN67@xmlSchemaV:

; 24718: 		prevVal = curVal;

	mov	DWORD PTR _prevVal$1$[ebp], eax

; 24719: 		curVal = NULL;

	mov	DWORD PTR _curVal$2[ebp], 0
$LN160@xmlSchemaV:

; 24720: 	    }
; 24721: 	    if (ret != 0) {

	test	esi, esi
	jne	SHORT $LN179@xmlSchemaV

; 24728: 		break;
; 24729: 	    }
; 24730: 	    cur = end;
; 24731: 	} while (*cur != 0);

	cmp	BYTE PTR [edi], 0
	mov	ecx, edi
	je	SHORT $LN9@xmlSchemaV

; 24691: 	cur = value;
; 24692: 	do {
; 24693: 	    while (IS_BLANK_CH(*cur))

	mov	esi, DWORD PTR _len$1$[ebp]
	jmp	$LL11@xmlSchemaV
$LN179@xmlSchemaV:

; 24722: 		if (ret < 0) {

	jns	SHORT $LN69@xmlSchemaV

; 24723: 		    AERROR_INT("xmlSchemaVCheckCVCSimpleType",

	mov	eax, DWORD PTR _actxt$[ebp]
	push	OFFSET ??_C@_0CH@JGMIFPNF@validating?5an?5item?5of?5list?5simp@
	push	OFFSET ??_C@_0BN@DBANEELH@xmlSchemaVCheckCVCSimpleType@
	push	eax

; 24724: 			"validating an item of list simple type");
; 24725: 		    goto internal_error;

	jmp	$LN180@xmlSchemaV
$LN69@xmlSchemaV:

; 24726: 		}
; 24727: 		ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2;

	mov	esi, 1825				; 00000721H
	jmp	SHORT $LN9@xmlSchemaV
$LN130@xmlSchemaV:

; 24699: 		break;

	xor	esi, esi
$LN9@xmlSchemaV:

; 24732: 	FREE_AND_NULL(tmpValue);

	mov	ecx, DWORD PTR _tmpValue$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN70@xmlSchemaV
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN70@xmlSchemaV:

; 24733: 	if ((ret == 0) && (type->flags & XML_SCHEMAS_TYPE_HAS_FACETS)) {

	mov	edi, DWORD PTR _value$5$[ebp]
	test	esi, esi
	jne	SHORT $LN161@xmlSchemaV
	test	DWORD PTR [ebx+48], 134217728		; 08000000H
	je	SHORT $LN161@xmlSchemaV

; 24734: 	    /*
; 24735: 	    * Apply facets (pattern, enumeration).
; 24736: 	    */
; 24737: 	    ret = xmlSchemaValidateFacets(actxt, node, type,

	push	DWORD PTR _fireErrors$[ebp]
	mov	eax, DWORD PTR _actxt$[ebp]
	push	DWORD PTR _len$1$[ebp]
	push	DWORD PTR _val$[ebp]
	push	edi
	push	esi
	push	ebx
	push	DWORD PTR _node$[ebp]
	push	eax
	call	_xmlSchemaValidateFacets
	mov	esi, eax
	add	esp, 32					; 00000020H

; 24738: 		XML_SCHEMAS_UNKNOWN, value, val,
; 24739: 		len, fireErrors);
; 24740: 	    if (ret != 0) {

	test	esi, esi
	je	SHORT $LN161@xmlSchemaV

; 24741: 		if (ret < 0) {

	jns	SHORT $LN73@xmlSchemaV

; 24742: 		    AERROR_INT("xmlSchemaVCheckCVCSimpleType",

	push	OFFSET ??_C@_0CG@LKPAEBKB@validating?5facets?5of?5list?5simpl@
	push	OFFSET ??_C@_0BN@DBANEELH@xmlSchemaVCheckCVCSimpleType@
	push	DWORD PTR _actxt$[ebp]

; 24743: 			"validating facets of list simple type");
; 24744: 		    goto internal_error;

	jmp	$LN180@xmlSchemaV
$LN73@xmlSchemaV:

; 24745: 		}
; 24746: 		ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2;

	mov	esi, 1825				; 00000721H
$LN161@xmlSchemaV:

; 24747: 	    }
; 24748: 	}
; 24749: 	if (fireErrors && (ret > 0)) {

	cmp	DWORD PTR _fireErrors$[ebp], 0
	je	$LN162@xmlSchemaV
	test	esi, esi
	jle	$LN162@xmlSchemaV

; 24750: 	    /*
; 24751: 	    * Report the normalized value.
; 24752: 	    */
; 24753: 	    normalize = 1;
; 24754: 	    NORMALIZE(type);

	cmp	DWORD PTR _isNormalized$1$[ebp], 0
	jne	SHORT $LN77@xmlSchemaV
	push	edi
	push	ebx
	call	_xmlSchemaNormalizeValue
	add	esp, 8
	mov	DWORD PTR _normValue$1$[ebp], eax
	test	eax, eax
	cmovne	edi, eax
$LN77@xmlSchemaV:

; 24755: 	    xmlSchemaSimpleTypeErr(actxt, ret, node, value, type, 1);

	push	1
	push	ebx
	push	edi
	push	DWORD PTR _node$[ebp]
	push	esi
	push	DWORD PTR _actxt$[ebp]

; 24756: 	}

	jmp	$LN181@xmlSchemaV
$LN53@xmlSchemaV:

; 24757:     } else if (WXS_IS_UNION(type)) {

	test	al, al
	jns	$LN152@xmlSchemaV

; 24758: 	xmlSchemaTypeLinkPtr memberLink;
; 24759: 	/*
; 24760: 	* TODO: For all datatypes `derived` by `union`  whiteSpace does
; 24761: 	* not apply directly; however, the normalization behavior of `union`
; 24762: 	* types is controlled by the value of whiteSpace on that one of the
; 24763: 	* `memberTypes` against which the `union` is successfully validated.
; 24764: 	*
; 24765: 	* This means that the value is normalized by the first validating
; 24766: 	* member type, then the facets of the union type are applied. This
; 24767: 	* needs changing of the value!
; 24768: 	*/
; 24769: 
; 24770: 	/*
; 24771: 	* 1.2.3 if {variety} is `union` then the string must `match` a
; 24772: 	* literal in the `lexical space` of at least one member of
; 24773: 	* {member type definitions}
; 24774: 	*/
; 24775: 	memberLink = xmlSchemaGetUnionSimpleTypeMemberTypes(type);

	push	ebx
	call	_xmlSchemaGetUnionSimpleTypeMemberTypes
	mov	ebx, eax
	add	esp, 4

; 24776: 	if (memberLink == NULL) {

	test	ebx, ebx
	jne	SHORT $LN153@xmlSchemaV

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	eax
	push	eax
	push	OFFSET ??_C@_0CG@NCCHNOHC@union?5simple?5type?5has?5no?5member@
	push	OFFSET ??_C@_0BN@DBANEELH@xmlSchemaVCheckCVCSimpleType@
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 24777: 	    AERROR_INT("xmlSchemaVCheckCVCSimpleType",
; 24778: 		"union simple type has no member types");
; 24779: 	    goto internal_error;

	jmp	$LN99@xmlSchemaV
$LN153@xmlSchemaV:
	xor	ecx, ecx
	lea	eax, DWORD PTR _val$[ebp]

; 24780: 	}
; 24781: 	/*
; 24782: 	* Always normalize union type values, since we currently
; 24783: 	* cannot store the whitespace information with the value
; 24784: 	* itself; otherwise a later value-comparison would be
; 24785: 	* not possible.
; 24786: 	*/
; 24787: 	while (memberLink != NULL) {
; 24788: 	    if (valNeeded)
; 24789: 		ret = xmlSchemaVCheckCVCSimpleType(actxt, node,
; 24790: 		    memberLink->type, value, &val, 0, 1, 0);
; 24791: 	    else
; 24792: 		ret = xmlSchemaVCheckCVCSimpleType(actxt, node,
; 24793: 		    memberLink->type, value, NULL, 0, 1, 0);
; 24794: 	    if (ret <= 0)

	cmp	DWORD PTR _valNeeded$1$[ebp], ecx
	cmove	eax, ecx
	mov	DWORD PTR tv1224[ebp], eax
	npad	6
$LL15@xmlSchemaV:
	push	0
	push	1
	push	0
	push	eax
	mov	eax, DWORD PTR [ebx+4]
	push	edi
	push	eax
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaVCheckCVCSimpleType
	mov	esi, eax
	add	esp, 32					; 00000020H
	test	esi, esi
	jle	SHORT $LN182@xmlSchemaV

; 24795: 		break;
; 24796: 	    memberLink = memberLink->next;

	mov	ebx, DWORD PTR [ebx]
	mov	eax, DWORD PTR tv1224[ebp]
	test	ebx, ebx
	jne	SHORT $LL15@xmlSchemaV

; 24797: 	}
; 24798: 	if (ret != 0) {

	test	esi, esi
$LN182@xmlSchemaV:
	je	SHORT $LN83@xmlSchemaV

; 24799: 	    if (ret < 0) {

	test	esi, esi
	jns	SHORT $LN84@xmlSchemaV

; 24800: 		AERROR_INT("xmlSchemaVCheckCVCSimpleType",

	mov	edi, DWORD PTR _actxt$[ebp]
	push	OFFSET ??_C@_0CI@MOMFK@validating?5members?5of?5union?5sim@
	push	OFFSET ??_C@_0BN@DBANEELH@xmlSchemaVCheckCVCSimpleType@
	push	edi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH

; 24801: 		    "validating members of union simple type");
; 24802: 		goto internal_error;

	jmp	$LN99@xmlSchemaV
$LN84@xmlSchemaV:

; 24803: 	    }
; 24804: 	    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3;

	mov	esi, 1826				; 00000722H
$LN83@xmlSchemaV:

; 24805: 	}
; 24806: 	/*
; 24807: 	* Apply facets (pattern, enumeration).
; 24808: 	*/
; 24809: 	if ((ret == 0) && (type->flags & XML_SCHEMAS_TYPE_HAS_FACETS)) {

	mov	edx, DWORD PTR _type$[ebp]
	mov	eax, edi
	test	esi, esi
	jne	$LN167@xmlSchemaV
	mov	ecx, DWORD PTR [edx+48]
	test	ecx, 134217728				; 08000000H
	je	$LN167@xmlSchemaV

; 24810: 	    /*
; 24811: 	    * The normalization behavior of `union` types is controlled by
; 24812: 	    * the value of whiteSpace on that one of the `memberTypes`
; 24813: 	    * against which the `union` is successfully validated.
; 24814: 	    */
; 24815: 	    NORMALIZE(memberLink->type);

	mov	DWORD PTR _value$7$[ebp], eax
	cmp	DWORD PTR _isNormalized$[ebp], esi
	jne	SHORT $LN88@xmlSchemaV
	cmp	DWORD PTR _normalize$[ebp], esi
	jne	SHORT $LN87@xmlSchemaV
	mov	DWORD PTR _value$7$[ebp], eax
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN88@xmlSchemaV
$LN87@xmlSchemaV:
	push	edi
	push	DWORD PTR [ebx+4]
	call	_xmlSchemaNormalizeValue
	mov	edx, DWORD PTR _type$[ebp]
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR _normValue$1$[ebp], ecx
	test	ecx, ecx
	mov	eax, edi
	cmovne	eax, ecx
	mov	DWORD PTR _value$7$[ebp], eax
$LN88@xmlSchemaV:

; 24816: 	    ret = xmlSchemaValidateFacets(actxt, node, type,

	push	DWORD PTR _fireErrors$[ebp]
	mov	ebx, DWORD PTR _node$[ebp]
	mov	edi, DWORD PTR _actxt$[ebp]
	push	0
	push	DWORD PTR _val$[ebp]
	push	eax
	push	0
	push	edx
	push	ebx
	push	edi
	call	_xmlSchemaValidateFacets
	mov	esi, eax
	add	esp, 32					; 00000020H

; 24817: 		XML_SCHEMAS_UNKNOWN, value, val,
; 24818: 		0, fireErrors);
; 24819: 	    if (ret != 0) {

	test	esi, esi
	je	SHORT $LN165@xmlSchemaV

; 24820: 		if (ret < 0) {

	jns	SHORT $LN90@xmlSchemaV

; 24821: 		    AERROR_INT("xmlSchemaVCheckCVCSimpleType",

	push	OFFSET ??_C@_0CH@DGPHKMDI@validating?5facets?5of?5union?5simp@
$LN177@xmlSchemaV:

; 24842: internal_error:
; 24843:     if (normValue != NULL)

	push	OFFSET ??_C@_0BN@DBANEELH@xmlSchemaVCheckCVCSimpleType@
	push	edi
$LN180@xmlSchemaV:
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH
$internal_error$185:
	mov	eax, DWORD PTR _normValue$1$[ebp]
	test	eax, eax
	je	SHORT $LN99@xmlSchemaV

; 24844: 	xmlFree(normValue);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN99@xmlSchemaV:

; 24845:     if (val != NULL)

	mov	eax, DWORD PTR _val$[ebp]
	test	eax, eax
	je	SHORT $LN100@xmlSchemaV

; 24846: 	xmlSchemaFreeValue(val);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN100@xmlSchemaV:

; 24847:     return (-1);
; 24848: }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN90@xmlSchemaV:

; 24822: 			"validating facets of union simple type");
; 24823: 		    goto internal_error;
; 24824: 		}
; 24825: 		ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3;

	mov	esi, 1826				; 00000722H
$LN165@xmlSchemaV:

; 24826: 	    }
; 24827: 	}
; 24828: 	if (fireErrors && (ret > 0))

	mov	eax, DWORD PTR _value$7$[ebp]
	mov	edx, DWORD PTR _type$[ebp]
	jmp	SHORT $LN89@xmlSchemaV
$LN167@xmlSchemaV:
	mov	ebx, DWORD PTR _node$[ebp]
	mov	edi, DWORD PTR _actxt$[ebp]
$LN89@xmlSchemaV:
	cmp	DWORD PTR _fireErrors$[ebp], 0
	je	SHORT $LN162@xmlSchemaV
	test	esi, esi
	jle	SHORT $LN162@xmlSchemaV

; 24829: 	    xmlSchemaSimpleTypeErr(actxt, ret, node, value, type, 1);

	push	1
	push	edx
	push	eax
	push	ebx
$LN178@xmlSchemaV:

; 24830:     }
; 24831: 
; 24832:     if (normValue != NULL)

	push	esi
	push	edi
$LN181@xmlSchemaV:
	call	_xmlSchemaSimpleTypeErr
	add	esp, 24					; 00000018H
$LN162@xmlSchemaV:
	mov	eax, DWORD PTR _normValue$1$[ebp]
	test	eax, eax
	je	SHORT $LN92@xmlSchemaV

; 24833: 	xmlFree(normValue);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN92@xmlSchemaV:

; 24834:     if (ret == 0) {

	test	esi, esi
	jne	SHORT $LN95@xmlSchemaV
$LN152@xmlSchemaV:

; 24835: 	if (retVal != NULL)

	mov	ecx, DWORD PTR _retVal$[ebp]
	test	ecx, ecx
	je	SHORT $LN95@xmlSchemaV

; 24836: 	    *retVal = val;

	mov	eax, DWORD PTR _val$[ebp]
	pop	edi
	mov	DWORD PTR [ecx], eax

; 24837: 	else if (val != NULL)
; 24838: 	    xmlSchemaFreeValue(val);
; 24839:     } else if (val != NULL)
; 24840: 	xmlSchemaFreeValue(val);
; 24841:     return (ret);

	mov	eax, esi

; 24847:     return (-1);
; 24848: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN95@xmlSchemaV:

; 24837: 	else if (val != NULL)
; 24838: 	    xmlSchemaFreeValue(val);
; 24839:     } else if (val != NULL)
; 24840: 	xmlSchemaFreeValue(val);
; 24841:     return (ret);

	mov	eax, DWORD PTR _val$[ebp]
	test	eax, eax
	je	SHORT $LN98@xmlSchemaV
	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN98@xmlSchemaV:
	pop	edi
	mov	eax, esi

; 24847:     return (-1);
; 24848: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaVCheckCVCSimpleType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCreateVCtxtOnPCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSchemaCreateVCtxtOnPCtxt PROC			; COMDAT

; 15797: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+92], 0
	jne	SHORT $LN2@xmlSchemaC

; 15798:    if (ctxt->vctxt == NULL) {
; 15799: 	ctxt->vctxt = xmlSchemaNewValidCtxt(NULL);

	push	0
	call	_xmlSchemaNewValidCtxt
	add	esp, 4
	mov	DWORD PTR [esi+92], eax

; 15800: 	if (ctxt->vctxt == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlSchemaC

; 15801: 	    xmlSchemaPErr(ctxt, NULL,

	push	eax
	push	eax
	push	OFFSET ??_C@_0FL@FMHFMMBK@Internal?5error?3?5xmlSchemaCreate@
	push	3069					; 00000bfdH
	push	eax
	push	esi
	call	_xmlSchemaPErr
	add	esp, 24					; 00000018H

; 15802: 		XML_SCHEMAP_INTERNAL,
; 15803: 		"Internal error: xmlSchemaCreateVCtxtOnPCtxt, "
; 15804: 		"failed to create a temp. validation context.\n",
; 15805: 		NULL, NULL);
; 15806: 	    return (-1);

	or	eax, -1
	pop	esi

; 15815: }

	pop	ebp
	ret	0
$LN3@xmlSchemaC:

; 15807: 	}
; 15808: 	/* TODO: Pass user data. */
; 15809: 	xmlSchemaSetValidErrors(ctxt->vctxt,

	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	push	eax
	call	_xmlSchemaSetValidErrors

; 15810: 	    ctxt->error, ctxt->warning, ctxt->errCtxt);
; 15811: 	xmlSchemaSetValidStructuredErrors(ctxt->vctxt,

	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi+24]
	push	DWORD PTR [esi+92]
	call	_xmlSchemaSetValidStructuredErrors
	add	esp, 28					; 0000001cH
$LN2@xmlSchemaC:

; 15812: 	    ctxt->serror, ctxt->errCtxt);
; 15813:     }
; 15814:     return (0);

	xor	eax, eax
	pop	esi

; 15815: }

	pop	ebp
	ret	0
_xmlSchemaCreateVCtxtOnPCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckCOSSTRestricts
_TEXT	SEGMENT
_node$1$ = -24						; size = 4
_baseItemType$1$ = -24					; size = 4
_str2$1$ = -20						; size = 4
_str3$1$ = -16						; size = 4
_ok$1$ = -12						; size = 4
_strBMT$1 = -12						; size = 4
_strBT$2 = -12						; size = 4
_primitive$1$ = -8					; size = 4
_strBT$3 = -8						; size = 4
_strT$4 = -4						; size = 4
_str$ = -4						; size = 4
_pctxt$ = 8						; size = 4
_member$3$ = 12						; size = 4
_des$5 = 12						; size = 4
_strBIT$6 = 12						; size = 4
_type$ = 12						; size = 4
_xmlSchemaCheckCOSSTRestricts PROC			; COMDAT

; 15297: {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _type$[ebp]
	mov	DWORD PTR _str$[ebp], 0
	cmp	DWORD PTR [esi], 4
	je	SHORT $LN24@xmlSchemaC

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CM@LMHOOJIC@given?5type?5is?5not?5a?5user?9derive@
	push	OFFSET ??_C@_0BN@JGCJPHDI@xmlSchemaCheckCOSSTRestricts@
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 15298:     xmlChar *str = NULL;
; 15299: 
; 15300:     if (type->type != XML_SCHEMA_TYPE_SIMPLE) {
; 15301: 	PERROR_INT("xmlSchemaCheckCOSSTRestricts",
; 15302: 	    "given type is not a user-derived simpleType");
; 15303: 	return (-1);

	or	eax, -1
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlSchemaC:

; 15304:     }
; 15305: 
; 15306:     if (WXS_IS_ATOMIC(type)) {

	mov	eax, DWORD PTR [esi+48]
	push	ebx
	push	edi
	test	eax, 256				; 00000100H
	je	$LN25@xmlSchemaC

; 15307: 	xmlSchemaTypePtr primitive;
; 15308: 	/*
; 15309: 	* 1.1 The {base type definition} must be an atomic simple
; 15310: 	* type definition or a built-in primitive datatype.
; 15311: 	*/
; 15312: 	if (! WXS_IS_ATOMIC(type->baseType)) {

	mov	edi, DWORD PTR [esi+64]
	mov	eax, DWORD PTR [edi+48]
	test	eax, 256				; 00000100H
	jne	SHORT $LN27@xmlSchemaC

; 1429 :     return (xmlSchemaFormatQName(buf,

	push	edi
	call	_xmlSchemaGetComponentName
	add	esp, 4
	push	eax
	push	edi
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaFormatQName

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	eax
	push	OFFSET ??_C@_0DA@BHMFPHHO@The?5base?5type?5?8?$CFs?8?5is?5not?5an?5at@
	push	0
	push	esi
	push	3011					; 00000bc3H
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaPCustomErrExt

; 15313: 	    xmlSchemaPCustomErr(pctxt,
; 15314: 		XML_SCHEMAP_COS_ST_RESTRICTS_1_1,
; 15315: 		WXS_BASIC_CAST type, NULL,
; 15316: 		"The base type '%s' is not an atomic simple type",
; 15317: 		xmlSchemaGetComponentQName(&str, type->baseType));
; 15318: 	    FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$[ebp]

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	add	esp, 44					; 0000002cH

; 15313: 	    xmlSchemaPCustomErr(pctxt,
; 15314: 		XML_SCHEMAP_COS_ST_RESTRICTS_1_1,
; 15315: 		WXS_BASIC_CAST type, NULL,
; 15316: 		"The base type '%s' is not an atomic simple type",
; 15317: 		xmlSchemaGetComponentQName(&str, type->baseType));
; 15318: 	    FREE_AND_NULL(str)

	test	eax, eax
	je	SHORT $LN28@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN28@xmlSchemaC:

; 15319: 	    return (XML_SCHEMAP_COS_ST_RESTRICTS_1_1);

	pop	edi
	pop	ebx
	mov	eax, 3011				; 00000bc3H
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlSchemaC:

; 14652:     if (type == NULL)

	test	edi, edi
	je	SHORT $LN29@xmlSchemaC

; 14653: 	return (0);
; 14654:     if (type->flags & final)

	test	eax, 1024				; 00000400H
	je	SHORT $LN29@xmlSchemaC

; 15320: 	}
; 15321: 	/* 1.2 The {final} of the {base type definition} must not contain
; 15322: 	* restriction.
; 15323: 	*/
; 15324: 	/* OPTIMIZE TODO : This is already done in xmlSchemaCheckStPropsCorrect */
; 15325: 	if (xmlSchemaTypeFinalContains(type->baseType,
; 15326: 	    XML_SCHEMAS_TYPE_FINAL_RESTRICTION)) {
; 15327: 	    xmlSchemaPCustomErr(pctxt,

	lea	eax, DWORD PTR _str$[ebp]
	push	edi
	push	eax
	call	_xmlSchemaGetComponentQName

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	eax
	push	OFFSET ??_C@_0DP@KJOCHNDL@The?5final?5of?5its?5base?5type?5?8?$CFs?8@
	push	0
	push	esi
	push	3012					; 00000bc4H
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaPCustomErrExt

; 15328: 		XML_SCHEMAP_COS_ST_RESTRICTS_1_2,
; 15329: 		WXS_BASIC_CAST type, NULL,
; 15330: 		"The final of its base type '%s' must not contain 'restriction'",
; 15331: 		xmlSchemaGetComponentQName(&str, type->baseType));
; 15332: 	    FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$[ebp]

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	add	esp, 40					; 00000028H

; 15328: 		XML_SCHEMAP_COS_ST_RESTRICTS_1_2,
; 15329: 		WXS_BASIC_CAST type, NULL,
; 15330: 		"The final of its base type '%s' must not contain 'restriction'",
; 15331: 		xmlSchemaGetComponentQName(&str, type->baseType));
; 15332: 	    FREE_AND_NULL(str)

	test	eax, eax
	je	SHORT $LN30@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN30@xmlSchemaC:

; 15333: 	    return (XML_SCHEMAP_COS_ST_RESTRICTS_1_2);

	pop	edi
	pop	ebx
	mov	eax, 3012				; 00000bc4H
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlSchemaC:

; 15334: 	}
; 15335: 
; 15336: 	/*
; 15337: 	* 1.3.1 DF must be an allowed constraining facet for the {primitive
; 15338: 	* type definition}, as specified in the appropriate subsection of 3.2
; 15339: 	* Primitive datatypes.
; 15340: 	*/
; 15341: 	if (type->facets != NULL) {

	cmp	DWORD PTR [esi+68], 0
	je	$LN92@xmlSchemaC

; 15342: 	    xmlSchemaFacetPtr facet;
; 15343: 	    int ok = 1;
; 15344: 
; 15345: 	    primitive = xmlSchemaGetPrimitiveType(type);

	push	esi
	mov	DWORD PTR _ok$1$[ebp], 1
	call	_xmlSchemaGetPrimitiveType
	add	esp, 4
	mov	DWORD PTR _primitive$1$[ebp], eax

; 15346: 	    if (primitive == NULL) {

	test	eax, eax
	jne	SHORT $LN32@xmlSchemaC

; 15347: 		PERROR_INT("xmlSchemaCheckCOSSTRestricts",

	push	OFFSET ??_C@_0BN@KLLNOLEJ@failed?5to?5get?5primitive?5type@
	push	OFFSET ??_C@_0BN@JGCJPHDI@xmlSchemaCheckCOSSTRestricts@
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH

; 15348: 		    "failed to get primitive type");
; 15349: 		return (-1);

	or	eax, -1
	pop	edi
	pop	ebx
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@xmlSchemaC:

; 15350: 	    }
; 15351: 	    facet = type->facets;

	mov	ebx, DWORD PTR [esi+68]
	mov	edi, DWORD PTR _pctxt$[ebp]
	npad	6
$LL4@xmlSchemaC:

; 15352: 	    do {
; 15353: 		if (xmlSchemaIsBuiltInTypeFacet(primitive, facet->type) == 0) {

	push	DWORD PTR [ebx]
	push	eax
	call	_xmlSchemaIsBuiltInTypeFacet
	add	esp, 8
	test	eax, eax
	jne	$LN109@xmlSchemaC

; 3043 :     xmlSchemaFormatItemForReport(&des, NULL, WXS_BASIC_CAST type, type->node);

	push	DWORD PTR [esi+36]

; 15354: 		    ok = 0;

	mov	DWORD PTR _ok$1$[ebp], eax

; 3043 :     xmlSchemaFormatItemForReport(&des, NULL, WXS_BASIC_CAST type, type->node);

	push	esi
	push	eax
	mov	DWORD PTR _des$5[ebp], eax
	mov	DWORD PTR _strT$4[ebp], eax
	lea	eax, DWORD PTR _des$5[ebp]
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3044 :     xmlSchemaPErrExt(ctxt, type->node, error, NULL, NULL, NULL,

	push	0
	push	DWORD PTR _primitive$1$[ebp]
	lea	eax, DWORD PTR _strT$4[ebp]
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport
	push	DWORD PTR [ebx]
	mov	DWORD PTR _str3$1$[ebp], eax
	call	_xmlSchemaFacetTypeToString
	mov	DWORD PTR _str2$1$[ebp], eax
	add	esp, 36					; 00000024H
	mov	eax, DWORD PTR [esi+36]

; 1971 :     xmlGenericErrorFunc channel = NULL;

	xor	ecx, ecx

; 3044 :     xmlSchemaPErrExt(ctxt, type->node, error, NULL, NULL, NULL,

	mov	DWORD PTR _node$1$[ebp], eax

; 1972 :     xmlStructuredErrorFunc schannel = NULL;

	xor	edx, edx

; 1973 :     void *data = NULL;

	xor	eax, eax

; 1974 : 
; 1975 :     if (ctxt != NULL) {

	test	edi, edi
	je	SHORT $LN112@xmlSchemaC

; 1976 :         ctxt->nberrors++;

	inc	DWORD PTR [edi+20]

; 1977 : 	ctxt->err = error;
; 1978 :         channel = ctxt->error;

	mov	ecx, DWORD PTR [edi+8]

; 1979 :         data = ctxt->errCtxt;

	mov	eax, DWORD PTR [edi+4]

; 1980 : 	schannel = ctxt->serror;

	mov	edx, DWORD PTR [edi+24]
	mov	DWORD PTR [edi+16], 3013		; 00000bc5H
$LN112@xmlSchemaC:

; 1981 :     }
; 1982 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	push	0
	push	0
	push	DWORD PTR _str3$1$[ebp]
	push	DWORD PTR _str2$1$[ebp]
	push	DWORD PTR _des$5[ebp]
	push	OFFSET ??_C@_0EG@LINCPIFE@?$CFs?3?5The?5facet?5?8?$CFs?8?5is?5not?5allow@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	3013					; 00000bc5H
	push	16					; 00000010H
	push	DWORD PTR _node$1$[ebp]
	push	edi
	push	eax
	push	ecx
	push	edx
	call	___xmlRaiseError

; 3050 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$5[ebp]

; 1982 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 84					; 00000054H

; 3050 :     FREE_AND_NULL(des);

	test	eax, eax
	je	SHORT $LN108@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	DWORD PTR _des$5[ebp], 0
$LN108@xmlSchemaC:

; 3051 :     FREE_AND_NULL(strT);

	mov	eax, DWORD PTR _strT$4[ebp]
	test	eax, eax
	je	SHORT $LN109@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN109@xmlSchemaC:

; 15355: 		    xmlSchemaPIllegalFacetAtomicErr(pctxt,
; 15356: 			XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1,
; 15357: 			type, primitive, facet);
; 15358: 		}
; 15359: 		facet = facet->next;

	mov	ebx, DWORD PTR [ebx+4]

; 15360: 	    } while (facet != NULL);

	mov	eax, DWORD PTR _primitive$1$[ebp]
	test	ebx, ebx
	jne	$LL4@xmlSchemaC

; 15361: 	    if (ok == 0)

	cmp	DWORD PTR _ok$1$[ebp], 0
	jne	$LN92@xmlSchemaC

; 15362: 		return (XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1);

	pop	edi
	pop	ebx
	mov	eax, 3013				; 00000bc5H
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlSchemaC:

; 15363: 	}
; 15364: 	/*
; 15365: 	* SPEC (1.3.2) "If there is a facet of the same kind in the {facets}
; 15366: 	* of the {base type definition} (call this BF),then the DF's {value}
; 15367: 	* must be a valid restriction of BF's {value} as defined in
; 15368: 	* [XML Schemas: Datatypes]."
; 15369: 	*
; 15370: 	* NOTE (1.3.2) Facet derivation constraints are currently handled in
; 15371: 	* xmlSchemaDeriveAndValidateFacets()
; 15372: 	*/
; 15373:     } else if (WXS_IS_LIST(type)) {

	test	al, 64					; 00000040H
	je	$LN35@xmlSchemaC

; 15374: 	xmlSchemaTypePtr itemType = NULL;
; 15375: 
; 15376: 	itemType = type->subtypes;

	mov	edi, DWORD PTR [esi+28]

; 15377: 	if ((itemType == NULL) || (! WXS_IS_SIMPLE(itemType))) {

	test	edi, edi
	je	SHORT $LN39@xmlSchemaC
	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR _pctxt$[ebp]
	cmp	eax, 4
	je	SHORT $LN37@xmlSchemaC
	cmp	eax, 1
	jne	SHORT $LN39@xmlSchemaC
	cmp	DWORD PTR [edi+88], 45			; 0000002dH
	jne	SHORT $LN40@xmlSchemaC
$LN39@xmlSchemaC:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CB@HJDIBIBN@failed?5to?5evaluate?5the?5item?5typ@
	push	OFFSET ??_C@_0BN@JGCJPHDI@xmlSchemaCheckCOSSTRestricts@
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 15378: 	    PERROR_INT("xmlSchemaCheckCOSSTRestricts",
; 15379: 		"failed to evaluate the item type");
; 15380: 	    return (-1);

	or	eax, -1
	pop	edi
	pop	ebx
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@xmlSchemaC:

; 15381: 	}
; 15382: 	if (WXS_IS_TYPE_NOT_FIXED(itemType))

	cmp	eax, 1
	je	SHORT $LN40@xmlSchemaC
	test	DWORD PTR [edi+48], 4194304		; 00400000H
	jne	SHORT $LN40@xmlSchemaC

; 15383: 	    xmlSchemaTypeFixup(itemType, ACTXT_CAST pctxt);

	push	ebx
	push	edi
	call	_xmlSchemaTypeFixup
	add	esp, 8
$LN40@xmlSchemaC:

; 15384: 	/*
; 15385: 	* 2.1 The {item type definition} must have a {variety} of atomic or
; 15386: 	* union (in which case all the {member type definitions}
; 15387: 	* must be atomic).
; 15388: 	*/
; 15389: 	if ((! WXS_IS_ATOMIC(itemType)) &&

	mov	eax, DWORD PTR [edi+48]
	test	eax, 384				; 00000180H
	jne	SHORT $LN41@xmlSchemaC

; 15390: 	    (! WXS_IS_UNION(itemType))) {
; 15391: 	    xmlSchemaPCustomErr(pctxt,

	lea	eax, DWORD PTR _str$[ebp]
	push	edi
	push	eax
	call	_xmlSchemaGetComponentQName
	push	eax
	push	OFFSET ??_C@_0DO@CNOGHMHL@The?5item?5type?5?8?$CFs?8?5does?5not?5hav@
	jmp	$LN294@xmlSchemaC
$LN41@xmlSchemaC:

; 15392: 		XML_SCHEMAP_COS_ST_RESTRICTS_2_1,
; 15393: 		WXS_BASIC_CAST type, NULL,
; 15394: 		"The item type '%s' does not have a variety of atomic or union",
; 15395: 		xmlSchemaGetComponentQName(&str, itemType));
; 15396: 	    FREE_AND_NULL(str)
; 15397: 	    return (XML_SCHEMAP_COS_ST_RESTRICTS_2_1);
; 15398: 	} else if (WXS_IS_UNION(itemType)) {

	test	al, al
	jns	SHORT $LN6@xmlSchemaC

; 15399: 	    xmlSchemaTypeLinkPtr member;
; 15400: 
; 15401: 	    member = itemType->memberTypes;

	mov	eax, DWORD PTR [edi+92]

; 15402: 	    while (member != NULL) {

	test	eax, eax
	je	SHORT $LN6@xmlSchemaC
	npad	5
$LL5@xmlSchemaC:

; 15403: 		if (! WXS_IS_ATOMIC(member->type)) {

	mov	ecx, DWORD PTR [eax+4]
	test	DWORD PTR [ecx+48], 256			; 00000100H
	je	SHORT $LN245@xmlSchemaC

; 15412: 		}
; 15413: 		member = member->next;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL5@xmlSchemaC
$LN6@xmlSchemaC:

; 15414: 	    }
; 15415: 	}
; 15416: 
; 15417: 	if (WXS_IS_ANY_SIMPLE_TYPE(type->baseType)) {

	mov	eax, DWORD PTR [esi+64]
	cmp	DWORD PTR [eax], 1
	jne	$LN47@xmlSchemaC
	cmp	DWORD PTR [eax+88], 46			; 0000002eH
	jne	$LN47@xmlSchemaC

; 15418: 	    xmlSchemaFacetPtr facet;
; 15419: 	    /*
; 15420: 	    * This is the case if we have: <simpleType><list ..
; 15421: 	    */
; 15422: 	    /*
; 15423: 	    * 2.3.1
; 15424: 	    * 2.3.1.1 The {final} of the {item type definition} must not
; 15425: 	    * contain list.
; 15426: 	    */
; 15427: 	    if (xmlSchemaTypeFinalContains(itemType,

	push	2048					; 00000800H
	push	edi
	call	_xmlSchemaTypeFinalContains
	add	esp, 8
	test	eax, eax
	je	SHORT $LN49@xmlSchemaC

; 15428: 		XML_SCHEMAS_TYPE_FINAL_LIST)) {
; 15429: 		xmlSchemaPCustomErr(pctxt,

	lea	eax, DWORD PTR _str$[ebp]
	push	edi
	push	eax
	call	_xmlSchemaGetComponentQName
	push	eax
	push	OFFSET ??_C@_0DI@HJPNFIBB@The?5final?5of?5its?5item?5type?5?8?$CFs?8@
	push	0
	push	esi
	push	3016					; 00000bc8H
	push	ebx
	call	_xmlSchemaPCustomErr

; 15430: 		    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1,
; 15431: 		    WXS_BASIC_CAST type, NULL,
; 15432: 		    "The final of its item type '%s' must not contain 'list'",
; 15433: 		    xmlSchemaGetComponentQName(&str, itemType));
; 15434: 		FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$[ebp]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN50@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN50@xmlSchemaC:

; 15435: 		return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1);

	pop	edi
	pop	ebx
	mov	eax, 3016				; 00000bc8H
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN245@xmlSchemaC:

; 15404: 		    xmlSchemaPCustomErr(pctxt,

	push	ecx
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaGetComponentQName
	push	eax
	push	OFFSET ??_C@_0FI@NONGNEND@The?5item?5type?5is?5a?5union?5type?0?5@
$LN294@xmlSchemaC:

; 15405: 			XML_SCHEMAP_COS_ST_RESTRICTS_2_1,
; 15406: 			WXS_BASIC_CAST type, NULL,
; 15407: 			"The item type is a union type, but the "
; 15408: 			"member type '%s' of this item type is not atomic",
; 15409: 			xmlSchemaGetComponentQName(&str, member->type));
; 15410: 		    FREE_AND_NULL(str)
; 15411: 		    return (XML_SCHEMAP_COS_ST_RESTRICTS_2_1);

	push	0
	push	esi
	push	3015					; 00000bc7H
	push	ebx
	call	_xmlSchemaPCustomErr
	mov	eax, DWORD PTR _str$[ebp]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN46@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN46@xmlSchemaC:
	pop	edi
	pop	ebx
	mov	eax, 3015				; 00000bc7H
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@xmlSchemaC:

; 15436: 	    }
; 15437: 	    /*
; 15438: 	    * 2.3.1.2 The {facets} must only contain the whiteSpace
; 15439: 	    * facet component.
; 15440: 	    * OPTIMIZE TODO: the S4S already disallows any facet
; 15441: 	    * to be specified.
; 15442: 	    */
; 15443: 	    if (type->facets != NULL) {

	mov	eax, DWORD PTR [esi+68]
	test	eax, eax
	je	SHORT $LN92@xmlSchemaC
	npad	3
$LL9@xmlSchemaC:

; 15444: 		facet = type->facets;
; 15445: 		do {
; 15446: 		    if (facet->type != XML_SCHEMA_FACET_WHITESPACE) {

	cmp	DWORD PTR [eax], 1008			; 000003f0H
	jne	SHORT $LN246@xmlSchemaC

; 15451: 		    }
; 15452: 		    facet = facet->next;

	mov	eax, DWORD PTR [eax+4]

; 15453: 		} while (facet != NULL);

	test	eax, eax
	jne	SHORT $LL9@xmlSchemaC
$LN92@xmlSchemaC:
	pop	edi
	pop	ebx

; 15734: 
; 15735: 	    }
; 15736: 	    /*
; 15737: 	    * SPEC (3.3.2.5) (same as 1.3.2)
; 15738: 	    *
; 15739: 	    * NOTE (3.3.2.5) This is currently done in
; 15740: 	    * xmlSchemaDeriveAndValidateFacets()
; 15741: 	    */
; 15742: 	}
; 15743:     }
; 15744: 
; 15745:     return (0);

	xor	eax, eax
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN246@xmlSchemaC:

; 15447: 			xmlSchemaPIllegalFacetListUnionErr(pctxt,

	push	eax
	push	esi
	push	3017					; 00000bc9H
	push	ebx
	call	_xmlSchemaPIllegalFacetListUnionErr
	add	esp, 16					; 00000010H

; 15448: 			    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2,
; 15449: 			    type, facet);
; 15450: 			return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2);

	mov	eax, 3017				; 00000bc9H
	pop	edi
	pop	ebx
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@xmlSchemaC:

; 15454: 	    }
; 15455: 	    /*
; 15456: 	    * MAYBE TODO: (Hmm, not really) Datatypes states:
; 15457: 	    * A `list` datatype can be `derived` from an `atomic` datatype
; 15458: 	    * whose `lexical space` allows space (such as string or anyURI)or
; 15459: 	    * a `union` datatype any of whose {member type definitions}'s
; 15460: 	    * `lexical space` allows space.
; 15461: 	    */
; 15462: 	} else {
; 15463: 	    /*
; 15464: 	    * This is the case if we have: <simpleType><restriction ...
; 15465: 	    * I.e. the variety of "list" is inherited.
; 15466: 	    */
; 15467: 	    /*
; 15468: 	    * 2.3.2
; 15469: 	    * 2.3.2.1 The {base type definition} must have a {variety} of list.
; 15470: 	    */
; 15471: 	    if (! WXS_IS_LIST(type->baseType)) {

	test	BYTE PTR [eax+48], 64			; 00000040H
	jne	SHORT $LN53@xmlSchemaC

; 15472: 		xmlSchemaPCustomErr(pctxt,

	push	eax
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaGetComponentQName
	push	eax
	push	OFFSET ??_C@_0CH@GNOCMONM@The?5base?5type?5?8?$CFs?8?5must?5be?5a?5li@
	push	0
	push	esi
	push	3018					; 00000bcaH
	push	ebx
	call	_xmlSchemaPCustomErr

; 15473: 		    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1,
; 15474: 		    WXS_BASIC_CAST type, NULL,
; 15475: 		    "The base type '%s' must be a list type",
; 15476: 		    xmlSchemaGetComponentQName(&str, type->baseType));
; 15477: 		FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$[ebp]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN54@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN54@xmlSchemaC:

; 15478: 		return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1);

	pop	edi
	pop	ebx
	mov	eax, 3018				; 00000bcaH
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@xmlSchemaC:

; 15479: 	    }
; 15480: 	    /*
; 15481: 	    * 2.3.2.2 The {final} of the {base type definition} must not
; 15482: 	    * contain restriction.
; 15483: 	    */
; 15484: 	    if (xmlSchemaTypeFinalContains(type->baseType,

	push	1024					; 00000400H
	push	eax
	call	_xmlSchemaTypeFinalContains
	mov	ecx, DWORD PTR [esi+64]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN55@xmlSchemaC

; 15485: 		XML_SCHEMAS_TYPE_FINAL_RESTRICTION)) {
; 15486: 		xmlSchemaPCustomErr(pctxt,

	push	ecx
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaGetComponentQName
	push	eax
	push	OFFSET ??_C@_0EB@DKPMMCLA@The?5?8final?8?5of?5the?5base?5type?5?8?$CF@
	push	0
	push	esi
	push	3019					; 00000bcbH
	push	ebx
	call	_xmlSchemaPCustomErr

; 15487: 		    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2,
; 15488: 		    WXS_BASIC_CAST type, NULL,
; 15489: 		    "The 'final' of the base type '%s' must not contain 'restriction'",
; 15490: 		    xmlSchemaGetComponentQName(&str, type->baseType));
; 15491: 		FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$[ebp]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN56@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN56@xmlSchemaC:

; 15492: 		return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2);

	pop	edi
	pop	ebx
	mov	eax, 3019				; 00000bcbH
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN55@xmlSchemaC:

; 15493: 	    }
; 15494: 	    /*
; 15495: 	    * 2.3.2.3 The {item type definition} must be validly derived
; 15496: 	    * from the {base type definition}'s {item type definition} given
; 15497: 	    * the empty set, as defined in Type Derivation OK (Simple) ($3.14.6).
; 15498: 	    */
; 15499: 	    {
; 15500: 		xmlSchemaTypePtr baseItemType;
; 15501: 
; 15502: 		baseItemType = type->baseType->subtypes;

	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _baseItemType$1$[ebp], eax

; 15503: 		if ((baseItemType == NULL) || (! WXS_IS_SIMPLE(baseItemType))) {

	test	eax, eax
	je	$LN59@xmlSchemaC
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	SHORT $LN57@xmlSchemaC
	cmp	ecx, 1
	jne	$LN59@xmlSchemaC
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	je	$LN59@xmlSchemaC
$LN57@xmlSchemaC:

; 15507: 		}
; 15508: 		if ((itemType != baseItemType) &&

	cmp	edi, eax
	je	$LN60@xmlSchemaC
	push	0
	push	eax
	push	edi
	push	ebx
	call	_xmlSchemaCheckCOSSTDerivedOK
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN60@xmlSchemaC

; 15509: 		    (xmlSchemaCheckCOSSTDerivedOK(ACTXT_CAST pctxt, itemType,
; 15510: 			baseItemType, 0) != 0)) {
; 15511: 		    xmlChar *strBIT = NULL, *strBT = NULL;
; 15512: 		    xmlSchemaPCustomErrExt(pctxt,

	push	DWORD PTR [esi+64]
	lea	eax, DWORD PTR _strBT$2[ebp]
	mov	DWORD PTR _strBIT$6[ebp], 0
	push	eax
	mov	DWORD PTR _strBT$2[ebp], 0
	call	_xmlSchemaGetComponentQName
	add	esp, 8
	push	eax
	push	DWORD PTR _baseItemType$1$[ebp]
	lea	eax, DWORD PTR _strBIT$6[ebp]
	push	eax
	call	_xmlSchemaGetComponentQName
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _str$[ebp]
	push	edi
	push	eax
	call	_xmlSchemaGetComponentQName
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0FI@JBMOEDMD@The?5item?5type?5?8?$CFs?8?5is?5not?5valid@
	push	0
	push	esi
	push	3020					; 00000bccH
	push	ebx
	call	_xmlSchemaPCustomErrExt

; 15513: 			XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3,
; 15514: 			WXS_BASIC_CAST type, NULL,
; 15515: 			"The item type '%s' is not validly derived from "
; 15516: 			"the item type '%s' of the base type '%s'",
; 15517: 			xmlSchemaGetComponentQName(&str, itemType),
; 15518: 			xmlSchemaGetComponentQName(&strBIT, baseItemType),
; 15519: 			xmlSchemaGetComponentQName(&strBT, type->baseType));
; 15520: 
; 15521: 		    FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$[ebp]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN61@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN61@xmlSchemaC:

; 15522: 		    FREE_AND_NULL(strBIT)

	mov	eax, DWORD PTR _strBIT$6[ebp]
	test	eax, eax
	je	SHORT $LN62@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN62@xmlSchemaC:

; 15523: 		    FREE_AND_NULL(strBT)

	mov	eax, DWORD PTR _strBT$2[ebp]
	test	eax, eax
	je	SHORT $LN63@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN63@xmlSchemaC:

; 15524: 		    return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3);

	pop	edi
	pop	ebx
	mov	eax, 3020				; 00000bccH
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN60@xmlSchemaC:

; 15525: 		}
; 15526: 	    }
; 15527: 
; 15528: 	    if (type->facets != NULL) {

	mov	edi, DWORD PTR [esi+68]
	test	edi, edi
	je	$LN92@xmlSchemaC

; 15529: 		xmlSchemaFacetPtr facet;
; 15530: 		int ok = 1;

	mov	ecx, 1
$LL12@xmlSchemaC:

; 15531: 		/*
; 15532: 		* 2.3.2.4 Only length, minLength, maxLength, whiteSpace, pattern
; 15533: 		* and enumeration facet components are allowed among the {facets}.
; 15534: 		*/
; 15535: 		facet = type->facets;
; 15536: 		do {
; 15537: 		    switch (facet->type) {

	mov	eax, DWORD PTR [edi]
	cmp	eax, 1006				; 000003eeH
	jl	SHORT $LN66@xmlSchemaC
	cmp	eax, 1011				; 000003f3H
	jle	SHORT $LN13@xmlSchemaC
$LN66@xmlSchemaC:

; 15538: 			case XML_SCHEMA_FACET_LENGTH:
; 15539: 			case XML_SCHEMA_FACET_MINLENGTH:
; 15540: 			case XML_SCHEMA_FACET_MAXLENGTH:
; 15541: 			case XML_SCHEMA_FACET_WHITESPACE:
; 15542: 			    /*
; 15543: 			    * TODO: 2.5.1.2 List datatypes
; 15544: 			    * The value of `whiteSpace` is fixed to the value collapse.
; 15545: 			    */
; 15546: 			case XML_SCHEMA_FACET_PATTERN:
; 15547: 			case XML_SCHEMA_FACET_ENUMERATION:
; 15548: 			    break;
; 15549: 			default: {
; 15550: 			    xmlSchemaPIllegalFacetListUnionErr(pctxt,

	push	edi
	push	esi
	push	3021					; 00000bcdH
	push	ebx
	call	_xmlSchemaPIllegalFacetListUnionErr
	add	esp, 16					; 00000010H

; 15551: 				XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4,
; 15552: 				type, facet);
; 15553: 			    /*
; 15554: 			    * We could return, but it's nicer to report all
; 15555: 			    * invalid facets.
; 15556: 			    */
; 15557: 			    ok = 0;

	xor	ecx, ecx
$LN13@xmlSchemaC:

; 15558: 			}
; 15559: 		    }
; 15560: 		    facet = facet->next;

	mov	edi, DWORD PTR [edi+4]

; 15561: 		} while (facet != NULL);

	test	edi, edi
	jne	SHORT $LL12@xmlSchemaC

; 15562: 		if (ok == 0)

	test	ecx, ecx
	jne	$LN92@xmlSchemaC

; 15563: 		    return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4);

	pop	edi
	pop	ebx
	mov	eax, 3021				; 00000bcdH
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@xmlSchemaC:

; 15504: 		    PERROR_INT("xmlSchemaCheckCOSSTRestricts",

	push	OFFSET ??_C@_0CM@CKGJJDPM@failed?5to?5eval?5the?5item?5type?5of@
	push	OFFSET ??_C@_0BN@JGCJPHDI@xmlSchemaCheckCOSSTRestricts@
	push	ebx
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH

; 15505: 			"failed to eval the item type of a base type");
; 15506: 		    return (-1);

	or	eax, -1
	pop	edi
	pop	ebx
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@xmlSchemaC:

; 15564: 		/*
; 15565: 		* SPEC (2.3.2.5) (same as 1.3.2)
; 15566: 		*
; 15567: 		* NOTE (2.3.2.5) This is currently done in
; 15568: 		* xmlSchemaDeriveAndValidateFacets()
; 15569: 		*/
; 15570: 	    }
; 15571: 	}
; 15572:     } else if (WXS_IS_UNION(type)) {

	test	al, al
	jns	$LN92@xmlSchemaC

; 15573: 	/*
; 15574: 	* 3.1 The {member type definitions} must all have {variety} of
; 15575: 	* atomic or list.
; 15576: 	*/
; 15577: 	xmlSchemaTypeLinkPtr member;
; 15578: 
; 15579: 	member = type->memberTypes;

	mov	edi, DWORD PTR [esi+92]

; 15580: 	while (member != NULL) {

	mov	ebx, DWORD PTR _pctxt$[ebp]
	test	edi, edi
	je	SHORT $LN16@xmlSchemaC
	npad	3
$LL15@xmlSchemaC:

; 15581: 	    if (WXS_IS_TYPE_NOT_FIXED(member->type))

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, eax
	cmp	DWORD PTR [eax], 1
	je	SHORT $LN69@xmlSchemaC
	test	DWORD PTR [eax+48], 4194304		; 00400000H
	jne	SHORT $LN69@xmlSchemaC

; 15582: 		xmlSchemaTypeFixup(member->type, ACTXT_CAST pctxt);

	push	ebx
	push	eax
	call	_xmlSchemaTypeFixup
	mov	ecx, DWORD PTR [edi+4]
	add	esp, 8
$LN69@xmlSchemaC:

; 15583: 
; 15584: 	    if ((! WXS_IS_ATOMIC(member->type)) &&

	test	DWORD PTR [ecx+48], 320			; 00000140H
	je	SHORT $LN247@xmlSchemaC

; 15593: 	    }
; 15594: 	    member = member->next;

	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	SHORT $LL15@xmlSchemaC
$LN16@xmlSchemaC:

; 15595: 	}
; 15596: 	/*
; 15597: 	* 3.3.1 If the {base type definition} is the `simple ur-type
; 15598: 	* definition`
; 15599: 	*/
; 15600: 	if (type->baseType->builtInType == XML_SCHEMAS_ANYSIMPLETYPE) {

	mov	eax, DWORD PTR [esi+64]
	cmp	DWORD PTR [eax+88], 46			; 0000002eH
	jne	$LN72@xmlSchemaC

; 15601: 	    /*
; 15602: 	    * 3.3.1.1 All of the {member type definitions} must have a
; 15603: 	    * {final} which does not contain union.
; 15604: 	    */
; 15605: 	    member = type->memberTypes;

	mov	eax, DWORD PTR [esi+92]

; 15606: 	    while (member != NULL) {

	test	eax, eax
	je	SHORT $LN18@xmlSchemaC
$LL17@xmlSchemaC:

; 15607: 		if (xmlSchemaTypeFinalContains(member->type,

	mov	ecx, DWORD PTR [eax+4]

; 14652:     if (type == NULL)

	test	ecx, ecx
	je	SHORT $LN275@xmlSchemaC

; 14653: 	return (0);
; 14654:     if (type->flags & final)

	test	DWORD PTR [ecx+48], 4096		; 00001000H
	jne	SHORT $LN248@xmlSchemaC
$LN275@xmlSchemaC:

; 15616: 		}
; 15617: 		member = member->next;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL17@xmlSchemaC
$LN18@xmlSchemaC:

; 15618: 	    }
; 15619: 	    /*
; 15620: 	    * 3.3.1.2 The {facets} must be empty.
; 15621: 	    */
; 15622: 	    if (type->facetSet != NULL) {

	cmp	DWORD PTR [esi+96], 0
	je	$LN92@xmlSchemaC

; 15623: 		xmlSchemaPCustomErr(pctxt,

	push	0
	push	OFFSET ??_C@_0BC@LHNABEDG@No?5facets?5allowed@
	push	0
	push	esi
	push	3025					; 00000bd1H
	push	ebx
	call	_xmlSchemaPCustomErr
	add	esp, 24					; 00000018H

; 15624: 		    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2,
; 15625: 		    WXS_BASIC_CAST type, NULL,
; 15626: 		    "No facets allowed", NULL);
; 15627: 		return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2);

	mov	eax, 3025				; 00000bd1H
	pop	edi
	pop	ebx
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN247@xmlSchemaC:

; 15585: 		(! WXS_IS_LIST(member->type))) {
; 15586: 		xmlSchemaPCustomErr(pctxt,

	push	ecx
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaGetComponentQName
	push	eax
	push	OFFSET ??_C@_0DL@JIAIGPPB@The?5member?5type?5?8?$CFs?8?5is?5neither@
	push	0
	push	esi
	push	3023					; 00000bcfH
	push	ebx
	call	_xmlSchemaPCustomErr

; 15587: 		    XML_SCHEMAP_COS_ST_RESTRICTS_3_1,
; 15588: 		    WXS_BASIC_CAST type, NULL,
; 15589: 		    "The member type '%s' is neither an atomic, nor a list type",
; 15590: 		    xmlSchemaGetComponentQName(&str, member->type));
; 15591: 		FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$[ebp]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN71@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN71@xmlSchemaC:

; 15592: 		return (XML_SCHEMAP_COS_ST_RESTRICTS_3_1);

	pop	edi
	pop	ebx
	mov	eax, 3023				; 00000bcfH
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN248@xmlSchemaC:

; 15608: 		    XML_SCHEMAS_TYPE_FINAL_UNION)) {
; 15609: 		    xmlSchemaPCustomErr(pctxt,

	push	ecx
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaGetComponentQName
	push	eax
	push	OFFSET ??_C@_0DB@GMGLNPMG@The?5?8final?8?5of?5member?5type?5?8?$CFs?8@
	push	0
	push	esi
	push	3024					; 00000bd0H
	push	ebx
	call	_xmlSchemaPCustomErr

; 15610: 			XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1,
; 15611: 			WXS_BASIC_CAST type, NULL,
; 15612: 			"The 'final' of member type '%s' contains 'union'",
; 15613: 			xmlSchemaGetComponentQName(&str, member->type));
; 15614: 		    FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$[ebp]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN75@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN75@xmlSchemaC:

; 15615: 		    return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1);

	pop	edi
	pop	ebx
	mov	eax, 3024				; 00000bd0H
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN72@xmlSchemaC:

; 15628: 	    }
; 15629: 	} else {
; 15630: 	    /*
; 15631: 	    * 3.3.2.1 The {base type definition} must have a {variety} of union.
; 15632: 	    * I.e. the variety of "list" is inherited.
; 15633: 	    */
; 15634: 	    if (! WXS_IS_UNION(type->baseType)) {

	test	BYTE PTR [eax+48], 128			; 00000080H
	jne	SHORT $LN77@xmlSchemaC

; 15635: 		xmlSchemaPCustomErr(pctxt,

	push	eax
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaGetComponentQName
	push	eax
	push	OFFSET ??_C@_0CH@MIGLCPEH@The?5base?5type?5?8?$CFs?8?5is?5not?5a?5uni@
	push	0
	push	esi
	push	3027					; 00000bd3H
	push	ebx
	call	_xmlSchemaPCustomErr

; 15636: 		    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1,
; 15637: 		    WXS_BASIC_CAST type, NULL,
; 15638: 		    "The base type '%s' is not a union type",
; 15639: 		    xmlSchemaGetComponentQName(&str, type->baseType));
; 15640: 		FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$[ebp]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN78@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN78@xmlSchemaC:

; 15641: 		return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1);

	pop	edi
	pop	ebx
	mov	eax, 3027				; 00000bd3H
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN77@xmlSchemaC:

; 15642: 	    }
; 15643: 	    /*
; 15644: 	    * 3.3.2.2 The {final} of the {base type definition} must not contain restriction.
; 15645: 	    */
; 15646: 	    if (xmlSchemaTypeFinalContains(type->baseType,

	push	1024					; 00000400H
	push	eax
	call	_xmlSchemaTypeFinalContains
	add	esp, 8
	test	eax, eax
	je	SHORT $LN79@xmlSchemaC

; 15647: 		XML_SCHEMAS_TYPE_FINAL_RESTRICTION)) {
; 15648: 		xmlSchemaPCustomErr(pctxt,

	push	DWORD PTR [esi+64]
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaGetComponentQName
	push	eax
	push	OFFSET ??_C@_0EB@JOOLHCHD@The?5?8final?8?5of?5its?5base?5type?5?8?$CF@
	push	0
	push	esi
	push	3026					; 00000bd2H
	push	ebx
	call	_xmlSchemaPCustomErr

; 15649: 		    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2,
; 15650: 		    WXS_BASIC_CAST type, NULL,
; 15651: 		    "The 'final' of its base type '%s' must not contain 'restriction'",
; 15652: 		    xmlSchemaGetComponentQName(&str, type->baseType));
; 15653: 		FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$[ebp]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN80@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN80@xmlSchemaC:

; 15654: 		return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2);

	pop	edi
	pop	ebx
	mov	eax, 3026				; 00000bd2H
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN79@xmlSchemaC:

; 15655: 	    }
; 15656: 	    /*
; 15657: 	    * 3.3.2.3 The {member type definitions}, in order, must be validly
; 15658: 	    * derived from the corresponding type definitions in the {base
; 15659: 	    * type definition}'s {member type definitions} given the empty set,
; 15660: 	    * as defined in Type Derivation OK (Simple) ($3.14.6).
; 15661: 	    */
; 15662: 	    {
; 15663: 		xmlSchemaTypeLinkPtr baseMember;
; 15664: 
; 15665: 		/*
; 15666: 		* OPTIMIZE: if the type is restricting, it has no local defined
; 15667: 		* member types and inherits the member types of the base type;
; 15668: 		* thus a check for equality can be skipped.
; 15669: 		*/
; 15670: 		/*
; 15671: 		* Even worse: I cannot see a scenario where a restricting
; 15672: 		* union simple type can have other member types as the member
; 15673: 		* types of it's base type. This check seems not necessary with
; 15674: 		* respect to the derivation process in libxml2.
; 15675: 		* But necessary if constructing types with an API.
; 15676: 		*/
; 15677: 		if (type->memberTypes != NULL) {

	mov	eax, DWORD PTR [esi+92]
	mov	DWORD PTR _member$3$[ebp], eax
	test	eax, eax
	je	SHORT $LN282@xmlSchemaC

; 15678: 		    member = type->memberTypes;
; 15679: 		    baseMember = xmlSchemaGetUnionSimpleTypeMemberTypes(type->baseType);

	push	DWORD PTR [esi+64]
	call	_xmlSchemaGetUnionSimpleTypeMemberTypes
	mov	edi, eax
	add	esp, 4

; 15680: 		    if ((member == NULL) && (baseMember != NULL)) {

	mov	eax, DWORD PTR _member$3$[ebp]
	test	eax, eax
	jne	SHORT $LL19@xmlSchemaC
	test	edi, edi
	je	SHORT $LN282@xmlSchemaC

; 15681: 			PERROR_INT("xmlSchemaCheckCOSSTRestricts",

	push	OFFSET ??_C@_0CJ@HOHKAHOI@different?5number?5of?5member?5type@
	push	OFFSET ??_C@_0BN@JGCJPHDI@xmlSchemaCheckCOSSTRestricts@
	push	ebx
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH
$LN282@xmlSchemaC:

; 15710: 		    }
; 15711: 		}
; 15712: 	    }
; 15713: 	    /*
; 15714: 	    * 3.3.2.4 Only pattern and enumeration facet components are
; 15715: 	    * allowed among the {facets}.
; 15716: 	    */
; 15717: 	    if (type->facets != NULL) {

	mov	edi, DWORD PTR [esi+68]
	test	edi, edi
	je	$LN92@xmlSchemaC

; 15718: 		xmlSchemaFacetPtr facet;
; 15719: 		int ok = 1;

	mov	ecx, 1
	npad	2
$LL23@xmlSchemaC:

; 15720: 
; 15721: 		facet = type->facets;
; 15722: 		do {
; 15723: 		    if ((facet->type != XML_SCHEMA_FACET_PATTERN) &&

	mov	eax, DWORD PTR [edi]
	cmp	eax, 1006				; 000003eeH
	je	SHORT $LN91@xmlSchemaC
	cmp	eax, 1007				; 000003efH
	je	SHORT $LN91@xmlSchemaC

; 15724: 			(facet->type != XML_SCHEMA_FACET_ENUMERATION)) {
; 15725: 			xmlSchemaPIllegalFacetListUnionErr(pctxt,

	push	edi
	push	esi
	push	3029					; 00000bd5H
	push	ebx
	call	_xmlSchemaPIllegalFacetListUnionErr
	add	esp, 16					; 00000010H

; 15726: 				XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4,
; 15727: 				type, facet);
; 15728: 			ok = 0;

	xor	ecx, ecx
$LN91@xmlSchemaC:

; 15729: 		    }
; 15730: 		    facet = facet->next;

	mov	edi, DWORD PTR [edi+4]

; 15731: 		} while (facet != NULL);

	test	edi, edi
	jne	SHORT $LL23@xmlSchemaC

; 15732: 		if (ok == 0)

	test	ecx, ecx
	jne	$LN92@xmlSchemaC

; 15733: 		    return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4);

	pop	edi
	pop	ebx
	mov	eax, 3029				; 00000bd5H
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LL19@xmlSchemaC:

; 15685: 			if (baseMember == NULL) {

	test	edi, edi
	jne	SHORT $LN83@xmlSchemaC

; 15686: 			    PERROR_INT("xmlSchemaCheckCOSSTRestricts",

	push	OFFSET ??_C@_0CJ@HOHKAHOI@different?5number?5of?5member?5type@
	push	OFFSET ??_C@_0BN@JGCJPHDI@xmlSchemaCheckCOSSTRestricts@
	push	ebx
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN295@xmlSchemaC
$LN83@xmlSchemaC:

; 15687: 			    "different number of member types in base");
; 15688: 			} else if ((member->type != baseMember->type) &&

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edi+4]
	cmp	ecx, edx
	je	SHORT $LN85@xmlSchemaC
	push	0
	push	edx
	push	ecx
	push	ebx
	call	_xmlSchemaCheckCOSSTDerivedOK
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN249@xmlSchemaC
$LN295@xmlSchemaC:

; 15706: 			}
; 15707: 			member = member->next;

	mov	eax, DWORD PTR _member$3$[ebp]
$LN85@xmlSchemaC:
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _member$3$[ebp], eax

; 15708:                         if (baseMember != NULL)

	test	edi, edi
	je	SHORT $LN89@xmlSchemaC

; 15709:                             baseMember = baseMember->next;

	mov	edi, DWORD PTR [edi]
$LN89@xmlSchemaC:

; 15682: 			    "different number of member types in base");
; 15683: 		    }
; 15684: 		    while (member != NULL) {

	test	eax, eax
	jne	SHORT $LL19@xmlSchemaC
	jmp	$LN282@xmlSchemaC
$LN249@xmlSchemaC:

; 15689: 			    (xmlSchemaCheckCOSSTDerivedOK(ACTXT_CAST pctxt,
; 15690: 				member->type, baseMember->type, 0) != 0)) {
; 15691: 			    xmlChar *strBMT = NULL, *strBT = NULL;
; 15692: 
; 15693: 			    xmlSchemaPCustomErrExt(pctxt,

	push	DWORD PTR [esi+64]
	lea	eax, DWORD PTR _strBT$3[ebp]
	mov	DWORD PTR _strBMT$1[ebp], 0
	push	eax
	mov	DWORD PTR _strBT$3[ebp], 0
	call	_xmlSchemaGetComponentQName
	add	esp, 8
	push	eax
	push	DWORD PTR [edi+4]
	lea	eax, DWORD PTR _strBMT$1[ebp]
	push	eax
	call	_xmlSchemaGetComponentQName
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _member$3$[ebp]
	push	DWORD PTR [eax+4]
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaGetComponentQName
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0GE@MIEEABNE@The?5member?5type?5?$CFs?5is?5not?5valid@
	push	0
	push	esi
	push	3028					; 00000bd4H
	push	ebx
	call	_xmlSchemaPCustomErrExt

; 15694: 				XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3,
; 15695: 				WXS_BASIC_CAST type, NULL,
; 15696: 				"The member type %s is not validly "
; 15697: 				"derived from its corresponding member "
; 15698: 				"type %s of the base type %s",
; 15699: 				xmlSchemaGetComponentQName(&str, member->type),
; 15700: 				xmlSchemaGetComponentQName(&strBMT, baseMember->type),
; 15701: 				xmlSchemaGetComponentQName(&strBT, type->baseType));
; 15702: 			    FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$[ebp]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN86@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN86@xmlSchemaC:

; 15703: 			    FREE_AND_NULL(strBMT)

	mov	eax, DWORD PTR _strBMT$1[ebp]
	test	eax, eax
	je	SHORT $LN87@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN87@xmlSchemaC:

; 15704: 			    FREE_AND_NULL(strBT)

	mov	eax, DWORD PTR _strBT$3[ebp]
	test	eax, eax
	je	SHORT $LN88@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN88@xmlSchemaC:

; 15705: 			    return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3);

	pop	edi
	pop	ebx
	mov	eax, 3028				; 00000bd4H
	pop	esi

; 15746: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCheckCOSSTRestricts ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckSTPropsCorrect
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_type$ = 12						; size = 4
_xmlSchemaCheckSTPropsCorrect PROC			; COMDAT

; 15192: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _type$[ebp]
	mov	DWORD PTR _str$[ebp], 0
	mov	esi, DWORD PTR [edi+64]
	test	esi, esi
	jne	SHORT $LN2@xmlSchemaC

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	esi
	push	esi
	push	esi
	push	OFFSET ??_C@_0BG@PPOHGOMN@No?5base?5type?5existent@
$LN40@xmlSchemaC:

; 15278: }

	push	0
	push	edi
	push	3008					; 00000bc0H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
	mov	eax, 3008				; 00000bc0H
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN2@xmlSchemaC:

; 15193:     xmlSchemaTypePtr baseType = type->baseType;
; 15194:     xmlChar *str = NULL;
; 15195: 
; 15196:     /* STATE: error funcs converted. */
; 15197:     /*
; 15198:     * Schema Component Constraint: Simple Type Definition Properties Correct
; 15199:     *
; 15200:     * NOTE: This is somehow redundant, since we actually built a simple type
; 15201:     * to have all the needed information; this acts as an self test.
; 15202:     */
; 15203:     /* Base type: If the datatype has been `derived` by `restriction`
; 15204:     * then the Simple Type Definition component from which it is `derived`,
; 15205:     * otherwise the Simple Type Definition for anySimpleType ($4.1.6).
; 15206:     */
; 15207:     if (baseType == NULL) {
; 15208: 	/*
; 15209: 	* TODO: Think about: "modulo the impact of Missing
; 15210: 	* Sub-components ($5.3)."
; 15211: 	*/
; 15212: 	xmlSchemaPCustomErr(ctxt,
; 15213: 	    XML_SCHEMAP_ST_PROPS_CORRECT_1,
; 15214: 	    WXS_BASIC_CAST type, NULL,
; 15215: 	    "No base type existent", NULL);
; 15216: 	return (XML_SCHEMAP_ST_PROPS_CORRECT_1);
; 15217: 
; 15218:     }
; 15219:     if (! WXS_IS_SIMPLE(baseType)) {

	mov	eax, DWORD PTR [esi]
	cmp	eax, 4
	je	SHORT $LN36@xmlSchemaC
	cmp	eax, 1
	jne	SHORT $LN4@xmlSchemaC
	cmp	DWORD PTR [esi+88], 45			; 0000002dH
	jne	SHORT $LN36@xmlSchemaC
$LN4@xmlSchemaC:

; 1429 :     return (xmlSchemaFormatQName(buf,

	push	esi
	call	_xmlSchemaGetComponentName
	add	esp, 4
	push	eax
	push	esi
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaFormatQName

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	eax
	push	OFFSET ??_C@_0CI@BABCEAKF@The?5base?5type?5?8?$CFs?8?5is?5not?5a?5sim@
	push	0
	push	edi
	push	3008					; 00000bc0H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPCustomErrExt
	add	esp, 44					; 0000002cH
	jmp	SHORT $LN38@xmlSchemaC
$LN36@xmlSchemaC:

; 15220: 	xmlSchemaPCustomErr(ctxt,
; 15221: 	    XML_SCHEMAP_ST_PROPS_CORRECT_1,
; 15222: 	    WXS_BASIC_CAST type, NULL,
; 15223: 	    "The base type '%s' is not a simple type",
; 15224: 	    xmlSchemaGetComponentQName(&str, baseType));
; 15225: 	FREE_AND_NULL(str)
; 15226: 	return (XML_SCHEMAP_ST_PROPS_CORRECT_1);
; 15227:     }
; 15228:     if ((WXS_IS_LIST(type) || WXS_IS_UNION(type)) &&
; 15229: 	(WXS_IS_RESTRICTION(type) == 0) &&

	mov	ecx, DWORD PTR [edi+48]
	test	cl, 192					; 000000c0H
	je	SHORT $LN6@xmlSchemaC
	test	cl, 4
	jne	SHORT $LN6@xmlSchemaC
	cmp	eax, 1
	jne	SHORT $LN8@xmlSchemaC
	cmp	DWORD PTR [esi+88], 46			; 0000002eH
	jmp	SHORT $LN39@xmlSchemaC
$LN8@xmlSchemaC:
	cmp	eax, 4
$LN39@xmlSchemaC:

; 15230: 	((! WXS_IS_ANY_SIMPLE_TYPE(baseType)) &&
; 15231:          (baseType->type != XML_SCHEMA_TYPE_SIMPLE))) {
; 15232: 	xmlSchemaPCustomErr(ctxt,

	je	SHORT $LN6@xmlSchemaC
	lea	eax, DWORD PTR _str$[ebp]
	push	esi
	push	eax
	call	_xmlSchemaGetComponentQName

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	eax
	push	OFFSET ??_C@_0GB@OJPAIDNO@A?5type?0?5derived?5by?5list?5or?5unio@
	push	0
	push	edi
	push	3008					; 00000bc0H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPCustomErrExt
	add	esp, 40					; 00000028H
$LN38@xmlSchemaC:

; 15233: 	    XML_SCHEMAP_ST_PROPS_CORRECT_1,
; 15234: 	    WXS_BASIC_CAST type, NULL,
; 15235: 	    "A type, derived by list or union, must have "
; 15236: 	    "the simple ur-type definition as base type, not '%s'",
; 15237: 	    xmlSchemaGetComponentQName(&str, baseType));
; 15238: 	FREE_AND_NULL(str)
; 15239: 	return (XML_SCHEMAP_ST_PROPS_CORRECT_1);

	mov	eax, DWORD PTR _str$[ebp]
	test	eax, eax
	je	SHORT $LN9@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlSchemaC:
	pop	edi
	mov	eax, 3008				; 00000bc0H

; 15278: }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlSchemaC:
	test	ecx, 448				; 000001c0H

; 15240:     }
; 15241:     /*
; 15242:     * Variety: One of {atomic, list, union}.
; 15243:     */
; 15244:     if ((! WXS_IS_ATOMIC(type)) && (! WXS_IS_UNION(type)) &&

	jne	SHORT $LN10@xmlSchemaC

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BG@NAEJKMEI@The?5variety?5is?5absent@

; 15245: 	(! WXS_IS_LIST(type))) {
; 15246: 	xmlSchemaPCustomErr(ctxt,
; 15247: 	    XML_SCHEMAP_ST_PROPS_CORRECT_1,
; 15248: 	    WXS_BASIC_CAST type, NULL,
; 15249: 	    "The variety is absent", NULL);
; 15250: 	return (XML_SCHEMAP_ST_PROPS_CORRECT_1);

	jmp	$LN40@xmlSchemaC
$LN10@xmlSchemaC:

; 14654:     if (type->flags & final)

	test	DWORD PTR [esi+48], 1024		; 00000400H
	je	SHORT $LN11@xmlSchemaC

; 1429 :     return (xmlSchemaFormatQName(buf,

	push	esi
	call	_xmlSchemaGetComponentName
	add	esp, 4
	push	eax
	push	esi
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaFormatQName

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	eax
	push	OFFSET ??_C@_0EB@JOOLHCHD@The?5?8final?8?5of?5its?5base?5type?5?8?$CF@
	push	0
	push	edi
	push	3010					; 00000bc2H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPCustomErrExt

; 15251:     }
; 15252:     /* TODO: Finish this. Hmm, is this finished? */
; 15253: 
; 15254:     /*
; 15255:     * 3 The {final} of the {base type definition} must not contain restriction.
; 15256:     */
; 15257:     if (xmlSchemaTypeFinalContains(baseType,
; 15258: 	XML_SCHEMAS_TYPE_FINAL_RESTRICTION)) {
; 15259: 	xmlSchemaPCustomErr(ctxt,
; 15260: 	    XML_SCHEMAP_ST_PROPS_CORRECT_3,
; 15261: 	    WXS_BASIC_CAST type, NULL,
; 15262: 	    "The 'final' of its base type '%s' must not contain "
; 15263: 	    "'restriction'",
; 15264: 	    xmlSchemaGetComponentQName(&str, baseType));
; 15265: 	FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$[ebp]

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	add	esp, 44					; 0000002cH

; 15251:     }
; 15252:     /* TODO: Finish this. Hmm, is this finished? */
; 15253: 
; 15254:     /*
; 15255:     * 3 The {final} of the {base type definition} must not contain restriction.
; 15256:     */
; 15257:     if (xmlSchemaTypeFinalContains(baseType,
; 15258: 	XML_SCHEMAS_TYPE_FINAL_RESTRICTION)) {
; 15259: 	xmlSchemaPCustomErr(ctxt,
; 15260: 	    XML_SCHEMAP_ST_PROPS_CORRECT_3,
; 15261: 	    WXS_BASIC_CAST type, NULL,
; 15262: 	    "The 'final' of its base type '%s' must not contain "
; 15263: 	    "'restriction'",
; 15264: 	    xmlSchemaGetComponentQName(&str, baseType));
; 15265: 	FREE_AND_NULL(str)

	test	eax, eax
	je	SHORT $LN12@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlSchemaC:

; 15266: 	return (XML_SCHEMAP_ST_PROPS_CORRECT_3);

	pop	edi
	mov	eax, 3010				; 00000bc2H

; 15278: }

	pop	esi
	pop	ebp
	ret	0
$LN11@xmlSchemaC:
	pop	edi

; 15267:     }
; 15268: 
; 15269:     /*
; 15270:     * 2 All simple type definitions must be derived ultimately from the `simple
; 15271:     * ur-type definition` (so circular definitions are disallowed). That is, it
; 15272:     * must be possible to reach a built-in primitive datatype or the `simple
; 15273:     * ur-type definition` by repeatedly following the {base type definition}.
; 15274:     *
; 15275:     * NOTE: this is done in xmlSchemaCheckTypeDefCircular().
; 15276:     */
; 15277:     return (0);

	xor	eax, eax

; 15278: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaCheckSTPropsCorrect ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaResolveTypeReferences
_TEXT	SEGMENT
_name$1$ = -4						; size = 4
_msg$1 = 8						; size = 4
_nsName$1$ = 8						; size = 4
_typeDef$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_xmlSchemaResolveTypeReferences PROC			; COMDAT

; 15063: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _typeDef$[ebp]
	test	esi, esi
	je	$LN12@xmlSchemaR

; 15064:     if (typeDef == NULL)
; 15065: 	return;
; 15066: 
; 15067:     /*
; 15068:     * Resolve the base type.
; 15069:     */
; 15070:     if (typeDef->baseType == NULL) {

	cmp	DWORD PTR [esi+64], 0
	push	ebx
	mov	ebx, DWORD PTR _ctxt$[ebp]
	jne	SHORT $LN4@xmlSchemaR

; 15071: 	typeDef->baseType = xmlSchemaGetType(ctxt->schema,

	push	DWORD PTR [esi+60]
	push	DWORD PTR [esi+56]
	push	DWORD PTR [ebx+36]
	call	_xmlSchemaGetType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+64], eax

; 15072: 	    typeDef->base, typeDef->baseNs);
; 15073: 	if (typeDef->baseType == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlSchemaR

; 15074: 	    xmlSchemaPResCompAttrErr(ctxt,

	push	eax
	push	4
	push	DWORD PTR [esi+60]
	push	DWORD PTR [esi+56]
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	DWORD PTR [esi+36]
	push	esi
	push	3004					; 00000bbcH
	push	ebx
	call	_xmlSchemaPResCompAttrErr
	add	esp, 36					; 00000024H
	pop	ebx
	pop	esi

; 15164: 			/* TODO: error code */
; 15165: 			XML_SCHEMAP_COS_ALL_LIMITED,
; 15166: 			WXS_ITEM_NODE(WXS_TYPE_PARTICLE(typeDef)), NULL,
; 15167: 			"The particle's {max occurs} must be 1, since the "
; 15168: 			"reference resolves to an 'all' model group",
; 15169: 			NULL, NULL);
; 15170: 		}
; 15171: 	    }
; 15172: 	}
; 15173:     }
; 15174: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlSchemaR:

; 15075: 		XML_SCHEMAP_SRC_RESOLVE,
; 15076: 		WXS_BASIC_CAST typeDef, typeDef->node,
; 15077: 		"base", typeDef->base, typeDef->baseNs,
; 15078: 		XML_SCHEMA_TYPE_SIMPLE, NULL);
; 15079: 	    return;
; 15080: 	}
; 15081:     }
; 15082:     if (WXS_IS_SIMPLE(typeDef)) {

	mov	eax, DWORD PTR [esi]
	push	edi
	cmp	eax, 4
	je	$LN7@xmlSchemaR
	cmp	eax, 1
	jne	SHORT $LN5@xmlSchemaR
	cmp	DWORD PTR [esi+88], 45			; 0000002dH
	jne	$LN7@xmlSchemaR
$LN5@xmlSchemaR:

; 15103: 			XML_SCHEMAP_SRC_RESOLVE,
; 15104: 			WXS_BASIC_CAST typeDef, typeDef->node,
; 15105: 			"itemType", typeDef->base, typeDef->baseNs,
; 15106: 			XML_SCHEMA_TYPE_SIMPLE, NULL);
; 15107: 		}
; 15108: 	    }
; 15109: 	    return;
; 15110: 	}
; 15111:     }
; 15112:     /*
; 15113:     * The ball of letters below means, that if we have a particle
; 15114:     * which has a QName-helper component as its {term}, we want
; 15115:     * to resolve it...
; 15116:     */
; 15117:     else if ((WXS_TYPE_CONTENTTYPE(typeDef) != NULL) &&
; 15118: 	((WXS_TYPE_CONTENTTYPE(typeDef))->type ==
; 15119: 	    XML_SCHEMA_TYPE_PARTICLE) &&
; 15120: 	(WXS_TYPE_PARTICLE_TERM(typeDef) != NULL) &&

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	$LN61@xmlSchemaR
	cmp	DWORD PTR [eax], 25			; 00000019H
	jne	$LN61@xmlSchemaR
	mov	edi, DWORD PTR [eax+12]
	test	edi, edi
	je	$LN61@xmlSchemaR
	cmp	DWORD PTR [edi], 2000			; 000007d0H
	jne	$LN61@xmlSchemaR

; 15121: 	((WXS_TYPE_PARTICLE_TERM(typeDef))->type ==
; 15122: 	    XML_SCHEMA_EXTRA_QNAMEREF))
; 15123:     {
; 15124: 	xmlSchemaQNameRefPtr ref =
; 15125: 	    WXS_QNAME_CAST WXS_TYPE_PARTICLE_TERM(typeDef);
; 15126: 	xmlSchemaModelGroupDefPtr groupDef;
; 15127: 
; 15128: 	/*
; 15129: 	* URGENT TODO: Test this.
; 15130: 	*/
; 15131: 	WXS_TYPE_PARTICLE_TERM(typeDef) = NULL;

	mov	DWORD PTR [eax+12], 0

; 15132: 	/*
; 15133: 	* Resolve the MG definition reference.
; 15134: 	*/
; 15135: 	groupDef =

	push	DWORD PTR [edi+16]
	push	DWORD PTR [edi+12]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [ebx+36]
	call	_xmlSchemaGetNamedComponent
	mov	edx, eax
	add	esp, 16					; 00000010H

; 15136: 	    WXS_MODEL_GROUPDEF_CAST xmlSchemaGetNamedComponent(ctxt->schema,
; 15137: 		ref->itemType, ref->name, ref->targetNamespace);
; 15138: 	if (groupDef == NULL) {

	test	edx, edx
	jne	SHORT $LN16@xmlSchemaR

; 15139: 	    xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,

	push	eax
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+16]
	push	DWORD PTR [edi+12]
	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	DWORD PTR [esi+28]
	call	_xmlSchemaGetComponentNode
	add	esp, 4
	push	eax
	push	0
	push	3004					; 00000bbcH
	push	ebx
	call	_xmlSchemaPResCompAttrErr
	add	esp, 36					; 00000024H

; 15140: 		NULL, WXS_ITEM_NODE(WXS_TYPE_PARTICLE(typeDef)),
; 15141: 		"ref", ref->name, ref->targetNamespace, ref->itemType,
; 15142: 		NULL);
; 15143: 	    /* Remove the particle. */
; 15144: 	    WXS_TYPE_CONTENTTYPE(typeDef) = NULL;

	mov	DWORD PTR [esi+28], 0
	pop	edi
	pop	ebx
	pop	esi

; 15164: 			/* TODO: error code */
; 15165: 			XML_SCHEMAP_COS_ALL_LIMITED,
; 15166: 			WXS_ITEM_NODE(WXS_TYPE_PARTICLE(typeDef)), NULL,
; 15167: 			"The particle's {max occurs} must be 1, since the "
; 15168: 			"reference resolves to an 'all' model group",
; 15169: 			NULL, NULL);
; 15170: 		}
; 15171: 	    }
; 15172: 	}
; 15173:     }
; 15174: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlSchemaR:

; 15145: 	} else if (WXS_MODELGROUPDEF_MODEL(groupDef) == NULL)

	mov	ecx, DWORD PTR [edx+12]
	test	ecx, ecx
	jne	SHORT $LN18@xmlSchemaR

; 15146: 	    /* Remove the particle. */
; 15147: 	    WXS_TYPE_CONTENTTYPE(typeDef) = NULL;

	pop	edi
	pop	ebx
	mov	DWORD PTR [esi+28], ecx
	pop	esi

; 15164: 			/* TODO: error code */
; 15165: 			XML_SCHEMAP_COS_ALL_LIMITED,
; 15166: 			WXS_ITEM_NODE(WXS_TYPE_PARTICLE(typeDef)), NULL,
; 15167: 			"The particle's {max occurs} must be 1, since the "
; 15168: 			"reference resolves to an 'all' model group",
; 15169: 			NULL, NULL);
; 15170: 		}
; 15171: 	    }
; 15172: 	}
; 15173:     }
; 15174: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlSchemaR:

; 15148: 	else {
; 15149: 	    /*
; 15150: 	    * Assign the MG definition's {model group} to the
; 15151: 	    * particle's {term}.
; 15152: 	    */
; 15153: 	    WXS_TYPE_PARTICLE_TERM(typeDef) = WXS_MODELGROUPDEF_MODEL(groupDef);

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax+12], ecx

; 15154: 
; 15155: 	    if (WXS_MODELGROUPDEF_MODEL(groupDef)->type == XML_SCHEMA_TYPE_ALL) {

	mov	eax, DWORD PTR [edx+12]
	cmp	DWORD PTR [eax], 8
	jne	$LN61@xmlSchemaR

; 15156: 		/*
; 15157: 		* SPEC cos-all-limited (1.2)
; 15158: 		* "1.2 the {term} property of a particle with
; 15159: 		* {max occurs}=1 which is part of a pair which constitutes
; 15160: 		* the {content type} of a complex type definition."
; 15161: 		*/
; 15162: 		if ((WXS_TYPE_PARTICLE(typeDef))->maxOccurs != 1) {

	mov	eax, DWORD PTR [esi+28]
	cmp	DWORD PTR [eax+20], 1
	je	$LN61@xmlSchemaR

; 15163: 		    xmlSchemaCustomErr(ACTXT_CAST ctxt,

	push	eax
	call	_xmlSchemaGetComponentNode

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,

	mov	esi, eax

; 2339 :     xmlChar *msg = NULL;

	mov	DWORD PTR _msg$1[ebp], 0

; 2340 : 
; 2341 :     if ((node == NULL) && (item != NULL) &&
; 2342 : 	(actxt->type == XML_SCHEMA_CTXT_PARSER)) {
; 2343 : 	node = WXS_ITEM_NODE(item);
; 2344 : 	xmlSchemaFormatItemForReport(&msg, NULL, item, NULL);
; 2345 : 	msg = xmlStrcat(msg, BAD_CAST ": ");
; 2346 :     } else
; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	esi
	lea	eax, DWORD PTR _msg$1[ebp]
	push	ebx
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0FM@NJGNMMEM@The?5particle?8s?5?$HLmax?5occurs?$HN?5mus@
	push	DWORD PTR _msg$1[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	esi
	push	3091					; 00000c13H
	push	2
	push	ebx

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$1[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$1[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 72					; 00000048H

; 2352 :     FREE_AND_NULL(msg)

	test	eax, eax
	je	$LN61@xmlSchemaR
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
	pop	ebx
	pop	esi

; 15164: 			/* TODO: error code */
; 15165: 			XML_SCHEMAP_COS_ALL_LIMITED,
; 15166: 			WXS_ITEM_NODE(WXS_TYPE_PARTICLE(typeDef)), NULL,
; 15167: 			"The particle's {max occurs} must be 1, since the "
; 15168: 			"reference resolves to an 'all' model group",
; 15169: 			NULL, NULL);
; 15170: 		}
; 15171: 	    }
; 15172: 	}
; 15173:     }
; 15174: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlSchemaR:

; 15083: 	if (WXS_IS_UNION(typeDef)) {

	mov	eax, DWORD PTR [esi+48]
	test	al, al
	jns	$LN8@xmlSchemaR

; 13340:     link = type->memberTypes;

	mov	edi, DWORD PTR [esi+92]

; 13341:     lastLink = NULL;

	xor	ebx, ebx

; 13342:     while (link != NULL) {

	test	edi, edi
	je	$LN25@xmlSchemaR
	npad	6
$LL24@xmlSchemaR:

; 13343: 	const xmlChar *name, *nsName;
; 13344: 
; 13345: 	name = ((xmlSchemaQNameRefPtr) link->type)->name;

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+12]

; 13346: 	nsName = ((xmlSchemaQNameRefPtr) link->type)->targetNamespace;

	mov	eax, DWORD PTR [eax+16]

; 13347: 
; 13348: 	memberType = xmlSchemaGetType(ctxt->schema, name, nsName);

	push	eax
	mov	DWORD PTR _nsName$1$[ebp], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	ecx
	mov	DWORD PTR _name$1$[ebp], ecx
	push	DWORD PTR [eax+36]
	call	_xmlSchemaGetType
	add	esp, 12					; 0000000cH

; 13349: 	if ((memberType == NULL) || (! WXS_IS_SIMPLE(memberType))) {

	test	eax, eax
	je	SHORT $LN31@xmlSchemaR
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	SHORT $LN56@xmlSchemaR
	cmp	ecx, 1
	jne	SHORT $LN31@xmlSchemaR
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	je	SHORT $LN31@xmlSchemaR
$LN56@xmlSchemaR:

; 13363: 	} else {
; 13364: 	    link->type = memberType;

	mov	DWORD PTR [edi+4], eax

; 13365: 	    lastLink = link;

	mov	ebx, edi

; 13366: 	    link = link->next;

	mov	edi, DWORD PTR [edi]
	jmp	SHORT $LN29@xmlSchemaR
$LN31@xmlSchemaR:

; 13350: 	    xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,

	push	0
	push	4
	push	DWORD PTR _nsName$1$[ebp]
	push	DWORD PTR _name$1$[ebp]
	push	OFFSET ??_C@_0M@OEMIGMAO@memberTypes@
	push	DWORD PTR [esi+36]
	push	esi
	push	3004					; 00000bbcH
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPResCompAttrErr
	mov	eax, DWORD PTR [edi]
	add	esp, 36					; 00000024H

; 13351: 		WXS_BASIC_CAST type, type->node, "memberTypes",
; 13352: 		name, nsName, XML_SCHEMA_TYPE_SIMPLE, NULL);
; 13353: 	    /*
; 13354: 	    * Remove the member type link.
; 13355: 	    */
; 13356: 	    if (lastLink == NULL)

	test	ebx, ebx
	jne	SHORT $LN32@xmlSchemaR

; 13357: 		type->memberTypes = link->next;

	mov	DWORD PTR [esi+92], eax
	jmp	SHORT $LN33@xmlSchemaR
$LN32@xmlSchemaR:

; 13358: 	    else
; 13359: 		lastLink->next = link->next;

	mov	DWORD PTR [ebx], eax
$LN33@xmlSchemaR:

; 13360: 	    newLink = link;
; 13361: 	    link = link->next;
; 13362: 	    xmlFree(newLink);

	push	edi
	mov	edi, DWORD PTR [edi]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN29@xmlSchemaR:

; 13342:     while (link != NULL) {

	test	edi, edi
	jne	SHORT $LL24@xmlSchemaR
$LN25@xmlSchemaR:

; 13367: 	}
; 13368:     }
; 13369:     /*
; 13370:     * Add local simple types,
; 13371:     */
; 13372:     memberType = type->subtypes;

	mov	edi, DWORD PTR [esi+28]

; 13373:     while (memberType != NULL) {

	test	edi, edi
	je	$LN61@xmlSchemaR
	npad	7
$LL26@xmlSchemaR:

; 13374: 	link = (xmlSchemaTypeLinkPtr) xmlMalloc(sizeof(xmlSchemaTypeLink));

	push	8
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 13375: 	if (link == NULL) {

	test	eax, eax
	je	SHORT $LN52@xmlSchemaR

; 13376: 	    xmlSchemaPErrMemory(ctxt, "allocating a type link", NULL);
; 13377: 	    return (-1);
; 13378: 	}
; 13379: 	link->type = memberType;

	mov	DWORD PTR [eax+4], edi

; 13380: 	link->next = NULL;

	mov	DWORD PTR [eax], 0

; 13381: 	if (lastLink == NULL)

	test	ebx, ebx
	jne	SHORT $LN35@xmlSchemaR

; 13382: 	    type->memberTypes = link;

	mov	DWORD PTR [esi+92], eax
	jmp	SHORT $LN36@xmlSchemaR
$LN35@xmlSchemaR:

; 13383: 	else
; 13384: 	    lastLink->next = link;

	mov	DWORD PTR [ebx], eax
$LN36@xmlSchemaR:

; 13385: 	lastLink = link;
; 13386: 	memberType = memberType->next;

	mov	edi, DWORD PTR [edi+4]
	mov	ebx, eax
	test	edi, edi
	jne	SHORT $LL26@xmlSchemaR
	pop	edi
	pop	ebx
	pop	esi

; 15164: 			/* TODO: error code */
; 15165: 			XML_SCHEMAP_COS_ALL_LIMITED,
; 15166: 			WXS_ITEM_NODE(WXS_TYPE_PARTICLE(typeDef)), NULL,
; 15167: 			"The particle's {max occurs} must be 1, since the "
; 15168: 			"reference resolves to an 'all' model group",
; 15169: 			NULL, NULL);
; 15170: 		}
; 15171: 	    }
; 15172: 	}
; 15173:     }
; 15174: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@xmlSchemaR:

; 1884 :     if (ctxt != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN39@xmlSchemaR

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [eax+20]
$LN39@xmlSchemaR:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BH@ENHIIAOL@allocating?5a?5type?5link@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
	pop	edi
	pop	ebx
	pop	esi

; 15164: 			/* TODO: error code */
; 15165: 			XML_SCHEMAP_COS_ALL_LIMITED,
; 15166: 			WXS_ITEM_NODE(WXS_TYPE_PARTICLE(typeDef)), NULL,
; 15167: 			"The particle's {max occurs} must be 1, since the "
; 15168: 			"reference resolves to an 'all' model group",
; 15169: 			NULL, NULL);
; 15170: 		}
; 15171: 	    }
; 15172: 	}
; 15173:     }
; 15174: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlSchemaR:

; 15084: 	    /*
; 15085: 	    * Resolve the memberTypes.
; 15086: 	    */
; 15087: 	    xmlSchemaResolveUnionMemberTypes(ctxt, typeDef);
; 15088: 	    return;
; 15089: 	} else if (WXS_IS_LIST(typeDef)) {

	test	al, 64					; 00000040H
	je	SHORT $LN61@xmlSchemaR

; 15090: 	    /*
; 15091: 	    * Resolve the itemType.
; 15092: 	    */
; 15093: 	    if ((typeDef->subtypes == NULL) && (typeDef->base != NULL)) {

	cmp	DWORD PTR [esi+28], 0
	jne	SHORT $LN61@xmlSchemaR
	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN61@xmlSchemaR

; 15094: 
; 15095: 		typeDef->subtypes = xmlSchemaGetType(ctxt->schema,

	push	DWORD PTR [esi+60]
	push	eax
	push	DWORD PTR [ebx+36]
	call	_xmlSchemaGetType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+28], eax

; 15096: 		    typeDef->base, typeDef->baseNs);
; 15097: 
; 15098: 		if ((typeDef->subtypes == NULL) ||

	test	eax, eax
	je	SHORT $LN14@xmlSchemaR
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	SHORT $LN61@xmlSchemaR
	cmp	ecx, 1
	jne	SHORT $LN14@xmlSchemaR
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	jne	SHORT $LN61@xmlSchemaR
$LN14@xmlSchemaR:

; 15099: 		    (! WXS_IS_SIMPLE(typeDef->subtypes)))
; 15100: 		{
; 15101: 		    typeDef->subtypes = NULL;
; 15102: 		    xmlSchemaPResCompAttrErr(ctxt,

	push	0
	push	4
	push	DWORD PTR [esi+60]
	mov	DWORD PTR [esi+28], 0
	push	DWORD PTR [esi+56]
	push	OFFSET ??_C@_08DLBHENKN@itemType@
	push	DWORD PTR [esi+36]
	push	esi
	push	3004					; 00000bbcH
	push	ebx
	call	_xmlSchemaPResCompAttrErr
	add	esp, 36					; 00000024H
$LN61@xmlSchemaR:
	pop	edi
	pop	ebx
$LN12@xmlSchemaR:
	pop	esi

; 15164: 			/* TODO: error code */
; 15165: 			XML_SCHEMAP_COS_ALL_LIMITED,
; 15166: 			WXS_ITEM_NODE(WXS_TYPE_PARTICLE(typeDef)), NULL,
; 15167: 			"The particle's {max occurs} must be 1, since the "
; 15168: 			"reference resolves to an 'all' model group",
; 15169: 			NULL, NULL);
; 15170: 		}
; 15171: 	    }
; 15172: 	}
; 15173:     }
; 15174: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaResolveTypeReferences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckUnionTypeDefCircular
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlSchemaCheckUnionTypeDefCircular PROC		; COMDAT

; 15045: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	test	BYTE PTR [eax+48], 128			; 00000080H
	jne	SHORT $LN2@xmlSchemaC

; 15046:     if (! WXS_IS_UNION(type))
; 15047: 	return(0);

	xor	eax, eax

; 15049: 	type->memberTypes));
; 15050: }

	pop	ebp
	ret	0
$LN2@xmlSchemaC:

; 15048:     return(xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, type,

	push	DWORD PTR [eax+92]
	push	eax
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaCheckUnionTypeDefCircularRecur
	add	esp, 12					; 0000000cH

; 15049: 	type->memberTypes));
; 15050: }

	pop	ebp
	ret	0
_xmlSchemaCheckUnionTypeDefCircular ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckUnionTypeDefCircularRecur
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_ctxType$ = 12						; size = 4
_members$ = 16						; size = 4
_xmlSchemaCheckUnionTypeDefCircularRecur PROC		; COMDAT

; 15007: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _members$[ebp]
	test	ebx, ebx
	je	SHORT $LN35@xmlSchemaC
	mov	edi, DWORD PTR _ctxType$[ebp]
	mov	edx, DWORD PTR _pctxt$[ebp]
	npad	3
$LL2@xmlSchemaC:

; 15008:     xmlSchemaTypeLinkPtr member;
; 15009:     xmlSchemaTypePtr memberType;
; 15010: 
; 15011:     member = members;
; 15012:     while (member != NULL) {
; 15013: 	memberType = member->type;

	mov	esi, DWORD PTR [ebx+4]

; 15014: 	while ((memberType != NULL) &&

	test	esi, esi
	je	SHORT $LN37@xmlSchemaC
$LL4@xmlSchemaC:
	cmp	DWORD PTR [esi], 1
	je	SHORT $LN37@xmlSchemaC

; 15015: 	    (memberType->type != XML_SCHEMA_TYPE_BASIC)) {
; 15016: 	    if (memberType == ctxType) {

	cmp	esi, edi
	je	SHORT $LN22@xmlSchemaC

; 15022: 	    }
; 15023: 	    if ((WXS_IS_UNION(memberType)) &&

	mov	ecx, DWORD PTR [esi+48]
	mov	eax, ecx
	and	eax, 65664				; 00010080H
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN33@xmlSchemaC

; 15024: 		((memberType->flags & XML_SCHEMAS_TYPE_MARKED) == 0))
; 15025: 	    {
; 15026: 		int res;
; 15027: 		memberType->flags |= XML_SCHEMAS_TYPE_MARKED;

	or	ecx, 65536				; 00010000H

; 15028: 		res = xmlSchemaCheckUnionTypeDefCircularRecur(pctxt,

	mov	eax, esi
	mov	DWORD PTR [esi+48], ecx
	npad	4
$LL13@xmlSchemaC:

; 14670:     while ((type != NULL) && (type->type == XML_SCHEMA_TYPE_SIMPLE)) {

	cmp	DWORD PTR [eax], 4
	jne	SHORT $LN14@xmlSchemaC

; 14671: 	if (type->memberTypes != NULL)

	mov	ecx, DWORD PTR [eax+92]
	test	ecx, ecx
	jne	SHORT $LN12@xmlSchemaC

; 14672: 	    return (type->memberTypes);
; 14673: 	else
; 14674: 	    type = type->baseType;

	mov	eax, DWORD PTR [eax+64]
	test	eax, eax
	jne	SHORT $LL13@xmlSchemaC
$LN14@xmlSchemaC:

; 14675:     }
; 14676:     return (NULL);

	xor	ecx, ecx
$LN12@xmlSchemaC:

; 15028: 		res = xmlSchemaCheckUnionTypeDefCircularRecur(pctxt,

	push	ecx
	push	edi
	push	edx
	call	_xmlSchemaCheckUnionTypeDefCircularRecur

; 15029: 		    ctxType,
; 15030: 		    xmlSchemaGetUnionSimpleTypeMemberTypes(memberType));
; 15031: 		memberType->flags ^= XML_SCHEMAS_TYPE_MARKED;

	xor	DWORD PTR [esi+48], 65536		; 00010000H
	add	esp, 12					; 0000000cH

; 15032: 		if (res != 0)

	test	eax, eax
	jne	SHORT $LN1@xmlSchemaC
	mov	edx, DWORD PTR _pctxt$[ebp]
$LN33@xmlSchemaC:

; 15033: 		    return(res);
; 15034: 	    }
; 15035: 	    memberType = memberType->baseType;

	mov	esi, DWORD PTR [esi+64]
	test	esi, esi
	jne	SHORT $LL4@xmlSchemaC
$LN37@xmlSchemaC:

; 15036: 	}
; 15037: 	member = member->next;

	mov	ebx, DWORD PTR [ebx]
	test	ebx, ebx
	jne	SHORT $LL2@xmlSchemaC
$LN35@xmlSchemaC:

; 15038:     }
; 15039:     return(0);

	xor	eax, eax
$LN1@xmlSchemaC:
	pop	edi

; 15040: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN22@xmlSchemaC:

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CG@FDHFJMFM@The?5union?5type?5definition?5is?5ci@
	push	0
	push	edi
	push	3003					; 00000bbbH
	push	edx
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 15017: 		xmlSchemaPCustomErr(pctxt,
; 15018: 		    XML_SCHEMAP_SRC_SIMPLE_TYPE_4,
; 15019: 		    WXS_BASIC_CAST ctxType, NULL,
; 15020: 		    "The union type definition is circular", NULL);
; 15021: 		return (XML_SCHEMAP_SRC_SIMPLE_TYPE_4);

	mov	eax, 3003				; 00000bbbH
	pop	edi

; 15040: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaCheckUnionTypeDefCircularRecur ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckTypeDefCircular
_TEXT	SEGMENT
_item$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_xmlSchemaCheckTypeDefCircular PROC			; COMDAT

; 14981: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _item$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaC

; 14982:     if ((item == NULL) ||
; 14983: 	(item->type == XML_SCHEMA_TYPE_BASIC) ||

	cmp	DWORD PTR [eax], 1
	je	SHORT $LN3@xmlSchemaC
	mov	ecx, DWORD PTR [eax+64]
	test	ecx, ecx
	je	SHORT $LN3@xmlSchemaC

; 14984: 	(item->baseType == NULL))
; 14985: 	return;
; 14986:     xmlSchemaCheckTypeDefCircularInternal(ctxt, item,

	push	ecx
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaCheckTypeDefCircularInternal
	add	esp, 12					; 0000000cH
$LN3@xmlSchemaC:

; 14987: 	item->baseType);
; 14988: }

	pop	ebp
	ret	0
_xmlSchemaCheckTypeDefCircular ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckTypeDefCircularInternal
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_ctxtType$ = 12						; size = 4
_ancestor$ = 16						; size = 4
_xmlSchemaCheckTypeDefCircularInternal PROC		; COMDAT

; 14944: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ancestor$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaC

; 14945:     int ret;
; 14946: 
; 14947:     if ((ancestor == NULL) || (ancestor->type == XML_SCHEMA_TYPE_BASIC))

	cmp	DWORD PTR [esi], 1
	je	SHORT $LN3@xmlSchemaC

; 14949: 
; 14950:     if (ctxtType == ancestor) {

	mov	edi, DWORD PTR _ctxtType$[ebp]
	cmp	edi, esi
	jne	SHORT $LN4@xmlSchemaC

; 14951: 	xmlSchemaPCustomErr(pctxt,

	push	edi
	call	_xmlSchemaGetComponentNode

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BL@KGAFCIDP@The?5definition?5is?5circular@
	push	eax
	push	edi
	push	3009					; 00000bc1H
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaPCustomErrExt
	add	esp, 36					; 00000024H

; 14952: 	    XML_SCHEMAP_ST_PROPS_CORRECT_2,
; 14953: 	    WXS_BASIC_CAST ctxtType, WXS_ITEM_NODE(ctxtType),
; 14954: 	    "The definition is circular", NULL);
; 14955: 	return (XML_SCHEMAP_ST_PROPS_CORRECT_2);

	mov	eax, 3009				; 00000bc1H
	pop	edi

; 14967:     return (ret);
; 14968: }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlSchemaC:

; 14956:     }
; 14957:     if (ancestor->flags & XML_SCHEMAS_TYPE_MARKED) {

	mov	eax, DWORD PTR [esi+48]
	test	eax, 65536				; 00010000H
	jne	SHORT $LN3@xmlSchemaC

; 14958: 	/*
; 14959: 	* Avoid inifinite recursion on circular types not yet checked.
; 14960: 	*/
; 14961: 	return (0);
; 14962:     }
; 14963:     ancestor->flags |= XML_SCHEMAS_TYPE_MARKED;
; 14964:     ret = xmlSchemaCheckTypeDefCircularInternal(pctxt, ctxtType,

	push	DWORD PTR [esi+64]
	or	eax, 65536				; 00010000H
	push	edi
	push	DWORD PTR _pctxt$[ebp]
	mov	DWORD PTR [esi+48], eax
	call	_xmlSchemaCheckTypeDefCircularInternal
	add	esp, 12					; 0000000cH

; 14965: 	ancestor->baseType);
; 14966:     ancestor->flags ^= XML_SCHEMAS_TYPE_MARKED;

	xor	DWORD PTR [esi+48], 65536		; 00010000H
	pop	edi

; 14967:     return (ret);
; 14968: }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlSchemaC:
	pop	edi

; 14948: 	return (0);

	xor	eax, eax

; 14967:     return (ret);
; 14968: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaCheckTypeDefCircularInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIsParticleEmptiable
_TEXT	SEGMENT
_particle$ = 8						; size = 4
_xmlSchemaIsParticleEmptiable PROC			; COMDAT

; 14807: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _particle$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaI

; 14808:     /*
; 14809:     * SPEC (1) "Its {min occurs} is 0."
; 14810:     */
; 14811:     if ((particle == NULL) || (particle->minOccurs == 0) ||

	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN3@xmlSchemaI
	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN3@xmlSchemaI

; 14814:     /*
; 14815:     * SPEC (2) "Its {term} is a group and the minimum part of the
; 14816:     * effective total range of that group, [...] is 0."
; 14817:     */
; 14818:     if (WXS_IS_MODEL_GROUP(particle->children)) {

	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, 6
	je	SHORT $LN5@xmlSchemaI
	cmp	ecx, 7
	je	SHORT $LN5@xmlSchemaI
	cmp	ecx, 8
	jne	SHORT $LN6@xmlSchemaI
$LN5@xmlSchemaI:

; 14819: 	if (xmlSchemaGetParticleTotalRangeMin(particle) == 0)

	push	eax
	call	_xmlSchemaGetParticleTotalRangeMin
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@xmlSchemaI
$LN6@xmlSchemaI:

; 14820: 	    return (1);
; 14821:     }
; 14822:     return (0);

	xor	eax, eax

; 14823: }

	pop	ebp
	ret	0
$LN3@xmlSchemaI:

; 14812: 	(particle->children == NULL))
; 14813: 	return (1);

	mov	eax, 1

; 14823: }

	pop	ebp
	ret	0
_xmlSchemaIsParticleEmptiable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetParticleTotalRangeMin
_TEXT	SEGMENT
_particle$ = 8						; size = 4
_xmlSchemaGetParticleTotalRangeMin PROC			; COMDAT

; 14690: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _particle$[ebp]
	mov	eax, DWORD PTR [ebx+12]
	test	eax, eax
	je	$LN8@xmlSchemaG

; 14691:     if ((particle->children == NULL) ||

	cmp	DWORD PTR [ebx+16], 0
	je	$LN8@xmlSchemaG

; 14692: 	(particle->minOccurs == 0))
; 14693: 	return (0);
; 14694:     if (particle->children->type == XML_SCHEMA_TYPE_CHOICE) {

	cmp	DWORD PTR [eax], 7
	mov	esi, DWORD PTR [eax+12]
	jne	SHORT $LN9@xmlSchemaG

; 14695: 	int min = -1, cur;

	or	edi, -1

; 14696: 	xmlSchemaParticlePtr part =
; 14697: 	    (xmlSchemaParticlePtr) particle->children->children;
; 14698: 
; 14699: 	if (part == NULL)

	test	esi, esi
	je	SHORT $LN8@xmlSchemaG
$LL2@xmlSchemaG:

; 14700: 	    return (0);
; 14701: 	while (part != NULL) {
; 14702: 	    if ((part->children->type == XML_SCHEMA_TYPE_ELEMENT) ||

	mov	eax, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [eax]
	cmp	eax, 14					; 0000000eH
	je	SHORT $LN31@xmlSchemaG
	cmp	eax, 2
	je	SHORT $LN31@xmlSchemaG

; 14705: 	    else
; 14706: 		cur = xmlSchemaGetParticleTotalRangeMin(part);

	push	esi
	call	_xmlSchemaGetParticleTotalRangeMin
	add	esp, 4
	jmp	SHORT $LN13@xmlSchemaG
$LN31@xmlSchemaG:

; 14703: 		(part->children->type == XML_SCHEMA_TYPE_ANY))
; 14704: 		cur = part->minOccurs;

	mov	eax, DWORD PTR [esi+16]
$LN13@xmlSchemaG:

; 14707: 	    if (cur == 0)

	test	eax, eax
	je	SHORT $LN8@xmlSchemaG

; 14708: 		return (0);
; 14709: 	    if ((min > cur) || (min == -1))

	cmp	edi, eax
	jg	SHORT $LN17@xmlSchemaG
	cmp	edi, -1
	jne	SHORT $LN16@xmlSchemaG
$LN17@xmlSchemaG:

; 14710: 		min = cur;

	mov	edi, eax
$LN16@xmlSchemaG:

; 14711: 	    part = (xmlSchemaParticlePtr) part->next;

	mov	esi, DWORD PTR [esi+8]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaG

; 14712: 	}
; 14713: 	return (particle->minOccurs * min);

	mov	eax, DWORD PTR [ebx+16]
	imul	eax, edi
	pop	edi

; 14731:     }
; 14732: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlSchemaG:

; 14714:     } else {
; 14715: 	/* <all> and <sequence> */
; 14716: 	int sum = 0;

	xor	edi, edi

; 14717: 	xmlSchemaParticlePtr part =
; 14718: 	    (xmlSchemaParticlePtr) particle->children->children;
; 14719: 
; 14720: 	if (part == NULL)

	test	esi, esi
	je	SHORT $LN8@xmlSchemaG
	npad	5
$LL6@xmlSchemaG:

; 14721: 	    return (0);
; 14722: 	do {
; 14723: 	    if ((part->children->type == XML_SCHEMA_TYPE_ELEMENT) ||

	mov	eax, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [eax]
	cmp	eax, 14					; 0000000eH
	je	SHORT $LN32@xmlSchemaG
	cmp	eax, 2
	je	SHORT $LN32@xmlSchemaG

; 14726: 	    else
; 14727: 		sum += xmlSchemaGetParticleTotalRangeMin(part);

	push	esi
	call	_xmlSchemaGetParticleTotalRangeMin
	add	esp, 4
	add	edi, eax
	jmp	SHORT $LN20@xmlSchemaG
$LN32@xmlSchemaG:

; 14724: 		(part->children->type == XML_SCHEMA_TYPE_ANY))
; 14725: 		sum += part->minOccurs;

	add	edi, DWORD PTR [esi+16]
$LN20@xmlSchemaG:

; 14728: 	    part = (xmlSchemaParticlePtr) part->next;

	mov	esi, DWORD PTR [esi+8]

; 14729: 	} while (part != NULL);

	test	esi, esi
	jne	SHORT $LL6@xmlSchemaG

; 14730: 	return (particle->minOccurs * sum);

	mov	eax, DWORD PTR [ebx+16]
	imul	eax, edi
	pop	edi

; 14731:     }
; 14732: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlSchemaG:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaGetParticleTotalRangeMin ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaTypeFinalContains
_TEXT	SEGMENT
_type$ = 8						; size = 4
_final$ = 12						; size = 4
_xmlSchemaTypeFinalContains PROC			; COMDAT

; 14651: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _type$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlSchemaT

; 14652:     if (type == NULL)
; 14653: 	return (0);
; 14654:     if (type->flags & final)

	mov	eax, DWORD PTR _final$[ebp]
	test	DWORD PTR [ecx+48], eax
	je	SHORT $LN3@xmlSchemaT

; 14655: 	return (1);

	mov	eax, 1

; 14658: }

	pop	ebp
	ret	0
$LN3@xmlSchemaT:

; 14656:     else
; 14657: 	return (0);

	xor	eax, eax

; 14658: }

	pop	ebp
	ret	0
_xmlSchemaTypeFinalContains ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFixupTypeAttributeUses
_TEXT	SEGMENT
_baseType$1$ = -32					; size = 4
tv818 = -28						; size = 4
_baseUses$1$ = -24					; size = 4
_i$1$ = -20						; size = 4
_use$1$ = -16						; size = 4
tv826 = -12						; size = 4
_prohibs$1$ = -8					; size = 4
_usesCount$1$ = -4					; size = 4
_pctxt$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlSchemaFixupTypeAttributeUses PROC			; COMDAT

; 14454: {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	edi, edi
	mov	DWORD PTR _prohibs$1$[ebp], edi
	mov	edi, DWORD PTR _type$[ebp]
	mov	ebx, DWORD PTR [edi+64]
	mov	DWORD PTR _baseType$1$[ebp], ebx
	test	ebx, ebx
	jne	SHORT $LN14@xmlSchemaF

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	ebx
	push	ebx
	push	OFFSET ??_C@_0N@OMCNPMDL@no?5base?5type@
	push	OFFSET ??_C@_0CA@OFHPNPHI@xmlSchemaFixupTypeAttributeUses@
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$LN102@xmlSchemaF:
	pop	edi

; 14635: }

	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlSchemaF:

; 14455:     xmlSchemaTypePtr baseType = NULL;
; 14456:     xmlSchemaAttributeUsePtr use;
; 14457:     xmlSchemaItemListPtr uses, baseUses, prohibs = NULL;
; 14458: 
; 14459:     if (type->baseType == NULL) {
; 14460: 	PERROR_INT("xmlSchemaFixupTypeAttributeUses",
; 14461: 	    "no base type");
; 14462:         return (-1);
; 14463:     }
; 14464:     baseType = type->baseType;
; 14465:     if (WXS_IS_TYPE_NOT_FIXED(baseType))

	cmp	DWORD PTR [ebx], 1
	je	SHORT $LN16@xmlSchemaF
	test	DWORD PTR [ebx+48], 4194304		; 00400000H
	jne	SHORT $LN16@xmlSchemaF

; 14466: 	if (xmlSchemaTypeFixup(baseType, ACTXT_CAST pctxt) == -1)

	push	DWORD PTR _pctxt$[ebp]
	push	ebx
	call	_xmlSchemaTypeFixup
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN102@xmlSchemaF
$LN16@xmlSchemaF:

; 14467: 	    return(-1);
; 14468: 
; 14469:     uses = type->attrUses;
; 14470:     baseUses = baseType->attrUses;

	mov	ebx, DWORD PTR [ebx+116]
	push	esi
	mov	esi, DWORD PTR [edi+116]
	mov	DWORD PTR _baseUses$1$[ebp], ebx

; 14471:     /*
; 14472:     * Expand attribute group references. And build the 'complete'
; 14473:     * wildcard, i.e. intersect multiple wildcards.
; 14474:     * Move attribute prohibitions into a separate list.
; 14475:     */
; 14476:     if (uses != NULL) {

	test	esi, esi
	je	$LN99@xmlSchemaF

; 14477: 	if (WXS_IS_RESTRICTION(type)) {

	test	BYTE PTR [edi+48], 4
	lea	eax, DWORD PTR [edi+84]
	je	SHORT $LN18@xmlSchemaF

; 14478: 	    /*
; 14479: 	    * This one will transfer all attr. prohibitions
; 14480: 	    * into pctxt->attrProhibs.
; 14481: 	    */
; 14482: 	    if (xmlSchemaExpandAttributeGroupRefs(pctxt,
; 14483: 		WXS_BASIC_CAST type, &(type->attributeWildcard), uses,
; 14484: 		pctxt->attrProhibs) == -1)

	mov	ecx, DWORD PTR _pctxt$[ebp]
	push	DWORD PTR [ecx+128]
	push	esi
	push	eax
	push	edi
	push	ecx
	call	_xmlSchemaExpandAttributeGroupRefs
	add	esp, 20					; 00000014H
	cmp	eax, -1
	jne	SHORT $LN59@xmlSchemaF

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BM@FJOPIFJN@failed?5to?5expand?5attributes@
	push	OFFSET ??_C@_0CA@OFHPNPHI@xmlSchemaFixupTypeAttributeUses@
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$LN59@xmlSchemaF:

; 14485: 	    {
; 14486: 		PERROR_INT("xmlSchemaFixupTypeAttributeUses",
; 14487: 		"failed to expand attributes");
; 14488: 	    }
; 14489: 	    if (pctxt->attrProhibs->nbItems != 0)

	mov	eax, DWORD PTR _pctxt$[ebp]
	mov	edx, DWORD PTR [eax+128]

; 14490: 		prohibs = pctxt->attrProhibs;
; 14491: 	} else {

	xor	eax, eax
	cmp	DWORD PTR [edx+4], eax
	cmove	edx, eax
	mov	DWORD PTR _prohibs$1$[ebp], edx
	jmp	SHORT $LN61@xmlSchemaF
$LN18@xmlSchemaF:

; 14492: 	    if (xmlSchemaExpandAttributeGroupRefs(pctxt,
; 14493: 		WXS_BASIC_CAST type, &(type->attributeWildcard), uses,
; 14494: 		NULL) == -1)

	push	0
	push	esi
	push	eax
	push	edi
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaExpandAttributeGroupRefs
	add	esp, 20					; 00000014H
	cmp	eax, -1
	jne	SHORT $LN99@xmlSchemaF

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BM@FJOPIFJN@failed?5to?5expand?5attributes@
	push	OFFSET ??_C@_0CA@OFHPNPHI@xmlSchemaFixupTypeAttributeUses@
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$LN99@xmlSchemaF:

; 14495: 	    {
; 14496: 		PERROR_INT("xmlSchemaFixupTypeAttributeUses",
; 14497: 		"failed to expand attributes");
; 14498: 	    }
; 14499: 	}
; 14500:     }
; 14501:     /*
; 14502:     * Inherit the attribute uses of the base type.
; 14503:     */
; 14504:     if (baseUses != NULL) {

	xor	edx, edx
$LN61@xmlSchemaF:
	test	ebx, ebx
	je	$LN12@xmlSchemaF

; 14505: 	int i, j;
; 14506: 	xmlSchemaAttributeUseProhibPtr pro;
; 14507: 
; 14508: 	if (WXS_IS_RESTRICTION(type)) {

	test	BYTE PTR [edi+48], 4
	je	$LN24@xmlSchemaF

; 14509: 	    int usesCount;
; 14510: 	    xmlSchemaAttributeUsePtr tmp;
; 14511: 
; 14512: 	    if (uses != NULL)

	test	esi, esi
	je	SHORT $LN26@xmlSchemaF

; 14513: 		usesCount = uses->nbItems;

	mov	eax, DWORD PTR [esi+4]
	jmp	SHORT $LN101@xmlSchemaF
$LN26@xmlSchemaF:

; 14514: 	    else
; 14515: 		usesCount = 0;

	xor	eax, eax
$LN101@xmlSchemaF:

; 14516: 
; 14517: 	    /* Restriction. */
; 14518: 	    for (i = 0; i < baseUses->nbItems; i++) {

	xor	ecx, ecx
	mov	DWORD PTR _usesCount$1$[ebp], eax
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	DWORD PTR [ebx+4], ecx
	jle	$LN12@xmlSchemaF
$LL4@xmlSchemaF:

; 14519: 		use = baseUses->items[i];

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _use$1$[ebp], eax

; 14520: 		if (prohibs) {

	test	edx, edx
	je	SHORT $LN6@xmlSchemaF

; 14521: 		    /*
; 14522: 		    * Filter out prohibited uses.
; 14523: 		    */
; 14524: 		    for (j = 0; j < prohibs->nbItems; j++) {

	mov	edi, DWORD PTR _prohibs$1$[ebp]
	xor	edx, edx
	mov	ebx, DWORD PTR [edi+4]
	test	ebx, ebx
	jle	SHORT $LN6@xmlSchemaF

; 14525: 			pro = prohibs->items[j];
; 14526: 			if ((WXS_ATTRUSE_DECL_NAME(use) == pro->name) &&

	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv826[ebp], eax
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv818[ebp], ecx
	mov	ecx, DWORD PTR [edi]
	npad	5
$LL7@xmlSchemaF:
	mov	edi, DWORD PTR [ecx]
	mov	eax, DWORD PTR tv818[ebp]
	cmp	eax, DWORD PTR [edi+8]
	mov	eax, DWORD PTR tv826[ebp]
	jne	SHORT $LN5@xmlSchemaF
	mov	eax, DWORD PTR [eax+56]
	cmp	eax, DWORD PTR [edi+12]
	je	SHORT $inherit_next$104
$LN5@xmlSchemaF:

; 14521: 		    /*
; 14522: 		    * Filter out prohibited uses.
; 14523: 		    */
; 14524: 		    for (j = 0; j < prohibs->nbItems; j++) {

	inc	edx
	add	ecx, 4
	cmp	edx, ebx
	jl	SHORT $LL7@xmlSchemaF
$LN6@xmlSchemaF:

; 14527: 			    (WXS_ATTRUSE_DECL_TNS(use) ==
; 14528: 				pro->targetNamespace))
; 14529: 			{
; 14530: 			    goto inherit_next;
; 14531: 			}
; 14532: 		    }
; 14533: 		}
; 14534: 		if (usesCount) {

	mov	eax, DWORD PTR _usesCount$1$[ebp]
	test	eax, eax
	je	SHORT $LN9@xmlSchemaF

; 14535: 		    /*
; 14536: 		    * Filter out existing uses.
; 14537: 		    */
; 14538: 		    for (j = 0; j < usesCount; j++) {

	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN9@xmlSchemaF

; 14539: 			tmp = uses->items[j];
; 14540: 			if ((WXS_ATTRUSE_DECL_NAME(use) ==
; 14541: 				WXS_ATTRUSE_DECL_NAME(tmp)) &&

	mov	ebx, DWORD PTR _use$1$[ebp]
	mov	edx, DWORD PTR [esi]
	mov	ebx, DWORD PTR [ebx+12]
$LL10@xmlSchemaF:
	mov	eax, DWORD PTR [edx]
	mov	edi, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [ebx+8]
	cmp	eax, DWORD PTR [edi+8]
	jne	SHORT $LN8@xmlSchemaF
	mov	eax, DWORD PTR [ebx+56]
	cmp	eax, DWORD PTR [edi+56]
	je	SHORT $inherit_next$104
$LN8@xmlSchemaF:

; 14535: 		    /*
; 14536: 		    * Filter out existing uses.
; 14537: 		    */
; 14538: 		    for (j = 0; j < usesCount; j++) {

	inc	ecx
	add	edx, 4
	cmp	ecx, DWORD PTR _usesCount$1$[ebp]
	jl	SHORT $LL10@xmlSchemaF
$LN9@xmlSchemaF:

; 14542: 			    (WXS_ATTRUSE_DECL_TNS(use) ==
; 14543: 				WXS_ATTRUSE_DECL_TNS(tmp)))
; 14544: 			{
; 14545: 			    goto inherit_next;
; 14546: 			}
; 14547: 		    }
; 14548: 		}
; 14549: 		if (uses == NULL) {

	test	esi, esi
	jne	SHORT $LN32@xmlSchemaF

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 3342 :     if (ret == NULL) {

	test	esi, esi
	je	SHORT $LN94@xmlSchemaF

; 14550: 		    type->attrUses = xmlSchemaItemListCreate();

	mov	eax, DWORD PTR _type$[ebp]
	xorps	xmm0, xmm0

; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));

	movq	QWORD PTR [esi], xmm0
	mov	DWORD PTR [esi+8], 0

; 14550: 		    type->attrUses = xmlSchemaItemListCreate();

	mov	DWORD PTR [eax+116], esi
$LN32@xmlSchemaF:

; 14551: 		    if (type->attrUses == NULL)
; 14552: 			goto exit_failure;
; 14553: 		    uses = type->attrUses;
; 14554: 		}
; 14555: 		xmlSchemaItemListAddSize(uses, 2, use);

	push	DWORD PTR _use$1$[ebp]
	push	2
	push	esi
	call	_xmlSchemaItemListAddSize
	add	esp, 12					; 0000000cH
$inherit_next$104:

; 14516: 
; 14517: 	    /* Restriction. */
; 14518: 	    for (i = 0; i < baseUses->nbItems; i++) {

	mov	ecx, DWORD PTR _i$1$[ebp]
	mov	ebx, DWORD PTR _baseUses$1$[ebp]
	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	ecx, DWORD PTR [ebx+4]
	jge	SHORT $LN97@xmlSchemaF
	mov	edx, DWORD PTR _prohibs$1$[ebp]
	jmp	$LL4@xmlSchemaF
$LN94@xmlSchemaF:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@BAFOADOL@allocating?5an?5item?5list?5structu@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError

; 14550: 		    type->attrUses = xmlSchemaItemListCreate();

	mov	eax, DWORD PTR _type$[ebp]

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	add	esp, 20					; 00000014H
	pop	esi
	pop	edi

; 14550: 		    type->attrUses = xmlSchemaItemListCreate();

	mov	DWORD PTR [eax+116], 0

; 14632: 
; 14633: exit_failure:
; 14634:     return(-1);

	or	eax, -1

; 14635: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlSchemaF:

; 14556: inherit_next: {}
; 14557: 	    }
; 14558: 	} else {
; 14559: 	    /* Extension. */
; 14560: 	    for (i = 0; i < baseUses->nbItems; i++) {

	xor	edi, edi
	cmp	DWORD PTR [ebx+4], edi
	jle	SHORT $LN97@xmlSchemaF
	npad	2
$LL13@xmlSchemaF:

; 14561: 		use = baseUses->items[i];

	mov	eax, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [eax+edi*4]

; 14562: 		if (uses == NULL) {

	test	esi, esi
	jne	SHORT $LN34@xmlSchemaF

; 14563: 		    type->attrUses = xmlSchemaItemListCreate();

	call	_xmlSchemaItemListCreate
	mov	esi, eax
	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+116], esi

; 14564: 		    if (type->attrUses == NULL)

	test	esi, esi
	je	SHORT $exit_failure$105
$LN34@xmlSchemaF:

; 14565: 			goto exit_failure;
; 14566: 		    uses = type->attrUses;
; 14567: 		}
; 14568: 		xmlSchemaItemListAddSize(uses, baseUses->nbItems, use);

	push	ebx
	mov	ebx, DWORD PTR _baseUses$1$[ebp]
	push	DWORD PTR [ebx+4]
	push	esi
	call	_xmlSchemaItemListAddSize
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, DWORD PTR [ebx+4]
	jl	SHORT $LL13@xmlSchemaF
$LN97@xmlSchemaF:

; 14569: 	    }
; 14570: 	}
; 14571:     }
; 14572:     /*
; 14573:     * Shrink attr. uses.
; 14574:     */
; 14575:     if (uses) {

	mov	edi, DWORD PTR _type$[ebp]
$LN12@xmlSchemaF:
	test	esi, esi
	je	SHORT $LN37@xmlSchemaF

; 14576: 	if (uses->nbItems == 0) {

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN37@xmlSchemaF

; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN71@xmlSchemaF

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN71@xmlSchemaF:

; 3534 :     xmlFree(list);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 14577: 	    xmlSchemaItemListFree(uses);
; 14578: 	    type->attrUses = NULL;

	mov	DWORD PTR [edi+116], 0
$LN37@xmlSchemaF:

; 14579: 	}
; 14580: 	/*
; 14581: 	* TODO: We could shrink the size of the array
; 14582: 	* to fit the actual number of items.
; 14583: 	*/
; 14584:     }
; 14585:     /*
; 14586:     * Compute the complete wildcard.
; 14587:     */
; 14588:     if (WXS_IS_EXTENSION(type)) {

	test	BYTE PTR [edi+48], 2
	je	SHORT $LN43@xmlSchemaF

; 14589: 	if (baseType->attributeWildcard != NULL) {

	mov	eax, DWORD PTR _baseType$1$[ebp]
	mov	eax, DWORD PTR [eax+84]
	test	eax, eax
	je	SHORT $LN43@xmlSchemaF

; 14590: 	    /*
; 14591: 	    * (3.2.2.1) "If the `base wildcard` is non-`absent`, then
; 14592: 	    * the appropriate case among the following:"
; 14593: 	    */
; 14594: 	    if (type->attributeWildcard != NULL) {

	mov	ecx, DWORD PTR [edi+84]
	test	ecx, ecx
	je	SHORT $LN42@xmlSchemaF

; 14595: 		/*
; 14596: 		* Union the complete wildcard with the base wildcard.
; 14597: 		* SPEC {attribute wildcard}
; 14598: 		* (3.2.2.1.2) "otherwise a wildcard whose {process contents}
; 14599: 		* and {annotation} are those of the `complete wildcard`,
; 14600: 		* and whose {namespace constraint} is the intensional union
; 14601: 		* of the {namespace constraint} of the `complete wildcard`
; 14602: 		* and of the `base wildcard`, as defined in Attribute
; 14603: 		* Wildcard Union ($3.10.6)."
; 14604: 		*/
; 14605: 		if (xmlSchemaUnionWildcards(pctxt, type->attributeWildcard,
; 14606: 		    baseType->attributeWildcard) == -1)

	push	eax
	push	ecx
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaUnionWildcards
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN43@xmlSchemaF
$exit_failure$105:
	pop	esi
	pop	edi

; 14632: 
; 14633: exit_failure:
; 14634:     return(-1);

	or	eax, -1

; 14635: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@xmlSchemaF:

; 14607: 		    goto exit_failure;
; 14608: 	    } else {
; 14609: 		/*
; 14610: 		* (3.2.2.1.1) "If the `complete wildcard` is `absent`,
; 14611: 		* then the `base wildcard`."
; 14612: 		*/
; 14613: 		type->attributeWildcard = baseType->attributeWildcard;

	mov	DWORD PTR [edi+84], eax
$LN43@xmlSchemaF:
	pop	esi
	pop	edi

; 14614: 	    }
; 14615: 	} else {
; 14616: 	    /*
; 14617: 	    * (3.2.2.2) "otherwise (the `base wildcard` is `absent`) the
; 14618: 	    * `complete wildcard`"
; 14619: 	    * NOOP
; 14620: 	    */
; 14621: 	}
; 14622:     } else {
; 14623: 	/*
; 14624: 	* SPEC {attribute wildcard}
; 14625: 	* (3.1) "If the <restriction> alternative is chosen, then the
; 14626: 	* `complete wildcard`;"
; 14627: 	* NOOP
; 14628: 	*/
; 14629:     }
; 14630: 
; 14631:     return (0);

	xor	eax, eax

; 14635: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaFixupTypeAttributeUses ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaExpandAttributeGroupRefs
_TEXT	SEGMENT
_item$1$ = -12						; size = 4
_str$1 = -12						; size = 4
tv991 = -8						; size = 4
_created$1$ = -8					; size = 4
_sublist$1$ = -4					; size = 4
_gr$1$ = -4						; size = 4
_i$2$ = -4						; size = 4
_pctxt$ = 8						; size = 4
_item$ = 12						; size = 4
_prohib$1$ = 16						; size = 4
_msg$2 = 16						; size = 4
_completeWild$ = 16					; size = 4
_list$ = 20						; size = 4
_prohibs$ = 24						; size = 4
_xmlSchemaExpandAttributeGroupRefs PROC			; COMDAT

; 19202: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _completeWild$[ebp]
	xor	eax, eax
	mov	ecx, DWORD PTR _prohibs$[ebp]
	cmp	DWORD PTR [edx], eax
	setne	al
	mov	DWORD PTR _created$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN101@xmlSchemaE

; 19203:     xmlSchemaAttributeGroupPtr gr;
; 19204:     xmlSchemaAttributeUsePtr use;
; 19205:     xmlSchemaItemListPtr sublist;
; 19206:     int i, j;
; 19207:     int created = (*completeWild == NULL) ? 0 : 1;
; 19208: 
; 19209:     if (prohibs)
; 19210: 	prohibs->nbItems = 0;

	mov	DWORD PTR [ecx+4], 0
$LN101@xmlSchemaE:
	push	ebx

; 19211: 
; 19212:     for (i = 0; i < list->nbItems; i++) {

	mov	ebx, DWORD PTR _list$[ebp]
	push	esi
	xor	esi, esi
	push	edi
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	jle	$LN99@xmlSchemaE
	npad	2
$LL4@xmlSchemaE:

; 19213: 	use = list->items[i];

	mov	eax, DWORD PTR [ebx]
	mov	edi, DWORD PTR [eax+esi*4]

; 19214: 
; 19215: 	if (use->type == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB) {

	mov	eax, DWORD PTR [edi]
	cmp	eax, 2001				; 000007d1H
	jne	SHORT $LN15@xmlSchemaE

; 19216: 	    if (prohibs == NULL) {

	test	ecx, ecx
	je	$LN68@xmlSchemaE

; 19217: 		PERROR_INT("xmlSchemaExpandAttributeGroupRefs",
; 19218: 		    "unexpected attr prohibition found");
; 19219: 		return(-1);
; 19220: 	    }
; 19221: 	    /*
; 19222: 	    * Remove from attribute uses.
; 19223: 	    */
; 19224: 	    if (xmlSchemaItemListRemove(list, i) == -1)

	push	esi
	push	ebx
	call	_xmlSchemaItemListRemove
	add	esp, 8
	cmp	eax, -1
	je	$LN77@xmlSchemaE

; 19225: 		return(-1);
; 19226: 	    i--;
; 19227: 	    /*
; 19228: 	    * Note that duplicate prohibitions were already
; 19229: 	    * handled at parsing time.
; 19230: 	    */
; 19231: 	    /*
; 19232: 	    * Add to list of prohibitions.
; 19233: 	    */
; 19234: 	    xmlSchemaItemListAddSize(prohibs, 2, use);

	push	edi
	push	2
	push	DWORD PTR _prohibs$[ebp]
	dec	esi
	call	_xmlSchemaItemListAddSize
	add	esp, 12					; 0000000cH

; 19235: 	    continue;

	jmp	$LN108@xmlSchemaE
$LN15@xmlSchemaE:

; 19236: 	}
; 19237: 	if ((use->type == XML_SCHEMA_EXTRA_QNAMEREF) &&

	cmp	eax, 2000				; 000007d0H
	jne	$LN2@xmlSchemaE
	cmp	DWORD PTR [edi+8], 16			; 00000010H
	jne	$LN2@xmlSchemaE

; 19238: 	    ((WXS_QNAME_CAST use)->itemType == XML_SCHEMA_TYPE_ATTRIBUTEGROUP))
; 19239: 	{
; 19240: 	    if ((WXS_QNAME_CAST use)->item == NULL)

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _gr$1$[ebp], eax
	test	eax, eax
	je	$LN77@xmlSchemaE

; 19241: 		return(-1);
; 19242: 	    gr = WXS_ATTR_GROUP_CAST (WXS_QNAME_CAST use)->item;
; 19243: 	    /*
; 19244: 	    * Expand the referenced attr. group.
; 19245: 	    * TODO: remove this, this is done in a previous step, so
; 19246: 	    * already done here.
; 19247: 	    */
; 19248: 	    if ((gr->flags & XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED) == 0) {

	test	BYTE PTR [eax+36], 1
	jne	SHORT $LN21@xmlSchemaE

; 19249: 		if (xmlSchemaAttributeGroupExpandRefs(pctxt, gr) == -1)

	push	eax
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaAttributeGroupExpandRefs
	add	esp, 8
	cmp	eax, -1
	je	$LN77@xmlSchemaE
	mov	eax, DWORD PTR _gr$1$[ebp]
	mov	edx, DWORD PTR _completeWild$[ebp]
$LN21@xmlSchemaE:

; 19250: 		    return(-1);
; 19251: 	    }
; 19252: 	    /*
; 19253: 	    * Build the 'complete' wildcard; i.e. intersect multiple
; 19254: 	    * wildcards.
; 19255: 	    */
; 19256: 	    if (gr->attributeWildcard != NULL) {

	mov	ecx, DWORD PTR [eax+40]
	test	ecx, ecx
	je	$LN28@xmlSchemaE

; 19257: 		if (*completeWild == NULL) {

	mov	edi, DWORD PTR [edx]
	test	edi, edi
	jne	SHORT $LN23@xmlSchemaE

; 19258: 		    *completeWild = gr->attributeWildcard;

	mov	DWORD PTR [edx], ecx

; 19259: 		} else {

	jmp	SHORT $LN28@xmlSchemaE
$LN23@xmlSchemaE:

; 19260: 		    if (! created) {

	cmp	DWORD PTR _created$1$[ebp], 0
	jne	SHORT $LN25@xmlSchemaE

; 19261: 			xmlSchemaWildcardPtr tmpWild;
; 19262: 
; 19263: 			 /*
; 19264: 			* Copy the first encountered wildcard as context,
; 19265: 			* except for the annotation.
; 19266: 			*
; 19267: 			* Although the complete wildcard might not correspond
; 19268: 			* to any node in the schema, we will anchor it on
; 19269: 			* the node of the owner component.
; 19270: 			*/
; 19271: 			tmpWild =  xmlSchemaAddWildcard(pctxt, pctxt->schema,

	push	DWORD PTR _item$[ebp]
	call	_xmlSchemaGetComponentNode
	push	eax
	mov	eax, DWORD PTR _pctxt$[ebp]
	push	21					; 00000015H
	push	DWORD PTR [eax+36]
	push	eax
	call	_xmlSchemaAddWildcard
	mov	edi, eax
	add	esp, 20					; 00000014H

; 19272: 			    XML_SCHEMA_TYPE_ANY_ATTRIBUTE,
; 19273: 			    WXS_ITEM_NODE(item));
; 19274: 			if (tmpWild == NULL)

	test	edi, edi
	je	$LN77@xmlSchemaE

; 19275: 			    return(-1);
; 19276: 			if (xmlSchemaCloneWildcardNsConstraints(pctxt,
; 19277: 			    tmpWild, *completeWild) == -1)

	mov	eax, DWORD PTR _completeWild$[ebp]
	push	DWORD PTR [eax]
	push	edi
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaCloneWildcardNsConstraints
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	je	$LN77@xmlSchemaE

; 19278: 			    return (-1);
; 19279: 			tmpWild->processContents = (*completeWild)->processContents;

	mov	ecx, DWORD PTR _completeWild$[ebp]

; 19280: 			*completeWild = tmpWild;
; 19281: 			created = 1;

	mov	DWORD PTR _created$1$[ebp], 1
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR [edi+24], eax
	mov	eax, DWORD PTR _gr$1$[ebp]
	mov	DWORD PTR [ecx], edi
	mov	ecx, DWORD PTR [eax+40]
$LN25@xmlSchemaE:

; 19282: 		    }
; 19283: 
; 19284: 		    if (xmlSchemaIntersectWildcards(pctxt, *completeWild,
; 19285: 			gr->attributeWildcard) == -1)

	push	ecx
	push	edi
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaIntersectWildcards
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	je	$LN77@xmlSchemaE
	mov	eax, DWORD PTR _gr$1$[ebp]
$LN28@xmlSchemaE:

; 19286: 			return(-1);
; 19287: 		}
; 19288: 	    }
; 19289: 	    /*
; 19290: 	    * Just remove the reference if the referenced group does not
; 19291: 	    * contain any attribute uses.
; 19292: 	    */
; 19293: 	    sublist = ((xmlSchemaItemListPtr) gr->attrUses);

	mov	edx, DWORD PTR [eax+56]
	mov	DWORD PTR _sublist$1$[ebp], edx

; 19294: 	    if ((sublist == NULL) || sublist->nbItems == 0) {

	test	edx, edx
	je	$LN30@xmlSchemaE
	cmp	DWORD PTR [edx+4], 0
	je	$LN30@xmlSchemaE

; 19298: 		continue;
; 19299: 	    }
; 19300: 	    /*
; 19301: 	    * Add the attribute uses.
; 19302: 	    */
; 19303: 	    list->items[i] = sublist->items[0];

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+esi*4], eax

; 19304: 	    if (sublist->nbItems != 1) {

	cmp	DWORD PTR [edx+4], 1
	je	$LN108@xmlSchemaE

; 19305: 		for (j = 1; j < sublist->nbItems; j++) {

	mov	edi, 1
	jle	$LN108@xmlSchemaE
$LL7@xmlSchemaE:

; 19306: 		    i++;
; 19307: 		    if (xmlSchemaItemListInsert(list,
; 19308: 			    sublist->items[j], i) == -1)

	mov	eax, DWORD PTR [edx]
	inc	esi

; 3419 :     if (list->items == NULL) {

	mov	ecx, DWORD PTR [ebx]

; 19306: 		    i++;
; 19307: 		    if (xmlSchemaItemListInsert(list,
; 19308: 			    sublist->items[j], i) == -1)

	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR _item$1$[ebp], eax

; 3419 :     if (list->items == NULL) {

	test	ecx, ecx
	jne	SHORT $LN45@xmlSchemaE

; 3420 : 	list->items = (void **) xmlMalloc(

	push	80					; 00000050H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [ebx], ecx

; 3421 : 	    20 * sizeof(void *));
; 3422 : 	if (list->items == NULL) {

	test	ecx, ecx
	je	$LN96@xmlSchemaE

; 3423 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3424 : 	    return(-1);
; 3425 : 	}
; 3426 : 	list->sizeItems = 20;

	mov	DWORD PTR [ebx+8], 20			; 00000014H
	jmp	SHORT $LN49@xmlSchemaE
$LN45@xmlSchemaE:

; 3427 :     } else if (list->sizeItems <= list->nbItems) {

	mov	eax, DWORD PTR [ebx+8]
	cmp	eax, DWORD PTR [ebx+4]
	jg	SHORT $LN49@xmlSchemaE

; 3428 : 	list->sizeItems *= 2;

	add	eax, eax
	mov	DWORD PTR [ebx+8], eax

; 3429 : 	list->items = (void **) xmlRealloc(list->items,

	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR [ebx], ecx

; 3430 : 	    list->sizeItems * sizeof(void *));
; 3431 : 	if (list->items == NULL) {

	test	ecx, ecx
	je	$LN98@xmlSchemaE
$LN49@xmlSchemaE:

; 3434 : 	    return(-1);
; 3435 : 	}
; 3436 :     }
; 3437 :     /*
; 3438 :     * Just append if the index is greater/equal than the item count.
; 3439 :     */
; 3440 :     if (idx >= list->nbItems) {

	mov	eax, DWORD PTR [ebx+4]
	cmp	esi, eax
	jl	SHORT $LL50@xmlSchemaE

; 3441 : 	list->items[list->nbItems++] = item;

	mov	edx, DWORD PTR _item$1$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 3442 :     } else {

	jmp	SHORT $LN112@xmlSchemaE
$LL50@xmlSchemaE:

; 3443 : 	int i;
; 3444 : 	for (i = list->nbItems; i > idx; i--)
; 3445 : 	    list->items[i] = list->items[i-1];

	mov	ecx, DWORD PTR [ebx]
	lea	edx, DWORD PTR [ecx+eax*4]
	dec	eax
	mov	ecx, DWORD PTR [edx-4]
	mov	DWORD PTR [edx], ecx
	cmp	eax, esi
	jg	SHORT $LL50@xmlSchemaE

; 3446 : 	list->items[idx] = item;

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR _item$1$[ebp]
	mov	DWORD PTR [eax+esi*4], ecx
$LN112@xmlSchemaE:

; 19305: 		for (j = 1; j < sublist->nbItems; j++) {

	mov	edx, DWORD PTR _sublist$1$[ebp]
	inc	edi
	inc	DWORD PTR [ebx+4]
	cmp	edi, DWORD PTR [edx+4]
	jl	$LL7@xmlSchemaE

; 19341: 		    /*
; 19342: 		    * Remove the prohibition.
; 19343: 		    */
; 19344: 		    if (xmlSchemaItemListRemove(prohibs, i) == -1)

	jmp	SHORT $LN108@xmlSchemaE
$LN30@xmlSchemaE:

; 19295: 		if (xmlSchemaItemListRemove(list, i) == -1)

	push	esi
	push	ebx
	call	_xmlSchemaItemListRemove
	add	esp, 8
	cmp	eax, -1
	je	$LN77@xmlSchemaE

; 19296: 		    return(-1);
; 19297: 		i--;

	dec	esi
$LN108@xmlSchemaE:

; 19211: 
; 19212:     for (i = 0; i < list->nbItems; i++) {

	mov	edx, DWORD PTR _completeWild$[ebp]
	mov	ecx, DWORD PTR _prohibs$[ebp]
$LN2@xmlSchemaE:
	mov	eax, DWORD PTR [ebx+4]
	inc	esi
	cmp	esi, eax
	jl	$LL4@xmlSchemaE
$LN99@xmlSchemaE:

; 19309: 			return(-1);
; 19310: 		}
; 19311: 	    }
; 19312: 	}
; 19313: 
; 19314:     }
; 19315:     /*
; 19316:     * Handle pointless prohibitions of declared attributes.
; 19317:     */
; 19318:     if (prohibs && (prohibs->nbItems != 0) && (list->nbItems != 0)) {

	test	ecx, ecx
	je	$LN104@xmlSchemaE
	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	je	$LN104@xmlSchemaE
	test	eax, eax
	je	$LN104@xmlSchemaE

; 19319: 	xmlSchemaAttributeUseProhibPtr prohib;
; 19320: 
; 19321: 	for (i = prohibs->nbItems -1; i >= 0; i--) {

	add	ecx, -1
	mov	DWORD PTR _i$2$[ebp], ecx
	js	$LN104@xmlSchemaE
	npad	2
$LL10@xmlSchemaE:

; 19322: 	    prohib = prohibs->items[i];

	mov	eax, DWORD PTR _prohibs$[ebp]

; 19323: 	    for (j = 0; j < list->nbItems; j++) {

	mov	edi, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+ecx*4]
	xor	ecx, ecx
	mov	DWORD PTR _prohib$1$[ebp], esi
	test	edi, edi
	jle	$LN8@xmlSchemaE

; 19324: 		use = list->items[j];
; 19325: 
; 19326: 		if ((prohib->name == WXS_ATTRUSE_DECL_NAME(use)) &&

	mov	eax, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [ebx]
	mov	DWORD PTR tv991[ebp], eax
$LL13@xmlSchemaE:
	mov	eax, DWORD PTR [edx]
	mov	ebx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax+12]
	cmp	ebx, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR _list$[ebp]
	jne	SHORT $LN11@xmlSchemaE
	mov	esi, DWORD PTR [esi+12]
	cmp	esi, DWORD PTR [eax+56]
	je	SHORT $LN76@xmlSchemaE
	mov	esi, DWORD PTR _prohib$1$[ebp]
$LN11@xmlSchemaE:

; 19323: 	    for (j = 0; j < list->nbItems; j++) {

	inc	ecx
	add	edx, 4
	cmp	ecx, edi
	jl	SHORT $LL13@xmlSchemaE
	jmp	$LN8@xmlSchemaE
$LN68@xmlSchemaE:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CC@JIEJECEC@unexpected?5attr?5prohibition?5fou@
	push	OFFSET ??_C@_0CC@NLBCMGHN@xmlSchemaExpandAttributeGroupRe@
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaInternalErr2

; 19345: 			return(-1);
; 19346: 		    break;
; 19347: 		}
; 19348: 	    }
; 19349: 	}
; 19350:     }
; 19351:     return(0);
; 19352: }

	add	esp, 20					; 00000014H
$LN77@xmlSchemaE:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN96@xmlSchemaE:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BJ@JABJNCPJ@allocating?5new?5item?5list@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError

; 19345: 			return(-1);
; 19346: 		    break;
; 19347: 		}
; 19348: 	    }
; 19349: 	}
; 19350:     }
; 19351:     return(0);
; 19352: }

	add	esp, 20					; 00000014H
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN98@xmlSchemaE:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BC@PKMEEMHP@growing?5item?5list@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError

; 19345: 			return(-1);
; 19346: 		    break;
; 19347: 		}
; 19348: 	    }
; 19349: 	}
; 19350:     }
; 19351:     return(0);
; 19352: }

	add	esp, 20					; 00000014H

; 3433 : 	    list->sizeItems = 0;

	mov	DWORD PTR [ebx+8], 0

; 19345: 			return(-1);
; 19346: 		    break;
; 19347: 		}
; 19348: 	    }
; 19349: 	}
; 19350:     }
; 19351:     return(0);
; 19352: }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN76@xmlSchemaE:

; 19327: 		    (prohib->targetNamespace == WXS_ATTRUSE_DECL_TNS(use)))
; 19328: 		{
; 19329: 		    xmlChar *str = NULL;
; 19330: 
; 19331: 		    xmlSchemaCustomWarning(ACTXT_CAST pctxt,

	push	DWORD PTR tv991[ebp]
	lea	eax, DWORD PTR _str$1[ebp]
	mov	DWORD PTR _str$1[ebp], 0
	push	esi
	push	eax
	call	_xmlSchemaFormatQName
	mov	edi, DWORD PTR _prohib$1$[ebp]
	mov	esi, eax

; 2382 :     xmlSchemaFormatNodeForError(&msg, actxt, node);

	lea	eax, DWORD PTR _msg$2[ebp]
	mov	DWORD PTR _msg$2[ebp], 0

; 19327: 		    (prohib->targetNamespace == WXS_ATTRUSE_DECL_TNS(use)))
; 19328: 		{
; 19329: 		    xmlChar *str = NULL;
; 19330: 
; 19331: 		    xmlSchemaCustomWarning(ACTXT_CAST pctxt,

	mov	edi, DWORD PTR [edi+4]

; 2382 :     xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	edi
	push	DWORD PTR _pctxt$[ebp]
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2383 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0HN@PJGMJAIH@Skipping?5pointless?5attribute?5us@
	push	DWORD PTR _msg$2[ebp]
	call	_xmlStrcat

; 2384 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$2[ebp], eax
	call	_xmlStrcat

; 2385 : 
; 2386 :     /* URGENT TODO: Set the error code to something sane. */
; 2387 :     xmlSchemaErr4Line(actxt, XML_ERR_WARNING, error, node, 0,

	push	0
	push	0
	push	0
	push	esi
	push	eax
	push	0
	push	edi
	push	3086					; 00000c0eH
	push	1
	push	DWORD PTR _pctxt$[ebp]
	mov	DWORD PTR _msg$2[ebp], eax
	call	_xmlSchemaErr4Line

; 2388 : 	(const char *) msg, str1, str2, str3, NULL);
; 2389 : 
; 2390 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$2[ebp]
	add	esp, 80					; 00000050H
	test	eax, eax
	je	SHORT $LN60@xmlSchemaE
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN60@xmlSchemaE:

; 19332: 			XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
; 19333: 			prohib->node, NULL,
; 19334: 			"Skipping pointless attribute use prohibition "
; 19335: 			"'%s', since a corresponding attribute use "
; 19336: 			"exists already in the type definition",
; 19337: 			xmlSchemaFormatQName(&str,
; 19338: 			    prohib->targetNamespace, prohib->name),
; 19339: 			NULL, NULL);
; 19340: 		    FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$1[ebp]
	test	eax, eax
	je	SHORT $LN36@xmlSchemaE
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN36@xmlSchemaE:

; 19341: 		    /*
; 19342: 		    * Remove the prohibition.
; 19343: 		    */
; 19344: 		    if (xmlSchemaItemListRemove(prohibs, i) == -1)

	push	DWORD PTR _i$2$[ebp]
	push	DWORD PTR _prohibs$[ebp]
	call	_xmlSchemaItemListRemove
	add	esp, 8
	cmp	eax, -1
	je	$LN77@xmlSchemaE
$LN8@xmlSchemaE:

; 19319: 	xmlSchemaAttributeUseProhibPtr prohib;
; 19320: 
; 19321: 	for (i = prohibs->nbItems -1; i >= 0; i--) {

	mov	ecx, DWORD PTR _i$2$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$2$[ebp], ecx
	jns	$LL10@xmlSchemaE
$LN104@xmlSchemaE:
	pop	edi

; 19345: 			return(-1);
; 19346: 		    break;
; 19347: 		}
; 19348: 	    }
; 19349: 	}
; 19350:     }
; 19351:     return(0);
; 19352: }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaExpandAttributeGroupRefs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckDerivationOKRestriction2to4
_TEXT	SEGMENT
_i$1$ = -16						; size = 4
_strA$1 = -16						; size = 4
_cur$1$ = -12						; size = 4
_strB$2 = -12						; size = 4
_str$3 = -12						; size = 4
_str$4 = -12						; size = 4
_strC$5 = -12						; size = 4
_str1$1$ = -8						; size = 4
tv1404 = -8						; size = 4
_bcur$2$ = -8						; size = 4
_strB$6 = -8						; size = 4
tv1421 = -4						; size = 4
_j$2$ = -4						; size = 4
_msg$7 = -4						; size = 4
_strA$8 = -4						; size = 4
_str$9 = -4						; size = 4
_pctxt$ = 8						; size = 4
_action$ = 12						; size = 4
_item$ = 16						; size = 4
_baseItem$ = 20						; size = 4
_uses$ = 24						; size = 4
_str$10 = 28						; size = 4
_str$11 = 28						; size = 4
_str$12 = 28						; size = 4
_baseUses$ = 28						; size = 4
_wild$ = 32						; size = 4
_baseWild$ = 36						; size = 4
_xmlSchemaCheckDerivationOKRestriction2to4 PROC		; COMDAT

; 14157: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _uses$[ebp]
	mov	ebx, OFFSET ??_C@_04BHIIPFEC@base@
	mov	edi, OFFSET ??_C@_09KLOJBFOH@redefined@
	test	edx, edx
	je	$LN3@xmlSchemaC

; 14158:     xmlSchemaAttributeUsePtr cur = NULL, bcur;
; 14159:     int i, j, found; /* err = 0; */
; 14160:     const xmlChar *bEffValue;
; 14161:     int effFixed;
; 14162: 
; 14163:     if (uses != NULL) {
; 14164: 	for (i = 0; i < uses->nbItems; i++) {

	xor	ecx, ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	DWORD PTR [edx+4], ecx
	jle	$LN3@xmlSchemaC
	jmp	SHORT $LN4@xmlSchemaC
	npad	8
$LL210@xmlSchemaC:
	mov	ebx, OFFSET ??_C@_04BHIIPFEC@base@
	mov	edi, OFFSET ??_C@_09KLOJBFOH@redefined@
$LN4@xmlSchemaC:

; 14165: 	    cur = uses->items[i];

	mov	eax, DWORD PTR [edx]

; 14166: 	    found = 0;
; 14167: 	    if (baseUses == NULL)

	mov	edx, DWORD PTR _baseUses$[ebp]
	mov	esi, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _cur$1$[ebp], esi
	test	edx, edx
	je	SHORT $LN206@xmlSchemaC

; 14168: 		goto not_found;
; 14169: 	    for (j = 0; j < baseUses->nbItems; j++) {

	mov	ebx, DWORD PTR [edx+4]
	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN209@xmlSchemaC

; 14170: 		bcur = baseUses->items[j];
; 14171: 		if ((WXS_ATTRUSE_DECL_NAME(cur) ==
; 14172: 			WXS_ATTRUSE_DECL_NAME(bcur)) &&

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR tv1421[ebp], eax
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv1404[ebp], ecx
	mov	ecx, DWORD PTR [edx]
$LL7@xmlSchemaC:
	mov	esi, DWORD PTR [ecx]
	mov	eax, DWORD PTR tv1404[ebp]
	mov	edx, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [edx+8]
	mov	eax, DWORD PTR tv1421[ebp]
	jne	SHORT $LN5@xmlSchemaC
	mov	eax, DWORD PTR [eax+56]
	cmp	eax, DWORD PTR [edx+56]
	je	$LN169@xmlSchemaC
$LN5@xmlSchemaC:

; 14168: 		goto not_found;
; 14169: 	    for (j = 0; j < baseUses->nbItems; j++) {

	inc	edi
	add	ecx, 4
	cmp	edi, ebx
	jl	SHORT $LL7@xmlSchemaC
	mov	esi, DWORD PTR _cur$1$[ebp]
$LN209@xmlSchemaC:

; 14287: 		/*
; 14288: 		* (2.2) "otherwise the {base type definition} must have an
; 14289: 		* {attribute wildcard} and the {target namespace} of the
; 14290: 		* R's {attribute declaration} must be `valid` with respect
; 14291: 		* to that wildcard, as defined in Wildcard allows Namespace
; 14292: 		* Name ($3.10.4)."
; 14293: 		*/
; 14294: 		if ((baseWild == NULL) ||

	mov	edi, OFFSET ??_C@_09KLOJBFOH@redefined@
	mov	ebx, OFFSET ??_C@_04BHIIPFEC@base@
$LN206@xmlSchemaC:
	mov	ecx, DWORD PTR _baseWild$[ebp]
	test	ecx, ecx
	je	SHORT $LN31@xmlSchemaC
	mov	eax, DWORD PTR [esi+12]
	push	DWORD PTR [eax+56]
	push	ecx
	call	_xmlSchemaCheckCVCWildcardNamespace
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@xmlSchemaC
$LN31@xmlSchemaC:

; 14295: 		    (xmlSchemaCheckCVCWildcardNamespace(baseWild,
; 14296: 		    (WXS_ATTRUSE_DECL(cur))->targetNamespace) != 0))
; 14297: 		{
; 14298: 		    xmlChar *str = NULL;
; 14299: 
; 14300: 		    xmlSchemaPAttrUseErr4(pctxt,

	push	0
	push	0
	push	DWORD PTR _baseItem$[ebp]
	lea	eax, DWORD PTR _str$3[ebp]
	mov	DWORD PTR _str$3[ebp], 0
	push	eax
	call	_xmlSchemaGetComponentDesignation
	add	esp, 8
	cmp	DWORD PTR _action$[ebp], 0
	push	eax
	mov	eax, ebx
	cmovne	eax, edi
	push	eax
	mov	eax, DWORD PTR _item$[ebp]
	push	OFFSET ??_C@_0EO@EJIDKJHC@Neither?5a?5matching?5attribute?5us@
	push	esi
	push	eax
	push	eax
	call	_xmlSchemaGetComponentNode
	add	esp, 4
	push	eax
	push	1790					; 000006feH
	push	DWORD PTR _pctxt$[ebp]
$LN216@xmlSchemaC:

; 14158:     xmlSchemaAttributeUsePtr cur = NULL, bcur;
; 14159:     int i, j, found; /* err = 0; */
; 14160:     const xmlChar *bEffValue;
; 14161:     int effFixed;
; 14162: 
; 14163:     if (uses != NULL) {
; 14164: 	for (i = 0; i < uses->nbItems; i++) {

	call	_xmlSchemaPAttrUseErr4
	mov	eax, DWORD PTR _str$3[ebp]
$LN213@xmlSchemaC:
	add	esp, 40					; 00000028H
$LN214@xmlSchemaC:
	test	eax, eax
	je	SHORT $LN2@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlSchemaC:
	mov	ecx, DWORD PTR _i$1$[ebp]
	mov	edx, DWORD PTR _uses$[ebp]
	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	ecx, DWORD PTR [edx+4]
	jl	$LL210@xmlSchemaC
$LN3@xmlSchemaC:

; 14301: 			XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2,
; 14302: 			WXS_ITEM_NODE(item), item, cur,
; 14303: 			"Neither a matching attribute use, "
; 14304: 			"nor a matching wildcard exists in the %s %s",
; 14305: 			WXS_ACTION_STR(action),
; 14306: 			xmlSchemaGetComponentDesignation(&str, baseItem),
; 14307: 			NULL, NULL);
; 14308: 		    FREE_AND_NULL(str);
; 14309: 		    /* err = pctxt->err; */
; 14310: 		}
; 14311: 	    }
; 14312: 	}
; 14313:     }
; 14314:     /*
; 14315:     * SPEC derivation-ok-restriction (3):
; 14316:     * (3) "For each attribute use in the {attribute uses} of the {base type
; 14317:     * definition} whose {required} is true, there must be an attribute
; 14318:     * use with an {attribute declaration} with the same {name} and
; 14319:     * {target namespace} as its {attribute declaration} in the {attribute
; 14320:     * uses} of the complex type definition itself whose {required} is true.
; 14321:     */
; 14322:     if (baseUses != NULL) {

	mov	eax, DWORD PTR _baseUses$[ebp]
	test	eax, eax
	je	$LN9@xmlSchemaC

; 14323: 	for (j = 0; j < baseUses->nbItems; j++) {

	xor	ebx, ebx
	mov	DWORD PTR _j$2$[ebp], ebx
	cmp	DWORD PTR [eax+4], ebx
	jle	$LN9@xmlSchemaC
$LL10@xmlSchemaC:

; 14324: 	    bcur = baseUses->items[j];

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR _bcur$2$[ebp], eax

; 14325: 	    if (bcur->occurs != XML_SCHEMAS_ATTR_USE_REQUIRED)

	cmp	DWORD PTR [eax+24], 1
	jne	$LN8@xmlSchemaC

; 14326: 		continue;
; 14327: 	    found = 0;
; 14328: 	    if (uses != NULL) {

	test	edx, edx
	je	SHORT $LN200@xmlSchemaC

; 14329: 		for (i = 0; i < uses->nbItems; i++) {

	mov	esi, DWORD PTR [edx+4]
	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN200@xmlSchemaC

; 14330: 		    cur = uses->items[i];
; 14331: 		    if ((WXS_ATTRUSE_DECL_NAME(cur) ==
; 14332: 			WXS_ATTRUSE_DECL_NAME(bcur)) &&

	mov	edi, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [edx]
	mov	ebx, DWORD PTR [edi+8]
$LL13@xmlSchemaC:
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+12]
	cmp	DWORD PTR [eax+8], ebx
	jne	SHORT $LN11@xmlSchemaC
	mov	eax, DWORD PTR [eax+56]
	cmp	eax, DWORD PTR [edi+56]
	je	$LN207@xmlSchemaC
$LN11@xmlSchemaC:

; 14329: 		for (i = 0; i < uses->nbItems; i++) {

	inc	ecx
	add	edx, 4
	cmp	ecx, esi
	jl	SHORT $LL13@xmlSchemaC
	mov	ebx, DWORD PTR _j$2$[ebp]
$LN200@xmlSchemaC:

; 14333: 			(WXS_ATTRUSE_DECL_TNS(cur) ==
; 14334: 			WXS_ATTRUSE_DECL_TNS(bcur))) {
; 14335: 			found = 1;
; 14336: 			break;
; 14337: 		    }
; 14338: 		}
; 14339: 	    }
; 14340: 	    if (!found) {
; 14341: 		xmlChar *strA = NULL, *strB = NULL;
; 14342: 
; 14343: 		xmlSchemaCustomErr4(ACTXT_CAST pctxt,

	push	DWORD PTR _baseItem$[ebp]
	lea	eax, DWORD PTR _strB$2[ebp]
	mov	DWORD PTR _strA$1[ebp], 0
	push	eax
	mov	DWORD PTR _strB$2[ebp], 0
	call	_xmlSchemaGetComponentDesignation
	push	DWORD PTR _bcur$2$[ebp]
	mov	edi, eax
	lea	eax, DWORD PTR _strA$1[ebp]
	push	eax
	call	_xmlSchemaGetComponentDesignation
	mov	DWORD PTR _str1$1$[ebp], eax
	xor	esi, esi

; 2341 :     if ((node == NULL) && (item != NULL) &&

	mov	eax, DWORD PTR _item$[ebp]

; 14333: 			(WXS_ATTRUSE_DECL_TNS(cur) ==
; 14334: 			WXS_ATTRUSE_DECL_TNS(bcur))) {
; 14335: 			found = 1;
; 14336: 			break;
; 14337: 		    }
; 14338: 		}
; 14339: 	    }
; 14340: 	    if (!found) {
; 14341: 		xmlChar *strA = NULL, *strB = NULL;
; 14342: 
; 14343: 		xmlSchemaCustomErr4(ACTXT_CAST pctxt,

	add	esp, 16					; 00000010H

; 2339 :     xmlChar *msg = NULL;

	mov	DWORD PTR _msg$7[ebp], esi

; 2340 : 
; 2341 :     if ((node == NULL) && (item != NULL) &&

	test	eax, eax
	je	$LN96@xmlSchemaC
	mov	ecx, DWORD PTR _pctxt$[ebp]
	cmp	DWORD PTR [ecx], 1
	jne	$LN96@xmlSchemaC

; 2342 : 	(actxt->type == XML_SCHEMA_CTXT_PARSER)) {
; 2343 : 	node = WXS_ITEM_NODE(item);

	push	eax
	call	_xmlSchemaGetComponentNode

; 2344 : 	xmlSchemaFormatItemForReport(&msg, NULL, item, NULL);

	push	0
	push	DWORD PTR _item$[ebp]
	mov	esi, eax
	lea	eax, DWORD PTR _msg$7[ebp]
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 2345 : 	msg = xmlStrcat(msg, BAD_CAST ": ");

	push	OFFSET ??_C@_02LMMGGCAJ@?3?5@
	push	DWORD PTR _msg$7[ebp]
	call	_xmlStrcat
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _msg$7[ebp], eax

; 2346 :     } else

	jmp	$LN97@xmlSchemaC
$LN169@xmlSchemaC:

; 14173: 		    (WXS_ATTRUSE_DECL_TNS(cur) ==
; 14174: 			WXS_ATTRUSE_DECL_TNS(bcur)))
; 14175: 		{
; 14176: 		    /*
; 14177: 		    * (2.1) "If there is an attribute use in the {attribute
; 14178: 		    * uses} of the {base type definition} (call this B) whose
; 14179: 		    * {attribute declaration} has the same {name} and {target
; 14180: 		    * namespace}, then  all of the following must be true:"
; 14181: 		    */
; 14182: 		    found = 1;
; 14183: 
; 14184: 		    if ((cur->occurs == XML_SCHEMAS_ATTR_USE_OPTIONAL) &&

	mov	ebx, DWORD PTR _cur$1$[ebp]
	cmp	DWORD PTR [ebx+24], 2
	jne	SHORT $LN17@xmlSchemaC
	cmp	DWORD PTR [esi+24], 1
	jne	SHORT $LN17@xmlSchemaC

; 14185: 			(bcur->occurs == XML_SCHEMAS_ATTR_USE_REQUIRED))
; 14186: 		    {
; 14187: 			xmlChar *str = NULL;
; 14188: 			/*
; 14189: 			* (2.1.1) "one of the following must be true:"
; 14190: 			* (2.1.1.1) "B's {required} is false."
; 14191: 			* (2.1.1.2) "R's {required} is true."
; 14192: 			*/
; 14193: 			xmlSchemaPAttrUseErr4(pctxt,

	push	0
	push	0
	push	DWORD PTR _baseItem$[ebp]
	lea	eax, DWORD PTR _str$9[ebp]
	mov	DWORD PTR _str$9[ebp], 0
	push	eax
	call	_xmlSchemaGetComponentDesignation
	add	esp, 8
	mov	ecx, OFFSET ??_C@_09KLOJBFOH@redefined@
	cmp	DWORD PTR _action$[ebp], 0
	push	eax
	mov	eax, OFFSET ??_C@_04BHIIPFEC@base@
	cmovne	eax, ecx
	push	eax
	push	OFFSET ??_C@_0GK@JGCEGOAB@The?5?8optional?8?5attribute?5use?5is@
	push	ebx
	mov	ebx, DWORD PTR _item$[ebp]
	push	ebx
	push	ebx
	call	_xmlSchemaGetComponentNode
	mov	edi, DWORD PTR _pctxt$[ebp]
	add	esp, 4
	push	eax
	push	1788					; 000006fcH
	push	edi
	call	_xmlSchemaPAttrUseErr4

; 14194: 			    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1,
; 14195: 			    WXS_ITEM_NODE(item), item, cur,
; 14196: 			    "The 'optional' attribute use is inconsistent "
; 14197: 			    "with the corresponding 'required' attribute use of "
; 14198: 			    "the %s %s",
; 14199: 			    WXS_ACTION_STR(action),
; 14200: 			    xmlSchemaGetComponentDesignation(&str, baseItem),
; 14201: 			    NULL, NULL);
; 14202: 			FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$9[ebp]

; 14203: 			/* err = pctxt->err; */
; 14204: 		    } else if (xmlSchemaCheckCOSSTDerivedOK(ACTXT_CAST pctxt,

	jmp	$LN213@xmlSchemaC
$LN17@xmlSchemaC:

; 14205: 			WXS_ATTRUSE_TYPEDEF(cur),
; 14206: 			WXS_ATTRUSE_TYPEDEF(bcur), 0) != 0)

	mov	eax, DWORD PTR tv1421[ebp]
	mov	edi, DWORD PTR _pctxt$[ebp]
	push	0
	push	DWORD PTR [edx+48]
	push	DWORD PTR [eax+48]
	push	edi
	call	_xmlSchemaCheckCOSSTDerivedOK
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN20@xmlSchemaC

; 14207: 		    {
; 14208: 			xmlChar *strA = NULL, *strB = NULL, *strC = NULL;
; 14209: 
; 14210: 			/*
; 14211: 			* SPEC (2.1.2) "R's {attribute declaration}'s
; 14212: 			* {type definition} must be validly derived from
; 14213: 			* B's {type definition} given the empty set as
; 14214: 			* defined in Type Derivation OK (Simple) ($3.14.6)."
; 14215: 			*/
; 14216: 			xmlSchemaPAttrUseErr4(pctxt,

	push	DWORD PTR _baseItem$[ebp]
	lea	eax, DWORD PTR _strC$5[ebp]
	mov	DWORD PTR _strA$8[ebp], 0
	push	eax
	mov	DWORD PTR _strB$6[ebp], 0
	mov	DWORD PTR _strC$5[ebp], 0
	call	_xmlSchemaGetComponentDesignation
	add	esp, 8
	mov	ecx, OFFSET ??_C@_09KLOJBFOH@redefined@
	cmp	DWORD PTR _action$[ebp], 0
	push	eax
	mov	eax, OFFSET ??_C@_04BHIIPFEC@base@
	cmovne	eax, ecx
	push	eax
	mov	eax, DWORD PTR [esi+12]
	push	DWORD PTR [eax+48]
	lea	eax, DWORD PTR _strB$6[ebp]
	push	eax
	call	_xmlSchemaGetComponentDesignation
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR [ebx+12]
	push	DWORD PTR [eax+48]
	lea	eax, DWORD PTR _strA$8[ebp]
	push	eax
	call	_xmlSchemaGetComponentDesignation
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0HK@BBMHJBAP@The?5attribute?5declaration?8s?5?$CFs?5@
	push	ebx
	mov	ebx, DWORD PTR _item$[ebp]
	push	ebx
	push	ebx
	call	_xmlSchemaGetComponentNode
	add	esp, 4
	push	eax
	push	1789					; 000006fdH
	push	edi
	call	_xmlSchemaPAttrUseErr4

; 14217: 			    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2,
; 14218: 			    WXS_ITEM_NODE(item), item, cur,
; 14219: 			    "The attribute declaration's %s "
; 14220: 			    "is not validly derived from "
; 14221: 			    "the corresponding %s of the "
; 14222: 			    "attribute declaration in the %s %s",
; 14223: 			    xmlSchemaGetComponentDesignation(&strA,
; 14224: 				WXS_ATTRUSE_TYPEDEF(cur)),
; 14225: 			    xmlSchemaGetComponentDesignation(&strB,
; 14226: 				WXS_ATTRUSE_TYPEDEF(bcur)),
; 14227: 			    WXS_ACTION_STR(action),
; 14228: 			    xmlSchemaGetComponentDesignation(&strC, baseItem));
; 14229: 			    /* xmlSchemaGetComponentDesignation(&str, baseItem), */
; 14230: 			FREE_AND_NULL(strA);

	mov	eax, DWORD PTR _strA$8[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN22@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN22@xmlSchemaC:

; 14231: 			FREE_AND_NULL(strB);

	mov	eax, DWORD PTR _strB$6[ebp]
	test	eax, eax
	je	SHORT $LN23@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN23@xmlSchemaC:

; 14232: 			FREE_AND_NULL(strC);

	mov	eax, DWORD PTR _strC$5[ebp]

; 14233: 			/* err = pctxt->err; */
; 14234: 		    } else {

	jmp	$LN214@xmlSchemaC
$LN20@xmlSchemaC:

; 14077:     if (attruse->defValue != NULL) {

	mov	ecx, DWORD PTR [esi+28]
	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN77@xmlSchemaC

; 14078: 	*value = attruse->defValue;
; 14079: 	if (val != NULL)
; 14080: 	    *val = attruse->defVal;
; 14081: 	if (attruse->flags & XML_SCHEMA_ATTR_USE_FIXED)

	mov	eax, DWORD PTR [esi+16]
	mov	edx, ecx
	and	eax, 1

; 14082: 	    *fixed = 1;
; 14083: 	return(1);

	jmp	SHORT $LN83@xmlSchemaC
$LN77@xmlSchemaC:

; 14084:     } else if ((attruse->attrDecl != NULL) &&

	mov	edi, DWORD PTR [esi+12]
	test	edi, edi
	je	$LN2@xmlSchemaC
	mov	edx, DWORD PTR [edi+44]
	test	edx, edx
	je	$LN2@xmlSchemaC

; 14085: 	(attruse->attrDecl->defValue != NULL)) {
; 14086: 	*value = attruse->attrDecl->defValue;
; 14087: 	if (val != NULL)
; 14088: 	    *val = attruse->attrDecl->defVal;
; 14089: 	if (attruse->attrDecl->flags & XML_SCHEMAS_ATTR_FIXED)

	test	DWORD PTR [edi+60], 512			; 00000200H
	mov	edi, 1
	cmovne	eax, edi
	mov	edi, DWORD PTR _pctxt$[ebp]
$LN83@xmlSchemaC:

; 14235: 			/*
; 14236: 			* 2.1.3 [Definition:]  Let the effective value
; 14237: 			* constraint of an attribute use be its {value
; 14238: 			* constraint}, if present, otherwise its {attribute
; 14239: 			* declaration}'s {value constraint} .
; 14240: 			*/
; 14241: 			xmlSchemaGetEffectiveValueConstraint(bcur,
; 14242: 			    &effFixed, &bEffValue, NULL);
; 14243: 			/*
; 14244: 			* 2.1.3 ... one of the following must be true
; 14245: 			*
; 14246: 			* 2.1.3.1 B's `effective value constraint` is
; 14247: 			* `absent` or default.
; 14248: 			*/
; 14249: 			if ((bEffValue != NULL) &&

	test	edx, edx
	je	$LN2@xmlSchemaC
	cmp	eax, 1
	jne	$LN2@xmlSchemaC

; 14077:     if (attruse->defValue != NULL) {

	test	ecx, ecx
	je	SHORT $LN87@xmlSchemaC

; 14078: 	*value = attruse->defValue;
; 14079: 	if (val != NULL)
; 14080: 	    *val = attruse->defVal;
; 14081: 	if (attruse->flags & XML_SCHEMA_ATTR_USE_FIXED)

	mov	eax, DWORD PTR [esi+16]
	and	eax, 1

; 14250: 			    (effFixed == 1)) {
; 14251: 			    const xmlChar *rEffValue = NULL;
; 14252: 
; 14253: 			    xmlSchemaGetEffectiveValueConstraint(bcur,
; 14254: 				&effFixed, &rEffValue, NULL);
; 14255: 			    /*
; 14256: 			    * 2.1.3.2 R's `effective value constraint` is
; 14257: 			    * fixed with the same string as B's.
; 14258: 			    * MAYBE TODO: Compare the computed values.
; 14259: 			    *       Hmm, it says "same string" so
; 14260: 			    *       string-equality might really be sufficient.
; 14261: 			    */
; 14262: 			    if ((effFixed == 0) ||

	jmp	SHORT $LN215@xmlSchemaC
$LN87@xmlSchemaC:

; 14084:     } else if ((attruse->attrDecl != NULL) &&

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN27@xmlSchemaC
	mov	ecx, DWORD PTR [eax+44]
	test	ecx, ecx
	je	SHORT $LN27@xmlSchemaC

; 14085: 	(attruse->attrDecl->defValue != NULL)) {
; 14086: 	*value = attruse->attrDecl->defValue;
; 14087: 	if (val != NULL)
; 14088: 	    *val = attruse->attrDecl->defVal;
; 14089: 	if (attruse->attrDecl->flags & XML_SCHEMAS_ATTR_FIXED)

	test	DWORD PTR [eax+60], 512			; 00000200H
$LN215@xmlSchemaC:

; 14250: 			    (effFixed == 1)) {
; 14251: 			    const xmlChar *rEffValue = NULL;
; 14252: 
; 14253: 			    xmlSchemaGetEffectiveValueConstraint(bcur,
; 14254: 				&effFixed, &rEffValue, NULL);
; 14255: 			    /*
; 14256: 			    * 2.1.3.2 R's `effective value constraint` is
; 14257: 			    * fixed with the same string as B's.
; 14258: 			    * MAYBE TODO: Compare the computed values.
; 14259: 			    *       Hmm, it says "same string" so
; 14260: 			    *       string-equality might really be sufficient.
; 14261: 			    */
; 14262: 			    if ((effFixed == 0) ||

	je	SHORT $LN27@xmlSchemaC
	cmp	ecx, edx
	je	$LN2@xmlSchemaC
$LN27@xmlSchemaC:

; 14263: 				(! WXS_ARE_DEFAULT_STR_EQUAL(rEffValue, bEffValue)))
; 14264: 			    {
; 14265: 				xmlChar *str = NULL;
; 14266: 
; 14267: 				xmlSchemaPAttrUseErr4(pctxt,

	push	0
	push	0
	push	DWORD PTR _baseItem$[ebp]
	lea	eax, DWORD PTR _str$4[ebp]
	mov	DWORD PTR _str$4[ebp], 0
	push	eax
	call	_xmlSchemaGetComponentDesignation
	add	esp, 8
	mov	ecx, OFFSET ??_C@_09KLOJBFOH@redefined@
	cmp	DWORD PTR _action$[ebp], 0
	push	eax
	mov	eax, OFFSET ??_C@_04BHIIPFEC@base@
	cmovne	eax, ecx
	push	eax
	push	OFFSET ??_C@_0GI@OJPOJNKC@The?5effective?5value?5constraint?5@
	push	ebx
	mov	ebx, DWORD PTR _item$[ebp]
	push	ebx
	push	ebx
	call	_xmlSchemaGetComponentNode
	add	esp, 4
	push	eax
	push	3077					; 00000c05H
	push	edi

; 14268: 				    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3,
; 14269: 				    WXS_ITEM_NODE(item), item, cur,
; 14270: 				    "The effective value constraint of the "
; 14271: 				    "attribute use is inconsistent with "
; 14272: 				    "its correspondent in the %s %s",
; 14273: 				    WXS_ACTION_STR(action),
; 14274: 				    xmlSchemaGetComponentDesignation(&str,
; 14275: 					baseItem),
; 14276: 				    NULL, NULL);
; 14277: 				FREE_AND_NULL(str);
; 14278: 				/* err = pctxt->err; */
; 14279: 			    }
; 14280: 			}
; 14281: 		    }
; 14282: 		    break;
; 14283: 		}
; 14284: 	    }
; 14285: not_found:
; 14286: 	    if (!found) {

	jmp	$LN216@xmlSchemaC
$LN96@xmlSchemaC:

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	0
	push	DWORD PTR _pctxt$[ebp]
	lea	eax, DWORD PTR _msg$7[ebp]
	push	eax
	call	_xmlSchemaFormatNodeForError
	mov	eax, DWORD PTR _msg$7[ebp]
	add	esp, 12					; 0000000cH
$LN97@xmlSchemaC:

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0EH@JCFCIHDB@A?5matching?5attribute?5use?5for?5th@
	push	eax
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$7[ebp], eax
	call	_xmlStrcat

; 14333: 			(WXS_ATTRUSE_DECL_TNS(cur) ==
; 14334: 			WXS_ATTRUSE_DECL_TNS(bcur))) {
; 14335: 			found = 1;
; 14336: 			break;
; 14337: 		    }
; 14338: 		}
; 14339: 	    }
; 14340: 	    if (!found) {
; 14341: 		xmlChar *strA = NULL, *strB = NULL;
; 14342: 
; 14343: 		xmlSchemaCustomErr4(ACTXT_CAST pctxt,

	cmp	DWORD PTR _action$[ebp], 0

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	ecx, eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	edi

; 14333: 			(WXS_ATTRUSE_DECL_TNS(cur) ==
; 14334: 			WXS_ATTRUSE_DECL_TNS(bcur))) {
; 14335: 			found = 1;
; 14336: 			break;
; 14337: 		    }
; 14338: 		}
; 14339: 	    }
; 14340: 	    if (!found) {
; 14341: 		xmlChar *strA = NULL, *strB = NULL;
; 14342: 
; 14343: 		xmlSchemaCustomErr4(ACTXT_CAST pctxt,

	mov	edx, OFFSET ??_C@_09KLOJBFOH@redefined@

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$7[ebp], ecx

; 14333: 			(WXS_ATTRUSE_DECL_TNS(cur) ==
; 14334: 			WXS_ATTRUSE_DECL_TNS(bcur))) {
; 14335: 			found = 1;
; 14336: 			break;
; 14337: 		    }
; 14338: 		}
; 14339: 	    }
; 14340: 	    if (!found) {
; 14341: 		xmlChar *strA = NULL, *strB = NULL;
; 14342: 
; 14343: 		xmlSchemaCustomErr4(ACTXT_CAST pctxt,

	mov	eax, OFFSET ??_C@_04BHIIPFEC@base@
	cmovne	eax, edx

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	eax
	push	DWORD PTR _str1$1$[ebp]
	push	ecx
	push	0
	push	esi
	push	1791					; 000006ffH
	push	2
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$7[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 56					; 00000038H

; 2352 :     FREE_AND_NULL(msg)

	test	eax, eax
	je	SHORT $LN98@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN98@xmlSchemaC:

; 14344: 		    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3,
; 14345: 		    NULL, item,
; 14346: 		    "A matching attribute use for the "
; 14347: 		    "'required' %s of the %s %s is missing",
; 14348: 		    xmlSchemaGetComponentDesignation(&strA, bcur),
; 14349: 		    WXS_ACTION_STR(action),
; 14350: 		    xmlSchemaGetComponentDesignation(&strB, baseItem),
; 14351: 		    NULL);
; 14352: 		FREE_AND_NULL(strA);

	mov	eax, DWORD PTR _strA$1[ebp]
	test	eax, eax
	je	SHORT $LN38@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN38@xmlSchemaC:

; 14353: 		FREE_AND_NULL(strB);

	mov	eax, DWORD PTR _strB$2[ebp]
	test	eax, eax
	je	SHORT $LN8@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	jmp	SHORT $LN8@xmlSchemaC
$LN207@xmlSchemaC:

; 14330: 		    cur = uses->items[i];
; 14331: 		    if ((WXS_ATTRUSE_DECL_NAME(cur) ==
; 14332: 			WXS_ATTRUSE_DECL_NAME(bcur)) &&

	mov	ebx, DWORD PTR _j$2$[ebp]
$LN8@xmlSchemaC:

; 14323: 	for (j = 0; j < baseUses->nbItems; j++) {

	mov	eax, DWORD PTR _baseUses$[ebp]
	inc	ebx
	mov	edx, DWORD PTR _uses$[ebp]
	mov	DWORD PTR _j$2$[ebp], ebx
	cmp	ebx, DWORD PTR [eax+4]
	jl	$LL10@xmlSchemaC
$LN9@xmlSchemaC:

; 14354: 	    }
; 14355: 	}
; 14356:     }
; 14357:     /*
; 14358:     * derivation-ok-restriction (4)
; 14359:     */
; 14360:     if (wild != NULL) {

	mov	edi, DWORD PTR _wild$[ebp]
	test	edi, edi
	je	$LN46@xmlSchemaC

; 14361: 	/*
; 14362: 	* (4) "If there is an {attribute wildcard}, all of the
; 14363: 	* following must be true:"
; 14364: 	*/
; 14365: 	if (baseWild == NULL) {

	mov	edx, DWORD PTR _baseWild$[ebp]
	test	edx, edx
	jne	$LN41@xmlSchemaC

; 1429 :     return (xmlSchemaFormatQName(buf,

	mov	esi, DWORD PTR _baseItem$[ebp]
	push	esi

; 14366: 	    xmlChar *str = NULL;

	mov	DWORD PTR _str$12[ebp], edx

; 1429 :     return (xmlSchemaFormatQName(buf,

	call	_xmlSchemaGetComponentName
	add	esp, 4
	push	eax
	push	esi
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _str$12[ebp]
	push	eax
	call	_xmlSchemaFormatQName

; 1183 :     switch (item->type) {

	mov	ecx, DWORD PTR [esi]

; 1429 :     return (xmlSchemaFormatQName(buf,

	mov	ebx, eax

; 1183 :     switch (item->type) {

	mov	eax, ecx

; 1429 :     return (xmlSchemaFormatQName(buf,

	add	esp, 12					; 0000000cH

; 1183 :     switch (item->type) {

	mov	esi, OFFSET ??_C@_0BH@BIKOCJPH@simple?5type?5definition@
	mov	edx, OFFSET ??_C@_0BI@MHGDJJNC@complex?5type?5definition@
	sub	eax, 1
	je	SHORT $LN107@xmlSchemaC

; 1186 : 		return(BAD_CAST "complex type definition");
; 1187 : 	    else
; 1188 : 		return(BAD_CAST "simple type definition");
; 1189 : 	default:
; 1190 : 	    return(xmlSchemaItemTypeToStr(item->type));

	push	ecx
	call	_xmlSchemaItemTypeToStr
	add	esp, 4
	mov	edi, eax
	jmp	SHORT $LN110@xmlSchemaC
$LN107@xmlSchemaC:

; 1184 : 	case XML_SCHEMA_TYPE_BASIC:
; 1185 : 	    if (WXS_IS_COMPLEX(WXS_TYPE_CAST item))

	mov	eax, DWORD PTR _baseItem$[ebp]
	mov	edi, esi
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	cmove	edi, edx
$LN110@xmlSchemaC:

; 1183 :     switch (item->type) {

	mov	edx, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	eax, ecx
	sub	eax, 1
	je	SHORT $LN116@xmlSchemaC

; 1186 : 		return(BAD_CAST "complex type definition");
; 1187 : 	    else
; 1188 : 		return(BAD_CAST "simple type definition");
; 1189 : 	default:
; 1190 : 	    return(xmlSchemaItemTypeToStr(item->type));

	push	ecx
	call	_xmlSchemaItemTypeToStr
	mov	edx, DWORD PTR _item$[ebp]
	add	esp, 4
	mov	esi, eax
	jmp	SHORT $LN119@xmlSchemaC
$LN116@xmlSchemaC:

; 1184 : 	case XML_SCHEMA_TYPE_BASIC:
; 1185 : 	    if (WXS_IS_COMPLEX(WXS_TYPE_CAST item))

	cmp	DWORD PTR [edx+88], 45			; 0000002dH
	mov	eax, OFFSET ??_C@_0BI@MHGDJJNC@complex?5type?5definition@
	cmove	esi, eax
$LN119@xmlSchemaC:

; 14367: 
; 14368: 	    /*
; 14369: 	    * (4.1) "The {base type definition} must also have one."
; 14370: 	    */
; 14371: 	    xmlSchemaCustomErr4(ACTXT_CAST pctxt,

	cmp	DWORD PTR _action$[ebp], 0
	mov	ecx, OFFSET ??_C@_09KLOJBFOH@redefined@
	push	ebx
	mov	ebx, DWORD PTR _pctxt$[ebp]
	mov	eax, OFFSET ??_C@_04BHIIPFEC@base@
	push	edi
	cmovne	eax, ecx
	push	eax
	push	esi
	push	OFFSET ??_C@_0EH@LKDIOLEM@The?5?$CFs?5has?5an?5attribute?5wildcar@
	push	edx
	push	0
	push	1797					; 00000705H
	push	ebx
	call	_xmlSchemaCustomErr4

; 14372: 		XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1,
; 14373: 		NULL, item,
; 14374: 		"The %s has an attribute wildcard, "
; 14375: 		"but the %s %s '%s' does not have one",
; 14376: 		WXS_ITEM_TYPE_NAME(item),
; 14377: 		WXS_ACTION_STR(action),
; 14378: 		WXS_ITEM_TYPE_NAME(baseItem),
; 14379: 		xmlSchemaGetComponentQName(&str, baseItem));
; 14380: 	    FREE_AND_NULL(str);

	mov	ecx, DWORD PTR _str$12[ebp]
	add	esp, 36					; 00000024H
	test	ecx, ecx
	je	SHORT $LN43@xmlSchemaC
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN43@xmlSchemaC:

; 14381: 	    return(pctxt->err);

	mov	eax, DWORD PTR [ebx+16]
	pop	edi

; 14425: 	}
; 14426:     }
; 14427:     return(0);
; 14428: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@xmlSchemaC:

; 14382: 	} else if ((baseWild->any == 0) &&

	cmp	DWORD PTR [edx+28], 0
	jne	$LN44@xmlSchemaC

; 14017: 	(super->negNsSet != NULL) &&

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN130@xmlSchemaC
	mov	ecx, DWORD PTR [edx+36]
	test	ecx, ecx
	je	SHORT $LN130@xmlSchemaC
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [ecx+4]
	je	SHORT $LN44@xmlSchemaC
$LN130@xmlSchemaC:

; 14018: 	(sub->negNsSet->value == super->negNsSet->value))
; 14019: 	return (0);
; 14020:     /*
; 14021:     * 3.1 sub must be a set whose members are either namespace names or `absent`.
; 14022:     */
; 14023:     if (sub->nsSet != NULL) {

	mov	ecx, DWORD PTR [edi+32]
	test	ecx, ecx
	je	SHORT $LN137@xmlSchemaC

; 14024: 	/*
; 14025: 	* 3.2.1 super must be the same set or a superset thereof.
; 14026: 	*/
; 14027: 	if (super->nsSet != NULL) {

	mov	esi, DWORD PTR [edx+32]
	test	esi, esi
	je	$LN132@xmlSchemaC
	npad	4
$LL123@xmlSchemaC:

; 14033: 		found = 0;
; 14034: 		curB = super->nsSet;
; 14035: 		while (curB != NULL) {
; 14036: 		    if (cur->value == curB->value) {

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, esi
$LL125@xmlSchemaC:
	cmp	edx, DWORD PTR [eax+4]
	je	SHORT $LN171@xmlSchemaC

; 14037: 			found = 1;
; 14038: 			break;
; 14039: 		    }
; 14040: 		    curB = curB->next;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL125@xmlSchemaC
$LN137@xmlSchemaC:

; 1429 :     return (xmlSchemaFormatQName(buf,

	mov	ebx, DWORD PTR _baseItem$[ebp]
	push	ebx

; 14383: 		xmlSchemaCheckCOSNSSubset(wild, baseWild))
; 14384: 	{
; 14385: 	    xmlChar *str = NULL;

	mov	DWORD PTR _str$11[ebp], 0

; 1429 :     return (xmlSchemaFormatQName(buf,

	call	_xmlSchemaGetComponentName
	add	esp, 4
	push	eax
	push	ebx
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _str$11[ebp]
	push	eax
	call	_xmlSchemaFormatQName

; 1183 :     switch (item->type) {

	mov	edx, DWORD PTR [ebx]

; 1429 :     return (xmlSchemaFormatQName(buf,

	add	esp, 12					; 0000000cH

; 1183 :     switch (item->type) {

	mov	ecx, edx

; 1429 :     return (xmlSchemaFormatQName(buf,

	mov	esi, eax

; 1183 :     switch (item->type) {

	sub	ecx, 1
	je	$LN145@xmlSchemaC

; 1186 : 		return(BAD_CAST "complex type definition");
; 1187 : 	    else
; 1188 : 		return(BAD_CAST "simple type definition");
; 1189 : 	default:
; 1190 : 	    return(xmlSchemaItemTypeToStr(item->type));

	push	edx
	call	_xmlSchemaItemTypeToStr
	add	esp, 4
	jmp	$LN148@xmlSchemaC
$LN171@xmlSchemaC:

; 14044: 		cur = cur->next;

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $LL123@xmlSchemaC

; 14028: 	    xmlSchemaWildcardNsPtr cur, curB;
; 14029: 	    int found = 0;
; 14030: 
; 14031: 	    cur = sub->nsSet;
; 14032: 	    while (cur != NULL) {

	mov	edx, DWORD PTR _baseWild$[ebp]
$LN44@xmlSchemaC:

; 14393: 		XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2,
; 14394: 		NULL, item,
; 14395: 		"The attribute wildcard is not a valid "
; 14396: 		"subset of the wildcard in the %s %s '%s'",
; 14397: 		WXS_ACTION_STR(action),
; 14398: 		WXS_ITEM_TYPE_NAME(baseItem),
; 14399: 		xmlSchemaGetComponentQName(&str, baseItem),
; 14400: 		NULL);
; 14401: 	    FREE_AND_NULL(str);
; 14402: 	    return(pctxt->err);
; 14403: 	}
; 14404: 	/* 4.3 Unless the {base type definition} is the `ur-type
; 14405: 	* definition`, the complex type definition's {attribute
; 14406: 	* wildcard}'s {process contents} must be identical to or
; 14407: 	* stronger than the {base type definition}'s {attribute
; 14408: 	* wildcard}'s {process contents}, where strict is stronger
; 14409: 	* than lax is stronger than skip.
; 14410: 	*/
; 14411: 	if ((! WXS_IS_ANYTYPE(baseItem)) &&

	mov	ebx, DWORD PTR _baseItem$[ebp]
	cmp	DWORD PTR [ebx], 1
	jne	SHORT $LN205@xmlSchemaC
	cmp	DWORD PTR [ebx+88], 45			; 0000002dH
	je	$LN46@xmlSchemaC
$LN205@xmlSchemaC:
	mov	eax, DWORD PTR [edi+24]
	cmp	eax, DWORD PTR [edx+24]
	jge	$LN46@xmlSchemaC

; 1429 :     return (xmlSchemaFormatQName(buf,

	push	ebx

; 14412: 	    (wild->processContents < baseWild->processContents)) {
; 14413: 	    xmlChar *str = NULL;

	mov	DWORD PTR _str$10[ebp], 0

; 1429 :     return (xmlSchemaFormatQName(buf,

	call	_xmlSchemaGetComponentName
	add	esp, 4
	push	eax
	push	ebx
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _str$10[ebp]
	push	eax
	call	_xmlSchemaFormatQName

; 1183 :     switch (item->type) {

	mov	edx, DWORD PTR [ebx]

; 1429 :     return (xmlSchemaFormatQName(buf,

	add	esp, 12					; 0000000cH

; 1183 :     switch (item->type) {

	mov	ecx, edx

; 1429 :     return (xmlSchemaFormatQName(buf,

	mov	esi, eax

; 1183 :     switch (item->type) {

	sub	ecx, 1
	je	$LN156@xmlSchemaC

; 1186 : 		return(BAD_CAST "complex type definition");
; 1187 : 	    else
; 1188 : 		return(BAD_CAST "simple type definition");
; 1189 : 	default:
; 1190 : 	    return(xmlSchemaItemTypeToStr(item->type));

	push	edx
	call	_xmlSchemaItemTypeToStr
	add	esp, 4
	jmp	$LN159@xmlSchemaC
$LN132@xmlSchemaC:

; 14048: 	} else if (super->negNsSet != NULL) {

	mov	eax, DWORD PTR [edx+36]
	test	eax, eax
	je	$LN137@xmlSchemaC

; 14049: 	    xmlSchemaWildcardNsPtr cur;
; 14050: 	    /*
; 14051: 	    * 3.2.2 super must be a pair of not and a namespace name or
; 14052: 	    * `absent` and that value must not be in sub's set.
; 14053: 	    */
; 14054: 	    cur = sub->nsSet;
; 14055: 	    while (cur != NULL) {
; 14056: 		if (cur->value == super->negNsSet->value)

	mov	eax, DWORD PTR [eax+4]
$LL127@xmlSchemaC:
	cmp	DWORD PTR [ecx+4], eax
	je	$LN137@xmlSchemaC

; 14057: 		    return (1);
; 14058: 		cur = cur->next;

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $LL127@xmlSchemaC

; 14049: 	    xmlSchemaWildcardNsPtr cur;
; 14050: 	    /*
; 14051: 	    * 3.2.2 super must be a pair of not and a namespace name or
; 14052: 	    * `absent` and that value must not be in sub's set.
; 14053: 	    */
; 14054: 	    cur = sub->nsSet;
; 14055: 	    while (cur != NULL) {
; 14056: 		if (cur->value == super->negNsSet->value)

	jmp	$LN44@xmlSchemaC
$LN145@xmlSchemaC:

; 1185 : 	    if (WXS_IS_COMPLEX(WXS_TYPE_CAST item))

	cmp	DWORD PTR [ebx+88], 45			; 0000002dH
	mov	eax, OFFSET ??_C@_0BH@BIKOCJPH@simple?5type?5definition@
	mov	ecx, OFFSET ??_C@_0BI@MHGDJJNC@complex?5type?5definition@
	cmove	eax, ecx
$LN148@xmlSchemaC:

; 14386: 	    /*
; 14387: 	    * (4.2) "The complex type definition's {attribute wildcard}'s
; 14388: 	    * {namespace constraint} must be a subset of the {base type
; 14389: 	    * definition}'s {attribute wildcard}'s {namespace constraint},
; 14390: 	    * as defined by Wildcard Subset ($3.10.6)."
; 14391: 	    */
; 14392: 	    xmlSchemaCustomErr4(ACTXT_CAST pctxt,

	cmp	DWORD PTR _action$[ebp], 0
	mov	ecx, OFFSET ??_C@_09KLOJBFOH@redefined@
	push	0
	push	esi
	push	eax
	mov	eax, OFFSET ??_C@_04BHIIPFEC@base@
	cmovne	eax, ecx
	push	eax
	push	OFFSET ??_C@_0EP@KINLKDD@The?5attribute?5wildcard?5is?5not?5a@
	push	DWORD PTR _item$[ebp]
	push	0
	push	1798					; 00000706H
$LN217@xmlSchemaC:

; 14425: 	}
; 14426:     }
; 14427:     return(0);
; 14428: }

	mov	ebx, DWORD PTR _pctxt$[ebp]
	push	ebx
	call	_xmlSchemaCustomErr4
	mov	eax, DWORD PTR _str$11[ebp]
	add	esp, 36					; 00000024H
	test	eax, eax
	je	$LN43@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [ebx+16]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN156@xmlSchemaC:

; 1185 : 	    if (WXS_IS_COMPLEX(WXS_TYPE_CAST item))

	cmp	DWORD PTR [ebx+88], 45			; 0000002dH
	mov	eax, OFFSET ??_C@_0BH@BIKOCJPH@simple?5type?5definition@
	mov	ecx, OFFSET ??_C@_0BI@MHGDJJNC@complex?5type?5definition@
	cmove	eax, ecx
$LN159@xmlSchemaC:

; 14414: 	    xmlSchemaCustomErr4(ACTXT_CAST pctxt,

	cmp	DWORD PTR _action$[ebp], 0
	mov	ecx, OFFSET ??_C@_09KLOJBFOH@redefined@
	push	0
	push	esi
	push	eax
	mov	eax, OFFSET ??_C@_04BHIIPFEC@base@
	cmovne	eax, ecx
	push	eax
	push	OFFSET ??_C@_0FK@HDNJNNIO@The?5?$HLprocess?5contents?$HN?5of?5the?5a@
	push	ebx
	push	0
	push	1799					; 00000707H

; 14415: 		XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3,
; 14416: 		NULL, baseItem,
; 14417: 		"The {process contents} of the attribute wildcard is "
; 14418: 		"weaker than the one in the %s %s '%s'",
; 14419: 		WXS_ACTION_STR(action),
; 14420: 		WXS_ITEM_TYPE_NAME(baseItem),
; 14421: 		xmlSchemaGetComponentQName(&str, baseItem),
; 14422: 		NULL);
; 14423: 	    FREE_AND_NULL(str)
; 14424: 		return(pctxt->err);

	jmp	SHORT $LN217@xmlSchemaC
$LN46@xmlSchemaC:
	pop	edi

; 14425: 	}
; 14426:     }
; 14427:     return(0);
; 14428: }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCheckDerivationOKRestriction2to4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckCVCWildcardNamespace
_TEXT	SEGMENT
_wild$ = 8						; size = 4
_ns$ = 12						; size = 4
_xmlSchemaCheckCVCWildcardNamespace PROC		; COMDAT

; 14109: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _wild$[ebp]
	test	eax, eax
	jne	SHORT $LN4@xmlSchemaC

; 14110:     if (wild == NULL)
; 14111: 	return(-1);

	or	eax, -1

; 14129: }

	pop	ebp
	ret	0
$LN4@xmlSchemaC:

; 14112: 
; 14113:     if (wild->any)

	cmp	DWORD PTR [eax+28], 0
	push	esi
	push	edi
	jne	SHORT $LN17@xmlSchemaC

; 14114: 	return(0);
; 14115:     else if (wild->nsSet != NULL) {

	mov	esi, DWORD PTR [eax+32]
	test	esi, esi
	je	SHORT $LN7@xmlSchemaC

; 14116: 	xmlSchemaWildcardNsPtr cur;
; 14117: 
; 14118: 	cur = wild->nsSet;

	mov	edi, DWORD PTR _ns$[ebp]
	npad	5
$LL2@xmlSchemaC:

; 14119: 	while (cur != NULL) {
; 14120: 	    if (xmlStrEqual(cur->value, ns))

	push	edi
	push	DWORD PTR [esi+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@xmlSchemaC

; 14121: 		return(0);
; 14122: 	    cur = cur->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaC

; 14127: 
; 14128:     return(1);

	pop	edi
	lea	eax, DWORD PTR [esi+1]
	pop	esi

; 14129: }

	pop	ebp
	ret	0
$LN7@xmlSchemaC:

; 14123: 	}
; 14124:     } else if ((wild->negNsSet != NULL) && (ns != NULL) &&

	mov	ecx, DWORD PTR [eax+36]
	test	ecx, ecx
	je	SHORT $LN10@xmlSchemaC
	mov	eax, DWORD PTR _ns$[ebp]
	test	eax, eax
	je	SHORT $LN10@xmlSchemaC
	push	eax
	push	DWORD PTR [ecx+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlSchemaC
$LN10@xmlSchemaC:
	pop	edi

; 14127: 
; 14128:     return(1);

	mov	eax, 1
	pop	esi

; 14129: }

	pop	ebp
	ret	0
$LN17@xmlSchemaC:
	pop	edi

; 14125: 	(!xmlStrEqual(wild->negNsSet->value, ns)))
; 14126: 	return(0);

	xor	eax, eax
	pop	esi

; 14129: }

	pop	ebp
	ret	0
_xmlSchemaCheckCVCWildcardNamespace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetEffectiveValueConstraint
_TEXT	SEGMENT
_attruse$ = 8						; size = 4
_fixed$ = 12						; size = 4
_value$ = 16						; size = 4
_val$ = 20						; size = 4
_xmlSchemaGetEffectiveValueConstraint PROC		; COMDAT

; 14071: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _fixed$[ebp]
	mov	eax, DWORD PTR _value$[ebp]
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [eax], 0
	test	edx, edx
	je	SHORT $LN2@xmlSchemaG

; 14072:     *fixed = 0;
; 14073:     *value = NULL;
; 14074:     if (val != 0)
; 14075: 	*val = NULL;

	mov	DWORD PTR [edx], 0
$LN2@xmlSchemaG:

; 14076: 
; 14077:     if (attruse->defValue != NULL) {

	mov	ecx, DWORD PTR _attruse$[ebp]
	mov	edi, DWORD PTR [ecx+28]
	test	edi, edi
	je	SHORT $LN3@xmlSchemaG

; 14078: 	*value = attruse->defValue;

	mov	DWORD PTR [eax], edi

; 14079: 	if (val != NULL)

	test	edx, edx
	je	SHORT $LN5@xmlSchemaG

; 14080: 	    *val = attruse->defVal;

	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [edx], eax
$LN5@xmlSchemaG:

; 14081: 	if (attruse->flags & XML_SCHEMA_ATTR_USE_FIXED)

	test	BYTE PTR [ecx+16], 1
	jmp	SHORT $LN11@xmlSchemaG
$LN3@xmlSchemaG:

; 14082: 	    *fixed = 1;
; 14083: 	return(1);
; 14084:     } else if ((attruse->attrDecl != NULL) &&

	mov	edi, DWORD PTR [ecx+12]
	test	edi, edi
	je	SHORT $LN7@xmlSchemaG
	mov	edi, DWORD PTR [edi+44]
	test	edi, edi
	je	SHORT $LN7@xmlSchemaG

; 14085: 	(attruse->attrDecl->defValue != NULL)) {
; 14086: 	*value = attruse->attrDecl->defValue;

	mov	DWORD PTR [eax], edi

; 14087: 	if (val != NULL)

	test	edx, edx
	je	SHORT $LN8@xmlSchemaG

; 14088: 	    *val = attruse->attrDecl->defVal;

	mov	eax, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [eax+68]
	mov	DWORD PTR [edx], eax
$LN8@xmlSchemaG:

; 14089: 	if (attruse->attrDecl->flags & XML_SCHEMAS_ATTR_FIXED)

	mov	eax, DWORD PTR [ecx+12]
	test	DWORD PTR [eax+60], 512			; 00000200H
$LN11@xmlSchemaG:

; 14090: 	    *fixed = 1;
; 14091: 	return(1);

	je	SHORT $LN9@xmlSchemaG
	mov	DWORD PTR [esi], 1
$LN9@xmlSchemaG:
	pop	edi
	mov	eax, 1

; 14094: }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlSchemaG:
	pop	edi

; 14092:     }
; 14093:     return(0);

	xor	eax, eax

; 14094: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaGetEffectiveValueConstraint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckCOSNSSubset
_TEXT	SEGMENT
_sub$ = 8						; size = 4
_super$ = 12						; size = 4
_xmlSchemaCheckCOSNSSubset PROC				; COMDAT

; 14006: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _super$[ebp]
	cmp	DWORD PTR [edx+28], 0
	jne	SHORT $LN7@xmlSchemaC

; 14007:     /*
; 14008:     * 1 super must be any.
; 14009:     */
; 14010:     if (super->any)
; 14011: 	return (0);
; 14012:     /*
; 14013:     * 2.1 sub must be a pair of not and a namespace name or `absent`.
; 14014:     * 2.2 super must be a pair of not and the same value.
; 14015:     */
; 14016:     if ((sub->negNsSet != NULL) &&
; 14017: 	(super->negNsSet != NULL) &&

	mov	ecx, DWORD PTR _sub$[ebp]
	mov	eax, DWORD PTR [ecx+36]
	test	eax, eax
	je	SHORT $LN9@xmlSchemaC
	mov	esi, DWORD PTR [edx+36]
	test	esi, esi
	je	SHORT $LN9@xmlSchemaC
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN7@xmlSchemaC
$LN9@xmlSchemaC:

; 14018: 	(sub->negNsSet->value == super->negNsSet->value))
; 14019: 	return (0);
; 14020:     /*
; 14021:     * 3.1 sub must be a set whose members are either namespace names or `absent`.
; 14022:     */
; 14023:     if (sub->nsSet != NULL) {

	mov	ecx, DWORD PTR [ecx+32]
	test	ecx, ecx
	je	SHORT $LN16@xmlSchemaC

; 14024: 	/*
; 14025: 	* 3.2.1 super must be the same set or a superset thereof.
; 14026: 	*/
; 14027: 	if (super->nsSet != NULL) {

	mov	esi, DWORD PTR [edx+32]
	test	esi, esi
	je	SHORT $LN11@xmlSchemaC
	npad	2
$LL2@xmlSchemaC:

; 14028: 	    xmlSchemaWildcardNsPtr cur, curB;
; 14029: 	    int found = 0;
; 14030: 
; 14031: 	    cur = sub->nsSet;
; 14032: 	    while (cur != NULL) {
; 14033: 		found = 0;
; 14034: 		curB = super->nsSet;
; 14035: 		while (curB != NULL) {
; 14036: 		    if (cur->value == curB->value) {

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, esi
$LL4@xmlSchemaC:
	cmp	edx, DWORD PTR [eax+4]
	je	SHORT $LN22@xmlSchemaC

; 14037: 			found = 1;
; 14038: 			break;
; 14039: 		    }
; 14040: 		    curB = curB->next;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL4@xmlSchemaC
$LN16@xmlSchemaC:

; 14061: 	}
; 14062:     }
; 14063:     return (1);

	mov	eax, 1
	pop	esi

; 14064: }

	pop	ebp
	ret	0
$LN22@xmlSchemaC:

; 14041: 		}
; 14042: 		if (!found)
; 14043: 		    return (1);
; 14044: 		cur = cur->next;

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $LL2@xmlSchemaC
$LN7@xmlSchemaC:

; 14059: 	    }
; 14060: 	    return (0);

	xor	eax, eax
	pop	esi

; 14064: }

	pop	ebp
	ret	0
$LN11@xmlSchemaC:

; 14045: 	    }
; 14046: 	    if (found)
; 14047: 		return (0);
; 14048: 	} else if (super->negNsSet != NULL) {

	mov	eax, DWORD PTR [edx+36]
	test	eax, eax
	je	SHORT $LN16@xmlSchemaC

; 14049: 	    xmlSchemaWildcardNsPtr cur;
; 14050: 	    /*
; 14051: 	    * 3.2.2 super must be a pair of not and a namespace name or
; 14052: 	    * `absent` and that value must not be in sub's set.
; 14053: 	    */
; 14054: 	    cur = sub->nsSet;
; 14055: 	    while (cur != NULL) {
; 14056: 		if (cur->value == super->negNsSet->value)

	mov	eax, DWORD PTR [eax+4]
	npad	3
$LL6@xmlSchemaC:
	cmp	DWORD PTR [ecx+4], eax
	je	SHORT $LN16@xmlSchemaC

; 14057: 		    return (1);
; 14058: 		cur = cur->next;

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $LL6@xmlSchemaC

; 14059: 	    }
; 14060: 	    return (0);

	xor	eax, eax
	pop	esi

; 14064: }

	pop	ebp
	ret	0
_xmlSchemaCheckCOSNSSubset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIntersectWildcards
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
tv744 = 12						; size = 4
_completeWild$ = 12					; size = 4
_curWild$ = 16						; size = 4
_xmlSchemaIntersectWildcards PROC			; COMDAT

; 13829: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _completeWild$[ebp]
	mov	edx, DWORD PTR _curWild$[ebp]
	mov	eax, DWORD PTR [ebx+28]
	cmp	eax, DWORD PTR [edx+28]
	jne	$LN78@xmlSchemaI

; 13830:     xmlSchemaWildcardNsPtr cur, curB, prev,  tmp;
; 13831: 
; 13832:     /*
; 13833:     * 1 If O1 and O2 are the same value, then that value must be the
; 13834:     * value.
; 13835:     */
; 13836:     if ((completeWild->any == curWild->any) &&
; 13837: 	((completeWild->nsSet == NULL) == (curWild->nsSet == NULL)) &&

	mov	edi, DWORD PTR _curWild$[ebp]
	xor	ecx, ecx
	mov	edx, DWORD PTR [ebx+32]
	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	mov	DWORD PTR tv744[ebp], eax
	sete	cl
	xor	eax, eax
	test	edx, edx
	sete	al
	cmp	eax, ecx
	jne	$LN88@xmlSchemaI
	mov	edi, DWORD PTR [edi+36]
	xor	ecx, ecx
	mov	esi, DWORD PTR [ebx+36]
	test	edi, edi
	sete	cl
	xor	eax, eax
	test	esi, esi
	sete	al
	cmp	eax, ecx
	jne	SHORT $LN91@xmlSchemaI

; 13838: 	((completeWild->negNsSet == NULL) == (curWild->negNsSet == NULL))) {
; 13839: 
; 13840: 	if ((completeWild->negNsSet == NULL) ||

	test	esi, esi
	je	SHORT $LN16@xmlSchemaI
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [edi+4]
	jne	SHORT $LN91@xmlSchemaI
$LN16@xmlSchemaI:

; 13841: 	    (completeWild->negNsSet->value == curWild->negNsSet->value)) {
; 13842: 
; 13843: 	    if (completeWild->nsSet != NULL) {

	test	edx, edx
	je	$LN43@xmlSchemaI
	mov	esi, DWORD PTR tv744[ebp]
$LL2@xmlSchemaI:

; 13844: 		int found = 0;
; 13845: 
; 13846: 		/*
; 13847: 		* Check equality of sets.
; 13848: 		*/
; 13849: 		cur = completeWild->nsSet;
; 13850: 		while (cur != NULL) {
; 13851: 		    found = 0;
; 13852: 		    curB = curWild->nsSet;

	mov	eax, esi

; 13853: 		    while (curB != NULL) {

	test	eax, eax
	je	SHORT $LN91@xmlSchemaI

; 13854: 			if (cur->value == curB->value) {

	mov	ecx, DWORD PTR [edx+4]
	npad	4
$LL4@xmlSchemaI:
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN52@xmlSchemaI

; 13855: 			    found = 1;
; 13856: 			    break;
; 13857: 			}
; 13858: 			curB = curB->next;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL4@xmlSchemaI
$LN91@xmlSchemaI:

; 13875: 	    return(-1);
; 13876: 	return(0);
; 13877:     }
; 13878:     /*
; 13879:     * 3 If either O1 or O2 is a pair of not and a value (a namespace
; 13880:     * name or `absent`) and the other is a set of (namespace names or
; 13881:     * `absent`), then that set, minus the negated value if it was in
; 13882:     * the set, minus `absent` if it was in the set, must be the value.
; 13883:     */
; 13884:     if (((completeWild->negNsSet != NULL) && (curWild->nsSet != NULL)) ||

	mov	edx, DWORD PTR _curWild$[ebp]
$LN22@xmlSchemaI:
	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	je	SHORT $LN85@xmlSchemaI
	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $LN83@xmlSchemaI
$LN85@xmlSchemaI:
	mov	esi, DWORD PTR [edx+36]
	test	esi, esi
	je	$LN84@xmlSchemaI
	cmp	DWORD PTR [ebx+32], 0
	je	$LN84@xmlSchemaI
$LN83@xmlSchemaI:

; 13885: 	((curWild->negNsSet != NULL) && (completeWild->nsSet != NULL))) {
; 13886: 	const xmlChar *neg;
; 13887: 
; 13888: 	if (completeWild->nsSet == NULL) {

	mov	ecx, DWORD PTR [ebx+32]
	test	ecx, ecx
	jne	SHORT $LN27@xmlSchemaI

; 13889: 	    neg = completeWild->negNsSet->value;

	mov	esi, DWORD PTR [eax+4]

; 13890: 	    if (xmlSchemaCloneWildcardNsConstraints(ctxt, completeWild, curWild) == -1)

	push	edx
	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaCloneWildcardNsConstraints
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN29@xmlSchemaI

; 13990: }

	pop	edi
	pop	esi
	or	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN52@xmlSchemaI:

; 13859: 		    }
; 13860: 		    if (!found)
; 13861: 			break;
; 13862: 		    cur = cur->next;

	mov	edx, DWORD PTR [edx]
	test	edx, edx
	jne	SHORT $LL2@xmlSchemaI

; 13990: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN78@xmlSchemaI:

; 13863: 		}
; 13864: 		if (found)
; 13865: 		    return(0);
; 13866: 	    } else
; 13867: 		return(0);
; 13868: 	}
; 13869:     }
; 13870:     /*
; 13871:     * 2 If either O1 or O2 is any, then the other must be the value.
; 13872:     */
; 13873:     if ((completeWild->any != curWild->any) && (completeWild->any)) {

	test	eax, eax
	je	SHORT $LN22@xmlSchemaI

; 13874: 	if (xmlSchemaCloneWildcardNsConstraints(ctxt, completeWild, curWild) == -1)

	push	edx
	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaCloneWildcardNsConstraints
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	$LN43@xmlSchemaI

; 13990: }

	pop	edi
	pop	esi
	or	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN88@xmlSchemaI:

; 13830:     xmlSchemaWildcardNsPtr cur, curB, prev,  tmp;
; 13831: 
; 13832:     /*
; 13833:     * 1 If O1 and O2 are the same value, then that value must be the
; 13834:     * value.
; 13835:     */
; 13836:     if ((completeWild->any == curWild->any) &&
; 13837: 	((completeWild->nsSet == NULL) == (curWild->nsSet == NULL)) &&

	mov	edx, edi

; 13838: 	((completeWild->negNsSet == NULL) == (curWild->negNsSet == NULL))) {
; 13839: 
; 13840: 	if ((completeWild->negNsSet == NULL) ||

	jmp	SHORT $LN22@xmlSchemaI
$LN29@xmlSchemaI:

; 13891: 		return(-1);
; 13892: 	} else

	mov	ecx, DWORD PTR [ebx+32]
	jmp	SHORT $LN28@xmlSchemaI
$LN27@xmlSchemaI:

; 13893: 	    neg = curWild->negNsSet->value;

	mov	eax, DWORD PTR [edx+36]
	mov	esi, DWORD PTR [eax+4]
$LN28@xmlSchemaI:

; 13894: 	/*
; 13895: 	* Remove absent and negated.
; 13896: 	*/
; 13897: 	prev = NULL;

	xor	edx, edx

; 13898: 	cur = completeWild->nsSet;
; 13899: 	while (cur != NULL) {

	test	ecx, ecx
	je	SHORT $LN7@xmlSchemaI
$LL6@xmlSchemaI:

; 13900: 	    if (cur->value == NULL) {

	cmp	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR [ecx]
	je	SHORT $LN54@xmlSchemaI

; 13906: 		break;
; 13907: 	    }
; 13908: 	    prev = cur;

	mov	edx, ecx

; 13909: 	    cur = cur->next;

	mov	ecx, eax
	test	ecx, ecx
	jne	SHORT $LL6@xmlSchemaI

; 13943: 		if (cur->value == curB->value) {

	jmp	SHORT $LN7@xmlSchemaI
$LN54@xmlSchemaI:

; 13901: 		if (prev == NULL)

	test	edx, edx
	jne	SHORT $LN31@xmlSchemaI

; 13902: 		    completeWild->nsSet = cur->next;

	mov	DWORD PTR [ebx+32], eax
	jmp	SHORT $LN32@xmlSchemaI
$LN31@xmlSchemaI:

; 13903: 		else
; 13904: 		    prev->next = cur->next;

	mov	DWORD PTR [edx], eax
$LN32@xmlSchemaI:

; 13905: 		xmlFree(cur);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlSchemaI:

; 13910: 	}
; 13911: 	if (neg != NULL) {

	test	esi, esi
	je	$LN43@xmlSchemaI

; 13912: 	    prev = NULL;
; 13913: 	    cur = completeWild->nsSet;

	mov	eax, DWORD PTR [ebx+32]
	xor	edx, edx

; 13914: 	    while (cur != NULL) {

	test	eax, eax
	je	$LN43@xmlSchemaI
$LL8@xmlSchemaI:

; 13915: 		if (cur->value == neg) {

	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [eax+4], esi
	je	SHORT $LN55@xmlSchemaI

; 13921: 		    break;
; 13922: 		}
; 13923: 		prev = cur;

	mov	edx, eax

; 13924: 		cur = cur->next;

	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LL8@xmlSchemaI

; 13990: }

	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN55@xmlSchemaI:

; 13916: 		    if (prev == NULL)

	test	edx, edx
	jne	SHORT $LN35@xmlSchemaI

; 13917: 			completeWild->nsSet = cur->next;
; 13918: 		    else
; 13919: 			prev->next = cur->next;
; 13920: 		    xmlFree(cur);

	push	eax
	mov	DWORD PTR [ebx+32], ecx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 13988:     }
; 13989:     return(0);

	xor	eax, eax
	pop	edi

; 13990: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN35@xmlSchemaI:

; 13917: 			completeWild->nsSet = cur->next;
; 13918: 		    else
; 13919: 			prev->next = cur->next;
; 13920: 		    xmlFree(cur);

	push	eax
	mov	DWORD PTR [edx], ecx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 13988:     }
; 13989:     return(0);

	xor	eax, eax
	pop	edi

; 13990: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN84@xmlSchemaI:

; 13925: 	    }
; 13926: 	}
; 13927: 
; 13928: 	return(0);
; 13929:     }
; 13930:     /*
; 13931:     * 4 If both O1 and O2 are sets of (namespace names or `absent`),
; 13932:     * then the intersection of those sets must be the value.
; 13933:     */
; 13934:     if ((completeWild->nsSet != NULL) && (curWild->nsSet != NULL)) {

	mov	ecx, DWORD PTR [ebx+32]
	test	ecx, ecx
	je	SHORT $LN37@xmlSchemaI
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN37@xmlSchemaI

; 13935: 	int found;
; 13936: 
; 13937: 	cur = completeWild->nsSet;
; 13938: 	prev = NULL;

	xor	edi, edi
$LL10@xmlSchemaI:

; 13940: 	    found = 0;
; 13941: 	    curB = curWild->nsSet;

	mov	eax, DWORD PTR [edx+32]
	xor	esi, esi

; 13942: 	    while (curB != NULL) {

	test	eax, eax
	je	SHORT $LN13@xmlSchemaI

; 13943: 		if (cur->value == curB->value) {

	mov	edx, DWORD PTR [ecx+4]
	npad	4
$LL12@xmlSchemaI:
	cmp	edx, DWORD PTR [eax+4]
	je	SHORT $LN56@xmlSchemaI

; 13945: 		    break;
; 13946: 		}
; 13947: 		curB = curB->next;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL12@xmlSchemaI

; 13943: 		if (cur->value == curB->value) {

	jmp	SHORT $LN13@xmlSchemaI
$LN56@xmlSchemaI:

; 13944: 		    found = 1;

	mov	esi, 1
$LN13@xmlSchemaI:

; 13948: 	    }
; 13949: 	    if (!found) {

	mov	eax, DWORD PTR [ecx]
	test	esi, esi
	jne	SHORT $LN39@xmlSchemaI

; 13950: 		if (prev == NULL)

	test	edi, edi
	jne	SHORT $LN40@xmlSchemaI

; 13951: 		    completeWild->nsSet = cur->next;

	mov	DWORD PTR [ebx+32], eax

; 13954: 		tmp = cur->next;

	mov	esi, DWORD PTR [ecx]

; 13955: 		xmlFree(cur);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 13956: 		cur = tmp;

	mov	ecx, esi

; 13957: 		continue;

	jmp	SHORT $LN62@xmlSchemaI
$LN40@xmlSchemaI:

; 13952: 		else
; 13953: 		    prev->next = cur->next;

	mov	DWORD PTR [edi], eax

; 13954: 		tmp = cur->next;

	mov	esi, DWORD PTR [ecx]

; 13955: 		xmlFree(cur);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 13956: 		cur = tmp;

	mov	ecx, esi

; 13957: 		continue;

	jmp	SHORT $LN62@xmlSchemaI
$LN39@xmlSchemaI:

; 13958: 	    }
; 13959: 	    prev = cur;

	mov	edi, ecx

; 13960: 	    cur = cur->next;

	mov	ecx, eax
$LN62@xmlSchemaI:

; 13939: 	while (cur != NULL) {

	mov	edx, DWORD PTR _curWild$[ebp]
	test	ecx, ecx
	jne	SHORT $LL10@xmlSchemaI

; 13990: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN37@xmlSchemaI:

; 13961: 	}
; 13962: 
; 13963: 	return(0);
; 13964:     }
; 13965:     /* 5 If the two are negations of different namespace names,
; 13966:     * then the intersection is not expressible
; 13967:     */
; 13968:     if ((completeWild->negNsSet != NULL) &&
; 13969: 	(curWild->negNsSet != NULL) &&
; 13970: 	(completeWild->negNsSet->value != curWild->negNsSet->value) &&
; 13971: 	(completeWild->negNsSet->value != NULL) &&

	test	eax, eax
	je	SHORT $LN43@xmlSchemaI
	test	esi, esi
	je	SHORT $LN43@xmlSchemaI
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edx, ecx
	je	SHORT $LN43@xmlSchemaI
	test	edx, edx
	je	SHORT $LN42@xmlSchemaI
	test	ecx, ecx
	je	SHORT $LN42@xmlSchemaI

; 13972: 	(curWild->negNsSet->value != NULL)) {
; 13973: 
; 13974: 	xmlSchemaPErr(ctxt, completeWild->node, XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE,

	push	0
	push	0
	push	OFFSET ??_C@_0DF@DJLMCEFH@The?5intersection?5of?5the?5wilcard@
	push	1793					; 00000701H
	push	DWORD PTR [ebx+12]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPErr
	add	esp, 24					; 00000018H

; 13975: 	    "The intersection of the wilcard is not expressible.\n",
; 13976: 	    NULL, NULL);
; 13977: 	return(XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE);

	mov	eax, 1793				; 00000701H
	pop	edi

; 13990: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN42@xmlSchemaI:

; 13978:     }
; 13979:     /*
; 13980:     * 6 If the one is a negation of a namespace name and the other
; 13981:     * is a negation of `absent`, then the one which is the negation
; 13982:     * of a namespace name must be the value.
; 13983:     */
; 13984:     if ((completeWild->negNsSet != NULL) && (curWild->negNsSet != NULL) &&
; 13985: 	(completeWild->negNsSet->value != curWild->negNsSet->value) &&

	cmp	edx, ecx
	je	SHORT $LN43@xmlSchemaI
	test	edx, edx
	jne	SHORT $LN43@xmlSchemaI

; 13986: 	(completeWild->negNsSet->value == NULL)) {
; 13987: 	completeWild->negNsSet->value =  curWild->negNsSet->value;

	mov	DWORD PTR [eax+4], ecx
$LN43@xmlSchemaI:
	pop	edi

; 13990: }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaIntersectWildcards ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaUnionWildcards
_TEXT	SEGMENT
tv910 = -4						; size = 4
_ctxt$ = 8						; size = 4
_completeWild$ = 12					; size = 4
_curWild$ = 16						; size = 4
_xmlSchemaUnionWildcards PROC				; COMDAT

; 13569: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _completeWild$[ebp]
	mov	edx, DWORD PTR _curWild$[ebp]
	mov	eax, DWORD PTR [edi+28]
	cmp	eax, DWORD PTR [edx+28]
	jne	$LN101@xmlSchemaU

; 13570:     xmlSchemaWildcardNsPtr cur, curB, tmp;
; 13571: 
; 13572:     /*
; 13573:     * 1 If O1 and O2 are the same value, then that value must be the
; 13574:     * value.
; 13575:     */
; 13576:     if ((completeWild->any == curWild->any) &&
; 13577: 	((completeWild->nsSet == NULL) == (curWild->nsSet == NULL)) &&

	mov	esi, DWORD PTR [edx+32]
	xor	ecx, ecx
	mov	ebx, DWORD PTR [edi+32]
	test	esi, esi
	sete	cl
	xor	eax, eax
	test	ebx, ebx
	sete	al
	cmp	eax, ecx
	jne	SHORT $LN22@xmlSchemaU
	mov	ecx, DWORD PTR _curWild$[ebp]
	mov	edx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [ecx+36]
	xor	ecx, ecx
	test	eax, eax
	sete	cl
	xor	eax, eax
	test	edx, edx
	sete	al
	cmp	eax, ecx
	jne	SHORT $LN116@xmlSchemaU

; 13578: 	((completeWild->negNsSet == NULL) == (curWild->negNsSet == NULL))) {
; 13579: 
; 13580: 	if ((completeWild->negNsSet == NULL) ||

	test	edx, edx
	je	SHORT $LN16@xmlSchemaU
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _curWild$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	cmp	eax, DWORD PTR [ecx+4]
	jne	SHORT $LN22@xmlSchemaU
$LN16@xmlSchemaU:

; 13581: 	    (completeWild->negNsSet->value == curWild->negNsSet->value)) {
; 13582: 
; 13583: 	    if (completeWild->nsSet != NULL) {

	test	ebx, ebx
	je	$LN55@xmlSchemaU

; 13584: 		int found = 0;
; 13585: 
; 13586: 		/*
; 13587: 		* Check equality of sets.
; 13588: 		*/
; 13589: 		cur = completeWild->nsSet;

	mov	edx, ebx
$LL2@xmlSchemaU:

; 13590: 		while (cur != NULL) {
; 13591: 		    found = 0;
; 13592: 		    curB = curWild->nsSet;

	mov	eax, esi

; 13593: 		    while (curB != NULL) {

	test	eax, eax
	je	SHORT $LN116@xmlSchemaU

; 13594: 			if (cur->value == curB->value) {

	mov	ecx, DWORD PTR [edx+4]
	npad	5
$LL4@xmlSchemaU:
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN73@xmlSchemaU

; 13595: 			    found = 1;
; 13596: 			    break;
; 13597: 			}
; 13598: 			curB = curB->next;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL4@xmlSchemaU
$LN116@xmlSchemaU:

; 13618: 		completeWild->nsSet = NULL;
; 13619: 	    }
; 13620: 	    if (completeWild->negNsSet != NULL) {
; 13621: 		xmlFree(completeWild->negNsSet);
; 13622: 		completeWild->negNsSet = NULL;
; 13623: 	    }
; 13624: 	}
; 13625: 	return (0);
; 13626:     }
; 13627:     /*
; 13628:     * 3 If both O1 and O2 are sets of (namespace names or `absent`),
; 13629:     * then the union of those sets must be the value.
; 13630:     */
; 13631:     if ((completeWild->nsSet != NULL) && (curWild->nsSet != NULL)) {

	mov	edx, DWORD PTR _curWild$[ebp]
$LN22@xmlSchemaU:
	test	ebx, ebx
	je	SHORT $LN91@xmlSchemaU
	test	esi, esi
	je	SHORT $LN91@xmlSchemaU
$LL6@xmlSchemaU:

; 13632: 	int found;
; 13633: 	xmlSchemaWildcardNsPtr start;
; 13634: 
; 13635: 	cur = curWild->nsSet;
; 13636: 	start = completeWild->nsSet;
; 13637: 	while (cur != NULL) {
; 13638: 	    found = 0;
; 13639: 	    curB = start;

	mov	eax, ebx

; 13640: 	    while (curB != NULL) {

	test	ebx, ebx
	je	SHORT $LN108@xmlSchemaU

; 13641: 		if (cur->value == curB->value) {

	mov	ecx, DWORD PTR [esi+4]
	npad	1
$LL8@xmlSchemaU:
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN28@xmlSchemaU

; 13642: 		    found = 1;
; 13643: 		    break;
; 13644: 		}
; 13645: 		curB = curB->next;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL8@xmlSchemaU
$LN108@xmlSchemaU:

; 13646: 	    }
; 13647: 	    if (!found) {
; 13648: 		tmp = xmlSchemaNewWildcardNsConstraint(ctxt);

	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaNewWildcardNsConstraint
	add	esp, 4

; 13649: 		if (tmp == NULL)

	test	eax, eax
	je	$LN113@xmlSchemaU

; 13650: 		    return (-1);
; 13651: 		tmp->value = cur->value;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx

; 13652: 		tmp->next = completeWild->nsSet;

	mov	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR [eax], ecx

; 13653: 		completeWild->nsSet = tmp;

	mov	DWORD PTR [edi+32], eax
$LN28@xmlSchemaU:

; 13654: 	    }
; 13655: 	    cur = cur->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL6@xmlSchemaU

; 13805: 		return (-1);
; 13806: 	    completeWild->negNsSet->value = NULL;
; 13807: 	}
; 13808: 	return (0);
; 13809:     }
; 13810:     return (0);
; 13811: 
; 13812: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN73@xmlSchemaU:

; 13599: 		    }
; 13600: 		    if (!found)
; 13601: 			break;
; 13602: 		    cur = cur->next;

	mov	edx, DWORD PTR [edx]
	test	edx, edx
	jne	SHORT $LL2@xmlSchemaU

; 13805: 		return (-1);
; 13806: 	    completeWild->negNsSet->value = NULL;
; 13807: 	}
; 13808: 	return (0);
; 13809:     }
; 13810:     return (0);
; 13811: 
; 13812: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN91@xmlSchemaU:

; 13656: 	}
; 13657: 
; 13658: 	return(0);
; 13659:     }
; 13660:     /*
; 13661:     * 4 If the two are negations of different values (namespace names
; 13662:     * or `absent`), then a pair of not and `absent` must be the value.
; 13663:     */
; 13664:     if ((completeWild->negNsSet != NULL) &&
; 13665: 	(curWild->negNsSet != NULL) &&

	mov	ecx, DWORD PTR [edi+36]
	mov	DWORD PTR tv910[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN33@xmlSchemaU
	mov	edx, DWORD PTR [edx+36]
	test	edx, edx
	je	SHORT $LN111@xmlSchemaU
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	je	SHORT $LN111@xmlSchemaU

; 13805: 		return (-1);
; 13806: 	    completeWild->negNsSet->value = NULL;
; 13807: 	}
; 13808: 	return (0);
; 13809:     }
; 13810:     return (0);
; 13811: 
; 13812: }

	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+4], 0
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN111@xmlSchemaU:

; 13666: 	(completeWild->negNsSet->value != curWild->negNsSet->value)) {
; 13667: 	completeWild->negNsSet->value = NULL;
; 13668: 
; 13669: 	return(0);
; 13670:     }
; 13671:     /*
; 13672:      * 5.
; 13673:      */
; 13674:     if (((completeWild->negNsSet != NULL) &&
; 13675: 	(completeWild->negNsSet->value != NULL) &&
; 13676: 	(curWild->nsSet != NULL)) ||

	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN33@xmlSchemaU
	test	esi, esi
	jne	SHORT $LN92@xmlSchemaU
$LN33@xmlSchemaU:
	mov	eax, DWORD PTR _curWild$[ebp]
	mov	edx, DWORD PTR [eax+36]
	test	edx, edx
	je	$LN31@xmlSchemaU
	cmp	DWORD PTR [edx+4], 0
	je	$LN31@xmlSchemaU
	test	ebx, ebx
	je	$LN31@xmlSchemaU
$LN92@xmlSchemaU:

; 13677: 	((curWild->negNsSet != NULL) &&
; 13678: 	(curWild->negNsSet->value != NULL) &&
; 13679: 	(completeWild->nsSet != NULL))) {
; 13680: 
; 13681: 	int nsFound, absentFound = 0;

	xor	ecx, ecx

; 13682: 
; 13683: 	if (completeWild->nsSet != NULL) {

	test	ebx, ebx
	je	SHORT $LN34@xmlSchemaU

; 13684: 	    cur = completeWild->nsSet;

	mov	esi, ebx

; 13685: 	    curB = curWild->negNsSet;
; 13686: 	} else {

	jmp	SHORT $LN35@xmlSchemaU
$LN34@xmlSchemaU:

; 13687: 	    cur = curWild->nsSet;
; 13688: 	    curB = completeWild->negNsSet;

	mov	edx, DWORD PTR tv910[ebp]
$LN35@xmlSchemaU:

; 13689: 	}
; 13690: 	nsFound = 0;
; 13691: 	while (cur != NULL) {

	test	esi, esi
	je	$LN112@xmlSchemaU

; 13694: 	    else if (cur->value == curB->value)

	xor	edi, edi
$LL10@xmlSchemaU:

; 13692: 	    if (cur->value == NULL)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN36@xmlSchemaU

; 13693: 		absentFound = 1;

	lea	ecx, DWORD PTR [eax+1]
$LN38@xmlSchemaU:

; 13696: 	    if (nsFound && absentFound)

	test	edi, edi
	je	SHORT $LN39@xmlSchemaU
$LN104@xmlSchemaU:
	test	ecx, ecx
	jne	SHORT $LN77@xmlSchemaU
$LN39@xmlSchemaU:

; 13697: 		break;
; 13698: 	    cur = cur->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL10@xmlSchemaU
$LN77@xmlSchemaU:

; 13699: 	}
; 13700: 
; 13701: 	if (nsFound && absentFound) {

	test	edi, edi
	mov	edi, DWORD PTR _completeWild$[ebp]
	je	SHORT $LN100@xmlSchemaU
	test	ecx, ecx
	je	SHORT $LN40@xmlSchemaU
$LN78@xmlSchemaU:

; 13805: 		return (-1);
; 13806: 	    completeWild->negNsSet->value = NULL;
; 13807: 	}
; 13808: 	return (0);
; 13809:     }
; 13810:     return (0);
; 13811: 
; 13812: }

	mov	DWORD PTR [edi+28], 1
	test	ebx, ebx
	je	$LN24@xmlSchemaU
	push	ebx
	jmp	$LN118@xmlSchemaU
$LN36@xmlSchemaU:

; 13694: 	    else if (cur->value == curB->value)

	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN38@xmlSchemaU

; 13695: 		nsFound = 1;

	mov	edi, 1

; 13696: 	    if (nsFound && absentFound)

	jmp	SHORT $LN104@xmlSchemaU
$LN40@xmlSchemaU:

; 13702: 	    /*
; 13703: 	    * 5.1 If the set S includes both the negated namespace
; 13704: 	    * name and `absent`, then any must be the value.
; 13705: 	    */
; 13706: 	    completeWild->any = 1;
; 13707: 	    if (completeWild->nsSet != NULL) {
; 13708: 		xmlSchemaFreeWildcardNsSet(completeWild->nsSet);
; 13709: 		completeWild->nsSet = NULL;
; 13710: 	    }
; 13711: 	    if (completeWild->negNsSet != NULL) {
; 13712: 		xmlFree(completeWild->negNsSet);
; 13713: 		completeWild->negNsSet = NULL;
; 13714: 	    }
; 13715: 	} else if (nsFound && (!absentFound)) {
; 13716: 	    /*
; 13717: 	    * 5.2 If the set S includes the negated namespace name
; 13718: 	    * but not `absent`, then a pair of not and `absent` must
; 13719: 	    * be the value.
; 13720: 	    */
; 13721: 	    if (completeWild->nsSet != NULL) {

	test	ebx, ebx
	je	SHORT $LN46@xmlSchemaU

; 13722: 		xmlSchemaFreeWildcardNsSet(completeWild->nsSet);

	push	ebx
	call	_xmlSchemaFreeWildcardNsSet
	add	esp, 4

; 13723: 		completeWild->nsSet = NULL;

	mov	DWORD PTR [edi+32], 0
$LN46@xmlSchemaU:

; 13724: 	    }
; 13725: 	    if (completeWild->negNsSet == NULL) {

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	jne	SHORT $LN48@xmlSchemaU

; 13726: 		completeWild->negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);

	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaNewWildcardNsConstraint
	add	esp, 4
	mov	DWORD PTR [edi+36], eax

; 13727: 		if (completeWild->negNsSet == NULL)

	test	eax, eax
	je	$LN113@xmlSchemaU
$LN48@xmlSchemaU:
	pop	edi

; 13805: 		return (-1);
; 13806: 	    completeWild->negNsSet->value = NULL;
; 13807: 	}
; 13808: 	return (0);
; 13809:     }
; 13810:     return (0);
; 13811: 
; 13812: }

	pop	esi
	mov	DWORD PTR [eax+4], 0
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN100@xmlSchemaU:

; 13728: 		    return (-1);
; 13729: 	    }
; 13730: 	    completeWild->negNsSet->value = NULL;
; 13731: 	} else if ((!nsFound) && absentFound) {

	test	ecx, ecx
	je	SHORT $LN112@xmlSchemaU

; 13732: 	    /*
; 13733: 	    * 5.3 If the set S includes `absent` but not the negated
; 13734: 	    * namespace name, then the union is not expressible.
; 13735: 	    */
; 13736: 	    xmlSchemaPErr(ctxt, completeWild->node,

	push	0
	push	0
	push	OFFSET ??_C@_0CO@HFHAKEB@The?5union?5of?5the?5wilcard?5is?5not@
	push	1794					; 00000702H
	push	DWORD PTR [edi+12]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPErr
	add	esp, 24					; 00000018H

; 13737: 		XML_SCHEMAP_UNION_NOT_EXPRESSIBLE,
; 13738: 		"The union of the wilcard is not expressible.\n",
; 13739: 		NULL, NULL);
; 13740: 	    return(XML_SCHEMAP_UNION_NOT_EXPRESSIBLE);

	mov	eax, 1794				; 00000702H
	pop	edi

; 13805: 		return (-1);
; 13806: 	    completeWild->negNsSet->value = NULL;
; 13807: 	}
; 13808: 	return (0);
; 13809:     }
; 13810:     return (0);
; 13811: 
; 13812: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN112@xmlSchemaU:

; 13741: 	} else if ((!nsFound) && (!absentFound)) {
; 13742: 	    /*
; 13743: 	    * 5.4 If the set S does not include either the negated namespace
; 13744: 	    * name or `absent`, then whichever of O1 or O2 is a pair of not
; 13745: 	    * and a namespace name must be the value.
; 13746: 	    */
; 13747: 	    if (completeWild->negNsSet == NULL) {

	cmp	DWORD PTR tv910[ebp], 0
	jne	$LN55@xmlSchemaU

; 13748: 		if (completeWild->nsSet != NULL) {

	test	ebx, ebx
	je	SHORT $LN53@xmlSchemaU

; 13749: 		    xmlSchemaFreeWildcardNsSet(completeWild->nsSet);

	push	ebx
	call	_xmlSchemaFreeWildcardNsSet
	add	esp, 4

; 13750: 		    completeWild->nsSet = NULL;

	mov	DWORD PTR [edi+32], 0
$LN53@xmlSchemaU:

; 13751: 		}
; 13752: 		completeWild->negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);

	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaNewWildcardNsConstraint
	add	esp, 4
	mov	DWORD PTR [edi+36], eax

; 13753: 		if (completeWild->negNsSet == NULL)

	test	eax, eax
	je	$LN113@xmlSchemaU

; 13754: 		    return (-1);
; 13755: 		completeWild->negNsSet->value = curWild->negNsSet->value;

	mov	ecx, DWORD PTR _curWild$[ebp]
	pop	edi

; 13805: 		return (-1);
; 13806: 	    completeWild->negNsSet->value = NULL;
; 13807: 	}
; 13808: 	return (0);
; 13809:     }
; 13810:     return (0);
; 13811: 
; 13812: }

	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlSchemaU:

; 13756: 	    }
; 13757: 	}
; 13758: 	return (0);
; 13759:     }
; 13760:     /*
; 13761:      * 6.
; 13762:      */
; 13763:     if (((completeWild->negNsSet != NULL) &&
; 13764: 	(completeWild->negNsSet->value == NULL) &&
; 13765: 	(curWild->nsSet != NULL)) ||

	test	ecx, ecx
	je	SHORT $LN57@xmlSchemaU
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN57@xmlSchemaU
	test	esi, esi
	je	SHORT $LN57@xmlSchemaU

; 13766: 	((curWild->negNsSet != NULL) &&
; 13767: 	(curWild->negNsSet->value == NULL) &&
; 13768: 	(completeWild->nsSet != NULL))) {
; 13769: 
; 13770: 	if (completeWild->nsSet != NULL) {

	test	ebx, ebx
	jne	SHORT $LN99@xmlSchemaU

; 13772: 	} else {
; 13773: 	    cur = curWild->nsSet;

	jmp	SHORT $LN72@xmlSchemaU
$LN57@xmlSchemaU:

; 13756: 	    }
; 13757: 	}
; 13758: 	return (0);
; 13759:     }
; 13760:     /*
; 13761:      * 6.
; 13762:      */
; 13763:     if (((completeWild->negNsSet != NULL) &&
; 13764: 	(completeWild->negNsSet->value == NULL) &&
; 13765: 	(curWild->nsSet != NULL)) ||

	test	edx, edx
	je	$LN55@xmlSchemaU
	cmp	DWORD PTR [edx+4], 0
	jne	$LN55@xmlSchemaU
	test	ebx, ebx
	je	$LN55@xmlSchemaU
$LN99@xmlSchemaU:

; 13771: 	    cur = completeWild->nsSet;

	mov	esi, ebx
$LN72@xmlSchemaU:

; 13774: 	}
; 13775: 	while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN13@xmlSchemaU
$LL12@xmlSchemaU:

; 13776: 	    if (cur->value == NULL) {

	cmp	DWORD PTR [esi+4], 0
	je	$LN78@xmlSchemaU

; 13777: 		/*
; 13778: 		* 6.1 If the set S includes `absent`, then any must be the
; 13779: 		* value.
; 13780: 		*/
; 13781: 		completeWild->any = 1;
; 13782: 		if (completeWild->nsSet != NULL) {
; 13783: 		    xmlSchemaFreeWildcardNsSet(completeWild->nsSet);
; 13784: 		    completeWild->nsSet = NULL;
; 13785: 		}
; 13786: 		if (completeWild->negNsSet != NULL) {
; 13787: 		    xmlFree(completeWild->negNsSet);
; 13788: 		    completeWild->negNsSet = NULL;
; 13789: 		}
; 13790: 		return (0);
; 13791: 	    }
; 13792: 	    cur = cur->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL12@xmlSchemaU
$LN13@xmlSchemaU:

; 13793: 	}
; 13794: 	if (completeWild->negNsSet == NULL) {

	test	ecx, ecx
	jne	SHORT $LN55@xmlSchemaU

; 13795: 	    /*
; 13796: 	    * 6.2 If the set S does not include `absent`, then a pair of not
; 13797: 	    * and `absent` must be the value.
; 13798: 	    */
; 13799: 	    if (completeWild->nsSet != NULL) {

	test	ebx, ebx
	je	SHORT $LN64@xmlSchemaU

; 13800: 		xmlSchemaFreeWildcardNsSet(completeWild->nsSet);

	push	ebx
	call	_xmlSchemaFreeWildcardNsSet
	add	esp, 4

; 13801: 		completeWild->nsSet = NULL;

	mov	DWORD PTR [edi+32], 0
$LN64@xmlSchemaU:

; 13802: 	    }
; 13803: 	    completeWild->negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);

	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaNewWildcardNsConstraint
	add	esp, 4
	mov	DWORD PTR [edi+36], eax

; 13804: 	    if (completeWild->negNsSet == NULL)

	test	eax, eax
	jne	$LN48@xmlSchemaU
$LN113@xmlSchemaU:
	pop	edi

; 13805: 		return (-1);
; 13806: 	    completeWild->negNsSet->value = NULL;
; 13807: 	}
; 13808: 	return (0);
; 13809:     }
; 13810:     return (0);
; 13811: 
; 13812: }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN101@xmlSchemaU:

; 13603: 		}
; 13604: 		if (found)
; 13605: 		    return(0);
; 13606: 	    } else
; 13607: 		return(0);
; 13608: 	}
; 13609:     }
; 13610:     /*
; 13611:     * 2 If either O1 or O2 is any, then any must be the value
; 13612:     */
; 13613:     if (completeWild->any != curWild->any) {
; 13614: 	if (completeWild->any == 0) {

	test	eax, eax
	jne	SHORT $LN55@xmlSchemaU

; 13615: 	    completeWild->any = 1;
; 13616: 	    if (completeWild->nsSet != NULL) {

	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [edi+28], 1
	test	eax, eax
	je	SHORT $LN24@xmlSchemaU

; 13617: 		xmlSchemaFreeWildcardNsSet(completeWild->nsSet);

	push	eax
$LN118@xmlSchemaU:

; 13805: 		return (-1);
; 13806: 	    completeWild->negNsSet->value = NULL;
; 13807: 	}
; 13808: 	return (0);
; 13809:     }
; 13810:     return (0);
; 13811: 
; 13812: }

	call	_xmlSchemaFreeWildcardNsSet
	add	esp, 4
	mov	DWORD PTR [edi+32], 0
$LN24@xmlSchemaU:
	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN55@xmlSchemaU
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	DWORD PTR [edi+36], 0
$LN55@xmlSchemaU:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaUnionWildcards ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCloneWildcardNsConstraints
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_dest$ = 12						; size = 4
_source$ = 16						; size = 4
_xmlSchemaCloneWildcardNsConstraints PROC		; COMDAT

; 13522: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _source$[ebp]
	test	ecx, ecx
	je	$LN5@xmlSchemaC

; 13523:     xmlSchemaWildcardNsPtr cur, tmp, last;
; 13524: 
; 13525:     if ((source == NULL) || (dest == NULL))

	mov	ebx, DWORD PTR _dest$[ebp]
	test	ebx, ebx
	je	$LN5@xmlSchemaC

; 13526: 	return(-1);
; 13527:     dest->any = source->any;

	mov	eax, DWORD PTR [ecx+28]

; 13528:     cur = source->nsSet;
; 13529:     last = NULL;

	xor	edi, edi
	mov	DWORD PTR [ebx+28], eax
	mov	esi, DWORD PTR [ecx+32]

; 13530:     while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlSchemaC
$LL2@xmlSchemaC:

; 5637 :     ret = (xmlSchemaWildcardNsPtr)

	push	8
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 5638 : 	xmlMalloc(sizeof(xmlSchemaWildcardNs));
; 5639 :     if (ret == NULL) {

	test	eax, eax
	je	SHORT $LN25@xmlSchemaC

; 5640 : 	xmlSchemaPErrMemory(ctxt, "creating wildcard namespace constraint", NULL);
; 5641 : 	return (NULL);
; 5642 :     }
; 5643 :     ret->value = NULL;

	mov	DWORD PTR [eax+4], 0

; 5644 :     ret->next = NULL;

	mov	DWORD PTR [eax], 0

; 13531: 	tmp = xmlSchemaNewWildcardNsConstraint(ctxt);
; 13532: 	if (tmp == NULL)
; 13533: 	    return(-1);
; 13534: 	tmp->value = cur->value;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx

; 13535: 	if (last == NULL)

	test	edi, edi
	jne	SHORT $LN7@xmlSchemaC

; 13536: 	    dest->nsSet = tmp;

	mov	DWORD PTR [ebx+32], eax
	jmp	SHORT $LN8@xmlSchemaC
$LN7@xmlSchemaC:

; 13537: 	else
; 13538: 	    last->next = tmp;

	mov	DWORD PTR [edi], eax
$LN8@xmlSchemaC:

; 13539: 	last = tmp;
; 13540: 	cur = cur->next;

	mov	esi, DWORD PTR [esi]
	mov	edi, eax
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaC
$LN3@xmlSchemaC:

; 13541:     }
; 13542:     if (dest->negNsSet != NULL)

	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	je	SHORT $LN9@xmlSchemaC

; 13543: 	xmlSchemaFreeWildcardNsSet(dest->negNsSet);

	push	eax
	call	_xmlSchemaFreeWildcardNsSet
	add	esp, 4
$LN9@xmlSchemaC:

; 13544:     if (source->negNsSet != NULL) {

	mov	esi, DWORD PTR _source$[ebp]
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN10@xmlSchemaC

; 13545: 	dest->negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);

	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaNewWildcardNsConstraint
	add	esp, 4
	mov	DWORD PTR [ebx+36], eax

; 13546: 	if (dest->negNsSet == NULL)

	test	eax, eax
	je	SHORT $LN5@xmlSchemaC

; 13547: 	    return(-1);
; 13548: 	dest->negNsSet->value = source->negNsSet->value;

	mov	ecx, DWORD PTR [esi+36]
	pop	edi

; 13549:     } else
; 13550: 	dest->negNsSet = NULL;
; 13551:     return(0);
; 13552: }

	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	xor	eax, eax
	pop	ebp
	ret	0
$LN25@xmlSchemaC:

; 1884 :     if (ctxt != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN18@xmlSchemaC

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [eax+20]
$LN18@xmlSchemaC:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CH@KLLMMGAA@creating?5wildcard?5namespace?5con@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
$LN5@xmlSchemaC:
	pop	edi

; 13549:     } else
; 13550: 	dest->negNsSet = NULL;
; 13551:     return(0);
; 13552: }

	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN10@xmlSchemaC:
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+36], 0
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaCloneWildcardNsConstraints ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetPrimitiveType
_TEXT	SEGMENT
_type$ = 8						; size = 4
_xmlSchemaGetPrimitiveType PROC				; COMDAT

; 13469: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaG
$LL2@xmlSchemaG:

; 13470: 
; 13471:     while (type != NULL) {
; 13472: 	/*
; 13473: 	* Note that anySimpleType is actually not a primitive type
; 13474: 	* but we need that here.
; 13475: 	*/
; 13476: 	if ((type->builtInType == XML_SCHEMAS_ANYSIMPLETYPE) ||

	cmp	DWORD PTR [eax+88], 46			; 0000002eH
	je	SHORT $LN1@xmlSchemaG
	test	DWORD PTR [eax+48], 16384		; 00004000H
	jne	SHORT $LN1@xmlSchemaG

; 13477: 	   (type->flags & XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE))
; 13478: 	    return (type);
; 13479: 	type = type->baseType;

	mov	eax, DWORD PTR [eax+64]
	test	eax, eax
	jne	SHORT $LL2@xmlSchemaG
$LN3@xmlSchemaG:

; 13480:     }
; 13481: 
; 13482:     return (NULL);

	xor	eax, eax
$LN1@xmlSchemaG:

; 13483: }

	pop	ebp
	ret	0
_xmlSchemaGetPrimitiveType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIsDerivedFromBuiltInType
_TEXT	SEGMENT
_type$ = 8						; size = 4
_valType$ = 12						; size = 4
_xmlSchemaIsDerivedFromBuiltInType PROC			; COMDAT

; 13403: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _type$[ebp]
	test	esi, esi
	je	SHORT $LN19@xmlSchemaI
	mov	edi, DWORD PTR _valType$[ebp]
	npad	7
$LL10@xmlSchemaI:

; 13404:     if (type == NULL)
; 13405: 	return (0);
; 13406:     if (WXS_IS_COMPLEX(type))

	mov	ecx, DWORD PTR [esi]
	cmp	ecx, 5
	je	SHORT $LN19@xmlSchemaI
	mov	eax, DWORD PTR [esi+88]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN19@xmlSchemaI

; 13408:     if (type->type == XML_SCHEMA_TYPE_BASIC) {

	cmp	ecx, 1
	jne	SHORT $LN5@xmlSchemaI

; 13409: 	if (type->builtInType == valType)

	cmp	eax, edi
	je	SHORT $LN14@xmlSchemaI

; 13411: 	if ((type->builtInType == XML_SCHEMAS_ANYSIMPLETYPE) ||

	cmp	eax, 46					; 0000002eH
	je	SHORT $LN19@xmlSchemaI
$LN5@xmlSchemaI:
	mov	esi, DWORD PTR [esi+28]
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	test	esi, esi
	jne	SHORT $LL10@xmlSchemaI
$LN19@xmlSchemaI:
	pop	edi

; 13407: 	return (0);

	xor	eax, eax

; 13412: 	    (type->builtInType == XML_SCHEMAS_ANYTYPE))
; 13413: 	    return (0);
; 13414: 	return(xmlSchemaIsDerivedFromBuiltInType(type->subtypes, valType));
; 13415:     }
; 13416:     return(xmlSchemaIsDerivedFromBuiltInType(type->subtypes, valType));
; 13417: }

	pop	esi
	pop	ebp
	ret	0
$LN14@xmlSchemaI:
	pop	edi

; 13410: 	    return(1);

	mov	eax, 1

; 13412: 	    (type->builtInType == XML_SCHEMAS_ANYTYPE))
; 13413: 	    return (0);
; 13414: 	return(xmlSchemaIsDerivedFromBuiltInType(type->subtypes, valType));
; 13415:     }
; 13416:     return(xmlSchemaIsDerivedFromBuiltInType(type->subtypes, valType));
; 13417: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaIsDerivedFromBuiltInType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaResolveUnionMemberTypes
_TEXT	SEGMENT
_name$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_nsName$1$ = 12						; size = 4
_type$ = 12						; size = 4
_xmlSchemaResolveUnionMemberTypes PROC			; COMDAT

; 13325: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _type$[ebp]
	xor	edi, edi
	mov	esi, DWORD PTR [ebx+92]
	test	esi, esi
	je	$LN3@xmlSchemaR
$LL2@xmlSchemaR:

; 13343: 	const xmlChar *name, *nsName;
; 13344: 
; 13345: 	name = ((xmlSchemaQNameRefPtr) link->type)->name;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+12]

; 13346: 	nsName = ((xmlSchemaQNameRefPtr) link->type)->targetNamespace;

	mov	eax, DWORD PTR [eax+16]

; 13347: 
; 13348: 	memberType = xmlSchemaGetType(ctxt->schema, name, nsName);

	push	eax
	mov	DWORD PTR _nsName$1$[ebp], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	ecx
	mov	DWORD PTR _name$1$[ebp], ecx
	push	DWORD PTR [eax+36]
	call	_xmlSchemaGetType
	add	esp, 12					; 0000000cH

; 13349: 	if ((memberType == NULL) || (! WXS_IS_SIMPLE(memberType))) {

	test	eax, eax
	je	SHORT $LN9@xmlSchemaR
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	SHORT $LN25@xmlSchemaR
	cmp	ecx, 1
	jne	SHORT $LN9@xmlSchemaR
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	je	SHORT $LN9@xmlSchemaR
$LN25@xmlSchemaR:

; 13363: 	} else {
; 13364: 	    link->type = memberType;

	mov	DWORD PTR [esi+4], eax

; 13365: 	    lastLink = link;

	mov	edi, esi

; 13366: 	    link = link->next;

	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN7@xmlSchemaR
$LN9@xmlSchemaR:

; 13350: 	    xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,

	push	0
	push	4
	push	DWORD PTR _nsName$1$[ebp]
	push	DWORD PTR _name$1$[ebp]
	push	OFFSET ??_C@_0M@OEMIGMAO@memberTypes@
	push	DWORD PTR [ebx+36]
	push	ebx
	push	3004					; 00000bbcH
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPResCompAttrErr
	mov	eax, DWORD PTR [esi]
	add	esp, 36					; 00000024H

; 13351: 		WXS_BASIC_CAST type, type->node, "memberTypes",
; 13352: 		name, nsName, XML_SCHEMA_TYPE_SIMPLE, NULL);
; 13353: 	    /*
; 13354: 	    * Remove the member type link.
; 13355: 	    */
; 13356: 	    if (lastLink == NULL)

	test	edi, edi
	jne	SHORT $LN10@xmlSchemaR

; 13357: 		type->memberTypes = link->next;

	mov	DWORD PTR [ebx+92], eax
	jmp	SHORT $LN11@xmlSchemaR
$LN10@xmlSchemaR:

; 13358: 	    else
; 13359: 		lastLink->next = link->next;

	mov	DWORD PTR [edi], eax
$LN11@xmlSchemaR:

; 13360: 	    newLink = link;
; 13361: 	    link = link->next;
; 13362: 	    xmlFree(newLink);

	push	esi
	mov	esi, DWORD PTR [esi]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlSchemaR:

; 13326: 
; 13327:     xmlSchemaTypeLinkPtr link, lastLink, newLink;
; 13328:     xmlSchemaTypePtr memberType;
; 13329: 
; 13330:     /*
; 13331:     * SPEC (1) "If the <union> alternative is chosen, then [Definition:]
; 13332:     * define the explicit members as the type definitions `resolved`
; 13333:     * to by the items in the `actual value` of the memberTypes [attribute],
; 13334:     * if any, followed by the type definitions corresponding to the
; 13335:     * <simpleType>s among the [children] of <union>, if any."
; 13336:     */
; 13337:     /*
; 13338:     * Resolve references.
; 13339:     */
; 13340:     link = type->memberTypes;
; 13341:     lastLink = NULL;
; 13342:     while (link != NULL) {

	test	esi, esi
	jne	SHORT $LL2@xmlSchemaR
$LN3@xmlSchemaR:

; 13367: 	}
; 13368:     }
; 13369:     /*
; 13370:     * Add local simple types,
; 13371:     */
; 13372:     memberType = type->subtypes;

	mov	esi, DWORD PTR [ebx+28]

; 13373:     while (memberType != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlSchemaR
$LL4@xmlSchemaR:

; 13374: 	link = (xmlSchemaTypeLinkPtr) xmlMalloc(sizeof(xmlSchemaTypeLink));

	push	8
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 13375: 	if (link == NULL) {

	test	eax, eax
	je	SHORT $LN21@xmlSchemaR

; 13378: 	}
; 13379: 	link->type = memberType;

	mov	DWORD PTR [eax+4], esi

; 13380: 	link->next = NULL;

	mov	DWORD PTR [eax], 0

; 13381: 	if (lastLink == NULL)

	test	edi, edi
	jne	SHORT $LN13@xmlSchemaR

; 13382: 	    type->memberTypes = link;

	mov	DWORD PTR [ebx+92], eax
	jmp	SHORT $LN14@xmlSchemaR
$LN13@xmlSchemaR:

; 13383: 	else
; 13384: 	    lastLink->next = link;

	mov	DWORD PTR [edi], eax
$LN14@xmlSchemaR:

; 13385: 	lastLink = link;
; 13386: 	memberType = memberType->next;

	mov	esi, DWORD PTR [esi+4]
	mov	edi, eax
	test	esi, esi
	jne	SHORT $LL4@xmlSchemaR
$LN5@xmlSchemaR:
	pop	edi

; 13387:     }
; 13388:     return (0);
; 13389: }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlSchemaR:

; 1884 :     if (ctxt != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN17@xmlSchemaR

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [eax+20]
$LN17@xmlSchemaR:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BH@ENHIIAOL@allocating?5a?5type?5link@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 13376: 	    xmlSchemaPErrMemory(ctxt, "allocating a type link", NULL);
; 13377: 	    return (-1);

	or	eax, -1
	pop	edi

; 13387:     }
; 13388:     return (0);
; 13389: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaResolveUnionMemberTypes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaResolveElementReferences
_TEXT	SEGMENT
_elemDecl$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_xmlSchemaResolveElementReferences PROC			; COMDAT

; 13245: {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN3@xmlSchemaR

; 13246:     if ((ctxt == NULL) || (elemDecl == NULL) ||

	push	esi
	mov	esi, DWORD PTR _elemDecl$[ebp]
	test	esi, esi
	je	$LN14@xmlSchemaR
	mov	eax, DWORD PTR [esi+48]
	test	eax, 256				; 00000100H
	jne	$LN14@xmlSchemaR

; 13247: 	((elemDecl != NULL) &&
; 13248: 	(elemDecl->flags & XML_SCHEMAS_ELEM_INTERNAL_RESOLVED)))
; 13249:         return;
; 13250:     elemDecl->flags |= XML_SCHEMAS_ELEM_INTERNAL_RESOLVED;

	or	eax, 256				; 00000100H

; 13251: 
; 13252:     if ((elemDecl->subtypes == NULL) && (elemDecl->namedType != NULL)) {

	cmp	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+48], eax
	jne	SHORT $LN6@xmlSchemaR
	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN6@xmlSchemaR

; 13253: 	xmlSchemaTypePtr type;
; 13254: 
; 13255: 	/* (type definition) ... otherwise the type definition `resolved`
; 13256: 	* to by the `actual value` of the type [attribute] ...
; 13257: 	*/
; 13258: 	type = xmlSchemaGetType(ctxt->schema, elemDecl->namedType,

	push	DWORD PTR [esi+60]
	push	eax
	push	DWORD PTR [edi+36]
	call	_xmlSchemaGetType
	add	esp, 12					; 0000000cH

; 13259: 	    elemDecl->namedTypeNs);
; 13260: 	if (type == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlSchemaR

; 13261: 	    xmlSchemaPResCompAttrErr(ctxt,

	push	OFFSET ??_C@_0BA@LIFKLDKP@type?5definition@
	push	1
	push	DWORD PTR [esi+60]
	push	DWORD PTR [esi+56]
	push	OFFSET ??_C@_04GPMDFGEJ@type@
	push	DWORD PTR [esi+36]
	push	esi
	push	3004					; 00000bbcH
	push	edi
	call	_xmlSchemaPResCompAttrErr
	add	esp, 36					; 00000024H

; 13262: 		XML_SCHEMAP_SRC_RESOLVE,
; 13263: 		WXS_BASIC_CAST elemDecl, elemDecl->node,
; 13264: 		"type", elemDecl->namedType, elemDecl->namedTypeNs,
; 13265: 		XML_SCHEMA_TYPE_BASIC, "type definition");
; 13266: 	} else

	jmp	SHORT $LN6@xmlSchemaR
$LN5@xmlSchemaR:

; 13267: 	    elemDecl->subtypes = type;

	mov	DWORD PTR [esi+28], eax
$LN6@xmlSchemaR:

; 13268:     }
; 13269:     if (elemDecl->substGroup != NULL) {

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN10@xmlSchemaR

; 13270: 	xmlSchemaElementPtr substHead;
; 13271: 
; 13272: 	/*
; 13273: 	* FIXME TODO: Do we need a new field in _xmlSchemaElement for
; 13274: 	* substitutionGroup?
; 13275: 	*/
; 13276: 	substHead = xmlSchemaGetElem(ctxt->schema, elemDecl->substGroup,

	push	ebx
	push	DWORD PTR [esi+68]
	push	eax
	push	DWORD PTR [edi+36]
	call	_xmlSchemaGetElem
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 13277: 	    elemDecl->substGroupNs);
; 13278: 	if (substHead == NULL) {

	test	ebx, ebx
	jne	SHORT $LN8@xmlSchemaR

; 13279: 	    xmlSchemaPResCompAttrErr(ctxt,

	push	eax
	push	14					; 0000000eH
	push	DWORD PTR [esi+68]
	push	DWORD PTR [esi+64]
	push	OFFSET ??_C@_0BC@CGDMBFF@substitutionGroup@
	push	eax
	push	esi
	push	3004					; 00000bbcH
	push	edi
	call	_xmlSchemaPResCompAttrErr
	add	esp, 36					; 00000024H

; 13280: 		XML_SCHEMAP_SRC_RESOLVE,
; 13281: 		WXS_BASIC_CAST elemDecl, NULL,
; 13282: 		"substitutionGroup", elemDecl->substGroup,
; 13283: 		elemDecl->substGroupNs, XML_SCHEMA_TYPE_ELEMENT, NULL);
; 13284: 	} else {

	jmp	SHORT $LN15@xmlSchemaR
$LN8@xmlSchemaR:

; 13285: 	    xmlSchemaResolveElementReferences(substHead, ctxt);

	push	edi
	push	ebx
	call	_xmlSchemaResolveElementReferences
	add	esp, 8

; 13286: 	    /*
; 13287: 	    * Set the "substitution group affiliation".
; 13288: 	    * NOTE that now we use the "refDecl" field for this.
; 13289: 	    */
; 13290: 	    WXS_SUBST_HEAD(elemDecl) = substHead;

	mov	DWORD PTR [esi+80], ebx

; 13291: 	    /*
; 13292: 	    * The type definitions is set to:
; 13293: 	    * SPEC "...the {type definition} of the element
; 13294: 	    * declaration `resolved` to by the `actual value`
; 13295: 	    * of the substitutionGroup [attribute], if present"
; 13296: 	    */
; 13297: 	    if (elemDecl->subtypes == NULL)

	cmp	DWORD PTR [esi+28], 0
	jne	SHORT $LN15@xmlSchemaR

; 13298: 		elemDecl->subtypes = substHead->subtypes;

	mov	eax, DWORD PTR [ebx+28]
	mov	DWORD PTR [esi+28], eax
$LN15@xmlSchemaR:
	pop	ebx
$LN10@xmlSchemaR:

; 13299: 	}
; 13300:     }
; 13301:     /*
; 13302:     * SPEC "The definition of anyType serves as the default type definition
; 13303:     * for element declarations whose XML representation does not specify one."
; 13304:     */
; 13305:     if ((elemDecl->subtypes == NULL) &&
; 13306: 	(elemDecl->namedType == NULL) &&

	cmp	DWORD PTR [esi+28], 0
	jne	SHORT $LN14@xmlSchemaR
	cmp	DWORD PTR [esi+56], 0
	jne	SHORT $LN14@xmlSchemaR
	cmp	DWORD PTR [esi+64], 0
	jne	SHORT $LN14@xmlSchemaR

; 13307: 	(elemDecl->substGroup == NULL))
; 13308: 	elemDecl->subtypes = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);

	push	45					; 0000002dH
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	mov	DWORD PTR [esi+28], eax
$LN14@xmlSchemaR:
	pop	esi
$LN3@xmlSchemaR:
	pop	edi

; 13309: }

	pop	ebp
	ret	0
_xmlSchemaResolveElementReferences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaBuildContentModel
_TEXT	SEGMENT
_type$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_xmlSchemaBuildContentModel PROC			; COMDAT

; 13185: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [esi], 5
	jne	$LN3@xmlSchemaB

; 13186:     if ((type->type != XML_SCHEMA_TYPE_COMPLEX) ||
; 13187: 	(type->contModel != NULL) ||

	cmp	DWORD PTR [esi+108], 0
	jne	$LN3@xmlSchemaB
	mov	eax, DWORD PTR [esi+52]
	cmp	eax, 2
	je	SHORT $LN2@xmlSchemaB
	cmp	eax, 3
	jne	$LN3@xmlSchemaB
$LN2@xmlSchemaB:
	push	edi

; 13188: 	((type->contentType != XML_SCHEMA_CONTENT_ELEMENTS) &&
; 13189: 	(type->contentType != XML_SCHEMA_CONTENT_MIXED)))
; 13190: 	return;
; 13191: 
; 13192: #ifdef DEBUG_CONTENT
; 13193:     xmlGenericError(xmlGenericErrorContext,
; 13194:                     "Building content model for %s\n", name);
; 13195: #endif
; 13196:     ctxt->am = NULL;

	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edi+64], 0

; 13197:     ctxt->am = xmlNewAutomata();

	call	_xmlNewAutomata
	mov	DWORD PTR [edi+64], eax

; 13198:     if (ctxt->am == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlSchemaB

; 13199:         xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, DWORD PTR [esi+8]
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0CM@ONMINIGJ@Cannot?5create?5automata?5for?5comp@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 13231: }

	pop	ebp
	ret	0
$LN4@xmlSchemaB:

; 13200: 	    "Cannot create automata for complex type %s\n", type->name);
; 13201:         return;
; 13202:     }
; 13203:     ctxt->state = xmlAutomataGetInitState(ctxt->am);

	push	eax
	call	_xmlAutomataGetInitState
	mov	DWORD PTR [edi+76], eax

; 13204:     /*
; 13205:     * Build the automaton.
; 13206:     */
; 13207:     xmlSchemaBuildAContentModel(ctxt, WXS_TYPE_PARTICLE(type));

	push	DWORD PTR [esi+28]
	push	edi
	call	_xmlSchemaBuildAContentModel

; 13208:     xmlAutomataSetFinalState(ctxt->am, ctxt->state);

	push	DWORD PTR [edi+76]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataSetFinalState

; 13209:     type->contModel = xmlAutomataCompile(ctxt->am);

	push	DWORD PTR [edi+64]
	call	_xmlAutomataCompile
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+108], eax

; 13210:     if (type->contModel == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlSchemaB

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0CE@GNJHIDLA@Failed?5to?5compile?5the?5content?5m@
	push	DWORD PTR [esi+36]
	push	esi
	push	3069					; 00000bfdH
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 2982 : 	str1, NULL, NULL);
; 2983 : }

	jmp	SHORT $LN7@xmlSchemaB
$LN5@xmlSchemaB:

; 13211:         xmlSchemaPCustomErr(ctxt,
; 13212: 	    XML_SCHEMAP_INTERNAL,
; 13213: 	    WXS_BASIC_CAST type, type->node,
; 13214: 	    "Failed to compile the content model", NULL);
; 13215:     } else if (xmlRegexpIsDeterminist(type->contModel) != 1) {

	push	eax
	call	_xmlRegexpIsDeterminist
	add	esp, 4
	cmp	eax, 1
	je	SHORT $LN7@xmlSchemaB

; 13216:         xmlSchemaPCustomErr(ctxt,

	push	0
	push	OFFSET ??_C@_0CF@FHONPKDJ@The?5content?5model?5is?5not?5determ@
	push	DWORD PTR [esi+36]
	push	esi
	push	3070					; 00000bfeH
	push	edi
	call	_xmlSchemaPCustomErr
	add	esp, 24					; 00000018H
$LN7@xmlSchemaB:

; 13217: 	    XML_SCHEMAP_NOT_DETERMINISTIC,
; 13218: 	    /* XML_SCHEMAS_ERR_NOTDETERMINIST, */
; 13219: 	    WXS_BASIC_CAST type, type->node,
; 13220: 	    "The content model is not determinist", NULL);
; 13221:     } else {
; 13222: #ifdef DEBUG_CONTENT_REGEXP
; 13223:         xmlGenericError(xmlGenericErrorContext,
; 13224:                         "Content model of %s:\n", type->name);
; 13225:         xmlRegexpPrint(stderr, type->contModel);
; 13226: #endif
; 13227:     }
; 13228:     ctxt->state = NULL;
; 13229:     xmlFreeAutomata(ctxt->am);

	push	DWORD PTR [edi+64]
	mov	DWORD PTR [edi+76], 0
	call	_xmlFreeAutomata
	add	esp, 4

; 13230:     ctxt->am = NULL;

	mov	DWORD PTR [edi+64], 0
	pop	edi
$LN3@xmlSchemaB:
	pop	esi

; 13231: }

	pop	ebp
	ret	0
_xmlSchemaBuildContentModel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaBuildAContentModel
_TEXT	SEGMENT
_start$1$ = -24						; size = 4
_counter$1$ = -20					; size = 4
tv1257 = -20						; size = 4
_counter$1$ = -20					; size = 4
_start$1$ = -16						; size = 4
_counter$1$ = -16					; size = 4
_ns$2$ = -16						; size = 4
_ns$1$ = -16						; size = 4
_wild$1$ = -16						; size = 4
_tmp$1$ = -12						; size = 4
_base$1$ = -12						; size = 4
_oldstate$4$ = -12					; size = 4
_oldstate$3$ = -12					; size = 4
_oldstate$2$ = -12					; size = 4
_hop$1$ = -12						; size = 4
_end$1$ = -8						; size = 4
_end$1$ = -8						; size = 4
_hop$1$ = -4						; size = 4
_start$1$ = -4						; size = 4
_pctxt$ = 8						; size = 4
_counter$1$ = 12					; size = 4
_particle$ = 12						; size = 4
_xmlSchemaBuildAContentModel PROC			; COMDAT

; 12778: {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _particle$[ebp]
	xor	esi, esi
	test	edi, edi
	jne	SHORT $LN26@xmlSchemaB

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	edi
	push	edi
	push	OFFSET ??_C@_0BB@IKBLLFGH@particle?5is?5NULL@
	push	OFFSET ??_C@_0BM@HHPDPMCK@xmlSchemaBuildAContentModel@
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 12779:     int ret = 0, tmp2;
; 12780: 
; 12781:     if (particle == NULL) {
; 12782: 	PERROR_INT("xmlSchemaBuildAContentModel", "particle is NULL");
; 12783: 	return(1);

	lea	eax, DWORD PTR [esi+1]
	pop	edi

; 13172: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlSchemaB:
	push	ebx

; 12784:     }
; 12785:     if (particle->children == NULL) {

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR _wild$1$[ebp], ebx
	test	ebx, ebx
	jne	SHORT $LN27@xmlSchemaB

; 12786: 	/*
; 12787: 	* Just return in this case. A missing "term" of the particle
; 12788: 	* might arise due to an invalid "term" component.
; 12789: 	*/
; 12790: 	return(1);

	lea	eax, DWORD PTR [ebx+1]
	pop	ebx
	pop	edi

; 13172: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlSchemaB:

; 12791:     }
; 12792: 
; 12793:     switch (particle->children->type) {

	mov	eax, DWORD PTR [ebx]
	add	eax, -2					; fffffffeH
	cmp	eax, 15					; 0000000fH
	ja	$LN80@xmlSchemaB
	movzx	eax, BYTE PTR $LN134@xmlSchemaB[eax]
	jmp	DWORD PTR $LN145@xmlSchemaB[eax*4]
$LN28@xmlSchemaB:

; 12794: 	case XML_SCHEMA_TYPE_ANY: {
; 12795: 	    xmlAutomataStatePtr start, end;
; 12796: 	    xmlSchemaWildcardPtr wild;
; 12797: 	    xmlSchemaWildcardNsPtr ns;
; 12798: 
; 12799: 	    wild = (xmlSchemaWildcardPtr) particle->children;
; 12800: 
; 12801: 	    start = pctxt->state;

	mov	edi, DWORD PTR _pctxt$[ebp]
	mov	eax, DWORD PTR [edi+76]

; 12802: 	    end = xmlAutomataNewState(pctxt->am);

	push	DWORD PTR [edi+64]
	mov	DWORD PTR _start$1$[ebp], eax
	call	_xmlAutomataNewState
	mov	ecx, eax
	add	esp, 4

; 12803: 
; 12804: 	    if (particle->maxOccurs == 1) {

	mov	eax, DWORD PTR _particle$[ebp]
	mov	DWORD PTR _end$1$[ebp], ecx
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, 1
	jne	$LN29@xmlSchemaB

; 12805: 		if (wild->any == 1) {

	cmp	DWORD PTR [ebx+28], edx
	jne	SHORT $LN31@xmlSchemaB

; 12806: 		    /*
; 12807: 		    * We need to add both transitions:
; 12808: 		    *
; 12809: 		    * 1. the {"*", "*"} for elements in a namespace.
; 12810: 		    */
; 12811: 		    pctxt->state =

	push	ebx
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	push	0
	push	DWORD PTR _start$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewTransition2

; 12812: 			xmlAutomataNewTransition2(pctxt->am,
; 12813: 			start, NULL, BAD_CAST "*", BAD_CAST "*", wild);
; 12814: 		    xmlAutomataNewEpsilon(pctxt->am, pctxt->state, end);

	push	DWORD PTR _end$1$[ebp]
	mov	DWORD PTR [edi+76], eax
	push	eax
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewEpsilon

; 12815: 		    /*
; 12816: 		    * 2. the {"*"} for elements in no namespace.
; 12817: 		    */
; 12818: 		    pctxt->state =

	push	ebx
	push	0
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	push	0
	push	DWORD PTR _start$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewTransition2

; 12819: 			xmlAutomataNewTransition2(pctxt->am,
; 12820: 			start, NULL, BAD_CAST "*", NULL, wild);
; 12821: 		    xmlAutomataNewEpsilon(pctxt->am, pctxt->state, end);

	push	DWORD PTR _end$1$[ebp]
	mov	DWORD PTR [edi+76], eax
	push	eax
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewEpsilon
	add	esp, 72					; 00000048H
	jmp	$LN137@xmlSchemaB
$LN31@xmlSchemaB:

; 12822: 
; 12823: 		} else if (wild->nsSet != NULL) {

	mov	eax, DWORD PTR [ebx+32]
	mov	DWORD PTR _ns$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN33@xmlSchemaB
	mov	esi, DWORD PTR _start$1$[ebp]
	npad	7
$LL6@xmlSchemaB:

; 12824: 		    ns = wild->nsSet;
; 12825: 		    do {
; 12826: 			pctxt->state = start;
; 12827: 			pctxt->state = xmlAutomataNewTransition2(pctxt->am,

	push	ebx
	mov	DWORD PTR [edi+76], esi
	push	DWORD PTR [eax+4]
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	push	0
	push	esi
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewTransition2

; 12828: 			    pctxt->state, NULL, BAD_CAST "*", ns->value, wild);
; 12829: 			xmlAutomataNewEpsilon(pctxt->am, pctxt->state, end);

	push	DWORD PTR _end$1$[ebp]
	mov	DWORD PTR [edi+76], eax
	push	eax
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewEpsilon

; 12830: 			ns = ns->next;

	mov	eax, DWORD PTR _ns$1$[ebp]
	add	esp, 36					; 00000024H
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _ns$1$[ebp], eax

; 12831: 		    } while (ns != NULL);

	test	eax, eax
	jne	SHORT $LL6@xmlSchemaB

; 12832: 
; 12833: 		} else if (wild->negNsSet != NULL) {

	xor	esi, esi
	jmp	$LN137@xmlSchemaB
$LN33@xmlSchemaB:
	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	je	$LN30@xmlSchemaB

; 12834: 		    pctxt->state = xmlAutomataNewNegTrans(pctxt->am,

	push	ebx
	push	DWORD PTR [eax+4]
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	push	ecx
	push	DWORD PTR _start$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewNegTrans
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+76], eax

; 12835: 			start, end, BAD_CAST "*", wild->negNsSet->value,
; 12836: 			wild);
; 12837: 		}
; 12838: 	    } else {

	jmp	$LN137@xmlSchemaB
$LN29@xmlSchemaB:

; 12839: 		int counter;
; 12840: 		xmlAutomataStatePtr hop;
; 12841: 		int maxOccurs =

	mov	ecx, 1073741824				; 40000000H
	cmp	edx, 1073741824				; 40000000H
	je	SHORT $LN83@xmlSchemaB
	lea	ecx, DWORD PTR [edx-1]
$LN83@xmlSchemaB:

; 12842: 		    particle->maxOccurs == UNBOUNDED ? UNBOUNDED :
; 12843:                                            particle->maxOccurs - 1;
; 12844: 		int minOccurs =

	mov	edx, DWORD PTR [eax+16]

; 12845: 		    particle->minOccurs < 1 ? 0 : particle->minOccurs - 1;
; 12846: 
; 12847: 		counter = xmlAutomataNewCounter(pctxt->am, minOccurs, maxOccurs);

	xor	eax, eax
	push	ecx
	cmp	edx, 1
	lea	ecx, DWORD PTR [edx-1]
	cmovge	eax, ecx
	push	eax
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewCounter

; 12848: 		hop = xmlAutomataNewState(pctxt->am);

	push	DWORD PTR [edi+64]
	mov	DWORD PTR _counter$1$[ebp], eax
	call	_xmlAutomataNewState
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hop$1$[ebp], eax

; 12849: 		if (wild->any == 1) {

	cmp	DWORD PTR [ebx+28], 1
	jne	SHORT $LN36@xmlSchemaB

; 12850: 		    pctxt->state =

	push	ebx
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	push	0
	push	DWORD PTR _start$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewTransition2

; 12851: 			xmlAutomataNewTransition2(pctxt->am,
; 12852: 			start, NULL, BAD_CAST "*", BAD_CAST "*", wild);
; 12853: 		    xmlAutomataNewEpsilon(pctxt->am, pctxt->state, hop);

	push	DWORD PTR _hop$1$[ebp]
	mov	DWORD PTR [edi+76], eax
	push	eax
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewEpsilon

; 12854: 		    pctxt->state =

	push	ebx
	push	0
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	push	0
	push	DWORD PTR _start$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewTransition2

; 12855: 			xmlAutomataNewTransition2(pctxt->am,
; 12856: 			start, NULL, BAD_CAST "*", NULL, wild);
; 12857: 		    xmlAutomataNewEpsilon(pctxt->am, pctxt->state, hop);

	push	DWORD PTR _hop$1$[ebp]
	mov	DWORD PTR [edi+76], eax
	push	eax
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewEpsilon
	add	esp, 72					; 00000048H
	jmp	SHORT $LN40@xmlSchemaB
$LN36@xmlSchemaB:

; 12858: 		} else if (wild->nsSet != NULL) {

	mov	eax, DWORD PTR [ebx+32]
	mov	DWORD PTR _ns$2$[ebp], eax
	test	eax, eax
	je	SHORT $LN38@xmlSchemaB
	mov	esi, DWORD PTR _start$1$[ebp]
$LL9@xmlSchemaB:

; 12859: 		    ns = wild->nsSet;
; 12860: 		    do {
; 12861: 			pctxt->state =

	push	ebx
	push	DWORD PTR [eax+4]
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	push	0
	push	esi
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewTransition2

; 12862: 			    xmlAutomataNewTransition2(pctxt->am,
; 12863: 				start, NULL, BAD_CAST "*", ns->value, wild);
; 12864: 			xmlAutomataNewEpsilon(pctxt->am, pctxt->state, hop);

	push	DWORD PTR _hop$1$[ebp]
	mov	DWORD PTR [edi+76], eax
	push	eax
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewEpsilon

; 12865: 			ns = ns->next;

	mov	eax, DWORD PTR _ns$2$[ebp]
	add	esp, 36					; 00000024H
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _ns$2$[ebp], eax

; 12866: 		    } while (ns != NULL);

	test	eax, eax
	jne	SHORT $LL9@xmlSchemaB

; 12867: 
; 12868: 		} else if (wild->negNsSet != NULL) {

	xor	esi, esi
	jmp	SHORT $LN40@xmlSchemaB
$LN38@xmlSchemaB:
	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	je	SHORT $LN40@xmlSchemaB

; 12869: 		    pctxt->state = xmlAutomataNewNegTrans(pctxt->am,

	push	ebx
	push	DWORD PTR [eax+4]
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	push	DWORD PTR _hop$1$[ebp]
	push	DWORD PTR _start$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewNegTrans
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+76], eax
$LN40@xmlSchemaB:

; 12870: 			start, hop, BAD_CAST "*", wild->negNsSet->value,
; 12871: 			wild);
; 12872: 		}
; 12873: 		xmlAutomataNewCountedTrans(pctxt->am, hop, start, counter);

	mov	ebx, DWORD PTR _counter$1$[ebp]
	push	ebx
	push	DWORD PTR _start$1$[ebp]
	push	DWORD PTR _hop$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewCountedTrans

; 12874: 		xmlAutomataNewCounterTrans(pctxt->am, hop, end, counter);

	push	ebx
	push	DWORD PTR _end$1$[ebp]
	push	DWORD PTR _hop$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewCounterTrans
	add	esp, 32					; 00000020H
$LN137@xmlSchemaB:

; 12875: 	    }
; 12876: 	    if (particle->minOccurs == 0) {

	mov	ecx, DWORD PTR _end$1$[ebp]
$LN30@xmlSchemaB:
	mov	eax, DWORD PTR _particle$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN41@xmlSchemaB

; 12877: 		xmlAutomataNewEpsilon(pctxt->am, start, end);

	push	ecx
	push	DWORD PTR _start$1$[ebp]
$LN143@xmlSchemaB:

; 13170:     }
; 13171:     return(ret);

	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewEpsilon
	add	esp, 12					; 0000000cH
	mov	esi, 1
$LN41@xmlSchemaB:
	mov	eax, DWORD PTR _end$1$[ebp]
	pop	ebx
	mov	DWORD PTR [edi+76], eax
	mov	eax, esi
	pop	edi

; 13172: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@xmlSchemaB:

; 12878:                 ret = 1;
; 12879: 	    }
; 12880: 	    pctxt->state = end;
; 12881:             break;
; 12882: 	}
; 12883:         case XML_SCHEMA_TYPE_ELEMENT:
; 12884: 	    ret = xmlSchemaBuildContentModelForElement(pctxt, particle);

	push	edi
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaBuildContentModelForElement
	add	esp, 8
	mov	esi, eax
	pop	ebx
	pop	edi

; 13172: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@xmlSchemaB:

; 12885: 	    break;
; 12886:         case XML_SCHEMA_TYPE_SEQUENCE:{
; 12887:             xmlSchemaTreeItemPtr sub;
; 12888: 
; 12889:             ret = 1;
; 12890:             /*
; 12891:              * If max and min occurances are default (1) then
; 12892:              * simply iterate over the particles of the <sequence>.
; 12893:              */
; 12894:             if ((particle->minOccurs == 1) && (particle->maxOccurs == 1)) {

	mov	eax, DWORD PTR [edi+16]
	mov	esi, 1
	mov	DWORD PTR tv1257[ebp], eax
	cmp	eax, esi
	jne	SHORT $LN133@xmlSchemaB
	cmp	DWORD PTR [edi+20], esi
	jne	SHORT $LN133@xmlSchemaB

; 12895:                 sub = particle->children->children;

	mov	edi, DWORD PTR [ebx+12]

; 12896: 
; 12897:                 while (sub != NULL) {

	test	edi, edi
	je	$LN2@xmlSchemaB
	mov	ebx, DWORD PTR _pctxt$[ebp]
$LL10@xmlSchemaB:

; 12898:                     tmp2 = xmlSchemaBuildAContentModel(pctxt,

	push	edi
	push	ebx
	call	_xmlSchemaBuildAContentModel

; 12899:                                         (xmlSchemaParticlePtr) sub);
; 12900:                     if (tmp2 != 1) ret = 0;
; 12901:                     sub = sub->next;

	mov	edi, DWORD PTR [edi+8]
	xor	ecx, ecx
	add	esp, 8
	cmp	eax, 1
	cmovne	esi, ecx
	test	edi, edi
	jne	SHORT $LL10@xmlSchemaB

; 13170:     }
; 13171:     return(ret);

	pop	ebx
	pop	edi
	mov	eax, esi

; 13172: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN133@xmlSchemaB:

; 12902:                 }
; 12903:             } else {
; 12904:                 xmlAutomataStatePtr oldstate = pctxt->state;

	mov	ebx, DWORD PTR _pctxt$[ebp]

; 12905: 
; 12906:                 if (particle->maxOccurs >= UNBOUNDED) {

	mov	edx, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [ebx+76]
	mov	DWORD PTR _oldstate$3$[ebp], ecx
	cmp	edx, 1073741824				; 40000000H
	jl	$LN47@xmlSchemaB

; 12907:                     if (particle->minOccurs > 1) {

	push	0
	push	ecx
	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewEpsilon
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _oldstate$2$[ebp], eax
	mov	DWORD PTR [ebx+76], eax
	cmp	DWORD PTR tv1257[ebp], esi
	jle	$LN49@xmlSchemaB

; 12908:                         xmlAutomataStatePtr tmp;
; 12909:                         int counter;
; 12910: 
; 12911:                         pctxt->state = xmlAutomataNewEpsilon(pctxt->am,
; 12912:                             oldstate, NULL);
; 12913:                         oldstate = pctxt->state;
; 12914: 
; 12915:                         counter = xmlAutomataNewCounter(pctxt->am,

	mov	ecx, DWORD PTR [edi+16]
	push	1073741824				; 40000000H
	dec	ecx
	push	ecx
	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewCounter

; 12916:                             particle->minOccurs - 1, UNBOUNDED);
; 12917: 
; 12918:                         sub = particle->children->children;

	mov	ecx, DWORD PTR [edi+12]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _counter$1$[ebp], eax
	mov	edi, DWORD PTR [ecx+12]

; 12919:                         while (sub != NULL) {

	test	edi, edi
	je	SHORT $LN13@xmlSchemaB
$LL12@xmlSchemaB:

; 12920:                             tmp2 = xmlSchemaBuildAContentModel(pctxt,

	push	edi
	push	ebx
	call	_xmlSchemaBuildAContentModel

; 12921:                                             (xmlSchemaParticlePtr) sub);
; 12922:                             if (tmp2 != 1) ret = 0;
; 12923:                             sub = sub->next;

	mov	edi, DWORD PTR [edi+8]
	xor	ecx, ecx
	add	esp, 8
	cmp	eax, 1
	cmovne	esi, ecx
	test	edi, edi
	jne	SHORT $LL12@xmlSchemaB
	mov	eax, DWORD PTR _counter$1$[ebp]
$LN13@xmlSchemaB:

; 12924:                         }
; 12925:                         tmp = pctxt->state;

	mov	edi, DWORD PTR [ebx+76]

; 12926:                         xmlAutomataNewCountedTrans(pctxt->am, tmp,

	push	eax
	push	DWORD PTR _oldstate$2$[ebp]
	push	edi
	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewCountedTrans

; 12927:                                                    oldstate, counter);
; 12928:                         pctxt->state =

	push	DWORD PTR _counter$1$[ebp]
	push	0
	push	edi
	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewCounterTrans
	add	esp, 32					; 00000020H
	mov	DWORD PTR [ebx+76], eax

; 12929:                             xmlAutomataNewCounterTrans(pctxt->am, tmp,
; 12930:                                                        NULL, counter);
; 12931:                         if (ret == 1)

	cmp	esi, 1
	jne	SHORT $LN2@xmlSchemaB

; 12932:                             xmlAutomataNewEpsilon(pctxt->am,

	push	eax
	push	DWORD PTR _oldstate$2$[ebp]
	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewEpsilon
	add	esp, 12					; 0000000cH

; 13170:     }
; 13171:     return(ret);

	mov	eax, esi
	pop	ebx
	pop	edi

; 13172: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@xmlSchemaB:

; 12933:                                                 oldstate, pctxt->state);
; 12934: 
; 12935:                     } else {
; 12936:                         pctxt->state = xmlAutomataNewEpsilon(pctxt->am,
; 12937:                             oldstate, NULL);
; 12938:                         oldstate = pctxt->state;
; 12939: 
; 12940:                         sub = particle->children->children;

	mov	eax, DWORD PTR [edi+12]
	mov	edi, DWORD PTR [eax+12]

; 12941:                         while (sub != NULL) {

	test	edi, edi
	je	SHORT $LN15@xmlSchemaB
$LL14@xmlSchemaB:

; 12942:                             tmp2 = xmlSchemaBuildAContentModel(pctxt,

	push	edi
	push	ebx
	call	_xmlSchemaBuildAContentModel

; 12943:                                         (xmlSchemaParticlePtr) sub);
; 12944:                             if (tmp2 != 1) ret = 0;
; 12945:                             sub = sub->next;

	mov	edi, DWORD PTR [edi+8]
	xor	ecx, ecx
	add	esp, 8
	cmp	eax, 1
	cmovne	esi, ecx
	test	edi, edi
	jne	SHORT $LL14@xmlSchemaB
$LN15@xmlSchemaB:

; 12946:                         }
; 12947:                         xmlAutomataNewEpsilon(pctxt->am, pctxt->state,

	mov	edi, DWORD PTR _oldstate$2$[ebp]
	push	edi
	push	DWORD PTR [ebx+76]
	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewEpsilon

; 12948:                                               oldstate);
; 12949:                         /*
; 12950:                          * epsilon needed to block previous trans from
; 12951:                          * being allowed to enter back from another
; 12952:                          * construct
; 12953:                          */
; 12954:                         pctxt->state = xmlAutomataNewEpsilon(pctxt->am,

	push	0
	push	DWORD PTR [ebx+76]
	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewEpsilon
	mov	ecx, eax
	add	esp, 24					; 00000018H

; 12955:                                             pctxt->state, NULL);
; 12956:                         if (particle->minOccurs == 0) {

	mov	eax, DWORD PTR _particle$[ebp]
	mov	DWORD PTR [ebx+76], ecx
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN2@xmlSchemaB

; 12957:                             xmlAutomataNewEpsilon(pctxt->am,

	push	ecx
	push	edi
$LN142@xmlSchemaB:

; 13170:     }
; 13171:     return(ret);

	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewEpsilon
	add	esp, 12					; 0000000cH
$LN79@xmlSchemaB:
	mov	esi, 1
$LN2@xmlSchemaB:
	pop	ebx
	pop	edi
	mov	eax, esi

; 13172: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@xmlSchemaB:

; 12958:                                 oldstate, pctxt->state);
; 12959:                             ret = 1;
; 12960:                         }
; 12961:                     }
; 12962:                 } else if ((particle->maxOccurs > 1)
; 12963:                            || (particle->minOccurs > 1)) {

	cmp	edx, 1
	jg	SHORT $LN57@xmlSchemaB
	cmp	eax, 1
	jg	SHORT $LN57@xmlSchemaB

; 12989:                         xmlAutomataNewEpsilon(pctxt->am,
; 12990:                                             oldstate, pctxt->state);
; 12991:                         ret = 1;
; 12992:                     }
; 12993:                 } else {
; 12994:                     sub = particle->children->children;

	mov	eax, DWORD PTR _wild$1$[ebp]
	mov	edi, DWORD PTR [eax+12]

; 12995:                     while (sub != NULL) {

	test	edi, edi
	je	SHORT $LN19@xmlSchemaB
	npad	4
$LL18@xmlSchemaB:

; 12996:                         tmp2 = xmlSchemaBuildAContentModel(pctxt,

	push	edi
	push	ebx
	call	_xmlSchemaBuildAContentModel

; 12997:                                         (xmlSchemaParticlePtr) sub);
; 12998:                         if (tmp2 != 1) ret = 0;
; 12999:                         sub = sub->next;

	mov	edi, DWORD PTR [edi+8]
	xor	ecx, ecx
	add	esp, 8
	cmp	eax, 1
	cmovne	esi, ecx
	test	edi, edi
	jne	SHORT $LL18@xmlSchemaB
	mov	ecx, DWORD PTR [ebx+76]
$LN19@xmlSchemaB:

; 13000:                     }
; 13001: 
; 13002: 		    /*
; 13003: 		     * epsilon needed to block previous trans from
; 13004: 		     * being allowed to enter back from another
; 13005: 		     * construct
; 13006: 		     */
; 13007: 		    pctxt->state = xmlAutomataNewEpsilon(pctxt->am,

	push	0
	push	ecx
	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewEpsilon
	mov	ecx, eax
	add	esp, 12					; 0000000cH

; 13008: 					pctxt->state, NULL);
; 13009: 
; 13010:                     if (particle->minOccurs == 0) {

	mov	eax, DWORD PTR _particle$[ebp]
	mov	DWORD PTR [ebx+76], ecx
	cmp	DWORD PTR [eax+16], 0
$LN141@xmlSchemaB:

; 13170:     }
; 13171:     return(ret);

	jne	SHORT $LN2@xmlSchemaB
$LN60@xmlSchemaB:
	push	ecx
	push	DWORD PTR _oldstate$3$[ebp]
	jmp	SHORT $LN142@xmlSchemaB
$LN57@xmlSchemaB:

; 12964:                     xmlAutomataStatePtr tmp;
; 12965:                     int counter;
; 12966: 
; 12967:                     pctxt->state = xmlAutomataNewEpsilon(pctxt->am,

	push	0
	push	ecx
	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewEpsilon
	mov	DWORD PTR [ebx+76], eax

; 12968:                         oldstate, NULL);
; 12969:                     oldstate = pctxt->state;
; 12970: 
; 12971:                     counter = xmlAutomataNewCounter(pctxt->am,

	mov	ecx, DWORD PTR [edi+20]
	dec	ecx
	mov	DWORD PTR _oldstate$4$[ebp], eax
	push	ecx
	mov	ecx, DWORD PTR [edi+16]
	dec	ecx
	push	ecx
	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewCounter

; 12972:                         particle->minOccurs - 1,
; 12973:                         particle->maxOccurs - 1);
; 12974: 
; 12975:                     sub = particle->children->children;

	mov	ecx, DWORD PTR [edi+12]
	add	esp, 24					; 00000018H
	mov	DWORD PTR _counter$1$[ebp], eax
	mov	edi, DWORD PTR [ecx+12]

; 12976:                     while (sub != NULL) {

	test	edi, edi
	je	SHORT $LN17@xmlSchemaB
$LL16@xmlSchemaB:

; 12977:                         tmp2 = xmlSchemaBuildAContentModel(pctxt,

	push	edi
	push	ebx
	call	_xmlSchemaBuildAContentModel

; 12978:                                         (xmlSchemaParticlePtr) sub);
; 12979:                         if (tmp2 != 1) ret = 0;
; 12980:                         sub = sub->next;

	mov	edi, DWORD PTR [edi+8]
	xor	ecx, ecx
	add	esp, 8
	cmp	eax, 1
	cmovne	esi, ecx
	test	edi, edi
	jne	SHORT $LL16@xmlSchemaB
	mov	eax, DWORD PTR _counter$1$[ebp]
$LN17@xmlSchemaB:

; 12981:                     }
; 12982:                     tmp = pctxt->state;

	mov	edi, DWORD PTR [ebx+76]

; 12983:                     xmlAutomataNewCountedTrans(pctxt->am,

	push	eax
	push	DWORD PTR _oldstate$4$[ebp]
	push	edi
	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewCountedTrans

; 12984:                         tmp, oldstate, counter);
; 12985:                     pctxt->state =

	push	DWORD PTR _counter$1$[ebp]
	push	0
	push	edi
	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewCounterTrans
	mov	ecx, eax
	add	esp, 32					; 00000020H

; 12986:                         xmlAutomataNewCounterTrans(pctxt->am, tmp, NULL,
; 12987:                                                    counter);
; 12988:                     if ((particle->minOccurs == 0) || (ret == 1)) {

	mov	eax, DWORD PTR _particle$[ebp]
	mov	DWORD PTR [ebx+76], ecx
	cmp	DWORD PTR [eax+16], 0
	je	$LN60@xmlSchemaB
	cmp	esi, 1

; 13011:                         xmlAutomataNewEpsilon(pctxt->am, oldstate,
; 13012:                                               pctxt->state);
; 13013:                         ret = 1;
; 13014:                     }
; 13015:                 }
; 13016:             }
; 13017:             break;

	jmp	$LN141@xmlSchemaB
$LN63@xmlSchemaB:

; 13018:         }
; 13019:         case XML_SCHEMA_TYPE_CHOICE:{
; 13020:             xmlSchemaTreeItemPtr sub;
; 13021:             xmlAutomataStatePtr start, end;
; 13022: 
; 13023:             ret = 0;
; 13024:             start = pctxt->state;

	mov	edi, DWORD PTR _pctxt$[ebp]
	xor	esi, esi
	mov	eax, DWORD PTR [edi+76]

; 13025:             end = xmlAutomataNewState(pctxt->am);

	push	DWORD PTR [edi+64]
	mov	DWORD PTR _start$1$[ebp], eax
	call	_xmlAutomataNewState

; 13026: 
; 13027:             /*
; 13028:              * iterate over the subtypes and remerge the end with an
; 13029:              * epsilon transition
; 13030:              */
; 13031:             if (particle->maxOccurs == 1) {

	mov	ebx, DWORD PTR _particle$[ebp]
	add	esp, 4
	mov	DWORD PTR _end$1$[ebp], eax
	mov	ecx, DWORD PTR [ebx+20]
	cmp	ecx, 1
	jne	SHORT $LN64@xmlSchemaB

; 13032:                 sub = particle->children->children;

	mov	ecx, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [ecx+12]

; 13033:                 while (sub != NULL) {

	test	ecx, ecx
	je	$LN68@xmlSchemaB
	mov	ebx, ecx
	npad	4
$LL20@xmlSchemaB:

; 13034:                     pctxt->state = start;

	mov	eax, DWORD PTR _start$1$[ebp]

; 13035:                     tmp2 = xmlSchemaBuildAContentModel(pctxt,

	push	ebx
	push	edi
	mov	DWORD PTR [edi+76], eax
	call	_xmlSchemaBuildAContentModel

; 13036:                                         (xmlSchemaParticlePtr) sub);
; 13037:                     if (tmp2 == 1) ret = 1;
; 13038:                     xmlAutomataNewEpsilon(pctxt->am, pctxt->state, end);

	push	DWORD PTR _end$1$[ebp]
	cmp	eax, 1
	mov	eax, 1
	push	DWORD PTR [edi+76]
	cmove	esi, eax
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewEpsilon

; 13039:                     sub = sub->next;

	mov	ebx, DWORD PTR [ebx+8]
	add	esp, 20					; 00000014H
	test	ebx, ebx
	jne	SHORT $LL20@xmlSchemaB

; 13040:                 }
; 13041:             } else {

	mov	ebx, DWORD PTR _particle$[ebp]
	jmp	$LN135@xmlSchemaB
$LN64@xmlSchemaB:

; 13042:                 int counter;
; 13043:                 xmlAutomataStatePtr hop, base;
; 13044:                 int maxOccurs = particle->maxOccurs == UNBOUNDED ?

	cmp	ecx, 1073741824				; 40000000H
	jne	SHORT $LN86@xmlSchemaB
	jmp	SHORT $LN87@xmlSchemaB
$LN86@xmlSchemaB:
	dec	ecx
$LN87@xmlSchemaB:

; 13045:                     UNBOUNDED : particle->maxOccurs - 1;
; 13046:                 int minOccurs =

	mov	edx, DWORD PTR [ebx+16]

; 13047:                     particle->minOccurs < 1 ? 0 : particle->minOccurs - 1;
; 13048: 
; 13049:                 /*
; 13050:                  * use a counter to keep track of the number of transtions
; 13051:                  * which went through the choice.
; 13052:                  */
; 13053:                 counter =

	xor	eax, eax
	push	ecx
	cmp	edx, 1
	lea	ecx, DWORD PTR [edx-1]
	cmovge	eax, ecx
	push	eax
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewCounter

; 13054:                     xmlAutomataNewCounter(pctxt->am, minOccurs, maxOccurs);
; 13055:                 hop = xmlAutomataNewState(pctxt->am);

	push	DWORD PTR [edi+64]
	mov	DWORD PTR _counter$1$[ebp], eax
	call	_xmlAutomataNewState

; 13056:                 base = xmlAutomataNewState(pctxt->am);

	push	DWORD PTR [edi+64]
	mov	DWORD PTR _hop$1$[ebp], eax
	call	_xmlAutomataNewState

; 13057: 
; 13058:                 sub = particle->children->children;

	mov	ecx, DWORD PTR [ebx+12]
	add	esp, 20					; 00000014H
	mov	DWORD PTR _base$1$[ebp], eax
	mov	ecx, DWORD PTR [ecx+12]

; 13059:                 while (sub != NULL) {

	test	ecx, ecx
	je	SHORT $LN23@xmlSchemaB
	mov	ebx, ecx
$LL22@xmlSchemaB:

; 13060:                     pctxt->state = base;
; 13061:                     tmp2 = xmlSchemaBuildAContentModel(pctxt,

	push	ebx
	push	edi
	mov	DWORD PTR [edi+76], eax
	call	_xmlSchemaBuildAContentModel

; 13062:                                         (xmlSchemaParticlePtr) sub);
; 13063:                     if (tmp2 == 1) ret = 1;
; 13064:                     xmlAutomataNewEpsilon(pctxt->am, pctxt->state, hop);

	push	DWORD PTR _hop$1$[ebp]
	cmp	eax, 1
	mov	eax, 1
	push	DWORD PTR [edi+76]
	cmove	esi, eax
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewEpsilon

; 13065:                     sub = sub->next;

	mov	ebx, DWORD PTR [ebx+8]
	add	esp, 20					; 00000014H
	mov	eax, DWORD PTR _base$1$[ebp]
	test	ebx, ebx
	jne	SHORT $LL22@xmlSchemaB
	mov	ebx, DWORD PTR _particle$[ebp]
$LN23@xmlSchemaB:

; 13066:                 }
; 13067:                 xmlAutomataNewEpsilon(pctxt->am, start, base);

	push	eax
	push	DWORD PTR _start$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewEpsilon

; 13068:                 xmlAutomataNewCountedTrans(pctxt->am, hop, base, counter);

	push	DWORD PTR _counter$1$[ebp]
	push	DWORD PTR _base$1$[ebp]
	push	DWORD PTR _hop$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewCountedTrans

; 13069:                 xmlAutomataNewCounterTrans(pctxt->am, hop, end, counter);

	push	DWORD PTR _counter$1$[ebp]
	push	DWORD PTR _end$1$[ebp]
	push	DWORD PTR _hop$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewCounterTrans
	add	esp, 44					; 0000002cH

; 13070:                 if (ret == 1)

	cmp	esi, 1
	jne	SHORT $LN135@xmlSchemaB

; 13071:                     xmlAutomataNewEpsilon(pctxt->am, base, end);

	push	DWORD PTR _end$1$[ebp]
	push	DWORD PTR _base$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewEpsilon
	add	esp, 12					; 0000000cH
$LN135@xmlSchemaB:

; 13072:             }
; 13073:             if (particle->minOccurs == 0) {

	mov	eax, DWORD PTR _end$1$[ebp]
$LN68@xmlSchemaB:
	cmp	DWORD PTR [ebx+16], 0
	jne	$LN41@xmlSchemaB

; 13074:                 xmlAutomataNewEpsilon(pctxt->am, start, end);

	push	eax
	push	DWORD PTR _start$1$[ebp]

; 13075:                 ret = 1;
; 13076:             }
; 13077:             pctxt->state = end;
; 13078:             break;

	jmp	$LN143@xmlSchemaB
$LN70@xmlSchemaB:

; 13079:         }
; 13080:         case XML_SCHEMA_TYPE_ALL:{
; 13081:             xmlAutomataStatePtr start, tmp;
; 13082:             xmlSchemaParticlePtr sub;
; 13083:             xmlSchemaElementPtr elemDecl;
; 13084: 
; 13085:             ret = 1;
; 13086: 
; 13087:             sub = (xmlSchemaParticlePtr) particle->children->children;

	mov	edi, DWORD PTR [ebx+12]
	mov	esi, 1

; 13088:             if (sub == NULL)

	test	edi, edi
	je	$LN2@xmlSchemaB

; 13089:                 break;
; 13090: 
; 13091:             ret = 0;
; 13092: 
; 13093:             start = pctxt->state;

	mov	ebx, DWORD PTR _pctxt$[ebp]
	xor	esi, esi
	mov	eax, DWORD PTR [ebx+76]

; 13094:             tmp = xmlAutomataNewState(pctxt->am);

	push	DWORD PTR [ebx+64]
	mov	DWORD PTR _start$1$[ebp], eax
	call	_xmlAutomataNewState

; 13095:             xmlAutomataNewEpsilon(pctxt->am, pctxt->state, tmp);

	push	eax
	push	DWORD PTR [ebx+76]
	mov	DWORD PTR _tmp$1$[ebp], eax
	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewEpsilon
	mov	ecx, DWORD PTR _tmp$1$[ebp]
	add	esp, 16					; 00000010H
	npad	5
$LL24@xmlSchemaB:

; 13096:             pctxt->state = tmp;
; 13097:             while (sub != NULL) {
; 13098:                 pctxt->state = tmp;

	mov	DWORD PTR [ebx+76], ecx

; 13099: 
; 13100:                 elemDecl = (xmlSchemaElementPtr) sub->children;

	mov	eax, DWORD PTR [edi+12]

; 13101:                 if (elemDecl == NULL) {

	test	eax, eax
	je	$LN102@xmlSchemaB

; 13103:                         "<element> particle has no term");
; 13104:                     return(ret);
; 13105:                 };
; 13106:                 /*
; 13107:                 * NOTE: The {max occurs} of all the particles in the
; 13108:                 * {particles} of the group must be 0 or 1; this is
; 13109:                 * already ensured during the parse of the content of
; 13110:                 * <all>.
; 13111:                 */
; 13112:                 if (elemDecl->flags & XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD) {

	test	DWORD PTR [eax+48], 131072		; 00020000H
	je	SHORT $LN73@xmlSchemaB

; 13113:                     int counter;
; 13114: 
; 13115:                     /*
; 13116:                      * This is an abstract group, we need to share
; 13117:                      * the same counter for all the element transitions
; 13118:                      * derived from the group
; 13119:                      */
; 13120:                     counter = xmlAutomataNewCounter(pctxt->am,

	push	DWORD PTR [edi+20]
	push	DWORD PTR [edi+16]
	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewCounter

; 13121:                                        sub->minOccurs, sub->maxOccurs);
; 13122:                     xmlSchemaBuildContentModelForSubstGroup(pctxt,

	push	DWORD PTR [ebx+76]
	push	eax
	push	edi
	push	ebx
	call	_xmlSchemaBuildContentModelForSubstGroup
	add	esp, 28					; 0000001cH

; 13123:                                        sub, counter, pctxt->state);
; 13124:                 } else {

	jmp	SHORT $LN138@xmlSchemaB
$LN73@xmlSchemaB:

; 13125:                     if ((sub->minOccurs == 1) &&

	mov	edx, DWORD PTR [edi+16]
	cmp	edx, 1
	jne	SHORT $LN122@xmlSchemaB
	cmp	DWORD PTR [edi+20], edx
	jne	SHORT $LN77@xmlSchemaB

; 13126:                         (sub->maxOccurs == 1)) {
; 13127:                         xmlAutomataNewOnceTrans2(pctxt->am, pctxt->state,

	push	eax
	push	edx
	push	edx
	push	DWORD PTR [eax+52]
	push	DWORD PTR [eax+8]
	push	ecx
	push	ecx
	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewOnceTrans2
	jmp	SHORT $LN139@xmlSchemaB
$LN122@xmlSchemaB:

; 13128:                                                 pctxt->state,
; 13129:                                                 elemDecl->name,
; 13130:                                                 elemDecl->targetNamespace,
; 13131:                                                 1, 1, elemDecl);
; 13132:                     } else if ((sub->minOccurs == 0) &&

	test	edx, edx
	jne	SHORT $LN77@xmlSchemaB
	cmp	DWORD PTR [edi+20], 1
	jne	SHORT $LN77@xmlSchemaB

; 13133:                         (sub->maxOccurs == 1)) {
; 13134: 
; 13135:                         xmlAutomataNewCountTrans2(pctxt->am, pctxt->state,

	push	eax
	push	1
	push	edx
	push	DWORD PTR [eax+52]
	push	DWORD PTR [eax+8]
	push	ecx
	push	ecx
	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewCountTrans2
$LN139@xmlSchemaB:

; 13136:                                                  pctxt->state,
; 13137:                                                  elemDecl->name,
; 13138:                                                  elemDecl->targetNamespace,
; 13139:                                                  0,
; 13140:                                                  1,
; 13141:                                                  elemDecl);
; 13142:                     }
; 13143:                 }
; 13144:                 sub = (xmlSchemaParticlePtr) sub->next;

	add	esp, 32					; 00000020H
$LN138@xmlSchemaB:
	mov	ecx, DWORD PTR _tmp$1$[ebp]
$LN77@xmlSchemaB:
	mov	edi, DWORD PTR [edi+8]
	test	edi, edi
	jne	$LL24@xmlSchemaB

; 13145:             }
; 13146:             pctxt->state =

	push	edi
	push	edi
	push	DWORD PTR [ebx+76]
	push	DWORD PTR [ebx+64]
	call	_xmlAutomataNewAllTrans
	mov	ecx, eax
	add	esp, 16					; 00000010H

; 13147:                 xmlAutomataNewAllTrans(pctxt->am, pctxt->state, NULL, 0);
; 13148:             if (particle->minOccurs == 0) {

	mov	eax, DWORD PTR _particle$[ebp]
	mov	DWORD PTR [ebx+76], ecx
	cmp	DWORD PTR [eax+16], esi
	jne	$LN2@xmlSchemaB

; 13149:                 xmlAutomataNewEpsilon(pctxt->am, start, pctxt->state);

	push	ecx
	push	DWORD PTR _start$1$[ebp]

; 13150:                 ret = 1;
; 13151:             }
; 13152:             break;

	jmp	$LN142@xmlSchemaB
$LN102@xmlSchemaB:

; 13102:                     PERROR_INT("xmlSchemaBuildAContentModel",

	push	OFFSET ??_C@_0BP@LJGCIBKB@?$DMelement?$DO?5particle?5has?5no?5term@
	push	OFFSET ??_C@_0BM@HHPDPMCK@xmlSchemaBuildAContentModel@
	push	ebx
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH

; 13166: 		"xmlSchemaBuildAContentModel",
; 13167: 		"found unexpected term of type '%s' in content model",
; 13168: 		WXS_ITEM_TYPE_NAME(particle->children), NULL);
; 13169:             return(ret);

	xor	eax, eax
	pop	ebx
	pop	edi

; 13172: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN80@xmlSchemaB:

; 13153:         }
; 13154: 	case XML_SCHEMA_TYPE_GROUP:
; 13155: 	    /*
; 13156: 	    * If we hit a model group definition, then this means that
; 13157: 	    * it was empty, thus was not substituted for the containing
; 13158: 	    * model group. Just do nothing in this case.
; 13159: 	    * TODO: But the group should be substituted and not occur at
; 13160: 	    * all in the content model at this point. Fix this.
; 13161: 	    */
; 13162:             ret = 1;
; 13163: 	    break;
; 13164:         default:
; 13165: 	    xmlSchemaInternalErr2(ACTXT_CAST pctxt,

	push	0
	push	ebx
	call	_xmlSchemaGetComponentTypeStr
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DE@JHALJFOD@found?5unexpected?5term?5of?5type?5?8@
	push	OFFSET ??_C@_0BM@HHPDPMCK@xmlSchemaBuildAContentModel@
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 13166: 		"xmlSchemaBuildAContentModel",
; 13167: 		"found unexpected term of type '%s' in content model",
; 13168: 		WXS_ITEM_TYPE_NAME(particle->children), NULL);
; 13169:             return(ret);

	xor	eax, eax
	pop	ebx
	pop	edi

; 13172: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN145@xmlSchemaB:
	DD	$LN28@xmlSchemaB
	DD	$LN43@xmlSchemaB
	DD	$LN63@xmlSchemaB
	DD	$LN70@xmlSchemaB
	DD	$LN42@xmlSchemaB
	DD	$LN79@xmlSchemaB
	DD	$LN80@xmlSchemaB
$LN134@xmlSchemaB:
	DB	0
	DB	6
	DB	6
	DB	6
	DB	1
	DB	2
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	6
	DB	5
_xmlSchemaBuildAContentModel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaBuildContentModelForElement
_TEXT	SEGMENT
_maxOccurs$1$ = -12					; size = 4
tv432 = -8						; size = 4
_start$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
tv435 = 12						; size = 4
_particle$ = 12						; size = 4
_xmlSchemaBuildContentModelForElement PROC		; COMDAT

; 12713: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	ebx
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _particle$[ebp]
	mov	edi, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [edi+48]
	test	eax, 131072				; 00020000H
	je	SHORT $LN2@xmlSchemaB

; 12714:     int ret = 0;
; 12715: 
; 12716:     if (((xmlSchemaElementPtr) particle->children)->flags &
; 12717: 	XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD) {
; 12718: 	/*
; 12719: 	* Substitution groups.
; 12720: 	*/
; 12721: 	ret = xmlSchemaBuildContentModelForSubstGroup(ctxt, particle, -1, NULL);

	push	0
	push	-1
	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaBuildContentModelForSubstGroup
	add	esp, 16					; 00000010H
	pop	edi

; 12760:         }
; 12761:     }
; 12762:     return(ret);
; 12763: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlSchemaB:

; 12722:     } else {
; 12723: 	xmlSchemaElementPtr elemDecl;
; 12724: 	xmlAutomataStatePtr start;
; 12725: 
; 12726: 	elemDecl = (xmlSchemaElementPtr) particle->children;
; 12727: 
; 12728: 	if (elemDecl->flags & XML_SCHEMAS_ELEM_ABSTRACT)

	test	al, 16					; 00000010H
	je	SHORT $LN4@xmlSchemaB

; 12729: 	    return(0);

	pop	edi
	xor	eax, eax

; 12760:         }
; 12761:     }
; 12762:     return(ret);
; 12763: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlSchemaB:

; 12730: 	if (particle->maxOccurs == 1) {

	mov	eax, DWORD PTR [ebx+20]
	push	esi
	cmp	eax, 1
	jne	SHORT $LN5@xmlSchemaB

; 12731: 	    start = ctxt->state;

	mov	eax, DWORD PTR _ctxt$[ebp]

; 12732: 	    ctxt->state = xmlAutomataNewTransition2(ctxt->am, start, NULL,

	push	edi
	push	DWORD PTR [edi+52]
	lea	esi, DWORD PTR [eax+64]
	push	DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR tv435[ebp], ecx
	mov	ecx, DWORD PTR [ecx]
	push	0
	push	ecx
	push	DWORD PTR [esi]
	mov	DWORD PTR _start$1$[ebp], ecx
	call	_xmlAutomataNewTransition2
	add	esp, 24					; 00000018H
	jmp	$LN19@xmlSchemaB
$LN5@xmlSchemaB:

; 12733: 		    elemDecl->name, elemDecl->targetNamespace, elemDecl);
; 12734: 	} else if ((particle->maxOccurs >= UNBOUNDED) &&

	cmp	eax, 1073741824				; 40000000H
	jl	SHORT $LN11@xmlSchemaB
	cmp	DWORD PTR [ebx+16], 2
	jge	SHORT $LN16@xmlSchemaB

; 12735: 	           (particle->minOccurs < 2)) {
; 12736: 	    /* Special case. */
; 12737: 	    start = ctxt->state;

	mov	eax, DWORD PTR _ctxt$[ebp]

; 12738: 	    ctxt->state = xmlAutomataNewTransition2(ctxt->am, start, NULL,

	push	edi
	push	DWORD PTR [edi+52]
	lea	esi, DWORD PTR [eax+64]
	push	DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR tv435[ebp], ecx
	mov	ecx, DWORD PTR [ecx]
	push	0
	push	ecx
	push	DWORD PTR [esi]
	mov	DWORD PTR _start$1$[ebp], ecx
	call	_xmlAutomataNewTransition2
	mov	ecx, DWORD PTR tv435[ebp]

; 12739: 		elemDecl->name, elemDecl->targetNamespace, elemDecl);
; 12740: 	    ctxt->state = xmlAutomataNewTransition2(ctxt->am, ctxt->state, ctxt->state,

	push	edi
	mov	DWORD PTR [ecx], eax
	push	DWORD PTR [edi+52]
	push	DWORD PTR [edi+8]
	push	eax
	push	eax
	push	DWORD PTR [esi]
	call	_xmlAutomataNewTransition2
	add	esp, 48					; 00000030H

; 12741: 		elemDecl->name, elemDecl->targetNamespace, elemDecl);
; 12742: 	} else {

	jmp	$LN19@xmlSchemaB
$LN16@xmlSchemaB:

; 12743: 	    int counter;
; 12744: 	    int maxOccurs = particle->maxOccurs == UNBOUNDED ?

	cmp	eax, 1073741824				; 40000000H
	jne	SHORT $LN11@xmlSchemaB
	mov	DWORD PTR _maxOccurs$1$[ebp], eax
	jmp	SHORT $LN12@xmlSchemaB
$LN11@xmlSchemaB:
	dec	eax
	mov	DWORD PTR _maxOccurs$1$[ebp], eax
$LN12@xmlSchemaB:

; 12745: 			    UNBOUNDED : particle->maxOccurs - 1;
; 12746: 	    int minOccurs = particle->minOccurs < 1 ?
; 12747: 			    0 : particle->minOccurs - 1;
; 12748: 
; 12749: 	    start = xmlAutomataNewEpsilon(ctxt->am, ctxt->state, NULL);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	esi, DWORD PTR [ebx+16]
	lea	ecx, DWORD PTR [eax+76]
	add	eax, 64					; 00000040H
	mov	DWORD PTR tv435[ebp], ecx
	push	0
	push	DWORD PTR [ecx]
	mov	DWORD PTR tv432[ebp], eax
	push	DWORD PTR [eax]
	call	_xmlAutomataNewEpsilon

; 12750: 	    counter = xmlAutomataNewCounter(ctxt->am, minOccurs, maxOccurs);

	push	DWORD PTR _maxOccurs$1$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _start$1$[ebp], eax
	lea	edx, DWORD PTR [esi-1]
	cmp	esi, 1
	cmovge	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR tv432[ebp]
	push	DWORD PTR [ecx]
	call	_xmlAutomataNewCounter

; 12751: 	    ctxt->state = xmlAutomataNewTransition2(ctxt->am, start, NULL,

	push	edi
	push	DWORD PTR [edi+52]
	mov	esi, eax
	push	DWORD PTR [edi+8]
	mov	edi, DWORD PTR tv432[ebp]
	push	0
	push	DWORD PTR _start$1$[ebp]
	push	DWORD PTR [edi]
	call	_xmlAutomataNewTransition2
	mov	ecx, DWORD PTR tv435[ebp]

; 12752: 		elemDecl->name, elemDecl->targetNamespace, elemDecl);
; 12753: 	    xmlAutomataNewCountedTrans(ctxt->am, ctxt->state, start, counter);

	push	esi
	push	DWORD PTR _start$1$[ebp]
	push	eax
	push	DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax
	call	_xmlAutomataNewCountedTrans

; 12754: 	    ctxt->state = xmlAutomataNewCounterTrans(ctxt->am, ctxt->state,

	mov	eax, DWORD PTR tv435[ebp]
	add	esp, 64					; 00000040H
	push	esi
	push	0
	push	DWORD PTR [eax]
	mov	esi, edi
	push	DWORD PTR [esi]
	call	_xmlAutomataNewCounterTrans
	add	esp, 16					; 00000010H
$LN19@xmlSchemaB:

; 12755: 		NULL, counter);
; 12756: 	}
; 12757: 	if (particle->minOccurs == 0) {

	mov	ecx, eax
	mov	eax, DWORD PTR tv435[ebp]
	mov	DWORD PTR [eax], ecx
	cmp	DWORD PTR [ebx+16], 0
	jne	SHORT $LN17@xmlSchemaB

; 12758: 	    xmlAutomataNewEpsilon(ctxt->am, start, ctxt->state);

	push	ecx
	push	DWORD PTR _start$1$[ebp]
	push	DWORD PTR [esi]
	call	_xmlAutomataNewEpsilon
	add	esp, 12					; 0000000cH

; 12759:             ret = 1;

	mov	eax, 1
	pop	esi
	pop	edi

; 12760:         }
; 12761:     }
; 12762:     return(ret);
; 12763: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlSchemaB:
	pop	esi
	pop	edi

; 12755: 		NULL, counter);
; 12756: 	}
; 12757: 	if (particle->minOccurs == 0) {

	xor	eax, eax

; 12760:         }
; 12761:     }
; 12762:     return(ret);
; 12763: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaBuildContentModelForElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaBuildContentModelForSubstGroup
_TEXT	SEGMENT
$T1 = -16						; size = 4
_substGroup$1$ = -12					; size = 4
_counter$2$ = -12					; size = 4
_elemDecl$1$ = -8					; size = 4
_start$1$ = -4						; size = 4
_hop$1$ = 8						; size = 4
_pctxt$ = 8						; size = 4
_particle$ = 12						; size = 4
_counter$ = 16						; size = 4
_tmp$1$ = 20						; size = 4
_end$ = 20						; size = 4
_xmlSchemaBuildContentModelForSubstGroup PROC		; COMDAT

; 12596: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pctxt$[ebp]
	mov	ecx, DWORD PTR _particle$[ebp]
	mov	ebx, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR [edi+76]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR _start$1$[ebp], eax
	lea	eax, DWORD PTR [edi+64]
	mov	DWORD PTR _elemDecl$1$[ebp], ecx
	mov	DWORD PTR $T1[ebp], eax
	test	ebx, ebx
	jne	SHORT $LN42@xmlSchemaB

; 12597:     xmlAutomataStatePtr start, tmp;
; 12598:     xmlSchemaElementPtr elemDecl, member;
; 12599:     xmlSchemaSubstGroupPtr substGroup;
; 12600:     int i;
; 12601:     int ret = 0;
; 12602: 
; 12603:     elemDecl = (xmlSchemaElementPtr) particle->children;
; 12604:     /*
; 12605:     * Wrap the substitution group with a CHOICE.
; 12606:     */
; 12607:     start = pctxt->state;
; 12608:     if (end == NULL)
; 12609: 	end = xmlAutomataNewState(pctxt->am);

	push	DWORD PTR [eax]
	call	_xmlAutomataNewState
	mov	ecx, DWORD PTR _elemDecl$1$[ebp]
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _end$[ebp], ebx
	jmp	SHORT $LN11@xmlSchemaB
$LN42@xmlSchemaB:
	mov	DWORD PTR $T1[ebp], eax
$LN11@xmlSchemaB:

; 5769 :     if (WXS_SUBST_GROUPS(pctxt) == NULL)

	mov	eax, DWORD PTR [edi+28]
	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	je	$LN41@xmlSchemaB

; 5770 : 	return(NULL);
; 5771 :     return(xmlHashLookup2(WXS_SUBST_GROUPS(pctxt),

	push	DWORD PTR [ecx+52]
	push	DWORD PTR [ecx+8]
	push	eax
	call	_xmlHashLookup2
	mov	esi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _substGroup$1$[ebp], esi

; 12610:     substGroup = xmlSchemaSubstGroupGet(pctxt, elemDecl);
; 12611:     if (substGroup == NULL) {

	test	esi, esi
	je	$LN41@xmlSchemaB

; 12618:     }
; 12619:     if (counter >= 0) {

	mov	eax, DWORD PTR _counter$[ebp]
	test	eax, eax
	js	$LN13@xmlSchemaB

; 12620: 	/*
; 12621: 	* NOTE that we put the declaration in, even if it's abstract.
; 12622: 	* However, an error will be raised during *validation* if an element
; 12623: 	* information item shall be validated against an abstract element
; 12624: 	* declaration.
; 12625: 	*/
; 12626: 	tmp = xmlAutomataNewCountedTrans(pctxt->am, start, NULL, counter);

	mov	esi, DWORD PTR $T1[ebp]
	push	eax
	push	0
	push	DWORD PTR _start$1$[ebp]
	push	DWORD PTR [esi]
	call	_xmlAutomataNewCountedTrans

; 12627:         xmlAutomataNewTransition2(pctxt->am, tmp, end,

	mov	ecx, DWORD PTR _elemDecl$1$[ebp]
	push	ecx
	mov	DWORD PTR _tmp$1$[ebp], eax
	push	DWORD PTR [ecx+52]
	push	DWORD PTR [ecx+8]
	push	ebx
	push	eax
	push	DWORD PTR [esi]
	call	_xmlAutomataNewTransition2

; 12628: 	            elemDecl->name, elemDecl->targetNamespace, elemDecl);
; 12629: 	/*
; 12630: 	* Add subst. group members.
; 12631: 	*/
; 12632: 	for (i = 0; i < substGroup->members->nbItems; i++) {

	mov	eax, DWORD PTR _substGroup$1$[ebp]
	xor	esi, esi
	add	esp, 40					; 00000028H
	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+4], esi
	jle	SHORT $LN44@xmlSchemaB
	mov	edi, DWORD PTR _substGroup$1$[ebp]
$LL4@xmlSchemaB:

; 12633: 	    member = (xmlSchemaElementPtr) substGroup->members->items[i];

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+esi*4]

; 12634:             xmlAutomataNewTransition2(pctxt->am, tmp, end,

	push	eax
	push	DWORD PTR [eax+52]
	push	DWORD PTR [eax+8]
	mov	eax, DWORD PTR $T1[ebp]
	push	ebx
	push	DWORD PTR _tmp$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlAutomataNewTransition2
	mov	eax, DWORD PTR [edi+4]
	inc	esi
	add	esp, 24					; 00000018H
	cmp	esi, DWORD PTR [eax+4]
	jl	SHORT $LL4@xmlSchemaB

; 12635: 		               member->name, member->targetNamespace, member);
; 12636: 	}
; 12637:     } else if (particle->maxOccurs == 1) {

	mov	edi, DWORD PTR _pctxt$[ebp]
$LN44@xmlSchemaB:

; 12696:     }
; 12697:     if (particle->minOccurs == 0) {

	mov	esi, DWORD PTR _start$1$[ebp]
$LN16@xmlSchemaB:
	mov	eax, DWORD PTR _particle$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	$LN45@xmlSchemaB

; 12698: 	xmlAutomataNewEpsilon(pctxt->am, start, end);

	mov	eax, DWORD PTR $T1[ebp]
	push	ebx
	push	esi
	push	DWORD PTR [eax]
	call	_xmlAutomataNewEpsilon
	add	esp, 12					; 0000000cH

; 12699:         ret = 1;
; 12700:     }
; 12701:     pctxt->state = end;

	mov	DWORD PTR [edi+76], ebx
	mov	eax, 1
	pop	edi

; 12702:     return(ret);
; 12703: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlSchemaB:

; 12635: 		               member->name, member->targetNamespace, member);
; 12636: 	}
; 12637:     } else if (particle->maxOccurs == 1) {

	mov	ecx, DWORD PTR _particle$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, 1
	jne	SHORT $LN15@xmlSchemaB

; 12638: 	/*
; 12639: 	* NOTE that we put the declaration in, even if it's abstract,
; 12640: 	*/
; 12641: 	xmlAutomataNewEpsilon(pctxt->am,

	mov	ecx, DWORD PTR _elemDecl$1$[ebp]
	push	ebx
	push	ecx
	push	DWORD PTR [ecx+52]
	push	DWORD PTR [ecx+8]
	push	0
	push	DWORD PTR _start$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewTransition2
	add	esp, 24					; 00000018H
	push	eax
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewEpsilon

; 12642: 	    xmlAutomataNewTransition2(pctxt->am,
; 12643: 	    start, NULL,
; 12644: 	    elemDecl->name, elemDecl->targetNamespace, elemDecl), end);
; 12645: 	/*
; 12646: 	* Add subst. group members.
; 12647: 	*/
; 12648: 	for (i = 0; i < substGroup->members->nbItems; i++) {

	mov	eax, DWORD PTR _substGroup$1$[ebp]
	xor	esi, esi
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+4], esi
	jle	SHORT $LN44@xmlSchemaB
	npad	3
$LL7@xmlSchemaB:

; 12649: 	    member = (xmlSchemaElementPtr) substGroup->members->items[i];

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+esi*4]

; 12650: 	    /*
; 12651: 	    * NOTE: This fixes bug #341150. xmlAutomataNewOnceTrans2()
; 12652: 	    *  was incorrectly used instead of xmlAutomataNewTransition2()
; 12653: 	    *  (seems like a copy&paste bug from the XML_SCHEMA_TYPE_ALL
; 12654: 	    *  section in xmlSchemaBuildAContentModel() ).
; 12655: 	    * TODO: Check if xmlAutomataNewOnceTrans2() was instead
; 12656: 	    *  intended for the above "counter" section originally. I.e.,
; 12657: 	    *  check xs:all with subst-groups.
; 12658: 	    *
; 12659: 	    * tmp = xmlAutomataNewOnceTrans2(pctxt->am, start, NULL,
; 12660: 	    *	               member->name, member->targetNamespace,
; 12661: 	    *		       1, 1, member);
; 12662: 	    */
; 12663: 	    tmp = xmlAutomataNewTransition2(pctxt->am, start, NULL,

	push	eax
	push	DWORD PTR [eax+52]
	push	DWORD PTR [eax+8]
	push	0
	push	DWORD PTR _start$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewTransition2

; 12664: 		member->name, member->targetNamespace, member);
; 12665: 	    xmlAutomataNewEpsilon(pctxt->am, tmp, end);

	push	ebx
	push	eax
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewEpsilon
	mov	eax, DWORD PTR _substGroup$1$[ebp]
	inc	esi
	add	esp, 36					; 00000024H
	mov	eax, DWORD PTR [eax+4]
	cmp	esi, DWORD PTR [eax+4]
	jl	SHORT $LL7@xmlSchemaB

; 12666: 	}
; 12667:     } else {

	jmp	$LN44@xmlSchemaB
$LN15@xmlSchemaB:

; 12668: 	xmlAutomataStatePtr hop;
; 12669: 	int maxOccurs = particle->maxOccurs == UNBOUNDED ?

	cmp	eax, 1073741824				; 40000000H
	jne	SHORT $LN19@xmlSchemaB
	jmp	SHORT $LN20@xmlSchemaB
$LN19@xmlSchemaB:
	dec	eax
$LN20@xmlSchemaB:

; 12670: 	    UNBOUNDED : particle->maxOccurs - 1;
; 12671: 	int minOccurs = particle->minOccurs < 1 ? 0 : particle->minOccurs - 1;

	mov	edx, DWORD PTR [ecx+16]

; 12672: 
; 12673: 	counter =

	push	eax
	xor	eax, eax
	cmp	edx, 1
	lea	ecx, DWORD PTR [edx-1]
	cmovge	eax, ecx
	push	eax
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewCounter

; 12674: 	    xmlAutomataNewCounter(pctxt->am, minOccurs,
; 12675: 	    maxOccurs);
; 12676: 	hop = xmlAutomataNewState(pctxt->am);

	push	DWORD PTR [edi+64]
	mov	DWORD PTR _counter$2$[ebp], eax
	call	_xmlAutomataNewState

; 12677: 
; 12678: 	xmlAutomataNewEpsilon(pctxt->am,

	mov	ecx, DWORD PTR _elemDecl$1$[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hop$1$[ebp], eax
	push	eax
	push	ecx
	push	DWORD PTR [ecx+52]
	push	DWORD PTR [ecx+8]
	push	0
	push	DWORD PTR _start$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewTransition2
	add	esp, 24					; 00000018H
	push	eax
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewEpsilon

; 12679: 	    xmlAutomataNewTransition2(pctxt->am,
; 12680: 	    start, NULL,
; 12681: 	    elemDecl->name, elemDecl->targetNamespace, elemDecl),
; 12682: 	    hop);
; 12683: 	/*
; 12684: 	 * Add subst. group members.
; 12685: 	 */
; 12686: 	for (i = 0; i < substGroup->members->nbItems; i++) {

	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [eax+4], 0
	jle	SHORT $LN9@xmlSchemaB
	xor	ebx, ebx
	npad	4
$LL10@xmlSchemaB:

; 12687: 	    member = (xmlSchemaElementPtr) substGroup->members->items[i];

	mov	eax, DWORD PTR [eax]

; 12688: 	    xmlAutomataNewEpsilon(pctxt->am,

	push	DWORD PTR _hop$1$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4]
	push	eax
	push	DWORD PTR [eax+52]
	push	DWORD PTR [eax+8]
	push	0
	push	DWORD PTR _start$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewTransition2
	add	esp, 24					; 00000018H
	push	eax
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewEpsilon
	mov	eax, DWORD PTR [esi+4]
	inc	ebx
	add	esp, 12					; 0000000cH
	cmp	ebx, DWORD PTR [eax+4]
	jl	SHORT $LL10@xmlSchemaB
	mov	ebx, DWORD PTR _end$[ebp]
$LN9@xmlSchemaB:

; 12689: 		xmlAutomataNewTransition2(pctxt->am,
; 12690: 		start, NULL,
; 12691: 		member->name, member->targetNamespace, member),
; 12692: 		hop);
; 12693: 	}
; 12694: 	xmlAutomataNewCountedTrans(pctxt->am, hop, start, counter);

	push	DWORD PTR _counter$2$[ebp]
	mov	esi, DWORD PTR _start$1$[ebp]
	push	esi
	push	DWORD PTR _hop$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewCountedTrans

; 12695: 	xmlAutomataNewCounterTrans(pctxt->am, hop, end, counter);

	push	DWORD PTR _counter$2$[ebp]
	push	ebx
	push	DWORD PTR _hop$1$[ebp]
	push	DWORD PTR [edi+64]
	call	_xmlAutomataNewCounterTrans
	add	esp, 32					; 00000020H
	jmp	$LN16@xmlSchemaB
$LN45@xmlSchemaB:

; 12699:         ret = 1;
; 12700:     }
; 12701:     pctxt->state = end;

	mov	DWORD PTR [edi+76], ebx
	xor	eax, eax
	pop	edi

; 12702:     return(ret);
; 12703: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@xmlSchemaB:

; 12612: 	xmlSchemaPErr(pctxt, WXS_ITEM_NODE(particle),

	mov	ecx, DWORD PTR _elemDecl$1$[ebp]
	push	DWORD PTR _particle$[ebp]
	mov	esi, DWORD PTR [ecx+8]
	call	_xmlSchemaGetComponentNode

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	push	0
	push	esi
	push	OFFSET ??_C@_0HK@IHMHBPHC@Internal?5error?3?5xmlSchemaBuildC@
	push	0
	push	0
	push	0
	push	0
	push	esi
	inc	DWORD PTR [edi+20]
	push	0
	push	0
	push	2
	push	3069					; 00000bfdH
	push	16					; 00000010H
	push	eax
	push	edi
	push	DWORD PTR [edi+4]
	mov	DWORD PTR [edi+16], 3069		; 00000bfdH
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+24]
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH

; 12613: 	    XML_SCHEMAP_INTERNAL,
; 12614: 	    "Internal error: xmlSchemaBuildContentModelForSubstGroup, "
; 12615: 	    "declaration is marked having a subst. group but none "
; 12616: 	    "available.\n", elemDecl->name, NULL);
; 12617: 	return(0);

	xor	eax, eax
	pop	edi

; 12702:     return(ret);
; 12703: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaBuildContentModelForSubstGroup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseComplexContent
_TEXT	SEGMENT
_des$1 = 8						; size = 4
_des$2 = 8						; size = 4
_des$3 = 8						; size = 4
_type$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_hasRestrictionOrExtension$ = 20			; size = 4
_xmlSchemaParseComplexContent PROC			; COMDAT

; 12050: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN5@xmlSchemaP

; 12051:     xmlSchemaTypePtr type;
; 12052:     xmlNodePtr child = NULL;
; 12053:     xmlAttrPtr attr;
; 12054: 
; 12055:     if ((ctxt == NULL) || (schema == NULL) || (node == NULL) ||

	cmp	DWORD PTR _schema$[ebp], 0
	je	$LN5@xmlSchemaP
	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	$LN5@xmlSchemaP
	mov	eax, DWORD PTR _hasRestrictionOrExtension$[ebp]
	test	eax, eax
	je	$LN5@xmlSchemaP

; 12058:     *hasRestrictionOrExtension = 0;

	mov	DWORD PTR [eax], 0

; 12059:     /* Not a component, don't create it. */
; 12060:     type = ctxt->ctxtType;

	mov	eax, DWORD PTR [edi+84]
	push	esi

; 12061:     /*
; 12062:     * Check for illegal attributes.
; 12063:     */
; 12064:     attr = node->properties;

	mov	esi, DWORD PTR [ebx+44]
	mov	DWORD PTR _type$1$[ebp], eax

; 12065:     while (attr != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlSchemaP
	npad	2
$LL2@xmlSchemaP:

; 12066: 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN6@xmlSchemaP

; 12067: 	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP
	push	OFFSET ??_C@_05IPHDHIPP@mixed@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP

; 12068: 		(!xmlStrEqual(attr->name, BAD_CAST "mixed")))
; 12069: 	    {
; 12070: 		xmlSchemaPIllegalAttrErr(ctxt,
; 12071: 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 12072: 	    }

	jmp	SHORT $LN103@xmlSchemaP
$LN6@xmlSchemaP:

; 12073: 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlSchemaP
$LN103@xmlSchemaP:

; 12074: 	    xmlSchemaPIllegalAttrErr(ctxt,
; 12075: 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 12076: 	}
; 12077: 	attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN9@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaP
$LN3@xmlSchemaP:

; 12078:     }
; 12079: 
; 12080:     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	ebx
	push	edi
	call	_xmlSchemaPValAttrID

; 12081: 
; 12082:     /*
; 12083:     * Set the 'mixed' on the complex type ancestor.
; 12084:     */
; 12085:     if (xmlGetBooleanProp(ctxt, node, "mixed", 0))  {

	push	0
	push	OFFSET ??_C@_05IPHDHIPP@mixed@
	push	ebx
	push	edi
	call	_xmlGetBooleanProp
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	SHORT $LN11@xmlSchemaP

; 12086: 	if ((type->flags & XML_SCHEMAS_TYPE_MIXED) == 0)

	mov	ecx, DWORD PTR _type$1$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	test	al, 1
	jne	SHORT $LN11@xmlSchemaP

; 12087: 	    type->flags |= XML_SCHEMAS_TYPE_MIXED;

	or	eax, 1
	mov	DWORD PTR [ecx+48], eax
$LN11@xmlSchemaP:

; 12088:     }
; 12089:     child = node->children;

	mov	esi, DWORD PTR [ebx+12]

; 12090:     if (IS_SCHEMA(child, "annotation")) {

	test	esi, esi
	je	SHORT $LN102@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN12@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlSchemaP

; 12091: 	/*
; 12092: 	* Add the annotation to the complex type ancestor.
; 12093: 	*/
; 12094: 	xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,

	push	1
	push	esi
	push	edi
	call	_xmlSchemaParseAnnotation
	push	eax
	push	DWORD PTR _type$1$[ebp]
	call	_xmlSchemaAddAnnotation

; 12095: 	    xmlSchemaParseAnnotation(ctxt, child, 1));
; 12096:         child = child->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 20					; 00000014H
$LN12@xmlSchemaP:

; 12097:     }
; 12098:     if (child == NULL) {

	test	esi, esi
	jne	$LN101@xmlSchemaP
$LN102@xmlSchemaP:

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	0
	lea	eax, DWORD PTR _des$3[ebp]
	mov	DWORD PTR _des$3[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 1942 :         xmlSchemaPErr(ctxt, node, error, msg, str1, str2);

	push	OFFSET ??_C@_0CJ@BJCOBFBF@?$CIannotation?$DP?0?5?$CIrestriction?5?$HM?5ex@
	push	DWORD PTR _des$3[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3034					; 00000bdaH
	push	ebx
	push	edi
	call	_xmlSchemaPErr

; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$3[ebp]

; 1942 :         xmlSchemaPErr(ctxt, node, error, msg, str1, str2);

	add	esp, 40					; 00000028H

; 3241 :     FREE_AND_NULL(des)

	test	eax, eax
	je	SHORT $LN25@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN25@xmlSchemaP:

; 12099: 	xmlSchemaPContentErr(ctxt,
; 12100: 	    XML_SCHEMAP_S4S_ELEM_MISSING,
; 12101: 	    NULL, node, NULL,
; 12102: 	    NULL, "(annotation?, (restriction | extension))");
; 12103:     }
; 12104:     if (child == NULL) {

	test	esi, esi
	jne	SHORT $LN101@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	esi
	lea	eax, DWORD PTR _des$2[ebp]
	mov	DWORD PTR _des$2[ebp], esi
	push	esi
	push	eax
	call	_xmlSchemaFormatItemForReport

; 1942 :         xmlSchemaPErr(ctxt, node, error, msg, str1, str2);

	push	OFFSET ??_C@_0CJ@BJCOBFBF@?$CIannotation?$DP?0?5?$CIrestriction?5?$HM?5ex@
	push	DWORD PTR _des$2[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3034					; 00000bdaH
	push	ebx
	push	edi
	call	_xmlSchemaPErr

; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$2[ebp]

; 1942 :         xmlSchemaPErr(ctxt, node, error, msg, str1, str2);

	add	esp, 40					; 00000028H

; 3241 :     FREE_AND_NULL(des)

	test	eax, eax
	je	$LN17@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 12105: 	xmlSchemaPContentErr(ctxt,
; 12106: 	    XML_SCHEMAP_S4S_ELEM_MISSING,
; 12107: 	    NULL, node, NULL,
; 12108: 	    NULL, "(annotation?, (restriction | extension))");
; 12109:     }
; 12110:     if (IS_SCHEMA(child, "restriction")) {

	jmp	$LN17@xmlSchemaP
$LN101@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN17@xmlSchemaP
	push	OFFSET ??_C@_0M@FBFLGGFO@restriction@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlSchemaP

; 12111:         xmlSchemaParseRestriction(ctxt, schema, child,

	mov	eax, DWORD PTR _schema$[ebp]
	push	10					; 0000000aH
	push	esi
	push	eax
	push	edi
	call	_xmlSchemaParseRestriction

; 12112: 	    XML_SCHEMA_TYPE_COMPLEX_CONTENT);
; 12113: 	(*hasRestrictionOrExtension) = 1;
; 12114:         child = child->next;

	jmp	SHORT $LN105@xmlSchemaP
$LN15@xmlSchemaP:

; 12115:     } else if (IS_SCHEMA(child, "extension")) {

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN17@xmlSchemaP
	push	OFFSET ??_C@_09ODADEDNA@extension@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlSchemaP

; 12116:         xmlSchemaParseExtension(ctxt, schema, child,

	mov	eax, DWORD PTR _schema$[ebp]
	push	10					; 0000000aH
	push	esi
	push	eax
	push	edi
	call	_xmlSchemaParseExtension
$LN105@xmlSchemaP:

; 12117: 	    XML_SCHEMA_TYPE_COMPLEX_CONTENT);
; 12118: 	(*hasRestrictionOrExtension) = 1;
; 12119:         child = child->next;
; 12120:     }
; 12121:     if (child != NULL) {

	mov	eax, DWORD PTR _hasRestrictionOrExtension$[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [eax], 1
	mov	esi, DWORD PTR [esi+24]
$LN17@xmlSchemaP:
	test	esi, esi
	je	SHORT $LN75@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	0
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0CJ@BJCOBFBF@?$CIannotation?$DP?0?5?$CIrestriction?5?$HM?5ex@
	push	DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	edi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN75@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN75@xmlSchemaP:

; 12122: 	xmlSchemaPContentErr(ctxt,
; 12123: 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 12124: 	    NULL, node, child,
; 12125: 	    NULL, "(annotation?, (restriction | extension))");
; 12126:     }
; 12127:     return (0);

	pop	esi
	pop	edi
	xor	eax, eax

; 12128: }

	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlSchemaP:
	pop	edi

; 12056: 	(hasRestrictionOrExtension == NULL))
; 12057:         return (-1);

	or	eax, -1

; 12128: }

	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaParseComplexContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseSimpleContent
_TEXT	SEGMENT
_des$1 = 8						; size = 4
_des$2 = 8						; size = 4
_des$3 = 8						; size = 4
_type$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_hasRestrictionOrExtension$ = 20			; size = 4
_xmlSchemaParseSimpleContent PROC			; COMDAT

; 11960: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN5@xmlSchemaP

; 11961:     xmlSchemaTypePtr type;
; 11962:     xmlNodePtr child = NULL;
; 11963:     xmlAttrPtr attr;
; 11964: 
; 11965:     if ((ctxt == NULL) || (schema == NULL) || (node == NULL) ||

	cmp	DWORD PTR _schema$[ebp], 0
	je	$LN5@xmlSchemaP
	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	$LN5@xmlSchemaP
	mov	eax, DWORD PTR _hasRestrictionOrExtension$[ebp]
	test	eax, eax
	je	$LN5@xmlSchemaP

; 11968:     *hasRestrictionOrExtension = 0;

	mov	DWORD PTR [eax], 0

; 11969:     /* Not a component, don't create it. */
; 11970:     type = ctxt->ctxtType;

	mov	eax, DWORD PTR [edi+84]
	push	esi
	mov	DWORD PTR _type$1$[ebp], eax

; 11971:     type->contentType = XML_SCHEMA_CONTENT_SIMPLE;

	mov	DWORD PTR [eax+52], 4

; 11972:     /*
; 11973:     * Check for illegal attributes.
; 11974:     */
; 11975:     attr = node->properties;

	mov	esi, DWORD PTR [ebx+44]

; 11976:     while (attr != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlSchemaP
$LL2@xmlSchemaP:

; 11977: 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN6@xmlSchemaP

; 11978: 	    if ((!xmlStrEqual(attr->name, BAD_CAST "id"))) {

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP

; 11979: 		xmlSchemaPIllegalAttrErr(ctxt,
; 11980: 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 11981: 	    }

	jmp	SHORT $LN101@xmlSchemaP
$LN6@xmlSchemaP:

; 11982: 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlSchemaP
$LN101@xmlSchemaP:

; 11983: 	    xmlSchemaPIllegalAttrErr(ctxt,
; 11984: 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 11985: 	}
; 11986: 	attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN9@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaP
$LN3@xmlSchemaP:

; 11987:     }
; 11988: 
; 11989:     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	ebx
	push	edi
	call	_xmlSchemaPValAttrID

; 11990: 
; 11991:     /*
; 11992:     * And now for the children...
; 11993:     */
; 11994:     child = node->children;

	mov	esi, DWORD PTR [ebx+12]
	add	esp, 12					; 0000000cH

; 11995:     if (IS_SCHEMA(child, "annotation")) {

	test	esi, esi
	je	SHORT $LN100@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN10@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlSchemaP

; 11996: 	/*
; 11997: 	* Add the annotation to the complex type ancestor.
; 11998: 	*/
; 11999: 	xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,

	push	1
	push	esi
	push	edi
	call	_xmlSchemaParseAnnotation
	push	eax
	push	DWORD PTR _type$1$[ebp]
	call	_xmlSchemaAddAnnotation

; 12000: 	    xmlSchemaParseAnnotation(ctxt, child, 1));
; 12001:         child = child->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 20					; 00000014H
$LN10@xmlSchemaP:

; 12002:     }
; 12003:     if (child == NULL) {

	test	esi, esi
	jne	$LN99@xmlSchemaP
$LN100@xmlSchemaP:

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	0
	lea	eax, DWORD PTR _des$3[ebp]
	mov	DWORD PTR _des$3[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 1942 :         xmlSchemaPErr(ctxt, node, error, msg, str1, str2);

	push	OFFSET ??_C@_0CJ@BJCOBFBF@?$CIannotation?$DP?0?5?$CIrestriction?5?$HM?5ex@
	push	DWORD PTR _des$3[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3034					; 00000bdaH
	push	ebx
	push	edi
	call	_xmlSchemaPErr

; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$3[ebp]

; 1942 :         xmlSchemaPErr(ctxt, node, error, msg, str1, str2);

	add	esp, 40					; 00000028H

; 3241 :     FREE_AND_NULL(des)

	test	eax, eax
	je	SHORT $LN23@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN23@xmlSchemaP:

; 12004: 	xmlSchemaPContentErr(ctxt,
; 12005: 	    XML_SCHEMAP_S4S_ELEM_MISSING,
; 12006: 	    NULL, node, NULL, NULL,
; 12007: 	    "(annotation?, (restriction | extension))");
; 12008:     }
; 12009:     if (child == NULL) {

	test	esi, esi
	jne	SHORT $LN99@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	esi
	lea	eax, DWORD PTR _des$2[ebp]
	mov	DWORD PTR _des$2[ebp], esi
	push	esi
	push	eax
	call	_xmlSchemaFormatItemForReport

; 1942 :         xmlSchemaPErr(ctxt, node, error, msg, str1, str2);

	push	OFFSET ??_C@_0CJ@BJCOBFBF@?$CIannotation?$DP?0?5?$CIrestriction?5?$HM?5ex@
	push	DWORD PTR _des$2[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3034					; 00000bdaH
	push	ebx
	push	edi
	call	_xmlSchemaPErr

; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$2[ebp]

; 1942 :         xmlSchemaPErr(ctxt, node, error, msg, str1, str2);

	add	esp, 40					; 00000028H

; 3241 :     FREE_AND_NULL(des)

	test	eax, eax
	je	$LN15@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 12010: 	xmlSchemaPContentErr(ctxt,
; 12011: 	    XML_SCHEMAP_S4S_ELEM_MISSING,
; 12012: 	    NULL, node, NULL, NULL,
; 12013: 	    "(annotation?, (restriction | extension))");
; 12014:     }
; 12015:     if (IS_SCHEMA(child, "restriction")) {

	jmp	$LN15@xmlSchemaP
$LN99@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN15@xmlSchemaP
	push	OFFSET ??_C@_0M@FBFLGGFO@restriction@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlSchemaP

; 12016:         xmlSchemaParseRestriction(ctxt, schema, child,

	mov	eax, DWORD PTR _schema$[ebp]
	push	9
	push	esi
	push	eax
	push	edi
	call	_xmlSchemaParseRestriction

; 12017: 	    XML_SCHEMA_TYPE_SIMPLE_CONTENT);
; 12018: 	(*hasRestrictionOrExtension) = 1;
; 12019:         child = child->next;

	jmp	SHORT $LN103@xmlSchemaP
$LN13@xmlSchemaP:

; 12020:     } else if (IS_SCHEMA(child, "extension")) {

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN15@xmlSchemaP
	push	OFFSET ??_C@_09ODADEDNA@extension@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlSchemaP

; 12021:         xmlSchemaParseExtension(ctxt, schema, child,

	mov	eax, DWORD PTR _schema$[ebp]
	push	9
	push	esi
	push	eax
	push	edi
	call	_xmlSchemaParseExtension
$LN103@xmlSchemaP:

; 12022: 	    XML_SCHEMA_TYPE_SIMPLE_CONTENT);
; 12023: 	(*hasRestrictionOrExtension) = 1;
; 12024:         child = child->next;
; 12025:     }
; 12026:     if (child != NULL) {

	mov	eax, DWORD PTR _hasRestrictionOrExtension$[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [eax], 1
	mov	esi, DWORD PTR [esi+24]
$LN15@xmlSchemaP:
	test	esi, esi
	je	SHORT $LN73@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	0
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0CJ@BJCOBFBF@?$CIannotation?$DP?0?5?$CIrestriction?5?$HM?5ex@
	push	DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	edi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN73@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN73@xmlSchemaP:

; 12027: 	xmlSchemaPContentErr(ctxt,
; 12028: 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 12029: 	    NULL, node, child, NULL,
; 12030: 	    "(annotation?, (restriction | extension))");
; 12031:     }
; 12032:     return (0);

	pop	esi
	pop	edi
	xor	eax, eax

; 12033: }

	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlSchemaP:
	pop	edi

; 11966: 	(hasRestrictionOrExtension == NULL))
; 11967:         return (-1);

	or	eax, -1

; 12033: }

	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaParseSimpleContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseExtension
_TEXT	SEGMENT
_des$1 = -8						; size = 4
_child$ = -8						; size = 4
$T2 = -4						; size = 4
_des$3 = 8						; size = 4
_type$1$ = 8						; size = 4
_des$4 = 8						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_parentType$ = 20					; size = 4
_xmlSchemaParseExtension PROC				; COMDAT

; 11824: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN5@xmlSchemaP

; 11825:     xmlSchemaTypePtr type;
; 11826:     xmlNodePtr child = NULL;
; 11827:     xmlAttrPtr attr;
; 11828: 
; 11829:     if ((ctxt == NULL) || (schema == NULL) || (node == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	$LN5@xmlSchemaP
	push	ebx
	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	$LN109@xmlSchemaP

; 11831:     /* Not a component, don't create it. */
; 11832:     type = ctxt->ctxtType;

	mov	eax, DWORD PTR [edi+84]
	push	esi
	mov	DWORD PTR _type$1$[ebp], eax

; 11833:     type->flags |= XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION;

	or	DWORD PTR [eax+48], 2

; 11834: 
; 11835:     /*
; 11836:     * Check for illegal attributes.
; 11837:     */
; 11838:     attr = node->properties;

	mov	esi, DWORD PTR [ebx+44]

; 11839:     while (attr != NULL) {

	test	esi, esi
	je	$LN104@xmlSchemaP
$LL2@xmlSchemaP:

; 11840: 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN6@xmlSchemaP

; 11841: 	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP

; 11842: 		(!xmlStrEqual(attr->name, BAD_CAST "base"))) {
; 11843: 		xmlSchemaPIllegalAttrErr(ctxt,
; 11844: 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 11845: 	    }

	jmp	SHORT $LN112@xmlSchemaP
$LN6@xmlSchemaP:

; 11846: 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlSchemaP
$LN112@xmlSchemaP:

; 11847: 	    xmlSchemaPIllegalAttrErr(ctxt,
; 11848: 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 11849: 	}
; 11850: 	attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN9@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaP
	mov	esi, DWORD PTR [ebx+44]

; 4667 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN104@xmlSchemaP
	npad	3
$LL31@xmlSchemaP:

; 4668 :         if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN35@xmlSchemaP
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@xmlSchemaP
$LN35@xmlSchemaP:

; 4669 : 	    return(prop);
; 4670 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL31@xmlSchemaP

; 3242 : }
; 3243 : 
; 3244 : /************************************************************************
; 3245 :  *									*
; 3246 :  *			Streamable error functions                      *
; 3247 :  *									*
; 3248 :  ************************************************************************/
; 3249 : 
; 3250 : 
; 3251 : 
; 3252 : 
; 3253 : /************************************************************************
; 3254 :  *									*
; 3255 :  *			Validation helper functions			*
; 3256 :  *									*
; 3257 :  ************************************************************************/
; 3258 : 
; 3259 : 
; 3260 : /************************************************************************
; 3261 :  *									*
; 3262 :  *			Allocation functions				*
; 3263 :  *									*
; 3264 :  ************************************************************************/
; 3265 : 
; 3266 : /**
; 3267 :  * xmlSchemaNewSchemaForParserCtxt:
; 3268 :  * @ctxt:  a schema validation context
; 3269 :  *
; 3270 :  * Allocate a new Schema structure.
; 3271 :  *
; 3272 :  * Returns the newly allocated structure or NULL in case or error
; 3273 :  */
; 3274 : static xmlSchemaPtr
; 3275 : xmlSchemaNewSchema(xmlSchemaParserCtxtPtr ctxt)
; 3276 : {
; 3277 :     xmlSchemaPtr ret;
; 3278 : 
; 3279 :     ret = (xmlSchemaPtr) xmlMalloc(sizeof(xmlSchema));
; 3280 :     if (ret == NULL) {
; 3281 :         xmlSchemaPErrMemory(ctxt, "allocating schema", NULL);
; 3282 :         return (NULL);
; 3283 :     }
; 3284 :     memset(ret, 0, sizeof(xmlSchema));
; 3285 :     ret->dict = ctxt->dict;
; 3286 :     xmlDictReference(ret->dict);
; 3287 : 
; 3288 :     return (ret);
; 3289 : }
; 3290 : 
; 3291 : /**
; 3292 :  * xmlSchemaNewFacet:
; 3293 :  *
; 3294 :  * Allocate a new Facet structure.
; 3295 :  *
; 3296 :  * Returns the newly allocated structure or NULL in case or error
; 3297 :  */
; 3298 : xmlSchemaFacetPtr
; 3299 : xmlSchemaNewFacet(void)
; 3300 : {
; 3301 :     xmlSchemaFacetPtr ret;
; 3302 : 
; 3303 :     ret = (xmlSchemaFacetPtr) xmlMalloc(sizeof(xmlSchemaFacet));
; 3304 :     if (ret == NULL) {
; 3305 :         return (NULL);
; 3306 :     }
; 3307 :     memset(ret, 0, sizeof(xmlSchemaFacet));
; 3308 : 
; 3309 :     return (ret);
; 3310 : }
; 3311 : 
; 3312 : /**
; 3313 :  * xmlSchemaNewAnnot:
; 3314 :  * @ctxt:  a schema validation context
; 3315 :  * @node:  a node
; 3316 :  *
; 3317 :  * Allocate a new annotation structure.
; 3318 :  *
; 3319 :  * Returns the newly allocated structure or NULL in case or error
; 3320 :  */
; 3321 : static xmlSchemaAnnotPtr
; 3322 : xmlSchemaNewAnnot(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node)
; 3323 : {
; 3324 :     xmlSchemaAnnotPtr ret;
; 3325 : 
; 3326 :     ret = (xmlSchemaAnnotPtr) xmlMalloc(sizeof(xmlSchemaAnnot));
; 3327 :     if (ret == NULL) {
; 3328 :         xmlSchemaPErrMemory(ctxt, "allocating annotation", node);
; 3329 :         return (NULL);
; 3330 :     }
; 3331 :     memset(ret, 0, sizeof(xmlSchemaAnnot));
; 3332 :     ret->content = node;
; 3333 :     return (ret);
; 3334 : }
; 3335 : 
; 3336 : static xmlSchemaItemListPtr
; 3337 : xmlSchemaItemListCreate(void)
; 3338 : {
; 3339 :     xmlSchemaItemListPtr ret;
; 3340 : 
; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));
; 3342 :     if (ret == NULL) {
; 3343 : 	xmlSchemaPErrMemory(NULL,
; 3344 : 	    "allocating an item list structure", NULL);
; 3345 : 	return (NULL);
; 3346 :     }
; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));
; 3348 :     return (ret);
; 3349 : }
; 3350 : 
; 3351 : static void
; 3352 : xmlSchemaItemListClear(xmlSchemaItemListPtr list)
; 3353 : {
; 3354 :     if (list->items != NULL) {
; 3355 : 	xmlFree(list->items);
; 3356 : 	list->items = NULL;
; 3357 :     }
; 3358 :     list->nbItems = 0;
; 3359 :     list->sizeItems = 0;
; 3360 : }
; 3361 : 
; 3362 : static int
; 3363 : xmlSchemaItemListAdd(xmlSchemaItemListPtr list, void *item)
; 3364 : {
; 3365 :     if (list->items == NULL) {
; 3366 : 	list->items = (void **) xmlMalloc(
; 3367 : 	    20 * sizeof(void *));
; 3368 : 	if (list->items == NULL) {
; 3369 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3370 : 	    return(-1);
; 3371 : 	}
; 3372 : 	list->sizeItems = 20;
; 3373 :     } else if (list->sizeItems <= list->nbItems) {
; 3374 : 	list->sizeItems *= 2;
; 3375 : 	list->items = (void **) xmlRealloc(list->items,
; 3376 : 	    list->sizeItems * sizeof(void *));
; 3377 : 	if (list->items == NULL) {
; 3378 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3379 : 	    list->sizeItems = 0;
; 3380 : 	    return(-1);
; 3381 : 	}
; 3382 :     }
; 3383 :     list->items[list->nbItems++] = item;
; 3384 :     return(0);
; 3385 : }
; 3386 : 
; 3387 : static int
; 3388 : xmlSchemaItemListAddSize(xmlSchemaItemListPtr list,
; 3389 : 			 int initialSize,
; 3390 : 			 void *item)
; 3391 : {
; 3392 :     if (list->items == NULL) {
; 3393 : 	if (initialSize <= 0)
; 3394 : 	    initialSize = 1;
; 3395 : 	list->items = (void **) xmlMalloc(
; 3396 : 	    initialSize * sizeof(void *));
; 3397 : 	if (list->items == NULL) {
; 3398 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3399 : 	    return(-1);
; 3400 : 	}
; 3401 : 	list->sizeItems = initialSize;
; 3402 :     } else if (list->sizeItems <= list->nbItems) {
; 3403 : 	list->sizeItems *= 2;
; 3404 : 	list->items = (void **) xmlRealloc(list->items,
; 3405 : 	    list->sizeItems * sizeof(void *));
; 3406 : 	if (list->items == NULL) {
; 3407 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3408 : 	    list->sizeItems = 0;
; 3409 : 	    return(-1);
; 3410 : 	}
; 3411 :     }
; 3412 :     list->items[list->nbItems++] = item;
; 3413 :     return(0);
; 3414 : }
; 3415 : 
; 3416 : static int
; 3417 : xmlSchemaItemListInsert(xmlSchemaItemListPtr list, void *item, int idx)
; 3418 : {
; 3419 :     if (list->items == NULL) {
; 3420 : 	list->items = (void **) xmlMalloc(
; 3421 : 	    20 * sizeof(void *));
; 3422 : 	if (list->items == NULL) {
; 3423 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3424 : 	    return(-1);
; 3425 : 	}
; 3426 : 	list->sizeItems = 20;
; 3427 :     } else if (list->sizeItems <= list->nbItems) {
; 3428 : 	list->sizeItems *= 2;
; 3429 : 	list->items = (void **) xmlRealloc(list->items,
; 3430 : 	    list->sizeItems * sizeof(void *));
; 3431 : 	if (list->items == NULL) {
; 3432 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3433 : 	    list->sizeItems = 0;
; 3434 : 	    return(-1);
; 3435 : 	}
; 3436 :     }
; 3437 :     /*
; 3438 :     * Just append if the index is greater/equal than the item count.
; 3439 :     */
; 3440 :     if (idx >= list->nbItems) {
; 3441 : 	list->items[list->nbItems++] = item;
; 3442 :     } else {
; 3443 : 	int i;
; 3444 : 	for (i = list->nbItems; i > idx; i--)
; 3445 : 	    list->items[i] = list->items[i-1];
; 3446 : 	list->items[idx] = item;
; 3447 : 	list->nbItems++;
; 3448 :     }
; 3449 :     return(0);
; 3450 : }
; 3451 : 
; 3452 : #if 0 /* enable if ever needed */
; 3453 : static int
; 3454 : xmlSchemaItemListInsertSize(xmlSchemaItemListPtr list,
; 3455 : 			    int initialSize,
; 3456 : 			    void *item,
; 3457 : 			    int idx)
; 3458 : {
; 3459 :     if (list->items == NULL) {
; 3460 : 	if (initialSize <= 0)
; 3461 : 	    initialSize = 1;
; 3462 : 	list->items = (void **) xmlMalloc(
; 3463 : 	    initialSize * sizeof(void *));
; 3464 : 	if (list->items == NULL) {
; 3465 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3466 : 	    return(-1);
; 3467 : 	}
; 3468 : 	list->sizeItems = initialSize;
; 3469 :     } else if (list->sizeItems <= list->nbItems) {
; 3470 : 	list->sizeItems *= 2;
; 3471 : 	list->items = (void **) xmlRealloc(list->items,
; 3472 : 	    list->sizeItems * sizeof(void *));
; 3473 : 	if (list->items == NULL) {
; 3474 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3475 : 	    list->sizeItems = 0;
; 3476 : 	    return(-1);
; 3477 : 	}
; 3478 :     }
; 3479 :     /*
; 3480 :     * Just append if the index is greater/equal than the item count.
; 3481 :     */
; 3482 :     if (idx >= list->nbItems) {
; 3483 : 	list->items[list->nbItems++] = item;
; 3484 :     } else {
; 3485 : 	int i;
; 3486 : 	for (i = list->nbItems; i > idx; i--)
; 3487 : 	    list->items[i] = list->items[i-1];
; 3488 : 	list->items[idx] = item;
; 3489 : 	list->nbItems++;
; 3490 :     }
; 3491 :     return(0);
; 3492 : }
; 3493 : #endif
; 3494 : 
; 3495 : static int
; 3496 : xmlSchemaItemListRemove(xmlSchemaItemListPtr list, int idx)
; 3497 : {
; 3498 :     int i;
; 3499 :     if ((list->items == NULL) || (idx >= list->nbItems)) {
; 3500 : 	xmlSchemaPSimpleErr("Internal error: xmlSchemaItemListRemove, "
; 3501 : 	    "index error.\n");
; 3502 : 	return(-1);
; 3503 :     }
; 3504 : 
; 3505 :     if (list->nbItems == 1) {
; 3506 : 	/* TODO: Really free the list? */
; 3507 : 	xmlFree(list->items);
; 3508 : 	list->items = NULL;
; 3509 : 	list->nbItems = 0;
; 3510 : 	list->sizeItems = 0;
; 3511 :     } else if (list->nbItems -1 == idx) {
; 3512 : 	list->nbItems--;
; 3513 :     } else {
; 3514 : 	for (i = idx; i < list->nbItems -1; i++)
; 3515 : 	    list->items[i] = list->items[i+1];
; 3516 : 	list->nbItems--;
; 3517 :     }
; 3518 :     return(0);
; 3519 : }
; 3520 : 
; 3521 : /**
; 3522 :  * xmlSchemaItemListFree:
; 3523 :  * @annot:  a schema type structure
; 3524 :  *
; 3525 :  * Deallocate a annotation structure
; 3526 :  */
; 3527 : static void
; 3528 : xmlSchemaItemListFree(xmlSchemaItemListPtr list)
; 3529 : {
; 3530 :     if (list == NULL)
; 3531 : 	return;
; 3532 :     if (list->items != NULL)
; 3533 : 	xmlFree(list->items);
; 3534 :     xmlFree(list);
; 3535 : }
; 3536 : 
; 3537 : static void
; 3538 : xmlSchemaBucketFree(xmlSchemaBucketPtr bucket)
; 3539 : {
; 3540 :     if (bucket == NULL)
; 3541 : 	return;
; 3542 :     if (bucket->globals != NULL) {
; 3543 : 	xmlSchemaComponentListFree(bucket->globals);
; 3544 : 	xmlSchemaItemListFree(bucket->globals);
; 3545 :     }
; 3546 :     if (bucket->locals != NULL) {
; 3547 : 	xmlSchemaComponentListFree(bucket->locals);
; 3548 : 	xmlSchemaItemListFree(bucket->locals);
; 3549 :     }
; 3550 :     if (bucket->relations != NULL) {
; 3551 : 	xmlSchemaSchemaRelationPtr prev, cur = bucket->relations;
; 3552 : 	do {
; 3553 : 	    prev = cur;
; 3554 : 	    cur = cur->next;
; 3555 : 	    xmlFree(prev);
; 3556 : 	} while (cur != NULL);
; 3557 :     }
; 3558 :     if ((! bucket->preserveDoc) && (bucket->doc != NULL)) {
; 3559 : 	xmlFreeDoc(bucket->doc);
; 3560 :     }
; 3561 :     if (bucket->type == XML_SCHEMA_SCHEMA_IMPORT) {
; 3562 : 	if (WXS_IMPBUCKET(bucket)->schema != NULL)
; 3563 : 	    xmlSchemaFree(WXS_IMPBUCKET(bucket)->schema);
; 3564 :     }
; 3565 :     xmlFree(bucket);
; 3566 : }
; 3567 : 
; 3568 : static void
; 3569 : xmlSchemaBucketFreeEntry(void *bucket, const xmlChar *name ATTRIBUTE_UNUSED)
; 3570 : {
; 3571 :     xmlSchemaBucketFree((xmlSchemaBucketPtr) bucket);
; 3572 : }
; 3573 : 
; 3574 : static xmlSchemaBucketPtr
; 3575 : xmlSchemaBucketCreate(xmlSchemaParserCtxtPtr pctxt,
; 3576 : 			 int type, const xmlChar *targetNamespace)
; 3577 : {
; 3578 :     xmlSchemaBucketPtr ret;
; 3579 :     int size;
; 3580 :     xmlSchemaPtr mainSchema;
; 3581 : 
; 3582 :     if (WXS_CONSTRUCTOR(pctxt)->mainSchema == NULL) {
; 3583 : 	PERROR_INT("xmlSchemaBucketCreate",
; 3584 : 	    "no main schema on constructor");
; 3585 : 	return(NULL);
; 3586 :     }
; 3587 :     mainSchema = WXS_CONSTRUCTOR(pctxt)->mainSchema;
; 3588 :     /* Create the schema bucket. */
; 3589 :     if (WXS_IS_BUCKET_INCREDEF(type))
; 3590 : 	size = sizeof(xmlSchemaInclude);
; 3591 :     else
; 3592 : 	size = sizeof(xmlSchemaImport);
; 3593 :     ret = (xmlSchemaBucketPtr) xmlMalloc(size);
; 3594 :     if (ret == NULL) {
; 3595 : 	xmlSchemaPErrMemory(NULL, "allocating schema bucket", NULL);
; 3596 : 	return(NULL);
; 3597 :     }
; 3598 :     memset(ret, 0, size);
; 3599 :     ret->targetNamespace = targetNamespace;
; 3600 :     ret->type = type;
; 3601 :     ret->globals = xmlSchemaItemListCreate();
; 3602 :     if (ret->globals == NULL) {
; 3603 : 	xmlFree(ret);
; 3604 : 	return(NULL);
; 3605 :     }
; 3606 :     ret->locals = xmlSchemaItemListCreate();
; 3607 :     if (ret->locals == NULL) {
; 3608 : 	xmlFree(ret);
; 3609 : 	return(NULL);
; 3610 :     }
; 3611 :     /*
; 3612 :     * The following will assure that only the first bucket is marked as
; 3613 :     * XML_SCHEMA_SCHEMA_MAIN and it points to the *main* schema.
; 3614 :     * For each following import buckets an xmlSchema will be created.
; 3615 :     * An xmlSchema will be created for every distinct targetNamespace.
; 3616 :     * We assign the targetNamespace to the schemata here.
; 3617 :     */
; 3618 :     if (! WXS_HAS_BUCKETS(pctxt)) {
; 3619 : 	if (WXS_IS_BUCKET_INCREDEF(type)) {
; 3620 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3621 : 		"first bucket but it's an include or redefine");
; 3622 : 	    xmlSchemaBucketFree(ret);
; 3623 : 	    return(NULL);
; 3624 : 	}
; 3625 : 	/* Force the type to be XML_SCHEMA_SCHEMA_MAIN. */
; 3626 : 	ret->type = XML_SCHEMA_SCHEMA_MAIN;
; 3627 : 	/* Point to the *main* schema. */
; 3628 : 	WXS_CONSTRUCTOR(pctxt)->mainBucket = ret;
; 3629 : 	WXS_IMPBUCKET(ret)->schema = mainSchema;
; 3630 : 	/*
; 3631 : 	* Ensure that the main schema gets a targetNamespace.
; 3632 : 	*/
; 3633 : 	mainSchema->targetNamespace = targetNamespace;
; 3634 :     } else {
; 3635 : 	if (type == XML_SCHEMA_SCHEMA_MAIN) {
; 3636 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3637 : 		"main bucket but it's not the first one");
; 3638 : 	    xmlSchemaBucketFree(ret);
; 3639 : 	    return(NULL);
; 3640 : 	} else if (type == XML_SCHEMA_SCHEMA_IMPORT) {
; 3641 : 	    /*
; 3642 : 	    * Create a schema for imports and assign the
; 3643 : 	    * targetNamespace.
; 3644 : 	    */
; 3645 : 	    WXS_IMPBUCKET(ret)->schema = xmlSchemaNewSchema(pctxt);
; 3646 : 	    if (WXS_IMPBUCKET(ret)->schema == NULL) {
; 3647 : 		xmlSchemaBucketFree(ret);
; 3648 : 		return(NULL);
; 3649 : 	    }
; 3650 : 	    WXS_IMPBUCKET(ret)->schema->targetNamespace = targetNamespace;
; 3651 : 	}
; 3652 :     }
; 3653 :     if (WXS_IS_BUCKET_IMPMAIN(type)) {
; 3654 : 	int res;
; 3655 : 	/*
; 3656 : 	* Imports go into the "schemasImports" slot of the main *schema*.
; 3657 : 	* Note that we create an import entry for the main schema as well; i.e.,
; 3658 : 	* even if there's only one schema, we'll get an import.
; 3659 : 	*/
; 3660 : 	if (mainSchema->schemasImports == NULL) {
; 3661 : 	    mainSchema->schemasImports = xmlHashCreateDict(5,
; 3662 : 		WXS_CONSTRUCTOR(pctxt)->dict);
; 3663 : 	    if (mainSchema->schemasImports == NULL) {
; 3664 : 		xmlSchemaBucketFree(ret);
; 3665 : 		return(NULL);
; 3666 : 	    }
; 3667 : 	}
; 3668 : 	if (targetNamespace == NULL)
; 3669 : 	    res = xmlHashAddEntry(mainSchema->schemasImports,
; 3670 : 		XML_SCHEMAS_NO_NAMESPACE, ret);
; 3671 : 	else
; 3672 : 	    res = xmlHashAddEntry(mainSchema->schemasImports,
; 3673 : 		targetNamespace, ret);
; 3674 : 	if (res != 0) {
; 3675 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3676 : 		"failed to add the schema bucket to the hash");
; 3677 : 	    xmlSchemaBucketFree(ret);
; 3678 : 	    return(NULL);
; 3679 : 	}
; 3680 :     } else {
; 3681 : 	/* Set the @ownerImport of an include bucket. */
; 3682 : 	if (WXS_IS_BUCKET_IMPMAIN(WXS_CONSTRUCTOR(pctxt)->bucket->type))
; 3683 : 	    WXS_INCBUCKET(ret)->ownerImport =
; 3684 : 		WXS_IMPBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket);
; 3685 : 	else
; 3686 : 	    WXS_INCBUCKET(ret)->ownerImport =
; 3687 : 		WXS_INCBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket)->ownerImport;
; 3688 : 
; 3689 : 	/* Includes got into the "includes" slot of the *main* schema. */
; 3690 : 	if (mainSchema->includes == NULL) {
; 3691 : 	    mainSchema->includes = xmlSchemaItemListCreate();
; 3692 : 	    if (mainSchema->includes == NULL) {
; 3693 : 		xmlSchemaBucketFree(ret);
; 3694 : 		return(NULL);
; 3695 : 	    }
; 3696 : 	}
; 3697 : 	xmlSchemaItemListAdd(mainSchema->includes, ret);
; 3698 :     }
; 3699 :     /*
; 3700 :     * Add to list of all buckets; this is used for lookup
; 3701 :     * during schema construction time only.
; 3702 :     */
; 3703 :     if (xmlSchemaItemListAdd(WXS_CONSTRUCTOR(pctxt)->buckets, ret) == -1)
; 3704 : 	return(NULL);
; 3705 :     return(ret);
; 3706 : }
; 3707 : 
; 3708 : static int
; 3709 : xmlSchemaAddItemSize(xmlSchemaItemListPtr *list, int initialSize, void *item)
; 3710 : {
; 3711 :     if (*list == NULL) {
; 3712 : 	*list = xmlSchemaItemListCreate();
; 3713 : 	if (*list == NULL)
; 3714 : 	    return(-1);
; 3715 :     }
; 3716 :     xmlSchemaItemListAddSize(*list, initialSize, item);
; 3717 :     return(0);
; 3718 : }
; 3719 : 
; 3720 : /**
; 3721 :  * xmlSchemaFreeAnnot:
; 3722 :  * @annot:  a schema type structure
; 3723 :  *
; 3724 :  * Deallocate a annotation structure
; 3725 :  */
; 3726 : static void
; 3727 : xmlSchemaFreeAnnot(xmlSchemaAnnotPtr annot)
; 3728 : {
; 3729 :     if (annot == NULL)
; 3730 :         return;
; 3731 :     if (annot->next == NULL) {
; 3732 : 	xmlFree(annot);
; 3733 :     } else {
; 3734 : 	xmlSchemaAnnotPtr prev;
; 3735 : 
; 3736 : 	do {
; 3737 : 	    prev = annot;
; 3738 : 	    annot = annot->next;
; 3739 : 	    xmlFree(prev);
; 3740 : 	} while (annot != NULL);
; 3741 :     }
; 3742 : }
; 3743 : 
; 3744 : /**
; 3745 :  * xmlSchemaFreeNotation:
; 3746 :  * @schema:  a schema notation structure
; 3747 :  *
; 3748 :  * Deallocate a Schema Notation structure.
; 3749 :  */
; 3750 : static void
; 3751 : xmlSchemaFreeNotation(xmlSchemaNotationPtr nota)
; 3752 : {
; 3753 :     if (nota == NULL)
; 3754 :         return;
; 3755 :     xmlFree(nota);
; 3756 : }
; 3757 : 
; 3758 : /**
; 3759 :  * xmlSchemaFreeAttribute:
; 3760 :  * @attr:  an attribute declaration
; 3761 :  *
; 3762 :  * Deallocates an attribute declaration structure.
; 3763 :  */
; 3764 : static void
; 3765 : xmlSchemaFreeAttribute(xmlSchemaAttributePtr attr)
; 3766 : {
; 3767 :     if (attr == NULL)
; 3768 :         return;
; 3769 :     if (attr->annot != NULL)
; 3770 : 	xmlSchemaFreeAnnot(attr->annot);
; 3771 :     if (attr->defVal != NULL)
; 3772 : 	xmlSchemaFreeValue(attr->defVal);
; 3773 :     xmlFree(attr);
; 3774 : }
; 3775 : 
; 3776 : /**
; 3777 :  * xmlSchemaFreeAttributeUse:
; 3778 :  * @use:  an attribute use
; 3779 :  *
; 3780 :  * Deallocates an attribute use structure.
; 3781 :  */
; 3782 : static void
; 3783 : xmlSchemaFreeAttributeUse(xmlSchemaAttributeUsePtr use)
; 3784 : {
; 3785 :     if (use == NULL)
; 3786 :         return;
; 3787 :     if (use->annot != NULL)
; 3788 : 	xmlSchemaFreeAnnot(use->annot);
; 3789 :     if (use->defVal != NULL)
; 3790 : 	xmlSchemaFreeValue(use->defVal);
; 3791 :     xmlFree(use);
; 3792 : }
; 3793 : 
; 3794 : /**
; 3795 :  * xmlSchemaFreeAttributeUseProhib:
; 3796 :  * @prohib:  an attribute use prohibition
; 3797 :  *
; 3798 :  * Deallocates an attribute use structure.
; 3799 :  */
; 3800 : static void
; 3801 : xmlSchemaFreeAttributeUseProhib(xmlSchemaAttributeUseProhibPtr prohib)
; 3802 : {
; 3803 :     if (prohib == NULL)
; 3804 :         return;
; 3805 :     xmlFree(prohib);
; 3806 : }
; 3807 : 
; 3808 : /**
; 3809 :  * xmlSchemaFreeWildcardNsSet:
; 3810 :  * set:  a schema wildcard namespace
; 3811 :  *
; 3812 :  * Deallocates a list of wildcard constraint structures.
; 3813 :  */
; 3814 : static void
; 3815 : xmlSchemaFreeWildcardNsSet(xmlSchemaWildcardNsPtr set)
; 3816 : {
; 3817 :     xmlSchemaWildcardNsPtr next;
; 3818 : 
; 3819 :     while (set != NULL) {
; 3820 : 	next = set->next;
; 3821 : 	xmlFree(set);
; 3822 : 	set = next;
; 3823 :     }
; 3824 : }
; 3825 : 
; 3826 : /**
; 3827 :  * xmlSchemaFreeWildcard:
; 3828 :  * @wildcard:  a wildcard structure
; 3829 :  *
; 3830 :  * Deallocates a wildcard structure.
; 3831 :  */
; 3832 : void
; 3833 : xmlSchemaFreeWildcard(xmlSchemaWildcardPtr wildcard)
; 3834 : {
; 3835 :     if (wildcard == NULL)
; 3836 :         return;
; 3837 :     if (wildcard->annot != NULL)
; 3838 :         xmlSchemaFreeAnnot(wildcard->annot);
; 3839 :     if (wildcard->nsSet != NULL)
; 3840 : 	xmlSchemaFreeWildcardNsSet(wildcard->nsSet);
; 3841 :     if (wildcard->negNsSet != NULL)
; 3842 : 	xmlFree(wildcard->negNsSet);
; 3843 :     xmlFree(wildcard);
; 3844 : }
; 3845 : 
; 3846 : /**
; 3847 :  * xmlSchemaFreeAttributeGroup:
; 3848 :  * @schema:  a schema attribute group structure
; 3849 :  *
; 3850 :  * Deallocate a Schema Attribute Group structure.
; 3851 :  */
; 3852 : static void
; 3853 : xmlSchemaFreeAttributeGroup(xmlSchemaAttributeGroupPtr attrGr)
; 3854 : {
; 3855 :     if (attrGr == NULL)
; 3856 :         return;
; 3857 :     if (attrGr->annot != NULL)
; 3858 :         xmlSchemaFreeAnnot(attrGr->annot);
; 3859 :     if (attrGr->attrUses != NULL)
; 3860 : 	xmlSchemaItemListFree(WXS_LIST_CAST attrGr->attrUses);
; 3861 :     xmlFree(attrGr);
; 3862 : }
; 3863 : 
; 3864 : /**
; 3865 :  * xmlSchemaFreeQNameRef:
; 3866 :  * @item: a QName reference structure
; 3867 :  *
; 3868 :  * Deallocatea a QName reference structure.
; 3869 :  */
; 3870 : static void
; 3871 : xmlSchemaFreeQNameRef(xmlSchemaQNameRefPtr item)
; 3872 : {
; 3873 :     xmlFree(item);
; 3874 : }
; 3875 : 
; 3876 : /**
; 3877 :  * xmlSchemaFreeTypeLinkList:
; 3878 :  * @alink: a type link
; 3879 :  *
; 3880 :  * Deallocate a list of types.
; 3881 :  */
; 3882 : static void
; 3883 : xmlSchemaFreeTypeLinkList(xmlSchemaTypeLinkPtr link)
; 3884 : {
; 3885 :     xmlSchemaTypeLinkPtr next;
; 3886 : 
; 3887 :     while (link != NULL) {
; 3888 : 	next = link->next;
; 3889 : 	xmlFree(link);
; 3890 : 	link = next;
; 3891 :     }
; 3892 : }
; 3893 : 
; 3894 : static void
; 3895 : xmlSchemaFreeIDCStateObjList(xmlSchemaIDCStateObjPtr sto)
; 3896 : {
; 3897 :     xmlSchemaIDCStateObjPtr next;
; 3898 :     while (sto != NULL) {
; 3899 : 	next = sto->next;
; 3900 : 	if (sto->history != NULL)
; 3901 : 	    xmlFree(sto->history);
; 3902 : 	if (sto->xpathCtxt != NULL)
; 3903 : 	    xmlFreeStreamCtxt((xmlStreamCtxtPtr) sto->xpathCtxt);
; 3904 : 	xmlFree(sto);
; 3905 : 	sto = next;
; 3906 :     }
; 3907 : }
; 3908 : 
; 3909 : /**
; 3910 :  * xmlSchemaFreeIDC:
; 3911 :  * @idc: a identity-constraint definition
; 3912 :  *
; 3913 :  * Deallocates an identity-constraint definition.
; 3914 :  */
; 3915 : static void
; 3916 : xmlSchemaFreeIDC(xmlSchemaIDCPtr idcDef)
; 3917 : {
; 3918 :     xmlSchemaIDCSelectPtr cur, prev;
; 3919 : 
; 3920 :     if (idcDef == NULL)
; 3921 : 	return;
; 3922 :     if (idcDef->annot != NULL)
; 3923 :         xmlSchemaFreeAnnot(idcDef->annot);
; 3924 :     /* Selector */
; 3925 :     if (idcDef->selector != NULL) {
; 3926 : 	if (idcDef->selector->xpathComp != NULL)
; 3927 : 	    xmlFreePattern((xmlPatternPtr) idcDef->selector->xpathComp);
; 3928 : 	xmlFree(idcDef->selector);
; 3929 :     }
; 3930 :     /* Fields */
; 3931 :     if (idcDef->fields != NULL) {
; 3932 : 	cur = idcDef->fields;
; 3933 : 	do {
; 3934 : 	    prev = cur;
; 3935 : 	    cur = cur->next;
; 3936 : 	    if (prev->xpathComp != NULL)
; 3937 : 		xmlFreePattern((xmlPatternPtr) prev->xpathComp);
; 3938 : 	    xmlFree(prev);
; 3939 : 	} while (cur != NULL);
; 3940 :     }
; 3941 :     xmlFree(idcDef);
; 3942 : }
; 3943 : 
; 3944 : /**
; 3945 :  * xmlSchemaFreeElement:
; 3946 :  * @schema:  a schema element structure
; 3947 :  *
; 3948 :  * Deallocate a Schema Element structure.
; 3949 :  */
; 3950 : static void
; 3951 : xmlSchemaFreeElement(xmlSchemaElementPtr elem)
; 3952 : {
; 3953 :     if (elem == NULL)
; 3954 :         return;
; 3955 :     if (elem->annot != NULL)
; 3956 :         xmlSchemaFreeAnnot(elem->annot);
; 3957 :     if (elem->contModel != NULL)
; 3958 :         xmlRegFreeRegexp(elem->contModel);
; 3959 :     if (elem->defVal != NULL)
; 3960 : 	xmlSchemaFreeValue(elem->defVal);
; 3961 :     xmlFree(elem);
; 3962 : }
; 3963 : 
; 3964 : /**
; 3965 :  * xmlSchemaFreeFacet:
; 3966 :  * @facet:  a schema facet structure
; 3967 :  *
; 3968 :  * Deallocate a Schema Facet structure.
; 3969 :  */
; 3970 : void
; 3971 : xmlSchemaFreeFacet(xmlSchemaFacetPtr facet)
; 3972 : {
; 3973 :     if (facet == NULL)
; 3974 :         return;
; 3975 :     if (facet->val != NULL)
; 3976 :         xmlSchemaFreeValue(facet->val);
; 3977 :     if (facet->regexp != NULL)
; 3978 :         xmlRegFreeRegexp(facet->regexp);
; 3979 :     if (facet->annot != NULL)
; 3980 :         xmlSchemaFreeAnnot(facet->annot);
; 3981 :     xmlFree(facet);
; 3982 : }
; 3983 : 
; 3984 : /**
; 3985 :  * xmlSchemaFreeType:
; 3986 :  * @type:  a schema type structure
; 3987 :  *
; 3988 :  * Deallocate a Schema Type structure.
; 3989 :  */
; 3990 : void
; 3991 : xmlSchemaFreeType(xmlSchemaTypePtr type)
; 3992 : {
; 3993 :     if (type == NULL)
; 3994 :         return;
; 3995 :     if (type->annot != NULL)
; 3996 :         xmlSchemaFreeAnnot(type->annot);
; 3997 :     if (type->facets != NULL) {
; 3998 :         xmlSchemaFacetPtr facet, next;
; 3999 : 
; 4000 :         facet = type->facets;
; 4001 :         while (facet != NULL) {
; 4002 :             next = facet->next;
; 4003 :             xmlSchemaFreeFacet(facet);
; 4004 :             facet = next;
; 4005 :         }
; 4006 :     }
; 4007 :     if (type->attrUses != NULL)
; 4008 : 	xmlSchemaItemListFree((xmlSchemaItemListPtr) type->attrUses);
; 4009 :     if (type->memberTypes != NULL)
; 4010 : 	xmlSchemaFreeTypeLinkList(type->memberTypes);
; 4011 :     if (type->facetSet != NULL) {
; 4012 : 	xmlSchemaFacetLinkPtr next, link;
; 4013 : 
; 4014 : 	link = type->facetSet;
; 4015 : 	do {
; 4016 : 	    next = link->next;
; 4017 : 	    xmlFree(link);
; 4018 : 	    link = next;
; 4019 : 	} while (link != NULL);
; 4020 :     }
; 4021 :     if (type->contModel != NULL)
; 4022 :         xmlRegFreeRegexp(type->contModel);
; 4023 :     xmlFree(type);
; 4024 : }
; 4025 : 
; 4026 : /**
; 4027 :  * xmlSchemaFreeModelGroupDef:
; 4028 :  * @item:  a schema model group definition
; 4029 :  *
; 4030 :  * Deallocates a schema model group definition.
; 4031 :  */
; 4032 : static void
; 4033 : xmlSchemaFreeModelGroupDef(xmlSchemaModelGroupDefPtr item)
; 4034 : {
; 4035 :     if (item->annot != NULL)
; 4036 : 	xmlSchemaFreeAnnot(item->annot);
; 4037 :     xmlFree(item);
; 4038 : }
; 4039 : 
; 4040 : /**
; 4041 :  * xmlSchemaFreeModelGroup:
; 4042 :  * @item:  a schema model group
; 4043 :  *
; 4044 :  * Deallocates a schema model group structure.
; 4045 :  */
; 4046 : static void
; 4047 : xmlSchemaFreeModelGroup(xmlSchemaModelGroupPtr item)
; 4048 : {
; 4049 :     if (item->annot != NULL)
; 4050 : 	xmlSchemaFreeAnnot(item->annot);
; 4051 :     xmlFree(item);
; 4052 : }
; 4053 : 
; 4054 : static void
; 4055 : xmlSchemaComponentListFree(xmlSchemaItemListPtr list)
; 4056 : {
; 4057 :     if ((list == NULL) || (list->nbItems == 0))
; 4058 : 	return;
; 4059 :     {
; 4060 : 	xmlSchemaTreeItemPtr item;
; 4061 : 	xmlSchemaTreeItemPtr *items = (xmlSchemaTreeItemPtr *) list->items;
; 4062 : 	int i;
; 4063 : 
; 4064 : 	for (i = 0; i < list->nbItems; i++) {
; 4065 : 	    item = items[i];
; 4066 : 	    if (item == NULL)
; 4067 : 		continue;
; 4068 : 	    switch (item->type) {
; 4069 : 		case XML_SCHEMA_TYPE_SIMPLE:
; 4070 : 		case XML_SCHEMA_TYPE_COMPLEX:
; 4071 : 		    xmlSchemaFreeType((xmlSchemaTypePtr) item);
; 4072 : 		    break;
; 4073 : 		case XML_SCHEMA_TYPE_ATTRIBUTE:
; 4074 : 		    xmlSchemaFreeAttribute((xmlSchemaAttributePtr) item);
; 4075 : 		    break;
; 4076 : 		case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
; 4077 : 		    xmlSchemaFreeAttributeUse((xmlSchemaAttributeUsePtr) item);
; 4078 : 		    break;
; 4079 : 		case XML_SCHEMA_EXTRA_ATTR_USE_PROHIB:
; 4080 : 		    xmlSchemaFreeAttributeUseProhib(
; 4081 : 			(xmlSchemaAttributeUseProhibPtr) item);
; 4082 : 		    break;
; 4083 : 		case XML_SCHEMA_TYPE_ELEMENT:
; 4084 : 		    xmlSchemaFreeElement((xmlSchemaElementPtr) item);
; 4085 : 		    break;
; 4086 : 		case XML_SCHEMA_TYPE_PARTICLE:
; 4087 : 		    if (item->annot != NULL)
; 4088 : 			xmlSchemaFreeAnnot(item->annot);
; 4089 : 		    xmlFree(item);
; 4090 : 		    break;
; 4091 : 		case XML_SCHEMA_TYPE_SEQUENCE:
; 4092 : 		case XML_SCHEMA_TYPE_CHOICE:
; 4093 : 		case XML_SCHEMA_TYPE_ALL:
; 4094 : 		    xmlSchemaFreeModelGroup((xmlSchemaModelGroupPtr) item);
; 4095 : 		    break;
; 4096 : 		case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 4097 : 		    xmlSchemaFreeAttributeGroup(
; 4098 : 			(xmlSchemaAttributeGroupPtr) item);
; 4099 : 		    break;
; 4100 : 		case XML_SCHEMA_TYPE_GROUP:
; 4101 : 		    xmlSchemaFreeModelGroupDef(
; 4102 : 			(xmlSchemaModelGroupDefPtr) item);
; 4103 : 		    break;
; 4104 : 		case XML_SCHEMA_TYPE_ANY:
; 4105 : 		case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:
; 4106 : 		    xmlSchemaFreeWildcard((xmlSchemaWildcardPtr) item);
; 4107 : 		    break;
; 4108 : 		case XML_SCHEMA_TYPE_IDC_KEY:
; 4109 : 		case XML_SCHEMA_TYPE_IDC_UNIQUE:
; 4110 : 		case XML_SCHEMA_TYPE_IDC_KEYREF:
; 4111 : 		    xmlSchemaFreeIDC((xmlSchemaIDCPtr) item);
; 4112 : 		    break;
; 4113 : 		case XML_SCHEMA_TYPE_NOTATION:
; 4114 : 		    xmlSchemaFreeNotation((xmlSchemaNotationPtr) item);
; 4115 : 		    break;
; 4116 : 		case XML_SCHEMA_EXTRA_QNAMEREF:
; 4117 : 		    xmlSchemaFreeQNameRef((xmlSchemaQNameRefPtr) item);
; 4118 : 		    break;
; 4119 : 		default: {
; 4120 : 		    /* TODO: This should never be hit. */
; 4121 : 		    xmlSchemaPSimpleInternalErr(NULL,
; 4122 : 			"Internal error: xmlSchemaComponentListFree, "
; 4123 : 			"unexpected component type '%s'\n",
; 4124 : 			(const xmlChar *) WXS_ITEM_TYPE_NAME(item));
; 4125 : 			 }
; 4126 : 		    break;
; 4127 : 	    }
; 4128 : 	}
; 4129 : 	list->nbItems = 0;
; 4130 :     }
; 4131 : }
; 4132 : 
; 4133 : /**
; 4134 :  * xmlSchemaFree:
; 4135 :  * @schema:  a schema structure
; 4136 :  *
; 4137 :  * Deallocate a Schema structure.
; 4138 :  */
; 4139 : void
; 4140 : xmlSchemaFree(xmlSchemaPtr schema)
; 4141 : {
; 4142 :     if (schema == NULL)
; 4143 :         return;
; 4144 :     /* @volatiles is not used anymore :-/ */
; 4145 :     if (schema->volatiles != NULL)
; 4146 : 	TODO
; 4147 :     /*
; 4148 :     * Note that those slots are not responsible for freeing
; 4149 :     * schema components anymore; this will now be done by
; 4150 :     * the schema buckets.
; 4151 :     */
; 4152 :     if (schema->notaDecl != NULL)
; 4153 :         xmlHashFree(schema->notaDecl, NULL);
; 4154 :     if (schema->attrDecl != NULL)
; 4155 :         xmlHashFree(schema->attrDecl, NULL);
; 4156 :     if (schema->attrgrpDecl != NULL)
; 4157 :         xmlHashFree(schema->attrgrpDecl, NULL);
; 4158 :     if (schema->elemDecl != NULL)
; 4159 :         xmlHashFree(schema->elemDecl, NULL);
; 4160 :     if (schema->typeDecl != NULL)
; 4161 :         xmlHashFree(schema->typeDecl, NULL);
; 4162 :     if (schema->groupDecl != NULL)
; 4163 :         xmlHashFree(schema->groupDecl, NULL);
; 4164 :     if (schema->idcDef != NULL)
; 4165 :         xmlHashFree(schema->idcDef, NULL);
; 4166 : 
; 4167 :     if (schema->schemasImports != NULL)
; 4168 : 	xmlHashFree(schema->schemasImports, xmlSchemaBucketFreeEntry);
; 4169 :     if (schema->includes != NULL) {
; 4170 : 	xmlSchemaItemListPtr list = (xmlSchemaItemListPtr) schema->includes;
; 4171 : 	int i;
; 4172 : 	for (i = 0; i < list->nbItems; i++) {
; 4173 : 	    xmlSchemaBucketFree((xmlSchemaBucketPtr) list->items[i]);
; 4174 : 	}
; 4175 : 	xmlSchemaItemListFree(list);
; 4176 :     }
; 4177 :     if (schema->annot != NULL)
; 4178 :         xmlSchemaFreeAnnot(schema->annot);
; 4179 :     /* Never free the doc here, since this will be done by the buckets. */
; 4180 : 
; 4181 :     xmlDictFree(schema->dict);
; 4182 :     xmlFree(schema);
; 4183 : }
; 4184 : 
; 4185 : /************************************************************************
; 4186 :  *									*
; 4187 :  *			Debug functions					*
; 4188 :  *									*
; 4189 :  ************************************************************************/
; 4190 : 
; 4191 : #ifdef LIBXML_OUTPUT_ENABLED
; 4192 : 
; 4193 : static void
; 4194 : xmlSchemaTypeDump(xmlSchemaTypePtr type, FILE * output); /* forward */
; 4195 : 
; 4196 : /**
; 4197 :  * xmlSchemaElementDump:
; 4198 :  * @elem:  an element
; 4199 :  * @output:  the file output
; 4200 :  *
; 4201 :  * Dump the element
; 4202 :  */
; 4203 : static void
; 4204 : xmlSchemaElementDump(void *payload, void *data,
; 4205 :                      const xmlChar * name ATTRIBUTE_UNUSED,
; 4206 : 		     const xmlChar * namespace ATTRIBUTE_UNUSED,
; 4207 :                      const xmlChar * context ATTRIBUTE_UNUSED)
; 4208 : {
; 4209 :     xmlSchemaElementPtr elem = (xmlSchemaElementPtr) payload;
; 4210 :     FILE *output = (FILE *) data;
; 4211 :     if (elem == NULL)
; 4212 :         return;
; 4213 : 
; 4214 : 
; 4215 :     fprintf(output, "Element");
; 4216 :     if (elem->flags & XML_SCHEMAS_ELEM_GLOBAL)
; 4217 : 	fprintf(output, " (global)");
; 4218 :     fprintf(output, ": '%s' ", elem->name);
; 4219 :     if (namespace != NULL)
; 4220 : 	fprintf(output, "ns '%s'", namespace);
; 4221 :     fprintf(output, "\n");
; 4222 : #if 0
; 4223 :     if ((elem->minOccurs != 1) || (elem->maxOccurs != 1)) {
; 4224 : 	fprintf(output, "  min %d ", elem->minOccurs);
; 4225 :         if (elem->maxOccurs >= UNBOUNDED)
; 4226 :             fprintf(output, "max: unbounded\n");
; 4227 :         else if (elem->maxOccurs != 1)
; 4228 :             fprintf(output, "max: %d\n", elem->maxOccurs);
; 4229 :         else
; 4230 :             fprintf(output, "\n");
; 4231 :     }
; 4232 : #endif
; 4233 :     /*
; 4234 :     * Misc other properties.
; 4235 :     */
; 4236 :     if ((elem->flags & XML_SCHEMAS_ELEM_NILLABLE) ||
; 4237 : 	(elem->flags & XML_SCHEMAS_ELEM_ABSTRACT) ||
; 4238 : 	(elem->flags & XML_SCHEMAS_ELEM_FIXED) ||
; 4239 : 	(elem->flags & XML_SCHEMAS_ELEM_DEFAULT)) {
; 4240 : 	fprintf(output, "  props: ");
; 4241 : 	if (elem->flags & XML_SCHEMAS_ELEM_FIXED)
; 4242 : 	    fprintf(output, "[fixed] ");
; 4243 : 	if (elem->flags & XML_SCHEMAS_ELEM_DEFAULT)
; 4244 : 	    fprintf(output, "[default] ");
; 4245 : 	if (elem->flags & XML_SCHEMAS_ELEM_ABSTRACT)
; 4246 : 	    fprintf(output, "[abstract] ");
; 4247 : 	if (elem->flags & XML_SCHEMAS_ELEM_NILLABLE)
; 4248 : 	    fprintf(output, "[nillable] ");
; 4249 : 	fprintf(output, "\n");
; 4250 :     }
; 4251 :     /*
; 4252 :     * Default/fixed value.
; 4253 :     */
; 4254 :     if (elem->value != NULL)
; 4255 : 	fprintf(output, "  value: '%s'\n", elem->value);
; 4256 :     /*
; 4257 :     * Type.
; 4258 :     */
; 4259 :     if (elem->namedType != NULL) {
; 4260 : 	fprintf(output, "  type: '%s' ", elem->namedType);
; 4261 : 	if (elem->namedTypeNs != NULL)
; 4262 : 	    fprintf(output, "ns '%s'\n", elem->namedTypeNs);
; 4263 : 	else
; 4264 : 	    fprintf(output, "\n");
; 4265 :     } else if (elem->subtypes != NULL) {
; 4266 : 	/*
; 4267 : 	* Dump local types.
; 4268 : 	*/
; 4269 : 	xmlSchemaTypeDump(elem->subtypes, output);
; 4270 :     }
; 4271 :     /*
; 4272 :     * Substitution group.
; 4273 :     */
; 4274 :     if (elem->substGroup != NULL) {
; 4275 : 	fprintf(output, "  substitutionGroup: '%s' ", elem->substGroup);
; 4276 : 	if (elem->substGroupNs != NULL)
; 4277 : 	    fprintf(output, "ns '%s'\n", elem->substGroupNs);
; 4278 : 	else
; 4279 : 	    fprintf(output, "\n");
; 4280 :     }
; 4281 : }
; 4282 : 
; 4283 : /**
; 4284 :  * xmlSchemaAnnotDump:
; 4285 :  * @output:  the file output
; 4286 :  * @annot:  a annotation
; 4287 :  *
; 4288 :  * Dump the annotation
; 4289 :  */
; 4290 : static void
; 4291 : xmlSchemaAnnotDump(FILE * output, xmlSchemaAnnotPtr annot)
; 4292 : {
; 4293 :     xmlChar *content;
; 4294 : 
; 4295 :     if (annot == NULL)
; 4296 :         return;
; 4297 : 
; 4298 :     content = xmlNodeGetContent(annot->content);
; 4299 :     if (content != NULL) {
; 4300 :         fprintf(output, "  Annot: %s\n", content);
; 4301 :         xmlFree(content);
; 4302 :     } else
; 4303 :         fprintf(output, "  Annot: empty\n");
; 4304 : }
; 4305 : 
; 4306 : /**
; 4307 :  * xmlSchemaContentModelDump:
; 4308 :  * @particle: the schema particle
; 4309 :  * @output: the file output
; 4310 :  * @depth: the depth used for intentation
; 4311 :  *
; 4312 :  * Dump a SchemaType structure
; 4313 :  */
; 4314 : static void
; 4315 : xmlSchemaContentModelDump(xmlSchemaParticlePtr particle, FILE * output, int depth)
; 4316 : {
; 4317 :     xmlChar *str = NULL;
; 4318 :     xmlSchemaTreeItemPtr term;
; 4319 :     char shift[100];
; 4320 :     int i;
; 4321 : 
; 4322 :     if (particle == NULL)
; 4323 : 	return;
; 4324 :     for (i = 0;((i < depth) && (i < 25));i++)
; 4325 :         shift[2 * i] = shift[2 * i + 1] = ' ';
; 4326 :     shift[2 * i] = shift[2 * i + 1] = 0;
; 4327 :     fprintf(output, "%s", shift);
; 4328 :     if (particle->children == NULL) {
; 4329 : 	fprintf(output, "MISSING particle term\n");
; 4330 : 	return;
; 4331 :     }
; 4332 :     term = particle->children;
; 4333 :     if (term == NULL) {
; 4334 : 	fprintf(output, "(NULL)");
; 4335 :     } else {
; 4336 : 	switch (term->type) {
; 4337 : 	    case XML_SCHEMA_TYPE_ELEMENT:
; 4338 : 		fprintf(output, "ELEM '%s'", xmlSchemaFormatQName(&str,
; 4339 : 		    ((xmlSchemaElementPtr)term)->targetNamespace,
; 4340 : 		    ((xmlSchemaElementPtr)term)->name));
; 4341 : 		FREE_AND_NULL(str);
; 4342 : 		break;
; 4343 : 	    case XML_SCHEMA_TYPE_SEQUENCE:
; 4344 : 		fprintf(output, "SEQUENCE");
; 4345 : 		break;
; 4346 : 	    case XML_SCHEMA_TYPE_CHOICE:
; 4347 : 		fprintf(output, "CHOICE");
; 4348 : 		break;
; 4349 : 	    case XML_SCHEMA_TYPE_ALL:
; 4350 : 		fprintf(output, "ALL");
; 4351 : 		break;
; 4352 : 	    case XML_SCHEMA_TYPE_ANY:
; 4353 : 		fprintf(output, "ANY");
; 4354 : 		break;
; 4355 : 	    default:
; 4356 : 		fprintf(output, "UNKNOWN\n");
; 4357 : 		return;
; 4358 : 	}
; 4359 :     }
; 4360 :     if (particle->minOccurs != 1)
; 4361 : 	fprintf(output, " min: %d", particle->minOccurs);
; 4362 :     if (particle->maxOccurs >= UNBOUNDED)
; 4363 : 	fprintf(output, " max: unbounded");
; 4364 :     else if (particle->maxOccurs != 1)
; 4365 : 	fprintf(output, " max: %d", particle->maxOccurs);
; 4366 :     fprintf(output, "\n");
; 4367 :     if (term &&
; 4368 : 	((term->type == XML_SCHEMA_TYPE_SEQUENCE) ||
; 4369 : 	 (term->type == XML_SCHEMA_TYPE_CHOICE) ||
; 4370 : 	 (term->type == XML_SCHEMA_TYPE_ALL)) &&
; 4371 : 	 (term->children != NULL)) {
; 4372 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) term->children,
; 4373 : 	    output, depth +1);
; 4374 :     }
; 4375 :     if (particle->next != NULL)
; 4376 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) particle->next,
; 4377 : 		output, depth);
; 4378 : }
; 4379 : 
; 4380 : /**
; 4381 :  * xmlSchemaAttrUsesDump:
; 4382 :  * @uses:  attribute uses list
; 4383 :  * @output:  the file output
; 4384 :  *
; 4385 :  * Dumps a list of attribute use components.
; 4386 :  */
; 4387 : static void
; 4388 : xmlSchemaAttrUsesDump(xmlSchemaItemListPtr uses, FILE * output)
; 4389 : {
; 4390 :     xmlSchemaAttributeUsePtr use;
; 4391 :     xmlSchemaAttributeUseProhibPtr prohib;
; 4392 :     xmlSchemaQNameRefPtr ref;
; 4393 :     const xmlChar *name, *tns;
; 4394 :     xmlChar *str = NULL;
; 4395 :     int i;
; 4396 : 
; 4397 :     if ((uses == NULL) || (uses->nbItems == 0))
; 4398 :         return;
; 4399 : 
; 4400 :     fprintf(output, "  attributes:\n");
; 4401 :     for (i = 0; i < uses->nbItems; i++) {
; 4402 : 	use = uses->items[i];
; 4403 : 	if (use->type == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB) {
; 4404 : 	    fprintf(output, "  [prohibition] ");
; 4405 : 	    prohib = (xmlSchemaAttributeUseProhibPtr) use;
; 4406 : 	    name = prohib->name;
; 4407 : 	    tns = prohib->targetNamespace;
; 4408 : 	} else if (use->type == XML_SCHEMA_EXTRA_QNAMEREF) {
; 4409 : 	    fprintf(output, "  [reference] ");
; 4410 : 	    ref = (xmlSchemaQNameRefPtr) use;
; 4411 : 	    name = ref->name;
; 4412 : 	    tns = ref->targetNamespace;
; 4413 : 	} else {
; 4414 : 	    fprintf(output, "  [use] ");
; 4415 : 	    name = WXS_ATTRUSE_DECL_NAME(use);
; 4416 : 	    tns = WXS_ATTRUSE_DECL_TNS(use);
; 4417 : 	}
; 4418 : 	fprintf(output, "'%s'\n",
; 4419 : 	    (const char *) xmlSchemaFormatQName(&str, tns, name));
; 4420 : 	FREE_AND_NULL(str);
; 4421 :     }
; 4422 : }
; 4423 : 
; 4424 : /**
; 4425 :  * xmlSchemaTypeDump:
; 4426 :  * @output:  the file output
; 4427 :  * @type:  a type structure
; 4428 :  *
; 4429 :  * Dump a SchemaType structure
; 4430 :  */
; 4431 : static void
; 4432 : xmlSchemaTypeDump(xmlSchemaTypePtr type, FILE * output)
; 4433 : {
; 4434 :     if (type == NULL) {
; 4435 :         fprintf(output, "Type: NULL\n");
; 4436 :         return;
; 4437 :     }
; 4438 :     fprintf(output, "Type: ");
; 4439 :     if (type->name != NULL)
; 4440 :         fprintf(output, "'%s' ", type->name);
; 4441 :     else
; 4442 :         fprintf(output, "(no name) ");
; 4443 :     if (type->targetNamespace != NULL)
; 4444 : 	fprintf(output, "ns '%s' ", type->targetNamespace);
; 4445 :     switch (type->type) {
; 4446 :         case XML_SCHEMA_TYPE_BASIC:
; 4447 :             fprintf(output, "[basic] ");
; 4448 :             break;
; 4449 :         case XML_SCHEMA_TYPE_SIMPLE:
; 4450 :             fprintf(output, "[simple] ");
; 4451 :             break;
; 4452 :         case XML_SCHEMA_TYPE_COMPLEX:
; 4453 :             fprintf(output, "[complex] ");
; 4454 :             break;
; 4455 :         case XML_SCHEMA_TYPE_SEQUENCE:
; 4456 :             fprintf(output, "[sequence] ");
; 4457 :             break;
; 4458 :         case XML_SCHEMA_TYPE_CHOICE:
; 4459 :             fprintf(output, "[choice] ");
; 4460 :             break;
; 4461 :         case XML_SCHEMA_TYPE_ALL:
; 4462 :             fprintf(output, "[all] ");
; 4463 :             break;
; 4464 :         case XML_SCHEMA_TYPE_UR:
; 4465 :             fprintf(output, "[ur] ");
; 4466 :             break;
; 4467 :         case XML_SCHEMA_TYPE_RESTRICTION:
; 4468 :             fprintf(output, "[restriction] ");
; 4469 :             break;
; 4470 :         case XML_SCHEMA_TYPE_EXTENSION:
; 4471 :             fprintf(output, "[extension] ");
; 4472 :             break;
; 4473 :         default:
; 4474 :             fprintf(output, "[unknown type %d] ", type->type);
; 4475 :             break;
; 4476 :     }
; 4477 :     fprintf(output, "content: ");
; 4478 :     switch (type->contentType) {
; 4479 :         case XML_SCHEMA_CONTENT_UNKNOWN:
; 4480 :             fprintf(output, "[unknown] ");
; 4481 :             break;
; 4482 :         case XML_SCHEMA_CONTENT_EMPTY:
; 4483 :             fprintf(output, "[empty] ");
; 4484 :             break;
; 4485 :         case XML_SCHEMA_CONTENT_ELEMENTS:
; 4486 :             fprintf(output, "[element] ");
; 4487 :             break;
; 4488 :         case XML_SCHEMA_CONTENT_MIXED:
; 4489 :             fprintf(output, "[mixed] ");
; 4490 :             break;
; 4491 :         case XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS:
; 4492 : 	/* not used. */
; 4493 :             break;
; 4494 :         case XML_SCHEMA_CONTENT_BASIC:
; 4495 :             fprintf(output, "[basic] ");
; 4496 :             break;
; 4497 :         case XML_SCHEMA_CONTENT_SIMPLE:
; 4498 :             fprintf(output, "[simple] ");
; 4499 :             break;
; 4500 :         case XML_SCHEMA_CONTENT_ANY:
; 4501 :             fprintf(output, "[any] ");
; 4502 :             break;
; 4503 :     }
; 4504 :     fprintf(output, "\n");
; 4505 :     if (type->base != NULL) {
; 4506 :         fprintf(output, "  base type: '%s'", type->base);
; 4507 : 	if (type->baseNs != NULL)
; 4508 : 	    fprintf(output, " ns '%s'\n", type->baseNs);
; 4509 : 	else
; 4510 : 	    fprintf(output, "\n");
; 4511 :     }
; 4512 :     if (type->attrUses != NULL)
; 4513 : 	xmlSchemaAttrUsesDump(type->attrUses, output);
; 4514 :     if (type->annot != NULL)
; 4515 :         xmlSchemaAnnotDump(output, type->annot);
; 4516 : #ifdef DUMP_CONTENT_MODEL
; 4517 :     if ((type->type == XML_SCHEMA_TYPE_COMPLEX) &&
; 4518 : 	(type->subtypes != NULL)) {
; 4519 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) type->subtypes,
; 4520 : 	    output, 1);
; 4521 :     }
; 4522 : #endif
; 4523 : }
; 4524 : 
; 4525 : static void
; 4526 : xmlSchemaTypeDumpEntry(void *type, void *output,
; 4527 :                        const xmlChar *name ATTRIBUTE_UNUSED)
; 4528 : {
; 4529 :     xmlSchemaTypeDump((xmlSchemaTypePtr) type, (FILE *) output);
; 4530 : }
; 4531 : 
; 4532 : /**
; 4533 :  * xmlSchemaDump:
; 4534 :  * @output:  the file output
; 4535 :  * @schema:  a schema structure
; 4536 :  *
; 4537 :  * Dump a Schema structure.
; 4538 :  */
; 4539 : void
; 4540 : xmlSchemaDump(FILE * output, xmlSchemaPtr schema)
; 4541 : {
; 4542 :     if (output == NULL)
; 4543 :         return;
; 4544 :     if (schema == NULL) {
; 4545 :         fprintf(output, "Schemas: NULL\n");
; 4546 :         return;
; 4547 :     }
; 4548 :     fprintf(output, "Schemas: ");
; 4549 :     if (schema->name != NULL)
; 4550 :         fprintf(output, "%s, ", schema->name);
; 4551 :     else
; 4552 :         fprintf(output, "no name, ");
; 4553 :     if (schema->targetNamespace != NULL)
; 4554 :         fprintf(output, "%s", (const char *) schema->targetNamespace);
; 4555 :     else
; 4556 :         fprintf(output, "no target namespace");
; 4557 :     fprintf(output, "\n");
; 4558 :     if (schema->annot != NULL)
; 4559 :         xmlSchemaAnnotDump(output, schema->annot);
; 4560 :     xmlHashScan(schema->typeDecl, xmlSchemaTypeDumpEntry, output);
; 4561 :     xmlHashScanFull(schema->elemDecl, xmlSchemaElementDump, output);
; 4562 : }
; 4563 : 
; 4564 : #ifdef DEBUG_IDC_NODE_TABLE
; 4565 : /**
; 4566 :  * xmlSchemaDebugDumpIDCTable:
; 4567 :  * @vctxt: the WXS validation context
; 4568 :  *
; 4569 :  * Displays the current IDC table for debug purposes.
; 4570 :  */
; 4571 : static void
; 4572 : xmlSchemaDebugDumpIDCTable(FILE * output,
; 4573 : 			   const xmlChar *namespaceName,
; 4574 : 			   const xmlChar *localName,
; 4575 : 			   xmlSchemaPSVIIDCBindingPtr bind)
; 4576 : {
; 4577 :     xmlChar *str = NULL;
; 4578 :     const xmlChar *value;
; 4579 :     xmlSchemaPSVIIDCNodePtr tab;
; 4580 :     xmlSchemaPSVIIDCKeyPtr key;
; 4581 :     int i, j, res;
; 4582 : 
; 4583 :     fprintf(output, "IDC: TABLES on '%s'\n",
; 4584 : 	xmlSchemaFormatQName(&str, namespaceName, localName));
; 4585 :     FREE_AND_NULL(str)
; 4586 : 
; 4587 :     if (bind == NULL)
; 4588 : 	return;
; 4589 :     do {
; 4590 : 	fprintf(output, "IDC:   BINDING '%s' (%d)\n",
; 4591 : 	    xmlSchemaGetComponentQName(&str,
; 4592 : 		bind->definition), bind->nbNodes);
; 4593 : 	FREE_AND_NULL(str)
; 4594 : 	for (i = 0; i < bind->nbNodes; i++) {
; 4595 : 	    tab = bind->nodeTable[i];
; 4596 : 	    fprintf(output, "         ( ");
; 4597 : 	    for (j = 0; j < bind->definition->nbFields; j++) {
; 4598 : 		key = tab->keys[j];
; 4599 : 		if ((key != NULL) && (key->val != NULL)) {
; 4600 : 		    res = xmlSchemaGetCanonValue(key->val, &value);
; 4601 : 		    if (res >= 0)
; 4602 : 			fprintf(output, "'%s' ", value);
; 4603 : 		    else
; 4604 : 			fprintf(output, "CANON-VALUE-FAILED ");
; 4605 : 		    if (res == 0)
; 4606 : 			FREE_AND_NULL(value)
; 4607 : 		} else if (key != NULL)
; 4608 : 		    fprintf(output, "(no val), ");
; 4609 : 		else
; 4610 : 		    fprintf(output, "(key missing), ");
; 4611 : 	    }
; 4612 : 	    fprintf(output, ")\n");
; 4613 : 	}
; 4614 : 	if (bind->dupls && bind->dupls->nbItems) {
; 4615 : 	    fprintf(output, "IDC:     dupls (%d):\n", bind->dupls->nbItems);
; 4616 : 	    for (i = 0; i < bind->dupls->nbItems; i++) {
; 4617 : 		tab = bind->dupls->items[i];
; 4618 : 		fprintf(output, "         ( ");
; 4619 : 		for (j = 0; j < bind->definition->nbFields; j++) {
; 4620 : 		    key = tab->keys[j];
; 4621 : 		    if ((key != NULL) && (key->val != NULL)) {
; 4622 : 			res = xmlSchemaGetCanonValue(key->val, &value);
; 4623 : 			if (res >= 0)
; 4624 : 			    fprintf(output, "'%s' ", value);
; 4625 : 			else
; 4626 : 			    fprintf(output, "CANON-VALUE-FAILED ");
; 4627 : 			if (res == 0)
; 4628 : 			    FREE_AND_NULL(value)
; 4629 : 		    } else if (key != NULL)
; 4630 : 		    fprintf(output, "(no val), ");
; 4631 : 			else
; 4632 : 			    fprintf(output, "(key missing), ");
; 4633 : 		}
; 4634 : 		fprintf(output, ")\n");
; 4635 : 	    }
; 4636 : 	}
; 4637 : 	bind = bind->next;
; 4638 :     } while (bind != NULL);
; 4639 : }
; 4640 : #endif /* DEBUG_IDC */
; 4641 : #endif /* LIBXML_OUTPUT_ENABLED */
; 4642 : 
; 4643 : /************************************************************************
; 4644 :  *									*
; 4645 :  *			Utilities					*
; 4646 :  *									*
; 4647 :  ************************************************************************/
; 4648 : 
; 4649 : /**
; 4650 :  * xmlSchemaGetPropNode:
; 4651 :  * @node: the element node
; 4652 :  * @name: the name of the attribute
; 4653 :  *
; 4654 :  * Seeks an attribute with a name of @name in
; 4655 :  * no namespace.
; 4656 :  *
; 4657 :  * Returns the attribute or NULL if not present.
; 4658 :  */
; 4659 : static xmlAttrPtr
; 4660 : xmlSchemaGetPropNode(xmlNodePtr node, const char *name)
; 4661 : {
; 4662 :     xmlAttrPtr prop;
; 4663 : 
; 4664 :     if ((node == NULL) || (name == NULL))
; 4665 : 	return(NULL);
; 4666 :     prop = node->properties;
; 4667 :     while (prop != NULL) {

	jmp	SHORT $LN104@xmlSchemaP
$LN30@xmlSchemaP:

; 6041 :     return(xmlSchemaPValAttrNodeID(ctxt, attr));

	push	esi
	push	edi
	call	_xmlSchemaPValAttrNodeID
	add	esp, 8
$LN104@xmlSchemaP:

; 11851:     }
; 11852: 
; 11853:     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
; 11854: 
; 11855:     /*
; 11856:     * Attribute "base" - mandatory.
; 11857:     */
; 11858:     if ((xmlSchemaPValAttrQName(ctxt, schema, NULL, node,
; 11859: 	"base", &(type->baseNs), &(type->base)) == 0) &&

	mov	eax, DWORD PTR _type$1$[ebp]
	lea	esi, DWORD PTR [eax+56]
	add	eax, 60					; 0000003cH
	push	esi
	push	eax
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	ebx
	push	0
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaPValAttrQName
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	SHORT $LN40@xmlSchemaP
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN40@xmlSchemaP

; 2802 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	eax
	push	eax
	mov	DWORD PTR _des$1[ebp], eax
	lea	eax, DWORD PTR _des$1[ebp]
	push	eax
	call	_xmlSchemaFormatItemForReport

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	mov	eax, DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	eax
	push	OFFSET ??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	eax
	inc	DWORD PTR [edi+20]
	push	0
	push	0
	push	2
	push	3036					; 00000bdcH
	push	16					; 00000010H
	push	ebx
	push	edi
	push	DWORD PTR [edi+4]
	mov	DWORD PTR [edi+16], 3036		; 00000bdcH
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+24]
	call	___xmlRaiseError

; 2810 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$1[ebp]

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 88					; 00000058H

; 2810 :     FREE_AND_NULL(des);

	test	eax, eax
	je	SHORT $LN40@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN40@xmlSchemaP:

; 11860: 	(type->base == NULL)) {
; 11861: 	xmlSchemaPMissingAttrErr(ctxt,
; 11862: 	    XML_SCHEMAP_S4S_ATTR_MISSING,
; 11863: 	    NULL, node, "base", NULL);
; 11864:     }
; 11865:     /*
; 11866:     * And now for the children...
; 11867:     */
; 11868:     child = node->children;

	mov	esi, DWORD PTR [ebx+12]
	mov	ebx, esi
	mov	DWORD PTR _child$[ebp], esi
	mov	DWORD PTR $T2[ebp], ebx
	test	esi, esi

; 11869:     if (IS_SCHEMA(child, "annotation")) {

	je	SHORT $LN11@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	mov	DWORD PTR $T2[ebp], ebx
	je	SHORT $LN11@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	mov	DWORD PTR $T2[ebp], ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	mov	DWORD PTR $T2[ebp], ebx
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlSchemaP

; 11870: 	/*
; 11871: 	* Add the annotation to the type ancestor.
; 11872: 	*/
; 11873: 	xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,

	push	1
	push	esi
	push	edi
	call	_xmlSchemaParseAnnotation
	push	eax
	push	DWORD PTR _type$1$[ebp]
	call	_xmlSchemaAddAnnotation

; 11874: 	    xmlSchemaParseAnnotation(ctxt, child, 1));
; 11875:         child = child->next;

	mov	ebx, DWORD PTR [esi+24]
	add	esp, 20					; 00000014H
	mov	esi, ebx
	mov	DWORD PTR $T2[ebp], ebx
	mov	DWORD PTR _child$[ebp], esi
$LN11@xmlSchemaP:

; 11876:     }
; 11877:     if (parentType == XML_SCHEMA_TYPE_COMPLEX_CONTENT) {

	cmp	DWORD PTR _parentType$[ebp], 10		; 0000000aH
	jne	$LN108@xmlSchemaP

; 11878: 	/*
; 11879: 	* Corresponds to <complexType><complexContent><extension>... and:
; 11880: 	*
; 11881: 	* Model groups <all>, <choice>, <sequence> and <group>.
; 11882: 	*/
; 11883: 	if (IS_SCHEMA(child, "all")) {

	mov	ebx, DWORD PTR $T2[ebp]
	test	ebx, ebx
	je	$LN22@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	$LN17@xmlSchemaP
	push	OFFSET ??_C@_03NFKEKGGK@all@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlSchemaP

; 11884: 	    type->subtypes = (xmlSchemaTypePtr)

	push	1
	push	8

; 11885: 		xmlSchemaParseModelGroup(ctxt, schema,
; 11886: 		    child, XML_SCHEMA_TYPE_ALL, 1);
; 11887: 	    child = child->next;

	jmp	SHORT $LN117@xmlSchemaP
$LN13@xmlSchemaP:

; 11888: 	} else if (IS_SCHEMA(child, "choice")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN17@xmlSchemaP
	push	OFFSET ??_C@_06DDDNEJEA@choice@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlSchemaP

; 11889: 	    type->subtypes = (xmlSchemaTypePtr)

	push	1
	push	7

; 11890: 		xmlSchemaParseModelGroup(ctxt, schema,
; 11891: 		    child, XML_SCHEMA_TYPE_CHOICE, 1);
; 11892: 	    child = child->next;

	jmp	SHORT $LN117@xmlSchemaP
$LN15@xmlSchemaP:

; 11893: 	} else if (IS_SCHEMA(child, "sequence")) {

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN17@xmlSchemaP
	push	OFFSET ??_C@_08IBBDGPOF@sequence@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlSchemaP

; 11894: 	    type->subtypes = (xmlSchemaTypePtr)

	push	1
	push	6
$LN117@xmlSchemaP:

; 11900: 		xmlSchemaParseModelGroupDefRef(ctxt, schema, child);
; 11901: 	    /*
; 11902: 	    * Note that the reference will be resolved in
; 11903: 	    * xmlSchemaResolveTypeReferences();
; 11904: 	    */
; 11905: 	    child = child->next;
; 11906: 	}
; 11907:     }
; 11908:     if (child != NULL) {

	push	esi
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaParseModelGroup
	mov	ecx, DWORD PTR _type$1$[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR [ecx+28], eax
	mov	ebx, DWORD PTR [esi+24]
	mov	esi, ebx
	mov	DWORD PTR _child$[ebp], esi
	jmp	SHORT $LN19@xmlSchemaP
$LN17@xmlSchemaP:

; 11895: 		xmlSchemaParseModelGroup(ctxt, schema,
; 11896: 		child, XML_SCHEMA_TYPE_SEQUENCE, 1);
; 11897: 	    child = child->next;
; 11898: 	} else if (IS_SCHEMA(child, "group")) {

	test	ebx, ebx
	je	$LN22@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN108@xmlSchemaP
	mov	ebx, DWORD PTR $T2[ebp]
	push	OFFSET ??_C@_05MGJOOGAJ@group@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN108@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN108@xmlSchemaP

; 11899: 	    type->subtypes = (xmlSchemaTypePtr)

	push	esi
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaParseModelGroupDefRef

; 11900: 		xmlSchemaParseModelGroupDefRef(ctxt, schema, child);
; 11901: 	    /*
; 11902: 	    * Note that the reference will be resolved in
; 11903: 	    * xmlSchemaResolveTypeReferences();
; 11904: 	    */
; 11905: 	    child = child->next;
; 11906: 	}
; 11907:     }
; 11908:     if (child != NULL) {

	mov	ecx, DWORD PTR _type$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+28], eax
	mov	ebx, DWORD PTR [esi+24]
	mov	esi, ebx
	mov	DWORD PTR _child$[ebp], esi
	jmp	SHORT $LN19@xmlSchemaP
$LN108@xmlSchemaP:
	mov	ecx, DWORD PTR _type$1$[ebp]
$LN19@xmlSchemaP:
	test	ebx, ebx
	je	SHORT $LN22@xmlSchemaP

; 11909: 	/*
; 11910: 	* Attribute uses/declarations.
; 11911: 	*/
; 11912: 	if (xmlSchemaParseLocalAttributes(ctxt, schema, &child,
; 11913: 	    (xmlSchemaItemListPtr *) &(type->attrUses),
; 11914: 	    XML_SCHEMA_TYPE_EXTENSION, NULL) == -1)

	mov	ebx, DWORD PTR _schema$[ebp]
	lea	eax, DWORD PTR [ecx+116]
	push	0
	push	13					; 0000000dH
	push	eax
	lea	eax, DWORD PTR _child$[ebp]
	push	eax
	push	ebx
	push	edi
	call	_xmlSchemaParseLocalAttributes
	add	esp, 24					; 00000018H
	cmp	eax, -1
	je	$LN110@xmlSchemaP

; 11915: 	    return(NULL);
; 11916: 	/*
; 11917: 	* Attribute wildcard.
; 11918: 	*/
; 11919: 	if (IS_SCHEMA(child, "anyAttribute")) {

	mov	esi, DWORD PTR _child$[ebp]
	test	esi, esi
	je	$LN110@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN22@xmlSchemaP
	push	OFFSET ??_C@_0N@DDKCLMJG@anyAttribute@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@xmlSchemaP

; 11920: 	    ctxt->ctxtType->attributeWildcard =

	push	esi
	push	ebx
	push	edi
	call	_xmlSchemaParseAnyAttribute
	mov	ecx, DWORD PTR [edi+84]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+84], eax

; 11921: 		xmlSchemaParseAnyAttribute(ctxt, schema, child);
; 11922: 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]
$LN22@xmlSchemaP:

; 11923: 	}
; 11924:     }
; 11925:     if (child != NULL) {

	test	esi, esi
	je	SHORT $LN110@xmlSchemaP

; 11926: 	if (parentType == XML_SCHEMA_TYPE_COMPLEX_CONTENT) {

	push	DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$4[ebp]
	mov	DWORD PTR _des$4[ebp], 0
	push	0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport
	cmp	DWORD PTR _parentType$[ebp], 10		; 0000000aH
	jne	SHORT $LN24@xmlSchemaP

; 3235 : 	} else {

	push	OFFSET ??_C@_0GE@NILNJLFH@?$CIannotation?$DP?0?5?$CI?$CIgroup?5?$HM?5all?5?$HM?5c@

; 11927: 	    /* Complex content extension. */
; 11928: 	    xmlSchemaPContentErr(ctxt,
; 11929: 		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 11930: 		NULL, node, child, NULL,
; 11931: 		"(annotation?, ((group | all | choice | sequence)?, "
; 11932: 		"((attribute | attributeGroup)*, anyAttribute?)))");
; 11933: 	} else {

	jmp	SHORT $LN120@xmlSchemaP
$LN24@xmlSchemaP:

; 3235 : 	} else {

	push	OFFSET ??_C@_0DO@PEEJHPPG@?$CIannotation?$DP?0?5?$CI?$CIattribute?5?$HM?5att@
$LN120@xmlSchemaP:

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	push	DWORD PTR _des$3[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	edi
	call	_xmlSchemaPErr
	mov	eax, DWORD PTR _des$3[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN110@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN110@xmlSchemaP:
	pop	esi
$LN109@xmlSchemaP:
	pop	ebx
$LN5@xmlSchemaP:

; 11830:         return (NULL);

	xor	eax, eax
	pop	edi

; 11934: 	    /* Simple content extension. */
; 11935: 	    xmlSchemaPContentErr(ctxt,
; 11936: 		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 11937: 		NULL, node, child, NULL,
; 11938: 		"(annotation?, ((attribute | attributeGroup)*, "
; 11939: 		"anyAttribute?))");
; 11940: 	}
; 11941:     }
; 11942:     return (NULL);
; 11943: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseExtension ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseIncludeOrRedefine
_TEXT	SEGMENT
_wasChameleon$1$ = -16					; size = 4
_isChameleon$1$ = -12					; size = 4
_bucket$ = -8						; size = 4
_des$1 = -4						; size = 4
_des$2 = -4						; size = 4
_schemaLocation$ = -4					; size = 4
_res$2$ = 8						; size = 4
_pctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_type$ = 20						; size = 4
_xmlSchemaParseIncludeOrRedefine PROC			; COMDAT

; 10994: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pctxt$[ebp]
	xor	eax, eax
	mov	DWORD PTR _schemaLocation$[ebp], 0
	mov	DWORD PTR _isChameleon$1$[ebp], eax
	mov	DWORD PTR _wasChameleon$1$[ebp], eax
	mov	DWORD PTR _bucket$[ebp], eax
	test	edi, edi
	je	$LN5@xmlSchemaP

; 10995:     xmlNodePtr child = NULL;
; 10996:     const xmlChar *schemaLocation = NULL;
; 10997:     int res = 0; /* hasRedefinitions = 0 */
; 10998:     int isChameleon = 0, wasChameleon = 0;
; 10999:     xmlSchemaBucketPtr bucket = NULL;
; 11000: 
; 11001:     if ((pctxt == NULL) || (schema == NULL) || (node == NULL))

	mov	eax, DWORD PTR _schema$[ebp]
	test	eax, eax
	je	$LN5@xmlSchemaP
	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	$LN5@xmlSchemaP

; 11003: 
; 11004:     /*
; 11005:     * Parse attributes. Note that the returned schemaLocation will
; 11006:     * be already converted to an absolute URI.
; 11007:     */
; 11008:     res = xmlSchemaParseIncludeOrRedefineAttrs(pctxt, schema,

	push	DWORD PTR _type$[ebp]
	lea	ecx, DWORD PTR _schemaLocation$[ebp]
	push	ecx
	push	ebx
	push	eax
	push	edi
	call	_xmlSchemaParseIncludeOrRedefineAttrs
	add	esp, 20					; 00000014H

; 11009: 	node, (xmlChar **) (&schemaLocation), type);
; 11010:     if (res != 0)

	test	eax, eax
	jne	$LN1@xmlSchemaP

; 11011: 	return(res);
; 11012:     /*
; 11013:     * Load and add the schema document.
; 11014:     */
; 11015:     res = xmlSchemaAddSchemaDoc(pctxt, type, schemaLocation, NULL,

	push	esi
	mov	esi, DWORD PTR _schemaLocation$[ebp]
	lea	eax, DWORD PTR _bucket$[ebp]
	push	eax
	push	0
	push	DWORD PTR [edi+112]
	push	ebx
	push	0
	push	0
	push	0
	push	esi
	push	DWORD PTR _type$[ebp]
	push	edi
	call	_xmlSchemaAddSchemaDoc
	add	esp, 40					; 00000028H
	mov	DWORD PTR _res$2$[ebp], eax

; 11016: 	NULL, 0, node, pctxt->targetNamespace, NULL, &bucket);
; 11017:     if (res != 0)

	test	eax, eax
	jne	SHORT $LN90@xmlSchemaP

; 11018: 	return(res);
; 11019:     /*
; 11020:     * If we get no schema bucket back, then this means that the schema
; 11021:     * document could not be located or was broken XML or was not
; 11022:     * a schema document.
; 11023:     */
; 11024:     if ((bucket == NULL) || (bucket->doc == NULL)) {

	mov	ebx, DWORD PTR _bucket$[ebp]
	test	ebx, ebx
	je	SHORT $LN10@xmlSchemaP
	cmp	DWORD PTR [ebx+20], eax
	je	SHORT $LN10@xmlSchemaP

; 11056: 		node, NULL,
; 11057: 		"Failed to load the document '%s' for redefinition",
; 11058: 		schemaLocation, NULL);
; 11059: 	}
; 11060:     } else {
; 11061: 	/*
; 11062: 	* Check targetNamespace sanity before parsing the new schema.
; 11063: 	* TODO: Note that we won't check further content if the
; 11064: 	* targetNamespace was bad.
; 11065: 	*/
; 11066: 	if (bucket->origTargetNamespace != NULL) {

	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [edi+112]
	test	ecx, ecx
	je	SHORT $LN13@xmlSchemaP

; 11067: 	    /*
; 11068: 	    * SPEC src-include (2.1)
; 11069: 	    * "SII has a targetNamespace [attribute], and its `actual
; 11070: 	    * value` is identical to the `actual value` of the targetNamespace
; 11071: 	    * [attribute] of SII' (which must have such an [attribute])."
; 11072: 	    */
; 11073: 	    if (pctxt->targetNamespace == NULL) {

	test	eax, eax
	jne	SHORT $LN15@xmlSchemaP

; 11074: 		xmlSchemaCustomErr(ACTXT_CAST pctxt,

	push	eax
	push	esi
	push	OFFSET ??_C@_0IL@MIGJBHGC@The?5target?5namespace?5of?5the?5inc@
	push	eax
	push	DWORD PTR _node$[ebp]
	push	3050					; 00000beaH
	push	edi
	call	_xmlSchemaCustomErr

; 11192: 
; 11193: exit_error:
; 11194:     return(pctxt->err);

	mov	eax, DWORD PTR [edi+16]
	add	esp, 28					; 0000001cH
	pop	esi
	pop	edi

; 11195: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlSchemaP:

; 11075: 		    XML_SCHEMAP_SRC_INCLUDE,
; 11076: 		    node, NULL,
; 11077: 		    "The target namespace of the included/redefined schema "
; 11078: 		    "'%s' has to be absent, since the including/redefining "
; 11079: 		    "schema has no target namespace",
; 11080: 		    schemaLocation, NULL);
; 11081: 		goto exit_error;
; 11082: 	    } else if (!xmlStrEqual(bucket->origTargetNamespace,

	push	eax
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN89@xmlSchemaP

; 11083: 		pctxt->targetNamespace)) {
; 11084: 		/* TODO: Change error function. */
; 11085: 		xmlSchemaPCustomErrExt(pctxt,

	push	DWORD PTR [edi+112]
	push	esi
	push	DWORD PTR [ebx+12]
	push	OFFSET ??_C@_0HF@NFPCCAHE@The?5target?5namespace?5?8?$CFs?8?5of?5th@
	push	DWORD PTR _node$[ebp]
	push	eax
	push	3050					; 00000beaH
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
$exit_error$105:

; 11192: 
; 11193: exit_error:
; 11194:     return(pctxt->err);

	mov	eax, DWORD PTR [edi+16]
$LN90@xmlSchemaP:
	pop	esi
$LN1@xmlSchemaP:
	pop	edi

; 11195: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlSchemaP:

; 11086: 		    XML_SCHEMAP_SRC_INCLUDE,
; 11087: 		    NULL, node,
; 11088: 		    "The target namespace '%s' of the included/redefined "
; 11089: 		    "schema '%s' differs from '%s' of the "
; 11090: 		    "including/redefining schema",
; 11091: 		    bucket->origTargetNamespace, schemaLocation,
; 11092: 		    pctxt->targetNamespace);
; 11093: 		goto exit_error;
; 11094: 	    }
; 11095: 	} else if (pctxt->targetNamespace != NULL) {

	test	eax, eax
	je	SHORT $LN89@xmlSchemaP

; 11096: 	    /*
; 11097: 	    * Chameleons: the original target namespace will
; 11098: 	    * differ from the resulting namespace.
; 11099: 	    */
; 11100: 	    isChameleon = 1;

	mov	ecx, 1

; 11101: 	    if (bucket->parsed &&
; 11102: 		bucket->origTargetNamespace != NULL) {
; 11103: 		xmlSchemaCustomErr(ACTXT_CAST pctxt,
; 11104: 		    XML_SCHEMAP_SRC_INCLUDE,
; 11105: 		    node, NULL,
; 11106: 		    "The target namespace of the included/redefined schema "
; 11107: 		    "'%s' has to be absent or the same as the "
; 11108: 		    "including/redefining schema's target namespace",
; 11109: 		    schemaLocation, NULL);
; 11110: 		goto exit_error;
; 11111: 	    }
; 11112: 	    bucket->targetNamespace = pctxt->targetNamespace;

	mov	DWORD PTR [ebx+16], eax
	mov	DWORD PTR _isChameleon$1$[ebp], ecx
	jmp	SHORT $LN12@xmlSchemaP
$LN10@xmlSchemaP:

; 11025: 	if (type == XML_SCHEMA_SCHEMA_INCLUDE) {

	cmp	DWORD PTR _type$[ebp], 2
	push	0
	push	esi
	jne	SHORT $LN11@xmlSchemaP

; 11026: 	    /*
; 11027: 	    * WARNING for <include>:
; 11028: 	    * We will raise an error if the schema cannot be located
; 11029: 	    * for inclusions, since the that was the feedback from the
; 11030: 	    * schema people. I.e. the following spec piece will *not* be
; 11031: 	    * satisfied:
; 11032: 	    * SPEC src-include: "It is not an error for the `actual value` of the
; 11033: 	    * schemaLocation [attribute] to fail to resolve it all, in which
; 11034: 	    * case no corresponding inclusion is performed.
; 11035: 	    * So do we need a warning report here?"
; 11036: 	    */
; 11037: 	    res = XML_SCHEMAP_SRC_INCLUDE;
; 11038: 	    xmlSchemaCustomErr(ACTXT_CAST pctxt, res,

	push	OFFSET ??_C@_0CP@PKPHBKIC@Failed?5to?5load?5the?5document?5?8?$CFs@
	push	0
	push	DWORD PTR _node$[ebp]
	mov	DWORD PTR _res$2$[ebp], 3050		; 00000beaH
	push	3050					; 00000beaH

; 11039: 		node, NULL,
; 11040: 		"Failed to load the document '%s' for inclusion",
; 11041: 		schemaLocation, NULL);
; 11042: 	} else {

	jmp	SHORT $LN103@xmlSchemaP
$LN11@xmlSchemaP:

; 11043: 	    /*
; 11044: 	    * NOTE: This was changed to raise an error even if no redefinitions
; 11045: 	    * are specified.
; 11046: 	    *
; 11047: 	    * SPEC src-redefine (1)
; 11048: 	    * "If there are any element information items among the [children]
; 11049: 	    * other than <annotation> then the `actual value` of the
; 11050: 	    * schemaLocation [attribute] must successfully resolve."
; 11051: 	    * TODO: Ask the WG if a the location has always to resolve
; 11052: 	    * here as well!
; 11053: 	    */
; 11054: 	    res = XML_SCHEMAP_SRC_REDEFINE;
; 11055: 	    xmlSchemaCustomErr(ACTXT_CAST pctxt, res,

	push	OFFSET ??_C@_0DC@DJHEKCBE@Failed?5to?5load?5the?5document?5?8?$CFs@
	push	0
	push	DWORD PTR _node$[ebp]
	mov	DWORD PTR _res$2$[ebp], 3081		; 00000c09H
	push	3081					; 00000c09H
$LN103@xmlSchemaP:

; 11113: 	}
; 11114:     }
; 11115:     /*
; 11116:     * Parse the schema.
; 11117:     */
; 11118:     if (bucket && (!bucket->parsed) && (bucket->doc != NULL)) {

	push	edi
	call	_xmlSchemaCustomErr
	add	esp, 28					; 0000001cH
$LN89@xmlSchemaP:
	xor	ecx, ecx
$LN12@xmlSchemaP:
	test	ebx, ebx
	je	SHORT $LN24@xmlSchemaP
	cmp	DWORD PTR [ebx+32], 0
	jne	SHORT $LN24@xmlSchemaP
	cmp	DWORD PTR [ebx+20], 0
	je	SHORT $LN24@xmlSchemaP

; 11119: 	if (isChameleon) {

	mov	esi, DWORD PTR _schema$[ebp]
	test	ecx, ecx
	je	SHORT $LN23@xmlSchemaP

; 11120: 	    /* TODO: Get rid of this flag on the schema itself. */
; 11121: 	    if ((schema->flags & XML_SCHEMAS_INCLUDING_CONVERT_NS) == 0) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, 512				; 00000200H
	jne	SHORT $LN22@xmlSchemaP

; 11122: 		schema->flags |= XML_SCHEMAS_INCLUDING_CONVERT_NS;

	or	eax, 512				; 00000200H
	mov	DWORD PTR [esi+24], eax

; 11123: 	    } else

	jmp	SHORT $LN23@xmlSchemaP
$LN22@xmlSchemaP:

; 11124: 		wasChameleon = 1;

	mov	DWORD PTR _wasChameleon$1$[ebp], 1
$LN23@xmlSchemaP:

; 11125: 	}
; 11126: 	xmlSchemaParseNewDoc(pctxt, schema, bucket);

	push	ebx
	push	esi
	push	edi
	call	_xmlSchemaParseNewDoc
	add	esp, 12					; 0000000cH

; 11127: 	/* Restore chameleon flag. */
; 11128: 	if (isChameleon && (!wasChameleon))

	cmp	DWORD PTR _isChameleon$1$[ebp], 0
	je	SHORT $LN24@xmlSchemaP
	cmp	DWORD PTR _wasChameleon$1$[ebp], 0
	jne	SHORT $LN24@xmlSchemaP

; 11129: 	    schema->flags ^= XML_SCHEMAS_INCLUDING_CONVERT_NS;

	xor	DWORD PTR [esi+24], 512			; 00000200H
$LN24@xmlSchemaP:

; 11130:     }
; 11131:     /*
; 11132:     * And now for the children...
; 11133:     */
; 11134:     child = node->children;
; 11135:     if (type == XML_SCHEMA_SCHEMA_REDEFINE) {

	cmp	DWORD PTR _type$[ebp], 3
	mov	eax, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [eax+12]
	jne	$LN25@xmlSchemaP

; 11136: 	/*
; 11137: 	* Parse (simpleType | complexType | group | attributeGroup))*
; 11138: 	*/
; 11139: 	pctxt->redefined = bucket;

	mov	DWORD PTR [edi+116], ebx
	mov	ebx, DWORD PTR _schema$[ebp]

; 11140: 	/*
; 11141: 	* How to proceed if the redefined schema was not located?
; 11142: 	*/
; 11143: 	pctxt->isRedefine = 1;

	mov	DWORD PTR [edi+100], 1
	npad	6
$LL2@xmlSchemaP:

; 11144: 	while (IS_SCHEMA(child, "annotation") ||
; 11145: 	    IS_SCHEMA(child, "simpleType") ||
; 11146: 	    IS_SCHEMA(child, "complexType") ||
; 11147: 	    IS_SCHEMA(child, "group") ||

	test	esi, esi
	je	$LN3@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	$LN3@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN28@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN27@xmlSchemaP
$LN28@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN3@xmlSchemaP
	push	OFFSET ??_C@_0L@FMMGGLOP@simpleType@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN29@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN27@xmlSchemaP
$LN29@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN3@xmlSchemaP
	push	OFFSET ??_C@_0M@OCBEIBDG@complexType@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN30@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@xmlSchemaP
$LN30@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN3@xmlSchemaP
	push	OFFSET ??_C@_05MGJOOGAJ@group@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN31@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@xmlSchemaP
$LN31@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN3@xmlSchemaP
	push	OFFSET ??_C@_0P@KIDCOMBF@attributeGroup@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN3@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN3@xmlSchemaP
$LN27@xmlSchemaP:

; 11148: 	    IS_SCHEMA(child, "attributeGroup")) {
; 11149: 	    if (IS_SCHEMA(child, "annotation")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN40@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN32@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN40@xmlSchemaP
$LN32@xmlSchemaP:

; 11150: 		/*
; 11151: 		* TODO: discard or not?
; 11152: 		*/
; 11153: 	    } else if (IS_SCHEMA(child, "simpleType")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN40@xmlSchemaP
	push	OFFSET ??_C@_0L@FMMGGLOP@simpleType@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN34@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN34@xmlSchemaP

; 11154: 		xmlSchemaParseSimpleType(pctxt, schema, child, 1);

	push	1
	push	esi
	push	ebx
	push	edi
	call	_xmlSchemaParseSimpleType

; 11165: 		    child);
; 11166: 	    }
; 11167: 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 16					; 00000010H

; 11168: 	}

	jmp	$LL2@xmlSchemaP
$LN34@xmlSchemaP:

; 11155: 	    } else if (IS_SCHEMA(child, "complexType")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN40@xmlSchemaP
	push	OFFSET ??_C@_0M@OCBEIBDG@complexType@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN36@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN36@xmlSchemaP

; 11156: 		xmlSchemaParseComplexType(pctxt, schema, child, 1);

	push	1
	push	esi
	push	ebx
	push	edi
	call	_xmlSchemaParseComplexType

; 11165: 		    child);
; 11166: 	    }
; 11167: 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 16					; 00000010H

; 11168: 	}

	jmp	$LL2@xmlSchemaP
$LN36@xmlSchemaP:

; 11157: 		/* hasRedefinitions = 1; */
; 11158: 	    } else if (IS_SCHEMA(child, "group")) {

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN40@xmlSchemaP
	push	OFFSET ??_C@_05MGJOOGAJ@group@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN38@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN38@xmlSchemaP

; 11159: 		/* hasRedefinitions = 1; */
; 11160: 		xmlSchemaParseModelGroupDefinition(pctxt,

	push	esi
	push	ebx
	push	edi
	call	_xmlSchemaParseModelGroupDefinition

; 11165: 		    child);
; 11166: 	    }
; 11167: 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 12					; 0000000cH

; 11168: 	}

	jmp	$LL2@xmlSchemaP
$LN38@xmlSchemaP:

; 11161: 		    schema, child);
; 11162: 	    } else if (IS_SCHEMA(child, "attributeGroup")) {

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN40@xmlSchemaP
	push	OFFSET ??_C@_0P@KIDCOMBF@attributeGroup@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN40@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN40@xmlSchemaP

; 11163: 		/* hasRedefinitions = 1; */
; 11164: 		xmlSchemaParseAttributeGroupDefinition(pctxt, schema,

	push	esi
	push	ebx
	push	edi
	call	_xmlSchemaParseAttributeGroupDefinition

; 11165: 		    child);
; 11166: 	    }
; 11167: 	    child = child->next;

	add	esp, 12					; 0000000cH
$LN40@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]

; 11168: 	}

	jmp	$LL2@xmlSchemaP
$LN3@xmlSchemaP:

; 11169: 	pctxt->redefined = NULL;

	mov	DWORD PTR [edi+116], 0

; 11170: 	pctxt->isRedefine = 0;

	mov	DWORD PTR [edi+100], 0

; 11171:     } else {

	jmp	SHORT $LN41@xmlSchemaP
$LN25@xmlSchemaP:

; 11172: 	if (IS_SCHEMA(child, "annotation")) {

	test	esi, esi
	je	$LN70@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN41@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN41@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN41@xmlSchemaP

; 11173: 	    /*
; 11174: 	    * TODO: discard or not?
; 11175: 	    */
; 11176: 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]
$LN41@xmlSchemaP:

; 11177: 	}
; 11178:     }
; 11179:     if (child != NULL) {

	test	esi, esi
	je	SHORT $LN70@xmlSchemaP

; 11180: 	res = XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED;
; 11181: 	if (type == XML_SCHEMA_SCHEMA_REDEFINE) {

	push	DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$2[ebp]
	mov	DWORD PTR _res$2$[ebp], 3033		; 00000bd9H
	push	0
	push	0
	push	eax
	mov	DWORD PTR _des$2[ebp], 0
	call	_xmlSchemaFormatItemForReport
	cmp	DWORD PTR _type$[ebp], 3
	jne	SHORT $LN43@xmlSchemaP

; 3241 :     FREE_AND_NULL(des)

	push	OFFSET ??_C@_0EE@OHBEFOEM@?$CIannotation?5?$HM?5?$CIsimpleType?5?$HM?5com@

; 11182: 	    xmlSchemaPContentErr(pctxt, res,
; 11183: 		NULL, node, child, NULL,
; 11184: 		"(annotation | (simpleType | complexType | group | attributeGroup))*");
; 11185: 	} else {

	jmp	SHORT $LN102@xmlSchemaP
$LN43@xmlSchemaP:

; 3241 :     FREE_AND_NULL(des)

	push	OFFSET ??_C@_0O@MNAJHLGE@?$CIannotation?$DP?$CJ@
$LN102@xmlSchemaP:

; 11186: 	     xmlSchemaPContentErr(pctxt, res,
; 11187: 		NULL, node, child, NULL,
; 11188: 		"(annotation?)");
; 11189: 	}
; 11190:     }
; 11191:     return(res);

	push	DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	edi
	call	_xmlSchemaPErr
	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN70@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN70@xmlSchemaP:
	mov	eax, DWORD PTR _res$2$[ebp]
	pop	esi
	pop	edi

; 11195: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlSchemaP:
	pop	edi

; 11002:         return (-1);

	or	eax, -1

; 11195: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseIncludeOrRedefine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseIncludeOrRedefineAttrs
_TEXT	SEGMENT
_base$1$ = -4						; size = 4
_uri$1$ = 8						; size = 4
_des$1 = 8						; size = 4
_attr$2$ = 8						; size = 4
_pctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_schemaLocation$ = 20					; size = 4
_type$ = 24						; size = 4
_xmlSchemaParseIncludeOrRedefineAttrs PROC		; COMDAT

; 10899: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pctxt$[ebp]
	test	edi, edi
	je	$LN5@xmlSchemaP

; 10900:     xmlAttrPtr attr;
; 10901: 
; 10902:     if ((pctxt == NULL) || (schema == NULL) || (node == NULL) ||

	cmp	DWORD PTR _schema$[ebp], 0
	je	$LN5@xmlSchemaP
	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	$LN5@xmlSchemaP
	mov	eax, DWORD PTR _schemaLocation$[ebp]
	test	eax, eax
	je	$LN5@xmlSchemaP

; 10905: 
; 10906:     *schemaLocation = NULL;

	push	esi
	mov	DWORD PTR [eax], 0

; 10907:     /*
; 10908:     * Check for illegal attributes.
; 10909:     * Applies for both <include> and <redefine>.
; 10910:     */
; 10911:     attr = node->properties;

	mov	esi, DWORD PTR [ebx+44]

; 10912:     while (attr != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlSchemaP
	npad	7
$LL2@xmlSchemaP:

; 10913: 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN6@xmlSchemaP

; 10914: 	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP
	push	OFFSET ??_C@_0P@DEMHLMFE@schemaLocation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP

; 10915: 		(!xmlStrEqual(attr->name, BAD_CAST "schemaLocation"))) {
; 10916: 		xmlSchemaPIllegalAttrErr(pctxt,
; 10917: 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 10918: 	    }

	jmp	SHORT $LN33@xmlSchemaP
$LN6@xmlSchemaP:

; 10919: 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlSchemaP
$LN33@xmlSchemaP:

; 10920: 	    xmlSchemaPIllegalAttrErr(pctxt,
; 10921: 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 10922: 	}
; 10923: 	attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN9@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaP
$LN3@xmlSchemaP:

; 10924:     }
; 10925:     xmlSchemaPValAttrID(pctxt, node, BAD_CAST "id");

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	ebx
	push	edi
	call	_xmlSchemaPValAttrID

; 10926:     /*
; 10927:     * Preliminary step, extract the URI-Reference and make an URI
; 10928:     * from the base.
; 10929:     */
; 10930:     /*
; 10931:     * Attribute "schemaLocation" is mandatory.
; 10932:     */
; 10933:     attr = xmlSchemaGetPropNode(node, "schemaLocation");

	push	OFFSET ??_C@_0P@DEMHLMFE@schemaLocation@
	push	ebx
	call	_xmlSchemaGetPropNode
	add	esp, 20					; 00000014H
	mov	DWORD PTR _attr$2$[ebp], eax

; 10934:     if (attr != NULL) {

	test	eax, eax
	je	$LN10@xmlSchemaP

; 10935:         xmlChar *base = NULL;
; 10936:         xmlChar *uri = NULL;
; 10937: 
; 10938: 	if (xmlSchemaPValAttrNode(pctxt, NULL, attr,
; 10939: 	    xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
; 10940: 	    (const xmlChar **) schemaLocation) != 0)

	mov	esi, DWORD PTR _schemaLocation$[ebp]
	push	esi
	push	29					; 0000001dH
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	push	eax
	push	DWORD PTR _attr$2$[ebp]
	push	0
	push	edi
	call	_xmlSchemaPValAttrNode
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$exit_error$35

; 10941: 	    goto exit_error;
; 10942: 	base = xmlNodeGetBase(node->doc, node);

	push	ebx
	push	DWORD PTR [ebx+32]
	call	_xmlNodeGetBase
	add	esp, 8
	mov	DWORD PTR _base$1$[ebp], eax

; 10943: 	if (base == NULL) {

	test	eax, eax
	jne	SHORT $LN13@xmlSchemaP

; 10944: 	    uri = xmlBuildURI(*schemaLocation, node->doc->URL);

	mov	eax, DWORD PTR [ebx+32]
	push	DWORD PTR [eax+72]
	push	DWORD PTR [esi]
	call	_xmlBuildURI
	add	esp, 8
	mov	DWORD PTR _uri$1$[ebp], eax

; 10945: 	} else {

	jmp	SHORT $LN14@xmlSchemaP
$LN13@xmlSchemaP:

; 10946: 	    uri = xmlBuildURI(*schemaLocation, base);

	push	eax
	push	DWORD PTR [esi]
	call	_xmlBuildURI

; 10947: 	    xmlFree(base);

	push	DWORD PTR _base$1$[ebp]
	mov	DWORD PTR _uri$1$[ebp], eax
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _uri$1$[ebp]
	add	esp, 12					; 0000000cH
$LN14@xmlSchemaP:

; 10948: 	}
; 10949: 	if (uri == NULL) {

	test	eax, eax
	jne	SHORT $LN15@xmlSchemaP

; 10950: 	    PERROR_INT("xmlSchemaParseIncludeOrRedefine",

	push	OFFSET ??_C@_0CP@EKIECFJN@could?5not?5build?5an?5URI?5from?5the@
	push	OFFSET ??_C@_0CA@NKMDDHKI@xmlSchemaParseIncludeOrRedefine@
	push	edi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH
$exit_failure$36:

; 10985: exit_failure:
; 10986:     return(-1);

	pop	esi
	pop	edi
	or	eax, -1

; 10987: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlSchemaP:

; 10951: 		"could not build an URI from the schemaLocation")
; 10952: 	    goto exit_failure;
; 10953: 	}
; 10954: 	(*schemaLocation) = (xmlChar *) xmlDictLookup(pctxt->dict, uri, -1);

	push	-1
	push	eax
	push	DWORD PTR [edi+80]
	call	_xmlDictLookup
	mov	DWORD PTR [esi], eax

; 10955: 	xmlFree(uri);

	mov	eax, DWORD PTR _uri$1$[ebp]
	push	eax
	call	DWORD PTR _xmlFree

; 10956:     } else {
; 10957: 	xmlSchemaPMissingAttrErr(pctxt,
; 10958: 	    XML_SCHEMAP_S4S_ATTR_MISSING,
; 10959: 	    NULL, node, "schemaLocation", NULL);
; 10960: 	goto exit_error;
; 10961:     }
; 10962:     /*
; 10963:     * Report self-inclusion and self-redefinition.
; 10964:     */
; 10965:     if (xmlStrEqual(*schemaLocation, pctxt->URL)) {

	push	DWORD PTR [edi+44]
	push	DWORD PTR [esi]
	call	_xmlStrEqual
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN16@xmlSchemaP

; 10966: 	if (type == XML_SCHEMA_SCHEMA_REDEFINE) {
; 10967: 	    xmlSchemaPCustomErr(pctxt,
; 10968: 		XML_SCHEMAP_SRC_REDEFINE,
; 10969: 		NULL, node,
; 10970: 		"The schema document '%s' cannot redefine itself.",
; 10971: 		*schemaLocation);
; 10972: 	} else {
; 10973: 	    xmlSchemaPCustomErr(pctxt,
; 10974: 		XML_SCHEMAP_SRC_INCLUDE,
; 10975: 		NULL, node,
; 10976: 		"The schema document '%s' cannot include itself.",
; 10977: 		*schemaLocation);
; 10978: 	}
; 10979: 	goto exit_error;

	push	DWORD PTR [esi]
	cmp	DWORD PTR _type$[ebp], 3
	mov	edx, OFFSET ??_C@_0DB@IGEPJIPN@The?5schema?5document?5?8?$CFs?8?5cannot@
	mov	eax, OFFSET ??_C@_0DA@JGHKIBFN@The?5schema?5document?5?8?$CFs?8?5cannot@
	cmove	eax, edx
	mov	edx, 3050				; 00000beaH
	push	eax
	push	ebx
	mov	eax, 3081				; 00000c09H
	push	0
	cmovne	eax, edx
	push	eax
	push	edi
	call	_xmlSchemaPCustomErr

; 10983: exit_error:
; 10984:     return(pctxt->err);

	mov	eax, DWORD PTR [edi+16]
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi

; 10987: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlSchemaP:
	pop	esi
	pop	edi

; 10980:     }
; 10981: 
; 10982:     return(0);

	xor	eax, eax

; 10987: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlSchemaP:

; 2802 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	0
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	mov	eax, DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0P@DEMHLMFE@schemaLocation@
	push	eax
	push	OFFSET ??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0P@DEMHLMFE@schemaLocation@
	push	eax
	inc	DWORD PTR [edi+20]
	push	0
	push	0
	push	2
	push	3036					; 00000bdcH
	push	16					; 00000010H
	push	ebx
	push	edi
	push	DWORD PTR [edi+4]
	mov	DWORD PTR [edi+16], 3036		; 00000bdcH
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+24]
	call	___xmlRaiseError

; 2810 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$1[ebp]

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 88					; 00000058H

; 2810 :     FREE_AND_NULL(des);

	test	eax, eax
	je	SHORT $exit_error$35
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$exit_error$35:

; 10983: exit_error:
; 10984:     return(pctxt->err);

	mov	eax, DWORD PTR [edi+16]
	pop	esi
	pop	edi

; 10987: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlSchemaP:
	pop	edi

; 10903: 	(schemaLocation == NULL))
; 10904:         return (-1);

	or	eax, -1

; 10987: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseIncludeOrRedefineAttrs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddSchemaDoc
_TEXT	SEGMENT
_targetNamespace$1$ = -28				; size = 4
_preserveDoc$1$ = -24					; size = 4
_located$1$ = -20					; size = 4
tv1578 = -16						; size = 4
_docElem$1$ = -16					; size = 4
_msg$1 = -16						; size = 4
_relation$1$ = -12					; size = 4
_doc$1$ = -8						; size = 4
_schemaLocation$1$ = -4					; size = 4
_pctxt$ = 8						; size = 4
_msg$2 = 12						; size = 4
_msg$3 = 12						; size = 4
_type$ = 12						; size = 4
_schemaLocation$ = 16					; size = 4
_schemaDoc$ = 20					; size = 4
_schemaBuffer$ = 24					; size = 4
_schemaBufferLen$ = 28					; size = 4
_invokingNode$ = 32					; size = 4
_sourceTargetNamespace$ = 36				; size = 4
_importNamespace$ = 40					; size = 4
_bucket$ = 44						; size = 4
_xmlSchemaAddSchemaDoc PROC				; COMDAT

; 10333: {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	xor	ecx, ecx
	mov	DWORD PTR _targetNamespace$1$[ebp], eax
	xor	esi, esi
	mov	DWORD PTR _relation$1$[ebp], eax
	xor	edi, edi
	mov	DWORD PTR _doc$1$[ebp], eax
	mov	DWORD PTR _preserveDoc$1$[ebp], eax
	mov	eax, DWORD PTR _bucket$[ebp]
	mov	DWORD PTR _located$1$[ebp], ecx
	test	eax, eax
	je	SHORT $LN4@xmlSchemaA

; 10334:     const xmlChar *targetNamespace = NULL;
; 10335:     xmlSchemaSchemaRelationPtr relation = NULL;
; 10336:     xmlDocPtr doc = NULL;
; 10337:     int res = 0, err = 0, located = 0, preserveDoc = 0;
; 10338:     xmlSchemaBucketPtr bkt = NULL;
; 10339: 
; 10340:     if (bucket != NULL)
; 10341: 	*bucket = NULL;

	mov	DWORD PTR [eax], ecx
$LN4@xmlSchemaA:

; 10342: 
; 10343:     switch (type) {

	mov	eax, DWORD PTR _type$[ebp]
	cmp	eax, 3
	ja	SHORT $LN2@xmlSchemaA
	jmp	DWORD PTR $LN230@xmlSchemaA[eax*4]
$LN5@xmlSchemaA:

; 10344: 	case XML_SCHEMA_SCHEMA_IMPORT:
; 10345: 	case XML_SCHEMA_SCHEMA_MAIN:
; 10346: 	    err = XML_SCHEMAP_SRC_IMPORT;

	mov	esi, 3082				; 00000c0aH
$LN2@xmlSchemaA:

; 10353: 	    break;
; 10354:     }
; 10355: 
; 10356: 
; 10357:     /* Special handling for the main schema:
; 10358:     * skip the location and relation logic and just parse the doc.
; 10359:     * We need just a bucket to be returned in this case.
; 10360:     */
; 10361:     if ((type == XML_SCHEMA_SCHEMA_MAIN) || (! WXS_HAS_BUCKETS(pctxt)))

	test	eax, eax
	je	$LN214@xmlSchemaA
$LN204@xmlSchemaA:
	mov	ebx, DWORD PTR _pctxt$[ebp]
	mov	ebx, DWORD PTR [ebx+28]
	mov	DWORD PTR tv1578[ebp], ebx
	mov	eax, DWORD PTR [ebx+12]
	test	eax, eax
	je	$LN214@xmlSchemaA
	mov	edx, DWORD PTR [eax+4]
	test	edx, edx
	jle	$LN214@xmlSchemaA

; 10362: 	goto doc_load;
; 10363: 
; 10364:     /* Note that we expect the location to be an absulute URI. */
; 10365:     if (schemaLocation != NULL) {

	mov	ecx, DWORD PTR _schemaLocation$[ebp]
	mov	DWORD PTR _schemaLocation$1$[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN12@xmlSchemaA

; 10071: 	for (i = 0; i < list->nbItems; i++) {

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN77@xmlSchemaA

; 10072: 	    cur = (xmlSchemaBucketPtr) list->items[i];

	mov	eax, DWORD PTR [eax]
$LL78@xmlSchemaA:
	mov	edi, DWORD PTR [eax]

; 10073: 	    /* Pointer comparison! */
; 10074: 	    if (cur->schemaLocation == schemaLocation)

	mov	ebx, DWORD PTR _schemaLocation$[ebp]
	cmp	DWORD PTR [edi+8], ebx
	mov	ebx, DWORD PTR tv1578[ebp]
	je	SHORT $LN173@xmlSchemaA

; 9902 :     return(ret);
; 9903 : }
; 9904 : 
; 9905 : #if 0
; 9906 : static void
; 9907 : xmlSchemaSchemaRelationFree(xmlSchemaSchemaRelationPtr rel)
; 9908 : {
; 9909 :     xmlFree(rel);
; 9910 : }
; 9911 : #endif
; 9912 : 
; 9913 : static void
; 9914 : xmlSchemaRedefListFree(xmlSchemaRedefPtr redef)
; 9915 : {
; 9916 :     xmlSchemaRedefPtr prev;
; 9917 : 
; 9918 :     while (redef != NULL) {
; 9919 : 	prev = redef;
; 9920 : 	redef = redef->next;
; 9921 : 	xmlFree(prev);
; 9922 :     }
; 9923 : }
; 9924 : 
; 9925 : static void
; 9926 : xmlSchemaConstructionCtxtFree(xmlSchemaConstructionCtxtPtr con)
; 9927 : {
; 9928 :     /*
; 9929 :     * After the construction context has been freed, there will be
; 9930 :     * no schema graph available any more. Only the schema buckets
; 9931 :     * will stay alive, which are put into the "schemasImports" and
; 9932 :     * "includes" slots of the xmlSchema.
; 9933 :     */
; 9934 :     if (con->buckets != NULL)
; 9935 : 	xmlSchemaItemListFree(con->buckets);
; 9936 :     if (con->pending != NULL)
; 9937 : 	xmlSchemaItemListFree(con->pending);
; 9938 :     if (con->substGroups != NULL)
; 9939 : 	xmlHashFree(con->substGroups, xmlSchemaSubstGroupFreeEntry);
; 9940 :     if (con->redefs != NULL)
; 9941 : 	xmlSchemaRedefListFree(con->redefs);
; 9942 :     if (con->dict != NULL)
; 9943 : 	xmlDictFree(con->dict);
; 9944 :     xmlFree(con);
; 9945 : }
; 9946 : 
; 9947 : static xmlSchemaConstructionCtxtPtr
; 9948 : xmlSchemaConstructionCtxtCreate(xmlDictPtr dict)
; 9949 : {
; 9950 :     xmlSchemaConstructionCtxtPtr ret;
; 9951 : 
; 9952 :     ret = (xmlSchemaConstructionCtxtPtr)
; 9953 : 	xmlMalloc(sizeof(xmlSchemaConstructionCtxt));
; 9954 :     if (ret == NULL) {
; 9955 :         xmlSchemaPErrMemory(NULL,
; 9956 : 	    "allocating schema construction context", NULL);
; 9957 :         return (NULL);
; 9958 :     }
; 9959 :     memset(ret, 0, sizeof(xmlSchemaConstructionCtxt));
; 9960 : 
; 9961 :     ret->buckets = xmlSchemaItemListCreate();
; 9962 :     if (ret->buckets == NULL) {
; 9963 : 	xmlSchemaPErrMemory(NULL,
; 9964 : 	    "allocating list of schema buckets", NULL);
; 9965 : 	xmlFree(ret);
; 9966 :         return (NULL);
; 9967 :     }
; 9968 :     ret->pending = xmlSchemaItemListCreate();
; 9969 :     if (ret->pending == NULL) {
; 9970 : 	xmlSchemaPErrMemory(NULL,
; 9971 : 	    "allocating list of pending global components", NULL);
; 9972 : 	xmlSchemaConstructionCtxtFree(ret);
; 9973 :         return (NULL);
; 9974 :     }
; 9975 :     ret->dict = dict;
; 9976 :     xmlDictReference(dict);
; 9977 :     return(ret);
; 9978 : }
; 9979 : 
; 9980 : static xmlSchemaParserCtxtPtr
; 9981 : xmlSchemaParserCtxtCreate(void)
; 9982 : {
; 9983 :     xmlSchemaParserCtxtPtr ret;
; 9984 : 
; 9985 :     ret = (xmlSchemaParserCtxtPtr) xmlMalloc(sizeof(xmlSchemaParserCtxt));
; 9986 :     if (ret == NULL) {
; 9987 :         xmlSchemaPErrMemory(NULL, "allocating schema parser context",
; 9988 :                             NULL);
; 9989 :         return (NULL);
; 9990 :     }
; 9991 :     memset(ret, 0, sizeof(xmlSchemaParserCtxt));
; 9992 :     ret->type = XML_SCHEMA_CTXT_PARSER;
; 9993 :     ret->attrProhibs = xmlSchemaItemListCreate();
; 9994 :     if (ret->attrProhibs == NULL) {
; 9995 : 	xmlFree(ret);
; 9996 : 	return(NULL);
; 9997 :     }
; 9998 :     return(ret);
; 9999 : }
; 10000: 
; 10001: /**
; 10002:  * xmlSchemaNewParserCtxtUseDict:
; 10003:  * @URL:  the location of the schema
; 10004:  * @dict: the dictionary to be used
; 10005:  *
; 10006:  * Create an XML Schemas parse context for that file/resource expected
; 10007:  * to contain an XML Schemas file.
; 10008:  *
; 10009:  * Returns the parser context or NULL in case of error
; 10010:  */
; 10011: static xmlSchemaParserCtxtPtr
; 10012: xmlSchemaNewParserCtxtUseDict(const char *URL, xmlDictPtr dict)
; 10013: {
; 10014:     xmlSchemaParserCtxtPtr ret;
; 10015: 
; 10016:     ret = xmlSchemaParserCtxtCreate();
; 10017:     if (ret == NULL)
; 10018:         return (NULL);
; 10019:     ret->dict = dict;
; 10020:     xmlDictReference(dict);
; 10021:     if (URL != NULL)
; 10022: 	ret->URL = xmlDictLookup(dict, (const xmlChar *) URL, -1);
; 10023:     return (ret);
; 10024: }
; 10025: 
; 10026: static int
; 10027: xmlSchemaCreatePCtxtOnVCtxt(xmlSchemaValidCtxtPtr vctxt)
; 10028: {
; 10029:     if (vctxt->pctxt == NULL) {
; 10030:         if (vctxt->schema != NULL)
; 10031: 	    vctxt->pctxt =
; 10032: 		xmlSchemaNewParserCtxtUseDict("*", vctxt->schema->dict);
; 10033: 	else
; 10034: 	    vctxt->pctxt = xmlSchemaNewParserCtxt("*");
; 10035: 	if (vctxt->pctxt == NULL) {
; 10036: 	    VERROR_INT("xmlSchemaCreatePCtxtOnVCtxt",
; 10037: 		"failed to create a temp. parser context");
; 10038: 	    return (-1);
; 10039: 	}
; 10040: 	/* TODO: Pass user data. */
; 10041: 	xmlSchemaSetParserErrors(vctxt->pctxt, vctxt->error,
; 10042: 	    vctxt->warning, vctxt->errCtxt);
; 10043: 	xmlSchemaSetParserStructuredErrors(vctxt->pctxt, vctxt->serror,
; 10044: 	    vctxt->errCtxt);
; 10045:     }
; 10046:     return (0);
; 10047: }
; 10048: 
; 10049: /**
; 10050:  * xmlSchemaGetSchemaBucket:
; 10051:  * @pctxt: the schema parser context
; 10052:  * @schemaLocation: the URI of the schema document
; 10053:  *
; 10054:  * Returns a schema bucket if it was already parsed.
; 10055:  *
; 10056:  * Returns a schema bucket if it was already parsed from
; 10057:  *         @schemaLocation, NULL otherwise.
; 10058:  */
; 10059: static xmlSchemaBucketPtr
; 10060: xmlSchemaGetSchemaBucket(xmlSchemaParserCtxtPtr pctxt,
; 10061: 			    const xmlChar *schemaLocation)
; 10062: {
; 10063:     xmlSchemaBucketPtr cur;
; 10064:     xmlSchemaItemListPtr list;
; 10065: 
; 10066:     list = pctxt->constructor->buckets;
; 10067:     if (list->nbItems == 0)
; 10068: 	return(NULL);
; 10069:     else {
; 10070: 	int i;
; 10071: 	for (i = 0; i < list->nbItems; i++) {

	inc	ecx
	add	eax, 4
	cmp	ecx, edx
	jl	SHORT $LL78@xmlSchemaA
$LN77@xmlSchemaA:

; 10075: 		return(cur);
; 10076: 	}
; 10077:     }
; 10078:     return(NULL);

	xor	edi, edi
$LN12@xmlSchemaA:

; 9895 :     ret = (xmlSchemaSchemaRelationPtr)

	push	16					; 00000010H
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _relation$1$[ebp], ebx

; 9896 : 	xmlMalloc(sizeof(xmlSchemaSchemaRelation));
; 9897 :     if (ret == NULL) {

	test	ebx, ebx
	jne	SHORT $LN84@xmlSchemaA

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BL@CHFLODC@allocating?5schema?5relation@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 10372: 		invokingNode, NULL,
; 10373: 		"The schema must not import/include/redefine itself",
; 10374: 		NULL, NULL);
; 10375: 	    goto exit;
; 10376: 	}
; 10377:     }
; 10378:     /*
; 10379:     * Create a relation for the graph of schemas.
; 10380:     */
; 10381:     relation = xmlSchemaSchemaRelationCreate();
; 10382:     if (relation == NULL)
; 10383: 	return(-1);

	or	eax, -1
	pop	edi

; 10732: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlSchemaA:

; 10347: 	    break;
; 10348: 	case XML_SCHEMA_SCHEMA_INCLUDE:
; 10349: 	    err = XML_SCHEMAP_SRC_INCLUDE;

	mov	esi, 3050				; 00000beaH

; 10350: 	    break;

	jmp	SHORT $LN204@xmlSchemaA
$LN7@xmlSchemaA:

; 10351: 	case XML_SCHEMA_SCHEMA_REDEFINE:
; 10352: 	    err = XML_SCHEMAP_SRC_REDEFINE;

	mov	esi, 3081				; 00000c09H

; 10353: 	    break;
; 10354:     }
; 10355: 
; 10356: 
; 10357:     /* Special handling for the main schema:
; 10358:     * skip the location and relation logic and just parse the doc.
; 10359:     * We need just a bucket to be returned in this case.
; 10360:     */
; 10361:     if ((type == XML_SCHEMA_SCHEMA_MAIN) || (! WXS_HAS_BUCKETS(pctxt)))

	jmp	$LN204@xmlSchemaA
$LN173@xmlSchemaA:

; 10366: 	bkt = xmlSchemaGetSchemaBucket(pctxt, schemaLocation);
; 10367: 	if ((bkt != NULL) &&

	cmp	DWORD PTR [ebx+16], edi
	jne	SHORT $LN12@xmlSchemaA

; 10368: 	    (pctxt->constructor->bucket == bkt)) {
; 10369: 	    /* Report self-imports/inclusions/redefinitions. */
; 10370: 
; 10371: 	    xmlSchemaCustomErr(ACTXT_CAST pctxt, err,

	push	0
	push	0
	push	OFFSET ??_C@_0DD@JJBMBON@The?5schema?5must?5not?5import?1incl@
$LN228@xmlSchemaA:

; 10705: 	    relation->bucket = bkt;
; 10706:     }
; 10707: 
; 10708: exit:
; 10709:     /*
; 10710:     * Return the bucket explicitely; this is needed for the
; 10711:     * main schema.
; 10712:     */
; 10713:     if (bucket != NULL)

	push	0
	push	DWORD PTR _invokingNode$[ebp]
	push	esi
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaCustomErr
	add	esp, 28					; 0000001cH
	jmp	$exit$231
$LN84@xmlSchemaA:

; 10384:     xmlSchemaSchemaRelationAddChild(pctxt->constructor->bucket,

	mov	eax, DWORD PTR _pctxt$[ebp]
	xorps	xmm0, xmm0

; 9901 :     memset(ret, 0, sizeof(xmlSchemaSchemaRelation));

	movups	XMMWORD PTR [ebx], xmm0

; 10384:     xmlSchemaSchemaRelationAddChild(pctxt->constructor->bucket,

	mov	eax, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [eax+16]

; 10265:     xmlSchemaSchemaRelationPtr cur = bucket->relations;

	mov	edx, DWORD PTR [eax+24]

; 10266: 
; 10267:     if (cur == NULL) {

	test	edx, edx
	jne	SHORT $LN168@xmlSchemaA

; 10268: 	bucket->relations = rel;

	mov	DWORD PTR [eax+24], ebx

; 10269: 	return;

	jmp	SHORT $LN89@xmlSchemaA
$LN168@xmlSchemaA:

; 10270:     }
; 10271:     while (cur->next != NULL)

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $LN91@xmlSchemaA
	npad	2
$LL90@xmlSchemaA:
	mov	eax, DWORD PTR [ecx]

; 10272: 	cur = cur->next;

	mov	edx, ecx
	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL90@xmlSchemaA
$LN91@xmlSchemaA:

; 10273:     cur->next = rel;

	mov	DWORD PTR [edx], ebx
$LN89@xmlSchemaA:

; 10385: 	relation);
; 10386:     relation->type = type;

	mov	eax, DWORD PTR _type$[ebp]

; 10387: 
; 10388:     /*
; 10389:     * Save the namespace import information.
; 10390:     */
; 10391:     if (WXS_IS_BUCKET_IMPMAIN(type)) {

	mov	edx, DWORD PTR _schemaLocation$[ebp]
	mov	DWORD PTR [ebx+4], eax
	mov	ebx, DWORD PTR _importNamespace$[ebp]
	cmp	eax, 1
	jne	SHORT $LN14@xmlSchemaA

; 10392: 	relation->importNamespace = importNamespace;

	mov	eax, DWORD PTR _relation$1$[ebp]
	mov	DWORD PTR [eax+8], ebx

; 10393: 	if (schemaLocation == NULL) {

	test	edx, edx
	je	$exit$231

; 10394: 	    /*
; 10395: 	    * No location; this is just an import of the namespace.
; 10396: 	    * Note that we don't assign a bucket to the relation
; 10397: 	    * in this case.
; 10398: 	    */
; 10399: 	    goto exit;
; 10400: 	}
; 10401: 	targetNamespace = importNamespace;

	mov	DWORD PTR _targetNamespace$1$[ebp], ebx
$LN14@xmlSchemaA:

; 10402:     }
; 10403: 
; 10404:     /* Did we already fetch the doc? */
; 10405:     if (bkt != NULL) {

	mov	ecx, OFFSET ??_C@_0BB@IEONCAEH@in_memory_buffer@
	test	edi, edi
	je	SHORT $LN25@xmlSchemaA

; 10406: 	if ((WXS_IS_BUCKET_IMPMAIN(type)) && (! bkt->imported)) {

	cmp	DWORD PTR _type$[ebp], 1
	mov	eax, DWORD PTR [edi+36]
	jne	SHORT $LN205@xmlSchemaA
	test	eax, eax
	jne	$LN28@xmlSchemaA

; 10407: 	    /*
; 10408: 	    * We included/redefined and then try to import a schema,
; 10409: 	    * but the new location provided for import was different.
; 10410: 	    */
; 10411: 	    if (schemaLocation == NULL)
; 10412: 		schemaLocation = BAD_CAST "in_memory_buffer";
; 10413: 	    if (!xmlStrEqual(schemaLocation,

	push	DWORD PTR [edi+8]
	test	edx, edx
	mov	eax, ecx
	cmovne	eax, edx
	push	eax
	mov	DWORD PTR _schemaLocation$1$[ebp], eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN28@xmlSchemaA

; 10414: 		bkt->schemaLocation)) {
; 10415: 		xmlSchemaCustomErr(ACTXT_CAST pctxt, err,

	push	eax
	push	DWORD PTR _schemaLocation$1$[ebp]
	push	OFFSET ??_C@_0FI@DLHCDBDL@The?5schema?5document?5?8?$CFs?8?5cannot@

; 10416: 		    invokingNode, NULL,
; 10417: 		    "The schema document '%s' cannot be imported, since "
; 10418: 		    "it was already included or redefined",
; 10419: 		    schemaLocation, NULL);
; 10420: 		goto exit;

	jmp	$LN228@xmlSchemaA
$LN205@xmlSchemaA:

; 10421: 	    }
; 10422: 	} else if ((! WXS_IS_BUCKET_IMPMAIN(type)) && (bkt->imported)) {

	test	eax, eax
	je	SHORT $LN25@xmlSchemaA

; 10423: 	    /*
; 10424: 	    * We imported and then try to include/redefine a schema,
; 10425: 	    * but the new location provided for the include/redefine
; 10426: 	    * was different.
; 10427: 	    */
; 10428: 	    if (schemaLocation == NULL)
; 10429: 		schemaLocation = BAD_CAST "in_memory_buffer";
; 10430: 	    if (!xmlStrEqual(schemaLocation,

	push	DWORD PTR [edi+8]
	test	edx, edx
	mov	eax, ecx
	cmovne	eax, edx
	push	eax
	mov	DWORD PTR _schemaLocation$1$[ebp], eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@xmlSchemaA

; 10431: 		bkt->schemaLocation)) {
; 10432: 		xmlSchemaCustomErr(ACTXT_CAST pctxt, err,

	push	eax
	push	DWORD PTR _schemaLocation$1$[ebp]
	push	OFFSET ??_C@_0FI@DIIKKJHP@The?5schema?5document?5?8?$CFs?8?5cannot@

; 10433: 		    invokingNode, NULL,
; 10434: 		    "The schema document '%s' cannot be included or "
; 10435: 		    "redefined, since it was already imported",
; 10436: 		    schemaLocation, NULL);
; 10437: 		goto exit;

	jmp	$LN228@xmlSchemaA
$LN25@xmlSchemaA:

; 10438: 	    }
; 10439: 	}
; 10440:     }
; 10441: 
; 10442:     if (WXS_IS_BUCKET_IMPMAIN(type)) {

	cmp	DWORD PTR _type$[ebp], 1
	je	$LN28@xmlSchemaA

; 10495: 	    }
; 10496: 	}
; 10497: 	/*
; 10498: 	* No bucket + first location: load the doc and create a
; 10499: 	* bucket.
; 10500: 	*/
; 10501:     } else {
; 10502: 	/* <include> and <redefine> */
; 10503: 	if (bkt != NULL) {

	test	edi, edi
	je	SHORT $LN217@xmlSchemaA

; 10504: 
; 10505: 	    if ((bkt->origTargetNamespace == NULL) &&

	cmp	DWORD PTR [edi+12], 0
	jne	$LN36@xmlSchemaA
	mov	ebx, DWORD PTR _sourceTargetNamespace$[ebp]
	cmp	DWORD PTR [edi+16], ebx
	je	$LN36@xmlSchemaA

; 10089:     list = pctxt->constructor->buckets;

	mov	eax, DWORD PTR _pctxt$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	ecx, DWORD PTR [eax+12]

; 10090:     if (list->nbItems == 0)

	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN210@xmlSchemaA

; 10091: 	return(NULL);
; 10092:     else {
; 10093: 	int i;
; 10094: 	for (i = 0; i < list->nbItems; i++) {

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN210@xmlSchemaA

; 10095: 	    cur = (xmlSchemaBucketPtr) list->items[i];

	mov	ecx, DWORD PTR [ecx]
	npad	4
$LL108@xmlSchemaA:
	mov	eax, DWORD PTR [ecx]

; 10096: 	    /* Pointer comparison! */
; 10097: 	    if ((cur->origTargetNamespace == NULL) &&
; 10098: 		(cur->schemaLocation == schemaLocation) &&

	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN106@xmlSchemaA
	mov	ebx, DWORD PTR _schemaLocation$1$[ebp]
	cmp	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR _sourceTargetNamespace$[ebp]
	jne	SHORT $LN106@xmlSchemaA
	cmp	DWORD PTR [eax+16], ebx
	je	$LN105@xmlSchemaA
$LN106@xmlSchemaA:

; 10091: 	return(NULL);
; 10092:     else {
; 10093: 	int i;
; 10094: 	for (i = 0; i < list->nbItems; i++) {

	inc	edx
	add	ecx, 4
	cmp	edx, esi
	jl	SHORT $LL108@xmlSchemaA
$LN210@xmlSchemaA:

; 10532: 		}
; 10533: 		/*
; 10534: 		* We need to parse the chameleon again for a different
; 10535: 		* targetNamespace.
; 10536: 		* CHAMELEON TODO: Optimize this by only parsing the
; 10537: 		* chameleon once, and then copying the components to
; 10538: 		* the new targetNamespace.
; 10539: 		*/
; 10540: 		bkt = NULL;

	xor	edi, edi
$LN217@xmlSchemaA:

; 10549: 	    "trying to load a schema doc, but a doc is already "
; 10550: 	    "assigned to the schema bucket");
; 10551: 	goto exit_failure;
; 10552:     }
; 10553: 
; 10554: doc_load:
; 10555:     /*
; 10556:     * Load the document.
; 10557:     */
; 10558:     if (schemaDoc != NULL) {

	mov	esi, DWORD PTR _pctxt$[ebp]
$LN223@xmlSchemaA:
	mov	ecx, DWORD PTR _schemaLocation$1$[ebp]
$doc_load$232:
	mov	eax, DWORD PTR _schemaDoc$[ebp]
	test	eax, eax
	je	$LN40@xmlSchemaA

; 10559: 	doc = schemaDoc;

	mov	DWORD PTR _doc$1$[ebp], eax

; 10560: 	/* Don' free this one, since it was provided by the caller. */
; 10561: 	preserveDoc = 1;
; 10562: 	/* TODO: Does the context or the doc hold the location? */
; 10563: 	if (schemaDoc->URL != NULL)

	mov	eax, DWORD PTR [eax+72]
	mov	DWORD PTR _preserveDoc$1$[ebp], 1
	test	eax, eax
	je	$LN42@xmlSchemaA

; 10564: 	    schemaLocation = xmlDictLookup(pctxt->dict,

	push	-1
	push	eax
	push	DWORD PTR [esi+80]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	ebx, eax
$LN224@xmlSchemaA:

; 10648: 	xmlNodePtr docElem = NULL;
; 10649: 
; 10650: 	located = 1;

	mov	eax, DWORD PTR _doc$1$[ebp]
	mov	DWORD PTR _schemaLocation$1$[ebp], ebx
$LN56@xmlSchemaA:

; 10651: 	docElem = xmlDocGetRootElement(doc);

	push	eax
	mov	DWORD PTR _located$1$[ebp], 1
	call	_xmlDocGetRootElement
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _docElem$1$[ebp], esi

; 10652: 	if (docElem == NULL) {

	test	esi, esi
	jne	$LN58@xmlSchemaA

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	DWORD PTR _invokingNode$[ebp]
	mov	esi, DWORD PTR _pctxt$[ebp]
	mov	DWORD PTR _msg$3[ebp], eax
	lea	eax, DWORD PTR _msg$3[ebp]
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0CK@LEAJAMEE@The?5document?5?8?$CFs?8?5has?5no?5docume@
	push	DWORD PTR _msg$3[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$3[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	ebx
	push	eax
	push	0
	push	DWORD PTR _invokingNode$[ebp]
	push	1759					; 000006dfH
	push	2
	push	esi

; 10653: 	    xmlSchemaCustomErr(ACTXT_CAST pctxt, XML_SCHEMAP_NOROOT,
; 10654: 		invokingNode, NULL,
; 10655: 		"The document '%s' has no document element",
; 10656: 		schemaLocation, NULL);
; 10657: 	    goto exit_error;

	jmp	$LN226@xmlSchemaA
$LN105@xmlSchemaA:

; 10506: 		(bkt->targetNamespace != sourceTargetNamespace)) {
; 10507: 		xmlSchemaBucketPtr chamel;
; 10508: 
; 10509: 		/*
; 10510: 		* Chameleon include/redefine: skip loading only if it was
; 10511: 		* aleady build for the targetNamespace of the including
; 10512: 		* schema.
; 10513: 		*/
; 10514: 		/*
; 10515: 		* URGENT TODO: If the schema is a chameleon-include then copy
; 10516: 		* the components into the including schema and modify the
; 10517: 		* targetNamespace of those components, do nothing otherwise.
; 10518: 		* NOTE: This is currently worked-around by compiling the
; 10519: 		* chameleon for every destinct including targetNamespace; thus
; 10520: 		* not performant at the moment.
; 10521: 		* TODO: Check when the namespace in wildcards for chameleons
; 10522: 		* needs to be converted: before we built wildcard intersections
; 10523: 		* or after.
; 10524: 		*   Answer: after!
; 10525: 		*/
; 10526: 		chamel = xmlSchemaGetChameleonSchemaBucket(pctxt,
; 10527: 		    schemaLocation, sourceTargetNamespace);
; 10528: 		if (chamel != NULL) {
; 10529: 		    /* A fitting chameleon was already parsed; NOP. */
; 10530: 		    relation->bucket = chamel;

	mov	ecx, DWORD PTR _relation$1$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 10531: 		    goto exit;

	jmp	$exit$231
$LN28@xmlSchemaA:

; 10443: 	/*
; 10444: 	* Given that the schemaLocation [attribute] is only a hint, it is open
; 10445: 	* to applications to ignore all but the first <import> for a given
; 10446: 	* namespace, regardless of the `actual value` of schemaLocation, but
; 10447: 	* such a strategy risks missing useful information when new
; 10448: 	* schemaLocations are offered.
; 10449: 	*
; 10450: 	* We will use the first <import> that comes with a location.
; 10451: 	* Further <import>s *with* a location, will result in an error.
; 10452: 	* TODO: Better would be to just report a warning here, but
; 10453: 	* we'll try it this way until someone complains.
; 10454: 	*
; 10455: 	* Schema Document Location Strategy:
; 10456: 	* 3 Based on the namespace name, identify an existing schema document,
; 10457: 	* either as a resource which is an XML document or a <schema> element
; 10458: 	* information item, in some local schema repository;
; 10459: 	* 5 Attempt to resolve the namespace name to locate such a resource.
; 10460: 	*
; 10461: 	* NOTE: (3) and (5) are not supported.
; 10462: 	*/
; 10463: 	if (bkt != NULL) {

	test	edi, edi
	je	SHORT $LN29@xmlSchemaA
$LN36@xmlSchemaA:

; 10705: 	    relation->bucket = bkt;
; 10706:     }
; 10707: 
; 10708: exit:
; 10709:     /*
; 10710:     * Return the bucket explicitely; this is needed for the
; 10711:     * main schema.
; 10712:     */
; 10713:     if (bucket != NULL)

	mov	eax, DWORD PTR _relation$1$[ebp]
	jmp	$LN222@xmlSchemaA
$LN29@xmlSchemaA:

; 10118:     list = pctxt->constructor->buckets;

	mov	esi, DWORD PTR _pctxt$[ebp]
	mov	eax, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [eax+12]

; 10119:     if (list->nbItems == 0)

	mov	edx, DWORD PTR [eax+4]
	test	edx, edx
	jne	SHORT $LN98@xmlSchemaA
$LN211@xmlSchemaA:

; 10549: 	    "trying to load a schema doc, but a doc is already "
; 10550: 	    "assigned to the schema bucket");
; 10551: 	goto exit_failure;
; 10552:     }
; 10553: 
; 10554: doc_load:
; 10555:     /*
; 10556:     * Load the document.
; 10557:     */
; 10558:     if (schemaDoc != NULL) {

	xor	edi, edi
	jmp	$LN223@xmlSchemaA
$LN98@xmlSchemaA:

; 10123: 	for (i = 0; i < list->nbItems; i++) {

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN211@xmlSchemaA

; 10124: 	    cur = (xmlSchemaBucketPtr) list->items[i];

	mov	eax, DWORD PTR [eax]
	npad	3
$LL97@xmlSchemaA:
	mov	edi, DWORD PTR [eax]

; 10125: 	    if ((! IS_BAD_SCHEMA_DOC(cur)) &&
; 10126: 		(cur->origTargetNamespace == targetNamespace) &&

	cmp	DWORD PTR [edi+20], 0
	jne	SHORT $LN207@xmlSchemaA
	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN95@xmlSchemaA
$LN207@xmlSchemaA:
	cmp	DWORD PTR [edi+12], ebx
	jne	SHORT $LN95@xmlSchemaA
	cmp	DWORD PTR [edi+36], 0
	jne	SHORT $LN102@xmlSchemaA
$LN95@xmlSchemaA:

; 10120: 	return(NULL);
; 10121:     else {
; 10122: 	int i;
; 10123: 	for (i = 0; i < list->nbItems; i++) {

	inc	ecx
	add	eax, 4
	cmp	ecx, edx
	jl	SHORT $LL97@xmlSchemaA

; 10549: 	    "trying to load a schema doc, but a doc is already "
; 10550: 	    "assigned to the schema bucket");
; 10551: 	goto exit_failure;
; 10552:     }
; 10553: 
; 10554: doc_load:
; 10555:     /*
; 10556:     * Load the document.
; 10557:     */
; 10558:     if (schemaDoc != NULL) {

	xor	edi, edi
	jmp	$LN223@xmlSchemaA
$LN102@xmlSchemaA:

; 10464: 	    relation->bucket = bkt;
; 10465: 	    goto exit;
; 10466: 	}
; 10467: 	bkt = xmlSchemaGetSchemaBucketByTNS(pctxt,
; 10468: 	    importNamespace, 1);
; 10469: 
; 10470: 	if (bkt != NULL) {
; 10471: 	    relation->bucket = bkt;

	mov	eax, DWORD PTR _relation$1$[ebp]
	mov	DWORD PTR [eax+12], edi

; 10472: 	    if (bkt->schemaLocation == NULL) {

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	jne	SHORT $LN31@xmlSchemaA

; 10473: 		/* First given location of the schema; load the doc. */
; 10474: 		bkt->schemaLocation = schemaLocation;

	mov	ecx, DWORD PTR _schemaLocation$1$[ebp]
	mov	DWORD PTR [edi+8], ecx

; 10541: 	    } else {
; 10542: 		relation->bucket = bkt;
; 10543: 		goto exit;
; 10544: 	    }
; 10545: 	}
; 10546:     }
; 10547:     if ((bkt != NULL) && (bkt->doc != NULL)) {

	cmp	DWORD PTR [edi+20], eax
	je	$doc_load$232

; 10548: 	PERROR_INT("xmlSchemaAddSchemaDoc",

	push	OFFSET ??_C@_0FA@FCNDNFNE@trying?5to?5load?5a?5schema?5doc?0?5bu@
	push	OFFSET ??_C@_0BG@PEDNHGDB@xmlSchemaAddSchemaDoc@
	push	esi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH

; 10728: 	if (bkt != NULL)
; 10729: 	    bkt->doc = NULL;
; 10730:     }
; 10731:     return (-1);

	or	eax, -1
	pop	edi

; 10732: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlSchemaA:

; 10475: 	    } else {
; 10476: 		if (!xmlStrEqual(schemaLocation,

	mov	esi, DWORD PTR _schemaLocation$1$[ebp]
	push	eax
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$exit$231

; 10477: 		    bkt->schemaLocation)) {
; 10478: 		    /*
; 10479: 		    * Additional location given; just skip it.
; 10480: 		    * URGENT TODO: We should report a warning here.
; 10481: 		    * res = XML_SCHEMAP_SRC_IMPORT;
; 10482: 		    */
; 10483: 		    if (schemaLocation == NULL)
; 10484: 			schemaLocation = BAD_CAST "in_memory_buffer";
; 10485: 
; 10486: 		    xmlSchemaCustomWarning(ACTXT_CAST pctxt,

	push	DWORD PTR [edi+8]
	test	esi, esi
	mov	eax, OFFSET ??_C@_0BB@IEONCAEH@in_memory_buffer@
	push	ebx
	cmovne	eax, esi
	push	eax
	push	OFFSET ??_C@_0IM@HCCFLAGC@Skipping?5import?5of?5schema?5locat@
	push	0
	push	DWORD PTR _invokingNode$[ebp]
	push	3083					; 00000c0bH
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaCustomWarning
	add	esp, 32					; 00000020H

; 10487: 			XML_SCHEMAP_WARN_SKIP_SCHEMA,
; 10488: 			invokingNode, NULL,
; 10489: 			"Skipping import of schema located at '%s' for the "
; 10490: 			"namespace '%s', since this namespace was already "
; 10491: 			"imported with the schema located at '%s'",
; 10492: 			schemaLocation, importNamespace, bkt->schemaLocation);
; 10493: 		}
; 10494: 		goto exit;

	jmp	$exit$231
$LN214@xmlSchemaA:

; 10353: 	    break;
; 10354:     }
; 10355: 
; 10356: 
; 10357:     /* Special handling for the main schema:
; 10358:     * skip the location and relation logic and just parse the doc.
; 10359:     * We need just a bucket to be returned in this case.
; 10360:     */
; 10361:     if ((type == XML_SCHEMA_SCHEMA_MAIN) || (! WXS_HAS_BUCKETS(pctxt)))

	mov	ecx, DWORD PTR _schemaLocation$[ebp]

; 10495: 	    }
; 10496: 	}
; 10497: 	/*
; 10498: 	* No bucket + first location: load the doc and create a
; 10499: 	* bucket.
; 10500: 	*/
; 10501:     } else {
; 10502: 	/* <include> and <redefine> */
; 10503: 	if (bkt != NULL) {

	mov	esi, DWORD PTR _pctxt$[ebp]
	mov	DWORD PTR _schemaLocation$1$[ebp], ecx
	jmp	$doc_load$232
$LN42@xmlSchemaA:

; 10565: 		schemaDoc->URL, -1);
; 10566:         else
; 10567: 	    schemaLocation = BAD_CAST "in_memory_buffer";

	mov	ebx, OFFSET ??_C@_0BB@IEONCAEH@in_memory_buffer@

; 10568:     } else if ((schemaLocation != NULL) || (schemaBuffer != NULL)) {

	jmp	$LN224@xmlSchemaA
$LN40@xmlSchemaA:
	mov	ebx, DWORD PTR _schemaBuffer$[ebp]
	test	ecx, ecx
	jne	SHORT $LN46@xmlSchemaA
	test	ebx, ebx
	jne	SHORT $LN46@xmlSchemaA

; 10635: 	    goto exit_error;
; 10636:     } else {
; 10637: 	xmlSchemaPErr(pctxt, NULL,

	push	ebx
	push	ebx
	push	OFFSET ??_C@_0EP@KKBODFED@No?5information?5for?5parsing?5was?5@
	push	1758					; 000006deH
	push	ebx
	push	esi
	call	_xmlSchemaPErr
	add	esp, 24					; 00000018H

; 10728: 	if (bkt != NULL)
; 10729: 	    bkt->doc = NULL;
; 10730:     }
; 10731:     return (-1);

	or	eax, -1
	pop	edi

; 10732: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@xmlSchemaA:

; 10569: 	xmlParserCtxtPtr parserCtxt;
; 10570: 
; 10571: 	parserCtxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	esi, eax

; 10572: 	if (parserCtxt == NULL) {

	test	esi, esi
	jne	SHORT $LN47@xmlSchemaA

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CN@KMMHPBMO@xmlSchemaGetDoc?0?5allocating?5a?5p@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 10728: 	if (bkt != NULL)
; 10729: 	    bkt->doc = NULL;
; 10730:     }
; 10731:     return (-1);

	or	eax, -1
	pop	edi

; 10732: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@xmlSchemaA:

; 10573: 	    xmlSchemaPErrMemory(NULL, "xmlSchemaGetDoc, "
; 10574: 		"allocating a parser context", NULL);
; 10575: 	    goto exit_failure;
; 10576: 	}
; 10577: 	if ((pctxt->dict != NULL) && (parserCtxt->dict != NULL)) {

	mov	eax, DWORD PTR _pctxt$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN48@xmlSchemaA
	mov	eax, DWORD PTR [esi+296]
	test	eax, eax
	je	SHORT $LN48@xmlSchemaA

; 10578: 	    /*
; 10579: 	    * TODO: Do we have to burden the schema parser dict with all
; 10580: 	    * the content of the schema doc?
; 10581: 	    */
; 10582: 	    xmlDictFree(parserCtxt->dict);

	push	eax
	call	_xmlDictFree

; 10583: 	    parserCtxt->dict = pctxt->dict;

	mov	eax, DWORD PTR _pctxt$[ebp]
	mov	eax, DWORD PTR [eax+80]

; 10584: 	    xmlDictReference(parserCtxt->dict);

	push	eax
	mov	DWORD PTR [esi+296], eax
	call	_xmlDictReference
	add	esp, 8
$LN48@xmlSchemaA:

; 10585: 	}
; 10586: 	if (schemaLocation != NULL) {

	mov	eax, DWORD PTR _schemaLocation$1$[ebp]
	test	eax, eax
	je	SHORT $LN49@xmlSchemaA

; 10587: 	    /* Parse from file. */
; 10588: 	    doc = xmlCtxtReadFile(parserCtxt, (const char *) schemaLocation,

	push	2
	push	0
	push	eax
	push	esi
	call	_xmlCtxtReadFile
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _doc$1$[ebp], ebx
	jmp	SHORT $LN52@xmlSchemaA
$LN49@xmlSchemaA:

; 10589: 		NULL, SCHEMAS_PARSE_OPTIONS);
; 10590: 	} else if (schemaBuffer != NULL) {

	test	ebx, ebx
	je	SHORT $LN199@xmlSchemaA

; 10591: 	    /* Parse from memory buffer. */
; 10592: 	    doc = xmlCtxtReadMemory(parserCtxt, schemaBuffer, schemaBufferLen,

	push	2
	push	0
	push	0
	push	DWORD PTR _schemaBufferLen$[ebp]
	push	ebx
	push	esi
	call	_xmlCtxtReadMemory
	mov	ebx, eax

; 10593: 		NULL, NULL, SCHEMAS_PARSE_OPTIONS);
; 10594: 	    schemaLocation = BAD_CAST "in_memory_buffer";

	mov	DWORD PTR _schemaLocation$1$[ebp], OFFSET ??_C@_0BB@IEONCAEH@in_memory_buffer@
	add	esp, 24					; 00000018H
	mov	DWORD PTR _doc$1$[ebp], ebx

; 10595: 	    if (doc != NULL)

	test	ebx, ebx
	je	SHORT $LN199@xmlSchemaA

; 10596: 		doc->URL = xmlStrdup(schemaLocation);

	push	OFFSET ??_C@_0BB@IEONCAEH@in_memory_buffer@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+72], eax
$LN52@xmlSchemaA:

; 10597: 	}
; 10598: 	/*
; 10599: 	* For <import>:
; 10600: 	* 2.1 The referent is (a fragment of) a resource which is an
; 10601: 	* XML document (see clause 1.1), which in turn corresponds to
; 10602: 	* a <schema> element information item in a well-formed information
; 10603: 	* set, which in turn corresponds to a valid schema.
; 10604: 	* TODO: (2.1) fragments of XML documents are not supported.
; 10605: 	*
; 10606: 	* 2.2 The referent is a <schema> element information item in
; 10607: 	* a well-formed information set, which in turn corresponds
; 10608: 	* to a valid schema.
; 10609: 	* TODO: (2.2) is not supported.
; 10610: 	*/
; 10611: 	if (doc == NULL) {

	test	ebx, ebx
	jne	SHORT $LN219@xmlSchemaA
$LN199@xmlSchemaA:

; 10612: 	    xmlErrorPtr lerr;
; 10613: 	    lerr = xmlGetLastError();

	call	_xmlGetLastError

; 10614: 	    /*
; 10615: 	    * Check if this a parser error, or if the document could
; 10616: 	    * just not be located.
; 10617: 	    * TODO: Try to find specific error codes to react only on
; 10618: 	    * localisation failures.
; 10619: 	    */
; 10620: 	    if ((lerr == NULL) || (lerr->domain != XML_FROM_IO)) {

	test	eax, eax
	je	SHORT $LN55@xmlSchemaA
	cmp	DWORD PTR [eax], 8
	je	SHORT $LN219@xmlSchemaA
$LN55@xmlSchemaA:

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	DWORD PTR _invokingNode$[ebp]
	lea	eax, DWORD PTR _msg$1[ebp]

; 10621: 		/*
; 10622: 		* We assume a parser error here.
; 10623: 		*/
; 10624: 		located = 1;

	mov	DWORD PTR _located$1$[ebp], 1

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	DWORD PTR _pctxt$[ebp]
	mov	DWORD PTR _msg$1[ebp], 0
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0CG@MKFNOEJC@Failed?5to?5parse?5the?5XML?5resourc@
	push	DWORD PTR _msg$1[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	mov	ebx, DWORD PTR _schemaLocation$1$[ebp]
	push	0
	push	0
	push	0
	push	ebx
	push	eax
	push	0
	push	DWORD PTR _invokingNode$[ebp]

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$1[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	3067					; 00000bfbH
	push	2
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$1[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 68					; 00000044H

; 2352 :     FREE_AND_NULL(msg)

	test	eax, eax
	je	SHORT $LN121@xmlSchemaA
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 10597: 	}
; 10598: 	/*
; 10599: 	* For <import>:
; 10600: 	* 2.1 The referent is (a fragment of) a resource which is an
; 10601: 	* XML document (see clause 1.1), which in turn corresponds to
; 10602: 	* a <schema> element information item in a well-formed information
; 10603: 	* set, which in turn corresponds to a valid schema.
; 10604: 	* TODO: (2.1) fragments of XML documents are not supported.
; 10605: 	*
; 10606: 	* 2.2 The referent is a <schema> element information item in
; 10607: 	* a well-formed information set, which in turn corresponds
; 10608: 	* to a valid schema.
; 10609: 	* TODO: (2.2) is not supported.
; 10610: 	*/
; 10611: 	if (doc == NULL) {

	jmp	SHORT $LN121@xmlSchemaA
$LN219@xmlSchemaA:

; 10625: 		/* TODO: Error code ?? */
; 10626: 		res = XML_SCHEMAP_SRC_IMPORT_2_1;
; 10627: 		xmlSchemaCustomErr(ACTXT_CAST pctxt, res,
; 10628: 		    invokingNode, NULL,
; 10629: 		    "Failed to parse the XML resource '%s'",
; 10630: 		    schemaLocation, NULL);
; 10631: 	    }
; 10632: 	}
; 10633: 	xmlFreeParserCtxt(parserCtxt);

	mov	ebx, DWORD PTR _schemaLocation$1$[ebp]
$LN121@xmlSchemaA:
	push	esi
	call	_xmlFreeParserCtxt

; 10634: 	if ((doc == NULL) && located)

	mov	eax, DWORD PTR _doc$1$[ebp]
	add	esp, 4
	test	eax, eax
	jne	$LN56@xmlSchemaA
	mov	eax, DWORD PTR _located$1$[ebp]
	test	eax, eax
	jne	$LN71@xmlSchemaA

; 10638: 	    XML_SCHEMAP_NOTHING_TO_PARSE,
; 10639: 	    "No information for parsing was provided with the "
; 10640: 	    "given schema parser context.\n",
; 10641: 	    NULL, NULL);
; 10642: 	goto exit_failure;
; 10643:     }
; 10644:     /*
; 10645:     * Preprocess the document.
; 10646:     */
; 10647:     if (doc != NULL) {

	mov	ebx, DWORD PTR _pctxt$[ebp]
	mov	esi, DWORD PTR _targetNamespace$1$[ebp]
	jmp	$LN57@xmlSchemaA
$LN58@xmlSchemaA:

; 9580 :     if ((ctxt == NULL) || (root == NULL)) return;

	mov	ebx, DWORD PTR _pctxt$[ebp]
	test	ebx, ebx
	je	$LN141@xmlSchemaA

; 9581 : 
; 9582 :     /*
; 9583 :      * Remove all the blank text nodes
; 9584 :      */
; 9585 :     delete = NULL;

	xor	ebx, ebx
	npad	4
$LL135@xmlSchemaA:

; 9588 :         if (delete != NULL) {

	test	ebx, ebx
	je	SHORT $LN142@xmlSchemaA

; 9589 :             xmlUnlinkNode(delete);

	push	ebx
	call	_xmlUnlinkNode

; 9590 :             xmlFreeNode(delete);

	push	ebx
	call	_xmlFreeNode
	add	esp, 8

; 9591 :             delete = NULL;

	xor	ebx, ebx
$LN142@xmlSchemaA:

; 9592 :         }
; 9593 :         if (cur->type == XML_TEXT_NODE) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 3
	jne	SHORT $LN143@xmlSchemaA

; 9594 :             if (IS_BLANK_NODE(cur)) {

	push	-1
	push	DWORD PTR [esi+40]
	call	_xmlSchemaIsBlank
	add	esp, 8
	test	eax, eax
	je	SHORT $LN147@xmlSchemaA

; 9595 :                 if (xmlNodeGetSpacePreserve(cur) != 1) {

	push	esi
	call	_xmlNodeGetSpacePreserve
	add	esp, 4
	cmp	eax, 1
	je	SHORT $LN147@xmlSchemaA

; 9596 :                     delete = cur;

	mov	ebx, esi
$LN147@xmlSchemaA:

; 9603 :         }
; 9604 : 
; 9605 :         /*
; 9606 :          * Skip to next node
; 9607 :          */
; 9608 :         if (cur->children != NULL) {

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $skip_children$233

; 9609 :             if ((cur->children->type != XML_ENTITY_DECL) &&
; 9610 :                 (cur->children->type != XML_ENTITY_REF_NODE) &&

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 17					; 00000011H
	je	SHORT $skip_children$233
	cmp	eax, 5
	je	SHORT $skip_children$233
	cmp	eax, 6
	je	SHORT $skip_children$233

; 9611 :                 (cur->children->type != XML_ENTITY_NODE)) {
; 9612 :                 cur = cur->children;

	mov	esi, ecx

; 9613 :                 continue;

	jmp	SHORT $LN138@xmlSchemaA
$LN143@xmlSchemaA:

; 9597 :                 }
; 9598 :             }
; 9599 :         } else if ((cur->type != XML_ELEMENT_NODE) &&

	cmp	eax, 1
	je	SHORT $LN147@xmlSchemaA
	cmp	eax, 4
	je	SHORT $LN147@xmlSchemaA

; 9600 :                    (cur->type != XML_CDATA_SECTION_NODE)) {
; 9601 :             delete = cur;

	mov	ebx, esi

; 9602 :             goto skip_children;

	jmp	SHORT $skip_children$233
	npad	7
$LL139@xmlSchemaA:

; 9614 :             }
; 9615 :         }
; 9616 :       skip_children:
; 9617 :         if (cur->next != NULL) {
; 9618 :             cur = cur->next;
; 9619 :             continue;
; 9620 :         }
; 9621 : 
; 9622 :         do {
; 9623 :             cur = cur->parent;

	mov	esi, DWORD PTR [esi+20]

; 9624 :             if (cur == NULL)

	test	esi, esi
	je	SHORT $LN176@xmlSchemaA

; 9625 :                 break;
; 9626 :             if (cur == root) {

	cmp	esi, DWORD PTR _docElem$1$[ebp]
	je	SHORT $LN176@xmlSchemaA
$skip_children$233:

; 9586 :     cur = root;
; 9587 :     while (cur != NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LL139@xmlSchemaA
	mov	esi, eax
$LN138@xmlSchemaA:
	test	esi, esi
	jne	$LL135@xmlSchemaA
$LN176@xmlSchemaA:

; 9627 :                 cur = NULL;
; 9628 :                 break;
; 9629 :             }
; 9630 :             if (cur->next != NULL) {
; 9631 :                 cur = cur->next;
; 9632 :                 break;
; 9633 :             }
; 9634 :         } while (cur != NULL);
; 9635 :     }
; 9636 :     if (delete != NULL) {

	test	ebx, ebx
	je	SHORT $LN216@xmlSchemaA

; 9637 :         xmlUnlinkNode(delete);

	push	ebx
	call	_xmlUnlinkNode

; 9638 :         xmlFreeNode(delete);

	push	ebx
	call	_xmlFreeNode
	add	esp, 8
$LN216@xmlSchemaA:

; 10658: 	}
; 10659: 	/*
; 10660: 	* Remove all the blank text nodes.
; 10661: 	*/
; 10662: 	xmlSchemaCleanupDoc(pctxt, docElem);
; 10663: 	/*
; 10664: 	* Check the schema's top level element.
; 10665: 	*/
; 10666: 	if (!IS_SCHEMA(docElem, "schema")) {

	mov	ebx, DWORD PTR _pctxt$[ebp]
	mov	esi, DWORD PTR _docElem$1$[ebp]
$LN141@xmlSchemaA:
	cmp	DWORD PTR [esi+36], 0
	je	$LN60@xmlSchemaA
	push	OFFSET ??_C@_06KICAKOOL@schema@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN60@xmlSchemaA
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN60@xmlSchemaA

; 10667: 	    xmlSchemaCustomErr(ACTXT_CAST pctxt, XML_SCHEMAP_NOT_SCHEMA,
; 10668: 		invokingNode, NULL,
; 10669: 		"The XML document '%s' is not a schema document",
; 10670: 		schemaLocation, NULL);
; 10671: 	    goto exit_error;
; 10672: 	}
; 10673: 	/*
; 10674: 	* Note that we don't apply a type check for the
; 10675: 	* targetNamespace value here.
; 10676: 	*/
; 10677: 	targetNamespace = xmlSchemaGetProp(pctxt, docElem,

	push	OFFSET ??_C@_0BA@JJLDNFDJ@targetNamespace@
	push	esi
	push	ebx
	call	_xmlSchemaGetProp
	mov	esi, eax
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _located$1$[ebp]
$LN57@xmlSchemaA:

; 10678: 	    "targetNamespace");
; 10679:     }
; 10680: 
; 10681: /* after_doc_loading: */
; 10682:     if ((bkt == NULL) && located) {

	test	edi, edi
	jne	SHORT $LN197@xmlSchemaA
	test	eax, eax
	je	SHORT $exit$231

; 10683: 	/* Only create a bucket if the schema was located. */
; 10684:         bkt = xmlSchemaBucketCreate(pctxt, type,

	push	esi
	push	DWORD PTR _type$[ebp]
	push	ebx
	call	_xmlSchemaBucketCreate
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 10685: 	    targetNamespace);
; 10686: 	if (bkt == NULL)

	test	edi, edi
	jne	SHORT $LN197@xmlSchemaA
$exit_failure$234:

; 10724: 
; 10725: exit_failure:
; 10726:     if ((doc != NULL) && (! preserveDoc)) {

	mov	eax, DWORD PTR _doc$1$[ebp]
	test	eax, eax
	je	SHORT $LN73@xmlSchemaA
	cmp	DWORD PTR _preserveDoc$1$[ebp], edi
	jne	SHORT $LN73@xmlSchemaA

; 10727: 	xmlFreeDoc(doc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN73@xmlSchemaA:

; 10732: }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN197@xmlSchemaA:

; 10687: 	    goto exit_failure;
; 10688:     }
; 10689:     if (bkt != NULL) {
; 10690: 	bkt->schemaLocation = schemaLocation;

	mov	eax, DWORD PTR _schemaLocation$1$[ebp]

; 10691: 	bkt->located = located;

	mov	ecx, DWORD PTR _located$1$[ebp]
	mov	DWORD PTR [edi+8], eax

; 10692: 	if (doc != NULL) {

	mov	eax, DWORD PTR _doc$1$[ebp]
	mov	DWORD PTR [edi+28], ecx
	test	eax, eax
	je	SHORT $LN65@xmlSchemaA

; 10693: 	    bkt->doc = doc;
; 10694: 	    bkt->targetNamespace = targetNamespace;
; 10695: 	    bkt->origTargetNamespace = targetNamespace;
; 10696: 	    if (preserveDoc)

	cmp	DWORD PTR _preserveDoc$1$[ebp], 0
	mov	DWORD PTR [edi+20], eax
	mov	DWORD PTR [edi+16], esi
	mov	DWORD PTR [edi+12], esi
	je	SHORT $LN65@xmlSchemaA

; 10697: 		bkt->preserveDoc = 1;

	mov	DWORD PTR [edi+40], 1
$LN65@xmlSchemaA:

; 10698: 	}
; 10699: 	if (WXS_IS_BUCKET_IMPMAIN(type))

	mov	eax, DWORD PTR _type$[ebp]
	test	eax, eax
	je	SHORT $LN67@xmlSchemaA
	cmp	eax, 1
	jne	SHORT $LN66@xmlSchemaA
$LN67@xmlSchemaA:

; 10700: 	    bkt->imported++;

	inc	DWORD PTR [edi+36]
$LN66@xmlSchemaA:

; 10701: 	    /*
; 10702: 	    * Add it to the graph of schemas.
; 10703: 	    */
; 10704: 	if (relation != NULL)

	mov	eax, DWORD PTR _relation$1$[ebp]
	test	eax, eax
	je	SHORT $exit$231
$LN222@xmlSchemaA:

; 10705: 	    relation->bucket = bkt;
; 10706:     }
; 10707: 
; 10708: exit:
; 10709:     /*
; 10710:     * Return the bucket explicitely; this is needed for the
; 10711:     * main schema.
; 10712:     */
; 10713:     if (bucket != NULL)

	mov	DWORD PTR [eax+12], edi
$exit$231:
	mov	eax, DWORD PTR _bucket$[ebp]
	test	eax, eax
	je	SHORT $LN69@xmlSchemaA

; 10714: 	*bucket = bkt;

	mov	DWORD PTR [eax], edi
$LN69@xmlSchemaA:
	pop	edi

; 10732: }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN60@xmlSchemaA:

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	mov	esi, DWORD PTR _invokingNode$[ebp]
	lea	eax, DWORD PTR _msg$2[ebp]
	push	esi
	push	ebx
	push	eax
	mov	DWORD PTR _msg$2[ebp], 0
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0CP@HFPALNHL@The?5XML?5document?5?8?$CFs?8?5is?5not?5a?5@
	push	DWORD PTR _msg$2[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$2[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	DWORD PTR _schemaLocation$1$[ebp]
	push	eax
	push	0
	push	esi
	push	1772					; 000006ecH
	push	2
	push	ebx
$LN226@xmlSchemaA:

; 10715:     return (0);
; 10716: 
; 10717: exit_error:
; 10718:     if ((doc != NULL) && (! preserveDoc)) {

	mov	DWORD PTR _msg$2[ebp], eax
	call	_xmlSchemaErr4Line
	mov	eax, DWORD PTR _msg$2[ebp]
	add	esp, 68					; 00000044H
	test	eax, eax
	je	SHORT $exit_error$235
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$exit_error$235:
	cmp	DWORD PTR _preserveDoc$1$[ebp], 0
	jne	SHORT $LN71@xmlSchemaA

; 10719: 	xmlFreeDoc(doc);

	push	DWORD PTR _doc$1$[ebp]
	call	_xmlFreeDoc
	add	esp, 4

; 10720: 	if (bkt != NULL)

	test	edi, edi
	je	SHORT $LN71@xmlSchemaA

; 10721: 	    bkt->doc = NULL;

	mov	DWORD PTR [edi+20], 0
$LN71@xmlSchemaA:

; 10722:     }
; 10723:     return(pctxt->err);

	mov	eax, DWORD PTR _pctxt$[ebp]
	pop	edi

; 10732: }

	pop	esi
	pop	ebx
	mov	eax, DWORD PTR [eax+16]
	mov	esp, ebp
	pop	ebp
	ret	0
$LN230@xmlSchemaA:
	DD	$LN5@xmlSchemaA
	DD	$LN5@xmlSchemaA
	DD	$LN6@xmlSchemaA
	DD	$LN7@xmlSchemaA
_xmlSchemaAddSchemaDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaBuildAbsoluteURI
_TEXT	SEGMENT
_dict$ = 8						; size = 4
_location$ = 12						; size = 4
_ctxtNode$ = 16						; size = 4
_xmlSchemaBuildAbsoluteURI PROC				; COMDAT

; 10280: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _location$[ebp]
	test	esi, esi
	je	SHORT $LN7@xmlSchemaB

; 10281:     /*
; 10282:     * Build an absolue location URI.
; 10283:     */
; 10284:     if (location != NULL) {
; 10285: 	if (ctxtNode == NULL)

	mov	edi, DWORD PTR _ctxtNode$[ebp]
	test	edi, edi
	je	SHORT $LN9@xmlSchemaB

; 10286: 	    return(location);
; 10287: 	else {
; 10288: 	    xmlChar *base, *URI;
; 10289: 	    const xmlChar *ret = NULL;
; 10290: 
; 10291: 	    base = xmlNodeGetBase(ctxtNode->doc, ctxtNode);

	push	ebx
	push	edi
	push	DWORD PTR [edi+32]
	call	_xmlNodeGetBase
	mov	ebx, eax
	add	esp, 8

; 10292: 	    if (base == NULL) {

	test	ebx, ebx
	jne	SHORT $LN5@xmlSchemaB

; 10293: 		URI = xmlBuildURI(location, ctxtNode->doc->URL);

	mov	eax, DWORD PTR [edi+32]
	push	DWORD PTR [eax+72]
	push	esi
	call	_xmlBuildURI
	add	esp, 8
	mov	edi, eax

; 10294: 	    } else {

	jmp	SHORT $LN6@xmlSchemaB
$LN5@xmlSchemaB:

; 10295: 		URI = xmlBuildURI(location, base);

	push	ebx
	push	esi
	call	_xmlBuildURI

; 10296: 		xmlFree(base);

	push	ebx
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
$LN6@xmlSchemaB:

; 10297: 	    }
; 10298: 	    if (URI != NULL) {

	pop	ebx
	test	edi, edi
	je	SHORT $LN7@xmlSchemaB

; 10299: 		ret = xmlDictLookup(dict, URI, -1);

	push	-1
	push	edi
	push	DWORD PTR _dict$[ebp]
	call	_xmlDictLookup

; 10300: 		xmlFree(URI);

	push	edi
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H
$LN9@xmlSchemaB:

; 10306: }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	0
$LN7@xmlSchemaB:
	pop	edi

; 10301: 		return(ret);
; 10302: 	    }
; 10303: 	}
; 10304:     }
; 10305:     return(NULL);

	xor	eax, eax

; 10306: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaBuildAbsoluteURI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSchemaRelationAddChild
_TEXT	SEGMENT
_bucket$ = 8						; size = 4
_rel$ = 12						; size = 4
_xmlSchemaSchemaRelationAddChild PROC			; COMDAT

; 10264: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _bucket$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	test	edx, edx
	jne	SHORT $LN6@xmlSchemaS

; 10265:     xmlSchemaSchemaRelationPtr cur = bucket->relations;
; 10266: 
; 10267:     if (cur == NULL) {
; 10268: 	bucket->relations = rel;

	mov	eax, DWORD PTR _rel$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 10274: }

	pop	ebp
	ret	0
$LN6@xmlSchemaS:

; 10269: 	return;
; 10270:     }
; 10271:     while (cur->next != NULL)

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $LN3@xmlSchemaS
$LL2@xmlSchemaS:
	mov	eax, DWORD PTR [ecx]

; 10272: 	cur = cur->next;

	mov	edx, ecx
	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL2@xmlSchemaS
$LN3@xmlSchemaS:

; 10273:     cur->next = rel;

	mov	eax, DWORD PTR _rel$[ebp]
	mov	DWORD PTR [edx], eax

; 10274: }

	pop	ebp
	ret	0
_xmlSchemaSchemaRelationAddChild ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseNewDoc
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_bucket$ = 16						; size = 4
_xmlSchemaParseNewDoc PROC				; COMDAT

; 10208: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _bucket$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaP

; 10259: }

	pop	ebp
	ret	0
$LN2@xmlSchemaP:

; 10209:     xmlSchemaParserCtxtPtr newpctxt;
; 10210:     int res = 0;
; 10211: 
; 10212:     if (bucket == NULL)
; 10213: 	return(0);
; 10214:     if (bucket->parsed) {

	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN3@xmlSchemaP

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BH@IFNOMMON@reparsing?5a?5schema?5doc@
$LN36@xmlSchemaP:

; 10259: }

	push	OFFSET ??_C@_0BF@DMMABNCK@xmlSchemaParseNewDoc@
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
	or	eax, -1
	pop	ebp
	ret	0
$LN3@xmlSchemaP:

; 10215: 	PERROR_INT("xmlSchemaParseNewDoc",
; 10216: 	    "reparsing a schema doc");
; 10217: 	return(-1);
; 10218:     }
; 10219:     if (bucket->doc == NULL) {

	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN4@xmlSchemaP

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CJ@PEPIDOML@parsing?5a?5schema?5doc?0?5but?5there@

; 10220: 	PERROR_INT("xmlSchemaParseNewDoc",
; 10221: 	    "parsing a schema doc, but there's no doc");
; 10222: 	return(-1);

	jmp	SHORT $LN36@xmlSchemaP
$LN4@xmlSchemaP:
	push	edi

; 10223:     }
; 10224:     if (pctxt->constructor == NULL) {

	mov	edi, DWORD PTR _pctxt$[ebp]
	cmp	DWORD PTR [edi+28], 0
	jne	SHORT $LN5@xmlSchemaP

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0P@BIPJKJFE@no?5constructor@
	push	OFFSET ??_C@_0BF@DMMABNCK@xmlSchemaParseNewDoc@
	push	edi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 10225: 	PERROR_INT("xmlSchemaParseNewDoc",
; 10226: 	    "no constructor");
; 10227: 	return(-1);

	or	eax, -1
	pop	edi

; 10259: }

	pop	ebp
	ret	0
$LN5@xmlSchemaP:
	push	ebx

; 10228:     }
; 10229:     /* Create and init the temporary parser context. */
; 10230:     newpctxt = xmlSchemaNewParserCtxtUseDict(

	push	DWORD PTR [edi+80]
	push	DWORD PTR [eax+8]
	call	_xmlSchemaNewParserCtxtUseDict
	mov	ebx, eax
	add	esp, 8

; 10231: 	(const char *) bucket->schemaLocation, pctxt->dict);
; 10232:     if (newpctxt == NULL)

	test	ebx, ebx
	jne	SHORT $LN6@xmlSchemaP

; 10233: 	return(-1);

	pop	ebx
	or	eax, -1
	pop	edi

; 10259: }

	pop	ebp
	ret	0
$LN6@xmlSchemaP:

; 10234:     newpctxt->constructor = pctxt->constructor;

	mov	eax, DWORD PTR [edi+28]
	push	esi

; 10235:     /*
; 10236:     * TODO: Can we avoid that the parser knows about the main schema?
; 10237:     * It would be better if he knows about the current schema bucket
; 10238:     * only.
; 10239:     */
; 10240:     newpctxt->schema = schema;

	mov	esi, DWORD PTR _schema$[ebp]
	mov	DWORD PTR [ebx+28], eax
	mov	DWORD PTR [ebx+36], esi

; 10241:     xmlSchemaSetParserErrors(newpctxt, pctxt->error, pctxt->warning,

	push	DWORD PTR [edi+4]
	push	DWORD PTR [edi+12]
	push	DWORD PTR [edi+8]
	push	ebx
	call	_xmlSchemaSetParserErrors

; 10242: 	pctxt->errCtxt);
; 10243:     xmlSchemaSetParserStructuredErrors(newpctxt, pctxt->serror,

	push	DWORD PTR [edi+4]
	push	DWORD PTR [edi+24]
	push	ebx
	call	_xmlSchemaSetParserStructuredErrors

; 10244: 	pctxt->errCtxt);
; 10245:     newpctxt->counter = pctxt->counter;
; 10246: 
; 10247: 
; 10248:     res = xmlSchemaParseNewDocWithContext(newpctxt, schema, bucket);

	push	DWORD PTR _bucket$[ebp]
	mov	eax, DWORD PTR [edi+40]
	push	esi
	push	ebx
	mov	DWORD PTR [ebx+40], eax
	call	_xmlSchemaParseNewDocWithContext
	mov	esi, eax
	add	esp, 40					; 00000028H

; 10249: 
; 10250:     /* Channel back errors and cleanup the temporary parser context. */
; 10251:     if (res != 0)

	test	esi, esi
	je	SHORT $LN7@xmlSchemaP

; 10252: 	pctxt->err = res;

	mov	DWORD PTR [edi+16], esi
$LN7@xmlSchemaP:

; 10253:     pctxt->nberrors += newpctxt->nberrors;

	mov	ecx, DWORD PTR [ebx+20]
	add	DWORD PTR [edi+20], ecx

; 10254:     pctxt->counter = newpctxt->counter;

	mov	eax, DWORD PTR [ebx+40]
	mov	DWORD PTR [edi+40], eax

; 10255:     newpctxt->constructor = NULL;
; 10256:     /* Free the parser context. */
; 10257:     xmlSchemaFreeParserCtxt(newpctxt);

	push	ebx
	mov	DWORD PTR [ebx+28], 0
	call	_xmlSchemaFreeParserCtxt
	add	esp, 4

; 10258:     return(res);

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 10259: }

	pop	ebp
	ret	0
_xmlSchemaParseNewDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseNewDocWithContext
_TEXT	SEGMENT
_oldFlags$1$ = -4					; size = 4
_oldbucket$1$ = 8					; size = 4
_pctxt$ = 8						; size = 4
_oldDoc$1$ = 12						; size = 4
_schema$ = 12						; size = 4
_bucket$ = 16						; size = 4
_xmlSchemaParseNewDocWithContext PROC			; COMDAT

; 10139: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pctxt$[ebp]
	mov	esi, DWORD PTR _schema$[ebp]
	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR _oldFlags$1$[ebp], ecx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _oldbucket$1$[ebp], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR _oldDoc$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN18@xmlSchemaP

; 9647 :     if (schema->flags & XML_SCHEMAS_QUALIF_ELEM)

	mov	eax, ecx
	test	cl, 1
	je	SHORT $LN10@xmlSchemaP

; 9648 : 	schema->flags ^= XML_SCHEMAS_QUALIF_ELEM;

	xor	eax, 1
	mov	DWORD PTR [esi+24], eax
$LN10@xmlSchemaP:

; 9649 : 
; 9650 :     if (schema->flags & XML_SCHEMAS_QUALIF_ATTR)

	test	al, 2
	je	SHORT $LN11@xmlSchemaP

; 9651 : 	schema->flags ^= XML_SCHEMAS_QUALIF_ATTR;

	xor	eax, 2
	mov	DWORD PTR [esi+24], eax
$LN11@xmlSchemaP:

; 9652 : 
; 9653 :     if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_EXTENSION)

	test	al, 4
	je	SHORT $LN12@xmlSchemaP

; 9654 : 	schema->flags ^= XML_SCHEMAS_FINAL_DEFAULT_EXTENSION;

	xor	eax, 4
	mov	DWORD PTR [esi+24], eax
$LN12@xmlSchemaP:

; 9655 :     if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION)

	test	al, 8
	je	SHORT $LN13@xmlSchemaP

; 9656 : 	schema->flags ^= XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION;

	xor	eax, 8
	mov	DWORD PTR [esi+24], eax
$LN13@xmlSchemaP:

; 9657 :     if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_LIST)

	test	al, 16					; 00000010H
	je	SHORT $LN14@xmlSchemaP

; 9658 : 	schema->flags ^= XML_SCHEMAS_FINAL_DEFAULT_LIST;

	xor	eax, 16					; 00000010H
	mov	DWORD PTR [esi+24], eax
$LN14@xmlSchemaP:

; 9659 :     if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_UNION)

	test	al, 32					; 00000020H
	je	SHORT $LN15@xmlSchemaP

; 9660 : 	schema->flags ^= XML_SCHEMAS_FINAL_DEFAULT_UNION;

	xor	eax, 32					; 00000020H
	mov	DWORD PTR [esi+24], eax
$LN15@xmlSchemaP:

; 9661 : 
; 9662 :     if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION)

	test	al, 64					; 00000040H
	je	SHORT $LN16@xmlSchemaP

; 9663 : 	schema->flags ^= XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION;

	xor	eax, 64					; 00000040H
	mov	DWORD PTR [esi+24], eax
$LN16@xmlSchemaP:

; 9664 :     if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION)

	test	al, al
	jns	SHORT $LN17@xmlSchemaP

; 9665 : 	schema->flags ^= XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION;

	xor	eax, 128				; 00000080H
	mov	DWORD PTR [esi+24], eax
$LN17@xmlSchemaP:

; 9666 :     if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION)

	test	eax, 256				; 00000100H
	je	SHORT $LN18@xmlSchemaP

; 9667 : 	schema->flags ^= XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION;

	xor	eax, 256				; 00000100H
	mov	DWORD PTR [esi+24], eax
$LN18@xmlSchemaP:

; 10140:     int oldFlags;
; 10141:     xmlDocPtr oldDoc;
; 10142:     xmlNodePtr node;
; 10143:     int ret, oldErrs;
; 10144:     xmlSchemaBucketPtr oldbucket = pctxt->constructor->bucket;
; 10145: 
; 10146:     /*
; 10147:     * Save old values; reset the *main* schema.
; 10148:     * URGENT TODO: This is not good; move the per-document information
; 10149:     * to the parser. Get rid of passing the main schema to the
; 10150:     * parsing functions.
; 10151:     */
; 10152:     oldFlags = schema->flags;
; 10153:     oldDoc = schema->doc;
; 10154:     if (schema->flags != 0)
; 10155: 	xmlSchemaClearSchemaDefaults(schema);
; 10156:     schema->doc = bucket->doc;

	mov	ebx, DWORD PTR _bucket$[ebp]
	mov	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR [esi+16], eax

; 10157:     pctxt->schema = schema;

	mov	DWORD PTR [edi+36], esi

; 10158:     /*
; 10159:     * Keep the current target namespace on the parser *not* on the
; 10160:     * main schema.
; 10161:     */
; 10162:     pctxt->targetNamespace = bucket->targetNamespace;

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR [edi+112], eax

; 10163:     WXS_CONSTRUCTOR(pctxt)->bucket = bucket;

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [eax+16], ebx

; 10164: 
; 10165:     if ((bucket->targetNamespace != NULL) &&

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaP
	push	DWORD PTR _xmlSchemaNs
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@xmlSchemaP

; 10166: 	xmlStrEqual(bucket->targetNamespace, xmlSchemaNs)) {
; 10167: 	/*
; 10168: 	* We are parsing the schema for schemas!
; 10169: 	*/
; 10170: 	pctxt->isS4S = 1;

	mov	DWORD PTR [edi+96], 1
$LN3@xmlSchemaP:

; 10171:     }
; 10172:     /* Mark it as parsed, even if parsing fails. */
; 10173:     bucket->parsed++;
; 10174:     /* Compile the schema doc. */
; 10175:     node = xmlDocGetRootElement(bucket->doc);

	push	DWORD PTR [ebx+20]
	inc	DWORD PTR [ebx+32]
	call	_xmlDocGetRootElement
	mov	ebx, eax

; 10176:     ret = xmlSchemaParseSchemaElement(pctxt, schema, node);

	push	ebx
	push	esi
	push	edi
	call	_xmlSchemaParseSchemaElement
	mov	ecx, eax
	add	esp, 16					; 00000010H

; 10177:     if (ret != 0)

	test	ecx, ecx
	jne	SHORT $exit$21

; 10178: 	goto exit;
; 10179:     /* An empty schema; just get out. */
; 10180:     if (node->children == NULL)

	mov	eax, DWORD PTR [ebx+12]
	test	eax, eax
	je	SHORT $exit$21

; 10181: 	goto exit;
; 10182:     oldErrs = pctxt->nberrors;

	mov	ebx, DWORD PTR [edi+20]

; 10183:     ret = xmlSchemaParseSchemaTopLevel(pctxt, schema, node->children);

	push	eax
	push	esi
	push	edi
	call	_xmlSchemaParseSchemaTopLevel
	mov	ecx, eax
	add	esp, 12					; 0000000cH

; 10184:     if (ret != 0)

	test	ecx, ecx
	jne	SHORT $exit$21

; 10185: 	goto exit;
; 10186:     /*
; 10187:     * TODO: Not nice, but I'm not 100% sure we will get always an error
; 10188:     * as a result of the obove functions; so better rely on pctxt->err
; 10189:     * as well.
; 10190:     */
; 10191:     if ((ret == 0) && (oldErrs != pctxt->nberrors)) {

	cmp	ebx, DWORD PTR [edi+20]
	je	SHORT $exit$21

; 10192: 	ret = pctxt->err;

	mov	ecx, DWORD PTR [edi+16]
$exit$21:

; 10193: 	goto exit;
; 10194:     }
; 10195: 
; 10196: exit:
; 10197:     WXS_CONSTRUCTOR(pctxt)->bucket = oldbucket;

	mov	eax, DWORD PTR [edi+28]
	mov	edx, DWORD PTR _oldbucket$1$[ebp]

; 10198:     /* Restore schema values. */
; 10199:     schema->doc = oldDoc;
; 10200:     schema->flags = oldFlags;
; 10201:     return(ret);

	pop	edi
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR _oldDoc$1$[ebp]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR _oldFlags$1$[ebp]
	mov	DWORD PTR [esi+24], eax
	mov	eax, ecx
	pop	esi
	pop	ebx

; 10202: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseNewDocWithContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetSchemaBucketByTNS
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_targetNamespace$ = 12					; size = 4
_imported$ = 16						; size = 4
_xmlSchemaGetSchemaBucketByTNS PROC			; COMDAT

; 10114: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _pctxt$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [eax+12]
	mov	edi, DWORD PTR [edx+4]
	test	edi, edi
	je	SHORT $LN18@xmlSchemaG

; 10115:     xmlSchemaBucketPtr cur;
; 10116:     xmlSchemaItemListPtr list;
; 10117: 
; 10118:     list = pctxt->constructor->buckets;
; 10119:     if (list->nbItems == 0)
; 10120: 	return(NULL);
; 10121:     else {
; 10122: 	int i;
; 10123: 	for (i = 0; i < list->nbItems; i++) {

	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN18@xmlSchemaG

; 10124: 	    cur = (xmlSchemaBucketPtr) list->items[i];

	mov	edx, DWORD PTR [edx]
	mov	ebx, DWORD PTR _targetNamespace$[ebp]
	npad	5
$LL4@xmlSchemaG:
	mov	eax, DWORD PTR [edx]

; 10125: 	    if ((! IS_BAD_SCHEMA_DOC(cur)) &&
; 10126: 		(cur->origTargetNamespace == targetNamespace) &&

	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN8@xmlSchemaG
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@xmlSchemaG
$LN8@xmlSchemaG:
	cmp	DWORD PTR [eax+12], ebx
	jne	SHORT $LN2@xmlSchemaG
	cmp	DWORD PTR _imported$[ebp], 0
	mov	esi, DWORD PTR [eax+36]
	je	SHORT $LN17@xmlSchemaG
	test	esi, esi
	jne	SHORT $LN1@xmlSchemaG
	jmp	SHORT $LN2@xmlSchemaG
$LN17@xmlSchemaG:
	test	esi, esi
	je	SHORT $LN1@xmlSchemaG
$LN2@xmlSchemaG:

; 10115:     xmlSchemaBucketPtr cur;
; 10116:     xmlSchemaItemListPtr list;
; 10117: 
; 10118:     list = pctxt->constructor->buckets;
; 10119:     if (list->nbItems == 0)
; 10120: 	return(NULL);
; 10121:     else {
; 10122: 	int i;
; 10123: 	for (i = 0; i < list->nbItems; i++) {

	inc	ecx
	add	edx, 4
	cmp	ecx, edi
	jl	SHORT $LL4@xmlSchemaG
$LN18@xmlSchemaG:

; 10127: 		((imported && cur->imported) ||
; 10128: 		 ((!imported) && (!cur->imported))))
; 10129: 		return(cur);
; 10130: 	}
; 10131:     }
; 10132:     return(NULL);

	xor	eax, eax
$LN1@xmlSchemaG:
	pop	edi

; 10133: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaGetSchemaBucketByTNS ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetChameleonSchemaBucket
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_schemaLocation$ = 12					; size = 4
_targetNamespace$ = 16					; size = 4
_xmlSchemaGetChameleonSchemaBucket PROC			; COMDAT

; 10085: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _pctxt$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [eax+12]
	mov	esi, DWORD PTR [edx+4]
	test	esi, esi
	je	SHORT $LN14@xmlSchemaG

; 10086:     xmlSchemaBucketPtr cur;
; 10087:     xmlSchemaItemListPtr list;
; 10088: 
; 10089:     list = pctxt->constructor->buckets;
; 10090:     if (list->nbItems == 0)
; 10091: 	return(NULL);
; 10092:     else {
; 10093: 	int i;
; 10094: 	for (i = 0; i < list->nbItems; i++) {

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN14@xmlSchemaG

; 10095: 	    cur = (xmlSchemaBucketPtr) list->items[i];

	mov	edx, DWORD PTR [edx]
	mov	edi, DWORD PTR _targetNamespace$[ebp]
	mov	ebx, DWORD PTR _schemaLocation$[ebp]
	npad	2
$LL4@xmlSchemaG:
	mov	eax, DWORD PTR [edx]

; 10096: 	    /* Pointer comparison! */
; 10097: 	    if ((cur->origTargetNamespace == NULL) &&
; 10098: 		(cur->schemaLocation == schemaLocation) &&

	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN2@xmlSchemaG
	cmp	DWORD PTR [eax+8], ebx
	jne	SHORT $LN2@xmlSchemaG
	cmp	DWORD PTR [eax+16], edi
	je	SHORT $LN1@xmlSchemaG
$LN2@xmlSchemaG:

; 10086:     xmlSchemaBucketPtr cur;
; 10087:     xmlSchemaItemListPtr list;
; 10088: 
; 10089:     list = pctxt->constructor->buckets;
; 10090:     if (list->nbItems == 0)
; 10091: 	return(NULL);
; 10092:     else {
; 10093: 	int i;
; 10094: 	for (i = 0; i < list->nbItems; i++) {

	inc	ecx
	add	edx, 4
	cmp	ecx, esi
	jl	SHORT $LL4@xmlSchemaG
$LN14@xmlSchemaG:

; 10099: 		(cur->targetNamespace == targetNamespace))
; 10100: 		return(cur);
; 10101: 	}
; 10102:     }
; 10103:     return(NULL);

	xor	eax, eax
$LN1@xmlSchemaG:
	pop	edi

; 10104: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaGetChameleonSchemaBucket ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetSchemaBucket
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_schemaLocation$ = 12					; size = 4
_xmlSchemaGetSchemaBucket PROC				; COMDAT

; 10062: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _pctxt$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	ecx, DWORD PTR [eax+12]
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaG

; 10063:     xmlSchemaBucketPtr cur;
; 10064:     xmlSchemaItemListPtr list;
; 10065: 
; 10066:     list = pctxt->constructor->buckets;
; 10067:     if (list->nbItems == 0)
; 10068: 	return(NULL);
; 10069:     else {
; 10070: 	int i;
; 10071: 	for (i = 0; i < list->nbItems; i++) {

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN3@xmlSchemaG

; 10072: 	    cur = (xmlSchemaBucketPtr) list->items[i];

	mov	ecx, DWORD PTR [ecx]
	mov	edi, DWORD PTR _schemaLocation$[ebp]
	npad	6
$LL4@xmlSchemaG:
	mov	edx, DWORD PTR [ecx]

; 10073: 	    /* Pointer comparison! */
; 10074: 	    if (cur->schemaLocation == schemaLocation)

	cmp	DWORD PTR [edx+8], edi
	je	SHORT $LN10@xmlSchemaG

; 10063:     xmlSchemaBucketPtr cur;
; 10064:     xmlSchemaItemListPtr list;
; 10065: 
; 10066:     list = pctxt->constructor->buckets;
; 10067:     if (list->nbItems == 0)
; 10068: 	return(NULL);
; 10069:     else {
; 10070: 	int i;
; 10071: 	for (i = 0; i < list->nbItems; i++) {

	inc	eax
	add	ecx, 4
	cmp	eax, esi
	jl	SHORT $LL4@xmlSchemaG
$LN3@xmlSchemaG:
	pop	edi

; 10076: 	}
; 10077:     }
; 10078:     return(NULL);

	xor	eax, eax

; 10079: }

	pop	esi
	pop	ebp
	ret	0
$LN10@xmlSchemaG:
	pop	edi

; 10075: 		return(cur);

	mov	eax, edx

; 10079: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaGetSchemaBucket ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCreatePCtxtOnVCtxt
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_xmlSchemaCreatePCtxtOnVCtxt PROC			; COMDAT

; 10028: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _vctxt$[ebp]
	cmp	DWORD PTR [edi+88], 0
	jne	$LN23@xmlSchemaC

; 10029:     if (vctxt->pctxt == NULL) {
; 10030:         if (vctxt->schema != NULL)

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaC

; 10031: 	    vctxt->pctxt =

	push	ebx
	mov	ebx, DWORD PTR [eax+60]

; 10016:     ret = xmlSchemaParserCtxtCreate();

	call	_xmlSchemaParserCtxtCreate
	mov	esi, eax

; 10017:     if (ret == NULL)

	test	esi, esi
	jne	SHORT $LN8@xmlSchemaC

; 10031: 	    vctxt->pctxt =

	pop	ebx
	jmp	SHORT $LN11@xmlSchemaC
$LN8@xmlSchemaC:

; 10020:     xmlDictReference(dict);

	push	ebx
	mov	DWORD PTR [esi+80], ebx
	call	_xmlDictReference

; 10021:     if (URL != NULL)
; 10022: 	ret->URL = xmlDictLookup(dict, (const xmlChar *) URL, -1);

	push	-1
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	push	ebx
	call	_xmlDictLookup
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+44], eax
	pop	ebx

; 10031: 	    vctxt->pctxt =

	jmp	SHORT $LN11@xmlSchemaC
$LN3@xmlSchemaC:

; 12494:     ret = xmlSchemaParserCtxtCreate();

	call	_xmlSchemaParserCtxtCreate
	mov	esi, eax

; 12495:     if (ret == NULL)

	test	esi, esi
	je	SHORT $LN11@xmlSchemaC
$LN13@xmlSchemaC:

; 12496: 	return(NULL);
; 12497:     ret->dict = xmlDictCreate();

	call	_xmlDictCreate

; 12498:     ret->URL = xmlDictLookup(ret->dict, (const xmlChar *) URL, -1);

	push	-1
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	push	eax
	mov	DWORD PTR [esi+80], eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+44], eax
$LN11@xmlSchemaC:

; 10032: 		xmlSchemaNewParserCtxtUseDict("*", vctxt->schema->dict);
; 10033: 	else
; 10034: 	    vctxt->pctxt = xmlSchemaNewParserCtxt("*");
; 10035: 	if (vctxt->pctxt == NULL) {

	mov	DWORD PTR [edi+88], esi
	test	esi, esi
	jne	SHORT $LN5@xmlSchemaC

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	esi
	push	esi
	push	OFFSET ??_C@_0CI@GJEMMNOJ@failed?5to?5create?5a?5temp?4?5parser@
	push	OFFSET ??_C@_0BM@OJEBCMPM@xmlSchemaCreatePCtxtOnVCtxt@
	push	edi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 10036: 	    VERROR_INT("xmlSchemaCreatePCtxtOnVCtxt",
; 10037: 		"failed to create a temp. parser context");
; 10038: 	    return (-1);

	or	eax, -1
	pop	edi

; 10047: }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlSchemaC:

; 10039: 	}
; 10040: 	/* TODO: Pass user data. */
; 10041: 	xmlSchemaSetParserErrors(vctxt->pctxt, vctxt->error,

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edi+8]

; 21462:     ctxt->error = err;

	mov	DWORD PTR [esi+8], edx

; 21463:     ctxt->warning = warn;

	mov	DWORD PTR [esi+12], ecx

; 21464:     ctxt->errCtxt = ctx;

	mov	DWORD PTR [esi+4], eax

; 21465:     if (ctxt->vctxt != NULL)

	mov	esi, DWORD PTR [esi+92]
	test	esi, esi
	je	SHORT $LN19@xmlSchemaC

; 21466: 	xmlSchemaSetValidErrors(ctxt->vctxt, err, warn, ctx);

	push	eax
	push	ecx
	push	edx
	push	esi
	call	_xmlSchemaSetValidErrors
	add	esp, 16					; 00000010H
$LN19@xmlSchemaC:

; 10042: 	    vctxt->warning, vctxt->errCtxt);
; 10043: 	xmlSchemaSetParserStructuredErrors(vctxt->pctxt, vctxt->serror,

	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi+16]

; 21482:     if (ctxt == NULL)

	test	eax, eax
	je	SHORT $LN23@xmlSchemaC

; 21483: 	return;
; 21484:     ctxt->serror = serror;

	mov	DWORD PTR [eax+24], edx

; 21485:     ctxt->errCtxt = ctx;

	mov	DWORD PTR [eax+4], ecx

; 21486:     if (ctxt->vctxt != NULL)

	mov	eax, DWORD PTR [eax+92]
	test	eax, eax
	je	SHORT $LN23@xmlSchemaC

; 21487: 	xmlSchemaSetValidStructuredErrors(ctxt->vctxt, serror, ctx);

	push	ecx
	push	edx
	push	eax
	call	_xmlSchemaSetValidStructuredErrors
	add	esp, 12					; 0000000cH
$LN23@xmlSchemaC:
	pop	edi

; 10044: 	    vctxt->errCtxt);
; 10045:     }
; 10046:     return (0);

	xor	eax, eax

; 10047: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaCreatePCtxtOnVCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaNewParserCtxtUseDict
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_dict$ = 12						; size = 4
_xmlSchemaNewParserCtxtUseDict PROC			; COMDAT

; 10013: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlSchemaParserCtxtCreate
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN2@xmlSchemaN
	pop	esi

; 10024: }

	pop	ebp
	ret	0
$LN2@xmlSchemaN:
	push	edi

; 10014:     xmlSchemaParserCtxtPtr ret;
; 10015: 
; 10016:     ret = xmlSchemaParserCtxtCreate();
; 10017:     if (ret == NULL)
; 10018:         return (NULL);
; 10019:     ret->dict = dict;

	mov	edi, DWORD PTR _dict$[ebp]

; 10020:     xmlDictReference(dict);

	push	edi
	mov	DWORD PTR [esi+80], edi
	call	_xmlDictReference

; 10021:     if (URL != NULL)

	mov	eax, DWORD PTR _URL$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@xmlSchemaN

; 10022: 	ret->URL = xmlDictLookup(dict, (const xmlChar *) URL, -1);

	push	-1
	push	eax
	push	edi
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+44], eax
$LN3@xmlSchemaN:

; 10023:     return (ret);

	pop	edi
	mov	eax, esi
	pop	esi

; 10024: }

	pop	ebp
	ret	0
_xmlSchemaNewParserCtxtUseDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParserCtxtCreate
_TEXT	SEGMENT
_xmlSchemaParserCtxtCreate PROC				; COMDAT

; 9982 : {

	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	132					; 00000084H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlSchemaP

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CB@NCMLFNIB@allocating?5schema?5parser?5contex@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 9983 :     xmlSchemaParserCtxtPtr ret;
; 9984 : 
; 9985 :     ret = (xmlSchemaParserCtxtPtr) xmlMalloc(sizeof(xmlSchemaParserCtxt));
; 9986 :     if (ret == NULL) {
; 9987 :         xmlSchemaPErrMemory(NULL, "allocating schema parser context",
; 9988 :                             NULL);
; 9989 :         return (NULL);

	xor	eax, eax
	pop	esi

; 9999 : }

	ret	0
$LN2@xmlSchemaP:

; 9990 :     }
; 9991 :     memset(ret, 0, sizeof(xmlSchemaParserCtxt));

	push	128					; 00000080H
	lea	eax, DWORD PTR [esi+4]
	push	0
	push	eax
	call	_memset

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	push	12					; 0000000cH

; 9992 :     ret->type = XML_SCHEMA_CTXT_PARSER;

	mov	DWORD PTR [esi], 1

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	call	DWORD PTR _xmlMalloc
	add	esp, 16					; 00000010H

; 3342 :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@BAFOADOL@allocating?5an?5item?5list?5structu@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3345 : 	return (NULL);

	xor	eax, eax
	jmp	SHORT $LN8@xmlSchemaP
$LN9@xmlSchemaP:
	xorps	xmm0, xmm0

; 3346 :     }
; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));

	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], 0
$LN8@xmlSchemaP:

; 9993 :     ret->attrProhibs = xmlSchemaItemListCreate();

	mov	DWORD PTR [esi+128], eax

; 9994 :     if (ret->attrProhibs == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlSchemaP

; 9995 : 	xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 9996 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 9999 : }

	ret	0
$LN3@xmlSchemaP:

; 9997 :     }
; 9998 :     return(ret);

	mov	eax, esi
	pop	esi

; 9999 : }

	ret	0
_xmlSchemaParserCtxtCreate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaConstructionCtxtCreate
_TEXT	SEGMENT
_dict$ = 8						; size = 4
_xmlSchemaConstructionCtxtCreate PROC			; COMDAT

; 9949 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlSchemaC

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CH@HOMALJAM@allocating?5schema?5construction?5@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 9950 :     xmlSchemaConstructionCtxtPtr ret;
; 9951 : 
; 9952 :     ret = (xmlSchemaConstructionCtxtPtr)
; 9953 : 	xmlMalloc(sizeof(xmlSchemaConstructionCtxt));
; 9954 :     if (ret == NULL) {
; 9955 :         xmlSchemaPErrMemory(NULL,
; 9956 : 	    "allocating schema construction context", NULL);
; 9957 :         return (NULL);

	xor	eax, eax
	pop	esi

; 9978 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaC:
	xorps	xmm0, xmm0

; 9958 :     }
; 9959 :     memset(ret, 0, sizeof(xmlSchemaConstructionCtxt));

	movups	XMMWORD PTR [esi], xmm0

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	push	12					; 0000000cH

; 9958 :     }
; 9959 :     memset(ret, 0, sizeof(xmlSchemaConstructionCtxt));

	movups	XMMWORD PTR [esi+16], xmm0
	mov	DWORD PTR [esi+32], 0

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 3342 :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN10@xmlSchemaC

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@BAFOADOL@allocating?5an?5item?5list?5structu@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3345 : 	return (NULL);

	xor	eax, eax
	jmp	SHORT $LN9@xmlSchemaC
$LN10@xmlSchemaC:
	xorps	xmm0, xmm0

; 3346 :     }
; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));

	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], 0
$LN9@xmlSchemaC:

; 9960 : 
; 9961 :     ret->buckets = xmlSchemaItemListCreate();

	mov	DWORD PTR [esi+12], eax

; 9962 :     if (ret->buckets == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlSchemaC

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@KNCAMKIP@allocating?5list?5of?5schema?5bucke@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError

; 9963 : 	xmlSchemaPErrMemory(NULL,
; 9964 : 	    "allocating list of schema buckets", NULL);
; 9965 : 	xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 24					; 00000018H

; 9966 :         return (NULL);

	xor	eax, eax
	pop	esi

; 9978 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaC:

; 9967 :     }
; 9968 :     ret->pending = xmlSchemaItemListCreate();

	call	_xmlSchemaItemListCreate
	mov	DWORD PTR [esi+20], eax

; 9969 :     if (ret->pending == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlSchemaC

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CN@MGLOMDJH@allocating?5list?5of?5pending?5glob@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError

; 9970 : 	xmlSchemaPErrMemory(NULL,
; 9971 : 	    "allocating list of pending global components", NULL);
; 9972 : 	xmlSchemaConstructionCtxtFree(ret);

	push	esi
	call	_xmlSchemaConstructionCtxtFree
	add	esp, 24					; 00000018H

; 9973 :         return (NULL);

	xor	eax, eax
	pop	esi

; 9978 : }

	pop	ebp
	ret	0
$LN4@xmlSchemaC:

; 9974 :     }
; 9975 :     ret->dict = dict;

	mov	eax, DWORD PTR _dict$[ebp]

; 9976 :     xmlDictReference(dict);

	push	eax
	mov	DWORD PTR [esi+8], eax
	call	_xmlDictReference
	add	esp, 4

; 9977 :     return(ret);

	mov	eax, esi
	pop	esi

; 9978 : }

	pop	ebp
	ret	0
_xmlSchemaConstructionCtxtCreate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaConstructionCtxtFree
_TEXT	SEGMENT
_con$ = 8						; size = 4
_xmlSchemaConstructionCtxtFree PROC			; COMDAT

; 9927 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _con$[ebp]
	mov	esi, DWORD PTR [edi+12]
	test	esi, esi
	je	SHORT $LN8@xmlSchemaC

; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN10@xmlSchemaC

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlSchemaC:

; 3534 :     xmlFree(list);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlSchemaC:

; 9928 :     /*
; 9929 :     * After the construction context has been freed, there will be
; 9930 :     * no schema graph available any more. Only the schema buckets
; 9931 :     * will stay alive, which are put into the "schemasImports" and
; 9932 :     * "includes" slots of the xmlSchema.
; 9933 :     */
; 9934 :     if (con->buckets != NULL)
; 9935 : 	xmlSchemaItemListFree(con->buckets);
; 9936 :     if (con->pending != NULL)

	mov	esi, DWORD PTR [edi+20]
	test	esi, esi
	je	SHORT $LN12@xmlSchemaC

; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN14@xmlSchemaC

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlSchemaC:

; 3534 :     xmlFree(list);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlSchemaC:

; 9937 : 	xmlSchemaItemListFree(con->pending);
; 9938 :     if (con->substGroups != NULL)

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaC

; 9939 : 	xmlHashFree(con->substGroups, xmlSchemaSubstGroupFreeEntry);

	push	OFFSET _xmlSchemaSubstGroupFreeEntry
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN4@xmlSchemaC:

; 9940 :     if (con->redefs != NULL)

	mov	esi, DWORD PTR [edi+28]
	test	esi, esi
	je	SHORT $LN18@xmlSchemaC
$LL17@xmlSchemaC:

; 9921 : 	xmlFree(prev);

	push	esi
	mov	esi, DWORD PTR [esi]
	call	DWORD PTR _xmlFree
	add	esp, 4
	test	esi, esi
	jne	SHORT $LL17@xmlSchemaC
$LN18@xmlSchemaC:

; 9941 : 	xmlSchemaRedefListFree(con->redefs);
; 9942 :     if (con->dict != NULL)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN6@xmlSchemaC

; 9943 : 	xmlDictFree(con->dict);

	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN6@xmlSchemaC:

; 9944 :     xmlFree(con);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
	pop	esi

; 9945 : }

	pop	ebp
	ret	0
_xmlSchemaConstructionCtxtFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaRedefListFree
_TEXT	SEGMENT
_redef$ = 8						; size = 4
_xmlSchemaRedefListFree PROC				; COMDAT

; 9915 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _redef$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaR
$LL2@xmlSchemaR:

; 9916 :     xmlSchemaRedefPtr prev;
; 9917 : 
; 9918 :     while (redef != NULL) {
; 9919 : 	prev = redef;
; 9920 : 	redef = redef->next;
; 9921 : 	xmlFree(prev);

	push	esi
	mov	esi, DWORD PTR [esi]
	call	DWORD PTR _xmlFree
	add	esp, 4
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaR
$LN3@xmlSchemaR:
	pop	esi

; 9922 :     }
; 9923 : }

	pop	ebp
	ret	0
_xmlSchemaRedefListFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSchemaRelationCreate
_TEXT	SEGMENT
_xmlSchemaSchemaRelationCreate PROC			; COMDAT
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	16					; 00000010H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaS

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BL@CHFLODC@allocating?5schema?5relation@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 9893 :     xmlSchemaSchemaRelationPtr ret;
; 9894 : 
; 9895 :     ret = (xmlSchemaSchemaRelationPtr)
; 9896 : 	xmlMalloc(sizeof(xmlSchemaSchemaRelation));
; 9897 :     if (ret == NULL) {
; 9898 : 	xmlSchemaPErrMemory(NULL, "allocating schema relation", NULL);
; 9899 : 	return(NULL);

	xor	eax, eax

; 9902 :     return(ret);
; 9903 : }

	ret	0
$LN2@xmlSchemaS:
	xorps	xmm0, xmm0

; 9900 :     }
; 9901 :     memset(ret, 0, sizeof(xmlSchemaSchemaRelation));

	movups	XMMWORD PTR [eax], xmm0

; 9902 :     return(ret);
; 9903 : }

	ret	0
_xmlSchemaSchemaRelationCreate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseSchemaTopLevel
_TEXT	SEGMENT
_oldErrs$1$ = -8					; size = 4
_res$1$ = -4						; size = 4
_tmpOldErrs$2$ = 8					; size = 4
_tmpOldErrs$1$ = 8					; size = 4
_des$1 = 8						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_nodes$ = 16						; size = 4
_xmlSchemaParseSchemaTopLevel PROC			; COMDAT

; 9790 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	mov	DWORD PTR _res$1$[ebp], eax
	test	ebx, ebx
	je	$LN9@xmlSchemaP

; 9791 :     xmlNodePtr child;
; 9792 :     xmlSchemaAnnotPtr annot;
; 9793 :     int res = 0, oldErrs, tmpOldErrs;
; 9794 : 
; 9795 :     if ((ctxt == NULL) || (schema == NULL) || (nodes == NULL))

	mov	esi, DWORD PTR _schema$[ebp]
	test	esi, esi
	je	$LN9@xmlSchemaP
	mov	edi, DWORD PTR _nodes$[ebp]
	test	edi, edi
	je	$LN9@xmlSchemaP

; 9797 : 
; 9798 :     oldErrs = ctxt->nberrors;

	mov	ecx, DWORD PTR [ebx+20]
	mov	DWORD PTR _oldErrs$1$[ebp], ecx
	npad	1
$LL2@xmlSchemaP:

; 9799 :     child = nodes;
; 9800 :     while ((IS_SCHEMA(child, "include")) ||
; 9801 : 	   (IS_SCHEMA(child, "import")) ||
; 9802 : 	   (IS_SCHEMA(child, "redefine")) ||

	test	edi, edi
	je	$exit$169
	cmp	DWORD PTR [edi+36], 0
	je	$LN44@xmlSchemaP
	push	OFFSET ??_C@_07FHOHOHLG@include@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN10@xmlSchemaP
$LN11@xmlSchemaP:
	cmp	DWORD PTR [edi+36], 0
	je	$LN44@xmlSchemaP
	push	OFFSET ??_C@_06EOGGDCGF@import@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@xmlSchemaP
$LN12@xmlSchemaP:
	cmp	DWORD PTR [edi+36], 0
	je	$LN44@xmlSchemaP
	push	OFFSET ??_C@_08HCPHBLGO@redefine@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@xmlSchemaP
$LN13@xmlSchemaP:
	cmp	DWORD PTR [edi+36], 0
	je	$LN44@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LL4@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LL4@xmlSchemaP
$LN10@xmlSchemaP:

; 9803 : 	   (IS_SCHEMA(child, "annotation"))) {
; 9804 : 	if (IS_SCHEMA(child, "annotation")) {

	cmp	DWORD PTR [edi+36], 0
	je	SHORT $LN147@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlSchemaP

; 9805 : 	    annot = xmlSchemaParseAnnotation(ctxt, child, 1);

	push	1
	push	edi
	push	ebx
	call	_xmlSchemaParseAnnotation
	add	esp, 12					; 0000000cH

; 9806 : 	    if (schema->annot == NULL)

	cmp	DWORD PTR [esi+20], 0
	jne	SHORT $LN16@xmlSchemaP

; 9807 : 		schema->annot = annot;

	mov	DWORD PTR [esi+20], eax
$LN147@xmlSchemaP:

; 9830 : 		goto exit;
; 9831 : 	}
; 9832 : 	child = child->next;

	mov	eax, DWORD PTR _res$1$[ebp]
	mov	edi, DWORD PTR [edi+24]

; 9833 :     }

	jmp	$LL2@xmlSchemaP
$LN16@xmlSchemaP:

; 9808 : 	    else
; 9809 : 		xmlSchemaFreeAnnot(annot);

	push	eax
	call	_xmlSchemaFreeAnnot

; 9830 : 		goto exit;
; 9831 : 	}
; 9832 : 	child = child->next;

	mov	eax, DWORD PTR _res$1$[ebp]
	add	esp, 4
	mov	edi, DWORD PTR [edi+24]

; 9833 :     }

	jmp	$LL2@xmlSchemaP
$LN14@xmlSchemaP:

; 9810 : 	} else if (IS_SCHEMA(child, "import")) {

	cmp	DWORD PTR [edi+36], 0
	je	SHORT $LN147@xmlSchemaP
	push	OFFSET ??_C@_06EOGGDCGF@import@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlSchemaP

; 9811 : 	    tmpOldErrs = ctxt->nberrors;

	mov	eax, DWORD PTR [ebx+20]

; 9812 : 	    res = xmlSchemaParseImport(ctxt, schema, child);

	push	edi
	push	esi
	push	ebx
	mov	DWORD PTR _tmpOldErrs$1$[ebp], eax
	call	_xmlSchemaParseImport
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _res$1$[ebp], eax

; 9813 : 	    HFAILURE;

	cmp	eax, -1
	je	SHORT $LN9@xmlSchemaP

; 9814 : 	    HSTOP(ctxt);

	cmp	DWORD PTR [ebx+108], 0
	jne	$exit$169

; 9815 : 	    if (tmpOldErrs != ctxt->nberrors)

	mov	ecx, DWORD PTR _tmpOldErrs$1$[ebp]
	cmp	ecx, DWORD PTR [ebx+20]
	jne	$exit$169

; 9830 : 		goto exit;
; 9831 : 	}
; 9832 : 	child = child->next;

	mov	edi, DWORD PTR [edi+24]

; 9833 :     }

	jmp	$LL2@xmlSchemaP
$LN18@xmlSchemaP:

; 9816 : 		goto exit;
; 9817 : 	} else if (IS_SCHEMA(child, "include")) {

	cmp	DWORD PTR [edi+36], 0
	je	$LN147@xmlSchemaP
	push	OFFSET ??_C@_07FHOHOHLG@include@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xmlSchemaP

; 11219:     res = xmlSchemaParseIncludeOrRedefine(pctxt, schema, node,

	push	2
$LN167@xmlSchemaP:

; 9830 : 		goto exit;
; 9831 : 	}
; 9832 : 	child = child->next;

	mov	eax, DWORD PTR [ebx+20]
	push	edi
	push	esi
	push	ebx
	mov	DWORD PTR _tmpOldErrs$2$[ebp], eax
	call	_xmlSchemaParseIncludeOrRedefine
	add	esp, 16					; 00000010H
	mov	DWORD PTR _res$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN51@xmlSchemaP
	cmp	eax, -1
	jne	SHORT $LN116@xmlSchemaP
$LN9@xmlSchemaP:
$exit_failure$170:

; 9796 :         return(-1);

	or	eax, -1
$LN1@xmlSchemaP:
	pop	edi

; 9885 :     return(res);
; 9886 : exit_failure:
; 9887 :     return(-1);
; 9888 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@xmlSchemaP:

; 9830 : 		goto exit;
; 9831 : 	}
; 9832 : 	child = child->next;

	xor	eax, eax
	mov	DWORD PTR _res$1$[ebp], eax
$LN116@xmlSchemaP:
	cmp	DWORD PTR [ebx+108], 0
	jne	$exit$169
	mov	eax, DWORD PTR _tmpOldErrs$2$[ebp]
	cmp	eax, DWORD PTR [ebx+20]
	mov	eax, DWORD PTR _res$1$[ebp]
	jne	$exit$169
	mov	edi, DWORD PTR [edi+24]

; 9833 :     }

	jmp	$LL2@xmlSchemaP
$LN23@xmlSchemaP:

; 9818 : 	    tmpOldErrs = ctxt->nberrors;
; 9819 : 	    res = xmlSchemaParseInclude(ctxt, schema, child);
; 9820 : 	    HFAILURE;
; 9821 : 	    HSTOP(ctxt);
; 9822 : 	    if (tmpOldErrs != ctxt->nberrors)
; 9823 : 		goto exit;
; 9824 : 	} else if (IS_SCHEMA(child, "redefine")) {

	cmp	DWORD PTR [edi+36], 0
	je	$LN147@xmlSchemaP
	push	OFFSET ??_C@_08HCPHBLGO@redefine@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN147@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN147@xmlSchemaP

; 11206:     res = xmlSchemaParseIncludeOrRedefine(pctxt, schema, node,

	push	3

; 9825 : 	    tmpOldErrs = ctxt->nberrors;
; 9826 : 	    res = xmlSchemaParseRedefine(ctxt, schema, child);
; 9827 : 	    HFAILURE;

	jmp	$LN167@xmlSchemaP
$LL4@xmlSchemaP:

; 9839 : 	if (IS_SCHEMA(child, "complexType")) {

	cmp	DWORD PTR [edi+36], 0
	je	$LN44@xmlSchemaP
	push	OFFSET ??_C@_0M@OCBEIBDG@complexType@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN32@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN32@xmlSchemaP

; 9840 : 	    xmlSchemaParseComplexType(ctxt, schema, child, 1);

	push	1
	push	edi
	push	esi
	push	ebx
	call	_xmlSchemaParseComplexType
	add	esp, 16					; 00000010H

; 9841 : 	    child = child->next;

	jmp	$LN61@xmlSchemaP
$LN32@xmlSchemaP:

; 9842 : 	} else if (IS_SCHEMA(child, "simpleType")) {

	cmp	DWORD PTR [edi+36], 0
	je	$LN44@xmlSchemaP
	push	OFFSET ??_C@_0L@FMMGGLOP@simpleType@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN34@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN34@xmlSchemaP

; 9843 : 	    xmlSchemaParseSimpleType(ctxt, schema, child, 1);

	push	1
	push	edi
	push	esi
	push	ebx
	call	_xmlSchemaParseSimpleType
	add	esp, 16					; 00000010H

; 9844 : 	    child = child->next;

	jmp	$LN61@xmlSchemaP
$LN34@xmlSchemaP:

; 9845 : 	} else if (IS_SCHEMA(child, "element")) {

	cmp	DWORD PTR [edi+36], 0
	je	$LN44@xmlSchemaP
	push	OFFSET ??_C@_07HCLJNICE@element@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN36@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN36@xmlSchemaP

; 9846 : 	    xmlSchemaParseElement(ctxt, schema, child, NULL, 1);

	push	1
	push	0
	push	edi
	push	esi
	push	ebx
	call	_xmlSchemaParseElement
	add	esp, 20					; 00000014H

; 9847 : 	    child = child->next;

	jmp	$LN61@xmlSchemaP
$LN36@xmlSchemaP:

; 9848 : 	} else if (IS_SCHEMA(child, "attribute")) {

	cmp	DWORD PTR [edi+36], 0
	je	$LN44@xmlSchemaP
	push	OFFSET ??_C@_09HGIEBAJ@attribute@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN38@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN38@xmlSchemaP

; 9849 : 	    xmlSchemaParseGlobalAttribute(ctxt, schema, child);

	push	edi
	push	esi
	push	ebx
	call	_xmlSchemaParseGlobalAttribute
	add	esp, 12					; 0000000cH

; 9850 : 	    child = child->next;

	jmp	$LN61@xmlSchemaP
$LN38@xmlSchemaP:

; 9851 : 	} else if (IS_SCHEMA(child, "attributeGroup")) {

	cmp	DWORD PTR [edi+36], 0
	je	$LN44@xmlSchemaP
	push	OFFSET ??_C@_0P@KIDCOMBF@attributeGroup@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN40@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN40@xmlSchemaP

; 9852 : 	    xmlSchemaParseAttributeGroupDefinition(ctxt, schema, child);

	push	edi
	push	esi
	push	ebx
	call	_xmlSchemaParseAttributeGroupDefinition
	add	esp, 12					; 0000000cH

; 9853 : 	    child = child->next;

	jmp	$LN61@xmlSchemaP
$LN40@xmlSchemaP:

; 9854 : 	} else if (IS_SCHEMA(child, "group")) {

	cmp	DWORD PTR [edi+36], 0
	je	SHORT $LN44@xmlSchemaP
	push	OFFSET ??_C@_05MGJOOGAJ@group@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN42@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN42@xmlSchemaP

; 9855 : 	    xmlSchemaParseModelGroupDefinition(ctxt, schema, child);

	push	edi
	push	esi
	push	ebx
	call	_xmlSchemaParseModelGroupDefinition
	add	esp, 12					; 0000000cH

; 9856 : 	    child = child->next;

	jmp	$LN61@xmlSchemaP
$LN42@xmlSchemaP:

; 9857 : 	} else if (IS_SCHEMA(child, "notation")) {

	cmp	DWORD PTR [edi+36], 0
	je	SHORT $LN44@xmlSchemaP
	push	OFFSET ??_C@_08KNJKBPAF@notation@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN44@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN44@xmlSchemaP

; 9858 : 	    xmlSchemaParseNotation(ctxt, schema, child);

	push	edi
	push	esi
	push	ebx
	call	_xmlSchemaParseNotation
	add	esp, 12					; 0000000cH

; 9859 : 	    child = child->next;
; 9860 : 	} else {

	jmp	SHORT $LN61@xmlSchemaP
$LN44@xmlSchemaP:

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	DWORD PTR [edi+20]
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0JG@PPPAGMJA@?$CI?$CIinclude?5?$HM?5import?5?$HM?5redefine?5?$HM@
	push	DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	edi
	push	ebx
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN61@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN61@xmlSchemaP:

; 9861 : 	    xmlSchemaPContentErr(ctxt,
; 9862 : 		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 9863 : 		NULL, child->parent, child,
; 9864 : 		NULL, "((include | import | redefine | annotation)*, "
; 9865 : 		"(((simpleType | complexType | group | attributeGroup) "
; 9866 : 		"| element | attribute | notation), annotation*)*)");
; 9867 : 	    child = child->next;
; 9868 : 	}
; 9869 : 	while (IS_SCHEMA(child, "annotation")) {

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	je	$LN139@xmlSchemaP
	npad	5
$LL6@xmlSchemaP:
	cmp	DWORD PTR [edi+36], 0
	je	SHORT $LN142@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN142@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN142@xmlSchemaP

; 9870 : 	    /*
; 9871 : 	    * TODO: We should add all annotations.
; 9872 : 	    */
; 9873 : 	    annot = xmlSchemaParseAnnotation(ctxt, child, 1);

	push	1
	push	edi
	push	ebx
	call	_xmlSchemaParseAnnotation
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 9874 : 	    if (schema->annot == NULL)

	mov	eax, DWORD PTR _schema$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN46@xmlSchemaP

; 9875 : 		schema->annot = annot;

	mov	DWORD PTR [eax+20], esi
	jmp	SHORT $LN83@xmlSchemaP
$LN46@xmlSchemaP:

; 3729 :     if (annot == NULL)

	test	esi, esi
	je	SHORT $LN83@xmlSchemaP

; 3730 :         return;
; 3731 :     if (annot->next == NULL) {

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LL84@xmlSchemaP

; 3732 : 	xmlFree(annot);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3733 :     } else {

	jmp	SHORT $LN83@xmlSchemaP
$LL84@xmlSchemaP:

; 3734 : 	xmlSchemaAnnotPtr prev;
; 3735 : 
; 3736 : 	do {
; 3737 : 	    prev = annot;
; 3738 : 	    annot = annot->next;
; 3739 : 	    xmlFree(prev);

	push	esi
	mov	esi, DWORD PTR [esi]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3740 : 	} while (annot != NULL);

	test	esi, esi
	jne	SHORT $LL84@xmlSchemaP
$LN83@xmlSchemaP:

; 9876 : 	    else
; 9877 : 		xmlSchemaFreeAnnot(annot);
; 9878 : 	    child = child->next;

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	SHORT $LL6@xmlSchemaP

; 9861 : 	    xmlSchemaPContentErr(ctxt,
; 9862 : 		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 9863 : 		NULL, child->parent, child,
; 9864 : 		NULL, "((include | import | redefine | annotation)*, "
; 9865 : 		"(((simpleType | complexType | group | attributeGroup) "
; 9866 : 		"| element | attribute | notation), annotation*)*)");
; 9867 : 	    child = child->next;
; 9868 : 	}
; 9869 : 	while (IS_SCHEMA(child, "annotation")) {

	jmp	SHORT $LN139@xmlSchemaP
$LN142@xmlSchemaP:

; 9834 :     /*
; 9835 :     * URGENT TODO: Change the functions to return int results.
; 9836 :     * We need especially to catch internal errors.
; 9837 :     */
; 9838 :     while (child != NULL) {

	mov	esi, DWORD PTR _schema$[ebp]
	test	edi, edi
	jne	$LL4@xmlSchemaP
$LN139@xmlSchemaP:

; 9828 : 	    HSTOP(ctxt);
; 9829 : 	    if (tmpOldErrs != ctxt->nberrors)

	mov	eax, DWORD PTR _res$1$[ebp]
$exit$169:

; 9879 : 	}
; 9880 :     }
; 9881 : exit:
; 9882 :     ctxt->ctxtType = NULL;
; 9883 :     if (oldErrs != ctxt->nberrors)

	mov	esi, DWORD PTR _oldErrs$1$[ebp]
	mov	DWORD PTR [ebx+84], 0
	cmp	esi, DWORD PTR [ebx+20]
	je	$LN1@xmlSchemaP

; 9884 : 	res = ctxt->err;

	mov	eax, DWORD PTR [ebx+16]
	pop	edi

; 9885 :     return(res);
; 9886 : exit_failure:
; 9887 :     return(-1);
; 9888 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseSchemaTopLevel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseSchemaElement
_TEXT	SEGMENT
_oldErrs$1$ = -16					; size = 4
_attr$2$ = -12						; size = 4
_val$3$ = -8						; size = 4
_attr$3$ = -8						; size = 4
_res$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_val$4$ = 16						; size = 4
_node$ = 16						; size = 4
_xmlSchemaParseSchemaElement PROC			; COMDAT

; 9674 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]

; 4664 :     if ((node == NULL) || (name == NULL))

	mov	edi, DWORD PTR _node$[ebp]

; 9675 :     xmlAttrPtr attr;
; 9676 :     const xmlChar *val;
; 9677 :     int res = 0, oldErrs = ctxt->nberrors;

	mov	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR _oldErrs$1$[ebp], eax

; 4664 :     if ((node == NULL) || (name == NULL))

	test	edi, edi
	je	SHORT $LN192@xmlSchemaP

; 4665 : 	return(NULL);
; 4666 :     prop = node->properties;

	mov	esi, DWORD PTR [edi+44]

; 4667 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN192@xmlSchemaP
	npad	6
$LL24@xmlSchemaP:

; 4668 :         if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN28@xmlSchemaP
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@xmlSchemaP
$LN28@xmlSchemaP:

; 4669 : 	    return(prop);
; 4670 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL24@xmlSchemaP
$LN192@xmlSchemaP:

; 6040 : 	return(0);

	xor	ebx, ebx
$LN193@xmlSchemaP:

; 4664 :     if ((node == NULL) || (name == NULL))

	test	edi, edi
	je	$LN198@xmlSchemaP

; 4665 : 	return(NULL);
; 4666 :     prop = node->properties;

	mov	esi, DWORD PTR [edi+44]

; 4667 :     while (prop != NULL) {

	test	esi, esi
	je	$LN197@xmlSchemaP
$LL31@xmlSchemaP:

; 4668 :         if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN35@xmlSchemaP
	push	OFFSET ??_C@_0BA@JJLDNFDJ@targetNamespace@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@xmlSchemaP
$LN35@xmlSchemaP:

; 4669 : 	    return(prop);
; 4670 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL31@xmlSchemaP

; 4667 :     while (prop != NULL) {

	jmp	SHORT $LN197@xmlSchemaP
$LN21@xmlSchemaP:

; 6041 :     return(xmlSchemaPValAttrNodeID(ctxt, attr));

	push	esi
	push	ebx
	call	_xmlSchemaPValAttrNodeID
	mov	ebx, eax
	add	esp, 8

; 9678 : 
; 9679 :     /*
; 9680 :     * Those flags should be moved to the parser context flags,
; 9681 :     * since they are not visible at the component level. I.e.
; 9682 :     * they are used if processing schema *documents* only.
; 9683 :     */
; 9684 :     res = xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
; 9685 :     HFAILURE;

	cmp	ebx, -1
	jne	SHORT $LN193@xmlSchemaP
$exit_failure$215:
	pop	edi

; 9773 :     return(res);
; 9774 : exit_failure:
; 9775 :     return(-1);
; 9776 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@xmlSchemaP:

; 9686 : 
; 9687 :     /*
; 9688 :     * Since the version is of type xs:token, we won't bother to
; 9689 :     * check it.
; 9690 :     */
; 9691 :     /* REMOVED:
; 9692 :     attr = xmlSchemaGetPropNode(node, "version");
; 9693 :     if (attr != NULL) {
; 9694 : 	res = xmlSchemaPValAttrNode(ctxt, NULL, NULL, attr,
; 9695 : 	    xmlSchemaGetBuiltInType(XML_SCHEMAS_TOKEN), &val);
; 9696 : 	HFAILURE;
; 9697 :     }
; 9698 :     */
; 9699 :     attr = xmlSchemaGetPropNode(node, "targetNamespace");
; 9700 :     if (attr != NULL) {
; 9701 : 	res = xmlSchemaPValAttrNode(ctxt, NULL, attr,

	push	29					; 0000001dH
	call	_xmlSchemaGetBuiltInType
	mov	edi, eax
	add	esp, 4

; 6385 :     if ((ctxt == NULL) || (type == NULL) || (attr == NULL))

	test	edi, edi
	je	SHORT $exit_failure$215

; 6386 : 	return (-1);
; 6387 : 
; 6388 :     val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	esi
	push	ebx
	call	_xmlSchemaGetNodeContent

; 6389 :     if (value != NULL)
; 6390 : 	*value = val;
; 6391 : 
; 6392 :     return (xmlSchemaPValAttrNodeValue(ctxt, ownerItem, attr,

	push	edi
	push	eax
	push	esi
	push	0
	push	ebx
	call	_xmlSchemaPValAttrNodeValue
	mov	ebx, eax
	add	esp, 28					; 0000001cH

; 9702 : 	    xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI), NULL);
; 9703 : 	HFAILURE;

	cmp	ebx, -1
	je	SHORT $exit_failure$215

; 9704 : 	if (res != 0) {

	test	ebx, ebx
	je	SHORT $LN209@xmlSchemaP

; 9705 : 	    ctxt->stop = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+108], 3037		; 00000bddH

; 9706 : 	    goto exit;

	jmp	$exit$216
$LN209@xmlSchemaP:

; 9704 : 	if (res != 0) {

	mov	edi, DWORD PTR _node$[ebp]
$LN197@xmlSchemaP:

; 4666 :     prop = node->properties;

	mov	esi, DWORD PTR [edi+44]

; 4667 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN198@xmlSchemaP
$LL43@xmlSchemaP:

; 4668 :         if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN47@xmlSchemaP
	push	OFFSET ??_C@_0BD@GLAKFDIM@elementFormDefault@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN42@xmlSchemaP
$LN47@xmlSchemaP:

; 4669 : 	    return(prop);
; 4670 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL43@xmlSchemaP

; 4667 :     while (prop != NULL) {

	jmp	SHORT $LN198@xmlSchemaP
$LN42@xmlSchemaP:

; 9707 : 	}
; 9708 :     }
; 9709 :     attr = xmlSchemaGetPropNode(node, "elementFormDefault");
; 9710 :     if (attr != NULL) {
; 9711 : 	val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	esi
	push	eax
	call	_xmlSchemaGetNodeContent

; 9712 : 	res = xmlSchemaPValAttrFormDefault(val, &schema->flags,

	mov	ecx, DWORD PTR _schema$[ebp]
	mov	edi, eax
	push	1
	add	ecx, 24					; 00000018H
	push	ecx
	push	edi
	call	_xmlSchemaPValAttrFormDefault
	mov	ebx, eax
	add	esp, 20					; 00000014H

; 9713 : 	    XML_SCHEMAS_QUALIF_ELEM);
; 9714 : 	HFAILURE;

	cmp	ebx, -1
	je	$exit_failure$215

; 9715 : 	if (res != 0) {

	test	ebx, ebx
	je	SHORT $LN208@xmlSchemaP

; 9716 : 	    xmlSchemaPSimpleTypeErr(ctxt,

	push	0
	push	0
	push	0
	push	edi
	push	OFFSET ??_C@_0BK@IDHDHMBC@?$CIqualified?5?$HM?5unqualified?$CJ@
	push	0
	push	esi
	push	0
	push	1705					; 000006a9H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPSimpleTypeErr
	add	esp, 40					; 00000028H
$LN208@xmlSchemaP:

; 9717 : 		XML_SCHEMAP_ELEMFORMDEFAULT_VALUE,
; 9718 : 		NULL, (xmlNodePtr) attr, NULL,
; 9719 : 		"(qualified | unqualified)", val, NULL, NULL, NULL);
; 9720 : 	}
; 9721 :     }
; 9722 :     attr = xmlSchemaGetPropNode(node, "attributeFormDefault");

	mov	edi, DWORD PTR _node$[ebp]
$LN198@xmlSchemaP:
	push	OFFSET ??_C@_0BF@PMHAPIPB@attributeFormDefault@
	push	edi
	call	_xmlSchemaGetPropNode
	mov	esi, eax
	add	esp, 8

; 9723 :     if (attr != NULL) {

	test	esi, esi
	je	SHORT $LN212@xmlSchemaP

; 9724 : 	val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaGetNodeContent

; 9725 : 	res = xmlSchemaPValAttrFormDefault(val, &schema->flags,

	mov	ecx, DWORD PTR _schema$[ebp]
	mov	edi, eax
	push	2
	add	ecx, 24					; 00000018H
	push	ecx
	push	edi
	call	_xmlSchemaPValAttrFormDefault
	mov	ebx, eax
	add	esp, 20					; 00000014H

; 9726 : 	    XML_SCHEMAS_QUALIF_ATTR);
; 9727 : 	HFAILURE;

	cmp	ebx, -1
	je	$exit_failure$215

; 9728 : 	if (res != 0) {

	test	ebx, ebx
	je	SHORT $LN207@xmlSchemaP

; 9729 : 	    xmlSchemaPSimpleTypeErr(ctxt,

	push	0
	push	0
	push	0
	push	edi
	push	OFFSET ??_C@_0BK@IDHDHMBC@?$CIqualified?5?$HM?5unqualified?$CJ@
	push	0
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	0
	push	1701					; 000006a5H
	push	esi
	call	_xmlSchemaPSimpleTypeErr
	mov	edi, DWORD PTR _node$[ebp]
	add	esp, 40					; 00000028H
	jmp	SHORT $LN11@xmlSchemaP
$LN207@xmlSchemaP:

; 9728 : 	if (res != 0) {

	mov	edi, DWORD PTR _node$[ebp]
$LN212@xmlSchemaP:

; 9730 : 		XML_SCHEMAP_ATTRFORMDEFAULT_VALUE,
; 9731 : 		NULL, (xmlNodePtr) attr, NULL,
; 9732 : 		"(qualified | unqualified)", val, NULL, NULL, NULL);
; 9733 : 	}
; 9734 :     }
; 9735 :     attr = xmlSchemaGetPropNode(node, "finalDefault");

	mov	esi, DWORD PTR _ctxt$[ebp]
$LN11@xmlSchemaP:
	push	OFFSET ??_C@_0N@DFGPIJFA@finalDefault@
	push	edi
	call	_xmlSchemaGetPropNode
	add	esp, 8
	mov	DWORD PTR _attr$2$[ebp], eax

; 9736 :     if (attr != NULL) {

	test	eax, eax
	je	$LN14@xmlSchemaP

; 9737 : 	val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	push	eax
	push	esi
	call	_xmlSchemaGetNodeContent

; 9738 : 	res = xmlSchemaPValAttrBlockFinal(val, &(schema->flags), -1,

	mov	ebx, DWORD PTR _schema$[ebp]
	add	esp, 8

; 7953 :     int ret = 0;

	mov	DWORD PTR _res$1$[ebp], 0

; 9737 : 	val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	mov	esi, eax
	mov	DWORD PTR _val$3$[ebp], esi

; 9738 : 	res = xmlSchemaPValAttrBlockFinal(val, &(schema->flags), -1,

	add	ebx, 24					; 00000018H

; 7958 :     if ((flags == NULL) || (value == NULL))

	je	$exit_failure$215
	test	esi, esi
	je	$exit_failure$215

; 7959 : 	return (-1);
; 7960 :     if (value[0] == 0)

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN59@xmlSchemaP

; 7961 : 	return (0);

	xor	ebx, ebx
	jmp	$LN14@xmlSchemaP
$LN59@xmlSchemaP:

; 7962 :     if (xmlStrEqual(value, BAD_CAST "#all")) {

	push	OFFSET ??_C@_04LEKDNLLP@?$CDall@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN60@xmlSchemaP

; 7972 : 	    if (flagList != -1)
; 7973 : 		*flags |= flagList;
; 7974 : 	    if (flagUnion != -1)
; 7975 : 		*flags |= flagUnion;

	or	DWORD PTR [ebx], 60			; 0000003cH

; 7976 : 	}
; 7977 :     } else {

	jmp	$LN51@xmlSchemaP
$LN60@xmlSchemaP:

; 7978 : 	const xmlChar *end, *cur = value;

	mov	ecx, esi
	npad	4
$LL53@xmlSchemaP:

; 7979 : 	xmlChar *item;
; 7980 : 
; 7981 : 	do {
; 7982 : 	    while (IS_BLANK_CH(*cur))

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN69@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN70@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN69@xmlSchemaP
$LN70@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN54@xmlSchemaP
$LN69@xmlSchemaP:

; 7983 : 		cur++;

	inc	ecx
	jmp	SHORT $LL53@xmlSchemaP
$LN54@xmlSchemaP:

; 7984 : 	    end = cur;

	mov	esi, ecx

; 7985 : 	    while ((*end != 0) && (!(IS_BLANK_CH(*end))))

	test	al, al
	je	$LN206@xmlSchemaP
	npad	1
$LL55@xmlSchemaP:
	cmp	al, 32					; 00000020H
	je	SHORT $LN56@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN71@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN56@xmlSchemaP
$LN71@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN56@xmlSchemaP
	mov	al, BYTE PTR [esi+1]

; 7986 : 		end++;

	inc	esi
	test	al, al
	jne	SHORT $LL55@xmlSchemaP
$LN56@xmlSchemaP:

; 7987 : 	    if (end == cur)

	cmp	esi, ecx
	je	$LN206@xmlSchemaP

; 7988 : 		break;
; 7989 : 	    item = xmlStrndup(cur, end - cur);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	call	_xmlStrndup
	mov	edi, eax

; 7990 : 	    if (xmlStrEqual(item, BAD_CAST "extension")) {

	push	OFFSET ??_C@_09ODADEDNA@extension@
	push	edi
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN73@xmlSchemaP

; 7991 : 		if (flagExtension != -1) {
; 7992 : 		    if ((*flags & flagExtension) == 0)

	mov	eax, DWORD PTR [ebx]
	test	al, 4
	jne	$LN94@xmlSchemaP

; 7993 : 			*flags |= flagExtension;

	or	eax, 4
	mov	DWORD PTR [ebx], eax

; 7994 : 		} else
; 7995 : 		    ret = 1;
; 7996 : 	    } else if (xmlStrEqual(item, BAD_CAST "restriction")) {

	jmp	SHORT $LN94@xmlSchemaP
$LN73@xmlSchemaP:
	push	OFFSET ??_C@_0M@FBFLGGFO@restriction@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN78@xmlSchemaP

; 7997 : 		if (flagRestriction != -1) {
; 7998 : 		    if ((*flags & flagRestriction) == 0)

	mov	eax, DWORD PTR [ebx]
	test	al, 8
	jne	SHORT $LN94@xmlSchemaP

; 7999 : 			*flags |= flagRestriction;

	or	eax, 8
	mov	DWORD PTR [ebx], eax

; 8000 : 		} else
; 8001 : 		    ret = 1;
; 8002 : 	    } else if (xmlStrEqual(item, BAD_CAST "substitution")) {

	jmp	SHORT $LN94@xmlSchemaP
$LN78@xmlSchemaP:
	push	OFFSET ??_C@_0N@INDADLAA@substitution@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN93@xmlSchemaP

; 8006 : 		} else
; 8007 : 		    ret = 1;
; 8008 : 	    } else if (xmlStrEqual(item, BAD_CAST "list")) {

	push	OFFSET ??_C@_04DONFEANM@list@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN88@xmlSchemaP

; 8009 : 		if (flagList != -1) {
; 8010 : 		    if ((*flags & flagList) == 0)

	mov	eax, DWORD PTR [ebx]
	test	al, 16					; 00000010H
	jne	SHORT $LN94@xmlSchemaP

; 8011 : 			*flags |= flagList;

	or	eax, 16					; 00000010H
	mov	DWORD PTR [ebx], eax

; 8012 : 		} else
; 8013 : 		    ret = 1;
; 8014 : 	    } else if (xmlStrEqual(item, BAD_CAST "union")) {

	jmp	SHORT $LN94@xmlSchemaP
$LN88@xmlSchemaP:
	push	OFFSET ??_C@_05MNALHJLP@union@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN93@xmlSchemaP

; 8015 : 		if (flagUnion != -1) {
; 8016 : 		    if ((*flags & flagUnion) == 0)

	mov	eax, DWORD PTR [ebx]
	test	al, 32					; 00000020H
	jne	SHORT $LN94@xmlSchemaP

; 8017 : 			*flags |= flagUnion;

	or	eax, 32					; 00000020H
	mov	DWORD PTR [ebx], eax

; 8018 : 		} else
; 8019 : 		    ret = 1;
; 8020 : 	    } else

	jmp	SHORT $LN94@xmlSchemaP
$LN93@xmlSchemaP:

; 8021 : 		ret = 1;
; 8022 : 	    if (item != NULL)

	mov	DWORD PTR _res$1$[ebp], 1
$LN94@xmlSchemaP:
	test	edi, edi
	je	SHORT $LN98@xmlSchemaP

; 8023 : 		xmlFree(item);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN98@xmlSchemaP:

; 8024 : 	    cur = end;
; 8025 : 	} while ((ret == 0) && (*cur != 0));

	cmp	DWORD PTR _res$1$[ebp], 0
	mov	ecx, esi
	jne	SHORT $LN206@xmlSchemaP
	cmp	BYTE PTR [esi], 0
	jne	$LL53@xmlSchemaP
$LN206@xmlSchemaP:

; 9739 : 	    XML_SCHEMAS_FINAL_DEFAULT_EXTENSION,
; 9740 : 	    XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION,
; 9741 : 	    -1,
; 9742 : 	    XML_SCHEMAS_FINAL_DEFAULT_LIST,
; 9743 : 	    XML_SCHEMAS_FINAL_DEFAULT_UNION);
; 9744 : 	HFAILURE;

	mov	esi, DWORD PTR _val$3$[ebp]
	mov	edi, DWORD PTR _node$[ebp]
$LN51@xmlSchemaP:
	mov	ebx, DWORD PTR _res$1$[ebp]
	cmp	ebx, -1
	je	$exit_failure$215

; 9745 : 	if (res != 0) {

	test	ebx, ebx
	je	SHORT $LN14@xmlSchemaP

; 9746 : 	    xmlSchemaPSimpleTypeErr(ctxt,

	push	0
	push	0
	push	0
	push	esi
	push	OFFSET ??_C@_0DK@JHFKOEOC@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@
	push	0
	push	DWORD PTR _attr$2$[ebp]
	push	0
	push	3037					; 00000bddH
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPSimpleTypeErr
	add	esp, 40					; 00000028H
$LN14@xmlSchemaP:

; 9747 : 		XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 9748 : 		NULL, (xmlNodePtr) attr, NULL,
; 9749 : 		"(#all | List of (extension | restriction | list | union))",
; 9750 : 		val, NULL, NULL, NULL);
; 9751 : 	}
; 9752 :     }
; 9753 :     attr = xmlSchemaGetPropNode(node, "blockDefault");

	push	OFFSET ??_C@_0N@MMGPPGOC@blockDefault@
	push	edi
	call	_xmlSchemaGetPropNode
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR _attr$3$[ebp], edi

; 9754 :     if (attr != NULL) {

	test	edi, edi
	je	SHORT $LN211@xmlSchemaP

; 9755 : 	val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaGetNodeContent

; 9756 : 	res = xmlSchemaPValAttrBlockFinal(val, &(schema->flags), -1,

	mov	ebx, DWORD PTR _schema$[ebp]
	add	esp, 8

; 7953 :     int ret = 0;

	mov	DWORD PTR _res$1$[ebp], 0

; 9755 : 	val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	mov	esi, eax
	mov	DWORD PTR _val$4$[ebp], esi

; 9756 : 	res = xmlSchemaPValAttrBlockFinal(val, &(schema->flags), -1,

	add	ebx, 24					; 00000018H

; 7958 :     if ((flags == NULL) || (value == NULL))

	je	$exit_failure$215
	test	esi, esi
	je	$exit_failure$215

; 7959 : 	return (-1);
; 7960 :     if (value[0] == 0)

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN111@xmlSchemaP

; 7961 : 	return (0);

	xor	ebx, ebx
$LN211@xmlSchemaP:

; 9763 : 		XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 9764 : 		NULL, (xmlNodePtr) attr, NULL,
; 9765 : 		"(#all | List of (extension | restriction | substitution))",
; 9766 : 		val, NULL, NULL, NULL);
; 9767 : 	}
; 9768 :     }
; 9769 : 
; 9770 : exit:
; 9771 :     if (oldErrs != ctxt->nberrors)

	mov	eax, DWORD PTR _ctxt$[ebp]
$exit$216:
	mov	ecx, DWORD PTR _oldErrs$1$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	je	SHORT $LN18@xmlSchemaP

; 9772 : 	res = ctxt->err;

	mov	ebx, DWORD PTR [eax+16]
$LN18@xmlSchemaP:
	pop	edi

; 9773 :     return(res);
; 9774 : exit_failure:
; 9775 :     return(-1);
; 9776 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN111@xmlSchemaP:

; 7962 :     if (xmlStrEqual(value, BAD_CAST "#all")) {

	push	OFFSET ??_C@_04LEKDNLLP@?$CDall@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN112@xmlSchemaP

; 7963 : 	if (flagAll != -1)
; 7964 : 	    *flags |= flagAll;
; 7965 : 	else {
; 7966 : 	    if (flagExtension != -1)
; 7967 : 		*flags |= flagExtension;
; 7968 : 	    if (flagRestriction != -1)
; 7969 : 		*flags |= flagRestriction;
; 7970 : 	    if (flagSubstitution != -1)
; 7971 : 		*flags |= flagSubstitution;

	or	DWORD PTR [ebx], 448			; 000001c0H

; 7976 : 	}
; 7977 :     } else {

	jmp	$LN103@xmlSchemaP
$LN112@xmlSchemaP:

; 7978 : 	const xmlChar *end, *cur = value;

	mov	ecx, esi
	npad	2
$LL105@xmlSchemaP:

; 7979 : 	xmlChar *item;
; 7980 : 
; 7981 : 	do {
; 7982 : 	    while (IS_BLANK_CH(*cur))

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN121@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN122@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN121@xmlSchemaP
$LN122@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN106@xmlSchemaP
$LN121@xmlSchemaP:

; 7983 : 		cur++;

	inc	ecx
	jmp	SHORT $LL105@xmlSchemaP
$LN106@xmlSchemaP:

; 7984 : 	    end = cur;

	mov	esi, ecx

; 7985 : 	    while ((*end != 0) && (!(IS_BLANK_CH(*end))))

	test	al, al
	je	$LN204@xmlSchemaP
	npad	1
$LL107@xmlSchemaP:
	cmp	al, 32					; 00000020H
	je	SHORT $LN108@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN123@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN108@xmlSchemaP
$LN123@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN108@xmlSchemaP
	mov	al, BYTE PTR [esi+1]

; 7986 : 		end++;

	inc	esi
	test	al, al
	jne	SHORT $LL107@xmlSchemaP
$LN108@xmlSchemaP:

; 7987 : 	    if (end == cur)

	cmp	esi, ecx
	je	$LN204@xmlSchemaP

; 7988 : 		break;
; 7989 : 	    item = xmlStrndup(cur, end - cur);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	call	_xmlStrndup
	mov	edi, eax

; 7990 : 	    if (xmlStrEqual(item, BAD_CAST "extension")) {

	push	OFFSET ??_C@_09ODADEDNA@extension@
	push	edi
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN125@xmlSchemaP

; 7991 : 		if (flagExtension != -1) {
; 7992 : 		    if ((*flags & flagExtension) == 0)

	mov	eax, DWORD PTR [ebx]
	test	al, 64					; 00000040H
	jne	SHORT $LN145@xmlSchemaP

; 7993 : 			*flags |= flagExtension;

	or	eax, 64					; 00000040H
	mov	DWORD PTR [ebx], eax

; 7994 : 		} else
; 7995 : 		    ret = 1;
; 7996 : 	    } else if (xmlStrEqual(item, BAD_CAST "restriction")) {

	jmp	SHORT $LN145@xmlSchemaP
$LN125@xmlSchemaP:
	push	OFFSET ??_C@_0M@FBFLGGFO@restriction@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN130@xmlSchemaP

; 7997 : 		if (flagRestriction != -1) {
; 7998 : 		    if ((*flags & flagRestriction) == 0)

	mov	eax, DWORD PTR [ebx]
	test	al, al
	js	SHORT $LN145@xmlSchemaP

; 7999 : 			*flags |= flagRestriction;

	or	eax, 128				; 00000080H
	mov	DWORD PTR [ebx], eax

; 8000 : 		} else
; 8001 : 		    ret = 1;
; 8002 : 	    } else if (xmlStrEqual(item, BAD_CAST "substitution")) {

	jmp	SHORT $LN145@xmlSchemaP
$LN130@xmlSchemaP:
	push	OFFSET ??_C@_0N@INDADLAA@substitution@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN135@xmlSchemaP

; 8003 : 		if (flagSubstitution != -1) {
; 8004 : 		    if ((*flags & flagSubstitution) == 0)

	mov	eax, DWORD PTR [ebx]
	test	eax, 256				; 00000100H
	jne	SHORT $LN145@xmlSchemaP

; 8005 : 			*flags |= flagSubstitution;

	or	eax, 256				; 00000100H
	mov	DWORD PTR [ebx], eax

; 8006 : 		} else
; 8007 : 		    ret = 1;
; 8008 : 	    } else if (xmlStrEqual(item, BAD_CAST "list")) {

	jmp	SHORT $LN145@xmlSchemaP
$LN135@xmlSchemaP:
	push	OFFSET ??_C@_04DONFEANM@list@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN213@xmlSchemaP

; 8012 : 		} else
; 8013 : 		    ret = 1;
; 8014 : 	    } else if (xmlStrEqual(item, BAD_CAST "union")) {

	push	OFFSET ??_C@_05MNALHJLP@union@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
$LN213@xmlSchemaP:

; 8021 : 		ret = 1;
; 8022 : 	    if (item != NULL)

	mov	DWORD PTR _res$1$[ebp], 1
$LN145@xmlSchemaP:
	test	edi, edi
	je	SHORT $LN150@xmlSchemaP

; 8023 : 		xmlFree(item);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN150@xmlSchemaP:

; 8024 : 	    cur = end;
; 8025 : 	} while ((ret == 0) && (*cur != 0));

	cmp	DWORD PTR _res$1$[ebp], 0
	mov	ecx, esi
	jne	SHORT $LN204@xmlSchemaP
	cmp	BYTE PTR [esi], 0
	jne	$LL105@xmlSchemaP
$LN204@xmlSchemaP:

; 9757 : 	    XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION,
; 9758 : 	    XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION,
; 9759 : 	    XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION, -1, -1);
; 9760 : 	HFAILURE;

	mov	esi, DWORD PTR _val$4$[ebp]
	mov	edi, DWORD PTR _attr$3$[ebp]
$LN103@xmlSchemaP:
	mov	ebx, DWORD PTR _res$1$[ebp]
	cmp	ebx, -1
	je	$exit_failure$215

; 9761 : 	if (res != 0) {

	test	ebx, ebx
	je	$LN211@xmlSchemaP

; 9762 : 	    xmlSchemaPSimpleTypeErr(ctxt,

	push	0
	push	0
	push	0
	push	esi
	push	OFFSET ??_C@_0DK@DDAOLEFB@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@
	push	0
	push	edi
	push	0
	push	3037					; 00000bddH
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPSimpleTypeErr
	add	esp, 40					; 00000028H
	jmp	$LN211@xmlSchemaP
_xmlSchemaParseSchemaElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaClearSchemaDefaults
_TEXT	SEGMENT
_schema$ = 8						; size = 4
_xmlSchemaClearSchemaDefaults PROC			; COMDAT

; 9646 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _schema$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	test	al, 1
	je	SHORT $LN2@xmlSchemaC

; 9647 :     if (schema->flags & XML_SCHEMAS_QUALIF_ELEM)
; 9648 : 	schema->flags ^= XML_SCHEMAS_QUALIF_ELEM;

	xor	eax, 1
	mov	DWORD PTR [ecx+24], eax
$LN2@xmlSchemaC:

; 9649 : 
; 9650 :     if (schema->flags & XML_SCHEMAS_QUALIF_ATTR)

	test	al, 2
	je	SHORT $LN3@xmlSchemaC

; 9651 : 	schema->flags ^= XML_SCHEMAS_QUALIF_ATTR;

	xor	eax, 2
	mov	DWORD PTR [ecx+24], eax
$LN3@xmlSchemaC:

; 9652 : 
; 9653 :     if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_EXTENSION)

	test	al, 4
	je	SHORT $LN4@xmlSchemaC

; 9654 : 	schema->flags ^= XML_SCHEMAS_FINAL_DEFAULT_EXTENSION;

	xor	eax, 4
	mov	DWORD PTR [ecx+24], eax
$LN4@xmlSchemaC:

; 9655 :     if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION)

	test	al, 8
	je	SHORT $LN5@xmlSchemaC

; 9656 : 	schema->flags ^= XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION;

	xor	eax, 8
	mov	DWORD PTR [ecx+24], eax
$LN5@xmlSchemaC:

; 9657 :     if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_LIST)

	test	al, 16					; 00000010H
	je	SHORT $LN6@xmlSchemaC

; 9658 : 	schema->flags ^= XML_SCHEMAS_FINAL_DEFAULT_LIST;

	xor	eax, 16					; 00000010H
	mov	DWORD PTR [ecx+24], eax
$LN6@xmlSchemaC:

; 9659 :     if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_UNION)

	test	al, 32					; 00000020H
	je	SHORT $LN7@xmlSchemaC

; 9660 : 	schema->flags ^= XML_SCHEMAS_FINAL_DEFAULT_UNION;

	xor	eax, 32					; 00000020H
	mov	DWORD PTR [ecx+24], eax
$LN7@xmlSchemaC:

; 9661 : 
; 9662 :     if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION)

	test	al, 64					; 00000040H
	je	SHORT $LN8@xmlSchemaC

; 9663 : 	schema->flags ^= XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION;

	xor	eax, 64					; 00000040H
	mov	DWORD PTR [ecx+24], eax
$LN8@xmlSchemaC:

; 9664 :     if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION)

	test	al, al
	jns	SHORT $LN9@xmlSchemaC

; 9665 : 	schema->flags ^= XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION;

	xor	eax, 128				; 00000080H
	mov	DWORD PTR [ecx+24], eax
$LN9@xmlSchemaC:

; 9666 :     if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION)

	test	eax, 256				; 00000100H
	je	SHORT $LN10@xmlSchemaC

; 9667 : 	schema->flags ^= XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION;

	xor	eax, 256				; 00000100H
	mov	DWORD PTR [ecx+24], eax
$LN10@xmlSchemaC:

; 9668 : }

	pop	ebp
	ret	0
_xmlSchemaClearSchemaDefaults ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCleanupDoc
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_root$ = 12						; size = 4
_xmlSchemaCleanupDoc PROC				; COMDAT

; 9577 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _ctxt$[ebp], 0
	je	$LN8@xmlSchemaC

; 9578 :     xmlNodePtr delete, cur;
; 9579 : 
; 9580 :     if ((ctxt == NULL) || (root == NULL)) return;

	push	ebx
	mov	ebx, DWORD PTR _root$[ebp]
	test	ebx, ebx
	je	$LN46@xmlSchemaC

; 9581 : 
; 9582 :     /*
; 9583 :      * Remove all the blank text nodes
; 9584 :      */
; 9585 :     delete = NULL;

	push	esi
	push	edi
	xor	edi, edi

; 9586 :     cur = root;

	mov	esi, ebx
	npad	7
$LL2@xmlSchemaC:

; 9588 :         if (delete != NULL) {

	test	edi, edi
	je	SHORT $LN9@xmlSchemaC

; 9589 :             xmlUnlinkNode(delete);

	push	edi
	call	_xmlUnlinkNode

; 9590 :             xmlFreeNode(delete);

	push	edi
	call	_xmlFreeNode
	add	esp, 8

; 9591 :             delete = NULL;

	xor	edi, edi
$LN9@xmlSchemaC:

; 9592 :         }
; 9593 :         if (cur->type == XML_TEXT_NODE) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 3
	jne	SHORT $LN10@xmlSchemaC

; 9594 :             if (IS_BLANK_NODE(cur)) {

	push	-1
	push	DWORD PTR [esi+40]
	call	_xmlSchemaIsBlank
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlSchemaC

; 9595 :                 if (xmlNodeGetSpacePreserve(cur) != 1) {

	push	esi
	call	_xmlNodeGetSpacePreserve
	add	esp, 4
	cmp	eax, 1
	je	SHORT $LN14@xmlSchemaC

; 9596 :                     delete = cur;

	mov	edi, esi
$LN14@xmlSchemaC:

; 9603 :         }
; 9604 : 
; 9605 :         /*
; 9606 :          * Skip to next node
; 9607 :          */
; 9608 :         if (cur->children != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $skip_children$51

; 9609 :             if ((cur->children->type != XML_ENTITY_DECL) &&
; 9610 :                 (cur->children->type != XML_ENTITY_REF_NODE) &&

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 17					; 00000011H
	je	SHORT $skip_children$51
	cmp	ecx, 5
	je	SHORT $skip_children$51
	cmp	ecx, 6
	jne	SHORT $LN48@xmlSchemaC

; 9611 :                 (cur->children->type != XML_ENTITY_NODE)) {
; 9612 :                 cur = cur->children;
; 9613 :                 continue;
; 9614 :             }
; 9615 :         }
; 9616 :       skip_children:
; 9617 :         if (cur->next != NULL) {
; 9618 :             cur = cur->next;
; 9619 :             continue;

	jmp	SHORT $skip_children$51
$LN10@xmlSchemaC:

; 9597 :                 }
; 9598 :             }
; 9599 :         } else if ((cur->type != XML_ELEMENT_NODE) &&

	cmp	eax, 1
	je	SHORT $LN14@xmlSchemaC
	cmp	eax, 4
	je	SHORT $LN14@xmlSchemaC

; 9600 :                    (cur->type != XML_CDATA_SECTION_NODE)) {
; 9601 :             delete = cur;

	mov	edi, esi

; 9602 :             goto skip_children;

	jmp	SHORT $skip_children$51
$LL6@xmlSchemaC:

; 9620 :         }
; 9621 : 
; 9622 :         do {
; 9623 :             cur = cur->parent;

	mov	esi, DWORD PTR [esi+20]

; 9624 :             if (cur == NULL)

	test	esi, esi
	je	SHORT $LN28@xmlSchemaC

; 9625 :                 break;
; 9626 :             if (cur == root) {

	cmp	esi, ebx
	je	SHORT $LN28@xmlSchemaC
$skip_children$51:

; 9587 :     while (cur != NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LL6@xmlSchemaC
$LN48@xmlSchemaC:
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaC
$LN28@xmlSchemaC:

; 9627 :                 cur = NULL;
; 9628 :                 break;
; 9629 :             }
; 9630 :             if (cur->next != NULL) {
; 9631 :                 cur = cur->next;
; 9632 :                 break;
; 9633 :             }
; 9634 :         } while (cur != NULL);
; 9635 :     }
; 9636 :     if (delete != NULL) {

	test	edi, edi
	je	SHORT $LN47@xmlSchemaC

; 9637 :         xmlUnlinkNode(delete);

	push	edi
	call	_xmlUnlinkNode

; 9638 :         xmlFreeNode(delete);

	push	edi
	call	_xmlFreeNode
	add	esp, 8
$LN47@xmlSchemaC:
	pop	edi
	pop	esi
$LN46@xmlSchemaC:
	pop	ebx
$LN8@xmlSchemaC:

; 9639 :         delete = NULL;
; 9640 :     }
; 9641 : }

	pop	ebp
	ret	0
_xmlSchemaCleanupDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseModelGroupDefinition
_TEXT	SEGMENT
_val$1$ = -8						; size = 4
_attr$1$ = -4						; size = 4
_nsName$1$ = 8						; size = 4
_type$1$ = 8						; size = 4
_des$1 = 8						; size = 4
_des$2 = 8						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaParseModelGroupDefinition PROC		; COMDAT

; 9493 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN5@xmlSchemaP

; 9494 :     xmlSchemaModelGroupDefPtr item;
; 9495 :     xmlNodePtr child = NULL;
; 9496 :     xmlAttrPtr attr;
; 9497 :     const xmlChar *name;
; 9498 : 
; 9499 :     if ((ctxt == NULL) || (schema == NULL) || (node == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	SHORT $LN5@xmlSchemaP
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlSchemaP

; 9501 : 
; 9502 :     attr = xmlSchemaGetPropNode(node, "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	esi
	call	_xmlSchemaGetPropNode
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _attr$1$[ebp], ebx

; 9503 :     if (attr == NULL) {

	test	ebx, ebx
	jne	SHORT $LN6@xmlSchemaP

; 2802 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	esi
	push	eax
	push	eax
	mov	DWORD PTR _des$2[ebp], eax
	lea	eax, DWORD PTR _des$2[ebp]
	push	eax
	call	_xmlSchemaFormatItemForReport

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	mov	eax, DWORD PTR _des$2[ebp]
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	push	OFFSET ??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@
	push	ebx
	push	ebx
	push	ebx
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	inc	DWORD PTR [edi+20]
	push	ebx
	push	ebx
	push	2
	push	3036					; 00000bdcH
	push	16					; 00000010H
	push	esi
	push	edi
	push	DWORD PTR [edi+4]
	mov	DWORD PTR [edi+16], 3036		; 00000bdcH
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+24]
	call	___xmlRaiseError

; 2810 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$2[ebp]

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 88					; 00000058H

; 2810 :     FREE_AND_NULL(des);

	test	eax, eax
	je	SHORT $LN5@xmlSchemaP
	push	eax

; 9500 :         return (NULL);

	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlSchemaP:

; 9560 : 	xmlSchemaPContentErr(ctxt,
; 9561 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 9562 : 	    NULL, node, child, NULL,
; 9563 : 	    "(annotation?, (all | choice | sequence)?)");
; 9564 :     }
; 9565 :     return (item);
; 9566 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlSchemaP:

; 9504 : 	xmlSchemaPMissingAttrErr(ctxt,
; 9505 : 	    XML_SCHEMAP_S4S_ATTR_MISSING,
; 9506 : 	    NULL, node,
; 9507 : 	    "name", NULL);
; 9508 : 	return (NULL);
; 9509 :     } else if (xmlSchemaPValAttrNode(ctxt, NULL, attr,
; 9510 : 	xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {

	push	22					; 00000016H
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	mov	DWORD PTR _type$1$[ebp], eax

; 6385 :     if ((ctxt == NULL) || (type == NULL) || (attr == NULL))

	test	eax, eax
	je	SHORT $LN5@xmlSchemaP

; 6386 : 	return (-1);
; 6387 : 
; 6388 :     val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	push	ebx
	push	edi
	call	_xmlSchemaGetNodeContent

; 6389 :     if (value != NULL)
; 6390 : 	*value = val;
; 6391 : 
; 6392 :     return (xmlSchemaPValAttrNodeValue(ctxt, ownerItem, attr,

	push	DWORD PTR _type$1$[ebp]
	mov	ebx, eax
	push	ebx
	push	DWORD PTR _attr$1$[ebp]
	mov	DWORD PTR _val$1$[ebp], ebx
	push	0
	push	edi
	call	_xmlSchemaPValAttrNodeValue
	add	esp, 28					; 0000001cH

; 9504 : 	xmlSchemaPMissingAttrErr(ctxt,
; 9505 : 	    XML_SCHEMAP_S4S_ATTR_MISSING,
; 9506 : 	    NULL, node,
; 9507 : 	    "name", NULL);
; 9508 : 	return (NULL);
; 9509 :     } else if (xmlSchemaPValAttrNode(ctxt, NULL, attr,
; 9510 : 	xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {

	test	eax, eax
	jne	SHORT $LN5@xmlSchemaP

; 9511 : 	return (NULL);
; 9512 :     }
; 9513 :     item = xmlSchemaAddModelGroupDefinition(ctxt, schema, name,

	mov	eax, DWORD PTR [edi+112]
	mov	DWORD PTR _nsName$1$[ebp], eax

; 5595 :     if ((ctxt == NULL) || (schema == NULL) || (name == NULL))

	test	ebx, ebx
	je	SHORT $LN5@xmlSchemaP

; 5596 :         return (NULL);
; 5597 : 
; 5598 :     ret = (xmlSchemaModelGroupDefPtr)

	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4

; 5599 : 	xmlMalloc(sizeof(xmlSchemaModelGroupDef));
; 5600 :     if (ret == NULL) {

	test	ebx, ebx
	jne	SHORT $LN38@xmlSchemaP

; 5601 :         xmlSchemaPErrMemory(ctxt, "adding group", NULL);

	push	eax
	push	OFFSET ??_C@_0N@MMNEFFIM@adding?5group@
	push	edi
	call	_xmlSchemaPErrMemory
	add	esp, 12					; 0000000cH

; 9500 :         return (NULL);

	xor	eax, eax
	pop	edi

; 9560 : 	xmlSchemaPContentErr(ctxt,
; 9561 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 9562 : 	    NULL, node, child, NULL,
; 9563 : 	    "(annotation?, (all | choice | sequence)?)");
; 9564 :     }
; 9565 :     return (item);
; 9566 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@xmlSchemaP:

; 5605 :     ret->name = name;

	mov	eax, DWORD PTR _val$1$[ebp]
	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+12], 0
	mov	DWORD PTR [ebx+28], 0

; 5606 :     ret->type = XML_SCHEMA_TYPE_GROUP;
; 5607 :     ret->node = node;
; 5608 :     ret->targetNamespace = nsName;

	mov	ecx, DWORD PTR _nsName$1$[ebp]
	mov	DWORD PTR [ebx+16], eax
	mov	DWORD PTR [ebx], 17			; 00000011H
	mov	DWORD PTR [ebx+24], esi
	mov	DWORD PTR [ebx+20], ecx

; 5609 : 
; 5610 :     if (ctxt->isRedefine) {

	cmp	DWORD PTR [edi+100], 0
	je	SHORT $LN39@xmlSchemaP

; 5611 : 	ctxt->redef = xmlSchemaAddRedef(ctxt, ctxt->redefined,

	push	ecx
	push	eax
	push	ebx
	push	DWORD PTR [edi+116]
	push	edi
	call	_xmlSchemaAddRedef
	add	esp, 20					; 00000014H
	mov	DWORD PTR [edi+120], eax

; 5612 : 	    ret, name, nsName);
; 5613 : 	if (ctxt->redef == NULL) {

	test	eax, eax
	jne	SHORT $LN40@xmlSchemaP

; 5614 : 	    xmlFree(ret);

	push	ebx

; 9500 :         return (NULL);

	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	edi

; 9560 : 	xmlSchemaPContentErr(ctxt,
; 9561 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 9562 : 	    NULL, node, child, NULL,
; 9563 : 	    "(annotation?, (all | choice | sequence)?)");
; 9564 :     }
; 9565 :     return (item);
; 9566 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@xmlSchemaP:

; 5617 : 	ctxt->redefCounter = 0;

	mov	DWORD PTR [edi+124], 0
$LN39@xmlSchemaP:

; 5618 :     }
; 5619 :     WXS_ADD_GLOBAL(ctxt, ret);

	mov	eax, DWORD PTR [edi+28]
	push	ebx
	push	5
	mov	eax, DWORD PTR [eax+16]
	add	eax, 44					; 0000002cH
	push	eax
	call	_xmlSchemaAddItemSize

; 5620 :     WXS_ADD_PENDING(ctxt, ret);

	mov	eax, DWORD PTR [edi+28]
	push	ebx
	add	eax, 20					; 00000014H
	push	10					; 0000000aH
	push	eax
	call	_xmlSchemaAddItemSize

; 9514 : 	ctxt->targetNamespace, node);
; 9515 :     if (item == NULL)
; 9516 : 	return (NULL);
; 9517 :     /*
; 9518 :     * Check for illegal attributes.
; 9519 :     */
; 9520 :     attr = node->properties;

	mov	esi, DWORD PTR [esi+44]

; 5620 :     WXS_ADD_PENDING(ctxt, ret);

	add	esp, 24					; 00000018H

; 9521 :     while (attr != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlSchemaP
$LL2@xmlSchemaP:

; 9522 : 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN10@xmlSchemaP

; 9523 : 	    if ((!xmlStrEqual(attr->name, BAD_CAST "name")) &&

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlSchemaP
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlSchemaP

; 9524 : 		(!xmlStrEqual(attr->name, BAD_CAST "id"))) {
; 9525 : 		xmlSchemaPIllegalAttrErr(ctxt,
; 9526 : 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 9527 : 	    }

	jmp	SHORT $LN73@xmlSchemaP
$LN10@xmlSchemaP:

; 9528 : 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlSchemaP
$LN73@xmlSchemaP:

; 9529 : 	    xmlSchemaPIllegalAttrErr(ctxt,
; 9530 : 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 9531 : 	}
; 9532 : 	attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN13@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaP
$LN3@xmlSchemaP:

; 9533 :     }
; 9534 :     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");

	mov	esi, DWORD PTR _node$[ebp]
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	esi
	push	edi
	call	_xmlSchemaPValAttrID

; 9535 :     /*
; 9536 :     * And now for the children...
; 9537 :     */
; 9538 :     child = node->children;

	mov	esi, DWORD PTR [esi+12]
	add	esp, 12					; 0000000cH

; 9539 :     if (IS_SCHEMA(child, "annotation")) {

	test	esi, esi
	je	$LN47@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN14@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlSchemaP

; 9540 : 	item->annot = xmlSchemaParseAnnotation(ctxt, child, 1);

	push	1
	push	esi
	push	edi
	call	_xmlSchemaParseAnnotation
	mov	DWORD PTR [ebx+4], eax
	add	esp, 12					; 0000000cH

; 9541 : 	child = child->next;

	mov	esi, DWORD PTR [esi+24]
$LN14@xmlSchemaP:

; 9542 :     }
; 9543 :     if (IS_SCHEMA(child, "all")) {

	test	esi, esi
	je	$LN47@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	$LN19@xmlSchemaP
	push	OFFSET ??_C@_03NFKEKGGK@all@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlSchemaP

; 9544 : 	item->children = xmlSchemaParseModelGroup(ctxt, schema, child,

	push	0
	push	8

; 9545 : 	    XML_SCHEMA_TYPE_ALL, 0);
; 9546 : 	child = child->next;

	jmp	SHORT $LN77@xmlSchemaP
$LN15@xmlSchemaP:

; 9547 :     } else if (IS_SCHEMA(child, "choice")) {

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN19@xmlSchemaP
	push	OFFSET ??_C@_06DDDNEJEA@choice@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlSchemaP

; 9548 : 	item->children = xmlSchemaParseModelGroup(ctxt, schema, child,

	push	0
	push	7

; 9549 : 	    XML_SCHEMA_TYPE_CHOICE, 0);
; 9550 : 	child = child->next;

	jmp	SHORT $LN77@xmlSchemaP
$LN17@xmlSchemaP:

; 9551 :     } else if (IS_SCHEMA(child, "sequence")) {

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN19@xmlSchemaP
	push	OFFSET ??_C@_08IBBDGPOF@sequence@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@xmlSchemaP

; 9552 : 	item->children = xmlSchemaParseModelGroup(ctxt, schema, child,

	push	0
	push	6
$LN77@xmlSchemaP:

; 9553 : 	    XML_SCHEMA_TYPE_SEQUENCE, 0);
; 9554 : 	child = child->next;
; 9555 :     }
; 9556 : 
; 9557 : 
; 9558 : 
; 9559 :     if (child != NULL) {

	push	esi
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaParseModelGroup
	mov	DWORD PTR [ebx+12], eax
	add	esp, 20					; 00000014H
	mov	esi, DWORD PTR [esi+24]
$LN19@xmlSchemaP:
	test	esi, esi
	je	SHORT $LN47@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0CK@IMPEKNJM@?$CIannotation?$DP?0?5?$CIall?5?$HM?5choice?5?$HM?5s@
	push	DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	edi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN47@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN47@xmlSchemaP:
	pop	edi

; 9560 : 	xmlSchemaPContentErr(ctxt,
; 9561 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 9562 : 	    NULL, node, child, NULL,
; 9563 : 	    "(annotation?, (all | choice | sequence)?)");
; 9564 :     }
; 9565 :     return (item);
; 9566 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseModelGroupDefinition ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseModelGroupDefRef
_TEXT	SEGMENT
_item$1$ = -20						; size = 4
_ref$ = -16						; size = 4
_max$1$ = -12						; size = 4
_min$1$ = -8						; size = 4
_refNs$ = -4						; size = 4
_des$1 = 8						; size = 4
_des$2 = 8						; size = 4
_attr$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaParseModelGroupDefRef PROC			; COMDAT

; 9391 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _ref$[ebp], 0
	mov	DWORD PTR _refNs$[ebp], 0
	test	edi, edi
	je	$LN5@xmlSchemaP

; 9392 :     xmlSchemaParticlePtr item;
; 9393 :     xmlNodePtr child = NULL;
; 9394 :     xmlAttrPtr attr;
; 9395 :     const xmlChar *ref = NULL, *refNs = NULL;
; 9396 :     int min, max;
; 9397 : 
; 9398 :     if ((ctxt == NULL) || (schema == NULL) || (node == NULL))

	mov	esi, DWORD PTR _schema$[ebp]
	test	esi, esi
	je	$LN5@xmlSchemaP
	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	SHORT $LN5@xmlSchemaP

; 9399 :         return (NULL);
; 9400 : 
; 9401 :     attr = xmlSchemaGetPropNode(node, "ref");

	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	ebx
	call	_xmlSchemaGetPropNode
	add	esp, 8
	mov	DWORD PTR _attr$1$[ebp], eax

; 9402 :     if (attr == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlSchemaP

; 2802 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	eax
	push	eax
	mov	DWORD PTR _des$2[ebp], eax
	lea	eax, DWORD PTR _des$2[ebp]
	push	eax
	call	_xmlSchemaFormatItemForReport

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	mov	eax, DWORD PTR _des$2[ebp]
	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	eax
	push	OFFSET ??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	eax
	inc	DWORD PTR [edi+20]
	push	0
	push	0
	push	2
	push	3036					; 00000bdcH
	push	16					; 00000010H
	push	ebx
	push	edi
	push	DWORD PTR [edi+4]
	mov	DWORD PTR [edi+16], 3036		; 00000bdcH
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+24]
	call	___xmlRaiseError

; 2810 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$2[ebp]

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 88					; 00000058H

; 2810 :     FREE_AND_NULL(des);

	test	eax, eax
	je	SHORT $LN5@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlSchemaP:
	pop	edi

; 9470 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlSchemaP:

; 9403 : 	xmlSchemaPMissingAttrErr(ctxt,
; 9404 : 	    XML_SCHEMAP_S4S_ATTR_MISSING,
; 9405 : 	    NULL, node, "ref", NULL);
; 9406 : 	return (NULL);
; 9407 :     } else if (xmlSchemaPValAttrNodeQName(ctxt, schema, NULL,
; 9408 : 	attr, &refNs, &ref) != 0) {

	lea	ecx, DWORD PTR _ref$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _refNs$[ebp]
	push	ecx
	push	eax
	push	0
	push	esi
	push	edi
	call	_xmlSchemaPValAttrNodeQName
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN5@xmlSchemaP

; 9409 : 	return (NULL);
; 9410 :     }
; 9411 :     xmlSchemaCheckReference(ctxt, schema, node, attr, refNs);

	push	DWORD PTR _refNs$[ebp]
	push	DWORD PTR _attr$1$[ebp]
	push	ebx
	push	esi
	push	edi
	call	_xmlSchemaCheckReference

; 9412 :     min = xmlGetMinOccurs(ctxt, node, 0, -1, 1, "xs:nonNegativeInteger");

	push	OFFSET ??_C@_0BG@FKFDAFPO@xs?3nonNegativeInteger@
	push	1
	push	-1
	push	0
	push	ebx
	push	edi
	call	_xmlGetMinOccurs

; 9413 :     max = xmlGetMaxOccurs(ctxt, node, 0, UNBOUNDED, 1,

	push	OFFSET ??_C@_0CE@BEMOBFLH@?$CIxs?3nonNegativeInteger?5?$HM?5unboun@
	push	1
	push	1073741824				; 40000000H
	push	0
	push	ebx
	push	edi
	mov	DWORD PTR _min$1$[ebp], eax
	call	_xmlGetMaxOccurs

; 9414 : 	"(xs:nonNegativeInteger | unbounded)");
; 9415 :     /*
; 9416 :     * Check for illegal attributes.
; 9417 :     */
; 9418 :     attr = node->properties;

	mov	esi, DWORD PTR [ebx+44]
	add	esp, 68					; 00000044H
	mov	DWORD PTR _max$1$[ebp], eax

; 9419 :     while (attr != NULL) {

	test	esi, esi
	je	$LN3@xmlSchemaP
$LL2@xmlSchemaP:

; 9420 : 	if (attr->ns == NULL) {

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	jne	SHORT $LN9@xmlSchemaP

; 9421 : 	    if ((!xmlStrEqual(attr->name, BAD_CAST "ref")) &&
; 9422 : 		(!xmlStrEqual(attr->name, BAD_CAST "id")) &&
; 9423 : 		(!xmlStrEqual(attr->name, BAD_CAST "minOccurs")) &&

	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlSchemaP
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlSchemaP
	push	OFFSET ??_C@_09OAPKCOGD@minOccurs@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlSchemaP
	push	OFFSET ??_C@_09OBPGLENH@maxOccurs@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlSchemaP

; 9424 : 		(!xmlStrEqual(attr->name, BAD_CAST "maxOccurs"))) {
; 9425 : 		xmlSchemaPIllegalAttrErr(ctxt,
; 9426 : 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 9427 : 	    }

	jmp	SHORT $LN55@xmlSchemaP
$LN9@xmlSchemaP:

; 9428 : 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [ecx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlSchemaP
$LN55@xmlSchemaP:

; 9429 : 	    xmlSchemaPIllegalAttrErr(ctxt,
; 9430 : 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 9431 : 	}
; 9432 : 	attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN12@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	$LL2@xmlSchemaP
$LN3@xmlSchemaP:

; 9433 :     }
; 9434 :     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	ebx
	push	edi
	call	_xmlSchemaPValAttrID

; 9435 :     item = xmlSchemaAddParticle(ctxt, node, min, max);

	push	DWORD PTR _max$1$[ebp]
	push	DWORD PTR _min$1$[ebp]
	push	ebx
	push	edi
	call	_xmlSchemaAddParticle
	mov	esi, eax
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _item$1$[ebp], esi

; 9436 :     if (item == NULL)

	test	esi, esi
	je	$LN5@xmlSchemaP

; 9437 : 	return (NULL);
; 9438 :     /*
; 9439 :     * Create a qname-reference and set as the term; it will be substituted
; 9440 :     * for the model group after the reference has been resolved.
; 9441 :     */
; 9442 :     item->children = (xmlSchemaTreeItemPtr)

	push	DWORD PTR _refNs$[ebp]
	push	DWORD PTR _ref$[ebp]
	push	17					; 00000011H
	push	edi
	call	_xmlSchemaNewQNameRef

; 9443 : 	xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_GROUP, ref, refNs);
; 9444 :     xmlSchemaPCheckParticleCorrect_2(ctxt, item, node, min, max);

	push	DWORD PTR _max$1$[ebp]
	mov	DWORD PTR [esi+12], eax
	push	DWORD PTR _min$1$[ebp]
	push	ebx
	push	esi
	push	edi
	call	_xmlSchemaPCheckParticleCorrect_2

; 9445 :     /*
; 9446 :     * And now for the children...
; 9447 :     */
; 9448 :     child = node->children;

	mov	esi, DWORD PTR [ebx+12]
	add	esp, 36					; 00000024H

; 9449 :     /* TODO: Is annotation even allowed for a model group reference? */
; 9450 :     if (IS_SCHEMA(child, "annotation")) {

	test	esi, esi
	je	$LN31@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN14@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlSchemaP

; 9451 : 	/*
; 9452 : 	* TODO: What to do exactly with the annotation?
; 9453 : 	*/
; 9454 : 	item->annot = xmlSchemaParseAnnotation(ctxt, child, 1);

	push	1
	push	esi
	push	edi
	call	_xmlSchemaParseAnnotation
	mov	ecx, DWORD PTR _item$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+4], eax

; 9455 : 	child = child->next;

	mov	esi, DWORD PTR [esi+24]
$LN14@xmlSchemaP:

; 9456 :     }
; 9457 :     if (child != NULL) {

	test	esi, esi
	je	SHORT $LN31@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	0
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0O@MNAJHLGE@?$CIannotation?$DP?$CJ@
	push	DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	edi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN31@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN31@xmlSchemaP:

; 9458 : 	xmlSchemaPContentErr(ctxt,
; 9459 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 9460 : 	    NULL, node, child, NULL,
; 9461 : 	    "(annotation?)");
; 9462 :     }
; 9463 :     /*
; 9464 :     * Corresponds to no component at all if minOccurs==maxOccurs==0.
; 9465 :     */
; 9466 :     if ((min == 0) && (max == 0))

	cmp	DWORD PTR _min$1$[ebp], 0
	jne	SHORT $LN16@xmlSchemaP
	cmp	DWORD PTR _max$1$[ebp], 0
	je	$LN5@xmlSchemaP
$LN16@xmlSchemaP:

; 9467 : 	return (NULL);
; 9468 : 
; 9469 :     return ((xmlSchemaTreeItemPtr) item);

	mov	eax, DWORD PTR _item$1$[ebp]
	pop	edi

; 9470 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseModelGroupDefRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseUnion
_TEXT	SEGMENT
_localName$1 = -20					; size = 4
_nsName$2 = -16						; size = 4
_attr$2$ = -12						; size = 4
_lastLink$1$ = -8					; size = 4
_type$1$ = -4						; size = 4
_des$3 = 8						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaParseUnion PROC				; COMDAT

; 8896 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	je	$LN14@xmlSchemaP

; 8897 :     xmlSchemaTypePtr type;
; 8898 :     xmlNodePtr child = NULL;
; 8899 :     xmlAttrPtr attr;
; 8900 :     const xmlChar *cur = NULL;
; 8901 : 
; 8902 :     if ((ctxt == NULL) || (schema == NULL) || (node == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	$LN14@xmlSchemaP
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	$LN14@xmlSchemaP

; 8903 :         return (-1);
; 8904 :     /* Not a component, don't create it. */
; 8905 :     type = ctxt->ctxtType;

	mov	edi, DWORD PTR [ebx+84]

; 8906 :     /*
; 8907 :     * Mark the simple type as being of variety "union".
; 8908 :     */
; 8909 :     type->flags |= XML_SCHEMAS_TYPE_VARIETY_UNION;
; 8910 :     /*
; 8911 :     * SPEC (Base type) (2) "If the <list> or <union> alternative is chosen,
; 8912 :     * then the `simple ur-type definition`."
; 8913 :     */
; 8914 :     type->baseType = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);

	push	46					; 0000002eH
	mov	DWORD PTR _type$1$[ebp], edi
	or	DWORD PTR [edi+48], 128			; 00000080H
	call	_xmlSchemaGetBuiltInType
	mov	DWORD PTR [edi+64], eax
	add	esp, 4

; 8915 :     /*
; 8916 :     * Check for illegal attributes.
; 8917 :     */
; 8918 :     attr = node->properties;

	mov	esi, DWORD PTR [esi+44]

; 8919 :     while (attr != NULL) {

	test	esi, esi
	je	$LN204@xmlSchemaP
$LL2@xmlSchemaP:

; 8920 : 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN15@xmlSchemaP

; 8921 : 	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN18@xmlSchemaP
	push	OFFSET ??_C@_0M@OEMIGMAO@memberTypes@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN18@xmlSchemaP

; 8922 : 		(!xmlStrEqual(attr->name, BAD_CAST "memberTypes"))) {
; 8923 : 		xmlSchemaPIllegalAttrErr(ctxt,
; 8924 : 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 8925 : 	    }

	jmp	SHORT $LN213@xmlSchemaP
$LN15@xmlSchemaP:

; 8926 : 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlSchemaP
$LN213@xmlSchemaP:

; 8927 : 	    xmlSchemaPIllegalAttrErr(ctxt,
; 8928 : 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 8929 : 	}
; 8930 : 	attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	ebx
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN18@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaP
	mov	esi, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [esi+44]

; 4667 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN204@xmlSchemaP
$LL43@xmlSchemaP:

; 4668 :         if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN47@xmlSchemaP
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN42@xmlSchemaP
$LN47@xmlSchemaP:

; 4669 : 	    return(prop);
; 4670 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL43@xmlSchemaP

; 3242 : }
; 3243 : 
; 3244 : /************************************************************************
; 3245 :  *									*
; 3246 :  *			Streamable error functions                      *
; 3247 :  *									*
; 3248 :  ************************************************************************/
; 3249 : 
; 3250 : 
; 3251 : 
; 3252 : 
; 3253 : /************************************************************************
; 3254 :  *									*
; 3255 :  *			Validation helper functions			*
; 3256 :  *									*
; 3257 :  ************************************************************************/
; 3258 : 
; 3259 : 
; 3260 : /************************************************************************
; 3261 :  *									*
; 3262 :  *			Allocation functions				*
; 3263 :  *									*
; 3264 :  ************************************************************************/
; 3265 : 
; 3266 : /**
; 3267 :  * xmlSchemaNewSchemaForParserCtxt:
; 3268 :  * @ctxt:  a schema validation context
; 3269 :  *
; 3270 :  * Allocate a new Schema structure.
; 3271 :  *
; 3272 :  * Returns the newly allocated structure or NULL in case or error
; 3273 :  */
; 3274 : static xmlSchemaPtr
; 3275 : xmlSchemaNewSchema(xmlSchemaParserCtxtPtr ctxt)
; 3276 : {
; 3277 :     xmlSchemaPtr ret;
; 3278 : 
; 3279 :     ret = (xmlSchemaPtr) xmlMalloc(sizeof(xmlSchema));
; 3280 :     if (ret == NULL) {
; 3281 :         xmlSchemaPErrMemory(ctxt, "allocating schema", NULL);
; 3282 :         return (NULL);
; 3283 :     }
; 3284 :     memset(ret, 0, sizeof(xmlSchema));
; 3285 :     ret->dict = ctxt->dict;
; 3286 :     xmlDictReference(ret->dict);
; 3287 : 
; 3288 :     return (ret);
; 3289 : }
; 3290 : 
; 3291 : /**
; 3292 :  * xmlSchemaNewFacet:
; 3293 :  *
; 3294 :  * Allocate a new Facet structure.
; 3295 :  *
; 3296 :  * Returns the newly allocated structure or NULL in case or error
; 3297 :  */
; 3298 : xmlSchemaFacetPtr
; 3299 : xmlSchemaNewFacet(void)
; 3300 : {
; 3301 :     xmlSchemaFacetPtr ret;
; 3302 : 
; 3303 :     ret = (xmlSchemaFacetPtr) xmlMalloc(sizeof(xmlSchemaFacet));
; 3304 :     if (ret == NULL) {
; 3305 :         return (NULL);
; 3306 :     }
; 3307 :     memset(ret, 0, sizeof(xmlSchemaFacet));
; 3308 : 
; 3309 :     return (ret);
; 3310 : }
; 3311 : 
; 3312 : /**
; 3313 :  * xmlSchemaNewAnnot:
; 3314 :  * @ctxt:  a schema validation context
; 3315 :  * @node:  a node
; 3316 :  *
; 3317 :  * Allocate a new annotation structure.
; 3318 :  *
; 3319 :  * Returns the newly allocated structure or NULL in case or error
; 3320 :  */
; 3321 : static xmlSchemaAnnotPtr
; 3322 : xmlSchemaNewAnnot(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node)
; 3323 : {
; 3324 :     xmlSchemaAnnotPtr ret;
; 3325 : 
; 3326 :     ret = (xmlSchemaAnnotPtr) xmlMalloc(sizeof(xmlSchemaAnnot));
; 3327 :     if (ret == NULL) {
; 3328 :         xmlSchemaPErrMemory(ctxt, "allocating annotation", node);
; 3329 :         return (NULL);
; 3330 :     }
; 3331 :     memset(ret, 0, sizeof(xmlSchemaAnnot));
; 3332 :     ret->content = node;
; 3333 :     return (ret);
; 3334 : }
; 3335 : 
; 3336 : static xmlSchemaItemListPtr
; 3337 : xmlSchemaItemListCreate(void)
; 3338 : {
; 3339 :     xmlSchemaItemListPtr ret;
; 3340 : 
; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));
; 3342 :     if (ret == NULL) {
; 3343 : 	xmlSchemaPErrMemory(NULL,
; 3344 : 	    "allocating an item list structure", NULL);
; 3345 : 	return (NULL);
; 3346 :     }
; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));
; 3348 :     return (ret);
; 3349 : }
; 3350 : 
; 3351 : static void
; 3352 : xmlSchemaItemListClear(xmlSchemaItemListPtr list)
; 3353 : {
; 3354 :     if (list->items != NULL) {
; 3355 : 	xmlFree(list->items);
; 3356 : 	list->items = NULL;
; 3357 :     }
; 3358 :     list->nbItems = 0;
; 3359 :     list->sizeItems = 0;
; 3360 : }
; 3361 : 
; 3362 : static int
; 3363 : xmlSchemaItemListAdd(xmlSchemaItemListPtr list, void *item)
; 3364 : {
; 3365 :     if (list->items == NULL) {
; 3366 : 	list->items = (void **) xmlMalloc(
; 3367 : 	    20 * sizeof(void *));
; 3368 : 	if (list->items == NULL) {
; 3369 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3370 : 	    return(-1);
; 3371 : 	}
; 3372 : 	list->sizeItems = 20;
; 3373 :     } else if (list->sizeItems <= list->nbItems) {
; 3374 : 	list->sizeItems *= 2;
; 3375 : 	list->items = (void **) xmlRealloc(list->items,
; 3376 : 	    list->sizeItems * sizeof(void *));
; 3377 : 	if (list->items == NULL) {
; 3378 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3379 : 	    list->sizeItems = 0;
; 3380 : 	    return(-1);
; 3381 : 	}
; 3382 :     }
; 3383 :     list->items[list->nbItems++] = item;
; 3384 :     return(0);
; 3385 : }
; 3386 : 
; 3387 : static int
; 3388 : xmlSchemaItemListAddSize(xmlSchemaItemListPtr list,
; 3389 : 			 int initialSize,
; 3390 : 			 void *item)
; 3391 : {
; 3392 :     if (list->items == NULL) {
; 3393 : 	if (initialSize <= 0)
; 3394 : 	    initialSize = 1;
; 3395 : 	list->items = (void **) xmlMalloc(
; 3396 : 	    initialSize * sizeof(void *));
; 3397 : 	if (list->items == NULL) {
; 3398 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3399 : 	    return(-1);
; 3400 : 	}
; 3401 : 	list->sizeItems = initialSize;
; 3402 :     } else if (list->sizeItems <= list->nbItems) {
; 3403 : 	list->sizeItems *= 2;
; 3404 : 	list->items = (void **) xmlRealloc(list->items,
; 3405 : 	    list->sizeItems * sizeof(void *));
; 3406 : 	if (list->items == NULL) {
; 3407 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3408 : 	    list->sizeItems = 0;
; 3409 : 	    return(-1);
; 3410 : 	}
; 3411 :     }
; 3412 :     list->items[list->nbItems++] = item;
; 3413 :     return(0);
; 3414 : }
; 3415 : 
; 3416 : static int
; 3417 : xmlSchemaItemListInsert(xmlSchemaItemListPtr list, void *item, int idx)
; 3418 : {
; 3419 :     if (list->items == NULL) {
; 3420 : 	list->items = (void **) xmlMalloc(
; 3421 : 	    20 * sizeof(void *));
; 3422 : 	if (list->items == NULL) {
; 3423 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3424 : 	    return(-1);
; 3425 : 	}
; 3426 : 	list->sizeItems = 20;
; 3427 :     } else if (list->sizeItems <= list->nbItems) {
; 3428 : 	list->sizeItems *= 2;
; 3429 : 	list->items = (void **) xmlRealloc(list->items,
; 3430 : 	    list->sizeItems * sizeof(void *));
; 3431 : 	if (list->items == NULL) {
; 3432 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3433 : 	    list->sizeItems = 0;
; 3434 : 	    return(-1);
; 3435 : 	}
; 3436 :     }
; 3437 :     /*
; 3438 :     * Just append if the index is greater/equal than the item count.
; 3439 :     */
; 3440 :     if (idx >= list->nbItems) {
; 3441 : 	list->items[list->nbItems++] = item;
; 3442 :     } else {
; 3443 : 	int i;
; 3444 : 	for (i = list->nbItems; i > idx; i--)
; 3445 : 	    list->items[i] = list->items[i-1];
; 3446 : 	list->items[idx] = item;
; 3447 : 	list->nbItems++;
; 3448 :     }
; 3449 :     return(0);
; 3450 : }
; 3451 : 
; 3452 : #if 0 /* enable if ever needed */
; 3453 : static int
; 3454 : xmlSchemaItemListInsertSize(xmlSchemaItemListPtr list,
; 3455 : 			    int initialSize,
; 3456 : 			    void *item,
; 3457 : 			    int idx)
; 3458 : {
; 3459 :     if (list->items == NULL) {
; 3460 : 	if (initialSize <= 0)
; 3461 : 	    initialSize = 1;
; 3462 : 	list->items = (void **) xmlMalloc(
; 3463 : 	    initialSize * sizeof(void *));
; 3464 : 	if (list->items == NULL) {
; 3465 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3466 : 	    return(-1);
; 3467 : 	}
; 3468 : 	list->sizeItems = initialSize;
; 3469 :     } else if (list->sizeItems <= list->nbItems) {
; 3470 : 	list->sizeItems *= 2;
; 3471 : 	list->items = (void **) xmlRealloc(list->items,
; 3472 : 	    list->sizeItems * sizeof(void *));
; 3473 : 	if (list->items == NULL) {
; 3474 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3475 : 	    list->sizeItems = 0;
; 3476 : 	    return(-1);
; 3477 : 	}
; 3478 :     }
; 3479 :     /*
; 3480 :     * Just append if the index is greater/equal than the item count.
; 3481 :     */
; 3482 :     if (idx >= list->nbItems) {
; 3483 : 	list->items[list->nbItems++] = item;
; 3484 :     } else {
; 3485 : 	int i;
; 3486 : 	for (i = list->nbItems; i > idx; i--)
; 3487 : 	    list->items[i] = list->items[i-1];
; 3488 : 	list->items[idx] = item;
; 3489 : 	list->nbItems++;
; 3490 :     }
; 3491 :     return(0);
; 3492 : }
; 3493 : #endif
; 3494 : 
; 3495 : static int
; 3496 : xmlSchemaItemListRemove(xmlSchemaItemListPtr list, int idx)
; 3497 : {
; 3498 :     int i;
; 3499 :     if ((list->items == NULL) || (idx >= list->nbItems)) {
; 3500 : 	xmlSchemaPSimpleErr("Internal error: xmlSchemaItemListRemove, "
; 3501 : 	    "index error.\n");
; 3502 : 	return(-1);
; 3503 :     }
; 3504 : 
; 3505 :     if (list->nbItems == 1) {
; 3506 : 	/* TODO: Really free the list? */
; 3507 : 	xmlFree(list->items);
; 3508 : 	list->items = NULL;
; 3509 : 	list->nbItems = 0;
; 3510 : 	list->sizeItems = 0;
; 3511 :     } else if (list->nbItems -1 == idx) {
; 3512 : 	list->nbItems--;
; 3513 :     } else {
; 3514 : 	for (i = idx; i < list->nbItems -1; i++)
; 3515 : 	    list->items[i] = list->items[i+1];
; 3516 : 	list->nbItems--;
; 3517 :     }
; 3518 :     return(0);
; 3519 : }
; 3520 : 
; 3521 : /**
; 3522 :  * xmlSchemaItemListFree:
; 3523 :  * @annot:  a schema type structure
; 3524 :  *
; 3525 :  * Deallocate a annotation structure
; 3526 :  */
; 3527 : static void
; 3528 : xmlSchemaItemListFree(xmlSchemaItemListPtr list)
; 3529 : {
; 3530 :     if (list == NULL)
; 3531 : 	return;
; 3532 :     if (list->items != NULL)
; 3533 : 	xmlFree(list->items);
; 3534 :     xmlFree(list);
; 3535 : }
; 3536 : 
; 3537 : static void
; 3538 : xmlSchemaBucketFree(xmlSchemaBucketPtr bucket)
; 3539 : {
; 3540 :     if (bucket == NULL)
; 3541 : 	return;
; 3542 :     if (bucket->globals != NULL) {
; 3543 : 	xmlSchemaComponentListFree(bucket->globals);
; 3544 : 	xmlSchemaItemListFree(bucket->globals);
; 3545 :     }
; 3546 :     if (bucket->locals != NULL) {
; 3547 : 	xmlSchemaComponentListFree(bucket->locals);
; 3548 : 	xmlSchemaItemListFree(bucket->locals);
; 3549 :     }
; 3550 :     if (bucket->relations != NULL) {
; 3551 : 	xmlSchemaSchemaRelationPtr prev, cur = bucket->relations;
; 3552 : 	do {
; 3553 : 	    prev = cur;
; 3554 : 	    cur = cur->next;
; 3555 : 	    xmlFree(prev);
; 3556 : 	} while (cur != NULL);
; 3557 :     }
; 3558 :     if ((! bucket->preserveDoc) && (bucket->doc != NULL)) {
; 3559 : 	xmlFreeDoc(bucket->doc);
; 3560 :     }
; 3561 :     if (bucket->type == XML_SCHEMA_SCHEMA_IMPORT) {
; 3562 : 	if (WXS_IMPBUCKET(bucket)->schema != NULL)
; 3563 : 	    xmlSchemaFree(WXS_IMPBUCKET(bucket)->schema);
; 3564 :     }
; 3565 :     xmlFree(bucket);
; 3566 : }
; 3567 : 
; 3568 : static void
; 3569 : xmlSchemaBucketFreeEntry(void *bucket, const xmlChar *name ATTRIBUTE_UNUSED)
; 3570 : {
; 3571 :     xmlSchemaBucketFree((xmlSchemaBucketPtr) bucket);
; 3572 : }
; 3573 : 
; 3574 : static xmlSchemaBucketPtr
; 3575 : xmlSchemaBucketCreate(xmlSchemaParserCtxtPtr pctxt,
; 3576 : 			 int type, const xmlChar *targetNamespace)
; 3577 : {
; 3578 :     xmlSchemaBucketPtr ret;
; 3579 :     int size;
; 3580 :     xmlSchemaPtr mainSchema;
; 3581 : 
; 3582 :     if (WXS_CONSTRUCTOR(pctxt)->mainSchema == NULL) {
; 3583 : 	PERROR_INT("xmlSchemaBucketCreate",
; 3584 : 	    "no main schema on constructor");
; 3585 : 	return(NULL);
; 3586 :     }
; 3587 :     mainSchema = WXS_CONSTRUCTOR(pctxt)->mainSchema;
; 3588 :     /* Create the schema bucket. */
; 3589 :     if (WXS_IS_BUCKET_INCREDEF(type))
; 3590 : 	size = sizeof(xmlSchemaInclude);
; 3591 :     else
; 3592 : 	size = sizeof(xmlSchemaImport);
; 3593 :     ret = (xmlSchemaBucketPtr) xmlMalloc(size);
; 3594 :     if (ret == NULL) {
; 3595 : 	xmlSchemaPErrMemory(NULL, "allocating schema bucket", NULL);
; 3596 : 	return(NULL);
; 3597 :     }
; 3598 :     memset(ret, 0, size);
; 3599 :     ret->targetNamespace = targetNamespace;
; 3600 :     ret->type = type;
; 3601 :     ret->globals = xmlSchemaItemListCreate();
; 3602 :     if (ret->globals == NULL) {
; 3603 : 	xmlFree(ret);
; 3604 : 	return(NULL);
; 3605 :     }
; 3606 :     ret->locals = xmlSchemaItemListCreate();
; 3607 :     if (ret->locals == NULL) {
; 3608 : 	xmlFree(ret);
; 3609 : 	return(NULL);
; 3610 :     }
; 3611 :     /*
; 3612 :     * The following will assure that only the first bucket is marked as
; 3613 :     * XML_SCHEMA_SCHEMA_MAIN and it points to the *main* schema.
; 3614 :     * For each following import buckets an xmlSchema will be created.
; 3615 :     * An xmlSchema will be created for every distinct targetNamespace.
; 3616 :     * We assign the targetNamespace to the schemata here.
; 3617 :     */
; 3618 :     if (! WXS_HAS_BUCKETS(pctxt)) {
; 3619 : 	if (WXS_IS_BUCKET_INCREDEF(type)) {
; 3620 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3621 : 		"first bucket but it's an include or redefine");
; 3622 : 	    xmlSchemaBucketFree(ret);
; 3623 : 	    return(NULL);
; 3624 : 	}
; 3625 : 	/* Force the type to be XML_SCHEMA_SCHEMA_MAIN. */
; 3626 : 	ret->type = XML_SCHEMA_SCHEMA_MAIN;
; 3627 : 	/* Point to the *main* schema. */
; 3628 : 	WXS_CONSTRUCTOR(pctxt)->mainBucket = ret;
; 3629 : 	WXS_IMPBUCKET(ret)->schema = mainSchema;
; 3630 : 	/*
; 3631 : 	* Ensure that the main schema gets a targetNamespace.
; 3632 : 	*/
; 3633 : 	mainSchema->targetNamespace = targetNamespace;
; 3634 :     } else {
; 3635 : 	if (type == XML_SCHEMA_SCHEMA_MAIN) {
; 3636 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3637 : 		"main bucket but it's not the first one");
; 3638 : 	    xmlSchemaBucketFree(ret);
; 3639 : 	    return(NULL);
; 3640 : 	} else if (type == XML_SCHEMA_SCHEMA_IMPORT) {
; 3641 : 	    /*
; 3642 : 	    * Create a schema for imports and assign the
; 3643 : 	    * targetNamespace.
; 3644 : 	    */
; 3645 : 	    WXS_IMPBUCKET(ret)->schema = xmlSchemaNewSchema(pctxt);
; 3646 : 	    if (WXS_IMPBUCKET(ret)->schema == NULL) {
; 3647 : 		xmlSchemaBucketFree(ret);
; 3648 : 		return(NULL);
; 3649 : 	    }
; 3650 : 	    WXS_IMPBUCKET(ret)->schema->targetNamespace = targetNamespace;
; 3651 : 	}
; 3652 :     }
; 3653 :     if (WXS_IS_BUCKET_IMPMAIN(type)) {
; 3654 : 	int res;
; 3655 : 	/*
; 3656 : 	* Imports go into the "schemasImports" slot of the main *schema*.
; 3657 : 	* Note that we create an import entry for the main schema as well; i.e.,
; 3658 : 	* even if there's only one schema, we'll get an import.
; 3659 : 	*/
; 3660 : 	if (mainSchema->schemasImports == NULL) {
; 3661 : 	    mainSchema->schemasImports = xmlHashCreateDict(5,
; 3662 : 		WXS_CONSTRUCTOR(pctxt)->dict);
; 3663 : 	    if (mainSchema->schemasImports == NULL) {
; 3664 : 		xmlSchemaBucketFree(ret);
; 3665 : 		return(NULL);
; 3666 : 	    }
; 3667 : 	}
; 3668 : 	if (targetNamespace == NULL)
; 3669 : 	    res = xmlHashAddEntry(mainSchema->schemasImports,
; 3670 : 		XML_SCHEMAS_NO_NAMESPACE, ret);
; 3671 : 	else
; 3672 : 	    res = xmlHashAddEntry(mainSchema->schemasImports,
; 3673 : 		targetNamespace, ret);
; 3674 : 	if (res != 0) {
; 3675 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3676 : 		"failed to add the schema bucket to the hash");
; 3677 : 	    xmlSchemaBucketFree(ret);
; 3678 : 	    return(NULL);
; 3679 : 	}
; 3680 :     } else {
; 3681 : 	/* Set the @ownerImport of an include bucket. */
; 3682 : 	if (WXS_IS_BUCKET_IMPMAIN(WXS_CONSTRUCTOR(pctxt)->bucket->type))
; 3683 : 	    WXS_INCBUCKET(ret)->ownerImport =
; 3684 : 		WXS_IMPBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket);
; 3685 : 	else
; 3686 : 	    WXS_INCBUCKET(ret)->ownerImport =
; 3687 : 		WXS_INCBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket)->ownerImport;
; 3688 : 
; 3689 : 	/* Includes got into the "includes" slot of the *main* schema. */
; 3690 : 	if (mainSchema->includes == NULL) {
; 3691 : 	    mainSchema->includes = xmlSchemaItemListCreate();
; 3692 : 	    if (mainSchema->includes == NULL) {
; 3693 : 		xmlSchemaBucketFree(ret);
; 3694 : 		return(NULL);
; 3695 : 	    }
; 3696 : 	}
; 3697 : 	xmlSchemaItemListAdd(mainSchema->includes, ret);
; 3698 :     }
; 3699 :     /*
; 3700 :     * Add to list of all buckets; this is used for lookup
; 3701 :     * during schema construction time only.
; 3702 :     */
; 3703 :     if (xmlSchemaItemListAdd(WXS_CONSTRUCTOR(pctxt)->buckets, ret) == -1)
; 3704 : 	return(NULL);
; 3705 :     return(ret);
; 3706 : }
; 3707 : 
; 3708 : static int
; 3709 : xmlSchemaAddItemSize(xmlSchemaItemListPtr *list, int initialSize, void *item)
; 3710 : {
; 3711 :     if (*list == NULL) {
; 3712 : 	*list = xmlSchemaItemListCreate();
; 3713 : 	if (*list == NULL)
; 3714 : 	    return(-1);
; 3715 :     }
; 3716 :     xmlSchemaItemListAddSize(*list, initialSize, item);
; 3717 :     return(0);
; 3718 : }
; 3719 : 
; 3720 : /**
; 3721 :  * xmlSchemaFreeAnnot:
; 3722 :  * @annot:  a schema type structure
; 3723 :  *
; 3724 :  * Deallocate a annotation structure
; 3725 :  */
; 3726 : static void
; 3727 : xmlSchemaFreeAnnot(xmlSchemaAnnotPtr annot)
; 3728 : {
; 3729 :     if (annot == NULL)
; 3730 :         return;
; 3731 :     if (annot->next == NULL) {
; 3732 : 	xmlFree(annot);
; 3733 :     } else {
; 3734 : 	xmlSchemaAnnotPtr prev;
; 3735 : 
; 3736 : 	do {
; 3737 : 	    prev = annot;
; 3738 : 	    annot = annot->next;
; 3739 : 	    xmlFree(prev);
; 3740 : 	} while (annot != NULL);
; 3741 :     }
; 3742 : }
; 3743 : 
; 3744 : /**
; 3745 :  * xmlSchemaFreeNotation:
; 3746 :  * @schema:  a schema notation structure
; 3747 :  *
; 3748 :  * Deallocate a Schema Notation structure.
; 3749 :  */
; 3750 : static void
; 3751 : xmlSchemaFreeNotation(xmlSchemaNotationPtr nota)
; 3752 : {
; 3753 :     if (nota == NULL)
; 3754 :         return;
; 3755 :     xmlFree(nota);
; 3756 : }
; 3757 : 
; 3758 : /**
; 3759 :  * xmlSchemaFreeAttribute:
; 3760 :  * @attr:  an attribute declaration
; 3761 :  *
; 3762 :  * Deallocates an attribute declaration structure.
; 3763 :  */
; 3764 : static void
; 3765 : xmlSchemaFreeAttribute(xmlSchemaAttributePtr attr)
; 3766 : {
; 3767 :     if (attr == NULL)
; 3768 :         return;
; 3769 :     if (attr->annot != NULL)
; 3770 : 	xmlSchemaFreeAnnot(attr->annot);
; 3771 :     if (attr->defVal != NULL)
; 3772 : 	xmlSchemaFreeValue(attr->defVal);
; 3773 :     xmlFree(attr);
; 3774 : }
; 3775 : 
; 3776 : /**
; 3777 :  * xmlSchemaFreeAttributeUse:
; 3778 :  * @use:  an attribute use
; 3779 :  *
; 3780 :  * Deallocates an attribute use structure.
; 3781 :  */
; 3782 : static void
; 3783 : xmlSchemaFreeAttributeUse(xmlSchemaAttributeUsePtr use)
; 3784 : {
; 3785 :     if (use == NULL)
; 3786 :         return;
; 3787 :     if (use->annot != NULL)
; 3788 : 	xmlSchemaFreeAnnot(use->annot);
; 3789 :     if (use->defVal != NULL)
; 3790 : 	xmlSchemaFreeValue(use->defVal);
; 3791 :     xmlFree(use);
; 3792 : }
; 3793 : 
; 3794 : /**
; 3795 :  * xmlSchemaFreeAttributeUseProhib:
; 3796 :  * @prohib:  an attribute use prohibition
; 3797 :  *
; 3798 :  * Deallocates an attribute use structure.
; 3799 :  */
; 3800 : static void
; 3801 : xmlSchemaFreeAttributeUseProhib(xmlSchemaAttributeUseProhibPtr prohib)
; 3802 : {
; 3803 :     if (prohib == NULL)
; 3804 :         return;
; 3805 :     xmlFree(prohib);
; 3806 : }
; 3807 : 
; 3808 : /**
; 3809 :  * xmlSchemaFreeWildcardNsSet:
; 3810 :  * set:  a schema wildcard namespace
; 3811 :  *
; 3812 :  * Deallocates a list of wildcard constraint structures.
; 3813 :  */
; 3814 : static void
; 3815 : xmlSchemaFreeWildcardNsSet(xmlSchemaWildcardNsPtr set)
; 3816 : {
; 3817 :     xmlSchemaWildcardNsPtr next;
; 3818 : 
; 3819 :     while (set != NULL) {
; 3820 : 	next = set->next;
; 3821 : 	xmlFree(set);
; 3822 : 	set = next;
; 3823 :     }
; 3824 : }
; 3825 : 
; 3826 : /**
; 3827 :  * xmlSchemaFreeWildcard:
; 3828 :  * @wildcard:  a wildcard structure
; 3829 :  *
; 3830 :  * Deallocates a wildcard structure.
; 3831 :  */
; 3832 : void
; 3833 : xmlSchemaFreeWildcard(xmlSchemaWildcardPtr wildcard)
; 3834 : {
; 3835 :     if (wildcard == NULL)
; 3836 :         return;
; 3837 :     if (wildcard->annot != NULL)
; 3838 :         xmlSchemaFreeAnnot(wildcard->annot);
; 3839 :     if (wildcard->nsSet != NULL)
; 3840 : 	xmlSchemaFreeWildcardNsSet(wildcard->nsSet);
; 3841 :     if (wildcard->negNsSet != NULL)
; 3842 : 	xmlFree(wildcard->negNsSet);
; 3843 :     xmlFree(wildcard);
; 3844 : }
; 3845 : 
; 3846 : /**
; 3847 :  * xmlSchemaFreeAttributeGroup:
; 3848 :  * @schema:  a schema attribute group structure
; 3849 :  *
; 3850 :  * Deallocate a Schema Attribute Group structure.
; 3851 :  */
; 3852 : static void
; 3853 : xmlSchemaFreeAttributeGroup(xmlSchemaAttributeGroupPtr attrGr)
; 3854 : {
; 3855 :     if (attrGr == NULL)
; 3856 :         return;
; 3857 :     if (attrGr->annot != NULL)
; 3858 :         xmlSchemaFreeAnnot(attrGr->annot);
; 3859 :     if (attrGr->attrUses != NULL)
; 3860 : 	xmlSchemaItemListFree(WXS_LIST_CAST attrGr->attrUses);
; 3861 :     xmlFree(attrGr);
; 3862 : }
; 3863 : 
; 3864 : /**
; 3865 :  * xmlSchemaFreeQNameRef:
; 3866 :  * @item: a QName reference structure
; 3867 :  *
; 3868 :  * Deallocatea a QName reference structure.
; 3869 :  */
; 3870 : static void
; 3871 : xmlSchemaFreeQNameRef(xmlSchemaQNameRefPtr item)
; 3872 : {
; 3873 :     xmlFree(item);
; 3874 : }
; 3875 : 
; 3876 : /**
; 3877 :  * xmlSchemaFreeTypeLinkList:
; 3878 :  * @alink: a type link
; 3879 :  *
; 3880 :  * Deallocate a list of types.
; 3881 :  */
; 3882 : static void
; 3883 : xmlSchemaFreeTypeLinkList(xmlSchemaTypeLinkPtr link)
; 3884 : {
; 3885 :     xmlSchemaTypeLinkPtr next;
; 3886 : 
; 3887 :     while (link != NULL) {
; 3888 : 	next = link->next;
; 3889 : 	xmlFree(link);
; 3890 : 	link = next;
; 3891 :     }
; 3892 : }
; 3893 : 
; 3894 : static void
; 3895 : xmlSchemaFreeIDCStateObjList(xmlSchemaIDCStateObjPtr sto)
; 3896 : {
; 3897 :     xmlSchemaIDCStateObjPtr next;
; 3898 :     while (sto != NULL) {
; 3899 : 	next = sto->next;
; 3900 : 	if (sto->history != NULL)
; 3901 : 	    xmlFree(sto->history);
; 3902 : 	if (sto->xpathCtxt != NULL)
; 3903 : 	    xmlFreeStreamCtxt((xmlStreamCtxtPtr) sto->xpathCtxt);
; 3904 : 	xmlFree(sto);
; 3905 : 	sto = next;
; 3906 :     }
; 3907 : }
; 3908 : 
; 3909 : /**
; 3910 :  * xmlSchemaFreeIDC:
; 3911 :  * @idc: a identity-constraint definition
; 3912 :  *
; 3913 :  * Deallocates an identity-constraint definition.
; 3914 :  */
; 3915 : static void
; 3916 : xmlSchemaFreeIDC(xmlSchemaIDCPtr idcDef)
; 3917 : {
; 3918 :     xmlSchemaIDCSelectPtr cur, prev;
; 3919 : 
; 3920 :     if (idcDef == NULL)
; 3921 : 	return;
; 3922 :     if (idcDef->annot != NULL)
; 3923 :         xmlSchemaFreeAnnot(idcDef->annot);
; 3924 :     /* Selector */
; 3925 :     if (idcDef->selector != NULL) {
; 3926 : 	if (idcDef->selector->xpathComp != NULL)
; 3927 : 	    xmlFreePattern((xmlPatternPtr) idcDef->selector->xpathComp);
; 3928 : 	xmlFree(idcDef->selector);
; 3929 :     }
; 3930 :     /* Fields */
; 3931 :     if (idcDef->fields != NULL) {
; 3932 : 	cur = idcDef->fields;
; 3933 : 	do {
; 3934 : 	    prev = cur;
; 3935 : 	    cur = cur->next;
; 3936 : 	    if (prev->xpathComp != NULL)
; 3937 : 		xmlFreePattern((xmlPatternPtr) prev->xpathComp);
; 3938 : 	    xmlFree(prev);
; 3939 : 	} while (cur != NULL);
; 3940 :     }
; 3941 :     xmlFree(idcDef);
; 3942 : }
; 3943 : 
; 3944 : /**
; 3945 :  * xmlSchemaFreeElement:
; 3946 :  * @schema:  a schema element structure
; 3947 :  *
; 3948 :  * Deallocate a Schema Element structure.
; 3949 :  */
; 3950 : static void
; 3951 : xmlSchemaFreeElement(xmlSchemaElementPtr elem)
; 3952 : {
; 3953 :     if (elem == NULL)
; 3954 :         return;
; 3955 :     if (elem->annot != NULL)
; 3956 :         xmlSchemaFreeAnnot(elem->annot);
; 3957 :     if (elem->contModel != NULL)
; 3958 :         xmlRegFreeRegexp(elem->contModel);
; 3959 :     if (elem->defVal != NULL)
; 3960 : 	xmlSchemaFreeValue(elem->defVal);
; 3961 :     xmlFree(elem);
; 3962 : }
; 3963 : 
; 3964 : /**
; 3965 :  * xmlSchemaFreeFacet:
; 3966 :  * @facet:  a schema facet structure
; 3967 :  *
; 3968 :  * Deallocate a Schema Facet structure.
; 3969 :  */
; 3970 : void
; 3971 : xmlSchemaFreeFacet(xmlSchemaFacetPtr facet)
; 3972 : {
; 3973 :     if (facet == NULL)
; 3974 :         return;
; 3975 :     if (facet->val != NULL)
; 3976 :         xmlSchemaFreeValue(facet->val);
; 3977 :     if (facet->regexp != NULL)
; 3978 :         xmlRegFreeRegexp(facet->regexp);
; 3979 :     if (facet->annot != NULL)
; 3980 :         xmlSchemaFreeAnnot(facet->annot);
; 3981 :     xmlFree(facet);
; 3982 : }
; 3983 : 
; 3984 : /**
; 3985 :  * xmlSchemaFreeType:
; 3986 :  * @type:  a schema type structure
; 3987 :  *
; 3988 :  * Deallocate a Schema Type structure.
; 3989 :  */
; 3990 : void
; 3991 : xmlSchemaFreeType(xmlSchemaTypePtr type)
; 3992 : {
; 3993 :     if (type == NULL)
; 3994 :         return;
; 3995 :     if (type->annot != NULL)
; 3996 :         xmlSchemaFreeAnnot(type->annot);
; 3997 :     if (type->facets != NULL) {
; 3998 :         xmlSchemaFacetPtr facet, next;
; 3999 : 
; 4000 :         facet = type->facets;
; 4001 :         while (facet != NULL) {
; 4002 :             next = facet->next;
; 4003 :             xmlSchemaFreeFacet(facet);
; 4004 :             facet = next;
; 4005 :         }
; 4006 :     }
; 4007 :     if (type->attrUses != NULL)
; 4008 : 	xmlSchemaItemListFree((xmlSchemaItemListPtr) type->attrUses);
; 4009 :     if (type->memberTypes != NULL)
; 4010 : 	xmlSchemaFreeTypeLinkList(type->memberTypes);
; 4011 :     if (type->facetSet != NULL) {
; 4012 : 	xmlSchemaFacetLinkPtr next, link;
; 4013 : 
; 4014 : 	link = type->facetSet;
; 4015 : 	do {
; 4016 : 	    next = link->next;
; 4017 : 	    xmlFree(link);
; 4018 : 	    link = next;
; 4019 : 	} while (link != NULL);
; 4020 :     }
; 4021 :     if (type->contModel != NULL)
; 4022 :         xmlRegFreeRegexp(type->contModel);
; 4023 :     xmlFree(type);
; 4024 : }
; 4025 : 
; 4026 : /**
; 4027 :  * xmlSchemaFreeModelGroupDef:
; 4028 :  * @item:  a schema model group definition
; 4029 :  *
; 4030 :  * Deallocates a schema model group definition.
; 4031 :  */
; 4032 : static void
; 4033 : xmlSchemaFreeModelGroupDef(xmlSchemaModelGroupDefPtr item)
; 4034 : {
; 4035 :     if (item->annot != NULL)
; 4036 : 	xmlSchemaFreeAnnot(item->annot);
; 4037 :     xmlFree(item);
; 4038 : }
; 4039 : 
; 4040 : /**
; 4041 :  * xmlSchemaFreeModelGroup:
; 4042 :  * @item:  a schema model group
; 4043 :  *
; 4044 :  * Deallocates a schema model group structure.
; 4045 :  */
; 4046 : static void
; 4047 : xmlSchemaFreeModelGroup(xmlSchemaModelGroupPtr item)
; 4048 : {
; 4049 :     if (item->annot != NULL)
; 4050 : 	xmlSchemaFreeAnnot(item->annot);
; 4051 :     xmlFree(item);
; 4052 : }
; 4053 : 
; 4054 : static void
; 4055 : xmlSchemaComponentListFree(xmlSchemaItemListPtr list)
; 4056 : {
; 4057 :     if ((list == NULL) || (list->nbItems == 0))
; 4058 : 	return;
; 4059 :     {
; 4060 : 	xmlSchemaTreeItemPtr item;
; 4061 : 	xmlSchemaTreeItemPtr *items = (xmlSchemaTreeItemPtr *) list->items;
; 4062 : 	int i;
; 4063 : 
; 4064 : 	for (i = 0; i < list->nbItems; i++) {
; 4065 : 	    item = items[i];
; 4066 : 	    if (item == NULL)
; 4067 : 		continue;
; 4068 : 	    switch (item->type) {
; 4069 : 		case XML_SCHEMA_TYPE_SIMPLE:
; 4070 : 		case XML_SCHEMA_TYPE_COMPLEX:
; 4071 : 		    xmlSchemaFreeType((xmlSchemaTypePtr) item);
; 4072 : 		    break;
; 4073 : 		case XML_SCHEMA_TYPE_ATTRIBUTE:
; 4074 : 		    xmlSchemaFreeAttribute((xmlSchemaAttributePtr) item);
; 4075 : 		    break;
; 4076 : 		case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
; 4077 : 		    xmlSchemaFreeAttributeUse((xmlSchemaAttributeUsePtr) item);
; 4078 : 		    break;
; 4079 : 		case XML_SCHEMA_EXTRA_ATTR_USE_PROHIB:
; 4080 : 		    xmlSchemaFreeAttributeUseProhib(
; 4081 : 			(xmlSchemaAttributeUseProhibPtr) item);
; 4082 : 		    break;
; 4083 : 		case XML_SCHEMA_TYPE_ELEMENT:
; 4084 : 		    xmlSchemaFreeElement((xmlSchemaElementPtr) item);
; 4085 : 		    break;
; 4086 : 		case XML_SCHEMA_TYPE_PARTICLE:
; 4087 : 		    if (item->annot != NULL)
; 4088 : 			xmlSchemaFreeAnnot(item->annot);
; 4089 : 		    xmlFree(item);
; 4090 : 		    break;
; 4091 : 		case XML_SCHEMA_TYPE_SEQUENCE:
; 4092 : 		case XML_SCHEMA_TYPE_CHOICE:
; 4093 : 		case XML_SCHEMA_TYPE_ALL:
; 4094 : 		    xmlSchemaFreeModelGroup((xmlSchemaModelGroupPtr) item);
; 4095 : 		    break;
; 4096 : 		case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 4097 : 		    xmlSchemaFreeAttributeGroup(
; 4098 : 			(xmlSchemaAttributeGroupPtr) item);
; 4099 : 		    break;
; 4100 : 		case XML_SCHEMA_TYPE_GROUP:
; 4101 : 		    xmlSchemaFreeModelGroupDef(
; 4102 : 			(xmlSchemaModelGroupDefPtr) item);
; 4103 : 		    break;
; 4104 : 		case XML_SCHEMA_TYPE_ANY:
; 4105 : 		case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:
; 4106 : 		    xmlSchemaFreeWildcard((xmlSchemaWildcardPtr) item);
; 4107 : 		    break;
; 4108 : 		case XML_SCHEMA_TYPE_IDC_KEY:
; 4109 : 		case XML_SCHEMA_TYPE_IDC_UNIQUE:
; 4110 : 		case XML_SCHEMA_TYPE_IDC_KEYREF:
; 4111 : 		    xmlSchemaFreeIDC((xmlSchemaIDCPtr) item);
; 4112 : 		    break;
; 4113 : 		case XML_SCHEMA_TYPE_NOTATION:
; 4114 : 		    xmlSchemaFreeNotation((xmlSchemaNotationPtr) item);
; 4115 : 		    break;
; 4116 : 		case XML_SCHEMA_EXTRA_QNAMEREF:
; 4117 : 		    xmlSchemaFreeQNameRef((xmlSchemaQNameRefPtr) item);
; 4118 : 		    break;
; 4119 : 		default: {
; 4120 : 		    /* TODO: This should never be hit. */
; 4121 : 		    xmlSchemaPSimpleInternalErr(NULL,
; 4122 : 			"Internal error: xmlSchemaComponentListFree, "
; 4123 : 			"unexpected component type '%s'\n",
; 4124 : 			(const xmlChar *) WXS_ITEM_TYPE_NAME(item));
; 4125 : 			 }
; 4126 : 		    break;
; 4127 : 	    }
; 4128 : 	}
; 4129 : 	list->nbItems = 0;
; 4130 :     }
; 4131 : }
; 4132 : 
; 4133 : /**
; 4134 :  * xmlSchemaFree:
; 4135 :  * @schema:  a schema structure
; 4136 :  *
; 4137 :  * Deallocate a Schema structure.
; 4138 :  */
; 4139 : void
; 4140 : xmlSchemaFree(xmlSchemaPtr schema)
; 4141 : {
; 4142 :     if (schema == NULL)
; 4143 :         return;
; 4144 :     /* @volatiles is not used anymore :-/ */
; 4145 :     if (schema->volatiles != NULL)
; 4146 : 	TODO
; 4147 :     /*
; 4148 :     * Note that those slots are not responsible for freeing
; 4149 :     * schema components anymore; this will now be done by
; 4150 :     * the schema buckets.
; 4151 :     */
; 4152 :     if (schema->notaDecl != NULL)
; 4153 :         xmlHashFree(schema->notaDecl, NULL);
; 4154 :     if (schema->attrDecl != NULL)
; 4155 :         xmlHashFree(schema->attrDecl, NULL);
; 4156 :     if (schema->attrgrpDecl != NULL)
; 4157 :         xmlHashFree(schema->attrgrpDecl, NULL);
; 4158 :     if (schema->elemDecl != NULL)
; 4159 :         xmlHashFree(schema->elemDecl, NULL);
; 4160 :     if (schema->typeDecl != NULL)
; 4161 :         xmlHashFree(schema->typeDecl, NULL);
; 4162 :     if (schema->groupDecl != NULL)
; 4163 :         xmlHashFree(schema->groupDecl, NULL);
; 4164 :     if (schema->idcDef != NULL)
; 4165 :         xmlHashFree(schema->idcDef, NULL);
; 4166 : 
; 4167 :     if (schema->schemasImports != NULL)
; 4168 : 	xmlHashFree(schema->schemasImports, xmlSchemaBucketFreeEntry);
; 4169 :     if (schema->includes != NULL) {
; 4170 : 	xmlSchemaItemListPtr list = (xmlSchemaItemListPtr) schema->includes;
; 4171 : 	int i;
; 4172 : 	for (i = 0; i < list->nbItems; i++) {
; 4173 : 	    xmlSchemaBucketFree((xmlSchemaBucketPtr) list->items[i]);
; 4174 : 	}
; 4175 : 	xmlSchemaItemListFree(list);
; 4176 :     }
; 4177 :     if (schema->annot != NULL)
; 4178 :         xmlSchemaFreeAnnot(schema->annot);
; 4179 :     /* Never free the doc here, since this will be done by the buckets. */
; 4180 : 
; 4181 :     xmlDictFree(schema->dict);
; 4182 :     xmlFree(schema);
; 4183 : }
; 4184 : 
; 4185 : /************************************************************************
; 4186 :  *									*
; 4187 :  *			Debug functions					*
; 4188 :  *									*
; 4189 :  ************************************************************************/
; 4190 : 
; 4191 : #ifdef LIBXML_OUTPUT_ENABLED
; 4192 : 
; 4193 : static void
; 4194 : xmlSchemaTypeDump(xmlSchemaTypePtr type, FILE * output); /* forward */
; 4195 : 
; 4196 : /**
; 4197 :  * xmlSchemaElementDump:
; 4198 :  * @elem:  an element
; 4199 :  * @output:  the file output
; 4200 :  *
; 4201 :  * Dump the element
; 4202 :  */
; 4203 : static void
; 4204 : xmlSchemaElementDump(void *payload, void *data,
; 4205 :                      const xmlChar * name ATTRIBUTE_UNUSED,
; 4206 : 		     const xmlChar * namespace ATTRIBUTE_UNUSED,
; 4207 :                      const xmlChar * context ATTRIBUTE_UNUSED)
; 4208 : {
; 4209 :     xmlSchemaElementPtr elem = (xmlSchemaElementPtr) payload;
; 4210 :     FILE *output = (FILE *) data;
; 4211 :     if (elem == NULL)
; 4212 :         return;
; 4213 : 
; 4214 : 
; 4215 :     fprintf(output, "Element");
; 4216 :     if (elem->flags & XML_SCHEMAS_ELEM_GLOBAL)
; 4217 : 	fprintf(output, " (global)");
; 4218 :     fprintf(output, ": '%s' ", elem->name);
; 4219 :     if (namespace != NULL)
; 4220 : 	fprintf(output, "ns '%s'", namespace);
; 4221 :     fprintf(output, "\n");
; 4222 : #if 0
; 4223 :     if ((elem->minOccurs != 1) || (elem->maxOccurs != 1)) {
; 4224 : 	fprintf(output, "  min %d ", elem->minOccurs);
; 4225 :         if (elem->maxOccurs >= UNBOUNDED)
; 4226 :             fprintf(output, "max: unbounded\n");
; 4227 :         else if (elem->maxOccurs != 1)
; 4228 :             fprintf(output, "max: %d\n", elem->maxOccurs);
; 4229 :         else
; 4230 :             fprintf(output, "\n");
; 4231 :     }
; 4232 : #endif
; 4233 :     /*
; 4234 :     * Misc other properties.
; 4235 :     */
; 4236 :     if ((elem->flags & XML_SCHEMAS_ELEM_NILLABLE) ||
; 4237 : 	(elem->flags & XML_SCHEMAS_ELEM_ABSTRACT) ||
; 4238 : 	(elem->flags & XML_SCHEMAS_ELEM_FIXED) ||
; 4239 : 	(elem->flags & XML_SCHEMAS_ELEM_DEFAULT)) {
; 4240 : 	fprintf(output, "  props: ");
; 4241 : 	if (elem->flags & XML_SCHEMAS_ELEM_FIXED)
; 4242 : 	    fprintf(output, "[fixed] ");
; 4243 : 	if (elem->flags & XML_SCHEMAS_ELEM_DEFAULT)
; 4244 : 	    fprintf(output, "[default] ");
; 4245 : 	if (elem->flags & XML_SCHEMAS_ELEM_ABSTRACT)
; 4246 : 	    fprintf(output, "[abstract] ");
; 4247 : 	if (elem->flags & XML_SCHEMAS_ELEM_NILLABLE)
; 4248 : 	    fprintf(output, "[nillable] ");
; 4249 : 	fprintf(output, "\n");
; 4250 :     }
; 4251 :     /*
; 4252 :     * Default/fixed value.
; 4253 :     */
; 4254 :     if (elem->value != NULL)
; 4255 : 	fprintf(output, "  value: '%s'\n", elem->value);
; 4256 :     /*
; 4257 :     * Type.
; 4258 :     */
; 4259 :     if (elem->namedType != NULL) {
; 4260 : 	fprintf(output, "  type: '%s' ", elem->namedType);
; 4261 : 	if (elem->namedTypeNs != NULL)
; 4262 : 	    fprintf(output, "ns '%s'\n", elem->namedTypeNs);
; 4263 : 	else
; 4264 : 	    fprintf(output, "\n");
; 4265 :     } else if (elem->subtypes != NULL) {
; 4266 : 	/*
; 4267 : 	* Dump local types.
; 4268 : 	*/
; 4269 : 	xmlSchemaTypeDump(elem->subtypes, output);
; 4270 :     }
; 4271 :     /*
; 4272 :     * Substitution group.
; 4273 :     */
; 4274 :     if (elem->substGroup != NULL) {
; 4275 : 	fprintf(output, "  substitutionGroup: '%s' ", elem->substGroup);
; 4276 : 	if (elem->substGroupNs != NULL)
; 4277 : 	    fprintf(output, "ns '%s'\n", elem->substGroupNs);
; 4278 : 	else
; 4279 : 	    fprintf(output, "\n");
; 4280 :     }
; 4281 : }
; 4282 : 
; 4283 : /**
; 4284 :  * xmlSchemaAnnotDump:
; 4285 :  * @output:  the file output
; 4286 :  * @annot:  a annotation
; 4287 :  *
; 4288 :  * Dump the annotation
; 4289 :  */
; 4290 : static void
; 4291 : xmlSchemaAnnotDump(FILE * output, xmlSchemaAnnotPtr annot)
; 4292 : {
; 4293 :     xmlChar *content;
; 4294 : 
; 4295 :     if (annot == NULL)
; 4296 :         return;
; 4297 : 
; 4298 :     content = xmlNodeGetContent(annot->content);
; 4299 :     if (content != NULL) {
; 4300 :         fprintf(output, "  Annot: %s\n", content);
; 4301 :         xmlFree(content);
; 4302 :     } else
; 4303 :         fprintf(output, "  Annot: empty\n");
; 4304 : }
; 4305 : 
; 4306 : /**
; 4307 :  * xmlSchemaContentModelDump:
; 4308 :  * @particle: the schema particle
; 4309 :  * @output: the file output
; 4310 :  * @depth: the depth used for intentation
; 4311 :  *
; 4312 :  * Dump a SchemaType structure
; 4313 :  */
; 4314 : static void
; 4315 : xmlSchemaContentModelDump(xmlSchemaParticlePtr particle, FILE * output, int depth)
; 4316 : {
; 4317 :     xmlChar *str = NULL;
; 4318 :     xmlSchemaTreeItemPtr term;
; 4319 :     char shift[100];
; 4320 :     int i;
; 4321 : 
; 4322 :     if (particle == NULL)
; 4323 : 	return;
; 4324 :     for (i = 0;((i < depth) && (i < 25));i++)
; 4325 :         shift[2 * i] = shift[2 * i + 1] = ' ';
; 4326 :     shift[2 * i] = shift[2 * i + 1] = 0;
; 4327 :     fprintf(output, "%s", shift);
; 4328 :     if (particle->children == NULL) {
; 4329 : 	fprintf(output, "MISSING particle term\n");
; 4330 : 	return;
; 4331 :     }
; 4332 :     term = particle->children;
; 4333 :     if (term == NULL) {
; 4334 : 	fprintf(output, "(NULL)");
; 4335 :     } else {
; 4336 : 	switch (term->type) {
; 4337 : 	    case XML_SCHEMA_TYPE_ELEMENT:
; 4338 : 		fprintf(output, "ELEM '%s'", xmlSchemaFormatQName(&str,
; 4339 : 		    ((xmlSchemaElementPtr)term)->targetNamespace,
; 4340 : 		    ((xmlSchemaElementPtr)term)->name));
; 4341 : 		FREE_AND_NULL(str);
; 4342 : 		break;
; 4343 : 	    case XML_SCHEMA_TYPE_SEQUENCE:
; 4344 : 		fprintf(output, "SEQUENCE");
; 4345 : 		break;
; 4346 : 	    case XML_SCHEMA_TYPE_CHOICE:
; 4347 : 		fprintf(output, "CHOICE");
; 4348 : 		break;
; 4349 : 	    case XML_SCHEMA_TYPE_ALL:
; 4350 : 		fprintf(output, "ALL");
; 4351 : 		break;
; 4352 : 	    case XML_SCHEMA_TYPE_ANY:
; 4353 : 		fprintf(output, "ANY");
; 4354 : 		break;
; 4355 : 	    default:
; 4356 : 		fprintf(output, "UNKNOWN\n");
; 4357 : 		return;
; 4358 : 	}
; 4359 :     }
; 4360 :     if (particle->minOccurs != 1)
; 4361 : 	fprintf(output, " min: %d", particle->minOccurs);
; 4362 :     if (particle->maxOccurs >= UNBOUNDED)
; 4363 : 	fprintf(output, " max: unbounded");
; 4364 :     else if (particle->maxOccurs != 1)
; 4365 : 	fprintf(output, " max: %d", particle->maxOccurs);
; 4366 :     fprintf(output, "\n");
; 4367 :     if (term &&
; 4368 : 	((term->type == XML_SCHEMA_TYPE_SEQUENCE) ||
; 4369 : 	 (term->type == XML_SCHEMA_TYPE_CHOICE) ||
; 4370 : 	 (term->type == XML_SCHEMA_TYPE_ALL)) &&
; 4371 : 	 (term->children != NULL)) {
; 4372 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) term->children,
; 4373 : 	    output, depth +1);
; 4374 :     }
; 4375 :     if (particle->next != NULL)
; 4376 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) particle->next,
; 4377 : 		output, depth);
; 4378 : }
; 4379 : 
; 4380 : /**
; 4381 :  * xmlSchemaAttrUsesDump:
; 4382 :  * @uses:  attribute uses list
; 4383 :  * @output:  the file output
; 4384 :  *
; 4385 :  * Dumps a list of attribute use components.
; 4386 :  */
; 4387 : static void
; 4388 : xmlSchemaAttrUsesDump(xmlSchemaItemListPtr uses, FILE * output)
; 4389 : {
; 4390 :     xmlSchemaAttributeUsePtr use;
; 4391 :     xmlSchemaAttributeUseProhibPtr prohib;
; 4392 :     xmlSchemaQNameRefPtr ref;
; 4393 :     const xmlChar *name, *tns;
; 4394 :     xmlChar *str = NULL;
; 4395 :     int i;
; 4396 : 
; 4397 :     if ((uses == NULL) || (uses->nbItems == 0))
; 4398 :         return;
; 4399 : 
; 4400 :     fprintf(output, "  attributes:\n");
; 4401 :     for (i = 0; i < uses->nbItems; i++) {
; 4402 : 	use = uses->items[i];
; 4403 : 	if (use->type == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB) {
; 4404 : 	    fprintf(output, "  [prohibition] ");
; 4405 : 	    prohib = (xmlSchemaAttributeUseProhibPtr) use;
; 4406 : 	    name = prohib->name;
; 4407 : 	    tns = prohib->targetNamespace;
; 4408 : 	} else if (use->type == XML_SCHEMA_EXTRA_QNAMEREF) {
; 4409 : 	    fprintf(output, "  [reference] ");
; 4410 : 	    ref = (xmlSchemaQNameRefPtr) use;
; 4411 : 	    name = ref->name;
; 4412 : 	    tns = ref->targetNamespace;
; 4413 : 	} else {
; 4414 : 	    fprintf(output, "  [use] ");
; 4415 : 	    name = WXS_ATTRUSE_DECL_NAME(use);
; 4416 : 	    tns = WXS_ATTRUSE_DECL_TNS(use);
; 4417 : 	}
; 4418 : 	fprintf(output, "'%s'\n",
; 4419 : 	    (const char *) xmlSchemaFormatQName(&str, tns, name));
; 4420 : 	FREE_AND_NULL(str);
; 4421 :     }
; 4422 : }
; 4423 : 
; 4424 : /**
; 4425 :  * xmlSchemaTypeDump:
; 4426 :  * @output:  the file output
; 4427 :  * @type:  a type structure
; 4428 :  *
; 4429 :  * Dump a SchemaType structure
; 4430 :  */
; 4431 : static void
; 4432 : xmlSchemaTypeDump(xmlSchemaTypePtr type, FILE * output)
; 4433 : {
; 4434 :     if (type == NULL) {
; 4435 :         fprintf(output, "Type: NULL\n");
; 4436 :         return;
; 4437 :     }
; 4438 :     fprintf(output, "Type: ");
; 4439 :     if (type->name != NULL)
; 4440 :         fprintf(output, "'%s' ", type->name);
; 4441 :     else
; 4442 :         fprintf(output, "(no name) ");
; 4443 :     if (type->targetNamespace != NULL)
; 4444 : 	fprintf(output, "ns '%s' ", type->targetNamespace);
; 4445 :     switch (type->type) {
; 4446 :         case XML_SCHEMA_TYPE_BASIC:
; 4447 :             fprintf(output, "[basic] ");
; 4448 :             break;
; 4449 :         case XML_SCHEMA_TYPE_SIMPLE:
; 4450 :             fprintf(output, "[simple] ");
; 4451 :             break;
; 4452 :         case XML_SCHEMA_TYPE_COMPLEX:
; 4453 :             fprintf(output, "[complex] ");
; 4454 :             break;
; 4455 :         case XML_SCHEMA_TYPE_SEQUENCE:
; 4456 :             fprintf(output, "[sequence] ");
; 4457 :             break;
; 4458 :         case XML_SCHEMA_TYPE_CHOICE:
; 4459 :             fprintf(output, "[choice] ");
; 4460 :             break;
; 4461 :         case XML_SCHEMA_TYPE_ALL:
; 4462 :             fprintf(output, "[all] ");
; 4463 :             break;
; 4464 :         case XML_SCHEMA_TYPE_UR:
; 4465 :             fprintf(output, "[ur] ");
; 4466 :             break;
; 4467 :         case XML_SCHEMA_TYPE_RESTRICTION:
; 4468 :             fprintf(output, "[restriction] ");
; 4469 :             break;
; 4470 :         case XML_SCHEMA_TYPE_EXTENSION:
; 4471 :             fprintf(output, "[extension] ");
; 4472 :             break;
; 4473 :         default:
; 4474 :             fprintf(output, "[unknown type %d] ", type->type);
; 4475 :             break;
; 4476 :     }
; 4477 :     fprintf(output, "content: ");
; 4478 :     switch (type->contentType) {
; 4479 :         case XML_SCHEMA_CONTENT_UNKNOWN:
; 4480 :             fprintf(output, "[unknown] ");
; 4481 :             break;
; 4482 :         case XML_SCHEMA_CONTENT_EMPTY:
; 4483 :             fprintf(output, "[empty] ");
; 4484 :             break;
; 4485 :         case XML_SCHEMA_CONTENT_ELEMENTS:
; 4486 :             fprintf(output, "[element] ");
; 4487 :             break;
; 4488 :         case XML_SCHEMA_CONTENT_MIXED:
; 4489 :             fprintf(output, "[mixed] ");
; 4490 :             break;
; 4491 :         case XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS:
; 4492 : 	/* not used. */
; 4493 :             break;
; 4494 :         case XML_SCHEMA_CONTENT_BASIC:
; 4495 :             fprintf(output, "[basic] ");
; 4496 :             break;
; 4497 :         case XML_SCHEMA_CONTENT_SIMPLE:
; 4498 :             fprintf(output, "[simple] ");
; 4499 :             break;
; 4500 :         case XML_SCHEMA_CONTENT_ANY:
; 4501 :             fprintf(output, "[any] ");
; 4502 :             break;
; 4503 :     }
; 4504 :     fprintf(output, "\n");
; 4505 :     if (type->base != NULL) {
; 4506 :         fprintf(output, "  base type: '%s'", type->base);
; 4507 : 	if (type->baseNs != NULL)
; 4508 : 	    fprintf(output, " ns '%s'\n", type->baseNs);
; 4509 : 	else
; 4510 : 	    fprintf(output, "\n");
; 4511 :     }
; 4512 :     if (type->attrUses != NULL)
; 4513 : 	xmlSchemaAttrUsesDump(type->attrUses, output);
; 4514 :     if (type->annot != NULL)
; 4515 :         xmlSchemaAnnotDump(output, type->annot);
; 4516 : #ifdef DUMP_CONTENT_MODEL
; 4517 :     if ((type->type == XML_SCHEMA_TYPE_COMPLEX) &&
; 4518 : 	(type->subtypes != NULL)) {
; 4519 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) type->subtypes,
; 4520 : 	    output, 1);
; 4521 :     }
; 4522 : #endif
; 4523 : }
; 4524 : 
; 4525 : static void
; 4526 : xmlSchemaTypeDumpEntry(void *type, void *output,
; 4527 :                        const xmlChar *name ATTRIBUTE_UNUSED)
; 4528 : {
; 4529 :     xmlSchemaTypeDump((xmlSchemaTypePtr) type, (FILE *) output);
; 4530 : }
; 4531 : 
; 4532 : /**
; 4533 :  * xmlSchemaDump:
; 4534 :  * @output:  the file output
; 4535 :  * @schema:  a schema structure
; 4536 :  *
; 4537 :  * Dump a Schema structure.
; 4538 :  */
; 4539 : void
; 4540 : xmlSchemaDump(FILE * output, xmlSchemaPtr schema)
; 4541 : {
; 4542 :     if (output == NULL)
; 4543 :         return;
; 4544 :     if (schema == NULL) {
; 4545 :         fprintf(output, "Schemas: NULL\n");
; 4546 :         return;
; 4547 :     }
; 4548 :     fprintf(output, "Schemas: ");
; 4549 :     if (schema->name != NULL)
; 4550 :         fprintf(output, "%s, ", schema->name);
; 4551 :     else
; 4552 :         fprintf(output, "no name, ");
; 4553 :     if (schema->targetNamespace != NULL)
; 4554 :         fprintf(output, "%s", (const char *) schema->targetNamespace);
; 4555 :     else
; 4556 :         fprintf(output, "no target namespace");
; 4557 :     fprintf(output, "\n");
; 4558 :     if (schema->annot != NULL)
; 4559 :         xmlSchemaAnnotDump(output, schema->annot);
; 4560 :     xmlHashScan(schema->typeDecl, xmlSchemaTypeDumpEntry, output);
; 4561 :     xmlHashScanFull(schema->elemDecl, xmlSchemaElementDump, output);
; 4562 : }
; 4563 : 
; 4564 : #ifdef DEBUG_IDC_NODE_TABLE
; 4565 : /**
; 4566 :  * xmlSchemaDebugDumpIDCTable:
; 4567 :  * @vctxt: the WXS validation context
; 4568 :  *
; 4569 :  * Displays the current IDC table for debug purposes.
; 4570 :  */
; 4571 : static void
; 4572 : xmlSchemaDebugDumpIDCTable(FILE * output,
; 4573 : 			   const xmlChar *namespaceName,
; 4574 : 			   const xmlChar *localName,
; 4575 : 			   xmlSchemaPSVIIDCBindingPtr bind)
; 4576 : {
; 4577 :     xmlChar *str = NULL;
; 4578 :     const xmlChar *value;
; 4579 :     xmlSchemaPSVIIDCNodePtr tab;
; 4580 :     xmlSchemaPSVIIDCKeyPtr key;
; 4581 :     int i, j, res;
; 4582 : 
; 4583 :     fprintf(output, "IDC: TABLES on '%s'\n",
; 4584 : 	xmlSchemaFormatQName(&str, namespaceName, localName));
; 4585 :     FREE_AND_NULL(str)
; 4586 : 
; 4587 :     if (bind == NULL)
; 4588 : 	return;
; 4589 :     do {
; 4590 : 	fprintf(output, "IDC:   BINDING '%s' (%d)\n",
; 4591 : 	    xmlSchemaGetComponentQName(&str,
; 4592 : 		bind->definition), bind->nbNodes);
; 4593 : 	FREE_AND_NULL(str)
; 4594 : 	for (i = 0; i < bind->nbNodes; i++) {
; 4595 : 	    tab = bind->nodeTable[i];
; 4596 : 	    fprintf(output, "         ( ");
; 4597 : 	    for (j = 0; j < bind->definition->nbFields; j++) {
; 4598 : 		key = tab->keys[j];
; 4599 : 		if ((key != NULL) && (key->val != NULL)) {
; 4600 : 		    res = xmlSchemaGetCanonValue(key->val, &value);
; 4601 : 		    if (res >= 0)
; 4602 : 			fprintf(output, "'%s' ", value);
; 4603 : 		    else
; 4604 : 			fprintf(output, "CANON-VALUE-FAILED ");
; 4605 : 		    if (res == 0)
; 4606 : 			FREE_AND_NULL(value)
; 4607 : 		} else if (key != NULL)
; 4608 : 		    fprintf(output, "(no val), ");
; 4609 : 		else
; 4610 : 		    fprintf(output, "(key missing), ");
; 4611 : 	    }
; 4612 : 	    fprintf(output, ")\n");
; 4613 : 	}
; 4614 : 	if (bind->dupls && bind->dupls->nbItems) {
; 4615 : 	    fprintf(output, "IDC:     dupls (%d):\n", bind->dupls->nbItems);
; 4616 : 	    for (i = 0; i < bind->dupls->nbItems; i++) {
; 4617 : 		tab = bind->dupls->items[i];
; 4618 : 		fprintf(output, "         ( ");
; 4619 : 		for (j = 0; j < bind->definition->nbFields; j++) {
; 4620 : 		    key = tab->keys[j];
; 4621 : 		    if ((key != NULL) && (key->val != NULL)) {
; 4622 : 			res = xmlSchemaGetCanonValue(key->val, &value);
; 4623 : 			if (res >= 0)
; 4624 : 			    fprintf(output, "'%s' ", value);
; 4625 : 			else
; 4626 : 			    fprintf(output, "CANON-VALUE-FAILED ");
; 4627 : 			if (res == 0)
; 4628 : 			    FREE_AND_NULL(value)
; 4629 : 		    } else if (key != NULL)
; 4630 : 		    fprintf(output, "(no val), ");
; 4631 : 			else
; 4632 : 			    fprintf(output, "(key missing), ");
; 4633 : 		}
; 4634 : 		fprintf(output, ")\n");
; 4635 : 	    }
; 4636 : 	}
; 4637 : 	bind = bind->next;
; 4638 :     } while (bind != NULL);
; 4639 : }
; 4640 : #endif /* DEBUG_IDC */
; 4641 : #endif /* LIBXML_OUTPUT_ENABLED */
; 4642 : 
; 4643 : /************************************************************************
; 4644 :  *									*
; 4645 :  *			Utilities					*
; 4646 :  *									*
; 4647 :  ************************************************************************/
; 4648 : 
; 4649 : /**
; 4650 :  * xmlSchemaGetPropNode:
; 4651 :  * @node: the element node
; 4652 :  * @name: the name of the attribute
; 4653 :  *
; 4654 :  * Seeks an attribute with a name of @name in
; 4655 :  * no namespace.
; 4656 :  *
; 4657 :  * Returns the attribute or NULL if not present.
; 4658 :  */
; 4659 : static xmlAttrPtr
; 4660 : xmlSchemaGetPropNode(xmlNodePtr node, const char *name)
; 4661 : {
; 4662 :     xmlAttrPtr prop;
; 4663 : 
; 4664 :     if ((node == NULL) || (name == NULL))
; 4665 : 	return(NULL);
; 4666 :     prop = node->properties;
; 4667 :     while (prop != NULL) {

	jmp	SHORT $LN204@xmlSchemaP
$LN42@xmlSchemaP:

; 6041 :     return(xmlSchemaPValAttrNodeID(ctxt, attr));

	push	esi
	push	ebx
	call	_xmlSchemaPValAttrNodeID
	add	esp, 8
$LN204@xmlSchemaP:

; 8931 :     }
; 8932 :     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
; 8933 :     /*
; 8934 :     * Attribute "memberTypes". This is a list of QNames.
; 8935 :     * TODO: Check the value to contain anything.
; 8936 :     */
; 8937 :     attr = xmlSchemaGetPropNode(node, "memberTypes");

	push	OFFSET ??_C@_0M@OEMIGMAO@memberTypes@
	push	DWORD PTR _node$[ebp]
	call	_xmlSchemaGetPropNode
	add	esp, 8
	mov	DWORD PTR _attr$2$[ebp], eax

; 8938 :     if (attr != NULL) {

	test	eax, eax
	je	$LN5@xmlSchemaP

; 8939 : 	const xmlChar *end;
; 8940 : 	xmlChar *tmp;
; 8941 : 	const xmlChar *localName, *nsName;
; 8942 : 	xmlSchemaTypeLinkPtr link, lastLink = NULL;
; 8943 : 	xmlSchemaQNameRefPtr ref;
; 8944 : 
; 8945 : 	cur = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	push	eax
	push	ebx
	mov	DWORD PTR _lastLink$1$[ebp], 0
	call	_xmlSchemaGetNodeContent
	mov	edx, eax
	add	esp, 8

; 8946 : 	type->base = cur;

	mov	DWORD PTR [edi+56], edx
	mov	edi, ebx
$LL7@xmlSchemaP:

; 8947 : 	do {
; 8948 : 	    while (IS_BLANK_CH(*cur))

	mov	cl, BYTE PTR [edx]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN20@xmlSchemaP
	cmp	cl, 9
	jb	SHORT $LN21@xmlSchemaP
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN20@xmlSchemaP
$LN21@xmlSchemaP:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN8@xmlSchemaP
$LN20@xmlSchemaP:

; 8949 : 		cur++;

	inc	edx
	jmp	SHORT $LL7@xmlSchemaP
$LN8@xmlSchemaP:

; 8950 : 	    end = cur;

	mov	esi, edx

; 8951 : 	    while ((*end != 0) && (!(IS_BLANK_CH(*end))))

	test	cl, cl
	je	$LN210@xmlSchemaP
$LL9@xmlSchemaP:
	cmp	cl, 32					; 00000020H
	je	SHORT $LN10@xmlSchemaP
	cmp	cl, 9
	jb	SHORT $LN22@xmlSchemaP
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN10@xmlSchemaP
$LN22@xmlSchemaP:
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN10@xmlSchemaP
	mov	cl, BYTE PTR [esi+1]

; 8952 : 		end++;

	inc	esi
	test	cl, cl
	jne	SHORT $LL9@xmlSchemaP
$LN10@xmlSchemaP:

; 8953 : 	    if (end == cur)

	cmp	esi, edx
	je	$LN210@xmlSchemaP

; 8954 : 		break;
; 8955 : 	    tmp = xmlStrndup(cur, end - cur);

	mov	eax, esi
	sub	eax, edx
	push	eax
	push	edx
	call	_xmlStrndup
	mov	ebx, eax

; 8956 : 	    if (xmlSchemaPValAttrNodeQNameValue(ctxt, schema,
; 8957 : 		NULL, attr, BAD_CAST tmp, &nsName, &localName) == 0) {

	lea	eax, DWORD PTR _localName$1[ebp]
	push	eax
	lea	eax, DWORD PTR _nsName$2[ebp]
	push	eax
	push	ebx
	push	DWORD PTR _attr$2$[ebp]
	push	0
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaPValAttrNodeQNameValue
	add	esp, 36					; 00000024H
	test	eax, eax
	jne	SHORT $LN24@xmlSchemaP

; 8958 : 		/*
; 8959 : 		* Create the member type link.
; 8960 : 		*/
; 8961 : 		link = (xmlSchemaTypeLinkPtr)

	push	8
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 8962 : 		    xmlMalloc(sizeof(xmlSchemaTypeLink));
; 8963 : 		if (link == NULL) {

	test	edi, edi
	je	$LN184@xmlSchemaP

; 8965 : 			"allocating a type link", NULL);
; 8966 : 		    return (-1);
; 8967 : 		}
; 8968 : 		link->type = NULL;
; 8969 : 		link->next = NULL;
; 8970 : 		if (lastLink == NULL)

	mov	eax, DWORD PTR _lastLink$1$[ebp]
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi], 0
	test	eax, eax
	jne	SHORT $LN26@xmlSchemaP

; 8971 : 		    type->memberTypes = link;

	mov	eax, DWORD PTR _type$1$[ebp]
	mov	DWORD PTR [eax+92], edi
	jmp	SHORT $LN27@xmlSchemaP
$LN26@xmlSchemaP:

; 8972 : 		else
; 8973 : 		    lastLink->next = link;

	mov	DWORD PTR [eax], edi
$LN27@xmlSchemaP:

; 8974 : 		lastLink = link;
; 8975 : 		/*
; 8976 : 		* Create a reference item.
; 8977 : 		*/
; 8978 : 		ref = xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_SIMPLE,

	push	DWORD PTR _nsName$2[ebp]
	mov	DWORD PTR _lastLink$1$[ebp], edi
	push	DWORD PTR _localName$1[ebp]
	push	4
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaNewQNameRef
	add	esp, 16					; 00000010H

; 8979 : 		    localName, nsName);
; 8980 : 		if (ref == NULL) {

	test	eax, eax
	je	$LN185@xmlSchemaP

; 8982 : 		    return (-1);
; 8983 : 		}
; 8984 : 		/*
; 8985 : 		* Assign the reference to the link, it will be resolved
; 8986 : 		* later during fixup of the union simple type.
; 8987 : 		*/
; 8988 : 		link->type = (xmlSchemaTypePtr) ref;

	mov	DWORD PTR [edi+4], eax
	mov	edi, DWORD PTR _ctxt$[ebp]
$LN24@xmlSchemaP:

; 8989 : 	    }
; 8990 : 	    FREE_AND_NULL(tmp)

	test	ebx, ebx
	je	SHORT $LN30@xmlSchemaP
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN30@xmlSchemaP:

; 8991 : 	    cur = end;
; 8992 : 	} while (*cur != 0);

	cmp	BYTE PTR [esi], 0
	mov	edx, esi
	jne	$LL7@xmlSchemaP
$LN210@xmlSchemaP:

; 8993 : 
; 8994 :     }
; 8995 :     /*
; 8996 :     * And now for the children...
; 8997 :     */
; 8998 :     child = node->children;

	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	edi, DWORD PTR _type$1$[ebp]
$LN5@xmlSchemaP:
	mov	eax, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [eax+12]

; 8999 :     if (IS_SCHEMA(child, "annotation")) {

	test	esi, esi
	je	$LN211@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN31@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN31@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN31@xmlSchemaP

; 9000 : 	/*
; 9001 : 	* Add the annotation to the simple type ancestor.
; 9002 : 	*/
; 9003 : 	xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,

	push	1
	push	esi
	push	ebx
	call	_xmlSchemaParseAnnotation
	push	eax
	push	edi
	call	_xmlSchemaAddAnnotation

; 9004 : 	    xmlSchemaParseAnnotation(ctxt, child, 1));
; 9005 :         child = child->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 20					; 00000014H
$LN31@xmlSchemaP:

; 9006 :     }
; 9007 :     if (IS_SCHEMA(child, "simpleType")) {

	test	esi, esi
	je	$LN211@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	$LN207@xmlSchemaP
	push	OFFSET ??_C@_0L@FMMGGLOP@simpleType@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN207@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN207@xmlSchemaP

; 9008 : 	xmlSchemaTypePtr subtype, last = NULL;

	xor	edi, edi
$LL11@xmlSchemaP:

; 9009 : 
; 9010 : 	/*
; 9011 : 	* Anchor the member types in the "subtypes" field of the
; 9012 : 	* simple type.
; 9013 : 	*/
; 9014 : 	while (IS_SCHEMA(child, "simpleType")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN207@xmlSchemaP
	push	OFFSET ??_C@_0L@FMMGGLOP@simpleType@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN207@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN207@xmlSchemaP

; 9015 : 	    subtype = (xmlSchemaTypePtr)

	push	0
	push	esi
	push	DWORD PTR _schema$[ebp]
	push	ebx
	call	_xmlSchemaParseSimpleType
	add	esp, 16					; 00000010H

; 9016 : 		xmlSchemaParseSimpleType(ctxt, schema, child, 0);
; 9017 : 	    if (subtype != NULL) {

	test	eax, eax
	je	SHORT $LN33@xmlSchemaP

; 9018 : 		if (last == NULL) {

	test	edi, edi
	jne	SHORT $LN34@xmlSchemaP

; 9019 : 		    type->subtypes = subtype;

	mov	ecx, DWORD PTR _type$1$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 9020 : 		    last = subtype;
; 9021 : 		} else {

	jmp	SHORT $LN215@xmlSchemaP
$LN185@xmlSchemaP:

; 8981 : 		    FREE_AND_NULL(tmp)

	test	ebx, ebx
	je	SHORT $LN14@xmlSchemaP
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlSchemaP:

; 9042 : 	    XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES,
; 9043 : 	    NULL, node,
; 9044 : 	    "Either the attribute 'memberTypes' or "
; 9045 : 	    "at least one <simpleType> child must be present", NULL);
; 9046 :     }
; 9047 :     return (0);
; 9048 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN184@xmlSchemaP:

; 8964 : 		    xmlSchemaPErrMemory(ctxt, "xmlSchemaParseUnion, "

	push	0
	push	OFFSET ??_C@_0CM@CGPNFFK@xmlSchemaParseUnion?0?5allocating@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPErrMemory
	add	esp, 12					; 0000000cH

; 9042 : 	    XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES,
; 9043 : 	    NULL, node,
; 9044 : 	    "Either the attribute 'memberTypes' or "
; 9045 : 	    "at least one <simpleType> child must be present", NULL);
; 9046 :     }
; 9047 :     return (0);
; 9048 : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xmlSchemaP:

; 9022 : 		    last->next = subtype;

	mov	DWORD PTR [edi+4], eax
$LN215@xmlSchemaP:

; 9023 : 		    last = subtype;
; 9024 : 		}
; 9025 : 		last->next = NULL;

	mov	edi, eax
	mov	DWORD PTR [eax+4], 0
$LN33@xmlSchemaP:

; 9026 : 	    }
; 9027 : 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	$LL11@xmlSchemaP
$LN207@xmlSchemaP:

; 9028 : 	}
; 9029 :     }
; 9030 :     if (child != NULL) {

	test	esi, esi
	je	SHORT $LN211@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	mov	edi, DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$3[ebp]
	push	edi
	push	0
	push	0
	push	eax
	mov	DWORD PTR _des$3[ebp], 0
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0BL@BBOMAGGA@?$CIannotation?$DP?0?5simpleType?$CK?$CJ@
	push	DWORD PTR _des$3[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	ebx
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$3[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN155@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 9028 : 	}
; 9029 :     }
; 9030 :     if (child != NULL) {

	jmp	SHORT $LN155@xmlSchemaP
$LN211@xmlSchemaP:
	mov	edi, DWORD PTR _node$[ebp]
$LN155@xmlSchemaP:

; 9031 : 	xmlSchemaPContentErr(ctxt,
; 9032 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 9033 : 	    NULL, node, child, NULL, "(annotation?, simpleType*)");
; 9034 :     }
; 9035 :     if ((attr == NULL) && (type->subtypes == NULL)) {

	cmp	DWORD PTR _attr$2$[ebp], 0
	jne	SHORT $LN37@xmlSchemaP
	mov	eax, DWORD PTR _type$1$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN37@xmlSchemaP

; 9036 : 	 /*
; 9037 : 	* src-union-memberTypes-or-simpleTypes
; 9038 : 	* Either the memberTypes [attribute] of the <union> element must
; 9039 : 	* be non-empty or there must be at least one simpleType [child].
; 9040 : 	*/
; 9041 : 	xmlSchemaPCustomErr(ctxt,

	push	0
	push	OFFSET ??_C@_0FG@HHPGDCB@Either?5the?5attribute?5?8memberTyp@
	push	edi
	push	0
	push	3007					; 00000bbfH
	push	ebx
	call	_xmlSchemaPCustomErr
	add	esp, 24					; 00000018H
$LN37@xmlSchemaP:

; 9042 : 	    XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES,
; 9043 : 	    NULL, node,
; 9044 : 	    "Either the attribute 'memberTypes' or "
; 9045 : 	    "at least one <simpleType> child must be present", NULL);
; 9046 :     }
; 9047 :     return (0);
; 9048 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseUnion ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseElement
_TEXT	SEGMENT
_attr$5$ = -36						; size = 4
_attrValue$3$ = -36					; size = 4
_attr$6$ = -32						; size = 4
_attrValue$2$ = -32					; size = 4
_lastIDC$1$ = -28					; size = 4
_ref$1 = -28						; size = 4
_annot$1$ = -24						; size = 4
_des$2 = -24						; size = 4
tv2531 = -20						; size = 4
_ret$1$ = -20						; size = 4
_ret$1$ = -20						; size = 4
_min$1$ = -20						; size = 4
_name$3 = -20						; size = 4
_isRef$1$ = -16						; size = 4
_curIDC$1$ = -16					; size = 4
_refNs$4 = -16						; size = 4
_child$1$ = -12						; size = 4
_particle$1$ = -8					; size = 4
_max$1$ = -4						; size = 4
_ret$1$ = -4						; size = 4
_des$5 = 8						; size = 4
_des$6 = 8						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_isElemRef$ = 20					; size = 4
_topLevel$ = 24						; size = 4
_xmlSchemaParseElement PROC				; COMDAT

; 8498 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _ctxt$[ebp], 0
	mov	DWORD PTR _particle$1$[ebp], 0
	mov	DWORD PTR _annot$1$[ebp], 0
	mov	DWORD PTR _isRef$1$[ebp], 0
	je	$LN9@xmlSchemaP

; 8499 :     xmlSchemaElementPtr decl = NULL;
; 8500 :     xmlSchemaParticlePtr particle = NULL;
; 8501 :     xmlSchemaAnnotPtr annot = NULL;
; 8502 :     xmlNodePtr child = NULL;
; 8503 :     xmlAttrPtr attr, nameAttr;
; 8504 :     int min, max, isRef = 0;
; 8505 :     xmlChar *des = NULL;
; 8506 : 
; 8507 :     /* 3.3.3 Constraints on XML Representations of Element Declarations */
; 8508 :     /* TODO: Complete implementation of 3.3.6 */
; 8509 : 
; 8510 :     if ((ctxt == NULL) || (schema == NULL) || (node == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	$LN9@xmlSchemaP
	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	$LN9@xmlSchemaP

; 8512 : 
; 8513 :     if (isElemRef != NULL)

	mov	esi, DWORD PTR _isElemRef$[ebp]
	test	esi, esi
	je	SHORT $LN10@xmlSchemaP

; 8514 : 	*isElemRef = 0;

	mov	DWORD PTR [esi], 0
$LN10@xmlSchemaP:

; 8515 :     /*
; 8516 :     * If we get a "ref" attribute on a local <element> we will assume it's
; 8517 :     * a reference - even if there's a "name" attribute; this seems to be more
; 8518 :     * robust.
; 8519 :     */
; 8520 :     nameAttr = xmlSchemaGetPropNode(node, "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	ebx
	call	_xmlSchemaGetPropNode

; 8521 :     attr = xmlSchemaGetPropNode(node, "ref");

	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	ebx
	mov	edi, eax
	call	_xmlSchemaGetPropNode
	add	esp, 16					; 00000010H
	mov	ebx, eax

; 8522 :     if ((topLevel) || (attr == NULL)) {

	cmp	DWORD PTR _topLevel$[ebp], 0
	jne	$LN13@xmlSchemaP
	test	ebx, ebx
	je	$LN13@xmlSchemaP

; 8524 : 	    xmlSchemaPMissingAttrErr(ctxt,
; 8525 : 		XML_SCHEMAP_S4S_ATTR_MISSING,
; 8526 : 		NULL, node, "name", NULL);
; 8527 : 	    return (NULL);
; 8528 : 	}
; 8529 :     } else
; 8530 : 	isRef = 1;

	mov	DWORD PTR _isRef$1$[ebp], 1
$LN14@xmlSchemaP:

; 8531 : 
; 8532 :     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPValAttrID

; 8533 :     child = node->children;

	mov	ecx, DWORD PTR _node$[ebp]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _child$1$[ebp], eax

; 8534 :     if (IS_SCHEMA(child, "annotation")) {

	test	eax, eax
	je	SHORT $LN15@xmlSchemaP
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN15@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN504@xmlSchemaP
	mov	eax, DWORD PTR _child$1$[ebp]
	push	DWORD PTR _xmlSchemaNs
	mov	eax, DWORD PTR [eax+36]
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN504@xmlSchemaP

; 8535 : 	annot = xmlSchemaParseAnnotation(ctxt, child, 1);

	push	1
	push	DWORD PTR _child$1$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaParseAnnotation
	mov	DWORD PTR _annot$1$[ebp], eax
	add	esp, 12					; 0000000cH

; 8536 : 	child = child->next;

	mov	eax, DWORD PTR _child$1$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR _child$1$[ebp], eax
$LN504@xmlSchemaP:

; 8537 :     }
; 8538 :     /*
; 8539 :     * Skip particle part if a global declaration.
; 8540 :     */
; 8541 :     if (topLevel)

	mov	ecx, DWORD PTR _node$[ebp]
$LN15@xmlSchemaP:
	cmp	DWORD PTR _topLevel$[ebp], 0
	jne	$declaration_part$526

; 8542 : 	goto declaration_part;
; 8543 :     /*
; 8544 :     * The particle part ==================================================
; 8545 :     */
; 8546 :     min = xmlGetMinOccurs(ctxt, node, 0, -1, 1, "xs:nonNegativeInteger");

	push	OFFSET ??_C@_0BG@FKFDAFPO@xs?3nonNegativeInteger@
	push	1
	push	-1
	push	0
	push	ecx
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlGetMinOccurs

; 8547 :     max = xmlGetMaxOccurs(ctxt, node, 0, UNBOUNDED, 1, "(xs:nonNegativeInteger | unbounded)");

	push	OFFSET ??_C@_0CE@BEMOBFLH@?$CIxs?3nonNegativeInteger?5?$HM?5unboun@
	push	1
	push	1073741824				; 40000000H
	push	0
	push	DWORD PTR _node$[ebp]
	mov	DWORD PTR _min$1$[ebp], eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlGetMaxOccurs

; 8548 :     xmlSchemaPCheckParticleCorrect_2(ctxt, NULL, node, min, max);

	push	eax
	push	DWORD PTR _min$1$[ebp]
	mov	DWORD PTR _max$1$[ebp], eax
	push	DWORD PTR _node$[ebp]
	push	0
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPCheckParticleCorrect_2
	add	esp, 68					; 00000044H

; 8549 :     particle = xmlSchemaAddParticle(ctxt, node, min, max);

	push	DWORD PTR _max$1$[ebp]
	push	DWORD PTR _min$1$[ebp]
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaAddParticle
	add	esp, 16					; 00000010H
	mov	DWORD PTR _particle$1$[ebp], eax

; 8550 :     if (particle == NULL)

	test	eax, eax
	je	$LN87@xmlSchemaP

; 8551 : 	goto return_null;
; 8552 : 
; 8553 :     /* ret->flags |= XML_SCHEMAS_ELEM_REF; */
; 8554 : 
; 8555 :     if (isRef) {

	cmp	DWORD PTR _isRef$1$[ebp], 0
	je	$declaration_part$526

; 8556 : 	const xmlChar *refNs = NULL, *ref = NULL;

	mov	DWORD PTR _refNs$4[ebp], 0
	mov	DWORD PTR _ref$1[ebp], 0

; 8557 : 	xmlSchemaQNameRefPtr refer = NULL;
; 8558 : 	/*
; 8559 : 	* The reference part =============================================
; 8560 : 	*/
; 8561 : 	if (isElemRef != NULL)

	test	esi, esi
	je	SHORT $LN19@xmlSchemaP

; 8562 : 	    *isElemRef = 1;

	mov	DWORD PTR [esi], 1
$LN19@xmlSchemaP:

; 8563 : 
; 8564 : 	xmlSchemaPValAttrNodeQName(ctxt, schema,

	mov	esi, DWORD PTR _ctxt$[ebp]
	lea	eax, DWORD PTR _ref$1[ebp]
	push	eax
	lea	eax, DWORD PTR _refNs$4[ebp]
	push	eax
	push	ebx
	push	0
	push	DWORD PTR _schema$[ebp]
	push	esi
	call	_xmlSchemaPValAttrNodeQName

; 8565 : 	    NULL, attr, &refNs, &ref);
; 8566 : 	xmlSchemaCheckReference(ctxt, schema, node, attr, refNs);

	push	DWORD PTR _refNs$4[ebp]
	push	ebx
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _schema$[ebp]
	push	esi
	call	_xmlSchemaCheckReference
	add	esp, 44					; 0000002cH

; 8567 : 	/*
; 8568 : 	* SPEC (3.3.3 : 2.1) "One of ref or name must be present, but not both"
; 8569 : 	*/
; 8570 : 	if (nameAttr != NULL) {

	test	edi, edi
	je	$LN488@xmlSchemaP

; 8571 : 	    xmlSchemaPMutualExclAttrErr(ctxt,

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	edi
	push	0
	push	3039					; 00000bdfH
	mov	edi, esi
	push	edi
	call	_xmlSchemaPMutualExclAttrErr
	add	esp, 24					; 00000018H
	jmp	SHORT $LN20@xmlSchemaP
$LN13@xmlSchemaP:

; 8523 : 	if (nameAttr == NULL) {

	test	edi, edi
	jne	$LN14@xmlSchemaP

; 2802 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	mov	ebx, DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$2[ebp]
	push	ebx
	push	edi
	push	edi
	push	eax
	mov	DWORD PTR _des$2[ebp], edi
	call	_xmlSchemaFormatItemForReport

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	mov	eax, DWORD PTR _des$2[ebp]
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	OFFSET ??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@
	push	edi
	push	edi
	push	edi
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	inc	DWORD PTR [ecx+20]
	push	edi
	push	edi
	push	2
	push	3036					; 00000bdcH
	push	16					; 00000010H
	push	ebx
	push	ecx
	push	DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+16], 3036		; 00000bdcH
	push	DWORD PTR [ecx+8]
	push	DWORD PTR [ecx+24]
	call	___xmlRaiseError

; 2810 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$2[ebp]

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 88					; 00000058H

; 2810 :     FREE_AND_NULL(des);

	test	eax, eax
	je	$LN9@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree

; 8511 :         return (NULL);

	add	esp, 4
	xor	eax, eax
	pop	edi

; 8877 :     }
; 8878 :     return (NULL);
; 8879 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN488@xmlSchemaP:

; 8567 : 	/*
; 8568 : 	* SPEC (3.3.3 : 2.1) "One of ref or name must be present, but not both"
; 8569 : 	*/
; 8570 : 	if (nameAttr != NULL) {

	mov	edi, esi
$LN20@xmlSchemaP:

; 8572 : 		XML_SCHEMAP_SRC_ELEMENT_2_1, NULL, nameAttr, "ref", "name");
; 8573 : 	}
; 8574 : 	/*
; 8575 : 	* Check for illegal attributes.
; 8576 : 	*/
; 8577 : 	attr = node->properties;

	mov	eax, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [eax+44]

; 8578 : 	while (attr != NULL) {

	test	esi, esi
	je	$LN478@xmlSchemaP
	npad	5
$LL2@xmlSchemaP:

; 8579 : 	    if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	$LN21@xmlSchemaP

; 8580 : 		if (xmlStrEqual(attr->name, BAD_CAST "ref") ||
; 8581 : 		    xmlStrEqual(attr->name, BAD_CAST "name") ||
; 8582 : 		    xmlStrEqual(attr->name, BAD_CAST "id") ||
; 8583 : 		    xmlStrEqual(attr->name, BAD_CAST "maxOccurs") ||

	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN26@xmlSchemaP
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN26@xmlSchemaP
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN26@xmlSchemaP
	push	OFFSET ??_C@_09OBPGLENH@maxOccurs@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN26@xmlSchemaP
	push	OFFSET ??_C@_09OAPKCOGD@minOccurs@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN26@xmlSchemaP

; 8584 : 		    xmlStrEqual(attr->name, BAD_CAST "minOccurs"))
; 8585 : 		{
; 8586 : 		    attr = attr->next;
; 8587 : 		    continue;
; 8588 : 		} else {
; 8589 : 		    /* SPEC (3.3.3 : 2.2) */
; 8590 : 		    xmlSchemaPCustomAttrErr(ctxt,

	push	OFFSET ??_C@_0FH@LFNFLK@Only?5the?5attributes?5?8minOccurs?8@
	push	esi
	push	eax
	push	eax
	push	3040					; 00000be0H
	push	edi
	call	_xmlSchemaPCustomAttrErr
	add	esp, 24					; 00000018H
$LN505@xmlSchemaP:

; 8599 : 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 8600 : 	    }
; 8601 : 	    attr = attr->next;
; 8602 : 	}
; 8603 : 	/*
; 8604 : 	* No children except <annotation> expected.
; 8605 : 	*/
; 8606 : 	if (child != NULL) {

	mov	eax, DWORD PTR _node$[ebp]
$LN478@xmlSchemaP:
	mov	ebx, DWORD PTR _child$1$[ebp]
	test	ebx, ebx
	je	SHORT $LN105@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	eax
	push	0
	lea	eax, DWORD PTR _des$6[ebp]
	mov	DWORD PTR _des$6[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0O@MNAJHLGE@?$CIannotation?$DP?$CJ@
	push	DWORD PTR _des$6[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	ebx
	push	edi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$6[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN105@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN105@xmlSchemaP:

; 8607 : 	    xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 8608 : 		NULL, node, child, NULL, "(annotation?)");
; 8609 : 	}
; 8610 : 	if ((min == 0) && (max == 0))

	cmp	DWORD PTR _min$1$[ebp], 0
	jne	SHORT $LN28@xmlSchemaP
	cmp	DWORD PTR _max$1$[ebp], 0
	je	$LN509@xmlSchemaP
$LN28@xmlSchemaP:

; 8611 : 	    goto return_null;
; 8612 : 	/*
; 8613 : 	* Create the reference item and attach it to the particle.
; 8614 : 	*/
; 8615 : 	refer = xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_ELEMENT,

	push	DWORD PTR _refNs$4[ebp]
	push	DWORD PTR _ref$1[ebp]
	push	14					; 0000000eH
	push	edi
	call	_xmlSchemaNewQNameRef
	add	esp, 16					; 00000010H

; 8616 : 	    ref, refNs);
; 8617 : 	if (refer == NULL)

	test	eax, eax
	je	$LN509@xmlSchemaP

; 8618 : 	    goto return_null;
; 8619 : 	particle->children = (xmlSchemaTreeItemPtr) refer;

	mov	ebx, DWORD PTR _particle$1$[ebp]

; 8620 : 	particle->annot = annot;

	mov	ecx, DWORD PTR _annot$1$[ebp]

; 8621 : 	/*
; 8622 : 	* Add the particle to pending components, since the reference
; 8623 : 	* need to be resolved.
; 8624 : 	*/
; 8625 : 	WXS_ADD_PENDING(ctxt, particle);

	push	ebx
	push	10					; 0000000aH
	mov	DWORD PTR [ebx+12], eax
	mov	DWORD PTR [ebx+4], ecx
	mov	eax, DWORD PTR [edi+28]
	add	eax, 20					; 00000014H
	push	eax
	call	_xmlSchemaAddItemSize
	add	esp, 12					; 0000000cH

; 8626 : 	return ((xmlSchemaBasicItemPtr) particle);

	mov	eax, ebx
	pop	edi

; 8877 :     }
; 8878 :     return (NULL);
; 8879 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlSchemaP:

; 8591 : 			XML_SCHEMAP_SRC_ELEMENT_2_2,
; 8592 : 			NULL, NULL, attr,
; 8593 : 			"Only the attributes 'minOccurs', 'maxOccurs' and "
; 8594 : 			"'id' are allowed in addition to 'ref'");
; 8595 : 		    break;
; 8596 : 		}
; 8597 : 	    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN26@xmlSchemaP

; 8598 : 		xmlSchemaPIllegalAttrErr(ctxt,

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN26@xmlSchemaP:

; 8578 : 	while (attr != NULL) {

	mov	eax, DWORD PTR [esi+24]
	mov	esi, eax
	test	eax, eax
	jne	$LL2@xmlSchemaP
	jmp	$LN505@xmlSchemaP
$declaration_part$526:

; 8627 :     }
; 8628 :     /*
; 8629 :     * The declaration part ===============================================
; 8630 :     */
; 8631 : declaration_part:
; 8632 :     {
; 8633 : 	const xmlChar *ns = NULL, *fixed, *name, *attrValue;
; 8634 : 	xmlSchemaIDCPtr curIDC = NULL, lastIDC = NULL;
; 8635 : 
; 8636 : 	if (xmlSchemaPValAttrNode(ctxt, NULL, nameAttr,
; 8637 : 	    xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0)

	lea	eax, DWORD PTR _name$3[ebp]
	xor	esi, esi
	push	eax
	push	22					; 00000016H
	mov	DWORD PTR _curIDC$1$[ebp], esi
	mov	DWORD PTR _lastIDC$1$[ebp], esi
	call	_xmlSchemaGetBuiltInType
	mov	ebx, DWORD PTR _ctxt$[ebp]
	add	esp, 4
	push	eax
	push	edi
	push	esi
	push	ebx
	call	_xmlSchemaPValAttrNode
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$LN509@xmlSchemaP

; 8638 : 	    goto return_null;
; 8639 : 	/*
; 8640 : 	* Evaluate the target namespace.
; 8641 : 	*/
; 8642 : 	if (topLevel) {

	cmp	DWORD PTR _topLevel$[ebp], esi
	je	SHORT $LN31@xmlSchemaP

; 8643 : 	    ns = ctxt->targetNamespace;

	mov	esi, DWORD PTR [ebx+112]

; 8644 : 	} else {

	jmp	SHORT $LN38@xmlSchemaP
$LN31@xmlSchemaP:

; 8645 : 	    attr = xmlSchemaGetPropNode(node, "form");

	push	OFFSET ??_C@_04MLMMMEIO@form@
	push	DWORD PTR _node$[ebp]
	call	_xmlSchemaGetPropNode
	mov	edi, eax
	add	esp, 8

; 8646 : 	    if (attr != NULL) {

	test	edi, edi
	je	SHORT $LN33@xmlSchemaP

; 8647 : 		attrValue = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	push	edi
	push	ebx
	call	_xmlSchemaGetNodeContent
	mov	ebx, eax

; 8648 : 		if (xmlStrEqual(attrValue, BAD_CAST "qualified")) {

	push	OFFSET ??_C@_09NPLHLKJP@qualified@
	push	ebx
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN35@xmlSchemaP

; 8649 : 		    ns = ctxt->targetNamespace;

	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	esi, DWORD PTR [ebx+112]
	jmp	SHORT $LN38@xmlSchemaP
$LN35@xmlSchemaP:

; 8650 : 		} else if (!xmlStrEqual(attrValue, BAD_CAST "unqualified")) {

	push	OFFSET ??_C@_0M@PJKDFPFM@unqualified@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN495@xmlSchemaP

; 8651 : 		    xmlSchemaPSimpleTypeErr(ctxt,

	push	eax
	push	eax
	push	eax
	push	ebx
	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	OFFSET ??_C@_0BK@IDHDHMBC@?$CIqualified?5?$HM?5unqualified?$CJ@
	push	eax
	push	edi
	push	eax
	push	3037					; 00000bddH
	push	ebx
	call	_xmlSchemaPSimpleTypeErr
	add	esp, 40					; 00000028H

; 8652 : 			XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 8653 : 			NULL, (xmlNodePtr) attr,
; 8654 : 			NULL, "(qualified | unqualified)",
; 8655 : 			attrValue, NULL, NULL, NULL);
; 8656 : 		}

	jmp	SHORT $LN38@xmlSchemaP
$LN33@xmlSchemaP:

; 8657 : 	    } else if (schema->flags & XML_SCHEMAS_QUALIF_ELEM)

	mov	eax, DWORD PTR _schema$[ebp]
	test	BYTE PTR [eax+24], 1
	je	SHORT $LN38@xmlSchemaP

; 8658 : 		ns = ctxt->targetNamespace;

	mov	esi, DWORD PTR [ebx+112]
	jmp	SHORT $LN38@xmlSchemaP
$LN495@xmlSchemaP:

; 8650 : 		} else if (!xmlStrEqual(attrValue, BAD_CAST "unqualified")) {

	mov	ebx, DWORD PTR _ctxt$[ebp]
$LN38@xmlSchemaP:

; 5367 :     if ((ctxt == NULL) || (name == NULL))

	mov	edi, DWORD PTR _name$3[ebp]
	test	edi, edi
	je	SHORT $LN509@xmlSchemaP

; 5368 :         return (NULL);
; 5369 : 
; 5370 :     ret = (xmlSchemaElementPtr) xmlMalloc(sizeof(xmlSchemaElement));

	push	104					; 00000068H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _ret$1$[ebp], eax

; 5371 :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN128@xmlSchemaP

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [ebx+20]

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BD@OFNGJBCE@allocating?5element@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
$LN509@xmlSchemaP:

; 8866 : 	return ((xmlSchemaBasicItemPtr) particle);
; 8867 :     }
; 8868 : 
; 8869 : return_null:
; 8870 :     FREE_AND_NULL(des);
; 8871 :     if (annot != NULL) {

	mov	eax, DWORD PTR _particle$1$[ebp]
$LN87@xmlSchemaP:
	mov	ecx, DWORD PTR _annot$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN9@xmlSchemaP

; 8872 : 	if (particle != NULL)

	test	eax, eax
	je	SHORT $LN90@xmlSchemaP

; 8873 : 	    particle->annot = NULL;

	mov	DWORD PTR [eax+4], 0
$LN90@xmlSchemaP:

; 8874 : 	if (decl != NULL)
; 8875 : 	    decl->annot = NULL;
; 8876 : 	xmlSchemaFreeAnnot(annot);

	push	ecx
	call	_xmlSchemaFreeAnnot
	add	esp, 4
$LN9@xmlSchemaP:

; 8877 :     }
; 8878 :     return (NULL);
; 8879 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN128@xmlSchemaP:

; 5375 :     memset(ret, 0, sizeof(xmlSchemaElement));

	push	104					; 00000068H
	push	0
	push	eax
	call	_memset

; 5376 :     ret->type = XML_SCHEMA_TYPE_ELEMENT;

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 12					; 0000000cH

; 5377 :     ret->name = name;
; 5378 :     ret->targetNamespace = nsName;
; 5379 :     ret->node = node;
; 5380 : 
; 5381 :     if (topLevel)

	mov	edx, DWORD PTR _topLevel$[ebp]
	mov	DWORD PTR [eax+8], edi
	mov	edi, eax
	mov	DWORD PTR [eax], 14			; 0000000eH
	mov	DWORD PTR [edi+52], esi
	mov	esi, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edi+36], esi
	mov	eax, DWORD PTR [ebx+28]
	mov	eax, DWORD PTR [eax+16]

; 5382 : 	WXS_ADD_GLOBAL(ctxt, ret);

	lea	ecx, DWORD PTR [eax+44]
	test	edx, edx
	jne	SHORT $LN130@xmlSchemaP

; 5383 :     else
; 5384 : 	WXS_ADD_LOCAL(ctxt, ret);

	lea	ecx, DWORD PTR [eax+48]
$LN130@xmlSchemaP:

; 5385 :     WXS_ADD_PENDING(ctxt, ret);

	test	edx, edx
	mov	DWORD PTR tv2531[ebp], 10		; 0000000aH
	mov	eax, 5
	cmove	eax, DWORD PTR tv2531[ebp]
	push	edi
	push	eax
	push	ecx
	call	_xmlSchemaAddItemSize
	mov	eax, DWORD PTR [ebx+28]
	push	edi
	add	eax, 20					; 00000014H
	push	10					; 0000000aH
	push	eax
	call	_xmlSchemaAddItemSize

; 8659 : 	}
; 8660 : 	decl = xmlSchemaAddElement(ctxt, name, ns, node, topLevel);
; 8661 : 	if (decl == NULL) {
; 8662 : 	    goto return_null;
; 8663 : 	}
; 8664 : 	/*
; 8665 : 	* Check for illegal attributes.
; 8666 : 	*/
; 8667 : 	attr = node->properties;

	mov	esi, DWORD PTR [esi+44]

; 5385 :     WXS_ADD_PENDING(ctxt, ret);

	add	esp, 24					; 00000018H

; 8668 : 	while (attr != NULL) {

	test	esi, esi
	je	$LN5@xmlSchemaP
$LL4@xmlSchemaP:

; 8669 : 	    if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	$LN40@xmlSchemaP

; 8670 : 		if ((!xmlStrEqual(attr->name, BAD_CAST "name")) &&
; 8671 : 		    (!xmlStrEqual(attr->name, BAD_CAST "type")) &&
; 8672 : 		    (!xmlStrEqual(attr->name, BAD_CAST "id")) &&
; 8673 : 		    (!xmlStrEqual(attr->name, BAD_CAST "default")) &&
; 8674 : 		    (!xmlStrEqual(attr->name, BAD_CAST "fixed")) &&
; 8675 : 		    (!xmlStrEqual(attr->name, BAD_CAST "block")) &&

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN47@xmlSchemaP
	push	OFFSET ??_C@_04GPMDFGEJ@type@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN47@xmlSchemaP
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN47@xmlSchemaP
	push	OFFSET ??_C@_07DLHCIBDH@default@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN47@xmlSchemaP
	push	OFFSET ??_C@_05OFLEIIDM@fixed@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN47@xmlSchemaP
	push	OFFSET ??_C@_05PIBOEKAB@block@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN47@xmlSchemaP
	push	OFFSET ??_C@_08BNOJCPJE@nillable@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN47@xmlSchemaP

; 8676 : 		    (!xmlStrEqual(attr->name, BAD_CAST "nillable")))
; 8677 : 		{
; 8678 : 		    if (topLevel == 0) {

	cmp	DWORD PTR _topLevel$[ebp], 0
	mov	eax, DWORD PTR [esi+8]
	jne	SHORT $LN43@xmlSchemaP

; 8679 : 			if ((!xmlStrEqual(attr->name, BAD_CAST "maxOccurs")) &&
; 8680 : 			    (!xmlStrEqual(attr->name, BAD_CAST "minOccurs")) &&

	push	OFFSET ??_C@_09OBPGLENH@maxOccurs@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN47@xmlSchemaP
	push	OFFSET ??_C@_09OAPKCOGD@minOccurs@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN47@xmlSchemaP
	push	OFFSET ??_C@_04MLMMMEIO@form@
$LN513@xmlSchemaP:

; 8695 : 
; 8696 : 		xmlSchemaPIllegalAttrErr(ctxt,
; 8697 : 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 8698 : 	    }
; 8699 : 	    attr = attr->next;

	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN47@xmlSchemaP
	jmp	SHORT $LN512@xmlSchemaP
$LN43@xmlSchemaP:

; 8681 : 			    (!xmlStrEqual(attr->name, BAD_CAST "form")))
; 8682 : 			{
; 8683 : 			    xmlSchemaPIllegalAttrErr(ctxt,
; 8684 : 				XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 8685 : 			}
; 8686 : 		    } else if ((!xmlStrEqual(attr->name, BAD_CAST "final")) &&
; 8687 : 			(!xmlStrEqual(attr->name, BAD_CAST "abstract")) &&

	push	OFFSET ??_C@_05FPBGKCKL@final@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN47@xmlSchemaP
	push	OFFSET ??_C@_08IMFJLGFD@abstract@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN47@xmlSchemaP
	push	OFFSET ??_C@_0BC@CGDMBFF@substitutionGroup@

; 8688 : 			(!xmlStrEqual(attr->name, BAD_CAST "substitutionGroup"))) {
; 8689 : 
; 8690 : 			xmlSchemaPIllegalAttrErr(ctxt,
; 8691 : 			    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 8692 : 		    }
; 8693 : 		}

	jmp	SHORT $LN513@xmlSchemaP
$LN40@xmlSchemaP:

; 8694 : 	    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN47@xmlSchemaP
$LN512@xmlSchemaP:

; 8695 : 
; 8696 : 		xmlSchemaPIllegalAttrErr(ctxt,
; 8697 : 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 8698 : 	    }
; 8699 : 	    attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	ebx
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN47@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	$LL4@xmlSchemaP
$LN5@xmlSchemaP:

; 8700 : 	}
; 8701 : 	/*
; 8702 : 	* Extract/validate attributes.
; 8703 : 	*/
; 8704 : 	if (topLevel) {

	cmp	DWORD PTR _topLevel$[ebp], 0
	je	$LN502@xmlSchemaP

; 8705 : 	    /*
; 8706 : 	    * Process top attributes of global element declarations here.
; 8707 : 	    */
; 8708 : 	    decl->flags |= XML_SCHEMAS_ELEM_GLOBAL;
; 8709 : 	    decl->flags |= XML_SCHEMAS_ELEM_TOPLEVEL;
; 8710 : 	    xmlSchemaPValAttrQName(ctxt, schema,

	mov	esi, DWORD PTR _ctxt$[ebp]
	lea	eax, DWORD PTR [edi+64]
	or	DWORD PTR [edi+48], 34			; 00000022H
	lea	ebx, DWORD PTR [edi+48]
	push	eax
	lea	eax, DWORD PTR [edi+68]
	mov	edi, DWORD PTR _node$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@CGDMBFF@substitutionGroup@
	push	edi
	push	0
	push	DWORD PTR _schema$[ebp]
	push	esi
	call	_xmlSchemaPValAttrQName

; 8711 : 		NULL, node, "substitutionGroup",
; 8712 : 		&(decl->substGroupNs), &(decl->substGroup));
; 8713 : 	    if (xmlGetBooleanProp(ctxt, node, "abstract", 0))

	push	0
	push	OFFSET ??_C@_08IMFJLGFD@abstract@
	push	edi
	push	esi
	call	_xmlGetBooleanProp
	add	esp, 44					; 0000002cH
	test	eax, eax
	je	SHORT $LN467@xmlSchemaP

; 8714 : 		decl->flags |= XML_SCHEMAS_ELEM_ABSTRACT;

	or	DWORD PTR [ebx], 16			; 00000010H
$LN467@xmlSchemaP:

; 8715 : 	    /*
; 8716 : 	    * Attribute "final".
; 8717 : 	    */
; 8718 : 	    attr = xmlSchemaGetPropNode(node, "final");

	push	OFFSET ??_C@_05FPBGKCKL@final@
	push	edi
	call	_xmlSchemaGetPropNode
	add	esp, 8
	mov	DWORD PTR _attr$5$[ebp], eax

; 8719 : 	    if (attr == NULL) {

	test	eax, eax
	jne	SHORT $LN50@xmlSchemaP

; 8720 : 		if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_EXTENSION)

	mov	esi, DWORD PTR _schema$[ebp]
	mov	eax, DWORD PTR [esi+24]
	test	al, 4
	je	SHORT $LN468@xmlSchemaP

; 8721 : 		    decl->flags |= XML_SCHEMAS_ELEM_FINAL_EXTENSION;

	or	DWORD PTR [ebx], 32768			; 00008000H
	mov	eax, DWORD PTR [esi+24]
$LN468@xmlSchemaP:

; 8722 : 		if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION)

	test	al, 8
	je	SHORT $LN491@xmlSchemaP

; 8723 : 		    decl->flags |= XML_SCHEMAS_ELEM_FINAL_RESTRICTION;

	or	DWORD PTR [ebx], 65536			; 00010000H
$LN491@xmlSchemaP:

; 8731 : 			XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 8732 : 			NULL, (xmlNodePtr) attr,
; 8733 : 			NULL, "(#all | List of (extension | restriction))",
; 8734 : 			attrValue, NULL, NULL, NULL);
; 8735 : 		}
; 8736 : 	    }
; 8737 : 	}
; 8738 : 	/*
; 8739 : 	* Attribute "block".
; 8740 : 	*/
; 8741 : 	attr = xmlSchemaGetPropNode(node, "block");

	mov	ebx, DWORD PTR _ctxt$[ebp]
	jmp	SHORT $LN54@xmlSchemaP
$LN50@xmlSchemaP:

; 8724 : 	    } else {
; 8725 : 		attrValue = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	push	eax
	push	esi
	call	_xmlSchemaGetNodeContent
	add	esp, 8

; 7953 :     int ret = 0;

	mov	DWORD PTR _ret$1$[ebp], 0

; 8724 : 	    } else {
; 8725 : 		attrValue = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	mov	esi, eax
	mov	DWORD PTR _attrValue$2$[ebp], esi

; 7958 :     if ((flags == NULL) || (value == NULL))

	test	ebx, ebx
	je	$LN144@xmlSchemaP
	test	esi, esi
	je	$LN144@xmlSchemaP

; 7959 : 	return (-1);
; 7960 :     if (value[0] == 0)

	cmp	BYTE PTR [esi], 0
	je	SHORT $LN494@xmlSchemaP

; 7961 : 	return (0);
; 7962 :     if (xmlStrEqual(value, BAD_CAST "#all")) {

	push	OFFSET ??_C@_04LEKDNLLP@?$CDall@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN146@xmlSchemaP

; 7963 : 	if (flagAll != -1)
; 7964 : 	    *flags |= flagAll;
; 7965 : 	else {
; 7966 : 	    if (flagExtension != -1)
; 7967 : 		*flags |= flagExtension;
; 7968 : 	    if (flagRestriction != -1)
; 7969 : 		*flags |= flagRestriction;

	or	DWORD PTR [ebx], 98304			; 00018000H
$LN494@xmlSchemaP:

; 8731 : 			XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 8732 : 			NULL, (xmlNodePtr) attr,
; 8733 : 			NULL, "(#all | List of (extension | restriction))",
; 8734 : 			attrValue, NULL, NULL, NULL);
; 8735 : 		}
; 8736 : 	    }
; 8737 : 	}
; 8738 : 	/*
; 8739 : 	* Attribute "block".
; 8740 : 	*/
; 8741 : 	attr = xmlSchemaGetPropNode(node, "block");

	mov	ebx, DWORD PTR _ctxt$[ebp]
$LN502@xmlSchemaP:
	mov	esi, DWORD PTR _schema$[ebp]
$LN54@xmlSchemaP:
	push	OFFSET ??_C@_05PIBOEKAB@block@
	push	DWORD PTR _node$[ebp]
	call	_xmlSchemaGetPropNode
	add	esp, 8
	mov	DWORD PTR _attr$6$[ebp], eax

; 8742 : 	if (attr == NULL) {

	test	eax, eax
	jne	$LN55@xmlSchemaP

; 8743 : 	    /*
; 8744 : 	    * Apply default "block" values.
; 8745 : 	    */
; 8746 : 	    if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION)

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR _ret$1$[ebp]
	test	al, al
	jns	SHORT $LN470@xmlSchemaP

; 8747 : 		decl->flags |= XML_SCHEMAS_ELEM_BLOCK_RESTRICTION;

	or	DWORD PTR [ecx+48], 4096		; 00001000H
	mov	eax, DWORD PTR [esi+24]
$LN470@xmlSchemaP:

; 8748 : 	    if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION)

	test	al, 64					; 00000040H
	je	SHORT $LN471@xmlSchemaP

; 8749 : 		decl->flags |= XML_SCHEMAS_ELEM_BLOCK_EXTENSION;

	or	DWORD PTR [ecx+48], 2048		; 00000800H
	mov	eax, DWORD PTR [esi+24]
$LN471@xmlSchemaP:

; 8750 : 	    if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION)

	test	eax, 256				; 00000100H
	je	$LN60@xmlSchemaP

; 8751 : 		decl->flags |= XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION;

	or	DWORD PTR [ecx+48], 8192		; 00002000H
	jmp	$LN60@xmlSchemaP
$LN146@xmlSchemaP:

; 7978 : 	const xmlChar *end, *cur = value;

	mov	ecx, esi
$LL139@xmlSchemaP:

; 7979 : 	xmlChar *item;
; 7980 : 
; 7981 : 	do {
; 7982 : 	    while (IS_BLANK_CH(*cur))

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN155@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN156@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN155@xmlSchemaP
$LN156@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN140@xmlSchemaP
$LN155@xmlSchemaP:

; 7983 : 		cur++;

	inc	ecx
	jmp	SHORT $LL139@xmlSchemaP
$LN140@xmlSchemaP:

; 7984 : 	    end = cur;

	mov	edi, ecx

; 7985 : 	    while ((*end != 0) && (!(IS_BLANK_CH(*end))))

	test	al, al
	je	SHORT $LN494@xmlSchemaP
$LL141@xmlSchemaP:
	cmp	al, 32					; 00000020H
	je	SHORT $LN142@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN157@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN142@xmlSchemaP
$LN157@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN142@xmlSchemaP
	mov	al, BYTE PTR [edi+1]

; 7986 : 		end++;

	inc	edi
	test	al, al
	jne	SHORT $LL141@xmlSchemaP
$LN142@xmlSchemaP:

; 7987 : 	    if (end == cur)

	cmp	edi, ecx
	je	$LN494@xmlSchemaP

; 7988 : 		break;
; 7989 : 	    item = xmlStrndup(cur, end - cur);

	mov	eax, edi
	sub	eax, ecx
	push	eax
	push	ecx
	call	_xmlStrndup
	mov	esi, eax

; 7990 : 	    if (xmlStrEqual(item, BAD_CAST "extension")) {

	push	OFFSET ??_C@_09ODADEDNA@extension@
	push	esi
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN159@xmlSchemaP

; 7991 : 		if (flagExtension != -1) {
; 7992 : 		    if ((*flags & flagExtension) == 0)

	mov	eax, DWORD PTR [ebx]
	test	eax, 32768				; 00008000H
	jne	SHORT $LN179@xmlSchemaP

; 7993 : 			*flags |= flagExtension;

	or	eax, 32768				; 00008000H
	mov	DWORD PTR [ebx], eax

; 7994 : 		} else
; 7995 : 		    ret = 1;
; 7996 : 	    } else if (xmlStrEqual(item, BAD_CAST "restriction")) {

	jmp	SHORT $LN179@xmlSchemaP
$LN159@xmlSchemaP:
	push	OFFSET ??_C@_0M@FBFLGGFO@restriction@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN164@xmlSchemaP

; 7997 : 		if (flagRestriction != -1) {
; 7998 : 		    if ((*flags & flagRestriction) == 0)

	mov	eax, DWORD PTR [ebx]
	test	eax, 65536				; 00010000H
	jne	SHORT $LN179@xmlSchemaP

; 7999 : 			*flags |= flagRestriction;

	or	eax, 65536				; 00010000H
	mov	DWORD PTR [ebx], eax

; 8000 : 		} else
; 8001 : 		    ret = 1;
; 8002 : 	    } else if (xmlStrEqual(item, BAD_CAST "substitution")) {

	jmp	SHORT $LN179@xmlSchemaP
$LN164@xmlSchemaP:
	push	OFFSET ??_C@_0N@INDADLAA@substitution@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN514@xmlSchemaP

; 8006 : 		} else
; 8007 : 		    ret = 1;
; 8008 : 	    } else if (xmlStrEqual(item, BAD_CAST "list")) {

	push	OFFSET ??_C@_04DONFEANM@list@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN514@xmlSchemaP

; 8009 : 		if (flagList != -1) {
; 8010 : 		    if ((*flags & flagList) == 0)
; 8011 : 			*flags |= flagList;
; 8012 : 		} else
; 8013 : 		    ret = 1;
; 8014 : 	    } else if (xmlStrEqual(item, BAD_CAST "union")) {

	push	OFFSET ??_C@_05MNALHJLP@union@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
$LN514@xmlSchemaP:

; 8015 : 		if (flagUnion != -1) {
; 8016 : 		    if ((*flags & flagUnion) == 0)
; 8017 : 			*flags |= flagUnion;
; 8018 : 		} else
; 8019 : 		    ret = 1;
; 8020 : 	    } else
; 8021 : 		ret = 1;
; 8022 : 	    if (item != NULL)

	mov	DWORD PTR _ret$1$[ebp], 1
$LN179@xmlSchemaP:
	test	esi, esi
	je	SHORT $LN184@xmlSchemaP

; 8023 : 		xmlFree(item);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN184@xmlSchemaP:

; 8024 : 	    cur = end;
; 8025 : 	} while ((ret == 0) && (*cur != 0));

	cmp	DWORD PTR _ret$1$[ebp], 0
	mov	ecx, edi
	jne	SHORT $LN486@xmlSchemaP
	cmp	BYTE PTR [edi], 0
	jne	$LL139@xmlSchemaP

; 8584 : 		    xmlStrEqual(attr->name, BAD_CAST "minOccurs"))
; 8585 : 		{
; 8586 : 		    attr = attr->next;
; 8587 : 		    continue;
; 8588 : 		} else {
; 8589 : 		    /* SPEC (3.3.3 : 2.2) */
; 8590 : 		    xmlSchemaPCustomAttrErr(ctxt,

	jmp	$LN494@xmlSchemaP
$LN486@xmlSchemaP:

; 8025 : 	} while ((ret == 0) && (*cur != 0));

	mov	esi, DWORD PTR _attrValue$2$[ebp]
$LN144@xmlSchemaP:

; 8726 : 		if (xmlSchemaPValAttrBlockFinal(attrValue, &(decl->flags),
; 8727 : 		    -1,
; 8728 : 		    XML_SCHEMAS_ELEM_FINAL_EXTENSION,
; 8729 : 		    XML_SCHEMAS_ELEM_FINAL_RESTRICTION, -1, -1, -1) != 0) {
; 8730 : 		    xmlSchemaPSimpleTypeErr(ctxt,

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	0
	push	0
	push	0
	push	esi
	push	OFFSET ??_C@_0CL@KNGCEGAB@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@
	push	0
	push	DWORD PTR _attr$5$[ebp]
	push	0
	push	3037					; 00000bddH
	push	ebx
	call	_xmlSchemaPSimpleTypeErr
	add	esp, 40					; 00000028H

; 7960 :     if (value[0] == 0)

	jmp	$LN502@xmlSchemaP
$LN55@xmlSchemaP:

; 8752 : 	} else {
; 8753 : 	    attrValue = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	push	eax
	push	ebx
	call	_xmlSchemaGetNodeContent

; 8754 : 	    if (xmlSchemaPValAttrBlockFinal(attrValue, &(decl->flags),
; 8755 : 		-1,
; 8756 : 		XML_SCHEMAS_ELEM_BLOCK_EXTENSION,
; 8757 : 		XML_SCHEMAS_ELEM_BLOCK_RESTRICTION,
; 8758 : 		XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION, -1, -1) != 0) {

	mov	ebx, DWORD PTR _ret$1$[ebp]
	add	esp, 8

; 7953 :     int ret = 0;

	mov	DWORD PTR _ret$1$[ebp], 0

; 8752 : 	} else {
; 8753 : 	    attrValue = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	mov	esi, eax
	mov	DWORD PTR _attrValue$3$[ebp], esi

; 8754 : 	    if (xmlSchemaPValAttrBlockFinal(attrValue, &(decl->flags),
; 8755 : 		-1,
; 8756 : 		XML_SCHEMAS_ELEM_BLOCK_EXTENSION,
; 8757 : 		XML_SCHEMAS_ELEM_BLOCK_RESTRICTION,
; 8758 : 		XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION, -1, -1) != 0) {

	add	ebx, 48					; 00000030H

; 7958 :     if ((flags == NULL) || (value == NULL))

	je	$LN196@xmlSchemaP
	test	esi, esi
	je	$LN196@xmlSchemaP

; 7959 : 	return (-1);
; 7960 :     if (value[0] == 0)

	cmp	BYTE PTR [esi], 0
	je	$LN60@xmlSchemaP

; 7961 : 	return (0);
; 7962 :     if (xmlStrEqual(value, BAD_CAST "#all")) {

	push	OFFSET ??_C@_04LEKDNLLP@?$CDall@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN198@xmlSchemaP

; 7970 : 	    if (flagSubstitution != -1)
; 7971 : 		*flags |= flagSubstitution;

	or	DWORD PTR [ebx], 14336			; 00003800H

; 7972 : 	    if (flagList != -1)
; 7973 : 		*flags |= flagList;
; 7974 : 	    if (flagUnion != -1)
; 7975 : 		*flags |= flagUnion;
; 7976 : 	}
; 7977 :     } else {

	jmp	$LN60@xmlSchemaP
$LN198@xmlSchemaP:

; 7978 : 	const xmlChar *end, *cur = value;

	mov	ecx, esi
$LL191@xmlSchemaP:

; 7979 : 	xmlChar *item;
; 7980 : 
; 7981 : 	do {
; 7982 : 	    while (IS_BLANK_CH(*cur))

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN207@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN208@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN207@xmlSchemaP
$LN208@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN192@xmlSchemaP
$LN207@xmlSchemaP:

; 7983 : 		cur++;

	inc	ecx
	jmp	SHORT $LL191@xmlSchemaP
$LN192@xmlSchemaP:

; 7984 : 	    end = cur;

	mov	edi, ecx

; 7985 : 	    while ((*end != 0) && (!(IS_BLANK_CH(*end))))

	test	al, al
	je	$LN60@xmlSchemaP
$LL193@xmlSchemaP:
	cmp	al, 32					; 00000020H
	je	SHORT $LN194@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN209@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN194@xmlSchemaP
$LN209@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN194@xmlSchemaP
	mov	al, BYTE PTR [edi+1]

; 7986 : 		end++;

	inc	edi
	test	al, al
	jne	SHORT $LL193@xmlSchemaP
$LN194@xmlSchemaP:

; 7987 : 	    if (end == cur)

	cmp	edi, ecx
	je	$LN60@xmlSchemaP

; 7988 : 		break;
; 7989 : 	    item = xmlStrndup(cur, end - cur);

	mov	eax, edi
	sub	eax, ecx
	push	eax
	push	ecx
	call	_xmlStrndup
	mov	esi, eax

; 7990 : 	    if (xmlStrEqual(item, BAD_CAST "extension")) {

	push	OFFSET ??_C@_09ODADEDNA@extension@
	push	esi
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN211@xmlSchemaP

; 7991 : 		if (flagExtension != -1) {
; 7992 : 		    if ((*flags & flagExtension) == 0)

	mov	eax, DWORD PTR [ebx]
	test	eax, 2048				; 00000800H
	jne	$LN231@xmlSchemaP

; 7993 : 			*flags |= flagExtension;

	or	eax, 2048				; 00000800H
	mov	DWORD PTR [ebx], eax

; 7994 : 		} else
; 7995 : 		    ret = 1;
; 7996 : 	    } else if (xmlStrEqual(item, BAD_CAST "restriction")) {

	jmp	SHORT $LN231@xmlSchemaP
$LN211@xmlSchemaP:
	push	OFFSET ??_C@_0M@FBFLGGFO@restriction@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN216@xmlSchemaP

; 7997 : 		if (flagRestriction != -1) {
; 7998 : 		    if ((*flags & flagRestriction) == 0)

	mov	eax, DWORD PTR [ebx]
	test	eax, 4096				; 00001000H
	jne	SHORT $LN231@xmlSchemaP

; 7999 : 			*flags |= flagRestriction;

	or	eax, 4096				; 00001000H
	mov	DWORD PTR [ebx], eax

; 8000 : 		} else
; 8001 : 		    ret = 1;
; 8002 : 	    } else if (xmlStrEqual(item, BAD_CAST "substitution")) {

	jmp	SHORT $LN231@xmlSchemaP
$LN216@xmlSchemaP:
	push	OFFSET ??_C@_0N@INDADLAA@substitution@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN221@xmlSchemaP

; 8003 : 		if (flagSubstitution != -1) {
; 8004 : 		    if ((*flags & flagSubstitution) == 0)

	mov	eax, DWORD PTR [ebx]
	test	eax, 8192				; 00002000H
	jne	SHORT $LN231@xmlSchemaP

; 8005 : 			*flags |= flagSubstitution;

	or	eax, 8192				; 00002000H
	mov	DWORD PTR [ebx], eax

; 8006 : 		} else
; 8007 : 		    ret = 1;
; 8008 : 	    } else if (xmlStrEqual(item, BAD_CAST "list")) {

	jmp	SHORT $LN231@xmlSchemaP
$LN221@xmlSchemaP:
	push	OFFSET ??_C@_04DONFEANM@list@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN515@xmlSchemaP

; 8009 : 		if (flagList != -1) {
; 8010 : 		    if ((*flags & flagList) == 0)
; 8011 : 			*flags |= flagList;
; 8012 : 		} else
; 8013 : 		    ret = 1;
; 8014 : 	    } else if (xmlStrEqual(item, BAD_CAST "union")) {

	push	OFFSET ??_C@_05MNALHJLP@union@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
$LN515@xmlSchemaP:

; 8015 : 		if (flagUnion != -1) {
; 8016 : 		    if ((*flags & flagUnion) == 0)
; 8017 : 			*flags |= flagUnion;
; 8018 : 		} else
; 8019 : 		    ret = 1;
; 8020 : 	    } else
; 8021 : 		ret = 1;
; 8022 : 	    if (item != NULL)

	mov	DWORD PTR _ret$1$[ebp], 1
$LN231@xmlSchemaP:
	test	esi, esi
	je	SHORT $LN236@xmlSchemaP

; 8023 : 		xmlFree(item);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN236@xmlSchemaP:

; 8024 : 	    cur = end;
; 8025 : 	} while ((ret == 0) && (*cur != 0));

	cmp	DWORD PTR _ret$1$[ebp], 0
	mov	ecx, edi
	jne	SHORT $LN487@xmlSchemaP
	cmp	BYTE PTR [edi], 0
	jne	$LL191@xmlSchemaP

; 8584 : 		    xmlStrEqual(attr->name, BAD_CAST "minOccurs"))
; 8585 : 		{
; 8586 : 		    attr = attr->next;
; 8587 : 		    continue;
; 8588 : 		} else {
; 8589 : 		    /* SPEC (3.3.3 : 2.2) */
; 8590 : 		    xmlSchemaPCustomAttrErr(ctxt,

	jmp	SHORT $LN60@xmlSchemaP
$LN487@xmlSchemaP:

; 8025 : 	} while ((ret == 0) && (*cur != 0));

	mov	esi, DWORD PTR _attrValue$3$[ebp]
$LN196@xmlSchemaP:

; 8759 : 		xmlSchemaPSimpleTypeErr(ctxt,

	push	0
	push	0
	push	0
	push	esi
	push	OFFSET ??_C@_0DK@DDAOLEFB@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@
	push	0
	push	DWORD PTR _attr$6$[ebp]
	push	0
	push	3037					; 00000bddH
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPSimpleTypeErr
	add	esp, 40					; 00000028H
$LN60@xmlSchemaP:

; 8760 : 		    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 8761 : 		    NULL, (xmlNodePtr) attr,
; 8762 : 		    NULL, "(#all | List of (extension | "
; 8763 : 		    "restriction | substitution))", attrValue,
; 8764 : 		    NULL, NULL, NULL);
; 8765 : 	    }
; 8766 : 	}
; 8767 : 	if (xmlGetBooleanProp(ctxt, node, "nillable", 0))

	mov	esi, DWORD PTR _node$[ebp]
	push	0
	push	OFFSET ??_C@_08BNOJCPJE@nillable@
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlGetBooleanProp
	mov	ebx, DWORD PTR _ret$1$[ebp]
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN473@xmlSchemaP

; 8768 : 	    decl->flags |= XML_SCHEMAS_ELEM_NILLABLE;

	or	DWORD PTR [ebx+48], 1
$LN473@xmlSchemaP:

; 8769 : 
; 8770 : 	attr = xmlSchemaGetPropNode(node, "type");

	push	OFFSET ??_C@_04GPMDFGEJ@type@
	push	esi
	call	_xmlSchemaGetPropNode
	mov	edi, eax
	add	esp, 8

; 8771 : 	if (attr != NULL) {

	test	edi, edi
	je	SHORT $LN489@xmlSchemaP

; 8772 : 	    xmlSchemaPValAttrNodeQName(ctxt, schema,

	lea	ecx, DWORD PTR [ebx+56]
	push	ecx
	lea	esi, DWORD PTR [ebx+60]
	push	esi
	push	edi
	push	0
	push	DWORD PTR _schema$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPValAttrNodeQName

; 8773 : 		NULL, attr,
; 8774 : 		&(decl->namedTypeNs), &(decl->namedType));
; 8775 : 	    xmlSchemaCheckReference(ctxt, schema, node,

	push	DWORD PTR [esi]
	mov	esi, DWORD PTR _node$[ebp]
	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	push	esi
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaCheckReference
	add	esp, 44					; 0000002cH
	jmp	SHORT $LN62@xmlSchemaP
$LN489@xmlSchemaP:

; 8771 : 	if (attr != NULL) {

	mov	edi, DWORD PTR _ctxt$[ebp]
$LN62@xmlSchemaP:

; 8776 : 		attr, decl->namedTypeNs);
; 8777 : 	}
; 8778 : 	decl->value = xmlSchemaGetProp(ctxt, node, "default");

	push	OFFSET ??_C@_07DLHCIBDH@default@
	push	esi
	push	edi
	call	_xmlSchemaGetProp

; 8779 : 	attr = xmlSchemaGetPropNode(node, "fixed");

	push	OFFSET ??_C@_05OFLEIIDM@fixed@
	push	esi
	mov	DWORD PTR [ebx+76], eax
	call	_xmlSchemaGetPropNode
	mov	esi, eax
	add	esp, 20					; 00000014H

; 8780 : 	if (attr != NULL) {

	test	esi, esi
	je	SHORT $LN498@xmlSchemaP

; 8781 : 	    fixed = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	push	esi
	push	edi
	call	_xmlSchemaGetNodeContent
	add	esp, 8

; 8782 : 	    if (decl->value != NULL) {

	cmp	DWORD PTR [ebx+76], 0
	je	$LN64@xmlSchemaP

; 8783 : 		/*
; 8784 : 		* 3.3.3 : 1
; 8785 : 		* default and fixed must not both be present.
; 8786 : 		*/
; 8787 : 		xmlSchemaPMutualExclAttrErr(ctxt,

	push	OFFSET ??_C@_05OFLEIIDM@fixed@
	push	OFFSET ??_C@_07DLHCIBDH@default@
	push	esi
	push	0
	push	3038					; 00000bdeH
	push	edi
	call	_xmlSchemaPMutualExclAttrErr
	add	esp, 24					; 00000018H
$LN498@xmlSchemaP:

; 8793 : 	    }
; 8794 : 	}
; 8795 : 	/*
; 8796 : 	* And now for the children...
; 8797 : 	*/
; 8798 : 	if (IS_SCHEMA(child, "complexType")) {

	mov	esi, DWORD PTR _ret$1$[ebp]
$LN65@xmlSchemaP:
	mov	ebx, DWORD PTR _child$1$[ebp]
	test	ebx, ebx
	je	$LN397@xmlSchemaP
	cmp	DWORD PTR [ebx+36], 0
	je	$LL6@xmlSchemaP
	push	OFFSET ??_C@_0M@OCBEIBDG@complexType@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN66@xmlSchemaP
	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN66@xmlSchemaP

; 8799 : 	    /*
; 8800 : 	    * 3.3.3 : 3
; 8801 : 	    * "type" and either <simpleType> or <complexType> are mutually
; 8802 : 	    * exclusive
; 8803 : 	    */
; 8804 : 	    if (decl->namedType != NULL) {

	cmp	DWORD PTR [esi+56], 0
	push	0
	je	SHORT $LN68@xmlSchemaP

; 8805 : 		xmlSchemaPContentErr(ctxt,

	push	OFFSET ??_C@_0EI@DDMHFMFF@The?5attribute?5?8type?8?5and?5the?5?$DMc@
	push	ebx
	push	DWORD PTR _node$[ebp]
	push	0
	push	3041					; 00000be1H
	push	edi
	call	_xmlSchemaPContentErr
	add	esp, 28					; 0000001cH

; 8806 : 		    XML_SCHEMAP_SRC_ELEMENT_3,
; 8807 : 		    NULL, node, child,
; 8808 : 		    "The attribute 'type' and the <complexType> child are "
; 8809 : 		    "mutually exclusive", NULL);
; 8810 : 	    } else

	jmp	$LN72@xmlSchemaP
$LN64@xmlSchemaP:

; 8788 : 		    XML_SCHEMAP_SRC_ELEMENT_1,
; 8789 : 		    NULL, attr, "default", "fixed");
; 8790 : 	    } else {
; 8791 : 		decl->flags |= XML_SCHEMAS_ELEM_FIXED;

	mov	esi, DWORD PTR _ret$1$[ebp]
	or	DWORD PTR [esi+48], 8

; 8792 : 		decl->value = fixed;

	mov	DWORD PTR [esi+76], eax
	jmp	SHORT $LN65@xmlSchemaP
$LN68@xmlSchemaP:

; 8811 : 		WXS_ELEM_TYPEDEF(decl) = xmlSchemaParseComplexType(ctxt, schema, child, 0);

	push	ebx
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaParseComplexType

; 8812 : 	    child = child->next;

	jmp	SHORT $LN518@xmlSchemaP
$LN66@xmlSchemaP:

; 8813 : 	} else if (IS_SCHEMA(child, "simpleType")) {

	cmp	DWORD PTR [ebx+36], 0
	je	SHORT $LL6@xmlSchemaP
	push	OFFSET ??_C@_0L@FMMGGLOP@simpleType@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LL6@xmlSchemaP
	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LL6@xmlSchemaP

; 8814 : 	    /*
; 8815 : 	    * 3.3.3 : 3
; 8816 : 	    * "type" and either <simpleType> or <complexType> are
; 8817 : 	    * mutually exclusive
; 8818 : 	    */
; 8819 : 	    if (decl->namedType != NULL) {

	cmp	DWORD PTR [esi+56], 0
	push	0
	je	SHORT $LN71@xmlSchemaP

; 8820 : 		xmlSchemaPContentErr(ctxt,

	push	OFFSET ??_C@_0EH@BAMMFMJA@The?5attribute?5?8type?8?5and?5the?5?$DMs@
	push	ebx
	push	DWORD PTR _node$[ebp]
	push	0
	push	3041					; 00000be1H
	push	edi
	call	_xmlSchemaPContentErr
	add	esp, 28					; 0000001cH

; 8821 : 		    XML_SCHEMAP_SRC_ELEMENT_3,
; 8822 : 		    NULL, node, child,
; 8823 : 		    "The attribute 'type' and the <simpleType> child are "
; 8824 : 		    "mutually exclusive", NULL);
; 8825 : 	    } else

	jmp	SHORT $LN72@xmlSchemaP
$LN71@xmlSchemaP:

; 8826 : 		WXS_ELEM_TYPEDEF(decl) = xmlSchemaParseSimpleType(ctxt, schema, child, 0);

	push	ebx
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaParseSimpleType
$LN518@xmlSchemaP:

; 8827 : 	    child = child->next;
; 8828 : 	}
; 8829 : 	while ((IS_SCHEMA(child, "unique")) ||
; 8830 : 	    (IS_SCHEMA(child, "key")) || (IS_SCHEMA(child, "keyref"))) {

	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+28], eax
$LN72@xmlSchemaP:
	mov	ebx, DWORD PTR [ebx+24]
	npad	2
$LL6@xmlSchemaP:
	test	ebx, ebx
	je	$LN397@xmlSchemaP
	cmp	DWORD PTR [ebx+36], 0
	je	$LN7@xmlSchemaP
	push	OFFSET ??_C@_06ODCMFGLL@unique@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN74@xmlSchemaP
	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN73@xmlSchemaP
$LN74@xmlSchemaP:
	cmp	DWORD PTR [ebx+36], 0
	je	$LN7@xmlSchemaP
	push	OFFSET ??_C@_03ICHNJLJF@key@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN75@xmlSchemaP
	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN73@xmlSchemaP
$LN75@xmlSchemaP:
	cmp	DWORD PTR [ebx+36], 0
	je	$LN7@xmlSchemaP
	push	OFFSET ??_C@_06PLFEIJDE@keyref@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN7@xmlSchemaP
	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN7@xmlSchemaP
$LN73@xmlSchemaP:

; 8831 : 	    if (IS_SCHEMA(child, "unique")) {

	cmp	DWORD PTR [ebx+36], 0
	je	$LN501@xmlSchemaP
	push	OFFSET ??_C@_06ODCMFGLL@unique@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN76@xmlSchemaP
	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN76@xmlSchemaP

; 8832 : 		curIDC = xmlSchemaParseIDC(ctxt, schema, child,

	push	DWORD PTR [esi+52]
	push	22					; 00000016H
	jmp	SHORT $LN524@xmlSchemaP
$LN76@xmlSchemaP:

; 8833 : 		    XML_SCHEMA_TYPE_IDC_UNIQUE, decl->targetNamespace);
; 8834 : 	    } else if (IS_SCHEMA(child, "key")) {

	cmp	DWORD PTR [ebx+36], 0
	je	$LN501@xmlSchemaP
	push	OFFSET ??_C@_03ICHNJLJF@key@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN78@xmlSchemaP
	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN78@xmlSchemaP

; 8835 : 		curIDC = xmlSchemaParseIDC(ctxt, schema, child,

	push	DWORD PTR [esi+52]
	push	23					; 00000017H
$LN524@xmlSchemaP:

; 8839 : 		    XML_SCHEMA_TYPE_IDC_KEYREF, decl->targetNamespace);
; 8840 : 	    }
; 8841 : 	    if (lastIDC != NULL)

	push	ebx
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaParseIDC
	add	esp, 20					; 00000014H
	mov	DWORD PTR _curIDC$1$[ebp], eax
	jmp	SHORT $LN80@xmlSchemaP
$LN78@xmlSchemaP:

; 8836 : 		    XML_SCHEMA_TYPE_IDC_KEY, decl->targetNamespace);
; 8837 : 	    } else if (IS_SCHEMA(child, "keyref")) {

	cmp	DWORD PTR [ebx+36], 0
	je	SHORT $LN501@xmlSchemaP
	push	OFFSET ??_C@_06PLFEIJDE@keyref@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN501@xmlSchemaP
	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN501@xmlSchemaP

; 8838 : 		curIDC = xmlSchemaParseIDC(ctxt, schema, child,

	push	DWORD PTR [esi+52]
	push	24					; 00000018H
	jmp	SHORT $LN524@xmlSchemaP
$LN501@xmlSchemaP:

; 8839 : 		    XML_SCHEMA_TYPE_IDC_KEYREF, decl->targetNamespace);
; 8840 : 	    }
; 8841 : 	    if (lastIDC != NULL)

	mov	eax, DWORD PTR _curIDC$1$[ebp]
$LN80@xmlSchemaP:
	mov	ecx, DWORD PTR _lastIDC$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN81@xmlSchemaP

; 8842 : 		lastIDC->next = curIDC;

	mov	DWORD PTR [ecx+8], eax

; 8845 : 	    lastIDC = curIDC;

	mov	DWORD PTR _lastIDC$1$[ebp], eax

; 8846 : 	    child = child->next;
; 8847 : 	}

	jmp	$LN72@xmlSchemaP
$LN81@xmlSchemaP:

; 8843 : 	    else
; 8844 : 		decl->idcs = (void *) curIDC;

	mov	DWORD PTR [esi+100], eax

; 8845 : 	    lastIDC = curIDC;

	mov	DWORD PTR _lastIDC$1$[ebp], eax

; 8846 : 	    child = child->next;
; 8847 : 	}

	jmp	$LN72@xmlSchemaP
$LN7@xmlSchemaP:

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$5[ebp]
	mov	DWORD PTR _des$5[ebp], 0
	push	0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0EH@NHLOCELP@?$CIannotation?$DP?0?5?$CI?$CIsimpleType?5?$HM?5co@
	push	DWORD PTR _des$5[ebp]
	test	ebx, ebx
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	cmove	ebx, DWORD PTR _node$[ebp]
	push	3033					; 00000bd9H
	push	ebx
	push	edi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$5[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN397@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN397@xmlSchemaP:

; 8848 : 	if (child != NULL) {
; 8849 : 	    xmlSchemaPContentErr(ctxt,
; 8850 : 		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 8851 : 		NULL, node, child,
; 8852 : 		NULL, "(annotation?, ((simpleType | complexType)?, "
; 8853 : 		"(unique | key | keyref)*))");
; 8854 : 	}
; 8855 : 	decl->annot = annot;
; 8856 :     }
; 8857 :     /*
; 8858 :     * NOTE: Element Declaration Representation OK 4. will be checked at a
; 8859 :     * different layer.
; 8860 :     */
; 8861 :     FREE_AND_NULL(des)
; 8862 :     if (topLevel)

	cmp	DWORD PTR _topLevel$[ebp], 0
	mov	ecx, DWORD PTR _annot$1$[ebp]
	mov	DWORD PTR [esi+24], ecx
	je	SHORT $LN85@xmlSchemaP

; 8863 : 	return ((xmlSchemaBasicItemPtr) decl);

	pop	edi
	mov	eax, esi

; 8877 :     }
; 8878 :     return (NULL);
; 8879 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN85@xmlSchemaP:

; 8864 :     else {
; 8865 : 	particle->children = (xmlSchemaTreeItemPtr) decl;

	mov	eax, DWORD PTR _particle$1$[ebp]
	pop	edi
	mov	DWORD PTR [eax+12], esi

; 8877 :     }
; 8878 :     return (NULL);
; 8879 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseIDC
_TEXT	SEGMENT
_lastField$1$ = -8					; size = 4
_val$1$ = -4						; size = 4
_attr$2$ = -4						; size = 4
_des$1 = -4						; size = 4
_des$2 = -4						; size = 4
_des$3 = -4						; size = 4
_des$4 = -4						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_des$5 = 16						; size = 4
_node$ = 16						; size = 4
_idcCategory$ = 20					; size = 4
_targetNamespace$ = 24					; size = 4
_xmlSchemaParseIDC PROC					; COMDAT

; 8351 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR _node$[ebp]
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR [ebx+44]
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _lastField$1$[ebp], 0
	test	esi, esi
	je	$LN170@xmlSchemaP
	mov	ebx, DWORD PTR _idcCategory$[ebp]
	npad	2
$LL2@xmlSchemaP:

; 8352 :     xmlSchemaIDCPtr item = NULL;
; 8353 :     xmlNodePtr child = NULL;
; 8354 :     xmlAttrPtr attr;
; 8355 :     const xmlChar *name = NULL;
; 8356 :     xmlSchemaIDCSelectPtr field = NULL, lastField = NULL;
; 8357 : 
; 8358 :     /*
; 8359 :     * Check for illegal attributes.
; 8360 :     */
; 8361 :     attr = node->properties;
; 8362 :     while (attr != NULL) {
; 8363 : 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN7@xmlSchemaP

; 8364 : 	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
; 8365 : 		(!xmlStrEqual(attr->name, BAD_CAST "name")) &&

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlSchemaP
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlSchemaP
	cmp	ebx, 24					; 00000018H
	jne	SHORT $LN10@xmlSchemaP
	push	OFFSET ??_C@_05BEFNLAML@refer@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlSchemaP

; 8366 : 		((idcCategory != XML_SCHEMA_TYPE_IDC_KEYREF) ||
; 8367 : 		 (!xmlStrEqual(attr->name, BAD_CAST "refer")))) {
; 8368 : 		xmlSchemaPIllegalAttrErr(ctxt,
; 8369 : 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 8370 : 	    }

	jmp	SHORT $LN10@xmlSchemaP
$LN7@xmlSchemaP:

; 8371 : 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlSchemaP
$LN10@xmlSchemaP:

; 8372 : 	    xmlSchemaPIllegalAttrErr(ctxt,
; 8373 : 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 8374 : 	}
; 8375 : 	attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN11@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaP
	mov	ebx, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [ebx+44]

; 4667 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN170@xmlSchemaP
$LL32@xmlSchemaP:

; 4668 :         if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN36@xmlSchemaP
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN12@xmlSchemaP
$LN36@xmlSchemaP:

; 4669 : 	    return(prop);
; 4670 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL32@xmlSchemaP
$LN170@xmlSchemaP:

; 2802 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	0
	lea	eax, DWORD PTR _des$5[ebp]
	mov	DWORD PTR _des$5[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport
	add	esp, 16					; 00000010H

; 1905 :     xmlGenericErrorFunc channel = NULL;

	xor	ecx, ecx

; 1906 :     xmlStructuredErrorFunc schannel = NULL;

	xor	edx, edx

; 1907 :     void *data = NULL;

	xor	esi, esi

; 1908 : 
; 1909 :     if (ctxt != NULL) {

	test	edi, edi
	je	SHORT $LN44@xmlSchemaP

; 1910 :         ctxt->nberrors++;

	inc	DWORD PTR [edi+20]

; 1911 : 	ctxt->err = error;
; 1912 :         channel = ctxt->error;

	mov	ecx, DWORD PTR [edi+8]

; 1913 :         data = ctxt->errCtxt;

	mov	esi, DWORD PTR [edi+4]

; 1914 : 	schannel = ctxt->serror;

	mov	edx, DWORD PTR [edi+24]
	mov	DWORD PTR [edi+16], 3036		; 00000bdcH
$LN44@xmlSchemaP:

; 1915 :     }
; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	mov	eax, DWORD PTR _des$5[ebp]
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	push	OFFSET ??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	push	0
	push	0
	push	2
	push	3036					; 00000bdcH
	push	16					; 00000010H
	push	ebx
	push	edi
	push	esi
	push	ecx
	push	edx
	call	___xmlRaiseError

; 2810 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$5[ebp]

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 72					; 00000048H

; 2810 :     FREE_AND_NULL(des);

	test	eax, eax
	je	SHORT $LN173@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN173@xmlSchemaP:
	pop	edi

; 8473 : 	xmlSchemaPContentErr(ctxt,
; 8474 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 8475 : 	    NULL, node, child,
; 8476 : 	    NULL, "(annotation?, (selector, field+))");
; 8477 :     }
; 8478 : 
; 8479 :     return (item);
; 8480 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlSchemaP:

; 8376 :     }
; 8377 :     /*
; 8378 :     * Attribute "name" (mandatory).
; 8379 :     */
; 8380 :     attr = xmlSchemaGetPropNode(node, "name");
; 8381 :     if (attr == NULL) {
; 8382 : 	xmlSchemaPMissingAttrErr(ctxt,
; 8383 : 	    XML_SCHEMAP_S4S_ATTR_MISSING,
; 8384 : 	    NULL, node,
; 8385 : 	    "name", NULL);
; 8386 : 	return (NULL);
; 8387 :     } else if (xmlSchemaPValAttrNode(ctxt,
; 8388 : 	NULL, attr,
; 8389 : 	xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {

	push	22					; 00000016H
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	mov	ebx, eax

; 6385 :     if ((ctxt == NULL) || (type == NULL) || (attr == NULL))

	test	edi, edi
	je	SHORT $LN173@xmlSchemaP
	test	ebx, ebx
	je	SHORT $LN173@xmlSchemaP

; 6386 : 	return (-1);
; 6387 : 
; 6388 :     val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	push	esi
	push	edi
	call	_xmlSchemaGetNodeContent

; 6389 :     if (value != NULL)
; 6390 : 	*value = val;
; 6391 : 
; 6392 :     return (xmlSchemaPValAttrNodeValue(ctxt, ownerItem, attr,

	push	ebx
	push	eax
	push	esi
	push	0
	push	edi
	mov	DWORD PTR _val$1$[ebp], eax
	call	_xmlSchemaPValAttrNodeValue
	add	esp, 28					; 0000001cH

; 8376 :     }
; 8377 :     /*
; 8378 :     * Attribute "name" (mandatory).
; 8379 :     */
; 8380 :     attr = xmlSchemaGetPropNode(node, "name");
; 8381 :     if (attr == NULL) {
; 8382 : 	xmlSchemaPMissingAttrErr(ctxt,
; 8383 : 	    XML_SCHEMAP_S4S_ATTR_MISSING,
; 8384 : 	    NULL, node,
; 8385 : 	    "name", NULL);
; 8386 : 	return (NULL);
; 8387 :     } else if (xmlSchemaPValAttrNode(ctxt,
; 8388 : 	NULL, attr,
; 8389 : 	xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {

	test	eax, eax
	jne	SHORT $LN173@xmlSchemaP

; 5655 :     if ((ctxt == NULL) || (schema == NULL) || (name == NULL))

	cmp	DWORD PTR _schema$[ebp], eax
	je	SHORT $LN173@xmlSchemaP
	mov	esi, DWORD PTR _val$1$[ebp]
	test	esi, esi
	je	SHORT $LN173@xmlSchemaP

; 5656 :         return (NULL);
; 5657 : 
; 5658 :     ret = (xmlSchemaIDCPtr) xmlMalloc(sizeof(xmlSchemaIDC));

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4

; 5659 :     if (ret == NULL) {

	test	ebx, ebx
	jne	SHORT $LN54@xmlSchemaP

; 5660 :         xmlSchemaPErrMemory(ctxt,

	push	eax
	push	OFFSET ??_C@_0CN@LEONOKAC@allocating?5an?5identity?9constrai@
	push	edi
	call	_xmlSchemaPErrMemory
	add	esp, 12					; 0000000cH

; 8416 : 		return (NULL);

	xor	eax, eax
	pop	edi

; 8473 : 	xmlSchemaPContentErr(ctxt,
; 8474 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 8475 : 	    NULL, node, child,
; 8476 : 	    NULL, "(annotation?, (selector, field+))");
; 8477 :     }
; 8478 : 
; 8479 :     return (item);
; 8480 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@xmlSchemaP:

; 5666 :     ret->targetNamespace = nsName;

	mov	eax, DWORD PTR _targetNamespace$[ebp]
	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+24], 0
	mov	DWORD PTR [ebx+28], 0
	mov	DWORD PTR [ebx+32], 0
	mov	DWORD PTR [ebx+36], 0
	mov	DWORD PTR [ebx+20], eax

; 5667 :     ret->name = name;
; 5668 :     ret->type = category;

	mov	eax, DWORD PTR _idcCategory$[ebp]
	mov	DWORD PTR [ebx+16], esi

; 5669 :     ret->node = node;

	mov	esi, DWORD PTR _node$[ebp]
	mov	DWORD PTR [ebx], eax
	mov	DWORD PTR [ebx+12], esi

; 5670 : 
; 5671 :     WXS_ADD_GLOBAL(ctxt, ret);

	mov	eax, DWORD PTR [edi+28]
	push	ebx
	push	5
	mov	eax, DWORD PTR [eax+16]
	add	eax, 44					; 0000002cH
	push	eax
	call	_xmlSchemaAddItemSize
	add	esp, 12					; 0000000cH

; 5672 :     /*
; 5673 :     * Only keyrefs need to be fixup up.
; 5674 :     */
; 5675 :     if (category == XML_SCHEMA_TYPE_IDC_KEYREF)

	cmp	DWORD PTR _idcCategory$[ebp], 24	; 00000018H
	jne	SHORT $LN15@xmlSchemaP

; 5676 : 	WXS_ADD_PENDING(ctxt, ret);

	mov	eax, DWORD PTR [edi+28]
	push	ebx
	add	eax, 20					; 00000014H
	push	10					; 0000000aH
	push	eax
	call	_xmlSchemaAddItemSize
	add	esp, 12					; 0000000cH
$LN15@xmlSchemaP:

; 4666 :     prop = node->properties;

	mov	esi, DWORD PTR [esi+44]

; 4667 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN174@xmlSchemaP
$LL61@xmlSchemaP:

; 4668 :         if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN65@xmlSchemaP
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN60@xmlSchemaP
$LN65@xmlSchemaP:

; 4669 : 	    return(prop);
; 4670 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL61@xmlSchemaP

; 4667 :     while (prop != NULL) {

	jmp	SHORT $LN174@xmlSchemaP
$LN60@xmlSchemaP:

; 6041 :     return(xmlSchemaPValAttrNodeID(ctxt, attr));

	push	esi
	push	edi
	call	_xmlSchemaPValAttrNodeID
	add	esp, 8
$LN174@xmlSchemaP:

; 8390 : 	return (NULL);
; 8391 :     }
; 8392 :     /* Create the component. */
; 8393 :     item = xmlSchemaAddIDC(ctxt, schema, name, targetNamespace,
; 8394 : 	idcCategory, node);
; 8395 :     if (item == NULL)
; 8396 : 	return(NULL);
; 8397 : 
; 8398 :     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
; 8399 :     if (idcCategory == XML_SCHEMA_TYPE_IDC_KEYREF) {

	cmp	DWORD PTR _idcCategory$[ebp], 24	; 00000018H
	mov	esi, DWORD PTR _node$[ebp]
	jne	$LN18@xmlSchemaP

; 8400 : 	/*
; 8401 : 	* Attribute "refer" (mandatory).
; 8402 : 	*/
; 8403 : 	attr = xmlSchemaGetPropNode(node, "refer");

	push	OFFSET ??_C@_05BEFNLAML@refer@
	push	esi
	call	_xmlSchemaGetPropNode
	add	esp, 8
	mov	DWORD PTR _attr$2$[ebp], eax

; 8404 : 	if (attr == NULL) {

	test	eax, eax
	jne	SHORT $LN17@xmlSchemaP

; 2802 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	esi
	push	eax
	push	eax
	mov	DWORD PTR _des$4[ebp], eax
	lea	eax, DWORD PTR _des$4[ebp]
	push	eax
	call	_xmlSchemaFormatItemForReport

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	mov	eax, DWORD PTR _des$4[ebp]
	push	OFFSET ??_C@_05BEFNLAML@refer@
	push	eax
	push	OFFSET ??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_05BEFNLAML@refer@
	push	eax
	inc	DWORD PTR [edi+20]
	push	0
	push	0
	push	2
	push	3036					; 00000bdcH
	push	16					; 00000010H
	push	esi
	push	edi
	push	DWORD PTR [edi+4]
	mov	DWORD PTR [edi+16], 3036		; 00000bdcH
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+24]
	call	___xmlRaiseError

; 2810 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$4[ebp]

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 88					; 00000058H

; 2810 :     FREE_AND_NULL(des);

	test	eax, eax
	je	SHORT $LN18@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 8405 : 	    xmlSchemaPMissingAttrErr(ctxt,
; 8406 : 		XML_SCHEMAP_S4S_ATTR_MISSING,
; 8407 : 		NULL, node,
; 8408 : 		"refer", NULL);
; 8409 : 	} else {

	jmp	SHORT $LN18@xmlSchemaP
$LN17@xmlSchemaP:

; 8410 : 	    /*
; 8411 : 	    * Create a reference item.
; 8412 : 	    */
; 8413 : 	    item->ref = xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_IDC_KEY,

	push	0
	push	0
	push	23					; 00000017H
	push	edi
	call	_xmlSchemaNewQNameRef
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ebx+36], eax

; 8414 : 		NULL, NULL);
; 8415 : 	    if (item->ref == NULL)

	test	eax, eax
	je	$LN173@xmlSchemaP

; 8417 : 	    xmlSchemaPValAttrNodeQName(ctxt, schema,

	lea	ecx, DWORD PTR [eax+12]
	add	eax, 16					; 00000010H
	push	ecx
	push	eax
	push	DWORD PTR _attr$2$[ebp]
	push	0
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaPValAttrNodeQName

; 8418 : 		NULL, attr,
; 8419 : 		&(item->ref->targetNamespace),
; 8420 : 		&(item->ref->name));
; 8421 : 	    xmlSchemaCheckReference(ctxt, schema, node, attr,

	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR [eax+16]
	push	DWORD PTR _attr$2$[ebp]
	push	esi
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaCheckReference
	add	esp, 44					; 0000002cH
$LN18@xmlSchemaP:

; 8422 : 		item->ref->targetNamespace);
; 8423 : 	}
; 8424 :     }
; 8425 :     /*
; 8426 :     * And now for the children...
; 8427 :     */
; 8428 :     child = node->children;

	mov	esi, DWORD PTR [esi+12]

; 8429 :     if (IS_SCHEMA(child, "annotation")) {

	test	esi, esi
	je	SHORT $LN178@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN20@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlSchemaP

; 8430 : 	item->annot = xmlSchemaParseAnnotation(ctxt, child, 1);

	push	1
	push	esi
	push	edi
	call	_xmlSchemaParseAnnotation
	mov	DWORD PTR [ebx+4], eax
	add	esp, 12					; 0000000cH

; 8431 : 	child = child->next;

	mov	esi, DWORD PTR [esi+24]
$LN20@xmlSchemaP:

; 8432 :     }
; 8433 :     if (child == NULL) {

	test	esi, esi
	jne	SHORT $LN169@xmlSchemaP
$LN178@xmlSchemaP:

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$3[ebp]
	mov	DWORD PTR _des$3[ebp], 0
	push	0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,

	push	OFFSET ??_C@_0BL@HDFCKCKI@A?5child?5element?5is?5missing@
	push	DWORD PTR _des$3[ebp]
	push	OFFSET ??_C@_08EAGHGJIC@?$CFs?3?5?$CFs?4?6@
	push	3034					; 00000bdaH
	push	DWORD PTR _node$[ebp]

; 8434 : 	xmlSchemaPContentErr(ctxt,
; 8435 : 		XML_SCHEMAP_S4S_ELEM_MISSING,
; 8436 : 		NULL, node, child,
; 8437 : 		"A child element is missing",
; 8438 : 		"(annotation?, (selector, field+))");
; 8439 :     }
; 8440 :     /*
; 8441 :     * Child element <selector>.
; 8442 :     */
; 8443 :     if (IS_SCHEMA(child, "selector")) {

	jmp	$LN180@xmlSchemaP
$LN169@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN105@xmlSchemaP
	push	OFFSET ??_C@_08DILBKPNJ@selector@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN105@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN105@xmlSchemaP

; 8444 : 	item->selector = xmlSchemaParseIDCSelectorAndField(ctxt,

	push	0
	push	esi
	push	ebx
	push	edi
	call	_xmlSchemaParseIDCSelectorAndField
	mov	DWORD PTR [ebx+24], eax
	add	esp, 16					; 00000010H

; 8445 : 	    item, child, 0);
; 8446 : 	child = child->next;

	mov	esi, DWORD PTR [esi+24]

; 8447 : 	/*
; 8448 : 	* Child elements <field>.
; 8449 : 	*/
; 8450 : 	if (IS_SCHEMA(child, "field")) {

	test	esi, esi
	je	$LN23@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	$LN23@xmlSchemaP
	push	OFFSET ??_C@_05EIBGDMPB@field@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN23@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xmlSchemaP
	npad	2
$LL6@xmlSchemaP:

; 8451 : 	    do {
; 8452 : 		field = xmlSchemaParseIDCSelectorAndField(ctxt,

	push	1
	push	esi
	push	ebx
	push	edi
	call	_xmlSchemaParseIDCSelectorAndField
	add	esp, 16					; 00000010H

; 8453 : 		    item, child, 1);
; 8454 : 		if (field != NULL) {

	test	eax, eax
	je	SHORT $LN25@xmlSchemaP

; 8455 : 		    field->index = item->nbFields;

	mov	ecx, DWORD PTR [ebx+32]
	mov	DWORD PTR [eax+8], ecx

; 8456 : 		    item->nbFields++;

	inc	DWORD PTR [ebx+32]

; 8457 : 		    if (lastField != NULL)

	mov	ecx, DWORD PTR _lastField$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN26@xmlSchemaP

; 8458 : 			lastField->next = field;

	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN27@xmlSchemaP
$LN26@xmlSchemaP:

; 8459 : 		    else
; 8460 : 			item->fields = field;

	mov	DWORD PTR [ebx+28], eax
$LN27@xmlSchemaP:

; 8461 : 		    lastField = field;

	mov	DWORD PTR _lastField$1$[ebp], eax
$LN25@xmlSchemaP:

; 8462 : 		}
; 8463 : 		child = child->next;

	mov	esi, DWORD PTR [esi+24]

; 8464 : 	    } while (IS_SCHEMA(child, "field"));

	test	esi, esi
	je	$LN130@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	$LN105@xmlSchemaP
	push	OFFSET ??_C@_05EIBGDMPB@field@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN105@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL6@xmlSchemaP

; 8465 : 	} else {

	jmp	SHORT $LN105@xmlSchemaP
$LN23@xmlSchemaP:

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$2[ebp]
	mov	DWORD PTR _des$2[ebp], 0
	push	0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0CC@DEBKGIBF@?$CIannotation?$DP?0?5?$CIselector?0?5field?$CL@
	push	DWORD PTR _des$2[ebp]
	test	esi, esi
	mov	eax, esi
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	cmove	eax, DWORD PTR _node$[ebp]
	push	3033					; 00000bd9H
	push	eax
$LN180@xmlSchemaP:

; 8466 : 	    xmlSchemaPContentErr(ctxt,
; 8467 : 		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 8468 : 		NULL, node, child,
; 8469 : 		NULL, "(annotation?, (selector, field+))");
; 8470 : 	}
; 8471 :     }
; 8472 :     if (child != NULL) {

	push	edi
	call	_xmlSchemaPErr
	mov	eax, DWORD PTR _des$2[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN105@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN105@xmlSchemaP:
	test	esi, esi
	je	SHORT $LN130@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0CC@DEBKGIBF@?$CIannotation?$DP?0?5?$CIselector?0?5field?$CL@
	push	DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	edi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN130@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN130@xmlSchemaP:
	pop	edi

; 8473 : 	xmlSchemaPContentErr(ctxt,
; 8474 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 8475 : 	    NULL, node, child,
; 8476 : 	    NULL, "(annotation?, (selector, field+))");
; 8477 :     }
; 8478 : 
; 8479 :     return (item);
; 8480 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseIDC ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseIDCSelectorAndField
_TEXT	SEGMENT
_des$1 = -4						; size = 4
_ctxt$ = 8						; size = 4
_idc$ = 12						; size = 4
_des$2 = 16						; size = 4
_node$ = 16						; size = 4
_isField$ = 20						; size = 4
_xmlSchemaParseIDCSelectorAndField PROC			; COMDAT

; 8253 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	esi, DWORD PTR [esi+44]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaP
	npad	2
$LL2@xmlSchemaP:

; 8254 :     xmlSchemaIDCSelectPtr item;
; 8255 :     xmlNodePtr child = NULL;
; 8256 :     xmlAttrPtr attr;
; 8257 : 
; 8258 :     /*
; 8259 :     * Check for illegal attributes.
; 8260 :     */
; 8261 :     attr = node->properties;
; 8262 :     while (attr != NULL) {
; 8263 : 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN4@xmlSchemaP

; 8264 : 	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@xmlSchemaP
	push	OFFSET ??_C@_05CNNIIAHK@xpath@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@xmlSchemaP

; 8265 : 		(!xmlStrEqual(attr->name, BAD_CAST "xpath"))) {
; 8266 : 		xmlSchemaPIllegalAttrErr(ctxt,
; 8267 : 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 8268 : 	    }

	jmp	SHORT $LN88@xmlSchemaP
$LN4@xmlSchemaP:

; 8269 : 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@xmlSchemaP
$LN88@xmlSchemaP:

; 8270 : 	    xmlSchemaPIllegalAttrErr(ctxt,
; 8271 : 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 8272 : 	}
; 8273 : 	attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN7@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaP
$LN3@xmlSchemaP:

; 8274 :     }
; 8275 :     /*
; 8276 :     * Create the item.
; 8277 :     */
; 8278 :     item = (xmlSchemaIDCSelectPtr) xmlMalloc(sizeof(xmlSchemaIDCSelect));

	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4

; 8279 :     if (item == NULL) {

	test	ebx, ebx
	jne	SHORT $LN8@xmlSchemaP

; 1884 :     if (ctxt != NULL)

	test	edi, edi
	je	SHORT $LN16@xmlSchemaP

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [edi+20]
$LN16@xmlSchemaP:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0DN@GFJDOCKM@allocating?5a?5?8selector?8?5of?5an?5i@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 8280 :         xmlSchemaPErrMemory(ctxt,
; 8281 : 	    "allocating a 'selector' of an identity-constraint definition",
; 8282 : 	    NULL);
; 8283 :         return (NULL);

	xor	eax, eax
	pop	edi

; 8326 : 	xmlSchemaPContentErr(ctxt,
; 8327 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 8328 : 	    NULL, node, child,
; 8329 : 	    NULL, "(annotation?)");
; 8330 :     }
; 8331 : 
; 8332 :     return (item);
; 8333 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlSchemaP:

; 4666 :     prop = node->properties;

	mov	eax, DWORD PTR _node$[ebp]
	xorps	xmm0, xmm0

; 8284 :     }
; 8285 :     memset(item, 0, sizeof(xmlSchemaIDCSelect));

	movups	XMMWORD PTR [ebx], xmm0
	mov	DWORD PTR [ebx+16], 0

; 4666 :     prop = node->properties;

	mov	esi, DWORD PTR [eax+44]

; 4667 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN82@xmlSchemaP
	npad	5
$LL19@xmlSchemaP:

; 4668 :         if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN23@xmlSchemaP
	push	OFFSET ??_C@_05CNNIIAHK@xpath@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN9@xmlSchemaP
$LN23@xmlSchemaP:

; 4669 : 	    return(prop);
; 4670 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL19@xmlSchemaP

; 4667 :     while (prop != NULL) {

	mov	eax, DWORD PTR _node$[ebp]
$LN82@xmlSchemaP:

; 2802 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	eax
	push	0
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport
	add	esp, 16					; 00000010H

; 1905 :     xmlGenericErrorFunc channel = NULL;

	xor	ecx, ecx

; 1906 :     xmlStructuredErrorFunc schannel = NULL;

	xor	edx, edx

; 1907 :     void *data = NULL;

	xor	esi, esi

; 1908 : 
; 1909 :     if (ctxt != NULL) {

	test	edi, edi
	je	SHORT $LN31@xmlSchemaP

; 1910 :         ctxt->nberrors++;

	inc	DWORD PTR [edi+20]

; 1911 : 	ctxt->err = error;
; 1912 :         channel = ctxt->error;

	mov	ecx, DWORD PTR [edi+8]

; 1913 :         data = ctxt->errCtxt;

	mov	esi, DWORD PTR [edi+4]

; 1914 : 	schannel = ctxt->serror;

	mov	edx, DWORD PTR [edi+24]
	mov	DWORD PTR [edi+16], 3036		; 00000bdcH
$LN31@xmlSchemaP:

; 1915 :     }
; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	mov	eax, DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	push	OFFSET ??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	push	0
	push	0
	push	2
	push	3036					; 00000bdcH
	push	16					; 00000010H
	push	DWORD PTR _node$[ebp]
	push	edi
	push	esi
	push	ecx
	push	edx
	call	___xmlRaiseError

; 2810 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$1[ebp]

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 72					; 00000048H

; 2810 :     FREE_AND_NULL(des);

	test	eax, eax
	je	SHORT $LN11@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlSchemaP:

; 4666 :     prop = node->properties;

	mov	eax, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [eax+44]

; 4667 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN83@xmlSchemaP
	npad	2
$LL37@xmlSchemaP:

; 4668 :         if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN41@xmlSchemaP
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN36@xmlSchemaP
$LN41@xmlSchemaP:

; 4669 : 	    return(prop);
; 4670 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL37@xmlSchemaP

; 4667 :     while (prop != NULL) {

	jmp	SHORT $LN87@xmlSchemaP
$LN9@xmlSchemaP:

; 8286 :     /*
; 8287 :     * Attribute "xpath" (mandatory).
; 8288 :     */
; 8289 :     attr = xmlSchemaGetPropNode(node, "xpath");
; 8290 :     if (attr == NULL) {
; 8291 : 	xmlSchemaPMissingAttrErr(ctxt,
; 8292 : 	    XML_SCHEMAP_S4S_ATTR_MISSING,
; 8293 : 	    NULL, node,
; 8294 : 	    "name", NULL);
; 8295 :     } else {
; 8296 : 	item->xpath = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	push	esi
	push	edi
	call	_xmlSchemaGetNodeContent

; 8297 : 	/*
; 8298 : 	* URGENT TODO: "field"s have an other syntax than "selector"s.
; 8299 : 	*/
; 8300 : 
; 8301 : 	if (xmlSchemaCheckCSelectorXPath(ctxt, idc, item, attr,
; 8302 : 	    isField) == -1) {

	push	DWORD PTR _isField$[ebp]
	mov	DWORD PTR [ebx+12], eax
	push	esi
	push	ebx
	push	DWORD PTR _idc$[ebp]
	push	edi
	call	_xmlSchemaCheckCSelectorXPath
	add	esp, 28					; 0000001cH
	cmp	eax, -1
	jne	SHORT $LN11@xmlSchemaP

; 8303 : 	    xmlSchemaPErr(ctxt,

	push	0
	push	0
	push	OFFSET ??_C@_0GH@EOECGLHE@Internal?5error?3?5xmlSchemaParseI@
	push	3069					; 00000bfdH
	push	esi
	push	edi
	call	_xmlSchemaPErr
	add	esp, 24					; 00000018H
	jmp	SHORT $LN11@xmlSchemaP
$LN36@xmlSchemaP:

; 6041 :     return(xmlSchemaPValAttrNodeID(ctxt, attr));

	push	esi
	push	edi
	call	_xmlSchemaPValAttrNodeID
	add	esp, 8
$LN87@xmlSchemaP:

; 8304 : 		(xmlNodePtr) attr,
; 8305 : 		XML_SCHEMAP_INTERNAL,
; 8306 : 		"Internal error: xmlSchemaParseIDCSelectorAndField, "
; 8307 : 		"validating the XPath expression of a IDC selector.\n",
; 8308 : 		NULL, NULL);
; 8309 : 	}
; 8310 : 
; 8311 :     }
; 8312 :     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
; 8313 :     /*
; 8314 :     * And now for the children...
; 8315 :     */
; 8316 :     child = node->children;

	mov	eax, DWORD PTR _node$[ebp]
$LN83@xmlSchemaP:
	mov	esi, DWORD PTR [eax+12]

; 8317 :     if (IS_SCHEMA(child, "annotation")) {

	test	esi, esi
	je	$LN48@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN12@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN86@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN86@xmlSchemaP

; 8318 : 	/*
; 8319 : 	* Add the annotation to the parent IDC.
; 8320 : 	*/
; 8321 : 	xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) idc,

	push	1
	push	esi
	push	edi
	call	_xmlSchemaParseAnnotation
	push	eax
	push	DWORD PTR _idc$[ebp]
	call	_xmlSchemaAddAnnotation

; 8322 : 	    xmlSchemaParseAnnotation(ctxt, child, 1));
; 8323 : 	child = child->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 20					; 00000014H
$LN86@xmlSchemaP:

; 8324 :     }
; 8325 :     if (child != NULL) {

	mov	eax, DWORD PTR _node$[ebp]
$LN12@xmlSchemaP:
	test	esi, esi
	je	SHORT $LN48@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	eax
	push	0
	lea	eax, DWORD PTR _des$2[ebp]
	mov	DWORD PTR _des$2[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0O@MNAJHLGE@?$CIannotation?$DP?$CJ@
	push	DWORD PTR _des$2[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	edi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$2[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN48@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN48@xmlSchemaP:
	pop	edi

; 8326 : 	xmlSchemaPContentErr(ctxt,
; 8327 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 8328 : 	    NULL, node, child,
; 8329 : 	    NULL, "(annotation?)");
; 8330 :     }
; 8331 : 
; 8332 :     return (item);
; 8333 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseIDCSelectorAndField ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddAnnotation
_TEXT	SEGMENT
_des$1 = 8						; size = 4
_annItem$ = 8						; size = 4
_annot$ = 12						; size = 4
_xmlSchemaAddAnnotation PROC				; COMDAT

; 8153 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _annItem$[ebp]
	test	eax, eax
	je	$LN5@xmlSchemaA

; 8154 :     if ((annItem == NULL) || (annot == NULL))

	mov	esi, DWORD PTR _annot$[ebp]
	test	esi, esi
	je	$LN5@xmlSchemaA

; 8156 :     switch (annItem->type) {

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 1011				; 000003f3H
	jg	SHORT $LN38@xmlSchemaA
	cmp	ecx, 1000				; 000003e8H
	jge	SHORT $LN24@xmlSchemaA
	sub	ecx, 2
	cmp	ecx, 23					; 00000017H
	ja	SHORT $LN38@xmlSchemaA
	movzx	ecx, BYTE PTR $LN49@xmlSchemaA[ecx]
	jmp	DWORD PTR $LN52@xmlSchemaA[ecx*4]
$LN6@xmlSchemaA:

; 8235 : }

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	jne	SHORT $LN7@xmlSchemaA
	mov	DWORD PTR [eax+24], esi
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	0
$LN7@xmlSchemaA:

; 8206 : 	    }
; 8207 : 	    break;
; 8208 : 	case XML_SCHEMA_TYPE_SIMPLE:
; 8209 : 	case XML_SCHEMA_TYPE_COMPLEX: {
; 8210 : 		xmlSchemaTypePtr item = (xmlSchemaTypePtr) annItem;
; 8211 : 		ADD_ANNOTATION(annot)
; 8212 : 	    }
; 8213 : 	    break;
; 8214 : 	case XML_SCHEMA_TYPE_GROUP: {
; 8215 : 		xmlSchemaModelGroupDefPtr item = (xmlSchemaModelGroupDefPtr) annItem;
; 8216 : 		ADD_ANNOTATION(annot)
; 8217 : 	    }
; 8218 : 	    break;
; 8219 : 	case XML_SCHEMA_TYPE_SEQUENCE:
; 8220 : 	case XML_SCHEMA_TYPE_CHOICE:
; 8221 : 	case XML_SCHEMA_TYPE_ALL: {
; 8222 : 		xmlSchemaModelGroupPtr item = (xmlSchemaModelGroupPtr) annItem;
; 8223 : 		ADD_ANNOTATION(annot)
; 8224 : 	    }
; 8225 : 	    break;
; 8226 : 	default:
; 8227 : 	     xmlSchemaPCustomErr(NULL,
; 8228 : 		XML_SCHEMAP_INTERNAL,
; 8229 : 		NULL, NULL,
; 8230 : 		"Internal error: xmlSchemaAddAnnotation, "
; 8231 : 		"The item is not a annotated schema component", NULL);
; 8232 : 	     break;
; 8233 :     }
; 8234 :     return (annot);

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	cmovne	ecx, eax
	mov	eax, esi
	mov	DWORD PTR [ecx], esi
	pop	esi

; 8235 : }

	pop	ebp
	ret	0
$LN9@xmlSchemaA:

; 8157 : 	case XML_SCHEMA_TYPE_ELEMENT: {
; 8158 : 		xmlSchemaElementPtr item = (xmlSchemaElementPtr) annItem;
; 8159 : 		ADD_ANNOTATION(annot)
; 8160 : 	    }
; 8161 : 	    break;
; 8162 : 	case XML_SCHEMA_TYPE_ATTRIBUTE: {
; 8163 : 		xmlSchemaAttributePtr item = (xmlSchemaAttributePtr) annItem;
; 8164 : 		ADD_ANNOTATION(annot)

	mov	ecx, DWORD PTR [eax+32]
	test	ecx, ecx
	jne	SHORT $LN7@xmlSchemaA
	mov	DWORD PTR [eax+32], esi
	mov	eax, esi
	pop	esi

; 8235 : }

	pop	ebp
	ret	0
$LN12@xmlSchemaA:
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	jne	SHORT $LN7@xmlSchemaA
	mov	DWORD PTR [eax+8], esi
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	0
$LN15@xmlSchemaA:
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN7@xmlSchemaA
	mov	DWORD PTR [eax+4], esi
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	0
$LN24@xmlSchemaA:

; 8165 : 	    }
; 8166 : 	    break;
; 8167 : 	case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:
; 8168 : 	case XML_SCHEMA_TYPE_ANY: {
; 8169 : 		xmlSchemaWildcardPtr item = (xmlSchemaWildcardPtr) annItem;
; 8170 : 		ADD_ANNOTATION(annot)
; 8171 : 	    }
; 8172 : 	    break;
; 8173 : 	case XML_SCHEMA_TYPE_PARTICLE:
; 8174 : 	case XML_SCHEMA_TYPE_IDC_KEY:
; 8175 : 	case XML_SCHEMA_TYPE_IDC_KEYREF:
; 8176 : 	case XML_SCHEMA_TYPE_IDC_UNIQUE: {
; 8177 : 		xmlSchemaAnnotItemPtr item = (xmlSchemaAnnotItemPtr) annItem;
; 8178 : 		ADD_ANNOTATION(annot)
; 8179 : 	    }
; 8180 : 	    break;
; 8181 : 	case XML_SCHEMA_TYPE_ATTRIBUTEGROUP: {
; 8182 : 		xmlSchemaAttributeGroupPtr item =
; 8183 : 		    (xmlSchemaAttributeGroupPtr) annItem;
; 8184 : 		ADD_ANNOTATION(annot)
; 8185 : 	    }
; 8186 : 	    break;
; 8187 : 	case XML_SCHEMA_TYPE_NOTATION: {
; 8188 : 		xmlSchemaNotationPtr item = (xmlSchemaNotationPtr) annItem;
; 8189 : 		ADD_ANNOTATION(annot)
; 8190 : 	    }
; 8191 : 	    break;
; 8192 : 	case XML_SCHEMA_FACET_MININCLUSIVE:
; 8193 : 	case XML_SCHEMA_FACET_MINEXCLUSIVE:
; 8194 : 	case XML_SCHEMA_FACET_MAXINCLUSIVE:
; 8195 : 	case XML_SCHEMA_FACET_MAXEXCLUSIVE:
; 8196 : 	case XML_SCHEMA_FACET_TOTALDIGITS:
; 8197 : 	case XML_SCHEMA_FACET_FRACTIONDIGITS:
; 8198 : 	case XML_SCHEMA_FACET_PATTERN:
; 8199 : 	case XML_SCHEMA_FACET_ENUMERATION:
; 8200 : 	case XML_SCHEMA_FACET_WHITESPACE:
; 8201 : 	case XML_SCHEMA_FACET_LENGTH:
; 8202 : 	case XML_SCHEMA_FACET_MAXLENGTH:
; 8203 : 	case XML_SCHEMA_FACET_MINLENGTH: {
; 8204 : 		xmlSchemaFacetPtr item = (xmlSchemaFacetPtr) annItem;
; 8205 : 		ADD_ANNOTATION(annot)

	mov	ecx, DWORD PTR [eax+16]
	test	ecx, ecx
	jne	SHORT $LN7@xmlSchemaA
	mov	DWORD PTR [eax+16], esi
	mov	eax, esi
	pop	esi

; 8235 : }

	pop	ebp
	ret	0
$LN38@xmlSchemaA:
	push	edi

; 2949 :     xmlSchemaFormatItemForReport(&des, NULL, item, itemElem);

	push	0
	push	0
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 2950 :     msg = xmlStrdup(BAD_CAST "%s: ");

	push	OFFSET ??_C@_04PFAOODAA@?$CFs?3?5@
	call	_xmlStrdup

; 2951 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0FF@CNICCNGM@Internal?5error?3?5xmlSchemaAddAnn@
	push	eax
	call	_xmlStrcat

; 2952 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	call	_xmlStrcat

; 1982 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	push	0
	push	0
	push	0
	push	0
	push	DWORD PTR _des$1[ebp]

; 2952 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	edi, eax

; 1982 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	push	edi
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	3069					; 00000bfdH
	push	16					; 00000010H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError

; 2957 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$1[ebp]

; 1982 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 120				; 00000078H

; 2957 :     FREE_AND_NULL(des);

	test	eax, eax
	je	SHORT $LN43@xmlSchemaA
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	DWORD PTR _des$1[ebp], 0
$LN43@xmlSchemaA:

; 2958 :     FREE_AND_NULL(msg);

	test	edi, edi
	je	SHORT $LN50@xmlSchemaA
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN50@xmlSchemaA:
	pop	edi

; 8206 : 	    }
; 8207 : 	    break;
; 8208 : 	case XML_SCHEMA_TYPE_SIMPLE:
; 8209 : 	case XML_SCHEMA_TYPE_COMPLEX: {
; 8210 : 		xmlSchemaTypePtr item = (xmlSchemaTypePtr) annItem;
; 8211 : 		ADD_ANNOTATION(annot)
; 8212 : 	    }
; 8213 : 	    break;
; 8214 : 	case XML_SCHEMA_TYPE_GROUP: {
; 8215 : 		xmlSchemaModelGroupDefPtr item = (xmlSchemaModelGroupDefPtr) annItem;
; 8216 : 		ADD_ANNOTATION(annot)
; 8217 : 	    }
; 8218 : 	    break;
; 8219 : 	case XML_SCHEMA_TYPE_SEQUENCE:
; 8220 : 	case XML_SCHEMA_TYPE_CHOICE:
; 8221 : 	case XML_SCHEMA_TYPE_ALL: {
; 8222 : 		xmlSchemaModelGroupPtr item = (xmlSchemaModelGroupPtr) annItem;
; 8223 : 		ADD_ANNOTATION(annot)
; 8224 : 	    }
; 8225 : 	    break;
; 8226 : 	default:
; 8227 : 	     xmlSchemaPCustomErr(NULL,
; 8228 : 		XML_SCHEMAP_INTERNAL,
; 8229 : 		NULL, NULL,
; 8230 : 		"Internal error: xmlSchemaAddAnnotation, "
; 8231 : 		"The item is not a annotated schema component", NULL);
; 8232 : 	     break;
; 8233 :     }
; 8234 :     return (annot);

	mov	eax, esi
	pop	esi

; 8235 : }

	pop	ebp
	ret	0
$LN5@xmlSchemaA:

; 8155 : 	return (NULL);

	xor	eax, eax
	pop	esi

; 8235 : }

	pop	ebp
	ret	0
$LN52@xmlSchemaA:
	DD	$LN12@xmlSchemaA
	DD	$LN6@xmlSchemaA
	DD	$LN15@xmlSchemaA
	DD	$LN9@xmlSchemaA
	DD	$LN38@xmlSchemaA
$LN49@xmlSchemaA:
	DB	0
	DB	4
	DB	1
	DB	1
	DB	2
	DB	2
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	3
	DB	1
	DB	2
	DB	0
	DB	4
	DB	4
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
_xmlSchemaAddAnnotation ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckCSelectorXPath
_TEXT	SEGMENT
tv532 = -8						; size = 4
_node$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_idc$ = 12						; size = 4
_selector$ = 16						; size = 4
_attr$ = 20						; size = 4
_isField$ = 24						; size = 4
_xmlSchemaCheckCSelectorXPath PROC			; COMDAT

; 8037 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _selector$[ebp]
	test	esi, esi
	jne	SHORT $LN8@xmlSchemaC

; 8038 :     xmlNodePtr node;
; 8039 : 
; 8040 :     /*
; 8041 :     * c-selector-xpath:
; 8042 :     * Schema Component Constraint: Selector Value OK
; 8043 :     *
; 8044 :     * TODO: 1 The {selector} must be a valid XPath expression, as defined
; 8045 :     * in [XPath].
; 8046 :     */
; 8047 :     if (selector == NULL) {
; 8048 : 	xmlSchemaPErr(ctxt, idc->node,

	mov	eax, DWORD PTR _idc$[ebp]

; 1905 :     xmlGenericErrorFunc channel = NULL;

	xor	ecx, ecx

; 1906 :     xmlStructuredErrorFunc schannel = NULL;

	xor	edx, edx

; 8038 :     xmlNodePtr node;
; 8039 : 
; 8040 :     /*
; 8041 :     * c-selector-xpath:
; 8042 :     * Schema Component Constraint: Selector Value OK
; 8043 :     *
; 8044 :     * TODO: 1 The {selector} must be a valid XPath expression, as defined
; 8045 :     * in [XPath].
; 8046 :     */
; 8047 :     if (selector == NULL) {
; 8048 : 	xmlSchemaPErr(ctxt, idc->node,

	mov	edi, DWORD PTR [eax+12]

; 1909 :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN23@xmlSchemaC

; 1910 :         ctxt->nberrors++;

	inc	DWORD PTR [eax+20]

; 1911 : 	ctxt->err = error;
; 1912 :         channel = ctxt->error;

	mov	ecx, DWORD PTR [eax+8]

; 1913 :         data = ctxt->errCtxt;

	mov	esi, DWORD PTR [eax+4]

; 1914 : 	schannel = ctxt->serror;

	mov	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+16], 3069		; 00000bfdH
$LN23@xmlSchemaC:

; 1915 :     }
; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	push	0
	push	0
	push	OFFSET ??_C@_0EO@EIAADIEO@Internal?5error?3?5xmlSchemaCheckC@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	3069					; 00000bfdH
	push	16					; 00000010H
	push	edi
	push	eax
	push	esi
	push	ecx
	push	edx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 8049 : 	    XML_SCHEMAP_INTERNAL,
; 8050 : 	    "Internal error: xmlSchemaCheckCSelectorXPath, "
; 8051 : 	    "the selector is not specified.\n", NULL, NULL);
; 8052 : 	return (-1);

	or	eax, -1
	pop	edi

; 8127 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlSchemaC:

; 8053 :     }
; 8054 :     if (attr == NULL)

	mov	ecx, DWORD PTR _attr$[ebp]
	test	ecx, ecx
	jne	SHORT $LN9@xmlSchemaC

; 8055 : 	node = idc->node;

	mov	eax, DWORD PTR _idc$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _node$1$[ebp], eax
	jmp	SHORT $LN10@xmlSchemaC
$LN9@xmlSchemaC:

; 8056 :     else
; 8057 : 	node = (xmlNodePtr) attr;

	mov	eax, ecx
	mov	DWORD PTR _node$1$[ebp], ecx
$LN10@xmlSchemaC:

; 8058 :     if (selector->xpath == NULL) {

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN11@xmlSchemaC

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0DC@LABDBLHI@The?5XPath?5expression?5of?5the?5sel@
	push	eax
	push	0
	push	3037					; 00000bddH
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 8059 : 	xmlSchemaPCustomErr(ctxt,
; 8060 : 	    /* TODO: Adjust error code. */
; 8061 : 	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 8062 : 	    NULL, node,
; 8063 : 	    "The XPath expression of the selector is not valid", NULL);
; 8064 : 	return (XML_SCHEMAP_S4S_ATTR_INVALID_VALUE);

	mov	eax, 3037				; 00000bddH
	pop	edi

; 8127 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlSchemaC:

; 8065 :     } else {
; 8066 : 	const xmlChar **nsArray = NULL;

	xor	edi, edi
	push	ebx

; 8067 : 	xmlNsPtr *nsList = NULL;
; 8068 : 	/*
; 8069 : 	* Compile the XPath expression.
; 8070 : 	*/
; 8071 : 	/*
; 8072 : 	* TODO: We need the array of in-scope namespaces for compilation.
; 8073 : 	* TODO: Call xmlPatterncompile with different options for selector/
; 8074 : 	* field.
; 8075 : 	*/
; 8076 : 	if (attr == NULL)

	test	ecx, ecx
	je	$LN15@xmlSchemaC

; 8077 : 	    nsList = NULL;
; 8078 : 	else
; 8079 : 	    nsList = xmlGetNsList(attr->doc, attr->parent);

	push	DWORD PTR [ecx+20]
	push	DWORD PTR [ecx+32]
	call	_xmlGetNsList
	mov	ebx, eax
	add	esp, 8

; 8080 : 	/*
; 8081 : 	* Build an array of prefixes and namespaces.
; 8082 : 	*/
; 8083 : 	if (nsList != NULL) {

	test	ebx, ebx
	je	$LN15@xmlSchemaC

; 8084 : 	    int i, count = 0;

	xor	esi, esi

; 8085 : 
; 8086 : 	    for (i = 0; nsList[i] != NULL; i++)

	cmp	DWORD PTR [ebx], esi
	je	SHORT $LN3@xmlSchemaC
$LL4@xmlSchemaC:
	lea	eax, DWORD PTR [eax+4]

; 8087 : 		count++;

	inc	esi
	cmp	DWORD PTR [eax], edi
	jne	SHORT $LL4@xmlSchemaC
$LN3@xmlSchemaC:

; 8088 : 
; 8089 : 	    nsArray = (const xmlChar **) xmlMalloc(

	lea	eax, DWORD PTR [esi*8]
	mov	DWORD PTR tv532[ebp], eax
	add	eax, 4
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 8090 : 		(count * 2 + 1) * sizeof(const xmlChar *));
; 8091 : 	    if (nsArray == NULL) {

	test	edi, edi
	jne	SHORT $LN16@xmlSchemaC

; 1884 :     if (ctxt != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN28@xmlSchemaC

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [eax+20]
$LN28@xmlSchemaC:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BN@LCFJGAGM@allocating?5a?5namespace?5array@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError

; 8092 : 		xmlSchemaPErrMemory(ctxt, "allocating a namespace array",
; 8093 : 		    NULL);
; 8094 : 		xmlFree(nsList);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 24					; 00000018H

; 8095 : 		return (-1);

	or	eax, -1
	pop	ebx
	pop	edi

; 8127 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlSchemaC:

; 8096 : 	    }
; 8097 : 	    for (i = 0; i < count; i++) {

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN6@xmlSchemaC
	npad	3
$LL7@xmlSchemaC:

; 8098 : 		nsArray[2 * i] = nsList[i]->href;

	mov	eax, DWORD PTR [ebx+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edi+ecx*8], eax

; 8099 : 		nsArray[2 * i + 1] = nsList[i]->prefix;

	mov	eax, DWORD PTR [ebx+ecx*4]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edi+ecx*8+4], eax
	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LL7@xmlSchemaC
$LN6@xmlSchemaC:

; 8100 : 	    }
; 8101 : 	    nsArray[count * 2] = NULL;

	mov	eax, DWORD PTR tv532[ebp]

; 8102 : 	    xmlFree(nsList);

	push	ebx
	mov	DWORD PTR [eax+edi], 0
	call	DWORD PTR _xmlFree
	mov	esi, DWORD PTR _selector$[ebp]
	add	esp, 4
$LN15@xmlSchemaC:

; 8103 : 	}
; 8104 : 	/*
; 8105 : 	* TODO: Differentiate between "selector" and "field".
; 8106 : 	*/
; 8107 : 	if (isField)
; 8108 : 	    selector->xpathComp = (void *) xmlPatterncompile(selector->xpath,
; 8109 : 		NULL, XML_PATTERN_XSFIELD, nsArray);
; 8110 : 	else
; 8111 : 	    selector->xpathComp = (void *) xmlPatterncompile(selector->xpath,
; 8112 : 		NULL, XML_PATTERN_XSSEL, nsArray);
; 8113 : 	if (nsArray != NULL)

	xor	eax, eax
	cmp	DWORD PTR _isField$[ebp], eax
	push	edi
	setne	al
	lea	eax, DWORD PTR [eax*2+2]
	push	eax
	push	0
	push	DWORD PTR [esi+12]
	call	_xmlPatterncompile
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+16], eax
	test	edi, edi
	je	SHORT $LN19@xmlSchemaC

; 8114 : 	    xmlFree((xmlChar **) nsArray);

	push	edi
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [esi+16]
	add	esp, 4
$LN19@xmlSchemaC:

; 8115 : 
; 8116 : 	if (selector->xpathComp == NULL) {

	test	eax, eax
	jne	SHORT $LN20@xmlSchemaC

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	eax
	push	eax
	push	DWORD PTR [esi+12]
	push	OFFSET ??_C@_0DA@MEAKINLE@The?5XPath?5expression?5?8?$CFs?8?5could@
	push	DWORD PTR _node$1$[ebp]
	push	eax
	push	3037					; 00000bddH
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 8117 : 	    xmlSchemaPCustomErr(ctxt,
; 8118 : 		/* TODO: Adjust error code? */
; 8119 : 		XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 8120 : 		NULL, node,
; 8121 : 		"The XPath expression '%s' could not be "
; 8122 : 		"compiled", selector->xpath);
; 8123 : 	    return (XML_SCHEMAP_S4S_ATTR_INVALID_VALUE);

	mov	eax, 3037				; 00000bddH
	pop	ebx
	pop	edi

; 8127 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlSchemaC:
	pop	ebx
	pop	edi

; 8124 : 	}
; 8125 :     }
; 8126 :     return (0);

	xor	eax, eax

; 8127 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCheckCSelectorXPath ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPValAttrBlockFinal
_TEXT	SEGMENT
_ret$1$ = -4						; size = 4
_value$ = 8						; size = 4
_flags$ = 12						; size = 4
_flagAll$ = 16						; size = 4
_flagExtension$ = 20					; size = 4
_flagRestriction$ = 24					; size = 4
_flagSubstitution$ = 28					; size = 4
_flagList$ = 32						; size = 4
_flagUnion$ = 36					; size = 4
_xmlSchemaPValAttrBlockFinal PROC			; COMDAT

; 7952 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR _ret$1$[ebp], 0
	test	ebx, ebx
	je	$LN10@xmlSchemaP

; 7953 :     int ret = 0;
; 7954 : 
; 7955 :     /*
; 7956 :     * TODO: This does not check for dublicate entries.
; 7957 :     */
; 7958 :     if ((flags == NULL) || (value == NULL))

	mov	esi, DWORD PTR _value$[ebp]
	test	esi, esi
	je	$LN10@xmlSchemaP

; 7960 :     if (value[0] == 0)

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN11@xmlSchemaP

; 7961 : 	return (0);

	pop	esi
	xor	eax, eax

; 8029 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlSchemaP:

; 7962 :     if (xmlStrEqual(value, BAD_CAST "#all")) {

	push	OFFSET ??_C@_04LEKDNLLP@?$CDall@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN76@xmlSchemaP

; 7963 : 	if (flagAll != -1)

	mov	eax, DWORD PTR _flagAll$[ebp]
	cmp	eax, -1
	jne	SHORT $LN82@xmlSchemaP

; 7964 : 	    *flags |= flagAll;
; 7965 : 	else {
; 7966 : 	    if (flagExtension != -1)

	mov	eax, DWORD PTR _flagExtension$[ebp]
	cmp	eax, -1
	je	SHORT $LN69@xmlSchemaP

; 7967 : 		*flags |= flagExtension;

	or	DWORD PTR [ebx], eax
$LN69@xmlSchemaP:

; 7968 : 	    if (flagRestriction != -1)

	mov	eax, DWORD PTR _flagRestriction$[ebp]
	cmp	eax, -1
	je	SHORT $LN70@xmlSchemaP

; 7969 : 		*flags |= flagRestriction;

	or	DWORD PTR [ebx], eax
$LN70@xmlSchemaP:

; 7970 : 	    if (flagSubstitution != -1)

	mov	eax, DWORD PTR _flagSubstitution$[ebp]
	cmp	eax, -1
	je	SHORT $LN71@xmlSchemaP

; 7971 : 		*flags |= flagSubstitution;

	or	DWORD PTR [ebx], eax
$LN71@xmlSchemaP:

; 7972 : 	    if (flagList != -1)

	mov	eax, DWORD PTR _flagList$[ebp]
	cmp	eax, -1
	je	SHORT $LN72@xmlSchemaP

; 7973 : 		*flags |= flagList;

	or	DWORD PTR [ebx], eax
$LN72@xmlSchemaP:

; 7974 : 	    if (flagUnion != -1)

	mov	eax, DWORD PTR _flagUnion$[ebp]
	cmp	eax, -1
	je	$LN3@xmlSchemaP
$LN82@xmlSchemaP:

; 8026 :     }
; 8027 : 
; 8028 :     return (ret);

	or	DWORD PTR [ebx], eax
	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	esi

; 8029 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN76@xmlSchemaP:
	push	edi
$LL5@xmlSchemaP:

; 7975 : 		*flags |= flagUnion;
; 7976 : 	}
; 7977 :     } else {
; 7978 : 	const xmlChar *end, *cur = value;
; 7979 : 	xmlChar *item;
; 7980 : 
; 7981 : 	do {
; 7982 : 	    while (IS_BLANK_CH(*cur))

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN21@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN22@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN21@xmlSchemaP
$LN22@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN6@xmlSchemaP
$LN21@xmlSchemaP:

; 7983 : 		cur++;

	inc	esi
	jmp	SHORT $LL5@xmlSchemaP
$LN6@xmlSchemaP:

; 7984 : 	    end = cur;

	mov	edi, esi

; 7985 : 	    while ((*end != 0) && (!(IS_BLANK_CH(*end))))

	test	al, al
	je	$LN79@xmlSchemaP
$LL7@xmlSchemaP:
	cmp	al, 32					; 00000020H
	je	SHORT $LN8@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN23@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN8@xmlSchemaP
$LN23@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN8@xmlSchemaP
	mov	al, BYTE PTR [edi+1]

; 7986 : 		end++;

	inc	edi
	test	al, al
	jne	SHORT $LL7@xmlSchemaP
$LN8@xmlSchemaP:

; 7987 : 	    if (end == cur)

	cmp	edi, esi
	je	$LN79@xmlSchemaP

; 7988 : 		break;
; 7989 : 	    item = xmlStrndup(cur, end - cur);

	mov	eax, edi
	sub	eax, esi
	push	eax
	push	esi
	call	_xmlStrndup
	mov	esi, eax

; 7990 : 	    if (xmlStrEqual(item, BAD_CAST "extension")) {

	push	OFFSET ??_C@_09ODADEDNA@extension@
	push	esi
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN25@xmlSchemaP

; 7991 : 		if (flagExtension != -1) {

	mov	ecx, DWORD PTR _flagExtension$[ebp]

; 7992 : 		    if ((*flags & flagExtension) == 0)
; 7993 : 			*flags |= flagExtension;
; 7994 : 		} else
; 7995 : 		    ret = 1;
; 7996 : 	    } else if (xmlStrEqual(item, BAD_CAST "restriction")) {

	jmp	SHORT $LN81@xmlSchemaP
$LN25@xmlSchemaP:
	push	OFFSET ??_C@_0M@FBFLGGFO@restriction@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN30@xmlSchemaP

; 7997 : 		if (flagRestriction != -1) {

	mov	ecx, DWORD PTR _flagRestriction$[ebp]

; 7998 : 		    if ((*flags & flagRestriction) == 0)
; 7999 : 			*flags |= flagRestriction;
; 8000 : 		} else
; 8001 : 		    ret = 1;
; 8002 : 	    } else if (xmlStrEqual(item, BAD_CAST "substitution")) {

	jmp	SHORT $LN81@xmlSchemaP
$LN30@xmlSchemaP:
	push	OFFSET ??_C@_0N@INDADLAA@substitution@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN35@xmlSchemaP

; 8003 : 		if (flagSubstitution != -1) {

	mov	ecx, DWORD PTR _flagSubstitution$[ebp]

; 8004 : 		    if ((*flags & flagSubstitution) == 0)
; 8005 : 			*flags |= flagSubstitution;
; 8006 : 		} else
; 8007 : 		    ret = 1;
; 8008 : 	    } else if (xmlStrEqual(item, BAD_CAST "list")) {

	jmp	SHORT $LN81@xmlSchemaP
$LN35@xmlSchemaP:
	push	OFFSET ??_C@_04DONFEANM@list@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN40@xmlSchemaP

; 8009 : 		if (flagList != -1) {

	mov	ecx, DWORD PTR _flagList$[ebp]

; 8010 : 		    if ((*flags & flagList) == 0)
; 8011 : 			*flags |= flagList;
; 8012 : 		} else
; 8013 : 		    ret = 1;
; 8014 : 	    } else if (xmlStrEqual(item, BAD_CAST "union")) {

	jmp	SHORT $LN81@xmlSchemaP
$LN40@xmlSchemaP:
	push	OFFSET ??_C@_05MNALHJLP@union@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN45@xmlSchemaP

; 8015 : 		if (flagUnion != -1) {

	mov	ecx, DWORD PTR _flagUnion$[ebp]
$LN81@xmlSchemaP:

; 8016 : 		    if ((*flags & flagUnion) == 0)
; 8017 : 			*flags |= flagUnion;
; 8018 : 		} else
; 8019 : 		    ret = 1;
; 8020 : 	    } else
; 8021 : 		ret = 1;
; 8022 : 	    if (item != NULL)

	cmp	ecx, -1
	je	SHORT $LN45@xmlSchemaP
	mov	eax, DWORD PTR [ebx]
	test	eax, ecx
	jne	SHORT $LN46@xmlSchemaP
	or	eax, ecx
	mov	DWORD PTR [ebx], eax
	jmp	SHORT $LN46@xmlSchemaP
$LN45@xmlSchemaP:
	mov	DWORD PTR _ret$1$[ebp], 1
$LN46@xmlSchemaP:
	test	esi, esi
	je	SHORT $LN50@xmlSchemaP

; 8023 : 		xmlFree(item);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN50@xmlSchemaP:

; 8024 : 	    cur = end;
; 8025 : 	} while ((ret == 0) && (*cur != 0));

	cmp	DWORD PTR _ret$1$[ebp], 0
	mov	esi, edi
	jne	SHORT $LN79@xmlSchemaP
	cmp	BYTE PTR [edi], 0
	jne	$LL5@xmlSchemaP
$LN79@xmlSchemaP:
	pop	edi
$LN3@xmlSchemaP:

; 8026 :     }
; 8027 : 
; 8028 :     return (ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	esi

; 8029 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlSchemaP:
	pop	esi

; 7959 : 	return (-1);

	or	eax, -1

; 8029 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaPValAttrBlockFinal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPValAttrFormDefault
_TEXT	SEGMENT
_value$ = 8						; size = 4
_flags$ = 12						; size = 4
_flagQualified$ = 16					; size = 4
_xmlSchemaPValAttrFormDefault PROC			; COMDAT

; 7916 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	OFFSET ??_C@_09NPLHLKJP@qualified@
	push	DWORD PTR _value$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@xmlSchemaP

; 7917 :     if (xmlStrEqual(value, BAD_CAST "qualified")) {
; 7918 : 	if  ((*flags & flagQualified) == 0)

	mov	ecx, DWORD PTR _flags$[ebp]
	mov	edx, DWORD PTR _flagQualified$[ebp]
	mov	eax, DWORD PTR [ecx]
	test	eax, edx
	jne	SHORT $LN5@xmlSchemaP

; 7919 : 	    *flags |= flagQualified;

	or	eax, edx
	mov	DWORD PTR [ecx], eax
$LN5@xmlSchemaP:

; 7922 : 
; 7923 :     return (0);

	xor	eax, eax

; 7924 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaP:

; 7920 :     } else if (!xmlStrEqual(value, BAD_CAST "unqualified"))

	push	OFFSET ??_C@_0M@PJKDFPFM@unqualified@
	push	DWORD PTR _value$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@xmlSchemaP

; 7921 : 	return (1);

	mov	eax, 1

; 7924 : }

	pop	ebp
	ret	0
_xmlSchemaPValAttrFormDefault ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseAttributeGroupDefinition
_TEXT	SEGMENT
_nsName$1$ = -8						; size = 4
_type$1$ = -8						; size = 4
_hasRefs$ = -4						; size = 4
_val$1$ = 8						; size = 4
_des$1 = 8						; size = 4
_des$2 = 8						; size = 4
_child$ = 8						; size = 4
_pctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaParseAttributeGroupDefinition PROC		; COMDAT

; 7821 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pctxt$[ebp]
	mov	DWORD PTR _hasRefs$[ebp], 0
	test	edi, edi
	je	$LN5@xmlSchemaP

; 7822 :     const xmlChar *name;
; 7823 :     xmlSchemaAttributeGroupPtr ret;
; 7824 :     xmlNodePtr child = NULL;
; 7825 :     xmlAttrPtr attr;
; 7826 :     int hasRefs = 0;
; 7827 : 
; 7828 :     if ((pctxt == NULL) || (schema == NULL) || (node == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	SHORT $LN5@xmlSchemaP
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlSchemaP

; 7830 : 
; 7831 :     attr = xmlSchemaGetPropNode(node, "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	esi
	call	_xmlSchemaGetPropNode
	mov	ebx, eax
	add	esp, 8

; 7832 :     if (attr == NULL) {

	test	ebx, ebx
	jne	SHORT $LN6@xmlSchemaP

; 2802 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	esi
	push	eax
	push	eax
	mov	DWORD PTR _des$2[ebp], eax
	lea	eax, DWORD PTR _des$2[ebp]
	push	eax
	call	_xmlSchemaFormatItemForReport

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	mov	eax, DWORD PTR _des$2[ebp]
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	push	OFFSET ??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@
	push	ebx
	push	ebx
	push	ebx
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	inc	DWORD PTR [edi+20]
	push	ebx
	push	ebx
	push	2
	push	3036					; 00000bdcH
	push	16					; 00000010H
	push	esi
	push	edi
	push	DWORD PTR [edi+4]
	mov	DWORD PTR [edi+16], 3036		; 00000bdcH
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+24]
	call	___xmlRaiseError

; 2810 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$2[ebp]

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 88					; 00000058H

; 2810 :     FREE_AND_NULL(des);

	test	eax, eax
	je	SHORT $LN5@xmlSchemaP
	push	eax

; 7829 :         return (NULL);

	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlSchemaP:

; 7896 : 	xmlSchemaPContentErr(pctxt,
; 7897 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 7898 : 	    NULL, node, child, NULL,
; 7899 : 	    "(annotation?, ((attribute | attributeGroup)*, anyAttribute?))");
; 7900 :     }
; 7901 :     return (ret);
; 7902 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlSchemaP:

; 7833 : 	xmlSchemaPMissingAttrErr(pctxt,
; 7834 : 	    XML_SCHEMAP_S4S_ATTR_MISSING,
; 7835 : 	    NULL, node, "name", NULL);
; 7836 : 	return (NULL);
; 7837 :     }
; 7838 :     /*
; 7839 :     * The name is crucial, exit if invalid.
; 7840 :     */
; 7841 :     if (xmlSchemaPValAttrNode(pctxt,
; 7842 : 	NULL, attr,
; 7843 : 	xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {

	push	22					; 00000016H
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	mov	DWORD PTR _type$1$[ebp], eax

; 6385 :     if ((ctxt == NULL) || (type == NULL) || (attr == NULL))

	test	eax, eax
	je	SHORT $LN5@xmlSchemaP

; 6386 : 	return (-1);
; 6387 : 
; 6388 :     val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	push	ebx
	push	edi
	call	_xmlSchemaGetNodeContent

; 6389 :     if (value != NULL)
; 6390 : 	*value = val;
; 6391 : 
; 6392 :     return (xmlSchemaPValAttrNodeValue(ctxt, ownerItem, attr,

	push	DWORD PTR _type$1$[ebp]
	mov	DWORD PTR _val$1$[ebp], eax
	push	eax
	push	ebx
	push	0
	push	edi
	call	_xmlSchemaPValAttrNodeValue
	add	esp, 28					; 0000001cH

; 7833 : 	xmlSchemaPMissingAttrErr(pctxt,
; 7834 : 	    XML_SCHEMAP_S4S_ATTR_MISSING,
; 7835 : 	    NULL, node, "name", NULL);
; 7836 : 	return (NULL);
; 7837 :     }
; 7838 :     /*
; 7839 :     * The name is crucial, exit if invalid.
; 7840 :     */
; 7841 :     if (xmlSchemaPValAttrNode(pctxt,
; 7842 : 	NULL, attr,
; 7843 : 	xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {

	test	eax, eax
	jne	SHORT $LN5@xmlSchemaP

; 5317 :     if ((pctxt == NULL) || (name == NULL))

	cmp	DWORD PTR _val$1$[ebp], 0

; 7844 : 	return (NULL);
; 7845 :     }
; 7846 :     ret = xmlSchemaAddAttributeGroupDefinition(pctxt, schema,

	mov	eax, DWORD PTR [edi+112]
	mov	DWORD PTR _nsName$1$[ebp], eax

; 5317 :     if ((pctxt == NULL) || (name == NULL))

	je	SHORT $LN5@xmlSchemaP

; 5318 :         return (NULL);
; 5319 : 
; 5320 :     ret = (xmlSchemaAttributeGroupPtr)

	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4

; 5321 :         xmlMalloc(sizeof(xmlSchemaAttributeGroup));
; 5322 :     if (ret == NULL) {

	test	ebx, ebx
	jne	SHORT $LN35@xmlSchemaP

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [edi+20]

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BL@LFEIBOLE@allocating?5attribute?5group@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 7829 :         return (NULL);

	xor	eax, eax
	pop	edi

; 7896 : 	xmlSchemaPContentErr(pctxt,
; 7897 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 7898 : 	    NULL, node, child, NULL,
; 7899 : 	    "(annotation?, ((attribute | attributeGroup)*, anyAttribute?))");
; 7900 :     }
; 7901 :     return (ret);
; 7902 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@xmlSchemaP:

; 5329 :     ret->targetNamespace = nsName;

	mov	ecx, DWORD PTR _nsName$1$[ebp]
	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+12], 0
	mov	DWORD PTR [ebx+16], 0
	mov	DWORD PTR [ebx+20], 0
	mov	DWORD PTR [ebx+24], 0
	mov	DWORD PTR [ebx+28], 0
	mov	DWORD PTR [ebx+36], 0
	mov	DWORD PTR [ebx+40], 0
	mov	DWORD PTR [ebx+44], 0
	mov	DWORD PTR [ebx+48], 0
	mov	DWORD PTR [ebx+56], 0
	mov	eax, DWORD PTR _val$1$[ebp]

; 5330 :     ret->node = node;
; 5331 : 
; 5332 :     /* TODO: Remove the flag. */
; 5333 :     ret->flags |= XML_SCHEMAS_ATTRGROUP_GLOBAL;

	or	DWORD PTR [ebx+36], 2
	mov	DWORD PTR [ebx], 16			; 00000010H
	mov	DWORD PTR [ebx+8], eax
	mov	DWORD PTR [ebx+52], ecx
	mov	DWORD PTR [ebx+32], esi

; 5334 :     if (pctxt->isRedefine) {

	cmp	DWORD PTR [edi+100], 0
	je	SHORT $LN36@xmlSchemaP

; 5335 : 	pctxt->redef = xmlSchemaAddRedef(pctxt, pctxt->redefined,

	push	ecx
	push	eax
	push	ebx
	push	DWORD PTR [edi+116]
	push	edi
	call	_xmlSchemaAddRedef
	add	esp, 20					; 00000014H
	mov	DWORD PTR [edi+120], eax

; 5336 : 	    ret, name, nsName);
; 5337 : 	if (pctxt->redef == NULL) {

	test	eax, eax
	jne	SHORT $LN37@xmlSchemaP

; 5338 : 	    xmlFree(ret);

	push	ebx

; 7829 :         return (NULL);

	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	edi

; 7896 : 	xmlSchemaPContentErr(pctxt,
; 7897 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 7898 : 	    NULL, node, child, NULL,
; 7899 : 	    "(annotation?, ((attribute | attributeGroup)*, anyAttribute?))");
; 7900 :     }
; 7901 :     return (ret);
; 7902 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@xmlSchemaP:

; 5341 : 	pctxt->redefCounter = 0;

	mov	DWORD PTR [edi+124], 0
$LN36@xmlSchemaP:

; 5342 :     }
; 5343 :     WXS_ADD_GLOBAL(pctxt, ret);

	mov	eax, DWORD PTR [edi+28]
	push	ebx
	push	5
	mov	eax, DWORD PTR [eax+16]
	add	eax, 44					; 0000002cH
	push	eax
	call	_xmlSchemaAddItemSize

; 5344 :     WXS_ADD_PENDING(pctxt, ret);

	mov	eax, DWORD PTR [edi+28]
	push	ebx
	add	eax, 20					; 00000014H
	push	10					; 0000000aH
	push	eax
	call	_xmlSchemaAddItemSize

; 7847 : 	name, pctxt->targetNamespace, node);
; 7848 :     if (ret == NULL)
; 7849 : 	return (NULL);
; 7850 :     /*
; 7851 :     * Check for illegal attributes.
; 7852 :     */
; 7853 :     attr = node->properties;

	mov	esi, DWORD PTR [esi+44]

; 5344 :     WXS_ADD_PENDING(pctxt, ret);

	add	esp, 24					; 00000018H

; 7854 :     while (attr != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlSchemaP
$LL2@xmlSchemaP:

; 7855 : 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP

; 7856 : 	    if ((!xmlStrEqual(attr->name, BAD_CAST "name")) &&

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlSchemaP
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlSchemaP

; 7857 : 		(!xmlStrEqual(attr->name, BAD_CAST "id")))
; 7858 : 	    {
; 7859 : 		xmlSchemaPIllegalAttrErr(pctxt,
; 7860 : 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 7861 : 	    }

	jmp	SHORT $LN73@xmlSchemaP
$LN9@xmlSchemaP:

; 7862 : 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlSchemaP
$LN73@xmlSchemaP:

; 7863 : 	    xmlSchemaPIllegalAttrErr(pctxt,
; 7864 : 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 7865 : 	}
; 7866 : 	attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN12@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaP
$LN3@xmlSchemaP:

; 7867 :     }
; 7868 :     /* Attribute ID */
; 7869 :     xmlSchemaPValAttrID(pctxt, node, BAD_CAST "id");

	mov	esi, DWORD PTR _node$[ebp]
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	esi
	push	edi
	call	_xmlSchemaPValAttrID

; 7870 :     /*
; 7871 :     * And now for the children...
; 7872 :     */
; 7873 :     child = node->children;

	mov	esi, DWORD PTR [esi+12]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _child$[ebp], esi
	test	esi, esi

; 7874 :     if (IS_SCHEMA(child, "annotation")) {

	je	SHORT $LN13@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN13@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlSchemaP

; 7875 :         ret->annot = xmlSchemaParseAnnotation(pctxt, child, 1);

	push	1
	push	esi
	push	edi
	call	_xmlSchemaParseAnnotation
	mov	DWORD PTR [ebx+24], eax
	add	esp, 12					; 0000000cH

; 7876 :         child = child->next;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _child$[ebp], eax
$LN13@xmlSchemaP:

; 7877 :     }
; 7878 :     /*
; 7879 :     * Parse contained attribute decls/refs.
; 7880 :     */
; 7881 :     if (xmlSchemaParseLocalAttributes(pctxt, schema, &child,
; 7882 : 	(xmlSchemaItemListPtr *) &(ret->attrUses),
; 7883 : 	XML_SCHEMA_TYPE_ATTRIBUTEGROUP, &hasRefs) == -1)

	lea	eax, DWORD PTR _hasRefs$[ebp]
	push	eax
	push	16					; 00000010H
	lea	eax, DWORD PTR [ebx+56]
	push	eax
	lea	eax, DWORD PTR _child$[ebp]
	push	eax
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaParseLocalAttributes
	add	esp, 24					; 00000018H
	cmp	eax, -1
	je	$LN5@xmlSchemaP

; 7884 : 	return(NULL);
; 7885 :     if (hasRefs)

	cmp	DWORD PTR _hasRefs$[ebp], 0
	je	SHORT $LN15@xmlSchemaP

; 7886 : 	ret->flags |= XML_SCHEMAS_ATTRGROUP_HAS_REFS;

	or	DWORD PTR [ebx+36], 16			; 00000010H
$LN15@xmlSchemaP:

; 7887 :     /*
; 7888 :     * Parse the attribute wildcard.
; 7889 :     */
; 7890 :     if (IS_SCHEMA(child, "anyAttribute")) {

	mov	esi, DWORD PTR _child$[ebp]
	test	esi, esi
	je	$LN47@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN16@xmlSchemaP
	push	OFFSET ??_C@_0N@DDKCLMJG@anyAttribute@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlSchemaP

; 7891 : 	ret->attributeWildcard = xmlSchemaParseAnyAttribute(pctxt,

	push	esi
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaParseAnyAttribute
	mov	DWORD PTR [ebx+40], eax
	add	esp, 12					; 0000000cH

; 7892 : 	    schema, child);
; 7893 : 	child = child->next;

	mov	esi, DWORD PTR [esi+24]
$LN16@xmlSchemaP:

; 7894 :     }
; 7895 :     if (child != NULL) {

	test	esi, esi
	je	SHORT $LN47@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0DO@PEEJHPPG@?$CIannotation?$DP?0?5?$CI?$CIattribute?5?$HM?5att@
	push	DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	edi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN47@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN47@xmlSchemaP:
	pop	edi

; 7896 : 	xmlSchemaPContentErr(pctxt,
; 7897 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 7898 : 	    NULL, node, child, NULL,
; 7899 : 	    "(annotation?, ((attribute | attributeGroup)*, anyAttribute?))");
; 7900 :     }
; 7901 :     return (ret);
; 7902 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseAttributeGroupDefinition ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseGlobalAttribute
_TEXT	SEGMENT
_type$1$ = -4						; size = 4
_val$1$ = 8						; size = 4
_des$1 = 8						; size = 4
_des$2 = 8						; size = 4
_pctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaParseGlobalAttribute PROC			; COMDAT

; 7537 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pctxt$[ebp]
	test	edi, edi
	je	$LN5@xmlSchemaP

; 7538 :     const xmlChar *attrValue;
; 7539 :     xmlSchemaAttributePtr ret;
; 7540 :     xmlNodePtr child = NULL;
; 7541 :     xmlAttrPtr attr;
; 7542 : 
; 7543 :     /*
; 7544 :      * Note that the w3c spec assumes the schema to be validated with schema
; 7545 :      * for schemas beforehand.
; 7546 :      *
; 7547 :      * 3.2.3 Constraints on XML Representations of Attribute Declarations
; 7548 :      */
; 7549 :     if ((pctxt == NULL) || (schema == NULL) || (node == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	SHORT $LN5@xmlSchemaP
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlSchemaP

; 7550 :         return (NULL);
; 7551 :     /*
; 7552 :     * 3.2.3 : 3.1
; 7553 :     * One of ref or name must be present, but not both
; 7554 :     */
; 7555 :     attr = xmlSchemaGetPropNode(node, "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	esi
	call	_xmlSchemaGetPropNode
	mov	ebx, eax
	add	esp, 8

; 7556 :     if (attr == NULL) {

	test	ebx, ebx
	jne	SHORT $LN6@xmlSchemaP

; 2802 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	esi
	push	eax
	push	eax
	mov	DWORD PTR _des$2[ebp], eax
	lea	eax, DWORD PTR _des$2[ebp]
	push	eax
	call	_xmlSchemaFormatItemForReport

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	mov	eax, DWORD PTR _des$2[ebp]
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	push	OFFSET ??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@
	push	ebx
	push	ebx
	push	ebx
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	inc	DWORD PTR [edi+20]
	push	ebx
	push	ebx
	push	2
	push	3036					; 00000bdcH
	push	16					; 00000010H
	push	esi
	push	edi
	push	DWORD PTR [edi+4]
	mov	DWORD PTR [edi+16], 3036		; 00000bdcH
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+24]
	call	___xmlRaiseError

; 2810 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$2[ebp]

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 88					; 00000058H

; 2810 :     FREE_AND_NULL(des);

	test	eax, eax
	je	SHORT $LN5@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlSchemaP:
	pop	edi

; 7666 : 	xmlSchemaPContentErr(pctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 7667 : 	    NULL, node, child, NULL,
; 7668 : 	    "(annotation?, simpleType?)");
; 7669 : 
; 7670 :     return (ret);
; 7671 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlSchemaP:

; 7557 : 	xmlSchemaPMissingAttrErr(pctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
; 7558 : 	    NULL, node, "name", NULL);
; 7559 : 	return (NULL);
; 7560 :     }
; 7561 :     if (xmlSchemaPValAttrNode(pctxt, NULL, attr,
; 7562 : 	xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &attrValue) != 0) {

	push	22					; 00000016H
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	mov	DWORD PTR _type$1$[ebp], eax

; 6385 :     if ((ctxt == NULL) || (type == NULL) || (attr == NULL))

	test	eax, eax
	je	SHORT $LN5@xmlSchemaP

; 6386 : 	return (-1);
; 6387 : 
; 6388 :     val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	push	ebx
	push	edi
	call	_xmlSchemaGetNodeContent

; 6389 :     if (value != NULL)
; 6390 : 	*value = val;
; 6391 : 
; 6392 :     return (xmlSchemaPValAttrNodeValue(ctxt, ownerItem, attr,

	push	DWORD PTR _type$1$[ebp]
	mov	DWORD PTR _val$1$[ebp], eax
	push	eax
	push	ebx
	push	0
	push	edi
	call	_xmlSchemaPValAttrNodeValue
	add	esp, 28					; 0000001cH

; 7557 : 	xmlSchemaPMissingAttrErr(pctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
; 7558 : 	    NULL, node, "name", NULL);
; 7559 : 	return (NULL);
; 7560 :     }
; 7561 :     if (xmlSchemaPValAttrNode(pctxt, NULL, attr,
; 7562 : 	xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &attrValue) != 0) {

	test	eax, eax
	jne	SHORT $LN5@xmlSchemaP

; 7563 : 	return (NULL);
; 7564 :     }
; 7565 :     /*
; 7566 :     * 3.2.6 Schema Component Constraint: xmlns Not Allowed
; 7567 :     * TODO: Move this to the component layer.
; 7568 :     */
; 7569 :     if (xmlStrEqual(attrValue, BAD_CAST "xmlns")) {

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR _val$1$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlSchemaP

; 7570 : 	xmlSchemaPSimpleTypeErr(pctxt,

	push	0
	push	0
	push	OFFSET ??_C@_0DC@IMLKIPJD@The?5value?5of?5the?5attribute?5must@
	push	0
	push	0
	push	22					; 00000016H
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	push	eax
	push	ebx
	push	0
	push	3056					; 00000bf0H
	push	edi
	call	_xmlSchemaPSimpleTypeErr
	add	esp, 40					; 00000028H

; 7666 : 	xmlSchemaPContentErr(pctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 7667 : 	    NULL, node, child, NULL,
; 7668 : 	    "(annotation?, simpleType?)");
; 7669 : 
; 7670 :     return (ret);
; 7671 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlSchemaP:

; 7571 : 	    XML_SCHEMAP_NO_XMLNS,
; 7572 : 	    NULL, (xmlNodePtr) attr,
; 7573 : 	    xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), NULL, NULL,
; 7574 : 	    "The value of the attribute must not match 'xmlns'",
; 7575 : 	    NULL, NULL);
; 7576 : 	return (NULL);
; 7577 :     }
; 7578 :     /*
; 7579 :     * 3.2.6 Schema Component Constraint: xsi: Not Allowed
; 7580 :     * TODO: Move this to the component layer.
; 7581 :     *       Or better leave it here and add it to the component layer
; 7582 :     *       if we have a schema construction API.
; 7583 :     */
; 7584 :     if (xmlStrEqual(pctxt->targetNamespace, xmlSchemaInstanceNs)) {

	push	DWORD PTR _xmlSchemaInstanceNs
	push	DWORD PTR [edi+112]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlSchemaP

; 7585 : 	xmlSchemaCustomErr(ACTXT_CAST pctxt,

	push	0
	push	DWORD PTR _xmlSchemaInstanceNs
	push	OFFSET ??_C@_0CJ@KHJHCHGN@The?5target?5namespace?5must?5not?5m@
	push	0
	push	esi
	push	3057					; 00000bf1H
	push	edi
	call	_xmlSchemaCustomErr
	add	esp, 28					; 0000001cH
$LN9@xmlSchemaP:

; 7586 : 	    XML_SCHEMAP_NO_XSI, node, NULL,
; 7587 : 	    "The target namespace must not match '%s'",
; 7588 : 	    xmlSchemaInstanceNs, NULL);
; 7589 :     }
; 7590 : 
; 7591 :     ret = xmlSchemaAddAttribute(pctxt, schema, attrValue,

	push	1
	push	esi
	push	DWORD PTR [edi+112]
	push	DWORD PTR _val$1$[ebp]
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaAddAttribute
	mov	ebx, eax
	add	esp, 24					; 00000018H

; 7592 : 	pctxt->targetNamespace, node, 1);
; 7593 :     if (ret == NULL)

	test	ebx, ebx
	je	$LN5@xmlSchemaP

; 7594 : 	return (NULL);
; 7595 :     ret->flags |= XML_SCHEMAS_ATTR_GLOBAL;

	or	DWORD PTR [ebx+60], 1

; 7596 : 
; 7597 :     /*
; 7598 :     * Check for illegal attributes.
; 7599 :     */
; 7600 :     attr = node->properties;

	mov	esi, DWORD PTR [esi+44]

; 7601 :     while (attr != NULL) {

	test	esi, esi
	je	$LN3@xmlSchemaP
	npad	5
$LL2@xmlSchemaP:

; 7602 : 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN11@xmlSchemaP

; 7603 : 	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
; 7604 : 		(!xmlStrEqual(attr->name, BAD_CAST "default")) &&
; 7605 : 		(!xmlStrEqual(attr->name, BAD_CAST "fixed")) &&
; 7606 : 		(!xmlStrEqual(attr->name, BAD_CAST "name")) &&

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlSchemaP
	push	OFFSET ??_C@_07DLHCIBDH@default@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlSchemaP
	push	OFFSET ??_C@_05OFLEIIDM@fixed@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlSchemaP
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlSchemaP
	push	OFFSET ??_C@_04GPMDFGEJ@type@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlSchemaP

; 7607 : 		(!xmlStrEqual(attr->name, BAD_CAST "type")))
; 7608 : 	    {
; 7609 : 		xmlSchemaPIllegalAttrErr(pctxt,
; 7610 : 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 7611 : 	    }

	jmp	SHORT $LN70@xmlSchemaP
$LN11@xmlSchemaP:

; 7612 : 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlSchemaP
$LN70@xmlSchemaP:

; 7613 : 	    xmlSchemaPIllegalAttrErr(pctxt,
; 7614 : 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 7615 : 	}
; 7616 : 	attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN14@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	$LL2@xmlSchemaP
$LN3@xmlSchemaP:

; 7617 :     }
; 7618 :     xmlSchemaPValAttrQName(pctxt, schema, NULL,

	mov	esi, DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR [ebx+24]
	push	eax
	lea	eax, DWORD PTR [ebx+28]
	push	eax
	push	OFFSET ??_C@_04GPMDFGEJ@type@
	push	esi
	push	0
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaPValAttrQName

; 7619 : 	node, "type", &ret->typeNs, &ret->typeName);
; 7620 : 
; 7621 :     xmlSchemaPValAttrID(pctxt, node, BAD_CAST "id");

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	esi
	push	edi
	call	_xmlSchemaPValAttrID

; 7622 :     /*
; 7623 :     * Attribute "fixed".
; 7624 :     */
; 7625 :     ret->defValue = xmlSchemaGetProp(pctxt, node, "fixed");

	push	OFFSET ??_C@_05OFLEIIDM@fixed@
	push	esi
	push	edi
	call	_xmlSchemaGetProp
	add	esp, 52					; 00000034H
	mov	DWORD PTR [ebx+44], eax

; 7626 :     if (ret->defValue != NULL)

	test	eax, eax
	je	SHORT $LN69@xmlSchemaP

; 7627 : 	ret->flags |= XML_SCHEMAS_ATTR_FIXED;

	or	DWORD PTR [ebx+60], 512			; 00000200H
$LN69@xmlSchemaP:

; 7628 :     /*
; 7629 :     * Attribute "default".
; 7630 :     */
; 7631 :     attr = xmlSchemaGetPropNode(node, "default");

	push	OFFSET ??_C@_07DLHCIBDH@default@
	push	esi
	call	_xmlSchemaGetPropNode
	add	esp, 8

; 7632 :     if (attr != NULL) {

	test	eax, eax
	je	SHORT $LN18@xmlSchemaP

; 7633 : 	/*
; 7634 : 	* 3.2.3 : 1
; 7635 : 	* default and fixed must not both be present.
; 7636 : 	*/
; 7637 : 	if (ret->flags & XML_SCHEMAS_ATTR_FIXED) {

	test	DWORD PTR [ebx+60], 512			; 00000200H
	je	SHORT $LN17@xmlSchemaP

; 7638 : 	    xmlSchemaPMutualExclAttrErr(pctxt, XML_SCHEMAP_SRC_ATTRIBUTE_1,

	push	OFFSET ??_C@_05OFLEIIDM@fixed@
	push	OFFSET ??_C@_07DLHCIBDH@default@
	push	eax
	push	ebx
	push	3051					; 00000bebH
	push	edi
	call	_xmlSchemaPMutualExclAttrErr
	add	esp, 24					; 00000018H

; 7639 : 		WXS_BASIC_CAST ret, attr, "default", "fixed");
; 7640 : 	} else

	jmp	SHORT $LN18@xmlSchemaP
$LN17@xmlSchemaP:

; 7641 : 	    ret->defValue = xmlSchemaGetNodeContent(pctxt, (xmlNodePtr) attr);

	push	eax
	push	edi
	call	_xmlSchemaGetNodeContent
	add	esp, 8
	mov	DWORD PTR [ebx+44], eax
$LN18@xmlSchemaP:

; 7642 :     }
; 7643 :     /*
; 7644 :     * And now for the children...
; 7645 :     */
; 7646 :     child = node->children;

	mov	esi, DWORD PTR [esi+12]

; 7647 :     if (IS_SCHEMA(child, "annotation")) {

	test	esi, esi
	je	$LN43@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN19@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@xmlSchemaP

; 7648 :         ret->annot = xmlSchemaParseAnnotation(pctxt, child, 1);

	push	1
	push	esi
	push	edi
	call	_xmlSchemaParseAnnotation
	mov	DWORD PTR [ebx+32], eax
	add	esp, 12					; 0000000cH

; 7649 :         child = child->next;

	mov	esi, DWORD PTR [esi+24]
$LN19@xmlSchemaP:

; 7650 :     }
; 7651 :     if (IS_SCHEMA(child, "simpleType")) {

	test	esi, esi
	je	$LN43@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN20@xmlSchemaP
	push	OFFSET ??_C@_0L@FMMGGLOP@simpleType@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlSchemaP

; 7652 : 	if (ret->typeName != NULL) {

	cmp	DWORD PTR [ebx+24], 0
	push	0
	je	SHORT $LN21@xmlSchemaP

; 7653 : 	    /*
; 7654 : 	    * 3.2.3 : 4
; 7655 : 	    * type and <simpleType> must not both be present.
; 7656 : 	    */
; 7657 : 	    xmlSchemaPContentErr(pctxt, XML_SCHEMAP_SRC_ATTRIBUTE_4,

	push	OFFSET ??_C@_0EH@BAMMFMJA@The?5attribute?5?8type?8?5and?5the?5?$DMs@
	push	esi
	push	DWORD PTR _node$[ebp]
	push	0
	push	3055					; 00000befH
	push	edi
	call	_xmlSchemaPContentErr
	add	esp, 28					; 0000001cH

; 7658 : 		NULL, node, child,
; 7659 : 		"The attribute 'type' and the <simpleType> child "
; 7660 : 		"are mutually exclusive", NULL);
; 7661 : 	} else

	jmp	SHORT $LN22@xmlSchemaP
$LN21@xmlSchemaP:

; 7662 : 	    ret->subtypes = xmlSchemaParseSimpleType(pctxt, schema, child, 0);

	push	esi
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaParseSimpleType
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ebx+48], eax
$LN22@xmlSchemaP:

; 7663 : 	child = child->next;

	mov	esi, DWORD PTR [esi+24]
$LN20@xmlSchemaP:

; 7664 :     }
; 7665 :     if (child != NULL)

	test	esi, esi
	je	SHORT $LN43@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0BL@LABGHPL@?$CIannotation?$DP?0?5simpleType?$DP?$CJ@
	push	DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	edi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN43@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN43@xmlSchemaP:
	pop	edi

; 7666 : 	xmlSchemaPContentErr(pctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 7667 : 	    NULL, node, child, NULL,
; 7668 : 	    "(annotation?, simpleType?)");
; 7669 : 
; 7670 :     return (ret);
; 7671 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseGlobalAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseNotation
_TEXT	SEGMENT
_nsName$1$ = -4						; size = 4
_des$1 = 8						; size = 4
_name$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaParseNotation PROC				; COMDAT

; 7026 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaP

; 7027 :     const xmlChar *name;
; 7028 :     xmlSchemaNotationPtr ret;
; 7029 :     xmlNodePtr child = NULL;
; 7030 : 
; 7031 :     if ((ctxt == NULL) || (schema == NULL) || (node == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	SHORT $LN3@xmlSchemaP
	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlSchemaP

; 7032 :         return (NULL);
; 7033 :     name = xmlSchemaGetProp(ctxt, node, "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	edi
	push	esi
	call	_xmlSchemaGetProp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _name$1$[ebp], eax

; 7034 :     if (name == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlSchemaP

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	push	eax
	push	eax
	push	OFFSET ??_C@_0BG@DHBIDCLH@Notation?5has?5no?5name?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	inc	DWORD PTR [esi+20]
	push	eax
	push	eax
	push	2
	push	1723					; 000006bbH
	push	16					; 00000010H
	push	edi
	push	esi
	push	DWORD PTR [esi+4]
	mov	DWORD PTR [esi+16], 1723		; 000006bbH
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+24]
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN3@xmlSchemaP:
	pop	edi

; 7051 : 	xmlSchemaPContentErr(ctxt,
; 7052 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 7053 : 	    NULL, node, child,
; 7054 : 	    NULL, "(annotation?)");
; 7055 :     }
; 7056 : 
; 7057 :     return (ret);
; 7058 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlSchemaP:

; 7035 :         xmlSchemaPErr2(ctxt, node, child, XML_SCHEMAP_NOTATION_NO_NAME,
; 7036 :                        "Notation has no name\n", NULL, NULL);
; 7037 :         return (NULL);
; 7038 :     }
; 7039 :     ret = xmlSchemaAddNotation(ctxt, schema, name,

	mov	eax, DWORD PTR [esi+112]

; 5170 :     ret = (xmlSchemaNotationPtr) xmlMalloc(sizeof(xmlSchemaNotation));

	push	20					; 00000014H

; 7035 :         xmlSchemaPErr2(ctxt, node, child, XML_SCHEMAP_NOTATION_NO_NAME,
; 7036 :                        "Notation has no name\n", NULL, NULL);
; 7037 :         return (NULL);
; 7038 :     }
; 7039 :     ret = xmlSchemaAddNotation(ctxt, schema, name,

	mov	DWORD PTR _nsName$1$[ebp], eax

; 5170 :     ret = (xmlSchemaNotationPtr) xmlMalloc(sizeof(xmlSchemaNotation));

	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4

; 5171 :     if (ret == NULL) {

	test	ebx, ebx
	jne	SHORT $LN22@xmlSchemaP

; 5172 :         xmlSchemaPErrMemory(ctxt, "add annotation", NULL);

	push	eax
	push	OFFSET ??_C@_0P@HKPLIAHO@add?5annotation@
	push	esi
	call	_xmlSchemaPErrMemory
	add	esp, 12					; 0000000cH

; 7051 : 	xmlSchemaPContentErr(ctxt,
; 7052 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 7053 : 	    NULL, node, child,
; 7054 : 	    NULL, "(annotation?)");
; 7055 :     }
; 7056 : 
; 7057 :     return (ret);
; 7058 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@xmlSchemaP:

; 5175 :     memset(ret, 0, sizeof(xmlSchemaNotation));

	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+12], 0

; 5176 :     ret->type = XML_SCHEMA_TYPE_NOTATION;
; 5177 :     ret->name = name;

	mov	eax, DWORD PTR _name$1$[ebp]
	mov	DWORD PTR [ebx+4], eax

; 5178 :     ret->targetNamespace = nsName;

	mov	eax, DWORD PTR _nsName$1$[ebp]
	mov	DWORD PTR [ebx+16], eax
	mov	DWORD PTR [ebx], 18			; 00000012H

; 5179 :     /* TODO: do we need the node to be set?
; 5180 :     * ret->node = node;*/
; 5181 :     WXS_ADD_GLOBAL(ctxt, ret);

	mov	eax, DWORD PTR [esi+28]
	push	ebx
	push	5
	mov	eax, DWORD PTR [eax+16]
	add	eax, 44					; 0000002cH
	push	eax
	call	_xmlSchemaAddItemSize

; 7040 : 	ctxt->targetNamespace, node);
; 7041 :     if (ret == NULL)
; 7042 :         return (NULL);
; 7043 :     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	edi
	push	esi
	call	_xmlSchemaPValAttrID

; 7044 : 
; 7045 :     child = node->children;

	mov	edi, DWORD PTR [edi+12]
	add	esp, 24					; 00000018H

; 7046 :     if (IS_SCHEMA(child, "annotation")) {

	test	edi, edi
	je	$LN29@xmlSchemaP
	cmp	DWORD PTR [edi+36], 0
	je	SHORT $LN6@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlSchemaP

; 7047 :         ret->annot = xmlSchemaParseAnnotation(ctxt, child, 1);

	push	1
	push	edi
	push	esi
	call	_xmlSchemaParseAnnotation
	mov	DWORD PTR [ebx+8], eax
	add	esp, 12					; 0000000cH

; 7048 :         child = child->next;

	mov	edi, DWORD PTR [edi+24]
$LN6@xmlSchemaP:

; 7049 :     }
; 7050 :     if (child != NULL) {

	test	edi, edi
	je	SHORT $LN29@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0O@MNAJHLGE@?$CIannotation?$DP?$CJ@
	push	DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	edi
	push	esi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN29@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN29@xmlSchemaP:
	pop	edi

; 7051 : 	xmlSchemaPContentErr(ctxt,
; 7052 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 7053 : 	    NULL, node, child,
; 7054 : 	    NULL, "(annotation?)");
; 7055 :     }
; 7056 : 
; 7057 :     return (ret);
; 7058 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseNotation ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseAny
_TEXT	SEGMENT
_wild$1$ = -16						; size = 4
_min$1$ = -12						; size = 4
_annot$1$ = -8						; size = 4
_max$1$ = -4						; size = 4
_des$1 = 8						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaParseAny PROC					; COMDAT

; 6934 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _annot$1$[ebp], 0
	test	edi, edi
	je	$LN5@xmlSchemaP

; 6935 :     xmlSchemaParticlePtr particle;
; 6936 :     xmlNodePtr child = NULL;
; 6937 :     xmlSchemaWildcardPtr wild;
; 6938 :     int min, max;
; 6939 :     xmlAttrPtr attr;
; 6940 :     xmlSchemaAnnotPtr annot = NULL;
; 6941 : 
; 6942 :     if ((ctxt == NULL) || (schema == NULL) || (node == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	$LN5@xmlSchemaP
	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	$LN5@xmlSchemaP

; 6943 :         return (NULL);
; 6944 :     /*
; 6945 :     * Check for illegal attributes.
; 6946 :     */
; 6947 :     attr = node->properties;

	mov	esi, DWORD PTR [ebx+44]

; 6948 :     while (attr != NULL) {

	test	esi, esi
	je	$LN60@xmlSchemaP
$LL2@xmlSchemaP:

; 6949 : 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN6@xmlSchemaP

; 6950 : 	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
; 6951 : 		(!xmlStrEqual(attr->name, BAD_CAST "minOccurs")) &&
; 6952 : 		(!xmlStrEqual(attr->name, BAD_CAST "maxOccurs")) &&
; 6953 : 	        (!xmlStrEqual(attr->name, BAD_CAST "namespace")) &&

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP
	push	OFFSET ??_C@_09OAPKCOGD@minOccurs@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP
	push	OFFSET ??_C@_09OBPGLENH@maxOccurs@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP
	push	OFFSET ??_C@_09KPMGAFNI@namespace@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP
	push	OFFSET ??_C@_0BA@LJOIJHLO@processContents@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP

; 6954 : 		(!xmlStrEqual(attr->name, BAD_CAST "processContents"))) {
; 6955 : 		xmlSchemaPIllegalAttrErr(ctxt,
; 6956 : 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 6957 : 	    }

	jmp	SHORT $LN63@xmlSchemaP
$LN6@xmlSchemaP:

; 6958 : 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlSchemaP
$LN63@xmlSchemaP:

; 6959 : 	    xmlSchemaPIllegalAttrErr(ctxt,
; 6960 : 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 6961 : 	}
; 6962 : 	attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN9@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	$LL2@xmlSchemaP
	mov	esi, DWORD PTR [ebx+44]

; 4667 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN60@xmlSchemaP
	npad	6
$LL20@xmlSchemaP:

; 4668 :         if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN24@xmlSchemaP
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@xmlSchemaP
$LN24@xmlSchemaP:

; 4669 : 	    return(prop);
; 4670 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL20@xmlSchemaP

; 3242 : }
; 3243 : 
; 3244 : /************************************************************************
; 3245 :  *									*
; 3246 :  *			Streamable error functions                      *
; 3247 :  *									*
; 3248 :  ************************************************************************/
; 3249 : 
; 3250 : 
; 3251 : 
; 3252 : 
; 3253 : /************************************************************************
; 3254 :  *									*
; 3255 :  *			Validation helper functions			*
; 3256 :  *									*
; 3257 :  ************************************************************************/
; 3258 : 
; 3259 : 
; 3260 : /************************************************************************
; 3261 :  *									*
; 3262 :  *			Allocation functions				*
; 3263 :  *									*
; 3264 :  ************************************************************************/
; 3265 : 
; 3266 : /**
; 3267 :  * xmlSchemaNewSchemaForParserCtxt:
; 3268 :  * @ctxt:  a schema validation context
; 3269 :  *
; 3270 :  * Allocate a new Schema structure.
; 3271 :  *
; 3272 :  * Returns the newly allocated structure or NULL in case or error
; 3273 :  */
; 3274 : static xmlSchemaPtr
; 3275 : xmlSchemaNewSchema(xmlSchemaParserCtxtPtr ctxt)
; 3276 : {
; 3277 :     xmlSchemaPtr ret;
; 3278 : 
; 3279 :     ret = (xmlSchemaPtr) xmlMalloc(sizeof(xmlSchema));
; 3280 :     if (ret == NULL) {
; 3281 :         xmlSchemaPErrMemory(ctxt, "allocating schema", NULL);
; 3282 :         return (NULL);
; 3283 :     }
; 3284 :     memset(ret, 0, sizeof(xmlSchema));
; 3285 :     ret->dict = ctxt->dict;
; 3286 :     xmlDictReference(ret->dict);
; 3287 : 
; 3288 :     return (ret);
; 3289 : }
; 3290 : 
; 3291 : /**
; 3292 :  * xmlSchemaNewFacet:
; 3293 :  *
; 3294 :  * Allocate a new Facet structure.
; 3295 :  *
; 3296 :  * Returns the newly allocated structure or NULL in case or error
; 3297 :  */
; 3298 : xmlSchemaFacetPtr
; 3299 : xmlSchemaNewFacet(void)
; 3300 : {
; 3301 :     xmlSchemaFacetPtr ret;
; 3302 : 
; 3303 :     ret = (xmlSchemaFacetPtr) xmlMalloc(sizeof(xmlSchemaFacet));
; 3304 :     if (ret == NULL) {
; 3305 :         return (NULL);
; 3306 :     }
; 3307 :     memset(ret, 0, sizeof(xmlSchemaFacet));
; 3308 : 
; 3309 :     return (ret);
; 3310 : }
; 3311 : 
; 3312 : /**
; 3313 :  * xmlSchemaNewAnnot:
; 3314 :  * @ctxt:  a schema validation context
; 3315 :  * @node:  a node
; 3316 :  *
; 3317 :  * Allocate a new annotation structure.
; 3318 :  *
; 3319 :  * Returns the newly allocated structure or NULL in case or error
; 3320 :  */
; 3321 : static xmlSchemaAnnotPtr
; 3322 : xmlSchemaNewAnnot(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node)
; 3323 : {
; 3324 :     xmlSchemaAnnotPtr ret;
; 3325 : 
; 3326 :     ret = (xmlSchemaAnnotPtr) xmlMalloc(sizeof(xmlSchemaAnnot));
; 3327 :     if (ret == NULL) {
; 3328 :         xmlSchemaPErrMemory(ctxt, "allocating annotation", node);
; 3329 :         return (NULL);
; 3330 :     }
; 3331 :     memset(ret, 0, sizeof(xmlSchemaAnnot));
; 3332 :     ret->content = node;
; 3333 :     return (ret);
; 3334 : }
; 3335 : 
; 3336 : static xmlSchemaItemListPtr
; 3337 : xmlSchemaItemListCreate(void)
; 3338 : {
; 3339 :     xmlSchemaItemListPtr ret;
; 3340 : 
; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));
; 3342 :     if (ret == NULL) {
; 3343 : 	xmlSchemaPErrMemory(NULL,
; 3344 : 	    "allocating an item list structure", NULL);
; 3345 : 	return (NULL);
; 3346 :     }
; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));
; 3348 :     return (ret);
; 3349 : }
; 3350 : 
; 3351 : static void
; 3352 : xmlSchemaItemListClear(xmlSchemaItemListPtr list)
; 3353 : {
; 3354 :     if (list->items != NULL) {
; 3355 : 	xmlFree(list->items);
; 3356 : 	list->items = NULL;
; 3357 :     }
; 3358 :     list->nbItems = 0;
; 3359 :     list->sizeItems = 0;
; 3360 : }
; 3361 : 
; 3362 : static int
; 3363 : xmlSchemaItemListAdd(xmlSchemaItemListPtr list, void *item)
; 3364 : {
; 3365 :     if (list->items == NULL) {
; 3366 : 	list->items = (void **) xmlMalloc(
; 3367 : 	    20 * sizeof(void *));
; 3368 : 	if (list->items == NULL) {
; 3369 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3370 : 	    return(-1);
; 3371 : 	}
; 3372 : 	list->sizeItems = 20;
; 3373 :     } else if (list->sizeItems <= list->nbItems) {
; 3374 : 	list->sizeItems *= 2;
; 3375 : 	list->items = (void **) xmlRealloc(list->items,
; 3376 : 	    list->sizeItems * sizeof(void *));
; 3377 : 	if (list->items == NULL) {
; 3378 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3379 : 	    list->sizeItems = 0;
; 3380 : 	    return(-1);
; 3381 : 	}
; 3382 :     }
; 3383 :     list->items[list->nbItems++] = item;
; 3384 :     return(0);
; 3385 : }
; 3386 : 
; 3387 : static int
; 3388 : xmlSchemaItemListAddSize(xmlSchemaItemListPtr list,
; 3389 : 			 int initialSize,
; 3390 : 			 void *item)
; 3391 : {
; 3392 :     if (list->items == NULL) {
; 3393 : 	if (initialSize <= 0)
; 3394 : 	    initialSize = 1;
; 3395 : 	list->items = (void **) xmlMalloc(
; 3396 : 	    initialSize * sizeof(void *));
; 3397 : 	if (list->items == NULL) {
; 3398 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3399 : 	    return(-1);
; 3400 : 	}
; 3401 : 	list->sizeItems = initialSize;
; 3402 :     } else if (list->sizeItems <= list->nbItems) {
; 3403 : 	list->sizeItems *= 2;
; 3404 : 	list->items = (void **) xmlRealloc(list->items,
; 3405 : 	    list->sizeItems * sizeof(void *));
; 3406 : 	if (list->items == NULL) {
; 3407 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3408 : 	    list->sizeItems = 0;
; 3409 : 	    return(-1);
; 3410 : 	}
; 3411 :     }
; 3412 :     list->items[list->nbItems++] = item;
; 3413 :     return(0);
; 3414 : }
; 3415 : 
; 3416 : static int
; 3417 : xmlSchemaItemListInsert(xmlSchemaItemListPtr list, void *item, int idx)
; 3418 : {
; 3419 :     if (list->items == NULL) {
; 3420 : 	list->items = (void **) xmlMalloc(
; 3421 : 	    20 * sizeof(void *));
; 3422 : 	if (list->items == NULL) {
; 3423 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3424 : 	    return(-1);
; 3425 : 	}
; 3426 : 	list->sizeItems = 20;
; 3427 :     } else if (list->sizeItems <= list->nbItems) {
; 3428 : 	list->sizeItems *= 2;
; 3429 : 	list->items = (void **) xmlRealloc(list->items,
; 3430 : 	    list->sizeItems * sizeof(void *));
; 3431 : 	if (list->items == NULL) {
; 3432 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3433 : 	    list->sizeItems = 0;
; 3434 : 	    return(-1);
; 3435 : 	}
; 3436 :     }
; 3437 :     /*
; 3438 :     * Just append if the index is greater/equal than the item count.
; 3439 :     */
; 3440 :     if (idx >= list->nbItems) {
; 3441 : 	list->items[list->nbItems++] = item;
; 3442 :     } else {
; 3443 : 	int i;
; 3444 : 	for (i = list->nbItems; i > idx; i--)
; 3445 : 	    list->items[i] = list->items[i-1];
; 3446 : 	list->items[idx] = item;
; 3447 : 	list->nbItems++;
; 3448 :     }
; 3449 :     return(0);
; 3450 : }
; 3451 : 
; 3452 : #if 0 /* enable if ever needed */
; 3453 : static int
; 3454 : xmlSchemaItemListInsertSize(xmlSchemaItemListPtr list,
; 3455 : 			    int initialSize,
; 3456 : 			    void *item,
; 3457 : 			    int idx)
; 3458 : {
; 3459 :     if (list->items == NULL) {
; 3460 : 	if (initialSize <= 0)
; 3461 : 	    initialSize = 1;
; 3462 : 	list->items = (void **) xmlMalloc(
; 3463 : 	    initialSize * sizeof(void *));
; 3464 : 	if (list->items == NULL) {
; 3465 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3466 : 	    return(-1);
; 3467 : 	}
; 3468 : 	list->sizeItems = initialSize;
; 3469 :     } else if (list->sizeItems <= list->nbItems) {
; 3470 : 	list->sizeItems *= 2;
; 3471 : 	list->items = (void **) xmlRealloc(list->items,
; 3472 : 	    list->sizeItems * sizeof(void *));
; 3473 : 	if (list->items == NULL) {
; 3474 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3475 : 	    list->sizeItems = 0;
; 3476 : 	    return(-1);
; 3477 : 	}
; 3478 :     }
; 3479 :     /*
; 3480 :     * Just append if the index is greater/equal than the item count.
; 3481 :     */
; 3482 :     if (idx >= list->nbItems) {
; 3483 : 	list->items[list->nbItems++] = item;
; 3484 :     } else {
; 3485 : 	int i;
; 3486 : 	for (i = list->nbItems; i > idx; i--)
; 3487 : 	    list->items[i] = list->items[i-1];
; 3488 : 	list->items[idx] = item;
; 3489 : 	list->nbItems++;
; 3490 :     }
; 3491 :     return(0);
; 3492 : }
; 3493 : #endif
; 3494 : 
; 3495 : static int
; 3496 : xmlSchemaItemListRemove(xmlSchemaItemListPtr list, int idx)
; 3497 : {
; 3498 :     int i;
; 3499 :     if ((list->items == NULL) || (idx >= list->nbItems)) {
; 3500 : 	xmlSchemaPSimpleErr("Internal error: xmlSchemaItemListRemove, "
; 3501 : 	    "index error.\n");
; 3502 : 	return(-1);
; 3503 :     }
; 3504 : 
; 3505 :     if (list->nbItems == 1) {
; 3506 : 	/* TODO: Really free the list? */
; 3507 : 	xmlFree(list->items);
; 3508 : 	list->items = NULL;
; 3509 : 	list->nbItems = 0;
; 3510 : 	list->sizeItems = 0;
; 3511 :     } else if (list->nbItems -1 == idx) {
; 3512 : 	list->nbItems--;
; 3513 :     } else {
; 3514 : 	for (i = idx; i < list->nbItems -1; i++)
; 3515 : 	    list->items[i] = list->items[i+1];
; 3516 : 	list->nbItems--;
; 3517 :     }
; 3518 :     return(0);
; 3519 : }
; 3520 : 
; 3521 : /**
; 3522 :  * xmlSchemaItemListFree:
; 3523 :  * @annot:  a schema type structure
; 3524 :  *
; 3525 :  * Deallocate a annotation structure
; 3526 :  */
; 3527 : static void
; 3528 : xmlSchemaItemListFree(xmlSchemaItemListPtr list)
; 3529 : {
; 3530 :     if (list == NULL)
; 3531 : 	return;
; 3532 :     if (list->items != NULL)
; 3533 : 	xmlFree(list->items);
; 3534 :     xmlFree(list);
; 3535 : }
; 3536 : 
; 3537 : static void
; 3538 : xmlSchemaBucketFree(xmlSchemaBucketPtr bucket)
; 3539 : {
; 3540 :     if (bucket == NULL)
; 3541 : 	return;
; 3542 :     if (bucket->globals != NULL) {
; 3543 : 	xmlSchemaComponentListFree(bucket->globals);
; 3544 : 	xmlSchemaItemListFree(bucket->globals);
; 3545 :     }
; 3546 :     if (bucket->locals != NULL) {
; 3547 : 	xmlSchemaComponentListFree(bucket->locals);
; 3548 : 	xmlSchemaItemListFree(bucket->locals);
; 3549 :     }
; 3550 :     if (bucket->relations != NULL) {
; 3551 : 	xmlSchemaSchemaRelationPtr prev, cur = bucket->relations;
; 3552 : 	do {
; 3553 : 	    prev = cur;
; 3554 : 	    cur = cur->next;
; 3555 : 	    xmlFree(prev);
; 3556 : 	} while (cur != NULL);
; 3557 :     }
; 3558 :     if ((! bucket->preserveDoc) && (bucket->doc != NULL)) {
; 3559 : 	xmlFreeDoc(bucket->doc);
; 3560 :     }
; 3561 :     if (bucket->type == XML_SCHEMA_SCHEMA_IMPORT) {
; 3562 : 	if (WXS_IMPBUCKET(bucket)->schema != NULL)
; 3563 : 	    xmlSchemaFree(WXS_IMPBUCKET(bucket)->schema);
; 3564 :     }
; 3565 :     xmlFree(bucket);
; 3566 : }
; 3567 : 
; 3568 : static void
; 3569 : xmlSchemaBucketFreeEntry(void *bucket, const xmlChar *name ATTRIBUTE_UNUSED)
; 3570 : {
; 3571 :     xmlSchemaBucketFree((xmlSchemaBucketPtr) bucket);
; 3572 : }
; 3573 : 
; 3574 : static xmlSchemaBucketPtr
; 3575 : xmlSchemaBucketCreate(xmlSchemaParserCtxtPtr pctxt,
; 3576 : 			 int type, const xmlChar *targetNamespace)
; 3577 : {
; 3578 :     xmlSchemaBucketPtr ret;
; 3579 :     int size;
; 3580 :     xmlSchemaPtr mainSchema;
; 3581 : 
; 3582 :     if (WXS_CONSTRUCTOR(pctxt)->mainSchema == NULL) {
; 3583 : 	PERROR_INT("xmlSchemaBucketCreate",
; 3584 : 	    "no main schema on constructor");
; 3585 : 	return(NULL);
; 3586 :     }
; 3587 :     mainSchema = WXS_CONSTRUCTOR(pctxt)->mainSchema;
; 3588 :     /* Create the schema bucket. */
; 3589 :     if (WXS_IS_BUCKET_INCREDEF(type))
; 3590 : 	size = sizeof(xmlSchemaInclude);
; 3591 :     else
; 3592 : 	size = sizeof(xmlSchemaImport);
; 3593 :     ret = (xmlSchemaBucketPtr) xmlMalloc(size);
; 3594 :     if (ret == NULL) {
; 3595 : 	xmlSchemaPErrMemory(NULL, "allocating schema bucket", NULL);
; 3596 : 	return(NULL);
; 3597 :     }
; 3598 :     memset(ret, 0, size);
; 3599 :     ret->targetNamespace = targetNamespace;
; 3600 :     ret->type = type;
; 3601 :     ret->globals = xmlSchemaItemListCreate();
; 3602 :     if (ret->globals == NULL) {
; 3603 : 	xmlFree(ret);
; 3604 : 	return(NULL);
; 3605 :     }
; 3606 :     ret->locals = xmlSchemaItemListCreate();
; 3607 :     if (ret->locals == NULL) {
; 3608 : 	xmlFree(ret);
; 3609 : 	return(NULL);
; 3610 :     }
; 3611 :     /*
; 3612 :     * The following will assure that only the first bucket is marked as
; 3613 :     * XML_SCHEMA_SCHEMA_MAIN and it points to the *main* schema.
; 3614 :     * For each following import buckets an xmlSchema will be created.
; 3615 :     * An xmlSchema will be created for every distinct targetNamespace.
; 3616 :     * We assign the targetNamespace to the schemata here.
; 3617 :     */
; 3618 :     if (! WXS_HAS_BUCKETS(pctxt)) {
; 3619 : 	if (WXS_IS_BUCKET_INCREDEF(type)) {
; 3620 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3621 : 		"first bucket but it's an include or redefine");
; 3622 : 	    xmlSchemaBucketFree(ret);
; 3623 : 	    return(NULL);
; 3624 : 	}
; 3625 : 	/* Force the type to be XML_SCHEMA_SCHEMA_MAIN. */
; 3626 : 	ret->type = XML_SCHEMA_SCHEMA_MAIN;
; 3627 : 	/* Point to the *main* schema. */
; 3628 : 	WXS_CONSTRUCTOR(pctxt)->mainBucket = ret;
; 3629 : 	WXS_IMPBUCKET(ret)->schema = mainSchema;
; 3630 : 	/*
; 3631 : 	* Ensure that the main schema gets a targetNamespace.
; 3632 : 	*/
; 3633 : 	mainSchema->targetNamespace = targetNamespace;
; 3634 :     } else {
; 3635 : 	if (type == XML_SCHEMA_SCHEMA_MAIN) {
; 3636 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3637 : 		"main bucket but it's not the first one");
; 3638 : 	    xmlSchemaBucketFree(ret);
; 3639 : 	    return(NULL);
; 3640 : 	} else if (type == XML_SCHEMA_SCHEMA_IMPORT) {
; 3641 : 	    /*
; 3642 : 	    * Create a schema for imports and assign the
; 3643 : 	    * targetNamespace.
; 3644 : 	    */
; 3645 : 	    WXS_IMPBUCKET(ret)->schema = xmlSchemaNewSchema(pctxt);
; 3646 : 	    if (WXS_IMPBUCKET(ret)->schema == NULL) {
; 3647 : 		xmlSchemaBucketFree(ret);
; 3648 : 		return(NULL);
; 3649 : 	    }
; 3650 : 	    WXS_IMPBUCKET(ret)->schema->targetNamespace = targetNamespace;
; 3651 : 	}
; 3652 :     }
; 3653 :     if (WXS_IS_BUCKET_IMPMAIN(type)) {
; 3654 : 	int res;
; 3655 : 	/*
; 3656 : 	* Imports go into the "schemasImports" slot of the main *schema*.
; 3657 : 	* Note that we create an import entry for the main schema as well; i.e.,
; 3658 : 	* even if there's only one schema, we'll get an import.
; 3659 : 	*/
; 3660 : 	if (mainSchema->schemasImports == NULL) {
; 3661 : 	    mainSchema->schemasImports = xmlHashCreateDict(5,
; 3662 : 		WXS_CONSTRUCTOR(pctxt)->dict);
; 3663 : 	    if (mainSchema->schemasImports == NULL) {
; 3664 : 		xmlSchemaBucketFree(ret);
; 3665 : 		return(NULL);
; 3666 : 	    }
; 3667 : 	}
; 3668 : 	if (targetNamespace == NULL)
; 3669 : 	    res = xmlHashAddEntry(mainSchema->schemasImports,
; 3670 : 		XML_SCHEMAS_NO_NAMESPACE, ret);
; 3671 : 	else
; 3672 : 	    res = xmlHashAddEntry(mainSchema->schemasImports,
; 3673 : 		targetNamespace, ret);
; 3674 : 	if (res != 0) {
; 3675 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3676 : 		"failed to add the schema bucket to the hash");
; 3677 : 	    xmlSchemaBucketFree(ret);
; 3678 : 	    return(NULL);
; 3679 : 	}
; 3680 :     } else {
; 3681 : 	/* Set the @ownerImport of an include bucket. */
; 3682 : 	if (WXS_IS_BUCKET_IMPMAIN(WXS_CONSTRUCTOR(pctxt)->bucket->type))
; 3683 : 	    WXS_INCBUCKET(ret)->ownerImport =
; 3684 : 		WXS_IMPBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket);
; 3685 : 	else
; 3686 : 	    WXS_INCBUCKET(ret)->ownerImport =
; 3687 : 		WXS_INCBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket)->ownerImport;
; 3688 : 
; 3689 : 	/* Includes got into the "includes" slot of the *main* schema. */
; 3690 : 	if (mainSchema->includes == NULL) {
; 3691 : 	    mainSchema->includes = xmlSchemaItemListCreate();
; 3692 : 	    if (mainSchema->includes == NULL) {
; 3693 : 		xmlSchemaBucketFree(ret);
; 3694 : 		return(NULL);
; 3695 : 	    }
; 3696 : 	}
; 3697 : 	xmlSchemaItemListAdd(mainSchema->includes, ret);
; 3698 :     }
; 3699 :     /*
; 3700 :     * Add to list of all buckets; this is used for lookup
; 3701 :     * during schema construction time only.
; 3702 :     */
; 3703 :     if (xmlSchemaItemListAdd(WXS_CONSTRUCTOR(pctxt)->buckets, ret) == -1)
; 3704 : 	return(NULL);
; 3705 :     return(ret);
; 3706 : }
; 3707 : 
; 3708 : static int
; 3709 : xmlSchemaAddItemSize(xmlSchemaItemListPtr *list, int initialSize, void *item)
; 3710 : {
; 3711 :     if (*list == NULL) {
; 3712 : 	*list = xmlSchemaItemListCreate();
; 3713 : 	if (*list == NULL)
; 3714 : 	    return(-1);
; 3715 :     }
; 3716 :     xmlSchemaItemListAddSize(*list, initialSize, item);
; 3717 :     return(0);
; 3718 : }
; 3719 : 
; 3720 : /**
; 3721 :  * xmlSchemaFreeAnnot:
; 3722 :  * @annot:  a schema type structure
; 3723 :  *
; 3724 :  * Deallocate a annotation structure
; 3725 :  */
; 3726 : static void
; 3727 : xmlSchemaFreeAnnot(xmlSchemaAnnotPtr annot)
; 3728 : {
; 3729 :     if (annot == NULL)
; 3730 :         return;
; 3731 :     if (annot->next == NULL) {
; 3732 : 	xmlFree(annot);
; 3733 :     } else {
; 3734 : 	xmlSchemaAnnotPtr prev;
; 3735 : 
; 3736 : 	do {
; 3737 : 	    prev = annot;
; 3738 : 	    annot = annot->next;
; 3739 : 	    xmlFree(prev);
; 3740 : 	} while (annot != NULL);
; 3741 :     }
; 3742 : }
; 3743 : 
; 3744 : /**
; 3745 :  * xmlSchemaFreeNotation:
; 3746 :  * @schema:  a schema notation structure
; 3747 :  *
; 3748 :  * Deallocate a Schema Notation structure.
; 3749 :  */
; 3750 : static void
; 3751 : xmlSchemaFreeNotation(xmlSchemaNotationPtr nota)
; 3752 : {
; 3753 :     if (nota == NULL)
; 3754 :         return;
; 3755 :     xmlFree(nota);
; 3756 : }
; 3757 : 
; 3758 : /**
; 3759 :  * xmlSchemaFreeAttribute:
; 3760 :  * @attr:  an attribute declaration
; 3761 :  *
; 3762 :  * Deallocates an attribute declaration structure.
; 3763 :  */
; 3764 : static void
; 3765 : xmlSchemaFreeAttribute(xmlSchemaAttributePtr attr)
; 3766 : {
; 3767 :     if (attr == NULL)
; 3768 :         return;
; 3769 :     if (attr->annot != NULL)
; 3770 : 	xmlSchemaFreeAnnot(attr->annot);
; 3771 :     if (attr->defVal != NULL)
; 3772 : 	xmlSchemaFreeValue(attr->defVal);
; 3773 :     xmlFree(attr);
; 3774 : }
; 3775 : 
; 3776 : /**
; 3777 :  * xmlSchemaFreeAttributeUse:
; 3778 :  * @use:  an attribute use
; 3779 :  *
; 3780 :  * Deallocates an attribute use structure.
; 3781 :  */
; 3782 : static void
; 3783 : xmlSchemaFreeAttributeUse(xmlSchemaAttributeUsePtr use)
; 3784 : {
; 3785 :     if (use == NULL)
; 3786 :         return;
; 3787 :     if (use->annot != NULL)
; 3788 : 	xmlSchemaFreeAnnot(use->annot);
; 3789 :     if (use->defVal != NULL)
; 3790 : 	xmlSchemaFreeValue(use->defVal);
; 3791 :     xmlFree(use);
; 3792 : }
; 3793 : 
; 3794 : /**
; 3795 :  * xmlSchemaFreeAttributeUseProhib:
; 3796 :  * @prohib:  an attribute use prohibition
; 3797 :  *
; 3798 :  * Deallocates an attribute use structure.
; 3799 :  */
; 3800 : static void
; 3801 : xmlSchemaFreeAttributeUseProhib(xmlSchemaAttributeUseProhibPtr prohib)
; 3802 : {
; 3803 :     if (prohib == NULL)
; 3804 :         return;
; 3805 :     xmlFree(prohib);
; 3806 : }
; 3807 : 
; 3808 : /**
; 3809 :  * xmlSchemaFreeWildcardNsSet:
; 3810 :  * set:  a schema wildcard namespace
; 3811 :  *
; 3812 :  * Deallocates a list of wildcard constraint structures.
; 3813 :  */
; 3814 : static void
; 3815 : xmlSchemaFreeWildcardNsSet(xmlSchemaWildcardNsPtr set)
; 3816 : {
; 3817 :     xmlSchemaWildcardNsPtr next;
; 3818 : 
; 3819 :     while (set != NULL) {
; 3820 : 	next = set->next;
; 3821 : 	xmlFree(set);
; 3822 : 	set = next;
; 3823 :     }
; 3824 : }
; 3825 : 
; 3826 : /**
; 3827 :  * xmlSchemaFreeWildcard:
; 3828 :  * @wildcard:  a wildcard structure
; 3829 :  *
; 3830 :  * Deallocates a wildcard structure.
; 3831 :  */
; 3832 : void
; 3833 : xmlSchemaFreeWildcard(xmlSchemaWildcardPtr wildcard)
; 3834 : {
; 3835 :     if (wildcard == NULL)
; 3836 :         return;
; 3837 :     if (wildcard->annot != NULL)
; 3838 :         xmlSchemaFreeAnnot(wildcard->annot);
; 3839 :     if (wildcard->nsSet != NULL)
; 3840 : 	xmlSchemaFreeWildcardNsSet(wildcard->nsSet);
; 3841 :     if (wildcard->negNsSet != NULL)
; 3842 : 	xmlFree(wildcard->negNsSet);
; 3843 :     xmlFree(wildcard);
; 3844 : }
; 3845 : 
; 3846 : /**
; 3847 :  * xmlSchemaFreeAttributeGroup:
; 3848 :  * @schema:  a schema attribute group structure
; 3849 :  *
; 3850 :  * Deallocate a Schema Attribute Group structure.
; 3851 :  */
; 3852 : static void
; 3853 : xmlSchemaFreeAttributeGroup(xmlSchemaAttributeGroupPtr attrGr)
; 3854 : {
; 3855 :     if (attrGr == NULL)
; 3856 :         return;
; 3857 :     if (attrGr->annot != NULL)
; 3858 :         xmlSchemaFreeAnnot(attrGr->annot);
; 3859 :     if (attrGr->attrUses != NULL)
; 3860 : 	xmlSchemaItemListFree(WXS_LIST_CAST attrGr->attrUses);
; 3861 :     xmlFree(attrGr);
; 3862 : }
; 3863 : 
; 3864 : /**
; 3865 :  * xmlSchemaFreeQNameRef:
; 3866 :  * @item: a QName reference structure
; 3867 :  *
; 3868 :  * Deallocatea a QName reference structure.
; 3869 :  */
; 3870 : static void
; 3871 : xmlSchemaFreeQNameRef(xmlSchemaQNameRefPtr item)
; 3872 : {
; 3873 :     xmlFree(item);
; 3874 : }
; 3875 : 
; 3876 : /**
; 3877 :  * xmlSchemaFreeTypeLinkList:
; 3878 :  * @alink: a type link
; 3879 :  *
; 3880 :  * Deallocate a list of types.
; 3881 :  */
; 3882 : static void
; 3883 : xmlSchemaFreeTypeLinkList(xmlSchemaTypeLinkPtr link)
; 3884 : {
; 3885 :     xmlSchemaTypeLinkPtr next;
; 3886 : 
; 3887 :     while (link != NULL) {
; 3888 : 	next = link->next;
; 3889 : 	xmlFree(link);
; 3890 : 	link = next;
; 3891 :     }
; 3892 : }
; 3893 : 
; 3894 : static void
; 3895 : xmlSchemaFreeIDCStateObjList(xmlSchemaIDCStateObjPtr sto)
; 3896 : {
; 3897 :     xmlSchemaIDCStateObjPtr next;
; 3898 :     while (sto != NULL) {
; 3899 : 	next = sto->next;
; 3900 : 	if (sto->history != NULL)
; 3901 : 	    xmlFree(sto->history);
; 3902 : 	if (sto->xpathCtxt != NULL)
; 3903 : 	    xmlFreeStreamCtxt((xmlStreamCtxtPtr) sto->xpathCtxt);
; 3904 : 	xmlFree(sto);
; 3905 : 	sto = next;
; 3906 :     }
; 3907 : }
; 3908 : 
; 3909 : /**
; 3910 :  * xmlSchemaFreeIDC:
; 3911 :  * @idc: a identity-constraint definition
; 3912 :  *
; 3913 :  * Deallocates an identity-constraint definition.
; 3914 :  */
; 3915 : static void
; 3916 : xmlSchemaFreeIDC(xmlSchemaIDCPtr idcDef)
; 3917 : {
; 3918 :     xmlSchemaIDCSelectPtr cur, prev;
; 3919 : 
; 3920 :     if (idcDef == NULL)
; 3921 : 	return;
; 3922 :     if (idcDef->annot != NULL)
; 3923 :         xmlSchemaFreeAnnot(idcDef->annot);
; 3924 :     /* Selector */
; 3925 :     if (idcDef->selector != NULL) {
; 3926 : 	if (idcDef->selector->xpathComp != NULL)
; 3927 : 	    xmlFreePattern((xmlPatternPtr) idcDef->selector->xpathComp);
; 3928 : 	xmlFree(idcDef->selector);
; 3929 :     }
; 3930 :     /* Fields */
; 3931 :     if (idcDef->fields != NULL) {
; 3932 : 	cur = idcDef->fields;
; 3933 : 	do {
; 3934 : 	    prev = cur;
; 3935 : 	    cur = cur->next;
; 3936 : 	    if (prev->xpathComp != NULL)
; 3937 : 		xmlFreePattern((xmlPatternPtr) prev->xpathComp);
; 3938 : 	    xmlFree(prev);
; 3939 : 	} while (cur != NULL);
; 3940 :     }
; 3941 :     xmlFree(idcDef);
; 3942 : }
; 3943 : 
; 3944 : /**
; 3945 :  * xmlSchemaFreeElement:
; 3946 :  * @schema:  a schema element structure
; 3947 :  *
; 3948 :  * Deallocate a Schema Element structure.
; 3949 :  */
; 3950 : static void
; 3951 : xmlSchemaFreeElement(xmlSchemaElementPtr elem)
; 3952 : {
; 3953 :     if (elem == NULL)
; 3954 :         return;
; 3955 :     if (elem->annot != NULL)
; 3956 :         xmlSchemaFreeAnnot(elem->annot);
; 3957 :     if (elem->contModel != NULL)
; 3958 :         xmlRegFreeRegexp(elem->contModel);
; 3959 :     if (elem->defVal != NULL)
; 3960 : 	xmlSchemaFreeValue(elem->defVal);
; 3961 :     xmlFree(elem);
; 3962 : }
; 3963 : 
; 3964 : /**
; 3965 :  * xmlSchemaFreeFacet:
; 3966 :  * @facet:  a schema facet structure
; 3967 :  *
; 3968 :  * Deallocate a Schema Facet structure.
; 3969 :  */
; 3970 : void
; 3971 : xmlSchemaFreeFacet(xmlSchemaFacetPtr facet)
; 3972 : {
; 3973 :     if (facet == NULL)
; 3974 :         return;
; 3975 :     if (facet->val != NULL)
; 3976 :         xmlSchemaFreeValue(facet->val);
; 3977 :     if (facet->regexp != NULL)
; 3978 :         xmlRegFreeRegexp(facet->regexp);
; 3979 :     if (facet->annot != NULL)
; 3980 :         xmlSchemaFreeAnnot(facet->annot);
; 3981 :     xmlFree(facet);
; 3982 : }
; 3983 : 
; 3984 : /**
; 3985 :  * xmlSchemaFreeType:
; 3986 :  * @type:  a schema type structure
; 3987 :  *
; 3988 :  * Deallocate a Schema Type structure.
; 3989 :  */
; 3990 : void
; 3991 : xmlSchemaFreeType(xmlSchemaTypePtr type)
; 3992 : {
; 3993 :     if (type == NULL)
; 3994 :         return;
; 3995 :     if (type->annot != NULL)
; 3996 :         xmlSchemaFreeAnnot(type->annot);
; 3997 :     if (type->facets != NULL) {
; 3998 :         xmlSchemaFacetPtr facet, next;
; 3999 : 
; 4000 :         facet = type->facets;
; 4001 :         while (facet != NULL) {
; 4002 :             next = facet->next;
; 4003 :             xmlSchemaFreeFacet(facet);
; 4004 :             facet = next;
; 4005 :         }
; 4006 :     }
; 4007 :     if (type->attrUses != NULL)
; 4008 : 	xmlSchemaItemListFree((xmlSchemaItemListPtr) type->attrUses);
; 4009 :     if (type->memberTypes != NULL)
; 4010 : 	xmlSchemaFreeTypeLinkList(type->memberTypes);
; 4011 :     if (type->facetSet != NULL) {
; 4012 : 	xmlSchemaFacetLinkPtr next, link;
; 4013 : 
; 4014 : 	link = type->facetSet;
; 4015 : 	do {
; 4016 : 	    next = link->next;
; 4017 : 	    xmlFree(link);
; 4018 : 	    link = next;
; 4019 : 	} while (link != NULL);
; 4020 :     }
; 4021 :     if (type->contModel != NULL)
; 4022 :         xmlRegFreeRegexp(type->contModel);
; 4023 :     xmlFree(type);
; 4024 : }
; 4025 : 
; 4026 : /**
; 4027 :  * xmlSchemaFreeModelGroupDef:
; 4028 :  * @item:  a schema model group definition
; 4029 :  *
; 4030 :  * Deallocates a schema model group definition.
; 4031 :  */
; 4032 : static void
; 4033 : xmlSchemaFreeModelGroupDef(xmlSchemaModelGroupDefPtr item)
; 4034 : {
; 4035 :     if (item->annot != NULL)
; 4036 : 	xmlSchemaFreeAnnot(item->annot);
; 4037 :     xmlFree(item);
; 4038 : }
; 4039 : 
; 4040 : /**
; 4041 :  * xmlSchemaFreeModelGroup:
; 4042 :  * @item:  a schema model group
; 4043 :  *
; 4044 :  * Deallocates a schema model group structure.
; 4045 :  */
; 4046 : static void
; 4047 : xmlSchemaFreeModelGroup(xmlSchemaModelGroupPtr item)
; 4048 : {
; 4049 :     if (item->annot != NULL)
; 4050 : 	xmlSchemaFreeAnnot(item->annot);
; 4051 :     xmlFree(item);
; 4052 : }
; 4053 : 
; 4054 : static void
; 4055 : xmlSchemaComponentListFree(xmlSchemaItemListPtr list)
; 4056 : {
; 4057 :     if ((list == NULL) || (list->nbItems == 0))
; 4058 : 	return;
; 4059 :     {
; 4060 : 	xmlSchemaTreeItemPtr item;
; 4061 : 	xmlSchemaTreeItemPtr *items = (xmlSchemaTreeItemPtr *) list->items;
; 4062 : 	int i;
; 4063 : 
; 4064 : 	for (i = 0; i < list->nbItems; i++) {
; 4065 : 	    item = items[i];
; 4066 : 	    if (item == NULL)
; 4067 : 		continue;
; 4068 : 	    switch (item->type) {
; 4069 : 		case XML_SCHEMA_TYPE_SIMPLE:
; 4070 : 		case XML_SCHEMA_TYPE_COMPLEX:
; 4071 : 		    xmlSchemaFreeType((xmlSchemaTypePtr) item);
; 4072 : 		    break;
; 4073 : 		case XML_SCHEMA_TYPE_ATTRIBUTE:
; 4074 : 		    xmlSchemaFreeAttribute((xmlSchemaAttributePtr) item);
; 4075 : 		    break;
; 4076 : 		case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
; 4077 : 		    xmlSchemaFreeAttributeUse((xmlSchemaAttributeUsePtr) item);
; 4078 : 		    break;
; 4079 : 		case XML_SCHEMA_EXTRA_ATTR_USE_PROHIB:
; 4080 : 		    xmlSchemaFreeAttributeUseProhib(
; 4081 : 			(xmlSchemaAttributeUseProhibPtr) item);
; 4082 : 		    break;
; 4083 : 		case XML_SCHEMA_TYPE_ELEMENT:
; 4084 : 		    xmlSchemaFreeElement((xmlSchemaElementPtr) item);
; 4085 : 		    break;
; 4086 : 		case XML_SCHEMA_TYPE_PARTICLE:
; 4087 : 		    if (item->annot != NULL)
; 4088 : 			xmlSchemaFreeAnnot(item->annot);
; 4089 : 		    xmlFree(item);
; 4090 : 		    break;
; 4091 : 		case XML_SCHEMA_TYPE_SEQUENCE:
; 4092 : 		case XML_SCHEMA_TYPE_CHOICE:
; 4093 : 		case XML_SCHEMA_TYPE_ALL:
; 4094 : 		    xmlSchemaFreeModelGroup((xmlSchemaModelGroupPtr) item);
; 4095 : 		    break;
; 4096 : 		case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 4097 : 		    xmlSchemaFreeAttributeGroup(
; 4098 : 			(xmlSchemaAttributeGroupPtr) item);
; 4099 : 		    break;
; 4100 : 		case XML_SCHEMA_TYPE_GROUP:
; 4101 : 		    xmlSchemaFreeModelGroupDef(
; 4102 : 			(xmlSchemaModelGroupDefPtr) item);
; 4103 : 		    break;
; 4104 : 		case XML_SCHEMA_TYPE_ANY:
; 4105 : 		case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:
; 4106 : 		    xmlSchemaFreeWildcard((xmlSchemaWildcardPtr) item);
; 4107 : 		    break;
; 4108 : 		case XML_SCHEMA_TYPE_IDC_KEY:
; 4109 : 		case XML_SCHEMA_TYPE_IDC_UNIQUE:
; 4110 : 		case XML_SCHEMA_TYPE_IDC_KEYREF:
; 4111 : 		    xmlSchemaFreeIDC((xmlSchemaIDCPtr) item);
; 4112 : 		    break;
; 4113 : 		case XML_SCHEMA_TYPE_NOTATION:
; 4114 : 		    xmlSchemaFreeNotation((xmlSchemaNotationPtr) item);
; 4115 : 		    break;
; 4116 : 		case XML_SCHEMA_EXTRA_QNAMEREF:
; 4117 : 		    xmlSchemaFreeQNameRef((xmlSchemaQNameRefPtr) item);
; 4118 : 		    break;
; 4119 : 		default: {
; 4120 : 		    /* TODO: This should never be hit. */
; 4121 : 		    xmlSchemaPSimpleInternalErr(NULL,
; 4122 : 			"Internal error: xmlSchemaComponentListFree, "
; 4123 : 			"unexpected component type '%s'\n",
; 4124 : 			(const xmlChar *) WXS_ITEM_TYPE_NAME(item));
; 4125 : 			 }
; 4126 : 		    break;
; 4127 : 	    }
; 4128 : 	}
; 4129 : 	list->nbItems = 0;
; 4130 :     }
; 4131 : }
; 4132 : 
; 4133 : /**
; 4134 :  * xmlSchemaFree:
; 4135 :  * @schema:  a schema structure
; 4136 :  *
; 4137 :  * Deallocate a Schema structure.
; 4138 :  */
; 4139 : void
; 4140 : xmlSchemaFree(xmlSchemaPtr schema)
; 4141 : {
; 4142 :     if (schema == NULL)
; 4143 :         return;
; 4144 :     /* @volatiles is not used anymore :-/ */
; 4145 :     if (schema->volatiles != NULL)
; 4146 : 	TODO
; 4147 :     /*
; 4148 :     * Note that those slots are not responsible for freeing
; 4149 :     * schema components anymore; this will now be done by
; 4150 :     * the schema buckets.
; 4151 :     */
; 4152 :     if (schema->notaDecl != NULL)
; 4153 :         xmlHashFree(schema->notaDecl, NULL);
; 4154 :     if (schema->attrDecl != NULL)
; 4155 :         xmlHashFree(schema->attrDecl, NULL);
; 4156 :     if (schema->attrgrpDecl != NULL)
; 4157 :         xmlHashFree(schema->attrgrpDecl, NULL);
; 4158 :     if (schema->elemDecl != NULL)
; 4159 :         xmlHashFree(schema->elemDecl, NULL);
; 4160 :     if (schema->typeDecl != NULL)
; 4161 :         xmlHashFree(schema->typeDecl, NULL);
; 4162 :     if (schema->groupDecl != NULL)
; 4163 :         xmlHashFree(schema->groupDecl, NULL);
; 4164 :     if (schema->idcDef != NULL)
; 4165 :         xmlHashFree(schema->idcDef, NULL);
; 4166 : 
; 4167 :     if (schema->schemasImports != NULL)
; 4168 : 	xmlHashFree(schema->schemasImports, xmlSchemaBucketFreeEntry);
; 4169 :     if (schema->includes != NULL) {
; 4170 : 	xmlSchemaItemListPtr list = (xmlSchemaItemListPtr) schema->includes;
; 4171 : 	int i;
; 4172 : 	for (i = 0; i < list->nbItems; i++) {
; 4173 : 	    xmlSchemaBucketFree((xmlSchemaBucketPtr) list->items[i]);
; 4174 : 	}
; 4175 : 	xmlSchemaItemListFree(list);
; 4176 :     }
; 4177 :     if (schema->annot != NULL)
; 4178 :         xmlSchemaFreeAnnot(schema->annot);
; 4179 :     /* Never free the doc here, since this will be done by the buckets. */
; 4180 : 
; 4181 :     xmlDictFree(schema->dict);
; 4182 :     xmlFree(schema);
; 4183 : }
; 4184 : 
; 4185 : /************************************************************************
; 4186 :  *									*
; 4187 :  *			Debug functions					*
; 4188 :  *									*
; 4189 :  ************************************************************************/
; 4190 : 
; 4191 : #ifdef LIBXML_OUTPUT_ENABLED
; 4192 : 
; 4193 : static void
; 4194 : xmlSchemaTypeDump(xmlSchemaTypePtr type, FILE * output); /* forward */
; 4195 : 
; 4196 : /**
; 4197 :  * xmlSchemaElementDump:
; 4198 :  * @elem:  an element
; 4199 :  * @output:  the file output
; 4200 :  *
; 4201 :  * Dump the element
; 4202 :  */
; 4203 : static void
; 4204 : xmlSchemaElementDump(void *payload, void *data,
; 4205 :                      const xmlChar * name ATTRIBUTE_UNUSED,
; 4206 : 		     const xmlChar * namespace ATTRIBUTE_UNUSED,
; 4207 :                      const xmlChar * context ATTRIBUTE_UNUSED)
; 4208 : {
; 4209 :     xmlSchemaElementPtr elem = (xmlSchemaElementPtr) payload;
; 4210 :     FILE *output = (FILE *) data;
; 4211 :     if (elem == NULL)
; 4212 :         return;
; 4213 : 
; 4214 : 
; 4215 :     fprintf(output, "Element");
; 4216 :     if (elem->flags & XML_SCHEMAS_ELEM_GLOBAL)
; 4217 : 	fprintf(output, " (global)");
; 4218 :     fprintf(output, ": '%s' ", elem->name);
; 4219 :     if (namespace != NULL)
; 4220 : 	fprintf(output, "ns '%s'", namespace);
; 4221 :     fprintf(output, "\n");
; 4222 : #if 0
; 4223 :     if ((elem->minOccurs != 1) || (elem->maxOccurs != 1)) {
; 4224 : 	fprintf(output, "  min %d ", elem->minOccurs);
; 4225 :         if (elem->maxOccurs >= UNBOUNDED)
; 4226 :             fprintf(output, "max: unbounded\n");
; 4227 :         else if (elem->maxOccurs != 1)
; 4228 :             fprintf(output, "max: %d\n", elem->maxOccurs);
; 4229 :         else
; 4230 :             fprintf(output, "\n");
; 4231 :     }
; 4232 : #endif
; 4233 :     /*
; 4234 :     * Misc other properties.
; 4235 :     */
; 4236 :     if ((elem->flags & XML_SCHEMAS_ELEM_NILLABLE) ||
; 4237 : 	(elem->flags & XML_SCHEMAS_ELEM_ABSTRACT) ||
; 4238 : 	(elem->flags & XML_SCHEMAS_ELEM_FIXED) ||
; 4239 : 	(elem->flags & XML_SCHEMAS_ELEM_DEFAULT)) {
; 4240 : 	fprintf(output, "  props: ");
; 4241 : 	if (elem->flags & XML_SCHEMAS_ELEM_FIXED)
; 4242 : 	    fprintf(output, "[fixed] ");
; 4243 : 	if (elem->flags & XML_SCHEMAS_ELEM_DEFAULT)
; 4244 : 	    fprintf(output, "[default] ");
; 4245 : 	if (elem->flags & XML_SCHEMAS_ELEM_ABSTRACT)
; 4246 : 	    fprintf(output, "[abstract] ");
; 4247 : 	if (elem->flags & XML_SCHEMAS_ELEM_NILLABLE)
; 4248 : 	    fprintf(output, "[nillable] ");
; 4249 : 	fprintf(output, "\n");
; 4250 :     }
; 4251 :     /*
; 4252 :     * Default/fixed value.
; 4253 :     */
; 4254 :     if (elem->value != NULL)
; 4255 : 	fprintf(output, "  value: '%s'\n", elem->value);
; 4256 :     /*
; 4257 :     * Type.
; 4258 :     */
; 4259 :     if (elem->namedType != NULL) {
; 4260 : 	fprintf(output, "  type: '%s' ", elem->namedType);
; 4261 : 	if (elem->namedTypeNs != NULL)
; 4262 : 	    fprintf(output, "ns '%s'\n", elem->namedTypeNs);
; 4263 : 	else
; 4264 : 	    fprintf(output, "\n");
; 4265 :     } else if (elem->subtypes != NULL) {
; 4266 : 	/*
; 4267 : 	* Dump local types.
; 4268 : 	*/
; 4269 : 	xmlSchemaTypeDump(elem->subtypes, output);
; 4270 :     }
; 4271 :     /*
; 4272 :     * Substitution group.
; 4273 :     */
; 4274 :     if (elem->substGroup != NULL) {
; 4275 : 	fprintf(output, "  substitutionGroup: '%s' ", elem->substGroup);
; 4276 : 	if (elem->substGroupNs != NULL)
; 4277 : 	    fprintf(output, "ns '%s'\n", elem->substGroupNs);
; 4278 : 	else
; 4279 : 	    fprintf(output, "\n");
; 4280 :     }
; 4281 : }
; 4282 : 
; 4283 : /**
; 4284 :  * xmlSchemaAnnotDump:
; 4285 :  * @output:  the file output
; 4286 :  * @annot:  a annotation
; 4287 :  *
; 4288 :  * Dump the annotation
; 4289 :  */
; 4290 : static void
; 4291 : xmlSchemaAnnotDump(FILE * output, xmlSchemaAnnotPtr annot)
; 4292 : {
; 4293 :     xmlChar *content;
; 4294 : 
; 4295 :     if (annot == NULL)
; 4296 :         return;
; 4297 : 
; 4298 :     content = xmlNodeGetContent(annot->content);
; 4299 :     if (content != NULL) {
; 4300 :         fprintf(output, "  Annot: %s\n", content);
; 4301 :         xmlFree(content);
; 4302 :     } else
; 4303 :         fprintf(output, "  Annot: empty\n");
; 4304 : }
; 4305 : 
; 4306 : /**
; 4307 :  * xmlSchemaContentModelDump:
; 4308 :  * @particle: the schema particle
; 4309 :  * @output: the file output
; 4310 :  * @depth: the depth used for intentation
; 4311 :  *
; 4312 :  * Dump a SchemaType structure
; 4313 :  */
; 4314 : static void
; 4315 : xmlSchemaContentModelDump(xmlSchemaParticlePtr particle, FILE * output, int depth)
; 4316 : {
; 4317 :     xmlChar *str = NULL;
; 4318 :     xmlSchemaTreeItemPtr term;
; 4319 :     char shift[100];
; 4320 :     int i;
; 4321 : 
; 4322 :     if (particle == NULL)
; 4323 : 	return;
; 4324 :     for (i = 0;((i < depth) && (i < 25));i++)
; 4325 :         shift[2 * i] = shift[2 * i + 1] = ' ';
; 4326 :     shift[2 * i] = shift[2 * i + 1] = 0;
; 4327 :     fprintf(output, "%s", shift);
; 4328 :     if (particle->children == NULL) {
; 4329 : 	fprintf(output, "MISSING particle term\n");
; 4330 : 	return;
; 4331 :     }
; 4332 :     term = particle->children;
; 4333 :     if (term == NULL) {
; 4334 : 	fprintf(output, "(NULL)");
; 4335 :     } else {
; 4336 : 	switch (term->type) {
; 4337 : 	    case XML_SCHEMA_TYPE_ELEMENT:
; 4338 : 		fprintf(output, "ELEM '%s'", xmlSchemaFormatQName(&str,
; 4339 : 		    ((xmlSchemaElementPtr)term)->targetNamespace,
; 4340 : 		    ((xmlSchemaElementPtr)term)->name));
; 4341 : 		FREE_AND_NULL(str);
; 4342 : 		break;
; 4343 : 	    case XML_SCHEMA_TYPE_SEQUENCE:
; 4344 : 		fprintf(output, "SEQUENCE");
; 4345 : 		break;
; 4346 : 	    case XML_SCHEMA_TYPE_CHOICE:
; 4347 : 		fprintf(output, "CHOICE");
; 4348 : 		break;
; 4349 : 	    case XML_SCHEMA_TYPE_ALL:
; 4350 : 		fprintf(output, "ALL");
; 4351 : 		break;
; 4352 : 	    case XML_SCHEMA_TYPE_ANY:
; 4353 : 		fprintf(output, "ANY");
; 4354 : 		break;
; 4355 : 	    default:
; 4356 : 		fprintf(output, "UNKNOWN\n");
; 4357 : 		return;
; 4358 : 	}
; 4359 :     }
; 4360 :     if (particle->minOccurs != 1)
; 4361 : 	fprintf(output, " min: %d", particle->minOccurs);
; 4362 :     if (particle->maxOccurs >= UNBOUNDED)
; 4363 : 	fprintf(output, " max: unbounded");
; 4364 :     else if (particle->maxOccurs != 1)
; 4365 : 	fprintf(output, " max: %d", particle->maxOccurs);
; 4366 :     fprintf(output, "\n");
; 4367 :     if (term &&
; 4368 : 	((term->type == XML_SCHEMA_TYPE_SEQUENCE) ||
; 4369 : 	 (term->type == XML_SCHEMA_TYPE_CHOICE) ||
; 4370 : 	 (term->type == XML_SCHEMA_TYPE_ALL)) &&
; 4371 : 	 (term->children != NULL)) {
; 4372 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) term->children,
; 4373 : 	    output, depth +1);
; 4374 :     }
; 4375 :     if (particle->next != NULL)
; 4376 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) particle->next,
; 4377 : 		output, depth);
; 4378 : }
; 4379 : 
; 4380 : /**
; 4381 :  * xmlSchemaAttrUsesDump:
; 4382 :  * @uses:  attribute uses list
; 4383 :  * @output:  the file output
; 4384 :  *
; 4385 :  * Dumps a list of attribute use components.
; 4386 :  */
; 4387 : static void
; 4388 : xmlSchemaAttrUsesDump(xmlSchemaItemListPtr uses, FILE * output)
; 4389 : {
; 4390 :     xmlSchemaAttributeUsePtr use;
; 4391 :     xmlSchemaAttributeUseProhibPtr prohib;
; 4392 :     xmlSchemaQNameRefPtr ref;
; 4393 :     const xmlChar *name, *tns;
; 4394 :     xmlChar *str = NULL;
; 4395 :     int i;
; 4396 : 
; 4397 :     if ((uses == NULL) || (uses->nbItems == 0))
; 4398 :         return;
; 4399 : 
; 4400 :     fprintf(output, "  attributes:\n");
; 4401 :     for (i = 0; i < uses->nbItems; i++) {
; 4402 : 	use = uses->items[i];
; 4403 : 	if (use->type == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB) {
; 4404 : 	    fprintf(output, "  [prohibition] ");
; 4405 : 	    prohib = (xmlSchemaAttributeUseProhibPtr) use;
; 4406 : 	    name = prohib->name;
; 4407 : 	    tns = prohib->targetNamespace;
; 4408 : 	} else if (use->type == XML_SCHEMA_EXTRA_QNAMEREF) {
; 4409 : 	    fprintf(output, "  [reference] ");
; 4410 : 	    ref = (xmlSchemaQNameRefPtr) use;
; 4411 : 	    name = ref->name;
; 4412 : 	    tns = ref->targetNamespace;
; 4413 : 	} else {
; 4414 : 	    fprintf(output, "  [use] ");
; 4415 : 	    name = WXS_ATTRUSE_DECL_NAME(use);
; 4416 : 	    tns = WXS_ATTRUSE_DECL_TNS(use);
; 4417 : 	}
; 4418 : 	fprintf(output, "'%s'\n",
; 4419 : 	    (const char *) xmlSchemaFormatQName(&str, tns, name));
; 4420 : 	FREE_AND_NULL(str);
; 4421 :     }
; 4422 : }
; 4423 : 
; 4424 : /**
; 4425 :  * xmlSchemaTypeDump:
; 4426 :  * @output:  the file output
; 4427 :  * @type:  a type structure
; 4428 :  *
; 4429 :  * Dump a SchemaType structure
; 4430 :  */
; 4431 : static void
; 4432 : xmlSchemaTypeDump(xmlSchemaTypePtr type, FILE * output)
; 4433 : {
; 4434 :     if (type == NULL) {
; 4435 :         fprintf(output, "Type: NULL\n");
; 4436 :         return;
; 4437 :     }
; 4438 :     fprintf(output, "Type: ");
; 4439 :     if (type->name != NULL)
; 4440 :         fprintf(output, "'%s' ", type->name);
; 4441 :     else
; 4442 :         fprintf(output, "(no name) ");
; 4443 :     if (type->targetNamespace != NULL)
; 4444 : 	fprintf(output, "ns '%s' ", type->targetNamespace);
; 4445 :     switch (type->type) {
; 4446 :         case XML_SCHEMA_TYPE_BASIC:
; 4447 :             fprintf(output, "[basic] ");
; 4448 :             break;
; 4449 :         case XML_SCHEMA_TYPE_SIMPLE:
; 4450 :             fprintf(output, "[simple] ");
; 4451 :             break;
; 4452 :         case XML_SCHEMA_TYPE_COMPLEX:
; 4453 :             fprintf(output, "[complex] ");
; 4454 :             break;
; 4455 :         case XML_SCHEMA_TYPE_SEQUENCE:
; 4456 :             fprintf(output, "[sequence] ");
; 4457 :             break;
; 4458 :         case XML_SCHEMA_TYPE_CHOICE:
; 4459 :             fprintf(output, "[choice] ");
; 4460 :             break;
; 4461 :         case XML_SCHEMA_TYPE_ALL:
; 4462 :             fprintf(output, "[all] ");
; 4463 :             break;
; 4464 :         case XML_SCHEMA_TYPE_UR:
; 4465 :             fprintf(output, "[ur] ");
; 4466 :             break;
; 4467 :         case XML_SCHEMA_TYPE_RESTRICTION:
; 4468 :             fprintf(output, "[restriction] ");
; 4469 :             break;
; 4470 :         case XML_SCHEMA_TYPE_EXTENSION:
; 4471 :             fprintf(output, "[extension] ");
; 4472 :             break;
; 4473 :         default:
; 4474 :             fprintf(output, "[unknown type %d] ", type->type);
; 4475 :             break;
; 4476 :     }
; 4477 :     fprintf(output, "content: ");
; 4478 :     switch (type->contentType) {
; 4479 :         case XML_SCHEMA_CONTENT_UNKNOWN:
; 4480 :             fprintf(output, "[unknown] ");
; 4481 :             break;
; 4482 :         case XML_SCHEMA_CONTENT_EMPTY:
; 4483 :             fprintf(output, "[empty] ");
; 4484 :             break;
; 4485 :         case XML_SCHEMA_CONTENT_ELEMENTS:
; 4486 :             fprintf(output, "[element] ");
; 4487 :             break;
; 4488 :         case XML_SCHEMA_CONTENT_MIXED:
; 4489 :             fprintf(output, "[mixed] ");
; 4490 :             break;
; 4491 :         case XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS:
; 4492 : 	/* not used. */
; 4493 :             break;
; 4494 :         case XML_SCHEMA_CONTENT_BASIC:
; 4495 :             fprintf(output, "[basic] ");
; 4496 :             break;
; 4497 :         case XML_SCHEMA_CONTENT_SIMPLE:
; 4498 :             fprintf(output, "[simple] ");
; 4499 :             break;
; 4500 :         case XML_SCHEMA_CONTENT_ANY:
; 4501 :             fprintf(output, "[any] ");
; 4502 :             break;
; 4503 :     }
; 4504 :     fprintf(output, "\n");
; 4505 :     if (type->base != NULL) {
; 4506 :         fprintf(output, "  base type: '%s'", type->base);
; 4507 : 	if (type->baseNs != NULL)
; 4508 : 	    fprintf(output, " ns '%s'\n", type->baseNs);
; 4509 : 	else
; 4510 : 	    fprintf(output, "\n");
; 4511 :     }
; 4512 :     if (type->attrUses != NULL)
; 4513 : 	xmlSchemaAttrUsesDump(type->attrUses, output);
; 4514 :     if (type->annot != NULL)
; 4515 :         xmlSchemaAnnotDump(output, type->annot);
; 4516 : #ifdef DUMP_CONTENT_MODEL
; 4517 :     if ((type->type == XML_SCHEMA_TYPE_COMPLEX) &&
; 4518 : 	(type->subtypes != NULL)) {
; 4519 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) type->subtypes,
; 4520 : 	    output, 1);
; 4521 :     }
; 4522 : #endif
; 4523 : }
; 4524 : 
; 4525 : static void
; 4526 : xmlSchemaTypeDumpEntry(void *type, void *output,
; 4527 :                        const xmlChar *name ATTRIBUTE_UNUSED)
; 4528 : {
; 4529 :     xmlSchemaTypeDump((xmlSchemaTypePtr) type, (FILE *) output);
; 4530 : }
; 4531 : 
; 4532 : /**
; 4533 :  * xmlSchemaDump:
; 4534 :  * @output:  the file output
; 4535 :  * @schema:  a schema structure
; 4536 :  *
; 4537 :  * Dump a Schema structure.
; 4538 :  */
; 4539 : void
; 4540 : xmlSchemaDump(FILE * output, xmlSchemaPtr schema)
; 4541 : {
; 4542 :     if (output == NULL)
; 4543 :         return;
; 4544 :     if (schema == NULL) {
; 4545 :         fprintf(output, "Schemas: NULL\n");
; 4546 :         return;
; 4547 :     }
; 4548 :     fprintf(output, "Schemas: ");
; 4549 :     if (schema->name != NULL)
; 4550 :         fprintf(output, "%s, ", schema->name);
; 4551 :     else
; 4552 :         fprintf(output, "no name, ");
; 4553 :     if (schema->targetNamespace != NULL)
; 4554 :         fprintf(output, "%s", (const char *) schema->targetNamespace);
; 4555 :     else
; 4556 :         fprintf(output, "no target namespace");
; 4557 :     fprintf(output, "\n");
; 4558 :     if (schema->annot != NULL)
; 4559 :         xmlSchemaAnnotDump(output, schema->annot);
; 4560 :     xmlHashScan(schema->typeDecl, xmlSchemaTypeDumpEntry, output);
; 4561 :     xmlHashScanFull(schema->elemDecl, xmlSchemaElementDump, output);
; 4562 : }
; 4563 : 
; 4564 : #ifdef DEBUG_IDC_NODE_TABLE
; 4565 : /**
; 4566 :  * xmlSchemaDebugDumpIDCTable:
; 4567 :  * @vctxt: the WXS validation context
; 4568 :  *
; 4569 :  * Displays the current IDC table for debug purposes.
; 4570 :  */
; 4571 : static void
; 4572 : xmlSchemaDebugDumpIDCTable(FILE * output,
; 4573 : 			   const xmlChar *namespaceName,
; 4574 : 			   const xmlChar *localName,
; 4575 : 			   xmlSchemaPSVIIDCBindingPtr bind)
; 4576 : {
; 4577 :     xmlChar *str = NULL;
; 4578 :     const xmlChar *value;
; 4579 :     xmlSchemaPSVIIDCNodePtr tab;
; 4580 :     xmlSchemaPSVIIDCKeyPtr key;
; 4581 :     int i, j, res;
; 4582 : 
; 4583 :     fprintf(output, "IDC: TABLES on '%s'\n",
; 4584 : 	xmlSchemaFormatQName(&str, namespaceName, localName));
; 4585 :     FREE_AND_NULL(str)
; 4586 : 
; 4587 :     if (bind == NULL)
; 4588 : 	return;
; 4589 :     do {
; 4590 : 	fprintf(output, "IDC:   BINDING '%s' (%d)\n",
; 4591 : 	    xmlSchemaGetComponentQName(&str,
; 4592 : 		bind->definition), bind->nbNodes);
; 4593 : 	FREE_AND_NULL(str)
; 4594 : 	for (i = 0; i < bind->nbNodes; i++) {
; 4595 : 	    tab = bind->nodeTable[i];
; 4596 : 	    fprintf(output, "         ( ");
; 4597 : 	    for (j = 0; j < bind->definition->nbFields; j++) {
; 4598 : 		key = tab->keys[j];
; 4599 : 		if ((key != NULL) && (key->val != NULL)) {
; 4600 : 		    res = xmlSchemaGetCanonValue(key->val, &value);
; 4601 : 		    if (res >= 0)
; 4602 : 			fprintf(output, "'%s' ", value);
; 4603 : 		    else
; 4604 : 			fprintf(output, "CANON-VALUE-FAILED ");
; 4605 : 		    if (res == 0)
; 4606 : 			FREE_AND_NULL(value)
; 4607 : 		} else if (key != NULL)
; 4608 : 		    fprintf(output, "(no val), ");
; 4609 : 		else
; 4610 : 		    fprintf(output, "(key missing), ");
; 4611 : 	    }
; 4612 : 	    fprintf(output, ")\n");
; 4613 : 	}
; 4614 : 	if (bind->dupls && bind->dupls->nbItems) {
; 4615 : 	    fprintf(output, "IDC:     dupls (%d):\n", bind->dupls->nbItems);
; 4616 : 	    for (i = 0; i < bind->dupls->nbItems; i++) {
; 4617 : 		tab = bind->dupls->items[i];
; 4618 : 		fprintf(output, "         ( ");
; 4619 : 		for (j = 0; j < bind->definition->nbFields; j++) {
; 4620 : 		    key = tab->keys[j];
; 4621 : 		    if ((key != NULL) && (key->val != NULL)) {
; 4622 : 			res = xmlSchemaGetCanonValue(key->val, &value);
; 4623 : 			if (res >= 0)
; 4624 : 			    fprintf(output, "'%s' ", value);
; 4625 : 			else
; 4626 : 			    fprintf(output, "CANON-VALUE-FAILED ");
; 4627 : 			if (res == 0)
; 4628 : 			    FREE_AND_NULL(value)
; 4629 : 		    } else if (key != NULL)
; 4630 : 		    fprintf(output, "(no val), ");
; 4631 : 			else
; 4632 : 			    fprintf(output, "(key missing), ");
; 4633 : 		}
; 4634 : 		fprintf(output, ")\n");
; 4635 : 	    }
; 4636 : 	}
; 4637 : 	bind = bind->next;
; 4638 :     } while (bind != NULL);
; 4639 : }
; 4640 : #endif /* DEBUG_IDC */
; 4641 : #endif /* LIBXML_OUTPUT_ENABLED */
; 4642 : 
; 4643 : /************************************************************************
; 4644 :  *									*
; 4645 :  *			Utilities					*
; 4646 :  *									*
; 4647 :  ************************************************************************/
; 4648 : 
; 4649 : /**
; 4650 :  * xmlSchemaGetPropNode:
; 4651 :  * @node: the element node
; 4652 :  * @name: the name of the attribute
; 4653 :  *
; 4654 :  * Seeks an attribute with a name of @name in
; 4655 :  * no namespace.
; 4656 :  *
; 4657 :  * Returns the attribute or NULL if not present.
; 4658 :  */
; 4659 : static xmlAttrPtr
; 4660 : xmlSchemaGetPropNode(xmlNodePtr node, const char *name)
; 4661 : {
; 4662 :     xmlAttrPtr prop;
; 4663 : 
; 4664 :     if ((node == NULL) || (name == NULL))
; 4665 : 	return(NULL);
; 4666 :     prop = node->properties;
; 4667 :     while (prop != NULL) {

	jmp	SHORT $LN60@xmlSchemaP
$LN19@xmlSchemaP:

; 6041 :     return(xmlSchemaPValAttrNodeID(ctxt, attr));

	push	esi
	push	edi
	call	_xmlSchemaPValAttrNodeID
	add	esp, 8
$LN60@xmlSchemaP:

; 6963 :     }
; 6964 :     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
; 6965 :     /*
; 6966 :     * minOccurs/maxOccurs.
; 6967 :     */
; 6968 :     max = xmlGetMaxOccurs(ctxt, node, 0, UNBOUNDED, 1,

	push	OFFSET ??_C@_0CE@BEMOBFLH@?$CIxs?3nonNegativeInteger?5?$HM?5unboun@
	push	1
	push	1073741824				; 40000000H
	push	0
	push	ebx
	push	edi
	call	_xmlGetMaxOccurs

; 6969 : 	"(xs:nonNegativeInteger | unbounded)");
; 6970 :     min = xmlGetMinOccurs(ctxt, node, 0, -1, 1,

	push	OFFSET ??_C@_0BG@FKFDAFPO@xs?3nonNegativeInteger@
	push	1
	push	-1
	push	0
	mov	esi, eax
	push	ebx
	push	edi
	mov	DWORD PTR _max$1$[ebp], esi
	call	_xmlGetMinOccurs

; 6971 : 	"xs:nonNegativeInteger");
; 6972 :     xmlSchemaPCheckParticleCorrect_2(ctxt, NULL, node, min, max);

	push	esi
	push	eax
	push	ebx
	push	0
	push	edi
	mov	DWORD PTR _min$1$[ebp], eax
	call	_xmlSchemaPCheckParticleCorrect_2

; 6973 :     /*
; 6974 :     * Create & parse the wildcard.
; 6975 :     */
; 6976 :     wild = xmlSchemaAddWildcard(ctxt, schema, XML_SCHEMA_TYPE_ANY, node);

	mov	esi, DWORD PTR _schema$[ebp]
	add	esp, 68					; 00000044H
	push	ebx
	push	2
	push	esi
	push	edi
	call	_xmlSchemaAddWildcard
	add	esp, 16					; 00000010H
	mov	DWORD PTR _wild$1$[ebp], eax

; 6977 :     if (wild == NULL)

	test	eax, eax
	je	$LN5@xmlSchemaP

; 6978 : 	return (NULL);
; 6979 :     xmlSchemaParseWildcardNs(ctxt, schema, wild, node);

	push	ebx
	push	eax
	push	esi
	push	edi
	call	_xmlSchemaParseWildcardNs

; 6980 :     /*
; 6981 :     * And now for the children...
; 6982 :     */
; 6983 :     child = node->children;

	mov	esi, DWORD PTR [ebx+12]
	add	esp, 16					; 00000010H

; 6984 :     if (IS_SCHEMA(child, "annotation")) {

	test	esi, esi
	je	$LN31@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN11@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlSchemaP

; 6985 :         annot = xmlSchemaParseAnnotation(ctxt, child, 1);

	push	1
	push	esi
	push	edi
	call	_xmlSchemaParseAnnotation

; 6986 :         child = child->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _annot$1$[ebp], eax
$LN11@xmlSchemaP:

; 6987 :     }
; 6988 :     if (child != NULL) {

	test	esi, esi
	je	SHORT $LN31@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	0
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0O@MNAJHLGE@?$CIannotation?$DP?$CJ@
	push	DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	edi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN31@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN31@xmlSchemaP:

; 6989 : 	xmlSchemaPContentErr(ctxt,
; 6990 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 6991 : 	    NULL, node, child,
; 6992 : 	    NULL, "(annotation?)");
; 6993 :     }
; 6994 :     /*
; 6995 :     * No component if minOccurs==maxOccurs==0.
; 6996 :     */
; 6997 :     if ((min == 0) && (max == 0)) {

	mov	ecx, DWORD PTR _min$1$[ebp]
	mov	eax, DWORD PTR _max$1$[ebp]
	test	ecx, ecx
	jne	SHORT $LN13@xmlSchemaP
	test	eax, eax
	je	SHORT $LN5@xmlSchemaP
$LN13@xmlSchemaP:

; 6998 : 	/* Don't free the wildcard, since it's already on the list. */
; 6999 : 	return (NULL);
; 7000 :     }
; 7001 :     /*
; 7002 :     * Create the particle.
; 7003 :     */
; 7004 :     particle = xmlSchemaAddParticle(ctxt, node, min, max);

	push	eax
	push	ecx
	push	ebx
	push	edi
	call	_xmlSchemaAddParticle
	add	esp, 16					; 00000010H

; 7005 :     if (particle == NULL)

	test	eax, eax
	je	SHORT $LN5@xmlSchemaP

; 7006 :         return (NULL);
; 7007 :     particle->annot = annot;

	mov	ecx, DWORD PTR _annot$1$[ebp]
	pop	edi
	mov	DWORD PTR [eax+4], ecx

; 7008 :     particle->children = (xmlSchemaTreeItemPtr) wild;

	mov	ecx, DWORD PTR _wild$1$[ebp]

; 7009 : 
; 7010 :     return (particle);
; 7011 : }

	pop	esi
	mov	DWORD PTR [eax+12], ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlSchemaP:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseAny ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPCheckParticleCorrect_2
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_item$ = 12						; size = 4
_node$ = 16						; size = 4
_minOccurs$ = 20					; size = 4
_maxOccurs$ = 24					; size = 4
_xmlSchemaPCheckParticleCorrect_2 PROC			; COMDAT

; 6879 : 				 int maxOccurs) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _maxOccurs$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaP

; 6880 : 
; 6881 :     if ((maxOccurs == 0) && ( minOccurs == 0))

	cmp	DWORD PTR _minOccurs$[ebp], eax
	jne	SHORT $LN9@xmlSchemaP
$LN6@xmlSchemaP:

; 6913 : 	}
; 6914 :     }
; 6915 :     return (0);

	xor	eax, eax

; 6916 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaP:

; 6882 : 	return (0);
; 6883 :     if (maxOccurs != UNBOUNDED) {

	cmp	eax, 1073741824				; 40000000H
	je	SHORT $LN6@xmlSchemaP

; 6884 : 	/*
; 6885 : 	* TODO: Maybe we should better not create the particle,
; 6886 : 	* if min/max is invalid, since it could confuse the build of the
; 6887 : 	* content model.
; 6888 : 	*/
; 6889 : 	/*
; 6890 : 	* 3.9.6 Schema Component Constraint: Particle Correct
; 6891 : 	*
; 6892 : 	*/
; 6893 : 	if (maxOccurs < 1) {

	cmp	eax, 1
	jge	SHORT $LN4@xmlSchemaP
$LN9@xmlSchemaP:

; 6894 : 	    /*
; 6895 : 	    * 2.2 {max occurs} must be greater than or equal to 1.
; 6896 : 	    */
; 6897 : 	    xmlSchemaPCustomAttrErr(ctxt,

	push	OFFSET ??_C@_0CN@HPDJBJNO@The?5value?5must?5be?5greater?5than?5@
	push	OFFSET ??_C@_09OBPGLENH@maxOccurs@
	push	DWORD PTR _node$[ebp]
	call	_xmlSchemaGetPropNode
	add	esp, 8
	push	eax
	push	0
	push	0
	push	3044					; 00000be4H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPCustomAttrErr
	add	esp, 24					; 00000018H

; 6898 : 		XML_SCHEMAP_P_PROPS_CORRECT_2_2,
; 6899 : 		NULL, NULL,
; 6900 : 		xmlSchemaGetPropNode(node, "maxOccurs"),
; 6901 : 		"The value must be greater than or equal to 1");
; 6902 : 	    return (XML_SCHEMAP_P_PROPS_CORRECT_2_2);

	mov	eax, 3044				; 00000be4H

; 6916 : }

	pop	ebp
	ret	0
$LN4@xmlSchemaP:

; 6903 : 	} else if (minOccurs > maxOccurs) {

	cmp	DWORD PTR _minOccurs$[ebp], eax
	jle	SHORT $LN6@xmlSchemaP

; 6904 : 	    /*
; 6905 : 	    * 2.1 {min occurs} must not be greater than {max occurs}.
; 6906 : 	    */
; 6907 : 	    xmlSchemaPCustomAttrErr(ctxt,

	push	OFFSET ??_C@_0DM@MJPPLMBN@The?5value?5must?5not?5be?5greater?5t@
	push	OFFSET ??_C@_09OAPKCOGD@minOccurs@
	push	DWORD PTR _node$[ebp]
	call	_xmlSchemaGetPropNode
	add	esp, 8
	push	eax
	push	0
	push	0
	push	3043					; 00000be3H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPCustomAttrErr
	add	esp, 24					; 00000018H

; 6908 : 		XML_SCHEMAP_P_PROPS_CORRECT_2_1,
; 6909 : 		NULL, NULL,
; 6910 : 		xmlSchemaGetPropNode(node, "minOccurs"),
; 6911 : 		"The value must not be greater than the value of 'maxOccurs'");
; 6912 : 	    return (XML_SCHEMAP_P_PROPS_CORRECT_2_1);

	mov	eax, 3043				; 00000be3H

; 6916 : }

	pop	ebp
	ret	0
_xmlSchemaPCheckParticleCorrect_2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseWildcardNs
_TEXT	SEGMENT
_lastNs$1$ = -12					; size = 4
_ret$1$ = -8						; size = 4
_expectedEscaped$1 = -4					; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_wildc$ = 16						; size = 4
_msg$2 = 20						; size = 4
_nsItem$1$ = 20						; size = 4
_node$ = 20						; size = 4
_xmlSchemaParseWildcardNs PROC				; COMDAT

; 6769 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4

; 4741 :     val = xmlGetNoNsProp(node, BAD_CAST name);

	mov	ebx, DWORD PTR _node$[ebp]
	push	OFFSET ??_C@_0BA@LJOIJHLO@processContents@
	push	ebx

; 6770 :     const xmlChar *pc, *ns, *dictnsItem;
; 6771 :     int ret = 0;

	mov	DWORD PTR _ret$1$[ebp], 0

; 6772 :     xmlChar *nsItem;
; 6773 :     xmlSchemaWildcardNsPtr tmp, lastNs = NULL;

	mov	DWORD PTR _lastNs$1$[ebp], 0

; 4741 :     val = xmlGetNoNsProp(node, BAD_CAST name);

	call	_xmlGetNoNsProp
	mov	edi, eax
	add	esp, 8

; 4742 :     if (val == NULL)

	test	edi, edi
	je	$LN13@xmlSchemaP

; 4743 :         return(NULL);
; 4744 :     ret = xmlDictLookup(ctxt->dict, val, -1);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	-1
	push	edi
	push	DWORD PTR [eax+80]
	call	_xmlDictLookup

; 4745 :     xmlFree(val);

	push	edi
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H

; 6774 :     xmlAttrPtr attr;
; 6775 : 
; 6776 :     pc = xmlSchemaGetProp(ctxt, node, "processContents");
; 6777 :     if ((pc == NULL)
; 6778 :         || (xmlStrEqual(pc, (const xmlChar *) "strict"))) {

	test	esi, esi
	je	$LN13@xmlSchemaP
	push	OFFSET ??_C@_06OLFOGHEN@strict@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlSchemaP

; 6780 :     } else if (xmlStrEqual(pc, (const xmlChar *) "skip")) {

	push	OFFSET ??_C@_04DLBGLKG@skip@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlSchemaP

; 6781 :         wildc->processContents = XML_SCHEMAS_ANY_SKIP;

	mov	eax, DWORD PTR _wildc$[ebp]
	mov	DWORD PTR [eax+24], 1
	jmp	SHORT $LN120@xmlSchemaP
$LN14@xmlSchemaP:

; 6782 :     } else if (xmlStrEqual(pc, (const xmlChar *) "lax")) {

	push	OFFSET ??_C@_03BLIDKLB@lax@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlSchemaP

; 6783 :         wildc->processContents = XML_SCHEMAS_ANY_LAX;

	mov	eax, DWORD PTR _wildc$[ebp]
	mov	DWORD PTR [eax+24], 2

; 6784 :     } else {

	jmp	SHORT $LN120@xmlSchemaP
$LN16@xmlSchemaP:

; 6785 :         xmlSchemaPSimpleTypeErr(ctxt,

	push	0
	push	0
	push	0
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	OFFSET ??_C@_0BG@JONDLOPH@?$CIstrict?5?$HM?5skip?5?$HM?5lax?$CJ@
	push	0
	push	ebx
	push	0
	push	3037					; 00000bddH
	push	esi
	call	_xmlSchemaPSimpleTypeErr

; 6786 : 	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 6787 : 	    NULL, node,
; 6788 : 	    NULL, "(strict | skip | lax)", pc,
; 6789 : 	    NULL, NULL, NULL);
; 6790 :         wildc->processContents = XML_SCHEMAS_ANY_STRICT;

	mov	eax, DWORD PTR _wildc$[ebp]
	add	esp, 40					; 00000028H

; 6791 : 	ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE;

	mov	DWORD PTR _ret$1$[ebp], 3037		; 00000bddH
	mov	DWORD PTR [eax+24], 3
	jmp	SHORT $LN17@xmlSchemaP
$LN13@xmlSchemaP:

; 6779 :         wildc->processContents = XML_SCHEMAS_ANY_STRICT;

	mov	eax, DWORD PTR _wildc$[ebp]
	mov	DWORD PTR [eax+24], 3
$LN120@xmlSchemaP:

; 4664 :     if ((node == NULL) || (name == NULL))

	mov	esi, DWORD PTR _ctxt$[ebp]
$LN17@xmlSchemaP:
	test	ebx, ebx
	je	SHORT $LN49@xmlSchemaP

; 4665 : 	return(NULL);
; 4666 :     prop = node->properties;

	mov	ebx, DWORD PTR [ebx+44]

; 4667 :     while (prop != NULL) {

	test	ebx, ebx
	je	SHORT $LN49@xmlSchemaP
	npad	7
$LL46@xmlSchemaP:

; 4668 :         if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))

	cmp	DWORD PTR [ebx+36], 0
	jne	SHORT $LN50@xmlSchemaP
	push	OFFSET ??_C@_09KPMGAFNI@namespace@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN45@xmlSchemaP
$LN50@xmlSchemaP:

; 4669 : 	    return(prop);
; 4670 : 	prop = prop->next;

	mov	ebx, DWORD PTR [ebx+24]
	test	ebx, ebx
	jne	SHORT $LL46@xmlSchemaP
$LN49@xmlSchemaP:

; 4710 :     val = xmlNodeGetContent(node);

	xor	ebx, ebx
$LN45@xmlSchemaP:
	push	ebx
	call	_xmlNodeGetContent
	mov	edi, eax
	add	esp, 4

; 4711 :     if (val == NULL)

	test	edi, edi
	jne	SHORT $LN53@xmlSchemaP

; 4712 : 	val = xmlStrdup((xmlChar *)"");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	edi, eax
$LN53@xmlSchemaP:

; 4713 :     ret = xmlDictLookup(ctxt->dict, val, -1);

	push	-1
	push	edi
	push	DWORD PTR [esi+80]
	call	_xmlDictLookup

; 4714 :     xmlFree(val);

	push	edi
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H

; 6792 :     }
; 6793 :     /*
; 6794 :      * Build the namespace constraints.
; 6795 :      */
; 6796 :     attr = xmlSchemaGetPropNode(node, "namespace");
; 6797 :     ns = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
; 6798 :     if ((attr == NULL) || (xmlStrEqual(ns, BAD_CAST "##any")))

	test	ebx, ebx
	je	$LN20@xmlSchemaP
	push	OFFSET ??_C@_05HGEKMIOD@?$CD?$CDany@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN20@xmlSchemaP

; 6800 :     else if (xmlStrEqual(ns, BAD_CAST "##other")) {

	push	OFFSET ??_C@_07ELAGFAPB@?$CD?$CDother@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LL5@xmlSchemaP

; 6801 : 	wildc->negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	ebx
	call	_xmlSchemaNewWildcardNsConstraint
	mov	ecx, eax
	add	esp, 4
	mov	eax, DWORD PTR _wildc$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 6802 : 	if (wildc->negNsSet == NULL) {

	test	ecx, ecx
	je	$LN124@xmlSchemaP

; 6803 : 	    return (-1);
; 6804 : 	}
; 6805 : 	wildc->negNsSet->value = ctxt->targetNamespace;

	mov	eax, DWORD PTR [ebx+112]
	pop	edi

; 6872 : }

	pop	esi
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LL5@xmlSchemaP:

; 6806 :     } else {
; 6807 : 	const xmlChar *end, *cur;
; 6808 : 
; 6809 : 	cur = ns;
; 6810 : 	do {
; 6811 : 	    while (IS_BLANK_CH(*cur))

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN24@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN25@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN24@xmlSchemaP
$LN25@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN6@xmlSchemaP
$LN24@xmlSchemaP:

; 6812 : 		cur++;

	inc	esi
	jmp	SHORT $LL5@xmlSchemaP
$LN6@xmlSchemaP:

; 6813 : 	    end = cur;

	mov	edi, esi

; 6814 : 	    while ((*end != 0) && (!(IS_BLANK_CH(*end))))

	test	al, al
	je	$LN3@xmlSchemaP
$LL7@xmlSchemaP:
	cmp	al, 32					; 00000020H
	je	SHORT $LN8@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN26@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN8@xmlSchemaP
$LN26@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN8@xmlSchemaP
	mov	al, BYTE PTR [edi+1]

; 6815 : 		end++;

	inc	edi
	test	al, al
	jne	SHORT $LL7@xmlSchemaP
$LN8@xmlSchemaP:

; 6816 : 	    if (end == cur)

	cmp	edi, esi
	je	$LN3@xmlSchemaP

; 6817 : 		break;
; 6818 : 	    nsItem = xmlStrndup(cur, end - cur);

	mov	eax, edi
	sub	eax, esi
	push	eax
	push	esi
	call	_xmlStrndup
	mov	esi, eax

; 6819 : 	    if ((xmlStrEqual(nsItem, BAD_CAST "##other")) ||

	push	OFFSET ??_C@_07ELAGFAPB@?$CD?$CDother@
	push	esi
	mov	DWORD PTR _nsItem$1$[ebp], esi
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN30@xmlSchemaP
	push	OFFSET ??_C@_05HGEKMIOD@?$CD?$CDany@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN30@xmlSchemaP

; 6829 : 	    } else {
; 6830 : 		if (xmlStrEqual(nsItem, BAD_CAST "##targetNamespace")) {

	push	OFFSET ??_C@_0BC@NIOKFNAN@?$CD?$CDtargetNamespace@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN31@xmlSchemaP

; 6831 : 		    dictnsItem = ctxt->targetNamespace;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	esi, DWORD PTR [ecx+112]
	jmp	SHORT $LN34@xmlSchemaP
$LN31@xmlSchemaP:

; 6832 : 		} else if (xmlStrEqual(nsItem, BAD_CAST "##local")) {

	push	OFFSET ??_C@_07NOOLJEMO@?$CD?$CDlocal@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@xmlSchemaP

; 6833 : 		    dictnsItem = NULL;

	xor	esi, esi

; 6834 : 		} else {

	jmp	SHORT $LN121@xmlSchemaP
$LN33@xmlSchemaP:

; 6835 : 		    /*
; 6836 : 		    * Validate the item (anyURI).
; 6837 : 		    */
; 6838 : 		    xmlSchemaPValAttrNodeValue(ctxt, NULL, attr,

	push	29					; 0000001dH
	call	_xmlSchemaGetBuiltInType
	push	eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	esi
	push	ebx
	push	0
	push	eax
	call	_xmlSchemaPValAttrNodeValue

; 6839 : 			nsItem, xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI));
; 6840 : 		    dictnsItem = xmlDictLookup(ctxt->dict, nsItem, -1);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	-1
	push	esi
	push	DWORD PTR [eax+80]
	call	_xmlDictLookup
	add	esp, 36					; 00000024H
	mov	esi, eax
$LN121@xmlSchemaP:

; 6841 : 		}
; 6842 : 		/*
; 6843 : 		* Avoid dublicate namespaces.
; 6844 : 		*/
; 6845 : 		tmp = wildc->nsSet;

	mov	ecx, DWORD PTR _ctxt$[ebp]
$LN34@xmlSchemaP:
	mov	eax, DWORD PTR _wildc$[ebp]
	mov	eax, DWORD PTR [eax+32]

; 6846 : 		while (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN110@xmlSchemaP
$LL9@xmlSchemaP:

; 6847 : 		    if (dictnsItem == tmp->value)

	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN115@xmlSchemaP

; 6848 : 			break;
; 6849 : 		    tmp = tmp->next;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL9@xmlSchemaP
$LN110@xmlSchemaP:

; 6850 : 		}
; 6851 : 		if (tmp == NULL) {
; 6852 : 		    tmp = xmlSchemaNewWildcardNsConstraint(ctxt);

	push	ecx
	call	_xmlSchemaNewWildcardNsConstraint
	add	esp, 4

; 6853 : 		    if (tmp == NULL) {

	test	eax, eax
	je	$LN95@xmlSchemaP

; 6855 : 			return (-1);
; 6856 : 		    }
; 6857 : 		    tmp->value = dictnsItem;
; 6858 : 		    tmp->next = NULL;
; 6859 : 		    if (wildc->nsSet == NULL)

	mov	ecx, DWORD PTR _wildc$[ebp]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], 0
	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN38@xmlSchemaP

; 6860 : 			wildc->nsSet = tmp;

	mov	DWORD PTR [ecx+32], eax
	jmp	SHORT $LN40@xmlSchemaP
$LN38@xmlSchemaP:

; 6861 : 		    else if (lastNs != NULL)

	mov	ecx, DWORD PTR _lastNs$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN40@xmlSchemaP

; 6862 : 			lastNs->next = tmp;

	mov	DWORD PTR [ecx], eax
$LN40@xmlSchemaP:

; 6863 : 		    lastNs = tmp;

	mov	DWORD PTR _lastNs$1$[ebp], eax
$LN115@xmlSchemaP:

; 6864 : 		}
; 6865 : 
; 6866 : 	    }
; 6867 : 	    xmlFree(nsItem);

	mov	esi, DWORD PTR _nsItem$1$[ebp]
$LN36@xmlSchemaP:
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 6868 : 	    cur = end;

	mov	esi, edi

; 6869 : 	} while (*cur != 0);

	cmp	BYTE PTR [edi], 0
	jne	$LL5@xmlSchemaP

; 6870 :     }
; 6871 :     return (ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 6872 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@xmlSchemaP:

; 3134 :     xmlSchemaFormatNodeForError(&msg, ACTXT_CAST ctxt, node);

	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	lea	eax, DWORD PTR _msg$2[ebp]
	mov	DWORD PTR _msg$2[ebp], 0
	push	eax
	call	_xmlSchemaFormatNodeForError
	add	esp, 12					; 0000000cH

; 3135 :     if (message == NULL) {
; 3136 : 	/*
; 3137 : 	* Use default messages.
; 3138 : 	*/
; 3139 : 	if (type != NULL) {
; 3140 : 	    if (node->type == XML_ATTRIBUTE_NODE)
; 3141 : 		msg = xmlStrcat(msg, BAD_CAST "'%s' is not a valid value of ");
; 3142 : 	    else
; 3143 : 		msg = xmlStrcat(msg, BAD_CAST "The character content is not a "
; 3144 : 		"valid value of ");
; 3145 : 	    if (! xmlSchemaIsGlobalItem(type))
; 3146 : 		msg = xmlStrcat(msg, BAD_CAST "the local ");
; 3147 : 	    else
; 3148 : 		msg = xmlStrcat(msg, BAD_CAST "the ");
; 3149 : 
; 3150 : 	    if (WXS_IS_ATOMIC(type))
; 3151 : 		msg = xmlStrcat(msg, BAD_CAST "atomic type");
; 3152 : 	    else if (WXS_IS_LIST(type))
; 3153 : 		msg = xmlStrcat(msg, BAD_CAST "list type");
; 3154 : 	    else if (WXS_IS_UNION(type))
; 3155 : 		msg = xmlStrcat(msg, BAD_CAST "union type");
; 3156 : 
; 3157 : 	    if (xmlSchemaIsGlobalItem(type)) {
; 3158 : 		xmlChar *str = NULL;
; 3159 : 		msg = xmlStrcat(msg, BAD_CAST " '");
; 3160 : 		if (type->builtInType != 0) {
; 3161 : 		    msg = xmlStrcat(msg, BAD_CAST "xs:");
; 3162 : 		    str = xmlStrdup(type->name);
; 3163 : 		} else {
; 3164 : 		    const xmlChar *qName = xmlSchemaFormatQName(&str, type->targetNamespace, type->name);
; 3165 : 		    if (!str)
; 3166 : 			str = xmlStrdup(qName);
; 3167 : 		}
; 3168 : 		msg = xmlStrcat(msg, xmlEscapeFormatString(&str));
; 3169 : 		msg = xmlStrcat(msg, BAD_CAST "'.");
; 3170 : 		FREE_AND_NULL(str);
; 3171 : 	    }
; 3172 : 	} else {
; 3173 : 	    if (node->type == XML_ATTRIBUTE_NODE)

	cmp	DWORD PTR [ebx+4], 2
	jne	SHORT $LN74@xmlSchemaP

; 3174 : 		msg = xmlStrcat(msg, BAD_CAST "The value '%s' is not valid.");

	push	OFFSET ??_C@_0BN@HAAPLFMH@The?5value?5?8?$CFs?8?5is?5not?5valid?4@
	jmp	SHORT $LN122@xmlSchemaP
$LN74@xmlSchemaP:

; 3175 : 	    else
; 3176 : 		msg = xmlStrcat(msg, BAD_CAST "The character content is not "

	push	OFFSET ??_C@_0CE@BMFBGFDE@The?5character?5content?5is?5not?5va@
$LN122@xmlSchemaP:

; 3177 : 		"valid.");
; 3178 : 	}
; 3179 : 	if (expected) {

	push	DWORD PTR _msg$2[ebp]
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _msg$2[ebp], eax

; 3180 : 	    xmlChar *expectedEscaped = xmlCharStrdup(expected);

	push	OFFSET ??_C@_0EK@HAPJOCKP@?$CI?$CI?$CD?$CDany?5?$HM?5?$CD?$CDother?$CJ?5?$HM?5List?5of?5?$CIx@
	call	_xmlCharStrdup

; 3181 : 	    msg = xmlStrcat(msg, BAD_CAST " Expected is '");

	push	OFFSET ??_C@_0P@PICMEPAD@?5Expected?5is?5?8@
	push	DWORD PTR _msg$2[ebp]
	mov	DWORD PTR _expectedEscaped$1[ebp], eax
	call	_xmlStrcat
	mov	DWORD PTR _msg$2[ebp], eax

; 3182 : 	    msg = xmlStrcat(msg, xmlEscapeFormatString(&expectedEscaped));

	lea	eax, DWORD PTR _expectedEscaped$1[ebp]
	push	eax
	call	_xmlEscapeFormatString
	push	eax
	push	DWORD PTR _msg$2[ebp]
	call	_xmlStrcat

; 3183 : 	    FREE_AND_NULL(expectedEscaped);

	mov	ecx, DWORD PTR _expectedEscaped$1[ebp]
	add	esp, 24					; 00000018H
	mov	DWORD PTR _msg$2[ebp], eax
	test	ecx, ecx
	je	SHORT $LN78@xmlSchemaP
	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _msg$2[ebp]
	add	esp, 4
	mov	DWORD PTR _expectedEscaped$1[ebp], 0
$LN78@xmlSchemaP:

; 3184 : 	    msg = xmlStrcat(msg, BAD_CAST "'.\n");

	push	OFFSET ??_C@_03CLGCDEAE@?8?4?6@
	push	eax
	call	_xmlStrcat
	add	esp, 8

; 3185 : 	} else
; 3186 : 	    msg = xmlStrcat(msg, BAD_CAST "\n");
; 3187 : 	if (node->type == XML_ATTRIBUTE_NODE)

	mov	DWORD PTR _msg$2[ebp], eax
	cmp	DWORD PTR [ebx+4], 2
	push	0
	jne	SHORT $LN79@xmlSchemaP

; 3188 : 	    xmlSchemaPErr(ctxt, node, error, (const char *) msg, value, NULL);

	push	esi
	jmp	SHORT $LN123@xmlSchemaP
$LN79@xmlSchemaP:

; 3189 : 	else
; 3190 : 	    xmlSchemaPErr(ctxt, node, error, (const char *) msg, NULL, NULL);

	push	0
$LN123@xmlSchemaP:

; 3191 :     } else {
; 3192 : 	msg = xmlStrcat(msg, BAD_CAST message);
; 3193 : 	msg = xmlStrcat(msg, BAD_CAST ".\n");
; 3194 : 	xmlSchemaPErrExt(ctxt, node, error, NULL, NULL, NULL,
; 3195 : 	     (const char*) msg, str1, str2, NULL, NULL, NULL);
; 3196 :     }
; 3197 :     /* Cleanup. */
; 3198 :     FREE_AND_NULL(msg)

	push	eax
	push	1792					; 00000700H
	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPErr
	mov	eax, DWORD PTR _msg$2[ebp]
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN81@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN81@xmlSchemaP:

; 6820 : 		    (xmlStrEqual(nsItem, BAD_CAST "##any"))) {
; 6821 : 		xmlSchemaPSimpleTypeErr(ctxt,
; 6822 : 		    XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER,
; 6823 : 		    NULL, (xmlNodePtr) attr,
; 6824 : 		    NULL,
; 6825 : 		    "((##any | ##other) | List of (xs:anyURI | "
; 6826 : 		    "(##targetNamespace | ##local)))",
; 6827 : 		    nsItem, NULL, NULL, NULL);
; 6828 : 		ret = XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER;

	mov	DWORD PTR _ret$1$[ebp], 1792		; 00000700H

; 6847 : 		    if (dictnsItem == tmp->value)

	jmp	$LN36@xmlSchemaP
$LN95@xmlSchemaP:

; 6854 : 			xmlFree(nsItem);

	push	DWORD PTR _nsItem$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN124@xmlSchemaP:

; 6872 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlSchemaP:

; 6799 : 	wildc->any = 1;

	mov	eax, DWORD PTR _wildc$[ebp]
	mov	DWORD PTR [eax+28], 1
$LN3@xmlSchemaP:

; 6870 :     }
; 6871 :     return (ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 6872 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseWildcardNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseFacet
_TEXT	SEGMENT
_value$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaParseFacet PROC				; COMDAT

; 6674 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	je	$LN3@xmlSchemaP

; 6675 :     xmlSchemaFacetPtr facet;
; 6676 :     xmlNodePtr child = NULL;
; 6677 :     const xmlChar *value;
; 6678 : 
; 6679 :     if ((ctxt == NULL) || (schema == NULL) || (node == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	$LN3@xmlSchemaP
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	$LN3@xmlSchemaP

; 6681 : 
; 6682 :     facet = xmlSchemaNewFacet();

	push	edi
	call	_xmlSchemaNewFacet
	mov	edi, eax

; 6683 :     if (facet == NULL) {

	test	edi, edi
	jne	SHORT $LN4@xmlSchemaP

; 6684 :         xmlSchemaPErrMemory(ctxt, "allocating facet", node);

	push	esi
	push	OFFSET ??_C@_0BB@DFGEBGMC@allocating?5facet@
	push	ebx
	call	_xmlSchemaPErrMemory
	add	esp, 12					; 0000000cH

; 6693 :         return (NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 6749 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlSchemaP:

; 6685 :         return (NULL);
; 6686 :     }
; 6687 :     facet->node = node;
; 6688 :     value = xmlSchemaGetProp(ctxt, node, "value");

	push	OFFSET ??_C@_05MFEJDJP@value@
	push	esi
	push	ebx
	mov	DWORD PTR [edi+20], esi
	call	_xmlSchemaGetProp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _value$1$[ebp], eax

; 6689 :     if (value == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlSchemaP

; 6690 :         xmlSchemaPErr2(ctxt, node, child, XML_SCHEMAP_FACET_NO_VALUE,

	push	eax
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0BH@LAHCBIKA@Facet?5?$CFs?5has?5no?5value?6@
	push	1708					; 000006acH
$LN48@xmlSchemaP:
	push	0
	push	esi
	push	ebx
	call	_xmlSchemaPErr2

; 6691 :                        "Facet %s has no value\n", node->name, NULL);
; 6692 :         xmlSchemaFreeFacet(facet);

	push	edi
	call	_xmlSchemaFreeFacet
	add	esp, 32					; 00000020H

; 6693 :         return (NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 6749 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlSchemaP:

; 6694 :     }
; 6695 :     if (IS_SCHEMA(node, "minInclusive")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN28@xmlSchemaP
	push	OFFSET ??_C@_0N@BDECKIL@minInclusive@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlSchemaP

; 6696 :         facet->type = XML_SCHEMA_FACET_MININCLUSIVE;

	mov	DWORD PTR [edi], 1000			; 000003e8H
	jmp	$LN29@xmlSchemaP
$LN6@xmlSchemaP:

; 6697 :     } else if (IS_SCHEMA(node, "minExclusive")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN28@xmlSchemaP
	push	OFFSET ??_C@_0N@MENCPBPO@minExclusive@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlSchemaP

; 6698 :         facet->type = XML_SCHEMA_FACET_MINEXCLUSIVE;

	mov	DWORD PTR [edi], 1001			; 000003e9H
	jmp	$LN29@xmlSchemaP
$LN8@xmlSchemaP:

; 6699 :     } else if (IS_SCHEMA(node, "maxInclusive")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN28@xmlSchemaP
	push	OFFSET ??_C@_0N@EBHLFCPN@maxInclusive@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlSchemaP

; 6700 :         facet->type = XML_SCHEMA_FACET_MAXINCLUSIVE;

	mov	DWORD PTR [edi], 1002			; 000003eaH
	jmp	$LN29@xmlSchemaP
$LN10@xmlSchemaP:

; 6701 :     } else if (IS_SCHEMA(node, "maxExclusive")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN28@xmlSchemaP
	push	OFFSET ??_C@_0N@IEJNIJII@maxExclusive@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlSchemaP

; 6702 :         facet->type = XML_SCHEMA_FACET_MAXEXCLUSIVE;

	mov	DWORD PTR [edi], 1003			; 000003ebH
	jmp	$LN29@xmlSchemaP
$LN12@xmlSchemaP:

; 6703 :     } else if (IS_SCHEMA(node, "totalDigits")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN28@xmlSchemaP
	push	OFFSET ??_C@_0M@PGNNBCIB@totalDigits@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlSchemaP

; 6704 :         facet->type = XML_SCHEMA_FACET_TOTALDIGITS;

	mov	DWORD PTR [edi], 1004			; 000003ecH
	jmp	$LN29@xmlSchemaP
$LN14@xmlSchemaP:

; 6705 :     } else if (IS_SCHEMA(node, "fractionDigits")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN28@xmlSchemaP
	push	OFFSET ??_C@_0P@EPJLKDGA@fractionDigits@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlSchemaP

; 6706 :         facet->type = XML_SCHEMA_FACET_FRACTIONDIGITS;

	mov	DWORD PTR [edi], 1005			; 000003edH
	jmp	$LN29@xmlSchemaP
$LN16@xmlSchemaP:

; 6707 :     } else if (IS_SCHEMA(node, "pattern")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN28@xmlSchemaP
	push	OFFSET ??_C@_07CHFOACKJ@pattern@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlSchemaP

; 6708 :         facet->type = XML_SCHEMA_FACET_PATTERN;

	mov	DWORD PTR [edi], 1006			; 000003eeH
	jmp	$LN29@xmlSchemaP
$LN18@xmlSchemaP:

; 6709 :     } else if (IS_SCHEMA(node, "enumeration")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN28@xmlSchemaP
	push	OFFSET ??_C@_0M@FJOIDAAJ@enumeration@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlSchemaP

; 6710 :         facet->type = XML_SCHEMA_FACET_ENUMERATION;

	mov	DWORD PTR [edi], 1007			; 000003efH
	jmp	$LN29@xmlSchemaP
$LN20@xmlSchemaP:

; 6711 :     } else if (IS_SCHEMA(node, "whiteSpace")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN28@xmlSchemaP
	push	OFFSET ??_C@_0L@CCEMGGFL@whiteSpace@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@xmlSchemaP

; 6712 :         facet->type = XML_SCHEMA_FACET_WHITESPACE;

	mov	DWORD PTR [edi], 1008			; 000003f0H
	jmp	$LN29@xmlSchemaP
$LN22@xmlSchemaP:

; 6713 :     } else if (IS_SCHEMA(node, "length")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN28@xmlSchemaP
	push	OFFSET ??_C@_06IJDLPEM@length@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@xmlSchemaP

; 6714 :         facet->type = XML_SCHEMA_FACET_LENGTH;

	mov	DWORD PTR [edi], 1009			; 000003f1H
	jmp	$LN29@xmlSchemaP
$LN24@xmlSchemaP:

; 6715 :     } else if (IS_SCHEMA(node, "maxLength")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN28@xmlSchemaP
	push	OFFSET ??_C@_09KJHMKBNK@maxLength@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN26@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN26@xmlSchemaP

; 6716 :         facet->type = XML_SCHEMA_FACET_MAXLENGTH;

	mov	DWORD PTR [edi], 1010			; 000003f2H
	jmp	SHORT $LN29@xmlSchemaP
$LN26@xmlSchemaP:

; 6717 :     } else if (IS_SCHEMA(node, "minLength")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN28@xmlSchemaP
	push	OFFSET ??_C@_09KIHADLGO@minLength@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN28@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN28@xmlSchemaP

; 6718 :         facet->type = XML_SCHEMA_FACET_MINLENGTH;

	mov	DWORD PTR [edi], 1011			; 000003f3H
$LN29@xmlSchemaP:

; 6724 :     }
; 6725 :     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	esi
	push	ebx
	call	_xmlSchemaPValAttrID

; 6726 :     facet->value = value;

	mov	eax, DWORD PTR _value$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+8], eax

; 6727 :     if ((facet->type != XML_SCHEMA_FACET_PATTERN) &&

	mov	eax, DWORD PTR [edi]
	cmp	eax, 1006				; 000003eeH
	je	SHORT $LN32@xmlSchemaP
	cmp	eax, 1007				; 000003efH
	je	SHORT $LN32@xmlSchemaP

; 6728 : 	(facet->type != XML_SCHEMA_FACET_ENUMERATION)) {
; 6729 : 	const xmlChar *fixed;
; 6730 : 
; 6731 : 	fixed = xmlSchemaGetProp(ctxt, node, "fixed");

	push	OFFSET ??_C@_05OFLEIIDM@fixed@
	push	esi
	push	ebx
	call	_xmlSchemaGetProp
	add	esp, 12					; 0000000cH

; 6732 : 	if (fixed != NULL) {

	test	eax, eax
	je	SHORT $LN32@xmlSchemaP

; 6733 : 	    if (xmlStrEqual(fixed, BAD_CAST "true"))

	push	OFFSET ??_C@_04LOAJBDKD@true@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN32@xmlSchemaP

; 6734 : 		facet->fixed = 1;

	mov	DWORD PTR [edi+24], 1
$LN32@xmlSchemaP:

; 6735 : 	}
; 6736 :     }
; 6737 :     child = node->children;

	mov	ebx, DWORD PTR [esi+12]

; 6738 : 
; 6739 :     if (IS_SCHEMA(child, "annotation")) {

	test	ebx, ebx
	je	SHORT $LN34@xmlSchemaP
	cmp	DWORD PTR [ebx+36], 0
	je	SHORT $LN33@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@xmlSchemaP
	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@xmlSchemaP

; 6740 :         facet->annot = xmlSchemaParseAnnotation(ctxt, child, 1);

	push	1
	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaParseAnnotation
	mov	DWORD PTR [edi+16], eax
	add	esp, 12					; 0000000cH

; 6741 :         child = child->next;

	mov	ebx, DWORD PTR [ebx+24]
$LN33@xmlSchemaP:

; 6742 :     }
; 6743 :     if (child != NULL) {

	test	ebx, ebx
	je	SHORT $LN34@xmlSchemaP

; 6744 :         xmlSchemaPErr2(ctxt, node, child, XML_SCHEMAP_UNKNOWN_FACET_CHILD,

	push	0
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0CH@KGEOIBLP@Facet?5?$CFs?5has?5unexpected?5child?5c@
	push	1740					; 000006ccH
	push	ebx
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPErr2
	add	esp, 28					; 0000001cH
$LN34@xmlSchemaP:

; 6745 :                        "Facet %s has unexpected child content\n",
; 6746 :                        node->name, NULL);
; 6747 :     }
; 6748 :     return (facet);

	mov	eax, edi
	pop	edi
	pop	esi

; 6749 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlSchemaP:

; 6719 :     } else {
; 6720 :         xmlSchemaPErr2(ctxt, node, child, XML_SCHEMAP_UNKNOWN_FACET_TYPE,

	push	0
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0BH@JGDFLELF@Unknown?5facet?5type?5?$CFs?6@
	push	1741					; 000006cdH

; 6721 :                        "Unknown facet type %s\n", node->name, NULL);
; 6722 :         xmlSchemaFreeFacet(facet);
; 6723 :         return (NULL);

	jmp	$LN48@xmlSchemaP
$LN3@xmlSchemaP:
	pop	esi

; 6680 :         return (NULL);

	xor	eax, eax

; 6749 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseFacet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseAnnotation
_TEXT	SEGMENT
_barked$1$ = -8						; size = 4
_ret$1$ = -4						; size = 4
_type$1$ = 8						; size = 4
_des$1 = 8						; size = 4
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_needed$ = 16						; size = 4
_xmlSchemaParseAnnotation PROC				; COMDAT

; 6554 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _barked$1$[ebp], 0
	test	edi, edi
	je	$LN11@xmlSchemaP

; 6555 :     xmlSchemaAnnotPtr ret;
; 6556 :     xmlNodePtr child = NULL;
; 6557 :     xmlAttrPtr attr;
; 6558 :     int barked = 0;
; 6559 : 
; 6560 :     /*
; 6561 :     * INFO: S4S completed.
; 6562 :     */
; 6563 :     /*
; 6564 :     * id = ID
; 6565 :     * {any attributes with non-schema namespace . . .}>
; 6566 :     * Content: (appinfo | documentation)*
; 6567 :     */
; 6568 :     if ((ctxt == NULL) || (node == NULL))

	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	$LN11@xmlSchemaP

; 6570 :     if (needed)

	cmp	DWORD PTR _needed$[ebp], 0
	je	SHORT $LN12@xmlSchemaP

; 3326 :     ret = (xmlSchemaAnnotPtr) xmlMalloc(sizeof(xmlSchemaAnnot));

	push	8
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _ret$1$[ebp], eax

; 3327 :     if (ret == NULL) {

	test	eax, eax
	jne	$LN33@xmlSchemaP

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [edi+20]

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BG@ICNGEPGO@allocating?5annotation@
	push	eax
	push	ebx
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
$LN12@xmlSchemaP:

; 6572 :     else
; 6573 : 	ret = NULL;
; 6574 :     attr = node->properties;

	mov	DWORD PTR _ret$1$[ebp], 0
$LN13@xmlSchemaP:
	push	esi
	mov	esi, DWORD PTR [ebx+44]

; 6575 :     while (attr != NULL) {

	test	esi, esi
	je	$LN119@xmlSchemaP
$LL2@xmlSchemaP:

; 6576 : 	if (((attr->ns == NULL) &&
; 6577 : 	    (!xmlStrEqual(attr->name, BAD_CAST "id"))) ||

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN16@xmlSchemaP
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlSchemaP
$LN16@xmlSchemaP:
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN14@xmlSchemaP
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlSchemaP
$LN15@xmlSchemaP:

; 6578 : 	    ((attr->ns != NULL) &&
; 6579 : 	    xmlStrEqual(attr->ns->href, xmlSchemaNs))) {
; 6580 : 
; 6581 : 	    xmlSchemaPIllegalAttrErr(ctxt,

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN14@xmlSchemaP:

; 6582 : 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 6583 : 	}
; 6584 : 	attr = attr->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaP

; 6576 : 	if (((attr->ns == NULL) &&
; 6577 : 	    (!xmlStrEqual(attr->name, BAD_CAST "id"))) ||

	mov	esi, DWORD PTR [ebx+44]

; 4667 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN119@xmlSchemaP
	npad	7
$LL42@xmlSchemaP:

; 4668 :         if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN46@xmlSchemaP
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN41@xmlSchemaP
$LN46@xmlSchemaP:

; 4669 : 	    return(prop);
; 4670 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL42@xmlSchemaP

; 3333 :     return (ret);
; 3334 : }
; 3335 : 
; 3336 : static xmlSchemaItemListPtr
; 3337 : xmlSchemaItemListCreate(void)
; 3338 : {
; 3339 :     xmlSchemaItemListPtr ret;
; 3340 : 
; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));
; 3342 :     if (ret == NULL) {
; 3343 : 	xmlSchemaPErrMemory(NULL,
; 3344 : 	    "allocating an item list structure", NULL);
; 3345 : 	return (NULL);
; 3346 :     }
; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));
; 3348 :     return (ret);
; 3349 : }
; 3350 : 
; 3351 : static void
; 3352 : xmlSchemaItemListClear(xmlSchemaItemListPtr list)
; 3353 : {
; 3354 :     if (list->items != NULL) {
; 3355 : 	xmlFree(list->items);
; 3356 : 	list->items = NULL;
; 3357 :     }
; 3358 :     list->nbItems = 0;
; 3359 :     list->sizeItems = 0;
; 3360 : }
; 3361 : 
; 3362 : static int
; 3363 : xmlSchemaItemListAdd(xmlSchemaItemListPtr list, void *item)
; 3364 : {
; 3365 :     if (list->items == NULL) {
; 3366 : 	list->items = (void **) xmlMalloc(
; 3367 : 	    20 * sizeof(void *));
; 3368 : 	if (list->items == NULL) {
; 3369 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3370 : 	    return(-1);
; 3371 : 	}
; 3372 : 	list->sizeItems = 20;
; 3373 :     } else if (list->sizeItems <= list->nbItems) {
; 3374 : 	list->sizeItems *= 2;
; 3375 : 	list->items = (void **) xmlRealloc(list->items,
; 3376 : 	    list->sizeItems * sizeof(void *));
; 3377 : 	if (list->items == NULL) {
; 3378 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3379 : 	    list->sizeItems = 0;
; 3380 : 	    return(-1);
; 3381 : 	}
; 3382 :     }
; 3383 :     list->items[list->nbItems++] = item;
; 3384 :     return(0);
; 3385 : }
; 3386 : 
; 3387 : static int
; 3388 : xmlSchemaItemListAddSize(xmlSchemaItemListPtr list,
; 3389 : 			 int initialSize,
; 3390 : 			 void *item)
; 3391 : {
; 3392 :     if (list->items == NULL) {
; 3393 : 	if (initialSize <= 0)
; 3394 : 	    initialSize = 1;
; 3395 : 	list->items = (void **) xmlMalloc(
; 3396 : 	    initialSize * sizeof(void *));
; 3397 : 	if (list->items == NULL) {
; 3398 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3399 : 	    return(-1);
; 3400 : 	}
; 3401 : 	list->sizeItems = initialSize;
; 3402 :     } else if (list->sizeItems <= list->nbItems) {
; 3403 : 	list->sizeItems *= 2;
; 3404 : 	list->items = (void **) xmlRealloc(list->items,
; 3405 : 	    list->sizeItems * sizeof(void *));
; 3406 : 	if (list->items == NULL) {
; 3407 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3408 : 	    list->sizeItems = 0;
; 3409 : 	    return(-1);
; 3410 : 	}
; 3411 :     }
; 3412 :     list->items[list->nbItems++] = item;
; 3413 :     return(0);
; 3414 : }
; 3415 : 
; 3416 : static int
; 3417 : xmlSchemaItemListInsert(xmlSchemaItemListPtr list, void *item, int idx)
; 3418 : {
; 3419 :     if (list->items == NULL) {
; 3420 : 	list->items = (void **) xmlMalloc(
; 3421 : 	    20 * sizeof(void *));
; 3422 : 	if (list->items == NULL) {
; 3423 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3424 : 	    return(-1);
; 3425 : 	}
; 3426 : 	list->sizeItems = 20;
; 3427 :     } else if (list->sizeItems <= list->nbItems) {
; 3428 : 	list->sizeItems *= 2;
; 3429 : 	list->items = (void **) xmlRealloc(list->items,
; 3430 : 	    list->sizeItems * sizeof(void *));
; 3431 : 	if (list->items == NULL) {
; 3432 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3433 : 	    list->sizeItems = 0;
; 3434 : 	    return(-1);
; 3435 : 	}
; 3436 :     }
; 3437 :     /*
; 3438 :     * Just append if the index is greater/equal than the item count.
; 3439 :     */
; 3440 :     if (idx >= list->nbItems) {
; 3441 : 	list->items[list->nbItems++] = item;
; 3442 :     } else {
; 3443 : 	int i;
; 3444 : 	for (i = list->nbItems; i > idx; i--)
; 3445 : 	    list->items[i] = list->items[i-1];
; 3446 : 	list->items[idx] = item;
; 3447 : 	list->nbItems++;
; 3448 :     }
; 3449 :     return(0);
; 3450 : }
; 3451 : 
; 3452 : #if 0 /* enable if ever needed */
; 3453 : static int
; 3454 : xmlSchemaItemListInsertSize(xmlSchemaItemListPtr list,
; 3455 : 			    int initialSize,
; 3456 : 			    void *item,
; 3457 : 			    int idx)
; 3458 : {
; 3459 :     if (list->items == NULL) {
; 3460 : 	if (initialSize <= 0)
; 3461 : 	    initialSize = 1;
; 3462 : 	list->items = (void **) xmlMalloc(
; 3463 : 	    initialSize * sizeof(void *));
; 3464 : 	if (list->items == NULL) {
; 3465 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3466 : 	    return(-1);
; 3467 : 	}
; 3468 : 	list->sizeItems = initialSize;
; 3469 :     } else if (list->sizeItems <= list->nbItems) {
; 3470 : 	list->sizeItems *= 2;
; 3471 : 	list->items = (void **) xmlRealloc(list->items,
; 3472 : 	    list->sizeItems * sizeof(void *));
; 3473 : 	if (list->items == NULL) {
; 3474 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3475 : 	    list->sizeItems = 0;
; 3476 : 	    return(-1);
; 3477 : 	}
; 3478 :     }
; 3479 :     /*
; 3480 :     * Just append if the index is greater/equal than the item count.
; 3481 :     */
; 3482 :     if (idx >= list->nbItems) {
; 3483 : 	list->items[list->nbItems++] = item;
; 3484 :     } else {
; 3485 : 	int i;
; 3486 : 	for (i = list->nbItems; i > idx; i--)
; 3487 : 	    list->items[i] = list->items[i-1];
; 3488 : 	list->items[idx] = item;
; 3489 : 	list->nbItems++;
; 3490 :     }
; 3491 :     return(0);
; 3492 : }
; 3493 : #endif
; 3494 : 
; 3495 : static int
; 3496 : xmlSchemaItemListRemove(xmlSchemaItemListPtr list, int idx)
; 3497 : {
; 3498 :     int i;
; 3499 :     if ((list->items == NULL) || (idx >= list->nbItems)) {
; 3500 : 	xmlSchemaPSimpleErr("Internal error: xmlSchemaItemListRemove, "
; 3501 : 	    "index error.\n");
; 3502 : 	return(-1);
; 3503 :     }
; 3504 : 
; 3505 :     if (list->nbItems == 1) {
; 3506 : 	/* TODO: Really free the list? */
; 3507 : 	xmlFree(list->items);
; 3508 : 	list->items = NULL;
; 3509 : 	list->nbItems = 0;
; 3510 : 	list->sizeItems = 0;
; 3511 :     } else if (list->nbItems -1 == idx) {
; 3512 : 	list->nbItems--;
; 3513 :     } else {
; 3514 : 	for (i = idx; i < list->nbItems -1; i++)
; 3515 : 	    list->items[i] = list->items[i+1];
; 3516 : 	list->nbItems--;
; 3517 :     }
; 3518 :     return(0);
; 3519 : }
; 3520 : 
; 3521 : /**
; 3522 :  * xmlSchemaItemListFree:
; 3523 :  * @annot:  a schema type structure
; 3524 :  *
; 3525 :  * Deallocate a annotation structure
; 3526 :  */
; 3527 : static void
; 3528 : xmlSchemaItemListFree(xmlSchemaItemListPtr list)
; 3529 : {
; 3530 :     if (list == NULL)
; 3531 : 	return;
; 3532 :     if (list->items != NULL)
; 3533 : 	xmlFree(list->items);
; 3534 :     xmlFree(list);
; 3535 : }
; 3536 : 
; 3537 : static void
; 3538 : xmlSchemaBucketFree(xmlSchemaBucketPtr bucket)
; 3539 : {
; 3540 :     if (bucket == NULL)
; 3541 : 	return;
; 3542 :     if (bucket->globals != NULL) {
; 3543 : 	xmlSchemaComponentListFree(bucket->globals);
; 3544 : 	xmlSchemaItemListFree(bucket->globals);
; 3545 :     }
; 3546 :     if (bucket->locals != NULL) {
; 3547 : 	xmlSchemaComponentListFree(bucket->locals);
; 3548 : 	xmlSchemaItemListFree(bucket->locals);
; 3549 :     }
; 3550 :     if (bucket->relations != NULL) {
; 3551 : 	xmlSchemaSchemaRelationPtr prev, cur = bucket->relations;
; 3552 : 	do {
; 3553 : 	    prev = cur;
; 3554 : 	    cur = cur->next;
; 3555 : 	    xmlFree(prev);
; 3556 : 	} while (cur != NULL);
; 3557 :     }
; 3558 :     if ((! bucket->preserveDoc) && (bucket->doc != NULL)) {
; 3559 : 	xmlFreeDoc(bucket->doc);
; 3560 :     }
; 3561 :     if (bucket->type == XML_SCHEMA_SCHEMA_IMPORT) {
; 3562 : 	if (WXS_IMPBUCKET(bucket)->schema != NULL)
; 3563 : 	    xmlSchemaFree(WXS_IMPBUCKET(bucket)->schema);
; 3564 :     }
; 3565 :     xmlFree(bucket);
; 3566 : }
; 3567 : 
; 3568 : static void
; 3569 : xmlSchemaBucketFreeEntry(void *bucket, const xmlChar *name ATTRIBUTE_UNUSED)
; 3570 : {
; 3571 :     xmlSchemaBucketFree((xmlSchemaBucketPtr) bucket);
; 3572 : }
; 3573 : 
; 3574 : static xmlSchemaBucketPtr
; 3575 : xmlSchemaBucketCreate(xmlSchemaParserCtxtPtr pctxt,
; 3576 : 			 int type, const xmlChar *targetNamespace)
; 3577 : {
; 3578 :     xmlSchemaBucketPtr ret;
; 3579 :     int size;
; 3580 :     xmlSchemaPtr mainSchema;
; 3581 : 
; 3582 :     if (WXS_CONSTRUCTOR(pctxt)->mainSchema == NULL) {
; 3583 : 	PERROR_INT("xmlSchemaBucketCreate",
; 3584 : 	    "no main schema on constructor");
; 3585 : 	return(NULL);
; 3586 :     }
; 3587 :     mainSchema = WXS_CONSTRUCTOR(pctxt)->mainSchema;
; 3588 :     /* Create the schema bucket. */
; 3589 :     if (WXS_IS_BUCKET_INCREDEF(type))
; 3590 : 	size = sizeof(xmlSchemaInclude);
; 3591 :     else
; 3592 : 	size = sizeof(xmlSchemaImport);
; 3593 :     ret = (xmlSchemaBucketPtr) xmlMalloc(size);
; 3594 :     if (ret == NULL) {
; 3595 : 	xmlSchemaPErrMemory(NULL, "allocating schema bucket", NULL);
; 3596 : 	return(NULL);
; 3597 :     }
; 3598 :     memset(ret, 0, size);
; 3599 :     ret->targetNamespace = targetNamespace;
; 3600 :     ret->type = type;
; 3601 :     ret->globals = xmlSchemaItemListCreate();
; 3602 :     if (ret->globals == NULL) {
; 3603 : 	xmlFree(ret);
; 3604 : 	return(NULL);
; 3605 :     }
; 3606 :     ret->locals = xmlSchemaItemListCreate();
; 3607 :     if (ret->locals == NULL) {
; 3608 : 	xmlFree(ret);
; 3609 : 	return(NULL);
; 3610 :     }
; 3611 :     /*
; 3612 :     * The following will assure that only the first bucket is marked as
; 3613 :     * XML_SCHEMA_SCHEMA_MAIN and it points to the *main* schema.
; 3614 :     * For each following import buckets an xmlSchema will be created.
; 3615 :     * An xmlSchema will be created for every distinct targetNamespace.
; 3616 :     * We assign the targetNamespace to the schemata here.
; 3617 :     */
; 3618 :     if (! WXS_HAS_BUCKETS(pctxt)) {
; 3619 : 	if (WXS_IS_BUCKET_INCREDEF(type)) {
; 3620 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3621 : 		"first bucket but it's an include or redefine");
; 3622 : 	    xmlSchemaBucketFree(ret);
; 3623 : 	    return(NULL);
; 3624 : 	}
; 3625 : 	/* Force the type to be XML_SCHEMA_SCHEMA_MAIN. */
; 3626 : 	ret->type = XML_SCHEMA_SCHEMA_MAIN;
; 3627 : 	/* Point to the *main* schema. */
; 3628 : 	WXS_CONSTRUCTOR(pctxt)->mainBucket = ret;
; 3629 : 	WXS_IMPBUCKET(ret)->schema = mainSchema;
; 3630 : 	/*
; 3631 : 	* Ensure that the main schema gets a targetNamespace.
; 3632 : 	*/
; 3633 : 	mainSchema->targetNamespace = targetNamespace;
; 3634 :     } else {
; 3635 : 	if (type == XML_SCHEMA_SCHEMA_MAIN) {
; 3636 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3637 : 		"main bucket but it's not the first one");
; 3638 : 	    xmlSchemaBucketFree(ret);
; 3639 : 	    return(NULL);
; 3640 : 	} else if (type == XML_SCHEMA_SCHEMA_IMPORT) {
; 3641 : 	    /*
; 3642 : 	    * Create a schema for imports and assign the
; 3643 : 	    * targetNamespace.
; 3644 : 	    */
; 3645 : 	    WXS_IMPBUCKET(ret)->schema = xmlSchemaNewSchema(pctxt);
; 3646 : 	    if (WXS_IMPBUCKET(ret)->schema == NULL) {
; 3647 : 		xmlSchemaBucketFree(ret);
; 3648 : 		return(NULL);
; 3649 : 	    }
; 3650 : 	    WXS_IMPBUCKET(ret)->schema->targetNamespace = targetNamespace;
; 3651 : 	}
; 3652 :     }
; 3653 :     if (WXS_IS_BUCKET_IMPMAIN(type)) {
; 3654 : 	int res;
; 3655 : 	/*
; 3656 : 	* Imports go into the "schemasImports" slot of the main *schema*.
; 3657 : 	* Note that we create an import entry for the main schema as well; i.e.,
; 3658 : 	* even if there's only one schema, we'll get an import.
; 3659 : 	*/
; 3660 : 	if (mainSchema->schemasImports == NULL) {
; 3661 : 	    mainSchema->schemasImports = xmlHashCreateDict(5,
; 3662 : 		WXS_CONSTRUCTOR(pctxt)->dict);
; 3663 : 	    if (mainSchema->schemasImports == NULL) {
; 3664 : 		xmlSchemaBucketFree(ret);
; 3665 : 		return(NULL);
; 3666 : 	    }
; 3667 : 	}
; 3668 : 	if (targetNamespace == NULL)
; 3669 : 	    res = xmlHashAddEntry(mainSchema->schemasImports,
; 3670 : 		XML_SCHEMAS_NO_NAMESPACE, ret);
; 3671 : 	else
; 3672 : 	    res = xmlHashAddEntry(mainSchema->schemasImports,
; 3673 : 		targetNamespace, ret);
; 3674 : 	if (res != 0) {
; 3675 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3676 : 		"failed to add the schema bucket to the hash");
; 3677 : 	    xmlSchemaBucketFree(ret);
; 3678 : 	    return(NULL);
; 3679 : 	}
; 3680 :     } else {
; 3681 : 	/* Set the @ownerImport of an include bucket. */
; 3682 : 	if (WXS_IS_BUCKET_IMPMAIN(WXS_CONSTRUCTOR(pctxt)->bucket->type))
; 3683 : 	    WXS_INCBUCKET(ret)->ownerImport =
; 3684 : 		WXS_IMPBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket);
; 3685 : 	else
; 3686 : 	    WXS_INCBUCKET(ret)->ownerImport =
; 3687 : 		WXS_INCBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket)->ownerImport;
; 3688 : 
; 3689 : 	/* Includes got into the "includes" slot of the *main* schema. */
; 3690 : 	if (mainSchema->includes == NULL) {
; 3691 : 	    mainSchema->includes = xmlSchemaItemListCreate();
; 3692 : 	    if (mainSchema->includes == NULL) {
; 3693 : 		xmlSchemaBucketFree(ret);
; 3694 : 		return(NULL);
; 3695 : 	    }
; 3696 : 	}
; 3697 : 	xmlSchemaItemListAdd(mainSchema->includes, ret);
; 3698 :     }
; 3699 :     /*
; 3700 :     * Add to list of all buckets; this is used for lookup
; 3701 :     * during schema construction time only.
; 3702 :     */
; 3703 :     if (xmlSchemaItemListAdd(WXS_CONSTRUCTOR(pctxt)->buckets, ret) == -1)
; 3704 : 	return(NULL);
; 3705 :     return(ret);
; 3706 : }
; 3707 : 
; 3708 : static int
; 3709 : xmlSchemaAddItemSize(xmlSchemaItemListPtr *list, int initialSize, void *item)
; 3710 : {
; 3711 :     if (*list == NULL) {
; 3712 : 	*list = xmlSchemaItemListCreate();
; 3713 : 	if (*list == NULL)
; 3714 : 	    return(-1);
; 3715 :     }
; 3716 :     xmlSchemaItemListAddSize(*list, initialSize, item);
; 3717 :     return(0);
; 3718 : }
; 3719 : 
; 3720 : /**
; 3721 :  * xmlSchemaFreeAnnot:
; 3722 :  * @annot:  a schema type structure
; 3723 :  *
; 3724 :  * Deallocate a annotation structure
; 3725 :  */
; 3726 : static void
; 3727 : xmlSchemaFreeAnnot(xmlSchemaAnnotPtr annot)
; 3728 : {
; 3729 :     if (annot == NULL)
; 3730 :         return;
; 3731 :     if (annot->next == NULL) {
; 3732 : 	xmlFree(annot);
; 3733 :     } else {
; 3734 : 	xmlSchemaAnnotPtr prev;
; 3735 : 
; 3736 : 	do {
; 3737 : 	    prev = annot;
; 3738 : 	    annot = annot->next;
; 3739 : 	    xmlFree(prev);
; 3740 : 	} while (annot != NULL);
; 3741 :     }
; 3742 : }
; 3743 : 
; 3744 : /**
; 3745 :  * xmlSchemaFreeNotation:
; 3746 :  * @schema:  a schema notation structure
; 3747 :  *
; 3748 :  * Deallocate a Schema Notation structure.
; 3749 :  */
; 3750 : static void
; 3751 : xmlSchemaFreeNotation(xmlSchemaNotationPtr nota)
; 3752 : {
; 3753 :     if (nota == NULL)
; 3754 :         return;
; 3755 :     xmlFree(nota);
; 3756 : }
; 3757 : 
; 3758 : /**
; 3759 :  * xmlSchemaFreeAttribute:
; 3760 :  * @attr:  an attribute declaration
; 3761 :  *
; 3762 :  * Deallocates an attribute declaration structure.
; 3763 :  */
; 3764 : static void
; 3765 : xmlSchemaFreeAttribute(xmlSchemaAttributePtr attr)
; 3766 : {
; 3767 :     if (attr == NULL)
; 3768 :         return;
; 3769 :     if (attr->annot != NULL)
; 3770 : 	xmlSchemaFreeAnnot(attr->annot);
; 3771 :     if (attr->defVal != NULL)
; 3772 : 	xmlSchemaFreeValue(attr->defVal);
; 3773 :     xmlFree(attr);
; 3774 : }
; 3775 : 
; 3776 : /**
; 3777 :  * xmlSchemaFreeAttributeUse:
; 3778 :  * @use:  an attribute use
; 3779 :  *
; 3780 :  * Deallocates an attribute use structure.
; 3781 :  */
; 3782 : static void
; 3783 : xmlSchemaFreeAttributeUse(xmlSchemaAttributeUsePtr use)
; 3784 : {
; 3785 :     if (use == NULL)
; 3786 :         return;
; 3787 :     if (use->annot != NULL)
; 3788 : 	xmlSchemaFreeAnnot(use->annot);
; 3789 :     if (use->defVal != NULL)
; 3790 : 	xmlSchemaFreeValue(use->defVal);
; 3791 :     xmlFree(use);
; 3792 : }
; 3793 : 
; 3794 : /**
; 3795 :  * xmlSchemaFreeAttributeUseProhib:
; 3796 :  * @prohib:  an attribute use prohibition
; 3797 :  *
; 3798 :  * Deallocates an attribute use structure.
; 3799 :  */
; 3800 : static void
; 3801 : xmlSchemaFreeAttributeUseProhib(xmlSchemaAttributeUseProhibPtr prohib)
; 3802 : {
; 3803 :     if (prohib == NULL)
; 3804 :         return;
; 3805 :     xmlFree(prohib);
; 3806 : }
; 3807 : 
; 3808 : /**
; 3809 :  * xmlSchemaFreeWildcardNsSet:
; 3810 :  * set:  a schema wildcard namespace
; 3811 :  *
; 3812 :  * Deallocates a list of wildcard constraint structures.
; 3813 :  */
; 3814 : static void
; 3815 : xmlSchemaFreeWildcardNsSet(xmlSchemaWildcardNsPtr set)
; 3816 : {
; 3817 :     xmlSchemaWildcardNsPtr next;
; 3818 : 
; 3819 :     while (set != NULL) {
; 3820 : 	next = set->next;
; 3821 : 	xmlFree(set);
; 3822 : 	set = next;
; 3823 :     }
; 3824 : }
; 3825 : 
; 3826 : /**
; 3827 :  * xmlSchemaFreeWildcard:
; 3828 :  * @wildcard:  a wildcard structure
; 3829 :  *
; 3830 :  * Deallocates a wildcard structure.
; 3831 :  */
; 3832 : void
; 3833 : xmlSchemaFreeWildcard(xmlSchemaWildcardPtr wildcard)
; 3834 : {
; 3835 :     if (wildcard == NULL)
; 3836 :         return;
; 3837 :     if (wildcard->annot != NULL)
; 3838 :         xmlSchemaFreeAnnot(wildcard->annot);
; 3839 :     if (wildcard->nsSet != NULL)
; 3840 : 	xmlSchemaFreeWildcardNsSet(wildcard->nsSet);
; 3841 :     if (wildcard->negNsSet != NULL)
; 3842 : 	xmlFree(wildcard->negNsSet);
; 3843 :     xmlFree(wildcard);
; 3844 : }
; 3845 : 
; 3846 : /**
; 3847 :  * xmlSchemaFreeAttributeGroup:
; 3848 :  * @schema:  a schema attribute group structure
; 3849 :  *
; 3850 :  * Deallocate a Schema Attribute Group structure.
; 3851 :  */
; 3852 : static void
; 3853 : xmlSchemaFreeAttributeGroup(xmlSchemaAttributeGroupPtr attrGr)
; 3854 : {
; 3855 :     if (attrGr == NULL)
; 3856 :         return;
; 3857 :     if (attrGr->annot != NULL)
; 3858 :         xmlSchemaFreeAnnot(attrGr->annot);
; 3859 :     if (attrGr->attrUses != NULL)
; 3860 : 	xmlSchemaItemListFree(WXS_LIST_CAST attrGr->attrUses);
; 3861 :     xmlFree(attrGr);
; 3862 : }
; 3863 : 
; 3864 : /**
; 3865 :  * xmlSchemaFreeQNameRef:
; 3866 :  * @item: a QName reference structure
; 3867 :  *
; 3868 :  * Deallocatea a QName reference structure.
; 3869 :  */
; 3870 : static void
; 3871 : xmlSchemaFreeQNameRef(xmlSchemaQNameRefPtr item)
; 3872 : {
; 3873 :     xmlFree(item);
; 3874 : }
; 3875 : 
; 3876 : /**
; 3877 :  * xmlSchemaFreeTypeLinkList:
; 3878 :  * @alink: a type link
; 3879 :  *
; 3880 :  * Deallocate a list of types.
; 3881 :  */
; 3882 : static void
; 3883 : xmlSchemaFreeTypeLinkList(xmlSchemaTypeLinkPtr link)
; 3884 : {
; 3885 :     xmlSchemaTypeLinkPtr next;
; 3886 : 
; 3887 :     while (link != NULL) {
; 3888 : 	next = link->next;
; 3889 : 	xmlFree(link);
; 3890 : 	link = next;
; 3891 :     }
; 3892 : }
; 3893 : 
; 3894 : static void
; 3895 : xmlSchemaFreeIDCStateObjList(xmlSchemaIDCStateObjPtr sto)
; 3896 : {
; 3897 :     xmlSchemaIDCStateObjPtr next;
; 3898 :     while (sto != NULL) {
; 3899 : 	next = sto->next;
; 3900 : 	if (sto->history != NULL)
; 3901 : 	    xmlFree(sto->history);
; 3902 : 	if (sto->xpathCtxt != NULL)
; 3903 : 	    xmlFreeStreamCtxt((xmlStreamCtxtPtr) sto->xpathCtxt);
; 3904 : 	xmlFree(sto);
; 3905 : 	sto = next;
; 3906 :     }
; 3907 : }
; 3908 : 
; 3909 : /**
; 3910 :  * xmlSchemaFreeIDC:
; 3911 :  * @idc: a identity-constraint definition
; 3912 :  *
; 3913 :  * Deallocates an identity-constraint definition.
; 3914 :  */
; 3915 : static void
; 3916 : xmlSchemaFreeIDC(xmlSchemaIDCPtr idcDef)
; 3917 : {
; 3918 :     xmlSchemaIDCSelectPtr cur, prev;
; 3919 : 
; 3920 :     if (idcDef == NULL)
; 3921 : 	return;
; 3922 :     if (idcDef->annot != NULL)
; 3923 :         xmlSchemaFreeAnnot(idcDef->annot);
; 3924 :     /* Selector */
; 3925 :     if (idcDef->selector != NULL) {
; 3926 : 	if (idcDef->selector->xpathComp != NULL)
; 3927 : 	    xmlFreePattern((xmlPatternPtr) idcDef->selector->xpathComp);
; 3928 : 	xmlFree(idcDef->selector);
; 3929 :     }
; 3930 :     /* Fields */
; 3931 :     if (idcDef->fields != NULL) {
; 3932 : 	cur = idcDef->fields;
; 3933 : 	do {
; 3934 : 	    prev = cur;
; 3935 : 	    cur = cur->next;
; 3936 : 	    if (prev->xpathComp != NULL)
; 3937 : 		xmlFreePattern((xmlPatternPtr) prev->xpathComp);
; 3938 : 	    xmlFree(prev);
; 3939 : 	} while (cur != NULL);
; 3940 :     }
; 3941 :     xmlFree(idcDef);
; 3942 : }
; 3943 : 
; 3944 : /**
; 3945 :  * xmlSchemaFreeElement:
; 3946 :  * @schema:  a schema element structure
; 3947 :  *
; 3948 :  * Deallocate a Schema Element structure.
; 3949 :  */
; 3950 : static void
; 3951 : xmlSchemaFreeElement(xmlSchemaElementPtr elem)
; 3952 : {
; 3953 :     if (elem == NULL)
; 3954 :         return;
; 3955 :     if (elem->annot != NULL)
; 3956 :         xmlSchemaFreeAnnot(elem->annot);
; 3957 :     if (elem->contModel != NULL)
; 3958 :         xmlRegFreeRegexp(elem->contModel);
; 3959 :     if (elem->defVal != NULL)
; 3960 : 	xmlSchemaFreeValue(elem->defVal);
; 3961 :     xmlFree(elem);
; 3962 : }
; 3963 : 
; 3964 : /**
; 3965 :  * xmlSchemaFreeFacet:
; 3966 :  * @facet:  a schema facet structure
; 3967 :  *
; 3968 :  * Deallocate a Schema Facet structure.
; 3969 :  */
; 3970 : void
; 3971 : xmlSchemaFreeFacet(xmlSchemaFacetPtr facet)
; 3972 : {
; 3973 :     if (facet == NULL)
; 3974 :         return;
; 3975 :     if (facet->val != NULL)
; 3976 :         xmlSchemaFreeValue(facet->val);
; 3977 :     if (facet->regexp != NULL)
; 3978 :         xmlRegFreeRegexp(facet->regexp);
; 3979 :     if (facet->annot != NULL)
; 3980 :         xmlSchemaFreeAnnot(facet->annot);
; 3981 :     xmlFree(facet);
; 3982 : }
; 3983 : 
; 3984 : /**
; 3985 :  * xmlSchemaFreeType:
; 3986 :  * @type:  a schema type structure
; 3987 :  *
; 3988 :  * Deallocate a Schema Type structure.
; 3989 :  */
; 3990 : void
; 3991 : xmlSchemaFreeType(xmlSchemaTypePtr type)
; 3992 : {
; 3993 :     if (type == NULL)
; 3994 :         return;
; 3995 :     if (type->annot != NULL)
; 3996 :         xmlSchemaFreeAnnot(type->annot);
; 3997 :     if (type->facets != NULL) {
; 3998 :         xmlSchemaFacetPtr facet, next;
; 3999 : 
; 4000 :         facet = type->facets;
; 4001 :         while (facet != NULL) {
; 4002 :             next = facet->next;
; 4003 :             xmlSchemaFreeFacet(facet);
; 4004 :             facet = next;
; 4005 :         }
; 4006 :     }
; 4007 :     if (type->attrUses != NULL)
; 4008 : 	xmlSchemaItemListFree((xmlSchemaItemListPtr) type->attrUses);
; 4009 :     if (type->memberTypes != NULL)
; 4010 : 	xmlSchemaFreeTypeLinkList(type->memberTypes);
; 4011 :     if (type->facetSet != NULL) {
; 4012 : 	xmlSchemaFacetLinkPtr next, link;
; 4013 : 
; 4014 : 	link = type->facetSet;
; 4015 : 	do {
; 4016 : 	    next = link->next;
; 4017 : 	    xmlFree(link);
; 4018 : 	    link = next;
; 4019 : 	} while (link != NULL);
; 4020 :     }
; 4021 :     if (type->contModel != NULL)
; 4022 :         xmlRegFreeRegexp(type->contModel);
; 4023 :     xmlFree(type);
; 4024 : }
; 4025 : 
; 4026 : /**
; 4027 :  * xmlSchemaFreeModelGroupDef:
; 4028 :  * @item:  a schema model group definition
; 4029 :  *
; 4030 :  * Deallocates a schema model group definition.
; 4031 :  */
; 4032 : static void
; 4033 : xmlSchemaFreeModelGroupDef(xmlSchemaModelGroupDefPtr item)
; 4034 : {
; 4035 :     if (item->annot != NULL)
; 4036 : 	xmlSchemaFreeAnnot(item->annot);
; 4037 :     xmlFree(item);
; 4038 : }
; 4039 : 
; 4040 : /**
; 4041 :  * xmlSchemaFreeModelGroup:
; 4042 :  * @item:  a schema model group
; 4043 :  *
; 4044 :  * Deallocates a schema model group structure.
; 4045 :  */
; 4046 : static void
; 4047 : xmlSchemaFreeModelGroup(xmlSchemaModelGroupPtr item)
; 4048 : {
; 4049 :     if (item->annot != NULL)
; 4050 : 	xmlSchemaFreeAnnot(item->annot);
; 4051 :     xmlFree(item);
; 4052 : }
; 4053 : 
; 4054 : static void
; 4055 : xmlSchemaComponentListFree(xmlSchemaItemListPtr list)
; 4056 : {
; 4057 :     if ((list == NULL) || (list->nbItems == 0))
; 4058 : 	return;
; 4059 :     {
; 4060 : 	xmlSchemaTreeItemPtr item;
; 4061 : 	xmlSchemaTreeItemPtr *items = (xmlSchemaTreeItemPtr *) list->items;
; 4062 : 	int i;
; 4063 : 
; 4064 : 	for (i = 0; i < list->nbItems; i++) {
; 4065 : 	    item = items[i];
; 4066 : 	    if (item == NULL)
; 4067 : 		continue;
; 4068 : 	    switch (item->type) {
; 4069 : 		case XML_SCHEMA_TYPE_SIMPLE:
; 4070 : 		case XML_SCHEMA_TYPE_COMPLEX:
; 4071 : 		    xmlSchemaFreeType((xmlSchemaTypePtr) item);
; 4072 : 		    break;
; 4073 : 		case XML_SCHEMA_TYPE_ATTRIBUTE:
; 4074 : 		    xmlSchemaFreeAttribute((xmlSchemaAttributePtr) item);
; 4075 : 		    break;
; 4076 : 		case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
; 4077 : 		    xmlSchemaFreeAttributeUse((xmlSchemaAttributeUsePtr) item);
; 4078 : 		    break;
; 4079 : 		case XML_SCHEMA_EXTRA_ATTR_USE_PROHIB:
; 4080 : 		    xmlSchemaFreeAttributeUseProhib(
; 4081 : 			(xmlSchemaAttributeUseProhibPtr) item);
; 4082 : 		    break;
; 4083 : 		case XML_SCHEMA_TYPE_ELEMENT:
; 4084 : 		    xmlSchemaFreeElement((xmlSchemaElementPtr) item);
; 4085 : 		    break;
; 4086 : 		case XML_SCHEMA_TYPE_PARTICLE:
; 4087 : 		    if (item->annot != NULL)
; 4088 : 			xmlSchemaFreeAnnot(item->annot);
; 4089 : 		    xmlFree(item);
; 4090 : 		    break;
; 4091 : 		case XML_SCHEMA_TYPE_SEQUENCE:
; 4092 : 		case XML_SCHEMA_TYPE_CHOICE:
; 4093 : 		case XML_SCHEMA_TYPE_ALL:
; 4094 : 		    xmlSchemaFreeModelGroup((xmlSchemaModelGroupPtr) item);
; 4095 : 		    break;
; 4096 : 		case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 4097 : 		    xmlSchemaFreeAttributeGroup(
; 4098 : 			(xmlSchemaAttributeGroupPtr) item);
; 4099 : 		    break;
; 4100 : 		case XML_SCHEMA_TYPE_GROUP:
; 4101 : 		    xmlSchemaFreeModelGroupDef(
; 4102 : 			(xmlSchemaModelGroupDefPtr) item);
; 4103 : 		    break;
; 4104 : 		case XML_SCHEMA_TYPE_ANY:
; 4105 : 		case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:
; 4106 : 		    xmlSchemaFreeWildcard((xmlSchemaWildcardPtr) item);
; 4107 : 		    break;
; 4108 : 		case XML_SCHEMA_TYPE_IDC_KEY:
; 4109 : 		case XML_SCHEMA_TYPE_IDC_UNIQUE:
; 4110 : 		case XML_SCHEMA_TYPE_IDC_KEYREF:
; 4111 : 		    xmlSchemaFreeIDC((xmlSchemaIDCPtr) item);
; 4112 : 		    break;
; 4113 : 		case XML_SCHEMA_TYPE_NOTATION:
; 4114 : 		    xmlSchemaFreeNotation((xmlSchemaNotationPtr) item);
; 4115 : 		    break;
; 4116 : 		case XML_SCHEMA_EXTRA_QNAMEREF:
; 4117 : 		    xmlSchemaFreeQNameRef((xmlSchemaQNameRefPtr) item);
; 4118 : 		    break;
; 4119 : 		default: {
; 4120 : 		    /* TODO: This should never be hit. */
; 4121 : 		    xmlSchemaPSimpleInternalErr(NULL,
; 4122 : 			"Internal error: xmlSchemaComponentListFree, "
; 4123 : 			"unexpected component type '%s'\n",
; 4124 : 			(const xmlChar *) WXS_ITEM_TYPE_NAME(item));
; 4125 : 			 }
; 4126 : 		    break;
; 4127 : 	    }
; 4128 : 	}
; 4129 : 	list->nbItems = 0;
; 4130 :     }
; 4131 : }
; 4132 : 
; 4133 : /**
; 4134 :  * xmlSchemaFree:
; 4135 :  * @schema:  a schema structure
; 4136 :  *
; 4137 :  * Deallocate a Schema structure.
; 4138 :  */
; 4139 : void
; 4140 : xmlSchemaFree(xmlSchemaPtr schema)
; 4141 : {
; 4142 :     if (schema == NULL)
; 4143 :         return;
; 4144 :     /* @volatiles is not used anymore :-/ */
; 4145 :     if (schema->volatiles != NULL)
; 4146 : 	TODO
; 4147 :     /*
; 4148 :     * Note that those slots are not responsible for freeing
; 4149 :     * schema components anymore; this will now be done by
; 4150 :     * the schema buckets.
; 4151 :     */
; 4152 :     if (schema->notaDecl != NULL)
; 4153 :         xmlHashFree(schema->notaDecl, NULL);
; 4154 :     if (schema->attrDecl != NULL)
; 4155 :         xmlHashFree(schema->attrDecl, NULL);
; 4156 :     if (schema->attrgrpDecl != NULL)
; 4157 :         xmlHashFree(schema->attrgrpDecl, NULL);
; 4158 :     if (schema->elemDecl != NULL)
; 4159 :         xmlHashFree(schema->elemDecl, NULL);
; 4160 :     if (schema->typeDecl != NULL)
; 4161 :         xmlHashFree(schema->typeDecl, NULL);
; 4162 :     if (schema->groupDecl != NULL)
; 4163 :         xmlHashFree(schema->groupDecl, NULL);
; 4164 :     if (schema->idcDef != NULL)
; 4165 :         xmlHashFree(schema->idcDef, NULL);
; 4166 : 
; 4167 :     if (schema->schemasImports != NULL)
; 4168 : 	xmlHashFree(schema->schemasImports, xmlSchemaBucketFreeEntry);
; 4169 :     if (schema->includes != NULL) {
; 4170 : 	xmlSchemaItemListPtr list = (xmlSchemaItemListPtr) schema->includes;
; 4171 : 	int i;
; 4172 : 	for (i = 0; i < list->nbItems; i++) {
; 4173 : 	    xmlSchemaBucketFree((xmlSchemaBucketPtr) list->items[i]);
; 4174 : 	}
; 4175 : 	xmlSchemaItemListFree(list);
; 4176 :     }
; 4177 :     if (schema->annot != NULL)
; 4178 :         xmlSchemaFreeAnnot(schema->annot);
; 4179 :     /* Never free the doc here, since this will be done by the buckets. */
; 4180 : 
; 4181 :     xmlDictFree(schema->dict);
; 4182 :     xmlFree(schema);
; 4183 : }
; 4184 : 
; 4185 : /************************************************************************
; 4186 :  *									*
; 4187 :  *			Debug functions					*
; 4188 :  *									*
; 4189 :  ************************************************************************/
; 4190 : 
; 4191 : #ifdef LIBXML_OUTPUT_ENABLED
; 4192 : 
; 4193 : static void
; 4194 : xmlSchemaTypeDump(xmlSchemaTypePtr type, FILE * output); /* forward */
; 4195 : 
; 4196 : /**
; 4197 :  * xmlSchemaElementDump:
; 4198 :  * @elem:  an element
; 4199 :  * @output:  the file output
; 4200 :  *
; 4201 :  * Dump the element
; 4202 :  */
; 4203 : static void
; 4204 : xmlSchemaElementDump(void *payload, void *data,
; 4205 :                      const xmlChar * name ATTRIBUTE_UNUSED,
; 4206 : 		     const xmlChar * namespace ATTRIBUTE_UNUSED,
; 4207 :                      const xmlChar * context ATTRIBUTE_UNUSED)
; 4208 : {
; 4209 :     xmlSchemaElementPtr elem = (xmlSchemaElementPtr) payload;
; 4210 :     FILE *output = (FILE *) data;
; 4211 :     if (elem == NULL)
; 4212 :         return;
; 4213 : 
; 4214 : 
; 4215 :     fprintf(output, "Element");
; 4216 :     if (elem->flags & XML_SCHEMAS_ELEM_GLOBAL)
; 4217 : 	fprintf(output, " (global)");
; 4218 :     fprintf(output, ": '%s' ", elem->name);
; 4219 :     if (namespace != NULL)
; 4220 : 	fprintf(output, "ns '%s'", namespace);
; 4221 :     fprintf(output, "\n");
; 4222 : #if 0
; 4223 :     if ((elem->minOccurs != 1) || (elem->maxOccurs != 1)) {
; 4224 : 	fprintf(output, "  min %d ", elem->minOccurs);
; 4225 :         if (elem->maxOccurs >= UNBOUNDED)
; 4226 :             fprintf(output, "max: unbounded\n");
; 4227 :         else if (elem->maxOccurs != 1)
; 4228 :             fprintf(output, "max: %d\n", elem->maxOccurs);
; 4229 :         else
; 4230 :             fprintf(output, "\n");
; 4231 :     }
; 4232 : #endif
; 4233 :     /*
; 4234 :     * Misc other properties.
; 4235 :     */
; 4236 :     if ((elem->flags & XML_SCHEMAS_ELEM_NILLABLE) ||
; 4237 : 	(elem->flags & XML_SCHEMAS_ELEM_ABSTRACT) ||
; 4238 : 	(elem->flags & XML_SCHEMAS_ELEM_FIXED) ||
; 4239 : 	(elem->flags & XML_SCHEMAS_ELEM_DEFAULT)) {
; 4240 : 	fprintf(output, "  props: ");
; 4241 : 	if (elem->flags & XML_SCHEMAS_ELEM_FIXED)
; 4242 : 	    fprintf(output, "[fixed] ");
; 4243 : 	if (elem->flags & XML_SCHEMAS_ELEM_DEFAULT)
; 4244 : 	    fprintf(output, "[default] ");
; 4245 : 	if (elem->flags & XML_SCHEMAS_ELEM_ABSTRACT)
; 4246 : 	    fprintf(output, "[abstract] ");
; 4247 : 	if (elem->flags & XML_SCHEMAS_ELEM_NILLABLE)
; 4248 : 	    fprintf(output, "[nillable] ");
; 4249 : 	fprintf(output, "\n");
; 4250 :     }
; 4251 :     /*
; 4252 :     * Default/fixed value.
; 4253 :     */
; 4254 :     if (elem->value != NULL)
; 4255 : 	fprintf(output, "  value: '%s'\n", elem->value);
; 4256 :     /*
; 4257 :     * Type.
; 4258 :     */
; 4259 :     if (elem->namedType != NULL) {
; 4260 : 	fprintf(output, "  type: '%s' ", elem->namedType);
; 4261 : 	if (elem->namedTypeNs != NULL)
; 4262 : 	    fprintf(output, "ns '%s'\n", elem->namedTypeNs);
; 4263 : 	else
; 4264 : 	    fprintf(output, "\n");
; 4265 :     } else if (elem->subtypes != NULL) {
; 4266 : 	/*
; 4267 : 	* Dump local types.
; 4268 : 	*/
; 4269 : 	xmlSchemaTypeDump(elem->subtypes, output);
; 4270 :     }
; 4271 :     /*
; 4272 :     * Substitution group.
; 4273 :     */
; 4274 :     if (elem->substGroup != NULL) {
; 4275 : 	fprintf(output, "  substitutionGroup: '%s' ", elem->substGroup);
; 4276 : 	if (elem->substGroupNs != NULL)
; 4277 : 	    fprintf(output, "ns '%s'\n", elem->substGroupNs);
; 4278 : 	else
; 4279 : 	    fprintf(output, "\n");
; 4280 :     }
; 4281 : }
; 4282 : 
; 4283 : /**
; 4284 :  * xmlSchemaAnnotDump:
; 4285 :  * @output:  the file output
; 4286 :  * @annot:  a annotation
; 4287 :  *
; 4288 :  * Dump the annotation
; 4289 :  */
; 4290 : static void
; 4291 : xmlSchemaAnnotDump(FILE * output, xmlSchemaAnnotPtr annot)
; 4292 : {
; 4293 :     xmlChar *content;
; 4294 : 
; 4295 :     if (annot == NULL)
; 4296 :         return;
; 4297 : 
; 4298 :     content = xmlNodeGetContent(annot->content);
; 4299 :     if (content != NULL) {
; 4300 :         fprintf(output, "  Annot: %s\n", content);
; 4301 :         xmlFree(content);
; 4302 :     } else
; 4303 :         fprintf(output, "  Annot: empty\n");
; 4304 : }
; 4305 : 
; 4306 : /**
; 4307 :  * xmlSchemaContentModelDump:
; 4308 :  * @particle: the schema particle
; 4309 :  * @output: the file output
; 4310 :  * @depth: the depth used for intentation
; 4311 :  *
; 4312 :  * Dump a SchemaType structure
; 4313 :  */
; 4314 : static void
; 4315 : xmlSchemaContentModelDump(xmlSchemaParticlePtr particle, FILE * output, int depth)
; 4316 : {
; 4317 :     xmlChar *str = NULL;
; 4318 :     xmlSchemaTreeItemPtr term;
; 4319 :     char shift[100];
; 4320 :     int i;
; 4321 : 
; 4322 :     if (particle == NULL)
; 4323 : 	return;
; 4324 :     for (i = 0;((i < depth) && (i < 25));i++)
; 4325 :         shift[2 * i] = shift[2 * i + 1] = ' ';
; 4326 :     shift[2 * i] = shift[2 * i + 1] = 0;
; 4327 :     fprintf(output, "%s", shift);
; 4328 :     if (particle->children == NULL) {
; 4329 : 	fprintf(output, "MISSING particle term\n");
; 4330 : 	return;
; 4331 :     }
; 4332 :     term = particle->children;
; 4333 :     if (term == NULL) {
; 4334 : 	fprintf(output, "(NULL)");
; 4335 :     } else {
; 4336 : 	switch (term->type) {
; 4337 : 	    case XML_SCHEMA_TYPE_ELEMENT:
; 4338 : 		fprintf(output, "ELEM '%s'", xmlSchemaFormatQName(&str,
; 4339 : 		    ((xmlSchemaElementPtr)term)->targetNamespace,
; 4340 : 		    ((xmlSchemaElementPtr)term)->name));
; 4341 : 		FREE_AND_NULL(str);
; 4342 : 		break;
; 4343 : 	    case XML_SCHEMA_TYPE_SEQUENCE:
; 4344 : 		fprintf(output, "SEQUENCE");
; 4345 : 		break;
; 4346 : 	    case XML_SCHEMA_TYPE_CHOICE:
; 4347 : 		fprintf(output, "CHOICE");
; 4348 : 		break;
; 4349 : 	    case XML_SCHEMA_TYPE_ALL:
; 4350 : 		fprintf(output, "ALL");
; 4351 : 		break;
; 4352 : 	    case XML_SCHEMA_TYPE_ANY:
; 4353 : 		fprintf(output, "ANY");
; 4354 : 		break;
; 4355 : 	    default:
; 4356 : 		fprintf(output, "UNKNOWN\n");
; 4357 : 		return;
; 4358 : 	}
; 4359 :     }
; 4360 :     if (particle->minOccurs != 1)
; 4361 : 	fprintf(output, " min: %d", particle->minOccurs);
; 4362 :     if (particle->maxOccurs >= UNBOUNDED)
; 4363 : 	fprintf(output, " max: unbounded");
; 4364 :     else if (particle->maxOccurs != 1)
; 4365 : 	fprintf(output, " max: %d", particle->maxOccurs);
; 4366 :     fprintf(output, "\n");
; 4367 :     if (term &&
; 4368 : 	((term->type == XML_SCHEMA_TYPE_SEQUENCE) ||
; 4369 : 	 (term->type == XML_SCHEMA_TYPE_CHOICE) ||
; 4370 : 	 (term->type == XML_SCHEMA_TYPE_ALL)) &&
; 4371 : 	 (term->children != NULL)) {
; 4372 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) term->children,
; 4373 : 	    output, depth +1);
; 4374 :     }
; 4375 :     if (particle->next != NULL)
; 4376 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) particle->next,
; 4377 : 		output, depth);
; 4378 : }
; 4379 : 
; 4380 : /**
; 4381 :  * xmlSchemaAttrUsesDump:
; 4382 :  * @uses:  attribute uses list
; 4383 :  * @output:  the file output
; 4384 :  *
; 4385 :  * Dumps a list of attribute use components.
; 4386 :  */
; 4387 : static void
; 4388 : xmlSchemaAttrUsesDump(xmlSchemaItemListPtr uses, FILE * output)
; 4389 : {
; 4390 :     xmlSchemaAttributeUsePtr use;
; 4391 :     xmlSchemaAttributeUseProhibPtr prohib;
; 4392 :     xmlSchemaQNameRefPtr ref;
; 4393 :     const xmlChar *name, *tns;
; 4394 :     xmlChar *str = NULL;
; 4395 :     int i;
; 4396 : 
; 4397 :     if ((uses == NULL) || (uses->nbItems == 0))
; 4398 :         return;
; 4399 : 
; 4400 :     fprintf(output, "  attributes:\n");
; 4401 :     for (i = 0; i < uses->nbItems; i++) {
; 4402 : 	use = uses->items[i];
; 4403 : 	if (use->type == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB) {
; 4404 : 	    fprintf(output, "  [prohibition] ");
; 4405 : 	    prohib = (xmlSchemaAttributeUseProhibPtr) use;
; 4406 : 	    name = prohib->name;
; 4407 : 	    tns = prohib->targetNamespace;
; 4408 : 	} else if (use->type == XML_SCHEMA_EXTRA_QNAMEREF) {
; 4409 : 	    fprintf(output, "  [reference] ");
; 4410 : 	    ref = (xmlSchemaQNameRefPtr) use;
; 4411 : 	    name = ref->name;
; 4412 : 	    tns = ref->targetNamespace;
; 4413 : 	} else {
; 4414 : 	    fprintf(output, "  [use] ");
; 4415 : 	    name = WXS_ATTRUSE_DECL_NAME(use);
; 4416 : 	    tns = WXS_ATTRUSE_DECL_TNS(use);
; 4417 : 	}
; 4418 : 	fprintf(output, "'%s'\n",
; 4419 : 	    (const char *) xmlSchemaFormatQName(&str, tns, name));
; 4420 : 	FREE_AND_NULL(str);
; 4421 :     }
; 4422 : }
; 4423 : 
; 4424 : /**
; 4425 :  * xmlSchemaTypeDump:
; 4426 :  * @output:  the file output
; 4427 :  * @type:  a type structure
; 4428 :  *
; 4429 :  * Dump a SchemaType structure
; 4430 :  */
; 4431 : static void
; 4432 : xmlSchemaTypeDump(xmlSchemaTypePtr type, FILE * output)
; 4433 : {
; 4434 :     if (type == NULL) {
; 4435 :         fprintf(output, "Type: NULL\n");
; 4436 :         return;
; 4437 :     }
; 4438 :     fprintf(output, "Type: ");
; 4439 :     if (type->name != NULL)
; 4440 :         fprintf(output, "'%s' ", type->name);
; 4441 :     else
; 4442 :         fprintf(output, "(no name) ");
; 4443 :     if (type->targetNamespace != NULL)
; 4444 : 	fprintf(output, "ns '%s' ", type->targetNamespace);
; 4445 :     switch (type->type) {
; 4446 :         case XML_SCHEMA_TYPE_BASIC:
; 4447 :             fprintf(output, "[basic] ");
; 4448 :             break;
; 4449 :         case XML_SCHEMA_TYPE_SIMPLE:
; 4450 :             fprintf(output, "[simple] ");
; 4451 :             break;
; 4452 :         case XML_SCHEMA_TYPE_COMPLEX:
; 4453 :             fprintf(output, "[complex] ");
; 4454 :             break;
; 4455 :         case XML_SCHEMA_TYPE_SEQUENCE:
; 4456 :             fprintf(output, "[sequence] ");
; 4457 :             break;
; 4458 :         case XML_SCHEMA_TYPE_CHOICE:
; 4459 :             fprintf(output, "[choice] ");
; 4460 :             break;
; 4461 :         case XML_SCHEMA_TYPE_ALL:
; 4462 :             fprintf(output, "[all] ");
; 4463 :             break;
; 4464 :         case XML_SCHEMA_TYPE_UR:
; 4465 :             fprintf(output, "[ur] ");
; 4466 :             break;
; 4467 :         case XML_SCHEMA_TYPE_RESTRICTION:
; 4468 :             fprintf(output, "[restriction] ");
; 4469 :             break;
; 4470 :         case XML_SCHEMA_TYPE_EXTENSION:
; 4471 :             fprintf(output, "[extension] ");
; 4472 :             break;
; 4473 :         default:
; 4474 :             fprintf(output, "[unknown type %d] ", type->type);
; 4475 :             break;
; 4476 :     }
; 4477 :     fprintf(output, "content: ");
; 4478 :     switch (type->contentType) {
; 4479 :         case XML_SCHEMA_CONTENT_UNKNOWN:
; 4480 :             fprintf(output, "[unknown] ");
; 4481 :             break;
; 4482 :         case XML_SCHEMA_CONTENT_EMPTY:
; 4483 :             fprintf(output, "[empty] ");
; 4484 :             break;
; 4485 :         case XML_SCHEMA_CONTENT_ELEMENTS:
; 4486 :             fprintf(output, "[element] ");
; 4487 :             break;
; 4488 :         case XML_SCHEMA_CONTENT_MIXED:
; 4489 :             fprintf(output, "[mixed] ");
; 4490 :             break;
; 4491 :         case XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS:
; 4492 : 	/* not used. */
; 4493 :             break;
; 4494 :         case XML_SCHEMA_CONTENT_BASIC:
; 4495 :             fprintf(output, "[basic] ");
; 4496 :             break;
; 4497 :         case XML_SCHEMA_CONTENT_SIMPLE:
; 4498 :             fprintf(output, "[simple] ");
; 4499 :             break;
; 4500 :         case XML_SCHEMA_CONTENT_ANY:
; 4501 :             fprintf(output, "[any] ");
; 4502 :             break;
; 4503 :     }
; 4504 :     fprintf(output, "\n");
; 4505 :     if (type->base != NULL) {
; 4506 :         fprintf(output, "  base type: '%s'", type->base);
; 4507 : 	if (type->baseNs != NULL)
; 4508 : 	    fprintf(output, " ns '%s'\n", type->baseNs);
; 4509 : 	else
; 4510 : 	    fprintf(output, "\n");
; 4511 :     }
; 4512 :     if (type->attrUses != NULL)
; 4513 : 	xmlSchemaAttrUsesDump(type->attrUses, output);
; 4514 :     if (type->annot != NULL)
; 4515 :         xmlSchemaAnnotDump(output, type->annot);
; 4516 : #ifdef DUMP_CONTENT_MODEL
; 4517 :     if ((type->type == XML_SCHEMA_TYPE_COMPLEX) &&
; 4518 : 	(type->subtypes != NULL)) {
; 4519 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) type->subtypes,
; 4520 : 	    output, 1);
; 4521 :     }
; 4522 : #endif
; 4523 : }
; 4524 : 
; 4525 : static void
; 4526 : xmlSchemaTypeDumpEntry(void *type, void *output,
; 4527 :                        const xmlChar *name ATTRIBUTE_UNUSED)
; 4528 : {
; 4529 :     xmlSchemaTypeDump((xmlSchemaTypePtr) type, (FILE *) output);
; 4530 : }
; 4531 : 
; 4532 : /**
; 4533 :  * xmlSchemaDump:
; 4534 :  * @output:  the file output
; 4535 :  * @schema:  a schema structure
; 4536 :  *
; 4537 :  * Dump a Schema structure.
; 4538 :  */
; 4539 : void
; 4540 : xmlSchemaDump(FILE * output, xmlSchemaPtr schema)
; 4541 : {
; 4542 :     if (output == NULL)
; 4543 :         return;
; 4544 :     if (schema == NULL) {
; 4545 :         fprintf(output, "Schemas: NULL\n");
; 4546 :         return;
; 4547 :     }
; 4548 :     fprintf(output, "Schemas: ");
; 4549 :     if (schema->name != NULL)
; 4550 :         fprintf(output, "%s, ", schema->name);
; 4551 :     else
; 4552 :         fprintf(output, "no name, ");
; 4553 :     if (schema->targetNamespace != NULL)
; 4554 :         fprintf(output, "%s", (const char *) schema->targetNamespace);
; 4555 :     else
; 4556 :         fprintf(output, "no target namespace");
; 4557 :     fprintf(output, "\n");
; 4558 :     if (schema->annot != NULL)
; 4559 :         xmlSchemaAnnotDump(output, schema->annot);
; 4560 :     xmlHashScan(schema->typeDecl, xmlSchemaTypeDumpEntry, output);
; 4561 :     xmlHashScanFull(schema->elemDecl, xmlSchemaElementDump, output);
; 4562 : }
; 4563 : 
; 4564 : #ifdef DEBUG_IDC_NODE_TABLE
; 4565 : /**
; 4566 :  * xmlSchemaDebugDumpIDCTable:
; 4567 :  * @vctxt: the WXS validation context
; 4568 :  *
; 4569 :  * Displays the current IDC table for debug purposes.
; 4570 :  */
; 4571 : static void
; 4572 : xmlSchemaDebugDumpIDCTable(FILE * output,
; 4573 : 			   const xmlChar *namespaceName,
; 4574 : 			   const xmlChar *localName,
; 4575 : 			   xmlSchemaPSVIIDCBindingPtr bind)
; 4576 : {
; 4577 :     xmlChar *str = NULL;
; 4578 :     const xmlChar *value;
; 4579 :     xmlSchemaPSVIIDCNodePtr tab;
; 4580 :     xmlSchemaPSVIIDCKeyPtr key;
; 4581 :     int i, j, res;
; 4582 : 
; 4583 :     fprintf(output, "IDC: TABLES on '%s'\n",
; 4584 : 	xmlSchemaFormatQName(&str, namespaceName, localName));
; 4585 :     FREE_AND_NULL(str)
; 4586 : 
; 4587 :     if (bind == NULL)
; 4588 : 	return;
; 4589 :     do {
; 4590 : 	fprintf(output, "IDC:   BINDING '%s' (%d)\n",
; 4591 : 	    xmlSchemaGetComponentQName(&str,
; 4592 : 		bind->definition), bind->nbNodes);
; 4593 : 	FREE_AND_NULL(str)
; 4594 : 	for (i = 0; i < bind->nbNodes; i++) {
; 4595 : 	    tab = bind->nodeTable[i];
; 4596 : 	    fprintf(output, "         ( ");
; 4597 : 	    for (j = 0; j < bind->definition->nbFields; j++) {
; 4598 : 		key = tab->keys[j];
; 4599 : 		if ((key != NULL) && (key->val != NULL)) {
; 4600 : 		    res = xmlSchemaGetCanonValue(key->val, &value);
; 4601 : 		    if (res >= 0)
; 4602 : 			fprintf(output, "'%s' ", value);
; 4603 : 		    else
; 4604 : 			fprintf(output, "CANON-VALUE-FAILED ");
; 4605 : 		    if (res == 0)
; 4606 : 			FREE_AND_NULL(value)
; 4607 : 		} else if (key != NULL)
; 4608 : 		    fprintf(output, "(no val), ");
; 4609 : 		else
; 4610 : 		    fprintf(output, "(key missing), ");
; 4611 : 	    }
; 4612 : 	    fprintf(output, ")\n");
; 4613 : 	}
; 4614 : 	if (bind->dupls && bind->dupls->nbItems) {
; 4615 : 	    fprintf(output, "IDC:     dupls (%d):\n", bind->dupls->nbItems);
; 4616 : 	    for (i = 0; i < bind->dupls->nbItems; i++) {
; 4617 : 		tab = bind->dupls->items[i];
; 4618 : 		fprintf(output, "         ( ");
; 4619 : 		for (j = 0; j < bind->definition->nbFields; j++) {
; 4620 : 		    key = tab->keys[j];
; 4621 : 		    if ((key != NULL) && (key->val != NULL)) {
; 4622 : 			res = xmlSchemaGetCanonValue(key->val, &value);
; 4623 : 			if (res >= 0)
; 4624 : 			    fprintf(output, "'%s' ", value);
; 4625 : 			else
; 4626 : 			    fprintf(output, "CANON-VALUE-FAILED ");
; 4627 : 			if (res == 0)
; 4628 : 			    FREE_AND_NULL(value)
; 4629 : 		    } else if (key != NULL)
; 4630 : 		    fprintf(output, "(no val), ");
; 4631 : 			else
; 4632 : 			    fprintf(output, "(key missing), ");
; 4633 : 		}
; 4634 : 		fprintf(output, ")\n");
; 4635 : 	    }
; 4636 : 	}
; 4637 : 	bind = bind->next;
; 4638 :     } while (bind != NULL);
; 4639 : }
; 4640 : #endif /* DEBUG_IDC */
; 4641 : #endif /* LIBXML_OUTPUT_ENABLED */
; 4642 : 
; 4643 : /************************************************************************
; 4644 :  *									*
; 4645 :  *			Utilities					*
; 4646 :  *									*
; 4647 :  ************************************************************************/
; 4648 : 
; 4649 : /**
; 4650 :  * xmlSchemaGetPropNode:
; 4651 :  * @node: the element node
; 4652 :  * @name: the name of the attribute
; 4653 :  *
; 4654 :  * Seeks an attribute with a name of @name in
; 4655 :  * no namespace.
; 4656 :  *
; 4657 :  * Returns the attribute or NULL if not present.
; 4658 :  */
; 4659 : static xmlAttrPtr
; 4660 : xmlSchemaGetPropNode(xmlNodePtr node, const char *name)
; 4661 : {
; 4662 :     xmlAttrPtr prop;
; 4663 : 
; 4664 :     if ((node == NULL) || (name == NULL))
; 4665 : 	return(NULL);
; 4666 :     prop = node->properties;
; 4667 :     while (prop != NULL) {

	jmp	SHORT $LN119@xmlSchemaP
$LN33@xmlSchemaP:
	xorps	xmm0, xmm0

; 3331 :     memset(ret, 0, sizeof(xmlSchemaAnnot));

	movq	QWORD PTR [eax], xmm0

; 3332 :     ret->content = node;

	mov	DWORD PTR [eax+4], ebx

; 6571 : 	ret = xmlSchemaNewAnnot(ctxt, node);

	jmp	$LN13@xmlSchemaP
$LN41@xmlSchemaP:

; 6041 :     return(xmlSchemaPValAttrNodeID(ctxt, attr));

	push	esi
	push	edi
	call	_xmlSchemaPValAttrNodeID
	add	esp, 8
$LN119@xmlSchemaP:

; 6585 :     }
; 6586 :     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
; 6587 :     /*
; 6588 :     * And now for the children...
; 6589 :     */
; 6590 :     child = node->children;

	mov	esi, ebx
	mov	ebx, DWORD PTR [esi+12]

; 6591 :     while (child != NULL) {

	test	ebx, ebx
	je	$LN5@xmlSchemaP
	npad	7
$LL4@xmlSchemaP:

; 6592 : 	if (IS_SCHEMA(child, "appinfo")) {

	test	ebx, ebx
	je	$LN22@xmlSchemaP
	cmp	DWORD PTR [ebx+36], 0
	je	$LN22@xmlSchemaP
	push	OFFSET ??_C@_07IADCAIKP@appinfo@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN17@xmlSchemaP
	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN17@xmlSchemaP

; 6593 : 	    /* TODO: make available the content of "appinfo". */
; 6594 : 	    /*
; 6595 : 	    * source = anyURI
; 6596 : 	    * {any attributes with non-schema namespace . . .}>
; 6597 : 	    * Content: ({any})*
; 6598 : 	    */
; 6599 : 	    attr = child->properties;

	mov	esi, DWORD PTR [ebx+44]

; 6600 : 	    while (attr != NULL) {

	test	esi, esi
	je	SHORT $LN7@xmlSchemaP
	npad	3
$LL6@xmlSchemaP:

; 6601 : 		if (((attr->ns == NULL) &&
; 6602 : 		     (!xmlStrEqual(attr->name, BAD_CAST "source"))) ||

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN21@xmlSchemaP
	push	OFFSET ??_C@_06OEKOLKIL@source@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlSchemaP
$LN21@xmlSchemaP:
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN19@xmlSchemaP
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@xmlSchemaP
$LN20@xmlSchemaP:

; 6603 : 		     ((attr->ns != NULL) &&
; 6604 : 		      xmlStrEqual(attr->ns->href, xmlSchemaNs))) {
; 6605 : 
; 6606 : 		    xmlSchemaPIllegalAttrErr(ctxt,

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN19@xmlSchemaP:

; 6607 : 			XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 6608 : 		}
; 6609 : 		attr = attr->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL6@xmlSchemaP
$LN7@xmlSchemaP:

; 6610 : 	    }
; 6611 : 	    xmlSchemaPValAttr(ctxt, NULL, child, "source",

	push	29					; 0000001dH
	call	_xmlSchemaGetBuiltInType
	mov	esi, eax
	add	esp, 4

; 6425 :     if ((ctxt == NULL) || (type == NULL)) {

	test	esi, esi
	je	SHORT $LN124@xmlSchemaP

; 6426 : 	if (value != NULL)
; 6427 : 	    *value = NULL;
; 6428 : 	return (-1);
; 6429 :     }
; 6430 :     if (type->type != XML_SCHEMA_TYPE_BASIC) {

	cmp	DWORD PTR [esi], 1
	je	SHORT $LN52@xmlSchemaP

; 6431 : 	if (value != NULL)
; 6432 : 	    *value = NULL;
; 6433 : 	xmlSchemaPErr(ctxt, ownerElem,

	push	0
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0FA@OJBBBDML@Internal?5error?3?5xmlSchemaPValAt@
	push	3069					; 00000bfdH
	push	ebx
	push	edi
	call	_xmlSchemaPErr
	add	esp, 24					; 00000018H
$LN124@xmlSchemaP:

; 6591 :     while (child != NULL) {

	mov	esi, DWORD PTR _node$[ebp]
$LN23@xmlSchemaP:
	mov	ecx, DWORD PTR [ebx+24]
	mov	ebx, ecx
	test	ecx, ecx
	jne	$LL4@xmlSchemaP
$LN5@xmlSchemaP:

; 6653 : 	    child = child->next;
; 6654 : 	}
; 6655 :     }
; 6656 : 
; 6657 :     return (ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	esi
	pop	edi

; 6658 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@xmlSchemaP:

; 6440 :     attr = xmlSchemaGetPropNode(ownerElem, name);

	push	OFFSET ??_C@_06OEKOLKIL@source@
	push	ebx
	call	_xmlSchemaGetPropNode
	add	esp, 8

; 6441 :     if (attr == NULL) {

	test	eax, eax
	je	SHORT $LN124@xmlSchemaP

; 6442 : 	if (value != NULL)
; 6443 : 	    *value = NULL;
; 6444 : 	return (0);
; 6445 :     }
; 6446 :     return (xmlSchemaPValAttrNode(ctxt, ownerItem, attr,

	push	0
	push	esi
	push	eax
	push	0
	push	edi
	call	_xmlSchemaPValAttrNode
	add	esp, 20					; 00000014H

; 6612 : 		xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI), NULL);
; 6613 : 	    child = child->next;

	jmp	SHORT $LN124@xmlSchemaP
$LN17@xmlSchemaP:

; 6614 : 	} else if (IS_SCHEMA(child, "documentation")) {

	cmp	DWORD PTR [ebx+36], 0
	je	$LN22@xmlSchemaP
	push	OFFSET ??_C@_0O@JMIFCMPP@documentation@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN22@xmlSchemaP
	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN22@xmlSchemaP

; 6615 : 	    /* TODO: make available the content of "documentation". */
; 6616 : 	    /*
; 6617 : 	    * source = anyURI
; 6618 : 	    * {any attributes with non-schema namespace . . .}>
; 6619 : 	    * Content: ({any})*
; 6620 : 	    */
; 6621 : 	    attr = child->properties;

	mov	esi, DWORD PTR [ebx+44]

; 6622 : 	    while (attr != NULL) {

	test	esi, esi
	je	$LN124@xmlSchemaP
$LL8@xmlSchemaP:

; 6623 : 		if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN24@xmlSchemaP

; 6624 : 		    if (!xmlStrEqual(attr->name, BAD_CAST "source")) {

	push	OFFSET ??_C@_06OEKOLKIL@source@
	push	DWORD PTR [esi+8]

; 6625 : 			xmlSchemaPIllegalAttrErr(ctxt,
; 6626 : 			    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 6627 : 		    }
; 6628 : 		} else {

	jmp	SHORT $LN129@xmlSchemaP
$LN24@xmlSchemaP:

; 6629 : 		    if (xmlStrEqual(attr->ns->href, xmlSchemaNs) ||

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN28@xmlSchemaP
	push	OFFSET ??_C@_04IOHABJIC@lang@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	DWORD PTR [eax+8]
$LN129@xmlSchemaP:

; 6630 : 			(xmlStrEqual(attr->name, BAD_CAST "lang") &&
; 6631 : 			(!xmlStrEqual(attr->ns->href, XML_XML_NAMESPACE)))) {
; 6632 : 
; 6633 : 			xmlSchemaPIllegalAttrErr(ctxt,
; 6634 : 			    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 6635 : 		    }
; 6636 : 		}
; 6637 : 		attr = attr->next;

	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@xmlSchemaP
$LN28@xmlSchemaP:
	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN27@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL8@xmlSchemaP

; 6601 : 		if (((attr->ns == NULL) &&
; 6602 : 		     (!xmlStrEqual(attr->name, BAD_CAST "source"))) ||

	mov	esi, DWORD PTR [ebx+44]

; 4694 :     while (prop != NULL) {

	test	esi, esi
	je	$LN124@xmlSchemaP
$LL58@xmlSchemaP:

; 4695 : 	if ((prop->ns != NULL) &&
; 4696 : 	    xmlStrEqual(prop->name, BAD_CAST name) &&

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN62@xmlSchemaP
	push	OFFSET ??_C@_04IOHABJIC@lang@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN62@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN57@xmlSchemaP
$LN62@xmlSchemaP:

; 4697 : 	    xmlStrEqual(prop->ns->href, BAD_CAST uri))
; 4698 : 	    return(prop);
; 4699 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL58@xmlSchemaP

; 4671 :     }
; 4672 :     return (NULL);
; 4673 : }
; 4674 : 
; 4675 : /**
; 4676 :  * xmlSchemaGetPropNodeNs:
; 4677 :  * @node: the element node
; 4678 :  * @uri: the uri
; 4679 :  * @name: the name of the attribute
; 4680 :  *
; 4681 :  * Seeks an attribute with a local name of @name and
; 4682 :  * a namespace URI of @uri.
; 4683 :  *
; 4684 :  * Returns the attribute or NULL if not present.
; 4685 :  */
; 4686 : static xmlAttrPtr
; 4687 : xmlSchemaGetPropNodeNs(xmlNodePtr node, const char *uri, const char *name)
; 4688 : {
; 4689 :     xmlAttrPtr prop;
; 4690 : 
; 4691 :     if ((node == NULL) || (name == NULL))
; 4692 : 	return(NULL);
; 4693 :     prop = node->properties;
; 4694 :     while (prop != NULL) {

	jmp	$LN124@xmlSchemaP
$LN57@xmlSchemaP:

; 6638 : 	    }
; 6639 : 	    /*
; 6640 : 	    * Attribute "xml:lang".
; 6641 : 	    */
; 6642 : 	    attr = xmlSchemaGetPropNodeNs(child, (const char *) XML_XML_NAMESPACE, "lang");
; 6643 : 	    if (attr != NULL)
; 6644 : 		xmlSchemaPValAttrNode(ctxt, NULL, attr,

	push	17					; 00000011H
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	mov	DWORD PTR _type$1$[ebp], eax

; 6385 :     if ((ctxt == NULL) || (type == NULL) || (attr == NULL))

	test	eax, eax
	je	$LN124@xmlSchemaP

; 6386 : 	return (-1);
; 6387 : 
; 6388 :     val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	push	esi
	push	edi
	call	_xmlSchemaGetNodeContent

; 6389 :     if (value != NULL)
; 6390 : 	*value = val;
; 6391 : 
; 6392 :     return (xmlSchemaPValAttrNodeValue(ctxt, ownerItem, attr,

	push	DWORD PTR _type$1$[ebp]
	push	eax
	push	esi
	push	0
	push	edi
	call	_xmlSchemaPValAttrNodeValue
	add	esp, 28					; 0000001cH

; 6645 : 		xmlSchemaGetBuiltInType(XML_SCHEMAS_LANGUAGE), NULL);
; 6646 : 	    child = child->next;
; 6647 : 	} else {

	jmp	$LN124@xmlSchemaP
$LN22@xmlSchemaP:

; 6648 : 	    if (!barked)

	cmp	DWORD PTR _barked$1$[ebp], 0
	jne	SHORT $LN74@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	esi
	push	0
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0BL@CHHJOIII@?$CIappinfo?5?$HM?5documentation?$CJ?$CK@
	push	DWORD PTR _des$1[ebp]
	test	ebx, ebx
	mov	eax, ebx
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	cmove	eax, esi
	push	eax
	push	edi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN74@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN74@xmlSchemaP:

; 6649 : 		xmlSchemaPContentErr(ctxt,
; 6650 : 		    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 6651 : 		    NULL, node, child, NULL, "(appinfo | documentation)*");
; 6652 : 	    barked = 1;

	mov	DWORD PTR _barked$1$[ebp], 1

; 6385 :     if ((ctxt == NULL) || (type == NULL) || (attr == NULL))

	jmp	$LN23@xmlSchemaP
$LN11@xmlSchemaP:
	pop	edi

; 6569 :         return (NULL);

	xor	eax, eax

; 6658 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseAnnotation ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseLocalAttributes
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_child$ = 16						; size = 4
_list$ = 20						; size = 4
_parentType$ = 24					; size = 4
_hasRefs$ = 28						; size = 4
_xmlSchemaParseLocalAttributes PROC			; COMDAT

; 6512 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _child$[ebp]
	mov	ebx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [esi]
$LN26@xmlSchemaP:

; 6513 :     void *item;
; 6514 : 
; 6515 :     while ((IS_SCHEMA((*child), "attribute")) ||

	mov	edi, DWORD PTR _schema$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaP
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN5@xmlSchemaP
	push	OFFSET ??_C@_09HGIEBAJ@attribute@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlSchemaP
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR _xmlSchemaNs
	mov	eax, DWORD PTR [eax+36]
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@xmlSchemaP
$LN5@xmlSchemaP:
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	$LN3@xmlSchemaP
	cmp	DWORD PTR [eax+36], 0
	je	$LN3@xmlSchemaP
	push	OFFSET ??_C@_0P@KIDCOMBF@attributeGroup@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN3@xmlSchemaP
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR _xmlSchemaNs
	mov	eax, DWORD PTR [eax+36]
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN3@xmlSchemaP
$LN4@xmlSchemaP:

; 6516 :            (IS_SCHEMA((*child), "attributeGroup"))) {
; 6517 :         if (IS_SCHEMA((*child), "attribute")) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xmlSchemaP
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN6@xmlSchemaP
	push	OFFSET ??_C@_09HGIEBAJ@attribute@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlSchemaP
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR _xmlSchemaNs
	mov	eax, DWORD PTR [eax+36]
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlSchemaP

; 6518 : 	    item = xmlSchemaParseLocalAttribute(ctxt, schema, *child,

	push	DWORD PTR _parentType$[ebp]
	push	DWORD PTR [ebx]
	push	DWORD PTR [esi]
	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaParseLocalAttribute
	add	esp, 20					; 00000014H
	mov	edi, eax

; 6519 : 		*list, parentType);
; 6520 :         } else {

	jmp	SHORT $LN8@xmlSchemaP
$LN6@xmlSchemaP:

; 6521 :             item = xmlSchemaParseAttributeGroupRef(ctxt, schema, *child);

	push	DWORD PTR [esi]
	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaParseAttributeGroupRef
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 6522 : 	    if ((item != NULL) && (hasRefs != NULL))

	test	edi, edi
	je	SHORT $LN12@xmlSchemaP
	mov	eax, DWORD PTR _hasRefs$[ebp]
	test	eax, eax
	je	SHORT $LN8@xmlSchemaP

; 6523 : 		*hasRefs = 1;

	mov	DWORD PTR [eax], 1
$LN8@xmlSchemaP:

; 6524 :         }
; 6525 : 	if (item != NULL) {

	test	edi, edi
	je	SHORT $LN12@xmlSchemaP

; 6526 : 	    if (*list == NULL) {

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	jne	SHORT $LN11@xmlSchemaP

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 3342 :     if (ret == NULL) {

	test	eax, eax
	je	SHORT $LN25@xmlSchemaP
	xorps	xmm0, xmm0

; 3343 : 	xmlSchemaPErrMemory(NULL,
; 3344 : 	    "allocating an item list structure", NULL);
; 3345 : 	return (NULL);
; 3346 :     }
; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));

	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], 0

; 6527 : 		/* TODO: Customize grow factor. */
; 6528 : 		*list = xmlSchemaItemListCreate();

	mov	DWORD PTR [ebx], eax
$LN11@xmlSchemaP:

; 6529 : 		if (*list == NULL)
; 6530 : 		    return(-1);
; 6531 : 	    }
; 6532 : 	    if (xmlSchemaItemListAddSize(*list, 2, item) == -1)

	push	edi
	push	2
	push	eax
	call	_xmlSchemaItemListAddSize
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	je	SHORT $LN22@xmlSchemaP
$LN12@xmlSchemaP:

; 6533 : 		return(-1);
; 6534 : 	}
; 6535 :         *child = (*child)->next;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR [esi], eax

; 6536 :     }

	jmp	$LN26@xmlSchemaP
$LN25@xmlSchemaP:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@BAFOADOL@allocating?5an?5item?5list?5structu@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 6527 : 		/* TODO: Customize grow factor. */
; 6528 : 		*list = xmlSchemaItemListCreate();

	mov	DWORD PTR [ebx], 0
$LN22@xmlSchemaP:

; 6537 :     return (0);
; 6538 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemaP:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaParseLocalAttributes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckReference
_TEXT	SEGMENT
_msg$1 = 8						; size = 4
_msg$2 = 8						; size = 4
_pctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_attr$ = 20						; size = 4
_namespaceName$ = 24					; size = 4
_xmlSchemaCheckReference PROC				; COMDAT

; 6456 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _pctxt$[ebp]
	mov	edi, DWORD PTR _namespaceName$[ebp]
	push	edi
	push	DWORD PTR [ebx+112]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN32@xmlSchemaC

; 6457 :     /* TODO: Pointer comparison instead? */
; 6458 :     if (xmlStrEqual(pctxt->targetNamespace, namespaceName))
; 6459 : 	return (0);
; 6460 :     if (xmlStrEqual(xmlSchemaNs, namespaceName))

	push	edi
	push	DWORD PTR _xmlSchemaNs
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN32@xmlSchemaC

; 6461 : 	return (0);
; 6462 :     /*
; 6463 :     * Check if the referenced namespace was <import>ed.
; 6464 :     */
; 6465 :     if (WXS_BUCKET(pctxt)->relations != NULL) {

	mov	eax, DWORD PTR [ebx+28]
	mov	eax, DWORD PTR [eax+16]
	mov	esi, DWORD PTR [eax+24]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaC
	npad	2
$LL4@xmlSchemaC:

; 6466 : 	xmlSchemaSchemaRelationPtr rel;
; 6467 : 
; 6468 : 	rel = WXS_BUCKET(pctxt)->relations;
; 6469 : 	do {
; 6470 : 	    if (WXS_IS_BUCKET_IMPMAIN(rel->type) &&

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN34@xmlSchemaC
	cmp	eax, 1
	jne	SHORT $LN8@xmlSchemaC
$LN34@xmlSchemaC:
	push	DWORD PTR [esi+8]
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN32@xmlSchemaC
$LN8@xmlSchemaC:

; 6471 : 		xmlStrEqual(namespaceName, rel->importNamespace))
; 6472 : 		return (0);
; 6473 : 	    rel = rel->next;

	mov	esi, DWORD PTR [esi]

; 6474 : 	} while (rel != NULL);

	test	esi, esi
	jne	SHORT $LL4@xmlSchemaC
$LN3@xmlSchemaC:

; 6475 :     }
; 6476 :     /*
; 6477 :     * No matching <import>ed namespace found.
; 6478 :     */
; 6479 :     {
; 6480 : 	xmlNodePtr n = (attr != NULL) ? (xmlNodePtr) attr : node;

	mov	eax, DWORD PTR _attr$[ebp]
	test	eax, eax
	mov	esi, DWORD PTR _node$[ebp]
	cmovne	esi, eax

; 6481 : 
; 6482 : 	if (namespaceName == NULL)

	mov	DWORD PTR _msg$2[ebp], 0
	push	esi
	lea	eax, DWORD PTR _msg$2[ebp]
	push	ebx
	push	eax
	call	_xmlSchemaFormatNodeForError
	test	edi, edi
	jne	SHORT $LN10@xmlSchemaC

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0HG@LIIBNHFM@References?5from?5this?5schema?5to?5@
	push	DWORD PTR _msg$2[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$2[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	edi
	push	edi
	push	edi
	push	edi

; 6483 : 	    xmlSchemaCustomErr(ACTXT_CAST pctxt,

	jmp	SHORT $LN37@xmlSchemaC
$LN10@xmlSchemaC:

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0HM@PFGFDKAG@References?5from?5this?5schema?5to?5@
	push	DWORD PTR _msg$1[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	edi
$LN37@xmlSchemaC:

; 6484 : 		XML_SCHEMAP_SRC_RESOLVE, n, NULL,
; 6485 : 		"References from this schema to components in no "
; 6486 : 		"namespace are not allowed, since not indicated by an "
; 6487 : 		"import statement", NULL, NULL);
; 6488 : 	else
; 6489 : 	    xmlSchemaCustomErr(ACTXT_CAST pctxt,
; 6490 : 		XML_SCHEMAP_SRC_RESOLVE, n, NULL,
; 6491 : 		"References from this schema to components in the "
; 6492 : 		"namespace '%s' are not allowed, since not indicated by an "
; 6493 : 		"import statement", namespaceName, NULL);
; 6494 :     }
; 6495 :     return (XML_SCHEMAP_SRC_RESOLVE);

	push	eax
	push	0
	push	esi
	push	3004					; 00000bbcH
	push	2
	push	ebx
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlSchemaErr4Line
	mov	eax, DWORD PTR _msg$1[ebp]
	add	esp, 68					; 00000044H
	test	eax, eax
	je	SHORT $LN27@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN27@xmlSchemaC:

; 6496 : }

	pop	edi
	pop	esi
	mov	eax, 3004				; 00000bbcH
	pop	ebx
	pop	ebp
	ret	0
$LN32@xmlSchemaC:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaCheckReference ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPValAttr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_ownerItem$ = 12					; size = 4
_ownerElem$ = 16					; size = 4
_name$ = 20						; size = 4
_type$ = 24						; size = 4
_value$ = 28						; size = 4
_xmlSchemaPValAttr PROC					; COMDAT

; 6422 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlSchemaP

; 6423 :     xmlAttrPtr attr;
; 6424 : 
; 6425 :     if ((ctxt == NULL) || (type == NULL)) {

	mov	esi, DWORD PTR _type$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaP

; 6428 : 	return (-1);
; 6429 :     }
; 6430 :     if (type->type != XML_SCHEMA_TYPE_BASIC) {

	cmp	DWORD PTR [esi], 1
	je	SHORT $LN5@xmlSchemaP

; 6431 : 	if (value != NULL)

	mov	eax, DWORD PTR _value$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlSchemaP

; 6432 : 	    *value = NULL;

	mov	DWORD PTR [eax], 0
$LN6@xmlSchemaP:

; 6433 : 	xmlSchemaPErr(ctxt, ownerElem,

	push	0
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0FA@OJBBBDML@Internal?5error?3?5xmlSchemaPValAt@
	push	3069					; 00000bfdH
	push	DWORD PTR _ownerElem$[ebp]
	push	edi
	call	_xmlSchemaPErr
	add	esp, 24					; 00000018H

; 6447 : 	type, value));
; 6448 : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN5@xmlSchemaP:

; 6434 : 	    XML_SCHEMAP_INTERNAL,
; 6435 : 	    "Internal error: xmlSchemaPValAttr, the given "
; 6436 : 	    "type '%s' is not a built-in type.\n",
; 6437 : 	    type->name, NULL);
; 6438 : 	return (-1);
; 6439 :     }
; 6440 :     attr = xmlSchemaGetPropNode(ownerElem, name);

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _ownerElem$[ebp]
	call	_xmlSchemaGetPropNode
	add	esp, 8

; 6441 :     if (attr == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlSchemaP

; 6442 : 	if (value != NULL)

	mov	eax, DWORD PTR _value$[ebp]
	test	eax, eax
	je	SHORT $LN8@xmlSchemaP

; 6443 : 	    *value = NULL;

	mov	DWORD PTR [eax], 0
$LN8@xmlSchemaP:
	pop	edi

; 6444 : 	return (0);

	xor	eax, eax

; 6447 : 	type, value));
; 6448 : }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlSchemaP:

; 6445 :     }
; 6446 :     return (xmlSchemaPValAttrNode(ctxt, ownerItem, attr,

	push	DWORD PTR _value$[ebp]
	push	esi
	push	eax
	push	DWORD PTR _ownerItem$[ebp]
	push	edi
	call	_xmlSchemaPValAttrNode
	add	esp, 20					; 00000014H
	pop	edi

; 6447 : 	type, value));
; 6448 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlSchemaP:

; 6426 : 	if (value != NULL)

	mov	eax, DWORD PTR _value$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaP

; 6427 : 	    *value = NULL;

	mov	DWORD PTR [eax], 0
$LN4@xmlSchemaP:
	pop	edi

; 6447 : 	type, value));
; 6448 : }

	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
_xmlSchemaPValAttr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPValAttrNode
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_ownerItem$ = 12					; size = 4
_attr$ = 16						; size = 4
_type$ = 20						; size = 4
_value$ = 24						; size = 4
_xmlSchemaPValAttrNode PROC				; COMDAT

; 6382 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaP

; 6383 :     const xmlChar *val;
; 6384 : 
; 6385 :     if ((ctxt == NULL) || (type == NULL) || (attr == NULL))

	cmp	DWORD PTR _type$[ebp], 0
	je	SHORT $LN3@xmlSchemaP
	mov	edi, DWORD PTR _attr$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlSchemaP

; 6387 : 
; 6388 :     val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);

	push	edi
	push	esi
	call	_xmlSchemaGetNodeContent

; 6389 :     if (value != NULL)

	mov	ecx, DWORD PTR _value$[ebp]
	add	esp, 8
	test	ecx, ecx
	je	SHORT $LN4@xmlSchemaP

; 6390 : 	*value = val;

	mov	DWORD PTR [ecx], eax
$LN4@xmlSchemaP:

; 6391 : 
; 6392 :     return (xmlSchemaPValAttrNodeValue(ctxt, ownerItem, attr,

	push	DWORD PTR _type$[ebp]
	push	eax
	push	edi
	push	DWORD PTR _ownerItem$[ebp]
	push	esi
	call	_xmlSchemaPValAttrNodeValue
	add	esp, 20					; 00000014H
	pop	edi

; 6393 : 	val, type));
; 6394 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlSchemaP:
	pop	edi

; 6386 : 	return (-1);

	or	eax, -1

; 6393 : 	val, type));
; 6394 : }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaPValAttrNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPValAttrNodeValue
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_ownerItem$ = 12					; size = 4
_attr$ = 16						; size = 4
_value$ = 20						; size = 4
_type$ = 24						; size = 4
_xmlSchemaPValAttrNodeValue PROC			; COMDAT

; 6309 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pctxt$[ebp]
	test	edi, edi
	je	SHORT $LN5@xmlSchemaP

; 6310 : 
; 6311 :     int ret = 0;
; 6312 : 
; 6313 :     /*
; 6314 :     * NOTE: Should we move this to xmlschematypes.c? Hmm, but this
; 6315 :     * one is really meant to be used internally, so better not.
; 6316 :     */
; 6317 :     if ((pctxt == NULL) || (type == NULL) || (attr == NULL))

	mov	ebx, DWORD PTR _type$[ebp]
	test	ebx, ebx
	je	SHORT $LN5@xmlSchemaP
	mov	ecx, DWORD PTR _attr$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@xmlSchemaP

; 6318 : 	return (-1);
; 6319 :     if (type->type != XML_SCHEMA_TYPE_BASIC) {

	cmp	DWORD PTR [ebx], 1
	je	SHORT $LN6@xmlSchemaP

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CG@JADIGFME@the?5given?5type?5is?5not?5a?5built?9i@
	push	OFFSET ??_C@_0BL@CNLGMFJP@xmlSchemaPValAttrNodeValue@
	push	edi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H
$LN5@xmlSchemaP:
	pop	edi

; 6357 : }

	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlSchemaP:

; 6320 : 	PERROR_INT("xmlSchemaPValAttrNodeValue",
; 6321 : 	    "the given type is not a built-in type");
; 6322 : 	return (-1);
; 6323 :     }
; 6324 :     switch (type->builtInType) {

	mov	eax, DWORD PTR [ebx+88]
	add	eax, -16				; fffffff0H
	cmp	eax, 13					; 0000000dH
	ja	SHORT $LN8@xmlSchemaP
	movzx	eax, BYTE PTR $LN17@xmlSchemaP[eax]
	jmp	DWORD PTR $LN21@xmlSchemaP[eax*4]
$LN7@xmlSchemaP:
	push	esi

; 6325 : 	case XML_SCHEMAS_NCNAME:
; 6326 : 	case XML_SCHEMAS_QNAME:
; 6327 : 	case XML_SCHEMAS_ANYURI:
; 6328 : 	case XML_SCHEMAS_TOKEN:
; 6329 : 	case XML_SCHEMAS_LANGUAGE:
; 6330 : 	    ret = xmlSchemaValPredefTypeNode(type, value, NULL,

	push	ecx
	push	0
	push	DWORD PTR _value$[ebp]
	push	ebx
	call	_xmlSchemaValPredefTypeNode
	mov	esi, eax
	add	esp, 16					; 00000010H

; 6338 : 	}
; 6339 :     }
; 6340 :     /*
; 6341 :     * TODO: Should we use the S4S error codes instead?
; 6342 :     */
; 6343 :     if (ret < 0) {

	test	esi, esi
	jns	SHORT $LN19@xmlSchemaP

; 6344 : 	PERROR_INT("xmlSchemaPValAttrNodeValue",

	push	OFFSET ??_C@_0CM@DLDNHDND@failed?5to?5validate?5a?5schema?5att@
	push	OFFSET ??_C@_0BL@CNLGMFJP@xmlSchemaPValAttrNodeValue@
	push	edi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH

; 6345 : 	    "failed to validate a schema attribute value");
; 6346 : 	return (-1);

	or	eax, -1
	pop	esi
	pop	edi

; 6357 : }

	pop	ebx
	pop	ebp
	ret	0
$LN19@xmlSchemaP:

; 6347 :     } else if (ret > 0) {

	jle	SHORT $LN11@xmlSchemaP

; 6348 : 	if (WXS_IS_LIST(type))

	mov	esi, DWORD PTR [ebx+48]

; 6349 : 	    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2;
; 6350 : 	else
; 6351 : 	    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1;
; 6352 : 	xmlSchemaPSimpleTypeErr(pctxt,

	push	0
	push	0
	push	0
	push	DWORD PTR _value$[ebp]
	and	esi, 64					; 00000040H
	push	0
	push	ebx
	push	DWORD PTR _attr$[ebp]
	or	esi, 116736				; 0001c800H
	push	DWORD PTR _ownerItem$[ebp]
	shr	esi, 6
	push	esi
	push	edi
	call	_xmlSchemaPSimpleTypeErr
	add	esp, 40					; 00000028H
$LN11@xmlSchemaP:

; 6353 : 	    ret, ownerItem, (xmlNodePtr) attr,
; 6354 : 	    type, NULL, value, NULL, NULL, NULL);
; 6355 :     }
; 6356 :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 6357 : }

	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlSchemaP:

; 6331 : 		(xmlNodePtr) attr);
; 6332 : 	    break;
; 6333 : 	default: {
; 6334 : 	    PERROR_INT("xmlSchemaPValAttrNodeValue",

	push	OFFSET ??_C@_0EI@OLDONBHK@validation?5using?5the?5given?5type@
	push	OFFSET ??_C@_0BL@CNLGMFJP@xmlSchemaPValAttrNodeValue@
	push	edi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH

; 6335 : 		"validation using the given type is not supported while "
; 6336 : 		"parsing a schema");
; 6337 : 	    return (-1);

	or	eax, -1
	pop	edi

; 6357 : }

	pop	ebx
	pop	ebp
	ret	0
	npad	1
$LN21@xmlSchemaP:
	DD	$LN7@xmlSchemaP
	DD	$LN8@xmlSchemaP
$LN17@xmlSchemaP:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
_xmlSchemaPValAttrNodeValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseAnyAttribute
_TEXT	SEGMENT
_ret$1$ = -4						; size = 4
_des$1 = 8						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaParseAnyAttribute PROC			; COMDAT

; 7074 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN5@xmlSchemaP

; 7075 :     xmlSchemaWildcardPtr ret;
; 7076 :     xmlNodePtr child = NULL;
; 7077 :     xmlAttrPtr attr;
; 7078 : 
; 7079 :     if ((ctxt == NULL) || (schema == NULL) || (node == NULL))

	mov	eax, DWORD PTR _schema$[ebp]
	test	eax, eax
	je	$LN5@xmlSchemaP
	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	$LN5@xmlSchemaP

; 7080 :         return (NULL);
; 7081 : 
; 7082 :     ret = xmlSchemaAddWildcard(ctxt, schema, XML_SCHEMA_TYPE_ANY_ATTRIBUTE,

	push	ebx
	push	21					; 00000015H
	push	eax
	push	edi
	call	_xmlSchemaAddWildcard
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$1$[ebp], eax

; 7083 : 	node);
; 7084 :     if (ret == NULL) {

	test	eax, eax
	je	$LN5@xmlSchemaP

; 7085 :         return (NULL);
; 7086 :     }
; 7087 :     /*
; 7088 :     * Check for illegal attributes.
; 7089 :     */
; 7090 :     attr = node->properties;

	mov	esi, DWORD PTR [ebx+44]

; 7091 :     while (attr != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlSchemaP
$LL2@xmlSchemaP:

; 7092 : 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN7@xmlSchemaP

; 7093 : 	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
; 7094 : 	        (!xmlStrEqual(attr->name, BAD_CAST "namespace")) &&

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@xmlSchemaP
	push	OFFSET ??_C@_09KPMGAFNI@namespace@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@xmlSchemaP
	push	OFFSET ??_C@_0BA@LJOIJHLO@processContents@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@xmlSchemaP

; 7095 : 		(!xmlStrEqual(attr->name, BAD_CAST "processContents"))) {
; 7096 : 		xmlSchemaPIllegalAttrErr(ctxt,
; 7097 : 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 7098 : 	    }

	jmp	SHORT $LN44@xmlSchemaP
$LN7@xmlSchemaP:

; 7099 : 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlSchemaP
$LN44@xmlSchemaP:

; 7100 : 	    xmlSchemaPIllegalAttrErr(ctxt,
; 7101 : 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 7102 : 	}
; 7103 : 	attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN10@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaP
$LN3@xmlSchemaP:

; 7104 :     }
; 7105 :     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	ebx
	push	edi
	call	_xmlSchemaPValAttrID

; 7106 :     /*
; 7107 :     * Parse the namespace list.
; 7108 :     */
; 7109 :     if (xmlSchemaParseWildcardNs(ctxt, schema, ret, node) != 0)

	push	ebx
	push	DWORD PTR _ret$1$[ebp]
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaParseWildcardNs
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	$LN5@xmlSchemaP

; 7110 : 	return (NULL);
; 7111 :     /*
; 7112 :     * And now for the children...
; 7113 :     */
; 7114 :     child = node->children;

	mov	esi, DWORD PTR [ebx+12]

; 7115 :     if (IS_SCHEMA(child, "annotation")) {

	test	esi, esi
	je	$LN20@xmlSchemaP
	cmp	DWORD PTR [esi+36], eax
	je	SHORT $LN12@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlSchemaP

; 7116 :         ret->annot = xmlSchemaParseAnnotation(ctxt, child, 1);

	push	1
	push	esi
	push	edi
	call	_xmlSchemaParseAnnotation
	mov	ecx, DWORD PTR _ret$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+8], eax

; 7117 :         child = child->next;

	mov	esi, DWORD PTR [esi+24]
$LN12@xmlSchemaP:

; 7118 :     }
; 7119 :     if (child != NULL) {

	test	esi, esi
	je	SHORT $LN20@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	0
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0O@MNAJHLGE@?$CIannotation?$DP?$CJ@
	push	DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	edi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN20@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN20@xmlSchemaP:

; 7120 : 	xmlSchemaPContentErr(ctxt,
; 7121 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 7122 : 	    NULL, node, child,
; 7123 : 	    NULL, "(annotation?)");
; 7124 :     }
; 7125 : 
; 7126 :     return (ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 7127 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlSchemaP:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseAnyAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseList
_TEXT	SEGMENT
_des$1 = -4						; size = 4
_type$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaParseList PROC				; COMDAT

; 9065 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN160@xmlSchemaP

; 9066 :     xmlSchemaTypePtr type;
; 9067 :     xmlNodePtr child = NULL;
; 9068 :     xmlAttrPtr attr;
; 9069 : 
; 9070 :     if ((ctxt == NULL) || (schema == NULL) || (node == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	$LN160@xmlSchemaP
	push	ebx
	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	$LN164@xmlSchemaP

; 9072 :     /* Not a component, don't create it. */
; 9073 :     type = ctxt->ctxtType;

	push	esi
	mov	esi, DWORD PTR [edi+84]

; 9074 :     /*
; 9075 :     * Mark the type as being of variety "list".
; 9076 :     */
; 9077 :     type->flags |= XML_SCHEMAS_TYPE_VARIETY_LIST;
; 9078 :     /*
; 9079 :     * SPEC (Base type) (2) "If the <list> or <union> alternative is chosen,
; 9080 :     * then the `simple ur-type definition`."
; 9081 :     */
; 9082 :     type->baseType = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);

	push	46					; 0000002eH
	mov	DWORD PTR _type$1$[ebp], esi
	or	DWORD PTR [esi+48], 64			; 00000040H
	call	_xmlSchemaGetBuiltInType
	mov	DWORD PTR [esi+64], eax
	add	esp, 4

; 9083 :     /*
; 9084 :     * Check for illegal attributes.
; 9085 :     */
; 9086 :     attr = node->properties;

	mov	esi, DWORD PTR [ebx+44]

; 9087 :     while (attr != NULL) {

	test	esi, esi
	je	$LN158@xmlSchemaP
$LL2@xmlSchemaP:

; 9088 : 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN6@xmlSchemaP

; 9089 : 	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP
	push	OFFSET ??_C@_08DLBHENKN@itemType@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP

; 9090 : 		(!xmlStrEqual(attr->name, BAD_CAST "itemType"))) {
; 9091 : 		xmlSchemaPIllegalAttrErr(ctxt,
; 9092 : 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 9093 : 	    }

	jmp	SHORT $LN167@xmlSchemaP
$LN6@xmlSchemaP:

; 9094 : 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlSchemaP
$LN167@xmlSchemaP:

; 9095 : 	    xmlSchemaPIllegalAttrErr(ctxt,
; 9096 : 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 9097 : 	}
; 9098 : 	attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN9@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaP
	mov	esi, DWORD PTR [ebx+44]

; 4667 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN158@xmlSchemaP
$LL23@xmlSchemaP:

; 4668 :         if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN27@xmlSchemaP
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN22@xmlSchemaP
$LN27@xmlSchemaP:

; 4669 : 	    return(prop);
; 4670 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL23@xmlSchemaP

; 3242 : }
; 3243 : 
; 3244 : /************************************************************************
; 3245 :  *									*
; 3246 :  *			Streamable error functions                      *
; 3247 :  *									*
; 3248 :  ************************************************************************/
; 3249 : 
; 3250 : 
; 3251 : 
; 3252 : 
; 3253 : /************************************************************************
; 3254 :  *									*
; 3255 :  *			Validation helper functions			*
; 3256 :  *									*
; 3257 :  ************************************************************************/
; 3258 : 
; 3259 : 
; 3260 : /************************************************************************
; 3261 :  *									*
; 3262 :  *			Allocation functions				*
; 3263 :  *									*
; 3264 :  ************************************************************************/
; 3265 : 
; 3266 : /**
; 3267 :  * xmlSchemaNewSchemaForParserCtxt:
; 3268 :  * @ctxt:  a schema validation context
; 3269 :  *
; 3270 :  * Allocate a new Schema structure.
; 3271 :  *
; 3272 :  * Returns the newly allocated structure or NULL in case or error
; 3273 :  */
; 3274 : static xmlSchemaPtr
; 3275 : xmlSchemaNewSchema(xmlSchemaParserCtxtPtr ctxt)
; 3276 : {
; 3277 :     xmlSchemaPtr ret;
; 3278 : 
; 3279 :     ret = (xmlSchemaPtr) xmlMalloc(sizeof(xmlSchema));
; 3280 :     if (ret == NULL) {
; 3281 :         xmlSchemaPErrMemory(ctxt, "allocating schema", NULL);
; 3282 :         return (NULL);
; 3283 :     }
; 3284 :     memset(ret, 0, sizeof(xmlSchema));
; 3285 :     ret->dict = ctxt->dict;
; 3286 :     xmlDictReference(ret->dict);
; 3287 : 
; 3288 :     return (ret);
; 3289 : }
; 3290 : 
; 3291 : /**
; 3292 :  * xmlSchemaNewFacet:
; 3293 :  *
; 3294 :  * Allocate a new Facet structure.
; 3295 :  *
; 3296 :  * Returns the newly allocated structure or NULL in case or error
; 3297 :  */
; 3298 : xmlSchemaFacetPtr
; 3299 : xmlSchemaNewFacet(void)
; 3300 : {
; 3301 :     xmlSchemaFacetPtr ret;
; 3302 : 
; 3303 :     ret = (xmlSchemaFacetPtr) xmlMalloc(sizeof(xmlSchemaFacet));
; 3304 :     if (ret == NULL) {
; 3305 :         return (NULL);
; 3306 :     }
; 3307 :     memset(ret, 0, sizeof(xmlSchemaFacet));
; 3308 : 
; 3309 :     return (ret);
; 3310 : }
; 3311 : 
; 3312 : /**
; 3313 :  * xmlSchemaNewAnnot:
; 3314 :  * @ctxt:  a schema validation context
; 3315 :  * @node:  a node
; 3316 :  *
; 3317 :  * Allocate a new annotation structure.
; 3318 :  *
; 3319 :  * Returns the newly allocated structure or NULL in case or error
; 3320 :  */
; 3321 : static xmlSchemaAnnotPtr
; 3322 : xmlSchemaNewAnnot(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node)
; 3323 : {
; 3324 :     xmlSchemaAnnotPtr ret;
; 3325 : 
; 3326 :     ret = (xmlSchemaAnnotPtr) xmlMalloc(sizeof(xmlSchemaAnnot));
; 3327 :     if (ret == NULL) {
; 3328 :         xmlSchemaPErrMemory(ctxt, "allocating annotation", node);
; 3329 :         return (NULL);
; 3330 :     }
; 3331 :     memset(ret, 0, sizeof(xmlSchemaAnnot));
; 3332 :     ret->content = node;
; 3333 :     return (ret);
; 3334 : }
; 3335 : 
; 3336 : static xmlSchemaItemListPtr
; 3337 : xmlSchemaItemListCreate(void)
; 3338 : {
; 3339 :     xmlSchemaItemListPtr ret;
; 3340 : 
; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));
; 3342 :     if (ret == NULL) {
; 3343 : 	xmlSchemaPErrMemory(NULL,
; 3344 : 	    "allocating an item list structure", NULL);
; 3345 : 	return (NULL);
; 3346 :     }
; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));
; 3348 :     return (ret);
; 3349 : }
; 3350 : 
; 3351 : static void
; 3352 : xmlSchemaItemListClear(xmlSchemaItemListPtr list)
; 3353 : {
; 3354 :     if (list->items != NULL) {
; 3355 : 	xmlFree(list->items);
; 3356 : 	list->items = NULL;
; 3357 :     }
; 3358 :     list->nbItems = 0;
; 3359 :     list->sizeItems = 0;
; 3360 : }
; 3361 : 
; 3362 : static int
; 3363 : xmlSchemaItemListAdd(xmlSchemaItemListPtr list, void *item)
; 3364 : {
; 3365 :     if (list->items == NULL) {
; 3366 : 	list->items = (void **) xmlMalloc(
; 3367 : 	    20 * sizeof(void *));
; 3368 : 	if (list->items == NULL) {
; 3369 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3370 : 	    return(-1);
; 3371 : 	}
; 3372 : 	list->sizeItems = 20;
; 3373 :     } else if (list->sizeItems <= list->nbItems) {
; 3374 : 	list->sizeItems *= 2;
; 3375 : 	list->items = (void **) xmlRealloc(list->items,
; 3376 : 	    list->sizeItems * sizeof(void *));
; 3377 : 	if (list->items == NULL) {
; 3378 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3379 : 	    list->sizeItems = 0;
; 3380 : 	    return(-1);
; 3381 : 	}
; 3382 :     }
; 3383 :     list->items[list->nbItems++] = item;
; 3384 :     return(0);
; 3385 : }
; 3386 : 
; 3387 : static int
; 3388 : xmlSchemaItemListAddSize(xmlSchemaItemListPtr list,
; 3389 : 			 int initialSize,
; 3390 : 			 void *item)
; 3391 : {
; 3392 :     if (list->items == NULL) {
; 3393 : 	if (initialSize <= 0)
; 3394 : 	    initialSize = 1;
; 3395 : 	list->items = (void **) xmlMalloc(
; 3396 : 	    initialSize * sizeof(void *));
; 3397 : 	if (list->items == NULL) {
; 3398 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3399 : 	    return(-1);
; 3400 : 	}
; 3401 : 	list->sizeItems = initialSize;
; 3402 :     } else if (list->sizeItems <= list->nbItems) {
; 3403 : 	list->sizeItems *= 2;
; 3404 : 	list->items = (void **) xmlRealloc(list->items,
; 3405 : 	    list->sizeItems * sizeof(void *));
; 3406 : 	if (list->items == NULL) {
; 3407 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3408 : 	    list->sizeItems = 0;
; 3409 : 	    return(-1);
; 3410 : 	}
; 3411 :     }
; 3412 :     list->items[list->nbItems++] = item;
; 3413 :     return(0);
; 3414 : }
; 3415 : 
; 3416 : static int
; 3417 : xmlSchemaItemListInsert(xmlSchemaItemListPtr list, void *item, int idx)
; 3418 : {
; 3419 :     if (list->items == NULL) {
; 3420 : 	list->items = (void **) xmlMalloc(
; 3421 : 	    20 * sizeof(void *));
; 3422 : 	if (list->items == NULL) {
; 3423 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3424 : 	    return(-1);
; 3425 : 	}
; 3426 : 	list->sizeItems = 20;
; 3427 :     } else if (list->sizeItems <= list->nbItems) {
; 3428 : 	list->sizeItems *= 2;
; 3429 : 	list->items = (void **) xmlRealloc(list->items,
; 3430 : 	    list->sizeItems * sizeof(void *));
; 3431 : 	if (list->items == NULL) {
; 3432 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3433 : 	    list->sizeItems = 0;
; 3434 : 	    return(-1);
; 3435 : 	}
; 3436 :     }
; 3437 :     /*
; 3438 :     * Just append if the index is greater/equal than the item count.
; 3439 :     */
; 3440 :     if (idx >= list->nbItems) {
; 3441 : 	list->items[list->nbItems++] = item;
; 3442 :     } else {
; 3443 : 	int i;
; 3444 : 	for (i = list->nbItems; i > idx; i--)
; 3445 : 	    list->items[i] = list->items[i-1];
; 3446 : 	list->items[idx] = item;
; 3447 : 	list->nbItems++;
; 3448 :     }
; 3449 :     return(0);
; 3450 : }
; 3451 : 
; 3452 : #if 0 /* enable if ever needed */
; 3453 : static int
; 3454 : xmlSchemaItemListInsertSize(xmlSchemaItemListPtr list,
; 3455 : 			    int initialSize,
; 3456 : 			    void *item,
; 3457 : 			    int idx)
; 3458 : {
; 3459 :     if (list->items == NULL) {
; 3460 : 	if (initialSize <= 0)
; 3461 : 	    initialSize = 1;
; 3462 : 	list->items = (void **) xmlMalloc(
; 3463 : 	    initialSize * sizeof(void *));
; 3464 : 	if (list->items == NULL) {
; 3465 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3466 : 	    return(-1);
; 3467 : 	}
; 3468 : 	list->sizeItems = initialSize;
; 3469 :     } else if (list->sizeItems <= list->nbItems) {
; 3470 : 	list->sizeItems *= 2;
; 3471 : 	list->items = (void **) xmlRealloc(list->items,
; 3472 : 	    list->sizeItems * sizeof(void *));
; 3473 : 	if (list->items == NULL) {
; 3474 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3475 : 	    list->sizeItems = 0;
; 3476 : 	    return(-1);
; 3477 : 	}
; 3478 :     }
; 3479 :     /*
; 3480 :     * Just append if the index is greater/equal than the item count.
; 3481 :     */
; 3482 :     if (idx >= list->nbItems) {
; 3483 : 	list->items[list->nbItems++] = item;
; 3484 :     } else {
; 3485 : 	int i;
; 3486 : 	for (i = list->nbItems; i > idx; i--)
; 3487 : 	    list->items[i] = list->items[i-1];
; 3488 : 	list->items[idx] = item;
; 3489 : 	list->nbItems++;
; 3490 :     }
; 3491 :     return(0);
; 3492 : }
; 3493 : #endif
; 3494 : 
; 3495 : static int
; 3496 : xmlSchemaItemListRemove(xmlSchemaItemListPtr list, int idx)
; 3497 : {
; 3498 :     int i;
; 3499 :     if ((list->items == NULL) || (idx >= list->nbItems)) {
; 3500 : 	xmlSchemaPSimpleErr("Internal error: xmlSchemaItemListRemove, "
; 3501 : 	    "index error.\n");
; 3502 : 	return(-1);
; 3503 :     }
; 3504 : 
; 3505 :     if (list->nbItems == 1) {
; 3506 : 	/* TODO: Really free the list? */
; 3507 : 	xmlFree(list->items);
; 3508 : 	list->items = NULL;
; 3509 : 	list->nbItems = 0;
; 3510 : 	list->sizeItems = 0;
; 3511 :     } else if (list->nbItems -1 == idx) {
; 3512 : 	list->nbItems--;
; 3513 :     } else {
; 3514 : 	for (i = idx; i < list->nbItems -1; i++)
; 3515 : 	    list->items[i] = list->items[i+1];
; 3516 : 	list->nbItems--;
; 3517 :     }
; 3518 :     return(0);
; 3519 : }
; 3520 : 
; 3521 : /**
; 3522 :  * xmlSchemaItemListFree:
; 3523 :  * @annot:  a schema type structure
; 3524 :  *
; 3525 :  * Deallocate a annotation structure
; 3526 :  */
; 3527 : static void
; 3528 : xmlSchemaItemListFree(xmlSchemaItemListPtr list)
; 3529 : {
; 3530 :     if (list == NULL)
; 3531 : 	return;
; 3532 :     if (list->items != NULL)
; 3533 : 	xmlFree(list->items);
; 3534 :     xmlFree(list);
; 3535 : }
; 3536 : 
; 3537 : static void
; 3538 : xmlSchemaBucketFree(xmlSchemaBucketPtr bucket)
; 3539 : {
; 3540 :     if (bucket == NULL)
; 3541 : 	return;
; 3542 :     if (bucket->globals != NULL) {
; 3543 : 	xmlSchemaComponentListFree(bucket->globals);
; 3544 : 	xmlSchemaItemListFree(bucket->globals);
; 3545 :     }
; 3546 :     if (bucket->locals != NULL) {
; 3547 : 	xmlSchemaComponentListFree(bucket->locals);
; 3548 : 	xmlSchemaItemListFree(bucket->locals);
; 3549 :     }
; 3550 :     if (bucket->relations != NULL) {
; 3551 : 	xmlSchemaSchemaRelationPtr prev, cur = bucket->relations;
; 3552 : 	do {
; 3553 : 	    prev = cur;
; 3554 : 	    cur = cur->next;
; 3555 : 	    xmlFree(prev);
; 3556 : 	} while (cur != NULL);
; 3557 :     }
; 3558 :     if ((! bucket->preserveDoc) && (bucket->doc != NULL)) {
; 3559 : 	xmlFreeDoc(bucket->doc);
; 3560 :     }
; 3561 :     if (bucket->type == XML_SCHEMA_SCHEMA_IMPORT) {
; 3562 : 	if (WXS_IMPBUCKET(bucket)->schema != NULL)
; 3563 : 	    xmlSchemaFree(WXS_IMPBUCKET(bucket)->schema);
; 3564 :     }
; 3565 :     xmlFree(bucket);
; 3566 : }
; 3567 : 
; 3568 : static void
; 3569 : xmlSchemaBucketFreeEntry(void *bucket, const xmlChar *name ATTRIBUTE_UNUSED)
; 3570 : {
; 3571 :     xmlSchemaBucketFree((xmlSchemaBucketPtr) bucket);
; 3572 : }
; 3573 : 
; 3574 : static xmlSchemaBucketPtr
; 3575 : xmlSchemaBucketCreate(xmlSchemaParserCtxtPtr pctxt,
; 3576 : 			 int type, const xmlChar *targetNamespace)
; 3577 : {
; 3578 :     xmlSchemaBucketPtr ret;
; 3579 :     int size;
; 3580 :     xmlSchemaPtr mainSchema;
; 3581 : 
; 3582 :     if (WXS_CONSTRUCTOR(pctxt)->mainSchema == NULL) {
; 3583 : 	PERROR_INT("xmlSchemaBucketCreate",
; 3584 : 	    "no main schema on constructor");
; 3585 : 	return(NULL);
; 3586 :     }
; 3587 :     mainSchema = WXS_CONSTRUCTOR(pctxt)->mainSchema;
; 3588 :     /* Create the schema bucket. */
; 3589 :     if (WXS_IS_BUCKET_INCREDEF(type))
; 3590 : 	size = sizeof(xmlSchemaInclude);
; 3591 :     else
; 3592 : 	size = sizeof(xmlSchemaImport);
; 3593 :     ret = (xmlSchemaBucketPtr) xmlMalloc(size);
; 3594 :     if (ret == NULL) {
; 3595 : 	xmlSchemaPErrMemory(NULL, "allocating schema bucket", NULL);
; 3596 : 	return(NULL);
; 3597 :     }
; 3598 :     memset(ret, 0, size);
; 3599 :     ret->targetNamespace = targetNamespace;
; 3600 :     ret->type = type;
; 3601 :     ret->globals = xmlSchemaItemListCreate();
; 3602 :     if (ret->globals == NULL) {
; 3603 : 	xmlFree(ret);
; 3604 : 	return(NULL);
; 3605 :     }
; 3606 :     ret->locals = xmlSchemaItemListCreate();
; 3607 :     if (ret->locals == NULL) {
; 3608 : 	xmlFree(ret);
; 3609 : 	return(NULL);
; 3610 :     }
; 3611 :     /*
; 3612 :     * The following will assure that only the first bucket is marked as
; 3613 :     * XML_SCHEMA_SCHEMA_MAIN and it points to the *main* schema.
; 3614 :     * For each following import buckets an xmlSchema will be created.
; 3615 :     * An xmlSchema will be created for every distinct targetNamespace.
; 3616 :     * We assign the targetNamespace to the schemata here.
; 3617 :     */
; 3618 :     if (! WXS_HAS_BUCKETS(pctxt)) {
; 3619 : 	if (WXS_IS_BUCKET_INCREDEF(type)) {
; 3620 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3621 : 		"first bucket but it's an include or redefine");
; 3622 : 	    xmlSchemaBucketFree(ret);
; 3623 : 	    return(NULL);
; 3624 : 	}
; 3625 : 	/* Force the type to be XML_SCHEMA_SCHEMA_MAIN. */
; 3626 : 	ret->type = XML_SCHEMA_SCHEMA_MAIN;
; 3627 : 	/* Point to the *main* schema. */
; 3628 : 	WXS_CONSTRUCTOR(pctxt)->mainBucket = ret;
; 3629 : 	WXS_IMPBUCKET(ret)->schema = mainSchema;
; 3630 : 	/*
; 3631 : 	* Ensure that the main schema gets a targetNamespace.
; 3632 : 	*/
; 3633 : 	mainSchema->targetNamespace = targetNamespace;
; 3634 :     } else {
; 3635 : 	if (type == XML_SCHEMA_SCHEMA_MAIN) {
; 3636 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3637 : 		"main bucket but it's not the first one");
; 3638 : 	    xmlSchemaBucketFree(ret);
; 3639 : 	    return(NULL);
; 3640 : 	} else if (type == XML_SCHEMA_SCHEMA_IMPORT) {
; 3641 : 	    /*
; 3642 : 	    * Create a schema for imports and assign the
; 3643 : 	    * targetNamespace.
; 3644 : 	    */
; 3645 : 	    WXS_IMPBUCKET(ret)->schema = xmlSchemaNewSchema(pctxt);
; 3646 : 	    if (WXS_IMPBUCKET(ret)->schema == NULL) {
; 3647 : 		xmlSchemaBucketFree(ret);
; 3648 : 		return(NULL);
; 3649 : 	    }
; 3650 : 	    WXS_IMPBUCKET(ret)->schema->targetNamespace = targetNamespace;
; 3651 : 	}
; 3652 :     }
; 3653 :     if (WXS_IS_BUCKET_IMPMAIN(type)) {
; 3654 : 	int res;
; 3655 : 	/*
; 3656 : 	* Imports go into the "schemasImports" slot of the main *schema*.
; 3657 : 	* Note that we create an import entry for the main schema as well; i.e.,
; 3658 : 	* even if there's only one schema, we'll get an import.
; 3659 : 	*/
; 3660 : 	if (mainSchema->schemasImports == NULL) {
; 3661 : 	    mainSchema->schemasImports = xmlHashCreateDict(5,
; 3662 : 		WXS_CONSTRUCTOR(pctxt)->dict);
; 3663 : 	    if (mainSchema->schemasImports == NULL) {
; 3664 : 		xmlSchemaBucketFree(ret);
; 3665 : 		return(NULL);
; 3666 : 	    }
; 3667 : 	}
; 3668 : 	if (targetNamespace == NULL)
; 3669 : 	    res = xmlHashAddEntry(mainSchema->schemasImports,
; 3670 : 		XML_SCHEMAS_NO_NAMESPACE, ret);
; 3671 : 	else
; 3672 : 	    res = xmlHashAddEntry(mainSchema->schemasImports,
; 3673 : 		targetNamespace, ret);
; 3674 : 	if (res != 0) {
; 3675 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3676 : 		"failed to add the schema bucket to the hash");
; 3677 : 	    xmlSchemaBucketFree(ret);
; 3678 : 	    return(NULL);
; 3679 : 	}
; 3680 :     } else {
; 3681 : 	/* Set the @ownerImport of an include bucket. */
; 3682 : 	if (WXS_IS_BUCKET_IMPMAIN(WXS_CONSTRUCTOR(pctxt)->bucket->type))
; 3683 : 	    WXS_INCBUCKET(ret)->ownerImport =
; 3684 : 		WXS_IMPBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket);
; 3685 : 	else
; 3686 : 	    WXS_INCBUCKET(ret)->ownerImport =
; 3687 : 		WXS_INCBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket)->ownerImport;
; 3688 : 
; 3689 : 	/* Includes got into the "includes" slot of the *main* schema. */
; 3690 : 	if (mainSchema->includes == NULL) {
; 3691 : 	    mainSchema->includes = xmlSchemaItemListCreate();
; 3692 : 	    if (mainSchema->includes == NULL) {
; 3693 : 		xmlSchemaBucketFree(ret);
; 3694 : 		return(NULL);
; 3695 : 	    }
; 3696 : 	}
; 3697 : 	xmlSchemaItemListAdd(mainSchema->includes, ret);
; 3698 :     }
; 3699 :     /*
; 3700 :     * Add to list of all buckets; this is used for lookup
; 3701 :     * during schema construction time only.
; 3702 :     */
; 3703 :     if (xmlSchemaItemListAdd(WXS_CONSTRUCTOR(pctxt)->buckets, ret) == -1)
; 3704 : 	return(NULL);
; 3705 :     return(ret);
; 3706 : }
; 3707 : 
; 3708 : static int
; 3709 : xmlSchemaAddItemSize(xmlSchemaItemListPtr *list, int initialSize, void *item)
; 3710 : {
; 3711 :     if (*list == NULL) {
; 3712 : 	*list = xmlSchemaItemListCreate();
; 3713 : 	if (*list == NULL)
; 3714 : 	    return(-1);
; 3715 :     }
; 3716 :     xmlSchemaItemListAddSize(*list, initialSize, item);
; 3717 :     return(0);
; 3718 : }
; 3719 : 
; 3720 : /**
; 3721 :  * xmlSchemaFreeAnnot:
; 3722 :  * @annot:  a schema type structure
; 3723 :  *
; 3724 :  * Deallocate a annotation structure
; 3725 :  */
; 3726 : static void
; 3727 : xmlSchemaFreeAnnot(xmlSchemaAnnotPtr annot)
; 3728 : {
; 3729 :     if (annot == NULL)
; 3730 :         return;
; 3731 :     if (annot->next == NULL) {
; 3732 : 	xmlFree(annot);
; 3733 :     } else {
; 3734 : 	xmlSchemaAnnotPtr prev;
; 3735 : 
; 3736 : 	do {
; 3737 : 	    prev = annot;
; 3738 : 	    annot = annot->next;
; 3739 : 	    xmlFree(prev);
; 3740 : 	} while (annot != NULL);
; 3741 :     }
; 3742 : }
; 3743 : 
; 3744 : /**
; 3745 :  * xmlSchemaFreeNotation:
; 3746 :  * @schema:  a schema notation structure
; 3747 :  *
; 3748 :  * Deallocate a Schema Notation structure.
; 3749 :  */
; 3750 : static void
; 3751 : xmlSchemaFreeNotation(xmlSchemaNotationPtr nota)
; 3752 : {
; 3753 :     if (nota == NULL)
; 3754 :         return;
; 3755 :     xmlFree(nota);
; 3756 : }
; 3757 : 
; 3758 : /**
; 3759 :  * xmlSchemaFreeAttribute:
; 3760 :  * @attr:  an attribute declaration
; 3761 :  *
; 3762 :  * Deallocates an attribute declaration structure.
; 3763 :  */
; 3764 : static void
; 3765 : xmlSchemaFreeAttribute(xmlSchemaAttributePtr attr)
; 3766 : {
; 3767 :     if (attr == NULL)
; 3768 :         return;
; 3769 :     if (attr->annot != NULL)
; 3770 : 	xmlSchemaFreeAnnot(attr->annot);
; 3771 :     if (attr->defVal != NULL)
; 3772 : 	xmlSchemaFreeValue(attr->defVal);
; 3773 :     xmlFree(attr);
; 3774 : }
; 3775 : 
; 3776 : /**
; 3777 :  * xmlSchemaFreeAttributeUse:
; 3778 :  * @use:  an attribute use
; 3779 :  *
; 3780 :  * Deallocates an attribute use structure.
; 3781 :  */
; 3782 : static void
; 3783 : xmlSchemaFreeAttributeUse(xmlSchemaAttributeUsePtr use)
; 3784 : {
; 3785 :     if (use == NULL)
; 3786 :         return;
; 3787 :     if (use->annot != NULL)
; 3788 : 	xmlSchemaFreeAnnot(use->annot);
; 3789 :     if (use->defVal != NULL)
; 3790 : 	xmlSchemaFreeValue(use->defVal);
; 3791 :     xmlFree(use);
; 3792 : }
; 3793 : 
; 3794 : /**
; 3795 :  * xmlSchemaFreeAttributeUseProhib:
; 3796 :  * @prohib:  an attribute use prohibition
; 3797 :  *
; 3798 :  * Deallocates an attribute use structure.
; 3799 :  */
; 3800 : static void
; 3801 : xmlSchemaFreeAttributeUseProhib(xmlSchemaAttributeUseProhibPtr prohib)
; 3802 : {
; 3803 :     if (prohib == NULL)
; 3804 :         return;
; 3805 :     xmlFree(prohib);
; 3806 : }
; 3807 : 
; 3808 : /**
; 3809 :  * xmlSchemaFreeWildcardNsSet:
; 3810 :  * set:  a schema wildcard namespace
; 3811 :  *
; 3812 :  * Deallocates a list of wildcard constraint structures.
; 3813 :  */
; 3814 : static void
; 3815 : xmlSchemaFreeWildcardNsSet(xmlSchemaWildcardNsPtr set)
; 3816 : {
; 3817 :     xmlSchemaWildcardNsPtr next;
; 3818 : 
; 3819 :     while (set != NULL) {
; 3820 : 	next = set->next;
; 3821 : 	xmlFree(set);
; 3822 : 	set = next;
; 3823 :     }
; 3824 : }
; 3825 : 
; 3826 : /**
; 3827 :  * xmlSchemaFreeWildcard:
; 3828 :  * @wildcard:  a wildcard structure
; 3829 :  *
; 3830 :  * Deallocates a wildcard structure.
; 3831 :  */
; 3832 : void
; 3833 : xmlSchemaFreeWildcard(xmlSchemaWildcardPtr wildcard)
; 3834 : {
; 3835 :     if (wildcard == NULL)
; 3836 :         return;
; 3837 :     if (wildcard->annot != NULL)
; 3838 :         xmlSchemaFreeAnnot(wildcard->annot);
; 3839 :     if (wildcard->nsSet != NULL)
; 3840 : 	xmlSchemaFreeWildcardNsSet(wildcard->nsSet);
; 3841 :     if (wildcard->negNsSet != NULL)
; 3842 : 	xmlFree(wildcard->negNsSet);
; 3843 :     xmlFree(wildcard);
; 3844 : }
; 3845 : 
; 3846 : /**
; 3847 :  * xmlSchemaFreeAttributeGroup:
; 3848 :  * @schema:  a schema attribute group structure
; 3849 :  *
; 3850 :  * Deallocate a Schema Attribute Group structure.
; 3851 :  */
; 3852 : static void
; 3853 : xmlSchemaFreeAttributeGroup(xmlSchemaAttributeGroupPtr attrGr)
; 3854 : {
; 3855 :     if (attrGr == NULL)
; 3856 :         return;
; 3857 :     if (attrGr->annot != NULL)
; 3858 :         xmlSchemaFreeAnnot(attrGr->annot);
; 3859 :     if (attrGr->attrUses != NULL)
; 3860 : 	xmlSchemaItemListFree(WXS_LIST_CAST attrGr->attrUses);
; 3861 :     xmlFree(attrGr);
; 3862 : }
; 3863 : 
; 3864 : /**
; 3865 :  * xmlSchemaFreeQNameRef:
; 3866 :  * @item: a QName reference structure
; 3867 :  *
; 3868 :  * Deallocatea a QName reference structure.
; 3869 :  */
; 3870 : static void
; 3871 : xmlSchemaFreeQNameRef(xmlSchemaQNameRefPtr item)
; 3872 : {
; 3873 :     xmlFree(item);
; 3874 : }
; 3875 : 
; 3876 : /**
; 3877 :  * xmlSchemaFreeTypeLinkList:
; 3878 :  * @alink: a type link
; 3879 :  *
; 3880 :  * Deallocate a list of types.
; 3881 :  */
; 3882 : static void
; 3883 : xmlSchemaFreeTypeLinkList(xmlSchemaTypeLinkPtr link)
; 3884 : {
; 3885 :     xmlSchemaTypeLinkPtr next;
; 3886 : 
; 3887 :     while (link != NULL) {
; 3888 : 	next = link->next;
; 3889 : 	xmlFree(link);
; 3890 : 	link = next;
; 3891 :     }
; 3892 : }
; 3893 : 
; 3894 : static void
; 3895 : xmlSchemaFreeIDCStateObjList(xmlSchemaIDCStateObjPtr sto)
; 3896 : {
; 3897 :     xmlSchemaIDCStateObjPtr next;
; 3898 :     while (sto != NULL) {
; 3899 : 	next = sto->next;
; 3900 : 	if (sto->history != NULL)
; 3901 : 	    xmlFree(sto->history);
; 3902 : 	if (sto->xpathCtxt != NULL)
; 3903 : 	    xmlFreeStreamCtxt((xmlStreamCtxtPtr) sto->xpathCtxt);
; 3904 : 	xmlFree(sto);
; 3905 : 	sto = next;
; 3906 :     }
; 3907 : }
; 3908 : 
; 3909 : /**
; 3910 :  * xmlSchemaFreeIDC:
; 3911 :  * @idc: a identity-constraint definition
; 3912 :  *
; 3913 :  * Deallocates an identity-constraint definition.
; 3914 :  */
; 3915 : static void
; 3916 : xmlSchemaFreeIDC(xmlSchemaIDCPtr idcDef)
; 3917 : {
; 3918 :     xmlSchemaIDCSelectPtr cur, prev;
; 3919 : 
; 3920 :     if (idcDef == NULL)
; 3921 : 	return;
; 3922 :     if (idcDef->annot != NULL)
; 3923 :         xmlSchemaFreeAnnot(idcDef->annot);
; 3924 :     /* Selector */
; 3925 :     if (idcDef->selector != NULL) {
; 3926 : 	if (idcDef->selector->xpathComp != NULL)
; 3927 : 	    xmlFreePattern((xmlPatternPtr) idcDef->selector->xpathComp);
; 3928 : 	xmlFree(idcDef->selector);
; 3929 :     }
; 3930 :     /* Fields */
; 3931 :     if (idcDef->fields != NULL) {
; 3932 : 	cur = idcDef->fields;
; 3933 : 	do {
; 3934 : 	    prev = cur;
; 3935 : 	    cur = cur->next;
; 3936 : 	    if (prev->xpathComp != NULL)
; 3937 : 		xmlFreePattern((xmlPatternPtr) prev->xpathComp);
; 3938 : 	    xmlFree(prev);
; 3939 : 	} while (cur != NULL);
; 3940 :     }
; 3941 :     xmlFree(idcDef);
; 3942 : }
; 3943 : 
; 3944 : /**
; 3945 :  * xmlSchemaFreeElement:
; 3946 :  * @schema:  a schema element structure
; 3947 :  *
; 3948 :  * Deallocate a Schema Element structure.
; 3949 :  */
; 3950 : static void
; 3951 : xmlSchemaFreeElement(xmlSchemaElementPtr elem)
; 3952 : {
; 3953 :     if (elem == NULL)
; 3954 :         return;
; 3955 :     if (elem->annot != NULL)
; 3956 :         xmlSchemaFreeAnnot(elem->annot);
; 3957 :     if (elem->contModel != NULL)
; 3958 :         xmlRegFreeRegexp(elem->contModel);
; 3959 :     if (elem->defVal != NULL)
; 3960 : 	xmlSchemaFreeValue(elem->defVal);
; 3961 :     xmlFree(elem);
; 3962 : }
; 3963 : 
; 3964 : /**
; 3965 :  * xmlSchemaFreeFacet:
; 3966 :  * @facet:  a schema facet structure
; 3967 :  *
; 3968 :  * Deallocate a Schema Facet structure.
; 3969 :  */
; 3970 : void
; 3971 : xmlSchemaFreeFacet(xmlSchemaFacetPtr facet)
; 3972 : {
; 3973 :     if (facet == NULL)
; 3974 :         return;
; 3975 :     if (facet->val != NULL)
; 3976 :         xmlSchemaFreeValue(facet->val);
; 3977 :     if (facet->regexp != NULL)
; 3978 :         xmlRegFreeRegexp(facet->regexp);
; 3979 :     if (facet->annot != NULL)
; 3980 :         xmlSchemaFreeAnnot(facet->annot);
; 3981 :     xmlFree(facet);
; 3982 : }
; 3983 : 
; 3984 : /**
; 3985 :  * xmlSchemaFreeType:
; 3986 :  * @type:  a schema type structure
; 3987 :  *
; 3988 :  * Deallocate a Schema Type structure.
; 3989 :  */
; 3990 : void
; 3991 : xmlSchemaFreeType(xmlSchemaTypePtr type)
; 3992 : {
; 3993 :     if (type == NULL)
; 3994 :         return;
; 3995 :     if (type->annot != NULL)
; 3996 :         xmlSchemaFreeAnnot(type->annot);
; 3997 :     if (type->facets != NULL) {
; 3998 :         xmlSchemaFacetPtr facet, next;
; 3999 : 
; 4000 :         facet = type->facets;
; 4001 :         while (facet != NULL) {
; 4002 :             next = facet->next;
; 4003 :             xmlSchemaFreeFacet(facet);
; 4004 :             facet = next;
; 4005 :         }
; 4006 :     }
; 4007 :     if (type->attrUses != NULL)
; 4008 : 	xmlSchemaItemListFree((xmlSchemaItemListPtr) type->attrUses);
; 4009 :     if (type->memberTypes != NULL)
; 4010 : 	xmlSchemaFreeTypeLinkList(type->memberTypes);
; 4011 :     if (type->facetSet != NULL) {
; 4012 : 	xmlSchemaFacetLinkPtr next, link;
; 4013 : 
; 4014 : 	link = type->facetSet;
; 4015 : 	do {
; 4016 : 	    next = link->next;
; 4017 : 	    xmlFree(link);
; 4018 : 	    link = next;
; 4019 : 	} while (link != NULL);
; 4020 :     }
; 4021 :     if (type->contModel != NULL)
; 4022 :         xmlRegFreeRegexp(type->contModel);
; 4023 :     xmlFree(type);
; 4024 : }
; 4025 : 
; 4026 : /**
; 4027 :  * xmlSchemaFreeModelGroupDef:
; 4028 :  * @item:  a schema model group definition
; 4029 :  *
; 4030 :  * Deallocates a schema model group definition.
; 4031 :  */
; 4032 : static void
; 4033 : xmlSchemaFreeModelGroupDef(xmlSchemaModelGroupDefPtr item)
; 4034 : {
; 4035 :     if (item->annot != NULL)
; 4036 : 	xmlSchemaFreeAnnot(item->annot);
; 4037 :     xmlFree(item);
; 4038 : }
; 4039 : 
; 4040 : /**
; 4041 :  * xmlSchemaFreeModelGroup:
; 4042 :  * @item:  a schema model group
; 4043 :  *
; 4044 :  * Deallocates a schema model group structure.
; 4045 :  */
; 4046 : static void
; 4047 : xmlSchemaFreeModelGroup(xmlSchemaModelGroupPtr item)
; 4048 : {
; 4049 :     if (item->annot != NULL)
; 4050 : 	xmlSchemaFreeAnnot(item->annot);
; 4051 :     xmlFree(item);
; 4052 : }
; 4053 : 
; 4054 : static void
; 4055 : xmlSchemaComponentListFree(xmlSchemaItemListPtr list)
; 4056 : {
; 4057 :     if ((list == NULL) || (list->nbItems == 0))
; 4058 : 	return;
; 4059 :     {
; 4060 : 	xmlSchemaTreeItemPtr item;
; 4061 : 	xmlSchemaTreeItemPtr *items = (xmlSchemaTreeItemPtr *) list->items;
; 4062 : 	int i;
; 4063 : 
; 4064 : 	for (i = 0; i < list->nbItems; i++) {
; 4065 : 	    item = items[i];
; 4066 : 	    if (item == NULL)
; 4067 : 		continue;
; 4068 : 	    switch (item->type) {
; 4069 : 		case XML_SCHEMA_TYPE_SIMPLE:
; 4070 : 		case XML_SCHEMA_TYPE_COMPLEX:
; 4071 : 		    xmlSchemaFreeType((xmlSchemaTypePtr) item);
; 4072 : 		    break;
; 4073 : 		case XML_SCHEMA_TYPE_ATTRIBUTE:
; 4074 : 		    xmlSchemaFreeAttribute((xmlSchemaAttributePtr) item);
; 4075 : 		    break;
; 4076 : 		case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
; 4077 : 		    xmlSchemaFreeAttributeUse((xmlSchemaAttributeUsePtr) item);
; 4078 : 		    break;
; 4079 : 		case XML_SCHEMA_EXTRA_ATTR_USE_PROHIB:
; 4080 : 		    xmlSchemaFreeAttributeUseProhib(
; 4081 : 			(xmlSchemaAttributeUseProhibPtr) item);
; 4082 : 		    break;
; 4083 : 		case XML_SCHEMA_TYPE_ELEMENT:
; 4084 : 		    xmlSchemaFreeElement((xmlSchemaElementPtr) item);
; 4085 : 		    break;
; 4086 : 		case XML_SCHEMA_TYPE_PARTICLE:
; 4087 : 		    if (item->annot != NULL)
; 4088 : 			xmlSchemaFreeAnnot(item->annot);
; 4089 : 		    xmlFree(item);
; 4090 : 		    break;
; 4091 : 		case XML_SCHEMA_TYPE_SEQUENCE:
; 4092 : 		case XML_SCHEMA_TYPE_CHOICE:
; 4093 : 		case XML_SCHEMA_TYPE_ALL:
; 4094 : 		    xmlSchemaFreeModelGroup((xmlSchemaModelGroupPtr) item);
; 4095 : 		    break;
; 4096 : 		case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 4097 : 		    xmlSchemaFreeAttributeGroup(
; 4098 : 			(xmlSchemaAttributeGroupPtr) item);
; 4099 : 		    break;
; 4100 : 		case XML_SCHEMA_TYPE_GROUP:
; 4101 : 		    xmlSchemaFreeModelGroupDef(
; 4102 : 			(xmlSchemaModelGroupDefPtr) item);
; 4103 : 		    break;
; 4104 : 		case XML_SCHEMA_TYPE_ANY:
; 4105 : 		case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:
; 4106 : 		    xmlSchemaFreeWildcard((xmlSchemaWildcardPtr) item);
; 4107 : 		    break;
; 4108 : 		case XML_SCHEMA_TYPE_IDC_KEY:
; 4109 : 		case XML_SCHEMA_TYPE_IDC_UNIQUE:
; 4110 : 		case XML_SCHEMA_TYPE_IDC_KEYREF:
; 4111 : 		    xmlSchemaFreeIDC((xmlSchemaIDCPtr) item);
; 4112 : 		    break;
; 4113 : 		case XML_SCHEMA_TYPE_NOTATION:
; 4114 : 		    xmlSchemaFreeNotation((xmlSchemaNotationPtr) item);
; 4115 : 		    break;
; 4116 : 		case XML_SCHEMA_EXTRA_QNAMEREF:
; 4117 : 		    xmlSchemaFreeQNameRef((xmlSchemaQNameRefPtr) item);
; 4118 : 		    break;
; 4119 : 		default: {
; 4120 : 		    /* TODO: This should never be hit. */
; 4121 : 		    xmlSchemaPSimpleInternalErr(NULL,
; 4122 : 			"Internal error: xmlSchemaComponentListFree, "
; 4123 : 			"unexpected component type '%s'\n",
; 4124 : 			(const xmlChar *) WXS_ITEM_TYPE_NAME(item));
; 4125 : 			 }
; 4126 : 		    break;
; 4127 : 	    }
; 4128 : 	}
; 4129 : 	list->nbItems = 0;
; 4130 :     }
; 4131 : }
; 4132 : 
; 4133 : /**
; 4134 :  * xmlSchemaFree:
; 4135 :  * @schema:  a schema structure
; 4136 :  *
; 4137 :  * Deallocate a Schema structure.
; 4138 :  */
; 4139 : void
; 4140 : xmlSchemaFree(xmlSchemaPtr schema)
; 4141 : {
; 4142 :     if (schema == NULL)
; 4143 :         return;
; 4144 :     /* @volatiles is not used anymore :-/ */
; 4145 :     if (schema->volatiles != NULL)
; 4146 : 	TODO
; 4147 :     /*
; 4148 :     * Note that those slots are not responsible for freeing
; 4149 :     * schema components anymore; this will now be done by
; 4150 :     * the schema buckets.
; 4151 :     */
; 4152 :     if (schema->notaDecl != NULL)
; 4153 :         xmlHashFree(schema->notaDecl, NULL);
; 4154 :     if (schema->attrDecl != NULL)
; 4155 :         xmlHashFree(schema->attrDecl, NULL);
; 4156 :     if (schema->attrgrpDecl != NULL)
; 4157 :         xmlHashFree(schema->attrgrpDecl, NULL);
; 4158 :     if (schema->elemDecl != NULL)
; 4159 :         xmlHashFree(schema->elemDecl, NULL);
; 4160 :     if (schema->typeDecl != NULL)
; 4161 :         xmlHashFree(schema->typeDecl, NULL);
; 4162 :     if (schema->groupDecl != NULL)
; 4163 :         xmlHashFree(schema->groupDecl, NULL);
; 4164 :     if (schema->idcDef != NULL)
; 4165 :         xmlHashFree(schema->idcDef, NULL);
; 4166 : 
; 4167 :     if (schema->schemasImports != NULL)
; 4168 : 	xmlHashFree(schema->schemasImports, xmlSchemaBucketFreeEntry);
; 4169 :     if (schema->includes != NULL) {
; 4170 : 	xmlSchemaItemListPtr list = (xmlSchemaItemListPtr) schema->includes;
; 4171 : 	int i;
; 4172 : 	for (i = 0; i < list->nbItems; i++) {
; 4173 : 	    xmlSchemaBucketFree((xmlSchemaBucketPtr) list->items[i]);
; 4174 : 	}
; 4175 : 	xmlSchemaItemListFree(list);
; 4176 :     }
; 4177 :     if (schema->annot != NULL)
; 4178 :         xmlSchemaFreeAnnot(schema->annot);
; 4179 :     /* Never free the doc here, since this will be done by the buckets. */
; 4180 : 
; 4181 :     xmlDictFree(schema->dict);
; 4182 :     xmlFree(schema);
; 4183 : }
; 4184 : 
; 4185 : /************************************************************************
; 4186 :  *									*
; 4187 :  *			Debug functions					*
; 4188 :  *									*
; 4189 :  ************************************************************************/
; 4190 : 
; 4191 : #ifdef LIBXML_OUTPUT_ENABLED
; 4192 : 
; 4193 : static void
; 4194 : xmlSchemaTypeDump(xmlSchemaTypePtr type, FILE * output); /* forward */
; 4195 : 
; 4196 : /**
; 4197 :  * xmlSchemaElementDump:
; 4198 :  * @elem:  an element
; 4199 :  * @output:  the file output
; 4200 :  *
; 4201 :  * Dump the element
; 4202 :  */
; 4203 : static void
; 4204 : xmlSchemaElementDump(void *payload, void *data,
; 4205 :                      const xmlChar * name ATTRIBUTE_UNUSED,
; 4206 : 		     const xmlChar * namespace ATTRIBUTE_UNUSED,
; 4207 :                      const xmlChar * context ATTRIBUTE_UNUSED)
; 4208 : {
; 4209 :     xmlSchemaElementPtr elem = (xmlSchemaElementPtr) payload;
; 4210 :     FILE *output = (FILE *) data;
; 4211 :     if (elem == NULL)
; 4212 :         return;
; 4213 : 
; 4214 : 
; 4215 :     fprintf(output, "Element");
; 4216 :     if (elem->flags & XML_SCHEMAS_ELEM_GLOBAL)
; 4217 : 	fprintf(output, " (global)");
; 4218 :     fprintf(output, ": '%s' ", elem->name);
; 4219 :     if (namespace != NULL)
; 4220 : 	fprintf(output, "ns '%s'", namespace);
; 4221 :     fprintf(output, "\n");
; 4222 : #if 0
; 4223 :     if ((elem->minOccurs != 1) || (elem->maxOccurs != 1)) {
; 4224 : 	fprintf(output, "  min %d ", elem->minOccurs);
; 4225 :         if (elem->maxOccurs >= UNBOUNDED)
; 4226 :             fprintf(output, "max: unbounded\n");
; 4227 :         else if (elem->maxOccurs != 1)
; 4228 :             fprintf(output, "max: %d\n", elem->maxOccurs);
; 4229 :         else
; 4230 :             fprintf(output, "\n");
; 4231 :     }
; 4232 : #endif
; 4233 :     /*
; 4234 :     * Misc other properties.
; 4235 :     */
; 4236 :     if ((elem->flags & XML_SCHEMAS_ELEM_NILLABLE) ||
; 4237 : 	(elem->flags & XML_SCHEMAS_ELEM_ABSTRACT) ||
; 4238 : 	(elem->flags & XML_SCHEMAS_ELEM_FIXED) ||
; 4239 : 	(elem->flags & XML_SCHEMAS_ELEM_DEFAULT)) {
; 4240 : 	fprintf(output, "  props: ");
; 4241 : 	if (elem->flags & XML_SCHEMAS_ELEM_FIXED)
; 4242 : 	    fprintf(output, "[fixed] ");
; 4243 : 	if (elem->flags & XML_SCHEMAS_ELEM_DEFAULT)
; 4244 : 	    fprintf(output, "[default] ");
; 4245 : 	if (elem->flags & XML_SCHEMAS_ELEM_ABSTRACT)
; 4246 : 	    fprintf(output, "[abstract] ");
; 4247 : 	if (elem->flags & XML_SCHEMAS_ELEM_NILLABLE)
; 4248 : 	    fprintf(output, "[nillable] ");
; 4249 : 	fprintf(output, "\n");
; 4250 :     }
; 4251 :     /*
; 4252 :     * Default/fixed value.
; 4253 :     */
; 4254 :     if (elem->value != NULL)
; 4255 : 	fprintf(output, "  value: '%s'\n", elem->value);
; 4256 :     /*
; 4257 :     * Type.
; 4258 :     */
; 4259 :     if (elem->namedType != NULL) {
; 4260 : 	fprintf(output, "  type: '%s' ", elem->namedType);
; 4261 : 	if (elem->namedTypeNs != NULL)
; 4262 : 	    fprintf(output, "ns '%s'\n", elem->namedTypeNs);
; 4263 : 	else
; 4264 : 	    fprintf(output, "\n");
; 4265 :     } else if (elem->subtypes != NULL) {
; 4266 : 	/*
; 4267 : 	* Dump local types.
; 4268 : 	*/
; 4269 : 	xmlSchemaTypeDump(elem->subtypes, output);
; 4270 :     }
; 4271 :     /*
; 4272 :     * Substitution group.
; 4273 :     */
; 4274 :     if (elem->substGroup != NULL) {
; 4275 : 	fprintf(output, "  substitutionGroup: '%s' ", elem->substGroup);
; 4276 : 	if (elem->substGroupNs != NULL)
; 4277 : 	    fprintf(output, "ns '%s'\n", elem->substGroupNs);
; 4278 : 	else
; 4279 : 	    fprintf(output, "\n");
; 4280 :     }
; 4281 : }
; 4282 : 
; 4283 : /**
; 4284 :  * xmlSchemaAnnotDump:
; 4285 :  * @output:  the file output
; 4286 :  * @annot:  a annotation
; 4287 :  *
; 4288 :  * Dump the annotation
; 4289 :  */
; 4290 : static void
; 4291 : xmlSchemaAnnotDump(FILE * output, xmlSchemaAnnotPtr annot)
; 4292 : {
; 4293 :     xmlChar *content;
; 4294 : 
; 4295 :     if (annot == NULL)
; 4296 :         return;
; 4297 : 
; 4298 :     content = xmlNodeGetContent(annot->content);
; 4299 :     if (content != NULL) {
; 4300 :         fprintf(output, "  Annot: %s\n", content);
; 4301 :         xmlFree(content);
; 4302 :     } else
; 4303 :         fprintf(output, "  Annot: empty\n");
; 4304 : }
; 4305 : 
; 4306 : /**
; 4307 :  * xmlSchemaContentModelDump:
; 4308 :  * @particle: the schema particle
; 4309 :  * @output: the file output
; 4310 :  * @depth: the depth used for intentation
; 4311 :  *
; 4312 :  * Dump a SchemaType structure
; 4313 :  */
; 4314 : static void
; 4315 : xmlSchemaContentModelDump(xmlSchemaParticlePtr particle, FILE * output, int depth)
; 4316 : {
; 4317 :     xmlChar *str = NULL;
; 4318 :     xmlSchemaTreeItemPtr term;
; 4319 :     char shift[100];
; 4320 :     int i;
; 4321 : 
; 4322 :     if (particle == NULL)
; 4323 : 	return;
; 4324 :     for (i = 0;((i < depth) && (i < 25));i++)
; 4325 :         shift[2 * i] = shift[2 * i + 1] = ' ';
; 4326 :     shift[2 * i] = shift[2 * i + 1] = 0;
; 4327 :     fprintf(output, "%s", shift);
; 4328 :     if (particle->children == NULL) {
; 4329 : 	fprintf(output, "MISSING particle term\n");
; 4330 : 	return;
; 4331 :     }
; 4332 :     term = particle->children;
; 4333 :     if (term == NULL) {
; 4334 : 	fprintf(output, "(NULL)");
; 4335 :     } else {
; 4336 : 	switch (term->type) {
; 4337 : 	    case XML_SCHEMA_TYPE_ELEMENT:
; 4338 : 		fprintf(output, "ELEM '%s'", xmlSchemaFormatQName(&str,
; 4339 : 		    ((xmlSchemaElementPtr)term)->targetNamespace,
; 4340 : 		    ((xmlSchemaElementPtr)term)->name));
; 4341 : 		FREE_AND_NULL(str);
; 4342 : 		break;
; 4343 : 	    case XML_SCHEMA_TYPE_SEQUENCE:
; 4344 : 		fprintf(output, "SEQUENCE");
; 4345 : 		break;
; 4346 : 	    case XML_SCHEMA_TYPE_CHOICE:
; 4347 : 		fprintf(output, "CHOICE");
; 4348 : 		break;
; 4349 : 	    case XML_SCHEMA_TYPE_ALL:
; 4350 : 		fprintf(output, "ALL");
; 4351 : 		break;
; 4352 : 	    case XML_SCHEMA_TYPE_ANY:
; 4353 : 		fprintf(output, "ANY");
; 4354 : 		break;
; 4355 : 	    default:
; 4356 : 		fprintf(output, "UNKNOWN\n");
; 4357 : 		return;
; 4358 : 	}
; 4359 :     }
; 4360 :     if (particle->minOccurs != 1)
; 4361 : 	fprintf(output, " min: %d", particle->minOccurs);
; 4362 :     if (particle->maxOccurs >= UNBOUNDED)
; 4363 : 	fprintf(output, " max: unbounded");
; 4364 :     else if (particle->maxOccurs != 1)
; 4365 : 	fprintf(output, " max: %d", particle->maxOccurs);
; 4366 :     fprintf(output, "\n");
; 4367 :     if (term &&
; 4368 : 	((term->type == XML_SCHEMA_TYPE_SEQUENCE) ||
; 4369 : 	 (term->type == XML_SCHEMA_TYPE_CHOICE) ||
; 4370 : 	 (term->type == XML_SCHEMA_TYPE_ALL)) &&
; 4371 : 	 (term->children != NULL)) {
; 4372 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) term->children,
; 4373 : 	    output, depth +1);
; 4374 :     }
; 4375 :     if (particle->next != NULL)
; 4376 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) particle->next,
; 4377 : 		output, depth);
; 4378 : }
; 4379 : 
; 4380 : /**
; 4381 :  * xmlSchemaAttrUsesDump:
; 4382 :  * @uses:  attribute uses list
; 4383 :  * @output:  the file output
; 4384 :  *
; 4385 :  * Dumps a list of attribute use components.
; 4386 :  */
; 4387 : static void
; 4388 : xmlSchemaAttrUsesDump(xmlSchemaItemListPtr uses, FILE * output)
; 4389 : {
; 4390 :     xmlSchemaAttributeUsePtr use;
; 4391 :     xmlSchemaAttributeUseProhibPtr prohib;
; 4392 :     xmlSchemaQNameRefPtr ref;
; 4393 :     const xmlChar *name, *tns;
; 4394 :     xmlChar *str = NULL;
; 4395 :     int i;
; 4396 : 
; 4397 :     if ((uses == NULL) || (uses->nbItems == 0))
; 4398 :         return;
; 4399 : 
; 4400 :     fprintf(output, "  attributes:\n");
; 4401 :     for (i = 0; i < uses->nbItems; i++) {
; 4402 : 	use = uses->items[i];
; 4403 : 	if (use->type == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB) {
; 4404 : 	    fprintf(output, "  [prohibition] ");
; 4405 : 	    prohib = (xmlSchemaAttributeUseProhibPtr) use;
; 4406 : 	    name = prohib->name;
; 4407 : 	    tns = prohib->targetNamespace;
; 4408 : 	} else if (use->type == XML_SCHEMA_EXTRA_QNAMEREF) {
; 4409 : 	    fprintf(output, "  [reference] ");
; 4410 : 	    ref = (xmlSchemaQNameRefPtr) use;
; 4411 : 	    name = ref->name;
; 4412 : 	    tns = ref->targetNamespace;
; 4413 : 	} else {
; 4414 : 	    fprintf(output, "  [use] ");
; 4415 : 	    name = WXS_ATTRUSE_DECL_NAME(use);
; 4416 : 	    tns = WXS_ATTRUSE_DECL_TNS(use);
; 4417 : 	}
; 4418 : 	fprintf(output, "'%s'\n",
; 4419 : 	    (const char *) xmlSchemaFormatQName(&str, tns, name));
; 4420 : 	FREE_AND_NULL(str);
; 4421 :     }
; 4422 : }
; 4423 : 
; 4424 : /**
; 4425 :  * xmlSchemaTypeDump:
; 4426 :  * @output:  the file output
; 4427 :  * @type:  a type structure
; 4428 :  *
; 4429 :  * Dump a SchemaType structure
; 4430 :  */
; 4431 : static void
; 4432 : xmlSchemaTypeDump(xmlSchemaTypePtr type, FILE * output)
; 4433 : {
; 4434 :     if (type == NULL) {
; 4435 :         fprintf(output, "Type: NULL\n");
; 4436 :         return;
; 4437 :     }
; 4438 :     fprintf(output, "Type: ");
; 4439 :     if (type->name != NULL)
; 4440 :         fprintf(output, "'%s' ", type->name);
; 4441 :     else
; 4442 :         fprintf(output, "(no name) ");
; 4443 :     if (type->targetNamespace != NULL)
; 4444 : 	fprintf(output, "ns '%s' ", type->targetNamespace);
; 4445 :     switch (type->type) {
; 4446 :         case XML_SCHEMA_TYPE_BASIC:
; 4447 :             fprintf(output, "[basic] ");
; 4448 :             break;
; 4449 :         case XML_SCHEMA_TYPE_SIMPLE:
; 4450 :             fprintf(output, "[simple] ");
; 4451 :             break;
; 4452 :         case XML_SCHEMA_TYPE_COMPLEX:
; 4453 :             fprintf(output, "[complex] ");
; 4454 :             break;
; 4455 :         case XML_SCHEMA_TYPE_SEQUENCE:
; 4456 :             fprintf(output, "[sequence] ");
; 4457 :             break;
; 4458 :         case XML_SCHEMA_TYPE_CHOICE:
; 4459 :             fprintf(output, "[choice] ");
; 4460 :             break;
; 4461 :         case XML_SCHEMA_TYPE_ALL:
; 4462 :             fprintf(output, "[all] ");
; 4463 :             break;
; 4464 :         case XML_SCHEMA_TYPE_UR:
; 4465 :             fprintf(output, "[ur] ");
; 4466 :             break;
; 4467 :         case XML_SCHEMA_TYPE_RESTRICTION:
; 4468 :             fprintf(output, "[restriction] ");
; 4469 :             break;
; 4470 :         case XML_SCHEMA_TYPE_EXTENSION:
; 4471 :             fprintf(output, "[extension] ");
; 4472 :             break;
; 4473 :         default:
; 4474 :             fprintf(output, "[unknown type %d] ", type->type);
; 4475 :             break;
; 4476 :     }
; 4477 :     fprintf(output, "content: ");
; 4478 :     switch (type->contentType) {
; 4479 :         case XML_SCHEMA_CONTENT_UNKNOWN:
; 4480 :             fprintf(output, "[unknown] ");
; 4481 :             break;
; 4482 :         case XML_SCHEMA_CONTENT_EMPTY:
; 4483 :             fprintf(output, "[empty] ");
; 4484 :             break;
; 4485 :         case XML_SCHEMA_CONTENT_ELEMENTS:
; 4486 :             fprintf(output, "[element] ");
; 4487 :             break;
; 4488 :         case XML_SCHEMA_CONTENT_MIXED:
; 4489 :             fprintf(output, "[mixed] ");
; 4490 :             break;
; 4491 :         case XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS:
; 4492 : 	/* not used. */
; 4493 :             break;
; 4494 :         case XML_SCHEMA_CONTENT_BASIC:
; 4495 :             fprintf(output, "[basic] ");
; 4496 :             break;
; 4497 :         case XML_SCHEMA_CONTENT_SIMPLE:
; 4498 :             fprintf(output, "[simple] ");
; 4499 :             break;
; 4500 :         case XML_SCHEMA_CONTENT_ANY:
; 4501 :             fprintf(output, "[any] ");
; 4502 :             break;
; 4503 :     }
; 4504 :     fprintf(output, "\n");
; 4505 :     if (type->base != NULL) {
; 4506 :         fprintf(output, "  base type: '%s'", type->base);
; 4507 : 	if (type->baseNs != NULL)
; 4508 : 	    fprintf(output, " ns '%s'\n", type->baseNs);
; 4509 : 	else
; 4510 : 	    fprintf(output, "\n");
; 4511 :     }
; 4512 :     if (type->attrUses != NULL)
; 4513 : 	xmlSchemaAttrUsesDump(type->attrUses, output);
; 4514 :     if (type->annot != NULL)
; 4515 :         xmlSchemaAnnotDump(output, type->annot);
; 4516 : #ifdef DUMP_CONTENT_MODEL
; 4517 :     if ((type->type == XML_SCHEMA_TYPE_COMPLEX) &&
; 4518 : 	(type->subtypes != NULL)) {
; 4519 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) type->subtypes,
; 4520 : 	    output, 1);
; 4521 :     }
; 4522 : #endif
; 4523 : }
; 4524 : 
; 4525 : static void
; 4526 : xmlSchemaTypeDumpEntry(void *type, void *output,
; 4527 :                        const xmlChar *name ATTRIBUTE_UNUSED)
; 4528 : {
; 4529 :     xmlSchemaTypeDump((xmlSchemaTypePtr) type, (FILE *) output);
; 4530 : }
; 4531 : 
; 4532 : /**
; 4533 :  * xmlSchemaDump:
; 4534 :  * @output:  the file output
; 4535 :  * @schema:  a schema structure
; 4536 :  *
; 4537 :  * Dump a Schema structure.
; 4538 :  */
; 4539 : void
; 4540 : xmlSchemaDump(FILE * output, xmlSchemaPtr schema)
; 4541 : {
; 4542 :     if (output == NULL)
; 4543 :         return;
; 4544 :     if (schema == NULL) {
; 4545 :         fprintf(output, "Schemas: NULL\n");
; 4546 :         return;
; 4547 :     }
; 4548 :     fprintf(output, "Schemas: ");
; 4549 :     if (schema->name != NULL)
; 4550 :         fprintf(output, "%s, ", schema->name);
; 4551 :     else
; 4552 :         fprintf(output, "no name, ");
; 4553 :     if (schema->targetNamespace != NULL)
; 4554 :         fprintf(output, "%s", (const char *) schema->targetNamespace);
; 4555 :     else
; 4556 :         fprintf(output, "no target namespace");
; 4557 :     fprintf(output, "\n");
; 4558 :     if (schema->annot != NULL)
; 4559 :         xmlSchemaAnnotDump(output, schema->annot);
; 4560 :     xmlHashScan(schema->typeDecl, xmlSchemaTypeDumpEntry, output);
; 4561 :     xmlHashScanFull(schema->elemDecl, xmlSchemaElementDump, output);
; 4562 : }
; 4563 : 
; 4564 : #ifdef DEBUG_IDC_NODE_TABLE
; 4565 : /**
; 4566 :  * xmlSchemaDebugDumpIDCTable:
; 4567 :  * @vctxt: the WXS validation context
; 4568 :  *
; 4569 :  * Displays the current IDC table for debug purposes.
; 4570 :  */
; 4571 : static void
; 4572 : xmlSchemaDebugDumpIDCTable(FILE * output,
; 4573 : 			   const xmlChar *namespaceName,
; 4574 : 			   const xmlChar *localName,
; 4575 : 			   xmlSchemaPSVIIDCBindingPtr bind)
; 4576 : {
; 4577 :     xmlChar *str = NULL;
; 4578 :     const xmlChar *value;
; 4579 :     xmlSchemaPSVIIDCNodePtr tab;
; 4580 :     xmlSchemaPSVIIDCKeyPtr key;
; 4581 :     int i, j, res;
; 4582 : 
; 4583 :     fprintf(output, "IDC: TABLES on '%s'\n",
; 4584 : 	xmlSchemaFormatQName(&str, namespaceName, localName));
; 4585 :     FREE_AND_NULL(str)
; 4586 : 
; 4587 :     if (bind == NULL)
; 4588 : 	return;
; 4589 :     do {
; 4590 : 	fprintf(output, "IDC:   BINDING '%s' (%d)\n",
; 4591 : 	    xmlSchemaGetComponentQName(&str,
; 4592 : 		bind->definition), bind->nbNodes);
; 4593 : 	FREE_AND_NULL(str)
; 4594 : 	for (i = 0; i < bind->nbNodes; i++) {
; 4595 : 	    tab = bind->nodeTable[i];
; 4596 : 	    fprintf(output, "         ( ");
; 4597 : 	    for (j = 0; j < bind->definition->nbFields; j++) {
; 4598 : 		key = tab->keys[j];
; 4599 : 		if ((key != NULL) && (key->val != NULL)) {
; 4600 : 		    res = xmlSchemaGetCanonValue(key->val, &value);
; 4601 : 		    if (res >= 0)
; 4602 : 			fprintf(output, "'%s' ", value);
; 4603 : 		    else
; 4604 : 			fprintf(output, "CANON-VALUE-FAILED ");
; 4605 : 		    if (res == 0)
; 4606 : 			FREE_AND_NULL(value)
; 4607 : 		} else if (key != NULL)
; 4608 : 		    fprintf(output, "(no val), ");
; 4609 : 		else
; 4610 : 		    fprintf(output, "(key missing), ");
; 4611 : 	    }
; 4612 : 	    fprintf(output, ")\n");
; 4613 : 	}
; 4614 : 	if (bind->dupls && bind->dupls->nbItems) {
; 4615 : 	    fprintf(output, "IDC:     dupls (%d):\n", bind->dupls->nbItems);
; 4616 : 	    for (i = 0; i < bind->dupls->nbItems; i++) {
; 4617 : 		tab = bind->dupls->items[i];
; 4618 : 		fprintf(output, "         ( ");
; 4619 : 		for (j = 0; j < bind->definition->nbFields; j++) {
; 4620 : 		    key = tab->keys[j];
; 4621 : 		    if ((key != NULL) && (key->val != NULL)) {
; 4622 : 			res = xmlSchemaGetCanonValue(key->val, &value);
; 4623 : 			if (res >= 0)
; 4624 : 			    fprintf(output, "'%s' ", value);
; 4625 : 			else
; 4626 : 			    fprintf(output, "CANON-VALUE-FAILED ");
; 4627 : 			if (res == 0)
; 4628 : 			    FREE_AND_NULL(value)
; 4629 : 		    } else if (key != NULL)
; 4630 : 		    fprintf(output, "(no val), ");
; 4631 : 			else
; 4632 : 			    fprintf(output, "(key missing), ");
; 4633 : 		}
; 4634 : 		fprintf(output, ")\n");
; 4635 : 	    }
; 4636 : 	}
; 4637 : 	bind = bind->next;
; 4638 :     } while (bind != NULL);
; 4639 : }
; 4640 : #endif /* DEBUG_IDC */
; 4641 : #endif /* LIBXML_OUTPUT_ENABLED */
; 4642 : 
; 4643 : /************************************************************************
; 4644 :  *									*
; 4645 :  *			Utilities					*
; 4646 :  *									*
; 4647 :  ************************************************************************/
; 4648 : 
; 4649 : /**
; 4650 :  * xmlSchemaGetPropNode:
; 4651 :  * @node: the element node
; 4652 :  * @name: the name of the attribute
; 4653 :  *
; 4654 :  * Seeks an attribute with a name of @name in
; 4655 :  * no namespace.
; 4656 :  *
; 4657 :  * Returns the attribute or NULL if not present.
; 4658 :  */
; 4659 : static xmlAttrPtr
; 4660 : xmlSchemaGetPropNode(xmlNodePtr node, const char *name)
; 4661 : {
; 4662 :     xmlAttrPtr prop;
; 4663 : 
; 4664 :     if ((node == NULL) || (name == NULL))
; 4665 : 	return(NULL);
; 4666 :     prop = node->properties;
; 4667 :     while (prop != NULL) {

	jmp	SHORT $LN158@xmlSchemaP
$LN22@xmlSchemaP:

; 6041 :     return(xmlSchemaPValAttrNodeID(ctxt, attr));

	push	esi
	push	edi
	call	_xmlSchemaPValAttrNodeID
	add	esp, 8
$LN158@xmlSchemaP:

; 9099 :     }
; 9100 : 
; 9101 :     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
; 9102 : 
; 9103 :     /*
; 9104 :     * Attribute "itemType". NOTE that we will use the "ref" and "refNs"
; 9105 :     * fields for holding the reference to the itemType.
; 9106 :     *
; 9107 :     * REVAMP TODO: Use the "base" and "baseNs" fields, since we will remove
; 9108 :     * the "ref" fields.
; 9109 :     */
; 9110 :     xmlSchemaPValAttrQName(ctxt, schema, NULL,

	mov	ecx, DWORD PTR _type$1$[ebp]
	lea	eax, DWORD PTR [ecx+56]
	push	eax
	lea	eax, DWORD PTR [ecx+60]
	push	eax
	push	OFFSET ??_C@_08DLBHENKN@itemType@
	push	ebx
	push	0
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaPValAttrQName

; 9111 : 	node, "itemType", &(type->baseNs), &(type->base));
; 9112 :     /*
; 9113 :     * And now for the children...
; 9114 :     */
; 9115 :     child = node->children;

	mov	esi, DWORD PTR [ebx+12]
	add	esp, 28					; 0000001cH

; 9116 :     if (IS_SCHEMA(child, "annotation")) {

	test	esi, esi
	je	$LN11@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN10@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlSchemaP

; 9117 : 	xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,

	push	1
	push	esi
	push	edi
	call	_xmlSchemaParseAnnotation
	mov	ecx, DWORD PTR _type$1$[ebp]
	push	eax
	push	ecx
	call	_xmlSchemaAddAnnotation

; 9118 : 	    xmlSchemaParseAnnotation(ctxt, child, 1));
; 9119 :         child = child->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 20					; 00000014H
$LN10@xmlSchemaP:

; 9120 :     }
; 9121 :     if (IS_SCHEMA(child, "simpleType")) {

	test	esi, esi
	je	SHORT $LN11@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN11@xmlSchemaP
	push	OFFSET ??_C@_0L@FMMGGLOP@simpleType@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlSchemaP

; 9122 : 	/*
; 9123 : 	* src-list-itemType-or-simpleType
; 9124 : 	* Either the itemType [attribute] or the <simpleType> [child] of
; 9125 : 	* the <list> element must be present, but not both.
; 9126 : 	*/
; 9127 : 	if (type->base != NULL) {

	mov	eax, DWORD PTR _type$1$[ebp]
	push	0
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN13@xmlSchemaP

; 9128 : 	    xmlSchemaPCustomErr(ctxt,

	push	OFFSET ??_C@_0EL@LEHAHIHI@The?5attribute?5?8itemType?8?5and?5th@
	push	ebx
	push	0
	push	3000					; 00000bb8H
	push	edi
	call	_xmlSchemaPCustomErr

; 9135 : 	}
; 9136 :         child = child->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 24					; 00000018H
	jmp	SHORT $LN122@xmlSchemaP
$LN13@xmlSchemaP:

; 9129 : 		XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
; 9130 : 		NULL, node,
; 9131 : 		"The attribute 'itemType' and the <simpleType> child "
; 9132 : 		"are mutually exclusive", NULL);
; 9133 : 	} else {
; 9134 : 	    type->subtypes = xmlSchemaParseSimpleType(ctxt, schema, child, 0);

	push	esi
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaParseSimpleType
	mov	ecx, DWORD PTR _type$1$[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx+28], eax

; 9135 : 	}
; 9136 :         child = child->next;

	mov	esi, DWORD PTR [esi+24]
	jmp	SHORT $LN122@xmlSchemaP
$LN11@xmlSchemaP:

; 9137 :     } else if (type->base == NULL) {

	mov	eax, DWORD PTR _type$1$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN122@xmlSchemaP

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0EK@BDPJPAFM@Either?5the?5attribute?5?8itemType?8@
	push	ebx
	push	0
	push	3000					; 00000bb8H
	push	edi
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H
$LN122@xmlSchemaP:

; 9138 : 	xmlSchemaPCustomErr(ctxt,
; 9139 : 	    XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
; 9140 : 	    NULL, node,
; 9141 : 	    "Either the attribute 'itemType' or the <simpleType> child "
; 9142 : 	    "must be present", NULL);
; 9143 :     }
; 9144 :     if (child != NULL) {

	test	esi, esi
	je	SHORT $LN129@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	0
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0BL@LABGHPL@?$CIannotation?$DP?0?5simpleType?$DP?$CJ@
	push	DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	edi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN129@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN129@xmlSchemaP:

; 9145 : 	xmlSchemaPContentErr(ctxt,
; 9146 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 9147 : 	    NULL, node, child, NULL, "(annotation?, simpleType?)");
; 9148 :     }
; 9149 :     if ((type->base == NULL) &&
; 9150 : 	(type->subtypes == NULL) &&

	mov	eax, DWORD PTR _type$1$[ebp]
	pop	esi
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN164@xmlSchemaP
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN164@xmlSchemaP
	push	OFFSET ??_C@_08DLBHENKN@itemType@
	push	ebx
	call	_xmlSchemaGetPropNode
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN164@xmlSchemaP

; 9151 : 	(xmlSchemaGetPropNode(node, "itemType") == NULL)) {
; 9152 : 	xmlSchemaPCustomErr(ctxt,

	push	eax
	push	OFFSET ??_C@_0EK@BDPJPAFM@Either?5the?5attribute?5?8itemType?8@
	push	ebx
	push	eax
	push	3000					; 00000bb8H
	push	edi
	call	_xmlSchemaPCustomErr
	add	esp, 24					; 00000018H
$LN164@xmlSchemaP:

; 9071 :         return (NULL);

	pop	ebx
	xor	eax, eax
	pop	edi

; 9153 : 	    XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
; 9154 : 	    NULL, node,
; 9155 : 	    "Either the attribute 'itemType' or the <simpleType> child "
; 9156 : 	    "must be present", NULL);
; 9157 :     }
; 9158 :     return (NULL);
; 9159 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN160@xmlSchemaP:
	xor	eax, eax
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseLocalAttribute
_TEXT	SEGMENT
_hasForm$1$ = -44					; size = 4
_name$ = -40						; size = 4
_tmpName$ = -36						; size = 4
_tmpNs$ = -32						; size = 4
_isRef$1$ = -28						; size = 4
_ns$1$ = -24						; size = 4
_defValue$1$ = -20					; size = 4
_tmpNs$1$ = -16						; size = 4
_use$2$ = -12						; size = 4
_defValueType$1$ = -8					; size = 4
_occurs$1$ = -4						; size = 4
_des$1 = 8						; size = 4
_des$2 = 8						; size = 4
_des$3 = 8						; size = 4
_des$4 = 8						; size = 4
_des$5 = 8						; size = 4
_nberrors$1$ = 8					; size = 4
_attr$3$ = 8						; size = 4
_str$6 = 8						; size = 4
_pctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_uses$ = 20						; size = 4
_parentType$ = 24					; size = 4
_xmlSchemaParseLocalAttribute PROC			; COMDAT

; 7147 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _pctxt$[ebp]
	xor	eax, eax
	xor	ecx, ecx
	mov	DWORD PTR _name$[ebp], 0
	xor	ebx, ebx
	mov	DWORD PTR _ns$1$[ebp], 0
	mov	DWORD PTR _use$2$[ebp], ecx
	mov	DWORD PTR _tmpNs$1$[ebp], eax
	mov	DWORD PTR _tmpNs$[ebp], eax
	mov	DWORD PTR _tmpName$[ebp], ebx
	mov	DWORD PTR _defValue$1$[ebp], eax
	mov	DWORD PTR _isRef$1$[ebp], eax
	mov	DWORD PTR _occurs$1$[ebp], 2
	mov	DWORD PTR _hasForm$1$[ebp], eax
	mov	DWORD PTR _defValueType$1$[ebp], eax
	test	esi, esi
	je	$LN8@xmlSchemaP

; 7148 :     const xmlChar *attrValue, *name = NULL, *ns = NULL;
; 7149 :     xmlSchemaAttributeUsePtr use = NULL;
; 7150 :     xmlNodePtr child = NULL;
; 7151 :     xmlAttrPtr attr;
; 7152 :     const xmlChar *tmpNs = NULL, *tmpName = NULL, *defValue = NULL;
; 7153 :     int isRef = 0, occurs = XML_SCHEMAS_ATTR_USE_OPTIONAL;
; 7154 :     int	nberrors, hasForm = 0, defValueType = 0;
; 7155 : 
; 7156 : #define WXS_ATTR_DEF_VAL_DEFAULT 1
; 7157 : #define WXS_ATTR_DEF_VAL_FIXED 2
; 7158 : 
; 7159 :     /*
; 7160 :      * 3.2.3 Constraints on XML Representations of Attribute Declarations
; 7161 :      */
; 7162 : 
; 7163 :     if ((pctxt == NULL) || (schema == NULL) || (node == NULL))

	cmp	DWORD PTR _schema$[ebp], eax
	je	$LN8@xmlSchemaP
	mov	eax, DWORD PTR _node$[ebp]
	test	eax, eax
	je	$LN8@xmlSchemaP

; 7164 :         return (NULL);
; 7165 :     attr = xmlSchemaGetPropNode(node, "ref");

	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	eax
	call	_xmlSchemaGetPropNode
	mov	edi, eax
	add	esp, 8

; 7166 :     if (attr != NULL) {

	test	edi, edi
	je	SHORT $LN337@xmlSchemaP

; 7167 : 	if (xmlSchemaPValAttrNodeQName(pctxt, schema,
; 7168 : 	    NULL, attr, &tmpNs, &tmpName) != 0) {

	lea	eax, DWORD PTR _tmpName$[ebp]
	push	eax
	lea	eax, DWORD PTR _tmpNs$[ebp]
	push	eax
	push	edi
	push	ebx
	mov	ebx, DWORD PTR _schema$[ebp]
	push	ebx
	push	esi
	call	_xmlSchemaPValAttrNodeQName
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	$LN8@xmlSchemaP

; 7169 : 	    return (NULL);
; 7170 : 	}
; 7171 : 	if (xmlSchemaCheckReference(pctxt, schema, node, attr, tmpNs) != 0)

	mov	eax, DWORD PTR _tmpNs$[ebp]
	push	eax
	push	edi
	push	DWORD PTR _node$[ebp]
	mov	DWORD PTR _tmpNs$1$[ebp], eax
	push	ebx
	push	esi
	call	_xmlSchemaCheckReference
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$LN8@xmlSchemaP

; 7172 : 	    return(NULL);
; 7173 : 	isRef = 1;

	mov	ebx, DWORD PTR _tmpName$[ebp]
	mov	edx, 1
	mov	DWORD PTR _isRef$1$[ebp], edx
	jmp	SHORT $LN9@xmlSchemaP
$LN337@xmlSchemaP:

; 7166 :     if (attr != NULL) {

	xor	edx, edx
$LN9@xmlSchemaP:

; 7174 :     }
; 7175 :     nberrors = pctxt->nberrors;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR _nberrors$1$[ebp], eax

; 7176 :     /*
; 7177 :     * Check for illegal attributes.
; 7178 :     */
; 7179 :     attr = node->properties;

	mov	eax, DWORD PTR _node$[ebp]
	mov	edi, DWORD PTR [eax+44]

; 7180 :     while (attr != NULL) {

	test	edi, edi
	je	$LN320@xmlSchemaP
	npad	8
$LL2@xmlSchemaP:

; 7181 : 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	jne	$LN12@xmlSchemaP

; 7182 : 	    if (isRef) {

	mov	eax, DWORD PTR [edi+8]
	test	edx, edx
	je	SHORT $LN14@xmlSchemaP

; 7183 : 		if (xmlStrEqual(attr->name, BAD_CAST "id")) {

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlSchemaP

; 7184 : 		    xmlSchemaPValAttrNodeID(pctxt, attr);

	push	edi
	push	esi
	call	_xmlSchemaPValAttrNodeID
	add	esp, 8

; 7185 : 		    goto attr_next;

	jmp	$LN330@xmlSchemaP
$LN16@xmlSchemaP:

; 7186 : 		} else if (xmlStrEqual(attr->name, BAD_CAST "ref")) {

	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN330@xmlSchemaP
$LN25@xmlSchemaP:

; 7217 : 		}
; 7218 : 	    }
; 7219 : 	    if (xmlStrEqual(attr->name, BAD_CAST "use")) {

	push	OFFSET ??_C@_03MMGHDJKG@use@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN29@xmlSchemaP

; 7220 : 
; 7221 : 		attrValue = xmlSchemaGetNodeContent(pctxt, (xmlNodePtr) attr);

	push	edi
	push	esi
	call	_xmlSchemaGetNodeContent
	mov	ebx, eax

; 7222 : 		/* TODO: Maybe we need to normalize the value beforehand. */
; 7223 : 		if (xmlStrEqual(attrValue, BAD_CAST "optional"))

	push	OFFSET ??_C@_08EBGGHLAO@optional@
	push	ebx
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN31@xmlSchemaP

; 7224 : 		    occurs = XML_SCHEMAS_ATTR_USE_OPTIONAL;

	mov	eax, 2
	mov	DWORD PTR _occurs$1$[ebp], eax
	jmp	$LN338@xmlSchemaP
$LN14@xmlSchemaP:

; 7187 : 		    goto attr_next;
; 7188 : 		}
; 7189 : 	    } else {
; 7190 : 		if (xmlStrEqual(attr->name, BAD_CAST "name")) {

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN330@xmlSchemaP

; 7191 : 		    goto attr_next;
; 7192 : 		} else if (xmlStrEqual(attr->name, BAD_CAST "id")) {

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@xmlSchemaP

; 7193 : 		    xmlSchemaPValAttrNodeID(pctxt, attr);

	push	edi
	push	esi
	call	_xmlSchemaPValAttrNodeID
	add	esp, 8

; 7194 : 		    goto attr_next;

	jmp	$LN330@xmlSchemaP
$LN21@xmlSchemaP:

; 7195 : 		} else if (xmlStrEqual(attr->name, BAD_CAST "type")) {

	push	OFFSET ??_C@_04GPMDFGEJ@type@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xmlSchemaP

; 7196 : 		    xmlSchemaPValAttrNodeQName(pctxt, schema, NULL,

	lea	eax, DWORD PTR _tmpName$[ebp]
	push	eax
	lea	eax, DWORD PTR _tmpNs$[ebp]
	push	eax
	push	edi
	push	0
	push	DWORD PTR _schema$[ebp]
	push	esi
	call	_xmlSchemaPValAttrNodeQName
	add	esp, 24					; 00000018H

; 7197 : 			attr, &tmpNs, &tmpName);
; 7198 : 		    goto attr_next;

	jmp	$LN330@xmlSchemaP
$LN23@xmlSchemaP:

; 7199 : 		} else if (xmlStrEqual(attr->name, BAD_CAST "form")) {

	push	OFFSET ??_C@_04MLMMMEIO@form@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN25@xmlSchemaP

; 7200 : 		    /*
; 7201 : 		    * Evaluate the target namespace
; 7202 : 		    */
; 7203 : 		    hasForm = 1;
; 7204 : 		    attrValue = xmlSchemaGetNodeContent(pctxt,

	push	edi
	push	esi
	mov	DWORD PTR _hasForm$1$[ebp], 1
	call	_xmlSchemaGetNodeContent
	mov	ebx, eax

; 7205 : 			(xmlNodePtr) attr);
; 7206 : 		    if (xmlStrEqual(attrValue, BAD_CAST "qualified")) {

	push	OFFSET ??_C@_09NPLHLKJP@qualified@
	push	ebx
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN26@xmlSchemaP

; 7207 : 			ns = pctxt->targetNamespace;

	mov	eax, DWORD PTR [esi+112]
	mov	DWORD PTR _ns$1$[ebp], eax
	jmp	$LN330@xmlSchemaP
$LN26@xmlSchemaP:

; 7208 : 		    } else if (!xmlStrEqual(attrValue, BAD_CAST "unqualified"))

	push	OFFSET ??_C@_0M@PJKDFPFM@unqualified@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN330@xmlSchemaP

; 7209 : 		    {
; 7210 : 			xmlSchemaPSimpleTypeErr(pctxt,

	push	eax
	push	eax
	push	eax
	push	ebx
	push	OFFSET ??_C@_0BK@IDHDHMBC@?$CIqualified?5?$HM?5unqualified?$CJ@
	push	eax
	push	edi
	push	eax
	push	3037					; 00000bddH
	push	esi
	call	_xmlSchemaPSimpleTypeErr
	add	esp, 40					; 00000028H

; 7211 : 			    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 7212 : 			    NULL, (xmlNodePtr) attr,
; 7213 : 			    NULL, "(qualified | unqualified)",
; 7214 : 			    attrValue, NULL, NULL, NULL);
; 7215 : 		    }
; 7216 : 		    goto attr_next;

	jmp	$LN330@xmlSchemaP
$LN31@xmlSchemaP:

; 7225 : 		else if (xmlStrEqual(attrValue, BAD_CAST "prohibited"))

	push	OFFSET ??_C@_0L@HMNCJOMG@prohibited@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@xmlSchemaP

; 7226 : 		    occurs = XML_SCHEMAS_ATTR_USE_PROHIBITED;

	xor	eax, eax
	mov	DWORD PTR _occurs$1$[ebp], eax
	jmp	$LN338@xmlSchemaP
$LN33@xmlSchemaP:

; 7227 : 		else if (xmlStrEqual(attrValue, BAD_CAST "required"))

	push	OFFSET ??_C@_08FEMBDDHD@required@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN35@xmlSchemaP

; 7228 : 		    occurs = XML_SCHEMAS_ATTR_USE_REQUIRED;

	mov	eax, 1
	mov	DWORD PTR _occurs$1$[ebp], eax
	jmp	$LN338@xmlSchemaP
$LN35@xmlSchemaP:

; 7229 : 		else {
; 7230 : 		    xmlSchemaPSimpleTypeErr(pctxt,

	push	0
	push	0
	push	0
	push	ebx
	push	OFFSET ??_C@_0CD@MEKFLEMO@?$CIoptional?5?$HM?5prohibited?5?$HM?5requir@
	push	0
	push	edi
	push	0
	push	1774					; 000006eeH
	push	esi
	call	_xmlSchemaPSimpleTypeErr
	add	esp, 40					; 00000028H

; 7231 : 			XML_SCHEMAP_INVALID_ATTR_USE,
; 7232 : 			NULL, (xmlNodePtr) attr,
; 7233 : 			NULL, "(optional | prohibited | required)",
; 7234 : 			attrValue, NULL, NULL, NULL);
; 7235 : 		}
; 7236 : 		goto attr_next;

	jmp	$LN330@xmlSchemaP
$LN29@xmlSchemaP:

; 7237 : 	    } else if (xmlStrEqual(attr->name, BAD_CAST "default")) {

	push	OFFSET ??_C@_07DLHCIBDH@default@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN37@xmlSchemaP

; 7238 : 		/*
; 7239 : 		* 3.2.3 : 1
; 7240 : 		* default and fixed must not both be present.
; 7241 : 		*/
; 7242 : 		if (defValue) {

	cmp	DWORD PTR _defValue$1$[ebp], 0
	je	SHORT $LN39@xmlSchemaP
$LN339@xmlSchemaP:

; 7270 : 	    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 7271 : 
; 7272 : attr_next:
; 7273 : 	attr = attr->next;

	push	OFFSET ??_C@_05OFLEIIDM@fixed@
	push	OFFSET ??_C@_07DLHCIBDH@default@
	push	edi
	push	0
	push	3051					; 00000bebH
	push	esi
	call	_xmlSchemaPMutualExclAttrErr
	add	esp, 24					; 00000018H
	jmp	SHORT $LN330@xmlSchemaP
$LN39@xmlSchemaP:

; 7243 : 		    xmlSchemaPMutualExclAttrErr(pctxt,
; 7244 : 			XML_SCHEMAP_SRC_ATTRIBUTE_1,
; 7245 : 			NULL, attr, "default", "fixed");
; 7246 : 		} else {
; 7247 : 		    defValue = xmlSchemaGetNodeContent(pctxt, (xmlNodePtr) attr);

	push	edi
	push	esi
	call	_xmlSchemaGetNodeContent

; 7248 : 		    defValueType = WXS_ATTR_DEF_VAL_DEFAULT;

	mov	ecx, 1
	mov	DWORD PTR _defValue$1$[ebp], eax

; 7249 : 		}
; 7250 : 		goto attr_next;

	mov	eax, DWORD PTR _occurs$1$[ebp]
	add	esp, 8
	mov	DWORD PTR _defValueType$1$[ebp], ecx
	jmp	SHORT $attr_next$349
$LN37@xmlSchemaP:

; 7251 : 	    } else if (xmlStrEqual(attr->name, BAD_CAST "fixed")) {

	push	OFFSET ??_C@_05OFLEIIDM@fixed@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN44@xmlSchemaP

; 7252 : 		/*
; 7253 : 		* 3.2.3 : 1
; 7254 : 		* default and fixed must not both be present.
; 7255 : 		*/
; 7256 : 		if (defValue) {

	cmp	DWORD PTR _defValue$1$[ebp], 0
	jne	SHORT $LN339@xmlSchemaP

; 7257 : 		    xmlSchemaPMutualExclAttrErr(pctxt,
; 7258 : 			XML_SCHEMAP_SRC_ATTRIBUTE_1,
; 7259 : 			NULL, attr, "default", "fixed");
; 7260 : 		} else {
; 7261 : 		    defValue = xmlSchemaGetNodeContent(pctxt, (xmlNodePtr) attr);

	push	edi
	push	esi
	call	_xmlSchemaGetNodeContent

; 7262 : 		    defValueType = WXS_ATTR_DEF_VAL_FIXED;

	mov	ecx, 2
	mov	DWORD PTR _defValue$1$[ebp], eax

; 7263 : 		}
; 7264 : 		goto attr_next;

	mov	eax, DWORD PTR _occurs$1$[ebp]
	add	esp, 8
	mov	DWORD PTR _defValueType$1$[ebp], ecx
	jmp	SHORT $attr_next$349
$LN12@xmlSchemaP:

; 7265 : 	    }
; 7266 : 	} else if (! xmlStrEqual(attr->ns->href, xmlSchemaNs))

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN330@xmlSchemaP
$LN44@xmlSchemaP:

; 7267 : 	    goto attr_next;
; 7268 : 
; 7269 : 	xmlSchemaPIllegalAttrErr(pctxt,

	push	edi
	push	0
	push	3035					; 00000bdbH
	push	esi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN330@xmlSchemaP:

; 7270 : 	    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 7271 : 
; 7272 : attr_next:
; 7273 : 	attr = attr->next;

	mov	eax, DWORD PTR _occurs$1$[ebp]
$LN338@xmlSchemaP:
	mov	ecx, DWORD PTR _defValueType$1$[ebp]
$attr_next$349:
	mov	edi, DWORD PTR [edi+24]
	mov	edx, DWORD PTR _isRef$1$[ebp]
	test	edi, edi
	jne	$LL2@xmlSchemaP

; 7274 :     }
; 7275 :     /*
; 7276 :     * 3.2.3 : 2
; 7277 :     * If default and use are both present, use must have
; 7278 :     * the actual value optional.
; 7279 :     */
; 7280 :     if ((defValueType == WXS_ATTR_DEF_VAL_DEFAULT) &&

	cmp	ecx, 1
	jne	SHORT $LN319@xmlSchemaP
	cmp	eax, 2
	je	SHORT $LN319@xmlSchemaP

; 7281 : 	(occurs != XML_SCHEMAS_ATTR_USE_OPTIONAL)) {
; 7282 : 	xmlSchemaPSimpleTypeErr(pctxt,

	push	0
	push	0
	push	OFFSET ??_C@_0FK@JMMMCAKL@The?5value?5of?5the?5attribute?5?8use@
	push	0
	push	OFFSET ??_C@_0CD@MEKFLEMO@?$CIoptional?5?$HM?5prohibited?5?$HM?5requir@
	push	0
	push	DWORD PTR _node$[ebp]
	push	0
	push	3052					; 00000becH
	push	esi
	call	_xmlSchemaPSimpleTypeErr
	add	esp, 40					; 00000028H
$LN319@xmlSchemaP:

; 7283 : 	    XML_SCHEMAP_SRC_ATTRIBUTE_2,
; 7284 : 	    NULL, node, NULL,
; 7285 : 	    "(optional | prohibited | required)", NULL,
; 7286 : 	    "The value of the attribute 'use' must be 'optional' "
; 7287 : 	    "if the attribute 'default' is present",
; 7288 : 	    NULL, NULL);
; 7289 :     }
; 7290 :     /*
; 7291 :     * We want correct attributes.
; 7292 :     */
; 7293 :     if (nberrors != pctxt->nberrors)

	mov	edi, DWORD PTR _tmpNs$[ebp]
	mov	ebx, DWORD PTR _tmpName$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _tmpNs$1$[ebp], edi
	jmp	SHORT $LN45@xmlSchemaP
$LN320@xmlSchemaP:

; 7180 :     while (attr != NULL) {

	mov	edi, DWORD PTR _tmpNs$1$[ebp]
$LN45@xmlSchemaP:

; 7283 : 	    XML_SCHEMAP_SRC_ATTRIBUTE_2,
; 7284 : 	    NULL, node, NULL,
; 7285 : 	    "(optional | prohibited | required)", NULL,
; 7286 : 	    "The value of the attribute 'use' must be 'optional' "
; 7287 : 	    "if the attribute 'default' is present",
; 7288 : 	    NULL, NULL);
; 7289 :     }
; 7290 :     /*
; 7291 :     * We want correct attributes.
; 7292 :     */
; 7293 :     if (nberrors != pctxt->nberrors)

	mov	ecx, DWORD PTR _nberrors$1$[ebp]
	cmp	ecx, DWORD PTR [esi+20]
	jne	$LN8@xmlSchemaP

; 7294 : 	return(NULL);
; 7295 :     if (! isRef) {

	cmp	DWORD PTR _isRef$1$[ebp], 0
	jne	$LN47@xmlSchemaP

; 7296 : 	xmlSchemaAttributePtr attrDecl;
; 7297 : 
; 7298 : 	/* TODO: move XML_SCHEMAS_QUALIF_ATTR to the parser. */
; 7299 : 	if ((! hasForm) && (schema->flags & XML_SCHEMAS_QUALIF_ATTR))

	cmp	DWORD PTR _hasForm$1$[ebp], 0
	jne	SHORT $LN336@xmlSchemaP
	mov	eax, DWORD PTR _schema$[ebp]
	test	BYTE PTR [eax+24], 2
	je	SHORT $LN336@xmlSchemaP

; 7300 : 	    ns = pctxt->targetNamespace;

	mov	eax, DWORD PTR [esi+112]
	mov	DWORD PTR _ns$1$[ebp], eax
	jmp	SHORT $LN49@xmlSchemaP
$LN336@xmlSchemaP:

; 7301 : 	/*
; 7302 : 	* 3.2.6 Schema Component Constraint: xsi: Not Allowed
; 7303 : 	* TODO: Move this to the component layer.
; 7304 : 	*/
; 7305 : 	if (xmlStrEqual(ns, xmlSchemaInstanceNs)) {

	mov	eax, DWORD PTR _ns$1$[ebp]
$LN49@xmlSchemaP:
	push	DWORD PTR _xmlSchemaInstanceNs
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN50@xmlSchemaP

; 7306 : 	    xmlSchemaCustomErr(ACTXT_CAST pctxt,

	push	0
	push	DWORD PTR _xmlSchemaInstanceNs
	push	OFFSET ??_C@_0CJ@KHJHCHGN@The?5target?5namespace?5must?5not?5m@
	push	0
	push	DWORD PTR _node$[ebp]
	push	3057					; 00000bf1H
	push	esi
	call	_xmlSchemaCustomErr
	add	esp, 28					; 0000001cH
$LN50@xmlSchemaP:

; 7307 : 		XML_SCHEMAP_NO_XSI,
; 7308 : 		node, NULL,
; 7309 : 		"The target namespace must not match '%s'",
; 7310 : 		xmlSchemaInstanceNs, NULL);
; 7311 : 	}
; 7312 : 	attr = xmlSchemaGetPropNode(node, "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR _node$[ebp]
	call	_xmlSchemaGetPropNode
	add	esp, 8
	mov	DWORD PTR _attr$3$[ebp], eax

; 7313 : 	if (attr == NULL) {

	test	eax, eax
	jne	SHORT $LN51@xmlSchemaP

; 2802 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	mov	ebx, DWORD PTR _node$[ebp]
	push	ebx
	push	eax
	push	eax
	mov	DWORD PTR _des$5[ebp], eax
	lea	eax, DWORD PTR _des$5[ebp]
	push	eax
	call	_xmlSchemaFormatItemForReport

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	mov	eax, DWORD PTR _des$5[ebp]
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	push	OFFSET ??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	inc	DWORD PTR [esi+20]
	push	0
	push	0
	push	2
	push	3036					; 00000bdcH
	push	16					; 00000010H
	push	ebx
	push	esi
	push	DWORD PTR [esi+4]
	mov	DWORD PTR [esi+16], 3036		; 00000bdcH
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+24]
	call	___xmlRaiseError
	add	esp, 88					; 00000058H
	jmp	$LN346@xmlSchemaP
$LN51@xmlSchemaP:

; 7314 : 	    xmlSchemaPMissingAttrErr(pctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
; 7315 : 		NULL, node, "name", NULL);
; 7316 : 	    return (NULL);
; 7317 : 	}
; 7318 : 	if (xmlSchemaPValAttrNode(pctxt, NULL, attr,
; 7319 : 	    xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	push	22					; 00000016H
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	push	eax
	push	DWORD PTR _attr$3$[ebp]
	push	0
	push	esi
	call	_xmlSchemaPValAttrNode
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN8@xmlSchemaP

; 7320 : 	    return (NULL);
; 7321 : 	}
; 7322 : 	/*
; 7323 : 	* 3.2.6 Schema Component Constraint: xmlns Not Allowed
; 7324 : 	* TODO: Move this to the component layer.
; 7325 : 	*/
; 7326 : 	if (xmlStrEqual(name, BAD_CAST "xmlns")) {

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR _name$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN53@xmlSchemaP

; 7327 : 	    xmlSchemaPSimpleTypeErr(pctxt,

	push	0
	push	0
	push	OFFSET ??_C@_0DC@IMLKIPJD@The?5value?5of?5the?5attribute?5must@
	push	0
	push	0
	push	22					; 00000016H
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	push	eax
	push	DWORD PTR _attr$3$[ebp]
	push	0
	push	3056					; 00000bf0H
	push	esi
	call	_xmlSchemaPSimpleTypeErr
	add	esp, 40					; 00000028H
$LN8@xmlSchemaP:

; 7530 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@xmlSchemaP:

; 7328 : 		XML_SCHEMAP_NO_XMLNS,
; 7329 : 		NULL, (xmlNodePtr) attr,
; 7330 : 		xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), NULL, NULL,
; 7331 : 		"The value of the attribute must not match 'xmlns'",
; 7332 : 		NULL, NULL);
; 7333 : 	    return (NULL);
; 7334 : 	}
; 7335 : 	if (occurs == XML_SCHEMAS_ATTR_USE_PROHIBITED)

	mov	ecx, DWORD PTR _occurs$1$[ebp]
	test	ecx, ecx
	je	$check_children$350

; 7336 : 	    goto check_children;
; 7337 : 	/*
; 7338 : 	* Create the attribute use component.
; 7339 : 	*/
; 7340 : 	use = xmlSchemaAddAttributeUse(pctxt, node);

	push	DWORD PTR _node$[ebp]
	push	esi
	call	_xmlSchemaAddAttributeUse
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR _use$2$[ebp], ecx

; 7341 : 	if (use == NULL)

	test	ecx, ecx
	je	SHORT $LN8@xmlSchemaP

; 7342 : 	    return(NULL);
; 7343 : 	use->occurs = occurs;

	mov	eax, DWORD PTR _occurs$1$[ebp]

; 7344 : 	/*
; 7345 : 	* Create the attribute declaration.
; 7346 : 	*/
; 7347 : 	attrDecl = xmlSchemaAddAttribute(pctxt, schema, name, ns, node, 0);

	push	0
	push	DWORD PTR _node$[ebp]
	mov	DWORD PTR [ecx+24], eax
	push	DWORD PTR _ns$1$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _schema$[ebp]
	push	esi
	call	_xmlSchemaAddAttribute
	add	esp, 24					; 00000018H

; 7348 : 	if (attrDecl == NULL)

	test	eax, eax
	je	SHORT $LN8@xmlSchemaP

; 7349 : 	    return (NULL);
; 7350 : 	if (tmpName != NULL) {

	test	ebx, ebx
	je	SHORT $LN57@xmlSchemaP

; 7351 : 	    attrDecl->typeName = tmpName;

	mov	DWORD PTR [eax+24], ebx

; 7352 : 	    attrDecl->typeNs = tmpNs;

	mov	DWORD PTR [eax+28], edi
$LN57@xmlSchemaP:

; 7353 : 	}
; 7354 : 	use->attrDecl = attrDecl;

	mov	ecx, DWORD PTR _use$2$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 7355 : 	/*
; 7356 : 	* Value constraint.
; 7357 : 	*/
; 7358 : 	if (defValue != NULL) {

	mov	ecx, DWORD PTR _defValue$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN326@xmlSchemaP

; 7359 : 	    attrDecl->defValue = defValue;
; 7360 : 	    if (defValueType == WXS_ATTR_DEF_VAL_FIXED)

	cmp	DWORD PTR _defValueType$1$[ebp], 2
	mov	DWORD PTR [eax+44], ecx
	mov	ecx, DWORD PTR _occurs$1$[ebp]
	jne	SHORT $check_children$350

; 7361 : 		attrDecl->flags |= XML_SCHEMAS_ATTR_FIXED;

	or	DWORD PTR [eax+60], 512			; 00000200H

; 7362 : 	}

	jmp	SHORT $check_children$350
$LN47@xmlSchemaP:

; 7363 :     } else if (occurs != XML_SCHEMAS_ATTR_USE_PROHIBITED) {

	mov	ecx, DWORD PTR _occurs$1$[ebp]
	test	ecx, ecx
	je	SHORT $check_children$350

; 7364 : 	xmlSchemaQNameRefPtr ref;
; 7365 : 
; 7366 : 	/*
; 7367 : 	* Create the attribute use component.
; 7368 : 	*/
; 7369 : 	use = xmlSchemaAddAttributeUse(pctxt, node);

	push	eax
	push	esi
	call	_xmlSchemaAddAttributeUse
	add	esp, 8
	mov	DWORD PTR _use$2$[ebp], eax

; 7370 : 	if (use == NULL)

	test	eax, eax
	je	$LN8@xmlSchemaP

; 7371 : 	    return(NULL);
; 7372 : 	/*
; 7373 : 	* We need to resolve the reference at later stage.
; 7374 : 	*/
; 7375 : 	WXS_ADD_PENDING(pctxt, use);

	push	eax
	mov	eax, DWORD PTR [esi+28]
	add	eax, 20					; 00000014H
	push	10					; 0000000aH
	push	eax
	call	_xmlSchemaAddItemSize

; 7376 : 	use->occurs = occurs;

	mov	ecx, DWORD PTR _use$2$[ebp]
	mov	eax, DWORD PTR _occurs$1$[ebp]

; 7377 : 	/*
; 7378 : 	* Create a QName reference to the attribute declaration.
; 7379 : 	*/
; 7380 : 	ref = xmlSchemaNewQNameRef(pctxt, XML_SCHEMA_TYPE_ATTRIBUTE,

	push	edi
	push	ebx
	push	15					; 0000000fH
	push	esi
	mov	DWORD PTR [ecx+24], eax
	call	_xmlSchemaNewQNameRef
	add	esp, 28					; 0000001cH

; 7381 : 	    tmpName, tmpNs);
; 7382 : 	if (ref == NULL)

	test	eax, eax
	je	$LN8@xmlSchemaP

; 7383 : 	    return(NULL);
; 7384 : 	/*
; 7385 : 	* Assign the reference. This will be substituted for the
; 7386 : 	* referenced attribute declaration when the QName is resolved.
; 7387 : 	*/
; 7388 : 	use->attrDecl = WXS_ATTR_CAST ref;

	mov	ecx, DWORD PTR _use$2$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 7389 : 	/*
; 7390 : 	* Value constraint.
; 7391 : 	*/
; 7392 : 	if (defValue != NULL)

	mov	eax, DWORD PTR _defValue$1$[ebp]
	test	eax, eax
	je	SHORT $LN63@xmlSchemaP

; 7393 : 	    use->defValue = defValue;

	mov	DWORD PTR [ecx+28], eax
$LN63@xmlSchemaP:

; 7394 : 	if (defValueType == WXS_ATTR_DEF_VAL_FIXED)

	cmp	DWORD PTR _defValueType$1$[ebp], 2
	jne	SHORT $LN326@xmlSchemaP

; 7395 : 	    use->flags |= XML_SCHEMA_ATTR_USE_FIXED;

	or	DWORD PTR [ecx+16], 1
$LN326@xmlSchemaP:

; 7396 :     }
; 7397 : 
; 7398 : check_children:
; 7399 :     /*
; 7400 :     * And now for the children...
; 7401 :     */
; 7402 :     child = node->children;

	mov	ecx, DWORD PTR _occurs$1$[ebp]
$check_children$350:
	mov	eax, DWORD PTR _node$[ebp]
	mov	edi, DWORD PTR [eax+12]

; 7403 :     if (occurs == XML_SCHEMAS_ATTR_USE_PROHIBITED) {

	test	ecx, ecx
	jne	$LN65@xmlSchemaP

; 7404 : 	xmlSchemaAttributeUseProhibPtr prohib;
; 7405 : 
; 7406 : 	if (IS_SCHEMA(child, "annotation")) {

	test	edi, edi
	je	$LN102@xmlSchemaP
	cmp	DWORD PTR [edi+36], ecx
	je	SHORT $LN67@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN323@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN323@xmlSchemaP

; 7407 : 	    xmlSchemaParseAnnotation(pctxt, child, 0);

	push	0
	push	edi
	push	esi
	call	_xmlSchemaParseAnnotation

; 7408 : 	    child = child->next;

	mov	edi, DWORD PTR [edi+24]
	add	esp, 12					; 0000000cH
$LN323@xmlSchemaP:

; 7409 : 	}
; 7410 : 	if (child != NULL) {

	mov	eax, DWORD PTR _node$[ebp]
$LN67@xmlSchemaP:
	test	edi, edi
	je	SHORT $LN102@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	eax
	push	0
	lea	eax, DWORD PTR _des$4[ebp]
	mov	DWORD PTR _des$4[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0O@MNAJHLGE@?$CIannotation?$DP?$CJ@
	push	DWORD PTR _des$4[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	edi
	push	esi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$4[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN102@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN102@xmlSchemaP:

; 7411 : 	    xmlSchemaPContentErr(pctxt,
; 7412 : 		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 7413 : 		NULL, node, child, NULL,
; 7414 : 		"(annotation?)");
; 7415 : 	}
; 7416 : 	/*
; 7417 : 	* Check for pointlessness of attribute prohibitions.
; 7418 : 	*/
; 7419 : 	if (parentType == XML_SCHEMA_TYPE_ATTRIBUTEGROUP) {

	mov	eax, DWORD PTR _parentType$[ebp]
	cmp	eax, 16					; 00000010H
	jne	SHORT $LN69@xmlSchemaP

; 7420 : 	    xmlSchemaCustomWarning(ACTXT_CAST pctxt,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0FF@PAOOKLLP@Skipping?5attribute?5use?5prohibit@
$LN347@xmlSchemaP:

; 7530 : }

	push	0
	push	DWORD PTR _node$[ebp]
	push	3086					; 00000c0eH
	push	esi
	call	_xmlSchemaCustomWarning
	add	esp, 32					; 00000020H
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN69@xmlSchemaP:

; 7421 : 		XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
; 7422 : 		node, NULL,
; 7423 : 		"Skipping attribute use prohibition, since it is "
; 7424 : 		"pointless inside an <attributeGroup>",
; 7425 : 		NULL, NULL, NULL);
; 7426 : 	    return(NULL);
; 7427 : 	} else if (parentType == XML_SCHEMA_TYPE_EXTENSION) {

	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN71@xmlSchemaP

; 7428 : 	    xmlSchemaCustomWarning(ACTXT_CAST pctxt,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0FA@EKEFODDF@Skipping?5attribute?5use?5prohibit@

; 7429 : 		XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
; 7430 : 		node, NULL,
; 7431 : 		"Skipping attribute use prohibition, since it is "
; 7432 : 		"pointless when extending a type",
; 7433 : 		NULL, NULL, NULL);
; 7434 : 	    return(NULL);

	jmp	SHORT $LN347@xmlSchemaP
$LN71@xmlSchemaP:

; 7435 : 	}
; 7436 : 	if (! isRef) {

	cmp	DWORD PTR _isRef$1$[ebp], 0
	jne	SHORT $LN321@xmlSchemaP

; 7437 : 	    tmpName = name;
; 7438 : 	    tmpNs = ns;

	mov	edi, DWORD PTR _ns$1$[ebp]
	mov	ebx, DWORD PTR _name$[ebp]
	mov	DWORD PTR _tmpNs$1$[ebp], edi
	jmp	SHORT $LN72@xmlSchemaP
$LN321@xmlSchemaP:

; 7435 : 	}
; 7436 : 	if (! isRef) {

	mov	edi, DWORD PTR _tmpNs$1$[ebp]
$LN72@xmlSchemaP:

; 7439 : 	}
; 7440 : 	/*
; 7441 : 	* Check for duplicate attribute prohibitions.
; 7442 : 	*/
; 7443 : 	if (uses) {

	mov	eax, DWORD PTR _uses$[ebp]
	test	eax, eax
	je	SHORT $LN318@xmlSchemaP

; 7444 : 	    int i;
; 7445 : 
; 7446 : 	    for (i = 0; i < uses->nbItems; i++) {

	xor	edx, edx
	cmp	DWORD PTR [eax+4], edx
	jle	SHORT $LN318@xmlSchemaP

; 7447 : 		use = uses->items[i];

	mov	ecx, DWORD PTR [eax]
$LL6@xmlSchemaP:
	mov	eax, DWORD PTR [ecx]

; 7448 : 		if ((use->type == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB) &&
; 7449 : 		    (tmpName == (WXS_ATTR_PROHIB_CAST use)->name) &&

	cmp	DWORD PTR [eax], 2001			; 000007d1H
	jne	SHORT $LN4@xmlSchemaP
	cmp	ebx, DWORD PTR [eax+8]
	jne	SHORT $LN4@xmlSchemaP
	cmp	edi, DWORD PTR [eax+12]
	je	SHORT $LN310@xmlSchemaP
$LN4@xmlSchemaP:

; 7444 : 	    int i;
; 7445 : 
; 7446 : 	    for (i = 0; i < uses->nbItems; i++) {

	mov	eax, DWORD PTR _uses$[ebp]
	inc	edx
	add	ecx, 4
	cmp	edx, DWORD PTR [eax+4]
	jl	SHORT $LL6@xmlSchemaP
$LN318@xmlSchemaP:

; 5472 :     ret = (xmlSchemaAttributeUseProhibPtr)

	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 5473 : 	xmlMalloc(sizeof(xmlSchemaAttributeUseProhib));
; 5474 :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN123@xmlSchemaP

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [esi+20]

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CF@BKCCIOBM@allocating?5attribute?5use?5prohib@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 7530 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN310@xmlSchemaP:

; 7450 : 		    (tmpNs == (WXS_ATTR_PROHIB_CAST use)->targetNamespace))
; 7451 : 		{
; 7452 : 		    xmlChar *str = NULL;
; 7453 : 
; 7454 : 		    xmlSchemaCustomWarning(ACTXT_CAST pctxt,

	push	0
	push	0
	push	ebx
	lea	eax, DWORD PTR _str$6[ebp]
	mov	DWORD PTR _str$6[ebp], 0
	push	edi
	push	eax
	call	_xmlSchemaFormatQName
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0DC@LIPHNCMP@Skipping?5duplicate?5attribute?5us@
	push	0
	push	DWORD PTR _node$[ebp]
	push	3086					; 00000c0eH
	push	esi
	call	_xmlSchemaCustomWarning
	add	esp, 32					; 00000020H
$LN346@xmlSchemaP:

; 7530 : }

	mov	eax, DWORD PTR _str$6[ebp]
	test	eax, eax
	je	$LN8@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN123@xmlSchemaP:

; 5479 :     memset(ret, 0, sizeof(xmlSchemaAttributeUseProhib));

	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+16], 0

; 5480 :     ret->type = XML_SCHEMA_EXTRA_ATTR_USE_PROHIB;

	mov	DWORD PTR [edi], 2001			; 000007d1H

; 5481 :     WXS_ADD_LOCAL(pctxt, ret);

	mov	eax, DWORD PTR [esi+28]
	push	edi
	push	10					; 0000000aH
	mov	eax, DWORD PTR [eax+16]
	add	eax, 48					; 00000030H
	push	eax
	call	_xmlSchemaAddItemSize

; 7455 : 			XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
; 7456 : 			node, NULL,
; 7457 : 			"Skipping duplicate attribute use prohibition '%s'",
; 7458 : 			xmlSchemaFormatQName(&str, tmpNs, tmpName),
; 7459 : 			NULL, NULL);
; 7460 : 		    FREE_AND_NULL(str)
; 7461 : 		    return(NULL);
; 7462 : 		}
; 7463 : 	    }
; 7464 : 	}
; 7465 : 	/*
; 7466 : 	* Create the attribute prohibition helper component.
; 7467 : 	*/
; 7468 : 	prohib = xmlSchemaAddAttributeUseProhib(pctxt);
; 7469 : 	if (prohib == NULL)
; 7470 : 	    return(NULL);
; 7471 : 	prohib->node = node;

	mov	eax, DWORD PTR _node$[ebp]

; 5481 :     WXS_ADD_LOCAL(pctxt, ret);

	add	esp, 12					; 0000000cH

; 7472 : 	prohib->name = tmpName;
; 7473 : 	prohib->targetNamespace = tmpNs;
; 7474 : 	if (isRef) {

	cmp	DWORD PTR _isRef$1$[ebp], 0
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR _tmpNs$1$[ebp]
	mov	DWORD PTR [edi+8], ebx
	mov	DWORD PTR [edi+12], eax
	je	SHORT $LN77@xmlSchemaP

; 7475 : 	    /*
; 7476 : 	    * We need at least to resolve to the attribute declaration.
; 7477 : 	    */
; 7478 : 	    WXS_ADD_PENDING(pctxt, prohib);

	mov	ecx, DWORD PTR [esi+28]
	push	edi
	add	ecx, 20					; 00000014H
	push	10					; 0000000aH
	push	ecx
	call	_xmlSchemaAddItemSize
	add	esp, 12					; 0000000cH
$LN77@xmlSchemaP:

; 7479 : 	}
; 7480 : 	return(WXS_BASIC_CAST prohib);

	mov	eax, edi
	pop	edi

; 7530 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN65@xmlSchemaP:

; 7481 :     } else {
; 7482 : 	if (IS_SCHEMA(child, "annotation")) {

	test	edi, edi
	je	SHORT $LN334@xmlSchemaP
	cmp	DWORD PTR [edi+36], 0
	je	SHORT $LN334@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN334@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN334@xmlSchemaP

; 7483 : 	    /*
; 7484 : 	    * TODO: Should this go into the attr decl?
; 7485 : 	    */
; 7486 : 	    use->annot = xmlSchemaParseAnnotation(pctxt, child, 1);

	push	1
	push	edi
	push	esi
	call	_xmlSchemaParseAnnotation
	mov	ebx, DWORD PTR _use$2$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebx+4], eax

; 7487 : 	    child = child->next;

	mov	edi, DWORD PTR [edi+24]
	jmp	SHORT $LN78@xmlSchemaP
$LN334@xmlSchemaP:

; 7488 : 	}
; 7489 : 	if (isRef) {

	mov	ebx, DWORD PTR _use$2$[ebp]
$LN78@xmlSchemaP:
	cmp	DWORD PTR _isRef$1$[ebp], 0
	je	$LN79@xmlSchemaP

; 7490 : 	    if (child != NULL) {

	test	edi, edi
	je	$LN288@xmlSchemaP

; 7491 : 		if (IS_SCHEMA(child, "simpleType"))

	cmp	DWORD PTR [edi+36], 0
	je	SHORT $LN82@xmlSchemaP
	push	OFFSET ??_C@_0L@FMMGGLOP@simpleType@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN82@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN82@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$3[ebp]
	mov	DWORD PTR _des$3[ebp], 0
	push	0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0O@MNAJHLGE@?$CIannotation?$DP?$CJ@
	push	DWORD PTR _des$3[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3054					; 00000beeH

; 7492 : 		    /*
; 7493 : 		    * 3.2.3 : 3.2
; 7494 : 		    * If ref is present, then all of <simpleType>,
; 7495 : 		    * form and type must be absent.
; 7496 : 		    */
; 7497 : 		    xmlSchemaPContentErr(pctxt,

	jmp	$LN343@xmlSchemaP
$LN82@xmlSchemaP:

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$2[ebp]
	mov	DWORD PTR _des$2[ebp], 0
	push	0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0O@MNAJHLGE@?$CIannotation?$DP?$CJ@

; 7498 : 			XML_SCHEMAP_SRC_ATTRIBUTE_3_2,
; 7499 : 			NULL, node, child, NULL,
; 7500 : 			"(annotation?)");
; 7501 : 		else
; 7502 : 		    xmlSchemaPContentErr(pctxt,
; 7503 : 			XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 7504 : 			NULL, node, child, NULL,
; 7505 : 			"(annotation?)");
; 7506 : 	    }
; 7507 : 	} else {

	jmp	$LN344@xmlSchemaP
$LN79@xmlSchemaP:

; 7508 : 	    if (IS_SCHEMA(child, "simpleType")) {

	test	edi, edi
	je	$LN288@xmlSchemaP
	cmp	DWORD PTR [edi+36], 0
	je	SHORT $LN84@xmlSchemaP
	push	OFFSET ??_C@_0L@FMMGGLOP@simpleType@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN84@xmlSchemaP
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN84@xmlSchemaP

; 7509 : 		if (WXS_ATTRUSE_DECL(use)->typeName != NULL) {

	mov	eax, DWORD PTR [ebx+12]
	push	0
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN85@xmlSchemaP

; 7510 : 		    /*
; 7511 : 		    * 3.2.3 : 4
; 7512 : 		    * type and <simpleType> must not both be present.
; 7513 : 		    */
; 7514 : 		    xmlSchemaPContentErr(pctxt, XML_SCHEMAP_SRC_ATTRIBUTE_4,

	push	OFFSET ??_C@_0EH@BAMMFMJA@The?5attribute?5?8type?8?5and?5the?5?$DMs@
	push	edi
	push	DWORD PTR _node$[ebp]
	push	0
	push	3055					; 00000befH
	push	esi
	call	_xmlSchemaPContentErr
	add	esp, 28					; 0000001cH

; 7515 : 			NULL, node, child,
; 7516 : 			"The attribute 'type' and the <simpleType> child "
; 7517 : 			"are mutually exclusive", NULL);
; 7518 : 		} else

	jmp	SHORT $LN86@xmlSchemaP
$LN85@xmlSchemaP:

; 7519 : 		    WXS_ATTRUSE_TYPEDEF(use) =

	push	edi
	push	DWORD PTR _schema$[ebp]
	push	esi
	call	_xmlSchemaParseSimpleType
	mov	ecx, DWORD PTR [ebx+12]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx+48], eax
$LN86@xmlSchemaP:

; 7520 : 			xmlSchemaParseSimpleType(pctxt, schema, child, 0);
; 7521 : 		child = child->next;

	mov	edi, DWORD PTR [edi+24]
$LN84@xmlSchemaP:

; 7522 : 	    }
; 7523 : 	    if (child != NULL)

	test	edi, edi
	je	SHORT $LN288@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0BL@LABGHPL@?$CIannotation?$DP?0?5simpleType?$DP?$CJ@
$LN344@xmlSchemaP:

; 7524 : 		xmlSchemaPContentErr(pctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 7525 : 		NULL, node, child, NULL,
; 7526 : 		"(annotation?, simpleType?)");
; 7527 : 	}
; 7528 :     }
; 7529 :     return (WXS_BASIC_CAST use);

	push	DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
$LN343@xmlSchemaP:
	push	edi
	push	esi
	call	_xmlSchemaPErr
	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN288@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN288@xmlSchemaP:

; 7530 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseLocalAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseRestriction
_TEXT	SEGMENT
_lastfacet$1$ = -8					; size = 4
_lastFacetLink$1$ = -8					; size = 4
_str2$1 = -8						; size = 4
_des$2 = -4						; size = 4
_str1$3 = -4						; size = 4
_child$ = -4						; size = 4
_des$4 = 8						; size = 4
_des$5 = 8						; size = 4
_type$1$ = 8						; size = 4
_des$6 = 8						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_parentType$ = 20					; size = 4
_xmlSchemaParseRestriction PROC				; COMDAT

; 11520: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN10@xmlSchemaP

; 11521:     xmlSchemaTypePtr type;
; 11522:     xmlNodePtr child = NULL;
; 11523:     xmlAttrPtr attr;
; 11524: 
; 11525:     if ((ctxt == NULL) || (schema == NULL) || (node == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	$LN10@xmlSchemaP
	mov	eax, DWORD PTR _node$[ebp]
	test	eax, eax
	je	$LN10@xmlSchemaP

; 11526:         return (NULL);
; 11527:     /* Not a component, don't create it. */
; 11528:     type = ctxt->ctxtType;

	mov	ebx, DWORD PTR [edi+84]
	mov	DWORD PTR _type$1$[ebp], ebx

; 11529:     type->flags |= XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION;

	or	DWORD PTR [ebx+48], 4

; 11530: 
; 11531:     /*
; 11532:     * Check for illegal attributes.
; 11533:     */
; 11534:     attr = node->properties;

	mov	esi, DWORD PTR [eax+44]

; 11535:     while (attr != NULL) {

	test	esi, esi
	je	$LN395@xmlSchemaP
$LL2@xmlSchemaP:

; 11536: 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN11@xmlSchemaP

; 11537: 	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlSchemaP
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlSchemaP

; 11538: 		(!xmlStrEqual(attr->name, BAD_CAST "base"))) {
; 11539: 		xmlSchemaPIllegalAttrErr(ctxt,
; 11540: 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 11541: 	    }

	jmp	SHORT $LN409@xmlSchemaP
$LN11@xmlSchemaP:

; 11542: 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlSchemaP
$LN409@xmlSchemaP:

; 11543: 	    xmlSchemaPIllegalAttrErr(ctxt,
; 11544: 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 11545: 	}
; 11546: 	attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN14@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaP
	mov	esi, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [esi+44]

; 4667 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN395@xmlSchemaP
$LL79@xmlSchemaP:

; 4668 :         if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN83@xmlSchemaP
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN78@xmlSchemaP
$LN83@xmlSchemaP:

; 4669 : 	    return(prop);
; 4670 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL79@xmlSchemaP

; 3243 : 
; 3244 : /************************************************************************
; 3245 :  *									*
; 3246 :  *			Streamable error functions                      *
; 3247 :  *									*
; 3248 :  ************************************************************************/
; 3249 : 
; 3250 : 
; 3251 : 
; 3252 : 
; 3253 : /************************************************************************
; 3254 :  *									*
; 3255 :  *			Validation helper functions			*
; 3256 :  *									*
; 3257 :  ************************************************************************/
; 3258 : 
; 3259 : 
; 3260 : /************************************************************************
; 3261 :  *									*
; 3262 :  *			Allocation functions				*
; 3263 :  *									*
; 3264 :  ************************************************************************/
; 3265 : 
; 3266 : /**
; 3267 :  * xmlSchemaNewSchemaForParserCtxt:
; 3268 :  * @ctxt:  a schema validation context
; 3269 :  *
; 3270 :  * Allocate a new Schema structure.
; 3271 :  *
; 3272 :  * Returns the newly allocated structure or NULL in case or error
; 3273 :  */
; 3274 : static xmlSchemaPtr
; 3275 : xmlSchemaNewSchema(xmlSchemaParserCtxtPtr ctxt)
; 3276 : {
; 3277 :     xmlSchemaPtr ret;
; 3278 : 
; 3279 :     ret = (xmlSchemaPtr) xmlMalloc(sizeof(xmlSchema));
; 3280 :     if (ret == NULL) {
; 3281 :         xmlSchemaPErrMemory(ctxt, "allocating schema", NULL);
; 3282 :         return (NULL);
; 3283 :     }
; 3284 :     memset(ret, 0, sizeof(xmlSchema));
; 3285 :     ret->dict = ctxt->dict;
; 3286 :     xmlDictReference(ret->dict);
; 3287 : 
; 3288 :     return (ret);
; 3289 : }
; 3290 : 
; 3291 : /**
; 3292 :  * xmlSchemaNewFacet:
; 3293 :  *
; 3294 :  * Allocate a new Facet structure.
; 3295 :  *
; 3296 :  * Returns the newly allocated structure or NULL in case or error
; 3297 :  */
; 3298 : xmlSchemaFacetPtr
; 3299 : xmlSchemaNewFacet(void)
; 3300 : {
; 3301 :     xmlSchemaFacetPtr ret;
; 3302 : 
; 3303 :     ret = (xmlSchemaFacetPtr) xmlMalloc(sizeof(xmlSchemaFacet));
; 3304 :     if (ret == NULL) {
; 3305 :         return (NULL);
; 3306 :     }
; 3307 :     memset(ret, 0, sizeof(xmlSchemaFacet));
; 3308 : 
; 3309 :     return (ret);
; 3310 : }
; 3311 : 
; 3312 : /**
; 3313 :  * xmlSchemaNewAnnot:
; 3314 :  * @ctxt:  a schema validation context
; 3315 :  * @node:  a node
; 3316 :  *
; 3317 :  * Allocate a new annotation structure.
; 3318 :  *
; 3319 :  * Returns the newly allocated structure or NULL in case or error
; 3320 :  */
; 3321 : static xmlSchemaAnnotPtr
; 3322 : xmlSchemaNewAnnot(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node)
; 3323 : {
; 3324 :     xmlSchemaAnnotPtr ret;
; 3325 : 
; 3326 :     ret = (xmlSchemaAnnotPtr) xmlMalloc(sizeof(xmlSchemaAnnot));
; 3327 :     if (ret == NULL) {
; 3328 :         xmlSchemaPErrMemory(ctxt, "allocating annotation", node);
; 3329 :         return (NULL);
; 3330 :     }
; 3331 :     memset(ret, 0, sizeof(xmlSchemaAnnot));
; 3332 :     ret->content = node;
; 3333 :     return (ret);
; 3334 : }
; 3335 : 
; 3336 : static xmlSchemaItemListPtr
; 3337 : xmlSchemaItemListCreate(void)
; 3338 : {
; 3339 :     xmlSchemaItemListPtr ret;
; 3340 : 
; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));
; 3342 :     if (ret == NULL) {
; 3343 : 	xmlSchemaPErrMemory(NULL,
; 3344 : 	    "allocating an item list structure", NULL);
; 3345 : 	return (NULL);
; 3346 :     }
; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));
; 3348 :     return (ret);
; 3349 : }
; 3350 : 
; 3351 : static void
; 3352 : xmlSchemaItemListClear(xmlSchemaItemListPtr list)
; 3353 : {
; 3354 :     if (list->items != NULL) {
; 3355 : 	xmlFree(list->items);
; 3356 : 	list->items = NULL;
; 3357 :     }
; 3358 :     list->nbItems = 0;
; 3359 :     list->sizeItems = 0;
; 3360 : }
; 3361 : 
; 3362 : static int
; 3363 : xmlSchemaItemListAdd(xmlSchemaItemListPtr list, void *item)
; 3364 : {
; 3365 :     if (list->items == NULL) {
; 3366 : 	list->items = (void **) xmlMalloc(
; 3367 : 	    20 * sizeof(void *));
; 3368 : 	if (list->items == NULL) {
; 3369 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3370 : 	    return(-1);
; 3371 : 	}
; 3372 : 	list->sizeItems = 20;
; 3373 :     } else if (list->sizeItems <= list->nbItems) {
; 3374 : 	list->sizeItems *= 2;
; 3375 : 	list->items = (void **) xmlRealloc(list->items,
; 3376 : 	    list->sizeItems * sizeof(void *));
; 3377 : 	if (list->items == NULL) {
; 3378 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3379 : 	    list->sizeItems = 0;
; 3380 : 	    return(-1);
; 3381 : 	}
; 3382 :     }
; 3383 :     list->items[list->nbItems++] = item;
; 3384 :     return(0);
; 3385 : }
; 3386 : 
; 3387 : static int
; 3388 : xmlSchemaItemListAddSize(xmlSchemaItemListPtr list,
; 3389 : 			 int initialSize,
; 3390 : 			 void *item)
; 3391 : {
; 3392 :     if (list->items == NULL) {
; 3393 : 	if (initialSize <= 0)
; 3394 : 	    initialSize = 1;
; 3395 : 	list->items = (void **) xmlMalloc(
; 3396 : 	    initialSize * sizeof(void *));
; 3397 : 	if (list->items == NULL) {
; 3398 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3399 : 	    return(-1);
; 3400 : 	}
; 3401 : 	list->sizeItems = initialSize;
; 3402 :     } else if (list->sizeItems <= list->nbItems) {
; 3403 : 	list->sizeItems *= 2;
; 3404 : 	list->items = (void **) xmlRealloc(list->items,
; 3405 : 	    list->sizeItems * sizeof(void *));
; 3406 : 	if (list->items == NULL) {
; 3407 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3408 : 	    list->sizeItems = 0;
; 3409 : 	    return(-1);
; 3410 : 	}
; 3411 :     }
; 3412 :     list->items[list->nbItems++] = item;
; 3413 :     return(0);
; 3414 : }
; 3415 : 
; 3416 : static int
; 3417 : xmlSchemaItemListInsert(xmlSchemaItemListPtr list, void *item, int idx)
; 3418 : {
; 3419 :     if (list->items == NULL) {
; 3420 : 	list->items = (void **) xmlMalloc(
; 3421 : 	    20 * sizeof(void *));
; 3422 : 	if (list->items == NULL) {
; 3423 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3424 : 	    return(-1);
; 3425 : 	}
; 3426 : 	list->sizeItems = 20;
; 3427 :     } else if (list->sizeItems <= list->nbItems) {
; 3428 : 	list->sizeItems *= 2;
; 3429 : 	list->items = (void **) xmlRealloc(list->items,
; 3430 : 	    list->sizeItems * sizeof(void *));
; 3431 : 	if (list->items == NULL) {
; 3432 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3433 : 	    list->sizeItems = 0;
; 3434 : 	    return(-1);
; 3435 : 	}
; 3436 :     }
; 3437 :     /*
; 3438 :     * Just append if the index is greater/equal than the item count.
; 3439 :     */
; 3440 :     if (idx >= list->nbItems) {
; 3441 : 	list->items[list->nbItems++] = item;
; 3442 :     } else {
; 3443 : 	int i;
; 3444 : 	for (i = list->nbItems; i > idx; i--)
; 3445 : 	    list->items[i] = list->items[i-1];
; 3446 : 	list->items[idx] = item;
; 3447 : 	list->nbItems++;
; 3448 :     }
; 3449 :     return(0);
; 3450 : }
; 3451 : 
; 3452 : #if 0 /* enable if ever needed */
; 3453 : static int
; 3454 : xmlSchemaItemListInsertSize(xmlSchemaItemListPtr list,
; 3455 : 			    int initialSize,
; 3456 : 			    void *item,
; 3457 : 			    int idx)
; 3458 : {
; 3459 :     if (list->items == NULL) {
; 3460 : 	if (initialSize <= 0)
; 3461 : 	    initialSize = 1;
; 3462 : 	list->items = (void **) xmlMalloc(
; 3463 : 	    initialSize * sizeof(void *));
; 3464 : 	if (list->items == NULL) {
; 3465 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3466 : 	    return(-1);
; 3467 : 	}
; 3468 : 	list->sizeItems = initialSize;
; 3469 :     } else if (list->sizeItems <= list->nbItems) {
; 3470 : 	list->sizeItems *= 2;
; 3471 : 	list->items = (void **) xmlRealloc(list->items,
; 3472 : 	    list->sizeItems * sizeof(void *));
; 3473 : 	if (list->items == NULL) {
; 3474 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3475 : 	    list->sizeItems = 0;
; 3476 : 	    return(-1);
; 3477 : 	}
; 3478 :     }
; 3479 :     /*
; 3480 :     * Just append if the index is greater/equal than the item count.
; 3481 :     */
; 3482 :     if (idx >= list->nbItems) {
; 3483 : 	list->items[list->nbItems++] = item;
; 3484 :     } else {
; 3485 : 	int i;
; 3486 : 	for (i = list->nbItems; i > idx; i--)
; 3487 : 	    list->items[i] = list->items[i-1];
; 3488 : 	list->items[idx] = item;
; 3489 : 	list->nbItems++;
; 3490 :     }
; 3491 :     return(0);
; 3492 : }
; 3493 : #endif
; 3494 : 
; 3495 : static int
; 3496 : xmlSchemaItemListRemove(xmlSchemaItemListPtr list, int idx)
; 3497 : {
; 3498 :     int i;
; 3499 :     if ((list->items == NULL) || (idx >= list->nbItems)) {
; 3500 : 	xmlSchemaPSimpleErr("Internal error: xmlSchemaItemListRemove, "
; 3501 : 	    "index error.\n");
; 3502 : 	return(-1);
; 3503 :     }
; 3504 : 
; 3505 :     if (list->nbItems == 1) {
; 3506 : 	/* TODO: Really free the list? */
; 3507 : 	xmlFree(list->items);
; 3508 : 	list->items = NULL;
; 3509 : 	list->nbItems = 0;
; 3510 : 	list->sizeItems = 0;
; 3511 :     } else if (list->nbItems -1 == idx) {
; 3512 : 	list->nbItems--;
; 3513 :     } else {
; 3514 : 	for (i = idx; i < list->nbItems -1; i++)
; 3515 : 	    list->items[i] = list->items[i+1];
; 3516 : 	list->nbItems--;
; 3517 :     }
; 3518 :     return(0);
; 3519 : }
; 3520 : 
; 3521 : /**
; 3522 :  * xmlSchemaItemListFree:
; 3523 :  * @annot:  a schema type structure
; 3524 :  *
; 3525 :  * Deallocate a annotation structure
; 3526 :  */
; 3527 : static void
; 3528 : xmlSchemaItemListFree(xmlSchemaItemListPtr list)
; 3529 : {
; 3530 :     if (list == NULL)
; 3531 : 	return;
; 3532 :     if (list->items != NULL)
; 3533 : 	xmlFree(list->items);
; 3534 :     xmlFree(list);
; 3535 : }
; 3536 : 
; 3537 : static void
; 3538 : xmlSchemaBucketFree(xmlSchemaBucketPtr bucket)
; 3539 : {
; 3540 :     if (bucket == NULL)
; 3541 : 	return;
; 3542 :     if (bucket->globals != NULL) {
; 3543 : 	xmlSchemaComponentListFree(bucket->globals);
; 3544 : 	xmlSchemaItemListFree(bucket->globals);
; 3545 :     }
; 3546 :     if (bucket->locals != NULL) {
; 3547 : 	xmlSchemaComponentListFree(bucket->locals);
; 3548 : 	xmlSchemaItemListFree(bucket->locals);
; 3549 :     }
; 3550 :     if (bucket->relations != NULL) {
; 3551 : 	xmlSchemaSchemaRelationPtr prev, cur = bucket->relations;
; 3552 : 	do {
; 3553 : 	    prev = cur;
; 3554 : 	    cur = cur->next;
; 3555 : 	    xmlFree(prev);
; 3556 : 	} while (cur != NULL);
; 3557 :     }
; 3558 :     if ((! bucket->preserveDoc) && (bucket->doc != NULL)) {
; 3559 : 	xmlFreeDoc(bucket->doc);
; 3560 :     }
; 3561 :     if (bucket->type == XML_SCHEMA_SCHEMA_IMPORT) {
; 3562 : 	if (WXS_IMPBUCKET(bucket)->schema != NULL)
; 3563 : 	    xmlSchemaFree(WXS_IMPBUCKET(bucket)->schema);
; 3564 :     }
; 3565 :     xmlFree(bucket);
; 3566 : }
; 3567 : 
; 3568 : static void
; 3569 : xmlSchemaBucketFreeEntry(void *bucket, const xmlChar *name ATTRIBUTE_UNUSED)
; 3570 : {
; 3571 :     xmlSchemaBucketFree((xmlSchemaBucketPtr) bucket);
; 3572 : }
; 3573 : 
; 3574 : static xmlSchemaBucketPtr
; 3575 : xmlSchemaBucketCreate(xmlSchemaParserCtxtPtr pctxt,
; 3576 : 			 int type, const xmlChar *targetNamespace)
; 3577 : {
; 3578 :     xmlSchemaBucketPtr ret;
; 3579 :     int size;
; 3580 :     xmlSchemaPtr mainSchema;
; 3581 : 
; 3582 :     if (WXS_CONSTRUCTOR(pctxt)->mainSchema == NULL) {
; 3583 : 	PERROR_INT("xmlSchemaBucketCreate",
; 3584 : 	    "no main schema on constructor");
; 3585 : 	return(NULL);
; 3586 :     }
; 3587 :     mainSchema = WXS_CONSTRUCTOR(pctxt)->mainSchema;
; 3588 :     /* Create the schema bucket. */
; 3589 :     if (WXS_IS_BUCKET_INCREDEF(type))
; 3590 : 	size = sizeof(xmlSchemaInclude);
; 3591 :     else
; 3592 : 	size = sizeof(xmlSchemaImport);
; 3593 :     ret = (xmlSchemaBucketPtr) xmlMalloc(size);
; 3594 :     if (ret == NULL) {
; 3595 : 	xmlSchemaPErrMemory(NULL, "allocating schema bucket", NULL);
; 3596 : 	return(NULL);
; 3597 :     }
; 3598 :     memset(ret, 0, size);
; 3599 :     ret->targetNamespace = targetNamespace;
; 3600 :     ret->type = type;
; 3601 :     ret->globals = xmlSchemaItemListCreate();
; 3602 :     if (ret->globals == NULL) {
; 3603 : 	xmlFree(ret);
; 3604 : 	return(NULL);
; 3605 :     }
; 3606 :     ret->locals = xmlSchemaItemListCreate();
; 3607 :     if (ret->locals == NULL) {
; 3608 : 	xmlFree(ret);
; 3609 : 	return(NULL);
; 3610 :     }
; 3611 :     /*
; 3612 :     * The following will assure that only the first bucket is marked as
; 3613 :     * XML_SCHEMA_SCHEMA_MAIN and it points to the *main* schema.
; 3614 :     * For each following import buckets an xmlSchema will be created.
; 3615 :     * An xmlSchema will be created for every distinct targetNamespace.
; 3616 :     * We assign the targetNamespace to the schemata here.
; 3617 :     */
; 3618 :     if (! WXS_HAS_BUCKETS(pctxt)) {
; 3619 : 	if (WXS_IS_BUCKET_INCREDEF(type)) {
; 3620 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3621 : 		"first bucket but it's an include or redefine");
; 3622 : 	    xmlSchemaBucketFree(ret);
; 3623 : 	    return(NULL);
; 3624 : 	}
; 3625 : 	/* Force the type to be XML_SCHEMA_SCHEMA_MAIN. */
; 3626 : 	ret->type = XML_SCHEMA_SCHEMA_MAIN;
; 3627 : 	/* Point to the *main* schema. */
; 3628 : 	WXS_CONSTRUCTOR(pctxt)->mainBucket = ret;
; 3629 : 	WXS_IMPBUCKET(ret)->schema = mainSchema;
; 3630 : 	/*
; 3631 : 	* Ensure that the main schema gets a targetNamespace.
; 3632 : 	*/
; 3633 : 	mainSchema->targetNamespace = targetNamespace;
; 3634 :     } else {
; 3635 : 	if (type == XML_SCHEMA_SCHEMA_MAIN) {
; 3636 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3637 : 		"main bucket but it's not the first one");
; 3638 : 	    xmlSchemaBucketFree(ret);
; 3639 : 	    return(NULL);
; 3640 : 	} else if (type == XML_SCHEMA_SCHEMA_IMPORT) {
; 3641 : 	    /*
; 3642 : 	    * Create a schema for imports and assign the
; 3643 : 	    * targetNamespace.
; 3644 : 	    */
; 3645 : 	    WXS_IMPBUCKET(ret)->schema = xmlSchemaNewSchema(pctxt);
; 3646 : 	    if (WXS_IMPBUCKET(ret)->schema == NULL) {
; 3647 : 		xmlSchemaBucketFree(ret);
; 3648 : 		return(NULL);
; 3649 : 	    }
; 3650 : 	    WXS_IMPBUCKET(ret)->schema->targetNamespace = targetNamespace;
; 3651 : 	}
; 3652 :     }
; 3653 :     if (WXS_IS_BUCKET_IMPMAIN(type)) {
; 3654 : 	int res;
; 3655 : 	/*
; 3656 : 	* Imports go into the "schemasImports" slot of the main *schema*.
; 3657 : 	* Note that we create an import entry for the main schema as well; i.e.,
; 3658 : 	* even if there's only one schema, we'll get an import.
; 3659 : 	*/
; 3660 : 	if (mainSchema->schemasImports == NULL) {
; 3661 : 	    mainSchema->schemasImports = xmlHashCreateDict(5,
; 3662 : 		WXS_CONSTRUCTOR(pctxt)->dict);
; 3663 : 	    if (mainSchema->schemasImports == NULL) {
; 3664 : 		xmlSchemaBucketFree(ret);
; 3665 : 		return(NULL);
; 3666 : 	    }
; 3667 : 	}
; 3668 : 	if (targetNamespace == NULL)
; 3669 : 	    res = xmlHashAddEntry(mainSchema->schemasImports,
; 3670 : 		XML_SCHEMAS_NO_NAMESPACE, ret);
; 3671 : 	else
; 3672 : 	    res = xmlHashAddEntry(mainSchema->schemasImports,
; 3673 : 		targetNamespace, ret);
; 3674 : 	if (res != 0) {
; 3675 : 	    PERROR_INT("xmlSchemaBucketCreate",
; 3676 : 		"failed to add the schema bucket to the hash");
; 3677 : 	    xmlSchemaBucketFree(ret);
; 3678 : 	    return(NULL);
; 3679 : 	}
; 3680 :     } else {
; 3681 : 	/* Set the @ownerImport of an include bucket. */
; 3682 : 	if (WXS_IS_BUCKET_IMPMAIN(WXS_CONSTRUCTOR(pctxt)->bucket->type))
; 3683 : 	    WXS_INCBUCKET(ret)->ownerImport =
; 3684 : 		WXS_IMPBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket);
; 3685 : 	else
; 3686 : 	    WXS_INCBUCKET(ret)->ownerImport =
; 3687 : 		WXS_INCBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket)->ownerImport;
; 3688 : 
; 3689 : 	/* Includes got into the "includes" slot of the *main* schema. */
; 3690 : 	if (mainSchema->includes == NULL) {
; 3691 : 	    mainSchema->includes = xmlSchemaItemListCreate();
; 3692 : 	    if (mainSchema->includes == NULL) {
; 3693 : 		xmlSchemaBucketFree(ret);
; 3694 : 		return(NULL);
; 3695 : 	    }
; 3696 : 	}
; 3697 : 	xmlSchemaItemListAdd(mainSchema->includes, ret);
; 3698 :     }
; 3699 :     /*
; 3700 :     * Add to list of all buckets; this is used for lookup
; 3701 :     * during schema construction time only.
; 3702 :     */
; 3703 :     if (xmlSchemaItemListAdd(WXS_CONSTRUCTOR(pctxt)->buckets, ret) == -1)
; 3704 : 	return(NULL);
; 3705 :     return(ret);
; 3706 : }
; 3707 : 
; 3708 : static int
; 3709 : xmlSchemaAddItemSize(xmlSchemaItemListPtr *list, int initialSize, void *item)
; 3710 : {
; 3711 :     if (*list == NULL) {
; 3712 : 	*list = xmlSchemaItemListCreate();
; 3713 : 	if (*list == NULL)
; 3714 : 	    return(-1);
; 3715 :     }
; 3716 :     xmlSchemaItemListAddSize(*list, initialSize, item);
; 3717 :     return(0);
; 3718 : }
; 3719 : 
; 3720 : /**
; 3721 :  * xmlSchemaFreeAnnot:
; 3722 :  * @annot:  a schema type structure
; 3723 :  *
; 3724 :  * Deallocate a annotation structure
; 3725 :  */
; 3726 : static void
; 3727 : xmlSchemaFreeAnnot(xmlSchemaAnnotPtr annot)
; 3728 : {
; 3729 :     if (annot == NULL)
; 3730 :         return;
; 3731 :     if (annot->next == NULL) {
; 3732 : 	xmlFree(annot);
; 3733 :     } else {
; 3734 : 	xmlSchemaAnnotPtr prev;
; 3735 : 
; 3736 : 	do {
; 3737 : 	    prev = annot;
; 3738 : 	    annot = annot->next;
; 3739 : 	    xmlFree(prev);
; 3740 : 	} while (annot != NULL);
; 3741 :     }
; 3742 : }
; 3743 : 
; 3744 : /**
; 3745 :  * xmlSchemaFreeNotation:
; 3746 :  * @schema:  a schema notation structure
; 3747 :  *
; 3748 :  * Deallocate a Schema Notation structure.
; 3749 :  */
; 3750 : static void
; 3751 : xmlSchemaFreeNotation(xmlSchemaNotationPtr nota)
; 3752 : {
; 3753 :     if (nota == NULL)
; 3754 :         return;
; 3755 :     xmlFree(nota);
; 3756 : }
; 3757 : 
; 3758 : /**
; 3759 :  * xmlSchemaFreeAttribute:
; 3760 :  * @attr:  an attribute declaration
; 3761 :  *
; 3762 :  * Deallocates an attribute declaration structure.
; 3763 :  */
; 3764 : static void
; 3765 : xmlSchemaFreeAttribute(xmlSchemaAttributePtr attr)
; 3766 : {
; 3767 :     if (attr == NULL)
; 3768 :         return;
; 3769 :     if (attr->annot != NULL)
; 3770 : 	xmlSchemaFreeAnnot(attr->annot);
; 3771 :     if (attr->defVal != NULL)
; 3772 : 	xmlSchemaFreeValue(attr->defVal);
; 3773 :     xmlFree(attr);
; 3774 : }
; 3775 : 
; 3776 : /**
; 3777 :  * xmlSchemaFreeAttributeUse:
; 3778 :  * @use:  an attribute use
; 3779 :  *
; 3780 :  * Deallocates an attribute use structure.
; 3781 :  */
; 3782 : static void
; 3783 : xmlSchemaFreeAttributeUse(xmlSchemaAttributeUsePtr use)
; 3784 : {
; 3785 :     if (use == NULL)
; 3786 :         return;
; 3787 :     if (use->annot != NULL)
; 3788 : 	xmlSchemaFreeAnnot(use->annot);
; 3789 :     if (use->defVal != NULL)
; 3790 : 	xmlSchemaFreeValue(use->defVal);
; 3791 :     xmlFree(use);
; 3792 : }
; 3793 : 
; 3794 : /**
; 3795 :  * xmlSchemaFreeAttributeUseProhib:
; 3796 :  * @prohib:  an attribute use prohibition
; 3797 :  *
; 3798 :  * Deallocates an attribute use structure.
; 3799 :  */
; 3800 : static void
; 3801 : xmlSchemaFreeAttributeUseProhib(xmlSchemaAttributeUseProhibPtr prohib)
; 3802 : {
; 3803 :     if (prohib == NULL)
; 3804 :         return;
; 3805 :     xmlFree(prohib);
; 3806 : }
; 3807 : 
; 3808 : /**
; 3809 :  * xmlSchemaFreeWildcardNsSet:
; 3810 :  * set:  a schema wildcard namespace
; 3811 :  *
; 3812 :  * Deallocates a list of wildcard constraint structures.
; 3813 :  */
; 3814 : static void
; 3815 : xmlSchemaFreeWildcardNsSet(xmlSchemaWildcardNsPtr set)
; 3816 : {
; 3817 :     xmlSchemaWildcardNsPtr next;
; 3818 : 
; 3819 :     while (set != NULL) {
; 3820 : 	next = set->next;
; 3821 : 	xmlFree(set);
; 3822 : 	set = next;
; 3823 :     }
; 3824 : }
; 3825 : 
; 3826 : /**
; 3827 :  * xmlSchemaFreeWildcard:
; 3828 :  * @wildcard:  a wildcard structure
; 3829 :  *
; 3830 :  * Deallocates a wildcard structure.
; 3831 :  */
; 3832 : void
; 3833 : xmlSchemaFreeWildcard(xmlSchemaWildcardPtr wildcard)
; 3834 : {
; 3835 :     if (wildcard == NULL)
; 3836 :         return;
; 3837 :     if (wildcard->annot != NULL)
; 3838 :         xmlSchemaFreeAnnot(wildcard->annot);
; 3839 :     if (wildcard->nsSet != NULL)
; 3840 : 	xmlSchemaFreeWildcardNsSet(wildcard->nsSet);
; 3841 :     if (wildcard->negNsSet != NULL)
; 3842 : 	xmlFree(wildcard->negNsSet);
; 3843 :     xmlFree(wildcard);
; 3844 : }
; 3845 : 
; 3846 : /**
; 3847 :  * xmlSchemaFreeAttributeGroup:
; 3848 :  * @schema:  a schema attribute group structure
; 3849 :  *
; 3850 :  * Deallocate a Schema Attribute Group structure.
; 3851 :  */
; 3852 : static void
; 3853 : xmlSchemaFreeAttributeGroup(xmlSchemaAttributeGroupPtr attrGr)
; 3854 : {
; 3855 :     if (attrGr == NULL)
; 3856 :         return;
; 3857 :     if (attrGr->annot != NULL)
; 3858 :         xmlSchemaFreeAnnot(attrGr->annot);
; 3859 :     if (attrGr->attrUses != NULL)
; 3860 : 	xmlSchemaItemListFree(WXS_LIST_CAST attrGr->attrUses);
; 3861 :     xmlFree(attrGr);
; 3862 : }
; 3863 : 
; 3864 : /**
; 3865 :  * xmlSchemaFreeQNameRef:
; 3866 :  * @item: a QName reference structure
; 3867 :  *
; 3868 :  * Deallocatea a QName reference structure.
; 3869 :  */
; 3870 : static void
; 3871 : xmlSchemaFreeQNameRef(xmlSchemaQNameRefPtr item)
; 3872 : {
; 3873 :     xmlFree(item);
; 3874 : }
; 3875 : 
; 3876 : /**
; 3877 :  * xmlSchemaFreeTypeLinkList:
; 3878 :  * @alink: a type link
; 3879 :  *
; 3880 :  * Deallocate a list of types.
; 3881 :  */
; 3882 : static void
; 3883 : xmlSchemaFreeTypeLinkList(xmlSchemaTypeLinkPtr link)
; 3884 : {
; 3885 :     xmlSchemaTypeLinkPtr next;
; 3886 : 
; 3887 :     while (link != NULL) {
; 3888 : 	next = link->next;
; 3889 : 	xmlFree(link);
; 3890 : 	link = next;
; 3891 :     }
; 3892 : }
; 3893 : 
; 3894 : static void
; 3895 : xmlSchemaFreeIDCStateObjList(xmlSchemaIDCStateObjPtr sto)
; 3896 : {
; 3897 :     xmlSchemaIDCStateObjPtr next;
; 3898 :     while (sto != NULL) {
; 3899 : 	next = sto->next;
; 3900 : 	if (sto->history != NULL)
; 3901 : 	    xmlFree(sto->history);
; 3902 : 	if (sto->xpathCtxt != NULL)
; 3903 : 	    xmlFreeStreamCtxt((xmlStreamCtxtPtr) sto->xpathCtxt);
; 3904 : 	xmlFree(sto);
; 3905 : 	sto = next;
; 3906 :     }
; 3907 : }
; 3908 : 
; 3909 : /**
; 3910 :  * xmlSchemaFreeIDC:
; 3911 :  * @idc: a identity-constraint definition
; 3912 :  *
; 3913 :  * Deallocates an identity-constraint definition.
; 3914 :  */
; 3915 : static void
; 3916 : xmlSchemaFreeIDC(xmlSchemaIDCPtr idcDef)
; 3917 : {
; 3918 :     xmlSchemaIDCSelectPtr cur, prev;
; 3919 : 
; 3920 :     if (idcDef == NULL)
; 3921 : 	return;
; 3922 :     if (idcDef->annot != NULL)
; 3923 :         xmlSchemaFreeAnnot(idcDef->annot);
; 3924 :     /* Selector */
; 3925 :     if (idcDef->selector != NULL) {
; 3926 : 	if (idcDef->selector->xpathComp != NULL)
; 3927 : 	    xmlFreePattern((xmlPatternPtr) idcDef->selector->xpathComp);
; 3928 : 	xmlFree(idcDef->selector);
; 3929 :     }
; 3930 :     /* Fields */
; 3931 :     if (idcDef->fields != NULL) {
; 3932 : 	cur = idcDef->fields;
; 3933 : 	do {
; 3934 : 	    prev = cur;
; 3935 : 	    cur = cur->next;
; 3936 : 	    if (prev->xpathComp != NULL)
; 3937 : 		xmlFreePattern((xmlPatternPtr) prev->xpathComp);
; 3938 : 	    xmlFree(prev);
; 3939 : 	} while (cur != NULL);
; 3940 :     }
; 3941 :     xmlFree(idcDef);
; 3942 : }
; 3943 : 
; 3944 : /**
; 3945 :  * xmlSchemaFreeElement:
; 3946 :  * @schema:  a schema element structure
; 3947 :  *
; 3948 :  * Deallocate a Schema Element structure.
; 3949 :  */
; 3950 : static void
; 3951 : xmlSchemaFreeElement(xmlSchemaElementPtr elem)
; 3952 : {
; 3953 :     if (elem == NULL)
; 3954 :         return;
; 3955 :     if (elem->annot != NULL)
; 3956 :         xmlSchemaFreeAnnot(elem->annot);
; 3957 :     if (elem->contModel != NULL)
; 3958 :         xmlRegFreeRegexp(elem->contModel);
; 3959 :     if (elem->defVal != NULL)
; 3960 : 	xmlSchemaFreeValue(elem->defVal);
; 3961 :     xmlFree(elem);
; 3962 : }
; 3963 : 
; 3964 : /**
; 3965 :  * xmlSchemaFreeFacet:
; 3966 :  * @facet:  a schema facet structure
; 3967 :  *
; 3968 :  * Deallocate a Schema Facet structure.
; 3969 :  */
; 3970 : void
; 3971 : xmlSchemaFreeFacet(xmlSchemaFacetPtr facet)
; 3972 : {
; 3973 :     if (facet == NULL)
; 3974 :         return;
; 3975 :     if (facet->val != NULL)
; 3976 :         xmlSchemaFreeValue(facet->val);
; 3977 :     if (facet->regexp != NULL)
; 3978 :         xmlRegFreeRegexp(facet->regexp);
; 3979 :     if (facet->annot != NULL)
; 3980 :         xmlSchemaFreeAnnot(facet->annot);
; 3981 :     xmlFree(facet);
; 3982 : }
; 3983 : 
; 3984 : /**
; 3985 :  * xmlSchemaFreeType:
; 3986 :  * @type:  a schema type structure
; 3987 :  *
; 3988 :  * Deallocate a Schema Type structure.
; 3989 :  */
; 3990 : void
; 3991 : xmlSchemaFreeType(xmlSchemaTypePtr type)
; 3992 : {
; 3993 :     if (type == NULL)
; 3994 :         return;
; 3995 :     if (type->annot != NULL)
; 3996 :         xmlSchemaFreeAnnot(type->annot);
; 3997 :     if (type->facets != NULL) {
; 3998 :         xmlSchemaFacetPtr facet, next;
; 3999 : 
; 4000 :         facet = type->facets;
; 4001 :         while (facet != NULL) {
; 4002 :             next = facet->next;
; 4003 :             xmlSchemaFreeFacet(facet);
; 4004 :             facet = next;
; 4005 :         }
; 4006 :     }
; 4007 :     if (type->attrUses != NULL)
; 4008 : 	xmlSchemaItemListFree((xmlSchemaItemListPtr) type->attrUses);
; 4009 :     if (type->memberTypes != NULL)
; 4010 : 	xmlSchemaFreeTypeLinkList(type->memberTypes);
; 4011 :     if (type->facetSet != NULL) {
; 4012 : 	xmlSchemaFacetLinkPtr next, link;
; 4013 : 
; 4014 : 	link = type->facetSet;
; 4015 : 	do {
; 4016 : 	    next = link->next;
; 4017 : 	    xmlFree(link);
; 4018 : 	    link = next;
; 4019 : 	} while (link != NULL);
; 4020 :     }
; 4021 :     if (type->contModel != NULL)
; 4022 :         xmlRegFreeRegexp(type->contModel);
; 4023 :     xmlFree(type);
; 4024 : }
; 4025 : 
; 4026 : /**
; 4027 :  * xmlSchemaFreeModelGroupDef:
; 4028 :  * @item:  a schema model group definition
; 4029 :  *
; 4030 :  * Deallocates a schema model group definition.
; 4031 :  */
; 4032 : static void
; 4033 : xmlSchemaFreeModelGroupDef(xmlSchemaModelGroupDefPtr item)
; 4034 : {
; 4035 :     if (item->annot != NULL)
; 4036 : 	xmlSchemaFreeAnnot(item->annot);
; 4037 :     xmlFree(item);
; 4038 : }
; 4039 : 
; 4040 : /**
; 4041 :  * xmlSchemaFreeModelGroup:
; 4042 :  * @item:  a schema model group
; 4043 :  *
; 4044 :  * Deallocates a schema model group structure.
; 4045 :  */
; 4046 : static void
; 4047 : xmlSchemaFreeModelGroup(xmlSchemaModelGroupPtr item)
; 4048 : {
; 4049 :     if (item->annot != NULL)
; 4050 : 	xmlSchemaFreeAnnot(item->annot);
; 4051 :     xmlFree(item);
; 4052 : }
; 4053 : 
; 4054 : static void
; 4055 : xmlSchemaComponentListFree(xmlSchemaItemListPtr list)
; 4056 : {
; 4057 :     if ((list == NULL) || (list->nbItems == 0))
; 4058 : 	return;
; 4059 :     {
; 4060 : 	xmlSchemaTreeItemPtr item;
; 4061 : 	xmlSchemaTreeItemPtr *items = (xmlSchemaTreeItemPtr *) list->items;
; 4062 : 	int i;
; 4063 : 
; 4064 : 	for (i = 0; i < list->nbItems; i++) {
; 4065 : 	    item = items[i];
; 4066 : 	    if (item == NULL)
; 4067 : 		continue;
; 4068 : 	    switch (item->type) {
; 4069 : 		case XML_SCHEMA_TYPE_SIMPLE:
; 4070 : 		case XML_SCHEMA_TYPE_COMPLEX:
; 4071 : 		    xmlSchemaFreeType((xmlSchemaTypePtr) item);
; 4072 : 		    break;
; 4073 : 		case XML_SCHEMA_TYPE_ATTRIBUTE:
; 4074 : 		    xmlSchemaFreeAttribute((xmlSchemaAttributePtr) item);
; 4075 : 		    break;
; 4076 : 		case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
; 4077 : 		    xmlSchemaFreeAttributeUse((xmlSchemaAttributeUsePtr) item);
; 4078 : 		    break;
; 4079 : 		case XML_SCHEMA_EXTRA_ATTR_USE_PROHIB:
; 4080 : 		    xmlSchemaFreeAttributeUseProhib(
; 4081 : 			(xmlSchemaAttributeUseProhibPtr) item);
; 4082 : 		    break;
; 4083 : 		case XML_SCHEMA_TYPE_ELEMENT:
; 4084 : 		    xmlSchemaFreeElement((xmlSchemaElementPtr) item);
; 4085 : 		    break;
; 4086 : 		case XML_SCHEMA_TYPE_PARTICLE:
; 4087 : 		    if (item->annot != NULL)
; 4088 : 			xmlSchemaFreeAnnot(item->annot);
; 4089 : 		    xmlFree(item);
; 4090 : 		    break;
; 4091 : 		case XML_SCHEMA_TYPE_SEQUENCE:
; 4092 : 		case XML_SCHEMA_TYPE_CHOICE:
; 4093 : 		case XML_SCHEMA_TYPE_ALL:
; 4094 : 		    xmlSchemaFreeModelGroup((xmlSchemaModelGroupPtr) item);
; 4095 : 		    break;
; 4096 : 		case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 4097 : 		    xmlSchemaFreeAttributeGroup(
; 4098 : 			(xmlSchemaAttributeGroupPtr) item);
; 4099 : 		    break;
; 4100 : 		case XML_SCHEMA_TYPE_GROUP:
; 4101 : 		    xmlSchemaFreeModelGroupDef(
; 4102 : 			(xmlSchemaModelGroupDefPtr) item);
; 4103 : 		    break;
; 4104 : 		case XML_SCHEMA_TYPE_ANY:
; 4105 : 		case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:
; 4106 : 		    xmlSchemaFreeWildcard((xmlSchemaWildcardPtr) item);
; 4107 : 		    break;
; 4108 : 		case XML_SCHEMA_TYPE_IDC_KEY:
; 4109 : 		case XML_SCHEMA_TYPE_IDC_UNIQUE:
; 4110 : 		case XML_SCHEMA_TYPE_IDC_KEYREF:
; 4111 : 		    xmlSchemaFreeIDC((xmlSchemaIDCPtr) item);
; 4112 : 		    break;
; 4113 : 		case XML_SCHEMA_TYPE_NOTATION:
; 4114 : 		    xmlSchemaFreeNotation((xmlSchemaNotationPtr) item);
; 4115 : 		    break;
; 4116 : 		case XML_SCHEMA_EXTRA_QNAMEREF:
; 4117 : 		    xmlSchemaFreeQNameRef((xmlSchemaQNameRefPtr) item);
; 4118 : 		    break;
; 4119 : 		default: {
; 4120 : 		    /* TODO: This should never be hit. */
; 4121 : 		    xmlSchemaPSimpleInternalErr(NULL,
; 4122 : 			"Internal error: xmlSchemaComponentListFree, "
; 4123 : 			"unexpected component type '%s'\n",
; 4124 : 			(const xmlChar *) WXS_ITEM_TYPE_NAME(item));
; 4125 : 			 }
; 4126 : 		    break;
; 4127 : 	    }
; 4128 : 	}
; 4129 : 	list->nbItems = 0;
; 4130 :     }
; 4131 : }
; 4132 : 
; 4133 : /**
; 4134 :  * xmlSchemaFree:
; 4135 :  * @schema:  a schema structure
; 4136 :  *
; 4137 :  * Deallocate a Schema structure.
; 4138 :  */
; 4139 : void
; 4140 : xmlSchemaFree(xmlSchemaPtr schema)
; 4141 : {
; 4142 :     if (schema == NULL)
; 4143 :         return;
; 4144 :     /* @volatiles is not used anymore :-/ */
; 4145 :     if (schema->volatiles != NULL)
; 4146 : 	TODO
; 4147 :     /*
; 4148 :     * Note that those slots are not responsible for freeing
; 4149 :     * schema components anymore; this will now be done by
; 4150 :     * the schema buckets.
; 4151 :     */
; 4152 :     if (schema->notaDecl != NULL)
; 4153 :         xmlHashFree(schema->notaDecl, NULL);
; 4154 :     if (schema->attrDecl != NULL)
; 4155 :         xmlHashFree(schema->attrDecl, NULL);
; 4156 :     if (schema->attrgrpDecl != NULL)
; 4157 :         xmlHashFree(schema->attrgrpDecl, NULL);
; 4158 :     if (schema->elemDecl != NULL)
; 4159 :         xmlHashFree(schema->elemDecl, NULL);
; 4160 :     if (schema->typeDecl != NULL)
; 4161 :         xmlHashFree(schema->typeDecl, NULL);
; 4162 :     if (schema->groupDecl != NULL)
; 4163 :         xmlHashFree(schema->groupDecl, NULL);
; 4164 :     if (schema->idcDef != NULL)
; 4165 :         xmlHashFree(schema->idcDef, NULL);
; 4166 : 
; 4167 :     if (schema->schemasImports != NULL)
; 4168 : 	xmlHashFree(schema->schemasImports, xmlSchemaBucketFreeEntry);
; 4169 :     if (schema->includes != NULL) {
; 4170 : 	xmlSchemaItemListPtr list = (xmlSchemaItemListPtr) schema->includes;
; 4171 : 	int i;
; 4172 : 	for (i = 0; i < list->nbItems; i++) {
; 4173 : 	    xmlSchemaBucketFree((xmlSchemaBucketPtr) list->items[i]);
; 4174 : 	}
; 4175 : 	xmlSchemaItemListFree(list);
; 4176 :     }
; 4177 :     if (schema->annot != NULL)
; 4178 :         xmlSchemaFreeAnnot(schema->annot);
; 4179 :     /* Never free the doc here, since this will be done by the buckets. */
; 4180 : 
; 4181 :     xmlDictFree(schema->dict);
; 4182 :     xmlFree(schema);
; 4183 : }
; 4184 : 
; 4185 : /************************************************************************
; 4186 :  *									*
; 4187 :  *			Debug functions					*
; 4188 :  *									*
; 4189 :  ************************************************************************/
; 4190 : 
; 4191 : #ifdef LIBXML_OUTPUT_ENABLED
; 4192 : 
; 4193 : static void
; 4194 : xmlSchemaTypeDump(xmlSchemaTypePtr type, FILE * output); /* forward */
; 4195 : 
; 4196 : /**
; 4197 :  * xmlSchemaElementDump:
; 4198 :  * @elem:  an element
; 4199 :  * @output:  the file output
; 4200 :  *
; 4201 :  * Dump the element
; 4202 :  */
; 4203 : static void
; 4204 : xmlSchemaElementDump(void *payload, void *data,
; 4205 :                      const xmlChar * name ATTRIBUTE_UNUSED,
; 4206 : 		     const xmlChar * namespace ATTRIBUTE_UNUSED,
; 4207 :                      const xmlChar * context ATTRIBUTE_UNUSED)
; 4208 : {
; 4209 :     xmlSchemaElementPtr elem = (xmlSchemaElementPtr) payload;
; 4210 :     FILE *output = (FILE *) data;
; 4211 :     if (elem == NULL)
; 4212 :         return;
; 4213 : 
; 4214 : 
; 4215 :     fprintf(output, "Element");
; 4216 :     if (elem->flags & XML_SCHEMAS_ELEM_GLOBAL)
; 4217 : 	fprintf(output, " (global)");
; 4218 :     fprintf(output, ": '%s' ", elem->name);
; 4219 :     if (namespace != NULL)
; 4220 : 	fprintf(output, "ns '%s'", namespace);
; 4221 :     fprintf(output, "\n");
; 4222 : #if 0
; 4223 :     if ((elem->minOccurs != 1) || (elem->maxOccurs != 1)) {
; 4224 : 	fprintf(output, "  min %d ", elem->minOccurs);
; 4225 :         if (elem->maxOccurs >= UNBOUNDED)
; 4226 :             fprintf(output, "max: unbounded\n");
; 4227 :         else if (elem->maxOccurs != 1)
; 4228 :             fprintf(output, "max: %d\n", elem->maxOccurs);
; 4229 :         else
; 4230 :             fprintf(output, "\n");
; 4231 :     }
; 4232 : #endif
; 4233 :     /*
; 4234 :     * Misc other properties.
; 4235 :     */
; 4236 :     if ((elem->flags & XML_SCHEMAS_ELEM_NILLABLE) ||
; 4237 : 	(elem->flags & XML_SCHEMAS_ELEM_ABSTRACT) ||
; 4238 : 	(elem->flags & XML_SCHEMAS_ELEM_FIXED) ||
; 4239 : 	(elem->flags & XML_SCHEMAS_ELEM_DEFAULT)) {
; 4240 : 	fprintf(output, "  props: ");
; 4241 : 	if (elem->flags & XML_SCHEMAS_ELEM_FIXED)
; 4242 : 	    fprintf(output, "[fixed] ");
; 4243 : 	if (elem->flags & XML_SCHEMAS_ELEM_DEFAULT)
; 4244 : 	    fprintf(output, "[default] ");
; 4245 : 	if (elem->flags & XML_SCHEMAS_ELEM_ABSTRACT)
; 4246 : 	    fprintf(output, "[abstract] ");
; 4247 : 	if (elem->flags & XML_SCHEMAS_ELEM_NILLABLE)
; 4248 : 	    fprintf(output, "[nillable] ");
; 4249 : 	fprintf(output, "\n");
; 4250 :     }
; 4251 :     /*
; 4252 :     * Default/fixed value.
; 4253 :     */
; 4254 :     if (elem->value != NULL)
; 4255 : 	fprintf(output, "  value: '%s'\n", elem->value);
; 4256 :     /*
; 4257 :     * Type.
; 4258 :     */
; 4259 :     if (elem->namedType != NULL) {
; 4260 : 	fprintf(output, "  type: '%s' ", elem->namedType);
; 4261 : 	if (elem->namedTypeNs != NULL)
; 4262 : 	    fprintf(output, "ns '%s'\n", elem->namedTypeNs);
; 4263 : 	else
; 4264 : 	    fprintf(output, "\n");
; 4265 :     } else if (elem->subtypes != NULL) {
; 4266 : 	/*
; 4267 : 	* Dump local types.
; 4268 : 	*/
; 4269 : 	xmlSchemaTypeDump(elem->subtypes, output);
; 4270 :     }
; 4271 :     /*
; 4272 :     * Substitution group.
; 4273 :     */
; 4274 :     if (elem->substGroup != NULL) {
; 4275 : 	fprintf(output, "  substitutionGroup: '%s' ", elem->substGroup);
; 4276 : 	if (elem->substGroupNs != NULL)
; 4277 : 	    fprintf(output, "ns '%s'\n", elem->substGroupNs);
; 4278 : 	else
; 4279 : 	    fprintf(output, "\n");
; 4280 :     }
; 4281 : }
; 4282 : 
; 4283 : /**
; 4284 :  * xmlSchemaAnnotDump:
; 4285 :  * @output:  the file output
; 4286 :  * @annot:  a annotation
; 4287 :  *
; 4288 :  * Dump the annotation
; 4289 :  */
; 4290 : static void
; 4291 : xmlSchemaAnnotDump(FILE * output, xmlSchemaAnnotPtr annot)
; 4292 : {
; 4293 :     xmlChar *content;
; 4294 : 
; 4295 :     if (annot == NULL)
; 4296 :         return;
; 4297 : 
; 4298 :     content = xmlNodeGetContent(annot->content);
; 4299 :     if (content != NULL) {
; 4300 :         fprintf(output, "  Annot: %s\n", content);
; 4301 :         xmlFree(content);
; 4302 :     } else
; 4303 :         fprintf(output, "  Annot: empty\n");
; 4304 : }
; 4305 : 
; 4306 : /**
; 4307 :  * xmlSchemaContentModelDump:
; 4308 :  * @particle: the schema particle
; 4309 :  * @output: the file output
; 4310 :  * @depth: the depth used for intentation
; 4311 :  *
; 4312 :  * Dump a SchemaType structure
; 4313 :  */
; 4314 : static void
; 4315 : xmlSchemaContentModelDump(xmlSchemaParticlePtr particle, FILE * output, int depth)
; 4316 : {
; 4317 :     xmlChar *str = NULL;
; 4318 :     xmlSchemaTreeItemPtr term;
; 4319 :     char shift[100];
; 4320 :     int i;
; 4321 : 
; 4322 :     if (particle == NULL)
; 4323 : 	return;
; 4324 :     for (i = 0;((i < depth) && (i < 25));i++)
; 4325 :         shift[2 * i] = shift[2 * i + 1] = ' ';
; 4326 :     shift[2 * i] = shift[2 * i + 1] = 0;
; 4327 :     fprintf(output, "%s", shift);
; 4328 :     if (particle->children == NULL) {
; 4329 : 	fprintf(output, "MISSING particle term\n");
; 4330 : 	return;
; 4331 :     }
; 4332 :     term = particle->children;
; 4333 :     if (term == NULL) {
; 4334 : 	fprintf(output, "(NULL)");
; 4335 :     } else {
; 4336 : 	switch (term->type) {
; 4337 : 	    case XML_SCHEMA_TYPE_ELEMENT:
; 4338 : 		fprintf(output, "ELEM '%s'", xmlSchemaFormatQName(&str,
; 4339 : 		    ((xmlSchemaElementPtr)term)->targetNamespace,
; 4340 : 		    ((xmlSchemaElementPtr)term)->name));
; 4341 : 		FREE_AND_NULL(str);
; 4342 : 		break;
; 4343 : 	    case XML_SCHEMA_TYPE_SEQUENCE:
; 4344 : 		fprintf(output, "SEQUENCE");
; 4345 : 		break;
; 4346 : 	    case XML_SCHEMA_TYPE_CHOICE:
; 4347 : 		fprintf(output, "CHOICE");
; 4348 : 		break;
; 4349 : 	    case XML_SCHEMA_TYPE_ALL:
; 4350 : 		fprintf(output, "ALL");
; 4351 : 		break;
; 4352 : 	    case XML_SCHEMA_TYPE_ANY:
; 4353 : 		fprintf(output, "ANY");
; 4354 : 		break;
; 4355 : 	    default:
; 4356 : 		fprintf(output, "UNKNOWN\n");
; 4357 : 		return;
; 4358 : 	}
; 4359 :     }
; 4360 :     if (particle->minOccurs != 1)
; 4361 : 	fprintf(output, " min: %d", particle->minOccurs);
; 4362 :     if (particle->maxOccurs >= UNBOUNDED)
; 4363 : 	fprintf(output, " max: unbounded");
; 4364 :     else if (particle->maxOccurs != 1)
; 4365 : 	fprintf(output, " max: %d", particle->maxOccurs);
; 4366 :     fprintf(output, "\n");
; 4367 :     if (term &&
; 4368 : 	((term->type == XML_SCHEMA_TYPE_SEQUENCE) ||
; 4369 : 	 (term->type == XML_SCHEMA_TYPE_CHOICE) ||
; 4370 : 	 (term->type == XML_SCHEMA_TYPE_ALL)) &&
; 4371 : 	 (term->children != NULL)) {
; 4372 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) term->children,
; 4373 : 	    output, depth +1);
; 4374 :     }
; 4375 :     if (particle->next != NULL)
; 4376 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) particle->next,
; 4377 : 		output, depth);
; 4378 : }
; 4379 : 
; 4380 : /**
; 4381 :  * xmlSchemaAttrUsesDump:
; 4382 :  * @uses:  attribute uses list
; 4383 :  * @output:  the file output
; 4384 :  *
; 4385 :  * Dumps a list of attribute use components.
; 4386 :  */
; 4387 : static void
; 4388 : xmlSchemaAttrUsesDump(xmlSchemaItemListPtr uses, FILE * output)
; 4389 : {
; 4390 :     xmlSchemaAttributeUsePtr use;
; 4391 :     xmlSchemaAttributeUseProhibPtr prohib;
; 4392 :     xmlSchemaQNameRefPtr ref;
; 4393 :     const xmlChar *name, *tns;
; 4394 :     xmlChar *str = NULL;
; 4395 :     int i;
; 4396 : 
; 4397 :     if ((uses == NULL) || (uses->nbItems == 0))
; 4398 :         return;
; 4399 : 
; 4400 :     fprintf(output, "  attributes:\n");
; 4401 :     for (i = 0; i < uses->nbItems; i++) {
; 4402 : 	use = uses->items[i];
; 4403 : 	if (use->type == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB) {
; 4404 : 	    fprintf(output, "  [prohibition] ");
; 4405 : 	    prohib = (xmlSchemaAttributeUseProhibPtr) use;
; 4406 : 	    name = prohib->name;
; 4407 : 	    tns = prohib->targetNamespace;
; 4408 : 	} else if (use->type == XML_SCHEMA_EXTRA_QNAMEREF) {
; 4409 : 	    fprintf(output, "  [reference] ");
; 4410 : 	    ref = (xmlSchemaQNameRefPtr) use;
; 4411 : 	    name = ref->name;
; 4412 : 	    tns = ref->targetNamespace;
; 4413 : 	} else {
; 4414 : 	    fprintf(output, "  [use] ");
; 4415 : 	    name = WXS_ATTRUSE_DECL_NAME(use);
; 4416 : 	    tns = WXS_ATTRUSE_DECL_TNS(use);
; 4417 : 	}
; 4418 : 	fprintf(output, "'%s'\n",
; 4419 : 	    (const char *) xmlSchemaFormatQName(&str, tns, name));
; 4420 : 	FREE_AND_NULL(str);
; 4421 :     }
; 4422 : }
; 4423 : 
; 4424 : /**
; 4425 :  * xmlSchemaTypeDump:
; 4426 :  * @output:  the file output
; 4427 :  * @type:  a type structure
; 4428 :  *
; 4429 :  * Dump a SchemaType structure
; 4430 :  */
; 4431 : static void
; 4432 : xmlSchemaTypeDump(xmlSchemaTypePtr type, FILE * output)
; 4433 : {
; 4434 :     if (type == NULL) {
; 4435 :         fprintf(output, "Type: NULL\n");
; 4436 :         return;
; 4437 :     }
; 4438 :     fprintf(output, "Type: ");
; 4439 :     if (type->name != NULL)
; 4440 :         fprintf(output, "'%s' ", type->name);
; 4441 :     else
; 4442 :         fprintf(output, "(no name) ");
; 4443 :     if (type->targetNamespace != NULL)
; 4444 : 	fprintf(output, "ns '%s' ", type->targetNamespace);
; 4445 :     switch (type->type) {
; 4446 :         case XML_SCHEMA_TYPE_BASIC:
; 4447 :             fprintf(output, "[basic] ");
; 4448 :             break;
; 4449 :         case XML_SCHEMA_TYPE_SIMPLE:
; 4450 :             fprintf(output, "[simple] ");
; 4451 :             break;
; 4452 :         case XML_SCHEMA_TYPE_COMPLEX:
; 4453 :             fprintf(output, "[complex] ");
; 4454 :             break;
; 4455 :         case XML_SCHEMA_TYPE_SEQUENCE:
; 4456 :             fprintf(output, "[sequence] ");
; 4457 :             break;
; 4458 :         case XML_SCHEMA_TYPE_CHOICE:
; 4459 :             fprintf(output, "[choice] ");
; 4460 :             break;
; 4461 :         case XML_SCHEMA_TYPE_ALL:
; 4462 :             fprintf(output, "[all] ");
; 4463 :             break;
; 4464 :         case XML_SCHEMA_TYPE_UR:
; 4465 :             fprintf(output, "[ur] ");
; 4466 :             break;
; 4467 :         case XML_SCHEMA_TYPE_RESTRICTION:
; 4468 :             fprintf(output, "[restriction] ");
; 4469 :             break;
; 4470 :         case XML_SCHEMA_TYPE_EXTENSION:
; 4471 :             fprintf(output, "[extension] ");
; 4472 :             break;
; 4473 :         default:
; 4474 :             fprintf(output, "[unknown type %d] ", type->type);
; 4475 :             break;
; 4476 :     }
; 4477 :     fprintf(output, "content: ");
; 4478 :     switch (type->contentType) {
; 4479 :         case XML_SCHEMA_CONTENT_UNKNOWN:
; 4480 :             fprintf(output, "[unknown] ");
; 4481 :             break;
; 4482 :         case XML_SCHEMA_CONTENT_EMPTY:
; 4483 :             fprintf(output, "[empty] ");
; 4484 :             break;
; 4485 :         case XML_SCHEMA_CONTENT_ELEMENTS:
; 4486 :             fprintf(output, "[element] ");
; 4487 :             break;
; 4488 :         case XML_SCHEMA_CONTENT_MIXED:
; 4489 :             fprintf(output, "[mixed] ");
; 4490 :             break;
; 4491 :         case XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS:
; 4492 : 	/* not used. */
; 4493 :             break;
; 4494 :         case XML_SCHEMA_CONTENT_BASIC:
; 4495 :             fprintf(output, "[basic] ");
; 4496 :             break;
; 4497 :         case XML_SCHEMA_CONTENT_SIMPLE:
; 4498 :             fprintf(output, "[simple] ");
; 4499 :             break;
; 4500 :         case XML_SCHEMA_CONTENT_ANY:
; 4501 :             fprintf(output, "[any] ");
; 4502 :             break;
; 4503 :     }
; 4504 :     fprintf(output, "\n");
; 4505 :     if (type->base != NULL) {
; 4506 :         fprintf(output, "  base type: '%s'", type->base);
; 4507 : 	if (type->baseNs != NULL)
; 4508 : 	    fprintf(output, " ns '%s'\n", type->baseNs);
; 4509 : 	else
; 4510 : 	    fprintf(output, "\n");
; 4511 :     }
; 4512 :     if (type->attrUses != NULL)
; 4513 : 	xmlSchemaAttrUsesDump(type->attrUses, output);
; 4514 :     if (type->annot != NULL)
; 4515 :         xmlSchemaAnnotDump(output, type->annot);
; 4516 : #ifdef DUMP_CONTENT_MODEL
; 4517 :     if ((type->type == XML_SCHEMA_TYPE_COMPLEX) &&
; 4518 : 	(type->subtypes != NULL)) {
; 4519 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) type->subtypes,
; 4520 : 	    output, 1);
; 4521 :     }
; 4522 : #endif
; 4523 : }
; 4524 : 
; 4525 : static void
; 4526 : xmlSchemaTypeDumpEntry(void *type, void *output,
; 4527 :                        const xmlChar *name ATTRIBUTE_UNUSED)
; 4528 : {
; 4529 :     xmlSchemaTypeDump((xmlSchemaTypePtr) type, (FILE *) output);
; 4530 : }
; 4531 : 
; 4532 : /**
; 4533 :  * xmlSchemaDump:
; 4534 :  * @output:  the file output
; 4535 :  * @schema:  a schema structure
; 4536 :  *
; 4537 :  * Dump a Schema structure.
; 4538 :  */
; 4539 : void
; 4540 : xmlSchemaDump(FILE * output, xmlSchemaPtr schema)
; 4541 : {
; 4542 :     if (output == NULL)
; 4543 :         return;
; 4544 :     if (schema == NULL) {
; 4545 :         fprintf(output, "Schemas: NULL\n");
; 4546 :         return;
; 4547 :     }
; 4548 :     fprintf(output, "Schemas: ");
; 4549 :     if (schema->name != NULL)
; 4550 :         fprintf(output, "%s, ", schema->name);
; 4551 :     else
; 4552 :         fprintf(output, "no name, ");
; 4553 :     if (schema->targetNamespace != NULL)
; 4554 :         fprintf(output, "%s", (const char *) schema->targetNamespace);
; 4555 :     else
; 4556 :         fprintf(output, "no target namespace");
; 4557 :     fprintf(output, "\n");
; 4558 :     if (schema->annot != NULL)
; 4559 :         xmlSchemaAnnotDump(output, schema->annot);
; 4560 :     xmlHashScan(schema->typeDecl, xmlSchemaTypeDumpEntry, output);
; 4561 :     xmlHashScanFull(schema->elemDecl, xmlSchemaElementDump, output);
; 4562 : }
; 4563 : 
; 4564 : #ifdef DEBUG_IDC_NODE_TABLE
; 4565 : /**
; 4566 :  * xmlSchemaDebugDumpIDCTable:
; 4567 :  * @vctxt: the WXS validation context
; 4568 :  *
; 4569 :  * Displays the current IDC table for debug purposes.
; 4570 :  */
; 4571 : static void
; 4572 : xmlSchemaDebugDumpIDCTable(FILE * output,
; 4573 : 			   const xmlChar *namespaceName,
; 4574 : 			   const xmlChar *localName,
; 4575 : 			   xmlSchemaPSVIIDCBindingPtr bind)
; 4576 : {
; 4577 :     xmlChar *str = NULL;
; 4578 :     const xmlChar *value;
; 4579 :     xmlSchemaPSVIIDCNodePtr tab;
; 4580 :     xmlSchemaPSVIIDCKeyPtr key;
; 4581 :     int i, j, res;
; 4582 : 
; 4583 :     fprintf(output, "IDC: TABLES on '%s'\n",
; 4584 : 	xmlSchemaFormatQName(&str, namespaceName, localName));
; 4585 :     FREE_AND_NULL(str)
; 4586 : 
; 4587 :     if (bind == NULL)
; 4588 : 	return;
; 4589 :     do {
; 4590 : 	fprintf(output, "IDC:   BINDING '%s' (%d)\n",
; 4591 : 	    xmlSchemaGetComponentQName(&str,
; 4592 : 		bind->definition), bind->nbNodes);
; 4593 : 	FREE_AND_NULL(str)
; 4594 : 	for (i = 0; i < bind->nbNodes; i++) {
; 4595 : 	    tab = bind->nodeTable[i];
; 4596 : 	    fprintf(output, "         ( ");
; 4597 : 	    for (j = 0; j < bind->definition->nbFields; j++) {
; 4598 : 		key = tab->keys[j];
; 4599 : 		if ((key != NULL) && (key->val != NULL)) {
; 4600 : 		    res = xmlSchemaGetCanonValue(key->val, &value);
; 4601 : 		    if (res >= 0)
; 4602 : 			fprintf(output, "'%s' ", value);
; 4603 : 		    else
; 4604 : 			fprintf(output, "CANON-VALUE-FAILED ");
; 4605 : 		    if (res == 0)
; 4606 : 			FREE_AND_NULL(value)
; 4607 : 		} else if (key != NULL)
; 4608 : 		    fprintf(output, "(no val), ");
; 4609 : 		else
; 4610 : 		    fprintf(output, "(key missing), ");
; 4611 : 	    }
; 4612 : 	    fprintf(output, ")\n");
; 4613 : 	}
; 4614 : 	if (bind->dupls && bind->dupls->nbItems) {
; 4615 : 	    fprintf(output, "IDC:     dupls (%d):\n", bind->dupls->nbItems);
; 4616 : 	    for (i = 0; i < bind->dupls->nbItems; i++) {
; 4617 : 		tab = bind->dupls->items[i];
; 4618 : 		fprintf(output, "         ( ");
; 4619 : 		for (j = 0; j < bind->definition->nbFields; j++) {
; 4620 : 		    key = tab->keys[j];
; 4621 : 		    if ((key != NULL) && (key->val != NULL)) {
; 4622 : 			res = xmlSchemaGetCanonValue(key->val, &value);
; 4623 : 			if (res >= 0)
; 4624 : 			    fprintf(output, "'%s' ", value);
; 4625 : 			else
; 4626 : 			    fprintf(output, "CANON-VALUE-FAILED ");
; 4627 : 			if (res == 0)
; 4628 : 			    FREE_AND_NULL(value)
; 4629 : 		    } else if (key != NULL)
; 4630 : 		    fprintf(output, "(no val), ");
; 4631 : 			else
; 4632 : 			    fprintf(output, "(key missing), ");
; 4633 : 		}
; 4634 : 		fprintf(output, ")\n");
; 4635 : 	    }
; 4636 : 	}
; 4637 : 	bind = bind->next;
; 4638 :     } while (bind != NULL);
; 4639 : }
; 4640 : #endif /* DEBUG_IDC */
; 4641 : #endif /* LIBXML_OUTPUT_ENABLED */
; 4642 : 
; 4643 : /************************************************************************
; 4644 :  *									*
; 4645 :  *			Utilities					*
; 4646 :  *									*
; 4647 :  ************************************************************************/
; 4648 : 
; 4649 : /**
; 4650 :  * xmlSchemaGetPropNode:
; 4651 :  * @node: the element node
; 4652 :  * @name: the name of the attribute
; 4653 :  *
; 4654 :  * Seeks an attribute with a name of @name in
; 4655 :  * no namespace.
; 4656 :  *
; 4657 :  * Returns the attribute or NULL if not present.
; 4658 :  */
; 4659 : static xmlAttrPtr
; 4660 : xmlSchemaGetPropNode(xmlNodePtr node, const char *name)
; 4661 : {
; 4662 :     xmlAttrPtr prop;
; 4663 : 
; 4664 :     if ((node == NULL) || (name == NULL))
; 4665 : 	return(NULL);
; 4666 :     prop = node->properties;
; 4667 :     while (prop != NULL) {

	jmp	SHORT $LN395@xmlSchemaP
$LN78@xmlSchemaP:

; 6041 :     return(xmlSchemaPValAttrNodeID(ctxt, attr));

	push	esi
	push	edi
	call	_xmlSchemaPValAttrNodeID
	add	esp, 8
$LN395@xmlSchemaP:

; 11547:     }
; 11548:     /*
; 11549:     * Extract and validate attributes.
; 11550:     */
; 11551:     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");
; 11552:     /*
; 11553:     * Attribute
; 11554:     */
; 11555:     /*
; 11556:     * Extract the base type. The "base" attribute is mandatory if inside
; 11557:     * a complex type or if redefining.
; 11558:     *
; 11559:     * SPEC (1.2) "...otherwise (<restriction> has no <simpleType> "
; 11560:     * among its [children]), the simple type definition which is
; 11561:     * the {content type} of the type definition `resolved` to by
; 11562:     * the `actual value` of the base [attribute]"
; 11563:     */
; 11564:     if (xmlSchemaPValAttrQName(ctxt, schema, NULL, node, "base",
; 11565: 	&(type->baseNs), &(type->base)) == 0)

	mov	esi, DWORD PTR _type$1$[ebp]
	add	ebx, 56					; 00000038H
	push	ebx
	add	esi, 60					; 0000003cH
	push	esi
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	DWORD PTR _node$[ebp]
	push	0
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaPValAttrQName
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	$LN21@xmlSchemaP

; 11566:     {
; 11567: 	if ((type->base == NULL) && (type->type == XML_SCHEMA_TYPE_COMPLEX)) {

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR _type$1$[ebp]
	test	eax, eax
	jne	SHORT $LN16@xmlSchemaP
	cmp	DWORD PTR [ecx], 5
	je	SHORT $LN410@xmlSchemaP
$LN16@xmlSchemaP:

; 11568: 	    xmlSchemaPMissingAttrErr(ctxt,
; 11569: 		XML_SCHEMAP_S4S_ATTR_MISSING,
; 11570: 		NULL, node, "base", NULL);
; 11571: 	} else if ((ctxt->isRedefine) &&

	cmp	DWORD PTR [edi+100], 0
	je	$LN21@xmlSchemaP
	test	BYTE PTR [ecx+48], 8
	je	$LN21@xmlSchemaP

; 11572: 	    (type->flags & XML_SCHEMAS_TYPE_GLOBAL))
; 11573: 	{
; 11574: 	    if (type->base == NULL) {

	test	eax, eax
	jne	SHORT $LN19@xmlSchemaP
$LN410@xmlSchemaP:

; 11601: 	    }
; 11602: 	}
; 11603:     }
; 11604:     /*
; 11605:     * And now for the children...
; 11606:     */
; 11607:     child = node->children;

	mov	ebx, DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$2[ebp]
	push	ebx
	push	0
	push	0
	push	eax
	mov	DWORD PTR _des$2[ebp], 0
	call	_xmlSchemaFormatItemForReport
	mov	eax, DWORD PTR _des$2[ebp]
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	eax
	push	OFFSET ??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	eax
	inc	DWORD PTR [edi+20]
	push	0
	push	0
	push	2
	push	3036					; 00000bdcH
	push	16					; 00000010H
	push	ebx
	push	edi
	push	DWORD PTR [edi+4]
	mov	DWORD PTR [edi+16], 3036		; 00000bdcH
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+24]
	call	___xmlRaiseError
	mov	eax, DWORD PTR _des$2[ebp]
	add	esp, 88					; 00000058H
	test	eax, eax
	je	$LN21@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	jmp	$LN21@xmlSchemaP
$LN19@xmlSchemaP:

; 11575: 		xmlSchemaPMissingAttrErr(ctxt,
; 11576: 		    XML_SCHEMAP_S4S_ATTR_MISSING,
; 11577: 		    NULL, node, "base", NULL);
; 11578: 	    } else if ((! xmlStrEqual(type->base, type->name)) ||

	push	DWORD PTR [ecx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@xmlSchemaP
	mov	eax, DWORD PTR _type$1$[ebp]
	push	DWORD PTR [eax+112]
	push	DWORD PTR [esi]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@xmlSchemaP
$LN22@xmlSchemaP:

; 11579: 		(! xmlStrEqual(type->baseNs, type->targetNamespace)))
; 11580: 	    {
; 11581: 		xmlChar *str1 = NULL, *str2 = NULL;
; 11582: 		/*
; 11583: 		* REDEFINE: SPEC src-redefine (5)
; 11584: 		* "Within the [children], each <simpleType> must have a
; 11585: 		* <restriction> among its [children] ... the `actual value` of
; 11586: 		* whose base [attribute] must be the same as the `actual value`
; 11587: 		* of its own name attribute plus target namespace;"
; 11588: 		*/
; 11589: 		xmlSchemaPCustomErrExt(ctxt, XML_SCHEMAP_SRC_REDEFINE,

	mov	eax, DWORD PTR _type$1$[ebp]
	push	0
	mov	DWORD PTR _str1$3[ebp], 0
	mov	DWORD PTR _str2$1[ebp], 0
	push	DWORD PTR [eax+8]
	push	DWORD PTR [eax+112]
	lea	eax, DWORD PTR _str2$1[ebp]
	push	eax
	call	_xmlSchemaFormatQName
	add	esp, 12					; 0000000cH
	push	eax
	push	DWORD PTR [ebx]
	lea	eax, DWORD PTR _str1$3[ebp]
	push	DWORD PTR [esi]
	push	eax
	call	_xmlSchemaFormatQName
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0HE@HDNCABHM@This?5is?5a?5redefinition?0?5but?5the@
	push	DWORD PTR _node$[ebp]
	push	0
	push	3081					; 00000c09H
	push	edi
	call	_xmlSchemaPCustomErrExt

; 11590: 		    NULL, node, "This is a redefinition, but the QName "
; 11591: 		    "value '%s' of the 'base' attribute does not match the "
; 11592: 		    "type's designation '%s'",
; 11593: 		    xmlSchemaFormatQName(&str1, type->baseNs, type->base),
; 11594: 		    xmlSchemaFormatQName(&str2, type->targetNamespace,
; 11595: 			type->name), NULL);
; 11596: 		FREE_AND_NULL(str1);

	mov	eax, DWORD PTR _str1$3[ebp]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN23@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN23@xmlSchemaP:

; 11597: 		FREE_AND_NULL(str2);

	mov	eax, DWORD PTR _str2$1[ebp]
	test	eax, eax
	je	SHORT $LN24@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN24@xmlSchemaP:

; 11598: 		/* Avoid confusion and erase the values. */
; 11599: 		type->base = NULL;

	mov	DWORD PTR [ebx], 0

; 11600: 		type->baseNs = NULL;

	mov	DWORD PTR [esi], 0
$LN21@xmlSchemaP:

; 11601: 	    }
; 11602: 	}
; 11603:     }
; 11604:     /*
; 11605:     * And now for the children...
; 11606:     */
; 11607:     child = node->children;

	mov	eax, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [eax+12]
	mov	ebx, esi
	mov	DWORD PTR _child$[ebp], esi
	test	esi, esi

; 11608:     if (IS_SCHEMA(child, "annotation")) {

	je	SHORT $LN25@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN25@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlSchemaP

; 11609: 	/*
; 11610: 	* Add the annotation to the simple type ancestor.
; 11611: 	*/
; 11612: 	xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,

	push	1
	push	esi
	push	edi
	call	_xmlSchemaParseAnnotation
	push	eax
	push	DWORD PTR _type$1$[ebp]
	call	_xmlSchemaAddAnnotation

; 11613: 	    xmlSchemaParseAnnotation(ctxt, child, 1));
; 11614:         child = child->next;

	mov	ebx, DWORD PTR [esi+24]
	add	esp, 20					; 00000014H
	mov	esi, ebx
	mov	DWORD PTR _child$[ebp], esi
$LN25@xmlSchemaP:

; 11615:     }
; 11616:     if (parentType == XML_SCHEMA_TYPE_SIMPLE) {

	mov	eax, DWORD PTR _parentType$[ebp]
	cmp	eax, 4
	jne	$LN26@xmlSchemaP

; 11617: 	/*
; 11618: 	* Corresponds to <simpleType><restriction><simpleType>.
; 11619: 	*/
; 11620: 	if (IS_SCHEMA(child, "simpleType")) {

	test	ebx, ebx
	je	SHORT $LN28@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN28@xmlSchemaP
	push	OFFSET ??_C@_0L@FMMGGLOP@simpleType@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN28@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN28@xmlSchemaP

; 11621: 	    if (type->base != NULL) {

	mov	ebx, DWORD PTR _type$1$[ebp]
	push	0
	cmp	DWORD PTR [ebx+56], 0
	je	SHORT $LN30@xmlSchemaP

; 11622: 		/*
; 11623: 		* src-restriction-base-or-simpleType
; 11624: 		* Either the base [attribute] or the simpleType [child] of the
; 11625: 		* <restriction> element must be present, but not both.
; 11626: 		*/
; 11627: 		xmlSchemaPContentErr(ctxt,

	push	OFFSET ??_C@_0EH@NLLIFAIL@The?5attribute?5?8base?8?5and?5the?5?$DMs@
	push	esi
	push	DWORD PTR _node$[ebp]
	push	0
	push	3005					; 00000bbdH
	push	edi
	call	_xmlSchemaPContentErr

; 11634: 		    xmlSchemaParseSimpleType(ctxt, schema, child, 0);
; 11635: 	    }
; 11636: 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _child$[ebp], esi
	jmp	$LN46@xmlSchemaP
$LN30@xmlSchemaP:

; 11628: 		    XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE,
; 11629: 		    NULL, node, child,
; 11630: 		    "The attribute 'base' and the <simpleType> child are "
; 11631: 		    "mutually exclusive", NULL);
; 11632: 	    } else {
; 11633: 		type->baseType = (xmlSchemaTypePtr)

	push	esi
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaParseSimpleType
	mov	DWORD PTR [ebx+64], eax
	add	esp, 16					; 00000010H

; 11634: 		    xmlSchemaParseSimpleType(ctxt, schema, child, 0);
; 11635: 	    }
; 11636: 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]
	mov	DWORD PTR _child$[ebp], esi
	jmp	$LN46@xmlSchemaP
$LN28@xmlSchemaP:

; 11637: 	} else if (type->base == NULL) {

	mov	ebx, DWORD PTR _type$1$[ebp]
	cmp	DWORD PTR [ebx+56], 0
	jne	$LN46@xmlSchemaP

; 11638: 	    xmlSchemaPContentErr(ctxt,

	push	0
	push	OFFSET ??_C@_0EE@KBNCPLAN@Either?5the?5attribute?5?8base?8?5or?5@
	push	esi
	push	DWORD PTR _node$[ebp]
	push	0
	push	3005					; 00000bbdH
	push	edi
	call	_xmlSchemaPContentErr
	add	esp, 28					; 0000001cH

; 11639: 		XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE,
; 11640: 		NULL, node, child,
; 11641: 		"Either the attribute 'base' or a <simpleType> child "
; 11642: 		"must be present", NULL);
; 11643: 	}

	jmp	$LN46@xmlSchemaP
$LN26@xmlSchemaP:

; 11644:     } else if (parentType == XML_SCHEMA_TYPE_COMPLEX_CONTENT) {

	cmp	eax, 10					; 0000000aH
	jne	$LN33@xmlSchemaP

; 11645: 	/*
; 11646: 	* Corresponds to <complexType><complexContent><restriction>...
; 11647: 	* followed by:
; 11648: 	*
; 11649: 	* Model groups <all>, <choice> and <sequence>.
; 11650: 	*/
; 11651: 	if (IS_SCHEMA(child, "all")) {

	test	ebx, ebx
	je	$LN407@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	$LN407@xmlSchemaP
	push	OFFSET ??_C@_03NFKEKGGK@all@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN35@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN35@xmlSchemaP

; 11652: 	    type->subtypes = (xmlSchemaTypePtr)

	mov	ebx, DWORD PTR _schema$[ebp]
	push	1
	push	8
	push	esi
	push	ebx
	push	edi
	call	_xmlSchemaParseModelGroup
	mov	ecx, DWORD PTR _type$1$[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR [ecx+28], eax

; 11653: 		xmlSchemaParseModelGroup(ctxt, schema, child,
; 11654: 		    XML_SCHEMA_TYPE_ALL, 1);
; 11655: 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]
	mov	DWORD PTR _child$[ebp], esi
	jmp	$LN7@xmlSchemaP
$LN35@xmlSchemaP:

; 11656: 	} else if (IS_SCHEMA(child, "choice")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN407@xmlSchemaP
	push	OFFSET ??_C@_06DDDNEJEA@choice@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN37@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN37@xmlSchemaP

; 11657: 	    type->subtypes = (xmlSchemaTypePtr)

	mov	ebx, DWORD PTR _schema$[ebp]
	push	1
	push	7
	push	esi
	push	ebx
	push	edi
	call	_xmlSchemaParseModelGroup
	mov	ecx, DWORD PTR _type$1$[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR [ecx+28], eax

; 11658: 		xmlSchemaParseModelGroup(ctxt,
; 11659: 		    schema, child, XML_SCHEMA_TYPE_CHOICE, 1);
; 11660: 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]
	mov	DWORD PTR _child$[ebp], esi
	jmp	$LN7@xmlSchemaP
$LN37@xmlSchemaP:

; 11661: 	} else if (IS_SCHEMA(child, "sequence")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN407@xmlSchemaP
	push	OFFSET ??_C@_08IBBDGPOF@sequence@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN39@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN39@xmlSchemaP

; 11662: 	    type->subtypes = (xmlSchemaTypePtr)

	mov	ebx, DWORD PTR _schema$[ebp]
	push	1
	push	6
	push	esi
	push	ebx
	push	edi
	call	_xmlSchemaParseModelGroup
	mov	ecx, DWORD PTR _type$1$[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR [ecx+28], eax

; 11663: 		xmlSchemaParseModelGroup(ctxt, schema, child,
; 11664: 		    XML_SCHEMA_TYPE_SEQUENCE, 1);
; 11665: 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]
	mov	DWORD PTR _child$[ebp], esi
	jmp	$LN7@xmlSchemaP
$LN39@xmlSchemaP:

; 11666: 	/*
; 11667: 	* Model group reference <group>.
; 11668: 	*/
; 11669: 	} else if (IS_SCHEMA(child, "group")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN407@xmlSchemaP
	push	OFFSET ??_C@_05MGJOOGAJ@group@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN407@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	mov	ebx, DWORD PTR _schema$[ebp]
	add	esp, 8
	test	eax, eax
	je	$LN7@xmlSchemaP

; 11670: 	    type->subtypes = (xmlSchemaTypePtr)

	push	esi
	push	ebx
	push	edi
	call	_xmlSchemaParseModelGroupDefRef
	mov	ecx, DWORD PTR _type$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+28], eax

; 11671: 		xmlSchemaParseModelGroupDefRef(ctxt, schema, child);
; 11672: 	    /*
; 11673: 	    * Note that the reference will be resolved in
; 11674: 	    * xmlSchemaResolveTypeReferences();
; 11675: 	    */
; 11676: 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]
	mov	DWORD PTR _child$[ebp], esi

; 11677: 	}

	jmp	$LN7@xmlSchemaP
$LN33@xmlSchemaP:

; 11678:     } else if (parentType == XML_SCHEMA_TYPE_SIMPLE_CONTENT) {

	cmp	eax, 9
	jne	$LN407@xmlSchemaP

; 11679: 	/*
; 11680: 	* Corresponds to <complexType><simpleContent><restriction>...
; 11681: 	*
; 11682: 	* "1.1 the simple type definition corresponding to the <simpleType>
; 11683: 	* among the [children] of <restriction> if there is one;"
; 11684: 	*/
; 11685: 	if (IS_SCHEMA(child, "simpleType")) {

	test	ebx, ebx
	je	SHORT $LN400@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN400@xmlSchemaP
	push	OFFSET ??_C@_0L@FMMGGLOP@simpleType@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN400@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN400@xmlSchemaP

; 11686: 	    /*
; 11687: 	    * We will store the to-be-restricted simple type in
; 11688: 	    * type->contentTypeDef *temporarily*.
; 11689: 	    */
; 11690: 	    type->contentTypeDef = (xmlSchemaTypePtr)

	push	0
	push	esi
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaParseSimpleType
	mov	ebx, DWORD PTR _type$1$[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ebx+104], eax

; 11691: 		xmlSchemaParseSimpleType(ctxt, schema, child, 0);
; 11692: 	    if ( type->contentTypeDef == NULL)

	test	eax, eax
	je	$LN10@xmlSchemaP

; 11693: 		return (NULL);
; 11694: 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]
	mov	DWORD PTR _child$[ebp], esi
	jmp	SHORT $LN46@xmlSchemaP
$LN400@xmlSchemaP:

; 11695: 	}
; 11696:     }
; 11697: 
; 11698:     if ((parentType == XML_SCHEMA_TYPE_SIMPLE) ||
; 11699: 	(parentType == XML_SCHEMA_TYPE_SIMPLE_CONTENT)) {
; 11700: 	xmlSchemaFacetPtr facet, lastfacet = NULL;

	mov	ebx, DWORD PTR _type$1$[ebp]
$LN46@xmlSchemaP:
	mov	DWORD PTR _lastfacet$1$[ebp], 0
$LL4@xmlSchemaP:

; 11701: 	/*
; 11702: 	* Corresponds to <complexType><simpleContent><restriction>...
; 11703: 	* <simpleType><restriction>...
; 11704: 	*/
; 11705: 
; 11706: 	/*
; 11707: 	* Add the facets to the simple type ancestor.
; 11708: 	*/
; 11709: 	/*
; 11710: 	* TODO: Datatypes: 4.1.3 Constraints on XML Representation of
; 11711: 	* Simple Type Definition Schema Representation Constraint:
; 11712: 	* *Single Facet Value*
; 11713: 	*/
; 11714: 	while ((IS_SCHEMA(child, "minInclusive")) ||
; 11715: 	    (IS_SCHEMA(child, "minExclusive")) ||
; 11716: 	    (IS_SCHEMA(child, "maxInclusive")) ||
; 11717: 	    (IS_SCHEMA(child, "maxExclusive")) ||
; 11718: 	    (IS_SCHEMA(child, "totalDigits")) ||
; 11719: 	    (IS_SCHEMA(child, "fractionDigits")) ||
; 11720: 	    (IS_SCHEMA(child, "pattern")) ||
; 11721: 	    (IS_SCHEMA(child, "enumeration")) ||
; 11722: 	    (IS_SCHEMA(child, "whiteSpace")) ||
; 11723: 	    (IS_SCHEMA(child, "length")) ||
; 11724: 	    (IS_SCHEMA(child, "maxLength")) ||

	test	esi, esi
	je	$LN5@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	$LN5@xmlSchemaP
	push	OFFSET ??_C@_0N@BDECKIL@minInclusive@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN48@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN47@xmlSchemaP
$LN48@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN5@xmlSchemaP
	push	OFFSET ??_C@_0N@MENCPBPO@minExclusive@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN49@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN47@xmlSchemaP
$LN49@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN5@xmlSchemaP
	push	OFFSET ??_C@_0N@EBHLFCPN@maxInclusive@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN50@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN47@xmlSchemaP
$LN50@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN5@xmlSchemaP
	push	OFFSET ??_C@_0N@IEJNIJII@maxExclusive@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN51@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN47@xmlSchemaP
$LN51@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN5@xmlSchemaP
	push	OFFSET ??_C@_0M@PGNNBCIB@totalDigits@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN52@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN47@xmlSchemaP
$LN52@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN5@xmlSchemaP
	push	OFFSET ??_C@_0P@EPJLKDGA@fractionDigits@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN53@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN47@xmlSchemaP
$LN53@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN5@xmlSchemaP
	push	OFFSET ??_C@_07CHFOACKJ@pattern@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN54@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN47@xmlSchemaP
$LN54@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN5@xmlSchemaP
	push	OFFSET ??_C@_0M@FJOIDAAJ@enumeration@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN55@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN47@xmlSchemaP
$LN55@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN5@xmlSchemaP
	push	OFFSET ??_C@_0L@CCEMGGFL@whiteSpace@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN56@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN47@xmlSchemaP
$LN56@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN5@xmlSchemaP
	push	OFFSET ??_C@_06IJDLPEM@length@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN57@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN47@xmlSchemaP
$LN57@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN5@xmlSchemaP
	push	OFFSET ??_C@_09KJHMKBNK@maxLength@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN58@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN47@xmlSchemaP
$LN58@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN5@xmlSchemaP
	push	OFFSET ??_C@_09KIHADLGO@minLength@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlSchemaP
$LN47@xmlSchemaP:

; 11725: 	    (IS_SCHEMA(child, "minLength"))) {
; 11726: 	    facet = xmlSchemaParseFacet(ctxt, schema, child);

	push	esi
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaParseFacet
	add	esp, 12					; 0000000cH

; 11727: 	    if (facet != NULL) {

	test	eax, eax
	je	SHORT $LN59@xmlSchemaP

; 11728: 		if (lastfacet == NULL)

	mov	ecx, DWORD PTR _lastfacet$1$[ebp]
	test	ecx, ecx
	jne	SHORT $LN60@xmlSchemaP

; 11729: 		    type->facets = facet;

	mov	DWORD PTR [ebx+68], eax
	jmp	SHORT $LN61@xmlSchemaP
$LN60@xmlSchemaP:

; 11730: 		else
; 11731: 		    lastfacet->next = facet;

	mov	DWORD PTR [ecx+4], eax
$LN61@xmlSchemaP:

; 11732: 		lastfacet = facet;

	mov	DWORD PTR _lastfacet$1$[ebp], eax

; 11733: 		lastfacet->next = NULL;

	mov	DWORD PTR [eax+4], 0
$LN59@xmlSchemaP:

; 11734: 	    }
; 11735: 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]
	mov	DWORD PTR _child$[ebp], esi

; 11736: 	}

	jmp	$LL4@xmlSchemaP
$LN5@xmlSchemaP:

; 11737: 	/*
; 11738: 	* Create links for derivation and validation.
; 11739: 	*/
; 11740: 	if (type->facets != NULL) {

	mov	ebx, DWORD PTR [ebx+68]
	test	ebx, ebx
	je	SHORT $LN407@xmlSchemaP

; 11741: 	    xmlSchemaFacetLinkPtr facetLink, lastFacetLink = NULL;

	mov	DWORD PTR _lastFacetLink$1$[ebp], 0
$LL8@xmlSchemaP:

; 11742: 
; 11743: 	    facet = type->facets;
; 11744: 	    do {
; 11745: 		facetLink = (xmlSchemaFacetLinkPtr)

	push	8
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 11746: 		    xmlMalloc(sizeof(xmlSchemaFacetLink));
; 11747: 		if (facetLink == NULL) {

	test	eax, eax
	je	$LN383@xmlSchemaP

; 11750: 		    return (NULL);
; 11751: 		}
; 11752: 		facetLink->facet = facet;
; 11753: 		facetLink->next = NULL;
; 11754: 		if (lastFacetLink == NULL)

	mov	ecx, DWORD PTR _lastFacetLink$1$[ebp]
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax], 0
	test	ecx, ecx
	jne	SHORT $LN64@xmlSchemaP

; 11755: 		    type->facetSet = facetLink;

	mov	ecx, DWORD PTR _type$1$[ebp]
	mov	DWORD PTR [ecx+96], eax
	jmp	SHORT $LN65@xmlSchemaP
$LN64@xmlSchemaP:

; 11756: 		else
; 11757: 		    lastFacetLink->next = facetLink;

	mov	DWORD PTR [ecx], eax
$LN65@xmlSchemaP:

; 11758: 		lastFacetLink = facetLink;
; 11759: 		facet = facet->next;

	mov	ebx, DWORD PTR [ebx+4]
	mov	DWORD PTR _lastFacetLink$1$[ebp], eax

; 11760: 	    } while (facet != NULL);

	test	ebx, ebx
	jne	SHORT $LL8@xmlSchemaP
$LN407@xmlSchemaP:

; 11761: 	}
; 11762:     }
; 11763:     if (type->type == XML_SCHEMA_TYPE_COMPLEX) {

	mov	ebx, DWORD PTR _schema$[ebp]
$LN7@xmlSchemaP:
	mov	eax, DWORD PTR _type$1$[ebp]
	cmp	DWORD PTR [eax], 5
	jne	SHORT $LN68@xmlSchemaP

; 11764: 	/*
; 11765: 	* Attribute uses/declarations.
; 11766: 	*/
; 11767: 	if (xmlSchemaParseLocalAttributes(ctxt, schema, &child,
; 11768: 	    (xmlSchemaItemListPtr *) &(type->attrUses),
; 11769: 	    XML_SCHEMA_TYPE_RESTRICTION, NULL) == -1)

	push	0
	push	12					; 0000000cH
	add	eax, 116				; 00000074H
	push	eax
	lea	eax, DWORD PTR _child$[ebp]
	push	eax
	push	ebx
	push	edi
	call	_xmlSchemaParseLocalAttributes
	add	esp, 24					; 00000018H
	cmp	eax, -1
	je	$LN10@xmlSchemaP

; 11770: 	    return(NULL);
; 11771: 	/*
; 11772: 	* Attribute wildcard.
; 11773: 	*/
; 11774: 	if (IS_SCHEMA(child, "anyAttribute")) {

	mov	esi, DWORD PTR _child$[ebp]
	test	esi, esi
	je	$LN10@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN68@xmlSchemaP
	push	OFFSET ??_C@_0N@DDKCLMJG@anyAttribute@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN68@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN68@xmlSchemaP

; 11775: 	    type->attributeWildcard =

	push	esi
	push	ebx
	push	edi
	call	_xmlSchemaParseAnyAttribute
	mov	ecx, DWORD PTR _type$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+84], eax

; 11776: 		xmlSchemaParseAnyAttribute(ctxt, schema, child);
; 11777: 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]
$LN68@xmlSchemaP:

; 11778: 	}
; 11779:     }
; 11780:     if (child != NULL) {

	test	esi, esi
	je	$LN10@xmlSchemaP

; 11781: 	if (parentType == XML_SCHEMA_TYPE_COMPLEX_CONTENT) {

	push	DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR _parentType$[ebp]
	mov	DWORD PTR _des$6[ebp], 0
	push	0
	push	0
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN70@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	lea	eax, DWORD PTR _des$6[ebp]
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0GB@CPHLEAHN@annotation?$DP?0?5?$CIgroup?5?$HM?5all?5?$HM?5cho@

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)
; 3242 : }

	jmp	SHORT $LN427@xmlSchemaP
$LN383@xmlSchemaP:

; 11748: 		    xmlSchemaPErrMemory(ctxt, "allocating a facet link", NULL);

	push	0
	push	OFFSET ??_C@_0BI@BKMOEBCP@allocating?5a?5facet?5link@
	push	edi
	call	_xmlSchemaPErrMemory

; 11749: 		    xmlFree(facetLink);

	push	0
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H

; 11796: 	    /* Simple type */
; 11797: 	    xmlSchemaPContentErr(ctxt,
; 11798: 		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 11799: 		NULL, node, child, NULL,
; 11800: 		"(annotation?, (simpleType?, (minExclusive | minInclusive | "
; 11801: 		"maxExclusive | maxInclusive | totalDigits | fractionDigits | "
; 11802: 		"length | minLength | maxLength | enumeration | whiteSpace | "
; 11803: 		"pattern)*))");
; 11804: 	}
; 11805:     }
; 11806:     return (NULL);
; 11807: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN70@xmlSchemaP:

; 11782: 	    xmlSchemaPContentErr(ctxt,
; 11783: 		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 11784: 		NULL, node, child, NULL,
; 11785: 		"annotation?, (group | all | choice | sequence)?, "
; 11786: 		"((attribute | attributeGroup)*, anyAttribute?))");
; 11787: 	} else if (parentType == XML_SCHEMA_TYPE_SIMPLE_CONTENT) {

	cmp	eax, 9
	lea	eax, DWORD PTR _des$4[ebp]
	push	eax
	jne	SHORT $LN72@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0PB@MMDBBLJD@?$CIannotation?$DP?0?5?$CIsimpleType?$DP?0?5?$CImi@

; 11788: 	     xmlSchemaPContentErr(ctxt,
; 11789: 		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 11790: 		NULL, node, child, NULL,
; 11791: 		"(annotation?, (simpleType?, (minExclusive | minInclusive | "
; 11792: 		"maxExclusive | maxInclusive | totalDigits | fractionDigits | "
; 11793: 		"length | minLength | maxLength | enumeration | whiteSpace | "
; 11794: 		"pattern)*)?, ((attribute | attributeGroup)*, anyAttribute?))");
; 11795: 	} else {

	jmp	SHORT $LN427@xmlSchemaP
$LN72@xmlSchemaP:

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0MA@MDLOJGLL@?$CIannotation?$DP?0?5?$CIsimpleType?$DP?0?5?$CImi@
$LN427@xmlSchemaP:

; 11796: 	    /* Simple type */
; 11797: 	    xmlSchemaPContentErr(ctxt,
; 11798: 		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 11799: 		NULL, node, child, NULL,
; 11800: 		"(annotation?, (simpleType?, (minExclusive | minInclusive | "
; 11801: 		"maxExclusive | maxInclusive | totalDigits | fractionDigits | "
; 11802: 		"length | minLength | maxLength | enumeration | whiteSpace | "
; 11803: 		"pattern)*))");
; 11804: 	}
; 11805:     }
; 11806:     return (NULL);
; 11807: }

	push	DWORD PTR _des$5[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	edi
	call	_xmlSchemaPErr
	mov	eax, DWORD PTR _des$5[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN10@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlSchemaP:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseRestriction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseComplexType
_TEXT	SEGMENT
_ctxtType$1$ = -28					; size = 4
_attrValue$1$ = -24					; size = 4
_attrValue$2$ = -24					; size = 4
_final$1$ = -20						; size = 4
_hasRestrictionOrExtension$ = -16			; size = 4
_attr$2$ = -12						; size = 4
_name$ = -12						; size = 4
_block$1$ = -8						; size = 4
_child$ = -8						; size = 4
_type$1$ = -4						; size = 4
_des$1 = 8						; size = 4
_des$2 = 8						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_topLevel$ = 20						; size = 4
_xmlSchemaParseComplexType PROC				; COMDAT

; 12144: {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	mov	DWORD PTR _name$[ebp], eax
	mov	DWORD PTR _final$1$[ebp], eax
	mov	DWORD PTR _block$1$[ebp], eax
	mov	DWORD PTR _hasRestrictionOrExtension$[ebp], eax
	test	edi, edi
	je	$LN5@xmlSchemaP

; 12145:     xmlSchemaTypePtr type, ctxtType;
; 12146:     xmlNodePtr child = NULL;
; 12147:     const xmlChar *name = NULL;
; 12148:     xmlAttrPtr attr;
; 12149:     const xmlChar *attrValue;
; 12150: #ifdef ENABLE_NAMED_LOCALS
; 12151:     char buf[40];
; 12152: #endif
; 12153:     int final = 0, block = 0, hasRestrictionOrExtension = 0;
; 12154: 
; 12155: 
; 12156:     if ((ctxt == NULL) || (schema == NULL) || (node == NULL))

	mov	edx, DWORD PTR _schema$[ebp]
	test	edx, edx
	je	$LN5@xmlSchemaP
	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	$LN5@xmlSchemaP

; 12157:         return (NULL);
; 12158: 
; 12159:     ctxtType = ctxt->ctxtType;

	mov	ecx, DWORD PTR [edi+84]
	mov	DWORD PTR _ctxtType$1$[ebp], ecx

; 12160: 
; 12161:     if (topLevel) {

	cmp	DWORD PTR _topLevel$[ebp], eax
	je	$LN9@xmlSchemaP

; 12162: 	attr = xmlSchemaGetPropNode(node, "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	ebx
	call	_xmlSchemaGetPropNode
	mov	esi, eax
	add	esp, 8

; 12163: 	if (attr == NULL) {

	test	esi, esi
	jne	SHORT $LN7@xmlSchemaP

; 2802 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	eax
	push	eax
	mov	DWORD PTR _des$2[ebp], eax
	lea	eax, DWORD PTR _des$2[ebp]
	push	eax
	call	_xmlSchemaFormatItemForReport

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	mov	eax, DWORD PTR _des$2[ebp]
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	push	OFFSET ??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@
	push	esi
	push	esi
	push	esi
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	inc	DWORD PTR [edi+20]
	push	esi
	push	esi
	push	2
	push	3036					; 00000bdcH
	push	16					; 00000010H
	push	ebx
	push	edi
	push	DWORD PTR [edi+4]
	mov	DWORD PTR [edi+16], 3036		; 00000bdcH
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+24]
	call	___xmlRaiseError

; 2810 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$2[ebp]

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 88					; 00000058H

; 2810 :     FREE_AND_NULL(des);

	test	eax, eax
	je	SHORT $LN5@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlSchemaP:
	pop	edi

; 12413: }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlSchemaP:

; 12164: 	    xmlSchemaPMissingAttrErr(ctxt,
; 12165: 		XML_SCHEMAP_S4S_ATTR_MISSING, NULL, node, "name", NULL);
; 12166: 	    return (NULL);
; 12167: 	} else if (xmlSchemaPValAttrNode(ctxt, NULL, attr,
; 12168: 	    xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	push	22					; 00000016H
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	push	eax
	push	esi
	push	0
	push	edi
	call	_xmlSchemaPValAttrNode
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN5@xmlSchemaP
	mov	eax, DWORD PTR _name$[ebp]
	mov	edx, DWORD PTR _schema$[ebp]
$LN9@xmlSchemaP:

; 12169: 	    return (NULL);
; 12170: 	}
; 12171:     }
; 12172: 
; 12173:     if (topLevel == 0) {

	cmp	DWORD PTR _topLevel$[ebp], 0
	mov	ecx, DWORD PTR [edi+112]
	jne	SHORT $LN10@xmlSchemaP

; 12174: 	/*
; 12175: 	* Parse as local complex type definition.
; 12176: 	*/
; 12177: #ifdef ENABLE_NAMED_LOCALS
; 12178:         snprintf(buf, 39, "#CT%d", ctxt->counter++ + 1);
; 12179: 	type = xmlSchemaAddType(ctxt, schema,
; 12180: 	    XML_SCHEMA_TYPE_COMPLEX,
; 12181: 	    xmlDictLookup(ctxt->dict, (const xmlChar *)buf, -1),
; 12182: 	    ctxt->targetNamespace, node, 0);
; 12183: #else
; 12184: 	type = xmlSchemaAddType(ctxt, schema,

	push	0
	push	ebx
	push	ecx
	push	0
	push	5
	push	edx
	push	edi
	call	_xmlSchemaAddType
	mov	esi, eax
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _type$1$[ebp], esi

; 12185: 	    XML_SCHEMA_TYPE_COMPLEX,
; 12186: 	    NULL, ctxt->targetNamespace, node, 0);
; 12187: #endif
; 12188: 	if (type == NULL)

	test	esi, esi
	je	SHORT $LN5@xmlSchemaP

; 12189: 	    return (NULL);
; 12190: 	name = type->name;
; 12191: 	type->node = node;
; 12192: 	type->type = XML_SCHEMA_TYPE_COMPLEX;
; 12193: 	/*
; 12194: 	* TODO: We need the target namespace.
; 12195: 	*/
; 12196:     } else {

	jmp	SHORT $LN387@xmlSchemaP
$LN10@xmlSchemaP:

; 12197: 	/*
; 12198: 	* Parse as global complex type definition.
; 12199: 	*/
; 12200: 	type = xmlSchemaAddType(ctxt, schema,

	push	1
	push	ebx
	push	ecx
	push	eax
	push	5
	push	edx
	push	edi
	call	_xmlSchemaAddType
	mov	esi, eax
	mov	DWORD PTR _type$1$[ebp], eax
	add	esp, 28					; 0000001cH

; 12201: 	    XML_SCHEMA_TYPE_COMPLEX,
; 12202: 	    name, ctxt->targetNamespace, node, 1);
; 12203: 	if (type == NULL)

	test	esi, esi
	je	SHORT $LN5@xmlSchemaP

; 12204: 	    return (NULL);
; 12205: 	type->node = node;
; 12206: 	type->type = XML_SCHEMA_TYPE_COMPLEX;
; 12207: 	type->flags |= XML_SCHEMAS_TYPE_GLOBAL;

	or	DWORD PTR [esi+48], 8
$LN387@xmlSchemaP:

; 12208:     }
; 12209:     type->targetNamespace = ctxt->targetNamespace;

	mov	DWORD PTR [esi], 5
	mov	DWORD PTR [esi+36], ebx
	mov	eax, DWORD PTR [edi+112]
	mov	DWORD PTR [esi+112], eax

; 12210:     /*
; 12211:     * Handle attributes.
; 12212:     */
; 12213:     attr = node->properties;

	mov	ebx, DWORD PTR [ebx+44]
	mov	DWORD PTR _attr$2$[ebp], ebx

; 12214:     while (attr != NULL) {

	test	ebx, ebx
	je	$LN355@xmlSchemaP
$LL2@xmlSchemaP:

; 12215: 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	jne	$LN14@xmlSchemaP

; 12216: 	    if (xmlStrEqual(attr->name, BAD_CAST "id")) {

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlSchemaP

; 12217: 		/*
; 12218: 		* Attribute "id".
; 12219: 		*/
; 12220: 		xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR _node$[ebp]
	push	edi
	call	_xmlSchemaPValAttrID
	add	esp, 12					; 0000000cH
	jmp	$LN386@xmlSchemaP
$LN16@xmlSchemaP:

; 12221: 	    } else if (xmlStrEqual(attr->name, BAD_CAST "mixed")) {

	push	OFFSET ??_C@_05IPHDHIPP@mixed@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlSchemaP

; 12222: 		/*
; 12223: 		* Attribute "mixed".
; 12224: 		*/
; 12225: 		if (xmlSchemaPGetBoolNodeValue(ctxt,

	push	ebx
	push	0
	push	edi
	call	_xmlSchemaPGetBoolNodeValue
	add	esp, 12					; 0000000cH
	test	eax, eax
	mov	eax, DWORD PTR _block$1$[ebp]
	je	$LN36@xmlSchemaP

; 12226: 			NULL, (xmlNodePtr) attr))
; 12227: 		    type->flags |= XML_SCHEMAS_TYPE_MIXED;

	or	DWORD PTR [esi+48], 1

; 12228: 	    } else if (topLevel) {

	jmp	$LN36@xmlSchemaP
$LN18@xmlSchemaP:
	cmp	DWORD PTR _topLevel$[ebp], 0
	je	$LN21@xmlSchemaP

; 12229: 		/*
; 12230: 		* Attributes of global complex type definitions.
; 12231: 		*/
; 12232: 		if (xmlStrEqual(attr->name, BAD_CAST "name")) {

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN386@xmlSchemaP

; 12233: 		    /* Pass. */
; 12234: 		} else if (xmlStrEqual(attr->name, BAD_CAST "abstract")) {

	push	OFFSET ??_C@_08IMFJLGFD@abstract@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlSchemaP

; 12235: 		    /*
; 12236: 		    * Attribute "abstract".
; 12237: 		    */
; 12238: 		    if (xmlSchemaPGetBoolNodeValue(ctxt,

	push	ebx
	push	0
	push	edi
	call	_xmlSchemaPGetBoolNodeValue
	add	esp, 12					; 0000000cH
	test	eax, eax
	mov	eax, DWORD PTR _block$1$[ebp]
	je	$LN36@xmlSchemaP

; 12239: 			    NULL, (xmlNodePtr) attr))
; 12240: 			type->flags |= XML_SCHEMAS_TYPE_ABSTRACT;

	or	DWORD PTR [esi+48], 1048576		; 00100000H

; 12241: 		} else if (xmlStrEqual(attr->name, BAD_CAST "final")) {

	jmp	$LN36@xmlSchemaP
$LN25@xmlSchemaP:
	push	OFFSET ??_C@_05FPBGKCKL@final@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN28@xmlSchemaP

; 12242: 		    /*
; 12243: 		    * Attribute "final".
; 12244: 		    */
; 12245: 		    attrValue = xmlSchemaGetNodeContent(ctxt,

	push	ebx
	push	edi
	call	_xmlSchemaGetNodeContent
	add	esp, 8
	mov	edi, eax

; 7953 :     int ret = 0;

	xor	ebx, ebx

; 12242: 		    /*
; 12243: 		    * Attribute "final".
; 12244: 		    */
; 12245: 		    attrValue = xmlSchemaGetNodeContent(ctxt,

	mov	DWORD PTR _attrValue$1$[ebp], edi

; 12246: 			(xmlNodePtr) attr);
; 12247: 		    if (xmlSchemaPValAttrBlockFinal(attrValue,
; 12248: 			&(type->flags),
; 12249: 			-1,
; 12250: 			XML_SCHEMAS_TYPE_FINAL_EXTENSION,
; 12251: 			XML_SCHEMAS_TYPE_FINAL_RESTRICTION,
; 12252: 			-1, -1, -1) != 0)

	add	esi, 48					; 00000030H

; 7958 :     if ((flags == NULL) || (value == NULL))

	je	$LN78@xmlSchemaP
	test	edi, edi
	je	$LN78@xmlSchemaP

; 7959 : 	return (-1);
; 7960 :     if (value[0] == 0)

	cmp	BYTE PTR [edi], bl
	je	$LN368@xmlSchemaP

; 7961 : 	return (0);
; 7962 :     if (xmlStrEqual(value, BAD_CAST "#all")) {

	push	OFFSET ??_C@_04LEKDNLLP@?$CDall@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN80@xmlSchemaP

; 7963 : 	if (flagAll != -1)
; 7964 : 	    *flags |= flagAll;
; 7965 : 	else {
; 7966 : 	    if (flagExtension != -1)
; 7967 : 		*flags |= flagExtension;
; 7968 : 	    if (flagRestriction != -1)
; 7969 : 		*flags |= flagRestriction;

	or	DWORD PTR [esi], 1536			; 00000600H

; 7970 : 	    if (flagSubstitution != -1)
; 7971 : 		*flags |= flagSubstitution;
; 7972 : 	    if (flagList != -1)
; 7973 : 		*flags |= flagList;
; 7974 : 	    if (flagUnion != -1)
; 7975 : 		*flags |= flagUnion;
; 7976 : 	}
; 7977 :     } else {

	jmp	$LN368@xmlSchemaP
$LN80@xmlSchemaP:

; 7978 : 	const xmlChar *end, *cur = value;

	mov	ecx, edi
$LL73@xmlSchemaP:

; 7979 : 	xmlChar *item;
; 7980 : 
; 7981 : 	do {
; 7982 : 	    while (IS_BLANK_CH(*cur))

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN89@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN90@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN89@xmlSchemaP
$LN90@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN74@xmlSchemaP
$LN89@xmlSchemaP:

; 7983 : 		cur++;

	inc	ecx
	jmp	SHORT $LL73@xmlSchemaP
$LN74@xmlSchemaP:

; 7984 : 	    end = cur;

	mov	esi, ecx

; 7985 : 	    while ((*end != 0) && (!(IS_BLANK_CH(*end))))

	test	al, al
	je	$LN368@xmlSchemaP
$LL75@xmlSchemaP:
	cmp	al, 32					; 00000020H
	je	SHORT $LN76@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN91@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN76@xmlSchemaP
$LN91@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN76@xmlSchemaP
	mov	al, BYTE PTR [esi+1]

; 7986 : 		end++;

	inc	esi
	test	al, al
	jne	SHORT $LL75@xmlSchemaP
$LN76@xmlSchemaP:

; 7987 : 	    if (end == cur)

	cmp	esi, ecx
	je	$LN368@xmlSchemaP

; 7988 : 		break;
; 7989 : 	    item = xmlStrndup(cur, end - cur);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	call	_xmlStrndup
	mov	edi, eax

; 7990 : 	    if (xmlStrEqual(item, BAD_CAST "extension")) {

	push	OFFSET ??_C@_09ODADEDNA@extension@
	push	edi
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN93@xmlSchemaP

; 7991 : 		if (flagExtension != -1) {
; 7992 : 		    if ((*flags & flagExtension) == 0)

	mov	ecx, DWORD PTR _type$1$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	test	eax, 512				; 00000200H
	jne	SHORT $LN113@xmlSchemaP

; 7993 : 			*flags |= flagExtension;

	or	eax, 512				; 00000200H
	mov	DWORD PTR [ecx+48], eax

; 7994 : 		} else
; 7995 : 		    ret = 1;
; 7996 : 	    } else if (xmlStrEqual(item, BAD_CAST "restriction")) {

	jmp	SHORT $LN113@xmlSchemaP
$LN93@xmlSchemaP:
	push	OFFSET ??_C@_0M@FBFLGGFO@restriction@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN98@xmlSchemaP

; 7997 : 		if (flagRestriction != -1) {
; 7998 : 		    if ((*flags & flagRestriction) == 0)

	mov	ecx, DWORD PTR _type$1$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	test	eax, 1024				; 00000400H
	jne	SHORT $LN113@xmlSchemaP

; 7999 : 			*flags |= flagRestriction;

	or	eax, 1024				; 00000400H
	mov	DWORD PTR [ecx+48], eax

; 8000 : 		} else
; 8001 : 		    ret = 1;
; 8002 : 	    } else if (xmlStrEqual(item, BAD_CAST "substitution")) {

	jmp	SHORT $LN113@xmlSchemaP
$LN98@xmlSchemaP:
	push	OFFSET ??_C@_0N@INDADLAA@substitution@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN388@xmlSchemaP

; 8003 : 		if (flagSubstitution != -1) {
; 8004 : 		    if ((*flags & flagSubstitution) == 0)
; 8005 : 			*flags |= flagSubstitution;
; 8006 : 		} else
; 8007 : 		    ret = 1;
; 8008 : 	    } else if (xmlStrEqual(item, BAD_CAST "list")) {

	push	OFFSET ??_C@_04DONFEANM@list@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN388@xmlSchemaP

; 8009 : 		if (flagList != -1) {
; 8010 : 		    if ((*flags & flagList) == 0)
; 8011 : 			*flags |= flagList;
; 8012 : 		} else
; 8013 : 		    ret = 1;
; 8014 : 	    } else if (xmlStrEqual(item, BAD_CAST "union")) {

	push	OFFSET ??_C@_05MNALHJLP@union@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
$LN388@xmlSchemaP:

; 8015 : 		if (flagUnion != -1) {
; 8016 : 		    if ((*flags & flagUnion) == 0)
; 8017 : 			*flags |= flagUnion;
; 8018 : 		} else
; 8019 : 		    ret = 1;
; 8020 : 	    } else
; 8021 : 		ret = 1;
; 8022 : 	    if (item != NULL)

	mov	ebx, 1
$LN113@xmlSchemaP:
	test	edi, edi
	je	SHORT $LN118@xmlSchemaP

; 8023 : 		xmlFree(item);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN118@xmlSchemaP:

; 8024 : 	    cur = end;

	mov	ecx, esi

; 8025 : 	} while ((ret == 0) && (*cur != 0));

	test	ebx, ebx
	jne	SHORT $LN370@xmlSchemaP
	cmp	BYTE PTR [esi], bl
	jne	$LL73@xmlSchemaP
$LN368@xmlSchemaP:

; 12255: 			    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 12256: 			    NULL, (xmlNodePtr) attr, NULL,
; 12257: 			    "(#all | List of (extension | restriction))",
; 12258: 			    attrValue, NULL, NULL, NULL);
; 12259: 		    } else
; 12260: 			final = 1;
; 12261: 		} else if (xmlStrEqual(attr->name, BAD_CAST "block")) {

	mov	ebx, DWORD PTR _attr$2$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	esi, DWORD PTR _type$1$[ebp]
	mov	DWORD PTR _final$1$[ebp], 1
	jmp	$LN386@xmlSchemaP
$LN370@xmlSchemaP:

; 8025 : 	} while ((ret == 0) && (*cur != 0));

	mov	edi, DWORD PTR _attrValue$1$[ebp]
$LN78@xmlSchemaP:

; 12253: 		    {
; 12254: 			xmlSchemaPSimpleTypeErr(ctxt,

	push	0
	push	0
	push	0
	push	edi
	push	OFFSET ??_C@_0CL@KNGCEGAB@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@
$LN390@xmlSchemaP:

; 12288: 	    xmlSchemaPIllegalAttrErr(ctxt,
; 12289: 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 12290: 	}
; 12291: 	attr = attr->next;

	mov	ebx, DWORD PTR _attr$2$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	push	0
	push	ebx
	push	0
	push	3037					; 00000bddH
	push	edi
	call	_xmlSchemaPSimpleTypeErr
	mov	esi, DWORD PTR _type$1$[ebp]
	add	esp, 40					; 00000028H
	jmp	$LN386@xmlSchemaP
$LN28@xmlSchemaP:

; 12255: 			    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 12256: 			    NULL, (xmlNodePtr) attr, NULL,
; 12257: 			    "(#all | List of (extension | restriction))",
; 12258: 			    attrValue, NULL, NULL, NULL);
; 12259: 		    } else
; 12260: 			final = 1;
; 12261: 		} else if (xmlStrEqual(attr->name, BAD_CAST "block")) {

	push	OFFSET ??_C@_05PIBOEKAB@block@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	push	ebx
	test	eax, eax
	je	$LN32@xmlSchemaP

; 12262: 		    /*
; 12263: 		    * Attribute "block".
; 12264: 		    */
; 12265: 		    attrValue = xmlSchemaGetNodeContent(ctxt,

	push	edi
	call	_xmlSchemaGetNodeContent
	add	esp, 8
	mov	edi, eax

; 7953 :     int ret = 0;

	xor	ebx, ebx

; 12262: 		    /*
; 12263: 		    * Attribute "block".
; 12264: 		    */
; 12265: 		    attrValue = xmlSchemaGetNodeContent(ctxt,

	mov	DWORD PTR _attrValue$2$[ebp], edi

; 12266: 			(xmlNodePtr) attr);
; 12267: 		    if (xmlSchemaPValAttrBlockFinal(attrValue, &(type->flags),
; 12268: 			-1,
; 12269: 			XML_SCHEMAS_TYPE_BLOCK_EXTENSION,
; 12270: 			XML_SCHEMAS_TYPE_BLOCK_RESTRICTION,
; 12271: 			-1, -1, -1) != 0) {

	add	esi, 48					; 00000030H

; 7958 :     if ((flags == NULL) || (value == NULL))

	je	$LN130@xmlSchemaP
	test	edi, edi
	je	$LN130@xmlSchemaP

; 7959 : 	return (-1);
; 7960 :     if (value[0] == 0)

	cmp	BYTE PTR [edi], bl
	je	$LN369@xmlSchemaP

; 7961 : 	return (0);
; 7962 :     if (xmlStrEqual(value, BAD_CAST "#all")) {

	push	OFFSET ??_C@_04LEKDNLLP@?$CDall@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN132@xmlSchemaP

; 7963 : 	if (flagAll != -1)
; 7964 : 	    *flags |= flagAll;
; 7965 : 	else {
; 7966 : 	    if (flagExtension != -1)
; 7967 : 		*flags |= flagExtension;
; 7968 : 	    if (flagRestriction != -1)
; 7969 : 		*flags |= flagRestriction;

	or	DWORD PTR [esi], 786432			; 000c0000H

; 7970 : 	    if (flagSubstitution != -1)
; 7971 : 		*flags |= flagSubstitution;
; 7972 : 	    if (flagList != -1)
; 7973 : 		*flags |= flagList;
; 7974 : 	    if (flagUnion != -1)
; 7975 : 		*flags |= flagUnion;
; 7976 : 	}
; 7977 :     } else {

	jmp	$LN369@xmlSchemaP
$LN132@xmlSchemaP:

; 7978 : 	const xmlChar *end, *cur = value;

	mov	ecx, edi
	npad	3
$LL125@xmlSchemaP:

; 7979 : 	xmlChar *item;
; 7980 : 
; 7981 : 	do {
; 7982 : 	    while (IS_BLANK_CH(*cur))

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN141@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN142@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN141@xmlSchemaP
$LN142@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN126@xmlSchemaP
$LN141@xmlSchemaP:

; 7983 : 		cur++;

	inc	ecx
	jmp	SHORT $LL125@xmlSchemaP
$LN126@xmlSchemaP:

; 7984 : 	    end = cur;

	mov	esi, ecx

; 7985 : 	    while ((*end != 0) && (!(IS_BLANK_CH(*end))))

	test	al, al
	je	$LN369@xmlSchemaP
	npad	1
$LL127@xmlSchemaP:
	cmp	al, 32					; 00000020H
	je	SHORT $LN128@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN143@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN128@xmlSchemaP
$LN143@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN128@xmlSchemaP
	mov	al, BYTE PTR [esi+1]

; 7986 : 		end++;

	inc	esi
	test	al, al
	jne	SHORT $LL127@xmlSchemaP
$LN128@xmlSchemaP:

; 7987 : 	    if (end == cur)

	cmp	esi, ecx
	je	$LN369@xmlSchemaP

; 7988 : 		break;
; 7989 : 	    item = xmlStrndup(cur, end - cur);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	call	_xmlStrndup
	mov	edi, eax

; 7990 : 	    if (xmlStrEqual(item, BAD_CAST "extension")) {

	push	OFFSET ??_C@_09ODADEDNA@extension@
	push	edi
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN145@xmlSchemaP

; 7991 : 		if (flagExtension != -1) {
; 7992 : 		    if ((*flags & flagExtension) == 0)

	mov	ecx, DWORD PTR _type$1$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	test	eax, 262144				; 00040000H
	jne	SHORT $LN165@xmlSchemaP

; 7993 : 			*flags |= flagExtension;

	or	eax, 262144				; 00040000H
	mov	DWORD PTR [ecx+48], eax

; 7994 : 		} else
; 7995 : 		    ret = 1;
; 7996 : 	    } else if (xmlStrEqual(item, BAD_CAST "restriction")) {

	jmp	SHORT $LN165@xmlSchemaP
$LN145@xmlSchemaP:
	push	OFFSET ??_C@_0M@FBFLGGFO@restriction@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN150@xmlSchemaP

; 7997 : 		if (flagRestriction != -1) {
; 7998 : 		    if ((*flags & flagRestriction) == 0)

	mov	ecx, DWORD PTR _type$1$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	test	eax, 524288				; 00080000H
	jne	SHORT $LN165@xmlSchemaP

; 7999 : 			*flags |= flagRestriction;

	or	eax, 524288				; 00080000H
	mov	DWORD PTR [ecx+48], eax

; 8000 : 		} else
; 8001 : 		    ret = 1;
; 8002 : 	    } else if (xmlStrEqual(item, BAD_CAST "substitution")) {

	jmp	SHORT $LN165@xmlSchemaP
$LN150@xmlSchemaP:
	push	OFFSET ??_C@_0N@INDADLAA@substitution@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN389@xmlSchemaP

; 8003 : 		if (flagSubstitution != -1) {
; 8004 : 		    if ((*flags & flagSubstitution) == 0)
; 8005 : 			*flags |= flagSubstitution;
; 8006 : 		} else
; 8007 : 		    ret = 1;
; 8008 : 	    } else if (xmlStrEqual(item, BAD_CAST "list")) {

	push	OFFSET ??_C@_04DONFEANM@list@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN389@xmlSchemaP

; 8009 : 		if (flagList != -1) {
; 8010 : 		    if ((*flags & flagList) == 0)
; 8011 : 			*flags |= flagList;
; 8012 : 		} else
; 8013 : 		    ret = 1;
; 8014 : 	    } else if (xmlStrEqual(item, BAD_CAST "union")) {

	push	OFFSET ??_C@_05MNALHJLP@union@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
$LN389@xmlSchemaP:

; 8015 : 		if (flagUnion != -1) {
; 8016 : 		    if ((*flags & flagUnion) == 0)
; 8017 : 			*flags |= flagUnion;
; 8018 : 		} else
; 8019 : 		    ret = 1;
; 8020 : 	    } else
; 8021 : 		ret = 1;
; 8022 : 	    if (item != NULL)

	mov	ebx, 1
$LN165@xmlSchemaP:
	test	edi, edi
	je	SHORT $LN170@xmlSchemaP

; 8023 : 		xmlFree(item);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN170@xmlSchemaP:

; 8024 : 	    cur = end;

	mov	ecx, esi

; 8025 : 	} while ((ret == 0) && (*cur != 0));

	test	ebx, ebx
	jne	SHORT $LN371@xmlSchemaP
	cmp	BYTE PTR [esi], bl
	jne	$LL125@xmlSchemaP
$LN369@xmlSchemaP:

; 12278: 			block = 1;
; 12279: 		} else {

	mov	ebx, DWORD PTR _attr$2$[ebp]
	mov	eax, 1
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	esi, DWORD PTR _type$1$[ebp]
	mov	DWORD PTR _block$1$[ebp], eax
	jmp	SHORT $LN36@xmlSchemaP
$LN371@xmlSchemaP:

; 8025 : 	} while ((ret == 0) && (*cur != 0));

	mov	edi, DWORD PTR _attrValue$2$[ebp]
$LN130@xmlSchemaP:

; 12272: 			xmlSchemaPSimpleTypeErr(ctxt,

	push	0
	push	0
	push	0
	push	edi
	push	OFFSET ??_C@_0CM@OCCOHGHC@?$CI?$CDall?5?$HM?5List?5of?5?$CIextension?5?$HM?5re@

; 12273: 			    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 12274: 			    NULL, (xmlNodePtr) attr, NULL,
; 12275: 			    "(#all | List of (extension | restriction)) ",
; 12276: 			    attrValue, NULL, NULL, NULL);
; 12277: 		    } else

	jmp	$LN390@xmlSchemaP
$LN14@xmlSchemaP:

; 12280: 			xmlSchemaPIllegalAttrErr(ctxt,
; 12281: 			    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 12282: 		}
; 12283: 	    } else {
; 12284: 		xmlSchemaPIllegalAttrErr(ctxt,
; 12285: 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 12286: 	    }
; 12287: 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN386@xmlSchemaP
$LN21@xmlSchemaP:

; 12288: 	    xmlSchemaPIllegalAttrErr(ctxt,
; 12289: 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 12290: 	}
; 12291: 	attr = attr->next;

	push	ebx
$LN32@xmlSchemaP:
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN386@xmlSchemaP:
	mov	eax, DWORD PTR _block$1$[ebp]
$LN36@xmlSchemaP:
	mov	ebx, DWORD PTR [ebx+24]
	mov	DWORD PTR _attr$2$[ebp], ebx
	test	ebx, ebx
	jne	$LL2@xmlSchemaP

; 12292:     }
; 12293:     if (! block) {

	test	eax, eax
	jne	SHORT $LN382@xmlSchemaP
$LN355@xmlSchemaP:

; 12294: 	/*
; 12295: 	* Apply default "block" values.
; 12296: 	*/
; 12297: 	if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION)

	mov	ecx, DWORD PTR _schema$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	test	al, al
	jns	SHORT $LN358@xmlSchemaP

; 12298: 	    type->flags |= XML_SCHEMAS_TYPE_BLOCK_RESTRICTION;

	or	DWORD PTR [esi+48], 524288		; 00080000H
	mov	eax, DWORD PTR [ecx+24]
$LN358@xmlSchemaP:

; 12299: 	if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION)

	test	al, 64					; 00000040H
	je	SHORT $LN39@xmlSchemaP

; 12300: 	    type->flags |= XML_SCHEMAS_TYPE_BLOCK_EXTENSION;

	or	DWORD PTR [esi+48], 262144		; 00040000H
	jmp	SHORT $LN39@xmlSchemaP
$LN382@xmlSchemaP:

; 12292:     }
; 12293:     if (! block) {

	mov	ecx, DWORD PTR _schema$[ebp]
$LN39@xmlSchemaP:

; 12301:     }
; 12302:     if (! final) {

	cmp	DWORD PTR _final$1$[ebp], 0
	jne	SHORT $LN42@xmlSchemaP

; 12303: 	/*
; 12304: 	* Apply default "block" values.
; 12305: 	*/
; 12306: 	if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION)

	mov	eax, DWORD PTR [ecx+24]
	test	al, 8
	je	SHORT $LN359@xmlSchemaP

; 12307: 	    type->flags |= XML_SCHEMAS_TYPE_FINAL_RESTRICTION;

	or	DWORD PTR [esi+48], 1024		; 00000400H
	mov	eax, DWORD PTR [ecx+24]
$LN359@xmlSchemaP:

; 12308: 	if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_EXTENSION)

	test	al, 4
	je	SHORT $LN42@xmlSchemaP

; 12309: 	    type->flags |= XML_SCHEMAS_TYPE_FINAL_EXTENSION;

	or	DWORD PTR [esi+48], 512			; 00000200H
$LN42@xmlSchemaP:

; 12310:     }
; 12311:     /*
; 12312:     * And now for the children...
; 12313:     */
; 12314:     child = node->children;

	mov	eax, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [eax+12]
	mov	edi, esi
	mov	DWORD PTR _child$[ebp], esi
	test	esi, esi

; 12315:     if (IS_SCHEMA(child, "annotation")) {

	je	SHORT $LN375@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN375@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN375@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	mov	ebx, DWORD PTR _ctxt$[ebp]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN43@xmlSchemaP

; 12316:         type->annot = xmlSchemaParseAnnotation(ctxt, child, 1);

	push	1
	push	esi
	push	ebx
	call	_xmlSchemaParseAnnotation
	mov	ecx, DWORD PTR _type$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+24], eax

; 12317:         child = child->next;

	mov	edi, DWORD PTR [esi+24]
	mov	esi, edi
	mov	DWORD PTR _child$[ebp], esi
	jmp	SHORT $LN43@xmlSchemaP
$LN375@xmlSchemaP:

; 12318:     }
; 12319:     ctxt->ctxtType = type;

	mov	ebx, DWORD PTR _ctxt$[ebp]
$LN43@xmlSchemaP:
	mov	eax, DWORD PTR _type$1$[ebp]
	mov	DWORD PTR [ebx+84], eax
	test	edi, edi

; 12320:     if (IS_SCHEMA(child, "simpleContent")) {

	je	$LN47@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	$LN47@xmlSchemaP
	push	OFFSET ??_C@_0O@EFHOFDNO@simpleContent@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN44@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN44@xmlSchemaP

; 12321: 	/*
; 12322: 	* <complexType><simpleContent>...
; 12323: 	* 3.4.3 : 2.2
; 12324: 	* Specifying mixed='true' when the <simpleContent>
; 12325: 	* alternative is chosen has no effect
; 12326: 	*/
; 12327: 	if (type->flags & XML_SCHEMAS_TYPE_MIXED)

	mov	ecx, DWORD PTR _type$1$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	test	al, 1
	je	SHORT $LN46@xmlSchemaP

; 12328: 	    type->flags ^= XML_SCHEMAS_TYPE_MIXED;

	xor	eax, 1
	mov	DWORD PTR [ecx+48], eax
$LN46@xmlSchemaP:

; 12329:         xmlSchemaParseSimpleContent(ctxt, schema, child,

	mov	edi, DWORD PTR _schema$[ebp]
	lea	eax, DWORD PTR _hasRestrictionOrExtension$[ebp]
	push	eax
	push	esi
	push	edi
	push	ebx
	call	_xmlSchemaParseSimpleContent
	add	esp, 16					; 00000010H

; 12330: 	    &hasRestrictionOrExtension);
; 12331:         child = child->next;

	jmp	$LN393@xmlSchemaP
$LN44@xmlSchemaP:

; 12332:     } else if (IS_SCHEMA(child, "complexContent")) {

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN47@xmlSchemaP
	push	OFFSET ??_C@_0P@LGKPFEB@complexContent@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN47@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN47@xmlSchemaP

; 12333: 	/*
; 12334: 	* <complexType><complexContent>...
; 12335: 	*/
; 12336: 	type->contentType = XML_SCHEMA_CONTENT_EMPTY;

	mov	eax, DWORD PTR _type$1$[ebp]

; 12337:         xmlSchemaParseComplexContent(ctxt, schema, child,

	mov	edi, DWORD PTR _schema$[ebp]
	mov	DWORD PTR [eax+52], 1
	lea	eax, DWORD PTR _hasRestrictionOrExtension$[ebp]
	push	eax
	push	esi
	push	edi
	push	ebx
	call	_xmlSchemaParseComplexContent
	add	esp, 16					; 00000010H

; 12338: 	    &hasRestrictionOrExtension);
; 12339:         child = child->next;
; 12340:     } else {

	jmp	$LN393@xmlSchemaP
$LN47@xmlSchemaP:

; 12341: 	/*
; 12342: 	* E.g <complexType><sequence>... or <complexType><attribute>... etc.
; 12343: 	*
; 12344: 	* SPEC
; 12345: 	* "...the third alternative (neither <simpleContent> nor
; 12346: 	* <complexContent>) is chosen. This case is understood as shorthand
; 12347: 	* for complex content restricting the `ur-type definition`, and the
; 12348: 	* details of the mappings should be modified as necessary.
; 12349: 	*/
; 12350: 	type->baseType = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);

	push	45					; 0000002dH
	call	_xmlSchemaGetBuiltInType
	mov	ecx, DWORD PTR _type$1$[ebp]
	add	esp, 4

; 12351: 	type->flags |= XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION;

	or	DWORD PTR [ecx+48], 4
	mov	DWORD PTR [ecx+64], eax
	test	edi, edi

; 12352: 	/*
; 12353: 	* Parse model groups.
; 12354: 	*/
; 12355:         if (IS_SCHEMA(child, "all")) {

	je	$LN381@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	$LN381@xmlSchemaP
	push	OFFSET ??_C@_03NFKEKGGK@all@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN49@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN49@xmlSchemaP

; 12356:             type->subtypes = (xmlSchemaTypePtr)

	mov	edi, DWORD PTR _schema$[ebp]
	push	1
	push	8
	push	esi
	push	edi
	push	ebx
	call	_xmlSchemaParseModelGroup
	mov	ecx, DWORD PTR _type$1$[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR [ecx+28], eax

; 12357: 		xmlSchemaParseModelGroup(ctxt, schema, child,
; 12358: 		    XML_SCHEMA_TYPE_ALL, 1);
; 12359:             child = child->next;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _child$[ebp], eax
	jmp	$LN55@xmlSchemaP
$LN49@xmlSchemaP:

; 12360:         } else if (IS_SCHEMA(child, "choice")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN381@xmlSchemaP
	push	OFFSET ??_C@_06DDDNEJEA@choice@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN51@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN51@xmlSchemaP

; 12361:             type->subtypes = (xmlSchemaTypePtr)

	mov	edi, DWORD PTR _schema$[ebp]
	push	1
	push	7
	push	esi
	push	edi
	push	ebx
	call	_xmlSchemaParseModelGroup
	mov	ecx, DWORD PTR _type$1$[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR [ecx+28], eax

; 12362: 		xmlSchemaParseModelGroup(ctxt, schema, child,
; 12363: 		    XML_SCHEMA_TYPE_CHOICE, 1);
; 12364:             child = child->next;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _child$[ebp], eax
	jmp	$LN55@xmlSchemaP
$LN51@xmlSchemaP:

; 12365:         } else if (IS_SCHEMA(child, "sequence")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN381@xmlSchemaP
	push	OFFSET ??_C@_08IBBDGPOF@sequence@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN53@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN53@xmlSchemaP

; 12366:             type->subtypes = (xmlSchemaTypePtr)

	mov	edi, DWORD PTR _schema$[ebp]
	push	1
	push	6
	push	esi
	push	edi
	push	ebx
	call	_xmlSchemaParseModelGroup
	mov	ecx, DWORD PTR _type$1$[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR [ecx+28], eax

; 12367: 		xmlSchemaParseModelGroup(ctxt, schema, child,
; 12368: 		    XML_SCHEMA_TYPE_SEQUENCE, 1);
; 12369:             child = child->next;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _child$[ebp], eax
	jmp	SHORT $LN55@xmlSchemaP
$LN53@xmlSchemaP:

; 12370:         } else if (IS_SCHEMA(child, "group")) {

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN381@xmlSchemaP
	push	OFFSET ??_C@_05MGJOOGAJ@group@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN381@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	mov	edi, DWORD PTR _schema$[ebp]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN55@xmlSchemaP

; 12371:             type->subtypes = (xmlSchemaTypePtr)

	push	esi
	push	edi
	push	ebx
	call	_xmlSchemaParseModelGroupDefRef
	mov	ecx, DWORD PTR _type$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+28], eax

; 12372: 		xmlSchemaParseModelGroupDefRef(ctxt, schema, child);
; 12373: 	    /*
; 12374: 	    * Note that the reference will be resolved in
; 12375: 	    * xmlSchemaResolveTypeReferences();
; 12376: 	    */
; 12377:             child = child->next;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _child$[ebp], eax
	jmp	SHORT $LN55@xmlSchemaP
$LN381@xmlSchemaP:

; 12378:         }
; 12379: 	/*
; 12380: 	* Parse attribute decls/refs.
; 12381: 	*/
; 12382:         if (xmlSchemaParseLocalAttributes(ctxt, schema, &child,
; 12383: 	    (xmlSchemaItemListPtr *) &(type->attrUses),
; 12384: 	    XML_SCHEMA_TYPE_RESTRICTION, NULL) == -1)

	mov	edi, DWORD PTR _schema$[ebp]
$LN55@xmlSchemaP:
	mov	eax, DWORD PTR _type$1$[ebp]
	push	0
	push	12					; 0000000cH
	add	eax, 116				; 00000074H
	push	eax
	lea	eax, DWORD PTR _child$[ebp]
	push	eax
	push	edi
	push	ebx
	call	_xmlSchemaParseLocalAttributes
	add	esp, 24					; 00000018H
	cmp	eax, -1
	je	$LN5@xmlSchemaP

; 12385: 	    return(NULL);
; 12386: 	/*
; 12387: 	* Parse attribute wildcard.
; 12388: 	*/
; 12389: 	if (IS_SCHEMA(child, "anyAttribute")) {

	mov	esi, DWORD PTR _child$[ebp]
	test	esi, esi
	je	$LN376@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN57@xmlSchemaP
	push	OFFSET ??_C@_0N@DDKCLMJG@anyAttribute@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN57@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN57@xmlSchemaP

; 12390: 	    type->attributeWildcard = xmlSchemaParseAnyAttribute(ctxt, schema, child);

	push	esi
	push	edi
	push	ebx
	call	_xmlSchemaParseAnyAttribute
	mov	ecx, DWORD PTR _type$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+84], eax
$LN393@xmlSchemaP:

; 12391: 	    child = child->next;
; 12392: 	}
; 12393:     }
; 12394:     if (child != NULL) {

	mov	esi, DWORD PTR [esi+24]
$LN57@xmlSchemaP:
	mov	edi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	SHORT $LN304@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	edi
	push	0
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0IH@OBLFEMHP@?$CIannotation?$DP?0?5?$CIsimpleContent?5?$HM?5@
	push	DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	ebx
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN304@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 12385: 	    return(NULL);
; 12386: 	/*
; 12387: 	* Parse attribute wildcard.
; 12388: 	*/
; 12389: 	if (IS_SCHEMA(child, "anyAttribute")) {

	jmp	SHORT $LN304@xmlSchemaP
$LN376@xmlSchemaP:
	mov	edi, DWORD PTR _node$[ebp]
$LN304@xmlSchemaP:

; 12395: 	xmlSchemaPContentErr(ctxt,
; 12396: 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 12397: 	    NULL, node, child,
; 12398: 	    NULL, "(annotation?, (simpleContent | complexContent | "
; 12399: 	    "((group | all | choice | sequence)?, ((attribute | "
; 12400: 	    "attributeGroup)*, anyAttribute?))))");
; 12401:     }
; 12402:     /*
; 12403:     * REDEFINE: SPEC src-redefine (5)
; 12404:     */
; 12405:     if (topLevel && ctxt->isRedefine && (! hasRestrictionOrExtension)) {

	cmp	DWORD PTR _topLevel$[ebp], 0
	je	SHORT $LN59@xmlSchemaP
	cmp	DWORD PTR [ebx+100], 0
	je	SHORT $LN59@xmlSchemaP
	cmp	DWORD PTR _hasRestrictionOrExtension$[ebp], 0
	jne	SHORT $LN59@xmlSchemaP

; 12406: 	xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_REDEFINE,

	push	0
	push	OFFSET ??_C@_0GE@BCLPNLHN@This?5is?5a?5redefinition?0?5thus?5th@
	push	edi
	push	0
	push	3081					; 00000c09H
	push	ebx
	call	_xmlSchemaPCustomErr
	add	esp, 24					; 00000018H
$LN59@xmlSchemaP:

; 12407: 	    NULL, node, "This is a redefinition, thus the "
; 12408: 	    "<complexType> must have a <restriction> or <extension> "
; 12409: 	    "grand-child", NULL);
; 12410:     }
; 12411:     ctxt->ctxtType = ctxtType;

	mov	eax, DWORD PTR _ctxtType$1$[ebp]
	pop	edi
	mov	DWORD PTR [ebx+84], eax

; 12412:     return (type);

	mov	eax, DWORD PTR _type$1$[ebp]

; 12413: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseComplexType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseSimpleType
_TEXT	SEGMENT
_attr$4$ = -16						; size = 4
_attrValue$2$ = -12					; size = 4
_hasRestriction$1$ = -8					; size = 4
_ret$1$ = -4						; size = 4
_des$1 = -4						; size = 4
_des$2 = -4						; size = 4
_attrValue$ = -4					; size = 4
_type$1$ = 8						; size = 4
_des$3 = 8						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_topLevel$ = 20						; size = 4
_xmlSchemaParseSimpleType PROC				; COMDAT

; 9176 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	mov	DWORD PTR _attrValue$[ebp], esi
	mov	DWORD PTR _hasRestriction$1$[ebp], esi
	test	ebx, ebx
	je	$LN7@xmlSchemaP

; 9177 :     xmlSchemaTypePtr type, oldCtxtType;
; 9178 :     xmlNodePtr child = NULL;
; 9179 :     const xmlChar *attrValue = NULL;
; 9180 :     xmlAttrPtr attr;
; 9181 :     int hasRestriction = 0;
; 9182 : 
; 9183 :     if ((ctxt == NULL) || (schema == NULL) || (node == NULL))

	mov	edx, DWORD PTR _schema$[ebp]
	test	edx, edx
	je	$LN7@xmlSchemaP
	mov	ecx, DWORD PTR _node$[ebp]
	test	ecx, ecx
	je	$LN7@xmlSchemaP

; 9184 :         return (NULL);
; 9185 : 
; 9186 :     if (topLevel) {

	mov	edi, DWORD PTR _topLevel$[ebp]
	test	edi, edi
	je	$LN14@xmlSchemaP

; 9187 : 	attr = xmlSchemaGetPropNode(node, "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	ecx
	call	_xmlSchemaGetPropNode
	mov	esi, eax
	add	esp, 8

; 9188 : 	if (attr == NULL) {

	test	esi, esi
	jne	SHORT $LN9@xmlSchemaP

; 2802 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	mov	esi, DWORD PTR _node$[ebp]
	push	esi
	push	eax
	push	eax
	mov	DWORD PTR _des$3[ebp], eax
	lea	eax, DWORD PTR _des$3[ebp]
	push	eax
	call	_xmlSchemaFormatItemForReport

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	mov	eax, DWORD PTR _des$3[ebp]
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	push	OFFSET ??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	inc	DWORD PTR [ebx+20]
	push	0
	push	0
	push	2
	push	3036					; 00000bdcH
	push	16					; 00000010H
	push	esi
	push	ebx
	push	DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx+16], 3036		; 00000bdcH
	push	DWORD PTR [ebx+8]
	push	DWORD PTR [ebx+24]
	call	___xmlRaiseError

; 2810 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$3[ebp]

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 88					; 00000058H

; 2810 :     FREE_AND_NULL(des);

	test	eax, eax
	je	SHORT $LN7@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlSchemaP:
	pop	edi

; 9374 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlSchemaP:

; 9189 : 	    xmlSchemaPMissingAttrErr(ctxt,
; 9190 : 		XML_SCHEMAP_S4S_ATTR_MISSING,
; 9191 : 		NULL, node,
; 9192 : 		"name", NULL);
; 9193 : 	    return (NULL);
; 9194 : 	} else {
; 9195 : 	    if (xmlSchemaPValAttrNode(ctxt,
; 9196 : 		NULL, attr,
; 9197 : 		xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &attrValue) != 0)

	lea	eax, DWORD PTR _attrValue$[ebp]
	push	eax
	push	22					; 00000016H
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	push	eax
	push	esi
	push	0
	push	ebx
	call	_xmlSchemaPValAttrNode
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN7@xmlSchemaP

; 9198 : 		return (NULL);
; 9199 : 	    /*
; 9200 : 	    * Skip built-in types.
; 9201 : 	    */
; 9202 : 	    if (ctxt->isS4S) {

	cmp	DWORD PTR [ebx+96], eax
	je	SHORT $LN181@xmlSchemaP

; 9203 : 		xmlSchemaTypePtr biType;
; 9204 : 
; 9205 : 		if (ctxt->isRedefine) {

	cmp	DWORD PTR [ebx+100], eax
	je	SHORT $LN13@xmlSchemaP

; 9206 : 		    /*
; 9207 : 		    * REDEFINE: Disallow redefinition of built-in-types.
; 9208 : 		    * TODO: It seems that the spec does not say anything
; 9209 : 		    * about this case.
; 9210 : 		    */
; 9211 : 		    xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_REDEFINE,

	push	eax
	mov	eax, DWORD PTR _node$[ebp]
	push	OFFSET ??_C@_0DH@OIPDFCAL@Redefinition?5of?5built?9in?5simple@
	push	eax
	push	0
	push	3081					; 00000c09H
	push	ebx
	call	_xmlSchemaPCustomErr
	add	esp, 24					; 00000018H

; 9374 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlSchemaP:

; 9212 : 			NULL, node,
; 9213 : 			"Redefinition of built-in simple types is not "
; 9214 : 			"supported", NULL);
; 9215 : 		    return(NULL);
; 9216 : 		}
; 9217 : 		biType = xmlSchemaGetPredefinedType(attrValue, xmlSchemaNs);

	push	DWORD PTR _xmlSchemaNs
	mov	esi, DWORD PTR _attrValue$[ebp]
	push	esi
	call	_xmlSchemaGetPredefinedType
	add	esp, 8

; 9218 : 		if (biType != NULL)

	test	eax, eax
	je	SHORT $LN185@xmlSchemaP

; 9374 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN181@xmlSchemaP:

; 9198 : 		return (NULL);
; 9199 : 	    /*
; 9200 : 	    * Skip built-in types.
; 9201 : 	    */
; 9202 : 	    if (ctxt->isS4S) {

	mov	esi, DWORD PTR _attrValue$[ebp]
$LN185@xmlSchemaP:

; 9219 : 		    return (biType);
; 9220 : 	    }
; 9221 : 	}
; 9222 :     }
; 9223 :     /*
; 9224 :     * TargetNamespace:
; 9225 :     * SPEC "The `actual value` of the targetNamespace [attribute]
; 9226 :     * of the <schema> ancestor element information item if present,
; 9227 :     * otherwise `absent`.
; 9228 :     */
; 9229 :     if (topLevel == 0) {

	mov	edx, DWORD PTR _schema$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
$LN14@xmlSchemaP:
	mov	eax, DWORD PTR [ebx+112]
	test	edi, edi
	jne	$LN15@xmlSchemaP

; 9230 : #ifdef ENABLE_NAMED_LOCALS
; 9231 :         char buf[40];
; 9232 : #endif
; 9233 : 	/*
; 9234 : 	* Parse as local simple type definition.
; 9235 : 	*/
; 9236 : #ifdef ENABLE_NAMED_LOCALS
; 9237 :         snprintf(buf, 39, "#ST%d", ctxt->counter++ + 1);
; 9238 : 	type = xmlSchemaAddType(ctxt, schema,
; 9239 : 	    XML_SCHEMA_TYPE_SIMPLE,
; 9240 : 	    xmlDictLookup(ctxt->dict, (const xmlChar *)buf, -1),
; 9241 : 	    ctxt->targetNamespace, node, 0);
; 9242 : #else
; 9243 : 	type = xmlSchemaAddType(ctxt, schema,

	push	edi
	push	ecx
	push	eax
	push	edi
	push	4
	push	edx
	push	ebx
	call	_xmlSchemaAddType
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _type$1$[ebp], eax

; 9244 : 	    XML_SCHEMA_TYPE_SIMPLE,
; 9245 : 	    NULL, ctxt->targetNamespace, node, 0);
; 9246 : #endif
; 9247 : 	if (type == NULL)

	test	eax, eax
	je	$LN7@xmlSchemaP

; 9248 : 	    return (NULL);
; 9249 : 	type->type = XML_SCHEMA_TYPE_SIMPLE;

	mov	DWORD PTR [eax], 4

; 9250 : 	type->contentType = XML_SCHEMA_CONTENT_SIMPLE;

	mov	DWORD PTR [eax+52], 4

; 9251 : 	/*
; 9252 : 	* Check for illegal attributes.
; 9253 : 	*/
; 9254 : 	attr = node->properties;

	mov	eax, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [eax+44]

; 9255 : 	while (attr != NULL) {

	test	esi, esi
	je	$LN32@xmlSchemaP
	npad	2
$LL2@xmlSchemaP:

; 9256 : 	    if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN18@xmlSchemaP

; 9257 : 		if (!xmlStrEqual(attr->name, BAD_CAST "id")) {

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@xmlSchemaP

; 9258 : 		    xmlSchemaPIllegalAttrErr(ctxt,
; 9259 : 			XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 9260 : 		}

	jmp	SHORT $LN187@xmlSchemaP
$LN18@xmlSchemaP:

; 9261 : 	    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@xmlSchemaP
$LN187@xmlSchemaP:

; 9262 : 		    xmlSchemaPIllegalAttrErr(ctxt,
; 9263 : 			XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 9264 : 	    }
; 9265 : 	    attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	ebx
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN21@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaP

; 9266 : 	}
; 9267 :     } else {

	jmp	$LN32@xmlSchemaP
$LN15@xmlSchemaP:

; 9268 : 	/*
; 9269 : 	* Parse as global simple type definition.
; 9270 : 	*
; 9271 : 	* Note that attrValue is the value of the attribute "name" here.
; 9272 : 	*/
; 9273 : 	type = xmlSchemaAddType(ctxt, schema, XML_SCHEMA_TYPE_SIMPLE,

	push	1
	push	ecx
	push	eax
	push	esi
	push	4
	push	edx
	push	ebx
	call	_xmlSchemaAddType
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _type$1$[ebp], eax

; 9274 : 	    attrValue, ctxt->targetNamespace, node, 1);
; 9275 : 	if (type == NULL)

	test	eax, eax
	je	$LN7@xmlSchemaP

; 9276 : 	    return (NULL);
; 9277 : 	type->type = XML_SCHEMA_TYPE_SIMPLE;
; 9278 : 	type->contentType = XML_SCHEMA_CONTENT_SIMPLE;
; 9279 : 	type->flags |= XML_SCHEMAS_TYPE_GLOBAL;

	or	DWORD PTR [eax+48], 8
	lea	edi, DWORD PTR [eax+48]
	mov	DWORD PTR [eax], 4
	mov	DWORD PTR [eax+52], 4

; 9280 : 	/*
; 9281 : 	* Check for illegal attributes.
; 9282 : 	*/
; 9283 : 	attr = node->properties;

	mov	eax, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [eax+44]

; 9284 : 	while (attr != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlSchemaP
	npad	7
$LL4@xmlSchemaP:

; 9285 : 	    if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN23@xmlSchemaP

; 9286 : 		if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
; 9287 : 		    (!xmlStrEqual(attr->name, BAD_CAST "name")) &&

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@xmlSchemaP
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@xmlSchemaP
	push	OFFSET ??_C@_05FPBGKCKL@final@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@xmlSchemaP

; 9288 : 		    (!xmlStrEqual(attr->name, BAD_CAST "final"))) {
; 9289 : 		    xmlSchemaPIllegalAttrErr(ctxt,
; 9290 : 			XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 9291 : 		}

	jmp	SHORT $LN188@xmlSchemaP
$LN23@xmlSchemaP:

; 9292 : 	    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN26@xmlSchemaP
$LN188@xmlSchemaP:

; 9293 : 		xmlSchemaPIllegalAttrErr(ctxt,
; 9294 : 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 9295 : 	    }
; 9296 : 	    attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	ebx
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN26@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL4@xmlSchemaP
$LN5@xmlSchemaP:

; 9297 : 	}
; 9298 : 	/*
; 9299 : 	* Attribute "final".
; 9300 : 	*/
; 9301 : 	attr = xmlSchemaGetPropNode(node, "final");

	mov	esi, DWORD PTR _node$[ebp]
	push	OFFSET ??_C@_05FPBGKCKL@final@
	push	esi
	call	_xmlSchemaGetPropNode
	add	esp, 8
	mov	DWORD PTR _attr$4$[ebp], eax

; 9302 : 	if (attr == NULL) {

	test	eax, eax
	jne	SHORT $LN27@xmlSchemaP

; 9303 : 	    if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION)

	mov	ecx, DWORD PTR _schema$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	test	al, 8
	je	SHORT $LN177@xmlSchemaP

; 9304 : 		type->flags |= XML_SCHEMAS_TYPE_FINAL_RESTRICTION;

	or	DWORD PTR [edi], 1024			; 00000400H
	mov	eax, DWORD PTR [ecx+24]
$LN177@xmlSchemaP:

; 9305 : 	    if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_LIST)

	test	al, 16					; 00000010H
	je	SHORT $LN178@xmlSchemaP

; 9306 : 		type->flags |= XML_SCHEMAS_TYPE_FINAL_LIST;

	or	DWORD PTR [edi], 2048			; 00000800H
	mov	eax, DWORD PTR [ecx+24]
$LN178@xmlSchemaP:

; 9307 : 	    if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_UNION)

	test	al, 32					; 00000020H
	je	$LN32@xmlSchemaP

; 9308 : 		type->flags |= XML_SCHEMAS_TYPE_FINAL_UNION;

	or	DWORD PTR [edi], 4096			; 00001000H

; 9309 : 	} else {

	jmp	$LN32@xmlSchemaP
$LN27@xmlSchemaP:

; 9310 : 	    attrValue = xmlSchemaGetProp(ctxt, node, "final");

	push	OFFSET ??_C@_05FPBGKCKL@final@
	push	esi
	push	ebx
	call	_xmlSchemaGetProp
	add	esp, 12					; 0000000cH

; 7953 :     int ret = 0;

	mov	DWORD PTR _ret$1$[ebp], 0

; 9310 : 	    attrValue = xmlSchemaGetProp(ctxt, node, "final");

	mov	esi, eax
	mov	DWORD PTR _attrValue$2$[ebp], esi

; 7958 :     if ((flags == NULL) || (value == NULL))

	test	edi, edi
	je	$LN61@xmlSchemaP
	test	esi, esi
	je	$LN61@xmlSchemaP

; 7959 : 	return (-1);
; 7960 :     if (value[0] == 0)

	cmp	BYTE PTR [esi], 0
	je	$LN32@xmlSchemaP

; 7961 : 	return (0);
; 7962 :     if (xmlStrEqual(value, BAD_CAST "#all")) {

	push	OFFSET ??_C@_04LEKDNLLP@?$CDall@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN63@xmlSchemaP

; 7963 : 	if (flagAll != -1)
; 7964 : 	    *flags |= flagAll;
; 7965 : 	else {
; 7966 : 	    if (flagExtension != -1)
; 7967 : 		*flags |= flagExtension;
; 7968 : 	    if (flagRestriction != -1)
; 7969 : 		*flags |= flagRestriction;
; 7970 : 	    if (flagSubstitution != -1)
; 7971 : 		*flags |= flagSubstitution;
; 7972 : 	    if (flagList != -1)
; 7973 : 		*flags |= flagList;
; 7974 : 	    if (flagUnion != -1)
; 7975 : 		*flags |= flagUnion;

	or	DWORD PTR [edi], 7168			; 00001c00H

; 7976 : 	}
; 7977 :     } else {

	jmp	$LN32@xmlSchemaP
$LN63@xmlSchemaP:

; 7978 : 	const xmlChar *end, *cur = value;

	mov	ecx, esi
$LL56@xmlSchemaP:

; 7979 : 	xmlChar *item;
; 7980 : 
; 7981 : 	do {
; 7982 : 	    while (IS_BLANK_CH(*cur))

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN72@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN73@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN72@xmlSchemaP
$LN73@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN57@xmlSchemaP
$LN72@xmlSchemaP:

; 7983 : 		cur++;

	inc	ecx
	jmp	SHORT $LL56@xmlSchemaP
$LN57@xmlSchemaP:

; 7984 : 	    end = cur;

	mov	esi, ecx

; 7985 : 	    while ((*end != 0) && (!(IS_BLANK_CH(*end))))

	test	al, al
	je	$LN32@xmlSchemaP
	npad	1
$LL58@xmlSchemaP:
	cmp	al, 32					; 00000020H
	je	SHORT $LN59@xmlSchemaP
	cmp	al, 9
	jb	SHORT $LN74@xmlSchemaP
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN59@xmlSchemaP
$LN74@xmlSchemaP:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN59@xmlSchemaP
	mov	al, BYTE PTR [esi+1]

; 7986 : 		end++;

	inc	esi
	test	al, al
	jne	SHORT $LL58@xmlSchemaP
$LN59@xmlSchemaP:

; 7987 : 	    if (end == cur)

	cmp	esi, ecx
	je	$LN32@xmlSchemaP

; 7988 : 		break;
; 7989 : 	    item = xmlStrndup(cur, end - cur);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	call	_xmlStrndup
	mov	edi, eax

; 7990 : 	    if (xmlStrEqual(item, BAD_CAST "extension")) {

	push	OFFSET ??_C@_09ODADEDNA@extension@
	push	edi
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN96@xmlSchemaP

; 7991 : 		if (flagExtension != -1) {
; 7992 : 		    if ((*flags & flagExtension) == 0)
; 7993 : 			*flags |= flagExtension;
; 7994 : 		} else
; 7995 : 		    ret = 1;
; 7996 : 	    } else if (xmlStrEqual(item, BAD_CAST "restriction")) {

	push	OFFSET ??_C@_0M@FBFLGGFO@restriction@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN81@xmlSchemaP

; 7997 : 		if (flagRestriction != -1) {
; 7998 : 		    if ((*flags & flagRestriction) == 0)

	mov	ecx, DWORD PTR _type$1$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	test	eax, 1024				; 00000400H
	jne	SHORT $LN97@xmlSchemaP

; 7999 : 			*flags |= flagRestriction;

	or	eax, 1024				; 00000400H
	mov	DWORD PTR [ecx+48], eax

; 8000 : 		} else
; 8001 : 		    ret = 1;
; 8002 : 	    } else if (xmlStrEqual(item, BAD_CAST "substitution")) {

	jmp	SHORT $LN97@xmlSchemaP
$LN81@xmlSchemaP:
	push	OFFSET ??_C@_0N@INDADLAA@substitution@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN96@xmlSchemaP

; 8003 : 		if (flagSubstitution != -1) {
; 8004 : 		    if ((*flags & flagSubstitution) == 0)
; 8005 : 			*flags |= flagSubstitution;
; 8006 : 		} else
; 8007 : 		    ret = 1;
; 8008 : 	    } else if (xmlStrEqual(item, BAD_CAST "list")) {

	push	OFFSET ??_C@_04DONFEANM@list@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN91@xmlSchemaP

; 8009 : 		if (flagList != -1) {
; 8010 : 		    if ((*flags & flagList) == 0)

	mov	ecx, DWORD PTR _type$1$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	test	eax, 2048				; 00000800H
	jne	SHORT $LN97@xmlSchemaP

; 8011 : 			*flags |= flagList;

	or	eax, 2048				; 00000800H
	mov	DWORD PTR [ecx+48], eax

; 8012 : 		} else
; 8013 : 		    ret = 1;
; 8014 : 	    } else if (xmlStrEqual(item, BAD_CAST "union")) {

	jmp	SHORT $LN97@xmlSchemaP
$LN91@xmlSchemaP:
	push	OFFSET ??_C@_05MNALHJLP@union@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN96@xmlSchemaP

; 8015 : 		if (flagUnion != -1) {
; 8016 : 		    if ((*flags & flagUnion) == 0)

	mov	ecx, DWORD PTR _type$1$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	test	eax, 4096				; 00001000H
	jne	SHORT $LN97@xmlSchemaP

; 8017 : 			*flags |= flagUnion;

	or	eax, 4096				; 00001000H
	mov	DWORD PTR [ecx+48], eax

; 8018 : 		} else
; 8019 : 		    ret = 1;
; 8020 : 	    } else

	jmp	SHORT $LN97@xmlSchemaP
$LN96@xmlSchemaP:

; 8021 : 		ret = 1;
; 8022 : 	    if (item != NULL)

	mov	DWORD PTR _ret$1$[ebp], 1
$LN97@xmlSchemaP:
	test	edi, edi
	je	SHORT $LN101@xmlSchemaP

; 8023 : 		xmlFree(item);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN101@xmlSchemaP:

; 8024 : 	    cur = end;
; 8025 : 	} while ((ret == 0) && (*cur != 0));

	cmp	DWORD PTR _ret$1$[ebp], 0
	mov	ecx, esi
	jne	SHORT $LN186@xmlSchemaP
	cmp	BYTE PTR [esi], 0
	jne	$LL56@xmlSchemaP

; 7979 : 	xmlChar *item;
; 7980 : 
; 7981 : 	do {
; 7982 : 	    while (IS_BLANK_CH(*cur))

	jmp	SHORT $LN32@xmlSchemaP
$LN186@xmlSchemaP:

; 8024 : 	    cur = end;
; 8025 : 	} while ((ret == 0) && (*cur != 0));

	mov	esi, DWORD PTR _attrValue$2$[ebp]
$LN61@xmlSchemaP:

; 9311 : 	    if (xmlSchemaPValAttrBlockFinal(attrValue, &(type->flags),
; 9312 : 		-1, -1, XML_SCHEMAS_TYPE_FINAL_RESTRICTION, -1,
; 9313 : 		XML_SCHEMAS_TYPE_FINAL_LIST,
; 9314 : 		XML_SCHEMAS_TYPE_FINAL_UNION) != 0) {
; 9315 : 
; 9316 : 		xmlSchemaPSimpleTypeErr(ctxt,

	push	0
	push	0
	push	0
	push	esi
	push	OFFSET ??_C@_0CN@IJLHAKIE@?$CI?$CDall?5?$HM?5List?5of?5?$CIlist?5?$HM?5union?5?$HM@
	push	0
	push	DWORD PTR _attr$4$[ebp]
	push	DWORD PTR _type$1$[ebp]
	push	3037					; 00000bddH
	push	ebx
	call	_xmlSchemaPSimpleTypeErr
	add	esp, 40					; 00000028H
$LN32@xmlSchemaP:

; 9317 : 		    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 9318 : 		    WXS_BASIC_CAST type, (xmlNodePtr) attr,
; 9319 : 		    NULL, "(#all | List of (list | union | restriction)",
; 9320 : 		    attrValue, NULL, NULL, NULL);
; 9321 : 	    }
; 9322 : 	}
; 9323 :     }
; 9324 :     type->targetNamespace = ctxt->targetNamespace;

	mov	ecx, DWORD PTR _type$1$[ebp]

; 9325 :     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");

	mov	esi, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ebx+112]
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	esi
	push	ebx
	mov	DWORD PTR [ecx+112], eax
	call	_xmlSchemaPValAttrID

; 9326 :     /*
; 9327 :     * And now for the children...
; 9328 :     */
; 9329 :     oldCtxtType = ctxt->ctxtType;

	mov	edi, DWORD PTR [ebx+84]
	add	esp, 12					; 0000000cH

; 9330 : 
; 9331 :     ctxt->ctxtType = type;

	mov	eax, DWORD PTR _type$1$[ebp]
	mov	DWORD PTR [ebx+84], eax

; 9332 : 
; 9333 :     child = node->children;

	mov	esi, DWORD PTR [esi+12]

; 9334 :     if (IS_SCHEMA(child, "annotation")) {

	test	esi, esi
	je	SHORT $LN190@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN33@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@xmlSchemaP

; 9335 :         type->annot = xmlSchemaParseAnnotation(ctxt, child, 1);

	push	1
	push	esi
	push	ebx
	call	_xmlSchemaParseAnnotation
	mov	ecx, DWORD PTR _type$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+24], eax

; 9336 :         child = child->next;

	mov	esi, DWORD PTR [esi+24]
$LN33@xmlSchemaP:

; 9337 :     }
; 9338 :     if (child == NULL) {

	test	esi, esi
	jne	SHORT $LN34@xmlSchemaP
$LN190@xmlSchemaP:

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	mov	esi, DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$2[ebp]
	push	esi
	push	0
	push	0
	push	eax
	mov	DWORD PTR _des$2[ebp], 0
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0CM@MDINDAN@?$CIannotation?$DP?0?5?$CIrestriction?5?$HM?5li@
	push	DWORD PTR _des$2[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3034					; 00000bdaH
	push	esi
	push	ebx
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$2[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	$LN134@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3242 : }

	jmp	$LN134@xmlSchemaP
$LN34@xmlSchemaP:

; 9339 : 	xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_MISSING,
; 9340 : 	    NULL, node, child, NULL,
; 9341 : 	    "(annotation?, (restriction | list | union))");
; 9342 :     } else if (IS_SCHEMA(child, "restriction")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN40@xmlSchemaP
	push	OFFSET ??_C@_0M@FBFLGGFO@restriction@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN36@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN36@xmlSchemaP

; 9343 :         xmlSchemaParseRestriction(ctxt, schema, child,

	push	4
	push	esi
	push	DWORD PTR _schema$[ebp]
	push	ebx
	call	_xmlSchemaParseRestriction
	add	esp, 16					; 00000010H

; 9344 : 	    XML_SCHEMA_TYPE_SIMPLE);
; 9345 : 	hasRestriction = 1;

	mov	DWORD PTR _hasRestriction$1$[ebp], 1

; 9346 :         child = child->next;

	jmp	$LN193@xmlSchemaP
$LN36@xmlSchemaP:

; 9347 :     } else if (IS_SCHEMA(child, "list")) {

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN40@xmlSchemaP
	push	OFFSET ??_C@_04DONFEANM@list@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN38@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN38@xmlSchemaP

; 9348 :         xmlSchemaParseList(ctxt, schema, child);

	push	esi
	push	DWORD PTR _schema$[ebp]
	push	ebx
	call	_xmlSchemaParseList

; 9349 :         child = child->next;

	jmp	SHORT $LN194@xmlSchemaP
$LN38@xmlSchemaP:

; 9350 :     } else if (IS_SCHEMA(child, "union")) {

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN40@xmlSchemaP
	push	OFFSET ??_C@_05MNALHJLP@union@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN40@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN40@xmlSchemaP

; 9351 :         xmlSchemaParseUnion(ctxt, schema, child);

	push	esi
	push	DWORD PTR _schema$[ebp]
	push	ebx
	call	_xmlSchemaParseUnion
$LN194@xmlSchemaP:

; 9352 :         child = child->next;
; 9353 :     }
; 9354 :     if (child != NULL) {

	add	esp, 12					; 0000000cH
$LN193@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
$LN40@xmlSchemaP:
	test	esi, esi
	je	SHORT $LN184@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	push	0
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0CM@MDINDAN@?$CIannotation?$DP?0?5?$CIrestriction?5?$HM?5li@
	push	DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	ebx
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN184@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN184@xmlSchemaP:

; 9355 : 	xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 9356 : 	    NULL, node, child, NULL,
; 9357 : 	    "(annotation?, (restriction | list | union))");
; 9358 :     }
; 9359 :     /*
; 9360 :     * REDEFINE: SPEC src-redefine (5)
; 9361 :     * "Within the [children], each <simpleType> must have a
; 9362 :     * <restriction> among its [children] ... the `actual value` of whose
; 9363 :     * base [attribute] must be the same as the `actual value` of its own
; 9364 :     * name attribute plus target namespace;"
; 9365 :     */
; 9366 :     if (topLevel && ctxt->isRedefine && (! hasRestriction)) {

	mov	esi, DWORD PTR _node$[ebp]
$LN134@xmlSchemaP:
	cmp	DWORD PTR _topLevel$[ebp], 0
	je	SHORT $LN42@xmlSchemaP
	cmp	DWORD PTR [ebx+100], 0
	je	SHORT $LN42@xmlSchemaP
	cmp	DWORD PTR _hasRestriction$1$[ebp], 0
	jne	SHORT $LN42@xmlSchemaP

; 9367 : 	xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_REDEFINE,

	push	0
	push	OFFSET ??_C@_0EO@JDMIJKLB@This?5is?5a?5redefinition?0?5thus?5th@
	push	esi
	push	0
	push	3081					; 00000c09H
	push	ebx
	call	_xmlSchemaPCustomErr
	add	esp, 24					; 00000018H
$LN42@xmlSchemaP:

; 9368 : 	    NULL, node, "This is a redefinition, thus the "
; 9369 : 	    "<simpleType> must have a <restriction> child", NULL);
; 9370 :     }
; 9371 : 
; 9372 :     ctxt->ctxtType = oldCtxtType;
; 9373 :     return (type);

	mov	eax, DWORD PTR _type$1$[ebp]
	mov	DWORD PTR [ebx+84], edi
	pop	edi

; 9374 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseSimpleType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlGetBooleanProp
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_name$ = 16						; size = 4
_def$ = 20						; size = 4
_xmlGetBooleanProp PROC					; COMDAT

; 6224 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4

; 4741 :     val = xmlGetNoNsProp(node, BAD_CAST name);

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _node$[ebp]
	call	_xmlGetNoNsProp
	mov	edi, eax
	add	esp, 8

; 4742 :     if (val == NULL)

	test	edi, edi
	je	$LN15@xmlGetBool

; 4743 :         return(NULL);
; 4744 :     ret = xmlDictLookup(ctxt->dict, val, -1);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	-1
	push	edi
	push	DWORD PTR [eax+80]
	call	_xmlDictLookup

; 4745 :     xmlFree(val);

	push	edi
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H

; 6225 :     const xmlChar *val;
; 6226 : 
; 6227 :     val = xmlSchemaGetProp(ctxt, node, name);
; 6228 :     if (val == NULL)

	test	esi, esi
	je	$LN15@xmlGetBool

; 6229 :         return (def);
; 6230 :     /*
; 6231 :     * 3.2.2.1 Lexical representation
; 6232 :     * An instance of a datatype that is defined as `boolean`
; 6233 :     * can have the following legal literals {true, false, 1, 0}.
; 6234 :     */
; 6235 :     if (xmlStrEqual(val, BAD_CAST "true"))

	push	OFFSET ??_C@_04LOAJBDKD@true@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@xmlGetBool

; 6236 :         def = 1;
; 6237 :     else if (xmlStrEqual(val, BAD_CAST "false"))

	push	OFFSET ??_C@_05LAPONLG@false@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@xmlGetBool

; 6238 :         def = 0;
; 6239 :     else if (xmlStrEqual(val, BAD_CAST "1"))

	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@xmlGetBool
$LN17@xmlGetBool:
	pop	edi

; 6245 : 	    XML_SCHEMAP_INVALID_BOOLEAN,
; 6246 : 	    NULL,
; 6247 : 	    (xmlNodePtr) xmlSchemaGetPropNode(node, name),
; 6248 : 	    xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
; 6249 : 	    NULL, val, NULL, NULL, NULL);
; 6250 :     }
; 6251 :     return (def);
; 6252 : }

	mov	eax, 1
	pop	esi
	pop	ebp
	ret	0
$LN7@xmlGetBool:

; 6240 : 	def = 1;
; 6241 :     else if (xmlStrEqual(val, BAD_CAST "0"))

	push	OFFSET ??_C@_01GBGANLPD@0@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlGetBool
$LN16@xmlGetBool:
	pop	edi

; 6245 : 	    XML_SCHEMAP_INVALID_BOOLEAN,
; 6246 : 	    NULL,
; 6247 : 	    (xmlNodePtr) xmlSchemaGetPropNode(node, name),
; 6248 : 	    xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
; 6249 : 	    NULL, val, NULL, NULL, NULL);
; 6250 :     }
; 6251 :     return (def);
; 6252 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN9@xmlGetBool:

; 6242 :         def = 0;
; 6243 :     else {
; 6244 :         xmlSchemaPSimpleTypeErr(ctxt,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	15					; 0000000fH
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	push	eax
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _node$[ebp]
	call	_xmlSchemaGetPropNode
	add	esp, 8
	push	eax
	push	0
	push	1714					; 000006b2H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPSimpleTypeErr
	add	esp, 40					; 00000028H
$LN15@xmlGetBool:

; 6245 : 	    XML_SCHEMAP_INVALID_BOOLEAN,
; 6246 : 	    NULL,
; 6247 : 	    (xmlNodePtr) xmlSchemaGetPropNode(node, name),
; 6248 : 	    xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
; 6249 : 	    NULL, val, NULL, NULL, NULL);
; 6250 :     }
; 6251 :     return (def);
; 6252 : }

	mov	eax, DWORD PTR _def$[ebp]
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlGetBooleanProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPGetBoolNodeValue
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_ownerItem$ = 12					; size = 4
_node$ = 16						; size = 4
_xmlSchemaPGetBoolNodeValue PROC			; COMDAT

; 6177 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _node$[ebp]
	xor	esi, esi
	call	_xmlNodeGetContent
	mov	edi, eax
	push	OFFSET ??_C@_04LOAJBDKD@true@
	push	edi
	call	_xmlStrEqual
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@xmlSchemaP

; 6178 :     xmlChar *value = NULL;
; 6179 :     int res = 0;
; 6180 : 
; 6181 :     value = xmlNodeGetContent(node);
; 6182 :     /*
; 6183 :     * 3.2.2.1 Lexical representation
; 6184 :     * An instance of a datatype that is defined as `boolean`
; 6185 :     * can have the following legal literals {true, false, 1, 0}.
; 6186 :     */
; 6187 :     if (xmlStrEqual(BAD_CAST value, BAD_CAST "true"))
; 6188 :         res = 1;

	mov	esi, 1
	jmp	SHORT $LN9@xmlSchemaP
$LN2@xmlSchemaP:

; 6189 :     else if (xmlStrEqual(BAD_CAST value, BAD_CAST "false"))

	push	OFFSET ??_C@_05LAPONLG@false@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@xmlSchemaP

; 6190 :         res = 0;

	xor	esi, esi
	jmp	SHORT $LN9@xmlSchemaP
$LN4@xmlSchemaP:

; 6191 :     else if (xmlStrEqual(BAD_CAST value, BAD_CAST "1"))

	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlSchemaP

; 6192 : 	res = 1;

	mov	esi, 1
	jmp	SHORT $LN9@xmlSchemaP
$LN6@xmlSchemaP:

; 6193 :     else if (xmlStrEqual(BAD_CAST value, BAD_CAST "0"))

	push	OFFSET ??_C@_01GBGANLPD@0@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlSchemaP

; 6194 :         res = 0;

	xor	esi, esi
	jmp	SHORT $LN9@xmlSchemaP
$LN8@xmlSchemaP:

; 6195 :     else {
; 6196 :         xmlSchemaPSimpleTypeErr(ctxt,

	push	0
	push	0
	push	0
	push	edi
	push	0
	push	15					; 0000000fH
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	push	eax
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _ownerItem$[ebp]
	push	1714					; 000006b2H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPSimpleTypeErr
	add	esp, 40					; 00000028H
$LN9@xmlSchemaP:

; 6197 : 	    XML_SCHEMAP_INVALID_BOOLEAN,
; 6198 : 	    ownerItem, node,
; 6199 : 	    xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
; 6200 : 	    NULL, BAD_CAST value,
; 6201 : 	    NULL, NULL, NULL);
; 6202 :     }
; 6203 :     if (value != NULL)

	test	edi, edi
	je	SHORT $LN12@xmlSchemaP

; 6204 : 	xmlFree(value);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlSchemaP:

; 6205 :     return (res);
; 6206 : }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	0
_xmlSchemaPGetBoolNodeValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlGetMinOccurs
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_ret$1$ = 12						; size = 4
_node$ = 12						; size = 4
_min$ = 16						; size = 4
_max$ = 20						; size = 4
_def$ = 24						; size = 4
_expected$ = 28						; size = 4
_xmlGetMinOccurs PROC					; COMDAT

; 6122 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4

; 4664 :     if ((node == NULL) || (name == NULL))

	mov	esi, DWORD PTR _node$[ebp]

; 6123 :     const xmlChar *val, *cur;
; 6124 :     int ret = 0;

	xor	ebx, ebx

; 4664 :     if ((node == NULL) || (name == NULL))

	test	esi, esi
	je	SHORT $LN45@xmlGetMinO

; 4665 : 	return(NULL);
; 4666 :     prop = node->properties;

	mov	esi, DWORD PTR [esi+44]

; 4667 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN45@xmlGetMinO
	npad	1
$LL18@xmlGetMinO:

; 4668 :         if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))

	cmp	DWORD PTR [esi+36], ebx
	jne	SHORT $LN22@xmlGetMinO
	push	OFFSET ??_C@_09OAPKCOGD@minOccurs@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@xmlGetMinO
$LN22@xmlGetMinO:

; 4669 : 	    return(prop);
; 4670 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL18@xmlGetMinO
$LN45@xmlGetMinO:

; 6125 :     xmlAttrPtr attr;
; 6126 : 
; 6127 :     attr = xmlSchemaGetPropNode(node, "minOccurs");
; 6128 :     if (attr == NULL)
; 6129 : 	return (def);

	mov	eax, DWORD PTR _def$[ebp]
	pop	esi

; 6160 : }

	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlGetMinO:
	push	edi

; 4710 :     val = xmlNodeGetContent(node);

	push	esi
	call	_xmlNodeGetContent
	mov	edi, eax
	add	esp, 4

; 4711 :     if (val == NULL)

	test	edi, edi
	jne	SHORT $LN25@xmlGetMinO

; 4712 : 	val = xmlStrdup((xmlChar *)"");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	edi, eax
$LN25@xmlGetMinO:

; 4713 :     ret = xmlDictLookup(ctxt->dict, val, -1);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	-1
	push	edi
	push	DWORD PTR [eax+80]
	call	_xmlDictLookup

; 4714 :     xmlFree(val);

	push	edi
	mov	DWORD PTR _ret$1$[ebp], eax
	call	DWORD PTR _xmlFree

; 6130 :     val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
; 6131 :     cur = val;

	mov	edi, DWORD PTR _ret$1$[ebp]

; 4714 :     xmlFree(val);

	add	esp, 16					; 00000010H

; 6130 :     val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
; 6131 :     cur = val;

	mov	edx, edi
$LL2@xmlGetMinO:

; 6132 :     while (IS_BLANK_CH(*cur))

	mov	al, BYTE PTR [edx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN9@xmlGetMinO
	cmp	al, 9
	jb	SHORT $LN10@xmlGetMinO
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN9@xmlGetMinO
$LN10@xmlGetMinO:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN3@xmlGetMinO
$LN9@xmlGetMinO:

; 6133 :         cur++;

	inc	edx
	jmp	SHORT $LL2@xmlGetMinO
$LN3@xmlGetMinO:

; 6134 :     if (*cur == 0) {

	test	al, al
	je	SHORT $LN15@xmlGetMinO

; 6135 :         xmlSchemaPSimpleTypeErr(ctxt,
; 6136 : 	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 6137 : 	    /* XML_SCHEMAP_INVALID_MINOCCURS, */
; 6138 : 	    NULL, (xmlNodePtr) attr, NULL, expected,
; 6139 : 	    val, NULL, NULL, NULL);
; 6140 :         return (def);
; 6141 :     }
; 6142 :     while ((*cur >= '0') && (*cur <= '9')) {

	cmp	al, 48					; 00000030H
	jb	SHORT $LL6@xmlGetMinO
$LL4@xmlGetMinO:
	cmp	al, 57					; 00000039H
	ja	SHORT $LL6@xmlGetMinO

; 6143 :         ret = ret * 10 + (*cur - '0');

	movzx	eax, al
	lea	ebx, DWORD PTR [ebx+ebx*4]

; 6144 :         cur++;

	inc	edx
	lea	ebx, DWORD PTR [ebx-24]
	lea	ebx, DWORD PTR [eax+ebx*2]
	mov	al, BYTE PTR [edx]
	cmp	al, 48					; 00000030H
	jae	SHORT $LL4@xmlGetMinO
	npad	6
$LL6@xmlGetMinO:

; 6145 :     }
; 6146 :     while (IS_BLANK_CH(*cur))

	mov	al, BYTE PTR [edx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN12@xmlGetMinO
	cmp	al, 9
	jb	SHORT $LN13@xmlGetMinO
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN12@xmlGetMinO
$LN13@xmlGetMinO:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN7@xmlGetMinO
$LN12@xmlGetMinO:

; 6147 :         cur++;

	inc	edx
	jmp	SHORT $LL6@xmlGetMinO
$LN7@xmlGetMinO:

; 6148 :     /*
; 6149 :     * TODO: Restrict the maximal value to Integer.
; 6150 :     */
; 6151 :     if ((*cur != 0) || (ret < min) || ((max != -1) && (ret > max))) {

	test	al, al
	jne	SHORT $LN15@xmlGetMinO
	cmp	ebx, DWORD PTR _min$[ebp]
	jl	SHORT $LN15@xmlGetMinO
	mov	eax, DWORD PTR _max$[ebp]
	cmp	eax, -1
	je	SHORT $LN14@xmlGetMinO
	cmp	ebx, eax
	jg	SHORT $LN15@xmlGetMinO
$LN14@xmlGetMinO:
	pop	edi
	pop	esi

; 6158 :     }
; 6159 :     return (ret);

	mov	eax, ebx

; 6160 : }

	pop	ebx
	pop	ebp
	ret	0
$LN15@xmlGetMinO:

; 6152 : 	xmlSchemaPSimpleTypeErr(ctxt,

	push	0
	push	0
	push	0
	push	edi
	push	DWORD PTR _expected$[ebp]
	push	0
	push	esi
	push	0
	push	3037					; 00000bddH
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPSimpleTypeErr

; 6153 : 	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 6154 : 	    /* XML_SCHEMAP_INVALID_MINOCCURS, */
; 6155 : 	    NULL, (xmlNodePtr) attr, NULL, expected,
; 6156 : 	    val, NULL, NULL, NULL);
; 6157 :         return (def);

	mov	eax, DWORD PTR _def$[ebp]
	add	esp, 40					; 00000028H
	pop	edi
	pop	esi

; 6160 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlGetMinOccurs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlGetMaxOccurs
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_ret$1$ = 12						; size = 4
_node$ = 12						; size = 4
_min$ = 16						; size = 4
_max$ = 20						; size = 4
_def$ = 24						; size = 4
_expected$ = 28						; size = 4
_xmlGetMaxOccurs PROC					; COMDAT

; 6057 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4

; 4664 :     if ((node == NULL) || (name == NULL))

	mov	esi, DWORD PTR _node$[ebp]

; 6058 :     const xmlChar *val, *cur;
; 6059 :     int ret = 0;

	xor	ebx, ebx

; 4664 :     if ((node == NULL) || (name == NULL))

	test	esi, esi
	je	SHORT $LN48@xmlGetMaxO

; 4665 : 	return(NULL);
; 4666 :     prop = node->properties;

	mov	esi, DWORD PTR [esi+44]

; 4667 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN48@xmlGetMaxO
	npad	1
$LL21@xmlGetMaxO:

; 4668 :         if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))

	cmp	DWORD PTR [esi+36], ebx
	jne	SHORT $LN25@xmlGetMaxO
	push	OFFSET ??_C@_09OBPGLENH@maxOccurs@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@xmlGetMaxO
$LN25@xmlGetMaxO:

; 4669 : 	    return(prop);
; 4670 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL21@xmlGetMaxO
$LN48@xmlGetMaxO:

; 6060 :     xmlAttrPtr attr;
; 6061 : 
; 6062 :     attr = xmlSchemaGetPropNode(node, "maxOccurs");
; 6063 :     if (attr == NULL)
; 6064 : 	return (def);

	mov	eax, DWORD PTR _def$[ebp]
	pop	esi

; 6108 : }

	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlGetMaxO:
	push	edi

; 4710 :     val = xmlNodeGetContent(node);

	push	esi
	call	_xmlNodeGetContent
	mov	edi, eax
	add	esp, 4

; 4711 :     if (val == NULL)

	test	edi, edi
	jne	SHORT $LN28@xmlGetMaxO

; 4712 : 	val = xmlStrdup((xmlChar *)"");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	edi, eax
$LN28@xmlGetMaxO:

; 4713 :     ret = xmlDictLookup(ctxt->dict, val, -1);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	-1
	push	edi
	push	DWORD PTR [eax+80]
	call	_xmlDictLookup

; 4714 :     xmlFree(val);

	push	edi
	mov	DWORD PTR _ret$1$[ebp], eax
	call	DWORD PTR _xmlFree

; 6065 :     val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
; 6066 : 
; 6067 :     if (xmlStrEqual(val, (const xmlChar *) "unbounded")) {

	mov	edi, DWORD PTR _ret$1$[ebp]
	push	OFFSET ??_C@_09PBKAIKML@unbounded@
	push	edi
	call	_xmlStrEqual
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN11@xmlGetMaxO

; 6068 : 	if (max != UNBOUNDED) {

	cmp	DWORD PTR _max$[ebp], 1073741824	; 40000000H
	jne	SHORT $LN18@xmlGetMaxO

; 6069 : 	    xmlSchemaPSimpleTypeErr(ctxt,
; 6070 : 		XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 6071 : 		/* XML_SCHEMAP_INVALID_MINOCCURS, */
; 6072 : 		NULL, (xmlNodePtr) attr, NULL, expected,
; 6073 : 		val, NULL, NULL, NULL);
; 6074 : 	    return (def);
; 6075 : 	} else
; 6076 : 	    return (UNBOUNDED);  /* encoding it with -1 might be another option */

	pop	edi
	pop	esi
	mov	eax, 1073741824				; 40000000H

; 6108 : }

	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlGetMaxO:

; 6077 :     }
; 6078 : 
; 6079 :     cur = val;

	mov	edx, edi
$LL2@xmlGetMaxO:

; 6080 :     while (IS_BLANK_CH(*cur))

	mov	al, BYTE PTR [edx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN12@xmlGetMaxO
	cmp	al, 9
	jb	SHORT $LN13@xmlGetMaxO
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN12@xmlGetMaxO
$LN13@xmlGetMaxO:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN3@xmlGetMaxO
$LN12@xmlGetMaxO:

; 6081 :         cur++;

	inc	edx
	jmp	SHORT $LL2@xmlGetMaxO
$LN3@xmlGetMaxO:

; 6082 :     if (*cur == 0) {

	test	al, al
	je	SHORT $LN18@xmlGetMaxO

; 6083 :         xmlSchemaPSimpleTypeErr(ctxt,
; 6084 : 	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 6085 : 	    /* XML_SCHEMAP_INVALID_MINOCCURS, */
; 6086 : 	    NULL, (xmlNodePtr) attr, NULL, expected,
; 6087 : 	    val, NULL, NULL, NULL);
; 6088 : 	return (def);
; 6089 :     }
; 6090 :     while ((*cur >= '0') && (*cur <= '9')) {

	cmp	al, 48					; 00000030H
	jb	SHORT $LL6@xmlGetMaxO
$LL4@xmlGetMaxO:
	cmp	al, 57					; 00000039H
	ja	SHORT $LL6@xmlGetMaxO

; 6091 :         ret = ret * 10 + (*cur - '0');

	movzx	eax, al
	lea	ebx, DWORD PTR [ebx+ebx*4]

; 6092 :         cur++;

	inc	edx
	lea	ebx, DWORD PTR [ebx-24]
	lea	ebx, DWORD PTR [eax+ebx*2]
	mov	al, BYTE PTR [edx]
	cmp	al, 48					; 00000030H
	jae	SHORT $LL4@xmlGetMaxO
	npad	4
$LL6@xmlGetMaxO:

; 6093 :     }
; 6094 :     while (IS_BLANK_CH(*cur))

	mov	al, BYTE PTR [edx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN15@xmlGetMaxO
	cmp	al, 9
	jb	SHORT $LN16@xmlGetMaxO
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN15@xmlGetMaxO
$LN16@xmlGetMaxO:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN7@xmlGetMaxO
$LN15@xmlGetMaxO:

; 6095 :         cur++;

	inc	edx
	jmp	SHORT $LL6@xmlGetMaxO
$LN7@xmlGetMaxO:

; 6096 :     /*
; 6097 :     * TODO: Restrict the maximal value to Integer.
; 6098 :     */
; 6099 :     if ((*cur != 0) || (ret < min) || ((max != -1) && (ret > max))) {

	test	al, al
	jne	SHORT $LN18@xmlGetMaxO
	cmp	ebx, DWORD PTR _min$[ebp]
	jl	SHORT $LN18@xmlGetMaxO
	mov	eax, DWORD PTR _max$[ebp]
	cmp	eax, -1
	je	SHORT $LN17@xmlGetMaxO
	cmp	ebx, eax
	jg	SHORT $LN18@xmlGetMaxO
$LN17@xmlGetMaxO:
	pop	edi
	pop	esi

; 6106 :     }
; 6107 :     return (ret);

	mov	eax, ebx

; 6108 : }

	pop	ebx
	pop	ebp
	ret	0
$LN18@xmlGetMaxO:

; 6100 : 	xmlSchemaPSimpleTypeErr(ctxt,

	push	0
	push	0
	push	0
	push	edi
	push	DWORD PTR _expected$[ebp]
	push	0
	push	esi
	push	0
	push	3037					; 00000bddH
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPSimpleTypeErr

; 6101 : 	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 6102 : 	    /* XML_SCHEMAP_INVALID_MINOCCURS, */
; 6103 : 	    NULL, (xmlNodePtr) attr, NULL, expected,
; 6104 : 	    val, NULL, NULL, NULL);
; 6105 :         return (def);

	mov	eax, DWORD PTR _def$[ebp]
	add	esp, 40					; 00000028H
	pop	edi
	pop	esi

; 6108 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlGetMaxOccurs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPValAttrID
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_ownerElem$ = 12					; size = 4
_name$ = 16						; size = 4
_xmlSchemaPValAttrID PROC				; COMDAT

; 6035 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _ownerElem$[ebp]
	call	_xmlSchemaGetPropNode
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaP

; 6042 : 
; 6043 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaP:

; 6036 :     xmlAttrPtr attr;
; 6037 : 
; 6038 :     attr = xmlSchemaGetPropNode(ownerElem, (const char *) name);
; 6039 :     if (attr == NULL)
; 6040 : 	return(0);
; 6041 :     return(xmlSchemaPValAttrNodeID(ctxt, attr));

	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPValAttrNodeID
	add	esp, 8

; 6042 : 
; 6043 : }

	pop	ebp
	ret	0
_xmlSchemaPValAttrID ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPValAttrNodeID
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_strip$1$ = 12						; size = 4
_attr$ = 12						; size = 4
_xmlSchemaPValAttrNodeID PROC				; COMDAT

; 5978 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _attr$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlSchemaP

; 5979 :     int ret;
; 5980 :     const xmlChar *value;
; 5981 : 
; 5982 :     if (attr == NULL)
; 5983 : 	return(0);

	xor	eax, eax
	pop	esi

; 6029 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaP:
	push	ebx
	push	edi

; 4721 :     return((const xmlChar*) xmlNodeGetContent(node));

	push	esi
	call	_xmlNodeGetContent

; 5984 :     value = xmlSchemaGetNodeContentNoDict((xmlNodePtr) attr);

	mov	edi, eax

; 5985 :     ret = xmlValidateNCName(value, 1);

	push	1
	push	edi
	call	_xmlValidateNCName
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 5986 :     if (ret == 0) {

	test	ebx, ebx
	jne	SHORT $LN14@xmlSchemaP

; 5987 : 	/*
; 5988 : 	* NOTE: the IDness might have already be declared in the DTD
; 5989 : 	*/
; 5990 : 	if (attr->atype != XML_ATTRIBUTE_ID) {

	cmp	DWORD PTR [esi+40], 2
	je	SHORT $LN9@xmlSchemaP

; 5991 : 	    xmlIDPtr res;
; 5992 : 	    xmlChar *strip;
; 5993 : 
; 5994 : 	    /*
; 5995 : 	    * TODO: Use xmlSchemaStrip here; it's not exported at this
; 5996 : 	    * moment.
; 5997 : 	    */
; 5998 : 	    strip = xmlSchemaCollapseString(value);

	push	edi
	call	_xmlSchemaCollapseString
	add	esp, 4
	mov	DWORD PTR _strip$1$[ebp], eax

; 5999 : 	    if (strip != NULL) {

	test	eax, eax
	je	SHORT $LN6@xmlSchemaP

; 6000 : 		xmlFree((xmlChar *) value);

	push	edi
	call	DWORD PTR _xmlFree

; 6001 : 		value = strip;

	mov	edi, DWORD PTR _strip$1$[ebp]
	add	esp, 4
$LN6@xmlSchemaP:

; 6002 : 	    }
; 6003 : 	    res = xmlAddID(NULL, attr->doc, value, attr);

	push	esi
	push	edi
	push	DWORD PTR [esi+32]
	push	0
	call	_xmlAddID
	add	esp, 16					; 00000010H

; 6004 : 	    if (res == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlSchemaP

; 6005 : 		ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE;
; 6006 : 		xmlSchemaPSimpleTypeErr(ctxt,

	push	eax
	push	edi
	push	OFFSET ??_C@_0CM@OMFMFEA@Duplicate?5value?5?8?$CFs?8?5of?5simple?5@

; 6007 : 		    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 6008 : 		    NULL, (xmlNodePtr) attr,
; 6009 : 		    xmlSchemaGetBuiltInType(XML_SCHEMAS_ID),
; 6010 : 		    NULL, NULL, "Duplicate value '%s' of simple "
; 6011 : 		    "type 'xs:ID'", value, NULL);
; 6012 : 	    } else

	jmp	SHORT $LN15@xmlSchemaP
$LN7@xmlSchemaP:

; 6013 : 		attr->atype = XML_ATTRIBUTE_ID;

	mov	DWORD PTR [esi+40], 2

; 6014 : 	}

	jmp	SHORT $LN9@xmlSchemaP
$LN14@xmlSchemaP:

; 6015 :     } else if (ret > 0) {

	jle	SHORT $LN9@xmlSchemaP

; 6016 : 	ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE;
; 6017 : 	xmlSchemaPSimpleTypeErr(ctxt,

	push	0
	push	edi
	push	OFFSET ??_C@_0EB@BMJNLDB@The?5value?5?8?$CFs?8?5of?5simple?5type?5?8@
$LN15@xmlSchemaP:

; 6018 : 	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 6019 : 	    NULL, (xmlNodePtr) attr,
; 6020 : 	    xmlSchemaGetBuiltInType(XML_SCHEMAS_ID),
; 6021 : 	    NULL, NULL, "The value '%s' of simple type 'xs:ID' is "
; 6022 : 	    "not a valid 'xs:NCName'",
; 6023 : 	    value, NULL);
; 6024 :     }
; 6025 :     if (value != NULL)

	push	0
	push	0
	push	23					; 00000017H
	mov	ebx, 3037				; 00000bddH
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	push	eax
	push	esi
	push	0
	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPSimpleTypeErr
	add	esp, 40					; 00000028H
$LN9@xmlSchemaP:
	test	edi, edi
	je	SHORT $LN10@xmlSchemaP

; 6026 : 	xmlFree((xmlChar *)value);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlSchemaP:

; 6027 : 
; 6028 :     return (ret);

	pop	edi
	mov	eax, ebx
	pop	ebx
	pop	esi

; 6029 : }

	pop	ebp
	ret	0
_xmlSchemaPValAttrNodeID ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPValAttrQName
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_ownerItem$ = 16					; size = 4
_ownerElem$ = 20					; size = 4
_name$ = 24						; size = 4
_uri$ = 28						; size = 4
_local$ = 32						; size = 4
_xmlSchemaPValAttrQName PROC				; COMDAT

; 5949 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _ownerElem$[ebp]
	call	_xmlSchemaGetPropNode
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaP

; 5950 :     xmlAttrPtr attr;
; 5951 : 
; 5952 :     attr = xmlSchemaGetPropNode(ownerElem, name);
; 5953 :     if (attr == NULL) {
; 5954 : 	*local = NULL;

	mov	eax, DWORD PTR _local$[ebp]
	mov	DWORD PTR [eax], 0

; 5955 : 	*uri = NULL;

	mov	eax, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [eax], 0

; 5956 : 	return (0);

	xor	eax, eax

; 5959 : 	ownerItem, attr, uri, local));
; 5960 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaP:

; 5957 :     }
; 5958 :     return (xmlSchemaPValAttrNodeQName(ctxt, schema,

	push	DWORD PTR _local$[ebp]
	push	DWORD PTR _uri$[ebp]
	push	eax
	push	DWORD PTR _ownerItem$[ebp]
	push	DWORD PTR _schema$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPValAttrNodeQName
	add	esp, 24					; 00000018H

; 5959 : 	ownerItem, attr, uri, local));
; 5960 : }

	pop	ebp
	ret	0
_xmlSchemaPValAttrQName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPValAttrNodeQName
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_ownerItem$ = 16					; size = 4
_attr$ = 20						; size = 4
_uri$ = 24						; size = 4
_local$ = 28						; size = 4
_xmlSchemaPValAttrNodeQName PROC			; COMDAT

; 5917 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4

; 4710 :     val = xmlNodeGetContent(node);

	push	DWORD PTR _attr$[ebp]
	call	_xmlNodeGetContent
	mov	ebx, eax
	add	esp, 4

; 4711 :     if (val == NULL)

	test	ebx, ebx
	jne	SHORT $LN4@xmlSchemaP

; 4712 : 	val = xmlStrdup((xmlChar *)"");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	ebx, eax
$LN4@xmlSchemaP:

; 4713 :     ret = xmlDictLookup(ctxt->dict, val, -1);

	mov	edi, DWORD PTR _ctxt$[ebp]
	push	-1
	push	ebx
	push	DWORD PTR [edi+80]
	call	_xmlDictLookup

; 4714 :     xmlFree(val);

	push	ebx
	mov	esi, eax
	call	DWORD PTR _xmlFree

; 5918 :     const xmlChar *value;
; 5919 : 
; 5920 :     value = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);
; 5921 :     return (xmlSchemaPValAttrNodeQNameValue(ctxt, schema,

	push	DWORD PTR _local$[ebp]
	push	DWORD PTR _uri$[ebp]
	push	esi
	push	DWORD PTR _attr$[ebp]
	push	DWORD PTR _ownerItem$[ebp]
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaPValAttrNodeQNameValue
	add	esp, 44					; 0000002cH
	pop	edi
	pop	esi
	pop	ebx

; 5922 : 	ownerItem, attr, value, uri, local));
; 5923 : }

	pop	ebp
	ret	0
_xmlSchemaPValAttrNodeQName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPValAttrNodeQNameValue
_TEXT	SEGMENT
_len$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_ownerItem$ = 16					; size = 4
_attr$ = 20						; size = 4
_value$ = 24						; size = 4
_uri$ = 28						; size = 4
_local$ = 32						; size = 4
_xmlSchemaPValAttrNodeQNameValue PROC			; COMDAT

; 5837 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _uri$[ebp]
	mov	ebx, DWORD PTR _local$[ebp]
	mov	edi, DWORD PTR _value$[ebp]
	push	1
	mov	DWORD PTR [esi], 0
	push	edi
	mov	DWORD PTR [ebx], 0
	call	_xmlValidateQName
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN12@xmlSchemaP

; 5838 :     const xmlChar *pref;
; 5839 :     xmlNsPtr ns;
; 5840 :     int len, ret;
; 5841 : 
; 5842 :     *uri = NULL;
; 5843 :     *local = NULL;
; 5844 :     ret = xmlValidateQName(value, 1);
; 5845 :     if (ret > 0) {
; 5846 : 	xmlSchemaPSimpleTypeErr(ctxt,

	push	0
	push	0
	push	0
	push	edi
	push	0
	push	21					; 00000015H
	call	_xmlSchemaGetBuiltInType
	mov	esi, DWORD PTR _ctxt$[ebp]
	add	esp, 4
	push	eax
	push	DWORD PTR _attr$[ebp]
	push	DWORD PTR _ownerItem$[ebp]
	push	3037					; 00000bddH
	push	esi
	call	_xmlSchemaPSimpleTypeErr
	add	esp, 40					; 00000028H

; 5847 : 	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 5848 : 	    ownerItem, (xmlNodePtr) attr,
; 5849 : 	    xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),
; 5850 : 	    NULL, value, NULL, NULL, NULL);
; 5851 : 	*local = value;

	mov	DWORD PTR [ebx], edi

; 5852 : 	return (ctxt->err);

	mov	eax, DWORD PTR [esi+16]
	pop	edi

; 5889 :     }
; 5890 :     return (0);
; 5891 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlSchemaP:

; 5853 :     } else if (ret < 0)

	jns	SHORT $LN4@xmlSchemaP

; 5889 :     }
; 5890 :     return (0);
; 5891 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlSchemaP:

; 5854 : 	return (-1);
; 5855 : 
; 5856 :     if (!strchr((char *) value, ':')) {

	push	58					; 0000003aH
	push	edi
	call	_strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@xmlSchemaP

; 5857 : 	ns = xmlSearchNs(attr->doc, attr->parent, NULL);

	push	eax
	mov	eax, DWORD PTR _attr$[ebp]
	push	DWORD PTR [eax+20]
	push	DWORD PTR [eax+32]
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH

; 5858 : 	if (ns)

	test	eax, eax
	je	SHORT $LN6@xmlSchemaP

; 5859 : 	    *uri = xmlDictLookup(ctxt->dict, ns->href, -1);

	push	-1
	push	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [eax+80]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN13@xmlSchemaP
$LN6@xmlSchemaP:

; 5860 : 	else if (schema->flags & XML_SCHEMAS_INCLUDING_CONVERT_NS) {

	mov	eax, DWORD PTR _schema$[ebp]
	test	DWORD PTR [eax+24], 512			; 00000200H
	je	SHORT $LN8@xmlSchemaP

; 5861 : 	    /* TODO: move XML_SCHEMAS_INCLUDING_CONVERT_NS to the
; 5862 : 	    * parser context. */
; 5863 : 	    /*
; 5864 : 	    * This one takes care of included schemas with no
; 5865 : 	    * target namespace.
; 5866 : 	    */
; 5867 : 	    *uri = ctxt->targetNamespace;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [eax+112]
$LN13@xmlSchemaP:

; 5868 : 	}
; 5869 : 	*local = xmlDictLookup(ctxt->dict, value, -1);

	mov	DWORD PTR [esi], eax
$LN8@xmlSchemaP:
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	-1
	push	edi
	push	DWORD PTR [eax+80]
	call	_xmlDictLookup

; 5889 :     }
; 5890 :     return (0);
; 5891 : }

	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebx], eax
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlSchemaP:

; 5870 : 	return (0);
; 5871 :     }
; 5872 :     /*
; 5873 :     * At this point xmlSplitQName3 has to return a local name.
; 5874 :     */
; 5875 :     *local = xmlSplitQName3(value, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	edi
	call	_xmlSplitQName3

; 5876 :     *local = xmlDictLookup(ctxt->dict, *local, -1);

	push	-1
	mov	DWORD PTR [ebx], eax
	push	eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [eax+80]
	call	_xmlDictLookup

; 5877 :     pref = xmlDictLookup(ctxt->dict, value, len);

	push	DWORD PTR _len$[ebp]
	mov	DWORD PTR [ebx], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	edi
	push	DWORD PTR [eax+80]
	call	_xmlDictLookup

; 5878 :     ns = xmlSearchNs(attr->doc, attr->parent, pref);

	mov	ebx, DWORD PTR _attr$[ebp]
	push	eax
	push	DWORD PTR [ebx+20]
	push	DWORD PTR [ebx+32]
	call	_xmlSearchNs
	add	esp, 44					; 0000002cH

; 5879 :     if (ns == NULL) {

	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP

; 5880 : 	xmlSchemaPSimpleTypeErr(ctxt,

	push	eax
	push	edi
	push	OFFSET ??_C@_0FN@NHMNMJGI@The?5value?5?8?$CFs?8?5of?5simple?5type?5?8@
	push	edi
	push	eax
	push	21					; 00000015H
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	push	eax
	push	ebx
	push	DWORD PTR _ownerItem$[ebp]
	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	3037					; 00000bddH
	push	ebx
	call	_xmlSchemaPSimpleTypeErr

; 5881 : 	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 5882 : 	    ownerItem, (xmlNodePtr) attr,
; 5883 : 	    xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME), NULL, value,
; 5884 : 	    "The value '%s' of simple type 'xs:QName' has no "
; 5885 : 	    "corresponding namespace declaration in scope", value, NULL);
; 5886 : 	return (ctxt->err);

	mov	eax, DWORD PTR [ebx+16]
	add	esp, 40					; 00000028H
	pop	edi

; 5889 :     }
; 5890 :     return (0);
; 5891 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlSchemaP:

; 5887 :     } else {
; 5888 :         *uri = xmlDictLookup(ctxt->dict, ns->href, -1);

	push	-1
	push	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [eax+80]
	call	_xmlDictLookup

; 5889 :     }
; 5890 :     return (0);
; 5891 : }

	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi], eax
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaPValAttrNodeQNameValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddElementSubstitutionMember
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_head$ = 12						; size = 4
_member$ = 16						; size = 4
_xmlSchemaAddElementSubstitutionMember PROC		; COMDAT

; 5790 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pctxt$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlSchemaA

; 5791 :     xmlSchemaSubstGroupPtr substGroup = NULL;
; 5792 : 
; 5793 :     if ((pctxt == NULL) || (head == NULL) || (member == NULL))

	mov	ebx, DWORD PTR _head$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@xmlSchemaA
	cmp	DWORD PTR _member$[ebp], 0
	je	SHORT $LN3@xmlSchemaA

; 5795 : 
; 5796 :     substGroup = xmlSchemaSubstGroupGet(pctxt, head);

	push	ebx
	push	edi
	call	_xmlSchemaSubstGroupGet
	mov	esi, eax
	add	esp, 8

; 5797 :     if (substGroup == NULL)

	test	esi, esi
	jne	$LN13@xmlSchemaA

; 5734 :     if (WXS_SUBST_GROUPS(pctxt) == NULL) {

	mov	eax, DWORD PTR [edi+28]
	cmp	DWORD PTR [eax+24], esi
	jne	SHORT $LN10@xmlSchemaA

; 5735 : 	WXS_SUBST_GROUPS(pctxt) = xmlHashCreateDict(10, pctxt->dict);

	push	DWORD PTR [edi+80]
	push	10					; 0000000aH
	call	_xmlHashCreateDict
	mov	ecx, DWORD PTR [edi+28]
	add	esp, 8
	mov	DWORD PTR [ecx+24], eax

; 5736 : 	if (WXS_SUBST_GROUPS(pctxt) == NULL)

	mov	eax, DWORD PTR [edi+28]
	cmp	DWORD PTR [eax+24], esi
	je	SHORT $LN3@xmlSchemaA
$LN10@xmlSchemaA:

; 5737 : 	    return(NULL);
; 5738 :     }
; 5739 :     /* Create a new substitution group. */
; 5740 :     ret = (xmlSchemaSubstGroupPtr) xmlMalloc(sizeof(xmlSchemaSubstGroup));

	push	8
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5741 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN11@xmlSchemaA

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CK@NKPACKCN@allocating?5a?5substitution?5group@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
$LN3@xmlSchemaA:
	pop	edi

; 5802 : 	return(-1);
; 5803 :     return(0);
; 5804 : }

	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlSchemaA:
	xorps	xmm0, xmm0

; 5746 :     memset(ret, 0, sizeof(xmlSchemaSubstGroup));

	movq	QWORD PTR [esi], xmm0

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	push	12					; 0000000cH

; 5747 :     ret->head = head;

	mov	DWORD PTR [esi], ebx

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 3342 :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN19@xmlSchemaA

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@BAFOADOL@allocating?5an?5item?5list?5structu@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3345 : 	return (NULL);

	xor	eax, eax
	jmp	SHORT $LN18@xmlSchemaA
$LN19@xmlSchemaA:
	xorps	xmm0, xmm0

; 3346 :     }
; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));

	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], 0
$LN18@xmlSchemaA:

; 5749 :     ret->members = xmlSchemaItemListCreate();

	mov	DWORD PTR [esi+4], eax

; 5750 :     if (ret->members == NULL) {

	push	esi
	test	eax, eax
	jne	SHORT $LN12@xmlSchemaA

; 5751 : 	xmlSchemaSubstGroupFree(ret);

	call	_xmlSchemaSubstGroupFree
	add	esp, 4

; 5794 : 	return (-1);

	or	eax, -1
	pop	edi

; 5802 : 	return(-1);
; 5803 :     return(0);
; 5804 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN12@xmlSchemaA:

; 5756 : 	head->name, head->targetNamespace, ret) != 0) {

	push	DWORD PTR [ebx+52]
	mov	eax, DWORD PTR [edi+28]
	push	DWORD PTR [ebx+8]
	push	DWORD PTR [eax+24]
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN13@xmlSchemaA

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CL@JADHFAI@failed?5to?5add?5a?5new?5substitutio@
	push	OFFSET ??_C@_0BH@CHMIFAPN@xmlSchemaSubstGroupAdd@
	push	edi
	call	_xmlSchemaInternalErr2

; 5759 : 	xmlSchemaSubstGroupFree(ret);

	push	esi
	call	_xmlSchemaSubstGroupFree
	add	esp, 24					; 00000018H

; 5794 : 	return (-1);

	or	eax, -1
	pop	edi

; 5802 : 	return(-1);
; 5803 :     return(0);
; 5804 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN13@xmlSchemaA:

; 5798 : 	substGroup = xmlSchemaSubstGroupAdd(pctxt, head);
; 5799 :     if (substGroup == NULL)
; 5800 : 	return(-1);
; 5801 :     if (xmlSchemaItemListAdd(substGroup->members, member) == -1)

	push	DWORD PTR _member$[ebp]
	push	DWORD PTR [esi+4]
	call	_xmlSchemaItemListAdd
	add	esp, 8
	cmp	eax, -1
	je	$LN3@xmlSchemaA

; 5802 : 	return(-1);
; 5803 :     return(0);
; 5804 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaAddElementSubstitutionMember ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSubstGroupGet
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_head$ = 12						; size = 4
_xmlSchemaSubstGroupGet PROC				; COMDAT

; 5768 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _pctxt$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	jne	SHORT $LN2@xmlSchemaS

; 5769 :     if (WXS_SUBST_GROUPS(pctxt) == NULL)
; 5770 : 	return(NULL);

	xor	eax, eax

; 5772 : 	head->name, head->targetNamespace));
; 5773 : 
; 5774 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaS:

; 5771 :     return(xmlHashLookup2(WXS_SUBST_GROUPS(pctxt),

	mov	eax, DWORD PTR _head$[ebp]
	push	DWORD PTR [eax+52]
	push	DWORD PTR [eax+8]
	push	ecx
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH

; 5772 : 	head->name, head->targetNamespace));
; 5773 : 
; 5774 : }

	pop	ebp
	ret	0
_xmlSchemaSubstGroupGet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSubstGroupAdd
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_head$ = 12						; size = 4
_xmlSchemaSubstGroupAdd PROC				; COMDAT

; 5730 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pctxt$[ebp]
	mov	eax, DWORD PTR [edi+28]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN3@xmlSchemaS

; 5731 :     xmlSchemaSubstGroupPtr ret;
; 5732 : 
; 5733 :     /* Init subst group hash. */
; 5734 :     if (WXS_SUBST_GROUPS(pctxt) == NULL) {
; 5735 : 	WXS_SUBST_GROUPS(pctxt) = xmlHashCreateDict(10, pctxt->dict);

	push	DWORD PTR [edi+80]
	push	10					; 0000000aH
	call	_xmlHashCreateDict
	mov	ecx, DWORD PTR [edi+28]
	add	esp, 8
	mov	DWORD PTR [ecx+24], eax

; 5736 : 	if (WXS_SUBST_GROUPS(pctxt) == NULL)

	mov	eax, DWORD PTR [edi+28]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN3@xmlSchemaS

; 5737 : 	    return(NULL);

	xor	eax, eax
	pop	edi

; 5763 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaS:
	push	esi

; 5738 :     }
; 5739 :     /* Create a new substitution group. */
; 5740 :     ret = (xmlSchemaSubstGroupPtr) xmlMalloc(sizeof(xmlSchemaSubstGroup));

	push	8
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5741 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlSchemaS

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CK@NKPACKCN@allocating?5a?5substitution?5group@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 5742 : 	xmlSchemaPErrMemory(NULL,
; 5743 : 	    "allocating a substitution group container", NULL);
; 5744 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 5763 : }

	pop	ebp
	ret	0
$LN4@xmlSchemaS:
	push	ebx

; 5745 :     }
; 5746 :     memset(ret, 0, sizeof(xmlSchemaSubstGroup));
; 5747 :     ret->head = head;

	mov	ebx, DWORD PTR _head$[ebp]
	xorps	xmm0, xmm0
	movq	QWORD PTR [esi], xmm0

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	push	12					; 0000000cH

; 5745 :     }
; 5746 :     memset(ret, 0, sizeof(xmlSchemaSubstGroup));
; 5747 :     ret->head = head;

	mov	DWORD PTR [esi], ebx

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 3342 :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlSchemaS

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@BAFOADOL@allocating?5an?5item?5list?5structu@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3345 : 	return (NULL);

	xor	eax, eax
	jmp	SHORT $LN11@xmlSchemaS
$LN12@xmlSchemaS:
	xorps	xmm0, xmm0

; 3346 :     }
; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));

	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], 0
$LN11@xmlSchemaS:

; 5748 :     /* Create list of members. */
; 5749 :     ret->members = xmlSchemaItemListCreate();

	mov	DWORD PTR [esi+4], eax

; 5750 :     if (ret->members == NULL) {

	push	esi
	test	eax, eax
	jne	SHORT $LN5@xmlSchemaS

; 5751 : 	xmlSchemaSubstGroupFree(ret);

	call	_xmlSchemaSubstGroupFree
	add	esp, 4

; 5752 : 	return(NULL);

	xor	eax, eax
	pop	ebx
	pop	esi
	pop	edi

; 5763 : }

	pop	ebp
	ret	0
$LN5@xmlSchemaS:

; 5753 :     }
; 5754 :     /* Add subst group to hash. */
; 5755 :     if (xmlHashAddEntry2(WXS_SUBST_GROUPS(pctxt),
; 5756 : 	head->name, head->targetNamespace, ret) != 0) {

	push	DWORD PTR [ebx+52]
	mov	eax, DWORD PTR [edi+28]
	push	DWORD PTR [ebx+8]
	push	DWORD PTR [eax+24]
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN6@xmlSchemaS

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CL@JADHFAI@failed?5to?5add?5a?5new?5substitutio@
	push	OFFSET ??_C@_0BH@CHMIFAPN@xmlSchemaSubstGroupAdd@
	push	edi
	call	_xmlSchemaInternalErr2

; 5757 : 	PERROR_INT("xmlSchemaSubstGroupAdd",
; 5758 : 	    "failed to add a new substitution container");
; 5759 : 	xmlSchemaSubstGroupFree(ret);

	push	esi
	call	_xmlSchemaSubstGroupFree
	add	esp, 24					; 00000018H

; 5760 : 	return(NULL);

	xor	eax, eax
	pop	ebx
	pop	esi
	pop	edi

; 5763 : }

	pop	ebp
	ret	0
$LN6@xmlSchemaS:
	pop	ebx

; 5761 :     }
; 5762 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 5763 : }

	pop	ebp
	ret	0
_xmlSchemaSubstGroupAdd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSubstGroupFreeEntry
_TEXT	SEGMENT
_group$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlSchemaSubstGroupFreeEntry PROC			; COMDAT

; 5723 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4

; 5714 :     if (group == NULL)

	mov	esi, DWORD PTR _group$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaS

; 5715 : 	return;
; 5716 :     if (group->members != NULL)

	push	edi
	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $LN7@xmlSchemaS

; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN9@xmlSchemaS

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlSchemaS:

; 3534 :     xmlFree(list);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlSchemaS:

; 5718 :     xmlFree(group);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
$LN3@xmlSchemaS:
	pop	esi

; 5724 :     xmlSchemaSubstGroupFree((xmlSchemaSubstGroupPtr) group);
; 5725 : }

	pop	ebp
	ret	0
_xmlSchemaSubstGroupFreeEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSubstGroupFree
_TEXT	SEGMENT
_group$ = 8						; size = 4
_xmlSchemaSubstGroupFree PROC				; COMDAT

; 5713 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _group$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlSchemaS

; 5714 :     if (group == NULL)
; 5715 : 	return;
; 5716 :     if (group->members != NULL)

	push	edi
	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $LN5@xmlSchemaS

; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN7@xmlSchemaS

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlSchemaS:

; 3534 :     xmlFree(list);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlSchemaS:

; 5717 : 	xmlSchemaItemListFree(group->members);
; 5718 :     xmlFree(group);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
$LN1@xmlSchemaS:
	pop	esi

; 5719 : }

	pop	ebp
	ret	0
_xmlSchemaSubstGroupFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddWildcard
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_type$ = 16						; size = 4
_node$ = 20						; size = 4
_xmlSchemaAddWildcard PROC				; COMDAT

; 5693 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN3@xmlSchemaA

; 5694 :     xmlSchemaWildcardPtr ret = NULL;
; 5695 : 
; 5696 :     if ((ctxt == NULL) || (schema == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	$LN3@xmlSchemaA

; 5698 : 
; 5699 :     ret = (xmlSchemaWildcardPtr) xmlMalloc(sizeof(xmlSchemaWildcard));

	push	esi
	push	44					; 0000002cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5700 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlSchemaA

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [edi+20]

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BA@CIBAJGPC@adding?5wildcard@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 5701 :         xmlSchemaPErrMemory(ctxt, "adding wildcard", NULL);
; 5702 :         return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 5709 : }

	pop	ebp
	ret	0
$LN4@xmlSchemaA:

; 5703 :     }
; 5704 :     memset(ret, 0, sizeof(xmlSchemaWildcard));
; 5705 :     ret->type = type;

	mov	eax, DWORD PTR _type$[ebp]

; 5706 :     ret->node = node;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi], eax

; 5707 :     WXS_ADD_LOCAL(ctxt, ret);

	mov	ecx, DWORD PTR [edi+28]
	push	esi
	push	10					; 0000000aH
	mov	ecx, DWORD PTR [ecx+16]
	add	ecx, 48					; 00000030H
	push	ecx
	call	_xmlSchemaAddItemSize
	add	esp, 12					; 0000000cH

; 5708 :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 5709 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaA:

; 5697 :         return (NULL);

	xor	eax, eax
	pop	edi

; 5709 : }

	pop	ebp
	ret	0
_xmlSchemaAddWildcard ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddIDC
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_name$ = 16						; size = 4
_nsName$ = 20						; size = 4
_category$ = 24						; size = 4
_node$ = 28						; size = 4
_xmlSchemaAddIDC PROC					; COMDAT

; 5652 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	je	$LN3@xmlSchemaA

; 5653 :     xmlSchemaIDCPtr ret = NULL;
; 5654 : 
; 5655 :     if ((ctxt == NULL) || (schema == NULL) || (name == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	$LN3@xmlSchemaA
	mov	esi, DWORD PTR _name$[ebp]
	test	esi, esi
	je	$LN3@xmlSchemaA

; 5657 : 
; 5658 :     ret = (xmlSchemaIDCPtr) xmlMalloc(sizeof(xmlSchemaIDC));

	push	edi
	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 5659 :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN4@xmlSchemaA

; 5660 :         xmlSchemaPErrMemory(ctxt,

	push	eax
	push	OFFSET ??_C@_0CN@LEONOKAC@allocating?5an?5identity?9constrai@
	push	ebx
	call	_xmlSchemaPErrMemory
	add	esp, 12					; 0000000cH

; 5661 : 	    "allocating an identity-constraint definition", NULL);
; 5662 :         return (NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 5678 : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlSchemaA:

; 5663 :     }
; 5664 :     memset(ret, 0, sizeof(xmlSchemaIDC));
; 5665 :     /* The target namespace of the parent element declaration. */
; 5666 :     ret->targetNamespace = nsName;

	mov	eax, DWORD PTR _nsName$[ebp]
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+24], 0
	mov	DWORD PTR [edi+28], 0
	mov	DWORD PTR [edi+32], 0
	mov	DWORD PTR [edi+36], 0
	mov	DWORD PTR [edi+20], eax

; 5667 :     ret->name = name;
; 5668 :     ret->type = category;
; 5669 :     ret->node = node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edi+16], esi
	mov	esi, DWORD PTR _category$[ebp]
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi], esi

; 5670 : 
; 5671 :     WXS_ADD_GLOBAL(ctxt, ret);

	mov	eax, DWORD PTR [ebx+28]
	push	edi
	push	5
	mov	eax, DWORD PTR [eax+16]
	add	eax, 44					; 0000002cH
	push	eax
	call	_xmlSchemaAddItemSize
	add	esp, 12					; 0000000cH

; 5672 :     /*
; 5673 :     * Only keyrefs need to be fixup up.
; 5674 :     */
; 5675 :     if (category == XML_SCHEMA_TYPE_IDC_KEYREF)

	cmp	esi, 24					; 00000018H
	jne	SHORT $LN5@xmlSchemaA

; 5676 : 	WXS_ADD_PENDING(ctxt, ret);

	mov	ecx, DWORD PTR [ebx+28]
	push	edi
	add	ecx, 20					; 00000014H
	push	10					; 0000000aH
	push	ecx
	call	_xmlSchemaAddItemSize
	add	esp, 12					; 0000000cH
$LN5@xmlSchemaA:

; 5677 :     return (ret);

	mov	eax, edi
	pop	edi
	pop	esi

; 5678 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemaA:
	pop	esi

; 5656 :         return (NULL);

	xor	eax, eax

; 5678 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaAddIDC ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaNewWildcardNsConstraint
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSchemaNewWildcardNsConstraint PROC			; COMDAT

; 5634 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	8
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaN

; 1884 :     if (ctxt != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaN

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [eax+20]
$LN5@xmlSchemaN:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CH@KLLMMGAA@creating?5wildcard?5namespace?5con@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 5635 :     xmlSchemaWildcardNsPtr ret;
; 5636 : 
; 5637 :     ret = (xmlSchemaWildcardNsPtr)
; 5638 : 	xmlMalloc(sizeof(xmlSchemaWildcardNs));
; 5639 :     if (ret == NULL) {
; 5640 : 	xmlSchemaPErrMemory(ctxt, "creating wildcard namespace constraint", NULL);
; 5641 : 	return (NULL);

	xor	eax, eax

; 5645 :     return (ret);
; 5646 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaN:

; 5642 :     }
; 5643 :     ret->value = NULL;

	mov	DWORD PTR [eax+4], 0

; 5644 :     ret->next = NULL;

	mov	DWORD PTR [eax], 0

; 5645 :     return (ret);
; 5646 : }

	pop	ebp
	ret	0
_xmlSchemaNewWildcardNsConstraint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddModelGroupDefinition
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_name$ = 16						; size = 4
_nsName$ = 20						; size = 4
_node$ = 24						; size = 4
_xmlSchemaAddModelGroupDefinition PROC			; COMDAT

; 5592 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN3@xmlSchemaA

; 5593 :     xmlSchemaModelGroupDefPtr ret = NULL;
; 5594 : 
; 5595 :     if ((ctxt == NULL) || (schema == NULL) || (name == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	$LN3@xmlSchemaA
	mov	ebx, DWORD PTR _name$[ebp]
	test	ebx, ebx
	je	$LN3@xmlSchemaA

; 5597 : 
; 5598 :     ret = (xmlSchemaModelGroupDefPtr)

	push	esi
	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5599 : 	xmlMalloc(sizeof(xmlSchemaModelGroupDef));
; 5600 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlSchemaA

; 5601 :         xmlSchemaPErrMemory(ctxt, "adding group", NULL);

	push	eax
	push	OFFSET ??_C@_0N@MMNEFFIM@adding?5group@
	push	edi
	call	_xmlSchemaPErrMemory
	add	esp, 12					; 0000000cH

; 5602 :         return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 5622 : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlSchemaA:

; 5603 :     }
; 5604 :     memset(ret, 0, sizeof(xmlSchemaModelGroupDef));
; 5605 :     ret->name = name;
; 5606 :     ret->type = XML_SCHEMA_TYPE_GROUP;
; 5607 :     ret->node = node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+24], eax

; 5608 :     ret->targetNamespace = nsName;

	mov	eax, DWORD PTR _nsName$[ebp]
	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi], 17			; 00000011H
	mov	DWORD PTR [esi+20], eax

; 5609 : 
; 5610 :     if (ctxt->isRedefine) {

	cmp	DWORD PTR [edi+100], 0
	je	SHORT $LN5@xmlSchemaA

; 5611 : 	ctxt->redef = xmlSchemaAddRedef(ctxt, ctxt->redefined,

	push	eax
	push	ebx
	push	esi
	push	DWORD PTR [edi+116]
	push	edi
	call	_xmlSchemaAddRedef
	add	esp, 20					; 00000014H
	mov	DWORD PTR [edi+120], eax

; 5612 : 	    ret, name, nsName);
; 5613 : 	if (ctxt->redef == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlSchemaA

; 5614 : 	    xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	esi
	pop	edi

; 5622 : }

	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlSchemaA:

; 5615 : 	    return(NULL);
; 5616 : 	}
; 5617 : 	ctxt->redefCounter = 0;

	mov	DWORD PTR [edi+124], 0
$LN5@xmlSchemaA:

; 5618 :     }
; 5619 :     WXS_ADD_GLOBAL(ctxt, ret);

	mov	eax, DWORD PTR [edi+28]
	push	esi
	push	5
	mov	eax, DWORD PTR [eax+16]
	add	eax, 44					; 0000002cH
	push	eax
	call	_xmlSchemaAddItemSize

; 5620 :     WXS_ADD_PENDING(ctxt, ret);

	mov	ecx, DWORD PTR [edi+28]
	push	esi
	add	ecx, 20					; 00000014H
	push	10					; 0000000aH
	push	ecx
	call	_xmlSchemaAddItemSize
	add	esp, 24					; 00000018H

; 5621 :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 5622 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemaA:
	pop	edi

; 5596 :         return (NULL);

	xor	eax, eax

; 5622 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaAddModelGroupDefinition ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddParticle
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_min$ = 16						; size = 4
_max$ = 20						; size = 4
_xmlSchemaAddParticle PROC				; COMDAT

; 5543 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlSchemaA

; 5544 :     xmlSchemaParticlePtr ret = NULL;
; 5545 :     if (ctxt == NULL)
; 5546 :         return (NULL);

	xor	eax, eax
	pop	edi

; 5574 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaA:
	push	esi

; 5547 : 
; 5548 : #ifdef DEBUG
; 5549 :     fprintf(stderr, "Adding particle component\n");
; 5550 : #endif
; 5551 :     ret = (xmlSchemaParticlePtr)

	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5552 : 	xmlMalloc(sizeof(xmlSchemaParticle));
; 5553 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN3@xmlSchemaA

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [edi+20]

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BO@IIFFCFND@allocating?5particle?5component@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 5554 : 	xmlSchemaPErrMemory(ctxt, "allocating particle component",
; 5555 : 	    NULL);
; 5556 : 	return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 5574 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaA:

; 5557 :     }
; 5558 :     ret->type = XML_SCHEMA_TYPE_PARTICLE;
; 5559 :     ret->annot = NULL;
; 5560 :     ret->node = node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [esi+24], eax

; 5561 :     ret->minOccurs = min;

	mov	eax, DWORD PTR _min$[ebp]
	mov	DWORD PTR [esi+16], eax

; 5562 :     ret->maxOccurs = max;

	mov	eax, DWORD PTR _max$[ebp]
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi], 25			; 00000019H
	mov	DWORD PTR [esi+4], 0

; 5563 :     ret->next = NULL;

	mov	DWORD PTR [esi+8], 0

; 5564 :     ret->children = NULL;

	mov	DWORD PTR [esi+12], 0

; 5565 : 
; 5566 :     WXS_ADD_LOCAL(ctxt, ret);

	mov	eax, DWORD PTR [edi+28]
	push	esi
	push	10					; 0000000aH
	mov	eax, DWORD PTR [eax+16]
	add	eax, 48					; 00000030H
	push	eax
	call	_xmlSchemaAddItemSize
	add	esp, 12					; 0000000cH

; 5567 :     /*
; 5568 :     * Note that addition to pending components will be done locally
; 5569 :     * to the specific parsing function, since the most particles
; 5570 :     * need not to be fixed up (i.e. the reference to be resolved).
; 5571 :     * REMOVED: WXS_ADD_PENDING(ctxt, ret);
; 5572 :     */
; 5573 :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 5574 : }

	pop	ebp
	ret	0
_xmlSchemaAddParticle ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddModelGroup
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_type$ = 16						; size = 4
_node$ = 20						; size = 4
_xmlSchemaAddModelGroup PROC				; COMDAT

; 5503 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN3@xmlSchemaA

; 5504 :     xmlSchemaModelGroupPtr ret = NULL;
; 5505 : 
; 5506 :     if ((ctxt == NULL) || (schema == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	$LN3@xmlSchemaA

; 5508 : 
; 5509 :     ret = (xmlSchemaModelGroupPtr)

	push	esi
	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5510 : 	xmlMalloc(sizeof(xmlSchemaModelGroup));
; 5511 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlSchemaA

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [edi+20]

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CB@MIJFJDPK@allocating?5model?5group?5componen@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 5512 : 	xmlSchemaPErrMemory(ctxt, "allocating model group component",
; 5513 : 	    NULL);
; 5514 : 	return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 5524 : }

	pop	ebp
	ret	0
$LN4@xmlSchemaA:

; 5515 :     }
; 5516 :     memset(ret, 0, sizeof(xmlSchemaModelGroup));
; 5517 :     ret->type = type;
; 5518 :     ret->node = node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	push	ebx
	mov	ebx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi], ebx

; 5519 :     WXS_ADD_LOCAL(ctxt, ret);

	mov	eax, DWORD PTR [edi+28]
	push	esi
	push	10					; 0000000aH
	mov	eax, DWORD PTR [eax+16]
	add	eax, 48					; 00000030H
	push	eax
	call	_xmlSchemaAddItemSize
	add	esp, 12					; 0000000cH

; 5520 :     if ((type == XML_SCHEMA_TYPE_SEQUENCE) ||

	cmp	ebx, 6
	je	SHORT $LN6@xmlSchemaA
	cmp	ebx, 7
	jne	SHORT $LN5@xmlSchemaA
$LN6@xmlSchemaA:

; 5521 : 	(type == XML_SCHEMA_TYPE_CHOICE))
; 5522 : 	WXS_ADD_PENDING(ctxt, ret);

	mov	ecx, DWORD PTR [edi+28]
	push	esi
	add	ecx, 20					; 00000014H
	push	10					; 0000000aH
	push	ecx
	call	_xmlSchemaAddItemSize
	add	esp, 12					; 0000000cH
$LN5@xmlSchemaA:

; 5523 :     return (ret);

	pop	ebx
	mov	eax, esi
	pop	esi
	pop	edi

; 5524 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaA:

; 5507 :         return (NULL);

	xor	eax, eax
	pop	edi

; 5524 : }

	pop	ebp
	ret	0
_xmlSchemaAddModelGroup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddAttributeUseProhib
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_xmlSchemaAddAttributeUseProhib PROC			; COMDAT

; 5469 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlSchemaA

; 1884 :     if (ctxt != NULL)

	mov	eax, DWORD PTR _pctxt$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaA

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [eax+20]
$LN5@xmlSchemaA:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CF@BKCCIOBM@allocating?5attribute?5use?5prohib@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 5470 :     xmlSchemaAttributeUseProhibPtr ret;
; 5471 : 
; 5472 :     ret = (xmlSchemaAttributeUseProhibPtr)
; 5473 : 	xmlMalloc(sizeof(xmlSchemaAttributeUseProhib));
; 5474 :     if (ret == NULL) {
; 5475 : 	xmlSchemaPErrMemory(pctxt,
; 5476 : 	    "allocating attribute use prohibition", NULL);
; 5477 : 	return (NULL);

	xor	eax, eax
	pop	esi

; 5483 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaA:

; 5478 :     }
; 5479 :     memset(ret, 0, sizeof(xmlSchemaAttributeUseProhib));
; 5480 :     ret->type = XML_SCHEMA_EXTRA_ATTR_USE_PROHIB;
; 5481 :     WXS_ADD_LOCAL(pctxt, ret);

	mov	ecx, DWORD PTR _pctxt$[ebp]
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi], 2001			; 000007d1H
	mov	ecx, DWORD PTR [ecx+28]
	push	esi
	push	10					; 0000000aH
	mov	ecx, DWORD PTR [ecx+16]
	add	ecx, 48					; 00000030H
	push	ecx
	call	_xmlSchemaAddItemSize
	add	esp, 12					; 0000000cH

; 5482 :     return (ret);

	mov	eax, esi
	pop	esi

; 5483 : }

	pop	ebp
	ret	0
_xmlSchemaAddAttributeUseProhib ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaNewQNameRef
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_refType$ = 12						; size = 4
_refName$ = 16						; size = 4
_refNs$ = 20						; size = 4
_xmlSchemaNewQNameRef PROC				; COMDAT

; 5444 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlSchemaN

; 1884 :     if (ctxt != NULL)

	mov	eax, DWORD PTR _pctxt$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaN

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [eax+20]
$LN5@xmlSchemaN:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CA@BENLLJIB@allocating?5QName?5reference?5item@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 5445 :     xmlSchemaQNameRefPtr ret;
; 5446 : 
; 5447 :     ret = (xmlSchemaQNameRefPtr)
; 5448 : 	xmlMalloc(sizeof(xmlSchemaQNameRef));
; 5449 :     if (ret == NULL) {
; 5450 : 	xmlSchemaPErrMemory(pctxt,
; 5451 : 	    "allocating QName reference item", NULL);
; 5452 : 	return (NULL);

	xor	eax, eax
	pop	esi

; 5465 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaN:

; 5453 :     }
; 5454 :     ret->node = NULL;
; 5455 :     ret->type = XML_SCHEMA_EXTRA_QNAMEREF;
; 5456 :     ret->name = refName;

	mov	eax, DWORD PTR _refName$[ebp]
	mov	DWORD PTR [esi+12], eax

; 5457 :     ret->targetNamespace = refNs;

	mov	eax, DWORD PTR _refNs$[ebp]
	mov	DWORD PTR [esi+16], eax

; 5458 :     ret->item = NULL;
; 5459 :     ret->itemType = refType;

	mov	eax, DWORD PTR _refType$[ebp]
	mov	DWORD PTR [esi+8], eax

; 5460 :     /*
; 5461 :     * Store the reference item in the schema.
; 5462 :     */
; 5463 :     WXS_ADD_LOCAL(pctxt, ret);

	mov	eax, DWORD PTR _pctxt$[ebp]
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi], 2000			; 000007d0H
	mov	DWORD PTR [esi+4], 0
	mov	eax, DWORD PTR [eax+28]
	push	esi
	push	10					; 0000000aH
	mov	eax, DWORD PTR [eax+16]
	add	eax, 48					; 00000030H
	push	eax
	call	_xmlSchemaAddItemSize
	add	esp, 12					; 0000000cH

; 5464 :     return (ret);

	mov	eax, esi
	pop	esi

; 5465 : }

	pop	ebp
	ret	0
_xmlSchemaNewQNameRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddType
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_type$ = 16						; size = 4
_name$ = 20						; size = 4
_nsName$ = 24						; size = 4
_node$ = 28						; size = 4
_topLevel$ = 32						; size = 4
_xmlSchemaAddType PROC					; COMDAT

; 5406 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN3@xmlSchemaA

; 5407 :     xmlSchemaTypePtr ret = NULL;
; 5408 : 
; 5409 :     if ((ctxt == NULL) || (schema == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	$LN3@xmlSchemaA

; 5411 : 
; 5412 :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	edi
	push	120					; 00000078H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 5413 :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN4@xmlSchemaA

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [esi+20]

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BA@BHDLCLLG@allocating?5type@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 5414 :         xmlSchemaPErrMemory(ctxt, "allocating type", NULL);
; 5415 :         return (NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 5437 : }

	pop	ebp
	ret	0
$LN4@xmlSchemaA:

; 5416 :     }
; 5417 :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	edi
	call	_memset

; 5418 :     ret->type = type;

	mov	eax, DWORD PTR _type$[ebp]
	add	esp, 12					; 0000000cH

; 5419 :     ret->name = name;
; 5420 :     ret->targetNamespace = nsName;
; 5421 :     ret->node = node;
; 5422 :     if (topLevel) {

	cmp	DWORD PTR _topLevel$[ebp], 0
	mov	ecx, DWORD PTR _name$[ebp]
	mov	edx, DWORD PTR _nsName$[ebp]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edi+8], ecx
	mov	DWORD PTR [edi+112], edx
	mov	DWORD PTR [edi+36], eax
	je	SHORT $LN5@xmlSchemaA

; 5423 : 	if (ctxt->isRedefine) {

	cmp	DWORD PTR [esi+100], 0
	je	SHORT $LN7@xmlSchemaA

; 5424 : 	    ctxt->redef = xmlSchemaAddRedef(ctxt, ctxt->redefined,

	push	edx
	push	ecx
	push	edi
	push	DWORD PTR [esi+116]
	push	esi
	call	_xmlSchemaAddRedef
	add	esp, 20					; 00000014H
	mov	DWORD PTR [esi+120], eax

; 5425 : 		ret, name, nsName);
; 5426 : 	    if (ctxt->redef == NULL) {

	test	eax, eax
	jne	SHORT $LN8@xmlSchemaA

; 5427 : 		xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi

; 5437 : }

	pop	ebp
	ret	0
$LN8@xmlSchemaA:

; 5428 : 		return(NULL);
; 5429 : 	    }
; 5430 : 	    ctxt->redefCounter = 0;

	mov	DWORD PTR [esi+124], 0
$LN7@xmlSchemaA:

; 5431 : 	}
; 5432 : 	WXS_ADD_GLOBAL(ctxt, ret);

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, 5
	mov	eax, DWORD PTR [eax+16]
	add	eax, 44					; 0000002cH

; 5433 :     } else

	jmp	SHORT $LN6@xmlSchemaA
$LN5@xmlSchemaA:

; 5434 : 	WXS_ADD_LOCAL(ctxt, ret);

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, 10					; 0000000aH
	mov	eax, DWORD PTR [eax+16]
	add	eax, 48					; 00000030H
$LN6@xmlSchemaA:

; 5435 :     WXS_ADD_PENDING(ctxt, ret);

	push	edi
	push	ecx
	push	eax
	call	_xmlSchemaAddItemSize
	mov	eax, DWORD PTR [esi+28]
	push	edi
	add	eax, 20					; 00000014H
	push	10					; 0000000aH
	push	eax
	call	_xmlSchemaAddItemSize
	add	esp, 24					; 00000018H

; 5436 :     return (ret);

	mov	eax, edi
	pop	edi
	pop	esi

; 5437 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaA:

; 5410 :         return (NULL);

	xor	eax, eax
	pop	esi

; 5437 : }

	pop	ebp
	ret	0
_xmlSchemaAddType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddElement
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_nsName$ = 16						; size = 4
_node$ = 20						; size = 4
_topLevel$ = 24						; size = 4
_xmlSchemaAddElement PROC				; COMDAT

; 5364 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN3@xmlSchemaA

; 5365 :     xmlSchemaElementPtr ret = NULL;
; 5366 : 
; 5367 :     if ((ctxt == NULL) || (name == NULL))

	mov	ebx, DWORD PTR _name$[ebp]
	test	ebx, ebx
	je	$LN3@xmlSchemaA

; 5369 : 
; 5370 :     ret = (xmlSchemaElementPtr) xmlMalloc(sizeof(xmlSchemaElement));

	push	esi
	push	104					; 00000068H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5371 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlSchemaA

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [edi+20]

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BD@OFNGJBCE@allocating?5element@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 5372 :         xmlSchemaPErrMemory(ctxt, "allocating element", NULL);
; 5373 :         return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 5387 : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlSchemaA:

; 5374 :     }
; 5375 :     memset(ret, 0, sizeof(xmlSchemaElement));

	push	104					; 00000068H
	push	0
	push	esi
	call	_memset

; 5376 :     ret->type = XML_SCHEMA_TYPE_ELEMENT;
; 5377 :     ret->name = name;
; 5378 :     ret->targetNamespace = nsName;

	mov	eax, DWORD PTR _nsName$[ebp]
	add	esp, 12					; 0000000cH

; 5379 :     ret->node = node;
; 5380 : 
; 5381 :     if (topLevel)

	mov	edx, DWORD PTR _topLevel$[ebp]
	mov	DWORD PTR [esi+52], eax
	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [esi], 14			; 0000000eH
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+36], eax
	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [eax+16]
	test	edx, edx
	je	SHORT $LN5@xmlSchemaA

; 5382 : 	WXS_ADD_GLOBAL(ctxt, ret);

	add	ecx, 44					; 0000002cH
	jmp	SHORT $LN6@xmlSchemaA
$LN5@xmlSchemaA:

; 5383 :     else
; 5384 : 	WXS_ADD_LOCAL(ctxt, ret);

	add	ecx, 48					; 00000030H
$LN6@xmlSchemaA:

; 5385 :     WXS_ADD_PENDING(ctxt, ret);

	test	edx, edx
	mov	eax, 5
	mov	ebx, 10					; 0000000aH
	push	esi
	cmove	eax, ebx
	push	eax
	push	ecx
	call	_xmlSchemaAddItemSize
	mov	eax, DWORD PTR [edi+28]
	push	esi
	add	eax, 20					; 00000014H
	push	ebx
	push	eax
	call	_xmlSchemaAddItemSize
	add	esp, 24					; 00000018H

; 5386 :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 5387 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemaA:
	pop	edi

; 5368 :         return (NULL);

	xor	eax, eax

; 5387 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaAddElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddAttributeGroupDefinition
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_name$ = 16						; size = 4
_nsName$ = 20						; size = 4
_node$ = 24						; size = 4
_xmlSchemaAddAttributeGroupDefinition PROC		; COMDAT

; 5314 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pctxt$[ebp]
	test	edi, edi
	je	$LN3@xmlSchemaA

; 5315 :     xmlSchemaAttributeGroupPtr ret = NULL;
; 5316 : 
; 5317 :     if ((pctxt == NULL) || (name == NULL))

	mov	ebx, DWORD PTR _name$[ebp]
	test	ebx, ebx
	je	$LN3@xmlSchemaA

; 5319 : 
; 5320 :     ret = (xmlSchemaAttributeGroupPtr)

	push	esi
	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5321 :         xmlMalloc(sizeof(xmlSchemaAttributeGroup));
; 5322 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlSchemaA

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [edi+20]

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BL@LFEIBOLE@allocating?5attribute?5group@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 5323 : 	xmlSchemaPErrMemory(pctxt, "allocating attribute group", NULL);
; 5324 : 	return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 5346 : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlSchemaA:

; 5325 :     }
; 5326 :     memset(ret, 0, sizeof(xmlSchemaAttributeGroup));
; 5327 :     ret->type = XML_SCHEMA_TYPE_ATTRIBUTEGROUP;
; 5328 :     ret->name = name;
; 5329 :     ret->targetNamespace = nsName;

	mov	ecx, DWORD PTR _nsName$[ebp]

; 5330 :     ret->node = node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+56], 0

; 5331 : 
; 5332 :     /* TODO: Remove the flag. */
; 5333 :     ret->flags |= XML_SCHEMAS_ATTRGROUP_GLOBAL;

	or	DWORD PTR [esi+36], 2
	mov	DWORD PTR [esi], 16			; 00000010H
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+52], ecx
	mov	DWORD PTR [esi+32], eax

; 5334 :     if (pctxt->isRedefine) {

	cmp	DWORD PTR [edi+100], 0
	je	SHORT $LN5@xmlSchemaA

; 5335 : 	pctxt->redef = xmlSchemaAddRedef(pctxt, pctxt->redefined,

	push	ecx
	push	ebx
	push	esi
	push	DWORD PTR [edi+116]
	push	edi
	call	_xmlSchemaAddRedef
	add	esp, 20					; 00000014H
	mov	DWORD PTR [edi+120], eax

; 5336 : 	    ret, name, nsName);
; 5337 : 	if (pctxt->redef == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlSchemaA

; 5338 : 	    xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	esi
	pop	edi

; 5346 : }

	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlSchemaA:

; 5339 : 	    return(NULL);
; 5340 : 	}
; 5341 : 	pctxt->redefCounter = 0;

	mov	DWORD PTR [edi+124], 0
$LN5@xmlSchemaA:

; 5342 :     }
; 5343 :     WXS_ADD_GLOBAL(pctxt, ret);

	mov	eax, DWORD PTR [edi+28]
	push	esi
	push	5
	mov	eax, DWORD PTR [eax+16]
	add	eax, 44					; 0000002cH
	push	eax
	call	_xmlSchemaAddItemSize

; 5344 :     WXS_ADD_PENDING(pctxt, ret);

	mov	ecx, DWORD PTR [edi+28]
	push	esi
	add	ecx, 20					; 00000014H
	push	10					; 0000000aH
	push	ecx
	call	_xmlSchemaAddItemSize
	add	esp, 24					; 00000018H

; 5345 :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 5346 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemaA:
	pop	edi

; 5318 :         return (NULL);

	xor	eax, eax

; 5346 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaAddAttributeGroupDefinition ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddRedef
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_targetBucket$ = 12					; size = 4
_item$ = 16						; size = 4
_refName$ = 20						; size = 4
_refTargetNs$ = 24					; size = 4
_xmlSchemaAddRedef PROC					; COMDAT

; 5272 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	mov	edx, eax
	add	esp, 4
	test	edx, edx
	jne	SHORT $LN2@xmlSchemaA

; 1884 :     if (ctxt != NULL)

	mov	eax, DWORD PTR _pctxt$[ebp]
	test	eax, eax
	je	SHORT $LN7@xmlSchemaA

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [eax+20]
$LN7@xmlSchemaA:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BN@DCKEMFJK@allocating?5redefinition?5info@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 5273 :     xmlSchemaRedefPtr ret;
; 5274 : 
; 5275 :     ret = (xmlSchemaRedefPtr)
; 5276 : 	xmlMalloc(sizeof(xmlSchemaRedef));
; 5277 :     if (ret == NULL) {
; 5278 : 	xmlSchemaPErrMemory(pctxt,
; 5279 : 	    "allocating redefinition info", NULL);
; 5280 : 	return (NULL);

	xor	eax, eax

; 5294 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaA:

; 5281 :     }
; 5282 :     memset(ret, 0, sizeof(xmlSchemaRedef));
; 5283 :     ret->item = item;

	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx], 0
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+4], eax

; 5284 :     ret->targetBucket = targetBucket;

	mov	eax, DWORD PTR _targetBucket$[ebp]
	mov	DWORD PTR [edx+24], eax

; 5285 :     ret->refName = refName;

	mov	eax, DWORD PTR _refName$[ebp]
	mov	DWORD PTR [edx+16], eax

; 5286 :     ret->refTargetNs = refTargetNs;

	mov	eax, DWORD PTR _refTargetNs$[ebp]
	mov	DWORD PTR [edx+20], eax

; 5287 :     if (WXS_CONSTRUCTOR(pctxt)->redefs == NULL)

	mov	eax, DWORD PTR _pctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $LN3@xmlSchemaA

; 5288 : 	WXS_CONSTRUCTOR(pctxt)->redefs = ret;

	mov	DWORD PTR [ecx+28], edx

; 5291 :     WXS_CONSTRUCTOR(pctxt)->lastRedef = ret;

	mov	ecx, DWORD PTR [eax+28]

; 5292 : 
; 5293 :     return (ret);

	mov	eax, edx
	mov	DWORD PTR [ecx+32], edx

; 5294 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaA:

; 5289 :     else
; 5290 : 	WXS_CONSTRUCTOR(pctxt)->lastRedef->next = ret;

	mov	ecx, DWORD PTR [ecx+32]
	mov	DWORD PTR [ecx], edx

; 5291 :     WXS_CONSTRUCTOR(pctxt)->lastRedef = ret;

	mov	ecx, DWORD PTR [eax+28]

; 5292 : 
; 5293 :     return (ret);

	mov	eax, edx
	mov	DWORD PTR [ecx+32], edx

; 5294 : }

	pop	ebp
	ret	0
_xmlSchemaAddRedef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddAttributeUse
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlSchemaAddAttributeUse PROC				; COMDAT

; 5241 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pctxt$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlSchemaA

; 5242 :     xmlSchemaAttributeUsePtr ret = NULL;
; 5243 : 
; 5244 :     if (pctxt == NULL)
; 5245 :         return (NULL);

	xor	eax, eax
	pop	edi

; 5258 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaA:
	push	esi

; 5246 : 
; 5247 :     ret = (xmlSchemaAttributeUsePtr) xmlMalloc(sizeof(xmlSchemaAttributeUse));

	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5248 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN3@xmlSchemaA

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [edi+20]

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BF@IGICPFC@allocating?5attribute@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 5249 :         xmlSchemaPErrMemory(pctxt, "allocating attribute", NULL);
; 5250 :         return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 5258 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaA:

; 5251 :     }
; 5252 :     memset(ret, 0, sizeof(xmlSchemaAttributeUse));
; 5253 :     ret->type = XML_SCHEMA_TYPE_ATTRIBUTE_USE;
; 5254 :     ret->node = node;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi], 26			; 0000001aH

; 5255 : 
; 5256 :     WXS_ADD_LOCAL(pctxt, ret);

	mov	ecx, DWORD PTR [edi+28]
	push	esi
	push	10					; 0000000aH
	mov	ecx, DWORD PTR [ecx+16]
	add	ecx, 48					; 00000030H
	push	ecx
	call	_xmlSchemaAddItemSize
	add	esp, 12					; 0000000cH

; 5257 :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 5258 : }

	pop	ebp
	ret	0
_xmlSchemaAddAttributeUse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddAttribute
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_name$ = 16						; size = 4
_nsName$ = 20						; size = 4
_node$ = 24						; size = 4
_topLevel$ = 28						; size = 4
_xmlSchemaAddAttribute PROC				; COMDAT

; 5201 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR _topLevel$[ebp]
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN3@xmlSchemaA

; 5202 :     xmlSchemaAttributePtr ret = NULL;
; 5203 : 
; 5204 :     if ((ctxt == NULL) || (schema == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	$LN3@xmlSchemaA

; 5206 : 
; 5207 :     ret = (xmlSchemaAttributePtr) xmlMalloc(sizeof(xmlSchemaAttribute));

	push	esi
	push	76					; 0000004cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5208 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlSchemaA

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [edi+20]

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BF@IGICPFC@allocating?5attribute@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 5209 :         xmlSchemaPErrMemory(ctxt, "allocating attribute", NULL);
; 5210 :         return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 5224 : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlSchemaA:

; 5211 :     }
; 5212 :     memset(ret, 0, sizeof(xmlSchemaAttribute));

	mov	DWORD PTR [esi+4], 0

; 5213 :     ret->type = XML_SCHEMA_TYPE_ATTRIBUTE;
; 5214 :     ret->node = node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+68], 0
	mov	DWORD PTR [esi+72], 0
	mov	DWORD PTR [esi+52], eax

; 5215 :     ret->name = name;

	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR [esi+8], eax

; 5216 :     ret->targetNamespace = nsName;

	mov	eax, DWORD PTR _nsName$[ebp]
	mov	DWORD PTR [esi], 15			; 0000000fH
	mov	DWORD PTR [esi+56], eax
	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [eax+16]

; 5217 : 
; 5218 :     if (topLevel)

	test	ebx, ebx
	je	SHORT $LN5@xmlSchemaA

; 5219 : 	WXS_ADD_GLOBAL(ctxt, ret);

	add	ecx, 44					; 0000002cH
	jmp	SHORT $LN6@xmlSchemaA
$LN5@xmlSchemaA:

; 5220 :     else
; 5221 : 	WXS_ADD_LOCAL(ctxt, ret);

	add	ecx, 48					; 00000030H
$LN6@xmlSchemaA:

; 5222 :     WXS_ADD_PENDING(ctxt, ret);

	mov	edx, 10					; 0000000aH
	test	ebx, ebx
	mov	eax, 5
	push	esi
	cmove	eax, edx
	push	eax
	push	ecx
	call	_xmlSchemaAddItemSize
	mov	ecx, DWORD PTR [edi+28]
	push	esi
	add	ecx, 20					; 00000014H
	push	10					; 0000000aH
	push	ecx
	call	_xmlSchemaAddItemSize
	add	esp, 24					; 00000018H

; 5223 :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 5224 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemaA:
	pop	edi

; 5205 :         return (NULL);

	xor	eax, eax

; 5224 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaAddAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddNotation
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_name$ = 16						; size = 4
_nsName$ = 20						; size = 4
_node$ = 24						; size = 4
_xmlSchemaAddNotation PROC				; COMDAT

; 5164 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlSchemaA

; 5165 :     xmlSchemaNotationPtr ret = NULL;
; 5166 : 
; 5167 :     if ((ctxt == NULL) || (schema == NULL) || (name == NULL))

	cmp	DWORD PTR _schema$[ebp], 0
	je	SHORT $LN3@xmlSchemaA
	mov	ebx, DWORD PTR _name$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@xmlSchemaA

; 5169 : 
; 5170 :     ret = (xmlSchemaNotationPtr) xmlMalloc(sizeof(xmlSchemaNotation));

	push	esi
	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5171 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlSchemaA

; 5172 :         xmlSchemaPErrMemory(ctxt, "add annotation", NULL);

	push	eax
	push	OFFSET ??_C@_0P@HKPLIAHO@add?5annotation@
	push	edi
	call	_xmlSchemaPErrMemory
	add	esp, 12					; 0000000cH

; 5173 :         return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 5183 : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlSchemaA:

; 5174 :     }
; 5175 :     memset(ret, 0, sizeof(xmlSchemaNotation));
; 5176 :     ret->type = XML_SCHEMA_TYPE_NOTATION;
; 5177 :     ret->name = name;
; 5178 :     ret->targetNamespace = nsName;

	mov	ecx, DWORD PTR _nsName$[ebp]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi], 18			; 00000012H
	mov	DWORD PTR [esi+4], ebx

; 5179 :     /* TODO: do we need the node to be set?
; 5180 :     * ret->node = node;*/
; 5181 :     WXS_ADD_GLOBAL(ctxt, ret);

	mov	ecx, DWORD PTR [edi+28]
	push	esi
	push	5
	mov	ecx, DWORD PTR [ecx+16]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	_xmlSchemaAddItemSize
	add	esp, 12					; 0000000cH

; 5182 :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 5183 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemaA:
	pop	edi

; 5168 :         return (NULL);

	xor	eax, eax

; 5183 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaAddNotation ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFindRedefCompInGraph
_TEXT	SEGMENT
tv380 = 8						; size = 4
_bucket$ = 8						; size = 4
_type$ = 12						; size = 4
_name$ = 16						; size = 4
_nsName$ = 20						; size = 4
_xmlSchemaFindRedefCompInGraph PROC			; COMDAT

; 5073 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _bucket$[ebp]
	test	ebx, ebx
	je	$LN11@xmlSchemaF

; 5074 :     xmlSchemaBasicItemPtr ret;
; 5075 :     int i;
; 5076 : 
; 5077 :     if ((bucket == NULL) || (name == NULL))

	mov	ecx, DWORD PTR _name$[ebp]
	test	ecx, ecx
	je	$LN11@xmlSchemaF

; 5079 :     if ((bucket->globals == NULL) ||

	mov	esi, DWORD PTR [ebx+44]
	mov	edi, DWORD PTR _type$[ebp]
	test	esi, esi
	je	SHORT $subschemas$50
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR tv380[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN46@xmlSchemaF

; 5080 : 	(bucket->globals->nbItems == 0))
; 5081 : 	goto subschemas;
; 5082 :     /*
; 5083 :     * Search in global components.
; 5084 :     */
; 5085 :     for (i = 0; i < bucket->globals->nbItems; i++) {

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN46@xmlSchemaF

; 5086 : 	ret = bucket->globals->items[i];

	mov	esi, DWORD PTR [esi]
	mov	eax, ecx
$LL4@xmlSchemaF:
	mov	ecx, DWORD PTR [esi]

; 5087 : 	if (ret->type == type) {

	cmp	DWORD PTR [ecx], edi
	jne	SHORT $LN2@xmlSchemaF

; 5088 : 	    switch (type) {

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 13					; 0000000dH
	ja	$LN11@xmlSchemaF
	movzx	eax, BYTE PTR $LN39@xmlSchemaF[eax]
	jmp	DWORD PTR $LN49@xmlSchemaF[eax*4]
$LN15@xmlSchemaF:

; 5089 : 		case XML_SCHEMA_TYPE_COMPLEX:
; 5090 : 		case XML_SCHEMA_TYPE_SIMPLE:
; 5091 : 		    if ((WXS_COMP_NAME(ret, xmlSchemaTypePtr) == name) &&

	mov	eax, DWORD PTR _name$[ebp]
	cmp	DWORD PTR [ecx+8], eax
	jne	SHORT $LN43@xmlSchemaF
	mov	eax, DWORD PTR _nsName$[ebp]
	cmp	DWORD PTR [ecx+112], eax

; 5092 : 			(WXS_COMP_TNS(ret, xmlSchemaTypePtr) ==
; 5093 : 			nsName))
; 5094 : 		    {
; 5095 : 			return(ret);
; 5096 : 		    }
; 5097 : 		    break;

	jmp	SHORT $LN47@xmlSchemaF
$LN17@xmlSchemaF:

; 5098 : 		case XML_SCHEMA_TYPE_GROUP:
; 5099 : 		    if ((WXS_COMP_NAME(ret,
; 5100 : 			    xmlSchemaModelGroupDefPtr) == name) &&

	mov	eax, DWORD PTR _name$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jne	SHORT $LN43@xmlSchemaF
	mov	eax, DWORD PTR _nsName$[ebp]
	cmp	DWORD PTR [ecx+20], eax

; 5101 : 			(WXS_COMP_TNS(ret,
; 5102 : 			    xmlSchemaModelGroupDefPtr) == nsName))
; 5103 : 		    {
; 5104 : 			return(ret);
; 5105 : 		    }
; 5106 : 		    break;

	jmp	SHORT $LN47@xmlSchemaF
$LN19@xmlSchemaF:

; 5107 : 		case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 5108 : 		    if ((WXS_COMP_NAME(ret,
; 5109 : 			    xmlSchemaAttributeGroupPtr) == name) &&

	mov	eax, DWORD PTR _name$[ebp]
	cmp	DWORD PTR [ecx+8], eax
	jne	SHORT $LN43@xmlSchemaF
	mov	eax, DWORD PTR _nsName$[ebp]
	cmp	DWORD PTR [ecx+52], eax
$LN47@xmlSchemaF:

; 5080 : 	(bucket->globals->nbItems == 0))
; 5081 : 	goto subschemas;
; 5082 :     /*
; 5083 :     * Search in global components.
; 5084 :     */
; 5085 :     for (i = 0; i < bucket->globals->nbItems; i++) {

	je	SHORT $LN30@xmlSchemaF
$LN43@xmlSchemaF:
	mov	eax, DWORD PTR tv380[ebp]
$LN2@xmlSchemaF:
	inc	edx
	add	esi, 4
	cmp	edx, eax
	jl	SHORT $LL4@xmlSchemaF
$LN46@xmlSchemaF:

; 5110 : 			(WXS_COMP_TNS(ret,
; 5111 : 			    xmlSchemaAttributeGroupPtr) == nsName))
; 5112 : 		    {
; 5113 : 			return(ret);
; 5114 : 		    }
; 5115 : 		    break;
; 5116 : 		default:
; 5117 : 		    /* Should not be hit. */
; 5118 : 		    return(NULL);
; 5119 : 	    }
; 5120 : 	}
; 5121 :     }
; 5122 : subschemas:
; 5123 :     /*
; 5124 :     * Process imported/included schemas.
; 5125 :     */
; 5126 :     if (bucket->relations != NULL) {

	mov	ecx, DWORD PTR _name$[ebp]
$subschemas$50:
	mov	esi, DWORD PTR [ebx+24]
	test	esi, esi
	je	SHORT $LN11@xmlSchemaF

; 5127 : 	xmlSchemaSchemaRelationPtr rel = bucket->relations;
; 5128 : 
; 5129 : 	/*
; 5130 : 	* TODO: Marking the bucket will not avoid multiple searches
; 5131 : 	* in the same schema, but avoids at least circularity.
; 5132 : 	*/
; 5133 : 	bucket->flags |= XML_SCHEMA_BUCKET_MARKED;

	or	DWORD PTR [ebx+4], 1
	npad	3
$LL9@xmlSchemaF:

; 5134 : 	do {
; 5135 : 	    if ((rel->bucket != NULL) &&

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN24@xmlSchemaF
	test	BYTE PTR [eax+4], 1
	jne	SHORT $LN24@xmlSchemaF

; 5136 : 		((rel->bucket->flags & XML_SCHEMA_BUCKET_MARKED) == 0)) {
; 5137 : 		ret = xmlSchemaFindRedefCompInGraph(rel->bucket,

	push	DWORD PTR _nsName$[ebp]
	push	ecx
	push	edi
	push	eax
	call	_xmlSchemaFindRedefCompInGraph
	add	esp, 16					; 00000010H

; 5138 : 		    type, name, nsName);
; 5139 : 		if (ret != NULL)

	test	eax, eax
	jne	SHORT $LN1@xmlSchemaF
$LN24@xmlSchemaF:

; 5140 : 		    return(ret);
; 5141 : 	    }
; 5142 : 	    rel = rel->next;

	mov	esi, DWORD PTR [esi]

; 5143 : 	} while (rel != NULL);

	test	esi, esi
	je	SHORT $LN32@xmlSchemaF
	mov	ecx, DWORD PTR _name$[ebp]
	jmp	SHORT $LL9@xmlSchemaF
$LN30@xmlSchemaF:
	pop	edi

; 5145 :     }
; 5146 :     return(NULL);
; 5147 : }

	pop	esi
	mov	eax, ecx
	pop	ebx
	pop	ebp
	ret	0
$LN32@xmlSchemaF:

; 5144 : 	 bucket->flags ^= XML_SCHEMA_BUCKET_MARKED;

	xor	DWORD PTR [ebx+4], 1
$LN11@xmlSchemaF:

; 5078 : 	return(NULL);

	xor	eax, eax
$LN1@xmlSchemaF:
	pop	edi

; 5145 :     }
; 5146 :     return(NULL);
; 5147 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN49@xmlSchemaF:
	DD	$LN15@xmlSchemaF
	DD	$LN19@xmlSchemaF
	DD	$LN17@xmlSchemaF
	DD	$LN11@xmlSchemaF
$LN39@xmlSchemaF:
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	2
_xmlSchemaFindRedefCompInGraph ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIsBlank
_TEXT	SEGMENT
_str$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlSchemaIsBlank PROC					; COMDAT

; 5043 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _len$[ebp]
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _str$[ebp]
	test	ecx, ecx
	je	SHORT $LN26@xmlSchemaI

; 5047 : 	while (*str != 0) {

	mov	al, BYTE PTR [ecx]
	test	al, al
	je	SHORT $LN26@xmlSchemaI

; 5044 :     if (str == NULL)
; 5045 :         return (1);
; 5046 :     if (len < 0) {

	test	esi, esi
	jns	SHORT $LN31@xmlSchemaI
$LL2@xmlSchemaI:

; 5048 : 	    if (!(IS_BLANK_CH(*str)))

	cmp	al, 32					; 00000020H
	je	SHORT $LN9@xmlSchemaI
	cmp	al, 9
	jb	SHORT $LN10@xmlSchemaI
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN9@xmlSchemaI
$LN10@xmlSchemaI:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN17@xmlSchemaI
$LN9@xmlSchemaI:

; 5047 : 	while (*str != 0) {

	mov	al, BYTE PTR [ecx+1]

; 5049 : 		return (0);
; 5050 : 	    str++;

	inc	ecx
	test	al, al
	jne	SHORT $LL2@xmlSchemaI
$LN26@xmlSchemaI:

; 5057 :     }
; 5058 : 
; 5059 :     return (1);

	mov	eax, 1
	pop	esi

; 5060 : }

	pop	ebp
	ret	0
$LL4@xmlSchemaI:

; 5051 : 	}
; 5052 :     } else while ((*str != 0) && (len != 0)) {

	test	esi, esi
$LN31@xmlSchemaI:
	je	SHORT $LN26@xmlSchemaI

; 5053 : 	if (!(IS_BLANK_CH(*str)))

	cmp	al, 32					; 00000020H
	je	SHORT $LN11@xmlSchemaI
	cmp	al, 9
	jb	SHORT $LN12@xmlSchemaI
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN11@xmlSchemaI
$LN12@xmlSchemaI:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN17@xmlSchemaI
$LN11@xmlSchemaI:

; 5051 : 	}
; 5052 :     } else while ((*str != 0) && (len != 0)) {

	mov	al, BYTE PTR [ecx+1]

; 5055 : 	str++;

	inc	ecx

; 5056 : 	len--;

	dec	esi
	test	al, al
	jne	SHORT $LL4@xmlSchemaI

; 5057 :     }
; 5058 : 
; 5059 :     return (1);

	mov	eax, 1
	pop	esi

; 5060 : }

	pop	ebp
	ret	0
$LN17@xmlSchemaI:

; 5054 : 	    return (0);

	xor	eax, eax
	pop	esi

; 5060 : }

	pop	ebp
	ret	0
_xmlSchemaIsBlank ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetNamedComponent
_TEXT	SEGMENT
_schema$ = 8						; size = 4
_itemType$ = 12						; size = 4
_name$ = 16						; size = 4
_targetNs$ = 20						; size = 4
_xmlSchemaGetNamedComponent PROC			; COMDAT

; 5009 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _itemType$[ebp]
	cmp	eax, 14					; 0000000eH
	je	$LN5@xmlSchemaG

; 5010 :     switch (itemType) {

	push	esi
	cmp	eax, 17					; 00000011H
	je	SHORT $LN4@xmlSchemaG

; 5016 : 		name, targetNs));
; 5017 : 	default:
; 5018 : 	    TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	5018					; 0000139aH
	push	OFFSET ??_C@_0GM@IJCDLDON@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H

; 5019 : 	    return (NULL);

	xor	eax, eax
	pop	esi

; 5020 :     }
; 5021 : }

	pop	ebp
	ret	0
$LN4@xmlSchemaG:
	push	ebx

; 4943 :     if ((name == NULL) || (schema == NULL))

	mov	ebx, DWORD PTR _name$[ebp]
	xor	esi, esi
	push	edi
	test	ebx, ebx
	je	SHORT $LN10@xmlSchemaG
	mov	edi, DWORD PTR _schema$[ebp]
	test	edi, edi
	je	SHORT $LN10@xmlSchemaG

; 4945 :     if (schema != NULL) {
; 4946 : 	WXS_FIND_GLOBAL_ITEM(groupDecl)

	push	DWORD PTR [edi+4]
	push	DWORD PTR _targetNs$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlSchemaG
	push	ebx
	push	DWORD PTR [edi+56]
	call	_xmlHashLookup
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	SHORT $LN8@xmlSchemaG
$LN13@xmlSchemaG:
	push	DWORD PTR [edi+48]
	call	_xmlHashSize
	add	esp, 4
	cmp	eax, 1
	jle	SHORT $LN8@xmlSchemaG
	mov	ecx, DWORD PTR _targetNs$[ebp]
	mov	eax, OFFSET ??_C@_02IEBMKJDF@?$CD?$CD@
	test	ecx, ecx
	cmovne	eax, ecx
	push	eax
	mov	eax, DWORD PTR [edi+48]
	push	eax
	call	_xmlHashLookup
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlSchemaG
	mov	eax, DWORD PTR [eax+52]
	push	ebx
	push	DWORD PTR [eax+56]
	call	_xmlHashLookup
	add	esp, 8
	mov	esi, eax
$exit$21:

; 5011 : 	case XML_SCHEMA_TYPE_GROUP:
; 5012 : 	    return ((xmlSchemaBasicItemPtr) xmlSchemaGetGroup(schema,

	pop	edi
	pop	ebx
	pop	esi

; 5020 :     }
; 5021 : }

	pop	ebp
	ret	0
$LN10@xmlSchemaG:

; 4944 :         return (NULL);

	xor	esi, esi
$LN8@xmlSchemaG:

; 5011 : 	case XML_SCHEMA_TYPE_GROUP:
; 5012 : 	    return ((xmlSchemaBasicItemPtr) xmlSchemaGetGroup(schema,

	pop	edi
	pop	ebx
	mov	eax, esi
	pop	esi

; 5020 :     }
; 5021 : }

	pop	ebp
	ret	0
$LN5@xmlSchemaG:

; 5013 : 		name, targetNs));
; 5014 : 	case XML_SCHEMA_TYPE_ELEMENT:
; 5015 : 	    return ((xmlSchemaBasicItemPtr) xmlSchemaGetElem(schema,

	push	DWORD PTR _targetNs$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _schema$[ebp]
	call	_xmlSchemaGetElem
	add	esp, 12					; 0000000cH

; 5020 :     }
; 5021 : }

	pop	ebp
	ret	0
_xmlSchemaGetNamedComponent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetIDC
_TEXT	SEGMENT
_schema$ = 8						; size = 4
_name$ = 12						; size = 4
_nsName$ = 16						; size = 4
_xmlSchemaGetIDC PROC					; COMDAT

; 4982 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _name$[ebp]
	xor	edi, edi
	test	ebx, ebx
	je	SHORT $LN3@xmlSchemaG

; 4983 :     xmlSchemaIDCPtr ret = NULL;
; 4984 : 
; 4985 :     if ((name == NULL) || (schema == NULL))

	mov	esi, DWORD PTR _schema$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaG

; 4986 :         return (NULL);
; 4987 :     if (schema != NULL) {
; 4988 : 	WXS_FIND_GLOBAL_ITEM(idcDef)

	push	DWORD PTR [esi+4]
	push	DWORD PTR _nsName$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlSchemaG
	push	ebx
	push	DWORD PTR [esi+76]
	call	_xmlHashLookup
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	jne	SHORT $exit$13
$LN6@xmlSchemaG:
	push	DWORD PTR [esi+48]
	call	_xmlHashSize
	add	esp, 4
	cmp	eax, 1
	jle	SHORT $exit$13
	mov	ecx, DWORD PTR _nsName$[ebp]
	mov	eax, OFFSET ??_C@_02IEBMKJDF@?$CD?$CD@
	test	ecx, ecx
	cmovne	eax, ecx
	push	eax
	push	DWORD PTR [esi+48]
	call	_xmlHashLookup
	add	esp, 8
	test	eax, eax
	je	SHORT $exit$13
	mov	eax, DWORD PTR [eax+52]
	push	ebx
	push	DWORD PTR [eax+76]
	call	_xmlHashLookup
	add	esp, 8
	mov	edi, eax
$exit$13:

; 4989 :     }
; 4990 : exit:
; 4991 :     return (ret);

	mov	eax, edi
	pop	edi

; 4992 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemaG:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaGetIDC ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetNotation
_TEXT	SEGMENT
_schema$ = 8						; size = 4
_name$ = 12						; size = 4
_nsName$ = 16						; size = 4
_xmlSchemaGetNotation PROC				; COMDAT

; 4966 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _name$[ebp]
	xor	edi, edi
	test	ebx, ebx
	je	SHORT $LN3@xmlSchemaG

; 4967 :     xmlSchemaNotationPtr ret = NULL;
; 4968 : 
; 4969 :     if ((name == NULL) || (schema == NULL))

	mov	esi, DWORD PTR _schema$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaG

; 4970 :         return (NULL);
; 4971 :     if (schema != NULL) {
; 4972 : 	WXS_FIND_GLOBAL_ITEM(notaDecl)

	push	DWORD PTR [esi+4]
	push	DWORD PTR _nsName$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlSchemaG
	push	ebx
	push	DWORD PTR [esi+44]
	call	_xmlHashLookup
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	jne	SHORT $exit$13
$LN6@xmlSchemaG:
	push	DWORD PTR [esi+48]
	call	_xmlHashSize
	add	esp, 4
	cmp	eax, 1
	jle	SHORT $exit$13
	mov	ecx, DWORD PTR _nsName$[ebp]
	mov	eax, OFFSET ??_C@_02IEBMKJDF@?$CD?$CD@
	test	ecx, ecx
	cmovne	eax, ecx
	push	eax
	push	DWORD PTR [esi+48]
	call	_xmlHashLookup
	add	esp, 8
	test	eax, eax
	je	SHORT $exit$13
	mov	eax, DWORD PTR [eax+52]
	push	ebx
	push	DWORD PTR [eax+44]
	call	_xmlHashLookup
	add	esp, 8
	mov	edi, eax
$exit$13:

; 4973 :     }
; 4974 : exit:
; 4975 :     return (ret);

	mov	eax, edi
	pop	edi

; 4976 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemaG:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaGetNotation ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetGroup
_TEXT	SEGMENT
_schema$ = 8						; size = 4
_name$ = 12						; size = 4
_nsName$ = 16						; size = 4
_xmlSchemaGetGroup PROC					; COMDAT

; 4940 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _name$[ebp]
	xor	edi, edi
	test	ebx, ebx
	je	SHORT $LN3@xmlSchemaG

; 4941 :     xmlSchemaModelGroupDefPtr ret = NULL;
; 4942 : 
; 4943 :     if ((name == NULL) || (schema == NULL))

	mov	esi, DWORD PTR _schema$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaG

; 4944 :         return (NULL);
; 4945 :     if (schema != NULL) {
; 4946 : 	WXS_FIND_GLOBAL_ITEM(groupDecl)

	push	DWORD PTR [esi+4]
	push	DWORD PTR _nsName$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlSchemaG
	push	ebx
	push	DWORD PTR [esi+56]
	call	_xmlHashLookup
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	jne	SHORT $exit$13
$LN6@xmlSchemaG:
	push	DWORD PTR [esi+48]
	call	_xmlHashSize
	add	esp, 4
	cmp	eax, 1
	jle	SHORT $exit$13
	mov	ecx, DWORD PTR _nsName$[ebp]
	mov	eax, OFFSET ??_C@_02IEBMKJDF@?$CD?$CD@
	test	ecx, ecx
	cmovne	eax, ecx
	push	eax
	push	DWORD PTR [esi+48]
	call	_xmlHashLookup
	add	esp, 8
	test	eax, eax
	je	SHORT $exit$13
	mov	eax, DWORD PTR [eax+52]
	push	ebx
	push	DWORD PTR [eax+56]
	call	_xmlHashLookup
	add	esp, 8
	mov	edi, eax
$exit$13:

; 4947 :     }
; 4948 : exit:
; 4949 : 
; 4950 : #ifdef DEBUG
; 4951 :     if (ret == NULL) {
; 4952 :         if (nsName == NULL)
; 4953 :             fprintf(stderr, "Unable to lookup group %s", name);
; 4954 :         else
; 4955 :             fprintf(stderr, "Unable to lookup group %s:%s", name,
; 4956 :                     nsName);
; 4957 :     }
; 4958 : #endif
; 4959 :     return (ret);

	mov	eax, edi
	pop	edi

; 4960 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemaG:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaGetGroup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetAttributeGroup
_TEXT	SEGMENT
_schema$ = 8						; size = 4
_name$ = 12						; size = 4
_nsName$ = 16						; size = 4
_xmlSchemaGetAttributeGroup PROC			; COMDAT

; 4900 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _name$[ebp]
	xor	edi, edi
	test	ebx, ebx
	je	SHORT $LN3@xmlSchemaG

; 4901 :     xmlSchemaAttributeGroupPtr ret = NULL;
; 4902 : 
; 4903 :     if ((name == NULL) || (schema == NULL))

	mov	esi, DWORD PTR _schema$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaG

; 4904 :         return (NULL);
; 4905 :     if (schema != NULL) {
; 4906 : 	WXS_FIND_GLOBAL_ITEM(attrgrpDecl)

	push	DWORD PTR [esi+4]
	push	DWORD PTR _nsName$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlSchemaG
	push	ebx
	push	DWORD PTR [esi+36]
	call	_xmlHashLookup
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	jne	SHORT $exit$13
$LN6@xmlSchemaG:
	push	DWORD PTR [esi+48]
	call	_xmlHashSize
	add	esp, 4
	cmp	eax, 1
	jle	SHORT $exit$13
	mov	ecx, DWORD PTR _nsName$[ebp]
	mov	eax, OFFSET ??_C@_02IEBMKJDF@?$CD?$CD@
	test	ecx, ecx
	cmovne	eax, ecx
	push	eax
	push	DWORD PTR [esi+48]
	call	_xmlHashLookup
	add	esp, 8
	test	eax, eax
	je	SHORT $exit$13
	mov	eax, DWORD PTR [eax+52]
	push	ebx
	push	DWORD PTR [eax+36]
	call	_xmlHashLookup
	add	esp, 8
	mov	edi, eax
$exit$13:

; 4907 :     }
; 4908 : exit:
; 4909 :     /* TODO:
; 4910 :     if ((ret != NULL) && (ret->redef != NULL)) {
; 4911 : 	* Return the last redefinition. *
; 4912 : 	ret = ret->redef;
; 4913 :     }
; 4914 :     */
; 4915 : #ifdef DEBUG
; 4916 :     if (ret == NULL) {
; 4917 :         if (nsName == NULL)
; 4918 :             fprintf(stderr, "Unable to lookup attribute group %s", name);
; 4919 :         else
; 4920 :             fprintf(stderr, "Unable to lookup attribute group %s:%s", name,
; 4921 :                     nsName);
; 4922 :     }
; 4923 : #endif
; 4924 :     return (ret);

	mov	eax, edi
	pop	edi

; 4925 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemaG:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaGetAttributeGroup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetAttributeDecl
_TEXT	SEGMENT
_schema$ = 8						; size = 4
_name$ = 12						; size = 4
_nsName$ = 16						; size = 4
_xmlSchemaGetAttributeDecl PROC				; COMDAT

; 4866 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _name$[ebp]
	xor	edi, edi
	test	ebx, ebx
	je	SHORT $LN3@xmlSchemaG

; 4867 :     xmlSchemaAttributePtr ret = NULL;
; 4868 : 
; 4869 :     if ((name == NULL) || (schema == NULL))

	mov	esi, DWORD PTR _schema$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaG

; 4870 :         return (NULL);
; 4871 :     if (schema != NULL) {
; 4872 : 	WXS_FIND_GLOBAL_ITEM(attrDecl)

	push	DWORD PTR [esi+4]
	push	DWORD PTR _nsName$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlSchemaG
	push	ebx
	push	DWORD PTR [esi+32]
	call	_xmlHashLookup
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	jne	SHORT $exit$13
$LN6@xmlSchemaG:
	push	DWORD PTR [esi+48]
	call	_xmlHashSize
	add	esp, 4
	cmp	eax, 1
	jle	SHORT $exit$13
	mov	ecx, DWORD PTR _nsName$[ebp]
	mov	eax, OFFSET ??_C@_02IEBMKJDF@?$CD?$CD@
	test	ecx, ecx
	cmovne	eax, ecx
	push	eax
	push	DWORD PTR [esi+48]
	call	_xmlHashLookup
	add	esp, 8
	test	eax, eax
	je	SHORT $exit$13
	mov	eax, DWORD PTR [eax+52]
	push	ebx
	push	DWORD PTR [eax+32]
	call	_xmlHashLookup
	add	esp, 8
	mov	edi, eax
$exit$13:

; 4873 :     }
; 4874 : exit:
; 4875 : #ifdef DEBUG
; 4876 :     if (ret == NULL) {
; 4877 :         if (nsName == NULL)
; 4878 :             fprintf(stderr, "Unable to lookup attribute %s", name);
; 4879 :         else
; 4880 :             fprintf(stderr, "Unable to lookup attribute %s:%s", name,
; 4881 :                     nsName);
; 4882 :     }
; 4883 : #endif
; 4884 :     return (ret);

	mov	eax, edi
	pop	edi

; 4885 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemaG:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaGetAttributeDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetType
_TEXT	SEGMENT
_schema$ = 8						; size = 4
_name$ = 12						; size = 4
_nsName$ = 16						; size = 4
_xmlSchemaGetType PROC					; COMDAT

; 4819 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _nsName$[ebp]
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _name$[ebp]
	xor	esi, esi
	test	ebx, ebx
	jne	SHORT $LN2@xmlSchemaG

; 4851 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN2@xmlSchemaG:

; 4820 :     xmlSchemaTypePtr ret = NULL;
; 4821 : 
; 4822 :     if (name == NULL)
; 4823 :         return (NULL);
; 4824 :     /* First try the built-in types. */
; 4825 :     if ((nsName != NULL) && xmlStrEqual(nsName, xmlSchemaNs)) {

	test	edi, edi
	je	SHORT $LN4@xmlSchemaG
	push	DWORD PTR _xmlSchemaNs
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@xmlSchemaG

; 4826 : 	ret = xmlSchemaGetPredefinedType(name, nsName);

	push	edi
	push	ebx
	call	_xmlSchemaGetPredefinedType
	mov	esi, eax
	add	esp, 8

; 4827 : 	if (ret != NULL)

	test	esi, esi
	jne	SHORT $exit$14
$LN4@xmlSchemaG:

; 4828 : 	    goto exit;
; 4829 : 	/*
; 4830 : 	* Note that we try the parsed schemas as well here
; 4831 : 	* since one might have parsed the S4S, which contain more
; 4832 : 	* than the built-in types.
; 4833 : 	* TODO: Can we optimize this?
; 4834 : 	*/
; 4835 :     }
; 4836 :     if (schema != NULL) {

	mov	ebx, DWORD PTR _schema$[ebp]
	test	ebx, ebx
	je	SHORT $exit$14

; 4837 : 	WXS_FIND_GLOBAL_ITEM(typeDecl)

	push	DWORD PTR [ebx+4]
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@xmlSchemaG
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [ebx+28]
	call	_xmlHashLookup
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	SHORT $exit$14
$LN7@xmlSchemaG:
	push	DWORD PTR [ebx+48]
	call	_xmlHashSize
	add	esp, 4
	cmp	eax, 1
	jle	SHORT $exit$14
	test	edi, edi
	mov	eax, OFFSET ??_C@_02IEBMKJDF@?$CD?$CD@
	cmovne	eax, edi
	push	eax
	push	DWORD PTR [ebx+48]
	call	_xmlHashLookup
	add	esp, 8
	test	eax, eax
	je	SHORT $exit$14
	mov	eax, DWORD PTR [eax+52]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [eax+28]
	call	_xmlHashLookup
	add	esp, 8
	mov	esi, eax
$exit$14:

; 4838 :     }
; 4839 : exit:
; 4840 : 
; 4841 : #ifdef DEBUG
; 4842 :     if (ret == NULL) {
; 4843 :         if (nsName == NULL)
; 4844 :             fprintf(stderr, "Unable to lookup type %s", name);
; 4845 :         else
; 4846 :             fprintf(stderr, "Unable to lookup type %s:%s", name,
; 4847 :                     nsName);
; 4848 :     }
; 4849 : #endif
; 4850 :     return (ret);

	pop	edi
	mov	eax, esi

; 4851 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaGetType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetElem
_TEXT	SEGMENT
_schema$ = 8						; size = 4
_name$ = 12						; size = 4
_nsName$ = 16						; size = 4
_xmlSchemaGetElem PROC					; COMDAT

; 4785 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _name$[ebp]
	xor	edi, edi
	test	ebx, ebx
	je	SHORT $LN3@xmlSchemaG

; 4786 :     xmlSchemaElementPtr ret = NULL;
; 4787 : 
; 4788 :     if ((name == NULL) || (schema == NULL))

	mov	esi, DWORD PTR _schema$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaG

; 4789 :         return(NULL);
; 4790 :     if (schema != NULL) {
; 4791 : 	WXS_FIND_GLOBAL_ITEM(elemDecl)

	push	DWORD PTR [esi+4]
	push	DWORD PTR _nsName$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlSchemaG
	push	ebx
	push	DWORD PTR [esi+40]
	call	_xmlHashLookup
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	jne	SHORT $exit$13
$LN6@xmlSchemaG:
	push	DWORD PTR [esi+48]
	call	_xmlHashSize
	add	esp, 4
	cmp	eax, 1
	jle	SHORT $exit$13
	mov	ecx, DWORD PTR _nsName$[ebp]
	mov	eax, OFFSET ??_C@_02IEBMKJDF@?$CD?$CD@
	test	ecx, ecx
	cmovne	eax, ecx
	push	eax
	push	DWORD PTR [esi+48]
	call	_xmlHashLookup
	add	esp, 8
	test	eax, eax
	je	SHORT $exit$13
	mov	eax, DWORD PTR [eax+52]
	push	ebx
	push	DWORD PTR [eax+40]
	call	_xmlHashLookup
	add	esp, 8
	mov	edi, eax
$exit$13:

; 4792 :     }
; 4793 : exit:
; 4794 : #ifdef DEBUG
; 4795 :     if (ret == NULL) {
; 4796 :         if (nsName == NULL)
; 4797 :             fprintf(stderr, "Unable to lookup element decl. %s", name);
; 4798 :         else
; 4799 :             fprintf(stderr, "Unable to lookup element decl. %s:%s", name,
; 4800 :                     nsName);
; 4801 :     }
; 4802 : #endif
; 4803 :     return (ret);

	mov	eax, edi
	pop	edi

; 4804 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemaG:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaGetElem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetProp
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlSchemaGetProp PROC					; COMDAT

; 4737 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _node$[ebp]
	call	_xmlGetNoNsProp
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	jne	SHORT $LN2@xmlSchemaG
	pop	edi

; 4747 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaG:

; 4738 :     xmlChar *val;
; 4739 :     const xmlChar *ret;
; 4740 : 
; 4741 :     val = xmlGetNoNsProp(node, BAD_CAST name);
; 4742 :     if (val == NULL)
; 4743 :         return(NULL);
; 4744 :     ret = xmlDictLookup(ctxt->dict, val, -1);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	esi
	push	-1
	push	edi
	push	DWORD PTR [eax+80]
	call	_xmlDictLookup

; 4745 :     xmlFree(val);

	push	edi
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H

; 4746 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 4747 : }

	pop	ebp
	ret	0
_xmlSchemaGetProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetNodeContentNoDict
_TEXT	SEGMENT
_node$ = 8						; size = 4
_xmlSchemaGetNodeContentNoDict PROC			; COMDAT

; 4720 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4

; 4722 : }

	pop	ebp

; 4721 :     return((const xmlChar*) xmlNodeGetContent(node));

	jmp	_xmlNodeGetContent
_xmlSchemaGetNodeContentNoDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetNodeContent
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlSchemaGetNodeContent PROC				; COMDAT

; 4706 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _node$[ebp]
	call	_xmlNodeGetContent
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN2@xmlSchemaG

; 4707 :     xmlChar *val;
; 4708 :     const xmlChar *ret;
; 4709 : 
; 4710 :     val = xmlNodeGetContent(node);
; 4711 :     if (val == NULL)
; 4712 : 	val = xmlStrdup((xmlChar *)"");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	edi, eax
$LN2@xmlSchemaG:

; 4713 :     ret = xmlDictLookup(ctxt->dict, val, -1);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	-1
	push	edi
	push	DWORD PTR [eax+80]
	call	_xmlDictLookup

; 4714 :     xmlFree(val);

	push	edi
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H

; 4715 :     return(ret);

	mov	eax, esi
	pop	edi
	pop	esi

; 4716 : }

	pop	ebp
	ret	0
_xmlSchemaGetNodeContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetPropNodeNs
_TEXT	SEGMENT
_node$ = 8						; size = 4
_uri$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlSchemaGetPropNodeNs PROC				; COMDAT

; 4688 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	SHORT $LN13@xmlSchemaG

; 4689 :     xmlAttrPtr prop;
; 4690 : 
; 4691 :     if ((node == NULL) || (name == NULL))

	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	je	SHORT $LN13@xmlSchemaG

; 4692 : 	return(NULL);
; 4693 :     prop = node->properties;

	mov	esi, DWORD PTR [esi+44]

; 4694 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN13@xmlSchemaG
	mov	ebx, DWORD PTR _uri$[ebp]
$LL2@xmlSchemaG:

; 4695 : 	if ((prop->ns != NULL) &&
; 4696 : 	    xmlStrEqual(prop->name, BAD_CAST name) &&

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN6@xmlSchemaG
	push	edi
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlSchemaG
	mov	eax, DWORD PTR [esi+36]
	push	ebx
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaG
$LN6@xmlSchemaG:

; 4699 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaG
$LN13@xmlSchemaG:
	pop	edi

; 4700 :     }
; 4701 :     return (NULL);
; 4702 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlSchemaG:
	pop	edi

; 4697 : 	    xmlStrEqual(prop->ns->href, BAD_CAST uri))
; 4698 : 	    return(prop);

	mov	eax, esi

; 4700 :     }
; 4701 :     return (NULL);
; 4702 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaGetPropNodeNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetPropNode
_TEXT	SEGMENT
_node$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlSchemaGetPropNode PROC				; COMDAT

; 4661 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	SHORT $LN13@xmlSchemaG

; 4662 :     xmlAttrPtr prop;
; 4663 : 
; 4664 :     if ((node == NULL) || (name == NULL))

	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	je	SHORT $LN13@xmlSchemaG

; 4666 :     prop = node->properties;

	mov	esi, DWORD PTR [esi+44]

; 4667 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN13@xmlSchemaG
$LL2@xmlSchemaG:

; 4668 :         if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN6@xmlSchemaG
	push	edi
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaG
$LN6@xmlSchemaG:

; 4670 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaG
$LN13@xmlSchemaG:
	pop	edi

; 4665 : 	return(NULL);

	xor	eax, eax

; 4671 :     }
; 4672 :     return (NULL);
; 4673 : }

	pop	esi
	pop	ebp
	ret	0
$LN9@xmlSchemaG:
	pop	edi

; 4669 : 	    return(prop);

	mov	eax, esi

; 4671 :     }
; 4672 :     return (NULL);
; 4673 : }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaGetPropNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaTypeDumpEntry
_TEXT	SEGMENT
_type$ = 8						; size = 4
_output$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlSchemaTypeDumpEntry PROC				; COMDAT

; 4528 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _output$[ebp]
	push	DWORD PTR _type$[ebp]
	call	_xmlSchemaTypeDump
	add	esp, 8

; 4529 :     xmlSchemaTypeDump((xmlSchemaTypePtr) type, (FILE *) output);
; 4530 : }

	pop	ebp
	ret	0
_xmlSchemaTypeDumpEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAttrUsesDump
_TEXT	SEGMENT
_i$1$ = -4						; size = 4
_uses$ = 8						; size = 4
_output$ = 12						; size = 4
_xmlSchemaAttrUsesDump PROC				; COMDAT

; 4389 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _uses$[ebp]
	test	esi, esi
	je	$LN6@xmlSchemaA

; 4390 :     xmlSchemaAttributeUsePtr use;
; 4391 :     xmlSchemaAttributeUseProhibPtr prohib;
; 4392 :     xmlSchemaQNameRefPtr ref;
; 4393 :     const xmlChar *name, *tns;
; 4394 :     xmlChar *str = NULL;
; 4395 :     int i;
; 4396 : 
; 4397 :     if ((uses == NULL) || (uses->nbItems == 0))

	cmp	DWORD PTR [esi+4], 0
	je	$LN6@xmlSchemaA

; 4398 :         return;
; 4399 : 
; 4400 :     fprintf(output, "  attributes:\n");

	push	ebx
	mov	ebx, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_0P@JCEFCIDL@?5?5attributes?3?6@
	push	ebx
	call	_fprintf

; 4401 :     for (i = 0; i < uses->nbItems; i++) {

	xor	ecx, ecx
	add	esp, 8
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	DWORD PTR [esi+4], ecx
	jle	$LN24@xmlSchemaA
	push	edi
$LL4@xmlSchemaA:

; 4402 : 	use = uses->items[i];

	mov	eax, DWORD PTR [esi]
	mov	edi, DWORD PTR [eax+ecx*4]

; 4403 : 	if (use->type == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB) {

	mov	eax, DWORD PTR [edi]
	cmp	eax, 2001				; 000007d1H
	jne	SHORT $LN7@xmlSchemaA

; 4404 : 	    fprintf(output, "  [prohibition] ");

	push	OFFSET ??_C@_0BB@EJJDJFMI@?5?5?$FLprohibition?$FN?5@
	push	ebx
	call	_fprintf

; 4405 : 	    prohib = (xmlSchemaAttributeUseProhibPtr) use;
; 4406 : 	    name = prohib->name;

	mov	esi, DWORD PTR [edi+8]

; 4407 : 	    tns = prohib->targetNamespace;

	mov	ebx, DWORD PTR [edi+12]
	jmp	SHORT $LN26@xmlSchemaA
$LN7@xmlSchemaA:

; 4408 : 	} else if (use->type == XML_SCHEMA_EXTRA_QNAMEREF) {

	cmp	eax, 2000				; 000007d0H
	jne	SHORT $LN9@xmlSchemaA

; 4409 : 	    fprintf(output, "  [reference] ");

	push	OFFSET ??_C@_0P@IGLOKPCJ@?5?5?$FLreference?$FN?5@
	push	ebx
	call	_fprintf

; 4410 : 	    ref = (xmlSchemaQNameRefPtr) use;
; 4411 : 	    name = ref->name;

	mov	esi, DWORD PTR [edi+12]

; 4412 : 	    tns = ref->targetNamespace;

	mov	ebx, DWORD PTR [edi+16]

; 4413 : 	} else {

	jmp	SHORT $LN26@xmlSchemaA
$LN9@xmlSchemaA:

; 4414 : 	    fprintf(output, "  [use] ");

	push	OFFSET ??_C@_08FLCGCOPE@?5?5?$FLuse?$FN?5@
	push	ebx
	call	_fprintf

; 4415 : 	    name = WXS_ATTRUSE_DECL_NAME(use);

	mov	eax, DWORD PTR [edi+12]
	mov	esi, DWORD PTR [eax+8]

; 4416 : 	    tns = WXS_ATTRUSE_DECL_TNS(use);

	mov	ebx, DWORD PTR [eax+56]
$LN26@xmlSchemaA:

; 1304 :     FREE_AND_NULL(*buf)

	add	esp, 8

; 1305 :     if (namespaceName != NULL) {

	xor	edi, edi
	xor	eax, eax
	test	ebx, ebx
	je	SHORT $LN15@xmlSchemaA

; 1306 : 	*buf = xmlStrdup(BAD_CAST "{");

	push	OFFSET ??_C@_01HCONENDN@?$HL@
	call	_xmlStrdup

; 1307 : 	*buf = xmlStrcat(*buf, namespaceName);

	push	ebx
	push	eax
	call	_xmlStrcat

; 1308 : 	*buf = xmlStrcat(*buf, BAD_CAST "}");

	push	OFFSET ??_C@_01CELHOKLL@?$HN@
	push	eax
	call	_xmlStrcat
	add	esp, 20					; 00000014H
	mov	edi, eax
$LN15@xmlSchemaA:

; 1309 :     }
; 1310 :     if (localName != NULL) {

	test	esi, esi
	je	SHORT $LN16@xmlSchemaA

; 1311 : 	if (namespaceName == NULL)

	test	ebx, ebx
	je	SHORT $LN13@xmlSchemaA

; 1312 : 	    return(localName);
; 1313 : 	*buf = xmlStrcat(*buf, localName);
; 1314 :     } else {

	jmp	SHORT $LN17@xmlSchemaA
$LN16@xmlSchemaA:

; 1315 : 	*buf = xmlStrcat(*buf, BAD_CAST "(NULL)");

	mov	esi, OFFSET ??_C@_06LHGEHABH@?$CINULL?$CJ@
$LN17@xmlSchemaA:

; 1316 :     }
; 1317 :     return ((const xmlChar *) *buf);

	push	esi
	push	edi
	call	_xmlStrcat
	mov	edi, eax
	add	esp, 8
	mov	esi, edi
$LN13@xmlSchemaA:

; 4417 : 	}
; 4418 : 	fprintf(output, "'%s'\n",

	mov	ebx, DWORD PTR _output$[ebp]
	push	esi
	push	OFFSET ??_C@_05ODNCHMDL@?8?$CFs?8?6@
	push	ebx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 4419 : 	    (const char *) xmlSchemaFormatQName(&str, tns, name));
; 4420 : 	FREE_AND_NULL(str);

	test	edi, edi
	je	SHORT $LN2@xmlSchemaA
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlSchemaA:

; 4401 :     for (i = 0; i < uses->nbItems; i++) {

	mov	ecx, DWORD PTR _i$1$[ebp]
	mov	esi, DWORD PTR _uses$[ebp]
	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	ecx, DWORD PTR [esi+4]
	jl	$LL4@xmlSchemaA
	pop	edi
$LN24@xmlSchemaA:
	pop	ebx
$LN6@xmlSchemaA:
	pop	esi

; 4421 :     }
; 4422 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaAttrUsesDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaContentModelDump
_TEXT	SEGMENT
_shift$ = -104						; size = 100
_str$ = -4						; size = 4
_term$1$ = 8						; size = 4
_particle$ = 8						; size = 4
_output$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlSchemaContentModelDump PROC				; COMDAT

; 4316 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _particle$[ebp]
	mov	DWORD PTR _str$[ebp], 0
	test	ebx, ebx
	je	$LN24@xmlSchemaC

; 4317 :     xmlChar *str = NULL;
; 4318 :     xmlSchemaTreeItemPtr term;
; 4319 :     char shift[100];
; 4320 :     int i;
; 4321 : 
; 4322 :     if (particle == NULL)
; 4323 : 	return;
; 4324 :     for (i = 0;((i < depth) && (i < 25));i++)

	push	edi
	mov	edi, DWORD PTR _depth$[ebp]
	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN31@xmlSchemaC
	npad	3
$LL4@xmlSchemaC:
	cmp	eax, 25					; 00000019H
	jge	SHORT $LN31@xmlSchemaC

; 4325 :         shift[2 * i] = shift[2 * i + 1] = ' ';

	mov	WORD PTR _shift$[ebp+eax*2], 8224	; 00002020H
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL4@xmlSchemaC
$LN31@xmlSchemaC:
	push	esi

; 4326 :     shift[2 * i] = shift[2 * i + 1] = 0;
; 4327 :     fprintf(output, "%s", shift);

	mov	esi, DWORD PTR _output$[ebp]
	mov	WORD PTR _shift$[ebp+eax*2], 0
	lea	eax, DWORD PTR _shift$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	esi
	call	_fprintf

; 4328 :     if (particle->children == NULL) {

	mov	ecx, DWORD PTR [ebx+12]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _term$1$[ebp], ecx
	test	ecx, ecx
	jne	SHORT $LN8@xmlSchemaC

; 4329 : 	fprintf(output, "MISSING particle term\n");

	push	OFFSET ??_C@_0BH@DPNPBLLK@MISSING?5particle?5term?6@

; 4354 : 		break;
; 4355 : 	    default:
; 4356 : 		fprintf(output, "UNKNOWN\n");

	push	esi
	call	_fprintf
	add	esp, 8
	pop	esi
	pop	edi
	pop	ebx

; 4377 : 		output, depth);
; 4378 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlSchemaC:

; 4330 : 	return;
; 4331 :     }
; 4332 :     term = particle->children;
; 4333 :     if (term == NULL) {
; 4334 : 	fprintf(output, "(NULL)");
; 4335 :     } else {
; 4336 : 	switch (term->type) {

	mov	eax, DWORD PTR [ecx]
	add	eax, -2					; fffffffeH
	cmp	eax, 12					; 0000000cH
	ja	$LN17@xmlSchemaC
	movzx	eax, BYTE PTR $LN30@xmlSchemaC[eax]
	jmp	DWORD PTR $LN37@xmlSchemaC[eax*4]
$LN11@xmlSchemaC:

; 4337 : 	    case XML_SCHEMA_TYPE_ELEMENT:
; 4338 : 		fprintf(output, "ELEM '%s'", xmlSchemaFormatQName(&str,

	push	DWORD PTR [ecx+8]
	lea	eax, DWORD PTR _str$[ebp]
	push	DWORD PTR [ecx+52]
	push	eax
	call	_xmlSchemaFormatQName
	push	eax
	push	OFFSET ??_C@_09HHDCLOAM@ELEM?5?8?$CFs?8@
	push	esi
	call	_fprintf

; 4339 : 		    ((xmlSchemaElementPtr)term)->targetNamespace,
; 4340 : 		    ((xmlSchemaElementPtr)term)->name));
; 4341 : 		FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$[ebp]
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN5@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 4342 : 		break;

	jmp	SHORT $LN5@xmlSchemaC
$LN13@xmlSchemaC:

; 4343 : 	    case XML_SCHEMA_TYPE_SEQUENCE:
; 4344 : 		fprintf(output, "SEQUENCE");

	push	OFFSET ??_C@_08POLPFBMC@SEQUENCE@

; 4345 : 		break;

	jmp	SHORT $LN35@xmlSchemaC
$LN14@xmlSchemaC:

; 4346 : 	    case XML_SCHEMA_TYPE_CHOICE:
; 4347 : 		fprintf(output, "CHOICE");

	push	OFFSET ??_C@_06DHBGJHJC@CHOICE@

; 4348 : 		break;

	jmp	SHORT $LN35@xmlSchemaC
$LN15@xmlSchemaC:

; 4349 : 	    case XML_SCHEMA_TYPE_ALL:
; 4350 : 		fprintf(output, "ALL");

	push	OFFSET ??_C@_03NIFPGLBG@ALL@

; 4351 : 		break;

	jmp	SHORT $LN35@xmlSchemaC
$LN16@xmlSchemaC:

; 4352 : 	    case XML_SCHEMA_TYPE_ANY:
; 4353 : 		fprintf(output, "ANY");

	push	OFFSET ??_C@_03OMGOFJGM@ANY@
$LN35@xmlSchemaC:

; 4357 : 		return;
; 4358 : 	}
; 4359 :     }
; 4360 :     if (particle->minOccurs != 1)

	push	esi
	call	_fprintf
	add	esp, 8
$LN5@xmlSchemaC:
	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, 1
	je	SHORT $LN18@xmlSchemaC

; 4361 : 	fprintf(output, " min: %d", particle->minOccurs);

	push	eax
	push	OFFSET ??_C@_08IIINJODF@?5min?3?5?$CFd@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN18@xmlSchemaC:

; 4362 :     if (particle->maxOccurs >= UNBOUNDED)

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, 1073741824				; 40000000H
	jl	SHORT $LN19@xmlSchemaC

; 4363 : 	fprintf(output, " max: unbounded");

	push	OFFSET ??_C@_0BA@NODJHFHO@?5max?3?5unbounded@
	push	esi
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN21@xmlSchemaC
$LN19@xmlSchemaC:

; 4364 :     else if (particle->maxOccurs != 1)

	cmp	eax, 1
	je	SHORT $LN21@xmlSchemaC

; 4365 : 	fprintf(output, " max: %d", particle->maxOccurs);

	push	eax
	push	OFFSET ??_C@_08GOONDBNE@?5max?3?5?$CFd@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN21@xmlSchemaC:

; 4366 :     fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	esi
	call	_fprintf

; 4367 :     if (term &&
; 4368 : 	((term->type == XML_SCHEMA_TYPE_SEQUENCE) ||
; 4369 : 	 (term->type == XML_SCHEMA_TYPE_CHOICE) ||
; 4370 : 	 (term->type == XML_SCHEMA_TYPE_ALL)) &&

	mov	ecx, DWORD PTR _term$1$[ebp]
	add	esp, 8
	mov	eax, DWORD PTR [ecx]
	cmp	eax, 6
	je	SHORT $LN23@xmlSchemaC
	cmp	eax, 7
	je	SHORT $LN23@xmlSchemaC
	cmp	eax, 8
	jne	SHORT $LN22@xmlSchemaC
$LN23@xmlSchemaC:
	mov	ecx, DWORD PTR [ecx+12]
	test	ecx, ecx
	je	SHORT $LN22@xmlSchemaC

; 4371 : 	 (term->children != NULL)) {
; 4372 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) term->children,

	lea	eax, DWORD PTR [edi+1]
	push	eax
	push	esi
	push	ecx
	call	_xmlSchemaContentModelDump
	add	esp, 12					; 0000000cH
$LN22@xmlSchemaC:

; 4373 : 	    output, depth +1);
; 4374 :     }
; 4375 :     if (particle->next != NULL)

	mov	eax, DWORD PTR [ebx+8]
	test	eax, eax
	je	SHORT $LN33@xmlSchemaC

; 4376 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) particle->next,

	push	edi
	push	esi
	push	eax
	call	_xmlSchemaContentModelDump
	add	esp, 12					; 0000000cH
	pop	esi
	pop	edi
	pop	ebx

; 4377 : 		output, depth);
; 4378 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlSchemaC:

; 4354 : 		break;
; 4355 : 	    default:
; 4356 : 		fprintf(output, "UNKNOWN\n");

	push	OFFSET ??_C@_08GCOIMFOL@UNKNOWN?6@
	push	esi
	call	_fprintf
	add	esp, 8
$LN33@xmlSchemaC:
	pop	esi
	pop	edi
$LN24@xmlSchemaC:
	pop	ebx

; 4377 : 		output, depth);
; 4378 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN37@xmlSchemaC:
	DD	$LN16@xmlSchemaC
	DD	$LN13@xmlSchemaC
	DD	$LN14@xmlSchemaC
	DD	$LN15@xmlSchemaC
	DD	$LN11@xmlSchemaC
	DD	$LN17@xmlSchemaC
$LN30@xmlSchemaC:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
_xmlSchemaContentModelDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAnnotDump
_TEXT	SEGMENT
_output$ = 8						; size = 4
_annot$ = 12						; size = 4
_xmlSchemaAnnotDump PROC				; COMDAT

; 4292 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _annot$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaA

; 4293 :     xmlChar *content;
; 4294 : 
; 4295 :     if (annot == NULL)
; 4296 :         return;
; 4297 : 
; 4298 :     content = xmlNodeGetContent(annot->content);

	push	esi
	push	DWORD PTR [eax+4]
	call	_xmlNodeGetContent
	mov	esi, eax
	add	esp, 4

; 4299 :     if (content != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlSchemaA

; 4300 :         fprintf(output, "  Annot: %s\n", content);

	push	esi
	push	OFFSET ??_C@_0N@FJPFKNMF@?5?5Annot?3?5?$CFs?6@
	push	DWORD PTR _output$[ebp]
	call	_fprintf

; 4301 :         xmlFree(content);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H
	pop	esi
$LN4@xmlSchemaA:

; 4304 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaA:
	pop	esi

; 4302 :     } else
; 4303 :         fprintf(output, "  Annot: empty\n");

	mov	DWORD PTR _annot$[ebp], OFFSET ??_C@_0BA@MKDNPCKH@?5?5Annot?3?5empty?6@

; 4304 : }

	pop	ebp

; 4302 :     } else
; 4303 :         fprintf(output, "  Annot: empty\n");

	jmp	_fprintf
_xmlSchemaAnnotDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaElementDump
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_namespace$ = 20					; size = 4
_context$ = 24						; size = 4
_xmlSchemaElementDump PROC				; COMDAT

; 4208 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _payload$[ebp]
	test	edi, edi
	je	$LN19@xmlSchemaE

; 4209 :     xmlSchemaElementPtr elem = (xmlSchemaElementPtr) payload;
; 4210 :     FILE *output = (FILE *) data;
; 4211 :     if (elem == NULL)
; 4212 :         return;
; 4213 : 
; 4214 : 
; 4215 :     fprintf(output, "Element");

	push	esi
	mov	esi, DWORD PTR _data$[ebp]
	push	OFFSET ??_C@_07ILMPLKHC@Element@
	push	esi
	call	_fprintf
	add	esp, 8

; 4216 :     if (elem->flags & XML_SCHEMAS_ELEM_GLOBAL)

	test	BYTE PTR [edi+48], 2
	je	SHORT $LN3@xmlSchemaE

; 4217 : 	fprintf(output, " (global)");

	push	OFFSET ??_C@_09GAHIJPLK@?5?$CIglobal?$CJ@
	push	esi
	call	_fprintf
	add	esp, 8
$LN3@xmlSchemaE:

; 4218 :     fprintf(output, ": '%s' ", elem->name);

	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_07IDOJLIPA@?3?5?8?$CFs?8?5@
	push	esi
	call	_fprintf

; 4219 :     if (namespace != NULL)

	mov	eax, DWORD PTR _namespace$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@xmlSchemaE

; 4220 : 	fprintf(output, "ns '%s'", namespace);

	push	eax
	push	OFFSET ??_C@_07ONOPJFOL@ns?5?8?$CFs?8@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN4@xmlSchemaE:

; 4221 :     fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	esi
	call	_fprintf
	add	esp, 8
	test	BYTE PTR [edi+48], 29			; 0000001dH

; 4222 : #if 0
; 4223 :     if ((elem->minOccurs != 1) || (elem->maxOccurs != 1)) {
; 4224 : 	fprintf(output, "  min %d ", elem->minOccurs);
; 4225 :         if (elem->maxOccurs >= UNBOUNDED)
; 4226 :             fprintf(output, "max: unbounded\n");
; 4227 :         else if (elem->maxOccurs != 1)
; 4228 :             fprintf(output, "max: %d\n", elem->maxOccurs);
; 4229 :         else
; 4230 :             fprintf(output, "\n");
; 4231 :     }
; 4232 : #endif
; 4233 :     /*
; 4234 :     * Misc other properties.
; 4235 :     */
; 4236 :     if ((elem->flags & XML_SCHEMAS_ELEM_NILLABLE) ||
; 4237 : 	(elem->flags & XML_SCHEMAS_ELEM_ABSTRACT) ||
; 4238 : 	(elem->flags & XML_SCHEMAS_ELEM_FIXED) ||

	je	SHORT $LN5@xmlSchemaE

; 4239 : 	(elem->flags & XML_SCHEMAS_ELEM_DEFAULT)) {
; 4240 : 	fprintf(output, "  props: ");

	push	OFFSET ??_C@_09MDPMFALO@?5?5props?3?5@
	push	esi
	call	_fprintf

; 4241 : 	if (elem->flags & XML_SCHEMAS_ELEM_FIXED)

	mov	eax, DWORD PTR [edi+48]
	add	esp, 8
	test	al, 8
	je	SHORT $LN7@xmlSchemaE

; 4242 : 	    fprintf(output, "[fixed] ");

	push	OFFSET ??_C@_08BCFMBKHE@?$FLfixed?$FN?5@
	push	esi
	call	_fprintf
	mov	eax, DWORD PTR [edi+48]
	add	esp, 8
$LN7@xmlSchemaE:

; 4243 : 	if (elem->flags & XML_SCHEMAS_ELEM_DEFAULT)

	test	al, 4
	je	SHORT $LN8@xmlSchemaE

; 4244 : 	    fprintf(output, "[default] ");

	push	OFFSET ??_C@_0L@CIMKDCEL@?$FLdefault?$FN?5@
	push	esi
	call	_fprintf
	mov	eax, DWORD PTR [edi+48]
	add	esp, 8
$LN8@xmlSchemaE:

; 4245 : 	if (elem->flags & XML_SCHEMAS_ELEM_ABSTRACT)

	test	al, 16					; 00000010H
	je	SHORT $LN9@xmlSchemaE

; 4246 : 	    fprintf(output, "[abstract] ");

	push	OFFSET ??_C@_0M@BPMPIELH@?$FLabstract?$FN?5@
	push	esi
	call	_fprintf
	mov	eax, DWORD PTR [edi+48]
	add	esp, 8
$LN9@xmlSchemaE:

; 4247 : 	if (elem->flags & XML_SCHEMAS_ELEM_NILLABLE)

	test	al, 1
	je	SHORT $LN10@xmlSchemaE

; 4248 : 	    fprintf(output, "[nillable] ");

	push	OFFSET ??_C@_0M@BCKHHPGO@?$FLnillable?$FN?5@
	push	esi
	call	_fprintf
	add	esp, 8
$LN10@xmlSchemaE:

; 4249 : 	fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	esi
	call	_fprintf
	add	esp, 8
$LN5@xmlSchemaE:

; 4250 :     }
; 4251 :     /*
; 4252 :     * Default/fixed value.
; 4253 :     */
; 4254 :     if (elem->value != NULL)

	mov	eax, DWORD PTR [edi+76]
	test	eax, eax
	je	SHORT $LN11@xmlSchemaE

; 4255 : 	fprintf(output, "  value: '%s'\n", elem->value);

	push	eax
	push	OFFSET ??_C@_0P@OOGOODOG@?5?5value?3?5?8?$CFs?8?6@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN11@xmlSchemaE:

; 4256 :     /*
; 4257 :     * Type.
; 4258 :     */
; 4259 :     if (elem->namedType != NULL) {

	mov	eax, DWORD PTR [edi+56]
	test	eax, eax
	je	SHORT $LN12@xmlSchemaE

; 4260 : 	fprintf(output, "  type: '%s' ", elem->namedType);

	push	eax
	push	OFFSET ??_C@_0O@LPELKPN@?5?5type?3?5?8?$CFs?8?5@
	push	esi
	call	_fprintf

; 4261 : 	if (elem->namedTypeNs != NULL)

	mov	eax, DWORD PTR [edi+60]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN14@xmlSchemaE

; 4262 : 	    fprintf(output, "ns '%s'\n", elem->namedTypeNs);

	push	eax
	push	OFFSET ??_C@_08MNNKDMOP@ns?5?8?$CFs?8?6@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN16@xmlSchemaE
$LN14@xmlSchemaE:

; 4263 : 	else
; 4264 : 	    fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	esi
	call	_fprintf

; 4265 :     } else if (elem->subtypes != NULL) {

	jmp	SHORT $LN22@xmlSchemaE
$LN12@xmlSchemaE:
	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	je	SHORT $LN16@xmlSchemaE

; 4266 : 	/*
; 4267 : 	* Dump local types.
; 4268 : 	*/
; 4269 : 	xmlSchemaTypeDump(elem->subtypes, output);

	push	esi
	push	eax
	call	_xmlSchemaTypeDump
$LN22@xmlSchemaE:

; 4270 :     }
; 4271 :     /*
; 4272 :     * Substitution group.
; 4273 :     */
; 4274 :     if (elem->substGroup != NULL) {

	add	esp, 8
$LN16@xmlSchemaE:
	mov	eax, DWORD PTR [edi+64]
	test	eax, eax
	je	SHORT $LN21@xmlSchemaE

; 4275 : 	fprintf(output, "  substitutionGroup: '%s' ", elem->substGroup);

	push	eax
	push	OFFSET ??_C@_0BL@GHPOMFG@?5?5substitutionGroup?3?5?8?$CFs?8?5@
	push	esi
	call	_fprintf

; 4276 : 	if (elem->substGroupNs != NULL)

	mov	eax, DWORD PTR [edi+68]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN18@xmlSchemaE

; 4277 : 	    fprintf(output, "ns '%s'\n", elem->substGroupNs);

	push	eax
	push	OFFSET ??_C@_08MNNKDMOP@ns?5?8?$CFs?8?6@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
	pop	esi
	pop	edi

; 4280 :     }
; 4281 : }

	pop	ebp
	ret	0
$LN18@xmlSchemaE:

; 4278 : 	else
; 4279 : 	    fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	esi
	call	_fprintf
	add	esp, 8
$LN21@xmlSchemaE:
	pop	esi
$LN19@xmlSchemaE:
	pop	edi

; 4280 :     }
; 4281 : }

	pop	ebp
	ret	0
_xmlSchemaElementDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaTypeDump
_TEXT	SEGMENT
_uses$1$ = -8						; size = 4
_str$1 = -4						; size = 4
_type$ = 8						; size = 4
_output$ = 12						; size = 4
_xmlSchemaTypeDump PROC					; COMDAT

; 4433 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _type$[ebp]
	test	edi, edi
	jne	SHORT $LN6@xmlSchemaT

; 4434 :     if (type == NULL) {
; 4435 :         fprintf(output, "Type: NULL\n");

	push	OFFSET ??_C@_0M@JCDJFDMD@Type?3?5NULL?6@
	push	DWORD PTR _output$[ebp]
	call	_fprintf
	add	esp, 8
	pop	edi

; 4520 : 	    output, 1);
; 4521 :     }
; 4522 : #endif
; 4523 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlSchemaT:
	push	esi

; 4436 :         return;
; 4437 :     }
; 4438 :     fprintf(output, "Type: ");

	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_06NAHGBCDG@Type?3?5@
	push	esi
	call	_fprintf

; 4439 :     if (type->name != NULL)

	mov	eax, DWORD PTR [edi+8]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@xmlSchemaT

; 4440 :         fprintf(output, "'%s' ", type->name);

	push	eax
	push	OFFSET ??_C@_05IMLJLABD@?8?$CFs?8?5@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN8@xmlSchemaT
$LN7@xmlSchemaT:

; 4441 :     else
; 4442 :         fprintf(output, "(no name) ");

	push	OFFSET ??_C@_0L@MKMGDOCG@?$CIno?5name?$CJ?5@
	push	esi
	call	_fprintf
	add	esp, 8
$LN8@xmlSchemaT:

; 4443 :     if (type->targetNamespace != NULL)

	mov	eax, DWORD PTR [edi+112]
	test	eax, eax
	je	SHORT $LN9@xmlSchemaT

; 4444 : 	fprintf(output, "ns '%s' ", type->targetNamespace);

	push	eax
	push	OFFSET ??_C@_08KCLBPAMH@ns?5?8?$CFs?8?5@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN9@xmlSchemaT:

; 4445 :     switch (type->type) {

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax-1]
	cmp	ecx, 12					; 0000000cH
	ja	$LN19@xmlSchemaT
	jmp	DWORD PTR $LN56@xmlSchemaT[ecx*4]
$LN10@xmlSchemaT:

; 4446 :         case XML_SCHEMA_TYPE_BASIC:
; 4447 :             fprintf(output, "[basic] ");

	push	OFFSET ??_C@_08JHBJHPJC@?$FLbasic?$FN?5@
	push	esi
	call	_fprintf
	add	esp, 8

; 4448 :             break;

	jmp	$LN2@xmlSchemaT
$LN11@xmlSchemaT:

; 4449 :         case XML_SCHEMA_TYPE_SIMPLE:
; 4450 :             fprintf(output, "[simple] ");

	push	OFFSET ??_C@_09BLJCIKGO@?$FLsimple?$FN?5@
	push	esi
	call	_fprintf
	add	esp, 8

; 4451 :             break;

	jmp	SHORT $LN2@xmlSchemaT
$LN12@xmlSchemaT:

; 4452 :         case XML_SCHEMA_TYPE_COMPLEX:
; 4453 :             fprintf(output, "[complex] ");

	push	OFFSET ??_C@_0L@KAOEKGBK@?$FLcomplex?$FN?5@
	push	esi
	call	_fprintf
	add	esp, 8

; 4454 :             break;

	jmp	SHORT $LN2@xmlSchemaT
$LN13@xmlSchemaT:

; 4455 :         case XML_SCHEMA_TYPE_SEQUENCE:
; 4456 :             fprintf(output, "[sequence] ");

	push	OFFSET ??_C@_0M@FCFPOKLD@?$FLsequence?$FN?5@
	push	esi
	call	_fprintf
	add	esp, 8

; 4457 :             break;

	jmp	SHORT $LN2@xmlSchemaT
$LN14@xmlSchemaT:

; 4458 :         case XML_SCHEMA_TYPE_CHOICE:
; 4459 :             fprintf(output, "[choice] ");

	push	OFFSET ??_C@_09EKOOBNCK@?$FLchoice?$FN?5@
	push	esi
	call	_fprintf
	add	esp, 8

; 4460 :             break;

	jmp	SHORT $LN2@xmlSchemaT
$LN15@xmlSchemaT:

; 4461 :         case XML_SCHEMA_TYPE_ALL:
; 4462 :             fprintf(output, "[all] ");

	push	OFFSET ??_C@_06FMDLAKIF@?$FLall?$FN?5@
	push	esi
	call	_fprintf
	add	esp, 8

; 4463 :             break;

	jmp	SHORT $LN2@xmlSchemaT
$LN16@xmlSchemaT:

; 4464 :         case XML_SCHEMA_TYPE_UR:
; 4465 :             fprintf(output, "[ur] ");

	push	OFFSET ??_C@_05CJJADIIB@?$FLur?$FN?5@
	push	esi
	call	_fprintf
	add	esp, 8

; 4466 :             break;

	jmp	SHORT $LN2@xmlSchemaT
$LN17@xmlSchemaT:

; 4467 :         case XML_SCHEMA_TYPE_RESTRICTION:
; 4468 :             fprintf(output, "[restriction] ");

	push	OFFSET ??_C@_0P@CHAMEEEB@?$FLrestriction?$FN?5@
	push	esi
	call	_fprintf
	add	esp, 8

; 4469 :             break;

	jmp	SHORT $LN2@xmlSchemaT
$LN18@xmlSchemaT:

; 4470 :         case XML_SCHEMA_TYPE_EXTENSION:
; 4471 :             fprintf(output, "[extension] ");

	push	OFFSET ??_C@_0N@FOPKHEI@?$FLextension?$FN?5@
	push	esi
	call	_fprintf
	add	esp, 8

; 4472 :             break;

	jmp	SHORT $LN2@xmlSchemaT
$LN19@xmlSchemaT:

; 4473 :         default:
; 4474 :             fprintf(output, "[unknown type %d] ", type->type);

	push	eax
	push	OFFSET ??_C@_0BD@MFKKFECO@?$FLunknown?5type?5?$CFd?$FN?5@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN2@xmlSchemaT:

; 4475 :             break;
; 4476 :     }
; 4477 :     fprintf(output, "content: ");

	push	OFFSET ??_C@_09FOCHAENE@content?3?5@
	push	esi
	call	_fprintf

; 4478 :     switch (type->contentType) {

	mov	eax, DWORD PTR [edi+52]
	add	esp, 8
	cmp	eax, 7
	ja	SHORT $LN4@xmlSchemaT
	jmp	DWORD PTR $LN57@xmlSchemaT[eax*4]
$LN20@xmlSchemaT:

; 4479 :         case XML_SCHEMA_CONTENT_UNKNOWN:
; 4480 :             fprintf(output, "[unknown] ");

	push	OFFSET ??_C@_0L@IFGHBDON@?$FLunknown?$FN?5@

; 4481 :             break;

	jmp	SHORT $LN53@xmlSchemaT
$LN21@xmlSchemaT:

; 4482 :         case XML_SCHEMA_CONTENT_EMPTY:
; 4483 :             fprintf(output, "[empty] ");

	push	OFFSET ??_C@_08HLDMIKJJ@?$FLempty?$FN?5@

; 4484 :             break;

	jmp	SHORT $LN53@xmlSchemaT
$LN22@xmlSchemaT:

; 4485 :         case XML_SCHEMA_CONTENT_ELEMENTS:
; 4486 :             fprintf(output, "[element] ");

	push	OFFSET ??_C@_0L@FLJCNDEC@?$FLelement?$FN?5@

; 4487 :             break;

	jmp	SHORT $LN53@xmlSchemaT
$LN23@xmlSchemaT:

; 4488 :         case XML_SCHEMA_CONTENT_MIXED:
; 4489 :             fprintf(output, "[mixed] ");

	push	OFFSET ??_C@_08EPDGAGCC@?$FLmixed?$FN?5@

; 4490 :             break;

	jmp	SHORT $LN53@xmlSchemaT
$LN25@xmlSchemaT:

; 4491 :         case XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS:
; 4492 : 	/* not used. */
; 4493 :             break;
; 4494 :         case XML_SCHEMA_CONTENT_BASIC:
; 4495 :             fprintf(output, "[basic] ");

	push	OFFSET ??_C@_08JHBJHPJC@?$FLbasic?$FN?5@

; 4496 :             break;

	jmp	SHORT $LN53@xmlSchemaT
$LN26@xmlSchemaT:

; 4497 :         case XML_SCHEMA_CONTENT_SIMPLE:
; 4498 :             fprintf(output, "[simple] ");

	push	OFFSET ??_C@_09BLJCIKGO@?$FLsimple?$FN?5@

; 4499 :             break;

	jmp	SHORT $LN53@xmlSchemaT
$LN27@xmlSchemaT:

; 4500 :         case XML_SCHEMA_CONTENT_ANY:
; 4501 :             fprintf(output, "[any] ");

	push	OFFSET ??_C@_06EBDMPOEI@?$FLany?$FN?5@
$LN53@xmlSchemaT:

; 4502 :             break;
; 4503 :     }
; 4504 :     fprintf(output, "\n");

	push	esi
	call	_fprintf
	add	esp, 8
$LN4@xmlSchemaT:
	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	esi
	call	_fprintf

; 4505 :     if (type->base != NULL) {

	mov	eax, DWORD PTR [edi+56]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN30@xmlSchemaT

; 4506 :         fprintf(output, "  base type: '%s'", type->base);

	push	eax
	push	OFFSET ??_C@_0BC@HMAJHNML@?5?5base?5type?3?5?8?$CFs?8@
	push	esi
	call	_fprintf

; 4507 : 	if (type->baseNs != NULL)

	mov	eax, DWORD PTR [edi+60]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN29@xmlSchemaT

; 4508 : 	    fprintf(output, " ns '%s'\n", type->baseNs);

	push	eax
	push	OFFSET ??_C@_09IHAEEDOH@?5ns?5?8?$CFs?8?6@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN30@xmlSchemaT
$LN29@xmlSchemaT:

; 4509 : 	else
; 4510 : 	    fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	esi
	call	_fprintf
	add	esp, 8
$LN30@xmlSchemaT:

; 4511 :     }
; 4512 :     if (type->attrUses != NULL)

	mov	eax, DWORD PTR [edi+116]
	mov	DWORD PTR _uses$1$[ebp], eax
	test	eax, eax
	je	$LN40@xmlSchemaT

; 4397 :     if ((uses == NULL) || (uses->nbItems == 0))

	cmp	DWORD PTR [eax+4], 0
	mov	DWORD PTR _str$1[ebp], 0
	je	$LN40@xmlSchemaT

; 4398 :         return;
; 4399 : 
; 4400 :     fprintf(output, "  attributes:\n");

	push	ebx
	push	OFFSET ??_C@_0P@JCEFCIDL@?5?5attributes?3?6@
	push	esi
	call	_fprintf

; 4401 :     for (i = 0; i < uses->nbItems; i++) {

	mov	eax, DWORD PTR _uses$1$[ebp]
	xor	ebx, ebx
	add	esp, 8
	cmp	DWORD PTR [eax+4], ebx
	jle	$LN52@xmlSchemaT
	npad	3
$LL38@xmlSchemaT:

; 4402 : 	use = uses->items[i];

	mov	eax, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+ebx*4]

; 4403 : 	if (use->type == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB) {

	mov	eax, DWORD PTR [edi]
	cmp	eax, 2001				; 000007d1H
	jne	SHORT $LN41@xmlSchemaT

; 4404 : 	    fprintf(output, "  [prohibition] ");

	push	OFFSET ??_C@_0BB@EJJDJFMI@?5?5?$FLprohibition?$FN?5@
	push	esi
	call	_fprintf

; 4405 : 	    prohib = (xmlSchemaAttributeUseProhibPtr) use;
; 4406 : 	    name = prohib->name;

	mov	ecx, DWORD PTR [edi+8]

; 4407 : 	    tns = prohib->targetNamespace;

	mov	eax, DWORD PTR [edi+12]
	jmp	SHORT $LN54@xmlSchemaT
$LN41@xmlSchemaT:

; 4408 : 	} else if (use->type == XML_SCHEMA_EXTRA_QNAMEREF) {

	cmp	eax, 2000				; 000007d0H
	jne	SHORT $LN43@xmlSchemaT

; 4409 : 	    fprintf(output, "  [reference] ");

	push	OFFSET ??_C@_0P@IGLOKPCJ@?5?5?$FLreference?$FN?5@
	push	esi
	call	_fprintf

; 4410 : 	    ref = (xmlSchemaQNameRefPtr) use;
; 4411 : 	    name = ref->name;

	mov	ecx, DWORD PTR [edi+12]

; 4412 : 	    tns = ref->targetNamespace;

	mov	eax, DWORD PTR [edi+16]

; 4413 : 	} else {

	jmp	SHORT $LN54@xmlSchemaT
$LN43@xmlSchemaT:

; 4414 : 	    fprintf(output, "  [use] ");

	push	OFFSET ??_C@_08FLCGCOPE@?5?5?$FLuse?$FN?5@
	push	esi
	call	_fprintf

; 4415 : 	    name = WXS_ATTRUSE_DECL_NAME(use);

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [eax+8]

; 4416 : 	    tns = WXS_ATTRUSE_DECL_TNS(use);

	mov	eax, DWORD PTR [eax+56]
$LN54@xmlSchemaT:

; 4417 : 	}
; 4418 : 	fprintf(output, "'%s'\n",

	add	esp, 8
	push	ecx
	push	eax
	lea	eax, DWORD PTR _str$1[ebp]
	push	eax
	call	_xmlSchemaFormatQName
	push	eax
	push	OFFSET ??_C@_05ODNCHMDL@?8?$CFs?8?6@
	push	esi
	call	_fprintf

; 4419 : 	    (const char *) xmlSchemaFormatQName(&str, tns, name));
; 4420 : 	FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$1[ebp]
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN36@xmlSchemaT
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	DWORD PTR _str$1[ebp], 0
$LN36@xmlSchemaT:

; 4401 :     for (i = 0; i < uses->nbItems; i++) {

	mov	eax, DWORD PTR _uses$1$[ebp]
	inc	ebx
	cmp	ebx, DWORD PTR [eax+4]
	jl	$LL38@xmlSchemaT
	mov	edi, DWORD PTR _type$[ebp]
$LN52@xmlSchemaT:
	pop	ebx
$LN40@xmlSchemaT:

; 4513 : 	xmlSchemaAttrUsesDump(type->attrUses, output);
; 4514 :     if (type->annot != NULL)

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN32@xmlSchemaT

; 4515 :         xmlSchemaAnnotDump(output, type->annot);

	push	eax
	push	esi
	call	_xmlSchemaAnnotDump
	add	esp, 8
$LN32@xmlSchemaT:

; 4516 : #ifdef DUMP_CONTENT_MODEL
; 4517 :     if ((type->type == XML_SCHEMA_TYPE_COMPLEX) &&

	cmp	DWORD PTR [edi], 5
	jne	SHORT $LN51@xmlSchemaT
	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	je	SHORT $LN51@xmlSchemaT

; 4518 : 	(type->subtypes != NULL)) {
; 4519 : 	xmlSchemaContentModelDump((xmlSchemaParticlePtr) type->subtypes,

	push	1
	push	esi
	push	eax
	call	_xmlSchemaContentModelDump
	add	esp, 12					; 0000000cH
$LN51@xmlSchemaT:
	pop	esi
	pop	edi

; 4520 : 	    output, 1);
; 4521 :     }
; 4522 : #endif
; 4523 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN56@xmlSchemaT:
	DD	$LN10@xmlSchemaT
	DD	$LN19@xmlSchemaT
	DD	$LN19@xmlSchemaT
	DD	$LN11@xmlSchemaT
	DD	$LN12@xmlSchemaT
	DD	$LN13@xmlSchemaT
	DD	$LN14@xmlSchemaT
	DD	$LN15@xmlSchemaT
	DD	$LN19@xmlSchemaT
	DD	$LN19@xmlSchemaT
	DD	$LN16@xmlSchemaT
	DD	$LN17@xmlSchemaT
	DD	$LN18@xmlSchemaT
$LN57@xmlSchemaT:
	DD	$LN20@xmlSchemaT
	DD	$LN21@xmlSchemaT
	DD	$LN22@xmlSchemaT
	DD	$LN23@xmlSchemaT
	DD	$LN26@xmlSchemaT
	DD	$LN4@xmlSchemaT
	DD	$LN25@xmlSchemaT
	DD	$LN27@xmlSchemaT
_xmlSchemaTypeDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeModelGroup
_TEXT	SEGMENT
_item$ = 8						; size = 4
_xmlSchemaFreeModelGroup PROC				; COMDAT

; 4048 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN2@xmlSchemaF

; 4049 :     if (item->annot != NULL)
; 4050 : 	xmlSchemaFreeAnnot(item->annot);

	push	eax
	call	_xmlSchemaFreeAnnot
	add	esp, 4
$LN2@xmlSchemaF:

; 4051 :     xmlFree(item);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi

; 4052 : }

	pop	ebp
	ret	0
_xmlSchemaFreeModelGroup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeModelGroupDef
_TEXT	SEGMENT
_item$ = 8						; size = 4
_xmlSchemaFreeModelGroupDef PROC			; COMDAT

; 4034 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN2@xmlSchemaF

; 4035 :     if (item->annot != NULL)
; 4036 : 	xmlSchemaFreeAnnot(item->annot);

	push	eax
	call	_xmlSchemaFreeAnnot
	add	esp, 4
$LN2@xmlSchemaF:

; 4037 :     xmlFree(item);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi

; 4038 : }

	pop	ebp
	ret	0
_xmlSchemaFreeModelGroupDef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeElement
_TEXT	SEGMENT
_elem$ = 8						; size = 4
_xmlSchemaFreeElement PROC				; COMDAT

; 3952 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _elem$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlSchemaF

; 3953 :     if (elem == NULL)
; 3954 :         return;
; 3955 :     if (elem->annot != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaF

; 3956 :         xmlSchemaFreeAnnot(elem->annot);

	push	eax
	call	_xmlSchemaFreeAnnot
	add	esp, 4
$LN3@xmlSchemaF:

; 3957 :     if (elem->contModel != NULL)

	mov	eax, DWORD PTR [esi+84]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaF

; 3958 :         xmlRegFreeRegexp(elem->contModel);

	push	eax
	call	_xmlRegFreeRegexp
	add	esp, 4
$LN4@xmlSchemaF:

; 3959 :     if (elem->defVal != NULL)

	mov	eax, DWORD PTR [esi+96]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaF

; 3960 : 	xmlSchemaFreeValue(elem->defVal);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN5@xmlSchemaF:

; 3961 :     xmlFree(elem);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlSchemaF:
	pop	esi

; 3962 : }

	pop	ebp
	ret	0
_xmlSchemaFreeElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeIDC
_TEXT	SEGMENT
_idcDef$ = 8						; size = 4
_xmlSchemaFreeIDC PROC					; COMDAT

; 3917 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _idcDef$[ebp]
	test	ebx, ebx
	je	SHORT $LN1@xmlSchemaF

; 3918 :     xmlSchemaIDCSelectPtr cur, prev;
; 3919 : 
; 3920 :     if (idcDef == NULL)
; 3921 : 	return;
; 3922 :     if (idcDef->annot != NULL)

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN6@xmlSchemaF

; 3923 :         xmlSchemaFreeAnnot(idcDef->annot);

	push	eax
	call	_xmlSchemaFreeAnnot
	add	esp, 4
$LN6@xmlSchemaF:

; 3924 :     /* Selector */
; 3925 :     if (idcDef->selector != NULL) {

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN7@xmlSchemaF

; 3926 : 	if (idcDef->selector->xpathComp != NULL)

	mov	ecx, DWORD PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN8@xmlSchemaF

; 3927 : 	    xmlFreePattern((xmlPatternPtr) idcDef->selector->xpathComp);

	push	ecx
	call	_xmlFreePattern
	mov	eax, DWORD PTR [ebx+24]
	add	esp, 4
$LN8@xmlSchemaF:

; 3928 : 	xmlFree(idcDef->selector);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlSchemaF:

; 3929 :     }
; 3930 :     /* Fields */
; 3931 :     if (idcDef->fields != NULL) {

	push	esi
	mov	esi, DWORD PTR [ebx+28]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaF
	push	edi
$LL4@xmlSchemaF:

; 3932 : 	cur = idcDef->fields;
; 3933 : 	do {
; 3934 : 	    prev = cur;

	mov	edi, esi

; 3935 : 	    cur = cur->next;

	mov	esi, DWORD PTR [esi]

; 3936 : 	    if (prev->xpathComp != NULL)

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN10@xmlSchemaF

; 3937 : 		xmlFreePattern((xmlPatternPtr) prev->xpathComp);

	push	eax
	call	_xmlFreePattern
	add	esp, 4
$LN10@xmlSchemaF:

; 3938 : 	    xmlFree(prev);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3939 : 	} while (cur != NULL);

	test	esi, esi
	jne	SHORT $LL4@xmlSchemaF
	pop	edi
$LN3@xmlSchemaF:

; 3940 :     }
; 3941 :     xmlFree(idcDef);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi
$LN1@xmlSchemaF:
	pop	ebx

; 3942 : }

	pop	ebp
	ret	0
_xmlSchemaFreeIDC ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeIDCStateObjList
_TEXT	SEGMENT
_sto$ = 8						; size = 4
_xmlSchemaFreeIDCStateObjList PROC			; COMDAT

; 3896 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _sto$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaF
	push	edi
$LL2@xmlSchemaF:

; 3897 :     xmlSchemaIDCStateObjPtr next;
; 3898 :     while (sto != NULL) {
; 3899 : 	next = sto->next;
; 3900 : 	if (sto->history != NULL)

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaF

; 3901 : 	    xmlFree(sto->history);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlSchemaF:

; 3902 : 	if (sto->xpathCtxt != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaF

; 3903 : 	    xmlFreeStreamCtxt((xmlStreamCtxtPtr) sto->xpathCtxt);

	push	eax
	call	_xmlFreeStreamCtxt
	add	esp, 4
$LN5@xmlSchemaF:

; 3904 : 	xmlFree(sto);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3905 : 	sto = next;

	mov	esi, edi
	test	edi, edi
	jne	SHORT $LL2@xmlSchemaF
	pop	edi
$LN3@xmlSchemaF:
	pop	esi

; 3906 :     }
; 3907 : }

	pop	ebp
	ret	0
_xmlSchemaFreeIDCStateObjList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeTypeLinkList
_TEXT	SEGMENT
_link$ = 8						; size = 4
_xmlSchemaFreeTypeLinkList PROC				; COMDAT

; 3884 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _link$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaF
	push	esi
$LL2@xmlSchemaF:

; 3885 :     xmlSchemaTypeLinkPtr next;
; 3886 : 
; 3887 :     while (link != NULL) {
; 3888 : 	next = link->next;

	mov	esi, DWORD PTR [eax]

; 3889 : 	xmlFree(link);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3890 : 	link = next;

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaF
	pop	esi
$LN3@xmlSchemaF:

; 3891 :     }
; 3892 : }

	pop	ebp
	ret	0
_xmlSchemaFreeTypeLinkList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeQNameRef
_TEXT	SEGMENT
_item$ = 8						; size = 4
_xmlSchemaFreeQNameRef PROC				; COMDAT

; 3872 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4

; 3874 : }

	pop	ebp

; 3873 :     xmlFree(item);

	jmp	DWORD PTR _xmlFree
_xmlSchemaFreeQNameRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeAttributeGroup
_TEXT	SEGMENT
_attrGr$ = 8						; size = 4
_xmlSchemaFreeAttributeGroup PROC			; COMDAT

; 3854 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _attrGr$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlSchemaF

; 3855 :     if (attrGr == NULL)
; 3856 :         return;
; 3857 :     if (attrGr->annot != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaF

; 3858 :         xmlSchemaFreeAnnot(attrGr->annot);

	push	eax
	call	_xmlSchemaFreeAnnot
	add	esp, 4
$LN3@xmlSchemaF:

; 3859 :     if (attrGr->attrUses != NULL)

	push	edi
	mov	edi, DWORD PTR [esi+56]
	test	edi, edi
	je	SHORT $LN6@xmlSchemaF

; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN8@xmlSchemaF

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlSchemaF:

; 3534 :     xmlFree(list);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlSchemaF:

; 3860 : 	xmlSchemaItemListFree(WXS_LIST_CAST attrGr->attrUses);
; 3861 :     xmlFree(attrGr);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
$LN1@xmlSchemaF:
	pop	esi

; 3862 : }

	pop	ebp
	ret	0
_xmlSchemaFreeAttributeGroup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeWildcardNsSet
_TEXT	SEGMENT
_set$ = 8						; size = 4
_xmlSchemaFreeWildcardNsSet PROC			; COMDAT

; 3816 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _set$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaF
	push	esi
$LL2@xmlSchemaF:

; 3817 :     xmlSchemaWildcardNsPtr next;
; 3818 : 
; 3819 :     while (set != NULL) {
; 3820 : 	next = set->next;

	mov	esi, DWORD PTR [eax]

; 3821 : 	xmlFree(set);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3822 : 	set = next;

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaF
	pop	esi
$LN3@xmlSchemaF:

; 3823 :     }
; 3824 : }

	pop	ebp
	ret	0
_xmlSchemaFreeWildcardNsSet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeAttributeUseProhib
_TEXT	SEGMENT
_prohib$ = 8						; size = 4
_xmlSchemaFreeAttributeUseProhib PROC			; COMDAT

; 3802 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _prohib$[ebp]
	test	eax, eax
	je	SHORT $LN1@xmlSchemaF

; 3803 :     if (prohib == NULL)
; 3804 :         return;
; 3805 :     xmlFree(prohib);

	mov	DWORD PTR _prohib$[ebp], eax

; 3806 : }

	pop	ebp

; 3803 :     if (prohib == NULL)
; 3804 :         return;
; 3805 :     xmlFree(prohib);

	jmp	DWORD PTR _xmlFree
$LN1@xmlSchemaF:

; 3806 : }

	pop	ebp
	ret	0
_xmlSchemaFreeAttributeUseProhib ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeAttributeUse
_TEXT	SEGMENT
_use$ = 8						; size = 4
_xmlSchemaFreeAttributeUse PROC				; COMDAT

; 3784 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _use$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlSchemaF

; 3785 :     if (use == NULL)
; 3786 :         return;
; 3787 :     if (use->annot != NULL)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaF

; 3788 : 	xmlSchemaFreeAnnot(use->annot);

	push	eax
	call	_xmlSchemaFreeAnnot
	add	esp, 4
$LN3@xmlSchemaF:

; 3789 :     if (use->defVal != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaF

; 3790 : 	xmlSchemaFreeValue(use->defVal);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN4@xmlSchemaF:

; 3791 :     xmlFree(use);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlSchemaF:
	pop	esi

; 3792 : }

	pop	ebp
	ret	0
_xmlSchemaFreeAttributeUse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeAttribute
_TEXT	SEGMENT
_attr$ = 8						; size = 4
_xmlSchemaFreeAttribute PROC				; COMDAT

; 3766 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _attr$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlSchemaF

; 3767 :     if (attr == NULL)
; 3768 :         return;
; 3769 :     if (attr->annot != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaF

; 3770 : 	xmlSchemaFreeAnnot(attr->annot);

	push	eax
	call	_xmlSchemaFreeAnnot
	add	esp, 4
$LN3@xmlSchemaF:

; 3771 :     if (attr->defVal != NULL)

	mov	eax, DWORD PTR [esi+68]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaF

; 3772 : 	xmlSchemaFreeValue(attr->defVal);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN4@xmlSchemaF:

; 3773 :     xmlFree(attr);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlSchemaF:
	pop	esi

; 3774 : }

	pop	ebp
	ret	0
_xmlSchemaFreeAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeNotation
_TEXT	SEGMENT
_nota$ = 8						; size = 4
_xmlSchemaFreeNotation PROC				; COMDAT

; 3752 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _nota$[ebp]
	test	eax, eax
	je	SHORT $LN1@xmlSchemaF

; 3753 :     if (nota == NULL)
; 3754 :         return;
; 3755 :     xmlFree(nota);

	mov	DWORD PTR _nota$[ebp], eax

; 3756 : }

	pop	ebp

; 3753 :     if (nota == NULL)
; 3754 :         return;
; 3755 :     xmlFree(nota);

	jmp	DWORD PTR _xmlFree
$LN1@xmlSchemaF:

; 3756 : }

	pop	ebp
	ret	0
_xmlSchemaFreeNotation ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeAnnot
_TEXT	SEGMENT
_annot$ = 8						; size = 4
_xmlSchemaFreeAnnot PROC				; COMDAT

; 3728 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _annot$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaF

; 3729 :     if (annot == NULL)
; 3730 :         return;
; 3731 :     if (annot->next == NULL) {

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LL4@xmlSchemaF

; 3732 : 	xmlFree(annot);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi

; 3741 :     }
; 3742 : }

	pop	ebp
	ret	0
$LL4@xmlSchemaF:

; 3733 :     } else {
; 3734 : 	xmlSchemaAnnotPtr prev;
; 3735 : 
; 3736 : 	do {
; 3737 : 	    prev = annot;
; 3738 : 	    annot = annot->next;
; 3739 : 	    xmlFree(prev);

	push	esi
	mov	esi, DWORD PTR [esi]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3740 : 	} while (annot != NULL);

	test	esi, esi
	jne	SHORT $LL4@xmlSchemaF
$LN3@xmlSchemaF:
	pop	esi

; 3741 :     }
; 3742 : }

	pop	ebp
	ret	0
_xmlSchemaFreeAnnot ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaAddItemSize
_TEXT	SEGMENT
_list$ = 8						; size = 4
_initialSize$ = 12					; size = 4
_item$ = 16						; size = 4
_xmlSchemaAddItemSize PROC				; COMDAT

; 3710 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN11@xmlSchemaA

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 3342 :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlSchemaA

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@BAFOADOL@allocating?5an?5item?5list?5structu@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3711 :     if (*list == NULL) {
; 3712 : 	*list = xmlSchemaItemListCreate();

	mov	DWORD PTR [esi], 0

; 3713 : 	if (*list == NULL)
; 3714 : 	    return(-1);

	or	eax, -1
	pop	esi

; 3718 : }

	pop	ebp
	ret	0
$LN6@xmlSchemaA:
	xorps	xmm0, xmm0

; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));

	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], 0

; 3711 :     if (*list == NULL) {
; 3712 : 	*list = xmlSchemaItemListCreate();

	mov	DWORD PTR [esi], eax
$LN11@xmlSchemaA:

; 3715 :     }
; 3716 :     xmlSchemaItemListAddSize(*list, initialSize, item);

	push	DWORD PTR _item$[ebp]
	push	DWORD PTR _initialSize$[ebp]
	push	eax
	call	_xmlSchemaItemListAddSize
	add	esp, 12					; 0000000cH

; 3717 :     return(0);

	xor	eax, eax
	pop	esi

; 3718 : }

	pop	ebp
	ret	0
_xmlSchemaAddItemSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaBucketCreate
_TEXT	SEGMENT
_mainSchema$1$ = 8					; size = 4
_pctxt$ = 8						; size = 4
_type$ = 12						; size = 4
_targetNamespace$ = 16					; size = 4
_xmlSchemaBucketCreate PROC				; COMDAT

; 3577 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pctxt$[ebp]
	mov	eax, DWORD PTR [edi+28]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _mainSchema$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaB

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	eax
	push	eax
	push	OFFSET ??_C@_0BO@PGEEMOLL@no?5main?5schema?5on?5constructor@
	push	OFFSET ??_C@_0BG@KOPDJPPO@xmlSchemaBucketCreate@
	push	edi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 3578 :     xmlSchemaBucketPtr ret;
; 3579 :     int size;
; 3580 :     xmlSchemaPtr mainSchema;
; 3581 : 
; 3582 :     if (WXS_CONSTRUCTOR(pctxt)->mainSchema == NULL) {
; 3583 : 	PERROR_INT("xmlSchemaBucketCreate",
; 3584 : 	    "no main schema on constructor");
; 3585 : 	return(NULL);

	xor	eax, eax
	pop	edi

; 3704 : 	return(NULL);
; 3705 :     return(ret);
; 3706 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaB:
	push	esi

; 3586 :     }
; 3587 :     mainSchema = WXS_CONSTRUCTOR(pctxt)->mainSchema;
; 3588 :     /* Create the schema bucket. */
; 3589 :     if (WXS_IS_BUCKET_INCREDEF(type))
; 3590 : 	size = sizeof(xmlSchemaInclude);
; 3591 :     else
; 3592 : 	size = sizeof(xmlSchemaImport);
; 3593 :     ret = (xmlSchemaBucketPtr) xmlMalloc(size);

	push	56					; 00000038H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 3594 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN6@xmlSchemaB

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BJ@CMBPIEML@allocating?5schema?5bucket@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3595 : 	xmlSchemaPErrMemory(NULL, "allocating schema bucket", NULL);
; 3596 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 3704 : 	return(NULL);
; 3705 :     return(ret);
; 3706 : }

	pop	ebp
	ret	0
$LN6@xmlSchemaB:
	push	ebx

; 3597 :     }
; 3598 :     memset(ret, 0, size);

	push	56					; 00000038H
	push	0
	push	esi
	call	_memset

; 3599 :     ret->targetNamespace = targetNamespace;

	mov	eax, DWORD PTR _targetNamespace$[ebp]
	add	esp, 12					; 0000000cH

; 3600 :     ret->type = type;

	mov	ebx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi], ebx

; 3601 :     ret->globals = xmlSchemaItemListCreate();

	call	_xmlSchemaItemListCreate
	mov	DWORD PTR [esi+44], eax

; 3602 :     if (ret->globals == NULL) {

	test	eax, eax
	je	$LN40@xmlSchemaB

; 3603 : 	xmlFree(ret);
; 3604 : 	return(NULL);
; 3605 :     }
; 3606 :     ret->locals = xmlSchemaItemListCreate();

	call	_xmlSchemaItemListCreate
	mov	DWORD PTR [esi+48], eax

; 3607 :     if (ret->locals == NULL) {

	test	eax, eax
	je	$LN40@xmlSchemaB

; 3610 :     }
; 3611 :     /*
; 3612 :     * The following will assure that only the first bucket is marked as
; 3613 :     * XML_SCHEMA_SCHEMA_MAIN and it points to the *main* schema.
; 3614 :     * For each following import buckets an xmlSchema will be created.
; 3615 :     * An xmlSchema will be created for every distinct targetNamespace.
; 3616 :     * We assign the targetNamespace to the schemata here.
; 3617 :     */
; 3618 :     if (! WXS_HAS_BUCKETS(pctxt)) {

	mov	eax, DWORD PTR [edi+28]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	$LN11@xmlSchemaB
	cmp	DWORD PTR [eax+4], 0
	jle	SHORT $LN11@xmlSchemaB

; 3634 :     } else {
; 3635 : 	if (type == XML_SCHEMA_SCHEMA_MAIN) {

	test	ebx, ebx
	jne	SHORT $LN14@xmlSchemaB

; 3636 : 	    PERROR_INT("xmlSchemaBucketCreate",

	push	OFFSET ??_C@_0CH@KFOKDOIL@main?5bucket?5but?5it?8s?5not?5the?5fi@
	push	OFFSET ??_C@_0BG@KOPDJPPO@xmlSchemaBucketCreate@
	push	edi
	call	_xmlSchemaInternalErr

; 3637 : 		"main bucket but it's not the first one");
; 3638 : 	    xmlSchemaBucketFree(ret);

	push	esi
	call	_xmlSchemaBucketFree
	add	esp, 16					; 00000010H
	xor	eax, eax
	pop	ebx
	pop	esi
	pop	edi

; 3704 : 	return(NULL);
; 3705 :     return(ret);
; 3706 : }

	pop	ebp
	ret	0
$LN14@xmlSchemaB:

; 3639 : 	    return(NULL);
; 3640 : 	} else if (type == XML_SCHEMA_SCHEMA_IMPORT) {

	cmp	ebx, 1
	jne	SHORT $LN41@xmlSchemaB

; 3641 : 	    /*
; 3642 : 	    * Create a schema for imports and assign the
; 3643 : 	    * targetNamespace.
; 3644 : 	    */
; 3645 : 	    WXS_IMPBUCKET(ret)->schema = xmlSchemaNewSchema(pctxt);

	push	edi
	call	_xmlSchemaNewSchema
	add	esp, 4
	mov	DWORD PTR [esi+52], eax

; 3646 : 	    if (WXS_IMPBUCKET(ret)->schema == NULL) {

	test	eax, eax
	je	SHORT $LN39@xmlSchemaB

; 3647 : 		xmlSchemaBucketFree(ret);
; 3648 : 		return(NULL);
; 3649 : 	    }
; 3650 : 	    WXS_IMPBUCKET(ret)->schema->targetNamespace = targetNamespace;

	mov	ecx, DWORD PTR _targetNamespace$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN20@xmlSchemaB:

; 3654 : 	int res;
; 3655 : 	/*
; 3656 : 	* Imports go into the "schemasImports" slot of the main *schema*.
; 3657 : 	* Note that we create an import entry for the main schema as well; i.e.,
; 3658 : 	* even if there's only one schema, we'll get an import.
; 3659 : 	*/
; 3660 : 	if (mainSchema->schemasImports == NULL) {

	mov	ebx, DWORD PTR _mainSchema$1$[ebp]
	mov	ecx, DWORD PTR [ebx+48]
	test	ecx, ecx
	jne	$LN22@xmlSchemaB

; 3661 : 	    mainSchema->schemasImports = xmlHashCreateDict(5,

	mov	eax, DWORD PTR [edi+28]
	push	DWORD PTR [eax+8]
	push	5
	call	_xmlHashCreateDict
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR [ebx+48], ecx

; 3662 : 		WXS_CONSTRUCTOR(pctxt)->dict);
; 3663 : 	    if (mainSchema->schemasImports == NULL) {

	test	ecx, ecx
	jne	$LN22@xmlSchemaB
$LN39@xmlSchemaB:

; 3664 : 		xmlSchemaBucketFree(ret);

	push	esi
	call	_xmlSchemaBucketFree
	add	esp, 4
	xor	eax, eax
	pop	ebx
	pop	esi
	pop	edi

; 3704 : 	return(NULL);
; 3705 :     return(ret);
; 3706 : }

	pop	ebp
	ret	0
$LN11@xmlSchemaB:

; 3619 : 	if (WXS_IS_BUCKET_INCREDEF(type)) {

	cmp	ebx, 2
	je	$LN13@xmlSchemaB
	cmp	ebx, 3
	je	$LN13@xmlSchemaB

; 3623 : 	    return(NULL);
; 3624 : 	}
; 3625 : 	/* Force the type to be XML_SCHEMA_SCHEMA_MAIN. */
; 3626 : 	ret->type = XML_SCHEMA_SCHEMA_MAIN;
; 3627 : 	/* Point to the *main* schema. */
; 3628 : 	WXS_CONSTRUCTOR(pctxt)->mainBucket = ret;
; 3629 : 	WXS_IMPBUCKET(ret)->schema = mainSchema;

	mov	ecx, DWORD PTR _mainSchema$1$[ebp]
	mov	DWORD PTR [esi], 0
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [eax+4], esi

; 3630 : 	/*
; 3631 : 	* Ensure that the main schema gets a targetNamespace.
; 3632 : 	*/
; 3633 : 	mainSchema->targetNamespace = targetNamespace;

	mov	eax, DWORD PTR _targetNamespace$[ebp]
	mov	DWORD PTR [esi+52], ecx
	mov	DWORD PTR [ecx+4], eax

; 3639 : 	    return(NULL);
; 3640 : 	} else if (type == XML_SCHEMA_SCHEMA_IMPORT) {

	jmp	SHORT $LN16@xmlSchemaB
$LN41@xmlSchemaB:
	mov	ecx, DWORD PTR _mainSchema$1$[ebp]
$LN16@xmlSchemaB:

; 3651 : 	}
; 3652 :     }
; 3653 :     if (WXS_IS_BUCKET_IMPMAIN(type)) {

	test	ebx, ebx
	je	SHORT $LN20@xmlSchemaB
	cmp	ebx, 1
	je	SHORT $LN20@xmlSchemaB

; 3678 : 	    return(NULL);
; 3679 : 	}
; 3680 :     } else {
; 3681 : 	/* Set the @ownerImport of an include bucket. */
; 3682 : 	if (WXS_IS_BUCKET_IMPMAIN(WXS_CONSTRUCTOR(pctxt)->bucket->type))

	mov	eax, DWORD PTR [edi+28]
	mov	eax, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN28@xmlSchemaB
	cmp	edx, 1
	je	SHORT $LN28@xmlSchemaB

; 3683 : 	    WXS_INCBUCKET(ret)->ownerImport =
; 3684 : 		WXS_IMPBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket);
; 3685 : 	else
; 3686 : 	    WXS_INCBUCKET(ret)->ownerImport =

	mov	eax, DWORD PTR [eax+52]
$LN28@xmlSchemaB:

; 3687 : 		WXS_INCBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket)->ownerImport;
; 3688 : 
; 3689 : 	/* Includes got into the "includes" slot of the *main* schema. */
; 3690 : 	if (mainSchema->includes == NULL) {

	mov	DWORD PTR [esi+52], eax
	mov	eax, DWORD PTR [ecx+64]
	test	eax, eax
	jne	SHORT $LN30@xmlSchemaB

; 3691 : 	    mainSchema->includes = xmlSchemaItemListCreate();

	call	_xmlSchemaItemListCreate
	mov	ebx, DWORD PTR _mainSchema$1$[ebp]
	mov	DWORD PTR [ebx+64], eax

; 3692 : 	    if (mainSchema->includes == NULL) {

	test	eax, eax
	je	SHORT $LN39@xmlSchemaB
$LN30@xmlSchemaB:

; 3693 : 		xmlSchemaBucketFree(ret);
; 3694 : 		return(NULL);
; 3695 : 	    }
; 3696 : 	}
; 3697 : 	xmlSchemaItemListAdd(mainSchema->includes, ret);

	push	esi
	push	eax
	call	_xmlSchemaItemListAdd
	add	esp, 8
$LN25@xmlSchemaB:

; 3698 :     }
; 3699 :     /*
; 3700 :     * Add to list of all buckets; this is used for lookup
; 3701 :     * during schema construction time only.
; 3702 :     */
; 3703 :     if (xmlSchemaItemListAdd(WXS_CONSTRUCTOR(pctxt)->buckets, ret) == -1)

	mov	eax, DWORD PTR [edi+28]
	push	esi
	push	DWORD PTR [eax+12]
	call	_xmlSchemaItemListAdd
	add	esp, 8
	xor	ecx, ecx
	cmp	eax, -1
	cmove	esi, ecx
	pop	ebx
	mov	eax, esi
	pop	esi
	pop	edi

; 3704 : 	return(NULL);
; 3705 :     return(ret);
; 3706 : }

	pop	ebp
	ret	0
$LN22@xmlSchemaB:

; 3665 : 		return(NULL);
; 3666 : 	    }
; 3667 : 	}
; 3668 : 	if (targetNamespace == NULL)
; 3669 : 	    res = xmlHashAddEntry(mainSchema->schemasImports,
; 3670 : 		XML_SCHEMAS_NO_NAMESPACE, ret);
; 3671 : 	else
; 3672 : 	    res = xmlHashAddEntry(mainSchema->schemasImports,
; 3673 : 		targetNamespace, ret);
; 3674 : 	if (res != 0) {

	mov	edx, DWORD PTR _targetNamespace$[ebp]
	mov	eax, OFFSET ??_C@_02IEBMKJDF@?$CD?$CD@
	test	edx, edx
	push	esi
	cmovne	eax, edx
	push	eax
	push	ecx
	call	_xmlHashAddEntry
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN25@xmlSchemaB

; 3675 : 	    PERROR_INT("xmlSchemaBucketCreate",

	push	OFFSET ??_C@_0CM@PPHBJHEG@failed?5to?5add?5the?5schema?5bucket@
	push	OFFSET ??_C@_0BG@KOPDJPPO@xmlSchemaBucketCreate@
	push	edi
	call	_xmlSchemaInternalErr

; 3676 : 		"failed to add the schema bucket to the hash");
; 3677 : 	    xmlSchemaBucketFree(ret);

	push	esi
	call	_xmlSchemaBucketFree
	add	esp, 16					; 00000010H
	xor	eax, eax
	pop	ebx
	pop	esi
	pop	edi

; 3704 : 	return(NULL);
; 3705 :     return(ret);
; 3706 : }

	pop	ebp
	ret	0
$LN13@xmlSchemaB:

; 3620 : 	    PERROR_INT("xmlSchemaBucketCreate",

	push	OFFSET ??_C@_0CN@IEDLEJJH@first?5bucket?5but?5it?8s?5an?5includ@
	push	OFFSET ??_C@_0BG@KOPDJPPO@xmlSchemaBucketCreate@
	push	edi
	call	_xmlSchemaInternalErr

; 3621 : 		"first bucket but it's an include or redefine");
; 3622 : 	    xmlSchemaBucketFree(ret);

	push	esi
	call	_xmlSchemaBucketFree
	add	esp, 16					; 00000010H
	xor	eax, eax
	pop	ebx
	pop	esi
	pop	edi

; 3704 : 	return(NULL);
; 3705 :     return(ret);
; 3706 : }

	pop	ebp
	ret	0
$LN40@xmlSchemaB:

; 3608 : 	xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3609 : 	return(NULL);

	xor	eax, eax
	pop	ebx
	pop	esi
	pop	edi

; 3704 : 	return(NULL);
; 3705 :     return(ret);
; 3706 : }

	pop	ebp
	ret	0
_xmlSchemaBucketCreate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaBucketFreeEntry
_TEXT	SEGMENT
_bucket$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlSchemaBucketFreeEntry PROC				; COMDAT

; 3570 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _bucket$[ebp]
	call	_xmlSchemaBucketFree
	add	esp, 4

; 3571 :     xmlSchemaBucketFree((xmlSchemaBucketPtr) bucket);
; 3572 : }

	pop	ebp
	ret	0
_xmlSchemaBucketFreeEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaBucketFree
_TEXT	SEGMENT
_bucket$ = 8						; size = 4
_xmlSchemaBucketFree PROC				; COMDAT

; 3539 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _bucket$[ebp]
	test	edi, edi
	je	$LN1@xmlSchemaB

; 3540 :     if (bucket == NULL)
; 3541 : 	return;
; 3542 :     if (bucket->globals != NULL) {

	mov	eax, DWORD PTR [edi+44]
	push	esi
	test	eax, eax
	je	SHORT $LN13@xmlSchemaB

; 3543 : 	xmlSchemaComponentListFree(bucket->globals);

	push	eax
	call	_xmlSchemaComponentListFree

; 3544 : 	xmlSchemaItemListFree(bucket->globals);

	mov	esi, DWORD PTR [edi+44]
	add	esp, 4

; 3530 :     if (list == NULL)

	test	esi, esi
	je	SHORT $LN13@xmlSchemaB

; 3531 : 	return;
; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN15@xmlSchemaB

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlSchemaB:

; 3534 :     xmlFree(list);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlSchemaB:

; 3545 :     }
; 3546 :     if (bucket->locals != NULL) {

	mov	eax, DWORD PTR [edi+48]
	test	eax, eax
	je	SHORT $LN17@xmlSchemaB

; 3547 : 	xmlSchemaComponentListFree(bucket->locals);

	push	eax
	call	_xmlSchemaComponentListFree

; 3548 : 	xmlSchemaItemListFree(bucket->locals);

	mov	esi, DWORD PTR [edi+48]
	add	esp, 4

; 3530 :     if (list == NULL)

	test	esi, esi
	je	SHORT $LN17@xmlSchemaB

; 3531 : 	return;
; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN19@xmlSchemaB

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN19@xmlSchemaB:

; 3534 :     xmlFree(list);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlSchemaB:

; 3549 :     }
; 3550 :     if (bucket->relations != NULL) {

	mov	esi, DWORD PTR [edi+24]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaB
$LL4@xmlSchemaB:

; 3551 : 	xmlSchemaSchemaRelationPtr prev, cur = bucket->relations;
; 3552 : 	do {
; 3553 : 	    prev = cur;
; 3554 : 	    cur = cur->next;
; 3555 : 	    xmlFree(prev);

	push	esi
	mov	esi, DWORD PTR [esi]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3556 : 	} while (cur != NULL);

	test	esi, esi
	jne	SHORT $LL4@xmlSchemaB
$LN3@xmlSchemaB:

; 3557 :     }
; 3558 :     if ((! bucket->preserveDoc) && (bucket->doc != NULL)) {

	cmp	DWORD PTR [edi+40], 0
	pop	esi
	jne	SHORT $LN9@xmlSchemaB
	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN9@xmlSchemaB

; 3559 : 	xmlFreeDoc(bucket->doc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN9@xmlSchemaB:

; 3560 :     }
; 3561 :     if (bucket->type == XML_SCHEMA_SCHEMA_IMPORT) {

	cmp	DWORD PTR [edi], 1
	jne	SHORT $LN11@xmlSchemaB

; 3562 : 	if (WXS_IMPBUCKET(bucket)->schema != NULL)

	mov	eax, DWORD PTR [edi+52]
	test	eax, eax
	je	SHORT $LN11@xmlSchemaB

; 3563 : 	    xmlSchemaFree(WXS_IMPBUCKET(bucket)->schema);

	push	eax
	call	_xmlSchemaFree
	add	esp, 4
$LN11@xmlSchemaB:

; 3564 :     }
; 3565 :     xmlFree(bucket);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlSchemaB:
	pop	edi

; 3566 : }

	pop	ebp
	ret	0
_xmlSchemaBucketFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaItemListFree
_TEXT	SEGMENT
_list$ = 8						; size = 4
_xmlSchemaItemListFree PROC				; COMDAT

; 3529 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _list$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlSchemaI

; 3530 :     if (list == NULL)
; 3531 : 	return;
; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaI

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlSchemaI:

; 3534 :     xmlFree(list);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlSchemaI:
	pop	esi

; 3535 : }

	pop	ebp
	ret	0
_xmlSchemaItemListFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaItemListRemove
_TEXT	SEGMENT
_list$ = 8						; size = 4
_idx$ = 12						; size = 4
_xmlSchemaItemListRemove PROC				; COMDAT

; 3497 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xmlSchemaI

; 3498 :     int i;
; 3499 :     if ((list->items == NULL) || (idx >= list->nbItems)) {

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _idx$[ebp]
	cmp	edx, ecx
	jge	SHORT $LN6@xmlSchemaI

; 3503 :     }
; 3504 : 
; 3505 :     if (list->nbItems == 1) {

	cmp	ecx, 1
	jne	SHORT $LN7@xmlSchemaI

; 3506 : 	/* TODO: Really free the list? */
; 3507 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3508 : 	list->items = NULL;

	mov	DWORD PTR [esi], 0

; 3509 : 	list->nbItems = 0;
; 3510 : 	list->sizeItems = 0;

	mov	DWORD PTR [esi+8], 0
	xor	eax, eax

; 3517 :     }
; 3518 :     return(0);

	mov	DWORD PTR [esi+4], eax
	pop	esi

; 3519 : }

	pop	ebp
	ret	0
$LN7@xmlSchemaI:

; 3511 :     } else if (list->nbItems -1 == idx) {

	lea	eax, DWORD PTR [ecx-1]
	cmp	eax, edx
	je	SHORT $LN10@xmlSchemaI

; 3512 : 	list->nbItems--;
; 3513 :     } else {
; 3514 : 	for (i = idx; i < list->nbItems -1; i++)

	jle	SHORT $LN3@xmlSchemaI
	npad	2
$LL4@xmlSchemaI:

; 3515 : 	    list->items[i] = list->items[i+1];

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+edx*4]
	inc	edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [ecx-1]
	cmp	edx, eax
	jl	SHORT $LL4@xmlSchemaI
$LN3@xmlSchemaI:

; 3516 : 	list->nbItems--;

	lea	eax, DWORD PTR [ecx-1]
$LN10@xmlSchemaI:

; 3517 :     }
; 3518 :     return(0);

	mov	DWORD PTR [esi+4], eax
	xor	eax, eax
	pop	esi

; 3519 : }

	pop	ebp
	ret	0
$LN6@xmlSchemaI:

; 1869 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, NULL, NULL,

	push	OFFSET ??_C@_0DH@PONCBEFB@Internal?5error?3?5xmlSchemaItemLi@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3500 : 	xmlSchemaPSimpleErr("Internal error: xmlSchemaItemListRemove, "
; 3501 : 	    "index error.\n");
; 3502 : 	return(-1);

	or	eax, -1
	pop	esi

; 3519 : }

	pop	ebp
	ret	0
_xmlSchemaItemListRemove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaItemListInsert
_TEXT	SEGMENT
_list$ = 8						; size = 4
_item$ = 12						; size = 4
_idx$ = 16						; size = 4
_xmlSchemaItemListInsert PROC				; COMDAT

; 3418 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	jne	SHORT $LN5@xmlSchemaI

; 3419 :     if (list->items == NULL) {
; 3420 : 	list->items = (void **) xmlMalloc(

	push	80					; 00000050H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [esi], ecx

; 3421 : 	    20 * sizeof(void *));
; 3422 : 	if (list->items == NULL) {

	test	ecx, ecx
	jne	SHORT $LN7@xmlSchemaI

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BJ@JABJNCPJ@allocating?5new?5item?5list@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3423 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3424 : 	    return(-1);

	or	eax, -1
	pop	esi

; 3450 : }

	pop	ebp
	ret	0
$LN7@xmlSchemaI:

; 3425 : 	}
; 3426 : 	list->sizeItems = 20;

	mov	DWORD PTR [esi+8], 20			; 00000014H
$LN9@xmlSchemaI:

; 3435 : 	}
; 3436 :     }
; 3437 :     /*
; 3438 :     * Just append if the index is greater/equal than the item count.
; 3439 :     */
; 3440 :     if (idx >= list->nbItems) {

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _idx$[ebp]
	cmp	edi, edx
	jl	SHORT $LL10@xmlSchemaI

; 3441 : 	list->items[list->nbItems++] = item;

	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 3447 : 	list->nbItems++;
; 3448 :     }
; 3449 :     return(0);

	inc	DWORD PTR [esi+4]
	xor	eax, eax
	pop	edi
	pop	esi

; 3450 : }

	pop	ebp
	ret	0
$LN5@xmlSchemaI:

; 3427 :     } else if (list->sizeItems <= list->nbItems) {

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [esi+4]
	jg	SHORT $LN9@xmlSchemaI

; 3428 : 	list->sizeItems *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+8], eax

; 3429 : 	list->items = (void **) xmlRealloc(list->items,

	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR [esi], ecx

; 3430 : 	    list->sizeItems * sizeof(void *));
; 3431 : 	if (list->items == NULL) {

	test	ecx, ecx
	jne	SHORT $LN9@xmlSchemaI

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BC@PKMEEMHP@growing?5item?5list@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3432 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3433 : 	    list->sizeItems = 0;

	mov	DWORD PTR [esi+8], 0

; 3434 : 	    return(-1);

	or	eax, -1
	pop	esi

; 3450 : }

	pop	ebp
	ret	0
$LL10@xmlSchemaI:

; 3442 :     } else {
; 3443 : 	int i;
; 3444 : 	for (i = list->nbItems; i > idx; i--)
; 3445 : 	    list->items[i] = list->items[i-1];

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+edx*4]
	dec	edx
	mov	eax, DWORD PTR [ecx-4]
	mov	DWORD PTR [ecx], eax
	cmp	edx, edi
	jg	SHORT $LL10@xmlSchemaI

; 3446 : 	list->items[idx] = item;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+edi*4], eax

; 3447 : 	list->nbItems++;
; 3448 :     }
; 3449 :     return(0);

	inc	DWORD PTR [esi+4]
	xor	eax, eax
	pop	edi
	pop	esi

; 3450 : }

	pop	ebp
	ret	0
_xmlSchemaItemListInsert ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaItemListAddSize
_TEXT	SEGMENT
_list$ = 8						; size = 4
_initialSize$ = 12					; size = 4
_item$ = 16						; size = 4
_xmlSchemaItemListAddSize PROC				; COMDAT

; 3391 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [esi]
	test	edx, edx
	jne	SHORT $LN2@xmlSchemaI

; 3392 :     if (list->items == NULL) {
; 3393 : 	if (initialSize <= 0)
; 3394 : 	    initialSize = 1;
; 3395 : 	list->items = (void **) xmlMalloc(

	mov	eax, DWORD PTR _initialSize$[ebp]
	mov	edi, 1
	test	eax, eax
	cmovg	edi, eax
	lea	eax, DWORD PTR [edi*4]
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR [esi], edx

; 3396 : 	    initialSize * sizeof(void *));
; 3397 : 	if (list->items == NULL) {

	test	edx, edx
	jne	SHORT $LN5@xmlSchemaI

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BJ@JABJNCPJ@allocating?5new?5item?5list@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3398 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3399 : 	    return(-1);

	or	eax, -1
	pop	edi

; 3414 : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlSchemaI:

; 3400 : 	}
; 3401 : 	list->sizeItems = initialSize;

	mov	DWORD PTR [esi+8], edi
$LN7@xmlSchemaI:

; 3410 : 	}
; 3411 :     }
; 3412 :     list->items[list->nbItems++] = item;

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR _item$[ebp]
	pop	edi
	mov	DWORD PTR [edx+ecx*4], eax
	inc	DWORD PTR [esi+4]

; 3413 :     return(0);

	xor	eax, eax

; 3414 : }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlSchemaI:

; 3402 :     } else if (list->sizeItems <= list->nbItems) {

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [esi+4]
	jg	SHORT $LN7@xmlSchemaI

; 3403 : 	list->sizeItems *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+8], eax

; 3404 : 	list->items = (void **) xmlRealloc(list->items,

	shl	eax, 2
	push	eax
	push	edx
	call	DWORD PTR _xmlRealloc
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR [esi], edx

; 3405 : 	    list->sizeItems * sizeof(void *));
; 3406 : 	if (list->items == NULL) {

	test	edx, edx
	jne	SHORT $LN7@xmlSchemaI

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BC@PKMEEMHP@growing?5item?5list@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3407 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3408 : 	    list->sizeItems = 0;

	mov	DWORD PTR [esi+8], 0

; 3409 : 	    return(-1);

	or	eax, -1
	pop	edi

; 3414 : }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaItemListAddSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaItemListAdd
_TEXT	SEGMENT
_list$ = 8						; size = 4
_item$ = 12						; size = 4
_xmlSchemaItemListAdd PROC				; COMDAT

; 3364 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [esi]
	test	edx, edx
	jne	SHORT $LN2@xmlSchemaI

; 3365 :     if (list->items == NULL) {
; 3366 : 	list->items = (void **) xmlMalloc(

	push	80					; 00000050H
	call	DWORD PTR _xmlMalloc
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR [esi], edx

; 3367 : 	    20 * sizeof(void *));
; 3368 : 	if (list->items == NULL) {

	test	edx, edx
	jne	SHORT $LN4@xmlSchemaI

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BJ@JABJNCPJ@allocating?5new?5item?5list@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3369 : 	    xmlSchemaPErrMemory(NULL, "allocating new item list", NULL);
; 3370 : 	    return(-1);

	or	eax, -1
	pop	esi

; 3385 : }

	pop	ebp
	ret	0
$LN4@xmlSchemaI:

; 3371 : 	}
; 3372 : 	list->sizeItems = 20;

	mov	DWORD PTR [esi+8], 20			; 00000014H
$LN6@xmlSchemaI:

; 3381 : 	}
; 3382 :     }
; 3383 :     list->items[list->nbItems++] = item;

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	inc	DWORD PTR [esi+4]

; 3384 :     return(0);

	xor	eax, eax
	pop	esi

; 3385 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaI:

; 3373 :     } else if (list->sizeItems <= list->nbItems) {

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [esi+4]
	jg	SHORT $LN6@xmlSchemaI

; 3374 : 	list->sizeItems *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+8], eax

; 3375 : 	list->items = (void **) xmlRealloc(list->items,

	shl	eax, 2
	push	eax
	push	edx
	call	DWORD PTR _xmlRealloc
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR [esi], edx

; 3376 : 	    list->sizeItems * sizeof(void *));
; 3377 : 	if (list->items == NULL) {

	test	edx, edx
	jne	SHORT $LN6@xmlSchemaI

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BC@PKMEEMHP@growing?5item?5list@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3378 : 	    xmlSchemaPErrMemory(NULL, "growing item list", NULL);
; 3379 : 	    list->sizeItems = 0;

	mov	DWORD PTR [esi+8], 0

; 3380 : 	    return(-1);

	or	eax, -1
	pop	esi

; 3385 : }

	pop	ebp
	ret	0
_xmlSchemaItemListAdd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaItemListClear
_TEXT	SEGMENT
_list$ = 8						; size = 4
_xmlSchemaItemListClear PROC				; COMDAT

; 3353 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaI

; 3354 :     if (list->items != NULL) {
; 3355 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3356 : 	list->items = NULL;

	mov	DWORD PTR [esi], 0
$LN4@xmlSchemaI:

; 3357 :     }
; 3358 :     list->nbItems = 0;
; 3359 :     list->sizeItems = 0;
; 3360 : }

	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi
	pop	ebp
	ret	0
_xmlSchemaItemListClear ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaItemListCreate
_TEXT	SEGMENT
_xmlSchemaItemListCreate PROC				; COMDAT
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaI

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@BAFOADOL@allocating?5an?5item?5list?5structu@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3339 :     xmlSchemaItemListPtr ret;
; 3340 : 
; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));
; 3342 :     if (ret == NULL) {
; 3343 : 	xmlSchemaPErrMemory(NULL,
; 3344 : 	    "allocating an item list structure", NULL);
; 3345 : 	return (NULL);

	xor	eax, eax

; 3348 :     return (ret);
; 3349 : }

	ret	0
$LN2@xmlSchemaI:
	xorps	xmm0, xmm0

; 3346 :     }
; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));

	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], 0

; 3348 :     return (ret);
; 3349 : }

	ret	0
_xmlSchemaItemListCreate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaNewAnnot
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlSchemaNewAnnot PROC					; COMDAT

; 3323 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	8
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	test	ecx, ecx
	jne	SHORT $LN2@xmlSchemaN

; 1884 :     if (ctxt != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaN

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [eax+20]
$LN5@xmlSchemaN:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BG@ICNGEPGO@allocating?5annotation@
	push	0
	push	DWORD PTR _node$[ebp]
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3324 :     xmlSchemaAnnotPtr ret;
; 3325 : 
; 3326 :     ret = (xmlSchemaAnnotPtr) xmlMalloc(sizeof(xmlSchemaAnnot));
; 3327 :     if (ret == NULL) {
; 3328 :         xmlSchemaPErrMemory(ctxt, "allocating annotation", node);
; 3329 :         return (NULL);

	xor	eax, eax

; 3334 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaN:

; 3330 :     }
; 3331 :     memset(ret, 0, sizeof(xmlSchemaAnnot));
; 3332 :     ret->content = node;

	mov	eax, DWORD PTR _node$[ebp]
	xorps	xmm0, xmm0
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+4], eax

; 3333 :     return (ret);

	mov	eax, ecx

; 3334 : }

	pop	ebp
	ret	0
_xmlSchemaNewAnnot ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaNewSchema
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSchemaNewSchema PROC				; COMDAT

; 3276 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	84					; 00000054H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlSchemaN

; 1884 :     if (ctxt != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaN

; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [eax+20]
$LN5@xmlSchemaN:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BC@BFLACGOA@allocating?5schema@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3277 :     xmlSchemaPtr ret;
; 3278 : 
; 3279 :     ret = (xmlSchemaPtr) xmlMalloc(sizeof(xmlSchema));
; 3280 :     if (ret == NULL) {
; 3281 :         xmlSchemaPErrMemory(ctxt, "allocating schema", NULL);
; 3282 :         return (NULL);

	xor	eax, eax
	pop	esi

; 3289 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaN:

; 3283 :     }
; 3284 :     memset(ret, 0, sizeof(xmlSchema));

	push	84					; 00000054H
	push	0
	push	esi
	call	_memset

; 3285 :     ret->dict = ctxt->dict;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [eax+80]

; 3286 :     xmlDictReference(ret->dict);

	push	eax
	mov	DWORD PTR [esi+60], eax
	call	_xmlDictReference
	add	esp, 16					; 00000010H

; 3287 : 
; 3288 :     return (ret);

	mov	eax, esi
	pop	esi

; 3289 : }

	pop	ebp
	ret	0
_xmlSchemaNewSchema ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPContentErr
_TEXT	SEGMENT
_des$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_ownerItem$ = 16					; size = 4
_ownerElem$ = 20					; size = 4
_child$ = 24						; size = 4
_message$ = 28						; size = 4
_content$ = 32						; size = 4
_xmlSchemaPContentErr PROC				; COMDAT

; 3222 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ownerElem$[ebp]
	lea	eax, DWORD PTR _des$[ebp]
	push	esi
	push	DWORD PTR _ownerItem$[ebp]
	mov	DWORD PTR _des$[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport
	mov	ecx, DWORD PTR _message$[ebp]
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR _child$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@xmlSchemaP

; 3223 :     xmlChar *des = NULL;
; 3224 : 
; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);
; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,

	test	eax, eax
	mov	edx, OFFSET ??_C@_08EAGHGJIC@?$CFs?3?5?$CFs?4?6@
	cmove	eax, esi
	jmp	SHORT $LN18@xmlSchemaP
$LN2@xmlSchemaP:

; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {

	mov	ecx, DWORD PTR _content$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@xmlSchemaP

; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	test	eax, eax
	mov	edx, OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	cmove	eax, esi
	jmp	SHORT $LN18@xmlSchemaP
$LN4@xmlSchemaP:

; 1939 :     if (child != NULL)

	xor	ecx, ecx
	mov	edx, OFFSET ??_C@_0BP@IENIKLPP@?$CFs?3?5The?5content?5is?5not?5valid?4?6@
	test	eax, eax
	jne	SHORT $LN18@xmlSchemaP

; 1940 :         xmlSchemaPErr(ctxt, child, error, msg, str1, str2);
; 1941 :     else
; 1942 :         xmlSchemaPErr(ctxt, node, error, msg, str1, str2);

	mov	eax, esi
$LN18@xmlSchemaP:

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	push	ecx
	push	DWORD PTR _des$[ebp]
	push	edx
	push	DWORD PTR _error$[ebp]
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPErr
	mov	eax, DWORD PTR _des$[ebp]
	add	esp, 24					; 00000018H
	pop	esi
	test	eax, eax
	je	SHORT $LN6@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlSchemaP:

; 3242 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaPContentErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPSimpleTypeErr
_TEXT	SEGMENT
_msg$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_ownerItem$ = 16					; size = 4
_node$ = 20						; size = 4
_type$ = 24						; size = 4
_expected$ = 28						; size = 4
_value$ = 32						; size = 4
_expectedEscaped$1 = 36					; size = 4
_str$2 = 36						; size = 4
_message$ = 36						; size = 4
_str1$ = 40						; size = 4
_str2$ = 44						; size = 4
_xmlSchemaPSimpleTypeErr PROC				; COMDAT

; 3131 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _node$[ebp]
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	push	ebx
	lea	eax, DWORD PTR _msg$[ebp]
	mov	DWORD PTR _msg$[ebp], 0
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError
	mov	eax, DWORD PTR _message$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN2@xmlSchemaP

; 3132 :     xmlChar *msg = NULL;
; 3133 : 
; 3134 :     xmlSchemaFormatNodeForError(&msg, ACTXT_CAST ctxt, node);
; 3135 :     if (message == NULL) {
; 3136 : 	/*
; 3137 : 	* Use default messages.
; 3138 : 	*/
; 3139 : 	if (type != NULL) {

	mov	edi, DWORD PTR _type$[ebp]
	mov	eax, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN4@xmlSchemaP

; 3140 : 	    if (node->type == XML_ATTRIBUTE_NODE)

	cmp	eax, 2
	jne	SHORT $LN6@xmlSchemaP

; 3141 : 		msg = xmlStrcat(msg, BAD_CAST "'%s' is not a valid value of ");

	push	OFFSET ??_C@_0BO@ONHLDAAN@?8?$CFs?8?5is?5not?5a?5valid?5value?5of?5@
	jmp	SHORT $LN33@xmlSchemaP
$LN6@xmlSchemaP:

; 3142 : 	    else
; 3143 : 		msg = xmlStrcat(msg, BAD_CAST "The character content is not a "

	push	OFFSET ??_C@_0CP@NNGHIIKI@The?5character?5content?5is?5not?5a?5@
$LN33@xmlSchemaP:

; 3144 : 		"valid value of ");
; 3145 : 	    if (! xmlSchemaIsGlobalItem(type))

	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _msg$[ebp], eax
	push	edi
	call	_xmlSchemaIsGlobalItem
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@xmlSchemaP

; 3146 : 		msg = xmlStrcat(msg, BAD_CAST "the local ");

	push	OFFSET ??_C@_0L@MLMEJNFI@the?5local?5@
	jmp	SHORT $LN34@xmlSchemaP
$LN8@xmlSchemaP:

; 3147 : 	    else
; 3148 : 		msg = xmlStrcat(msg, BAD_CAST "the ");

	push	OFFSET ??_C@_04BAIFLMGI@the?5@
$LN34@xmlSchemaP:

; 3149 : 
; 3150 : 	    if (WXS_IS_ATOMIC(type))

	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat
	mov	ecx, DWORD PTR [edi+48]
	add	esp, 8
	mov	DWORD PTR _msg$[ebp], eax
	test	ecx, 256				; 00000100H
	je	SHORT $LN10@xmlSchemaP

; 3151 : 		msg = xmlStrcat(msg, BAD_CAST "atomic type");

	push	OFFSET ??_C@_0M@NAKOLHPN@atomic?5type@
	jmp	SHORT $LN35@xmlSchemaP
$LN10@xmlSchemaP:

; 3152 : 	    else if (WXS_IS_LIST(type))

	test	cl, 64					; 00000040H
	je	SHORT $LN12@xmlSchemaP

; 3153 : 		msg = xmlStrcat(msg, BAD_CAST "list type");

	push	OFFSET ??_C@_09EMCEHNFO@list?5type@
	jmp	SHORT $LN35@xmlSchemaP
$LN12@xmlSchemaP:

; 3154 : 	    else if (WXS_IS_UNION(type))

	test	cl, cl
	jns	SHORT $LN14@xmlSchemaP

; 3155 : 		msg = xmlStrcat(msg, BAD_CAST "union type");

	push	OFFSET ??_C@_0L@KHBDGNKM@union?5type@
$LN35@xmlSchemaP:

; 3156 : 
; 3157 : 	    if (xmlSchemaIsGlobalItem(type)) {

	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _msg$[ebp], eax
$LN14@xmlSchemaP:
	push	edi
	call	_xmlSchemaIsGlobalItem
	add	esp, 4
	test	eax, eax
	je	$LN21@xmlSchemaP

; 3158 : 		xmlChar *str = NULL;
; 3159 : 		msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	DWORD PTR _msg$[ebp]
	mov	DWORD PTR _str$2[ebp], 0
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _msg$[ebp], eax

; 3160 : 		if (type->builtInType != 0) {

	cmp	DWORD PTR [edi+88], 0
	je	SHORT $LN16@xmlSchemaP

; 3161 : 		    msg = xmlStrcat(msg, BAD_CAST "xs:");

	push	OFFSET ??_C@_03DCOKAOA@xs?3@
	push	eax
	call	_xmlStrcat

; 3162 : 		    str = xmlStrdup(type->name);

	push	DWORD PTR [edi+8]
	mov	DWORD PTR _msg$[ebp], eax
	call	_xmlStrdup
	add	esp, 12					; 0000000cH

; 3163 : 		} else {

	jmp	SHORT $LN36@xmlSchemaP
$LN16@xmlSchemaP:

; 3164 : 		    const xmlChar *qName = xmlSchemaFormatQName(&str, type->targetNamespace, type->name);

	push	DWORD PTR [edi+8]
	lea	eax, DWORD PTR _str$2[ebp]
	push	DWORD PTR [edi+112]
	push	eax
	call	_xmlSchemaFormatQName
	add	esp, 12					; 0000000cH

; 3165 : 		    if (!str)

	cmp	DWORD PTR _str$2[ebp], 0
	jne	SHORT $LN18@xmlSchemaP

; 3166 : 			str = xmlStrdup(qName);

	push	eax
	call	_xmlStrdup
	add	esp, 4
$LN36@xmlSchemaP:

; 3167 : 		}
; 3168 : 		msg = xmlStrcat(msg, xmlEscapeFormatString(&str));

	mov	DWORD PTR _str$2[ebp], eax
$LN18@xmlSchemaP:
	lea	eax, DWORD PTR _str$2[ebp]
	push	eax
	call	_xmlEscapeFormatString
	push	eax
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat

; 3169 : 		msg = xmlStrcat(msg, BAD_CAST "'.");

	push	OFFSET ??_C@_02DGLLHPKE@?8?4@
	push	eax
	mov	DWORD PTR _msg$[ebp], eax
	call	_xmlStrcat
	mov	DWORD PTR _msg$[ebp], eax
	add	esp, 20					; 00000014H

; 3170 : 		FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$2[ebp]
	test	eax, eax
	je	SHORT $LN21@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3171 : 	    }
; 3172 : 	} else {

	jmp	SHORT $LN21@xmlSchemaP
$LN4@xmlSchemaP:

; 3173 : 	    if (node->type == XML_ATTRIBUTE_NODE)

	cmp	eax, 2
	jne	SHORT $LN20@xmlSchemaP

; 3174 : 		msg = xmlStrcat(msg, BAD_CAST "The value '%s' is not valid.");

	push	OFFSET ??_C@_0BN@HAAPLFMH@The?5value?5?8?$CFs?8?5is?5not?5valid?4@
	jmp	SHORT $LN37@xmlSchemaP
$LN20@xmlSchemaP:

; 3175 : 	    else
; 3176 : 		msg = xmlStrcat(msg, BAD_CAST "The character content is not "

	push	OFFSET ??_C@_0CE@BMFBGFDE@The?5character?5content?5is?5not?5va@
$LN37@xmlSchemaP:

; 3177 : 		"valid.");
; 3178 : 	}
; 3179 : 	if (expected) {

	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat
	mov	DWORD PTR _msg$[ebp], eax
	add	esp, 8
$LN21@xmlSchemaP:
	mov	eax, DWORD PTR _expected$[ebp]
	test	eax, eax
	je	SHORT $LN22@xmlSchemaP

; 3180 : 	    xmlChar *expectedEscaped = xmlCharStrdup(expected);

	push	eax
	call	_xmlCharStrdup

; 3181 : 	    msg = xmlStrcat(msg, BAD_CAST " Expected is '");

	push	OFFSET ??_C@_0P@PICMEPAD@?5Expected?5is?5?8@
	push	DWORD PTR _msg$[ebp]
	mov	DWORD PTR _expectedEscaped$1[ebp], eax
	call	_xmlStrcat
	mov	DWORD PTR _msg$[ebp], eax

; 3182 : 	    msg = xmlStrcat(msg, xmlEscapeFormatString(&expectedEscaped));

	lea	eax, DWORD PTR _expectedEscaped$1[ebp]
	push	eax
	call	_xmlEscapeFormatString
	push	eax
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat

; 3183 : 	    FREE_AND_NULL(expectedEscaped);

	mov	ecx, DWORD PTR _expectedEscaped$1[ebp]
	add	esp, 24					; 00000018H
	mov	DWORD PTR _msg$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN24@xmlSchemaP
	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _msg$[ebp]
	add	esp, 4
	mov	DWORD PTR _expectedEscaped$1[ebp], 0
$LN24@xmlSchemaP:

; 3184 : 	    msg = xmlStrcat(msg, BAD_CAST "'.\n");

	push	OFFSET ??_C@_03CLGCDEAE@?8?4?6@
	push	eax

; 3185 : 	} else

	jmp	SHORT $LN38@xmlSchemaP
$LN22@xmlSchemaP:

; 3186 : 	    msg = xmlStrcat(msg, BAD_CAST "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR _msg$[ebp]
$LN38@xmlSchemaP:

; 3187 : 	if (node->type == XML_ATTRIBUTE_NODE)

	call	_xmlStrcat

; 3188 : 	    xmlSchemaPErr(ctxt, node, error, (const char *) msg, value, NULL);
; 3189 : 	else
; 3190 : 	    xmlSchemaPErr(ctxt, node, error, (const char *) msg, NULL, NULL);
; 3191 :     } else {

	mov	ecx, DWORD PTR _value$[ebp]
	add	esp, 8
	xor	edx, edx
	mov	DWORD PTR _msg$[ebp], eax
	cmp	DWORD PTR [ebx+4], 2
	push	0
	cmovne	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _error$[ebp]
	push	eax
	push	ecx
	push	ebx
	push	esi
	call	_xmlSchemaPErr
	add	esp, 24					; 00000018H
	jmp	SHORT $LN29@xmlSchemaP
$LN2@xmlSchemaP:

; 3192 : 	msg = xmlStrcat(msg, BAD_CAST message);

	push	eax
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat

; 3193 : 	msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$[ebp], eax
	call	_xmlStrcat
	add	esp, 16					; 00000010H
	mov	DWORD PTR _msg$[ebp], eax

; 1971 :     xmlGenericErrorFunc channel = NULL;

	xor	ecx, ecx

; 1972 :     xmlStructuredErrorFunc schannel = NULL;

	xor	edx, edx

; 1973 :     void *data = NULL;

	xor	edi, edi

; 1974 : 
; 1975 :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN30@xmlSchemaP

; 1976 :         ctxt->nberrors++;
; 1977 : 	ctxt->err = error;

	mov	ecx, DWORD PTR _error$[ebp]
	inc	DWORD PTR [esi+20]

; 1978 :         channel = ctxt->error;
; 1979 :         data = ctxt->errCtxt;

	mov	edi, DWORD PTR [esi+4]

; 1980 : 	schannel = ctxt->serror;

	mov	edx, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+16], ecx
	mov	ecx, DWORD PTR [esi+8]
$LN30@xmlSchemaP:

; 1981 :     }
; 1982 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	push	0
	push	0
	push	0
	push	DWORD PTR _str2$[ebp]
	push	DWORD PTR _str1$[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	16					; 00000010H
	push	ebx
	push	esi
	push	edi
	push	ecx
	push	edx
	call	___xmlRaiseError
	add	esp, 84					; 00000054H
$LN29@xmlSchemaP:

; 3194 : 	xmlSchemaPErrExt(ctxt, node, error, NULL, NULL, NULL,
; 3195 : 	     (const char*) msg, str1, str2, NULL, NULL, NULL);
; 3196 :     }
; 3197 :     /* Cleanup. */
; 3198 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN27@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN27@xmlSchemaP:

; 3199 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaPSimpleTypeErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPMutualExclAttrErr
_TEXT	SEGMENT
_des$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_ownerItem$ = 16					; size = 4
_attr$ = 20						; size = 4
_name1$ = 24						; size = 4
_name2$ = 28						; size = 4
_xmlSchemaPMutualExclAttrErr PROC			; COMDAT

; 3097 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _attr$[ebp]
	lea	eax, DWORD PTR _des$[ebp]
	mov	DWORD PTR _des$[ebp], 0
	push	DWORD PTR [ebx+20]
	push	DWORD PTR _ownerItem$[ebp]
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 1975 :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]

; 3098 :     xmlChar *des = NULL;
; 3099 : 
; 3100 :     xmlSchemaFormatItemForReport(&des, NULL, WXS_BASIC_CAST ownerItem, attr->parent);

	add	esp, 16					; 00000010H

; 1975 :     if (ctxt != NULL) {

	mov	edi, DWORD PTR _error$[ebp]
	xor	ecx, ecx
	xor	edx, edx
	xor	esi, esi
	test	eax, eax
	je	SHORT $LN5@xmlSchemaP

; 1976 :         ctxt->nberrors++;

	inc	DWORD PTR [eax+20]

; 1977 : 	ctxt->err = error;
; 1978 :         channel = ctxt->error;

	mov	ecx, DWORD PTR [eax+8]

; 1979 :         data = ctxt->errCtxt;

	mov	esi, DWORD PTR [eax+4]

; 1980 : 	schannel = ctxt->serror;

	mov	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+16], edi
$LN5@xmlSchemaP:

; 1981 :     }
; 1982 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	push	0
	push	0
	push	DWORD PTR _name2$[ebp]
	push	DWORD PTR _name1$[ebp]
	push	DWORD PTR _des$[ebp]
	push	OFFSET ??_C@_0DK@HPMJEOHA@?$CFs?3?5The?5attributes?5?8?$CFs?8?5and?5?8?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	edi
	push	16					; 00000010H
	push	ebx
	push	eax
	push	esi
	push	ecx
	push	edx
	call	___xmlRaiseError

; 3101 :     xmlSchemaPErrExt(ctxt, (xmlNodePtr) attr, error, NULL, NULL, NULL,
; 3102 : 	"%s: The attributes '%s' and '%s' are mutually exclusive.\n",
; 3103 : 	BAD_CAST des, BAD_CAST name1, BAD_CAST name2, NULL, NULL);
; 3104 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$[ebp]

; 1982 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 84					; 00000054H

; 3101 :     xmlSchemaPErrExt(ctxt, (xmlNodePtr) attr, error, NULL, NULL, NULL,
; 3102 : 	"%s: The attributes '%s' and '%s' are mutually exclusive.\n",
; 3103 : 	BAD_CAST des, BAD_CAST name1, BAD_CAST name2, NULL, NULL);
; 3104 :     FREE_AND_NULL(des);

	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN2@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlSchemaP:

; 3105 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaPMutualExclAttrErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPIllegalFacetListUnionErr
_TEXT	SEGMENT
_des$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_str2$1$ = 16						; size = 4
_type$ = 16						; size = 4
_node$1$ = 20						; size = 4
_facet$ = 20						; size = 4
_xmlSchemaPIllegalFacetListUnionErr PROC		; COMDAT

; 3069 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _type$[ebp]
	lea	eax, DWORD PTR _des$[ebp]
	mov	DWORD PTR _des$[ebp], 0
	push	DWORD PTR [esi+36]
	push	esi
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport
	mov	eax, DWORD PTR _facet$[ebp]
	push	DWORD PTR [eax]
	call	_xmlSchemaFacetTypeToString
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 20					; 00000014H

; 1909 :     if (ctxt != NULL) {

	mov	ebx, DWORD PTR _error$[ebp]
	xor	edx, edx

; 3070 :     xmlChar *des = NULL;
; 3071 : 
; 3072 :     xmlSchemaFormatItemForReport(&des, NULL, WXS_BASIC_CAST type,
; 3073 : 	type->node);
; 3074 :     xmlSchemaPErr(ctxt, type->node, error,

	mov	DWORD PTR _node$1$[ebp], ecx

; 1906 :     xmlStructuredErrorFunc schannel = NULL;

	xor	esi, esi

; 1907 :     void *data = NULL;
; 1908 : 
; 1909 :     if (ctxt != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	xor	edi, edi

; 3070 :     xmlChar *des = NULL;
; 3071 : 
; 3072 :     xmlSchemaFormatItemForReport(&des, NULL, WXS_BASIC_CAST type,
; 3073 : 	type->node);
; 3074 :     xmlSchemaPErr(ctxt, type->node, error,

	mov	DWORD PTR _str2$1$[ebp], eax

; 1909 :     if (ctxt != NULL) {

	test	ecx, ecx
	je	SHORT $LN5@xmlSchemaP

; 1910 :         ctxt->nberrors++;

	inc	DWORD PTR [ecx+20]

; 1911 : 	ctxt->err = error;
; 1912 :         channel = ctxt->error;

	mov	edx, DWORD PTR [ecx+8]

; 1913 :         data = ctxt->errCtxt;

	mov	edi, DWORD PTR [ecx+4]

; 1914 : 	schannel = ctxt->serror;

	mov	esi, DWORD PTR [ecx+24]
	mov	DWORD PTR [ecx+16], ebx
$LN5@xmlSchemaP:

; 1915 :     }
; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	push	eax
	mov	eax, DWORD PTR _des$[ebp]
	push	eax
	push	OFFSET ??_C@_0CE@OEIFIFDF@?$CFs?3?5The?5facet?5?8?$CFs?8?5is?5not?5allow@
	push	0
	push	0
	push	0
	push	DWORD PTR _str2$1$[ebp]
	push	eax
	push	0
	push	0
	push	2
	push	ebx
	push	16					; 00000010H
	push	DWORD PTR _node$1$[ebp]
	push	ecx
	push	edi
	push	edx
	push	esi
	call	___xmlRaiseError

; 3075 : 	"%s: The facet '%s' is not allowed.\n",
; 3076 : 	BAD_CAST des, xmlSchemaFacetTypeToString(facet->type));
; 3077 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$[ebp]

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 72					; 00000048H

; 3075 : 	"%s: The facet '%s' is not allowed.\n",
; 3076 : 	BAD_CAST des, xmlSchemaFacetTypeToString(facet->type));
; 3077 :     FREE_AND_NULL(des);

	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN2@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlSchemaP:

; 3078 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaPIllegalFacetListUnionErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPIllegalFacetAtomicErr
_TEXT	SEGMENT
_strT$ = -8						; size = 4
_des$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_str2$1$ = 16						; size = 4
_type$ = 16						; size = 4
_baseType$ = 20						; size = 4
_node$1$ = 24						; size = 4
_facet$ = 24						; size = 4
_xmlSchemaPIllegalFacetAtomicErr PROC			; COMDAT

; 3040 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _type$[ebp]
	lea	eax, DWORD PTR _des$[ebp]
	mov	DWORD PTR _des$[ebp], 0
	mov	DWORD PTR _strT$[ebp], 0
	push	DWORD PTR [esi+36]
	push	esi
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport
	push	0
	push	DWORD PTR _baseType$[ebp]
	lea	eax, DWORD PTR _strT$[ebp]
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport
	mov	ecx, DWORD PTR _facet$[ebp]
	mov	ebx, eax
	push	DWORD PTR [ecx]
	call	_xmlSchemaFacetTypeToString

; 1975 :     if (ctxt != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]

; 3041 :     xmlChar *des = NULL, *strT = NULL;
; 3042 : 
; 3043 :     xmlSchemaFormatItemForReport(&des, NULL, WXS_BASIC_CAST type, type->node);
; 3044 :     xmlSchemaPErrExt(ctxt, type->node, error, NULL, NULL, NULL,

	add	esp, 36					; 00000024H
	mov	DWORD PTR _str2$1$[ebp], eax

; 1971 :     xmlGenericErrorFunc channel = NULL;

	xor	edx, edx

; 3041 :     xmlChar *des = NULL, *strT = NULL;
; 3042 : 
; 3043 :     xmlSchemaFormatItemForReport(&des, NULL, WXS_BASIC_CAST type, type->node);
; 3044 :     xmlSchemaPErrExt(ctxt, type->node, error, NULL, NULL, NULL,

	mov	eax, DWORD PTR [esi+36]

; 1973 :     void *data = NULL;

	xor	edi, edi
	xor	esi, esi

; 3041 :     xmlChar *des = NULL, *strT = NULL;
; 3042 : 
; 3043 :     xmlSchemaFormatItemForReport(&des, NULL, WXS_BASIC_CAST type, type->node);
; 3044 :     xmlSchemaPErrExt(ctxt, type->node, error, NULL, NULL, NULL,

	mov	DWORD PTR _node$1$[ebp], eax

; 1975 :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _error$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@xmlSchemaP

; 1976 :         ctxt->nberrors++;

	inc	DWORD PTR [ecx+20]

; 1977 : 	ctxt->err = error;
; 1978 :         channel = ctxt->error;

	mov	edx, DWORD PTR [ecx+8]

; 1979 :         data = ctxt->errCtxt;

	mov	edi, DWORD PTR [ecx+4]

; 1980 : 	schannel = ctxt->serror;

	mov	esi, DWORD PTR [ecx+24]
	mov	DWORD PTR [ecx+16], eax
$LN6@xmlSchemaP:

; 1981 :     }
; 1982 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	push	0
	push	0
	push	ebx
	push	DWORD PTR _str2$1$[ebp]
	push	DWORD PTR _des$[ebp]
	push	OFFSET ??_C@_0EG@LINCPIFE@?$CFs?3?5The?5facet?5?8?$CFs?8?5is?5not?5allow@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	eax
	push	16					; 00000010H
	push	DWORD PTR _node$1$[ebp]
	push	ecx
	push	edi
	push	edx
	push	esi
	call	___xmlRaiseError

; 3045 : 	"%s: The facet '%s' is not allowed on types derived from the "
; 3046 : 	"type %s.\n",
; 3047 : 	BAD_CAST des, xmlSchemaFacetTypeToString(facet->type),
; 3048 : 	xmlSchemaFormatItemForReport(&strT, NULL, WXS_BASIC_CAST baseType, NULL),
; 3049 : 	NULL, NULL);
; 3050 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$[ebp]

; 1982 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 84					; 00000054H

; 3045 : 	"%s: The facet '%s' is not allowed on types derived from the "
; 3046 : 	"type %s.\n",
; 3047 : 	BAD_CAST des, xmlSchemaFacetTypeToString(facet->type),
; 3048 : 	xmlSchemaFormatItemForReport(&strT, NULL, WXS_BASIC_CAST baseType, NULL),
; 3049 : 	NULL, NULL);
; 3050 :     FREE_AND_NULL(des);

	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN2@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	DWORD PTR _des$[ebp], 0
$LN2@xmlSchemaP:

; 3051 :     FREE_AND_NULL(strT);

	mov	eax, DWORD PTR _strT$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlSchemaP:

; 3052 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaPIllegalFacetAtomicErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPAttrUseErr4
_TEXT	SEGMENT
_str$ = -8						; size = 4
_msg$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_node$ = 16						; size = 4
_ownerItem$ = 20					; size = 4
_attruse$ = 24						; size = 4
_message$ = 28						; size = 4
_str1$ = 32						; size = 4
_str2$ = 36						; size = 4
_str3$ = 40						; size = 4
_str4$ = 44						; size = 4
_xmlSchemaPAttrUseErr4 PROC				; COMDAT

; 3007 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _ownerItem$[ebp]
	lea	eax, DWORD PTR _msg$[ebp]
	mov	DWORD PTR _str$[ebp], 0
	push	0
	push	eax
	mov	DWORD PTR _msg$[ebp], 0
	call	_xmlSchemaFormatItemForReport
	push	OFFSET ??_C@_02KEGNLNML@?0?5@
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat
	push	0
	push	DWORD PTR _attruse$[ebp]
	mov	DWORD PTR _msg$[ebp], eax
	lea	eax, DWORD PTR _str$[ebp]
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport
	push	eax
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat
	mov	ecx, DWORD PTR _str$[ebp]
	add	esp, 48					; 00000030H
	mov	DWORD PTR _msg$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN2@xmlSchemaP

; 3008 :     xmlChar *str = NULL, *msg = NULL;
; 3009 : 
; 3010 :     xmlSchemaFormatItemForReport(&msg, NULL, ownerItem, NULL);
; 3011 :     msg = xmlStrcat(msg, BAD_CAST ", ");
; 3012 :     msg = xmlStrcat(msg,
; 3013 : 	BAD_CAST xmlSchemaFormatItemForReport(&str, NULL,
; 3014 : 	WXS_BASIC_CAST attruse, NULL));
; 3015 :     FREE_AND_NULL(str);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _msg$[ebp]
	add	esp, 4
	mov	DWORD PTR _str$[ebp], 0
$LN2@xmlSchemaP:

; 3016 :     msg = xmlStrcat(msg, BAD_CAST ": ");

	push	OFFSET ??_C@_02LMMGGCAJ@?3?5@
	push	eax
	call	_xmlStrcat

; 3017 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	DWORD PTR _message$[ebp]
	mov	DWORD PTR _msg$[ebp], eax
	push	eax
	call	_xmlStrcat

; 3018 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	DWORD PTR _str4$[ebp]

; 3018 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	DWORD PTR _str3$[ebp]
	push	DWORD PTR _str2$[ebp]
	push	DWORD PTR _str1$[ebp]
	push	eax
	push	0
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _error$[ebp]
	push	2
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaErr4Line
	add	esp, 64					; 00000040H

; 3019 :     xmlSchemaErr4(ACTXT_CAST ctxt, error, node,
; 3020 : 	(const char *) msg, str1, str2, str3, str4);
; 3021 :     xmlFree(msg);

	push	DWORD PTR _msg$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3022 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaPAttrUseErr4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPCustomErr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_item$ = 16						; size = 4
_itemElem$ = 20						; size = 4
_message$ = 24						; size = 4
_str1$ = 28						; size = 4
_xmlSchemaPCustomErr PROC				; COMDAT

; 2980 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	0
	push	DWORD PTR _str1$[ebp]
	push	DWORD PTR _message$[ebp]
	push	DWORD PTR _itemElem$[ebp]
	push	DWORD PTR _item$[ebp]
	push	DWORD PTR _error$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,
; 2982 : 	str1, NULL, NULL);
; 2983 : }

	pop	ebp
	ret	0
_xmlSchemaPCustomErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPCustomErrExt
_TEXT	SEGMENT
_des$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_item$ = 16						; size = 4
_itemElem$ = 20						; size = 4
_message$ = 24						; size = 4
_str1$ = 28						; size = 4
_str2$ = 32						; size = 4
_str3$ = 36						; size = 4
_xmlSchemaPCustomErrExt PROC				; COMDAT

; 2946 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _itemElem$[ebp]
	lea	eax, DWORD PTR _des$[ebp]
	mov	edi, DWORD PTR _item$[ebp]
	push	ebx
	push	edi
	push	0
	push	eax
	mov	DWORD PTR _des$[ebp], 0
	call	_xmlSchemaFormatItemForReport
	push	OFFSET ??_C@_04PFAOODAA@?$CFs?3?5@
	call	_xmlStrdup
	push	DWORD PTR _message$[ebp]
	push	eax
	call	_xmlStrcat
	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	call	_xmlStrcat
	add	esp, 36					; 00000024H
	mov	esi, eax
	test	ebx, ebx
	jne	SHORT $LN2@xmlSchemaP

; 2947 :     xmlChar *des = NULL, *msg = NULL;
; 2948 : 
; 2949 :     xmlSchemaFormatItemForReport(&des, NULL, item, itemElem);
; 2950 :     msg = xmlStrdup(BAD_CAST "%s: ");
; 2951 :     msg = xmlStrcat(msg, (const xmlChar *) message);
; 2952 :     msg = xmlStrcat(msg, BAD_CAST ".\n");
; 2953 :     if ((itemElem == NULL) && (item != NULL))

	test	edi, edi
	je	SHORT $LN2@xmlSchemaP

; 2954 : 	itemElem = WXS_ITEM_NODE(item);

	push	edi
	call	_xmlSchemaGetComponentNode
	add	esp, 4
	mov	ebx, eax
$LN2@xmlSchemaP:

; 1975 :     if (ctxt != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	xor	edx, edx
	xor	edi, edi
	test	ecx, ecx
	je	SHORT $LN7@xmlSchemaP

; 1976 :         ctxt->nberrors++;
; 1977 : 	ctxt->err = error;

	mov	eax, DWORD PTR _error$[ebp]
	inc	DWORD PTR [ecx+20]

; 1978 :         channel = ctxt->error;
; 1979 :         data = ctxt->errCtxt;

	mov	edi, DWORD PTR [ecx+4]

; 1980 : 	schannel = ctxt->serror;

	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [ecx+8]
$LN7@xmlSchemaP:

; 1981 :     }
; 1982 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	push	0
	push	DWORD PTR _str3$[ebp]
	push	DWORD PTR _str2$[ebp]
	push	DWORD PTR _str1$[ebp]
	push	DWORD PTR _des$[ebp]
	push	esi
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	16					; 00000010H
	push	ebx
	push	ecx
	push	edi
	push	eax
	push	edx
	call	___xmlRaiseError

; 2955 :     xmlSchemaPErrExt(ctxt, itemElem, error, NULL, NULL, NULL,
; 2956 : 	(const char *) msg, BAD_CAST des, str1, str2, str3, NULL);
; 2957 :     FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$[ebp]

; 1982 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 84					; 00000054H

; 2955 :     xmlSchemaPErrExt(ctxt, itemElem, error, NULL, NULL, NULL,
; 2956 : 	(const char *) msg, BAD_CAST des, str1, str2, str3, NULL);
; 2957 :     FREE_AND_NULL(des);

	test	eax, eax
	je	SHORT $LN3@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	DWORD PTR _des$[ebp], 0
$LN3@xmlSchemaP:

; 2958 :     FREE_AND_NULL(msg);

	test	esi, esi
	je	SHORT $LN4@xmlSchemaP
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlSchemaP:

; 2959 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaPCustomErrExt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPIllegalAttrErr
_TEXT	SEGMENT
_strB$ = -8						; size = 4
_strA$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_ownerComp$ = 16					; size = 4
_attr$ = 20						; size = 4
_xmlSchemaPIllegalAttrErr PROC				; COMDAT

; 2911 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _attr$[ebp]
	lea	eax, DWORD PTR _strA$[ebp]
	xor	esi, esi
	mov	DWORD PTR _strA$[ebp], 0
	mov	DWORD PTR _strB$[ebp], esi
	push	DWORD PTR [edi+20]
	push	DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSchemaFormatNodeForError
	mov	ecx, DWORD PTR [edi+36]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [edi+8]

; 1323 :     if (ns != NULL)

	test	ecx, ecx
	je	SHORT $LN6@xmlSchemaP

; 1324 : 	return (xmlSchemaFormatQName(buf, ns->href, localName));

	push	eax
	push	DWORD PTR [ecx+8]
	lea	eax, DWORD PTR _strB$[ebp]
	push	eax
	call	_xmlSchemaFormatQName
	mov	esi, DWORD PTR _strB$[ebp]
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN9@xmlSchemaP
$LN6@xmlSchemaP:

; 1310 :     if (localName != NULL) {

	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP

; 1311 : 	if (namespaceName == NULL)
; 1312 : 	    return(localName);
; 1313 : 	*buf = xmlStrcat(*buf, localName);
; 1314 :     } else {
; 1315 : 	*buf = xmlStrcat(*buf, BAD_CAST "(NULL)");

	push	OFFSET ??_C@_06LHGEHABH@?$CINULL?$CJ@
	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	esi, eax
$LN9@xmlSchemaP:

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	eax
	push	DWORD PTR _strA$[ebp]
	push	OFFSET ??_C@_0CG@GPHLIIIG@?$CFsThe?5attribute?5?8?$CFs?8?5is?5not?5all@
	push	0
	push	edi
	push	DWORD PTR _error$[ebp]
	push	2
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaErr4Line

; 2912 :     xmlChar *strA = NULL, *strB = NULL;
; 2913 : 
; 2914 :     xmlSchemaFormatNodeForError(&strA, ACTXT_CAST ctxt, attr->parent);
; 2915 :     xmlSchemaErr4(ACTXT_CAST ctxt, error, (xmlNodePtr) attr,
; 2916 : 	"%sThe attribute '%s' is not allowed.\n", BAD_CAST strA,
; 2917 : 	xmlSchemaFormatQNameNs(&strB, attr->ns, attr->name),
; 2918 : 	NULL, NULL);
; 2919 :     FREE_AND_NULL(strA);

	mov	eax, DWORD PTR _strA$[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 40					; 00000028H

; 2912 :     xmlChar *strA = NULL, *strB = NULL;
; 2913 : 
; 2914 :     xmlSchemaFormatNodeForError(&strA, ACTXT_CAST ctxt, attr->parent);
; 2915 :     xmlSchemaErr4(ACTXT_CAST ctxt, error, (xmlNodePtr) attr,
; 2916 : 	"%sThe attribute '%s' is not allowed.\n", BAD_CAST strA,
; 2917 : 	xmlSchemaFormatQNameNs(&strB, attr->ns, attr->name),
; 2918 : 	NULL, NULL);
; 2919 :     FREE_AND_NULL(strA);

	test	eax, eax
	je	SHORT $LN2@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	DWORD PTR _strA$[ebp], 0
$LN2@xmlSchemaP:

; 2920 :     FREE_AND_NULL(strB);

	test	esi, esi
	je	SHORT $LN3@xmlSchemaP
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlSchemaP:

; 2921 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaPIllegalAttrErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPCustomAttrErr
_TEXT	SEGMENT
_des$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_data$1$ = 16						; size = 4
_ownerDes$ = 16						; size = 4
_ownerItem$ = 20					; size = 4
_str2$1$ = 24						; size = 4
_attr$ = 24						; size = 4
_msg$ = 28						; size = 4
_xmlSchemaPCustomAttrErr PROC				; COMDAT

; 2872 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ownerDes$[ebp]
	mov	edi, DWORD PTR _attr$[ebp]
	mov	DWORD PTR _des$[ebp], 0
	test	esi, esi
	jne	SHORT $LN2@xmlSchemaP

; 2873 :     xmlChar *des = NULL;
; 2874 : 
; 2875 :     if (ownerDes == NULL)
; 2876 : 	xmlSchemaFormatItemForReport(&des, NULL, ownerItem, attr->parent);

	push	DWORD PTR [edi+20]
	lea	eax, DWORD PTR _des$[ebp]
	push	DWORD PTR _ownerItem$[ebp]
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport
	mov	eax, DWORD PTR _des$[ebp]
	add	esp, 16					; 00000010H
	jmp	SHORT $LN5@xmlSchemaP
$LN2@xmlSchemaP:

; 2877 :     else if (*ownerDes == NULL) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN4@xmlSchemaP

; 2878 : 	xmlSchemaFormatItemForReport(ownerDes, NULL, ownerItem, attr->parent);

	push	DWORD PTR [edi+20]
	push	DWORD PTR _ownerItem$[ebp]
	push	eax
	push	esi
	call	_xmlSchemaFormatItemForReport

; 2879 : 	des = *ownerDes;

	mov	eax, DWORD PTR [esi]
	add	esp, 16					; 00000010H
$LN4@xmlSchemaP:

; 2880 :     } else
; 2881 : 	des = *ownerDes;
; 2882 :     if (attr == NULL) {

	mov	DWORD PTR _des$[ebp], eax
$LN5@xmlSchemaP:
	xor	edx, edx
	xor	ebx, ebx
	test	edi, edi
	jne	SHORT $LN6@xmlSchemaP

; 1975 :     if (ctxt != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN12@xmlSchemaP

; 1976 :         ctxt->nberrors++;
; 1977 : 	ctxt->err = error;

	mov	edx, DWORD PTR _error$[ebp]
	inc	DWORD PTR [ecx+20]

; 1978 :         channel = ctxt->error;
; 1979 :         data = ctxt->errCtxt;

	mov	ebx, DWORD PTR [ecx+4]

; 1980 : 	schannel = ctxt->serror;

	mov	edi, DWORD PTR [ecx+24]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR [ecx+8]
$LN12@xmlSchemaP:

; 1981 :     }
; 1982 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	push	0
	push	0
	push	DWORD PTR _msg$[ebp]
	push	OFFSET ??_C@_07NBCGADJA@Unknown@
	push	eax
	push	OFFSET ??_C@_0BJ@EDCPEHIM@?$CFs?0?5attribute?5?8?$CFs?8?3?5?$CFs?4?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	16					; 00000010H
	push	0
	push	ecx
	push	ebx
	push	edx
	push	edi

; 2883 : 	xmlSchemaPErrExt(ctxt, NULL, error, NULL, NULL, NULL,
; 2884 : 	    "%s, attribute '%s': %s.\n",
; 2885 : 	    BAD_CAST des, (const xmlChar *) "Unknown",
; 2886 : 	    (const xmlChar *) msg, NULL, NULL);
; 2887 :     } else {

	jmp	SHORT $LN17@xmlSchemaP
$LN6@xmlSchemaP:

; 2888 : 	xmlSchemaPErrExt(ctxt, (xmlNodePtr) attr, error, NULL, NULL, NULL,

	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR _str2$1$[ebp], ecx

; 1975 :     if (ctxt != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _data$1$[ebp], edx
	test	ecx, ecx
	je	SHORT $LN15@xmlSchemaP

; 1976 :         ctxt->nberrors++;
; 1977 : 	ctxt->err = error;

	mov	edx, DWORD PTR _error$[ebp]

; 1978 :         channel = ctxt->error;
; 1979 :         data = ctxt->errCtxt;

	mov	ebx, DWORD PTR [ecx+4]
	inc	DWORD PTR [ecx+20]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _data$1$[ebp], ebx

; 1980 : 	schannel = ctxt->serror;

	mov	ebx, DWORD PTR [ecx+24]
$LN15@xmlSchemaP:

; 1981 :     }
; 1982 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	push	0
	push	0
	push	DWORD PTR _msg$[ebp]
	push	DWORD PTR _str2$1$[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@EDCPEHIM@?$CFs?0?5attribute?5?8?$CFs?8?3?5?$CFs?4?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	16					; 00000010H
	push	edi
	push	ecx
	push	DWORD PTR _data$1$[ebp]
	push	edx
	push	ebx
$LN17@xmlSchemaP:

; 2889 : 	    "%s, attribute '%s': %s.\n",
; 2890 : 	    BAD_CAST des, attr->name, (const xmlChar *) msg, NULL, NULL);
; 2891 :     }
; 2892 :     if (ownerDes == NULL)

	call	___xmlRaiseError
	add	esp, 84					; 00000054H
	test	esi, esi
	pop	edi
	pop	esi
	pop	ebx
	jne	SHORT $LN9@xmlSchemaP

; 2893 : 	FREE_AND_NULL(des);

	mov	eax, DWORD PTR _des$[ebp]
	test	eax, eax
	je	SHORT $LN9@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlSchemaP:

; 2894 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaPCustomAttrErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPResCompAttrErr
_TEXT	SEGMENT
_strA$ = -8						; size = 4
_des$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_ownerItem$ = 16					; size = 4
_ownerElem$ = 20					; size = 4
_name$ = 24						; size = 4
_refName$ = 28						; size = 4
_refURI$ = 32						; size = 4
_refType$ = 36						; size = 4
_str3$1$ = 40						; size = 4
_refTypeStr$ = 40					; size = 4
_xmlSchemaPResCompAttrErr PROC				; COMDAT

; 2839 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _ownerElem$[ebp]
	lea	eax, DWORD PTR _des$[ebp]
	mov	DWORD PTR _des$[ebp], 0
	push	DWORD PTR _ownerItem$[ebp]
	mov	DWORD PTR _strA$[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport
	mov	esi, DWORD PTR _refTypeStr$[ebp]
	add	esp, 16					; 00000010H
	test	esi, esi
	jne	SHORT $LN2@xmlSchemaP

; 2840 :     xmlChar *des = NULL, *strA = NULL;
; 2841 : 
; 2842 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);
; 2843 :     if (refTypeStr == NULL)
; 2844 : 	refTypeStr = (const char *) xmlSchemaItemTypeToStr(refType);

	push	DWORD PTR _refType$[ebp]
	call	_xmlSchemaItemTypeToStr
	add	esp, 4
	mov	esi, eax
$LN2@xmlSchemaP:

; 2845 :     xmlSchemaPErrExt(ctxt, ownerElem, error,

	push	DWORD PTR _refName$[ebp]
	lea	eax, DWORD PTR _strA$[ebp]
	push	DWORD PTR _refURI$[ebp]
	push	eax
	call	_xmlSchemaFormatQName

; 1975 :     if (ctxt != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]

; 2845 :     xmlSchemaPErrExt(ctxt, ownerElem, error,

	add	esp, 12					; 0000000cH
	mov	DWORD PTR _str3$1$[ebp], eax

; 1971 :     xmlGenericErrorFunc channel = NULL;

	xor	edx, edx

; 1972 :     xmlStructuredErrorFunc schannel = NULL;

	xor	eax, eax

; 1973 :     void *data = NULL;

	xor	ebx, ebx

; 1974 : 
; 1975 :     if (ctxt != NULL) {

	test	ecx, ecx
	je	SHORT $LN7@xmlSchemaP

; 1976 :         ctxt->nberrors++;
; 1977 : 	ctxt->err = error;

	mov	eax, DWORD PTR _error$[ebp]
	inc	DWORD PTR [ecx+20]

; 1978 :         channel = ctxt->error;

	mov	edx, DWORD PTR [ecx+8]

; 1979 :         data = ctxt->errCtxt;

	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+16], eax

; 1980 : 	schannel = ctxt->serror;

	mov	eax, DWORD PTR [ecx+24]
$LN7@xmlSchemaP:

; 1981 :     }
; 1982 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	push	0
	push	esi
	push	DWORD PTR _str3$1$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _des$[ebp]
	push	OFFSET ??_C@_0EH@GOOOKJLI@?$CFs?0?5attribute?5?8?$CFs?8?3?5The?5QName?5v@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	16					; 00000010H
	push	DWORD PTR _ownerElem$[ebp]
	push	ecx
	push	ebx
	push	edx
	push	eax
	call	___xmlRaiseError

; 2846 : 	    NULL, NULL, NULL,
; 2847 : 	    "%s, attribute '%s': The QName value '%s' does not resolve to a(n) "
; 2848 : 	    "%s.\n", BAD_CAST des, BAD_CAST name,
; 2849 : 	    xmlSchemaFormatQName(&strA, refURI, refName),
; 2850 : 	    BAD_CAST refTypeStr, NULL);
; 2851 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$[ebp]

; 1982 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	add	esp, 84					; 00000054H

; 2846 : 	    NULL, NULL, NULL,
; 2847 : 	    "%s, attribute '%s': The QName value '%s' does not resolve to a(n) "
; 2848 : 	    "%s.\n", BAD_CAST des, BAD_CAST name,
; 2849 : 	    xmlSchemaFormatQName(&strA, refURI, refName),
; 2850 : 	    BAD_CAST refTypeStr, NULL);
; 2851 :     FREE_AND_NULL(des)

	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN3@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	DWORD PTR _des$[ebp], 0
$LN3@xmlSchemaP:

; 2852 :     FREE_AND_NULL(strA)

	mov	eax, DWORD PTR _strA$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlSchemaP:

; 2853 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaPResCompAttrErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPMissingAttrErr
_TEXT	SEGMENT
_des$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_ownerItem$ = 16					; size = 4
_ownerElem$ = 20					; size = 4
_name$ = 24						; size = 4
_message$ = 28						; size = 4
_xmlSchemaPMissingAttrErr PROC				; COMDAT

; 2799 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ownerElem$[ebp]
	lea	eax, DWORD PTR _des$[ebp]
	push	esi
	push	DWORD PTR _ownerItem$[ebp]
	mov	DWORD PTR _des$[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport
	mov	eax, DWORD PTR _message$[ebp]
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN2@xmlSchemaP

; 2800 :     xmlChar *des = NULL;
; 2801 : 
; 2802 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);
; 2803 : 
; 2804 :     if (message != NULL)
; 2805 : 	xmlSchemaPErr(ctxt, ownerElem, error, "%s: %s.\n", BAD_CAST des, BAD_CAST message);

	push	eax
	push	DWORD PTR _des$[ebp]
	push	OFFSET ??_C@_08EAGHGJIC@?$CFs?3?5?$CFs?4?6@
	jmp	SHORT $LN6@xmlSchemaP
$LN2@xmlSchemaP:

; 2806 :     else
; 2807 : 	xmlSchemaPErr(ctxt, ownerElem, error,

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _des$[ebp]
	push	OFFSET ??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@
$LN6@xmlSchemaP:

; 2808 : 	    "%s: The attribute '%s' is required but missing.\n",
; 2809 : 	    BAD_CAST des, BAD_CAST name);
; 2810 :     FREE_AND_NULL(des);

	push	DWORD PTR _error$[ebp]
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPErr
	mov	eax, DWORD PTR _des$[ebp]
	add	esp, 24					; 00000018H
	pop	esi
	test	eax, eax
	je	SHORT $LN4@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlSchemaP:

; 2811 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaPMissingAttrErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFacetErr
_TEXT	SEGMENT
_actLen$1 = -64						; size = 25
_len$2 = -36						; size = 25
_str$ = -8						; size = 4
_msg$ = -4						; size = 4
_actxt$ = 8						; size = 4
_error$ = 12						; size = 4
_nodeType$1$ = 16					; size = 4
_node$ = 16						; size = 4
_value$ = 20						; size = 4
_length$ = 24						; size = 4
_type$ = 28						; size = 4
_facet$ = 32						; size = 4
_message$ = 36						; size = 4
_str1$ = 40						; size = 4
_str2$ = 44						; size = 4
_xmlSchemaFacetErr PROC					; COMDAT

; 2657 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4

; 2423 :     if (node != NULL)

	mov	ebx, DWORD PTR _node$[ebp]
	mov	edi, DWORD PTR _actxt$[ebp]

; 2658 :     xmlChar *str = NULL, *msg = NULL;

	mov	DWORD PTR _str$[ebp], 0
	mov	DWORD PTR _msg$[ebp], 0

; 2423 :     if (node != NULL)

	test	ebx, ebx
	je	SHORT $LN39@xmlSchemaF

; 2424 : 	return (node->type);

	mov	esi, DWORD PTR [ebx+4]
	mov	DWORD PTR _nodeType$1$[ebp], esi
	jmp	SHORT $LN38@xmlSchemaF
$LN39@xmlSchemaF:

; 2425 :     if ((actxt->type == XML_SCHEMA_CTXT_VALIDATOR) &&

	cmp	DWORD PTR [edi], 2
	jne	SHORT $LN40@xmlSchemaF
	mov	esi, DWORD PTR [edi+108]
	test	esi, esi
	je	SHORT $LN40@xmlSchemaF

; 2426 : 	(((xmlSchemaValidCtxtPtr) actxt)->inode != NULL))
; 2427 : 	return ( ((xmlSchemaValidCtxtPtr) actxt)->inode->nodeType);

	mov	esi, DWORD PTR [esi]
	mov	DWORD PTR _nodeType$1$[ebp], esi
	jmp	SHORT $LN38@xmlSchemaF
$LN40@xmlSchemaF:

; 2428 :     return (-1);

	mov	DWORD PTR _nodeType$1$[ebp], -1
$LN38@xmlSchemaF:

; 2659 :     xmlSchemaTypeType facetType;
; 2660 :     int nodeType = xmlSchemaEvalErrorNodeType(actxt, node);
; 2661 : 
; 2662 :     xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	ebx
	lea	eax, DWORD PTR _msg$[ebp]
	push	edi
	push	eax
	call	_xmlSchemaFormatNodeForError
	add	esp, 12					; 0000000cH

; 2663 :     if (error == XML_SCHEMAV_CVC_ENUMERATION_VALID) {

	cmp	DWORD PTR _error$[ebp], 1840		; 00000730H
	jne	SHORT $LN2@xmlSchemaF

; 2664 : 	facetType = XML_SCHEMA_FACET_ENUMERATION;

	mov	esi, 1007				; 000003efH

; 2665 : 	/*
; 2666 : 	* If enumerations are validated, one must not expect the
; 2667 : 	* facet to be given.
; 2668 : 	*/
; 2669 :     } else

	jmp	SHORT $LN3@xmlSchemaF
$LN2@xmlSchemaF:

; 2670 : 	facetType = facet->type;

	mov	eax, DWORD PTR _facet$[ebp]
	mov	esi, DWORD PTR [eax]
$LN3@xmlSchemaF:

; 2671 :     msg = xmlStrcat(msg, BAD_CAST "[");

	push	OFFSET ??_C@_01OHGJGJJP@?$FL@
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat

; 2672 :     msg = xmlStrcat(msg, BAD_CAST "facet '");

	push	OFFSET ??_C@_07HIPPIIHM@facet?5?8@
	push	eax
	mov	DWORD PTR _msg$[ebp], eax
	call	_xmlStrcat

; 2673 :     msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facetType));

	push	esi
	mov	DWORD PTR _msg$[ebp], eax
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat

; 2674 :     msg = xmlStrcat(msg, BAD_CAST "'] ");

	push	OFFSET ??_C@_03BCLOCOCF@?8?$FN?5@
	push	eax
	mov	DWORD PTR _msg$[ebp], eax
	call	_xmlStrcat

; 2675 :     if (message == NULL) {

	mov	ecx, DWORD PTR _message$[ebp]
	add	esp, 36					; 00000024H
	mov	DWORD PTR _msg$[ebp], eax
	test	ecx, ecx
	jne	$LN4@xmlSchemaF

; 2676 : 	/*
; 2677 : 	* Use a default message.
; 2678 : 	*/
; 2679 : 	if ((facetType == XML_SCHEMA_FACET_LENGTH) ||
; 2680 : 	    (facetType == XML_SCHEMA_FACET_MINLENGTH) ||

	cmp	esi, 1009				; 000003f1H
	je	$LN8@xmlSchemaF
	cmp	esi, 1011				; 000003f3H
	je	$LN8@xmlSchemaF
	cmp	esi, 1010				; 000003f2H
	je	$LN8@xmlSchemaF

; 2707 : 		xmlSchemaErr3(actxt, error, node, (const char *) msg,
; 2708 : 		    value, (const xmlChar *) actLen, (const xmlChar *) len);
; 2709 : 	    else
; 2710 : 		xmlSchemaErr(actxt, error, node, (const char *) msg,
; 2711 : 		    (const xmlChar *) actLen, (const xmlChar *) len);
; 2712 : 
; 2713 : 	} else if (facetType == XML_SCHEMA_FACET_ENUMERATION) {

	cmp	esi, 1007				; 000003efH
	jne	SHORT $LN18@xmlSchemaF

; 2714 : 	    msg = xmlStrcat(msg, BAD_CAST "The value '%s' is not an element "

	push	OFFSET ??_C@_0DD@DOBLIGCG@The?5value?5?8?$CFs?8?5is?5not?5an?5elemen@
	push	eax
	call	_xmlStrcat

; 2715 : 		"of the set {%s}.\n");
; 2716 : 	    xmlSchemaErr(actxt, error, node, (const char *) msg, value,

	push	DWORD PTR _type$[ebp]
	mov	DWORD PTR _msg$[ebp], eax
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	push	edi
	call	_xmlSchemaFormatFacetEnumSet
	push	eax
	push	DWORD PTR _value$[ebp]
	mov	eax, DWORD PTR _error$[ebp]
	push	DWORD PTR _msg$[ebp]
	push	ebx
	push	eax
	push	edi
	call	_xmlSchemaErr

; 2763 : 	xmlSchemaErr(actxt, error, node, (const char *) msg, str1, str2);
; 2764 :     }
; 2765 :     FREE_AND_NULL(str)

	mov	eax, DWORD PTR _str$[ebp]
	add	esp, 44					; 0000002cH
	test	eax, eax
	je	$LN36@xmlSchemaF
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2766 :     xmlFree(msg);

	push	DWORD PTR _msg$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2767 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlSchemaF:

; 2717 : 		xmlSchemaFormatFacetEnumSet(actxt, &str, type));
; 2718 : 	} else if (facetType == XML_SCHEMA_FACET_PATTERN) {

	cmp	esi, 1006				; 000003eeH
	jne	SHORT $LN20@xmlSchemaF

; 2719 : 	    msg = xmlStrcat(msg, BAD_CAST "The value '%s' is not accepted "

	push	OFFSET ??_C@_0DF@NEKJCLEF@The?5value?5?8?$CFs?8?5is?5not?5accepted?5@
$LN58@xmlSchemaF:

; 2766 :     xmlFree(msg);

	push	eax
	call	_xmlStrcat
	mov	ecx, DWORD PTR _facet$[ebp]
	push	DWORD PTR [ecx+8]
$LN57@xmlSchemaF:
	push	DWORD PTR _value$[ebp]
$LN59@xmlSchemaF:
	push	eax
	mov	DWORD PTR _msg$[ebp], eax
	mov	eax, DWORD PTR _error$[ebp]
	push	ebx
	push	eax
	push	edi
	call	_xmlSchemaErr
	add	esp, 32					; 00000020H
	push	DWORD PTR _msg$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2767 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlSchemaF:

; 2720 : 		"by the pattern '%s'.\n");
; 2721 : 	    xmlSchemaErr(actxt, error, node, (const char *) msg, value,
; 2722 : 		facet->value);
; 2723 : 	} else if (facetType == XML_SCHEMA_FACET_MININCLUSIVE) {

	cmp	esi, 1000				; 000003e8H
	jne	SHORT $LN22@xmlSchemaF

; 2724 : 	    msg = xmlStrcat(msg, BAD_CAST "The value '%s' is less than the "

	push	OFFSET ??_C@_0DP@JKCFEDLM@The?5value?5?8?$CFs?8?5is?5less?5than?5the@

; 2725 : 		"minimum value allowed ('%s').\n");
; 2726 : 	    xmlSchemaErr(actxt, error, node, (const char *) msg, value,

	jmp	SHORT $LN58@xmlSchemaF
$LN22@xmlSchemaF:

; 2727 : 		facet->value);
; 2728 : 	} else if (facetType == XML_SCHEMA_FACET_MAXINCLUSIVE) {

	cmp	esi, 1002				; 000003eaH
	jne	SHORT $LN24@xmlSchemaF

; 2729 : 	    msg = xmlStrcat(msg, BAD_CAST "The value '%s' is greater than the "

	push	OFFSET ??_C@_0EC@ODIEFLC@The?5value?5?8?$CFs?8?5is?5greater?5than?5@

; 2730 : 		"maximum value allowed ('%s').\n");
; 2731 : 	    xmlSchemaErr(actxt, error, node, (const char *) msg, value,

	jmp	SHORT $LN58@xmlSchemaF
$LN24@xmlSchemaF:

; 2732 : 		facet->value);
; 2733 : 	} else if (facetType == XML_SCHEMA_FACET_MINEXCLUSIVE) {

	cmp	esi, 1001				; 000003e9H
	jne	SHORT $LN26@xmlSchemaF

; 2734 : 	    msg = xmlStrcat(msg, BAD_CAST "The value '%s' must be greater than "

	push	OFFSET ??_C@_0CL@CEDGHCDN@The?5value?5?8?$CFs?8?5must?5be?5greater?5@

; 2735 : 		"'%s'.\n");
; 2736 : 	    xmlSchemaErr(actxt, error, node, (const char *) msg, value,

	jmp	SHORT $LN58@xmlSchemaF
$LN26@xmlSchemaF:

; 2737 : 		facet->value);
; 2738 : 	} else if (facetType == XML_SCHEMA_FACET_MAXEXCLUSIVE) {

	cmp	esi, 1003				; 000003ebH
	jne	SHORT $LN28@xmlSchemaF

; 2739 : 	    msg = xmlStrcat(msg, BAD_CAST "The value '%s' must be less than "

	push	OFFSET ??_C@_0CI@DMBEGLJK@The?5value?5?8?$CFs?8?5must?5be?5less?5tha@

; 2740 : 		"'%s'.\n");
; 2741 : 	    xmlSchemaErr(actxt, error, node, (const char *) msg, value,

	jmp	SHORT $LN58@xmlSchemaF
$LN28@xmlSchemaF:

; 2742 : 		facet->value);
; 2743 : 	} else if (facetType == XML_SCHEMA_FACET_TOTALDIGITS) {

	cmp	esi, 1004				; 000003ecH
	jne	SHORT $LN30@xmlSchemaF

; 2744 : 	    msg = xmlStrcat(msg, BAD_CAST "The value '%s' has more "

	push	OFFSET ??_C@_0DJ@CHBCAGLC@The?5value?5?8?$CFs?8?5has?5more?5digits?5@

; 2745 : 		"digits than are allowed ('%s').\n");
; 2746 : 	    xmlSchemaErr(actxt, error, node, (const char*) msg, value,

	jmp	SHORT $LN58@xmlSchemaF
$LN30@xmlSchemaF:

; 2747 : 		facet->value);
; 2748 : 	} else if (facetType == XML_SCHEMA_FACET_FRACTIONDIGITS) {

	cmp	esi, 1005				; 000003edH
	jne	SHORT $LN32@xmlSchemaF

; 2749 : 	    msg = xmlStrcat(msg, BAD_CAST "The value '%s' has more fractional "

	push	OFFSET ??_C@_0EE@PPGDNELD@The?5value?5?8?$CFs?8?5has?5more?5fractio@

; 2750 : 		"digits than are allowed ('%s').\n");
; 2751 : 	    xmlSchemaErr(actxt, error, node, (const char*) msg, value,

	jmp	$LN58@xmlSchemaF
$LN32@xmlSchemaF:

; 2752 : 		facet->value);
; 2753 : 	} else if (nodeType == XML_ATTRIBUTE_NODE) {

	cmp	DWORD PTR _nodeType$1$[ebp], 2
	jne	SHORT $LN34@xmlSchemaF

; 2754 : 	    msg = xmlStrcat(msg, BAD_CAST "The value '%s' is not facet-valid.\n");

	push	OFFSET ??_C@_0CE@HKFPHOBG@The?5value?5?8?$CFs?8?5is?5not?5facet?9val@
	push	eax
	call	_xmlStrcat

; 2755 : 	    xmlSchemaErr(actxt, error, node, (const char *) msg, value, NULL);

	push	0

; 2756 : 	} else {

	jmp	$LN57@xmlSchemaF
$LN34@xmlSchemaF:

; 2757 : 	    msg = xmlStrcat(msg, BAD_CAST "The value is not facet-valid.\n");

	push	OFFSET ??_C@_0BP@CKLMMNCB@The?5value?5is?5not?5facet?9valid?4?6@
	push	eax
	call	_xmlStrcat

; 2758 : 	    xmlSchemaErr(actxt, error, node, (const char *) msg, NULL, NULL);

	push	0
	push	0
	jmp	$LN59@xmlSchemaF
$LN8@xmlSchemaF:

; 2681 : 	    (facetType == XML_SCHEMA_FACET_MAXLENGTH)) {
; 2682 : 
; 2683 : 	    char len[25], actLen[25];
; 2684 : 
; 2685 : 	    /* FIXME, TODO: What is the max expected string length of the
; 2686 : 	    * this value?
; 2687 : 	    */
; 2688 : 	    if (nodeType == XML_ATTRIBUTE_NODE)

	cmp	DWORD PTR _nodeType$1$[ebp], 2
	jne	SHORT $LN9@xmlSchemaF

; 2689 : 		msg = xmlStrcat(msg, BAD_CAST "The value '%s' has a length of '%s'; ");

	push	OFFSET ??_C@_0CG@GNANNDNL@The?5value?5?8?$CFs?8?5has?5a?5length?5of?5@
	jmp	SHORT $LN53@xmlSchemaF
$LN9@xmlSchemaF:

; 2690 : 	    else
; 2691 : 		msg = xmlStrcat(msg, BAD_CAST "The value has a length of '%s'; ");

	push	OFFSET ??_C@_0CB@KPGCMBDK@The?5value?5has?5a?5length?5of?5?8?$CFs?8?$DL@
$LN53@xmlSchemaF:

; 2692 : 
; 2693 : 	    snprintf(len, 24, "%lu", xmlSchemaGetFacetValueAsULong(facet));

	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _msg$[ebp], eax
	push	DWORD PTR _facet$[ebp]
	call	_xmlSchemaGetFacetValueAsULong
	push	eax
	push	OFFSET ??_C@_03FKNCMABI@?$CFlu@
	lea	eax, DWORD PTR _len$2[ebp]
	push	24					; 00000018H
	push	eax
	call	_snprintf

; 2694 : 	    snprintf(actLen, 24, "%lu", length);

	push	DWORD PTR _length$[ebp]
	lea	eax, DWORD PTR _actLen$1[ebp]
	push	OFFSET ??_C@_03FKNCMABI@?$CFlu@
	push	24					; 00000018H
	push	eax
	call	_snprintf
	add	esp, 36					; 00000024H

; 2695 : 
; 2696 : 	    if (facetType == XML_SCHEMA_FACET_LENGTH)

	cmp	esi, 1009				; 000003f1H
	jne	SHORT $LN11@xmlSchemaF

; 2697 : 		msg = xmlStrcat(msg,

	push	OFFSET ??_C@_0CP@IEDJOHDN@this?5differs?5from?5the?5allowed?5l@
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _msg$[ebp], eax
	jmp	SHORT $LN15@xmlSchemaF
$LN11@xmlSchemaF:

; 2698 : 		BAD_CAST "this differs from the allowed length of '%s'.\n");
; 2699 : 	    else if (facetType == XML_SCHEMA_FACET_MAXLENGTH)

	cmp	esi, 1010				; 000003f2H
	jne	SHORT $LN13@xmlSchemaF

; 2700 : 		msg = xmlStrcat(msg,

	push	OFFSET ??_C@_0DC@OJNJPCCF@this?5exceeds?5the?5allowed?5maximu@
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _msg$[ebp], eax
	jmp	SHORT $LN15@xmlSchemaF
$LN13@xmlSchemaF:

; 2701 : 		BAD_CAST "this exceeds the allowed maximum length of '%s'.\n");
; 2702 : 	    else if (facetType == XML_SCHEMA_FACET_MINLENGTH)

	cmp	esi, 1011				; 000003f3H
	jne	SHORT $LN52@xmlSchemaF

; 2703 : 		msg = xmlStrcat(msg,

	push	OFFSET ??_C@_0DE@PEKKBPHG@this?5underruns?5the?5allowed?5mini@
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _msg$[ebp], eax
	jmp	SHORT $LN15@xmlSchemaF
$LN52@xmlSchemaF:

; 2701 : 		BAD_CAST "this exceeds the allowed maximum length of '%s'.\n");
; 2702 : 	    else if (facetType == XML_SCHEMA_FACET_MINLENGTH)

	mov	eax, DWORD PTR _msg$[ebp]
$LN15@xmlSchemaF:

; 2704 : 		BAD_CAST "this underruns the allowed minimum length of '%s'.\n");
; 2705 : 
; 2706 : 	    if (nodeType == XML_ATTRIBUTE_NODE)

	cmp	DWORD PTR _nodeType$1$[ebp], 2
	lea	ecx, DWORD PTR _len$2[ebp]
	push	0
	jne	SHORT $LN16@xmlSchemaF

; 2159 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	ecx
	lea	ecx, DWORD PTR _actLen$1[ebp]
	push	ecx
	push	DWORD PTR _value$[ebp]
$LN56@xmlSchemaF:

; 2766 :     xmlFree(msg);

	push	eax
	mov	eax, DWORD PTR _error$[ebp]
	push	0
	push	ebx
	push	eax
	push	2
	push	edi
	call	_xmlSchemaErr4Line
	add	esp, 40					; 00000028H
	push	DWORD PTR _msg$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2767 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlSchemaF:

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	ecx
	lea	ecx, DWORD PTR _actLen$1[ebp]
	push	ecx

; 2759 : 	}
; 2760 :     } else {

	jmp	SHORT $LN56@xmlSchemaF
$LN4@xmlSchemaF:

; 2761 : 	msg = xmlStrcat(msg, (const xmlChar *) message);

	push	ecx
	push	eax
	call	_xmlStrcat

; 2762 : 	msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	DWORD PTR _str2$[ebp]

; 2762 : 	msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	DWORD PTR _str1$[ebp]
	push	eax
	mov	eax, DWORD PTR _error$[ebp]
	push	0
	push	ebx
	push	eax
	push	2
	push	edi
	call	_xmlSchemaErr4Line
	add	esp, 56					; 00000038H
$LN36@xmlSchemaF:

; 2766 :     xmlFree(msg);

	push	DWORD PTR _msg$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2767 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaFacetErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaComplexTypeErr
_TEXT	SEGMENT
tv461 = -16						; size = 4
_i$1$ = -12						; size = 4
_msg$ = -8						; size = 4
_str$ = -4						; size = 4
_actxt$ = 8						; size = 4
_error$ = 12						; size = 4
_node$ = 16						; size = 4
_type$ = 20						; size = 4
_message$ = 24						; size = 4
_nbval$ = 28						; size = 4
_nbneg$ = 32						; size = 4
_values$ = 36						; size = 4
_xmlSchemaComplexTypeErr PROC				; COMDAT

; 2555 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _msg$[ebp]
	mov	DWORD PTR _str$[ebp], 0
	push	DWORD PTR _actxt$[ebp]
	mov	DWORD PTR _msg$[ebp], 0
	push	eax
	call	_xmlSchemaFormatNodeForError
	push	DWORD PTR _message$[ebp]
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat
	push	OFFSET ??_C@_01LFCBOECM@?4@
	push	eax
	mov	DWORD PTR _msg$[ebp], eax
	call	_xmlStrcat
	mov	ecx, DWORD PTR _nbneg$[ebp]
	add	esp, 28					; 0000001cH
	add	ecx, DWORD PTR _nbval$[ebp]
	mov	DWORD PTR _msg$[ebp], eax
	mov	DWORD PTR tv461[ebp], ecx
	test	ecx, ecx
	jle	$LN9@xmlSchemaC

; 2556 :     xmlChar *str = NULL, *msg = NULL;
; 2557 :     xmlChar *localName, *nsName;
; 2558 :     const xmlChar *cur, *end;
; 2559 :     int i;
; 2560 : 
; 2561 :     xmlSchemaFormatNodeForError(&msg, actxt, node);
; 2562 :     msg = xmlStrcat(msg, (const xmlChar *) message);
; 2563 :     msg = xmlStrcat(msg, BAD_CAST ".");
; 2564 :     /*
; 2565 :     * Note that is does not make sense to report that we have a
; 2566 :     * wildcard here, since the wildcard might be unfolded into
; 2567 :     * multiple transitions.
; 2568 :     */
; 2569 :     if (nbval + nbneg > 0) {
; 2570 : 	if (nbval + nbneg > 1) {
; 2571 : 	    str = xmlStrdup(BAD_CAST " Expected is one of ( ");
; 2572 : 	} else
; 2573 : 	    str = xmlStrdup(BAD_CAST " Expected is ( ");
; 2574 : 	nsName = NULL;
; 2575 : 
; 2576 : 	for (i = 0; i < nbval + nbneg; i++) {

	push	ebx
	cmp	ecx, 1
	mov	edx, OFFSET ??_C@_0BH@JGKEPFCF@?5Expected?5is?5one?5of?5?$CI?5@
	push	esi
	mov	eax, OFFSET ??_C@_0BA@HCJBOGK@?5Expected?5is?5?$CI?5@
	cmovg	eax, edx
	push	edi
	push	eax
	call	_xmlStrdup
	mov	edx, DWORD PTR _values$[ebp]
	add	esp, 4
	mov	ecx, eax
	xor	edi, edi
	mov	eax, DWORD PTR tv461[ebp]
	mov	DWORD PTR _str$[ebp], ecx
	mov	DWORD PTR _i$1$[ebp], edi
	npad	7
$LL4@xmlSchemaC:

; 2577 : 	    cur = values[i];

	mov	edi, DWORD PTR [edx+edi*4]

; 2578 : 	    if (cur == NULL)

	test	edi, edi
	je	$LN49@xmlSchemaC

; 2579 : 	        continue;
; 2580 : 	    if ((cur[0] == 'n') && (cur[1] == 'o') && (cur[2] == 't') &&

	mov	dl, BYTE PTR [edi]
	mov	al, dl
	cmp	dl, 110					; 0000006eH
	jne	SHORT $LN14@xmlSchemaC
	cmp	BYTE PTR [edi+1], 111			; 0000006fH
	jne	SHORT $LN14@xmlSchemaC
	cmp	BYTE PTR [edi+2], 116			; 00000074H
	jne	SHORT $LN14@xmlSchemaC
	cmp	BYTE PTR [edi+3], 32			; 00000020H
	jne	SHORT $LN14@xmlSchemaC

; 2581 : 	        (cur[3] == ' ')) {
; 2582 : 		cur += 4;
; 2583 : 		str = xmlStrcat(str, BAD_CAST "##other");

	push	OFFSET ??_C@_07ELAGFAPB@?$CD?$CDother@
	push	ecx
	add	edi, 4
	call	_xmlStrcat
	mov	DWORD PTR _str$[ebp], eax
	add	esp, 8
	mov	al, BYTE PTR [edi]
$LN14@xmlSchemaC:

; 2584 : 	    }
; 2585 : 	    /*
; 2586 : 	    * Get the local name.
; 2587 : 	    */
; 2588 : 	    localName = NULL;
; 2589 : 
; 2590 : 	    end = cur;

	mov	esi, edi

; 2591 : 	    if (*end == '*') {

	cmp	al, 42					; 0000002aH
	jne	SHORT $LN36@xmlSchemaC

; 2592 : 		localName = xmlStrdup(BAD_CAST "*");

	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	call	_xmlStrdup
	add	esp, 4

; 2593 : 		end++;

	lea	esi, DWORD PTR [edi+1]

; 2594 : 	    } else {

	jmp	SHORT $LN51@xmlSchemaC
$LN36@xmlSchemaC:

; 2595 : 		while ((*end != 0) && (*end != '|'))

	test	al, al
	je	SHORT $LN48@xmlSchemaC
$LL5@xmlSchemaC:
	cmp	al, 124					; 0000007cH
	je	SHORT $LN48@xmlSchemaC
	mov	al, BYTE PTR [esi+1]

; 2596 : 		    end++;

	inc	esi
	test	al, al
	jne	SHORT $LL5@xmlSchemaC
$LN48@xmlSchemaC:

; 2597 : 		localName = xmlStrncat(localName, BAD_CAST cur, end - cur);

	mov	eax, esi
	sub	eax, edi
	push	eax
	push	edi
	push	0
	call	_xmlStrncat
	add	esp, 12					; 0000000cH
$LN51@xmlSchemaC:

; 2598 : 	    }
; 2599 : 	    if (*end != 0) {

	cmp	BYTE PTR [esi], 0
	mov	ebx, eax
	je	$LN47@xmlSchemaC

; 2600 : 		end++;

	inc	esi

; 2601 : 		/*
; 2602 : 		* Skip "*|*" if they come with negated expressions, since
; 2603 : 		* they represent the same negated wildcard.
; 2604 : 		*/
; 2605 : 		if ((nbneg == 0) || (*end != '*') || (*localName != '*')) {

	cmp	DWORD PTR _nbneg$[ebp], 0
	je	SHORT $LN20@xmlSchemaC
	cmp	BYTE PTR [esi], 42			; 0000002aH
	jne	SHORT $LN20@xmlSchemaC
	cmp	BYTE PTR [ebx], 42			; 0000002aH
	jne	SHORT $LN20@xmlSchemaC

; 2626 : 		} else {
; 2627 : 		    FREE_AND_NULL(localName);

	push	ebx
	call	DWORD PTR _xmlFree

; 2628 : 		    continue;

	mov	ecx, DWORD PTR _str$[ebp]
	add	esp, 4
	mov	edi, DWORD PTR _i$1$[ebp]
$LN50@xmlSchemaC:

; 2556 :     xmlChar *str = NULL, *msg = NULL;
; 2557 :     xmlChar *localName, *nsName;
; 2558 :     const xmlChar *cur, *end;
; 2559 :     int i;
; 2560 : 
; 2561 :     xmlSchemaFormatNodeForError(&msg, actxt, node);
; 2562 :     msg = xmlStrcat(msg, (const xmlChar *) message);
; 2563 :     msg = xmlStrcat(msg, BAD_CAST ".");
; 2564 :     /*
; 2565 :     * Note that is does not make sense to report that we have a
; 2566 :     * wildcard here, since the wildcard might be unfolded into
; 2567 :     * multiple transitions.
; 2568 :     */
; 2569 :     if (nbval + nbneg > 0) {
; 2570 : 	if (nbval + nbneg > 1) {
; 2571 : 	    str = xmlStrdup(BAD_CAST " Expected is one of ( ");
; 2572 : 	} else
; 2573 : 	    str = xmlStrdup(BAD_CAST " Expected is ( ");
; 2574 : 	nsName = NULL;
; 2575 : 
; 2576 : 	for (i = 0; i < nbval + nbneg; i++) {

	mov	eax, DWORD PTR tv461[ebp]
	mov	edx, DWORD PTR _values$[ebp]
$LN2@xmlSchemaC:
	inc	edi
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	edi, eax
	jl	$LL4@xmlSchemaC

; 2636 : 	}
; 2637 : 	str = xmlStrcat(str, BAD_CAST " ).\n");

	push	OFFSET ??_C@_04ONBKEEDC@?5?$CJ?4?6@
	push	ecx
	call	_xmlStrcat
	mov	DWORD PTR _str$[ebp], eax

; 2638 : 	msg = xmlStrcat(msg, xmlEscapeFormatString(&str));

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlEscapeFormatString
	push	eax
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat

; 2639 : 	FREE_AND_NULL(str)

	mov	ecx, DWORD PTR _str$[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR _msg$[ebp], eax
	pop	edi
	pop	esi
	pop	ebx
	test	ecx, ecx
	je	$LN10@xmlSchemaC
	push	ecx
	call	DWORD PTR _xmlFree

; 2640 :     } else

	mov	eax, DWORD PTR _msg$[ebp]
	add	esp, 4
	mov	DWORD PTR _str$[ebp], 0
	jmp	$LN10@xmlSchemaC
$LN20@xmlSchemaC:

; 2606 : 		    /*
; 2607 : 		    * Get the namespace name.
; 2608 : 		    */
; 2609 : 		    cur = end;
; 2610 : 		    if (*end == '*') {

	mov	al, BYTE PTR [esi]
	mov	edi, esi
	cmp	al, 42					; 0000002aH
	jne	SHORT $LN37@xmlSchemaC

; 2611 : 			nsName = xmlStrdup(BAD_CAST "{*}");

	push	OFFSET ??_C@_03MNMOMDPD@?$HL?$CK?$HN@
	call	_xmlStrdup
	add	esp, 4

; 2612 : 		    } else {

	jmp	SHORT $LN52@xmlSchemaC
$LN37@xmlSchemaC:

; 2613 : 			while (*end != 0)

	test	al, al
	je	SHORT $LN8@xmlSchemaC
	npad	6
$LL7@xmlSchemaC:

; 2614 : 			    end++;

	inc	esi
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LL7@xmlSchemaC
$LN8@xmlSchemaC:

; 2615 : 
; 2616 : 			if (i >= nbval)
; 2617 : 			    nsName = xmlStrdup(BAD_CAST "{##other:");
; 2618 : 			else
; 2619 : 			    nsName = xmlStrdup(BAD_CAST "{");
; 2620 : 
; 2621 : 			nsName = xmlStrncat(nsName, BAD_CAST cur, end - cur);

	mov	ecx, DWORD PTR _nbval$[ebp]
	mov	eax, OFFSET ??_C@_01HCONENDN@?$HL@
	cmp	DWORD PTR _i$1$[ebp], ecx
	mov	ecx, OFFSET ??_C@_09OEHCBIBE@?$HL?$CD?$CDother?3@
	cmovge	eax, ecx
	push	eax
	call	_xmlStrdup
	sub	esi, edi
	push	esi
	push	edi
	push	eax
	call	_xmlStrncat

; 2622 : 			nsName = xmlStrcat(nsName, BAD_CAST "}");

	push	OFFSET ??_C@_01CELHOKLL@?$HN@
	push	eax
	call	_xmlStrcat
	add	esp, 24					; 00000018H
$LN52@xmlSchemaC:

; 2623 : 		    }
; 2624 : 		    str = xmlStrcat(str, BAD_CAST nsName);

	mov	esi, eax
	push	esi
	push	DWORD PTR _str$[ebp]
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _str$[ebp], eax

; 2625 : 		    FREE_AND_NULL(nsName)

	test	esi, esi
	je	SHORT $LN47@xmlSchemaC
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN47@xmlSchemaC:

; 2629 : 		}
; 2630 : 	    }
; 2631 : 	    str = xmlStrcat(str, BAD_CAST localName);

	push	ebx
	push	DWORD PTR _str$[ebp]
	call	_xmlStrcat
	add	esp, 8
	mov	ecx, eax
	mov	DWORD PTR _str$[ebp], ecx

; 2632 : 	    FREE_AND_NULL(localName);

	test	ebx, ebx
	je	SHORT $LN27@xmlSchemaC
	push	ebx
	call	DWORD PTR _xmlFree
	mov	ecx, DWORD PTR _str$[ebp]
	add	esp, 4
$LN27@xmlSchemaC:

; 2633 : 
; 2634 : 	    if (i < nbval + nbneg -1)

	mov	eax, DWORD PTR _nbneg$[ebp]
	mov	edi, DWORD PTR _i$1$[ebp]
	dec	eax
	add	eax, DWORD PTR _nbval$[ebp]
	cmp	edi, eax
	jge	$LN50@xmlSchemaC

; 2635 : 		str = xmlStrcat(str, BAD_CAST ", ");

	push	OFFSET ??_C@_02KEGNLNML@?0?5@
	push	ecx
	call	_xmlStrcat
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR _str$[ebp], ecx
	jmp	$LN50@xmlSchemaC
$LN49@xmlSchemaC:

; 2578 : 	    if (cur == NULL)

	mov	edi, DWORD PTR _i$1$[ebp]
	jmp	$LN2@xmlSchemaC
$LN9@xmlSchemaC:

; 2641 :       msg = xmlStrcat(msg, BAD_CAST "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _msg$[ebp], eax
$LN10@xmlSchemaC:

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _error$[ebp]
	push	2
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaErr4Line

; 2642 :     xmlSchemaErr(actxt, error, node, (const char *) msg, NULL, NULL);
; 2643 :     xmlFree(msg);

	push	DWORD PTR _msg$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 44					; 0000002cH

; 2644 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaComplexTypeErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIllegalAttrErr
_TEXT	SEGMENT
_str$ = -8						; size = 4
_msg$ = -4						; size = 4
_actxt$ = 8						; size = 4
_error$ = 12						; size = 4
_ni$ = 16						; size = 4
_node$ = 20						; size = 4
_xmlSchemaIllegalAttrErr PROC				; COMDAT

; 2534 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _msg$[ebp]
	push	edi
	push	DWORD PTR _actxt$[ebp]
	xor	esi, esi
	mov	DWORD PTR _msg$[ebp], 0
	push	eax
	mov	DWORD PTR _str$[ebp], esi
	call	_xmlSchemaFormatNodeForError
	push	OFFSET ??_C@_0CE@FELNOPMA@The?5attribute?5?8?$CFs?8?5is?5not?5allow@
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat
	add	esp, 20					; 00000014H
	mov	DWORD PTR _msg$[ebp], eax

; 2519 :     if (node != NULL) {

	test	edi, edi
	je	SHORT $LN6@xmlSchemaI

; 2520 : 	if (node->ns != NULL)

	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN8@xmlSchemaI

; 2521 : 	    return (xmlSchemaFormatQName(str, node->ns->href, node->name));

	push	eax
	push	DWORD PTR [ecx+8]
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaFormatQName
	mov	esi, DWORD PTR _str$[ebp]
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@xmlSchemaI
$LN8@xmlSchemaI:

; 1310 :     if (localName != NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlSchemaI

; 1311 : 	if (namespaceName == NULL)
; 1312 : 	    return(localName);
; 1313 : 	*buf = xmlStrcat(*buf, localName);
; 1314 :     } else {
; 1315 : 	*buf = xmlStrcat(*buf, BAD_CAST "(NULL)");

	push	OFFSET ??_C@_06LHGEHABH@?$CINULL?$CJ@
	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	esi, eax

; 2523 : 	    return (xmlSchemaFormatQName(str, NULL, node->name));

	jmp	SHORT $LN5@xmlSchemaI
$LN6@xmlSchemaI:

; 2524 :     } else if (ni != NULL)

	mov	eax, DWORD PTR _ni$[ebp]
	test	eax, eax
	je	SHORT $LN10@xmlSchemaI

; 2525 : 	return (xmlSchemaFormatQName(str, ni->nsName, ni->localName));

	push	DWORD PTR [eax+12]
	push	DWORD PTR [eax+16]
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaFormatQName
	mov	esi, DWORD PTR _str$[ebp]
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@xmlSchemaI
$LN10@xmlSchemaI:

; 2526 :     return (NULL);

	xor	eax, eax
$LN5@xmlSchemaI:

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	edi
	push	DWORD PTR _error$[ebp]
	push	2
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaErr4Line
	add	esp, 40					; 00000028H

; 2535 :     xmlChar *msg = NULL, *str = NULL;
; 2536 : 
; 2537 :     xmlSchemaFormatNodeForError(&msg, actxt, node);
; 2538 :     msg = xmlStrcat(msg, BAD_CAST "The attribute '%s' is not allowed.\n");
; 2539 :     xmlSchemaErr(actxt, error, node, (const char *) msg,
; 2540 : 	xmlSchemaFormatErrorNodeQName(&str, (xmlSchemaNodeInfoPtr) ni, node),
; 2541 : 	NULL);
; 2542 :     FREE_AND_NULL(str)

	test	esi, esi
	je	SHORT $LN2@xmlSchemaI
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlSchemaI:

; 2543 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$[ebp]
	pop	edi
	pop	esi
	test	eax, eax
	je	SHORT $LN3@xmlSchemaI
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlSchemaI:

; 2544 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaIllegalAttrErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFormatErrorNodeQName
_TEXT	SEGMENT
_str$ = 8						; size = 4
_ni$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaFormatErrorNodeQName PROC			; COMDAT

; 2518 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	SHORT $LN2@xmlSchemaF

; 2519 :     if (node != NULL) {
; 2520 : 	if (node->ns != NULL)

	mov	eax, DWORD PTR [esi+36]
	mov	esi, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaF

; 2521 : 	    return (xmlSchemaFormatQName(str, node->ns->href, node->name));

	push	esi
	push	DWORD PTR [eax+8]
	push	DWORD PTR _str$[ebp]
	call	_xmlSchemaFormatQName
	add	esp, 12					; 0000000cH
	pop	esi

; 2527 : }

	pop	ebp
	ret	0
$LN4@xmlSchemaF:
	push	edi

; 1304 :     FREE_AND_NULL(*buf)

	mov	edi, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN9@xmlSchemaF
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	DWORD PTR [edi], 0
	xor	eax, eax
$LN9@xmlSchemaF:

; 1305 :     if (namespaceName != NULL) {
; 1306 : 	*buf = xmlStrdup(BAD_CAST "{");
; 1307 : 	*buf = xmlStrcat(*buf, namespaceName);
; 1308 : 	*buf = xmlStrcat(*buf, BAD_CAST "}");
; 1309 :     }
; 1310 :     if (localName != NULL) {

	test	esi, esi
	jne	SHORT $LN8@xmlSchemaF

; 1311 : 	if (namespaceName == NULL)
; 1312 : 	    return(localName);
; 1313 : 	*buf = xmlStrcat(*buf, localName);
; 1314 :     } else {
; 1315 : 	*buf = xmlStrcat(*buf, BAD_CAST "(NULL)");

	push	OFFSET ??_C@_06LHGEHABH@?$CINULL?$CJ@
	push	eax
	call	_xmlStrcat
	mov	esi, eax
	add	esp, 8
	mov	DWORD PTR [edi], esi
$LN8@xmlSchemaF:

; 2522 : 	else
; 2523 : 	    return (xmlSchemaFormatQName(str, NULL, node->name));

	pop	edi
	mov	eax, esi
	pop	esi

; 2527 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaF:

; 2524 :     } else if (ni != NULL)

	mov	eax, DWORD PTR _ni$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlSchemaF

; 2525 : 	return (xmlSchemaFormatQName(str, ni->nsName, ni->localName));

	push	DWORD PTR [eax+12]
	push	DWORD PTR [eax+16]
	push	DWORD PTR _str$[ebp]
	call	_xmlSchemaFormatQName
	add	esp, 12					; 0000000cH
	pop	esi

; 2527 : }

	pop	ebp
	ret	0
$LN6@xmlSchemaF:

; 2526 :     return (NULL);

	xor	eax, eax
	pop	esi

; 2527 : }

	pop	ebp
	ret	0
_xmlSchemaFormatErrorNodeQName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSimpleTypeErr
_TEXT	SEGMENT
_msg$ = -4						; size = 4
_actxt$ = 8						; size = 4
_error$ = 12						; size = 4
_node$ = 16						; size = 4
_value$ = 20						; size = 4
_str$1 = 24						; size = 4
_type$ = 24						; size = 4
_displayValue$ = 28					; size = 4
_xmlSchemaSimpleTypeErr PROC				; COMDAT

; 2466 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _msg$[ebp]
	mov	edi, DWORD PTR _actxt$[ebp]
	push	esi
	push	edi
	push	eax
	mov	DWORD PTR _msg$[ebp], 0
	call	_xmlSchemaFormatNodeForError
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _displayValue$[ebp], 0
	jne	SHORT $LN4@xmlSchemaS

; 2423 :     if (node != NULL)

	test	esi, esi
	je	SHORT $LN23@xmlSchemaS

; 2424 : 	return (node->type);

	lea	eax, DWORD PTR [esi+4]
	jmp	SHORT $LN22@xmlSchemaS
$LN23@xmlSchemaS:

; 2425 :     if ((actxt->type == XML_SCHEMA_CTXT_VALIDATOR) &&

	cmp	DWORD PTR [edi], 2
	jne	SHORT $LN38@xmlSchemaS
	mov	eax, DWORD PTR [edi+108]
	test	eax, eax
	je	SHORT $LN38@xmlSchemaS
$LN22@xmlSchemaS:

; 2467 :     xmlChar *msg = NULL;
; 2468 : 
; 2469 :     xmlSchemaFormatNodeForError(&msg, actxt, node);
; 2470 : 
; 2471 :     if (displayValue || (xmlSchemaEvalErrorNodeType(actxt, node) ==

	cmp	DWORD PTR [eax], 2
	je	SHORT $LN4@xmlSchemaS
$LN38@xmlSchemaS:

; 2474 :     else
; 2475 : 	msg = xmlStrcat(msg, BAD_CAST "The character content is not a valid "

	push	OFFSET ??_C@_0CP@NNGHIIKI@The?5character?5content?5is?5not?5a?5@
	jmp	SHORT $LN41@xmlSchemaS
$LN4@xmlSchemaS:

; 2472 : 	    XML_ATTRIBUTE_NODE))
; 2473 : 	msg = xmlStrcat(msg, BAD_CAST "'%s' is not a valid value of ");

	push	OFFSET ??_C@_0BO@ONHLDAAN@?8?$CFs?8?5is?5not?5a?5valid?5value?5of?5@
$LN41@xmlSchemaS:

; 2476 : 	    "value of ");
; 2477 : 
; 2478 :     if (! xmlSchemaIsGlobalItem(type))

	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _msg$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _type$[ebp]
	push	ebx
	call	_xmlSchemaIsGlobalItem
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@xmlSchemaS

; 2479 : 	msg = xmlStrcat(msg, BAD_CAST "the local ");

	push	OFFSET ??_C@_0L@MLMEJNFI@the?5local?5@
	jmp	SHORT $LN42@xmlSchemaS
$LN5@xmlSchemaS:

; 2480 :     else
; 2481 : 	msg = xmlStrcat(msg, BAD_CAST "the ");

	push	OFFSET ??_C@_04BAIFLMGI@the?5@
$LN42@xmlSchemaS:

; 2482 : 
; 2483 :     if (WXS_IS_ATOMIC(type))

	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat
	mov	ecx, DWORD PTR [ebx+48]
	add	esp, 8
	mov	DWORD PTR _msg$[ebp], eax
	test	ecx, 256				; 00000100H
	je	SHORT $LN7@xmlSchemaS

; 2484 : 	msg = xmlStrcat(msg, BAD_CAST "atomic type");

	push	OFFSET ??_C@_0M@NAKOLHPN@atomic?5type@
	jmp	SHORT $LN43@xmlSchemaS
$LN7@xmlSchemaS:

; 2485 :     else if (WXS_IS_LIST(type))

	test	cl, 64					; 00000040H
	je	SHORT $LN9@xmlSchemaS

; 2486 : 	msg = xmlStrcat(msg, BAD_CAST "list type");

	push	OFFSET ??_C@_09EMCEHNFO@list?5type@
	jmp	SHORT $LN43@xmlSchemaS
$LN9@xmlSchemaS:

; 2487 :     else if (WXS_IS_UNION(type))

	test	cl, cl
	jns	SHORT $LN11@xmlSchemaS

; 2488 : 	msg = xmlStrcat(msg, BAD_CAST "union type");

	push	OFFSET ??_C@_0L@KHBDGNKM@union?5type@
$LN43@xmlSchemaS:

; 2489 : 
; 2490 :     if (xmlSchemaIsGlobalItem(type)) {

	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _msg$[ebp], eax
$LN11@xmlSchemaS:
	push	ebx
	call	_xmlSchemaIsGlobalItem
	add	esp, 4
	test	eax, eax
	je	$LN40@xmlSchemaS

; 2491 : 	xmlChar *str = NULL;
; 2492 : 	msg = xmlStrcat(msg, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	DWORD PTR _msg$[ebp]
	mov	DWORD PTR _str$1[ebp], 0
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _msg$[ebp], eax

; 2493 : 	if (type->builtInType != 0) {

	cmp	DWORD PTR [ebx+88], 0
	je	SHORT $LN13@xmlSchemaS

; 2494 : 	    msg = xmlStrcat(msg, BAD_CAST "xs:");

	push	OFFSET ??_C@_03DCOKAOA@xs?3@
	push	eax
	call	_xmlStrcat

; 2495 : 	    str = xmlStrdup(type->name);

	push	DWORD PTR [ebx+8]
	mov	DWORD PTR _msg$[ebp], eax
	call	_xmlStrdup
	add	esp, 12					; 0000000cH

; 2496 : 	} else {

	jmp	SHORT $LN44@xmlSchemaS
$LN13@xmlSchemaS:

; 2497 : 	    const xmlChar *qName = xmlSchemaFormatQName(&str, type->targetNamespace, type->name);

	push	DWORD PTR [ebx+8]
	lea	eax, DWORD PTR _str$1[ebp]
	push	DWORD PTR [ebx+112]
	push	eax
	call	_xmlSchemaFormatQName
	add	esp, 12					; 0000000cH

; 2498 : 	    if (!str)

	cmp	DWORD PTR _str$1[ebp], 0
	jne	SHORT $LN15@xmlSchemaS

; 2499 : 		str = xmlStrdup(qName);

	push	eax
	call	_xmlStrdup
	add	esp, 4
$LN44@xmlSchemaS:

; 2500 : 	}
; 2501 : 	msg = xmlStrcat(msg, xmlEscapeFormatString(&str));

	mov	DWORD PTR _str$1[ebp], eax
$LN15@xmlSchemaS:
	lea	eax, DWORD PTR _str$1[ebp]
	push	eax
	call	_xmlEscapeFormatString
	push	eax
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat

; 2502 : 	msg = xmlStrcat(msg, BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	eax
	mov	DWORD PTR _msg$[ebp], eax
	call	_xmlStrcat
	mov	DWORD PTR _msg$[ebp], eax
	add	esp, 20					; 00000014H

; 2503 : 	FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$1[ebp]
	test	eax, eax
	je	SHORT $LN40@xmlSchemaS
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN40@xmlSchemaS:

; 2504 :     }
; 2505 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _msg$[ebp], eax

; 2506 :     if (displayValue || (xmlSchemaEvalErrorNodeType(actxt, node) ==

	cmp	DWORD PTR _displayValue$[ebp], 0
	pop	ebx
	jne	SHORT $LN19@xmlSchemaS

; 2423 :     if (node != NULL)

	test	esi, esi
	je	SHORT $LN27@xmlSchemaS

; 2424 : 	return (node->type);

	lea	ecx, DWORD PTR [esi+4]
	jmp	SHORT $LN26@xmlSchemaS
$LN27@xmlSchemaS:

; 2425 :     if ((actxt->type == XML_SCHEMA_CTXT_VALIDATOR) &&

	cmp	DWORD PTR [edi], 2
	jne	SHORT $LN39@xmlSchemaS
	mov	ecx, DWORD PTR [edi+108]
	test	ecx, ecx
	je	SHORT $LN39@xmlSchemaS
$LN26@xmlSchemaS:

; 2506 :     if (displayValue || (xmlSchemaEvalErrorNodeType(actxt, node) ==

	cmp	DWORD PTR [ecx], 2
	je	SHORT $LN19@xmlSchemaS
$LN39@xmlSchemaS:

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	jmp	SHORT $LN45@xmlSchemaS
$LN19@xmlSchemaS:
	push	0
	push	0
	push	0
	push	DWORD PTR _value$[ebp]
$LN45@xmlSchemaS:

; 2507 : 	    XML_ATTRIBUTE_NODE))
; 2508 : 	xmlSchemaErr(actxt, error, node, (const char *) msg, value, NULL);
; 2509 :     else
; 2510 : 	xmlSchemaErr(actxt, error, node, (const char *) msg, NULL, NULL);
; 2511 :     FREE_AND_NULL(msg)

	push	eax
	push	0
	push	esi
	push	DWORD PTR _error$[ebp]
	push	2
	push	edi
	call	_xmlSchemaErr4Line
	mov	eax, DWORD PTR _msg$[ebp]
	add	esp, 40					; 00000028H
	pop	edi
	pop	esi
	test	eax, eax
	je	SHORT $LN20@xmlSchemaS
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN20@xmlSchemaS:

; 2512 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaSimpleTypeErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIsGlobalItem
_TEXT	SEGMENT
_item$ = 8						; size = 4
_xmlSchemaIsGlobalItem PROC				; COMDAT

; 2433 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [ecx]
	add	eax, -4					; fffffffcH
	cmp	eax, 13					; 0000000dH
	ja	SHORT $LN11@xmlSchemaI

; 2434 :     switch (item->type) {

	movzx	eax, BYTE PTR $LN13@xmlSchemaI[eax]
	jmp	DWORD PTR $LN16@xmlSchemaI[eax*4]
$LN4@xmlSchemaI:

; 2435 : 	case XML_SCHEMA_TYPE_COMPLEX:
; 2436 : 	case XML_SCHEMA_TYPE_SIMPLE:
; 2437 : 	    if (item->flags & XML_SCHEMAS_TYPE_GLOBAL)

	test	BYTE PTR [ecx+48], 8
$LN14@xmlSchemaI:

; 2449 : 		XML_SCHEMAS_ATTR_GLOBAL)
; 2450 : 		return(1);
; 2451 : 	    break;
; 2452 : 	/* Note that attribute groups are always global. */
; 2453 : 	default:
; 2454 : 	    return(1);

	je	SHORT $LN10@xmlSchemaI
$LN11@xmlSchemaI:
	mov	eax, 1

; 2457 : }

	pop	ebp
	ret	0
$LN7@xmlSchemaI:

; 2438 : 		return(1);
; 2439 : 	    break;
; 2440 : 	case XML_SCHEMA_TYPE_GROUP:
; 2441 : 	    return (1);
; 2442 : 	case XML_SCHEMA_TYPE_ELEMENT:
; 2443 : 	    if ( ((xmlSchemaElementPtr) item)->flags &

	test	BYTE PTR [ecx+48], 2
	jmp	SHORT $LN14@xmlSchemaI
$LN9@xmlSchemaI:

; 2444 : 		XML_SCHEMAS_ELEM_GLOBAL)
; 2445 : 		return(1);
; 2446 : 	    break;
; 2447 : 	case XML_SCHEMA_TYPE_ATTRIBUTE:
; 2448 : 	    if ( ((xmlSchemaAttributePtr) item)->flags &

	test	BYTE PTR [ecx+60], 1
	jne	SHORT $LN11@xmlSchemaI
$LN10@xmlSchemaI:

; 2455 :     }
; 2456 :     return (0);

	xor	eax, eax

; 2457 : }

	pop	ebp
	ret	0
	npad	3
$LN16@xmlSchemaI:
	DD	$LN4@xmlSchemaI
	DD	$LN7@xmlSchemaI
	DD	$LN9@xmlSchemaI
	DD	$LN11@xmlSchemaI
	DD	$LN11@xmlSchemaI
$LN13@xmlSchemaI:
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	3
_xmlSchemaIsGlobalItem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaEvalErrorNodeType
_TEXT	SEGMENT
_actxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlSchemaEvalErrorNodeType PROC			; COMDAT

; 2422 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _node$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlSchemaE

; 2423 :     if (node != NULL)
; 2424 : 	return (node->type);

	mov	eax, DWORD PTR [eax+4]

; 2429 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaE:

; 2425 :     if ((actxt->type == XML_SCHEMA_CTXT_VALIDATOR) &&

	mov	eax, DWORD PTR _actxt$[ebp]
	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN3@xmlSchemaE
	mov	eax, DWORD PTR [eax+108]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaE

; 2426 : 	(((xmlSchemaValidCtxtPtr) actxt)->inode != NULL))
; 2427 : 	return ( ((xmlSchemaValidCtxtPtr) actxt)->inode->nodeType);

	mov	eax, DWORD PTR [eax]

; 2429 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaE:

; 2428 :     return (-1);

	or	eax, -1

; 2429 : }

	pop	ebp
	ret	0
_xmlSchemaEvalErrorNodeType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaKeyrefErr
_TEXT	SEGMENT
_qname$ = -4						; size = 4
_vctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_idcNode$ = 16						; size = 4
_type$ = 20						; size = 4
_message$ = 24						; size = 4
_str1$ = 28						; size = 4
_str2$ = 32						; size = 4
_xmlSchemaKeyrefErr PROC				; COMDAT

; 2403 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	OFFSET ??_C@_0P@KFJAHJM@Element?5?8?$CFs?8?3?5@
	mov	DWORD PTR _qname$[ebp], 0
	call	_xmlStrdup
	push	DWORD PTR _message$[ebp]
	push	eax
	call	_xmlStrcat
	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	call	_xmlStrcat
	mov	edi, DWORD PTR _vctxt$[ebp]
	add	esp, 20					; 00000014H
	mov	esi, DWORD PTR _idcNode$[ebp]
	mov	ebx, eax
	lea	eax, DWORD PTR _qname$[ebp]
	mov	ecx, DWORD PTR [edi+180]
	mov	edx, DWORD PTR [esi+12]
	push	0
	push	DWORD PTR _str2$[ebp]
	mov	ecx, DWORD PTR [ecx]
	push	DWORD PTR _str1$[ebp]
	push	DWORD PTR [ecx+edx*4]
	push	DWORD PTR [ecx+edx*4+4]
	push	eax
	call	_xmlSchemaFormatQName
	add	esp, 12					; 0000000cH
	push	eax
	push	ebx
	push	DWORD PTR [esi+8]
	push	0
	push	DWORD PTR _error$[ebp]
	push	2
	push	edi
	call	_xmlSchemaErr4Line
	mov	eax, DWORD PTR _qname$[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN2@xmlSchemaK

; 2404 :     xmlChar *msg = NULL, *qname = NULL;
; 2405 : 
; 2406 :     msg = xmlStrdup(BAD_CAST "Element '%s': ");
; 2407 :     msg = xmlStrcat(msg, (const xmlChar *) message);
; 2408 :     msg = xmlStrcat(msg, BAD_CAST ".\n");
; 2409 :     xmlSchemaErr4Line(ACTXT_CAST vctxt, XML_ERR_ERROR,
; 2410 : 	error, NULL, idcNode->nodeLine, (const char *) msg,
; 2411 : 	xmlSchemaFormatQName(&qname,
; 2412 : 	    vctxt->nodeQNames->items[idcNode->nodeQNameID +1],
; 2413 : 	    vctxt->nodeQNames->items[idcNode->nodeQNameID]),
; 2414 : 	str1, str2, NULL);
; 2415 :     FREE_AND_NULL(qname);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlSchemaK:

; 2416 :     FREE_AND_NULL(msg);

	test	ebx, ebx
	je	SHORT $LN3@xmlSchemaK
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlSchemaK:

; 2417 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaKeyrefErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCustomWarning
_TEXT	SEGMENT
_msg$ = -4						; size = 4
_actxt$ = 8						; size = 4
_error$ = 12						; size = 4
_node$ = 16						; size = 4
_type$ = 20						; size = 4
_message$ = 24						; size = 4
_str1$ = 28						; size = 4
_str2$ = 32						; size = 4
_str3$ = 36						; size = 4
_xmlSchemaCustomWarning PROC				; COMDAT

; 2379 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _msg$[ebp]
	mov	DWORD PTR _msg$[ebp], 0
	push	DWORD PTR _actxt$[ebp]
	push	eax
	call	_xmlSchemaFormatNodeForError
	push	DWORD PTR _message$[ebp]
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat
	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$[ebp], eax
	call	_xmlStrcat
	push	0
	push	DWORD PTR _str3$[ebp]
	mov	DWORD PTR _msg$[ebp], eax
	push	DWORD PTR _str2$[ebp]
	push	DWORD PTR _str1$[ebp]
	push	eax
	push	0
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _error$[ebp]
	push	1
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaErr4Line
	mov	eax, DWORD PTR _msg$[ebp]
	add	esp, 68					; 00000044H
	test	eax, eax
	je	SHORT $LN2@xmlSchemaC

; 2380 :     xmlChar *msg = NULL;
; 2381 : 
; 2382 :     xmlSchemaFormatNodeForError(&msg, actxt, node);
; 2383 :     msg = xmlStrcat(msg, (const xmlChar *) message);
; 2384 :     msg = xmlStrcat(msg, BAD_CAST ".\n");
; 2385 : 
; 2386 :     /* URGENT TODO: Set the error code to something sane. */
; 2387 :     xmlSchemaErr4Line(actxt, XML_ERR_WARNING, error, node, 0,
; 2388 : 	(const char *) msg, str1, str2, str3, NULL);
; 2389 : 
; 2390 :     FREE_AND_NULL(msg)

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlSchemaC:

; 2391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCustomWarning ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCustomErr
_TEXT	SEGMENT
_actxt$ = 8						; size = 4
_error$ = 12						; size = 4
_node$ = 16						; size = 4
_item$ = 20						; size = 4
_message$ = 24						; size = 4
_str1$ = 28						; size = 4
_str2$ = 32						; size = 4
_xmlSchemaCustomErr PROC				; COMDAT

; 2363 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	0
	push	DWORD PTR _str2$[ebp]
	push	DWORD PTR _str1$[ebp]
	push	DWORD PTR _message$[ebp]
	push	DWORD PTR _item$[ebp]
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _error$[ebp]
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaCustomErr4
	add	esp, 36					; 00000024H

; 2364 :     xmlSchemaCustomErr4(actxt, error, node, item,
; 2365 : 	message, str1, str2, NULL, NULL);
; 2366 : }

	pop	ebp
	ret	0
_xmlSchemaCustomErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCustomErr4
_TEXT	SEGMENT
_msg$ = -4						; size = 4
_actxt$ = 8						; size = 4
_error$ = 12						; size = 4
_node$ = 16						; size = 4
_item$ = 20						; size = 4
_message$ = 24						; size = 4
_str1$ = 28						; size = 4
_str2$ = 32						; size = 4
_str3$ = 36						; size = 4
_str4$ = 40						; size = 4
_xmlSchemaCustomErr4 PROC				; COMDAT

; 2338 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	mov	ebx, DWORD PTR _actxt$[ebp]
	mov	DWORD PTR _msg$[ebp], 0
	test	esi, esi
	jne	SHORT $LN2@xmlSchemaC

; 2339 :     xmlChar *msg = NULL;
; 2340 : 
; 2341 :     if ((node == NULL) && (item != NULL) &&

	mov	edi, DWORD PTR _item$[ebp]
	test	edi, edi
	je	SHORT $LN2@xmlSchemaC
	cmp	DWORD PTR [ebx], 1
	jne	SHORT $LN2@xmlSchemaC

; 2342 : 	(actxt->type == XML_SCHEMA_CTXT_PARSER)) {
; 2343 : 	node = WXS_ITEM_NODE(item);

	push	edi
	call	_xmlSchemaGetComponentNode

; 2344 : 	xmlSchemaFormatItemForReport(&msg, NULL, item, NULL);

	push	0
	push	edi
	mov	esi, eax
	lea	eax, DWORD PTR _msg$[ebp]
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 2345 : 	msg = xmlStrcat(msg, BAD_CAST ": ");

	push	OFFSET ??_C@_02LMMGGCAJ@?3?5@
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrcat
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _msg$[ebp], eax

; 2346 :     } else

	jmp	SHORT $LN3@xmlSchemaC
$LN2@xmlSchemaC:

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	esi
	lea	eax, DWORD PTR _msg$[ebp]
	push	ebx
	push	eax
	call	_xmlSchemaFormatNodeForError
	mov	eax, DWORD PTR _msg$[ebp]
	add	esp, 12					; 0000000cH
$LN3@xmlSchemaC:

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	DWORD PTR _message$[ebp]
	push	eax
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	DWORD PTR _str4$[ebp]

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	DWORD PTR _str3$[ebp]
	push	DWORD PTR _str2$[ebp]
	push	DWORD PTR _str1$[ebp]
	push	eax
	push	0
	push	esi
	push	DWORD PTR _error$[ebp]
	push	2
	push	ebx
	call	_xmlSchemaErr4Line

; 2350 :     xmlSchemaErr4(actxt, error, node,
; 2351 : 	(const char *) msg, str1, str2, str3, str4);
; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 56					; 00000038H

; 2350 :     xmlSchemaErr4(actxt, error, node,
; 2351 : 	(const char *) msg, str1, str2, str3, str4);
; 2352 :     FREE_AND_NULL(msg)

	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN4@xmlSchemaC
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlSchemaC:

; 2353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCustomErr4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaInternalErr2
_TEXT	SEGMENT
_actxt$ = 8						; size = 4
_funcName$ = 12						; size = 4
_message$ = 16						; size = 4
_str1$ = 20						; size = 4
_str2$ = 24						; size = 4
_xmlSchemaInternalErr2 PROC				; COMDAT

; 2290 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _actxt$[ebp]
	test	edi, edi
	je	SHORT $LN6@xmlSchemaI

; 2291 :     xmlChar *msg = NULL;
; 2292 : 
; 2293 :     if (actxt == NULL)
; 2294 :         return;
; 2295 :     msg = xmlStrdup(BAD_CAST "Internal error: %s, ");

	push	esi
	push	OFFSET ??_C@_0BF@EFOKBLAL@Internal?5error?3?5?$CFs?0?5@
	call	_xmlStrdup

; 2296 :     msg = xmlStrcat(msg, BAD_CAST message);

	push	DWORD PTR _message$[ebp]
	push	eax
	call	_xmlStrcat

; 2297 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	call	_xmlStrcat
	mov	esi, eax
	add	esp, 20					; 00000014H

; 2298 : 
; 2299 :     if (actxt->type == XML_SCHEMA_CTXT_VALIDATOR)

	mov	eax, DWORD PTR [edi]
	cmp	eax, 2
	jne	SHORT $LN3@xmlSchemaI

; 2159 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	DWORD PTR _str2$[ebp]
	push	DWORD PTR _str1$[ebp]
	push	DWORD PTR _funcName$[ebp]
	push	esi
	push	0
	push	0
	push	1818					; 0000071aH

; 2300 : 	xmlSchemaErr3(actxt, XML_SCHEMAV_INTERNAL, NULL,

	jmp	SHORT $LN13@xmlSchemaI
$LN3@xmlSchemaI:

; 2301 : 	    (const char *) msg, (const xmlChar *) funcName, str1, str2);
; 2302 :     else if (actxt->type == XML_SCHEMA_CTXT_PARSER)

	cmp	eax, 1
	jne	SHORT $LN10@xmlSchemaI

; 2159 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	DWORD PTR _str2$[ebp]
	push	DWORD PTR _str1$[ebp]
	push	DWORD PTR _funcName$[ebp]
	push	esi
	push	0
	push	0
	push	3069					; 00000bfdH
$LN13@xmlSchemaI:

; 2303 : 	xmlSchemaErr3(actxt, XML_SCHEMAP_INTERNAL, NULL,
; 2304 : 	    (const char *) msg, (const xmlChar *) funcName, str1, str2);
; 2305 : 
; 2306 :     FREE_AND_NULL(msg)

	push	2
	push	edi
	call	_xmlSchemaErr4Line
	add	esp, 40					; 00000028H
$LN10@xmlSchemaI:
	test	esi, esi
	je	SHORT $LN12@xmlSchemaI
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlSchemaI:
	pop	esi
$LN6@xmlSchemaI:
	pop	edi

; 2307 : }

	pop	ebp
	ret	0
_xmlSchemaInternalErr2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFormatNodeForError
_TEXT	SEGMENT
_str$ = -4						; size = 4
_msg$ = 8						; size = 4
_actxt$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaFormatNodeForError PROC			; COMDAT

; 2185 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _msg$[ebp]
	xor	ebx, ebx
	mov	esi, DWORD PTR _node$[ebp]
	mov	DWORD PTR _str$[ebp], ebx
	mov	DWORD PTR [edi], ebx
	test	esi, esi
	je	$LN3@xmlSchemaF

; 2186 :     xmlChar *str = NULL;
; 2187 : 
; 2188 :     *msg = NULL;
; 2189 :     if ((node != NULL) &&
; 2190 : 	(node->type != XML_ELEMENT_NODE) &&

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN36@xmlSchemaF
	cmp	eax, 2
	je	SHORT $LN38@xmlSchemaF

; 2191 : 	(node->type != XML_ATTRIBUTE_NODE))
; 2192 :     {
; 2193 : 	/*
; 2194 : 	* Don't try to format other nodes than element and
; 2195 : 	* attribute nodes.
; 2196 : 	* Play safe and return an empty string.
; 2197 : 	*/
; 2198 : 	*msg = xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [edi], eax
	pop	edi

; 2282 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@xmlSchemaF:

; 2199 : 	return(*msg);
; 2200 :     }
; 2201 :     if (node != NULL) {
; 2202 : 	/*
; 2203 : 	* Work on tree nodes.
; 2204 : 	*/
; 2205 : 	if (node->type == XML_ATTRIBUTE_NODE) {

	cmp	eax, 2
	jne	$LN5@xmlSchemaF
$LN38@xmlSchemaF:

; 2206 : 	    xmlNodePtr elem = node->parent;

	mov	esi, DWORD PTR [esi+20]

; 2207 : 
; 2208 : 	    *msg = xmlStrdup(BAD_CAST "Element '");

	push	OFFSET ??_C@_09NEDFDOKM@Element?5?8@
	call	_xmlStrdup
	mov	DWORD PTR [edi], eax
	add	esp, 4

; 2209 : 	    if (elem->ns != NULL)

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN7@xmlSchemaF

; 2210 : 		*msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,

	push	eax
	push	DWORD PTR [ecx+8]
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaFormatQName
	mov	ebx, DWORD PTR _str$[ebp]
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN22@xmlSchemaF
$LN7@xmlSchemaF:

; 1310 :     if (localName != NULL) {

	test	eax, eax
	jne	SHORT $LN22@xmlSchemaF

; 1311 : 	if (namespaceName == NULL)
; 1312 : 	    return(localName);
; 1313 : 	*buf = xmlStrcat(*buf, localName);
; 1314 :     } else {
; 1315 : 	*buf = xmlStrcat(*buf, BAD_CAST "(NULL)");

	push	OFFSET ??_C@_06LHGEHABH@?$CINULL?$CJ@
	push	eax
	call	_xmlStrcat
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _str$[ebp], ebx
$LN22@xmlSchemaF:

; 2211 : 		    elem->ns->href, elem->name));
; 2212 : 	    else
; 2213 : 		*msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,
; 2214 : 		    NULL, elem->name));
; 2215 : 	    FREE_AND_NULL(str);

	mov	ecx, DWORD PTR [edi]
	push	eax
	push	ecx
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	ebx, ebx
	je	SHORT $LN9@xmlSchemaF
	push	ebx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [edi]
	add	esp, 4
	xor	ebx, ebx
	mov	DWORD PTR _str$[ebp], ebx
$LN9@xmlSchemaF:

; 2216 : 	    *msg = xmlStrcat(*msg, BAD_CAST "', ");

	push	OFFSET ??_C@_03EHINCMEC@?8?0?5@
	push	eax
	call	_xmlStrcat

; 2217 : 	    *msg = xmlStrcat(*msg, BAD_CAST "attribute '");

	push	OFFSET ??_C@_0M@DCJBDJKC@attribute?5?8@
	push	eax
	mov	DWORD PTR [edi], eax
	call	_xmlStrcat

; 2218 : 	} else {

	mov	esi, DWORD PTR _node$[ebp]
	add	esp, 16					; 00000010H
	jmp	SHORT $LN6@xmlSchemaF
$LN5@xmlSchemaF:

; 2219 : 	    *msg = xmlStrdup(BAD_CAST "Element '");

	push	OFFSET ??_C@_09NEDFDOKM@Element?5?8@
	call	_xmlStrdup
	add	esp, 4
$LN6@xmlSchemaF:

; 2220 : 	}
; 2221 : 	if (node->ns != NULL)

	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [esi+36]
	mov	esi, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@xmlSchemaF

; 2222 : 	    *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,

	push	esi
	push	DWORD PTR [eax+8]
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaFormatQName
	mov	ebx, DWORD PTR _str$[ebp]
	add	esp, 12					; 0000000cH
	mov	esi, eax
	jmp	SHORT $LN29@xmlSchemaF
$LN10@xmlSchemaF:

; 1304 :     FREE_AND_NULL(*buf)

	test	ebx, ebx
	je	SHORT $LN30@xmlSchemaF
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	ebx, ebx
$LN30@xmlSchemaF:

; 1305 :     if (namespaceName != NULL) {
; 1306 : 	*buf = xmlStrdup(BAD_CAST "{");
; 1307 : 	*buf = xmlStrcat(*buf, namespaceName);
; 1308 : 	*buf = xmlStrcat(*buf, BAD_CAST "}");
; 1309 :     }
; 1310 :     if (localName != NULL) {

	test	esi, esi
	jne	SHORT $LN29@xmlSchemaF

; 1311 : 	if (namespaceName == NULL)
; 1312 : 	    return(localName);
; 1313 : 	*buf = xmlStrcat(*buf, localName);
; 1314 :     } else {
; 1315 : 	*buf = xmlStrcat(*buf, BAD_CAST "(NULL)");

	push	OFFSET ??_C@_06LHGEHABH@?$CINULL?$CJ@
	push	ebx
	call	_xmlStrcat
	mov	ebx, eax
	add	esp, 8

; 1316 :     }
; 1317 :     return ((const xmlChar *) *buf);

	mov	esi, ebx
$LN29@xmlSchemaF:

; 2223 : 	    node->ns->href, node->name));
; 2224 : 	else
; 2225 : 	    *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,
; 2226 : 	    NULL, node->name));
; 2227 : 	FREE_AND_NULL(str);

	mov	eax, DWORD PTR [edi]
	push	esi
	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	ebx, ebx
	je	SHORT $LN12@xmlSchemaF
	push	ebx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [edi]
	add	esp, 4
$LN12@xmlSchemaF:

; 2228 : 	*msg = xmlStrcat(*msg, BAD_CAST "': ");

	push	OFFSET ??_C@_03FPCGPDIA@?8?3?5@
	push	eax
	call	_xmlStrcat
	add	esp, 8

; 2260 :     }
; 2261 : 
; 2262 :     /*
; 2263 :      * xmlSchemaFormatItemForReport() also returns an escaped format
; 2264 :      * string, so do this before calling it below (in the future).
; 2265 :      */
; 2266 :     xmlEscapeFormatString(msg);

	mov	DWORD PTR [edi], eax
	push	edi
	call	_xmlEscapeFormatString

; 2267 : 
; 2268 :     /*
; 2269 :     * VAL TODO: The output of the given schema component is currently
; 2270 :     * disabled.
; 2271 :     */
; 2272 : #if 0
; 2273 :     if ((type != NULL) && (xmlSchemaIsGlobalItem(type))) {
; 2274 : 	*msg = xmlStrcat(*msg, BAD_CAST " [");
; 2275 : 	*msg = xmlStrcat(*msg, xmlSchemaFormatItemForReport(&str,
; 2276 : 	    NULL, type, NULL, 0));
; 2277 : 	FREE_AND_NULL(str)
; 2278 : 	*msg = xmlStrcat(*msg, BAD_CAST "]");
; 2279 :     }
; 2280 : #endif
; 2281 :     return (*msg);

	mov	eax, DWORD PTR [edi]
	add	esp, 4
	pop	edi

; 2282 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlSchemaF:

; 2229 :     } else if (actxt->type == XML_SCHEMA_CTXT_VALIDATOR) {

	mov	ebx, DWORD PTR _actxt$[ebp]
	mov	eax, DWORD PTR [ebx]
	cmp	eax, 2
	jne	$LN13@xmlSchemaF

; 2230 : 	xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) actxt;
; 2231 : 	/*
; 2232 : 	* Work on node infos.
; 2233 : 	*/
; 2234 : 	if (vctxt->inode->nodeType == XML_ATTRIBUTE_NODE) {

	mov	eax, DWORD PTR [ebx+108]
	push	OFFSET ??_C@_09NEDFDOKM@Element?5?8@
	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN15@xmlSchemaF

; 2235 : 	    xmlSchemaNodeInfoPtr ielem =

	mov	ecx, DWORD PTR [ebx+96]
	mov	eax, DWORD PTR [ebx+100]
	mov	esi, DWORD PTR [eax+ecx*4]

; 2236 : 		vctxt->elemInfos[vctxt->depth];
; 2237 : 
; 2238 : 	    *msg = xmlStrdup(BAD_CAST "Element '");

	call	_xmlStrdup
	mov	DWORD PTR [edi], eax

; 2239 : 	    *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,

	lea	eax, DWORD PTR _str$[ebp]
	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+16]
	push	eax
	call	_xmlSchemaFormatQName
	push	eax
	push	DWORD PTR [edi]
	call	_xmlStrcat
	mov	DWORD PTR [edi], eax
	add	esp, 24					; 00000018H

; 2240 : 		ielem->nsName, ielem->localName));
; 2241 : 	    FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$[ebp]
	test	eax, eax
	je	SHORT $LN17@xmlSchemaF
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	DWORD PTR _str$[ebp], 0
$LN17@xmlSchemaF:

; 2242 : 	    *msg = xmlStrcat(*msg, BAD_CAST "', ");

	push	OFFSET ??_C@_03EHINCMEC@?8?0?5@
	push	DWORD PTR [edi]
	call	_xmlStrcat

; 2243 : 	    *msg = xmlStrcat(*msg, BAD_CAST "attribute '");

	push	OFFSET ??_C@_0M@DCJBDJKC@attribute?5?8@
	push	eax
	mov	DWORD PTR [edi], eax
	call	_xmlStrcat
	add	esp, 16					; 00000010H

; 2244 : 	} else {

	jmp	SHORT $LN16@xmlSchemaF
$LN15@xmlSchemaF:

; 2245 : 	    *msg = xmlStrdup(BAD_CAST "Element '");

	call	_xmlStrdup
	add	esp, 4
$LN16@xmlSchemaF:

; 2246 : 	}
; 2247 : 	*msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,

	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [ebx+108]
	push	DWORD PTR [eax+12]
	push	DWORD PTR [eax+16]
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaFormatQName
	push	eax
	push	DWORD PTR [edi]
	call	_xmlStrcat
	mov	DWORD PTR [edi], eax
	add	esp, 20					; 00000014H

; 2248 : 	    vctxt->inode->nsName, vctxt->inode->localName));
; 2249 : 	FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$[ebp]
	test	eax, eax
	je	SHORT $LN18@xmlSchemaF
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN18@xmlSchemaF:

; 2250 : 	*msg = xmlStrcat(*msg, BAD_CAST "': ");

	push	OFFSET ??_C@_03FPCGPDIA@?8?3?5@
	push	DWORD PTR [edi]
	call	_xmlStrcat
	add	esp, 8

; 2260 :     }
; 2261 : 
; 2262 :     /*
; 2263 :      * xmlSchemaFormatItemForReport() also returns an escaped format
; 2264 :      * string, so do this before calling it below (in the future).
; 2265 :      */
; 2266 :     xmlEscapeFormatString(msg);

	mov	DWORD PTR [edi], eax
	push	edi
	call	_xmlEscapeFormatString

; 2267 : 
; 2268 :     /*
; 2269 :     * VAL TODO: The output of the given schema component is currently
; 2270 :     * disabled.
; 2271 :     */
; 2272 : #if 0
; 2273 :     if ((type != NULL) && (xmlSchemaIsGlobalItem(type))) {
; 2274 : 	*msg = xmlStrcat(*msg, BAD_CAST " [");
; 2275 : 	*msg = xmlStrcat(*msg, xmlSchemaFormatItemForReport(&str,
; 2276 : 	    NULL, type, NULL, 0));
; 2277 : 	FREE_AND_NULL(str)
; 2278 : 	*msg = xmlStrcat(*msg, BAD_CAST "]");
; 2279 :     }
; 2280 : #endif
; 2281 :     return (*msg);

	mov	eax, DWORD PTR [edi]
	add	esp, 4
	pop	edi

; 2282 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlSchemaF:

; 2251 :     } else if (actxt->type == XML_SCHEMA_CTXT_PARSER) {

	cmp	eax, 1
	jne	SHORT $LN19@xmlSchemaF

; 2252 : 	/*
; 2253 : 	* Hmm, no node while parsing?
; 2254 : 	* Return an empty string, in case NULL will break something.
; 2255 : 	*/
; 2256 : 	*msg = xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4

; 2260 :     }
; 2261 : 
; 2262 :     /*
; 2263 :      * xmlSchemaFormatItemForReport() also returns an escaped format
; 2264 :      * string, so do this before calling it below (in the future).
; 2265 :      */
; 2266 :     xmlEscapeFormatString(msg);

	mov	DWORD PTR [edi], eax
	push	edi
	call	_xmlEscapeFormatString

; 2267 : 
; 2268 :     /*
; 2269 :     * VAL TODO: The output of the given schema component is currently
; 2270 :     * disabled.
; 2271 :     */
; 2272 : #if 0
; 2273 :     if ((type != NULL) && (xmlSchemaIsGlobalItem(type))) {
; 2274 : 	*msg = xmlStrcat(*msg, BAD_CAST " [");
; 2275 : 	*msg = xmlStrcat(*msg, xmlSchemaFormatItemForReport(&str,
; 2276 : 	    NULL, type, NULL, 0));
; 2277 : 	FREE_AND_NULL(str)
; 2278 : 	*msg = xmlStrcat(*msg, BAD_CAST "]");
; 2279 :     }
; 2280 : #endif
; 2281 :     return (*msg);

	mov	eax, DWORD PTR [edi]
	add	esp, 4
	pop	edi

; 2282 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlSchemaF:

; 2257 :     } else {
; 2258 : 	TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	2258					; 000008d2H
	push	OFFSET ??_C@_0GM@IJCDLDON@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H

; 2259 : 	return (NULL);

	xor	eax, eax
	pop	edi

; 2282 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaFormatNodeForError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaErr
_TEXT	SEGMENT
_actxt$ = 8						; size = 4
_error$ = 12						; size = 4
_node$ = 16						; size = 4
_msg$ = 20						; size = 4
_str1$ = 24						; size = 4
_str2$ = 28						; size = 4
_xmlSchemaErr PROC					; COMDAT

; 2177 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	DWORD PTR _str2$[ebp]
	push	DWORD PTR _str1$[ebp]
	push	DWORD PTR _msg$[ebp]
	push	0
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _error$[ebp]
	push	2
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaErr4Line
	add	esp, 40					; 00000028H

; 2178 :     xmlSchemaErr4(actxt, error, node, msg, str1, str2, NULL, NULL);
; 2179 : }

	pop	ebp
	ret	0
_xmlSchemaErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaErr4
_TEXT	SEGMENT
_actxt$ = 8						; size = 4
_error$ = 12						; size = 4
_node$ = 16						; size = 4
_msg$ = 20						; size = 4
_str1$ = 24						; size = 4
_str2$ = 28						; size = 4
_str3$ = 32						; size = 4
_str4$ = 36						; size = 4
_xmlSchemaErr4 PROC					; COMDAT

; 2168 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _str4$[ebp]
	push	DWORD PTR _str3$[ebp]
	push	DWORD PTR _str2$[ebp]
	push	DWORD PTR _str1$[ebp]
	push	DWORD PTR _msg$[ebp]
	push	0
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _error$[ebp]
	push	2
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaErr4Line
	add	esp, 40					; 00000028H

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,
; 2170 : 	msg, str1, str2, str3, str4);
; 2171 : }

	pop	ebp
	ret	0
_xmlSchemaErr4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaErr3
_TEXT	SEGMENT
_actxt$ = 8						; size = 4
_error$ = 12						; size = 4
_node$ = 16						; size = 4
_msg$ = 20						; size = 4
_str1$ = 24						; size = 4
_str2$ = 28						; size = 4
_str3$ = 32						; size = 4
_xmlSchemaErr3 PROC					; COMDAT

; 2158 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _str3$[ebp]
	push	DWORD PTR _str2$[ebp]
	push	DWORD PTR _str1$[ebp]
	push	DWORD PTR _msg$[ebp]
	push	0
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _error$[ebp]
	push	2
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaErr4Line
	add	esp, 40					; 00000028H

; 2159 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,
; 2160 : 	msg, str1, str2, str3, NULL);
; 2161 : }

	pop	ebp
	ret	0
_xmlSchemaErr3 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaErr4Line
_TEXT	SEGMENT
_schannel$1$ = -24					; size = 4
_data$1$ = -20						; size = 4
_l$1 = -16						; size = 4
_f$2 = -12						; size = 4
_channel$1$ = -8					; size = 4
_col$1$ = -4						; size = 4
_channel$2$ = 8						; size = 4
_node$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_errorLevel$ = 12					; size = 4
_error$ = 16						; size = 4
_node$ = 20						; size = 4
_line$ = 24						; size = 4
_msg$ = 28						; size = 4
_str1$ = 32						; size = 4
_str2$ = 36						; size = 4
_str3$ = 40						; size = 4
_str4$ = 44						; size = 4
_xmlSchemaErr4Line PROC					; COMDAT

; 2045 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN21@xmlSchemaE

; 2046 :     xmlStructuredErrorFunc schannel = NULL;
; 2047 :     xmlGenericErrorFunc channel = NULL;
; 2048 :     void *data = NULL;
; 2049 : 
; 2050 :     if (ctxt != NULL) {
; 2051 : 	if (ctxt->type == XML_SCHEMA_CTXT_VALIDATOR) {

	mov	eax, DWORD PTR [esi]
	push	ebx
	push	edi
	cmp	eax, 2
	jne	$LN3@xmlSchemaE

; 2052 : 	    xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) ctxt;
; 2053 : 	    const char *file = NULL;

	xor	edi, edi

; 2054 : 	    int col = 0;
; 2055 : 	    if (errorLevel != XML_ERR_WARNING) {

	cmp	DWORD PTR _errorLevel$[ebp], 1
	mov	DWORD PTR _col$1$[ebp], edi
	je	SHORT $LN5@xmlSchemaE

; 2056 : 		vctxt->nberrors++;
; 2057 : 		vctxt->err = error;

	mov	eax, DWORD PTR _error$[ebp]
	inc	DWORD PTR [esi+56]
	mov	DWORD PTR [esi+52], eax

; 2058 : 		channel = vctxt->error;

	mov	eax, DWORD PTR [esi+8]

; 2059 : 	    } else {

	jmp	SHORT $LN28@xmlSchemaE
$LN5@xmlSchemaE:

; 2060 : 		channel = vctxt->warning;

	mov	eax, DWORD PTR [esi+12]
$LN28@xmlSchemaE:

; 2061 : 	    }
; 2062 : 	    schannel = vctxt->serror;
; 2063 : 	    data = vctxt->errCtxt;
; 2064 : 
; 2065 : 	    /*
; 2066 : 	    * Error node. If we specify a line number, then
; 2067 : 	    * do not channel any node to the error function.
; 2068 : 	    */
; 2069 : 	    if (line == 0) {

	mov	ebx, DWORD PTR _line$[ebp]
	mov	DWORD PTR _channel$1$[ebp], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR _schannel$1$[ebp], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _data$1$[ebp], eax
	test	ebx, ebx
	jne	SHORT $LN7@xmlSchemaE

; 2070 : 		if ((node == NULL) &&
; 2071 : 		    (vctxt->depth >= 0) &&

	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _node$1$[ebp], ecx
	test	ecx, ecx
	jne	SHORT $LN13@xmlSchemaE
	cmp	DWORD PTR [esi+96], edi
	jl	SHORT $LN25@xmlSchemaE
	mov	eax, DWORD PTR [esi+108]
	test	eax, eax
	je	SHORT $LN25@xmlSchemaE

; 2072 : 		    (vctxt->inode != NULL)) {
; 2073 : 		    node = vctxt->inode->node;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _node$1$[ebp], eax

; 2074 : 		}
; 2075 : 		/*
; 2076 : 		* Get filename and line if no node-tree.
; 2077 : 		*/
; 2078 : 		if ((node == NULL) &&
; 2079 : 		    (vctxt->parserCtxt != NULL) &&

	test	eax, eax
	jne	SHORT $LN13@xmlSchemaE
$LN25@xmlSchemaE:
	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN13@xmlSchemaE
	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	SHORT $LN13@xmlSchemaE

; 2080 : 		    (vctxt->parserCtxt->input != NULL)) {
; 2081 : 		    file = vctxt->parserCtxt->input->filename;

	mov	edi, DWORD PTR [eax+4]

; 2082 : 		    line = vctxt->parserCtxt->input->line;

	mov	ebx, DWORD PTR [eax+28]

; 2083 : 		    col = vctxt->parserCtxt->input->col;

	mov	eax, DWORD PTR [eax+32]
	mov	DWORD PTR _col$1$[ebp], eax

; 2084 : 		}
; 2085 : 	    } else {

	jmp	SHORT $LN13@xmlSchemaE
$LN7@xmlSchemaE:

; 2086 : 		/*
; 2087 : 		* Override the given node's (if any) position
; 2088 : 		* and channel only the given line number.
; 2089 : 		*/
; 2090 : 		node = NULL;
; 2091 : 		/*
; 2092 : 		* Get filename.
; 2093 : 		*/
; 2094 : 		if (vctxt->doc != NULL)

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _node$1$[ebp], edi
	test	eax, eax
	je	SHORT $LN11@xmlSchemaE

; 2095 : 		    file = (const char *) vctxt->doc->URL;

	mov	edi, DWORD PTR [eax+72]
	jmp	SHORT $LN13@xmlSchemaE
$LN11@xmlSchemaE:

; 2096 : 		else if ((vctxt->parserCtxt != NULL) &&

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN13@xmlSchemaE
	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	SHORT $LN13@xmlSchemaE

; 2097 : 		    (vctxt->parserCtxt->input != NULL))
; 2098 : 		    file = vctxt->parserCtxt->input->filename;

	mov	edi, DWORD PTR [eax+4]
$LN13@xmlSchemaE:

; 2099 : 	    }
; 2100 : 	    if (vctxt->locFunc != NULL) {

	mov	eax, DWORD PTR [esi+196]
	test	eax, eax
	je	SHORT $LN18@xmlSchemaE

; 2101 : 	        if ((file == NULL) || (line == 0)) {

	test	edi, edi
	je	SHORT $LN16@xmlSchemaE
	test	ebx, ebx
	jne	SHORT $LN18@xmlSchemaE
$LN16@xmlSchemaE:

; 2102 : 		    unsigned long l;
; 2103 : 		    const char *f;
; 2104 : 		    vctxt->locFunc(vctxt->locCtxt, &f, &l);

	lea	ecx, DWORD PTR _l$1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _f$2[ebp]
	push	ecx
	push	DWORD PTR [esi+200]
	call	eax
	add	esp, 12					; 0000000cH

; 2105 : 		    if (file == NULL)

	test	edi, edi
	cmove	edi, DWORD PTR _f$2[ebp]

; 2106 : 		        file = f;
; 2107 : 		    if (line == 0)

	test	ebx, ebx
	cmove	ebx, DWORD PTR _l$1[ebp]
$LN18@xmlSchemaE:

; 2108 : 		        line = (int) l;
; 2109 : 		}
; 2110 : 	    }
; 2111 : 	    if ((file == NULL) && (vctxt->filename != NULL))

	test	edi, edi
	jne	SHORT $LN19@xmlSchemaE
	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	cmovne	edi, eax
$LN19@xmlSchemaE:

; 2112 : 	        file = vctxt->filename;
; 2113 : 
; 2114 : 	    __xmlRaiseError(schannel, channel, data, ctxt,

	push	DWORD PTR _str4$[ebp]
	mov	edx, DWORD PTR _str3$[ebp]
	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	edx
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	DWORD PTR _col$1$[ebp]
	push	0
	push	edx
	push	ecx
	push	eax
	push	ebx
	push	edi
	push	DWORD PTR _errorLevel$[ebp]
	push	DWORD PTR _error$[ebp]
	push	17					; 00000011H
	push	DWORD PTR _node$1$[ebp]
	push	esi
	push	DWORD PTR _data$1$[ebp]
	push	DWORD PTR _channel$1$[ebp]
	push	DWORD PTR _schannel$1$[ebp]
	call	___xmlRaiseError
	add	esp, 80					; 00000050H
	pop	edi
	pop	ebx
	pop	esi

; 2138 : 	}
; 2139 :     }
; 2140 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlSchemaE:

; 2115 : 		node, XML_FROM_SCHEMASV,
; 2116 : 		error, errorLevel, file, line,
; 2117 : 		(const char *) str1, (const char *) str2,
; 2118 : 		(const char *) str3, 0, col, msg, str1, str2, str3, str4);
; 2119 : 
; 2120 : 	} else if (ctxt->type == XML_SCHEMA_CTXT_PARSER) {

	cmp	eax, 1
	jne	SHORT $LN20@xmlSchemaE

; 2121 : 	    xmlSchemaParserCtxtPtr pctxt = (xmlSchemaParserCtxtPtr) ctxt;
; 2122 : 	    if (errorLevel != XML_ERR_WARNING) {

	mov	edi, DWORD PTR _errorLevel$[ebp]
	mov	ebx, DWORD PTR _error$[ebp]
	cmp	edi, eax
	je	SHORT $LN22@xmlSchemaE

; 2123 : 		pctxt->nberrors++;

	inc	DWORD PTR [esi+20]

; 2124 : 		pctxt->err = error;
; 2125 : 		channel = pctxt->error;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+16], ebx

; 2126 : 	    } else {

	jmp	SHORT $LN29@xmlSchemaE
$LN22@xmlSchemaE:

; 2127 : 		channel = pctxt->warning;

	mov	eax, DWORD PTR [esi+12]
$LN29@xmlSchemaE:

; 2128 : 	    }
; 2129 : 	    schannel = pctxt->serror;
; 2130 : 	    data = pctxt->errCtxt;
; 2131 : 	    __xmlRaiseError(schannel, channel, data, ctxt,

	push	DWORD PTR _str4$[ebp]
	mov	edx, DWORD PTR _str3$[ebp]
	mov	ecx, DWORD PTR _str2$[ebp]
	push	edx
	push	ecx
	mov	DWORD PTR _channel$2$[ebp], eax
	mov	eax, DWORD PTR _str1$[ebp]
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	edx
	push	ecx
	push	eax
	push	0
	push	0
	push	edi
	push	ebx
	push	16					; 00000010H
	push	DWORD PTR _node$[ebp]
	push	esi
	push	DWORD PTR [esi+4]
	push	DWORD PTR _channel$2$[ebp]
	push	DWORD PTR [esi+24]
	call	___xmlRaiseError
	add	esp, 80					; 00000050H
	pop	edi
	pop	ebx
	pop	esi

; 2138 : 	}
; 2139 :     }
; 2140 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlSchemaE:

; 2132 : 		node, XML_FROM_SCHEMASP, error,
; 2133 : 		errorLevel, NULL, 0,
; 2134 : 		(const char *) str1, (const char *) str2,
; 2135 : 		(const char *) str3, 0, 0, msg, str1, str2, str3, str4);
; 2136 : 	} else {
; 2137 : 	    TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	2137					; 00000859H
	push	OFFSET ??_C@_0GM@IJCDLDON@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	pop	edi
	pop	ebx
$LN21@xmlSchemaE:
	pop	esi

; 2138 : 	}
; 2139 :     }
; 2140 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaErr4Line ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPSimpleInternalErr
_TEXT	SEGMENT
_node$ = 8						; size = 4
_msg$ = 12						; size = 4
_str$ = 16						; size = 4
_xmlSchemaPSimpleInternalErr PROC			; COMDAT

; 2017 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _str$[ebp]
	push	DWORD PTR _msg$[ebp]
	push	DWORD PTR _node$[ebp]
	push	3069					; 00000bfdH
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2018 :      __xmlSimpleError(XML_FROM_SCHEMASP, XML_SCHEMAP_INTERNAL, node,
; 2019 : 	 msg, (const char *) str);
; 2020 : }

	pop	ebp
	ret	0
_xmlSchemaPSimpleInternalErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaVErrMemory
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_extra$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaVErrMemory PROC				; COMDAT

; 2005 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlSchemaV

; 2006 :     if (ctxt != NULL) {
; 2007 :         ctxt->nberrors++;
; 2008 :         ctxt->err = XML_SCHEMAV_INTERNAL;

	inc	DWORD PTR [eax+56]
	mov	DWORD PTR [eax+52], 1818		; 0000071aH
$LN2@xmlSchemaV:

; 2009 :     }
; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	DWORD PTR _extra$[ebp]
	push	0
	push	DWORD PTR _node$[ebp]
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2011 :                      extra);
; 2012 : }

	pop	ebp
	ret	0
_xmlSchemaVErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPErrExt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_error$ = 16						; size = 4
_strData1$ = 20						; size = 4
_strData2$ = 24						; size = 4
_strData3$ = 28						; size = 4
_msg$ = 32						; size = 4
_str1$ = 36						; size = 4
_str2$ = 40						; size = 4
_str3$ = 44						; size = 4
_str4$ = 48						; size = 4
_str5$ = 52						; size = 4
_xmlSchemaPErrExt PROC					; COMDAT

; 1969 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	mov	edi, DWORD PTR _error$[ebp]
	xor	edx, edx
	xor	esi, esi
	test	eax, eax
	je	SHORT $LN2@xmlSchemaP

; 1970 : 
; 1971 :     xmlGenericErrorFunc channel = NULL;
; 1972 :     xmlStructuredErrorFunc schannel = NULL;
; 1973 :     void *data = NULL;
; 1974 : 
; 1975 :     if (ctxt != NULL) {
; 1976 :         ctxt->nberrors++;
; 1977 : 	ctxt->err = error;
; 1978 :         channel = ctxt->error;

	inc	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR [eax+8]

; 1979 :         data = ctxt->errCtxt;

	mov	esi, DWORD PTR [eax+4]

; 1980 : 	schannel = ctxt->serror;

	mov	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+16], edi
$LN2@xmlSchemaP:

; 1981 :     }
; 1982 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	push	DWORD PTR _str5$[ebp]
	push	DWORD PTR _str4$[ebp]
	push	DWORD PTR _str3$[ebp]
	push	DWORD PTR _str2$[ebp]
	push	DWORD PTR _str1$[ebp]
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	DWORD PTR _strData3$[ebp]
	push	DWORD PTR _strData2$[ebp]
	push	DWORD PTR _strData1$[ebp]
	push	0
	push	0
	push	2
	push	edi
	push	16					; 00000010H
	push	DWORD PTR _node$[ebp]
	push	eax
	push	esi
	push	ecx
	push	edx
	call	___xmlRaiseError
	add	esp, 84					; 00000054H
	pop	edi
	pop	esi

; 1983 :                     error, XML_ERR_ERROR, NULL, 0,
; 1984 :                     (const char *) strData1, (const char *) strData2,
; 1985 : 		    (const char *) strData3, 0, 0, msg, str1, str2,
; 1986 : 		    str3, str4, str5);
; 1987 : }

	pop	ebp
	ret	0
_xmlSchemaPErrExt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPErr2
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_child$ = 16						; size = 4
_error$ = 20						; size = 4
_msg$ = 24						; size = 4
_str1$ = 28						; size = 4
_str2$ = 32						; size = 4
_xmlSchemaPErr2 PROC					; COMDAT

; 1938 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _child$[ebp]
	test	eax, eax
	push	DWORD PTR _str1$[ebp]
	cmove	eax, DWORD PTR _node$[ebp]
	push	DWORD PTR _msg$[ebp]
	push	DWORD PTR _error$[ebp]
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaPErr
	add	esp, 24					; 00000018H

; 1939 :     if (child != NULL)
; 1940 :         xmlSchemaPErr(ctxt, child, error, msg, str1, str2);
; 1941 :     else
; 1942 :         xmlSchemaPErr(ctxt, node, error, msg, str1, str2);
; 1943 : }

	pop	ebp
	ret	0
_xmlSchemaPErr2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPErr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_error$ = 16						; size = 4
_msg$ = 20						; size = 4
_str1$ = 24						; size = 4
_str2$ = 28						; size = 4
_xmlSchemaPErr PROC					; COMDAT

; 1904 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	xor	edi, edi
	xor	ebx, ebx
	test	edx, edx
	je	SHORT $LN2@xmlSchemaP

; 1905 :     xmlGenericErrorFunc channel = NULL;
; 1906 :     xmlStructuredErrorFunc schannel = NULL;
; 1907 :     void *data = NULL;
; 1908 : 
; 1909 :     if (ctxt != NULL) {
; 1910 :         ctxt->nberrors++;

	mov	eax, DWORD PTR _error$[ebp]
	inc	DWORD PTR [edx+20]

; 1911 : 	ctxt->err = error;
; 1912 :         channel = ctxt->error;

	mov	esi, DWORD PTR [edx+8]

; 1913 :         data = ctxt->errCtxt;

	mov	ebx, DWORD PTR [edx+4]

; 1914 : 	schannel = ctxt->serror;

	mov	edi, DWORD PTR [edx+24]
	mov	DWORD PTR [edx+16], eax
$LN2@xmlSchemaP:

; 1915 :     }
; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	16					; 00000010H
	push	DWORD PTR _node$[ebp]
	push	edx
	push	ebx
	push	esi
	push	edi
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
	pop	edi
	pop	esi
	pop	ebx

; 1917 :                     error, XML_ERR_ERROR, NULL, 0,
; 1918 :                     (const char *) str1, (const char *) str2, NULL, 0, 0,
; 1919 :                     msg, str1, str2);
; 1920 : }

	pop	ebp
	ret	0
_xmlSchemaPErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPErrMemory
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_extra$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaPErrMemory PROC				; COMDAT

; 1883 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlSchemaP

; 1884 :     if (ctxt != NULL)
; 1885 :         ctxt->nberrors++;

	inc	DWORD PTR [eax+20]
$LN2@xmlSchemaP:

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	DWORD PTR _extra$[ebp]
	push	0
	push	DWORD PTR _node$[ebp]
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 1887 :                      extra);
; 1888 : }

	pop	ebp
	ret	0
_xmlSchemaPErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaPSimpleErr
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_xmlSchemaPSimpleErr PROC				; COMDAT

; 1868 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 1869 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, NULL, NULL,
; 1870 :                      msg);
; 1871 : }

	pop	ebp
	ret	0
_xmlSchemaPSimpleErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFormatFacetEnumSet
_TEXT	SEGMENT
_found$1$ = -8						; size = 4
_value$ = -4						; size = 4
_actxt$ = 8						; size = 4
_buf$ = 12						; size = 4
tv341 = 16						; size = 4
_type$ = 16						; size = 4
_xmlSchemaFormatFacetEnumSet PROC			; COMDAT

; 1796 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _buf$[ebp]
	xor	eax, eax
	mov	DWORD PTR _found$1$[ebp], eax
	mov	DWORD PTR _value$[ebp], 0
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN8@xmlSchemaF

; 1797 :     xmlSchemaFacetPtr facet;
; 1798 :     xmlSchemaWhitespaceValueType ws;
; 1799 :     xmlChar *value = NULL;
; 1800 :     int res, found = 0;
; 1801 : 
; 1802 :     if (*buf != NULL)
; 1803 : 	xmlFree(*buf);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlSchemaF:

; 1804 :     *buf = NULL;

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [edi], 0
	npad	5
$LL4@xmlSchemaF:

; 1805 : 
; 1806 :     do {
; 1807 : 	/*
; 1808 : 	* Use the whitespace type of the base type.
; 1809 : 	*/
; 1810 : 	ws = xmlSchemaGetWhiteSpaceFacetValue(type->baseType);

	mov	ebx, DWORD PTR [eax+64]
	lea	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR tv341[ebp], ecx

; 21567:     if (type->type == XML_SCHEMA_TYPE_BASIC) {

	cmp	DWORD PTR [ebx], 1
	jne	SHORT $LN19@xmlSchemaF

; 21568: 	/*
; 21569: 	* Note that we assume a whitespace of preserve for anySimpleType.
; 21570: 	*/
; 21571: 	if ((type->builtInType == XML_SCHEMAS_STRING) ||

	mov	ecx, DWORD PTR [ebx+88]
	cmp	ecx, 1
	je	SHORT $LN45@xmlSchemaF
	cmp	ecx, 46					; 0000002eH
	je	SHORT $LN45@xmlSchemaF

; 21572: 	    (type->builtInType == XML_SCHEMAS_ANYSIMPLETYPE))
; 21573: 	    return(XML_SCHEMA_WHITESPACE_PRESERVE);
; 21574: 	else if (type->builtInType == XML_SCHEMAS_NORMSTRING)

	xor	ebx, ebx
	cmp	ecx, 2
	setne	bl
	add	ebx, 2

; 21575: 	    return(XML_SCHEMA_WHITESPACE_REPLACE);
; 21576: 	else {
; 21577: 	    /*
; 21578: 	    * For all `atomic` datatypes other than string (and types `derived`
; 21579: 	    * by `restriction` from it) the value of whiteSpace is fixed to
; 21580: 	    * collapse
; 21581: 	    * Note that this includes built-in list datatypes.
; 21582: 	    */
; 21583: 	    return(XML_SCHEMA_WHITESPACE_COLLAPSE);

	jmp	SHORT $LN18@xmlSchemaF
$LN19@xmlSchemaF:

; 21584: 	}
; 21585:     } else if (WXS_IS_LIST(type)) {

	mov	ebx, DWORD PTR [ebx+48]
	test	bl, 64					; 00000040H
	je	SHORT $LN26@xmlSchemaF

; 21586: 	/*
; 21587: 	* For list types the facet "whiteSpace" is fixed to "collapse".
; 21588: 	*/
; 21589: 	return (XML_SCHEMA_WHITESPACE_COLLAPSE);

	mov	ebx, 3
	jmp	SHORT $LN18@xmlSchemaF
$LN26@xmlSchemaF:

; 21590:     } else if (WXS_IS_UNION(type)) {

	test	bl, bl
	jns	SHORT $LN28@xmlSchemaF

; 21591: 	return (XML_SCHEMA_WHITESPACE_UNKNOWN);

	xor	ebx, ebx
	jmp	SHORT $LN18@xmlSchemaF
$LN28@xmlSchemaF:

; 21592:     } else if (WXS_IS_ATOMIC(type)) {

	test	ebx, 256				; 00000100H
	je	SHORT $LN34@xmlSchemaF

; 21593: 	if (type->flags & XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE)

	test	ebx, 16777216				; 01000000H
	je	SHORT $LN31@xmlSchemaF
$LN45@xmlSchemaF:

; 1811 : 	for (facet = type->facets; facet != NULL; facet = facet->next) {

	mov	ebx, 1
	jmp	SHORT $LN18@xmlSchemaF
$LN31@xmlSchemaF:

; 21595: 	else if (type->flags & XML_SCHEMAS_TYPE_WHITESPACE_REPLACE)

	shr	ebx, 25					; 00000019H
	not	ebx
	and	ebx, 1
	or	ebx, 2

; 21596: 	    return (XML_SCHEMA_WHITESPACE_REPLACE);
; 21597: 	else
; 21598: 	    return (XML_SCHEMA_WHITESPACE_COLLAPSE);

	jmp	SHORT $LN18@xmlSchemaF
$LN34@xmlSchemaF:

; 21599:     }
; 21600:     return (-1);

	or	ebx, -1
$LN18@xmlSchemaF:

; 1811 : 	for (facet = type->facets; facet != NULL; facet = facet->next) {

	mov	esi, DWORD PTR [eax+68]
	test	esi, esi
	je	$LN48@xmlSchemaF
$LL7@xmlSchemaF:

; 1812 : 	    if (facet->type != XML_SCHEMA_FACET_ENUMERATION)

	cmp	DWORD PTR [esi], 1007			; 000003efH
	jne	$LN5@xmlSchemaF

; 1813 : 		continue;
; 1814 : 	    found = 1;
; 1815 : 	    res = xmlSchemaGetCanonValueWhtspExt(facet->val,

	lea	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _found$1$[ebp], 1
	push	eax
	push	ebx
	push	DWORD PTR [esi+32]
	call	_xmlSchemaGetCanonValueWhtspExt
	add	esp, 12					; 0000000cH

; 1816 : 		ws, &value);
; 1817 : 	    if (res == -1) {

	cmp	eax, -1
	je	$LN40@xmlSchemaF

; 1825 : 	    }
; 1826 : 	    if (*buf == NULL)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN12@xmlSchemaF

; 1827 : 		*buf = xmlStrdup(BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	call	_xmlStrdup
	add	esp, 4
	jmp	SHORT $LN13@xmlSchemaF
$LN12@xmlSchemaF:

; 1828 : 	    else
; 1829 : 		*buf = xmlStrcat(*buf, BAD_CAST ", '");

	push	OFFSET ??_C@_03NGNHMEOA@?0?5?8@
	push	eax
	call	_xmlStrcat
	add	esp, 8
$LN13@xmlSchemaF:

; 1830 : 	    *buf = xmlStrcat(*buf, BAD_CAST value);

	mov	DWORD PTR [edi], eax
	mov	edi, DWORD PTR _value$[ebp]
	push	edi
	push	eax
	call	_xmlStrcat
	mov	ecx, DWORD PTR _buf$[ebp]

; 1831 : 	    *buf = xmlStrcat(*buf, BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	eax
	mov	DWORD PTR [ecx], eax
	call	_xmlStrcat
	mov	ecx, DWORD PTR _buf$[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx], eax

; 1832 : 	    if (value != NULL) {

	test	edi, edi
	je	SHORT $LN52@xmlSchemaF

; 1833 : 		xmlFree((xmlChar *)value);

	push	edi
	call	DWORD PTR _xmlFree
	mov	edi, DWORD PTR _buf$[ebp]
	add	esp, 4

; 1834 : 		value = NULL;

	mov	DWORD PTR _value$[ebp], 0
	jmp	SHORT $LN5@xmlSchemaF
$LN52@xmlSchemaF:

; 1832 : 	    if (value != NULL) {

	mov	edi, ecx
$LN5@xmlSchemaF:

; 1811 : 	for (facet = type->facets; facet != NULL; facet = facet->next) {

	mov	esi, DWORD PTR [esi+4]
	test	esi, esi
	jne	$LL7@xmlSchemaF

; 1835 : 	    }
; 1836 : 	}
; 1837 : 	/*
; 1838 : 	* The enumeration facet of a type restricts the enumeration
; 1839 : 	* facet of the ancestor type; i.e., such restricted enumerations
; 1840 : 	* do not belong to the set of the given type. Thus we break
; 1841 : 	* on the first found enumeration.
; 1842 : 	*/
; 1843 : 	if (found)

	cmp	DWORD PTR _found$1$[ebp], esi
	jne	SHORT $LN3@xmlSchemaF
$LN48@xmlSchemaF:

; 1844 : 	    break;
; 1845 : 	type = type->baseType;

	mov	eax, DWORD PTR tv341[ebp]
	mov	eax, DWORD PTR [eax]

; 1846 :     } while ((type != NULL) && (type->type != XML_SCHEMA_TYPE_BASIC));

	test	eax, eax
	je	SHORT $LN3@xmlSchemaF
	cmp	DWORD PTR [eax], 1
	jne	$LL4@xmlSchemaF
$LN3@xmlSchemaF:

; 1847 : 
; 1848 :     return ((const xmlChar *) *buf);

	mov	eax, DWORD PTR [edi]
	pop	edi

; 1849 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@xmlSchemaF:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CN@FICFNABL@compute?5the?5canonical?5lexical?5r@
	push	OFFSET ??_C@_0BM@OEBNECHE@xmlSchemaFormatFacetEnumSet@
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaInternalErr2

; 1818 : 		xmlSchemaInternalErr(actxt,
; 1819 : 		    "xmlSchemaFormatFacetEnumSet",
; 1820 : 		    "compute the canonical lexical representation");
; 1821 : 		if (*buf != NULL)

	mov	eax, DWORD PTR [edi]

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	add	esp, 20					; 00000014H

; 1818 : 		xmlSchemaInternalErr(actxt,
; 1819 : 		    "xmlSchemaFormatFacetEnumSet",
; 1820 : 		    "compute the canonical lexical representation");
; 1821 : 		if (*buf != NULL)

	test	eax, eax
	je	SHORT $LN11@xmlSchemaF

; 1822 : 		    xmlFree(*buf);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlSchemaF:

; 1823 : 		*buf = NULL;

	mov	DWORD PTR [edi], 0

; 1824 : 		return (NULL);

	xor	eax, eax
	pop	edi

; 1849 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaFormatFacetEnumSet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFormatItemForReport
_TEXT	SEGMENT
_str$ = -4						; size = 4
_buf$ = 8						; size = 4
_itemDes$ = 12						; size = 4
_item$ = 16						; size = 4
_itemNode$ = 20						; size = 4
_xmlSchemaFormatItemForReport PROC			; COMDAT

; 1582 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	xor	edi, edi
	mov	DWORD PTR _str$[ebp], edi
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaF

; 1583 :     xmlChar *str = NULL;
; 1584 :     int named = 1;
; 1585 : 
; 1586 :     if (*buf != NULL) {
; 1587 : 	xmlFree(*buf);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1588 : 	*buf = NULL;

	mov	DWORD PTR [esi], edi
$LN4@xmlSchemaF:

; 1589 :     }
; 1590 : 
; 1591 :     if (itemDes != NULL) {

	mov	eax, DWORD PTR _itemDes$[ebp]
	mov	ecx, DWORD PTR _itemNode$[ebp]
	push	ebx
	test	eax, eax
	je	SHORT $LN5@xmlSchemaF

; 1592 : 	*buf = xmlStrdup(itemDes);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	jmp	$LN75@xmlSchemaF
$LN5@xmlSchemaF:

; 1593 :     } else if (item != NULL) {

	mov	ebx, DWORD PTR _item$[ebp]
	test	ebx, ebx
	je	$LN7@xmlSchemaF

; 1594 : 	switch (item->type) {

	mov	edx, DWORD PTR [ebx]
	mov	eax, edx
	cmp	eax, 1011				; 000003f3H
	jg	$LN7@xmlSchemaF
	cmp	eax, 1000				; 000003e8H
	jge	$LN44@xmlSchemaF
	dec	eax
	cmp	eax, 25					; 00000019H
	ja	$LN7@xmlSchemaF
	movzx	eax, BYTE PTR $LN73@xmlSchemaF[eax]
	jmp	DWORD PTR $LN82@xmlSchemaF[eax*4]
$LN9@xmlSchemaF:

; 1595 : 	case XML_SCHEMA_TYPE_BASIC: {
; 1596 : 	    xmlSchemaTypePtr type = WXS_TYPE_CAST item;
; 1597 : 
; 1598 : 	    if (WXS_IS_ATOMIC(type))

	mov	eax, DWORD PTR [ebx+48]
	test	eax, 256				; 00000100H
	je	SHORT $LN10@xmlSchemaF

; 1599 : 		*buf = xmlStrdup(BAD_CAST "atomic type 'xs:");

	mov	eax, OFFSET ??_C@_0BB@MLAHCBJL@atomic?5type?5?8xs?3@
	jmp	SHORT $LN14@xmlSchemaF
$LN10@xmlSchemaF:

; 1600 : 	    else if (WXS_IS_LIST(type))

	test	al, 64					; 00000040H
	je	SHORT $LN12@xmlSchemaF

; 1601 : 		*buf = xmlStrdup(BAD_CAST "list type 'xs:");

	mov	eax, OFFSET ??_C@_0P@NECGJBPP@list?5type?5?8xs?3@
	jmp	SHORT $LN14@xmlSchemaF
$LN12@xmlSchemaF:

; 1602 : 	    else if (WXS_IS_UNION(type))

	test	al, 128					; 00000080H
	mov	ecx, OFFSET ??_C@_0BB@GMNLLPLD@simple?5type?5?8xs?3@
	mov	eax, OFFSET ??_C@_0BA@CKGFBMGP@union?5type?5?8xs?3@
	cmove	eax, ecx
$LN14@xmlSchemaF:

; 1603 : 		*buf = xmlStrdup(BAD_CAST "union type 'xs:");
; 1604 : 	    else
; 1605 : 		*buf = xmlStrdup(BAD_CAST "simple type 'xs:");
; 1606 : 	    *buf = xmlStrcat(*buf, type->name);

	push	eax
	call	_xmlStrdup
	mov	DWORD PTR [esi], eax
	push	DWORD PTR [ebx+8]
$LN78@xmlSchemaF:

; 1766 : 	*buf = xmlStrcat(*buf, BAD_CAST "'");
; 1767 : 
; 1768 :     }
; 1769 :     if ((itemNode != NULL) && (itemNode->type == XML_ATTRIBUTE_NODE)) {

	push	eax
	call	_xmlStrcat
	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	eax
	mov	DWORD PTR [esi], eax
	call	_xmlStrcat
	add	esp, 20					; 00000014H
	jmp	$LN75@xmlSchemaF
$LN16@xmlSchemaF:

; 1607 : 	    *buf = xmlStrcat(*buf, BAD_CAST "'");
; 1608 : 	    }
; 1609 : 	    break;
; 1610 : 	case XML_SCHEMA_TYPE_SIMPLE: {
; 1611 : 	    xmlSchemaTypePtr type = WXS_TYPE_CAST item;
; 1612 : 
; 1613 : 	    if (type->flags & XML_SCHEMAS_TYPE_GLOBAL) {

	test	BYTE PTR [ebx+48], 8

; 1614 : 		*buf = xmlStrdup(BAD_CAST"");
; 1615 : 	    } else {
; 1616 : 		*buf = xmlStrdup(BAD_CAST "local ");
; 1617 : 	    }
; 1618 : 	    if (WXS_IS_ATOMIC(type))

	mov	ecx, OFFSET ??_C@_00CNPNBAHC@@
	mov	eax, OFFSET ??_C@_06FOGGDAIC@local?5@
	cmovne	eax, ecx
	push	eax
	call	_xmlStrdup
	mov	DWORD PTR [esi], eax
	add	esp, 4
	mov	ecx, DWORD PTR [ebx+48]
	test	ecx, 256				; 00000100H
	je	SHORT $LN19@xmlSchemaF

; 1619 : 		*buf = xmlStrcat(*buf, BAD_CAST "atomic type");

	mov	ecx, OFFSET ??_C@_0M@NAKOLHPN@atomic?5type@
	jmp	SHORT $LN23@xmlSchemaF
$LN19@xmlSchemaF:

; 1620 : 	    else if (WXS_IS_LIST(type))

	test	cl, 64					; 00000040H
	je	SHORT $LN21@xmlSchemaF

; 1621 : 		*buf = xmlStrcat(*buf, BAD_CAST "list type");

	mov	ecx, OFFSET ??_C@_09EMCEHNFO@list?5type@
	jmp	SHORT $LN23@xmlSchemaF
$LN21@xmlSchemaF:

; 1622 : 	    else if (WXS_IS_UNION(type))

	test	cl, 128					; 00000080H
	mov	edx, OFFSET ??_C@_0M@CHKFADBH@simple?5type@
	mov	ecx, OFFSET ??_C@_0L@KHBDGNKM@union?5type@
	cmove	ecx, edx
$LN23@xmlSchemaF:

; 1623 : 		*buf = xmlStrcat(*buf, BAD_CAST "union type");
; 1624 : 	    else
; 1625 : 		*buf = xmlStrcat(*buf, BAD_CAST "simple type");
; 1626 : 	    if (type->flags & XML_SCHEMAS_TYPE_GLOBAL) {

	push	ecx
	push	eax
	call	_xmlStrcat
	add	esp, 8
$LN79@xmlSchemaF:

; 1766 : 	*buf = xmlStrcat(*buf, BAD_CAST "'");
; 1767 : 
; 1768 :     }
; 1769 :     if ((itemNode != NULL) && (itemNode->type == XML_ATTRIBUTE_NODE)) {

	mov	DWORD PTR [esi], eax
	test	BYTE PTR [ebx+48], 8
	je	$LN51@xmlSchemaF
	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	call	_xmlStrcat
	mov	DWORD PTR [esi], eax
	push	DWORD PTR [ebx+8]
	push	eax
$LN80@xmlSchemaF:
	call	_xmlStrcat
	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	eax
	mov	DWORD PTR [esi], eax
	call	_xmlStrcat
	add	esp, 24					; 00000018H
	jmp	$LN75@xmlSchemaF
$LN26@xmlSchemaF:

; 1627 : 		*buf = xmlStrcat(*buf, BAD_CAST " '");
; 1628 : 		*buf = xmlStrcat(*buf, type->name);
; 1629 : 		*buf = xmlStrcat(*buf, BAD_CAST "'");
; 1630 : 	    }
; 1631 : 	    }
; 1632 : 	    break;
; 1633 : 	case XML_SCHEMA_TYPE_COMPLEX: {
; 1634 : 	    xmlSchemaTypePtr type = WXS_TYPE_CAST item;
; 1635 : 
; 1636 : 	    if (type->flags & XML_SCHEMAS_TYPE_GLOBAL)

	test	BYTE PTR [ebx+48], 8

; 1637 : 		*buf = xmlStrdup(BAD_CAST "");
; 1638 : 	    else
; 1639 : 		*buf = xmlStrdup(BAD_CAST "local ");
; 1640 : 	    *buf = xmlStrcat(*buf, BAD_CAST "complex type");

	mov	ecx, OFFSET ??_C@_00CNPNBAHC@@
	mov	eax, OFFSET ??_C@_06FOGGDAIC@local?5@
	cmovne	eax, ecx
	push	eax
	call	_xmlStrdup
	push	OFFSET ??_C@_0N@NIBELLIN@complex?5type@
	push	eax
	mov	DWORD PTR [esi], eax
	call	_xmlStrcat
	add	esp, 12					; 0000000cH

; 1641 : 	    if (type->flags & XML_SCHEMAS_TYPE_GLOBAL) {
; 1642 : 		*buf = xmlStrcat(*buf, BAD_CAST " '");
; 1643 : 		*buf = xmlStrcat(*buf, type->name);
; 1644 : 		*buf = xmlStrcat(*buf, BAD_CAST "'");
; 1645 : 	    }
; 1646 : 	    }
; 1647 : 	    break;

	jmp	SHORT $LN79@xmlSchemaF
$LN30@xmlSchemaF:

; 1648 : 	case XML_SCHEMA_TYPE_ATTRIBUTE_USE: {
; 1649 : 		xmlSchemaAttributeUsePtr ause;
; 1650 : 
; 1651 : 		ause = WXS_ATTR_USE_CAST item;
; 1652 : 		*buf = xmlStrdup(BAD_CAST "attribute use ");

	push	OFFSET ??_C@_0P@LDLBBJOE@attribute?5use?5@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 1653 : 		if (WXS_ATTRUSE_DECL(ause) != NULL) {

	cmp	DWORD PTR [ebx+12], edi
	je	SHORT $LN31@xmlSchemaF

; 1654 : 		    *buf = xmlStrcat(*buf, BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	eax
	call	_xmlStrcat
	mov	DWORD PTR [esi], eax

; 1655 : 		    *buf = xmlStrcat(*buf,

	lea	eax, DWORD PTR _str$[ebp]
	push	DWORD PTR [ebx+12]
	push	eax
	call	_xmlSchemaGetComponentQName
	push	eax
	push	DWORD PTR [esi]
	call	_xmlStrcat

; 1656 : 			xmlSchemaGetComponentQName(&str, WXS_ATTRUSE_DECL(ause)));
; 1657 : 		    FREE_AND_NULL(str)

	mov	edi, DWORD PTR _str$[ebp]
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi], eax
	test	edi, edi
	je	SHORT $LN33@xmlSchemaF
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	edi, edi
	mov	DWORD PTR _str$[ebp], edi
$LN33@xmlSchemaF:

; 1658 : 			*buf = xmlStrcat(*buf, BAD_CAST "'");

	mov	eax, DWORD PTR [esi]
	mov	ecx, OFFSET ??_C@_01GEODFPGF@?8@

; 1661 : 		}
; 1662 : 	    }
; 1663 : 	    break;

	push	ecx
	push	eax
	jmp	$LN76@xmlSchemaF
$LN31@xmlSchemaF:

; 1659 : 		} else {
; 1660 : 		    *buf = xmlStrcat(*buf, BAD_CAST "(unknown)");

	mov	ecx, OFFSET ??_C@_09GPGAJHPD@?$CIunknown?$CJ@

; 1661 : 		}
; 1662 : 	    }
; 1663 : 	    break;

	push	ecx
	push	eax
	jmp	$LN76@xmlSchemaF
$LN34@xmlSchemaF:

; 1664 : 	case XML_SCHEMA_TYPE_ATTRIBUTE: {
; 1665 : 		xmlSchemaAttributePtr attr;
; 1666 : 
; 1667 : 		attr = (xmlSchemaAttributePtr) item;
; 1668 : 		*buf = xmlStrdup(BAD_CAST "attribute decl.");

	push	OFFSET ??_C@_0BA@NHBCAGDA@attribute?5decl?4@
	call	_xmlStrdup

; 1669 : 		*buf = xmlStrcat(*buf, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	mov	DWORD PTR [esi], eax
	call	_xmlStrcat
	mov	DWORD PTR [esi], eax

; 1670 : 		*buf = xmlStrcat(*buf, xmlSchemaFormatQName(&str,

	lea	eax, DWORD PTR _str$[ebp]
	push	DWORD PTR [ebx+8]
	push	DWORD PTR [ebx+56]
	push	eax
	call	_xmlSchemaFormatQName
	push	eax
	push	DWORD PTR [esi]
	call	_xmlStrcat

; 1671 : 		    attr->targetNamespace, attr->name));
; 1672 : 		FREE_AND_NULL(str)

	mov	edi, DWORD PTR _str$[ebp]
	add	esp, 32					; 00000020H
	mov	DWORD PTR [esi], eax
	test	edi, edi
	je	$LN55@xmlSchemaF
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	edi, edi
	mov	DWORD PTR _str$[ebp], edi

; 1673 : 		    *buf = xmlStrcat(*buf, BAD_CAST "'");
; 1674 : 	    }
; 1675 : 	    break;

	jmp	$LN55@xmlSchemaF
$LN36@xmlSchemaF:

; 1676 : 	case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 1677 : 	    xmlSchemaGetComponentDesignation(buf, item);

	push	ebx
	push	esi
	call	_xmlSchemaGetComponentDesignation
	add	esp, 8

; 1678 : 	    break;

	jmp	$LN51@xmlSchemaF
$LN37@xmlSchemaF:

; 1679 : 	case XML_SCHEMA_TYPE_ELEMENT: {
; 1680 : 		xmlSchemaElementPtr elem;
; 1681 : 
; 1682 : 		elem = (xmlSchemaElementPtr) item;
; 1683 : 		*buf = xmlStrdup(BAD_CAST "element decl.");

	push	OFFSET ??_C@_0O@HMOECBPO@element?5decl?4@
	call	_xmlStrdup

; 1684 : 		*buf = xmlStrcat(*buf, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	mov	DWORD PTR [esi], eax
	call	_xmlStrcat
	mov	DWORD PTR [esi], eax

; 1685 : 		*buf = xmlStrcat(*buf, xmlSchemaFormatQName(&str,

	lea	eax, DWORD PTR _str$[ebp]
	push	DWORD PTR [ebx+8]
	push	DWORD PTR [ebx+52]
	push	eax
	call	_xmlSchemaFormatQName
	push	eax
	push	DWORD PTR [esi]
	call	_xmlStrcat

; 1686 : 		    elem->targetNamespace, elem->name));
; 1687 : 		*buf = xmlStrcat(*buf, BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	eax
	mov	DWORD PTR [esi], eax
	call	_xmlStrcat

; 1688 : 	    }
; 1689 : 	    break;

	mov	edi, DWORD PTR _str$[ebp]
	add	esp, 40					; 00000028H
	jmp	$LN75@xmlSchemaF
$LN38@xmlSchemaF:

; 1690 : 	case XML_SCHEMA_TYPE_IDC_UNIQUE:
; 1691 : 	case XML_SCHEMA_TYPE_IDC_KEY:
; 1692 : 	case XML_SCHEMA_TYPE_IDC_KEYREF:
; 1693 : 	    if (item->type == XML_SCHEMA_TYPE_IDC_UNIQUE)

	cmp	edx, 22					; 00000016H
	jne	SHORT $LN39@xmlSchemaF

; 1694 : 		*buf = xmlStrdup(BAD_CAST "unique '");

	mov	eax, OFFSET ??_C@_08GHLBJEBL@unique?5?8@

; 1696 : 		*buf = xmlStrdup(BAD_CAST "key '");
; 1697 : 	    else
; 1698 : 		*buf = xmlStrdup(BAD_CAST "keyRef '");
; 1699 : 	    *buf = xmlStrcat(*buf, ((xmlSchemaIDCPtr) item)->name);

	push	eax
	call	_xmlStrdup
	mov	DWORD PTR [esi], eax
	push	DWORD PTR [ebx+16]

; 1700 : 	    *buf = xmlStrcat(*buf, BAD_CAST "'");
; 1701 : 	    break;

	jmp	$LN78@xmlSchemaF
$LN39@xmlSchemaF:

; 1695 : 	    else if (item->type == XML_SCHEMA_TYPE_IDC_KEY)

	cmp	edx, 23					; 00000017H
	mov	ecx, OFFSET ??_C@_08MKGKMCJE@keyRef?5?8@
	mov	eax, OFFSET ??_C@_05IJGDECGL@key?5?8@
	cmovne	eax, ecx

; 1696 : 		*buf = xmlStrdup(BAD_CAST "key '");
; 1697 : 	    else
; 1698 : 		*buf = xmlStrdup(BAD_CAST "keyRef '");
; 1699 : 	    *buf = xmlStrcat(*buf, ((xmlSchemaIDCPtr) item)->name);

	push	eax
	call	_xmlStrdup
	mov	DWORD PTR [esi], eax
	push	DWORD PTR [ebx+16]

; 1700 : 	    *buf = xmlStrcat(*buf, BAD_CAST "'");
; 1701 : 	    break;

	jmp	$LN78@xmlSchemaF
$LN43@xmlSchemaF:

; 1464 :     switch (pc) {

	mov	eax, DWORD PTR [ebx+24]
	sub	eax, 1
	je	SHORT $LN67@xmlSchemaF
	sub	eax, 1
	je	SHORT $LN68@xmlSchemaF
	sub	eax, 1
	je	SHORT $LN69@xmlSchemaF

; 1471 : 	default:
; 1472 : 	    return (BAD_CAST "invalid process contents");

	mov	eax, OFFSET ??_C@_0BJ@IEOMLCDH@invalid?5process?5contents@
	jmp	SHORT $LN64@xmlSchemaF
$LN69@xmlSchemaF:

; 1469 : 	case XML_SCHEMAS_ANY_STRICT:
; 1470 : 	    return (BAD_CAST "strict");

	mov	eax, OFFSET ??_C@_06OLFOGHEN@strict@
	jmp	SHORT $LN64@xmlSchemaF
$LN68@xmlSchemaF:

; 1467 : 	case XML_SCHEMAS_ANY_LAX:
; 1468 : 	    return (BAD_CAST "lax");

	mov	eax, OFFSET ??_C@_03BLIDKLB@lax@
	jmp	SHORT $LN64@xmlSchemaF
$LN67@xmlSchemaF:

; 1465 : 	case XML_SCHEMAS_ANY_SKIP:
; 1466 : 	    return (BAD_CAST "skip");

	mov	eax, OFFSET ??_C@_04DLBGLKG@skip@
$LN64@xmlSchemaF:

; 1702 : 	case XML_SCHEMA_TYPE_ANY:
; 1703 : 	case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:
; 1704 : 	    *buf = xmlStrdup(xmlSchemaWildcardPCToString(

	push	eax
	call	_xmlStrdup

; 1705 : 		    ((xmlSchemaWildcardPtr) item)->processContents));
; 1706 : 	    *buf = xmlStrcat(*buf, BAD_CAST " wildcard");

	push	OFFSET ??_C@_09NMNBGFGO@?5wildcard@
	push	eax
	mov	DWORD PTR [esi], eax
	call	_xmlStrcat
	add	esp, 12					; 0000000cH

; 1707 : 	    break;

	jmp	$LN75@xmlSchemaF
$LN45@xmlSchemaF:

; 1724 : 	case XML_SCHEMA_TYPE_GROUP: {
; 1725 : 		*buf = xmlStrdup(BAD_CAST "model group def.");

	push	OFFSET ??_C@_0BB@IMEONDPK@model?5group?5def?4@
	call	_xmlStrdup

; 1726 : 		*buf = xmlStrcat(*buf, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	mov	DWORD PTR [esi], eax
	call	_xmlStrcat
	mov	DWORD PTR [esi], eax

; 1727 : 		*buf = xmlStrcat(*buf, xmlSchemaGetComponentQName(&str, item));

	lea	eax, DWORD PTR _str$[ebp]
	push	ebx
	push	eax
	call	_xmlSchemaGetComponentQName
	push	eax
	push	DWORD PTR [esi]
	call	_xmlStrcat

; 1728 : 		*buf = xmlStrcat(*buf, BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	eax
	mov	DWORD PTR [esi], eax
	call	_xmlStrcat

; 1729 : 		FREE_AND_NULL(str)

	mov	edi, DWORD PTR _str$[ebp]
	add	esp, 36					; 00000024H
	mov	DWORD PTR [esi], eax
	test	edi, edi
	je	$LN51@xmlSchemaF
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	edi, edi
	mov	DWORD PTR _str$[ebp], edi

; 1730 : 	    }
; 1731 : 	    break;

	jmp	$LN51@xmlSchemaF
$LN47@xmlSchemaF:

; 1732 : 	case XML_SCHEMA_TYPE_SEQUENCE:
; 1733 : 	case XML_SCHEMA_TYPE_CHOICE:
; 1734 : 	case XML_SCHEMA_TYPE_ALL:
; 1735 : 	case XML_SCHEMA_TYPE_PARTICLE:
; 1736 : 	    *buf = xmlStrdup(WXS_ITEM_TYPE_NAME(item));

	push	ebx
	call	_xmlSchemaGetComponentTypeStr
	push	eax
	call	_xmlStrdup

; 1737 : 	    break;

	jmp	$LN77@xmlSchemaF
$LN48@xmlSchemaF:

; 1738 : 	case XML_SCHEMA_TYPE_NOTATION: {
; 1739 : 		*buf = xmlStrdup(WXS_ITEM_TYPE_NAME(item));

	push	ebx
	call	_xmlSchemaGetComponentTypeStr
	push	eax
	call	_xmlStrdup

; 1740 : 		*buf = xmlStrcat(*buf, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	mov	DWORD PTR [esi], eax
	call	_xmlStrcat
	mov	DWORD PTR [esi], eax

; 1741 : 		*buf = xmlStrcat(*buf, xmlSchemaGetComponentQName(&str, item));

	lea	eax, DWORD PTR _str$[ebp]
	push	ebx
	push	eax
	call	_xmlSchemaGetComponentQName
	push	eax
	push	DWORD PTR [esi]
	call	_xmlStrcat

; 1742 : 		*buf = xmlStrcat(*buf, BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	eax
	mov	DWORD PTR [esi], eax
	call	_xmlStrcat

; 1743 : 		FREE_AND_NULL(str);

	mov	edi, DWORD PTR _str$[ebp]
	add	esp, 40					; 00000028H
	mov	DWORD PTR [esi], eax
	test	edi, edi
	je	SHORT $LN74@xmlSchemaF
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	edi, edi
	mov	DWORD PTR _str$[ebp], edi
$LN74@xmlSchemaF:

; 1744 : 	    }
; 1745 :             /* Falls through. */
; 1746 : 	default:
; 1747 : 	    named = 0;
; 1748 : 	}
; 1749 :     } else
; 1750 : 	named = 0;
; 1751 : 
; 1752 :     if ((named == 0) && (itemNode != NULL)) {

	mov	ecx, DWORD PTR _itemNode$[ebp]
$LN7@xmlSchemaF:
	test	ecx, ecx
	je	$LN57@xmlSchemaF

; 1753 : 	xmlNodePtr elem;
; 1754 : 
; 1755 : 	if (itemNode->type == XML_ATTRIBUTE_NODE)

	cmp	DWORD PTR [ecx+4], 2
	jne	SHORT $LN52@xmlSchemaF

; 1756 : 	    elem = itemNode->parent;

	mov	ebx, DWORD PTR [ecx+20]
	jmp	SHORT $LN53@xmlSchemaF
$LN44@xmlSchemaF:

; 1708 : 	case XML_SCHEMA_FACET_MININCLUSIVE:
; 1709 : 	case XML_SCHEMA_FACET_MINEXCLUSIVE:
; 1710 : 	case XML_SCHEMA_FACET_MAXINCLUSIVE:
; 1711 : 	case XML_SCHEMA_FACET_MAXEXCLUSIVE:
; 1712 : 	case XML_SCHEMA_FACET_TOTALDIGITS:
; 1713 : 	case XML_SCHEMA_FACET_FRACTIONDIGITS:
; 1714 : 	case XML_SCHEMA_FACET_PATTERN:
; 1715 : 	case XML_SCHEMA_FACET_ENUMERATION:
; 1716 : 	case XML_SCHEMA_FACET_WHITESPACE:
; 1717 : 	case XML_SCHEMA_FACET_LENGTH:
; 1718 : 	case XML_SCHEMA_FACET_MAXLENGTH:
; 1719 : 	case XML_SCHEMA_FACET_MINLENGTH:
; 1720 : 	    *buf = xmlStrdup(BAD_CAST "facet '");

	push	OFFSET ??_C@_07HIPPIIHM@facet?5?8@
	call	_xmlStrdup
	mov	DWORD PTR [esi], eax

; 1721 : 	    *buf = xmlStrcat(*buf, xmlSchemaFacetTypeToString(item->type));

	push	DWORD PTR [ebx]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	DWORD PTR [esi]

; 1722 : 	    *buf = xmlStrcat(*buf, BAD_CAST "'");
; 1723 : 	    break;

	jmp	$LN80@xmlSchemaF
$LN52@xmlSchemaF:

; 1757 : 	else
; 1758 : 	    elem = itemNode;

	mov	ebx, ecx
$LN53@xmlSchemaF:

; 1759 : 	*buf = xmlStrdup(BAD_CAST "Element '");

	push	OFFSET ??_C@_09NEDFDOKM@Element?5?8@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 1760 : 	if (elem->ns != NULL) {

	mov	edx, DWORD PTR [ebx+36]
	mov	ecx, DWORD PTR [ebx+8]
	push	ecx
	test	edx, edx
	je	SHORT $LN54@xmlSchemaF

; 1761 : 	    *buf = xmlStrcat(*buf,

	push	DWORD PTR [edx+8]
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaFormatQName
	push	eax
	push	DWORD PTR [esi]
	call	_xmlStrcat

; 1762 : 		xmlSchemaFormatQName(&str, elem->ns->href, elem->name));
; 1763 : 	    FREE_AND_NULL(str)

	mov	edi, DWORD PTR _str$[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR [esi], eax
	test	edi, edi
	je	SHORT $LN55@xmlSchemaF
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	edi, edi
	mov	DWORD PTR _str$[ebp], edi

; 1764 : 	} else

	jmp	SHORT $LN55@xmlSchemaF
$LN54@xmlSchemaF:

; 1765 : 	    *buf = xmlStrcat(*buf, elem->name);

	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR [esi], eax
$LN55@xmlSchemaF:

; 1766 : 	*buf = xmlStrcat(*buf, BAD_CAST "'");
; 1767 : 
; 1768 :     }
; 1769 :     if ((itemNode != NULL) && (itemNode->type == XML_ATTRIBUTE_NODE)) {

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	DWORD PTR [esi]
$LN76@xmlSchemaF:
	call	_xmlStrcat
$LN77@xmlSchemaF:
	add	esp, 8
$LN75@xmlSchemaF:
	mov	DWORD PTR [esi], eax
$LN51@xmlSchemaF:
	mov	ebx, DWORD PTR _itemNode$[ebp]
	test	ebx, ebx
	je	SHORT $LN57@xmlSchemaF
	cmp	DWORD PTR [ebx+4], 2
	jne	SHORT $LN57@xmlSchemaF

; 1770 : 	*buf = xmlStrcat(*buf, BAD_CAST ", attribute '");

	push	OFFSET ??_C@_0O@MMBACEAK@?0?5attribute?5?8@
	push	DWORD PTR [esi]
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR [esi], eax

; 1771 : 	if (itemNode->ns != NULL) {

	mov	edx, DWORD PTR [ebx+36]
	mov	ecx, DWORD PTR [ebx+8]
	push	ecx
	test	edx, edx
	je	SHORT $LN58@xmlSchemaF

; 1772 : 	    *buf = xmlStrcat(*buf, xmlSchemaFormatQName(&str,

	push	DWORD PTR [edx+8]
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaFormatQName
	push	eax
	push	DWORD PTR [esi]
	call	_xmlStrcat

; 1773 : 		itemNode->ns->href, itemNode->name));
; 1774 : 	    FREE_AND_NULL(str)

	mov	edi, DWORD PTR _str$[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR [esi], eax
	test	edi, edi
	je	SHORT $LN59@xmlSchemaF
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	edi, edi

; 1775 : 	} else

	jmp	SHORT $LN59@xmlSchemaF
$LN58@xmlSchemaF:

; 1776 : 	    *buf = xmlStrcat(*buf, itemNode->name);

	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR [esi], eax
$LN59@xmlSchemaF:

; 1777 : 	*buf = xmlStrcat(*buf, BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	DWORD PTR [esi]
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR [esi], eax
$LN57@xmlSchemaF:

; 1778 :     }
; 1779 :     FREE_AND_NULL(str)

	pop	ebx
	test	edi, edi
	je	SHORT $LN61@xmlSchemaF
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN61@xmlSchemaF:

; 1780 : 
; 1781 :     return (xmlEscapeFormatString(buf));

	push	esi
	call	_xmlEscapeFormatString
	add	esp, 4
	pop	edi
	pop	esi

; 1782 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN82@xmlSchemaF:
	DD	$LN9@xmlSchemaF
	DD	$LN43@xmlSchemaF
	DD	$LN16@xmlSchemaF
	DD	$LN26@xmlSchemaF
	DD	$LN47@xmlSchemaF
	DD	$LN37@xmlSchemaF
	DD	$LN34@xmlSchemaF
	DD	$LN36@xmlSchemaF
	DD	$LN45@xmlSchemaF
	DD	$LN48@xmlSchemaF
	DD	$LN38@xmlSchemaF
	DD	$LN30@xmlSchemaF
	DD	$LN7@xmlSchemaF
$LN73@xmlSchemaF:
	DB	0
	DB	1
	DB	12					; 0000000cH
	DB	2
	DB	3
	DB	4
	DB	4
	DB	4
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	1
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	4
	DB	11					; 0000000bH
_xmlSchemaFormatItemForReport ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetCanonValueWhtspExt
_TEXT	SEGMENT
_value2$ = -4						; size = 4
_val$ = 8						; size = 4
_ws$ = 12						; size = 4
tv259 = 16						; size = 4
_retValue$ = 16						; size = 4
_xmlSchemaGetCanonValueWhtspExt PROC			; COMDAT

; 1492 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR _value2$[ebp], 0
	test	ebx, ebx
	je	$LN8@xmlSchemaG

; 1493 :     int list;
; 1494 :     xmlSchemaValType valType;
; 1495 :     const xmlChar *value, *value2 = NULL;
; 1496 : 
; 1497 : 
; 1498 :     if ((retValue == NULL) || (val == NULL))

	mov	edi, DWORD PTR _val$[ebp]
	test	edi, edi
	je	$LN8@xmlSchemaG

; 1499 : 	return (-1);
; 1500 :     list = xmlSchemaValueGetNext(val) ? 1 : 0;

	push	edi
	call	_xmlSchemaValueGetNext
	add	esp, 4

; 1501 :     *retValue = NULL;

	mov	DWORD PTR [ebx], 0
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	DWORD PTR tv259[ebp], eax
$LL4@xmlSchemaG:

; 1502 :     do {
; 1503 : 	value = NULL;
; 1504 : 	valType = xmlSchemaGetValType(val);

	push	edi
	call	_xmlSchemaGetValType
	add	esp, 4

; 1505 : 	switch (valType) {

	test	eax, eax
	jle	SHORT $LN15@xmlSchemaG
	cmp	eax, 2
	jle	SHORT $LN9@xmlSchemaG
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN15@xmlSchemaG
$LN9@xmlSchemaG:

; 1506 : 	    case XML_SCHEMAS_STRING:
; 1507 : 	    case XML_SCHEMAS_NORMSTRING:
; 1508 : 	    case XML_SCHEMAS_ANYSIMPLETYPE:
; 1509 : 		value = xmlSchemaValueGetAsString(val);

	push	edi
	call	_xmlSchemaValueGetAsString
	mov	esi, eax
	add	esp, 4

; 1510 : 		if (value != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlSchemaG

; 1511 : 		    if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	mov	eax, DWORD PTR _ws$[ebp]
	cmp	eax, 3
	jne	SHORT $LN11@xmlSchemaG

; 1512 : 			value2 = xmlSchemaCollapseString(value);

	push	esi
	call	_xmlSchemaCollapseString
	jmp	SHORT $LN35@xmlSchemaG
$LN11@xmlSchemaG:

; 1513 : 		    else if (ws == XML_SCHEMA_WHITESPACE_REPLACE)

	cmp	eax, 2
	jne	SHORT $LN33@xmlSchemaG

; 1514 : 			value2 = xmlSchemaWhiteSpaceReplace(value);

	push	esi
	call	_xmlSchemaWhiteSpaceReplace
$LN35@xmlSchemaG:

; 1515 : 		    if (value2 != NULL)

	mov	DWORD PTR _value2$[ebp], eax
	add	esp, 4
$LN33@xmlSchemaG:
	mov	eax, DWORD PTR _value2$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaG

; 1516 : 			value = value2;

	mov	esi, eax

; 1517 : 		}
; 1518 : 		break;

	jmp	SHORT $LN5@xmlSchemaG
$LN15@xmlSchemaG:

; 1519 : 	    default:
; 1520 : 		if (xmlSchemaGetCanonValue(val, &value2) == -1) {

	lea	eax, DWORD PTR _value2$[ebp]
	push	eax
	push	edi
	call	_xmlSchemaGetCanonValue
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN29@xmlSchemaG

; 1523 : 		    goto internal_error;
; 1524 : 		}
; 1525 : 		value = value2;

	mov	esi, DWORD PTR _value2$[ebp]
$LN5@xmlSchemaG:

; 1526 : 	}
; 1527 : 	if (*retValue == NULL)

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	jne	SHORT $LN18@xmlSchemaG

; 1528 : 	    if (value == NULL) {

	test	esi, esi
	jne	SHORT $LN20@xmlSchemaG

; 1529 : 		if (! list)

	cmp	DWORD PTR tv259[ebp], esi
	jne	SHORT $LN23@xmlSchemaG

; 1530 : 		    *retValue = xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4

; 1531 : 	    } else

	jmp	SHORT $LN36@xmlSchemaG
$LN20@xmlSchemaG:

; 1532 : 		*retValue = xmlStrdup(value);

	push	esi
	call	_xmlStrdup
	add	esp, 4
	jmp	SHORT $LN36@xmlSchemaG
$LN18@xmlSchemaG:

; 1533 : 	else if (value != NULL) {

	test	esi, esi
	je	SHORT $LN23@xmlSchemaG

; 1534 : 	    /* List. */
; 1535 : 	    *retValue = xmlStrcat((xmlChar *) *retValue, BAD_CAST " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	eax
	call	_xmlStrcat

; 1536 : 	    *retValue = xmlStrcat((xmlChar *) *retValue, value);

	push	esi
	push	eax
	mov	DWORD PTR [ebx], eax
	call	_xmlStrcat
	add	esp, 16					; 00000010H
$LN36@xmlSchemaG:

; 1537 : 	}
; 1538 : 	FREE_AND_NULL(value2)

	mov	DWORD PTR [ebx], eax
$LN23@xmlSchemaG:
	mov	eax, DWORD PTR _value2$[ebp]
	test	eax, eax
	je	SHORT $LN24@xmlSchemaG
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	DWORD PTR _value2$[ebp], 0
$LN24@xmlSchemaG:

; 1539 : 	val = xmlSchemaValueGetNext(val);

	push	edi
	call	_xmlSchemaValueGetNext
	mov	edi, eax
	add	esp, 4

; 1540 :     } while (val != NULL);

	test	edi, edi
	jne	$LL4@xmlSchemaG

; 1548 :     return (-1);
; 1549 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlSchemaG:

; 1521 : 		    if (value2 != NULL)

	mov	eax, DWORD PTR _value2$[ebp]
	test	eax, eax
	je	SHORT $internal_error$38

; 1522 : 			xmlFree((xmlChar *) value2);

	push	eax
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _value2$[ebp]
	add	esp, 4
$internal_error$38:

; 1541 : 
; 1542 :     return (0);
; 1543 : internal_error:
; 1544 :     if (*retValue != NULL)

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN25@xmlSchemaG

; 1545 : 	xmlFree((xmlChar *) (*retValue));

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _value2$[ebp]
	add	esp, 4
$LN25@xmlSchemaG:

; 1546 :     if (value2 != NULL)

	test	eax, eax
	je	SHORT $LN8@xmlSchemaG

; 1547 : 	xmlFree((xmlChar *) value2);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlSchemaG:

; 1548 :     return (-1);
; 1549 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaGetCanonValueWhtspExt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaWildcardPCToString
_TEXT	SEGMENT
_pc$ = 8						; size = 4
_xmlSchemaWildcardPCToString PROC			; COMDAT

; 1463 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _pc$[ebp]
	sub	eax, 1
	je	SHORT $LN4@xmlSchemaW

; 1464 :     switch (pc) {

	sub	eax, 1
	je	SHORT $LN5@xmlSchemaW
	sub	eax, 1
	je	SHORT $LN6@xmlSchemaW

; 1471 : 	default:
; 1472 : 	    return (BAD_CAST "invalid process contents");

	mov	eax, OFFSET ??_C@_0BJ@IEOMLCDH@invalid?5process?5contents@

; 1473 :     }
; 1474 : }

	pop	ebp
	ret	0
$LN6@xmlSchemaW:

; 1469 : 	case XML_SCHEMAS_ANY_STRICT:
; 1470 : 	    return (BAD_CAST "strict");

	mov	eax, OFFSET ??_C@_06OLFOGHEN@strict@

; 1473 :     }
; 1474 : }

	pop	ebp
	ret	0
$LN5@xmlSchemaW:

; 1467 : 	case XML_SCHEMAS_ANY_LAX:
; 1468 : 	    return (BAD_CAST "lax");

	mov	eax, OFFSET ??_C@_03BLIDKLB@lax@

; 1473 :     }
; 1474 : }

	pop	ebp
	ret	0
$LN4@xmlSchemaW:

; 1465 : 	case XML_SCHEMAS_ANY_SKIP:
; 1466 : 	    return (BAD_CAST "skip");

	mov	eax, OFFSET ??_C@_04DLBGLKG@skip@

; 1473 :     }
; 1474 : }

	pop	ebp
	ret	0
_xmlSchemaWildcardPCToString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetIDCDesignation
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_idc$ = 12						; size = 4
_xmlSchemaGetIDCDesignation PROC			; COMDAT

; 1450 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4

; 1452 : }

	pop	ebp

; 1451 :     return(xmlSchemaGetComponentDesignation(buf, idc));

	jmp	_xmlSchemaGetComponentDesignation
_xmlSchemaGetIDCDesignation ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetComponentDesignation
_TEXT	SEGMENT
_str$ = -4						; size = 4
_buf$ = 8						; size = 4
_item$ = 12						; size = 4
_xmlSchemaGetComponentDesignation PROC			; COMDAT

; 1436 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4

; 1183 :     switch (item->type) {

	mov	edi, DWORD PTR _item$[ebp]

; 1437 :     xmlChar *str = NULL;

	mov	DWORD PTR _str$[ebp], 0

; 1183 :     switch (item->type) {

	mov	ecx, DWORD PTR [edi]
	mov	eax, ecx
	sub	eax, 1
	je	SHORT $LN7@xmlSchemaG

; 1186 : 		return(BAD_CAST "complex type definition");
; 1187 : 	    else
; 1188 : 		return(BAD_CAST "simple type definition");
; 1189 : 	default:
; 1190 : 	    return(xmlSchemaItemTypeToStr(item->type));

	push	ecx
	call	_xmlSchemaItemTypeToStr
	add	esp, 4
	jmp	SHORT $LN10@xmlSchemaG
$LN7@xmlSchemaG:

; 1184 : 	case XML_SCHEMA_TYPE_BASIC:
; 1185 : 	    if (WXS_IS_COMPLEX(WXS_TYPE_CAST item))

	cmp	DWORD PTR [edi+88], 45			; 0000002dH
	mov	eax, OFFSET ??_C@_0BH@BIKOCJPH@simple?5type?5definition@
	mov	ecx, OFFSET ??_C@_0BI@MHGDJJNC@complex?5type?5definition@
	cmove	eax, ecx
$LN10@xmlSchemaG:

; 1438 : 
; 1439 :     *buf = xmlStrcat(*buf, WXS_ITEM_TYPE_NAME(item));

	mov	esi, DWORD PTR _buf$[ebp]
	push	eax
	push	DWORD PTR [esi]
	call	_xmlStrcat

; 1440 :     *buf = xmlStrcat(*buf, BAD_CAST " '");

	push	OFFSET ??_C@_02OCDGNCGI@?5?8@
	push	eax
	mov	DWORD PTR [esi], eax
	call	_xmlStrcat

; 1429 :     return (xmlSchemaFormatQName(buf,

	push	edi

; 1440 :     *buf = xmlStrcat(*buf, BAD_CAST " '");

	mov	DWORD PTR [esi], eax

; 1429 :     return (xmlSchemaFormatQName(buf,

	call	_xmlSchemaGetComponentName
	add	esp, 20					; 00000014H
	push	eax
	push	edi
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlSchemaFormatQName

; 1441 :     *buf = xmlStrcat(*buf, xmlSchemaGetComponentQName(&str,

	push	eax
	push	DWORD PTR [esi]
	call	_xmlStrcat

; 1442 : 	(xmlSchemaBasicItemPtr) item));
; 1443 :     *buf = xmlStrcat(*buf, BAD_CAST "'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	eax
	mov	DWORD PTR [esi], eax
	call	_xmlStrcat
	mov	DWORD PTR [esi], eax
	add	esp, 28					; 0000001cH

; 1444 :     FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$[ebp]
	test	eax, eax
	je	SHORT $LN15@xmlSchemaG
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlSchemaG:

; 1445 :     return(*buf);
; 1446 : }

	mov	eax, DWORD PTR [esi]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaGetComponentDesignation ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetComponentQName
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_item$ = 12						; size = 4
_xmlSchemaGetComponentQName PROC			; COMDAT

; 1428 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _item$[ebp]
	call	_xmlSchemaGetComponentName
	add	esp, 4
	push	eax
	push	DWORD PTR _item$[ebp]
	call	_xmlSchemaGetComponentTargetNs
	add	esp, 4
	push	eax
	push	DWORD PTR _buf$[ebp]
	call	_xmlSchemaFormatQName
	add	esp, 12					; 0000000cH

; 1429 :     return (xmlSchemaFormatQName(buf,
; 1430 : 	xmlSchemaGetComponentTargetNs((xmlSchemaBasicItemPtr) item),
; 1431 : 	xmlSchemaGetComponentName((xmlSchemaBasicItemPtr) item)));
; 1432 : }

	pop	ebp
	ret	0
_xmlSchemaGetComponentQName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetComponentTargetNs
_TEXT	SEGMENT
_item$ = 8						; size = 4
_xmlSchemaGetComponentTargetNs PROC			; COMDAT

; 1386 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [esi]
	cmp	eax, 14					; 0000000eH
	jle	SHORT $LN28@xmlSchemaG
$LL19@xmlSchemaG:

; 1387 :     switch (item->type) {

	cmp	eax, 24					; 00000018H
	jle	SHORT $LN22@xmlSchemaG
	cmp	eax, 26					; 0000001aH
	jne	SHORT $LN23@xmlSchemaG

; 1405 : 	case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
; 1406 : 	    if (WXS_ATTRUSE_DECL(item) != NULL) {

	mov	esi, DWORD PTR [esi+12]
	test	esi, esi
	je	SHORT $LN12@xmlSchemaG
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR [esi]
	cmp	eax, 14					; 0000000eH
	jg	SHORT $LL19@xmlSchemaG

; 1387 :     switch (item->type) {

	cmp	eax, 14					; 0000000eH
$LN28@xmlSchemaG:
	je	SHORT $LN4@xmlSchemaG
	cmp	eax, 1
	je	SHORT $LN7@xmlSchemaG
	add	eax, -4					; fffffffcH
	cmp	eax, 1
	ja	SHORT $LN12@xmlSchemaG

; 1396 : 	case XML_SCHEMA_TYPE_SIMPLE:
; 1397 : 	case XML_SCHEMA_TYPE_COMPLEX:
; 1398 : 	    return (((xmlSchemaTypePtr) item)->targetNamespace);

	mov	eax, DWORD PTR [esi+112]
	pop	esi

; 1423 : }

	pop	ebp
	ret	0
$LN23@xmlSchemaG:

; 1387 :     switch (item->type) {

	cmp	eax, 2000				; 000007d0H
	jne	SHORT $LN12@xmlSchemaG
$LN27@xmlSchemaG:

; 1407 : 		return(xmlSchemaGetComponentTargetNs(
; 1408 : 		    WXS_BASIC_CAST WXS_ATTRUSE_DECL(item)));
; 1409 : 	    }
; 1410 : 	    /* TODO: Will returning NULL break something? */
; 1411 : 	    break;
; 1412 : 	case XML_SCHEMA_EXTRA_QNAMEREF:
; 1413 : 	    return (((xmlSchemaQNameRefPtr) item)->targetNamespace);

	mov	eax, DWORD PTR [esi+16]
	pop	esi

; 1423 : }

	pop	ebp
	ret	0
$LN22@xmlSchemaG:

; 1387 :     switch (item->type) {

	cmp	eax, 22					; 00000016H
	jge	SHORT $LN10@xmlSchemaG
	sub	eax, 15					; 0000000fH
	cmp	eax, 3
	ja	SHORT $LN12@xmlSchemaG
	jmp	DWORD PTR $LN31@xmlSchemaG[eax*4]
$LN5@xmlSchemaG:

; 1388 : 	case XML_SCHEMA_TYPE_ELEMENT:
; 1389 : 	    return (((xmlSchemaElementPtr) item)->targetNamespace);
; 1390 : 	case XML_SCHEMA_TYPE_ATTRIBUTE:
; 1391 : 	    return (((xmlSchemaAttributePtr) item)->targetNamespace);

	mov	eax, DWORD PTR [esi+56]
	pop	esi

; 1423 : }

	pop	ebp
	ret	0
$LN10@xmlSchemaG:

; 1399 : 	case XML_SCHEMA_TYPE_GROUP:
; 1400 : 	    return (((xmlSchemaModelGroupDefPtr) item)->targetNamespace);
; 1401 : 	case XML_SCHEMA_TYPE_IDC_KEY:
; 1402 : 	case XML_SCHEMA_TYPE_IDC_UNIQUE:
; 1403 : 	case XML_SCHEMA_TYPE_IDC_KEYREF:
; 1404 : 	    return (((xmlSchemaIDCPtr) item)->targetNamespace);

	mov	eax, DWORD PTR [esi+20]
	pop	esi

; 1423 : }

	pop	ebp
	ret	0
$LN12@xmlSchemaG:

; 1414 : 	case XML_SCHEMA_TYPE_NOTATION:
; 1415 : 	    return (((xmlSchemaNotationPtr) item)->targetNamespace);
; 1416 : 	default:
; 1417 : 	    /*
; 1418 : 	    * Other components cannot have names.
; 1419 : 	    */
; 1420 : 	    break;
; 1421 :     }
; 1422 :     return (NULL);

	xor	eax, eax
	pop	esi

; 1423 : }

	pop	ebp
	ret	0
$LN7@xmlSchemaG:

; 1392 : 	case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 1393 : 	    return (((xmlSchemaAttributeGroupPtr) item)->targetNamespace);
; 1394 : 	case XML_SCHEMA_TYPE_BASIC:
; 1395 : 	    return (BAD_CAST "http://www.w3.org/2001/XMLSchema");

	mov	eax, OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	pop	esi

; 1423 : }

	pop	ebp
	ret	0
$LN4@xmlSchemaG:
	mov	eax, DWORD PTR [esi+52]
	pop	esi
	pop	ebp
	ret	0
	npad	2
$LN31@xmlSchemaG:
	DD	$LN5@xmlSchemaG
	DD	$LN4@xmlSchemaG
	DD	$LN10@xmlSchemaG
	DD	$LN27@xmlSchemaG
_xmlSchemaGetComponentTargetNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetComponentName
_TEXT	SEGMENT
_item$ = 8						; size = 4
_xmlSchemaGetComponentName PROC				; COMDAT

; 1331 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [esi]
	cmp	eax, 14					; 0000000eH
	jle	SHORT $LN27@xmlSchemaG
$LL19@xmlSchemaG:

; 1332 :     switch (item->type) {

	cmp	eax, 24					; 00000018H
	jle	SHORT $LN22@xmlSchemaG
	cmp	eax, 26					; 0000001aH
	jne	SHORT $LN23@xmlSchemaG

; 1349 : 	case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
; 1350 : 	    if (WXS_ATTRUSE_DECL(item) != NULL) {

	mov	esi, DWORD PTR [esi+12]
	test	esi, esi
	je	SHORT $LN11@xmlSchemaG
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR [esi]
	cmp	eax, 14					; 0000000eH
	jg	SHORT $LL19@xmlSchemaG

; 1332 :     switch (item->type) {

	cmp	eax, 14					; 0000000eH
$LN27@xmlSchemaG:
	je	SHORT $LN4@xmlSchemaG
	cmp	eax, 1
	je	SHORT $LN4@xmlSchemaG
	add	eax, -4					; fffffffcH
	cmp	eax, 1
	jbe	SHORT $LN4@xmlSchemaG
$LN11@xmlSchemaG:

; 1351 : 		return(xmlSchemaGetComponentName(
; 1352 : 		    WXS_BASIC_CAST WXS_ATTRUSE_DECL(item)));
; 1353 : 	    } else
; 1354 : 		return(NULL);

	xor	eax, eax
	pop	esi

; 1359 : 	default:
; 1360 : 	    /*
; 1361 : 	    * Other components cannot have names.
; 1362 : 	    */
; 1363 : 	    break;
; 1364 :     }
; 1365 :     return (NULL);
; 1366 : }

	pop	ebp
	ret	0
$LN23@xmlSchemaG:

; 1332 :     switch (item->type) {

	cmp	eax, 2000				; 000007d0H
	jne	SHORT $LN11@xmlSchemaG

; 1355 : 	case XML_SCHEMA_EXTRA_QNAMEREF:
; 1356 : 	    return (((xmlSchemaQNameRefPtr) item)->name);

	mov	eax, DWORD PTR [esi+12]
	pop	esi

; 1359 : 	default:
; 1360 : 	    /*
; 1361 : 	    * Other components cannot have names.
; 1362 : 	    */
; 1363 : 	    break;
; 1364 :     }
; 1365 :     return (NULL);
; 1366 : }

	pop	ebp
	ret	0
$LN22@xmlSchemaG:

; 1332 :     switch (item->type) {

	cmp	eax, 22					; 00000016H
	jge	SHORT $LN9@xmlSchemaG
	sub	eax, 15					; 0000000fH
	cmp	eax, 3
	ja	SHORT $LN11@xmlSchemaG
	jmp	DWORD PTR $LN29@xmlSchemaG[eax*4]
$LN14@xmlSchemaG:

; 1357 : 	case XML_SCHEMA_TYPE_NOTATION:
; 1358 : 	    return (((xmlSchemaNotationPtr) item)->name);

	mov	eax, DWORD PTR [esi+4]
	pop	esi

; 1359 : 	default:
; 1360 : 	    /*
; 1361 : 	    * Other components cannot have names.
; 1362 : 	    */
; 1363 : 	    break;
; 1364 :     }
; 1365 :     return (NULL);
; 1366 : }

	pop	ebp
	ret	0
$LN9@xmlSchemaG:

; 1333 : 	case XML_SCHEMA_TYPE_ELEMENT:
; 1334 : 	    return (((xmlSchemaElementPtr) item)->name);
; 1335 : 	case XML_SCHEMA_TYPE_ATTRIBUTE:
; 1336 : 	    return (((xmlSchemaAttributePtr) item)->name);
; 1337 : 	case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 1338 : 	    return (((xmlSchemaAttributeGroupPtr) item)->name);
; 1339 : 	case XML_SCHEMA_TYPE_BASIC:
; 1340 : 	case XML_SCHEMA_TYPE_SIMPLE:
; 1341 : 	case XML_SCHEMA_TYPE_COMPLEX:
; 1342 : 	    return (((xmlSchemaTypePtr) item)->name);
; 1343 : 	case XML_SCHEMA_TYPE_GROUP:
; 1344 : 	    return (((xmlSchemaModelGroupDefPtr) item)->name);
; 1345 : 	case XML_SCHEMA_TYPE_IDC_KEY:
; 1346 : 	case XML_SCHEMA_TYPE_IDC_UNIQUE:
; 1347 : 	case XML_SCHEMA_TYPE_IDC_KEYREF:
; 1348 : 	    return (((xmlSchemaIDCPtr) item)->name);

	mov	eax, DWORD PTR [esi+16]
	pop	esi

; 1359 : 	default:
; 1360 : 	    /*
; 1361 : 	    * Other components cannot have names.
; 1362 : 	    */
; 1363 : 	    break;
; 1364 :     }
; 1365 :     return (NULL);
; 1366 : }

	pop	ebp
	ret	0
$LN4@xmlSchemaG:
	mov	eax, DWORD PTR [esi+8]
	pop	esi
	pop	ebp
	ret	0
$LN29@xmlSchemaG:
	DD	$LN4@xmlSchemaG
	DD	$LN4@xmlSchemaG
	DD	$LN9@xmlSchemaG
	DD	$LN14@xmlSchemaG
_xmlSchemaGetComponentName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFormatQNameNs
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_ns$ = 12						; size = 4
_localName$ = 16					; size = 4
_xmlSchemaFormatQNameNs PROC				; COMDAT

; 1322 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ns$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlSchemaF

; 1323 :     if (ns != NULL)
; 1324 : 	return (xmlSchemaFormatQName(buf, ns->href, localName));

	push	DWORD PTR _localName$[ebp]
	push	DWORD PTR [eax+8]
	push	DWORD PTR _buf$[ebp]
	call	_xmlSchemaFormatQName
	add	esp, 12					; 0000000cH

; 1327 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaF:
	push	esi

; 1304 :     FREE_AND_NULL(*buf)

	mov	esi, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xmlSchemaF
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	DWORD PTR [esi], 0
	xor	eax, eax
$LN6@xmlSchemaF:

; 1305 :     if (namespaceName != NULL) {
; 1306 : 	*buf = xmlStrdup(BAD_CAST "{");
; 1307 : 	*buf = xmlStrcat(*buf, namespaceName);
; 1308 : 	*buf = xmlStrcat(*buf, BAD_CAST "}");
; 1309 :     }
; 1310 :     if (localName != NULL) {

	mov	ecx, DWORD PTR _localName$[ebp]
	test	ecx, ecx
	jne	SHORT $LN5@xmlSchemaF

; 1311 : 	if (namespaceName == NULL)
; 1312 : 	    return(localName);
; 1313 : 	*buf = xmlStrcat(*buf, localName);
; 1314 :     } else {
; 1315 : 	*buf = xmlStrcat(*buf, BAD_CAST "(NULL)");

	push	OFFSET ??_C@_06LHGEHABH@?$CINULL?$CJ@
	push	eax
	call	_xmlStrcat
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR [esi], ecx
$LN5@xmlSchemaF:

; 1325 :     else
; 1326 : 	return (xmlSchemaFormatQName(buf, NULL, localName));

	mov	eax, ecx
	pop	esi

; 1327 : }

	pop	ebp
	ret	0
_xmlSchemaFormatQNameNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFormatQName
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_namespaceName$ = 12					; size = 4
_localName$ = 16					; size = 4
_xmlSchemaFormatQName PROC				; COMDAT

; 1303 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xmlSchemaF

; 1304 :     FREE_AND_NULL(*buf)

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	DWORD PTR [esi], 0
$LN2@xmlSchemaF:

; 1305 :     if (namespaceName != NULL) {

	mov	edi, DWORD PTR _namespaceName$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlSchemaF

; 1306 : 	*buf = xmlStrdup(BAD_CAST "{");

	push	OFFSET ??_C@_01HCONENDN@?$HL@
	call	_xmlStrdup

; 1307 : 	*buf = xmlStrcat(*buf, namespaceName);

	push	edi
	push	eax
	mov	DWORD PTR [esi], eax
	call	_xmlStrcat

; 1308 : 	*buf = xmlStrcat(*buf, BAD_CAST "}");

	push	OFFSET ??_C@_01CELHOKLL@?$HN@
	push	eax
	mov	DWORD PTR [esi], eax
	call	_xmlStrcat
	add	esp, 20					; 00000014H
	mov	DWORD PTR [esi], eax
$LN3@xmlSchemaF:

; 1309 :     }
; 1310 :     if (localName != NULL) {

	mov	eax, DWORD PTR _localName$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaF

; 1311 : 	if (namespaceName == NULL)

	test	edi, edi
	jne	SHORT $LN5@xmlSchemaF

; 1318 : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlSchemaF:

; 1312 : 	    return(localName);
; 1313 : 	*buf = xmlStrcat(*buf, localName);
; 1314 :     } else {
; 1315 : 	*buf = xmlStrcat(*buf, BAD_CAST "(NULL)");

	mov	eax, OFFSET ??_C@_06LHGEHABH@?$CINULL?$CJ@
$LN5@xmlSchemaF:

; 1316 :     }
; 1317 :     return ((const xmlChar *) *buf);

	push	eax
	push	DWORD PTR [esi]
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR [esi], eax
	pop	edi

; 1318 : }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaFormatQName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetComponentNode
_TEXT	SEGMENT
_item$ = 8						; size = 4
_xmlSchemaGetComponentNode PROC				; COMDAT

; 1206 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 2000				; 000007d0H
	jg	SHORT $LN17@xmlSchemaG

; 1207 :     switch (item->type) {

	je	SHORT $LN13@xmlSchemaG
	sub	ecx, 2
	cmp	ecx, 24					; 00000018H
	ja	SHORT $LN17@xmlSchemaG
	movzx	ecx, BYTE PTR $LN18@xmlSchemaG[ecx]
	jmp	DWORD PTR $LN20@xmlSchemaG[ecx*4]
$LN5@xmlSchemaG:

; 1208 : 	case XML_SCHEMA_TYPE_ELEMENT:
; 1209 : 	    return (((xmlSchemaElementPtr) item)->node);
; 1210 : 	case XML_SCHEMA_TYPE_ATTRIBUTE:
; 1211 : 	    return (((xmlSchemaAttributePtr) item)->node);

	mov	eax, DWORD PTR [eax+52]

; 1242 :     }
; 1243 : }

	pop	ebp
	ret	0
$LN6@xmlSchemaG:

; 1212 : 	case XML_SCHEMA_TYPE_COMPLEX:
; 1213 : 	case XML_SCHEMA_TYPE_SIMPLE:
; 1214 : 	    return (((xmlSchemaTypePtr) item)->node);

	mov	eax, DWORD PTR [eax+36]

; 1242 :     }
; 1243 : }

	pop	ebp
	ret	0
$LN9@xmlSchemaG:

; 1215 : 	case XML_SCHEMA_TYPE_ANY:
; 1216 : 	case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:
; 1217 : 	    return (((xmlSchemaWildcardPtr) item)->node);
; 1218 : 	case XML_SCHEMA_TYPE_PARTICLE:
; 1219 : 	    return (((xmlSchemaParticlePtr) item)->node);
; 1220 : 	case XML_SCHEMA_TYPE_SEQUENCE:
; 1221 : 	case XML_SCHEMA_TYPE_CHOICE:
; 1222 : 	case XML_SCHEMA_TYPE_ALL:
; 1223 : 	    return (((xmlSchemaModelGroupPtr) item)->node);

	mov	eax, DWORD PTR [eax+16]

; 1242 :     }
; 1243 : }

	pop	ebp
	ret	0
$LN10@xmlSchemaG:

; 1224 : 	case XML_SCHEMA_TYPE_GROUP:
; 1225 : 	    return (((xmlSchemaModelGroupDefPtr) item)->node);

	mov	eax, DWORD PTR [eax+24]

; 1242 :     }
; 1243 : }

	pop	ebp
	ret	0
$LN11@xmlSchemaG:

; 1226 : 	case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 1227 : 	    return (((xmlSchemaAttributeGroupPtr) item)->node);

	mov	eax, DWORD PTR [eax+32]

; 1242 :     }
; 1243 : }

	pop	ebp
	ret	0
$LN12@xmlSchemaG:

; 1228 : 	case XML_SCHEMA_TYPE_IDC_UNIQUE:
; 1229 : 	case XML_SCHEMA_TYPE_IDC_KEY:
; 1230 : 	case XML_SCHEMA_TYPE_IDC_KEYREF:
; 1231 : 	    return (((xmlSchemaIDCPtr) item)->node);

	mov	eax, DWORD PTR [eax+12]

; 1242 :     }
; 1243 : }

	pop	ebp
	ret	0
$LN13@xmlSchemaG:

; 1232 : 	case XML_SCHEMA_EXTRA_QNAMEREF:
; 1233 : 	    return(((xmlSchemaQNameRefPtr) item)->node);

	mov	eax, DWORD PTR [eax+20]

; 1242 :     }
; 1243 : }

	pop	ebp
	ret	0
$LN17@xmlSchemaG:

; 1234 : 	/* TODO: What to do with NOTATIONs?
; 1235 : 	case XML_SCHEMA_TYPE_NOTATION:
; 1236 : 	    return (((xmlSchemaNotationPtr) item)->node);
; 1237 : 	*/
; 1238 : 	case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
; 1239 : 	    return (((xmlSchemaAttributeUsePtr) item)->node);
; 1240 : 	default:
; 1241 : 	    return (NULL);

	xor	eax, eax

; 1242 :     }
; 1243 : }

	pop	ebp
	ret	0
	npad	3
$LN20@xmlSchemaG:
	DD	$LN12@xmlSchemaG
	DD	$LN6@xmlSchemaG
	DD	$LN9@xmlSchemaG
	DD	$LN5@xmlSchemaG
	DD	$LN11@xmlSchemaG
	DD	$LN10@xmlSchemaG
	DD	$LN13@xmlSchemaG
	DD	$LN17@xmlSchemaG
$LN18@xmlSchemaG:
	DB	0
	DB	7
	DB	1
	DB	1
	DB	2
	DB	2
	DB	2
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	1
	DB	3
	DB	4
	DB	5
	DB	7
	DB	7
	DB	7
	DB	0
	DB	0
	DB	0
	DB	0
	DB	5
	DB	6
_xmlSchemaGetComponentNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaItemTypeToStr
_TEXT	SEGMENT
_type$ = 8						; size = 4
_xmlSchemaItemTypeToStr PROC				; COMDAT

; 1126 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	cmp	eax, 2000				; 000007d0H
	jg	$LN25@xmlSchemaI

; 1127 :     switch (type) {

	je	$LN21@xmlSchemaI
	dec	eax
	cmp	eax, 25					; 00000019H
	ja	$LN23@xmlSchemaI
	movzx	eax, BYTE PTR $LN26@xmlSchemaI[eax]
	jmp	DWORD PTR $LN28@xmlSchemaI[eax*4]
$LN5@xmlSchemaI:

; 1128 : 	case XML_SCHEMA_TYPE_BASIC:
; 1129 : 	    return(BAD_CAST "simple type definition");
; 1130 : 	case XML_SCHEMA_TYPE_SIMPLE:
; 1131 : 	    return(BAD_CAST "simple type definition");

	mov	eax, OFFSET ??_C@_0BH@BIKOCJPH@simple?5type?5definition@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN6@xmlSchemaI:

; 1132 : 	case XML_SCHEMA_TYPE_COMPLEX:
; 1133 : 	    return(BAD_CAST "complex type definition");

	mov	eax, OFFSET ??_C@_0BI@MHGDJJNC@complex?5type?5definition@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN7@xmlSchemaI:

; 1134 : 	case XML_SCHEMA_TYPE_ELEMENT:
; 1135 : 	    return(BAD_CAST "element declaration");

	mov	eax, OFFSET ??_C@_0BE@GNKEMAII@element?5declaration@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN8@xmlSchemaI:

; 1136 : 	case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
; 1137 : 	    return(BAD_CAST "attribute use");

	mov	eax, OFFSET ??_C@_0O@OMANOKDA@attribute?5use@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN9@xmlSchemaI:

; 1138 : 	case XML_SCHEMA_TYPE_ATTRIBUTE:
; 1139 : 	    return(BAD_CAST "attribute declaration");

	mov	eax, OFFSET ??_C@_0BG@EDIHLHKC@attribute?5declaration@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN10@xmlSchemaI:

; 1140 : 	case XML_SCHEMA_TYPE_GROUP:
; 1141 : 	    return(BAD_CAST "model group definition");

	mov	eax, OFFSET ??_C@_0BH@MMBLGEHA@model?5group?5definition@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN11@xmlSchemaI:

; 1142 : 	case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 1143 : 	    return(BAD_CAST "attribute group definition");

	mov	eax, OFFSET ??_C@_0BL@LEHHANJP@attribute?5group?5definition@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN12@xmlSchemaI:

; 1144 : 	case XML_SCHEMA_TYPE_NOTATION:
; 1145 : 	    return(BAD_CAST "notation declaration");

	mov	eax, OFFSET ??_C@_0BF@JHGFINH@notation?5declaration@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN13@xmlSchemaI:

; 1146 : 	case XML_SCHEMA_TYPE_SEQUENCE:
; 1147 : 	    return(BAD_CAST "model group (sequence)");

	mov	eax, OFFSET ??_C@_0BH@EJHDDDLA@model?5group?5?$CIsequence?$CJ@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN14@xmlSchemaI:

; 1148 : 	case XML_SCHEMA_TYPE_CHOICE:
; 1149 : 	    return(BAD_CAST "model group (choice)");

	mov	eax, OFFSET ??_C@_0BF@DBPJFANL@model?5group?5?$CIchoice?$CJ@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN15@xmlSchemaI:

; 1150 : 	case XML_SCHEMA_TYPE_ALL:
; 1151 : 	    return(BAD_CAST "model group (all)");

	mov	eax, OFFSET ??_C@_0BC@IIBLBPCH@model?5group?5?$CIall?$CJ@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN16@xmlSchemaI:

; 1152 : 	case XML_SCHEMA_TYPE_PARTICLE:
; 1153 : 	    return(BAD_CAST "particle");

	mov	eax, OFFSET ??_C@_08PKKGOGAD@particle@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN17@xmlSchemaI:

; 1154 : 	case XML_SCHEMA_TYPE_IDC_UNIQUE:
; 1155 : 	    return(BAD_CAST "unique identity-constraint");

	mov	eax, OFFSET ??_C@_0BL@NFCPOJDK@unique?5identity?9constraint@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN18@xmlSchemaI:

; 1156 : 	    /* return(BAD_CAST "IDC (unique)"); */
; 1157 : 	case XML_SCHEMA_TYPE_IDC_KEY:
; 1158 : 	    return(BAD_CAST "key identity-constraint");

	mov	eax, OFFSET ??_C@_0BI@LJCGFAMF@key?5identity?9constraint@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN19@xmlSchemaI:

; 1159 : 	    /* return(BAD_CAST "IDC (key)"); */
; 1160 : 	case XML_SCHEMA_TYPE_IDC_KEYREF:
; 1161 : 	    return(BAD_CAST "keyref identity-constraint");

	mov	eax, OFFSET ??_C@_0BL@GKPNKMCM@keyref?5identity?9constraint@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN20@xmlSchemaI:

; 1162 : 	    /* return(BAD_CAST "IDC (keyref)"); */
; 1163 : 	case XML_SCHEMA_TYPE_ANY:
; 1164 : 	    return(BAD_CAST "wildcard (any)");

	mov	eax, OFFSET ??_C@_0P@BBIPBLEO@wildcard?5?$CIany?$CJ@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN21@xmlSchemaI:

; 1165 : 	case XML_SCHEMA_EXTRA_QNAMEREF:
; 1166 : 	    return(BAD_CAST "[helper component] QName reference");

	mov	eax, OFFSET ??_C@_0CD@GEFKFDJJ@?$FLhelper?5component?$FN?5QName?5refere@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN25@xmlSchemaI:

; 1127 :     switch (type) {

	cmp	eax, 2001				; 000007d1H
	je	SHORT $LN22@xmlSchemaI
$LN23@xmlSchemaI:

; 1169 : 	default:
; 1170 : 	    return(BAD_CAST "Not a schema component");

	mov	eax, OFFSET ??_C@_0BH@CAFJLKIN@Not?5a?5schema?5component@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
$LN22@xmlSchemaI:

; 1167 : 	case XML_SCHEMA_EXTRA_ATTR_USE_PROHIB:
; 1168 : 	    return(BAD_CAST "[helper component] attribute use prohibition");

	mov	eax, OFFSET ??_C@_0CN@OAJJPDIM@?$FLhelper?5component?$FN?5attribute?5us@

; 1171 :     }
; 1172 : }

	pop	ebp
	ret	0
	npad	3
$LN28@xmlSchemaI:
	DD	$LN5@xmlSchemaI
	DD	$LN20@xmlSchemaI
	DD	$LN6@xmlSchemaI
	DD	$LN13@xmlSchemaI
	DD	$LN14@xmlSchemaI
	DD	$LN15@xmlSchemaI
	DD	$LN7@xmlSchemaI
	DD	$LN9@xmlSchemaI
	DD	$LN11@xmlSchemaI
	DD	$LN10@xmlSchemaI
	DD	$LN12@xmlSchemaI
	DD	$LN17@xmlSchemaI
	DD	$LN18@xmlSchemaI
	DD	$LN19@xmlSchemaI
	DD	$LN16@xmlSchemaI
	DD	$LN8@xmlSchemaI
	DD	$LN23@xmlSchemaI
$LN26@xmlSchemaI:
	DB	0
	DB	1
	DB	16					; 00000010H
	DB	0
	DB	2
	DB	3
	DB	4
	DB	5
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
_xmlSchemaItemTypeToStr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseAttributeGroupRef
_TEXT	SEGMENT
_ref$ = -8						; size = 4
_refNs$ = -4						; size = 4
_des$1 = 8						; size = 4
_attr$1$ = 8						; size = 4
_des$2 = 8						; size = 4
_str$3 = 8						; size = 4
_pctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaParseAttributeGroupRef PROC			; COMDAT

; 7690 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pctxt$[ebp]
	mov	DWORD PTR _refNs$[ebp], 0
	mov	DWORD PTR _ref$[ebp], 0
	test	edi, edi
	je	$LN5@xmlSchemaP

; 7691 :     xmlSchemaQNameRefPtr ret;
; 7692 :     xmlNodePtr child = NULL;
; 7693 :     xmlAttrPtr attr;
; 7694 :     const xmlChar *refNs = NULL, *ref = NULL;
; 7695 : 
; 7696 :     if ((pctxt == NULL) || (schema == NULL) || (node == NULL))

	mov	esi, DWORD PTR _schema$[ebp]
	test	esi, esi
	je	$LN5@xmlSchemaP
	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	$LN5@xmlSchemaP

; 7698 : 
; 7699 :     attr = xmlSchemaGetPropNode(node, "ref");

	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	ebx
	call	_xmlSchemaGetPropNode
	add	esp, 8
	mov	DWORD PTR _attr$1$[ebp], eax

; 7700 :     if (attr == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlSchemaP

; 2802 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	eax
	push	eax
	mov	DWORD PTR _des$2[ebp], eax
	lea	eax, DWORD PTR _des$2[ebp]
	push	eax
	call	_xmlSchemaFormatItemForReport

; 1916 :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	mov	eax, DWORD PTR _des$2[ebp]
	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	eax
	push	OFFSET ??_C@_0DB@LLELCGPM@?$CFs?3?5The?5attribute?5?8?$CFs?8?5is?5requi@
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	eax
	inc	DWORD PTR [edi+20]
	push	0
	push	0
	push	2
	push	3036					; 00000bdcH
	push	16					; 00000010H
	push	ebx
	push	edi
	push	DWORD PTR [edi+4]
	mov	DWORD PTR [edi+16], 3036		; 00000bdcH
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+24]
	call	___xmlRaiseError
	add	esp, 88					; 00000058H
	jmp	$LN64@xmlSchemaP
$LN6@xmlSchemaP:

; 7701 : 	xmlSchemaPMissingAttrErr(pctxt,
; 7702 : 	    XML_SCHEMAP_S4S_ATTR_MISSING,
; 7703 : 	    NULL, node, "ref", NULL);
; 7704 : 	return (NULL);
; 7705 :     }
; 7706 :     xmlSchemaPValAttrNodeQName(pctxt, schema,

	lea	ecx, DWORD PTR _ref$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _refNs$[ebp]
	push	ecx
	push	eax
	push	0
	push	esi
	push	edi
	call	_xmlSchemaPValAttrNodeQName

; 7707 : 	NULL, attr, &refNs, &ref);
; 7708 :     if (xmlSchemaCheckReference(pctxt, schema, node, attr, refNs) != 0)

	push	DWORD PTR _refNs$[ebp]
	push	DWORD PTR _attr$1$[ebp]
	push	ebx
	push	esi
	push	edi
	call	_xmlSchemaCheckReference
	add	esp, 44					; 0000002cH
	test	eax, eax
	jne	$LN5@xmlSchemaP

; 7709 : 	return(NULL);
; 7710 : 
; 7711 :     /*
; 7712 :     * Check for illegal attributes.
; 7713 :     */
; 7714 :     attr = node->properties;

	mov	esi, DWORD PTR [ebx+44]

; 7715 :     while (attr != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlSchemaP
$LL2@xmlSchemaP:

; 7716 : 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN8@xmlSchemaP

; 7717 : 	    if ((!xmlStrEqual(attr->name, BAD_CAST "ref")) &&

	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlSchemaP
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlSchemaP

; 7718 : 		(!xmlStrEqual(attr->name, BAD_CAST "id")))
; 7719 : 	    {
; 7720 : 		xmlSchemaPIllegalAttrErr(pctxt,
; 7721 : 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 7722 : 	    }

	jmp	SHORT $LN62@xmlSchemaP
$LN8@xmlSchemaP:

; 7723 : 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlSchemaP
$LN62@xmlSchemaP:

; 7724 : 	    xmlSchemaPIllegalAttrErr(pctxt,
; 7725 : 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 7726 : 	}
; 7727 : 	attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN11@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaP
$LN3@xmlSchemaP:

; 7728 :     }
; 7729 :     /* Attribute ID */
; 7730 :     xmlSchemaPValAttrID(pctxt, node, BAD_CAST "id");

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	ebx
	push	edi
	call	_xmlSchemaPValAttrID

; 7731 : 
; 7732 :     /*
; 7733 :     * And now for the children...
; 7734 :     */
; 7735 :     child = node->children;

	mov	esi, DWORD PTR [ebx+12]
	add	esp, 12					; 0000000cH

; 7736 :     if (IS_SCHEMA(child, "annotation")) {

	test	esi, esi
	je	$LN34@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN12@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlSchemaP

; 7737 : 	/*
; 7738 : 	* TODO: We do not have a place to store the annotation, do we?
; 7739 : 	*/
; 7740 :         xmlSchemaParseAnnotation(pctxt, child, 0);

	push	0
	push	esi
	push	edi
	call	_xmlSchemaParseAnnotation

; 7741 :         child = child->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 12					; 0000000cH
$LN12@xmlSchemaP:

; 7742 :     }
; 7743 :     if (child != NULL) {

	test	esi, esi
	je	SHORT $LN34@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	0
	lea	eax, DWORD PTR _des$1[ebp]
	mov	DWORD PTR _des$1[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0O@MNAJHLGE@?$CIannotation?$DP?$CJ@
	push	DWORD PTR _des$1[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	edi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN34@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN34@xmlSchemaP:

; 7744 : 	xmlSchemaPContentErr(pctxt,
; 7745 : 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 7746 : 	    NULL, node, child, NULL,
; 7747 : 	    "(annotation?)");
; 7748 :     }
; 7749 : 
; 7750 :     /*
; 7751 :     * Handle attribute group redefinitions.
; 7752 :     */
; 7753 :     if (pctxt->isRedefine && pctxt->redef &&
; 7754 : 	(pctxt->redef->item->type ==
; 7755 : 	    XML_SCHEMA_TYPE_ATTRIBUTEGROUP) &&
; 7756 : 	(ref == pctxt->redef->refName) &&

	cmp	DWORD PTR [edi+100], 0
	mov	edx, DWORD PTR _ref$[ebp]
	je	$LN61@xmlSchemaP
	mov	ecx, DWORD PTR [edi+120]
	test	ecx, ecx
	je	$LN61@xmlSchemaP
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax], 16			; 00000010H
	mov	eax, DWORD PTR _refNs$[ebp]
	jne	$LN14@xmlSchemaP
	cmp	edx, DWORD PTR [ecx+16]
	jne	$LN14@xmlSchemaP
	cmp	eax, DWORD PTR [ecx+20]
	jne	SHORT $LN14@xmlSchemaP

; 7757 : 	(refNs == pctxt->redef->refTargetNs))
; 7758 :     {
; 7759 : 	/*
; 7760 : 	* SPEC src-redefine:
; 7761 : 	* (7.1) "If it has an <attributeGroup> among its contents
; 7762 : 	* the `actual value` of whose ref [attribute] is the same
; 7763 : 	* as the `actual value` of its own name attribute plus
; 7764 : 	* target namespace, then it must have exactly one such group."
; 7765 : 	*/
; 7766 : 	if (pctxt->redefCounter != 0) {

	cmp	DWORD PTR [edi+124], 0
	je	SHORT $LN16@xmlSchemaP

; 7767 : 	    xmlChar *str = NULL;
; 7768 : 
; 7769 : 	    xmlSchemaCustomErr(ACTXT_CAST pctxt,

	push	0
	push	edx
	push	eax
	lea	eax, DWORD PTR _str$3[ebp]
	mov	DWORD PTR _str$3[ebp], 0
	push	eax
	call	_xmlSchemaFormatQName
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0HE@EDEMIIKM@The?5redefining?5attribute?5group?5@
	push	0
	push	ebx
	push	3081					; 00000c09H
	push	edi
	call	_xmlSchemaCustomErr
	add	esp, 28					; 0000001cH
$LN64@xmlSchemaP:

; 7697 :         return (NULL);

	mov	eax, DWORD PTR _str$3[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlSchemaP:

; 7804 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlSchemaP:

; 7770 : 		XML_SCHEMAP_SRC_REDEFINE, node, NULL,
; 7771 : 		"The redefining attribute group definition "
; 7772 : 		"'%s' must not contain more than one "
; 7773 : 		"reference to the redefined definition",
; 7774 : 		xmlSchemaFormatQName(&str, refNs, ref), NULL);
; 7775 : 	    FREE_AND_NULL(str);
; 7776 : 	    return(NULL);
; 7777 : 	}
; 7778 : 	pctxt->redefCounter++;
; 7779 : 	/*
; 7780 : 	* URGENT TODO: How to ensure that the reference will not be
; 7781 : 	* handled by the normal component resolution mechanism?
; 7782 : 	*/
; 7783 : 	ret = xmlSchemaNewQNameRef(pctxt,

	push	eax
	push	edx
	push	16					; 00000010H
	push	edi
	mov	DWORD PTR [edi+124], 1
	call	_xmlSchemaNewQNameRef
	mov	esi, eax
	add	esp, 16					; 00000010H

; 7784 : 	    XML_SCHEMA_TYPE_ATTRIBUTEGROUP, ref, refNs);
; 7785 : 	if (ret == NULL)

	test	esi, esi
	je	SHORT $LN5@xmlSchemaP

; 7786 : 	    return(NULL);
; 7787 : 	ret->node = node;

	mov	DWORD PTR [esi+20], ebx

; 7788 : 	pctxt->redef->reference = WXS_BASIC_CAST ret;

	mov	ecx, DWORD PTR [edi+120]
	pop	edi
	mov	DWORD PTR [ecx+8], esi

; 7804 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@xmlSchemaP:

; 7789 :     } else {
; 7790 : 	/*
; 7791 : 	* Create a QName-reference helper component. We will substitute this
; 7792 : 	* component for the attribute uses of the referenced attribute group
; 7793 : 	* definition.
; 7794 : 	*/
; 7795 : 	ret = xmlSchemaNewQNameRef(pctxt,

	mov	eax, DWORD PTR _refNs$[ebp]
$LN14@xmlSchemaP:
	push	eax
	push	edx
	push	16					; 00000010H
	push	edi
	call	_xmlSchemaNewQNameRef
	mov	esi, eax
	add	esp, 16					; 00000010H

; 7796 : 	    XML_SCHEMA_TYPE_ATTRIBUTEGROUP, ref, refNs);
; 7797 : 	if (ret == NULL)

	test	esi, esi
	je	SHORT $LN5@xmlSchemaP

; 7798 : 	    return(NULL);
; 7799 : 	ret->node = node;

	mov	DWORD PTR [esi+20], ebx

; 7800 : 	/* Add to pending items, to be able to resolve the reference. */
; 7801 : 	WXS_ADD_PENDING(pctxt, ret);

	mov	eax, DWORD PTR [edi+28]
	push	esi
	add	eax, 20					; 00000014H
	push	10					; 0000000aH
	push	eax
	call	_xmlSchemaAddItemSize
	add	esp, 12					; 0000000cH

; 7802 :     }
; 7803 :     return (ret);

	mov	eax, esi
	pop	edi

; 7804 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseAttributeGroupRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaComponentListFree
_TEXT	SEGMENT
_items$1$ = -8						; size = 4
_i$1$ = -4						; size = 4
_list$ = 8						; size = 4
_xmlSchemaComponentListFree PROC			; COMDAT

; 4056 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _list$[ebp]
	test	edi, edi
	je	$LN8@xmlSchemaC

; 4057 :     if ((list == NULL) || (list->nbItems == 0))

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	$LN8@xmlSchemaC

; 4058 : 	return;
; 4059 :     {
; 4060 : 	xmlSchemaTreeItemPtr item;
; 4061 : 	xmlSchemaTreeItemPtr *items = (xmlSchemaTreeItemPtr *) list->items;

	mov	ecx, DWORD PTR [edi]
	push	esi

; 4062 : 	int i;
; 4063 : 
; 4064 : 	for (i = 0; i < list->nbItems; i++) {

	xor	esi, esi
	mov	DWORD PTR _items$1$[ebp], ecx
	mov	DWORD PTR _i$1$[ebp], esi
	test	eax, eax
	jle	$LN3@xmlSchemaC
	mov	edx, OFFSET ??_C@_0BI@MHGDJJNC@complex?5type?5definition@
	push	ebx
$LL4@xmlSchemaC:

; 4065 : 	    item = items[i];

	mov	ebx, DWORD PTR [ecx+esi*4]

; 4066 : 	    if (item == NULL)

	test	ebx, ebx
	je	$LN2@xmlSchemaC

; 4067 : 		continue;
; 4068 : 	    switch (item->type) {

	mov	ecx, DWORD PTR [ebx]
	mov	eax, ecx
	cmp	eax, 2000				; 000007d0H
	jg	$LN26@xmlSchemaC
	je	$LN13@xmlSchemaC
	sub	eax, 2
	cmp	eax, 24					; 00000018H
	ja	$LN24@xmlSchemaC
	movzx	eax, BYTE PTR $LN95@xmlSchemaC[eax]
	jmp	DWORD PTR $LN102@xmlSchemaC[eax*4]
$LN10@xmlSchemaC:

; 4069 : 		case XML_SCHEMA_TYPE_SIMPLE:
; 4070 : 		case XML_SCHEMA_TYPE_COMPLEX:
; 4071 : 		    xmlSchemaFreeType((xmlSchemaTypePtr) item);

	push	ebx
	call	_xmlSchemaFreeType

; 4072 : 		    break;

	jmp	$LN98@xmlSchemaC
$LN11@xmlSchemaC:

; 3769 :     if (attr->annot != NULL)

	mov	eax, DWORD PTR [ebx+32]
	test	eax, eax
	je	SHORT $LN29@xmlSchemaC

; 3770 : 	xmlSchemaFreeAnnot(attr->annot);

	push	eax
	call	_xmlSchemaFreeAnnot
	add	esp, 4
$LN29@xmlSchemaC:

; 3771 :     if (attr->defVal != NULL)

	mov	eax, DWORD PTR [ebx+68]
	jmp	SHORT $LN100@xmlSchemaC
$LN12@xmlSchemaC:

; 3787 :     if (use->annot != NULL)

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN34@xmlSchemaC

; 3788 : 	xmlSchemaFreeAnnot(use->annot);

	push	eax
	call	_xmlSchemaFreeAnnot
	add	esp, 4
$LN34@xmlSchemaC:

; 3789 :     if (use->defVal != NULL)

	mov	eax, DWORD PTR [ebx+32]
	jmp	SHORT $LN100@xmlSchemaC
$LN14@xmlSchemaC:

; 3955 :     if (elem->annot != NULL)

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN42@xmlSchemaC

; 3956 :         xmlSchemaFreeAnnot(elem->annot);

	push	eax
	call	_xmlSchemaFreeAnnot
	add	esp, 4
$LN42@xmlSchemaC:

; 3957 :     if (elem->contModel != NULL)

	mov	eax, DWORD PTR [ebx+84]
	test	eax, eax
	je	SHORT $LN43@xmlSchemaC

; 3958 :         xmlRegFreeRegexp(elem->contModel);

	push	eax
	call	_xmlRegFreeRegexp
	add	esp, 4
$LN43@xmlSchemaC:

; 3959 :     if (elem->defVal != NULL)

	mov	eax, DWORD PTR [ebx+96]
$LN100@xmlSchemaC:

; 3805 :     xmlFree(prohib);

	test	eax, eax
	je	SHORT $LN13@xmlSchemaC
	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4
	jmp	SHORT $LN13@xmlSchemaC
$LN18@xmlSchemaC:

; 3857 :     if (attrGr->annot != NULL)

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN51@xmlSchemaC

; 3858 :         xmlSchemaFreeAnnot(attrGr->annot);

	push	eax
	call	_xmlSchemaFreeAnnot
	add	esp, 4
$LN51@xmlSchemaC:

; 3859 :     if (attrGr->attrUses != NULL)

	mov	esi, DWORD PTR [ebx+56]
	test	esi, esi
	je	SHORT $LN97@xmlSchemaC

; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN56@xmlSchemaC

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN56@xmlSchemaC:

; 3534 :     xmlFree(list);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN97@xmlSchemaC:

; 3805 :     xmlFree(prohib);

	mov	esi, DWORD PTR _i$1$[ebp]
$LN13@xmlSchemaC:
	push	ebx
	call	DWORD PTR _xmlFree
$LN98@xmlSchemaC:

; 4062 : 	int i;
; 4063 : 
; 4064 : 	for (i = 0; i < list->nbItems; i++) {

	add	esp, 4
$LN99@xmlSchemaC:
	mov	ecx, DWORD PTR _items$1$[ebp]
	mov	edx, OFFSET ??_C@_0BI@MHGDJJNC@complex?5type?5definition@
$LN2@xmlSchemaC:
	inc	esi
	mov	DWORD PTR _i$1$[ebp], esi
	cmp	esi, DWORD PTR [edi+4]
	jl	$LL4@xmlSchemaC
	pop	ebx
$LN3@xmlSchemaC:

; 4108 : 		case XML_SCHEMA_TYPE_IDC_KEY:
; 4109 : 		case XML_SCHEMA_TYPE_IDC_UNIQUE:
; 4110 : 		case XML_SCHEMA_TYPE_IDC_KEYREF:
; 4111 : 		    xmlSchemaFreeIDC((xmlSchemaIDCPtr) item);
; 4112 : 		    break;
; 4113 : 		case XML_SCHEMA_TYPE_NOTATION:
; 4114 : 		    xmlSchemaFreeNotation((xmlSchemaNotationPtr) item);
; 4115 : 		    break;
; 4116 : 		case XML_SCHEMA_EXTRA_QNAMEREF:
; 4117 : 		    xmlSchemaFreeQNameRef((xmlSchemaQNameRefPtr) item);
; 4118 : 		    break;
; 4119 : 		default: {
; 4120 : 		    /* TODO: This should never be hit. */
; 4121 : 		    xmlSchemaPSimpleInternalErr(NULL,
; 4122 : 			"Internal error: xmlSchemaComponentListFree, "
; 4123 : 			"unexpected component type '%s'\n",
; 4124 : 			(const xmlChar *) WXS_ITEM_TYPE_NAME(item));
; 4125 : 			 }
; 4126 : 		    break;
; 4127 : 	    }
; 4128 : 	}
; 4129 : 	list->nbItems = 0;

	mov	DWORD PTR [edi+4], 0
	pop	esi
$LN8@xmlSchemaC:
	pop	edi

; 4130 :     }
; 4131 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlSchemaC:

; 3805 :     xmlFree(prohib);

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN13@xmlSchemaC
	push	eax
	call	_xmlSchemaFreeAnnot
	add	esp, 4
	jmp	SHORT $LN13@xmlSchemaC
$LN20@xmlSchemaC:

; 4073 : 		case XML_SCHEMA_TYPE_ATTRIBUTE:
; 4074 : 		    xmlSchemaFreeAttribute((xmlSchemaAttributePtr) item);
; 4075 : 		    break;
; 4076 : 		case XML_SCHEMA_TYPE_ATTRIBUTE_USE:
; 4077 : 		    xmlSchemaFreeAttributeUse((xmlSchemaAttributeUsePtr) item);
; 4078 : 		    break;
; 4079 : 		case XML_SCHEMA_EXTRA_ATTR_USE_PROHIB:
; 4080 : 		    xmlSchemaFreeAttributeUseProhib(
; 4081 : 			(xmlSchemaAttributeUseProhibPtr) item);
; 4082 : 		    break;
; 4083 : 		case XML_SCHEMA_TYPE_ELEMENT:
; 4084 : 		    xmlSchemaFreeElement((xmlSchemaElementPtr) item);
; 4085 : 		    break;
; 4086 : 		case XML_SCHEMA_TYPE_PARTICLE:
; 4087 : 		    if (item->annot != NULL)
; 4088 : 			xmlSchemaFreeAnnot(item->annot);
; 4089 : 		    xmlFree(item);
; 4090 : 		    break;
; 4091 : 		case XML_SCHEMA_TYPE_SEQUENCE:
; 4092 : 		case XML_SCHEMA_TYPE_CHOICE:
; 4093 : 		case XML_SCHEMA_TYPE_ALL:
; 4094 : 		    xmlSchemaFreeModelGroup((xmlSchemaModelGroupPtr) item);
; 4095 : 		    break;
; 4096 : 		case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:
; 4097 : 		    xmlSchemaFreeAttributeGroup(
; 4098 : 			(xmlSchemaAttributeGroupPtr) item);
; 4099 : 		    break;
; 4100 : 		case XML_SCHEMA_TYPE_GROUP:
; 4101 : 		    xmlSchemaFreeModelGroupDef(
; 4102 : 			(xmlSchemaModelGroupDefPtr) item);
; 4103 : 		    break;
; 4104 : 		case XML_SCHEMA_TYPE_ANY:
; 4105 : 		case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:
; 4106 : 		    xmlSchemaFreeWildcard((xmlSchemaWildcardPtr) item);

	push	ebx
	call	_xmlSchemaFreeWildcard

; 4107 : 		    break;

	jmp	SHORT $LN98@xmlSchemaC
$LN21@xmlSchemaC:

; 3922 :     if (idcDef->annot != NULL)

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN66@xmlSchemaC

; 3923 :         xmlSchemaFreeAnnot(idcDef->annot);

	push	eax
	call	_xmlSchemaFreeAnnot
	add	esp, 4
$LN66@xmlSchemaC:

; 3924 :     /* Selector */
; 3925 :     if (idcDef->selector != NULL) {

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN67@xmlSchemaC

; 3926 : 	if (idcDef->selector->xpathComp != NULL)

	mov	ecx, DWORD PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN68@xmlSchemaC

; 3927 : 	    xmlFreePattern((xmlPatternPtr) idcDef->selector->xpathComp);

	push	ecx
	call	_xmlFreePattern
	mov	eax, DWORD PTR [ebx+24]
	add	esp, 4
$LN68@xmlSchemaC:

; 3928 : 	xmlFree(idcDef->selector);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN67@xmlSchemaC:

; 3929 :     }
; 3930 :     /* Fields */
; 3931 :     if (idcDef->fields != NULL) {

	mov	esi, DWORD PTR [ebx+28]
	test	esi, esi
	je	$LN97@xmlSchemaC
	npad	5
$LL64@xmlSchemaC:

; 3932 : 	cur = idcDef->fields;
; 3933 : 	do {
; 3934 : 	    prev = cur;

	mov	edi, esi

; 3935 : 	    cur = cur->next;

	mov	esi, DWORD PTR [esi]

; 3936 : 	    if (prev->xpathComp != NULL)

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN70@xmlSchemaC

; 3937 : 		xmlFreePattern((xmlPatternPtr) prev->xpathComp);

	push	eax
	call	_xmlFreePattern
	add	esp, 4
$LN70@xmlSchemaC:

; 3938 : 	    xmlFree(prev);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3939 : 	} while (cur != NULL);

	test	esi, esi
	jne	SHORT $LL64@xmlSchemaC
	mov	edi, DWORD PTR _list$[ebp]
	jmp	$LN97@xmlSchemaC
$LN26@xmlSchemaC:

; 4067 : 		continue;
; 4068 : 	    switch (item->type) {

	cmp	eax, 2001				; 000007d1H
	je	$LN13@xmlSchemaC
$LN24@xmlSchemaC:

; 1183 :     switch (item->type) {

	mov	eax, ecx
	sub	eax, 1
	je	SHORT $LN80@xmlSchemaC

; 1186 : 		return(BAD_CAST "complex type definition");
; 1187 : 	    else
; 1188 : 		return(BAD_CAST "simple type definition");
; 1189 : 	default:
; 1190 : 	    return(xmlSchemaItemTypeToStr(item->type));

	push	ecx
	call	_xmlSchemaItemTypeToStr
	add	esp, 4
	jmp	SHORT $LN83@xmlSchemaC
$LN80@xmlSchemaC:

; 1184 : 	case XML_SCHEMA_TYPE_BASIC:
; 1185 : 	    if (WXS_IS_COMPLEX(WXS_TYPE_CAST item))

	cmp	DWORD PTR [ebx+88], 45			; 0000002dH
	mov	eax, OFFSET ??_C@_0BH@BIKOCJPH@simple?5type?5definition@
	cmove	eax, edx
$LN83@xmlSchemaC:

; 2018 :      __xmlSimpleError(XML_FROM_SCHEMASP, XML_SCHEMAP_INTERNAL, node,

	push	eax
	push	OFFSET ??_C@_0EM@EBPFONFN@Internal?5error?3?5xmlSchemaCompon@
	push	0
	push	3069					; 00000bfdH
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
	jmp	$LN99@xmlSchemaC
	npad	1
$LN102@xmlSchemaC:

; 4130 :     }
; 4131 : }

	DD	$LN20@xmlSchemaC
	DD	$LN10@xmlSchemaC
	DD	$LN19@xmlSchemaC
	DD	$LN14@xmlSchemaC
	DD	$LN11@xmlSchemaC
	DD	$LN18@xmlSchemaC
	DD	$LN13@xmlSchemaC
	DD	$LN21@xmlSchemaC
	DD	$LN12@xmlSchemaC
	DD	$LN24@xmlSchemaC
$LN95@xmlSchemaC:
	DB	0
	DB	9
	DB	1
	DB	1
	DB	2
	DB	2
	DB	2
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	3
	DB	4
	DB	5
	DB	2
	DB	6
	DB	9
	DB	9
	DB	0
	DB	7
	DB	7
	DB	7
	DB	2
	DB	8
_xmlSchemaComponentListFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckElementDeclComponent
_TEXT	SEGMENT
_elemDecl$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_xmlSchemaCheckElementDeclComponent PROC		; COMDAT

; 20034: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _elemDecl$[ebp]
	test	esi, esi
	je	SHORT $LN4@xmlSchemaC

; 20035:     if (elemDecl == NULL)
; 20036: 	return;
; 20037:     if (elemDecl->flags & XML_SCHEMAS_ELEM_INTERNAL_CHECKED)

	mov	eax, DWORD PTR [esi+48]
	test	eax, 262144				; 00040000H
	jne	SHORT $LN4@xmlSchemaC

; 20038: 	return;
; 20039:     elemDecl->flags |= XML_SCHEMAS_ELEM_INTERNAL_CHECKED;
; 20040:     if (xmlSchemaCheckElemPropsCorrect(ctxt, elemDecl) == 0) {

	push	esi
	push	DWORD PTR _ctxt$[ebp]
	or	eax, 262144				; 00040000H
	mov	DWORD PTR [esi+48], eax
	call	_xmlSchemaCheckElemPropsCorrect
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@xmlSchemaC

; 20041: 	/*
; 20042: 	* Adds substitution group members.
; 20043: 	*/
; 20044: 	xmlSchemaCheckElemSubstGroup(ctxt, elemDecl);

	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaCheckElemSubstGroup
	add	esp, 8
$LN4@xmlSchemaC:
	pop	esi

; 20045:     }
; 20046: }

	pop	ebp
	ret	0
_xmlSchemaCheckElementDeclComponent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckCOSSTDerivedOK
_TEXT	SEGMENT
_actxt$ = 8						; size = 4
_type$ = 12						; size = 4
_baseType$ = 16						; size = 4
_subset$ = 20						; size = 4
_xmlSchemaCheckCOSSTDerivedOK PROC			; COMDAT

; 14845: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _type$[ebp]
	mov	esi, DWORD PTR _baseType$[ebp]
	cmp	edi, esi
	je	$LN28@xmlSchemaC

; 14846:     /*
; 14847:     * 1 They are the same type definition.
; 14848:     * TODO: The identy check might have to be more complex than this.
; 14849:     */
; 14850:     if (type == baseType)
; 14851: 	return (0);
; 14852:     /*
; 14853:     * 2.1 restriction is not in the subset, or in the {final}
; 14854:     * of its own {base type definition};
; 14855:     *
; 14856:     * NOTE that this will be used also via "xsi:type".
; 14857:     *
; 14858:     * TODO: Revise this, it looks strange. How can the "type"
; 14859:     * not be fixed or *in* fixing?
; 14860:     */
; 14861:     if (WXS_IS_TYPE_NOT_FIXED(type))

	cmp	DWORD PTR [edi], 1
	mov	ebx, DWORD PTR _actxt$[ebp]
	je	SHORT $LN6@xmlSchemaC
	test	DWORD PTR [edi+48], 4194304		; 00400000H
	jne	SHORT $LN6@xmlSchemaC

; 14862: 	if (xmlSchemaTypeFixup(type, actxt) == -1)

	push	ebx
	push	edi
	call	_xmlSchemaTypeFixup
	add	esp, 8
	cmp	eax, -1
	je	$LN27@xmlSchemaC
$LN6@xmlSchemaC:

; 14863: 	    return(-1);
; 14864:     if (WXS_IS_TYPE_NOT_FIXED(baseType))

	cmp	DWORD PTR [esi], 1
	je	SHORT $LN8@xmlSchemaC
	test	DWORD PTR [esi+48], 4194304		; 00400000H
	jne	SHORT $LN8@xmlSchemaC

; 14865: 	if (xmlSchemaTypeFixup(baseType, actxt) == -1)

	push	ebx
	push	esi
	call	_xmlSchemaTypeFixup
	add	esp, 8
	cmp	eax, -1
	je	$LN27@xmlSchemaC
$LN8@xmlSchemaC:

; 14866: 	    return(-1);
; 14867:     if ((subset & SUBSET_RESTRICTION) ||

	mov	ecx, DWORD PTR _subset$[ebp]
	test	cl, 1
	jne	$LN10@xmlSchemaC
	mov	eax, DWORD PTR [edi+64]

; 14652:     if (type == NULL)

	test	eax, eax
	je	SHORT $LN23@xmlSchemaC

; 14653: 	return (0);
; 14654:     if (type->flags & final)

	test	DWORD PTR [eax+48], 1024		; 00000400H
	jne	$LN10@xmlSchemaC
$LN23@xmlSchemaC:

; 14868: 	(xmlSchemaTypeFinalContains(type->baseType,
; 14869: 	    XML_SCHEMAS_TYPE_FINAL_RESTRICTION))) {
; 14870: 	return (XML_SCHEMAP_COS_ST_DERIVED_OK_2_1);
; 14871:     }
; 14872:     /* 2.2 */
; 14873:     if (type->baseType == baseType) {

	cmp	eax, esi
	je	$LN28@xmlSchemaC

; 14874: 	/*
; 14875: 	* 2.2.1 D's `base type definition` is B.
; 14876: 	*/
; 14877: 	return (0);
; 14878:     }
; 14879:     /*
; 14880:     * 2.2.2 D's `base type definition` is not the `ur-type definition`
; 14881:     * and is validly derived from B given the subset, as defined by this
; 14882:     * constraint.
; 14883:     */
; 14884:     if ((! WXS_IS_ANYTYPE(type->baseType)) &&

	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN13@xmlSchemaC
	cmp	DWORD PTR [eax+88], 45			; 0000002dH
	je	SHORT $LN12@xmlSchemaC
$LN13@xmlSchemaC:
	push	ecx
	push	esi
	push	eax
	push	ebx
	call	_xmlSchemaCheckCOSSTDerivedOK
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN28@xmlSchemaC
$LN12@xmlSchemaC:

; 14885: 	(xmlSchemaCheckCOSSTDerivedOK(actxt, type->baseType,
; 14886: 	    baseType, subset) == 0)) {
; 14887: 	return (0);
; 14888:     }
; 14889:     /*
; 14890:     * 2.2.3 D's {variety} is list or union and B is the `simple ur-type
; 14891:     * definition`.
; 14892:     */
; 14893:     if (WXS_IS_ANY_SIMPLE_TYPE(baseType) &&

	cmp	DWORD PTR [esi], 1
	jne	SHORT $LN14@xmlSchemaC
	cmp	DWORD PTR [esi+88], 46			; 0000002eH
	jne	SHORT $LN14@xmlSchemaC
	test	BYTE PTR [edi+48], 192			; 000000c0H
	jne	SHORT $LN28@xmlSchemaC
$LN14@xmlSchemaC:

; 14894: 	(WXS_IS_LIST(type) || WXS_IS_UNION(type))) {
; 14895: 	return (0);
; 14896:     }
; 14897:     /*
; 14898:     * 2.2.4 B's {variety} is union and D is validly derived from a type
; 14899:     * definition in B's {member type definitions} given the subset, as
; 14900:     * defined by this constraint.
; 14901:     *
; 14902:     * NOTE: This seems not to involve built-in types, since there is no
; 14903:     * built-in Union Simple Type.
; 14904:     */
; 14905:     if (WXS_IS_UNION(baseType)) {

	test	BYTE PTR [esi+48], 128			; 00000080H
	je	SHORT $LN33@xmlSchemaC

; 14906: 	xmlSchemaTypeLinkPtr cur;
; 14907: 
; 14908: 	cur = baseType->memberTypes;

	mov	esi, DWORD PTR [esi+92]

; 14909: 	while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN33@xmlSchemaC
$LL2@xmlSchemaC:

; 14910: 	    if (WXS_IS_TYPE_NOT_FIXED(cur->type))

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax], 1
	je	SHORT $LN18@xmlSchemaC
	test	DWORD PTR [eax+48], 4194304		; 00400000H
	jne	SHORT $LN18@xmlSchemaC

; 14911: 		if (xmlSchemaTypeFixup(cur->type, actxt) == -1)

	push	ebx
	push	eax
	call	_xmlSchemaTypeFixup
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN27@xmlSchemaC
$LN18@xmlSchemaC:

; 14912: 		    return(-1);
; 14913: 	    if (xmlSchemaCheckCOSSTDerivedOK(actxt,
; 14914: 		    type, cur->type, subset) == 0)

	push	DWORD PTR _subset$[ebp]
	push	DWORD PTR [esi+4]
	push	edi
	push	ebx
	call	_xmlSchemaCheckCOSSTDerivedOK
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN28@xmlSchemaC

; 14915: 	    {
; 14916: 		/*
; 14917: 		* It just has to be validly derived from at least one
; 14918: 		* member-type.
; 14919: 		*/
; 14920: 		return (0);
; 14921: 	    }
; 14922: 	    cur = cur->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaC
$LN33@xmlSchemaC:
	pop	edi

; 14923: 	}
; 14924:     }
; 14925:     return (XML_SCHEMAP_COS_ST_DERIVED_OK_2_2);
; 14926: }

	pop	esi
	mov	eax, 3032				; 00000bd8H
	pop	ebx
	pop	ebp
	ret	0
$LN27@xmlSchemaC:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN10@xmlSchemaC:
	pop	edi
	pop	esi
	mov	eax, 3031				; 00000bd7H
	pop	ebx
	pop	ebp
	ret	0
$LN28@xmlSchemaC:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaCheckCOSSTDerivedOK ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaInternalErr
_TEXT	SEGMENT
_actxt$ = 8						; size = 4
_funcName$ = 12						; size = 4
_message$ = 16						; size = 4
_xmlSchemaInternalErr PROC				; COMDAT

; 2313 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	0
	push	DWORD PTR _message$[ebp]
	push	DWORD PTR _funcName$[ebp]
	push	DWORD PTR _actxt$[ebp]
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);
; 2315 : }

	pop	ebp
	ret	0
_xmlSchemaInternalErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetUnionSimpleTypeMemberTypes
_TEXT	SEGMENT
_type$ = 8						; size = 4
_xmlSchemaGetUnionSimpleTypeMemberTypes PROC		; COMDAT

; 14669: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaG
$LL2@xmlSchemaG:

; 14670:     while ((type != NULL) && (type->type == XML_SCHEMA_TYPE_SIMPLE)) {

	cmp	DWORD PTR [eax], 4
	jne	SHORT $LN3@xmlSchemaG

; 14671: 	if (type->memberTypes != NULL)

	mov	ecx, DWORD PTR [eax+92]
	test	ecx, ecx
	jne	SHORT $LN8@xmlSchemaG

; 14673: 	else
; 14674: 	    type = type->baseType;

	mov	eax, DWORD PTR [eax+64]
	test	eax, eax
	jne	SHORT $LL2@xmlSchemaG
$LN3@xmlSchemaG:

; 14675:     }
; 14676:     return (NULL);

	xor	eax, eax

; 14677: }

	pop	ebp
	ret	0
$LN8@xmlSchemaG:

; 14672: 	    return (type->memberTypes);

	mov	eax, ecx

; 14677: }

	pop	ebp
	ret	0
_xmlSchemaGetUnionSimpleTypeMemberTypes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetComponentTypeStr
_TEXT	SEGMENT
_item$ = 8						; size = 4
_xmlSchemaGetComponentTypeStr PROC			; COMDAT

; 1182 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	eax, ecx
	sub	eax, 1
	je	SHORT $LN4@xmlSchemaG

; 1186 : 		return(BAD_CAST "complex type definition");
; 1187 : 	    else
; 1188 : 		return(BAD_CAST "simple type definition");
; 1189 : 	default:
; 1190 : 	    return(xmlSchemaItemTypeToStr(item->type));

	mov	DWORD PTR _item$[ebp], ecx

; 1191 :     }
; 1192 : }

	pop	ebp

; 1186 : 		return(BAD_CAST "complex type definition");
; 1187 : 	    else
; 1188 : 		return(BAD_CAST "simple type definition");
; 1189 : 	default:
; 1190 : 	    return(xmlSchemaItemTypeToStr(item->type));

	jmp	_xmlSchemaItemTypeToStr
$LN4@xmlSchemaG:

; 1183 :     switch (item->type) {
; 1184 : 	case XML_SCHEMA_TYPE_BASIC:
; 1185 : 	    if (WXS_IS_COMPLEX(WXS_TYPE_CAST item))

	cmp	DWORD PTR [edx+88], 45			; 0000002dH
	mov	eax, OFFSET ??_C@_0BH@BIKOCJPH@simple?5type?5definition@
	mov	ecx, OFFSET ??_C@_0BI@MHGDJJNC@complex?5type?5definition@
	cmove	eax, ecx

; 1191 :     }
; 1192 : }

	pop	ebp
	ret	0
_xmlSchemaGetComponentTypeStr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseModelGroup
_TEXT	SEGMENT
_particle$1$ = -28					; size = 4
_last$1$ = -24						; size = 4
_last$1$ = -20						; size = 4
_str$1 = -20						; size = 4
_str$2 = -20						; size = 4
_max$1$ = -16						; size = 4
_des$3 = -12						; size = 4
_des$4 = -12						; size = 4
_isElemRef$ = -12					; size = 4
_min$1$ = -8						; size = 4
_hasRefs$1$ = -4					; size = 4
_item$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_type$ = 20						; size = 4
_withParticle$ = 24					; size = 4
_xmlSchemaParseModelGroup PROC				; COMDAT

; 11255: {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _particle$1$[ebp], 0
	mov	DWORD PTR _min$1$[ebp], 1
	mov	DWORD PTR _max$1$[ebp], 1
	mov	DWORD PTR _hasRefs$1$[ebp], 0
	test	ebx, ebx
	je	$LN11@xmlSchemaP

; 11256:     xmlSchemaModelGroupPtr item;
; 11257:     xmlSchemaParticlePtr particle = NULL;
; 11258:     xmlNodePtr child = NULL;
; 11259:     xmlAttrPtr attr;
; 11260:     int min = 1, max = 1, isElemRef, hasRefs = 0;
; 11261: 
; 11262:     if ((ctxt == NULL) || (schema == NULL) || (node == NULL))

	mov	eax, DWORD PTR _schema$[ebp]
	test	eax, eax
	je	$LN11@xmlSchemaP
	mov	ecx, DWORD PTR _node$[ebp]
	test	ecx, ecx
	je	$LN11@xmlSchemaP

; 11263:         return (NULL);
; 11264:     /*
; 11265:     * Create a model group with the given compositor.
; 11266:     */
; 11267:     item = xmlSchemaAddModelGroup(ctxt, schema, type, node);

	mov	edi, DWORD PTR _type$[ebp]
	push	ecx
	push	edi
	push	eax
	push	ebx
	call	_xmlSchemaAddModelGroup
	mov	esi, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _item$1$[ebp], esi

; 11268:     if (item == NULL)

	test	esi, esi
	je	$LN11@xmlSchemaP

; 11269: 	return (NULL);
; 11270: 
; 11271:     if (withParticle) {

	cmp	DWORD PTR _withParticle$[ebp], 0
	je	$LN13@xmlSchemaP

; 11272: 	if (type == XML_SCHEMA_TYPE_ALL) {
; 11273: 	    min = xmlGetMinOccurs(ctxt, node, 0, 1, 1, "(0 | 1)");
; 11274: 	    max = xmlGetMaxOccurs(ctxt, node, 1, 1, 1, "1");
; 11275: 	} else {
; 11276: 	    /* choice + sequence */
; 11277: 	    min = xmlGetMinOccurs(ctxt, node, 0, -1, 1, "xs:nonNegativeInteger");
; 11278: 	    max = xmlGetMaxOccurs(ctxt, node, 0, UNBOUNDED, 1,
; 11279: 		"(xs:nonNegativeInteger | unbounded)");
; 11280: 	}
; 11281: 	xmlSchemaPCheckParticleCorrect_2(ctxt, NULL, node, min, max);

	cmp	edi, 8
	mov	ecx, OFFSET ??_C@_07OCHOELKN@?$CI0?5?$HM?51?$CJ@
	mov	eax, OFFSET ??_C@_0BG@FKFDAFPO@xs?3nonNegativeInteger@
	cmove	eax, ecx
	push	eax
	xor	eax, eax
	cmp	edi, 8
	push	1
	sete	al
	lea	eax, DWORD PTR [eax*2-1]
	push	eax
	push	0
	push	DWORD PTR _node$[ebp]
	push	ebx
	call	_xmlGetMinOccurs
	mov	DWORD PTR _min$1$[ebp], eax
	cmp	edi, 8
	mov	ecx, OFFSET ??_C@_01HIHLOKLC@1@
	mov	eax, OFFSET ??_C@_0CE@BEMOBFLH@?$CIxs?3nonNegativeInteger?5?$HM?5unboun@
	cmove	eax, ecx
	mov	ecx, 1073741824				; 40000000H
	push	eax
	push	1
	mov	eax, 1
	cmovne	eax, ecx
	push	eax
	xor	eax, eax
	cmp	edi, 8
	sete	al
	push	eax
	push	DWORD PTR _node$[ebp]
	push	ebx
	call	_xmlGetMaxOccurs
	push	eax
	push	DWORD PTR _min$1$[ebp]
	mov	DWORD PTR _max$1$[ebp], eax
	push	DWORD PTR _node$[ebp]
	push	0
	push	ebx
	call	_xmlSchemaPCheckParticleCorrect_2
	add	esp, 68					; 00000044H

; 11282: 	/*
; 11283: 	* Create a particle
; 11284: 	*/
; 11285: 	particle = xmlSchemaAddParticle(ctxt, node, min, max);

	push	DWORD PTR _max$1$[ebp]
	push	DWORD PTR _min$1$[ebp]
	push	DWORD PTR _node$[ebp]
	push	ebx
	call	_xmlSchemaAddParticle
	add	esp, 16					; 00000010H
	mov	DWORD PTR _particle$1$[ebp], eax

; 11286: 	if (particle == NULL)

	test	eax, eax
	je	$LN11@xmlSchemaP

; 11287: 	    return (NULL);
; 11288: 	particle->children = (xmlSchemaTreeItemPtr) item;

	mov	DWORD PTR [eax+12], esi

; 11289: 	/*
; 11290: 	* Check for illegal attributes.
; 11291: 	*/
; 11292: 	attr = node->properties;

	mov	eax, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [eax+44]

; 11293: 	while (attr != NULL) {

	test	esi, esi
	je	$LN5@xmlSchemaP
	npad	3
$LL2@xmlSchemaP:

; 11294: 	    if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN18@xmlSchemaP

; 11295: 		if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
; 11296: 		    (!xmlStrEqual(attr->name, BAD_CAST "maxOccurs")) &&

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@xmlSchemaP
	push	OFFSET ??_C@_09OBPGLENH@maxOccurs@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@xmlSchemaP
	push	OFFSET ??_C@_09OAPKCOGD@minOccurs@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@xmlSchemaP

; 11297: 		    (!xmlStrEqual(attr->name, BAD_CAST "minOccurs"))) {
; 11298: 		    xmlSchemaPIllegalAttrErr(ctxt,
; 11299: 			XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 11300: 		}

	jmp	SHORT $LN139@xmlSchemaP
$LN18@xmlSchemaP:

; 11301: 	    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@xmlSchemaP
$LN139@xmlSchemaP:

; 11302: 		xmlSchemaPIllegalAttrErr(ctxt,
; 11303: 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 11304: 	    }
; 11305: 	    attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	ebx
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN21@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaP

; 11306: 	}
; 11307:     } else {

	jmp	SHORT $LN5@xmlSchemaP
$LN13@xmlSchemaP:

; 11308: 	/*
; 11309: 	* Check for illegal attributes.
; 11310: 	*/
; 11311: 	attr = node->properties;

	mov	eax, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [eax+44]

; 11312: 	while (attr != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlSchemaP
	npad	2
$LL4@xmlSchemaP:

; 11313: 	    if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN22@xmlSchemaP

; 11314: 		if (!xmlStrEqual(attr->name, BAD_CAST "id")) {

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@xmlSchemaP

; 11315: 		    xmlSchemaPIllegalAttrErr(ctxt,
; 11316: 			XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 11317: 		}

	jmp	SHORT $LN140@xmlSchemaP
$LN22@xmlSchemaP:

; 11318: 	    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlSchemaP
$LN140@xmlSchemaP:

; 11319: 		xmlSchemaPIllegalAttrErr(ctxt,
; 11320: 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 11321: 	    }
; 11322: 	    attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	ebx
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN25@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL4@xmlSchemaP
$LN5@xmlSchemaP:

; 11323: 	}
; 11324:     }
; 11325: 
; 11326:     /*
; 11327:     * Extract and validate attributes.
; 11328:     */
; 11329:     xmlSchemaPValAttrID(ctxt, node, BAD_CAST "id");

	mov	esi, DWORD PTR _node$[ebp]
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	esi
	push	ebx
	call	_xmlSchemaPValAttrID

; 11330:     /*
; 11331:     * And now for the children...
; 11332:     */
; 11333:     child = node->children;

	mov	esi, DWORD PTR [esi+12]
	add	esp, 12					; 0000000cH

; 11334:     if (IS_SCHEMA(child, "annotation")) {

	test	esi, esi
	je	SHORT $LN26@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN26@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN26@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN26@xmlSchemaP

; 11335:         item->annot = xmlSchemaParseAnnotation(ctxt, child, 1);

	push	1
	push	esi
	push	ebx
	call	_xmlSchemaParseAnnotation
	mov	ecx, DWORD PTR _item$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+4], eax

; 11336:         child = child->next;

	mov	esi, DWORD PTR [esi+24]
$LN26@xmlSchemaP:

; 11337:     }
; 11338:     if (type == XML_SCHEMA_TYPE_ALL) {

	cmp	edi, 8
	jne	$LN27@xmlSchemaP

; 11339: 	xmlSchemaParticlePtr part, last = NULL;

	mov	DWORD PTR _last$1$[ebp], 0

; 11340: 
; 11341: 	while (IS_SCHEMA(child, "element")) {

	test	esi, esi
	je	$LN103@xmlSchemaP
$LL6@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN138@xmlSchemaP
	push	OFFSET ??_C@_07HCLJNICE@element@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN138@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN138@xmlSchemaP

; 11342: 	    part = (xmlSchemaParticlePtr) xmlSchemaParseElement(ctxt,

	push	0
	lea	eax, DWORD PTR _isElemRef$[ebp]
	push	eax
	push	esi
	push	DWORD PTR _schema$[ebp]
	push	ebx
	call	_xmlSchemaParseElement
	mov	edi, eax
	add	esp, 20					; 00000014H

; 11343: 		schema, child, &isElemRef, 0);
; 11344: 	    /*
; 11345: 	    * SPEC cos-all-limited (2)
; 11346: 	    * "The {max occurs} of all the particles in the {particles}
; 11347: 	    * of the ('all') group must be 0 or 1.
; 11348: 	    */
; 11349: 	    if (part != NULL) {

	test	edi, edi
	je	SHORT $LN29@xmlSchemaP

; 11350: 		if (isElemRef)

	cmp	DWORD PTR _isElemRef$[ebp], 0
	je	SHORT $LN30@xmlSchemaP

; 11351: 		    hasRefs++;

	inc	DWORD PTR _hasRefs$1$[ebp]
$LN30@xmlSchemaP:

; 11352: 		if (part->minOccurs > 1) {

	cmp	DWORD PTR [edi+16], 1
	jle	SHORT $LN31@xmlSchemaP

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CN@GPAMDNEI@Invalid?5value?5for?5minOccurs?5?$CImu@
	push	esi
	push	0
	push	3091					; 00000c13H
	push	ebx
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 11353: 		    xmlSchemaPCustomErr(ctxt,
; 11354: 			XML_SCHEMAP_COS_ALL_LIMITED,
; 11355: 			NULL, child,
; 11356: 			"Invalid value for minOccurs (must be 0 or 1)",
; 11357: 			NULL);
; 11358: 		    /* Reset to 1. */
; 11359: 		    part->minOccurs = 1;

	mov	DWORD PTR [edi+16], 1
$LN31@xmlSchemaP:

; 11360: 		}
; 11361: 		if (part->maxOccurs > 1) {

	cmp	DWORD PTR [edi+20], 1
	jle	SHORT $LN32@xmlSchemaP

; 2981 :     xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CN@JOJFLDM@Invalid?5value?5for?5maxOccurs?5?$CImu@
	push	esi
	push	0
	push	3091					; 00000c13H
	push	ebx
	call	_xmlSchemaPCustomErrExt
	add	esp, 32					; 00000020H

; 11362: 		    xmlSchemaPCustomErr(ctxt,
; 11363: 			XML_SCHEMAP_COS_ALL_LIMITED,
; 11364: 			NULL, child,
; 11365: 			"Invalid value for maxOccurs (must be 0 or 1)",
; 11366: 			NULL);
; 11367: 		    /* Reset to 1. */
; 11368: 		    part->maxOccurs = 1;

	mov	DWORD PTR [edi+20], 1
$LN32@xmlSchemaP:

; 11369: 		}
; 11370: 		if (last == NULL)

	mov	eax, DWORD PTR _last$1$[ebp]
	test	eax, eax
	jne	SHORT $LN33@xmlSchemaP

; 11371: 		    item->children = (xmlSchemaTreeItemPtr) part;

	mov	eax, DWORD PTR _item$1$[ebp]
	mov	DWORD PTR [eax+12], edi
	jmp	SHORT $LN34@xmlSchemaP
$LN33@xmlSchemaP:

; 11372: 		else
; 11373: 		    last->next = (xmlSchemaTreeItemPtr) part;

	mov	DWORD PTR [eax+8], edi
$LN34@xmlSchemaP:

; 11374: 		last = part;

	mov	DWORD PTR _last$1$[ebp], edi
$LN29@xmlSchemaP:

; 11375: 	    }
; 11376: 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	$LL6@xmlSchemaP
$LN138@xmlSchemaP:

; 11377: 	}
; 11378: 	if (child != NULL) {

	test	esi, esi
	je	$LN103@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$4[ebp]
	mov	DWORD PTR _des$4[ebp], 0
	push	0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0CG@DCDFMCOM@?$CIannotation?$DP?0?5?$CIannotation?$DP?0?5ele@

; 11379: 	    xmlSchemaPContentErr(ctxt,
; 11380: 		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 11381: 		NULL, node, child, NULL,
; 11382: 		"(annotation?, (annotation?, element*)");
; 11383: 	}
; 11384:     } else {

	jmp	$LN143@xmlSchemaP
$LN27@xmlSchemaP:

; 11385: 	/* choice + sequence */
; 11386: 	xmlSchemaTreeItemPtr part = NULL, last = NULL;

	xor	edi, edi
	mov	DWORD PTR _last$1$[ebp], edi
$LL8@xmlSchemaP:

; 11387: 
; 11388: 	while ((IS_SCHEMA(child, "element")) ||
; 11389: 	    (IS_SCHEMA(child, "group")) ||
; 11390: 	    (IS_SCHEMA(child, "any")) ||
; 11391: 	    (IS_SCHEMA(child, "choice")) ||

	test	esi, esi
	je	$LN103@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	$LN9@xmlSchemaP
	push	OFFSET ??_C@_07HCLJNICE@element@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN37@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN36@xmlSchemaP
$LN37@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN9@xmlSchemaP
	push	OFFSET ??_C@_05MGJOOGAJ@group@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN38@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN36@xmlSchemaP
$LN38@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN9@xmlSchemaP
	push	OFFSET ??_C@_03OBJFJEBA@any@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN39@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN36@xmlSchemaP
$LN39@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN9@xmlSchemaP
	push	OFFSET ??_C@_06DDDNEJEA@choice@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN40@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN36@xmlSchemaP
$LN40@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN9@xmlSchemaP
	push	OFFSET ??_C@_08IBBDGPOF@sequence@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN9@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN9@xmlSchemaP
$LN36@xmlSchemaP:

; 11392: 	    (IS_SCHEMA(child, "sequence"))) {
; 11393: 
; 11394: 	    if (IS_SCHEMA(child, "element")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN59@xmlSchemaP
	push	OFFSET ??_C@_07HCLJNICE@element@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN41@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN41@xmlSchemaP

; 11395: 		part = (xmlSchemaTreeItemPtr)

	push	0
	lea	eax, DWORD PTR _isElemRef$[ebp]
	push	eax
	push	esi
	push	DWORD PTR _schema$[ebp]
	push	ebx
	call	_xmlSchemaParseElement
	mov	edi, eax
	add	esp, 20					; 00000014H

; 11396: 		    xmlSchemaParseElement(ctxt, schema, child, &isElemRef, 0);
; 11397: 		if (part && isElemRef)

	test	edi, edi
	je	$LN60@xmlSchemaP
	cmp	DWORD PTR _isElemRef$[ebp], 0
	je	$LN59@xmlSchemaP

; 11398: 		    hasRefs++;

	inc	DWORD PTR _hasRefs$1$[ebp]

; 11399: 	    } else if (IS_SCHEMA(child, "group")) {

	jmp	$LN59@xmlSchemaP
$LN41@xmlSchemaP:
	cmp	DWORD PTR [esi+36], 0
	je	$LN59@xmlSchemaP
	push	OFFSET ??_C@_05MGJOOGAJ@group@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN44@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN44@xmlSchemaP

; 11400: 		part =

	push	esi
	push	DWORD PTR _schema$[ebp]
	push	ebx
	call	_xmlSchemaParseModelGroupDefRef
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 11401: 		    xmlSchemaParseModelGroupDefRef(ctxt, schema, child);
; 11402: 		if (part != NULL)

	test	edi, edi
	je	SHORT $LN46@xmlSchemaP

; 11403: 		    hasRefs++;

	inc	DWORD PTR _hasRefs$1$[ebp]
$LN46@xmlSchemaP:

; 11404: 		/*
; 11405: 		* Handle redefinitions.
; 11406: 		*/
; 11407: 		if (ctxt->isRedefine && ctxt->redef &&
; 11408: 		    (ctxt->redef->item->type == XML_SCHEMA_TYPE_GROUP) &&
; 11409: 		    part && part->children)

	cmp	DWORD PTR [ebx+100], 0
	je	$LN59@xmlSchemaP
	mov	ecx, DWORD PTR [ebx+120]
	test	ecx, ecx
	je	$LN59@xmlSchemaP
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax], 17			; 00000011H
	jne	$LN59@xmlSchemaP
	test	edi, edi
	je	$LN60@xmlSchemaP
	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	$LN59@xmlSchemaP

; 11410: 		{
; 11411: 		    if ((xmlSchemaGetQNameRefName(part->children) ==
; 11412: 			    ctxt->redef->refName) &&

	mov	edx, DWORD PTR [ecx+16]
	cmp	DWORD PTR [eax+12], edx
	jne	$LN59@xmlSchemaP
	mov	ecx, DWORD PTR [ecx+20]
	cmp	DWORD PTR [eax+16], ecx
	jne	$LN59@xmlSchemaP

; 11413: 			(xmlSchemaGetQNameRefTargetNs(part->children) ==
; 11414: 			    ctxt->redef->refTargetNs))
; 11415: 		    {
; 11416: 			/*
; 11417: 			* SPEC src-redefine:
; 11418: 			* (6.1) "If it has a <group> among its contents at
; 11419: 			* some level the `actual value` of whose ref
; 11420: 			* [attribute] is the same as the `actual value` of
; 11421: 			* its own name attribute plus target namespace, then
; 11422: 			* all of the following must be true:"
; 11423: 			* (6.1.1) "It must have exactly one such group."
; 11424: 			*/
; 11425: 			if (ctxt->redefCounter != 0) {

	cmp	DWORD PTR [ebx+124], 0
	je	SHORT $LN49@xmlSchemaP

; 11426: 			    xmlChar *str = NULL;
; 11427: 
; 11428: 			    xmlSchemaCustomErr(ACTXT_CAST ctxt,

	push	0
	push	edx
	push	ecx
	lea	eax, DWORD PTR _str$2[ebp]
	mov	DWORD PTR _str$2[ebp], 0
	push	eax
	call	_xmlSchemaFormatQName
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0HA@PEPECPEK@The?5redefining?5model?5group?5defi@

; 11429: 				XML_SCHEMAP_SRC_REDEFINE, child, NULL,
; 11430: 				"The redefining model group definition "
; 11431: 				"'%s' must not contain more than one "
; 11432: 				"reference to the redefined definition",
; 11433: 				xmlSchemaFormatQName(&str,
; 11434: 				    ctxt->redef->refTargetNs,
; 11435: 				    ctxt->redef->refName),
; 11436: 				NULL);
; 11437: 			    FREE_AND_NULL(str)
; 11438: 			    part = NULL;

	jmp	SHORT $LN154@xmlSchemaP
$LN49@xmlSchemaP:

; 11439: 			} else if (((WXS_PARTICLE(part))->minOccurs != 1) ||

	cmp	DWORD PTR [edi+16], 1
	jne	SHORT $LN53@xmlSchemaP
	cmp	DWORD PTR [edi+20], 1
	je	SHORT $LN52@xmlSchemaP
$LN53@xmlSchemaP:

; 11440: 			    ((WXS_PARTICLE(part))->maxOccurs != 1))
; 11441: 			{
; 11442: 			    xmlChar *str = NULL;
; 11443: 			    /*
; 11444: 			    * SPEC src-redefine:
; 11445: 			    * (6.1.2) "The `actual value` of both that
; 11446: 			    * group's minOccurs and maxOccurs [attribute]
; 11447: 			    * must be 1 (or `absent`).
; 11448: 			    */
; 11449: 			    xmlSchemaCustomErr(ACTXT_CAST ctxt,

	push	0
	push	edx
	push	ecx
	lea	eax, DWORD PTR _str$1[ebp]
	mov	DWORD PTR _str$1[ebp], 0
	push	eax
	call	_xmlSchemaFormatQName
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0IM@HPEJBILG@The?5redefining?5model?5group?5defi@
$LN154@xmlSchemaP:

; 11450: 				XML_SCHEMAP_SRC_REDEFINE, child, NULL,
; 11451: 				"The redefining model group definition "
; 11452: 				"'%s' must not contain a reference to the "
; 11453: 				"redefined definition with a "
; 11454: 				"maxOccurs/minOccurs other than 1",
; 11455: 				xmlSchemaFormatQName(&str,
; 11456: 				    ctxt->redef->refTargetNs,
; 11457: 				    ctxt->redef->refName),
; 11458: 				NULL);
; 11459: 			    FREE_AND_NULL(str)
; 11460: 			    part = NULL;
; 11461: 			}
; 11462: 			ctxt->redef->reference = WXS_BASIC_CAST part;

	push	0
	push	esi
	push	3081					; 00000c09H
	push	ebx
	call	_xmlSchemaCustomErr
	mov	eax, DWORD PTR _str$1[ebp]
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	SHORT $LN54@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN54@xmlSchemaP:
	xor	edi, edi
$LN52@xmlSchemaP:
	mov	eax, DWORD PTR [ebx+120]
	mov	DWORD PTR [eax+8], edi

; 11463: 			ctxt->redefCounter++;

	inc	DWORD PTR [ebx+124]

; 11464: 		    }
; 11465: 		}

	jmp	$LN59@xmlSchemaP
$LN44@xmlSchemaP:

; 11466: 	    } else if (IS_SCHEMA(child, "any")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN59@xmlSchemaP
	push	OFFSET ??_C@_03OBJFJEBA@any@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN55@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN55@xmlSchemaP

; 11467: 		part = (xmlSchemaTreeItemPtr)

	push	esi
	push	DWORD PTR _schema$[ebp]
	push	ebx
	call	_xmlSchemaParseAny
	add	esp, 12					; 0000000cH
	jmp	$LN155@xmlSchemaP
$LN55@xmlSchemaP:

; 11468: 		    xmlSchemaParseAny(ctxt, schema, child);
; 11469: 	    } else if (IS_SCHEMA(child, "choice")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN59@xmlSchemaP
	push	OFFSET ??_C@_06DDDNEJEA@choice@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN57@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN57@xmlSchemaP

; 11470: 		part = xmlSchemaParseModelGroup(ctxt, schema, child,

	push	1
	push	7
	jmp	SHORT $LN156@xmlSchemaP
$LN57@xmlSchemaP:

; 11471: 		    XML_SCHEMA_TYPE_CHOICE, 1);
; 11472: 	    } else if (IS_SCHEMA(child, "sequence")) {

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN59@xmlSchemaP
	push	OFFSET ??_C@_08IBBDGPOF@sequence@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN59@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN59@xmlSchemaP

; 11473: 		part = xmlSchemaParseModelGroup(ctxt, schema, child,

	push	1
	push	6
$LN156@xmlSchemaP:

; 11474: 		    XML_SCHEMA_TYPE_SEQUENCE, 1);
; 11475: 	    }
; 11476: 	    if (part != NULL) {

	push	esi
	push	DWORD PTR _schema$[ebp]
	push	ebx
	call	_xmlSchemaParseModelGroup
	add	esp, 20					; 00000014H
$LN155@xmlSchemaP:
	mov	edi, eax
$LN59@xmlSchemaP:
	test	edi, edi
	je	SHORT $LN60@xmlSchemaP

; 11477: 		if (last == NULL)

	mov	eax, DWORD PTR _last$1$[ebp]
	test	eax, eax
	jne	SHORT $LN61@xmlSchemaP

; 11478: 		    item->children = part;

	mov	eax, DWORD PTR _item$1$[ebp]

; 11481: 		last = part;

	mov	DWORD PTR _last$1$[ebp], edi
	mov	DWORD PTR [eax+12], edi

; 11482: 	    }
; 11483: 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]

; 11484: 	}

	jmp	$LL8@xmlSchemaP
$LN61@xmlSchemaP:

; 11479: 		else
; 11480: 		    last->next = part;

	mov	DWORD PTR [eax+8], edi

; 11481: 		last = part;

	mov	DWORD PTR _last$1$[ebp], edi
$LN60@xmlSchemaP:

; 11482: 	    }
; 11483: 	    child = child->next;

	mov	esi, DWORD PTR [esi+24]

; 11484: 	}

	jmp	$LL8@xmlSchemaP
$LN9@xmlSchemaP:

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	mov	edi, DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _des$3[ebp]
	push	edi
	push	0
	push	0
	push	eax
	mov	DWORD PTR _des$3[ebp], 0
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	test	esi, esi
	push	OFFSET ??_C@_0DM@EMLAMPJB@?$CIannotation?$DP?0?5?$CIelement?5?$HM?5group?5@
	cmove	esi, edi
$LN143@xmlSchemaP:

; 11485: 	if (child != NULL) {
; 11486: 	    xmlSchemaPContentErr(ctxt,
; 11487: 		XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 11488: 		NULL, node, child, NULL,
; 11489: 		"(annotation?, (element | group | choice | sequence | any)*)");
; 11490: 	}
; 11491:     }
; 11492:     if ((max == 0) && (min == 0))

	push	DWORD PTR _des$3[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	ebx
	call	_xmlSchemaPErr
	mov	eax, DWORD PTR _des$3[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN103@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN103@xmlSchemaP:
	cmp	DWORD PTR _max$1$[ebp], 0
	jne	SHORT $LN64@xmlSchemaP
	cmp	DWORD PTR _min$1$[ebp], 0
	je	SHORT $LN11@xmlSchemaP
$LN64@xmlSchemaP:

; 11493: 	return (NULL);
; 11494:     if (hasRefs) {

	cmp	DWORD PTR _hasRefs$1$[ebp], 0
	je	SHORT $LN65@xmlSchemaP

; 11495: 	/*
; 11496: 	* We need to resolve references.
; 11497: 	*/
; 11498: 	WXS_ADD_PENDING(ctxt, item);

	push	DWORD PTR _item$1$[ebp]
	mov	eax, DWORD PTR [ebx+28]
	add	eax, 20					; 00000014H
	push	10					; 0000000aH
	push	eax
	call	_xmlSchemaAddItemSize
	add	esp, 12					; 0000000cH
$LN65@xmlSchemaP:

; 11499:     }
; 11500:     if (withParticle)

	cmp	DWORD PTR _withParticle$[ebp], 0
	mov	eax, DWORD PTR _item$1$[ebp]
	cmovne	eax, DWORD PTR _particle$1$[ebp]
	pop	edi

; 11501: 	return ((xmlSchemaTreeItemPtr) particle);
; 11502:     else
; 11503: 	return ((xmlSchemaTreeItemPtr) item);
; 11504: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlSchemaP:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseModelGroup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetWhiteSpaceFacetValue
_TEXT	SEGMENT
_type$ = 8						; size = 4
_xmlSchemaGetWhiteSpaceFacetValue PROC			; COMDAT

; 21562: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN2@xmlSchemaG

; 21563:     /*
; 21564:     * The normalization type can be changed only for types which are derived
; 21565:     * from xsd:string.
; 21566:     */
; 21567:     if (type->type == XML_SCHEMA_TYPE_BASIC) {
; 21568: 	/*
; 21569: 	* Note that we assume a whitespace of preserve for anySimpleType.
; 21570: 	*/
; 21571: 	if ((type->builtInType == XML_SCHEMAS_STRING) ||

	mov	eax, DWORD PTR [eax+88]
	cmp	eax, 1
	je	SHORT $LN19@xmlSchemaG
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN19@xmlSchemaG

; 21572: 	    (type->builtInType == XML_SCHEMAS_ANYSIMPLETYPE))
; 21573: 	    return(XML_SCHEMA_WHITESPACE_PRESERVE);
; 21574: 	else if (type->builtInType == XML_SCHEMAS_NORMSTRING)

	cmp	eax, 2
	je	SHORT $LN20@xmlSchemaG
$LN16@xmlSchemaG:

; 21597: 	else
; 21598: 	    return (XML_SCHEMA_WHITESPACE_COLLAPSE);

	mov	eax, 3

; 21601: }

	pop	ebp
	ret	0
$LN2@xmlSchemaG:

; 21575: 	    return(XML_SCHEMA_WHITESPACE_REPLACE);
; 21576: 	else {
; 21577: 	    /*
; 21578: 	    * For all `atomic` datatypes other than string (and types `derived`
; 21579: 	    * by `restriction` from it) the value of whiteSpace is fixed to
; 21580: 	    * collapse
; 21581: 	    * Note that this includes built-in list datatypes.
; 21582: 	    */
; 21583: 	    return(XML_SCHEMA_WHITESPACE_COLLAPSE);
; 21584: 	}
; 21585:     } else if (WXS_IS_LIST(type)) {

	mov	eax, DWORD PTR [eax+48]
	test	al, 64					; 00000040H
	jne	SHORT $LN16@xmlSchemaG

; 21586: 	/*
; 21587: 	* For list types the facet "whiteSpace" is fixed to "collapse".
; 21588: 	*/
; 21589: 	return (XML_SCHEMA_WHITESPACE_COLLAPSE);
; 21590:     } else if (WXS_IS_UNION(type)) {

	test	al, al
	jns	SHORT $LN11@xmlSchemaG

; 21591: 	return (XML_SCHEMA_WHITESPACE_UNKNOWN);

	xor	eax, eax

; 21601: }

	pop	ebp
	ret	0
$LN11@xmlSchemaG:

; 21592:     } else if (WXS_IS_ATOMIC(type)) {

	test	eax, 256				; 00000100H
	je	SHORT $LN17@xmlSchemaG

; 21593: 	if (type->flags & XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE)

	test	eax, 16777216				; 01000000H
	je	SHORT $LN14@xmlSchemaG
$LN19@xmlSchemaG:

; 21594: 	    return (XML_SCHEMA_WHITESPACE_PRESERVE);

	mov	eax, 1

; 21601: }

	pop	ebp
	ret	0
$LN14@xmlSchemaG:

; 21595: 	else if (type->flags & XML_SCHEMAS_TYPE_WHITESPACE_REPLACE)

	test	eax, 33554432				; 02000000H
	je	SHORT $LN16@xmlSchemaG
$LN20@xmlSchemaG:

; 21596: 	    return (XML_SCHEMA_WHITESPACE_REPLACE);

	mov	eax, 2

; 21601: }

	pop	ebp
	ret	0
$LN17@xmlSchemaG:

; 21599:     }
; 21600:     return (-1);

	or	eax, -1

; 21601: }

	pop	ebp
	ret	0
_xmlSchemaGetWhiteSpaceFacetValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaClearValidCtxt
_TEXT	SEGMENT
_matcher$1$ = -8					; size = 4
_next$1$ = -4						; size = 4
_vctxt$ = 8						; size = 4
_xmlSchemaClearValidCtxt PROC				; COMDAT

; 27597: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	push	ebx
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _vctxt$[ebp]
	test	ebx, ebx
	je	$LN26@xmlSchemaC

; 27598:     if (vctxt == NULL)
; 27599:         return;
; 27600: 
; 27601:     /*
; 27602:     * TODO: Should we clear the flags?
; 27603:     *   Might be problematic if one reuses the context
; 27604:     *   and assumes that the options remain the same.
; 27605:     */
; 27606:     vctxt->flags = 0;

	mov	eax, DWORD PTR [ebx+72]
	mov	DWORD PTR [ebx+152], 0

; 27607:     vctxt->validationRoot = NULL;

	mov	DWORD PTR [ebx+84], 0

; 27608:     vctxt->doc = NULL;

	mov	DWORD PTR [ebx+24], 0

; 27609: #ifdef LIBXML_READER_ENABLED
; 27610:     vctxt->reader = NULL;

	mov	DWORD PTR [ebx+160], 0

; 27611: #endif
; 27612:     vctxt->hasKeyrefs = 0;

	mov	DWORD PTR [ebx+184], 0

; 27613: 
; 27614:     if (vctxt->value != NULL) {

	test	eax, eax
	je	SHORT $LN17@xmlSchemaC

; 27615:         xmlSchemaFreeValue(vctxt->value);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4

; 27616: 	vctxt->value = NULL;

	mov	DWORD PTR [ebx+72], 0
$LN17@xmlSchemaC:

; 27617:     }
; 27618:     /*
; 27619:     * Augmented IDC information.
; 27620:     */
; 27621:     if (vctxt->aidcs != NULL) {

	mov	eax, DWORD PTR [ebx+112]
	push	esi
	test	eax, eax
	je	SHORT $LN18@xmlSchemaC
$LL4@xmlSchemaC:

; 27622: 	xmlSchemaIDCAugPtr cur = vctxt->aidcs, next;
; 27623: 	do {
; 27624: 	    next = cur->next;

	mov	esi, DWORD PTR [eax]

; 27625: 	    xmlFree(cur);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 27626: 	    cur = next;

	mov	eax, esi

; 27627: 	} while (cur != NULL);

	test	esi, esi
	jne	SHORT $LL4@xmlSchemaC

; 27628: 	vctxt->aidcs = NULL;

	mov	DWORD PTR [ebx+112], esi
$LN18@xmlSchemaC:

; 27629:     }
; 27630:     if (vctxt->idcMatcherCache != NULL) {

	mov	eax, DWORD PTR [ebx+124]
	push	edi
	test	eax, eax
	je	$LN19@xmlSchemaC
$LL5@xmlSchemaC:

; 27634: 	    tmp = matcher;

	mov	esi, eax

; 27635: 	    matcher = matcher->nextCached;

	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _matcher$1$[ebp], eax
$LL29@xmlSchemaC:

; 22327: 	if (matcher->keySeqs != NULL) {

	mov	eax, DWORD PTR [esi+24]
	mov	ebx, DWORD PTR [esi+8]
	mov	DWORD PTR _next$1$[ebp], ebx
	test	eax, eax
	je	SHORT $LN37@xmlSchemaC

; 22328: 	    int i;
; 22329: 	    for (i = 0; i < matcher->sizeKeySeqs; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+28], edi
	jle	SHORT $LN32@xmlSchemaC

; 22330: 		if (matcher->keySeqs[i] != NULL)

	mov	edx, eax
$LL33@xmlSchemaC:
	mov	ecx, DWORD PTR [eax+edi*4]
	test	ecx, ecx
	je	SHORT $LN31@xmlSchemaC

; 22331: 		    xmlFree(matcher->keySeqs[i]);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [esi+24]
	add	esp, 4
	mov	edx, eax
$LN31@xmlSchemaC:

; 22328: 	    int i;
; 22329: 	    for (i = 0; i < matcher->sizeKeySeqs; i++)

	inc	edi
	cmp	edi, DWORD PTR [esi+28]
	jl	SHORT $LL33@xmlSchemaC
	mov	eax, edx
$LN32@xmlSchemaC:

; 22332: 	    xmlFree(matcher->keySeqs);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN37@xmlSchemaC:

; 22333: 	}
; 22334: 	if (matcher->targets != NULL) {

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN42@xmlSchemaC

; 22335: 	    if (matcher->idcType == XML_SCHEMA_TYPE_IDC_KEYREF) {

	cmp	DWORD PTR [esi+20], 24			; 00000018H
	mov	edi, eax
	jne	SHORT $LN35@xmlSchemaC

; 22336: 		int i;
; 22337: 		xmlSchemaPSVIIDCNodePtr idcNode;
; 22338: 		/*
; 22339: 		* Node-table items for keyrefs are not stored globally
; 22340: 		* to the validation context, since they are not bubbled.
; 22341: 		* We need to free them here.
; 22342: 		*/
; 22343: 		for (i = 0; i < matcher->targets->nbItems; i++) {

	xor	ebx, ebx
	cmp	DWORD PTR [eax+4], ebx
	jle	SHORT $LN85@xmlSchemaC
$LL36@xmlSchemaC:

; 22344: 		    idcNode =

	mov	eax, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+ebx*4]

; 22345: 			(xmlSchemaPSVIIDCNodePtr) matcher->targets->items[i];
; 22346: 		    xmlFree(idcNode->keys);

	push	DWORD PTR [edi+4]
	call	DWORD PTR _xmlFree

; 22347: 		    xmlFree(idcNode);

	push	edi
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [esi+32]
	inc	ebx
	add	esp, 8
	cmp	ebx, DWORD PTR [eax+4]
	jl	SHORT $LL36@xmlSchemaC
	mov	edi, eax
$LN85@xmlSchemaC:

; 3530 :     if (list == NULL)

	mov	ebx, DWORD PTR _next$1$[ebp]
$LN35@xmlSchemaC:
	test	edi, edi
	je	SHORT $LN42@xmlSchemaC

; 3531 : 	return;
; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN44@xmlSchemaC

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN44@xmlSchemaC:

; 3534 :     xmlFree(list);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN42@xmlSchemaC:

; 22352: 	xmlFree(matcher);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 22353: 	matcher = next;

	mov	esi, ebx
	test	ebx, ebx
	jne	$LL29@xmlSchemaC

; 27631: 	xmlSchemaIDCMatcherPtr matcher = vctxt->idcMatcherCache, tmp;
; 27632: 
; 27633: 	while (matcher) {

	mov	eax, DWORD PTR _matcher$1$[ebp]
	test	eax, eax
	jne	$LL5@xmlSchemaC

; 27636: 	    xmlSchemaIDCFreeMatcherList(tmp);
; 27637: 	}
; 27638: 	vctxt->idcMatcherCache = NULL;

	mov	ebx, DWORD PTR _vctxt$[ebp]
	mov	DWORD PTR [ebx+124], eax
$LN19@xmlSchemaC:

; 27639:     }
; 27640: 
; 27641: 
; 27642:     if (vctxt->idcNodes != NULL) {

	mov	eax, DWORD PTR [ebx+128]
	test	eax, eax
	je	SHORT $LN20@xmlSchemaC

; 27643: 	int i;
; 27644: 	xmlSchemaPSVIIDCNodePtr item;
; 27645: 
; 27646: 	for (i = 0; i < vctxt->nbIdcNodes; i++) {

	xor	edi, edi
	cmp	DWORD PTR [ebx+132], edi
	jle	SHORT $LN8@xmlSchemaC
$LL9@xmlSchemaC:

; 27647: 	    item = vctxt->idcNodes[i];

	mov	eax, DWORD PTR [ebx+128]
	mov	esi, DWORD PTR [eax+edi*4]

; 27648: 	    xmlFree(item->keys);

	push	DWORD PTR [esi+4]
	call	DWORD PTR _xmlFree

; 27649: 	    xmlFree(item);

	push	esi
	call	DWORD PTR _xmlFree
	inc	edi
	add	esp, 8
	cmp	edi, DWORD PTR [ebx+132]
	jl	SHORT $LL9@xmlSchemaC
	mov	eax, DWORD PTR [ebx+128]
$LN8@xmlSchemaC:

; 27650: 	}
; 27651: 	xmlFree(vctxt->idcNodes);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 27652: 	vctxt->idcNodes = NULL;

	mov	DWORD PTR [ebx+128], 0

; 27653: 	vctxt->nbIdcNodes = 0;

	mov	DWORD PTR [ebx+132], 0

; 27654: 	vctxt->sizeIdcNodes = 0;

	mov	DWORD PTR [ebx+136], 0
$LN20@xmlSchemaC:

; 27655:     }
; 27656: 
; 27657:     if (vctxt->idcKeys != NULL) {

	cmp	DWORD PTR [ebx+140], 0
	je	SHORT $LN21@xmlSchemaC

; 27658: 	int i;
; 27659: 	for (i = 0; i < vctxt->nbIdcKeys; i++)

	xor	esi, esi
	cmp	DWORD PTR [ebx+144], esi
	jle	SHORT $LN11@xmlSchemaC
	npad	9
$LL12@xmlSchemaC:

; 27660: 	    xmlSchemaIDCFreeKey(vctxt->idcKeys[i]);

	mov	eax, DWORD PTR [ebx+140]
	mov	edi, DWORD PTR [eax+esi*4]

; 22275:     if (key->val != NULL)

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN47@xmlSchemaC

; 22276: 	xmlSchemaFreeValue(key->val);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN47@xmlSchemaC:

; 22277:     xmlFree(key);

	push	edi
	call	DWORD PTR _xmlFree

; 27658: 	int i;
; 27659: 	for (i = 0; i < vctxt->nbIdcKeys; i++)

	inc	esi

; 22277:     xmlFree(key);

	add	esp, 4

; 27658: 	int i;
; 27659: 	for (i = 0; i < vctxt->nbIdcKeys; i++)

	cmp	esi, DWORD PTR [ebx+144]
	jl	SHORT $LL12@xmlSchemaC
$LN11@xmlSchemaC:

; 27661: 	xmlFree(vctxt->idcKeys);

	push	DWORD PTR [ebx+140]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 27662: 	vctxt->idcKeys = NULL;

	mov	DWORD PTR [ebx+140], 0

; 27663: 	vctxt->nbIdcKeys = 0;

	mov	DWORD PTR [ebx+144], 0

; 27664: 	vctxt->sizeIdcKeys = 0;

	mov	DWORD PTR [ebx+148], 0
$LN21@xmlSchemaC:

; 27665:     }
; 27666: 
; 27667:     /*
; 27668:     * Note that we won't delete the XPath state pool here.
; 27669:     */
; 27670:     if (vctxt->xpathStates != NULL) {

	mov	eax, DWORD PTR [ebx+116]
	pop	edi
	test	eax, eax
	je	SHORT $LN22@xmlSchemaC

; 27671: 	xmlSchemaFreeIDCStateObjList(vctxt->xpathStates);

	push	eax
	call	_xmlSchemaFreeIDCStateObjList
	add	esp, 4

; 27672: 	vctxt->xpathStates = NULL;

	mov	DWORD PTR [ebx+116], 0
$LN22@xmlSchemaC:

; 27673:     }
; 27674:     /*
; 27675:     * Attribute info.
; 27676:     */
; 27677:     if (vctxt->nbAttrInfos != 0) {

	cmp	DWORD PTR [ebx+168], 0
	je	SHORT $LN23@xmlSchemaC

; 27678: 	xmlSchemaClearAttrInfos(vctxt);

	push	ebx
	call	_xmlSchemaClearAttrInfos
	add	esp, 4
$LN23@xmlSchemaC:

; 27679:     }
; 27680:     /*
; 27681:     * Element info.
; 27682:     */
; 27683:     if (vctxt->elemInfos != NULL) {

	cmp	DWORD PTR [ebx+100], 0
	je	SHORT $LN84@xmlSchemaC

; 27684: 	int i;
; 27685: 	xmlSchemaNodeInfoPtr ei;
; 27686: 
; 27687: 	for (i = 0; i < vctxt->sizeElemInfos; i++) {

	xor	esi, esi
	cmp	DWORD PTR [ebx+104], esi
	jle	SHORT $LN84@xmlSchemaC
$LL15@xmlSchemaC:

; 27688: 	    ei = vctxt->elemInfos[i];

	mov	eax, DWORD PTR [ebx+100]
	mov	eax, DWORD PTR [eax+esi*4]

; 27689: 	    if (ei == NULL)

	test	eax, eax
	je	SHORT $LN84@xmlSchemaC

; 27690: 		break;
; 27691: 	    xmlSchemaClearElemInfo(vctxt, ei);

	push	eax
	push	ebx
	call	_xmlSchemaClearElemInfo
	inc	esi
	add	esp, 8
	cmp	esi, DWORD PTR [ebx+104]
	jl	SHORT $LL15@xmlSchemaC
$LN84@xmlSchemaC:

; 27692: 	}
; 27693:     }
; 27694:     xmlSchemaItemListClear(vctxt->nodeQNames);

	mov	esi, DWORD PTR [ebx+180]

; 3354 :     if (list->items != NULL) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN50@xmlSchemaC

; 3355 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3356 : 	list->items = NULL;

	mov	DWORD PTR [esi], 0
$LN50@xmlSchemaC:

; 3357 :     }
; 3358 :     list->nbItems = 0;

	mov	DWORD PTR [esi+4], 0

; 3359 :     list->sizeItems = 0;

	mov	DWORD PTR [esi+8], 0

; 27695:     /* Recreate the dict. */
; 27696:     xmlDictFree(vctxt->dict);

	push	DWORD PTR [ebx+156]
	call	_xmlDictFree
	add	esp, 4

; 27697:     /*
; 27698:     * TODO: Is is save to recreate it? Do we have a scenario
; 27699:     * where the user provides the dict?
; 27700:     */
; 27701:     vctxt->dict = xmlDictCreate();

	call	_xmlDictCreate
	mov	DWORD PTR [ebx+156], eax

; 27702: 
; 27703:     if (vctxt->filename != NULL) {

	mov	eax, DWORD PTR [ebx+48]
	pop	esi
	test	eax, eax
	je	SHORT $LN26@xmlSchemaC

; 27704:         xmlFree(vctxt->filename);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 27705: 	vctxt->filename = NULL;

	mov	DWORD PTR [ebx+48], 0
$LN26@xmlSchemaC:
	pop	ebx

; 27706:     }
; 27707: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaClearValidCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckFacetValues
_TEXT	SEGMENT
_olderrs$1$ = -4					; size = 4
_typeDecl$ = 8						; size = 4
_name$1$ = 12						; size = 4
_pctxt$ = 12						; size = 4
_xmlSchemaCheckFacetValues PROC				; COMDAT

; 18879: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _typeDecl$[ebp]
	mov	edi, DWORD PTR _pctxt$[ebp]
	mov	esi, DWORD PTR [ebx+68]
	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR _olderrs$1$[ebp], eax
	mov	DWORD PTR _name$1$[ebp], ecx
	test	esi, esi
	je	$LN4@xmlSchemaC

; 18880:     int res, olderrs = pctxt->nberrors;
; 18881:     const xmlChar *name = typeDecl->name;
; 18882:     /*
; 18883:     * NOTE: It is intended to use the facets list, instead
; 18884:     * of facetSet.
; 18885:     */
; 18886:     if (typeDecl->facets != NULL) {
; 18887: 	xmlSchemaFacetPtr facet = typeDecl->facets;
; 18888: 
; 18889: 	/*
; 18890: 	* Temporarily assign the "schema" to the validation context
; 18891: 	* of the parser context. This is needed for NOTATION validation.
; 18892: 	*/
; 18893: 	if (pctxt->vctxt == NULL) {

	mov	edx, DWORD PTR [edi+92]
	test	edx, edx
	jne	SHORT $LN18@xmlSchemaC

; 15799: 	ctxt->vctxt = xmlSchemaNewValidCtxt(NULL);

	push	edx
	call	_xmlSchemaNewValidCtxt
	add	esp, 4
	mov	DWORD PTR [edi+92], eax

; 15800: 	if (ctxt->vctxt == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlSchemaC

; 15801: 	    xmlSchemaPErr(ctxt, NULL,

	push	eax
	push	eax
	push	OFFSET ??_C@_0FL@FMHFMMBK@Internal?5error?3?5xmlSchemaCreate@
	push	3069					; 00000bfdH
	push	eax
	push	edi
	call	_xmlSchemaPErr
	add	esp, 24					; 00000018H
$exit_failure$22:
	pop	edi

; 18907:     return(0);
; 18908: exit_failure:
; 18909:     return(-1);
; 18910: }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlSchemaC:

; 15809: 	xmlSchemaSetValidErrors(ctxt->vctxt,

	push	DWORD PTR [edi+4]
	push	DWORD PTR [edi+12]
	push	DWORD PTR [edi+8]
	push	eax
	call	_xmlSchemaSetValidErrors

; 15810: 	    ctxt->error, ctxt->warning, ctxt->errCtxt);
; 15811: 	xmlSchemaSetValidStructuredErrors(ctxt->vctxt,

	push	DWORD PTR [edi+4]
	push	DWORD PTR [edi+24]
	push	DWORD PTR [edi+92]
	call	_xmlSchemaSetValidStructuredErrors
	mov	edx, DWORD PTR [edi+92]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR _name$1$[ebp]
$LN18@xmlSchemaC:

; 18894: 	    if (xmlSchemaCreateVCtxtOnPCtxt(pctxt) == -1)
; 18895: 		return(-1);
; 18896: 	}
; 18897: 	pctxt->vctxt->schema = pctxt->schema;

	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [edx+20], eax

; 18898: 	while (facet != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlSchemaC
$LL2@xmlSchemaC:

; 18899: 	    res = xmlSchemaCheckFacet(facet, typeDecl, pctxt, name);

	push	ecx
	push	edi
	push	ebx
	push	esi
	call	_xmlSchemaCheckFacet
	add	esp, 16					; 00000010H

; 18900: 	    HFAILURE

	cmp	eax, -1
	je	SHORT $exit_failure$22

; 18901: 	    facet = facet->next;

	mov	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _name$1$[ebp]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaC
$LN3@xmlSchemaC:

; 18902: 	}
; 18903: 	pctxt->vctxt->schema = NULL;

	mov	ecx, DWORD PTR [edi+92]
	mov	DWORD PTR [ecx+20], 0
	mov	eax, DWORD PTR [edi+20]
$LN4@xmlSchemaC:

; 18904:     }
; 18905:     if (olderrs != pctxt->nberrors)

	cmp	DWORD PTR _olderrs$1$[ebp], eax
	je	SHORT $LN8@xmlSchemaC

; 18906: 	return(pctxt->err);

	mov	eax, DWORD PTR [edi+16]
	pop	edi

; 18907:     return(0);
; 18908: exit_failure:
; 18909:     return(-1);
; 18910: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlSchemaC:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCheckFacetValues ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseImport
_TEXT	SEGMENT
_bucket$ = -16						; size = 4
_schemaLocation$1$ = -12				; size = 4
_schemaLocation$ = -8					; size = 4
_namespaceName$ = -4					; size = 4
$T1 = 8							; size = 4
_thisTargetNamespace$1$ = 8				; size = 4
_des$2 = 8						; size = 4
_ret$1$ = 8						; size = 4
_pctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaParseImport PROC				; COMDAT

; 10749: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pctxt$[ebp]
	xor	eax, eax
	mov	DWORD PTR _namespaceName$[ebp], 0
	mov	DWORD PTR _schemaLocation$1$[ebp], eax
	mov	DWORD PTR _schemaLocation$[ebp], eax
	mov	DWORD PTR _bucket$[ebp], eax
	test	edi, edi
	je	$LN5@xmlSchemaP

; 10750:     xmlNodePtr child;
; 10751:     const xmlChar *namespaceName = NULL, *schemaLocation = NULL;
; 10752:     const xmlChar *thisTargetNamespace;
; 10753:     xmlAttrPtr attr;
; 10754:     int ret = 0;
; 10755:     xmlSchemaBucketPtr bucket = NULL;
; 10756: 
; 10757:     if ((pctxt == NULL) || (schema == NULL) || (node == NULL))

	cmp	DWORD PTR _schema$[ebp], eax
	je	$LN5@xmlSchemaP
	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	$LN5@xmlSchemaP

; 10759: 
; 10760:     /*
; 10761:     * Check for illegal attributes.
; 10762:     */
; 10763:     attr = node->properties;

	push	esi
	mov	esi, DWORD PTR [ebx+44]

; 10764:     while (attr != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlSchemaP
	npad	5
$LL2@xmlSchemaP:

; 10765: 	if (attr->ns == NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN6@xmlSchemaP

; 10766: 	    if ((!xmlStrEqual(attr->name, BAD_CAST "id")) &&
; 10767: 		(!xmlStrEqual(attr->name, BAD_CAST "namespace")) &&

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP
	push	OFFSET ??_C@_09KPMGAFNI@namespace@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP
	push	OFFSET ??_C@_0P@DEMHLMFE@schemaLocation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaP

; 10768: 		(!xmlStrEqual(attr->name, BAD_CAST "schemaLocation"))) {
; 10769: 		xmlSchemaPIllegalAttrErr(pctxt,
; 10770: 		    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 10771: 	    }

	jmp	SHORT $LN79@xmlSchemaP
$LN6@xmlSchemaP:

; 10772: 	} else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {

	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlSchemaP
$LN79@xmlSchemaP:

; 10773: 	    xmlSchemaPIllegalAttrErr(pctxt,
; 10774: 		XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);
; 10775: 	}
; 10776: 	attr = attr->next;

	push	esi
	push	0
	push	3035					; 00000bdbH
	push	edi
	call	_xmlSchemaPIllegalAttrErr
	add	esp, 16					; 00000010H
$LN9@xmlSchemaP:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaP
$LN3@xmlSchemaP:

; 10777:     }
; 10778:     /*
; 10779:     * Extract and validate attributes.
; 10780:     */
; 10781:     if (xmlSchemaPValAttr(pctxt, NULL, node,
; 10782: 	"namespace", xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
; 10783: 	&namespaceName) != 0) {

	push	29					; 0000001dH
	call	_xmlSchemaGetBuiltInType
	mov	esi, eax
	add	esp, 4

; 6425 :     if ((ctxt == NULL) || (type == NULL)) {

	test	esi, esi
	je	SHORT $LN25@xmlSchemaP

; 6426 : 	if (value != NULL)
; 6427 : 	    *value = NULL;
; 6428 : 	return (-1);
; 6429 :     }
; 6430 :     if (type->type != XML_SCHEMA_TYPE_BASIC) {

	cmp	DWORD PTR [esi], 1
	je	SHORT $LN27@xmlSchemaP

; 6431 : 	if (value != NULL)
; 6432 : 	    *value = NULL;
; 6433 : 	xmlSchemaPErr(ctxt, ownerElem,

	push	0
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0FA@OJBBBDML@Internal?5error?3?5xmlSchemaPValAt@
	push	3069					; 00000bfdH
	push	ebx
	push	edi
	call	_xmlSchemaPErr
	add	esp, 24					; 00000018H
$LN25@xmlSchemaP:

; 10777:     }
; 10778:     /*
; 10779:     * Extract and validate attributes.
; 10780:     */
; 10781:     if (xmlSchemaPValAttr(pctxt, NULL, node,
; 10782: 	"namespace", xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
; 10783: 	&namespaceName) != 0) {

	mov	DWORD PTR $T1[ebp], -1
$LN23@xmlSchemaP:
	push	29					; 0000001dH
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	mov	esi, eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN10@xmlSchemaP

; 10784: 	xmlSchemaPSimpleTypeErr(pctxt,

	push	0
	push	0
	push	0
	push	DWORD PTR _namespaceName$[ebp]
	push	0
	push	esi

; 10785: 	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 10786: 	    NULL, node,
; 10787: 	    xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
; 10788: 	    NULL, namespaceName, NULL, NULL, NULL);
; 10789: 	return (pctxt->err);

	jmp	SHORT $LN83@xmlSchemaP
$LN27@xmlSchemaP:

; 6440 :     attr = xmlSchemaGetPropNode(ownerElem, name);

	push	OFFSET ??_C@_09KPMGAFNI@namespace@
	push	ebx
	call	_xmlSchemaGetPropNode
	add	esp, 8

; 6441 :     if (attr == NULL) {

	test	eax, eax
	jne	SHORT $LN29@xmlSchemaP

; 6442 : 	if (value != NULL)
; 6443 : 	    *value = NULL;
; 6444 : 	return (0);

	mov	DWORD PTR $T1[ebp], eax
	jmp	SHORT $LN23@xmlSchemaP
$LN29@xmlSchemaP:

; 6445 :     }
; 6446 :     return (xmlSchemaPValAttrNode(ctxt, ownerItem, attr,

	lea	ecx, DWORD PTR _namespaceName$[ebp]
	push	ecx
	push	esi
	push	eax
	push	0
	push	edi
	call	_xmlSchemaPValAttrNode
	add	esp, 20					; 00000014H
	mov	DWORD PTR $T1[ebp], eax
	jmp	SHORT $LN23@xmlSchemaP
$LN10@xmlSchemaP:

; 6425 :     if ((ctxt == NULL) || (type == NULL)) {

	test	esi, esi
	je	SHORT $LN74@xmlSchemaP

; 6426 : 	if (value != NULL)
; 6427 : 	    *value = NULL;
; 6428 : 	return (-1);
; 6429 :     }
; 6430 :     if (type->type != XML_SCHEMA_TYPE_BASIC) {

	cmp	DWORD PTR [esi], 1
	je	SHORT $LN36@xmlSchemaP

; 6431 : 	if (value != NULL)
; 6432 : 	    *value = NULL;
; 6433 : 	xmlSchemaPErr(ctxt, ownerElem,

	push	0
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0FA@OJBBBDML@Internal?5error?3?5xmlSchemaPValAt@
	push	3069					; 00000bfdH
	push	ebx
	push	edi
	call	_xmlSchemaPErr
	add	esp, 24					; 00000018H
$LN74@xmlSchemaP:

; 10795: 	xmlSchemaPSimpleTypeErr(pctxt,

	xor	eax, eax
$LN72@xmlSchemaP:
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	29					; 0000001dH
	call	_xmlSchemaGetBuiltInType
	add	esp, 4
	push	eax
$LN83@xmlSchemaP:

; 10850: 		XML_SCHEMAP_SRC_IMPORT_1_2,
; 10851: 		NULL, node,
; 10852: 		"The attribute 'namespace' must be existent if "
; 10853: 		"the importing schema has no target namespace",
; 10854: 		NULL);
; 10855: 	    return (pctxt->err);

	push	ebx
	push	0
	push	3037					; 00000bddH
	push	edi
	call	_xmlSchemaPSimpleTypeErr
	mov	eax, DWORD PTR [edi+16]
	add	esp, 40					; 00000028H
	pop	esi
	pop	edi

; 10891: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@xmlSchemaP:

; 6440 :     attr = xmlSchemaGetPropNode(ownerElem, name);

	push	OFFSET ??_C@_0P@DEMHLMFE@schemaLocation@
	push	ebx
	call	_xmlSchemaGetPropNode
	add	esp, 8

; 6441 :     if (attr == NULL) {

	test	eax, eax
	je	SHORT $LN11@xmlSchemaP

; 6445 :     }
; 6446 :     return (xmlSchemaPValAttrNode(ctxt, ownerItem, attr,

	lea	ecx, DWORD PTR _schemaLocation$[ebp]
	push	ecx
	push	esi
	push	eax
	push	0
	push	edi
	call	_xmlSchemaPValAttrNode
	add	esp, 20					; 00000014H

; 10790:     }
; 10791: 
; 10792:     if (xmlSchemaPValAttr(pctxt, NULL, node,
; 10793: 	"schemaLocation", xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
; 10794: 	&schemaLocation) != 0) {

	test	eax, eax
	mov	eax, DWORD PTR _schemaLocation$[ebp]
	jne	SHORT $LN72@xmlSchemaP
	mov	DWORD PTR _schemaLocation$1$[ebp], eax
$LN11@xmlSchemaP:

; 10796: 	    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
; 10797: 	    NULL, node,
; 10798: 	    xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
; 10799: 	    NULL, schemaLocation, NULL, NULL, NULL);
; 10800: 	return (pctxt->err);
; 10801:     }
; 10802:     /*
; 10803:     * And now for the children...
; 10804:     */
; 10805:     child = node->children;

	mov	esi, DWORD PTR [ebx+12]

; 10806:     if (IS_SCHEMA(child, "annotation")) {

	test	esi, esi
	je	SHORT $LN46@xmlSchemaP
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN12@xmlSchemaP
	push	OFFSET ??_C@_0L@HOGAMHHM@annotation@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlSchemaP
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchemaNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlSchemaP

; 10807:         /*
; 10808:          * the annotation here is simply discarded ...
; 10809: 	 * TODO: really?
; 10810:          */
; 10811:         child = child->next;

	mov	esi, DWORD PTR [esi+24]
$LN12@xmlSchemaP:

; 10812:     }
; 10813:     if (child != NULL) {

	test	esi, esi
	je	SHORT $LN46@xmlSchemaP

; 3225 :     xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);

	push	ebx
	push	0
	lea	eax, DWORD PTR _des$2[ebp]
	mov	DWORD PTR _des$2[ebp], 0
	push	0
	push	eax
	call	_xmlSchemaFormatItemForReport

; 3226 :     if (message != NULL)
; 3227 : 	xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3228 : 	    "%s: %s.\n",
; 3229 : 	    BAD_CAST des, BAD_CAST message);
; 3230 :     else {
; 3231 : 	if (content != NULL) {
; 3232 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3233 : 		"%s: The content is not valid. Expected is %s.\n",
; 3234 : 		BAD_CAST des, BAD_CAST content);
; 3235 : 	} else {

	push	OFFSET ??_C@_0O@MNAJHLGE@?$CIannotation?$DP?$CJ@
	push	DWORD PTR _des$2[ebp]
	push	OFFSET ??_C@_0CP@OEFNIPAD@?$CFs?3?5The?5content?5is?5not?5valid?4?5E@
	push	3033					; 00000bd9H
	push	esi
	push	edi
	call	_xmlSchemaPErr

; 3236 : 	    xmlSchemaPErr2(ctxt, ownerElem, child, error,
; 3237 : 		"%s: The content is not valid.\n",
; 3238 : 		BAD_CAST des, NULL);
; 3239 : 	}
; 3240 :     }
; 3241 :     FREE_AND_NULL(des)

	mov	eax, DWORD PTR _des$2[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN46@xmlSchemaP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN46@xmlSchemaP:

; 10814: 	xmlSchemaPContentErr(pctxt,
; 10815: 	    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
; 10816: 	    NULL, node, child, NULL,
; 10817: 	    "(annotation?)");
; 10818:     }
; 10819:     /*
; 10820:     * Apply additional constraints.
; 10821:     *
; 10822:     * Note that it is important to use the original @targetNamespace
; 10823:     * (or none at all), to rule out imports of schemas _with_ a
; 10824:     * @targetNamespace if the importing schema is a chameleon schema
; 10825:     * (with no @targetNamespace).
; 10826:     */
; 10827:     thisTargetNamespace = WXS_BUCKET(pctxt)->origTargetNamespace;

	mov	eax, DWORD PTR [edi+28]
	mov	eax, DWORD PTR [eax+16]
	mov	esi, DWORD PTR [eax+12]

; 10828:     if (namespaceName != NULL) {

	mov	eax, DWORD PTR _namespaceName$[ebp]
	mov	DWORD PTR _thisTargetNamespace$1$[ebp], esi
	test	eax, eax
	je	SHORT $LN14@xmlSchemaP

; 10829: 	/*
; 10830: 	* 1.1 If the namespace [attribute] is present, then its `actual value`
; 10831: 	* must not match the `actual value` of the enclosing <schema>'s
; 10832: 	* targetNamespace [attribute].
; 10833: 	*/
; 10834: 	if (xmlStrEqual(thisTargetNamespace, namespaceName)) {

	push	eax
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlSchemaP

; 10835: 	    xmlSchemaPCustomErr(pctxt,

	push	esi
	push	OFFSET ??_C@_0GI@OLOMMMCB@The?5value?5of?5the?5attribute?5?8nam@
	push	ebx
	push	0
	push	3064					; 00000bf8H

; 10850: 		XML_SCHEMAP_SRC_IMPORT_1_2,
; 10851: 		NULL, node,
; 10852: 		"The attribute 'namespace' must be existent if "
; 10853: 		"the importing schema has no target namespace",
; 10854: 		NULL);
; 10855: 	    return (pctxt->err);

	push	edi
	call	_xmlSchemaPCustomErr
	mov	eax, DWORD PTR [edi+16]
	add	esp, 24					; 00000018H
$LN78@xmlSchemaP:

; 10891: }

	pop	esi
	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlSchemaP:

; 10836: 		XML_SCHEMAP_SRC_IMPORT_1_1,
; 10837: 		NULL, node,
; 10838: 		"The value of the attribute 'namespace' must not match "
; 10839: 		"the target namespace '%s' of the importing schema",
; 10840: 		thisTargetNamespace);
; 10841: 	    return (pctxt->err);
; 10842: 	}
; 10843:     } else {
; 10844: 	/*
; 10845: 	* 1.2 If the namespace [attribute] is not present, then the enclosing
; 10846: 	* <schema> must have a targetNamespace [attribute].
; 10847: 	*/
; 10848: 	if (thisTargetNamespace == NULL) {

	test	esi, esi
	jne	SHORT $LN17@xmlSchemaP

; 10849: 	    xmlSchemaPCustomErr(pctxt,

	push	esi
	push	OFFSET ??_C@_0FL@GDFMFMFB@The?5attribute?5?8namespace?8?5must?5@
	push	ebx
	push	esi
	push	3065					; 00000bf9H

; 10850: 		XML_SCHEMAP_SRC_IMPORT_1_2,
; 10851: 		NULL, node,
; 10852: 		"The attribute 'namespace' must be existent if "
; 10853: 		"the importing schema has no target namespace",
; 10854: 		NULL);
; 10855: 	    return (pctxt->err);

	push	edi
	call	_xmlSchemaPCustomErr
	mov	eax, DWORD PTR [edi+16]
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi

; 10891: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlSchemaP:

; 10856: 	}
; 10857:     }
; 10858:     /*
; 10859:     * Locate and acquire the schema document.
; 10860:     */
; 10861:     if (schemaLocation != NULL)

	mov	esi, DWORD PTR _schemaLocation$1$[ebp]
	test	esi, esi
	je	SHORT $LN18@xmlSchemaP

; 10862: 	schemaLocation = xmlSchemaBuildAbsoluteURI(pctxt->dict,

	push	ebx
	push	esi
	push	DWORD PTR [edi+80]
	call	_xmlSchemaBuildAbsoluteURI
	add	esp, 12					; 0000000cH
	mov	esi, eax
$LN18@xmlSchemaP:

; 10863: 	    schemaLocation, node);
; 10864:     ret = xmlSchemaAddSchemaDoc(pctxt, XML_SCHEMA_SCHEMA_IMPORT,

	lea	eax, DWORD PTR _bucket$[ebp]
	push	eax
	push	DWORD PTR _namespaceName$[ebp]
	push	DWORD PTR _thisTargetNamespace$1$[ebp]
	push	ebx
	push	0
	push	0
	push	0
	push	esi
	push	1
	push	edi
	call	_xmlSchemaAddSchemaDoc
	add	esp, 40					; 00000028H
	mov	DWORD PTR _ret$1$[ebp], eax

; 10865: 	schemaLocation, NULL, NULL, 0, node, thisTargetNamespace,
; 10866: 	namespaceName, &bucket);
; 10867: 
; 10868:     if (ret != 0)

	test	eax, eax
	jne	SHORT $LN78@xmlSchemaP

; 10869: 	return(ret);
; 10870: 
; 10871:     /*
; 10872:     * For <import>: "It is *not* an error for the application
; 10873:     * schema reference strategy to fail."
; 10874:     * So just don't parse if no schema document was found.
; 10875:     * Note that we will get no bucket if the schema could not be
; 10876:     * located or if there was no schemaLocation.
; 10877:     */
; 10878:     if ((bucket == NULL) && (schemaLocation != NULL)) {

	mov	eax, DWORD PTR _bucket$[ebp]
	test	eax, eax
	jne	SHORT $LN71@xmlSchemaP
	test	esi, esi
	je	SHORT $LN77@xmlSchemaP

; 10879: 	xmlSchemaCustomWarning(ACTXT_CAST pctxt,

	push	eax
	push	eax
	push	esi
	push	OFFSET ??_C@_0EA@NKOOPGEC@Failed?5to?5locate?5a?5schema?5at?5lo@
	push	eax
	push	ebx
	push	3084					; 00000c0cH
	push	edi
	call	_xmlSchemaCustomWarning
	add	esp, 32					; 00000020H
$LN77@xmlSchemaP:

; 10888:     }
; 10889: 
; 10890:     return (ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	esi
	pop	edi

; 10891: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@xmlSchemaP:

; 10880: 	    XML_SCHEMAP_WARN_UNLOCATED_SCHEMA,
; 10881: 	    node, NULL,
; 10882: 	    "Failed to locate a schema at location '%s'. "
; 10883: 	    "Skipping the import", schemaLocation, NULL, NULL);
; 10884:     }
; 10885: 
; 10886:     if ((bucket != NULL) && CAN_PARSE_SCHEMA(bucket)) {

	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN77@xmlSchemaP
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN77@xmlSchemaP

; 10887: 	ret = xmlSchemaParseNewDoc(pctxt, schema, bucket);

	push	eax
	push	DWORD PTR _schema$[ebp]
	push	edi
	call	_xmlSchemaParseNewDoc
	add	esp, 12					; 0000000cH
	pop	esi
	pop	edi

; 10891: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlSchemaP:
	pop	edi

; 10758:         return (-1);

	or	eax, -1

; 10891: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseImport ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFacetTypeToString
_TEXT	SEGMENT
_type$ = 8						; size = 4
_xmlSchemaFacetTypeToString PROC			; COMDAT

; 21528: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	add	eax, -1000				; fffffc18H
	cmp	eax, 11					; 0000000bH
	ja	SHORT $LN16@xmlSchemaF

; 21529:     switch (type) {

	jmp	DWORD PTR $LN19@xmlSchemaF[eax*4]
$LN4@xmlSchemaF:

; 21530:         case XML_SCHEMA_FACET_PATTERN:
; 21531:             return (BAD_CAST "pattern");

	mov	eax, OFFSET ??_C@_07CHFOACKJ@pattern@

; 21558: }

	pop	ebp
	ret	0
$LN5@xmlSchemaF:

; 21532:         case XML_SCHEMA_FACET_MAXEXCLUSIVE:
; 21533:             return (BAD_CAST "maxExclusive");

	mov	eax, OFFSET ??_C@_0N@IEJNIJII@maxExclusive@

; 21558: }

	pop	ebp
	ret	0
$LN6@xmlSchemaF:

; 21534:         case XML_SCHEMA_FACET_MAXINCLUSIVE:
; 21535:             return (BAD_CAST "maxInclusive");

	mov	eax, OFFSET ??_C@_0N@EBHLFCPN@maxInclusive@

; 21558: }

	pop	ebp
	ret	0
$LN7@xmlSchemaF:

; 21536:         case XML_SCHEMA_FACET_MINEXCLUSIVE:
; 21537:             return (BAD_CAST "minExclusive");

	mov	eax, OFFSET ??_C@_0N@MENCPBPO@minExclusive@

; 21558: }

	pop	ebp
	ret	0
$LN8@xmlSchemaF:

; 21538:         case XML_SCHEMA_FACET_MININCLUSIVE:
; 21539:             return (BAD_CAST "minInclusive");

	mov	eax, OFFSET ??_C@_0N@BDECKIL@minInclusive@

; 21558: }

	pop	ebp
	ret	0
$LN9@xmlSchemaF:

; 21540:         case XML_SCHEMA_FACET_WHITESPACE:
; 21541:             return (BAD_CAST "whiteSpace");

	mov	eax, OFFSET ??_C@_0L@CCEMGGFL@whiteSpace@

; 21558: }

	pop	ebp
	ret	0
$LN10@xmlSchemaF:

; 21542:         case XML_SCHEMA_FACET_ENUMERATION:
; 21543:             return (BAD_CAST "enumeration");

	mov	eax, OFFSET ??_C@_0M@FJOIDAAJ@enumeration@

; 21558: }

	pop	ebp
	ret	0
$LN11@xmlSchemaF:

; 21544:         case XML_SCHEMA_FACET_LENGTH:
; 21545:             return (BAD_CAST "length");

	mov	eax, OFFSET ??_C@_06IJDLPEM@length@

; 21558: }

	pop	ebp
	ret	0
$LN12@xmlSchemaF:

; 21546:         case XML_SCHEMA_FACET_MAXLENGTH:
; 21547:             return (BAD_CAST "maxLength");

	mov	eax, OFFSET ??_C@_09KJHMKBNK@maxLength@

; 21558: }

	pop	ebp
	ret	0
$LN13@xmlSchemaF:

; 21548:         case XML_SCHEMA_FACET_MINLENGTH:
; 21549:             return (BAD_CAST "minLength");

	mov	eax, OFFSET ??_C@_09KIHADLGO@minLength@

; 21558: }

	pop	ebp
	ret	0
$LN14@xmlSchemaF:

; 21550:         case XML_SCHEMA_FACET_TOTALDIGITS:
; 21551:             return (BAD_CAST "totalDigits");

	mov	eax, OFFSET ??_C@_0M@PGNNBCIB@totalDigits@

; 21558: }

	pop	ebp
	ret	0
$LN15@xmlSchemaF:

; 21552:         case XML_SCHEMA_FACET_FRACTIONDIGITS:
; 21553:             return (BAD_CAST "fractionDigits");

	mov	eax, OFFSET ??_C@_0P@EPJLKDGA@fractionDigits@

; 21558: }

	pop	ebp
	ret	0
$LN16@xmlSchemaF:

; 21554:         default:
; 21555:             break;
; 21556:     }
; 21557:     return (BAD_CAST "Internal Error");

	mov	eax, OFFSET ??_C@_0P@DAONFGNJ@Internal?5Error@

; 21558: }

	pop	ebp
	ret	0
$LN19@xmlSchemaF:
	DD	$LN8@xmlSchemaF
	DD	$LN7@xmlSchemaF
	DD	$LN6@xmlSchemaF
	DD	$LN5@xmlSchemaF
	DD	$LN14@xmlSchemaF
	DD	$LN15@xmlSchemaF
	DD	$LN4@xmlSchemaF
	DD	$LN10@xmlSchemaF
	DD	$LN9@xmlSchemaF
	DD	$LN11@xmlSchemaF
	DD	$LN12@xmlSchemaF
	DD	$LN13@xmlSchemaF
_xmlSchemaFacetTypeToString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaTypeFixup
_TEXT	SEGMENT
_type$ = 8						; size = 4
_actxt$ = 12						; size = 4
_xmlSchemaTypeFixup PROC				; COMDAT

; 18639: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaT

; 18640:     if (type == NULL)
; 18641:         return(0);
; 18642:     if (actxt->type != XML_SCHEMA_CTXT_PARSER) {

	mov	ecx, DWORD PTR _actxt$[ebp]
	cmp	DWORD PTR [ecx], 1
	je	SHORT $LN3@xmlSchemaT

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0CF@EHENJODP@this?5function?5needs?5a?5parser?5co@
	push	OFFSET ??_C@_0BD@JIKEDLJK@xmlSchemaTypeFixup@
	push	ecx
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 18643: 	AERROR_INT("xmlSchemaTypeFixup",
; 18644: 	    "this function needs a parser context");
; 18645: 	return(-1);

	or	eax, -1

; 18653:     return(0);
; 18654: }

	pop	ebp
	ret	0
$LN3@xmlSchemaT:

; 18646:     }
; 18647:     if (! WXS_IS_TYPE_NOT_FIXED(type))

	mov	edx, DWORD PTR [eax]
	cmp	edx, 1
	je	SHORT $LN5@xmlSchemaT
	test	DWORD PTR [eax+48], 4194304		; 00400000H
	jne	SHORT $LN5@xmlSchemaT

; 18649:     if (type->type == XML_SCHEMA_TYPE_COMPLEX)

	cmp	edx, 5
	jne	SHORT $LN6@xmlSchemaT

; 18650: 	return(xmlSchemaFixupComplexType(PCTXT_CAST actxt, type));

	mov	DWORD PTR _actxt$[ebp], eax
	mov	DWORD PTR _type$[ebp], ecx

; 18653:     return(0);
; 18654: }

	pop	ebp

; 18650: 	return(xmlSchemaFixupComplexType(PCTXT_CAST actxt, type));

	jmp	_xmlSchemaFixupComplexType
$LN6@xmlSchemaT:

; 18651:     else if (type->type == XML_SCHEMA_TYPE_SIMPLE)

	cmp	edx, 4
	jne	SHORT $LN5@xmlSchemaT

; 18652: 	return(xmlSchemaFixupSimpleTypeStageTwo(PCTXT_CAST actxt, type));

	mov	DWORD PTR _actxt$[ebp], eax
	mov	DWORD PTR _type$[ebp], ecx

; 18653:     return(0);
; 18654: }

	pop	ebp

; 18652: 	return(xmlSchemaFixupSimpleTypeStageTwo(PCTXT_CAST actxt, type));

	jmp	_xmlSchemaFixupSimpleTypeStageTwo
$LN5@xmlSchemaT:

; 18648: 	return(0);

	xor	eax, eax

; 18653:     return(0);
; 18654: }

	pop	ebp
	ret	0
_xmlSchemaTypeFixup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseRedefine
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaParseRedefine PROC				; COMDAT

; 11200: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	3
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _schema$[ebp]
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaParseIncludeOrRedefine
	add	esp, 16					; 00000010H

; 11201:     int res;
; 11202: #ifndef ENABLE_REDEFINE
; 11203:     TODO
; 11204:     return(0);
; 11205: #endif
; 11206:     res = xmlSchemaParseIncludeOrRedefine(pctxt, schema, node,
; 11207: 	XML_SCHEMA_SCHEMA_REDEFINE);
; 11208:     if (res != 0)
; 11209: 	return(res);
; 11210:     return(0);
; 11211: }

	pop	ebp
	ret	0
_xmlSchemaParseRedefine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParseInclude
_TEXT	SEGMENT
_pctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchemaParseInclude PROC				; COMDAT

; 11216: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	2
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _schema$[ebp]
	push	DWORD PTR _pctxt$[ebp]
	call	_xmlSchemaParseIncludeOrRedefine
	add	esp, 16					; 00000010H

; 11217:     int res;
; 11218: 
; 11219:     res = xmlSchemaParseIncludeOrRedefine(pctxt, schema, node,
; 11220: 	XML_SCHEMA_SCHEMA_INCLUDE);
; 11221:     if (res != 0)
; 11222: 	return(res);
; 11223:     return(0);
; 11224: }

	pop	ebp
	ret	0
_xmlSchemaParseInclude ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeFacet
_TEXT	SEGMENT
_facet$ = 8						; size = 4
_xmlSchemaFreeFacet PROC				; COMDAT

; 3972 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _facet$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlSchemaF

; 3973 :     if (facet == NULL)
; 3974 :         return;
; 3975 :     if (facet->val != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaF

; 3976 :         xmlSchemaFreeValue(facet->val);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN3@xmlSchemaF:

; 3977 :     if (facet->regexp != NULL)

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaF

; 3978 :         xmlRegFreeRegexp(facet->regexp);

	push	eax
	call	_xmlRegFreeRegexp
	add	esp, 4
$LN4@xmlSchemaF:

; 3979 :     if (facet->annot != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaF

; 3980 :         xmlSchemaFreeAnnot(facet->annot);

	push	eax
	call	_xmlSchemaFreeAnnot
	add	esp, 4
$LN5@xmlSchemaF:

; 3981 :     xmlFree(facet);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlSchemaF:
	pop	esi

; 3982 : }

	pop	ebp
	ret	0
_xmlSchemaFreeFacet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaCheckFacet
_TEXT	SEGMENT
tv555 = -8						; size = 4
_ret$1$ = -4						; size = 4
_str$1 = 8						; size = 4
_facet$ = 8						; size = 4
_typeDecl$ = 12						; size = 4
_pctxt$ = 16						; size = 4
_name$ = 20						; size = 4
_xmlSchemaCheckFacet PROC				; COMDAT

; 18673: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _pctxt$[ebp]
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	mov	DWORD PTR tv555[ebp], edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _facet$[ebp]
	mov	DWORD PTR _ret$1$[ebp], 0
	test	ebx, ebx
	je	SHORT $LN5@xmlSchemaC

; 18674:     int ret = 0, ctxtGiven;
; 18675: 
; 18676:     if ((facet == NULL) || (typeDecl == NULL))

	mov	esi, DWORD PTR _typeDecl$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlSchemaC

; 18677:         return(-1);
; 18678:     /*
; 18679:     * TODO: will the parser context be given if used from
; 18680:     * the relaxNG module?
; 18681:     */
; 18682:     if (pctxt == NULL)
; 18683: 	ctxtGiven = 0;
; 18684:     else
; 18685: 	ctxtGiven = 1;
; 18686: 
; 18687:     switch (facet->type) {

	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [ecx-1000]
	cmp	eax, 11					; 0000000bH
	ja	$exit$53
	movzx	eax, BYTE PTR $LN48@xmlSchemaC[eax]
	jmp	DWORD PTR $LN52@xmlSchemaC[eax*4]
$LN8@xmlSchemaC:

; 18688:         case XML_SCHEMA_FACET_MININCLUSIVE:
; 18689:         case XML_SCHEMA_FACET_MINEXCLUSIVE:
; 18690:         case XML_SCHEMA_FACET_MAXINCLUSIVE:
; 18691:         case XML_SCHEMA_FACET_MAXEXCLUSIVE:
; 18692: 	case XML_SCHEMA_FACET_ENUMERATION: {
; 18693:                 /*
; 18694:                  * Okay we need to validate the value
; 18695:                  * at that point.
; 18696:                  */
; 18697: 		xmlSchemaTypePtr base;
; 18698: 
; 18699: 		/* 4.3.5.5 Constraints on enumeration Schema Components
; 18700: 		* Schema Component Constraint: enumeration valid restriction
; 18701: 		* It is an `error` if any member of {value} is not in the
; 18702: 		* `value space` of {base type definition}.
; 18703: 		*
; 18704: 		* minInclusive, maxInclusive, minExclusive, maxExclusive:
; 18705: 		* The value `must` be in the
; 18706: 		* `value space` of the `base type`.
; 18707: 		*/
; 18708: 		/*
; 18709: 		* This function is intended to deliver a compiled value
; 18710: 		* on the facet. In this implementation of XML Schemata the
; 18711: 		* type holding a facet, won't be a built-in type.
; 18712: 		* Thus to ensure that other API
; 18713: 		* calls (relaxng) do work, if the given type is a built-in
; 18714: 		* type, we will assume that the given built-in type *is
; 18715: 		* already* the base type.
; 18716: 		*/
; 18717: 		if (typeDecl->type != XML_SCHEMA_TYPE_BASIC) {

	cmp	DWORD PTR [esi], 1
	je	SHORT $LN9@xmlSchemaC

; 18718: 		    base = typeDecl->baseType;

	mov	esi, DWORD PTR [esi+64]

; 18719: 		    if (base == NULL) {

	test	esi, esi
	jne	SHORT $LN9@xmlSchemaC

; 18720: 			PERROR_INT("xmlSchemaCheckFacet",

	push	OFFSET ??_C@_0CK@KJAODNIP@a?5type?5user?5derived?5type?5has?5no@
$LN50@xmlSchemaC:

; 18866:     return (-1);
; 18867: }

	push	OFFSET ??_C@_0BE@GOHHCECA@xmlSchemaCheckFacet@
	push	edi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH
$LN5@xmlSchemaC:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlSchemaC:

; 18721: 			    "a type user derived type has no base type");
; 18722: 			return (-1);
; 18723: 		    }
; 18724: 		} else
; 18725: 		    base = typeDecl;
; 18726: 
; 18727: 		if (! ctxtGiven) {

	test	edi, edi
	jne	SHORT $LN47@xmlSchemaC

; 18728: 		    /*
; 18729: 		    * A context is needed if called from RelaxNG.
; 18730: 		    */
; 18731: 		    pctxt = xmlSchemaNewParserCtxt("*");

	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	call	_xmlSchemaNewParserCtxt
	mov	edi, eax
	add	esp, 4

; 18732: 		    if (pctxt == NULL)

	test	edi, edi
	je	SHORT $LN5@xmlSchemaC
$LN47@xmlSchemaC:

; 18733: 			return (-1);
; 18734: 		}
; 18735: 		/*
; 18736: 		* NOTE: This call does not check the content nodes,
; 18737: 		* since they are not available:
; 18738: 		* facet->node is just the node holding the facet
; 18739: 		* definition, *not* the attribute holding the *value*
; 18740: 		* of the facet.
; 18741: 		*/
; 18742: 		ret = xmlSchemaVCheckCVCSimpleType(

	push	0
	push	1
	push	1
	lea	eax, DWORD PTR [ebx+32]
	push	eax
	push	DWORD PTR [ebx+8]
	push	esi
	push	DWORD PTR [ebx+20]
	push	edi
	call	_xmlSchemaVCheckCVCSimpleType
	add	esp, 32					; 00000020H
	mov	DWORD PTR _ret$1$[ebp], eax

; 18743: 		    ACTXT_CAST pctxt, facet->node, base,
; 18744: 		    facet->value, &(facet->val), 1, 1, 0);
; 18745:                 if (ret != 0) {

	test	eax, eax
	je	$LN14@xmlSchemaC

; 18746: 		    if (ret < 0) {

	jns	SHORT $LN16@xmlSchemaC

; 18747: 			/* No error message for RelaxNG. */
; 18748: 			if (ctxtGiven) {

	cmp	DWORD PTR tv555[ebp], 0
	je	SHORT $LN46@xmlSchemaC

; 18749: 			    xmlSchemaCustomErr(ACTXT_CAST pctxt,

	push	DWORD PTR [ebx]
	call	_xmlSchemaFacetTypeToString
	push	eax
	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0GP@JDEDDDKD@Internal?5error?3?5xmlSchemaCheckF@
	push	0
	push	DWORD PTR [ebx+20]
	push	3069					; 00000bfdH
	push	edi
	call	_xmlSchemaCustomErr
	add	esp, 32					; 00000020H

; 18866:     return (-1);
; 18867: }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@xmlSchemaC:

; 18863: internal_error:
; 18864:     if ((! ctxtGiven) && (pctxt != NULL))

	test	edi, edi
	je	SHORT $LN5@xmlSchemaC

; 18865: 	xmlSchemaFreeParserCtxt(pctxt);

	push	edi
	call	_xmlSchemaFreeParserCtxt
	add	esp, 4
$internal_error$54:

; 18866:     return (-1);
; 18867: }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlSchemaC:

; 18750: 				XML_SCHEMAP_INTERNAL, facet->node, NULL,
; 18751: 				"Internal error: xmlSchemaCheckFacet, "
; 18752: 				"failed to validate the value '%s' of the "
; 18753: 				"facet '%s' against the base type",
; 18754: 				facet->value, xmlSchemaFacetTypeToString(facet->type));
; 18755: 			}
; 18756: 			goto internal_error;
; 18757: 		    }
; 18758: 		    ret = XML_SCHEMAP_INVALID_FACET_VALUE;
; 18759: 		    /* No error message for RelaxNG. */
; 18760: 		    if (ctxtGiven) {

	cmp	DWORD PTR tv555[ebp], 0
	mov	DWORD PTR _ret$1$[ebp], 1717		; 000006b5H
	je	$LN45@xmlSchemaC

; 18761: 			xmlChar *str = NULL;
; 18762: 
; 18763: 			xmlSchemaCustomErr(ACTXT_CAST pctxt,

	push	DWORD PTR [esi+8]
	lea	eax, DWORD PTR _str$1[ebp]
	mov	DWORD PTR _str$1[ebp], 0
	push	DWORD PTR [esi+112]
	push	eax
	call	_xmlSchemaFormatQName
	push	eax
	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0EJ@BAMFGHGG@The?5value?5?8?$CFs?8?5of?5the?5facet?5doe@
	push	ebx
	push	DWORD PTR [ebx+20]
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaCustomErr

; 18764: 			    ret, facet->node, WXS_BASIC_CAST facet,
; 18765: 			    "The value '%s' of the facet does not validate "
; 18766: 			    "against the base type '%s'",
; 18767: 			    facet->value,
; 18768: 			    xmlSchemaFormatQName(&str,
; 18769: 				base->targetNamespace, base->name));
; 18770: 			FREE_AND_NULL(str);

	mov	eax, DWORD PTR _str$1[ebp]
	add	esp, 40					; 00000028H
	test	eax, eax
	je	$exit$53
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 18771: 		    }
; 18772: 		    goto exit;

	jmp	$exit$53
$LN14@xmlSchemaC:

; 18773:                 } else if (facet->val == NULL) {

	cmp	DWORD PTR [ebx+32], 0
	jne	$exit$53

; 18774: 		    if (ctxtGiven) {

	cmp	DWORD PTR tv555[ebp], 0
	je	SHORT $LN21@xmlSchemaC

; 18775: 			PERROR_INT("xmlSchemaCheckFacet",

	push	OFFSET ??_C@_0BH@DKKABPAP@value?5was?5not?5computed@
	push	OFFSET ??_C@_0BE@GOHHCECA@xmlSchemaCheckFacet@
	push	edi
	call	_xmlSchemaInternalErr
	add	esp, 12					; 0000000cH
$LN21@xmlSchemaC:

; 18776: 			    "value was not computed");
; 18777: 		    }
; 18778: 		    TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	18778					; 0000495aH
	push	OFFSET ??_C@_0GM@IJCDLDON@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H

; 18779: 		}
; 18780:                 break;

	jmp	$exit$53
$LN22@xmlSchemaC:

; 18781:             }
; 18782:         case XML_SCHEMA_FACET_PATTERN:
; 18783:             facet->regexp = xmlRegexpCompile(facet->value);

	push	DWORD PTR [ebx+8]
	call	_xmlRegexpCompile
	add	esp, 4
	mov	DWORD PTR [ebx+36], eax

; 18784:             if (facet->regexp == NULL) {

	test	eax, eax
	jne	$exit$53

; 18785: 		ret = XML_SCHEMAP_REGEXP_INVALID;

	mov	eax, 1756				; 000006dcH
	mov	DWORD PTR _ret$1$[ebp], eax

; 18786: 		/* No error message for RelaxNG. */
; 18787: 		if (ctxtGiven) {

	test	edi, edi
	je	$LN41@xmlSchemaC

; 18788: 		    xmlSchemaCustomErr(ACTXT_CAST pctxt,

	push	0
	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0EI@FMIFFGFN@The?5value?5?8?$CFs?8?5of?5the?5facet?5?8pa@
	push	esi
	push	DWORD PTR [ebx+20]
	push	eax

; 18789: 			ret, facet->node, WXS_BASIC_CAST typeDecl,
; 18790: 			"The value '%s' of the facet 'pattern' is not a "
; 18791: 			"valid regular expression",
; 18792: 			facet->value, NULL);
; 18793: 		}
; 18794:             }
; 18795:             break;

	jmp	$LN49@xmlSchemaC
$LN25@xmlSchemaC:

; 18796:         case XML_SCHEMA_FACET_TOTALDIGITS:
; 18797:         case XML_SCHEMA_FACET_FRACTIONDIGITS:
; 18798:         case XML_SCHEMA_FACET_LENGTH:
; 18799:         case XML_SCHEMA_FACET_MAXLENGTH:
; 18800:         case XML_SCHEMA_FACET_MINLENGTH:
; 18801: 
; 18802: 	    if (facet->type == XML_SCHEMA_FACET_TOTALDIGITS) {

	mov	esi, DWORD PTR [ebx+8]

; 18803: 		ret = xmlSchemaValidatePredefinedType(
; 18804: 		    xmlSchemaGetBuiltInType(XML_SCHEMAS_PINTEGER),
; 18805: 		    facet->value, &(facet->val));
; 18806: 	    } else {
; 18807: 		ret = xmlSchemaValidatePredefinedType(
; 18808: 		    xmlSchemaGetBuiltInType(XML_SCHEMAS_NNINTEGER),
; 18809: 		    facet->value, &(facet->val));
; 18810: 	    }
; 18811: 	    if (ret != 0) {

	xor	eax, eax
	cmp	ecx, 1004				; 000003ecH
	sete	al
	add	eax, 33					; 00000021H
	push	eax
	call	_xmlSchemaGetBuiltInType
	lea	ecx, DWORD PTR [ebx+32]
	push	ecx
	push	esi
	push	eax
	call	_xmlSchemaValidatePredefinedType
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$1$[ebp], eax
	test	eax, eax
	je	$exit$53

; 18812: 		if (ret < 0) {

	jns	SHORT $LN29@xmlSchemaC

; 18813: 		    /* No error message for RelaxNG. */
; 18814: 		    if (ctxtGiven) {

	test	edi, edi
	je	$LN5@xmlSchemaC

; 18815: 			PERROR_INT("xmlSchemaCheckFacet",

	push	OFFSET ??_C@_0BH@ODKMLHFB@validating?5facet?5value@

; 18863: internal_error:
; 18864:     if ((! ctxtGiven) && (pctxt != NULL))

	jmp	$LN50@xmlSchemaC
$LN29@xmlSchemaC:

; 18816: 			    "validating facet value");
; 18817: 		    }
; 18818: 		    goto internal_error;
; 18819: 		}
; 18820: 		ret = XML_SCHEMAP_INVALID_FACET_VALUE;

	mov	DWORD PTR _ret$1$[ebp], 1717		; 000006b5H

; 18821: 		/* No error message for RelaxNG. */
; 18822: 		if (ctxtGiven) {

	test	edi, edi
	je	$LN41@xmlSchemaC

; 18823: 		    /* error code */
; 18824: 		    xmlSchemaCustomErr4(ACTXT_CAST pctxt,

	mov	ecx, DWORD PTR [ebx]
	mov	edx, OFFSET ??_C@_0BA@PNFEGAHG@positiveInteger@
	cmp	ecx, 1004				; 000003ecH
	mov	eax, OFFSET ??_C@_0BD@IEOLADAC@nonNegativeInteger@
	push	0
	cmove	eax, edx
	push	eax
	push	ecx
	call	_xmlSchemaFacetTypeToString
	add	esp, 4
	push	eax
	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0DF@HPIINFD@The?5value?5?8?$CFs?8?5of?5the?5facet?5?8?$CFs@
	push	DWORD PTR _typeDecl$[ebp]
	push	DWORD PTR [ebx+20]
	push	1717					; 000006b5H
	push	edi
	call	_xmlSchemaCustomErr4
	add	esp, 36					; 00000024H

; 18825: 			ret, facet->node, WXS_BASIC_CAST typeDecl,
; 18826: 			"The value '%s' of the facet '%s' is not a valid '%s'",
; 18827: 			facet->value,
; 18828: 			xmlSchemaFacetTypeToString(facet->type),
; 18829: 			(facet->type != XML_SCHEMA_FACET_TOTALDIGITS) ?
; 18830: 			    BAD_CAST "nonNegativeInteger" :
; 18831: 			    BAD_CAST "positiveInteger",
; 18832: 			NULL);
; 18833: 		}
; 18834: 	    }
; 18835: 	    break;

	jmp	SHORT $exit$53
$LN32@xmlSchemaC:

; 18836: 
; 18837:         case XML_SCHEMA_FACET_WHITESPACE:{
; 18838:                 if (xmlStrEqual(facet->value, BAD_CAST "preserve")) {

	push	OFFSET ??_C@_08ILAKLJGO@preserve@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@xmlSchemaC

; 18839:                     facet->whitespace = XML_SCHEMAS_FACET_PRESERVE;

	mov	DWORD PTR [ebx+28], 1
	jmp	SHORT $exit$53
$LN33@xmlSchemaC:

; 18840:                 } else if (xmlStrEqual(facet->value, BAD_CAST "replace")) {

	push	OFFSET ??_C@_07CLEHDIEJ@replace@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN35@xmlSchemaC

; 18841:                     facet->whitespace = XML_SCHEMAS_FACET_REPLACE;

	mov	DWORD PTR [ebx+28], 2
	jmp	SHORT $exit$53
$LN35@xmlSchemaC:

; 18842:                 } else if (xmlStrEqual(facet->value, BAD_CAST "collapse")) {

	push	OFFSET ??_C@_08MHKDLKBN@collapse@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN37@xmlSchemaC

; 18843:                     facet->whitespace = XML_SCHEMAS_FACET_COLLAPSE;

	mov	DWORD PTR [ebx+28], 3

; 18844:                 } else {

	jmp	SHORT $exit$53
$LN37@xmlSchemaC:

; 18845: 		    ret = XML_SCHEMAP_INVALID_FACET_VALUE;

	mov	eax, 1717				; 000006b5H
	mov	DWORD PTR _ret$1$[ebp], eax

; 18846:                     /* No error message for RelaxNG. */
; 18847: 		    if (ctxtGiven) {

	test	edi, edi
	je	SHORT $LN41@xmlSchemaC

; 18848: 			/* error was previously: XML_SCHEMAP_INVALID_WHITE_SPACE */
; 18849: 			xmlSchemaCustomErr(ACTXT_CAST pctxt,

	push	0
	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0DG@BFJCEJH@The?5value?5?8?$CFs?8?5of?5the?5facet?5?8wh@
	push	esi
	push	DWORD PTR [ebx+20]
	push	eax
$LN49@xmlSchemaC:

; 18850: 			    ret, facet->node, WXS_BASIC_CAST typeDecl,
; 18851: 			    "The value '%s' of the facet 'whitespace' is not "
; 18852: 			    "valid", facet->value, NULL);
; 18853:                     }
; 18854:                 }
; 18855:             }
; 18856:         default:
; 18857:             break;
; 18858:     }
; 18859: exit:
; 18860:     if ((! ctxtGiven) && (pctxt != NULL))

	push	edi
	call	_xmlSchemaCustomErr
	add	esp, 28					; 0000001cH
$exit$53:
	cmp	DWORD PTR tv555[ebp], 0
	jne	SHORT $LN41@xmlSchemaC
$LN45@xmlSchemaC:
	test	edi, edi
	je	SHORT $LN41@xmlSchemaC

; 18861: 	xmlSchemaFreeParserCtxt(pctxt);

	push	edi
	call	_xmlSchemaFreeParserCtxt
	add	esp, 4
$LN41@xmlSchemaC:

; 18862:     return (ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 18866:     return (-1);
; 18867: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN52@xmlSchemaC:
	DD	$LN8@xmlSchemaC
	DD	$LN25@xmlSchemaC
	DD	$LN22@xmlSchemaC
	DD	$LN32@xmlSchemaC
$LN48@xmlSchemaC:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	2
	DB	0
	DB	3
	DB	1
	DB	1
	DB	1
_xmlSchemaCheckFacet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaNewFacet
_TEXT	SEGMENT
_xmlSchemaNewFacet PROC					; COMDAT
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaN

; 3308 : 
; 3309 :     return (ret);
; 3310 : }

	ret	0
$LN2@xmlSchemaN:
	xorps	xmm0, xmm0

; 3301 :     xmlSchemaFacetPtr ret;
; 3302 : 
; 3303 :     ret = (xmlSchemaFacetPtr) xmlMalloc(sizeof(xmlSchemaFacet));
; 3304 :     if (ret == NULL) {
; 3305 :         return (NULL);
; 3306 :     }
; 3307 :     memset(ret, 0, sizeof(xmlSchemaFacet));

	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0

; 3308 : 
; 3309 :     return (ret);
; 3310 : }

	ret	0
_xmlSchemaNewFacet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeWildcard
_TEXT	SEGMENT
_wildcard$ = 8						; size = 4
_xmlSchemaFreeWildcard PROC				; COMDAT

; 3834 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _wildcard$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlSchemaF

; 3835 :     if (wildcard == NULL)
; 3836 :         return;
; 3837 :     if (wildcard->annot != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaF

; 3838 :         xmlSchemaFreeAnnot(wildcard->annot);

	push	eax
	call	_xmlSchemaFreeAnnot
	add	esp, 4
$LN3@xmlSchemaF:

; 3839 :     if (wildcard->nsSet != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaF

; 3840 : 	xmlSchemaFreeWildcardNsSet(wildcard->nsSet);

	push	eax
	call	_xmlSchemaFreeWildcardNsSet
	add	esp, 4
$LN4@xmlSchemaF:

; 3841 :     if (wildcard->negNsSet != NULL)

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaF

; 3842 : 	xmlFree(wildcard->negNsSet);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlSchemaF:

; 3843 :     xmlFree(wildcard);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlSchemaF:
	pop	esi

; 3844 : }

	pop	ebp
	ret	0
_xmlSchemaFreeWildcard ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeType
_TEXT	SEGMENT
_type$ = 8						; size = 4
_xmlSchemaFreeType PROC					; COMDAT

; 3992 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _type$[ebp]
	test	ebx, ebx
	je	$LN1@xmlSchemaF

; 3993 :     if (type == NULL)
; 3994 :         return;
; 3995 :     if (type->annot != NULL)

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN8@xmlSchemaF

; 3996 :         xmlSchemaFreeAnnot(type->annot);

	push	eax
	call	_xmlSchemaFreeAnnot
	add	esp, 4
$LN8@xmlSchemaF:

; 3997 :     if (type->facets != NULL) {

	push	esi
	push	edi
	mov	edi, DWORD PTR [ebx+68]
	test	edi, edi
	je	SHORT $LN3@xmlSchemaF
$LL2@xmlSchemaF:

; 3975 :     if (facet->val != NULL)

	mov	eax, DWORD PTR [edi+32]

; 3998 :         xmlSchemaFacetPtr facet, next;
; 3999 : 
; 4000 :         facet = type->facets;
; 4001 :         while (facet != NULL) {
; 4002 :             next = facet->next;

	mov	ebx, DWORD PTR [edi+4]

; 3975 :     if (facet->val != NULL)

	test	eax, eax
	je	SHORT $LN17@xmlSchemaF

; 3976 :         xmlSchemaFreeValue(facet->val);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN17@xmlSchemaF:

; 3977 :     if (facet->regexp != NULL)

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN18@xmlSchemaF

; 3978 :         xmlRegFreeRegexp(facet->regexp);

	push	eax
	call	_xmlRegFreeRegexp
	add	esp, 4
$LN18@xmlSchemaF:

; 3979 :     if (facet->annot != NULL)

	mov	esi, DWORD PTR [edi+16]
	test	esi, esi
	je	SHORT $LN23@xmlSchemaF

; 3731 :     if (annot->next == NULL) {

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LL24@xmlSchemaF

; 3732 : 	xmlFree(annot);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3733 :     } else {

	jmp	SHORT $LN23@xmlSchemaF
	npad	3
$LL24@xmlSchemaF:

; 3734 : 	xmlSchemaAnnotPtr prev;
; 3735 : 
; 3736 : 	do {
; 3737 : 	    prev = annot;
; 3738 : 	    annot = annot->next;
; 3739 : 	    xmlFree(prev);

	push	esi
	mov	esi, DWORD PTR [esi]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3740 : 	} while (annot != NULL);

	test	esi, esi
	jne	SHORT $LL24@xmlSchemaF
$LN23@xmlSchemaF:

; 3981 :     xmlFree(facet);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 4003 :             xmlSchemaFreeFacet(facet);
; 4004 :             facet = next;

	mov	edi, ebx
	test	ebx, ebx
	jne	SHORT $LL2@xmlSchemaF
	mov	ebx, DWORD PTR _type$[ebp]
$LN3@xmlSchemaF:

; 4005 :         }
; 4006 :     }
; 4007 :     if (type->attrUses != NULL)

	mov	esi, DWORD PTR [ebx+116]
	test	esi, esi
	je	SHORT $LN29@xmlSchemaF

; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN31@xmlSchemaF

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN31@xmlSchemaF:

; 3534 :     xmlFree(list);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN29@xmlSchemaF:

; 4008 : 	xmlSchemaItemListFree((xmlSchemaItemListPtr) type->attrUses);
; 4009 :     if (type->memberTypes != NULL)

	mov	eax, DWORD PTR [ebx+92]
	test	eax, eax
	je	SHORT $LN35@xmlSchemaF
	npad	5
$LL34@xmlSchemaF:

; 3888 : 	next = link->next;

	mov	esi, DWORD PTR [eax]

; 3889 : 	xmlFree(link);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3890 : 	link = next;

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL34@xmlSchemaF
$LN35@xmlSchemaF:

; 4010 : 	xmlSchemaFreeTypeLinkList(type->memberTypes);
; 4011 :     if (type->facetSet != NULL) {

	mov	eax, DWORD PTR [ebx+96]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaF
	npad	7
$LL6@xmlSchemaF:

; 4012 : 	xmlSchemaFacetLinkPtr next, link;
; 4013 : 
; 4014 : 	link = type->facetSet;
; 4015 : 	do {
; 4016 : 	    next = link->next;

	mov	esi, DWORD PTR [eax]

; 4017 : 	    xmlFree(link);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 4018 : 	    link = next;

	mov	eax, esi

; 4019 : 	} while (link != NULL);

	test	esi, esi
	jne	SHORT $LL6@xmlSchemaF
$LN5@xmlSchemaF:

; 4020 :     }
; 4021 :     if (type->contModel != NULL)

	mov	eax, DWORD PTR [ebx+108]
	pop	edi
	pop	esi
	test	eax, eax
	je	SHORT $LN13@xmlSchemaF

; 4022 :         xmlRegFreeRegexp(type->contModel);

	push	eax
	call	_xmlRegFreeRegexp
	add	esp, 4
$LN13@xmlSchemaF:

; 4023 :     xmlFree(type);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlSchemaF:
	pop	ebx

; 4024 : }

	pop	ebp
	ret	0
_xmlSchemaFreeType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidateSetLocator
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_f$ = 12						; size = 4
_ctxt$ = 16						; size = 4
_xmlSchemaValidateSetLocator PROC			; COMDAT

; 28807: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _vctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@xmlSchemaV

; 28808:     if (vctxt == NULL) return;
; 28809:     vctxt->locFunc = f;

	mov	eax, DWORD PTR _f$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 28810:     vctxt->locCtxt = ctxt;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
$LN1@xmlSchemaV:

; 28811: }

	pop	ebp
	ret	0
_xmlSchemaValidateSetLocator ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSAXUnplug
_TEXT	SEGMENT
_plug$ = 8						; size = 4
_xmlSchemaSAXUnplug PROC				; COMDAT

; 28769: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _plug$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaS

; 28770:     xmlSAXHandlerPtr *sax;
; 28771:     void **user_data;
; 28772: 
; 28773:     if ((plug == NULL) || (plug->magic != XML_SAX_PLUG_MAGIC))

	cmp	DWORD PTR [esi], -599541215		; dc43ba21H
	jne	SHORT $LN3@xmlSchemaS

; 28775:     plug->magic = 0;

	push	edi

; 28776: 
; 28777:     xmlSchemaPostRun(plug->ctxt);

	mov	edi, DWORD PTR [esi+148]
	mov	DWORD PTR [esi], 0

; 28169:     if (vctxt->xsiAssemble) {

	cmp	DWORD PTR [edi+92], 0
	je	SHORT $LN8@xmlSchemaS

; 28170: 	if (vctxt->schema != NULL) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN8@xmlSchemaS

; 28171: 	    xmlSchemaFree(vctxt->schema);

	push	eax
	call	_xmlSchemaFree
	add	esp, 4

; 28172: 	    vctxt->schema = NULL;

	mov	DWORD PTR [edi+20], 0
$LN8@xmlSchemaS:

; 28173: 	}
; 28174:     }
; 28175:     xmlSchemaClearValidCtxt(vctxt);

	push	edi
	call	_xmlSchemaClearValidCtxt

; 28778:     /* restore the data */
; 28779:     sax = plug->user_sax_ptr;

	mov	ecx, DWORD PTR [esi+4]

; 28175:     xmlSchemaClearValidCtxt(vctxt);

	add	esp, 4

; 28780:     *sax = plug->user_sax;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx], eax

; 28781:     if (plug->user_sax != NULL) {

	cmp	DWORD PTR [esi+8], 0
	pop	edi
	je	SHORT $LN4@xmlSchemaS

; 28782: 	user_data = plug->user_data_ptr;

	mov	ecx, DWORD PTR [esi+12]

; 28783: 	*user_data = plug->user_data;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx], eax
$LN4@xmlSchemaS:

; 28784:     }
; 28785: 
; 28786:     /* free and return */
; 28787:     xmlFree(plug);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 28788:     return(0);

	xor	eax, eax
	pop	esi

; 28789: }

	pop	ebp
	ret	0
$LN3@xmlSchemaS:

; 28774:         return(-1);

	or	eax, -1
	pop	esi

; 28789: }

	pop	ebp
	ret	0
_xmlSchemaSAXUnplug ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSAXPlug
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_sax$ = 12						; size = 4
_user_data$ = 16					; size = 4
_xmlSchemaSAXPlug PROC					; COMDAT

; 28628: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	je	$LN3@xmlSchemaS

; 28629:     xmlSchemaSAXPlugPtr ret;
; 28630:     xmlSAXHandlerPtr old_sax;
; 28631: 
; 28632:     if ((ctxt == NULL) || (sax == NULL) || (user_data == NULL))

	mov	eax, DWORD PTR _sax$[ebp]
	test	eax, eax
	je	$LN3@xmlSchemaS
	cmp	DWORD PTR _user_data$[ebp], 0
	je	$LN3@xmlSchemaS

; 28633:         return(NULL);
; 28634: 
; 28635:     /*
; 28636:      * We only allow to plug into SAX2 event streams
; 28637:      */
; 28638:     old_sax = *sax;

	mov	edi, DWORD PTR [eax]

; 28639:     if ((old_sax != NULL) && (old_sax->initialized != XML_SAX2_MAGIC))

	test	edi, edi
	je	SHORT $LN5@xmlSchemaS
	cmp	DWORD PTR [edi+108], -554844497		; deedbeafH
	jne	$LN3@xmlSchemaS

; 28640:         return(NULL);
; 28641:     if ((old_sax != NULL) &&
; 28642:         (old_sax->startElementNs == NULL) && (old_sax->endElementNs == NULL) &&

	cmp	DWORD PTR [edi+116], 0
	jne	SHORT $LN5@xmlSchemaS
	cmp	DWORD PTR [edi+120], 0
	jne	SHORT $LN5@xmlSchemaS
	cmp	DWORD PTR [edi+56], 0
	jne	$LN3@xmlSchemaS
	cmp	DWORD PTR [edi+60], 0
	jne	$LN3@xmlSchemaS
$LN5@xmlSchemaS:

; 28643:         ((old_sax->startElement != NULL) || (old_sax->endElement != NULL)))
; 28644:         return(NULL);
; 28645: 
; 28646:     /*
; 28647:      * everything seems right allocate the local data needed for that layer
; 28648:      */
; 28649:     ret = (xmlSchemaSAXPlugPtr) xmlMalloc(sizeof(xmlSchemaSAXPlugStruct));

	push	152					; 00000098H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 28650:     if (ret == NULL) {

	test	esi, esi
	je	$LN3@xmlSchemaS

; 28651:         return(NULL);
; 28652:     }
; 28653:     memset(ret, 0, sizeof(xmlSchemaSAXPlugStruct));

	push	152					; 00000098H
	push	0
	push	esi
	call	_memset

; 28654:     ret->magic = XML_SAX_PLUG_MAGIC;
; 28655:     ret->schemas_sax.initialized = XML_SAX2_MAGIC;
; 28656:     ret->ctxt = ctxt;
; 28657:     ret->user_sax_ptr = sax;

	mov	eax, DWORD PTR _sax$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi], -599541215		; dc43ba21H
	mov	DWORD PTR [esi+128], -554844497		; deedbeafH
	mov	DWORD PTR [esi+148], ebx
	mov	DWORD PTR [esi+4], eax

; 28658:     ret->user_sax = old_sax;

	mov	DWORD PTR [esi+8], edi

; 28659:     if (old_sax == NULL) {

	test	edi, edi
	jne	SHORT $LN8@xmlSchemaS

; 28660:         /*
; 28661: 	 * go direct, no need for the split block and functions.
; 28662: 	 */
; 28663: 	ret->schemas_sax.startElementNs = xmlSchemaSAXHandleStartElementNs;
; 28664: 	ret->schemas_sax.endElementNs = xmlSchemaSAXHandleEndElementNs;
; 28665: 	/*
; 28666: 	 * Note that we use the same text-function for both, to prevent
; 28667: 	 * the parser from testing for ignorable whitespace.
; 28668: 	 */
; 28669: 	ret->schemas_sax.ignorableWhitespace = xmlSchemaSAXHandleText;
; 28670: 	ret->schemas_sax.characters = xmlSchemaSAXHandleText;
; 28671: 
; 28672: 	ret->schemas_sax.cdataBlock = xmlSchemaSAXHandleCDataSection;
; 28673: 	ret->schemas_sax.reference = xmlSchemaSAXHandleReference;
; 28674: 
; 28675: 	ret->user_data = ctxt;
; 28676: 	*user_data = ctxt;
; 28677:     } else {

	mov	edi, DWORD PTR _user_data$[ebp]
	mov	eax, ebx
	mov	DWORD PTR [esi+136], OFFSET _xmlSchemaSAXHandleStartElementNs
	mov	ecx, ebx
	mov	DWORD PTR [esi+140], OFFSET _xmlSchemaSAXHandleEndElementNs
	mov	DWORD PTR [esi+92], OFFSET _xmlSchemaSAXHandleText
	mov	DWORD PTR [esi+88], OFFSET _xmlSchemaSAXHandleText
	mov	DWORD PTR [esi+120], OFFSET _xmlSchemaSAXHandleCDataSection
	mov	DWORD PTR [esi+84], OFFSET _xmlSchemaSAXHandleReference
	jmp	$LN34@xmlSchemaS
$LN8@xmlSchemaS:

; 28678:        /*
; 28679:         * for each callback unused by Schemas initialize it to the Split
; 28680: 	* routine only if non NULL in the user block, this can speed up
; 28681: 	* things at the SAX level.
; 28682: 	*/
; 28683:         if (old_sax->internalSubset != NULL)

	cmp	DWORD PTR [edi], 0
	je	SHORT $LN10@xmlSchemaS

; 28684:             ret->schemas_sax.internalSubset = internalSubsetSplit;

	mov	DWORD PTR [esi+20], OFFSET _internalSubsetSplit
$LN10@xmlSchemaS:

; 28685:         if (old_sax->isStandalone != NULL)

	cmp	DWORD PTR [edi+4], 0
	je	SHORT $LN11@xmlSchemaS

; 28686:             ret->schemas_sax.isStandalone = isStandaloneSplit;

	mov	DWORD PTR [esi+24], OFFSET _isStandaloneSplit
$LN11@xmlSchemaS:

; 28687:         if (old_sax->hasInternalSubset != NULL)

	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN12@xmlSchemaS

; 28688:             ret->schemas_sax.hasInternalSubset = hasInternalSubsetSplit;

	mov	DWORD PTR [esi+28], OFFSET _hasInternalSubsetSplit
$LN12@xmlSchemaS:

; 28689:         if (old_sax->hasExternalSubset != NULL)

	cmp	DWORD PTR [edi+12], 0
	je	SHORT $LN13@xmlSchemaS

; 28690:             ret->schemas_sax.hasExternalSubset = hasExternalSubsetSplit;

	mov	DWORD PTR [esi+32], OFFSET _hasExternalSubsetSplit
$LN13@xmlSchemaS:

; 28691:         if (old_sax->resolveEntity != NULL)

	cmp	DWORD PTR [edi+16], 0
	je	SHORT $LN14@xmlSchemaS

; 28692:             ret->schemas_sax.resolveEntity = resolveEntitySplit;

	mov	DWORD PTR [esi+36], OFFSET _resolveEntitySplit
$LN14@xmlSchemaS:

; 28693:         if (old_sax->getEntity != NULL)

	cmp	DWORD PTR [edi+20], 0
	je	SHORT $LN15@xmlSchemaS

; 28694:             ret->schemas_sax.getEntity = getEntitySplit;

	mov	DWORD PTR [esi+40], OFFSET _getEntitySplit
$LN15@xmlSchemaS:

; 28695:         if (old_sax->entityDecl != NULL)

	cmp	DWORD PTR [edi+24], 0
	je	SHORT $LN16@xmlSchemaS

; 28696:             ret->schemas_sax.entityDecl = entityDeclSplit;

	mov	DWORD PTR [esi+44], OFFSET _entityDeclSplit
$LN16@xmlSchemaS:

; 28697:         if (old_sax->notationDecl != NULL)

	cmp	DWORD PTR [edi+28], 0
	je	SHORT $LN17@xmlSchemaS

; 28698:             ret->schemas_sax.notationDecl = notationDeclSplit;

	mov	DWORD PTR [esi+48], OFFSET _notationDeclSplit
$LN17@xmlSchemaS:

; 28699:         if (old_sax->attributeDecl != NULL)

	cmp	DWORD PTR [edi+32], 0
	je	SHORT $LN18@xmlSchemaS

; 28700:             ret->schemas_sax.attributeDecl = attributeDeclSplit;

	mov	DWORD PTR [esi+52], OFFSET _attributeDeclSplit
$LN18@xmlSchemaS:

; 28701:         if (old_sax->elementDecl != NULL)

	cmp	DWORD PTR [edi+36], 0
	je	SHORT $LN19@xmlSchemaS

; 28702:             ret->schemas_sax.elementDecl = elementDeclSplit;

	mov	DWORD PTR [esi+56], OFFSET _elementDeclSplit
$LN19@xmlSchemaS:

; 28703:         if (old_sax->unparsedEntityDecl != NULL)

	cmp	DWORD PTR [edi+40], 0
	je	SHORT $LN20@xmlSchemaS

; 28704:             ret->schemas_sax.unparsedEntityDecl = unparsedEntityDeclSplit;

	mov	DWORD PTR [esi+60], OFFSET _unparsedEntityDeclSplit
$LN20@xmlSchemaS:

; 28705:         if (old_sax->setDocumentLocator != NULL)

	cmp	DWORD PTR [edi+44], 0
	je	SHORT $LN21@xmlSchemaS

; 28706:             ret->schemas_sax.setDocumentLocator = setDocumentLocatorSplit;

	mov	DWORD PTR [esi+64], OFFSET _setDocumentLocatorSplit
$LN21@xmlSchemaS:

; 28707:         if (old_sax->startDocument != NULL)

	cmp	DWORD PTR [edi+48], 0
	je	SHORT $LN22@xmlSchemaS

; 28708:             ret->schemas_sax.startDocument = startDocumentSplit;

	mov	DWORD PTR [esi+68], OFFSET _startDocumentSplit
$LN22@xmlSchemaS:

; 28709:         if (old_sax->endDocument != NULL)

	cmp	DWORD PTR [edi+52], 0
	je	SHORT $LN23@xmlSchemaS

; 28710:             ret->schemas_sax.endDocument = endDocumentSplit;

	mov	DWORD PTR [esi+72], OFFSET _endDocumentSplit
$LN23@xmlSchemaS:

; 28711:         if (old_sax->processingInstruction != NULL)

	cmp	DWORD PTR [edi+76], 0
	je	SHORT $LN24@xmlSchemaS

; 28712:             ret->schemas_sax.processingInstruction = processingInstructionSplit;

	mov	DWORD PTR [esi+96], OFFSET _processingInstructionSplit
$LN24@xmlSchemaS:

; 28713:         if (old_sax->comment != NULL)

	cmp	DWORD PTR [edi+80], 0
	je	SHORT $LN25@xmlSchemaS

; 28714:             ret->schemas_sax.comment = commentSplit;

	mov	DWORD PTR [esi+100], OFFSET _commentSplit
$LN25@xmlSchemaS:

; 28715:         if (old_sax->warning != NULL)

	cmp	DWORD PTR [edi+84], 0
	je	SHORT $LN26@xmlSchemaS

; 28716:             ret->schemas_sax.warning = warningSplit;

	mov	DWORD PTR [esi+104], OFFSET _warningSplit
$LN26@xmlSchemaS:

; 28717:         if (old_sax->error != NULL)

	cmp	DWORD PTR [edi+88], 0
	je	SHORT $LN27@xmlSchemaS

; 28718:             ret->schemas_sax.error = errorSplit;

	mov	DWORD PTR [esi+108], OFFSET _errorSplit
$LN27@xmlSchemaS:

; 28719:         if (old_sax->fatalError != NULL)

	cmp	DWORD PTR [edi+92], 0
	je	SHORT $LN28@xmlSchemaS

; 28720:             ret->schemas_sax.fatalError = fatalErrorSplit;

	mov	DWORD PTR [esi+112], OFFSET _fatalErrorSplit
$LN28@xmlSchemaS:

; 28721:         if (old_sax->getParameterEntity != NULL)

	cmp	DWORD PTR [edi+96], 0
	je	SHORT $LN29@xmlSchemaS

; 28722:             ret->schemas_sax.getParameterEntity = getParameterEntitySplit;

	mov	DWORD PTR [esi+116], OFFSET _getParameterEntitySplit
$LN29@xmlSchemaS:

; 28723:         if (old_sax->externalSubset != NULL)

	cmp	DWORD PTR [edi+104], 0
	je	SHORT $LN30@xmlSchemaS

; 28724:             ret->schemas_sax.externalSubset = externalSubsetSplit;

	mov	DWORD PTR [esi+124], OFFSET _externalSubsetSplit
$LN30@xmlSchemaS:

; 28725: 
; 28726: 	/*
; 28727: 	 * the 6 schemas callback have to go to the splitter functions
; 28728: 	 * Note that we use the same text-function for ignorableWhitespace
; 28729: 	 * if possible, to prevent the parser from testing for ignorable
; 28730: 	 * whitespace.
; 28731: 	 */
; 28732:         ret->schemas_sax.characters = charactersSplit;

	mov	DWORD PTR [esi+88], OFFSET _charactersSplit

; 28733: 	if ((old_sax->ignorableWhitespace != NULL) &&

	mov	eax, DWORD PTR [edi+72]
	test	eax, eax
	je	SHORT $LN31@xmlSchemaS
	cmp	eax, DWORD PTR [edi+68]

; 28734: 	    (old_sax->ignorableWhitespace != old_sax->characters))
; 28735: 	    ret->schemas_sax.ignorableWhitespace = ignorableWhitespaceSplit;

	mov	eax, OFFSET _ignorableWhitespaceSplit
	jne	SHORT $LN32@xmlSchemaS
$LN31@xmlSchemaS:

; 28736: 	else
; 28737: 	    ret->schemas_sax.ignorableWhitespace = charactersSplit;

	mov	eax, OFFSET _charactersSplit
$LN32@xmlSchemaS:

; 28738:         ret->schemas_sax.cdataBlock = cdataBlockSplit;
; 28739:         ret->schemas_sax.reference = referenceSplit;
; 28740:         ret->schemas_sax.startElementNs = startElementNsSplit;
; 28741:         ret->schemas_sax.endElementNs = endElementNsSplit;
; 28742: 
; 28743: 	ret->user_data_ptr = user_data;

	mov	edi, DWORD PTR _user_data$[ebp]
	mov	DWORD PTR [esi+92], eax

; 28744: 	ret->user_data = *user_data;
; 28745: 	*user_data = ret;

	mov	eax, esi
	mov	DWORD PTR [esi+120], OFFSET _cdataBlockSplit
	mov	DWORD PTR [esi+84], OFFSET _referenceSplit
	mov	DWORD PTR [esi+136], OFFSET _startElementNsSplit
	mov	DWORD PTR [esi+140], OFFSET _endElementNsSplit
	mov	DWORD PTR [esi+12], edi
	mov	ecx, DWORD PTR [edi]
$LN34@xmlSchemaS:

; 28746:     }
; 28747: 
; 28748:     /*
; 28749:      * plug the pointers back.
; 28750:      */
; 28751:     *sax = &(ret->schemas_sax);

	mov	edx, esi

; 28752:     ctxt->sax = *sax;
; 28753:     ctxt->flags |= XML_SCHEMA_VALID_CTXT_FLAG_STREAM;
; 28754:     xmlSchemaPreRun(ctxt);

	push	ebx
	mov	DWORD PTR [edx+16], ecx
	lea	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR _sax$[ebp]
	mov	DWORD PTR [eax], ecx
	or	DWORD PTR [ebx+152], 1
	mov	DWORD PTR [ebx+36], ecx
	call	_xmlSchemaPreRun
	add	esp, 4

; 28755:     return(ret);

	mov	eax, esi
	pop	edi

; 28756: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemaS:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaSAXPlug ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidCtxtGetParserCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSchemaValidCtxtGetParserCtxt PROC			; COMDAT

; 28980: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaV

; 28984: }

	pop	ebp
	ret	0
$LN2@xmlSchemaV:

; 28981:     if (ctxt == NULL)
; 28982:         return(NULL);
; 28983:     return (ctxt->parserCtxt);

	mov	eax, DWORD PTR [eax+40]

; 28984: }

	pop	ebp
	ret	0
_xmlSchemaValidCtxtGetParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidateFile
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_filename$ = 12						; size = 4
_options$ = 16						; size = 4
_xmlSchemaValidateFile PROC				; COMDAT

; 28953: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlSchemaV

; 28954:     int ret;
; 28955:     xmlParserInputBufferPtr input;
; 28956: 
; 28957:     if ((ctxt == NULL) || (filename == NULL))

	mov	eax, DWORD PTR _filename$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaV

; 28959: 
; 28960:     input = xmlParserInputBufferCreateFilename(filename,

	push	0
	push	eax
	call	_xmlParserInputBufferCreateFilename
	add	esp, 8

; 28961: 	XML_CHAR_ENCODING_NONE);
; 28962:     if (input == NULL)

	test	eax, eax
	je	SHORT $LN3@xmlSchemaV

; 28963: 	return (-1);
; 28964:     ret = xmlSchemaValidateStream(ctxt, input, XML_CHAR_ENCODING_NONE,

	push	0
	push	0
	push	0
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchemaValidateStream
	add	esp, 20					; 00000014H

; 28965: 	NULL, NULL);
; 28966:     return (ret);
; 28967: }

	pop	ebp
	ret	0
$LN3@xmlSchemaV:

; 28958:         return (-1);

	or	eax, -1

; 28965: 	NULL, NULL);
; 28966:     return (ret);
; 28967: }

	pop	ebp
	ret	0
_xmlSchemaValidateFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidateStream
_TEXT	SEGMENT
_plug$1$ = -4						; size = 4
_old_sax$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_input$ = 12						; size = 4
_enc$ = 16						; size = 4
_sax$ = 20						; size = 4
_user_data$ = 24					; size = 4
_xmlSchemaValidateStream PROC				; COMDAT

; 28867: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _plug$1$[ebp], 0
	test	esi, esi
	je	$LN3@xmlSchemaV

; 28868:     xmlSchemaSAXPlugPtr plug = NULL;
; 28869:     xmlSAXHandlerPtr old_sax = NULL;
; 28870:     xmlParserCtxtPtr pctxt = NULL;
; 28871:     xmlParserInputPtr inputStream = NULL;
; 28872:     int ret;
; 28873: 
; 28874:     if ((ctxt == NULL) || (input == NULL))

	mov	ebx, DWORD PTR _input$[ebp]
	test	ebx, ebx
	je	$LN3@xmlSchemaV

; 28875:         return (-1);
; 28876: 
; 28877:     /*
; 28878:      * prepare the parser
; 28879:      */
; 28880:     pctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	edi, eax

; 28881:     if (pctxt == NULL)

	test	edi, edi
	je	$LN3@xmlSchemaV

; 28882:         return (-1);
; 28883:     old_sax = pctxt->sax;

	mov	eax, DWORD PTR [edi]

; 28884:     pctxt->sax = sax;
; 28885:     pctxt->userData = user_data;
; 28886: #if 0
; 28887:     if (options)
; 28888:         xmlCtxtUseOptions(pctxt, options);
; 28889: #endif
; 28890:     pctxt->linenumbers = 1;
; 28891:     xmlSchemaValidateSetLocator(ctxt, xmlSchemaValidateStreamLocator, pctxt);
; 28892: 
; 28893:     inputStream = xmlNewIOInputStream(pctxt, input, enc);;

	push	DWORD PTR _enc$[ebp]
	mov	DWORD PTR _old_sax$1$[ebp], eax
	mov	eax, DWORD PTR _sax$[ebp]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR _user_data$[ebp]
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+280], 1
	push	ebx
	push	edi

; 28809:     vctxt->locFunc = f;

	mov	DWORD PTR [esi+196], OFFSET _xmlSchemaValidateStreamLocator

; 28810:     vctxt->locCtxt = ctxt;

	mov	DWORD PTR [esi+200], edi

; 28884:     pctxt->sax = sax;
; 28885:     pctxt->userData = user_data;
; 28886: #if 0
; 28887:     if (options)
; 28888:         xmlCtxtUseOptions(pctxt, options);
; 28889: #endif
; 28890:     pctxt->linenumbers = 1;
; 28891:     xmlSchemaValidateSetLocator(ctxt, xmlSchemaValidateStreamLocator, pctxt);
; 28892: 
; 28893:     inputStream = xmlNewIOInputStream(pctxt, input, enc);;

	call	_xmlNewIOInputStream
	add	esp, 12					; 0000000cH

; 28894:     if (inputStream == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlSchemaV

; 28895:         ret = -1;

	or	ebx, -1

; 28896: 	goto done;

	jmp	SHORT $done$16
$LN5@xmlSchemaV:

; 28897:     }
; 28898:     inputPush(pctxt, inputStream);

	push	eax
	push	edi
	call	_inputPush

; 28899:     ctxt->parserCtxt = pctxt;
; 28900:     ctxt->input = input;
; 28901: 
; 28902:     /*
; 28903:      * Plug the validation and launch the parsing
; 28904:      */
; 28905:     plug = xmlSchemaSAXPlug(ctxt, &(pctxt->sax), &(pctxt->userData));

	lea	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+40], edi
	push	eax
	push	edi
	push	esi
	mov	DWORD PTR [esi+28], ebx
	call	_xmlSchemaSAXPlug
	add	esp, 20					; 00000014H
	mov	DWORD PTR _plug$1$[ebp], eax

; 28906:     if (plug == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlSchemaV

; 28907:         ret = -1;

	or	ebx, -1

; 28908: 	goto done;

	jmp	SHORT $done$16
$LN6@xmlSchemaV:

; 28909:     }
; 28910:     ctxt->input = input;
; 28911:     ctxt->enc = enc;

	mov	eax, DWORD PTR _enc$[ebp]
	mov	DWORD PTR [esi+28], ebx
	mov	DWORD PTR [esi+32], eax

; 28912:     ctxt->sax = pctxt->sax;

	mov	eax, DWORD PTR [edi]

; 28913:     ctxt->flags |= XML_SCHEMA_VALID_CTXT_FLAG_STREAM;

	or	DWORD PTR [esi+152], 1

; 28914:     ret = xmlSchemaVStart(ctxt);

	push	esi
	mov	DWORD PTR [esi+36], eax
	call	_xmlSchemaVStart
	mov	ebx, eax
	add	esp, 4

; 28915: 
; 28916:     if ((ret == 0) && (! ctxt->parserCtxt->wellFormed)) {

	test	ebx, ebx
	jne	SHORT $done$16
	mov	eax, DWORD PTR [esi+40]
	cmp	DWORD PTR [eax+12], ebx
	jne	SHORT $done$16

; 28917: 	ret = ctxt->parserCtxt->errNo;

	mov	ebx, DWORD PTR [eax+84]

; 28918: 	if (ret == 0)

	test	ebx, ebx
	mov	eax, 1
	cmove	ebx, eax
$done$16:

; 28919: 	    ret = 1;
; 28920:     }
; 28921: 
; 28922: done:
; 28923:     ctxt->parserCtxt = NULL;

	mov	DWORD PTR [esi+40], 0

; 28924:     ctxt->sax = NULL;

	mov	DWORD PTR [esi+36], 0

; 28925:     ctxt->input = NULL;

	mov	DWORD PTR [esi+28], 0

; 28926:     if (plug != NULL) {

	mov	esi, DWORD PTR _plug$1$[ebp]
	test	esi, esi
	je	SHORT $LN9@xmlSchemaV

; 28927:         xmlSchemaSAXUnplug(plug);

	push	esi
	call	_xmlSchemaSAXUnplug
	add	esp, 4
$LN9@xmlSchemaV:

; 28928:     }
; 28929:     /* cleanup */
; 28930:     if (pctxt != NULL) {
; 28931: 	pctxt->sax = old_sax;

	mov	eax, DWORD PTR _old_sax$1$[ebp]

; 28932: 	xmlFreeParserCtxt(pctxt);

	push	edi
	mov	DWORD PTR [edi], eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 28933:     }
; 28934:     return (ret);

	mov	eax, ebx
	pop	edi

; 28935: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlSchemaV:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaValidateStream ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidateOneElement
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_elem$ = 12						; size = 4
_xmlSchemaValidateOneElement PROC			; COMDAT

; 28229: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlSchemaV

; 28230:     if ((ctxt == NULL) || (elem == NULL) || (elem->type != XML_ELEMENT_NODE))

	mov	edx, DWORD PTR _elem$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlSchemaV
	cmp	DWORD PTR [edx+4], 1
	jne	SHORT $LN3@xmlSchemaV

; 28232: 
; 28233:     if (ctxt->schema == NULL)

	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN3@xmlSchemaV

; 28234: 	return (-1);
; 28235: 
; 28236:     ctxt->doc = elem->doc;

	mov	eax, DWORD PTR [edx+32]

; 28237:     ctxt->node = elem;
; 28238:     ctxt->validationRoot = elem;
; 28239:     return(xmlSchemaVStart(ctxt));

	push	ecx
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+60], edx
	mov	DWORD PTR [ecx+84], edx
	call	_xmlSchemaVStart
	add	esp, 4

; 28240: }

	pop	ebp
	ret	0
$LN3@xmlSchemaV:

; 28231: 	return (-1);

	or	eax, -1

; 28240: }

	pop	ebp
	ret	0
_xmlSchemaValidateOneElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidateDoc
_TEXT	SEGMENT
_msg$1 = 8						; size = 4
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlSchemaValidateDoc PROC				; COMDAT

; 28254: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN3@xmlSchemaV

; 28255:     if ((ctxt == NULL) || (doc == NULL))

	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	je	$LN3@xmlSchemaV

; 28257: 
; 28258:     ctxt->doc = doc;
; 28259:     ctxt->node = xmlDocGetRootElement(doc);

	push	edi
	mov	DWORD PTR [esi+24], edi
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR [esi+60], eax

; 28260:     if (ctxt->node == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlSchemaV

; 2347 : 	xmlSchemaFormatNodeForError(&msg, actxt, node);

	push	edi
	mov	DWORD PTR _msg$1[ebp], eax
	lea	eax, DWORD PTR _msg$1[ebp]
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0CF@IJEICDHG@The?5document?5has?5no?5document?5el@
	push	DWORD PTR _msg$1[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	edi
	push	1872					; 00000750H
	push	2
	push	esi

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	mov	DWORD PTR _msg$1[ebp], eax

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	call	_xmlSchemaErr4Line

; 2352 :     FREE_AND_NULL(msg)

	mov	eax, DWORD PTR _msg$1[ebp]

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	add	esp, 68					; 00000044H

; 2352 :     FREE_AND_NULL(msg)

	test	eax, eax
	je	SHORT $LN11@xmlSchemaV
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlSchemaV:

; 28261:         xmlSchemaCustomErr(ACTXT_CAST ctxt,
; 28262: 	    XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING,
; 28263: 	    (xmlNodePtr) doc, NULL,
; 28264: 	    "The document has no document element", NULL, NULL);
; 28265:         return (ctxt->err);

	mov	eax, DWORD PTR [esi+52]
	pop	edi

; 28269: }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlSchemaV:

; 28266:     }
; 28267:     ctxt->validationRoot = ctxt->node;
; 28268:     return (xmlSchemaVStart(ctxt));

	push	esi
	mov	DWORD PTR [esi+84], eax
	call	_xmlSchemaVStart
	add	esp, 4
	pop	edi

; 28269: }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlSchemaV:
	pop	edi

; 28256:         return (-1);

	or	eax, -1

; 28269: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaValidateDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeValidCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSchemaFreeValidCtxt PROC				; COMDAT

; 27717: {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN1@xmlSchemaF

; 27718:     if (ctxt == NULL)
; 27719:         return;
; 27720:     if (ctxt->value != NULL)

	mov	eax, DWORD PTR [edi+72]
	test	eax, eax
	je	SHORT $LN18@xmlSchemaF

; 27721:         xmlSchemaFreeValue(ctxt->value);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN18@xmlSchemaF:

; 27722:     if (ctxt->pctxt != NULL)

	mov	eax, DWORD PTR [edi+88]
	test	eax, eax
	je	SHORT $LN19@xmlSchemaF

; 27723: 	xmlSchemaFreeParserCtxt(ctxt->pctxt);

	push	eax
	call	_xmlSchemaFreeParserCtxt
	add	esp, 4
$LN19@xmlSchemaF:

; 27724:     if (ctxt->idcNodes != NULL) {

	mov	eax, DWORD PTR [edi+128]
	push	ebx
	push	esi
	test	eax, eax
	je	SHORT $LN20@xmlSchemaF

; 27725: 	int i;
; 27726: 	xmlSchemaPSVIIDCNodePtr item;
; 27727: 
; 27728: 	for (i = 0; i < ctxt->nbIdcNodes; i++) {

	xor	ebx, ebx
	cmp	DWORD PTR [edi+132], ebx
	jle	SHORT $LN3@xmlSchemaF
	npad	1
$LL4@xmlSchemaF:

; 27729: 	    item = ctxt->idcNodes[i];

	mov	eax, DWORD PTR [edi+128]
	mov	esi, DWORD PTR [eax+ebx*4]

; 27730: 	    xmlFree(item->keys);

	push	DWORD PTR [esi+4]
	call	DWORD PTR _xmlFree

; 27731: 	    xmlFree(item);

	push	esi
	call	DWORD PTR _xmlFree
	inc	ebx
	add	esp, 8
	cmp	ebx, DWORD PTR [edi+132]
	jl	SHORT $LL4@xmlSchemaF
	mov	eax, DWORD PTR [edi+128]
$LN3@xmlSchemaF:

; 27732: 	}
; 27733: 	xmlFree(ctxt->idcNodes);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN20@xmlSchemaF:

; 27734:     }
; 27735:     if (ctxt->idcKeys != NULL) {

	cmp	DWORD PTR [edi+140], 0
	je	SHORT $LN21@xmlSchemaF

; 27736: 	int i;
; 27737: 	for (i = 0; i < ctxt->nbIdcKeys; i++)

	xor	esi, esi
	cmp	DWORD PTR [edi+144], esi
	jle	SHORT $LN6@xmlSchemaF
	npad	8
$LL7@xmlSchemaF:

; 27738: 	    xmlSchemaIDCFreeKey(ctxt->idcKeys[i]);

	mov	eax, DWORD PTR [edi+140]
	mov	ebx, DWORD PTR [eax+esi*4]

; 22275:     if (key->val != NULL)

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN64@xmlSchemaF

; 22276: 	xmlSchemaFreeValue(key->val);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN64@xmlSchemaF:

; 22277:     xmlFree(key);

	push	ebx
	call	DWORD PTR _xmlFree

; 27736: 	int i;
; 27737: 	for (i = 0; i < ctxt->nbIdcKeys; i++)

	inc	esi

; 22277:     xmlFree(key);

	add	esp, 4

; 27736: 	int i;
; 27737: 	for (i = 0; i < ctxt->nbIdcKeys; i++)

	cmp	esi, DWORD PTR [edi+144]
	jl	SHORT $LL7@xmlSchemaF
$LN6@xmlSchemaF:

; 27739: 	xmlFree(ctxt->idcKeys);

	push	DWORD PTR [edi+140]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN21@xmlSchemaF:

; 27740:     }
; 27741: 
; 27742:     if (ctxt->xpathStates != NULL) {

	mov	eax, DWORD PTR [edi+116]
	test	eax, eax
	je	SHORT $LN22@xmlSchemaF

; 27743: 	xmlSchemaFreeIDCStateObjList(ctxt->xpathStates);

	push	eax
	call	_xmlSchemaFreeIDCStateObjList
	add	esp, 4

; 27744: 	ctxt->xpathStates = NULL;

	mov	DWORD PTR [edi+116], 0
$LN22@xmlSchemaF:

; 27745:     }
; 27746:     if (ctxt->xpathStatePool != NULL) {

	mov	eax, DWORD PTR [edi+120]
	test	eax, eax
	je	SHORT $LN23@xmlSchemaF

; 27747: 	xmlSchemaFreeIDCStateObjList(ctxt->xpathStatePool);

	push	eax
	call	_xmlSchemaFreeIDCStateObjList
	add	esp, 4

; 27748: 	ctxt->xpathStatePool = NULL;

	mov	DWORD PTR [edi+120], 0
$LN23@xmlSchemaF:

; 27749:     }
; 27750: 
; 27751:     /*
; 27752:     * Augmented IDC information.
; 27753:     */
; 27754:     if (ctxt->aidcs != NULL) {

	mov	eax, DWORD PTR [edi+112]
	test	eax, eax
	je	SHORT $LN9@xmlSchemaF
$LL10@xmlSchemaF:

; 27755: 	xmlSchemaIDCAugPtr cur = ctxt->aidcs, next;
; 27756: 	do {
; 27757: 	    next = cur->next;

	mov	esi, DWORD PTR [eax]

; 27758: 	    xmlFree(cur);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 27759: 	    cur = next;

	mov	eax, esi

; 27760: 	} while (cur != NULL);

	test	esi, esi
	jne	SHORT $LL10@xmlSchemaF
$LN9@xmlSchemaF:

; 27761:     }
; 27762:     if (ctxt->attrInfos != NULL) {

	mov	eax, DWORD PTR [edi+164]
	test	eax, eax
	je	SHORT $LN25@xmlSchemaF

; 27763: 	int i;
; 27764: 	xmlSchemaAttrInfoPtr attr;
; 27765: 
; 27766: 	/* Just a paranoid call to the cleanup. */
; 27767: 	if (ctxt->nbAttrInfos != 0)

	cmp	DWORD PTR [edi+168], 0
	je	SHORT $LN26@xmlSchemaF

; 27768: 	    xmlSchemaClearAttrInfos(ctxt);

	push	edi
	call	_xmlSchemaClearAttrInfos
	mov	eax, DWORD PTR [edi+164]
	add	esp, 4
$LN26@xmlSchemaF:

; 27769: 	for (i = 0; i < ctxt->sizeAttrInfos; i++) {

	xor	esi, esi
	cmp	DWORD PTR [edi+172], esi
	jle	SHORT $LN12@xmlSchemaF
	npad	2
$LL13@xmlSchemaF:

; 27770: 	    attr = ctxt->attrInfos[i];
; 27771: 	    xmlFree(attr);

	mov	eax, DWORD PTR [edi+164]
	push	DWORD PTR [eax+esi*4]
	call	DWORD PTR _xmlFree
	inc	esi
	add	esp, 4
	cmp	esi, DWORD PTR [edi+172]
	jl	SHORT $LL13@xmlSchemaF
	mov	eax, DWORD PTR [edi+164]
$LN12@xmlSchemaF:

; 27772: 	}
; 27773: 	xmlFree(ctxt->attrInfos);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN25@xmlSchemaF:

; 27774:     }
; 27775:     if (ctxt->elemInfos != NULL) {

	cmp	DWORD PTR [edi+100], 0
	je	SHORT $LN27@xmlSchemaF

; 27776: 	int i;
; 27777: 	xmlSchemaNodeInfoPtr ei;
; 27778: 
; 27779: 	for (i = 0; i < ctxt->sizeElemInfos; i++) {

	xor	esi, esi
	cmp	DWORD PTR [edi+104], esi
	jle	SHORT $LN90@xmlSchemaF
$LL16@xmlSchemaF:

; 27780: 	    ei = ctxt->elemInfos[i];

	mov	eax, DWORD PTR [edi+100]
	mov	ebx, DWORD PTR [eax+esi*4]

; 27781: 	    if (ei == NULL)

	test	ebx, ebx
	je	SHORT $LN90@xmlSchemaF

; 27782: 		break;
; 27783: 	    xmlSchemaClearElemInfo(ctxt, ei);

	push	ebx
	push	edi
	call	_xmlSchemaClearElemInfo

; 27784: 	    xmlFree(ei);

	push	ebx
	call	DWORD PTR _xmlFree
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, DWORD PTR [edi+104]
	jl	SHORT $LL16@xmlSchemaF
$LN90@xmlSchemaF:

; 27785: 	}
; 27786: 	xmlFree(ctxt->elemInfos);

	push	DWORD PTR [edi+100]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN27@xmlSchemaF:

; 27787:     }
; 27788:     if (ctxt->nodeQNames != NULL)

	mov	esi, DWORD PTR [edi+180]
	test	esi, esi
	je	SHORT $LN66@xmlSchemaF

; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN68@xmlSchemaF

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN68@xmlSchemaF:

; 3534 :     xmlFree(list);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN66@xmlSchemaF:

; 27789: 	xmlSchemaItemListFree(ctxt->nodeQNames);
; 27790:     if (ctxt->dict != NULL)

	mov	eax, DWORD PTR [edi+156]
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN30@xmlSchemaF

; 27791: 	xmlDictFree(ctxt->dict);

	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN30@xmlSchemaF:

; 27792:     if (ctxt->filename != NULL)

	mov	eax, DWORD PTR [edi+48]
	test	eax, eax
	je	SHORT $LN31@xmlSchemaF

; 27793: 	xmlFree(ctxt->filename);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN31@xmlSchemaF:

; 27794:     xmlFree(ctxt);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlSchemaF:
	pop	edi

; 27795: }

	pop	ebp
	ret	0
_xmlSchemaFreeValidCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaNewValidCtxt
_TEXT	SEGMENT
_schema$ = 8						; size = 4
_xmlSchemaNewValidCtxt PROC				; COMDAT

; 27552: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	push	204					; 000000ccH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlSchemaN

; 2010 :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BO@JGCBGKGF@allocating?5validation?5context@
	push	eax
	push	eax
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 27553:     xmlSchemaValidCtxtPtr ret;
; 27554: 
; 27555:     ret = (xmlSchemaValidCtxtPtr) xmlMalloc(sizeof(xmlSchemaValidCtxt));
; 27556:     if (ret == NULL) {
; 27557:         xmlSchemaVErrMemory(NULL, "allocating validation context", NULL);
; 27558:         return (NULL);

	xor	eax, eax
	pop	esi

; 27566: }

	pop	ebp
	ret	0
$LN2@xmlSchemaN:

; 27559:     }
; 27560:     memset(ret, 0, sizeof(xmlSchemaValidCtxt));

	push	200					; 000000c8H
	lea	eax, DWORD PTR [esi+4]
	push	0
	push	eax
	call	_memset

; 27561:     ret->type = XML_SCHEMA_CTXT_VALIDATOR;

	mov	DWORD PTR [esi], 2

; 27562:     ret->dict = xmlDictCreate();

	call	_xmlDictCreate

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	push	12					; 0000000cH

; 27562:     ret->dict = xmlDictCreate();

	mov	DWORD PTR [esi+156], eax

; 3341 :     ret = xmlMalloc(sizeof(xmlSchemaItemList));

	call	DWORD PTR _xmlMalloc
	add	esp, 16					; 00000010H

; 3342 :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN8@xmlSchemaN

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CC@BAFOADOL@allocating?5an?5item?5list?5structu@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError

; 27564:     ret->schema = schema;

	mov	ecx, DWORD PTR _schema$[ebp]

; 1886 :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	add	esp, 20					; 00000014H

; 3345 : 	return (NULL);

	xor	eax, eax

; 27564:     ret->schema = schema;

	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+180], eax

; 27565:     return (ret);

	mov	eax, esi
	pop	esi

; 27566: }

	pop	ebp
	ret	0
$LN8@xmlSchemaN:

; 27564:     ret->schema = schema;

	mov	ecx, DWORD PTR _schema$[ebp]
	xorps	xmm0, xmm0

; 3347 :     memset(ret, 0, sizeof(xmlSchemaItemList));

	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], 0

; 27563:     ret->nodeQNames = xmlSchemaItemListCreate();

	mov	DWORD PTR [esi+180], eax

; 27565:     return (ret);

	mov	eax, esi
	mov	DWORD PTR [esi+20], ecx
	pop	esi

; 27566: }

	pop	ebp
	ret	0
_xmlSchemaNewValidCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidCtxtGetOptions
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSchemaValidCtxtGetOptions PROC			; COMDAT

; 27931: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaV

; 27932:     if (ctxt == NULL)
; 27933: 	return (-1);

	or	eax, -1

; 27936: }

	pop	ebp
	ret	0
$LN2@xmlSchemaV:

; 27934:     else
; 27935: 	return (ctxt->options);

	mov	eax, DWORD PTR [eax+80]

; 27936: }

	pop	ebp
	ret	0
_xmlSchemaValidCtxtGetOptions ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaValidateSetFilename
_TEXT	SEGMENT
_vctxt$ = 8						; size = 4
_filename$ = 12						; size = 4
_xmlSchemaValidateSetFilename PROC			; COMDAT

; 27577: xmlSchemaValidateSetFilename(xmlSchemaValidCtxtPtr vctxt, const char *filename) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _vctxt$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlSchemaV

; 27578:     if (vctxt == NULL)
; 27579:         return;
; 27580:     if (vctxt->filename != NULL)

	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaV

; 27581:         xmlFree(vctxt->filename);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlSchemaV:

; 27582:     if (filename != NULL)

	mov	eax, DWORD PTR _filename$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaV

; 27583:         vctxt->filename = (char *) xmlStrdup((const xmlChar *) filename);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+48], eax
	pop	esi

; 27586: }

	pop	ebp
	ret	0
$LN4@xmlSchemaV:

; 27584:     else
; 27585:         vctxt->filename = NULL;

	mov	DWORD PTR [esi+48], 0
$LN5@xmlSchemaV:
	pop	esi

; 27586: }

	pop	ebp
	ret	0
_xmlSchemaValidateSetFilename ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSetValidOptions
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_options$ = 12						; size = 4
_xmlSchemaSetValidOptions PROC				; COMDAT

; 27901: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN9@xmlSchemaS

; 27902:     int i;
; 27903: 
; 27904:     if (ctxt == NULL)
; 27905: 	return (-1);
; 27906:     /*
; 27907:     * WARNING: Change the start value if adding to the
; 27908:     * xmlSchemaValidOption.
; 27909:     * TODO: Is there an other, more easy to maintain,
; 27910:     * way?
; 27911:     */
; 27912:     for (i = 1; i < (int) sizeof(int) * 8; i++) {

	mov	edx, DWORD PTR _options$[ebp]
	mov	ecx, 1
	npad	3
$LL4@xmlSchemaS:

; 27913:         if (options & 1<<i)

	mov	eax, 1
	shl	eax, cl
	test	eax, edx
	jne	SHORT $LN9@xmlSchemaS

; 27902:     int i;
; 27903: 
; 27904:     if (ctxt == NULL)
; 27905: 	return (-1);
; 27906:     /*
; 27907:     * WARNING: Change the start value if adding to the
; 27908:     * xmlSchemaValidOption.
; 27909:     * TODO: Is there an other, more easy to maintain,
; 27910:     * way?
; 27911:     */
; 27912:     for (i = 1; i < (int) sizeof(int) * 8; i++) {

	inc	ecx
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LL4@xmlSchemaS

; 27915:     }
; 27916:     ctxt->options = options;

	mov	DWORD PTR [esi+80], edx

; 27917:     return (0);

	xor	eax, eax
	pop	esi

; 27918: }

	pop	ebp
	ret	0
$LN9@xmlSchemaS:

; 27914: 	    return (-1);

	or	eax, -1
	pop	esi

; 27918: }

	pop	ebp
	ret	0
_xmlSchemaSetValidOptions ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetValidErrors
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_err$ = 12						; size = 4
_warn$ = 16						; size = 4
_ctx$ = 20						; size = 4
_xmlSchemaGetValidErrors PROC				; COMDAT

; 27874: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@xmlSchemaG

; 27875: 	if (ctxt == NULL)
; 27876: 		return (-1);

	or	eax, -1

; 27884: }

	pop	ebp
	ret	0
$LN2@xmlSchemaG:

; 27877: 	if (err != NULL)

	mov	edx, DWORD PTR _err$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlSchemaG

; 27878: 		*err = ctxt->error;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax
$LN3@xmlSchemaG:

; 27879: 	if (warn != NULL)

	mov	edx, DWORD PTR _warn$[ebp]
	test	edx, edx
	je	SHORT $LN4@xmlSchemaG

; 27880: 		*warn = ctxt->warning;

	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx], eax
$LN4@xmlSchemaG:

; 27881: 	if (ctx != NULL)

	mov	edx, DWORD PTR _ctx$[ebp]
	test	edx, edx
	je	SHORT $LN5@xmlSchemaG

; 27882: 		*ctx = ctxt->errCtxt;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN5@xmlSchemaG:

; 27883: 	return (0);

	xor	eax, eax

; 27884: }

	pop	ebp
	ret	0
_xmlSchemaGetValidErrors ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSetValidStructuredErrors
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_serror$ = 12						; size = 4
_ctx$ = 16						; size = 4
_xmlSchemaSetValidStructuredErrors PROC			; COMDAT

; 27848: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN16@xmlSchemaS
	push	ebx
	mov	ebx, DWORD PTR _serror$[ebp]
	push	edi
	mov	edi, DWORD PTR _ctx$[ebp]
	npad	3
$LL9@xmlSchemaS:

; 27849:     if (ctxt == NULL)
; 27850:         return;
; 27851:     ctxt->serror = serror;

	mov	DWORD PTR [esi+16], ebx

; 27852:     ctxt->error = NULL;

	mov	DWORD PTR [esi+8], 0

; 27853:     ctxt->warning = NULL;

	mov	DWORD PTR [esi+12], 0

; 27854:     ctxt->errCtxt = ctx;

	mov	DWORD PTR [esi+4], edi

; 27855:     if (ctxt->pctxt != NULL)

	mov	esi, DWORD PTR [esi+88]
	test	esi, esi
	je	SHORT $LN17@xmlSchemaS

; 21484:     ctxt->serror = serror;

	mov	DWORD PTR [esi+24], ebx

; 21485:     ctxt->errCtxt = ctx;

	mov	DWORD PTR [esi+4], edi

; 21486:     if (ctxt->vctxt != NULL)

	mov	esi, DWORD PTR [esi+92]
	test	esi, esi
	je	SHORT $LN17@xmlSchemaS
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	test	esi, esi
	jne	SHORT $LL9@xmlSchemaS
$LN17@xmlSchemaS:
	pop	edi
	pop	ebx
$LN16@xmlSchemaS:
	pop	esi

; 27856: 	xmlSchemaSetParserStructuredErrors(ctxt->pctxt, serror, ctx);
; 27857: }

	pop	ebp
	ret	0
_xmlSchemaSetValidStructuredErrors ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSetValidErrors
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_err$ = 12						; size = 4
_warn$ = 16						; size = 4
_ctx$ = 20						; size = 4
_xmlSchemaSetValidErrors PROC				; COMDAT

; 27827: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN16@xmlSchemaS
	push	ebx
	mov	ebx, DWORD PTR _warn$[ebp]
	push	edi
	mov	edi, DWORD PTR _ctx$[ebp]
	npad	3
$LL9@xmlSchemaS:

; 27828:     if (ctxt == NULL)
; 27829:         return;
; 27830:     ctxt->error = err;

	mov	eax, DWORD PTR _err$[ebp]
	mov	DWORD PTR [esi+8], eax

; 27831:     ctxt->warning = warn;

	mov	DWORD PTR [esi+12], ebx

; 27832:     ctxt->errCtxt = ctx;

	mov	DWORD PTR [esi+4], edi

; 27833:     if (ctxt->pctxt != NULL)

	mov	esi, DWORD PTR [esi+88]
	test	esi, esi
	je	SHORT $LN17@xmlSchemaS

; 21462:     ctxt->error = err;

	mov	DWORD PTR [esi+8], eax

; 21463:     ctxt->warning = warn;

	mov	DWORD PTR [esi+12], ebx

; 21464:     ctxt->errCtxt = ctx;

	mov	DWORD PTR [esi+4], edi

; 21465:     if (ctxt->vctxt != NULL)

	mov	esi, DWORD PTR [esi+92]
	test	esi, esi
	je	SHORT $LN17@xmlSchemaS
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	test	esi, esi
	jne	SHORT $LL9@xmlSchemaS
$LN17@xmlSchemaS:
	pop	edi
	pop	ebx
$LN16@xmlSchemaS:
	pop	esi

; 27834: 	xmlSchemaSetParserErrors(ctxt->pctxt, err, warn, ctx);
; 27835: }

	pop	ebp
	ret	0
_xmlSchemaSetValidErrors ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaDump
_TEXT	SEGMENT
_output$ = 8						; size = 4
_schema$ = 12						; size = 4
_xmlSchemaDump PROC					; COMDAT

; 4541 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	test	esi, esi
	je	$LN1@xmlSchemaD

; 4542 :     if (output == NULL)
; 4543 :         return;
; 4544 :     if (schema == NULL) {

	push	edi
	mov	edi, DWORD PTR _schema$[ebp]
	test	edi, edi
	jne	SHORT $LN3@xmlSchemaD

; 4545 :         fprintf(output, "Schemas: NULL\n");

	push	OFFSET ??_C@_0P@IDICKHMO@Schemas?3?5NULL?6@
	push	esi
	call	_fprintf
	add	esp, 8
	pop	edi
	pop	esi

; 4562 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaD:

; 4546 :         return;
; 4547 :     }
; 4548 :     fprintf(output, "Schemas: ");

	push	OFFSET ??_C@_09CEPCMGAA@Schemas?3?5@
	push	esi
	call	_fprintf

; 4549 :     if (schema->name != NULL)

	mov	eax, DWORD PTR [edi]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@xmlSchemaD

; 4550 :         fprintf(output, "%s, ", schema->name);

	push	eax
	push	OFFSET ??_C@_04ONKFDMMC@?$CFs?0?5@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@xmlSchemaD
$LN4@xmlSchemaD:

; 4551 :     else
; 4552 :         fprintf(output, "no name, ");

	push	OFFSET ??_C@_09HIFPELMF@no?5name?0?5@
	push	esi
	call	_fprintf
	add	esp, 8
$LN5@xmlSchemaD:

; 4553 :     if (schema->targetNamespace != NULL)

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN6@xmlSchemaD

; 4554 :         fprintf(output, "%s", (const char *) schema->targetNamespace);

	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN7@xmlSchemaD
$LN6@xmlSchemaD:

; 4555 :     else
; 4556 :         fprintf(output, "no target namespace");

	push	OFFSET ??_C@_0BE@HFGDBOPE@no?5target?5namespace@
	push	esi
	call	_fprintf
	add	esp, 8
$LN7@xmlSchemaD:

; 4557 :     fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	esi
	call	_fprintf

; 4558 :     if (schema->annot != NULL)

	mov	eax, DWORD PTR [edi+20]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlSchemaD

; 4559 :         xmlSchemaAnnotDump(output, schema->annot);

	push	eax
	push	esi
	call	_xmlSchemaAnnotDump
	add	esp, 8
$LN8@xmlSchemaD:

; 4560 :     xmlHashScan(schema->typeDecl, xmlSchemaTypeDumpEntry, output);

	push	esi
	push	OFFSET _xmlSchemaTypeDumpEntry
	push	DWORD PTR [edi+28]
	call	_xmlHashScan

; 4561 :     xmlHashScanFull(schema->elemDecl, xmlSchemaElementDump, output);

	push	esi
	push	OFFSET _xmlSchemaElementDump
	push	DWORD PTR [edi+40]
	call	_xmlHashScanFull
	add	esp, 24					; 00000018H
	pop	edi
$LN1@xmlSchemaD:
	pop	esi

; 4562 : }

	pop	ebp
	ret	0
_xmlSchemaDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFree
_TEXT	SEGMENT
_schema$ = 8						; size = 4
_xmlSchemaFree PROC					; COMDAT

; 4141 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _schema$[ebp]
	test	edi, edi
	je	$LN1@xmlSchemaF

; 4142 :     if (schema == NULL)
; 4143 :         return;
; 4144 :     /* @volatiles is not used anymore :-/ */
; 4145 :     if (schema->volatiles != NULL)

	cmp	DWORD PTR [edi+80], 0
	push	esi
	je	SHORT $LN6@xmlSchemaF

; 4146 : 	TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	4146					; 00001032H
	push	OFFSET ??_C@_0GM@IJCDLDON@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN6@xmlSchemaF:

; 4147 :     /*
; 4148 :     * Note that those slots are not responsible for freeing
; 4149 :     * schema components anymore; this will now be done by
; 4150 :     * the schema buckets.
; 4151 :     */
; 4152 :     if (schema->notaDecl != NULL)

	mov	eax, DWORD PTR [edi+44]
	test	eax, eax
	je	SHORT $LN7@xmlSchemaF

; 4153 :         xmlHashFree(schema->notaDecl, NULL);

	push	0
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN7@xmlSchemaF:

; 4154 :     if (schema->attrDecl != NULL)

	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	je	SHORT $LN8@xmlSchemaF

; 4155 :         xmlHashFree(schema->attrDecl, NULL);

	push	0
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN8@xmlSchemaF:

; 4156 :     if (schema->attrgrpDecl != NULL)

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN9@xmlSchemaF

; 4157 :         xmlHashFree(schema->attrgrpDecl, NULL);

	push	0
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN9@xmlSchemaF:

; 4158 :     if (schema->elemDecl != NULL)

	mov	eax, DWORD PTR [edi+40]
	test	eax, eax
	je	SHORT $LN10@xmlSchemaF

; 4159 :         xmlHashFree(schema->elemDecl, NULL);

	push	0
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN10@xmlSchemaF:

; 4160 :     if (schema->typeDecl != NULL)

	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	je	SHORT $LN11@xmlSchemaF

; 4161 :         xmlHashFree(schema->typeDecl, NULL);

	push	0
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN11@xmlSchemaF:

; 4162 :     if (schema->groupDecl != NULL)

	mov	eax, DWORD PTR [edi+56]
	test	eax, eax
	je	SHORT $LN12@xmlSchemaF

; 4163 :         xmlHashFree(schema->groupDecl, NULL);

	push	0
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN12@xmlSchemaF:

; 4164 :     if (schema->idcDef != NULL)

	mov	eax, DWORD PTR [edi+76]
	test	eax, eax
	je	SHORT $LN13@xmlSchemaF

; 4165 :         xmlHashFree(schema->idcDef, NULL);

	push	0
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN13@xmlSchemaF:

; 4166 : 
; 4167 :     if (schema->schemasImports != NULL)

	mov	eax, DWORD PTR [edi+48]
	test	eax, eax
	je	SHORT $LN14@xmlSchemaF

; 4168 : 	xmlHashFree(schema->schemasImports, xmlSchemaBucketFreeEntry);

	push	OFFSET _xmlSchemaBucketFreeEntry
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN14@xmlSchemaF:

; 4169 :     if (schema->includes != NULL) {

	push	ebx
	mov	ebx, DWORD PTR [edi+64]
	test	ebx, ebx
	je	SHORT $LN18@xmlSchemaF

; 4170 : 	xmlSchemaItemListPtr list = (xmlSchemaItemListPtr) schema->includes;
; 4171 : 	int i;
; 4172 : 	for (i = 0; i < list->nbItems; i++) {

	xor	esi, esi
	cmp	DWORD PTR [ebx+4], esi
	jle	SHORT $LN3@xmlSchemaF
$LL4@xmlSchemaF:

; 4173 : 	    xmlSchemaBucketFree((xmlSchemaBucketPtr) list->items[i]);

	mov	eax, DWORD PTR [ebx]
	push	DWORD PTR [eax+esi*4]
	call	_xmlSchemaBucketFree
	inc	esi
	add	esp, 4
	cmp	esi, DWORD PTR [ebx+4]
	jl	SHORT $LL4@xmlSchemaF
$LN3@xmlSchemaF:

; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN20@xmlSchemaF

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN20@xmlSchemaF:

; 3534 :     xmlFree(list);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN18@xmlSchemaF:

; 4174 : 	}
; 4175 : 	xmlSchemaItemListFree(list);
; 4176 :     }
; 4177 :     if (schema->annot != NULL)

	mov	esi, DWORD PTR [edi+20]
	pop	ebx
	test	esi, esi
	je	SHORT $LN24@xmlSchemaF

; 3731 :     if (annot->next == NULL) {

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LL25@xmlSchemaF

; 3732 : 	xmlFree(annot);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3733 :     } else {

	jmp	SHORT $LN24@xmlSchemaF
	npad	4
$LL25@xmlSchemaF:

; 3734 : 	xmlSchemaAnnotPtr prev;
; 3735 : 
; 3736 : 	do {
; 3737 : 	    prev = annot;
; 3738 : 	    annot = annot->next;
; 3739 : 	    xmlFree(prev);

	push	esi
	mov	esi, DWORD PTR [esi]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3740 : 	} while (annot != NULL);

	test	esi, esi
	jne	SHORT $LL25@xmlSchemaF
$LN24@xmlSchemaF:

; 4178 :         xmlSchemaFreeAnnot(schema->annot);
; 4179 :     /* Never free the doc here, since this will be done by the buckets. */
; 4180 : 
; 4181 :     xmlDictFree(schema->dict);

	push	DWORD PTR [edi+60]
	call	_xmlDictFree

; 4182 :     xmlFree(schema);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 8
	pop	esi
$LN1@xmlSchemaF:
	pop	edi

; 4183 : }

	pop	ebp
	ret	0
_xmlSchemaFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaParse
_TEXT	SEGMENT
_bucket$ = -4						; size = 4
_msg$1 = 8						; size = 4
_msg$2 = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlSchemaParse PROC					; COMDAT

; 21334: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	DWORD PTR _bucket$[ebp], 0
	call	_xmlSchemaInitTypes
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN40@xmlSchemaP

; 21335:     xmlSchemaPtr mainSchema = NULL;
; 21336:     xmlSchemaBucketPtr bucket = NULL;
; 21337:     int res;
; 21338: 
; 21339:     /*
; 21340:     * This one is used if the schema to be parsed was specified via
; 21341:     * the API; i.e. not automatically by the validated instance document.
; 21342:     */
; 21343: 
; 21344:     xmlSchemaInitTypes();
; 21345: 
; 21346:     if (ctxt == NULL)
; 21347:         return (NULL);
; 21348: 
; 21349:     /* TODO: Init the context. Is this all we need?*/
; 21350:     ctxt->nberrors = 0;

	push	esi
	mov	DWORD PTR [esi+20], 0

; 21351:     ctxt->err = 0;

	mov	DWORD PTR [esi+16], 0

; 21352:     ctxt->counter = 0;

	mov	DWORD PTR [esi+40], 0

; 21353: 
; 21354:     /* Create the *main* schema. */
; 21355:     mainSchema = xmlSchemaNewSchema(ctxt);

	call	_xmlSchemaNewSchema
	mov	edi, eax
	add	esp, 4

; 21356:     if (mainSchema == NULL)

	test	edi, edi
	je	$LN17@xmlSchemaP

; 21357: 	goto exit_failure;
; 21358:     /*
; 21359:     * Create the schema constructor.
; 21360:     */
; 21361:     if (ctxt->constructor == NULL) {

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	jne	SHORT $LN4@xmlSchemaP

; 21362: 	ctxt->constructor = xmlSchemaConstructionCtxtCreate(ctxt->dict);

	push	DWORD PTR [esi+80]
	call	_xmlSchemaConstructionCtxtCreate
	add	esp, 4
	mov	DWORD PTR [esi+28], eax

; 21363: 	if (ctxt->constructor == NULL)

	test	eax, eax
	je	$LN40@xmlSchemaP

; 21364: 	    return(NULL);
; 21365: 	/* Take ownership of the constructor to be able to free it. */
; 21366: 	ctxt->ownsConstructor = 1;

	mov	DWORD PTR [esi+32], 1
$LN4@xmlSchemaP:

; 21367:     }
; 21368:     ctxt->constructor->mainSchema = mainSchema;

	mov	DWORD PTR [eax], edi

; 21369:     /*
; 21370:     * Locate and add the schema document.
; 21371:     */
; 21372:     res = xmlSchemaAddSchemaDoc(ctxt, XML_SCHEMA_SCHEMA_MAIN,

	lea	eax, DWORD PTR _bucket$[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	DWORD PTR [esi+60]
	push	DWORD PTR [esi+56]
	push	DWORD PTR [esi+48]
	push	DWORD PTR [esi+44]
	push	0
	push	esi
	call	_xmlSchemaAddSchemaDoc
	add	esp, 40					; 00000028H

; 21373: 	ctxt->URL, ctxt->doc, ctxt->buffer, ctxt->size, NULL,
; 21374: 	NULL, NULL, &bucket);
; 21375:     if (res == -1)

	cmp	eax, -1
	je	$exit_failure$46

; 21376: 	goto exit_failure;
; 21377:     if (res != 0)

	test	eax, eax
	jne	$exit$47

; 21378: 	goto exit;
; 21379: 
; 21380:     if (bucket == NULL) {

	mov	ebx, DWORD PTR _bucket$[ebp]
	test	ebx, ebx
	jne	$LN8@xmlSchemaP

; 21381: 	/* TODO: Error code, actually we failed to *locate* the schema. */
; 21382: 	if (ctxt->URL)

	mov	ebx, DWORD PTR [esi+44]
	push	eax
	mov	DWORD PTR _msg$2[ebp], eax
	lea	eax, DWORD PTR _msg$2[ebp]
	push	esi
	push	eax
	call	_xmlSchemaFormatNodeForError
	test	ebx, ebx
	je	SHORT $LN9@xmlSchemaP

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0DC@HKCNLJOG@Failed?5to?5locate?5the?5main?5schem@
	push	DWORD PTR _msg$2[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$2[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	ebx

; 21383: 	    xmlSchemaCustomErr(ACTXT_CAST ctxt, XML_SCHEMAP_FAILED_LOAD,

	jmp	SHORT $LN44@xmlSchemaP
$LN9@xmlSchemaP:

; 2348 :     msg = xmlStrcat(msg, (const xmlChar *) message);

	push	OFFSET ??_C@_0CK@PCIDMOBP@Failed?5to?5locate?5the?5main?5schem@
	push	DWORD PTR _msg$1[ebp]
	call	_xmlStrcat

; 2349 :     msg = xmlStrcat(msg, BAD_CAST ".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6@
	push	eax
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlStrcat

; 2169 :     xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,

	push	0
	push	0
	push	0
	push	0
$LN44@xmlSchemaP:

; 21406: 	goto exit_failure;
; 21407: 
; 21408:     /*
; 21409:     * TODO: This is not nice, since we cannot distinguish from the
; 21410:     * result if there was an internal error or not.
; 21411:     */
; 21412: exit:
; 21413:     if (ctxt->nberrors != 0) {

	push	eax
	push	0
	push	0
	push	1757					; 000006ddH
	push	2
	push	esi
	mov	DWORD PTR _msg$1[ebp], eax
	call	_xmlSchemaErr4Line
	mov	eax, DWORD PTR _msg$1[ebp]
	add	esp, 68					; 00000044H
	test	eax, eax
	je	SHORT $exit$47
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	jmp	SHORT $exit$47
$LN8@xmlSchemaP:

; 21384: 		NULL, NULL,
; 21385: 		"Failed to locate the main schema resource at '%s'",
; 21386: 		ctxt->URL, NULL);
; 21387: 	else
; 21388: 	    xmlSchemaCustomErr(ACTXT_CAST ctxt, XML_SCHEMAP_FAILED_LOAD,
; 21389: 		NULL, NULL,
; 21390: 		"Failed to locate the main schema resource",
; 21391: 		    NULL, NULL);
; 21392: 	goto exit;
; 21393:     }
; 21394:     /* Then do the parsing for good. */
; 21395:     if (xmlSchemaParseNewDocWithContext(ctxt, mainSchema, bucket) == -1)

	push	ebx
	push	edi
	push	esi
	call	_xmlSchemaParseNewDocWithContext
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	je	SHORT $exit_failure$46

; 21396: 	goto exit_failure;
; 21397:     if (ctxt->nberrors != 0)

	cmp	DWORD PTR [esi+20], 0
	jne	SHORT $LN42@xmlSchemaP

; 21398: 	goto exit;
; 21399: 
; 21400:     mainSchema->doc = bucket->doc;

	mov	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR [edi+16], eax

; 21401:     mainSchema->preserve = ctxt->preserve;

	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [edi+68], eax

; 21402: 
; 21403:     ctxt->schema = mainSchema;
; 21404: 
; 21405:     if (xmlSchemaFixupComponents(ctxt, WXS_CONSTRUCTOR(ctxt)->mainBucket) == -1)

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [esi+36], edi
	push	DWORD PTR [eax+4]
	push	esi
	call	_xmlSchemaFixupComponents
	add	esp, 8
	cmp	eax, -1
	je	SHORT $exit_failure$46
$exit$47:

; 21406: 	goto exit_failure;
; 21407: 
; 21408:     /*
; 21409:     * TODO: This is not nice, since we cannot distinguish from the
; 21410:     * result if there was an internal error or not.
; 21411:     */
; 21412: exit:
; 21413:     if (ctxt->nberrors != 0) {

	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN16@xmlSchemaP
$LN42@xmlSchemaP:

; 21414: 	if (mainSchema) {
; 21415: 	    xmlSchemaFree(mainSchema);

	push	edi
	call	_xmlSchemaFree

; 21416: 	    mainSchema = NULL;
; 21417: 	}
; 21418: 	if (ctxt->constructor) {

	mov	eax, DWORD PTR [esi+28]
	add	esp, 4
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN16@xmlSchemaP

; 21419: 	    xmlSchemaConstructionCtxtFree(ctxt->constructor);

	push	eax
	call	_xmlSchemaConstructionCtxtFree
	add	esp, 4

; 21420: 	    ctxt->constructor = NULL;

	mov	DWORD PTR [esi+28], edi

; 21421: 	    ctxt->ownsConstructor = 0;

	mov	DWORD PTR [esi+32], edi
$LN16@xmlSchemaP:

; 21422: 	}
; 21423:     }
; 21424:     ctxt->schema = NULL;
; 21425:     return(mainSchema);

	mov	eax, edi
	mov	DWORD PTR [esi+36], 0
	pop	edi

; 21443:     return(NULL);
; 21444: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$exit_failure$46:

; 21426: exit_failure:
; 21427:     /*
; 21428:     * Quite verbose, but should catch internal errors, which were
; 21429:     * not communitated.
; 21430:     */
; 21431:     if (mainSchema) {
; 21432:         xmlSchemaFree(mainSchema);

	push	edi
	call	_xmlSchemaFree
	add	esp, 4
$LN17@xmlSchemaP:

; 21433: 	mainSchema = NULL;
; 21434:     }
; 21435:     if (ctxt->constructor) {

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN18@xmlSchemaP

; 21436: 	xmlSchemaConstructionCtxtFree(ctxt->constructor);

	push	eax
	call	_xmlSchemaConstructionCtxtFree
	add	esp, 4

; 21437: 	ctxt->constructor = NULL;

	mov	DWORD PTR [esi+28], 0

; 21438: 	ctxt->ownsConstructor = 0;

	mov	DWORD PTR [esi+32], 0
$LN18@xmlSchemaP:

; 2314 :     xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BL@KBEKBABO@An?5internal?5error?5occurred@
	push	OFFSET ??_C@_0P@FJHIALID@xmlSchemaParse@
	push	esi
	call	_xmlSchemaInternalErr2
	add	esp, 20					; 00000014H

; 21439:     }
; 21440:     PERROR_INT2("xmlSchemaParse",
; 21441: 	"An internal error occurred");
; 21442:     ctxt->schema = NULL;

	mov	DWORD PTR [esi+36], 0
$LN40@xmlSchemaP:

; 21443:     return(NULL);
; 21444: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaIsValid
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSchemaIsValid PROC					; COMDAT

; 27808: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@xmlSchemaI

; 27809:     if (ctxt == NULL)
; 27810:         return(-1);

	or	eax, -1

; 27812: }

	pop	ebp
	ret	0
$LN2@xmlSchemaI:

; 27811:     return(ctxt->err == 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+52], eax
	sete	al

; 27812: }

	pop	ebp
	ret	0
_xmlSchemaIsValid ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaGetParserErrors
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_err$ = 12						; size = 4
_warn$ = 16						; size = 4
_ctx$ = 20						; size = 4
_xmlSchemaGetParserErrors PROC				; COMDAT

; 21505: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@xmlSchemaG

; 21506: 	if (ctxt == NULL)
; 21507: 		return(-1);

	or	eax, -1

; 21515: }

	pop	ebp
	ret	0
$LN2@xmlSchemaG:

; 21508: 	if (err != NULL)

	mov	edx, DWORD PTR _err$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlSchemaG

; 21509: 		*err = ctxt->error;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax
$LN3@xmlSchemaG:

; 21510: 	if (warn != NULL)

	mov	edx, DWORD PTR _warn$[ebp]
	test	edx, edx
	je	SHORT $LN4@xmlSchemaG

; 21511: 		*warn = ctxt->warning;

	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx], eax
$LN4@xmlSchemaG:

; 21512: 	if (ctx != NULL)

	mov	edx, DWORD PTR _ctx$[ebp]
	test	edx, edx
	je	SHORT $LN5@xmlSchemaG

; 21513: 		*ctx = ctxt->errCtxt;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN5@xmlSchemaG:

; 21514: 	return(0);

	xor	eax, eax

; 21515: }

	pop	ebp
	ret	0
_xmlSchemaGetParserErrors ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSetParserStructuredErrors
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_serror$ = 12						; size = 4
_ctx$ = 16						; size = 4
_xmlSchemaSetParserStructuredErrors PROC		; COMDAT

; 21481: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaS

; 21482:     if (ctxt == NULL)
; 21483: 	return;
; 21484:     ctxt->serror = serror;
; 21485:     ctxt->errCtxt = ctx;

	mov	ecx, DWORD PTR _serror$[ebp]
	mov	edx, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+4], edx

; 21486:     if (ctxt->vctxt != NULL)

	mov	eax, DWORD PTR [eax+92]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaS

; 21487: 	xmlSchemaSetValidStructuredErrors(ctxt->vctxt, serror, ctx);

	mov	DWORD PTR _ctx$[ebp], edx
	mov	DWORD PTR _serror$[ebp], ecx
	mov	DWORD PTR _ctxt$[ebp], eax

; 21488: }

	pop	ebp

; 21487: 	xmlSchemaSetValidStructuredErrors(ctxt->vctxt, serror, ctx);

	jmp	_xmlSchemaSetValidStructuredErrors
$LN3@xmlSchemaS:

; 21488: }

	pop	ebp
	ret	0
_xmlSchemaSetParserStructuredErrors ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaSetParserErrors
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_err$ = 12						; size = 4
_warn$ = 16						; size = 4
_ctx$ = 20						; size = 4
_xmlSchemaSetParserErrors PROC				; COMDAT

; 21459: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaS

; 21460:     if (ctxt == NULL)
; 21461:         return;
; 21462:     ctxt->error = err;
; 21463:     ctxt->warning = warn;

	mov	ecx, DWORD PTR _err$[ebp]
	mov	edx, DWORD PTR _warn$[ebp]
	push	esi

; 21464:     ctxt->errCtxt = ctx;

	mov	esi, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+4], esi

; 21465:     if (ctxt->vctxt != NULL)

	mov	eax, DWORD PTR [eax+92]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaS

; 21466: 	xmlSchemaSetValidErrors(ctxt->vctxt, err, warn, ctx);

	push	esi
	push	edx
	push	ecx
	push	eax
	call	_xmlSchemaSetValidErrors
	add	esp, 16					; 00000010H
$LN5@xmlSchemaS:
	pop	esi
$LN3@xmlSchemaS:

; 21467: }

	pop	ebp
	ret	0
_xmlSchemaSetParserErrors ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaFreeParserCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSchemaFreeParserCtxt PROC				; COMDAT

; 12563: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN1@xmlSchemaF

; 12564:     if (ctxt == NULL)
; 12565:         return;
; 12566:     if (ctxt->doc != NULL && !ctxt->preserve)

	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaF
	cmp	DWORD PTR [esi+52], 0
	jne	SHORT $LN3@xmlSchemaF

; 12567:         xmlFreeDoc(ctxt->doc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN3@xmlSchemaF:

; 12568:     if (ctxt->vctxt != NULL) {

	mov	eax, DWORD PTR [esi+92]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaF

; 12569: 	xmlSchemaFreeValidCtxt(ctxt->vctxt);

	push	eax
	call	_xmlSchemaFreeValidCtxt
	add	esp, 4
$LN4@xmlSchemaF:

; 12570:     }
; 12571:     if (ctxt->ownsConstructor && (ctxt->constructor != NULL)) {

	cmp	DWORD PTR [esi+32], 0
	je	SHORT $LN5@xmlSchemaF
	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaF

; 12572: 	xmlSchemaConstructionCtxtFree(ctxt->constructor);

	push	eax
	call	_xmlSchemaConstructionCtxtFree
	add	esp, 4

; 12573: 	ctxt->constructor = NULL;

	mov	DWORD PTR [esi+28], 0

; 12574: 	ctxt->ownsConstructor = 0;

	mov	DWORD PTR [esi+32], 0
$LN5@xmlSchemaF:

; 12575:     }
; 12576:     if (ctxt->attrProhibs != NULL)

	push	edi
	mov	edi, DWORD PTR [esi+128]
	test	edi, edi
	je	SHORT $LN8@xmlSchemaF

; 3532 :     if (list->items != NULL)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN10@xmlSchemaF

; 3533 : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlSchemaF:

; 3534 :     xmlFree(list);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlSchemaF:

; 12577: 	xmlSchemaItemListFree(ctxt->attrProhibs);
; 12578:     xmlDictFree(ctxt->dict);

	push	DWORD PTR [esi+80]
	call	_xmlDictFree

; 12579:     xmlFree(ctxt);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 8
	pop	edi
$LN1@xmlSchemaF:
	pop	esi

; 12580: }

	pop	ebp
	ret	0
_xmlSchemaFreeParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaNewDocParserCtxt
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_xmlSchemaNewDocParserCtxt PROC				; COMDAT

; 12539: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	je	SHORT $LN5@xmlSchemaN

; 12540:     xmlSchemaParserCtxtPtr ret;
; 12541: 
; 12542:     if (doc == NULL)
; 12543:       return (NULL);
; 12544:     ret = xmlSchemaParserCtxtCreate();

	call	_xmlSchemaParserCtxtCreate
	mov	esi, eax

; 12545:     if (ret == NULL)

	test	esi, esi
	je	SHORT $LN5@xmlSchemaN

; 12547:     ret->doc = doc;

	mov	DWORD PTR [esi+48], edi

; 12548:     ret->dict = xmlDictCreate();

	call	_xmlDictCreate
	mov	DWORD PTR [esi+80], eax

; 12549:     /* The application has responsibility for the document */
; 12550:     ret->preserve = 1;
; 12551: 
; 12552:     return (ret);

	mov	eax, esi
	pop	edi
	mov	DWORD PTR [esi+52], 1

; 12553: }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlSchemaN:
	pop	edi

; 12546: 	return(NULL);

	xor	eax, eax

; 12553: }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaNewDocParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaNewMemParserCtxt
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlSchemaNewMemParserCtxt PROC				; COMDAT

; 12514: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _buffer$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@xmlSchemaN

; 12515:     xmlSchemaParserCtxtPtr ret;
; 12516: 
; 12517:     if ((buffer == NULL) || (size <= 0))

	mov	edi, DWORD PTR _size$[ebp]
	test	edi, edi
	jle	SHORT $LN3@xmlSchemaN

; 12518:         return (NULL);
; 12519:     ret = xmlSchemaParserCtxtCreate();

	call	_xmlSchemaParserCtxtCreate
	mov	esi, eax

; 12520:     if (ret == NULL)

	test	esi, esi
	je	SHORT $LN3@xmlSchemaN

; 12521: 	return(NULL);
; 12522:     ret->buffer = buffer;

	mov	DWORD PTR [esi+56], ebx

; 12523:     ret->size = size;

	mov	DWORD PTR [esi+60], edi

; 12524:     ret->dict = xmlDictCreate();

	call	_xmlDictCreate
	mov	DWORD PTR [esi+80], eax

; 12525:     return (ret);

	mov	eax, esi
	pop	edi

; 12526: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemaN:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaNewMemParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemas.c
;	COMDAT _xmlSchemaNewParserCtxt
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_xmlSchemaNewParserCtxt PROC				; COMDAT

; 12488: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7C094509_xmlschemas@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _URL$[ebp], 0
	je	SHORT $LN5@xmlSchemaN

; 12489:     xmlSchemaParserCtxtPtr ret;
; 12490: 
; 12491:     if (URL == NULL)
; 12492:         return (NULL);
; 12493: 
; 12494:     ret = xmlSchemaParserCtxtCreate();

	call	_xmlSchemaParserCtxtCreate
	mov	esi, eax

; 12495:     if (ret == NULL)

	test	esi, esi
	je	SHORT $LN5@xmlSchemaN

; 12497:     ret->dict = xmlDictCreate();

	call	_xmlDictCreate

; 12498:     ret->URL = xmlDictLookup(ret->dict, (const xmlChar *) URL, -1);

	push	-1
	push	DWORD PTR _URL$[ebp]
	mov	DWORD PTR [esi+80], eax
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+44], eax

; 12499:     return (ret);

	mov	eax, esi
	pop	esi

; 12500: }

	pop	ebp
	ret	0
$LN5@xmlSchemaN:

; 12496: 	return(NULL);

	xor	eax, eax
	pop	esi

; 12500: }

	pop	ebp
	ret	0
_xmlSchemaNewParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	or	ecx, 2
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;

	pop	esi

; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);
; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;

	pop	esi

; 842  :     }

	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
; 644  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
