; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\pattern.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__69230394_pattern@c DB 01H
msvcjmc	ENDS
PUBLIC	_xmlFreePattern
PUBLIC	_xmlFreePatternList
PUBLIC	_xmlPatterncompile
PUBLIC	_xmlPatternMatch
PUBLIC	_xmlPatternStreamable
PUBLIC	_xmlPatternMaxDepth
PUBLIC	_xmlPatternMinDepth
PUBLIC	_xmlPatternFromRoot
PUBLIC	_xmlPatternGetStreamCtxt
PUBLIC	_xmlFreeStreamCtxt
PUBLIC	_xmlStreamPushNode
PUBLIC	_xmlStreamPush
PUBLIC	_xmlStreamPushAttr
PUBLIC	_xmlStreamPop
PUBLIC	_xmlStreamWantsAnyNode
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ ; `string'
PUBLIC	??_C@_05GPGNDLEK@child@				; `string'
PUBLIC	??_C@_09HGIEBAJ@attribute@			; `string'
PUBLIC	__xmm@ffffffffffffffffffffffffffffffff
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlDictReference:PROC
EXTRN	_xmlDictFree:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlCharInRange:PROC
EXTRN	_xmlStringCurrentChar:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
;	COMDAT __xmm@ffffffffffffffffffffffffffffffff
CONST	SEGMENT
__xmm@ffffffffffffffffffffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
CONST	ENDS
;	COMDAT ??_C@_09HGIEBAJ@attribute@
CONST	SEGMENT
??_C@_09HGIEBAJ@attribute@ DB 'attribute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GPGNDLEK@child@
CONST	SEGMENT
??_C@_05GPGNDLEK@child@ DB 'child', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
CONST	SEGMENT
??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ DB 'http://ww'
	DB	'w.w3.org/XML/1998/namespace', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamPushInternal
_TEXT	SEGMENT
_step$ = -44						; size = 16
_desc$1$ = -28						; size = 4
_err$1$ = -24						; size = 4
_stepNr$1$ = -20					; size = 4
_step$10$ = -16						; size = 4
_i$1$ = -16						; size = 4
_m$1$ = -12						; size = 4
_final$1$ = -8						; size = 4
_ret$2$ = -4						; size = 4
_comp$1$ = 8						; size = 4
_stream$ = 8						; size = 4
_name$ = 12						; size = 4
_ns$ = 16						; size = 4
_nodeType$ = 20						; size = 4
_xmlStreamPushInternal PROC				; COMDAT

; 1860 : 		      int nodeType) {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _stream$[ebp]
	xor	eax, eax
	xor	ecx, ecx
	mov	DWORD PTR _err$1$[ebp], eax
	mov	DWORD PTR _ret$2$[ebp], ecx
	mov	DWORD PTR _final$1$[ebp], eax
	test	esi, esi
	je	$LN7@xmlStreamP

; 1861 :     int ret = 0, err = 0, final = 0, tmp, i, m, match, stepNr, desc;
; 1862 :     xmlStreamCompPtr comp;
; 1863 :     xmlStreamStep step;
; 1864 : #ifdef DEBUG_STREAMING
; 1865 :     xmlStreamCtxtPtr orig = stream;
; 1866 : #endif
; 1867 : 
; 1868 :     if ((stream == NULL) || (stream->nbState < 0))

	cmp	DWORD PTR [esi+8], eax
	jl	$LN7@xmlStreamP
	mov	edx, DWORD PTR _nodeType$[ebp]
	mov	edi, DWORD PTR _ns$[ebp]
	npad	6
$LL2@xmlStreamP:

; 1872 : 	comp = stream->comp;

	mov	ebx, DWORD PTR [esi+4]
	mov	DWORD PTR _comp$1$[ebp], ebx

; 1873 : 
; 1874 : 	if ((nodeType == XML_ELEMENT_NODE) &&
; 1875 : 	    (name == NULL) && (ns == NULL)) {

	cmp	edx, 1
	jne	SHORT $LN8@xmlStreamP
	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN8@xmlStreamP
	test	edi, edi
	jne	SHORT $LN8@xmlStreamP

; 1876 : 	    /* We have a document node here (or a reset). */
; 1877 : 	    stream->nbState = 0;

	mov	DWORD PTR [esi+8], edi

; 1878 : 	    stream->level = 0;

	mov	DWORD PTR [esi+16], edi

; 1879 : 	    stream->blockLevel = -1;

	mov	DWORD PTR [esi+28], -1

; 1880 : 	    if (comp->flags & XML_STREAM_FROM_ROOT) {

	test	DWORD PTR [ebx+16], 32768		; 00008000H
	je	SHORT $LN15@xmlStreamP

; 1881 : 		if (comp->nbStep == 0) {

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	jne	SHORT $LN10@xmlStreamP

; 1882 : 		    /* TODO: We have a "/." here? */
; 1883 : 		    ret = 1;

	mov	DWORD PTR _ret$2$[ebp], edx

; 1899 : 		    }
; 1900 : 		}
; 1901 : 	    }
; 1902 : 	    stream = stream->next;
; 1903 : 	    continue; /* while */

	mov	ecx, edx
	jmp	$LN122@xmlStreamP
$LN10@xmlStreamP:

; 1884 : 		} else {
; 1885 : 		    if ((comp->nbStep == 1) &&
; 1886 : 			(comp->steps[0].nodeType == XML_STREAM_ANY_NODE) &&

	cmp	eax, 1
	jne	SHORT $LN12@xmlStreamP
	mov	eax, DWORD PTR [ebx+12]
	cmp	DWORD PTR [eax+12], 100			; 00000064H
	jne	SHORT $LN12@xmlStreamP
	test	BYTE PTR [eax], 1
	je	SHORT $LN12@xmlStreamP

; 1887 : 			(comp->steps[0].flags & XML_STREAM_STEP_DESC))
; 1888 : 		    {
; 1889 : 			/*
; 1890 : 			* In the case of "//." the document node will match
; 1891 : 			* as well.
; 1892 : 			*/
; 1893 : 			ret = 1;

	mov	DWORD PTR _ret$2$[ebp], 1

; 1899 : 		    }
; 1900 : 		}
; 1901 : 	    }
; 1902 : 	    stream = stream->next;
; 1903 : 	    continue; /* while */

	mov	ecx, DWORD PTR _ret$2$[ebp]
	jmp	$LN122@xmlStreamP
$LN12@xmlStreamP:

; 1894 : 		    } else if (comp->steps[0].flags & XML_STREAM_STEP_ROOT) {

	mov	eax, DWORD PTR [ebx+12]
	test	BYTE PTR [eax], 4
	je	SHORT $LN15@xmlStreamP

; 1895 : 			/* TODO: Do we need this ? */
; 1896 : 			tmp = xmlStreamCtxtAddState(stream, 0, 0);

	push	0
	push	0
	push	esi
	call	_xmlStreamCtxtAddState

; 1897 : 			if (tmp < 0)

	mov	edx, DWORD PTR _nodeType$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jns	SHORT $LN15@xmlStreamP

; 1898 : 			    err++;

	inc	DWORD PTR _err$1$[ebp]
$LN15@xmlStreamP:

; 1899 : 		    }
; 1900 : 		}
; 1901 : 	    }
; 1902 : 	    stream = stream->next;
; 1903 : 	    continue; /* while */

	mov	ecx, DWORD PTR _ret$2$[ebp]
	jmp	$LN122@xmlStreamP
$LN8@xmlStreamP:

; 1904 : 	}
; 1905 : 
; 1906 : 	/*
; 1907 : 	* Fast check for ".".
; 1908 : 	*/
; 1909 : 	if (comp->nbStep == 0) {

	cmp	DWORD PTR [ebx+4], 0
	jne	SHORT $LN16@xmlStreamP

; 1910 : 	    /*
; 1911 : 	     * / and . are handled at the XPath node set creation
; 1912 : 	     * level by checking min depth
; 1913 : 	     */
; 1914 : 	    if (stream->flags & XML_PATTERN_XPATH) {

	mov	eax, DWORD PTR [esi+24]
	test	al, 1
	je	SHORT $LN17@xmlStreamP

; 1915 : 		stream = stream->next;
; 1916 : 		continue; /* while */

	mov	ecx, DWORD PTR _ret$2$[ebp]
	jmp	$LN122@xmlStreamP
$LN17@xmlStreamP:

; 1917 : 	    }
; 1918 : 	    /*
; 1919 : 	    * For non-pattern like evaluation like XML Schema IDCs
; 1920 : 	    * or traditional XPath expressions, this will match if
; 1921 : 	    * we are at the first level only, otherwise on every level.
; 1922 : 	    */
; 1923 : 	    if ((nodeType != XML_ATTRIBUTE_NODE) &&

	cmp	edx, 2
	je	SHORT $LN18@xmlStreamP
	test	al, 7
	je	SHORT $LN95@xmlStreamP
	cmp	DWORD PTR [esi+16], 0
	jne	SHORT $LN18@xmlStreamP
$LN95@xmlStreamP:

; 1924 : 		(((stream->flags & XML_PATTERN_NOTPATTERN) == 0) ||
; 1925 : 		(stream->level == 0))) {
; 1926 : 		    ret = 1;

	mov	DWORD PTR _ret$2$[ebp], 1
$LN18@xmlStreamP:

; 1927 : 	    }
; 1928 : 	    stream->level++;

	inc	DWORD PTR [esi+16]
$LN98@xmlStreamP:

; 2186 : 	}
; 2187 : 
; 2188 : stream_next:
; 2189 :         stream = stream->next;

	mov	ecx, DWORD PTR _ret$2$[ebp]
	jmp	$stream_next$124
$LN16@xmlStreamP:

; 1929 : 	    goto stream_next;
; 1930 : 	}
; 1931 : 	if (stream->blockLevel != -1) {

	cmp	DWORD PTR [esi+28], -1
	je	SHORT $LN20@xmlStreamP

; 1932 : 	    /*
; 1933 : 	    * Skip blocked expressions.
; 1934 : 	    */
; 1935 : 	    stream->level++;

	inc	DWORD PTR [esi+16]

; 1936 : 	    goto stream_next;

	mov	ecx, DWORD PTR _ret$2$[ebp]
	jmp	$stream_next$124
$LN20@xmlStreamP:

; 1937 : 	}
; 1938 : 
; 1939 : 	if ((nodeType != XML_ELEMENT_NODE) &&
; 1940 : 	    (nodeType != XML_ATTRIBUTE_NODE) &&

	cmp	edx, 1
	je	SHORT $LN21@xmlStreamP
	cmp	edx, 2
	je	SHORT $LN21@xmlStreamP
	test	DWORD PTR [ebx+16], 16384		; 00004000H
	jne	SHORT $LN21@xmlStreamP

; 1941 : 	    ((comp->flags & XML_STREAM_FINAL_IS_ANY_NODE) == 0)) {
; 1942 : 	    /*
; 1943 : 	    * No need to process nodes of other types if we don't
; 1944 : 	    * resolve to those types.
; 1945 : 	    * TODO: Do we need to block the context here?
; 1946 : 	    */
; 1947 : 	    stream->level++;

	inc	DWORD PTR [esi+16]

; 1948 : 	    goto stream_next;

	mov	ecx, DWORD PTR _ret$2$[ebp]
	jmp	$stream_next$124
$LN21@xmlStreamP:

; 1949 : 	}
; 1950 : 
; 1951 : 	/*
; 1952 : 	 * Check evolution of existing states
; 1953 : 	 */
; 1954 : 	i = 0;
; 1955 : 	m = stream->nbState;

	mov	edx, DWORD PTR [esi+8]
	xor	eax, eax
	mov	DWORD PTR _i$1$[ebp], eax
	mov	DWORD PTR _m$1$[ebp], edx

; 1956 : 	while (i < m) {

	test	edx, edx
	jle	$LN5@xmlStreamP
	mov	ecx, edx
	npad	1
$LL4@xmlStreamP:

; 1957 : 	    if ((comp->flags & XML_STREAM_DESC) == 0) {

	mov	edi, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [esi+20]
	and	edi, 65536				; 00010000H
	jne	SHORT $LN22@xmlStreamP

; 1958 : 		/*
; 1959 : 		* If there is no "//", then only the last
; 1960 : 		* added state is of interest.
; 1961 : 		*/
; 1962 : 		stepNr = stream->states[2 * (stream->nbState -1)];

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [edx+eax*8-8]
	mov	DWORD PTR _stepNr$1$[ebp], ecx

; 1963 : 		/*
; 1964 : 		* TODO: Security check, should not happen, remove it.
; 1965 : 		*/
; 1966 : 		if (stream->states[(2 * (stream->nbState -1)) + 1] <

	mov	ecx, DWORD PTR [esi+16]
	cmp	DWORD PTR [edx+eax*8-4], ecx
	jl	$LN7@xmlStreamP

; 1967 : 		    stream->level) {
; 1968 : 		    return (-1);
; 1969 : 		}
; 1970 : 		desc = 0;
; 1971 : 		/* loop-stopper */
; 1972 : 		i = m;

	mov	eax, DWORD PTR _m$1$[ebp]
	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR _desc$1$[ebp], 0
	mov	DWORD PTR _i$1$[ebp], eax

; 1973 : 	    } else {

	jmp	SHORT $LN27@xmlStreamP
$LN22@xmlStreamP:

; 1974 : 		/*
; 1975 : 		* If there are "//", then we need to process every "//"
; 1976 : 		* occuring in the states, plus any other state for this
; 1977 : 		* level.
; 1978 : 		*/
; 1979 : 		stepNr = stream->states[2 * i];

	mov	eax, DWORD PTR [edx+eax*8]
	mov	DWORD PTR _stepNr$1$[ebp], eax

; 1980 : 
; 1981 : 		/* TODO: should not happen anymore: dead states */
; 1982 : 		if (stepNr < 0)

	test	eax, eax
	js	$next_state$125

; 1983 : 		    goto next_state;
; 1984 : 
; 1985 : 		tmp = stream->states[(2 * i) + 1];

	mov	ebx, DWORD PTR _i$1$[ebp]

; 1986 : 
; 1987 : 		/* skip new states just added */
; 1988 : 		if (tmp > stream->level)

	mov	ecx, DWORD PTR [esi+16]
	mov	ebx, DWORD PTR [edx+ebx*8+4]
	cmp	ebx, ecx
	jg	$LN105@xmlStreamP

; 1989 : 		    goto next_state;
; 1990 : 
; 1991 : 		/* skip states at ancestor levels, except if "//" */
; 1992 : 		desc = comp->steps[stepNr].flags & XML_STREAM_STEP_DESC;

	mov	edx, DWORD PTR _comp$1$[ebp]
	add	eax, eax
	mov	edx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR [edx+eax*8]
	and	eax, 1

; 1993 : 		if ((tmp < stream->level) && (!desc))

	cmp	ebx, ecx
	mov	ebx, DWORD PTR _comp$1$[ebp]
	mov	DWORD PTR _desc$1$[ebp], eax
	jge	SHORT $LN27@xmlStreamP
	test	eax, eax
	je	$LN118@xmlStreamP
$LN27@xmlStreamP:

; 1994 : 		    goto next_state;
; 1995 : 	    }
; 1996 : 	    /*
; 1997 : 	    * Check for correct node-type.
; 1998 : 	    */
; 1999 : 	    step = comp->steps[stepNr];

	mov	eax, DWORD PTR _stepNr$1$[ebp]
	add	eax, eax
	movups	xmm0, XMMWORD PTR [edx+eax*8]
	movups	XMMWORD PTR _step$[ebp], xmm0

; 2000 : 	    if (step.nodeType != nodeType) {

	psrldq	xmm0, 12				; 0000000cH
	movd	eax, xmm0
	cmp	eax, DWORD PTR _nodeType$[ebp]
	je	SHORT $LN32@xmlStreamP

; 2001 : 		if (step.nodeType == XML_ATTRIBUTE_NODE) {

	cmp	eax, 2
	jne	SHORT $LN29@xmlStreamP

; 2002 : 		    /*
; 2003 : 		    * Block this expression for deeper evaluation.
; 2004 : 		    */
; 2005 : 		    if ((comp->flags & XML_STREAM_DESC) == 0)

	test	edi, edi
	jne	$LN118@xmlStreamP

; 2006 : 			stream->blockLevel = stream->level +1;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+28], eax

; 2007 : 		    goto next_state;

	jmp	$LN118@xmlStreamP
$LN29@xmlStreamP:

; 2008 : 		} else if (step.nodeType != XML_STREAM_ANY_NODE)

	cmp	eax, 100				; 00000064H
	jne	$LN118@xmlStreamP
$LN32@xmlStreamP:

; 2009 : 		    goto next_state;
; 2010 : 	    }
; 2011 : 	    /*
; 2012 : 	    * Compare local/namespace-name.
; 2013 : 	    */
; 2014 : 	    match = 0;

	xor	edi, edi

; 2015 : 	    if (step.nodeType == XML_STREAM_ANY_NODE) {

	cmp	eax, 100				; 00000064H
	je	SHORT $LN41@xmlStreamP

; 2016 : 		match = 1;
; 2017 : 	    } else if (step.name == NULL) {

	mov	edx, DWORD PTR _step$[ebp+4]
	test	edx, edx
	jne	SHORT $LN35@xmlStreamP

; 2018 : 		if (step.ns == NULL) {

	mov	eax, DWORD PTR _step$[ebp+8]
	test	eax, eax
	je	SHORT $LN41@xmlStreamP

; 2019 : 		    /*
; 2020 : 		    * This lets through all elements/attributes.
; 2021 : 		    */
; 2022 : 		    match = 1;
; 2023 : 		} else if (ns != NULL)

	mov	ecx, DWORD PTR _ns$[ebp]
	test	ecx, ecx
	je	$LN114@xmlStreamP

; 2024 : 		    match = xmlStrEqual(step.ns, ns);

	push	ecx
	push	eax
	call	_xmlStrEqual
	mov	edi, eax
	add	esp, 8

; 2029 : 		((step.ns == ns) || xmlStrEqual(step.ns, ns)))
; 2030 : 	    {
; 2031 : 		match = 1;
; 2032 : 	    }
; 2033 : #if 0
; 2034 : /*
; 2035 : * TODO: Pointer comparison won't work, since not guaranteed that the given
; 2036 : *  values are in the same dict; especially if it's the namespace name,
; 2037 : *  normally coming from ns->href. We need a namespace dict mechanism !
; 2038 : */
; 2039 : 	    } else if (comp->dict) {
; 2040 : 		if (step.name == NULL) {
; 2041 : 		    if (step.ns == NULL)
; 2042 : 			match = 1;
; 2043 : 		    else
; 2044 : 			match = (step.ns == ns);
; 2045 : 		} else {
; 2046 : 		    match = ((step.name == name) && (step.ns == ns));
; 2047 : 		}
; 2048 : #endif /* if 0 ------------------------------------------------------- */
; 2049 : 	    if (match) {

	test	edi, edi
	je	$LN114@xmlStreamP
	jmp	SHORT $LN93@xmlStreamP
$LN35@xmlStreamP:

; 2025 : 	    } else if (((step.ns != NULL) == (ns != NULL)) &&
; 2026 : 		(name != NULL) &&
; 2027 : 		(step.name[0] == name[0]) &&
; 2028 : 		xmlStrEqual(step.name, name) &&

	mov	ebx, DWORD PTR _step$[ebp+8]
	xor	ecx, ecx
	test	ebx, ebx
	setne	cl
	xor	eax, eax
	cmp	DWORD PTR _ns$[ebp], eax
	setne	al
	cmp	ecx, eax
	jne	SHORT $LN111@xmlStreamP
	mov	ecx, DWORD PTR _name$[ebp]
	test	ecx, ecx
	je	SHORT $LN111@xmlStreamP
	mov	al, BYTE PTR [edx]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN111@xmlStreamP
	push	ecx
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN111@xmlStreamP
	mov	eax, DWORD PTR _ns$[ebp]
	cmp	ebx, eax
	je	SHORT $LN41@xmlStreamP
	push	eax
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN111@xmlStreamP
$LN41@xmlStreamP:

; 2050 : 		final = step.flags & XML_STREAM_STEP_FINAL;

	mov	edi, 1
$LN93@xmlStreamP:
	mov	ebx, DWORD PTR _step$[ebp]
	mov	eax, ebx
	and	eax, 2
	mov	DWORD PTR _final$1$[ebp], eax

; 2068 : 		    /*
; 2069 : 		    * Check if we have a special case like "foo/bar//.", where
; 2070 : 		    * "foo" is selected as well.
; 2071 : 		    */
; 2072 : 		    ret = 1;
; 2073 : 		}
; 2074 : 	    }
; 2075 : 	    if (((comp->flags & XML_STREAM_DESC) == 0) &&

	test	eax, eax
	je	SHORT $LN47@xmlStreamP
	mov	ebx, DWORD PTR _comp$1$[ebp]
	mov	DWORD PTR _ret$2$[ebp], 1
	jmp	SHORT $LN49@xmlStreamP
$LN47@xmlStreamP:

; 2051 : 		if (desc) {
; 2052 : 		    if (final) {
; 2053 : 			ret = 1;
; 2054 : 		    } else {
; 2055 : 			/* descending match create a new state */
; 2056 : 			xmlStreamCtxtAddState(stream, stepNr + 1,
; 2057 : 			                      stream->level + 1);
; 2058 : 		    }
; 2059 : 		} else {
; 2060 : 		    if (final) {
; 2061 : 			ret = 1;
; 2062 : 		    } else {
; 2063 : 			xmlStreamCtxtAddState(stream, stepNr + 1,
; 2064 : 			                      stream->level + 1);
; 2065 : 		    }
; 2066 : 		}
; 2067 : 		if ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {

	mov	eax, DWORD PTR [esi+16]
	inc	eax
	push	eax
	mov	eax, DWORD PTR _stepNr$1$[ebp]
	inc	eax
	push	eax
	push	esi
	call	_xmlStreamCtxtAddState
	mov	eax, DWORD PTR _ret$2$[ebp]
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $LN111@xmlStreamP
	test	bl, 32					; 00000020H
	mov	ecx, 1
	cmovne	eax, ecx
	mov	DWORD PTR _ret$2$[ebp], eax
$LN111@xmlStreamP:

; 2068 : 		    /*
; 2069 : 		    * Check if we have a special case like "foo/bar//.", where
; 2070 : 		    * "foo" is selected as well.
; 2071 : 		    */
; 2072 : 		    ret = 1;
; 2073 : 		}
; 2074 : 	    }
; 2075 : 	    if (((comp->flags & XML_STREAM_DESC) == 0) &&

	mov	ebx, DWORD PTR _comp$1$[ebp]
$LN114@xmlStreamP:
	mov	eax, DWORD PTR _final$1$[ebp]
$LN49@xmlStreamP:
	test	DWORD PTR [ebx+16], 65536		; 00010000H
	jne	SHORT $LN118@xmlStreamP
	test	edi, edi
	je	SHORT $LN51@xmlStreamP
	test	eax, eax
	je	SHORT $LN118@xmlStreamP
$LN51@xmlStreamP:

; 2076 : 		((! match) || final))  {
; 2077 : 		/*
; 2078 : 		* Mark this expression as blocked for any evaluation at
; 2079 : 		* deeper levels. Note that this includes "/foo"
; 2080 : 		* expressions if the *pattern* behaviour is used.
; 2081 : 		*/
; 2082 : 		stream->blockLevel = stream->level +1;

	mov	eax, DWORD PTR [esi+16]
	inc	eax
	mov	DWORD PTR [esi+28], eax
	jmp	SHORT $LN118@xmlStreamP
$LN105@xmlStreamP:

; 1986 : 
; 1987 : 		/* skip new states just added */
; 1988 : 		if (tmp > stream->level)

	mov	ebx, DWORD PTR _comp$1$[ebp]
$LN118@xmlStreamP:

; 2083 : 	    }
; 2084 : next_state:
; 2085 : 	    i++;

	mov	ecx, DWORD PTR _m$1$[ebp]
$next_state$125:
	mov	eax, DWORD PTR _i$1$[ebp]
	inc	eax
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, ecx
	jl	$LL4@xmlStreamP
	mov	edi, DWORD PTR _ns$[ebp]
$LN5@xmlStreamP:

; 2086 : 	}
; 2087 : 
; 2088 : 	stream->level++;

	mov	ecx, DWORD PTR [esi+16]
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+16], eax

; 2089 : 
; 2090 : 	/*
; 2091 : 	* Re/enter the expression.
; 2092 : 	* Don't reenter if it's an absolute expression like "/foo",
; 2093 : 	*   except "//foo".
; 2094 : 	*/
; 2095 : 	step = comp->steps[0];

	mov	eax, DWORD PTR [ebx+12]
	movups	xmm0, XMMWORD PTR [eax]

; 2096 : 	if (step.flags & XML_STREAM_STEP_ROOT)

	movd	ebx, xmm0
	movups	XMMWORD PTR _step$[ebp], xmm0
	mov	DWORD PTR _step$10$[ebp], ebx
	test	bl, 4
	jne	SHORT $LN101@xmlStreamP

; 2100 : 	if (stream->flags & XML_PATTERN_NOTPATTERN) {

	mov	eax, DWORD PTR [esi+24]
	test	al, 7
	je	SHORT $compare$126

; 2101 : 	    /*
; 2102 : 	    * Re/enter the expression if it is a "descendant" one,
; 2103 : 	    * or if we are at the 1st level of evaluation.
; 2104 : 	    */
; 2105 : 
; 2106 : 	    if (stream->level == 1) {

	test	ecx, ecx
	jne	SHORT $LN56@xmlStreamP

; 2107 : 		if (XML_STREAM_XS_IDC(stream)) {

	test	al, 6
	je	SHORT $compare$126
$LN101@xmlStreamP:

; 2186 : 	}
; 2187 : 
; 2188 : stream_next:
; 2189 :         stream = stream->next;

	mov	ecx, DWORD PTR _ret$2$[ebp]
$LN120@xmlStreamP:
	mov	edx, DWORD PTR _nodeType$[ebp]
$stream_next$124:
	mov	edi, DWORD PTR _ns$[ebp]
$LN122@xmlStreamP:

; 1869 :         return(-1);
; 1870 : 
; 1871 :     while (stream != NULL) {

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	$LL2@xmlStreamP

; 2190 :     } /* while stream != NULL */
; 2191 : 
; 2192 :     if (err > 0)

	mov	eax, DWORD PTR _err$1$[ebp]
	or	edx, -1
	test	eax, eax
	pop	edi
	cmovg	ecx, edx

; 2193 :         ret = -1;
; 2194 : #ifdef DEBUG_STREAMING
; 2195 :     xmlDebugStreamCtxt(orig, ret);
; 2196 : #endif
; 2197 :     return(ret);
; 2198 : }

	pop	esi
	mov	eax, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN56@xmlStreamP:

; 2097 : 	    goto stream_next;
; 2098 : 
; 2099 : 	desc = step.flags & XML_STREAM_STEP_DESC;

	test	bl, 1

; 2108 : 		    /*
; 2109 : 		    * XS-IDC: The missing "self::node()" will always
; 2110 : 		    * match the first given node.
; 2111 : 		    */
; 2112 : 		    goto stream_next;
; 2113 : 		} else
; 2114 : 		    goto compare;
; 2115 : 	    }
; 2116 : 	    /*
; 2117 : 	    * A "//" is always reentrant.
; 2118 : 	    */
; 2119 : 	    if (desc)

	jne	SHORT $compare$126

; 2120 : 		goto compare;
; 2121 : 
; 2122 : 	    /*
; 2123 : 	    * XS-IDC: Process the 2nd level, since the missing
; 2124 : 	    * "self::node()" is responsible for the 2nd level being
; 2125 : 	    * the real start level.
; 2126 : 	    */
; 2127 : 	    if ((stream->level == 2) && XML_STREAM_XS_IDC(stream))

	cmp	ecx, 1
	jne	SHORT $LN101@xmlStreamP
	test	al, 6
	je	SHORT $LN101@xmlStreamP
$compare$126:

; 2128 : 		goto compare;
; 2129 : 
; 2130 : 	    goto stream_next;
; 2131 : 	}
; 2132 : 
; 2133 : compare:
; 2134 : 	/*
; 2135 : 	* Check expected node-type.
; 2136 : 	*/
; 2137 : 	if (step.nodeType != nodeType) {

	mov	eax, DWORD PTR _step$[ebp+12]
	mov	edx, DWORD PTR _nodeType$[ebp]
	cmp	eax, edx
	je	SHORT $LN62@xmlStreamP

; 2138 : 	    if (nodeType == XML_ATTRIBUTE_NODE)

	cmp	edx, 2
	je	$LN98@xmlStreamP

; 2139 : 		goto stream_next;
; 2140 : 	    else if (step.nodeType != XML_STREAM_ANY_NODE)

	cmp	eax, 100				; 00000064H
	jne	$LN98@xmlStreamP
$LN62@xmlStreamP:

; 2141 : 		goto stream_next;
; 2142 : 	}
; 2143 : 	/*
; 2144 : 	* Compare local/namespace-name.
; 2145 : 	*/
; 2146 : 	match = 0;

	xor	ebx, ebx

; 2147 : 	if (step.nodeType == XML_STREAM_ANY_NODE) {

	cmp	eax, 100				; 00000064H
	jne	SHORT $LN63@xmlStreamP

; 2164 : 	}
; 2165 : 	final = step.flags & XML_STREAM_STEP_FINAL;

	mov	edi, DWORD PTR _step$10$[ebp]
	lea	ebx, DWORD PTR [eax-99]
	and	edi, 2
	mov	DWORD PTR _final$1$[ebp], edi
	jmp	$LN94@xmlStreamP
$LN63@xmlStreamP:

; 2148 : 	    match = 1;
; 2149 : 	} else if (step.name == NULL) {

	mov	edx, DWORD PTR _step$[ebp+4]
	test	edx, edx
	jne	SHORT $LN65@xmlStreamP

; 2150 : 	    if (step.ns == NULL) {

	mov	eax, DWORD PTR _step$[ebp+8]
	test	eax, eax
	jne	SHORT $LN67@xmlStreamP

; 2164 : 	}
; 2165 : 	final = step.flags & XML_STREAM_STEP_FINAL;

	mov	edi, DWORD PTR _step$10$[ebp]
	lea	ebx, DWORD PTR [edx+1]
	and	edi, 2
	mov	DWORD PTR _final$1$[ebp], edi
	jmp	SHORT $LN94@xmlStreamP
$LN67@xmlStreamP:

; 2151 : 		/*
; 2152 : 		* This lets through all elements/attributes.
; 2153 : 		*/
; 2154 : 		match = 1;
; 2155 : 	    } else if (ns != NULL)

	test	edi, edi
	je	SHORT $LN70@xmlStreamP

; 2156 : 		match = xmlStrEqual(step.ns, ns);

	push	edi
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	mov	ebx, eax

; 2157 : 	} else if (((step.ns != NULL) == (ns != NULL)) &&

	jmp	SHORT $LN70@xmlStreamP
$LN65@xmlStreamP:

; 2158 : 	    (name != NULL) &&
; 2159 : 	    (step.name[0] == name[0]) &&
; 2160 : 	    xmlStrEqual(step.name, name) &&

	mov	edi, DWORD PTR _step$[ebp+8]
	xor	ecx, ecx
	test	edi, edi
	setne	cl
	xor	eax, eax
	cmp	DWORD PTR _ns$[ebp], eax
	setne	al
	cmp	ecx, eax
	jne	SHORT $LN70@xmlStreamP
	mov	ecx, DWORD PTR _name$[ebp]
	test	ecx, ecx
	je	SHORT $LN70@xmlStreamP
	mov	al, BYTE PTR [edx]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN70@xmlStreamP
	push	ecx
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN70@xmlStreamP
	mov	eax, DWORD PTR _ns$[ebp]
	cmp	edi, eax
	je	SHORT $LN71@xmlStreamP
	push	eax
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN70@xmlStreamP
$LN71@xmlStreamP:

; 2161 : 	    ((step.ns == ns) || xmlStrEqual(step.ns, ns)))
; 2162 : 	{
; 2163 : 	    match = 1;

	mov	ebx, 1
$LN70@xmlStreamP:

; 2164 : 	}
; 2165 : 	final = step.flags & XML_STREAM_STEP_FINAL;

	mov	edi, DWORD PTR _step$10$[ebp]
	and	edi, 2
	mov	DWORD PTR _final$1$[ebp], edi

; 2166 : 	if (match) {

	test	ebx, ebx
	je	SHORT $LN103@xmlStreamP
$LN94@xmlStreamP:

; 2167 : 	    if (final)

	test	edi, edi
	je	SHORT $LN73@xmlStreamP

; 2168 : 		ret = 1;

	mov	ecx, 1
	mov	DWORD PTR _ret$2$[ebp], ecx
	jmp	SHORT $LN75@xmlStreamP
$LN73@xmlStreamP:

; 2169 : 	    else
; 2170 : 		xmlStreamCtxtAddState(stream, 1, stream->level);

	push	DWORD PTR [esi+16]
	push	1
	push	esi
	call	_xmlStreamCtxtAddState

; 2171 : 	    if ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {

	mov	eax, DWORD PTR _ret$2$[ebp]
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $LN103@xmlStreamP
	test	BYTE PTR _step$10$[ebp], 32		; 00000020H
	mov	ecx, 1
	cmovne	eax, ecx
	mov	DWORD PTR _ret$2$[ebp], eax
$LN103@xmlStreamP:

; 2172 : 		/*
; 2173 : 		* Check if we have a special case like "foo//.", where
; 2174 : 		* "foo" is selected as well.
; 2175 : 		*/
; 2176 : 		ret = 1;
; 2177 : 	    }
; 2178 : 	}
; 2179 : 	if (((comp->flags & XML_STREAM_DESC) == 0) &&

	mov	ecx, DWORD PTR _ret$2$[ebp]
$LN75@xmlStreamP:
	mov	edx, DWORD PTR _comp$1$[ebp]
	test	DWORD PTR [edx+16], 65536		; 00010000H
	jne	$LN120@xmlStreamP
	test	ebx, ebx
	je	SHORT $LN77@xmlStreamP
	test	edi, edi
	je	$LN120@xmlStreamP
$LN77@xmlStreamP:

; 2180 : 	    ((! match) || final))  {
; 2181 : 	    /*
; 2182 : 	    * Mark this expression as blocked for any evaluation at
; 2183 : 	    * deeper levels.
; 2184 : 	    */
; 2185 : 	    stream->blockLevel = stream->level;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+28], eax
	jmp	$LN120@xmlStreamP
$LN7@xmlStreamP:
	pop	edi

; 2193 :         ret = -1;
; 2194 : #ifdef DEBUG_STREAMING
; 2195 :     xmlDebugStreamCtxt(orig, ret);
; 2196 : #endif
; 2197 :     return(ret);
; 2198 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStreamPushInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamCtxtAddState
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_idx$ = 12						; size = 4
_level$ = 16						; size = 4
_xmlStreamCtxtAddState PROC				; COMDAT

; 1814 : xmlStreamCtxtAddState(xmlStreamCtxtPtr comp, int idx, int level) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _comp$[ebp]
	xor	eax, eax
	mov	edx, DWORD PTR [esi+8]
	test	edx, edx
	jle	SHORT $LN3@xmlStreamC

; 1817 :         if (comp->states[2 * i] < 0) {

	mov	edi, DWORD PTR [esi+20]
	npad	2
$LL4@xmlStreamC:
	cmp	DWORD PTR [edi+eax*8], 0
	jl	SHORT $LN10@xmlStreamC

; 1815 :     int i;
; 1816 :     for (i = 0;i < comp->nbState;i++) {

	inc	eax
	cmp	eax, edx
	jl	SHORT $LL4@xmlStreamC
$LN3@xmlStreamC:

; 1820 : 	    return(i);
; 1821 : 	}
; 1822 :     }
; 1823 :     if (comp->nbState >= comp->maxState) {

	mov	eax, DWORD PTR [esi+12]
	cmp	edx, eax
	jl	SHORT $LN15@xmlStreamC

; 1824 :         int *cur;
; 1825 : 
; 1826 : 	cur = (int *) xmlRealloc(comp->states,

	shl	eax, 4
	push	eax
	push	DWORD PTR [esi+20]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1827 : 				 comp->maxState * 4 * sizeof(int));
; 1828 : 	if (cur == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlStreamC

; 1829 : 	    ERROR(NULL, NULL, NULL,
; 1830 : 		  "xmlNewStreamCtxt: malloc failed\n");
; 1831 : 	    return(-1);

	pop	edi
	or	eax, -1

; 1838 :     return(comp->nbState - 1);
; 1839 : }

	pop	esi
	pop	ebp
	ret	0
$LN10@xmlStreamC:

; 1818 : 	    comp->states[2 * i] = idx;

	mov	ecx, DWORD PTR _idx$[ebp]
	mov	DWORD PTR [edi+eax*8], ecx

; 1819 : 	    comp->states[2 * i + 1] = level;

	mov	edx, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR _level$[ebp]
	pop	edi

; 1838 :     return(comp->nbState - 1);
; 1839 : }

	pop	esi
	mov	DWORD PTR [edx+eax*8+4], ecx
	pop	ebp
	ret	0
$LN7@xmlStreamC:

; 1832 : 	}
; 1833 : 	comp->states = cur;
; 1834 :         comp->maxState *= 2;

	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+20], eax
	mov	eax, DWORD PTR [esi+12]
	add	eax, eax
	mov	DWORD PTR [esi+12], eax
$LN15@xmlStreamC:

; 1835 :     }
; 1836 :     comp->states[2 * comp->nbState] = idx;

	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR _idx$[ebp]
	pop	edi
	mov	DWORD PTR [ecx+edx*8], eax

; 1837 :     comp->states[2 * comp->nbState++ + 1] = level;

	mov	edx, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR _level$[ebp]
	mov	DWORD PTR [ecx+edx*8+4], eax
	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+8], ecx

; 1838 :     return(comp->nbState - 1);
; 1839 : }

	pop	esi
	pop	ebp
	ret	0
_xmlStreamCtxtAddState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlNewStreamCtxt
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_xmlNewStreamCtxt PROC					; COMDAT

; 1760 : xmlNewStreamCtxt(xmlStreamCompPtr stream) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN5@xmlNewStre

; 1761 :     xmlStreamCtxtPtr cur;
; 1762 : 
; 1763 :     cur = (xmlStreamCtxtPtr) xmlMalloc(sizeof(xmlStreamCtxt));
; 1764 :     if (cur == NULL) {
; 1765 : 	ERROR(NULL, NULL, NULL,
; 1766 : 		"xmlNewStreamCtxt: malloc failed\n");
; 1767 : 	return(NULL);
; 1768 :     }
; 1769 :     memset(cur, 0, sizeof(xmlStreamCtxt));

	xorps	xmm0, xmm0
	movups	XMMWORD PTR [esi], xmm0

; 1770 :     cur->states = (int *) xmlMalloc(4 * 2 * sizeof(int));

	push	32					; 00000020H
	movups	XMMWORD PTR [esi+16], xmm0
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+20], eax

; 1771 :     if (cur->states == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlNewStre

; 1772 : 	xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlNewStre:

; 1783 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlNewStre:

; 1773 : 	ERROR(NULL, NULL, NULL,
; 1774 : 	      "xmlNewStreamCtxt: malloc failed\n");
; 1775 : 	return(NULL);
; 1776 :     }
; 1777 :     cur->nbState = 0;
; 1778 :     cur->maxState = 4;
; 1779 :     cur->level = 0;
; 1780 :     cur->comp = stream;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [esi+4], eax

; 1781 :     cur->blockLevel = -1;
; 1782 :     return(cur);

	mov	eax, esi
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 4
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+28], -1
	pop	esi

; 1783 : }

	pop	ebp
	ret	0
_xmlNewStreamCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamCompile
_TEXT	SEGMENT
_step$ = -28						; size = 12
_root$1$ = -16						; size = 4
$T1 = -12						; size = 4
_prevs$1$ = -8						; size = 4
_i$1$ = -4						; size = 4
_comp$ = 8						; size = 4
_xmlStreamCompile PROC					; COMDAT

; 1578 : xmlStreamCompile(xmlPatternPtr comp) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _comp$[ebp]
	xor	edi, edi
	or	eax, -1
	mov	DWORD PTR _root$1$[ebp], edi
	xor	ebx, ebx
	mov	DWORD PTR _prevs$1$[ebp], eax
	test	esi, esi
	je	$LN8@xmlStreamC

; 1579 :     xmlStreamCompPtr stream;
; 1580 :     int i, s = 0, root = 0, flags = 0, prevs = -1;
; 1581 :     xmlStepOp step;
; 1582 : 
; 1583 :     if ((comp == NULL) || (comp->steps == NULL))

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	$LN8@xmlStreamC

; 1584 :         return(-1);
; 1585 :     /*
; 1586 :      * special case for .
; 1587 :      */
; 1588 :     if ((comp->nbStep == 1) &&
; 1589 :         (comp->steps[0].op == XML_OP_ELEM) &&
; 1590 : 	(comp->steps[0].value == NULL) &&

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 1
	jne	SHORT $LN9@xmlStreamC
	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN9@xmlStreamC
	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN9@xmlStreamC
	cmp	DWORD PTR [eax+8], ebx
	jne	SHORT $LN9@xmlStreamC

; 1591 : 	(comp->steps[0].value2 == NULL)) {
; 1592 : 	stream = xmlNewStreamComp(0);

	push	ebx
	call	_xmlNewStreamComp
	add	esp, 4

; 1593 : 	if (stream == NULL)

	test	eax, eax
	je	$LN8@xmlStreamC

; 1594 : 	    return(-1);
; 1595 : 	/* Note that the stream will have no steps in this case. */
; 1596 : 	stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;

	or	DWORD PTR [eax+16], 16384		; 00004000H
	pop	edi

; 1597 : 	comp->stream = stream;

	mov	DWORD PTR [esi+32], eax

; 1598 : 	return(0);

	xor	eax, eax

; 1749 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlStreamC:

; 1599 :     }
; 1600 : 
; 1601 :     stream = xmlNewStreamComp((comp->nbStep / 2) + 1);

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	inc	eax
	push	eax
	call	_xmlNewStreamComp
	mov	esi, eax
	add	esp, 4

; 1602 :     if (stream == NULL)

	test	esi, esi
	je	$LN8@xmlStreamC

; 1603 :         return(-1);
; 1604 :     if (comp->dict != NULL) {

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN12@xmlStreamC

; 1605 :         stream->dict = comp->dict;
; 1606 : 	xmlDictReference(stream->dict);

	push	ecx
	mov	DWORD PTR [esi], ecx
	call	_xmlDictReference
	mov	eax, DWORD PTR _comp$[ebp]
	add	esp, 4
$LN12@xmlStreamC:

; 1607 :     }
; 1608 : 
; 1609 :     i = 0;

	xor	edx, edx

; 1610 :     if (comp->flags & PAT_FROM_ROOT)

	test	DWORD PTR [eax+16], 256			; 00000100H
	mov	DWORD PTR _i$1$[ebp], edx
	je	SHORT $LN63@xmlStreamC

; 1611 : 	stream->flags |= XML_STREAM_FROM_ROOT;

	or	DWORD PTR [esi+16], 32768		; 00008000H
$LN63@xmlStreamC:

; 1612 : 
; 1613 :     for (;i < comp->nbStep;i++) {

	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T1[ebp], ecx
	test	ecx, ecx
	jle	$LN68@xmlStreamC
	npad	9
$LL4@xmlStreamC:

; 1614 : 	step = comp->steps[i];

	mov	eax, DWORD PTR [eax+28]
	lea	ecx, DWORD PTR [edx+edx*2]
	movq	xmm0, QWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [eax+ecx*4+8]
	movq	QWORD PTR _step$[ebp], xmm0

; 1615 :         switch (step.op) {

	mov	eax, DWORD PTR _step$[ebp]
	dec	eax
	cmp	eax, 7
	ja	SHORT $LN2@xmlStreamC
	jmp	DWORD PTR $LN73@xmlStreamC[eax*4]
$LN15@xmlStreamC:

; 1616 : 	    case XML_OP_END:
; 1617 : 	        break;
; 1618 : 	    case XML_OP_ROOT:
; 1619 : 	        if (i != 0)

	test	edx, edx
	jne	$error$74

; 1620 : 		    goto error;
; 1621 : 		root = 1;

	mov	DWORD PTR _root$1$[ebp], 1

; 1622 : 		break;

	jmp	SHORT $LN2@xmlStreamC
$LN17@xmlStreamC:

; 1623 : 	    case XML_OP_NS:
; 1624 : 		s = xmlStreamCompAddStep(stream, NULL, step.value,

	push	ebx
	push	1
	push	DWORD PTR _step$[ebp+4]
$LN71@xmlStreamC:

; 1612 : 
; 1613 :     for (;i < comp->nbStep;i++) {

	push	0
$LN70@xmlStreamC:
	push	esi
	call	_xmlStreamCompAddStep
	mov	edi, eax
	add	esp, 20					; 00000014H
	test	edi, edi
	js	$error$74
	mov	DWORD PTR _prevs$1$[ebp], edi
	xor	ebx, ebx
$LN67@xmlStreamC:
	mov	edx, DWORD PTR _i$1$[ebp]
$LN2@xmlStreamC:
	mov	eax, DWORD PTR _comp$[ebp]
	inc	edx
	mov	DWORD PTR _i$1$[ebp], edx
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T1[ebp], ecx
	cmp	edx, ecx
	jl	SHORT $LL4@xmlStreamC

; 1719 : 		break;
; 1720 : 	}
; 1721 :     }
; 1722 :     if ((! root) && (comp->flags & XML_PATTERN_NOTPATTERN) == 0) {

	mov	edx, DWORD PTR _root$1$[ebp]
	test	edx, edx
	jne	$LN40@xmlStreamC

; 1612 : 
; 1613 :     for (;i < comp->nbStep;i++) {

	jmp	$LN62@xmlStreamC
$LN19@xmlStreamC:

; 1625 : 		    XML_ELEMENT_NODE, flags);
; 1626 : 		if (s < 0)
; 1627 : 		    goto error;
; 1628 : 		prevs = s;
; 1629 : 		flags = 0;
; 1630 : 		break;
; 1631 : 	    case XML_OP_ATTR:
; 1632 : 		flags |= XML_STREAM_STEP_ATTR;

	or	ebx, 8

; 1633 : 		prevs = -1;

	or	eax, -1

; 1634 : 		s = xmlStreamCompAddStep(stream,

	push	ebx
	push	2
	push	ecx
	push	DWORD PTR _step$[ebp+4]
	mov	DWORD PTR _prevs$1$[ebp], eax
	push	esi
	call	_xmlStreamCompAddStep
	mov	edi, eax
	add	esp, 20					; 00000014H

; 1635 : 		    step.value, step.value2, XML_ATTRIBUTE_NODE, flags);
; 1636 : 		flags = 0;

	xor	ebx, ebx

; 1637 : 		if (s < 0)

	test	edi, edi
	js	$error$74

; 1638 : 		    goto error;
; 1639 : 		break;

	jmp	SHORT $LN67@xmlStreamC
$LN21@xmlStreamC:

; 1640 : 	    case XML_OP_ELEM:
; 1641 : 	        if ((step.value == NULL) && (step.value2 == NULL)) {

	mov	eax, DWORD PTR _step$[ebp+4]
	test	eax, eax
	jne	SHORT $LN24@xmlStreamC
	test	ecx, ecx
	jne	SHORT $LN24@xmlStreamC

; 1642 : 		    /*
; 1643 : 		    * We have a "." or "self::node()" here.
; 1644 : 		    * Eliminate redundant self::node() tests like in "/./."
; 1645 : 		    * or "//./"
; 1646 : 		    * The only case we won't eliminate is "//.", i.e. if
; 1647 : 		    * self::node() is the last node test and we had
; 1648 : 		    * continuation somewhere beforehand.
; 1649 : 		    */
; 1650 : 		    if ((comp->nbStep == i + 1) &&

	mov	eax, DWORD PTR _i$1$[ebp]
	inc	eax
	cmp	DWORD PTR $T1[ebp], eax
	jne	SHORT $LN67@xmlStreamC
	test	bl, 1
	je	SHORT $LN67@xmlStreamC

; 1651 : 			(flags & XML_STREAM_STEP_DESC)) {
; 1652 : 			/*
; 1653 : 			* Mark the special case where the expression resolves
; 1654 : 			* to any type of node.
; 1655 : 			*/
; 1656 : 			if (comp->nbStep == i + 1) {
; 1657 : 			    stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;

	or	DWORD PTR [esi+16], 16384		; 00004000H

; 1658 : 			}
; 1659 : 			flags |= XML_STREAM_STEP_NODE;

	or	ebx, 16					; 00000010H

; 1660 : 			s = xmlStreamCompAddStep(stream, NULL, NULL,

	push	ebx
	push	100					; 00000064H
	push	ecx
	push	ecx
	push	esi
	call	_xmlStreamCompAddStep
	mov	edi, eax
	add	esp, 20					; 00000014H

; 1661 : 			    XML_STREAM_ANY_NODE, flags);
; 1662 : 			if (s < 0)

	test	edi, edi
	js	$error$74

; 1663 : 			    goto error;
; 1664 : 			flags = 0;
; 1665 : 			/*
; 1666 : 			* If there was a previous step, mark it to be added to
; 1667 : 			* the result node-set; this is needed since only
; 1668 : 			* the last step will be marked as "final" and only
; 1669 : 			* "final" nodes are added to the resulting set.
; 1670 : 			*/
; 1671 : 			if (prevs != -1) {

	mov	ecx, DWORD PTR _prevs$1$[ebp]
	xor	ebx, ebx
	cmp	ecx, -1
	je	$LN67@xmlStreamC

; 1672 : 			    stream->steps[prevs].flags |= XML_STREAM_STEP_IN_SET;

	mov	eax, DWORD PTR [esi+12]
	add	ecx, ecx
	or	DWORD PTR [eax+ecx*8], 32		; 00000020H

; 1673 : 			    prevs = -1;

	or	eax, -1
	mov	DWORD PTR _prevs$1$[ebp], eax

; 1674 : 			}
; 1675 : 			break;

	jmp	$LN67@xmlStreamC
$LN24@xmlStreamC:

; 1676 : 
; 1677 : 		    } else {
; 1678 : 			/* Just skip this one. */
; 1679 : 			continue;
; 1680 : 		    }
; 1681 : 		}
; 1682 : 		/* An element node. */
; 1683 : 	        s = xmlStreamCompAddStep(stream, step.value, step.value2,

	push	ebx
	push	1
	push	ecx
	push	eax

; 1684 : 		    XML_ELEMENT_NODE, flags);
; 1685 : 		if (s < 0)
; 1686 : 		    goto error;
; 1687 : 		prevs = s;
; 1688 : 		flags = 0;
; 1689 : 		break;

	jmp	$LN70@xmlStreamC
$LN29@xmlStreamC:

; 1690 : 	    case XML_OP_CHILD:
; 1691 : 		/* An element node child. */
; 1692 : 	        s = xmlStreamCompAddStep(stream, step.value, step.value2,

	push	ebx
	push	1
	push	ecx
	push	DWORD PTR _step$[ebp+4]

; 1693 : 		    XML_ELEMENT_NODE, flags);
; 1694 : 		if (s < 0)
; 1695 : 		    goto error;
; 1696 : 		prevs = s;
; 1697 : 		flags = 0;
; 1698 : 		break;

	jmp	$LN70@xmlStreamC
$LN31@xmlStreamC:

; 1699 : 	    case XML_OP_ALL:
; 1700 : 	        s = xmlStreamCompAddStep(stream, NULL, NULL,

	push	ebx
	push	1
	push	0

; 1701 : 		    XML_ELEMENT_NODE, flags);
; 1702 : 		if (s < 0)
; 1703 : 		    goto error;
; 1704 : 		prevs = s;
; 1705 : 		flags = 0;
; 1706 : 		break;

	jmp	$LN71@xmlStreamC
$LN34@xmlStreamC:

; 1707 : 	    case XML_OP_PARENT:
; 1708 : 	        break;
; 1709 : 	    case XML_OP_ANCESTOR:
; 1710 : 		/* Skip redundant continuations. */
; 1711 : 		if (flags & XML_STREAM_STEP_DESC)

	test	bl, 1
	jne	$LN2@xmlStreamC

; 1712 : 		    break;
; 1713 : 	        flags |= XML_STREAM_STEP_DESC;
; 1714 : 		/*
; 1715 : 		* Mark the expression as having "//".
; 1716 : 		*/
; 1717 : 		if ((stream->flags & XML_STREAM_DESC) == 0)

	mov	eax, DWORD PTR [esi+16]
	or	ebx, 1
	test	eax, 65536				; 00010000H
	jne	$LN2@xmlStreamC

; 1718 : 		    stream->flags |= XML_STREAM_DESC;

	or	eax, 65536				; 00010000H
	mov	DWORD PTR [esi+16], eax
	jmp	$LN2@xmlStreamC
$LN68@xmlStreamC:

; 1612 : 
; 1613 :     for (;i < comp->nbStep;i++) {

	xor	edx, edx
$LN62@xmlStreamC:

; 1719 : 		break;
; 1720 : 	}
; 1721 :     }
; 1722 :     if ((! root) && (comp->flags & XML_PATTERN_NOTPATTERN) == 0) {

	test	BYTE PTR [eax+16], 7
	jne	SHORT $LN40@xmlStreamC

; 1723 : 	/*
; 1724 : 	* If this should behave like a real pattern, we will mark
; 1725 : 	* the first step as having "//", to be reentrant on every
; 1726 : 	* tree level.
; 1727 : 	*/
; 1728 : 	if ((stream->flags & XML_STREAM_DESC) == 0)

	mov	eax, DWORD PTR [esi+16]
	test	eax, 65536				; 00010000H
	jne	SHORT $LN38@xmlStreamC

; 1729 : 	    stream->flags |= XML_STREAM_DESC;

	or	eax, 65536				; 00010000H
	mov	DWORD PTR [esi+16], eax
$LN38@xmlStreamC:

; 1730 : 
; 1731 : 	if (stream->nbStep > 0) {

	cmp	DWORD PTR [esi+4], 0
	jle	SHORT $LN40@xmlStreamC

; 1732 : 	    if ((stream->steps[0].flags & XML_STREAM_STEP_DESC) == 0)

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [ecx]
	test	al, 1
	jne	SHORT $LN40@xmlStreamC

; 1733 : 		stream->steps[0].flags |= XML_STREAM_STEP_DESC;

	or	eax, 1
	mov	DWORD PTR [ecx], eax
$LN40@xmlStreamC:

; 1734 : 	}
; 1735 :     }
; 1736 :     if (stream->nbStep <= s)

	cmp	DWORD PTR [esi+4], edi
	jg	SHORT $LN41@xmlStreamC
$error$74:

; 1526 :         if (comp->steps != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN46@xmlStreamC

; 1527 : 	    xmlFree(comp->steps);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN46@xmlStreamC:

; 1528 : 	if (comp->dict != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN47@xmlStreamC

; 1529 : 	    xmlDictFree(comp->dict);

	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN47@xmlStreamC:

; 1530 :         xmlFree(comp);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1746 : error:
; 1747 :     xmlFreeStreamComp(stream);
; 1748 :     return(0);

	xor	eax, eax
	pop	edi

; 1749 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@xmlStreamC:

; 1737 : 	goto error;
; 1738 :     stream->steps[s].flags |= XML_STREAM_STEP_FINAL;

	mov	eax, DWORD PTR [esi+12]
	add	edi, edi
	or	DWORD PTR [eax+edi*8], 2

; 1739 :     if (root)

	test	edx, edx
	je	SHORT $LN42@xmlStreamC

; 1740 : 	stream->steps[0].flags |= XML_STREAM_STEP_ROOT;

	mov	eax, DWORD PTR [esi+12]
	or	DWORD PTR [eax], 4
$LN42@xmlStreamC:

; 1741 : #ifdef DEBUG_STREAMING
; 1742 :     xmlDebugStreamComp(stream);
; 1743 : #endif
; 1744 :     comp->stream = stream;

	mov	eax, DWORD PTR _comp$[ebp]
	pop	edi
	mov	DWORD PTR [eax+32], esi

; 1745 :     return(0);

	xor	eax, eax

; 1749 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlStreamC:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN73@xmlStreamC:
	DD	$LN15@xmlStreamC
	DD	$LN21@xmlStreamC
	DD	$LN29@xmlStreamC
	DD	$LN19@xmlStreamC
	DD	$LN2@xmlStreamC
	DD	$LN34@xmlStreamC
	DD	$LN17@xmlStreamC
	DD	$LN31@xmlStreamC
_xmlStreamCompile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamCompAddStep
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_name$ = 12						; size = 4
_ns$ = 16						; size = 4
_nodeType$ = 20						; size = 4
_flags$ = 24						; size = 4
_xmlStreamCompAddStep PROC				; COMDAT

; 1547 :                      const xmlChar *ns, int nodeType, int flags) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+8]
	cmp	edx, eax
	jl	SHORT $LN6@xmlStreamC

; 1548 :     xmlStreamStepPtr cur;
; 1549 : 
; 1550 :     if (comp->nbStep >= comp->maxStep) {
; 1551 : 	cur = (xmlStreamStepPtr) xmlRealloc(comp->steps,

	shl	eax, 5
	push	eax
	push	DWORD PTR [esi+12]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1552 : 				 comp->maxStep * 2 * sizeof(xmlStreamStep));
; 1553 : 	if (cur == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlStreamC

; 1554 : 	    ERROR(NULL, NULL, NULL,
; 1555 : 		  "xmlNewStreamComp: malloc failed\n");
; 1556 : 	    return(-1);

	or	eax, -1
	pop	esi

; 1567 : }

	pop	ebp
	ret	0
$LN3@xmlStreamC:

; 1557 : 	}
; 1558 : 	comp->steps = cur;
; 1559 :         comp->maxStep *= 2;

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [esi+8]
	add	eax, eax
	mov	DWORD PTR [esi+8], eax
$LN6@xmlStreamC:

; 1560 :     }
; 1561 :     cur = &comp->steps[comp->nbStep++];

	mov	ecx, edx
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [esi+4], eax

; 1562 :     cur->flags = flags;

	mov	eax, DWORD PTR _flags$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx], eax

; 1563 :     cur->name = name;

	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1564 :     cur->ns = ns;

	mov	eax, DWORD PTR _ns$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1565 :     cur->nodeType = nodeType;

	mov	eax, DWORD PTR _nodeType$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1566 :     return(comp->nbStep - 1);

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	pop	esi

; 1567 : }

	pop	ebp
	ret	0
_xmlStreamCompAddStep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlNewStreamComp
_TEXT	SEGMENT
_size$ = 8						; size = 4
_xmlNewStreamComp PROC					; COMDAT

; 1492 : xmlNewStreamComp(int size) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, 4
	cmp	DWORD PTR _size$[ebp], edi
	push	20					; 00000014H
	cmovge	edi, DWORD PTR _size$[ebp]
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN6@xmlNewStre

; 1493 :     xmlStreamCompPtr cur;
; 1494 : 
; 1495 :     if (size < 4)
; 1496 :         size  = 4;
; 1497 : 
; 1498 :     cur = (xmlStreamCompPtr) xmlMalloc(sizeof(xmlStreamComp));
; 1499 :     if (cur == NULL) {
; 1500 : 	ERROR(NULL, NULL, NULL,
; 1501 : 		"xmlNewStreamComp: malloc failed\n");
; 1502 : 	return(NULL);
; 1503 :     }
; 1504 :     memset(cur, 0, sizeof(xmlStreamComp));
; 1505 :     cur->steps = (xmlStreamStepPtr) xmlMalloc(size * sizeof(xmlStreamStep));

	mov	eax, edi
	xorps	xmm0, xmm0
	shl	eax, 4
	movups	XMMWORD PTR [esi], xmm0
	push	eax
	mov	DWORD PTR [esi+16], 0
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+12], eax

; 1506 :     if (cur->steps == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlNewStre

; 1507 : 	xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlNewStre:

; 1515 : }

	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlNewStre:

; 1508 : 	ERROR(NULL, NULL, NULL,
; 1509 : 	      "xmlNewStreamComp: malloc failed\n");
; 1510 : 	return(NULL);
; 1511 :     }
; 1512 :     cur->nbStep = 0;
; 1513 :     cur->maxStep = size;

	mov	DWORD PTR [esi+8], edi

; 1514 :     return(cur);

	mov	eax, esi
	pop	edi
	mov	DWORD PTR [esi+4], 0

; 1515 : }

	pop	esi
	pop	ebp
	ret	0
_xmlNewStreamComp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlCompileIDCXPathPath
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlCompileIDCXPathPath PROC				; COMDAT

; 1330 : xmlCompileIDCXPathPath(xmlPatParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi]
$LL2@xmlCompile:

; 1331 :     SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN17@xmlCompile
	cmp	al, 9
	jb	SHORT $LN18@xmlCompile
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN17@xmlCompile
$LN18@xmlCompile:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN3@xmlCompile
$LN17@xmlCompile:
	test	al, al
	je	SHORT $LL2@xmlCompile
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL2@xmlCompile
$LN3@xmlCompile:

; 1332 :     if (CUR == '/') {

	cmp	al, 47					; 0000002fH
	je	$error$144

; 1333 : 	ERROR5(NULL, NULL, NULL,
; 1334 : 	    "Unexpected selection of the document root in '%s'.\n",
; 1335 : 	    ctxt->base);
; 1336 : 	goto error;
; 1337 :     }
; 1338 :     ctxt->comp->flags |= PAT_FROM_CUR;

	mov	eax, DWORD PTR [esi+16]
	or	DWORD PTR [eax+16], 512			; 00000200H

; 1339 : 
; 1340 :     if (CUR == '.') {

	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx], 46			; 0000002eH
	jne	$LN76@xmlCompile
$LN139@xmlCompile:

; 1341 : 	/* "." - "self::node()" */
; 1342 : 	NEXT;
; 1343 : 	SKIP_BLANKS;

	inc	ecx
	mov	DWORD PTR [esi], ecx
	npad	1
$LL4@xmlCompile:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN21@xmlCompile
	cmp	al, 9
	jb	SHORT $LN22@xmlCompile
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN21@xmlCompile
$LN22@xmlCompile:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN5@xmlCompile
$LN21@xmlCompile:
	test	al, al
	je	SHORT $LL4@xmlCompile
	jmp	SHORT $LN139@xmlCompile
$LN5@xmlCompile:

; 1344 : 	if (CUR == 0) {

	test	al, al
	jne	SHORT $LN23@xmlCompile

; 1345 : 	    /*
; 1346 : 	    * Selection of the context node.
; 1347 : 	    */
; 1348 : 	    PUSH(XML_OP_ELEM, NULL, NULL);

	push	0
	push	0
	push	2
	push	DWORD PTR [esi+16]
	push	esi
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$error$144

; 1405 : 	ERROR5(NULL, NULL, NULL,
; 1406 : 	    "Failed to compile expression '%s'.\n", ctxt->base);
; 1407 : 	ctxt->error = 1;
; 1408 :     }
; 1409 :     return;
; 1410 : error:
; 1411 :     ctxt->error = 1;
; 1412 :     return;
; 1413 : 
; 1414 : error_unfinished:
; 1415 :     ctxt->error = 1;
; 1416 :     ERROR5(NULL, NULL, NULL,
; 1417 : 	"Unfinished expression '%s'.\n", ctxt->base);
; 1418 :     return;
; 1419 : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN23@xmlCompile:

; 1349 : 	    return;
; 1350 : 	}
; 1351 : 	if (CUR != '/') {

	cmp	al, 47					; 0000002fH
	jne	$error$144
$LN140@xmlCompile:

; 1352 : 	    /* TODO: A more meaningful error message. */
; 1353 : 	    ERROR5(NULL, NULL, NULL,
; 1354 : 	    "Unexpected token after '.' in '%s'.\n", ctxt->base);
; 1355 : 	    goto error;
; 1356 : 	}
; 1357 : 	/* "./" - "self::node()/" */
; 1358 : 	NEXT;
; 1359 : 	SKIP_BLANKS;

	inc	ecx
	mov	DWORD PTR [esi], ecx
$LL6@xmlCompile:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN26@xmlCompile
	cmp	al, 9
	jb	SHORT $LN27@xmlCompile
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN26@xmlCompile
$LN27@xmlCompile:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN7@xmlCompile
$LN26@xmlCompile:
	test	al, al
	je	SHORT $LL6@xmlCompile
	jmp	SHORT $LN140@xmlCompile
$LN7@xmlCompile:

; 1360 : 	if (CUR == '/') {

	cmp	al, 47					; 0000002fH
	jne	SHORT $LN134@xmlCompile

; 1361 : 	    if (IS_BLANK_CH(PEEKPREV(1))) {

	mov	al, BYTE PTR [ecx-1]
	cmp	al, 32					; 00000020H
	je	$error$144
	cmp	al, 9
	jb	SHORT $LN31@xmlCompile
	cmp	al, 10					; 0000000aH
	jbe	$error$144
$LN31@xmlCompile:
	cmp	al, 13					; 0000000dH
	je	$error$144

; 1362 : 		/*
; 1363 : 		* Disallow "./ /"
; 1364 : 		*/
; 1365 : 		ERROR5(NULL, NULL, NULL,
; 1366 : 		    "Unexpected '/' token in '%s'.\n", ctxt->base);
; 1367 : 		goto error;
; 1368 : 	    }
; 1369 : 	    /* ".//" - "self:node()/descendant-or-self::node()/" */
; 1370 : 	    PUSH(XML_OP_ANCESTOR, NULL, NULL);

	push	0
	push	0
	push	6
	push	DWORD PTR [esi+16]
	push	esi
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$error$144

; 1371 : 	    NEXT;

	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx], al
$LN141@xmlCompile:

; 1372 : 	    SKIP_BLANKS;

	je	SHORT $LL8@xmlCompile
	inc	ecx
	mov	DWORD PTR [esi], ecx
$LL8@xmlCompile:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN33@xmlCompile
	cmp	al, 9
	jb	SHORT $LN34@xmlCompile
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN33@xmlCompile
$LN34@xmlCompile:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN134@xmlCompile
$LN33@xmlCompile:
	test	al, al
	jmp	SHORT $LN141@xmlCompile
$LN134@xmlCompile:

; 1373 : 	}
; 1374 : 	if (CUR == 0)

	test	al, al
	je	$error$144
$LN76@xmlCompile:

; 1375 : 	    goto error_unfinished;
; 1376 :     }
; 1377 :     /*
; 1378 :     * Process steps.
; 1379 :     */
; 1380 :     do {
; 1381 : 	xmlCompileStepPattern(ctxt);

	push	esi
	call	_xmlCompileStepPattern
	add	esp, 4

; 1382 : 	if (ctxt->error != 0)

	cmp	DWORD PTR [esi+8], 0
	jne	$error$144
$LL12@xmlCompile:
	mov	ecx, DWORD PTR [esi]
$LL13@xmlCompile:

; 1383 : 	    goto error;
; 1384 : 	SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN37@xmlCompile
	cmp	al, 9
	jb	SHORT $LN38@xmlCompile
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN37@xmlCompile
$LN38@xmlCompile:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN14@xmlCompile
$LN37@xmlCompile:
	test	al, al
	je	SHORT $LL13@xmlCompile
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL13@xmlCompile
$LN14@xmlCompile:

; 1385 : 	if (CUR != '/')

	cmp	al, 47					; 0000002fH
	jne	$LN11@xmlCompile

; 1386 : 	    break;
; 1387 : 	PUSH(XML_OP_PARENT, NULL, NULL);

	mov	edi, DWORD PTR [esi+16]

; 351  :     if (comp->nbStep >= comp->maxStep) {

	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [edi+24]
	cmp	eax, ecx
	jl	SHORT $LN124@xmlCompile

; 352  :         xmlStepOpPtr temp;
; 353  : 	temp = (xmlStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *

	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 3
	push	eax
	push	DWORD PTR [edi+28]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 354  : 	                                 sizeof(xmlStepOp));
; 355  :         if (temp == NULL) {

	test	eax, eax
	je	$error$144

; 356  : 	    ERROR(ctxt, NULL, NULL,
; 357  : 			     "xmlPatternAdd: realloc failed\n");
; 358  : 	    return (-1);
; 359  : 	}
; 360  : 	comp->steps = temp;

	mov	DWORD PTR [edi+28], eax

; 361  : 	comp->maxStep *= 2;

	mov	eax, DWORD PTR [edi+24]
	add	eax, eax
	mov	DWORD PTR [edi+24], eax
	mov	eax, DWORD PTR [edi+20]
$LN124@xmlCompile:

; 362  :     }
; 363  :     comp->steps[comp->nbStep].op = op;

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [eax+ecx*4], 5

; 364  :     comp->steps[comp->nbStep].value = value;

	mov	eax, DWORD PTR [edi+20]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [eax+ecx*4+4], 0

; 365  :     comp->steps[comp->nbStep].value2 = value2;

	mov	eax, DWORD PTR [edi+20]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [eax+ecx*4+8], 0

; 366  :     comp->nbStep++;

	inc	DWORD PTR [edi+20]

; 1388 : 	NEXT;

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 0
$LN142@xmlCompile:

; 1389 : 	SKIP_BLANKS;

	je	SHORT $LL15@xmlCompile
	inc	eax
	mov	DWORD PTR [esi], eax
	npad	5
$LL15@xmlCompile:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN41@xmlCompile
	cmp	cl, 9
	jb	SHORT $LN42@xmlCompile
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN41@xmlCompile
$LN42@xmlCompile:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN16@xmlCompile
$LN41@xmlCompile:
	test	cl, cl
	jmp	SHORT $LN142@xmlCompile
$LN16@xmlCompile:

; 1390 : 	if (CUR == '/') {

	cmp	cl, 47					; 0000002fH
	je	SHORT $error$144

; 1391 : 	    /*
; 1392 : 	    * Disallow subsequent '//'.
; 1393 : 	    */
; 1394 : 	    ERROR5(NULL, NULL, NULL,
; 1395 : 		"Unexpected subsequent '//' in '%s'.\n",
; 1396 : 		ctxt->base);
; 1397 : 	    goto error;
; 1398 : 	}
; 1399 : 	if (CUR == 0)

	test	cl, cl
	je	SHORT $error$144

; 1375 : 	    goto error_unfinished;
; 1376 :     }
; 1377 :     /*
; 1378 :     * Process steps.
; 1379 :     */
; 1380 :     do {
; 1381 : 	xmlCompileStepPattern(ctxt);

	push	esi
	call	_xmlCompileStepPattern
	add	esp, 4

; 1382 : 	if (ctxt->error != 0)

	cmp	DWORD PTR [esi+8], 0
	je	$LL12@xmlCompile
$error_unfinished$145:
	pop	edi

; 1405 : 	ERROR5(NULL, NULL, NULL,
; 1406 : 	    "Failed to compile expression '%s'.\n", ctxt->base);
; 1407 : 	ctxt->error = 1;
; 1408 :     }
; 1409 :     return;
; 1410 : error:
; 1411 :     ctxt->error = 1;
; 1412 :     return;
; 1413 : 
; 1414 : error_unfinished:
; 1415 :     ctxt->error = 1;
; 1416 :     ERROR5(NULL, NULL, NULL,
; 1417 : 	"Unfinished expression '%s'.\n", ctxt->base);
; 1418 :     return;
; 1419 : }

	mov	DWORD PTR [esi+8], 1
	pop	esi
	pop	ebp
	ret	0
$LN11@xmlCompile:

; 1400 : 	    goto error_unfinished;
; 1401 : 
; 1402 :     } while (CUR != 0);
; 1403 : 
; 1404 :     if (CUR != 0) {

	test	al, al
	je	SHORT $LN45@xmlCompile
$error$144:
$error_unfinished_1$146:

; 1405 : 	ERROR5(NULL, NULL, NULL,
; 1406 : 	    "Failed to compile expression '%s'.\n", ctxt->base);
; 1407 : 	ctxt->error = 1;
; 1408 :     }
; 1409 :     return;
; 1410 : error:
; 1411 :     ctxt->error = 1;
; 1412 :     return;
; 1413 : 
; 1414 : error_unfinished:
; 1415 :     ctxt->error = 1;
; 1416 :     ERROR5(NULL, NULL, NULL,
; 1417 : 	"Unfinished expression '%s'.\n", ctxt->base);
; 1418 :     return;
; 1419 : }

	mov	DWORD PTR [esi+8], 1
$LN45@xmlCompile:
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlCompileIDCXPathPath ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlCompilePathPattern
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlCompilePathPattern PROC				; COMDAT

; 1233 : xmlCompilePathPattern(xmlPatParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __69230394_pattern@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR [esi]
$LL2@xmlCompile:

; 1234 :     SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN18@xmlCompile
	cmp	al, 9
	jb	SHORT $LN19@xmlCompile
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN18@xmlCompile
$LN19@xmlCompile:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN3@xmlCompile
$LN18@xmlCompile:
	test	al, al
	je	SHORT $LL2@xmlCompile
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL2@xmlCompile
$LN3@xmlCompile:

; 1235 :     if (CUR == '/') {

	cmp	al, 47					; 0000002fH
	jne	SHORT $LN20@xmlCompile

; 1236 :         ctxt->comp->flags |= PAT_FROM_ROOT;

	mov	eax, DWORD PTR [esi+16]
	or	DWORD PTR [eax+16], 256			; 00000100H
	jmp	SHORT $LN22@xmlCompile
$LN20@xmlCompile:

; 1237 :     } else if ((CUR == '.') || (ctxt->comp->flags & XML_PATTERN_NOTPATTERN)) {

	cmp	al, 46					; 0000002eH
	je	SHORT $LN147@xmlCompile
	mov	eax, DWORD PTR [esi+16]
	test	BYTE PTR [eax+16], 7
	je	SHORT $LN22@xmlCompile
$LN147@xmlCompile:

; 1238 :         ctxt->comp->flags |= PAT_FROM_CUR;

	mov	eax, DWORD PTR [esi+16]
	or	DWORD PTR [eax+16], 512			; 00000200H
$LN22@xmlCompile:

; 1239 :     }
; 1240 : 
; 1241 :     if ((CUR == '/') && (NXT(1) == '/')) {

	mov	edx, DWORD PTR [esi]
	mov	cl, BYTE PTR [edx]
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN149@xmlCompile
	cmp	BYTE PTR [edx+1], cl
	jne	SHORT $LN149@xmlCompile

; 1242 : 	PUSH(XML_OP_ANCESTOR, NULL, NULL);

	push	0
	push	0
	push	6
	push	DWORD PTR [esi+16]
	push	esi
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$error$185

; 1243 : 	NEXT;

	mov	eax, DWORD PTR [esi]
	mov	cl, BYTE PTR [eax]
	test	cl, cl
	je	SHORT $LN63@xmlCompile
	inc	eax
	mov	DWORD PTR [esi], eax
	mov	cl, BYTE PTR [eax]

; 1244 : 	NEXT;

	test	cl, cl
	je	SHORT $LN63@xmlCompile
	inc	eax
	mov	DWORD PTR [esi], eax
$LN63@xmlCompile:

; 1245 :     } else if ((CUR == '.') && (NXT(1) == '/') && (NXT(2) == '/')) {

	mov	cl, BYTE PTR [eax]
	jmp	SHORT $LN31@xmlCompile
$LN149@xmlCompile:
	mov	bl, cl
	mov	eax, edx
	cmp	cl, 46					; 0000002eH
	jne	SHORT $LN31@xmlCompile
	cmp	BYTE PTR [edx+1], 47			; 0000002fH
	jne	SHORT $LN31@xmlCompile
	cmp	BYTE PTR [edx+2], 47			; 0000002fH
	jne	SHORT $LN31@xmlCompile

; 1246 : 	PUSH(XML_OP_ANCESTOR, NULL, NULL);

	push	0
	push	0
	push	6
	push	DWORD PTR [esi+16]
	push	esi
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$error$185

; 1247 : 	NEXT;

	mov	eax, DWORD PTR [esi]
	mov	cl, BYTE PTR [eax]
	test	cl, cl
	je	SHORT $LL4@xmlCompile
	inc	eax
	mov	DWORD PTR [esi], eax
	mov	cl, BYTE PTR [eax]

; 1248 : 	NEXT;

	test	cl, cl
	je	SHORT $LL4@xmlCompile
	inc	eax
	mov	DWORD PTR [esi], eax
	mov	cl, BYTE PTR [eax]
$LN29@xmlCompile:

; 1249 : 	NEXT;
; 1250 : 	/* Check for incompleteness. */
; 1251 : 	SKIP_BLANKS;

	test	cl, cl
	je	SHORT $LL4@xmlCompile
	inc	eax
	mov	DWORD PTR [esi], eax
$LL4@xmlCompile:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN29@xmlCompile
	cmp	cl, 9
	jb	SHORT $LN30@xmlCompile
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN29@xmlCompile
$LN30@xmlCompile:
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN29@xmlCompile

; 1252 : 	if (CUR == 0) {

	test	cl, cl
	je	$LN158@xmlCompile
$LN31@xmlCompile:

; 1253 : 	    ERROR5(NULL, NULL, NULL,
; 1254 : 	       "Incomplete expression '%s'.\n", ctxt->base);
; 1255 : 	    ctxt->error = 1;
; 1256 : 	    goto error;
; 1257 : 	}
; 1258 :     }
; 1259 :     if (CUR == '@') {

	cmp	cl, 64					; 00000040H
	jne	SHORT $LN32@xmlCompile

; 1260 : 	NEXT;

	test	cl, cl
	je	SHORT $LN152@xmlCompile
	inc	eax
	mov	DWORD PTR [esi], eax
$LN152@xmlCompile:

; 1261 : 	xmlCompileAttributeTest(ctxt);

	push	esi
	call	_xmlCompileAttributeTest
	mov	ecx, DWORD PTR [esi]
	add	esp, 4
$LL6@xmlCompile:

; 1262 : 	SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN34@xmlCompile
	cmp	al, 9
	jb	SHORT $LN35@xmlCompile
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN34@xmlCompile
$LN35@xmlCompile:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN7@xmlCompile
$LN34@xmlCompile:
	test	al, al
	je	SHORT $LL6@xmlCompile
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL6@xmlCompile
$LN7@xmlCompile:

; 1263 : 	/* TODO: check for incompleteness */
; 1264 : 	if (CUR != 0) {

	test	al, al
	je	SHORT $LN37@xmlCompile

; 1265 : 	    xmlCompileStepPattern(ctxt);

	push	esi
	call	_xmlCompileStepPattern
	add	esp, 4

; 1266 : 	    if (ctxt->error != 0)

	cmp	DWORD PTR [esi+8], 0
	jne	$error$185
$LN37@xmlCompile:

; 1267 : 		goto error;
; 1268 : 	}
; 1269 :     } else {

	mov	eax, DWORD PTR [esi]
	mov	cl, BYTE PTR [eax]
	jmp	$LN13@xmlCompile
$LN32@xmlCompile:

; 1270 :         if (CUR == '/') {

	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN42@xmlCompile

; 1271 : 	    PUSH(XML_OP_ROOT, NULL, NULL);

	push	0
	push	0
	push	1
	push	DWORD PTR [esi+16]
	push	esi
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$error$185

; 1272 : 	    NEXT;

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 0
$LN178@xmlCompile:

; 1273 : 	    /* Check for incompleteness. */
; 1274 : 	    SKIP_BLANKS;

	je	SHORT $LL8@xmlCompile
	inc	eax
	mov	DWORD PTR [esi], eax
	npad	4
$LL8@xmlCompile:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN40@xmlCompile
	cmp	cl, 9
	jb	SHORT $LN41@xmlCompile
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN40@xmlCompile
$LN41@xmlCompile:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN9@xmlCompile
$LN40@xmlCompile:
	test	cl, cl
	jmp	SHORT $LN178@xmlCompile
$LN9@xmlCompile:

; 1275 : 	    if (CUR == 0) {

	test	cl, cl
	je	$LN158@xmlCompile
$LN42@xmlCompile:

; 1276 : 		ERROR5(NULL, NULL, NULL,
; 1277 : 		    "Incomplete expression '%s'.\n", ctxt->base);
; 1278 : 		ctxt->error = 1;
; 1279 : 		goto error;
; 1280 : 	    }
; 1281 : 	}
; 1282 : 	xmlCompileStepPattern(ctxt);

	push	esi
	call	_xmlCompileStepPattern
	add	esp, 4

; 1283 : 	if (ctxt->error != 0)

	cmp	DWORD PTR [esi+8], 0
	jne	$error$185

; 1237 :     } else if ((CUR == '.') || (ctxt->comp->flags & XML_PATTERN_NOTPATTERN)) {

	mov	eax, DWORD PTR [esi]
$LL10@xmlCompile:

; 1284 : 	    goto error;
; 1285 : 	SKIP_BLANKS;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN44@xmlCompile
	cmp	cl, 9
	jb	SHORT $LN45@xmlCompile
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN44@xmlCompile
$LN45@xmlCompile:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN99@xmlCompile
$LN44@xmlCompile:
	test	cl, cl
	je	SHORT $LL10@xmlCompile
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL10@xmlCompile
$LN99@xmlCompile:

; 1286 : 	while (CUR == '/') {

	cmp	cl, 47					; 0000002fH
	jne	$LN13@xmlCompile
	npad	1
$LL12@xmlCompile:

; 1287 : 	    if (NXT(1) == '/') {

	cmp	BYTE PTR [eax+1], 47			; 0000002fH
	mov	ecx, DWORD PTR [esi+16]
	push	0
	push	0
	jne	SHORT $LN46@xmlCompile

; 1288 : 	        PUSH(XML_OP_ANCESTOR, NULL, NULL);

	push	6
	push	ecx
	push	esi
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$error$185

; 1289 : 		NEXT;

	mov	eax, DWORD PTR [esi]
	mov	cl, BYTE PTR [eax]
	test	cl, cl
	je	SHORT $LL14@xmlCompile
	inc	eax
	mov	DWORD PTR [esi], eax
	mov	cl, BYTE PTR [eax]
$LN49@xmlCompile:

; 1290 : 		NEXT;
; 1291 : 		SKIP_BLANKS;

	test	cl, cl
	je	SHORT $LL14@xmlCompile
	inc	eax
	mov	DWORD PTR [esi], eax
$LL14@xmlCompile:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN49@xmlCompile
	cmp	cl, 9
	jb	SHORT $LN50@xmlCompile
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN49@xmlCompile
$LN50@xmlCompile:
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN49@xmlCompile

; 1292 : 		xmlCompileStepPattern(ctxt);
; 1293 : 		if (ctxt->error != 0)
; 1294 : 		    goto error;
; 1295 : 	    } else {

	jmp	SHORT $LN182@xmlCompile
$LN46@xmlCompile:

; 1296 : 	        PUSH(XML_OP_PARENT, NULL, NULL);

	push	5
	push	ecx
	push	esi
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $error$185

; 1297 : 		NEXT;

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 0
$LN183@xmlCompile:

; 1298 : 		SKIP_BLANKS;

	je	SHORT $LL16@xmlCompile
	inc	eax
	mov	DWORD PTR [esi], eax
$LL16@xmlCompile:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN53@xmlCompile
	cmp	cl, 9
	jb	SHORT $LN54@xmlCompile
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN53@xmlCompile
$LN54@xmlCompile:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN17@xmlCompile
$LN53@xmlCompile:
	test	cl, cl
	jmp	SHORT $LN183@xmlCompile
$LN17@xmlCompile:

; 1299 : 		if (CUR == 0) {

	test	cl, cl
	je	SHORT $LN158@xmlCompile
$LN182@xmlCompile:

; 1286 : 	while (CUR == '/') {

	push	esi
	call	_xmlCompileStepPattern
	add	esp, 4
	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $error$185
	mov	eax, DWORD PTR [esi]
	mov	cl, BYTE PTR [eax]
	cmp	cl, 47					; 0000002fH
	je	$LL12@xmlCompile
$LN13@xmlCompile:

; 1300 : 		    ERROR5(NULL, NULL, NULL,
; 1301 : 		    "Incomplete expression '%s'.\n", ctxt->base);
; 1302 : 		    ctxt->error = 1;
; 1303 : 		    goto error;
; 1304 : 		}
; 1305 : 		xmlCompileStepPattern(ctxt);
; 1306 : 		if (ctxt->error != 0)
; 1307 : 		    goto error;
; 1308 : 	    }
; 1309 : 	}
; 1310 :     }
; 1311 :     if (CUR != 0) {

	test	cl, cl
	je	SHORT $error$185
$LN158@xmlCompile:

; 1312 : 	ERROR5(NULL, NULL, NULL,
; 1313 : 	       "Failed to compile pattern %s\n", ctxt->base);
; 1314 : 	ctxt->error = 1;
; 1315 :     }
; 1316 : error:
; 1317 :     return;
; 1318 : }

	mov	DWORD PTR [esi+8], 1
$error$185:
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlCompilePathPattern ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlCompileStepPattern
_TEXT	SEGMENT
_token$1$ = -4						; size = 4
_URL$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlCompileStepPattern PROC				; COMDAT

; 1014 : xmlCompileStepPattern(xmlPatParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR [esi]
	xor	ebx, ebx
	mov	DWORD PTR _URL$1$[ebp], 0
	npad	2
$LL2@xmlCompile:

; 1015 :     xmlChar *token = NULL;
; 1016 :     xmlChar *name = NULL;
; 1017 :     xmlChar *URL = NULL;
; 1018 :     int hasBlanks = 0;
; 1019 : 
; 1020 :     SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN12@xmlCompile
	cmp	al, 9
	jb	SHORT $LN13@xmlCompile
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN12@xmlCompile
$LN13@xmlCompile:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN3@xmlCompile
$LN12@xmlCompile:
	test	al, al
	je	SHORT $LL2@xmlCompile
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL2@xmlCompile
$LN3@xmlCompile:

; 1021 :     if (CUR == '.') {

	cmp	al, 46					; 0000002eH
	jne	SHORT $LN14@xmlCompile

; 1022 : 	/*
; 1023 : 	* Context node.
; 1024 : 	*/
; 1025 : 	NEXT;

	test	al, al
	je	SHORT $LN98@xmlCompile
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi], eax
$LN98@xmlCompile:

; 1026 : 	PUSH(XML_OP_ELEM, NULL, NULL);

	push	0
	push	0
	push	2
	push	DWORD PTR [esi+16]
	push	esi
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	pop	esi

; 1221 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlCompile:

; 1027 : 	return;
; 1028 :     }
; 1029 :     if (CUR == '@') {

	cmp	al, 64					; 00000040H
	jne	SHORT $LN16@xmlCompile

; 1030 : 	/*
; 1031 : 	* Attribute test.
; 1032 : 	*/
; 1033 : 	if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {

	mov	eax, DWORD PTR [esi+16]
	test	BYTE PTR [eax+16], 2
	je	SHORT $LN17@xmlCompile

; 1034 : 	    ERROR5(NULL, NULL, NULL,
; 1035 : 		"Unexpected attribute axis in '%s'.\n", ctxt->base);
; 1036 : 	    ctxt->error = 1;

	mov	DWORD PTR [esi+8], 1
	pop	esi

; 1221 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlCompile:

; 1037 : 	    return;
; 1038 : 	}
; 1039 : 	NEXT;

	lea	eax, DWORD PTR [ecx+1]

; 1040 : 	xmlCompileAttributeTest(ctxt);

	push	esi
	mov	DWORD PTR [esi], eax
	call	_xmlCompileAttributeTest
	add	esp, 4
	pop	esi

; 1221 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlCompile:
	push	edi

; 1041 : 	if (ctxt->error != 0)
; 1042 : 	    goto error;
; 1043 : 	return;
; 1044 :     }
; 1045 :     name = xmlPatScanNCName(ctxt);

	push	esi
	call	_xmlPatScanNCName
	mov	edx, DWORD PTR [esi]
	mov	edi, eax
	add	esp, 4
	mov	al, BYTE PTR [edx]

; 1046 :     if (name == NULL) {

	test	edi, edi
	jne	SHORT $LN21@xmlCompile

; 1047 : 	if (CUR == '*') {

	cmp	al, 42					; 0000002aH
	jne	$LN55@xmlCompile

; 1048 : 	    NEXT;
; 1049 : 	    PUSH(XML_OP_ALL, NULL, NULL);

	push	edi
	push	edi
	push	8
	push	DWORD PTR [esi+16]
	lea	eax, DWORD PTR [edx+1]
	push	esi
	mov	DWORD PTR [esi], eax
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi

; 1221 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlCompile:

; 1050 : 	    return;
; 1051 : 	} else {
; 1052 : 	    ERROR(NULL, NULL, NULL,
; 1053 : 		    "xmlCompileStepPattern : Name expected\n");
; 1054 : 	    ctxt->error = 1;
; 1055 : 	    return;
; 1056 : 	}
; 1057 :     }
; 1058 :     if (IS_BLANK_CH(CUR)) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN24@xmlCompile
	cmp	al, 9
	jb	SHORT $LN25@xmlCompile
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN24@xmlCompile
$LN25@xmlCompile:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN142@xmlCompile
$LN24@xmlCompile:

; 1059 : 	hasBlanks = 1;

	mov	ebx, 1
	npad	5
$LL4@xmlCompile:

; 1060 : 	SKIP_BLANKS;

	mov	cl, al
	cmp	cl, 32					; 00000020H
	je	SHORT $LN26@xmlCompile
	cmp	cl, 9
	jb	SHORT $LN27@xmlCompile
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN26@xmlCompile
$LN27@xmlCompile:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN142@xmlCompile
$LN26@xmlCompile:
	mov	eax, edx
	test	cl, cl
	je	SHORT $LN104@xmlCompile
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [esi], eax
$LN104@xmlCompile:
	mov	edx, eax
	mov	al, BYTE PTR [eax]
	jmp	SHORT $LL4@xmlCompile
$LN142@xmlCompile:

; 1061 :     }
; 1062 :     if (CUR == ':') {

	cmp	al, 58					; 0000003aH
	jne	$LN28@xmlCompile

; 1063 : 	NEXT;

	test	al, al
	je	SHORT $LN139@xmlCompile
	inc	edx
	mov	DWORD PTR [esi], edx
	mov	al, BYTE PTR [edx]
$LN139@xmlCompile:

; 1064 : 	if (CUR != ':') {

	cmp	al, 58					; 0000003aH
	je	$LN30@xmlCompile

; 1065 : 	    xmlChar *prefix = name;
; 1066 : 	    int i;
; 1067 : 
; 1068 : 	    if (hasBlanks || IS_BLANK_CH(CUR)) {

	test	ebx, ebx
	jne	$LN34@xmlCompile
	cmp	al, 32					; 00000020H
	je	$LN34@xmlCompile
	cmp	al, 9
	jb	SHORT $LN35@xmlCompile
	cmp	al, 10					; 0000000aH
	jbe	$LN34@xmlCompile
$LN35@xmlCompile:
	cmp	al, 13					; 0000000dH
	je	$LN34@xmlCompile

; 1069 : 		ERROR5(NULL, NULL, NULL, "Invalid QName.\n", NULL);
; 1070 : 		ctxt->error = 1;
; 1071 : 		goto error;
; 1072 : 	    }
; 1073 : 	    /*
; 1074 : 	     * This is a namespace match
; 1075 : 	     */
; 1076 : 	    token = xmlPatScanName(ctxt);

	push	esi
	call	_xmlPatScanName
	add	esp, 4
	mov	ebx, eax

; 1077 : 	    if ((prefix[0] == 'x') &&
; 1078 : 		(prefix[1] == 'm') &&
; 1079 : 		(prefix[2] == 'l') &&

	cmp	BYTE PTR [edi], 120			; 00000078H
	mov	DWORD PTR _token$1$[ebp], ebx
	jne	SHORT $LN36@xmlCompile
	cmp	BYTE PTR [edi+1], 109			; 0000006dH
	jne	SHORT $LN36@xmlCompile
	cmp	BYTE PTR [edi+2], 108			; 0000006cH
	jne	SHORT $LN36@xmlCompile
	cmp	BYTE PTR [edi+3], 0
	jne	SHORT $LN36@xmlCompile

; 1080 : 		(prefix[3] == 0))
; 1081 : 	    {
; 1082 : 		XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN38@xmlCompile
	push	-1
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _URL$1$[ebp], eax
	jmp	SHORT $LN43@xmlCompile
$LN38@xmlCompile:
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _URL$1$[ebp], eax

; 1083 : 	    } else {

	jmp	SHORT $LN43@xmlCompile
$LN36@xmlCompile:

; 1084 : 		for (i = 0;i < ctxt->nb_namespaces;i++) {

	xor	ebx, ebx
	cmp	ebx, DWORD PTR [esi+28]
	jge	SHORT $LN147@xmlCompile
$LL8@xmlCompile:

; 1085 : 		    if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {

	mov	eax, DWORD PTR [esi+24]
	push	edi
	push	DWORD PTR [eax+ebx*8+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN125@xmlCompile

; 1084 : 		for (i = 0;i < ctxt->nb_namespaces;i++) {

	inc	ebx
	cmp	ebx, DWORD PTR [esi+28]
	jl	SHORT $LL8@xmlCompile

; 1152 : 			    if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {

	jmp	SHORT $LN42@xmlCompile
$LN125@xmlCompile:

; 1086 : 			XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [eax+ebx*8]
	test	ecx, ecx
	je	SHORT $LN41@xmlCompile
	push	-1
	push	eax
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN148@xmlCompile
$LN41@xmlCompile:
	push	eax
	call	_xmlStrdup
	add	esp, 4
$LN148@xmlCompile:

; 1087 : 			break;
; 1088 : 		    }
; 1089 : 		}
; 1090 : 		if (i >= ctxt->nb_namespaces) {

	mov	DWORD PTR _URL$1$[ebp], eax
$LN42@xmlCompile:
	cmp	ebx, DWORD PTR [esi+28]
	jl	SHORT $LN144@xmlCompile
$LN147@xmlCompile:

; 1091 : 		    ERROR5(NULL, NULL, NULL,
; 1092 : 			"xmlCompileStepPattern : no namespace bound to prefix %s\n",
; 1093 : 			prefix);
; 1094 : 		    ctxt->error = 1;
; 1095 : 		    goto error;

	mov	ebx, DWORD PTR _token$1$[ebp]
	mov	DWORD PTR [esi+8], 1
	jmp	$error$160
$LN144@xmlCompile:

; 1087 : 			break;
; 1088 : 		    }
; 1089 : 		}
; 1090 : 		if (i >= ctxt->nb_namespaces) {

	mov	ebx, DWORD PTR _token$1$[ebp]
$LN43@xmlCompile:

; 1096 : 		}
; 1097 : 	    }
; 1098 : 	    XML_PAT_FREE_STRING(ctxt, prefix);

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN44@xmlCompile
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN44@xmlCompile:

; 1099 : 	    name = NULL;

	xor	edi, edi

; 1100 : 	    if (token == NULL) {

	test	ebx, ebx
	jne	SHORT $LN45@xmlCompile
$LN158@xmlCompile:

; 1212 :     }
; 1213 :     return;
; 1214 : error:
; 1215 :     if (URL != NULL)

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 42			; 0000002aH
	jne	$LN47@xmlCompile
	push	0
	push	DWORD PTR _URL$1$[ebp]
	inc	eax
	mov	DWORD PTR [esi], eax
	push	7
	jmp	$LN150@xmlCompile
$LN45@xmlCompile:

; 1101 : 		if (CUR == '*') {
; 1102 : 		    NEXT;
; 1103 : 		    PUSH(XML_OP_NS, URL, NULL);
; 1104 : 		} else {
; 1105 : 		    ERROR(NULL, NULL, NULL,
; 1106 : 			    "xmlCompileStepPattern : Name expected\n");
; 1107 : 		    ctxt->error = 1;
; 1108 : 		    goto error;
; 1109 : 		}
; 1110 : 	    } else {
; 1111 : 		PUSH(XML_OP_ELEM, token, URL);

	push	DWORD PTR _URL$1$[ebp]
	push	ebx
	push	2

; 1193 : 		if (ctxt->error != 0)
; 1194 : 		    goto error;
; 1195 : 		return;
; 1196 : 	    } else {
; 1197 : 		ERROR5(NULL, NULL, NULL,
; 1198 : 		    "The 'element' or 'attribute' axis is expected.\n", NULL);
; 1199 : 		ctxt->error = 1;
; 1200 : 		goto error;
; 1201 : 	    }
; 1202 : 	}

	jmp	$LN150@xmlCompile
$LN30@xmlCompile:

; 1112 : 	    }
; 1113 : 	} else {
; 1114 : 	    NEXT;

	lea	eax, DWORD PTR [edx+1]

; 1115 : 	    if (xmlStrEqual(name, (const xmlChar *) "child")) {

	push	OFFSET ??_C@_05GPGNDLEK@child@
	push	edi
	mov	DWORD PTR [esi], eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN51@xmlCompile

; 1116 : 		XML_PAT_FREE_STRING(ctxt, name);

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN53@xmlCompile
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN53@xmlCompile:

; 1117 : 		name = xmlPatScanName(ctxt);

	push	esi
	call	_xmlPatScanName
	mov	edi, eax
	add	esp, 4
	mov	eax, DWORD PTR [esi]
	mov	cl, BYTE PTR [eax]

; 1118 : 		if (name == NULL) {

	test	edi, edi
	jne	SHORT $LN56@xmlCompile

; 1119 : 		    if (CUR == '*') {

	cmp	cl, 42					; 0000002aH
	jne	$LN55@xmlCompile

; 1120 : 			NEXT;
; 1121 : 			PUSH(XML_OP_ALL, NULL, NULL);

	push	edi
	push	edi
	push	8
	push	DWORD PTR [esi+16]
	inc	eax
	push	esi
	mov	DWORD PTR [esi], eax
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi

; 1221 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN56@xmlCompile:

; 1122 : 			return;
; 1123 : 		    } else {
; 1124 : 			ERROR(NULL, NULL, NULL,
; 1125 : 			    "xmlCompileStepPattern : QName expected\n");
; 1126 : 			ctxt->error = 1;
; 1127 : 			goto error;
; 1128 : 		    }
; 1129 : 		}
; 1130 : 		if (CUR == ':') {

	cmp	cl, 58					; 0000003aH
	jne	$LN58@xmlCompile

; 1131 : 		    xmlChar *prefix = name;
; 1132 : 		    int i;
; 1133 : 
; 1134 : 		    NEXT;

	inc	eax
	mov	DWORD PTR [esi], eax

; 1135 : 		    if (IS_BLANK_CH(CUR)) {

	mov	al, BYTE PTR [eax]
	cmp	al, 32					; 00000020H
	je	$LN34@xmlCompile
	cmp	al, 9
	jb	SHORT $LN62@xmlCompile
	cmp	al, 10					; 0000000aH
	jbe	$LN34@xmlCompile
$LN62@xmlCompile:
	cmp	al, 13					; 0000000dH
	je	$LN34@xmlCompile

; 1136 : 			ERROR5(NULL, NULL, NULL, "Invalid QName.\n", NULL);
; 1137 : 			ctxt->error = 1;
; 1138 : 			goto error;
; 1139 : 		    }
; 1140 : 		    /*
; 1141 : 		    * This is a namespace match
; 1142 : 		    */
; 1143 : 		    token = xmlPatScanName(ctxt);

	push	esi
	call	_xmlPatScanName
	add	esp, 4
	mov	ebx, eax

; 1144 : 		    if ((prefix[0] == 'x') &&
; 1145 : 			(prefix[1] == 'm') &&
; 1146 : 			(prefix[2] == 'l') &&

	cmp	BYTE PTR [edi], 120			; 00000078H
	mov	DWORD PTR _token$1$[ebp], ebx
	jne	$LN63@xmlCompile
	cmp	BYTE PTR [edi+1], 109			; 0000006dH
	jne	$LN63@xmlCompile
	cmp	BYTE PTR [edi+2], 108			; 0000006cH
	jne	$LN63@xmlCompile
	cmp	BYTE PTR [edi+3], 0
	jne	$LN63@xmlCompile

; 1147 : 			(prefix[3] == 0))
; 1148 : 		    {
; 1149 : 			XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	$LN65@xmlCompile
	push	-1
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
$LN157@xmlCompile:

; 1158 : 			    ERROR5(NULL, NULL, NULL,
; 1159 : 				"xmlCompileStepPattern : no namespace bound "
; 1160 : 				"to prefix %s\n", prefix);
; 1161 : 			    ctxt->error = 1;
; 1162 : 			    goto error;
; 1163 : 			}
; 1164 : 		    }
; 1165 : 		    XML_PAT_FREE_STRING(ctxt, prefix);

	mov	DWORD PTR _URL$1$[ebp], eax
$LN70@xmlCompile:
	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN71@xmlCompile
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN71@xmlCompile:

; 1166 : 		    name = NULL;

	xor	edi, edi

; 1167 : 		    if (token == NULL) {

	test	ebx, ebx
	je	$LN158@xmlCompile

; 1168 : 			if (CUR == '*') {
; 1169 : 			    NEXT;
; 1170 : 			    PUSH(XML_OP_NS, URL, NULL);
; 1171 : 			} else {
; 1172 : 			    ERROR(NULL, NULL, NULL,
; 1173 : 				"xmlCompileStepPattern : Name expected\n");
; 1174 : 			    ctxt->error = 1;
; 1175 : 			    goto error;
; 1176 : 			}
; 1177 : 		    } else {
; 1178 : 			PUSH(XML_OP_CHILD, token, URL);

	push	DWORD PTR _URL$1$[ebp]
	push	ebx
	push	3
$LN150@xmlCompile:

; 1212 :     }
; 1213 :     return;
; 1214 : error:
; 1215 :     if (URL != NULL)

	push	DWORD PTR [esi+16]
	push	esi
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	$LN145@xmlCompile
$error$160:
	mov	ecx, DWORD PTR _URL$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN90@xmlCompile

; 1216 : 	XML_PAT_FREE_STRING(ctxt, URL)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN90@xmlCompile
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN90@xmlCompile:

; 1217 :     if (token != NULL)

	test	ebx, ebx
	je	$LN92@xmlCompile

; 1218 : 	XML_PAT_FREE_STRING(ctxt, token)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax+4], 0
	jne	$LN92@xmlCompile
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
	jmp	$LN92@xmlCompile
$LN65@xmlCompile:

; 1147 : 			(prefix[3] == 0))
; 1148 : 		    {
; 1149 : 			XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	call	_xmlStrdup
	add	esp, 4

; 1150 : 		    } else {

	jmp	$LN157@xmlCompile
$LN63@xmlCompile:

; 1151 : 			for (i = 0;i < ctxt->nb_namespaces;i++) {

	xor	ebx, ebx
	cmp	ebx, DWORD PTR [esi+28]
	jge	$LN147@xmlCompile
$LL11@xmlCompile:

; 1152 : 			    if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {

	mov	eax, DWORD PTR [esi+24]
	push	edi
	push	DWORD PTR [eax+ebx*8+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN126@xmlCompile

; 1151 : 			for (i = 0;i < ctxt->nb_namespaces;i++) {

	inc	ebx
	cmp	ebx, DWORD PTR [esi+28]
	jl	SHORT $LL11@xmlCompile

; 1152 : 			    if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {

	jmp	SHORT $LN69@xmlCompile
$LN126@xmlCompile:

; 1153 : 				XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [eax+ebx*8]
	test	ecx, ecx
	je	SHORT $LN68@xmlCompile
	push	-1
	push	eax
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN153@xmlCompile
$LN68@xmlCompile:
	push	eax
	call	_xmlStrdup
	add	esp, 4
$LN153@xmlCompile:

; 1154 : 				break;
; 1155 : 			    }
; 1156 : 			}
; 1157 : 			if (i >= ctxt->nb_namespaces) {

	mov	DWORD PTR _URL$1$[ebp], eax
$LN69@xmlCompile:
	cmp	ebx, DWORD PTR [esi+28]
	mov	ebx, DWORD PTR _token$1$[ebp]
	jl	$LN70@xmlCompile
$LN47@xmlCompile:

; 1212 :     }
; 1213 :     return;
; 1214 : error:
; 1215 :     if (URL != NULL)

	mov	DWORD PTR [esi+8], 1
	jmp	$error$160
$LN58@xmlCompile:

; 1179 : 		    }
; 1180 : 		} else
; 1181 : 		    PUSH(XML_OP_CHILD, name, NULL);

	push	0
	push	edi
	push	3

; 1182 : 		return;

	jmp	SHORT $LN155@xmlCompile
$LN51@xmlCompile:

; 1183 : 	    } else if (xmlStrEqual(name, (const xmlChar *) "attribute")) {

	push	OFFSET ??_C@_09HGIEBAJ@attribute@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN34@xmlCompile

; 1184 : 		XML_PAT_FREE_STRING(ctxt, name)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN81@xmlCompile
	push	edi
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [esi+16]
	add	esp, 4
$LN81@xmlCompile:

; 1185 : 		name = NULL;
; 1186 : 		if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {

	test	BYTE PTR [eax+16], 2
	je	SHORT $LN82@xmlCompile
$LN55@xmlCompile:
	pop	edi

; 1187 : 		    ERROR5(NULL, NULL, NULL,
; 1188 : 			"Unexpected attribute axis in '%s'.\n", ctxt->base);
; 1189 : 		    ctxt->error = 1;

	mov	DWORD PTR [esi+8], 1
	pop	esi

; 1221 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN82@xmlCompile:

; 1190 : 		    goto error;
; 1191 : 		}
; 1192 : 		xmlCompileAttributeTest(ctxt);

	push	esi
	call	_xmlCompileAttributeTest

; 1220 : 	XML_PAT_FREE_STRING(ctxt, name)

	add	esp, 4
	pop	edi
	pop	esi

; 1221 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlCompile:

; 1203 :     } else if (CUR == '*') {

	cmp	al, 42					; 0000002aH
	jne	SHORT $LN84@xmlCompile
$LN34@xmlCompile:

; 1219 :     if (name != NULL)

	mov	DWORD PTR [esi+8], 1
	jmp	SHORT $LN92@xmlCompile
$LN84@xmlCompile:

; 1204 :         if (name != NULL) {
; 1205 : 	    ctxt->error = 1;
; 1206 : 	    goto error;
; 1207 : 	}
; 1208 : 	NEXT;
; 1209 : 	PUSH(XML_OP_ALL, token, NULL);
; 1210 :     } else {
; 1211 : 	PUSH(XML_OP_ELEM, name, NULL);

	push	0
	push	edi
	push	2
$LN155@xmlCompile:

; 1219 :     if (name != NULL)

	push	DWORD PTR [esi+16]
	push	esi
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN145@xmlCompile
$LN92@xmlCompile:
	test	edi, edi
	je	SHORT $LN145@xmlCompile

; 1220 : 	XML_PAT_FREE_STRING(ctxt, name)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN145@xmlCompile
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN145@xmlCompile:

; 1221 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCompileStepPattern ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlCompileAttributeTest
_TEXT	SEGMENT
$T1 = -8						; size = 4
_token$1$ = -4						; size = 4
_URL$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlCompileAttributeTest PROC				; COMDAT

; 921  : xmlCompileAttributeTest(xmlPatParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR _URL$1$[ebp], 0
	npad	2
$LL2@xmlCompile:

; 922  :     xmlChar *token = NULL;
; 923  :     xmlChar *name = NULL;
; 924  :     xmlChar *URL = NULL;
; 925  : 
; 926  :     SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN7@xmlCompile
	cmp	al, 9
	jb	SHORT $LN8@xmlCompile
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN7@xmlCompile
$LN8@xmlCompile:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN3@xmlCompile
$LN7@xmlCompile:
	test	al, al
	je	SHORT $LL2@xmlCompile
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL2@xmlCompile
$LN3@xmlCompile:

; 927  :     name = xmlPatScanNCName(ctxt);

	push	esi
	call	_xmlPatScanNCName
	mov	ecx, DWORD PTR [esi]
	mov	ebx, eax
	add	esp, 4
	mov	al, BYTE PTR [ecx]

; 928  :     if (name == NULL) {

	test	ebx, ebx
	jne	SHORT $LN9@xmlCompile

; 929  : 	if (CUR == '*') {

	cmp	al, 42					; 0000002aH
	jne	$LN18@xmlCompile

; 930  : 	    PUSH(XML_OP_ATTR, NULL, NULL);

	push	ebx
	push	ebx
	push	4
	push	DWORD PTR [esi+16]
	push	esi
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$LN35@xmlCompile

; 931  : 	    NEXT;

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], bl
	je	$LN35@xmlCompile
	inc	eax
	mov	DWORD PTR [esi], eax
	pop	esi

; 1000 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlCompile:

; 932  : 	} else {
; 933  : 	    ERROR(NULL, NULL, NULL,
; 934  : 		"xmlCompileAttributeTest : Name expected\n");
; 935  : 	    ctxt->error = 1;
; 936  : 	}
; 937  : 	return;
; 938  :     }
; 939  :     if (CUR == ':') {

	cmp	al, 58					; 0000003aH
	jne	$LN13@xmlCompile

; 940  : 	int i;
; 941  : 	xmlChar *prefix = name;
; 942  : 
; 943  : 	NEXT;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi], eax

; 944  : 
; 945  : 	if (IS_BLANK_CH(CUR)) {

	mov	al, BYTE PTR [eax]
	cmp	al, 32					; 00000020H
	je	$LN16@xmlCompile
	cmp	al, 9
	jb	SHORT $LN17@xmlCompile
	cmp	al, 10					; 0000000aH
	jbe	$LN16@xmlCompile
$LN17@xmlCompile:
	cmp	al, 13					; 0000000dH
	je	$LN16@xmlCompile

; 948  : 	    ctxt->error = 1;
; 949  : 	    goto error;
; 950  : 	}
; 951  : 	/*
; 952  : 	* This is a namespace match
; 953  : 	*/
; 954  : 	token = xmlPatScanName(ctxt);

	push	edi
	push	esi
	call	_xmlPatScanName
	add	esp, 4
	mov	DWORD PTR _token$1$[ebp], eax

; 955  : 	if ((prefix[0] == 'x') &&
; 956  : 	    (prefix[1] == 'm') &&
; 957  : 	    (prefix[2] == 'l') &&

	cmp	BYTE PTR [ebx], 120			; 00000078H
	jne	SHORT $LN19@xmlCompile
	cmp	BYTE PTR [ebx+1], 109			; 0000006dH
	jne	SHORT $LN19@xmlCompile
	cmp	BYTE PTR [ebx+2], 108			; 0000006cH
	jne	SHORT $LN19@xmlCompile
	cmp	BYTE PTR [ebx+3], 0
	jne	SHORT $LN19@xmlCompile

; 958  : 	    (prefix[3] == 0))
; 959  : 	{
; 960  : 	    XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN21@xmlCompile
	push	-1
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN63@xmlCompile
$LN21@xmlCompile:
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	call	_xmlStrdup
	add	esp, 4
$LN63@xmlCompile:

; 961  : 	} else {

	mov	DWORD PTR _URL$1$[ebp], eax
	lea	eax, DWORD PTR [esi+16]
$LN59@xmlCompile:

; 975  : 	    }
; 976  : 	}
; 977  : 	XML_PAT_FREE_STRING(ctxt, prefix);

	mov	edi, eax
	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN28@xmlCompile
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN28@xmlCompile:

; 978  : 	if (token == NULL) {

	mov	eax, DWORD PTR _token$1$[ebp]
	mov	ebx, edi
	test	eax, eax
	jne	$LN29@xmlCompile

; 979  : 	    if (CUR == '*') {

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 42			; 0000002aH
	jne	$LN31@xmlCompile

; 980  : 		NEXT;
; 981  : 		PUSH(XML_OP_ATTR, NULL, URL);

	push	DWORD PTR _URL$1$[ebp]
	inc	eax
	mov	DWORD PTR [esi], eax
	push	0

; 987  : 	    }
; 988  : 	} else {

	jmp	$LN66@xmlCompile
$LN19@xmlCompile:

; 962  : 	    for (i = 0;i < ctxt->nb_namespaces;i++) {

	xor	edi, edi
	cmp	DWORD PTR [esi+28], edi
	jle	SHORT $LN25@xmlCompile
	npad	1
$LL6@xmlCompile:

; 963  : 		if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {

	mov	eax, DWORD PTR [esi+24]
	push	ebx
	push	DWORD PTR [eax+edi*8+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN52@xmlCompile

; 962  : 	    for (i = 0;i < ctxt->nb_namespaces;i++) {

	inc	edi
	cmp	edi, DWORD PTR [esi+28]
	jl	SHORT $LL6@xmlCompile

; 963  : 		if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {

	jmp	SHORT $LN25@xmlCompile
$LN52@xmlCompile:

; 964  : 		    XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [eax+edi*8]
	test	ecx, ecx
	je	SHORT $LN24@xmlCompile
	push	-1
	push	eax
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN64@xmlCompile
$LN24@xmlCompile:
	push	eax
	call	_xmlStrdup
	add	esp, 4
$LN64@xmlCompile:

; 965  : 		    break;
; 966  : 		}
; 967  : 	    }
; 968  : 	    if (i >= ctxt->nb_namespaces) {

	mov	DWORD PTR _URL$1$[ebp], eax
$LN25@xmlCompile:
	lea	eax, DWORD PTR [esi+16]
	mov	DWORD PTR $T1[ebp], eax
	cmp	edi, DWORD PTR [esi+28]
	jl	$LN59@xmlCompile

; 969  : 		ERROR5(NULL, NULL, NULL,
; 970  : 		    "xmlCompileAttributeTest : no namespace bound to prefix %s\n",
; 971  : 		    prefix);
; 972  : 	        XML_PAT_FREE_STRING(ctxt, prefix);

	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN27@xmlCompile
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN27@xmlCompile:

; 973  : 		ctxt->error = 1;
; 974  : 		goto error;

	mov	ebx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [esi+8], 1
	jmp	SHORT $error$68
$LN31@xmlCompile:

; 982  : 	    } else {
; 983  : 		ERROR(NULL, NULL, NULL,
; 984  : 		    "xmlCompileAttributeTest : Name expected\n");
; 985  : 		ctxt->error = 1;

	mov	DWORD PTR [esi+8], 1

; 986  : 		goto error;

	jmp	SHORT $error$68
$LN29@xmlCompile:

; 989  : 	    PUSH(XML_OP_ATTR, token, URL);

	push	DWORD PTR _URL$1$[ebp]
	push	eax
$LN66@xmlCompile:

; 993  :     }
; 994  :     return;
; 995  : error:
; 996  :     if (URL != NULL)

	push	4
	push	DWORD PTR [edi]
	push	esi
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN62@xmlCompile
$error$68:
	mov	ecx, DWORD PTR _URL$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN37@xmlCompile

; 997  : 	XML_PAT_FREE_STRING(ctxt, URL)

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN37@xmlCompile
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN37@xmlCompile:

; 998  :     if (token != NULL)

	mov	ecx, DWORD PTR _token$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN62@xmlCompile

; 999  : 	XML_PAT_FREE_STRING(ctxt, token);

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN62@xmlCompile
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN62@xmlCompile:
	pop	edi
$LN35@xmlCompile:
	pop	esi

; 1000 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlCompile:

; 946  : 	    ERROR5(NULL, NULL, NULL, "Invalid QName.\n", NULL);
; 947  : 	    XML_PAT_FREE_STRING(ctxt, prefix);

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN18@xmlCompile
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN18@xmlCompile:

; 1000 : }

	mov	DWORD PTR [esi+8], 1
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlCompile:

; 990  : 	}
; 991  :     } else {
; 992  : 	PUSH(XML_OP_ATTR, name, NULL);

	push	0
	push	ebx
	push	4
	push	DWORD PTR [esi+16]
	push	esi
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	pop	esi

; 1000 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCompileAttributeTest ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatScanNCName
_TEXT	SEGMENT
_len$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlPatScanNCName PROC					; COMDAT

; 860  : xmlPatScanNCName(xmlPatParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edi, DWORD PTR [ecx]
$LL2@xmlPatScan:

; 861  :     const xmlChar *q, *cur;
; 862  :     xmlChar *ret = NULL;
; 863  :     int val, len;
; 864  : 
; 865  :     SKIP_BLANKS;

	mov	al, BYTE PTR [edi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN6@xmlPatScan
	cmp	al, 9
	jb	SHORT $LN7@xmlPatScan
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN6@xmlPatScan
$LN7@xmlPatScan:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN3@xmlPatScan
$LN6@xmlPatScan:
	test	al, al
	je	SHORT $LL2@xmlPatScan
	inc	edi
	mov	DWORD PTR [ecx], edi
	jmp	SHORT $LL2@xmlPatScan
$LN3@xmlPatScan:

; 866  : 
; 867  :     cur = q = CUR_PTR;
; 868  :     val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	mov	ebx, edi
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 869  :     if (!IS_LETTER(val) && (val != '_'))

	cmp	esi, 256				; 00000100H
	jge	$LN21@xmlPatScan
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN15@xmlPatScan
	cmp	esi, 90					; 0000005aH
	jle	SHORT $LL4@xmlPatScan
$LN15@xmlPatScan:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN16@xmlPatScan
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LL4@xmlPatScan
$LN16@xmlPatScan:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN18@xmlPatScan
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LL4@xmlPatScan
$LN18@xmlPatScan:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN19@xmlPatScan
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LL4@xmlPatScan
$LN19@xmlPatScan:
	cmp	esi, 248				; 000000f8H
	jl	SHORT $LN61@xmlPatScan
	npad	4
$LL4@xmlPatScan:

; 870  : 	return(NULL);
; 871  : 
; 872  :     while ((IS_LETTER(val)) || (IS_DIGIT(val)) ||
; 873  :            (val == '.') || (val == '-') ||
; 874  : 	   (val == '_') ||
; 875  : 	   (IS_COMBINING(val)) ||

	cmp	esi, 256				; 00000100H
	jge	$LN35@xmlPatScan
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN29@xmlPatScan
	cmp	esi, 90					; 0000005aH
	jle	$LN9@xmlPatScan
$LN29@xmlPatScan:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN30@xmlPatScan
	cmp	esi, 122				; 0000007aH
	jle	$LN9@xmlPatScan
$LN30@xmlPatScan:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN32@xmlPatScan
	cmp	esi, 214				; 000000d6H
	jle	$LN9@xmlPatScan
$LN32@xmlPatScan:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN33@xmlPatScan
	cmp	esi, 246				; 000000f6H
	jle	$LN9@xmlPatScan
$LN33@xmlPatScan:
	cmp	esi, 248				; 000000f8H
	jge	$LN9@xmlPatScan
	jmp	SHORT $LN62@xmlPatScan
$LN21@xmlPatScan:

; 869  :     if (!IS_LETTER(val) && (val != '_'))

	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL4@xmlPatScan
$LN61@xmlPatScan:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN66@xmlPatScan
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN23@xmlPatScan
	cmp	esi, 40869				; 00009fa5H
	jle	$LL4@xmlPatScan
$LN23@xmlPatScan:
	cmp	esi, 12295				; 00003007H
	je	$LL4@xmlPatScan
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN66@xmlPatScan
	cmp	esi, 12329				; 00003029H
	jle	$LL4@xmlPatScan
$LN66@xmlPatScan:
	cmp	esi, 95					; 0000005fH
	je	$LL4@xmlPatScan

; 885  :     return(ret);
; 886  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@xmlPatScan:

; 870  : 	return(NULL);
; 871  : 
; 872  :     while ((IS_LETTER(val)) || (IS_DIGIT(val)) ||
; 873  :            (val == '.') || (val == '-') ||
; 874  : 	   (val == '_') ||
; 875  : 	   (IS_COMBINING(val)) ||

	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN9@xmlPatScan
$LN62@xmlPatScan:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN79@xmlPatScan
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN37@xmlPatScan
	cmp	esi, 40869				; 00009fa5H
	jle	$LN9@xmlPatScan
$LN37@xmlPatScan:
	cmp	esi, 12295				; 00003007H
	je	SHORT $LN9@xmlPatScan
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN67@xmlPatScan
	cmp	esi, 12329				; 00003029H
	jle	SHORT $LN9@xmlPatScan
$LN67@xmlPatScan:
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN45@xmlPatScan
$LN79@xmlPatScan:
	lea	eax, DWORD PTR [esi-48]
	cmp	eax, 9
	ja	SHORT $LN63@xmlPatScan
	jmp	SHORT $LN9@xmlPatScan
$LN45@xmlPatScan:
	push	OFFSET _xmlIsDigitGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlPatScan
$LN63@xmlPatScan:
	cmp	esi, 46					; 0000002eH
	je	SHORT $LN9@xmlPatScan
	cmp	esi, 45					; 0000002dH
	je	SHORT $LN9@xmlPatScan
	cmp	esi, 95					; 0000005fH
	je	SHORT $LN9@xmlPatScan
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN68@xmlPatScan
	push	OFFSET _xmlIsCombiningGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlPatScan
	push	OFFSET _xmlIsExtenderGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	jmp	SHORT $LN50@xmlPatScan
$LN68@xmlPatScan:
	xor	eax, eax
	cmp	esi, 183				; 000000b7H
	sete	al
$LN50@xmlPatScan:
	test	eax, eax
	je	SHORT $LN5@xmlPatScan
$LN9@xmlPatScan:

; 876  : 	   (IS_EXTENDER(val))) {
; 877  : 	cur += len;

	add	ebx, DWORD PTR _len$[ebp]

; 878  : 	val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	ebx
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 879  :     }

	jmp	$LL4@xmlPatScan
$LN5@xmlPatScan:

; 880  :     if (ctxt->dict)

	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, ebx
	sub	eax, edi
	push	eax
	push	edi
	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $LN10@xmlPatScan

; 881  : 	ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);

	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 884  :     CUR_PTR = cur;

	mov	DWORD PTR [esi], ebx
	pop	edi

; 885  :     return(ret);
; 886  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlPatScan:

; 882  :     else
; 883  : 	ret = xmlStrndup(q, cur - q);

	call	_xmlStrndup
	add	esp, 8

; 884  :     CUR_PTR = cur;

	mov	DWORD PTR [esi], ebx
	pop	edi

; 885  :     return(ret);
; 886  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlPatScanNCName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatScanName
_TEXT	SEGMENT
_len$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlPatScanName PROC					; COMDAT

; 822  : xmlPatScanName(xmlPatParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edi, DWORD PTR [ecx]
$LL2@xmlPatScan:

; 823  :     const xmlChar *q, *cur;
; 824  :     xmlChar *ret = NULL;
; 825  :     int val, len;
; 826  : 
; 827  :     SKIP_BLANKS;

	mov	al, BYTE PTR [edi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN6@xmlPatScan
	cmp	al, 9
	jb	SHORT $LN7@xmlPatScan
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN6@xmlPatScan
$LN7@xmlPatScan:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN3@xmlPatScan
$LN6@xmlPatScan:
	test	al, al
	je	SHORT $LL2@xmlPatScan
	inc	edi
	mov	DWORD PTR [ecx], edi
	jmp	SHORT $LL2@xmlPatScan
$LN3@xmlPatScan:

; 828  : 
; 829  :     cur = q = CUR_PTR;
; 830  :     val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	mov	ebx, edi
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 831  :     if (!IS_LETTER(val) && (val != '_') && (val != ':'))

	cmp	esi, 256				; 00000100H
	jge	$LN21@xmlPatScan
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN15@xmlPatScan
	cmp	esi, 90					; 0000005aH
	jle	SHORT $LL4@xmlPatScan
$LN15@xmlPatScan:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN16@xmlPatScan
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LL4@xmlPatScan
$LN16@xmlPatScan:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN18@xmlPatScan
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LL4@xmlPatScan
$LN18@xmlPatScan:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN19@xmlPatScan
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LL4@xmlPatScan
$LN19@xmlPatScan:
	cmp	esi, 248				; 000000f8H
	jl	SHORT $LN61@xmlPatScan
	npad	4
$LL4@xmlPatScan:

; 832  : 	return(NULL);
; 833  : 
; 834  :     while ((IS_LETTER(val)) || (IS_DIGIT(val)) ||
; 835  :            (val == '.') || (val == '-') ||
; 836  : 	   (val == '_') ||
; 837  : 	   (IS_COMBINING(val)) ||

	cmp	esi, 256				; 00000100H
	jge	$LN35@xmlPatScan
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN29@xmlPatScan
	cmp	esi, 90					; 0000005aH
	jle	$LN9@xmlPatScan
$LN29@xmlPatScan:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN30@xmlPatScan
	cmp	esi, 122				; 0000007aH
	jle	$LN9@xmlPatScan
$LN30@xmlPatScan:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN32@xmlPatScan
	cmp	esi, 214				; 000000d6H
	jle	$LN9@xmlPatScan
$LN32@xmlPatScan:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN33@xmlPatScan
	cmp	esi, 246				; 000000f6H
	jle	$LN9@xmlPatScan
$LN33@xmlPatScan:
	cmp	esi, 248				; 000000f8H
	jge	$LN9@xmlPatScan
	jmp	SHORT $LN62@xmlPatScan
$LN21@xmlPatScan:

; 831  :     if (!IS_LETTER(val) && (val != '_') && (val != ':'))

	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL4@xmlPatScan
$LN61@xmlPatScan:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN66@xmlPatScan
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN23@xmlPatScan
	cmp	esi, 40869				; 00009fa5H
	jle	$LL4@xmlPatScan
$LN23@xmlPatScan:
	cmp	esi, 12295				; 00003007H
	je	$LL4@xmlPatScan
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN66@xmlPatScan
	cmp	esi, 12329				; 00003029H
	jle	$LL4@xmlPatScan
$LN66@xmlPatScan:
	cmp	esi, 95					; 0000005fH
	je	$LL4@xmlPatScan
	cmp	esi, 58					; 0000003aH
	je	$LL4@xmlPatScan

; 847  :     return(ret);
; 848  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@xmlPatScan:

; 832  : 	return(NULL);
; 833  : 
; 834  :     while ((IS_LETTER(val)) || (IS_DIGIT(val)) ||
; 835  :            (val == '.') || (val == '-') ||
; 836  : 	   (val == '_') ||
; 837  : 	   (IS_COMBINING(val)) ||

	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN9@xmlPatScan
$LN62@xmlPatScan:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN79@xmlPatScan
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN37@xmlPatScan
	cmp	esi, 40869				; 00009fa5H
	jle	$LN9@xmlPatScan
$LN37@xmlPatScan:
	cmp	esi, 12295				; 00003007H
	je	SHORT $LN9@xmlPatScan
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN67@xmlPatScan
	cmp	esi, 12329				; 00003029H
	jle	SHORT $LN9@xmlPatScan
$LN67@xmlPatScan:
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN45@xmlPatScan
$LN79@xmlPatScan:
	lea	eax, DWORD PTR [esi-48]
	cmp	eax, 9
	ja	SHORT $LN63@xmlPatScan
	jmp	SHORT $LN9@xmlPatScan
$LN45@xmlPatScan:
	push	OFFSET _xmlIsDigitGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlPatScan
$LN63@xmlPatScan:
	cmp	esi, 46					; 0000002eH
	je	SHORT $LN9@xmlPatScan
	cmp	esi, 45					; 0000002dH
	je	SHORT $LN9@xmlPatScan
	cmp	esi, 95					; 0000005fH
	je	SHORT $LN9@xmlPatScan
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN68@xmlPatScan
	push	OFFSET _xmlIsCombiningGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlPatScan
	push	OFFSET _xmlIsExtenderGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	jmp	SHORT $LN50@xmlPatScan
$LN68@xmlPatScan:
	xor	eax, eax
	cmp	esi, 183				; 000000b7H
	sete	al
$LN50@xmlPatScan:
	test	eax, eax
	je	SHORT $LN5@xmlPatScan
$LN9@xmlPatScan:

; 838  : 	   (IS_EXTENDER(val))) {
; 839  : 	cur += len;

	add	ebx, DWORD PTR _len$[ebp]

; 840  : 	val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	ebx
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 841  :     }

	jmp	$LL4@xmlPatScan
$LN5@xmlPatScan:

; 842  :     if (ctxt->dict)

	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, ebx
	sub	eax, edi
	push	eax
	push	edi
	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $LN10@xmlPatScan

; 843  : 	ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);

	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 846  :     CUR_PTR = cur;

	mov	DWORD PTR [esi], ebx
	pop	edi

; 847  :     return(ret);
; 848  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlPatScan:

; 844  :     else
; 845  : 	ret = xmlStrndup(q, cur - q);

	call	_xmlStrndup
	add	esp, 8

; 846  :     CUR_PTR = cur;

	mov	DWORD PTR [esi], ebx
	pop	edi

; 847  :     return(ret);
; 848  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlPatScanName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatMatch
_TEXT	SEGMENT
_states$ = -16						; size = 12
_i$1$ = -4						; size = 4
_comp$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlPatMatch PROC					; COMDAT

; 498  : xmlPatMatch(xmlPatternPtr comp, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _comp$[ebp]
	xor	edx, edx
	mov	DWORD PTR _states$[ebp], 0
	mov	DWORD PTR _states$[ebp+4], 0
	mov	DWORD PTR _states$[ebp+8], edx
	test	eax, eax
	je	$LN12@xmlPatMatc

; 499  :     int i;
; 500  :     xmlStepOpPtr step;
; 501  :     xmlStepStates states = {0, 0, NULL}; /* // may require backtrack */
; 502  : 
; 503  :     if ((comp == NULL) || (node == NULL)) return(-1);

	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	$LN12@xmlPatMatc

; 504  :     i = 0;

	xor	esi, esi
	mov	DWORD PTR _i$1$[ebp], esi

; 505  : restart:
; 506  :     for (;i < comp->nbStep;i++) {

	cmp	DWORD PTR [eax+20], edx
	jle	$LN84@xmlPatMatc
	npad	6
$restart$163:

; 507  : 	step = &comp->steps[i];

	mov	ecx, DWORD PTR [eax+28]
	lea	eax, DWORD PTR [esi+esi*2]
	lea	ebx, DWORD PTR [ecx+eax*4]

; 508  : 	switch (step->op) {

	mov	eax, DWORD PTR [ebx]
	cmp	eax, 8
	ja	$LN2@xmlPatMatc
	jmp	DWORD PTR $LN162@xmlPatMatc[eax*4]
$LN14@xmlPatMatc:

; 509  :             case XML_OP_END:
; 510  : 		goto found;
; 511  :             case XML_OP_ROOT:
; 512  : 		if (node->type == XML_NAMESPACE_DECL)

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	SHORT $rollback$164

; 513  : 		    goto rollback;
; 514  : 		node = node->parent;

	mov	edi, DWORD PTR [edi+20]

; 515  : 		if ((node->type == XML_DOCUMENT_NODE) ||
; 516  : #ifdef LIBXML_DOCB_ENABLED
; 517  : 		    (node->type == XML_DOCB_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 9
	je	$LN2@xmlPatMatc
	cmp	eax, 21					; 00000015H
	je	$LN2@xmlPatMatc
	cmp	eax, 13					; 0000000dH
	jne	SHORT $rollback$164

; 518  : #endif
; 519  : 		    (node->type == XML_HTML_DOCUMENT_NODE))
; 520  : 		    continue;

	jmp	$LN2@xmlPatMatc
$LN18@xmlPatMatc:

; 521  : 		goto rollback;
; 522  :             case XML_OP_ELEM:
; 523  : 		if (node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [edi+4], 1
	jne	SHORT $rollback$164
$LN160@xmlPatMatc:

; 505  : restart:
; 506  :     for (;i < comp->nbStep;i++) {

	mov	ecx, DWORD PTR [ebx+4]
	test	ecx, ecx
	je	$LN2@xmlPatMatc
	mov	edx, DWORD PTR [edi+8]
	mov	al, BYTE PTR [ecx]
	cmp	al, BYTE PTR [edx]
	jne	SHORT $LN155@xmlPatMatc
	push	edx
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN155@xmlPatMatc
	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	jne	SHORT $LN23@xmlPatMatc
	cmp	DWORD PTR [ebx+8], eax
	je	$LN2@xmlPatMatc
$LN155@xmlPatMatc:

; 687  :     }
; 688  :     return(1);
; 689  : rollback:
; 690  :     /* got an error try to rollback */
; 691  :     if (states.states == NULL)

	mov	edx, DWORD PTR _states$[ebp+8]
$rollback$164:
	test	edx, edx
	je	$LN127@xmlPatMatc

; 692  : 	return(0);
; 693  :     if (states.nbstates <= 0) {

	mov	eax, DWORD PTR _states$[ebp]
	test	eax, eax
	jle	$LN128@xmlPatMatc

; 695  : 	return(0);
; 696  :     }
; 697  :     states.nbstates--;
; 698  :     i = states.states[states.nbstates].step;

	mov	esi, DWORD PTR [edx+eax*8-8]
	dec	eax
	mov	DWORD PTR _states$[ebp], eax

; 699  :     node = states.states[states.nbstates].node;

	mov	edi, DWORD PTR [edx+eax*8+4]
	jmp	$LN157@xmlPatMatc
$LN23@xmlPatMatc:

; 505  : restart:
; 506  :     for (;i < comp->nbStep;i++) {

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	$LN2@xmlPatMatc
	mov	eax, DWORD PTR [ebx+8]
	test	eax, eax
	je	SHORT $LN155@xmlPatMatc
$LN159@xmlPatMatc:
	push	ecx
$LN158@xmlPatMatc:
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN155@xmlPatMatc
	jmp	$LN2@xmlPatMatc
$LN29@xmlPatMatc:

; 528  : 		    goto rollback;
; 529  : 		if (!xmlStrEqual(step->value, node->name))
; 530  : 		    goto rollback;
; 531  : 
; 532  : 		/* Namespace test */
; 533  : 		if (node->ns == NULL) {
; 534  : 		    if (step->value2 != NULL)
; 535  : 			goto rollback;
; 536  : 		} else if (node->ns->href != NULL) {
; 537  : 		    if (step->value2 == NULL)
; 538  : 			goto rollback;
; 539  : 		    if (!xmlStrEqual(step->value2, node->ns->href))
; 540  : 			goto rollback;
; 541  : 		}
; 542  : 		continue;
; 543  :             case XML_OP_CHILD: {
; 544  : 		xmlNodePtr lst;
; 545  : 
; 546  : 		if ((node->type != XML_ELEMENT_NODE) &&
; 547  : 		    (node->type != XML_DOCUMENT_NODE) &&
; 548  : #ifdef LIBXML_DOCB_ENABLED
; 549  : 		    (node->type != XML_DOCB_DOCUMENT_NODE) &&

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 1
	je	SHORT $LN30@xmlPatMatc
	cmp	eax, 9
	je	SHORT $LN30@xmlPatMatc
	cmp	eax, 21					; 00000015H
	je	SHORT $LN30@xmlPatMatc
	cmp	eax, 13					; 0000000dH
	jne	SHORT $rollback$164
$LN30@xmlPatMatc:

; 550  : #endif
; 551  : 		    (node->type != XML_HTML_DOCUMENT_NODE))
; 552  : 		    goto rollback;
; 553  : 
; 554  : 		lst = node->children;
; 555  : 
; 556  : 		if (step->value != NULL) {

	cmp	DWORD PTR [ebx+4], 0
	mov	esi, DWORD PTR [edi+12]
	je	SHORT $rollback$164

; 557  : 		    while (lst != NULL) {

	test	esi, esi
	je	SHORT $rollback$164
	npad	5
$LL7@xmlPatMatc:

; 558  : 			if ((lst->type == XML_ELEMENT_NODE) &&
; 559  : 			    (step->value[0] == lst->name[0]) &&

	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN32@xmlPatMatc
	mov	edx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [esi+8]
	mov	al, BYTE PTR [edx]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN32@xmlPatMatc
	push	ecx
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN140@xmlPatMatc
$LN32@xmlPatMatc:

; 560  : 			    (xmlStrEqual(step->value, lst->name)))
; 561  : 			    break;
; 562  : 			lst = lst->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL7@xmlPatMatc

; 563  : 		    }
; 564  : 		    if (lst != NULL)

	jmp	$LN155@xmlPatMatc
$LN34@xmlPatMatc:

; 565  : 			continue;
; 566  : 		}
; 567  : 		goto rollback;
; 568  : 	    }
; 569  :             case XML_OP_ATTR:
; 570  : 		if (node->type != XML_ATTRIBUTE_NODE)

	cmp	DWORD PTR [edi+4], 2
	jne	$rollback$164

; 571  : 		    goto rollback;
; 572  : 		if (step->value != NULL) {

	mov	ecx, DWORD PTR [ebx+4]
	test	ecx, ecx
	je	SHORT $LN38@xmlPatMatc

; 573  : 		    if (step->value[0] != node->name[0])

	mov	edx, DWORD PTR [edi+8]
	mov	al, BYTE PTR [ecx]
	cmp	al, BYTE PTR [edx]
	jne	$LN155@xmlPatMatc

; 574  : 			goto rollback;
; 575  : 		    if (!xmlStrEqual(step->value, node->name))

	push	edx
	push	ecx
	call	_xmlStrEqual
	mov	edx, DWORD PTR _states$[ebp+8]
	add	esp, 8
	test	eax, eax
	je	$rollback$164
$LN38@xmlPatMatc:

; 576  : 			goto rollback;
; 577  : 		}
; 578  : 		/* Namespace test */
; 579  : 		if (node->ns == NULL) {

	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [ebx+8]
	test	ecx, ecx
	jne	SHORT $LN39@xmlPatMatc

; 580  : 		    if (step->value2 != NULL)

	test	eax, eax
	jne	$rollback$164

; 581  : 			goto rollback;
; 582  : 		} else if (step->value2 != NULL) {

	jmp	$LN2@xmlPatMatc
$LN39@xmlPatMatc:
	test	eax, eax
	je	$LN2@xmlPatMatc

; 583  : 		    if (!xmlStrEqual(step->value2, node->ns->href))

	push	DWORD PTR [ecx+8]

; 584  : 			goto rollback;
; 585  : 		}
; 586  : 		continue;

	jmp	$LN158@xmlPatMatc
$LN44@xmlPatMatc:

; 587  :             case XML_OP_PARENT:
; 588  : 		if ((node->type == XML_DOCUMENT_NODE) ||
; 589  : 		    (node->type == XML_HTML_DOCUMENT_NODE) ||
; 590  : #ifdef LIBXML_DOCB_ENABLED
; 591  : 		    (node->type == XML_DOCB_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 9
	je	$rollback$164
	cmp	eax, 13					; 0000000dH
	je	$rollback$164
	cmp	eax, 21					; 00000015H
	je	$rollback$164
	cmp	eax, 18					; 00000012H
	je	$rollback$164

; 592  : #endif
; 593  : 		    (node->type == XML_NAMESPACE_DECL))
; 594  : 		    goto rollback;
; 595  : 		node = node->parent;

	mov	edi, DWORD PTR [edi+20]

; 596  : 		if (node == NULL)

	test	edi, edi
	je	$rollback$164

; 597  : 		    goto rollback;
; 598  : 		if (step->value == NULL)
; 599  : 		    continue;
; 600  : 		if (step->value[0] != node->name[0])
; 601  : 		    goto rollback;
; 602  : 		if (!xmlStrEqual(step->value, node->name))
; 603  : 		    goto rollback;
; 604  : 		/* Namespace test */
; 605  : 		if (node->ns == NULL) {
; 606  : 		    if (step->value2 != NULL)
; 607  : 			goto rollback;
; 608  : 		} else if (node->ns->href != NULL) {

	jmp	$LN160@xmlPatMatc
$LN57@xmlPatMatc:

; 609  : 		    if (step->value2 == NULL)
; 610  : 			goto rollback;
; 611  : 		    if (!xmlStrEqual(step->value2, node->ns->href))
; 612  : 			goto rollback;
; 613  : 		}
; 614  : 		continue;
; 615  :             case XML_OP_ANCESTOR:
; 616  : 		/* TODO: implement coalescing of ANCESTOR/NODE ops */
; 617  : 		if (step->value == NULL) {

	cmp	DWORD PTR [ebx+4], 0
	jne	SHORT $LN61@xmlPatMatc

; 618  : 		    i++;

	inc	esi

; 619  : 		    step = &comp->steps[i];

	lea	eax, DWORD PTR [esi+esi*2]
	lea	ebx, DWORD PTR [ecx+eax*4]

; 620  : 		    if (step->op == XML_OP_ROOT)

	mov	eax, DWORD PTR [ebx]
	cmp	eax, 1
	je	$found$165

; 621  : 			goto found;
; 622  : 		    if (step->op != XML_OP_ELEM)

	cmp	eax, 2
	jne	$rollback$164

; 623  : 			goto rollback;
; 624  : 		    if (step->value == NULL)

	cmp	DWORD PTR [ebx+4], 0
	je	$LN12@xmlPatMatc
$LN61@xmlPatMatc:

; 625  : 			return(-1);
; 626  : 		}
; 627  : 		if (node == NULL)

	test	edi, edi
	je	$rollback$164

; 628  : 		    goto rollback;
; 629  : 		if ((node->type == XML_DOCUMENT_NODE) ||
; 630  : 		    (node->type == XML_HTML_DOCUMENT_NODE) ||
; 631  : #ifdef LIBXML_DOCB_ENABLED
; 632  : 		    (node->type == XML_DOCB_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 9
	je	$rollback$164
	cmp	eax, 13					; 0000000dH
	je	$rollback$164
	cmp	eax, 21					; 00000015H
	je	$rollback$164
	cmp	eax, 18					; 00000012H
	je	$rollback$164

; 633  : #endif
; 634  : 		    (node->type == XML_NAMESPACE_DECL))
; 635  : 		    goto rollback;
; 636  : 		node = node->parent;

	mov	edi, DWORD PTR [edi+20]

; 637  : 		while (node != NULL) {

	test	edi, edi
	je	$rollback$164
$LL9@xmlPatMatc:

; 638  : 		    if ((node->type == XML_ELEMENT_NODE) &&
; 639  : 			(step->value[0] == node->name[0]) &&

	cmp	DWORD PTR [edi+4], 1
	jne	SHORT $LN70@xmlPatMatc
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [edi+8]
	mov	al, BYTE PTR [ecx]
	cmp	al, BYTE PTR [edx]
	jne	SHORT $LN70@xmlPatMatc
	push	edx
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN70@xmlPatMatc

; 640  : 			(xmlStrEqual(step->value, node->name))) {
; 641  : 			/* Namespace test */
; 642  : 			if (node->ns == NULL) {

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	jne	SHORT $LN66@xmlPatMatc

; 643  : 			    if (step->value2 == NULL)

	cmp	DWORD PTR [ebx+8], eax
	jne	SHORT $LN70@xmlPatMatc
$LN94@xmlPatMatc:

; 652  : 		}
; 653  : 		if (node == NULL)

	test	edi, edi
	je	$LN155@xmlPatMatc

; 654  : 		    goto rollback;
; 655  : 		/*
; 656  : 		 * prepare a potential rollback from here
; 657  : 		 * for ancestors of that node.
; 658  : 		 */
; 659  : 		if (step->op == XML_OP_ANCESTOR)
; 660  : 		    xmlPatPushState(&states, i, node);
; 661  : 		else
; 662  : 		    xmlPatPushState(&states, i - 1, node);
; 663  : 		continue;

	cmp	DWORD PTR [ebx], 6
	lea	eax, DWORD PTR [esi-1]
	mov	ecx, esi
	cmovne	ecx, eax
	lea	eax, DWORD PTR _states$[ebp]
	push	edi
	push	ecx
	push	eax
	call	_xmlPatPushState
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@xmlPatMatc
$LN66@xmlPatMatc:

; 644  : 				break;
; 645  : 			} else if (node->ns->href != NULL) {

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN70@xmlPatMatc

; 646  : 			    if ((step->value2 != NULL) &&

	mov	eax, DWORD PTR [ebx+8]
	test	eax, eax
	je	SHORT $LN70@xmlPatMatc
	push	ecx
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN94@xmlPatMatc
$LN70@xmlPatMatc:

; 647  : 			        (xmlStrEqual(step->value2, node->ns->href)))
; 648  : 				break;
; 649  : 			}
; 650  : 		    }
; 651  : 		    node = node->parent;

	mov	edi, DWORD PTR [edi+20]
	test	edi, edi
	jne	SHORT $LL9@xmlPatMatc

; 637  : 		while (node != NULL) {

	jmp	$LN155@xmlPatMatc
$LN74@xmlPatMatc:

; 664  :             case XML_OP_NS:
; 665  : 		if (node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [edi+4], 1
	jne	$rollback$164

; 666  : 		    goto rollback;
; 667  : 		if (node->ns == NULL) {

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	jne	SHORT $LN76@xmlPatMatc

; 668  : 		    if (step->value != NULL)

	cmp	DWORD PTR [ebx+4], eax
	jne	$rollback$164

; 669  : 			goto rollback;
; 670  : 		} else if (node->ns->href != NULL) {

	jmp	SHORT $LN2@xmlPatMatc
$LN76@xmlPatMatc:
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@xmlPatMatc

; 671  : 		    if (step->value == NULL)

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	$rollback$164

; 672  : 			goto rollback;
; 673  : 		    if (!xmlStrEqual(step->value, node->ns->href))
; 674  : 			goto rollback;
; 675  : 		}
; 676  : 		break;

	jmp	$LN159@xmlPatMatc
$LN82@xmlPatMatc:

; 677  :             case XML_OP_ALL:
; 678  : 		if (node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [edi+4], 1
	je	SHORT $LN2@xmlPatMatc

; 524  : 		    goto rollback;
; 525  : 		if (step->value == NULL)
; 526  : 		    continue;
; 527  : 		if (step->value[0] != node->name[0])

	jmp	$rollback$164
$LN140@xmlPatMatc:

; 558  : 			if ((lst->type == XML_ELEMENT_NODE) &&
; 559  : 			    (step->value[0] == lst->name[0]) &&

	mov	esi, DWORD PTR _i$1$[ebp]
$LN2@xmlPatMatc:
	mov	edx, DWORD PTR _states$[ebp+8]

; 505  : restart:
; 506  :     for (;i < comp->nbStep;i++) {

	inc	esi
$LN157@xmlPatMatc:
	mov	eax, DWORD PTR _comp$[ebp]
	mov	DWORD PTR _i$1$[ebp], esi
	cmp	esi, DWORD PTR [eax+20]
	jl	$restart$163
$found$165:

; 679  : 		    goto rollback;
; 680  : 		break;
; 681  : 	}
; 682  :     }
; 683  : found:
; 684  :     if (states.states != NULL) {

	test	edx, edx
	je	SHORT $LN84@xmlPatMatc

; 685  :         /* Free the rollback states */
; 686  : 	xmlFree(states.states);

	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN84@xmlPatMatc:

; 700  : #if 0
; 701  :     fprintf(stderr, "Pop: %d, %s\n", i, node->name);
; 702  : #endif
; 703  :     goto restart;
; 704  : }

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN128@xmlPatMatc:

; 694  : 	xmlFree(states.states);

	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN127@xmlPatMatc:

; 700  : #if 0
; 701  :     fprintf(stderr, "Pop: %d, %s\n", i, node->name);
; 702  : #endif
; 703  :     goto restart;
; 704  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlPatMatc:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN162@xmlPatMatc:
	DD	$found$165
	DD	$LN14@xmlPatMatc
	DD	$LN18@xmlPatMatc
	DD	$LN29@xmlPatMatc
	DD	$LN34@xmlPatMatc
	DD	$LN44@xmlPatMatc
	DD	$LN57@xmlPatMatc
	DD	$LN74@xmlPatMatc
	DD	$LN82@xmlPatMatc
_xmlPatMatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatPushState
_TEXT	SEGMENT
_states$ = 8						; size = 4
_step$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlPatPushState PROC					; COMDAT

; 464  : xmlPatPushState(xmlStepStates *states, int step, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _states$[ebp]
	mov	edx, DWORD PTR [esi+8]
	test	edx, edx
	je	SHORT $LN4@xmlPatPush

; 465  :     if ((states->states == NULL) || (states->maxstates <= 0)) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jle	SHORT $LN4@xmlPatPush

; 469  :     }
; 470  :     else if (states->maxstates <= states->nbstates) {

	cmp	eax, DWORD PTR [esi]
	jg	SHORT $LN5@xmlPatPush

; 471  :         xmlStepState *tmp;
; 472  : 
; 473  : 	tmp = (xmlStepStatePtr) xmlRealloc(states->states,

	shl	eax, 4
	push	eax
	push	edx
	call	DWORD PTR _xmlRealloc
	mov	edx, eax
	add	esp, 8

; 474  : 			       2 * states->maxstates * sizeof(xmlStepState));
; 475  : 	if (tmp == NULL)

	test	edx, edx
	jne	SHORT $LN6@xmlPatPush

; 476  : 	    return(-1);

	or	eax, -1
	pop	esi

; 486  : }

	pop	ebp
	ret	0
$LN6@xmlPatPush:

; 477  : 	states->states = tmp;
; 478  : 	states->maxstates *= 2;

	mov	eax, DWORD PTR [esi+4]
	add	eax, eax
	mov	DWORD PTR [esi+4], eax
	jmp	SHORT $LN8@xmlPatPush
$LN4@xmlPatPush:

; 466  :         states->maxstates = 4;
; 467  : 	states->nbstates = 0;
; 468  : 	states->states = xmlMalloc(4 * sizeof(xmlStepState));

	push	32					; 00000020H
	mov	DWORD PTR [esi+4], 4
	mov	DWORD PTR [esi], 0
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	edx, eax
$LN8@xmlPatPush:

; 479  :     }
; 480  :     states->states[states->nbstates].step = step;

	mov	DWORD PTR [esi+8], edx
$LN5@xmlPatPush:
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR _step$[ebp]
	mov	DWORD PTR [edx+ecx*8], eax

; 481  :     states->states[states->nbstates++].node = node;

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [ecx+edx*8+4], eax
	inc	DWORD PTR [esi]

; 482  : #if 0
; 483  :     fprintf(stderr, "Push: %d, %s\n", step, node->name);
; 484  : #endif
; 485  :     return(0);

	xor	eax, eax
	pop	esi

; 486  : }

	pop	ebp
	ret	0
_xmlPatPushState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlReversePattern
_TEXT	SEGMENT
_i$1$ = -4						; size = 4
tv695 = 8						; size = 4
_comp$ = 8						; size = 4
_xmlReversePattern PROC					; COMDAT

; 408  : xmlReversePattern(xmlPatternPtr comp) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [esi+20]
	mov	edx, ecx
	test	ecx, ecx
	jle	SHORT $LN7@xmlReverse

; 409  :     int i, j;
; 410  : 
; 411  :     /*
; 412  :      * remove the leading // for //a or .//a
; 413  :      */
; 414  :     if ((comp->nbStep > 0) && (comp->steps[0].op == XML_OP_ANCESTOR)) {

	mov	eax, DWORD PTR [esi+28]
	cmp	DWORD PTR [eax], 6
	jne	SHORT $LN7@xmlReverse

; 415  :         for (i = 0, j = 1;j < comp->nbStep;i++,j++) {

	mov	edi, 1
	cmp	ecx, edi
	jle	SHORT $LN3@xmlReverse
	mov	edx, 12					; 0000000cH
$LL4@xmlReverse:

; 416  : 	    comp->steps[i].value = comp->steps[j].value;

	mov	ecx, DWORD PTR [esi+28]
	lea	edx, DWORD PTR [edx+12]
	inc	edi
	mov	eax, DWORD PTR [edx+ecx-8]
	mov	DWORD PTR [edx+ecx-20], eax

; 417  : 	    comp->steps[i].value2 = comp->steps[j].value2;

	mov	ecx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [edx+ecx-4]
	mov	DWORD PTR [edx+ecx-16], eax

; 418  : 	    comp->steps[i].op = comp->steps[j].op;

	mov	ecx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [edx+ecx-12]
	mov	DWORD PTR [edx+ecx-24], eax
	mov	ecx, DWORD PTR [esi+20]
	cmp	edi, ecx
	jl	SHORT $LL4@xmlReverse
$LN3@xmlReverse:

; 419  : 	}
; 420  : 	comp->nbStep--;

	lea	edx, DWORD PTR [ecx-1]
	mov	DWORD PTR [esi+20], edx
$LN7@xmlReverse:

; 421  :     }
; 422  :     if (comp->nbStep >= comp->maxStep) {

	mov	eax, DWORD PTR [esi+24]
	cmp	edx, eax
	jl	SHORT $LN20@xmlReverse

; 423  :         xmlStepOpPtr temp;
; 424  : 	temp = (xmlStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 3
	push	eax
	push	DWORD PTR [esi+28]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 425  : 	                                 sizeof(xmlStepOp));
; 426  :         if (temp == NULL) {

	test	eax, eax
	jne	SHORT $LN9@xmlReverse

; 427  : 	    ERROR(ctxt, NULL, NULL,
; 428  : 			     "xmlReversePattern: realloc failed\n");
; 429  : 	    return (-1);

	pop	edi
	or	eax, -1

; 455  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlReverse:

; 430  : 	}
; 431  : 	comp->steps = temp;
; 432  : 	comp->maxStep *= 2;

	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+28], eax
	mov	eax, DWORD PTR [esi+24]
	add	eax, eax
	mov	DWORD PTR [esi+24], eax
$LN20@xmlReverse:

; 435  :     j = comp->nbStep - 1;

	push	ebx
	lea	ebx, DWORD PTR [edx-1]
	mov	DWORD PTR _i$1$[ebp], 0

; 436  :     while (j > i) {

	test	ebx, ebx
	jle	SHORT $LN6@xmlReverse

; 433  :     }
; 434  :     i = 0;

	lea	edi, DWORD PTR [ebx+ebx*2]
	shl	edi, 2
	xor	ecx, ecx
	mov	DWORD PTR tv695[ebp], ecx
$LL5@xmlReverse:

; 437  : 	register const xmlChar *tmp;
; 438  : 	register xmlPatOp op;
; 439  : 	tmp = comp->steps[i].value;

	mov	eax, DWORD PTR [esi+28]

; 440  : 	comp->steps[i].value = comp->steps[j].value;
; 441  : 	comp->steps[j].value = tmp;
; 442  : 	tmp = comp->steps[i].value2;
; 443  : 	comp->steps[i].value2 = comp->steps[j].value2;
; 444  : 	comp->steps[j].value2 = tmp;
; 445  : 	op = comp->steps[i].op;
; 446  : 	comp->steps[i].op = comp->steps[j].op;
; 447  : 	comp->steps[j].op = op;
; 448  : 	j--;

	lea	edi, DWORD PTR [edi-12]
	add	ecx, eax
	dec	ebx
	mov	eax, DWORD PTR [edi+eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR tv695[ebp]
	mov	DWORD PTR [edi+eax+16], edx
	mov	eax, DWORD PTR [esi+28]
	add	ecx, eax
	mov	eax, DWORD PTR [edi+eax+20]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR tv695[ebp]
	mov	DWORD PTR [edi+eax+20], edx
	mov	eax, DWORD PTR [esi+28]
	add	ecx, eax
	mov	eax, DWORD PTR [edi+eax+12]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [esi+28]

; 449  : 	i++;

	mov	ecx, DWORD PTR tv695[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR tv695[ebp], ecx
	mov	DWORD PTR [edi+eax+12], edx
	mov	eax, DWORD PTR _i$1$[ebp]
	inc	eax
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	ebx, eax
	jg	SHORT $LL5@xmlReverse

; 430  : 	}
; 431  : 	comp->steps = temp;
; 432  : 	comp->maxStep *= 2;

	mov	edx, DWORD PTR [esi+20]
$LN6@xmlReverse:

; 450  :     }
; 451  :     comp->steps[comp->nbStep].value = NULL;

	mov	eax, DWORD PTR [esi+28]
	lea	ecx, DWORD PTR [edx+edx*2]

; 452  :     comp->steps[comp->nbStep].value2 = NULL;
; 453  :     comp->steps[comp->nbStep++].op = XML_OP_END;
; 454  :     return(0);

	pop	ebx
	pop	edi
	mov	DWORD PTR [eax+ecx*4+4], 0
	mov	eax, DWORD PTR [esi+20]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax+ecx*4+8], 0
	mov	eax, DWORD PTR [esi+20]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax+ecx*4], 0
	inc	DWORD PTR [esi+20]
	xor	eax, eax

; 455  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlReversePattern ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatternAdd
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_comp$ = 12						; size = 4
_op$ = 16						; size = 4
_value$ = 20						; size = 4
_value2$ = 24						; size = 4
_xmlPatternAdd PROC					; COMDAT

; 350  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [esi+24]
	cmp	ecx, eax
	jl	SHORT $LN6@xmlPattern

; 351  :     if (comp->nbStep >= comp->maxStep) {
; 352  :         xmlStepOpPtr temp;
; 353  : 	temp = (xmlStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 3
	push	eax
	push	DWORD PTR [esi+28]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 354  : 	                                 sizeof(xmlStepOp));
; 355  :         if (temp == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlPattern

; 356  : 	    ERROR(ctxt, NULL, NULL,
; 357  : 			     "xmlPatternAdd: realloc failed\n");
; 358  : 	    return (-1);

	or	eax, -1
	pop	esi

; 368  : }

	pop	ebp
	ret	0
$LN3@xmlPattern:

; 359  : 	}
; 360  : 	comp->steps = temp;
; 361  : 	comp->maxStep *= 2;

	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+28], eax
	mov	eax, DWORD PTR [esi+24]
	add	eax, eax
	mov	DWORD PTR [esi+24], eax
$LN6@xmlPattern:

; 362  :     }
; 363  :     comp->steps[comp->nbStep].op = op;

	mov	eax, DWORD PTR _op$[ebp]
	lea	edx, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR [ecx+edx*4], eax

; 364  :     comp->steps[comp->nbStep].value = value;

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+28]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx+edx*4+4], eax

; 365  :     comp->steps[comp->nbStep].value2 = value2;

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+28]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR _value2$[ebp]
	mov	DWORD PTR [ecx+edx*4+8], eax

; 366  :     comp->nbStep++;

	inc	DWORD PTR [esi+20]

; 367  :     return (0);

	xor	eax, eax
	pop	esi

; 368  : }

	pop	ebp
	ret	0
_xmlPatternAdd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlFreePatParserContext
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlFreePatParserContext PROC				; COMDAT

; 328  : xmlFreePatParserContext(xmlPatParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN1@xmlFreePat

; 329  :     if (ctxt == NULL)
; 330  : 	return;
; 331  :     memset(ctxt, -1, sizeof(xmlPatParserContext));

	movaps	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0

; 332  :     xmlFree(ctxt);

	mov	DWORD PTR _ctxt$[ebp], eax

; 333  : }

	pop	ebp

; 332  :     xmlFree(ctxt);

	jmp	DWORD PTR _xmlFree
$LN1@xmlFreePat:

; 333  : }

	pop	ebp
	ret	0
_xmlFreePatParserContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlNewPatParserContext
_TEXT	SEGMENT
_pattern$ = 8						; size = 4
_dict$ = 12						; size = 4
_namespaces$ = 16					; size = 4
_xmlNewPatParserContext PROC				; COMDAT

; 293  :                        const xmlChar **namespaces) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _pattern$[ebp]
	test	esi, esi
	je	SHORT $LN14@xmlNewPatP

; 294  :     xmlPatParserContextPtr cur;
; 295  : 
; 296  :     if (pattern == NULL)
; 297  :         return(NULL);
; 298  : 
; 299  :     cur = (xmlPatParserContextPtr) xmlMalloc(sizeof(xmlPatParserContext));

	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4

; 300  :     if (cur == NULL) {

	test	ecx, ecx
	je	SHORT $LN14@xmlNewPatP

; 304  :     }
; 305  :     memset(cur, 0, sizeof(xmlPatParserContext));
; 306  :     cur->dict = dict;

	mov	eax, DWORD PTR _dict$[ebp]

; 307  :     cur->cur = pattern;
; 308  :     cur->base = pattern;
; 309  :     if (namespaces != NULL) {

	mov	edx, DWORD PTR _namespaces$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+12], eax
	xor	eax, eax
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], esi
	test	edx, edx
	je	SHORT $LN8@xmlNewPatP

; 310  :         int i;
; 311  :         for (i = 0;namespaces[2 * i] != NULL;i++)

	cmp	DWORD PTR [edx], eax
	je	SHORT $LN8@xmlNewPatP
$LL4@xmlNewPatP:
	inc	eax
	cmp	DWORD PTR [edx+eax*8], 0
	jne	SHORT $LL4@xmlNewPatP
$LN8@xmlNewPatP:

; 312  :             ;
; 313  :         cur->nb_namespaces = i;
; 314  :     } else {
; 315  :         cur->nb_namespaces = 0;
; 316  :     }
; 317  :     cur->namespaces = namespaces;

	mov	DWORD PTR [ecx+28], eax

; 318  :     return(cur);

	mov	eax, ecx
	mov	DWORD PTR [ecx+24], edx
	pop	esi

; 319  : }

	pop	ebp
	ret	0
$LN14@xmlNewPatP:

; 301  : 	ERROR(NULL, NULL, NULL,
; 302  : 		"xmlNewPatParserContext : malloc failed\n");
; 303  : 	return(NULL);

	xor	eax, eax
	pop	esi

; 319  : }

	pop	ebp
	ret	0
_xmlNewPatParserContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlNewPattern
_TEXT	SEGMENT
_xmlNewPattern PROC					; COMDAT

; 203  : xmlNewPattern(void) {

	push	esi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN5@xmlNewPatt

; 204  :     xmlPatternPtr cur;
; 205  : 
; 206  :     cur = (xmlPatternPtr) xmlMalloc(sizeof(xmlPattern));
; 207  :     if (cur == NULL) {
; 208  : 	ERROR(NULL, NULL, NULL,
; 209  : 		"xmlNewPattern : malloc failed\n");
; 210  : 	return(NULL);
; 211  :     }
; 212  :     memset(cur, 0, sizeof(xmlPattern));

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0

; 213  :     cur->maxStep = 10;
; 214  :     cur->steps = (xmlStepOpPtr) xmlMalloc(cur->maxStep * sizeof(xmlStepOp));

	push	120					; 00000078H
	mov	DWORD PTR [esi+24], 10			; 0000000aH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+28], eax

; 215  :     if (cur->steps == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlNewPatt

; 216  :         xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlNewPatt:

; 222  : }

	xor	eax, eax
	pop	esi
	ret	0
$LN3@xmlNewPatt:

; 217  : 	ERROR(NULL, NULL, NULL,
; 218  : 		"xmlNewPattern : malloc failed\n");
; 219  : 	return(NULL);
; 220  :     }
; 221  :     return(cur);

	mov	eax, esi
	pop	esi

; 222  : }

	ret	0
_xmlNewPattern ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlFreeStreamComp
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_xmlFreeStreamComp PROC					; COMDAT

; 1524 : xmlFreeStreamComp(xmlStreamCompPtr comp) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _comp$[ebp]
	test	esi, esi
	je	SHORT $LN2@xmlFreeStr

; 1525 :     if (comp != NULL) {
; 1526 :         if (comp->steps != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN3@xmlFreeStr

; 1527 : 	    xmlFree(comp->steps);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlFreeStr:

; 1528 : 	if (comp->dict != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@xmlFreeStr

; 1529 : 	    xmlDictFree(comp->dict);

	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN4@xmlFreeStr:

; 1530 :         xmlFree(comp);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlFreeStr:
	pop	esi

; 1531 :     }
; 1532 : }

	pop	ebp
	ret	0
_xmlFreeStreamComp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamWantsAnyNode
_TEXT	SEGMENT
_streamCtxt$ = 8					; size = 4
_xmlStreamWantsAnyNode PROC				; COMDAT

; 2330 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _streamCtxt$[ebp]
	test	eax, eax
	jne	SHORT $LL2@xmlStreamW

; 2331 :     if (streamCtxt == NULL)
; 2332 : 	return(-1);

	or	eax, -1

; 2337 :     }
; 2338 :     return(0);
; 2339 : }

	pop	ebp
	ret	0
	npad	7
$LL2@xmlStreamW:

; 2333 :     while (streamCtxt != NULL) {
; 2334 : 	if (streamCtxt->comp->flags & XML_STREAM_FINAL_IS_ANY_NODE)

	mov	ecx, DWORD PTR [eax+4]
	test	DWORD PTR [ecx+16], 16384		; 00004000H
	jne	SHORT $LN8@xmlStreamW

; 2336 : 	streamCtxt = streamCtxt->next;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL2@xmlStreamW

; 2337 :     }
; 2338 :     return(0);
; 2339 : }

	pop	ebp
	ret	0
$LN8@xmlStreamW:

; 2335 : 	    return(1);

	mov	eax, 1

; 2337 :     }
; 2338 :     return(0);
; 2339 : }

	pop	ebp
	ret	0
_xmlStreamWantsAnyNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamPop
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_xmlStreamPop PROC					; COMDAT

; 2281 : xmlStreamPop(xmlStreamCtxtPtr stream) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _stream$[ebp]
	test	eax, eax
	jne	SHORT $LN39@xmlStreamP

; 2282 :     int i, lev;
; 2283 : 
; 2284 :     if (stream == NULL)
; 2285 :         return(-1);

	or	eax, -1

; 2314 : }

	pop	ebp
	ret	0
$LN39@xmlStreamP:
	push	esi
	npad	6
$LL2@xmlStreamP:

; 2286 :     while (stream != NULL) {
; 2287 : 	/*
; 2288 : 	* Reset block-level.
; 2289 : 	*/
; 2290 : 	if (stream->blockLevel == stream->level)

	mov	esi, DWORD PTR [eax+16]
	cmp	DWORD PTR [eax+28], esi
	jne	SHORT $LN26@xmlStreamP

; 2291 : 	    stream->blockLevel = -1;

	mov	DWORD PTR [eax+28], -1
$LN26@xmlStreamP:

; 2292 : 
; 2293 : 	/*
; 2294 : 	 *  stream->level can be zero when XML_FINAL_IS_ANY_NODE is set
; 2295 : 	 *  (see the thread at
; 2296 : 	 *  http://mail.gnome.org/archives/xslt/2008-July/msg00027.html)
; 2297 : 	 */
; 2298 : 	if (stream->level)

	test	esi, esi
	je	SHORT $LN27@xmlStreamP

; 2299 : 	    stream->level--;

	dec	esi
	mov	DWORD PTR [eax+16], esi
$LN27@xmlStreamP:

; 2300 : 	/*
; 2301 : 	 * Check evolution of existing states
; 2302 : 	 */
; 2303 : 	for (i = stream->nbState -1; i >= 0; i--) {

	mov	edx, DWORD PTR [eax+8]
	sub	edx, 1
	js	SHORT $LN38@xmlStreamP

; 2304 : 	    /* discard obsoleted states */
; 2305 : 	    lev = stream->states[(2 * i) + 1];

	mov	ecx, DWORD PTR [eax+20]
	lea	ecx, DWORD PTR [ecx+edx*8]
	add	ecx, 4
$LL6@xmlStreamP:

; 2306 : 	    if (lev > stream->level)

	cmp	DWORD PTR [ecx], esi
	jle	SHORT $LN38@xmlStreamP

; 2307 : 		stream->nbState--;

	dec	DWORD PTR [eax+8]
	sub	ecx, 8
	sub	edx, 1
	jns	SHORT $LL6@xmlStreamP
$LN38@xmlStreamP:

; 2308 : 	    if (lev <= stream->level)
; 2309 : 		break;
; 2310 : 	}
; 2311 : 	stream = stream->next;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL2@xmlStreamP

; 2312 :     }
; 2313 :     return(0);

	pop	esi

; 2314 : }

	pop	ebp
	ret	0
_xmlStreamPop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamPushAttr
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_name$ = 12						; size = 4
_ns$ = 16						; size = 4
_xmlStreamPushAttr PROC					; COMDAT

; 2268 : 		  const xmlChar *name, const xmlChar *ns) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	push	2
	push	DWORD PTR _ns$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _stream$[ebp]
	call	_xmlStreamPushInternal
	add	esp, 16					; 00000010H

; 2269 :     return (xmlStreamPushInternal(stream, name, ns, (int) XML_ATTRIBUTE_NODE));
; 2270 : }

	pop	ebp
	ret	0
_xmlStreamPushAttr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamPush
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_name$ = 12						; size = 4
_ns$ = 16						; size = 4
_xmlStreamPush PROC					; COMDAT

; 2218 :               const xmlChar *name, const xmlChar *ns) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	push	1
	push	DWORD PTR _ns$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _stream$[ebp]
	call	_xmlStreamPushInternal
	add	esp, 16					; 00000010H

; 2219 :     return (xmlStreamPushInternal(stream, name, ns, (int) XML_ELEMENT_NODE));
; 2220 : }

	pop	ebp
	ret	0
_xmlStreamPush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamPushNode
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_name$ = 12						; size = 4
_ns$ = 16						; size = 4
_nodeType$ = 20						; size = 4
_xmlStreamPushNode PROC					; COMDAT

; 2245 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 2247 : 	nodeType));
; 2248 : }

	pop	ebp

; 2246 :     return (xmlStreamPushInternal(stream, name, ns,

	jmp	_xmlStreamPushInternal
_xmlStreamPushNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlFreeStreamCtxt
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_xmlFreeStreamCtxt PROC					; COMDAT

; 1792 : xmlFreeStreamCtxt(xmlStreamCtxtPtr stream) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _stream$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlFreeStr
	push	edi
$LL2@xmlFreeStr:

; 1793 :     xmlStreamCtxtPtr next;
; 1794 : 
; 1795 :     while (stream != NULL) {
; 1796 :         next = stream->next;
; 1797 :         if (stream->states != NULL)

	mov	eax, DWORD PTR [esi+20]
	mov	edi, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@xmlFreeStr

; 1798 : 	    xmlFree(stream->states);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlFreeStr:

; 1799 :         xmlFree(stream);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1800 : 	stream = next;

	mov	esi, edi
	test	edi, edi
	jne	SHORT $LL2@xmlFreeStr
	pop	edi
$LN3@xmlFreeStr:
	pop	esi

; 1801 :     }
; 1802 : }

	pop	ebp
	ret	0
_xmlFreeStreamCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatternGetStreamCtxt
_TEXT	SEGMENT
tv241 = 8						; size = 4
_comp$ = 8						; size = 4
_xmlPatternGetStreamCtxt PROC				; COMDAT

; 2491 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _comp$[ebp]
	xor	ebx, ebx
	test	edi, edi
	je	$LN5@xmlPattern

; 2492 :     xmlStreamCtxtPtr ret = NULL, cur;
; 2493 : 
; 2494 :     if ((comp == NULL) || (comp->stream == NULL))

	cmp	DWORD PTR [edi+32], ebx
	je	$LN5@xmlPattern
	push	esi
$LL2@xmlPattern:

; 2496 : 
; 2497 :     while (comp != NULL) {
; 2498 :         if (comp->stream == NULL)

	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR tv241[ebp], eax
	test	eax, eax
	je	SHORT $failed$26

; 1763 :     cur = (xmlStreamCtxtPtr) xmlMalloc(sizeof(xmlStreamCtxt));

	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 1764 :     if (cur == NULL) {

	test	esi, esi
	je	SHORT $failed$26
	xorps	xmm0, xmm0

; 1765 : 	ERROR(NULL, NULL, NULL,
; 1766 : 		"xmlNewStreamCtxt: malloc failed\n");
; 1767 : 	return(NULL);
; 1768 :     }
; 1769 :     memset(cur, 0, sizeof(xmlStreamCtxt));

	movups	XMMWORD PTR [esi], xmm0

; 1770 :     cur->states = (int *) xmlMalloc(4 * 2 * sizeof(int));

	push	32					; 00000020H
	movups	XMMWORD PTR [esi+16], xmm0
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+20], eax

; 1771 :     if (cur->states == NULL) {

	test	eax, eax
	je	SHORT $LN23@xmlPattern

; 1773 : 	ERROR(NULL, NULL, NULL,
; 1774 : 	      "xmlNewStreamCtxt: malloc failed\n");
; 1775 : 	return(NULL);
; 1776 :     }
; 1777 :     cur->nbState = 0;
; 1778 :     cur->maxState = 4;
; 1779 :     cur->level = 0;
; 1780 :     cur->comp = stream;

	mov	eax, DWORD PTR tv241[ebp]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 4
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+4], eax

; 1781 :     cur->blockLevel = -1;

	mov	DWORD PTR [esi+28], -1

; 2499 : 	    goto failed;
; 2500 : 	cur = xmlNewStreamCtxt(comp->stream);
; 2501 : 	if (cur == NULL)
; 2502 : 	    goto failed;
; 2503 : 	if (ret == NULL)

	test	ebx, ebx
	jne	SHORT $LN8@xmlPattern

; 2504 : 	    ret = cur;

	mov	ebx, esi
	jmp	SHORT $LN9@xmlPattern
$LN8@xmlPattern:

; 2505 : 	else {
; 2506 : 	    cur->next = ret->next;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax

; 2507 : 	    ret->next = cur;

	mov	DWORD PTR [ebx], esi
$LN9@xmlPattern:

; 2508 : 	}
; 2509 : 	cur->flags = comp->flags;

	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+24], ecx

; 2510 : 	comp = comp->next;

	mov	edi, DWORD PTR [edi+8]
	test	edi, edi
	jne	SHORT $LL2@xmlPattern

; 2511 :     }
; 2512 :     return(ret);

	pop	esi
	pop	edi
	mov	eax, ebx

; 2516 : }

	pop	ebx
	pop	ebp
	ret	0
$LN23@xmlPattern:

; 1772 : 	xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$failed$26:

; 2513 : failed:
; 2514 :     xmlFreeStreamCtxt(ret);

	push	ebx
	call	_xmlFreeStreamCtxt
	add	esp, 4

; 2515 :     return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 2516 : }

	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlPattern:
	pop	edi

; 2495 :         return(NULL);

	xor	eax, eax

; 2516 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlPatternGetStreamCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatternFromRoot
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_xmlPatternFromRoot PROC				; COMDAT

; 2602 : xmlPatternFromRoot(xmlPatternPtr comp) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _comp$[ebp]
	test	eax, eax
	je	SHORT $LN9@xmlPattern
$LL2@xmlPattern:

; 2603 :     if (comp == NULL)
; 2604 :         return(-1);
; 2605 :     while (comp != NULL) {
; 2606 :         if (comp->stream == NULL)

	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN9@xmlPattern

; 2608 : 	if (comp->flags & PAT_FROM_ROOT)

	test	DWORD PTR [eax+16], 256			; 00000100H
	jne	SHORT $LN10@xmlPattern

; 2610 : 	comp = comp->next;

	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	jne	SHORT $LL2@xmlPattern

; 2611 :     }
; 2612 :     return(0);
; 2613 : 
; 2614 : }

	pop	ebp
	ret	0
$LN10@xmlPattern:

; 2609 : 	    return(1);

	mov	eax, 1

; 2611 :     }
; 2612 :     return(0);
; 2613 : 
; 2614 : }

	pop	ebp
	ret	0
$LN9@xmlPattern:

; 2607 : 	    return(-1);

	or	eax, -1

; 2611 :     }
; 2612 :     return(0);
; 2613 : 
; 2614 : }

	pop	ebp
	ret	0
_xmlPatternFromRoot ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatternMinDepth
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_xmlPatternMinDepth PROC				; COMDAT

; 2577 : xmlPatternMinDepth(xmlPatternPtr comp) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	eax, 12345678				; 00bc614eH
	test	ecx, ecx
	je	SHORT $LN10@xmlPattern
	npad	7
$LL2@xmlPattern:

; 2578 :     int ret = 12345678;
; 2579 :     if (comp == NULL)
; 2580 :         return(-1);
; 2581 :     while (comp != NULL) {
; 2582 :         if (comp->stream == NULL)

	mov	edx, eax
	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	je	SHORT $LN10@xmlPattern

; 2584 : 	if (comp->stream->nbStep < ret)

	mov	eax, DWORD PTR [eax+4]

; 2585 : 	    ret = comp->stream->nbStep;
; 2586 : 	if (ret == 0)

	cmp	eax, edx
	cmovge	eax, edx
	test	eax, eax
	je	SHORT $LN11@xmlPattern

; 2588 : 	comp = comp->next;

	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	jne	SHORT $LL2@xmlPattern

; 2589 :     }
; 2590 :     return(ret);
; 2591 : }

	pop	ebp
	ret	0
$LN11@xmlPattern:

; 2587 : 	    return(0);

	xor	eax, eax

; 2589 :     }
; 2590 :     return(ret);
; 2591 : }

	pop	ebp
	ret	0
$LN10@xmlPattern:

; 2583 : 	    return(-1);

	or	eax, -1

; 2589 :     }
; 2590 :     return(ret);
; 2591 : }

	pop	ebp
	ret	0
_xmlPatternMinDepth ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatternMaxDepth
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_xmlPatternMaxDepth PROC				; COMDAT

; 2549 : xmlPatternMaxDepth(xmlPatternPtr comp) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _comp$[ebp]
	xor	edi, edi
	test	esi, esi
	je	SHORT $LN15@xmlPattern
$LL2@xmlPattern:

; 2550 :     int ret = 0, i;
; 2551 :     if (comp == NULL)
; 2552 :         return(-1);
; 2553 :     while (comp != NULL) {
; 2554 :         if (comp->stream == NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN15@xmlPattern

; 2556 : 	for (i = 0;i < comp->stream->nbStep;i++)

	mov	edx, DWORD PTR [eax+4]
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN5@xmlPattern

; 2557 : 	    if (comp->stream->steps[i].flags & XML_STREAM_STEP_DESC)

	mov	eax, DWORD PTR [eax+12]
	npad	5
$LL6@xmlPattern:
	test	BYTE PTR [eax], 1
	jne	SHORT $LN14@xmlPattern

; 2556 : 	for (i = 0;i < comp->stream->nbStep;i++)

	inc	ecx
	add	eax, 16					; 00000010H
	cmp	ecx, edx
	jl	SHORT $LL6@xmlPattern
$LN5@xmlPattern:

; 2559 : 	if (comp->stream->nbStep > ret)
; 2560 : 	    ret = comp->stream->nbStep;
; 2561 : 	comp = comp->next;

	mov	esi, DWORD PTR [esi+8]
	cmp	edx, edi
	cmovle	edx, edi
	mov	edi, edx
	test	esi, esi
	jne	SHORT $LL2@xmlPattern

; 2562 :     }
; 2563 :     return(ret);

	mov	eax, edi
	pop	edi

; 2564 : }

	pop	esi
	pop	ebp
	ret	0
$LN14@xmlPattern:
	pop	edi

; 2558 : 	        return(-2);

	mov	eax, -2					; fffffffeH

; 2564 : }

	pop	esi
	pop	ebp
	ret	0
$LN15@xmlPattern:
	pop	edi

; 2555 : 	    return(-1);

	or	eax, -1

; 2564 : }

	pop	esi
	pop	ebp
	ret	0
_xmlPatternMaxDepth ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatternStreamable
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_xmlPatternStreamable PROC				; COMDAT

; 2528 : xmlPatternStreamable(xmlPatternPtr comp) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _comp$[ebp]
	test	eax, eax
	jne	SHORT $LL2@xmlPattern

; 2529 :     if (comp == NULL)
; 2530 :         return(-1);

	or	eax, -1

; 2537 : }

	pop	ebp
	ret	0
	npad	7
$LL2@xmlPattern:

; 2531 :     while (comp != NULL) {
; 2532 :         if (comp->stream == NULL)

	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN8@xmlPattern

; 2534 : 	comp = comp->next;

	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	jne	SHORT $LL2@xmlPattern

; 2535 :     }
; 2536 :     return(1);

	mov	eax, 1

; 2537 : }

	pop	ebp
	ret	0
$LN8@xmlPattern:

; 2533 : 	    return(0);

	xor	eax, eax

; 2537 : }

	pop	ebp
	ret	0
_xmlPatternStreamable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatternMatch
_TEXT	SEGMENT
_states$1 = -16						; size = 12
_i$1$ = -4						; size = 4
_comp$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlPatternMatch PROC					; COMDAT

; 2465 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _comp$[ebp]
	test	eax, eax
	je	$LN5@xmlPattern

; 2466 :     int ret = 0;
; 2467 : 
; 2468 :     if ((comp == NULL) || (node == NULL))

	mov	ecx, DWORD PTR _node$[ebp]
	test	ecx, ecx
	je	$LN5@xmlPattern
	push	ebx
	push	esi
	push	edi
	npad	7
$LL2@xmlPattern:

; 2470 : 
; 2471 :     while (comp != NULL) {
; 2472 :         ret = xmlPatMatch(comp, node);

	mov	edi, ecx

; 501  :     xmlStepStates states = {0, 0, NULL}; /* // may require backtrack */

	mov	DWORD PTR _states$1[ebp], 0
	xor	ecx, ecx
	mov	DWORD PTR _states$1[ebp+4], 0

; 502  : 
; 503  :     if ((comp == NULL) || (node == NULL)) return(-1);
; 504  :     i = 0;

	xor	esi, esi
	mov	DWORD PTR _states$1[ebp+8], ecx
	mov	DWORD PTR _i$1$[ebp], esi

; 505  : restart:
; 506  :     for (;i < comp->nbStep;i++) {

	cmp	DWORD PTR [eax+20], ecx
	jle	$LN91@xmlPattern
$restart$167:

; 507  : 	step = &comp->steps[i];

	mov	ecx, DWORD PTR [eax+28]
	lea	eax, DWORD PTR [esi+esi*2]
	lea	ebx, DWORD PTR [ecx+eax*4]

; 508  : 	switch (step->op) {

	mov	eax, DWORD PTR [ebx]
	cmp	eax, 8
	ja	$LN9@xmlPattern
	jmp	DWORD PTR $LN166@xmlPattern[eax*4]
$LN21@xmlPattern:

; 509  :             case XML_OP_END:
; 510  : 		goto found;
; 511  :             case XML_OP_ROOT:
; 512  : 		if (node->type == XML_NAMESPACE_DECL)

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	$rollback$168

; 513  : 		    goto rollback;
; 514  : 		node = node->parent;

	mov	edi, DWORD PTR [edi+20]

; 515  : 		if ((node->type == XML_DOCUMENT_NODE) ||
; 516  : #ifdef LIBXML_DOCB_ENABLED
; 517  : 		    (node->type == XML_DOCB_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 9
	je	$LN9@xmlPattern
	cmp	eax, 21					; 00000015H
	je	$LN9@xmlPattern
	cmp	eax, 13					; 0000000dH
	jne	$rollback$168

; 518  : #endif
; 519  : 		    (node->type == XML_HTML_DOCUMENT_NODE))
; 520  : 		    continue;

	jmp	$LN9@xmlPattern
$LN25@xmlPattern:

; 521  : 		goto rollback;
; 522  :             case XML_OP_ELEM:
; 523  : 		if (node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [edi+4], 1
	jne	$rollback$168
$LN164@xmlPattern:

; 505  : restart:
; 506  :     for (;i < comp->nbStep;i++) {

	mov	ecx, DWORD PTR [ebx+4]
	test	ecx, ecx
	je	$LN9@xmlPattern
	mov	edx, DWORD PTR [edi+8]
	mov	al, BYTE PTR [ecx]
	cmp	al, BYTE PTR [edx]
	jne	$rollback$168
	push	edx
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$rollback$168
	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	jne	SHORT $LN30@xmlPattern
	cmp	DWORD PTR [ebx+8], eax
	jne	$rollback$168
	jmp	$LN9@xmlPattern
$LN30@xmlPattern:
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	$LN9@xmlPattern
	mov	eax, DWORD PTR [ebx+8]
$LN163@xmlPattern:
	test	eax, eax
	je	$rollback$168
	push	ecx
$LN162@xmlPattern:
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$rollback$168
	jmp	$LN9@xmlPattern
$LN36@xmlPattern:

; 524  : 		    goto rollback;
; 525  : 		if (step->value == NULL)
; 526  : 		    continue;
; 527  : 		if (step->value[0] != node->name[0])
; 528  : 		    goto rollback;
; 529  : 		if (!xmlStrEqual(step->value, node->name))
; 530  : 		    goto rollback;
; 531  : 
; 532  : 		/* Namespace test */
; 533  : 		if (node->ns == NULL) {
; 534  : 		    if (step->value2 != NULL)
; 535  : 			goto rollback;
; 536  : 		} else if (node->ns->href != NULL) {
; 537  : 		    if (step->value2 == NULL)
; 538  : 			goto rollback;
; 539  : 		    if (!xmlStrEqual(step->value2, node->ns->href))
; 540  : 			goto rollback;
; 541  : 		}
; 542  : 		continue;
; 543  :             case XML_OP_CHILD: {
; 544  : 		xmlNodePtr lst;
; 545  : 
; 546  : 		if ((node->type != XML_ELEMENT_NODE) &&
; 547  : 		    (node->type != XML_DOCUMENT_NODE) &&
; 548  : #ifdef LIBXML_DOCB_ENABLED
; 549  : 		    (node->type != XML_DOCB_DOCUMENT_NODE) &&

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 1
	je	SHORT $LN37@xmlPattern
	cmp	eax, 9
	je	SHORT $LN37@xmlPattern
	cmp	eax, 21					; 00000015H
	je	SHORT $LN37@xmlPattern
	cmp	eax, 13					; 0000000dH
	jne	$rollback$168
$LN37@xmlPattern:

; 550  : #endif
; 551  : 		    (node->type != XML_HTML_DOCUMENT_NODE))
; 552  : 		    goto rollback;
; 553  : 
; 554  : 		lst = node->children;
; 555  : 
; 556  : 		if (step->value != NULL) {

	cmp	DWORD PTR [ebx+4], 0
	mov	esi, DWORD PTR [edi+12]
	je	$rollback$168

; 557  : 		    while (lst != NULL) {

	test	esi, esi
	je	$rollback$168
$LL14@xmlPattern:

; 558  : 			if ((lst->type == XML_ELEMENT_NODE) &&
; 559  : 			    (step->value[0] == lst->name[0]) &&

	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN39@xmlPattern
	mov	edx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [esi+8]
	mov	al, BYTE PTR [edx]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN39@xmlPattern
	push	ecx
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN157@xmlPattern
$LN39@xmlPattern:

; 560  : 			    (xmlStrEqual(step->value, lst->name)))
; 561  : 			    break;
; 562  : 			lst = lst->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL14@xmlPattern

; 563  : 		    }
; 564  : 		    if (lst != NULL)

	jmp	$rollback$168
$LN41@xmlPattern:

; 565  : 			continue;
; 566  : 		}
; 567  : 		goto rollback;
; 568  : 	    }
; 569  :             case XML_OP_ATTR:
; 570  : 		if (node->type != XML_ATTRIBUTE_NODE)

	cmp	DWORD PTR [edi+4], 2
	jne	$rollback$168

; 571  : 		    goto rollback;
; 572  : 		if (step->value != NULL) {

	mov	ecx, DWORD PTR [ebx+4]
	test	ecx, ecx
	je	SHORT $LN45@xmlPattern

; 573  : 		    if (step->value[0] != node->name[0])

	mov	edx, DWORD PTR [edi+8]
	mov	al, BYTE PTR [ecx]
	cmp	al, BYTE PTR [edx]
	jne	$rollback$168

; 574  : 			goto rollback;
; 575  : 		    if (!xmlStrEqual(step->value, node->name))

	push	edx
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$rollback$168
$LN45@xmlPattern:

; 576  : 			goto rollback;
; 577  : 		}
; 578  : 		/* Namespace test */
; 579  : 		if (node->ns == NULL) {

	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [ebx+8]
	test	ecx, ecx
	jne	SHORT $LN46@xmlPattern

; 580  : 		    if (step->value2 != NULL)

	test	eax, eax
	jne	$rollback$168

; 581  : 			goto rollback;
; 582  : 		} else if (step->value2 != NULL) {

	jmp	$LN9@xmlPattern
$LN46@xmlPattern:
	test	eax, eax
	je	$LN9@xmlPattern

; 583  : 		    if (!xmlStrEqual(step->value2, node->ns->href))

	push	DWORD PTR [ecx+8]

; 584  : 			goto rollback;
; 585  : 		}
; 586  : 		continue;

	jmp	$LN162@xmlPattern
$LN51@xmlPattern:

; 587  :             case XML_OP_PARENT:
; 588  : 		if ((node->type == XML_DOCUMENT_NODE) ||
; 589  : 		    (node->type == XML_HTML_DOCUMENT_NODE) ||
; 590  : #ifdef LIBXML_DOCB_ENABLED
; 591  : 		    (node->type == XML_DOCB_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 9
	je	$rollback$168
	cmp	eax, 13					; 0000000dH
	je	$rollback$168
	cmp	eax, 21					; 00000015H
	je	$rollback$168
	cmp	eax, 18					; 00000012H
	je	$rollback$168

; 592  : #endif
; 593  : 		    (node->type == XML_NAMESPACE_DECL))
; 594  : 		    goto rollback;
; 595  : 		node = node->parent;

	mov	edi, DWORD PTR [edi+20]

; 596  : 		if (node == NULL)

	test	edi, edi
	je	$rollback$168

; 597  : 		    goto rollback;
; 598  : 		if (step->value == NULL)
; 599  : 		    continue;
; 600  : 		if (step->value[0] != node->name[0])
; 601  : 		    goto rollback;
; 602  : 		if (!xmlStrEqual(step->value, node->name))
; 603  : 		    goto rollback;
; 604  : 		/* Namespace test */
; 605  : 		if (node->ns == NULL) {
; 606  : 		    if (step->value2 != NULL)
; 607  : 			goto rollback;
; 608  : 		} else if (node->ns->href != NULL) {

	jmp	$LN164@xmlPattern
$LN64@xmlPattern:

; 609  : 		    if (step->value2 == NULL)
; 610  : 			goto rollback;
; 611  : 		    if (!xmlStrEqual(step->value2, node->ns->href))
; 612  : 			goto rollback;
; 613  : 		}
; 614  : 		continue;
; 615  :             case XML_OP_ANCESTOR:
; 616  : 		/* TODO: implement coalescing of ANCESTOR/NODE ops */
; 617  : 		if (step->value == NULL) {

	cmp	DWORD PTR [ebx+4], 0
	jne	SHORT $LN68@xmlPattern

; 618  : 		    i++;

	inc	esi

; 619  : 		    step = &comp->steps[i];

	lea	eax, DWORD PTR [esi+esi*2]
	lea	ebx, DWORD PTR [ecx+eax*4]

; 620  : 		    if (step->op == XML_OP_ROOT)

	mov	eax, DWORD PTR [ebx]
	cmp	eax, 1
	je	$found$169

; 621  : 			goto found;
; 622  : 		    if (step->op != XML_OP_ELEM)

	cmp	eax, 2
	jne	$rollback$168

; 623  : 			goto rollback;
; 624  : 		    if (step->value == NULL)

	cmp	DWORD PTR [ebx+4], 0
	je	$LN126@xmlPattern
$LN68@xmlPattern:

; 626  : 		}
; 627  : 		if (node == NULL)

	test	edi, edi
	je	$rollback$168

; 628  : 		    goto rollback;
; 629  : 		if ((node->type == XML_DOCUMENT_NODE) ||
; 630  : 		    (node->type == XML_HTML_DOCUMENT_NODE) ||
; 631  : #ifdef LIBXML_DOCB_ENABLED
; 632  : 		    (node->type == XML_DOCB_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 9
	je	$rollback$168
	cmp	eax, 13					; 0000000dH
	je	$rollback$168
	cmp	eax, 21					; 00000015H
	je	$rollback$168
	cmp	eax, 18					; 00000012H
	je	$rollback$168

; 633  : #endif
; 634  : 		    (node->type == XML_NAMESPACE_DECL))
; 635  : 		    goto rollback;
; 636  : 		node = node->parent;

	mov	edi, DWORD PTR [edi+20]

; 637  : 		while (node != NULL) {

	test	edi, edi
	je	$rollback$168
$LL16@xmlPattern:

; 638  : 		    if ((node->type == XML_ELEMENT_NODE) &&
; 639  : 			(step->value[0] == node->name[0]) &&

	cmp	DWORD PTR [edi+4], 1
	jne	SHORT $LN77@xmlPattern
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [edi+8]
	mov	al, BYTE PTR [ecx]
	cmp	al, BYTE PTR [edx]
	jne	SHORT $LN77@xmlPattern
	push	edx
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN77@xmlPattern

; 640  : 			(xmlStrEqual(step->value, node->name))) {
; 641  : 			/* Namespace test */
; 642  : 			if (node->ns == NULL) {

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	jne	SHORT $LN73@xmlPattern

; 643  : 			    if (step->value2 == NULL)

	cmp	DWORD PTR [ebx+8], eax
	jne	SHORT $LN77@xmlPattern
$LN102@xmlPattern:

; 652  : 		}
; 653  : 		if (node == NULL)

	test	edi, edi
	je	SHORT $rollback$168

; 654  : 		    goto rollback;
; 655  : 		/*
; 656  : 		 * prepare a potential rollback from here
; 657  : 		 * for ancestors of that node.
; 658  : 		 */
; 659  : 		if (step->op == XML_OP_ANCESTOR)
; 660  : 		    xmlPatPushState(&states, i, node);
; 661  : 		else
; 662  : 		    xmlPatPushState(&states, i - 1, node);
; 663  : 		continue;

	cmp	DWORD PTR [ebx], 6
	lea	eax, DWORD PTR [esi-1]
	mov	ecx, esi
	cmovne	ecx, eax
	lea	eax, DWORD PTR _states$1[ebp]
	push	edi
	push	ecx
	push	eax
	call	_xmlPatPushState
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN9@xmlPattern
$LN73@xmlPattern:

; 644  : 				break;
; 645  : 			} else if (node->ns->href != NULL) {

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN77@xmlPattern

; 646  : 			    if ((step->value2 != NULL) &&

	mov	eax, DWORD PTR [ebx+8]
	test	eax, eax
	je	SHORT $LN77@xmlPattern
	push	ecx
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN102@xmlPattern
$LN77@xmlPattern:

; 647  : 			        (xmlStrEqual(step->value2, node->ns->href)))
; 648  : 				break;
; 649  : 			}
; 650  : 		    }
; 651  : 		    node = node->parent;

	mov	edi, DWORD PTR [edi+20]
	test	edi, edi
	jne	SHORT $LL16@xmlPattern

; 637  : 		while (node != NULL) {

	jmp	SHORT $rollback$168
$LN81@xmlPattern:

; 664  :             case XML_OP_NS:
; 665  : 		if (node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [edi+4], 1
	jne	SHORT $rollback$168

; 666  : 		    goto rollback;
; 667  : 		if (node->ns == NULL) {

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	jne	SHORT $LN83@xmlPattern

; 668  : 		    if (step->value != NULL)

	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $rollback$168

; 669  : 			goto rollback;
; 670  : 		} else if (node->ns->href != NULL) {

	jmp	SHORT $LN9@xmlPattern
$LN83@xmlPattern:
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN9@xmlPattern

; 671  : 		    if (step->value == NULL)

	mov	eax, DWORD PTR [ebx+4]

; 672  : 			goto rollback;
; 673  : 		    if (!xmlStrEqual(step->value, node->ns->href))
; 674  : 			goto rollback;
; 675  : 		}
; 676  : 		break;

	jmp	$LN163@xmlPattern
$LN89@xmlPattern:

; 677  :             case XML_OP_ALL:
; 678  : 		if (node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [edi+4], 1
	je	SHORT $LN9@xmlPattern
$rollback$168:

; 689  : rollback:
; 690  :     /* got an error try to rollback */
; 691  :     if (states.states == NULL)

	mov	eax, DWORD PTR _states$1[ebp+8]
	test	eax, eax
	je	SHORT $LN150@xmlPattern

; 692  : 	return(0);
; 693  :     if (states.nbstates <= 0) {

	mov	edx, DWORD PTR _states$1[ebp]
	test	edx, edx
	jle	SHORT $LN136@xmlPattern

; 695  : 	return(0);
; 696  :     }
; 697  :     states.nbstates--;
; 698  :     i = states.states[states.nbstates].step;

	mov	esi, DWORD PTR [eax+edx*8-8]
	dec	edx
	mov	DWORD PTR _states$1[ebp], edx

; 699  :     node = states.states[states.nbstates].node;

	mov	edi, DWORD PTR [eax+edx*8+4]
	jmp	SHORT $LN161@xmlPattern
$LN157@xmlPattern:

; 558  : 			if ((lst->type == XML_ELEMENT_NODE) &&
; 559  : 			    (step->value[0] == lst->name[0]) &&

	mov	esi, DWORD PTR _i$1$[ebp]
$LN9@xmlPattern:

; 505  : restart:
; 506  :     for (;i < comp->nbStep;i++) {

	inc	esi
$LN161@xmlPattern:
	mov	eax, DWORD PTR _comp$[ebp]
	mov	DWORD PTR _i$1$[ebp], esi
	cmp	esi, DWORD PTR [eax+20]
	jl	$restart$167
$found$169:

; 679  : 		    goto rollback;
; 680  : 		break;
; 681  : 	}
; 682  :     }
; 683  : found:
; 684  :     if (states.states != NULL) {

	mov	ecx, DWORD PTR _states$1[ebp+8]
	test	ecx, ecx
	je	SHORT $LN91@xmlPattern

; 685  :         /* Free the rollback states */
; 686  : 	xmlFree(states.states);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN91@xmlPattern:
	pop	edi
	pop	esi

; 687  :     }
; 688  :     return(1);

	mov	eax, 1
	pop	ebx

; 2478 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN136@xmlPattern:

; 694  : 	xmlFree(states.states);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN150@xmlPattern:

; 2473 : 	if (ret != 0)
; 2474 : 	    return(ret);
; 2475 : 	comp = comp->next;

	mov	eax, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _comp$[ebp], eax
	test	eax, eax
	je	SHORT $LN3@xmlPattern

; 624  : 		    if (step->value == NULL)

	mov	ecx, DWORD PTR _node$[ebp]
	jmp	$LL2@xmlPattern
$LN126@xmlPattern:
	pop	edi
	pop	esi

; 625  : 			return(-1);

	or	eax, -1
	pop	ebx

; 2478 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlPattern:
	pop	edi
	pop	esi

; 2476 :     }
; 2477 :     return(ret);

	xor	eax, eax
	pop	ebx

; 2478 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlPattern:

; 2469 :         return(-1);

	or	eax, -1

; 2478 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN166@xmlPattern:
	DD	$found$169
	DD	$LN21@xmlPattern
	DD	$LN25@xmlPattern
	DD	$LN36@xmlPattern
	DD	$LN41@xmlPattern
	DD	$LN51@xmlPattern
	DD	$LN64@xmlPattern
	DD	$LN81@xmlPattern
	DD	$LN89@xmlPattern
_xmlPatternMatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatterncompile
_TEXT	SEGMENT
_type$1$ = -12						; size = 4
_streamable$1$ = -8					; size = 4
_ret$1$ = -4						; size = 4
_tmp$1$ = 8						; size = 4
_pattern$ = 8						; size = 4
_dict$ = 12						; size = 4
_flags$ = 16						; size = 4
_namespaces$ = 20					; size = 4
_xmlPatterncompile PROC					; COMDAT

; 2360 :                   const xmlChar **namespaces) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _pattern$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _ret$1$[ebp], ebx
	mov	DWORD PTR _type$1$[ebp], ebx
	mov	DWORD PTR _streamable$1$[ebp], 1
	test	edx, edx
	jne	SHORT $LN8@xmlPattern

; 2361 :     xmlPatternPtr ret = NULL, cur;
; 2362 :     xmlPatParserContextPtr ctxt = NULL;
; 2363 :     const xmlChar *or, *start;
; 2364 :     xmlChar *tmp = NULL;
; 2365 :     int type = 0;
; 2366 :     int streamable = 1;
; 2367 : 
; 2368 :     if (pattern == NULL)
; 2369 :         return(NULL);

	xor	eax, eax
	pop	ebx

; 2452 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlPattern:

; 2370 : 
; 2371 :     start = pattern;
; 2372 :     or = start;
; 2373 :     while (*or != 0) {

	mov	al, BYTE PTR [edx]
	push	esi
	push	edi
	mov	edi, edx
	test	al, al
	je	$LN7@xmlPattern
	mov	esi, DWORD PTR _namespaces$[ebp]
	mov	ecx, DWORD PTR _flags$[ebp]
$LL70@xmlPattern:

; 2374 : 	tmp = NULL;

	mov	ebx, DWORD PTR _dict$[ebp]
	mov	DWORD PTR _tmp$1$[ebp], 0

; 2375 : 	while ((*or != 0) && (*or != '|')) or++;

	test	al, al
	je	SHORT $LN67@xmlPattern
$LL4@xmlPattern:
	mov	cl, al
	cmp	al, 124					; 0000007cH
	je	SHORT $LN5@xmlPattern
	mov	al, BYTE PTR [edi+1]
	inc	edi
	mov	cl, al
	test	al, al
	jne	SHORT $LL4@xmlPattern
$LN5@xmlPattern:

; 2376 :         if (*or == 0)

	test	cl, cl
	je	SHORT $LN67@xmlPattern

; 2378 : 	else {
; 2379 : 	    tmp = xmlStrndup(start, or - start);

	mov	eax, edi
	sub	eax, edx
	push	eax
	push	edx
	call	_xmlStrndup
	mov	esi, eax
	add	esp, 8
	xor	ebx, ebx
	mov	DWORD PTR _tmp$1$[ebp], esi

; 2380 : 	    if (tmp != NULL) {

	test	esi, esi
	je	SHORT $LN11@xmlPattern

; 2381 : 		ctxt = xmlNewPatParserContext(tmp, dict, namespaces);

	push	DWORD PTR _namespaces$[ebp]
	push	DWORD PTR _dict$[ebp]
	push	esi
	call	_xmlNewPatParserContext
	add	esp, 12					; 0000000cH
	mov	ebx, eax
$LN11@xmlPattern:

; 2382 : 	    }
; 2383 : 	    or++;

	inc	edi
	jmp	SHORT $LN10@xmlPattern
$LN67@xmlPattern:

; 2377 : 	    ctxt = xmlNewPatParserContext(start, dict, namespaces);

	push	esi
	push	ebx
	push	edx
	call	_xmlNewPatParserContext
	add	esp, 12					; 0000000cH
	mov	ebx, eax
$LN10@xmlPattern:

; 2384 : 	}
; 2385 : 	if (ctxt == NULL) goto error;

	test	ebx, ebx
	je	$LN44@xmlPattern

; 206  :     cur = (xmlPatternPtr) xmlMalloc(sizeof(xmlPattern));

	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 207  :     if (cur == NULL) {

	test	esi, esi
	je	$error$75

; 208  : 	ERROR(NULL, NULL, NULL,
; 209  : 		"xmlNewPattern : malloc failed\n");
; 210  : 	return(NULL);
; 211  :     }
; 212  :     memset(cur, 0, sizeof(xmlPattern));

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0

; 213  :     cur->maxStep = 10;
; 214  :     cur->steps = (xmlStepOpPtr) xmlMalloc(cur->maxStep * sizeof(xmlStepOp));

	push	120					; 00000078H
	mov	DWORD PTR [esi+24], 10			; 0000000aH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+28], eax

; 215  :     if (cur->steps == NULL) {

	test	eax, eax
	je	$LN66@xmlPattern

; 2386 : 	cur = xmlNewPattern();
; 2387 : 	if (cur == NULL) goto error;
; 2388 : 	/*
; 2389 : 	* Assign string dict.
; 2390 : 	*/
; 2391 : 	if (dict) {

	mov	eax, DWORD PTR _dict$[ebp]
	test	eax, eax
	je	SHORT $LN14@xmlPattern

; 2392 : 	    cur->dict = dict;
; 2393 : 	    xmlDictReference(dict);

	push	eax
	mov	DWORD PTR [esi+4], eax
	call	_xmlDictReference
	add	esp, 4
$LN14@xmlPattern:

; 2394 : 	}
; 2395 : 	if (ret == NULL)

	mov	ecx, DWORD PTR _ret$1$[ebp]
	test	ecx, ecx
	jne	SHORT $LN15@xmlPattern

; 2396 : 	    ret = cur;

	mov	DWORD PTR _ret$1$[ebp], esi
	jmp	SHORT $LN16@xmlPattern
$LN15@xmlPattern:

; 2397 : 	else {
; 2398 : 	    cur->next = ret->next;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax

; 2399 : 	    ret->next = cur;

	mov	DWORD PTR [ecx+8], esi
$LN16@xmlPattern:

; 2400 : 	}
; 2401 : 	cur->flags = flags;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [esi+16], eax

; 2402 : 	ctxt->comp = cur;

	mov	DWORD PTR [ebx+16], esi

; 2403 : 
; 2404 : 	if (XML_STREAM_XS_IDC(cur))

	test	BYTE PTR [esi+16], 6
	push	ebx
	je	SHORT $LN17@xmlPattern

; 2405 : 	    xmlCompileIDCXPathPath(ctxt);

	call	_xmlCompileIDCXPathPath
	jmp	SHORT $LN73@xmlPattern
$LN17@xmlPattern:

; 2406 : 	else
; 2407 : 	    xmlCompilePathPattern(ctxt);

	call	_xmlCompilePathPattern
$LN73@xmlPattern:

; 2408 : 	if (ctxt->error != 0)

	add	esp, 4
	cmp	DWORD PTR [ebx+8], 0
	jne	$error$75

; 331  :     memset(ctxt, -1, sizeof(xmlPatParserContext));

	movaps	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movups	XMMWORD PTR [ebx], xmm0

; 332  :     xmlFree(ctxt);

	push	ebx
	movups	XMMWORD PTR [ebx+16], xmm0
	call	DWORD PTR _xmlFree

; 2409 : 	    goto error;
; 2410 : 	xmlFreePatParserContext(ctxt);
; 2411 : 	ctxt = NULL;
; 2412 : 
; 2413 : 
; 2414 :         if (streamable) {

	mov	ebx, DWORD PTR _streamable$1$[ebp]

; 332  :     xmlFree(ctxt);

	add	esp, 4

; 2409 : 	    goto error;
; 2410 : 	xmlFreePatParserContext(ctxt);
; 2411 : 	ctxt = NULL;
; 2412 : 
; 2413 : 
; 2414 :         if (streamable) {

	test	ebx, ebx
	je	SHORT $LN28@xmlPattern

; 2415 : 	    if (type == 0) {

	mov	eax, DWORD PTR _type$1$[ebp]
	test	eax, eax
	jne	$LN21@xmlPattern

; 2416 : 	        type = cur->flags & (PAT_FROM_ROOT | PAT_FROM_CUR);

	mov	eax, DWORD PTR [esi+16]
	and	eax, 768				; 00000300H
	mov	DWORD PTR _type$1$[ebp], eax
$LN27@xmlPattern:

; 2423 : 	    }
; 2424 : 	}
; 2425 : 	if (streamable)

	test	ebx, ebx
	je	SHORT $LN28@xmlPattern

; 2426 : 	    xmlStreamCompile(cur);

	push	esi
	call	_xmlStreamCompile
	add	esp, 4
$LN28@xmlPattern:

; 2427 : 	if (xmlReversePattern(cur) < 0)

	push	esi
	call	_xmlReversePattern
	add	esp, 4
	test	eax, eax
	js	$LN44@xmlPattern

; 2428 : 	    goto error;
; 2429 : 	if (tmp != NULL) {

	mov	eax, DWORD PTR _tmp$1$[ebp]
	test	eax, eax
	je	SHORT $LN30@xmlPattern

; 2430 : 	    xmlFree(tmp);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN30@xmlPattern:

; 2431 : 	    tmp = NULL;
; 2432 : 	}
; 2433 : 	start = or;

	mov	al, BYTE PTR [edi]
	mov	edx, edi
	mov	esi, DWORD PTR _namespaces$[ebp]
	test	al, al
	jne	$LL70@xmlPattern

; 2434 :     }
; 2435 :     if (streamable == 0) {

	test	ebx, ebx
	mov	ebx, DWORD PTR _ret$1$[ebp]
	jne	SHORT $LN7@xmlPattern

; 2436 :         cur = ret;

	mov	esi, ebx

; 2437 : 	while (cur != NULL) {

	test	ebx, ebx
	je	SHORT $LN7@xmlPattern
$LL6@xmlPattern:

; 2438 : 	    if (cur->stream != NULL) {

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN68@xmlPattern

; 2439 : 		xmlFreeStreamComp(cur->stream);

	push	eax
	call	_xmlFreeStreamComp
	add	esp, 4

; 2440 : 		cur->stream = NULL;

	mov	DWORD PTR [esi+32], 0
$LN68@xmlPattern:

; 2441 : 	    }
; 2442 : 	    cur = cur->next;

	mov	esi, DWORD PTR [esi+8]
	test	esi, esi
	jne	SHORT $LL6@xmlPattern
$LN7@xmlPattern:
	pop	edi
	pop	esi

; 2443 : 	}
; 2444 :     }
; 2445 : 
; 2446 :     return(ret);

	mov	eax, ebx
	pop	ebx

; 2452 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlPattern:

; 2417 : 	    } else if (type == PAT_FROM_ROOT) {

	cmp	eax, 256				; 00000100H
	jne	SHORT $LN23@xmlPattern

; 2418 : 	        if (cur->flags & PAT_FROM_CUR)

	test	DWORD PTR [esi+16], 512			; 00000200H

; 2419 : 		    streamable = 0;
; 2420 : 	    } else if (type == PAT_FROM_CUR) {

	mov	eax, 0
	cmove	eax, ebx
	mov	ebx, eax
	mov	DWORD PTR _streamable$1$[ebp], ebx
	jmp	$LN27@xmlPattern
$LN23@xmlPattern:
	cmp	eax, 512				; 00000200H
	jne	$LN27@xmlPattern

; 2421 : 	        if (cur->flags & PAT_FROM_ROOT)

	test	DWORD PTR [esi+16], 256			; 00000100H
	je	$LN27@xmlPattern

; 2422 : 		    streamable = 0;

	xor	ebx, ebx
	mov	DWORD PTR _streamable$1$[ebp], ebx

; 2423 : 	    }
; 2424 : 	}
; 2425 : 	if (streamable)

	jmp	$LN28@xmlPattern
$LN66@xmlPattern:

; 216  :         xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$error$75:

; 331  :     memset(ctxt, -1, sizeof(xmlPatParserContext));

	movaps	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movups	XMMWORD PTR [ebx], xmm0

; 332  :     xmlFree(ctxt);

	push	ebx
	movups	XMMWORD PTR [ebx+16], xmm0
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN44@xmlPattern:

; 2447 : error:
; 2448 :     if (ctxt != NULL) xmlFreePatParserContext(ctxt);
; 2449 :     if (ret != NULL) xmlFreePattern(ret);

	mov	ebx, DWORD PTR _ret$1$[ebp]
	test	ebx, ebx
	je	SHORT $LN34@xmlPattern
	push	ebx
	call	_xmlFreePattern
	add	esp, 4
$LN34@xmlPattern:

; 2450 :     if (tmp != NULL) xmlFree(tmp);

	mov	eax, DWORD PTR _tmp$1$[ebp]
	test	eax, eax
	je	SHORT $LN35@xmlPattern
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN35@xmlPattern:

; 2451 :     return(NULL);

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 2452 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlPatterncompile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlFreePatternList
_TEXT	SEGMENT
tv329 = -4						; size = 4
_comp$ = 8						; size = 4
_xmlFreePatternList PROC				; COMDAT

; 269  : xmlFreePatternList(xmlPatternPtr comp) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _comp$[ebp]
	test	ebx, ebx
	je	$LN3@xmlFreePat
	push	esi
	push	edi
	npad	4
$LL2@xmlFreePat:

; 273  : 	cur = comp;

	mov	esi, ebx

; 274  : 	comp = comp->next;

	lea	eax, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR _comp$[ebp], ebx

; 275  : 	cur->next = NULL;

	mov	DWORD PTR [eax], 0

; 239  :     if (comp->stream != NULL)

	mov	edi, DWORD PTR [esi+32]
	test	edi, edi
	je	SHORT $LN20@xmlFreePat

; 1526 :         if (comp->steps != NULL)

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN21@xmlFreePat

; 1527 : 	    xmlFree(comp->steps);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN21@xmlFreePat:

; 1528 : 	if (comp->dict != NULL)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN22@xmlFreePat

; 1529 : 	    xmlDictFree(comp->dict);

	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN22@xmlFreePat:

; 1530 :         xmlFree(comp);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN20@xmlFreePat:

; 241  :     if (comp->pattern != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN12@xmlFreePat

; 242  : 	xmlFree((xmlChar *)comp->pattern);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlFreePat:

; 243  :     if (comp->steps != NULL) {

	cmp	DWORD PTR [esi+28], 0
	je	SHORT $LN13@xmlFreePat

; 244  :         if (comp->dict == NULL) {

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN7@xmlFreePat

; 245  : 	    for (i = 0;i < comp->nbStep;i++) {

	xor	ebx, ebx
	cmp	DWORD PTR [esi+20], ebx
	jle	SHORT $LN31@xmlFreePat
	xor	eax, eax
	mov	DWORD PTR tv329[ebp], eax
	npad	6
$LL8@xmlFreePat:

; 246  : 		op = &comp->steps[i];

	mov	edi, DWORD PTR [esi+28]
	add	edi, eax

; 247  : 		if (op->value != NULL)

	mov	ecx, DWORD PTR [edi+4]
	test	ecx, ecx
	je	SHORT $LN15@xmlFreePat

; 248  : 		    xmlFree((xmlChar *) op->value);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR tv329[ebp]
	add	esp, 4
$LN15@xmlFreePat:

; 249  : 		if (op->value2 != NULL)

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN6@xmlFreePat

; 250  : 		    xmlFree((xmlChar *) op->value2);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR tv329[ebp]
	add	esp, 4
$LN6@xmlFreePat:

; 245  : 	    for (i = 0;i < comp->nbStep;i++) {

	inc	ebx
	add	eax, 12					; 0000000cH
	mov	DWORD PTR tv329[ebp], eax
	cmp	ebx, DWORD PTR [esi+20]
	jl	SHORT $LL8@xmlFreePat
$LN31@xmlFreePat:

; 251  : 	    }
; 252  : 	}
; 253  : 	xmlFree(comp->steps);

	mov	ebx, DWORD PTR _comp$[ebp]
$LN7@xmlFreePat:
	push	DWORD PTR [esi+28]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlFreePat:

; 254  :     }
; 255  :     if (comp->dict != NULL)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN17@xmlFreePat

; 256  :         xmlDictFree(comp->dict);

	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN17@xmlFreePat:

; 257  : 
; 258  :     memset(comp, -1, sizeof(xmlPattern));

	movaps	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movups	XMMWORD PTR [esi], xmm0

; 259  :     xmlFree(comp);

	push	esi
	movups	XMMWORD PTR [esi+16], xmm0
	mov	DWORD PTR [esi+32], -1
	call	DWORD PTR _xmlFree
	add	esp, 4

; 270  :     xmlPatternPtr cur;
; 271  : 
; 272  :     while (comp != NULL) {

	test	ebx, ebx
	jne	$LL2@xmlFreePat
	pop	edi
	pop	esi
$LN3@xmlFreePat:
	pop	ebx

; 276  : 	xmlFreePattern(cur);
; 277  :     }
; 278  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFreePatternList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlFreePattern
_TEXT	SEGMENT
tv263 = 8						; size = 4
_comp$ = 8						; size = 4
_xmlFreePattern PROC					; COMDAT

; 231  : xmlFreePattern(xmlPatternPtr comp) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _comp$[ebp]
	test	esi, esi
	je	$LN1@xmlFreePat

; 232  :     xmlStepOpPtr op;
; 233  :     int i;
; 234  : 
; 235  :     if (comp == NULL)
; 236  : 	return;
; 237  :     if (comp->next != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN6@xmlFreePat

; 238  :         xmlFreePattern(comp->next);

	push	eax
	call	_xmlFreePattern
	add	esp, 4
$LN6@xmlFreePat:

; 239  :     if (comp->stream != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN7@xmlFreePat

; 240  :         xmlFreeStreamComp(comp->stream);

	push	eax
	call	_xmlFreeStreamComp
	add	esp, 4
$LN7@xmlFreePat:

; 241  :     if (comp->pattern != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN8@xmlFreePat

; 242  : 	xmlFree((xmlChar *)comp->pattern);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlFreePat:

; 243  :     if (comp->steps != NULL) {

	cmp	DWORD PTR [esi+28], 0
	je	SHORT $LN9@xmlFreePat

; 244  :         if (comp->dict == NULL) {

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN3@xmlFreePat

; 245  : 	    for (i = 0;i < comp->nbStep;i++) {

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [esi+20], ebx
	jle	SHORT $LN19@xmlFreePat
	xor	eax, eax
	mov	DWORD PTR tv263[ebp], eax
	push	edi
$LL4@xmlFreePat:

; 246  : 		op = &comp->steps[i];

	mov	edi, DWORD PTR [esi+28]
	add	edi, eax

; 247  : 		if (op->value != NULL)

	mov	ecx, DWORD PTR [edi+4]
	test	ecx, ecx
	je	SHORT $LN11@xmlFreePat

; 248  : 		    xmlFree((xmlChar *) op->value);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR tv263[ebp]
	add	esp, 4
$LN11@xmlFreePat:

; 249  : 		if (op->value2 != NULL)

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN2@xmlFreePat

; 250  : 		    xmlFree((xmlChar *) op->value2);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR tv263[ebp]
	add	esp, 4
$LN2@xmlFreePat:

; 245  : 	    for (i = 0;i < comp->nbStep;i++) {

	inc	ebx
	add	eax, 12					; 0000000cH
	mov	DWORD PTR tv263[ebp], eax
	cmp	ebx, DWORD PTR [esi+20]
	jl	SHORT $LL4@xmlFreePat
	pop	edi
$LN19@xmlFreePat:
	pop	ebx
$LN3@xmlFreePat:

; 251  : 	    }
; 252  : 	}
; 253  : 	xmlFree(comp->steps);

	push	DWORD PTR [esi+28]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlFreePat:

; 254  :     }
; 255  :     if (comp->dict != NULL)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN13@xmlFreePat

; 256  :         xmlDictFree(comp->dict);

	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN13@xmlFreePat:

; 257  : 
; 258  :     memset(comp, -1, sizeof(xmlPattern));

	movaps	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movups	XMMWORD PTR [esi], xmm0

; 259  :     xmlFree(comp);

	push	esi
	movups	XMMWORD PTR [esi+16], xmm0
	mov	DWORD PTR [esi+32], -1
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreePat:
	pop	esi

; 260  : }

	pop	ebp
	ret	0
_xmlFreePattern ENDP
_TEXT	ENDS
END
