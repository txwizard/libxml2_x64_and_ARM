; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\buf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__7B7A869E_ctype@h DB 01H
__4FDA1B3E_buf@c DB 01H
msvcjmc	ENDS
PUBLIC	_xmlBufContent
PUBLIC	_xmlBufEnd
PUBLIC	_xmlBufUse
PUBLIC	_xmlBufShrink
PUBLIC	_xmlBufCreate
PUBLIC	_xmlBufCreateSize
PUBLIC	_xmlBufCreateStatic
PUBLIC	_xmlBufSetAllocationScheme
PUBLIC	_xmlBufGetAllocationScheme
PUBLIC	_xmlBufFree
PUBLIC	_xmlBufEmpty
PUBLIC	_xmlBufGrow
PUBLIC	_xmlBufInflate
PUBLIC	_xmlBufResize
PUBLIC	_xmlBufAdd
PUBLIC	_xmlBufAddHead
PUBLIC	_xmlBufCat
PUBLIC	_xmlBufCCat
PUBLIC	_xmlBufWriteCHAR
PUBLIC	_xmlBufWriteChar
PUBLIC	_xmlBufWriteQuotedString
PUBLIC	_xmlBufAvail
PUBLIC	_xmlBufLength
PUBLIC	_xmlBufIsEmpty
PUBLIC	_xmlBufAddLen
PUBLIC	_xmlBufErase
PUBLIC	_xmlBufDetach
PUBLIC	_xmlBufDump
PUBLIC	_xmlBufFromBuffer
PUBLIC	_xmlBufBackToBuffer
PUBLIC	_xmlBufMergeBuffer
PUBLIC	_xmlBufResetInput
PUBLIC	_xmlBufGetInputBase
PUBLIC	_xmlBufSetInputBaseCur
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BA@GIGPFFIA@creating?5buffer@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BN@GFPONKGI@buffer?5error?3?5text?5too?5long?6@ ; `string'
PUBLIC	??_C@_0P@LKGMENGP@growing?5buffer@		; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC@				; `string'
PUBLIC	??_C@_06DDLNFFBN@?$CGquot?$DL@			; `string'
PUBLIC	??_C@_01GEODFPGF@?8@				; `string'
PUBLIC	??_C@_0CA@IHEGKOED@Used?5size?5too?5big?5for?5xmlBuffer@ ; `string'
PUBLIC	??_C@_0CF@HDAKMICL@Allocated?5size?5too?5big?5for?5xmlB@ ; `string'
PUBLIC	??_C@_0CG@MJEMBJAO@Input?5reference?5outside?5of?5the?5@ ; `string'
EXTRN	_xmlStrchr:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	_xmlBufferFree:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	___xmlBufferAllocScheme:PROC
EXTRN	___xmlDefaultBufferSize:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
;	COMDAT ??_C@_0CG@MJEMBJAO@Input?5reference?5outside?5of?5the?5@
CONST	SEGMENT
??_C@_0CG@MJEMBJAO@Input?5reference?5outside?5of?5the?5@ DB 'Input refere'
	DB	'nce outside of the buffer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HDAKMICL@Allocated?5size?5too?5big?5for?5xmlB@
CONST	SEGMENT
??_C@_0CF@HDAKMICL@Allocated?5size?5too?5big?5for?5xmlB@ DB 'Allocated si'
	DB	'ze too big for xmlBuffer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IHEGKOED@Used?5size?5too?5big?5for?5xmlBuffer@
CONST	SEGMENT
??_C@_0CA@IHEGKOED@Used?5size?5too?5big?5for?5xmlBuffer@ DB 'Used size to'
	DB	'o big for xmlBuffer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8@
CONST	SEGMENT
??_C@_01GEODFPGF@?8@ DB '''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DDLNFFBN@?$CGquot?$DL@
CONST	SEGMENT
??_C@_06DDLNFFBN@?$CGquot?$DL@ DB '&quot;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LKGMENGP@growing?5buffer@
CONST	SEGMENT
??_C@_0P@LKGMENGP@growing?5buffer@ DB 'growing buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GFPONKGI@buffer?5error?3?5text?5too?5long?6@
CONST	SEGMENT
??_C@_0BN@GFPONKGI@buffer?5error?3?5text?5too?5long?6@ DB 'buffer error: '
	DB	'text too long', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GIGPFFIA@creating?5buffer@
CONST	SEGMENT
??_C@_0BA@GIGPFFIA@creating?5buffer@ DB 'creating buffer', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufGrowInternal
_TEXT	SEGMENT
tv558 = 8						; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlBufGrowInternal PROC				; COMDAT

; 437  : xmlBufGrowInternal(xmlBufPtr buf, size_t len) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	$LN3@xmlBufGrow

; 438  :     size_t size;
; 439  :     xmlChar *newbuf;
; 440  : 
; 441  :     if ((buf == NULL) || (buf->error != 0)) return(0);

	cmp	DWORD PTR [esi+32], 0
	jne	$LN3@xmlBufGrow

; 442  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+8]
	cmp	ecx, eax
	je	SHORT $LN5@xmlBufGrow
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufGrow
	mov	DWORD PTR [esi+24], eax
	mov	ecx, eax
$LN5@xmlBufGrow:
	mov	eax, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi+4]
	cmp	eax, edx
	je	SHORT $LN7@xmlBufGrow
	cmp	edx, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufGrow
	mov	DWORD PTR [esi+20], edx
	mov	eax, edx
$LN7@xmlBufGrow:

; 443  : 
; 444  :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return(0);

	mov	ebx, DWORD PTR [esi+12]
	cmp	ebx, 2
	je	$LN3@xmlBufGrow

; 445  :     if (buf->use + len < buf->size)

	push	edi
	mov	edi, DWORD PTR _len$[ebp]
	lea	edx, DWORD PTR [eax+edi]
	mov	DWORD PTR tv558[ebp], edx
	cmp	edx, ecx
	jae	SHORT $LN9@xmlBufGrow

; 446  :         return(buf->size - buf->use);

	pop	edi
	sub	ecx, eax
	pop	esi
	mov	eax, ecx

; 496  : }

	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlBufGrow:

; 447  : 
; 448  :     /*
; 449  :      * Windows has a BIG problem on realloc timing, so we try to double
; 450  :      * the buffer size (if that's enough) (bug 146697)
; 451  :      * Apparently BSD too, and it's probably best for linux too
; 452  :      * On an embedded system this may be something to change
; 453  :      */
; 454  : #if 1
; 455  :     if (buf->size > (size_t) len)
; 456  :         size = buf->size * 2;
; 457  :     else
; 458  :         size = buf->use + len + 100;
; 459  : #else
; 460  :     size = buf->use + len + 100;
; 461  : #endif
; 462  : 
; 463  :     if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {

	cmp	ecx, edi
	lea	eax, DWORD PTR [edx+100]
	lea	edx, DWORD PTR [ecx+ecx]
	cmovbe	edx, eax
	mov	edi, edx
	cmp	ebx, 5
	jne	SHORT $LN15@xmlBufGrow

; 464  :         /*
; 465  : 	 * Used to provide parsing limits
; 466  : 	 */
; 467  :         if ((buf->use + len >= XML_MAX_TEXT_LENGTH) ||

	cmp	DWORD PTR tv558[ebp], 10000000		; 00989680H
	jae	SHORT $LN14@xmlBufGrow
	cmp	ecx, 10000000				; 00989680H
	jae	SHORT $LN14@xmlBufGrow

; 471  : 	}
; 472  : 	if (size >= XML_MAX_TEXT_LENGTH)

	cmp	edx, 10000000				; 00989680H
	jb	SHORT $LN16@xmlBufGrow

; 473  : 	    size = XML_MAX_TEXT_LENGTH;

	mov	edi, 10000000				; 00989680H
$LN16@xmlBufGrow:

; 485  :     } else {
; 486  : 	newbuf = (xmlChar *) xmlRealloc(buf->content, size);

	push	edi
	push	DWORD PTR [esi]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 487  : 	if (newbuf == NULL) {

	test	eax, eax
	jne	SHORT $LN19@xmlBufGrow
$LN25@xmlBufGrow:

; 488  : 	    xmlBufMemoryError(buf, "growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	push	esi
	call	_xmlBufMemoryError
	add	esp, 8
	xor	eax, eax
	pop	edi
	pop	esi

; 496  : }

	pop	ebx
	pop	ebp
	ret	0
$LN14@xmlBufGrow:

; 468  : 	    (buf->size >= XML_MAX_TEXT_LENGTH)) {
; 469  : 	    xmlBufMemoryError(buf, "buffer error: text too long\n");

	push	OFFSET ??_C@_0BN@GFPONKGI@buffer?5error?3?5text?5too?5long?6@
	push	esi
	call	_xmlBufMemoryError
	add	esp, 8

; 470  : 	    return(0);

	xor	eax, eax
	pop	edi
	pop	esi

; 496  : }

	pop	ebx
	pop	ebp
	ret	0
$LN15@xmlBufGrow:

; 474  :     }
; 475  :     if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {

	cmp	ebx, 3
	jne	SHORT $LN16@xmlBufGrow
	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	je	SHORT $LN16@xmlBufGrow

; 476  :         size_t start_buf = buf->content - buf->contentIO;

	mov	ebx, DWORD PTR [esi]
	sub	ebx, ecx

; 477  : 
; 478  : 	newbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);

	lea	eax, DWORD PTR [ebx+edi]
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 479  : 	if (newbuf == NULL) {

	test	eax, eax
	je	SHORT $LN25@xmlBufGrow

; 480  : 	    xmlBufMemoryError(buf, "growing buffer");
; 481  : 	    return(0);
; 482  : 	}
; 483  : 	buf->contentIO = newbuf;

	mov	DWORD PTR [esi+16], eax

; 484  : 	buf->content = newbuf + start_buf;

	add	eax, ebx
$LN19@xmlBufGrow:

; 489  : 	    return(0);
; 490  : 	}
; 491  : 	buf->content = newbuf;
; 492  :     }
; 493  :     buf->size = size;

	mov	DWORD PTR [esi], eax

; 494  :     UPDATE_COMPAT(buf)

	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	mov	DWORD PTR [esi+24], edi
	cmp	edi, eax
	cmovb	eax, edi
	mov	DWORD PTR [esi+8], eax
	cmp	DWORD PTR [esi+20], ecx
	pop	edi
	cmovb	ecx, DWORD PTR [esi+20]

; 495  :     return(buf->size - buf->use);

	mov	DWORD PTR [esi+4], ecx
	mov	eax, DWORD PTR [esi+24]
	sub	eax, DWORD PTR [esi+20]
	pop	esi

; 496  : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlBufGrow:
	pop	esi

; 438  :     size_t size;
; 439  :     xmlChar *newbuf;
; 440  : 
; 441  :     if ((buf == NULL) || (buf->error != 0)) return(0);

	xor	eax, eax

; 496  : }

	pop	ebx
	pop	ebp
	ret	0
_xmlBufGrowInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufOverflowError
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlBufOverflowError PROC				; COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _extra$[ebp]
	push	0
	push	0
	push	7000					; 00001b58H
	push	29					; 0000001dH
	call	___xmlSimpleError
	mov	eax, DWORD PTR _buf$[ebp]
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN2@xmlBufOver

; 109  :     __xmlSimpleError(XML_FROM_BUFFER, XML_BUF_OVERFLOW, NULL, NULL, extra);
; 110  :     if ((buf) && (buf->error == 0))

	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN2@xmlBufOver

; 111  :         buf->error = XML_BUF_OVERFLOW;

	mov	DWORD PTR [eax+32], 7000		; 00001b58H
$LN2@xmlBufOver:

; 112  : }

	pop	ebp
	ret	0
_xmlBufOverflowError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufMemoryError
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlBufMemoryError PROC					; COMDAT

; 93   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _extra$[ebp]
	push	0
	push	0
	push	2
	push	29					; 0000001dH
	call	___xmlSimpleError
	mov	eax, DWORD PTR _buf$[ebp]
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN2@xmlBufMemo

; 94   :     __xmlSimpleError(XML_FROM_BUFFER, XML_ERR_NO_MEMORY, NULL, NULL, extra);
; 95   :     if ((buf) && (buf->error == 0))

	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN2@xmlBufMemo

; 96   :         buf->error = XML_ERR_NO_MEMORY;

	mov	DWORD PTR [eax+32], 2
$LN2@xmlBufMemo:

; 97   : }

	pop	ebp
	ret	0
_xmlBufMemoryError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufSetInputBaseCur
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_input$ = 12						; size = 4
_base$ = 16						; size = 4
_cur$ = 20						; size = 4
_xmlBufSetInputBaseCur PROC				; COMDAT

; 1334 :                       size_t base, size_t cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _input$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlBufSetI

; 1335 :     if ((input == NULL) || (buf == NULL) || (buf->error))

	mov	edx, DWORD PTR _buf$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlBufSetI
	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $LN3@xmlBufSetI

; 1337 :     CHECK_COMPAT(buf)

	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [edx+24], eax
	je	SHORT $LN5@xmlBufSetI
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufSetI
	mov	DWORD PTR [edx+24], eax
$LN5@xmlBufSetI:
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [edx+20], eax
	je	SHORT $LN7@xmlBufSetI
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufSetI
	mov	DWORD PTR [edx+20], eax
$LN7@xmlBufSetI:

; 1338 :     input->base = &buf->content[base];

	mov	ecx, DWORD PTR [edx]
	add	ecx, DWORD PTR _base$[ebp]

; 1339 :     input->cur = input->base + cur;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, ecx
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+16], eax

; 1340 :     input->end = &buf->content[buf->use];

	mov	eax, DWORD PTR [edx+20]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi+20], eax

; 1341 :     return(0);

	xor	eax, eax
	pop	esi

; 1342 : }

	pop	ebp
	ret	0
$LN3@xmlBufSetI:

; 1336 :         return(-1);

	or	eax, -1
	pop	esi

; 1342 : }

	pop	ebp
	ret	0
_xmlBufSetInputBaseCur ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufGetInputBase
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_input$ = 12						; size = 4
_xmlBufGetInputBase PROC				; COMDAT

; 1302 : xmlBufGetInputBase(xmlBufPtr buf, xmlParserInputPtr input) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _input$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlBufGetI

; 1303 :     size_t base;
; 1304 : 
; 1305 :     if ((input == NULL) || (buf == NULL) || (buf->error))

	mov	eax, DWORD PTR _buf$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlBufGetI
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN3@xmlBufGetI

; 1307 :     CHECK_COMPAT(buf)

	mov	edx, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR [eax+8]
	cmp	edx, ecx
	je	SHORT $LN5@xmlBufGetI
	cmp	ecx, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufGetI
	mov	DWORD PTR [eax+24], ecx
	mov	edx, ecx
$LN5@xmlBufGetI:
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+20], ecx
	je	SHORT $LN7@xmlBufGetI
	cmp	ecx, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufGetI
	mov	DWORD PTR [eax+20], ecx
$LN7@xmlBufGetI:

; 1308 :     base = input->base - buf->content;

	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, DWORD PTR [eax]

; 1309 :     /*
; 1310 :      * We could do some pointer arythmetic checks but that's probably
; 1311 :      * sufficient.
; 1312 :      */
; 1313 :     if (base > buf->size) {

	cmp	ecx, edx
	jbe	SHORT $LN8@xmlBufGetI

; 1314 :         xmlBufOverflowError(buf, "Input reference outside of the buffer");

	push	OFFSET ??_C@_0CG@MJEMBJAO@Input?5reference?5outside?5of?5the?5@
	push	eax
	call	_xmlBufOverflowError
	add	esp, 8

; 1315 :         base = 0;

	xor	ecx, ecx
$LN8@xmlBufGetI:

; 1316 :     }
; 1317 :     return(base);

	mov	eax, ecx
	pop	esi

; 1318 : }

	pop	ebp
	ret	0
$LN3@xmlBufGetI:

; 1306 :         return(-1);

	or	eax, -1
	pop	esi

; 1318 : }

	pop	ebp
	ret	0
_xmlBufGetInputBase ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufResetInput
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_input$ = 12						; size = 4
_xmlBufResetInput PROC					; COMDAT

; 1283 : xmlBufResetInput(xmlBufPtr buf, xmlParserInputPtr input) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _input$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlBufRese

; 1284 :     if ((input == NULL) || (buf == NULL) || (buf->error))

	mov	ecx, DWORD PTR _buf$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlBufRese
	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN3@xmlBufRese

; 1286 :     CHECK_COMPAT(buf)

	mov	eax, DWORD PTR [ecx+8]
	cmp	DWORD PTR [ecx+24], eax
	je	SHORT $LN5@xmlBufRese
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufRese
	mov	DWORD PTR [ecx+24], eax
$LN5@xmlBufRese:
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [ecx+20], eax
	je	SHORT $LN7@xmlBufRese
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufRese
	mov	DWORD PTR [ecx+20], eax
$LN7@xmlBufRese:

; 1287 :     input->base = input->cur = buf->content;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+16], eax
	mov	DWORD PTR [edx+12], eax

; 1288 :     input->end = &buf->content[buf->use];

	mov	eax, DWORD PTR [ecx+20]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+20], eax

; 1289 :     return(0);

	xor	eax, eax

; 1290 : }

	pop	ebp
	ret	0
$LN3@xmlBufRese:

; 1285 :         return(-1);

	or	eax, -1

; 1290 : }

	pop	ebp
	ret	0
_xmlBufResetInput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufMergeBuffer
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_buffer$ = 12						; size = 4
_xmlBufMergeBuffer PROC					; COMDAT

; 1257 : xmlBufMergeBuffer(xmlBufPtr buf, xmlBufferPtr buffer) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _buf$[ebp]
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN3@xmlBufMerg

; 1258 :     int ret = 0;
; 1259 : 
; 1260 :     if ((buf == NULL) || (buf->error)) {

	cmp	DWORD PTR [eax+32], edi
	jne	SHORT $LN3@xmlBufMerg

; 1263 :     }
; 1264 :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [eax+24], ecx
	je	SHORT $LN5@xmlBufMerg
	cmp	ecx, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufMerg
	mov	DWORD PTR [eax+24], ecx
$LN5@xmlBufMerg:
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+20], ecx
	je	SHORT $LN7@xmlBufMerg
	cmp	ecx, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufMerg
	mov	DWORD PTR [eax+20], ecx
$LN7@xmlBufMerg:
	push	esi

; 1265 :     if ((buffer != NULL) && (buffer->content != NULL) &&

	mov	esi, DWORD PTR _buffer$[ebp]
	test	esi, esi
	je	SHORT $LN8@xmlBufMerg
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN8@xmlBufMerg
	mov	edx, DWORD PTR [esi+4]
	test	edx, edx
	je	SHORT $LN8@xmlBufMerg

; 1266 :              (buffer->use > 0)) {
; 1267 :         ret = xmlBufAdd(buf, buffer->content, buffer->use);

	push	edx
	push	ecx
	push	eax
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
	mov	edi, eax
$LN8@xmlBufMerg:

; 1268 :     }
; 1269 :     xmlBufferFree(buffer);

	push	esi
	call	_xmlBufferFree
	add	esp, 4

; 1270 :     return(ret);

	mov	eax, edi
	pop	esi
	pop	edi

; 1271 : }

	pop	ebp
	ret	0
$LN3@xmlBufMerg:

; 1261 : 	xmlBufferFree(buffer);

	push	DWORD PTR _buffer$[ebp]
	call	_xmlBufferFree
	add	esp, 4

; 1262 :         return(-1);

	or	eax, -1
	pop	edi

; 1271 : }

	pop	ebp
	ret	0
_xmlBufMergeBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufBackToBuffer
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufBackToBuffer PROC				; COMDAT

; 1204 : xmlBufBackToBuffer(xmlBufPtr buf) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	$LN3@xmlBufBack

; 1205 :     xmlBufferPtr ret;
; 1206 : 
; 1207 :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR [esi+32], 0
	jne	$LN3@xmlBufBack

; 1209 :     CHECK_COMPAT(buf)

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi+8]
	cmp	eax, ecx
	je	SHORT $LN5@xmlBufBack
	cmp	ecx, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufBack
	mov	DWORD PTR [esi+24], ecx
	mov	eax, ecx
$LN5@xmlBufBack:
	mov	ecx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi+4]
	cmp	ecx, edx
	je	SHORT $LN7@xmlBufBack
	cmp	edx, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufBack
	mov	DWORD PTR [esi+20], edx
	mov	ecx, edx
$LN7@xmlBufBack:

; 1210 :     if (buf->buffer == NULL) {

	push	edi
	mov	edi, DWORD PTR [esi+28]
	test	edi, edi
	jne	SHORT $LN8@xmlBufBack

; 338  :     if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, 3
	jne	SHORT $LN15@xmlBufBack
	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	jne	SHORT $LN20@xmlBufBack
$LN15@xmlBufBack:

; 339  :         (buf->contentIO != NULL)) {
; 340  :         xmlFree(buf->contentIO);
; 341  :     } else if ((buf->content != NULL) &&

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN17@xmlBufBack
	cmp	eax, 2
	je	SHORT $LN17@xmlBufBack
$LN20@xmlBufBack:

; 342  :         (buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE)) {
; 343  :         xmlFree(buf->content);
; 344  :     }
; 345  :     xmlFree(buf);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlBufBack:
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1211 :         xmlBufFree(buf);
; 1212 :         return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 1245 : }

	pop	ebp
	ret	0
$LN8@xmlBufBack:

; 1213 :     }
; 1214 : 
; 1215 :     ret = buf->buffer;
; 1216 :     /*
; 1217 :      * What to do in case of error in the buffer ???
; 1218 :      */
; 1219 :     if (buf->use > INT_MAX) {

	cmp	ecx, 2147483647				; 7fffffffH
	jbe	SHORT $LN9@xmlBufBack

; 1220 :         /*
; 1221 :          * Worse case, we really allocated and used more than the
; 1222 :          * maximum allowed memory for an xmlBuffer on this architecture.
; 1223 :          * Keep the buffer but provide a truncated size value.
; 1224 :          */
; 1225 :         xmlBufOverflowError(buf, "Used size too big for xmlBuffer");

	push	OFFSET ??_C@_0CA@IHEGKOED@Used?5size?5too?5big?5for?5xmlBuffer@
	push	esi
	call	_xmlBufOverflowError

; 1226 :         ret->use = INT_MAX;

	mov	DWORD PTR [edi+4], 2147483647		; 7fffffffH

; 1227 :         ret->size = INT_MAX;

	jmp	SHORT $LN21@xmlBufBack
$LN9@xmlBufBack:

; 1228 :     } else if (buf->size > INT_MAX) {

	cmp	eax, 2147483647				; 7fffffffH
	jbe	SHORT $LN11@xmlBufBack

; 1229 :         /*
; 1230 :          * milder case, we allocated more than the maximum allowed memory
; 1231 :          * for an xmlBuffer on this architecture, but used less than the
; 1232 :          * limit.
; 1233 :          * Keep the buffer but provide a truncated size value.
; 1234 :          */
; 1235 :         xmlBufOverflowError(buf, "Allocated size too big for xmlBuffer");

	push	OFFSET ??_C@_0CF@HDAKMICL@Allocated?5size?5too?5big?5for?5xmlB@
	push	esi
	call	_xmlBufOverflowError
$LN21@xmlBufBack:

; 1236 :         ret->size = INT_MAX;
; 1237 :     }
; 1238 :     ret->use = (int) buf->use;

	mov	DWORD PTR [edi+8], 2147483647		; 7fffffffH
	add	esp, 8
$LN11@xmlBufBack:
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+4], eax

; 1239 :     ret->size = (int) buf->size;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edi+8], eax

; 1240 :     ret->alloc = buf->alloc;

	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], ecx

; 1241 :     ret->content = buf->content;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [edi], ecx

; 1242 :     ret->contentIO = buf->contentIO;

	mov	ecx, DWORD PTR [esi+16]

; 1243 :     xmlFree(buf);

	push	esi
	mov	DWORD PTR [edi+16], ecx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1244 :     return(ret);

	mov	eax, edi
	pop	edi
	pop	esi

; 1245 : }

	pop	ebp
	ret	0
$LN3@xmlBufBack:

; 1208 :         return(NULL);

	xor	eax, eax
	pop	esi

; 1245 : }

	pop	ebp
	ret	0
_xmlBufBackToBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufFromBuffer
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_xmlBufFromBuffer PROC					; COMDAT

; 1167 : xmlBufFromBuffer(xmlBufferPtr buffer) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buffer$[ebp]
	test	esi, esi
	je	SHORT $LN8@xmlBufFrom

; 1168 :     xmlBufPtr ret;
; 1169 : 
; 1170 :     if (buffer == NULL)
; 1171 :         return(NULL);
; 1172 : 
; 1173 :     ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));

	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4

; 1174 :     if (ret == NULL) {

	test	ecx, ecx
	jne	SHORT $LN3@xmlBufFrom

; 94   :     __xmlSimpleError(XML_FROM_BUFFER, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	eax
	push	eax
	push	2
	push	29					; 0000001dH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
$LN8@xmlBufFrom:

; 1189 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlBufFrom:

; 1175 : 	xmlBufMemoryError(NULL, "creating buffer");
; 1176 :         return(NULL);
; 1177 :     }
; 1178 :     ret->use = buffer->use;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+20], eax

; 1179 :     ret->size = buffer->size;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+24], eax

; 1180 :     ret->compat_use = buffer->use;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax

; 1181 :     ret->compat_size = buffer->size;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], eax

; 1182 :     ret->error = 0;
; 1183 :     ret->buffer = buffer;

	mov	DWORD PTR [ecx+28], esi
	mov	DWORD PTR [ecx+32], 0

; 1184 :     ret->alloc = buffer->alloc;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], eax

; 1185 :     ret->content = buffer->content;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 1186 :     ret->contentIO = buffer->contentIO;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+16], eax

; 1187 : 
; 1188 :     return(ret);

	mov	eax, ecx
	pop	esi

; 1189 : }

	pop	ebp
	ret	0
_xmlBufFromBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufDump
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_xmlBufDump PROC					; COMDAT

; 548  : xmlBufDump(FILE *file, xmlBufPtr buf) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlBufDump

; 549  :     size_t ret;
; 550  : 
; 551  :     if ((buf == NULL) || (buf->error != 0)) {

	cmp	DWORD PTR [esi+32], 0
	jne	SHORT $LN3@xmlBufDump

; 557  :     }
; 558  :     if (buf->content == NULL) {

	mov	edx, DWORD PTR [esi]
	test	edx, edx
	je	SHORT $LN3@xmlBufDump

; 559  : #ifdef DEBUG_BUFFER
; 560  :         xmlGenericError(xmlGenericErrorContext,
; 561  : 		"xmlBufDump: buf->content == NULL\n");
; 562  : #endif
; 563  : 	return(0);
; 564  :     }
; 565  :     CHECK_COMPAT(buf)

	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [esi+24], eax
	je	SHORT $LN6@xmlBufDump
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN6@xmlBufDump
	mov	DWORD PTR [esi+24], eax
$LN6@xmlBufDump:
	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+4]
	cmp	eax, ecx
	je	SHORT $LN8@xmlBufDump
	cmp	ecx, 2147483647				; 7fffffffH
	jae	SHORT $LN8@xmlBufDump
	mov	DWORD PTR [esi+20], ecx
	mov	eax, ecx
$LN8@xmlBufDump:

; 566  :     if (file == NULL)

	mov	ecx, DWORD PTR _file$[ebp]
	test	ecx, ecx
	jne	SHORT $LN9@xmlBufDump

; 567  : 	file = stdout;

	push	1
	call	DWORD PTR __imp____acrt_iob_func
	mov	edx, DWORD PTR [esi]
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+20]
	add	esp, 4
$LN9@xmlBufDump:

; 568  :     ret = fwrite(buf->content, sizeof(xmlChar), buf->use, file);

	push	ecx
	push	eax
	push	1
	push	edx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	pop	esi

; 569  :     return(ret);
; 570  : }

	pop	ebp
	ret	0
$LN3@xmlBufDump:

; 552  : #ifdef DEBUG_BUFFER
; 553  :         xmlGenericError(xmlGenericErrorContext,
; 554  : 		"xmlBufDump: buf == NULL or in error\n");
; 555  : #endif
; 556  : 	return(0);

	xor	eax, eax
	pop	esi

; 569  :     return(ret);
; 570  : }

	pop	ebp
	ret	0
_xmlBufDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufDetach
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufDetach PROC					; COMDAT

; 196  : xmlBufDetach(xmlBufPtr buf) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _buf$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@xmlBufDeta

; 197  :     xmlChar *ret;
; 198  : 
; 199  :     if (buf == NULL)
; 200  :         return(NULL);
; 201  :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE)

	cmp	DWORD PTR [ecx+12], 2
	je	SHORT $LN7@xmlBufDeta

; 202  :         return(NULL);
; 203  :     if (buf->buffer != NULL)

	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $LN7@xmlBufDeta

; 204  :         return(NULL);
; 205  :     if (buf->error)

	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN7@xmlBufDeta

; 207  : 
; 208  :     ret = buf->content;

	mov	eax, DWORD PTR [ecx]

; 209  :     buf->content = NULL;

	mov	DWORD PTR [ecx], 0

; 210  :     buf->size = 0;

	mov	DWORD PTR [ecx+24], 0

; 211  :     buf->use = 0;

	mov	DWORD PTR [ecx+20], 0

; 212  :     buf->compat_use = 0;

	mov	DWORD PTR [ecx+4], 0

; 213  :     buf->compat_size = 0;

	mov	DWORD PTR [ecx+8], 0

; 214  : 
; 215  :     return ret;
; 216  : }

	pop	ebp
	ret	0
$LN7@xmlBufDeta:

; 206  :         return(NULL);

	xor	eax, eax

; 214  : 
; 215  :     return ret;
; 216  : }

	pop	ebp
	ret	0
_xmlBufDetach ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufErase
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlBufErase PROC					; COMDAT

; 646  : xmlBufErase(xmlBufPtr buf, size_t len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlBufEras

; 647  :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR [esi+32], 0
	jne	SHORT $LN3@xmlBufEras

; 649  :     CHECK_COMPAT(buf)

	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [esi+24], eax
	je	SHORT $LN5@xmlBufEras
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufEras
	mov	DWORD PTR [esi+24], eax
$LN5@xmlBufEras:
	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN7@xmlBufEras
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufEras
	mov	DWORD PTR [esi+20], eax
	mov	ecx, eax
$LN7@xmlBufEras:

; 650  :     if (len > buf->use)

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, ecx
	ja	SHORT $LN3@xmlBufEras

; 651  :         return(-1);
; 652  :     buf->use -= len;

	sub	ecx, eax

; 653  :     buf->content[buf->use] = 0;
; 654  :     UPDATE_COMPAT(buf)

	mov	edx, 2147483647				; 7fffffffH
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+20], ecx
	mov	BYTE PTR [ecx+eax], 0
	mov	eax, edx
	cmp	DWORD PTR [esi+24], eax
	cmovb	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+8], eax
	cmp	DWORD PTR [esi+20], edx
	cmovb	edx, DWORD PTR [esi+20]

; 655  :     return(0);

	xor	eax, eax
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 656  : }

	pop	ebp
	ret	0
$LN3@xmlBufEras:

; 648  :         return(-1);

	or	eax, -1
	pop	esi

; 656  : }

	pop	ebp
	ret	0
_xmlBufErase ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufAddLen
_TEXT	SEGMENT
tv191 = 8						; size = 4
tv65 = 8						; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlBufAddLen PROC					; COMDAT

; 621  : xmlBufAddLen(xmlBufPtr buf, size_t len) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _buf$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlBufAddL

; 622  :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $LN3@xmlBufAddL

; 623  :         return(-1);
; 624  :     CHECK_COMPAT(buf)

	mov	eax, DWORD PTR [edx+24]
	mov	esi, eax
	mov	ecx, DWORD PTR [edx+8]
	cmp	eax, ecx
	je	SHORT $LN5@xmlBufAddL
	cmp	ecx, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufAddL
	mov	DWORD PTR [edx+24], ecx
	mov	esi, ecx
	mov	eax, ecx
$LN5@xmlBufAddL:
	mov	ecx, DWORD PTR [edx+20]
	mov	ebx, eax
	mov	edi, DWORD PTR [edx+4]
	cmp	ecx, edi
	je	SHORT $LN7@xmlBufAddL
	cmp	edi, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufAddL
	mov	DWORD PTR [edx+20], edi
	mov	ecx, edi
$LN7@xmlBufAddL:

; 625  :     if (len > (buf->size - buf->use))

	mov	edi, DWORD PTR _len$[ebp]
	mov	eax, esi
	sub	eax, ecx
	cmp	edi, eax
	ja	SHORT $LN3@xmlBufAddL

; 626  :         return(-1);
; 627  :     buf->use += len;

	add	edi, ecx

; 628  :     UPDATE_COMPAT(buf)

	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	mov	DWORD PTR [edx+20], edi
	cmp	esi, eax
	cmovb	eax, esi
	cmp	edi, ecx
	mov	DWORD PTR [edx+8], eax
	cmovb	ecx, edi

; 629  :     if (buf->size > buf->use)

	mov	DWORD PTR [edx+4], ecx
	cmp	ebx, edi
	jbe	SHORT $LN3@xmlBufAddL

; 630  :         buf->content[buf->use] = 0;

	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [edi+eax], 0

; 631  :     else
; 632  :         return(-1);
; 633  :     return(0);

	xor	eax, eax
	pop	edi

; 634  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlBufAddL:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
_xmlBufAddLen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufIsEmpty
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufIsEmpty PROC					; COMDAT

; 727  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _buf$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlBufIsEm

; 728  :     if ((!buf) || (buf->error))

	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN3@xmlBufIsEm

; 730  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [eax+24], ecx
	je	SHORT $LN5@xmlBufIsEm
	cmp	ecx, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufIsEm
	mov	DWORD PTR [eax+24], ecx
$LN5@xmlBufIsEm:
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax+4]
	cmp	ecx, edx
	je	SHORT $LN7@xmlBufIsEm
	cmp	edx, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufIsEm
	mov	DWORD PTR [eax+20], edx
	mov	ecx, edx
$LN7@xmlBufIsEm:

; 731  : 
; 732  :     return(buf->use == 0);

	xor	eax, eax
	test	ecx, ecx
	sete	al

; 733  : }

	pop	ebp
	ret	0
$LN3@xmlBufIsEm:

; 729  :         return(-1);

	or	eax, -1

; 733  : }

	pop	ebp
	ret	0
_xmlBufIsEmpty ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufLength
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufLength PROC					; COMDAT

; 669  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _buf$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlBufLeng

; 670  :     if ((!buf) || (buf->error))

	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN3@xmlBufLeng

; 672  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [eax+24], ecx
	je	SHORT $LN5@xmlBufLeng
	cmp	ecx, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufLeng
	mov	DWORD PTR [eax+24], ecx
$LN5@xmlBufLeng:
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax+4]
	cmp	ecx, edx
	je	SHORT $LN7@xmlBufLeng
	cmp	edx, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufLeng
	mov	DWORD PTR [eax+20], edx
	mov	ecx, edx
$LN7@xmlBufLeng:

; 673  : 
; 674  :     return(buf->use);

	mov	eax, ecx

; 675  : }

	pop	ebp
	ret	0
$LN3@xmlBufLeng:

; 671  :         return 0;

	xor	eax, eax

; 675  : }

	pop	ebp
	ret	0
_xmlBufLength ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufAvail
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufAvail PROC					; COMDAT

; 709  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _buf$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlBufAvai

; 710  :     if ((!buf) || (buf->error))

	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN3@xmlBufAvai

; 712  :     CHECK_COMPAT(buf)

	mov	eax, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [ecx+8]
	cmp	eax, edx
	je	SHORT $LN5@xmlBufAvai
	cmp	edx, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufAvai
	mov	DWORD PTR [ecx+24], edx
	mov	eax, edx
$LN5@xmlBufAvai:
	mov	edx, DWORD PTR [ecx+20]
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	cmp	edx, esi
	je	SHORT $LN7@xmlBufAvai
	cmp	esi, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufAvai
	mov	DWORD PTR [ecx+20], esi
	mov	edx, esi
$LN7@xmlBufAvai:

; 713  : 
; 714  :     return(buf->size - buf->use);

	sub	eax, edx
	pop	esi

; 715  : }

	pop	ebp
	ret	0
$LN3@xmlBufAvai:

; 711  :         return 0;

	xor	eax, eax

; 715  : }

	pop	ebp
	ret	0
_xmlBufAvail ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufWriteQuotedString
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_string$ = 12						; size = 4
_xmlBufWriteQuotedString PROC				; COMDAT

; 1111 : xmlBufWriteQuotedString(xmlBufPtr buf, const xmlChar *string) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _buf$[ebp]
	test	edi, edi
	je	$LN5@xmlBufWrit

; 1112 :     const xmlChar *cur, *base;
; 1113 :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR [edi+32], 0
	jne	$LN5@xmlBufWrit

; 1115 :     CHECK_COMPAT(buf)

	mov	eax, DWORD PTR [edi+8]
	cmp	DWORD PTR [edi+24], eax
	je	SHORT $LN7@xmlBufWrit
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufWrit
	mov	DWORD PTR [edi+24], eax
$LN7@xmlBufWrit:
	mov	eax, DWORD PTR [edi+4]
	cmp	DWORD PTR [edi+20], eax
	je	SHORT $LN9@xmlBufWrit
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN9@xmlBufWrit
	mov	DWORD PTR [edi+20], eax
$LN9@xmlBufWrit:

; 1116 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE)

	cmp	DWORD PTR [edi+12], 2
	je	$LN5@xmlBufWrit

; 1117 :         return(-1);
; 1118 :     if (xmlStrchr(string, '\"')) {

	push	esi
	mov	esi, DWORD PTR _string$[ebp]
	push	34					; 00000022H
	push	esi
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	$LN11@xmlBufWrit

; 1119 :         if (xmlStrchr(string, '\'')) {

	push	39					; 00000027H
	push	esi
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlBufWrit

; 1120 : #ifdef DEBUG_BUFFER
; 1121 : 	    xmlGenericError(xmlGenericErrorContext,
; 1122 :  "xmlBufWriteQuotedString: string contains quote and double-quotes !\n");
; 1123 : #endif
; 1124 : 	    xmlBufCCat(buf, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	edi
	call	_xmlBufCCat

; 1125 :             base = cur = string;
; 1126 :             while(*cur != 0){

	mov	al, BYTE PTR [esi]
	add	esp, 8
	mov	ecx, esi
	test	al, al
	je	$LN18@xmlBufWrit
$LL2@xmlBufWrit:

; 1127 :                 if(*cur == '"'){

	cmp	al, 34					; 00000022H
	jne	SHORT $LN15@xmlBufWrit

; 1128 :                     if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN17@xmlBufWrit

; 1129 :                         xmlBufAdd(buf, base, cur - base);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN17@xmlBufWrit:

; 1130 :                     xmlBufAdd(buf, BAD_CAST "&quot;", 6);

	push	6
	push	OFFSET ??_C@_06DDLNFFBN@?$CGquot?$DL@
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 1131 :                     cur++;

	lea	ecx, DWORD PTR [esi+1]
$LN15@xmlBufWrit:

; 1125 :             base = cur = string;
; 1126 :             while(*cur != 0){

	mov	al, BYTE PTR [esi+1]
	inc	esi
	test	al, al
	jne	SHORT $LL2@xmlBufWrit

; 1132 :                     base = cur;
; 1133 :                 }
; 1134 :                 else {
; 1135 :                     cur++;
; 1136 :                 }
; 1137 :             }
; 1138 :             if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN18@xmlBufWrit

; 1139 :                 xmlBufAdd(buf, base, cur - base);

	sub	esi, ecx
	push	esi
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 1140 : 	    xmlBufCCat(buf, "\"");
; 1141 : 	}

	jmp	SHORT $LN18@xmlBufWrit
$LN13@xmlBufWrit:

; 1142 :         else{
; 1143 : 	    xmlBufCCat(buf, "\'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	edi
	call	_xmlBufCCat

; 1144 :             xmlBufCat(buf, string);

	push	esi
	push	edi
	call	_xmlBufCat
	add	esp, 16					; 00000010H

; 1145 : 	    xmlBufCCat(buf, "\'");

	mov	eax, OFFSET ??_C@_01GEODFPGF@?8@

; 1150 :         xmlBufCCat(buf, "\"");
; 1151 :     }
; 1152 :     return(0);

	push	eax
	push	edi
	call	_xmlBufCCat
	add	esp, 8
	xor	eax, eax
	pop	esi
	pop	edi

; 1153 : }

	pop	ebp
	ret	0
$LN11@xmlBufWrit:

; 1146 :         }
; 1147 :     } else {
; 1148 :         xmlBufCCat(buf, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	edi
	call	_xmlBufCCat

; 1149 :         xmlBufCat(buf, string);

	push	esi
	push	edi
	call	_xmlBufCat
	add	esp, 16					; 00000010H
$LN18@xmlBufWrit:

; 1150 :         xmlBufCCat(buf, "\"");
; 1151 :     }
; 1152 :     return(0);

	mov	eax, OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	eax
	push	edi
	call	_xmlBufCCat
	add	esp, 8
	xor	eax, eax
	pop	esi
	pop	edi

; 1153 : }

	pop	ebp
	ret	0
$LN5@xmlBufWrit:

; 1114 :         return(-1);

	or	eax, -1
	pop	edi

; 1153 : }

	pop	ebp
	ret	0
_xmlBufWriteQuotedString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufWriteChar
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_string$ = 12						; size = 4
_xmlBufWriteChar PROC					; COMDAT

; 1088 : xmlBufWriteChar(xmlBufPtr buf, const char *string) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _buf$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlBufWrit

; 1089 :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN3@xmlBufWrit

; 1091 :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [eax+24], ecx
	je	SHORT $LN5@xmlBufWrit
	cmp	ecx, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufWrit
	mov	DWORD PTR [eax+24], ecx
$LN5@xmlBufWrit:
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+20], ecx
	je	SHORT $LN7@xmlBufWrit
	cmp	ecx, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufWrit
	mov	DWORD PTR [eax+20], ecx
$LN7@xmlBufWrit:

; 1092 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE)

	cmp	DWORD PTR [eax+12], 2
	je	SHORT $LN3@xmlBufWrit

; 1093 :         return(-1);
; 1094 :     return(xmlBufCCat(buf, string));

	mov	DWORD PTR _buf$[ebp], eax

; 1095 : }

	pop	ebp

; 1093 :         return(-1);
; 1094 :     return(xmlBufCCat(buf, string));

	jmp	_xmlBufCCat
$LN3@xmlBufWrit:

; 1090 :         return(-1);

	or	eax, -1

; 1095 : }

	pop	ebp
	ret	0
_xmlBufWriteChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufWriteCHAR
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_string$ = 12						; size = 4
_xmlBufWriteCHAR PROC					; COMDAT

; 1067 : xmlBufWriteCHAR(xmlBufPtr buf, const xmlChar *string) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _buf$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlBufWrit

; 1068 :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN3@xmlBufWrit

; 1070 :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [eax+24], ecx
	je	SHORT $LN5@xmlBufWrit
	cmp	ecx, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufWrit
	mov	DWORD PTR [eax+24], ecx
$LN5@xmlBufWrit:
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+20], ecx
	je	SHORT $LN7@xmlBufWrit
	cmp	ecx, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufWrit
	mov	DWORD PTR [eax+20], ecx
$LN7@xmlBufWrit:

; 1071 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE)

	cmp	DWORD PTR [eax+12], 2
	je	SHORT $LN3@xmlBufWrit

; 1072 :         return(-1);
; 1073 :     return(xmlBufCat(buf, string));

	mov	DWORD PTR _buf$[ebp], eax

; 1074 : }

	pop	ebp

; 1072 :         return(-1);
; 1073 :     return(xmlBufCat(buf, string));

	jmp	_xmlBufCat
$LN3@xmlBufWrit:

; 1069 :         return(-1);

	or	eax, -1

; 1074 : }

	pop	ebp
	ret	0
_xmlBufWriteCHAR ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufCCat
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlBufCCat PROC					; COMDAT

; 1027 : xmlBufCCat(xmlBufPtr buf, const char *str) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	$LN6@xmlBufCCat

; 1028 :     const char *cur;
; 1029 : 
; 1030 :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR [esi+32], 0
	jne	$LN6@xmlBufCCat

; 1032 :     CHECK_COMPAT(buf)

	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [esi+24], eax
	je	SHORT $LN8@xmlBufCCat
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN8@xmlBufCCat
	mov	DWORD PTR [esi+24], eax
$LN8@xmlBufCCat:
	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN10@xmlBufCCat
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN10@xmlBufCCat
	mov	DWORD PTR [esi+20], eax
	mov	ecx, eax
$LN10@xmlBufCCat:

; 1033 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;

	cmp	DWORD PTR [esi+12], 2
	je	SHORT $LN6@xmlBufCCat

; 1034 :     if (str == NULL) {

	mov	edi, DWORD PTR _str$[ebp]
	test	edi, edi
	je	SHORT $LN6@xmlBufCCat

; 1035 : #ifdef DEBUG_BUFFER
; 1036 :         xmlGenericError(xmlGenericErrorContext,
; 1037 : 		"xmlBufCCat: str == NULL\n");
; 1038 : #endif
; 1039 : 	return -1;
; 1040 :     }
; 1041 :     for (cur = str;*cur != 0;cur++) {

	cmp	BYTE PTR [edi], 0
	je	SHORT $LN26@xmlBufCCat
	npad	2
$LL4@xmlBufCCat:

; 1042 :         if (buf->use  + 10 >= buf->size) {

	add	ecx, 10					; 0000000aH
	cmp	ecx, DWORD PTR [esi+24]
	jb	SHORT $LN24@xmlBufCCat

; 1043 :             if (!xmlBufResize(buf, buf->use+10)){

	push	ecx
	push	esi
	call	_xmlBufResize
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@xmlBufCCat
$LN24@xmlBufCCat:

; 1046 :             }
; 1047 :         }
; 1048 :         buf->content[buf->use++] = *cur;

	mov	edx, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR [edi]
	inc	edi
	mov	BYTE PTR [edx+ecx], al
	mov	ecx, DWORD PTR [esi+20]
	inc	ecx
	mov	DWORD PTR [esi+20], ecx
	cmp	BYTE PTR [edi], 0
	jne	SHORT $LL4@xmlBufCCat
$LN26@xmlBufCCat:

; 1049 :     }
; 1050 :     buf->content[buf->use] = 0;

	mov	eax, DWORD PTR [esi]

; 1051 :     UPDATE_COMPAT(buf)

	mov	edx, 2147483647				; 7fffffffH
	pop	edi
	mov	BYTE PTR [ecx+eax], 0
	mov	eax, edx
	cmp	DWORD PTR [esi+24], eax
	cmovb	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+8], eax
	cmp	DWORD PTR [esi+20], edx
	cmovb	edx, DWORD PTR [esi+20]

; 1052 :     return 0;

	xor	eax, eax
	mov	DWORD PTR [esi+4], edx

; 1053 : }

	pop	esi
	pop	ebp
	ret	0
$LN21@xmlBufCCat:

; 1044 : 		xmlBufMemoryError(buf, "growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	push	esi
	call	_xmlBufMemoryError
	add	esp, 8

; 1045 :                 return XML_ERR_NO_MEMORY;

	mov	eax, 2
	pop	edi

; 1053 : }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlBufCCat:
	pop	edi

; 1031 :         return(-1);

	or	eax, -1

; 1053 : }

	pop	esi
	pop	ebp
	ret	0
_xmlBufCCat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufCat
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlBufCat PROC						; COMDAT

; 1007 : xmlBufCat(xmlBufPtr buf, const xmlChar *str) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _buf$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlBufCat

; 1008 :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN3@xmlBufCat

; 1010 :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [eax+24], ecx
	je	SHORT $LN5@xmlBufCat
	cmp	ecx, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufCat
	mov	DWORD PTR [eax+24], ecx
$LN5@xmlBufCat:
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+20], ecx
	je	SHORT $LN7@xmlBufCat
	cmp	ecx, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufCat
	mov	DWORD PTR [eax+20], ecx
$LN7@xmlBufCat:

; 1011 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;

	cmp	DWORD PTR [eax+12], 2
	je	SHORT $LN3@xmlBufCat

; 1012 :     if (str == NULL) return -1;

	mov	ecx, DWORD PTR _str$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlBufCat

; 1013 :     return xmlBufAdd(buf, str, -1);

	push	-1
	push	ecx
	push	eax
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 1014 : }

	pop	ebp
	ret	0
$LN3@xmlBufCat:

; 1009 :         return(-1);

	or	eax, -1

; 1014 : }

	pop	ebp
	ret	0
_xmlBufCat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufAddHead
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_str$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlBufAddHead PROC					; COMDAT

; 928  : xmlBufAddHead(xmlBufPtr buf, const xmlChar *str, int len) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	$LN3@xmlBufAddH

; 929  :     unsigned int needSize;
; 930  : 
; 931  :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR [esi+32], 0
	jne	$LN3@xmlBufAddH

; 932  :         return(-1);
; 933  :     CHECK_COMPAT(buf)

	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [esi+24], eax
	je	SHORT $LN5@xmlBufAddH
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufAddH
	mov	DWORD PTR [esi+24], eax
$LN5@xmlBufAddH:
	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN7@xmlBufAddH
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufAddH
	mov	DWORD PTR [esi+20], eax
$LN7@xmlBufAddH:

; 934  :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;

	cmp	DWORD PTR [esi+12], 2
	je	$LN3@xmlBufAddH

; 935  :     if (str == NULL) {

	mov	ebx, DWORD PTR _str$[ebp]
	test	ebx, ebx
	je	$LN3@xmlBufAddH

; 936  : #ifdef DEBUG_BUFFER
; 937  :         xmlGenericError(xmlGenericErrorContext,
; 938  : 		"xmlBufAddHead: str == NULL\n");
; 939  : #endif
; 940  : 	return -1;
; 941  :     }
; 942  :     if (len < -1) {

	mov	edi, DWORD PTR _len$[ebp]
	cmp	edi, -1
	jl	$LN3@xmlBufAddH

; 943  : #ifdef DEBUG_BUFFER
; 944  :         xmlGenericError(xmlGenericErrorContext,
; 945  : 		"xmlBufAddHead: len < 0\n");
; 946  : #endif
; 947  : 	return -1;
; 948  :     }
; 949  :     if (len == 0) return 0;

	test	edi, edi
	je	SHORT $LN34@xmlBufAddH

; 950  : 
; 951  :     if (len < 0)

	jns	SHORT $LN35@xmlBufAddH

; 952  :         len = xmlStrlen(str);

	push	ebx
	call	_xmlStrlen
	mov	edi, eax
	add	esp, 4

; 953  : 
; 954  :     if (len <= 0) return -1;

	test	edi, edi
$LN35@xmlBufAddH:
	jle	$LN3@xmlBufAddH

; 955  : 
; 956  :     if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {

	mov	ecx, DWORD PTR [esi+12]
	cmp	ecx, 3
	jne	SHORT $LN15@xmlBufAddH
	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	je	SHORT $LN32@xmlBufAddH

; 957  :         size_t start_buf = buf->content - buf->contentIO;

	mov	edx, DWORD PTR [esi]
	mov	eax, edx
	sub	eax, ecx

; 958  : 
; 959  : 	if (start_buf > (unsigned int) len) {

	cmp	eax, edi
	jbe	SHORT $LN32@xmlBufAddH

; 960  : 	    /*
; 961  : 	     * We can add it in the space previously shrinked
; 962  : 	     */
; 963  : 	    buf->content -= len;
; 964  :             memmove(&buf->content[0], str, len);

	push	edi
	sub	edx, edi
	push	ebx
	push	edx
	mov	DWORD PTR [esi], edx
	call	_memmove

; 965  : 	    buf->use += len;

	mov	edx, DWORD PTR [esi+20]
	add	esp, 12					; 0000000cH

; 966  : 	    buf->size += len;

	mov	ecx, DWORD PTR [esi+24]
	add	edx, edi
	add	ecx, edi
	mov	DWORD PTR [esi+20], edx

; 967  : 	    UPDATE_COMPAT(buf)

	mov	edi, 2147483647				; 7fffffffH
	mov	DWORD PTR [esi+24], ecx
	mov	eax, edi
	cmp	ecx, eax
	cmovb	eax, ecx
	cmp	edx, edi
	mov	DWORD PTR [esi+8], eax
	cmovb	edi, edx

; 968  : 	    return(0);

	mov	DWORD PTR [esi+4], edi
$LN34@xmlBufAddH:

; 994  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN32@xmlBufAddH:

; 969  : 	}
; 970  :     }
; 971  :     needSize = buf->use + len + 2;

	mov	ecx, DWORD PTR [esi+12]
$LN15@xmlBufAddH:
	mov	eax, DWORD PTR [esi+20]
	add	eax, 2
	add	eax, edi

; 972  :     if (needSize > buf->size){

	cmp	eax, DWORD PTR [esi+24]
	jbe	SHORT $LN30@xmlBufAddH

; 973  : 	if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {

	cmp	ecx, 5
	jne	SHORT $LN22@xmlBufAddH

; 974  : 	    /*
; 975  : 	     * Used to provide parsing limits
; 976  : 	     */
; 977  : 	    if (needSize >= XML_MAX_TEXT_LENGTH) {

	cmp	eax, 10000000				; 00989680H
	jb	SHORT $LN22@xmlBufAddH

; 978  : 		xmlBufMemoryError(buf, "buffer error: text too long\n");

	push	OFFSET ??_C@_0BN@GFPONKGI@buffer?5error?3?5text?5too?5long?6@
	push	esi
	call	_xmlBufMemoryError
	add	esp, 8
$LN3@xmlBufAddH:

; 994  : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN22@xmlBufAddH:

; 979  : 		return(-1);
; 980  : 	    }
; 981  : 	}
; 982  :         if (!xmlBufResize(buf, needSize)){

	push	eax
	push	esi
	call	_xmlBufResize
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@xmlBufAddH

; 983  : 	    xmlBufMemoryError(buf, "growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	push	esi
	call	_xmlBufMemoryError
	add	esp, 8

; 984  :             return XML_ERR_NO_MEMORY;

	mov	eax, 2
	pop	edi

; 994  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN30@xmlBufAddH:

; 985  :         }
; 986  :     }
; 987  : 
; 988  :     memmove(&buf->content[len], &buf->content[0], buf->use);

	push	DWORD PTR [esi+20]
	mov	eax, DWORD PTR [esi]
	push	eax
	add	eax, edi
	push	eax
	call	_memmove

; 989  :     memmove(&buf->content[0], str, len);

	push	edi
	push	ebx
	push	DWORD PTR [esi]
	call	_memmove

; 990  :     buf->use += len;

	add	DWORD PTR [esi+20], edi
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [esi+20]

; 991  :     buf->content[buf->use] = 0;
; 992  :     UPDATE_COMPAT(buf)

	mov	edi, 2147483647				; 7fffffffH
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [ecx+eax], 0
	mov	ecx, edi
	cmp	DWORD PTR [esi+24], ecx
	cmovb	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+8], ecx
	cmp	DWORD PTR [esi+20], edi
	cmovb	edi, DWORD PTR [esi+20]

; 993  :     return 0;

	xor	eax, eax
	mov	DWORD PTR [esi+4], edi
	pop	edi

; 994  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlBufAddHead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufAdd
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_str$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlBufAdd PROC						; COMDAT

; 868  : xmlBufAdd(xmlBufPtr buf, const xmlChar *str, int len) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _str$[ebp]
	test	ebx, ebx
	je	$LN3@xmlBufAdd

; 869  :     unsigned int needSize;
; 870  : 
; 871  :     if ((str == NULL) || (buf == NULL) || (buf->error))

	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlBufAdd
	cmp	DWORD PTR [esi+32], 0
	jne	SHORT $LN3@xmlBufAdd

; 872  : 	return -1;
; 873  :     CHECK_COMPAT(buf)

	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [esi+24], eax
	je	SHORT $LN5@xmlBufAdd
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufAdd
	mov	DWORD PTR [esi+24], eax
$LN5@xmlBufAdd:
	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN7@xmlBufAdd
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufAdd
	mov	DWORD PTR [esi+20], eax
$LN7@xmlBufAdd:

; 874  : 
; 875  :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;

	cmp	DWORD PTR [esi+12], 2
	je	SHORT $LN3@xmlBufAdd

; 876  :     if (len < -1) {

	mov	edi, DWORD PTR _len$[ebp]
	cmp	edi, -1
	jl	SHORT $LN3@xmlBufAdd

; 877  : #ifdef DEBUG_BUFFER
; 878  :         xmlGenericError(xmlGenericErrorContext,
; 879  : 		"xmlBufAdd: len < 0\n");
; 880  : #endif
; 881  : 	return -1;
; 882  :     }
; 883  :     if (len == 0) return 0;

	test	edi, edi
	je	$LN26@xmlBufAdd

; 884  : 
; 885  :     if (len < 0)

	jns	SHORT $LN27@xmlBufAdd

; 886  :         len = xmlStrlen(str);

	push	ebx
	call	_xmlStrlen
	mov	edi, eax
	add	esp, 4

; 887  : 
; 888  :     if (len < 0) return -1;

	test	edi, edi
	js	SHORT $LN3@xmlBufAdd
$LN27@xmlBufAdd:

; 889  :     if (len == 0) return 0;

	je	$LN26@xmlBufAdd

; 890  : 
; 891  :     needSize = buf->use + len + 2;

	mov	eax, DWORD PTR [esi+20]
	add	eax, 2
	add	eax, edi

; 892  :     if (needSize > buf->size){

	cmp	eax, DWORD PTR [esi+24]
	jbe	SHORT $LN25@xmlBufAdd

; 893  : 	if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {

	cmp	DWORD PTR [esi+12], 5
	jne	SHORT $LN16@xmlBufAdd

; 894  : 	    /*
; 895  : 	     * Used to provide parsing limits
; 896  : 	     */
; 897  : 	    if (needSize >= XML_MAX_TEXT_LENGTH) {

	cmp	eax, 10000000				; 00989680H
	jb	SHORT $LN16@xmlBufAdd

; 898  : 		xmlBufMemoryError(buf, "buffer error: text too long\n");

	push	OFFSET ??_C@_0BN@GFPONKGI@buffer?5error?3?5text?5too?5long?6@
	push	esi
	call	_xmlBufMemoryError
	add	esp, 8
$LN3@xmlBufAdd:

; 913  : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN16@xmlBufAdd:

; 899  : 		return(-1);
; 900  : 	    }
; 901  : 	}
; 902  :         if (!xmlBufResize(buf, needSize)){

	push	eax
	push	esi
	call	_xmlBufResize
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@xmlBufAdd

; 903  : 	    xmlBufMemoryError(buf, "growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	push	esi
	call	_xmlBufMemoryError
	add	esp, 8

; 904  :             return XML_ERR_NO_MEMORY;

	mov	eax, 2
	pop	edi

; 913  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN25@xmlBufAdd:

; 905  :         }
; 906  :     }
; 907  : 
; 908  :     memmove(&buf->content[buf->use], str, len*sizeof(xmlChar));

	mov	eax, DWORD PTR [esi+20]
	add	eax, DWORD PTR [esi]
	push	edi
	push	ebx
	push	eax
	call	_memmove

; 909  :     buf->use += len;

	add	DWORD PTR [esi+20], edi

; 910  :     buf->content[buf->use] = 0;
; 911  :     UPDATE_COMPAT(buf)

	mov	edx, 2147483647				; 7fffffffH
	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [esi+20]
	mov	BYTE PTR [ecx+eax], 0
	mov	eax, edx
	cmp	DWORD PTR [esi+24], eax
	cmovb	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+8], eax
	cmp	DWORD PTR [esi+20], edx
	cmovb	edx, DWORD PTR [esi+20]

; 912  :     return 0;

	mov	DWORD PTR [esi+4], edx
$LN26@xmlBufAdd:

; 913  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlBufAdd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufResize
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlBufResize PROC					; COMDAT

; 746  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _buf$[ebp]
	test	edi, edi
	je	$LN9@xmlBufResi

; 747  :     unsigned int newSize;
; 748  :     xmlChar* rebuf = NULL;
; 749  :     size_t start_buf;
; 750  : 
; 751  :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR [edi+32], 0
	jne	$LN9@xmlBufResi

; 752  :         return(0);
; 753  :     CHECK_COMPAT(buf)

	mov	edx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [edi+8]
	cmp	edx, eax
	je	SHORT $LN11@xmlBufResi
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN11@xmlBufResi
	mov	DWORD PTR [edi+24], eax
	mov	edx, eax
$LN11@xmlBufResi:
	mov	esi, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [edi+4]
	cmp	esi, eax
	je	SHORT $LN13@xmlBufResi
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN13@xmlBufResi
	mov	DWORD PTR [edi+20], eax
	mov	esi, eax
$LN13@xmlBufResi:

; 754  : 
; 755  :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return(0);

	mov	ebx, DWORD PTR [edi+12]
	cmp	ebx, 2
	je	$LN9@xmlBufResi

; 756  :     if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {

	mov	ecx, DWORD PTR _size$[ebp]
	cmp	ebx, 5
	jne	SHORT $LN16@xmlBufResi

; 757  :         /*
; 758  : 	 * Used to provide parsing limits
; 759  : 	 */
; 760  :         if (size >= XML_MAX_TEXT_LENGTH) {

	cmp	ecx, 10000000				; 00989680H
	jb	SHORT $LN16@xmlBufResi

; 761  : 	    xmlBufMemoryError(buf, "buffer error: text too long\n");

	push	OFFSET ??_C@_0BN@GFPONKGI@buffer?5error?3?5text?5too?5long?6@

; 853  : }

	push	edi
	call	_xmlBufMemoryError
	add	esp, 8
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN16@xmlBufResi:

; 762  : 	    return(0);
; 763  : 	}
; 764  :     }
; 765  : 
; 766  :     /* Don't resize if we don't have to */
; 767  :     if (size < buf->size)

	cmp	ecx, edx
	jb	$LN56@xmlBufResi

; 768  :         return 1;
; 769  : 
; 770  :     /* figure out new size */
; 771  :     switch (buf->alloc){

	cmp	ebx, 4
	ja	SHORT $LN25@xmlBufResi
	jmp	DWORD PTR $LN59@xmlBufResi[ebx*4]
$LN18@xmlBufResi:

; 772  : 	case XML_BUFFER_ALLOC_IO:
; 773  : 	case XML_BUFFER_ALLOC_DOUBLEIT:
; 774  : 	    /*take care of empty case*/
; 775  : 	    newSize = (buf->size ? buf->size*2 : size + 10);
; 776  : 	    while (size > newSize) {

	test	edx, edx
	lea	eax, DWORD PTR [ecx+10]
	lea	esi, DWORD PTR [edx+edx]
	cmove	esi, eax
	cmp	ecx, esi
	jbe	SHORT $LN2@xmlBufResi
	npad	11
$LL4@xmlBufResi:

; 777  : 	        if (newSize > UINT_MAX / 2) {

	cmp	esi, 2147483647				; 7fffffffH
	ja	$LN54@xmlBufResi

; 778  : 	            xmlBufMemoryError(buf, "growing buffer");
; 779  : 	            return 0;
; 780  : 	        }
; 781  : 	        newSize *= 2;

	add	esi, esi
	cmp	ecx, esi
	ja	SHORT $LL4@xmlBufResi

; 782  : 	    }
; 783  : 	    break;
; 784  : 	case XML_BUFFER_ALLOC_EXACT:
; 785  : 	    newSize = size+10;
; 786  : 	    break;

	jmp	SHORT $LN2@xmlBufResi
$LN21@xmlBufResi:

; 787  :         case XML_BUFFER_ALLOC_HYBRID:
; 788  :             if (buf->use < BASE_BUFFER_SIZE)

	cmp	esi, 4096				; 00001000H
	jae	SHORT $LN22@xmlBufResi

; 789  :                 newSize = size;

	mov	esi, ecx
	jmp	SHORT $LN2@xmlBufResi
$LN22@xmlBufResi:

; 790  :             else {
; 791  :                 newSize = buf->size * 2;

	lea	esi, DWORD PTR [edx+edx]

; 792  :                 while (size > newSize) {

	cmp	ecx, esi
	jbe	SHORT $LN2@xmlBufResi
	npad	9
$LL6@xmlBufResi:

; 793  :                     if (newSize > UINT_MAX / 2) {

	cmp	esi, 2147483647				; 7fffffffH
	ja	$LN54@xmlBufResi

; 794  :                         xmlBufMemoryError(buf, "growing buffer");
; 795  :                         return 0;
; 796  :                     }
; 797  :                     newSize *= 2;

	add	esi, esi
	cmp	ecx, esi
	ja	SHORT $LL6@xmlBufResi

; 798  :                 }
; 799  :             }
; 800  :             break;
; 801  : 
; 802  : 	default:
; 803  : 	    newSize = size+10;
; 804  : 	    break;
; 805  :     }
; 806  : 
; 807  :     if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {

	jmp	SHORT $LN2@xmlBufResi
$LN25@xmlBufResi:
	lea	esi, DWORD PTR [ecx+10]
$LN2@xmlBufResi:
	cmp	ebx, 3
	jne	SHORT $LN26@xmlBufResi
	mov	ecx, DWORD PTR [edi+16]
	test	ecx, ecx
	je	SHORT $LN26@xmlBufResi

; 808  :         start_buf = buf->content - buf->contentIO;

	mov	eax, DWORD PTR [edi]
	mov	ebx, eax
	sub	ebx, ecx

; 809  : 
; 810  :         if (start_buf > newSize) {

	cmp	ebx, esi
	jbe	SHORT $LN28@xmlBufResi

; 811  : 	    /* move data back to start */
; 812  : 	    memmove(buf->contentIO, buf->content, buf->use);

	push	DWORD PTR [edi+20]
	push	eax
	push	ecx
	call	_memmove

; 813  : 	    buf->content = buf->contentIO;

	mov	ecx, DWORD PTR [edi+16]
	add	esp, 12					; 0000000cH

; 814  : 	    buf->content[buf->use] = 0;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [edi], ecx
	mov	BYTE PTR [ecx+eax], 0

; 815  : 	    buf->size += start_buf;
; 816  : 	} else {

	jmp	SHORT $LN27@xmlBufResi
$LN28@xmlBufResi:

; 817  : 	    rebuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + newSize);

	lea	eax, DWORD PTR [ebx+esi]
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 818  : 	    if (rebuf == NULL) {

	test	eax, eax
	je	$LN54@xmlBufResi

; 819  : 		xmlBufMemoryError(buf, "growing buffer");
; 820  : 		return 0;
; 821  : 	    }
; 822  : 	    buf->contentIO = rebuf;

	mov	DWORD PTR [edi+16], eax

; 823  : 	    buf->content = rebuf + start_buf;

	add	eax, ebx
	mov	DWORD PTR [edi], eax

; 824  : 	}
; 825  :     } else {

	jmp	SHORT $LN27@xmlBufResi
$LN26@xmlBufResi:

; 826  : 	if (buf->content == NULL) {

	mov	ecx, DWORD PTR [edi]
	push	esi
	test	ecx, ecx
	jne	SHORT $LN31@xmlBufResi

; 827  : 	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);

	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	ebx, eax
	jmp	SHORT $LN35@xmlBufResi
$LN31@xmlBufResi:

; 828  : 	} else if (buf->size - buf->use < 100) {

	mov	eax, DWORD PTR [edi+24]
	sub	eax, DWORD PTR [edi+20]
	cmp	eax, 100				; 00000064H
	jae	SHORT $LN33@xmlBufResi

; 829  : 	    rebuf = (xmlChar *) xmlRealloc(buf->content, newSize);

	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	ebx, eax

; 830  :         } else {

	jmp	SHORT $LN35@xmlBufResi
$LN33@xmlBufResi:

; 831  : 	    /*
; 832  : 	     * if we are reallocating a buffer far from being full, it's
; 833  : 	     * better to make a new allocation and copy only the used range
; 834  : 	     * and free the old one.
; 835  : 	     */
; 836  : 	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);

	call	DWORD PTR _xmlMallocAtomic
	mov	ebx, eax
	add	esp, 4

; 837  : 	    if (rebuf != NULL) {

	test	ebx, ebx
	je	SHORT $LN54@xmlBufResi

; 838  : 		memcpy(rebuf, buf->content, buf->use);

	push	DWORD PTR [edi+20]
	push	DWORD PTR [edi]
	push	ebx
	call	_memcpy

; 839  : 		xmlFree(buf->content);

	push	DWORD PTR [edi]
	call	DWORD PTR _xmlFree

; 840  : 		rebuf[buf->use] = 0;

	mov	eax, DWORD PTR [edi+20]
	add	esp, 16					; 00000010H
	mov	BYTE PTR [ebx+eax], 0
$LN35@xmlBufResi:

; 841  : 	    }
; 842  : 	}
; 843  : 	if (rebuf == NULL) {

	test	ebx, ebx
	je	SHORT $LN54@xmlBufResi

; 845  : 	    return 0;
; 846  : 	}
; 847  : 	buf->content = rebuf;

	mov	DWORD PTR [edi], ebx
$LN27@xmlBufResi:

; 848  :     }
; 849  :     buf->size = newSize;
; 850  :     UPDATE_COMPAT(buf)

	mov	ecx, 2147483647				; 7fffffffH
	mov	DWORD PTR [edi+24], esi
	mov	eax, ecx
	cmp	esi, eax
	cmovb	eax, esi
	mov	DWORD PTR [edi+8], eax
	cmp	DWORD PTR [edi+20], ecx
	cmovb	ecx, DWORD PTR [edi+20]

; 851  : 
; 852  :     return 1;

	mov	DWORD PTR [edi+4], ecx
$LN56@xmlBufResi:

; 853  : }

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	pop	ebp
	ret	0
$LN54@xmlBufResi:

; 844  : 	    xmlBufMemoryError(buf, "growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@

; 853  : }

	push	edi
	call	_xmlBufMemoryError
	add	esp, 8
$LN9@xmlBufResi:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
	npad	3
$LN59@xmlBufResi:
	DD	$LN18@xmlBufResi
	DD	$LN25@xmlBufResi
	DD	$LN25@xmlBufResi
	DD	$LN18@xmlBufResi
	DD	$LN21@xmlBufResi
_xmlBufResize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufInflate
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlBufInflate PROC					; COMDAT

; 531  : xmlBufInflate(xmlBufPtr buf, size_t len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlBufInfl

; 532  :     if (buf == NULL) return(-1);
; 533  :     xmlBufGrowInternal(buf, len + buf->size);

	mov	eax, DWORD PTR [esi+24]
	add	eax, DWORD PTR _len$[ebp]
	push	eax
	push	esi
	call	_xmlBufGrowInternal
	add	esp, 8

; 534  :     if (buf->error)

	cmp	DWORD PTR [esi+32], 0
	jne	SHORT $LN5@xmlBufInfl

; 536  :     return(0);

	xor	eax, eax
	pop	esi

; 537  : }

	pop	ebp
	ret	0
$LN5@xmlBufInfl:

; 535  :         return(-1);

	or	eax, -1
	pop	esi

; 537  : }

	pop	ebp
	ret	0
_xmlBufInflate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufGrow
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlBufGrow PROC					; COMDAT

; 509  : xmlBufGrow(xmlBufPtr buf, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlBufGrow

; 510  :     size_t ret;
; 511  : 
; 512  :     if ((buf == NULL) || (len < 0)) return(-1);

	mov	eax, DWORD PTR _len$[ebp]
	test	eax, eax
	js	SHORT $LN3@xmlBufGrow

; 513  :     if (len == 0)

	jne	SHORT $LN4@xmlBufGrow

; 514  :         return(0);

	xor	eax, eax
	pop	esi

; 517  :         return(-1);
; 518  :     return((int) ret);
; 519  : }

	pop	ebp
	ret	0
$LN4@xmlBufGrow:

; 515  :     ret = xmlBufGrowInternal(buf, len);

	push	eax
	push	esi
	call	_xmlBufGrowInternal
	add	esp, 8

; 516  :     if (buf->error != 0)

	cmp	DWORD PTR [esi+32], 0
	je	SHORT $LN1@xmlBufGrow
$LN3@xmlBufGrow:

; 510  :     size_t ret;
; 511  : 
; 512  :     if ((buf == NULL) || (len < 0)) return(-1);

	or	eax, -1
$LN1@xmlBufGrow:
	pop	esi

; 517  :         return(-1);
; 518  :     return((int) ret);
; 519  : }

	pop	ebp
	ret	0
_xmlBufGrow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufEmpty
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufEmpty PROC					; COMDAT

; 355  : xmlBufEmpty(xmlBufPtr buf) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	SHORT $LN15@xmlBufEmpt

; 356  :     if ((buf == NULL) || (buf->error != 0)) return;

	cmp	DWORD PTR [esi+32], 0
	jne	SHORT $LN15@xmlBufEmpt

; 357  :     if (buf->content == NULL) return;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN15@xmlBufEmpt

; 358  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [esi+8]
	cmp	ecx, edx
	je	SHORT $LN6@xmlBufEmpt
	cmp	edx, 2147483647				; 7fffffffH
	jae	SHORT $LN6@xmlBufEmpt
	mov	DWORD PTR [esi+24], edx
	mov	ecx, edx
$LN6@xmlBufEmpt:

; 359  :     buf->use = 0;
; 360  :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) {

	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+20], 0
	cmp	edx, 2
	jne	SHORT $LN9@xmlBufEmpt

; 361  :         buf->content = BAD_CAST "";

	mov	DWORD PTR [esi], OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN12@xmlBufEmpt
$LN9@xmlBufEmpt:

; 362  :     } else if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&

	cmp	edx, 3
	jne	SHORT $LN11@xmlBufEmpt
	mov	edx, DWORD PTR [esi+16]
	test	edx, edx
	je	SHORT $LN11@xmlBufEmpt

; 363  :                (buf->contentIO != NULL)) {
; 364  :         size_t start_buf = buf->content - buf->contentIO;
; 365  : 
; 366  : 	buf->size += start_buf;

	sub	eax, edx

; 367  :         buf->content = buf->contentIO;

	mov	DWORD PTR [esi], edx
	add	eax, ecx
	mov	DWORD PTR [esi+24], eax

; 368  :         buf->content[0] = 0;

	mov	BYTE PTR [edx], 0

; 369  :     } else {

	jmp	SHORT $LN12@xmlBufEmpt
$LN11@xmlBufEmpt:

; 370  :         buf->content[0] = 0;

	mov	BYTE PTR [eax], 0
$LN12@xmlBufEmpt:

; 371  :     }
; 372  :     UPDATE_COMPAT(buf)

	mov	edx, 2147483647				; 7fffffffH
	mov	eax, edx
	cmp	DWORD PTR [esi+24], eax
	cmovb	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+8], eax
	cmp	DWORD PTR [esi+20], edx
	cmovb	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+4], edx
$LN15@xmlBufEmpt:
	pop	esi

; 373  : }

	pop	ebp
	ret	0
_xmlBufEmpty ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufFree
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufFree PROC					; COMDAT

; 329  : xmlBufFree(xmlBufPtr buf) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlBufFree

; 330  :     if (buf == NULL) {
; 331  : #ifdef DEBUG_BUFFER
; 332  :         xmlGenericError(xmlGenericErrorContext,
; 333  : 		"xmlBufFree: buf == NULL\n");
; 334  : #endif
; 335  : 	return;
; 336  :     }
; 337  : 
; 338  :     if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, 3
	jne	SHORT $LN3@xmlBufFree
	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	jne	SHORT $LN7@xmlBufFree
$LN3@xmlBufFree:

; 339  :         (buf->contentIO != NULL)) {
; 340  :         xmlFree(buf->contentIO);
; 341  :     } else if ((buf->content != NULL) &&

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@xmlBufFree
	cmp	eax, 2
	je	SHORT $LN5@xmlBufFree
$LN7@xmlBufFree:

; 342  :         (buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE)) {
; 343  :         xmlFree(buf->content);
; 344  :     }
; 345  :     xmlFree(buf);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlBufFree:
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlBufFree:
	pop	esi

; 346  : }

	pop	ebp
	ret	0
_xmlBufFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufGetAllocationScheme
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufGetAllocationScheme PROC				; COMDAT

; 267  : xmlBufGetAllocationScheme(xmlBufPtr buf) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _buf$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlBufGetA

; 268  :     if (buf == NULL) {
; 269  : #ifdef DEBUG_BUFFER
; 270  :         xmlGenericError(xmlGenericErrorContext,
; 271  : 		"xmlBufGetAllocationScheme: buf == NULL\n");
; 272  : #endif
; 273  :         return(-1);

	or	eax, -1

; 276  : }

	pop	ebp
	ret	0
$LN2@xmlBufGetA:

; 274  :     }
; 275  :     return(buf->alloc);

	mov	eax, DWORD PTR [eax+12]

; 276  : }

	pop	ebp
	ret	0
_xmlBufGetAllocationScheme ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufSetAllocationScheme
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_scheme$ = 12						; size = 4
_xmlBufSetAllocationScheme PROC				; COMDAT

; 289  :                           xmlBufferAllocationScheme scheme) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _buf$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlBufSetA

; 290  :     if ((buf == NULL) || (buf->error != 0)) {

	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN3@xmlBufSetA

; 296  :     }
; 297  :     if ((buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) ||

	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, 2
	je	SHORT $LN3@xmlBufSetA
	cmp	eax, 3
	je	SHORT $LN3@xmlBufSetA

; 298  :         (buf->alloc == XML_BUFFER_ALLOC_IO))
; 299  :         return(-1);
; 300  :     if ((scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||
; 301  :         (scheme == XML_BUFFER_ALLOC_EXACT) ||
; 302  :         (scheme == XML_BUFFER_ALLOC_HYBRID) ||
; 303  :         (scheme == XML_BUFFER_ALLOC_IMMUTABLE) ||

	mov	eax, DWORD PTR _scheme$[ebp]
	test	eax, eax
	je	SHORT $LN7@xmlBufSetA
	cmp	eax, 1
	je	SHORT $LN7@xmlBufSetA
	cmp	eax, 4
	je	SHORT $LN7@xmlBufSetA
	cmp	eax, 2
	je	SHORT $LN7@xmlBufSetA
	cmp	eax, 5
	je	SHORT $LN7@xmlBufSetA

; 309  :     }
; 310  :     /*
; 311  :      * Switching a buffer ALLOC_IO has the side effect of initializing
; 312  :      * the contentIO field with the current content
; 313  :      */
; 314  :     if (scheme == XML_BUFFER_ALLOC_IO) {

	cmp	eax, 3
	jne	SHORT $LN3@xmlBufSetA

; 315  :         buf->alloc = XML_BUFFER_ALLOC_IO;

	mov	DWORD PTR [ecx+12], eax

; 316  :         buf->contentIO = buf->content;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+16], eax
$LN3@xmlBufSetA:

; 291  : #ifdef DEBUG_BUFFER
; 292  :         xmlGenericError(xmlGenericErrorContext,
; 293  : 		"xmlBufSetAllocationScheme: buf == NULL or in error\n");
; 294  : #endif
; 295  :         return(-1);

	or	eax, -1

; 317  :     }
; 318  :     return(-1);
; 319  : }

	pop	ebp
	ret	0
$LN7@xmlBufSetA:

; 304  : 	(scheme == XML_BUFFER_ALLOC_BOUNDED)) {
; 305  : 	buf->alloc = scheme;

	mov	DWORD PTR [ecx+12], eax

; 306  :         if (buf->buffer)

	mov	ecx, DWORD PTR [ecx+28]
	test	ecx, ecx
	je	SHORT $LN8@xmlBufSetA

; 307  :             buf->buffer->alloc = scheme;

	mov	DWORD PTR [ecx+12], eax
$LN8@xmlBufSetA:

; 308  :         return(0);

	xor	eax, eax

; 317  :     }
; 318  :     return(-1);
; 319  : }

	pop	ebp
	ret	0
_xmlBufSetAllocationScheme ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufCreateStatic
_TEXT	SEGMENT
_mem$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlBufCreateStatic PROC				; COMDAT

; 231  : xmlBufCreateStatic(void *mem, size_t size) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _size$[ebp]
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _mem$[ebp]
	test	edi, edi
	je	SHORT $LN10@xmlBufCrea

; 232  :     xmlBufPtr ret;
; 233  : 
; 234  :     if (mem == NULL)
; 235  :         return(NULL);
; 236  : 
; 237  :     ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));

	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4

; 238  :     if (ret == NULL) {

	test	ecx, ecx
	jne	SHORT $LN3@xmlBufCrea

; 94   :     __xmlSimpleError(XML_FROM_BUFFER, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	eax
	push	eax
	push	2
	push	29					; 0000001dH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
$LN10@xmlBufCrea:
	pop	edi

; 256  : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlBufCrea:

; 239  : 	xmlBufMemoryError(NULL, "creating buffer");
; 240  :         return(NULL);
; 241  :     }
; 242  :     if (size < INT_MAX) {
; 243  :         ret->compat_use = size;
; 244  :         ret->compat_size = size;
; 245  :     } else {
; 246  :         ret->compat_use = INT_MAX;
; 247  :         ret->compat_size = INT_MAX;
; 248  :     }
; 249  :     ret->use = size;

	mov	edx, 2147483647				; 7fffffffH
	mov	eax, esi
	cmp	esi, edx
	cmovae	eax, edx
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax

; 250  :     ret->size = size;
; 251  :     ret->alloc = XML_BUFFER_ALLOC_IMMUTABLE;
; 252  :     ret->content = (xmlChar *) mem;
; 253  :     ret->error = 0;
; 254  :     ret->buffer = NULL;
; 255  :     return(ret);

	mov	eax, ecx
	mov	DWORD PTR [ecx], edi
	pop	edi
	mov	DWORD PTR [ecx+20], esi
	mov	DWORD PTR [ecx+24], esi
	mov	DWORD PTR [ecx+12], 2
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+28], 0

; 256  : }

	pop	esi
	pop	ebp
	ret	0
_xmlBufCreateStatic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufCreateSize
_TEXT	SEGMENT
_size$ = 8						; size = 4
_xmlBufCreateSize PROC					; COMDAT

; 156  : xmlBufCreateSize(size_t size) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlBufCrea

; 94   :     __xmlSimpleError(XML_FROM_BUFFER, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	eax
	push	eax
	push	2
	push	29					; 0000001dH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 157  :     xmlBufPtr ret;
; 158  : 
; 159  :     ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));
; 160  :     if (ret == NULL) {
; 161  : 	xmlBufMemoryError(NULL, "creating buffer");
; 162  :         return(NULL);

	xor	eax, eax
	pop	esi

; 183  : }

	pop	ebp
	ret	0
$LN2@xmlBufCrea:

; 163  :     }
; 164  :     ret->compat_use = 0;

	mov	DWORD PTR [esi+4], 0

; 165  :     ret->use = 0;

	mov	DWORD PTR [esi+20], 0

; 166  :     ret->error = 0;

	mov	DWORD PTR [esi+32], 0

; 167  :     ret->buffer = NULL;

	mov	DWORD PTR [esi+28], 0

; 168  :     ret->alloc = xmlBufferAllocScheme;

	call	___xmlBufferAllocScheme

; 169  :     ret->size = (size ? size+2 : 0);         /* +1 for ending null */

	mov	ecx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+12], eax
	lea	eax, DWORD PTR [ecx+2]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, eax
	mov	DWORD PTR [esi+24], ecx

; 170  :     ret->compat_size = (int) ret->size;

	mov	DWORD PTR [esi+8], ecx

; 171  :     if (ret->size){

	je	SHORT $LN3@xmlBufCrea

; 172  :         ret->content = (xmlChar *) xmlMallocAtomic(ret->size * sizeof(xmlChar));

	push	ecx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 173  :         if (ret->content == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlBufCrea

; 174  : 	    xmlBufMemoryError(ret, "creating buffer");

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	esi
	call	_xmlBufMemoryError

; 175  :             xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 176  :             return(NULL);

	xor	eax, eax
	pop	esi

; 183  : }

	pop	ebp
	ret	0
$LN5@xmlBufCrea:

; 177  :         }
; 178  :         ret->content[0] = 0;

	mov	BYTE PTR [eax], 0

; 181  :     ret->contentIO = NULL;
; 182  :     return(ret);

	mov	eax, esi
	mov	DWORD PTR [esi+16], 0
	pop	esi

; 183  : }

	pop	ebp
	ret	0
$LN3@xmlBufCrea:

; 179  :     } else
; 180  : 	ret->content = NULL;

	mov	DWORD PTR [esi], 0

; 181  :     ret->contentIO = NULL;
; 182  :     return(ret);

	mov	eax, esi
	mov	DWORD PTR [esi+16], 0
	pop	esi

; 183  : }

	pop	ebp
	ret	0
_xmlBufCreateSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufCreate
_TEXT	SEGMENT
_xmlBufCreate PROC					; COMDAT

; 122  : xmlBufCreate(void) {

	push	esi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlBufCrea

; 94   :     __xmlSimpleError(XML_FROM_BUFFER, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	eax
	push	eax
	push	2
	push	29					; 0000001dH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 123  :     xmlBufPtr ret;
; 124  : 
; 125  :     ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));
; 126  :     if (ret == NULL) {
; 127  : 	xmlBufMemoryError(NULL, "creating buffer");
; 128  :         return(NULL);

	xor	eax, eax
	pop	esi

; 146  : }

	ret	0
$LN2@xmlBufCrea:

; 129  :     }
; 130  :     ret->compat_use = 0;

	mov	DWORD PTR [esi+4], 0

; 131  :     ret->use = 0;

	mov	DWORD PTR [esi+20], 0

; 132  :     ret->error = 0;

	mov	DWORD PTR [esi+32], 0

; 133  :     ret->buffer = NULL;

	mov	DWORD PTR [esi+28], 0

; 134  :     ret->size = xmlDefaultBufferSize;

	call	___xmlDefaultBufferSize
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+24], eax

; 135  :     ret->compat_size = xmlDefaultBufferSize;

	call	___xmlDefaultBufferSize
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+8], eax

; 136  :     ret->alloc = xmlBufferAllocScheme;

	call	___xmlBufferAllocScheme

; 137  :     ret->content = (xmlChar *) xmlMallocAtomic(ret->size * sizeof(xmlChar));

	push	DWORD PTR [esi+24]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+12], eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 138  :     if (ret->content == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlBufCrea

; 94   :     __xmlSimpleError(XML_FROM_BUFFER, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	eax
	push	eax
	push	2
	push	29					; 0000001dH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 95   :     if ((buf) && (buf->error == 0))

	cmp	DWORD PTR [esi+32], 0
	jne	SHORT $LN9@xmlBufCrea

; 96   :         buf->error = XML_ERR_NO_MEMORY;

	mov	DWORD PTR [esi+32], 2
$LN9@xmlBufCrea:

; 139  : 	xmlBufMemoryError(ret, "creating buffer");
; 140  : 	xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 141  :         return(NULL);

	xor	eax, eax
	pop	esi

; 146  : }

	ret	0
$LN3@xmlBufCrea:

; 142  :     }
; 143  :     ret->content[0] = 0;

	mov	BYTE PTR [eax], 0

; 144  :     ret->contentIO = NULL;
; 145  :     return(ret);

	mov	eax, esi
	mov	DWORD PTR [esi+16], 0
	pop	esi

; 146  : }

	ret	0
_xmlBufCreate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufShrink
_TEXT	SEGMENT
tv521 = 8						; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlBufShrink PROC					; COMDAT

; 388  : xmlBufShrink(xmlBufPtr buf, size_t len) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	$LN3@xmlBufShri

; 389  :     if ((buf == NULL) || (buf->error != 0)) return(0);

	cmp	DWORD PTR [esi+32], 0
	jne	$LN3@xmlBufShri

; 390  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+8]
	cmp	ecx, eax
	je	SHORT $LN5@xmlBufShri
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufShri
	mov	DWORD PTR [esi+24], eax
	mov	ecx, eax
$LN5@xmlBufShri:
	mov	edx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	je	SHORT $LN7@xmlBufShri
	cmp	eax, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufShri
	mov	DWORD PTR [esi+20], eax
	mov	edx, eax
$LN7@xmlBufShri:

; 391  :     if (len == 0) return(0);

	mov	edi, DWORD PTR _len$[ebp]
	test	edi, edi
	je	$LN3@xmlBufShri

; 392  :     if (len > buf->use) return(0);

	cmp	edi, edx
	ja	$LN3@xmlBufShri

; 393  : 
; 394  :     buf->use -= len;

	push	ebx

; 395  :     if ((buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) ||

	mov	ebx, DWORD PTR [esi+12]
	sub	edx, edi
	mov	DWORD PTR [esi+20], edx
	cmp	ebx, 2
	je	SHORT $LN21@xmlBufShri
	cmp	ebx, 3
	jne	SHORT $LN10@xmlBufShri
	cmp	DWORD PTR [esi+16], 0
	jne	SHORT $LN21@xmlBufShri
$LN10@xmlBufShri:

; 415  : 	    }
; 416  : 	}
; 417  :     } else {
; 418  : 	memmove(buf->content, &buf->content[len], buf->use);

	mov	ecx, DWORD PTR [esi]
	push	edx
	lea	eax, DWORD PTR [ecx+edi]
	push	eax
	push	ecx
	call	_memmove

; 419  : 	buf->content[buf->use] = 0;

	mov	ecx, DWORD PTR [esi+20]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [ecx+eax], 0
	jmp	SHORT $LN22@xmlBufShri
$LN21@xmlBufShri:

; 396  :         ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL))) {
; 397  : 	/*
; 398  : 	 * we just move the content pointer, but also make sure
; 399  : 	 * the perceived buffer size has shrinked accordingly
; 400  : 	 */
; 401  :         buf->content += len;

	mov	eax, DWORD PTR [esi]

; 402  : 	buf->size -= len;

	sub	ecx, edi
	add	eax, edi
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR tv521[ebp], eax
	mov	DWORD PTR [esi], eax

; 403  : 
; 404  :         /*
; 405  : 	 * sometimes though it maybe be better to really shrink
; 406  : 	 * on IO buffers
; 407  : 	 */
; 408  : 	if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {

	mov	eax, ecx
	cmp	ebx, 3
	jne	SHORT $LN14@xmlBufShri
	cmp	DWORD PTR [esi+16], 0
	je	SHORT $LN14@xmlBufShri

; 409  : 	    size_t start_buf = buf->content - buf->contentIO;

	mov	ebx, DWORD PTR tv521[ebp]
	sub	ebx, DWORD PTR [esi+16]

; 410  : 	    if (start_buf >= buf->size) {

	cmp	ebx, ecx
	jb	SHORT $LN14@xmlBufShri

; 411  : 		memmove(buf->contentIO, &buf->content[0], buf->use);

	push	edx
	push	DWORD PTR tv521[ebp]
	push	DWORD PTR [esi+16]
	call	_memmove

; 412  : 		buf->content = buf->contentIO;

	mov	ecx, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH

; 413  : 		buf->content[buf->use] = 0;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi], ecx
	mov	BYTE PTR [ecx+eax], 0

; 414  : 		buf->size += start_buf;

	add	DWORD PTR [esi+24], ebx
$LN22@xmlBufShri:

; 420  :     }
; 421  :     UPDATE_COMPAT(buf)

	mov	eax, DWORD PTR [esi+24]
$LN14@xmlBufShri:
	mov	edx, 2147483647				; 7fffffffH
	cmp	eax, edx
	mov	ecx, edx

; 422  :     return(len);

	pop	ebx
	cmovb	ecx, eax
	mov	eax, edi
	mov	DWORD PTR [esi+8], ecx
	cmp	DWORD PTR [esi+20], edx
	pop	edi
	cmovb	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+4], edx

; 423  : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlBufShri:
	pop	edi

; 389  :     if ((buf == NULL) || (buf->error != 0)) return(0);

	xor	eax, eax

; 423  : }

	pop	esi
	pop	ebp
	ret	0
_xmlBufShrink ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufUse
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufUse PROC						; COMDAT

; 688  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _buf$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlBufUse

; 689  :     if ((!buf) || (buf->error))

	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN3@xmlBufUse

; 691  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [eax+24], ecx
	je	SHORT $LN5@xmlBufUse
	cmp	ecx, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufUse
	mov	DWORD PTR [eax+24], ecx
$LN5@xmlBufUse:
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax+4]
	cmp	ecx, edx
	je	SHORT $LN7@xmlBufUse
	cmp	edx, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufUse
	mov	DWORD PTR [eax+20], edx
	mov	ecx, edx
$LN7@xmlBufUse:

; 692  : 
; 693  :     return(buf->use);

	mov	eax, ecx

; 694  : }

	pop	ebp
	ret	0
$LN3@xmlBufUse:

; 690  :         return 0;

	xor	eax, eax

; 694  : }

	pop	ebp
	ret	0
_xmlBufUse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufEnd
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufEnd PROC						; COMDAT

; 601  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _buf$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlBufEnd

; 602  :     if ((!buf) || (buf->error))

	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN3@xmlBufEnd

; 604  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [eax+24], ecx
	je	SHORT $LN5@xmlBufEnd
	cmp	ecx, 2147483647				; 7fffffffH
	jae	SHORT $LN5@xmlBufEnd
	mov	DWORD PTR [eax+24], ecx
$LN5@xmlBufEnd:
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax+4]
	cmp	ecx, edx
	je	SHORT $LN7@xmlBufEnd
	cmp	edx, 2147483647				; 7fffffffH
	jae	SHORT $LN7@xmlBufEnd
	mov	DWORD PTR [eax+20], edx
	mov	ecx, edx
$LN7@xmlBufEnd:

; 605  : 
; 606  :     return(&buf->content[buf->use]);

	mov	eax, DWORD PTR [eax]
	add	eax, ecx

; 607  : }

	pop	ebp
	ret	0
$LN3@xmlBufEnd:

; 603  :         return NULL;

	xor	eax, eax

; 607  : }

	pop	ebp
	ret	0
_xmlBufEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufContent
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufContent PROC					; COMDAT

; 583  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _buf$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlBufCont

; 584  :     if ((!buf) || (buf->error))

	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN3@xmlBufCont

; 586  : 
; 587  :     return(buf->content);

	mov	eax, DWORD PTR [eax]

; 588  : }

	pop	ebp
	ret	0
$LN3@xmlBufCont:

; 585  :         return NULL;

	xor	eax, eax

; 588  : }

	pop	ebp
	ret	0
_xmlBufContent ENDP
_TEXT	ENDS
END
