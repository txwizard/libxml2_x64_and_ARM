; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\relaxng.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CE@EODHHDFK@http?3?1?1relaxng?4org?1ns?1structure@ ; `string'
PUBLIC	??_C@_01KHDNNMEB@?$AB@				; `string'
_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
;	COMDAT ??_C@_01KHDNNMEB@?$AB@
CONST	SEGMENT
??_C@_01KHDNNMEB@?$AB@ DB 01H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EODHHDFK@http?3?1?1relaxng?4org?1ns?1structure@
CONST	SEGMENT
??_C@_0CE@EODHHDFK@http?3?1?1relaxng?4org?1ns?1structure@ DB 'http://rela'
	DB	'xng.org/ns/structure/1.0', 00H		; `string'
CONST	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__49DBE4F2_relaxng@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_snprintf
PUBLIC	_xmlRelaxNGInitTypes
PUBLIC	_xmlRelaxNGCleanupTypes
PUBLIC	_xmlRelaxNGNewParserCtxt
PUBLIC	_xmlRelaxNGNewMemParserCtxt
PUBLIC	_xmlRelaxNGNewDocParserCtxt
PUBLIC	_xmlRelaxParserSetFlag
PUBLIC	_xmlRelaxNGFreeParserCtxt
PUBLIC	_xmlRelaxNGSetParserErrors
PUBLIC	_xmlRelaxNGGetParserErrors
PUBLIC	_xmlRelaxNGSetParserStructuredErrors
PUBLIC	_xmlRelaxNGParse
PUBLIC	_xmlRelaxNGFree
PUBLIC	_xmlRelaxNGDump
PUBLIC	_xmlRelaxNGDumpTree
PUBLIC	_xmlRelaxNGSetValidErrors
PUBLIC	_xmlRelaxNGGetValidErrors
PUBLIC	_xmlRelaxNGSetValidStructuredErrors
PUBLIC	_xmlRelaxNGNewValidCtxt
PUBLIC	_xmlRelaxNGFreeValidCtxt
PUBLIC	_xmlRelaxNGValidateDoc
PUBLIC	_xmlRelaxNGValidatePushElement
PUBLIC	_xmlRelaxNGValidatePushCData
PUBLIC	_xmlRelaxNGValidatePopElement
PUBLIC	_xmlRelaxNGValidateFullElement
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@ ; `string'
PUBLIC	??_C@_0BD@KFBIDMJP@allocating?5define?6@	; `string'
PUBLIC	??_C@_0BD@FIBAKIJP@allocating?5states?6@	; `string'
PUBLIC	??_C@_0P@NLODGFON@adding?5states?6@		; `string'
PUBLIC	??_C@_0BA@DKBKEJJK@storing?5states?6@		; `string'
PUBLIC	??_C@_0BE@NICNHGJN@allocating?5include?6@	; `string'
PUBLIC	??_C@_05FAGFPHJG@start@				; `string'
PUBLIC	??_C@_06EPMMJFDC@define@			; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_07FHOHOHLG@include@			; `string'
PUBLIC	??_C@_07EFOLCII@grammar@			; `string'
PUBLIC	??_C@_0CG@MLBLJJIG@Detected?5an?5Include?5recursion?5f@ ; `string'
PUBLIC	??_C@_0BP@BDBHMEOE@xmlRelaxNG?3?5could?5not?5load?5?$CFs?6@ ; `string'
PUBLIC	??_C@_02EGOFOKPC@ns@				; `string'
PUBLIC	??_C@_0CL@MDFAGPKO@xmlRelaxNG?3?5included?5document?5i@ ; `string'
PUBLIC	??_C@_0DI@NNDELAMP@xmlRelaxNG?3?5included?5document?5?$CF@ ; `string'
PUBLIC	??_C@_0EB@LAOLKJIK@xmlRelaxNG?3?5include?5?$CFs?5has?5a?5st@ ; `string'
PUBLIC	??_C@_0DA@OCDIDEDL@xmlRelaxNG?3?5include?5?$CFs?5has?5defi@ ; `string'
PUBLIC	??_C@_0EF@PNICLKOF@xmlRelaxNG?3?5include?5?$CFs?5has?5a?5de@ ; `string'
PUBLIC	??_C@_03FEJMGOGI@div@				; `string'
PUBLIC	??_C@_0P@JOLGCMKD@pushing?5error?6@		; `string'
PUBLIC	??_C@_0BB@MHBNCBHM@adding?5document?6@		; `string'
PUBLIC	??_C@_0CK@BCCMNNOD@Detected?5an?5externalRef?5recursi@ ; `string'
PUBLIC	??_C@_0CI@PEJCGLNC@xmlRelaxNG?3?5allocate?5memory?5for@ ; `string'
PUBLIC	??_C@_04CGFJFPFD@none@				; `string'
PUBLIC	??_C@_05LBJMNBOG@empty@				; `string'
PUBLIC	??_C@_0L@GPGJMKBL@notAllowed@			; `string'
PUBLIC	??_C@_06JBKEBCGB@except@			; `string'
PUBLIC	??_C@_04CIMGMMMG@text@				; `string'
PUBLIC	??_C@_07HCLJNICE@element@			; `string'
PUBLIC	??_C@_08IJKJONLA@datatype@			; `string'
PUBLIC	??_C@_05MFEJDJP@value@				; `string'
PUBLIC	??_C@_04DONFEANM@list@				; `string'
PUBLIC	??_C@_09HGIEBAJ@attribute@			; `string'
PUBLIC	??_C@_03BHEEIFFN@def@				; `string'
PUBLIC	??_C@_03GCDGINBO@ref@				; `string'
PUBLIC	??_C@_0M@CPEFJFBC@externalRef@			; `string'
PUBLIC	??_C@_09LEMMFILP@parentRef@			; `string'
PUBLIC	??_C@_08EBGGHLAO@optional@			; `string'
PUBLIC	??_C@_0L@BANFCDDP@zeroOrMore@			; `string'
PUBLIC	??_C@_09EIEDMNLG@oneOrMore@			; `string'
PUBLIC	??_C@_06DDDNEJEA@choice@			; `string'
PUBLIC	??_C@_05MGJOOGAJ@group@				; `string'
PUBLIC	??_C@_0L@NLPEADBD@interleave@			; `string'
PUBLIC	??_C@_04BACONDHA@noop@				; `string'
PUBLIC	??_C@_05LJDNNBIK@param@				; `string'
PUBLIC	??_C@_07CIFAGBMG@unknown@			; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0P@PCJPAHLM@out?5of?5memory?6@		; `string'
PUBLIC	??_C@_0BM@ECNPKFCP@failed?5to?5validate?5type?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CC@KEMEBCBB@Type?5?$CFs?5doesn?8t?5allow?5value?5?8?$CFs@ ; `string'
PUBLIC	??_C@_0BB@HOPAIONI@ID?5?$CFs?5redefined?6@	; `string'
PUBLIC	??_C@_0BL@NPBAOLP@failed?5to?5compare?5type?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BK@NEMAGDEO@Internal?5error?3?5no?5state?6@ ; `string'
PUBLIC	??_C@_0BL@MNHHIDKB@Internal?5error?3?5no?5define?6@ ; `string'
PUBLIC	??_C@_0BE@MNPHNNMB@Internal?5error?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BI@DGHEOLEJ@Extra?5data?5in?5list?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CI@IMJEPEGE@Internal?3?5interleave?5block?5has?5@ ; `string'
PUBLIC	??_C@_0CA@EOAAMELI@Invalid?5sequence?5in?5interleave?6@ ; `string'
PUBLIC	??_C@_0CA@LHKGPAAK@Extra?5element?5?$CFs?5in?5interleave?6@ ; `string'
PUBLIC	??_C@_0BO@IPFGDLDE@Expecting?5element?5?$CFs?0?5got?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CG@JOOKFIPP@Expecting?5a?5namespace?5for?5eleme@ ; `string'
PUBLIC	??_C@_0CO@FJCKMMIH@Element?5?$CFs?5has?5wrong?5namespace?3@ ; `string'
PUBLIC	??_C@_0CB@PHEJHGKI@Did?5not?5expect?5element?5?$CFs?5there@ ; `string'
PUBLIC	??_C@_0CL@PJGOEKPA@Did?5not?5expect?5text?5in?5element?5@ ; `string'
PUBLIC	??_C@_0CH@HAJGKJGA@Expecting?5no?5namespace?5for?5elem@ ; `string'
PUBLIC	??_C@_0CC@DNABBFDN@Expecting?5element?5?$CFs?5to?5be?5empt@ ; `string'
PUBLIC	??_C@_0CG@GHEDPKLH@Expecting?5an?5element?5?$CFs?0?5got?5no@ ; `string'
PUBLIC	??_C@_0BP@PIOGJCNK@Expecting?5an?5element?5got?5text?6@ ; `string'
PUBLIC	??_C@_0CK@NNGAPDCO@Element?5?$CFs?5failed?5to?5validate?5a@ ; `string'
PUBLIC	??_C@_0CH@HDDGPFIH@Element?5?$CFs?5failed?5to?5validate?5c@ ; `string'
PUBLIC	??_C@_0CC@PHDGKAKM@Element?5?$CFs?5has?5extra?5content?3?5?$CF@ ; `string'
PUBLIC	??_C@_0CF@ECDDKCLG@Invalid?5attribute?5?$CFs?5for?5elemen@ ; `string'
PUBLIC	??_C@_0CG@FMKMGJKC@Datatype?5element?5?$CFs?5contains?5no@ ; `string'
PUBLIC	??_C@_0CI@NMBBKCFB@Datatype?5element?5?$CFs?5has?5child?5e@ ; `string'
PUBLIC	??_C@_0CF@MGMBBHLP@Value?5element?5?$CFs?5has?5child?5elem@ ; `string'
PUBLIC	??_C@_0CE@LKJLECIM@List?5element?5?$CFs?5has?5child?5eleme@ ; `string'
PUBLIC	??_C@_0BO@GLDGEAAK@Error?5validating?5datatype?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BL@BLOANDFF@Error?5validating?5value?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BH@MNIEAPHM@Error?5validating?5list?6@	; `string'
PUBLIC	??_C@_0BI@LEPPKIJB@No?5top?5grammar?5defined?6@	; `string'
PUBLIC	??_C@_0BM@HIGEPHGM@Extra?5data?5in?5the?5document?6@ ; `string'
PUBLIC	??_C@_0BB@OENMHDGG@Unknown?5error?5?$CB?6@	; `string'
PUBLIC	??_C@_0BH@OAFIADK@Unknown?5error?5code?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@ ; `string'
PUBLIC	??_C@_0N@BDECKIL@minInclusive@			; `string'
PUBLIC	??_C@_0N@MENCPBPO@minExclusive@			; `string'
PUBLIC	??_C@_0N@EBHLFCPN@maxInclusive@			; `string'
PUBLIC	??_C@_0N@IEJNIJII@maxExclusive@			; `string'
PUBLIC	??_C@_0M@PGNNBCIB@totalDigits@			; `string'
PUBLIC	??_C@_0P@EPJLKDGA@fractionDigits@		; `string'
PUBLIC	??_C@_07CHFOACKJ@pattern@			; `string'
PUBLIC	??_C@_0M@FJOIDAAJ@enumeration@			; `string'
PUBLIC	??_C@_0L@CCEMGGFL@whiteSpace@			; `string'
PUBLIC	??_C@_06IJDLPEM@length@				; `string'
PUBLIC	??_C@_09KJHMKBNK@maxLength@			; `string'
PUBLIC	??_C@_09KIHADLGO@minLength@			; `string'
PUBLIC	??_C@_06ICGJLFIM@string@			; `string'
PUBLIC	??_C@_05JMKJMOPH@token@				; `string'
PUBLIC	??_C@_0DA@KBDGNEEG@Relax?9NG?5types?5library?5?8?$CFs?8?5alr@ ; `string'
PUBLIC	??_C@_0BG@BMGNHHOA@adding?5types?5library?6@	; `string'
PUBLIC	??_C@_0DA@DKNFFGLK@Relax?9NG?5types?5library?5failed?5t@ ; `string'
PUBLIC	??_C@_0DA@BNBDCCII@Failed?5to?5allocate?5sh?5table?5for@ ; `string'
PUBLIC	??_C@_0CL@MAOGIMDF@http?3?1?1www?4w3?4org?12001?1XMLSchem@ ; `string'
PUBLIC	??_C@_05NOBOONOA@?$CDtext@			; `string'
PUBLIC	??_C@_0CJ@JOFHGKIK@RNG?5internal?5error?5trying?5to?5co@ ; `string'
PUBLIC	??_C@_04PJOLNDGD@data@				; `string'
PUBLIC	??_C@_0BA@OLOJGOCH@datatypeLibrary@		; `string'
PUBLIC	??_C@_04EIMIMFCI@?3?1?$CD?$DP@			; `string'
PUBLIC	??_C@_04GPMDFGEJ@type@				; `string'
PUBLIC	??_C@_0CC@HGJHHNGH@value?5type?5?8?$CFs?8?5is?5not?5an?5NCNam@ ; `string'
PUBLIC	??_C@_0CH@BAFMNDJC@Use?5of?5unregistered?5type?5librar@ ; `string'
PUBLIC	??_C@_0DC@GFLCPBDN@Internal?5error?5with?5type?5librar@ ; `string'
PUBLIC	??_C@_0DG@BCJPPODI@Error?5type?5?8?$CFs?8?5is?5not?5exported@ ; `string'
PUBLIC	??_C@_0DC@DOAINIPC@Expecting?5a?5single?5text?5value?5f@ ; `string'
PUBLIC	??_C@_0CA@OGDHDPEE@Element?5?$DMvalue?$DO?5has?5no?5content?6@ ; `string'
PUBLIC	??_C@_0CM@DOBLDJBI@Value?5?8?$CFs?8?5is?5not?5acceptable?5fo@ ; `string'
PUBLIC	??_C@_0BC@JLMCOJJL@data?5has?5no?5type?6@	; `string'
PUBLIC	??_C@_0CB@BPINBNAH@data?5type?5?8?$CFs?8?5is?5not?5an?5NCName@ ; `string'
PUBLIC	??_C@_05HKGPJLPA@IDREF@				; `string'
PUBLIC	??_C@_06CMFBJDBA@IDREFS@			; `string'
PUBLIC	??_C@_0DC@MKALBABO@Type?5library?5?8?$CFs?8?5does?5not?5allo@ ; `string'
PUBLIC	??_C@_0BD@HHALNFAB@param?5has?5no?5name?6@	; `string'
PUBLIC	??_C@_0BH@BGPIOKNJ@except?5has?5no?5content?6@	; `string'
PUBLIC	??_C@_0CI@PINMOFEF@Element?5data?5has?5unexpected?5con@ ; `string'
PUBLIC	??_C@_0GJ@NFABHKPN@c?3?2users?2dag?2documents?2_clients@ ; `string'
PUBLIC	??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ ; `string'
PUBLIC	??_C@_0BG@CHOOIKPA@getting?5element?5list?6@	; `string'
PUBLIC	??_C@_0BB@HIJGJJAM@building?5choice?6@		; `string'
PUBLIC	??_C@_04IAJCOJMF@?$CDany@			; `string'
PUBLIC	??_C@_0BA@MBENMANO@building?5group?6@		; `string'
PUBLIC	??_C@_0BP@PNPCONEA@Attributes?5conflicts?5in?5group?6@ ; `string'
PUBLIC	??_C@_0CJ@CIKEPODC@Element?5or?5text?5conflicts?5in?5in@ ; `string'
PUBLIC	??_C@_0CE@PJGIOECJ@Attributes?5conflicts?5in?5interle@ ; `string'
PUBLIC	??_C@_0BL@FDJODHDJ@in?5interleave?5computation?6@ ; `string'
PUBLIC	??_C@_0BE@JIDAHLJE@create?5interleaves?6@	; `string'
PUBLIC	??_C@_0N@MHPBOBHE@interleave?$CFd@		; `string'
PUBLIC	??_C@_0CA@BLFIOJCN@Failed?5to?5add?5?$CFs?5to?5hash?5table?6@ ; `string'
PUBLIC	??_C@_0BN@JGOKJKPH@Element?5interleave?5is?5empty?6@ ; `string'
PUBLIC	??_C@_0BK@PJHELFJE@Include?5node?5has?5no?5data?6@ ; `string'
PUBLIC	??_C@_0BL@NJFOGBOE@Include?5document?5is?5empty?6@ ; `string'
PUBLIC	??_C@_0CI@GFEIPOEG@Include?5document?5root?5is?5not?5a?5@ ; `string'
PUBLIC	??_C@_0BE@OMGBAGKJ@define?5has?5no?5name?6@	; `string'
PUBLIC	??_C@_0CD@LEKDIHDI@define?5name?5?8?$CFs?8?5is?5not?5an?5NCNa@ ; `string'
PUBLIC	??_C@_0BI@KMIJHMFO@define?5has?5no?5children?6@	; `string'
PUBLIC	??_C@_0CC@EGGMPODH@Could?5not?5create?5definition?5has@ ; `string'
PUBLIC	??_C@_0CM@PJMCGFMO@Internal?5error?5on?5define?5aggreg@ ; `string'
PUBLIC	??_C@_0BN@KBAJDCGM@Error?5refs?5definitions?5?8?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0BI@KAJIFPGI@Error?5refs?5definitions?6@	; `string'
PUBLIC	??_C@_0CC@NOKALBCN@Could?5not?5create?5references?5has@ ; `string'
PUBLIC	??_C@_0BO@JMOIDLLM@xmlRelaxNGParse?3?5?$CFs?5is?5empty?6@ ; `string'
PUBLIC	??_C@_0BJ@FKDMDHPF@empty?3?5had?5a?5child?5node?6@ ; `string'
PUBLIC	??_C@_0BI@LOCKCMHG@text?3?5had?5a?5child?5node?6@ ; `string'
PUBLIC	??_C@_0BF@BCLGKPIM@Element?5?$CFs?5is?5empty?6@	; `string'
PUBLIC	??_C@_0BB@BOHONICN@ref?5has?5no?5name?6@	; `string'
PUBLIC	??_C@_0CA@CEHKGAHL@ref?5name?5?8?$CFs?8?5is?5not?5an?5NCName?6@ ; `string'
PUBLIC	??_C@_0BC@KLFBBEAG@ref?5is?5not?5empty?6@	; `string'
PUBLIC	??_C@_0DC@MEMHAAID@xmlRelaxNGParse?3?5notAllowed?5ele@ ; `string'
PUBLIC	??_C@_0CL@EGBMGFAB@Use?5of?5parentRef?5without?5a?5pare@ ; `string'
PUBLIC	??_C@_0BH@CNIAONFA@parentRef?5has?5no?5name?6@	; `string'
PUBLIC	??_C@_0CG@HCJCFDNF@parentRef?5name?5?8?$CFs?8?5is?5not?5an?5N@ ; `string'
PUBLIC	??_C@_0BI@IFNGOHLC@parentRef?5is?5not?5empty?6@	; `string'
PUBLIC	??_C@_0CL@BEBEIBPH@Internal?5error?5parentRef?5defini@ ; `string'
PUBLIC	??_C@_05IPHDHIPP@mixed@				; `string'
PUBLIC	??_C@_0BA@KLBAOPHA@Mixed?5is?5empty?6@		; `string'
PUBLIC	??_C@_0CF@JOIAOFAL@Unexpected?5node?5?$CFs?5is?5not?5a?5pat@ ; `string'
PUBLIC	??_C@_0DF@EOBONIDO@xmlRelaxNGParseattribute?3?5attri@ ; `string'
PUBLIC	??_C@_0BP@NPGIAHLH@attribute?5has?5invalid?5content?6@ ; `string'
PUBLIC	??_C@_0CN@KBLNJNDN@RNG?5Internal?5error?0?5noop?5found?5@ ; `string'
PUBLIC	??_C@_0CB@BOMNCDFG@attribute?5has?5multiple?5children@ ; `string'
PUBLIC	??_C@_0BK@FIOBKDGD@Expecting?5an?5except?5node?6@ ; `string'
PUBLIC	??_C@_0DC@LBJNBDAD@exceptNameClass?5allows?5only?5a?5s@ ; `string'
PUBLIC	??_C@_07ENOEFKNN@anyName@			; `string'
PUBLIC	??_C@_06IHANJIJ@nsName@				; `string'
PUBLIC	??_C@_0CH@CJKCJPCE@Element?5?$CFs?5name?5?8?$CFs?8?5is?5not?5an?5@ ; `string'
PUBLIC	??_C@_0BM@EMBMPALF@name?5?8?$CFs?8?5is?5not?5an?5NCName?6@ ; `string'
PUBLIC	??_C@_0BN@FIBBGPIH@http?3?1?1www?4w3?4org?12000?1xmlns@ ; `string'
PUBLIC	??_C@_0CO@HDKKBGMJ@Attribute?5with?5namespace?5?8?$CFs?8?5i@ ; `string'
PUBLIC	??_C@_05PPEFOGKI@xmlns@				; `string'
PUBLIC	??_C@_0CN@HLKDALFC@Attribute?5with?5QName?5?8xmlns?8?5is@ ; `string'
PUBLIC	??_C@_0BM@OBCEAFCO@nsName?5has?5no?5ns?5attribute?6@ ; `string'
PUBLIC	??_C@_0BJ@LPGNADIK@Element?5choice?5is?5empty?6@ ; `string'
PUBLIC	??_C@_07DFGIHOIL@nothing@			; `string'
PUBLIC	??_C@_0DE@HGEBBBBP@expecting?5name?0?5anyName?0?5nsName@ ; `string'
PUBLIC	??_C@_0DB@JEBMCLMO@xmlRelaxNGParseElement?3?5element@ ; `string'
PUBLIC	??_C@_0DA@IDPILCIF@xmlRelaxNGParseElement?3?5element@ ; `string'
PUBLIC	??_C@_0CM@MFMPBBAO@RNG?5Internal?5error?0?5start?5found@ ; `string'
PUBLIC	??_C@_0CM@LPIDEEPC@RNG?5Internal?5error?0?5param?5found@ ; `string'
PUBLIC	??_C@_0CN@HLONCHKK@RNG?5Internal?5error?0?5except?5foun@ ; `string'
PUBLIC	??_C@_0CL@MLMNOJNJ@RNG?5Internal?5error?0?5noop?5found?5@ ; `string'
PUBLIC	??_C@_0BH@HFFJFLLH@start?5has?5no?5children?6@	; `string'
PUBLIC	??_C@_0BM@NFEKGCB@element?5empty?5is?5not?5empty?6@ ; `string'
PUBLIC	??_C@_0CB@CILNEPNL@element?5notAllowed?5is?5not?5empty@ ; `string'
PUBLIC	??_C@_0BO@LLNPKKPG@start?5more?5than?5one?5children?6@ ; `string'
PUBLIC	??_C@_0BJ@FLPPFCBJ@grammar?5has?5no?5children?6@ ; `string'
PUBLIC	??_C@_0CB@DOHNNNEN@grammar?5has?5unexpected?5child?5?$CFs@ ; `string'
PUBLIC	??_C@_0DB@CFGFLOFC@Internal?5error?3?5no?5grammar?5in?5C@ ; `string'
PUBLIC	??_C@_0DM@EAGPADBI@Internal?5error?3?5reference?5has?5c@ ; `string'
PUBLIC	??_C@_0CJ@POOAHNP@Reference?5?$CFs?5has?5no?5matching?5de@ ; `string'
PUBLIC	??_C@_07PCDCECCK@combine@			; `string'
PUBLIC	??_C@_0DD@LACLCNBH@Defines?5for?5?$CFs?5use?5both?5?8choice@ ; `string'
PUBLIC	??_C@_0DA@BFEPFJDA@Defines?5for?5?$CFs?5use?5unknown?5comb@ ; `string'
PUBLIC	??_C@_0DB@MHLFAPLB@Some?5defines?5for?5?$CFs?5needs?5the?5c@ ; `string'
PUBLIC	??_C@_0CJ@MHLGCECD@Failed?5to?5create?5interleaves?5ha@ ; `string'
PUBLIC	??_C@_0CJ@EGDAKNFC@Internal?5error?3?5start?5element?5n@ ; `string'
PUBLIC	??_C@_0CM@KNKPDGOJ@?$DMstart?$DO?5use?5both?5?8choice?8?5and?5?8@ ; `string'
PUBLIC	??_C@_0CK@DGGLNMFN@?$DMstart?$DO?5uses?5unknown?5combine?5va@ ; `string'
PUBLIC	??_C@_0DB@FEIAJIL@Some?5?$DMstart?$DO?5element?5miss?5the?5c@ ; `string'
PUBLIC	??_C@_0CD@GDGLIOPD@Detected?5a?5cycle?5in?5?$CFs?5referenc@ ; `string'
PUBLIC	??_C@_0CK@JHAPLGCC@Found?5forbidden?5pattern?5data?1ex@ ; `string'
PUBLIC	??_C@_0CK@BAJLBNJH@Internal?5found?5no?5define?5for?5pa@ ; `string'
PUBLIC	??_C@_04MLLLIHIP@null@				; `string'
PUBLIC	??_C@_0CF@GFDJFDLL@Internal?5found?5no?5define?5for?5re@ ; `string'
PUBLIC	??_C@_0DD@HDAPPKEG@Found?5forbidden?5pattern?5data?1ex@ ; `string'
PUBLIC	??_C@_0CM@EGCJFEMH@Found?5forbidden?5pattern?5list?1?1e@ ; `string'
PUBLIC	??_C@_0DB@MJBLDFBL@Found?5forbidden?5pattern?5attribu@ ; `string'
PUBLIC	??_C@_0DB@COIJMLBL@Element?5?$CFs?5attributes?5have?5a?5co@ ; `string'
PUBLIC	??_C@_0CF@DGIEHIGM@Element?5?$CFs?5has?5a?5content?5type?5e@ ; `string'
PUBLIC	??_C@_0CO@INMFBEHE@Found?5forbidden?5pattern?5attribu@ ; `string'
PUBLIC	??_C@_0CJ@MJOFOIHP@Found?5forbidden?5pattern?5list?1?1a@ ; `string'
PUBLIC	??_C@_0DF@EKCKBFFE@Found?5forbidden?5pattern?5oneOrMo@ ; `string'
PUBLIC	??_C@_0DK@NGAGBKIF@Found?5forbidden?5pattern?5oneOrMo@ ; `string'
PUBLIC	??_C@_0DA@ENKJFBDG@Found?5forbidden?5pattern?5data?1ex@ ; `string'
PUBLIC	??_C@_0CK@BCEDDHLB@Found?5forbidden?5pattern?5start?1?1@ ; `string'
PUBLIC	??_C@_0DE@BFPCKEFO@Found?5anyName?5attribute?5without@ ; `string'
PUBLIC	??_C@_0DD@LLONPEJF@Found?5nsName?5attribute?5without?5@ ; `string'
PUBLIC	??_C@_0DA@BGDINEKH@Found?5forbidden?5pattern?5data?1ex@ ; `string'
PUBLIC	??_C@_0CK@EJNCLCCA@Found?5forbidden?5pattern?5start?1?1@ ; `string'
PUBLIC	??_C@_0CE@NEHBNEAE@Found?5forbidden?5pattern?5list?1?1l@ ; `string'
PUBLIC	??_C@_0CL@OKJMMKMF@Found?5forbidden?5pattern?5data?1ex@ ; `string'
PUBLIC	??_C@_0CF@DLNDBMML@Found?5forbidden?5pattern?5start?1?1@ ; `string'
PUBLIC	??_C@_0CM@DONHBELN@Found?5forbidden?5pattern?5data?1ex@ ; `string'
PUBLIC	??_C@_0CG@NJLOHGGM@Found?5forbidden?5pattern?5start?1?1@ ; `string'
PUBLIC	??_C@_0CK@GDHHJMOD@Found?5forbidden?5pattern?5list?1?1i@ ; `string'
PUBLIC	??_C@_0DB@GMPDCJGO@Found?5forbidden?5pattern?5data?1ex@ ; `string'
PUBLIC	??_C@_0CL@BPHANFIL@Found?5forbidden?5pattern?5start?1?1@ ; `string'
PUBLIC	??_C@_0CF@GAMKIMEF@Found?5forbidden?5pattern?5start?1?1@ ; `string'
PUBLIC	??_C@_0CG@MABIIKGI@Found?5forbidden?5pattern?5start?1?1@ ; `string'
PUBLIC	??_C@_0CE@CJAFDOPC@Found?5forbidden?5pattern?5list?1?1t@ ; `string'
PUBLIC	??_C@_0CL@BHOICADD@Found?5forbidden?5pattern?5data?1ex@ ; `string'
PUBLIC	??_C@_0CF@MGKHPGDN@Found?5forbidden?5pattern?5start?1?1@ ; `string'
PUBLIC	??_C@_0CM@OBFOJGD@Found?5forbidden?5pattern?5data?1ex@ ; `string'
PUBLIC	??_C@_0CG@OJHMILLC@Found?5forbidden?5pattern?5start?1?1@ ; `string'
PUBLIC	??_C@_0CC@BLDDIJOB@Element?5?$DMgrammar?$DO?5has?5no?5?$DMstart@ ; `string'
PUBLIC	??_C@_0BB@LGCAJOFI@building?5parser?6@		; `string'
PUBLIC	??_C@_0CD@DKPPJJNH@Attribute?5?$CFs?5is?5not?5allowed?5on?5@ ; `string'
PUBLIC	??_C@_04CMBCJJJD@href@				; `string'
PUBLIC	??_C@_0CG@BHOFIFCK@Attribute?5?$CFs?5contains?5invalid?5U@ ; `string'
PUBLIC	??_C@_0CF@MJPHBHBO@Attribute?5?$CFs?5URI?5?$CFs?5is?5not?5abso@ ; `string'
PUBLIC	??_C@_0CH@HOEFBPIP@Attribute?5?$CFs?5URI?5?$CFs?5has?5a?5fragm@ ; `string'
PUBLIC	??_C@_0BM@DCBEKLDL@Unknown?5attribute?5?$CFs?5on?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CL@IEADNMBI@element?5?$CFs?5doesn?8t?5allow?5foreig@ ; `string'
PUBLIC	??_C@_0DE@IKNPMFHP@xmlRelaxNGParse?3?5externalRef?5ha@ ; `string'
PUBLIC	??_C@_0CC@NOODBOMC@Incorrect?5URI?5for?5externalRef?5?$CF@ ; `string'
PUBLIC	??_C@_0CO@GJLFMGAP@Fragment?5forbidden?5in?5URI?5for?5e@ ; `string'
PUBLIC	??_C@_0CK@MJBGKOFC@Failed?5to?5compute?5URL?5for?5exter@ ; `string'
PUBLIC	??_C@_0BP@HCBMCAK@Failed?5to?5load?5externalRef?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0DA@KKFOMCKH@xmlRelaxNGParse?3?5include?5has?5no@ ; `string'
PUBLIC	??_C@_0CG@HMHDMNIG@Failed?5to?5compute?5URL?5for?5inclu@ ; `string'
PUBLIC	??_C@_0BL@NFGKAGJD@Failed?5to?5load?5include?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CE@PCFKGPKF@Failed?5to?5create?5a?5name?5?$CFs?5elem@ ; `string'
PUBLIC	??_C@_0CN@ILNMLAAE@xmlRelaxNGParse?3?5no?5namespace?5f@ ; `string'
PUBLIC	??_C@_0DB@OONPGEPE@Found?5nsName?1except?1?1nsName?5for@ ; `string'
PUBLIC	??_C@_0DD@IENCCDMP@Found?5anyName?1except?1?1anyName?5f@ ; `string'
PUBLIC	??_C@_0DC@EKOIKCCH@Found?5nsName?1except?1?1anyName?5fo@ ; `string'
PUBLIC	??_C@_0CE@JEGPHEEO@xmlRelaxNGParse?3?5could?5not?5load@ ; `string'
PUBLIC	??_C@_0CK@DLIMDDCN@xmlRelaxNGParse?3?5could?5not?5pars@ ; `string'
PUBLIC	??_C@_0BB@IEONCAEH@in_memory_buffer@		; `string'
PUBLIC	??_C@_0CD@ECFNFIDE@xmlRelaxNGParse?3?5nothing?5to?5par@ ; `string'
PUBLIC	??_C@_07DDGCDBGL@schemas@			; `string'
PUBLIC	??_C@_09JHPCAGIE@?$DMempty?1?$DO?6@		; `string'
PUBLIC	??_C@_0P@LGHJEHKL@?$DMnotAllowed?1?$DO?6@	; `string'
PUBLIC	??_C@_08OHAPHCGE@?$DMtext?1?$DO?6@		; `string'
PUBLIC	??_C@_0L@HIHOJKI@?$DMelement?$DO?6@		; `string'
PUBLIC	??_C@_05MAJIAHFB@?$DMname@			; `string'
PUBLIC	??_C@_08OGOKLGPP@?5ns?$DN?$CC?$CFs?$CC@		; `string'
PUBLIC	??_C@_0M@NKLFPNCC@?$DO?$CFs?$DM?1name?$DO?6@	; `string'
PUBLIC	??_C@_0M@DBOCEHGE@?$DM?1element?$DO?6@		; `string'
PUBLIC	??_C@_07KFGHJDGD@?$DMlist?$DO?6@		; `string'
PUBLIC	??_C@_08BMHNFNKK@?$DM?1list?$DO?6@		; `string'
PUBLIC	??_C@_0N@GKDCALFJ@?$DMoneOrMore?$DO?6@		; `string'
PUBLIC	??_C@_0O@DMBDCLJB@?$DM?1oneOrMore?$DO?6@	; `string'
PUBLIC	??_C@_0O@HBEPIBFH@?$DMzeroOrMore?$DO?6@		; `string'
PUBLIC	??_C@_0P@OEKGOKPF@?$DM?1zeroOrMore?$DO?6@	; `string'
PUBLIC	??_C@_09FMCPLLHC@?$DMchoice?$DO?6@		; `string'
PUBLIC	??_C@_0L@DKMLIBNI@?$DM?1choice?$DO?6@		; `string'
PUBLIC	??_C@_08HJPOCIL@?$DMgroup?$DO?6@		; `string'
PUBLIC	??_C@_09OFJOICFB@?$DM?1group?$DO?6@		; `string'
PUBLIC	??_C@_0O@HDBAABBA@?$DMinterleave?$DO?6@		; `string'
PUBLIC	??_C@_0P@OGPJGKLC@?$DM?1interleave?$DO?6@	; `string'
PUBLIC	??_C@_0M@IMDPOIEK@?$DMoptional?$DO?6@		; `string'
PUBLIC	??_C@_0N@BONLADHP@?$DM?1optional?$DO?6@		; `string'
PUBLIC	??_C@_0N@ONGBDJAO@?$DMattribute?$DO?6@		; `string'
PUBLIC	??_C@_0O@LLEABJMG@?$DM?1attribute?$DO?6@	; `string'
PUBLIC	??_C@_07GFOANDBH@?$DMdefine@			; `string'
PUBLIC	??_C@_0L@GBLOBBPK@?5name?$DN?$CC?$CFs?$CC@	; `string'
PUBLIC	??_C@_02NEKEAGPN@?$DO?6@			; `string'
PUBLIC	??_C@_0L@KIKHHIKC@?$DM?1define?$DO?6@		; `string'
PUBLIC	??_C@_04OBIBPAJI@?$DMref@			; `string'
PUBLIC	??_C@_07KMCFPDOJ@?$DM?1ref?$DO?6@		; `string'
PUBLIC	??_C@_0L@BOLBFIPO@?$DMparentRef@		; `string'
PUBLIC	??_C@_0O@GNLEALJM@?$DM?1parentRef?$DO?6@	; `string'
PUBLIC	??_C@_0O@ONLPMFHM@?$DMexternalRef?$DO@		; `string'
PUBLIC	??_C@_0BA@JLPMEBPH@?$DM?1externalRef?$DO?6@	; `string'
PUBLIC	??_C@_08EPHAEKIJ@?$DMgrammar@			; `string'
PUBLIC	??_C@_0CN@MGKJIEH@?5xmlns?$DN?$CChttp?3?1?1relaxng?4org?1ns?1s@ ; `string'
PUBLIC	??_C@_0BC@JCPJPOMG@?5combine?$DN?$CCchoice?$CC@	; `string'
PUBLIC	??_C@_0BG@DIIHEMFB@?5combine?$DN?$CCinterleave?$CC@ ; `string'
PUBLIC	??_C@_0CA@NOBFJPON@?5?$DM?$CB?9?9?5invalid?5combine?5value?5?9?9?$DO@ ; `string'
PUBLIC	??_C@_0BP@HDPMIPMJ@?5?$DM?$CB?9?9?5grammar?5had?5no?5start?5?9?9?$DO@ ; `string'
PUBLIC	??_C@_08JLPGMCFH@?$DMstart?$DO?6@		; `string'
PUBLIC	??_C@_09HJPHKCIN@?$DM?1start?$DO?6@		; `string'
PUBLIC	??_C@_0M@JODHEKCA@?$DM?1grammar?$DO?6@		; `string'
PUBLIC	??_C@_0CE@LIIBEOG@RelaxNG?5empty?5or?5failed?5to?5comp@ ; `string'
PUBLIC	??_C@_09KHOMLKFG@RelaxNG?3?5@			; `string'
PUBLIC	??_C@_0N@PEHAONBJ@no?5document?6@		; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0BM@HEJEDHAB@RelaxNG?5has?5no?5top?5grammar?6@ ; `string'
PUBLIC	??_C@_0CA@KBMDPFMM@callback?5on?5?$CFs?5missing?5context?6@ ; `string'
PUBLIC	??_C@_0BP@FKGGDPOM@callback?5on?5?$CFs?5missing?5define?6@ ; `string'
PUBLIC	??_C@_0CG@GECBHEAN@callback?5on?5?$CFs?5define?5is?5not?5el@ ; `string'
PUBLIC	??_C@_0M@PEGDIBJJ@validating?6@			; `string'
PUBLIC	??_C@_06BKKGLNFB@?5TODO?5@			; `string'
PUBLIC	??_C@_06LNKFDEGN@noname@			; `string'
PUBLIC	??_C@_0BF@BELJIEJG@NULL?5definition?5list@	; `string'
PUBLIC	??_C@_0BC@JDIHBOGI@building?5context?6@		; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlCharStrdup:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlStrcat:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_xmlEscapeFormatString:PROC
EXTRN	_xmlRegFreeRegexp:PROC
EXTRN	_xmlRegexpIsDeterminist:PROC
EXTRN	_xmlRegNewExecCtxt:PROC
EXTRN	_xmlRegFreeExecCtxt:PROC
EXTRN	_xmlRegExecPushString:PROC
EXTRN	_xmlRegExecPushString2:PROC
EXTRN	_xmlValidateNCName:PROC
EXTRN	_xmlSplitQName2:PROC
EXTRN	_xmlFreeDoc:PROC
EXTRN	_xmlCopyDoc:PROC
EXTRN	_xmlNewDocNode:PROC
EXTRN	_xmlNewChild:PROC
EXTRN	_xmlNewText:PROC
EXTRN	_xmlDocGetRootElement:PROC
EXTRN	_xmlIsBlankNode:PROC
EXTRN	_xmlAddChild:PROC
EXTRN	_xmlAddPrevSibling:PROC
EXTRN	_xmlAddNextSibling:PROC
EXTRN	_xmlUnlinkNode:PROC
EXTRN	_xmlFreeNode:PROC
EXTRN	_xmlSearchNs:PROC
EXTRN	_xmlSetProp:PROC
EXTRN	_xmlGetProp:PROC
EXTRN	_xmlHasProp:PROC
EXTRN	_xmlNodeListGetString:PROC
EXTRN	_xmlNodeSetContent:PROC
EXTRN	_xmlNodeGetContent:PROC
EXTRN	_xmlNodeGetBase:PROC
EXTRN	_xmlUnsetProp:PROC
EXTRN	_xmlDocDump:PROC
EXTRN	_xmlHashCreate:PROC
EXTRN	_xmlHashFree:PROC
EXTRN	_xmlHashAddEntry:PROC
EXTRN	_xmlHashAddEntry2:PROC
EXTRN	_xmlHashLookup:PROC
EXTRN	_xmlHashLookup2:PROC
EXTRN	_xmlHashScan:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	_xmlNewAutomata:PROC
EXTRN	_xmlFreeAutomata:PROC
EXTRN	_xmlAutomataGetInitState:PROC
EXTRN	_xmlAutomataSetFinalState:PROC
EXTRN	_xmlAutomataNewTransition:PROC
EXTRN	_xmlAutomataNewTransition2:PROC
EXTRN	_xmlAutomataNewEpsilon:PROC
EXTRN	_xmlAutomataCompile:PROC
EXTRN	_xmlAutomataIsDeterminist:PROC
EXTRN	_xmlValidateDocumentFinal:PROC
EXTRN	_xmlReadFile:PROC
EXTRN	_xmlReadMemory:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	_xmlBuildURI:PROC
EXTRN	_xmlParseURI:PROC
EXTRN	_xmlURIEscapeStr:PROC
EXTRN	_xmlFreeURI:PROC
EXTRN	_xmlSchemaCleanupTypes:PROC
EXTRN	_xmlSchemaGetPredefinedType:PROC
EXTRN	_xmlSchemaValPredefTypeNode:PROC
EXTRN	_xmlSchemaValidateFacet:PROC
EXTRN	_xmlSchemaFreeValue:PROC
EXTRN	_xmlSchemaNewFacet:PROC
EXTRN	_xmlSchemaCheckFacet:PROC
EXTRN	_xmlSchemaFreeFacet:PROC
EXTRN	_xmlSchemaCompareValues:PROC
EXTRN	_xmlAutomataSetFlags:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_xmlRelaxNGTypeInitialized DD 01H DUP (?)
_xmlRelaxNGRegisteredTypes DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BC@JDIHBOGI@building?5context?6@
CONST	SEGMENT
??_C@_0BC@JDIHBOGI@building?5context?6@ DB 'building context', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BELJIEJG@NULL?5definition?5list@
CONST	SEGMENT
??_C@_0BF@BELJIEJG@NULL?5definition?5list@ DB 'NULL definition list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LNKFDEGN@noname@
CONST	SEGMENT
??_C@_06LNKFDEGN@noname@ DB 'noname', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BKKGLNFB@?5TODO?5@
CONST	SEGMENT
??_C@_06BKKGLNFB@?5TODO?5@ DB ' TODO ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PEGDIBJJ@validating?6@
CONST	SEGMENT
??_C@_0M@PEGDIBJJ@validating?6@ DB 'validating', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GECBHEAN@callback?5on?5?$CFs?5define?5is?5not?5el@
CONST	SEGMENT
??_C@_0CG@GECBHEAN@callback?5on?5?$CFs?5define?5is?5not?5el@ DB 'callback'
	DB	' on %s define is not element', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FKGGDPOM@callback?5on?5?$CFs?5missing?5define?6@
CONST	SEGMENT
??_C@_0BP@FKGGDPOM@callback?5on?5?$CFs?5missing?5define?6@ DB 'callback o'
	DB	'n %s missing define', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KBMDPFMM@callback?5on?5?$CFs?5missing?5context?6@
CONST	SEGMENT
??_C@_0CA@KBMDPFMM@callback?5on?5?$CFs?5missing?5context?6@ DB 'callback '
	DB	'on %s missing context', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HEJEDHAB@RelaxNG?5has?5no?5top?5grammar?6@
CONST	SEGMENT
??_C@_0BM@HEJEDHAB@RelaxNG?5has?5no?5top?5grammar?6@ DB 'RelaxNG has no t'
	DB	'op grammar', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PEHAONBJ@no?5document?6@
CONST	SEGMENT
??_C@_0N@PEHAONBJ@no?5document?6@ DB 'no document', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KHOMLKFG@RelaxNG?3?5@
CONST	SEGMENT
??_C@_09KHOMLKFG@RelaxNG?3?5@ DB 'RelaxNG: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LIIBEOG@RelaxNG?5empty?5or?5failed?5to?5comp@
CONST	SEGMENT
??_C@_0CE@LIIBEOG@RelaxNG?5empty?5or?5failed?5to?5comp@ DB 'RelaxNG empty'
	DB	' or failed to compile', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JODHEKCA@?$DM?1grammar?$DO?6@
CONST	SEGMENT
??_C@_0M@JODHEKCA@?$DM?1grammar?$DO?6@ DB '</grammar>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HJPHKCIN@?$DM?1start?$DO?6@
CONST	SEGMENT
??_C@_09HJPHKCIN@?$DM?1start?$DO?6@ DB '</start>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JLPGMCFH@?$DMstart?$DO?6@
CONST	SEGMENT
??_C@_08JLPGMCFH@?$DMstart?$DO?6@ DB '<start>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HDPMIPMJ@?5?$DM?$CB?9?9?5grammar?5had?5no?5start?5?9?9?$DO@
CONST	SEGMENT
??_C@_0BP@HDPMIPMJ@?5?$DM?$CB?9?9?5grammar?5had?5no?5start?5?9?9?$DO@ DB ' '
	DB	'<!-- grammar had no start -->', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NOBFJPON@?5?$DM?$CB?9?9?5invalid?5combine?5value?5?9?9?$DO@
CONST	SEGMENT
??_C@_0CA@NOBFJPON@?5?$DM?$CB?9?9?5invalid?5combine?5value?5?9?9?$DO@ DB ' '
	DB	'<!-- invalid combine value -->', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DIIHEMFB@?5combine?$DN?$CCinterleave?$CC@
CONST	SEGMENT
??_C@_0BG@DIIHEMFB@?5combine?$DN?$CCinterleave?$CC@ DB ' combine="interle'
	DB	'ave"', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JCPJPOMG@?5combine?$DN?$CCchoice?$CC@
CONST	SEGMENT
??_C@_0BC@JCPJPOMG@?5combine?$DN?$CCchoice?$CC@ DB ' combine="choice"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@MGKJIEH@?5xmlns?$DN?$CChttp?3?1?1relaxng?4org?1ns?1s@
CONST	SEGMENT
??_C@_0CN@MGKJIEH@?5xmlns?$DN?$CChttp?3?1?1relaxng?4org?1ns?1s@ DB ' xmln'
	DB	's="http://relaxng.org/ns/structure/1.0"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPHAEKIJ@?$DMgrammar@
CONST	SEGMENT
??_C@_08EPHAEKIJ@?$DMgrammar@ DB '<grammar', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JLPMEBPH@?$DM?1externalRef?$DO?6@
CONST	SEGMENT
??_C@_0BA@JLPMEBPH@?$DM?1externalRef?$DO?6@ DB '</externalRef>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ONLPMFHM@?$DMexternalRef?$DO@
CONST	SEGMENT
??_C@_0O@ONLPMFHM@?$DMexternalRef?$DO@ DB '<externalRef>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GNLEALJM@?$DM?1parentRef?$DO?6@
CONST	SEGMENT
??_C@_0O@GNLEALJM@?$DM?1parentRef?$DO?6@ DB '</parentRef>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BOLBFIPO@?$DMparentRef@
CONST	SEGMENT
??_C@_0L@BOLBFIPO@?$DMparentRef@ DB '<parentRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KMCFPDOJ@?$DM?1ref?$DO?6@
CONST	SEGMENT
??_C@_07KMCFPDOJ@?$DM?1ref?$DO?6@ DB '</ref>', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04OBIBPAJI@?$DMref@
CONST	SEGMENT
??_C@_04OBIBPAJI@?$DMref@ DB '<ref', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KIKHHIKC@?$DM?1define?$DO?6@
CONST	SEGMENT
??_C@_0L@KIKHHIKC@?$DM?1define?$DO?6@ DB '</define>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02NEKEAGPN@?$DO?6@
CONST	SEGMENT
??_C@_02NEKEAGPN@?$DO?6@ DB '>', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GBLOBBPK@?5name?$DN?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_0L@GBLOBBPK@?5name?$DN?$CC?$CFs?$CC@ DB ' name="%s"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GFOANDBH@?$DMdefine@
CONST	SEGMENT
??_C@_07GFOANDBH@?$DMdefine@ DB '<define', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LLEABJMG@?$DM?1attribute?$DO?6@
CONST	SEGMENT
??_C@_0O@LLEABJMG@?$DM?1attribute?$DO?6@ DB '</attribute>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ONGBDJAO@?$DMattribute?$DO?6@
CONST	SEGMENT
??_C@_0N@ONGBDJAO@?$DMattribute?$DO?6@ DB '<attribute>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BONLADHP@?$DM?1optional?$DO?6@
CONST	SEGMENT
??_C@_0N@BONLADHP@?$DM?1optional?$DO?6@ DB '</optional>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IMDPOIEK@?$DMoptional?$DO?6@
CONST	SEGMENT
??_C@_0M@IMDPOIEK@?$DMoptional?$DO?6@ DB '<optional>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OGPJGKLC@?$DM?1interleave?$DO?6@
CONST	SEGMENT
??_C@_0P@OGPJGKLC@?$DM?1interleave?$DO?6@ DB '</interleave>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HDBAABBA@?$DMinterleave?$DO?6@
CONST	SEGMENT
??_C@_0O@HDBAABBA@?$DMinterleave?$DO?6@ DB '<interleave>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OFJOICFB@?$DM?1group?$DO?6@
CONST	SEGMENT
??_C@_09OFJOICFB@?$DM?1group?$DO?6@ DB '</group>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HJPOCIL@?$DMgroup?$DO?6@
CONST	SEGMENT
??_C@_08HJPOCIL@?$DMgroup?$DO?6@ DB '<group>', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DKMLIBNI@?$DM?1choice?$DO?6@
CONST	SEGMENT
??_C@_0L@DKMLIBNI@?$DM?1choice?$DO?6@ DB '</choice>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FMCPLLHC@?$DMchoice?$DO?6@
CONST	SEGMENT
??_C@_09FMCPLLHC@?$DMchoice?$DO?6@ DB '<choice>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OEKGOKPF@?$DM?1zeroOrMore?$DO?6@
CONST	SEGMENT
??_C@_0P@OEKGOKPF@?$DM?1zeroOrMore?$DO?6@ DB '</zeroOrMore>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HBEPIBFH@?$DMzeroOrMore?$DO?6@
CONST	SEGMENT
??_C@_0O@HBEPIBFH@?$DMzeroOrMore?$DO?6@ DB '<zeroOrMore>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DMBDCLJB@?$DM?1oneOrMore?$DO?6@
CONST	SEGMENT
??_C@_0O@DMBDCLJB@?$DM?1oneOrMore?$DO?6@ DB '</oneOrMore>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GKDCALFJ@?$DMoneOrMore?$DO?6@
CONST	SEGMENT
??_C@_0N@GKDCALFJ@?$DMoneOrMore?$DO?6@ DB '<oneOrMore>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BMHNFNKK@?$DM?1list?$DO?6@
CONST	SEGMENT
??_C@_08BMHNFNKK@?$DM?1list?$DO?6@ DB '</list>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KFGHJDGD@?$DMlist?$DO?6@
CONST	SEGMENT
??_C@_07KFGHJDGD@?$DMlist?$DO?6@ DB '<list>', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DBOCEHGE@?$DM?1element?$DO?6@
CONST	SEGMENT
??_C@_0M@DBOCEHGE@?$DM?1element?$DO?6@ DB '</element>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NKLFPNCC@?$DO?$CFs?$DM?1name?$DO?6@
CONST	SEGMENT
??_C@_0M@NKLFPNCC@?$DO?$CFs?$DM?1name?$DO?6@ DB '>%s</name>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OGOKLGPP@?5ns?$DN?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_08OGOKLGPP@?5ns?$DN?$CC?$CFs?$CC@ DB ' ns="%s"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MAJIAHFB@?$DMname@
CONST	SEGMENT
??_C@_05MAJIAHFB@?$DMname@ DB '<name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HIHOJKI@?$DMelement?$DO?6@
CONST	SEGMENT
??_C@_0L@HIHOJKI@?$DMelement?$DO?6@ DB '<element>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OHAPHCGE@?$DMtext?1?$DO?6@
CONST	SEGMENT
??_C@_08OHAPHCGE@?$DMtext?1?$DO?6@ DB '<text/>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LGHJEHKL@?$DMnotAllowed?1?$DO?6@
CONST	SEGMENT
??_C@_0P@LGHJEHKL@?$DMnotAllowed?1?$DO?6@ DB '<notAllowed/>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JHPCAGIE@?$DMempty?1?$DO?6@
CONST	SEGMENT
??_C@_09JHPCAGIE@?$DMempty?1?$DO?6@ DB '<empty/>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DDGCDBGL@schemas@
CONST	SEGMENT
??_C@_07DDGCDBGL@schemas@ DB 'schemas', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@ECFNFIDE@xmlRelaxNGParse?3?5nothing?5to?5par@
CONST	SEGMENT
??_C@_0CD@ECFNFIDE@xmlRelaxNGParse?3?5nothing?5to?5par@ DB 'xmlRelaxNGPar'
	DB	'se: nothing to parse', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IEONCAEH@in_memory_buffer@
CONST	SEGMENT
??_C@_0BB@IEONCAEH@in_memory_buffer@ DB 'in_memory_buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DLIMDDCN@xmlRelaxNGParse?3?5could?5not?5pars@
CONST	SEGMENT
??_C@_0CK@DLIMDDCN@xmlRelaxNGParse?3?5could?5not?5pars@ DB 'xmlRelaxNGPar'
	DB	'se: could not parse schemas', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JEGPHEEO@xmlRelaxNGParse?3?5could?5not?5load@
CONST	SEGMENT
??_C@_0CE@JEGPHEEO@xmlRelaxNGParse?3?5could?5not?5load@ DB 'xmlRelaxNGPar'
	DB	'se: could not load %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@EKOIKCCH@Found?5nsName?1except?1?1anyName?5fo@
CONST	SEGMENT
??_C@_0DC@EKOIKCCH@Found?5nsName?1except?1?1anyName?5fo@ DB 'Found nsName'
	DB	'/except//anyName forbidden construct', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@IENCCDMP@Found?5anyName?1except?1?1anyName?5f@
CONST	SEGMENT
??_C@_0DD@IENCCDMP@Found?5anyName?1except?1?1anyName?5f@ DB 'Found anyNam'
	DB	'e/except//anyName forbidden construct', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@OONPGEPE@Found?5nsName?1except?1?1nsName?5for@
CONST	SEGMENT
??_C@_0DB@OONPGEPE@Found?5nsName?1except?1?1nsName?5for@ DB 'Found nsName'
	DB	'/except//nsName forbidden construct', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@ILNMLAAE@xmlRelaxNGParse?3?5no?5namespace?5f@
CONST	SEGMENT
??_C@_0CN@ILNMLAAE@xmlRelaxNGParse?3?5no?5namespace?5f@ DB 'xmlRelaxNGPar'
	DB	'se: no namespace for prefix %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PCFKGPKF@Failed?5to?5create?5a?5name?5?$CFs?5elem@
CONST	SEGMENT
??_C@_0CE@PCFKGPKF@Failed?5to?5create?5a?5name?5?$CFs?5elem@ DB 'Failed t'
	DB	'o create a name %s element', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NFGKAGJD@Failed?5to?5load?5include?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@NFGKAGJD@Failed?5to?5load?5include?5?$CFs?6@ DB 'Failed to load'
	DB	' include %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HMHDMNIG@Failed?5to?5compute?5URL?5for?5inclu@
CONST	SEGMENT
??_C@_0CG@HMHDMNIG@Failed?5to?5compute?5URL?5for?5inclu@ DB 'Failed to co'
	DB	'mpute URL for include %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KKFOMCKH@xmlRelaxNGParse?3?5include?5has?5no@
CONST	SEGMENT
??_C@_0DA@KKFOMCKH@xmlRelaxNGParse?3?5include?5has?5no@ DB 'xmlRelaxNGPar'
	DB	'se: include has no href attribute', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HCBMCAK@Failed?5to?5load?5externalRef?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@HCBMCAK@Failed?5to?5load?5externalRef?5?$CFs?6@ DB 'Failed to l'
	DB	'oad externalRef %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MJBGKOFC@Failed?5to?5compute?5URL?5for?5exter@
CONST	SEGMENT
??_C@_0CK@MJBGKOFC@Failed?5to?5compute?5URL?5for?5exter@ DB 'Failed to co'
	DB	'mpute URL for externalRef %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GJLFMGAP@Fragment?5forbidden?5in?5URI?5for?5e@
CONST	SEGMENT
??_C@_0CO@GJLFMGAP@Fragment?5forbidden?5in?5URI?5for?5e@ DB 'Fragment for'
	DB	'bidden in URI for externalRef %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NOODBOMC@Incorrect?5URI?5for?5externalRef?5?$CF@
CONST	SEGMENT
??_C@_0CC@NOODBOMC@Incorrect?5URI?5for?5externalRef?5?$CF@ DB 'Incorrect '
	DB	'URI for externalRef %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@IKNPMFHP@xmlRelaxNGParse?3?5externalRef?5ha@
CONST	SEGMENT
??_C@_0DE@IKNPMFHP@xmlRelaxNGParse?3?5externalRef?5ha@ DB 'xmlRelaxNGPars'
	DB	'e: externalRef has no href attribute', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IEADNMBI@element?5?$CFs?5doesn?8t?5allow?5foreig@
CONST	SEGMENT
??_C@_0CL@IEADNMBI@element?5?$CFs?5doesn?8t?5allow?5foreig@ DB 'element %'
	DB	's doesn''t allow foreign elements', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DCBEKLDL@Unknown?5attribute?5?$CFs?5on?5?$CFs?6@
CONST	SEGMENT
??_C@_0BM@DCBEKLDL@Unknown?5attribute?5?$CFs?5on?5?$CFs?6@ DB 'Unknown at'
	DB	'tribute %s on %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HOEFBPIP@Attribute?5?$CFs?5URI?5?$CFs?5has?5a?5fragm@
CONST	SEGMENT
??_C@_0CH@HOEFBPIP@Attribute?5?$CFs?5URI?5?$CFs?5has?5a?5fragm@ DB 'Attri'
	DB	'bute %s URI %s has a fragment ID', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MJPHBHBO@Attribute?5?$CFs?5URI?5?$CFs?5is?5not?5abso@
CONST	SEGMENT
??_C@_0CF@MJPHBHBO@Attribute?5?$CFs?5URI?5?$CFs?5is?5not?5abso@ DB 'Attri'
	DB	'bute %s URI %s is not absolute', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BHOFIFCK@Attribute?5?$CFs?5contains?5invalid?5U@
CONST	SEGMENT
??_C@_0CG@BHOFIFCK@Attribute?5?$CFs?5contains?5invalid?5U@ DB 'Attribute '
	DB	'%s contains invalid URI %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CMBCJJJD@href@
CONST	SEGMENT
??_C@_04CMBCJJJD@href@ DB 'href', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DKPPJJNH@Attribute?5?$CFs?5is?5not?5allowed?5on?5@
CONST	SEGMENT
??_C@_0CD@DKPPJJNH@Attribute?5?$CFs?5is?5not?5allowed?5on?5@ DB 'Attribut'
	DB	'e %s is not allowed on %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LGCAJOFI@building?5parser?6@
CONST	SEGMENT
??_C@_0BB@LGCAJOFI@building?5parser?6@ DB 'building parser', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BLDDIJOB@Element?5?$DMgrammar?$DO?5has?5no?5?$DMstart@
CONST	SEGMENT
??_C@_0CC@BLDDIJOB@Element?5?$DMgrammar?$DO?5has?5no?5?$DMstart@ DB 'Elem'
	DB	'ent <grammar> has no <start>', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OJHMILLC@Found?5forbidden?5pattern?5start?1?1@
CONST	SEGMENT
??_C@_0CG@OJHMILLC@Found?5forbidden?5pattern?5start?1?1@ DB 'Found forbid'
	DB	'den pattern start//empty', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OBFOJGD@Found?5forbidden?5pattern?5data?1ex@
CONST	SEGMENT
??_C@_0CM@OBFOJGD@Found?5forbidden?5pattern?5data?1ex@ DB 'Found forbidde'
	DB	'n pattern data/except//empty', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MGKHPGDN@Found?5forbidden?5pattern?5start?1?1@
CONST	SEGMENT
??_C@_0CF@MGKHPGDN@Found?5forbidden?5pattern?5start?1?1@ DB 'Found forbid'
	DB	'den pattern start//text', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BHOICADD@Found?5forbidden?5pattern?5data?1ex@
CONST	SEGMENT
??_C@_0CL@BHOICADD@Found?5forbidden?5pattern?5data?1ex@ DB 'Found forbidd'
	DB	'en pattern data/except//text', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CJAFDOPC@Found?5forbidden?5pattern?5list?1?1t@
CONST	SEGMENT
??_C@_0CE@CJAFDOPC@Found?5forbidden?5pattern?5list?1?1t@ DB 'Found forbid'
	DB	'den pattern list//text', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MABIIKGI@Found?5forbidden?5pattern?5start?1?1@
CONST	SEGMENT
??_C@_0CG@MABIIKGI@Found?5forbidden?5pattern?5start?1?1@ DB 'Found forbid'
	DB	'den pattern start//value', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GAMKIMEF@Found?5forbidden?5pattern?5start?1?1@
CONST	SEGMENT
??_C@_0CF@GAMKIMEF@Found?5forbidden?5pattern?5start?1?1@ DB 'Found forbid'
	DB	'den pattern start//data', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BPHANFIL@Found?5forbidden?5pattern?5start?1?1@
CONST	SEGMENT
??_C@_0CL@BPHANFIL@Found?5forbidden?5pattern?5start?1?1@ DB 'Found forbid'
	DB	'den pattern start//interleave', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GMPDCJGO@Found?5forbidden?5pattern?5data?1ex@
CONST	SEGMENT
??_C@_0DB@GMPDCJGO@Found?5forbidden?5pattern?5data?1ex@ DB 'Found forbidd'
	DB	'en pattern data/except//interleave', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GDHHJMOD@Found?5forbidden?5pattern?5list?1?1i@
CONST	SEGMENT
??_C@_0CK@GDHHJMOD@Found?5forbidden?5pattern?5list?1?1i@ DB 'Found forbid'
	DB	'den pattern list//interleave', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NJLOHGGM@Found?5forbidden?5pattern?5start?1?1@
CONST	SEGMENT
??_C@_0CG@NJLOHGGM@Found?5forbidden?5pattern?5start?1?1@ DB 'Found forbid'
	DB	'den pattern start//group', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DONHBELN@Found?5forbidden?5pattern?5data?1ex@
CONST	SEGMENT
??_C@_0CM@DONHBELN@Found?5forbidden?5pattern?5data?1ex@ DB 'Found forbidd'
	DB	'en pattern data/except//group', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DLNDBMML@Found?5forbidden?5pattern?5start?1?1@
CONST	SEGMENT
??_C@_0CF@DLNDBMML@Found?5forbidden?5pattern?5start?1?1@ DB 'Found forbid'
	DB	'den pattern start//list', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@OKJMMKMF@Found?5forbidden?5pattern?5data?1ex@
CONST	SEGMENT
??_C@_0CL@OKJMMKMF@Found?5forbidden?5pattern?5data?1ex@ DB 'Found forbidd'
	DB	'en pattern data/except//list', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NEHBNEAE@Found?5forbidden?5pattern?5list?1?1l@
CONST	SEGMENT
??_C@_0CE@NEHBNEAE@Found?5forbidden?5pattern?5list?1?1l@ DB 'Found forbid'
	DB	'den pattern list//list', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@EJNCLCCA@Found?5forbidden?5pattern?5start?1?1@
CONST	SEGMENT
??_C@_0CK@EJNCLCCA@Found?5forbidden?5pattern?5start?1?1@ DB 'Found forbid'
	DB	'den pattern start//oneOrMore', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BGDINEKH@Found?5forbidden?5pattern?5data?1ex@
CONST	SEGMENT
??_C@_0DA@BGDINEKH@Found?5forbidden?5pattern?5data?1ex@ DB 'Found forbidd'
	DB	'en pattern data/except//oneOrMore', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@LLONPEJF@Found?5nsName?5attribute?5without?5@
CONST	SEGMENT
??_C@_0DD@LLONPEJF@Found?5nsName?5attribute?5without?5@ DB 'Found nsName '
	DB	'attribute without oneOrMore ancestor', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@BFPCKEFO@Found?5anyName?5attribute?5without@
CONST	SEGMENT
??_C@_0DE@BFPCKEFO@Found?5anyName?5attribute?5without@ DB 'Found anyName '
	DB	'attribute without oneOrMore ancestor', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@BCEDDHLB@Found?5forbidden?5pattern?5start?1?1@
CONST	SEGMENT
??_C@_0CK@BCEDDHLB@Found?5forbidden?5pattern?5start?1?1@ DB 'Found forbid'
	DB	'den pattern start//attribute', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@ENKJFBDG@Found?5forbidden?5pattern?5data?1ex@
CONST	SEGMENT
??_C@_0DA@ENKJFBDG@Found?5forbidden?5pattern?5data?1ex@ DB 'Found forbidd'
	DB	'en pattern data/except//attribute', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@NGAGBKIF@Found?5forbidden?5pattern?5oneOrMo@
CONST	SEGMENT
??_C@_0DK@NGAGBKIF@Found?5forbidden?5pattern?5oneOrMo@ DB 'Found forbidde'
	DB	'n pattern oneOrMore//interleave//attribute', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EKCKBFFE@Found?5forbidden?5pattern?5oneOrMo@
CONST	SEGMENT
??_C@_0DF@EKCKBFFE@Found?5forbidden?5pattern?5oneOrMo@ DB 'Found forbidde'
	DB	'n pattern oneOrMore//group//attribute', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MJOFOIHP@Found?5forbidden?5pattern?5list?1?1a@
CONST	SEGMENT
??_C@_0CJ@MJOFOIHP@Found?5forbidden?5pattern?5list?1?1a@ DB 'Found forbid'
	DB	'den pattern list//attribute', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@INMFBEHE@Found?5forbidden?5pattern?5attribu@
CONST	SEGMENT
??_C@_0CO@INMFBEHE@Found?5forbidden?5pattern?5attribu@ DB 'Found forbidde'
	DB	'n pattern attribute//attribute', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGIEHIGM@Element?5?$CFs?5has?5a?5content?5type?5e@
CONST	SEGMENT
??_C@_0CF@DGIEHIGM@Element?5?$CFs?5has?5a?5content?5type?5e@ DB 'Element '
	DB	'%s has a content type error', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@COIJMLBL@Element?5?$CFs?5attributes?5have?5a?5co@
CONST	SEGMENT
??_C@_0DB@COIJMLBL@Element?5?$CFs?5attributes?5have?5a?5co@ DB 'Element %'
	DB	's attributes have a content type error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MJBLDFBL@Found?5forbidden?5pattern?5attribu@
CONST	SEGMENT
??_C@_0DB@MJBLDFBL@Found?5forbidden?5pattern?5attribu@ DB 'Found forbidde'
	DB	'n pattern attribute//element(ref)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@EGCJFEMH@Found?5forbidden?5pattern?5list?1?1e@
CONST	SEGMENT
??_C@_0CM@EGCJFEMH@Found?5forbidden?5pattern?5list?1?1e@ DB 'Found forbid'
	DB	'den pattern list//element(ref)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@HDAPPKEG@Found?5forbidden?5pattern?5data?1ex@
CONST	SEGMENT
??_C@_0DD@HDAPPKEG@Found?5forbidden?5pattern?5data?1ex@ DB 'Found forbidd'
	DB	'en pattern data/except//element(ref)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GFDJFDLL@Internal?5found?5no?5define?5for?5re@
CONST	SEGMENT
??_C@_0CF@GFDJFDLL@Internal?5found?5no?5define?5for?5re@ DB 'Internal fou'
	DB	'nd no define for ref %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLLLIHIP@null@
CONST	SEGMENT
??_C@_04MLLLIHIP@null@ DB 'null', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@BAJLBNJH@Internal?5found?5no?5define?5for?5pa@
CONST	SEGMENT
??_C@_0CK@BAJLBNJH@Internal?5found?5no?5define?5for?5pa@ DB 'Internal fou'
	DB	'nd no define for parent refs', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JHAPLGCC@Found?5forbidden?5pattern?5data?1ex@
CONST	SEGMENT
??_C@_0CK@JHAPLGCC@Found?5forbidden?5pattern?5data?1ex@ DB 'Found forbidd'
	DB	'en pattern data/except//ref', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GDGLIOPD@Detected?5a?5cycle?5in?5?$CFs?5referenc@
CONST	SEGMENT
??_C@_0CD@GDGLIOPD@Detected?5a?5cycle?5in?5?$CFs?5referenc@ DB 'Detected '
	DB	'a cycle in %s references', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@FEIAJIL@Some?5?$DMstart?$DO?5element?5miss?5the?5c@
CONST	SEGMENT
??_C@_0DB@FEIAJIL@Some?5?$DMstart?$DO?5element?5miss?5the?5c@ DB 'Some <s'
	DB	'tart> element miss the combine attribute', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DGGLNMFN@?$DMstart?$DO?5uses?5unknown?5combine?5va@
CONST	SEGMENT
??_C@_0CK@DGGLNMFN@?$DMstart?$DO?5uses?5unknown?5combine?5va@ DB '<start>'
	DB	' uses unknown combine value ''%s''''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@KNKPDGOJ@?$DMstart?$DO?5use?5both?5?8choice?8?5and?5?8@
CONST	SEGMENT
??_C@_0CM@KNKPDGOJ@?$DMstart?$DO?5use?5both?5?8choice?8?5and?5?8@ DB '<st'
	DB	'art> use both ''choice'' and ''interleave''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EGDAKNFC@Internal?5error?3?5start?5element?5n@
CONST	SEGMENT
??_C@_0CJ@EGDAKNFC@Internal?5error?3?5start?5element?5n@ DB 'Internal err'
	DB	'or: start element not found', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MHLGCECD@Failed?5to?5create?5interleaves?5ha@
CONST	SEGMENT
??_C@_0CJ@MHLGCECD@Failed?5to?5create?5interleaves?5ha@ DB 'Failed to cre'
	DB	'ate interleaves hash table', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MHLFAPLB@Some?5defines?5for?5?$CFs?5needs?5the?5c@
CONST	SEGMENT
??_C@_0DB@MHLFAPLB@Some?5defines?5for?5?$CFs?5needs?5the?5c@ DB 'Some def'
	DB	'ines for %s needs the combine attribute', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BFEPFJDA@Defines?5for?5?$CFs?5use?5unknown?5comb@
CONST	SEGMENT
??_C@_0DA@BFEPFJDA@Defines?5for?5?$CFs?5use?5unknown?5comb@ DB 'Defines f'
	DB	'or %s use unknown combine value ''%s''''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@LACLCNBH@Defines?5for?5?$CFs?5use?5both?5?8choice@
CONST	SEGMENT
??_C@_0DD@LACLCNBH@Defines?5for?5?$CFs?5use?5both?5?8choice@ DB 'Defines '
	DB	'for %s use both ''choice'' and ''interleave''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PCDCECCK@combine@
CONST	SEGMENT
??_C@_07PCDCECCK@combine@ DB 'combine', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@POOAHNP@Reference?5?$CFs?5has?5no?5matching?5de@
CONST	SEGMENT
??_C@_0CJ@POOAHNP@Reference?5?$CFs?5has?5no?5matching?5de@ DB 'Reference '
	DB	'%s has no matching definition', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@EAGPADBI@Internal?5error?3?5reference?5has?5c@
CONST	SEGMENT
??_C@_0DM@EAGPADBI@Internal?5error?3?5reference?5has?5c@ DB 'Internal err'
	DB	'or: reference has content in CheckReference %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@CFGFLOFC@Internal?5error?3?5no?5grammar?5in?5C@
CONST	SEGMENT
??_C@_0DB@CFGFLOFC@Internal?5error?3?5no?5grammar?5in?5C@ DB 'Internal er'
	DB	'ror: no grammar in CheckReference %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DOHNNNEN@grammar?5has?5unexpected?5child?5?$CFs@
CONST	SEGMENT
??_C@_0CB@DOHNNNEN@grammar?5has?5unexpected?5child?5?$CFs@ DB 'grammar ha'
	DB	's unexpected child %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FLPPFCBJ@grammar?5has?5no?5children?6@
CONST	SEGMENT
??_C@_0BJ@FLPPFCBJ@grammar?5has?5no?5children?6@ DB 'grammar has no child'
	DB	'ren', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LLNPKKPG@start?5more?5than?5one?5children?6@
CONST	SEGMENT
??_C@_0BO@LLNPKKPG@start?5more?5than?5one?5children?6@ DB 'start more tha'
	DB	'n one children', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CILNEPNL@element?5notAllowed?5is?5not?5empty@
CONST	SEGMENT
??_C@_0CB@CILNEPNL@element?5notAllowed?5is?5not?5empty@ DB 'element notAl'
	DB	'lowed is not empty', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NFEKGCB@element?5empty?5is?5not?5empty?6@
CONST	SEGMENT
??_C@_0BM@NFEKGCB@element?5empty?5is?5not?5empty?6@ DB 'element empty is '
	DB	'not empty', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HFFJFLLH@start?5has?5no?5children?6@
CONST	SEGMENT
??_C@_0BH@HFFJFLLH@start?5has?5no?5children?6@ DB 'start has no children', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MLMNOJNJ@RNG?5Internal?5error?0?5noop?5found?5@
CONST	SEGMENT
??_C@_0CL@MLMNOJNJ@RNG?5Internal?5error?0?5noop?5found?5@ DB 'RNG Interna'
	DB	'l error, noop found in element', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HLONCHKK@RNG?5Internal?5error?0?5except?5foun@
CONST	SEGMENT
??_C@_0CN@HLONCHKK@RNG?5Internal?5error?0?5except?5foun@ DB 'RNG Internal'
	DB	' error, except found in element', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LPIDEEPC@RNG?5Internal?5error?0?5param?5found@
CONST	SEGMENT
??_C@_0CM@LPIDEEPC@RNG?5Internal?5error?0?5param?5found@ DB 'RNG Internal'
	DB	' error, param found in element', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MFMPBBAO@RNG?5Internal?5error?0?5start?5found@
CONST	SEGMENT
??_C@_0CM@MFMPBBAO@RNG?5Internal?5error?0?5start?5found@ DB 'RNG Internal'
	DB	' error, start found in element', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@IDPILCIF@xmlRelaxNGParseElement?3?5element@
CONST	SEGMENT
??_C@_0DA@IDPILCIF@xmlRelaxNGParseElement?3?5element@ DB 'xmlRelaxNGParse'
	DB	'Element: element has no content', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JEBMCLMO@xmlRelaxNGParseElement?3?5element@
CONST	SEGMENT
??_C@_0DB@JEBMCLMO@xmlRelaxNGParseElement?3?5element@ DB 'xmlRelaxNGParse'
	DB	'Element: element has no children', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@HGEBBBBP@expecting?5name?0?5anyName?0?5nsName@
CONST	SEGMENT
??_C@_0DE@HGEBBBBP@expecting?5name?0?5anyName?0?5nsName@ DB 'expecting na'
	DB	'me, anyName, nsName or choice : got %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DFGIHOIL@nothing@
CONST	SEGMENT
??_C@_07DFGIHOIL@nothing@ DB 'nothing', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LPGNADIK@Element?5choice?5is?5empty?6@
CONST	SEGMENT
??_C@_0BJ@LPGNADIK@Element?5choice?5is?5empty?6@ DB 'Element choice is em'
	DB	'pty', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OBCEAFCO@nsName?5has?5no?5ns?5attribute?6@
CONST	SEGMENT
??_C@_0BM@OBCEAFCO@nsName?5has?5no?5ns?5attribute?6@ DB 'nsName has no ns'
	DB	' attribute', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HLKDALFC@Attribute?5with?5QName?5?8xmlns?8?5is@
CONST	SEGMENT
??_C@_0CN@HLKDALFC@Attribute?5with?5QName?5?8xmlns?8?5is@ DB 'Attribute w'
	DB	'ith QName ''xmlns'' is not allowed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPEFOGKI@xmlns@
CONST	SEGMENT
??_C@_05PPEFOGKI@xmlns@ DB 'xmlns', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HDKKBGMJ@Attribute?5with?5namespace?5?8?$CFs?8?5i@
CONST	SEGMENT
??_C@_0CO@HDKKBGMJ@Attribute?5with?5namespace?5?8?$CFs?8?5i@ DB 'Attribut'
	DB	'e with namespace ''%s'' is not allowed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FIBBGPIH@http?3?1?1www?4w3?4org?12000?1xmlns@
CONST	SEGMENT
??_C@_0BN@FIBBGPIH@http?3?1?1www?4w3?4org?12000?1xmlns@ DB 'http://www.w3'
	DB	'.org/2000/xmlns', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EMBMPALF@name?5?8?$CFs?8?5is?5not?5an?5NCName?6@
CONST	SEGMENT
??_C@_0BM@EMBMPALF@name?5?8?$CFs?8?5is?5not?5an?5NCName?6@ DB 'name ''%s'''
	DB	' is not an NCName', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CJKCJPCE@Element?5?$CFs?5name?5?8?$CFs?8?5is?5not?5an?5@
CONST	SEGMENT
??_C@_0CH@CJKCJPCE@Element?5?$CFs?5name?5?8?$CFs?8?5is?5not?5an?5@ DB 'El'
	DB	'ement %s name ''%s'' is not an NCName', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06IHANJIJ@nsName@
CONST	SEGMENT
??_C@_06IHANJIJ@nsName@ DB 'nsName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07ENOEFKNN@anyName@
CONST	SEGMENT
??_C@_07ENOEFKNN@anyName@ DB 'anyName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LBJNBDAD@exceptNameClass?5allows?5only?5a?5s@
CONST	SEGMENT
??_C@_0DC@LBJNBDAD@exceptNameClass?5allows?5only?5a?5s@ DB 'exceptNameCla'
	DB	'ss allows only a single except node', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FIOBKDGD@Expecting?5an?5except?5node?6@
CONST	SEGMENT
??_C@_0BK@FIOBKDGD@Expecting?5an?5except?5node?6@ DB 'Expecting an except'
	DB	' node', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BOMNCDFG@attribute?5has?5multiple?5children@
CONST	SEGMENT
??_C@_0CB@BOMNCDFG@attribute?5has?5multiple?5children@ DB 'attribute has '
	DB	'multiple children', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KBLNJNDN@RNG?5Internal?5error?0?5noop?5found?5@
CONST	SEGMENT
??_C@_0CN@KBLNJNDN@RNG?5Internal?5error?0?5noop?5found?5@ DB 'RNG Interna'
	DB	'l error, noop found in attribute', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NPGIAHLH@attribute?5has?5invalid?5content?6@
CONST	SEGMENT
??_C@_0BP@NPGIAHLH@attribute?5has?5invalid?5content?6@ DB 'attribute has '
	DB	'invalid content', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EOBONIDO@xmlRelaxNGParseattribute?3?5attri@
CONST	SEGMENT
??_C@_0DF@EOBONIDO@xmlRelaxNGParseattribute?3?5attri@ DB 'xmlRelaxNGParse'
	DB	'attribute: attribute has no children', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JOIAOFAL@Unexpected?5node?5?$CFs?5is?5not?5a?5pat@
CONST	SEGMENT
??_C@_0CF@JOIAOFAL@Unexpected?5node?5?$CFs?5is?5not?5a?5pat@ DB 'Unexpect'
	DB	'ed node %s is not a pattern', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KLBAOPHA@Mixed?5is?5empty?6@
CONST	SEGMENT
??_C@_0BA@KLBAOPHA@Mixed?5is?5empty?6@ DB 'Mixed is empty', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05IPHDHIPP@mixed@
CONST	SEGMENT
??_C@_05IPHDHIPP@mixed@ DB 'mixed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BEBEIBPH@Internal?5error?5parentRef?5defini@
CONST	SEGMENT
??_C@_0CL@BEBEIBPH@Internal?5error?5parentRef?5defini@ DB 'Internal error'
	DB	' parentRef definitions ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IFNGOHLC@parentRef?5is?5not?5empty?6@
CONST	SEGMENT
??_C@_0BI@IFNGOHLC@parentRef?5is?5not?5empty?6@ DB 'parentRef is not empt'
	DB	'y', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HCJCFDNF@parentRef?5name?5?8?$CFs?8?5is?5not?5an?5N@
CONST	SEGMENT
??_C@_0CG@HCJCFDNF@parentRef?5name?5?8?$CFs?8?5is?5not?5an?5N@ DB 'parent'
	DB	'Ref name ''%s'' is not an NCName', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CNIAONFA@parentRef?5has?5no?5name?6@
CONST	SEGMENT
??_C@_0BH@CNIAONFA@parentRef?5has?5no?5name?6@ DB 'parentRef has no name', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@EGBMGFAB@Use?5of?5parentRef?5without?5a?5pare@
CONST	SEGMENT
??_C@_0CL@EGBMGFAB@Use?5of?5parentRef?5without?5a?5pare@ DB 'Use of paren'
	DB	'tRef without a parent grammar', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MEMHAAID@xmlRelaxNGParse?3?5notAllowed?5ele@
CONST	SEGMENT
??_C@_0DC@MEMHAAID@xmlRelaxNGParse?3?5notAllowed?5ele@ DB 'xmlRelaxNGPars'
	DB	'e: notAllowed element is not empty', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KLFBBEAG@ref?5is?5not?5empty?6@
CONST	SEGMENT
??_C@_0BC@KLFBBEAG@ref?5is?5not?5empty?6@ DB 'ref is not empty', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CEHKGAHL@ref?5name?5?8?$CFs?8?5is?5not?5an?5NCName?6@
CONST	SEGMENT
??_C@_0CA@CEHKGAHL@ref?5name?5?8?$CFs?8?5is?5not?5an?5NCName?6@ DB 'ref n'
	DB	'ame ''%s'' is not an NCName', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BOHONICN@ref?5has?5no?5name?6@
CONST	SEGMENT
??_C@_0BB@BOHONICN@ref?5has?5no?5name?6@ DB 'ref has no name', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BCLGKPIM@Element?5?$CFs?5is?5empty?6@
CONST	SEGMENT
??_C@_0BF@BCLGKPIM@Element?5?$CFs?5is?5empty?6@ DB 'Element %s is empty', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LOCKCMHG@text?3?5had?5a?5child?5node?6@
CONST	SEGMENT
??_C@_0BI@LOCKCMHG@text?3?5had?5a?5child?5node?6@ DB 'text: had a child n'
	DB	'ode', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FKDMDHPF@empty?3?5had?5a?5child?5node?6@
CONST	SEGMENT
??_C@_0BJ@FKDMDHPF@empty?3?5had?5a?5child?5node?6@ DB 'empty: had a child'
	DB	' node', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JMOIDLLM@xmlRelaxNGParse?3?5?$CFs?5is?5empty?6@
CONST	SEGMENT
??_C@_0BO@JMOIDLLM@xmlRelaxNGParse?3?5?$CFs?5is?5empty?6@ DB 'xmlRelaxNGP'
	DB	'arse: %s is empty', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NOKALBCN@Could?5not?5create?5references?5has@
CONST	SEGMENT
??_C@_0CC@NOKALBCN@Could?5not?5create?5references?5has@ DB 'Could not cre'
	DB	'ate references hash', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KAJIFPGI@Error?5refs?5definitions?6@
CONST	SEGMENT
??_C@_0BI@KAJIFPGI@Error?5refs?5definitions?6@ DB 'Error refs definitions'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KBAJDCGM@Error?5refs?5definitions?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BN@KBAJDCGM@Error?5refs?5definitions?5?8?$CFs?8?6@ DB 'Error refs '
	DB	'definitions ''%s''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PJMCGFMO@Internal?5error?5on?5define?5aggreg@
CONST	SEGMENT
??_C@_0CM@PJMCGFMO@Internal?5error?5on?5define?5aggreg@ DB 'Internal erro'
	DB	'r on define aggregation of %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@EGGMPODH@Could?5not?5create?5definition?5has@
CONST	SEGMENT
??_C@_0CC@EGGMPODH@Could?5not?5create?5definition?5has@ DB 'Could not cre'
	DB	'ate definition hash', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KMIJHMFO@define?5has?5no?5children?6@
CONST	SEGMENT
??_C@_0BI@KMIJHMFO@define?5has?5no?5children?6@ DB 'define has no childre'
	DB	'n', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LEKDIHDI@define?5name?5?8?$CFs?8?5is?5not?5an?5NCNa@
CONST	SEGMENT
??_C@_0CD@LEKDIHDI@define?5name?5?8?$CFs?8?5is?5not?5an?5NCNa@ DB 'define'
	DB	' name ''%s'' is not an NCName', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OMGBAGKJ@define?5has?5no?5name?6@
CONST	SEGMENT
??_C@_0BE@OMGBAGKJ@define?5has?5no?5name?6@ DB 'define has no name', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GFEIPOEG@Include?5document?5root?5is?5not?5a?5@
CONST	SEGMENT
??_C@_0CI@GFEIPOEG@Include?5document?5root?5is?5not?5a?5@ DB 'Include doc'
	DB	'ument root is not a grammar', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NJFOGBOE@Include?5document?5is?5empty?6@
CONST	SEGMENT
??_C@_0BL@NJFOGBOE@Include?5document?5is?5empty?6@ DB 'Include document i'
	DB	's empty', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PJHELFJE@Include?5node?5has?5no?5data?6@
CONST	SEGMENT
??_C@_0BK@PJHELFJE@Include?5node?5has?5no?5data?6@ DB 'Include node has n'
	DB	'o data', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JGOKJKPH@Element?5interleave?5is?5empty?6@
CONST	SEGMENT
??_C@_0BN@JGOKJKPH@Element?5interleave?5is?5empty?6@ DB 'Element interlea'
	DB	've is empty', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BLFIOJCN@Failed?5to?5add?5?$CFs?5to?5hash?5table?6@
CONST	SEGMENT
??_C@_0CA@BLFIOJCN@Failed?5to?5add?5?$CFs?5to?5hash?5table?6@ DB 'Failed '
	DB	'to add %s to hash table', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MHPBOBHE@interleave?$CFd@
CONST	SEGMENT
??_C@_0N@MHPBOBHE@interleave?$CFd@ DB 'interleave%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JIDAHLJE@create?5interleaves?6@
CONST	SEGMENT
??_C@_0BE@JIDAHLJE@create?5interleaves?6@ DB 'create interleaves', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FDJODHDJ@in?5interleave?5computation?6@
CONST	SEGMENT
??_C@_0BL@FDJODHDJ@in?5interleave?5computation?6@ DB 'in interleave compu'
	DB	'tation', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PJGIOECJ@Attributes?5conflicts?5in?5interle@
CONST	SEGMENT
??_C@_0CE@PJGIOECJ@Attributes?5conflicts?5in?5interle@ DB 'Attributes con'
	DB	'flicts in interleave', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CIKEPODC@Element?5or?5text?5conflicts?5in?5in@
CONST	SEGMENT
??_C@_0CJ@CIKEPODC@Element?5or?5text?5conflicts?5in?5in@ DB 'Element or t'
	DB	'ext conflicts in interleave', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PNPCONEA@Attributes?5conflicts?5in?5group?6@
CONST	SEGMENT
??_C@_0BP@PNPCONEA@Attributes?5conflicts?5in?5group?6@ DB 'Attributes con'
	DB	'flicts in group', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MBENMANO@building?5group?6@
CONST	SEGMENT
??_C@_0BA@MBENMANO@building?5group?6@ DB 'building group', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IAJCOJMF@?$CDany@
CONST	SEGMENT
??_C@_04IAJCOJMF@?$CDany@ DB '#any', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HIJGJJAM@building?5choice?6@
CONST	SEGMENT
??_C@_0BB@HIJGJJAM@building?5choice?6@ DB 'building choice', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CHOOIKPA@getting?5element?5list?6@
CONST	SEGMENT
??_C@_0BG@CHOOIKPA@getting?5element?5list?6@ DB 'getting element list', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
CONST	SEGMENT
??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ DB 'Unimplem'
	DB	'ented block at %s:%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@NFABHKPN@c?3?2users?2dag?2documents?2_clients@
CONST	SEGMENT
??_C@_0GJ@NFABHKPN@c?3?2users?2dag?2documents?2_clients@ DB 'c:\users\dag'
	DB	'\documents\_clients\codeproject authors group\windows on arm\'
	DB	'libxml2\libxml2-2.9.9\relaxng.c', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PINMOFEF@Element?5data?5has?5unexpected?5con@
CONST	SEGMENT
??_C@_0CI@PINMOFEF@Element?5data?5has?5unexpected?5con@ DB 'Element data '
	DB	'has unexpected content %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BGPIOKNJ@except?5has?5no?5content?6@
CONST	SEGMENT
??_C@_0BH@BGPIOKNJ@except?5has?5no?5content?6@ DB 'except has no content', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HHALNFAB@param?5has?5no?5name?6@
CONST	SEGMENT
??_C@_0BD@HHALNFAB@param?5has?5no?5name?6@ DB 'param has no name', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MKALBABO@Type?5library?5?8?$CFs?8?5does?5not?5allo@
CONST	SEGMENT
??_C@_0DC@MKALBABO@Type?5library?5?8?$CFs?8?5does?5not?5allo@ DB 'Type li'
	DB	'brary ''%s'' does not allow type parameters', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CMFBJDBA@IDREFS@
CONST	SEGMENT
??_C@_06CMFBJDBA@IDREFS@ DB 'IDREFS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HKGPJLPA@IDREF@
CONST	SEGMENT
??_C@_05HKGPJLPA@IDREF@ DB 'IDREF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BPINBNAH@data?5type?5?8?$CFs?8?5is?5not?5an?5NCName@
CONST	SEGMENT
??_C@_0CB@BPINBNAH@data?5type?5?8?$CFs?8?5is?5not?5an?5NCName@ DB 'data t'
	DB	'ype ''%s'' is not an NCName', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JLMCOJJL@data?5has?5no?5type?6@
CONST	SEGMENT
??_C@_0BC@JLMCOJJL@data?5has?5no?5type?6@ DB 'data has no type', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DOBLDJBI@Value?5?8?$CFs?8?5is?5not?5acceptable?5fo@
CONST	SEGMENT
??_C@_0CM@DOBLDJBI@Value?5?8?$CFs?8?5is?5not?5acceptable?5fo@ DB 'Value '''
	DB	'%s'' is not acceptable for type ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OGDHDPEE@Element?5?$DMvalue?$DO?5has?5no?5content?6@
CONST	SEGMENT
??_C@_0CA@OGDHDPEE@Element?5?$DMvalue?$DO?5has?5no?5content?6@ DB 'Elemen'
	DB	't <value> has no content', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DOAINIPC@Expecting?5a?5single?5text?5value?5f@
CONST	SEGMENT
??_C@_0DC@DOAINIPC@Expecting?5a?5single?5text?5value?5f@ DB 'Expecting a '
	DB	'single text value for <value>content', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@BCJPPODI@Error?5type?5?8?$CFs?8?5is?5not?5exported@
CONST	SEGMENT
??_C@_0DG@BCJPPODI@Error?5type?5?8?$CFs?8?5is?5not?5exported@ DB 'Error t'
	DB	'ype ''%s'' is not exported by type library ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@GFLCPBDN@Internal?5error?5with?5type?5librar@
CONST	SEGMENT
??_C@_0DC@GFLCPBDN@Internal?5error?5with?5type?5librar@ DB 'Internal erro'
	DB	'r with type library ''%s'': no ''have''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BAFMNDJC@Use?5of?5unregistered?5type?5librar@
CONST	SEGMENT
??_C@_0CH@BAFMNDJC@Use?5of?5unregistered?5type?5librar@ DB 'Use of unregi'
	DB	'stered type library ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HGJHHNGH@value?5type?5?8?$CFs?8?5is?5not?5an?5NCNam@
CONST	SEGMENT
??_C@_0CC@HGJHHNGH@value?5type?5?8?$CFs?8?5is?5not?5an?5NCNam@ DB 'value '
	DB	'type ''%s'' is not an NCName', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04GPMDFGEJ@type@
CONST	SEGMENT
??_C@_04GPMDFGEJ@type@ DB 'type', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EIMIMFCI@?3?1?$CD?$DP@
CONST	SEGMENT
??_C@_04EIMIMFCI@?3?1?$CD?$DP@ DB ':/#?', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OLOJGOCH@datatypeLibrary@
CONST	SEGMENT
??_C@_0BA@OLOJGOCH@datatypeLibrary@ DB 'datatypeLibrary', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJOLNDGD@data@
CONST	SEGMENT
??_C@_04PJOLNDGD@data@ DB 'data', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JOFHGKIK@RNG?5internal?5error?5trying?5to?5co@
CONST	SEGMENT
??_C@_0CJ@JOFHGKIK@RNG?5internal?5error?5trying?5to?5co@ DB 'RNG internal'
	DB	' error trying to compile %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05NOBOONOA@?$CDtext@
CONST	SEGMENT
??_C@_05NOBOONOA@?$CDtext@ DB '#text', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MAOGIMDF@http?3?1?1www?4w3?4org?12001?1XMLSchem@
CONST	SEGMENT
??_C@_0CL@MAOGIMDF@http?3?1?1www?4w3?4org?12001?1XMLSchem@ DB 'http://www'
	DB	'.w3.org/2001/XMLSchema-datatypes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BNBDCCII@Failed?5to?5allocate?5sh?5table?5for@
CONST	SEGMENT
??_C@_0DA@BNBDCCII@Failed?5to?5allocate?5sh?5table?5for@ DB 'Failed to al'
	DB	'locate sh table for Relax-NG types', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DKNFFGLK@Relax?9NG?5types?5library?5failed?5t@
CONST	SEGMENT
??_C@_0DA@DKNFFGLK@Relax?9NG?5types?5library?5failed?5t@ DB 'Relax-NG typ'
	DB	'es library failed to register ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BMGNHHOA@adding?5types?5library?6@
CONST	SEGMENT
??_C@_0BG@BMGNHHOA@adding?5types?5library?6@ DB 'adding types library', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KBDGNEEG@Relax?9NG?5types?5library?5?8?$CFs?8?5alr@
CONST	SEGMENT
??_C@_0DA@KBDGNEEG@Relax?9NG?5types?5library?5?8?$CFs?8?5alr@ DB 'Relax-N'
	DB	'G types library ''%s'' already registered', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JMKJMOPH@token@
CONST	SEGMENT
??_C@_05JMKJMOPH@token@ DB 'token', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICGJLFIM@string@
CONST	SEGMENT
??_C@_06ICGJLFIM@string@ DB 'string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KIHADLGO@minLength@
CONST	SEGMENT
??_C@_09KIHADLGO@minLength@ DB 'minLength', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KJHMKBNK@maxLength@
CONST	SEGMENT
??_C@_09KJHMKBNK@maxLength@ DB 'maxLength', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IJDLPEM@length@
CONST	SEGMENT
??_C@_06IJDLPEM@length@ DB 'length', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CCEMGGFL@whiteSpace@
CONST	SEGMENT
??_C@_0L@CCEMGGFL@whiteSpace@ DB 'whiteSpace', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FJOIDAAJ@enumeration@
CONST	SEGMENT
??_C@_0M@FJOIDAAJ@enumeration@ DB 'enumeration', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CHFOACKJ@pattern@
CONST	SEGMENT
??_C@_07CHFOACKJ@pattern@ DB 'pattern', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EPJLKDGA@fractionDigits@
CONST	SEGMENT
??_C@_0P@EPJLKDGA@fractionDigits@ DB 'fractionDigits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PGNNBCIB@totalDigits@
CONST	SEGMENT
??_C@_0M@PGNNBCIB@totalDigits@ DB 'totalDigits', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IEJNIJII@maxExclusive@
CONST	SEGMENT
??_C@_0N@IEJNIJII@maxExclusive@ DB 'maxExclusive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EBHLFCPN@maxInclusive@
CONST	SEGMENT
??_C@_0N@EBHLFCPN@maxInclusive@ DB 'maxInclusive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MENCPBPO@minExclusive@
CONST	SEGMENT
??_C@_0N@MENCPBPO@minExclusive@ DB 'minExclusive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BDECKIL@minInclusive@
CONST	SEGMENT
??_C@_0N@BDECKIL@minInclusive@ DB 'minInclusive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
CONST	SEGMENT
??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@ DB 'http://www'
	DB	'.w3.org/2001/XMLSchema', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OAFIADK@Unknown?5error?5code?5?$CFd?6@
CONST	SEGMENT
??_C@_0BH@OAFIADK@Unknown?5error?5code?5?$CFd?6@ DB 'Unknown error code %'
	DB	'd', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OENMHDGG@Unknown?5error?5?$CB?6@
CONST	SEGMENT
??_C@_0BB@OENMHDGG@Unknown?5error?5?$CB?6@ DB 'Unknown error !', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HIGEPHGM@Extra?5data?5in?5the?5document?6@
CONST	SEGMENT
??_C@_0BM@HIGEPHGM@Extra?5data?5in?5the?5document?6@ DB 'Extra data in th'
	DB	'e document', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LEPPKIJB@No?5top?5grammar?5defined?6@
CONST	SEGMENT
??_C@_0BI@LEPPKIJB@No?5top?5grammar?5defined?6@ DB 'No top grammar define'
	DB	'd', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MNIEAPHM@Error?5validating?5list?6@
CONST	SEGMENT
??_C@_0BH@MNIEAPHM@Error?5validating?5list?6@ DB 'Error validating list', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BLOANDFF@Error?5validating?5value?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@BLOANDFF@Error?5validating?5value?5?$CFs?6@ DB 'Error validatin'
	DB	'g value %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GLDGEAAK@Error?5validating?5datatype?5?$CFs?6@
CONST	SEGMENT
??_C@_0BO@GLDGEAAK@Error?5validating?5datatype?5?$CFs?6@ DB 'Error valida'
	DB	'ting datatype %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LKJLECIM@List?5element?5?$CFs?5has?5child?5eleme@
CONST	SEGMENT
??_C@_0CE@LKJLECIM@List?5element?5?$CFs?5has?5child?5eleme@ DB 'List elem'
	DB	'ent %s has child elements', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MGMBBHLP@Value?5element?5?$CFs?5has?5child?5elem@
CONST	SEGMENT
??_C@_0CF@MGMBBHLP@Value?5element?5?$CFs?5has?5child?5elem@ DB 'Value ele'
	DB	'ment %s has child elements', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NMBBKCFB@Datatype?5element?5?$CFs?5has?5child?5e@
CONST	SEGMENT
??_C@_0CI@NMBBKCFB@Datatype?5element?5?$CFs?5has?5child?5e@ DB 'Datatype '
	DB	'element %s has child elements', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FMKMGJKC@Datatype?5element?5?$CFs?5contains?5no@
CONST	SEGMENT
??_C@_0CG@FMKMGJKC@Datatype?5element?5?$CFs?5contains?5no@ DB 'Datatype e'
	DB	'lement %s contains no data', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@ECDDKCLG@Invalid?5attribute?5?$CFs?5for?5elemen@
CONST	SEGMENT
??_C@_0CF@ECDDKCLG@Invalid?5attribute?5?$CFs?5for?5elemen@ DB 'Invalid at'
	DB	'tribute %s for element %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PHDGKAKM@Element?5?$CFs?5has?5extra?5content?3?5?$CF@
CONST	SEGMENT
??_C@_0CC@PHDGKAKM@Element?5?$CFs?5has?5extra?5content?3?5?$CF@ DB 'Eleme'
	DB	'nt %s has extra content: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HDDGPFIH@Element?5?$CFs?5failed?5to?5validate?5c@
CONST	SEGMENT
??_C@_0CH@HDDGPFIH@Element?5?$CFs?5failed?5to?5validate?5c@ DB 'Element %'
	DB	's failed to validate content', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NNGAPDCO@Element?5?$CFs?5failed?5to?5validate?5a@
CONST	SEGMENT
??_C@_0CK@NNGAPDCO@Element?5?$CFs?5failed?5to?5validate?5a@ DB 'Element %'
	DB	's failed to validate attributes', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PIOGJCNK@Expecting?5an?5element?5got?5text?6@
CONST	SEGMENT
??_C@_0BP@PIOGJCNK@Expecting?5an?5element?5got?5text?6@ DB 'Expecting an '
	DB	'element got text', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GHEDPKLH@Expecting?5an?5element?5?$CFs?0?5got?5no@
CONST	SEGMENT
??_C@_0CG@GHEDPKLH@Expecting?5an?5element?5?$CFs?0?5got?5no@ DB 'Expectin'
	DB	'g an element %s, got nothing', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DNABBFDN@Expecting?5element?5?$CFs?5to?5be?5empt@
CONST	SEGMENT
??_C@_0CC@DNABBFDN@Expecting?5element?5?$CFs?5to?5be?5empt@ DB 'Expecting'
	DB	' element %s to be empty', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HAJGKJGA@Expecting?5no?5namespace?5for?5elem@
CONST	SEGMENT
??_C@_0CH@HAJGKJGA@Expecting?5no?5namespace?5for?5elem@ DB 'Expecting no '
	DB	'namespace for element %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PJGOEKPA@Did?5not?5expect?5text?5in?5element?5@
CONST	SEGMENT
??_C@_0CL@PJGOEKPA@Did?5not?5expect?5text?5in?5element?5@ DB 'Did not exp'
	DB	'ect text in element %s content', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PHEJHGKI@Did?5not?5expect?5element?5?$CFs?5there@
CONST	SEGMENT
??_C@_0CB@PHEJHGKI@Did?5not?5expect?5element?5?$CFs?5there@ DB 'Did not e'
	DB	'xpect element %s there', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FJCKMMIH@Element?5?$CFs?5has?5wrong?5namespace?3@
CONST	SEGMENT
??_C@_0CO@FJCKMMIH@Element?5?$CFs?5has?5wrong?5namespace?3@ DB 'Element %'
	DB	's has wrong namespace: expecting %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JOOKFIPP@Expecting?5a?5namespace?5for?5eleme@
CONST	SEGMENT
??_C@_0CG@JOOKFIPP@Expecting?5a?5namespace?5for?5eleme@ DB 'Expecting a n'
	DB	'amespace for element %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IPFGDLDE@Expecting?5element?5?$CFs?0?5got?5?$CFs?6@
CONST	SEGMENT
??_C@_0BO@IPFGDLDE@Expecting?5element?5?$CFs?0?5got?5?$CFs?6@ DB 'Expecti'
	DB	'ng element %s, got %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LHKGPAAK@Extra?5element?5?$CFs?5in?5interleave?6@
CONST	SEGMENT
??_C@_0CA@LHKGPAAK@Extra?5element?5?$CFs?5in?5interleave?6@ DB 'Extra ele'
	DB	'ment %s in interleave', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EOAAMELI@Invalid?5sequence?5in?5interleave?6@
CONST	SEGMENT
??_C@_0CA@EOAAMELI@Invalid?5sequence?5in?5interleave?6@ DB 'Invalid seque'
	DB	'nce in interleave', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@IMJEPEGE@Internal?3?5interleave?5block?5has?5@
CONST	SEGMENT
??_C@_0CI@IMJEPEGE@Internal?3?5interleave?5block?5has?5@ DB 'Internal: in'
	DB	'terleave block has no data', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DGHEOLEJ@Extra?5data?5in?5list?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@DGHEOLEJ@Extra?5data?5in?5list?3?5?$CFs?6@ DB 'Extra data in li'
	DB	'st: %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MNPHNNMB@Internal?5error?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BE@MNPHNNMB@Internal?5error?3?5?$CFs?6@ DB 'Internal error: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MNHHIDKB@Internal?5error?3?5no?5define?6@
CONST	SEGMENT
??_C@_0BL@MNHHIDKB@Internal?5error?3?5no?5define?6@ DB 'Internal error: n'
	DB	'o define', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NEMAGDEO@Internal?5error?3?5no?5state?6@
CONST	SEGMENT
??_C@_0BK@NEMAGDEO@Internal?5error?3?5no?5state?6@ DB 'Internal error: no'
	DB	' state', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NPBAOLP@failed?5to?5compare?5type?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@NPBAOLP@failed?5to?5compare?5type?5?$CFs?6@ DB 'failed to compa'
	DB	're type %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HOPAIONI@ID?5?$CFs?5redefined?6@
CONST	SEGMENT
??_C@_0BB@HOPAIONI@ID?5?$CFs?5redefined?6@ DB 'ID %s redefined', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KEMEBCBB@Type?5?$CFs?5doesn?8t?5allow?5value?5?8?$CFs@
CONST	SEGMENT
??_C@_0CC@KEMEBCBB@Type?5?$CFs?5doesn?8t?5allow?5value?5?8?$CFs@ DB 'Type'
	DB	' %s doesn''t allow value ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@ECNPKFCP@failed?5to?5validate?5type?5?$CFs?6@
CONST	SEGMENT
??_C@_0BM@ECNPKFCP@failed?5to?5validate?5type?5?$CFs?6@ DB 'failed to val'
	DB	'idate type %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PCJPAHLM@out?5of?5memory?6@
CONST	SEGMENT
??_C@_0P@PCJPAHLM@out?5of?5memory?6@ DB 'out of memory', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIFAGBMG@unknown@
CONST	SEGMENT
??_C@_07CIFAGBMG@unknown@ DB 'unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LJDNNBIK@param@
CONST	SEGMENT
??_C@_05LJDNNBIK@param@ DB 'param', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BACONDHA@noop@
CONST	SEGMENT
??_C@_04BACONDHA@noop@ DB 'noop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NLPEADBD@interleave@
CONST	SEGMENT
??_C@_0L@NLPEADBD@interleave@ DB 'interleave', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05MGJOOGAJ@group@
CONST	SEGMENT
??_C@_05MGJOOGAJ@group@ DB 'group', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DDDNEJEA@choice@
CONST	SEGMENT
??_C@_06DDDNEJEA@choice@ DB 'choice', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EIEDMNLG@oneOrMore@
CONST	SEGMENT
??_C@_09EIEDMNLG@oneOrMore@ DB 'oneOrMore', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BANFCDDP@zeroOrMore@
CONST	SEGMENT
??_C@_0L@BANFCDDP@zeroOrMore@ DB 'zeroOrMore', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EBGGHLAO@optional@
CONST	SEGMENT
??_C@_08EBGGHLAO@optional@ DB 'optional', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LEMMFILP@parentRef@
CONST	SEGMENT
??_C@_09LEMMFILP@parentRef@ DB 'parentRef', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CPEFJFBC@externalRef@
CONST	SEGMENT
??_C@_0M@CPEFJFBC@externalRef@ DB 'externalRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03GCDGINBO@ref@
CONST	SEGMENT
??_C@_03GCDGINBO@ref@ DB 'ref', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BHEEIFFN@def@
CONST	SEGMENT
??_C@_03BHEEIFFN@def@ DB 'def', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09HGIEBAJ@attribute@
CONST	SEGMENT
??_C@_09HGIEBAJ@attribute@ DB 'attribute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DONFEANM@list@
CONST	SEGMENT
??_C@_04DONFEANM@list@ DB 'list', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MFEJDJP@value@
CONST	SEGMENT
??_C@_05MFEJDJP@value@ DB 'value', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08IJKJONLA@datatype@
CONST	SEGMENT
??_C@_08IJKJONLA@datatype@ DB 'datatype', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HCLJNICE@element@
CONST	SEGMENT
??_C@_07HCLJNICE@element@ DB 'element', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CIMGMMMG@text@
CONST	SEGMENT
??_C@_04CIMGMMMG@text@ DB 'text', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06JBKEBCGB@except@
CONST	SEGMENT
??_C@_06JBKEBCGB@except@ DB 'except', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GPGJMKBL@notAllowed@
CONST	SEGMENT
??_C@_0L@GPGJMKBL@notAllowed@ DB 'notAllowed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05LBJMNBOG@empty@
CONST	SEGMENT
??_C@_05LBJMNBOG@empty@ DB 'empty', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGFJFPFD@none@
CONST	SEGMENT
??_C@_04CGFJFPFD@none@ DB 'none', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PEJCGLNC@xmlRelaxNG?3?5allocate?5memory?5for@
CONST	SEGMENT
??_C@_0CI@PEJCGLNC@xmlRelaxNG?3?5allocate?5memory?5for@ DB 'xmlRelaxNG: a'
	DB	'llocate memory for doc %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@BCCMNNOD@Detected?5an?5externalRef?5recursi@
CONST	SEGMENT
??_C@_0CK@BCCMNNOD@Detected?5an?5externalRef?5recursi@ DB 'Detected an ex'
	DB	'ternalRef recursion for %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MHBNCBHM@adding?5document?6@
CONST	SEGMENT
??_C@_0BB@MHBNCBHM@adding?5document?6@ DB 'adding document', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JOLGCMKD@pushing?5error?6@
CONST	SEGMENT
??_C@_0P@JOLGCMKD@pushing?5error?6@ DB 'pushing error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03FEJMGOGI@div@
CONST	SEGMENT
??_C@_03FEJMGOGI@div@ DB 'div', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@PNICLKOF@xmlRelaxNG?3?5include?5?$CFs?5has?5a?5de@
CONST	SEGMENT
??_C@_0EF@PNICLKOF@xmlRelaxNG?3?5include?5?$CFs?5has?5a?5de@ DB 'xmlRelax'
	DB	'NG: include %s has a define %s but not the included grammar', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@OCDIDEDL@xmlRelaxNG?3?5include?5?$CFs?5has?5defi@
CONST	SEGMENT
??_C@_0DA@OCDIDEDL@xmlRelaxNG?3?5include?5?$CFs?5has?5defi@ DB 'xmlRelaxN'
	DB	'G: include %s has define without name', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@LAOLKJIK@xmlRelaxNG?3?5include?5?$CFs?5has?5a?5st@
CONST	SEGMENT
??_C@_0EB@LAOLKJIK@xmlRelaxNG?3?5include?5?$CFs?5has?5a?5st@ DB 'xmlRelax'
	DB	'NG: include %s has a start but not the included grammar', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@NNDELAMP@xmlRelaxNG?3?5included?5document?5?$CF@
CONST	SEGMENT
??_C@_0DI@NNDELAMP@xmlRelaxNG?3?5included?5document?5?$CF@ DB 'xmlRelaxNG'
	DB	': included document %s root is not a grammar', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MDFAGPKO@xmlRelaxNG?3?5included?5document?5i@
CONST	SEGMENT
??_C@_0CL@MDFAGPKO@xmlRelaxNG?3?5included?5document?5i@ DB 'xmlRelaxNG: i'
	DB	'ncluded document is empty %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGOFOKPC@ns@
CONST	SEGMENT
??_C@_02EGOFOKPC@ns@ DB 'ns', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BDBHMEOE@xmlRelaxNG?3?5could?5not?5load?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@BDBHMEOE@xmlRelaxNG?3?5could?5not?5load?5?$CFs?6@ DB 'xmlRelaxN'
	DB	'G: could not load %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MLBLJJIG@Detected?5an?5Include?5recursion?5f@
CONST	SEGMENT
??_C@_0CG@MLBLJJIG@Detected?5an?5Include?5recursion?5f@ DB 'Detected an I'
	DB	'nclude recursion for %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EFOLCII@grammar@
CONST	SEGMENT
??_C@_07EFOLCII@grammar@ DB 'grammar', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FHOHOHLG@include@
CONST	SEGMENT
??_C@_07FHOHOHLG@include@ DB 'include', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06EPMMJFDC@define@
CONST	SEGMENT
??_C@_06EPMMJFDC@define@ DB 'define', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FAGFPHJG@start@
CONST	SEGMENT
??_C@_05FAGFPHJG@start@ DB 'start', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NICNHGJN@allocating?5include?6@
CONST	SEGMENT
??_C@_0BE@NICNHGJN@allocating?5include?6@ DB 'allocating include', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DKBKEJJK@storing?5states?6@
CONST	SEGMENT
??_C@_0BA@DKBKEJJK@storing?5states?6@ DB 'storing states', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NLODGFON@adding?5states?6@
CONST	SEGMENT
??_C@_0P@NLODGFON@adding?5states?6@ DB 'adding states', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FIBAKIJP@allocating?5states?6@
CONST	SEGMENT
??_C@_0BD@FIBAKIJP@allocating?5states?6@ DB 'allocating states', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KFBIDMJP@allocating?5define?6@
CONST	SEGMENT
??_C@_0BD@KFBIDMJP@allocating?5define?6@ DB 'allocating define', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
CONST	SEGMENT
??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@ DB 'Memory allocation fa'
	DB	'iled', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ DB 'Memory al'
	DB	'location failed : %s', 0aH, 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_xmlRelaxNGNs DD FLAT:??_C@_0CE@EODHHDFK@http?3?1?1relaxng?4org?1ns?1structure@
_invalidName DD	FLAT:??_C@_01KHDNNMEB@?$AB@
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGCleanPSVI
_TEXT	SEGMENT
_node$ = 8						; size = 4
_xmlRelaxNGCleanPSVI PROC				; COMDAT

; 10857: xmlRelaxNGCleanPSVI(xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _node$[ebp]
	test	edx, edx
	je	SHORT $LN22@xmlRelaxNG

; 10858:     xmlNodePtr cur;
; 10859: 
; 10860:     if ((node == NULL) ||

	mov	eax, DWORD PTR [edx+4]
	cmp	eax, 1
	je	SHORT $LN32@xmlRelaxNG
	cmp	eax, 9
	je	SHORT $LN9@xmlRelaxNG
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN22@xmlRelaxNG

; 10861:         ((node->type != XML_ELEMENT_NODE) &&
; 10862:          (node->type != XML_DOCUMENT_NODE) &&
; 10863:          (node->type != XML_HTML_DOCUMENT_NODE)))
; 10864: 	return;
; 10865:     if (node->type == XML_ELEMENT_NODE)

	jmp	SHORT $LN9@xmlRelaxNG
$LN32@xmlRelaxNG:

; 10866:         node->psvi = NULL;

	mov	DWORD PTR [edx+52], 0
$LN9@xmlRelaxNG:

; 10867: 
; 10868:     cur = node->children;

	mov	eax, DWORD PTR [edx+12]

; 10869:     while (cur != NULL) {

	test	eax, eax
	je	SHORT $LN22@xmlRelaxNG
$LL2@xmlRelaxNG:

; 10870: 	if (cur->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN11@xmlRelaxNG

; 10871: 	    cur->psvi = NULL;
; 10872: 	    if (cur->children != NULL) {

	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+52], 0
	test	ecx, ecx
	jne	SHORT $LN40@xmlRelaxNG

; 10873: 		cur = cur->children;
; 10874: 		continue;
; 10875: 	    }
; 10876: 	}
; 10877: 	if (cur->next != NULL) {
; 10878: 	    cur = cur->next;
; 10879: 	    continue;

	jmp	SHORT $LN11@xmlRelaxNG
	npad	4
$LL6@xmlRelaxNG:

; 10880: 	}
; 10881: 	do {
; 10882: 	    cur = cur->parent;

	mov	eax, DWORD PTR [eax+20]

; 10883: 	    if (cur == NULL)

	test	eax, eax
	je	SHORT $LN22@xmlRelaxNG

; 10884: 		break;
; 10885: 	    if (cur == node) {

	cmp	eax, edx
	je	SHORT $LN22@xmlRelaxNG
$LN11@xmlRelaxNG:

; 10869:     while (cur != NULL) {

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LL6@xmlRelaxNG
$LN40@xmlRelaxNG:
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LL2@xmlRelaxNG
$LN22@xmlRelaxNG:

; 10886: 		cur = NULL;
; 10887: 		break;
; 10888: 	    }
; 10889: 	    if (cur->next != NULL) {
; 10890: 		cur = cur->next;
; 10891: 		break;
; 10892: 	    }
; 10893: 	} while (cur != NULL);
; 10894:     }
; 10895:     return;
; 10896: }

	pop	ebp
	ret	0
_xmlRelaxNGCleanPSVI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidateDocument
_TEXT	SEGMENT
_vctxt$1 = -68						; size = 64
_ret$1$ = -4						; size = 4
_tmp$1$ = 8						; size = 4
_state$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlRelaxNGValidateDocument PROC			; COMDAT

; 10760: {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN6@xmlRelaxNG

; 10761:     int ret;
; 10762:     xmlRelaxNGPtr schema;
; 10763:     xmlRelaxNGGrammarPtr grammar;
; 10764:     xmlRelaxNGValidStatePtr state;
; 10765:     xmlNodePtr node;
; 10766: 
; 10767:     if ((ctxt == NULL) || (ctxt->schema == NULL) || (doc == NULL))

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	$LN6@xmlRelaxNG
	cmp	DWORD PTR _doc$[ebp], 0
	je	$LN6@xmlRelaxNG

; 10769: 
; 10770:     ctxt->errNo = XML_RELAXNG_OK;

	push	esi
	mov	DWORD PTR [edi+40], 0

; 10771:     schema = ctxt->schema;
; 10772:     grammar = schema->topgrammar;

	mov	esi, DWORD PTR [eax+4]

; 10773:     if (grammar == NULL) {

	test	esi, esi
	jne	SHORT $LN7@xmlRelaxNG

; 10774:         VALID_ERR(XML_RELAXNG_ERR_NOGRAMMAR);

	push	esi
	push	esi
	push	esi
	push	34					; 00000022H
	push	edi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 10775:         return (-1);

	or	eax, -1
	pop	esi
	pop	edi

; 10841: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlRelaxNG:
	push	ebx

; 10776:     }
; 10777:     state = xmlRelaxNGNewValidState(ctxt, NULL);

	push	0
	push	edi
	call	_xmlRelaxNGNewValidState

; 10778:     ctxt->state = state;

	mov	DWORD PTR [edi+60], eax

; 10779:     ret = xmlRelaxNGValidateDefinition(ctxt, grammar->start);

	push	DWORD PTR [esi+12]
	mov	DWORD PTR _state$1$[ebp], eax
	push	edi
	call	_xmlRelaxNGValidateDefinition

; 10780:     if ((ctxt->state != NULL) && (state->seq != NULL)) {

	mov	ecx, DWORD PTR [edi+60]
	add	esp, 16					; 00000010H
	mov	ebx, eax
	mov	DWORD PTR _ret$1$[ebp], ebx
	test	ecx, ecx
	je	SHORT $LN8@xmlRelaxNG
	mov	eax, DWORD PTR _state$1$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN8@xmlRelaxNG

; 10781:         state = ctxt->state;
; 10782:         node = state->seq;
; 10783:         node = xmlRelaxNGSkipIgnored(ctxt, node);

	push	DWORD PTR [ecx+4]
	push	edi
	call	_xmlRelaxNGSkipIgnored
	add	esp, 8

; 10784:         if (node != NULL) {

	test	eax, eax
	je	SHORT $LN15@xmlRelaxNG

; 10785:             if (ret != -1) {
; 10786:                 VALID_ERR(XML_RELAXNG_ERR_EXTRADATA);
; 10787:                 ret = -1;
; 10788:             }
; 10789:         }

	jmp	SHORT $LN26@xmlRelaxNG
$LN8@xmlRelaxNG:

; 10790:     } else if (ctxt->states != NULL) {

	mov	eax, DWORD PTR [edi+64]
	test	eax, eax
	je	SHORT $LN15@xmlRelaxNG

; 10791:         int i;
; 10792:         int tmp = -1;
; 10793: 
; 10794:         for (i = 0; i < ctxt->states->nbState; i++) {

	cmp	DWORD PTR [eax], 0
	mov	DWORD PTR _tmp$1$[ebp], -1
	jle	SHORT $LN26@xmlRelaxNG
	xor	ebx, ebx
	npad	2
$LL4@xmlRelaxNG:

; 10795:             state = ctxt->states->tabState[i];

	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+ebx*4]

; 10796:             node = state->seq;
; 10797:             node = xmlRelaxNGSkipIgnored(ctxt, node);

	push	DWORD PTR [esi+4]
	push	edi
	call	_xmlRelaxNGSkipIgnored

; 10798:             if (node == NULL)

	neg	eax

; 10799:                 tmp = 0;
; 10800:             xmlRelaxNGFreeValidState(ctxt, state);

	push	esi
	sbb	eax, eax
	and	DWORD PTR _tmp$1$[ebp], eax
	push	edi
	call	_xmlRelaxNGFreeValidState
	mov	eax, DWORD PTR [edi+64]
	inc	ebx
	add	esp, 16					; 00000010H
	cmp	ebx, DWORD PTR [eax]
	jl	SHORT $LL4@xmlRelaxNG

; 10801:         }
; 10802:         if (tmp == -1) {

	cmp	DWORD PTR _tmp$1$[ebp], -1
	mov	ebx, DWORD PTR _ret$1$[ebp]
	jne	SHORT $LN15@xmlRelaxNG
$LN26@xmlRelaxNG:

; 10803:             if (ret != -1) {
; 10804:                 VALID_ERR(XML_RELAXNG_ERR_EXTRADATA);
; 10805:                 ret = -1;
; 10806:             }
; 10807:         }
; 10808:     }
; 10809:     if (ctxt->state != NULL) {

	cmp	ebx, -1
	je	SHORT $LN15@xmlRelaxNG
	push	0
	push	0
	push	0
	push	35					; 00000023H
	push	edi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H
	or	ebx, -1
$LN15@xmlRelaxNG:
	mov	eax, DWORD PTR [edi+60]
	test	eax, eax
	je	SHORT $LN16@xmlRelaxNG

; 10810:         xmlRelaxNGFreeValidState(ctxt, ctxt->state);

	push	eax
	push	edi
	call	_xmlRelaxNGFreeValidState
	add	esp, 8

; 10811:         ctxt->state = NULL;

	mov	DWORD PTR [edi+60], 0
$LN16@xmlRelaxNG:

; 10812:     }
; 10813:     if (ret != 0)

	test	ebx, ebx
	je	SHORT $LN17@xmlRelaxNG

; 10814:         xmlRelaxNGDumpValidError(ctxt);

	push	edi
	call	_xmlRelaxNGDumpValidError
	add	esp, 4
$LN17@xmlRelaxNG:

; 10815: #ifdef DEBUG
; 10816:     else if (ctxt->errNr != 0) {
; 10817:         ctxt->error(ctxt->userData,
; 10818:                     "%d Extra error messages left on stack !\n",
; 10819:                     ctxt->errNr);
; 10820:         xmlRelaxNGDumpValidError(ctxt);
; 10821:     }
; 10822: #endif
; 10823: #ifdef LIBXML_VALID_ENABLED
; 10824:     if (ctxt->idref == 1) {

	cmp	DWORD PTR [edi+36], 1
	jne	SHORT $LN19@xmlRelaxNG

; 10825:         xmlValidCtxt vctxt;
; 10826: 
; 10827:         memset(&vctxt, 0, sizeof(xmlValidCtxt));
; 10828:         vctxt.valid = 1;
; 10829:         vctxt.error = ctxt->error;

	mov	eax, DWORD PTR [edi+4]
	xorps	xmm0, xmm0

; 10830:         vctxt.warning = ctxt->warning;
; 10831:         vctxt.userData = ctxt->userData;
; 10832: 
; 10833:         if (xmlValidateDocumentFinal(&vctxt, doc) != 1)

	push	DWORD PTR _doc$[ebp]
	mov	DWORD PTR _vctxt$1[ebp+4], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR _vctxt$1[ebp+8], eax
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _vctxt$1[ebp], eax
	lea	eax, DWORD PTR _vctxt$1[ebp]
	push	eax
	movlpd	QWORD PTR _vctxt$1[ebp+12], xmm0
	movlpd	QWORD PTR _vctxt$1[ebp+20], xmm0
	movlpd	QWORD PTR _vctxt$1[ebp+28], xmm0
	movlpd	QWORD PTR _vctxt$1[ebp+40], xmm0
	movlpd	QWORD PTR _vctxt$1[ebp+48], xmm0
	movlpd	QWORD PTR _vctxt$1[ebp+56], xmm0
	mov	DWORD PTR _vctxt$1[ebp+36], 1
	call	_xmlValidateDocumentFinal
	add	esp, 8
	cmp	eax, 1
	je	SHORT $LN19@xmlRelaxNG

; 10834:             ret = -1;

	or	ebx, -1

; 10838:         ret = -1;
; 10839: 
; 10840:     return (ret);

	mov	eax, ebx
	pop	ebx
	pop	esi
	pop	edi

; 10841: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlRelaxNG:

; 10835:     }
; 10836: #endif /* LIBXML_VALID_ENABLED */
; 10837:     if ((ret == 0) && (ctxt->errNo != XML_RELAXNG_OK))

	test	ebx, ebx
	jne	SHORT $LN20@xmlRelaxNG
	or	eax, -1
	cmp	DWORD PTR [edi+40], ebx
	cmovne	ebx, eax
$LN20@xmlRelaxNG:

; 10838:         ret = -1;
; 10839: 
; 10840:     return (ret);

	mov	eax, ebx
	pop	ebx
	pop	esi
	pop	edi

; 10841: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlRelaxNG:

; 10768:         return (-1);

	or	eax, -1
	pop	edi

; 10841: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGValidateDocument ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidateState
_TEXT	SEGMENT
$T1 = -32						; size = 4
_oldflags$3$ = -32					; size = 4
_errNr$2$ = -32						; size = 4
_oldflags$4$ = -28					; size = 4
_oldflags$1$ = -28					; size = 4
_tmpstates$1$ = -24					; size = 4
_errNr$5$ = -24						; size = 4
_res$1$ = -20						; size = 4
_oldstate$1$ = -20					; size = 4
_node$2$ = -20						; size = 4
_j$3$ = -16						; size = 4
_i$5$ = -16						; size = 4
_nseq$1$ = -16						; size = 4
_tmp$3$ = -16						; size = 4
$T2 = -12						; size = 4
_progress$1$ = -12					; size = 4
_tmpstate$1$ = -12					; size = 4
_tmp$2$ = -12						; size = 4
_oldflags$2$ = -12					; size = 4
_errNr$1$ = -12						; size = 4
_node$3$ = -12						; size = 4
_content$1$ = -8					; size = 4
_content$1$ = -8					; size = 4
_i$6$ = -8						; size = 4
_ret$1$ = -8						; size = 4
_content$1$ = -4					; size = 4
_states$1$ = -4						; size = 4
_node$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_triage$1$ = 12						; size = 4
_list$2$ = 12						; size = 4
_define$ = 12						; size = 4
_xmlRelaxNGValidateState PROC				; COMDAT

; 9864 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	push	ebx
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _define$[ebp]
	xor	ebx, ebx
	xor	eax, eax
	test	edi, edi
	jne	SHORT $LN51@xmlRelaxNG

; 9865 :     xmlNodePtr node;
; 9866 :     int ret = 0, i, tmp, oldflags, errNr;
; 9867 :     xmlRelaxNGValidStatePtr oldstate = NULL, state;
; 9868 : 
; 9869 :     if (define == NULL) {
; 9870 :         VALID_ERR(XML_RELAXNG_ERR_NODEFINE);

	push	edi
	push	edi
	push	edi
	push	7
	push	esi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 9871 :         return (-1);

	or	eax, -1
	pop	edi

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@xmlRelaxNG:

; 9872 :     }
; 9873 : 
; 9874 :     if (ctxt->state != NULL) {

	mov	edx, DWORD PTR [esi+60]
	test	edx, edx
	je	SHORT $LN52@xmlRelaxNG

; 9875 :         node = ctxt->state->seq;

	mov	ecx, DWORD PTR [edx+4]

; 9876 :     } else {

	jmp	SHORT $LN435@xmlRelaxNG
$LN52@xmlRelaxNG:

; 9877 :         node = NULL;

	xor	ecx, ecx
$LN435@xmlRelaxNG:

; 9878 :     }
; 9879 : #ifdef DEBUG
; 9880 :     for (i = 0; i < ctxt->depth; i++)
; 9881 :         xmlGenericError(xmlGenericErrorContext, " ");
; 9882 :     xmlGenericError(xmlGenericErrorContext,
; 9883 :                     "Start validating %s ", xmlRelaxNGDefName(define));
; 9884 :     if (define->name != NULL)
; 9885 :         xmlGenericError(xmlGenericErrorContext, "%s ", define->name);
; 9886 :     if ((node != NULL) && (node->name != NULL))
; 9887 :         xmlGenericError(xmlGenericErrorContext, "on %s\n", node->name);
; 9888 :     else
; 9889 :         xmlGenericError(xmlGenericErrorContext, "\n");
; 9890 : #endif
; 9891 :     ctxt->depth++;

	inc	DWORD PTR [esi+32]

; 9892 :     switch (define->type) {

	mov	eax, DWORD PTR [edi]
	inc	eax
	mov	DWORD PTR _node$3$[ebp], ecx
	cmp	eax, 21					; 00000015H
	ja	$LN2@xmlRelaxNG
	jmp	DWORD PTR $LN454@xmlRelaxNG[eax*4]
$LN54@xmlRelaxNG:

; 9893 :         case XML_RELAXNG_EMPTY:
; 9894 :             xmlRelaxNGSkipIgnored(ctxt, node);

	push	ecx
	push	esi
	call	_xmlRelaxNGSkipIgnored
	add	esp, 8

; 9895 :             ret = 0;

	xor	ebx, ebx

; 10602:             break;
; 10603:     }
; 10604:     ctxt->depth--;

	dec	DWORD PTR [esi+32]

; 10605: #ifdef DEBUG
; 10606:     for (i = 0; i < ctxt->depth; i++)
; 10607:         xmlGenericError(xmlGenericErrorContext, " ");
; 10608:     xmlGenericError(xmlGenericErrorContext,
; 10609:                     "Validating %s ", xmlRelaxNGDefName(define));
; 10610:     if (define->name != NULL)
; 10611:         xmlGenericError(xmlGenericErrorContext, "%s ", define->name);
; 10612:     if (ret == 0)
; 10613:         xmlGenericError(xmlGenericErrorContext, "suceeded\n");
; 10614:     else
; 10615:         xmlGenericError(xmlGenericErrorContext, "failed\n");
; 10616: #endif
; 10617:     return (ret);

	mov	eax, ebx
	pop	edi

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN337@xmlRelaxNG:

; 9896 :             break;
; 9897 :         case XML_RELAXNG_NOT_ALLOWED:
; 9898 :             ret = -1;
; 9899 :             break;
; 9900 :         case XML_RELAXNG_TEXT:
; 9901 :             while ((node != NULL) &&

	test	ecx, ecx
	je	SHORT $LN427@xmlRelaxNG
	npad	4
$LL4@xmlRelaxNG:
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 3
	je	SHORT $LN57@xmlRelaxNG
	cmp	eax, 8
	je	SHORT $LN57@xmlRelaxNG
	cmp	eax, 7
	je	SHORT $LN57@xmlRelaxNG
	cmp	eax, 4
	jne	SHORT $LN427@xmlRelaxNG
$LN57@xmlRelaxNG:

; 9902 :                    ((node->type == XML_TEXT_NODE) ||
; 9903 :                     (node->type == XML_COMMENT_NODE) ||
; 9904 :                     (node->type == XML_PI_NODE) ||
; 9905 :                     (node->type == XML_CDATA_SECTION_NODE)))
; 9906 :                 node = node->next;

	mov	ecx, DWORD PTR [ecx+24]
	test	ecx, ecx
	jne	SHORT $LL4@xmlRelaxNG
$LN427@xmlRelaxNG:
	pop	edi

; 9907 :             ctxt->state->seq = node;

	mov	DWORD PTR [edx+4], ecx

; 10605: #ifdef DEBUG
; 10606:     for (i = 0; i < ctxt->depth; i++)
; 10607:         xmlGenericError(xmlGenericErrorContext, " ");
; 10608:     xmlGenericError(xmlGenericErrorContext,
; 10609:                     "Validating %s ", xmlRelaxNGDefName(define));
; 10610:     if (define->name != NULL)
; 10611:         xmlGenericError(xmlGenericErrorContext, "%s ", define->name);
; 10612:     if (ret == 0)
; 10613:         xmlGenericError(xmlGenericErrorContext, "suceeded\n");
; 10614:     else
; 10615:         xmlGenericError(xmlGenericErrorContext, "failed\n");
; 10616: #endif
; 10617:     return (ret);

	mov	eax, ebx
	dec	DWORD PTR [esi+32]

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN58@xmlRelaxNG:

; 9908 :             break;
; 9909 :         case XML_RELAXNG_ELEMENT:
; 9910 :             errNr = ctxt->errNr;

	mov	eax, DWORD PTR [esi+48]

; 9911 :             node = xmlRelaxNGSkipIgnored(ctxt, node);

	push	ecx
	push	esi
	mov	DWORD PTR _errNr$1$[ebp], eax
	call	_xmlRelaxNGSkipIgnored
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR _node$1$[ebp], edi

; 9912 :             if (node == NULL) {

	test	edi, edi
	jne	SHORT $LN59@xmlRelaxNG

; 9913 :                 VALID_ERR2(XML_RELAXNG_ERR_NOELEM, define->name);

	mov	ecx, DWORD PTR _define$[ebp]
	push	eax
	push	eax
	push	DWORD PTR [ecx+8]
	push	22					; 00000016H
$LN443@xmlRelaxNG:

; 10602:             break;
; 10603:     }
; 10604:     ctxt->depth--;

	push	esi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H
$LN444@xmlRelaxNG:
	or	ebx, -1
	test	BYTE PTR [esi+28], 1
$LN446@xmlRelaxNG:
	jne	$LN2@xmlRelaxNG
	push	esi
	call	_xmlRelaxNGDumpValidError
	add	esp, 4

; 10605: #ifdef DEBUG
; 10606:     for (i = 0; i < ctxt->depth; i++)
; 10607:         xmlGenericError(xmlGenericErrorContext, " ");
; 10608:     xmlGenericError(xmlGenericErrorContext,
; 10609:                     "Validating %s ", xmlRelaxNGDefName(define));
; 10610:     if (define->name != NULL)
; 10611:         xmlGenericError(xmlGenericErrorContext, "%s ", define->name);
; 10612:     if (ret == 0)
; 10613:         xmlGenericError(xmlGenericErrorContext, "suceeded\n");
; 10614:     else
; 10615:         xmlGenericError(xmlGenericErrorContext, "failed\n");
; 10616: #endif
; 10617:     return (ret);

	mov	eax, ebx
	dec	DWORD PTR [esi+32]
	pop	edi

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@xmlRelaxNG:

; 9914 :                 ret = -1;
; 9915 :                 if ((ctxt->flags & FLAGS_IGNORABLE) == 0)
; 9916 :                     xmlRelaxNGDumpValidError(ctxt);
; 9917 :                 break;
; 9918 :             }
; 9919 :             if (node->type != XML_ELEMENT_NODE) {

	cmp	DWORD PTR [edi+4], 1
	je	SHORT $LN61@xmlRelaxNG

; 9920 :                 VALID_ERR(XML_RELAXNG_ERR_NOTELEM);

	push	0
	push	0
	push	0
	push	23					; 00000017H

; 9921 :                 ret = -1;
; 9922 :                 if ((ctxt->flags & FLAGS_IGNORABLE) == 0)
; 9923 :                     xmlRelaxNGDumpValidError(ctxt);
; 9924 :                 break;

	jmp	SHORT $LN443@xmlRelaxNG
$LN61@xmlRelaxNG:

; 9925 :             }
; 9926 :             /*
; 9927 :              * This node was already validated successfully against
; 9928 :              * this definition.
; 9929 :              */
; 9930 :             if (node->psvi == define) {

	mov	eax, DWORD PTR _define$[ebp]
	cmp	DWORD PTR [edi+52], eax
	jne	$LN63@xmlRelaxNG

; 9931 :                 ctxt->state->seq = xmlRelaxNGSkipIgnored(ctxt, node->next);

	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGSkipIgnored
	mov	ecx, DWORD PTR [esi+60]
	add	esp, 8
	mov	DWORD PTR [ecx+4], eax

; 9932 :                 if (ctxt->errNr > errNr)

	mov	ecx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR _errNr$1$[ebp]
	cmp	ecx, eax
	jle	SHORT $LN64@xmlRelaxNG

; 9933 :                     xmlRelaxNGPopErrors(ctxt, errNr);

	push	eax
	push	esi
	call	_xmlRelaxNGPopErrors
	mov	ecx, DWORD PTR [esi+48]
	add	esp, 8
$LN64@xmlRelaxNG:

; 9934 :                 if (ctxt->errNr != 0) {

	test	ecx, ecx
	je	$LN2@xmlRelaxNG

; 9935 :                     while ((ctxt->err != NULL) &&

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	$LN2@xmlRelaxNG
$LL6@xmlRelaxNG:
	cmp	DWORD PTR [eax], 13			; 0000000dH
	jne	SHORT $LN67@xmlRelaxNG
	push	DWORD PTR [edi+8]
	push	DWORD PTR [eax+20]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN66@xmlRelaxNG
$LN67@xmlRelaxNG:
	mov	eax, DWORD PTR [esi+44]
	cmp	DWORD PTR [eax], 19			; 00000013H
	jne	SHORT $LN68@xmlRelaxNG
	push	DWORD PTR [edi+8]
	push	DWORD PTR [eax+16]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN66@xmlRelaxNG
$LN68@xmlRelaxNG:
	mov	eax, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [eax]
	cmp	eax, 22					; 00000016H
	je	SHORT $LN66@xmlRelaxNG
	cmp	eax, 23					; 00000017H
	jne	$LN2@xmlRelaxNG
$LN66@xmlRelaxNG:

; 9936 :                            (((ctxt->err->err == XML_RELAXNG_ERR_ELEMNAME)
; 9937 :                              && (xmlStrEqual(ctxt->err->arg2, node->name)))
; 9938 :                             ||
; 9939 :                             ((ctxt->err->err ==
; 9940 :                               XML_RELAXNG_ERR_ELEMEXTRANS)
; 9941 :                              && (xmlStrEqual(ctxt->err->arg1, node->name)))
; 9942 :                             || (ctxt->err->err == XML_RELAXNG_ERR_NOELEM)
; 9943 :                             || (ctxt->err->err ==
; 9944 :                                 XML_RELAXNG_ERR_NOTELEM)))
; 9945 :                         xmlRelaxNGValidErrorPop(ctxt);

	push	esi
	call	_xmlRelaxNGValidErrorPop
	mov	eax, DWORD PTR [esi+44]
	add	esp, 4
	test	eax, eax
	jne	SHORT $LL6@xmlRelaxNG

; 10602:             break;
; 10603:     }
; 10604:     ctxt->depth--;

	dec	DWORD PTR [esi+32]

; 10605: #ifdef DEBUG
; 10606:     for (i = 0; i < ctxt->depth; i++)
; 10607:         xmlGenericError(xmlGenericErrorContext, " ");
; 10608:     xmlGenericError(xmlGenericErrorContext,
; 10609:                     "Validating %s ", xmlRelaxNGDefName(define));
; 10610:     if (define->name != NULL)
; 10611:         xmlGenericError(xmlGenericErrorContext, "%s ", define->name);
; 10612:     if (ret == 0)
; 10613:         xmlGenericError(xmlGenericErrorContext, "suceeded\n");
; 10614:     else
; 10615:         xmlGenericError(xmlGenericErrorContext, "failed\n");
; 10616: #endif
; 10617:     return (ret);

	mov	eax, ebx
	pop	edi

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@xmlRelaxNG:

; 9946 :                 }
; 9947 :                 break;
; 9948 :             }
; 9949 : 
; 9950 :             ret = xmlRelaxNGElementMatch(ctxt, define, node);

	push	edi
	push	eax
	push	esi
	call	_xmlRelaxNGElementMatch
	add	esp, 12					; 0000000cH

; 9951 :             if (ret <= 0) {

	test	eax, eax
	jle	$LN444@xmlRelaxNG

; 9952 :                 ret = -1;
; 9953 :                 if ((ctxt->flags & FLAGS_IGNORABLE) == 0)
; 9954 :                     xmlRelaxNGDumpValidError(ctxt);
; 9955 :                 break;
; 9956 :             }
; 9957 :             ret = 0;
; 9958 :             if (ctxt->errNr != 0) {

	mov	ecx, DWORD PTR [esi+48]
	xor	ebx, ebx
	mov	DWORD PTR _ret$1$[ebp], ebx
	test	ecx, ecx
	je	SHORT $LN428@xmlRelaxNG

; 9959 :                 if (ctxt->errNr > errNr)

	mov	eax, DWORD PTR _errNr$1$[ebp]
	cmp	ecx, eax
	jle	SHORT $LN339@xmlRelaxNG

; 9960 :                     xmlRelaxNGPopErrors(ctxt, errNr);

	push	eax
	push	esi
	call	_xmlRelaxNGPopErrors
	add	esp, 8
$LN339@xmlRelaxNG:

; 9961 :                 while ((ctxt->err != NULL) &&

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN428@xmlRelaxNG
	npad	6
$LL8@xmlRelaxNG:
	cmp	DWORD PTR [eax], 13			; 0000000dH
	jne	SHORT $LN74@xmlRelaxNG
	push	DWORD PTR [edi+8]
	push	DWORD PTR [eax+20]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN73@xmlRelaxNG
$LN74@xmlRelaxNG:
	mov	eax, DWORD PTR [esi+44]
	cmp	DWORD PTR [eax], 19			; 00000013H
	jne	SHORT $LN75@xmlRelaxNG
	push	DWORD PTR [edi+8]
	push	DWORD PTR [eax+16]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN73@xmlRelaxNG
$LN75@xmlRelaxNG:
	mov	eax, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [eax]
	cmp	eax, 22					; 00000016H
	je	SHORT $LN73@xmlRelaxNG
	cmp	eax, 23					; 00000017H
	jne	SHORT $LN428@xmlRelaxNG
$LN73@xmlRelaxNG:

; 9962 :                        (((ctxt->err->err == XML_RELAXNG_ERR_ELEMNAME) &&
; 9963 :                          (xmlStrEqual(ctxt->err->arg2, node->name))) ||
; 9964 :                         ((ctxt->err->err == XML_RELAXNG_ERR_ELEMEXTRANS) &&
; 9965 :                          (xmlStrEqual(ctxt->err->arg1, node->name))) ||
; 9966 :                         (ctxt->err->err == XML_RELAXNG_ERR_NOELEM) ||
; 9967 :                         (ctxt->err->err == XML_RELAXNG_ERR_NOTELEM)))
; 9968 :                     xmlRelaxNGValidErrorPop(ctxt);

	push	esi
	call	_xmlRelaxNGValidErrorPop
	mov	eax, DWORD PTR [esi+44]
	add	esp, 4
	test	eax, eax
	jne	SHORT $LL8@xmlRelaxNG
$LN428@xmlRelaxNG:

; 9969 :             }
; 9970 :             errNr = ctxt->errNr;

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR _errNr$2$[ebp], eax

; 9971 : 
; 9972 :             oldflags = ctxt->flags;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR _oldflags$1$[ebp], eax

; 9973 :             if (ctxt->flags & FLAGS_MIXED_CONTENT) {

	test	al, 4
	je	SHORT $LN76@xmlRelaxNG

; 9974 :                 ctxt->flags -= FLAGS_MIXED_CONTENT;

	add	eax, -4					; fffffffcH
	mov	DWORD PTR [esi+28], eax
$LN76@xmlRelaxNG:

; 9975 :             }
; 9976 :             state = xmlRelaxNGNewValidState(ctxt, node);

	push	edi
	push	esi
	call	_xmlRelaxNGNewValidState
	add	esp, 8

; 9977 :             if (state == NULL) {

	test	eax, eax
	je	$LN444@xmlRelaxNG

; 9978 :                 ret = -1;
; 9979 :                 if ((ctxt->flags & FLAGS_IGNORABLE) == 0)
; 9980 :                     xmlRelaxNGDumpValidError(ctxt);
; 9981 :                 break;
; 9982 :             }
; 9983 : 
; 9984 :             oldstate = ctxt->state;

	mov	ecx, DWORD PTR [esi+60]
	mov	DWORD PTR _oldstate$1$[ebp], ecx

; 9985 :             ctxt->state = state;
; 9986 :             if (define->attrs != NULL) {

	mov	ecx, DWORD PTR _define$[ebp]
	mov	DWORD PTR [esi+60], eax
	mov	eax, DWORD PTR [ecx+36]
	test	eax, eax
	je	SHORT $LN80@xmlRelaxNG

; 9987 :                 tmp = xmlRelaxNGValidateAttributeList(ctxt, define->attrs);

	push	eax
	push	esi
	call	_xmlRelaxNGValidateAttributeList
	add	esp, 8

; 9988 :                 if (tmp != 0) {

	test	eax, eax
	je	SHORT $LN80@xmlRelaxNG

; 9989 :                     ret = -1;
; 9990 :                     VALID_ERR2(XML_RELAXNG_ERR_ATTRVALID, node->name);

	push	0
	push	0
	push	DWORD PTR [edi+8]
	or	ebx, -1
	push	24					; 00000018H
	push	esi
	mov	DWORD PTR _ret$1$[ebp], ebx
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H
$LN80@xmlRelaxNG:

; 9991 :                 }
; 9992 :             }
; 9993 :             if (define->contModel != NULL) {

	mov	eax, DWORD PTR _define$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	$LN81@xmlRelaxNG

; 9994 :                 xmlRelaxNGValidStatePtr nstate, tmpstate = ctxt->state;

	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR _tmpstate$1$[ebp], eax

; 9995 :                 xmlRelaxNGStatesPtr tmpstates = ctxt->states;

	mov	eax, DWORD PTR [esi+64]

; 9996 :                 xmlNodePtr nseq;
; 9997 : 
; 9998 :                 nstate = xmlRelaxNGNewValidState(ctxt, node);

	push	edi
	push	esi
	mov	DWORD PTR _tmpstates$1$[ebp], eax
	call	_xmlRelaxNGNewValidState
	mov	ebx, eax

; 9999 :                 ctxt->state = nstate;
; 10000:                 ctxt->states = NULL;

	mov	DWORD PTR [esi+64], 0

; 10001: 
; 10002:                 tmp = xmlRelaxNGValidateCompiledContent(ctxt,

	mov	eax, DWORD PTR _define$[ebp]
	mov	DWORD PTR [esi+60], ebx
	push	DWORD PTR [ebx+4]
	push	DWORD PTR [eax+52]
	push	esi
	call	_xmlRelaxNGValidateCompiledContent
	mov	edi, eax

; 10003:                                                         define->contModel,
; 10004:                                                         ctxt->state->seq);
; 10005:                 nseq = ctxt->state->seq;

	mov	eax, DWORD PTR [esi+60]

; 10006:                 ctxt->state = tmpstate;
; 10007:                 ctxt->states = tmpstates;
; 10008:                 xmlRelaxNGFreeValidState(ctxt, nstate);

	push	ebx
	push	esi
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _nseq$1$[ebp], eax
	mov	eax, DWORD PTR _tmpstate$1$[ebp]
	mov	DWORD PTR [esi+60], eax
	mov	eax, DWORD PTR _tmpstates$1$[ebp]
	mov	DWORD PTR [esi+64], eax
	call	_xmlRelaxNGFreeValidState

; 10009: 
; 10010: #ifdef DEBUG_COMPILE
; 10011:                 xmlGenericError(xmlGenericErrorContext,
; 10012:                                 "Validating content of '%s' : %d\n",
; 10013:                                 define->name, tmp);
; 10014: #endif
; 10015:                 if (tmp != 0)

	mov	ebx, DWORD PTR _ret$1$[ebp]
	or	eax, -1
	add	esp, 28					; 0000001cH
	test	edi, edi
	cmovne	ebx, eax

; 10016:                     ret = -1;
; 10017: 
; 10018:                 if (ctxt->states != NULL) {

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	$LN84@xmlRelaxNG

; 10019:                     tmp = -1;
; 10020: 
; 10021:                     for (i = 0; i < ctxt->states->nbState; i++) {

	xor	edi, edi
	mov	DWORD PTR _tmp$2$[ebp], -1
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN414@xmlRelaxNG
$LL12@xmlRelaxNG:

; 10022:                         state = ctxt->states->tabState[i];
; 10023:                         ctxt->state = state;

	mov	eax, DWORD PTR [eax+8]

; 10024:                         ctxt->state->seq = nseq;

	mov	ecx, DWORD PTR _nseq$1$[ebp]

; 10025: 
; 10026:                         if (xmlRelaxNGValidateElementEnd(ctxt, 0) == 0) {

	push	0
	push	esi
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+60], eax
	mov	DWORD PTR [eax+4], ecx
	call	_xmlRelaxNGValidateElementEnd
	add	esp, 8
	test	eax, eax
	je	$LN355@xmlRelaxNG

; 10019:                     tmp = -1;
; 10020: 
; 10021:                     for (i = 0; i < ctxt->states->nbState; i++) {

	mov	eax, DWORD PTR [esi+64]
	inc	edi
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL12@xmlRelaxNG
$LN414@xmlRelaxNG:

; 10032:                         /*
; 10033:                          * validation error, log the message for the "best" one
; 10034:                          */
; 10035:                         ctxt->flags |= FLAGS_IGNORABLE;

	or	DWORD PTR [esi+28], 1

; 10036:                         xmlRelaxNGLogBestError(ctxt);

	push	esi
	call	_xmlRelaxNGLogBestError
	add	esp, 4
$LN87@xmlRelaxNG:

; 10037:                     }
; 10038:                     for (i = 0; i < ctxt->states->nbState; i++) {

	mov	eax, DWORD PTR [esi+64]
	xor	edi, edi
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN14@xmlRelaxNG
$LL15@xmlRelaxNG:

; 10039:                         xmlRelaxNGFreeValidState(ctxt,

	mov	eax, DWORD PTR [esi+64]
	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [eax+edi*4]
	push	esi
	call	_xmlRelaxNGFreeValidState
	mov	eax, DWORD PTR [esi+64]
	inc	edi
	add	esp, 8
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL15@xmlRelaxNG
$LN14@xmlRelaxNG:

; 10040:                                                  ctxt->states->
; 10041:                                                  tabState[i]);
; 10042:                     }
; 10043:                     xmlRelaxNGFreeStates(ctxt, ctxt->states);

	push	eax
	push	esi
	call	_xmlRelaxNGFreeStates
	add	esp, 8

; 10044:                     ctxt->flags = oldflags;
; 10045:                     ctxt->states = NULL;

	mov	DWORD PTR [esi+64], 0

; 10046:                     if ((ret == 0) && (tmp == -1))

	test	ebx, ebx
	jne	SHORT $LN433@xmlRelaxNG
	cmp	DWORD PTR _tmp$2$[ebp], -1
$LN439@xmlRelaxNG:

; 10113:             }
; 10114:             ctxt->flags = oldflags;

	jne	$LN426@xmlRelaxNG
	or	ebx, -1
$LN433@xmlRelaxNG:
	mov	eax, DWORD PTR _node$1$[ebp]
$LN101@xmlRelaxNG:

; 10115:             ctxt->state = oldstate;

	mov	edi, DWORD PTR _oldstate$1$[ebp]
	mov	ecx, DWORD PTR _oldflags$1$[ebp]
	mov	DWORD PTR [esi+28], ecx
	mov	DWORD PTR [esi+60], edi

; 10116:             if (oldstate != NULL)

	test	edi, edi
	je	SHORT $LN102@xmlRelaxNG

; 10117:                 oldstate->seq = xmlRelaxNGSkipIgnored(ctxt, node->next);

	push	DWORD PTR [eax+24]
	push	esi
	call	_xmlRelaxNGSkipIgnored
	add	esp, 8
	mov	DWORD PTR [edi+4], eax
$LN102@xmlRelaxNG:

; 10118:             if (ret != 0) {

	test	ebx, ebx
	je	$LN103@xmlRelaxNG

; 10119:                 if ((ctxt->flags & FLAGS_IGNORABLE) == 0) {

	mov	edi, DWORD PTR [esi+28]
	and	edi, 1
	jne	SHORT $LN105@xmlRelaxNG

; 10120:                     xmlRelaxNGDumpValidError(ctxt);

	push	esi
	call	_xmlRelaxNGDumpValidError
	add	esp, 4
$LN105@xmlRelaxNG:

; 10121:                     ret = 0;
; 10122: #if 0
; 10123:                 } else {
; 10124:                     ret = -2;
; 10125: #endif
; 10126:                 }
; 10127:             } else {

	xor	eax, eax
	test	edi, edi
	pop	edi
	cmovne	eax, ebx

; 10602:             break;
; 10603:     }
; 10604:     ctxt->depth--;

	dec	DWORD PTR [esi+32]
	mov	ebx, eax

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN355@xmlRelaxNG:

; 10027:                             tmp = 0;

	mov	DWORD PTR _tmp$2$[ebp], 0

; 10028:                             break;
; 10029:                         }
; 10030:                     }
; 10031:                     if (tmp != 0) {

	jmp	$LN87@xmlRelaxNG
$LN84@xmlRelaxNG:

; 10047:                         ret = -1;
; 10048:                 } else {
; 10049:                     state = ctxt->state;

	mov	edi, DWORD PTR [esi+60]

; 10050: 		    if (ctxt->state != NULL)

	test	edi, edi
	je	$LN89@xmlRelaxNG

; 10051: 			ctxt->state->seq = nseq;

	mov	eax, DWORD PTR _nseq$1$[ebp]
	mov	DWORD PTR [edi+4], eax

; 10052:                     if (ret == 0)
; 10053:                         ret = xmlRelaxNGValidateElementEnd(ctxt, 1);
; 10054:                     xmlRelaxNGFreeValidState(ctxt, state);
; 10055:                 }
; 10056:             } else {

	jmp	$LN89@xmlRelaxNG
$LN81@xmlRelaxNG:

; 10057:                 if (define->content != NULL) {

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	je	SHORT $LN94@xmlRelaxNG

; 10058:                     tmp = xmlRelaxNGValidateDefinitionList(ctxt,

	push	eax
	push	esi
	call	_xmlRelaxNGValidateDefinitionList
	add	esp, 8

; 10059:                                                            define->
; 10060:                                                            content);
; 10061:                     if (tmp != 0) {

	test	eax, eax
	je	SHORT $LN94@xmlRelaxNG

; 10062:                         ret = -1;

	or	ebx, -1

; 10063:                         if (ctxt->state == NULL) {

	cmp	DWORD PTR [esi+60], 0
	push	0
	push	0
	jne	SHORT $LN93@xmlRelaxNG

; 10064:                             ctxt->state = oldstate;

	mov	eax, DWORD PTR _oldstate$1$[ebp]
	mov	DWORD PTR [esi+60], eax

; 10065:                             VALID_ERR2(XML_RELAXNG_ERR_CONTENTVALID,

	push	DWORD PTR [edi+8]
	push	25					; 00000019H
	push	esi
	call	_xmlRelaxNGAddValidError

; 10066:                                        node->name);
; 10067:                             ctxt->state = NULL;

	mov	DWORD PTR [esi+60], 0

; 10068:                         } else {

	jmp	SHORT $LN437@xmlRelaxNG
$LN93@xmlRelaxNG:

; 10069:                             VALID_ERR2(XML_RELAXNG_ERR_CONTENTVALID,

	push	DWORD PTR [edi+8]
	push	25					; 00000019H
	push	esi
	call	_xmlRelaxNGAddValidError
$LN437@xmlRelaxNG:

; 10070:                                        node->name);
; 10071:                         }
; 10072: 
; 10073:                     }
; 10074:                 }
; 10075:                 if (ctxt->states != NULL) {

	add	esp, 20					; 00000014H
$LN94@xmlRelaxNG:
	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	$LN95@xmlRelaxNG

; 10076:                     tmp = -1;
; 10077: 
; 10078:                     for (i = 0; i < ctxt->states->nbState; i++) {

	xor	edi, edi
	mov	DWORD PTR _tmp$3$[ebp], -1
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN415@xmlRelaxNG
	npad	2
$LL18@xmlRelaxNG:

; 10079:                         state = ctxt->states->tabState[i];
; 10080:                         ctxt->state = state;

	mov	eax, DWORD PTR [eax+8]

; 10081: 
; 10082:                         if (xmlRelaxNGValidateElementEnd(ctxt, 0) == 0) {

	push	0
	push	esi
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+60], eax
	call	_xmlRelaxNGValidateElementEnd
	add	esp, 8
	test	eax, eax
	je	SHORT $LN356@xmlRelaxNG

; 10076:                     tmp = -1;
; 10077: 
; 10078:                     for (i = 0; i < ctxt->states->nbState; i++) {

	mov	eax, DWORD PTR [esi+64]
	inc	edi
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL18@xmlRelaxNG
$LN415@xmlRelaxNG:

; 10088:                         /*
; 10089:                          * validation error, log the message for the "best" one
; 10090:                          */
; 10091:                         ctxt->flags |= FLAGS_IGNORABLE;

	or	DWORD PTR [esi+28], 1

; 10092:                         xmlRelaxNGLogBestError(ctxt);

	push	esi
	call	_xmlRelaxNGLogBestError
	add	esp, 4
$LN98@xmlRelaxNG:

; 10093:                     }
; 10094:                     for (i = 0; i < ctxt->states->nbState; i++) {

	mov	eax, DWORD PTR [esi+64]
	xor	edi, edi
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN20@xmlRelaxNG
$LL21@xmlRelaxNG:

; 10095:                         xmlRelaxNGFreeValidState(ctxt,

	mov	eax, DWORD PTR [esi+64]
	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [eax+edi*4]
	push	esi
	call	_xmlRelaxNGFreeValidState

; 10096:                                                  ctxt->states->tabState[i]);
; 10097:                         ctxt->states->tabState[i] = NULL;

	mov	eax, DWORD PTR [esi+64]
	add	esp, 8
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+edi*4], 0
	inc	edi
	mov	eax, DWORD PTR [esi+64]
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL21@xmlRelaxNG
$LN20@xmlRelaxNG:

; 10098:                     }
; 10099:                     xmlRelaxNGFreeStates(ctxt, ctxt->states);

	push	eax
	push	esi
	call	_xmlRelaxNGFreeStates
	add	esp, 8

; 10100:                     ctxt->flags = oldflags;
; 10101:                     ctxt->states = NULL;

	mov	DWORD PTR [esi+64], 0

; 10102:                     if ((ret == 0) && (tmp == -1))

	test	ebx, ebx
	jne	$LN433@xmlRelaxNG
	cmp	DWORD PTR _tmp$3$[ebp], -1

; 10103:                         ret = -1;
; 10104:                 } else {

	jmp	$LN439@xmlRelaxNG
$LN356@xmlRelaxNG:

; 10083:                             tmp = 0;

	mov	DWORD PTR _tmp$3$[ebp], 0

; 10084:                             break;
; 10085:                         }
; 10086:                     }
; 10087:                     if (tmp != 0) {

	jmp	SHORT $LN98@xmlRelaxNG
$LN95@xmlRelaxNG:

; 10105:                     state = ctxt->state;

	mov	edi, DWORD PTR [esi+60]
$LN89@xmlRelaxNG:

; 10106:                     if (ret == 0)
; 10107:                         ret = xmlRelaxNGValidateElementEnd(ctxt, 1);
; 10108:                     xmlRelaxNGFreeValidState(ctxt, state);
; 10109:                 }
; 10110:             }
; 10111:             if (ret == 0) {

	test	ebx, ebx
	jne	SHORT $LN100@xmlRelaxNG
	push	1
	push	esi
	call	_xmlRelaxNGValidateElementEnd
	mov	ebx, eax
	add	esp, 8
$LN100@xmlRelaxNG:
	push	edi
	push	esi
	call	_xmlRelaxNGFreeValidState
	add	esp, 8
	test	ebx, ebx
	jne	$LN433@xmlRelaxNG
$LN426@xmlRelaxNG:

; 10112:                 node->psvi = define;

	mov	eax, DWORD PTR _node$1$[ebp]
	mov	ecx, DWORD PTR _define$[ebp]
	mov	DWORD PTR [eax+52], ecx
	jmp	$LN101@xmlRelaxNG
$LN103@xmlRelaxNG:

; 10128:                 if (ctxt->errNr > errNr)

	mov	eax, DWORD PTR _errNr$2$[ebp]
$LN447@xmlRelaxNG:

; 10602:             break;
; 10603:     }
; 10604:     ctxt->depth--;

	cmp	DWORD PTR [esi+48], eax
	jle	$LN2@xmlRelaxNG
	push	eax
	push	esi
	call	_xmlRelaxNGPopErrors
	add	esp, 8

; 10605: #ifdef DEBUG
; 10606:     for (i = 0; i < ctxt->depth; i++)
; 10607:         xmlGenericError(xmlGenericErrorContext, " ");
; 10608:     xmlGenericError(xmlGenericErrorContext,
; 10609:                     "Validating %s ", xmlRelaxNGDefName(define));
; 10610:     if (define->name != NULL)
; 10611:         xmlGenericError(xmlGenericErrorContext, "%s ", define->name);
; 10612:     if (ret == 0)
; 10613:         xmlGenericError(xmlGenericErrorContext, "suceeded\n");
; 10614:     else
; 10615:         xmlGenericError(xmlGenericErrorContext, "failed\n");
; 10616: #endif
; 10617:     return (ret);

	mov	eax, ebx
	dec	DWORD PTR [esi+32]
	pop	edi

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN107@xmlRelaxNG:

; 10129:                     xmlRelaxNGPopErrors(ctxt, errNr);
; 10130:             }
; 10131: 
; 10132: #ifdef DEBUG
; 10133:             xmlGenericError(xmlGenericErrorContext,
; 10134:                             "xmlRelaxNGValidateDefinition(): validated %s : %d",
; 10135:                             node->name, ret);
; 10136:             if (oldstate == NULL)
; 10137:                 xmlGenericError(xmlGenericErrorContext, ": no state\n");
; 10138:             else if (oldstate->seq == NULL)
; 10139:                 xmlGenericError(xmlGenericErrorContext, ": done\n");
; 10140:             else if (oldstate->seq->type == XML_ELEMENT_NODE)
; 10141:                 xmlGenericError(xmlGenericErrorContext, ": next elem %s\n",
; 10142:                                 oldstate->seq->name);
; 10143:             else
; 10144:                 xmlGenericError(xmlGenericErrorContext, ": next %s %d\n",
; 10145:                                 oldstate->seq->name, oldstate->seq->type);
; 10146: #endif
; 10147:             break;
; 10148:         case XML_RELAXNG_OPTIONAL:{
; 10149:                 errNr = ctxt->errNr;
; 10150:                 oldflags = ctxt->flags;

	mov	eax, DWORD PTR [esi+28]
	mov	edi, DWORD PTR [esi+48]
	mov	DWORD PTR _oldflags$2$[ebp], eax

; 10151:                 ctxt->flags |= FLAGS_IGNORABLE;

	or	eax, 1

; 10152:                 oldstate = xmlRelaxNGCopyValidState(ctxt, ctxt->state);

	push	edx
	push	esi
	mov	DWORD PTR [esi+28], eax
	call	_xmlRelaxNGCopyValidState
	mov	ebx, eax

; 10153:                 ret =

	mov	eax, DWORD PTR _define$[ebp]
	push	DWORD PTR [eax+24]
	push	esi
	call	_xmlRelaxNGValidateDefinitionList
	add	esp, 16					; 00000010H

; 10154:                     xmlRelaxNGValidateDefinitionList(ctxt,
; 10155:                                                      define->content);
; 10156:                 if (ret != 0) {

	test	eax, eax
	je	SHORT $LN108@xmlRelaxNG

; 10157:                     if (ctxt->state != NULL)

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN109@xmlRelaxNG

; 10158:                         xmlRelaxNGFreeValidState(ctxt, ctxt->state);

	push	eax
	push	esi
	call	_xmlRelaxNGFreeValidState
	add	esp, 8
$LN109@xmlRelaxNG:

; 10159:                     ctxt->state = oldstate;

	mov	DWORD PTR [esi+60], ebx
$LN112@xmlRelaxNG:

; 10602:             break;
; 10603:     }
; 10604:     ctxt->depth--;

	xor	ebx, ebx
$LN452@xmlRelaxNG:
	mov	eax, DWORD PTR _oldflags$2$[ebp]
	mov	DWORD PTR [esi+28], eax
	cmp	DWORD PTR [esi+48], edi
	jle	$LN2@xmlRelaxNG
	push	edi
	push	esi
	call	_xmlRelaxNGPopErrors
	add	esp, 8

; 10605: #ifdef DEBUG
; 10606:     for (i = 0; i < ctxt->depth; i++)
; 10607:         xmlGenericError(xmlGenericErrorContext, " ");
; 10608:     xmlGenericError(xmlGenericErrorContext,
; 10609:                     "Validating %s ", xmlRelaxNGDefName(define));
; 10610:     if (define->name != NULL)
; 10611:         xmlGenericError(xmlGenericErrorContext, "%s ", define->name);
; 10612:     if (ret == 0)
; 10613:         xmlGenericError(xmlGenericErrorContext, "suceeded\n");
; 10614:     else
; 10615:         xmlGenericError(xmlGenericErrorContext, "failed\n");
; 10616: #endif
; 10617:     return (ret);

	mov	eax, ebx
	dec	DWORD PTR [esi+32]
	pop	edi

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN108@xmlRelaxNG:

; 10160:                     ctxt->flags = oldflags;
; 10161:                     ret = 0;
; 10162:                     if (ctxt->errNr > errNr)
; 10163:                         xmlRelaxNGPopErrors(ctxt, errNr);
; 10164:                     break;
; 10165:                 }
; 10166:                 if (ctxt->states != NULL) {

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN111@xmlRelaxNG

; 10167:                     xmlRelaxNGAddStates(ctxt, ctxt->states, oldstate);

	push	ebx
	push	eax
	push	esi
	call	_xmlRelaxNGAddStates
	add	esp, 12					; 0000000cH

; 10168:                 } else {

	jmp	SHORT $LN112@xmlRelaxNG
$LN111@xmlRelaxNG:

; 10169:                     ctxt->states = xmlRelaxNGNewStates(ctxt, 1);

	push	1
	push	esi
	call	_xmlRelaxNGNewStates
	add	esp, 8
	mov	DWORD PTR [esi+64], eax

; 10170:                     if (ctxt->states == NULL) {

	push	ebx
	test	eax, eax
	jne	SHORT $LN113@xmlRelaxNG

; 10171:                         xmlRelaxNGFreeValidState(ctxt, oldstate);

	push	esi
	call	_xmlRelaxNGFreeValidState
	add	esp, 8

; 10172:                         ctxt->flags = oldflags;
; 10173:                         ret = -1;

	or	ebx, -1

; 10174:                         if (ctxt->errNr > errNr)
; 10175:                             xmlRelaxNGPopErrors(ctxt, errNr);
; 10176:                         break;

	jmp	SHORT $LN452@xmlRelaxNG
$LN113@xmlRelaxNG:

; 10177:                     }
; 10178:                     xmlRelaxNGAddStates(ctxt, ctxt->states, oldstate);

	push	eax
	push	esi
	call	_xmlRelaxNGAddStates

; 10179:                     xmlRelaxNGAddStates(ctxt, ctxt->states, ctxt->state);

	push	DWORD PTR [esi+60]
	push	DWORD PTR [esi+64]
	push	esi
	call	_xmlRelaxNGAddStates
	add	esp, 24					; 00000018H

; 10180:                     ctxt->state = NULL;

	mov	DWORD PTR [esi+60], 0

; 10181:                 }
; 10182:                 ctxt->flags = oldflags;
; 10183:                 ret = 0;
; 10184:                 if (ctxt->errNr > errNr)
; 10185:                     xmlRelaxNGPopErrors(ctxt, errNr);
; 10186:                 break;

	jmp	SHORT $LN112@xmlRelaxNG
$LN116@xmlRelaxNG:

; 10187:             }
; 10188:         case XML_RELAXNG_ONEORMORE:
; 10189:             errNr = ctxt->errNr;
; 10190:             ret = xmlRelaxNGValidateDefinitionList(ctxt, define->content);

	mov	eax, DWORD PTR _define$[ebp]
	mov	edi, DWORD PTR [esi+48]
	push	DWORD PTR [eax+24]
	push	esi
	call	_xmlRelaxNGValidateDefinitionList
	mov	ebx, eax
	add	esp, 8

; 10191:             if (ret != 0) {

	test	ebx, ebx
	jne	$LN2@xmlRelaxNG

; 10192:                 break;
; 10193:             }
; 10194:             if (ctxt->errNr > errNr)

	cmp	DWORD PTR [esi+48], edi
	jle	SHORT $LN118@xmlRelaxNG

; 10195:                 xmlRelaxNGPopErrors(ctxt, errNr);

	push	edi
	push	esi
	call	_xmlRelaxNGPopErrors
	add	esp, 8
$LN118@xmlRelaxNG:

; 10196:             /* Falls through. */
; 10197:         case XML_RELAXNG_ZEROORMORE:{
; 10198:                 int progress;
; 10199:                 xmlRelaxNGStatesPtr states = NULL, res = NULL;
; 10200:                 int base, j;
; 10201: 
; 10202:                 errNr = ctxt->errNr;
; 10203:                 res = xmlRelaxNGNewStates(ctxt, 1);

	push	1
	push	esi
	mov	DWORD PTR _states$1$[ebp], 0
	call	_xmlRelaxNGNewStates
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _res$1$[ebp], ebx

; 10204:                 if (res == NULL) {

	test	ebx, ebx
	je	$LN55@xmlRelaxNG

; 10205:                     ret = -1;
; 10206:                     break;
; 10207:                 }
; 10208:                 /*
; 10209:                  * All the input states are also exit states
; 10210:                  */
; 10211:                 if (ctxt->state != NULL) {

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN121@xmlRelaxNG

; 10212:                     xmlRelaxNGAddStates(ctxt, res,

	push	eax
	push	esi
	call	_xmlRelaxNGCopyValidState
	push	eax
	push	ebx
	push	esi
	call	_xmlRelaxNGAddStates
	add	esp, 20					; 00000014H

; 10213:                                         xmlRelaxNGCopyValidState(ctxt,
; 10214:                                                                  ctxt->
; 10215:                                                                  state));
; 10216:                 } else {

	jmp	SHORT $LN23@xmlRelaxNG
$LN121@xmlRelaxNG:

; 10217:                     for (j = 0; j < ctxt->states->nbState; j++) {

	mov	eax, DWORD PTR [esi+64]
	xor	edi, edi
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN23@xmlRelaxNG
$LL24@xmlRelaxNG:

; 10218:                         xmlRelaxNGAddStates(ctxt, res,

	mov	eax, DWORD PTR [esi+64]
	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [eax+edi*4]
	push	esi
	call	_xmlRelaxNGCopyValidState
	push	eax
	push	ebx
	push	esi
	call	_xmlRelaxNGAddStates
	mov	eax, DWORD PTR [esi+64]
	inc	edi
	add	esp, 20					; 00000014H
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL24@xmlRelaxNG
$LN23@xmlRelaxNG:

; 10219:                             xmlRelaxNGCopyValidState(ctxt,
; 10220:                                             ctxt->states->tabState[j]));
; 10221:                     }
; 10222:                 }
; 10223:                 oldflags = ctxt->flags;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR _oldflags$3$[ebp], eax

; 10224:                 ctxt->flags |= FLAGS_IGNORABLE;

	or	eax, 1
	mov	DWORD PTR [esi+28], eax
$LL27@xmlRelaxNG:

; 10225:                 do {
; 10226:                     progress = 0;
; 10227:                     base = res->nbState;

	mov	eax, DWORD PTR [ebx]
	xor	edi, edi
	mov	DWORD PTR _i$6$[ebp], eax

; 10228: 
; 10229:                     if (ctxt->states != NULL) {

	mov	eax, DWORD PTR [esi+64]
	mov	DWORD PTR _progress$1$[ebp], edi
	test	eax, eax
	je	$LN123@xmlRelaxNG

; 10230:                         states = ctxt->states;
; 10231:                         for (i = 0; i < states->nbState; i++) {

	xor	ecx, ecx
	mov	DWORD PTR _states$1$[ebp], eax
	mov	DWORD PTR _i$5$[ebp], ecx
	cmp	DWORD PTR [eax], ecx
	jle	$LN416@xmlRelaxNG
	npad	7
$LL30@xmlRelaxNG:

; 10232:                             ctxt->state = states->tabState[i];

	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+60], eax

; 10233:                             ctxt->states = NULL;
; 10234:                             ret = xmlRelaxNGValidateDefinitionList(ctxt,

	mov	eax, DWORD PTR _define$[ebp]
	mov	DWORD PTR [esi+64], 0
	push	DWORD PTR [eax+24]
	push	esi
	call	_xmlRelaxNGValidateDefinitionList
	mov	ecx, DWORD PTR [esi+60]
	add	esp, 8

; 10235:                                                                    define->
; 10236:                                                                    content);
; 10237:                             if (ret == 0) {

	test	eax, eax
	jne	SHORT $LN125@xmlRelaxNG

; 10238:                                 if (ctxt->state != NULL) {

	test	ecx, ecx
	je	SHORT $LN127@xmlRelaxNG

; 10239:                                     tmp = xmlRelaxNGAddStates(ctxt, res,

	push	ecx
	push	ebx
	push	esi
	call	_xmlRelaxNGAddStates
	add	esp, 12					; 0000000cH

; 10240:                                                               ctxt->state);
; 10241:                                     ctxt->state = NULL;

	mov	DWORD PTR [esi+60], 0

; 10242:                                     if (tmp == 1)

	cmp	eax, 1
	jne	SHORT $LN28@xmlRelaxNG

; 10243:                                         progress = 1;

	mov	edi, eax

; 10244:                                 } else if (ctxt->states != NULL) {

	jmp	SHORT $LN28@xmlRelaxNG
$LN127@xmlRelaxNG:
	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN28@xmlRelaxNG

; 10245:                                     for (j = 0; j < ctxt->states->nbState;

	xor	ebx, ebx
	cmp	DWORD PTR [eax], ebx
	jle	SHORT $LN32@xmlRelaxNG
$LL33@xmlRelaxNG:

; 10246:                                          j++) {
; 10247:                                         tmp =

	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [eax+ebx*4]
	push	DWORD PTR _res$1$[ebp]
	push	esi
	call	_xmlRelaxNGAddStates
	add	esp, 12					; 0000000cH

; 10248:                                             xmlRelaxNGAddStates(ctxt, res,
; 10249:                                                    ctxt->states->tabState[j]);
; 10250:                                         if (tmp == 1)

	cmp	eax, 1
	mov	eax, 1
	cmove	edi, eax
	mov	eax, DWORD PTR [esi+64]
	inc	ebx
	cmp	ebx, DWORD PTR [eax]
	jl	SHORT $LL33@xmlRelaxNG
$LN32@xmlRelaxNG:

; 10251:                                             progress = 1;
; 10252:                                     }
; 10253:                                     xmlRelaxNGFreeStates(ctxt,

	push	eax
	push	esi
	call	_xmlRelaxNGFreeStates

; 10254:                                                          ctxt->states);
; 10255:                                     ctxt->states = NULL;
; 10256:                                 }
; 10257:                             } else {

	mov	ebx, DWORD PTR _res$1$[ebp]
	mov	DWORD PTR [esi+64], 0
	jmp	SHORT $LN440@xmlRelaxNG
$LN125@xmlRelaxNG:

; 10258:                                 if (ctxt->state != NULL) {

	test	ecx, ecx
	je	SHORT $LN28@xmlRelaxNG

; 10259:                                     xmlRelaxNGFreeValidState(ctxt,

	push	ecx
	push	esi
	call	_xmlRelaxNGFreeValidState

; 10260:                                                              ctxt->state);
; 10261:                                     ctxt->state = NULL;

	mov	DWORD PTR [esi+60], 0
$LN440@xmlRelaxNG:

; 10230:                         states = ctxt->states;
; 10231:                         for (i = 0; i < states->nbState; i++) {

	add	esp, 8
$LN28@xmlRelaxNG:
	mov	ecx, DWORD PTR _i$5$[ebp]
	mov	eax, DWORD PTR _states$1$[ebp]
	inc	ecx
	mov	DWORD PTR _i$5$[ebp], ecx
	cmp	ecx, DWORD PTR [eax]
	jl	$LL30@xmlRelaxNG

; 10262:                                 }
; 10263:                             }
; 10264:                         }
; 10265:                     } else {

	mov	DWORD PTR _progress$1$[ebp], edi
	jmp	$LN138@xmlRelaxNG
$LN123@xmlRelaxNG:

; 10266:                         ret = xmlRelaxNGValidateDefinitionList(ctxt,

	mov	eax, DWORD PTR _define$[ebp]
	push	DWORD PTR [eax+24]
	push	esi
	call	_xmlRelaxNGValidateDefinitionList
	add	esp, 8

; 10267:                                                                define->
; 10268:                                                                content);
; 10269:                         if (ret != 0) {

	test	eax, eax
	jne	$LN425@xmlRelaxNG

; 10272:                         } else {
; 10273:                             base = res->nbState;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR _i$6$[ebp], eax

; 10274:                             if (ctxt->state != NULL) {

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN135@xmlRelaxNG

; 10275:                                 tmp = xmlRelaxNGAddStates(ctxt, res,

	push	eax
	push	ebx
	push	esi
	call	_xmlRelaxNGAddStates
	add	esp, 12					; 0000000cH

; 10276:                                                           ctxt->state);
; 10277:                                 ctxt->state = NULL;

	mov	DWORD PTR [esi+60], edi

; 10278:                                 if (tmp == 1)

	cmp	eax, 1
	jne	$LN430@xmlRelaxNG

; 10279:                                     progress = 1;

	mov	edi, eax
	mov	DWORD PTR _progress$1$[ebp], edi

; 10280:                             } else if (ctxt->states != NULL) {

	jmp	SHORT $LN417@xmlRelaxNG
$LN135@xmlRelaxNG:
	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	$LN430@xmlRelaxNG

; 10281:                                 for (j = 0; j < ctxt->states->nbState; j++) {

	xor	ecx, ecx
	mov	DWORD PTR _j$3$[ebp], ecx
	cmp	DWORD PTR [eax], ecx
	jle	SHORT $LN35@xmlRelaxNG
	npad	2
$LL36@xmlRelaxNG:

; 10282:                                     tmp = xmlRelaxNGAddStates(ctxt, res,

	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [eax+ecx*4]
	push	ebx
	push	esi
	call	_xmlRelaxNGAddStates
	mov	ecx, DWORD PTR _j$3$[ebp]
	add	esp, 12					; 0000000cH

; 10283:                                                ctxt->states->tabState[j]);
; 10284:                                     if (tmp == 1)

	cmp	eax, 1
	mov	eax, 1
	cmove	edi, eax
	mov	eax, DWORD PTR [esi+64]
	inc	ecx
	mov	DWORD PTR _j$3$[ebp], ecx
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LL36@xmlRelaxNG
	mov	DWORD PTR _progress$1$[ebp], edi
$LN35@xmlRelaxNG:

; 10285:                                         progress = 1;
; 10286:                                 }
; 10287:                                 if (states == NULL) {

	cmp	DWORD PTR _states$1$[ebp], 0
	jne	SHORT $LN140@xmlRelaxNG

; 10288:                                     states = ctxt->states;

	mov	DWORD PTR _states$1$[ebp], eax

; 10289:                                 } else {

	jmp	SHORT $LN141@xmlRelaxNG
$LN140@xmlRelaxNG:

; 10290:                                     xmlRelaxNGFreeStates(ctxt,

	push	eax
	push	esi
	call	_xmlRelaxNGFreeStates
	mov	eax, DWORD PTR _states$1$[ebp]
	add	esp, 8
$LN141@xmlRelaxNG:

; 10291:                                                          ctxt->states);
; 10292:                                 }
; 10293:                                 ctxt->states = NULL;

	mov	DWORD PTR [esi+64], 0
$LN138@xmlRelaxNG:

; 10294:                             }
; 10295:                         }
; 10296:                     }
; 10297:                     if (progress) {

	test	edi, edi
	je	SHORT $LN25@xmlRelaxNG
$LN417@xmlRelaxNG:

; 10298:                         /*
; 10299:                          * Collect all the new nodes added at that step
; 10300:                          * and make them the new node set
; 10301:                          */
; 10302:                         if (res->nbState - base == 1) {

	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR _i$6$[ebp]
	sub	edx, ecx
	cmp	edx, 1
	jne	SHORT $LN143@xmlRelaxNG

; 10303:                             ctxt->state = xmlRelaxNGCopyValidState(ctxt,

	mov	eax, DWORD PTR [ebx+8]
	push	DWORD PTR [eax+ecx*4]
	push	esi
	call	_xmlRelaxNGCopyValidState
	mov	DWORD PTR [esi+60], eax
	add	esp, 8

; 10304:                                                                    res->
; 10305:                                                                    tabState
; 10306:                                                                    [base]);
; 10307:                         } else {

	mov	eax, DWORD PTR _states$1$[ebp]
	jmp	SHORT $LN25@xmlRelaxNG
$LN143@xmlRelaxNG:

; 10308:                             if (states == NULL) {

	mov	eax, DWORD PTR _states$1$[ebp]
	test	eax, eax
	jne	SHORT $LN146@xmlRelaxNG

; 10309:                                 xmlRelaxNGNewStates(ctxt,

	push	edx
	push	esi
	call	_xmlRelaxNGNewStates

; 10310:                                                     res->nbState - base);
; 10311: 			        states = ctxt->states;

	mov	eax, DWORD PTR [esi+64]
	add	esp, 8
	mov	DWORD PTR _states$1$[ebp], eax

; 10312: 				if (states == NULL) {

	test	eax, eax
	je	SHORT $LN147@xmlRelaxNG
	mov	ecx, DWORD PTR _i$6$[ebp]
$LN146@xmlRelaxNG:

; 10313: 				    progress = 0;
; 10314: 				    break;
; 10315: 				}
; 10316:                             }
; 10317:                             states->nbState = 0;

	mov	DWORD PTR [eax], 0

; 10318:                             for (i = base; i < res->nbState; i++)

	cmp	ecx, DWORD PTR [ebx]
	jge	SHORT $LN38@xmlRelaxNG
	mov	edi, DWORD PTR _states$1$[ebp]
	npad	3
$LL39@xmlRelaxNG:

; 10319:                                 xmlRelaxNGAddStates(ctxt, states,

	mov	eax, DWORD PTR [ebx+8]
	push	DWORD PTR [eax+ecx*4]
	push	esi
	call	_xmlRelaxNGCopyValidState
	push	eax
	push	edi
	push	esi
	call	_xmlRelaxNGAddStates
	mov	ecx, DWORD PTR _i$6$[ebp]
	add	esp, 20					; 00000014H
	inc	ecx
	mov	DWORD PTR _i$6$[ebp], ecx
	cmp	ecx, DWORD PTR [ebx]
	jl	SHORT $LL39@xmlRelaxNG
	mov	edi, DWORD PTR _progress$1$[ebp]
	mov	eax, DWORD PTR _states$1$[ebp]
$LN38@xmlRelaxNG:

; 10320:                                                     xmlRelaxNGCopyValidState
; 10321:                                                     (ctxt, res->tabState[i]));
; 10322:                             ctxt->states = states;

	mov	DWORD PTR [esi+64], eax
$LN25@xmlRelaxNG:

; 10323:                         }
; 10324:                     }
; 10325:                 } while (progress == 1);

	cmp	edi, 1
	je	$LL27@xmlRelaxNG
	jmp	SHORT $LN416@xmlRelaxNG
$LN425@xmlRelaxNG:

; 10270:                             xmlRelaxNGFreeValidState(ctxt, ctxt->state);

	push	DWORD PTR [esi+60]
	push	esi
	call	_xmlRelaxNGFreeValidState
	add	esp, 8

; 10271:                             ctxt->state = NULL;

	mov	DWORD PTR [esi+60], edi
$LN430@xmlRelaxNG:

; 10326:                 if (states != NULL) {

	mov	eax, DWORD PTR _states$1$[ebp]
$LN416@xmlRelaxNG:
	test	eax, eax
	je	SHORT $LN147@xmlRelaxNG

; 10327:                     xmlRelaxNGFreeStates(ctxt, states);

	push	eax
	push	esi
	call	_xmlRelaxNGFreeStates
	add	esp, 8
$LN147@xmlRelaxNG:

; 10328:                 }
; 10329:                 ctxt->states = res;
; 10330:                 ctxt->flags = oldflags;

	mov	eax, DWORD PTR _oldflags$3$[ebp]
	mov	DWORD PTR [esi+64], ebx

; 10331: #if 0
; 10332:                 /*
; 10333:                  * errors may have to be propagated back...
; 10334:                  */
; 10335:                 if (ctxt->errNr > errNr)
; 10336:                     xmlRelaxNGPopErrors(ctxt, errNr);
; 10337: #endif
; 10338:                 ret = 0;

	xor	ebx, ebx

; 10602:             break;
; 10603:     }
; 10604:     ctxt->depth--;

	dec	DWORD PTR [esi+32]
	pop	edi
	mov	DWORD PTR [esi+28], eax

; 10605: #ifdef DEBUG
; 10606:     for (i = 0; i < ctxt->depth; i++)
; 10607:         xmlGenericError(xmlGenericErrorContext, " ");
; 10608:     xmlGenericError(xmlGenericErrorContext,
; 10609:                     "Validating %s ", xmlRelaxNGDefName(define));
; 10610:     if (define->name != NULL)
; 10611:         xmlGenericError(xmlGenericErrorContext, "%s ", define->name);
; 10612:     if (ret == 0)
; 10613:         xmlGenericError(xmlGenericErrorContext, "suceeded\n");
; 10614:     else
; 10615:         xmlGenericError(xmlGenericErrorContext, "failed\n");
; 10616: #endif
; 10617:     return (ret);

	mov	eax, ebx

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN148@xmlRelaxNG:

; 10339:                 break;
; 10340:             }
; 10341:         case XML_RELAXNG_CHOICE:{
; 10342:                 xmlRelaxNGDefinePtr list = NULL;
; 10343:                 xmlRelaxNGStatesPtr states = NULL;
; 10344: 
; 10345:                 node = xmlRelaxNGSkipIgnored(ctxt, node);

	push	ecx
	xor	edi, edi
	push	esi
	mov	DWORD PTR $T2[ebp], edi
	call	_xmlRelaxNGSkipIgnored

; 10346: 
; 10347:                 errNr = ctxt->errNr;

	mov	ecx, DWORD PTR [esi+48]
	add	esp, 8
	mov	DWORD PTR _errNr$5$[ebp], ecx

; 10348:                 if ((define->dflags & IS_TRIABLE) && (define->data != NULL) &&

	mov	ecx, DWORD PTR _define$[ebp]
	mov	DWORD PTR _node$2$[ebp], eax
	test	BYTE PTR [ecx+50], 16			; 00000010H
	je	$LN149@xmlRelaxNG
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _triage$1$[ebp], edx
	test	edx, edx
	je	$LN149@xmlRelaxNG
	test	eax, eax
	je	$LN149@xmlRelaxNG

; 10349: 		    (node != NULL)) {
; 10350: 		    /*
; 10351: 		     * node == NULL can't be optimized since IS_TRIABLE
; 10352: 		     * doesn't account for choice which may lead to
; 10353: 		     * only attributes.
; 10354: 		     */
; 10355:                     xmlHashTablePtr triage =
; 10356:                         (xmlHashTablePtr) define->data;
; 10357: 
; 10358:                     /*
; 10359:                      * Something we can optimize cleanly there is only one
; 10360:                      * possble branch out !
; 10361:                      */
; 10362:                     if ((node->type == XML_TEXT_NODE) ||

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 3
	je	SHORT $LN152@xmlRelaxNG
	cmp	ecx, 4
	je	SHORT $LN152@xmlRelaxNG

; 10365:                             xmlHashLookup2(triage, BAD_CAST "#text", NULL);
; 10366:                     } else if (node->type == XML_ELEMENT_NODE) {

	cmp	ecx, 1
	jne	SHORT $LN418@xmlRelaxNG

; 10367:                         if (node->ns != NULL) {

	mov	ecx, DWORD PTR [eax+36]
	test	ecx, ecx
	je	SHORT $LN154@xmlRelaxNG

; 10368:                             list = xmlHashLookup2(triage, node->name,

	push	DWORD PTR [ecx+8]
	push	DWORD PTR [eax+8]
	push	edx
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH

; 10369:                                                   node->ns->href);
; 10370:                             if (list == NULL)

	test	eax, eax
	jne	SHORT $LN158@xmlRelaxNG

; 10371:                                 list =

	mov	eax, DWORD PTR _node$2$[ebp]
	mov	ecx, OFFSET ??_C@_04IAJCOJMF@?$CDany@

; 10372:                                     xmlHashLookup2(triage, BAD_CAST "#any",
; 10373:                                                    node->ns->href);
; 10374:                         } else

	mov	edx, DWORD PTR _triage$1$[ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN155@xmlRelaxNG
$LN154@xmlRelaxNG:

; 10375:                             list =

	mov	ecx, DWORD PTR [eax+8]
	xor	eax, eax
$LN155@xmlRelaxNG:

; 10376:                                 xmlHashLookup2(triage, node->name, NULL);
; 10377:                         if (list == NULL)

	push	eax
	push	ecx
	push	edx
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN158@xmlRelaxNG

; 10378:                             list =

	mov	edx, DWORD PTR _triage$1$[ebp]
	mov	eax, OFFSET ??_C@_04IAJCOJMF@?$CDany@
	jmp	SHORT $LN157@xmlRelaxNG
$LN152@xmlRelaxNG:

; 10363:                         (node->type == XML_CDATA_SECTION_NODE)) {
; 10364:                         list =

	mov	eax, OFFSET ??_C@_05NOBOONOA@?$CDtext@
$LN157@xmlRelaxNG:

; 10379:                                 xmlHashLookup2(triage, BAD_CAST "#any",
; 10380:                                                NULL);
; 10381:                     }
; 10382:                     if (list == NULL) {

	push	0
	push	eax
	push	edx
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN158@xmlRelaxNG
	mov	eax, DWORD PTR _node$2$[ebp]
$LN418@xmlRelaxNG:

; 10383:                         ret = -1;
; 10384: 			VALID_ERR2(XML_RELAXNG_ERR_ELEMWRONG, node->name);

	push	0
	push	0
	push	DWORD PTR [eax+8]
	or	ebx, -1
	push	38					; 00000026H
	push	esi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 10605: #ifdef DEBUG
; 10606:     for (i = 0; i < ctxt->depth; i++)
; 10607:         xmlGenericError(xmlGenericErrorContext, " ");
; 10608:     xmlGenericError(xmlGenericErrorContext,
; 10609:                     "Validating %s ", xmlRelaxNGDefName(define));
; 10610:     if (define->name != NULL)
; 10611:         xmlGenericError(xmlGenericErrorContext, "%s ", define->name);
; 10612:     if (ret == 0)
; 10613:         xmlGenericError(xmlGenericErrorContext, "suceeded\n");
; 10614:     else
; 10615:         xmlGenericError(xmlGenericErrorContext, "failed\n");
; 10616: #endif
; 10617:     return (ret);

	mov	eax, ebx
	dec	DWORD PTR [esi+32]
	pop	edi

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN158@xmlRelaxNG:

; 10385:                         break;
; 10386:                     }
; 10387:                     ret = xmlRelaxNGValidateDefinition(ctxt, list);

	push	eax
	push	esi
	call	_xmlRelaxNGValidateDefinition
	add	esp, 8
	mov	ebx, eax

; 10602:             break;
; 10603:     }
; 10604:     ctxt->depth--;

	dec	DWORD PTR [esi+32]
	pop	edi

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN149@xmlRelaxNG:

; 10388:                     if (ret == 0) {
; 10389:                     }
; 10390:                     break;
; 10391:                 }
; 10392: 
; 10393:                 list = define->content;
; 10394:                 oldflags = ctxt->flags;

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR _oldflags$4$[ebp], eax

; 10395:                 ctxt->flags |= FLAGS_IGNORABLE;

	or	eax, 1
	mov	DWORD PTR _list$2$[ebp], ecx
	mov	DWORD PTR [esi+28], eax

; 10396: 
; 10397:                 while (list != NULL) {

	test	ecx, ecx
	je	$LN434@xmlRelaxNG

; 10312: 				if (states == NULL) {

	mov	ecx, DWORD PTR [esi+60]
$LL40@xmlRelaxNG:

; 10398:                     oldstate = xmlRelaxNGCopyValidState(ctxt, ctxt->state);

	push	ecx
	push	esi
	call	_xmlRelaxNGCopyValidState

; 10399:                     ret = xmlRelaxNGValidateDefinition(ctxt, list);

	push	DWORD PTR _list$2$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	push	esi
	call	_xmlRelaxNGValidateDefinition
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$1$[ebp], ebx

; 10400:                     if (ret == 0) {

	test	ebx, ebx
	jne	SHORT $LN160@xmlRelaxNG

; 10401:                         if (states == NULL) {

	test	edi, edi
	jne	SHORT $LN162@xmlRelaxNG

; 10402:                             states = xmlRelaxNGNewStates(ctxt, 1);

	push	1
	push	esi
	call	_xmlRelaxNGNewStates
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR $T2[ebp], edi
$LN162@xmlRelaxNG:

; 10403:                         }
; 10404:                         if (ctxt->state != NULL) {

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN163@xmlRelaxNG

; 10405:                             xmlRelaxNGAddStates(ctxt, states, ctxt->state);

	push	eax
	push	edi
	push	esi
	call	_xmlRelaxNGAddStates
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN161@xmlRelaxNG
$LN163@xmlRelaxNG:

; 10406:                         } else if (ctxt->states != NULL) {

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN161@xmlRelaxNG

; 10407:                             for (i = 0; i < ctxt->states->nbState; i++) {

	xor	edi, edi
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN43@xmlRelaxNG
	mov	ebx, DWORD PTR $T2[ebp]
	npad	8
$LL44@xmlRelaxNG:

; 10408:                                 xmlRelaxNGAddStates(ctxt, states,

	mov	eax, DWORD PTR [esi+64]
	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [eax+edi*4]
	push	ebx
	push	esi
	call	_xmlRelaxNGAddStates
	mov	eax, DWORD PTR [esi+64]
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL44@xmlRelaxNG
	mov	ebx, DWORD PTR _ret$1$[ebp]
$LN43@xmlRelaxNG:

; 10409:                                                     ctxt->states->
; 10410:                                                     tabState[i]);
; 10411:                             }
; 10412:                             xmlRelaxNGFreeStates(ctxt, ctxt->states);

	push	eax
	push	esi
	call	_xmlRelaxNGFreeStates

; 10413:                             ctxt->states = NULL;

	mov	DWORD PTR [esi+64], 0

; 10414:                         }
; 10415:                     } else {

	jmp	SHORT $LN441@xmlRelaxNG
$LN160@xmlRelaxNG:

; 10416:                         xmlRelaxNGFreeValidState(ctxt, ctxt->state);

	push	DWORD PTR [esi+60]
	push	esi
	call	_xmlRelaxNGFreeValidState
$LN441@xmlRelaxNG:

; 10417:                     }
; 10418:                     ctxt->state = oldstate;

	add	esp, 8
$LN161@xmlRelaxNG:

; 10419:                     list = list->next;

	mov	eax, DWORD PTR _list$2$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edi, DWORD PTR $T2[ebp]
	mov	DWORD PTR [esi+60], ecx
	mov	eax, DWORD PTR [eax+32]
	mov	DWORD PTR _list$2$[ebp], eax
	test	eax, eax
	jne	$LL40@xmlRelaxNG

; 10396: 
; 10397:                 while (list != NULL) {

	jmp	SHORT $LN41@xmlRelaxNG
$LN434@xmlRelaxNG:
	xor	ecx, ecx
$LN41@xmlRelaxNG:

; 10420:                 }
; 10421:                 if (states != NULL) {

	test	edi, edi
	je	SHORT $LN166@xmlRelaxNG

; 10422:                     xmlRelaxNGFreeValidState(ctxt, oldstate);

	push	ecx
	push	esi
	call	_xmlRelaxNGFreeValidState
	add	esp, 8

; 10423:                     ctxt->states = states;
; 10424:                     ctxt->state = NULL;

	mov	DWORD PTR [esi+60], 0

; 10425:                     ret = 0;

	xor	ebx, ebx

; 10426:                 } else {

	jmp	SHORT $LN167@xmlRelaxNG
$LN166@xmlRelaxNG:

; 10427:                     ctxt->states = NULL;

	xor	edi, edi
$LN167@xmlRelaxNG:

; 10428:                 }
; 10429:                 ctxt->flags = oldflags;

	mov	eax, DWORD PTR _oldflags$4$[ebp]
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+28], eax

; 10430:                 if (ret != 0) {

	test	ebx, ebx
	je	SHORT $LN168@xmlRelaxNG

; 10431:                     if ((ctxt->flags & FLAGS_IGNORABLE) == 0) {

	test	al, 1

; 10432:                         xmlRelaxNGDumpValidError(ctxt);
; 10433:                     }
; 10434:                 } else {

	jmp	$LN446@xmlRelaxNG
$LN168@xmlRelaxNG:

; 10435:                     if (ctxt->errNr > errNr)

	mov	eax, DWORD PTR _errNr$5$[ebp]

; 10436:                         xmlRelaxNGPopErrors(ctxt, errNr);
; 10437:                 }
; 10438:                 break;

	jmp	$LN447@xmlRelaxNG
$LN172@xmlRelaxNG:

; 10439:             }
; 10440:         case XML_RELAXNG_DEF:
; 10441:         case XML_RELAXNG_GROUP:
; 10442:             ret = xmlRelaxNGValidateDefinitionList(ctxt, define->content);

	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGValidateDefinitionList
	add	esp, 8
	mov	ebx, eax

; 10602:             break;
; 10603:     }
; 10604:     ctxt->depth--;

	dec	DWORD PTR [esi+32]
	pop	edi

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN173@xmlRelaxNG:

; 10443:             break;
; 10444:         case XML_RELAXNG_INTERLEAVE:
; 10445:             ret = xmlRelaxNGValidateInterleave(ctxt, define);

	push	edi
	push	esi
	call	_xmlRelaxNGValidateInterleave
	add	esp, 8
	mov	ebx, eax

; 10602:             break;
; 10603:     }
; 10604:     ctxt->depth--;

	dec	DWORD PTR [esi+32]
	pop	edi

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN174@xmlRelaxNG:

; 10446:             break;
; 10447:         case XML_RELAXNG_ATTRIBUTE:
; 10448:             ret = xmlRelaxNGValidateAttribute(ctxt, define);

	push	edi
	push	esi
	call	_xmlRelaxNGValidateAttribute
	add	esp, 8
	mov	ebx, eax

; 10602:             break;
; 10603:     }
; 10604:     ctxt->depth--;

	dec	DWORD PTR [esi+32]
	pop	edi

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN175@xmlRelaxNG:

; 10449:             break;
; 10450:         case XML_RELAXNG_START:
; 10451:         case XML_RELAXNG_NOOP:
; 10452:         case XML_RELAXNG_REF:
; 10453:         case XML_RELAXNG_EXTERNALREF:
; 10454:         case XML_RELAXNG_PARENTREF:
; 10455:             ret = xmlRelaxNGValidateDefinition(ctxt, define->content);

	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGValidateDefinition
	add	esp, 8
	mov	ebx, eax

; 10602:             break;
; 10603:     }
; 10604:     ctxt->depth--;

	dec	DWORD PTR [esi+32]
	pop	edi

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN176@xmlRelaxNG:

; 10456:             break;
; 10457:         case XML_RELAXNG_DATATYPE:{
; 10458:                 xmlNodePtr child;
; 10459:                 xmlChar *content = NULL;

	xor	edx, edx

; 10460: 
; 10461:                 child = node;

	mov	edi, ecx
	mov	DWORD PTR _content$1$[ebp], edx

; 10462:                 while (child != NULL) {

	test	ecx, ecx
	je	SHORT $LN419@xmlRelaxNG
$LL45@xmlRelaxNG:

; 10463:                     if (child->type == XML_ELEMENT_NODE) {

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 1
	je	SHORT $LN358@xmlRelaxNG

; 10465:                                    node->parent->name);
; 10466:                         ret = -1;
; 10467:                         break;
; 10468:                     } else if ((child->type == XML_TEXT_NODE) ||

	cmp	eax, 3
	je	SHORT $LN180@xmlRelaxNG
	cmp	eax, 4
	jne	SHORT $LN179@xmlRelaxNG
$LN180@xmlRelaxNG:

; 10469:                                (child->type == XML_CDATA_SECTION_NODE)) {
; 10470:                         content = xmlStrcat(content, child->content);

	push	DWORD PTR [edi+40]
	push	edx
	call	_xmlStrcat
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR _content$1$[ebp], edx
$LN179@xmlRelaxNG:

; 10471:                     }
; 10472:                     /* TODO: handle entities ... */
; 10473:                     child = child->next;

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	SHORT $LL45@xmlRelaxNG

; 10474:                 }
; 10475:                 if (ret == -1) {
; 10476:                     if (content != NULL)
; 10477:                         xmlFree(content);
; 10478:                     break;
; 10479:                 }
; 10480:                 if (content == NULL) {

	test	edx, edx
	jne	SHORT $LN184@xmlRelaxNG
$LN419@xmlRelaxNG:

; 10481:                     content = xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR _content$1$[ebp], edx

; 10482:                     if (content == NULL) {

	test	edx, edx
	jne	SHORT $LN184@xmlRelaxNG
$LN442@xmlRelaxNG:

; 10602:             break;
; 10603:     }
; 10604:     ctxt->depth--;

	push	OFFSET ??_C@_0M@PEGDIBJJ@validating?6@
	push	esi
	call	_xmlRngVErrMemory
	add	esp, 8
	or	ebx, -1
	dec	DWORD PTR [esi+32]

; 10605: #ifdef DEBUG
; 10606:     for (i = 0; i < ctxt->depth; i++)
; 10607:         xmlGenericError(xmlGenericErrorContext, " ");
; 10608:     xmlGenericError(xmlGenericErrorContext,
; 10609:                     "Validating %s ", xmlRelaxNGDefName(define));
; 10610:     if (define->name != NULL)
; 10611:         xmlGenericError(xmlGenericErrorContext, "%s ", define->name);
; 10612:     if (ret == 0)
; 10613:         xmlGenericError(xmlGenericErrorContext, "suceeded\n");
; 10614:     else
; 10615:         xmlGenericError(xmlGenericErrorContext, "failed\n");
; 10616: #endif
; 10617:     return (ret);

	mov	eax, ebx
	pop	edi

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN358@xmlRelaxNG:

; 10464:                         VALID_ERR2(XML_RELAXNG_ERR_DATAELEM,

	mov	eax, DWORD PTR _node$3$[ebp]
	push	0
	push	0
	mov	eax, DWORD PTR [eax+20]
	push	DWORD PTR [eax+8]
	push	28					; 0000001cH
$LN449@xmlRelaxNG:

; 10602:             break;
; 10603:     }
; 10604:     ctxt->depth--;

	push	esi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H
	or	ebx, -1
$LN187@xmlRelaxNG:
	mov	eax, DWORD PTR _content$1$[ebp]
$LN451@xmlRelaxNG:
	test	eax, eax
	je	$LN2@xmlRelaxNG
	push	eax
$LN450@xmlRelaxNG:
	call	DWORD PTR _xmlFree
	add	esp, 4

; 10605: #ifdef DEBUG
; 10606:     for (i = 0; i < ctxt->depth; i++)
; 10607:         xmlGenericError(xmlGenericErrorContext, " ");
; 10608:     xmlGenericError(xmlGenericErrorContext,
; 10609:                     "Validating %s ", xmlRelaxNGDefName(define));
; 10610:     if (define->name != NULL)
; 10611:         xmlGenericError(xmlGenericErrorContext, "%s ", define->name);
; 10612:     if (ret == 0)
; 10613:         xmlGenericError(xmlGenericErrorContext, "suceeded\n");
; 10614:     else
; 10615:         xmlGenericError(xmlGenericErrorContext, "failed\n");
; 10616: #endif
; 10617:     return (ret);

	mov	eax, ebx
	dec	DWORD PTR [esi+32]
	pop	edi

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN184@xmlRelaxNG:

; 10483:                         xmlRngVErrMemory(ctxt, "validating\n");
; 10484:                         ret = -1;
; 10485:                         break;
; 10486:                     }
; 10487:                 }
; 10488:                 ret = xmlRelaxNGValidateDatatype(ctxt, content, define,

	mov	eax, DWORD PTR [esi+60]
	mov	edi, DWORD PTR _define$[ebp]
	push	DWORD PTR [eax+4]
	push	edi
	push	edx
	push	esi
	call	_xmlRelaxNGValidateDatatype
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 10489:                                                  ctxt->state->seq);
; 10490:                 if (ret == -1) {

	cmp	ebx, -1
	jne	SHORT $LN185@xmlRelaxNG

; 10491:                     VALID_ERR2(XML_RELAXNG_ERR_DATATYPE, define->name);

	push	0
	push	0
	push	DWORD PTR [edi+8]
	push	31					; 0000001fH
	push	esi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H
	jmp	SHORT $LN187@xmlRelaxNG
$LN185@xmlRelaxNG:

; 10602:             break;
; 10603:     }
; 10604:     ctxt->depth--;

	test	ebx, ebx
	jne	SHORT $LN187@xmlRelaxNG
	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [eax+4], ebx
	jmp	SHORT $LN187@xmlRelaxNG
$LN189@xmlRelaxNG:

; 10492:                 } else if (ret == 0) {
; 10493:                     ctxt->state->seq = NULL;
; 10494:                 }
; 10495:                 if (content != NULL)
; 10496:                     xmlFree(content);
; 10497:                 break;
; 10498:             }
; 10499:         case XML_RELAXNG_VALUE:{
; 10500:                 xmlChar *content = NULL;

	xor	edx, edx

; 10501:                 xmlChar *oldvalue;
; 10502:                 xmlNodePtr child;
; 10503: 
; 10504:                 child = node;

	mov	edi, ecx
	mov	DWORD PTR _content$1$[ebp], edx

; 10505:                 while (child != NULL) {

	test	ecx, ecx
	je	SHORT $LN421@xmlRelaxNG
	npad	7
$LL47@xmlRelaxNG:

; 10506:                     if (child->type == XML_ELEMENT_NODE) {

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 1
	je	$LN359@xmlRelaxNG

; 10508:                                    node->parent->name);
; 10509:                         ret = -1;
; 10510:                         break;
; 10511:                     } else if ((child->type == XML_TEXT_NODE) ||

	cmp	eax, 3
	je	SHORT $LN193@xmlRelaxNG
	cmp	eax, 4
	jne	SHORT $LN192@xmlRelaxNG
$LN193@xmlRelaxNG:

; 10512:                                (child->type == XML_CDATA_SECTION_NODE)) {
; 10513:                         content = xmlStrcat(content, child->content);

	push	DWORD PTR [edi+40]
	push	edx
	call	_xmlStrcat
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR _content$1$[ebp], edx
$LN192@xmlRelaxNG:

; 10514:                     }
; 10515:                     /* TODO: handle entities ... */
; 10516:                     child = child->next;

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	SHORT $LL47@xmlRelaxNG

; 10522:                 }
; 10523:                 if (content == NULL) {

	test	edx, edx
	jne	SHORT $LN197@xmlRelaxNG
$LN421@xmlRelaxNG:

; 10524:                     content = xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR _content$1$[ebp], edx

; 10525:                     if (content == NULL) {

	test	edx, edx
	je	$LN442@xmlRelaxNG
$LN197@xmlRelaxNG:

; 10526:                         xmlRngVErrMemory(ctxt, "validating\n");
; 10527:                         ret = -1;
; 10528:                         break;
; 10529:                     }
; 10530:                 }
; 10531:                 oldvalue = ctxt->state->value;

	mov	eax, DWORD PTR [esi+60]

; 10532:                 ctxt->state->value = content;
; 10533:                 ret = xmlRelaxNGValidateValue(ctxt, define);

	push	DWORD PTR _define$[ebp]
	push	esi
	mov	edi, DWORD PTR [eax+20]
	mov	DWORD PTR [eax+20], edx
	call	_xmlRelaxNGValidateValue
	mov	ebx, eax
	add	esp, 8

; 10534:                 ctxt->state->value = oldvalue;

	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [eax+20], edi

; 10535:                 if (ret == -1) {

	cmp	ebx, -1
	jne	$LN185@xmlRelaxNG

; 10536:                     VALID_ERR2(XML_RELAXNG_ERR_VALUE, define->name);

	mov	eax, DWORD PTR _define$[ebp]
	push	0
	push	0
	push	DWORD PTR [eax+8]
	push	32					; 00000020H
	push	esi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H
	jmp	$LN187@xmlRelaxNG
$LN359@xmlRelaxNG:

; 10507:                         VALID_ERR2(XML_RELAXNG_ERR_VALELEM,

	mov	eax, DWORD PTR _node$3$[ebp]
	push	0
	push	0
	mov	eax, DWORD PTR [eax+20]
	push	DWORD PTR [eax+8]
	push	29					; 0000001dH

; 10517:                 }
; 10518:                 if (ret == -1) {
; 10519:                     if (content != NULL)
; 10520:                         xmlFree(content);
; 10521:                     break;

	jmp	$LN449@xmlRelaxNG
$LN202@xmlRelaxNG:

; 10537:                 } else if (ret == 0) {
; 10538:                     ctxt->state->seq = NULL;
; 10539:                 }
; 10540:                 if (content != NULL)
; 10541:                     xmlFree(content);
; 10542:                 break;
; 10543:             }
; 10544:         case XML_RELAXNG_LIST:{
; 10545:                 xmlChar *content;
; 10546:                 xmlNodePtr child;
; 10547:                 xmlChar *oldvalue, *oldendvalue;
; 10548:                 int len;
; 10549: 
; 10550:                 /*
; 10551:                  * Make sure it's only text nodes
; 10552:                  */
; 10553: 
; 10554:                 content = NULL;

	xor	eax, eax

; 10555:                 child = node;

	mov	edi, ecx
	mov	DWORD PTR _content$1$[ebp], eax

; 10556:                 while (child != NULL) {

	test	ecx, ecx
	je	SHORT $LN423@xmlRelaxNG
	npad	5
$LL49@xmlRelaxNG:

; 10557:                     if (child->type == XML_ELEMENT_NODE) {

	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, 1
	je	$LN360@xmlRelaxNG

; 10559:                                    node->parent->name);
; 10560:                         ret = -1;
; 10561:                         break;
; 10562:                     } else if ((child->type == XML_TEXT_NODE) ||

	cmp	ecx, 3
	je	SHORT $LN206@xmlRelaxNG
	cmp	ecx, 4
	jne	SHORT $LN205@xmlRelaxNG
$LN206@xmlRelaxNG:

; 10563:                                (child->type == XML_CDATA_SECTION_NODE)) {
; 10564:                         content = xmlStrcat(content, child->content);

	push	DWORD PTR [edi+40]
	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _content$1$[ebp], eax
$LN205@xmlRelaxNG:

; 10565:                     }
; 10566:                     /* TODO: handle entities ... */
; 10567:                     child = child->next;

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	SHORT $LL49@xmlRelaxNG

; 10573:                 }
; 10574:                 if (content == NULL) {

	test	eax, eax
	jne	SHORT $LN210@xmlRelaxNG
$LN423@xmlRelaxNG:

; 10575:                     content = xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _content$1$[ebp], eax

; 10576:                     if (content == NULL) {

	test	eax, eax
	je	$LN442@xmlRelaxNG
$LN210@xmlRelaxNG:

; 10577:                         xmlRngVErrMemory(ctxt, "validating\n");
; 10578:                         ret = -1;
; 10579:                         break;
; 10580:                     }
; 10581:                 }
; 10582:                 len = xmlStrlen(content);

	push	eax
	call	_xmlStrlen

; 10583:                 oldvalue = ctxt->state->value;

	mov	ecx, DWORD PTR [esi+60]

; 10584:                 oldendvalue = ctxt->state->endvalue;
; 10585:                 ctxt->state->value = content;

	mov	edx, DWORD PTR _content$1$[ebp]

; 10586:                 ctxt->state->endvalue = content + len;
; 10587:                 ret = xmlRelaxNGValidateValue(ctxt, define);

	push	DWORD PTR _define$[ebp]
	mov	edi, DWORD PTR [ecx+20]
	mov	ebx, DWORD PTR [ecx+24]
	mov	DWORD PTR [ecx+20], edx
	lea	ecx, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [esi+60]
	push	esi
	mov	DWORD PTR [eax+24], ecx
	call	_xmlRelaxNGValidateValue
	mov	DWORD PTR _ret$1$[ebp], eax
	add	esp, 12					; 0000000cH

; 10588:                 ctxt->state->value = oldvalue;

	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [eax+20], edi

; 10589:                 ctxt->state->endvalue = oldendvalue;

	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [eax+24], ebx

; 10590:                 if (ret == -1) {

	mov	ebx, DWORD PTR _ret$1$[ebp]
	cmp	ebx, -1
	jne	SHORT $LN211@xmlRelaxNG

; 10591:                     VALID_ERR(XML_RELAXNG_ERR_LIST);

	push	0
	push	0
	push	0
	push	33					; 00000021H
	push	esi
	call	_xmlRelaxNGAddValidError

; 10594:                 }
; 10595:                 if (content != NULL)

	mov	eax, DWORD PTR _content$1$[ebp]
	add	esp, 20					; 00000014H

; 10596:                     xmlFree(content);
; 10597:                 break;

	jmp	$LN451@xmlRelaxNG
$LN360@xmlRelaxNG:

; 10558:                         VALID_ERR2(XML_RELAXNG_ERR_LISTELEM,

	mov	eax, DWORD PTR _node$3$[ebp]
	push	0
	push	0
	mov	eax, DWORD PTR [eax+20]
	push	DWORD PTR [eax+8]
	push	30					; 0000001eH
	push	esi
	call	_xmlRelaxNGAddValidError

; 10568:                 }
; 10569:                 if (ret == -1) {
; 10570:                     if (content != NULL)

	mov	edx, DWORD PTR _content$1$[ebp]
	add	esp, 20					; 00000014H
	or	ebx, -1
	test	edx, edx
	je	SHORT $LN2@xmlRelaxNG

; 10571:                         xmlFree(content);

	push	edx

; 10572:                     break;

	jmp	$LN450@xmlRelaxNG
$LN211@xmlRelaxNG:

; 10592:                 } else if ((ret == 0) && (node != NULL)) {

	test	ebx, ebx
	jne	SHORT $LN213@xmlRelaxNG
	mov	eax, DWORD PTR _node$3$[ebp]
	test	eax, eax
	je	SHORT $LN213@xmlRelaxNG

; 10593:                     ctxt->state->seq = node->next;

	mov	ecx, DWORD PTR [esi+60]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+4], eax
$LN213@xmlRelaxNG:

; 10594:                 }
; 10595:                 if (content != NULL)

	mov	eax, DWORD PTR _content$1$[ebp]

; 10596:                     xmlFree(content);
; 10597:                 break;

	jmp	$LN451@xmlRelaxNG
$LN215@xmlRelaxNG:

; 10598:             }
; 10599:         case XML_RELAXNG_EXCEPT:
; 10600:         case XML_RELAXNG_PARAM:
; 10601:             TODO ret = -1;

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	10601					; 00002969H
	push	OFFSET ??_C@_0GJ@NFABHKPN@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 16					; 00000010H
$LN55@xmlRelaxNG:

; 10602:             break;
; 10603:     }
; 10604:     ctxt->depth--;

	or	ebx, -1
$LN2@xmlRelaxNG:
	dec	DWORD PTR [esi+32]

; 10605: #ifdef DEBUG
; 10606:     for (i = 0; i < ctxt->depth; i++)
; 10607:         xmlGenericError(xmlGenericErrorContext, " ");
; 10608:     xmlGenericError(xmlGenericErrorContext,
; 10609:                     "Validating %s ", xmlRelaxNGDefName(define));
; 10610:     if (define->name != NULL)
; 10611:         xmlGenericError(xmlGenericErrorContext, "%s ", define->name);
; 10612:     if (ret == 0)
; 10613:         xmlGenericError(xmlGenericErrorContext, "suceeded\n");
; 10614:     else
; 10615:         xmlGenericError(xmlGenericErrorContext, "failed\n");
; 10616: #endif
; 10617:     return (ret);

	mov	eax, ebx
	pop	edi

; 10618: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN454@xmlRelaxNG:
	DD	$LN175@xmlRelaxNG
	DD	$LN54@xmlRelaxNG
	DD	$LN55@xmlRelaxNG
	DD	$LN215@xmlRelaxNG
	DD	$LN337@xmlRelaxNG
	DD	$LN58@xmlRelaxNG
	DD	$LN176@xmlRelaxNG
	DD	$LN215@xmlRelaxNG
	DD	$LN189@xmlRelaxNG
	DD	$LN202@xmlRelaxNG
	DD	$LN174@xmlRelaxNG
	DD	$LN172@xmlRelaxNG
	DD	$LN175@xmlRelaxNG
	DD	$LN175@xmlRelaxNG
	DD	$LN175@xmlRelaxNG
	DD	$LN107@xmlRelaxNG
	DD	$LN118@xmlRelaxNG
	DD	$LN116@xmlRelaxNG
	DD	$LN148@xmlRelaxNG
	DD	$LN172@xmlRelaxNG
	DD	$LN173@xmlRelaxNG
	DD	$LN175@xmlRelaxNG
_xmlRelaxNGValidateState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGBestState
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlRelaxNGBestState PROC				; COMDAT

; 9758 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	or	ecx, -1
	mov	edx, 1000000				; 000f4240H
	test	edi, edi
	je	SHORT $LN6@xmlRelaxNG

; 9759 :     xmlRelaxNGValidStatePtr state;
; 9760 :     int i, tmp;
; 9761 :     int best = -1;
; 9762 :     int value = 1000000;
; 9763 : 
; 9764 :     if ((ctxt == NULL) || (ctxt->states == NULL) ||

	mov	edi, DWORD PTR [edi+64]
	test	edi, edi
	je	SHORT $LN6@xmlRelaxNG
	mov	ebx, DWORD PTR [edi]
	test	ebx, ebx
	jle	SHORT $LN6@xmlRelaxNG

; 9769 :         state = ctxt->states->tabState[i];

	mov	edi, DWORD PTR [edi+8]
	xor	eax, eax
	push	esi
$LL4@xmlRelaxNG:
	mov	esi, DWORD PTR [edi]

; 9770 :         if (state == NULL)

	test	esi, esi
	je	SHORT $LN2@xmlRelaxNG

; 9771 :             continue;
; 9772 :         if (state->seq != NULL) {

	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN8@xmlRelaxNG

; 9773 :             if ((best == -1) || (value > 100000)) {

	cmp	ecx, -1
	je	SHORT $LN11@xmlRelaxNG
	cmp	edx, 100000				; 000186a0H
	jle	SHORT $LN2@xmlRelaxNG
$LN11@xmlRelaxNG:

; 9774 :                 value = 100000;

	mov	edx, 100000				; 000186a0H

; 9775 :                 best = i;
; 9776 :             }
; 9777 :         } else {

	jmp	SHORT $LN19@xmlRelaxNG
$LN8@xmlRelaxNG:

; 9778 :             tmp = state->nbAttrLeft;

	mov	esi, DWORD PTR [esi+16]

; 9779 :             if ((best == -1) || (value > tmp)) {

	cmp	ecx, -1
	je	SHORT $LN13@xmlRelaxNG
	cmp	edx, esi
	jle	SHORT $LN2@xmlRelaxNG
$LN13@xmlRelaxNG:

; 9780 :                 value = tmp;

	mov	edx, esi
$LN19@xmlRelaxNG:

; 9767 : 
; 9768 :     for (i = 0; i < ctxt->states->nbState; i++) {

	mov	ecx, eax
$LN2@xmlRelaxNG:
	inc	eax
	add	edi, 4
	cmp	eax, ebx
	jl	SHORT $LL4@xmlRelaxNG

; 9781 :                 best = i;
; 9782 :             }
; 9783 :         }
; 9784 :     }
; 9785 :     return (best);

	pop	esi
	pop	edi
	mov	eax, ecx

; 9786 : }

	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlRelaxNG:
	pop	edi

; 9765 :         (ctxt->states->nbState <= 0))
; 9766 :         return (-1);

	or	eax, -1

; 9786 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlRelaxNGBestState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidateDefinitionList
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_defines$ = 12						; size = 4
_xmlRelaxNGValidateDefinitionList PROC			; COMDAT

; 9606 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _defines$[ebp]
	xor	ebx, ebx
	test	esi, esi
	jne	SHORT $LN64@xmlRelaxNG

; 9607 :     int ret = 0, res;
; 9608 : 
; 9609 : 
; 9610 :     if (defines == NULL) {
; 9611 :         VALID_ERR2(XML_RELAXNG_ERR_INTERNAL,

	push	esi
	push	esi
	push	OFFSET ??_C@_0BF@BELJIEJG@NULL?5definition?5list@
	push	37					; 00000025H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 9612 :                    BAD_CAST "NULL definition list");
; 9613 :         return (-1);

	or	eax, -1
	pop	esi

; 9630 : }

	pop	ebx
	pop	ebp
	ret	0
$LN64@xmlRelaxNG:
	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
$LL2@xmlRelaxNG:

; 9614 :     }
; 9615 :     while (defines != NULL) {
; 9616 :         if ((ctxt->state != NULL) || (ctxt->states != NULL)) {

	cmp	DWORD PTR [edi+60], 0
	jne	SHORT $LN7@xmlRelaxNG
	cmp	DWORD PTR [edi+64], 0
	je	SHORT $LN5@xmlRelaxNG
$LN7@xmlRelaxNG:

; 9617 :             res = xmlRelaxNGValidateDefinition(ctxt, defines);

	push	esi
	push	edi
	call	_xmlRelaxNGValidateDefinition
	add	esp, 8

; 9618 :             if (res < 0)

	mov	ecx, -1
	test	eax, eax
	cmovs	ebx, ecx

; 9623 :         }
; 9624 :         if (res == -1)          /* continues on -2 */

	cmp	eax, ecx
	je	SHORT $LN65@xmlRelaxNG

; 9625 :             break;
; 9626 :         defines = defines->next;

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL2@xmlRelaxNG
$LN65@xmlRelaxNG:
	pop	edi
	pop	esi

; 9627 :     }
; 9628 : 
; 9629 :     return (ret);

	mov	eax, ebx

; 9630 : }

	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlRelaxNG:

; 9619 :                 ret = -1;
; 9620 :         } else {
; 9621 :             VALID_ERR(XML_RELAXNG_ERR_NOSTATE);

	push	0
	push	0
	push	0
	push	6
	push	edi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 9622 :             return (-1);

	or	eax, -1
	pop	edi
	pop	esi

; 9630 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlRelaxNGValidateDefinitionList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidateInterleave
_TEXT	SEGMENT
_errNr$1$ = -68						; size = 4
_start$1$ = -64						; size = 4
_lastelem$1$ = -60					; size = 4
_ret$1$ = -56						; size = 4
tv1976 = -52						; size = 4
tv1914 = -48						; size = 4
_cur$5$ = -44						; size = 4
_oldflags$1$ = -40					; size = 4
tv1918 = -36						; size = 4
_last$1$ = -32						; size = 4
_lasts$1$ = -28						; size = 4
_list$1$ = -24						; size = 4
_i$2$ = -20						; size = 4
_cur$4$ = -16						; size = 4
_found$1$ = -12						; size = 4
_nbgroups$1$ = -8					; size = 4
_oldstate$1$ = -4					; size = 4
_best$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_partitions$1$ = 12					; size = 4
_define$ = 12						; size = 4
_xmlRelaxNGValidateInterleave PROC			; COMDAT

; 9311 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	xor	ebx, ebx
	mov	DWORD PTR _last$1$[ebp], 0
	mov	DWORD PTR _cur$5$[ebp], ebx
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR _errNr$1$[ebp], eax
	mov	eax, DWORD PTR _define$[ebp]
	mov	ebx, DWORD PTR [eax+20]
	mov	DWORD PTR _partitions$1$[ebp], ebx
	test	ebx, ebx
	je	$LN18@xmlRelaxNG

; 9312 :     int ret = 0, i, nbgroups;
; 9313 :     int errNr = ctxt->errNr;
; 9314 :     int oldflags;
; 9315 : 
; 9316 :     xmlRelaxNGValidStatePtr oldstate;
; 9317 :     xmlRelaxNGPartitionPtr partitions;
; 9318 :     xmlRelaxNGInterleaveGroupPtr group = NULL;
; 9319 :     xmlNodePtr cur, start, last = NULL, lastchg = NULL, lastelem;
; 9320 :     xmlNodePtr *list = NULL, *lasts = NULL;
; 9321 : 
; 9322 :     if (define->data != NULL) {
; 9323 :         partitions = (xmlRelaxNGPartitionPtr) define->data;
; 9324 :         nbgroups = partitions->nbgroups;

	test	BYTE PTR [eax+50], 8
	mov	ecx, DWORD PTR [ebx]

; 9328 :     }
; 9329 :     /*
; 9330 :      * Optimizations for MIXED
; 9331 :      */
; 9332 :     oldflags = ctxt->flags;

	mov	edx, DWORD PTR [esi+28]
	push	edi
	mov	DWORD PTR _nbgroups$1$[ebp], ecx
	mov	DWORD PTR _oldflags$1$[ebp], edx

; 9333 :     if (define->dflags & IS_MIXED) {

	je	SHORT $LN21@xmlRelaxNG

; 9334 :         ctxt->flags |= FLAGS_MIXED_CONTENT;

	mov	eax, edx
	or	eax, 4
	mov	DWORD PTR [esi+28], eax

; 9335 :         if (nbgroups == 2) {

	cmp	ecx, 2
	jne	SHORT $LN21@xmlRelaxNG

; 9336 :             /*
; 9337 :              * this is a pure <mixed> case
; 9338 :              */
; 9339 :             if (ctxt->state != NULL)

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN22@xmlRelaxNG

; 9340 :                 ctxt->state->seq = xmlRelaxNGSkipIgnored(ctxt,

	push	DWORD PTR [eax+4]
	push	esi
	call	_xmlRelaxNGSkipIgnored
	mov	ecx, DWORD PTR [esi+60]
	add	esp, 8
	mov	DWORD PTR [ecx+4], eax
$LN22@xmlRelaxNG:

; 9341 :                                                          ctxt->state->seq);
; 9342 :             if (partitions->groups[0]->rule->type == XML_RELAXNG_TEXT)

	mov	edx, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN23@xmlRelaxNG

; 9343 :                 ret = xmlRelaxNGValidateDefinition(ctxt,

	mov	ecx, DWORD PTR [edx+4]
$LN23@xmlRelaxNG:

; 9344 :                                                    partitions->groups[1]->
; 9345 :                                                    rule);
; 9346 :             else
; 9347 :                 ret = xmlRelaxNGValidateDefinition(ctxt,
; 9348 :                                                    partitions->groups[0]->
; 9349 :                                                    rule);
; 9350 :             if (ret == 0) {

	mov	eax, DWORD PTR [ecx]
	push	eax
	push	esi
	call	_xmlRelaxNGValidateDefinition
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	jne	SHORT $LN26@xmlRelaxNG

; 9351 :                 if (ctxt->state != NULL)

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN26@xmlRelaxNG

; 9352 :                     ctxt->state->seq = xmlRelaxNGSkipIgnored(ctxt,

	push	DWORD PTR [eax+4]
	push	esi
	call	_xmlRelaxNGSkipIgnored
	mov	ecx, DWORD PTR [esi+60]
	add	esp, 8
	mov	DWORD PTR [ecx+4], eax
$LN26@xmlRelaxNG:

; 9353 :                                                              ctxt->state->
; 9354 :                                                              seq);
; 9355 :             }
; 9356 :             ctxt->flags = oldflags;

	mov	eax, DWORD PTR _oldflags$1$[ebp]
	mov	DWORD PTR [esi+28], eax

; 9357 :             return (ret);

	mov	eax, edi
	pop	edi
	pop	esi

; 9592 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlRelaxNG:

; 9358 :         }
; 9359 :     }
; 9360 : 
; 9361 :     /*
; 9362 :      * Build arrays to store the first and last node of the chain
; 9363 :      * pertaining to each group
; 9364 :      */
; 9365 :     list = (xmlNodePtr *) xmlMalloc(nbgroups * sizeof(xmlNodePtr));

	lea	edi, DWORD PTR [ecx*4]
	push	edi
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _list$1$[ebp], eax

; 9366 :     if (list == NULL) {

	test	eax, eax
	jne	SHORT $LN27@xmlRelaxNG

; 480  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN165@xmlRelaxNG

; 481  : 	    schannel = ctxt->serror;
; 482  : 	else
; 483  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN165@xmlRelaxNG:

; 484  :         data = ctxt->userData;
; 485  :         ctxt->nbErrors++;
; 486  :     }
; 487  :     if (extra)
; 488  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0M@PEGDIBJJ@validating?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+16]
	push	OFFSET ??_C@_0M@PEGDIBJJ@validating?6@
	push	0
	push	0
	push	3
	push	2
	push	19					; 00000013H
	push	0
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 9367 :         xmlRngVErrMemory(ctxt, "validating\n");
; 9368 :         return (-1);

	or	eax, -1
	pop	edi
	pop	esi

; 9592 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlRelaxNG:

; 9369 :     }
; 9370 :     memset(list, 0, nbgroups * sizeof(xmlNodePtr));

	push	edi
	push	0
	push	eax
	call	_memset

; 9371 :     lasts = (xmlNodePtr *) xmlMalloc(nbgroups * sizeof(xmlNodePtr));

	push	edi
	call	DWORD PTR _xmlMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lasts$1$[ebp], eax

; 9372 :     if (lasts == NULL) {

	test	eax, eax
	jne	SHORT $LN28@xmlRelaxNG

; 9373 :         xmlRngVErrMemory(ctxt, "validating\n");

	push	OFFSET ??_C@_0M@PEGDIBJJ@validating?6@
	push	esi
	call	_xmlRngVErrMemory
	add	esp, 8
	or	eax, -1
	pop	edi
	pop	esi

; 9592 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlRelaxNG:

; 9374 :         return (-1);
; 9375 :     }
; 9376 :     memset(lasts, 0, nbgroups * sizeof(xmlNodePtr));

	push	edi
	push	0
	push	eax
	call	_memset

; 9377 : 
; 9378 :     /*
; 9379 :      * Walk the sequence of children finding the right group and
; 9380 :      * sorting them in sequences.
; 9381 :      */
; 9382 :     cur = ctxt->state->seq;

	mov	eax, DWORD PTR [esi+60]

; 9383 :     cur = xmlRelaxNGSkipIgnored(ctxt, cur);

	push	DWORD PTR [eax+4]
	push	esi
	call	_xmlRelaxNGSkipIgnored
	mov	ebx, eax
	mov	DWORD PTR _cur$4$[ebp], eax
	add	esp, 20					; 00000014H

; 9384 :     start = cur;

	mov	DWORD PTR _start$1$[ebp], ebx

; 9385 :     while (cur != NULL) {

	test	ebx, ebx
	je	$LN265@xmlRelaxNG
$LL2@xmlRelaxNG:

; 9386 :         ctxt->state->seq = cur;

	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [eax+4], ebx

; 9387 :         if ((partitions->triage != NULL) &&

	mov	eax, DWORD PTR _partitions$1$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	$LN29@xmlRelaxNG
	test	BYTE PTR [eax+8], 1
	je	$LN29@xmlRelaxNG

; 9388 :             (partitions->flags & IS_DETERMINIST)) {
; 9389 :             void *tmp = NULL;
; 9390 : 
; 9391 :             if ((cur->type == XML_TEXT_NODE) ||

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, 3
	je	SHORT $LN33@xmlRelaxNG
	cmp	eax, 4
	je	SHORT $LN33@xmlRelaxNG

; 9394 :                                      NULL);
; 9395 :             } else if (cur->type == XML_ELEMENT_NODE) {

	cmp	eax, 1
	jne	$LN266@xmlRelaxNG

; 9396 :                 if (cur->ns != NULL) {

	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	je	SHORT $LN35@xmlRelaxNG

; 9397 :                     tmp = xmlHashLookup2(partitions->triage, cur->name,

	push	DWORD PTR [eax+8]
	push	DWORD PTR [ebx+8]
	push	ecx
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH

; 9398 :                                          cur->ns->href);
; 9399 :                     if (tmp == NULL)

	test	eax, eax
	jne	SHORT $LN39@xmlRelaxNG

; 9400 :                         tmp = xmlHashLookup2(partitions->triage,

	mov	edi, DWORD PTR _partitions$1$[ebp]
	mov	edx, OFFSET ??_C@_04IAJCOJMF@?$CDany@
	mov	eax, DWORD PTR [ebx+36]
	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [eax+8]

; 9401 :                                              BAD_CAST "#any",
; 9402 :                                              cur->ns->href);
; 9403 :                 } else

	jmp	SHORT $LN36@xmlRelaxNG
$LN35@xmlRelaxNG:

; 9404 :                     tmp =

	mov	edx, DWORD PTR [ebx+8]
	xor	eax, eax
	mov	edi, DWORD PTR _partitions$1$[ebp]
$LN36@xmlRelaxNG:

; 9405 :                         xmlHashLookup2(partitions->triage, cur->name,
; 9406 :                                        NULL);
; 9407 :                 if (tmp == NULL)

	push	eax
	push	edx
	push	ecx
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN39@xmlRelaxNG

; 9408 :                     tmp =

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, OFFSET ??_C@_04IAJCOJMF@?$CDany@
	jmp	SHORT $LN38@xmlRelaxNG
$LN33@xmlRelaxNG:

; 9392 :                 (cur->type == XML_CDATA_SECTION_NODE)) {
; 9393 :                 tmp = xmlHashLookup2(partitions->triage, BAD_CAST "#text",

	mov	eax, OFFSET ??_C@_05NOBOONOA@?$CDtext@
$LN38@xmlRelaxNG:

; 9409 :                         xmlHashLookup2(partitions->triage, BAD_CAST "#any",
; 9410 :                                        NULL);
; 9411 :             }
; 9412 : 
; 9413 :             if (tmp == NULL) {

	push	0
	push	eax
	push	ecx
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN266@xmlRelaxNG
$LN39@xmlRelaxNG:

; 9414 :                 i = nbgroups;
; 9415 :             } else {
; 9416 :                 i = ((ptrdiff_t) tmp) - 1;

	lea	edi, DWORD PTR [eax-1]

; 9417 :                 if (partitions->flags & IS_NEEDCHECK) {

	mov	eax, DWORD PTR _partitions$1$[ebp]
	test	BYTE PTR [eax+8], 2
	je	SHORT $LN226@xmlRelaxNG

; 9418 :                     group = partitions->groups[i];

	mov	eax, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax+edi*4]

; 9419 :                     if (!xmlRelaxNGNodeMatchesList(cur, group->defs))

	push	DWORD PTR [eax+4]
	push	ebx
	call	_xmlRelaxNGNodeMatchesList
	add	esp, 8
	test	eax, eax
	je	SHORT $LN266@xmlRelaxNG
$LN226@xmlRelaxNG:

; 9429 :                     break;
; 9430 :             }
; 9431 :         }
; 9432 :         /*
; 9433 :          * We break as soon as an element not matched is found
; 9434 :          */
; 9435 :         if (i >= nbgroups) {

	cmp	edi, DWORD PTR _nbgroups$1$[ebp]
	jge	SHORT $LN266@xmlRelaxNG

; 9436 :             break;
; 9437 :         }
; 9438 :         if (lasts[i] != NULL) {

	mov	ecx, DWORD PTR _lasts$1$[ebp]
	mov	eax, DWORD PTR [ecx+edi*4]
	test	eax, eax
	je	SHORT $LN46@xmlRelaxNG

; 9439 :             lasts[i]->next = cur;

	mov	DWORD PTR [eax+24], ebx

; 9440 :             lasts[i] = cur;
; 9441 :         } else {

	jmp	SHORT $LN47@xmlRelaxNG
$LN29@xmlRelaxNG:

; 9420 :                         i = nbgroups;
; 9421 :                 }
; 9422 :             }
; 9423 :         } else {
; 9424 :             for (i = 0; i < nbgroups; i++) {

	xor	edi, edi
	cmp	DWORD PTR _nbgroups$1$[ebp], edi
	jle	SHORT $LN266@xmlRelaxNG
	npad	3
$LL6@xmlRelaxNG:

; 9425 :                 group = partitions->groups[i];

	mov	eax, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax+edi*4]

; 9426 :                 if (group == NULL)

	test	eax, eax
	je	SHORT $LN4@xmlRelaxNG

; 9427 :                     continue;
; 9428 :                 if (xmlRelaxNGNodeMatchesList(cur, group->defs))

	push	DWORD PTR [eax+4]
	push	ebx
	call	_xmlRelaxNGNodeMatchesList
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN226@xmlRelaxNG
$LN4@xmlRelaxNG:

; 9420 :                         i = nbgroups;
; 9421 :                 }
; 9422 :             }
; 9423 :         } else {
; 9424 :             for (i = 0; i < nbgroups; i++) {

	inc	edi
	cmp	edi, DWORD PTR _nbgroups$1$[ebp]
	jge	SHORT $LN266@xmlRelaxNG
	mov	eax, DWORD PTR _partitions$1$[ebp]
	jmp	SHORT $LL6@xmlRelaxNG
$LN46@xmlRelaxNG:

; 9442 :             list[i] = cur;

	mov	eax, DWORD PTR _list$1$[ebp]
	mov	DWORD PTR [eax+edi*4], ebx
$LN47@xmlRelaxNG:

; 9443 :             lasts[i] = cur;
; 9444 :         }
; 9445 :         if (cur->next != NULL)

	mov	DWORD PTR [ecx+edi*4], ebx
	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax

; 9446 :             lastchg = cur->next;
; 9447 :         else
; 9448 :             lastchg = cur;
; 9449 :         cur = xmlRelaxNGSkipIgnored(ctxt, cur->next);

	push	eax
	cmovne	ebx, eax
	push	esi
	mov	DWORD PTR _cur$5$[ebp], ebx
	call	_xmlRelaxNGSkipIgnored
	mov	ebx, eax
	add	esp, 8
	test	ebx, ebx
	jne	$LL2@xmlRelaxNG
$LN266@xmlRelaxNG:
	mov	DWORD PTR _cur$4$[ebp], ebx
$LN265@xmlRelaxNG:

; 9457 :     oldstate = ctxt->state;
; 9458 :     for (i = 0; i < nbgroups; i++) {

	cmp	DWORD PTR _nbgroups$1$[ebp], 0
	mov	edi, DWORD PTR [esi+60]
	mov	DWORD PTR _lastelem$1$[ebp], ebx
	mov	DWORD PTR _oldstate$1$[ebp], edi
	mov	DWORD PTR _i$2$[ebp], 0
	jle	$LN270@xmlRelaxNG

; 9450 :     }
; 9451 :     if (ret != 0) {
; 9452 :         VALID_ERR(XML_RELAXNG_ERR_INTERSEQ);
; 9453 :         ret = -1;
; 9454 :         goto done;
; 9455 :     }
; 9456 :     lastelem = cur;

	mov	ebx, DWORD PTR _lasts$1$[ebp]
	mov	eax, DWORD PTR _list$1$[ebp]
	sub	eax, ebx
	mov	DWORD PTR tv1918[ebp], ebx
	mov	DWORD PTR tv1914[ebp], eax
$LL9@xmlRelaxNG:

; 9459 :         ctxt->state = xmlRelaxNGCopyValidState(ctxt, oldstate);

	push	edi
	push	esi
	call	_xmlRelaxNGCopyValidState
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR [esi+60], ecx

; 9460 : 	if (ctxt->state == NULL) {

	test	ecx, ecx
	je	$LN57@xmlRelaxNG

; 9461 : 	    ret = -1;
; 9462 : 	    break;
; 9463 : 	}
; 9464 :         group = partitions->groups[i];

	mov	eax, DWORD PTR _partitions$1$[ebp]
	mov	edx, DWORD PTR _i$2$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+edx*4]

; 9465 :         if (lasts[i] != NULL) {

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN258@xmlRelaxNG

; 9466 :             last = lasts[i]->next;

	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _last$1$[ebp], ecx

; 9467 :             lasts[i]->next = NULL;

	mov	DWORD PTR [eax+24], 0
	mov	ecx, DWORD PTR [esi+60]
$LN258@xmlRelaxNG:

; 9468 :         }
; 9469 :         ctxt->state->seq = list[i];

	mov	eax, DWORD PTR tv1914[ebp]
	mov	eax, DWORD PTR [eax+ebx]
	mov	DWORD PTR [ecx+4], eax

; 9470 :         ret = xmlRelaxNGValidateDefinition(ctxt, group->rule);

	push	DWORD PTR [edx]
	push	esi
	call	_xmlRelaxNGValidateDefinition
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _ret$1$[ebp], ebx

; 9471 :         if (ret != 0)

	test	ebx, ebx
	jne	$LN8@xmlRelaxNG

; 9472 :             break;
; 9473 :         if (ctxt->state != NULL) {

	mov	ecx, DWORD PTR [esi+60]
	test	ecx, ecx
	je	SHORT $LN54@xmlRelaxNG

; 9474 :             cur = ctxt->state->seq;
; 9475 :             cur = xmlRelaxNGSkipIgnored(ctxt, cur);

	push	DWORD PTR [ecx+4]
	push	esi
	call	_xmlRelaxNGSkipIgnored
	mov	ebx, eax

; 9476 :             xmlRelaxNGFreeValidState(ctxt, oldstate);

	push	edi
	push	esi
	mov	DWORD PTR _cur$4$[ebp], ebx
	call	_xmlRelaxNGFreeValidState

; 9477 :             oldstate = ctxt->state;

	mov	edi, DWORD PTR [esi+60]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _oldstate$1$[ebp], edi

; 9478 :             ctxt->state = NULL;

	mov	DWORD PTR [esi+60], 0

; 9479 :             if (cur != NULL) {

	test	ebx, ebx
	je	$LN71@xmlRelaxNG

; 9480 :                 VALID_ERR2(XML_RELAXNG_ERR_INTEREXTRA, cur->name);

	push	0
	push	0
	push	DWORD PTR [ebx+8]
	push	12					; 0000000cH
	push	esi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 9481 :                 ret = -1;
; 9482 :                 ctxt->state = oldstate;

	mov	DWORD PTR [esi+60], edi

; 9483 :                 goto done;

	jmp	$LN213@xmlRelaxNG
$LN54@xmlRelaxNG:

; 9484 :             }
; 9485 :         } else if (ctxt->states != NULL) {

	mov	edx, DWORD PTR [esi+64]
	test	edx, edx
	je	$LN57@xmlRelaxNG

; 9486 :             int j;
; 9487 :             int found = 0;
; 9488 : 	    int best = -1;
; 9489 : 	    int lowattr = -1;
; 9490 : 
; 9491 : 	    /*
; 9492 : 	     * PBM: what happen if there is attributes checks in the interleaves
; 9493 : 	     */
; 9494 : 
; 9495 :             for (j = 0; j < ctxt->states->nbState; j++) {

	xor	ebx, ebx
	mov	DWORD PTR _found$1$[ebp], 0
	or	edi, -1
	mov	DWORD PTR _best$1$[ebp], -1
	cmp	DWORD PTR [edx], ebx
	jle	$LN267@xmlRelaxNG
$LL12@xmlRelaxNG:

; 9496 :                 cur = ctxt->states->tabState[j]->seq;

	mov	eax, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [eax+ebx*4]

; 9497 :                 cur = xmlRelaxNGSkipIgnored(ctxt, cur);

	push	DWORD PTR [eax+4]
	push	esi
	call	_xmlRelaxNGSkipIgnored
	add	esp, 8
	mov	DWORD PTR _cur$4$[ebp], eax

; 9498 :                 if (cur == NULL) {

	test	eax, eax
	jne	SHORT $LN59@xmlRelaxNG

; 9499 : 		    if (found == 0) {

	mov	edx, DWORD PTR [esi+64]
	mov	ecx, DWORD PTR [edx+8]
	cmp	DWORD PTR _found$1$[ebp], eax
	jne	SHORT $LN61@xmlRelaxNG

; 9500 : 		        lowattr = ctxt->states->tabState[j]->nbAttrLeft;

	mov	eax, DWORD PTR [ecx+ebx*4]

; 9501 : 			best = j;

	mov	DWORD PTR _best$1$[ebp], ebx
	mov	edi, DWORD PTR [eax+16]
$LN61@xmlRelaxNG:

; 9502 : 		    }
; 9503 :                     found = 1;
; 9504 : 		    if (ctxt->states->tabState[j]->nbAttrLeft <= lowattr) {

	mov	eax, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR _found$1$[ebp], 1
	mov	ecx, DWORD PTR [eax+16]

; 9505 : 		        /* try  to keep the latest one to mach old heuristic */
; 9506 : 		        lowattr = ctxt->states->tabState[j]->nbAttrLeft;
; 9507 : 			best = j;
; 9508 : 		    }
; 9509 :                     if (lowattr == 0)

	cmp	ecx, edi
	mov	eax, ecx
	cmovg	eax, edi
	mov	DWORD PTR tv1976[ebp], eax
	mov	eax, ebx
	cmovg	eax, DWORD PTR _best$1$[ebp]
	mov	edi, DWORD PTR tv1976[ebp]
	mov	DWORD PTR _best$1$[ebp], eax
	test	edi, edi
	je	SHORT $LN267@xmlRelaxNG

; 9510 : 		        break;
; 9511 :                 } else if (found == 0) {

	mov	DWORD PTR _best$1$[ebp], eax
	jmp	SHORT $LN10@xmlRelaxNG
$LN59@xmlRelaxNG:
	cmp	DWORD PTR _found$1$[ebp], 0
	jne	SHORT $LN10@xmlRelaxNG

; 9512 :                     if (lowattr == -1) {

	mov	eax, DWORD PTR [esi+64]
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+16]
	cmp	edi, -1
	je	SHORT $LN272@xmlRelaxNG

; 9513 : 		        lowattr = ctxt->states->tabState[j]->nbAttrLeft;
; 9514 : 			best = j;
; 9515 : 		    } else
; 9516 : 		    if (ctxt->states->tabState[j]->nbAttrLeft <= lowattr)  {

	cmp	eax, edi
	jg	SHORT $LN10@xmlRelaxNG
$LN272@xmlRelaxNG:

; 9486 :             int j;
; 9487 :             int found = 0;
; 9488 : 	    int best = -1;
; 9489 : 	    int lowattr = -1;
; 9490 : 
; 9491 : 	    /*
; 9492 : 	     * PBM: what happen if there is attributes checks in the interleaves
; 9493 : 	     */
; 9494 : 
; 9495 :             for (j = 0; j < ctxt->states->nbState; j++) {

	mov	DWORD PTR _best$1$[ebp], ebx
	mov	edi, eax
$LN10@xmlRelaxNG:
	mov	edx, DWORD PTR [esi+64]
	inc	ebx
	cmp	ebx, DWORD PTR [edx]
	jl	$LL12@xmlRelaxNG
$LN267@xmlRelaxNG:

; 9517 : 		        /* try  to keep the latest one to mach old heuristic */
; 9518 : 		        lowattr = ctxt->states->tabState[j]->nbAttrLeft;
; 9519 : 			best = j;
; 9520 : 		    }
; 9521 : 		}
; 9522 :             }
; 9523 : 	    /*
; 9524 : 	     * BIG PBM: here we pick only one restarting point :-(
; 9525 : 	     */
; 9526 :             if (ctxt->states->nbState > 0) {

	cmp	DWORD PTR [edx], 0
	mov	ebx, DWORD PTR _oldstate$1$[ebp]
	jle	SHORT $LN70@xmlRelaxNG

; 9527 :                 xmlRelaxNGFreeValidState(ctxt, oldstate);

	push	ebx
	push	esi
	call	_xmlRelaxNGFreeValidState

; 9528 : 		if (best != -1) {

	mov	ecx, DWORD PTR _best$1$[ebp]
	add	esp, 8
	mov	eax, DWORD PTR [esi+64]
	cmp	ecx, -1
	je	SHORT $LN69@xmlRelaxNG

; 9529 : 		    oldstate = ctxt->states->tabState[best];

	mov	eax, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [eax+ecx*4]

; 9530 : 		    ctxt->states->tabState[best] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 9531 : 		} else {

	jmp	SHORT $LN274@xmlRelaxNG
$LN69@xmlRelaxNG:

; 9532 : 		    oldstate =

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [eax+ecx*4-4]

; 9533 : 			ctxt->states->tabState[ctxt->states->nbState - 1];
; 9534 :                     ctxt->states->tabState[ctxt->states->nbState - 1] = NULL;

	mov	DWORD PTR [eax+ecx*4-4], 0

; 9535 :                     ctxt->states->nbState--;

	mov	eax, DWORD PTR [esi+64]
	dec	DWORD PTR [eax]
$LN274@xmlRelaxNG:

; 9536 : 		}
; 9537 :             }
; 9538 :             for (j = 0; j < ctxt->states->nbState ; j++) {

	mov	DWORD PTR _oldstate$1$[ebp], ebx
$LN70@xmlRelaxNG:
	mov	eax, DWORD PTR [esi+64]
	xor	edi, edi
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN14@xmlRelaxNG
	npad	7
$LL15@xmlRelaxNG:

; 9539 :                 xmlRelaxNGFreeValidState(ctxt, ctxt->states->tabState[j]);

	mov	eax, DWORD PTR [esi+64]
	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [eax+edi*4]
	push	esi
	call	_xmlRelaxNGFreeValidState
	mov	eax, DWORD PTR [esi+64]
	inc	edi
	add	esp, 8
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL15@xmlRelaxNG
$LN14@xmlRelaxNG:

; 9540 :             }
; 9541 :             xmlRelaxNGFreeStates(ctxt, ctxt->states);

	push	eax
	push	esi
	call	_xmlRelaxNGFreeStates
	add	esp, 8

; 9542 :             ctxt->states = NULL;

	mov	DWORD PTR [esi+64], 0

; 9543 :             if (found == 0) {

	cmp	DWORD PTR _found$1$[ebp], 0
	je	SHORT $LN232@xmlRelaxNG
	mov	edi, DWORD PTR _oldstate$1$[ebp]
$LN71@xmlRelaxNG:

; 9553 :             }
; 9554 :         } else {
; 9555 :             ret = -1;
; 9556 :             break;
; 9557 :         }
; 9558 :         if (lasts[i] != NULL) {

	mov	ebx, DWORD PTR tv1918[ebp]
	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG

; 9559 :             lasts[i]->next = last;

	mov	ecx, DWORD PTR _last$1$[ebp]
	mov	DWORD PTR [eax+24], ecx
$LN7@xmlRelaxNG:

; 9457 :     oldstate = ctxt->state;
; 9458 :     for (i = 0; i < nbgroups; i++) {

	mov	eax, DWORD PTR _i$2$[ebp]
	add	ebx, 4
	inc	eax
	mov	DWORD PTR tv1918[ebp], ebx
	mov	DWORD PTR _i$2$[ebp], eax
	cmp	eax, DWORD PTR _nbgroups$1$[ebp]
	jl	$LL9@xmlRelaxNG

; 9579 :         if ((cur == start) || (cur->prev == NULL))

	mov	ebx, DWORD PTR _ret$1$[ebp]
	jmp	SHORT $LN8@xmlRelaxNG
$LN232@xmlRelaxNG:

; 9544 :                 if (cur == NULL) {

	mov	eax, DWORD PTR _cur$4$[ebp]
	test	eax, eax
	jne	SHORT $LN72@xmlRelaxNG

; 9545 : 		    VALID_ERR2(XML_RELAXNG_ERR_INTEREXTRA,

	mov	eax, OFFSET ??_C@_06LNKFDEGN@noname@

; 9546 : 			       (const xmlChar *) "noname");
; 9547 :                 } else {

	jmp	SHORT $LN73@xmlRelaxNG
$LN72@xmlRelaxNG:

; 9548 :                     VALID_ERR2(XML_RELAXNG_ERR_INTEREXTRA, cur->name);

	mov	eax, DWORD PTR [eax+8]
$LN73@xmlRelaxNG:

; 9549 :                 }
; 9550 :                 ret = -1;

	push	0
	push	0
	push	eax
	push	12					; 0000000cH
	push	esi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 9551 :                 ctxt->state = oldstate;

	mov	DWORD PTR [esi+60], ebx

; 9552 :                 goto done;

	jmp	$LN213@xmlRelaxNG
$LN57@xmlRelaxNG:

; 9560 :         }
; 9561 :     }
; 9562 :     if (ctxt->state != NULL)

	or	ebx, -1
	jmp	SHORT $LN8@xmlRelaxNG
$LN270@xmlRelaxNG:

; 9457 :     oldstate = ctxt->state;
; 9458 :     for (i = 0; i < nbgroups; i++) {

	xor	ebx, ebx
$LN8@xmlRelaxNG:

; 9560 :         }
; 9561 :     }
; 9562 :     if (ctxt->state != NULL)

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN75@xmlRelaxNG

; 9563 :         xmlRelaxNGFreeValidState(ctxt, ctxt->state);

	push	eax
	push	esi
	call	_xmlRelaxNGFreeValidState
	add	esp, 8
$LN75@xmlRelaxNG:

; 9564 :     ctxt->state = oldstate;
; 9565 :     ctxt->state->seq = lastelem;

	mov	eax, DWORD PTR _lastelem$1$[ebp]
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR [edi+4], eax

; 9566 :     if (ret != 0) {

	test	ebx, ebx
	je	SHORT $done$276

; 2371 :     if (ctxt->flags & FLAGS_NOERROR)

	mov	eax, DWORD PTR [esi+28]
	test	al, 8
	jne	SHORT $LN213@xmlRelaxNG
	and	al, 3

; 2372 :         return;
; 2373 : 
; 2374 : #ifdef DEBUG_ERROR
; 2375 :     xmlGenericError(xmlGenericErrorContext, "Adding error %d\n", err);
; 2376 : #endif
; 2377 :     /*
; 2378 :      * generate the error directly
; 2379 :      */
; 2380 :     if (((ctxt->flags & FLAGS_IGNORABLE) == 0) ||

	cmp	al, 1
	jne	SHORT $LN214@xmlRelaxNG

; 2400 :     }
; 2401 :     /*
; 2402 :      * Stack the error for later processing if needed
; 2403 :      */
; 2404 :     else {
; 2405 :         xmlRelaxNGValidErrorPush(ctxt, err, arg1, arg2, dup);

	push	0
	push	0
	push	0
	push	11					; 0000000bH
	push	esi
	call	_xmlRelaxNGValidErrorPush
	add	esp, 20					; 00000014H
	jmp	SHORT $LN213@xmlRelaxNG
$LN214@xmlRelaxNG:

; 2381 : 	 (ctxt->flags & FLAGS_NEGATIVE)) {
; 2382 :         xmlNodePtr node, seq;
; 2383 : 
; 2384 :         /*
; 2385 :          * Flush first any stacked error which might be the
; 2386 :          * real cause of the problem.
; 2387 :          */
; 2388 :         if (ctxt->errNr != 0)

	cmp	DWORD PTR [esi+48], 0
	je	SHORT $LN215@xmlRelaxNG

; 2389 :             xmlRelaxNGDumpValidError(ctxt);

	push	esi
	call	_xmlRelaxNGDumpValidError
	add	esp, 4
$LN215@xmlRelaxNG:

; 2390 :         if (ctxt->state != NULL) {

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN216@xmlRelaxNG

; 2391 :             node = ctxt->state->node;

	mov	ecx, DWORD PTR [eax]

; 2392 :             seq = ctxt->state->seq;

	mov	eax, DWORD PTR [eax+4]

; 2395 :         }
; 2396 :         if ((node == NULL) && (seq == NULL)) {

	test	ecx, ecx
	jne	SHORT $LN218@xmlRelaxNG
	test	eax, eax
	jne	SHORT $LN218@xmlRelaxNG
	jmp	SHORT $LN255@xmlRelaxNG
$LN216@xmlRelaxNG:

; 2393 :         } else {
; 2394 :             node = seq = NULL;

	xor	eax, eax
$LN255@xmlRelaxNG:

; 2397 :             node = ctxt->pnode;

	mov	ecx, DWORD PTR [esi+104]
$LN218@xmlRelaxNG:

; 2398 :         }
; 2399 :         xmlRelaxNGShowValidError(ctxt, err, node, seq, arg1, arg2);

	push	0
	push	0
	push	eax
	push	ecx
	push	11					; 0000000bH
	push	esi
	call	_xmlRelaxNGShowValidError
	add	esp, 24					; 00000018H
$LN213@xmlRelaxNG:

; 9567 :         VALID_ERR(XML_RELAXNG_ERR_INTERSEQ);
; 9568 :         ret = -1;
; 9569 :         goto done;
; 9570 :     }
; 9571 : 
; 9572 :   done:
; 9573 :     ctxt->flags = oldflags;

	or	ebx, -1
$done$276:

; 9574 :     /*
; 9575 :      * builds the next links chain from the prev one
; 9576 :      */
; 9577 :     cur = lastchg;
; 9578 :     while (cur != NULL) {

	mov	edx, DWORD PTR _cur$5$[ebp]
	mov	eax, DWORD PTR _oldflags$1$[ebp]
	mov	DWORD PTR [esi+28], eax
	test	edx, edx
	je	SHORT $LN268@xmlRelaxNG
	mov	edi, DWORD PTR _start$1$[ebp]
	npad	6
$LL16@xmlRelaxNG:

; 9579 :         if ((cur == start) || (cur->prev == NULL))

	cmp	edx, edi
	je	SHORT $LN268@xmlRelaxNG
	mov	ecx, DWORD PTR [edx+28]
	test	ecx, ecx
	je	SHORT $LN268@xmlRelaxNG

; 9580 :             break;
; 9581 :         cur->prev->next = cur;

	mov	DWORD PTR [ecx+24], edx

; 9582 :         cur = cur->prev;

	mov	edx, DWORD PTR [edx+28]
	test	edx, edx
	jne	SHORT $LL16@xmlRelaxNG
$LN268@xmlRelaxNG:

; 9583 :     }
; 9584 :     if (ret == 0) {

	test	ebx, ebx
	jne	SHORT $LN80@xmlRelaxNG

; 9585 :         if (ctxt->errNr > errNr)

	mov	eax, DWORD PTR _errNr$1$[ebp]
	cmp	DWORD PTR [esi+48], eax
	jle	SHORT $LN80@xmlRelaxNG

; 9586 :             xmlRelaxNGPopErrors(ctxt, errNr);

	push	eax
	push	esi
	call	_xmlRelaxNGPopErrors
	add	esp, 8
$LN80@xmlRelaxNG:

; 9587 :     }
; 9588 : 
; 9589 :     xmlFree(list);

	push	DWORD PTR _list$1$[ebp]
	call	DWORD PTR _xmlFree

; 9590 :     xmlFree(lasts);

	push	DWORD PTR _lasts$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 8

; 9591 :     return (ret);

	mov	eax, ebx
	pop	edi
	pop	esi

; 9592 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlRelaxNG:

; 9325 :     } else {
; 9326 :         VALID_ERR(XML_RELAXNG_ERR_INTERNODATA);

	push	0
	push	0
	push	0
	push	10					; 0000000aH
	push	esi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 9327 :         return (-1);

	or	eax, -1
	pop	esi

; 9592 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGValidateInterleave ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGNodeMatchesList
_TEXT	SEGMENT
_node$ = 8						; size = 4
_list$ = 12						; size = 4
_xmlRelaxNGNodeMatchesList PROC				; COMDAT

; 9272 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	SHORT $LN5@xmlRelaxNG

; 9273 :     xmlRelaxNGDefinePtr cur;
; 9274 :     int i = 0, tmp;
; 9275 : 
; 9276 :     if ((node == NULL) || (list == NULL))

	mov	esi, DWORD PTR _list$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlRelaxNG

; 9278 : 
; 9279 :     cur = list[i++];

	mov	eax, DWORD PTR [esi]

; 9280 :     while (cur != NULL) {

	test	eax, eax
	je	SHORT $LN5@xmlRelaxNG

; 9278 : 
; 9279 :     cur = list[i++];

	add	esi, 4
$LL2@xmlRelaxNG:

; 9281 :         if ((node->type == XML_ELEMENT_NODE) &&

	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, 1
	jne	SHORT $LN18@xmlRelaxNG
	cmp	DWORD PTR [eax], 4
	jne	SHORT $LN9@xmlRelaxNG

; 9282 :             (cur->type == XML_RELAXNG_ELEMENT)) {
; 9283 :             tmp = xmlRelaxNGElementMatch(NULL, cur, node);

	push	edi
	push	eax
	push	0
	call	_xmlRelaxNGElementMatch
	add	esp, 12					; 0000000cH

; 9284 :             if (tmp == 1)

	cmp	eax, 1

; 9285 :                 return (1);
; 9286 :         } else if (((node->type == XML_TEXT_NODE) ||

	jmp	SHORT $LN21@xmlRelaxNG
$LN18@xmlRelaxNG:

; 9287 :                     (node->type == XML_CDATA_SECTION_NODE)) &&

	cmp	ecx, 3
	je	SHORT $LN10@xmlRelaxNG
	cmp	ecx, 4
	jne	SHORT $LN9@xmlRelaxNG
$LN10@xmlRelaxNG:
	mov	eax, DWORD PTR [eax]
	cmp	eax, 5
	je	SHORT $LN15@xmlRelaxNG
	cmp	eax, 8
	je	SHORT $LN15@xmlRelaxNG
	cmp	eax, 3
	je	SHORT $LN15@xmlRelaxNG
	cmp	eax, 7
$LN21@xmlRelaxNG:

; 9293 :         }
; 9294 :         cur = list[i++];

	je	SHORT $LN15@xmlRelaxNG
$LN9@xmlRelaxNG:
	mov	eax, DWORD PTR [esi]
	add	esi, 4
	test	eax, eax
	jne	SHORT $LL2@xmlRelaxNG
$LN5@xmlRelaxNG:
	pop	edi

; 9277 :         return (0);

	xor	eax, eax

; 9295 :     }
; 9296 :     return (0);
; 9297 : }

	pop	esi
	pop	ebp
	ret	0
$LN15@xmlRelaxNG:
	pop	edi

; 9288 :                    ((cur->type == XML_RELAXNG_DATATYPE) ||
; 9289 : 		    (cur->type == XML_RELAXNG_LIST) ||
; 9290 :                     (cur->type == XML_RELAXNG_TEXT) ||
; 9291 :                     (cur->type == XML_RELAXNG_VALUE))) {
; 9292 :             return (1);

	mov	eax, 1

; 9295 :     }
; 9296 :     return (0);
; 9297 : }

	pop	esi
	pop	ebp
	ret	0
_xmlRelaxNGNodeMatchesList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidateAttribute
_TEXT	SEGMENT
_oldseq$1$ = -8						; size = 4
_oldvalue$2$ = -8					; size = 4
_oldseq$2$ = -4						; size = 4
_oldvalue$1$ = -4					; size = 4
_value$4$ = 8						; size = 4
_value$2$ = 8						; size = 4
_ret$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_define$ = 12						; size = 4
_xmlRelaxNGValidateAttribute PROC			; COMDAT

; 9115 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+60]
	cmp	DWORD PTR [eax+16], 0
	jg	SHORT $LN8@xmlRelaxNG

; 9116 :     int ret = 0, i;
; 9117 :     xmlChar *value, *oldvalue;
; 9118 :     xmlAttrPtr prop = NULL, tmp;
; 9119 :     xmlNodePtr oldseq;
; 9120 : 
; 9121 :     if (ctxt->state->nbAttrLeft <= 0)
; 9122 :         return (-1);

	or	eax, -1
	pop	esi

; 9211 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlRelaxNG:

; 9123 :     if (define->name != NULL) {

	mov	ecx, DWORD PTR _define$[ebp]
	mov	edx, DWORD PTR [eax+8]
	push	ebx
	push	edi
	cmp	DWORD PTR [ecx+8], 0
	je	$LN9@xmlRelaxNG

; 9124 :         for (i = 0; i < ctxt->state->nbAttrs; i++) {

	xor	ebx, ebx
	test	edx, edx
	jle	SHORT $LN41@xmlRelaxNG
	npad	3
$LL4@xmlRelaxNG:

; 9125 :             tmp = ctxt->state->attrs[i];

	mov	eax, DWORD PTR [eax+28]
	mov	edi, DWORD PTR [eax+ebx*4]

; 9126 :             if ((tmp != NULL) && (xmlStrEqual(define->name, tmp->name))) {

	test	edi, edi
	je	SHORT $LN2@xmlRelaxNG
	push	DWORD PTR [edi+8]
	push	DWORD PTR [ecx+8]
	call	_xmlStrEqual
	mov	ecx, DWORD PTR _define$[ebp]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@xmlRelaxNG

; 9127 :                 if ((((define->ns == NULL) || (define->ns[0] == 0)) &&
; 9128 :                      (tmp->ns == NULL)) ||

	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	je	SHORT $LN35@xmlRelaxNG
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN39@xmlRelaxNG
$LN35@xmlRelaxNG:
	cmp	DWORD PTR [edi+36], 0
	je	SHORT $LN13@xmlRelaxNG
$LN39@xmlRelaxNG:
	mov	edx, DWORD PTR [edi+36]
	test	edx, edx
	je	SHORT $LN2@xmlRelaxNG
	push	DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlRelaxNG

; 9126 :             if ((tmp != NULL) && (xmlStrEqual(define->name, tmp->name))) {

	mov	ecx, DWORD PTR _define$[ebp]
$LN2@xmlRelaxNG:

; 9124 :         for (i = 0; i < ctxt->state->nbAttrs; i++) {

	mov	eax, DWORD PTR [esi+60]
	inc	ebx
	cmp	ebx, DWORD PTR [eax+8]
	jl	SHORT $LL4@xmlRelaxNG
$LN41@xmlRelaxNG:

; 9192 :                 ctxt->state->nbAttrLeft--;
; 9193 :             }
; 9194 :         } else {
; 9195 :             ret = -1;
; 9196 :         }
; 9197 : #ifdef DEBUG
; 9198 :         if (define->ns != NULL) {
; 9199 :             xmlGenericError(xmlGenericErrorContext,
; 9200 :                             "xmlRelaxNGValidateAttribute(nsName ns = %s): %d\n",
; 9201 :                             define->ns, ret);
; 9202 :         } else {
; 9203 :             xmlGenericError(xmlGenericErrorContext,
; 9204 :                             "xmlRelaxNGValidateAttribute(anyName): %d\n",
; 9205 :                             ret);
; 9206 :         }
; 9207 : #endif
; 9208 :     }
; 9209 : 
; 9210 :     return (ret);

	or	ecx, -1
$LN23@xmlRelaxNG:
	pop	edi
	pop	ebx
	mov	eax, ecx
	pop	esi

; 9211 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlRelaxNG:

; 9129 :                     ((tmp->ns != NULL) &&
; 9130 :                      (xmlStrEqual(define->ns, tmp->ns->href)))) {
; 9131 :                     prop = tmp;
; 9132 :                     break;
; 9133 :                 }
; 9134 :             }
; 9135 :         }
; 9136 :         if (prop != NULL) {
; 9137 :             value = xmlNodeListGetString(prop->doc, prop->children, 1);

	push	1
	push	DWORD PTR [edi+12]
	push	DWORD PTR [edi+32]
	call	_xmlNodeListGetString
	mov	DWORD PTR _value$2$[ebp], eax

; 9138 :             oldvalue = ctxt->state->value;

	mov	eax, DWORD PTR [esi+60]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _oldvalue$1$[ebp], ecx

; 9139 :             oldseq = ctxt->state->seq;

	mov	ecx, DWORD PTR [eax+4]

; 9140 :             ctxt->state->seq = (xmlNodePtr) prop;

	mov	DWORD PTR [eax+4], edi

; 9141 :             ctxt->state->value = value;

	mov	eax, DWORD PTR [esi+60]
	mov	edi, DWORD PTR _value$2$[ebp]
	mov	DWORD PTR _oldseq$1$[ebp], ecx
	mov	DWORD PTR [eax+20], edi

; 9142 :             ctxt->state->endvalue = NULL;

	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [eax+24], 0

; 9143 :             ret = xmlRelaxNGValidateValueContent(ctxt, define->content);

	mov	eax, DWORD PTR _define$[ebp]
	push	DWORD PTR [eax+24]
	push	esi
	call	_xmlRelaxNGValidateValueContent

; 9144 :             if (ctxt->state->value != NULL)

	mov	edx, DWORD PTR [esi+60]
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret$1$[ebp], eax
	mov	ecx, DWORD PTR [edx+20]
	test	ecx, ecx
	cmovne	edi, ecx

; 9145 :                 value = ctxt->state->value;
; 9146 :             if (value != NULL)

	test	edi, edi
	je	SHORT $LN19@xmlRelaxNG

; 9147 :                 xmlFree(value);

	push	edi
	call	DWORD PTR _xmlFree
	mov	edx, DWORD PTR [esi+60]
	add	esp, 4
$LN19@xmlRelaxNG:

; 9148 :             ctxt->state->value = oldvalue;

	mov	eax, DWORD PTR _oldvalue$1$[ebp]

; 9149 :             ctxt->state->seq = oldseq;

	mov	ecx, DWORD PTR _oldseq$1$[ebp]
	mov	DWORD PTR [edx+20], eax
	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [eax+4], ecx

; 9150 :             if (ret == 0) {

	mov	ecx, DWORD PTR _ret$1$[ebp]
	test	ecx, ecx
	jne	$LN23@xmlRelaxNG

; 9151 :                 /*
; 9152 :                  * flag the attribute as processed
; 9153 :                  */
; 9154 :                 ctxt->state->attrs[i] = NULL;

	mov	eax, DWORD PTR [esi+60]

; 9192 :                 ctxt->state->nbAttrLeft--;
; 9193 :             }
; 9194 :         } else {
; 9195 :             ret = -1;
; 9196 :         }
; 9197 : #ifdef DEBUG
; 9198 :         if (define->ns != NULL) {
; 9199 :             xmlGenericError(xmlGenericErrorContext,
; 9200 :                             "xmlRelaxNGValidateAttribute(nsName ns = %s): %d\n",
; 9201 :                             define->ns, ret);
; 9202 :         } else {
; 9203 :             xmlGenericError(xmlGenericErrorContext,
; 9204 :                             "xmlRelaxNGValidateAttribute(anyName): %d\n",
; 9205 :                             ret);
; 9206 :         }
; 9207 : #endif
; 9208 :     }
; 9209 : 
; 9210 :     return (ret);

	pop	edi
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR [eax+ebx*4], ecx
	mov	eax, DWORD PTR [esi+60]
	pop	ebx
	pop	esi
	dec	DWORD PTR [eax+16]
	mov	eax, ecx

; 9211 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlRelaxNG:

; 9155 :                 ctxt->state->nbAttrLeft--;
; 9156 :             }
; 9157 :         } else {
; 9158 :             ret = -1;
; 9159 :         }
; 9160 : #ifdef DEBUG
; 9161 :         xmlGenericError(xmlGenericErrorContext,
; 9162 :                         "xmlRelaxNGValidateAttribute(%s): %d\n",
; 9163 :                         define->name, ret);
; 9164 : #endif
; 9165 :     } else {
; 9166 :         for (i = 0; i < ctxt->state->nbAttrs; i++) {

	xor	edi, edi
	test	edx, edx
	jle	$LN41@xmlRelaxNG
	npad	1
$LL7@xmlRelaxNG:

; 9167 :             tmp = ctxt->state->attrs[i];

	mov	eax, DWORD PTR [eax+28]
	mov	ebx, DWORD PTR [eax+edi*4]

; 9168 :             if ((tmp != NULL) &&

	test	ebx, ebx
	je	SHORT $LN5@xmlRelaxNG
	push	ebx
	push	ecx
	push	esi
	call	_xmlRelaxNGAttributeMatch
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $LN30@xmlRelaxNG
	mov	ecx, DWORD PTR _define$[ebp]
$LN5@xmlRelaxNG:

; 9155 :                 ctxt->state->nbAttrLeft--;
; 9156 :             }
; 9157 :         } else {
; 9158 :             ret = -1;
; 9159 :         }
; 9160 : #ifdef DEBUG
; 9161 :         xmlGenericError(xmlGenericErrorContext,
; 9162 :                         "xmlRelaxNGValidateAttribute(%s): %d\n",
; 9163 :                         define->name, ret);
; 9164 : #endif
; 9165 :     } else {
; 9166 :         for (i = 0; i < ctxt->state->nbAttrs; i++) {

	mov	eax, DWORD PTR [esi+60]
	inc	edi
	cmp	edi, DWORD PTR [eax+8]
	jl	SHORT $LL7@xmlRelaxNG

; 9192 :                 ctxt->state->nbAttrLeft--;
; 9193 :             }
; 9194 :         } else {
; 9195 :             ret = -1;
; 9196 :         }
; 9197 : #ifdef DEBUG
; 9198 :         if (define->ns != NULL) {
; 9199 :             xmlGenericError(xmlGenericErrorContext,
; 9200 :                             "xmlRelaxNGValidateAttribute(nsName ns = %s): %d\n",
; 9201 :                             define->ns, ret);
; 9202 :         } else {
; 9203 :             xmlGenericError(xmlGenericErrorContext,
; 9204 :                             "xmlRelaxNGValidateAttribute(anyName): %d\n",
; 9205 :                             ret);
; 9206 :         }
; 9207 : #endif
; 9208 :     }
; 9209 : 
; 9210 :     return (ret);

	pop	edi
	or	ecx, -1
	pop	ebx
	mov	eax, ecx
	pop	esi

; 9211 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@xmlRelaxNG:

; 9169 :                 (xmlRelaxNGAttributeMatch(ctxt, define, tmp) == 1)) {
; 9170 :                 prop = tmp;
; 9171 :                 break;
; 9172 :             }
; 9173 :         }
; 9174 :         if (prop != NULL) {
; 9175 :             value = xmlNodeListGetString(prop->doc, prop->children, 1);

	push	1
	push	DWORD PTR [ebx+12]
	push	DWORD PTR [ebx+32]
	call	_xmlNodeListGetString

; 9176 :             oldvalue = ctxt->state->value;

	mov	ecx, DWORD PTR [esi+60]
	mov	DWORD PTR _value$4$[ebp], eax
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR _oldvalue$2$[ebp], eax

; 9177 :             oldseq = ctxt->state->seq;

	mov	eax, DWORD PTR [ecx+4]

; 9178 :             ctxt->state->seq = (xmlNodePtr) prop;

	mov	DWORD PTR [ecx+4], ebx

; 9179 :             ctxt->state->value = value;

	mov	ecx, DWORD PTR [esi+60]
	mov	ebx, DWORD PTR _value$4$[ebp]
	mov	DWORD PTR _oldseq$2$[ebp], eax

; 9180 :             ret = xmlRelaxNGValidateValueContent(ctxt, define->content);

	mov	eax, DWORD PTR _define$[ebp]
	mov	DWORD PTR [ecx+20], ebx
	push	DWORD PTR [eax+24]
	push	esi
	call	_xmlRelaxNGValidateValueContent

; 9181 :             if (ctxt->state->value != NULL)

	mov	ecx, DWORD PTR [esi+60]
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	cmovne	ebx, eax

; 9182 :                 value = ctxt->state->value;
; 9183 :             if (value != NULL)

	test	ebx, ebx
	je	SHORT $LN25@xmlRelaxNG

; 9184 :                 xmlFree(value);

	push	ebx
	call	DWORD PTR _xmlFree
	mov	ecx, DWORD PTR [esi+60]
	add	esp, 4
$LN25@xmlRelaxNG:

; 9185 :             ctxt->state->value = oldvalue;

	mov	eax, DWORD PTR _oldvalue$2$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 9186 :             ctxt->state->seq = oldseq;

	mov	eax, DWORD PTR [esi+60]
	mov	ecx, DWORD PTR _oldseq$2$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 9187 :             if (ret == 0) {

	mov	ecx, DWORD PTR _ret$1$[ebp]
	test	ecx, ecx
	jne	$LN23@xmlRelaxNG

; 9188 :                 /*
; 9189 :                  * flag the attribute as processed
; 9190 :                  */
; 9191 :                 ctxt->state->attrs[i] = NULL;

	mov	eax, DWORD PTR [esi+60]
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR [eax+edi*4], ecx

; 9192 :                 ctxt->state->nbAttrLeft--;
; 9193 :             }
; 9194 :         } else {
; 9195 :             ret = -1;
; 9196 :         }
; 9197 : #ifdef DEBUG
; 9198 :         if (define->ns != NULL) {
; 9199 :             xmlGenericError(xmlGenericErrorContext,
; 9200 :                             "xmlRelaxNGValidateAttribute(nsName ns = %s): %d\n",
; 9201 :                             define->ns, ret);
; 9202 :         } else {
; 9203 :             xmlGenericError(xmlGenericErrorContext,
; 9204 :                             "xmlRelaxNGValidateAttribute(anyName): %d\n",
; 9205 :                             ret);
; 9206 :         }
; 9207 : #endif
; 9208 :     }
; 9209 : 
; 9210 :     return (ret);

	mov	eax, DWORD PTR [esi+60]
	pop	edi
	pop	ebx
	pop	esi
	dec	DWORD PTR [eax+16]
	mov	eax, ecx

; 9211 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGValidateAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGAttributeMatch
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_define$ = 12						; size = 4
_prop$ = 16						; size = 4
_xmlRelaxNGAttributeMatch PROC				; COMDAT

; 9053 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _define$[ebp]
	mov	edi, DWORD PTR _prop$[ebp]
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG

; 9054 :     int ret;
; 9055 : 
; 9056 :     if (define->name != NULL) {
; 9057 :         if (!xmlStrEqual(define->name, prop->name))

	push	DWORD PTR [edi+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN5@xmlRelaxNG
$LN7@xmlRelaxNG:

; 9058 :             return (0);
; 9059 :     }
; 9060 :     if (define->ns != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN12@xmlRelaxNG

; 9061 :         if (define->ns[0] == 0) {

	cmp	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR [edi+36]
	jne	SHORT $LN9@xmlRelaxNG

; 9062 :             if (prop->ns != NULL)

	test	ecx, ecx
	je	SHORT $LN12@xmlRelaxNG

; 9101 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlRelaxNG:

; 9063 :                 return (0);
; 9064 :         } else {
; 9065 :             if ((prop->ns == NULL) ||

	test	ecx, ecx
	je	SHORT $LN5@xmlRelaxNG
	push	DWORD PTR [ecx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlRelaxNG
$LN12@xmlRelaxNG:

; 9066 :                 (!xmlStrEqual(define->ns, prop->ns->href)))
; 9067 :                 return (0);
; 9068 :         }
; 9069 :     }
; 9070 :     if (define->nameClass == NULL)

	mov	esi, DWORD PTR [esi+40]
	test	esi, esi
	je	$LN20@xmlRelaxNG

; 9071 :         return (1);
; 9072 :     define = define->nameClass;
; 9073 :     if (define->type == XML_RELAXNG_EXCEPT) {

	mov	eax, DWORD PTR [esi]
	cmp	eax, 2
	jne	SHORT $LN15@xmlRelaxNG

; 9074 :         xmlRelaxNGDefinePtr list;
; 9075 : 
; 9076 :         list = define->content;

	mov	esi, DWORD PTR [esi+24]

; 9077 :         while (list != NULL) {

	test	esi, esi
	je	$LN20@xmlRelaxNG
	mov	ebx, DWORD PTR _ctxt$[ebp]
	npad	1
$LL2@xmlRelaxNG:

; 9078 :             ret = xmlRelaxNGAttributeMatch(ctxt, list, prop);

	push	edi
	push	esi
	push	ebx
	call	_xmlRelaxNGAttributeMatch
	add	esp, 12					; 0000000cH

; 9079 :             if (ret == 1)

	cmp	eax, 1
	je	SHORT $LN5@xmlRelaxNG

; 9080 :                 return (0);
; 9081 :             if (ret < 0)

	test	eax, eax
	js	SHORT $LN1@xmlRelaxNG

; 9082 :                 return (ret);
; 9083 :             list = list->next;

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL2@xmlRelaxNG

; 9100 :     return (1);

	pop	edi
	lea	eax, DWORD PTR [esi+1]

; 9101 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN15@xmlRelaxNG:

; 9084 :         }
; 9085 :     } else if (define->type == XML_RELAXNG_CHOICE) {

	cmp	eax, 17					; 00000011H
	jne	SHORT $LN19@xmlRelaxNG

; 9086 :         xmlRelaxNGDefinePtr list;
; 9087 : 
; 9088 :         list = define->nameClass;

	mov	esi, DWORD PTR [esi+40]

; 9089 :         while (list != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlRelaxNG
	mov	ebx, DWORD PTR _ctxt$[ebp]
$LL4@xmlRelaxNG:

; 9090 :             ret = xmlRelaxNGAttributeMatch(ctxt, list, prop);

	push	edi
	push	esi
	push	ebx
	call	_xmlRelaxNGAttributeMatch
	add	esp, 12					; 0000000cH

; 9091 :             if (ret == 1)

	cmp	eax, 1
	je	SHORT $LN20@xmlRelaxNG

; 9092 :                 return (1);
; 9093 :             if (ret < 0)

	test	eax, eax
	js	SHORT $LN1@xmlRelaxNG

; 9094 :                 return (ret);
; 9095 :             list = list->next;

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL4@xmlRelaxNG
$LN5@xmlRelaxNG:
	pop	edi

; 9101 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN19@xmlRelaxNG:

; 9096 :         }
; 9097 :         return (0);
; 9098 :     } else {
; 9099 :     TODO}

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	9099					; 0000238bH
	push	OFFSET ??_C@_0GJ@NFABHKPN@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN20@xmlRelaxNG:

; 9100 :     return (1);

	mov	eax, 1
$LN1@xmlRelaxNG:
	pop	edi

; 9101 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlRelaxNGAttributeMatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidateValueContent
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_defines$ = 12						; size = 4
_xmlRelaxNGValidateValueContent PROC			; COMDAT

; 9028 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _defines$[ebp]
	test	esi, esi
	je	SHORT $LN12@xmlRelaxNG
	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	npad	7
$LL2@xmlRelaxNG:

; 9029 :     int ret = 0;
; 9030 : 
; 9031 :     while (defines != NULL) {
; 9032 :         ret = xmlRelaxNGValidateValue(ctxt, defines);

	push	esi
	push	edi
	call	_xmlRelaxNGValidateValue
	add	esp, 8

; 9033 :         if (ret != 0)

	test	eax, eax
	jne	SHORT $LN13@xmlRelaxNG

; 9034 :             break;
; 9035 :         defines = defines->next;

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL2@xmlRelaxNG
$LN13@xmlRelaxNG:
	pop	edi
	pop	esi

; 9038 : }

	pop	ebp
	ret	0
$LN12@xmlRelaxNG:

; 9036 :     }
; 9037 :     return (ret);

	xor	eax, eax
	pop	esi

; 9038 : }

	pop	ebp
	ret	0
_xmlRelaxNGValidateValueContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidateValueList
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_defines$ = 12						; size = 4
_xmlRelaxNGValidateValueList PROC			; COMDAT

; 8715 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _defines$[ebp]
	test	esi, esi
	je	SHORT $LN12@xmlRelaxNG
	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	npad	7
$LL2@xmlRelaxNG:

; 8716 :     int ret = 0;
; 8717 : 
; 8718 :     while (defines != NULL) {
; 8719 :         ret = xmlRelaxNGValidateValue(ctxt, defines);

	push	esi
	push	edi
	call	_xmlRelaxNGValidateValue
	add	esp, 8

; 8720 :         if (ret != 0)

	test	eax, eax
	jne	SHORT $LN13@xmlRelaxNG

; 8721 :             break;
; 8722 :         defines = defines->next;

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL2@xmlRelaxNG
$LN13@xmlRelaxNG:
	pop	edi
	pop	esi

; 8725 : }

	pop	ebp
	ret	0
$LN12@xmlRelaxNG:

; 8723 :     }
; 8724 :     return (ret);

	xor	eax, eax
	pop	esi

; 8725 : }

	pop	ebp
	ret	0
_xmlRelaxNGValidateValueList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGNextValue
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlRelaxNGNextValue PROC				; COMDAT

; 8683 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	esi, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG

; 8684 :     xmlChar *cur;
; 8685 : 
; 8686 :     cur = ctxt->state->value;
; 8687 :     if ((cur == NULL) || (ctxt->state->endvalue == NULL)) {

	mov	edx, DWORD PTR [esi+24]
	test	edx, edx
	je	SHORT $LN7@xmlRelaxNG

; 8690 :         return (0);
; 8691 :     }
; 8692 :     while (*cur != 0)

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN12@xmlRelaxNG
$LL2@xmlRelaxNG:

; 8693 :         cur++;

	inc	eax
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL2@xmlRelaxNG
$LN12@xmlRelaxNG:

; 8694 :     while ((cur != ctxt->state->endvalue) && (*cur == 0))

	cmp	eax, edx
	je	SHORT $LN19@xmlRelaxNG
$LL4@xmlRelaxNG:
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN19@xmlRelaxNG

; 8695 :         cur++;

	inc	eax
	cmp	eax, edx
	jne	SHORT $LL4@xmlRelaxNG
$LN19@xmlRelaxNG:

; 8696 :     if (cur == ctxt->state->endvalue)
; 8697 :         ctxt->state->value = NULL;
; 8698 :     else
; 8699 :         ctxt->state->value = cur;
; 8700 :     return (0);

	xor	ecx, ecx
	cmp	eax, edx
	cmovne	ecx, eax

; 8701 : }

	xor	eax, eax
	mov	DWORD PTR [esi+20], ecx
	pop	esi
	pop	ebp
	ret	0
$LN7@xmlRelaxNG:

; 8688 :         ctxt->state->value = NULL;

	mov	DWORD PTR [esi+20], 0

; 8689 :         ctxt->state->endvalue = NULL;

	mov	eax, DWORD PTR [ecx+60]
	pop	esi
	mov	DWORD PTR [eax+24], 0

; 8701 : }

	xor	eax, eax
	pop	ebp
	ret	0
_xmlRelaxNGNextValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidateDatatype
_TEXT	SEGMENT
_lib$1$ = -8						; size = 4
_result$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_define$ = 16						; size = 4
_node$ = 20						; size = 4
_xmlRelaxNGValidateDatatype PROC			; COMDAT

; 8614 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _define$[ebp]
	mov	DWORD PTR _result$[ebp], 0
	test	esi, esi
	je	$LN5@xmlRelaxNG

; 8615 :     int ret, tmp;
; 8616 :     xmlRelaxNGTypeLibraryPtr lib;
; 8617 :     void *result = NULL;
; 8618 :     xmlRelaxNGDefinePtr cur;
; 8619 : 
; 8620 :     if ((define == NULL) || (define->data == NULL)) {

	mov	edi, DWORD PTR [esi+20]
	mov	DWORD PTR _lib$1$[ebp], edi
	test	edi, edi
	je	$LN5@xmlRelaxNG

; 8621 :         return (-1);
; 8622 :     }
; 8623 :     lib = (xmlRelaxNGTypeLibraryPtr) define->data;
; 8624 :     if (lib->check != NULL) {

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	$LN26@xmlRelaxNG

; 8625 :         if ((define->attrs != NULL) &&

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	je	SHORT $LN8@xmlRelaxNG
	cmp	DWORD PTR [ecx], 6
	jne	SHORT $LN8@xmlRelaxNG

; 8626 :             (define->attrs->type == XML_RELAXNG_PARAM)) {
; 8627 :             ret =

	push	DWORD PTR _node$[ebp]
	lea	ecx, DWORD PTR _result$[ebp]
	push	ecx

; 8628 :                 lib->check(lib->data, define->name, value, &result, node);
; 8629 :         } else {

	jmp	SHORT $LN27@xmlRelaxNG
$LN8@xmlRelaxNG:

; 8630 :             ret = lib->check(lib->data, define->name, value, NULL, node);

	push	DWORD PTR _node$[ebp]
	push	0
$LN27@xmlRelaxNG:

; 8631 :         }
; 8632 :     } else
; 8633 :         ret = -1;
; 8634 :     if (ret < 0) {

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	push	DWORD PTR [esi+8]
	push	DWORD PTR [edi+4]
	call	eax
	mov	ebx, eax
	add	esp, 20					; 00000014H
	test	ebx, ebx
	js	$LN26@xmlRelaxNG

; 8638 :         return (-1);
; 8639 :     } else if (ret == 1) {

	cmp	ebx, 1
	jne	SHORT $LN13@xmlRelaxNG

; 8640 :         ret = 0;

	xor	ebx, ebx
	jmp	SHORT $LN16@xmlRelaxNG
$LN13@xmlRelaxNG:

; 8641 :     } else if (ret == 2) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	1
	cmp	ebx, 2
	jne	SHORT $LN15@xmlRelaxNG

; 8642 :         VALID_ERR2P(XML_RELAXNG_ERR_DUPID, value);

	push	0
	push	DWORD PTR _value$[ebp]
	push	4
	push	ecx
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 8643 :     } else {

	jmp	SHORT $LN16@xmlRelaxNG
$LN15@xmlRelaxNG:

; 8644 :         VALID_ERR3P(XML_RELAXNG_ERR_TYPEVAL, define->name, value);

	push	DWORD PTR _value$[ebp]
	push	DWORD PTR [esi+8]
	push	3
	push	ecx
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 8645 :         ret = -1;

	or	ebx, -1
$LN16@xmlRelaxNG:

; 8646 :     }
; 8647 :     cur = define->attrs;

	mov	esi, DWORD PTR [esi+36]

; 8648 :     while ((ret == 0) && (cur != NULL) && (cur->type == XML_RELAXNG_PARAM)) {

	test	ebx, ebx
	jne	$LN19@xmlRelaxNG
$LL2@xmlRelaxNG:
	test	esi, esi
	je	SHORT $LN3@xmlRelaxNG
	cmp	DWORD PTR [esi], 6
	jne	SHORT $LN3@xmlRelaxNG

; 8649 :         if (lib->facet != NULL) {

	mov	ecx, DWORD PTR [edi+20]
	test	ecx, ecx
	je	SHORT $LN18@xmlRelaxNG

; 8650 :             tmp = lib->facet(lib->data, define->name, cur->name,

	push	DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _define$[ebp]
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR [esi+16]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [eax+8]
	push	DWORD PTR [edi+4]
	call	ecx
	add	esp, 24					; 00000018H

; 8651 :                              cur->value, value, result);
; 8652 :             if (tmp != 0)

	test	eax, eax
	mov	eax, -1
	cmovne	ebx, eax
$LN18@xmlRelaxNG:

; 8653 :                 ret = -1;
; 8654 :         }
; 8655 :         cur = cur->next;

	mov	esi, DWORD PTR [esi+32]
	test	ebx, ebx
	je	SHORT $LL2@xmlRelaxNG

; 8656 :     }
; 8657 :     if ((ret == 0) && (define->content != NULL)) {

	jmp	SHORT $LN19@xmlRelaxNG
$LN3@xmlRelaxNG:
	test	ebx, ebx
	jne	SHORT $LN19@xmlRelaxNG
	mov	ecx, DWORD PTR _define$[ebp]
	cmp	DWORD PTR [ecx+24], ebx
	je	SHORT $LN19@xmlRelaxNG

; 8658 :         const xmlChar *oldvalue, *oldendvalue;
; 8659 : 
; 8660 :         oldvalue = ctxt->state->value;

	mov	ebx, DWORD PTR _ctxt$[ebp]

; 8661 :         oldendvalue = ctxt->state->endvalue;
; 8662 :         ctxt->state->value = (xmlChar *) value;

	mov	edx, DWORD PTR _value$[ebp]
	mov	eax, DWORD PTR [ebx+60]
	mov	esi, DWORD PTR [eax+20]
	mov	edi, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+20], edx

; 8663 :         ctxt->state->endvalue = NULL;

	mov	eax, DWORD PTR [ebx+60]
	mov	DWORD PTR [eax+24], 0

; 8664 :         ret = xmlRelaxNGValidateValue(ctxt, define->content);

	push	DWORD PTR [ecx+24]
	push	ebx
	call	_xmlRelaxNGValidateValue

; 8665 :         ctxt->state->value = (xmlChar *) oldvalue;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	ebx, eax
	add	esp, 8
	mov	eax, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+20], esi

; 8666 :         ctxt->state->endvalue = (xmlChar *) oldendvalue;

	mov	eax, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+24], edi
	mov	edi, DWORD PTR _lib$1$[ebp]
$LN19@xmlRelaxNG:

; 8667 :     }
; 8668 :     if ((result != NULL) && (lib != NULL) && (lib->freef != NULL))

	mov	eax, DWORD PTR _result$[ebp]
	test	eax, eax
	je	SHORT $LN20@xmlRelaxNG
	mov	ecx, DWORD PTR [edi+24]
	test	ecx, ecx
	je	SHORT $LN20@xmlRelaxNG

; 8669 :         lib->freef(lib->data, result);

	push	eax
	push	DWORD PTR [edi+4]
	call	ecx
	add	esp, 8
$LN20@xmlRelaxNG:

; 8670 :     return (ret);
; 8671 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlRelaxNG:

; 8635 :         VALID_ERR2(XML_RELAXNG_ERR_TYPE, define->name);

	push	0
	push	0
	push	DWORD PTR [esi+8]
	push	2
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGAddValidError

; 8636 :         if ((result != NULL) && (lib != NULL) && (lib->freef != NULL))

	mov	ecx, DWORD PTR _result$[ebp]
	add	esp, 20					; 00000014H
	test	ecx, ecx
	je	SHORT $LN5@xmlRelaxNG
	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN5@xmlRelaxNG

; 8637 :             lib->freef(lib->data, result);

	push	ecx
	push	DWORD PTR [edi+4]
	call	eax
	add	esp, 8
$LN5@xmlRelaxNG:

; 8670 :     return (ret);
; 8671 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGValidateDatatype ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGSkipIgnored
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlRelaxNGSkipIgnored PROC				; COMDAT

; 8535 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	SHORT $LN12@xmlRelaxNG
	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	npad	7
$LL2@xmlRelaxNG:

; 8536 :     /*
; 8537 :      * TODO complete and handle entities
; 8538 :      */
; 8539 :     while ((node != NULL) &&

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 8
	je	SHORT $LN6@xmlRelaxNG
	cmp	eax, 7
	je	SHORT $LN6@xmlRelaxNG
	cmp	eax, 19					; 00000013H
	je	SHORT $LN6@xmlRelaxNG
	cmp	eax, 20					; 00000014H
	je	SHORT $LN6@xmlRelaxNG
	cmp	eax, 3
	je	SHORT $LN5@xmlRelaxNG
	cmp	eax, 4
	jne	SHORT $LN15@xmlRelaxNG
$LN5@xmlRelaxNG:
	test	BYTE PTR [edi+28], 4
	jne	SHORT $LN6@xmlRelaxNG
	push	DWORD PTR [esi+40]
	call	_xmlRelaxNGIsBlank
	add	esp, 4
	test	eax, eax
	je	SHORT $LN15@xmlRelaxNG
$LN6@xmlRelaxNG:

; 8540 :            ((node->type == XML_COMMENT_NODE) ||
; 8541 :             (node->type == XML_PI_NODE) ||
; 8542 : 	    (node->type == XML_XINCLUDE_START) ||
; 8543 : 	    (node->type == XML_XINCLUDE_END) ||
; 8544 :             (((node->type == XML_TEXT_NODE) ||
; 8545 :               (node->type == XML_CDATA_SECTION_NODE)) &&
; 8546 :              ((ctxt->flags & FLAGS_MIXED_CONTENT) ||
; 8547 :               (IS_BLANK_NODE(node)))))) {
; 8548 :         node = node->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlRelaxNG
$LN15@xmlRelaxNG:
	pop	edi

; 8549 :     }
; 8550 :     return (node);

	mov	eax, esi
	pop	esi

; 8551 : }

	pop	ebp
	ret	0
$LN12@xmlRelaxNG:

; 8549 :     }
; 8550 :     return (node);

	mov	eax, esi
	pop	esi

; 8551 : }

	pop	ebp
	ret	0
_xmlRelaxNGSkipIgnored ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidateValue
_TEXT	SEGMENT
_oldend$1$ = -4						; size = 4
_oldflags$2$ = -4					; size = 4
_temp$1$ = 8						; size = 4
_temp$1$ = 8						; size = 4
_oldvalue$1$ = 8					; size = 4
_oldflags$1$ = 8					; size = 4
_ctxt$ = 8						; size = 4
_val$1$ = 12						; size = 4
_oldvalue$1$ = 12					; size = 4
_nval$1$ = 12						; size = 4
_define$ = 12						; size = 4
_xmlRelaxNGValidateValue PROC				; COMDAT

; 8739 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	mov	esi, DWORD PTR _define$[ebp]
	mov	edx, DWORD PTR [edi+60]
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR _oldvalue$1$[ebp], ecx
	cmp	eax, 18					; 00000012H
	ja	$LN85@xmlRelaxNG

; 8740 :     int ret = 0, oldflags;
; 8741 :     xmlChar *value;
; 8742 : 
; 8743 :     value = ctxt->state->value;
; 8744 :     switch (define->type) {

	jmp	DWORD PTR $LN143@xmlRelaxNG[eax*4]
$LN22@xmlRelaxNG:

; 8745 :         case XML_RELAXNG_EMPTY:{
; 8746 :                 if ((value != NULL) && (value[0] != 0)) {

	test	ecx, ecx
	je	$LN2@xmlRelaxNG
	mov	al, BYTE PTR [ecx]
	test	al, al
	je	$LN2@xmlRelaxNG
$LL4@xmlRelaxNG:

; 8747 :                     int idx = 0;
; 8748 : 
; 8749 :                     while (IS_BLANK_CH(value[idx]))

	cmp	al, 32					; 00000020H
	je	SHORT $LN24@xmlRelaxNG
	cmp	al, 9
	jb	SHORT $LN25@xmlRelaxNG
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN24@xmlRelaxNG
$LN25@xmlRelaxNG:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN5@xmlRelaxNG
$LN24@xmlRelaxNG:

; 8750 :                         idx++;

	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	jmp	SHORT $LL4@xmlRelaxNG
$LN5@xmlRelaxNG:

; 8751 :                     if (value[idx] != 0)

	test	al, al
	je	$LN2@xmlRelaxNG

; 9012 :     }
; 9013 :     return (ret);

	pop	edi
	or	ebx, -1

; 9014 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlRelaxNG:

; 8752 :                         ret = -1;
; 8753 :                 }
; 8754 :                 break;
; 8755 :             }
; 8756 :         case XML_RELAXNG_TEXT:
; 8757 :             break;
; 8758 :         case XML_RELAXNG_VALUE:{
; 8759 :                 if (!xmlStrEqual(value, define->value)) {

	push	DWORD PTR [esi+16]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN128@xmlRelaxNG

; 8760 :                     if (define->name != NULL) {

	cmp	DWORD PTR [esi+8], ebx
	je	SHORT $LN30@xmlRelaxNG

; 8761 :                         xmlRelaxNGTypeLibraryPtr lib;
; 8762 : 
; 8763 :                         lib = (xmlRelaxNGTypeLibraryPtr) define->data;

	mov	edx, DWORD PTR [esi+20]

; 8764 :                         if ((lib != NULL) && (lib->comp != NULL)) {

	test	edx, edx
	je	SHORT $LN129@xmlRelaxNG
	mov	ebx, DWORD PTR [edx+16]
	test	ebx, ebx
	je	SHORT $LN129@xmlRelaxNG

; 8765 :                             ret = lib->comp(lib->data, define->name,

	mov	eax, DWORD PTR [edi+60]
	mov	ecx, DWORD PTR _oldvalue$1$[ebp]
	push	DWORD PTR [eax]
	push	ecx
	push	DWORD PTR [esi+36]
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi+16]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [edx+4]
	call	ebx
	mov	ebx, eax
	add	esp, 28					; 0000001cH

; 8766 :                                             define->value, define->node,
; 8767 :                                             (void *) define->attrs,
; 8768 :                                             value, ctxt->state->node);
; 8769 :                         } else
; 8770 :                             ret = -1;
; 8771 :                         if (ret < 0) {

	test	ebx, ebx
	js	SHORT $LN129@xmlRelaxNG

; 8775 :                         } else if (ret == 1) {
; 8776 :                             ret = 0;
; 8777 :                         } else {
; 8778 :                             ret = -1;
; 8779 :                         }
; 8780 :                     } else {

	dec	ebx
	neg	ebx
	sbb	ebx, ebx
	jmp	SHORT $LN41@xmlRelaxNG
$LN129@xmlRelaxNG:

; 8772 :                             VALID_ERR2(XML_RELAXNG_ERR_TYPECMP,

	push	0
	push	0
	push	DWORD PTR [esi+8]
	push	5
	push	edi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 8773 :                                        define->name);
; 8774 :                             return (-1);

	or	eax, -1
	pop	edi

; 9014 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@xmlRelaxNG:

; 8781 :                         xmlChar *nval, *nvalue;
; 8782 : 
; 8783 :                         /*
; 8784 :                          * TODO: trivial optimizations are possible by
; 8785 :                          * computing at compile-time
; 8786 :                          */
; 8787 :                         nval = xmlRelaxNGNormalize(ctxt, define->value);

	push	DWORD PTR [esi+16]
	push	edi
	call	_xmlRelaxNGNormalize

; 8788 :                         nvalue = xmlRelaxNGNormalize(ctxt, value);

	mov	ecx, DWORD PTR _oldvalue$1$[ebp]
	push	ecx
	push	edi
	mov	DWORD PTR _nval$1$[ebp], eax
	call	_xmlRelaxNGNormalize
	mov	esi, eax
	add	esp, 16					; 00000010H

; 8789 : 
; 8790 :                         if ((nval == NULL) || (nvalue == NULL) ||

	mov	eax, DWORD PTR _nval$1$[ebp]
	test	eax, eax
	je	SHORT $LN39@xmlRelaxNG
	test	esi, esi
	je	SHORT $LN39@xmlRelaxNG
	push	esi
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN38@xmlRelaxNG
$LN39@xmlRelaxNG:

; 8791 :                             (!xmlStrEqual(nval, nvalue)))
; 8792 :                             ret = -1;

	or	ebx, -1
$LN38@xmlRelaxNG:

; 8793 :                         if (nval != NULL)

	mov	eax, DWORD PTR _nval$1$[ebp]
	test	eax, eax
	je	SHORT $LN40@xmlRelaxNG

; 8794 :                             xmlFree(nval);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN40@xmlRelaxNG:

; 8795 :                         if (nvalue != NULL)

	test	esi, esi
	je	SHORT $LN41@xmlRelaxNG

; 8796 :                             xmlFree(nvalue);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN41@xmlRelaxNG:

; 9012 :     }
; 9013 :     return (ret);

	test	ebx, ebx
	jne	$LN2@xmlRelaxNG
$LN128@xmlRelaxNG:
	push	edi
	call	_xmlRelaxNGNextValue
	add	esp, 4
	mov	eax, ebx
	pop	edi

; 9014 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@xmlRelaxNG:

; 8797 :                     }
; 8798 :                 }
; 8799 :                 if (ret == 0)
; 8800 :                     xmlRelaxNGNextValue(ctxt);
; 8801 :                 break;
; 8802 :             }
; 8803 :         case XML_RELAXNG_DATATYPE:{
; 8804 :                 ret = xmlRelaxNGValidateDatatype(ctxt, value, define,

	push	DWORD PTR [edx+4]
	push	esi
	push	ecx
	push	edi
	call	_xmlRelaxNGValidateDatatype
	add	esp, 16					; 00000010H
	mov	ebx, eax

; 8805 :                                                  ctxt->state->seq);
; 8806 :                 if (ret == 0)
; 8807 :                     xmlRelaxNGNextValue(ctxt);
; 8808 : 
; 8809 :                 break;

	jmp	SHORT $LN41@xmlRelaxNG
$LN45@xmlRelaxNG:

; 8810 :             }
; 8811 :         case XML_RELAXNG_CHOICE:{
; 8812 :                 xmlRelaxNGDefinePtr list = define->content;
; 8813 :                 xmlChar *oldvalue;
; 8814 : 
; 8815 :                 oldflags = ctxt->flags;

	mov	ecx, DWORD PTR [edi+28]

; 8816 :                 ctxt->flags |= FLAGS_IGNORABLE;

	mov	eax, ecx
	mov	esi, DWORD PTR [esi+24]
	or	eax, 1
	mov	DWORD PTR [edi+28], eax

; 8817 : 
; 8818 :                 oldvalue = ctxt->state->value;

	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _oldflags$1$[ebp], ecx
	mov	DWORD PTR _oldvalue$1$[ebp], eax

; 8819 :                 while (list != NULL) {

	test	esi, esi
	je	SHORT $LN97@xmlRelaxNG
	npad	6
$LL6@xmlRelaxNG:

; 8820 :                     ret = xmlRelaxNGValidateValue(ctxt, list);

	push	esi
	push	edi
	call	_xmlRelaxNGValidateValue
	mov	ebx, eax
	add	esp, 8

; 8821 :                     if (ret == 0) {

	test	ebx, ebx
	je	SHORT $LN138@xmlRelaxNG

; 8822 :                         break;
; 8823 :                     }
; 8824 :                     ctxt->state->value = oldvalue;

	mov	eax, DWORD PTR [edi+60]
	mov	ecx, DWORD PTR _oldvalue$1$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 8825 :                     list = list->next;

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL6@xmlRelaxNG
$LN138@xmlRelaxNG:
	mov	ecx, DWORD PTR _oldflags$1$[ebp]
$LN97@xmlRelaxNG:

; 8826 :                 }
; 8827 :                 ctxt->flags = oldflags;

	mov	DWORD PTR [edi+28], ecx

; 8828 :                 if (ret != 0) {

	test	ebx, ebx
	je	$LN47@xmlRelaxNG

; 8829 :                     if ((ctxt->flags & FLAGS_IGNORABLE) == 0)

	test	cl, 1
	jne	$LN2@xmlRelaxNG

; 8830 :                         xmlRelaxNGDumpValidError(ctxt);

	push	edi
	call	_xmlRelaxNGDumpValidError

; 9012 :     }
; 9013 :     return (ret);

	add	esp, 4
	mov	eax, ebx
	pop	edi

; 9014 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@xmlRelaxNG:

; 8831 :                 } else {
; 8832 :                     if (ctxt->errNr > 0)
; 8833 :                         xmlRelaxNGPopErrors(ctxt, 0);
; 8834 :                 }
; 8835 :                 break;
; 8836 :             }
; 8837 :         case XML_RELAXNG_LIST:{
; 8838 :                 xmlRelaxNGDefinePtr list = define->content;
; 8839 :                 xmlChar *oldvalue, *oldend, *val, *cur;
; 8840 : 
; 8841 : #ifdef DEBUG_LIST
; 8842 :                 int nb_values = 0;
; 8843 : #endif
; 8844 : 
; 8845 :                 oldvalue = ctxt->state->value;
; 8846 :                 oldend = ctxt->state->endvalue;

	mov	eax, DWORD PTR [edx+24]
	mov	esi, DWORD PTR [esi+24]

; 8847 : 
; 8848 :                 val = xmlStrdup(oldvalue);

	push	ecx
	mov	DWORD PTR _oldend$1$[ebp], eax
	call	_xmlStrdup
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR _val$1$[ebp], edx

; 8849 :                 if (val == NULL) {

	test	edx, edx
	jne	SHORT $LN53@xmlRelaxNG

; 8850 :                     val = xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	mov	edx, eax
	mov	DWORD PTR _val$1$[ebp], eax
	add	esp, 4

; 8851 :                 }
; 8852 :                 if (val == NULL) {

	test	edx, edx
	jne	SHORT $LN53@xmlRelaxNG

; 8853 :                     VALID_ERR(XML_RELAXNG_ERR_NOSTATE);

	push	eax
	push	eax
	push	eax
	push	6
	push	edi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 8854 :                     return (-1);

	or	eax, -1
	pop	edi

; 9014 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@xmlRelaxNG:

; 8855 :                 }
; 8856 :                 cur = val;
; 8857 :                 while (*cur != 0) {

	mov	al, BYTE PTR [edx]
	mov	ecx, edx
	test	al, al
	je	SHORT $LN137@xmlRelaxNG
	npad	6
$LL8@xmlRelaxNG:

; 8858 :                     if (IS_BLANK_CH(*cur)) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN56@xmlRelaxNG
	cmp	al, 9
	jb	SHORT $LN57@xmlRelaxNG
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN56@xmlRelaxNG
$LN57@xmlRelaxNG:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN56@xmlRelaxNG

; 8865 :                             *cur++ = 0;
; 8866 :                     } else
; 8867 :                         cur++;

	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	jmp	SHORT $LN117@xmlRelaxNG
$LN56@xmlRelaxNG:

; 8859 :                         *cur = 0;
; 8860 :                         cur++;
; 8861 : #ifdef DEBUG_LIST
; 8862 :                         nb_values++;
; 8863 : #endif
; 8864 :                         while (IS_BLANK_CH(*cur))

	mov	BYTE PTR [ecx], bl
	inc	ecx
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN56@xmlRelaxNG
	cmp	al, 9
	jb	SHORT $LN59@xmlRelaxNG
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN56@xmlRelaxNG
$LN59@xmlRelaxNG:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN56@xmlRelaxNG
$LN117@xmlRelaxNG:

; 8855 :                 }
; 8856 :                 cur = val;
; 8857 :                 while (*cur != 0) {

	test	al, al
	jne	SHORT $LL8@xmlRelaxNG
$LN137@xmlRelaxNG:

; 8868 :                 }
; 8869 : #ifdef DEBUG_LIST
; 8870 :                 xmlGenericError(xmlGenericErrorContext,
; 8871 :                                 "list value: '%s' found %d items\n",
; 8872 :                                 oldvalue, nb_values);
; 8873 :                 nb_values = 0;
; 8874 : #endif
; 8875 :                 ctxt->state->endvalue = cur;

	mov	eax, DWORD PTR [edi+60]
	mov	DWORD PTR [eax+24], ecx

; 8876 :                 cur = val;

	mov	ecx, edx

; 8877 :                 while ((*cur == 0) && (cur != ctxt->state->endvalue))

	cmp	BYTE PTR [edx], bl
	jne	SHORT $LN139@xmlRelaxNG
	mov	eax, DWORD PTR [edi+60]
	mov	eax, DWORD PTR [eax+24]
$LL12@xmlRelaxNG:
	cmp	ecx, eax
	je	SHORT $LN139@xmlRelaxNG

; 8878 :                     cur++;

	inc	ecx
	cmp	BYTE PTR [ecx], bl
	je	SHORT $LL12@xmlRelaxNG
$LN139@xmlRelaxNG:

; 8879 : 
; 8880 :                 ctxt->state->value = cur;

	mov	eax, DWORD PTR [edi+60]
	mov	DWORD PTR [eax+20], ecx

; 8881 : 
; 8882 :                 while (list != NULL) {

	test	esi, esi
	je	SHORT $LN130@xmlRelaxNG
$LL14@xmlRelaxNG:

; 8883 :                     if (ctxt->state->value == ctxt->state->endvalue)

	mov	ecx, DWORD PTR [edi+60]
	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR [ecx+24]
	jne	SHORT $LN131@xmlRelaxNG

; 8884 :                         ctxt->state->value = NULL;

	mov	DWORD PTR [ecx+20], 0
$LN131@xmlRelaxNG:

; 8885 :                     ret = xmlRelaxNGValidateValue(ctxt, list);

	push	esi
	push	edi
	call	_xmlRelaxNGValidateValue
	mov	ebx, eax
	add	esp, 8

; 8886 :                     if (ret != 0) {

	test	ebx, ebx
	jne	SHORT $LN62@xmlRelaxNG

; 8887 : #ifdef DEBUG_LIST
; 8888 :                         xmlGenericError(xmlGenericErrorContext,
; 8889 :                                         "Failed to validate value: '%s' with %d rule\n",
; 8890 :                                         ctxt->state->value, nb_values);
; 8891 : #endif
; 8892 :                         break;
; 8893 :                     }
; 8894 : #ifdef DEBUG_LIST
; 8895 :                     nb_values++;
; 8896 : #endif
; 8897 :                     list = list->next;

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL14@xmlRelaxNG
$LN130@xmlRelaxNG:

; 8898 :                 }
; 8899 : 
; 8900 :                 if ((ret == 0) && (ctxt->state->value != NULL) &&

	mov	ecx, DWORD PTR [edi+60]
	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN62@xmlRelaxNG
	cmp	eax, DWORD PTR [ecx+24]
	je	SHORT $LN62@xmlRelaxNG

; 8901 :                     (ctxt->state->value != ctxt->state->endvalue)) {
; 8902 :                     VALID_ERR2(XML_RELAXNG_ERR_LISTEXTRA,

	push	0
	push	0
	push	eax
	push	8
	push	edi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 8903 :                                ctxt->state->value);
; 8904 :                     ret = -1;

	or	ebx, -1
$LN62@xmlRelaxNG:

; 8905 :                 }
; 8906 :                 xmlFree(val);

	push	DWORD PTR _val$1$[ebp]
	call	DWORD PTR _xmlFree

; 8907 :                 ctxt->state->value = oldvalue;

	mov	eax, DWORD PTR [edi+60]
	add	esp, 4
	mov	ecx, DWORD PTR _oldvalue$1$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 8908 :                 ctxt->state->endvalue = oldend;

	mov	eax, DWORD PTR [edi+60]
	mov	ecx, DWORD PTR _oldend$1$[ebp]
	pop	edi

; 9014 : }

	pop	esi
	mov	DWORD PTR [eax+24], ecx
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@xmlRelaxNG:

; 8909 :                 break;
; 8910 :             }
; 8911 :         case XML_RELAXNG_ONEORMORE:
; 8912 :             ret = xmlRelaxNGValidateValueList(ctxt, define->content);

	push	DWORD PTR [esi+24]
	push	edi
	call	_xmlRelaxNGValidateValueList
	mov	ebx, eax
	add	esp, 8

; 8913 :             if (ret != 0) {

	test	ebx, ebx
	jne	$LN2@xmlRelaxNG
$LN64@xmlRelaxNG:

; 8914 :                 break;
; 8915 :             }
; 8916 :             /* Falls through. */
; 8917 :         case XML_RELAXNG_ZEROORMORE:{
; 8918 :                 xmlChar *cur, *temp;
; 8919 : 
; 8920 :                 if ((ctxt->state->value == NULL) ||

	mov	ecx, DWORD PTR [edi+60]
	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	$LN74@xmlRelaxNG
	cmp	BYTE PTR [eax], 0
	je	$LN74@xmlRelaxNG

; 8921 :                     (*ctxt->state->value == 0)) {
; 8922 :                     ret = 0;
; 8923 :                     break;
; 8924 :                 }
; 8925 :                 oldflags = ctxt->flags;

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR _oldflags$2$[ebp], eax

; 8926 :                 ctxt->flags |= FLAGS_IGNORABLE;

	or	eax, 1
	mov	DWORD PTR [edi+28], eax

; 8927 :                 cur = ctxt->state->value;
; 8928 :                 temp = NULL;

	xor	eax, eax
	mov	esi, DWORD PTR [ecx+20]

; 8929 :                 while ((cur != NULL) && (cur != ctxt->state->endvalue) &&

	test	esi, esi
	je	SHORT $LN17@xmlRelaxNG
$LL16@xmlRelaxNG:
	cmp	esi, DWORD PTR [ecx+24]
	je	SHORT $LN17@xmlRelaxNG
	cmp	eax, esi
	je	SHORT $LN17@xmlRelaxNG

; 8930 :                        (temp != cur)) {
; 8931 :                     temp = cur;
; 8932 :                     ret =

	mov	eax, DWORD PTR _define$[ebp]
	mov	DWORD PTR _temp$1$[ebp], esi
	push	DWORD PTR [eax+24]
	push	edi
	call	_xmlRelaxNGValidateValueList
	mov	ecx, DWORD PTR [edi+60]
	mov	ebx, eax
	add	esp, 8

; 8933 :                         xmlRelaxNGValidateValueList(ctxt, define->content);
; 8934 :                     if (ret != 0) {

	test	ebx, ebx
	jne	SHORT $LN99@xmlRelaxNG

; 8937 :                         break;
; 8938 :                     }
; 8939 :                     cur = ctxt->state->value;

	mov	esi, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _temp$1$[ebp]
	test	esi, esi
	jne	SHORT $LL16@xmlRelaxNG

; 8992 :                     if (ret != 0) {

	jmp	SHORT $LN17@xmlRelaxNG
$LN99@xmlRelaxNG:

; 8935 :                         ctxt->state->value = temp;

	mov	DWORD PTR [ecx+20], esi

; 8936 :                         ret = 0;

	xor	ebx, ebx
$LN17@xmlRelaxNG:

; 8940 :                 }
; 8941 :                 ctxt->flags = oldflags;

	mov	eax, DWORD PTR _oldflags$2$[ebp]
	mov	DWORD PTR [edi+28], eax
$LN47@xmlRelaxNG:

; 9012 :     }
; 9013 :     return (ret);

	cmp	DWORD PTR [edi+48], 0
	jle	$LN2@xmlRelaxNG
	push	0
	push	edi
	call	_xmlRelaxNGPopErrors
	add	esp, 8
	mov	eax, ebx
	pop	edi

; 9014 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN70@xmlRelaxNG:

; 8942 : 		if (ctxt->errNr > 0)
; 8943 : 		    xmlRelaxNGPopErrors(ctxt, 0);
; 8944 :                 break;
; 8945 :             }
; 8946 :         case XML_RELAXNG_OPTIONAL:{
; 8947 :                 xmlChar *temp;
; 8948 : 
; 8949 :                 if ((ctxt->state->value == NULL) ||

	test	ecx, ecx
	je	SHORT $LN74@xmlRelaxNG
	cmp	BYTE PTR [ecx], bl
	je	SHORT $LN74@xmlRelaxNG

; 8950 :                     (*ctxt->state->value == 0)) {
; 8951 :                     ret = 0;
; 8952 :                     break;
; 8953 :                 }
; 8954 :                 oldflags = ctxt->flags;

	mov	esi, DWORD PTR [edi+28]

; 8955 :                 ctxt->flags |= FLAGS_IGNORABLE;

	mov	eax, esi
	or	eax, 1
	mov	DWORD PTR [edi+28], eax

; 8956 :                 temp = ctxt->state->value;

	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _temp$1$[ebp], eax

; 8957 :                 ret = xmlRelaxNGValidateValue(ctxt, define->content);

	mov	eax, DWORD PTR _define$[ebp]
	push	DWORD PTR [eax+24]
	push	edi
	call	_xmlRelaxNGValidateValue
	mov	ebx, eax

; 8958 :                 ctxt->flags = oldflags;

	mov	DWORD PTR [edi+28], esi
	add	esp, 8

; 8959 :                 if (ret != 0) {

	test	ebx, ebx
	je	SHORT $LN47@xmlRelaxNG

; 8960 :                     ctxt->state->value = temp;

	mov	eax, DWORD PTR [edi+60]
	mov	ecx, DWORD PTR _temp$1$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 8961 :                     if (ctxt->errNr > 0)

	cmp	DWORD PTR [edi+48], 0
	jle	SHORT $LN74@xmlRelaxNG

; 8962 :                         xmlRelaxNGPopErrors(ctxt, 0);

	push	0
	push	edi
	call	_xmlRelaxNGPopErrors
	add	esp, 8
$LN74@xmlRelaxNG:

; 9012 :     }
; 9013 :     return (ret);

	pop	edi
	xor	ebx, ebx

; 9014 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN76@xmlRelaxNG:

; 8963 :                     ret = 0;
; 8964 :                     break;
; 8965 :                 }
; 8966 : 		if (ctxt->errNr > 0)
; 8967 : 		    xmlRelaxNGPopErrors(ctxt, 0);
; 8968 :                 break;
; 8969 :             }
; 8970 :         case XML_RELAXNG_EXCEPT:{
; 8971 :                 xmlRelaxNGDefinePtr list;
; 8972 : 
; 8973 :                 list = define->content;

	mov	esi, DWORD PTR [esi+24]

; 8974 :                 while (list != NULL) {

	test	esi, esi
	je	$LN2@xmlRelaxNG

; 8977 :                         ret = -1;
; 8978 :                         break;
; 8979 :                     } else
; 8980 :                         ret = 0;

	xor	ebx, ebx
$LL18@xmlRelaxNG:

; 8975 :                     ret = xmlRelaxNGValidateValue(ctxt, list);

	push	esi
	push	edi
	call	_xmlRelaxNGValidateValue
	add	esp, 8

; 8976 :                     if (ret == 0) {

	test	eax, eax
	je	$LN140@xmlRelaxNG

; 8981 :                     list = list->next;

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL18@xmlRelaxNG

; 9014 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN79@xmlRelaxNG:

; 8982 :                 }
; 8983 :                 break;
; 8984 :             }
; 8985 :         case XML_RELAXNG_DEF:
; 8986 :         case XML_RELAXNG_GROUP:{
; 8987 :                 xmlRelaxNGDefinePtr list;
; 8988 : 
; 8989 :                 list = define->content;

	mov	esi, DWORD PTR [esi+24]

; 8990 :                 while (list != NULL) {

	test	esi, esi
	je	$LN2@xmlRelaxNG

; 8993 :                         ret = -1;
; 8994 :                         break;
; 8995 :                     } else
; 8996 :                         ret = 0;

	xor	ebx, ebx
$LL20@xmlRelaxNG:

; 8991 :                     ret = xmlRelaxNGValidateValue(ctxt, list);

	push	esi
	push	edi
	call	_xmlRelaxNGValidateValue
	add	esp, 8

; 8992 :                     if (ret != 0) {

	test	eax, eax
	jne	SHORT $LN140@xmlRelaxNG

; 8997 :                     list = list->next;

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL20@xmlRelaxNG

; 9014 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN82@xmlRelaxNG:

; 8998 :                 }
; 8999 :                 break;
; 9000 :             }
; 9001 :         case XML_RELAXNG_REF:
; 9002 :         case XML_RELAXNG_PARENTREF:
; 9003 : 	    if (define->content == NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LN83@xmlRelaxNG

; 9004 :                 VALID_ERR(XML_RELAXNG_ERR_NODEFINE);

	push	eax
	push	eax
	push	eax
	push	7
	push	edi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 9012 :     }
; 9013 :     return (ret);

	or	ebx, -1
	mov	eax, ebx
	pop	edi

; 9014 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN83@xmlRelaxNG:

; 9005 :                 ret = -1;
; 9006 : 	    } else {
; 9007 :                 ret = xmlRelaxNGValidateValue(ctxt, define->content);

	push	eax
	push	edi
	call	_xmlRelaxNGValidateValue
	add	esp, 8
	mov	ebx, eax
	pop	edi

; 9014 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN85@xmlRelaxNG:

; 9008 :             }
; 9009 :             break;
; 9010 :         default:
; 9011 :             TODO ret = -1;

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	9011					; 00002333H
	push	OFFSET ??_C@_0GJ@NFABHKPN@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN140@xmlRelaxNG:

; 9012 :     }
; 9013 :     return (ret);

	or	ebx, -1
$LN2@xmlRelaxNG:
	pop	edi

; 9014 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN143@xmlRelaxNG:
	DD	$LN22@xmlRelaxNG
	DD	$LN85@xmlRelaxNG
	DD	$LN76@xmlRelaxNG
	DD	$LN2@xmlRelaxNG
	DD	$LN85@xmlRelaxNG
	DD	$LN43@xmlRelaxNG
	DD	$LN85@xmlRelaxNG
	DD	$LN28@xmlRelaxNG
	DD	$LN51@xmlRelaxNG
	DD	$LN85@xmlRelaxNG
	DD	$LN79@xmlRelaxNG
	DD	$LN82@xmlRelaxNG
	DD	$LN85@xmlRelaxNG
	DD	$LN82@xmlRelaxNG
	DD	$LN70@xmlRelaxNG
	DD	$LN64@xmlRelaxNG
	DD	$LN63@xmlRelaxNG
	DD	$LN45@xmlRelaxNG
	DD	$LN79@xmlRelaxNG
_xmlRelaxNGValidateValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidateProgressiveCallback
_TEXT	SEGMENT
_ret$1$ = -4						; size = 4
_exec$ = 8						; size = 4
_token$ = 12						; size = 4
_oldstate$1$ = 16					; size = 4
_transdata$ = 16					; size = 4
_oldflags$1$ = 20					; size = 4
_inputdata$ = 20					; size = 4
_xmlRelaxNGValidateProgressiveCallback PROC		; COMDAT

; 8168 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _inputdata$[ebp]
	mov	DWORD PTR _ret$1$[ebp], 0
	test	esi, esi
	jne	SHORT $LN8@xmlRelaxNG

; 8169 :     xmlRelaxNGValidCtxtPtr ctxt = (xmlRelaxNGValidCtxtPtr) inputdata;
; 8170 :     xmlRelaxNGDefinePtr define = (xmlRelaxNGDefinePtr) transdata;
; 8171 :     xmlRelaxNGValidStatePtr state, oldstate;
; 8172 :     xmlNodePtr node;
; 8173 :     int ret = 0, oldflags;
; 8174 : 
; 8175 : #ifdef DEBUG_PROGRESSIVE
; 8176 :     xmlGenericError(xmlGenericErrorContext,
; 8177 :                     "Progressive callback for: '%s'\n", token);
; 8178 : #endif
; 8179 :     if (ctxt == NULL) {
; 8180 :         fprintf(stderr, "callback on %s missing context\n", token);

	push	DWORD PTR _token$[ebp]
	push	OFFSET ??_C@_0CA@KBMDPFMM@callback?5on?5?$CFs?5missing?5context?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	pop	esi

; 8296 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlRelaxNG:
	push	ebx

; 8181 :         return;
; 8182 :     }
; 8183 :     node = ctxt->pnode;

	mov	ebx, DWORD PTR [esi+104]
	push	edi

; 8184 :     ctxt->pstate = 1;
; 8185 :     if (define == NULL) {

	mov	edi, DWORD PTR _transdata$[ebp]
	mov	DWORD PTR [esi+100], 1
	test	edi, edi
	jne	SHORT $LN9@xmlRelaxNG

; 8186 :         if (token[0] == '#')

	mov	eax, DWORD PTR _token$[ebp]
	cmp	BYTE PTR [eax], 35			; 00000023H
	je	SHORT $LN49@xmlRelaxNG

; 8187 :             return;
; 8188 :         fprintf(stderr, "callback on %s missing define\n", token);

	push	eax
	push	OFFSET ??_C@_0BP@FKGGDPOM@callback?5on?5?$CFs?5missing?5define?6@
$LN51@xmlRelaxNG:

; 8240 :         ctxt->pstate = -1;

	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+40], 0
	jne	SHORT $LN48@xmlRelaxNG
	mov	DWORD PTR [esi+40], 37			; 00000025H
$LN48@xmlRelaxNG:
	mov	DWORD PTR [esi+100], -1
$LN49@xmlRelaxNG:
	pop	edi
	pop	ebx
	pop	esi

; 8296 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlRelaxNG:

; 8189 :         if ((ctxt != NULL) && (ctxt->errNo == XML_RELAXNG_OK))
; 8190 :             ctxt->errNo = XML_RELAXNG_ERR_INTERNAL;
; 8191 :         ctxt->pstate = -1;
; 8192 :         return;
; 8193 :     }
; 8194 :     if ((ctxt == NULL) || (define == NULL)) {
; 8195 :         fprintf(stderr, "callback on %s missing info\n", token);
; 8196 :         if ((ctxt != NULL) && (ctxt->errNo == XML_RELAXNG_OK))
; 8197 :             ctxt->errNo = XML_RELAXNG_ERR_INTERNAL;
; 8198 :         ctxt->pstate = -1;
; 8199 :         return;
; 8200 :     } else if (define->type != XML_RELAXNG_ELEMENT) {

	cmp	DWORD PTR [edi], 4
	je	SHORT $LN16@xmlRelaxNG

; 8201 :         fprintf(stderr, "callback on %s define is not element\n", token);

	push	DWORD PTR _token$[ebp]
	push	OFFSET ??_C@_0CG@GECBHEAN@callback?5on?5?$CFs?5define?5is?5not?5el@

; 8256 :             ctxt->pstate = -1;

	jmp	SHORT $LN51@xmlRelaxNG
$LN16@xmlRelaxNG:

; 8202 :         if (ctxt->errNo == XML_RELAXNG_OK)
; 8203 :             ctxt->errNo = XML_RELAXNG_ERR_INTERNAL;
; 8204 :         ctxt->pstate = -1;
; 8205 :         return;
; 8206 :     }
; 8207 :     if (node->type != XML_ELEMENT_NODE) {

	cmp	DWORD PTR [ebx+4], 1
	je	SHORT $LN18@xmlRelaxNG

; 8208 :         VALID_ERR(XML_RELAXNG_ERR_NOTELEM);

	push	0
	push	0
	push	0
	push	23					; 00000017H
	push	esi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 8209 :         if ((ctxt->flags & FLAGS_IGNORABLE) == 0)

	test	BYTE PTR [esi+28], 1
	jne	SHORT $LN48@xmlRelaxNG

; 8210 :             xmlRelaxNGDumpValidError(ctxt);

	push	esi
	call	_xmlRelaxNGDumpValidError
	add	esp, 4

; 8240 :         ctxt->pstate = -1;

	mov	DWORD PTR [esi+100], -1
	pop	edi
	pop	ebx
	pop	esi

; 8296 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlRelaxNG:

; 8211 :         ctxt->pstate = -1;
; 8212 :         return;
; 8213 :     }
; 8214 :     if (define->contModel == NULL) {

	mov	eax, DWORD PTR [edi+52]
	test	eax, eax
	jne	SHORT $LN20@xmlRelaxNG

; 8215 :         /*
; 8216 :          * this node cannot be validated in a streamable fashion
; 8217 :          */
; 8218 : #ifdef DEBUG_PROGRESSIVE
; 8219 :         xmlGenericError(xmlGenericErrorContext,
; 8220 :                         "Element '%s' validation is not streamable\n",
; 8221 :                         token);
; 8222 : #endif
; 8223 :         ctxt->pstate = 0;
; 8224 :         ctxt->pdef = define;

	mov	DWORD PTR [esi+108], edi
	pop	edi
	pop	ebx
	mov	DWORD PTR [esi+100], eax
	pop	esi

; 8296 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlRelaxNG:

; 8225 :         return;
; 8226 :     }
; 8227 :     exec = xmlRegNewExecCtxt(define->contModel,

	push	esi
	push	OFFSET _xmlRelaxNGValidateProgressiveCallback
	push	eax
	call	_xmlRegNewExecCtxt
	add	esp, 12					; 0000000cH

; 8228 :                              xmlRelaxNGValidateProgressiveCallback, ctxt);
; 8229 :     if (exec == NULL) {

	test	eax, eax
	je	SHORT $LN48@xmlRelaxNG

; 8230 :         ctxt->pstate = -1;
; 8231 :         return;
; 8232 :     }
; 8233 :     xmlRelaxNGElemPush(ctxt, exec);

	push	eax
	push	esi
	call	_xmlRelaxNGElemPush

; 8234 : 
; 8235 :     /*
; 8236 :      * Validate the attributes part of the content.
; 8237 :      */
; 8238 :     state = xmlRelaxNGNewValidState(ctxt, node);

	push	ebx
	push	esi
	call	_xmlRelaxNGNewValidState
	add	esp, 16					; 00000010H

; 8239 :     if (state == NULL) {

	test	eax, eax
	je	$LN48@xmlRelaxNG

; 8241 :         return;
; 8242 :     }
; 8243 :     oldstate = ctxt->state;

	mov	ecx, DWORD PTR [esi+60]

; 8244 :     ctxt->state = state;

	mov	DWORD PTR [esi+60], eax

; 8245 :     if (define->attrs != NULL) {

	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR _oldstate$1$[ebp], ecx
	test	eax, eax
	je	SHORT $LN24@xmlRelaxNG

; 8246 :         ret = xmlRelaxNGValidateAttributeList(ctxt, define->attrs);

	push	eax
	push	esi
	call	_xmlRelaxNGValidateAttributeList
	add	esp, 8
	mov	DWORD PTR _ret$1$[ebp], eax

; 8247 :         if (ret != 0) {

	test	eax, eax
	je	SHORT $LN24@xmlRelaxNG

; 8248 :             ctxt->pstate = -1;
; 8249 :             VALID_ERR2(XML_RELAXNG_ERR_ATTRVALID, node->name);

	push	0
	push	0
	mov	DWORD PTR [esi+100], -1
	push	DWORD PTR [ebx+8]
	push	24					; 00000018H
	push	esi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H
$LN24@xmlRelaxNG:

; 8250 :         }
; 8251 :     }
; 8252 :     if (ctxt->state != NULL) {

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN25@xmlRelaxNG

; 8253 :         ctxt->state->seq = NULL;
; 8254 :         ret = xmlRelaxNGValidateElementEnd(ctxt, 1);

	push	1
	push	esi
	mov	DWORD PTR [eax+4], 0
	call	_xmlRelaxNGValidateElementEnd
	add	esp, 8

; 8255 :         if (ret != 0) {

	test	eax, eax
	je	SHORT $LN47@xmlRelaxNG

; 8256 :             ctxt->pstate = -1;

	mov	DWORD PTR [esi+100], -1
$LN47@xmlRelaxNG:

; 8257 :         }
; 8258 :         xmlRelaxNGFreeValidState(ctxt, ctxt->state);

	push	DWORD PTR [esi+60]
	push	esi
	call	_xmlRelaxNGFreeValidState
	add	esp, 8
	jmp	$LN28@xmlRelaxNG
$LN25@xmlRelaxNG:

; 8259 :     } else if (ctxt->states != NULL) {

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	$LN28@xmlRelaxNG

; 8260 :         int tmp = -1, i;
; 8261 : 
; 8262 :         oldflags = ctxt->flags;

	mov	ecx, DWORD PTR [esi+28]

; 8263 : 
; 8264 :         for (i = 0; i < ctxt->states->nbState; i++) {

	xor	edi, edi
	or	ebx, -1
	mov	DWORD PTR _oldflags$1$[ebp], ecx
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN46@xmlRelaxNG
	npad	6
$LL4@xmlRelaxNG:

; 8265 :             state = ctxt->states->tabState[i];
; 8266 :             ctxt->state = state;

	mov	eax, DWORD PTR [eax+8]

; 8267 :             ctxt->state->seq = NULL;
; 8268 : 
; 8269 :             if (xmlRelaxNGValidateElementEnd(ctxt, 0) == 0) {

	push	0
	push	esi
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+60], eax
	mov	DWORD PTR [eax+4], 0
	call	_xmlRelaxNGValidateElementEnd
	add	esp, 8
	test	eax, eax
	je	$LN37@xmlRelaxNG

; 8263 : 
; 8264 :         for (i = 0; i < ctxt->states->nbState; i++) {

	mov	eax, DWORD PTR [esi+64]
	inc	edi
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL4@xmlRelaxNG

; 8267 :             ctxt->state->seq = NULL;
; 8268 : 
; 8269 :             if (xmlRelaxNGValidateElementEnd(ctxt, 0) == 0) {

	mov	ecx, DWORD PTR [esi+28]
$LN46@xmlRelaxNG:

; 8275 :             /*
; 8276 :              * validation error, log the message for the "best" one
; 8277 :              */
; 8278 :             ctxt->flags |= FLAGS_IGNORABLE;

	or	ecx, 1

; 8279 :             xmlRelaxNGLogBestError(ctxt);

	push	esi
	mov	DWORD PTR [esi+28], ecx
	call	_xmlRelaxNGLogBestError
	add	esp, 4
$LN30@xmlRelaxNG:

; 8280 :         }
; 8281 :         for (i = 0; i < ctxt->states->nbState; i++) {

	mov	eax, DWORD PTR [esi+64]
	xor	edi, edi
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN6@xmlRelaxNG
$LL7@xmlRelaxNG:

; 8282 :             xmlRelaxNGFreeValidState(ctxt, ctxt->states->tabState[i]);

	mov	eax, DWORD PTR [esi+64]
	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [eax+edi*4]
	push	esi
	call	_xmlRelaxNGFreeValidState
	mov	eax, DWORD PTR [esi+64]
	inc	edi
	add	esp, 8
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL7@xmlRelaxNG
$LN6@xmlRelaxNG:

; 8283 :         }
; 8284 :         xmlRelaxNGFreeStates(ctxt, ctxt->states);

	push	eax
	push	esi
	call	_xmlRelaxNGFreeStates
	add	esp, 8

; 8285 :         ctxt->states = NULL;

	mov	DWORD PTR [esi+64], 0

; 8286 :         if ((ret == 0) && (tmp == -1))

	cmp	DWORD PTR _ret$1$[ebp], 0
	jne	SHORT $LN31@xmlRelaxNG
	cmp	ebx, -1
	jne	SHORT $LN31@xmlRelaxNG

; 8287 :             ctxt->pstate = -1;

	mov	DWORD PTR [esi+100], ebx
$LN31@xmlRelaxNG:

; 8288 :         ctxt->flags = oldflags;

	mov	eax, DWORD PTR _oldflags$1$[ebp]
	mov	DWORD PTR [esi+28], eax
$LN28@xmlRelaxNG:

; 8289 :     }
; 8290 :     if (ctxt->pstate == -1) {

	cmp	DWORD PTR [esi+100], -1
	jne	SHORT $LN33@xmlRelaxNG

; 8291 :         if ((ctxt->flags & FLAGS_IGNORABLE) == 0) {

	test	BYTE PTR [esi+28], 1
	jne	SHORT $LN33@xmlRelaxNG

; 8292 :             xmlRelaxNGDumpValidError(ctxt);

	push	esi
	call	_xmlRelaxNGDumpValidError
	add	esp, 4
$LN33@xmlRelaxNG:

; 8293 :         }
; 8294 :     }
; 8295 :     ctxt->state = oldstate;

	mov	eax, DWORD PTR _oldstate$1$[ebp]
	pop	edi
	pop	ebx
	mov	DWORD PTR [esi+60], eax
	pop	esi

; 8296 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@xmlRelaxNG:

; 8270 :                 tmp = 0;

	xor	ebx, ebx

; 8271 :                 break;
; 8272 :             }
; 8273 :         }
; 8274 :         if (tmp != 0) {

	jmp	SHORT $LN30@xmlRelaxNG
_xmlRelaxNGValidateProgressiveCallback ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGElemPop
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlRelaxNGElemPop PROC					; COMDAT

; 8138 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+88]
	test	ecx, ecx
	jg	SHORT $LN2@xmlRelaxNG

; 8139 :     xmlRegExecCtxtPtr ret;
; 8140 : 
; 8141 :     if (ctxt->elemNr <= 0)
; 8142 :         return (NULL);

	xor	eax, eax

; 8151 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:

; 8143 :     ctxt->elemNr--;
; 8144 :     ret = ctxt->elemTab[ctxt->elemNr];

	mov	eax, DWORD PTR [edx+96]
	dec	ecx
	mov	DWORD PTR [edx+88], ecx
	push	esi
	mov	esi, DWORD PTR [eax+ecx*4]

; 8145 :     ctxt->elemTab[ctxt->elemNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 8146 :     if (ctxt->elemNr > 0)

	mov	ecx, DWORD PTR [edx+88]
	test	ecx, ecx
	jle	SHORT $LN3@xmlRelaxNG

; 8147 :         ctxt->elem = ctxt->elemTab[ctxt->elemNr - 1];

	mov	eax, DWORD PTR [edx+96]
	mov	eax, DWORD PTR [eax+ecx*4-4]

; 8150 :     return (ret);

	mov	DWORD PTR [edx+84], eax
	mov	eax, esi
	pop	esi

; 8151 : }

	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 8148 :     else
; 8149 :         ctxt->elem = NULL;

	xor	eax, eax

; 8150 :     return (ret);

	mov	DWORD PTR [edx+84], eax
	mov	eax, esi
	pop	esi

; 8151 : }

	pop	ebp
	ret	0
_xmlRelaxNGElemPop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGElemPush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_exec$ = 12						; size = 4
_xmlRelaxNGElemPush PROC				; COMDAT

; 8101 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi+96]
	test	ecx, ecx
	jne	SHORT $LN3@xmlRelaxNG

; 8102 :     if (ctxt->elemTab == NULL) {
; 8103 :         ctxt->elemMax = 10;

	push	40					; 00000028H
	mov	DWORD PTR [esi+92], 10			; 0000000aH

; 8104 :         ctxt->elemTab = (xmlRegExecCtxtPtr *) xmlMalloc(ctxt->elemMax *

	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [esi+96], ecx

; 8105 :                                                         sizeof
; 8106 :                                                         (xmlRegExecCtxtPtr));
; 8107 :         if (ctxt->elemTab == NULL) {

	test	ecx, ecx
	jne	SHORT $LN3@xmlRelaxNG

; 480  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN10@xmlRelaxNG

; 481  : 	    schannel = ctxt->serror;
; 482  : 	else
; 483  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN10@xmlRelaxNG:

; 484  :         data = ctxt->userData;
; 485  :         ctxt->nbErrors++;
; 486  :     }
; 487  :     if (extra)
; 488  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0M@PEGDIBJJ@validating?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+16]
	push	OFFSET ??_C@_0M@PEGDIBJJ@validating?6@
	push	0
	push	0
	push	3
	push	2
	push	19					; 00000013H
	push	0
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 8108 :             xmlRngVErrMemory(ctxt, "validating\n");
; 8109 :             return (-1);

	or	eax, -1
	pop	esi

; 8126 : }

	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 8110 :         }
; 8111 :     }
; 8112 :     if (ctxt->elemNr >= ctxt->elemMax) {

	mov	edx, DWORD PTR [esi+88]
	mov	eax, DWORD PTR [esi+92]
	cmp	edx, eax
	jl	SHORT $LN5@xmlRelaxNG

; 8113 :         ctxt->elemMax *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+92], eax

; 8114 :         ctxt->elemTab = (xmlRegExecCtxtPtr *) xmlRealloc(ctxt->elemTab,

	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR [esi+96], ecx

; 8115 :                                                          ctxt->elemMax *
; 8116 :                                                          sizeof
; 8117 :                                                          (xmlRegExecCtxtPtr));
; 8118 :         if (ctxt->elemTab == NULL) {

	test	ecx, ecx
	jne	SHORT $LN21@xmlRelaxNG

; 480  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN17@xmlRelaxNG

; 481  : 	    schannel = ctxt->serror;
; 482  : 	else
; 483  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN17@xmlRelaxNG:

; 484  :         data = ctxt->userData;
; 485  :         ctxt->nbErrors++;
; 486  :     }
; 487  :     if (extra)
; 488  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0M@PEGDIBJJ@validating?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+16]
	push	OFFSET ??_C@_0M@PEGDIBJJ@validating?6@
	push	0
	push	0
	push	3
	push	2
	push	19					; 00000013H
	push	0
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 8119 :             xmlRngVErrMemory(ctxt, "validating\n");
; 8120 :             return (-1);

	or	eax, -1
	pop	esi

; 8126 : }

	pop	ebp
	ret	0
$LN21@xmlRelaxNG:
	mov	edx, DWORD PTR [esi+88]
$LN5@xmlRelaxNG:

; 8121 :         }
; 8122 :     }
; 8123 :     ctxt->elemTab[ctxt->elemNr++] = exec;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	DWORD PTR [esi+88]

; 8124 :     ctxt->elem = exec;

	mov	DWORD PTR [esi+84], eax

; 8125 :     return (0);

	xor	eax, eax
	pop	esi

; 8126 : }

	pop	ebp
	ret	0
_xmlRelaxNGElemPush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGLogBestError
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlRelaxNGLogBestError PROC				; COMDAT

; 9797 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG

; 9798 :     int best;
; 9799 : 
; 9800 :     if ((ctxt == NULL) || (ctxt->states == NULL) ||

	push	ebx
	mov	ebx, DWORD PTR [eax+64]
	test	ebx, ebx
	je	SHORT $LN24@xmlRelaxNG
	cmp	DWORD PTR [ebx], 0
	jle	SHORT $LN24@xmlRelaxNG

; 9761 :     int best = -1;

	push	esi
	push	edi

; 9769 :         state = ctxt->states->tabState[i];

	mov	edi, DWORD PTR [ebx+8]
	or	ecx, -1
	mov	esi, 1000000				; 000f4240H
	xor	eax, eax
$LL9@xmlRelaxNG:
	mov	edx, DWORD PTR [edi]

; 9770 :         if (state == NULL)

	test	edx, edx
	je	SHORT $LN7@xmlRelaxNG

; 9771 :             continue;
; 9772 :         if (state->seq != NULL) {

	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN13@xmlRelaxNG

; 9773 :             if ((best == -1) || (value > 100000)) {

	cmp	ecx, -1
	je	SHORT $LN16@xmlRelaxNG
	cmp	esi, 100000				; 000186a0H
	jle	SHORT $LN7@xmlRelaxNG
$LN16@xmlRelaxNG:

; 9774 :                 value = 100000;

	mov	esi, 100000				; 000186a0H

; 9775 :                 best = i;
; 9776 :             }
; 9777 :         } else {

	jmp	SHORT $LN25@xmlRelaxNG
$LN13@xmlRelaxNG:

; 9778 :             tmp = state->nbAttrLeft;

	mov	edx, DWORD PTR [edx+16]

; 9779 :             if ((best == -1) || (value > tmp)) {

	cmp	ecx, -1
	je	SHORT $LN18@xmlRelaxNG
	cmp	esi, edx
	jle	SHORT $LN7@xmlRelaxNG
$LN18@xmlRelaxNG:

; 9780 :                 value = tmp;

	mov	esi, edx
$LN25@xmlRelaxNG:

; 9762 :     int value = 1000000;
; 9763 : 
; 9764 :     if ((ctxt == NULL) || (ctxt->states == NULL) ||
; 9765 :         (ctxt->states->nbState <= 0))
; 9766 :         return (-1);
; 9767 : 
; 9768 :     for (i = 0; i < ctxt->states->nbState; i++) {

	mov	ecx, eax
$LN7@xmlRelaxNG:
	inc	eax
	add	edi, 4
	cmp	eax, DWORD PTR [ebx]
	jl	SHORT $LL9@xmlRelaxNG

; 9801 :         (ctxt->states->nbState <= 0))
; 9802 :         return;
; 9803 : 
; 9804 :     best = xmlRelaxNGBestState(ctxt);
; 9805 :     if ((best >= 0) && (best < ctxt->states->nbState)) {

	pop	edi
	pop	esi
	test	ecx, ecx
	js	SHORT $LN24@xmlRelaxNG
	cmp	ecx, DWORD PTR [ebx]
	jge	SHORT $LN24@xmlRelaxNG

; 9806 :         ctxt->state = ctxt->states->tabState[best];

	mov	eax, DWORD PTR [ebx+8]

; 9807 : 
; 9808 :         xmlRelaxNGValidateElementEnd(ctxt, 1);

	push	1
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	mov	DWORD PTR [ecx+60], eax
	call	_xmlRelaxNGValidateElementEnd
	add	esp, 8
$LN24@xmlRelaxNG:
	pop	ebx
$LN3@xmlRelaxNG:

; 9809 :     }
; 9810 : }

	pop	ebp
	ret	0
_xmlRelaxNGLogBestError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidateElementEnd
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_dolog$ = 12						; size = 4
_xmlRelaxNGValidateElementEnd PROC			; COMDAT

; 9825 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	edi, DWORD PTR [ebx+60]
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG

; 9826 :     int i;
; 9827 :     xmlRelaxNGValidStatePtr state;
; 9828 : 
; 9829 :     state = ctxt->state;
; 9830 :     if (state->seq != NULL) {
; 9831 :         state->seq = xmlRelaxNGSkipIgnored(ctxt, state->seq);

	push	eax
	push	ebx
	call	_xmlRelaxNGSkipIgnored
	add	esp, 8
	mov	DWORD PTR [edi+4], eax

; 9832 :         if (state->seq != NULL) {

	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG

; 9833 :             if (dolog) {

	cmp	DWORD PTR _dolog$[ebp], 0
	je	SHORT $LN7@xmlRelaxNG

; 9834 :                 VALID_ERR3(XML_RELAXNG_ERR_EXTRACONTENT,

	push	0
	push	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [edi]
	push	DWORD PTR [eax+8]
	push	26					; 0000001aH
	push	ebx
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H
$LN7@xmlRelaxNG:

; 9835 :                            state->node->name, state->seq->name);
; 9836 :             }
; 9837 :             return (-1);

	pop	edi
	or	eax, -1

; 9850 : }

	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlRelaxNG:

; 9838 :         }
; 9839 :     }
; 9840 :     for (i = 0; i < state->nbAttrs; i++) {

	mov	edx, DWORD PTR [edi+8]
	push	esi
	xor	esi, esi
	test	edx, edx
	jle	SHORT $LN3@xmlRelaxNG

; 9841 :         if (state->attrs[i] != NULL) {

	mov	eax, DWORD PTR [edi+28]
	npad	4
$LL4@xmlRelaxNG:
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN12@xmlRelaxNG

; 9838 :         }
; 9839 :     }
; 9840 :     for (i = 0; i < state->nbAttrs; i++) {

	inc	esi
	add	eax, 4
	cmp	esi, edx
	jl	SHORT $LL4@xmlRelaxNG
$LN3@xmlRelaxNG:
	pop	esi
	pop	edi

; 9847 :         }
; 9848 :     }
; 9849 :     return (0);

	xor	eax, eax

; 9850 : }

	pop	ebx
	pop	ebp
	ret	0
$LN12@xmlRelaxNG:

; 9842 :             if (dolog) {

	cmp	DWORD PTR _dolog$[ebp], 0
	je	SHORT $LN9@xmlRelaxNG

; 9843 :                 VALID_ERR3(XML_RELAXNG_ERR_INVALIDATTR,

	mov	eax, DWORD PTR [edi]
	push	0
	push	DWORD PTR [eax+8]
	push	DWORD PTR [ecx+8]
	push	27					; 0000001bH
	push	ebx
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H
$LN9@xmlRelaxNG:

; 9844 :                            state->attrs[i]->name, state->node->name);
; 9845 :             }
; 9846 :             return (-1 - i);

	not	esi
	mov	eax, esi
	pop	esi
	pop	edi

; 9850 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlRelaxNGValidateElementEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidateAttributeList
_TEXT	SEGMENT
_needmore$1$ = -8					; size = 4
_ret$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_defines$ = 12						; size = 4
_xmlRelaxNGValidateAttributeList PROC			; COMDAT

; 9225 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _defines$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _ret$1$[ebp], ecx
	mov	edi, esi
	mov	DWORD PTR _needmore$1$[ebp], ecx
	test	esi, esi
	je	SHORT $LN74@xmlRelaxNG
	mov	ebx, DWORD PTR _ctxt$[ebp]
$LL2@xmlRelaxNG:

; 9226 :     int ret = 0, res;
; 9227 :     int needmore = 0;
; 9228 :     xmlRelaxNGDefinePtr cur;
; 9229 : 
; 9230 :     cur = defines;
; 9231 :     while (cur != NULL) {
; 9232 :         if (cur->type == XML_RELAXNG_ATTRIBUTE) {

	cmp	DWORD PTR [edi], 9
	jne	SHORT $LN6@xmlRelaxNG

; 9233 :             if (xmlRelaxNGValidateAttribute(ctxt, cur) != 0)

	push	edi
	push	ebx
	call	_xmlRelaxNGValidateAttribute
	add	esp, 8
	test	eax, eax
	mov	eax, DWORD PTR _needmore$1$[ebp]
	je	SHORT $LN76@xmlRelaxNG

; 9234 :                 ret = -1;

	or	ecx, -1
	mov	DWORD PTR _ret$1$[ebp], ecx

; 9235 :         } else

	jmp	SHORT $LN7@xmlRelaxNG
$LN6@xmlRelaxNG:

; 9236 :             needmore = 1;

	mov	eax, 1
	mov	DWORD PTR _needmore$1$[ebp], eax
	jmp	SHORT $LN7@xmlRelaxNG
$LN76@xmlRelaxNG:

; 9233 :             if (xmlRelaxNGValidateAttribute(ctxt, cur) != 0)

	mov	ecx, DWORD PTR _ret$1$[ebp]
$LN7@xmlRelaxNG:

; 9237 :         cur = cur->next;

	mov	edi, DWORD PTR [edi+32]
	test	edi, edi
	jne	SHORT $LL2@xmlRelaxNG

; 9238 :     }
; 9239 :     if (!needmore)

	test	eax, eax
	je	SHORT $LN74@xmlRelaxNG

; 9240 :         return (ret);
; 9241 :     cur = defines;

	or	edi, -1
$LL4@xmlRelaxNG:

; 9242 :     while (cur != NULL) {
; 9243 :         if (cur->type != XML_RELAXNG_ATTRIBUTE) {

	cmp	DWORD PTR [esi], 9
	je	SHORT $LN15@xmlRelaxNG

; 9244 :             if ((ctxt->state != NULL) || (ctxt->states != NULL)) {

	cmp	DWORD PTR [ebx+60], 0
	jne	SHORT $LN13@xmlRelaxNG
	cmp	DWORD PTR [ebx+64], 0
	je	SHORT $LN11@xmlRelaxNG
$LN13@xmlRelaxNG:

; 9245 :                 res = xmlRelaxNGValidateDefinition(ctxt, cur);

	push	esi
	push	ebx
	call	_xmlRelaxNGValidateDefinition

; 9246 :                 if (res < 0)

	mov	ecx, DWORD PTR _ret$1$[ebp]
	add	esp, 8
	test	eax, eax
	cmovs	ecx, edi
	mov	DWORD PTR _ret$1$[ebp], ecx

; 9251 :             }
; 9252 :             if (res == -1)      /* continues on -2 */

	cmp	eax, -1
	je	SHORT $LN74@xmlRelaxNG
$LN15@xmlRelaxNG:

; 9253 :                 break;
; 9254 :         }
; 9255 :         cur = cur->next;

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL4@xmlRelaxNG
$LN74@xmlRelaxNG:
	pop	edi

; 9256 :     }
; 9257 : 
; 9258 :     return (ret);
; 9259 : }

	pop	esi
	mov	eax, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlRelaxNG:

; 9247 :                     ret = -1;
; 9248 :             } else {
; 9249 :                 VALID_ERR(XML_RELAXNG_ERR_NOSTATE);

	push	0
	push	0
	push	0
	push	6
	push	ebx
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 9250 :                 return (-1);

	mov	eax, edi
	pop	edi

; 9256 :     }
; 9257 : 
; 9258 :     return (ret);
; 9259 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGValidateAttributeList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidateCompiledContent
_TEXT	SEGMENT
_oldperr$1$ = -4					; size = 4
_exec$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_regexp$ = 12						; size = 4
_content$ = 16						; size = 4
_xmlRelaxNGValidateCompiledContent PROC			; COMDAT

; 8005 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	test	edi, edi
	je	$LN7@xmlRelaxNG

; 8006 :     xmlRegExecCtxtPtr exec;
; 8007 :     xmlNodePtr cur;
; 8008 :     int ret = 0;
; 8009 :     int oldperr;
; 8010 : 
; 8011 :     if ((ctxt == NULL) || (regexp == NULL))

	mov	eax, DWORD PTR _regexp$[ebp]
	test	eax, eax
	je	$LN7@xmlRelaxNG

; 8013 :     oldperr = ctxt->perr;

	mov	ecx, DWORD PTR [edi+112]
	push	esi

; 8014 :     exec = xmlRegNewExecCtxt(regexp,

	push	edi
	push	OFFSET _xmlRelaxNGValidateCompiledCallback
	push	eax
	mov	DWORD PTR _oldperr$1$[ebp], ecx
	call	_xmlRegNewExecCtxt

; 8015 :                              xmlRelaxNGValidateCompiledCallback, ctxt);
; 8016 :     ctxt->perr = 0;
; 8017 :     cur = content;

	mov	esi, DWORD PTR _content$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+112], ebx
	mov	ecx, eax
	mov	DWORD PTR _exec$1$[ebp], ecx

; 8018 :     while (cur != NULL) {

	test	esi, esi
	je	$LN25@xmlRelaxNG
$LL2@xmlRelaxNG:

; 8019 :         ctxt->state->seq = cur;

	mov	eax, DWORD PTR [edi+60]
	mov	DWORD PTR [eax+4], esi

; 8020 :         switch (cur->type) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN11@xmlRelaxNG
	add	eax, -3					; fffffffdH
	cmp	eax, 1
	ja	SHORT $LN14@xmlRelaxNG

; 8021 :             case XML_TEXT_NODE:
; 8022 :             case XML_CDATA_SECTION_NODE:
; 8023 :                 if (xmlIsBlankNode(cur))

	push	esi
	call	_xmlIsBlankNode
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN14@xmlRelaxNG

; 8024 :                     break;
; 8025 :                 ret = xmlRegExecPushString(exec, BAD_CAST "#text", ctxt);

	push	edi
	push	OFFSET ??_C@_05NOBOONOA@?$CDtext@
	push	DWORD PTR _exec$1$[ebp]
	call	_xmlRegExecPushString
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 8026 :                 if (ret < 0) {

	test	ebx, ebx
	jns	SHORT $LN29@xmlRelaxNG

; 8027 :                     VALID_ERR2(XML_RELAXNG_ERR_TEXTWRONG,

	mov	ecx, DWORD PTR [esi+20]
	push	0
	push	0
	push	DWORD PTR [ecx+8]
	push	39					; 00000027H

; 8028 :                                cur->parent->name);
; 8029 :                 }
; 8030 :                 break;

	jmp	SHORT $LN31@xmlRelaxNG
$LN11@xmlRelaxNG:

; 8031 :             case XML_ELEMENT_NODE:
; 8032 :                 if (cur->ns != NULL) {

	mov	eax, DWORD PTR [esi+36]
	push	edi
	test	eax, eax
	je	SHORT $LN12@xmlRelaxNG

; 8033 :                     ret = xmlRegExecPushString2(exec, cur->name,

	push	DWORD PTR [eax+8]
	push	DWORD PTR [esi+8]
	push	ecx
	call	_xmlRegExecPushString2
	add	esp, 16					; 00000010H

; 8034 :                                                 cur->ns->href, ctxt);
; 8035 :                 } else {

	jmp	SHORT $LN32@xmlRelaxNG
$LN12@xmlRelaxNG:

; 8036 :                     ret = xmlRegExecPushString(exec, cur->name, ctxt);

	push	DWORD PTR [esi+8]
	push	ecx
	call	_xmlRegExecPushString
	add	esp, 12					; 0000000cH
$LN32@xmlRelaxNG:

; 8037 :                 }
; 8038 :                 if (ret < 0) {

	mov	ebx, eax
	test	ebx, ebx
	jns	SHORT $LN29@xmlRelaxNG

; 8039 :                     VALID_ERR2(XML_RELAXNG_ERR_ELEMWRONG, cur->name);

	push	0
	push	0
	push	DWORD PTR [esi+8]
	push	38					; 00000026H
$LN31@xmlRelaxNG:

; 8040 :                 }
; 8041 :                 break;
; 8042 :             default:
; 8043 :                 break;
; 8044 :         }
; 8045 :         if (ret < 0)

	push	edi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H
$LN14@xmlRelaxNG:
	test	ebx, ebx
	js	SHORT $LN30@xmlRelaxNG
$LN29@xmlRelaxNG:

; 8046 :             break;
; 8047 :         /*
; 8048 :          * Switch to next element
; 8049 :          */
; 8050 :         cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR _exec$1$[ebp]
	test	esi, esi
	jne	$LL2@xmlRelaxNG
$LN30@xmlRelaxNG:
	mov	ecx, DWORD PTR _exec$1$[ebp]
$LN25@xmlRelaxNG:

; 8051 :     }
; 8052 :     ret = xmlRegExecPushString(exec, NULL, NULL);

	push	0
	push	0
	push	ecx
	call	_xmlRegExecPushString
	add	esp, 12					; 0000000cH

; 8053 :     if (ret == 1) {

	cmp	eax, 1
	jne	SHORT $LN17@xmlRelaxNG

; 8054 :         ret = 0;
; 8055 :         ctxt->state->seq = NULL;

	mov	eax, DWORD PTR [edi+60]
	xor	esi, esi
	mov	DWORD PTR [eax+4], esi
	jmp	SHORT $LN20@xmlRelaxNG
$LN17@xmlRelaxNG:

; 8056 :     } else if (ret == 0) {

	test	eax, eax
	jne	SHORT $LN19@xmlRelaxNG

; 8057 :         /*
; 8058 :          * TODO: get some of the names needed to exit the current state of exec
; 8059 :          */
; 8060 :         VALID_ERR2(XML_RELAXNG_ERR_NOELEM, BAD_CAST "");

	push	eax
	push	eax
	push	OFFSET ??_C@_00CNPNBAHC@@
	push	22					; 00000016H
	push	edi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 8061 :         ret = -1;

	or	esi, -1

; 8062 :         if ((ctxt->flags & FLAGS_IGNORABLE) == 0)

	test	BYTE PTR [edi+28], 1
	jne	SHORT $LN20@xmlRelaxNG

; 8063 :             xmlRelaxNGDumpValidError(ctxt);

	push	edi
	call	_xmlRelaxNGDumpValidError
	add	esp, 4

; 8064 :     } else {

	jmp	SHORT $LN20@xmlRelaxNG
$LN19@xmlRelaxNG:

; 8065 :         ret = -1;

	or	esi, -1
$LN20@xmlRelaxNG:

; 8066 :     }
; 8067 :     xmlRegFreeExecCtxt(exec);

	push	DWORD PTR _exec$1$[ebp]
	call	_xmlRegFreeExecCtxt
	add	esp, 4

; 8068 :     /*
; 8069 :      * There might be content model errors outside of the pure
; 8070 :      * regexp validation, e.g. for attribute values.
; 8071 :      */
; 8072 :     if ((ret == 0) && (ctxt->perr != 0)) {

	test	esi, esi
	jne	SHORT $LN22@xmlRelaxNG
	mov	ecx, DWORD PTR [edi+112]
	test	ecx, ecx
	cmovne	esi, ecx
$LN22@xmlRelaxNG:

; 8073 :         ret = ctxt->perr;
; 8074 :     }
; 8075 :     ctxt->perr = oldperr;

	mov	eax, DWORD PTR _oldperr$1$[ebp]
	mov	DWORD PTR [edi+112], eax

; 8076 :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 8077 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlRelaxNG:
	pop	edi

; 8012 :         return (-1);

	or	eax, -1

; 8077 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGValidateCompiledContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidateCompiledCallback
_TEXT	SEGMENT
_exec$ = 8						; size = 4
_token$ = 12						; size = 4
_transdata$ = 16					; size = 4
_inputdata$ = 20					; size = 4
_xmlRelaxNGValidateCompiledCallback PROC		; COMDAT

; 7955 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _inputdata$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlRelaxNG

; 7956 :     xmlRelaxNGValidCtxtPtr ctxt = (xmlRelaxNGValidCtxtPtr) inputdata;
; 7957 :     xmlRelaxNGDefinePtr define = (xmlRelaxNGDefinePtr) transdata;
; 7958 :     int ret;
; 7959 : 
; 7960 : #ifdef DEBUG_COMPILE
; 7961 :     xmlGenericError(xmlGenericErrorContext,
; 7962 :                     "Compiled callback for: '%s'\n", token);
; 7963 : #endif
; 7964 :     if (ctxt == NULL) {
; 7965 :         fprintf(stderr, "callback on %s missing context\n", token);

	push	DWORD PTR _token$[ebp]
	push	OFFSET ??_C@_0CA@KBMDPFMM@callback?5on?5?$CFs?5missing?5context?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	pop	esi

; 7990 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:

; 7966 :         return;
; 7967 :     }
; 7968 :     if (define == NULL) {

	mov	eax, DWORD PTR _transdata$[ebp]
	test	eax, eax
	jne	SHORT $LN3@xmlRelaxNG

; 7969 :         if (token[0] == '#')

	mov	eax, DWORD PTR _token$[ebp]
	cmp	BYTE PTR [eax], 35			; 00000023H
	je	SHORT $LN9@xmlRelaxNG

; 7970 :             return;
; 7971 :         fprintf(stderr, "callback on %s missing define\n", token);

	push	eax
	push	OFFSET ??_C@_0BP@FKGGDPOM@callback?5on?5?$CFs?5missing?5define?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 7972 :         if ((ctxt != NULL) && (ctxt->errNo == XML_RELAXNG_OK))

	cmp	DWORD PTR [esi+40], 0
	jne	SHORT $LN9@xmlRelaxNG

; 7973 :             ctxt->errNo = XML_RELAXNG_ERR_INTERNAL;

	mov	DWORD PTR [esi+40], 37			; 00000025H
	pop	esi

; 7990 : }

	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 7974 :         return;
; 7975 :     }
; 7976 :     if ((ctxt == NULL) || (define == NULL)) {
; 7977 :         fprintf(stderr, "callback on %s missing info\n", token);
; 7978 :         if ((ctxt != NULL) && (ctxt->errNo == XML_RELAXNG_OK))
; 7979 :             ctxt->errNo = XML_RELAXNG_ERR_INTERNAL;
; 7980 :         return;
; 7981 :     } else if (define->type != XML_RELAXNG_ELEMENT) {

	cmp	DWORD PTR [eax], 4
	je	SHORT $LN10@xmlRelaxNG

; 7982 :         fprintf(stderr, "callback on %s define is not element\n", token);

	push	DWORD PTR _token$[ebp]
	push	OFFSET ??_C@_0CG@GECBHEAN@callback?5on?5?$CFs?5define?5is?5not?5el@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 7983 :         if (ctxt->errNo == XML_RELAXNG_OK)

	cmp	DWORD PTR [esi+40], 0
	jne	SHORT $LN9@xmlRelaxNG

; 7984 :             ctxt->errNo = XML_RELAXNG_ERR_INTERNAL;

	mov	DWORD PTR [esi+40], 37			; 00000025H
	pop	esi

; 7990 : }

	pop	ebp
	ret	0
$LN10@xmlRelaxNG:

; 7985 :         return;
; 7986 :     }
; 7987 :     ret = xmlRelaxNGValidateDefinition(ctxt, define);

	push	eax
	push	esi
	call	_xmlRelaxNGValidateDefinition
	add	esp, 8

; 7988 :     if (ret != 0)

	test	eax, eax
	je	SHORT $LN9@xmlRelaxNG

; 7989 :         ctxt->perr = ret;

	mov	DWORD PTR [esi+112], eax
$LN9@xmlRelaxNG:
	pop	esi

; 7990 : }

	pop	ebp
	ret	0
_xmlRelaxNGValidateCompiledCallback ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidateDefinition
_TEXT	SEGMENT
_oldflags$1$ = -16					; size = 4
_ret$1$ = -12						; size = 4
_i$1$ = -8						; size = 4
_states$1$ = -4						; size = 4
_j$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_define$ = 12						; size = 4
_xmlRelaxNGValidateDefinition PROC			; COMDAT

; 10632: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+60], 0
	je	SHORT $LN14@xmlRelaxNG

; 10633:     xmlRelaxNGStatesPtr states, res;
; 10634:     int i, j, k, ret, oldflags;
; 10635: 
; 10636:     /*
; 10637:      * We should NOT have both ctxt->state and ctxt->states
; 10638:      */
; 10639:     if ((ctxt->state != NULL) && (ctxt->states != NULL)) {

	cmp	DWORD PTR [esi+64], 0
	je	SHORT $LN14@xmlRelaxNG

; 10640:         TODO xmlRelaxNGFreeValidState(ctxt, ctxt->state);

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	10640					; 00002990H
	push	OFFSET ??_C@_0GJ@NFABHKPN@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	push	DWORD PTR [esi+60]
	push	esi
	call	_xmlRelaxNGFreeValidState
	add	esp, 24					; 00000018H

; 10641:         ctxt->state = NULL;

	mov	DWORD PTR [esi+60], 0
$LN14@xmlRelaxNG:

; 10642:     }
; 10643: 
; 10644:     if ((ctxt->states == NULL) || (ctxt->states->nbState == 1)) {

	mov	edi, DWORD PTR [esi+64]
	mov	DWORD PTR _states$1$[ebp], edi
	test	edi, edi
	je	$LN17@xmlRelaxNG
	cmp	DWORD PTR [edi], 1
	je	$LN16@xmlRelaxNG

; 10659:         }
; 10660:         return (ret);
; 10661:     }
; 10662: 
; 10663:     states = ctxt->states;
; 10664:     ctxt->states = NULL;
; 10665:     res = NULL;
; 10666:     j = 0;
; 10667:     oldflags = ctxt->flags;

	mov	eax, DWORD PTR [esi+28]
	xor	ecx, ecx
	mov	DWORD PTR _oldflags$1$[ebp], eax

; 10668:     ctxt->flags |= FLAGS_IGNORABLE;
; 10669:     for (i = 0; i < states->nbState; i++) {

	xor	edx, edx
	or	eax, 1
	mov	DWORD PTR [esi+64], 0
	xor	ebx, ebx
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR _j$1$[ebp], ecx
	mov	DWORD PTR _i$1$[ebp], edx
	cmp	DWORD PTR [edi], ecx
	jle	$LN3@xmlRelaxNG
$LL4@xmlRelaxNG:

; 10670:         ctxt->state = states->tabState[i];

	mov	eax, DWORD PTR [edi+8]

; 10671:         ctxt->states = NULL;
; 10672:         ret = xmlRelaxNGValidateState(ctxt, define);

	push	DWORD PTR _define$[ebp]
	push	esi
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [esi+60], eax
	mov	DWORD PTR [esi+64], 0
	call	_xmlRelaxNGValidateState

; 10673:         /*
; 10674:          * We should NOT have both ctxt->state and ctxt->states
; 10675:          */
; 10676:         if ((ctxt->state != NULL) && (ctxt->states != NULL)) {

	mov	ecx, DWORD PTR [esi+60]
	add	esp, 8
	mov	DWORD PTR _ret$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN20@xmlRelaxNG
	cmp	DWORD PTR [esi+64], 0
	je	SHORT $LN20@xmlRelaxNG

; 10677:             TODO xmlRelaxNGFreeValidState(ctxt, ctxt->state);

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	10677					; 000029b5H
	push	OFFSET ??_C@_0GJ@NFABHKPN@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	push	DWORD PTR [esi+60]
	push	esi
	call	_xmlRelaxNGFreeValidState
	mov	edi, DWORD PTR _states$1$[ebp]
	add	esp, 24					; 00000018H
	mov	eax, DWORD PTR _ret$1$[ebp]

; 10678:             ctxt->state = NULL;

	xor	ecx, ecx
	mov	DWORD PTR [esi+60], 0
$LN20@xmlRelaxNG:

; 10679:         }
; 10680:         if (ret == 0) {

	test	eax, eax
	jne	$LN21@xmlRelaxNG

; 10681:             if (ctxt->states == NULL) {

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	jne	SHORT $LN23@xmlRelaxNG

; 10682:                 if (res != NULL) {

	test	ebx, ebx
	je	SHORT $LN25@xmlRelaxNG

; 10683:                     /* add the state to the container */
; 10684:                     xmlRelaxNGAddStates(ctxt, res, ctxt->state);

	push	ecx
	push	ebx
	push	esi
	call	_xmlRelaxNGAddStates
	add	esp, 12					; 0000000cH
$LN26@xmlRelaxNG:

; 10668:     ctxt->flags |= FLAGS_IGNORABLE;
; 10669:     for (i = 0; i < states->nbState; i++) {

	mov	DWORD PTR [esi+60], 0
$LN58@xmlRelaxNG:
	mov	ecx, DWORD PTR _j$1$[ebp]
$LN2@xmlRelaxNG:
	mov	edx, DWORD PTR _i$1$[ebp]
	inc	edx
	mov	DWORD PTR _i$1$[ebp], edx
	cmp	edx, DWORD PTR [edi]
	jl	$LL4@xmlRelaxNG
$LN3@xmlRelaxNG:

; 10718:             }
; 10719:         }
; 10720:     }
; 10721:     ctxt->flags = oldflags;

	mov	eax, DWORD PTR _oldflags$1$[ebp]
	mov	DWORD PTR [esi+28], eax

; 10722:     if (res != NULL) {

	test	ebx, ebx
	je	$LN32@xmlRelaxNG

; 10723:         xmlRelaxNGFreeStates(ctxt, states);

	push	edi
	push	esi
	call	_xmlRelaxNGFreeStates
	add	esp, 8

; 10724:         ctxt->states = res;

	mov	DWORD PTR [esi+64], ebx

; 10725:         ret = 0;

	xor	ebx, ebx
	jmp	$LN38@xmlRelaxNG
$LN25@xmlRelaxNG:

; 10685:                     ctxt->state = NULL;
; 10686:                 } else {
; 10687:                     /* add the state directly in states */
; 10688:                     states->tabState[j++] = ctxt->state;

	mov	edx, DWORD PTR _j$1$[ebp]
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+edx*4], ecx
	inc	edx
	mov	DWORD PTR _j$1$[ebp], edx

; 10689:                     ctxt->state = NULL;
; 10690:                 }
; 10691:             } else {

	jmp	SHORT $LN26@xmlRelaxNG
$LN23@xmlRelaxNG:

; 10692:                 if (res == NULL) {

	xor	edi, edi
	test	ebx, ebx
	jne	SHORT $LN27@xmlRelaxNG

; 10693:                     /* make it the new container and copy other results */
; 10694:                     res = ctxt->states;
; 10695:                     ctxt->states = NULL;
; 10696:                     for (k = 0; k < j; k++)

	mov	ecx, DWORD PTR _j$1$[ebp]
	mov	ebx, eax
	mov	DWORD PTR [esi+64], edi
	test	ecx, ecx
	jle	SHORT $LN57@xmlRelaxNG
$LL7@xmlRelaxNG:

; 10697:                         xmlRelaxNGAddStates(ctxt, res,

	mov	eax, DWORD PTR _states$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [eax+edi*4]
	push	ebx
	push	esi
	call	_xmlRelaxNGAddStates
	mov	ecx, DWORD PTR _j$1$[ebp]
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, ecx
	jl	SHORT $LL7@xmlRelaxNG
$LN57@xmlRelaxNG:

; 10668:     ctxt->flags |= FLAGS_IGNORABLE;
; 10669:     for (i = 0; i < states->nbState; i++) {

	mov	edi, DWORD PTR _states$1$[ebp]
	jmp	SHORT $LN2@xmlRelaxNG
$LN27@xmlRelaxNG:

; 10698:                                             states->tabState[k]);
; 10699:                 } else {
; 10700:                     /* add all the new results to res and reff the container */
; 10701:                     for (k = 0; k < ctxt->states->nbState; k++)

	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN9@xmlRelaxNG
	npad	6
$LL10@xmlRelaxNG:

; 10702:                         xmlRelaxNGAddStates(ctxt, res,

	mov	eax, DWORD PTR [esi+64]
	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [eax+edi*4]
	push	ebx
	push	esi
	call	_xmlRelaxNGAddStates
	mov	eax, DWORD PTR [esi+64]
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL10@xmlRelaxNG
$LN9@xmlRelaxNG:

; 10703:                                             ctxt->states->tabState[k]);
; 10704:                     xmlRelaxNGFreeStates(ctxt, ctxt->states);

	push	eax
	push	esi
	call	_xmlRelaxNGFreeStates

; 10705:                     ctxt->states = NULL;
; 10706:                 }
; 10707:             }
; 10708:         } else {

	mov	edi, DWORD PTR _states$1$[ebp]
	add	esp, 8
	mov	DWORD PTR [esi+64], 0
	jmp	$LN58@xmlRelaxNG
$LN21@xmlRelaxNG:

; 10709:             if (ctxt->state != NULL) {

	test	ecx, ecx
	je	SHORT $LN29@xmlRelaxNG

; 10710:                 xmlRelaxNGFreeValidState(ctxt, ctxt->state);

	push	ecx
	push	esi
	call	_xmlRelaxNGFreeValidState
	add	esp, 8

; 10711:                 ctxt->state = NULL;

	jmp	$LN26@xmlRelaxNG
$LN29@xmlRelaxNG:

; 10712:             } else if (ctxt->states != NULL) {

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	$LN58@xmlRelaxNG

; 10713:                 for (k = 0; k < ctxt->states->nbState; k++)

	xor	edi, edi
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN12@xmlRelaxNG
	npad	8
$LL13@xmlRelaxNG:

; 10714:                     xmlRelaxNGFreeValidState(ctxt,

	mov	eax, DWORD PTR [esi+64]
	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [eax+edi*4]
	push	esi
	call	_xmlRelaxNGFreeValidState
	mov	eax, DWORD PTR [esi+64]
	inc	edi
	add	esp, 8
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL13@xmlRelaxNG
$LN12@xmlRelaxNG:

; 10715:                                              ctxt->states->tabState[k]);
; 10716:                 xmlRelaxNGFreeStates(ctxt, ctxt->states);

	push	eax
	push	esi
	call	_xmlRelaxNGFreeStates
	mov	edi, DWORD PTR _states$1$[ebp]
	add	esp, 8

; 10717:                 ctxt->states = NULL;

	mov	DWORD PTR [esi+64], 0
	jmp	$LN58@xmlRelaxNG
$LN32@xmlRelaxNG:

; 10726:     } else if (j > 1) {

	cmp	ecx, 1
	jle	SHORT $LN34@xmlRelaxNG

; 10727:         states->nbState = j;

	mov	DWORD PTR [edi], ecx

; 10728:         ctxt->states = states;
; 10729:         ret = 0;

	xor	ebx, ebx
	mov	DWORD PTR [esi+64], edi
	jmp	SHORT $LN38@xmlRelaxNG
$LN34@xmlRelaxNG:

; 10730:     } else if (j == 1) {

	push	edi
	push	esi
	jne	SHORT $LN36@xmlRelaxNG

; 10731:         ctxt->state = states->tabState[0];

	mov	eax, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+60], eax

; 10732:         xmlRelaxNGFreeStates(ctxt, states);

	call	_xmlRelaxNGFreeStates
	add	esp, 8

; 10733:         ret = 0;

	xor	ebx, ebx

; 10734:     } else {

	jmp	SHORT $LN38@xmlRelaxNG
$LN36@xmlRelaxNG:

; 10735:         ret = -1;

	or	ebx, -1

; 10736:         xmlRelaxNGFreeStates(ctxt, states);

	call	_xmlRelaxNGFreeStates

; 10737:         if (ctxt->states != NULL) {

	mov	eax, DWORD PTR [esi+64]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN38@xmlRelaxNG

; 10738:             xmlRelaxNGFreeStates(ctxt, ctxt->states);

	push	eax
	push	esi
	call	_xmlRelaxNGFreeStates
	add	esp, 8

; 10739:             ctxt->states = NULL;

	mov	DWORD PTR [esi+64], 0
$LN38@xmlRelaxNG:

; 10740:         }
; 10741:     }
; 10742:     if ((ctxt->state != NULL) && (ctxt->states != NULL)) {

	cmp	DWORD PTR [esi+60], 0
	je	$LN19@xmlRelaxNG
	cmp	DWORD PTR [esi+64], 0
	je	$LN19@xmlRelaxNG

; 10743:         TODO xmlRelaxNGFreeValidState(ctxt, ctxt->state);

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	10743					; 000029f7H
	push	OFFSET ??_C@_0GJ@NFABHKPN@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	push	DWORD PTR [esi+60]
	push	esi
	call	_xmlRelaxNGFreeValidState
	add	esp, 24					; 00000018H

; 10744:         ctxt->state = NULL;

	mov	DWORD PTR [esi+60], 0

; 10745:     }
; 10746:     return (ret);
; 10747: }

	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlRelaxNG:

; 10645:         if (ctxt->states != NULL) {
; 10646:             ctxt->state = ctxt->states->tabState[0];

	mov	eax, DWORD PTR [edi+8]

; 10647:             xmlRelaxNGFreeStates(ctxt, ctxt->states);

	push	edi
	push	esi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+60], eax
	call	_xmlRelaxNGFreeStates
	add	esp, 8

; 10648:             ctxt->states = NULL;

	mov	DWORD PTR [esi+64], 0
$LN17@xmlRelaxNG:

; 10649:         }
; 10650:         ret = xmlRelaxNGValidateState(ctxt, define);

	push	DWORD PTR _define$[ebp]
	push	esi
	call	_xmlRelaxNGValidateState
	add	esp, 8
	mov	ebx, eax

; 10651:         if ((ctxt->state != NULL) && (ctxt->states != NULL)) {

	cmp	DWORD PTR [esi+60], 0
	je	SHORT $LN18@xmlRelaxNG
	cmp	DWORD PTR [esi+64], 0
	je	SHORT $LN18@xmlRelaxNG

; 10652:             TODO xmlRelaxNGFreeValidState(ctxt, ctxt->state);

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	10652					; 0000299cH
	push	OFFSET ??_C@_0GJ@NFABHKPN@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	push	DWORD PTR [esi+60]
	push	esi
	call	_xmlRelaxNGFreeValidState
	add	esp, 24					; 00000018H

; 10653:             ctxt->state = NULL;

	mov	DWORD PTR [esi+60], 0
$LN18@xmlRelaxNG:

; 10654:         }
; 10655:         if ((ctxt->states != NULL) && (ctxt->states->nbState == 1)) {

	mov	ecx, DWORD PTR [esi+64]
	test	ecx, ecx
	je	SHORT $LN19@xmlRelaxNG
	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN19@xmlRelaxNG

; 10656:             ctxt->state = ctxt->states->tabState[0];

	mov	eax, DWORD PTR [ecx+8]

; 10657:             xmlRelaxNGFreeStates(ctxt, ctxt->states);

	push	ecx
	push	esi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+60], eax
	call	_xmlRelaxNGFreeStates
	add	esp, 8

; 10658:             ctxt->states = NULL;

	mov	DWORD PTR [esi+64], 0
$LN19@xmlRelaxNG:

; 10745:     }
; 10746:     return (ret);
; 10747: }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGValidateDefinition ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGDumpGrammar
_TEXT	SEGMENT
_output$ = 8						; size = 4
_grammar$ = 12						; size = 4
_top$ = 16						; size = 4
_xmlRelaxNGDumpGrammar PROC				; COMDAT

; 7848 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _grammar$[ebp]
	test	edi, edi
	je	$LN1@xmlRelaxNG

; 7849 :     if (grammar == NULL)
; 7850 :         return;
; 7851 : 
; 7852 :     fprintf(output, "<grammar");

	push	esi
	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_08EPHAEKIJ@?$DMgrammar@
	push	esi
	call	_fprintf
	add	esp, 8

; 7853 :     if (top)

	cmp	DWORD PTR _top$[ebp], 0
	je	SHORT $LN5@xmlRelaxNG

; 7854 :         fprintf(output, " xmlns=\"http://relaxng.org/ns/structure/1.0\"");

	push	OFFSET ??_C@_0CN@MGKJIEH@?5xmlns?$DN?$CChttp?3?1?1relaxng?4org?1ns?1s@
	push	esi
	call	_fprintf
	add	esp, 8
$LN5@xmlRelaxNG:

; 7855 :     switch (grammar->combine) {

	mov	eax, DWORD PTR [edi+16]
	sub	eax, 0
	je	SHORT $LN6@xmlRelaxNG
	sub	eax, 1
	je	SHORT $LN7@xmlRelaxNG
	sub	eax, 1
	je	SHORT $LN8@xmlRelaxNG

; 7864 :         default:
; 7865 :             fprintf(output, " <!-- invalid combine value -->");

	push	OFFSET ??_C@_0CA@NOBFJPON@?5?$DM?$CB?9?9?5invalid?5combine?5value?5?9?9?$DO@
	jmp	SHORT $LN13@xmlRelaxNG
$LN8@xmlRelaxNG:

; 7860 :             break;
; 7861 :         case XML_RELAXNG_COMBINE_INTERLEAVE:
; 7862 :             fprintf(output, " combine=\"interleave\"");

	push	OFFSET ??_C@_0BG@DIIHEMFB@?5combine?$DN?$CCinterleave?$CC@

; 7863 :             break;

	jmp	SHORT $LN13@xmlRelaxNG
$LN7@xmlRelaxNG:

; 7856 :         case XML_RELAXNG_COMBINE_UNDEFINED:
; 7857 :             break;
; 7858 :         case XML_RELAXNG_COMBINE_CHOICE:
; 7859 :             fprintf(output, " combine=\"choice\"");

	push	OFFSET ??_C@_0BC@JCPJPOMG@?5combine?$DN?$CCchoice?$CC@
$LN13@xmlRelaxNG:

; 7866 :     }
; 7867 :     fprintf(output, ">\n");

	push	esi
	call	_fprintf
	add	esp, 8
$LN6@xmlRelaxNG:
	push	OFFSET ??_C@_02NEKEAGPN@?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 8

; 7868 :     if (grammar->start == NULL) {

	cmp	DWORD PTR [edi+12], 0
	jne	SHORT $LN10@xmlRelaxNG

; 7869 :         fprintf(output, " <!-- grammar had no start -->");

	mov	eax, OFFSET ??_C@_0BP@HDPMIPMJ@?5?$DM?$CB?9?9?5grammar?5had?5no?5start?5?9?9?$DO@

; 7870 :     } else {

	jmp	SHORT $LN11@xmlRelaxNG
$LN10@xmlRelaxNG:

; 7871 :         fprintf(output, "<start>\n");

	push	OFFSET ??_C@_08JLPGMCFH@?$DMstart?$DO?6@
	push	esi
	call	_fprintf

; 7872 :         xmlRelaxNGDumpDefine(output, grammar->start);

	push	DWORD PTR [edi+12]
	push	esi
	call	_xmlRelaxNGDumpDefine
	add	esp, 16					; 00000010H

; 7873 :         fprintf(output, "</start>\n");

	mov	eax, OFFSET ??_C@_09HJPHKCIN@?$DM?1start?$DO?6@
$LN11@xmlRelaxNG:

; 7874 :     }
; 7875 :     /* TODO ? Dump the defines ? */
; 7876 :     fprintf(output, "</grammar>\n");

	push	eax
	push	esi
	call	_fprintf
	push	OFFSET ??_C@_0M@JODHEKCA@?$DM?1grammar?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 16					; 00000010H
	pop	esi
$LN1@xmlRelaxNG:
	pop	edi

; 7877 : }

	pop	ebp
	ret	0
_xmlRelaxNGDumpGrammar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGDumpDefines
_TEXT	SEGMENT
_output$ = 8						; size = 4
_defines$ = 12						; size = 4
_xmlRelaxNGDumpDefines PROC				; COMDAT

; 7715 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _defines$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlRelaxNG
	push	edi
	mov	edi, DWORD PTR _output$[ebp]
	npad	7
$LL2@xmlRelaxNG:

; 7716 :     while (defines != NULL) {
; 7717 :         xmlRelaxNGDumpDefine(output, defines);

	push	esi
	push	edi
	call	_xmlRelaxNGDumpDefine

; 7718 :         defines = defines->next;

	mov	esi, DWORD PTR [esi+32]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL2@xmlRelaxNG
	pop	edi
$LN3@xmlRelaxNG:
	pop	esi

; 7719 :     }
; 7720 : }

	pop	ebp
	ret	0
_xmlRelaxNGDumpDefines ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGDumpDefine
_TEXT	SEGMENT
_output$ = 8						; size = 4
_define$ = 12						; size = 4
_xmlRelaxNGDumpDefine PROC				; COMDAT

; 7731 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _define$[ebp]
	test	edi, edi
	je	$LN2@xmlRelaxNG

; 7732 :     if (define == NULL)
; 7733 :         return;
; 7734 :     switch (define->type) {

	mov	eax, DWORD PTR [edi]
	inc	eax
	cmp	eax, 21					; 00000015H
	ja	$LN2@xmlRelaxNG
	push	esi
	jmp	DWORD PTR $LN35@xmlRelaxNG[eax*4]
$LN5@xmlRelaxNG:
	pop	esi
	pop	edi

; 7735 :         case XML_RELAXNG_EMPTY:
; 7736 :             fprintf(output, "<empty/>\n");

	mov	DWORD PTR _define$[ebp], OFFSET ??_C@_09JHPCAGIE@?$DMempty?1?$DO?6@

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp

; 7735 :         case XML_RELAXNG_EMPTY:
; 7736 :             fprintf(output, "<empty/>\n");

	jmp	_fprintf
$LN6@xmlRelaxNG:
	pop	esi
	pop	edi

; 7737 :             break;
; 7738 :         case XML_RELAXNG_NOT_ALLOWED:
; 7739 :             fprintf(output, "<notAllowed/>\n");

	mov	DWORD PTR _define$[ebp], OFFSET ??_C@_0P@LGHJEHKL@?$DMnotAllowed?1?$DO?6@

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp

; 7737 :             break;
; 7738 :         case XML_RELAXNG_NOT_ALLOWED:
; 7739 :             fprintf(output, "<notAllowed/>\n");

	jmp	_fprintf
$LN7@xmlRelaxNG:
	pop	esi
	pop	edi

; 7740 :             break;
; 7741 :         case XML_RELAXNG_TEXT:
; 7742 :             fprintf(output, "<text/>\n");

	mov	DWORD PTR _define$[ebp], OFFSET ??_C@_08OHAPHCGE@?$DMtext?1?$DO?6@

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp

; 7740 :             break;
; 7741 :         case XML_RELAXNG_TEXT:
; 7742 :             fprintf(output, "<text/>\n");

	jmp	_fprintf
$LN8@xmlRelaxNG:

; 7743 :             break;
; 7744 :         case XML_RELAXNG_ELEMENT:
; 7745 :             fprintf(output, "<element>\n");

	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_0L@HIHOJKI@?$DMelement?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 8

; 7746 :             if (define->name != NULL) {

	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN9@xmlRelaxNG

; 7747 :                 fprintf(output, "<name");

	push	OFFSET ??_C@_05MAJIAHFB@?$DMname@
	push	esi
	call	_fprintf

; 7748 :                 if (define->ns != NULL)

	mov	eax, DWORD PTR [edi+12]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlRelaxNG

; 7749 :                     fprintf(output, " ns=\"%s\"", define->ns);

	push	eax
	push	OFFSET ??_C@_08OGOKLGPP@?5ns?$DN?$CC?$CFs?$CC@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN10@xmlRelaxNG:

; 7750 :                 fprintf(output, ">%s</name>\n", define->name);

	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_0M@NKLFPNCC@?$DO?$CFs?$DM?1name?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN9@xmlRelaxNG:

; 7751 :             }
; 7752 :             xmlRelaxNGDumpDefines(output, define->attrs);

	push	DWORD PTR [edi+36]
	push	esi
	call	_xmlRelaxNGDumpDefines

; 7753 :             xmlRelaxNGDumpDefines(output, define->content);

	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGDumpDefines

; 7754 :             fprintf(output, "</element>\n");

	push	OFFSET ??_C@_0M@DBOCEHGE@?$DM?1element?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp
	ret	0
$LN11@xmlRelaxNG:

; 7755 :             break;
; 7756 :         case XML_RELAXNG_LIST:
; 7757 :             fprintf(output, "<list>\n");

	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_07KFGHJDGD@?$DMlist?$DO?6@
	push	esi
	call	_fprintf

; 7758 :             xmlRelaxNGDumpDefines(output, define->content);

	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGDumpDefines

; 7759 :             fprintf(output, "</list>\n");

	push	OFFSET ??_C@_08BMHNFNKK@?$DM?1list?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp
	ret	0
$LN12@xmlRelaxNG:

; 7760 :             break;
; 7761 :         case XML_RELAXNG_ONEORMORE:
; 7762 :             fprintf(output, "<oneOrMore>\n");

	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_0N@GKDCALFJ@?$DMoneOrMore?$DO?6@
	push	esi
	call	_fprintf

; 7763 :             xmlRelaxNGDumpDefines(output, define->content);

	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGDumpDefines

; 7764 :             fprintf(output, "</oneOrMore>\n");

	push	OFFSET ??_C@_0O@DMBDCLJB@?$DM?1oneOrMore?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp
	ret	0
$LN13@xmlRelaxNG:

; 7765 :             break;
; 7766 :         case XML_RELAXNG_ZEROORMORE:
; 7767 :             fprintf(output, "<zeroOrMore>\n");

	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_0O@HBEPIBFH@?$DMzeroOrMore?$DO?6@
	push	esi
	call	_fprintf

; 7768 :             xmlRelaxNGDumpDefines(output, define->content);

	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGDumpDefines

; 7769 :             fprintf(output, "</zeroOrMore>\n");

	push	OFFSET ??_C@_0P@OEKGOKPF@?$DM?1zeroOrMore?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp
	ret	0
$LN14@xmlRelaxNG:

; 7770 :             break;
; 7771 :         case XML_RELAXNG_CHOICE:
; 7772 :             fprintf(output, "<choice>\n");

	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_09FMCPLLHC@?$DMchoice?$DO?6@
	push	esi
	call	_fprintf

; 7773 :             xmlRelaxNGDumpDefines(output, define->content);

	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGDumpDefines

; 7774 :             fprintf(output, "</choice>\n");

	push	OFFSET ??_C@_0L@DKMLIBNI@?$DM?1choice?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp
	ret	0
$LN15@xmlRelaxNG:

; 7775 :             break;
; 7776 :         case XML_RELAXNG_GROUP:
; 7777 :             fprintf(output, "<group>\n");

	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_08HJPOCIL@?$DMgroup?$DO?6@
	push	esi
	call	_fprintf

; 7778 :             xmlRelaxNGDumpDefines(output, define->content);

	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGDumpDefines

; 7779 :             fprintf(output, "</group>\n");

	push	OFFSET ??_C@_09OFJOICFB@?$DM?1group?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp
	ret	0
$LN16@xmlRelaxNG:

; 7780 :             break;
; 7781 :         case XML_RELAXNG_INTERLEAVE:
; 7782 :             fprintf(output, "<interleave>\n");

	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_0O@HDBAABBA@?$DMinterleave?$DO?6@
	push	esi
	call	_fprintf

; 7783 :             xmlRelaxNGDumpDefines(output, define->content);

	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGDumpDefines

; 7784 :             fprintf(output, "</interleave>\n");

	push	OFFSET ??_C@_0P@OGPJGKLC@?$DM?1interleave?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp
	ret	0
$LN17@xmlRelaxNG:

; 7785 :             break;
; 7786 :         case XML_RELAXNG_OPTIONAL:
; 7787 :             fprintf(output, "<optional>\n");

	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_0M@IMDPOIEK@?$DMoptional?$DO?6@
	push	esi
	call	_fprintf

; 7788 :             xmlRelaxNGDumpDefines(output, define->content);

	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGDumpDefines

; 7789 :             fprintf(output, "</optional>\n");

	push	OFFSET ??_C@_0N@BONLADHP@?$DM?1optional?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp
	ret	0
$LN18@xmlRelaxNG:

; 7790 :             break;
; 7791 :         case XML_RELAXNG_ATTRIBUTE:
; 7792 :             fprintf(output, "<attribute>\n");

	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_0N@ONGBDJAO@?$DMattribute?$DO?6@
	push	esi
	call	_fprintf

; 7793 :             xmlRelaxNGDumpDefines(output, define->content);

	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGDumpDefines

; 7794 :             fprintf(output, "</attribute>\n");

	push	OFFSET ??_C@_0O@LLEABJMG@?$DM?1attribute?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp
	ret	0
$LN19@xmlRelaxNG:

; 7795 :             break;
; 7796 :         case XML_RELAXNG_DEF:
; 7797 :             fprintf(output, "<define");

	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_07GFOANDBH@?$DMdefine@
	push	esi
	call	_fprintf

; 7798 :             if (define->name != NULL)

	mov	eax, DWORD PTR [edi+8]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlRelaxNG

; 7799 :                 fprintf(output, " name=\"%s\"", define->name);

	push	eax
	push	OFFSET ??_C@_0L@GBLOBBPK@?5name?$DN?$CC?$CFs?$CC@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN20@xmlRelaxNG:

; 7800 :             fprintf(output, ">\n");

	push	OFFSET ??_C@_02NEKEAGPN@?$DO?6@
	push	esi
	call	_fprintf

; 7801 :             xmlRelaxNGDumpDefines(output, define->content);

	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGDumpDefines

; 7802 :             fprintf(output, "</define>\n");

	push	OFFSET ??_C@_0L@KIKHHIKC@?$DM?1define?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp
	ret	0
$LN21@xmlRelaxNG:

; 7803 :             break;
; 7804 :         case XML_RELAXNG_REF:
; 7805 :             fprintf(output, "<ref");

	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_04OBIBPAJI@?$DMref@
	push	esi
	call	_fprintf

; 7806 :             if (define->name != NULL)

	mov	eax, DWORD PTR [edi+8]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@xmlRelaxNG

; 7807 :                 fprintf(output, " name=\"%s\"", define->name);

	push	eax
	push	OFFSET ??_C@_0L@GBLOBBPK@?5name?$DN?$CC?$CFs?$CC@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN22@xmlRelaxNG:

; 7808 :             fprintf(output, ">\n");

	push	OFFSET ??_C@_02NEKEAGPN@?$DO?6@
	push	esi
	call	_fprintf

; 7809 :             xmlRelaxNGDumpDefines(output, define->content);

	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGDumpDefines

; 7810 :             fprintf(output, "</ref>\n");

	push	OFFSET ??_C@_07KMCFPDOJ@?$DM?1ref?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp
	ret	0
$LN23@xmlRelaxNG:

; 7811 :             break;
; 7812 :         case XML_RELAXNG_PARENTREF:
; 7813 :             fprintf(output, "<parentRef");

	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_0L@BOLBFIPO@?$DMparentRef@
	push	esi
	call	_fprintf

; 7814 :             if (define->name != NULL)

	mov	eax, DWORD PTR [edi+8]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@xmlRelaxNG

; 7815 :                 fprintf(output, " name=\"%s\"", define->name);

	push	eax
	push	OFFSET ??_C@_0L@GBLOBBPK@?5name?$DN?$CC?$CFs?$CC@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN24@xmlRelaxNG:

; 7816 :             fprintf(output, ">\n");

	push	OFFSET ??_C@_02NEKEAGPN@?$DO?6@
	push	esi
	call	_fprintf

; 7817 :             xmlRelaxNGDumpDefines(output, define->content);

	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGDumpDefines

; 7818 :             fprintf(output, "</parentRef>\n");

	push	OFFSET ??_C@_0O@GNLEALJM@?$DM?1parentRef?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp
	ret	0
$LN25@xmlRelaxNG:

; 7819 :             break;
; 7820 :         case XML_RELAXNG_EXTERNALREF:
; 7821 :             fprintf(output, "<externalRef>");

	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_0O@ONLPMFHM@?$DMexternalRef?$DO@
	push	esi
	call	_fprintf

; 7822 :             xmlRelaxNGDumpDefines(output, define->content);

	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGDumpDefines

; 7823 :             fprintf(output, "</externalRef>\n");

	push	OFFSET ??_C@_0BA@JLPMEBPH@?$DM?1externalRef?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp
	ret	0
$LN26@xmlRelaxNG:

; 7824 :             break;
; 7825 :         case XML_RELAXNG_DATATYPE:
; 7826 :         case XML_RELAXNG_VALUE:
; 7827 :             TODO break;

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	7827					; 00001e93H
	jmp	SHORT $LN33@xmlRelaxNG
$LN27@xmlRelaxNG:

; 7828 :         case XML_RELAXNG_START:
; 7829 :         case XML_RELAXNG_EXCEPT:
; 7830 :         case XML_RELAXNG_PARAM:
; 7831 :             TODO break;

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	7831					; 00001e97H
$LN33@xmlRelaxNG:
	push	OFFSET ??_C@_0GJ@NFABHKPN@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	pop	esi
	pop	edi

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp
	ret	0
$LN28@xmlRelaxNG:

; 7832 :         case XML_RELAXNG_NOOP:
; 7833 :             xmlRelaxNGDumpDefines(output, define->content);

	push	DWORD PTR [edi+24]
	push	DWORD PTR _output$[ebp]
	call	_xmlRelaxNGDumpDefines
	add	esp, 8
$LN30@xmlRelaxNG:
	pop	esi
$LN2@xmlRelaxNG:
	pop	edi

; 7834 :             break;
; 7835 :     }
; 7836 : }

	pop	ebp
	ret	0
	npad	1
$LN35@xmlRelaxNG:
	DD	$LN28@xmlRelaxNG
	DD	$LN5@xmlRelaxNG
	DD	$LN6@xmlRelaxNG
	DD	$LN27@xmlRelaxNG
	DD	$LN7@xmlRelaxNG
	DD	$LN8@xmlRelaxNG
	DD	$LN26@xmlRelaxNG
	DD	$LN27@xmlRelaxNG
	DD	$LN26@xmlRelaxNG
	DD	$LN11@xmlRelaxNG
	DD	$LN18@xmlRelaxNG
	DD	$LN19@xmlRelaxNG
	DD	$LN21@xmlRelaxNG
	DD	$LN25@xmlRelaxNG
	DD	$LN23@xmlRelaxNG
	DD	$LN17@xmlRelaxNG
	DD	$LN13@xmlRelaxNG
	DD	$LN12@xmlRelaxNG
	DD	$LN14@xmlRelaxNG
	DD	$LN15@xmlRelaxNG
	DD	$LN16@xmlRelaxNG
	DD	$LN27@xmlRelaxNG
_xmlRelaxNGDumpDefine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGCleanupTree
_TEXT	SEGMENT
_ins$1$ = -24						; size = 4
_local$1$ = -24						; size = 4
_ns$1$ = -24						; size = 4
_node$1$ = -24						; size = 4
_ns$1$ = -24						; size = 4
_base$1$ = -24						; size = 4
_docu$1$ = -24						; size = 4
_base$1$ = -24						; size = 4
_uri$1$ = -24						; size = 4
_prefix$1 = -20						; size = 4
_cur$1$ = -16						; size = 4
_ns$1$ = -12						; size = 4
_name$1$ = -12						; size = 4
_incl$1$ = -12						; size = 4
_URL$1$ = -12						; size = 4
_URL$1$ = -12						; size = 4
_href$1$ = -8						; size = 4
_delete$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_root$ = 12						; size = 4
_xmlRelaxNGCleanupTree PROC				; COMDAT

; 7029 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _root$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _delete$1$[ebp], ebx
	mov	esi, eax
	mov	DWORD PTR _cur$1$[ebp], esi
	test	eax, eax
	je	$LN111@xmlRelaxNG
	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	npad	5
$LL2@xmlRelaxNG:

; 7035 :         if (delete != NULL) {

	test	ebx, ebx
	je	SHORT $LN17@xmlRelaxNG

; 7036 :             xmlUnlinkNode(delete);

	push	ebx
	call	_xmlUnlinkNode

; 7037 :             xmlFreeNode(delete);

	push	ebx
	call	_xmlFreeNode
	add	esp, 8

; 7038 :             delete = NULL;

	xor	ebx, ebx
	mov	DWORD PTR _delete$1$[ebp], ebx
$LN17@xmlRelaxNG:

; 7039 :         }
; 7040 :         if (cur->type == XML_ELEMENT_NODE) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	jne	$LN18@xmlRelaxNG

; 7041 :             /*
; 7042 :              * Simplification 4.1. Annotations
; 7043 :              */
; 7044 :             if ((cur->ns == NULL) ||

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	$LN22@xmlRelaxNG
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN22@xmlRelaxNG

; 7057 :             } else {
; 7058 :                 xmlRelaxNGCleanupAttributes(ctxt, cur);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	esi
	push	ebx
	call	_xmlRelaxNGCleanupAttributes

; 7059 :                 if (xmlStrEqual(cur->name, BAD_CAST "externalRef")) {

	push	OFFSET ??_C@_0M@CPEFJFBC@externalRef@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN25@xmlRelaxNG

; 7060 :                     xmlChar *href, *ns, *base, *URL;
; 7061 :                     xmlRelaxNGDocumentPtr docu;
; 7062 :                     xmlNodePtr tmp;
; 7063 : 		    xmlURIPtr uri;
; 7064 : 
; 7065 :                     ns = xmlGetProp(cur, BAD_CAST "ns");

	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	esi
	call	_xmlGetProp
	mov	edi, eax
	add	esp, 8

; 7066 :                     if (ns == NULL) {

	test	edi, edi
	jne	SHORT $LN135@xmlRelaxNG

; 7067 :                         tmp = cur->parent;

	mov	ebx, DWORD PTR [esi+20]

; 7068 :                         while ((tmp != NULL) &&

	test	ebx, ebx
	je	SHORT $LN182@xmlRelaxNG
$LL4@xmlRelaxNG:
	cmp	DWORD PTR [ebx+4], 1
	jne	SHORT $LN182@xmlRelaxNG

; 7069 :                                (tmp->type == XML_ELEMENT_NODE)) {
; 7070 :                             ns = xmlGetProp(tmp, BAD_CAST "ns");

	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	ebx
	call	_xmlGetProp
	mov	edi, eax
	add	esp, 8

; 7071 :                             if (ns != NULL)

	test	edi, edi
	jne	SHORT $LN182@xmlRelaxNG

; 7072 :                                 break;
; 7073 :                             tmp = tmp->parent;

	mov	ebx, DWORD PTR [ebx+20]
	test	ebx, ebx
	jne	SHORT $LL4@xmlRelaxNG
$LN182@xmlRelaxNG:

; 7074 :                         }
; 7075 :                     }
; 7076 :                     href = xmlGetProp(cur, BAD_CAST "href");

	mov	ebx, DWORD PTR _ctxt$[ebp]
$LN135@xmlRelaxNG:
	push	OFFSET ??_C@_04CMBCJJJD@href@
	push	esi
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _href$1$[ebp], eax

; 7077 :                     if (href == NULL) {

	test	eax, eax
	jne	SHORT $LN29@xmlRelaxNG

; 7078 :                         xmlRngPErr(ctxt, cur, XML_RNGP_MISSING_HREF,

	push	eax
	push	eax
	push	OFFSET ??_C@_0DE@IKNPMFHP@xmlRelaxNGParse?3?5externalRef?5ha@
	push	1052					; 0000041cH
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 7079 :                                    "xmlRelaxNGParse: externalRef has no href attribute\n",
; 7080 :                                    NULL, NULL);
; 7081 :                         if (ns != NULL)

	test	edi, edi
	je	SHORT $LN30@xmlRelaxNG

; 7082 :                             xmlFree(ns);

	push	edi
$LN186@xmlRelaxNG:

; 7431 :             }
; 7432 :         }
; 7433 :       skip_children:
; 7434 :         if (cur->next != NULL) {

	call	DWORD PTR _xmlFree
	add	esp, 4
$LN30@xmlRelaxNG:
	mov	edi, DWORD PTR _ctxt$[ebp]
$LN102@xmlRelaxNG:
	mov	ebx, esi
	mov	DWORD PTR _delete$1$[ebp], ebx
$skip_children$189:
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	$LL16@xmlRelaxNG

; 7435 :             cur = cur->next;

	mov	esi, eax
	mov	DWORD PTR _cur$1$[ebp], esi

; 7436 :             continue;

	jmp	$LN15@xmlRelaxNG
$LN29@xmlRelaxNG:

; 7083 :                         delete = cur;
; 7084 :                         goto skip_children;
; 7085 :                     }
; 7086 : 		    uri = xmlParseURI((const char *) href);

	push	eax
	call	_xmlParseURI
	add	esp, 4
	mov	DWORD PTR _uri$1$[ebp], eax

; 7087 : 		    if (uri == NULL) {

	test	eax, eax
	jne	SHORT $LN31@xmlRelaxNG

; 7088 :                         xmlRngPErr(ctxt, cur, XML_RNGP_HREF_ERROR,

	push	eax
	push	DWORD PTR _href$1$[ebp]
	push	OFFSET ??_C@_0CC@NOODBOMC@Incorrect?5URI?5for?5externalRef?5?$CF@
	push	1041					; 00000411H
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 7089 :                                    "Incorrect URI for externalRef %s\n",
; 7090 :                                    href, NULL);
; 7091 :                         if (ns != NULL)

	test	edi, edi
	je	SHORT $LN32@xmlRelaxNG

; 7092 :                             xmlFree(ns);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN32@xmlRelaxNG:

; 7093 :                         if (href != NULL)
; 7094 :                             xmlFree(href);

	push	DWORD PTR _href$1$[ebp]

; 7095 :                         delete = cur;
; 7096 :                         goto skip_children;

	jmp	SHORT $LN186@xmlRelaxNG
$LN31@xmlRelaxNG:

; 7097 : 		    }
; 7098 : 		    if (uri->fragment != NULL) {

	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN34@xmlRelaxNG

; 7099 :                         xmlRngPErr(ctxt, cur, XML_RNGP_HREF_ERROR,

	push	0
	push	DWORD PTR _href$1$[ebp]
	push	OFFSET ??_C@_0CO@GJLFMGAP@Fragment?5forbidden?5in?5URI?5for?5e@
	push	1041					; 00000411H
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 7100 : 			       "Fragment forbidden in URI for externalRef %s\n",
; 7101 :                                    href, NULL);
; 7102 :                         if (ns != NULL)

	test	edi, edi
	je	SHORT $LN35@xmlRelaxNG

; 7103 :                             xmlFree(ns);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN35@xmlRelaxNG:

; 7104 : 		        xmlFreeURI(uri);

	push	DWORD PTR _uri$1$[ebp]
	call	_xmlFreeURI

; 7105 :                         if (href != NULL)
; 7106 :                             xmlFree(href);

	push	DWORD PTR _href$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 8

; 7107 :                         delete = cur;
; 7108 :                         goto skip_children;

	jmp	$LN30@xmlRelaxNG
$LN34@xmlRelaxNG:

; 7109 : 		    }
; 7110 : 		    xmlFreeURI(uri);

	push	eax
	call	_xmlFreeURI

; 7111 :                     base = xmlNodeGetBase(cur->doc, cur);

	push	esi
	push	DWORD PTR [esi+32]
	call	_xmlNodeGetBase

; 7112 :                     URL = xmlBuildURI(href, base);

	push	eax
	push	DWORD PTR _href$1$[ebp]
	mov	DWORD PTR _base$1$[ebp], eax
	call	_xmlBuildURI
	add	esp, 20					; 00000014H
	mov	DWORD PTR _URL$1$[ebp], eax

; 7113 :                     if (URL == NULL) {

	test	eax, eax
	jne	SHORT $LN37@xmlRelaxNG

; 7114 :                         xmlRngPErr(ctxt, cur, XML_RNGP_HREF_ERROR,

	push	eax
	push	DWORD PTR _href$1$[ebp]
	push	OFFSET ??_C@_0CK@MJBGKOFC@Failed?5to?5compute?5URL?5for?5exter@
	push	1041					; 00000411H
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 7115 :                                    "Failed to compute URL for externalRef %s\n",
; 7116 :                                    href, NULL);
; 7117 :                         if (ns != NULL)

	test	edi, edi
	je	SHORT $LN38@xmlRelaxNG

; 7118 :                             xmlFree(ns);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN38@xmlRelaxNG:

; 7119 :                         if (href != NULL)
; 7120 :                             xmlFree(href);

	push	DWORD PTR _href$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN184@xmlRelaxNG:

; 7431 :             }
; 7432 :         }
; 7433 :       skip_children:
; 7434 :         if (cur->next != NULL) {

	mov	eax, DWORD PTR _base$1$[ebp]
	test	eax, eax
	je	$LN30@xmlRelaxNG
	push	eax
	jmp	$LN186@xmlRelaxNG
$LN37@xmlRelaxNG:

; 7121 :                         if (base != NULL)
; 7122 :                             xmlFree(base);
; 7123 :                         delete = cur;
; 7124 :                         goto skip_children;
; 7125 :                     }
; 7126 :                     if (href != NULL)
; 7127 :                         xmlFree(href);

	push	DWORD PTR _href$1$[ebp]
	call	DWORD PTR _xmlFree

; 7128 :                     if (base != NULL)

	mov	eax, DWORD PTR _base$1$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN42@xmlRelaxNG

; 7129 :                         xmlFree(base);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN42@xmlRelaxNG:

; 7130 :                     docu = xmlRelaxNGLoadExternalRef(ctxt, URL, ns);

	push	edi
	push	DWORD PTR _URL$1$[ebp]
	push	ebx
	call	_xmlRelaxNGLoadExternalRef
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _docu$1$[ebp], eax

; 7131 :                     if (docu == NULL) {

	test	eax, eax
	jne	SHORT $LN43@xmlRelaxNG

; 7132 :                         xmlRngPErr(ctxt, cur, XML_RNGP_EXTERNAL_REF_FAILURE,

	push	eax
	push	DWORD PTR _URL$1$[ebp]
	push	OFFSET ??_C@_0BP@HCBMCAK@Failed?5to?5load?5externalRef?5?$CFs?6@
	push	1032					; 00000408H
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 7133 :                                    "Failed to load externalRef %s\n", URL,
; 7134 :                                    NULL);
; 7135 :                         if (ns != NULL)

	test	edi, edi
	je	SHORT $LN44@xmlRelaxNG

; 7136 :                             xmlFree(ns);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN44@xmlRelaxNG:

; 7137 :                         xmlFree(URL);

	push	DWORD PTR _URL$1$[ebp]

; 7138 :                         delete = cur;
; 7139 :                         goto skip_children;

	jmp	$LN186@xmlRelaxNG
$LN43@xmlRelaxNG:

; 7140 :                     }
; 7141 :                     if (ns != NULL)

	test	edi, edi
	je	SHORT $LN45@xmlRelaxNG

; 7142 :                         xmlFree(ns);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN45@xmlRelaxNG:

; 7143 :                     xmlFree(URL);

	push	DWORD PTR _URL$1$[ebp]
	call	DWORD PTR _xmlFree

; 7144 :                     cur->psvi = docu;

	mov	eax, DWORD PTR _docu$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+52], eax
	jmp	$LN69@xmlRelaxNG
$LN25@xmlRelaxNG:

; 7145 :                 } else if (xmlStrEqual(cur->name, BAD_CAST "include")) {

	push	OFFSET ??_C@_07FHOHOHLG@include@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN46@xmlRelaxNG

; 7146 :                     xmlChar *href, *ns, *base, *URL;
; 7147 :                     xmlRelaxNGIncludePtr incl;
; 7148 :                     xmlNodePtr tmp;
; 7149 : 
; 7150 :                     href = xmlGetProp(cur, BAD_CAST "href");

	push	OFFSET ??_C@_04CMBCJJJD@href@
	push	esi
	call	_xmlGetProp
	mov	edi, eax
	add	esp, 8

; 7151 :                     if (href == NULL) {

	test	edi, edi
	jne	SHORT $LN48@xmlRelaxNG

; 7152 :                         xmlRngPErr(ctxt, cur, XML_RNGP_MISSING_HREF,

	push	eax
	push	eax
	push	OFFSET ??_C@_0DA@KKFOMCKH@xmlRelaxNGParse?3?5include?5has?5no@
	push	1052					; 0000041cH
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 7153 :                                    "xmlRelaxNGParse: include has no href attribute\n",
; 7154 :                                    NULL, NULL);
; 7155 :                         delete = cur;
; 7156 :                         goto skip_children;

	jmp	$LN30@xmlRelaxNG
$LN48@xmlRelaxNG:

; 7157 :                     }
; 7158 :                     base = xmlNodeGetBase(cur->doc, cur);

	push	esi
	push	DWORD PTR [esi+32]
	call	_xmlNodeGetBase

; 7159 :                     URL = xmlBuildURI(href, base);

	push	eax
	push	edi
	mov	DWORD PTR _base$1$[ebp], eax
	call	_xmlBuildURI
	add	esp, 16					; 00000010H
	mov	DWORD PTR _URL$1$[ebp], eax

; 7160 :                     if (URL == NULL) {

	test	eax, eax
	jne	SHORT $LN49@xmlRelaxNG

; 7161 :                         xmlRngPErr(ctxt, cur, XML_RNGP_HREF_ERROR,

	push	eax
	push	edi
	push	OFFSET ??_C@_0CG@HMHDMNIG@Failed?5to?5compute?5URL?5for?5inclu@
	push	1041					; 00000411H
	push	esi
	push	ebx
	call	_xmlRngPErr

; 7162 :                                    "Failed to compute URL for include %s\n",
; 7163 :                                    href, NULL);
; 7164 :                         if (href != NULL)
; 7165 :                             xmlFree(href);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 28					; 0000001cH

; 7166 :                         if (base != NULL)
; 7167 :                             xmlFree(base);
; 7168 :                         delete = cur;
; 7169 :                         goto skip_children;

	jmp	$LN184@xmlRelaxNG
$LN49@xmlRelaxNG:

; 7170 :                     }
; 7171 :                     if (href != NULL)
; 7172 :                         xmlFree(href);

	push	edi
	call	DWORD PTR _xmlFree

; 7173 :                     if (base != NULL)

	mov	eax, DWORD PTR _base$1$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN53@xmlRelaxNG

; 7174 :                         xmlFree(base);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN53@xmlRelaxNG:

; 7175 :                     ns = xmlGetProp(cur, BAD_CAST "ns");

	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	esi
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _ns$1$[ebp], eax

; 7176 :                     if (ns == NULL) {

	test	eax, eax
	jne	SHORT $LN136@xmlRelaxNG

; 7177 :                         tmp = cur->parent;

	mov	edi, DWORD PTR [esi+20]

; 7178 :                         while ((tmp != NULL) &&

	test	edi, edi
	je	SHORT $LN136@xmlRelaxNG
	npad	7
$LL6@xmlRelaxNG:
	cmp	DWORD PTR [edi+4], 1
	jne	SHORT $LN180@xmlRelaxNG

; 7179 :                                (tmp->type == XML_ELEMENT_NODE)) {
; 7180 :                             ns = xmlGetProp(tmp, BAD_CAST "ns");

	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	edi
	call	_xmlGetProp
	add	esp, 8

; 7181 :                             if (ns != NULL)

	test	eax, eax
	jne	SHORT $LN180@xmlRelaxNG

; 7182 :                                 break;
; 7183 :                             tmp = tmp->parent;

	mov	edi, DWORD PTR [edi+20]
	test	edi, edi
	jne	SHORT $LL6@xmlRelaxNG
$LN180@xmlRelaxNG:
	mov	DWORD PTR _ns$1$[ebp], eax
$LN136@xmlRelaxNG:

; 7184 :                         }
; 7185 :                     }
; 7186 :                     incl = xmlRelaxNGLoadInclude(ctxt, URL, cur, ns);

	mov	edi, DWORD PTR _URL$1$[ebp]
	push	eax
	push	esi
	push	edi
	push	ebx
	call	_xmlRelaxNGLoadInclude
	mov	DWORD PTR _incl$1$[ebp], eax
	add	esp, 16					; 00000010H

; 7187 :                     if (ns != NULL)

	mov	eax, DWORD PTR _ns$1$[ebp]
	test	eax, eax
	je	SHORT $LN56@xmlRelaxNG

; 7188 :                         xmlFree(ns);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN56@xmlRelaxNG:

; 7189 :                     if (incl == NULL) {

	cmp	DWORD PTR _incl$1$[ebp], 0
	jne	SHORT $LN57@xmlRelaxNG

; 7190 :                         xmlRngPErr(ctxt, cur, XML_RNGP_INCLUDE_FAILURE,

	push	0
	push	edi
	push	OFFSET ??_C@_0BL@NFGKAGJD@Failed?5to?5load?5include?5?$CFs?6@
	push	1043					; 00000413H
	push	esi
	push	ebx
	call	_xmlRngPErr

; 7191 :                                    "Failed to load include %s\n", URL,
; 7192 :                                    NULL);
; 7193 :                         xmlFree(URL);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 28					; 0000001cH

; 7194 :                         delete = cur;
; 7195 :                         goto skip_children;

	jmp	$LN30@xmlRelaxNG
$LN57@xmlRelaxNG:

; 7196 :                     }
; 7197 :                     xmlFree(URL);

	push	edi
	call	DWORD PTR _xmlFree

; 7198 :                     cur->psvi = incl;

	mov	eax, DWORD PTR _incl$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+52], eax
	jmp	$LN69@xmlRelaxNG
$LN46@xmlRelaxNG:

; 7199 :                 } else if ((xmlStrEqual(cur->name, BAD_CAST "element")) ||

	push	OFFSET ??_C@_07HCLJNICE@element@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN60@xmlRelaxNG
	push	OFFSET ??_C@_09HGIEBAJ@attribute@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN60@xmlRelaxNG

; 7244 :                         }
; 7245 :                     }
; 7246 :                 } else if ((xmlStrEqual(cur->name, BAD_CAST "name")) ||
; 7247 :                            (xmlStrEqual(cur->name, BAD_CAST "nsName")) ||

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN72@xmlRelaxNG
	push	OFFSET ??_C@_06IHANJIJ@nsName@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN72@xmlRelaxNG
	push	OFFSET ??_C@_05MFEJDJP@value@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN72@xmlRelaxNG

; 7313 :                 } else if ((xmlStrEqual(cur->name, BAD_CAST "except")) &&

	push	OFFSET ??_C@_06JBKEBCGB@except@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN84@xmlRelaxNG
	cmp	esi, DWORD PTR _root$[ebp]
	je	SHORT $LN84@xmlRelaxNG

; 7314 :                            (cur != root)) {
; 7315 :                     int oldflags = ctxt->flags;
; 7316 : 
; 7317 :                     /*
; 7318 :                      * 4.16
; 7319 :                      */
; 7320 :                     if ((cur->parent != NULL) &&

	mov	eax, DWORD PTR [esi+20]
	mov	edi, DWORD PTR [ebx+32]
	test	eax, eax
	je	SHORT $LN173@xmlRelaxNG
	push	OFFSET ??_C@_07ENOEFKNN@anyName@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN173@xmlRelaxNG

; 7321 :                         (xmlStrEqual
; 7322 :                          (cur->parent->name, BAD_CAST "anyName"))) {
; 7323 :                         ctxt->flags |= XML_RELAXNG_IN_ANYEXCEPT;

	or	DWORD PTR [ebx+32], 256			; 00000100H
$LN187@xmlRelaxNG:

; 7431 :             }
; 7432 :         }
; 7433 :       skip_children:
; 7434 :         if (cur->next != NULL) {

	push	esi
	push	ebx
	call	_xmlRelaxNGCleanupTree
	mov	DWORD PTR [ebx+32], edi
	add	esp, 8
	mov	edi, ebx
	mov	ebx, DWORD PTR _delete$1$[ebp]
	jmp	$skip_children$189
$LN173@xmlRelaxNG:

; 7324 :                         xmlRelaxNGCleanupTree(ctxt, cur);
; 7325 :                         ctxt->flags = oldflags;
; 7326 :                         goto skip_children;
; 7327 :                     } else if ((cur->parent != NULL) &&

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	$LN69@xmlRelaxNG
	push	OFFSET ??_C@_06IHANJIJ@nsName@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN69@xmlRelaxNG

; 7328 :                                (xmlStrEqual
; 7329 :                                 (cur->parent->name, BAD_CAST "nsName"))) {
; 7330 :                         ctxt->flags |= XML_RELAXNG_IN_NSEXCEPT;

	or	DWORD PTR [ebx+32], 512			; 00000200H

; 7331 :                         xmlRelaxNGCleanupTree(ctxt, cur);
; 7332 :                         ctxt->flags = oldflags;
; 7333 :                         goto skip_children;

	jmp	SHORT $LN187@xmlRelaxNG
$LN84@xmlRelaxNG:

; 7334 :                     }
; 7335 :                 } else if (xmlStrEqual(cur->name, BAD_CAST "anyName")) {

	push	OFFSET ??_C@_07ENOEFKNN@anyName@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN69@xmlRelaxNG

; 7336 :                     /*
; 7337 :                      * 4.16
; 7338 :                      */
; 7339 :                     if (ctxt->flags & XML_RELAXNG_IN_ANYEXCEPT) {

	mov	eax, DWORD PTR [ebx+32]
	test	eax, 256				; 00000100H
	je	SHORT $LN90@xmlRelaxNG

; 7340 :                         xmlRngPErr(ctxt, cur,

	push	0
	push	0
	push	OFFSET ??_C@_0DD@IENCCDMP@Found?5anyName?1except?1?1anyName?5f@
	push	1066					; 0000042aH
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
	jmp	$LN69@xmlRelaxNG
$LN90@xmlRelaxNG:

; 7341 :                                    XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME,
; 7342 :                                    "Found anyName/except//anyName forbidden construct\n",
; 7343 :                                    NULL, NULL);
; 7344 :                     } else if (ctxt->flags & XML_RELAXNG_IN_NSEXCEPT) {

	test	eax, 512				; 00000200H
	je	$LN69@xmlRelaxNG

; 7345 :                         xmlRngPErr(ctxt, cur,

	push	0
	push	0
	push	OFFSET ??_C@_0DC@EKOIKCCH@Found?5nsName?1except?1?1anyName?5fo@
	push	1084					; 0000043cH
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
	jmp	$LN69@xmlRelaxNG
$LN72@xmlRelaxNG:

; 7248 :                            (xmlStrEqual(cur->name, BAD_CAST "value"))) {
; 7249 :                     /*
; 7250 :                      * Simplification 4.8. name attribute of element
; 7251 :                      * and attribute elements
; 7252 :                      */
; 7253 :                     if (xmlHasProp(cur, BAD_CAST "ns") == NULL) {

	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	esi
	call	_xmlHasProp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN76@xmlRelaxNG

; 7254 :                         xmlNodePtr node;
; 7255 :                         xmlChar *ns = NULL;
; 7256 : 
; 7257 :                         node = cur->parent;

	mov	edi, DWORD PTR [esi+20]

; 7258 :                         while ((node != NULL) &&

	test	edi, edi
	je	SHORT $LN169@xmlRelaxNG
	npad	4
$LL8@xmlRelaxNG:
	cmp	DWORD PTR [edi+4], 1
	jne	SHORT $LN169@xmlRelaxNG

; 7259 :                                (node->type == XML_ELEMENT_NODE)) {
; 7260 :                             ns = xmlGetProp(node, BAD_CAST "ns");

	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	edi
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _ns$1$[ebp], eax

; 7261 :                             if (ns != NULL) {

	test	eax, eax
	jne	$LN75@xmlRelaxNG

; 7262 :                                 break;
; 7263 :                             }
; 7264 :                             node = node->parent;

	mov	edi, DWORD PTR [edi+20]
	test	edi, edi
	jne	SHORT $LL8@xmlRelaxNG
$LN169@xmlRelaxNG:

; 7265 :                         }
; 7266 :                         if (ns == NULL) {
; 7267 :                             xmlSetProp(cur, BAD_CAST "ns", BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	esi
	call	_xmlSetProp
	add	esp, 12					; 0000000cH
$LN76@xmlRelaxNG:

; 7271 :                         }
; 7272 :                     }
; 7273 :                     if (xmlStrEqual(cur->name, BAD_CAST "name")) {

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN78@xmlRelaxNG

; 7274 :                         xmlChar *name, *local, *prefix;
; 7275 : 
; 7276 :                         /*
; 7277 :                          * Simplification: 4.10. QNames
; 7278 :                          */
; 7279 :                         name = xmlNodeGetContent(cur);

	push	esi
	call	_xmlNodeGetContent
	mov	edi, eax
	add	esp, 4

; 7280 :                         if (name != NULL) {

	test	edi, edi
	je	$LN78@xmlRelaxNG

; 7281 :                             local = xmlSplitQName2(name, &prefix);

	lea	eax, DWORD PTR _prefix$1[ebp]
	push	eax
	push	edi
	call	_xmlSplitQName2
	add	esp, 8
	mov	DWORD PTR _local$1$[ebp], eax

; 7282 :                             if (local != NULL) {

	test	eax, eax
	je	SHORT $LN79@xmlRelaxNG

; 7283 :                                 xmlNsPtr ns;
; 7284 : 
; 7285 :                                 ns = xmlSearchNs(cur->doc, cur, prefix);

	push	DWORD PTR _prefix$1[ebp]
	push	esi
	push	DWORD PTR [esi+32]
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH

; 7286 :                                 if (ns == NULL) {

	test	eax, eax
	jne	SHORT $LN80@xmlRelaxNG

; 7287 :                                     xmlRngPErr(ctxt, cur,

	push	eax
	push	DWORD PTR _prefix$1[ebp]
	push	OFFSET ??_C@_0CN@ILNMLAAE@xmlRelaxNGParse?3?5no?5namespace?5f@
	push	1097					; 00000449H
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 7288 :                                                XML_RNGP_PREFIX_UNDEFINED,
; 7289 :                                                "xmlRelaxNGParse: no namespace for prefix %s\n",
; 7290 :                                                prefix, NULL);
; 7291 :                                 } else {

	jmp	SHORT $LN81@xmlRelaxNG
$LN75@xmlRelaxNG:

; 7268 :                         } else {
; 7269 :                             xmlSetProp(cur, BAD_CAST "ns", ns);

	push	eax
	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	esi
	call	_xmlSetProp

; 7270 :                             xmlFree(ns);

	push	DWORD PTR _ns$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H
	jmp	$LN76@xmlRelaxNG
$LN80@xmlRelaxNG:

; 7292 :                                     xmlSetProp(cur, BAD_CAST "ns",

	push	DWORD PTR [eax+8]
	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	esi
	call	_xmlSetProp

; 7293 :                                                ns->href);
; 7294 :                                     xmlNodeSetContent(cur, local);

	push	DWORD PTR _local$1$[ebp]
	push	esi
	call	_xmlNodeSetContent
	add	esp, 20					; 00000014H
$LN81@xmlRelaxNG:

; 7295 :                                 }
; 7296 :                                 xmlFree(local);

	push	DWORD PTR _local$1$[ebp]
	call	DWORD PTR _xmlFree

; 7297 :                                 xmlFree(prefix);

	push	DWORD PTR _prefix$1[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 8
$LN79@xmlRelaxNG:

; 7298 :                             }
; 7299 :                             xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN78@xmlRelaxNG:

; 7300 :                         }
; 7301 :                     }
; 7302 :                     /*
; 7303 :                      * 4.16
; 7304 :                      */
; 7305 :                     if (xmlStrEqual(cur->name, BAD_CAST "nsName")) {

	push	OFFSET ??_C@_06IHANJIJ@nsName@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN69@xmlRelaxNG

; 7306 :                         if (ctxt->flags & XML_RELAXNG_IN_NSEXCEPT) {

	test	DWORD PTR [ebx+32], 512			; 00000200H
	je	$LN69@xmlRelaxNG

; 7307 :                             xmlRngPErr(ctxt, cur,

	push	0
	push	0
	push	OFFSET ??_C@_0DB@OONPGEPE@Found?5nsName?1except?1?1nsName?5for@
	push	1085					; 0000043dH
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 7308 :                                        XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME,
; 7309 :                                        "Found nsName/except//nsName forbidden construct\n",
; 7310 :                                        NULL, NULL);
; 7311 :                         }
; 7312 :                     }

	jmp	$LN69@xmlRelaxNG
$LN60@xmlRelaxNG:

; 7200 :                            (xmlStrEqual(cur->name, BAD_CAST "attribute")))
; 7201 :                 {
; 7202 :                     xmlChar *name, *ns;
; 7203 :                     xmlNodePtr text = NULL;
; 7204 : 
; 7205 :                     /*
; 7206 :                      * Simplification 4.8. name attribute of element
; 7207 :                      * and attribute elements
; 7208 :                      */
; 7209 :                     name = xmlGetProp(cur, BAD_CAST "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	esi
	xor	edi, edi
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _name$1$[ebp], eax

; 7210 :                     if (name != NULL) {

	test	eax, eax
	je	$LN69@xmlRelaxNG

; 7211 :                         if (cur->children == NULL) {

	mov	ecx, DWORD PTR [esi+36]
	cmp	DWORD PTR [esi+12], edi
	jne	SHORT $LN62@xmlRelaxNG

; 7212 :                             text =

	push	eax
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	ecx
	push	esi
	call	_xmlNewChild
	add	esp, 16					; 00000010H
	mov	edi, eax

; 7213 :                                 xmlNewChild(cur, cur->ns, BAD_CAST "name",
; 7214 :                                             name);
; 7215 :                         } else {

	jmp	SHORT $LN64@xmlRelaxNG
$LN62@xmlRelaxNG:

; 7216 :                             xmlNodePtr node;
; 7217 : 
; 7218 :                             node = xmlNewDocNode(cur->doc, cur->ns,

	push	0
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	ecx
	push	DWORD PTR [esi+32]
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _node$1$[ebp], eax

; 7219 : 			                         BAD_CAST "name", NULL);
; 7220 :                             if (node != NULL) {

	test	eax, eax
	je	SHORT $LN170@xmlRelaxNG

; 7221 :                                 xmlAddPrevSibling(cur->children, node);

	push	eax
	push	DWORD PTR [esi+12]
	call	_xmlAddPrevSibling

; 7222 :                                 text = xmlNewText(name);

	push	DWORD PTR _name$1$[ebp]
	call	_xmlNewText

; 7223 :                                 xmlAddChild(node, text);

	mov	edi, DWORD PTR _node$1$[ebp]
	push	eax
	push	edi
	call	_xmlAddChild
	add	esp, 20					; 00000014H
$LN64@xmlRelaxNG:

; 7224 :                                 text = node;
; 7225 :                             }
; 7226 :                         }
; 7227 :                         if (text == NULL) {

	test	edi, edi
	jne	SHORT $LN65@xmlRelaxNG
$LN170@xmlRelaxNG:

; 7228 :                             xmlRngPErr(ctxt, cur, XML_RNGP_CREATE_FAILURE,

	push	0
	push	DWORD PTR _name$1$[ebp]
	push	OFFSET ??_C@_0CE@PCFKGPKF@Failed?5to?5create?5a?5name?5?$CFs?5elem@
	push	1008					; 000003f0H
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN65@xmlRelaxNG:

; 7229 :                                        "Failed to create a name %s element\n",
; 7230 :                                        name, NULL);
; 7231 :                         }
; 7232 :                         xmlUnsetProp(cur, BAD_CAST "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	esi
	call	_xmlUnsetProp

; 7233 :                         xmlFree(name);

	push	DWORD PTR _name$1$[ebp]
	call	DWORD PTR _xmlFree

; 7234 :                         ns = xmlGetProp(cur, BAD_CAST "ns");

	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	esi
	call	_xmlGetProp
	mov	ebx, eax
	add	esp, 20					; 00000014H

; 7235 :                         if (ns != NULL) {

	test	ebx, ebx
	je	SHORT $LN66@xmlRelaxNG

; 7236 :                             if (text != NULL) {

	test	edi, edi
	je	SHORT $LN68@xmlRelaxNG

; 7237 :                                 xmlSetProp(text, BAD_CAST "ns", ns);

	push	ebx
	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	edi
	call	_xmlSetProp
	add	esp, 12					; 0000000cH
$LN68@xmlRelaxNG:

; 7238 :                                 /* xmlUnsetProp(cur, BAD_CAST "ns"); */
; 7239 :                             }
; 7240 :                             xmlFree(ns);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
	jmp	SHORT $LN69@xmlRelaxNG
$LN66@xmlRelaxNG:

; 7241 :                         } else if (xmlStrEqual(cur->name,

	push	OFFSET ??_C@_09HGIEBAJ@attribute@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN69@xmlRelaxNG

; 7242 :                                                BAD_CAST "attribute")) {
; 7243 :                             xmlSetProp(text, BAD_CAST "ns", BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	edi
	call	_xmlSetProp
	add	esp, 12					; 0000000cH
$LN69@xmlRelaxNG:

; 7346 :                                    XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME,
; 7347 :                                    "Found nsName/except//anyName forbidden construct\n",
; 7348 :                                    NULL, NULL);
; 7349 :                     }
; 7350 :                 }
; 7351 :                 /*
; 7352 :                  * This is not an else since "include" is transformed
; 7353 :                  * into a div
; 7354 :                  */
; 7355 :                 if (xmlStrEqual(cur->name, BAD_CAST "div")) {

	push	OFFSET ??_C@_03FEJMGOGI@div@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN181@xmlRelaxNG

; 7356 :                     xmlChar *ns;
; 7357 :                     xmlNodePtr child, ins, tmp;
; 7358 : 
; 7359 :                     /*
; 7360 :                      * implements rule 4.11
; 7361 :                      */
; 7362 : 
; 7363 :                     ns = xmlGetProp(cur, BAD_CAST "ns");

	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	esi
	call	_xmlGetProp

; 7364 : 
; 7365 :                     child = cur->children;

	mov	ebx, DWORD PTR [esi+12]
	add	esp, 8
	mov	DWORD PTR _ns$1$[ebp], eax

; 7366 :                     ins = cur;

	mov	DWORD PTR _ins$1$[ebp], esi

; 7367 :                     while (child != NULL) {

	test	ebx, ebx
	je	SHORT $LN11@xmlRelaxNG
	mov	esi, eax
	npad	4
$LL10@xmlRelaxNG:

; 7368 :                         if (ns != NULL) {

	test	esi, esi
	je	SHORT $LN95@xmlRelaxNG

; 7369 :                             if (!xmlHasProp(child, BAD_CAST "ns")) {

	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	ebx
	call	_xmlHasProp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN95@xmlRelaxNG

; 7370 :                                 xmlSetProp(child, BAD_CAST "ns", ns);

	push	esi
	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	ebx
	call	_xmlSetProp
	add	esp, 12					; 0000000cH
$LN95@xmlRelaxNG:

; 7371 :                             }
; 7372 :                         }
; 7373 :                         tmp = child->next;

	mov	edi, DWORD PTR [ebx+24]

; 7374 :                         xmlUnlinkNode(child);

	push	ebx
	call	_xmlUnlinkNode

; 7375 :                         ins = xmlAddNextSibling(ins, child);

	push	ebx
	push	DWORD PTR _ins$1$[ebp]
	call	_xmlAddNextSibling
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ins$1$[ebp], eax

; 7376 :                         child = tmp;

	mov	ebx, edi
	test	edi, edi
	jne	SHORT $LL10@xmlRelaxNG
	mov	esi, DWORD PTR _cur$1$[ebp]
	mov	eax, DWORD PTR _ns$1$[ebp]
$LN11@xmlRelaxNG:

; 7377 :                     }
; 7378 :                     if (ns != NULL)

	test	eax, eax
	je	SHORT $LN96@xmlRelaxNG

; 7379 :                         xmlFree(ns);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN96@xmlRelaxNG:

; 7380 : 		    /*
; 7381 : 		     * Since we are about to delete cur, if its nsDef is non-NULL we
; 7382 : 		     * need to preserve it (it contains the ns definitions for the
; 7383 : 		     * children we just moved).  We'll just stick it on to the end
; 7384 : 		     * of cur->parent's list, since it's never going to be re-serialized
; 7385 : 		     * (bug 143738).
; 7386 : 		     */
; 7387 : 		    if ((cur->nsDef != NULL) && (cur->parent != NULL)) {

	mov	edi, DWORD PTR [esi+48]
	test	edi, edi
	je	$LN30@xmlRelaxNG
	mov	edx, DWORD PTR [esi+20]
	test	edx, edx
	je	$LN30@xmlRelaxNG

; 7388 : 			xmlNsPtr parDef = (xmlNsPtr)&cur->parent->nsDef;
; 7389 : 			while (parDef->next != NULL)

	mov	ecx, DWORD PTR [edx+48]
	add	edx, 48					; 00000030H
	test	ecx, ecx
	je	SHORT $LN13@xmlRelaxNG
$LL12@xmlRelaxNG:
	mov	eax, DWORD PTR [ecx]

; 7390 : 			    parDef = parDef->next;

	mov	edx, ecx
	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL12@xmlRelaxNG
$LN13@xmlRelaxNG:

; 7391 : 			parDef->next = cur->nsDef;

	mov	DWORD PTR [edx], edi

; 7392 : 			cur->nsDef = NULL;

	mov	DWORD PTR [esi+48], 0

; 7393 : 		    }
; 7394 :                     delete = cur;
; 7395 :                     goto skip_children;

	jmp	$LN30@xmlRelaxNG
$LN22@xmlRelaxNG:

; 7045 :                 (!xmlStrEqual(cur->ns->href, xmlRelaxNGNs))) {
; 7046 :                 if ((cur->parent != NULL) &&
; 7047 :                     (cur->parent->type == XML_ELEMENT_NODE) &&

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	$LN102@xmlRelaxNG
	cmp	DWORD PTR [eax+4], 1
	jne	$LN102@xmlRelaxNG
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN24@xmlRelaxNG
	mov	eax, DWORD PTR [esi+20]
	push	OFFSET ??_C@_05MFEJDJP@value@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN24@xmlRelaxNG
	mov	eax, DWORD PTR [esi+20]
	push	OFFSET ??_C@_05LJDNNBIK@param@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN102@xmlRelaxNG
$LN24@xmlRelaxNG:

; 7048 :                     ((xmlStrEqual(cur->parent->name, BAD_CAST "name")) ||
; 7049 :                      (xmlStrEqual(cur->parent->name, BAD_CAST "value")) ||
; 7050 :                      (xmlStrEqual(cur->parent->name, BAD_CAST "param")))) {
; 7051 :                     xmlRngPErr(ctxt, cur, XML_RNGP_FOREIGN_ELEMENT,

	mov	eax, DWORD PTR [esi+20]

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	ecx, ecx

; 517  :     void *data = NULL;

	xor	edx, edx

; 7048 :                     ((xmlStrEqual(cur->parent->name, BAD_CAST "name")) ||
; 7049 :                      (xmlStrEqual(cur->parent->name, BAD_CAST "value")) ||
; 7050 :                      (xmlStrEqual(cur->parent->name, BAD_CAST "param")))) {
; 7051 :                     xmlRngPErr(ctxt, cur, XML_RNGP_FOREIGN_ELEMENT,

	mov	ebx, DWORD PTR [eax+8]

; 515  :     xmlStructuredErrorFunc schannel = NULL;

	xor	eax, eax

; 518  : 
; 519  :     if (ctxt != NULL) {

	test	edi, edi
	je	SHORT $LN114@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	jne	SHORT $LN116@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	ecx, DWORD PTR [edi+4]
$LN116@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	edx, DWORD PTR [edi]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [edi+36]
$LN114@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	ebx
	push	OFFSET ??_C@_0CL@IEADNMBI@element?5?$CFs?5doesn?8t?5allow?5foreig@
	push	0
	push	0
	push	0
	push	0
	push	ebx
	push	0
	push	0
	push	2
	push	1035					; 0000040bH
	push	18					; 00000012H
	push	esi
	push	0
	push	edx
	push	ecx
	push	eax
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 7052 :                                "element %s doesn't allow foreign elements\n",
; 7053 :                                cur->parent->name, NULL);
; 7054 :                 }
; 7055 :                 delete = cur;
; 7056 :                 goto skip_children;

	jmp	$LN102@xmlRelaxNG
$LN18@xmlRelaxNG:

; 7396 :                 }
; 7397 :             }
; 7398 :         }
; 7399 :         /*
; 7400 :          * Simplification 4.2 whitespaces
; 7401 :          */
; 7402 :         else if ((cur->type == XML_TEXT_NODE) ||

	cmp	eax, 3
	je	SHORT $LN100@xmlRelaxNG
	cmp	eax, 4
	jne	$LN102@xmlRelaxNG
$LN100@xmlRelaxNG:

; 7403 :                  (cur->type == XML_CDATA_SECTION_NODE)) {
; 7404 :             if (IS_BLANK_NODE(cur)) {

	mov	ecx, DWORD PTR [esi+40]

; 3464 :     if (str == NULL)

	test	ecx, ecx
	je	SHORT $LN120@xmlRelaxNG

; 3465 :         return (1);
; 3466 :     while (*str != 0) {

	mov	al, BYTE PTR [ecx]
	test	al, al
	je	SHORT $LN120@xmlRelaxNG
$LL119@xmlRelaxNG:

; 3467 :         if (!(IS_BLANK_CH(*str)))

	cmp	al, 32					; 00000020H
	je	SHORT $LN122@xmlRelaxNG
	cmp	al, 9
	jb	SHORT $LN123@xmlRelaxNG
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN122@xmlRelaxNG
$LN123@xmlRelaxNG:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN103@xmlRelaxNG
$LN122@xmlRelaxNG:

; 3465 :         return (1);
; 3466 :     while (*str != 0) {

	mov	al, BYTE PTR [ecx+1]

; 3468 :             return (0);
; 3469 :         str++;

	inc	ecx
	test	al, al
	jne	SHORT $LL119@xmlRelaxNG
$LN120@xmlRelaxNG:

; 7405 :                 if ((cur->parent != NULL) &&

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	$LN102@xmlRelaxNG
	cmp	DWORD PTR [eax+4], 1
	jne	$LN102@xmlRelaxNG

; 7406 : 		    (cur->parent->type == XML_ELEMENT_NODE)) {
; 7407 :                     if ((!xmlStrEqual(cur->parent->name, BAD_CAST "value"))
; 7408 :                         &&

	push	OFFSET ??_C@_05MFEJDJP@value@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN103@xmlRelaxNG
	mov	eax, DWORD PTR [esi+20]
	push	OFFSET ??_C@_05LJDNNBIK@param@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN103@xmlRelaxNG

; 7409 :                         (!xmlStrEqual
; 7410 :                          (cur->parent->name, BAD_CAST "param")))
; 7411 :                         delete = cur;

	mov	ebx, esi
	mov	DWORD PTR _delete$1$[ebp], ebx
	jmp	SHORT $LN103@xmlRelaxNG
$LN181@xmlRelaxNG:

; 7346 :                                    XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME,
; 7347 :                                    "Found nsName/except//anyName forbidden construct\n",
; 7348 :                                    NULL, NULL);
; 7349 :                     }
; 7350 :                 }
; 7351 :                 /*
; 7352 :                  * This is not an else since "include" is transformed
; 7353 :                  * into a div
; 7354 :                  */
; 7355 :                 if (xmlStrEqual(cur->name, BAD_CAST "div")) {

	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	ebx, DWORD PTR _delete$1$[ebp]
$LN103@xmlRelaxNG:

; 7412 :                 } else {
; 7413 :                     delete = cur;
; 7414 :                     goto skip_children;
; 7415 :                 }
; 7416 :             }
; 7417 :         } else {
; 7418 :             delete = cur;
; 7419 :             goto skip_children;
; 7420 :         }
; 7421 : 
; 7422 :         /*
; 7423 :          * Skip to next node
; 7424 :          */
; 7425 :         if (cur->children != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	$skip_children$189

; 7426 :             if ((cur->children->type != XML_ENTITY_DECL) &&
; 7427 :                 (cur->children->type != XML_ENTITY_REF_NODE) &&

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 17					; 00000011H
	je	$skip_children$189
	cmp	ecx, 5
	je	$skip_children$189
	cmp	ecx, 6
	je	$skip_children$189

; 7428 :                 (cur->children->type != XML_ENTITY_NODE)) {
; 7429 :                 cur = cur->children;

	mov	esi, eax
	mov	DWORD PTR _cur$1$[ebp], esi

; 7430 :                 continue;

	jmp	SHORT $LN15@xmlRelaxNG
	npad	6
$LL16@xmlRelaxNG:

; 7437 :         }
; 7438 : 
; 7439 :         do {
; 7440 :             cur = cur->parent;

	mov	esi, DWORD PTR [esi+20]

; 7441 :             if (cur == NULL)

	test	esi, esi
	je	SHORT $LN140@xmlRelaxNG

; 7442 :                 break;
; 7443 :             if (cur == root) {

	cmp	esi, DWORD PTR _root$[ebp]
	je	SHORT $LN140@xmlRelaxNG

; 7444 :                 cur = NULL;
; 7445 :                 break;
; 7446 :             }
; 7447 :             if (cur->next != NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LL16@xmlRelaxNG

; 7448 :                 cur = cur->next;

	mov	esi, eax
	mov	DWORD PTR _cur$1$[ebp], eax
$LN15@xmlRelaxNG:

; 7030 :     xmlNodePtr cur, delete;
; 7031 : 
; 7032 :     delete = NULL;
; 7033 :     cur = root;
; 7034 :     while (cur != NULL) {

	test	esi, esi
	jne	$LL2@xmlRelaxNG
$LN140@xmlRelaxNG:

; 7449 :                 break;
; 7450 :             }
; 7451 :         } while (cur != NULL);
; 7452 :     }
; 7453 :     if (delete != NULL) {

	pop	edi
	test	ebx, ebx
	je	SHORT $LN111@xmlRelaxNG

; 7454 :         xmlUnlinkNode(delete);

	push	ebx
	call	_xmlUnlinkNode

; 7455 :         xmlFreeNode(delete);

	push	ebx
	call	_xmlFreeNode
	add	esp, 8
$LN111@xmlRelaxNG:

; 7456 :         delete = NULL;
; 7457 :     }
; 7458 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGCleanupTree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGCleanupAttributes
_TEXT	SEGMENT
_next$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_uri$1$ = 12						; size = 4
_node$ = 12						; size = 4
_xmlRelaxNGCleanupAttributes PROC			; COMDAT

; 6941 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	$LN3@xmlRelaxNG
	push	ebx
	mov	ebx, DWORD PTR _ctxt$[ebp]
$LL2@xmlRelaxNG:

; 6942 :     xmlAttrPtr cur, next;
; 6943 : 
; 6944 :     cur = node->properties;
; 6945 :     while (cur != NULL) {
; 6946 :         next = cur->next;

	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR _next$1$[ebp], eax

; 6947 :         if ((cur->ns == NULL) ||

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN5@xmlRelaxNG
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN26@xmlRelaxNG
$LN5@xmlRelaxNG:

; 6948 :             (xmlStrEqual(cur->ns->href, xmlRelaxNGNs))) {
; 6949 :             if (xmlStrEqual(cur->name, BAD_CAST "name")) {

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG

; 6950 :                 if ((!xmlStrEqual(node->name, BAD_CAST "element")) &&
; 6951 :                     (!xmlStrEqual(node->name, BAD_CAST "attribute")) &&
; 6952 :                     (!xmlStrEqual(node->name, BAD_CAST "ref")) &&
; 6953 :                     (!xmlStrEqual(node->name, BAD_CAST "parentRef")) &&
; 6954 :                     (!xmlStrEqual(node->name, BAD_CAST "param")) &&

	push	OFFSET ??_C@_07HCLJNICE@element@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN26@xmlRelaxNG
	push	OFFSET ??_C@_09HGIEBAJ@attribute@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN26@xmlRelaxNG
	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN26@xmlRelaxNG
	push	OFFSET ??_C@_09LEMMFILP@parentRef@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN26@xmlRelaxNG
	push	OFFSET ??_C@_05LJDNNBIK@param@

; 6955 :                     (!xmlStrEqual(node->name, BAD_CAST "define"))) {
; 6956 :                     xmlRngPErr(ctxt, node, XML_RNGP_FORBIDDEN_ATTRIBUTE,
; 6957 :                                "Attribute %s is not allowed on %s\n",
; 6958 :                                cur->name, node->name);
; 6959 :                 }

	jmp	SHORT $LN34@xmlRelaxNG
$LN6@xmlRelaxNG:

; 6960 :             } else if (xmlStrEqual(cur->name, BAD_CAST "type")) {

	push	OFFSET ??_C@_04GPMDFGEJ@type@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlRelaxNG

; 6961 :                 if ((!xmlStrEqual(node->name, BAD_CAST "value")) &&

	push	OFFSET ??_C@_05MFEJDJP@value@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN26@xmlRelaxNG
	push	OFFSET ??_C@_04PJOLNDGD@data@

; 6962 :                     (!xmlStrEqual(node->name, BAD_CAST "data"))) {
; 6963 :                     xmlRngPErr(ctxt, node, XML_RNGP_FORBIDDEN_ATTRIBUTE,
; 6964 :                                "Attribute %s is not allowed on %s\n",
; 6965 :                                cur->name, node->name);
; 6966 :                 }

	jmp	SHORT $LN33@xmlRelaxNG
$LN9@xmlRelaxNG:

; 6967 :             } else if (xmlStrEqual(cur->name, BAD_CAST "href")) {

	push	OFFSET ??_C@_04CMBCJJJD@href@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlRelaxNG

; 6968 :                 if ((!xmlStrEqual(node->name, BAD_CAST "externalRef")) &&

	push	OFFSET ??_C@_0M@CPEFJFBC@externalRef@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN26@xmlRelaxNG
	push	OFFSET ??_C@_07FHOHOHLG@include@

; 6969 :                     (!xmlStrEqual(node->name, BAD_CAST "include"))) {
; 6970 :                     xmlRngPErr(ctxt, node, XML_RNGP_FORBIDDEN_ATTRIBUTE,
; 6971 :                                "Attribute %s is not allowed on %s\n",
; 6972 :                                cur->name, node->name);
; 6973 :                 }

	jmp	SHORT $LN33@xmlRelaxNG
$LN12@xmlRelaxNG:

; 6974 :             } else if (xmlStrEqual(cur->name, BAD_CAST "combine")) {

	push	OFFSET ??_C@_07PCDCECCK@combine@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlRelaxNG

; 6975 :                 if ((!xmlStrEqual(node->name, BAD_CAST "start")) &&

	push	OFFSET ??_C@_05FAGFPHJG@start@
$LN34@xmlRelaxNG:

; 7011 :                            "Unknown attribute %s on %s\n", cur->name,
; 7012 :                            node->name);
; 7013 :             }
; 7014 :         }
; 7015 :         cur = next;

	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN26@xmlRelaxNG
	push	OFFSET ??_C@_06EPMMJFDC@define@
$LN33@xmlRelaxNG:
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN26@xmlRelaxNG
	push	DWORD PTR [esi+8]
	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_0CD@DKPPJJNH@Attribute?5?$CFs?5is?5not?5allowed?5on?5@
	push	1034					; 0000040aH
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
	jmp	$LN26@xmlRelaxNG
$LN15@xmlRelaxNG:

; 6976 :                     (!xmlStrEqual(node->name, BAD_CAST "define"))) {
; 6977 :                     xmlRngPErr(ctxt, node, XML_RNGP_FORBIDDEN_ATTRIBUTE,
; 6978 :                                "Attribute %s is not allowed on %s\n",
; 6979 :                                cur->name, node->name);
; 6980 :                 }
; 6981 :             } else if (xmlStrEqual(cur->name, BAD_CAST "datatypeLibrary")) {

	push	OFFSET ??_C@_0BA@OLOJGOCH@datatypeLibrary@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN18@xmlRelaxNG

; 6982 :                 xmlChar *val;
; 6983 :                 xmlURIPtr uri;
; 6984 : 
; 6985 :                 val = xmlNodeListGetString(node->doc, cur->children, 1);

	push	1
	push	DWORD PTR [edi+12]
	push	DWORD PTR [esi+32]
	call	_xmlNodeListGetString
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 6986 :                 if (val != NULL) {

	test	ebx, ebx
	je	$LN32@xmlRelaxNG

; 6987 :                     if (val[0] != 0) {

	cmp	BYTE PTR [ebx], 0
	je	SHORT $LN23@xmlRelaxNG

; 6988 :                         uri = xmlParseURI((const char *) val);

	push	ebx
	call	_xmlParseURI
	add	esp, 4
	mov	DWORD PTR _uri$1$[ebp], eax

; 6989 :                         if (uri == NULL) {

	test	eax, eax
	jne	SHORT $LN22@xmlRelaxNG

; 6990 :                             xmlRngPErr(ctxt, node, XML_RNGP_INVALID_URI,

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	ebx
	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_0CG@BHOFIFCK@Attribute?5?$CFs?5contains?5invalid?5U@
	push	1050					; 0000041aH
	push	esi
	push	eax
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 6991 :                                        "Attribute %s contains invalid URI %s\n",
; 6992 :                                        cur->name, val);
; 6993 :                         } else {

	jmp	SHORT $LN23@xmlRelaxNG
$LN22@xmlRelaxNG:

; 6994 :                             if (uri->scheme == NULL) {

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN24@xmlRelaxNG

; 6995 :                                 xmlRngPErr(ctxt, node, XML_RNGP_URI_NOT_ABSOLUTE,

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	ebx
	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_0CF@MJPHBHBO@Attribute?5?$CFs?5URI?5?$CFs?5is?5not?5abso@
	push	1118					; 0000045eH
	push	esi
	push	eax
	call	_xmlRngPErr
	mov	eax, DWORD PTR _uri$1$[ebp]
	add	esp, 24					; 00000018H
$LN24@xmlRelaxNG:

; 6996 :                                            "Attribute %s URI %s is not absolute\n",
; 6997 :                                            cur->name, val);
; 6998 :                             }
; 6999 :                             if (uri->fragment != NULL) {

	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN25@xmlRelaxNG

; 7000 :                                 xmlRngPErr(ctxt, node, XML_RNGP_URI_FRAGMENT,

	push	ebx
	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_0CH@HOEFBPIP@Attribute?5?$CFs?5URI?5?$CFs?5has?5a?5fragm@
	push	1117					; 0000045dH
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRngPErr
	mov	eax, DWORD PTR _uri$1$[ebp]
	add	esp, 24					; 00000018H
$LN25@xmlRelaxNG:

; 7001 :                                            "Attribute %s URI %s has a fragment ID\n",
; 7002 :                                            cur->name, val);
; 7003 :                             }
; 7004 :                             xmlFreeURI(uri);

	push	eax
	call	_xmlFreeURI
	add	esp, 4
$LN23@xmlRelaxNG:

; 7005 :                         }
; 7006 :                     }
; 7007 :                     xmlFree(val);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN32@xmlRelaxNG:

; 7011 :                            "Unknown attribute %s on %s\n", cur->name,
; 7012 :                            node->name);
; 7013 :             }
; 7014 :         }
; 7015 :         cur = next;

	mov	ebx, DWORD PTR _ctxt$[ebp]
$LN26@xmlRelaxNG:
	mov	eax, DWORD PTR _next$1$[ebp]
	mov	edi, eax
	test	eax, eax
	jne	$LL2@xmlRelaxNG
	pop	ebx
$LN3@xmlRelaxNG:
	pop	edi

; 7016 :     }
; 7017 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlRelaxNG:

; 7008 :                 }
; 7009 :             } else if (!xmlStrEqual(cur->name, BAD_CAST "ns")) {

	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@xmlRelaxNG

; 7010 :                 xmlRngPErr(ctxt, node, XML_RNGP_UNKNOWN_ATTRIBUTE,

	push	DWORD PTR [esi+8]
	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_0BM@DCBEKLDL@Unknown?5attribute?5?$CFs?5on?5?$CFs?6@
	push	1113					; 00000459H

; 7011 :                            "Unknown attribute %s on %s\n", cur->name,
; 7012 :                            node->name);
; 7013 :             }
; 7014 :         }
; 7015 :         cur = next;

	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
	jmp	SHORT $LN26@xmlRelaxNG
_xmlRelaxNGCleanupAttributes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGCheckRules
_TEXT	SEGMENT
_node$1$ = -8						; size = 4
_node$1$ = -8						; size = 4
_val$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_node$1$ = 12						; size = 4
_node$1$ = 12						; size = 4
_channel$1$ = 12					; size = 4
_node$1$ = 12						; size = 4
_node$1$ = 12						; size = 4
_node$1$ = 12						; size = 4
_str1$1$ = 12						; size = 4
_cur$ = 12						; size = 4
_flags$ = 16						; size = 4
_ptype$ = 20						; size = 4
_xmlRelaxNGCheckRules PROC				; COMDAT

; 6274 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _cur$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _val$1$[ebp], ecx
	test	edi, edi
	je	$LN204@xmlRelaxNG
	push	ebx
	mov	ebx, DWORD PTR _flags$[ebp]
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	npad	7
$LL2@xmlRelaxNG:

; 6279 :         ret = XML_RELAXNG_CONTENT_EMPTY;
; 6280 :         if ((cur->type == XML_RELAXNG_REF) ||

	mov	eax, DWORD PTR [edi]
	cmp	eax, 11					; 0000000bH
	je	$LN6@xmlRelaxNG
	cmp	eax, 13					; 0000000dH
	je	$LN6@xmlRelaxNG

; 6318 :             }
; 6319 :         } else if (cur->type == XML_RELAXNG_ELEMENT) {

	cmp	eax, 4
	jne	$LN15@xmlRelaxNG

; 6320 :             /*
; 6321 :              * The 7.3 Attribute derivation rule for groups is plugged there
; 6322 :              */
; 6323 :             xmlRelaxNGCheckGroupAttrs(ctxt, cur);

	push	edi
	push	esi
	call	_xmlRelaxNGCheckGroupAttrs
	add	esp, 8

; 6324 :             if (flags & XML_RELAXNG_IN_DATAEXCEPT) {

	test	bl, 8
	je	SHORT $LN110@xmlRelaxNG

; 6325 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_ELEM,

	mov	eax, DWORD PTR [edi+4]

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	edx, edx

; 6325 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_ELEM,

	mov	DWORD PTR _node$1$[ebp], eax

; 517  :     void *data = NULL;

	xor	ecx, ecx
	xor	eax, eax

; 518  : 
; 519  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN193@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN194@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [esi+4]
$LN194@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	ecx, DWORD PTR [esi]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [esi+36]
$LN193@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	0
	push	OFFSET ??_C@_0DD@HDAPPKEG@Found?5forbidden?5pattern?5data?1ex@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1070					; 0000042eH
	push	18					; 00000012H
	push	DWORD PTR _node$1$[ebp]
	push	0
	push	ecx
	push	edx
	push	eax
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN110@xmlRelaxNG:

; 6326 :                            "Found forbidden pattern data/except//element(ref)\n",
; 6327 :                            NULL, NULL);
; 6328 :             }
; 6329 :             if (flags & XML_RELAXNG_IN_LIST) {

	test	bl, 4
	je	SHORT $LN115@xmlRelaxNG

; 6330 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_LIST_ELEM,

	mov	eax, DWORD PTR [edi+4]

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	edx, edx

; 6330 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_LIST_ELEM,

	mov	DWORD PTR _node$1$[ebp], eax

; 517  :     void *data = NULL;

	xor	ecx, ecx
	xor	eax, eax

; 518  : 
; 519  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN195@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN196@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [esi+4]
$LN196@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	ecx, DWORD PTR [esi]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [esi+36]
$LN195@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	0
	push	OFFSET ??_C@_0CM@EGCJFEMH@Found?5forbidden?5pattern?5list?1?1e@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1079					; 00000437H
	push	18					; 00000012H
	push	DWORD PTR _node$1$[ebp]
	push	0
	push	ecx
	push	edx
	push	eax
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN115@xmlRelaxNG:

; 6331 :                            "Found forbidden pattern list//element(ref)\n",
; 6332 :                            NULL, NULL);
; 6333 :             }
; 6334 :             if (flags & XML_RELAXNG_IN_ATTRIBUTE) {

	test	bl, 1
	je	$LN125@xmlRelaxNG

; 6335 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_ATTR_ELEM,

	mov	ebx, DWORD PTR [edi+4]

; 515  :     xmlStructuredErrorFunc schannel = NULL;

	xor	eax, eax

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	edx, edx

; 517  :     void *data = NULL;

	xor	ecx, ecx

; 518  : 
; 519  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN197@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN198@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [esi+4]
$LN198@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	ecx, DWORD PTR [esi]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [esi+36]
$LN197@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	0
	push	OFFSET ??_C@_0DB@MJBLDFBL@Found?5forbidden?5pattern?5attribu@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1068					; 0000042cH
	push	18					; 00000012H
	push	ebx
	push	0
	push	ecx
	push	edx
	push	eax
	call	___xmlRaiseError

; 6336 :                            "Found forbidden pattern attribute//element(ref)\n",
; 6337 :                            NULL, NULL);
; 6338 :             }
; 6339 :             if (flags & XML_RELAXNG_IN_ATTRIBUTE) {
; 6340 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_ATTR_ELEM,

	mov	ebx, DWORD PTR [edi+4]

; 527  :     __xmlRaiseError(schannel, channel, data,

	add	esp, 72					; 00000048H

; 515  :     xmlStructuredErrorFunc schannel = NULL;

	xor	eax, eax

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	edx, edx

; 517  :     void *data = NULL;

	xor	ecx, ecx

; 518  : 
; 519  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN199@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN200@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [esi+4]
$LN200@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	ecx, DWORD PTR [esi]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [esi+36]
$LN199@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	0
	push	OFFSET ??_C@_0DB@MJBLDFBL@Found?5forbidden?5pattern?5attribu@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1068					; 0000042cH
	push	18					; 00000012H
	push	ebx
	push	0
	push	ecx
	push	edx
	push	eax
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN125@xmlRelaxNG:

; 6341 :                            "Found forbidden pattern attribute//element(ref)\n",
; 6342 :                            NULL, NULL);
; 6343 :             }
; 6344 :             /*
; 6345 :              * reset since in the simple form elements are only child
; 6346 :              * of grammar/define
; 6347 :              */
; 6348 :             nflags = 0;
; 6349 :             ret =

	push	DWORD PTR [edi]
	push	0
	push	DWORD PTR [edi+36]
	push	esi
	call	_xmlRelaxNGCheckRules
	add	esp, 16					; 00000010H

; 6350 :                 xmlRelaxNGCheckRules(ctxt, cur->attrs, nflags, cur->type);
; 6351 :             if (ret != XML_RELAXNG_CONTENT_EMPTY) {

	test	eax, eax
	je	SHORT $LN130@xmlRelaxNG

; 6352 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_ELEM_CONTENT_EMPTY,

	mov	eax, DWORD PTR [edi+4]

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	edx, edx

; 6352 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_ELEM_CONTENT_EMPTY,

	mov	ebx, DWORD PTR [edi+8]

; 517  :     void *data = NULL;

	xor	ecx, ecx

; 6352 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_ELEM_CONTENT_EMPTY,

	mov	DWORD PTR _node$1$[ebp], eax

; 515  :     xmlStructuredErrorFunc schannel = NULL;

	xor	eax, eax

; 518  : 
; 519  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN201@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN133@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [esi+4]
$LN133@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	ecx, DWORD PTR [esi]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [esi+36]
$LN201@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	ebx
	push	OFFSET ??_C@_0DB@COIJMLBL@Element?5?$CFs?5attributes?5have?5a?5co@
	push	0
	push	0
	push	0
	push	0
	push	ebx
	push	0
	push	0
	push	2
	push	1015					; 000003f7H
	push	18					; 00000012H
	push	DWORD PTR _node$1$[ebp]
	push	0
	push	ecx
	push	edx
	push	eax
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN130@xmlRelaxNG:

; 6353 :                            "Element %s attributes have a content type error\n",
; 6354 :                            cur->name, NULL);
; 6355 :             }
; 6356 :             ret =

	push	DWORD PTR [edi]
	push	0
	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGCheckRules
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 6357 :                 xmlRelaxNGCheckRules(ctxt, cur->content, nflags,
; 6358 :                                      cur->type);
; 6359 :             if (ret == XML_RELAXNG_CONTENT_ERROR) {

	cmp	ebx, -1
	jne	$LN22@xmlRelaxNG

; 6360 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_ELEM_CONTENT_ERROR,

	mov	eax, DWORD PTR [edi+8]

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	edx, edx

; 6360 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_ELEM_CONTENT_ERROR,

	mov	DWORD PTR _str1$1$[ebp], eax

; 517  :     void *data = NULL;

	xor	ecx, ecx

; 6360 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_ELEM_CONTENT_ERROR,

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _node$1$[ebp], eax

; 515  :     xmlStructuredErrorFunc schannel = NULL;

	xor	eax, eax

; 518  : 
; 519  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN136@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN138@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [esi+4]
$LN138@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	ecx, DWORD PTR [esi]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [esi+36]
$LN136@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	DWORD PTR _str1$1$[ebp]
	push	OFFSET ??_C@_0CF@DGIEHIGM@Element?5?$CFs?5has?5a?5content?5type?5e@
	push	0
	push	0
	push	0
	push	0
	push	DWORD PTR _str1$1$[ebp]
	push	0
	push	0
	push	2
	push	1016					; 000003f8H
	push	18					; 00000012H
	push	DWORD PTR _node$1$[ebp]
	push	0
	push	ecx
	push	edx
	push	eax
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 6361 :                            "Element %s has a content type error\n",
; 6362 :                            cur->name, NULL);
; 6363 :             } else {

	jmp	$LN14@xmlRelaxNG
$LN15@xmlRelaxNG:

; 6364 :                 ret = XML_RELAXNG_CONTENT_COMPLEX;
; 6365 :             }
; 6366 :         } else if (cur->type == XML_RELAXNG_ATTRIBUTE) {

	cmp	eax, 9
	jne	$LN24@xmlRelaxNG

; 6367 :             if (flags & XML_RELAXNG_IN_ATTRIBUTE) {

	test	bl, 1
	je	SHORT $LN26@xmlRelaxNG

; 6368 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_ATTR_ATTR,

	push	0
	push	0
	push	OFFSET ??_C@_0CO@INMFBEHE@Found?5forbidden?5pattern?5attribu@
	push	1067					; 0000042bH
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN26@xmlRelaxNG:

; 6369 :                            "Found forbidden pattern attribute//attribute\n",
; 6370 :                            NULL, NULL);
; 6371 :             }
; 6372 :             if (flags & XML_RELAXNG_IN_LIST) {

	test	bl, 4
	je	SHORT $LN27@xmlRelaxNG

; 6373 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_LIST_ATTR,

	push	0
	push	0
	push	OFFSET ??_C@_0CJ@MJOFOIHP@Found?5forbidden?5pattern?5list?1?1a@
	push	1078					; 00000436H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN27@xmlRelaxNG:

; 6374 :                            "Found forbidden pattern list//attribute\n",
; 6375 :                            NULL, NULL);
; 6376 :             }
; 6377 :             if (flags & XML_RELAXNG_IN_OOMGROUP) {

	test	bl, 32					; 00000020H
	je	SHORT $LN28@xmlRelaxNG

; 6378 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_ONEMORE_GROUP_ATTR,

	push	0
	push	0
	push	OFFSET ??_C@_0DF@EKCKBFFE@Found?5forbidden?5pattern?5oneOrMo@
	push	1086					; 0000043eH
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN28@xmlRelaxNG:

; 6379 :                            "Found forbidden pattern oneOrMore//group//attribute\n",
; 6380 :                            NULL, NULL);
; 6381 :             }
; 6382 :             if (flags & XML_RELAXNG_IN_OOMINTERLEAVE) {

	test	bl, 64					; 00000040H
	je	SHORT $LN29@xmlRelaxNG

; 6383 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR,

	push	0
	push	0
	push	OFFSET ??_C@_0DK@NGAGBKIF@Found?5forbidden?5pattern?5oneOrMo@
	push	1087					; 0000043fH
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN29@xmlRelaxNG:

; 6384 :                            "Found forbidden pattern oneOrMore//interleave//attribute\n",
; 6385 :                            NULL, NULL);
; 6386 :             }
; 6387 :             if (flags & XML_RELAXNG_IN_DATAEXCEPT) {

	test	bl, 8
	je	SHORT $LN30@xmlRelaxNG

; 6388 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_ATTR,

	push	0
	push	0
	push	OFFSET ??_C@_0DA@ENKJFBDG@Found?5forbidden?5pattern?5data?1ex@
	push	1069					; 0000042dH
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN30@xmlRelaxNG:

; 6389 :                            "Found forbidden pattern data/except//attribute\n",
; 6390 :                            NULL, NULL);
; 6391 :             }
; 6392 :             if (flags & XML_RELAXNG_IN_START) {

	test	bl, 16					; 00000010H
	je	SHORT $LN31@xmlRelaxNG

; 6393 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_START_ATTR,

	push	0
	push	0
	push	OFFSET ??_C@_0CK@BCEDDHLB@Found?5forbidden?5pattern?5start?1?1@
	push	1088					; 00000440H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN31@xmlRelaxNG:

; 6394 :                            "Found forbidden pattern start//attribute\n",
; 6395 :                            NULL, NULL);
; 6396 :             }
; 6397 :             if ((!(flags & XML_RELAXNG_IN_ONEORMORE))
; 6398 :                 && (cur->name == NULL)) {

	test	bl, 2
	jne	SHORT $LN34@xmlRelaxNG
	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN34@xmlRelaxNG

; 6399 :                 if (cur->ns == NULL) {

	cmp	DWORD PTR [edi+12], 0
	mov	eax, DWORD PTR [edi+4]
	push	0
	push	0
	jne	SHORT $LN33@xmlRelaxNG

; 6400 :                     xmlRngPErr(ctxt, cur->node, XML_RNGP_ANYNAME_ATTR_ANCESTOR,

	push	OFFSET ??_C@_0DE@BFPCKEFO@Found?5anyName?5attribute?5without@
	push	1000					; 000003e8H

; 6401 :                                "Found anyName attribute without oneOrMore ancestor\n",
; 6402 :                                NULL, NULL);
; 6403 :                 } else {

	jmp	SHORT $LN206@xmlRelaxNG
$LN33@xmlRelaxNG:

; 6404 :                     xmlRngPErr(ctxt, cur->node, XML_RNGP_NSNAME_ATTR_ANCESTOR,

	push	OFFSET ??_C@_0DD@LLONPEJF@Found?5nsName?5attribute?5without?5@
	push	1056					; 00000420H
$LN206@xmlRelaxNG:

; 6405 :                                "Found nsName attribute without oneOrMore ancestor\n",
; 6406 :                                NULL, NULL);
; 6407 :                 }
; 6408 :             }
; 6409 :             nflags = flags | XML_RELAXNG_IN_ATTRIBUTE;
; 6410 :             xmlRelaxNGCheckRules(ctxt, cur->content, nflags, cur->type);

	push	eax
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN34@xmlRelaxNG:
	push	DWORD PTR [edi]
	mov	eax, ebx
	or	eax, 1
	push	eax
	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGCheckRules
	add	esp, 16					; 00000010H

; 6411 :             ret = XML_RELAXNG_CONTENT_EMPTY;

	xor	ebx, ebx
	jmp	$LN14@xmlRelaxNG
$LN24@xmlRelaxNG:

; 6412 :         } else if ((cur->type == XML_RELAXNG_ONEORMORE) ||

	cmp	eax, 16					; 00000010H
	je	$LN37@xmlRelaxNG
	cmp	eax, 15					; 0000000fH
	je	$LN37@xmlRelaxNG

; 6426 :                 xmlRelaxNGCheckRules(ctxt, cur->content, nflags,
; 6427 :                                      cur->type);
; 6428 :             ret = xmlRelaxNGGroupContentType(ret, ret);
; 6429 :         } else if (cur->type == XML_RELAXNG_LIST) {

	cmp	eax, 8
	jne	SHORT $LN40@xmlRelaxNG

; 6430 :             if (flags & XML_RELAXNG_IN_LIST) {

	test	bl, 4
	je	SHORT $LN42@xmlRelaxNG

; 6431 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_LIST_LIST,

	push	0
	push	0
	push	OFFSET ??_C@_0CE@NEHBNEAE@Found?5forbidden?5pattern?5list?1?1l@
	push	1081					; 00000439H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN42@xmlRelaxNG:

; 6432 :                            "Found forbidden pattern list//list\n", NULL,
; 6433 :                            NULL);
; 6434 :             }
; 6435 :             if (flags & XML_RELAXNG_IN_DATAEXCEPT) {

	test	bl, 8
	je	SHORT $LN43@xmlRelaxNG

; 6436 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_LIST,

	push	0
	push	0
	push	OFFSET ??_C@_0CL@OKJMMKMF@Found?5forbidden?5pattern?5data?1ex@
	push	1074					; 00000432H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN43@xmlRelaxNG:

; 6437 :                            "Found forbidden pattern data/except//list\n",
; 6438 :                            NULL, NULL);
; 6439 :             }
; 6440 :             if (flags & XML_RELAXNG_IN_START) {

	test	bl, 16					; 00000010H
	je	SHORT $LN44@xmlRelaxNG

; 6441 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_START_LIST,

	push	0
	push	0
	push	OFFSET ??_C@_0CF@DLNDBMML@Found?5forbidden?5pattern?5start?1?1@
	push	1093					; 00000445H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN44@xmlRelaxNG:

; 6442 :                            "Found forbidden pattern start//list\n", NULL,
; 6443 :                            NULL);
; 6444 :             }
; 6445 :             nflags = flags | XML_RELAXNG_IN_LIST;
; 6446 :             ret =

	push	DWORD PTR [edi]
	mov	eax, ebx
	or	eax, 4
	push	eax
	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGCheckRules
	add	esp, 16					; 00000010H
	mov	ebx, eax
	jmp	$LN14@xmlRelaxNG
$LN40@xmlRelaxNG:

; 6447 :                 xmlRelaxNGCheckRules(ctxt, cur->content, nflags,
; 6448 :                                      cur->type);
; 6449 :         } else if (cur->type == XML_RELAXNG_GROUP) {

	cmp	eax, 18					; 00000012H
	jne	SHORT $LN45@xmlRelaxNG

; 6450 :             if (flags & XML_RELAXNG_IN_DATAEXCEPT) {

	test	bl, 8
	je	SHORT $LN47@xmlRelaxNG

; 6451 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_GROUP,

	push	0
	push	0
	push	OFFSET ??_C@_0CM@DONHBELN@Found?5forbidden?5pattern?5data?1ex@
	push	1072					; 00000430H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN47@xmlRelaxNG:

; 6452 :                            "Found forbidden pattern data/except//group\n",
; 6453 :                            NULL, NULL);
; 6454 :             }
; 6455 :             if (flags & XML_RELAXNG_IN_START) {

	test	bl, 16					; 00000010H
	je	SHORT $LN48@xmlRelaxNG

; 6456 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_START_GROUP,

	push	0
	push	0
	push	OFFSET ??_C@_0CG@NJLOHGGM@Found?5forbidden?5pattern?5start?1?1@
	push	1091					; 00000443H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN48@xmlRelaxNG:

; 6457 :                            "Found forbidden pattern start//group\n", NULL,
; 6458 :                            NULL);
; 6459 :             }
; 6460 :             if (flags & XML_RELAXNG_IN_ONEORMORE)
; 6461 :                 nflags = flags | XML_RELAXNG_IN_OOMGROUP;
; 6462 :             else
; 6463 :                 nflags = flags;
; 6464 :             ret =

	push	DWORD PTR [edi]
	mov	eax, ebx
	mov	ecx, ebx
	or	ecx, 32					; 00000020H
	and	al, 2
	cmove	ecx, ebx
	push	ecx
	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGCheckRules

; 6465 :                 xmlRelaxNGCheckRules(ctxt, cur->content, nflags,
; 6466 :                                      cur->type);
; 6467 :             /*
; 6468 :              * The 7.3 Attribute derivation rule for groups is plugged there
; 6469 :              */
; 6470 :             xmlRelaxNGCheckGroupAttrs(ctxt, cur);

	push	edi
	push	esi
	mov	ebx, eax
	call	_xmlRelaxNGCheckGroupAttrs
	add	esp, 24					; 00000018H
	jmp	$LN14@xmlRelaxNG
$LN45@xmlRelaxNG:

; 6471 :         } else if (cur->type == XML_RELAXNG_INTERLEAVE) {

	cmp	eax, 19					; 00000013H
	jne	SHORT $LN51@xmlRelaxNG

; 6472 :             if (flags & XML_RELAXNG_IN_LIST) {

	test	bl, 4
	je	SHORT $LN53@xmlRelaxNG

; 6473 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_LIST_INTERLEAVE,

	push	0
	push	0
	push	OFFSET ??_C@_0CK@GDHHJMOD@Found?5forbidden?5pattern?5list?1?1i@
	push	1080					; 00000438H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN53@xmlRelaxNG:

; 6474 :                            "Found forbidden pattern list//interleave\n",
; 6475 :                            NULL, NULL);
; 6476 :             }
; 6477 :             if (flags & XML_RELAXNG_IN_DATAEXCEPT) {

	test	bl, 8
	je	SHORT $LN54@xmlRelaxNG

; 6478 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE,

	push	0
	push	0
	push	OFFSET ??_C@_0DB@GMPDCJGO@Found?5forbidden?5pattern?5data?1ex@
	push	1073					; 00000431H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN54@xmlRelaxNG:

; 6479 :                            "Found forbidden pattern data/except//interleave\n",
; 6480 :                            NULL, NULL);
; 6481 :             }
; 6482 :             if (flags & XML_RELAXNG_IN_START) {

	test	bl, 16					; 00000010H
	je	SHORT $LN55@xmlRelaxNG

; 6483 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE,

	push	0
	push	0
	push	OFFSET ??_C@_0CL@BPHANFIL@Found?5forbidden?5pattern?5start?1?1@
	push	1073					; 00000431H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN55@xmlRelaxNG:

; 6484 :                            "Found forbidden pattern start//interleave\n",
; 6485 :                            NULL, NULL);
; 6486 :             }
; 6487 :             if (flags & XML_RELAXNG_IN_ONEORMORE)
; 6488 :                 nflags = flags | XML_RELAXNG_IN_OOMINTERLEAVE;
; 6489 :             else
; 6490 :                 nflags = flags;
; 6491 :             ret =

	push	DWORD PTR [edi]
	mov	eax, ebx
	mov	ecx, ebx
	or	ecx, 64					; 00000040H
	and	al, 2
	cmove	ecx, ebx
	push	ecx
	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGCheckRules
	add	esp, 16					; 00000010H
	mov	ebx, eax
	jmp	$LN14@xmlRelaxNG
$LN51@xmlRelaxNG:

; 6492 :                 xmlRelaxNGCheckRules(ctxt, cur->content, nflags,
; 6493 :                                      cur->type);
; 6494 :         } else if (cur->type == XML_RELAXNG_EXCEPT) {

	cmp	eax, 2
	jne	SHORT $LN58@xmlRelaxNG

; 6495 :             if ((cur->parent != NULL) &&

	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	je	SHORT $LN60@xmlRelaxNG
	cmp	DWORD PTR [eax], 5
	jne	SHORT $LN60@xmlRelaxNG

; 6496 :                 (cur->parent->type == XML_RELAXNG_DATATYPE))
; 6497 :                 nflags = flags | XML_RELAXNG_IN_DATAEXCEPT;

	or	ebx, 8
$LN60@xmlRelaxNG:

; 6498 :             else
; 6499 :                 nflags = flags;
; 6500 :             ret =

	push	2
	push	ebx
	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGCheckRules
	add	esp, 16					; 00000010H
	mov	ebx, eax
	jmp	$LN14@xmlRelaxNG
$LN58@xmlRelaxNG:

; 6501 :                 xmlRelaxNGCheckRules(ctxt, cur->content, nflags,
; 6502 :                                      cur->type);
; 6503 :         } else if (cur->type == XML_RELAXNG_DATATYPE) {

	cmp	eax, 5
	jne	SHORT $LN62@xmlRelaxNG

; 6504 :             if (flags & XML_RELAXNG_IN_START) {

	test	bl, 16					; 00000010H
	je	SHORT $LN64@xmlRelaxNG

; 6505 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_START_DATA,

	push	0
	push	0
	push	OFFSET ??_C@_0CF@GAMKIMEF@Found?5forbidden?5pattern?5start?1?1@
	push	1089					; 00000441H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	mov	eax, DWORD PTR [edi]
	add	esp, 24					; 00000018H
$LN64@xmlRelaxNG:

; 6506 :                            "Found forbidden pattern start//data\n", NULL,
; 6507 :                            NULL);
; 6508 :             }
; 6509 :             xmlRelaxNGCheckRules(ctxt, cur->content, flags, cur->type);

	push	eax
	push	ebx
	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGCheckRules
	add	esp, 16					; 00000010H

; 6510 :             ret = XML_RELAXNG_CONTENT_SIMPLE;

	mov	ebx, 1
	jmp	$LN14@xmlRelaxNG
$LN62@xmlRelaxNG:

; 6511 :         } else if (cur->type == XML_RELAXNG_VALUE) {

	cmp	eax, 7
	jne	SHORT $LN65@xmlRelaxNG

; 6512 :             if (flags & XML_RELAXNG_IN_START) {

	test	bl, 16					; 00000010H
	je	SHORT $LN67@xmlRelaxNG

; 6513 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_START_VALUE,

	push	0
	push	0
	push	OFFSET ??_C@_0CG@MABIIKGI@Found?5forbidden?5pattern?5start?1?1@
	push	1096					; 00000448H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	mov	eax, DWORD PTR [edi]
	add	esp, 24					; 00000018H
$LN67@xmlRelaxNG:

; 6514 :                            "Found forbidden pattern start//value\n", NULL,
; 6515 :                            NULL);
; 6516 :             }
; 6517 :             xmlRelaxNGCheckRules(ctxt, cur->content, flags, cur->type);

	push	eax
	push	ebx
	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGCheckRules
	add	esp, 16					; 00000010H

; 6518 :             ret = XML_RELAXNG_CONTENT_SIMPLE;

	mov	ebx, 1
	jmp	$LN14@xmlRelaxNG
$LN65@xmlRelaxNG:

; 6519 :         } else if (cur->type == XML_RELAXNG_TEXT) {

	cmp	eax, 3
	jne	SHORT $LN68@xmlRelaxNG

; 6520 :             if (flags & XML_RELAXNG_IN_LIST) {

	test	bl, 4
	je	SHORT $LN70@xmlRelaxNG

; 6521 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_LIST_TEXT,

	push	0
	push	0
	push	OFFSET ??_C@_0CE@CJAFDOPC@Found?5forbidden?5pattern?5list?1?1t@
	push	1083					; 0000043bH
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN70@xmlRelaxNG:

; 6522 :                            "Found forbidden pattern list//text\n", NULL,
; 6523 :                            NULL);
; 6524 :             }
; 6525 :             if (flags & XML_RELAXNG_IN_DATAEXCEPT) {

	test	bl, 8
	je	SHORT $LN71@xmlRelaxNG

; 6526 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_TEXT,

	push	0
	push	0
	push	OFFSET ??_C@_0CL@BHOICADD@Found?5forbidden?5pattern?5data?1ex@
	push	1077					; 00000435H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN71@xmlRelaxNG:

; 6527 :                            "Found forbidden pattern data/except//text\n",
; 6528 :                            NULL, NULL);
; 6529 :             }
; 6530 :             if (flags & XML_RELAXNG_IN_START) {

	test	bl, 16					; 00000010H
	je	SHORT $LN72@xmlRelaxNG

; 6531 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_START_TEXT,

	push	0
	push	0
	push	OFFSET ??_C@_0CF@MGKHPGDN@Found?5forbidden?5pattern?5start?1?1@
	push	1095					; 00000447H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN72@xmlRelaxNG:

; 6532 :                            "Found forbidden pattern start//text\n", NULL,
; 6533 :                            NULL);
; 6534 :             }
; 6535 :             ret = XML_RELAXNG_CONTENT_COMPLEX;

	mov	ebx, 2
	jmp	$LN14@xmlRelaxNG
$LN68@xmlRelaxNG:

; 6536 :         } else if (cur->type == XML_RELAXNG_EMPTY) {

	test	eax, eax
	jne	SHORT $LN73@xmlRelaxNG

; 6537 :             if (flags & XML_RELAXNG_IN_DATAEXCEPT) {

	test	bl, 8
	je	SHORT $LN75@xmlRelaxNG

; 6538 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_EMPTY,

	push	eax
	push	eax
	push	OFFSET ??_C@_0CM@OBFOJGD@Found?5forbidden?5pattern?5data?1ex@
	push	1071					; 0000042fH
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN75@xmlRelaxNG:

; 6539 :                            "Found forbidden pattern data/except//empty\n",
; 6540 :                            NULL, NULL);
; 6541 :             }
; 6542 :             if (flags & XML_RELAXNG_IN_START) {

	test	bl, 16					; 00000010H
	je	SHORT $LN76@xmlRelaxNG

; 6543 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_START_EMPTY,

	push	0
	push	0
	push	OFFSET ??_C@_0CG@OJHMILLC@Found?5forbidden?5pattern?5start?1?1@
	push	1090					; 00000442H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN76@xmlRelaxNG:

; 6544 :                            "Found forbidden pattern start//empty\n", NULL,
; 6545 :                            NULL);
; 6546 :             }
; 6547 :             ret = XML_RELAXNG_CONTENT_EMPTY;

	xor	ebx, ebx
	jmp	$LN14@xmlRelaxNG
$LN73@xmlRelaxNG:

; 6548 :         } else if (cur->type == XML_RELAXNG_CHOICE) {

	cmp	eax, 17					; 00000011H
	jne	SHORT $LN77@xmlRelaxNG

; 6549 :             xmlRelaxNGCheckChoiceDeterminism(ctxt, cur);

	push	edi
	push	esi
	call	_xmlRelaxNGCheckChoiceDeterminism

; 6550 :             ret =

	push	DWORD PTR [edi]
	push	ebx
	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGCheckRules
	add	esp, 24					; 00000018H
	mov	ebx, eax

; 6551 :                 xmlRelaxNGCheckRules(ctxt, cur->content, flags, cur->type);
; 6552 :         } else {

	jmp	$LN14@xmlRelaxNG
$LN77@xmlRelaxNG:

; 6553 :             ret =

	push	eax
	push	ebx
	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGCheckRules
	add	esp, 16					; 00000010H
	mov	ebx, eax
	jmp	$LN14@xmlRelaxNG
$LN37@xmlRelaxNG:

; 6413 :                    (cur->type == XML_RELAXNG_ZEROORMORE)) {
; 6414 :             if (flags & XML_RELAXNG_IN_DATAEXCEPT) {

	test	bl, 8
	je	SHORT $LN38@xmlRelaxNG

; 6415 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_ONEMORE,

	push	0
	push	0
	push	OFFSET ??_C@_0DA@BGDINEKH@Found?5forbidden?5pattern?5data?1ex@
	push	1075					; 00000433H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN38@xmlRelaxNG:

; 6416 :                            "Found forbidden pattern data/except//oneOrMore\n",
; 6417 :                            NULL, NULL);
; 6418 :             }
; 6419 :             if (flags & XML_RELAXNG_IN_START) {

	test	bl, 16					; 00000010H
	je	SHORT $LN39@xmlRelaxNG

; 6420 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_START_ONEMORE,

	push	0
	push	0
	push	OFFSET ??_C@_0CK@EJNCLCCA@Found?5forbidden?5pattern?5start?1?1@
	push	1094					; 00000446H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN39@xmlRelaxNG:

; 6421 :                            "Found forbidden pattern start//oneOrMore\n",
; 6422 :                            NULL, NULL);
; 6423 :             }
; 6424 :             nflags = flags | XML_RELAXNG_IN_ONEORMORE;
; 6425 :             ret =

	push	DWORD PTR [edi]
	mov	eax, ebx
	or	eax, 2
	push	eax
	push	DWORD PTR [edi+24]
	push	esi
	call	_xmlRelaxNGCheckRules
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 6221 :     if ((ct1 == XML_RELAXNG_CONTENT_ERROR) ||

	cmp	ebx, -1
	je	SHORT $LN142@xmlRelaxNG

; 6224 :     if (ct1 == XML_RELAXNG_CONTENT_EMPTY)

	test	ebx, ebx
	je	$LN14@xmlRelaxNG

; 6225 :         return (ct2);
; 6226 :     if (ct2 == XML_RELAXNG_CONTENT_EMPTY)
; 6227 :         return (ct1);
; 6228 :     if ((ct1 == XML_RELAXNG_CONTENT_COMPLEX) &&

	or	eax, -1
	mov	ecx, 2
	cmp	ebx, 2
	cmove	eax, ecx
	mov	ebx, eax

; 6229 :         (ct2 == XML_RELAXNG_CONTENT_COMPLEX))
; 6230 :         return (XML_RELAXNG_CONTENT_COMPLEX);
; 6231 :     return (XML_RELAXNG_CONTENT_ERROR);

	jmp	$LN14@xmlRelaxNG
$LN142@xmlRelaxNG:

; 6222 :         (ct2 == XML_RELAXNG_CONTENT_ERROR))
; 6223 :         return (XML_RELAXNG_CONTENT_ERROR);

	or	ebx, -1

; 6232 : }

	jmp	$LN14@xmlRelaxNG
$LN6@xmlRelaxNG:

; 6281 :             (cur->type == XML_RELAXNG_PARENTREF)) {
; 6282 :            /*
; 6283 :             * This should actually be caught by list//element(ref) at the
; 6284 :             * element boundaries, c.f. Bug #159968 local refs are dropped
; 6285 :             * in step 4.19.
; 6286 :             */
; 6287 : #if 0
; 6288 :             if (flags & XML_RELAXNG_IN_LIST) {
; 6289 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_LIST_REF,
; 6290 :                            "Found forbidden pattern list//ref\n", NULL,
; 6291 :                            NULL);
; 6292 :             }
; 6293 : #endif
; 6294 :             if (flags & XML_RELAXNG_IN_DATAEXCEPT) {

	test	bl, 8
	je	SHORT $LN95@xmlRelaxNG

; 6295 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_REF,

	mov	eax, DWORD PTR [edi+4]

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	edx, edx

; 6295 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_REF,

	mov	DWORD PTR _node$1$[ebp], eax

; 517  :     void *data = NULL;

	xor	ecx, ecx
	xor	eax, eax

; 518  : 
; 519  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN202@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN203@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [esi+4]
$LN203@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	ecx, DWORD PTR [esi]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [esi+36]
$LN202@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	0
	push	OFFSET ??_C@_0CK@JHAPLGCC@Found?5forbidden?5pattern?5data?1ex@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1076					; 00000434H
	push	18					; 00000012H
	push	DWORD PTR _node$1$[ebp]
	push	0
	push	ecx
	push	edx
	push	eax
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN95@xmlRelaxNG:

; 6296 :                            "Found forbidden pattern data/except//ref\n",
; 6297 :                            NULL, NULL);
; 6298 :             }
; 6299 :             if (cur->content == NULL) {

	cmp	DWORD PTR [edi+24], 0
	jne	$LN105@xmlRelaxNG

; 6300 :                 if (cur->type == XML_RELAXNG_PARENTREF)

	cmp	DWORD PTR [edi], 13			; 0000000dH
	jne	SHORT $LN9@xmlRelaxNG

; 6301 :                     xmlRngPErr(ctxt, cur->node, XML_RNGP_REF_NO_DEF,

	mov	eax, DWORD PTR [edi+4]

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	edx, edx

; 6301 :                     xmlRngPErr(ctxt, cur->node, XML_RNGP_REF_NO_DEF,

	mov	DWORD PTR _node$1$[ebp], eax

; 517  :     void *data = NULL;

	xor	ecx, ecx
	xor	eax, eax

; 518  : 
; 519  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN101@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN103@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [esi+4]
$LN103@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	ecx, DWORD PTR [esi]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [esi+36]
$LN101@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	0
	push	OFFSET ??_C@_0CK@BAJLBNJH@Internal?5found?5no?5define?5for?5pa@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1101					; 0000044dH
	push	18					; 00000012H
	push	DWORD PTR _node$1$[ebp]
	push	0
	push	ecx
	push	edx

; 6301 :                     xmlRngPErr(ctxt, cur->node, XML_RNGP_REF_NO_DEF,

	jmp	SHORT $LN207@xmlRelaxNG
$LN9@xmlRelaxNG:

; 6302 :                                "Internal found no define for parent refs\n",
; 6303 :                                NULL, NULL);
; 6304 :                 else
; 6305 :                     xmlRngPErr(ctxt, cur->node, XML_RNGP_REF_NO_DEF,

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, OFFSET ??_C@_04MLLLIHIP@null@
	test	eax, eax
	cmovne	ecx, eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _node$1$[ebp], eax

; 517  :     void *data = NULL;

	xor	edx, edx
	xor	eax, eax
	mov	DWORD PTR _channel$1$[ebp], eax

; 518  : 
; 519  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN106@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN108@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR _channel$1$[ebp], edx
$LN108@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	edx, DWORD PTR [esi]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [esi+36]
$LN106@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	ecx
	push	OFFSET ??_C@_0CF@GFDJFDLL@Internal?5found?5no?5define?5for?5re@
	push	0
	push	0
	push	0
	push	0
	push	ecx
	push	0
	push	0
	push	2
	push	1101					; 0000044dH
	push	18					; 00000012H
	push	DWORD PTR _node$1$[ebp]
	push	0
	push	edx
	push	DWORD PTR _channel$1$[ebp]
$LN207@xmlRelaxNG:

; 6306 :                                "Internal found no define for ref %s\n",
; 6307 :                                (cur->name ? cur->name: BAD_CAST "null"), NULL);
; 6308 :             }
; 6309 :             if (cur->depth > -4) {

	push	eax
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN105@xmlRelaxNG:
	movzx	eax, WORD PTR [edi+48]
	cmp	ax, -4					; fffffffcH
	jle	SHORT $LN11@xmlRelaxNG

; 6310 :                 cur->depth = -4;
; 6311 :                 ret = xmlRelaxNGCheckRules(ctxt, cur->content,

	push	DWORD PTR [edi]
	mov	eax, -4					; fffffffcH
	push	ebx
	push	DWORD PTR [edi+24]
	mov	WORD PTR [edi+48], ax
	push	esi
	call	_xmlRelaxNGCheckRules
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 6312 :                                            flags, cur->type);
; 6313 :                 cur->depth = ret - 15;

	lea	eax, DWORD PTR [ebx-15]
	mov	WORD PTR [edi+48], ax
	jmp	SHORT $LN14@xmlRelaxNG
$LN11@xmlRelaxNG:

; 6314 :             } else if (cur->depth == -4) {

	jne	SHORT $LN13@xmlRelaxNG
$LN22@xmlRelaxNG:

; 6554 :                 xmlRelaxNGCheckRules(ctxt, cur->content, flags, cur->type);
; 6555 :         }
; 6556 :         cur = cur->next;

	mov	ebx, 2
	jmp	SHORT $LN14@xmlRelaxNG
$LN13@xmlRelaxNG:

; 6315 :                 ret = XML_RELAXNG_CONTENT_COMPLEX;
; 6316 :             } else {
; 6317 :                 ret = (xmlRelaxNGContentType) (cur->depth + 15);

	movsx	ebx, ax
	add	ebx, 15					; 0000000fH
$LN14@xmlRelaxNG:

; 6557 :         if (ptype == XML_RELAXNG_GROUP) {

	mov	edx, DWORD PTR _ptype$[ebp]
	mov	edi, DWORD PTR [edi+32]
	cmp	edx, 18					; 00000012H
	jne	SHORT $LN79@xmlRelaxNG
$LN88@xmlRelaxNG:

; 6275 :     int nflags;
; 6276 :     xmlRelaxNGContentType ret, tmp, val = XML_RELAXNG_CONTENT_EMPTY;
; 6277 : 
; 6278 :     while (cur != NULL) {

	mov	ecx, DWORD PTR _val$1$[ebp]
	cmp	ecx, -1
	je	SHORT $LN171@xmlRelaxNG
	cmp	ebx, -1
	je	SHORT $LN171@xmlRelaxNG
	test	ecx, ecx
	jne	SHORT $LN180@xmlRelaxNG
	mov	ecx, ebx
	mov	DWORD PTR _val$1$[ebp], ecx
	jmp	SHORT $LN177@xmlRelaxNG
$LN79@xmlRelaxNG:

; 6558 :             val = xmlRelaxNGGroupContentType(val, ret);
; 6559 :         } else if (ptype == XML_RELAXNG_INTERLEAVE) {

	cmp	edx, 19					; 00000013H
	je	SHORT $LN205@xmlRelaxNG

; 6560 :             /*
; 6561 :              * TODO: scan complain that tmp is never used, seems on purpose
; 6562 :              *       need double-checking
; 6563 :              */
; 6564 :             tmp = xmlRelaxNGGroupContentType(val, ret);
; 6565 :             if (tmp != XML_RELAXNG_CONTENT_ERROR)
; 6566 :                 tmp = xmlRelaxNGMaxContentType(val, ret);
; 6567 :         } else if (ptype == XML_RELAXNG_CHOICE) {

	cmp	edx, 17					; 00000011H
	jne	SHORT $LN84@xmlRelaxNG

; 6247 :     if ((ct1 == XML_RELAXNG_CONTENT_ERROR) ||

	mov	eax, DWORD PTR _val$1$[ebp]
	cmp	eax, -1
	je	SHORT $LN171@xmlRelaxNG
	cmp	ebx, -1
	je	SHORT $LN171@xmlRelaxNG

; 6248 :         (ct2 == XML_RELAXNG_CONTENT_ERROR))
; 6249 :         return (XML_RELAXNG_CONTENT_ERROR);
; 6250 :     if ((ct1 == XML_RELAXNG_CONTENT_SIMPLE) ||

	cmp	eax, 1
	je	SHORT $LN173@xmlRelaxNG
	cmp	ebx, 1
	je	SHORT $LN173@xmlRelaxNG

; 6251 :         (ct2 == XML_RELAXNG_CONTENT_SIMPLE))
; 6252 :         return (XML_RELAXNG_CONTENT_SIMPLE);
; 6253 :     if ((ct1 == XML_RELAXNG_CONTENT_COMPLEX) ||

	cmp	eax, 2
	je	SHORT $LN175@xmlRelaxNG
	cmp	ebx, 2
	je	SHORT $LN175@xmlRelaxNG

; 6254 :         (ct2 == XML_RELAXNG_CONTENT_COMPLEX))
; 6255 :         return (XML_RELAXNG_CONTENT_COMPLEX);
; 6256 :     return (XML_RELAXNG_CONTENT_EMPTY);

	xor	ecx, ecx
	mov	DWORD PTR _val$1$[ebp], ecx
	jmp	SHORT $LN177@xmlRelaxNG
$LN171@xmlRelaxNG:

; 6275 :     int nflags;
; 6276 :     xmlRelaxNGContentType ret, tmp, val = XML_RELAXNG_CONTENT_EMPTY;
; 6277 : 
; 6278 :     while (cur != NULL) {

	or	ecx, -1
	mov	DWORD PTR _val$1$[ebp], ecx
	jmp	SHORT $LN177@xmlRelaxNG
$LN84@xmlRelaxNG:

; 6568 :             val = xmlRelaxNGMaxContentType(val, ret);
; 6569 :         } else if (ptype == XML_RELAXNG_LIST) {

	cmp	edx, 8
	jne	SHORT $LN86@xmlRelaxNG
$LN173@xmlRelaxNG:

; 6275 :     int nflags;
; 6276 :     xmlRelaxNGContentType ret, tmp, val = XML_RELAXNG_CONTENT_EMPTY;
; 6277 : 
; 6278 :     while (cur != NULL) {

	mov	ecx, 1
	mov	DWORD PTR _val$1$[ebp], ecx
	jmp	SHORT $LN177@xmlRelaxNG
$LN86@xmlRelaxNG:

; 6570 :             val = XML_RELAXNG_CONTENT_SIMPLE;
; 6571 :         } else if (ptype == XML_RELAXNG_EXCEPT) {

	cmp	edx, 2
	jne	SHORT $LN88@xmlRelaxNG

; 6572 :             if (ret == XML_RELAXNG_CONTENT_ERROR)
; 6573 :                 val = XML_RELAXNG_CONTENT_ERROR;
; 6574 :             else
; 6575 :                 val = XML_RELAXNG_CONTENT_SIMPLE;
; 6576 :         } else {

	xor	ecx, ecx
	cmp	ebx, -1
	setne	cl
	lea	ecx, DWORD PTR [ecx*2-1]
	mov	DWORD PTR _val$1$[ebp], ecx
	jmp	SHORT $LN177@xmlRelaxNG
$LN180@xmlRelaxNG:

; 6275 :     int nflags;
; 6276 :     xmlRelaxNGContentType ret, tmp, val = XML_RELAXNG_CONTENT_EMPTY;
; 6277 : 
; 6278 :     while (cur != NULL) {

	test	ebx, ebx
	je	SHORT $LN177@xmlRelaxNG
	cmp	ecx, 2
	jne	SHORT $LN171@xmlRelaxNG
	cmp	ebx, ecx
	jne	SHORT $LN171@xmlRelaxNG
$LN175@xmlRelaxNG:
	mov	ecx, 2
	mov	DWORD PTR _val$1$[ebp], ecx
	jmp	SHORT $LN177@xmlRelaxNG
$LN205@xmlRelaxNG:

; 6558 :             val = xmlRelaxNGGroupContentType(val, ret);
; 6559 :         } else if (ptype == XML_RELAXNG_INTERLEAVE) {

	mov	ecx, DWORD PTR _val$1$[ebp]
$LN177@xmlRelaxNG:

; 6275 :     int nflags;
; 6276 :     xmlRelaxNGContentType ret, tmp, val = XML_RELAXNG_CONTENT_EMPTY;
; 6277 : 
; 6278 :     while (cur != NULL) {

	mov	ebx, DWORD PTR _flags$[ebp]
	test	edi, edi
	jne	$LL2@xmlRelaxNG

; 6577 :             val = xmlRelaxNGGroupContentType(val, ret);
; 6578 :         }
; 6579 : 
; 6580 :     }
; 6581 :     return (val);

	pop	esi
	pop	ebx
$LN204@xmlRelaxNG:

; 6582 : }

	mov	eax, ecx
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGCheckRules ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGMaxContentType
_TEXT	SEGMENT
_ct1$ = 8						; size = 4
_ct2$ = 12						; size = 4
_xmlRelaxNGMaxContentType PROC				; COMDAT

; 6246 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ct1$[ebp]
	cmp	ecx, -1
	je	SHORT $LN3@xmlRelaxNG

; 6247 :     if ((ct1 == XML_RELAXNG_CONTENT_ERROR) ||

	mov	eax, DWORD PTR _ct2$[ebp]
	cmp	eax, -1
	je	SHORT $LN3@xmlRelaxNG

; 6250 :     if ((ct1 == XML_RELAXNG_CONTENT_SIMPLE) ||

	cmp	ecx, 1
	je	SHORT $LN5@xmlRelaxNG
	cmp	eax, 1
	je	SHORT $LN5@xmlRelaxNG

; 6253 :     if ((ct1 == XML_RELAXNG_CONTENT_COMPLEX) ||

	cmp	ecx, 2
	je	SHORT $LN7@xmlRelaxNG
	cmp	eax, 2
	je	SHORT $LN7@xmlRelaxNG

; 6256 :     return (XML_RELAXNG_CONTENT_EMPTY);

	xor	eax, eax

; 6257 : }

	pop	ebp
	ret	0
$LN7@xmlRelaxNG:

; 6254 :         (ct2 == XML_RELAXNG_CONTENT_COMPLEX))
; 6255 :         return (XML_RELAXNG_CONTENT_COMPLEX);

	mov	eax, 2

; 6257 : }

	pop	ebp
	ret	0
$LN5@xmlRelaxNG:

; 6251 :         (ct2 == XML_RELAXNG_CONTENT_SIMPLE))
; 6252 :         return (XML_RELAXNG_CONTENT_SIMPLE);

	mov	eax, 1

; 6257 : }

	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 6248 :         (ct2 == XML_RELAXNG_CONTENT_ERROR))
; 6249 :         return (XML_RELAXNG_CONTENT_ERROR);

	or	eax, -1

; 6257 : }

	pop	ebp
	ret	0
_xmlRelaxNGMaxContentType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGGroupContentType
_TEXT	SEGMENT
_ct1$ = 8						; size = 4
_ct2$ = 12						; size = 4
_xmlRelaxNGGroupContentType PROC			; COMDAT

; 6220 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ct1$[ebp]
	cmp	ecx, -1
	je	SHORT $LN3@xmlRelaxNG

; 6221 :     if ((ct1 == XML_RELAXNG_CONTENT_ERROR) ||

	mov	eax, DWORD PTR _ct2$[ebp]
	cmp	eax, -1
	je	SHORT $LN3@xmlRelaxNG

; 6224 :     if (ct1 == XML_RELAXNG_CONTENT_EMPTY)

	test	ecx, ecx
	je	SHORT $LN1@xmlRelaxNG

; 6225 :         return (ct2);
; 6226 :     if (ct2 == XML_RELAXNG_CONTENT_EMPTY)

	test	eax, eax
	jne	SHORT $LN5@xmlRelaxNG

; 6227 :         return (ct1);

	mov	eax, ecx

; 6231 :     return (XML_RELAXNG_CONTENT_ERROR);
; 6232 : }

	pop	ebp
	ret	0
$LN5@xmlRelaxNG:

; 6228 :     if ((ct1 == XML_RELAXNG_CONTENT_COMPLEX) &&

	cmp	ecx, 2
	jne	SHORT $LN3@xmlRelaxNG
	cmp	eax, ecx
	jne	SHORT $LN3@xmlRelaxNG

; 6229 :         (ct2 == XML_RELAXNG_CONTENT_COMPLEX))
; 6230 :         return (XML_RELAXNG_CONTENT_COMPLEX);

	mov	eax, ecx

; 6231 :     return (XML_RELAXNG_CONTENT_ERROR);
; 6232 : }

	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 6222 :         (ct2 == XML_RELAXNG_CONTENT_ERROR))
; 6223 :         return (XML_RELAXNG_CONTENT_ERROR);

	or	eax, -1
$LN1@xmlRelaxNG:

; 6231 :     return (XML_RELAXNG_CONTENT_ERROR);
; 6232 : }

	pop	ebp
	ret	0
_xmlRelaxNGGroupContentType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGSimplify
_TEXT	SEGMENT
_prev$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
tv873 = 12						; size = 4
_cur$ = 12						; size = 4
_parent$ = 16						; size = 4
_xmlRelaxNGSimplify PROC				; COMDAT

; 6052 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	xor	edi, edi
	mov	DWORD PTR _prev$1$[ebp], edi
	test	esi, esi
	je	$LN73@xmlRelaxNG
	mov	ecx, DWORD PTR _ctxt$[ebp]
	lea	edx, DWORD PTR [edi-3]
	push	ebx
	mov	ebx, DWORD PTR _parent$[ebp]
	npad	6
$LL2@xmlRelaxNG:

; 6053 :     xmlRelaxNGDefinePtr prev = NULL;
; 6054 : 
; 6055 :     while (cur != NULL) {
; 6056 :         if ((cur->type == XML_RELAXNG_REF) ||

	mov	eax, DWORD PTR [esi]
	cmp	eax, 11					; 0000000bH
	je	$LN65@xmlRelaxNG
	cmp	eax, 13					; 0000000dH
	je	$LN65@xmlRelaxNG

; 6061 :             }
; 6062 :         } else if (cur->type == XML_RELAXNG_NOT_ALLOWED) {

	mov	DWORD PTR [esi+28], ebx
	cmp	eax, 1
	jne	SHORT $LN12@xmlRelaxNG

; 6063 :             cur->parent = parent;
; 6064 :             if ((parent != NULL) &&

	test	ebx, ebx
	je	SHORT $LN22@xmlRelaxNG
	mov	eax, DWORD PTR [ebx]
	cmp	eax, 9
	je	$LN47@xmlRelaxNG
	cmp	eax, 8
	je	$LN47@xmlRelaxNG
	cmp	eax, 18					; 00000012H
	je	$LN47@xmlRelaxNG
	cmp	eax, 19					; 00000013H
	je	$LN47@xmlRelaxNG
	cmp	eax, 16					; 00000010H
	je	$LN47@xmlRelaxNG
	cmp	eax, 15					; 0000000fH
	je	$LN47@xmlRelaxNG

; 6065 :                 ((parent->type == XML_RELAXNG_ATTRIBUTE) ||
; 6066 :                  (parent->type == XML_RELAXNG_LIST) ||
; 6067 :                  (parent->type == XML_RELAXNG_GROUP) ||
; 6068 :                  (parent->type == XML_RELAXNG_INTERLEAVE) ||
; 6069 :                  (parent->type == XML_RELAXNG_ONEORMORE) ||
; 6070 :                  (parent->type == XML_RELAXNG_ZEROORMORE))) {
; 6071 :                 parent->type = XML_RELAXNG_NOT_ALLOWED;
; 6072 :                 break;
; 6073 :             }
; 6074 :             if ((parent != NULL) && (parent->type == XML_RELAXNG_CHOICE)) {

	cmp	eax, 17					; 00000011H
	jne	SHORT $LN22@xmlRelaxNG
$LN24@xmlRelaxNG:

; 6198 :                 } else
; 6199 :                     prev = cur;
; 6200 :             } else {
; 6201 :                 prev = cur;
; 6202 :             }
; 6203 :         }
; 6204 :         cur = cur->next;

	push	edi
	push	ebx
	push	esi
	push	ecx
	call	_xmlRelaxNGTryUnlink
	mov	edi, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _prev$1$[ebp], edi
	jmp	$LN78@xmlRelaxNG
$LN12@xmlRelaxNG:

; 6075 :                 prev = xmlRelaxNGTryUnlink(ctxt, cur, parent, prev);
; 6076 :             } else
; 6077 :                 prev = cur;
; 6078 :         } else if (cur->type == XML_RELAXNG_EMPTY) {

	test	eax, eax
	jne	SHORT $LN18@xmlRelaxNG

; 6079 :             cur->parent = parent;
; 6080 :             if ((parent != NULL) &&

	test	ebx, ebx
	je	SHORT $LN22@xmlRelaxNG
	mov	eax, DWORD PTR [ebx]
	cmp	eax, 16					; 00000010H
	je	$LN53@xmlRelaxNG
	cmp	eax, 15					; 0000000fH
	je	$LN53@xmlRelaxNG

; 6081 :                 ((parent->type == XML_RELAXNG_ONEORMORE) ||
; 6082 :                  (parent->type == XML_RELAXNG_ZEROORMORE))) {
; 6083 :                 parent->type = XML_RELAXNG_EMPTY;
; 6084 :                 break;
; 6085 :             }
; 6086 :             if ((parent != NULL) &&

	cmp	eax, 18					; 00000012H
	je	SHORT $LN24@xmlRelaxNG
	cmp	eax, 19					; 00000013H
	je	SHORT $LN24@xmlRelaxNG
$LN22@xmlRelaxNG:

; 6198 :                 } else
; 6199 :                     prev = cur;
; 6200 :             } else {
; 6201 :                 prev = cur;
; 6202 :             }
; 6203 :         }
; 6204 :         cur = cur->next;

	mov	edi, esi
	mov	DWORD PTR _prev$1$[ebp], edi
	jmp	$LN11@xmlRelaxNG
$LN18@xmlRelaxNG:

; 6087 :                 ((parent->type == XML_RELAXNG_GROUP) ||
; 6088 :                  (parent->type == XML_RELAXNG_INTERLEAVE))) {
; 6089 :                 prev = xmlRelaxNGTryUnlink(ctxt, cur, parent, prev);
; 6090 :             } else
; 6091 :                 prev = cur;
; 6092 :         } else {
; 6093 :             cur->parent = parent;
; 6094 :             if (cur->content != NULL)

	lea	eax, DWORD PTR [esi+24]
	mov	DWORD PTR tv873[ebp], eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN25@xmlRelaxNG

; 6095 :                 xmlRelaxNGSimplify(ctxt, cur->content, cur);

	push	esi
	push	eax
	push	ecx
	call	_xmlRelaxNGSimplify
	mov	ecx, DWORD PTR _ctxt$[ebp]
	add	esp, 12					; 0000000cH
$LN25@xmlRelaxNG:

; 6096 :             if ((cur->type != XML_RELAXNG_VALUE) && (cur->attrs != NULL))

	cmp	DWORD PTR [esi], 7
	je	SHORT $LN26@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN26@xmlRelaxNG

; 6097 :                 xmlRelaxNGSimplify(ctxt, cur->attrs, cur);

	push	esi
	push	eax
	push	ecx
	call	_xmlRelaxNGSimplify
	add	esp, 12					; 0000000cH
$LN26@xmlRelaxNG:

; 6098 :             if (cur->nameClass != NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN27@xmlRelaxNG

; 6099 :                 xmlRelaxNGSimplify(ctxt, cur->nameClass, cur);

	push	esi
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGSimplify
	add	esp, 12					; 0000000cH
$LN27@xmlRelaxNG:

; 6100 :             /*
; 6101 :              * On Elements, try to move attribute only generating rules on
; 6102 :              * the attrs rules.
; 6103 :              */
; 6104 :             if (cur->type == XML_RELAXNG_ELEMENT) {

	cmp	DWORD PTR [esi], 4
	jne	SHORT $LN7@xmlRelaxNG

; 6105 :                 int attronly;
; 6106 :                 xmlRelaxNGDefinePtr tmp, pre;
; 6107 : 
; 6108 :                 while (cur->content != NULL) {

	mov	ebx, DWORD PTR tv873[ebp]
	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN29@xmlRelaxNG
	mov	edi, DWORD PTR _ctxt$[ebp]
	npad	7
$LL4@xmlRelaxNG:

; 6109 :                     attronly =

	push	eax
	push	edi
	call	_xmlRelaxNGGenerateAttributes
	add	esp, 8

; 6110 :                         xmlRelaxNGGenerateAttributes(ctxt, cur->content);
; 6111 :                     if (attronly == 1) {

	cmp	eax, 1
	jne	SHORT $LN74@xmlRelaxNG

; 6112 :                         /*
; 6113 :                          * migrate cur->content to attrs
; 6114 :                          */
; 6115 :                         tmp = cur->content;

	mov	ecx, DWORD PTR [ebx]

; 6116 :                         cur->content = tmp->next;

	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [ebx], eax

; 6117 :                         tmp->next = cur->attrs;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [ecx+32], eax

; 6118 :                         cur->attrs = tmp;

	mov	DWORD PTR [esi+36], ecx
	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	jne	SHORT $LL4@xmlRelaxNG
$LN74@xmlRelaxNG:
	mov	edi, DWORD PTR _prev$1$[ebp]
$LN29@xmlRelaxNG:

; 6119 :                     } else {
; 6120 :                         /*
; 6121 :                          * cur->content can generate elements or text
; 6122 :                          */
; 6123 :                         break;
; 6124 :                     }
; 6125 :                 }
; 6126 :                 pre = cur->content;

	mov	ebx, DWORD PTR [ebx]

; 6127 :                 while ((pre != NULL) && (pre->next != NULL)) {

	test	ebx, ebx
	je	SHORT $LN76@xmlRelaxNG
	npad	2
$LL6@xmlRelaxNG:
	mov	edi, DWORD PTR [ebx+32]
	test	edi, edi
	je	SHORT $LN75@xmlRelaxNG

; 6128 :                     tmp = pre->next;
; 6129 :                     attronly = xmlRelaxNGGenerateAttributes(ctxt, tmp);

	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGGenerateAttributes
	add	esp, 8

; 6130 :                     if (attronly == 1) {

	cmp	eax, 1
	jne	SHORT $LN31@xmlRelaxNG

; 6131 :                         /*
; 6132 :                          * migrate tmp to attrs
; 6133 :                          */
; 6134 :                         pre->next = tmp->next;

	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [ebx+32], eax

; 6135 :                         tmp->next = cur->attrs;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [edi+32], eax

; 6136 :                         cur->attrs = tmp;

	mov	DWORD PTR [esi+36], edi

; 6137 :                     } else {

	jmp	SHORT $LN32@xmlRelaxNG
$LN31@xmlRelaxNG:

; 6138 :                         pre = tmp;

	mov	ebx, edi
$LN32@xmlRelaxNG:

; 6127 :                 while ((pre != NULL) && (pre->next != NULL)) {

	test	ebx, ebx
	jne	SHORT $LL6@xmlRelaxNG
$LN75@xmlRelaxNG:
	mov	edi, DWORD PTR _prev$1$[ebp]
$LN76@xmlRelaxNG:

; 6139 :                     }
; 6140 :                 }
; 6141 :             }
; 6142 :             /*
; 6143 :              * This may result in a simplification
; 6144 :              */
; 6145 :             if ((cur->type == XML_RELAXNG_GROUP) ||

	mov	ebx, DWORD PTR _parent$[ebp]
$LN7@xmlRelaxNG:
	mov	eax, DWORD PTR [esi]
	cmp	eax, 18					; 00000012H
	je	SHORT $LN34@xmlRelaxNG
	cmp	eax, 19					; 00000013H
	jne	$LN41@xmlRelaxNG
$LN34@xmlRelaxNG:

; 6146 :                 (cur->type == XML_RELAXNG_INTERLEAVE)) {
; 6147 :                 if (cur->content == NULL)

	mov	edx, DWORD PTR tv873[ebp]
	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	jne	SHORT $LN35@xmlRelaxNG

; 6148 :                     cur->type = XML_RELAXNG_EMPTY;

	mov	DWORD PTR [esi], ecx
	xor	eax, eax
$LN42@xmlRelaxNG:

; 6170 :             } else if (cur->type == XML_RELAXNG_NOT_ALLOWED) {

	cmp	eax, 1
	jne	$LN44@xmlRelaxNG

; 6171 :                 if ((parent != NULL) &&

	test	ebx, ebx
	je	$LN48@xmlRelaxNG
	mov	eax, DWORD PTR [ebx]
	cmp	eax, 9
	je	$LN47@xmlRelaxNG
	cmp	eax, 8
	je	$LN47@xmlRelaxNG
	cmp	eax, 18					; 00000012H
	je	$LN47@xmlRelaxNG
	cmp	eax, 19					; 00000013H
	je	$LN47@xmlRelaxNG
	cmp	eax, 16					; 00000010H
	je	$LN47@xmlRelaxNG
	cmp	eax, 15					; 0000000fH
	je	$LN47@xmlRelaxNG

; 6179 :                     break;
; 6180 :                 }
; 6181 :                 if ((parent != NULL) &&

	cmp	eax, 17					; 00000011H
	jne	SHORT $LN48@xmlRelaxNG

; 6182 :                     (parent->type == XML_RELAXNG_CHOICE)) {
; 6183 :                     prev = xmlRelaxNGTryUnlink(ctxt, cur, parent, prev);

	push	edi
	push	ebx
	push	esi
	push	DWORD PTR _ctxt$[ebp]

; 6198 :                 } else
; 6199 :                     prev = cur;
; 6200 :             } else {
; 6201 :                 prev = cur;
; 6202 :             }
; 6203 :         }
; 6204 :         cur = cur->next;

	call	_xmlRelaxNGTryUnlink
	mov	edi, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _prev$1$[ebp], edi
	jmp	$LN78@xmlRelaxNG
$LN35@xmlRelaxNG:

; 6149 :                 else if (cur->content->next == NULL) {

	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN41@xmlRelaxNG

; 6150 :                     if ((parent == NULL) && (prev == NULL)) {

	test	ebx, ebx
	jne	SHORT $LN38@xmlRelaxNG
	test	edi, edi
	jne	SHORT $LN40@xmlRelaxNG

; 6151 :                         cur->type = XML_RELAXNG_NOOP;

	mov	DWORD PTR [esi], -1
	or	eax, -1
	jmp	SHORT $LN42@xmlRelaxNG
$LN38@xmlRelaxNG:

; 6152 :                     } else if (prev == NULL) {

	test	edi, edi
	jne	SHORT $LN40@xmlRelaxNG

; 6153 :                         parent->content = cur->content;

	mov	DWORD PTR [ebx+24], ecx

; 6154 :                         cur->content->next = cur->next;

	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [ecx+32], eax

; 6155 :                         cur = cur->content;
; 6156 :                     } else {

	jmp	SHORT $LN80@xmlRelaxNG
$LN40@xmlRelaxNG:

; 6157 :                         cur->content->next = cur->next;

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [ecx+32], eax

; 6158 :                         prev->next = cur->content;

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [edi+32], eax
$LN80@xmlRelaxNG:

; 6159 :                         cur = cur->content;
; 6160 :                     }
; 6161 :                 }
; 6162 :             }
; 6163 :             /*
; 6164 :              * the current node may have been transformed back
; 6165 :              */
; 6166 :             if ((cur->type == XML_RELAXNG_EXCEPT) &&
; 6167 :                 (cur->content != NULL) &&

	mov	esi, DWORD PTR [edx]
	mov	eax, DWORD PTR [esi]
$LN41@xmlRelaxNG:
	cmp	eax, 2
	jne	$LN42@xmlRelaxNG
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN48@xmlRelaxNG
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN48@xmlRelaxNG

; 6168 :                 (cur->content->type == XML_RELAXNG_NOT_ALLOWED)) {
; 6169 :                 prev = xmlRelaxNGTryUnlink(ctxt, cur, parent, prev);

	push	edi
	push	ebx
	push	esi
	push	DWORD PTR _ctxt$[ebp]

; 6198 :                 } else
; 6199 :                     prev = cur;
; 6200 :             } else {
; 6201 :                 prev = cur;
; 6202 :             }
; 6203 :         }
; 6204 :         cur = cur->next;

	call	_xmlRelaxNGTryUnlink
	mov	edi, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _prev$1$[ebp], edi
	jmp	SHORT $LN78@xmlRelaxNG
$LN48@xmlRelaxNG:
	mov	edi, esi
	mov	DWORD PTR _prev$1$[ebp], edi
	jmp	SHORT $LN78@xmlRelaxNG
$LN44@xmlRelaxNG:

; 6184 :                 } else
; 6185 :                     prev = cur;
; 6186 :             } else if (cur->type == XML_RELAXNG_EMPTY) {

	test	eax, eax
	jne	SHORT $LN48@xmlRelaxNG

; 6187 :                 if ((parent != NULL) &&

	test	ebx, ebx
	je	SHORT $LN48@xmlRelaxNG
	mov	eax, DWORD PTR [ebx]
	cmp	eax, 16					; 00000010H
	je	SHORT $LN53@xmlRelaxNG
	cmp	eax, 15					; 0000000fH
	je	SHORT $LN53@xmlRelaxNG

; 6191 :                     break;
; 6192 :                 }
; 6193 :                 if ((parent != NULL) &&

	cmp	eax, 18					; 00000012H
	je	SHORT $LN56@xmlRelaxNG
	cmp	eax, 19					; 00000013H
	je	SHORT $LN56@xmlRelaxNG
	cmp	eax, 17					; 00000011H
	jne	SHORT $LN48@xmlRelaxNG
$LN56@xmlRelaxNG:

; 6194 :                     ((parent->type == XML_RELAXNG_GROUP) ||
; 6195 :                      (parent->type == XML_RELAXNG_INTERLEAVE) ||
; 6196 :                      (parent->type == XML_RELAXNG_CHOICE))) {
; 6197 :                     prev = xmlRelaxNGTryUnlink(ctxt, cur, parent, prev);

	push	edi
	push	ebx
	push	esi
	push	DWORD PTR _ctxt$[ebp]

; 6198 :                 } else
; 6199 :                     prev = cur;
; 6200 :             } else {
; 6201 :                 prev = cur;
; 6202 :             }
; 6203 :         }
; 6204 :         cur = cur->next;

	call	_xmlRelaxNGTryUnlink
	mov	edi, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _prev$1$[ebp], edi
	jmp	SHORT $LN78@xmlRelaxNG
$LN65@xmlRelaxNG:

; 6057 :             (cur->type == XML_RELAXNG_PARENTREF)) {
; 6058 :             if (cur->depth != -3) {

	cmp	WORD PTR [esi+48], -3			; fffffffdH
	je	SHORT $LN11@xmlRelaxNG

; 6059 :                 cur->depth = -3;
; 6060 :                 xmlRelaxNGSimplify(ctxt, cur->content, cur);

	push	esi
	push	DWORD PTR [esi+24]
	mov	WORD PTR [esi+48], dx
	push	ecx
	call	_xmlRelaxNGSimplify
	add	esp, 12					; 0000000cH
$LN78@xmlRelaxNG:

; 6198 :                 } else
; 6199 :                     prev = cur;
; 6200 :             } else {
; 6201 :                 prev = cur;
; 6202 :             }
; 6203 :         }
; 6204 :         cur = cur->next;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, -3					; fffffffdH
$LN11@xmlRelaxNG:
	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	$LL2@xmlRelaxNG

; 6205 :     }
; 6206 : }

	pop	ebx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@xmlRelaxNG:

; 6172 :                     ((parent->type == XML_RELAXNG_ATTRIBUTE) ||
; 6173 :                      (parent->type == XML_RELAXNG_LIST) ||
; 6174 :                      (parent->type == XML_RELAXNG_GROUP) ||
; 6175 :                      (parent->type == XML_RELAXNG_INTERLEAVE) ||
; 6176 :                      (parent->type == XML_RELAXNG_ONEORMORE) ||
; 6177 :                      (parent->type == XML_RELAXNG_ZEROORMORE))) {
; 6178 :                     parent->type = XML_RELAXNG_NOT_ALLOWED;

	mov	DWORD PTR [ebx], 1
	pop	ebx
	pop	edi

; 6205 :     }
; 6206 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@xmlRelaxNG:

; 6188 :                     ((parent->type == XML_RELAXNG_ONEORMORE) ||
; 6189 :                      (parent->type == XML_RELAXNG_ZEROORMORE))) {
; 6190 :                     parent->type = XML_RELAXNG_EMPTY;

	mov	DWORD PTR [ebx], 0
	pop	ebx
$LN73@xmlRelaxNG:

; 6205 :     }
; 6206 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGSimplify ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGTryUnlink
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_parent$ = 16						; size = 4
_prev$ = 20						; size = 4
_xmlRelaxNGTryUnlink PROC				; COMDAT

; 6023 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _prev$[ebp]
	test	edx, edx
	je	SHORT $LN2@xmlRelaxNG

; 6036 :             prev = cur;
; 6037 :         }
; 6038 :     }
; 6039 :     return (prev);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	eax, edx
	mov	ecx, DWORD PTR [ecx+32]
	mov	DWORD PTR [edx+32], ecx

; 6040 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:

; 6024 :     if (prev != NULL) {
; 6025 :         prev->next = cur->next;
; 6026 :     } else {
; 6027 :         if (parent != NULL) {

	mov	ecx, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@xmlRelaxNG

; 6028 :             if (parent->content == cur)

	cmp	DWORD PTR [ecx+24], eax
	jne	SHORT $LN6@xmlRelaxNG

; 6029 :                 parent->content = cur->next;

	mov	eax, DWORD PTR [eax+32]
	mov	DWORD PTR [ecx+24], eax

; 6036 :             prev = cur;
; 6037 :         }
; 6038 :     }
; 6039 :     return (prev);

	mov	eax, edx

; 6040 : }

	pop	ebp
	ret	0
$LN6@xmlRelaxNG:

; 6030 :             else if (parent->attrs == cur)

	cmp	DWORD PTR [ecx+36], eax
	jne	SHORT $LN8@xmlRelaxNG

; 6031 :                 parent->attrs = cur->next;

	mov	eax, DWORD PTR [eax+32]
	mov	DWORD PTR [ecx+36], eax

; 6036 :             prev = cur;
; 6037 :         }
; 6038 :     }
; 6039 :     return (prev);

	mov	eax, edx

; 6040 : }

	pop	ebp
	ret	0
$LN8@xmlRelaxNG:

; 6032 :             else if (parent->nameClass == cur)

	cmp	DWORD PTR [ecx+40], eax
	jne	SHORT $LN12@xmlRelaxNG

; 6033 :                 parent->nameClass = cur->next;

	mov	eax, DWORD PTR [eax+32]
	mov	DWORD PTR [ecx+40], eax
$LN12@xmlRelaxNG:

; 6040 : }

	mov	eax, edx
	pop	ebp
	ret	0
$LN4@xmlRelaxNG:

; 6034 :         } else {
; 6035 :             cur->type = XML_RELAXNG_NOOP;

	mov	DWORD PTR [eax], -1

; 6040 : }

	pop	ebp
	ret	0
_xmlRelaxNGTryUnlink ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGCheckCycles
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlRelaxNGCheckCycles PROC				; COMDAT

; 5982 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _depth$[ebp]
	xor	ecx, ecx
	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	npad	5
$LL2@xmlRelaxNG:

; 5983 :     int ret = 0;
; 5984 : 
; 5985 :     while ((ret == 0) && (cur != NULL)) {

	test	esi, esi
	je	SHORT $LN3@xmlRelaxNG

; 5986 :         if ((cur->type == XML_RELAXNG_REF) ||

	mov	eax, DWORD PTR [esi]
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN17@xmlRelaxNG
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN17@xmlRelaxNG

; 5997 :             }
; 5998 :         } else if (cur->type == XML_RELAXNG_ELEMENT) {

	mov	ecx, DWORD PTR [esi+24]
	cmp	eax, 4
	jne	SHORT $LN10@xmlRelaxNG

; 5999 :             ret = xmlRelaxNGCheckCycles(ctxt, cur->content, depth + 1);

	lea	eax, DWORD PTR [edi+1]
	push	eax
	push	ecx
	push	ebx
	call	_xmlRelaxNGCheckCycles
	add	esp, 12					; 0000000cH
	mov	ecx, eax

; 6000 :         } else {

	jmp	SHORT $LN9@xmlRelaxNG
$LN10@xmlRelaxNG:

; 6001 :             ret = xmlRelaxNGCheckCycles(ctxt, cur->content, depth);

	push	edi
	push	ecx
	push	ebx
	call	_xmlRelaxNGCheckCycles
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	jmp	SHORT $LN9@xmlRelaxNG
$LN17@xmlRelaxNG:

; 5987 :             (cur->type == XML_RELAXNG_PARENTREF)) {
; 5988 :             if (cur->depth == -1) {

	movzx	eax, WORD PTR [esi+48]
	cmp	ax, -1
	jne	SHORT $LN7@xmlRelaxNG

; 5989 :                 cur->depth = depth;
; 5990 :                 ret = xmlRelaxNGCheckCycles(ctxt, cur->content, depth);

	push	edi
	push	DWORD PTR [esi+24]
	mov	WORD PTR [esi+48], di
	push	ebx
	call	_xmlRelaxNGCheckCycles
	mov	ecx, eax
	add	esp, 12					; 0000000cH

; 5991 :                 cur->depth = -2;

	mov	eax, -2					; fffffffeH
	mov	WORD PTR [esi+48], ax
	jmp	SHORT $LN9@xmlRelaxNG
$LN7@xmlRelaxNG:

; 5992 :             } else if (depth == cur->depth) {

	cwde
	cmp	edi, eax
	je	SHORT $LN14@xmlRelaxNG
$LN9@xmlRelaxNG:

; 6002 :         }
; 6003 :         cur = cur->next;

	mov	esi, DWORD PTR [esi+32]
	test	ecx, ecx
	je	SHORT $LL2@xmlRelaxNG
$LN3@xmlRelaxNG:
	pop	edi

; 6004 :     }
; 6005 :     return (ret);
; 6006 : }

	pop	esi
	mov	eax, ecx
	pop	ebx
	pop	ebp
	ret	0
$LN14@xmlRelaxNG:

; 5993 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_REF_CYCLE,

	push	0
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0CD@GDGLIOPD@Detected?5a?5cycle?5in?5?$CFs?5referenc@
	push	1099					; 0000044bH
	push	DWORD PTR [esi+4]
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 5994 :                            "Detected a cycle in %s references\n",
; 5995 :                            cur->name, NULL);
; 5996 :                 return (-1);

	or	eax, -1
	pop	edi

; 6004 :     }
; 6005 :     return (ret);
; 6006 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlRelaxNGCheckCycles ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGCombineStart
_TEXT	SEGMENT
_tmpname$1 = -44					; size = 32
tv539 = -12						; size = 4
_missing$1$ = -8					; size = 4
_choiceOrInterleave$1$ = -4				; size = 4
_ctxt$ = 8						; size = 4
_starts$1$ = 12						; size = 4
_grammar$ = 12						; size = 4
_xmlRelaxNGCombineStart PROC				; COMDAT

; 5875 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	or	eax, -1
	mov	DWORD PTR _missing$1$[ebp], 0
	mov	DWORD PTR _choiceOrInterleave$1$[ebp], eax
	mov	eax, DWORD PTR _grammar$[ebp]
	mov	DWORD PTR tv539[ebp], eax
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _starts$1$[ebp], eax
	test	eax, eax
	je	$LN5@xmlRelaxNG

; 5876 :     xmlRelaxNGDefinePtr starts;
; 5877 :     xmlChar *combine;
; 5878 :     int choiceOrInterleave = -1;
; 5879 :     int missing = 0;
; 5880 :     xmlRelaxNGDefinePtr cur;
; 5881 : 
; 5882 :     starts = grammar->start;
; 5883 :     if ((starts == NULL) || (starts->next == NULL))

	cmp	DWORD PTR [eax+32], 0
	je	$LN5@xmlRelaxNG

; 5884 :         return;
; 5885 :     cur = starts;

	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	edi
	mov	edi, eax
	push	ebx
$LL2@xmlRelaxNG:

; 5886 :     while (cur != NULL) {
; 5887 :         if ((cur->node == NULL) || (cur->node->parent == NULL) ||

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	$LN8@xmlRelaxNG
	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	je	$LN8@xmlRelaxNG
	push	OFFSET ??_C@_05FAGFPHJG@start@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN8@xmlRelaxNG

; 5891 :                        "Internal error: start element not found\n", NULL,
; 5892 :                        NULL);
; 5893 :         } else {
; 5894 :             combine = xmlGetProp(cur->node->parent, BAD_CAST "combine");

	mov	eax, DWORD PTR [edi+4]
	push	OFFSET ??_C@_07PCDCECCK@combine@
	push	DWORD PTR [eax+20]
	call	_xmlGetProp
	mov	ebx, eax
	add	esp, 8

; 5895 :         }
; 5896 : 
; 5897 :         if (combine != NULL) {

	test	ebx, ebx
	je	$LN9@xmlRelaxNG

; 5898 :             if (xmlStrEqual(combine, BAD_CAST "choice")) {

	push	OFFSET ??_C@_06DDDNEJEA@choice@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlRelaxNG

; 5899 :                 if (choiceOrInterleave == -1)

	mov	eax, DWORD PTR _choiceOrInterleave$1$[ebp]
	cmp	eax, -1
	jne	SHORT $LN13@xmlRelaxNG

; 5916 :                            "<start> uses unknown combine value '%s''\n",
; 5917 :                            combine, NULL);
; 5918 :             }
; 5919 :             xmlFree(combine);

	push	ebx
	mov	DWORD PTR _choiceOrInterleave$1$[ebp], 1
	call	DWORD PTR _xmlFree
	add	esp, 4

; 5920 :         } else {

	jmp	$LN38@xmlRelaxNG
$LN13@xmlRelaxNG:

; 5900 :                     choiceOrInterleave = 1;
; 5901 :                 else if (choiceOrInterleave == 0) {

	test	eax, eax
	jne	SHORT $LN17@xmlRelaxNG

; 5902 :                     xmlRngPErr(ctxt, cur->node, XML_RNGP_START_CHOICE_AND_INTERLEAVE,

	push	eax
	push	eax
	push	OFFSET ??_C@_0CM@KNKPDGOJ@?$DMstart?$DO?5use?5both?5?8choice?8?5and?5?8@
	push	1104					; 00000450H

; 5903 :                                "<start> use both 'choice' and 'interleave'\n",
; 5904 :                                NULL, NULL);
; 5905 :                 }

	jmp	SHORT $LN53@xmlRelaxNG
$LN11@xmlRelaxNG:

; 5906 :             } else if (xmlStrEqual(combine, BAD_CAST "interleave")) {

	push	OFFSET ??_C@_0L@NLPEADBD@interleave@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlRelaxNG

; 5907 :                 if (choiceOrInterleave == -1)

	mov	eax, DWORD PTR _choiceOrInterleave$1$[ebp]
	cmp	eax, -1
	jne	SHORT $LN18@xmlRelaxNG

; 5916 :                            "<start> uses unknown combine value '%s''\n",
; 5917 :                            combine, NULL);
; 5918 :             }
; 5919 :             xmlFree(combine);

	push	ebx
	mov	DWORD PTR _choiceOrInterleave$1$[ebp], 0
	call	DWORD PTR _xmlFree
	add	esp, 4

; 5920 :         } else {

	jmp	$LN38@xmlRelaxNG
$LN18@xmlRelaxNG:

; 5908 :                     choiceOrInterleave = 0;
; 5909 :                 else if (choiceOrInterleave == 1) {

	cmp	eax, 1
	jne	SHORT $LN17@xmlRelaxNG

; 5910 :                     xmlRngPErr(ctxt, cur->node, XML_RNGP_START_CHOICE_AND_INTERLEAVE,

	push	0
	push	0
	push	OFFSET ??_C@_0CM@KNKPDGOJ@?$DMstart?$DO?5use?5both?5?8choice?8?5and?5?8@
	push	1104					; 00000450H

; 5911 :                                "<start> use both 'choice' and 'interleave'\n",
; 5912 :                                NULL, NULL);
; 5913 :                 }
; 5914 :             } else {

	jmp	SHORT $LN53@xmlRelaxNG
$LN16@xmlRelaxNG:

; 5915 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_UNKNOWN_COMBINE,

	push	0
	push	ebx
	push	OFFSET ??_C@_0CK@DGGLNMFN@?$DMstart?$DO?5uses?5unknown?5combine?5va@
	push	1114					; 0000045aH
$LN53@xmlRelaxNG:

; 5916 :                            "<start> uses unknown combine value '%s''\n",
; 5917 :                            combine, NULL);
; 5918 :             }
; 5919 :             xmlFree(combine);

	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN17@xmlRelaxNG:
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 5920 :         } else {

	jmp	$LN38@xmlRelaxNG
$LN8@xmlRelaxNG:

; 5888 :             (!xmlStrEqual(cur->node->parent->name, BAD_CAST "start"))) {
; 5889 :             combine = NULL;
; 5890 :             xmlRngPErr(ctxt, cur->node, XML_RNGP_START_MISSING,

	mov	ebx, DWORD PTR [edi+4]

; 515  :     xmlStructuredErrorFunc schannel = NULL;

	xor	eax, eax

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	ecx, ecx

; 517  :     void *data = NULL;

	xor	edx, edx

; 518  : 
; 519  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN48@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN49@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	ecx, DWORD PTR [esi+4]
$LN49@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	edx, DWORD PTR [esi]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [esi+36]
$LN48@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	0
	push	OFFSET ??_C@_0CJ@EGDAKNFC@Internal?5error?3?5start?5element?5n@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1107					; 00000453H
	push	18					; 00000012H
	push	ebx
	push	0
	push	edx
	push	ecx
	push	eax
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN9@xmlRelaxNG:

; 5921 :             if (missing == 0)

	cmp	DWORD PTR _missing$1$[ebp], 0
	jne	SHORT $LN21@xmlRelaxNG

; 5922 :                 missing = 1;

	mov	DWORD PTR _missing$1$[ebp], 1
	jmp	SHORT $LN38@xmlRelaxNG
$LN21@xmlRelaxNG:

; 5923 :             else {
; 5924 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_NEED_COMBINE,

	mov	ebx, DWORD PTR [edi+4]

; 515  :     xmlStructuredErrorFunc schannel = NULL;

	xor	eax, eax

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	ecx, ecx

; 517  :     void *data = NULL;

	xor	edx, edx

; 518  : 
; 519  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN39@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN41@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	ecx, DWORD PTR [esi+4]
$LN41@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	edx, DWORD PTR [esi]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [esi+36]
$LN39@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	0
	push	OFFSET ??_C@_0DB@FEIAJIL@Some?5?$DMstart?$DO?5element?5miss?5the?5c@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1054					; 0000041eH
	push	18					; 00000012H
	push	ebx
	push	0
	push	edx
	push	ecx
	push	eax
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN38@xmlRelaxNG:

; 5925 :                            "Some <start> element miss the combine attribute\n",
; 5926 :                            NULL, NULL);
; 5927 :             }
; 5928 :         }
; 5929 : 
; 5930 :         cur = cur->next;

	mov	edi, DWORD PTR [edi+32]
	test	edi, edi
	jne	$LL2@xmlRelaxNG

; 5931 :     }
; 5932 : #ifdef DEBUG
; 5933 :     xmlGenericError(xmlGenericErrorContext,
; 5934 :                     "xmlRelaxNGCombineStart(): merging <start>: %d\n",
; 5935 :                     choiceOrInterleave);
; 5936 : #endif
; 5937 :     if (choiceOrInterleave == -1)
; 5938 :         choiceOrInterleave = 0;
; 5939 :     cur = xmlRelaxNGNewDefine(ctxt, starts->node);

	mov	eax, DWORD PTR _starts$1$[ebp]
	xor	ebx, ebx
	cmp	DWORD PTR _choiceOrInterleave$1$[ebp], -1
	cmovne	ebx, DWORD PTR _choiceOrInterleave$1$[ebp]
	push	DWORD PTR [eax+4]
	push	esi
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8

; 5940 :     if (cur == NULL)

	test	edi, edi
	je	$LN52@xmlRelaxNG

; 5941 :         return;
; 5942 :     if (choiceOrInterleave == 0)
; 5943 :         cur->type = XML_RELAXNG_INTERLEAVE;
; 5944 :     else
; 5945 :         cur->type = XML_RELAXNG_CHOICE;
; 5946 :     cur->content = grammar->start;

	mov	eax, DWORD PTR tv539[ebp]
	xor	ecx, ecx
	test	ebx, ebx
	sete	cl
	lea	ecx, DWORD PTR [ecx*2+17]
	mov	DWORD PTR [edi], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edi+24], ecx

; 5947 :     grammar->start = cur;

	mov	DWORD PTR [eax+12], edi

; 5948 :     if (choiceOrInterleave == 0) {

	test	ebx, ebx
	jne	SHORT $LN52@xmlRelaxNG

; 5949 :         if (ctxt->interleaves == NULL)

	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	jne	SHORT $LN29@xmlRelaxNG

; 5950 :             ctxt->interleaves = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+56], eax

; 5951 :         if (ctxt->interleaves == NULL) {

	test	eax, eax
	jne	SHORT $LN29@xmlRelaxNG

; 5952 :             xmlRngPErr(ctxt, cur->node, XML_RNGP_INTERLEAVE_CREATE_FAILED,

	push	eax
	push	eax
	push	OFFSET ??_C@_0CJ@MHLGCECD@Failed?5to?5create?5interleaves?5ha@

; 5953 :                        "Failed to create interleaves hash table\n", NULL,
; 5954 :                        NULL);
; 5955 :         } else {

	jmp	SHORT $LN55@xmlRelaxNG
$LN29@xmlRelaxNG:

; 5956 :             char tmpname[32];
; 5957 : 
; 5958 :             snprintf(tmpname, 32, "interleave%d", ctxt->nbInterleaves++);

	mov	ecx, DWORD PTR [esi+52]
	push	ecx
	push	OFFSET ??_C@_0N@MHPBOBHE@interleave?$CFd@
	push	32					; 00000020H
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+52], eax
	lea	eax, DWORD PTR _tmpname$1[ebp]
	push	eax
	call	_snprintf

; 5959 :             if (xmlHashAddEntry(ctxt->interleaves, BAD_CAST tmpname, cur) <

	push	edi
	lea	eax, DWORD PTR _tmpname$1[ebp]
	push	eax
	push	DWORD PTR [esi+56]
	call	_xmlHashAddEntry
	add	esp, 28					; 0000001cH
	test	eax, eax
	jns	SHORT $LN52@xmlRelaxNG

; 5960 :                 0) {
; 5961 :                 xmlRngPErr(ctxt, cur->node, XML_RNGP_INTERLEAVE_CREATE_FAILED,

	push	0
	lea	eax, DWORD PTR _tmpname$1[ebp]
	push	eax
	push	OFFSET ??_C@_0CA@BLFIOJCN@Failed?5to?5add?5?$CFs?5to?5hash?5table?6@
$LN55@xmlRelaxNG:
	push	1046					; 00000416H
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN52@xmlRelaxNG:
	pop	ebx
	pop	edi
	pop	esi
$LN5@xmlRelaxNG:

; 5962 :                            "Failed to add %s to hash table\n",
; 5963 : 			   (const xmlChar *) tmpname, NULL);
; 5964 :             }
; 5965 :         }
; 5966 :     }
; 5967 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGCombineStart ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGCheckCombine
_TEXT	SEGMENT
_tmpname$1 = -44					; size = 32
_node$1$ = -12						; size = 4
_node$1$ = -12						; size = 4
tv673 = -8						; size = 4
_cur$1$ = -8						; size = 4
_missing$1$ = -4					; size = 4
_cur$2$ = 8						; size = 4
_payload$ = 8						; size = 4
_data$1$ = 12						; size = 4
_data$1$ = 12						; size = 4
_last$1$ = 12						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlRelaxNGCheckCombine PROC				; COMDAT

; 5754 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _payload$[ebp]
	or	edi, -1
	mov	DWORD PTR _missing$1$[ebp], 0
	cmp	DWORD PTR [eax+44], 0
	je	$LN35@xmlRelaxNG

; 5755 :     xmlRelaxNGDefinePtr define = (xmlRelaxNGDefinePtr) payload;
; 5756 :     xmlRelaxNGParserCtxtPtr ctxt = (xmlRelaxNGParserCtxtPtr) data;
; 5757 :     xmlChar *combine;
; 5758 :     int choiceOrInterleave = -1;
; 5759 :     int missing = 0;
; 5760 :     xmlRelaxNGDefinePtr cur, last, tmp, tmp2;
; 5761 : 
; 5762 :     if (define->nextHash == NULL)
; 5763 :         return;
; 5764 :     cur = define;

	push	esi
	mov	esi, DWORD PTR _data$[ebp]
	mov	ecx, eax
	mov	DWORD PTR _cur$1$[ebp], ecx
	push	ebx
$LL2@xmlRelaxNG:

; 5765 :     while (cur != NULL) {
; 5766 :         combine = xmlGetProp(cur->node, BAD_CAST "combine");

	push	OFFSET ??_C@_07PCDCECCK@combine@
	push	DWORD PTR [ecx+4]
	call	_xmlGetProp
	mov	ebx, eax
	add	esp, 8

; 5767 :         if (combine != NULL) {

	test	ebx, ebx
	je	$LN7@xmlRelaxNG

; 5768 :             if (xmlStrEqual(combine, BAD_CAST "choice")) {

	push	OFFSET ??_C@_06DDDNEJEA@choice@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlRelaxNG

; 5769 :                 if (choiceOrInterleave == -1)

	cmp	edi, -1
	jne	SHORT $LN11@xmlRelaxNG

; 5786 :                            "Defines for %s use unknown combine value '%s''\n",
; 5787 :                            name, combine);
; 5788 :             }
; 5789 :             xmlFree(combine);

	push	ebx
	mov	edi, 1
	call	DWORD PTR _xmlFree

; 5790 :         } else {

	mov	ebx, DWORD PTR _payload$[ebp]
	add	esp, 4
	jmp	$LN42@xmlRelaxNG
$LN11@xmlRelaxNG:

; 5770 :                     choiceOrInterleave = 1;
; 5771 :                 else if (choiceOrInterleave == 0) {

	test	edi, edi

; 5772 :                     xmlRngPErr(ctxt, define->node, XML_RNGP_DEF_CHOICE_AND_INTERLEAVE,
; 5773 :                                "Defines for %s use both 'choice' and 'interleave'\n",
; 5774 :                                name, NULL);
; 5775 :                 }

	jmp	SHORT $LN59@xmlRelaxNG
$LN9@xmlRelaxNG:

; 5776 :             } else if (xmlStrEqual(combine, BAD_CAST "interleave")) {

	push	OFFSET ??_C@_0L@NLPEADBD@interleave@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlRelaxNG

; 5777 :                 if (choiceOrInterleave == -1)

	cmp	edi, -1
	jne	SHORT $LN16@xmlRelaxNG

; 5786 :                            "Defines for %s use unknown combine value '%s''\n",
; 5787 :                            name, combine);
; 5788 :             }
; 5789 :             xmlFree(combine);

	push	ebx
	xor	edi, edi
	call	DWORD PTR _xmlFree

; 5790 :         } else {

	mov	ebx, DWORD PTR _payload$[ebp]
	add	esp, 4
	jmp	$LN42@xmlRelaxNG
$LN16@xmlRelaxNG:

; 5778 :                     choiceOrInterleave = 0;
; 5779 :                 else if (choiceOrInterleave == 1) {

	cmp	edi, 1
$LN59@xmlRelaxNG:

; 5786 :                            "Defines for %s use unknown combine value '%s''\n",
; 5787 :                            name, combine);
; 5788 :             }
; 5789 :             xmlFree(combine);

	jne	$LN37@xmlRelaxNG
	mov	eax, DWORD PTR _payload$[ebp]
	push	0
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0DD@LACLCNBH@Defines?5for?5?$CFs?5use?5both?5?8choice@
	push	1010					; 000003f2H
	push	DWORD PTR [eax+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
	push	ebx
	call	DWORD PTR _xmlFree

; 5790 :         } else {

	mov	ebx, DWORD PTR _payload$[ebp]
	add	esp, 4
	jmp	$LN42@xmlRelaxNG
$LN14@xmlRelaxNG:

; 5780 :                     xmlRngPErr(ctxt, define->node, XML_RNGP_DEF_CHOICE_AND_INTERLEAVE,
; 5781 :                                "Defines for %s use both 'choice' and 'interleave'\n",
; 5782 :                                name, NULL);
; 5783 :                 }
; 5784 :             } else {
; 5785 :                 xmlRngPErr(ctxt, define->node, XML_RNGP_UNKNOWN_COMBINE,

	mov	eax, DWORD PTR _payload$[ebp]

; 515  :     xmlStructuredErrorFunc schannel = NULL;

	xor	ecx, ecx

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	edx, edx

; 517  :     void *data = NULL;

	mov	DWORD PTR _data$1$[ebp], ecx

; 5780 :                     xmlRngPErr(ctxt, define->node, XML_RNGP_DEF_CHOICE_AND_INTERLEAVE,
; 5781 :                                "Defines for %s use both 'choice' and 'interleave'\n",
; 5782 :                                name, NULL);
; 5783 :                 }
; 5784 :             } else {
; 5785 :                 xmlRngPErr(ctxt, define->node, XML_RNGP_UNKNOWN_COMBINE,

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _node$1$[ebp], eax

; 519  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN38@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN40@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [esi+4]
$LN40@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	eax, DWORD PTR [esi]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [esi+36]
	mov	DWORD PTR _data$1$[ebp], eax
$LN38@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	mov	eax, DWORD PTR _name$[ebp]
	push	ebx
	push	eax
	push	OFFSET ??_C@_0DA@BFEPFJDA@Defines?5for?5?$CFs?5use?5unknown?5comb@
	push	0
	push	0
	push	0
	push	ebx
	push	eax
	push	0
	push	0
	push	2
	push	1114					; 0000045aH
	push	18					; 00000012H
	push	DWORD PTR _node$1$[ebp]
	push	0
	push	DWORD PTR _data$1$[ebp]
	push	edx
	push	ecx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN37@xmlRelaxNG:

; 5786 :                            "Defines for %s use unknown combine value '%s''\n",
; 5787 :                            name, combine);
; 5788 :             }
; 5789 :             xmlFree(combine);

	push	ebx
	call	DWORD PTR _xmlFree

; 5790 :         } else {

	mov	ebx, DWORD PTR _payload$[ebp]
	add	esp, 4
	jmp	SHORT $LN42@xmlRelaxNG
$LN7@xmlRelaxNG:

; 5791 :             if (missing == 0)

	cmp	DWORD PTR _missing$1$[ebp], 0
	mov	ebx, DWORD PTR _payload$[ebp]
	jne	SHORT $LN19@xmlRelaxNG

; 5792 :                 missing = 1;

	mov	DWORD PTR _missing$1$[ebp], 1
	jmp	SHORT $LN42@xmlRelaxNG
$LN19@xmlRelaxNG:

; 5793 :             else {
; 5794 :                 xmlRngPErr(ctxt, define->node, XML_RNGP_NEED_COMBINE,

	mov	eax, DWORD PTR [ebx+4]

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	edx, edx

; 5793 :             else {
; 5794 :                 xmlRngPErr(ctxt, define->node, XML_RNGP_NEED_COMBINE,

	mov	DWORD PTR _node$1$[ebp], eax

; 515  :     xmlStructuredErrorFunc schannel = NULL;

	xor	eax, eax

; 517  :     void *data = NULL;

	mov	DWORD PTR _data$1$[ebp], eax

; 518  : 
; 519  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN43@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN45@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [esi+4]
$LN45@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	ecx, DWORD PTR [esi]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [esi+36]
	mov	DWORD PTR _data$1$[ebp], ecx
$LN43@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	mov	ecx, DWORD PTR _name$[ebp]
	push	0
	push	ecx
	push	OFFSET ??_C@_0DB@MHLFAPLB@Some?5defines?5for?5?$CFs?5needs?5the?5c@
	push	0
	push	0
	push	0
	push	0
	push	ecx
	push	0
	push	0
	push	2
	push	1054					; 0000041eH
	push	18					; 00000012H
	push	DWORD PTR _node$1$[ebp]
	push	0
	push	DWORD PTR _data$1$[ebp]
	push	edx
	push	eax
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN42@xmlRelaxNG:

; 5795 :                            "Some defines for %s needs the combine attribute\n",
; 5796 :                            name, NULL);
; 5797 :             }
; 5798 :         }
; 5799 : 
; 5800 :         cur = cur->nextHash;

	mov	ecx, DWORD PTR _cur$1$[ebp]
	mov	ecx, DWORD PTR [ecx+44]
	mov	DWORD PTR _cur$1$[ebp], ecx
	test	ecx, ecx
	jne	$LL2@xmlRelaxNG

; 5801 :     }
; 5802 : #ifdef DEBUG
; 5803 :     xmlGenericError(xmlGenericErrorContext,
; 5804 :                     "xmlRelaxNGCheckCombine(): merging %s defines: %d\n",
; 5805 :                     name, choiceOrInterleave);
; 5806 : #endif
; 5807 :     if (choiceOrInterleave == -1)
; 5808 :         choiceOrInterleave = 0;
; 5809 :     cur = xmlRelaxNGNewDefine(ctxt, define->node);

	push	DWORD PTR [ebx+4]
	xor	eax, eax
	cmp	edi, -1
	push	esi
	cmovne	eax, edi
	mov	DWORD PTR tv673[ebp], eax
	call	_xmlRelaxNGNewDefine
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR _cur$2$[ebp], edx

; 5810 :     if (cur == NULL)

	test	edx, edx
	je	$LN58@xmlRelaxNG

; 5811 :         return;
; 5812 :     if (choiceOrInterleave == 0)
; 5813 :         cur->type = XML_RELAXNG_INTERLEAVE;
; 5814 :     else
; 5815 :         cur->type = XML_RELAXNG_CHOICE;
; 5816 :     tmp = define;

	xor	ecx, ecx
	mov	edi, ebx
	cmp	DWORD PTR tv673[ebp], ecx
	sete	cl
	lea	ecx, DWORD PTR [ecx*2+17]
	mov	DWORD PTR [edx], ecx

; 5817 :     last = NULL;

	xor	ecx, ecx
	mov	DWORD PTR _last$1$[ebp], ecx
	npad	3
$LL4@xmlRelaxNG:

; 5818 :     while (tmp != NULL) {
; 5819 :         if (tmp->content != NULL) {

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN25@xmlRelaxNG

; 5820 :             if (tmp->content->next != NULL) {

	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN26@xmlRelaxNG

; 5821 :                 /*
; 5822 :                  * we need first to create a wrapper.
; 5823 :                  */
; 5824 :                 tmp2 = xmlRelaxNGNewDefine(ctxt, tmp->content->node);

	push	DWORD PTR [eax+4]
	push	esi
	call	_xmlRelaxNGNewDefine

; 5825 :                 if (tmp2 == NULL)

	mov	edx, DWORD PTR _cur$2$[ebp]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN49@xmlRelaxNG

; 5826 :                     break;
; 5827 :                 tmp2->type = XML_RELAXNG_GROUP;

	mov	DWORD PTR [eax], 18			; 00000012H

; 5828 :                 tmp2->content = tmp->content;

	mov	ecx, DWORD PTR [edi+24]
	mov	DWORD PTR [eax+24], ecx

; 5829 :             } else {

	mov	ecx, DWORD PTR _last$1$[ebp]
$LN26@xmlRelaxNG:

; 5830 :                 tmp2 = tmp->content;
; 5831 :             }
; 5832 :             if (last == NULL) {

	test	ecx, ecx
	jne	SHORT $LN29@xmlRelaxNG

; 5833 :                 cur->content = tmp2;

	mov	DWORD PTR [edx+24], eax

; 5834 :             } else {

	jmp	SHORT $LN30@xmlRelaxNG
$LN29@xmlRelaxNG:

; 5835 :                 last->next = tmp2;

	mov	DWORD PTR [ecx+32], eax
$LN30@xmlRelaxNG:

; 5836 :             }
; 5837 :             last = tmp2;

	mov	ecx, eax
	mov	DWORD PTR _last$1$[ebp], ecx
$LN25@xmlRelaxNG:

; 5838 :         }
; 5839 :         tmp->content = cur;

	mov	DWORD PTR [edi+24], edx

; 5840 :         tmp = tmp->nextHash;

	mov	edi, DWORD PTR [edi+44]
	test	edi, edi
	jne	SHORT $LL4@xmlRelaxNG
$LN49@xmlRelaxNG:

; 5841 :     }
; 5842 :     define->content = cur;
; 5843 :     if (choiceOrInterleave == 0) {

	cmp	DWORD PTR tv673[ebp], 0
	mov	DWORD PTR [ebx+24], edx
	jne	SHORT $LN58@xmlRelaxNG

; 5844 :         if (ctxt->interleaves == NULL)

	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	jne	SHORT $LN33@xmlRelaxNG

; 5845 :             ctxt->interleaves = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+56], eax

; 5846 :         if (ctxt->interleaves == NULL) {

	test	eax, eax
	jne	SHORT $LN33@xmlRelaxNG

; 5847 :             xmlRngPErr(ctxt, define->node, XML_RNGP_INTERLEAVE_CREATE_FAILED,

	push	eax
	push	eax
	push	OFFSET ??_C@_0CJ@MHLGCECD@Failed?5to?5create?5interleaves?5ha@

; 5848 :                        "Failed to create interleaves hash table\n", NULL,
; 5849 :                        NULL);
; 5850 :         } else {

	jmp	SHORT $LN61@xmlRelaxNG
$LN33@xmlRelaxNG:

; 5851 :             char tmpname[32];
; 5852 : 
; 5853 :             snprintf(tmpname, 32, "interleave%d", ctxt->nbInterleaves++);

	mov	ecx, DWORD PTR [esi+52]
	push	ecx
	push	OFFSET ??_C@_0N@MHPBOBHE@interleave?$CFd@
	push	32					; 00000020H
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+52], eax
	lea	eax, DWORD PTR _tmpname$1[ebp]
	push	eax
	call	_snprintf

; 5854 :             if (xmlHashAddEntry(ctxt->interleaves, BAD_CAST tmpname, cur) <

	push	DWORD PTR _cur$2$[ebp]
	lea	eax, DWORD PTR _tmpname$1[ebp]
	push	eax
	push	DWORD PTR [esi+56]
	call	_xmlHashAddEntry
	add	esp, 28					; 0000001cH
	test	eax, eax
	jns	SHORT $LN58@xmlRelaxNG

; 5855 :                 0) {
; 5856 :                 xmlRngPErr(ctxt, define->node, XML_RNGP_INTERLEAVE_CREATE_FAILED,

	push	0
	lea	eax, DWORD PTR _tmpname$1[ebp]
	push	eax
	push	OFFSET ??_C@_0CA@BLFIOJCN@Failed?5to?5add?5?$CFs?5to?5hash?5table?6@
$LN61@xmlRelaxNG:
	push	1046					; 00000416H
	push	DWORD PTR [ebx+4]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN58@xmlRelaxNG:
	pop	ebx
	pop	esi
$LN35@xmlRelaxNG:
	pop	edi

; 5857 :                            "Failed to add %s to hash table\n",
; 5858 : 			   (const xmlChar *) tmpname, NULL);
; 5859 :             }
; 5860 :         }
; 5861 :     }
; 5862 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGCheckCombine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGCheckReference
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlRelaxNGCheckReference PROC				; COMDAT

; 5698 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _payload$[ebp]
	mov	eax, 256				; 00000100H
	test	WORD PTR [esi+50], ax
	jne	$LN8@xmlRelaxNG

; 5699 :     xmlRelaxNGDefinePtr ref = (xmlRelaxNGDefinePtr) payload;
; 5700 :     xmlRelaxNGParserCtxtPtr ctxt = (xmlRelaxNGParserCtxtPtr) data;
; 5701 :     xmlRelaxNGGrammarPtr grammar;
; 5702 :     xmlRelaxNGDefinePtr def, cur;
; 5703 : 
; 5704 :     /*
; 5705 :      * Those rules don't apply to imported ref from xmlRelaxNGParseImportRef
; 5706 :      */
; 5707 :     if (ref->dflags & IS_EXTERNAL_REF)
; 5708 :         return;
; 5709 : 
; 5710 :     grammar = ctxt->grammar;

	push	edi
	mov	edi, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [edi+24]

; 5711 :     if (grammar == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlRelaxNG

; 5712 :         xmlRngPErr(ctxt, ref->node, XML_ERR_INTERNAL_ERROR,

	push	eax
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0DB@CFGFLOFC@Internal?5error?3?5no?5grammar?5in?5C@
	push	1

; 5730 :             }
; 5731 :         } else {
; 5732 :             xmlRngPErr(ctxt, ref->node, XML_RNGP_REF_NO_DEF,
; 5733 :                        "Reference %s has no matching definition\n", name,
; 5734 :                        NULL);
; 5735 :         }
; 5736 :     } else {
; 5737 :         xmlRngPErr(ctxt, ref->node, XML_RNGP_REF_NO_DEF,

	push	DWORD PTR [esi+4]
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi

; 5738 :                    "Reference %s has no matching definition\n", name,
; 5739 :                    NULL);
; 5740 :     }
; 5741 : }

	pop	ebp
	ret	0
$LN5@xmlRelaxNG:

; 5713 :                    "Internal error: no grammar in CheckReference %s\n",
; 5714 :                    name, NULL);
; 5715 :         return;
; 5716 :     }
; 5717 :     if (ref->content != NULL) {

	cmp	DWORD PTR [esi+24], 0
	je	SHORT $LN6@xmlRelaxNG

; 5718 :         xmlRngPErr(ctxt, ref->node, XML_ERR_INTERNAL_ERROR,

	push	0
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0DM@EAGPADBI@Internal?5error?3?5reference?5has?5c@
	push	1

; 5730 :             }
; 5731 :         } else {
; 5732 :             xmlRngPErr(ctxt, ref->node, XML_RNGP_REF_NO_DEF,
; 5733 :                        "Reference %s has no matching definition\n", name,
; 5734 :                        NULL);
; 5735 :         }
; 5736 :     } else {
; 5737 :         xmlRngPErr(ctxt, ref->node, XML_RNGP_REF_NO_DEF,

	push	DWORD PTR [esi+4]
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi

; 5738 :                    "Reference %s has no matching definition\n", name,
; 5739 :                    NULL);
; 5740 :     }
; 5741 : }

	pop	ebp
	ret	0
$LN6@xmlRelaxNG:

; 5719 :                    "Internal error: reference has content in CheckReference %s\n",
; 5720 :                    name, NULL);
; 5721 :         return;
; 5722 :     }
; 5723 :     if (grammar->defs != NULL) {

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG

; 5724 :         def = xmlHashLookup(grammar->defs, name);

	push	DWORD PTR _name$[ebp]
	push	eax
	call	_xmlHashLookup
	add	esp, 8

; 5725 :         if (def != NULL) {

	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG
	npad	1
$LL2@xmlRelaxNG:

; 5726 :             cur = ref;
; 5727 :             while (cur != NULL) {
; 5728 :                 cur->content = def;

	mov	DWORD PTR [esi+24], eax

; 5729 :                 cur = cur->nextHash;

	mov	esi, DWORD PTR [esi+44]
	test	esi, esi
	jne	SHORT $LL2@xmlRelaxNG
	pop	edi
	pop	esi

; 5738 :                    "Reference %s has no matching definition\n", name,
; 5739 :                    NULL);
; 5740 :     }
; 5741 : }

	pop	ebp
	ret	0
$LN7@xmlRelaxNG:

; 5730 :             }
; 5731 :         } else {
; 5732 :             xmlRngPErr(ctxt, ref->node, XML_RNGP_REF_NO_DEF,
; 5733 :                        "Reference %s has no matching definition\n", name,
; 5734 :                        NULL);
; 5735 :         }
; 5736 :     } else {
; 5737 :         xmlRngPErr(ctxt, ref->node, XML_RNGP_REF_NO_DEF,

	push	0
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0CJ@POOAHNP@Reference?5?$CFs?5has?5no?5matching?5de@
	push	1101					; 0000044dH
	push	DWORD PTR [esi+4]
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
	pop	edi
$LN8@xmlRelaxNG:
	pop	esi

; 5738 :                    "Reference %s has no matching definition\n", name,
; 5739 :                    NULL);
; 5740 :     }
; 5741 : }

	pop	ebp
	ret	0
_xmlRelaxNGCheckReference ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParseStart
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nodes$ = 12						; size = 4
_xmlRelaxNGParseStart PROC				; COMDAT

; 5591 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _nodes$[ebp]
	test	esi, esi
	jne	SHORT $LN4@xmlRelaxNG

; 519  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	xor	edx, edx
	test	eax, eax
	je	SHORT $LN18@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN20@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [eax+4]
$LN20@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	esi, DWORD PTR [eax]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [eax+36]
$LN18@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	0
	push	OFFSET ??_C@_0BH@HFFJFLLH@start?5has?5no?5children?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1106					; 00000452H
	push	18					; 00000012H
	push	0
	push	0
	push	esi
	push	edx
	push	ecx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 5592 :     int ret = 0;
; 5593 :     xmlRelaxNGDefinePtr def = NULL, last;
; 5594 : 
; 5595 :     if (nodes == NULL) {
; 5596 :         xmlRngPErr(ctxt, nodes, XML_RNGP_START_EMPTY, "start has no children\n",
; 5597 :                    NULL, NULL);
; 5598 :         return (-1);

	or	eax, -1
	pop	esi

; 5636 : }

	pop	ebp
	ret	0
$LN4@xmlRelaxNG:

; 5599 :     }
; 5600 :     if (IS_RELAXNG(nodes, "empty")) {

	cmp	DWORD PTR [esi+36], 0
	push	ebx
	push	edi
	je	$LN9@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN5@xmlRelaxNG
	push	OFFSET ??_C@_05LBJMNBOG@empty@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlRelaxNG

; 5601 :         def = xmlRelaxNGNewDefine(ctxt, nodes);

	mov	edi, DWORD PTR _ctxt$[ebp]
	push	esi
	push	edi
	call	_xmlRelaxNGNewDefine
	mov	ebx, eax
	add	esp, 8

; 5602 :         if (def == NULL)

	test	ebx, ebx
	je	$LN26@xmlRelaxNG

; 5603 :             return (-1);
; 5604 :         def->type = XML_RELAXNG_EMPTY;

	mov	DWORD PTR [ebx], 0

; 5605 :         if (nodes->children != NULL) {

	cmp	DWORD PTR [esi+12], 0
	je	$LN10@xmlRelaxNG

; 5606 :             xmlRngPErr(ctxt, nodes, XML_RNGP_EMPTY_CONTENT,

	push	0
	push	0
	push	OFFSET ??_C@_0BM@NFEKGCB@element?5empty?5is?5not?5empty?6@
	push	1024					; 00000400H
	push	esi
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 5607 :                        "element empty is not empty\n", NULL, NULL);
; 5608 :         }

	jmp	$LN10@xmlRelaxNG
$LN5@xmlRelaxNG:

; 5609 :     } else if (IS_RELAXNG(nodes, "notAllowed")) {

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN9@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN9@xmlRelaxNG
	push	OFFSET ??_C@_0L@GPGJMKBL@notAllowed@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlRelaxNG

; 5610 :         def = xmlRelaxNGNewDefine(ctxt, nodes);

	mov	edi, DWORD PTR _ctxt$[ebp]
	push	esi
	push	edi
	call	_xmlRelaxNGNewDefine
	mov	ebx, eax
	add	esp, 8

; 5611 :         if (def == NULL)

	test	ebx, ebx
	je	SHORT $LN26@xmlRelaxNG

; 5612 :             return (-1);
; 5613 :         def->type = XML_RELAXNG_NOT_ALLOWED;

	mov	DWORD PTR [ebx], 1

; 5614 :         if (nodes->children != NULL) {

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN10@xmlRelaxNG

; 5615 :             xmlRngPErr(ctxt, nodes, XML_RNGP_NOTALLOWED_NOT_EMPTY,

	push	0
	push	0
	push	OFFSET ??_C@_0CB@CILNEPNL@element?5notAllowed?5is?5not?5empty@
	push	1055					; 0000041fH
	push	esi
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 5616 :                        "element notAllowed is not empty\n", NULL, NULL);
; 5617 :         }
; 5618 :     } else {

	jmp	SHORT $LN10@xmlRelaxNG
$LN9@xmlRelaxNG:

; 5619 :         def = xmlRelaxNGParsePatterns(ctxt, nodes, 1);

	mov	edi, DWORD PTR _ctxt$[ebp]
	push	1
	push	esi
	push	edi
	call	_xmlRelaxNGParsePatterns
	add	esp, 12					; 0000000cH
	mov	ebx, eax
$LN10@xmlRelaxNG:

; 5620 :     }
; 5621 :     if (ctxt->grammar->start != NULL) {

	mov	ecx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	je	SHORT $LN13@xmlRelaxNG

; 5622 :         last = ctxt->grammar->start;
; 5623 :         while (last->next != NULL)

	mov	ecx, DWORD PTR [eax+32]
	test	ecx, ecx
	je	SHORT $LN3@xmlRelaxNG
	npad	7
$LL2@xmlRelaxNG:

; 5624 :             last = last->next;

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+32]
	test	ecx, ecx
	jne	SHORT $LL2@xmlRelaxNG
$LN3@xmlRelaxNG:

; 5625 :         last->next = def;

	mov	DWORD PTR [eax+32], ebx

; 5626 :     } else {

	jmp	SHORT $LN14@xmlRelaxNG
$LN13@xmlRelaxNG:

; 5627 :         ctxt->grammar->start = def;

	mov	DWORD PTR [ecx+12], ebx
$LN14@xmlRelaxNG:

; 5628 :     }
; 5629 :     nodes = nodes->next;

	mov	eax, DWORD PTR [esi+24]

; 5630 :     if (nodes != NULL) {

	test	eax, eax
	je	SHORT $LN15@xmlRelaxNG

; 5631 :         xmlRngPErr(ctxt, nodes, XML_RNGP_START_CONTENT,

	push	0
	push	0
	push	OFFSET ??_C@_0BO@LLNPKKPG@start?5more?5than?5one?5children?6@
	push	1105					; 00000451H
	push	eax
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN26@xmlRelaxNG:

; 5632 :                    "start more than one children\n", NULL, NULL);
; 5633 :         return (-1);

	pop	edi
	pop	ebx
	or	eax, -1
	pop	esi

; 5636 : }

	pop	ebp
	ret	0
$LN15@xmlRelaxNG:
	pop	edi
	pop	ebx

; 5634 :     }
; 5635 :     return (ret);

	xor	eax, eax
	pop	esi

; 5636 : }

	pop	ebp
	ret	0
_xmlRelaxNGParseStart ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParseExceptNameClass
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_ret$1$ = 12						; size = 4
_node$ = 12						; size = 4
_attr$ = 16						; size = 4
_xmlRelaxNGParseExceptNameClass PROC			; COMDAT

; 5225 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	xor	ebx, ebx
	test	esi, esi
	je	$LN5@xmlRelaxNG

; 5226 :     xmlRelaxNGDefinePtr ret, cur, last = NULL;
; 5227 :     xmlNodePtr child;
; 5228 : 
; 5229 :     if (!IS_RELAXNG(node, "except")) {

	cmp	DWORD PTR [esi+36], ebx
	je	$LN5@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	$LN5@xmlRelaxNG
	push	OFFSET ??_C@_06JBKEBCGB@except@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN5@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN5@xmlRelaxNG

; 5230 :         xmlRngPErr(ctxt, node, XML_RNGP_EXCEPT_MISSING,
; 5231 :                    "Expecting an except node\n", NULL, NULL);
; 5232 :         return (NULL);
; 5233 :     }
; 5234 :     if (node->next != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+24], ebx
	je	SHORT $LN6@xmlRelaxNG

; 5235 :         xmlRngPErr(ctxt, node, XML_RNGP_EXCEPT_MULTIPLE,

	push	ebx
	push	ebx
	push	OFFSET ??_C@_0DC@LBJNBDAD@exceptNameClass?5allows?5only?5a?5s@
	push	1029					; 00000405H
	push	esi
	push	eax
	call	_xmlRngPErr
	mov	eax, DWORD PTR _ctxt$[ebp]
	add	esp, 24					; 00000018H
$LN6@xmlRelaxNG:

; 5236 :                    "exceptNameClass allows only a single except node\n",
; 5237 :                    NULL, NULL);
; 5238 :     }
; 5239 :     if (node->children == NULL) {

	cmp	DWORD PTR [esi+12], ebx
	jne	SHORT $LN7@xmlRelaxNG

; 5240 :         xmlRngPErr(ctxt, node, XML_RNGP_EXCEPT_EMPTY, "except has no content\n",

	push	0
	push	0
	push	OFFSET ??_C@_0BH@BGPIOKNJ@except?5has?5no?5content?6@
	push	1027					; 00000403H
	push	esi
	push	eax
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 5268 :     }
; 5269 : 
; 5270 :     return (ret);
; 5271 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlRelaxNG:

; 5241 :                    NULL, NULL);
; 5242 :         return (NULL);
; 5243 :     }
; 5244 : 
; 5245 :     ret = xmlRelaxNGNewDefine(ctxt, node);

	push	esi
	push	eax
	call	_xmlRelaxNGNewDefine
	add	esp, 8
	mov	DWORD PTR _ret$1$[ebp], eax

; 5246 :     if (ret == NULL)

	test	eax, eax
	je	$LN76@xmlRelaxNG

; 5247 :         return (NULL);
; 5248 :     ret->type = XML_RELAXNG_EXCEPT;

	mov	DWORD PTR [eax], 2

; 5249 :     child = node->children;

	mov	edi, DWORD PTR [esi+12]

; 5250 :     while (child != NULL) {

	test	edi, edi
	je	$LN1@xmlRelaxNG
	npad	1
$LL2@xmlRelaxNG:

; 5251 :         cur = xmlRelaxNGNewDefine(ctxt, child);

	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGNewDefine
	mov	esi, eax
	add	esp, 8

; 5252 :         if (cur == NULL)

	test	esi, esi
	je	SHORT $LN75@xmlRelaxNG

; 5253 :             break;
; 5254 :         if (attr)
; 5255 :             cur->type = XML_RELAXNG_ATTRIBUTE;
; 5256 :         else
; 5257 :             cur->type = XML_RELAXNG_ELEMENT;
; 5258 : 
; 5259 :         if (xmlRelaxNGParseNameClass(ctxt, child, cur) != NULL) {

	cmp	DWORD PTR _attr$[ebp], 0
	mov	eax, 4
	push	esi
	mov	ecx, 9
	push	edi
	push	DWORD PTR _ctxt$[ebp]
	cmove	ecx, eax
	mov	DWORD PTR [esi], ecx
	call	_xmlRelaxNGParseNameClass
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN12@xmlRelaxNG

; 5260 :             if (last == NULL) {

	test	ebx, ebx
	jne	SHORT $LN13@xmlRelaxNG

; 5261 :                 ret->content = cur;

	mov	eax, DWORD PTR _ret$1$[ebp]
	mov	DWORD PTR [eax+24], esi

; 5262 :             } else {

	jmp	SHORT $LN14@xmlRelaxNG
$LN13@xmlRelaxNG:

; 5263 :                 last->next = cur;

	mov	DWORD PTR [ebx+32], esi
$LN14@xmlRelaxNG:

; 5264 :             }
; 5265 :             last = cur;

	mov	ebx, esi
$LN12@xmlRelaxNG:

; 5266 :         }
; 5267 :         child = child->next;

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	SHORT $LL2@xmlRelaxNG
$LN75@xmlRelaxNG:
	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 5268 :     }
; 5269 : 
; 5270 :     return (ret);
; 5271 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlRelaxNG:

; 519  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	xor	edx, edx
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN17@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN19@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [eax+4]
$LN19@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	edi, DWORD PTR [eax]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [eax+36]
$LN17@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	0
	push	OFFSET ??_C@_0BK@FIOBKDGD@Expecting?5an?5except?5node?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1028					; 00000404H
	push	18					; 00000012H
	push	esi
	push	0
	push	edi
	push	edx
	push	ecx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN76@xmlRelaxNG:

; 5268 :     }
; 5269 : 
; 5270 :     return (ret);
; 5271 : }

	xor	eax, eax
$LN1@xmlRelaxNG:
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlRelaxNGParseExceptNameClass ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGProcessExternalRef
_TEXT	SEGMENT
_def$1$ = -12						; size = 4
_newNs$1$ = -8						; size = 4
_root$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_docu$1$ = 12						; size = 4
_node$ = 12						; size = 4
_xmlRelaxNGProcessExternalRef PROC			; COMDAT

; 4754 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	mov	DWORD PTR _newNs$1$[ebp], 0
	mov	ebx, DWORD PTR [esi+52]
	mov	DWORD PTR _docu$1$[ebp], ebx
	test	ebx, ebx
	je	$LN4@xmlRelaxNG

; 4755 :     xmlRelaxNGDocumentPtr docu;
; 4756 :     xmlNodePtr root, tmp;
; 4757 :     xmlChar *ns;
; 4758 :     int newNs = 0, oldflags;
; 4759 :     xmlRelaxNGDefinePtr def;
; 4760 : 
; 4761 :     docu = node->psvi;
; 4762 :     if (docu != NULL) {
; 4763 :         def = xmlRelaxNGNewDefine(ctxt, node);

	mov	edi, DWORD PTR _ctxt$[ebp]
	push	esi
	push	edi
	call	_xmlRelaxNGNewDefine
	add	esp, 8
	mov	DWORD PTR _def$1$[ebp], eax

; 4764 :         if (def == NULL)

	test	eax, eax
	je	SHORT $LN113@xmlRelaxNG

; 4765 :             return (NULL);
; 4766 :         def->type = XML_RELAXNG_EXTERNALREF;

	mov	DWORD PTR [eax], 12			; 0000000cH

; 4767 : 
; 4768 :         if (docu->content == NULL) {

	cmp	DWORD PTR [ebx+12], 0
	jne	$LN15@xmlRelaxNG

; 4769 :             /*
; 4770 :              * Then do the parsing for good
; 4771 :              */
; 4772 :             root = xmlDocGetRootElement(docu->doc);

	push	DWORD PTR [ebx+8]
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$1$[ebp], eax

; 4773 :             if (root == NULL) {

	test	eax, eax
	jne	SHORT $LN8@xmlRelaxNG

; 4774 :                 xmlRngPErr(ctxt, node, XML_RNGP_EXTERNALREF_EMTPY,

	push	eax
	push	DWORD PTR [edi+68]
	push	OFFSET ??_C@_0BO@JMOIDLLM@xmlRelaxNGParse?3?5?$CFs?5is?5empty?6@
	push	1031					; 00000407H
	push	esi
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN113@xmlRelaxNG:

; 4825 :     }
; 4826 :     return (def);
; 4827 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlRelaxNG:

; 4775 :                            "xmlRelaxNGParse: %s is empty\n", ctxt->URL,
; 4776 :                            NULL);
; 4777 :                 return (NULL);
; 4778 :             }
; 4779 :             /*
; 4780 :              * ns transmission rules
; 4781 :              */
; 4782 :             ns = xmlGetProp(root, BAD_CAST "ns");

	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	eax
	call	_xmlGetProp
	add	esp, 8

; 4783 :             if (ns == NULL) {

	test	eax, eax
	jne	$LN9@xmlRelaxNG
$LL2@xmlRelaxNG:

; 4784 :                 tmp = node;
; 4785 :                 while ((tmp != NULL) && (tmp->type == XML_ELEMENT_NODE)) {

	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN111@xmlRelaxNG

; 4786 :                     ns = xmlGetProp(tmp, BAD_CAST "ns");

	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	esi
	call	_xmlGetProp
	mov	ebx, eax
	add	esp, 8

; 4787 :                     if (ns != NULL) {

	test	ebx, ebx
	jne	$LN110@xmlRelaxNG

; 4788 :                         break;
; 4789 :                     }
; 4790 :                     tmp = tmp->parent;

	mov	esi, DWORD PTR [esi+20]
	test	esi, esi
	jne	SHORT $LL2@xmlRelaxNG
$LN111@xmlRelaxNG:

; 4799 :             }
; 4800 : 
; 4801 :             /*
; 4802 :              * Parsing to get a precompiled schemas.
; 4803 :              */
; 4804 :             oldflags = ctxt->flags;

	mov	ebx, DWORD PTR _docu$1$[ebp]
$LN10@xmlRelaxNG:
	mov	esi, DWORD PTR [edi+32]

; 4805 :             ctxt->flags |= XML_RELAXNG_IN_EXTERNALREF;

	mov	eax, esi

; 4806 :             docu->schema = xmlRelaxNGParseDocument(ctxt, root);

	push	DWORD PTR _root$1$[ebp]
	or	eax, 128				; 00000080H
	push	edi
	mov	DWORD PTR [edi+32], eax
	call	_xmlRelaxNGParseDocument
	mov	DWORD PTR [ebx+16], eax
	add	esp, 8

; 4807 :             ctxt->flags = oldflags;

	mov	DWORD PTR [edi+32], esi

; 4808 :             if ((docu->schema != NULL) &&

	mov	esi, DWORD PTR [ebx+16]
	test	esi, esi
	je	$LN100@xmlRelaxNG
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	$LN100@xmlRelaxNG

; 4809 :                 (docu->schema->topgrammar != NULL)) {
; 4810 :                 docu->content = docu->schema->topgrammar->start;

	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ebx+12], eax

; 4811 :                 if (docu->schema->topgrammar->refs)

	mov	esi, DWORD PTR [esi+4]
	cmp	DWORD PTR [esi+28], 0
	je	$LN100@xmlRelaxNG

; 4728 :     if ((ctxt == NULL) || (grammar == NULL) || (ctxt->grammar == NULL))

	test	esi, esi
	je	$LN100@xmlRelaxNG
	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN100@xmlRelaxNG

; 4729 :         return(-1);
; 4730 :     if (grammar->refs == NULL)
; 4731 :         return(0);
; 4732 :     if (ctxt->grammar->refs == NULL)

	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN103@xmlRelaxNG

; 4733 :         ctxt->grammar->refs = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	mov	ecx, DWORD PTR [edi+24]
	add	esp, 4
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR [edi+24]

; 4734 :     if (ctxt->grammar->refs == NULL) {

	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN103@xmlRelaxNG

; 4735 :         xmlRngPErr(ctxt, NULL, XML_RNGP_REF_CREATE_FAILED,

	push	0
	push	0
	push	OFFSET ??_C@_0CC@NOKALBCN@Could?5not?5create?5references?5has@
	push	1098					; 0000044aH
	push	0
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 4736 :                    "Could not create references hash\n", NULL, NULL);
; 4737 :         return(-1);

	jmp	SHORT $LN100@xmlRelaxNG
$LN110@xmlRelaxNG:

; 4791 :                 }
; 4792 :                 if (ns != NULL) {
; 4793 :                     xmlSetProp(root, BAD_CAST "ns", ns);

	push	ebx
	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	DWORD PTR _root$1$[ebp]
	call	_xmlSetProp

; 4794 :                     newNs = 1;
; 4795 :                     xmlFree(ns);

	push	ebx
	mov	DWORD PTR _newNs$1$[ebp], 1
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H

; 4796 :                 }
; 4797 :             } else {

	jmp	$LN111@xmlRelaxNG
$LN9@xmlRelaxNG:

; 4798 :                 xmlFree(ns);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	jmp	$LN10@xmlRelaxNG
$LN103@xmlRelaxNG:

; 4739 :     xmlHashScan(grammar->refs, xmlRelaxNGParseImportRef, ctxt);

	push	edi
	push	OFFSET _xmlRelaxNGParseImportRef
	push	DWORD PTR [esi+28]
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN100@xmlRelaxNG:

; 4812 :                     xmlRelaxNGParseImportRefs(ctxt, docu->schema->topgrammar);
; 4813 :             }
; 4814 : 
; 4815 :             /*
; 4816 :              * the externalRef may be reused in a different ns context
; 4817 :              */
; 4818 :             if (newNs == 1) {

	cmp	DWORD PTR _newNs$1$[ebp], 1
	jne	SHORT $LN15@xmlRelaxNG

; 4819 :                 xmlUnsetProp(root, BAD_CAST "ns");

	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	DWORD PTR _root$1$[ebp]
	call	_xmlUnsetProp
	add	esp, 8
$LN15@xmlRelaxNG:

; 4820 :             }
; 4821 :         }
; 4822 :         def->content = docu->content;

	mov	ecx, DWORD PTR _def$1$[ebp]
	mov	eax, DWORD PTR [ebx+12]
	pop	edi

; 4825 :     }
; 4826 :     return (def);
; 4827 : }

	pop	esi
	mov	DWORD PTR [ecx+24], eax
	mov	eax, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlRelaxNG:
	pop	edi

; 4823 :     } else {
; 4824 :         def = NULL;

	xor	ecx, ecx

; 4825 :     }
; 4826 :     return (def);
; 4827 : }

	pop	esi
	mov	eax, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGProcessExternalRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParseImportRefs
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_grammar$ = 12						; size = 4
_xmlRelaxNGParseImportRefs PROC				; COMDAT

; 4727 :                           xmlRelaxNGGrammarPtr grammar) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlRelaxNG

; 4728 :     if ((ctxt == NULL) || (grammar == NULL) || (ctxt->grammar == NULL))

	mov	edi, DWORD PTR _grammar$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlRelaxNG
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG

; 4729 :         return(-1);
; 4730 :     if (grammar->refs == NULL)

	cmp	DWORD PTR [edi+28], 0
	je	SHORT $LN9@xmlRelaxNG

; 4731 :         return(0);
; 4732 :     if (ctxt->grammar->refs == NULL)

	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN6@xmlRelaxNG

; 4733 :         ctxt->grammar->refs = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	mov	ecx, DWORD PTR [esi+24]
	add	esp, 4
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR [esi+24]

; 4734 :     if (ctxt->grammar->refs == NULL) {

	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN6@xmlRelaxNG

; 4735 :         xmlRngPErr(ctxt, NULL, XML_RNGP_REF_CREATE_FAILED,

	push	0
	push	0
	push	OFFSET ??_C@_0CC@NOKALBCN@Could?5not?5create?5references?5has@
	push	1098					; 0000044aH
	push	0
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN3@xmlRelaxNG:

; 4740 :     return(0);
; 4741 : }

	pop	edi
	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN6@xmlRelaxNG:

; 4736 :                    "Could not create references hash\n", NULL, NULL);
; 4737 :         return(-1);
; 4738 :     }
; 4739 :     xmlHashScan(grammar->refs, xmlRelaxNGParseImportRef, ctxt);

	push	esi
	push	OFFSET _xmlRelaxNGParseImportRef
	push	DWORD PTR [edi+28]
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN9@xmlRelaxNG:

; 4740 :     return(0);
; 4741 : }

	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
_xmlRelaxNGParseImportRefs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParseImportRef
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlRelaxNGParseImportRef PROC				; COMDAT

; 4686 : xmlRelaxNGParseImportRef(void *payload, void *data, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _payload$[ebp]
	mov	eax, 256				; 00000100H
	mov	edi, DWORD PTR _data$[ebp]
	push	esi
	push	DWORD PTR _name$[ebp]
	or	WORD PTR [esi+50], ax
	mov	eax, DWORD PTR [edi+24]
	push	DWORD PTR [eax+28]
	call	_xmlHashAddEntry
	add	esp, 12					; 0000000cH
	test	eax, eax
	jns	SHORT $LN4@xmlRelaxNG

; 4687 :     xmlRelaxNGParserCtxtPtr ctxt = (xmlRelaxNGParserCtxtPtr) data;
; 4688 :     xmlRelaxNGDefinePtr def = (xmlRelaxNGDefinePtr) payload;
; 4689 :     int tmp;
; 4690 : 
; 4691 :     def->dflags |= IS_EXTERNAL_REF;
; 4692 : 
; 4693 :     tmp = xmlHashAddEntry(ctxt->grammar->refs, name, def);
; 4694 :     if (tmp < 0) {
; 4695 :         xmlRelaxNGDefinePtr prev;
; 4696 : 
; 4697 :         prev = (xmlRelaxNGDefinePtr)

	mov	eax, DWORD PTR [edi+24]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [eax+28]
	call	_xmlHashLookup
	mov	ecx, eax
	add	esp, 8

; 4698 :             xmlHashLookup(ctxt->grammar->refs, def->name);
; 4699 :         if (prev == NULL) {

	test	ecx, ecx
	jne	SHORT $LN3@xmlRelaxNG

; 4700 :             if (def->name != NULL) {

	mov	ecx, DWORD PTR [esi+8]

; 4701 :                 xmlRngPErr(ctxt, NULL, XML_RNGP_REF_CREATE_FAILED,
; 4702 :                            "Error refs definitions '%s'\n",
; 4703 :                            def->name, NULL);
; 4704 :             } else {
; 4705 :                 xmlRngPErr(ctxt, NULL, XML_RNGP_REF_CREATE_FAILED,
; 4706 :                            "Error refs definitions\n",
; 4707 :                            NULL, NULL);
; 4708 :             }
; 4709 :         } else {

	mov	edx, OFFSET ??_C@_0BN@KBAJDCGM@Error?5refs?5definitions?5?8?$CFs?8?6@
	push	eax
	push	ecx
	test	ecx, ecx
	mov	eax, OFFSET ??_C@_0BI@KAJIFPGI@Error?5refs?5definitions?6@
	cmovne	eax, edx
	push	eax
	push	1098					; 0000044aH
	push	0
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
	pop	edi

; 4712 :         }
; 4713 :     }
; 4714 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 4710 :             def->nextHash = prev->nextHash;

	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [esi+44], eax

; 4711 :             prev->nextHash = def;

	mov	DWORD PTR [ecx+44], esi
$LN4@xmlRelaxNG:

; 4712 :         }
; 4713 :     }
; 4714 : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlRelaxNGParseImportRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParseDefine
_TEXT	SEGMENT
_def$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlRelaxNGParseDefine PROC				; COMDAT

; 4616 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	esi
	call	_xmlGetProp
	mov	ebx, eax
	add	esp, 8
	test	ebx, ebx
	jne	SHORT $LN4@xmlRelaxNG

; 519  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	xor	edx, edx
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN18@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN20@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [eax+4]
$LN20@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	edi, DWORD PTR [eax]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [eax+36]
$LN18@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	0
	push	OFFSET ??_C@_0BE@OMGBAGKJ@define?5has?5no?5name?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1014					; 000003f6H
	push	18					; 00000012H
	push	esi
	push	0
	push	edi
	push	edx
	push	ecx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 4657 :             if (tmp < 0) {

	xor	eax, eax
	pop	edi

; 4670 :                 }
; 4671 :             }
; 4672 :         }
; 4673 :     }
; 4674 :     return (ret);
; 4675 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlRelaxNG:

; 4617 :     xmlChar *name;
; 4618 :     int ret = 0, tmp;
; 4619 :     xmlRelaxNGDefinePtr def;
; 4620 :     const xmlChar *olddefine;
; 4621 : 
; 4622 :     name = xmlGetProp(node, BAD_CAST "name");
; 4623 :     if (name == NULL) {
; 4624 :         xmlRngPErr(ctxt, node, XML_RNGP_DEFINE_NAME_MISSING,
; 4625 :                    "define has no name\n", NULL, NULL);
; 4626 :     } else {
; 4627 :         xmlRelaxNGNormExtSpace(name);

	push	ebx
	call	_xmlRelaxNGNormExtSpace

; 4628 :         if (xmlValidateNCName(name, 0)) {

	push	0
	push	ebx
	call	_xmlValidateNCName
	mov	edi, DWORD PTR _ctxt$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG

; 4629 :             xmlRngPErr(ctxt, node, XML_RNGP_INVALID_DEFINE_NAME,

	push	0
	push	ebx
	push	OFFSET ??_C@_0CD@LEKDIHDI@define?5name?5?8?$CFs?8?5is?5not?5an?5NCNa@
	push	1049					; 00000419H
	push	esi
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN6@xmlRelaxNG:

; 4630 :                        "define name '%s' is not an NCName\n", name, NULL);
; 4631 :         }
; 4632 :         def = xmlRelaxNGNewDefine(ctxt, node);

	push	esi
	push	edi
	call	_xmlRelaxNGNewDefine
	add	esp, 8
	mov	DWORD PTR _def$1$[ebp], eax

; 4633 :         if (def == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlRelaxNG

; 4634 :             xmlFree(name);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 4635 :             return (-1);

	or	eax, -1
	pop	edi

; 4670 :                 }
; 4671 :             }
; 4672 :         }
; 4673 :     }
; 4674 :     return (ret);
; 4675 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlRelaxNG:

; 4636 :         }
; 4637 :         def->type = XML_RELAXNG_DEF;

	mov	DWORD PTR [eax], 10			; 0000000aH

; 4638 :         def->name = name;

	mov	DWORD PTR [eax+8], ebx

; 4639 :         if (node->children == NULL) {

	cmp	DWORD PTR [esi+12], 0
	push	0
	jne	SHORT $LN8@xmlRelaxNG

; 4640 :             xmlRngPErr(ctxt, node, XML_RNGP_DEFINE_EMPTY,

	push	0
	push	OFFSET ??_C@_0BI@KMIJHMFO@define?5has?5no?5children?6@
	push	1012					; 000003f4H
	push	esi
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 4641 :                        "define has no children\n", NULL, NULL);
; 4642 :         } else {

	jmp	SHORT $LN9@xmlRelaxNG
$LN8@xmlRelaxNG:

; 4643 :             olddefine = ctxt->define;
; 4644 :             ctxt->define = name;
; 4645 :             def->content =

	mov	eax, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [edi+44]
	mov	DWORD PTR [edi+44], ebx
	push	DWORD PTR [eax+12]
	push	edi
	call	_xmlRelaxNGParsePatterns
	mov	ecx, DWORD PTR _def$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+24], eax

; 4646 :                 xmlRelaxNGParsePatterns(ctxt, node->children, 0);
; 4647 :             ctxt->define = olddefine;

	mov	DWORD PTR [edi+44], esi
	mov	esi, DWORD PTR _node$[ebp]
$LN9@xmlRelaxNG:

; 4648 :         }
; 4649 :         if (ctxt->grammar->defs == NULL)

	mov	eax, DWORD PTR [edi+24]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN10@xmlRelaxNG

; 4650 :             ctxt->grammar->defs = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	mov	ecx, DWORD PTR [edi+24]
	add	esp, 4
	mov	DWORD PTR [ecx+24], eax
	mov	eax, DWORD PTR [edi+24]
$LN10@xmlRelaxNG:

; 4651 :         if (ctxt->grammar->defs == NULL) {

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LN11@xmlRelaxNG

; 4652 :             xmlRngPErr(ctxt, node, XML_RNGP_DEFINE_CREATE_FAILED,

	push	eax
	push	eax
	push	OFFSET ??_C@_0CC@EGGMPODH@Could?5not?5create?5definition?5has@

; 4653 :                        "Could not create definition hash\n", NULL, NULL);
; 4654 :             ret = -1;
; 4655 :         } else {

	jmp	SHORT $LN27@xmlRelaxNG
$LN11@xmlRelaxNG:

; 4656 :             tmp = xmlHashAddEntry(ctxt->grammar->defs, name, def);

	push	DWORD PTR _def$1$[ebp]
	push	ebx
	push	eax
	call	_xmlHashAddEntry
	add	esp, 12					; 0000000cH

; 4657 :             if (tmp < 0) {

	test	eax, eax
	jns	SHORT $LN26@xmlRelaxNG

; 4658 :                 xmlRelaxNGDefinePtr prev;
; 4659 : 
; 4660 :                 prev = xmlHashLookup(ctxt->grammar->defs, name);

	mov	eax, DWORD PTR [edi+24]
	push	ebx
	push	DWORD PTR [eax+24]
	call	_xmlHashLookup
	mov	ecx, eax
	add	esp, 8

; 4661 :                 if (prev == NULL) {

	test	ecx, ecx
	jne	SHORT $LN22@xmlRelaxNG

; 4662 :                     xmlRngPErr(ctxt, node, XML_RNGP_DEFINE_CREATE_FAILED,

	push	eax
	push	ebx
	push	OFFSET ??_C@_0CM@PJMCGFMO@Internal?5error?5on?5define?5aggreg@
$LN27@xmlRelaxNG:

; 4670 :                 }
; 4671 :             }
; 4672 :         }
; 4673 :     }
; 4674 :     return (ret);
; 4675 : }

	push	1011					; 000003f3H
	push	esi
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@xmlRelaxNG:

; 4663 :                                "Internal error on define aggregation of %s\n",
; 4664 :                                name, NULL);
; 4665 :                     ret = -1;
; 4666 :                 } else {
; 4667 :                     while (prev->nextHash != NULL)

	mov	eax, DWORD PTR [ecx+44]
	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG
$LL2@xmlRelaxNG:

; 4668 :                         prev = prev->nextHash;

	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+44]
	test	eax, eax
	jne	SHORT $LL2@xmlRelaxNG
$LN3@xmlRelaxNG:

; 4669 :                     prev->nextHash = def;

	mov	eax, DWORD PTR _def$1$[ebp]
	mov	DWORD PTR [ecx+44], eax
$LN26@xmlRelaxNG:

; 4670 :                 }
; 4671 :             }
; 4672 :         }
; 4673 :     }
; 4674 :     return (ret);
; 4675 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGParseDefine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParseInclude
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlRelaxNGParseInclude PROC				; COMDAT

; 4566 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _node$[ebp]
	xor	esi, esi
	mov	eax, DWORD PTR [edi+52]
	test	eax, eax
	jne	SHORT $LN2@xmlRelaxNG

; 519  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	xor	edx, edx
	test	eax, eax
	je	SHORT $LN11@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN13@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [eax+4]
$LN13@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	esi, DWORD PTR [eax]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [eax+36]
$LN11@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	0
	push	OFFSET ??_C@_0BK@PJHELFJE@Include?5node?5has?5no?5data?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1042					; 00000412H
	push	18					; 00000012H
	push	edi
	push	0
	push	esi
	push	edx
	push	ecx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 4567 :     xmlRelaxNGIncludePtr incl;
; 4568 :     xmlNodePtr root;
; 4569 :     int ret = 0, tmp;
; 4570 : 
; 4571 :     incl = node->psvi;
; 4572 :     if (incl == NULL) {
; 4573 :         xmlRngPErr(ctxt, node, XML_RNGP_INCLUDE_EMPTY,
; 4574 :                    "Include node has no data\n", NULL, NULL);
; 4575 :         return (-1);

	or	eax, -1
	pop	edi

; 4603 : }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlRelaxNG:
	push	ebx

; 4576 :     }
; 4577 :     root = xmlDocGetRootElement(incl->doc);

	push	DWORD PTR [eax+8]
	call	_xmlDocGetRootElement
	mov	ebx, eax
	add	esp, 4

; 4578 :     if (root == NULL) {

	test	ebx, ebx
	jne	SHORT $LN3@xmlRelaxNG

; 4579 :         xmlRngPErr(ctxt, node, XML_RNGP_EMPTY, "Include document is empty\n",

	push	eax
	push	eax
	push	OFFSET ??_C@_0BL@NJFOGBOE@Include?5document?5is?5empty?6@
	push	1022					; 000003feH
	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 4580 :                    NULL, NULL);
; 4581 :         return (-1);

	or	eax, -1
	pop	ebx
	pop	edi

; 4603 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 4582 :     }
; 4583 :     if (!xmlStrEqual(root->name, BAD_CAST "grammar")) {

	push	OFFSET ??_C@_07EFOLCII@grammar@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@xmlRelaxNG

; 4584 :         xmlRngPErr(ctxt, node, XML_RNGP_GRAMMAR_MISSING,

	push	eax
	push	eax
	push	OFFSET ??_C@_0CI@GFEIPOEG@Include?5document?5root?5is?5not?5a?5@
	push	1038					; 0000040eH
	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 4585 :                    "Include document root is not a grammar\n", NULL, NULL);
; 4586 :         return (-1);

	or	eax, -1
	pop	ebx
	pop	edi

; 4603 : }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlRelaxNG:

; 4587 :     }
; 4588 : 
; 4589 :     /*
; 4590 :      * Merge the definition from both the include and the internal list
; 4591 :      */
; 4592 :     if (root->children != NULL) {

	mov	eax, DWORD PTR [ebx+12]
	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG

; 4593 :         tmp = xmlRelaxNGParseGrammarContent(ctxt, root->children);

	push	eax
	push	ebx
	call	_xmlRelaxNGParseGrammarContent
	add	esp, 8

; 4594 :         if (tmp != 0)

	test	eax, eax
	mov	eax, -1
	cmovne	esi, eax
$LN6@xmlRelaxNG:

; 4595 :             ret = -1;
; 4596 :     }
; 4597 :     if (node->children != NULL) {

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN8@xmlRelaxNG

; 4598 :         tmp = xmlRelaxNGParseGrammarContent(ctxt, node->children);

	push	eax
	push	ebx
	call	_xmlRelaxNGParseGrammarContent
	add	esp, 8

; 4599 :         if (tmp != 0)

	test	eax, eax
	mov	eax, -1
	cmovne	esi, eax
$LN8@xmlRelaxNG:

; 4600 :             ret = -1;
; 4601 :     }
; 4602 :     return (ret);

	pop	ebx
	pop	edi
	mov	eax, esi

; 4603 : }

	pop	esi
	pop	ebp
	ret	0
_xmlRelaxNGParseInclude ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParseInterleave
_TEXT	SEGMENT
_name$1 = -36						; size = 32
_def$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlRelaxNGParseInterleave PROC				; COMDAT

; 4504 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _node$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	push	edi
	call	_xmlRelaxNGNewDefine
	mov	esi, eax
	add	esp, 8
	mov	DWORD PTR _def$1$[ebp], esi
	test	esi, esi
	jne	SHORT $LN4@xmlRelaxNG

; 4553 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlRelaxNG:

; 4505 :     xmlRelaxNGDefinePtr def = NULL;
; 4506 :     xmlRelaxNGDefinePtr last = NULL, cur;
; 4507 :     xmlNodePtr child;
; 4508 : 
; 4509 :     def = xmlRelaxNGNewDefine(ctxt, node);
; 4510 :     if (def == NULL) {
; 4511 :         return (NULL);
; 4512 :     }
; 4513 :     def->type = XML_RELAXNG_INTERLEAVE;

	mov	DWORD PTR [esi], 19			; 00000013H

; 4514 : 
; 4515 :     if (ctxt->interleaves == NULL)

	mov	eax, DWORD PTR [edi+56]
	test	eax, eax
	jne	SHORT $LN6@xmlRelaxNG

; 4516 :         ctxt->interleaves = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [edi+56], eax

; 4517 :     if (ctxt->interleaves == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlRelaxNG

; 445  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [edi+12]
	test	ecx, ecx
	jne	SHORT $LN19@xmlRelaxNG

; 446  : 	    schannel = ctxt->serror;
; 447  : 	else
; 448  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [edi+4]
$LN19@xmlRelaxNG:

; 449  :         data = ctxt->userData;
; 450  :         ctxt->nbErrors++;
; 451  :     }
; 452  :     if (extra)
; 453  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BE@JIDAHLJE@create?5interleaves?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [edi+36]
	push	OFFSET ??_C@_0BE@JIDAHLJE@create?5interleaves?6@
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	DWORD PTR [edi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 4518 :         xmlRngPErrMemory(ctxt, "create interleaves\n");
; 4519 :     } else {

	jmp	SHORT $LN8@xmlRelaxNG
$LN6@xmlRelaxNG:

; 4520 :         char name[32];
; 4521 : 
; 4522 :         snprintf(name, 32, "interleave%d", ctxt->nbInterleaves++);

	mov	ecx, DWORD PTR [edi+52]
	push	ecx
	push	OFFSET ??_C@_0N@MHPBOBHE@interleave?$CFd@
	push	32					; 00000020H
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [edi+52], eax
	lea	eax, DWORD PTR _name$1[ebp]
	push	eax
	call	_snprintf

; 4523 :         if (xmlHashAddEntry(ctxt->interleaves, BAD_CAST name, def) < 0) {

	push	esi
	lea	eax, DWORD PTR _name$1[ebp]
	push	eax
	push	DWORD PTR [edi+56]
	call	_xmlHashAddEntry
	add	esp, 28					; 0000001cH
	test	eax, eax
	jns	SHORT $LN8@xmlRelaxNG

; 4524 :             xmlRngPErr(ctxt, node, XML_RNGP_INTERLEAVE_ADD,

	push	0
	lea	eax, DWORD PTR _name$1[ebp]
	push	eax
	push	OFFSET ??_C@_0CA@BLFIOJCN@Failed?5to?5add?5?$CFs?5to?5hash?5table?6@
	push	1045					; 00000415H
	push	DWORD PTR _node$[ebp]
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN8@xmlRelaxNG:

; 4525 :                        "Failed to add %s to hash table\n",
; 4526 : 		       (const xmlChar *) name, NULL);
; 4527 :         }
; 4528 :     }
; 4529 :     child = node->children;

	mov	eax, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [eax+12]

; 4530 :     if (child == NULL) {

	test	esi, esi
	jne	SHORT $LN60@xmlRelaxNG

; 4531 :         xmlRngPErr(ctxt, node, XML_RNGP_INTERLEAVE_NO_CONTENT,

	push	esi
	push	esi
	push	OFFSET ??_C@_0BN@JGOKJKPH@Element?5interleave?5is?5empty?6@
	push	1048					; 00000418H
	push	eax
	push	edi
	call	_xmlRngPErr

; 4550 :     }
; 4551 : 
; 4552 :     return (def);

	mov	eax, DWORD PTR _def$1$[ebp]
	add	esp, 24					; 00000018H
	pop	edi

; 4553 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN60@xmlRelaxNG:

; 4532 :                    "Element interleave is empty\n", NULL, NULL);
; 4533 :     }
; 4534 :     while (child != NULL) {
; 4535 :         if (IS_RELAXNG(child, "element")) {

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN10@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN10@xmlRelaxNG
	push	OFFSET ??_C@_07HCLJNICE@element@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlRelaxNG

; 4536 :             cur = xmlRelaxNGParseElement(ctxt, child);

	push	esi
	push	edi
	call	_xmlRelaxNGParseElement

; 4537 :         } else {

	jmp	SHORT $LN61@xmlRelaxNG
$LN10@xmlRelaxNG:

; 4538 :             cur = xmlRelaxNGParsePattern(ctxt, child);

	push	esi
	push	edi
	call	_xmlRelaxNGParsePattern
$LN61@xmlRelaxNG:

; 4539 :         }
; 4540 :         if (cur != NULL) {

	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlRelaxNG

; 4541 :             cur->parent = def;

	mov	ecx, DWORD PTR _def$1$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 4542 :             if (last == NULL) {

	test	ebx, ebx
	jne	SHORT $LN13@xmlRelaxNG

; 4543 :                 def->content = last = cur;

	mov	DWORD PTR [ecx+24], eax

; 4544 :             } else {

	jmp	SHORT $LN62@xmlRelaxNG
$LN13@xmlRelaxNG:

; 4545 :                 last->next = cur;

	mov	DWORD PTR [ebx+32], eax
$LN62@xmlRelaxNG:

; 4546 :                 last = cur;
; 4547 :             }
; 4548 :         }
; 4549 :         child = child->next;

	mov	ebx, eax
$LN14@xmlRelaxNG:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LN60@xmlRelaxNG

; 4550 :     }
; 4551 : 
; 4552 :     return (def);

	mov	eax, DWORD PTR _def$1$[ebp]
	pop	edi

; 4553 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGParseInterleave ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGComputeInterleaves
_TEXT	SEGMENT
tv1385 = -36						; size = 4
tv1358 = -32						; size = 4
_group$1$ = -28						; size = 4
tv1359 = -24						; size = 4
_is_mixed$1$ = -20					; size = 4
_partitions$1$ = -16					; size = 4
_is_determinist$1$ = -12				; size = 4
_nbgroups$1$ = -8					; size = 4
_groups$1$ = -4						; size = 4
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlRelaxNGComputeInterleaves PROC			; COMDAT

; 4335 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _data$[ebp]
	xor	ecx, ecx
	xor	edi, edi
	mov	DWORD PTR _is_mixed$1$[ebp], ecx
	mov	ebx, 1
	mov	DWORD PTR _nbgroups$1$[ebp], edi
	mov	DWORD PTR _is_determinist$1$[ebp], ebx
	cmp	DWORD PTR [esi+36], ecx
	jne	$LN45@xmlRelaxNG

; 4336 :     xmlRelaxNGDefinePtr def = (xmlRelaxNGDefinePtr) payload;
; 4337 :     xmlRelaxNGParserCtxtPtr ctxt = (xmlRelaxNGParserCtxtPtr) data;
; 4338 :     xmlRelaxNGDefinePtr cur, *tmp;
; 4339 : 
; 4340 :     xmlRelaxNGPartitionPtr partitions = NULL;
; 4341 :     xmlRelaxNGInterleaveGroupPtr *groups = NULL;
; 4342 :     xmlRelaxNGInterleaveGroupPtr group;
; 4343 :     int i, j, ret, res;
; 4344 :     int nbgroups = 0;
; 4345 :     int nbchild = 0;
; 4346 :     int is_mixed = 0;
; 4347 :     int is_determinist = 1;
; 4348 : 
; 4349 :     /*
; 4350 :      * Don't run that check in case of error. Infinite recursion
; 4351 :      * becomes possible.
; 4352 :      */
; 4353 :     if (ctxt->nbErrors != 0)
; 4354 :         return;
; 4355 : 
; 4356 : #ifdef DEBUG_INTERLEAVE
; 4357 :     xmlGenericError(xmlGenericErrorContext,
; 4358 :                     "xmlRelaxNGComputeInterleaves(%s)\n", name);
; 4359 : #endif
; 4360 :     cur = def->content;

	mov	eax, DWORD PTR _payload$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 4361 :     while (cur != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG
	npad	5
$LL2@xmlRelaxNG:

; 4362 :         nbchild++;
; 4363 :         cur = cur->next;

	mov	eax, DWORD PTR [eax+32]
	inc	ecx
	test	eax, eax
	jne	SHORT $LL2@xmlRelaxNG
$LN3@xmlRelaxNG:

; 4364 :     }
; 4365 : 
; 4366 : #ifdef DEBUG_INTERLEAVE
; 4367 :     xmlGenericError(xmlGenericErrorContext, "  %d child\n", nbchild);
; 4368 : #endif
; 4369 :     groups = (xmlRelaxNGInterleaveGroupPtr *)

	lea	eax, DWORD PTR [ecx*4]
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _groups$1$[ebp], eax

; 4370 :         xmlMalloc(nbchild * sizeof(xmlRelaxNGInterleaveGroupPtr));
; 4371 :     if (groups == NULL)

	test	eax, eax
	je	$error$103

; 4372 :         goto error;
; 4373 :     cur = def->content;

	mov	eax, DWORD PTR _payload$[ebp]
	mov	edi, DWORD PTR [eax+24]

; 4374 :     while (cur != NULL) {

	test	edi, edi
	je	SHORT $LN5@xmlRelaxNG
	npad	2
$LL4@xmlRelaxNG:

; 4375 :         groups[nbgroups] = (xmlRelaxNGInterleaveGroupPtr)

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	edx, DWORD PTR _groups$1$[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR _nbgroups$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [edx+eax*4], ecx

; 4376 :             xmlMalloc(sizeof(xmlRelaxNGInterleaveGroup));
; 4377 :         if (groups[nbgroups] == NULL)

	test	ecx, ecx
	je	$LN97@xmlRelaxNG

; 4378 :             goto error;
; 4379 :         if (cur->type == XML_RELAXNG_TEXT)
; 4380 :             is_mixed++;
; 4381 :         groups[nbgroups]->rule = cur;

	mov	edx, DWORD PTR _is_mixed$1$[ebp]
	cmp	DWORD PTR [edi], 3

; 4382 :         groups[nbgroups]->defs = xmlRelaxNGGetElements(ctxt, cur, 2);

	push	2
	push	edi
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], edi
	cmovne	eax, edx
	push	esi
	mov	DWORD PTR _is_mixed$1$[ebp], eax
	call	_xmlRelaxNGGetElements
	mov	edx, DWORD PTR _groups$1$[ebp]
	mov	ecx, DWORD PTR _nbgroups$1$[ebp]

; 4383 :         groups[nbgroups]->attrs = xmlRelaxNGGetElements(ctxt, cur, 1);

	push	1
	push	edi
	push	esi
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+4], eax
	call	_xmlRelaxNGGetElements
	mov	edx, DWORD PTR _nbgroups$1$[ebp]
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _groups$1$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]

; 4384 :         nbgroups++;

	inc	edx
	mov	DWORD PTR _nbgroups$1$[ebp], edx
	mov	DWORD PTR [ecx+8], eax

; 4385 :         cur = cur->next;

	mov	edi, DWORD PTR [edi+32]
	test	edi, edi
	jne	SHORT $LL4@xmlRelaxNG

; 4376 :             xmlMalloc(sizeof(xmlRelaxNGInterleaveGroup));
; 4377 :         if (groups[nbgroups] == NULL)

	mov	eax, DWORD PTR _is_mixed$1$[ebp]
	mov	DWORD PTR _is_mixed$1$[ebp], eax
$LN5@xmlRelaxNG:

; 4386 :     }
; 4387 : #ifdef DEBUG_INTERLEAVE
; 4388 :     xmlGenericError(xmlGenericErrorContext, "  %d groups\n", nbgroups);
; 4389 : #endif
; 4390 : 
; 4391 :     /*
; 4392 :      * Let's check that all rules makes a partitions according to 7.4
; 4393 :      */
; 4394 :     partitions = (xmlRelaxNGPartitionPtr)

	push	16					; 00000010H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _partitions$1$[ebp], edi

; 4395 :         xmlMalloc(sizeof(xmlRelaxNGPartition));
; 4396 :     if (partitions == NULL)

	test	edi, edi
	je	$error$103

; 4399 :     partitions->nbgroups = nbgroups;

	mov	eax, DWORD PTR _nbgroups$1$[ebp]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [edi], xmm0
	mov	DWORD PTR [edi], eax

; 4400 :     partitions->triage = xmlHashCreate(nbgroups);

	mov	edi, eax
	push	edi
	call	_xmlHashCreate
	mov	edx, DWORD PTR _partitions$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [edx+4], eax

; 4401 :     for (i = 0; i < nbgroups; i++) {

	test	edi, edi
	jle	$LN7@xmlRelaxNG

; 4397 :         goto error;
; 4398 :     memset(partitions, 0, sizeof(xmlRelaxNGPartition));

	mov	eax, DWORD PTR _groups$1$[ebp]
	mov	ecx, ebx
	mov	DWORD PTR tv1359[ebp], ecx
	mov	DWORD PTR tv1358[ebp], eax
	mov	DWORD PTR tv1385[ebp], edi
$LL8@xmlRelaxNG:

; 4402 :         group = groups[i];

	mov	edi, ecx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _group$1$[ebp], eax

; 4403 :         for (j = i + 1; j < nbgroups; j++) {

	cmp	ecx, DWORD PTR _nbgroups$1$[ebp]
	jge	$LN10@xmlRelaxNG
	mov	ebx, eax
	npad	7
$LL11@xmlRelaxNG:

; 4404 :             if (groups[j] == NULL)

	mov	eax, DWORD PTR _groups$1$[ebp]
	mov	eax, DWORD PTR [eax+edi*4]
	test	eax, eax
	je	$LN9@xmlRelaxNG

; 4405 :                 continue;
; 4406 : 
; 4407 :             ret = xmlRelaxNGCompareElemDefLists(ctxt, group->defs,

	push	DWORD PTR [eax+4]
	push	DWORD PTR [ebx+4]
	push	esi
	call	_xmlRelaxNGCompareElemDefLists
	add	esp, 12					; 0000000cH

; 4408 :                                                 groups[j]->defs);
; 4409 :             if (ret == 0) {

	test	eax, eax
	jne	SHORT $LN50@xmlRelaxNG

; 4410 :                 xmlRngPErr(ctxt, def->node, XML_RNGP_ELEM_TEXT_CONFLICT,

	mov	eax, DWORD PTR _payload$[ebp]

; 520  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]

; 4410 :                 xmlRngPErr(ctxt, def->node, XML_RNGP_ELEM_TEXT_CONFLICT,

	mov	edx, DWORD PTR [eax+4]

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	eax, eax

; 517  :     void *data = NULL;
; 518  : 
; 519  :     if (ctxt != NULL) {
; 520  :         if (ctxt->serror != NULL)

	test	ecx, ecx
	jne	SHORT $LN95@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN95@xmlRelaxNG:

; 524  :         data = ctxt->userData;
; 525  :         ctxt->nbErrors++;
; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	0
	push	OFFSET ??_C@_0CJ@CIKEPODC@Element?5or?5text?5conflicts?5in?5in@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+36]
	push	0
	push	0
	push	0
	push	2
	push	1021					; 000003fdH
	push	18					; 00000012H
	push	edx
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN50@xmlRelaxNG:

; 4411 :                            "Element or text conflicts in interleave\n",
; 4412 :                            NULL, NULL);
; 4413 :             }
; 4414 :             ret = xmlRelaxNGCompareElemDefLists(ctxt, group->attrs,

	mov	eax, DWORD PTR _groups$1$[ebp]
	mov	eax, DWORD PTR [eax+edi*4]
	push	DWORD PTR [eax+8]
	push	DWORD PTR [ebx+8]
	push	esi
	call	_xmlRelaxNGCompareElemDefLists
	add	esp, 12					; 0000000cH

; 4415 :                                                 groups[j]->attrs);
; 4416 :             if (ret == 0) {

	test	eax, eax
	jne	SHORT $LN9@xmlRelaxNG

; 4417 :                 xmlRngPErr(ctxt, def->node, XML_RNGP_ATTR_CONFLICT,

	mov	eax, DWORD PTR _payload$[ebp]

; 520  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]

; 4417 :                 xmlRngPErr(ctxt, def->node, XML_RNGP_ATTR_CONFLICT,

	mov	edx, DWORD PTR [eax+4]

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	eax, eax

; 517  :     void *data = NULL;
; 518  : 
; 519  :     if (ctxt != NULL) {
; 520  :         if (ctxt->serror != NULL)

	test	ecx, ecx
	jne	SHORT $LN58@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN58@xmlRelaxNG:

; 524  :         data = ctxt->userData;
; 525  :         ctxt->nbErrors++;
; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	0
	push	OFFSET ??_C@_0CE@PJGIOECJ@Attributes?5conflicts?5in?5interle@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+36]
	push	0
	push	0
	push	0
	push	2
	push	1001					; 000003e9H
	push	18					; 00000012H
	push	edx
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN9@xmlRelaxNG:

; 4403 :         for (j = i + 1; j < nbgroups; j++) {

	inc	edi
	cmp	edi, DWORD PTR _nbgroups$1$[ebp]
	jl	$LL11@xmlRelaxNG
	mov	ebx, DWORD PTR _is_determinist$1$[ebp]
	mov	eax, DWORD PTR _group$1$[ebp]
	mov	ecx, DWORD PTR tv1359[ebp]
	mov	edx, DWORD PTR _partitions$1$[ebp]
$LN10@xmlRelaxNG:

; 4418 :                            "Attributes conflicts in interleave\n", NULL,
; 4419 :                            NULL);
; 4420 :             }
; 4421 :         }
; 4422 :         tmp = group->defs;

	mov	edi, DWORD PTR [eax+4]

; 4423 :         if ((tmp != NULL) && (*tmp != NULL)) {

	test	edi, edi
	je	$LN86@xmlRelaxNG
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	$LN86@xmlRelaxNG
	mov	esi, DWORD PTR tv1359[ebp]
$LL12@xmlRelaxNG:

; 4425 :                 if ((*tmp)->type == XML_RELAXNG_TEXT) {

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 3
	jne	SHORT $LN27@xmlRelaxNG

; 4426 :                     res = xmlHashAddEntry2(partitions->triage,

	push	esi
	push	0
	push	OFFSET ??_C@_05NOBOONOA@?$CDtext@
	push	DWORD PTR [edx+4]

; 4453 :                         is_determinist = 2;
; 4454 :                     if (res != 0)
; 4455 :                         is_determinist = -1;
; 4456 :                 } else {
; 4457 :                     is_determinist = -1;
; 4458 :                 }
; 4459 :                 tmp++;

	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
	jmp	SHORT $LN101@xmlRelaxNG
$LN27@xmlRelaxNG:

; 4427 :                                            BAD_CAST "#text", NULL,
; 4428 :                                            (void *) (ptrdiff_t) (i + 1));
; 4429 :                     if (res != 0)
; 4430 :                         is_determinist = -1;
; 4431 :                 } else if (((*tmp)->type == XML_RELAXNG_ELEMENT) &&

	cmp	ecx, 4
	jne	SHORT $LN36@xmlRelaxNG
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN30@xmlRelaxNG

; 4432 :                            ((*tmp)->name != NULL)) {
; 4433 :                     if (((*tmp)->ns == NULL) || ((*tmp)->ns[0] == 0))

	test	eax, eax
	je	SHORT $LN88@xmlRelaxNG
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN33@xmlRelaxNG
$LN88@xmlRelaxNG:

; 4434 :                         res = xmlHashAddEntry2(partitions->triage,

	xor	eax, eax
$LN33@xmlRelaxNG:

; 4435 :                                                (*tmp)->name, NULL,
; 4436 :                                                (void *) (ptrdiff_t) (i + 1));
; 4437 :                     else
; 4438 :                         res = xmlHashAddEntry2(partitions->triage,
; 4439 :                                                (*tmp)->name, (*tmp)->ns,
; 4440 :                                                (void *) (ptrdiff_t) (i + 1));
; 4441 :                     if (res != 0)

	push	esi
	push	eax
	mov	eax, DWORD PTR [edx+4]
	push	ecx
	push	eax

; 4453 :                         is_determinist = 2;
; 4454 :                     if (res != 0)
; 4455 :                         is_determinist = -1;
; 4456 :                 } else {
; 4457 :                     is_determinist = -1;
; 4458 :                 }
; 4459 :                 tmp++;

	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
	jmp	SHORT $LN101@xmlRelaxNG
$LN30@xmlRelaxNG:

; 4442 :                         is_determinist = -1;
; 4443 :                 } else if ((*tmp)->type == XML_RELAXNG_ELEMENT) {
; 4444 :                     if (((*tmp)->ns == NULL) || ((*tmp)->ns[0] == 0))

	test	eax, eax
	je	SHORT $LN96@xmlRelaxNG
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN39@xmlRelaxNG
$LN96@xmlRelaxNG:

; 4445 :                         res = xmlHashAddEntry2(partitions->triage,

	xor	eax, eax
$LN39@xmlRelaxNG:

; 4446 :                                                BAD_CAST "#any", NULL,
; 4447 :                                                (void *) (ptrdiff_t) (i + 1));
; 4448 :                     else
; 4449 :                         res = xmlHashAddEntry2(partitions->triage,
; 4450 :                                                BAD_CAST "#any", (*tmp)->ns,
; 4451 :                                                (void *) (ptrdiff_t) (i + 1));
; 4452 :                     if ((*tmp)->nameClass != NULL)

	push	esi
	push	eax
	mov	eax, DWORD PTR [edx+4]
	push	OFFSET ??_C@_04IAJCOJMF@?$CDany@
	push	eax
	call	_xmlHashAddEntry2
	mov	ecx, DWORD PTR [edi]
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [ecx+40], 0
	mov	ecx, 2
	cmovne	ebx, ecx
$LN101@xmlRelaxNG:

; 4453 :                         is_determinist = 2;
; 4454 :                     if (res != 0)
; 4455 :                         is_determinist = -1;
; 4456 :                 } else {
; 4457 :                     is_determinist = -1;
; 4458 :                 }
; 4459 :                 tmp++;

	test	eax, eax
	je	SHORT $LN37@xmlRelaxNG
$LN36@xmlRelaxNG:
	or	ebx, -1
$LN37@xmlRelaxNG:

; 4424 :             while (*tmp != NULL) {

	mov	eax, DWORD PTR [edi+4]

; 4453 :                         is_determinist = 2;
; 4454 :                     if (res != 0)
; 4455 :                         is_determinist = -1;
; 4456 :                 } else {
; 4457 :                     is_determinist = -1;
; 4458 :                 }
; 4459 :                 tmp++;

	add	edi, 4
	mov	edx, DWORD PTR _partitions$1$[ebp]
	test	eax, eax
	jne	$LL12@xmlRelaxNG

; 4460 :             }
; 4461 :         } else {

	mov	esi, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR tv1359[ebp]
	jmp	SHORT $LN99@xmlRelaxNG
$LN86@xmlRelaxNG:

; 4462 :             is_determinist = 0;

	xor	ebx, ebx
$LN99@xmlRelaxNG:

; 4401 :     for (i = 0; i < nbgroups; i++) {

	mov	eax, DWORD PTR tv1358[ebp]
	inc	ecx
	mov	edx, DWORD PTR _partitions$1$[ebp]
	add	eax, 4
	sub	DWORD PTR tv1385[ebp], 1
	mov	DWORD PTR _is_determinist$1$[ebp], ebx
	mov	DWORD PTR tv1358[ebp], eax
	mov	DWORD PTR tv1359[ebp], ecx
	jne	$LL8@xmlRelaxNG
$LN7@xmlRelaxNG:

; 4463 :         }
; 4464 :     }
; 4465 :     partitions->groups = groups;
; 4466 : 
; 4467 :     /*
; 4468 :      * and save the partition list back in the def
; 4469 :      */
; 4470 :     def->data = partitions;
; 4471 :     if (is_mixed != 0)

	cmp	DWORD PTR _is_mixed$1$[ebp], 0
	mov	eax, DWORD PTR _groups$1$[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR _payload$[ebp]
	mov	DWORD PTR [eax+20], edx
	je	SHORT $LN43@xmlRelaxNG

; 4472 :         def->dflags |= IS_MIXED;

	or	WORD PTR [eax+50], 8
$LN43@xmlRelaxNG:

; 4473 :     if (is_determinist == 1)

	cmp	ebx, 1
	jne	SHORT $LN44@xmlRelaxNG

; 4491 : }

	pop	edi
	pop	esi
	mov	DWORD PTR [edx+8], ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@xmlRelaxNG:

; 4474 :         partitions->flags = IS_DETERMINIST;
; 4475 :     if (is_determinist == 2)

	cmp	ebx, 2
	jne	$LN45@xmlRelaxNG

; 4491 : }

	pop	edi
	pop	esi
	mov	DWORD PTR [edx+8], 3
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN97@xmlRelaxNG:

; 4376 :             xmlMalloc(sizeof(xmlRelaxNGInterleaveGroup));
; 4377 :         if (groups[nbgroups] == NULL)

	xor	edi, edi
$error$103:

; 445  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	xor	eax, eax
	test	ecx, ecx
	jne	SHORT $LN63@xmlRelaxNG

; 446  : 	    schannel = ctxt->serror;
; 447  : 	else
; 448  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN63@xmlRelaxNG:

; 449  :         data = ctxt->userData;
; 450  :         ctxt->nbErrors++;
; 451  :     }
; 452  :     if (extra)
; 453  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BL@FDJODHDJ@in?5interleave?5computation?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+36]
	push	OFFSET ??_C@_0BL@FDJODHDJ@in?5interleave?5computation?6@
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError

; 4476 :         partitions->flags = IS_DETERMINIST | IS_NEEDCHECK;
; 4477 :     return;
; 4478 : 
; 4479 :   error:
; 4480 :     xmlRngPErrMemory(ctxt, "in interleave computation\n");
; 4481 :     if (groups != NULL) {

	mov	ecx, DWORD PTR _groups$1$[ebp]

; 453  :         __xmlRaiseError(schannel, channel, data,

	add	esp, 68					; 00000044H

; 4476 :         partitions->flags = IS_DETERMINIST | IS_NEEDCHECK;
; 4477 :     return;
; 4478 : 
; 4479 :   error:
; 4480 :     xmlRngPErrMemory(ctxt, "in interleave computation\n");
; 4481 :     if (groups != NULL) {

	test	ecx, ecx
	je	SHORT $LN46@xmlRelaxNG

; 4482 :         for (i = 0; i < nbgroups; i++)

	mov	ebx, DWORD PTR _nbgroups$1$[ebp]
	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN15@xmlRelaxNG
$LL16@xmlRelaxNG:

; 4483 :             if (groups[i] != NULL) {

	mov	eax, DWORD PTR [ecx+esi*4]
	test	eax, eax
	je	SHORT $LN14@xmlRelaxNG

; 4484 :                 if (groups[i]->defs != NULL)

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN48@xmlRelaxNG

; 4485 :                     xmlFree(groups[i]->defs);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _groups$1$[ebp]
	add	esp, 4
	mov	eax, DWORD PTR [eax+esi*4]
$LN48@xmlRelaxNG:

; 4486 :                 xmlFree(groups[i]);

	push	eax
	call	DWORD PTR _xmlFree
	mov	ecx, DWORD PTR _groups$1$[ebp]
	add	esp, 4
$LN14@xmlRelaxNG:

; 4482 :         for (i = 0; i < nbgroups; i++)

	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL16@xmlRelaxNG
$LN15@xmlRelaxNG:

; 4487 :             }
; 4488 :         xmlFree(groups);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN46@xmlRelaxNG:

; 4489 :     }
; 4490 :     xmlRelaxNGFreePartition(partitions);

	push	edi
	call	_xmlRelaxNGFreePartition
	add	esp, 4
$LN45@xmlRelaxNG:

; 4491 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGComputeInterleaves ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGCheckGroupAttrs
_TEXT	SEGMENT
tv385 = -12						; size = 4
_i$1$ = -12						; size = 4
_list$1$ = -8						; size = 4
_nbchild$1$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_def$ = 12						; size = 4
_xmlRelaxNGCheckGroupAttrs PROC				; COMDAT

; 4243 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _def$[ebp]
	xor	eax, eax
	mov	DWORD PTR _nbchild$1$[ebp], eax
	test	esi, esi
	je	$LN20@xmlRelaxNG

; 4244 :     xmlRelaxNGDefinePtr **list;
; 4245 :     xmlRelaxNGDefinePtr cur;
; 4246 :     int nbchild = 0, i, j, ret;
; 4247 : 
; 4248 :     if ((def == NULL) ||

	mov	ecx, DWORD PTR [esi]
	cmp	ecx, 18					; 00000012H
	je	SHORT $LN19@xmlRelaxNG
	cmp	ecx, 4
	jne	$LN20@xmlRelaxNG
$LN19@xmlRelaxNG:

; 4249 :         ((def->type != XML_RELAXNG_GROUP) &&
; 4250 :          (def->type != XML_RELAXNG_ELEMENT)))
; 4251 :         return;
; 4252 : 
; 4253 :     if (def->dflags & IS_PROCESSED)

	test	BYTE PTR [esi+50], 32			; 00000020H
	jne	$LN20@xmlRelaxNG

; 4254 :         return;
; 4255 : 
; 4256 :     /*
; 4257 :      * Don't run that check in case of error. Infinite recursion
; 4258 :      * becomes possible.
; 4259 :      */
; 4260 :     if (ctxt->nbErrors != 0)

	push	ebx
	mov	ebx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ebx+36], eax
	jne	$LN59@xmlRelaxNG

; 4261 :         return;
; 4262 : 
; 4263 :     cur = def->attrs;

	mov	ecx, DWORD PTR [esi+36]

; 4264 :     while (cur != NULL) {

	test	ecx, ecx
	je	SHORT $LN3@xmlRelaxNG
	npad	1
$LL2@xmlRelaxNG:

; 4265 :         nbchild++;
; 4266 :         cur = cur->next;

	mov	ecx, DWORD PTR [ecx+32]
	inc	eax
	test	ecx, ecx
	jne	SHORT $LL2@xmlRelaxNG
	mov	DWORD PTR _nbchild$1$[ebp], eax
$LN3@xmlRelaxNG:

; 4267 :     }
; 4268 :     cur = def->content;

	mov	ecx, DWORD PTR [esi+24]

; 4269 :     while (cur != NULL) {

	test	ecx, ecx
	je	SHORT $LN5@xmlRelaxNG
$LL4@xmlRelaxNG:

; 4270 :         nbchild++;
; 4271 :         cur = cur->next;

	mov	ecx, DWORD PTR [ecx+32]
	inc	eax
	test	ecx, ecx
	jne	SHORT $LL4@xmlRelaxNG
	mov	DWORD PTR _nbchild$1$[ebp], eax
$LN5@xmlRelaxNG:

; 4272 :     }
; 4273 : 
; 4274 :     list = (xmlRelaxNGDefinePtr **) xmlMalloc(nbchild *

	shl	eax, 2
	push	edi
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _list$1$[ebp], edi

; 4275 :                                               sizeof(xmlRelaxNGDefinePtr
; 4276 :                                                      *));
; 4277 :     if (list == NULL) {

	test	edi, edi
	jne	SHORT $LN23@xmlRelaxNG

; 4278 :         xmlRngPErrMemory(ctxt, "building group\n");

	push	OFFSET ??_C@_0BA@MBENMANO@building?5group?6@
	push	ebx
	call	_xmlRngPErrMemory
	add	esp, 8
	pop	edi
	pop	ebx
	pop	esi

; 4315 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@xmlRelaxNG:

; 4279 :         return;
; 4280 :     }
; 4281 :     i = 0;
; 4282 :     cur = def->attrs;

	mov	esi, DWORD PTR [esi+36]
	xor	ecx, ecx
	mov	DWORD PTR _i$1$[ebp], ecx

; 4283 :     while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN7@xmlRelaxNG
$LL6@xmlRelaxNG:

; 4284 :         list[i] = xmlRelaxNGGetElements(ctxt, cur, 1);

	push	1
	push	esi
	push	ebx
	call	_xmlRelaxNGGetElements
	mov	ecx, DWORD PTR _i$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+ecx*4], eax

; 4285 :         i++;

	inc	ecx

; 4286 :         cur = cur->next;

	mov	esi, DWORD PTR [esi+32]
	mov	DWORD PTR _i$1$[ebp], ecx
	test	esi, esi
	jne	SHORT $LL6@xmlRelaxNG
$LN7@xmlRelaxNG:

; 4287 :     }
; 4288 :     cur = def->content;

	mov	esi, DWORD PTR _def$[ebp]
	mov	esi, DWORD PTR [esi+24]

; 4289 :     while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN9@xmlRelaxNG

; 4287 :     }
; 4288 :     cur = def->content;

	lea	edi, DWORD PTR [edi+ecx*4]
	npad	1
$LL8@xmlRelaxNG:

; 4290 :         list[i] = xmlRelaxNGGetElements(ctxt, cur, 1);

	push	1
	push	esi
	push	ebx
	call	_xmlRelaxNGGetElements
	mov	DWORD PTR [edi], eax

; 4291 :         i++;

	lea	edi, DWORD PTR [edi+4]

; 4292 :         cur = cur->next;

	mov	esi, DWORD PTR [esi+32]
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	SHORT $LL8@xmlRelaxNG
$LN9@xmlRelaxNG:

; 4293 :     }
; 4294 : 
; 4295 :     for (i = 0; i < nbchild; i++) {

	mov	eax, DWORD PTR _nbchild$1$[ebp]
	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN11@xmlRelaxNG
	mov	ecx, DWORD PTR _list$1$[ebp]
	mov	edx, ecx
	mov	DWORD PTR tv385[ebp], ecx
	npad	7
$LL12@xmlRelaxNG:

; 4296 :         if (list[i] == NULL)

	cmp	DWORD PTR [edx], 0
	je	SHORT $LN10@xmlRelaxNG

; 4297 :             continue;
; 4298 :         for (j = 0; j < i; j++) {

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN10@xmlRelaxNG
	npad	5
$LL15@xmlRelaxNG:

; 4299 :             if (list[j] == NULL)

	mov	eax, DWORD PTR [ecx+esi*4]
	test	eax, eax
	je	SHORT $LN13@xmlRelaxNG

; 4300 :                 continue;
; 4301 :             ret = xmlRelaxNGCompareElemDefLists(ctxt, list[i], list[j]);

	push	eax
	push	DWORD PTR [edx]
	push	ebx
	call	_xmlRelaxNGCompareElemDefLists
	add	esp, 12					; 0000000cH

; 4302 :             if (ret == 0) {

	test	eax, eax
	jne	SHORT $LN58@xmlRelaxNG

; 4303 :                 xmlRngPErr(ctxt, def->node, XML_RNGP_GROUP_ATTR_CONFLICT,

	push	eax
	push	eax
	mov	eax, DWORD PTR _def$[ebp]
	push	OFFSET ??_C@_0BP@PNPCONEA@Attributes?5conflicts?5in?5group?6@
	push	1040					; 00000410H
	push	DWORD PTR [eax+4]
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN58@xmlRelaxNG:

; 4297 :             continue;
; 4298 :         for (j = 0; j < i; j++) {

	mov	edx, DWORD PTR tv385[ebp]
	mov	ecx, DWORD PTR _list$1$[ebp]
$LN13@xmlRelaxNG:
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL15@xmlRelaxNG
	mov	eax, DWORD PTR _nbchild$1$[ebp]
$LN10@xmlRelaxNG:

; 4293 :     }
; 4294 : 
; 4295 :     for (i = 0; i < nbchild; i++) {

	inc	edi
	add	edx, 4
	mov	DWORD PTR tv385[ebp], edx
	cmp	edi, eax
	jl	SHORT $LL12@xmlRelaxNG
$LN11@xmlRelaxNG:

; 4304 :                            "Attributes conflicts in group\n", NULL, NULL);
; 4305 :             }
; 4306 :         }
; 4307 :     }
; 4308 :     for (i = 0; i < nbchild; i++) {

	mov	ebx, DWORD PTR _nbchild$1$[ebp]
	xor	esi, esi
	mov	edi, DWORD PTR _list$1$[ebp]
	test	ebx, ebx
	jle	SHORT $LN17@xmlRelaxNG
$LL18@xmlRelaxNG:

; 4309 :         if (list[i] != NULL)

	mov	eax, DWORD PTR [edi+esi*4]
	test	eax, eax
	je	SHORT $LN16@xmlRelaxNG

; 4310 :             xmlFree(list[i]);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlRelaxNG:

; 4304 :                            "Attributes conflicts in group\n", NULL, NULL);
; 4305 :             }
; 4306 :         }
; 4307 :     }
; 4308 :     for (i = 0; i < nbchild; i++) {

	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL18@xmlRelaxNG
$LN17@xmlRelaxNG:

; 4311 :     }
; 4312 : 
; 4313 :     xmlFree(list);

	push	edi
	call	DWORD PTR _xmlFree

; 4314 :     def->dflags |= IS_PROCESSED;

	mov	eax, DWORD PTR _def$[ebp]
	add	esp, 4
	or	WORD PTR [eax+50], 32			; 00000020H
	pop	edi
$LN59@xmlRelaxNG:
	pop	ebx
$LN20@xmlRelaxNG:
	pop	esi

; 4315 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGCheckGroupAttrs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGCheckChoiceDeterminism
_TEXT	SEGMENT
_is_indeterminist$1$ = -24				; size = 4
_nbchild$1$ = -20					; size = 4
tv806 = -16						; size = 4
_triage$1$ = -12					; size = 4
_list$1$ = -8						; size = 4
_is_triable$1$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_def$ = 12						; size = 4
_xmlRelaxNGCheckChoiceDeterminism PROC			; COMDAT

; 4107 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _def$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _nbchild$1$[ebp], ebx
	mov	edi, 1
	mov	DWORD PTR _is_indeterminist$1$[ebp], ebx
	mov	DWORD PTR _triage$1$[ebp], ebx
	mov	DWORD PTR _is_triable$1$[ebp], edi
	test	ecx, ecx
	je	$LN18@xmlRelaxNG

; 4108 :     xmlRelaxNGDefinePtr **list;
; 4109 :     xmlRelaxNGDefinePtr cur;
; 4110 :     int nbchild = 0, i, j, ret;
; 4111 :     int is_nullable = 0;
; 4112 :     int is_indeterminist = 0;
; 4113 :     xmlHashTablePtr triage = NULL;
; 4114 :     int is_triable = 1;
; 4115 : 
; 4116 :     if ((def == NULL) || (def->type != XML_RELAXNG_CHOICE))

	cmp	DWORD PTR [ecx], 17			; 00000011H
	jne	$LN18@xmlRelaxNG

; 4117 :         return;
; 4118 : 
; 4119 :     if (def->dflags & IS_PROCESSED)

	test	BYTE PTR [ecx+50], 32			; 00000020H
	jne	$LN18@xmlRelaxNG

; 4120 :         return;
; 4121 : 
; 4122 :     /*
; 4123 :      * Don't run that check in case of error. Infinite recursion
; 4124 :      * becomes possible.
; 4125 :      */
; 4126 :     if (ctxt->nbErrors != 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+36], ebx
	jne	$LN18@xmlRelaxNG

; 4127 :         return;
; 4128 : 
; 4129 :     is_nullable = xmlRelaxNGIsNullable(def);

	push	esi
	push	ecx
	call	_xmlRelaxNGIsNullable
	mov	esi, eax
	add	esp, 4

; 4130 : 
; 4131 :     cur = def->content;

	mov	eax, DWORD PTR _def$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 4132 :     while (cur != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG
$LL2@xmlRelaxNG:

; 4133 :         nbchild++;
; 4134 :         cur = cur->next;

	mov	eax, DWORD PTR [eax+32]
	inc	ebx
	test	eax, eax
	jne	SHORT $LL2@xmlRelaxNG
	mov	DWORD PTR _nbchild$1$[ebp], ebx
$LN3@xmlRelaxNG:

; 4135 :     }
; 4136 : 
; 4137 :     list = (xmlRelaxNGDefinePtr **) xmlMalloc(nbchild *

	lea	eax, DWORD PTR [ebx*4]
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _list$1$[ebp], eax

; 4138 :                                               sizeof(xmlRelaxNGDefinePtr
; 4139 :                                                      *));
; 4140 :     if (list == NULL) {

	test	eax, eax
	jne	SHORT $LN21@xmlRelaxNG

; 4141 :         xmlRngPErrMemory(ctxt, "building choice\n");

	push	OFFSET ??_C@_0BB@HIJGJJAM@building?5choice?6@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRngPErrMemory
	add	esp, 8
	pop	esi
	pop	edi

; 4231 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlRelaxNG:

; 4142 :         return;
; 4143 :     }
; 4144 :     i = 0;
; 4145 :     /*
; 4146 :      * a bit strong but safe
; 4147 :      */
; 4148 :     if (is_nullable == 0) {

	test	esi, esi
	jne	SHORT $LN22@xmlRelaxNG

; 4149 :         triage = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	mov	DWORD PTR _triage$1$[ebp], eax
	add	esp, 4

; 4150 :     } else {

	mov	eax, DWORD PTR _list$1$[ebp]
	jmp	SHORT $LN23@xmlRelaxNG
$LN22@xmlRelaxNG:

; 4151 :         is_triable = 0;

	xor	edi, edi
	mov	DWORD PTR _is_triable$1$[ebp], edi
$LN23@xmlRelaxNG:

; 4152 :     }
; 4153 :     cur = def->content;

	mov	ebx, DWORD PTR _def$[ebp]
	mov	ebx, DWORD PTR [ebx+24]

; 4154 :     while (cur != NULL) {

	test	ebx, ebx
	je	$LN5@xmlRelaxNG

; 4152 :     }
; 4153 :     cur = def->content;

	mov	DWORD PTR tv806[ebp], eax
	npad	5
$LL4@xmlRelaxNG:

; 4155 :         list[i] = xmlRelaxNGGetElements(ctxt, cur, 0);

	push	0
	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGGetElements
	mov	esi, eax
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR tv806[ebp]
	mov	DWORD PTR [eax], esi

; 4156 :         if ((list[i] == NULL) || (list[i][0] == NULL)) {

	test	esi, esi
	je	$LN26@xmlRelaxNG
	cmp	DWORD PTR [esi], 0
	je	$LN26@xmlRelaxNG

; 4158 :         } else if (is_triable == 1) {

	cmp	edi, 1
	jne	SHORT $LN7@xmlRelaxNG
	npad	5
$LL6@xmlRelaxNG:

; 4159 :             xmlRelaxNGDefinePtr *tmp;
; 4160 :             int res;
; 4161 : 
; 4162 :             tmp = list[i];
; 4163 :             while ((*tmp != NULL) && (is_triable == 1)) {

	cmp	edi, 1
	jne	SHORT $LN80@xmlRelaxNG

; 4164 :                 if ((*tmp)->type == XML_RELAXNG_TEXT) {

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 3
	jne	SHORT $LN28@xmlRelaxNG

; 4165 :                     res = xmlHashAddEntry2(triage,

	push	ebx
	push	0
	push	OFFSET ??_C@_05NOBOONOA@?$CDtext@

; 4192 :                         is_triable = -1;
; 4193 :                 } else {
; 4194 :                     is_triable = -1;
; 4195 :                 }
; 4196 :                 tmp++;

	jmp	SHORT $LN83@xmlRelaxNG
$LN28@xmlRelaxNG:

; 4166 :                                            BAD_CAST "#text", NULL,
; 4167 :                                            (void *) cur);
; 4168 :                     if (res != 0)
; 4169 :                         is_triable = -1;
; 4170 :                 } else if (((*tmp)->type == XML_RELAXNG_ELEMENT) &&

	cmp	ecx, 4
	jne	SHORT $LN37@xmlRelaxNG
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN31@xmlRelaxNG

; 4171 :                            ((*tmp)->name != NULL)) {
; 4172 :                     if (((*tmp)->ns == NULL) || ((*tmp)->ns[0] == 0))

	test	eax, eax
	je	SHORT $LN79@xmlRelaxNG
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN34@xmlRelaxNG
$LN79@xmlRelaxNG:

; 4173 :                         res = xmlHashAddEntry2(triage,

	xor	eax, eax
$LN34@xmlRelaxNG:

; 4174 :                                                (*tmp)->name, NULL,
; 4175 :                                                (void *) cur);
; 4176 :                     else
; 4177 :                         res = xmlHashAddEntry2(triage,
; 4178 :                                                (*tmp)->name, (*tmp)->ns,
; 4179 :                                                (void *) cur);
; 4180 :                     if (res != 0)

	push	ebx
	push	eax
	push	ecx

; 4181 :                         is_triable = -1;
; 4182 :                 } else if ((*tmp)->type == XML_RELAXNG_ELEMENT) {

	jmp	SHORT $LN83@xmlRelaxNG
$LN31@xmlRelaxNG:

; 4183 :                     if (((*tmp)->ns == NULL) || ((*tmp)->ns[0] == 0))

	test	eax, eax
	je	SHORT $LN78@xmlRelaxNG
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN40@xmlRelaxNG
$LN78@xmlRelaxNG:

; 4184 :                         res = xmlHashAddEntry2(triage,

	xor	eax, eax
$LN40@xmlRelaxNG:

; 4185 :                                                BAD_CAST "#any", NULL,
; 4186 :                                                (void *) cur);
; 4187 :                     else
; 4188 :                         res = xmlHashAddEntry2(triage,
; 4189 :                                                BAD_CAST "#any", (*tmp)->ns,
; 4190 :                                                (void *) cur);
; 4191 :                     if (res != 0)

	push	ebx
	push	eax
	push	OFFSET ??_C@_04IAJCOJMF@?$CDany@
$LN83@xmlRelaxNG:

; 4192 :                         is_triable = -1;
; 4193 :                 } else {
; 4194 :                     is_triable = -1;
; 4195 :                 }
; 4196 :                 tmp++;

	push	DWORD PTR _triage$1$[ebp]
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN38@xmlRelaxNG
$LN37@xmlRelaxNG:
	or	edi, -1
$LN38@xmlRelaxNG:
	add	esi, 4
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LL6@xmlRelaxNG
$LN80@xmlRelaxNG:

; 4197 :             }
; 4198 :         }
; 4199 :         i++;

	mov	eax, DWORD PTR tv806[ebp]
$LN7@xmlRelaxNG:

; 4200 :         cur = cur->next;

	mov	ebx, DWORD PTR [ebx+32]
	add	eax, 4
	mov	DWORD PTR tv806[ebp], eax
	test	ebx, ebx
	jne	$LL4@xmlRelaxNG
	mov	DWORD PTR _is_triable$1$[ebp], edi
$LN5@xmlRelaxNG:

; 4201 :     }
; 4202 : 
; 4203 :     for (i = 0; i < nbchild; i++) {

	mov	ecx, DWORD PTR _nbchild$1$[ebp]
	xor	ebx, ebx
	test	ecx, ecx
	jle	SHORT $LN9@xmlRelaxNG
	mov	eax, DWORD PTR _list$1$[ebp]
	mov	edi, eax
$LL10@xmlRelaxNG:

; 4204 :         if (list[i] == NULL)

	cmp	DWORD PTR [edi], 0
	je	SHORT $LN8@xmlRelaxNG

; 4205 :             continue;
; 4206 :         for (j = 0; j < i; j++) {

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN8@xmlRelaxNG
$LL13@xmlRelaxNG:

; 4207 :             if (list[j] == NULL)

	mov	eax, DWORD PTR [eax+esi*4]
	test	eax, eax
	je	SHORT $LN11@xmlRelaxNG

; 4208 :                 continue;
; 4209 :             ret = xmlRelaxNGCompareElemDefLists(ctxt, list[i], list[j]);

	push	eax
	push	DWORD PTR [edi]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGCompareElemDefLists

; 4210 :             if (ret == 0) {

	mov	ecx, DWORD PTR _is_indeterminist$1$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	mov	edx, 1
	cmove	ecx, edx
	mov	DWORD PTR _is_indeterminist$1$[ebp], ecx
$LN11@xmlRelaxNG:

; 4205 :             continue;
; 4206 :         for (j = 0; j < i; j++) {

	mov	eax, DWORD PTR _list$1$[ebp]
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL13@xmlRelaxNG
	mov	ecx, DWORD PTR _nbchild$1$[ebp]
$LN8@xmlRelaxNG:

; 4201 :     }
; 4202 : 
; 4203 :     for (i = 0; i < nbchild; i++) {

	inc	ebx
	add	edi, 4
	cmp	ebx, ecx
	jl	SHORT $LL10@xmlRelaxNG
	mov	edi, DWORD PTR _is_triable$1$[ebp]
$LN9@xmlRelaxNG:

; 4211 :                 is_indeterminist = 1;
; 4212 :             }
; 4213 :         }
; 4214 :     }
; 4215 :     for (i = 0; i < nbchild; i++) {

	mov	ebx, DWORD PTR _list$1$[ebp]
	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN15@xmlRelaxNG
$LL16@xmlRelaxNG:

; 4216 :         if (list[i] != NULL)

	mov	eax, DWORD PTR [ebx+esi*4]
	test	eax, eax
	je	SHORT $LN14@xmlRelaxNG

; 4217 :             xmlFree(list[i]);

	push	eax
	call	DWORD PTR _xmlFree
	mov	ecx, DWORD PTR _nbchild$1$[ebp]
	add	esp, 4
$LN14@xmlRelaxNG:

; 4211 :                 is_indeterminist = 1;
; 4212 :             }
; 4213 :         }
; 4214 :     }
; 4215 :     for (i = 0; i < nbchild; i++) {

	inc	esi
	cmp	esi, ecx
	jl	SHORT $LL16@xmlRelaxNG
$LN15@xmlRelaxNG:

; 4218 :     }
; 4219 : 
; 4220 :     xmlFree(list);

	push	ebx
	call	DWORD PTR _xmlFree
	mov	ebx, DWORD PTR _def$[ebp]
	add	esp, 4

; 4221 :     if (is_indeterminist) {

	cmp	DWORD PTR _is_indeterminist$1$[ebp], 0
	movzx	eax, WORD PTR [ebx+50]
	je	SHORT $LN47@xmlRelaxNG

; 4222 :         def->dflags |= IS_INDETERMINIST;

	or	eax, 4
	mov	WORD PTR [ebx+50], ax
	movzx	eax, ax
$LN47@xmlRelaxNG:

; 4223 :     }
; 4224 :     if (is_triable == 1) {

	mov	ecx, DWORD PTR _triage$1$[ebp]
	cmp	edi, 1
	jne	SHORT $LN48@xmlRelaxNG

; 4225 :         def->dflags |= IS_TRIABLE;

	or	eax, 16					; 00000010H

; 4226 :         def->data = triage;

	mov	DWORD PTR [ebx+20], ecx
	movzx	eax, ax
	pop	esi

; 4229 :     }
; 4230 :     def->dflags |= IS_PROCESSED;

	or	eax, 32					; 00000020H
	pop	edi
	mov	WORD PTR [ebx+50], ax

; 4231 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlRelaxNG:

; 4157 :             is_triable = 0;

	xor	edi, edi

; 4159 :             xmlRelaxNGDefinePtr *tmp;
; 4160 :             int res;
; 4161 : 
; 4162 :             tmp = list[i];
; 4163 :             while ((*tmp != NULL) && (is_triable == 1)) {

	jmp	$LN7@xmlRelaxNG
$LN48@xmlRelaxNG:

; 4227 :     } else if (triage != NULL) {

	movzx	eax, ax
	test	ecx, ecx
	je	SHORT $LN50@xmlRelaxNG

; 4228 :         xmlHashFree(triage, NULL);

	push	0
	push	ecx
	call	_xmlHashFree
	movzx	eax, WORD PTR [ebx+50]
	add	esp, 8
$LN50@xmlRelaxNG:

; 4229 :     }
; 4230 :     def->dflags |= IS_PROCESSED;

	or	eax, 32					; 00000020H
	mov	WORD PTR [ebx+50], ax
	pop	esi
$LN18@xmlRelaxNG:

; 4231 : }

	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGCheckChoiceDeterminism ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGGetElements
_TEXT	SEGMENT
_max$1$ = -8						; size = 4
_len$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_def$ = 12						; size = 4
_eora$ = 16						; size = 4
_xmlRelaxNGGetElements PROC				; COMDAT

; 4005 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	xor	ecx, ecx
	mov	DWORD PTR _len$1$[ebp], eax
	xor	edi, edi
	mov	DWORD PTR _max$1$[ebp], ecx
	cmp	DWORD PTR [edx+36], eax
	je	SHORT $LN9@xmlRelaxNG
	pop	edi

; 4095 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlRelaxNG:
	push	ebx

; 4006 :     xmlRelaxNGDefinePtr *ret = NULL, parent, cur, tmp;
; 4007 :     int len = 0;
; 4008 :     int max = 0;
; 4009 : 
; 4010 :     /*
; 4011 :      * Don't run that check in case of error. Infinite recursion
; 4012 :      * becomes possible.
; 4013 :      */
; 4014 :     if (ctxt->nbErrors != 0)
; 4015 :         return (NULL);
; 4016 : 
; 4017 :     parent = NULL;
; 4018 :     cur = def;

	mov	ebx, DWORD PTR _def$[ebp]
	push	esi
	mov	esi, ebx

; 4019 :     while (cur != NULL) {

	test	ebx, ebx
	je	$LN3@xmlRelaxNG
	mov	edx, DWORD PTR _eora$[ebp]
	npad	4
$LL2@xmlRelaxNG:

; 4020 :         if (((eora == 0) && ((cur->type == XML_RELAXNG_ELEMENT) ||
; 4021 :                              (cur->type == XML_RELAXNG_TEXT))) ||
; 4022 :             ((eora == 1) && (cur->type == XML_RELAXNG_ATTRIBUTE)) ||

	test	edx, edx
	jne	SHORT $LN47@xmlRelaxNG
	mov	eax, DWORD PTR [esi]
	cmp	eax, 4
	je	$LN67@xmlRelaxNG
	cmp	eax, 3
	je	$LN67@xmlRelaxNG
$LN49@xmlRelaxNG:

; 4052 :                    (cur->type == XML_RELAXNG_INTERLEAVE) ||
; 4053 :                    (cur->type == XML_RELAXNG_GROUP) ||
; 4054 :                    (cur->type == XML_RELAXNG_ONEORMORE) ||
; 4055 :                    (cur->type == XML_RELAXNG_ZEROORMORE) ||
; 4056 :                    (cur->type == XML_RELAXNG_OPTIONAL) ||
; 4057 :                    (cur->type == XML_RELAXNG_PARENTREF) ||
; 4058 :                    (cur->type == XML_RELAXNG_REF) ||
; 4059 :                    (cur->type == XML_RELAXNG_DEF) ||

	mov	eax, DWORD PTR [esi]
	cmp	eax, 17					; 00000011H
	je	SHORT $LN22@xmlRelaxNG
	cmp	eax, 19					; 00000013H
	je	SHORT $LN22@xmlRelaxNG
	cmp	eax, 18					; 00000012H
	je	SHORT $LN22@xmlRelaxNG
	cmp	eax, 16					; 00000010H
	je	SHORT $LN22@xmlRelaxNG
	cmp	eax, 15					; 0000000fH
	je	SHORT $LN22@xmlRelaxNG
	cmp	eax, 14					; 0000000eH
	je	SHORT $LN22@xmlRelaxNG
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN22@xmlRelaxNG
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN22@xmlRelaxNG
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN22@xmlRelaxNG
	cmp	eax, 12					; 0000000cH
	jne	$LN23@xmlRelaxNG
$LN22@xmlRelaxNG:

; 4060 : 		   (cur->type == XML_RELAXNG_EXTERNALREF)) {
; 4061 :             /*
; 4062 :              * Don't go within elements or attributes or string values.
; 4063 :              * Just gather the element top list
; 4064 :              */
; 4065 :             if (cur->content != NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	$LN23@xmlRelaxNG

; 4066 :                 parent = cur;

	mov	ecx, esi

; 4067 :                 cur = cur->content;

	mov	esi, eax

; 4068 :                 tmp = cur;
; 4069 :                 while (tmp != NULL) {

	test	esi, esi
	je	$LN3@xmlRelaxNG
$LL4@xmlRelaxNG:

; 4070 :                     tmp->parent = parent;

	mov	DWORD PTR [eax+28], ecx

; 4071 :                     tmp = tmp->next;

	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	jne	SHORT $LL4@xmlRelaxNG

; 4072 :                 }
; 4073 :                 continue;

	jmp	$LN7@xmlRelaxNG
$LN47@xmlRelaxNG:

; 4020 :         if (((eora == 0) && ((cur->type == XML_RELAXNG_ELEMENT) ||
; 4021 :                              (cur->type == XML_RELAXNG_TEXT))) ||
; 4022 :             ((eora == 1) && (cur->type == XML_RELAXNG_ATTRIBUTE)) ||

	cmp	edx, 1
	jne	SHORT $LN48@xmlRelaxNG
	cmp	DWORD PTR [esi], 9
	je	SHORT $LN15@xmlRelaxNG
	jmp	SHORT $LN49@xmlRelaxNG
$LN48@xmlRelaxNG:
	cmp	edx, 2
	jne	SHORT $LN49@xmlRelaxNG
	mov	eax, DWORD PTR [esi]
	cmp	eax, 5
	je	SHORT $LN67@xmlRelaxNG
	cmp	eax, 4
	je	SHORT $LN67@xmlRelaxNG
	cmp	eax, 8
	je	SHORT $LN67@xmlRelaxNG
	cmp	eax, 3
	je	SHORT $LN67@xmlRelaxNG
	cmp	eax, 7
	jne	$LN49@xmlRelaxNG
$LN67@xmlRelaxNG:

; 4023 :             ((eora == 2) && ((cur->type == XML_RELAXNG_DATATYPE) ||
; 4024 : 	                     (cur->type == XML_RELAXNG_ELEMENT) ||
; 4025 : 			     (cur->type == XML_RELAXNG_LIST) ||
; 4026 :                              (cur->type == XML_RELAXNG_TEXT) ||
; 4027 : 			     (cur->type == XML_RELAXNG_VALUE)))) {
; 4028 :             if (ret == NULL) {

	mov	eax, DWORD PTR _len$1$[ebp]
$LN15@xmlRelaxNG:
	test	edi, edi
	jne	SHORT $LN16@xmlRelaxNG

; 4029 :                 max = 10;
; 4030 :                 ret = (xmlRelaxNGDefinePtr *)

	push	44					; 0000002cH
	mov	DWORD PTR _max$1$[ebp], 10		; 0000000aH
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 4031 :                     xmlMalloc((max + 1) * sizeof(xmlRelaxNGDefinePtr));
; 4032 :                 if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN71@xmlRelaxNG

; 4033 :                     xmlRngPErrMemory(ctxt, "getting element list\n");

	push	OFFSET ??_C@_0BG@CHOOIKPA@getting?5element?5list?6@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRngPErrMemory
	add	esp, 8

; 4034 :                     return (NULL);

	xor	eax, eax
	pop	esi
	pop	ebx
	pop	edi

; 4095 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlRelaxNG:

; 4035 :                 }
; 4036 :             } else if (max <= len) {

	cmp	ecx, eax
	jg	SHORT $LN19@xmlRelaxNG

; 4037 : 	        xmlRelaxNGDefinePtr *temp;
; 4038 : 
; 4039 :                 max *= 2;

	add	ecx, ecx
	mov	DWORD PTR _max$1$[ebp], ecx

; 4040 :                 temp = xmlRealloc(ret,

	lea	eax, DWORD PTR [ecx*4+4]
	push	eax
	push	edi
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 4041 :                                (max + 1) * sizeof(xmlRelaxNGDefinePtr));
; 4042 :                 if (temp == NULL) {

	test	eax, eax
	je	SHORT $LN39@xmlRelaxNG

; 4046 :                 }
; 4047 : 		ret = temp;

	mov	edi, eax
$LN71@xmlRelaxNG:

; 4048 :             }
; 4049 :             ret[len++] = cur;

	mov	edx, DWORD PTR _eora$[ebp]
	mov	eax, DWORD PTR _len$1$[ebp]
$LN19@xmlRelaxNG:
	mov	DWORD PTR [edi+eax*4], esi
	inc	eax
	mov	DWORD PTR _len$1$[ebp], eax

; 4050 :             ret[len] = NULL;

	mov	DWORD PTR [edi+eax*4], 0

; 4051 :         } else if ((cur->type == XML_RELAXNG_CHOICE) ||

	jmp	SHORT $LN23@xmlRelaxNG
$LL8@xmlRelaxNG:

; 4074 :             }
; 4075 :         }
; 4076 :         if (cur == def)
; 4077 :             break;
; 4078 :         if (cur->next != NULL) {
; 4079 :             cur = cur->next;
; 4080 :             continue;
; 4081 :         }
; 4082 :         do {
; 4083 :             cur = cur->parent;

	mov	esi, DWORD PTR [esi+28]

; 4084 :             if (cur == NULL)

	test	esi, esi
	je	SHORT $LN3@xmlRelaxNG
$LN23@xmlRelaxNG:

; 4019 :     while (cur != NULL) {

	cmp	esi, ebx
	je	SHORT $LN3@xmlRelaxNG
	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LL8@xmlRelaxNG
	mov	esi, eax
$LN7@xmlRelaxNG:
	test	esi, esi
	je	SHORT $LN3@xmlRelaxNG
	mov	eax, DWORD PTR _len$1$[ebp]
	mov	ecx, DWORD PTR _max$1$[ebp]
	jmp	$LL2@xmlRelaxNG
$LN39@xmlRelaxNG:

; 4043 :                     xmlRngPErrMemory(ctxt, "getting element list\n");

	push	OFFSET ??_C@_0BG@CHOOIKPA@getting?5element?5list?6@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRngPErrMemory

; 4044 : 		    xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 4045 :                     return (NULL);

	xor	eax, eax
	pop	esi
	pop	ebx
	pop	edi

; 4095 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlRelaxNG:
	pop	esi
	pop	ebx

; 4085 :                 break;
; 4086 :             if (cur == def)
; 4087 :                 return (ret);
; 4088 :             if (cur->next != NULL) {
; 4089 :                 cur = cur->next;
; 4090 :                 break;
; 4091 :             }
; 4092 :         } while (cur != NULL);
; 4093 :     }
; 4094 :     return (ret);

	mov	eax, edi
	pop	edi

; 4095 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGGetElements ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGGenerateAttributes
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_def$ = 12						; size = 4
_xmlRelaxNGGenerateAttributes PROC			; COMDAT

; 3929 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN9@xmlRelaxNG

; 3930 :     xmlRelaxNGDefinePtr parent, cur, tmp;
; 3931 : 
; 3932 :     /*
; 3933 :      * Don't run that check in case of error. Infinite recursion
; 3934 :      * becomes possible.
; 3935 :      */
; 3936 :     if (ctxt->nbErrors != 0)
; 3937 :         return (-1);

	or	eax, -1

; 3990 : }

	pop	ebp
	ret	0
$LN9@xmlRelaxNG:

; 3938 : 
; 3939 :     parent = NULL;
; 3940 :     cur = def;

	mov	edx, DWORD PTR _def$[ebp]
	mov	eax, edx
	push	esi

; 3941 :     while (cur != NULL) {

	test	edx, edx
	je	$LN3@xmlRelaxNG
	npad	7
$LL2@xmlRelaxNG:

; 3942 :         if ((cur->type == XML_RELAXNG_ELEMENT) ||
; 3943 :             (cur->type == XML_RELAXNG_TEXT) ||
; 3944 :             (cur->type == XML_RELAXNG_DATATYPE) ||
; 3945 :             (cur->type == XML_RELAXNG_PARAM) ||
; 3946 :             (cur->type == XML_RELAXNG_LIST) ||
; 3947 :             (cur->type == XML_RELAXNG_VALUE) ||

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	$LN11@xmlRelaxNG
	cmp	ecx, 3
	je	$LN11@xmlRelaxNG
	cmp	ecx, 5
	je	$LN11@xmlRelaxNG
	cmp	ecx, 6
	je	$LN11@xmlRelaxNG
	cmp	ecx, 8
	je	SHORT $LN11@xmlRelaxNG
	cmp	ecx, 7
	je	SHORT $LN11@xmlRelaxNG
	test	ecx, ecx
	je	SHORT $LN11@xmlRelaxNG

; 3950 :         if ((cur->type == XML_RELAXNG_CHOICE) ||
; 3951 :             (cur->type == XML_RELAXNG_INTERLEAVE) ||
; 3952 :             (cur->type == XML_RELAXNG_GROUP) ||
; 3953 :             (cur->type == XML_RELAXNG_ONEORMORE) ||
; 3954 :             (cur->type == XML_RELAXNG_ZEROORMORE) ||
; 3955 :             (cur->type == XML_RELAXNG_OPTIONAL) ||
; 3956 :             (cur->type == XML_RELAXNG_PARENTREF) ||
; 3957 :             (cur->type == XML_RELAXNG_EXTERNALREF) ||
; 3958 :             (cur->type == XML_RELAXNG_REF) ||

	cmp	ecx, 17					; 00000011H
	je	SHORT $LN13@xmlRelaxNG
	cmp	ecx, 19					; 00000013H
	je	SHORT $LN13@xmlRelaxNG
	cmp	ecx, 18					; 00000012H
	je	SHORT $LN13@xmlRelaxNG
	cmp	ecx, 16					; 00000010H
	je	SHORT $LN13@xmlRelaxNG
	cmp	ecx, 15					; 0000000fH
	je	SHORT $LN13@xmlRelaxNG
	cmp	ecx, 14					; 0000000eH
	je	SHORT $LN13@xmlRelaxNG
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN13@xmlRelaxNG
	cmp	ecx, 12					; 0000000cH
	je	SHORT $LN13@xmlRelaxNG
	cmp	ecx, 11					; 0000000bH
	je	SHORT $LN13@xmlRelaxNG
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN14@xmlRelaxNG
$LN13@xmlRelaxNG:

; 3959 :             (cur->type == XML_RELAXNG_DEF)) {
; 3960 :             if (cur->content != NULL) {

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LN14@xmlRelaxNG

; 3961 :                 parent = cur;

	mov	esi, eax

; 3962 :                 cur = cur->content;

	mov	eax, ecx

; 3963 :                 tmp = cur;
; 3964 :                 while (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG
$LL4@xmlRelaxNG:

; 3965 :                     tmp->parent = parent;

	mov	DWORD PTR [ecx+28], esi

; 3966 :                     tmp = tmp->next;

	mov	ecx, DWORD PTR [ecx+32]
	test	ecx, ecx
	jne	SHORT $LL4@xmlRelaxNG

; 3967 :                 }
; 3968 :                 continue;

	jmp	SHORT $LN7@xmlRelaxNG
$LL8@xmlRelaxNG:

; 3969 :             }
; 3970 :         }
; 3971 :         if (cur == def)
; 3972 :             break;
; 3973 :         if (cur->next != NULL) {
; 3974 :             cur = cur->next;
; 3975 :             continue;
; 3976 :         }
; 3977 :         do {
; 3978 :             cur = cur->parent;

	mov	eax, DWORD PTR [eax+28]

; 3979 :             if (cur == NULL)

	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG
$LN14@xmlRelaxNG:

; 3941 :     while (cur != NULL) {

	cmp	eax, edx
	je	SHORT $LN3@xmlRelaxNG
	mov	ecx, DWORD PTR [eax+32]
	test	ecx, ecx
	je	SHORT $LL8@xmlRelaxNG
	mov	eax, ecx
$LN7@xmlRelaxNG:
	test	eax, eax
	jne	$LL2@xmlRelaxNG
$LN3@xmlRelaxNG:

; 3980 :                 break;
; 3981 :             if (cur == def)
; 3982 :                 return (1);
; 3983 :             if (cur->next != NULL) {
; 3984 :                 cur = cur->next;
; 3985 :                 break;
; 3986 :             }
; 3987 :         } while (cur != NULL);
; 3988 :     }
; 3989 :     return (1);

	mov	eax, 1
	pop	esi

; 3990 : }

	pop	ebp
	ret	0
$LN11@xmlRelaxNG:

; 3948 :             (cur->type == XML_RELAXNG_EMPTY))
; 3949 :             return (0);

	xor	eax, eax
	pop	esi

; 3990 : }

	pop	ebp
	ret	0
_xmlRelaxNGGenerateAttributes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGCompareElemDefLists
_TEXT	SEGMENT
_ctxt$1 = -200						; size = 116
_node$2 = -84						; size = 60
_ns$3 = -24						; size = 24
_ctxt$ = 8						; size = 4
_def1$ = 12						; size = 4
_def2$ = 16						; size = 4
_xmlRelaxNGCompareElemDefLists PROC			; COMDAT

; 3898 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _def1$[ebp]
	test	eax, eax
	je	$LN7@xmlRelaxNG

; 3899 :     xmlRelaxNGDefinePtr *basedef2 = def2;
; 3900 : 
; 3901 :     if ((def1 == NULL) || (def2 == NULL))

	mov	ecx, DWORD PTR _def2$[ebp]
	test	ecx, ecx
	je	$LN7@xmlRelaxNG

; 3902 :         return (1);
; 3903 :     if ((*def1 == NULL) || (*def2 == NULL))

	cmp	DWORD PTR [eax], 0
	je	$LN7@xmlRelaxNG
	cmp	DWORD PTR [ecx], 0
	je	$LN7@xmlRelaxNG
	npad	2
$LL2@xmlRelaxNG:

; 3904 :         return (1);
; 3905 :     while (*def1 != NULL) {
; 3906 :         while ((*def2) != NULL) {

	mov	esi, DWORD PTR [ecx]
	test	esi, esi
	je	$LN5@xmlRelaxNG
	mov	ebx, ecx
	npad	4
$LL4@xmlRelaxNG:

; 3907 :             if (xmlRelaxNGCompareNameClasses(*def1, *def2) == 0)

	mov	edi, DWORD PTR [eax]

; 3802 :     memset(&ctxt, 0, sizeof(xmlRelaxNGValidCtxt));

	lea	eax, DWORD PTR _ctxt$1[ebp]
	push	116					; 00000074H
	push	0
	push	eax
	call	_memset

; 3803 : 
; 3804 :     ctxt.flags = FLAGS_IGNORABLE | FLAGS_NOERROR;
; 3805 : 
; 3806 :     if ((def1->type == XML_RELAXNG_ELEMENT) ||

	mov	eax, DWORD PTR [edi]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ctxt$1[ebp+28], 9
	cmp	eax, 4
	je	SHORT $LN57@xmlRelaxNG
	cmp	eax, 9
	je	SHORT $LN57@xmlRelaxNG

; 3828 :             } else {
; 3829 :                 ret = 0;
; 3830 :             }
; 3831 :         } else {
; 3832 :             ret = 1;
; 3833 :         }
; 3834 :     } else if (def1->type == XML_RELAXNG_TEXT) {

	cmp	eax, 3
	jne	SHORT $LN27@xmlRelaxNG

; 3835 :         if (def2->type == XML_RELAXNG_TEXT)

	cmp	DWORD PTR [esi], eax

; 3836 :             return (0);
; 3837 :         return (1);

	jmp	$LN66@xmlRelaxNG
$LN27@xmlRelaxNG:

; 3838 :     } else if (def1->type == XML_RELAXNG_EXCEPT) {

	cmp	eax, 2
	jne	$LN30@xmlRelaxNG

; 3839 :         ret = xmlRelaxNGCompareNameClasses(def1->content, def2);

	push	esi
	push	DWORD PTR [edi+24]
	call	_xmlRelaxNGCompareNameClasses
	add	esp, 8

; 3840 : 	if (ret == 0)

	test	eax, eax
	je	SHORT $LN35@xmlRelaxNG

; 3841 : 	    ret = 1;
; 3842 : 	else if (ret == 1)

	cmp	eax, 1
	je	$LN52@xmlRelaxNG

; 3843 : 	    ret = 0;
; 3844 :     } else {

	jmp	SHORT $LN24@xmlRelaxNG
$LN57@xmlRelaxNG:

; 3807 :         (def1->type == XML_RELAXNG_ATTRIBUTE)) {
; 3808 :         if (def2->type == XML_RELAXNG_TEXT)

	cmp	DWORD PTR [esi], 3
	je	$LN60@xmlRelaxNG

; 3809 :             return (1);
; 3810 :         if (def1->name != NULL) {

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	mov	ecx, DWORD PTR _invalidName
	cmovne	ecx, eax

; 3811 :             node.name = def1->name;
; 3812 :         } else {
; 3813 :             node.name = invalidName;
; 3814 :         }
; 3815 :         if (def1->ns != NULL) {

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR _node$2[ebp+8], ecx
	test	eax, eax
	je	SHORT $LN19@xmlRelaxNG

; 3816 :             if (def1->ns[0] == 0) {

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN19@xmlRelaxNG

; 3817 :                 node.ns = NULL;
; 3818 :             } else {
; 3819 : 	        node.ns = &ns;

	lea	ecx, DWORD PTR _ns$3[ebp]

; 3820 :                 ns.href = def1->ns;

	mov	DWORD PTR _ns$3[ebp+8], eax
	mov	DWORD PTR _node$2[ebp+36], ecx

; 3821 :             }
; 3822 :         } else {

	jmp	SHORT $LN20@xmlRelaxNG
$LN19@xmlRelaxNG:

; 3823 :             node.ns = NULL;
; 3824 :         }
; 3825 :         if (xmlRelaxNGElementMatch(&ctxt, def2, &node)) {

	mov	DWORD PTR _node$2[ebp+36], 0
$LN20@xmlRelaxNG:
	lea	eax, DWORD PTR _node$2[ebp]
	push	eax
	lea	eax, DWORD PTR _ctxt$1[ebp]
	push	esi
	push	eax
	call	_xmlRelaxNGElementMatch
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN35@xmlRelaxNG

; 3826 :             if (def1->nameClass != NULL) {

	mov	eax, DWORD PTR [edi+40]
	test	eax, eax
	je	$LN52@xmlRelaxNG

; 3827 :                 ret = xmlRelaxNGCompareNameClasses(def1->nameClass, def2);

	push	esi
	push	eax
	call	_xmlRelaxNGCompareNameClasses
	add	esp, 8
$LN24@xmlRelaxNG:

; 3846 :     }
; 3847 :     if (ret == 0)

	test	eax, eax
	je	$LN52@xmlRelaxNG
$LN35@xmlRelaxNG:

; 3848 :         return (ret);
; 3849 :     if ((def2->type == XML_RELAXNG_ELEMENT) ||

	mov	eax, DWORD PTR [esi]
	cmp	eax, 4
	je	SHORT $LN38@xmlRelaxNG
	cmp	eax, 9
	jne	$LN65@xmlRelaxNG
$LN38@xmlRelaxNG:

; 3850 :         (def2->type == XML_RELAXNG_ATTRIBUTE)) {
; 3851 :         if (def2->name != NULL) {

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	mov	edx, DWORD PTR _invalidName
	mov	eax, edx
	cmovne	eax, ecx
	mov	DWORD PTR _node$2[ebp+8], eax

; 3852 :             node.name = def2->name;
; 3853 :         } else {
; 3854 :             node.name = invalidName;
; 3855 :         }
; 3856 :         node.ns = &ns;

	lea	eax, DWORD PTR _ns$3[ebp]
	mov	DWORD PTR _node$2[ebp+36], eax

; 3857 :         if (def2->ns != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN41@xmlRelaxNG

; 3858 :             if (def2->ns[0] == 0) {

	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN43@xmlRelaxNG

; 3859 :                 node.ns = NULL;

	mov	DWORD PTR _node$2[ebp+36], 0

; 3860 :             } else {

	jmp	SHORT $LN42@xmlRelaxNG
$LN43@xmlRelaxNG:

; 3861 :                 ns.href = def2->ns;

	mov	DWORD PTR _ns$3[ebp+8], eax

; 3862 :             }
; 3863 :         } else {

	jmp	SHORT $LN42@xmlRelaxNG
$LN41@xmlRelaxNG:

; 3864 :             ns.href = invalidName;

	mov	DWORD PTR _ns$3[ebp+8], edx
$LN42@xmlRelaxNG:

; 3865 :         }
; 3866 :         if (xmlRelaxNGElementMatch(&ctxt, def1, &node)) {

	lea	eax, DWORD PTR _node$2[ebp]
	push	eax
	lea	eax, DWORD PTR _ctxt$1[ebp]
	push	edi
	push	eax
	call	_xmlRelaxNGElementMatch
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN60@xmlRelaxNG

; 3867 :             if (def2->nameClass != NULL) {

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN52@xmlRelaxNG

; 3868 :                 ret = xmlRelaxNGCompareNameClasses(def2->nameClass, def1);

	push	edi
	push	eax
	call	_xmlRelaxNGCompareNameClasses
	add	esp, 8

; 3907 :             if (xmlRelaxNGCompareNameClasses(*def1, *def2) == 0)

	test	eax, eax
$LN66@xmlRelaxNG:

; 3909 :             def2++;

	je	SHORT $LN52@xmlRelaxNG
$LN60@xmlRelaxNG:

; 3904 :         return (1);
; 3905 :     while (*def1 != NULL) {
; 3906 :         while ((*def2) != NULL) {

	mov	esi, DWORD PTR [ebx+4]

; 3909 :             def2++;

	add	ebx, 4
	mov	eax, DWORD PTR _def1$[ebp]
	test	esi, esi
	jne	$LL4@xmlRelaxNG
	mov	ecx, DWORD PTR _def2$[ebp]
$LN5@xmlRelaxNG:

; 3910 :         }
; 3911 :         def2 = basedef2;
; 3912 :         def1++;

	add	eax, 4
	mov	DWORD PTR _def1$[ebp], eax
	cmp	DWORD PTR [eax], 0
	jne	$LL2@xmlRelaxNG
$LN7@xmlRelaxNG:
	pop	edi

; 3913 :     }
; 3914 :     return (1);
; 3915 : }

	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@xmlRelaxNG:

; 3845 :         TODO ret = 0;

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	3845					; 00000f05H
	jmp	SHORT $LN67@xmlRelaxNG
$LN65@xmlRelaxNG:

; 3869 :             } else {
; 3870 :                 ret = 0;
; 3871 :             }
; 3872 :         } else {
; 3873 :             ret = 1;
; 3874 :         }
; 3875 :     } else {
; 3876 :         TODO ret = 0;

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	3876					; 00000f24H
$LN67@xmlRelaxNG:

; 3908 :                 return (0);

	push	OFFSET ??_C@_0GJ@NFABHKPN@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN52@xmlRelaxNG:

; 3913 :     }
; 3914 :     return (1);
; 3915 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGCompareElemDefLists ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGCompareNameClasses
_TEXT	SEGMENT
_ctxt$ = -200						; size = 116
_node$ = -84						; size = 60
_ns$ = -24						; size = 24
_def1$ = 8						; size = 4
_def2$ = 12						; size = 4
_xmlRelaxNGCompareNameClasses PROC			; COMDAT

; 3796 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	push	116					; 00000074H
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	0
	push	eax
	call	_memset
	mov	edi, DWORD PTR _def1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ctxt$[ebp+28], 9
	mov	eax, DWORD PTR [edi]
	cmp	eax, 4
	je	SHORT $LN4@xmlRelaxNG

; 3797 :     int ret = 1;
; 3798 :     xmlNode node;
; 3799 :     xmlNs ns;
; 3800 :     xmlRelaxNGValidCtxt ctxt;
; 3801 : 
; 3802 :     memset(&ctxt, 0, sizeof(xmlRelaxNGValidCtxt));
; 3803 : 
; 3804 :     ctxt.flags = FLAGS_IGNORABLE | FLAGS_NOERROR;
; 3805 : 
; 3806 :     if ((def1->type == XML_RELAXNG_ELEMENT) ||

	cmp	eax, 9
	je	SHORT $LN4@xmlRelaxNG

; 3828 :             } else {
; 3829 :                 ret = 0;
; 3830 :             }
; 3831 :         } else {
; 3832 :             ret = 1;
; 3833 :         }
; 3834 :     } else if (def1->type == XML_RELAXNG_TEXT) {

	cmp	eax, 3
	jne	SHORT $LN16@xmlRelaxNG

; 3835 :         if (def2->type == XML_RELAXNG_TEXT)

	mov	eax, DWORD PTR _def2$[ebp]
	cmp	DWORD PTR [eax], 3
	je	$LN39@xmlRelaxNG
$LN34@xmlRelaxNG:
	pop	edi

; 3877 :     }
; 3878 : 
; 3879 :     return (ret);
; 3880 : }

	mov	eax, 1
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlRelaxNG:

; 3836 :             return (0);
; 3837 :         return (1);
; 3838 :     } else if (def1->type == XML_RELAXNG_EXCEPT) {

	cmp	eax, 2
	jne	SHORT $LN19@xmlRelaxNG

; 3839 :         ret = xmlRelaxNGCompareNameClasses(def1->content, def2);

	mov	esi, DWORD PTR _def2$[ebp]
	push	esi
	push	DWORD PTR [edi+24]
	call	_xmlRelaxNGCompareNameClasses
	add	esp, 8

; 3840 : 	if (ret == 0)

	test	eax, eax
	je	$LN24@xmlRelaxNG

; 3841 : 	    ret = 1;
; 3842 : 	else if (ret == 1)

	cmp	eax, 1
	jne	SHORT $LN13@xmlRelaxNG

; 3877 :     }
; 3878 : 
; 3879 :     return (ret);
; 3880 : }

	pop	edi
	xor	eax, eax
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlRelaxNG:

; 3843 : 	    ret = 0;
; 3844 :     } else {
; 3845 :         TODO ret = 0;

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	3845					; 00000f05H
	jmp	$LN41@xmlRelaxNG
$LN4@xmlRelaxNG:

; 3807 :         (def1->type == XML_RELAXNG_ATTRIBUTE)) {
; 3808 :         if (def2->type == XML_RELAXNG_TEXT)

	mov	esi, DWORD PTR _def2$[ebp]
	cmp	DWORD PTR [esi], 3
	je	SHORT $LN34@xmlRelaxNG

; 3809 :             return (1);
; 3810 :         if (def1->name != NULL) {

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	mov	ecx, DWORD PTR _invalidName
	cmovne	ecx, eax

; 3811 :             node.name = def1->name;
; 3812 :         } else {
; 3813 :             node.name = invalidName;
; 3814 :         }
; 3815 :         if (def1->ns != NULL) {

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR _node$[ebp+8], ecx
	test	eax, eax
	je	SHORT $LN8@xmlRelaxNG

; 3816 :             if (def1->ns[0] == 0) {

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN8@xmlRelaxNG

; 3817 :                 node.ns = NULL;
; 3818 :             } else {
; 3819 : 	        node.ns = &ns;

	lea	ecx, DWORD PTR _ns$[ebp]

; 3820 :                 ns.href = def1->ns;

	mov	DWORD PTR _ns$[ebp+8], eax
	mov	DWORD PTR _node$[ebp+36], ecx

; 3821 :             }
; 3822 :         } else {

	jmp	SHORT $LN9@xmlRelaxNG
$LN8@xmlRelaxNG:

; 3823 :             node.ns = NULL;
; 3824 :         }
; 3825 :         if (xmlRelaxNGElementMatch(&ctxt, def2, &node)) {

	mov	DWORD PTR _node$[ebp+36], 0
$LN9@xmlRelaxNG:
	lea	eax, DWORD PTR _node$[ebp]
	push	eax
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	esi
	push	eax
	call	_xmlRelaxNGElementMatch
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN24@xmlRelaxNG

; 3826 :             if (def1->nameClass != NULL) {

	mov	eax, DWORD PTR [edi+40]
	test	eax, eax
	je	SHORT $LN39@xmlRelaxNG

; 3827 :                 ret = xmlRelaxNGCompareNameClasses(def1->nameClass, def2);

	push	esi
	push	eax
	call	_xmlRelaxNGCompareNameClasses
	add	esp, 8
$LN13@xmlRelaxNG:

; 3846 :     }
; 3847 :     if (ret == 0)

	test	eax, eax
	je	SHORT $LN39@xmlRelaxNG
$LN24@xmlRelaxNG:

; 3848 :         return (ret);
; 3849 :     if ((def2->type == XML_RELAXNG_ELEMENT) ||

	mov	eax, DWORD PTR [esi]
	cmp	eax, 4
	je	SHORT $LN27@xmlRelaxNG
	cmp	eax, 9
	je	SHORT $LN27@xmlRelaxNG

; 3869 :             } else {
; 3870 :                 ret = 0;
; 3871 :             }
; 3872 :         } else {
; 3873 :             ret = 1;
; 3874 :         }
; 3875 :     } else {
; 3876 :         TODO ret = 0;

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	3876					; 00000f24H
$LN41@xmlRelaxNG:

; 3877 :     }
; 3878 : 
; 3879 :     return (ret);
; 3880 : }

	push	OFFSET ??_C@_0GJ@NFABHKPN@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN39@xmlRelaxNG:
	pop	edi
	xor	eax, eax
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlRelaxNG:

; 3850 :         (def2->type == XML_RELAXNG_ATTRIBUTE)) {
; 3851 :         if (def2->name != NULL) {

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	mov	edx, DWORD PTR _invalidName
	mov	eax, edx
	cmovne	eax, ecx
	mov	DWORD PTR _node$[ebp+8], eax

; 3852 :             node.name = def2->name;
; 3853 :         } else {
; 3854 :             node.name = invalidName;
; 3855 :         }
; 3856 :         node.ns = &ns;

	lea	eax, DWORD PTR _ns$[ebp]
	mov	DWORD PTR _node$[ebp+36], eax

; 3857 :         if (def2->ns != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN30@xmlRelaxNG

; 3858 :             if (def2->ns[0] == 0) {

	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN32@xmlRelaxNG

; 3859 :                 node.ns = NULL;

	mov	DWORD PTR _node$[ebp+36], 0

; 3860 :             } else {

	jmp	SHORT $LN31@xmlRelaxNG
$LN32@xmlRelaxNG:

; 3861 :                 ns.href = def2->ns;

	mov	DWORD PTR _ns$[ebp+8], eax

; 3862 :             }
; 3863 :         } else {

	jmp	SHORT $LN31@xmlRelaxNG
$LN30@xmlRelaxNG:

; 3864 :             ns.href = invalidName;

	mov	DWORD PTR _ns$[ebp+8], edx
$LN31@xmlRelaxNG:

; 3865 :         }
; 3866 :         if (xmlRelaxNGElementMatch(&ctxt, def1, &node)) {

	lea	eax, DWORD PTR _node$[ebp]
	push	eax
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	edi
	push	eax
	call	_xmlRelaxNGElementMatch
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN34@xmlRelaxNG

; 3867 :             if (def2->nameClass != NULL) {

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN39@xmlRelaxNG

; 3868 :                 ret = xmlRelaxNGCompareNameClasses(def2->nameClass, def1);

	push	edi
	push	eax
	call	_xmlRelaxNGCompareNameClasses
	add	esp, 8
	pop	edi

; 3877 :     }
; 3878 : 
; 3879 :     return (ret);
; 3880 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGCompareNameClasses ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParseData
_TEXT	SEGMENT
_except$1$ = -16					; size = 4
_lastparam$1$ = -16					; size = 4
_content$1$ = -12					; size = 4
_library$1$ = -8					; size = 4
_def$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlRelaxNGParseData PROC				; COMDAT

; 3630 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _node$[ebp]
	push	OFFSET ??_C@_04GPMDFGEJ@type@
	push	edi
	mov	DWORD PTR _lastparam$1$[ebp], 0
	call	_xmlGetProp
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	SHORT $LN8@xmlRelaxNG

; 519  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	xor	edx, edx
	test	eax, eax
	je	SHORT $LN37@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN39@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [eax+4]
$LN39@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	esi, DWORD PTR [eax]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [eax+36]
$LN37@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	0
	push	OFFSET ??_C@_0BC@JLMCOJJL@data?5has?5no?5type?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1110					; 00000456H
	push	18					; 00000012H
	push	edi
	push	0
	push	esi
	push	edx
	push	ecx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 3631 :     xmlRelaxNGDefinePtr def = NULL, except;
; 3632 :     xmlRelaxNGDefinePtr param, lastparam = NULL;
; 3633 :     xmlRelaxNGTypeLibraryPtr lib;
; 3634 :     xmlChar *type;
; 3635 :     xmlChar *library;
; 3636 :     xmlNodePtr content;
; 3637 :     int tmp;
; 3638 : 
; 3639 :     type = xmlGetProp(node, BAD_CAST "type");
; 3640 :     if (type == NULL) {
; 3641 :         xmlRngPErr(ctxt, node, XML_RNGP_TYPE_MISSING, "data has no type\n", NULL,
; 3642 :                    NULL);
; 3643 :         return (NULL);

	xor	eax, eax
	pop	edi

; 3776 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlRelaxNG:
	push	ebx

; 3644 :     }
; 3645 :     xmlRelaxNGNormExtSpace(type);

	push	esi
	call	_xmlRelaxNGNormExtSpace

; 3646 :     if (xmlValidateNCName(type, 0)) {

	push	0
	push	esi
	call	_xmlValidateNCName
	mov	ebx, DWORD PTR _ctxt$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@xmlRelaxNG

; 3647 :         xmlRngPErr(ctxt, node, XML_RNGP_TYPE_VALUE,

	push	0
	push	esi
	push	OFFSET ??_C@_0CB@BPINBNAH@data?5type?5?8?$CFs?8?5is?5not?5an?5NCName@
	push	1112					; 00000458H
	push	edi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN9@xmlRelaxNG:

; 3648 :                    "data type '%s' is not an NCName\n", type, NULL);
; 3649 :     }
; 3650 :     library = xmlRelaxNGGetDataTypeLibrary(ctxt, node);

	push	edi
	push	ebx
	call	_xmlRelaxNGGetDataTypeLibrary
	add	esp, 8
	mov	DWORD PTR _library$1$[ebp], eax

; 3651 :     if (library == NULL)

	test	eax, eax
	jne	SHORT $LN10@xmlRelaxNG

; 3652 :         library =

	push	OFFSET ??_C@_0CE@EODHHDFK@http?3?1?1relaxng?4org?1ns?1structure@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _library$1$[ebp], eax
$LN10@xmlRelaxNG:

; 3653 :             xmlStrdup(BAD_CAST "http://relaxng.org/ns/structure/1.0");
; 3654 : 
; 3655 :     def = xmlRelaxNGNewDefine(ctxt, node);

	push	edi
	push	ebx
	call	_xmlRelaxNGNewDefine
	add	esp, 8
	mov	DWORD PTR _def$1$[ebp], eax

; 3656 :     if (def == NULL) {

	test	eax, eax
	jne	SHORT $LN11@xmlRelaxNG

; 3657 :         xmlFree(type);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3658 :         return (NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 3776 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlRelaxNG:

; 3659 :     }
; 3660 :     def->type = XML_RELAXNG_DATATYPE;
; 3661 :     def->name = type;

	mov	DWORD PTR [eax+8], esi

; 3662 :     def->ns = library;

	mov	esi, DWORD PTR _library$1$[ebp]

; 3663 : 
; 3664 :     lib = (xmlRelaxNGTypeLibraryPtr)

	push	esi
	push	DWORD PTR _xmlRelaxNGRegisteredTypes
	mov	DWORD PTR [eax], 5
	mov	DWORD PTR [eax+12], esi
	call	_xmlHashLookup
	add	esp, 8

; 3665 :         xmlHashLookup(xmlRelaxNGRegisteredTypes, library);
; 3666 :     if (lib == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlRelaxNG

; 3667 :         xmlRngPErr(ctxt, node, XML_RNGP_UNKNOWN_TYPE_LIB,

	push	eax
	push	esi
	push	OFFSET ??_C@_0CH@BAFMNDJC@Use?5of?5unregistered?5type?5librar@
	push	1116					; 0000045cH
	push	edi
	push	ebx
	call	_xmlRngPErr

; 3668 :                    "Use of unregistered type library '%s'\n", library,
; 3669 :                    NULL);
; 3670 :         def->data = NULL;

	mov	ecx, DWORD PTR _def$1$[ebp]
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ecx+20], 0

; 3671 :     } else {

	jmp	$LN18@xmlRelaxNG
$LN12@xmlRelaxNG:

; 3672 :         def->data = lib;

	mov	edx, DWORD PTR _def$1$[ebp]
	mov	DWORD PTR [edx+20], eax

; 3673 :         if (lib->have == NULL) {

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	jne	SHORT $LN14@xmlRelaxNG

; 3674 :             xmlRngPErr(ctxt, node, XML_RNGP_ERROR_TYPE_LIB,

	push	ecx
	push	esi
	push	OFFSET ??_C@_0DC@GFLCPBDN@Internal?5error?5with?5type?5librar@
	push	1026					; 00000402H
	push	edi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 3675 :                        "Internal error with type library '%s': no 'have'\n",
; 3676 :                        library, NULL);
; 3677 :         } else {

	jmp	SHORT $LN18@xmlRelaxNG
$LN14@xmlRelaxNG:

; 3678 :             tmp = lib->have(lib->data, def->name);

	push	DWORD PTR [edx+8]
	push	DWORD PTR [eax+4]
	call	ecx
	add	esp, 8

; 3679 :             if (tmp != 1) {

	cmp	eax, 1
	je	SHORT $LN16@xmlRelaxNG

; 3680 :                 xmlRngPErr(ctxt, node, XML_RNGP_TYPE_NOT_FOUND,

	mov	ecx, DWORD PTR _def$1$[ebp]
	push	esi
	push	DWORD PTR [ecx+8]
	push	OFFSET ??_C@_0DG@BCJPPODI@Error?5type?5?8?$CFs?8?5is?5not?5exported@
	push	1111					; 00000457H
	push	edi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 3681 :                            "Error type '%s' is not exported by type library '%s'\n",
; 3682 :                            def->name, library);
; 3683 :             } else

	jmp	SHORT $LN18@xmlRelaxNG
$LN16@xmlRelaxNG:

; 3684 :                 if ((xmlStrEqual
; 3685 :                      (library,
; 3686 :                       BAD_CAST
; 3687 :                       "http://www.w3.org/2001/XMLSchema-datatypes"))
; 3688 :                     && ((xmlStrEqual(def->name, BAD_CAST "IDREF"))

	push	OFFSET ??_C@_0CL@MAOGIMDF@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlRelaxNG
	mov	esi, DWORD PTR _def$1$[ebp]
	push	OFFSET ??_C@_05HKGPJLPA@IDREF@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@xmlRelaxNG
	push	OFFSET ??_C@_06CMFBJDBA@IDREFS@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlRelaxNG
$LN19@xmlRelaxNG:

; 3689 :                         || (xmlStrEqual(def->name, BAD_CAST "IDREFS")))) {
; 3690 :                 ctxt->idref = 1;

	mov	DWORD PTR [ebx+128], 1
$LN18@xmlRelaxNG:

; 3691 :             }
; 3692 :         }
; 3693 :     }
; 3694 :     content = node->children;

	mov	esi, DWORD PTR [edi+12]
	mov	DWORD PTR _content$1$[ebp], esi

; 3695 : 
; 3696 :     /*
; 3697 :      * Handle optional params
; 3698 :      */
; 3699 :     while (content != NULL) {

	test	esi, esi
	je	$LN34@xmlRelaxNG
$LL2@xmlRelaxNG:

; 3700 :         if (!xmlStrEqual(content->name, BAD_CAST "param"))

	push	OFFSET ??_C@_05LJDNNBIK@param@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN49@xmlRelaxNG

; 3701 :             break;
; 3702 :         if (xmlStrEqual(library,

	push	OFFSET ??_C@_0CE@EODHHDFK@http?3?1?1relaxng?4org?1ns?1structure@
	push	DWORD PTR _library$1$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN21@xmlRelaxNG

; 515  :     xmlStructuredErrorFunc schannel = NULL;

	xor	eax, eax

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	ecx, ecx

; 517  :     void *data = NULL;

	xor	edx, edx

; 518  : 
; 519  :     if (ctxt != NULL) {

	test	ebx, ebx
	je	SHORT $LN42@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [ebx+12]
	test	eax, eax
	jne	SHORT $LN44@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	ecx, DWORD PTR [ebx+4]
$LN44@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	edx, DWORD PTR [ebx]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [ebx+36]
$LN42@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	DWORD PTR _library$1$[ebp]
	push	OFFSET ??_C@_0DC@MKALBABO@Type?5library?5?8?$CFs?8?5does?5not?5allo@
	push	0
	push	0
	push	0
	push	0
	push	DWORD PTR _library$1$[ebp]
	push	0
	push	0
	push	2
	push	1058					; 00000422H
	push	18					; 00000012H
	push	edi
	push	0
	push	edx
	push	ecx
	push	eax
	call	___xmlRaiseError

; 3703 :                         BAD_CAST "http://relaxng.org/ns/structure/1.0")) {
; 3704 :             xmlRngPErr(ctxt, node, XML_RNGP_PARAM_FORBIDDEN,
; 3705 :                        "Type library '%s' does not allow type parameters\n",
; 3706 :                        library, NULL);
; 3707 :             content = content->next;

	mov	esi, DWORD PTR [esi+24]

; 527  :     __xmlRaiseError(schannel, channel, data,

	add	esp, 72					; 00000048H

; 3703 :                         BAD_CAST "http://relaxng.org/ns/structure/1.0")) {
; 3704 :             xmlRngPErr(ctxt, node, XML_RNGP_PARAM_FORBIDDEN,
; 3705 :                        "Type library '%s' does not allow type parameters\n",
; 3706 :                        library, NULL);
; 3707 :             content = content->next;

	mov	DWORD PTR _content$1$[ebp], esi

; 3708 :             while ((content != NULL) &&

	test	esi, esi
	je	$LN34@xmlRelaxNG
	npad	6
$LL4@xmlRelaxNG:
	push	OFFSET ??_C@_05LJDNNBIK@param@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN22@xmlRelaxNG

; 3709 :                    (xmlStrEqual(content->name, BAD_CAST "param")))
; 3710 :                 content = content->next;

	mov	esi, DWORD PTR [esi+24]
	mov	DWORD PTR _content$1$[ebp], esi
	test	esi, esi
	jne	SHORT $LL4@xmlRelaxNG

; 3771 :                    "Element data has unexpected content %s\n",
; 3772 :                    content->name, NULL);
; 3773 :     }
; 3774 : 
; 3775 :     return (def);

	mov	eax, DWORD PTR _def$1$[ebp]
	pop	ebx
	pop	edi

; 3776 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlRelaxNG:

; 3711 :         } else {
; 3712 :             param = xmlRelaxNGNewDefine(ctxt, node);

	push	edi
	push	ebx
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8

; 3713 :             if (param != NULL) {

	test	edi, edi
	je	SHORT $LN26@xmlRelaxNG

; 3714 :                 param->type = XML_RELAXNG_PARAM;
; 3715 :                 param->name = xmlGetProp(content, BAD_CAST "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	esi
	mov	DWORD PTR [edi], 6
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR [edi+8], eax

; 3716 :                 if (param->name == NULL) {

	test	eax, eax
	jne	SHORT $LN24@xmlRelaxNG

; 3717 :                     xmlRngPErr(ctxt, node, XML_RNGP_PARAM_NAME_MISSING,

	push	eax
	push	eax
	push	OFFSET ??_C@_0BD@HHALNFAB@param?5has?5no?5name?6@
	push	1059					; 00000423H
	push	DWORD PTR _node$[ebp]
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN24@xmlRelaxNG:

; 3718 :                                "param has no name\n", NULL, NULL);
; 3719 :                 }
; 3720 :                 param->value = xmlNodeGetContent(content);

	push	esi
	call	_xmlNodeGetContent
	mov	DWORD PTR [edi+16], eax
	add	esp, 4

; 3721 :                 if (lastparam == NULL) {

	mov	eax, DWORD PTR _lastparam$1$[ebp]
	mov	DWORD PTR _lastparam$1$[ebp], edi
	test	eax, eax
	jne	SHORT $LN25@xmlRelaxNG

; 3722 :                     def->attrs = lastparam = param;

	mov	eax, DWORD PTR _def$1$[ebp]
	mov	DWORD PTR [eax+36], edi

; 3723 :                 } else {

	jmp	SHORT $LN26@xmlRelaxNG
$LN25@xmlRelaxNG:

; 3724 :                     lastparam->next = param;

	mov	DWORD PTR [eax+32], edi
$LN26@xmlRelaxNG:

; 3725 :                     lastparam = param;
; 3726 :                 }
; 3727 :                 if (lib != NULL) {
; 3728 :                 }
; 3729 :             }
; 3730 :             content = content->next;

	mov	esi, DWORD PTR [esi+24]
	mov	edi, DWORD PTR _node$[ebp]
	mov	DWORD PTR _content$1$[ebp], esi
$LN22@xmlRelaxNG:

; 3695 : 
; 3696 :     /*
; 3697 :      * Handle optional params
; 3698 :      */
; 3699 :     while (content != NULL) {

	test	esi, esi
	jne	$LL2@xmlRelaxNG

; 3771 :                    "Element data has unexpected content %s\n",
; 3772 :                    content->name, NULL);
; 3773 :     }
; 3774 : 
; 3775 :     return (def);

	mov	eax, DWORD PTR _def$1$[ebp]
	pop	ebx
	pop	edi

; 3776 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@xmlRelaxNG:

; 3731 :         }
; 3732 :     }
; 3733 :     /*
; 3734 :      * Handle optional except
; 3735 :      */
; 3736 :     if ((content != NULL)
; 3737 :         && (xmlStrEqual(content->name, BAD_CAST "except"))) {

	push	OFFSET ??_C@_06JBKEBCGB@except@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN28@xmlRelaxNG

; 3738 :         xmlNodePtr child;
; 3739 :         xmlRelaxNGDefinePtr tmp2, last = NULL;
; 3740 : 
; 3741 :         except = xmlRelaxNGNewDefine(ctxt, node);

	push	edi
	push	ebx
	call	_xmlRelaxNGNewDefine
	add	esp, 8
	mov	DWORD PTR _except$1$[ebp], eax

; 3742 :         if (except == NULL) {

	test	eax, eax
	je	SHORT $LN34@xmlRelaxNG

; 3743 :             return (def);
; 3744 :         }
; 3745 :         except->type = XML_RELAXNG_EXCEPT;
; 3746 :         child = content->children;
; 3747 : 	def->content = except;

	mov	ecx, DWORD PTR _def$1$[ebp]
	mov	DWORD PTR [eax], 2
	mov	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+24], eax

; 3748 :         if (child == NULL) {

	test	edi, edi
	jne	SHORT $LN67@xmlRelaxNG

; 3749 :             xmlRngPErr(ctxt, content, XML_RNGP_EXCEPT_NO_CONTENT,

	push	edi
	push	edi
	push	OFFSET ??_C@_0BH@BGPIOKNJ@except?5has?5no?5content?6@
	push	1030					; 00000406H
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 3750 :                        "except has no content\n", NULL, NULL);
; 3751 :         }
; 3752 :         while (child != NULL) {

	jmp	SHORT $LN7@xmlRelaxNG
$LN67@xmlRelaxNG:
	xor	esi, esi
	npad	3
$LL6@xmlRelaxNG:

; 3753 :             tmp2 = xmlRelaxNGParsePattern(ctxt, child);

	push	edi
	push	ebx
	call	_xmlRelaxNGParsePattern
	add	esp, 8

; 3754 :             if (tmp2 != NULL) {

	test	eax, eax
	je	SHORT $LN33@xmlRelaxNG

; 3755 :                 if (last == NULL) {

	test	esi, esi
	jne	SHORT $LN32@xmlRelaxNG

; 3756 :                     except->content = last = tmp2;

	mov	ecx, DWORD PTR _except$1$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 3757 :                 } else {

	jmp	SHORT $LN69@xmlRelaxNG
$LN32@xmlRelaxNG:

; 3758 :                     last->next = tmp2;

	mov	DWORD PTR [esi+32], eax
$LN69@xmlRelaxNG:

; 3759 :                     last = tmp2;
; 3760 :                 }
; 3761 :             }
; 3762 :             child = child->next;

	mov	esi, eax
$LN33@xmlRelaxNG:
	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	SHORT $LL6@xmlRelaxNG
	mov	esi, DWORD PTR _content$1$[ebp]
$LN7@xmlRelaxNG:

; 3763 :         }
; 3764 :         content = content->next;

	mov	esi, DWORD PTR [esi+24]
$LN28@xmlRelaxNG:

; 3765 :     }
; 3766 :     /*
; 3767 :      * Check there is no unhandled data
; 3768 :      */
; 3769 :     if (content != NULL) {

	test	esi, esi
	je	SHORT $LN34@xmlRelaxNG

; 3770 :         xmlRngPErr(ctxt, content, XML_RNGP_DATA_CONTENT,

	push	0
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0CI@PINMOFEF@Element?5data?5has?5unexpected?5con@
	push	1009					; 000003f1H
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN34@xmlRelaxNG:

; 3771 :                    "Element data has unexpected content %s\n",
; 3772 :                    content->name, NULL);
; 3773 :     }
; 3774 : 
; 3775 :     return (def);

	mov	eax, DWORD PTR _def$1$[ebp]
	pop	ebx
	pop	edi

; 3776 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGParseData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParseValue
_TEXT	SEGMENT
_success$1$ = -16					; size = 4
_val$1 = -16						; size = 4
_lib$1$ = -12						; size = 4
_type$1$ = -8						; size = 4
_library$1$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlRelaxNGParseValue PROC				; COMDAT

; 3538 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _node$[ebp]
	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	edi
	push	ebx
	mov	DWORD PTR _lib$1$[ebp], 0
	mov	DWORD PTR _success$1$[ebp], 0
	call	_xmlRelaxNGNewDefine
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	SHORT $LN2@xmlRelaxNG

; 3617 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlRelaxNG:

; 3539 :     xmlRelaxNGDefinePtr def = NULL;
; 3540 :     xmlRelaxNGTypeLibraryPtr lib = NULL;
; 3541 :     xmlChar *type;
; 3542 :     xmlChar *library;
; 3543 :     int success = 0;
; 3544 : 
; 3545 :     def = xmlRelaxNGNewDefine(ctxt, node);
; 3546 :     if (def == NULL)
; 3547 :         return (NULL);
; 3548 :     def->type = XML_RELAXNG_VALUE;
; 3549 : 
; 3550 :     type = xmlGetProp(node, BAD_CAST "type");

	push	OFFSET ??_C@_04GPMDFGEJ@type@
	push	edi
	mov	DWORD PTR [esi], 7
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _type$1$[ebp], eax

; 3551 :     if (type != NULL) {

	test	eax, eax
	je	$LN10@xmlRelaxNG

; 3552 :         xmlRelaxNGNormExtSpace(type);

	push	eax
	call	_xmlRelaxNGNormExtSpace

; 3553 :         if (xmlValidateNCName(type, 0)) {

	push	0
	push	DWORD PTR _type$1$[ebp]
	call	_xmlValidateNCName
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@xmlRelaxNG

; 3554 :             xmlRngPErr(ctxt, node, XML_RNGP_TYPE_VALUE,

	push	0
	push	DWORD PTR _type$1$[ebp]
	push	OFFSET ??_C@_0CC@HGJHHNGH@value?5type?5?8?$CFs?8?5is?5not?5an?5NCNam@
	push	1112					; 00000458H
	push	edi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN4@xmlRelaxNG:

; 3555 :                        "value type '%s' is not an NCName\n", type, NULL);
; 3556 :         }
; 3557 :         library = xmlRelaxNGGetDataTypeLibrary(ctxt, node);

	push	edi
	push	ebx
	call	_xmlRelaxNGGetDataTypeLibrary
	add	esp, 8
	mov	DWORD PTR _library$1$[ebp], eax

; 3558 :         if (library == NULL)

	test	eax, eax
	jne	SHORT $LN5@xmlRelaxNG

; 3559 :             library =

	push	OFFSET ??_C@_0CE@EODHHDFK@http?3?1?1relaxng?4org?1ns?1structure@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _library$1$[ebp], eax
$LN5@xmlRelaxNG:

; 3560 :                 xmlStrdup(BAD_CAST "http://relaxng.org/ns/structure/1.0");
; 3561 : 
; 3562 :         def->name = type;

	mov	ecx, DWORD PTR _type$1$[ebp]

; 3563 :         def->ns = library;
; 3564 : 
; 3565 :         lib = (xmlRelaxNGTypeLibraryPtr)

	push	eax
	push	DWORD PTR _xmlRelaxNGRegisteredTypes
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], eax
	call	_xmlHashLookup
	add	esp, 8
	mov	DWORD PTR _lib$1$[ebp], eax

; 3566 :             xmlHashLookup(xmlRelaxNGRegisteredTypes, library);
; 3567 :         if (lib == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlRelaxNG

; 3568 :             xmlRngPErr(ctxt, node, XML_RNGP_UNKNOWN_TYPE_LIB,

	push	eax
	push	DWORD PTR _library$1$[ebp]
	push	OFFSET ??_C@_0CH@BAFMNDJC@Use?5of?5unregistered?5type?5librar@
	push	1116					; 0000045cH
	push	edi
	push	ebx
	call	_xmlRngPErr

; 3569 :                        "Use of unregistered type library '%s'\n", library,
; 3570 :                        NULL);
; 3571 :             def->data = NULL;

	mov	DWORD PTR [esi+20], 0

; 3572 :         } else {

	jmp	SHORT $LN25@xmlRelaxNG
$LN6@xmlRelaxNG:

; 3573 :             def->data = lib;

	mov	DWORD PTR [esi+20], eax

; 3574 :             if (lib->have == NULL) {

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	jne	SHORT $LN8@xmlRelaxNG

; 3575 :                 xmlRngPErr(ctxt, node, XML_RNGP_ERROR_TYPE_LIB,

	push	ecx
	push	DWORD PTR _library$1$[ebp]
	push	OFFSET ??_C@_0DC@GFLCPBDN@Internal?5error?5with?5type?5librar@
	push	1026					; 00000402H

; 3576 :                            "Internal error with type library '%s': no 'have'\n",
; 3577 :                            library, NULL);
; 3578 :             } else {

	jmp	SHORT $LN26@xmlRelaxNG
$LN8@xmlRelaxNG:

; 3579 :                 success = lib->have(lib->data, def->name);

	push	DWORD PTR [esi+8]
	push	DWORD PTR [eax+4]
	call	ecx
	add	esp, 8
	mov	DWORD PTR _success$1$[ebp], eax

; 3580 :                 if (success != 1) {

	cmp	eax, 1
	je	SHORT $LN10@xmlRelaxNG

; 3581 :                     xmlRngPErr(ctxt, node, XML_RNGP_TYPE_NOT_FOUND,

	push	DWORD PTR _library$1$[ebp]
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0DG@BCJPPODI@Error?5type?5?8?$CFs?8?5is?5not?5exported@
	push	1111					; 00000457H
$LN26@xmlRelaxNG:

; 3582 :                                "Error type '%s' is not exported by type library '%s'\n",
; 3583 :                                def->name, library);
; 3584 :                 }
; 3585 :             }
; 3586 :         }
; 3587 :     }
; 3588 :     if (node->children == NULL) {

	push	edi
	push	ebx
	call	_xmlRngPErr
$LN25@xmlRelaxNG:
	add	esp, 24					; 00000018H
$LN10@xmlRelaxNG:
	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	jne	SHORT $LN11@xmlRelaxNG

; 3589 :         def->value = xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+16], eax

; 3613 :             }
; 3614 :         }
; 3615 :     }
; 3616 :     return (def);

	mov	eax, esi
	pop	edi

; 3617 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlRelaxNG:

; 3590 :     } else if (((node->children->type != XML_TEXT_NODE) &&
; 3591 :                 (node->children->type != XML_CDATA_SECTION_NODE)) ||

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 3
	je	SHORT $LN16@xmlRelaxNG
	cmp	ecx, 4
	jne	SHORT $LN15@xmlRelaxNG
$LN16@xmlRelaxNG:
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN13@xmlRelaxNG
$LN15@xmlRelaxNG:

; 3592 :                (node->children->next != NULL)) {
; 3593 :         xmlRngPErr(ctxt, node, XML_RNGP_TEXT_EXPECTED,

	push	0
	push	0
	push	OFFSET ??_C@_0DC@DOAINIPC@Expecting?5a?5single?5text?5value?5f@
	push	1108					; 00000454H
	push	edi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 3613 :             }
; 3614 :         }
; 3615 :     }
; 3616 :     return (def);

	mov	eax, esi
	pop	edi

; 3617 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlRelaxNG:

; 3594 :                    "Expecting a single text value for <value>content\n",
; 3595 :                    NULL, NULL);
; 3596 :     } else if (def != NULL) {
; 3597 :         def->value = xmlNodeGetContent(node);

	push	edi
	call	_xmlNodeGetContent
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [esi+16], ecx

; 3598 :         if (def->value == NULL) {

	test	ecx, ecx
	jne	SHORT $LN18@xmlRelaxNG

; 3599 :             xmlRngPErr(ctxt, node, XML_RNGP_VALUE_NO_CONTENT,

	push	eax
	push	eax
	push	OFFSET ??_C@_0CA@OGDHDPEE@Element?5?$DMvalue?$DO?5has?5no?5content?6@
	push	1120					; 00000460H
	push	edi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 3613 :             }
; 3614 :         }
; 3615 :     }
; 3616 :     return (def);

	mov	eax, esi
	pop	edi

; 3617 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlRelaxNG:

; 3600 :                        "Element <value> has no content\n", NULL, NULL);
; 3601 :         } else if ((lib != NULL) && (lib->check != NULL) && (success == 1)) {

	mov	eax, DWORD PTR _lib$1$[ebp]
	test	eax, eax
	je	SHORT $LN23@xmlRelaxNG
	mov	edx, DWORD PTR [eax+12]
	test	edx, edx
	je	SHORT $LN23@xmlRelaxNG
	cmp	DWORD PTR _success$1$[ebp], 1
	jne	SHORT $LN23@xmlRelaxNG

; 3602 :             void *val = NULL;
; 3603 : 
; 3604 :             success =

	push	edi
	lea	ebx, DWORD PTR _val$1[ebp]
	mov	DWORD PTR _val$1[ebp], 0
	push	ebx
	push	ecx
	push	DWORD PTR [esi+8]
	push	DWORD PTR [eax+4]
	call	edx

; 3605 :                 lib->check(lib->data, def->name, def->value, &val, node);
; 3606 :             if (success != 1) {

	mov	ebx, DWORD PTR _ctxt$[ebp]
	add	esp, 20					; 00000014H
	cmp	eax, 1
	je	SHORT $LN21@xmlRelaxNG

; 3607 :                 xmlRngPErr(ctxt, node, XML_RNGP_INVALID_VALUE,

	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+16]
	push	OFFSET ??_C@_0CM@DOBLDJBI@Value?5?8?$CFs?8?5is?5not?5acceptable?5fo@
	push	1051					; 0000041bH
	push	edi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 3613 :             }
; 3614 :         }
; 3615 :     }
; 3616 :     return (def);

	mov	eax, esi
	pop	edi

; 3617 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlRelaxNG:

; 3608 :                            "Value '%s' is not acceptable for type '%s'\n",
; 3609 :                            def->value, def->name);
; 3610 :             } else {
; 3611 :                 if (val != NULL)

	mov	eax, DWORD PTR _val$1[ebp]
	test	eax, eax
	je	SHORT $LN23@xmlRelaxNG

; 3612 :                     def->attrs = val;

	mov	DWORD PTR [esi+36], eax
$LN23@xmlRelaxNG:
	pop	edi

; 3613 :             }
; 3614 :         }
; 3615 :     }
; 3616 :     return (def);

	mov	eax, esi

; 3617 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGParseValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGGetDataTypeLibrary
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlRelaxNGGetDataTypeLibrary PROC			; COMDAT

; 3486 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	$LN3@xmlRelaxNG

; 3487 :     xmlChar *ret, *escape;
; 3488 : 
; 3489 :     if (node == NULL)
; 3490 :         return(NULL);
; 3491 : 
; 3492 :     if ((IS_RELAXNG(node, "data")) || (IS_RELAXNG(node, "value"))) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN8@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN7@xmlRelaxNG
	push	OFFSET ??_C@_04PJOLNDGD@data@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@xmlRelaxNG
$LN7@xmlRelaxNG:
	cmp	DWORD PTR [esi+36], 0
	je	$LN8@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN8@xmlRelaxNG
	push	OFFSET ??_C@_05MFEJDJP@value@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlRelaxNG
$LN6@xmlRelaxNG:

; 3493 :         ret = xmlGetProp(node, BAD_CAST "datatypeLibrary");

	push	OFFSET ??_C@_0BA@OLOJGOCH@datatypeLibrary@
	push	esi
	call	_xmlGetProp
	mov	edi, eax
	add	esp, 8

; 3494 :         if (ret != NULL) {

	test	edi, edi
	je	SHORT $LN8@xmlRelaxNG

; 3495 :             if (ret[0] == 0) {

	cmp	BYTE PTR [edi], 0
	jne	SHORT $LN9@xmlRelaxNG
$LN21@xmlRelaxNG:

; 3523 :     }
; 3524 :     return (NULL);
; 3525 : }

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlRelaxNG:
	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN9@xmlRelaxNG:
	push	OFFSET ??_C@_04EIMIMFCI@?3?1?$CD?$DP@
	push	edi
	call	_xmlURIEscapeStr
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	SHORT $LN10@xmlRelaxNG
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN10@xmlRelaxNG:
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN8@xmlRelaxNG:

; 3496 :                 xmlFree(ret);
; 3497 :                 return (NULL);
; 3498 :             }
; 3499 :             escape = xmlURIEscapeStr(ret, BAD_CAST ":/#?");
; 3500 :             if (escape == NULL) {
; 3501 :                 return (ret);
; 3502 :             }
; 3503 :             xmlFree(ret);
; 3504 :             return (escape);
; 3505 :         }
; 3506 :     }
; 3507 :     node = node->parent;

	mov	esi, DWORD PTR [esi+20]

; 3508 :     while ((node != NULL) && (node->type == XML_ELEMENT_NODE)) {

	test	esi, esi
	je	SHORT $LN3@xmlRelaxNG
	npad	4
$LL2@xmlRelaxNG:
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN3@xmlRelaxNG

; 3509 :         ret = xmlGetProp(node, BAD_CAST "datatypeLibrary");

	push	OFFSET ??_C@_0BA@OLOJGOCH@datatypeLibrary@
	push	esi
	call	_xmlGetProp
	mov	edi, eax
	add	esp, 8

; 3510 :         if (ret != NULL) {

	test	edi, edi
	jne	SHORT $LN16@xmlRelaxNG

; 3518 :             }
; 3519 :             xmlFree(ret);
; 3520 :             return (escape);
; 3521 :         }
; 3522 :         node = node->parent;

	mov	esi, DWORD PTR [esi+20]
	test	esi, esi
	jne	SHORT $LL2@xmlRelaxNG

; 3523 :     }
; 3524 :     return (NULL);
; 3525 : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN16@xmlRelaxNG:

; 3511 :             if (ret[0] == 0) {

	cmp	BYTE PTR [edi], 0
	je	SHORT $LN21@xmlRelaxNG

; 3512 :                 xmlFree(ret);
; 3513 :                 return (NULL);
; 3514 :             }
; 3515 :             escape = xmlURIEscapeStr(ret, BAD_CAST ":/#?");
; 3516 :             if (escape == NULL) {
; 3517 :                 return (ret);

	jmp	SHORT $LN9@xmlRelaxNG
_xmlRelaxNGGetDataTypeLibrary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGIsBlank
_TEXT	SEGMENT
_str$ = 8						; size = 4
_xmlRelaxNGIsBlank PROC					; COMDAT

; 3463 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _str$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@xmlRelaxNG

; 3464 :     if (str == NULL)
; 3465 :         return (1);
; 3466 :     while (*str != 0) {

	mov	al, BYTE PTR [ecx]
	test	al, al
	je	SHORT $LN13@xmlRelaxNG
	npad	6
$LL2@xmlRelaxNG:

; 3467 :         if (!(IS_BLANK_CH(*str)))

	cmp	al, 32					; 00000020H
	je	SHORT $LN5@xmlRelaxNG
	cmp	al, 9
	jb	SHORT $LN6@xmlRelaxNG
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN5@xmlRelaxNG
$LN6@xmlRelaxNG:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN9@xmlRelaxNG
$LN5@xmlRelaxNG:

; 3464 :     if (str == NULL)
; 3465 :         return (1);
; 3466 :     while (*str != 0) {

	mov	al, BYTE PTR [ecx+1]

; 3469 :         str++;

	inc	ecx
	test	al, al
	jne	SHORT $LL2@xmlRelaxNG
$LN13@xmlRelaxNG:

; 3470 :     }
; 3471 :     return (1);

	mov	eax, 1

; 3472 : }

	pop	ebp
	ret	0
$LN9@xmlRelaxNG:

; 3468 :             return (0);

	xor	eax, eax

; 3472 : }

	pop	ebp
	ret	0
_xmlRelaxNGIsBlank ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGIsNullable
_TEXT	SEGMENT
_define$ = 8						; size = 4
_xmlRelaxNGIsNullable PROC				; COMDAT

; 3384 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _define$[ebp]
	test	edi, edi
	je	$LN18@xmlRelaxNG

; 3385 :     int ret;
; 3386 : 
; 3387 :     if (define == NULL)
; 3388 :         return (-1);
; 3389 : 
; 3390 :     if (define->dflags & IS_NULLABLE)

	movzx	eax, WORD PTR [edi+50]
	test	al, 1
	jne	$LN7@xmlRelaxNG

; 3391 :         return (1);
; 3392 :     if (define->dflags & IS_NOT_NULLABLE)

	test	al, 2
	je	SHORT $LN10@xmlRelaxNG

; 3393 :         return (0);

	pop	edi
	xor	eax, eax

; 3450 :     return (ret);
; 3451 : }

	pop	esi
	pop	ebp
	ret	0
$LN10@xmlRelaxNG:

; 3394 :     switch (define->type) {

	mov	eax, DWORD PTR [edi]
	inc	eax
	cmp	eax, 21					; 00000015H
	ja	$LN18@xmlRelaxNG
	movzx	eax, BYTE PTR $LN35@xmlRelaxNG[eax]
	jmp	DWORD PTR $LN37@xmlRelaxNG[eax*4]
$LN11@xmlRelaxNG:

; 3395 :         case XML_RELAXNG_EMPTY:
; 3396 :         case XML_RELAXNG_TEXT:
; 3397 :             ret = 1;

	mov	eax, 1

; 3449 :         define->dflags |= IS_NULLABLE;

	or	WORD PTR [edi+50], ax
	pop	edi

; 3450 :     return (ret);
; 3451 : }

	pop	esi
	pop	ebp
	ret	0
$LN12@xmlRelaxNG:

; 3398 :             break;
; 3399 :         case XML_RELAXNG_NOOP:
; 3400 :         case XML_RELAXNG_DEF:
; 3401 :         case XML_RELAXNG_REF:
; 3402 :         case XML_RELAXNG_EXTERNALREF:
; 3403 :         case XML_RELAXNG_PARENTREF:
; 3404 :         case XML_RELAXNG_ONEORMORE:
; 3405 :             ret = xmlRelaxNGIsNullable(define->content);

	push	DWORD PTR [edi+24]
	call	_xmlRelaxNGIsNullable
	add	esp, 4
$done$38:

; 3444 :     }
; 3445 :   done:
; 3446 :     if (ret == 0)

	test	eax, eax
	jne	SHORT $LN30@xmlRelaxNG

; 3447 :         define->dflags |= IS_NOT_NULLABLE;

	or	WORD PTR [edi+50], 2
	pop	edi

; 3450 :     return (ret);
; 3451 : }

	pop	esi
	pop	ebp
	ret	0
$LN14@xmlRelaxNG:

; 3406 :             break;
; 3407 :         case XML_RELAXNG_EXCEPT:
; 3408 :         case XML_RELAXNG_NOT_ALLOWED:
; 3409 :         case XML_RELAXNG_ELEMENT:
; 3410 :         case XML_RELAXNG_DATATYPE:
; 3411 :         case XML_RELAXNG_PARAM:
; 3412 :         case XML_RELAXNG_VALUE:
; 3413 :         case XML_RELAXNG_LIST:
; 3414 :         case XML_RELAXNG_ATTRIBUTE:
; 3415 :             ret = 0;
; 3416 :             break;
; 3417 :         case XML_RELAXNG_CHOICE:{
; 3418 :                 xmlRelaxNGDefinePtr list = define->content;

	mov	esi, DWORD PTR [edi+24]

; 3419 : 
; 3420 :                 while (list != NULL) {

	test	esi, esi
	je	SHORT $LN13@xmlRelaxNG
$LL4@xmlRelaxNG:

; 3421 :                     ret = xmlRelaxNGIsNullable(list);

	push	esi
	call	_xmlRelaxNGIsNullable
	add	esp, 4

; 3422 :                     if (ret != 0)

	test	eax, eax
	jne	SHORT $LN30@xmlRelaxNG

; 3423 :                         goto done;
; 3424 :                     list = list->next;

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL4@xmlRelaxNG
$LN13@xmlRelaxNG:

; 3447 :         define->dflags |= IS_NOT_NULLABLE;

	xor	eax, eax
	or	WORD PTR [edi+50], 2
	pop	edi

; 3450 :     return (ret);
; 3451 : }

	pop	esi
	pop	ebp
	ret	0
$LN16@xmlRelaxNG:

; 3425 :                 }
; 3426 :                 ret = 0;
; 3427 :                 break;
; 3428 :             }
; 3429 :         case XML_RELAXNG_START:
; 3430 :         case XML_RELAXNG_INTERLEAVE:
; 3431 :         case XML_RELAXNG_GROUP:{
; 3432 :                 xmlRelaxNGDefinePtr list = define->content;

	mov	esi, DWORD PTR [edi+24]

; 3433 : 
; 3434 :                 while (list != NULL) {

	test	esi, esi
	je	SHORT $LN7@xmlRelaxNG
	npad	4
$LL6@xmlRelaxNG:

; 3435 :                     ret = xmlRelaxNGIsNullable(list);

	push	esi
	call	_xmlRelaxNGIsNullable
	add	esp, 4

; 3436 :                     if (ret != 1)

	cmp	eax, 1
	jne	SHORT $done$38

; 3437 :                         goto done;
; 3438 :                     list = list->next;

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL6@xmlRelaxNG
$LN7@xmlRelaxNG:
	pop	edi

; 3439 :                 }
; 3440 :                 return (1);

	mov	eax, 1

; 3450 :     return (ret);
; 3451 : }

	pop	esi
	pop	ebp
	ret	0
$LN30@xmlRelaxNG:

; 3448 :     if (ret == 1)

	cmp	eax, 1
	jne	SHORT $LN1@xmlRelaxNG

; 3449 :         define->dflags |= IS_NULLABLE;

	or	WORD PTR [edi+50], ax
	pop	edi

; 3450 :     return (ret);
; 3451 : }

	pop	esi
	pop	ebp
	ret	0
$LN18@xmlRelaxNG:

; 3441 :             }
; 3442 :         default:
; 3443 :             return (-1);

	or	eax, -1
$LN1@xmlRelaxNG:
	pop	edi

; 3450 :     return (ret);
; 3451 : }

	pop	esi
	pop	ebp
	ret	0
	npad	2
$LN37@xmlRelaxNG:
	DD	$LN12@xmlRelaxNG
	DD	$LN11@xmlRelaxNG
	DD	$LN13@xmlRelaxNG
	DD	$LN14@xmlRelaxNG
	DD	$LN16@xmlRelaxNG
	DD	$LN18@xmlRelaxNG
$LN35@xmlRelaxNG:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	0
	DB	0
	DB	0
	DB	5
	DB	5
	DB	0
	DB	3
	DB	4
	DB	4
	DB	4
_xmlRelaxNGIsNullable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGElementMatch
_TEXT	SEGMENT
_oldflags$1$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_define$ = 12						; size = 4
_elem$ = 16						; size = 4
_xmlRelaxNGElementMatch PROC				; COMDAT

; 9645 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _define$[ebp]
	xor	ebx, ebx
	mov	esi, DWORD PTR _elem$[ebp]
	mov	DWORD PTR _oldflags$1$[ebp], ebx
	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN53@xmlRelaxNG

; 9646 :     int ret = 0, oldflags = 0;
; 9647 : 
; 9648 :     if (define->name != NULL) {
; 9649 :         if (!xmlStrEqual(elem->name, define->name)) {

	push	eax
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN53@xmlRelaxNG

; 9650 :             VALID_ERR3(XML_RELAXNG_ERR_ELEMNAME, define->name, elem->name);

	push	eax
	push	DWORD PTR [esi+8]
	push	DWORD PTR [edi+8]
	push	13					; 0000000dH
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 9651 :             return (0);

	xor	eax, eax
	pop	edi

; 9743 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@xmlRelaxNG:

; 9652 :         }
; 9653 :     }
; 9654 :     if ((define->ns != NULL) && (define->ns[0] != 0)) {

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN8@xmlRelaxNG
	cmp	BYTE PTR [eax], bl
	je	SHORT $LN8@xmlRelaxNG

; 9655 :         if (elem->ns == NULL) {

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	jne	SHORT $LN10@xmlRelaxNG

; 9656 :             VALID_ERR2(XML_RELAXNG_ERR_ELEMNONS, elem->name);

	push	ecx
	push	ecx
	push	DWORD PTR [esi+8]
	push	15					; 0000000fH
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 9657 :             return (0);

	xor	eax, eax
	pop	edi

; 9743 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlRelaxNG:

; 9658 :         } else if (!xmlStrEqual(elem->ns->href, define->ns)) {

	push	eax
	push	DWORD PTR [ecx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN57@xmlRelaxNG

; 9659 :             VALID_ERR3(XML_RELAXNG_ERR_ELEMWRONGNS,

	push	eax
	push	DWORD PTR [edi+12]
	push	DWORD PTR [esi+8]
	push	17					; 00000011H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 9660 :                        elem->name, define->ns);
; 9661 :             return (0);

	xor	eax, eax
	pop	edi

; 9743 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlRelaxNG:

; 9662 :         }
; 9663 :     } else if ((elem->ns != NULL) && (define->ns != NULL) &&

	mov	ecx, DWORD PTR _elem$[ebp]
	cmp	DWORD PTR [ecx+36], ebx
	je	SHORT $LN15@xmlRelaxNG
	test	eax, eax
	je	SHORT $LN54@xmlRelaxNG
	cmp	DWORD PTR [edi+8], ebx
	jne	SHORT $LN54@xmlRelaxNG

; 9664 :                (define->name == NULL)) {
; 9665 :         VALID_ERR2(XML_RELAXNG_ERR_ELEMEXTRANS, elem->name);

	push	0
	push	0
	push	DWORD PTR [ecx+8]
	push	19					; 00000013H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 9666 :         return (0);

	xor	eax, eax
	pop	edi

; 9743 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@xmlRelaxNG:

; 9667 :     } else if ((elem->ns != NULL) && (define->name != NULL)) {

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN15@xmlRelaxNG

; 9668 :         VALID_ERR2(XML_RELAXNG_ERR_ELEMEXTRANS, define->name);

	push	0
	push	0
	push	eax
	push	19					; 00000013H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 9669 :         return (0);

	xor	eax, eax
	pop	edi

; 9743 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN57@xmlRelaxNG:

; 9658 :         } else if (!xmlStrEqual(elem->ns->href, define->ns)) {

	mov	ecx, DWORD PTR _elem$[ebp]
$LN15@xmlRelaxNG:

; 9670 :     }
; 9671 : 
; 9672 :     if (define->nameClass == NULL)

	mov	edx, DWORD PTR [edi+40]
	test	edx, edx
	je	$LN29@xmlRelaxNG

; 9673 :         return (1);
; 9674 : 
; 9675 :     define = define->nameClass;
; 9676 :     if (define->type == XML_RELAXNG_EXCEPT) {

	mov	eax, DWORD PTR [edx]
	cmp	eax, 2
	jne	SHORT $LN17@xmlRelaxNG

; 9677 :         xmlRelaxNGDefinePtr list;
; 9678 : 
; 9679 :         if (ctxt != NULL) {

	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	SHORT $LN58@xmlRelaxNG

; 9680 :             oldflags = ctxt->flags;

	mov	ebx, DWORD PTR [edi+28]

; 9681 :             ctxt->flags |= FLAGS_IGNORABLE;

	mov	eax, ebx
	or	eax, 1
	mov	DWORD PTR [edi+28], eax
	jmp	SHORT $LN19@xmlRelaxNG
$LN58@xmlRelaxNG:

; 9677 :         xmlRelaxNGDefinePtr list;
; 9678 : 
; 9679 :         if (ctxt != NULL) {

	xor	ebx, ebx
$LN19@xmlRelaxNG:

; 9682 :         }
; 9683 : 
; 9684 :         list = define->content;

	mov	esi, DWORD PTR [edx+24]

; 9685 :         while (list != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlRelaxNG
	npad	4
$LL2@xmlRelaxNG:

; 9686 :             ret = xmlRelaxNGElementMatch(ctxt, list, elem);

	push	ecx
	push	esi
	push	edi
	call	_xmlRelaxNGElementMatch
	add	esp, 12					; 0000000cH

; 9687 :             if (ret == 1) {

	cmp	eax, 1
	je	SHORT $LN41@xmlRelaxNG

; 9690 :                 return (0);
; 9691 :             }
; 9692 :             if (ret < 0) {

	test	eax, eax
	js	SHORT $LN42@xmlRelaxNG

; 9695 :                 return (ret);
; 9696 :             }
; 9697 :             list = list->next;

	mov	esi, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR _elem$[ebp]
	test	esi, esi
	jne	SHORT $LL2@xmlRelaxNG
$LN3@xmlRelaxNG:

; 9698 :         }
; 9699 :         ret = 1;

	mov	ecx, 1

; 9700 :         if (ctxt != NULL) {

	test	edi, edi
	je	$LN26@xmlRelaxNG

; 9701 :             ctxt->flags = oldflags;

	mov	DWORD PTR [edi+28], ebx

; 9741 :     }
; 9742 :     return (ret);

	mov	eax, ecx
	pop	edi

; 9743 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@xmlRelaxNG:

; 9693 :                 if (ctxt != NULL)

	test	edi, edi
	je	$LN1@xmlRelaxNG

; 9694 :                     ctxt->flags = oldflags;

	mov	DWORD PTR [edi+28], ebx
	pop	edi

; 9743 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@xmlRelaxNG:

; 9688 :                 if (ctxt != NULL)

	test	edi, edi
	je	SHORT $LN21@xmlRelaxNG

; 9689 :                     ctxt->flags = oldflags;

	mov	DWORD PTR [edi+28], ebx
$LN21@xmlRelaxNG:
	pop	edi

; 9743 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlRelaxNG:

; 9702 :         }
; 9703 :     } else if (define->type == XML_RELAXNG_CHOICE) {

	cmp	eax, 17					; 00000011H
	jne	$LN25@xmlRelaxNG

; 9704 :         xmlRelaxNGDefinePtr list;
; 9705 : 
; 9706 :         if (ctxt != NULL) {

	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN55@xmlRelaxNG

; 9707 :             oldflags = ctxt->flags;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR _oldflags$1$[ebp], eax

; 9708 :             ctxt->flags |= FLAGS_IGNORABLE;

	or	eax, 1
	mov	DWORD PTR [esi+28], eax
$LN55@xmlRelaxNG:

; 9709 :         }
; 9710 : 
; 9711 :         list = define->nameClass;

	mov	edi, DWORD PTR [edx+40]

; 9712 :         while (list != NULL) {

	test	edi, edi
	je	SHORT $LN5@xmlRelaxNG
	npad	4
$LL4@xmlRelaxNG:

; 9713 :             ret = xmlRelaxNGElementMatch(ctxt, list, elem);

	push	ecx
	push	edi
	push	esi
	call	_xmlRelaxNGElementMatch
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 9714 :             if (ret == 1) {

	cmp	ebx, 1
	je	SHORT $LN43@xmlRelaxNG

; 9718 :             }
; 9719 :             if (ret < 0) {

	test	ebx, ebx
	js	SHORT $LN44@xmlRelaxNG

; 9722 :                 return (ret);
; 9723 :             }
; 9724 :             list = list->next;

	mov	edi, DWORD PTR [edi+32]
	mov	ecx, DWORD PTR _elem$[ebp]
	test	edi, edi
	jne	SHORT $LL4@xmlRelaxNG
$LN5@xmlRelaxNG:

; 9725 :         }
; 9726 :         if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN36@xmlRelaxNG

; 9727 :             if (ret != 0) {

	test	ebx, ebx
	je	SHORT $LN33@xmlRelaxNG

; 9728 :                 if ((ctxt->flags & FLAGS_IGNORABLE) == 0)

	test	BYTE PTR [esi+28], 1
	jne	SHORT $LN36@xmlRelaxNG

; 9729 :                     xmlRelaxNGDumpValidError(ctxt);

	push	esi
	call	_xmlRelaxNGDumpValidError
	add	esp, 4

; 9730 :             } else {

	jmp	SHORT $LN36@xmlRelaxNG
$LN44@xmlRelaxNG:

; 9720 :                 if (ctxt != NULL)

	test	esi, esi
	je	SHORT $LN31@xmlRelaxNG

; 9721 :                     ctxt->flags = oldflags;

	mov	eax, DWORD PTR _oldflags$1$[ebp]
	mov	DWORD PTR [esi+28], eax
$LN31@xmlRelaxNG:

; 9743 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@xmlRelaxNG:

; 9715 :                 if (ctxt != NULL)

	test	esi, esi
	je	SHORT $LN29@xmlRelaxNG

; 9716 :                     ctxt->flags = oldflags;

	mov	eax, DWORD PTR _oldflags$1$[ebp]
	mov	DWORD PTR [esi+28], eax
$LN29@xmlRelaxNG:

; 9717 :                 return (1);

	mov	eax, 1
$LN1@xmlRelaxNG:
	pop	edi

; 9743 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@xmlRelaxNG:

; 9731 :                 if (ctxt->errNr > 0)

	cmp	DWORD PTR [esi+48], 0
	jle	SHORT $LN36@xmlRelaxNG

; 9732 :                     xmlRelaxNGPopErrors(ctxt, 0);

	push	0
	push	esi
	call	_xmlRelaxNGPopErrors
	add	esp, 8
$LN36@xmlRelaxNG:

; 9733 :             }
; 9734 :         }
; 9735 :         ret = 0;

	xor	ecx, ecx

; 9736 :         if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN26@xmlRelaxNG

; 9737 :             ctxt->flags = oldflags;

	mov	eax, DWORD PTR _oldflags$1$[ebp]
	pop	edi
	mov	DWORD PTR [esi+28], eax

; 9741 :     }
; 9742 :     return (ret);

	mov	eax, ecx

; 9743 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlRelaxNG:

; 9738 :         }
; 9739 :     } else {
; 9740 :         TODO ret = -1;

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	9740					; 0000260cH
	push	OFFSET ??_C@_0GJ@NFABHKPN@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	or	ecx, -1
$LN26@xmlRelaxNG:

; 9743 : }

	pop	edi
	pop	esi
	mov	eax, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGElementMatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParseGrammar
_TEXT	SEGMENT
_old$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_nodes$ = 12						; size = 4
_xmlRelaxNGParseGrammar PROC				; COMDAT

; 6596 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlRelaxNGNewGrammar
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN4@xmlRelaxNG

; 6654 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlRelaxNG:

; 6597 :     xmlRelaxNGGrammarPtr ret, tmp, old;
; 6598 : 
; 6599 : #ifdef DEBUG_GRAMMAR
; 6600 :     xmlGenericError(xmlGenericErrorContext, "Parsing a new grammar\n");
; 6601 : #endif
; 6602 : 
; 6603 :     ret = xmlRelaxNGNewGrammar(ctxt);
; 6604 :     if (ret == NULL)
; 6605 :         return (NULL);
; 6606 : 
; 6607 :     /*
; 6608 :      * Link the new grammar in the tree
; 6609 :      */
; 6610 :     ret->parent = ctxt->grammar;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edi], eax

; 6611 :     if (ctxt->grammar != NULL) {

	mov	ecx, DWORD PTR [esi+24]
	test	ecx, ecx
	je	SHORT $LN7@xmlRelaxNG

; 6612 :         tmp = ctxt->grammar->children;

	mov	eax, DWORD PTR [ecx+4]

; 6613 :         if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN14@xmlRelaxNG

; 6614 :             ctxt->grammar->children = ret;

	mov	DWORD PTR [ecx+4], edi

; 6615 :         } else {

	jmp	SHORT $LN7@xmlRelaxNG
$LN14@xmlRelaxNG:

; 6616 :             while (tmp->next != NULL)

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN3@xmlRelaxNG
$LL2@xmlRelaxNG:

; 6617 :                 tmp = tmp->next;

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	jne	SHORT $LL2@xmlRelaxNG
$LN3@xmlRelaxNG:

; 6618 :             tmp->next = ret;

	mov	DWORD PTR [eax+8], edi
$LN7@xmlRelaxNG:

; 6619 :         }
; 6620 :     }
; 6621 : 
; 6622 :     old = ctxt->grammar;
; 6623 :     ctxt->grammar = ret;
; 6624 :     xmlRelaxNGParseGrammarContent(ctxt, nodes);

	push	DWORD PTR _nodes$[ebp]
	mov	eax, DWORD PTR [esi+24]
	push	esi
	mov	DWORD PTR _old$1$[ebp], eax
	mov	DWORD PTR [esi+24], edi
	call	_xmlRelaxNGParseGrammarContent
	add	esp, 8

; 6625 :     ctxt->grammar = ret;

	mov	DWORD PTR [esi+24], edi

; 6626 :     if (ctxt->grammar == NULL) {
; 6627 :         xmlRngPErr(ctxt, nodes, XML_RNGP_GRAMMAR_CONTENT,
; 6628 :                    "Failed to parse <grammar> content\n", NULL, NULL);
; 6629 :     } else if (ctxt->grammar->start == NULL) {

	cmp	DWORD PTR [edi+12], 0
	jne	SHORT $LN10@xmlRelaxNG

; 6630 :         xmlRngPErr(ctxt, nodes, XML_RNGP_GRAMMAR_NO_START,

	push	0
	push	0
	push	OFFSET ??_C@_0CC@BLDDIJOB@Element?5?$DMgrammar?$DO?5has?5no?5?$DMstart@
	push	1039					; 0000040fH
	push	DWORD PTR _nodes$[ebp]
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN10@xmlRelaxNG:

; 6631 :                    "Element <grammar> has no <start>\n", NULL, NULL);
; 6632 :     }
; 6633 : 
; 6634 :     /*
; 6635 :      * Apply 4.17 merging rules to defines and starts
; 6636 :      */
; 6637 :     xmlRelaxNGCombineStart(ctxt, ret);

	push	edi
	push	esi
	call	_xmlRelaxNGCombineStart

; 6638 :     if (ret->defs != NULL) {

	mov	eax, DWORD PTR [edi+24]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlRelaxNG

; 6639 :         xmlHashScan(ret->defs, xmlRelaxNGCheckCombine, ctxt);

	push	esi
	push	OFFSET _xmlRelaxNGCheckCombine
	push	eax
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN11@xmlRelaxNG:

; 6640 :     }
; 6641 : 
; 6642 :     /*
; 6643 :      * link together defines and refs in this grammar
; 6644 :      */
; 6645 :     if (ret->refs != NULL) {

	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	je	SHORT $LN12@xmlRelaxNG

; 6646 :         xmlHashScan(ret->refs, xmlRelaxNGCheckReference, ctxt);

	push	esi
	push	OFFSET _xmlRelaxNGCheckReference
	push	eax
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN12@xmlRelaxNG:

; 6647 :     }
; 6648 : 
; 6649 : 
; 6650 :     /* @@@@ */
; 6651 : 
; 6652 :     ctxt->grammar = old;

	mov	eax, DWORD PTR _old$1$[ebp]
	mov	DWORD PTR [esi+24], eax

; 6653 :     return (ret);

	mov	eax, edi
	pop	edi

; 6654 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGParseGrammar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParseNameClass
_TEXT	SEGMENT
_child$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_last$1$ = 12						; size = 4
_val$2$ = 12						; size = 4
_val$1$ = 12						; size = 4
_node$ = 12						; size = 4
_def$ = 16						; size = 4
_xmlRelaxNGParseNameClass PROC				; COMDAT

; 5286 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	mov	edi, DWORD PTR _def$[ebp]
	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN58@xmlRelaxNG

; 5287 :     xmlRelaxNGDefinePtr ret, tmp;
; 5288 :     xmlChar *val;
; 5289 : 
; 5290 :     ret = def;
; 5291 :     if ((IS_RELAXNG(node, "name")) || (IS_RELAXNG(node, "anyName")) ||

	cmp	DWORD PTR [esi+36], 0
	je	$LN43@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN8@xmlRelaxNG
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@xmlRelaxNG
$LN8@xmlRelaxNG:
	cmp	DWORD PTR [esi+36], 0
	je	$LN43@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN9@xmlRelaxNG
	push	OFFSET ??_C@_07ENOEFKNN@anyName@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@xmlRelaxNG
$LN9@xmlRelaxNG:
	cmp	DWORD PTR [esi+36], 0
	je	$LN43@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN12@xmlRelaxNG
	push	OFFSET ??_C@_06IHANJIJ@nsName@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlRelaxNG
$LN7@xmlRelaxNG:

; 5292 :         (IS_RELAXNG(node, "nsName"))) {
; 5293 :         if ((def->type != XML_RELAXNG_ELEMENT) &&

	mov	eax, edi
	mov	eax, DWORD PTR [eax]
	cmp	eax, 4
	je	SHORT $LN12@xmlRelaxNG
	cmp	eax, 9
	je	SHORT $LN12@xmlRelaxNG

; 5294 :             (def->type != XML_RELAXNG_ATTRIBUTE)) {
; 5295 :             ret = xmlRelaxNGNewDefine(ctxt, node);

	push	esi
	push	ebx
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8

; 5296 :             if (ret == NULL)

	test	edi, edi
	je	$LN59@xmlRelaxNG

; 5297 :                 return (NULL);
; 5298 :             ret->parent = def;

	mov	eax, DWORD PTR _def$[ebp]

; 5299 :             if (ctxt->flags & XML_RELAXNG_IN_ATTRIBUTE)

	mov	ecx, 4
	mov	DWORD PTR [edi+28], eax
	mov	eax, 9
	test	BYTE PTR [ebx+32], 1
	cmovne	ecx, eax
	mov	DWORD PTR [edi], ecx
$LN12@xmlRelaxNG:

; 5300 :                 ret->type = XML_RELAXNG_ATTRIBUTE;
; 5301 :             else
; 5302 :                 ret->type = XML_RELAXNG_ELEMENT;
; 5303 :         }
; 5304 :     }
; 5305 :     if (IS_RELAXNG(node, "name")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN43@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	$LN14@xmlRelaxNG
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN14@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN14@xmlRelaxNG

; 5306 :         val = xmlNodeGetContent(node);

	push	esi
	call	_xmlNodeGetContent

; 5307 :         xmlRelaxNGNormExtSpace(val);

	push	eax
	mov	DWORD PTR _val$1$[ebp], eax
	call	_xmlRelaxNGNormExtSpace

; 5308 :         if (xmlValidateNCName(val, 0)) {

	push	0
	push	DWORD PTR _val$1$[ebp]
	call	_xmlValidateNCName
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN18@xmlRelaxNG

; 5309 : 	    if (node->parent != NULL)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN17@xmlRelaxNG

; 5310 : 		xmlRngPErr(ctxt, node, XML_RNGP_ELEMENT_NAME,

	push	DWORD PTR _val$1$[ebp]
	push	DWORD PTR [eax+8]
	push	OFFSET ??_C@_0CH@CJKCJPCE@Element?5?$CFs?5name?5?8?$CFs?8?5is?5not?5an?5@
	jmp	SHORT $LN69@xmlRelaxNG
$LN17@xmlRelaxNG:

; 5311 : 			   "Element %s name '%s' is not an NCName\n",
; 5312 : 			   node->parent->name, val);
; 5313 : 	    else
; 5314 : 		xmlRngPErr(ctxt, node, XML_RNGP_ELEMENT_NAME,

	push	0
	push	DWORD PTR _val$1$[ebp]
	push	OFFSET ??_C@_0BM@EMBMPALF@name?5?8?$CFs?8?5is?5not?5an?5NCName?6@
$LN69@xmlRelaxNG:

; 5315 : 			   "name '%s' is not an NCName\n",
; 5316 : 			   val, NULL);
; 5317 :         }
; 5318 :         ret->name = val;

	push	1019					; 000003fbH
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN18@xmlRelaxNG:
	mov	eax, DWORD PTR _val$1$[ebp]

; 5319 :         val = xmlGetProp(node, BAD_CAST "ns");

	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	esi
	mov	DWORD PTR [edi+8], eax
	call	_xmlGetProp
	add	esp, 8

; 5320 :         ret->ns = val;

	mov	DWORD PTR [edi+12], eax

; 5321 :         if ((ctxt->flags & XML_RELAXNG_IN_ATTRIBUTE) &&
; 5322 :             (val != NULL) &&

	test	BYTE PTR [ebx+32], 1
	mov	DWORD PTR _val$2$[ebp], eax
	je	$LN3@xmlRelaxNG
	test	eax, eax
	je	SHORT $LN19@xmlRelaxNG
	push	OFFSET ??_C@_0BN@FIBBGPIH@http?3?1?1www?4w3?4org?12000?1xmlns@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN60@xmlRelaxNG

; 5323 :             (xmlStrEqual(val, BAD_CAST "http://www.w3.org/2000/xmlns"))) {
; 5324 : 	    xmlRngPErr(ctxt, node, XML_RNGP_XML_NS,

	push	0
	push	DWORD PTR _val$2$[ebp]
	push	OFFSET ??_C@_0CO@HDKKBGMJ@Attribute?5with?5namespace?5?8?$CFs?8?5i@
	push	1122					; 00000462H
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN60@xmlRelaxNG:

; 5325 :                         "Attribute with namespace '%s' is not allowed\n",
; 5326 :                         val, NULL);
; 5327 :         }
; 5328 :         if ((ctxt->flags & XML_RELAXNG_IN_ATTRIBUTE) &&
; 5329 :             (val != NULL) &&
; 5330 :             (val[0] == 0) && (xmlStrEqual(ret->name, BAD_CAST "xmlns"))) {

	mov	eax, DWORD PTR _val$2$[ebp]
$LN19@xmlRelaxNG:
	test	BYTE PTR [ebx+32], 1
	je	$LN3@xmlRelaxNG
	test	eax, eax
	je	$LN3@xmlRelaxNG
	cmp	BYTE PTR [eax], 0
	jne	$LN3@xmlRelaxNG
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN3@xmlRelaxNG

; 5331 : 	    xmlRngPErr(ctxt, node, XML_RNGP_XMLNS_NAME,

	push	0
	push	DWORD PTR _val$2$[ebp]
	push	OFFSET ??_C@_0CN@HLKDALFC@Attribute?5with?5QName?5?8xmlns?8?5is@
	push	1121					; 00000461H
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 5332 :                        "Attribute with QName 'xmlns' is not allowed\n",
; 5333 :                        val, NULL);
; 5334 :         }

	jmp	$LN3@xmlRelaxNG
$LN14@xmlRelaxNG:

; 5335 :     } else if (IS_RELAXNG(node, "anyName")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN43@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN21@xmlRelaxNG
	push	OFFSET ??_C@_07ENOEFKNN@anyName@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@xmlRelaxNG

; 5336 :         ret->name = NULL;

	mov	DWORD PTR [edi+8], 0

; 5337 :         ret->ns = NULL;

	mov	DWORD PTR [edi+12], 0

; 5338 :         if (node->children != NULL) {
; 5339 :             ret->nameClass =
; 5340 :                 xmlRelaxNGParseExceptNameClass(ctxt, node->children,
; 5341 :                                                (def->type ==
; 5342 :                                                 XML_RELAXNG_ATTRIBUTE));
; 5343 :         }

	jmp	$LN27@xmlRelaxNG
$LN21@xmlRelaxNG:

; 5344 :     } else if (IS_RELAXNG(node, "nsName")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN43@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	$LN24@xmlRelaxNG
	push	OFFSET ??_C@_06IHANJIJ@nsName@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN24@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN24@xmlRelaxNG

; 5345 :         ret->name = NULL;
; 5346 :         ret->ns = xmlGetProp(node, BAD_CAST "ns");

	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	esi
	mov	DWORD PTR [edi+8], 0
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR [edi+12], eax

; 5347 :         if (ret->ns == NULL) {

	test	eax, eax
	jne	SHORT $LN26@xmlRelaxNG

; 5348 :             xmlRngPErr(ctxt, node, XML_RNGP_NSNAME_NO_NS,

	push	eax
	push	eax
	push	OFFSET ??_C@_0BM@OBCEAFCO@nsName?5has?5no?5ns?5attribute?6@
	push	1057					; 00000421H
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN26@xmlRelaxNG:

; 5349 :                        "nsName has no ns attribute\n", NULL, NULL);
; 5350 :         }
; 5351 :         if ((ctxt->flags & XML_RELAXNG_IN_ATTRIBUTE) &&
; 5352 :             (ret->ns != NULL) &&

	test	BYTE PTR [ebx+32], 1
	je	SHORT $LN27@xmlRelaxNG
	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN27@xmlRelaxNG
	push	OFFSET ??_C@_0BN@FIBBGPIH@http?3?1?1www?4w3?4org?12000?1xmlns@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@xmlRelaxNG

; 5353 :             (xmlStrEqual
; 5354 :              (ret->ns, BAD_CAST "http://www.w3.org/2000/xmlns"))) {
; 5355 :             xmlRngPErr(ctxt, node, XML_RNGP_XML_NS,

	push	0
	push	DWORD PTR [edi+12]
	push	OFFSET ??_C@_0CO@HDKKBGMJ@Attribute?5with?5namespace?5?8?$CFs?8?5i@
	push	1122					; 00000462H
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN27@xmlRelaxNG:

; 5400 :                    "expecting name, anyName, nsName or choice : got %s\n",
; 5401 :                    (node == NULL ? (const xmlChar *) "nothing" : node->name),
; 5402 : 		   NULL);
; 5403 :         return (NULL);
; 5404 :     }
; 5405 :     if (ret != def) {

	mov	edx, DWORD PTR [esi+12]
	test	edx, edx
	je	$LN3@xmlRelaxNG
	mov	ecx, DWORD PTR _def$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [ecx], 9
	sete	al
	push	eax
	push	edx
	push	ebx
	call	_xmlRelaxNGParseExceptNameClass
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+40], eax
	jmp	$LN3@xmlRelaxNG
$LN24@xmlRelaxNG:

; 5356 :                        "Attribute with namespace '%s' is not allowed\n",
; 5357 :                        ret->ns, NULL);
; 5358 :         }
; 5359 :         if (node->children != NULL) {
; 5360 :             ret->nameClass =
; 5361 :                 xmlRelaxNGParseExceptNameClass(ctxt, node->children,
; 5362 :                                                (def->type ==
; 5363 :                                                 XML_RELAXNG_ATTRIBUTE));
; 5364 :         }
; 5365 :     } else if (IS_RELAXNG(node, "choice")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN43@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	$LN43@xmlRelaxNG
	push	OFFSET ??_C@_06DDDNEJEA@choice@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN43@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN43@xmlRelaxNG

; 5366 :         xmlNodePtr child;
; 5367 :         xmlRelaxNGDefinePtr last = NULL;
; 5368 : 
; 5369 :         if (def->type == XML_RELAXNG_CHOICE) {

	mov	eax, DWORD PTR _def$[ebp]
	mov	DWORD PTR _last$1$[ebp], 0
	cmp	DWORD PTR [eax], 17			; 00000011H
	jne	SHORT $LN31@xmlRelaxNG

; 5370 :             ret = def;

	mov	edi, eax

; 5371 :         } else {

	jmp	SHORT $LN32@xmlRelaxNG
$LN31@xmlRelaxNG:

; 5372 :             ret = xmlRelaxNGNewDefine(ctxt, node);

	push	esi
	push	ebx
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8

; 5373 :             if (ret == NULL)

	test	edi, edi
	je	$LN59@xmlRelaxNG

; 5374 :                 return (NULL);
; 5375 :             ret->parent = def;

	mov	eax, DWORD PTR _def$[ebp]
	mov	DWORD PTR [edi+28], eax

; 5376 :             ret->type = XML_RELAXNG_CHOICE;

	mov	DWORD PTR [edi], 17			; 00000011H
$LN32@xmlRelaxNG:

; 5377 :         }
; 5378 : 
; 5379 :         if (node->children == NULL) {

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR _child$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LL2@xmlRelaxNG

; 5380 :             xmlRngPErr(ctxt, node, XML_RNGP_CHOICE_EMPTY,

	push	eax
	push	eax
	push	OFFSET ??_C@_0BJ@LPGNADIK@Element?5choice?5is?5empty?6@
	push	1007					; 000003efH
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 5381 :                        "Element choice is empty\n", NULL, NULL);
; 5382 :         } else {

	jmp	SHORT $LN3@xmlRelaxNG
$LL2@xmlRelaxNG:

; 5383 : 
; 5384 :             child = node->children;
; 5385 :             while (child != NULL) {
; 5386 :                 tmp = xmlRelaxNGParseNameClass(ctxt, child, ret);

	push	edi
	push	eax
	push	ebx
	call	_xmlRelaxNGParseNameClass
	add	esp, 12					; 0000000cH

; 5387 :                 if (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN38@xmlRelaxNG

; 5388 :                     if (last == NULL) {

	mov	ecx, DWORD PTR _last$1$[ebp]
	mov	DWORD PTR _last$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN38@xmlRelaxNG

; 5389 :                         last = tmp;
; 5390 :                     } else {
; 5391 :                         last->next = tmp;

	mov	DWORD PTR [ecx+32], eax
$LN38@xmlRelaxNG:

; 5392 :                         last = tmp;
; 5393 :                     }
; 5394 :                 }
; 5395 :                 child = child->next;

	mov	eax, DWORD PTR _child$1$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR _child$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LL2@xmlRelaxNG
$LN3@xmlRelaxNG:

; 5400 :                    "expecting name, anyName, nsName or choice : got %s\n",
; 5401 :                    (node == NULL ? (const xmlChar *) "nothing" : node->name),
; 5402 : 		   NULL);
; 5403 :         return (NULL);
; 5404 :     }
; 5405 :     if (ret != def) {

	mov	eax, DWORD PTR _def$[ebp]
	cmp	edi, eax
	je	SHORT $LN41@xmlRelaxNG

; 5406 :         if (def->nameClass == NULL) {

	mov	ecx, DWORD PTR [eax+40]
	test	ecx, ecx
	jne	SHORT $LN40@xmlRelaxNG

; 5407 :             def->nameClass = ret;

	mov	DWORD PTR [eax+40], edi

; 5414 :         }
; 5415 :     }
; 5416 :     return (ret);

	mov	eax, edi
	pop	edi

; 5417 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@xmlRelaxNG:

; 5408 :         } else {
; 5409 :             tmp = def->nameClass;
; 5410 :             while (tmp->next != NULL) {

	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	je	SHORT $LN5@xmlRelaxNG
	npad	2
$LL4@xmlRelaxNG:

; 5411 :                 tmp = tmp->next;

	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	jne	SHORT $LL4@xmlRelaxNG
$LN5@xmlRelaxNG:

; 5412 :             }
; 5413 :             tmp->next = ret;

	mov	DWORD PTR [ecx+32], edi
$LN41@xmlRelaxNG:

; 5414 :         }
; 5415 :     }
; 5416 :     return (ret);

	mov	eax, edi
	pop	edi

; 5417 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@xmlRelaxNG:

; 5396 :             }
; 5397 :         }
; 5398 :     } else {
; 5399 :         xmlRngPErr(ctxt, node, XML_RNGP_CHOICE_CONTENT,

	mov	eax, DWORD PTR [esi+8]
	jmp	SHORT $LN44@xmlRelaxNG
$LN58@xmlRelaxNG:
	mov	eax, OFFSET ??_C@_07DFGIHOIL@nothing@
$LN44@xmlRelaxNG:

; 515  :     xmlStructuredErrorFunc schannel = NULL;

	xor	ecx, ecx

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	edx, edx

; 517  :     void *data = NULL;

	xor	edi, edi

; 518  : 
; 519  :     if (ctxt != NULL) {

	test	ebx, ebx
	je	SHORT $LN46@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [ebx+12]
	test	ecx, ecx
	jne	SHORT $LN48@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [ebx+4]
$LN48@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	edi, DWORD PTR [ebx]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [ebx+36]
$LN46@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	eax
	push	OFFSET ??_C@_0DE@HGEBBBBP@expecting?5name?0?5anyName?0?5nsName@
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	2
	push	1006					; 000003eeH
	push	18					; 00000012H
	push	esi
	push	0
	push	edi
	push	edx
	push	ecx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN59@xmlRelaxNG:
	pop	edi

; 5417 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGParseNameClass ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParseGrammarContent
_TEXT	SEGMENT
_ret$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_root$1$ = 12						; size = 4
_nodes$ = 12						; size = 4
_xmlRelaxNGParseGrammarContent PROC			; COMDAT

; 5650 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _nodes$[ebp]
	mov	DWORD PTR _ret$1$[ebp], 0
	test	esi, esi
	jne	SHORT $LN51@xmlRelaxNG

; 519  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	xor	edx, edx
	test	eax, eax
	je	SHORT $LN18@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN20@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [eax+4]
$LN20@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	esi, DWORD PTR [eax]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [eax+36]
$LN18@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	0
	push	OFFSET ??_C@_0BJ@FLPPFCBJ@grammar?5has?5no?5children?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1037					; 0000040dH
	push	18					; 00000012H
	push	0
	push	0
	push	esi
	push	edx
	push	ecx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 5651 :     int ret = 0, tmp;
; 5652 : 
; 5653 :     if (nodes == NULL) {
; 5654 :         xmlRngPErr(ctxt, nodes, XML_RNGP_GRAMMAR_EMPTY,
; 5655 :                    "grammar has no children\n", NULL, NULL);
; 5656 :         return (-1);

	or	eax, -1
	pop	esi

; 5685 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@xmlRelaxNG:
	push	ebx
	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]

; 5657 :     }
; 5658 :     while (nodes != NULL) {
; 5659 :         if (IS_RELAXNG(nodes, "start")) {

	test	esi, esi
	je	$LN13@xmlRelaxNG
$LN61@xmlRelaxNG:
	cmp	DWORD PTR [esi+36], 0
	je	$LN13@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN5@xmlRelaxNG
	push	OFFSET ??_C@_05FAGFPHJG@start@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlRelaxNG

; 5660 :             if (nodes->children == NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN7@xmlRelaxNG

; 5661 :                 xmlRngPErr(ctxt, nodes, XML_RNGP_START_EMPTY,

	push	eax
	push	eax
	push	OFFSET ??_C@_0BH@HFFJFLLH@start?5has?5no?5children?6@
	push	1106					; 00000452H
	push	esi
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN54@xmlRelaxNG:

; 5678 :                        "grammar has unexpected child %s\n", nodes->name,
; 5679 :                        NULL);
; 5680 :             ret = -1;
; 5681 :         }
; 5682 :         nodes = nodes->next;

	mov	eax, DWORD PTR _ret$1$[ebp]
$LN14@xmlRelaxNG:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LN61@xmlRelaxNG

; 5683 :     }
; 5684 :     return (ret);

	pop	edi
	pop	ebx
	pop	esi

; 5685 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlRelaxNG:

; 5662 :                            "start has no children\n", NULL, NULL);
; 5663 :             } else {
; 5664 :                 tmp = xmlRelaxNGParseStart(ctxt, nodes->children);

	push	eax
	push	edi
	call	_xmlRelaxNGParseStart

; 5665 :                 if (tmp != 0)
; 5666 :                     ret = -1;
; 5667 :             }

	jmp	SHORT $LN58@xmlRelaxNG
$LN5@xmlRelaxNG:

; 5668 :         } else if (IS_RELAXNG(nodes, "define")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN13@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN10@xmlRelaxNG
	push	OFFSET ??_C@_06EPMMJFDC@define@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlRelaxNG

; 5669 :             tmp = xmlRelaxNGParseDefine(ctxt, nodes);

	push	esi
	push	edi
	call	_xmlRelaxNGParseDefine
$LN58@xmlRelaxNG:

; 5678 :                        "grammar has unexpected child %s\n", nodes->name,
; 5679 :                        NULL);
; 5680 :             ret = -1;
; 5681 :         }
; 5682 :         nodes = nodes->next;

	add	esp, 8
	test	eax, eax
	je	SHORT $LN54@xmlRelaxNG
	or	eax, -1
	mov	DWORD PTR _ret$1$[ebp], eax
	jmp	SHORT $LN14@xmlRelaxNG
$LN10@xmlRelaxNG:

; 5670 :             if (tmp != 0)
; 5671 :                 ret = -1;
; 5672 :         } else if (IS_RELAXNG(nodes, "include")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN13@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	$LN13@xmlRelaxNG
	push	OFFSET ??_C@_07FHOHOHLG@include@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN13@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN13@xmlRelaxNG

; 4571 :     incl = node->psvi;

	mov	eax, DWORD PTR [esi+52]
	xor	ebx, ebx

; 4572 :     if (incl == NULL) {

	test	eax, eax
	jne	SHORT $LN23@xmlRelaxNG

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	ecx, ecx

; 517  :     void *data = NULL;

	xor	edx, edx

; 518  : 
; 519  :     if (ctxt != NULL) {

	test	edi, edi
	je	SHORT $LN32@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	jne	SHORT $LN34@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	ecx, DWORD PTR [edi+4]
$LN34@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	edx, DWORD PTR [edi]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [edi+36]
$LN32@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	0
	push	OFFSET ??_C@_0BK@PJHELFJE@Include?5node?5has?5no?5data?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1042					; 00000412H
$LN62@xmlRelaxNG:

; 5675 :                 ret = -1;

	push	18					; 00000012H
	push	esi
	push	0
	push	edx
	push	ecx
	push	eax
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
	or	eax, -1
	mov	DWORD PTR _ret$1$[ebp], eax

; 5676 :         } else {

	jmp	$LN14@xmlRelaxNG
$LN23@xmlRelaxNG:

; 4577 :     root = xmlDocGetRootElement(incl->doc);

	push	DWORD PTR [eax+8]
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$1$[ebp], eax

; 4578 :     if (root == NULL) {

	test	eax, eax
	jne	SHORT $LN24@xmlRelaxNG

; 4579 :         xmlRngPErr(ctxt, node, XML_RNGP_EMPTY, "Include document is empty\n",

	push	eax
	push	eax
	push	OFFSET ??_C@_0BL@NJFOGBOE@Include?5document?5is?5empty?6@
	push	1022					; 000003feH
	push	esi
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 5675 :                 ret = -1;

	or	eax, -1
	mov	DWORD PTR _ret$1$[ebp], eax

; 5676 :         } else {

	jmp	$LN14@xmlRelaxNG
$LN24@xmlRelaxNG:

; 4583 :     if (!xmlStrEqual(root->name, BAD_CAST "grammar")) {

	push	OFFSET ??_C@_07EFOLCII@grammar@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@xmlRelaxNG

; 4584 :         xmlRngPErr(ctxt, node, XML_RNGP_GRAMMAR_MISSING,

	push	eax
	push	eax
	push	OFFSET ??_C@_0CI@GFEIPOEG@Include?5document?5root?5is?5not?5a?5@
	push	1038					; 0000040eH
	push	esi
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 5675 :                 ret = -1;

	or	eax, -1
	mov	DWORD PTR _ret$1$[ebp], eax

; 5676 :         } else {

	jmp	$LN14@xmlRelaxNG
$LN25@xmlRelaxNG:

; 4592 :     if (root->children != NULL) {

	mov	eax, DWORD PTR _root$1$[ebp]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN27@xmlRelaxNG

; 4593 :         tmp = xmlRelaxNGParseGrammarContent(ctxt, root->children);

	push	eax
	push	edi
	call	_xmlRelaxNGParseGrammarContent
	add	esp, 8

; 4594 :         if (tmp != 0)

	test	eax, eax
	mov	eax, -1
	cmovne	ebx, eax
$LN27@xmlRelaxNG:

; 4595 :             ret = -1;
; 4596 :     }
; 4597 :     if (node->children != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN47@xmlRelaxNG

; 4598 :         tmp = xmlRelaxNGParseGrammarContent(ctxt, node->children);

	push	eax
	push	edi
	call	_xmlRelaxNGParseGrammarContent
	add	esp, 8

; 4599 :         if (tmp != 0)

	test	eax, eax
	jne	SHORT $LN45@xmlRelaxNG
$LN47@xmlRelaxNG:

; 5673 :             tmp = xmlRelaxNGParseInclude(ctxt, nodes);
; 5674 :             if (tmp != 0)

	test	ebx, ebx
	je	$LN54@xmlRelaxNG
$LN45@xmlRelaxNG:

; 5675 :                 ret = -1;

	or	eax, -1
	mov	DWORD PTR _ret$1$[ebp], eax

; 5676 :         } else {

	jmp	$LN14@xmlRelaxNG
$LN13@xmlRelaxNG:

; 5677 :             xmlRngPErr(ctxt, nodes, XML_RNGP_GRAMMAR_CONTENT,

	mov	ebx, DWORD PTR [esi+8]

; 515  :     xmlStructuredErrorFunc schannel = NULL;

	xor	eax, eax

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	ecx, ecx

; 517  :     void *data = NULL;

	xor	edx, edx

; 518  : 
; 519  :     if (ctxt != NULL) {

	test	edi, edi
	je	SHORT $LN37@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	jne	SHORT $LN39@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	ecx, DWORD PTR [edi+4]
$LN39@xmlRelaxNG:

; 524  :         data = ctxt->userData;

	mov	edx, DWORD PTR [edi]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [edi+36]
$LN37@xmlRelaxNG:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	ebx
	push	OFFSET ??_C@_0CB@DOHNNNEN@grammar?5has?5unexpected?5child?5?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	ebx
	push	0
	push	0
	push	2
	push	1036					; 0000040cH

; 5673 :             tmp = xmlRelaxNGParseInclude(ctxt, nodes);
; 5674 :             if (tmp != 0)

	jmp	$LN62@xmlRelaxNG
_xmlRelaxNGParseGrammarContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParseDocument
_TEXT	SEGMENT
_olddefine$1$ = -4					; size = 4
_old$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlRelaxNGParseDocument PROC				; COMDAT

; 6669 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN7@xmlRelaxNG

; 6670 :     xmlRelaxNGPtr schema = NULL;
; 6671 :     const xmlChar *olddefine;
; 6672 :     xmlRelaxNGGrammarPtr old;
; 6673 : 
; 6674 :     if ((ctxt == NULL) || (node == NULL))

	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	SHORT $LN7@xmlRelaxNG

; 765  :     ret = (xmlRelaxNGPtr) xmlMalloc(sizeof(xmlRelaxNG));

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 766  :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN21@xmlRelaxNG

; 445  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN26@xmlRelaxNG

; 446  : 	    schannel = ctxt->serror;
; 447  : 	else
; 448  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN26@xmlRelaxNG:

; 449  :         data = ctxt->userData;
; 450  :         ctxt->nbErrors++;
; 451  :     }
; 452  :     if (extra)
; 453  :         __xmlRaiseError(schannel, channel, data,
; 454  :                         NULL, NULL, XML_FROM_RELAXNGP,
; 455  :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,
; 456  :                         NULL, NULL, 0, 0,
; 457  :                         "Memory allocation failed : %s\n", extra);
; 458  :     else
; 459  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+36]
	push	0
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 64					; 00000040H
$LN7@xmlRelaxNG:
	pop	edi

; 6738 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlRelaxNG:
	xorps	xmm0, xmm0

; 770  :     memset(ret, 0, sizeof(xmlRelaxNG));

	movups	XMMWORD PTR [edi], xmm0
	movups	XMMWORD PTR [edi+16], xmm0
	movq	QWORD PTR [edi+32], xmm0

; 6675 :         return (NULL);
; 6676 : 
; 6677 :     schema = xmlRelaxNGNewRelaxNG(ctxt);
; 6678 :     if (schema == NULL)
; 6679 :         return (NULL);
; 6680 : 
; 6681 :     olddefine = ctxt->define;

	mov	eax, DWORD PTR [esi+44]

; 6682 :     ctxt->define = NULL;

	mov	DWORD PTR [esi+44], 0

; 6683 :     if (IS_RELAXNG(node, "grammar")) {

	cmp	DWORD PTR [ebx+36], 0
	mov	DWORD PTR _olddefine$1$[ebp], eax
	je	SHORT $LN9@xmlRelaxNG
	cmp	DWORD PTR [ebx+4], 1
	jne	SHORT $LN9@xmlRelaxNG
	push	OFFSET ??_C@_07EFOLCII@grammar@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlRelaxNG
	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlRelaxNG

; 6684 :         schema->topgrammar = xmlRelaxNGParseGrammar(ctxt, node->children);

	push	DWORD PTR [ebx+12]
	push	esi
	call	_xmlRelaxNGParseGrammar
	add	esp, 8
	mov	DWORD PTR [edi+4], eax

; 6685 :         if (schema->topgrammar == NULL) {

	test	eax, eax
	jne	$LN16@xmlRelaxNG

; 6694 :             xmlRelaxNGFree(schema);

	push	edi
	call	_xmlRelaxNGFree
	add	esp, 4

; 6738 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlRelaxNG:

; 6686 :             xmlRelaxNGFree(schema);
; 6687 :             return (NULL);
; 6688 :         }
; 6689 :     } else {
; 6690 :         xmlRelaxNGGrammarPtr tmp, ret;
; 6691 : 
; 6692 :         schema->topgrammar = ret = xmlRelaxNGNewGrammar(ctxt);

	push	esi
	call	_xmlRelaxNGNewGrammar
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR [edi+4], edx

; 6693 :         if (schema->topgrammar == NULL) {

	test	edx, edx
	jne	SHORT $LN12@xmlRelaxNG

; 6694 :             xmlRelaxNGFree(schema);

	push	edi
	call	_xmlRelaxNGFree
	add	esp, 4

; 6738 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlRelaxNG:

; 6695 :             return (NULL);
; 6696 :         }
; 6697 :         /*
; 6698 :          * Link the new grammar in the tree
; 6699 :          */
; 6700 :         ret->parent = ctxt->grammar;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edx], eax

; 6701 :         if (ctxt->grammar != NULL) {

	mov	ecx, DWORD PTR [esi+24]
	test	ecx, ecx
	je	SHORT $LN15@xmlRelaxNG

; 6702 :             tmp = ctxt->grammar->children;

	mov	eax, DWORD PTR [ecx+4]

; 6703 :             if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN30@xmlRelaxNG

; 6704 :                 ctxt->grammar->children = ret;

	mov	DWORD PTR [ecx+4], edx

; 6705 :             } else {

	jmp	SHORT $LN15@xmlRelaxNG
$LN30@xmlRelaxNG:

; 6706 :                 while (tmp->next != NULL)

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN3@xmlRelaxNG
	npad	1
$LL2@xmlRelaxNG:

; 6707 :                     tmp = tmp->next;

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	jne	SHORT $LL2@xmlRelaxNG
$LN3@xmlRelaxNG:

; 6708 :                 tmp->next = ret;

	mov	DWORD PTR [eax+8], edx
$LN15@xmlRelaxNG:

; 6709 :             }
; 6710 :         }
; 6711 :         old = ctxt->grammar;

	mov	eax, DWORD PTR [esi+24]

; 6712 :         ctxt->grammar = ret;
; 6713 :         xmlRelaxNGParseStart(ctxt, node);

	push	ebx
	push	esi
	mov	DWORD PTR _old$1$[ebp], eax
	mov	DWORD PTR [esi+24], edx
	call	_xmlRelaxNGParseStart

; 6714 :         if (old != NULL)

	mov	eax, DWORD PTR _old$1$[ebp]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlRelaxNG

; 6715 :             ctxt->grammar = old;

	mov	DWORD PTR [esi+24], eax
$LN16@xmlRelaxNG:

; 6716 :     }
; 6717 :     ctxt->define = olddefine;

	mov	eax, DWORD PTR _olddefine$1$[ebp]
	mov	DWORD PTR [esi+44], eax

; 6718 :     if (schema->topgrammar->start != NULL) {

	mov	eax, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN18@xmlRelaxNG

; 6719 :         xmlRelaxNGCheckCycles(ctxt, schema->topgrammar->start, 0);

	push	0
	push	eax
	push	esi
	call	_xmlRelaxNGCheckCycles
	add	esp, 12					; 0000000cH

; 6720 :         if ((ctxt->flags & XML_RELAXNG_IN_EXTERNALREF) == 0) {

	test	BYTE PTR [esi+32], 128			; 00000080H
	jne	SHORT $LN18@xmlRelaxNG

; 6721 :             xmlRelaxNGSimplify(ctxt, schema->topgrammar->start, NULL);

	mov	eax, DWORD PTR [edi+4]
	push	0
	push	DWORD PTR [eax+12]
	push	esi
	call	_xmlRelaxNGSimplify

; 6722 :             while ((schema->topgrammar->start != NULL) &&
; 6723 :                    (schema->topgrammar->start->type == XML_RELAXNG_NOOP) &&

	mov	eax, DWORD PTR [edi+4]
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN40@xmlRelaxNG
	mov	ecx, eax
$LL4@xmlRelaxNG:
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, ecx
	cmp	DWORD PTR [edx], -1
	jne	SHORT $LN40@xmlRelaxNG
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN40@xmlRelaxNG

; 6724 :                    (schema->topgrammar->start->next != NULL))
; 6725 :                 schema->topgrammar->start =

	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, eax
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LL4@xmlRelaxNG
$LN40@xmlRelaxNG:

; 6726 :                     schema->topgrammar->start->content;
; 6727 :             xmlRelaxNGCheckRules(ctxt, schema->topgrammar->start,

	push	-1
	push	16					; 00000010H
	push	DWORD PTR [eax+12]
	push	esi
	call	_xmlRelaxNGCheckRules
	add	esp, 16					; 00000010H
$LN18@xmlRelaxNG:

; 6728 :                                  XML_RELAXNG_IN_START, XML_RELAXNG_NOOP);
; 6729 :         }
; 6730 :     }
; 6731 : #ifdef DEBUG
; 6732 :     if (schema == NULL)
; 6733 :         xmlGenericError(xmlGenericErrorContext,
; 6734 :                         "xmlRelaxNGParseDocument() failed\n");
; 6735 : #endif
; 6736 : 
; 6737 :     return (schema);

	mov	eax, edi
	pop	edi

; 6738 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGParseDocument ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParsePattern
_TEXT	SEGMENT
_old_flags$1$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_child$1$ = 12						; size = 4
_oldparent$1$ = 12					; size = 4
_node$ = 12						; size = 4
_xmlRelaxNGParsePattern PROC				; COMDAT

; 4841 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	$LN231@xmlRelaxNG

; 4842 :     xmlRelaxNGDefinePtr def = NULL;
; 4843 : 
; 4844 :     if (node == NULL) {
; 4845 :         return (NULL);
; 4846 :     }
; 4847 :     if (IS_RELAXNG(node, "element")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN3@xmlRelaxNG
	push	OFFSET ??_C@_07HCLJNICE@element@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG

; 4848 :         def = xmlRelaxNGParseElement(ctxt, node);

	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGParseElement
	add	esp, 8
	mov	edi, eax
	pop	edi

; 5127 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 4849 :     } else if (IS_RELAXNG(node, "attribute")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	$LN5@xmlRelaxNG
	push	OFFSET ??_C@_09HGIEBAJ@attribute@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN5@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN5@xmlRelaxNG

; 5145 :     ret = xmlRelaxNGNewDefine(ctxt, node);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	esi
	push	ebx
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8

; 5146 :     if (ret == NULL)

	test	edi, edi
	je	$LN252@xmlRelaxNG

; 5147 :         return (NULL);
; 5148 :     ret->type = XML_RELAXNG_ATTRIBUTE;

	mov	DWORD PTR [edi], 9

; 5149 :     ret->parent = ctxt->def;

	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [edi+28], eax

; 5150 :     child = node->children;

	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR _child$1$[ebp], ecx

; 5151 :     if (child == NULL) {

	test	ecx, ecx
	jne	SHORT $LN127@xmlRelaxNG

; 5152 :         xmlRngPErr(ctxt, node, XML_RNGP_ATTRIBUTE_EMPTY,

	push	ecx
	push	ecx
	push	OFFSET ??_C@_0DF@EOBONIDO@xmlRelaxNGParseattribute?3?5attri@
	push	1004					; 000003ecH
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 5127 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN127@xmlRelaxNG:

; 5157 :     old_flags = ctxt->flags;

	mov	eax, DWORD PTR [ebx+32]

; 5158 :     ctxt->flags |= XML_RELAXNG_IN_ATTRIBUTE;
; 5159 :     cur = xmlRelaxNGParseNameClass(ctxt, child, ret);

	push	edi
	mov	DWORD PTR _old_flags$1$[ebp], eax
	or	eax, 1
	push	ecx
	push	ebx
	mov	DWORD PTR [ebx+32], eax
	call	_xmlRelaxNGParseNameClass
	add	esp, 12					; 0000000cH

; 5160 :     if (cur != NULL)

	test	eax, eax
	mov	eax, DWORD PTR _child$1$[ebp]
	je	SHORT $LN128@xmlRelaxNG

; 5161 :         child = child->next;

	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR _child$1$[ebp], eax
$LN128@xmlRelaxNG:

; 5162 : 
; 5163 :     if (child != NULL) {

	test	eax, eax
	je	SHORT $LN134@xmlRelaxNG

; 5164 :         cur = xmlRelaxNGParsePattern(ctxt, child);

	push	eax
	push	ebx
	call	_xmlRelaxNGParsePattern
	add	esp, 8

; 5165 :         if (cur != NULL) {

	test	eax, eax
	je	SHORT $LN124@xmlRelaxNG

; 5166 :             switch (cur->type) {

	mov	ecx, DWORD PTR [eax]
	inc	ecx
	cmp	ecx, 21					; 00000015H
	ja	SHORT $LN124@xmlRelaxNG
	movzx	ecx, BYTE PTR $LN232@xmlRelaxNG[ecx]
	jmp	DWORD PTR $LN261@xmlRelaxNG[ecx*4]
$LN131@xmlRelaxNG:

; 5167 :                 case XML_RELAXNG_EMPTY:
; 5168 :                 case XML_RELAXNG_NOT_ALLOWED:
; 5169 :                 case XML_RELAXNG_TEXT:
; 5170 :                 case XML_RELAXNG_ELEMENT:
; 5171 :                 case XML_RELAXNG_DATATYPE:
; 5172 :                 case XML_RELAXNG_VALUE:
; 5173 :                 case XML_RELAXNG_LIST:
; 5174 :                 case XML_RELAXNG_REF:
; 5175 :                 case XML_RELAXNG_PARENTREF:
; 5176 :                 case XML_RELAXNG_EXTERNALREF:
; 5177 :                 case XML_RELAXNG_DEF:
; 5178 :                 case XML_RELAXNG_ONEORMORE:
; 5179 :                 case XML_RELAXNG_ZEROORMORE:
; 5180 :                 case XML_RELAXNG_OPTIONAL:
; 5181 :                 case XML_RELAXNG_CHOICE:
; 5182 :                 case XML_RELAXNG_GROUP:
; 5183 :                 case XML_RELAXNG_INTERLEAVE:
; 5184 :                 case XML_RELAXNG_ATTRIBUTE:
; 5185 :                     ret->content = cur;

	mov	DWORD PTR [edi+24], eax

; 5186 :                     cur->parent = ret;

	mov	DWORD PTR [eax+28], edi

; 5187 :                     break;

	jmp	SHORT $LN124@xmlRelaxNG
$LN132@xmlRelaxNG:

; 5188 :                 case XML_RELAXNG_START:
; 5189 :                 case XML_RELAXNG_PARAM:
; 5190 :                 case XML_RELAXNG_EXCEPT:
; 5191 :                     xmlRngPErr(ctxt, node, XML_RNGP_ATTRIBUTE_CONTENT,

	push	0
	push	0
	push	OFFSET ??_C@_0BP@NPGIAHLH@attribute?5has?5invalid?5content?6@
	push	1003					; 000003ebH

; 5192 :                                "attribute has invalid content\n", NULL,
; 5193 :                                NULL);
; 5194 :                     break;

	jmp	SHORT $LN253@xmlRelaxNG
$LN133@xmlRelaxNG:

; 5195 :                 case XML_RELAXNG_NOOP:
; 5196 :                     xmlRngPErr(ctxt, node, XML_RNGP_ATTRIBUTE_NOOP,

	push	0
	push	0
	push	OFFSET ??_C@_0CN@KBLNJNDN@RNG?5Internal?5error?0?5noop?5found?5@
	push	1005					; 000003edH
$LN253@xmlRelaxNG:

; 5197 :                                "RNG Internal error, noop found in attribute\n",
; 5198 :                                NULL, NULL);
; 5199 :                     break;
; 5200 :             }
; 5201 :         }
; 5202 :         child = child->next;
; 5203 :     }
; 5204 :     if (child != NULL) {

	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN124@xmlRelaxNG:
	mov	eax, DWORD PTR _child$1$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN134@xmlRelaxNG

; 5205 :         xmlRngPErr(ctxt, node, XML_RNGP_ATTRIBUTE_CHILDREN,

	push	0
	push	0
	push	OFFSET ??_C@_0CB@BOMNCDFG@attribute?5has?5multiple?5children@
	push	1002					; 000003eaH
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN134@xmlRelaxNG:

; 5206 :                    "attribute has multiple children\n", NULL, NULL);
; 5207 :     }
; 5208 :     ctxt->flags = old_flags;

	mov	eax, DWORD PTR _old_flags$1$[ebp]
	mov	DWORD PTR [ebx+32], eax

; 5127 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlRelaxNG:

; 4850 :         def = xmlRelaxNGParseAttribute(ctxt, node);
; 4851 :     } else if (IS_RELAXNG(node, "empty")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN7@xmlRelaxNG
	push	OFFSET ??_C@_05LBJMNBOG@empty@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG

; 4852 :         def = xmlRelaxNGNewDefine(ctxt, node);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	esi
	push	ebx
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8

; 4853 :         if (def == NULL)

	test	edi, edi
	je	$LN231@xmlRelaxNG

; 4854 :             return (NULL);
; 4855 :         def->type = XML_RELAXNG_EMPTY;

	mov	DWORD PTR [edi], 0

; 4856 :         if (node->children != NULL) {

	cmp	DWORD PTR [esi+12], 0
	je	$LN93@xmlRelaxNG

; 4857 :             xmlRngPErr(ctxt, node, XML_RNGP_EMPTY_NOT_EMPTY,

	push	0
	push	0
	push	OFFSET ??_C@_0BJ@FKDMDHPF@empty?3?5had?5a?5child?5node?6@
	push	1025					; 00000401H
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 5127 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlRelaxNG:

; 4858 :                        "empty: had a child node\n", NULL, NULL);
; 4859 :         }
; 4860 :     } else if (IS_RELAXNG(node, "text")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN11@xmlRelaxNG
	push	OFFSET ??_C@_04CIMGMMMG@text@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlRelaxNG

; 4861 :         def = xmlRelaxNGNewDefine(ctxt, node);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	esi
	push	ebx
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8

; 4862 :         if (def == NULL)

	test	edi, edi
	je	$LN231@xmlRelaxNG

; 4863 :             return (NULL);
; 4864 :         def->type = XML_RELAXNG_TEXT;

	mov	DWORD PTR [edi], 3

; 4865 :         if (node->children != NULL) {

	cmp	DWORD PTR [esi+12], 0
	je	$LN93@xmlRelaxNG

; 4866 :             xmlRngPErr(ctxt, node, XML_RNGP_TEXT_HAS_CHILD,

	push	0
	push	0
	push	OFFSET ??_C@_0BI@LOCKCMHG@text?3?5had?5a?5child?5node?6@
	push	1109					; 00000455H
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 5127 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlRelaxNG:

; 4867 :                        "text: had a child node\n", NULL, NULL);
; 4868 :         }
; 4869 :     } else if (IS_RELAXNG(node, "zeroOrMore")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN15@xmlRelaxNG
	push	OFFSET ??_C@_0L@BANFCDDP@zeroOrMore@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlRelaxNG

; 4870 :         def = xmlRelaxNGNewDefine(ctxt, node);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	esi
	push	ebx
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8

; 4871 :         if (def == NULL)

	test	edi, edi
	je	$LN231@xmlRelaxNG

; 4872 :             return (NULL);
; 4873 :         def->type = XML_RELAXNG_ZEROORMORE;

	mov	DWORD PTR [edi], 15			; 0000000fH
$LN258@xmlRelaxNG:

; 5122 :                    "Unexpected node %s is not a pattern\n", node->name,
; 5123 :                    NULL);
; 5124 :         def = NULL;
; 5125 :     }
; 5126 :     return (def);

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	$LN28@xmlRelaxNG
	push	eax
$LN259@xmlRelaxNG:
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0BF@BCLGKPIM@Element?5?$CFs?5is?5empty?6@
	push	1023					; 000003ffH
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 5127 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlRelaxNG:

; 4874 :         if (node->children == NULL) {
; 4875 :             xmlRngPErr(ctxt, node, XML_RNGP_EMPTY_CONSTRUCT,
; 4876 :                        "Element %s is empty\n", node->name, NULL);
; 4877 :         } else {
; 4878 :             def->content =
; 4879 :                 xmlRelaxNGParsePatterns(ctxt, node->children, 1);
; 4880 :         }
; 4881 :     } else if (IS_RELAXNG(node, "oneOrMore")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN20@xmlRelaxNG
	push	OFFSET ??_C@_09EIEDMNLG@oneOrMore@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlRelaxNG

; 4882 :         def = xmlRelaxNGNewDefine(ctxt, node);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	esi
	push	ebx
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8

; 4883 :         if (def == NULL)

	test	edi, edi
	je	$LN231@xmlRelaxNG

; 4884 :             return (NULL);
; 4885 :         def->type = XML_RELAXNG_ONEORMORE;

	mov	DWORD PTR [edi], 16			; 00000010H

; 4886 :         if (node->children == NULL) {
; 4887 :             xmlRngPErr(ctxt, node, XML_RNGP_EMPTY_CONSTRUCT,
; 4888 :                        "Element %s is empty\n", node->name, NULL);
; 4889 :         } else {

	jmp	$LN258@xmlRelaxNG
$LN20@xmlRelaxNG:

; 4890 :             def->content =
; 4891 :                 xmlRelaxNGParsePatterns(ctxt, node->children, 1);
; 4892 :         }
; 4893 :     } else if (IS_RELAXNG(node, "optional")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN25@xmlRelaxNG
	push	OFFSET ??_C@_08EBGGHLAO@optional@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlRelaxNG

; 4894 :         def = xmlRelaxNGNewDefine(ctxt, node);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	esi
	push	ebx
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8

; 4895 :         if (def == NULL)

	test	edi, edi
	je	$LN231@xmlRelaxNG

; 4896 :             return (NULL);
; 4897 :         def->type = XML_RELAXNG_OPTIONAL;

	mov	DWORD PTR [edi], 14			; 0000000eH

; 4898 :         if (node->children == NULL) {
; 4899 :             xmlRngPErr(ctxt, node, XML_RNGP_EMPTY_CONSTRUCT,
; 4900 :                        "Element %s is empty\n", node->name, NULL);
; 4901 :         } else {

	jmp	$LN258@xmlRelaxNG
$LN28@xmlRelaxNG:

; 5122 :                    "Unexpected node %s is not a pattern\n", node->name,
; 5123 :                    NULL);
; 5124 :         def = NULL;
; 5125 :     }
; 5126 :     return (def);

	push	1
$LN62@xmlRelaxNG:
	push	eax
	push	ebx
	call	_xmlRelaxNGParsePatterns
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+24], eax

; 5127 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlRelaxNG:

; 4902 :             def->content =
; 4903 :                 xmlRelaxNGParsePatterns(ctxt, node->children, 1);
; 4904 :         }
; 4905 :     } else if (IS_RELAXNG(node, "choice")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN30@xmlRelaxNG
	push	OFFSET ??_C@_06DDDNEJEA@choice@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN30@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN30@xmlRelaxNG

; 4906 :         def = xmlRelaxNGNewDefine(ctxt, node);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	esi
	push	ebx
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8

; 4907 :         if (def == NULL)

	test	edi, edi
	je	$LN231@xmlRelaxNG

; 4908 :             return (NULL);
; 4909 :         def->type = XML_RELAXNG_CHOICE;

	mov	DWORD PTR [edi], 17			; 00000011H

; 4910 :         if (node->children == NULL) {

	mov	eax, DWORD PTR [esi+12]
	push	0
	test	eax, eax
	jne	SHORT $LN62@xmlRelaxNG

; 4911 :             xmlRngPErr(ctxt, node, XML_RNGP_EMPTY_CONSTRUCT,
; 4912 :                        "Element %s is empty\n", node->name, NULL);
; 4913 :         } else {

	jmp	$LN259@xmlRelaxNG
$LN30@xmlRelaxNG:

; 4914 :             def->content =
; 4915 :                 xmlRelaxNGParsePatterns(ctxt, node->children, 0);
; 4916 :         }
; 4917 :     } else if (IS_RELAXNG(node, "group")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN35@xmlRelaxNG
	push	OFFSET ??_C@_05MGJOOGAJ@group@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN35@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN35@xmlRelaxNG

; 4918 :         def = xmlRelaxNGNewDefine(ctxt, node);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	esi
	push	ebx
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8

; 4919 :         if (def == NULL)

	test	edi, edi
	je	$LN231@xmlRelaxNG

; 4920 :             return (NULL);
; 4921 :         def->type = XML_RELAXNG_GROUP;

	mov	DWORD PTR [edi], 18			; 00000012H

; 4922 :         if (node->children == NULL) {

	mov	eax, DWORD PTR [esi+12]
	push	0
	test	eax, eax
	jne	$LN62@xmlRelaxNG

; 4923 :             xmlRngPErr(ctxt, node, XML_RNGP_EMPTY_CONSTRUCT,
; 4924 :                        "Element %s is empty\n", node->name, NULL);
; 4925 :         } else {

	jmp	$LN259@xmlRelaxNG
$LN35@xmlRelaxNG:

; 4926 :             def->content =
; 4927 :                 xmlRelaxNGParsePatterns(ctxt, node->children, 0);
; 4928 :         }
; 4929 :     } else if (IS_RELAXNG(node, "ref")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	$LN40@xmlRelaxNG
	push	OFFSET ??_C@_03GCDGINBO@ref@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN40@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN40@xmlRelaxNG

; 4930 :         def = xmlRelaxNGNewDefine(ctxt, node);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	esi
	push	ebx
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8

; 4931 :         if (def == NULL)

	test	edi, edi
	je	$LN231@xmlRelaxNG

; 4932 :             return (NULL);
; 4933 :         def->type = XML_RELAXNG_REF;
; 4934 :         def->name = xmlGetProp(node, BAD_CAST "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	esi
	mov	DWORD PTR [edi], 11			; 0000000bH
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR [edi+8], eax

; 4935 :         if (def->name == NULL) {

	test	eax, eax
	jne	SHORT $LN43@xmlRelaxNG

; 4936 :             xmlRngPErr(ctxt, node, XML_RNGP_REF_NO_NAME, "ref has no name\n",

	push	eax
	push	eax
	push	OFFSET ??_C@_0BB@BOHONICN@ref?5has?5no?5name?6@
	push	1102					; 0000044eH

; 4937 :                        NULL, NULL);
; 4938 :         } else {

	jmp	SHORT $LN254@xmlRelaxNG
$LN43@xmlRelaxNG:

; 4939 :             xmlRelaxNGNormExtSpace(def->name);

	push	eax
	call	_xmlRelaxNGNormExtSpace

; 4940 :             if (xmlValidateNCName(def->name, 0)) {

	push	0
	push	DWORD PTR [edi+8]
	call	_xmlValidateNCName
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN45@xmlRelaxNG

; 4941 :                 xmlRngPErr(ctxt, node, XML_RNGP_REF_NAME_INVALID,

	push	0
	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_0CA@CEHKGAHL@ref?5name?5?8?$CFs?8?5is?5not?5an?5NCName?6@
	push	1100					; 0000044cH
$LN254@xmlRelaxNG:

; 4942 :                            "ref name '%s' is not an NCName\n", def->name,
; 4943 :                            NULL);
; 4944 :             }
; 4945 :         }
; 4946 :         if (node->children != NULL) {

	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN45@xmlRelaxNG:
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN46@xmlRelaxNG

; 4947 :             xmlRngPErr(ctxt, node, XML_RNGP_REF_NOT_EMPTY, "ref is not empty\n",

	push	0
	push	0
	push	OFFSET ??_C@_0BC@KLFBBEAG@ref?5is?5not?5empty?6@
	push	1103					; 0000044fH
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN46@xmlRelaxNG:

; 4948 :                        NULL, NULL);
; 4949 :         }
; 4950 :         if (ctxt->grammar->refs == NULL)

	mov	eax, DWORD PTR [ebx+24]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN47@xmlRelaxNG

; 4951 :             ctxt->grammar->refs = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	mov	ecx, DWORD PTR [ebx+24]
	add	esp, 4
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR [ebx+24]
$LN47@xmlRelaxNG:

; 4952 :         if (ctxt->grammar->refs == NULL) {

	mov	eax, DWORD PTR [eax+28]
	test	eax, eax
	jne	SHORT $LN48@xmlRelaxNG

; 4953 :             xmlRngPErr(ctxt, node, XML_RNGP_REF_CREATE_FAILED,

	push	eax
	push	eax
	push	OFFSET ??_C@_0CC@NOKALBCN@Could?5not?5create?5references?5has@
	push	1098					; 0000044aH
	push	esi
	push	ebx

; 5122 :                    "Unexpected node %s is not a pattern\n", node->name,
; 5123 :                    NULL);
; 5124 :         def = NULL;
; 5125 :     }
; 5126 :     return (def);

	call	_xmlRngPErr
	add	esp, 24					; 00000018H
	xor	edi, edi

; 5127 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@xmlRelaxNG:

; 4954 :                        "Could not create references hash\n", NULL, NULL);
; 4955 :             def = NULL;
; 4956 :         } else {
; 4957 :             int tmp;
; 4958 : 
; 4959 :             tmp = xmlHashAddEntry(ctxt->grammar->refs, def->name, def);

	push	edi
	push	DWORD PTR [edi+8]
	push	eax
	call	_xmlHashAddEntry
	add	esp, 12					; 0000000cH

; 4960 :             if (tmp < 0) {

	test	eax, eax
	jns	$LN93@xmlRelaxNG

; 4961 :                 xmlRelaxNGDefinePtr prev;
; 4962 : 
; 4963 :                 prev = (xmlRelaxNGDefinePtr)

	mov	eax, DWORD PTR [ebx+24]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [eax+28]
	call	_xmlHashLookup
	mov	ecx, eax
	add	esp, 8

; 4964 :                     xmlHashLookup(ctxt->grammar->refs, def->name);
; 4965 :                 if (prev == NULL) {

	test	ecx, ecx
	jne	$LN90@xmlRelaxNG

; 4966 :                     if (def->name != NULL) {

	mov	ecx, DWORD PTR [edi+8]

; 4967 : 		        xmlRngPErr(ctxt, node, XML_RNGP_REF_CREATE_FAILED,
; 4968 : 				   "Error refs definitions '%s'\n",
; 4969 : 				   def->name, NULL);
; 4970 :                     } else {
; 4971 : 		        xmlRngPErr(ctxt, node, XML_RNGP_REF_CREATE_FAILED,
; 4972 : 				   "Error refs definitions\n",
; 4973 : 				   NULL, NULL);
; 4974 :                     }
; 4975 :                     def = NULL;

	mov	edx, OFFSET ??_C@_0BN@KBAJDCGM@Error?5refs?5definitions?5?8?$CFs?8?6@
	push	eax
	push	ecx
	test	ecx, ecx
	mov	eax, OFFSET ??_C@_0BI@KAJIFPGI@Error?5refs?5definitions?6@
	cmovne	eax, edx
	push	eax
	push	1098					; 0000044aH
	push	esi
	push	ebx

; 5122 :                    "Unexpected node %s is not a pattern\n", node->name,
; 5123 :                    NULL);
; 5124 :         def = NULL;
; 5125 :     }
; 5126 :     return (def);

	call	_xmlRngPErr
	add	esp, 24					; 00000018H
	xor	edi, edi

; 5127 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@xmlRelaxNG:

; 4976 :                 } else {
; 4977 :                     def->nextHash = prev->nextHash;
; 4978 :                     prev->nextHash = def;
; 4979 :                 }
; 4980 :             }
; 4981 :         }
; 4982 :     } else if (IS_RELAXNG(node, "data")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN55@xmlRelaxNG
	push	OFFSET ??_C@_04PJOLNDGD@data@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN55@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN55@xmlRelaxNG

; 4983 :         def = xmlRelaxNGParseData(ctxt, node);

	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGParseData
	add	esp, 8
	mov	edi, eax
	pop	edi

; 5127 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN55@xmlRelaxNG:

; 4984 :     } else if (IS_RELAXNG(node, "value")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN57@xmlRelaxNG
	push	OFFSET ??_C@_05MFEJDJP@value@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN57@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN57@xmlRelaxNG

; 4985 :         def = xmlRelaxNGParseValue(ctxt, node);

	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGParseValue
	add	esp, 8
	mov	edi, eax
	pop	edi

; 5127 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN57@xmlRelaxNG:

; 4986 :     } else if (IS_RELAXNG(node, "list")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN59@xmlRelaxNG
	push	OFFSET ??_C@_04DONFEANM@list@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN59@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN59@xmlRelaxNG

; 4987 :         def = xmlRelaxNGNewDefine(ctxt, node);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	esi
	push	ebx
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8

; 4988 :         if (def == NULL)

	test	edi, edi
	je	$LN231@xmlRelaxNG

; 4989 :             return (NULL);
; 4990 :         def->type = XML_RELAXNG_LIST;

	mov	DWORD PTR [edi], 8

; 4991 :         if (node->children == NULL) {

	mov	eax, DWORD PTR [esi+12]
	push	0
	test	eax, eax
	jne	$LN62@xmlRelaxNG

; 4992 :             xmlRngPErr(ctxt, node, XML_RNGP_EMPTY_CONSTRUCT,
; 4993 :                        "Element %s is empty\n", node->name, NULL);
; 4994 :         } else {

	jmp	$LN259@xmlRelaxNG
$LN59@xmlRelaxNG:

; 4995 :             def->content =
; 4996 :                 xmlRelaxNGParsePatterns(ctxt, node->children, 0);
; 4997 :         }
; 4998 :     } else if (IS_RELAXNG(node, "interleave")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN64@xmlRelaxNG
	push	OFFSET ??_C@_0L@NLPEADBD@interleave@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN64@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN64@xmlRelaxNG

; 4999 :         def = xmlRelaxNGParseInterleave(ctxt, node);

	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGParseInterleave
	add	esp, 8
	mov	edi, eax
	pop	edi

; 5127 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN64@xmlRelaxNG:

; 5000 :     } else if (IS_RELAXNG(node, "externalRef")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN66@xmlRelaxNG
	push	OFFSET ??_C@_0M@CPEFJFBC@externalRef@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN66@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN66@xmlRelaxNG

; 5001 :         def = xmlRelaxNGProcessExternalRef(ctxt, node);

	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGProcessExternalRef
	add	esp, 8
	mov	edi, eax
	pop	edi

; 5127 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN66@xmlRelaxNG:

; 5002 :     } else if (IS_RELAXNG(node, "notAllowed")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN68@xmlRelaxNG
	push	OFFSET ??_C@_0L@GPGJMKBL@notAllowed@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN68@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN68@xmlRelaxNG

; 5003 :         def = xmlRelaxNGNewDefine(ctxt, node);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	esi
	push	ebx
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8

; 5004 :         if (def == NULL)

	test	edi, edi
	je	$LN231@xmlRelaxNG

; 5005 :             return (NULL);
; 5006 :         def->type = XML_RELAXNG_NOT_ALLOWED;

	mov	DWORD PTR [edi], 1

; 5007 :         if (node->children != NULL) {

	cmp	DWORD PTR [esi+12], 0
	je	$LN93@xmlRelaxNG

; 5008 :             xmlRngPErr(ctxt, node, XML_RNGP_NOTALLOWED_NOT_EMPTY,

	push	0
	push	0
	push	OFFSET ??_C@_0DC@MEMHAAID@xmlRelaxNGParse?3?5notAllowed?5ele@
	push	1055					; 0000041fH
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 5127 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN68@xmlRelaxNG:

; 5009 :                        "xmlRelaxNGParse: notAllowed element is not empty\n",
; 5010 :                        NULL, NULL);
; 5011 :         }
; 5012 :     } else if (IS_RELAXNG(node, "grammar")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN72@xmlRelaxNG
	push	OFFSET ??_C@_07EFOLCII@grammar@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN72@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN72@xmlRelaxNG

; 5013 :         xmlRelaxNGGrammarPtr grammar, old;
; 5014 :         xmlRelaxNGGrammarPtr oldparent;
; 5015 : 
; 5016 : #ifdef DEBUG_GRAMMAR
; 5017 :         xmlGenericError(xmlGenericErrorContext,
; 5018 :                         "Found <grammar> pattern\n");
; 5019 : #endif
; 5020 : 
; 5021 :         oldparent = ctxt->parentgrammar;

	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edi+28]

; 5022 :         old = ctxt->grammar;

	mov	ebx, DWORD PTR [edi+24]

; 5023 :         ctxt->parentgrammar = old;

	mov	DWORD PTR [edi+28], ebx

; 5024 :         grammar = xmlRelaxNGParseGrammar(ctxt, node->children);

	push	DWORD PTR [esi+12]
	mov	DWORD PTR _oldparent$1$[ebp], eax
	push	edi
	call	_xmlRelaxNGParseGrammar
	add	esp, 8

; 5025 :         if (old != NULL) {

	test	ebx, ebx
	je	SHORT $LN74@xmlRelaxNG

; 5026 :             ctxt->grammar = old;
; 5027 :             ctxt->parentgrammar = oldparent;

	mov	ecx, DWORD PTR _oldparent$1$[ebp]
	mov	DWORD PTR [edi+24], ebx
	mov	DWORD PTR [edi+28], ecx
$LN74@xmlRelaxNG:

; 5028 : #if 0
; 5029 :             if (grammar != NULL) {
; 5030 :                 grammar->next = old->next;
; 5031 :                 old->next = grammar;
; 5032 :             }
; 5033 : #endif
; 5034 :         }
; 5035 :         if (grammar != NULL)

	test	eax, eax
	je	$LN252@xmlRelaxNG

; 5036 :             def = grammar->start;

	mov	edi, DWORD PTR [eax+12]

; 5127 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN72@xmlRelaxNG:

; 5037 :         else
; 5038 :             def = NULL;
; 5039 :     } else if (IS_RELAXNG(node, "parentRef")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	$LN77@xmlRelaxNG
	push	OFFSET ??_C@_09LEMMFILP@parentRef@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN77@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN77@xmlRelaxNG

; 5040 :         if (ctxt->parentgrammar == NULL) {

	mov	ebx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ebx+28], 0
	jne	SHORT $LN79@xmlRelaxNG

; 5041 :             xmlRngPErr(ctxt, node, XML_RNGP_PARENTREF_NO_PARENT,

	push	0
	push	0
	push	OFFSET ??_C@_0CL@EGBMGFAB@Use?5of?5parentRef?5without?5a?5pare@
	push	1063					; 00000427H
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN231@xmlRelaxNG:

; 5127 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN79@xmlRelaxNG:

; 5042 :                        "Use of parentRef without a parent grammar\n", NULL,
; 5043 :                        NULL);
; 5044 :             return (NULL);
; 5045 :         }
; 5046 :         def = xmlRelaxNGNewDefine(ctxt, node);

	push	esi
	push	ebx
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8

; 5047 :         if (def == NULL)

	test	edi, edi
	je	SHORT $LN231@xmlRelaxNG

; 5048 :             return (NULL);
; 5049 :         def->type = XML_RELAXNG_PARENTREF;
; 5050 :         def->name = xmlGetProp(node, BAD_CAST "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	esi
	mov	DWORD PTR [edi], 13			; 0000000dH
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR [edi+8], eax

; 5051 :         if (def->name == NULL) {

	test	eax, eax
	jne	SHORT $LN81@xmlRelaxNG

; 5052 :             xmlRngPErr(ctxt, node, XML_RNGP_PARENTREF_NO_NAME,

	push	eax
	push	eax
	push	OFFSET ??_C@_0BH@CNIAONFA@parentRef?5has?5no?5name?6@
	push	1062					; 00000426H

; 5053 :                        "parentRef has no name\n", NULL, NULL);
; 5054 :         } else {

	jmp	SHORT $LN256@xmlRelaxNG
$LN81@xmlRelaxNG:

; 5055 :             xmlRelaxNGNormExtSpace(def->name);

	push	eax
	call	_xmlRelaxNGNormExtSpace

; 5056 :             if (xmlValidateNCName(def->name, 0)) {

	push	0
	push	DWORD PTR [edi+8]
	call	_xmlValidateNCName
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN83@xmlRelaxNG

; 5057 :                 xmlRngPErr(ctxt, node, XML_RNGP_PARENTREF_NAME_INVALID,

	push	0
	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_0CG@HCJCFDNF@parentRef?5name?5?8?$CFs?8?5is?5not?5an?5N@
	push	1061					; 00000425H
$LN256@xmlRelaxNG:

; 5058 :                            "parentRef name '%s' is not an NCName\n",
; 5059 :                            def->name, NULL);
; 5060 :             }
; 5061 :         }
; 5062 :         if (node->children != NULL) {

	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN83@xmlRelaxNG:
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN84@xmlRelaxNG

; 5063 :             xmlRngPErr(ctxt, node, XML_RNGP_PARENTREF_NOT_EMPTY,

	push	0
	push	0
	push	OFFSET ??_C@_0BI@IFNGOHLC@parentRef?5is?5not?5empty?6@
	push	1064					; 00000428H
	push	esi
	push	ebx
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN84@xmlRelaxNG:

; 5064 :                        "parentRef is not empty\n", NULL, NULL);
; 5065 :         }
; 5066 :         if (ctxt->parentgrammar->refs == NULL)

	mov	eax, DWORD PTR [ebx+28]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN85@xmlRelaxNG

; 5067 :             ctxt->parentgrammar->refs = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	mov	ecx, DWORD PTR [ebx+28]
	add	esp, 4
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR [ebx+28]
$LN85@xmlRelaxNG:

; 5068 :         if (ctxt->parentgrammar->refs == NULL) {

	mov	ecx, DWORD PTR [eax+28]
	test	ecx, ecx
	jne	SHORT $LN86@xmlRelaxNG

; 5069 :             xmlRngPErr(ctxt, node, XML_RNGP_PARENTREF_CREATE_FAILED,

	push	ecx
	push	ecx
	push	OFFSET ??_C@_0CC@NOKALBCN@Could?5not?5create?5references?5has@
	push	1060					; 00000424H
	push	esi
	push	ebx

; 5122 :                    "Unexpected node %s is not a pattern\n", node->name,
; 5123 :                    NULL);
; 5124 :         def = NULL;
; 5125 :     }
; 5126 :     return (def);

	call	_xmlRngPErr
	add	esp, 24					; 00000018H
	xor	edi, edi

; 5127 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN86@xmlRelaxNG:

; 5070 :                        "Could not create references hash\n", NULL, NULL);
; 5071 :             def = NULL;
; 5072 :         } else if (def->name != NULL) {

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	$LN93@xmlRelaxNG

; 5073 :             int tmp;
; 5074 : 
; 5075 :             tmp =

	push	edi
	push	eax
	push	ecx
	call	_xmlHashAddEntry
	add	esp, 12					; 0000000cH

; 5076 :                 xmlHashAddEntry(ctxt->parentgrammar->refs, def->name, def);
; 5077 :             if (tmp < 0) {

	test	eax, eax
	jns	$LN93@xmlRelaxNG

; 5078 :                 xmlRelaxNGDefinePtr prev;
; 5079 : 
; 5080 :                 prev = (xmlRelaxNGDefinePtr)

	mov	eax, DWORD PTR [ebx+28]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [eax+28]
	call	_xmlHashLookup
	mov	ecx, eax
	add	esp, 8

; 5081 :                     xmlHashLookup(ctxt->parentgrammar->refs, def->name);
; 5082 :                 if (prev == NULL) {

	test	ecx, ecx
	jne	SHORT $LN90@xmlRelaxNG

; 5083 :                     xmlRngPErr(ctxt, node, XML_RNGP_PARENTREF_CREATE_FAILED,

	push	eax
	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_0CL@BEBEIBPH@Internal?5error?5parentRef?5defini@
	push	1060					; 00000424H
	push	esi
	push	ebx

; 5122 :                    "Unexpected node %s is not a pattern\n", node->name,
; 5123 :                    NULL);
; 5124 :         def = NULL;
; 5125 :     }
; 5126 :     return (def);

	call	_xmlRngPErr
	add	esp, 24					; 00000018H
	xor	edi, edi

; 5127 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN90@xmlRelaxNG:

; 5122 :                    "Unexpected node %s is not a pattern\n", node->name,
; 5123 :                    NULL);
; 5124 :         def = NULL;
; 5125 :     }
; 5126 :     return (def);

	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [edi+44], eax

; 5127 : }

	mov	eax, edi
	mov	DWORD PTR [ecx+44], edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN77@xmlRelaxNG:

; 5084 :                                "Internal error parentRef definitions '%s'\n",
; 5085 :                                def->name, NULL);
; 5086 :                     def = NULL;
; 5087 :                 } else {
; 5088 :                     def->nextHash = prev->nextHash;
; 5089 :                     prev->nextHash = def;
; 5090 :                 }
; 5091 :             }
; 5092 :         }
; 5093 :     } else if (IS_RELAXNG(node, "mixed")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN92@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	$LN92@xmlRelaxNG
	push	OFFSET ??_C@_05IPHDHIPP@mixed@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN92@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN92@xmlRelaxNG

; 5094 :         if (node->children == NULL) {

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN94@xmlRelaxNG

; 5095 :             xmlRngPErr(ctxt, node, XML_RNGP_EMPTY_CONSTRUCT, "Mixed is empty\n",

	push	0
	push	0
	push	OFFSET ??_C@_0BA@KLBAOPHA@Mixed?5is?5empty?6@
	push	1023					; 000003ffH

; 5096 :                        NULL, NULL);
; 5097 :             def = NULL;
; 5098 :         } else {

	jmp	SHORT $LN257@xmlRelaxNG
$LN94@xmlRelaxNG:

; 5099 :             def = xmlRelaxNGParseInterleave(ctxt, node);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	esi
	push	ebx
	call	_xmlRelaxNGParseInterleave
	mov	edi, eax
	add	esp, 8

; 5100 :             if (def != NULL) {

	test	edi, edi
	je	SHORT $LN93@xmlRelaxNG

; 5101 :                 xmlRelaxNGDefinePtr tmp;
; 5102 : 
; 5103 :                 if ((def->content != NULL) && (def->content->next != NULL)) {

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN98@xmlRelaxNG
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN98@xmlRelaxNG

; 5104 :                     tmp = xmlRelaxNGNewDefine(ctxt, node);

	push	esi
	push	ebx
	call	_xmlRelaxNGNewDefine
	add	esp, 8

; 5105 :                     if (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN98@xmlRelaxNG

; 5106 :                         tmp->type = XML_RELAXNG_GROUP;

	mov	DWORD PTR [eax], 18			; 00000012H

; 5107 :                         tmp->content = def->content;

	mov	ecx, DWORD PTR [edi+24]
	mov	DWORD PTR [eax+24], ecx

; 5108 :                         def->content = tmp;

	mov	DWORD PTR [edi+24], eax
$LN98@xmlRelaxNG:

; 5109 :                     }
; 5110 :                 }
; 5111 : 
; 5112 :                 tmp = xmlRelaxNGNewDefine(ctxt, node);

	push	esi
	push	ebx
	call	_xmlRelaxNGNewDefine
	mov	ecx, eax
	add	esp, 8

; 5113 :                 if (tmp == NULL)

	test	ecx, ecx
	je	SHORT $LN93@xmlRelaxNG

; 5114 :                     return (def);
; 5115 :                 tmp->type = XML_RELAXNG_TEXT;

	mov	DWORD PTR [ecx], 3

; 5116 :                 tmp->next = def->content;

	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [ecx+32], eax

; 5127 : }

	mov	eax, edi
	mov	DWORD PTR [edi+24], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN92@xmlRelaxNG:

; 5117 :                 def->content = tmp;
; 5118 :             }
; 5119 :         }
; 5120 :     } else {
; 5121 :         xmlRngPErr(ctxt, node, XML_RNGP_UNKNOWN_CONSTRUCT,

	push	0
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0CF@JOIAOFAL@Unexpected?5node?5?$CFs?5is?5not?5a?5pat@
	push	1115					; 0000045bH
$LN257@xmlRelaxNG:

; 5122 :                    "Unexpected node %s is not a pattern\n", node->name,
; 5123 :                    NULL);
; 5124 :         def = NULL;
; 5125 :     }
; 5126 :     return (def);

	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN252@xmlRelaxNG:
	xor	edi, edi
$LN93@xmlRelaxNG:

; 5127 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN261@xmlRelaxNG:
	DD	$LN133@xmlRelaxNG
	DD	$LN131@xmlRelaxNG
	DD	$LN132@xmlRelaxNG
$LN232@xmlRelaxNG:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	1
	DB	1
	DB	1
	DB	2
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	2
_xmlRelaxNGParsePattern ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParsePatterns
_TEXT	SEGMENT
_parent$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_cur$1$ = 12						; size = 4
_nodes$ = 12						; size = 4
_group$ = 16						; size = 4
_xmlRelaxNGParsePatterns PROC				; COMDAT

; 5544 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	xor	ebx, ebx
	mov	eax, DWORD PTR [esi+48]
	mov	esi, DWORD PTR _nodes$[ebp]
	mov	DWORD PTR _parent$1$[ebp], eax
	test	esi, esi
	je	$LN17@xmlRelaxNG
$LN21@xmlRelaxNG:

; 5545 :     xmlRelaxNGDefinePtr def = NULL, last = NULL, cur, parent;
; 5546 : 
; 5547 :     parent = ctxt->def;
; 5548 :     while (nodes != NULL) {
; 5549 :         if (IS_RELAXNG(nodes, "element")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN4@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN4@xmlRelaxNG
	push	OFFSET ??_C@_07HCLJNICE@element@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@xmlRelaxNG

; 5550 :             cur = xmlRelaxNGParseElement(ctxt, nodes);

	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGParseElement
	add	esp, 8
	mov	DWORD PTR _cur$1$[ebp], eax

; 5551 :             if (def == NULL) {

	test	edi, edi
	jne	SHORT $LN6@xmlRelaxNG

; 5559 :                 }
; 5560 :                 last->next = cur;
; 5561 :                 last = cur;
; 5562 :             }
; 5563 :             cur->parent = parent;

	mov	ecx, DWORD PTR _parent$1$[ebp]
	mov	edi, eax
	mov	DWORD PTR [eax+28], ecx

; 5564 :         } else {

	jmp	SHORT $LN19@xmlRelaxNG
$LN6@xmlRelaxNG:

; 5552 :                 def = last = cur;
; 5553 :             } else {
; 5554 :                 if ((group == 1) && (def->type == XML_RELAXNG_ELEMENT) &&

	cmp	DWORD PTR _group$[ebp], 1
	jne	SHORT $LN8@xmlRelaxNG
	cmp	DWORD PTR [edi], 4
	jne	SHORT $LN8@xmlRelaxNG
	cmp	edi, ebx
	jne	SHORT $LN8@xmlRelaxNG

; 5555 :                     (def == last)) {
; 5556 :                     def = xmlRelaxNGNewDefine(ctxt, nodes);

	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8
	mov	eax, DWORD PTR _cur$1$[ebp]

; 5557 :                     def->type = XML_RELAXNG_GROUP;

	mov	DWORD PTR [edi], 18			; 00000012H

; 5558 :                     def->content = last;

	mov	DWORD PTR [edi+24], ebx
$LN8@xmlRelaxNG:

; 5559 :                 }
; 5560 :                 last->next = cur;
; 5561 :                 last = cur;
; 5562 :             }
; 5563 :             cur->parent = parent;

	mov	ecx, DWORD PTR _parent$1$[ebp]
	mov	DWORD PTR [ebx+32], eax
	mov	DWORD PTR [eax+28], ecx

; 5564 :         } else {

	jmp	SHORT $LN19@xmlRelaxNG
$LN4@xmlRelaxNG:

; 5565 :             cur = xmlRelaxNGParsePattern(ctxt, nodes);

	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGParsePattern
	add	esp, 8

; 5566 :             if (cur != NULL) {

	test	eax, eax
	je	SHORT $LN11@xmlRelaxNG

; 5567 :                 if (def == NULL) {

	test	edi, edi
	jne	SHORT $LN10@xmlRelaxNG

; 5568 :                     def = last = cur;

	mov	edi, eax

; 5569 :                 } else {

	jmp	SHORT $LN19@xmlRelaxNG
$LN10@xmlRelaxNG:

; 5570 :                     last->next = cur;

	mov	DWORD PTR [ebx+32], eax
$LN19@xmlRelaxNG:

; 5571 :                     last = cur;
; 5572 :                 }
; 5573 :             }
; 5574 :         }
; 5575 :         nodes = nodes->next;

	mov	ebx, eax
$LN11@xmlRelaxNG:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	$LN21@xmlRelaxNG
$LN17@xmlRelaxNG:

; 5576 :     }
; 5577 :     return (def);
; 5578 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGParsePatterns ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParseElement
_TEXT	SEGMENT
_olddefine$1$ = -12					; size = 4
_cur$1$ = -8						; size = 4
_last$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlRelaxNGParseElement PROC				; COMDAT

; 5430 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	push	ebx
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _node$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	push	edi
	call	_xmlRelaxNGNewDefine
	mov	ebx, eax
	add	esp, 8
	test	ebx, ebx
	jne	SHORT $LN6@xmlRelaxNG

; 5529 : }

	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlRelaxNG:

; 5431 :     xmlRelaxNGDefinePtr ret, cur, last;
; 5432 :     xmlNodePtr child;
; 5433 :     const xmlChar *olddefine;
; 5434 : 
; 5435 :     ret = xmlRelaxNGNewDefine(ctxt, node);
; 5436 :     if (ret == NULL)
; 5437 :         return (NULL);
; 5438 :     ret->type = XML_RELAXNG_ELEMENT;

	mov	DWORD PTR [ebx], 4

; 5439 :     ret->parent = ctxt->def;

	mov	eax, DWORD PTR [edi+48]
	mov	DWORD PTR [ebx+28], eax

; 5440 :     child = node->children;

	mov	eax, DWORD PTR _node$[ebp]
	push	esi
	mov	esi, DWORD PTR [eax+12]

; 5441 :     if (child == NULL) {

	test	esi, esi
	jne	SHORT $LN7@xmlRelaxNG

; 5442 :         xmlRngPErr(ctxt, node, XML_RNGP_ELEMENT_EMPTY,

	push	esi
	push	esi
	push	OFFSET ??_C@_0DB@JEBMCLMO@xmlRelaxNGParseElement?3?5element@
	push	1017					; 000003f9H
	push	eax
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 5528 :     return (ret);

	mov	eax, ebx
	pop	esi
	pop	edi

; 5529 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlRelaxNG:

; 5443 :                    "xmlRelaxNGParseElement: element has no children\n",
; 5444 :                    NULL, NULL);
; 5445 :         return (ret);
; 5446 :     }
; 5447 :     cur = xmlRelaxNGParseNameClass(ctxt, child, ret);

	push	ebx
	push	esi
	push	edi
	call	_xmlRelaxNGParseNameClass
	add	esp, 12					; 0000000cH

; 5448 :     if (cur != NULL)

	test	eax, eax
	je	SHORT $LN8@xmlRelaxNG

; 5449 :         child = child->next;

	mov	esi, DWORD PTR [esi+24]
$LN8@xmlRelaxNG:

; 5450 : 
; 5451 :     if (child == NULL) {

	test	esi, esi
	jne	SHORT $LN9@xmlRelaxNG

; 5452 :         xmlRngPErr(ctxt, node, XML_RNGP_ELEMENT_NO_CONTENT,

	push	esi
	push	esi
	push	OFFSET ??_C@_0DA@IDPILCIF@xmlRelaxNGParseElement?3?5element@
	push	1020					; 000003fcH
	push	DWORD PTR _node$[ebp]
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 5528 :     return (ret);

	mov	eax, ebx
	pop	esi
	pop	edi

; 5529 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlRelaxNG:

; 5453 :                    "xmlRelaxNGParseElement: element has no content\n",
; 5454 :                    NULL, NULL);
; 5455 :         return (ret);
; 5456 :     }
; 5457 :     olddefine = ctxt->define;

	mov	eax, DWORD PTR [edi+44]

; 5458 :     ctxt->define = NULL;
; 5459 :     last = NULL;

	xor	ecx, ecx
	mov	DWORD PTR _olddefine$1$[ebp], eax
	mov	DWORD PTR [edi+44], 0
	mov	DWORD PTR _last$1$[ebp], ecx
	npad	4
$LL2@xmlRelaxNG:

; 5460 :     while (child != NULL) {
; 5461 :         cur = xmlRelaxNGParsePattern(ctxt, child);

	push	esi
	push	edi
	call	_xmlRelaxNGParsePattern
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR _cur$1$[ebp], edx

; 5462 :         if (cur != NULL) {

	test	edx, edx
	je	$LN4@xmlRelaxNG

; 5463 :             cur->parent = ret;
; 5464 :             switch (cur->type) {

	mov	ecx, DWORD PTR [edx]
	inc	ecx
	mov	DWORD PTR [edx+28], ebx
	cmp	ecx, 21					; 00000015H
	ja	$LN4@xmlRelaxNG
	movzx	eax, BYTE PTR $LN27@xmlRelaxNG[ecx]
	jmp	DWORD PTR $LN32@xmlRelaxNG[eax*4]
$LN11@xmlRelaxNG:

; 5465 :                 case XML_RELAXNG_EMPTY:
; 5466 :                 case XML_RELAXNG_NOT_ALLOWED:
; 5467 :                 case XML_RELAXNG_TEXT:
; 5468 :                 case XML_RELAXNG_ELEMENT:
; 5469 :                 case XML_RELAXNG_DATATYPE:
; 5470 :                 case XML_RELAXNG_VALUE:
; 5471 :                 case XML_RELAXNG_LIST:
; 5472 :                 case XML_RELAXNG_REF:
; 5473 :                 case XML_RELAXNG_PARENTREF:
; 5474 :                 case XML_RELAXNG_EXTERNALREF:
; 5475 :                 case XML_RELAXNG_DEF:
; 5476 :                 case XML_RELAXNG_ZEROORMORE:
; 5477 :                 case XML_RELAXNG_ONEORMORE:
; 5478 :                 case XML_RELAXNG_OPTIONAL:
; 5479 :                 case XML_RELAXNG_CHOICE:
; 5480 :                 case XML_RELAXNG_GROUP:
; 5481 :                 case XML_RELAXNG_INTERLEAVE:
; 5482 :                     if (last == NULL) {

	mov	eax, DWORD PTR _last$1$[ebp]
	test	eax, eax
	jne	SHORT $LN12@xmlRelaxNG

; 5483 :                         ret->content = last = cur;

	mov	DWORD PTR _last$1$[ebp], edx
	mov	DWORD PTR [ebx+24], edx

; 5484 :                     } else {

	jmp	$LN4@xmlRelaxNG
$LN12@xmlRelaxNG:

; 5485 :                         if ((last->type == XML_RELAXNG_ELEMENT) &&

	cmp	DWORD PTR [eax], 4
	jne	SHORT $LN16@xmlRelaxNG
	cmp	DWORD PTR [ebx+24], eax
	jne	SHORT $LN16@xmlRelaxNG

; 5486 :                             (ret->content == last)) {
; 5487 :                             ret->content = xmlRelaxNGNewDefine(ctxt, node);

	push	DWORD PTR _node$[ebp]
	push	edi
	call	_xmlRelaxNGNewDefine

; 5488 :                             if (ret->content != NULL) {

	mov	edx, DWORD PTR _cur$1$[ebp]
	add	esp, 8
	mov	DWORD PTR [ebx+24], eax
	test	eax, eax
	je	SHORT $LN15@xmlRelaxNG

; 5489 :                                 ret->content->type = XML_RELAXNG_GROUP;
; 5490 :                                 ret->content->content = last;

	mov	ecx, DWORD PTR _last$1$[ebp]
	mov	DWORD PTR [eax], 18			; 00000012H
	mov	eax, DWORD PTR [ebx+24]

; 5496 :                         last = cur;

	mov	DWORD PTR _last$1$[ebp], edx
	mov	DWORD PTR [eax+24], ecx
	mov	eax, ecx
	mov	DWORD PTR [eax+32], edx

; 5497 :                     }
; 5498 :                     break;

	jmp	SHORT $LN4@xmlRelaxNG
$LN15@xmlRelaxNG:

; 5491 :                             } else {
; 5492 :                                 ret->content = last;

	mov	eax, DWORD PTR _last$1$[ebp]
	mov	DWORD PTR [ebx+24], eax
$LN16@xmlRelaxNG:

; 5493 :                             }
; 5494 :                         }
; 5495 :                         last->next = cur;

	mov	DWORD PTR [eax+32], edx

; 5496 :                         last = cur;

	mov	DWORD PTR _last$1$[ebp], edx

; 5497 :                     }
; 5498 :                     break;

	jmp	SHORT $LN4@xmlRelaxNG
$LN17@xmlRelaxNG:

; 5499 :                 case XML_RELAXNG_ATTRIBUTE:
; 5500 :                     cur->next = ret->attrs;

	mov	eax, DWORD PTR [ebx+36]
	mov	DWORD PTR [edx+32], eax

; 5501 :                     ret->attrs = cur;

	mov	DWORD PTR [ebx+36], edx

; 5502 :                     break;

	jmp	SHORT $LN4@xmlRelaxNG
$LN18@xmlRelaxNG:

; 5503 :                 case XML_RELAXNG_START:
; 5504 :                     xmlRngPErr(ctxt, node, XML_RNGP_ELEMENT_CONTENT,

	push	0
	push	0
	push	OFFSET ??_C@_0CM@MFMPBBAO@RNG?5Internal?5error?0?5start?5found@

; 5505 :                                "RNG Internal error, start found in element\n",
; 5506 :                                NULL, NULL);
; 5507 :                     break;

	jmp	SHORT $LN30@xmlRelaxNG
$LN19@xmlRelaxNG:

; 5508 :                 case XML_RELAXNG_PARAM:
; 5509 :                     xmlRngPErr(ctxt, node, XML_RNGP_ELEMENT_CONTENT,

	push	0
	push	0
	push	OFFSET ??_C@_0CM@LPIDEEPC@RNG?5Internal?5error?0?5param?5found@

; 5510 :                                "RNG Internal error, param found in element\n",
; 5511 :                                NULL, NULL);
; 5512 :                     break;

	jmp	SHORT $LN30@xmlRelaxNG
$LN20@xmlRelaxNG:

; 5513 :                 case XML_RELAXNG_EXCEPT:
; 5514 :                     xmlRngPErr(ctxt, node, XML_RNGP_ELEMENT_CONTENT,

	push	0
	push	0
	push	OFFSET ??_C@_0CN@HLONCHKK@RNG?5Internal?5error?0?5except?5foun@

; 5515 :                                "RNG Internal error, except found in element\n",
; 5516 :                                NULL, NULL);
; 5517 :                     break;

	jmp	SHORT $LN30@xmlRelaxNG
$LN21@xmlRelaxNG:

; 5518 :                 case XML_RELAXNG_NOOP:
; 5519 :                     xmlRngPErr(ctxt, node, XML_RNGP_ELEMENT_CONTENT,

	push	0
	push	0
	push	OFFSET ??_C@_0CL@MLMNOJNJ@RNG?5Internal?5error?0?5noop?5found?5@
$LN30@xmlRelaxNG:

; 5520 :                                "RNG Internal error, noop found in element\n",
; 5521 :                                NULL, NULL);
; 5522 :                     break;
; 5523 :             }
; 5524 :         }
; 5525 :         child = child->next;

	push	1018					; 000003faH
	push	DWORD PTR _node$[ebp]
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN4@xmlRelaxNG:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	$LL2@xmlRelaxNG

; 5526 :     }
; 5527 :     ctxt->define = olddefine;

	mov	eax, DWORD PTR _olddefine$1$[ebp]
	pop	esi
	mov	DWORD PTR [edi+44], eax

; 5528 :     return (ret);

	mov	eax, ebx
	pop	edi

; 5529 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN32@xmlRelaxNG:
	DD	$LN21@xmlRelaxNG
	DD	$LN11@xmlRelaxNG
	DD	$LN20@xmlRelaxNG
	DD	$LN19@xmlRelaxNG
	DD	$LN17@xmlRelaxNG
	DD	$LN18@xmlRelaxNG
$LN27@xmlRelaxNG:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	1
	DB	1
	DB	1
	DB	3
	DB	1
	DB	1
	DB	4
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	5
_xmlRelaxNGParseElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParseAttribute
_TEXT	SEGMENT
_old_flags$1$ = -8					; size = 4
_child$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlRelaxNGParseAttribute PROC				; COMDAT

; 5140 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	ebx
	push	esi
	call	_xmlRelaxNGNewDefine
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	jne	SHORT $LN4@xmlRelaxNG

; 5209 :     return (ret);
; 5210 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlRelaxNG:

; 5141 :     xmlRelaxNGDefinePtr ret, cur;
; 5142 :     xmlNodePtr child;
; 5143 :     int old_flags;
; 5144 : 
; 5145 :     ret = xmlRelaxNGNewDefine(ctxt, node);
; 5146 :     if (ret == NULL)
; 5147 :         return (NULL);
; 5148 :     ret->type = XML_RELAXNG_ATTRIBUTE;

	mov	DWORD PTR [edi], 9

; 5149 :     ret->parent = ctxt->def;

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [edi+28], eax

; 5150 :     child = node->children;

	mov	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR _child$1$[ebp], ecx

; 5151 :     if (child == NULL) {

	test	ecx, ecx
	jne	SHORT $LN5@xmlRelaxNG

; 5152 :         xmlRngPErr(ctxt, node, XML_RNGP_ATTRIBUTE_EMPTY,

	push	ecx
	push	ecx
	push	OFFSET ??_C@_0DF@EOBONIDO@xmlRelaxNGParseattribute?3?5attri@
	push	1004					; 000003ecH
	push	ebx
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 5209 :     return (ret);
; 5210 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlRelaxNG:

; 5153 :                    "xmlRelaxNGParseattribute: attribute has no children\n",
; 5154 :                    NULL, NULL);
; 5155 :         return (ret);
; 5156 :     }
; 5157 :     old_flags = ctxt->flags;

	mov	eax, DWORD PTR [esi+32]

; 5158 :     ctxt->flags |= XML_RELAXNG_IN_ATTRIBUTE;
; 5159 :     cur = xmlRelaxNGParseNameClass(ctxt, child, ret);

	push	edi
	mov	DWORD PTR _old_flags$1$[ebp], eax
	or	eax, 1
	push	ecx
	push	esi
	mov	DWORD PTR [esi+32], eax
	call	_xmlRelaxNGParseNameClass
	add	esp, 12					; 0000000cH

; 5160 :     if (cur != NULL)

	test	eax, eax
	mov	eax, DWORD PTR _child$1$[ebp]
	je	SHORT $LN6@xmlRelaxNG

; 5161 :         child = child->next;

	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR _child$1$[ebp], eax
$LN6@xmlRelaxNG:

; 5162 : 
; 5163 :     if (child != NULL) {

	test	eax, eax
	je	SHORT $LN12@xmlRelaxNG

; 5164 :         cur = xmlRelaxNGParsePattern(ctxt, child);

	push	eax
	push	esi
	call	_xmlRelaxNGParsePattern
	add	esp, 8

; 5165 :         if (cur != NULL) {

	test	eax, eax
	je	SHORT $LN2@xmlRelaxNG

; 5166 :             switch (cur->type) {

	mov	ecx, DWORD PTR [eax]
	inc	ecx
	cmp	ecx, 21					; 00000015H
	ja	SHORT $LN2@xmlRelaxNG
	movzx	ecx, BYTE PTR $LN14@xmlRelaxNG[ecx]
	jmp	DWORD PTR $LN19@xmlRelaxNG[ecx*4]
$LN9@xmlRelaxNG:

; 5167 :                 case XML_RELAXNG_EMPTY:
; 5168 :                 case XML_RELAXNG_NOT_ALLOWED:
; 5169 :                 case XML_RELAXNG_TEXT:
; 5170 :                 case XML_RELAXNG_ELEMENT:
; 5171 :                 case XML_RELAXNG_DATATYPE:
; 5172 :                 case XML_RELAXNG_VALUE:
; 5173 :                 case XML_RELAXNG_LIST:
; 5174 :                 case XML_RELAXNG_REF:
; 5175 :                 case XML_RELAXNG_PARENTREF:
; 5176 :                 case XML_RELAXNG_EXTERNALREF:
; 5177 :                 case XML_RELAXNG_DEF:
; 5178 :                 case XML_RELAXNG_ONEORMORE:
; 5179 :                 case XML_RELAXNG_ZEROORMORE:
; 5180 :                 case XML_RELAXNG_OPTIONAL:
; 5181 :                 case XML_RELAXNG_CHOICE:
; 5182 :                 case XML_RELAXNG_GROUP:
; 5183 :                 case XML_RELAXNG_INTERLEAVE:
; 5184 :                 case XML_RELAXNG_ATTRIBUTE:
; 5185 :                     ret->content = cur;

	mov	DWORD PTR [edi+24], eax

; 5186 :                     cur->parent = ret;

	mov	DWORD PTR [eax+28], edi

; 5187 :                     break;

	jmp	SHORT $LN2@xmlRelaxNG
$LN10@xmlRelaxNG:

; 5188 :                 case XML_RELAXNG_START:
; 5189 :                 case XML_RELAXNG_PARAM:
; 5190 :                 case XML_RELAXNG_EXCEPT:
; 5191 :                     xmlRngPErr(ctxt, node, XML_RNGP_ATTRIBUTE_CONTENT,

	push	0
	push	0
	push	OFFSET ??_C@_0BP@NPGIAHLH@attribute?5has?5invalid?5content?6@
	push	1003					; 000003ebH

; 5192 :                                "attribute has invalid content\n", NULL,
; 5193 :                                NULL);
; 5194 :                     break;

	jmp	SHORT $LN17@xmlRelaxNG
$LN11@xmlRelaxNG:

; 5195 :                 case XML_RELAXNG_NOOP:
; 5196 :                     xmlRngPErr(ctxt, node, XML_RNGP_ATTRIBUTE_NOOP,

	push	0
	push	0
	push	OFFSET ??_C@_0CN@KBLNJNDN@RNG?5Internal?5error?0?5noop?5found?5@
	push	1005					; 000003edH
$LN17@xmlRelaxNG:

; 5197 :                                "RNG Internal error, noop found in attribute\n",
; 5198 :                                NULL, NULL);
; 5199 :                     break;
; 5200 :             }
; 5201 :         }
; 5202 :         child = child->next;
; 5203 :     }
; 5204 :     if (child != NULL) {

	push	ebx
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN2@xmlRelaxNG:
	mov	eax, DWORD PTR _child$1$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN12@xmlRelaxNG

; 5205 :         xmlRngPErr(ctxt, node, XML_RNGP_ATTRIBUTE_CHILDREN,

	push	0
	push	0
	push	OFFSET ??_C@_0CB@BOMNCDFG@attribute?5has?5multiple?5children@
	push	1002					; 000003eaH
	push	ebx
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN12@xmlRelaxNG:

; 5206 :                    "attribute has multiple children\n", NULL, NULL);
; 5207 :     }
; 5208 :     ctxt->flags = old_flags;

	mov	eax, DWORD PTR _old_flags$1$[ebp]
	mov	DWORD PTR [esi+32], eax

; 5209 :     return (ret);
; 5210 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN19@xmlRelaxNG:
	DD	$LN11@xmlRelaxNG
	DD	$LN9@xmlRelaxNG
	DD	$LN10@xmlRelaxNG
$LN14@xmlRelaxNG:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	1
	DB	1
	DB	1
	DB	2
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	2
_xmlRelaxNGParseAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGCompile
_TEXT	SEGMENT
_oldstate$1$ = -8					; size = 4
_oldstate$1$ = -8					; size = 4
_oldam$1$ = -4						; size = 4
_ret$1$ = -4						; size = 4
$T1 = 8							; size = 4
_target$1$ = 8						; size = 4
_oldstate$1$ = 8					; size = 4
_oldstate$1$ = 8					; size = 4
_oldstate$1$ = 8					; size = 4
_ctxt$ = 8						; size = 4
_def$ = 12						; size = 4
_xmlRelaxNGCompile PROC					; COMDAT

; 3041 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _ret$1$[ebp], 0
	test	edi, edi
	je	$LN21@xmlRelaxNG

; 3042 :     int ret = 0;
; 3043 :     xmlRelaxNGDefinePtr list;
; 3044 : 
; 3045 :     if ((ctxt == NULL) || (def == NULL))

	mov	ebx, DWORD PTR _def$[ebp]
	test	ebx, ebx
	je	$LN21@xmlRelaxNG

; 3047 : 
; 3048 :     switch (def->type) {

	mov	ecx, DWORD PTR [ebx]
	inc	ecx
	cmp	ecx, 21					; 00000015H
	ja	$LN129@xmlRelaxNG
	movzx	eax, BYTE PTR $LN123@xmlRelaxNG[ecx]
	jmp	DWORD PTR $LN133@xmlRelaxNG[eax*4]
$LN22@xmlRelaxNG:

; 3049 :         case XML_RELAXNG_START:
; 3050 :             if ((xmlRelaxNGIsCompileable(def) == 1) && (def->depth != -25)) {

	push	ebx
	call	_xmlRelaxNGIsCompileable
	add	esp, 4
	cmp	eax, 1
	jne	$LN129@xmlRelaxNG
	cmp	WORD PTR [ebx+48], -25			; ffffffe7H
	je	$LN129@xmlRelaxNG

; 3051 :                 xmlAutomataPtr oldam = ctxt->am;

	mov	eax, DWORD PTR [edi+132]

; 3052 :                 xmlAutomataStatePtr oldstate = ctxt->state;
; 3053 : 
; 3054 :                 def->depth = -25;
; 3055 : 
; 3056 :                 list = def->content;

	mov	esi, DWORD PTR [ebx+24]
	mov	DWORD PTR _oldam$1$[ebp], eax
	mov	eax, DWORD PTR [edi+136]
	mov	DWORD PTR _oldstate$1$[ebp], eax
	mov	eax, -25				; ffffffe7H
	mov	WORD PTR [ebx+48], ax

; 3057 :                 ctxt->am = xmlNewAutomata();

	call	_xmlNewAutomata
	mov	DWORD PTR [edi+132], eax

; 3058 :                 if (ctxt->am == NULL)

	test	eax, eax
	je	$LN21@xmlRelaxNG

; 3059 :                     return (-1);
; 3060 : 
; 3061 :                 /*
; 3062 :                  * assume identical strings but not same pointer are different
; 3063 :                  * atoms, needed for non-determinism detection
; 3064 :                  * That way if 2 elements with the same name are in a choice
; 3065 :                  * branch the automata is found non-deterministic and
; 3066 :                  * we fallback to the normal validation which does the right
; 3067 :                  * thing of exploring both choices.
; 3068 :                  */
; 3069 :                 xmlAutomataSetFlags(ctxt->am, 1);

	push	1
	push	eax
	call	_xmlAutomataSetFlags

; 3070 : 
; 3071 :                 ctxt->state = xmlAutomataGetInitState(ctxt->am);

	push	DWORD PTR [edi+132]
	call	_xmlAutomataGetInitState
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+136], eax

; 3072 :                 while (list != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlRelaxNG
$LL4@xmlRelaxNG:

; 3073 :                     xmlRelaxNGCompile(ctxt, list);

	push	esi
	push	edi
	call	_xmlRelaxNGCompile

; 3074 :                     list = list->next;

	mov	esi, DWORD PTR [esi+32]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL4@xmlRelaxNG
$LN5@xmlRelaxNG:

; 3075 :                 }
; 3076 :                 xmlAutomataSetFinalState(ctxt->am, ctxt->state);

	push	DWORD PTR [edi+136]
	push	DWORD PTR [edi+132]
	call	_xmlAutomataSetFinalState

; 3077 :                 if (xmlAutomataIsDeterminist(ctxt->am))

	push	DWORD PTR [edi+132]
	call	_xmlAutomataIsDeterminist
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN25@xmlRelaxNG

; 3078 :                     def->contModel = xmlAutomataCompile(ctxt->am);

	push	DWORD PTR [edi+132]
	call	_xmlAutomataCompile
	add	esp, 4
	mov	DWORD PTR [ebx+52], eax
$LN25@xmlRelaxNG:

; 3079 : 
; 3080 :                 xmlFreeAutomata(ctxt->am);

	push	DWORD PTR [edi+132]
	call	_xmlFreeAutomata

; 3081 :                 ctxt->state = oldstate;

	mov	eax, DWORD PTR _oldstate$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [edi+136], eax

; 3082 :                 ctxt->am = oldam;

	mov	eax, DWORD PTR _oldam$1$[ebp]
	mov	DWORD PTR [edi+132], eax

; 3249 :                     xmlRelaxNGDefName(def));
; 3250 :             break;
; 3251 :     }
; 3252 :     return (ret);

	xor	eax, eax
	pop	edi

; 3253 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlRelaxNG:

; 3083 :             }
; 3084 :             break;
; 3085 :         case XML_RELAXNG_ELEMENT:
; 3086 :             if ((ctxt->am != NULL) && (def->name != NULL)) {

	mov	eax, DWORD PTR [edi+132]
	test	eax, eax
	je	SHORT $LN27@xmlRelaxNG
	mov	ecx, DWORD PTR [ebx+8]
	test	ecx, ecx
	je	SHORT $LN27@xmlRelaxNG

; 3087 :                 ctxt->state = xmlAutomataNewTransition2(ctxt->am,

	push	ebx
	push	DWORD PTR [ebx+12]
	push	ecx
	push	0
	push	DWORD PTR [edi+136]
	push	eax
	call	_xmlAutomataNewTransition2
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+136], eax
$LN27@xmlRelaxNG:

; 3088 :                                                         ctxt->state, NULL,
; 3089 :                                                         def->name, def->ns,
; 3090 :                                                         def);
; 3091 :             }
; 3092 :             if ((def->dflags & IS_COMPILABLE) && (def->depth != -25)) {

	test	BYTE PTR [ebx+50], 64			; 00000040H
	je	$LN28@xmlRelaxNG
	cmp	WORD PTR [ebx+48], -25			; ffffffe7H
	je	$LN28@xmlRelaxNG

; 3093 :                 xmlAutomataPtr oldam = ctxt->am;

	mov	eax, DWORD PTR [edi+132]

; 3094 :                 xmlAutomataStatePtr oldstate = ctxt->state;
; 3095 : 
; 3096 :                 def->depth = -25;
; 3097 : 
; 3098 :                 list = def->content;

	mov	esi, DWORD PTR [ebx+24]
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR [edi+136]
	mov	DWORD PTR _oldstate$1$[ebp], eax
	mov	eax, -25				; ffffffe7H
	mov	WORD PTR [ebx+48], ax

; 3099 :                 ctxt->am = xmlNewAutomata();

	call	_xmlNewAutomata
	mov	DWORD PTR [edi+132], eax

; 3100 :                 if (ctxt->am == NULL)

	test	eax, eax
	je	$LN21@xmlRelaxNG

; 3101 :                     return (-1);
; 3102 :                 xmlAutomataSetFlags(ctxt->am, 1);

	push	1
	push	eax
	call	_xmlAutomataSetFlags

; 3103 :                 ctxt->state = xmlAutomataGetInitState(ctxt->am);

	push	DWORD PTR [edi+132]
	call	_xmlAutomataGetInitState
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+136], eax

; 3104 :                 while (list != NULL) {

	test	esi, esi
	je	SHORT $LN7@xmlRelaxNG
	npad	7
$LL6@xmlRelaxNG:

; 3105 :                     xmlRelaxNGCompile(ctxt, list);

	push	esi
	push	edi
	call	_xmlRelaxNGCompile

; 3106 :                     list = list->next;

	mov	esi, DWORD PTR [esi+32]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL6@xmlRelaxNG
$LN7@xmlRelaxNG:

; 3107 :                 }
; 3108 :                 xmlAutomataSetFinalState(ctxt->am, ctxt->state);

	push	DWORD PTR [edi+136]
	push	DWORD PTR [edi+132]
	call	_xmlAutomataSetFinalState

; 3109 :                 def->contModel = xmlAutomataCompile(ctxt->am);

	push	DWORD PTR [edi+132]
	call	_xmlAutomataCompile

; 3110 :                 if (!xmlRegexpIsDeterminist(def->contModel)) {

	push	eax
	mov	DWORD PTR [ebx+52], eax
	call	_xmlRegexpIsDeterminist
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN31@xmlRelaxNG

; 3111 : #ifdef DEBUG_COMPILE
; 3112 :                     xmlGenericError(xmlGenericErrorContext,
; 3113 :                         "Content model not determinist %s\n",
; 3114 :                                     def->name);
; 3115 : #endif
; 3116 :                     /*
; 3117 :                      * we can only use the automata if it is determinist
; 3118 :                      */
; 3119 :                     xmlRegFreeRegexp(def->contModel);

	push	DWORD PTR [ebx+52]
	call	_xmlRegFreeRegexp
	add	esp, 4

; 3120 :                     def->contModel = NULL;

	mov	DWORD PTR [ebx+52], 0
$LN31@xmlRelaxNG:

; 3121 :                 }
; 3122 :                 xmlFreeAutomata(ctxt->am);

	push	DWORD PTR [edi+132]
	call	_xmlFreeAutomata

; 3123 :                 ctxt->state = oldstate;

	mov	eax, DWORD PTR _oldstate$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [edi+136], eax

; 3134 :                 ctxt->am = oldam;
; 3135 :             }
; 3136 :             break;

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [edi+132], eax
	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 3253 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlRelaxNG:

; 3124 :                 ctxt->am = oldam;
; 3125 :             } else {
; 3126 :                 xmlAutomataPtr oldam = ctxt->am;

	mov	eax, DWORD PTR [edi+132]

; 3127 : 
; 3128 :                 /*
; 3129 :                  * we can't build the content model for this element content
; 3130 :                  * but it still might be possible to build it for some of its
; 3131 :                  * children, recurse.
; 3132 :                  */
; 3133 :                 ret = xmlRelaxNGTryCompile(ctxt, def);

	push	ebx
	push	edi
	mov	DWORD PTR $T1[ebp], eax
	call	_xmlRelaxNGTryCompile
	add	esp, 8
	mov	DWORD PTR _ret$1$[ebp], eax

; 3134 :                 ctxt->am = oldam;
; 3135 :             }
; 3136 :             break;

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [edi+132], eax
	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 3253 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@xmlRelaxNG:

; 3137 :         case XML_RELAXNG_NOOP:
; 3138 :             ret = xmlRelaxNGCompile(ctxt, def->content);

	push	DWORD PTR [ebx+24]
	push	edi
	call	_xmlRelaxNGCompile
	add	esp, 8
	pop	edi

; 3253 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@xmlRelaxNG:

; 3139 :             break;
; 3140 :         case XML_RELAXNG_OPTIONAL:{
; 3141 :                 xmlAutomataStatePtr oldstate = ctxt->state;
; 3142 : 
; 3143 :                 list = def->content;

	mov	esi, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [edi+136]
	mov	DWORD PTR _oldstate$1$[ebp], eax

; 3144 :                 while (list != NULL) {

	test	esi, esi
	je	SHORT $LN9@xmlRelaxNG
$LL8@xmlRelaxNG:

; 3145 :                     xmlRelaxNGCompile(ctxt, list);

	push	esi
	push	edi
	call	_xmlRelaxNGCompile

; 3146 :                     list = list->next;

	mov	esi, DWORD PTR [esi+32]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL8@xmlRelaxNG
	mov	eax, DWORD PTR [edi+136]
$LN9@xmlRelaxNG:

; 3147 :                 }
; 3148 :                 xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);

	push	eax
	push	DWORD PTR _oldstate$1$[ebp]
	push	DWORD PTR [edi+132]
	call	_xmlAutomataNewEpsilon

; 3249 :                     xmlRelaxNGDefName(def));
; 3250 :             break;
; 3251 :     }
; 3252 :     return (ret);

	add	esp, 12					; 0000000cH
	xor	eax, eax
	pop	edi

; 3253 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xmlRelaxNG:

; 3149 :                 break;
; 3150 :             }
; 3151 :         case XML_RELAXNG_ZEROORMORE:{
; 3152 :                 xmlAutomataStatePtr oldstate;
; 3153 : 
; 3154 :                 ctxt->state =

	push	0
	push	DWORD PTR [edi+136]
	push	DWORD PTR [edi+132]
	call	_xmlAutomataNewEpsilon
	mov	DWORD PTR [edi+136], eax
	add	esp, 12					; 0000000cH

; 3155 :                     xmlAutomataNewEpsilon(ctxt->am, ctxt->state, NULL);
; 3156 :                 oldstate = ctxt->state;
; 3157 :                 list = def->content;

	mov	esi, DWORD PTR [ebx+24]
	mov	ecx, eax
	mov	DWORD PTR _oldstate$1$[ebp], eax

; 3158 :                 while (list != NULL) {

	test	esi, esi
	je	SHORT $LN11@xmlRelaxNG
	npad	1
$LL10@xmlRelaxNG:

; 3159 :                     xmlRelaxNGCompile(ctxt, list);

	push	esi
	push	edi
	call	_xmlRelaxNGCompile

; 3160 :                     list = list->next;

	mov	esi, DWORD PTR [esi+32]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL10@xmlRelaxNG
	mov	ecx, DWORD PTR [edi+136]
	mov	eax, DWORD PTR _oldstate$1$[ebp]
$LN11@xmlRelaxNG:

; 3161 :                 }
; 3162 :                 xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldstate);

	push	eax
	push	ecx
	push	DWORD PTR [edi+132]
	call	_xmlAutomataNewEpsilon

; 3163 :                 ctxt->state =

	push	0
	push	DWORD PTR _oldstate$1$[ebp]
	push	DWORD PTR [edi+132]
	call	_xmlAutomataNewEpsilon
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+136], eax

; 3249 :                     xmlRelaxNGDefName(def));
; 3250 :             break;
; 3251 :     }
; 3252 :     return (ret);

	xor	eax, eax
	pop	edi

; 3253 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@xmlRelaxNG:

; 3164 :                     xmlAutomataNewEpsilon(ctxt->am, oldstate, NULL);
; 3165 :                 break;
; 3166 :             }
; 3167 :         case XML_RELAXNG_ONEORMORE:{
; 3168 :                 xmlAutomataStatePtr oldstate;
; 3169 : 
; 3170 :                 list = def->content;

	mov	esi, DWORD PTR [ebx+24]

; 3171 :                 while (list != NULL) {

	test	esi, esi
	je	SHORT $LN13@xmlRelaxNG
$LL12@xmlRelaxNG:

; 3172 :                     xmlRelaxNGCompile(ctxt, list);

	push	esi
	push	edi
	call	_xmlRelaxNGCompile

; 3173 :                     list = list->next;

	mov	esi, DWORD PTR [esi+32]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL12@xmlRelaxNG
	mov	esi, DWORD PTR [ebx+24]
$LN13@xmlRelaxNG:

; 3174 :                 }
; 3175 :                 oldstate = ctxt->state;

	mov	ebx, DWORD PTR [edi+136]

; 3176 :                 list = def->content;

	mov	eax, ebx

; 3177 :                 while (list != NULL) {

	test	esi, esi
	je	SHORT $LN15@xmlRelaxNG
$LL14@xmlRelaxNG:

; 3178 :                     xmlRelaxNGCompile(ctxt, list);

	push	esi
	push	edi
	call	_xmlRelaxNGCompile

; 3179 :                     list = list->next;

	mov	esi, DWORD PTR [esi+32]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL14@xmlRelaxNG
	mov	eax, DWORD PTR [edi+136]
$LN15@xmlRelaxNG:

; 3180 :                 }
; 3181 :                 xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldstate);

	push	ebx
	push	eax
	push	DWORD PTR [edi+132]
	call	_xmlAutomataNewEpsilon

; 3182 :                 ctxt->state =

	push	0
	push	ebx
	push	DWORD PTR [edi+132]
	call	_xmlAutomataNewEpsilon
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+136], eax

; 3249 :                     xmlRelaxNGDefName(def));
; 3250 :             break;
; 3251 :     }
; 3252 :     return (ret);

	xor	eax, eax
	pop	edi

; 3253 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@xmlRelaxNG:

; 3183 :                     xmlAutomataNewEpsilon(ctxt->am, oldstate, NULL);
; 3184 :                 break;
; 3185 :             }
; 3186 :         case XML_RELAXNG_CHOICE:{
; 3187 :                 xmlAutomataStatePtr target = NULL;
; 3188 :                 xmlAutomataStatePtr oldstate = ctxt->state;
; 3189 : 
; 3190 :                 list = def->content;

	mov	esi, DWORD PTR [ebx+24]
	xor	eax, eax
	mov	ecx, DWORD PTR [edi+136]
	mov	DWORD PTR _target$1$[ebp], eax
	mov	DWORD PTR _oldstate$1$[ebp], ecx

; 3191 :                 while (list != NULL) {

	test	esi, esi
	je	SHORT $LN124@xmlRelaxNG
	npad	7
$LL16@xmlRelaxNG:

; 3192 :                     ctxt->state = oldstate;
; 3193 :                     ret = xmlRelaxNGCompile(ctxt, list);

	push	esi
	push	edi
	mov	DWORD PTR [edi+136], ecx
	call	_xmlRelaxNGCompile
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR _ret$1$[ebp], ecx

; 3194 :                     if (ret != 0)

	test	ecx, ecx
	jne	SHORT $LN130@xmlRelaxNG

; 3195 :                         break;
; 3196 :                     if (target == NULL)

	mov	ebx, DWORD PTR _target$1$[ebp]
	mov	eax, DWORD PTR [edi+136]
	test	ebx, ebx
	jne	SHORT $LN38@xmlRelaxNG

; 3197 :                         target = ctxt->state;

	mov	DWORD PTR _target$1$[ebp], eax
	jmp	SHORT $LN39@xmlRelaxNG
$LN38@xmlRelaxNG:

; 3198 :                     else {
; 3199 :                         xmlAutomataNewEpsilon(ctxt->am, ctxt->state,

	push	ebx
	push	eax
	push	DWORD PTR [edi+132]
	call	_xmlAutomataNewEpsilon
	mov	eax, DWORD PTR _target$1$[ebp]
	add	esp, 12					; 0000000cH
$LN39@xmlRelaxNG:

; 3200 :                                               target);
; 3201 :                     }
; 3202 :                     list = list->next;

	mov	esi, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR _oldstate$1$[ebp]
	test	esi, esi
	jne	SHORT $LL16@xmlRelaxNG

; 3203 :                 }
; 3204 :                 ctxt->state = target;

	mov	DWORD PTR [edi+136], eax

; 3205 : 
; 3206 :                 break;

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 3253 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN130@xmlRelaxNG:

; 3194 :                     if (ret != 0)

	mov	eax, DWORD PTR _target$1$[ebp]
$LN124@xmlRelaxNG:

; 3203 :                 }
; 3204 :                 ctxt->state = target;

	mov	DWORD PTR [edi+136], eax

; 3205 : 
; 3206 :                 break;

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 3253 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@xmlRelaxNG:

; 3207 :             }
; 3208 :         case XML_RELAXNG_REF:
; 3209 :         case XML_RELAXNG_EXTERNALREF:
; 3210 :         case XML_RELAXNG_PARENTREF:
; 3211 :         case XML_RELAXNG_GROUP:
; 3212 :         case XML_RELAXNG_DEF:
; 3213 :             list = def->content;

	mov	esi, DWORD PTR [ebx+24]

; 3214 :             while (list != NULL) {

	test	esi, esi
	je	$LN129@xmlRelaxNG
$LL18@xmlRelaxNG:

; 3215 :                 ret = xmlRelaxNGCompile(ctxt, list);

	push	esi
	push	edi
	call	_xmlRelaxNGCompile
	add	esp, 8

; 3216 :                 if (ret != 0)

	test	eax, eax
	jne	$LN1@xmlRelaxNG

; 3217 :                     break;
; 3218 :                 list = list->next;

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL18@xmlRelaxNG

; 3253 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@xmlRelaxNG:

; 3219 :             }
; 3220 :             break;
; 3221 :         case XML_RELAXNG_TEXT:{
; 3222 :                 xmlAutomataStatePtr oldstate;
; 3223 : 
; 3224 :                 ctxt->state =

	push	0
	push	DWORD PTR [edi+136]
	push	DWORD PTR [edi+132]
	call	_xmlAutomataNewEpsilon
	mov	esi, eax
	mov	DWORD PTR [edi+136], esi

; 3225 :                     xmlAutomataNewEpsilon(ctxt->am, ctxt->state, NULL);
; 3226 :                 oldstate = ctxt->state;
; 3227 :                 xmlRelaxNGCompile(ctxt, def->content);

	push	DWORD PTR [ebx+24]
	push	edi
	call	_xmlRelaxNGCompile

; 3228 :                 xmlAutomataNewTransition(ctxt->am, ctxt->state,

	mov	ecx, DWORD PTR [edi+136]
	push	0
	push	OFFSET ??_C@_05NOBOONOA@?$CDtext@
	push	ecx
	push	ecx
	push	DWORD PTR [edi+132]
	call	_xmlAutomataNewTransition

; 3229 :                                          ctxt->state, BAD_CAST "#text",
; 3230 :                                          NULL);
; 3231 :                 ctxt->state =

	push	0
	push	esi
	push	DWORD PTR [edi+132]
	call	_xmlAutomataNewEpsilon
	add	esp, 52					; 00000034H
	mov	DWORD PTR [edi+136], eax

; 3249 :                     xmlRelaxNGDefName(def));
; 3250 :             break;
; 3251 :     }
; 3252 :     return (ret);

	xor	eax, eax
	pop	edi

; 3253 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@xmlRelaxNG:

; 3232 :                     xmlAutomataNewEpsilon(ctxt->am, oldstate, NULL);
; 3233 :                 break;
; 3234 :             }
; 3235 :         case XML_RELAXNG_EMPTY:
; 3236 :             ctxt->state =

	push	0
	push	DWORD PTR [edi+136]
	push	DWORD PTR [edi+132]
	call	_xmlAutomataNewEpsilon

; 3249 :                     xmlRelaxNGDefName(def));
; 3250 :             break;
; 3251 :     }
; 3252 :     return (ret);

	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+136], eax
	xor	eax, eax
	pop	edi

; 3253 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@xmlRelaxNG:

; 2042 :     switch (def->type) {

	jmp	DWORD PTR $LN134@xmlRelaxNG[ecx*4]
$LN66@xmlRelaxNG:

; 2043 :         case XML_RELAXNG_EMPTY:
; 2044 :             return ("empty");

	mov	eax, OFFSET ??_C@_05LBJMNBOG@empty@
	jmp	$LN62@xmlRelaxNG
$LN67@xmlRelaxNG:

; 2045 :         case XML_RELAXNG_NOT_ALLOWED:
; 2046 :             return ("notAllowed");

	mov	eax, OFFSET ??_C@_0L@GPGJMKBL@notAllowed@
	jmp	$LN62@xmlRelaxNG
$LN68@xmlRelaxNG:

; 2047 :         case XML_RELAXNG_EXCEPT:
; 2048 :             return ("except");

	mov	eax, OFFSET ??_C@_06JBKEBCGB@except@
	jmp	$LN62@xmlRelaxNG
$LN69@xmlRelaxNG:

; 2049 :         case XML_RELAXNG_TEXT:
; 2050 :             return ("text");

	mov	eax, OFFSET ??_C@_04CIMGMMMG@text@
	jmp	$LN62@xmlRelaxNG
$LN70@xmlRelaxNG:

; 2051 :         case XML_RELAXNG_ELEMENT:
; 2052 :             return ("element");

	mov	eax, OFFSET ??_C@_07HCLJNICE@element@
	jmp	SHORT $LN62@xmlRelaxNG
$LN71@xmlRelaxNG:

; 2053 :         case XML_RELAXNG_DATATYPE:
; 2054 :             return ("datatype");

	mov	eax, OFFSET ??_C@_08IJKJONLA@datatype@
	jmp	SHORT $LN62@xmlRelaxNG
$LN72@xmlRelaxNG:

; 2055 :         case XML_RELAXNG_VALUE:
; 2056 :             return ("value");

	mov	eax, OFFSET ??_C@_05MFEJDJP@value@
	jmp	SHORT $LN62@xmlRelaxNG
$LN73@xmlRelaxNG:

; 2057 :         case XML_RELAXNG_LIST:
; 2058 :             return ("list");

	mov	eax, OFFSET ??_C@_04DONFEANM@list@
	jmp	SHORT $LN62@xmlRelaxNG
$LN74@xmlRelaxNG:

; 2059 :         case XML_RELAXNG_ATTRIBUTE:
; 2060 :             return ("attribute");

	mov	eax, OFFSET ??_C@_09HGIEBAJ@attribute@
	jmp	SHORT $LN62@xmlRelaxNG
$LN75@xmlRelaxNG:

; 2061 :         case XML_RELAXNG_DEF:
; 2062 :             return ("def");

	mov	eax, OFFSET ??_C@_03BHEEIFFN@def@
	jmp	SHORT $LN62@xmlRelaxNG
$LN76@xmlRelaxNG:

; 2063 :         case XML_RELAXNG_REF:
; 2064 :             return ("ref");

	mov	eax, OFFSET ??_C@_03GCDGINBO@ref@
	jmp	SHORT $LN62@xmlRelaxNG
$LN77@xmlRelaxNG:

; 2065 :         case XML_RELAXNG_EXTERNALREF:
; 2066 :             return ("externalRef");

	mov	eax, OFFSET ??_C@_0M@CPEFJFBC@externalRef@
	jmp	SHORT $LN62@xmlRelaxNG
$LN78@xmlRelaxNG:

; 2067 :         case XML_RELAXNG_PARENTREF:
; 2068 :             return ("parentRef");

	mov	eax, OFFSET ??_C@_09LEMMFILP@parentRef@
	jmp	SHORT $LN62@xmlRelaxNG
$LN79@xmlRelaxNG:

; 2069 :         case XML_RELAXNG_OPTIONAL:
; 2070 :             return ("optional");

	mov	eax, OFFSET ??_C@_08EBGGHLAO@optional@
	jmp	SHORT $LN62@xmlRelaxNG
$LN80@xmlRelaxNG:

; 2071 :         case XML_RELAXNG_ZEROORMORE:
; 2072 :             return ("zeroOrMore");

	mov	eax, OFFSET ??_C@_0L@BANFCDDP@zeroOrMore@
	jmp	SHORT $LN62@xmlRelaxNG
$LN81@xmlRelaxNG:

; 2073 :         case XML_RELAXNG_ONEORMORE:
; 2074 :             return ("oneOrMore");

	mov	eax, OFFSET ??_C@_09EIEDMNLG@oneOrMore@
	jmp	SHORT $LN62@xmlRelaxNG
$LN82@xmlRelaxNG:

; 2075 :         case XML_RELAXNG_CHOICE:
; 2076 :             return ("choice");

	mov	eax, OFFSET ??_C@_06DDDNEJEA@choice@
	jmp	SHORT $LN62@xmlRelaxNG
$LN83@xmlRelaxNG:

; 2077 :         case XML_RELAXNG_GROUP:
; 2078 :             return ("group");

	mov	eax, OFFSET ??_C@_05MGJOOGAJ@group@
	jmp	SHORT $LN62@xmlRelaxNG
$LN84@xmlRelaxNG:

; 2079 :         case XML_RELAXNG_INTERLEAVE:
; 2080 :             return ("interleave");

	mov	eax, OFFSET ??_C@_0L@NLPEADBD@interleave@
	jmp	SHORT $LN62@xmlRelaxNG
$LN85@xmlRelaxNG:

; 2081 :         case XML_RELAXNG_START:
; 2082 :             return ("start");

	mov	eax, OFFSET ??_C@_05FAGFPHJG@start@
	jmp	SHORT $LN62@xmlRelaxNG
$LN86@xmlRelaxNG:

; 2083 :         case XML_RELAXNG_NOOP:
; 2084 :             return ("noop");

	mov	eax, OFFSET ??_C@_04BACONDHA@noop@
	jmp	SHORT $LN62@xmlRelaxNG
$LN87@xmlRelaxNG:

; 2085 :         case XML_RELAXNG_PARAM:
; 2086 :             return ("param");

	mov	eax, OFFSET ??_C@_05LJDNNBIK@param@
	jmp	SHORT $LN62@xmlRelaxNG
$LN62@xmlRelaxNG:

; 3237 :                 xmlAutomataNewEpsilon(ctxt->am, ctxt->state, NULL);
; 3238 :             break;
; 3239 :         case XML_RELAXNG_EXCEPT:
; 3240 :         case XML_RELAXNG_ATTRIBUTE:
; 3241 :         case XML_RELAXNG_INTERLEAVE:
; 3242 :         case XML_RELAXNG_NOT_ALLOWED:
; 3243 :         case XML_RELAXNG_DATATYPE:
; 3244 :         case XML_RELAXNG_LIST:
; 3245 :         case XML_RELAXNG_PARAM:
; 3246 :         case XML_RELAXNG_VALUE:
; 3247 :             /* This should not happen and generate an internal error */
; 3248 :             fprintf(stderr, "RNG internal error trying to compile %s\n",

	push	eax
	push	OFFSET ??_C@_0CJ@JOFHGKIK@RNG?5internal?5error?5trying?5to?5co@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf

; 3249 :                     xmlRelaxNGDefName(def));
; 3250 :             break;
; 3251 :     }
; 3252 :     return (ret);

	add	esp, 12					; 0000000cH
$LN129@xmlRelaxNG:

; 3253 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlRelaxNG:

; 3046 :         return (-1);

	or	eax, -1
$LN1@xmlRelaxNG:
	pop	edi

; 3253 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN133@xmlRelaxNG:
	DD	$LN32@xmlRelaxNG
	DD	$LN43@xmlRelaxNG
	DD	$LN44@xmlRelaxNG
	DD	$LN42@xmlRelaxNG
	DD	$LN26@xmlRelaxNG
	DD	$LN40@xmlRelaxNG
	DD	$LN33@xmlRelaxNG
	DD	$LN34@xmlRelaxNG
	DD	$LN35@xmlRelaxNG
	DD	$LN36@xmlRelaxNG
	DD	$LN22@xmlRelaxNG
$LN123@xmlRelaxNG:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	3
	DB	4
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	5
	DB	2
	DB	10					; 0000000aH
	npad	2
$LN134@xmlRelaxNG:
	DD	$LN86@xmlRelaxNG
	DD	$LN66@xmlRelaxNG
	DD	$LN67@xmlRelaxNG
	DD	$LN68@xmlRelaxNG
	DD	$LN69@xmlRelaxNG
	DD	$LN70@xmlRelaxNG
	DD	$LN71@xmlRelaxNG
	DD	$LN87@xmlRelaxNG
	DD	$LN72@xmlRelaxNG
	DD	$LN73@xmlRelaxNG
	DD	$LN74@xmlRelaxNG
	DD	$LN75@xmlRelaxNG
	DD	$LN76@xmlRelaxNG
	DD	$LN77@xmlRelaxNG
	DD	$LN78@xmlRelaxNG
	DD	$LN79@xmlRelaxNG
	DD	$LN80@xmlRelaxNG
	DD	$LN81@xmlRelaxNG
	DD	$LN82@xmlRelaxNG
	DD	$LN83@xmlRelaxNG
	DD	$LN84@xmlRelaxNG
	DD	$LN85@xmlRelaxNG
_xmlRelaxNGCompile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGIsCompileable
_TEXT	SEGMENT
_def$ = 8						; size = 4
_xmlRelaxNGIsCompileable PROC				; COMDAT

; 2890 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _def$[ebp]
	or	ecx, -1
	test	esi, esi
	jne	SHORT $LN10@xmlRelaxNG

; 2891 :     int ret = -1;
; 2892 : 
; 2893 :     if (def == NULL) {
; 2894 :         return (-1);

	or	eax, ecx
	pop	esi

; 3027 : }

	pop	ebp
	ret	0
$LN10@xmlRelaxNG:

; 2895 :     }
; 2896 :     if ((def->type != XML_RELAXNG_ELEMENT) &&

	mov	eax, DWORD PTR [esi]
	push	edi
	cmp	eax, 4
	je	SHORT $LN55@xmlRelaxNG
	movzx	edx, WORD PTR [esi+50]
	test	dl, 64					; 00000040H
	jne	$LN56@xmlRelaxNG

; 2897 :         (def->dflags & IS_COMPILABLE))
; 2898 :         return (1);
; 2899 :     if ((def->type != XML_RELAXNG_ELEMENT) &&

	test	dl, dl
	js	$LN22@xmlRelaxNG
$LN55@xmlRelaxNG:

; 2900 :         (def->dflags & IS_NOT_COMPILABLE))
; 2901 :         return (0);
; 2902 :     switch (def->type) {

	inc	eax
	cmp	eax, 21					; 00000015H
	ja	$LN31@xmlRelaxNG
	movzx	eax, BYTE PTR $LN57@xmlRelaxNG[eax]
	jmp	DWORD PTR $LN61@xmlRelaxNG[eax*4]
$LN13@xmlRelaxNG:

; 2903 :         case XML_RELAXNG_NOOP:
; 2904 :             ret = xmlRelaxNGIsCompileable(def->content);

	push	DWORD PTR [esi+24]
	call	_xmlRelaxNGIsCompileable
	add	esp, 4
	mov	ecx, eax
$LN2@xmlRelaxNG:

; 3005 :             break;
; 3006 :     }
; 3007 :     if (ret == 0)

	test	ecx, ecx
	je	$LN54@xmlRelaxNG

; 3009 :     if (ret == 1)

	cmp	ecx, 1
	jne	$LN31@xmlRelaxNG

; 3010 :         def->dflags |= IS_COMPILABLE;

	or	WORD PTR [esi+50], 64			; 00000040H

; 3011 : #ifdef DEBUG_COMPILE
; 3012 :     if (ret == 1) {
; 3013 :         xmlGenericError(xmlGenericErrorContext,
; 3014 :                         "RelaxNGIsCompileable %s : true\n",
; 3015 :                         xmlRelaxNGDefName(def));
; 3016 :     } else if (ret == 0) {
; 3017 :         xmlGenericError(xmlGenericErrorContext,
; 3018 :                         "RelaxNGIsCompileable %s : false\n",
; 3019 :                         xmlRelaxNGDefName(def));
; 3020 :     } else {
; 3021 :         xmlGenericError(xmlGenericErrorContext,
; 3022 :                         "Problem in RelaxNGIsCompileable %s\n",
; 3023 :                         xmlRelaxNGDefName(def));
; 3024 :     }
; 3025 : #endif
; 3026 :     return (ret);

	mov	eax, ecx
	pop	edi
	pop	esi

; 3027 : }

	pop	ebp
	ret	0
$LN14@xmlRelaxNG:

; 3010 :         def->dflags |= IS_COMPILABLE;

	or	WORD PTR [esi+50], 64			; 00000040H
	mov	ecx, 1
	pop	edi

; 3011 : #ifdef DEBUG_COMPILE
; 3012 :     if (ret == 1) {
; 3013 :         xmlGenericError(xmlGenericErrorContext,
; 3014 :                         "RelaxNGIsCompileable %s : true\n",
; 3015 :                         xmlRelaxNGDefName(def));
; 3016 :     } else if (ret == 0) {
; 3017 :         xmlGenericError(xmlGenericErrorContext,
; 3018 :                         "RelaxNGIsCompileable %s : false\n",
; 3019 :                         xmlRelaxNGDefName(def));
; 3020 :     } else {
; 3021 :         xmlGenericError(xmlGenericErrorContext,
; 3022 :                         "Problem in RelaxNGIsCompileable %s\n",
; 3023 :                         xmlRelaxNGDefName(def));
; 3024 :     }
; 3025 : #endif
; 3026 :     return (ret);

	mov	eax, ecx
	pop	esi

; 3027 : }

	pop	ebp
	ret	0
$LN15@xmlRelaxNG:
	test	BYTE PTR [esi+50], 192			; 000000c0H

; 2905 :             break;
; 2906 :         case XML_RELAXNG_TEXT:
; 2907 :         case XML_RELAXNG_EMPTY:
; 2908 :             ret = 1;
; 2909 :             break;
; 2910 :         case XML_RELAXNG_ELEMENT:
; 2911 :             /*
; 2912 :              * Check if the element content is compileable
; 2913 :              */
; 2914 :             if (((def->dflags & IS_NOT_COMPILABLE) == 0) &&

	jne	SHORT $LN19@xmlRelaxNG

; 2915 :                 ((def->dflags & IS_COMPILABLE) == 0)) {
; 2916 :                 xmlRelaxNGDefinePtr list;
; 2917 : 
; 2918 :                 list = def->content;

	mov	edi, DWORD PTR [esi+24]

; 2919 :                 while (list != NULL) {

	test	edi, edi
	je	SHORT $LN19@xmlRelaxNG
$LL4@xmlRelaxNG:

; 2920 :                     ret = xmlRelaxNGIsCompileable(list);

	push	edi
	call	_xmlRelaxNGIsCompileable
	add	esp, 4

; 2921 :                     if (ret != 1)

	cmp	eax, 1
	jne	SHORT $LN36@xmlRelaxNG

; 2922 :                         break;
; 2923 :                     list = list->next;

	mov	edi, DWORD PTR [edi+32]
	test	edi, edi
	jne	SHORT $LL4@xmlRelaxNG

; 2932 : 		}
; 2933 :                 if ((ret == 1) && !(def->dflags &= IS_NOT_COMPILABLE))

	mov	eax, 128				; 00000080H
	and	WORD PTR [esi+50], ax
	jne	SHORT $LN19@xmlRelaxNG

; 2934 :                     def->dflags |= IS_COMPILABLE;

	lea	eax, DWORD PTR [edi+64]
	jmp	SHORT $LN59@xmlRelaxNG
$LN36@xmlRelaxNG:

; 2924 :                 }
; 2925 : 		/*
; 2926 : 		 * Because the routine is recursive, we must guard against
; 2927 : 		 * discovering both COMPILABLE and NOT_COMPILABLE
; 2928 : 		 */
; 2929 :                 if (ret == 0) {

	test	eax, eax
	jne	SHORT $LN19@xmlRelaxNG

; 2930 : 		    def->dflags &= ~IS_COMPILABLE;

	mov	ax, WORD PTR [esi+50]

; 2931 :                     def->dflags |= IS_NOT_COMPILABLE;

	mov	ecx, 128				; 00000080H
	and	ax, -65					; ffffffbfH
	or	ax, cx
$LN59@xmlRelaxNG:

; 2935 : #ifdef DEBUG_COMPILE
; 2936 :                 if (ret == 1) {
; 2937 :                     xmlGenericError(xmlGenericErrorContext,
; 2938 :                                     "element content for %s is compilable\n",
; 2939 :                                     def->name);
; 2940 :                 } else if (ret == 0) {
; 2941 :                     xmlGenericError(xmlGenericErrorContext,
; 2942 :                                     "element content for %s is not compilable\n",
; 2943 :                                     def->name);
; 2944 :                 } else {
; 2945 :                     xmlGenericError(xmlGenericErrorContext,
; 2946 :                                     "Problem in RelaxNGIsCompileable for element %s\n",
; 2947 :                                     def->name);
; 2948 :                 }
; 2949 : #endif
; 2950 :             }
; 2951 :             /*
; 2952 :              * All elements return a compileable status unless they
; 2953 :              * are generic like anyName
; 2954 :              */
; 2955 :             if ((def->nameClass != NULL) || (def->name == NULL))

	mov	WORD PTR [esi+50], ax
$LN19@xmlRelaxNG:
	cmp	DWORD PTR [esi+40], 0
	jne	SHORT $LN22@xmlRelaxNG
	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN56@xmlRelaxNG
$LN22@xmlRelaxNG:
	pop	edi

; 2956 :                 ret = 0;

	xor	eax, eax
	pop	esi

; 3027 : }

	pop	ebp
	ret	0
$LN23@xmlRelaxNG:

; 2957 :             else
; 2958 :                 ret = 1;
; 2959 :             return (ret);
; 2960 :         case XML_RELAXNG_REF:
; 2961 :         case XML_RELAXNG_EXTERNALREF:
; 2962 :         case XML_RELAXNG_PARENTREF:
; 2963 :             if (def->depth == -20) {

	cmp	WORD PTR [esi+48], -20			; ffffffecH
	jne	SHORT $LN24@xmlRelaxNG
$LN56@xmlRelaxNG:
	pop	edi

; 2964 :                 return (1);

	mov	eax, 1
	pop	esi

; 3027 : }

	pop	ebp
	ret	0
$LN24@xmlRelaxNG:

; 2965 :             } else {
; 2966 :                 xmlRelaxNGDefinePtr list;
; 2967 : 
; 2968 :                 def->depth = -20;
; 2969 :                 list = def->content;

	mov	edi, DWORD PTR [esi+24]
	mov	eax, -20				; ffffffecH
	mov	WORD PTR [esi+48], ax

; 2970 :                 while (list != NULL) {

	test	edi, edi
	je	SHORT $LN31@xmlRelaxNG
$LL6@xmlRelaxNG:

; 2971 :                     ret = xmlRelaxNGIsCompileable(list);

	push	edi
	call	_xmlRelaxNGIsCompileable
	mov	ecx, eax
	add	esp, 4

; 2972 :                     if (ret != 1)

	cmp	ecx, 1
	jne	$LN2@xmlRelaxNG

; 2973 :                         break;
; 2974 :                     list = list->next;

	mov	edi, DWORD PTR [edi+32]
	test	edi, edi
	jne	SHORT $LL6@xmlRelaxNG

; 3010 :         def->dflags |= IS_COMPILABLE;

	or	WORD PTR [esi+50], 64			; 00000040H
	pop	edi
	pop	esi

; 3027 : }

	pop	ebp
	ret	0
$LN27@xmlRelaxNG:

; 2975 :                 }
; 2976 :             }
; 2977 :             break;
; 2978 :         case XML_RELAXNG_START:
; 2979 :         case XML_RELAXNG_OPTIONAL:
; 2980 :         case XML_RELAXNG_ZEROORMORE:
; 2981 :         case XML_RELAXNG_ONEORMORE:
; 2982 :         case XML_RELAXNG_CHOICE:
; 2983 :         case XML_RELAXNG_GROUP:
; 2984 :         case XML_RELAXNG_DEF:{
; 2985 :                 xmlRelaxNGDefinePtr list;
; 2986 : 
; 2987 :                 list = def->content;

	mov	edi, DWORD PTR [esi+24]

; 2988 :                 while (list != NULL) {

	test	edi, edi
	je	SHORT $LN31@xmlRelaxNG
$LL8@xmlRelaxNG:

; 2989 :                     ret = xmlRelaxNGIsCompileable(list);

	push	edi
	call	_xmlRelaxNGIsCompileable
	mov	ecx, eax
	add	esp, 4

; 2990 :                     if (ret != 1)

	cmp	ecx, 1
	jne	$LN2@xmlRelaxNG

; 2991 :                         break;
; 2992 :                     list = list->next;

	mov	edi, DWORD PTR [edi+32]
	test	edi, edi
	jne	SHORT $LL8@xmlRelaxNG

; 3010 :         def->dflags |= IS_COMPILABLE;

	or	WORD PTR [esi+50], 64			; 00000040H
	pop	edi
	pop	esi

; 3027 : }

	pop	ebp
	ret	0
$LN29@xmlRelaxNG:

; 2993 :                 }
; 2994 :                 break;
; 2995 :             }
; 2996 :         case XML_RELAXNG_EXCEPT:
; 2997 :         case XML_RELAXNG_ATTRIBUTE:
; 2998 :         case XML_RELAXNG_INTERLEAVE:
; 2999 :         case XML_RELAXNG_DATATYPE:
; 3000 :         case XML_RELAXNG_LIST:
; 3001 :         case XML_RELAXNG_PARAM:
; 3002 :         case XML_RELAXNG_VALUE:
; 3003 :         case XML_RELAXNG_NOT_ALLOWED:
; 3004 :             ret = 0;

	xor	ecx, ecx
$LN54@xmlRelaxNG:

; 3008 :         def->dflags |= IS_NOT_COMPILABLE;

	mov	eax, 128				; 00000080H
	or	WORD PTR [esi+50], ax
$LN31@xmlRelaxNG:

; 3011 : #ifdef DEBUG_COMPILE
; 3012 :     if (ret == 1) {
; 3013 :         xmlGenericError(xmlGenericErrorContext,
; 3014 :                         "RelaxNGIsCompileable %s : true\n",
; 3015 :                         xmlRelaxNGDefName(def));
; 3016 :     } else if (ret == 0) {
; 3017 :         xmlGenericError(xmlGenericErrorContext,
; 3018 :                         "RelaxNGIsCompileable %s : false\n",
; 3019 :                         xmlRelaxNGDefName(def));
; 3020 :     } else {
; 3021 :         xmlGenericError(xmlGenericErrorContext,
; 3022 :                         "Problem in RelaxNGIsCompileable %s\n",
; 3023 :                         xmlRelaxNGDefName(def));
; 3024 :     }
; 3025 : #endif
; 3026 :     return (ret);

	pop	edi
	mov	eax, ecx
	pop	esi

; 3027 : }

	pop	ebp
	ret	0
	npad	1
$LN61@xmlRelaxNG:
	DD	$LN13@xmlRelaxNG
	DD	$LN14@xmlRelaxNG
	DD	$LN29@xmlRelaxNG
	DD	$LN15@xmlRelaxNG
	DD	$LN27@xmlRelaxNG
	DD	$LN23@xmlRelaxNG
$LN57@xmlRelaxNG:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	1
	DB	3
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	4
	DB	5
	DB	5
	DB	5
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
_xmlRelaxNGIsCompileable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGTryCompile
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_def$ = 12						; size = 4
_xmlRelaxNGTryCompile PROC				; COMDAT

; 3267 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	test	edi, edi
	je	$LN7@xmlRelaxNG

; 3268 :     int ret = 0;
; 3269 :     xmlRelaxNGDefinePtr list;
; 3270 : 
; 3271 :     if ((ctxt == NULL) || (def == NULL))

	mov	esi, DWORD PTR _def$[ebp]
	test	esi, esi
	je	$LN7@xmlRelaxNG

; 3273 : 
; 3274 :     if ((def->type == XML_RELAXNG_START) ||

	mov	eax, DWORD PTR [esi]
	cmp	eax, 20					; 00000014H
	je	SHORT $LN9@xmlRelaxNG
	cmp	eax, 4
	jne	SHORT $LN10@xmlRelaxNG
$LN9@xmlRelaxNG:

; 3275 :         (def->type == XML_RELAXNG_ELEMENT)) {
; 3276 :         ret = xmlRelaxNGIsCompileable(def);

	push	esi
	call	_xmlRelaxNGIsCompileable
	add	esp, 4
	mov	ecx, eax

; 3277 :         if ((def->dflags & IS_COMPILABLE) && (def->depth != -25)) {

	test	BYTE PTR [esi+50], 64			; 00000040H
	je	SHORT $LN10@xmlRelaxNG
	cmp	WORD PTR [esi+48], -25			; ffffffe7H
	je	SHORT $LN10@xmlRelaxNG

; 3278 :             ctxt->am = NULL;
; 3279 :             ret = xmlRelaxNGCompile(ctxt, def);

	push	esi
	push	edi
	mov	DWORD PTR [edi+132], 0
	call	_xmlRelaxNGCompile
	add	esp, 8
	pop	edi

; 3340 : }

	pop	esi
	pop	ebp
	ret	0
$LN10@xmlRelaxNG:

; 3280 : #ifdef DEBUG_PROGRESSIVE
; 3281 :             if (ret == 0) {
; 3282 :                 if (def->type == XML_RELAXNG_START)
; 3283 :                     xmlGenericError(xmlGenericErrorContext,
; 3284 :                                     "compiled the start\n");
; 3285 :                 else
; 3286 :                     xmlGenericError(xmlGenericErrorContext,
; 3287 :                                     "compiled element %s\n", def->name);
; 3288 :             } else {
; 3289 :                 if (def->type == XML_RELAXNG_START)
; 3290 :                     xmlGenericError(xmlGenericErrorContext,
; 3291 :                                     "failed to compile the start\n");
; 3292 :                 else
; 3293 :                     xmlGenericError(xmlGenericErrorContext,
; 3294 :                                     "failed to compile element %s\n",
; 3295 :                                     def->name);
; 3296 :             }
; 3297 : #endif
; 3298 :             return (ret);
; 3299 :         }
; 3300 :     }
; 3301 :     switch (def->type) {

	mov	eax, DWORD PTR [esi]
	inc	eax
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN2@xmlRelaxNG
	movzx	eax, BYTE PTR $LN22@xmlRelaxNG[eax]
	jmp	DWORD PTR $LN25@xmlRelaxNG[eax*4]
$LN11@xmlRelaxNG:

; 3302 :         case XML_RELAXNG_NOOP:
; 3303 :             ret = xmlRelaxNGTryCompile(ctxt, def->content);

	push	DWORD PTR [esi+24]
	push	edi
	call	_xmlRelaxNGTryCompile
	add	esp, 8
	mov	ecx, eax
	pop	edi

; 3340 : }

	pop	esi
	pop	ebp
	ret	0
$LN13@xmlRelaxNG:

; 3304 :             break;
; 3305 :         case XML_RELAXNG_TEXT:
; 3306 :         case XML_RELAXNG_DATATYPE:
; 3307 :         case XML_RELAXNG_LIST:
; 3308 :         case XML_RELAXNG_PARAM:
; 3309 :         case XML_RELAXNG_VALUE:
; 3310 :         case XML_RELAXNG_EMPTY:
; 3311 :         case XML_RELAXNG_ELEMENT:
; 3312 :             ret = 0;
; 3313 :             break;
; 3314 :         case XML_RELAXNG_OPTIONAL:
; 3315 :         case XML_RELAXNG_ZEROORMORE:
; 3316 :         case XML_RELAXNG_ONEORMORE:
; 3317 :         case XML_RELAXNG_CHOICE:
; 3318 :         case XML_RELAXNG_GROUP:
; 3319 :         case XML_RELAXNG_DEF:
; 3320 :         case XML_RELAXNG_START:
; 3321 :         case XML_RELAXNG_REF:
; 3322 :         case XML_RELAXNG_EXTERNALREF:
; 3323 :         case XML_RELAXNG_PARENTREF:
; 3324 :             list = def->content;

	mov	esi, DWORD PTR [esi+24]

; 3325 :             while (list != NULL) {

	test	esi, esi
	je	SHORT $LN2@xmlRelaxNG
$LL4@xmlRelaxNG:

; 3326 :                 ret = xmlRelaxNGTryCompile(ctxt, list);

	push	esi
	push	edi
	call	_xmlRelaxNGTryCompile
	mov	ecx, eax
	add	esp, 8

; 3327 :                 if (ret != 0)

	test	ecx, ecx
	jne	SHORT $LN2@xmlRelaxNG

; 3328 :                     break;
; 3329 :                 list = list->next;

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL4@xmlRelaxNG

; 3340 : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN15@xmlRelaxNG:

; 3330 :             }
; 3331 :             break;
; 3332 :         case XML_RELAXNG_EXCEPT:
; 3333 :         case XML_RELAXNG_ATTRIBUTE:
; 3334 :         case XML_RELAXNG_INTERLEAVE:
; 3335 :         case XML_RELAXNG_NOT_ALLOWED:
; 3336 :             ret = 0;
; 3337 :             break;
; 3338 :     }
; 3339 :     return (ret);

	xor	ecx, ecx
$LN2@xmlRelaxNG:
	pop	edi
	mov	eax, ecx

; 3340 : }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlRelaxNG:
	pop	edi

; 3272 :         return (-1);

	or	eax, -1

; 3340 : }

	pop	esi
	pop	ebp
	ret	0
$LN25@xmlRelaxNG:
	DD	$LN11@xmlRelaxNG
	DD	$LN15@xmlRelaxNG
	DD	$LN13@xmlRelaxNG
$LN22@xmlRelaxNG:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
_xmlRelaxNGTryCompile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGRegisterTypeLibrary
_TEXT	SEGMENT
_namespace$ = 8						; size = 4
_data$ = 12						; size = 4
_have$ = 16						; size = 4
_check$ = 20						; size = 4
_comp$ = 24						; size = 4
_facet$ = 28						; size = 4
_freef$ = 32						; size = 4
_xmlRelaxNGRegisterTypeLibrary PROC			; COMDAT

; 2776 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _xmlRelaxNGRegisteredTypes
	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG

; 2777 :     xmlRelaxNGTypeLibraryPtr lib;
; 2778 :     int ret;
; 2779 : 
; 2780 :     if ((xmlRelaxNGRegisteredTypes == NULL) || (namespace == NULL) ||
; 2781 :         (check == NULL) || (comp == NULL))

	mov	ebx, DWORD PTR _namespace$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@xmlRelaxNG
	mov	esi, DWORD PTR _check$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlRelaxNG
	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN3@xmlRelaxNG

; 2782 :         return (-1);
; 2783 :     if (xmlHashLookup(xmlRelaxNGRegisteredTypes, namespace) != NULL) {

	push	ebx
	push	eax
	call	_xmlHashLookup
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@xmlRelaxNG

; 2784 :         xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	ebx
	push	OFFSET ??_C@_0DA@KBDGNEEG@Relax?9NG?5types?5library?5?8?$CFs?8?5alr@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
$LN3@xmlRelaxNG:

; 2813 : }

	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlRelaxNG:
	push	edi

; 2785 :                         "Relax-NG types library '%s' already registered\n",
; 2786 :                         namespace);
; 2787 :         return (-1);
; 2788 :     }
; 2789 :     lib =

	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 2790 :         (xmlRelaxNGTypeLibraryPtr)
; 2791 :         xmlMalloc(sizeof(xmlRelaxNGTypeLibrary));
; 2792 :     if (lib == NULL) {

	test	edi, edi
	jne	SHORT $LN5@xmlRelaxNG

; 488  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BG@BMGNHHOA@adding?5types?5library?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BG@BMGNHHOA@adding?5types?5library?6@
	push	eax
	push	eax
	push	3
	push	2
	push	19					; 00000013H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 2793 :         xmlRngVErrMemory(NULL, "adding types library\n");
; 2794 :         return (-1);

	or	eax, -1
	pop	edi
	pop	esi

; 2813 : }

	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlRelaxNG:
	xorps	xmm0, xmm0

; 2795 :     }
; 2796 :     memset(lib, 0, sizeof(xmlRelaxNGTypeLibrary));

	movups	XMMWORD PTR [edi], xmm0

; 2797 :     lib->namespace = xmlStrdup(namespace);

	push	ebx
	movq	QWORD PTR [edi+16], xmm0
	mov	DWORD PTR [edi+24], 0
	call	_xmlStrdup
	mov	DWORD PTR [edi], eax

; 2798 :     lib->data = data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edi+4], eax

; 2799 :     lib->have = have;

	mov	eax, DWORD PTR _have$[ebp]
	mov	DWORD PTR [edi+8], eax

; 2800 :     lib->comp = comp;

	mov	eax, DWORD PTR _comp$[ebp]

; 2801 :     lib->check = check;
; 2802 :     lib->facet = facet;
; 2803 :     lib->freef = freef;
; 2804 :     ret = xmlHashAddEntry(xmlRelaxNGRegisteredTypes, namespace, lib);

	push	edi
	mov	DWORD PTR [edi+16], eax
	mov	eax, DWORD PTR _facet$[ebp]
	push	ebx
	push	DWORD PTR _xmlRelaxNGRegisteredTypes
	mov	DWORD PTR [edi+20], eax
	mov	eax, DWORD PTR _freef$[ebp]
	mov	DWORD PTR [edi+12], esi
	mov	DWORD PTR [edi+24], eax
	call	_xmlHashAddEntry
	add	esp, 16					; 00000010H

; 2805 :     if (ret < 0) {

	test	eax, eax
	jns	SHORT $LN6@xmlRelaxNG

; 2806 :         xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	ebx
	push	OFFSET ??_C@_0DA@DKNFFGLK@Relax?9NG?5types?5library?5failed?5t@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax

; 2807 :                         "Relax-NG types library failed to register '%s'\n",
; 2808 :                         namespace);
; 2809 :         xmlRelaxNGFreeTypeLibrary(lib, namespace);

	push	ebx
	push	edi
	call	_xmlRelaxNGFreeTypeLibrary
	add	esp, 20					; 00000014H
	or	eax, -1
	pop	edi
	pop	esi

; 2813 : }

	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlRelaxNG:
	pop	edi
	pop	esi

; 2810 :         return (-1);
; 2811 :     }
; 2812 :     return (0);

	xor	eax, eax

; 2813 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlRelaxNGRegisterTypeLibrary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGFreeTypeLibrary
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_namespace$ = 12					; size = 4
_xmlRelaxNGFreeTypeLibrary PROC				; COMDAT

; 2748 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _payload$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlRelaxNG

; 2749 :     xmlRelaxNGTypeLibraryPtr lib = (xmlRelaxNGTypeLibraryPtr) payload;
; 2750 :     if (lib == NULL)
; 2751 :         return;
; 2752 :     if (lib->namespace != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG

; 2753 :         xmlFree((xmlChar *) lib->namespace);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlRelaxNG:

; 2754 :     xmlFree(lib);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlRelaxNG:
	pop	esi

; 2755 : }

	pop	ebp
	ret	0
_xmlRelaxNGFreeTypeLibrary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGDefaultTypeCompare
_TEXT	SEGMENT
_data$ = 8						; size = 4
_type$ = 12						; size = 4
_value1$ = 16						; size = 4
_ctxt1$ = 20						; size = 4
_comp1$ = 24						; size = 4
_value2$ = 28						; size = 4
_ctxt2$ = 32						; size = 4
_xmlRelaxNGDefaultTypeCompare PROC			; COMDAT

; 2703 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _type$[ebp]
	push	OFFSET ??_C@_06ICGJLFIM@string@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@xmlRelaxNG

; 2704 :     int ret = -1;
; 2705 : 
; 2706 :     if (xmlStrEqual(type, BAD_CAST "string")) {
; 2707 :         ret = xmlStrEqual(value1, value2);

	push	DWORD PTR _value2$[ebp]
	push	DWORD PTR _value1$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	pop	esi

; 2733 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:

; 2708 :     } else if (xmlStrEqual(type, BAD_CAST "token")) {

	push	OFFSET ??_C@_05JMKJMOPH@token@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlRelaxNG

; 2709 :         if (!xmlStrEqual(value1, value2)) {

	mov	esi, DWORD PTR _value2$[ebp]
	push	edi
	mov	edi, DWORD PTR _value1$[ebp]
	push	esi
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@xmlRelaxNG

; 2710 :             xmlChar *nval, *nvalue;
; 2711 : 
; 2712 :             /*
; 2713 :              * TODO: trivial optimizations are possible by
; 2714 :              * computing at compile-time
; 2715 :              */
; 2716 :             nval = xmlRelaxNGNormalize(NULL, value1);

	push	ebx
	push	edi
	push	eax
	call	_xmlRelaxNGNormalize

; 2717 :             nvalue = xmlRelaxNGNormalize(NULL, value2);

	push	esi
	push	0
	mov	ebx, eax
	call	_xmlRelaxNGNormalize
	add	esp, 16					; 00000010H
	mov	edi, eax

; 2718 : 
; 2719 :             if ((nval == NULL) || (nvalue == NULL))

	test	ebx, ebx
	je	SHORT $LN9@xmlRelaxNG
	test	edi, edi
	je	SHORT $LN9@xmlRelaxNG

; 2721 :             else if (xmlStrEqual(nval, nvalue))

	push	edi
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	mov	esi, eax
	neg	esi
	sbb	esi, esi
	neg	esi

; 2722 :                 ret = 1;
; 2723 :             else
; 2724 :                 ret = 0;

	jmp	SHORT $LN11@xmlRelaxNG
$LN9@xmlRelaxNG:

; 2720 :                 ret = -1;

	or	esi, -1
$LN11@xmlRelaxNG:

; 2725 :             if (nval != NULL)

	test	ebx, ebx
	je	SHORT $LN12@xmlRelaxNG

; 2726 :                 xmlFree(nval);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlRelaxNG:

; 2727 :             if (nvalue != NULL)

	pop	ebx
	test	edi, edi
	je	SHORT $LN16@xmlRelaxNG

; 2728 :                 xmlFree(nvalue);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlRelaxNG:

; 2729 :         } else
; 2730 :             ret = 1;
; 2731 :     }
; 2732 :     return (ret);

	pop	edi
	mov	eax, esi
	pop	esi

; 2733 : }

	pop	ebp
	ret	0
$LN5@xmlRelaxNG:
	pop	edi

; 2729 :         } else
; 2730 :             ret = 1;
; 2731 :     }
; 2732 :     return (ret);

	mov	eax, 1
	pop	esi

; 2733 : }

	pop	ebp
	ret	0
$LN15@xmlRelaxNG:

; 2729 :         } else
; 2730 :             ret = 1;
; 2731 :     }
; 2732 :     return (ret);

	or	eax, -1
	pop	esi

; 2733 : }

	pop	ebp
	ret	0
_xmlRelaxNGDefaultTypeCompare ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGDefaultTypeCheck
_TEXT	SEGMENT
_data$ = 8						; size = 4
_type$ = 12						; size = 4
_value$ = 16						; size = 4
_result$ = 20						; size = 4
_node$ = 24						; size = 4
_xmlRelaxNGDefaultTypeCheck PROC			; COMDAT

; 2671 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN2@xmlRelaxNG

; 2672 :     if (value == NULL)
; 2673 :         return (-1);

	or	eax, -1

; 2678 :     }
; 2679 : 
; 2680 :     return (0);
; 2681 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:

; 2674 :     if (xmlStrEqual(type, BAD_CAST "string"))

	push	OFFSET ??_C@_06ICGJLFIM@string@
	push	DWORD PTR _type$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@xmlRelaxNG

; 2675 :         return (1);
; 2676 :     if (xmlStrEqual(type, BAD_CAST "token")) {

	push	OFFSET ??_C@_05JMKJMOPH@token@
	push	DWORD PTR _type$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@xmlRelaxNG

; 2678 :     }
; 2679 : 
; 2680 :     return (0);
; 2681 : }

	pop	ebp
	ret	0
$LN6@xmlRelaxNG:

; 2677 :         return (1);

	mov	eax, 1

; 2678 :     }
; 2679 : 
; 2680 :     return (0);
; 2681 : }

	pop	ebp
	ret	0
_xmlRelaxNGDefaultTypeCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGDefaultTypeHave
_TEXT	SEGMENT
_data$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlRelaxNGDefaultTypeHave PROC				; COMDAT

; 2643 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _type$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlRelaxNG

; 2644 :     if (type == NULL)
; 2645 :         return (-1);

	or	eax, -1
	pop	esi

; 2650 :     return (0);
; 2651 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:

; 2646 :     if (xmlStrEqual(type, BAD_CAST "string"))

	push	OFFSET ??_C@_06ICGJLFIM@string@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@xmlRelaxNG

; 2647 :         return (1);
; 2648 :     if (xmlStrEqual(type, BAD_CAST "token"))

	push	OFFSET ??_C@_05JMKJMOPH@token@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@xmlRelaxNG
	pop	esi

; 2650 :     return (0);
; 2651 : }

	pop	ebp
	ret	0
$LN6@xmlRelaxNG:

; 2649 :         return (1);

	mov	eax, 1
	pop	esi

; 2650 :     return (0);
; 2651 : }

	pop	ebp
	ret	0
_xmlRelaxNGDefaultTypeHave ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGSchemaTypeCompare
_TEXT	SEGMENT
_res2$ = -8						; size = 4
_res1$ = -4						; size = 4
_data$ = 8						; size = 4
_type$ = 12						; size = 4
_value1$ = 16						; size = 4
_ctxt1$ = 20						; size = 4
_comp1$ = 24						; size = 4
_value2$ = 28						; size = 4
_ctxt2$ = 32						; size = 4
_xmlRelaxNGSchemaTypeCompare PROC			; COMDAT

; 2592 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR _res1$[ebp], 0
	mov	DWORD PTR _res2$[ebp], 0
	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG

; 2593 :     int ret;
; 2594 :     xmlSchemaTypePtr typ;
; 2595 :     xmlSchemaValPtr res1 = NULL, res2 = NULL;
; 2596 : 
; 2597 :     if ((type == NULL) || (value1 == NULL) || (value2 == NULL))

	mov	edi, DWORD PTR _value1$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlRelaxNG
	cmp	DWORD PTR _value2$[ebp], 0
	je	SHORT $LN3@xmlRelaxNG

; 2598 :         return (-1);
; 2599 :     typ = xmlSchemaGetPredefinedType(type,

	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	eax
	call	_xmlSchemaGetPredefinedType
	mov	ebx, eax
	add	esp, 8

; 2600 :                                      BAD_CAST
; 2601 :                                      "http://www.w3.org/2001/XMLSchema");
; 2602 :     if (typ == NULL)

	test	ebx, ebx
	je	SHORT $LN3@xmlRelaxNG

; 2603 :         return (-1);
; 2604 :     if (comp1 == NULL) {

	mov	esi, DWORD PTR _comp1$[ebp]
	test	esi, esi
	jne	SHORT $LN5@xmlRelaxNG

; 2605 :         ret = xmlSchemaValPredefTypeNode(typ, value1, &res1, ctxt1);

	push	DWORD PTR _ctxt1$[ebp]
	lea	eax, DWORD PTR _res1$[ebp]
	push	eax
	push	edi
	push	ebx
	call	_xmlSchemaValPredefTypeNode
	add	esp, 16					; 00000010H

; 2606 :         if (ret != 0)

	test	eax, eax
	jne	SHORT $LN3@xmlRelaxNG

; 2607 :             return (-1);
; 2608 :         if (res1 == NULL)

	cmp	DWORD PTR _res1$[ebp], eax
	jne	SHORT $LN6@xmlRelaxNG
$LN3@xmlRelaxNG:
	pop	edi

; 2626 :         return (1);
; 2627 :     return (0);
; 2628 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlRelaxNG:

; 2609 :             return (-1);
; 2610 :     } else {
; 2611 :         res1 = (xmlSchemaValPtr) comp1;

	mov	DWORD PTR _res1$[ebp], esi
$LN6@xmlRelaxNG:

; 2612 :     }
; 2613 :     ret = xmlSchemaValPredefTypeNode(typ, value2, &res2, ctxt2);

	push	DWORD PTR _ctxt2$[ebp]
	lea	eax, DWORD PTR _res2$[ebp]
	push	eax
	push	DWORD PTR _value2$[ebp]
	push	ebx
	call	_xmlSchemaValPredefTypeNode
	add	esp, 16					; 00000010H

; 2614 :     if (ret != 0) {

	test	eax, eax
	je	SHORT $LN9@xmlRelaxNG

; 2615 : 	if (res1 != (xmlSchemaValPtr) comp1)

	mov	eax, DWORD PTR _res1$[ebp]
	cmp	eax, esi
	je	SHORT $LN3@xmlRelaxNG

; 2616 : 	    xmlSchemaFreeValue(res1);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4
	or	eax, -1
	pop	edi

; 2626 :         return (1);
; 2627 :     return (0);
; 2628 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlRelaxNG:

; 2617 :         return (-1);
; 2618 :     }
; 2619 :     ret = xmlSchemaCompareValues(res1, res2);

	push	DWORD PTR _res2$[ebp]
	push	DWORD PTR _res1$[ebp]
	call	_xmlSchemaCompareValues
	mov	edi, eax
	add	esp, 8

; 2620 :     if (res1 != (xmlSchemaValPtr) comp1)

	mov	eax, DWORD PTR _res1$[ebp]
	cmp	eax, esi
	je	SHORT $LN11@xmlRelaxNG

; 2621 :         xmlSchemaFreeValue(res1);

	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN11@xmlRelaxNG:

; 2622 :     xmlSchemaFreeValue(res2);

	push	DWORD PTR _res2$[ebp]
	call	_xmlSchemaFreeValue
	add	esp, 4

; 2623 :     if (ret == -2)

	cmp	edi, -2					; fffffffeH
	je	SHORT $LN3@xmlRelaxNG

; 2624 :         return (-1);
; 2625 :     if (ret == 0)

	xor	eax, eax
	test	edi, edi
	pop	edi

; 2626 :         return (1);
; 2627 :     return (0);
; 2628 : }

	pop	esi
	sete	al
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGSchemaTypeCompare ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGSchemaFreeValue
_TEXT	SEGMENT
_data$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlRelaxNGSchemaFreeValue PROC				; COMDAT

; 2569 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _value$[ebp]
	call	_xmlSchemaFreeValue
	add	esp, 4

; 2570 :     xmlSchemaFreeValue(value);
; 2571 : }

	pop	ebp
	ret	0
_xmlRelaxNGSchemaFreeValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGSchemaFacetCheck
_TEXT	SEGMENT
_data$ = 8						; size = 4
_typ$1$ = 12						; size = 4
_type$ = 12						; size = 4
_facetname$ = 16					; size = 4
_val$ = 20						; size = 4
_strval$ = 24						; size = 4
_value$ = 28						; size = 4
_xmlRelaxNGSchemaFacetCheck PROC			; COMDAT

; 2500 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _type$[ebp]
	test	ebx, ebx
	je	$LN3@xmlRelaxNG

; 2501 :     xmlSchemaFacetPtr facet;
; 2502 :     xmlSchemaTypePtr typ;
; 2503 :     int ret;
; 2504 : 
; 2505 :     if ((type == NULL) || (strval == NULL))

	cmp	DWORD PTR _strval$[ebp], 0
	je	$LN3@xmlRelaxNG

; 2506 :         return (-1);
; 2507 :     typ = xmlSchemaGetPredefinedType(type,

	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	ebx
	call	_xmlSchemaGetPredefinedType
	add	esp, 8
	mov	DWORD PTR _typ$1$[ebp], eax

; 2508 :                                      BAD_CAST
; 2509 :                                      "http://www.w3.org/2001/XMLSchema");
; 2510 :     if (typ == NULL)

	test	eax, eax
	je	$LN3@xmlRelaxNG

; 2511 :         return (-1);
; 2512 : 
; 2513 :     facet = xmlSchemaNewFacet();

	call	_xmlSchemaNewFacet
	mov	edi, eax

; 2514 :     if (facet == NULL)

	test	edi, edi
	je	$LN3@xmlRelaxNG

; 2515 :         return (-1);
; 2516 : 
; 2517 :     if (xmlStrEqual(facetname, BAD_CAST "minInclusive")) {

	mov	esi, DWORD PTR _facetname$[ebp]
	push	OFFSET ??_C@_0N@BDECKIL@minInclusive@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG

; 2518 :         facet->type = XML_SCHEMA_FACET_MININCLUSIVE;

	mov	DWORD PTR [edi], 1000			; 000003e8H
	jmp	$LN29@xmlRelaxNG
$LN6@xmlRelaxNG:

; 2519 :     } else if (xmlStrEqual(facetname, BAD_CAST "minExclusive")) {

	push	OFFSET ??_C@_0N@MENCPBPO@minExclusive@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlRelaxNG

; 2520 :         facet->type = XML_SCHEMA_FACET_MINEXCLUSIVE;

	mov	DWORD PTR [edi], 1001			; 000003e9H
	jmp	$LN29@xmlRelaxNG
$LN8@xmlRelaxNG:

; 2521 :     } else if (xmlStrEqual(facetname, BAD_CAST "maxInclusive")) {

	push	OFFSET ??_C@_0N@EBHLFCPN@maxInclusive@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlRelaxNG

; 2522 :         facet->type = XML_SCHEMA_FACET_MAXINCLUSIVE;

	mov	DWORD PTR [edi], 1002			; 000003eaH
	jmp	$LN29@xmlRelaxNG
$LN10@xmlRelaxNG:

; 2523 :     } else if (xmlStrEqual(facetname, BAD_CAST "maxExclusive")) {

	push	OFFSET ??_C@_0N@IEJNIJII@maxExclusive@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlRelaxNG

; 2524 :         facet->type = XML_SCHEMA_FACET_MAXEXCLUSIVE;

	mov	DWORD PTR [edi], 1003			; 000003ebH
	jmp	$LN29@xmlRelaxNG
$LN12@xmlRelaxNG:

; 2525 :     } else if (xmlStrEqual(facetname, BAD_CAST "totalDigits")) {

	push	OFFSET ??_C@_0M@PGNNBCIB@totalDigits@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlRelaxNG

; 2526 :         facet->type = XML_SCHEMA_FACET_TOTALDIGITS;

	mov	DWORD PTR [edi], 1004			; 000003ecH
	jmp	$LN29@xmlRelaxNG
$LN14@xmlRelaxNG:

; 2527 :     } else if (xmlStrEqual(facetname, BAD_CAST "fractionDigits")) {

	push	OFFSET ??_C@_0P@EPJLKDGA@fractionDigits@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlRelaxNG

; 2528 :         facet->type = XML_SCHEMA_FACET_FRACTIONDIGITS;

	mov	DWORD PTR [edi], 1005			; 000003edH
	jmp	$LN29@xmlRelaxNG
$LN16@xmlRelaxNG:

; 2529 :     } else if (xmlStrEqual(facetname, BAD_CAST "pattern")) {

	push	OFFSET ??_C@_07CHFOACKJ@pattern@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlRelaxNG

; 2530 :         facet->type = XML_SCHEMA_FACET_PATTERN;

	mov	DWORD PTR [edi], 1006			; 000003eeH
	jmp	$LN29@xmlRelaxNG
$LN18@xmlRelaxNG:

; 2531 :     } else if (xmlStrEqual(facetname, BAD_CAST "enumeration")) {

	push	OFFSET ??_C@_0M@FJOIDAAJ@enumeration@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlRelaxNG

; 2532 :         facet->type = XML_SCHEMA_FACET_ENUMERATION;

	mov	DWORD PTR [edi], 1007			; 000003efH
	jmp	SHORT $LN29@xmlRelaxNG
$LN20@xmlRelaxNG:

; 2533 :     } else if (xmlStrEqual(facetname, BAD_CAST "whiteSpace")) {

	push	OFFSET ??_C@_0L@CCEMGGFL@whiteSpace@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@xmlRelaxNG

; 2534 :         facet->type = XML_SCHEMA_FACET_WHITESPACE;

	mov	DWORD PTR [edi], 1008			; 000003f0H
	jmp	SHORT $LN29@xmlRelaxNG
$LN22@xmlRelaxNG:

; 2535 :     } else if (xmlStrEqual(facetname, BAD_CAST "length")) {

	push	OFFSET ??_C@_06IJDLPEM@length@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@xmlRelaxNG

; 2536 :         facet->type = XML_SCHEMA_FACET_LENGTH;

	mov	DWORD PTR [edi], 1009			; 000003f1H
	jmp	SHORT $LN29@xmlRelaxNG
$LN24@xmlRelaxNG:

; 2537 :     } else if (xmlStrEqual(facetname, BAD_CAST "maxLength")) {

	push	OFFSET ??_C@_09KJHMKBNK@maxLength@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN26@xmlRelaxNG

; 2538 :         facet->type = XML_SCHEMA_FACET_MAXLENGTH;

	mov	DWORD PTR [edi], 1010			; 000003f2H
	jmp	SHORT $LN29@xmlRelaxNG
$LN26@xmlRelaxNG:

; 2539 :     } else if (xmlStrEqual(facetname, BAD_CAST "minLength")) {

	push	OFFSET ??_C@_09KIHADLGO@minLength@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN28@xmlRelaxNG

; 2540 :         facet->type = XML_SCHEMA_FACET_MINLENGTH;

	mov	DWORD PTR [edi], 1011			; 000003f3H
$LN29@xmlRelaxNG:

; 2543 :         return (-1);
; 2544 :     }
; 2545 :     facet->value = val;
; 2546 :     ret = xmlSchemaCheckFacet(facet, typ, NULL, type);

	mov	esi, DWORD PTR _typ$1$[ebp]
	mov	eax, DWORD PTR _val$[ebp]
	push	ebx
	push	0
	push	esi
	push	edi
	mov	DWORD PTR [edi+8], eax
	call	_xmlSchemaCheckFacet
	add	esp, 16					; 00000010H

; 2547 :     if (ret != 0) {

	test	eax, eax
	jne	SHORT $LN28@xmlRelaxNG

; 2548 :         xmlSchemaFreeFacet(facet);
; 2549 :         return (-1);
; 2550 :     }
; 2551 :     ret = xmlSchemaValidateFacet(typ, facet, strval, value);

	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _strval$[ebp]
	push	edi
	push	esi
	call	_xmlSchemaValidateFacet

; 2552 :     xmlSchemaFreeFacet(facet);

	push	edi
	mov	esi, eax
	call	_xmlSchemaFreeFacet
	add	esp, 20					; 00000014H

; 2553 :     if (ret != 0)

	test	esi, esi
	jne	SHORT $LN3@xmlRelaxNG

; 2554 :         return (-1);
; 2555 :     return (0);
; 2556 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN28@xmlRelaxNG:

; 2541 :     } else {
; 2542 :         xmlSchemaFreeFacet(facet);

	push	edi
	call	_xmlSchemaFreeFacet
	add	esp, 4
$LN3@xmlRelaxNG:

; 2554 :         return (-1);
; 2555 :     return (0);
; 2556 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
_xmlRelaxNGSchemaFacetCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGSchemaTypeCheck
_TEXT	SEGMENT
_data$ = 8						; size = 4
_type$ = 12						; size = 4
_value$ = 16						; size = 4
_result$ = 20						; size = 4
_node$ = 24						; size = 4
_xmlRelaxNGSchemaTypeCheck PROC				; COMDAT

; 2460 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG

; 2461 :     xmlSchemaTypePtr typ;
; 2462 :     int ret;
; 2463 : 
; 2464 :     if ((type == NULL) || (value == NULL))

	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN3@xmlRelaxNG

; 2466 :     typ = xmlSchemaGetPredefinedType(type,

	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	eax
	call	_xmlSchemaGetPredefinedType
	add	esp, 8

; 2467 :                                      BAD_CAST
; 2468 :                                      "http://www.w3.org/2001/XMLSchema");
; 2469 :     if (typ == NULL)

	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG

; 2470 :         return (-1);
; 2471 :     ret = xmlSchemaValPredefTypeNode(typ, value,

	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _result$[ebp]
	push	DWORD PTR _value$[ebp]
	push	eax
	call	_xmlSchemaValPredefTypeNode
	add	esp, 16					; 00000010H

; 2472 :                                      (xmlSchemaValPtr *) result, node);
; 2473 :     if (ret == 2)               /* special ID error code */

	cmp	eax, 2
	jne	SHORT $LN5@xmlRelaxNG

; 2479 :     return (-1);
; 2480 : }

	pop	ebp
	ret	0
$LN5@xmlRelaxNG:

; 2474 :         return (2);
; 2475 :     if (ret == 0)

	test	eax, eax
	jne	SHORT $LN9@xmlRelaxNG

; 2476 :         return (1);

	mov	eax, 1

; 2479 :     return (-1);
; 2480 : }

	pop	ebp
	ret	0
$LN9@xmlRelaxNG:

; 2477 :     if (ret > 0)

	jle	SHORT $LN3@xmlRelaxNG

; 2478 :         return (0);

	xor	eax, eax

; 2479 :     return (-1);
; 2480 : }

	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 2465 :         return (-1);

	or	eax, -1

; 2479 :     return (-1);
; 2480 : }

	pop	ebp
	ret	0
_xmlRelaxNGSchemaTypeCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGSchemaTypeHave
_TEXT	SEGMENT
_data$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlRelaxNGSchemaTypeHave PROC				; COMDAT

; 2430 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlRelaxNG

; 2431 :     xmlSchemaTypePtr typ;
; 2432 : 
; 2433 :     if (type == NULL)
; 2434 :         return (-1);

	or	eax, -1

; 2439 :         return (0);
; 2440 :     return (1);
; 2441 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:

; 2435 :     typ = xmlSchemaGetPredefinedType(type,

	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	eax
	call	_xmlSchemaGetPredefinedType
	add	esp, 8

; 2436 :                                      BAD_CAST
; 2437 :                                      "http://www.w3.org/2001/XMLSchema");
; 2438 :     if (typ == NULL)

	neg	eax
	sbb	eax, eax
	neg	eax

; 2439 :         return (0);
; 2440 :     return (1);
; 2441 : }

	pop	ebp
	ret	0
_xmlRelaxNGSchemaTypeHave ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGNormalize
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlRelaxNGNormalize PROC				; COMDAT

; 8565 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _str$[ebp]
	test	esi, esi
	jne	SHORT $LN10@xmlRelaxNG

; 8566 :     xmlChar *ret, *p;
; 8567 :     const xmlChar *tmp;
; 8568 :     int len;
; 8569 : 
; 8570 :     if (str == NULL)
; 8571 :         return (NULL);

	xor	eax, eax
	pop	esi

; 8597 : }

	pop	ebp
	ret	0
$LN10@xmlRelaxNG:

; 8572 :     tmp = str;
; 8573 :     while (*tmp != 0)

	cmp	BYTE PTR [esi], 0
	mov	eax, esi
	je	SHORT $LN3@xmlRelaxNG
$LL2@xmlRelaxNG:

; 8574 :         tmp++;

	inc	eax
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL2@xmlRelaxNG
$LN3@xmlRelaxNG:

; 8575 :     len = tmp - str;
; 8576 : 
; 8577 :     ret = (xmlChar *) xmlMallocAtomic((len + 1) * sizeof(xmlChar));

	sub	eax, esi
	inc	eax
	push	edi
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	mov	edi, eax
	add	esp, 4

; 8578 :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN11@xmlRelaxNG

; 479  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	xor	edx, edx
	xor	esi, esi
	test	eax, eax
	je	SHORT $LN23@xmlRelaxNG

; 480  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN25@xmlRelaxNG

; 481  : 	    schannel = ctxt->serror;
; 482  : 	else
; 483  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [eax+4]
$LN25@xmlRelaxNG:

; 484  :         data = ctxt->userData;

	mov	esi, DWORD PTR [eax]

; 485  :         ctxt->nbErrors++;

	inc	DWORD PTR [eax+16]
$LN23@xmlRelaxNG:

; 486  :     }
; 487  :     if (extra)
; 488  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0M@PEGDIBJJ@validating?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0M@PEGDIBJJ@validating?6@
	push	0
	push	0
	push	3
	push	2
	push	19					; 00000013H
	push	0
	push	0
	push	esi
	push	edx
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 8579 :         xmlRngVErrMemory(ctxt, "validating\n");
; 8580 :         return (NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 8597 : }

	pop	ebp
	ret	0
$LN11@xmlRelaxNG:

; 8581 :     }
; 8582 :     p = ret;

	mov	edx, edi
	npad	1
$LL4@xmlRelaxNG:

; 8583 :     while (IS_BLANK_CH(*str))

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN12@xmlRelaxNG
	cmp	al, 9
	jb	SHORT $LN13@xmlRelaxNG
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN12@xmlRelaxNG
$LN13@xmlRelaxNG:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN32@xmlRelaxNG
$LN12@xmlRelaxNG:

; 8584 :         str++;

	inc	esi
	jmp	SHORT $LL4@xmlRelaxNG
$LN32@xmlRelaxNG:

; 8585 :     while (*str != 0) {

	test	al, al
	je	SHORT $LN56@xmlRelaxNG
	npad	7
$LL6@xmlRelaxNG:

; 8586 :         if (IS_BLANK_CH(*str)) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN18@xmlRelaxNG
	cmp	al, 9
	jb	SHORT $LN17@xmlRelaxNG
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LL8@xmlRelaxNG
$LN17@xmlRelaxNG:
	cmp	al, 13					; 0000000dH
	je	SHORT $LL8@xmlRelaxNG

; 8592 :         } else
; 8593 :             *p++ = *str++;

	inc	esi
	jmp	SHORT $LN15@xmlRelaxNG
$LL8@xmlRelaxNG:

; 8587 :             while (IS_BLANK_CH(*str))

	cmp	al, 32					; 00000020H
	je	SHORT $LN18@xmlRelaxNG
	cmp	al, 9
	jb	SHORT $LN19@xmlRelaxNG
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN18@xmlRelaxNG
$LN19@xmlRelaxNG:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN9@xmlRelaxNG
$LN18@xmlRelaxNG:

; 8588 :                 str++;

	mov	al, BYTE PTR [esi+1]
	inc	esi
	jmp	SHORT $LL8@xmlRelaxNG
$LN9@xmlRelaxNG:

; 8589 :             if (*str == 0)

	test	al, al
	je	SHORT $LN56@xmlRelaxNG

; 8590 :                 break;
; 8591 :             *p++ = ' ';

	mov	al, 32					; 00000020H
$LN15@xmlRelaxNG:

; 8585 :     while (*str != 0) {

	mov	BYTE PTR [edx], al
	inc	edx
	mov	al, BYTE PTR [esi]
	test	al, al
	jne	SHORT $LL6@xmlRelaxNG
$LN56@xmlRelaxNG:

; 8594 :     }
; 8595 :     *p = 0;
; 8596 :     return (ret);

	mov	eax, edi
	mov	BYTE PTR [edx], 0
	pop	edi
	pop	esi

; 8597 : }

	pop	ebp
	ret	0
_xmlRelaxNGNormalize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGAddValidError
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_err$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_dup$ = 24						; size = 4
_xmlRelaxNGAddValidError PROC				; COMDAT

; 2368 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlRelaxNG

; 2369 :     if (ctxt == NULL)
; 2370 :         return;
; 2371 :     if (ctxt->flags & FLAGS_NOERROR)

	mov	eax, DWORD PTR [esi+28]
	test	al, 8
	jne	SHORT $LN5@xmlRelaxNG

; 2372 :         return;
; 2373 : 
; 2374 : #ifdef DEBUG_ERROR
; 2375 :     xmlGenericError(xmlGenericErrorContext, "Adding error %d\n", err);
; 2376 : #endif
; 2377 :     /*
; 2378 :      * generate the error directly
; 2379 :      */
; 2380 :     if (((ctxt->flags & FLAGS_IGNORABLE) == 0) ||

	and	al, 3
	cmp	al, 1
	jne	SHORT $LN6@xmlRelaxNG

; 2400 :     }
; 2401 :     /*
; 2402 :      * Stack the error for later processing if needed
; 2403 :      */
; 2404 :     else {
; 2405 :         xmlRelaxNGValidErrorPush(ctxt, err, arg1, arg2, dup);

	push	DWORD PTR _dup$[ebp]
	push	DWORD PTR _arg2$[ebp]
	push	DWORD PTR _arg1$[ebp]
	push	DWORD PTR _err$[ebp]
	push	esi
	call	_xmlRelaxNGValidErrorPush
	add	esp, 20					; 00000014H
	pop	esi

; 2406 :     }
; 2407 : }

	pop	ebp
	ret	0
$LN6@xmlRelaxNG:

; 2381 : 	 (ctxt->flags & FLAGS_NEGATIVE)) {
; 2382 :         xmlNodePtr node, seq;
; 2383 : 
; 2384 :         /*
; 2385 :          * Flush first any stacked error which might be the
; 2386 :          * real cause of the problem.
; 2387 :          */
; 2388 :         if (ctxt->errNr != 0)

	cmp	DWORD PTR [esi+48], 0
	je	SHORT $LN7@xmlRelaxNG

; 2389 :             xmlRelaxNGDumpValidError(ctxt);

	push	esi
	call	_xmlRelaxNGDumpValidError
	add	esp, 4
$LN7@xmlRelaxNG:

; 2390 :         if (ctxt->state != NULL) {

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN8@xmlRelaxNG

; 2391 :             node = ctxt->state->node;

	mov	ecx, DWORD PTR [eax]

; 2392 :             seq = ctxt->state->seq;

	mov	eax, DWORD PTR [eax+4]

; 2395 :         }
; 2396 :         if ((node == NULL) && (seq == NULL)) {

	test	ecx, ecx
	jne	SHORT $LN10@xmlRelaxNG
	test	eax, eax
	jne	SHORT $LN10@xmlRelaxNG
	jmp	SHORT $LN13@xmlRelaxNG
$LN8@xmlRelaxNG:

; 2393 :         } else {
; 2394 :             node = seq = NULL;

	xor	eax, eax
$LN13@xmlRelaxNG:

; 2397 :             node = ctxt->pnode;

	mov	ecx, DWORD PTR [esi+104]
$LN10@xmlRelaxNG:

; 2398 :         }
; 2399 :         xmlRelaxNGShowValidError(ctxt, err, node, seq, arg1, arg2);

	push	DWORD PTR _arg2$[ebp]
	push	DWORD PTR _arg1$[ebp]
	push	eax
	push	ecx
	push	DWORD PTR _err$[ebp]
	push	esi
	call	_xmlRelaxNGShowValidError
	add	esp, 24					; 00000018H
$LN5@xmlRelaxNG:
	pop	esi

; 2406 :     }
; 2407 : }

	pop	ebp
	ret	0
_xmlRelaxNGAddValidError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGDumpValidError
_TEXT	SEGMENT
tv274 = -16						; size = 4
_k$1$ = -12						; size = 4
tv273 = -8						; size = 4
_i$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlRelaxNGDumpValidError PROC				; COMDAT

; 2316 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	xor	ecx, ecx
	mov	DWORD PTR _i$1$[ebp], eax
	mov	DWORD PTR _k$1$[ebp], ecx
	cmp	DWORD PTR [edx+48], eax
	jle	$LN25@xmlRelaxNG
	push	ebx
	push	esi
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR tv273[ebp], ebx
	npad	2
$LL4@xmlRelaxNG:

; 2325 :         err = &ctxt->errTab[i];

	mov	esi, DWORD PTR [edx+56]
	add	esi, ebx

; 2326 :         if (k < MAX_ERROR) {

	cmp	ecx, 5
	jge	$skip$30

; 2327 :             for (j = 0; j < i; j++) {

	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN6@xmlRelaxNG
	mov	ecx, DWORD PTR _i$1$[ebp]
	xor	eax, eax
	mov	DWORD PTR tv274[ebp], eax
	npad	4
$LL7@xmlRelaxNG:

; 2328 :                 dup = &ctxt->errTab[j];

	mov	edi, DWORD PTR [edx+56]
	add	edi, eax

; 2329 :                 if ((err->err == dup->err) && (err->node == dup->node) &&
; 2330 :                     (xmlStrEqual(err->arg1, dup->arg1)) &&

	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [edi]
	jne	SHORT $LN5@xmlRelaxNG
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [edi+8]
	jne	SHORT $LN5@xmlRelaxNG
	push	DWORD PTR [edi+16]
	push	DWORD PTR [esi+16]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN26@xmlRelaxNG
	push	DWORD PTR [edi+20]
	push	DWORD PTR [esi+20]
	call	_xmlStrEqual
	mov	edx, DWORD PTR _ctxt$[ebp]
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@xmlRelaxNG
	jmp	SHORT $LN28@xmlRelaxNG
$LN26@xmlRelaxNG:
	mov	edx, DWORD PTR _ctxt$[ebp]
$LN28@xmlRelaxNG:

; 2327 :             for (j = 0; j < i; j++) {

	mov	ecx, DWORD PTR _i$1$[ebp]
$LN5@xmlRelaxNG:
	mov	eax, DWORD PTR tv274[ebp]
	inc	ebx
	add	eax, 24					; 00000018H
	mov	DWORD PTR tv274[ebp], eax
	cmp	ebx, ecx
	jl	SHORT $LL7@xmlRelaxNG
$LN6@xmlRelaxNG:

; 2331 :                     (xmlStrEqual(err->arg2, dup->arg2))) {
; 2332 :                     goto skip;
; 2333 :                 }
; 2334 :             }
; 2335 :             xmlRelaxNGShowValidError(ctxt, err->err, err->node, err->seq,

	push	DWORD PTR [esi+20]
	push	DWORD PTR [esi+16]
	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi]
	push	edx
	call	_xmlRelaxNGShowValidError
	mov	edx, DWORD PTR _ctxt$[ebp]
	add	esp, 24					; 00000018H

; 2336 :                                      err->arg1, err->arg2);
; 2337 :             k++;

	inc	DWORD PTR _k$1$[ebp]
$LN27@xmlRelaxNG:

; 2338 :         }
; 2339 :       skip:
; 2340 :         if (err->flags & ERROR_IS_DUP) {

	mov	ebx, DWORD PTR tv273[ebp]
	mov	eax, DWORD PTR _i$1$[ebp]
$skip$30:
	test	BYTE PTR [esi+4], 1
	je	SHORT $LN2@xmlRelaxNG

; 2341 :             if (err->arg1 != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN11@xmlRelaxNG

; 2342 :                 xmlFree((xmlChar *) err->arg1);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlRelaxNG:

; 2343 :             err->arg1 = NULL;
; 2344 :             if (err->arg2 != NULL)

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+16], 0
	test	eax, eax
	je	SHORT $LN12@xmlRelaxNG

; 2345 :                 xmlFree((xmlChar *) err->arg2);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlRelaxNG:

; 2346 :             err->arg2 = NULL;

	mov	eax, DWORD PTR _i$1$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [esi+20], 0

; 2347 :             err->flags = 0;

	mov	DWORD PTR [esi+4], 0
$LN2@xmlRelaxNG:

; 2317 :     int i, j, k;
; 2318 :     xmlRelaxNGValidErrorPtr err, dup;
; 2319 : 
; 2320 : #ifdef DEBUG_ERROR
; 2321 :     xmlGenericError(xmlGenericErrorContext,
; 2322 :                     "Dumping error stack %d errors\n", ctxt->errNr);
; 2323 : #endif
; 2324 :     for (i = 0, k = 0; i < ctxt->errNr; i++) {

	mov	ecx, DWORD PTR _k$1$[ebp]
	inc	eax
	add	ebx, 24					; 00000018H
	mov	DWORD PTR _i$1$[ebp], eax
	mov	DWORD PTR tv273[ebp], ebx
	cmp	eax, DWORD PTR [edx+48]
	jl	$LL4@xmlRelaxNG

; 2348 :         }
; 2349 :     }
; 2350 :     ctxt->errNr = 0;

	pop	edi
	pop	esi
	mov	DWORD PTR [edx+48], 0
	pop	ebx

; 2351 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlRelaxNG:

; 2348 :         }
; 2349 :     }
; 2350 :     ctxt->errNr = 0;

	mov	DWORD PTR [edx+48], eax

; 2351 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGDumpValidError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGPopErrors
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_level$ = 12						; size = 4
_xmlRelaxNGPopErrors PROC				; COMDAT

; 2283 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _level$[ebp]
	mov	ebx, ecx
	cmp	ecx, DWORD PTR [eax+48]
	jge	SHORT $LN3@xmlRelaxNG
	push	esi
	push	edi
	lea	edi, DWORD PTR [ecx+ecx*2]
	shl	edi, 3
$LL4@xmlRelaxNG:

; 2292 :         err = &ctxt->errTab[i];

	mov	esi, DWORD PTR [eax+56]
	add	esi, edi

; 2293 :         if (err->flags & ERROR_IS_DUP) {

	test	BYTE PTR [esi+4], 1
	je	SHORT $LN2@xmlRelaxNG

; 2294 :             if (err->arg1 != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG

; 2295 :                 xmlFree((xmlChar *) err->arg1);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlRelaxNG:

; 2296 :             err->arg1 = NULL;
; 2297 :             if (err->arg2 != NULL)

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+16], 0
	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG

; 2298 :                 xmlFree((xmlChar *) err->arg2);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlRelaxNG:

; 2299 :             err->arg2 = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [esi+20], 0

; 2300 :             err->flags = 0;

	mov	DWORD PTR [esi+4], 0
$LN2@xmlRelaxNG:

; 2284 :     int i;
; 2285 :     xmlRelaxNGValidErrorPtr err;
; 2286 : 
; 2287 : #ifdef DEBUG_ERROR
; 2288 :     xmlGenericError(xmlGenericErrorContext,
; 2289 :                     "Pop errors till level %d\n", level);
; 2290 : #endif
; 2291 :     for (i = level; i < ctxt->errNr; i++) {

	inc	ebx
	add	edi, 24					; 00000018H
	cmp	ebx, DWORD PTR [eax+48]
	jl	SHORT $LL4@xmlRelaxNG
	mov	ecx, DWORD PTR _level$[ebp]
	pop	edi
	pop	esi
$LN3@xmlRelaxNG:

; 2301 :         }
; 2302 :     }
; 2303 :     ctxt->errNr = level;

	mov	DWORD PTR [eax+48], ecx
	pop	ebx

; 2304 :     if (ctxt->errNr <= 0)

	test	ecx, ecx
	jg	SHORT $LN8@xmlRelaxNG

; 2305 :         ctxt->err = NULL;

	mov	DWORD PTR [eax+44], 0
$LN8@xmlRelaxNG:

; 2306 : }

	pop	ebp
	ret	0
_xmlRelaxNGPopErrors ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGShowValidError
_TEXT	SEGMENT
_msg$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_err$ = 12						; size = 4
_node$ = 16						; size = 4
_child$ = 20						; size = 4
_arg1$ = 24						; size = 4
_arg2$ = 28						; size = 4
_xmlRelaxNGShowValidError PROC				; COMDAT

; 2254 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	BYTE PTR [esi+28], 8
	jne	SHORT $LN1@xmlRelaxNG

; 2255 :     xmlChar *msg;
; 2256 : 
; 2257 :     if (ctxt->flags & FLAGS_NOERROR)
; 2258 :         return;
; 2259 : 
; 2260 : #ifdef DEBUG_ERROR
; 2261 :     xmlGenericError(xmlGenericErrorContext, "Show error %d\n", err);
; 2262 : #endif
; 2263 :     msg = xmlRelaxNGGetErrorString(err, arg1, arg2);

	push	ebx
	mov	ebx, DWORD PTR _arg2$[ebp]
	push	edi
	mov	edi, DWORD PTR _err$[ebp]
	push	ebx
	push	DWORD PTR _arg1$[ebp]
	push	edi
	call	_xmlRelaxNGGetErrorString
	mov	ecx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _msg$1$[ebp], ecx

; 2264 :     if (msg == NULL)

	test	ecx, ecx
	je	SHORT $LN11@xmlRelaxNG

; 2265 :         return;
; 2266 : 
; 2267 :     if (ctxt->errNo == XML_RELAXNG_OK)

	cmp	DWORD PTR [esi+40], 0
	jne	SHORT $LN4@xmlRelaxNG

; 2268 :         ctxt->errNo = err;

	mov	DWORD PTR [esi+40], edi
$LN4@xmlRelaxNG:

; 550  :     xmlGenericErrorFunc channel = NULL;

	xor	edx, edx

; 551  :     void *data = NULL;
; 552  : 
; 553  :     if (ctxt != NULL) {
; 554  :         if (ctxt->serror != NULL)

	cmp	DWORD PTR [esi+12], edx
	jne	SHORT $LN9@xmlRelaxNG

; 555  : 	    schannel = ctxt->serror;
; 556  : 	else
; 557  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [esi+4]
$LN9@xmlRelaxNG:

; 558  :         data = ctxt->userData;
; 559  :         ctxt->nbErrors++;
; 560  :     }
; 561  :     __xmlRaiseError(schannel, channel, data,

	mov	eax, DWORD PTR _arg1$[ebp]
	push	ebx
	push	eax
	inc	DWORD PTR [esi+16]
	push	ecx
	push	0
	push	0
	push	0
	push	ebx
	push	eax

; 2269 :     xmlRngVErr(ctxt, (child == NULL ? node : child), err,

	mov	eax, DWORD PTR _child$[ebp]
	test	eax, eax

; 561  :     __xmlRaiseError(schannel, channel, data,

	push	0

; 2269 :     xmlRngVErr(ctxt, (child == NULL ? node : child), err,

	cmove	eax, DWORD PTR _node$[ebp]

; 561  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	2
	push	edi
	push	19					; 00000013H
	push	eax
	push	0
	push	DWORD PTR [esi]
	push	edx
	push	DWORD PTR [esi+12]
	call	___xmlRaiseError

; 2270 :                (const char *) msg, arg1, arg2);
; 2271 :     xmlFree(msg);

	push	DWORD PTR _msg$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 76					; 0000004cH
$LN11@xmlRelaxNG:
	pop	edi
	pop	ebx
$LN1@xmlRelaxNG:
	pop	esi

; 2272 : }

	pop	ebp
	ret	0
_xmlRelaxNGShowValidError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGGetErrorString
_TEXT	SEGMENT
_msg$ = -1004						; size = 1000
_result$ = -4						; size = 4
_err$ = 8						; size = 4
_arg1$ = 12						; size = 4
_arg2$ = 16						; size = 4
_xmlRelaxNGGetErrorString PROC				; COMDAT

; 2104 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1004				; 000003ecH
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _arg1$[ebp]
	mov	edx, OFFSET ??_C@_00CNPNBAHC@@
	mov	esi, DWORD PTR _err$[ebp]
	test	eax, eax
	mov	ecx, edx
	mov	BYTE PTR _msg$[ebp], 0
	cmovne	ecx, eax
	mov	eax, DWORD PTR _arg2$[ebp]
	test	eax, eax
	cmovne	edx, eax
	cmp	esi, 39					; 00000027H
	ja	$LN41@xmlRelaxNG

; 2105 :     char msg[1000];
; 2106 :     xmlChar *result;
; 2107 : 
; 2108 :     if (arg1 == NULL)
; 2109 :         arg1 = BAD_CAST "";
; 2110 :     if (arg2 == NULL)
; 2111 :         arg2 = BAD_CAST "";
; 2112 : 
; 2113 :     msg[0] = 0;
; 2114 :     switch (err) {

	jmp	DWORD PTR $LN48@xmlRelaxNG[esi*4]
$LN6@xmlRelaxNG:

; 2115 :         case XML_RELAXNG_OK:
; 2116 :             return (NULL);

	xor	eax, eax
	pop	esi

; 2236 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlRelaxNG:

; 2117 :         case XML_RELAXNG_ERR_MEMORY:
; 2118 :             return (xmlCharStrdup("out of memory\n"));

	push	OFFSET ??_C@_0P@PCJPAHLM@out?5of?5memory?6@

; 2236 : }

	call	_xmlCharStrdup
	add	esp, 4
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlRelaxNG:

; 2119 :         case XML_RELAXNG_ERR_TYPE:
; 2120 :             snprintf(msg, 1000, "failed to validate type %s\n", arg1);

	push	ecx
	push	OFFSET ??_C@_0BM@ECNPKFCP@failed?5to?5validate?5type?5?$CFs?6@

; 2121 :             break;

	jmp	$LN45@xmlRelaxNG
$LN9@xmlRelaxNG:

; 2122 :         case XML_RELAXNG_ERR_TYPEVAL:
; 2123 :             snprintf(msg, 1000, "Type %s doesn't allow value '%s'\n", arg1,

	push	edx
	push	ecx
	push	OFFSET ??_C@_0CC@KEMEBCBB@Type?5?$CFs?5doesn?8t?5allow?5value?5?8?$CFs@
$LN46@xmlRelaxNG:

; 2229 :     }
; 2230 :     if (msg[0] == 0) {

	lea	eax, DWORD PTR _msg$[ebp]
	push	1000					; 000003e8H
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H
	jmp	$LN2@xmlRelaxNG
$LN10@xmlRelaxNG:

; 2124 :                      arg2);
; 2125 :             break;
; 2126 :         case XML_RELAXNG_ERR_DUPID:
; 2127 :             snprintf(msg, 1000, "ID %s redefined\n", arg1);

	push	ecx
	push	OFFSET ??_C@_0BB@HOPAIONI@ID?5?$CFs?5redefined?6@

; 2128 :             break;

	jmp	$LN45@xmlRelaxNG
$LN11@xmlRelaxNG:

; 2129 :         case XML_RELAXNG_ERR_TYPECMP:
; 2130 :             snprintf(msg, 1000, "failed to compare type %s\n", arg1);

	push	ecx
	push	OFFSET ??_C@_0BL@NPBAOLP@failed?5to?5compare?5type?5?$CFs?6@

; 2131 :             break;

	jmp	$LN45@xmlRelaxNG
$LN12@xmlRelaxNG:

; 2132 :         case XML_RELAXNG_ERR_NOSTATE:
; 2133 :             return (xmlCharStrdup("Internal error: no state\n"));

	push	OFFSET ??_C@_0BK@NEMAGDEO@Internal?5error?3?5no?5state?6@

; 2236 : }

	call	_xmlCharStrdup
	add	esp, 4
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlRelaxNG:

; 2134 :         case XML_RELAXNG_ERR_NODEFINE:
; 2135 :             return (xmlCharStrdup("Internal error: no define\n"));

	push	OFFSET ??_C@_0BL@MNHHIDKB@Internal?5error?3?5no?5define?6@

; 2236 : }

	call	_xmlCharStrdup
	add	esp, 4
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlRelaxNG:

; 2136 :         case XML_RELAXNG_ERR_INTERNAL:
; 2137 :             snprintf(msg, 1000, "Internal error: %s\n", arg1);

	push	ecx
	push	OFFSET ??_C@_0BE@MNPHNNMB@Internal?5error?3?5?$CFs?6@

; 2138 :             break;

	jmp	$LN45@xmlRelaxNG
$LN15@xmlRelaxNG:

; 2139 :         case XML_RELAXNG_ERR_LISTEXTRA:
; 2140 :             snprintf(msg, 1000, "Extra data in list: %s\n", arg1);

	push	ecx
	push	OFFSET ??_C@_0BI@DGHEOLEJ@Extra?5data?5in?5list?3?5?$CFs?6@

; 2141 :             break;

	jmp	$LN45@xmlRelaxNG
$LN16@xmlRelaxNG:

; 2142 :         case XML_RELAXNG_ERR_INTERNODATA:
; 2143 :             return (xmlCharStrdup

	push	OFFSET ??_C@_0CI@IMJEPEGE@Internal?3?5interleave?5block?5has?5@

; 2236 : }

	call	_xmlCharStrdup
	add	esp, 4
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlRelaxNG:

; 2144 :                     ("Internal: interleave block has no data\n"));
; 2145 :         case XML_RELAXNG_ERR_INTERSEQ:
; 2146 :             return (xmlCharStrdup("Invalid sequence in interleave\n"));

	push	OFFSET ??_C@_0CA@EOAAMELI@Invalid?5sequence?5in?5interleave?6@

; 2236 : }

	call	_xmlCharStrdup
	add	esp, 4
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlRelaxNG:

; 2147 :         case XML_RELAXNG_ERR_INTEREXTRA:
; 2148 :             snprintf(msg, 1000, "Extra element %s in interleave\n", arg1);

	push	ecx
	push	OFFSET ??_C@_0CA@LHKGPAAK@Extra?5element?5?$CFs?5in?5interleave?6@

; 2149 :             break;

	jmp	$LN45@xmlRelaxNG
$LN19@xmlRelaxNG:

; 2150 :         case XML_RELAXNG_ERR_ELEMNAME:
; 2151 :             snprintf(msg, 1000, "Expecting element %s, got %s\n", arg1,

	push	edx
	push	ecx
	push	OFFSET ??_C@_0BO@IPFGDLDE@Expecting?5element?5?$CFs?0?5got?5?$CFs?6@

; 2152 :                      arg2);
; 2153 :             break;

	jmp	$LN46@xmlRelaxNG
$LN20@xmlRelaxNG:

; 2154 :         case XML_RELAXNG_ERR_ELEMNONS:
; 2155 :             snprintf(msg, 1000, "Expecting a namespace for element %s\n",

	push	ecx
	push	OFFSET ??_C@_0CG@JOOKFIPP@Expecting?5a?5namespace?5for?5eleme@

; 2156 :                      arg1);
; 2157 :             break;

	jmp	$LN45@xmlRelaxNG
$LN21@xmlRelaxNG:

; 2158 :         case XML_RELAXNG_ERR_ELEMWRONGNS:
; 2159 :             snprintf(msg, 1000,

	push	edx
	push	ecx
	push	OFFSET ??_C@_0CO@FJCKMMIH@Element?5?$CFs?5has?5wrong?5namespace?3@

; 2160 :                      "Element %s has wrong namespace: expecting %s\n", arg1,
; 2161 :                      arg2);
; 2162 :             break;

	jmp	$LN46@xmlRelaxNG
$LN22@xmlRelaxNG:

; 2163 :         case XML_RELAXNG_ERR_ELEMWRONG:
; 2164 :             snprintf(msg, 1000, "Did not expect element %s there\n", arg1);

	push	ecx
	push	OFFSET ??_C@_0CB@PHEJHGKI@Did?5not?5expect?5element?5?$CFs?5there@

; 2165 :             break;

	jmp	$LN45@xmlRelaxNG
$LN23@xmlRelaxNG:

; 2166 :         case XML_RELAXNG_ERR_TEXTWRONG:
; 2167 :             snprintf(msg, 1000,

	push	ecx
	push	OFFSET ??_C@_0CL@PJGOEKPA@Did?5not?5expect?5text?5in?5element?5@

; 2168 :                      "Did not expect text in element %s content\n", arg1);
; 2169 :             break;

	jmp	$LN45@xmlRelaxNG
$LN24@xmlRelaxNG:

; 2170 :         case XML_RELAXNG_ERR_ELEMEXTRANS:
; 2171 :             snprintf(msg, 1000, "Expecting no namespace for element %s\n",

	push	ecx
	push	OFFSET ??_C@_0CH@HAJGKJGA@Expecting?5no?5namespace?5for?5elem@

; 2172 :                      arg1);
; 2173 :             break;

	jmp	SHORT $LN45@xmlRelaxNG
$LN25@xmlRelaxNG:

; 2174 :         case XML_RELAXNG_ERR_ELEMNOTEMPTY:
; 2175 :             snprintf(msg, 1000, "Expecting element %s to be empty\n", arg1);

	push	ecx
	push	OFFSET ??_C@_0CC@DNABBFDN@Expecting?5element?5?$CFs?5to?5be?5empt@

; 2176 :             break;

	jmp	SHORT $LN45@xmlRelaxNG
$LN26@xmlRelaxNG:

; 2177 :         case XML_RELAXNG_ERR_NOELEM:
; 2178 :             snprintf(msg, 1000, "Expecting an element %s, got nothing\n",

	push	ecx
	push	OFFSET ??_C@_0CG@GHEDPKLH@Expecting?5an?5element?5?$CFs?0?5got?5no@

; 2179 :                      arg1);
; 2180 :             break;

	jmp	SHORT $LN45@xmlRelaxNG
$LN27@xmlRelaxNG:

; 2181 :         case XML_RELAXNG_ERR_NOTELEM:
; 2182 :             return (xmlCharStrdup("Expecting an element got text\n"));

	push	OFFSET ??_C@_0BP@PIOGJCNK@Expecting?5an?5element?5got?5text?6@

; 2236 : }

	call	_xmlCharStrdup
	add	esp, 4
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlRelaxNG:

; 2183 :         case XML_RELAXNG_ERR_ATTRVALID:
; 2184 :             snprintf(msg, 1000, "Element %s failed to validate attributes\n",

	push	ecx
	push	OFFSET ??_C@_0CK@NNGAPDCO@Element?5?$CFs?5failed?5to?5validate?5a@

; 2185 :                      arg1);
; 2186 :             break;

	jmp	SHORT $LN45@xmlRelaxNG
$LN29@xmlRelaxNG:

; 2187 :         case XML_RELAXNG_ERR_CONTENTVALID:
; 2188 :             snprintf(msg, 1000, "Element %s failed to validate content\n",

	push	ecx
	push	OFFSET ??_C@_0CH@HDDGPFIH@Element?5?$CFs?5failed?5to?5validate?5c@

; 2189 :                      arg1);
; 2190 :             break;

	jmp	SHORT $LN45@xmlRelaxNG
$LN30@xmlRelaxNG:

; 2191 :         case XML_RELAXNG_ERR_EXTRACONTENT:
; 2192 :             snprintf(msg, 1000, "Element %s has extra content: %s\n",

	push	edx
	push	ecx
	push	OFFSET ??_C@_0CC@PHDGKAKM@Element?5?$CFs?5has?5extra?5content?3?5?$CF@

; 2193 :                      arg1, arg2);
; 2194 :             break;

	jmp	$LN46@xmlRelaxNG
$LN31@xmlRelaxNG:

; 2195 :         case XML_RELAXNG_ERR_INVALIDATTR:
; 2196 :             snprintf(msg, 1000, "Invalid attribute %s for element %s\n",

	push	edx
	push	ecx
	push	OFFSET ??_C@_0CF@ECDDKCLG@Invalid?5attribute?5?$CFs?5for?5elemen@

; 2197 :                      arg1, arg2);
; 2198 :             break;

	jmp	$LN46@xmlRelaxNG
$LN32@xmlRelaxNG:

; 2199 :         case XML_RELAXNG_ERR_LACKDATA:
; 2200 :             snprintf(msg, 1000, "Datatype element %s contains no data\n",

	push	ecx
	push	OFFSET ??_C@_0CG@FMKMGJKC@Datatype?5element?5?$CFs?5contains?5no@

; 2201 :                      arg1);
; 2202 :             break;

	jmp	SHORT $LN45@xmlRelaxNG
$LN33@xmlRelaxNG:

; 2203 :         case XML_RELAXNG_ERR_DATAELEM:
; 2204 :             snprintf(msg, 1000, "Datatype element %s has child elements\n",

	push	ecx
	push	OFFSET ??_C@_0CI@NMBBKCFB@Datatype?5element?5?$CFs?5has?5child?5e@

; 2205 :                      arg1);
; 2206 :             break;

	jmp	SHORT $LN45@xmlRelaxNG
$LN34@xmlRelaxNG:

; 2207 :         case XML_RELAXNG_ERR_VALELEM:
; 2208 :             snprintf(msg, 1000, "Value element %s has child elements\n",

	push	ecx
	push	OFFSET ??_C@_0CF@MGMBBHLP@Value?5element?5?$CFs?5has?5child?5elem@

; 2209 :                      arg1);
; 2210 :             break;

	jmp	SHORT $LN45@xmlRelaxNG
$LN35@xmlRelaxNG:

; 2211 :         case XML_RELAXNG_ERR_LISTELEM:
; 2212 :             snprintf(msg, 1000, "List element %s has child elements\n",

	push	ecx
	push	OFFSET ??_C@_0CE@LKJLECIM@List?5element?5?$CFs?5has?5child?5eleme@

; 2213 :                      arg1);
; 2214 :             break;

	jmp	SHORT $LN45@xmlRelaxNG
$LN36@xmlRelaxNG:

; 2215 :         case XML_RELAXNG_ERR_DATATYPE:
; 2216 :             snprintf(msg, 1000, "Error validating datatype %s\n", arg1);

	push	ecx
	push	OFFSET ??_C@_0BO@GLDGEAAK@Error?5validating?5datatype?5?$CFs?6@

; 2217 :             break;

	jmp	SHORT $LN45@xmlRelaxNG
$LN37@xmlRelaxNG:

; 2218 :         case XML_RELAXNG_ERR_VALUE:
; 2219 :             snprintf(msg, 1000, "Error validating value %s\n", arg1);

	push	ecx
	push	OFFSET ??_C@_0BL@BLOANDFF@Error?5validating?5value?5?$CFs?6@
$LN45@xmlRelaxNG:

; 2229 :     }
; 2230 :     if (msg[0] == 0) {

	lea	eax, DWORD PTR _msg$[ebp]
	push	1000					; 000003e8H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
$LN2@xmlRelaxNG:
	cmp	BYTE PTR _msg$[ebp], 0
	jne	SHORT $LN42@xmlRelaxNG

; 2231 :         snprintf(msg, 1000, "Unknown error code %d\n", err);

	push	esi
	push	OFFSET ??_C@_0BH@OAFIADK@Unknown?5error?5code?5?$CFd?6@
	lea	eax, DWORD PTR _msg$[ebp]
	push	1000					; 000003e8H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
$LN42@xmlRelaxNG:

; 2232 :     }
; 2233 :     msg[1000 - 1] = 0;
; 2234 :     result = xmlCharStrdup(msg);

	lea	eax, DWORD PTR _msg$[ebp]
	mov	BYTE PTR _msg$[ebp+999], 0
	push	eax
	call	_xmlCharStrdup
	mov	DWORD PTR _result$[ebp], eax

; 2235 :     return (xmlEscapeFormatString(&result));

	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	_xmlEscapeFormatString
	add	esp, 8
	pop	esi

; 2236 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@xmlRelaxNG:

; 2220 :             break;
; 2221 :         case XML_RELAXNG_ERR_LIST:
; 2222 :             return (xmlCharStrdup("Error validating list\n"));

	push	OFFSET ??_C@_0BH@MNIEAPHM@Error?5validating?5list?6@

; 2236 : }

	call	_xmlCharStrdup
	add	esp, 4
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@xmlRelaxNG:

; 2223 :         case XML_RELAXNG_ERR_NOGRAMMAR:
; 2224 :             return (xmlCharStrdup("No top grammar defined\n"));

	push	OFFSET ??_C@_0BI@LEPPKIJB@No?5top?5grammar?5defined?6@

; 2236 : }

	call	_xmlCharStrdup
	add	esp, 4
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@xmlRelaxNG:

; 2225 :         case XML_RELAXNG_ERR_EXTRADATA:
; 2226 :             return (xmlCharStrdup("Extra data in the document\n"));

	push	OFFSET ??_C@_0BM@HIGEPHGM@Extra?5data?5in?5the?5document?6@

; 2236 : }

	call	_xmlCharStrdup
	add	esp, 4
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@xmlRelaxNG:

; 2227 :         default:
; 2228 :             return (xmlCharStrdup("Unknown error !\n"));

	push	OFFSET ??_C@_0BB@OENMHDGG@Unknown?5error?5?$CB?6@

; 2236 : }

	call	_xmlCharStrdup
	add	esp, 4
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@xmlRelaxNG:
	DD	$LN6@xmlRelaxNG
	DD	$LN7@xmlRelaxNG
	DD	$LN8@xmlRelaxNG
	DD	$LN9@xmlRelaxNG
	DD	$LN10@xmlRelaxNG
	DD	$LN11@xmlRelaxNG
	DD	$LN12@xmlRelaxNG
	DD	$LN13@xmlRelaxNG
	DD	$LN15@xmlRelaxNG
	DD	$LN41@xmlRelaxNG
	DD	$LN16@xmlRelaxNG
	DD	$LN17@xmlRelaxNG
	DD	$LN18@xmlRelaxNG
	DD	$LN19@xmlRelaxNG
	DD	$LN41@xmlRelaxNG
	DD	$LN20@xmlRelaxNG
	DD	$LN41@xmlRelaxNG
	DD	$LN21@xmlRelaxNG
	DD	$LN41@xmlRelaxNG
	DD	$LN24@xmlRelaxNG
	DD	$LN41@xmlRelaxNG
	DD	$LN25@xmlRelaxNG
	DD	$LN26@xmlRelaxNG
	DD	$LN27@xmlRelaxNG
	DD	$LN28@xmlRelaxNG
	DD	$LN29@xmlRelaxNG
	DD	$LN30@xmlRelaxNG
	DD	$LN31@xmlRelaxNG
	DD	$LN33@xmlRelaxNG
	DD	$LN34@xmlRelaxNG
	DD	$LN35@xmlRelaxNG
	DD	$LN36@xmlRelaxNG
	DD	$LN37@xmlRelaxNG
	DD	$LN38@xmlRelaxNG
	DD	$LN39@xmlRelaxNG
	DD	$LN40@xmlRelaxNG
	DD	$LN32@xmlRelaxNG
	DD	$LN14@xmlRelaxNG
	DD	$LN22@xmlRelaxNG
	DD	$LN23@xmlRelaxNG
_xmlRelaxNGGetErrorString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGDefName
_TEXT	SEGMENT
_def$ = 8						; size = 4
_xmlRelaxNGDefName PROC					; COMDAT

; 2039 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _def$[ebp]
	test	eax, eax
	jne	SHORT $LN4@xmlRelaxNG

; 2040 :     if (def == NULL)
; 2041 :         return ("none");

	mov	eax, OFFSET ??_C@_04CGFJFPFD@none@

; 2089 : }

	pop	ebp
	ret	0
$LN4@xmlRelaxNG:

; 2042 :     switch (def->type) {

	mov	eax, DWORD PTR [eax]
	inc	eax
	cmp	eax, 21					; 00000015H
	ja	$LN2@xmlRelaxNG
	jmp	DWORD PTR $LN29@xmlRelaxNG[eax*4]
$LN5@xmlRelaxNG:

; 2043 :         case XML_RELAXNG_EMPTY:
; 2044 :             return ("empty");

	mov	eax, OFFSET ??_C@_05LBJMNBOG@empty@

; 2089 : }

	pop	ebp
	ret	0
$LN6@xmlRelaxNG:

; 2045 :         case XML_RELAXNG_NOT_ALLOWED:
; 2046 :             return ("notAllowed");

	mov	eax, OFFSET ??_C@_0L@GPGJMKBL@notAllowed@

; 2089 : }

	pop	ebp
	ret	0
$LN7@xmlRelaxNG:

; 2047 :         case XML_RELAXNG_EXCEPT:
; 2048 :             return ("except");

	mov	eax, OFFSET ??_C@_06JBKEBCGB@except@

; 2089 : }

	pop	ebp
	ret	0
$LN8@xmlRelaxNG:

; 2049 :         case XML_RELAXNG_TEXT:
; 2050 :             return ("text");

	mov	eax, OFFSET ??_C@_04CIMGMMMG@text@

; 2089 : }

	pop	ebp
	ret	0
$LN9@xmlRelaxNG:

; 2051 :         case XML_RELAXNG_ELEMENT:
; 2052 :             return ("element");

	mov	eax, OFFSET ??_C@_07HCLJNICE@element@

; 2089 : }

	pop	ebp
	ret	0
$LN10@xmlRelaxNG:

; 2053 :         case XML_RELAXNG_DATATYPE:
; 2054 :             return ("datatype");

	mov	eax, OFFSET ??_C@_08IJKJONLA@datatype@

; 2089 : }

	pop	ebp
	ret	0
$LN11@xmlRelaxNG:

; 2055 :         case XML_RELAXNG_VALUE:
; 2056 :             return ("value");

	mov	eax, OFFSET ??_C@_05MFEJDJP@value@

; 2089 : }

	pop	ebp
	ret	0
$LN12@xmlRelaxNG:

; 2057 :         case XML_RELAXNG_LIST:
; 2058 :             return ("list");

	mov	eax, OFFSET ??_C@_04DONFEANM@list@

; 2089 : }

	pop	ebp
	ret	0
$LN13@xmlRelaxNG:

; 2059 :         case XML_RELAXNG_ATTRIBUTE:
; 2060 :             return ("attribute");

	mov	eax, OFFSET ??_C@_09HGIEBAJ@attribute@

; 2089 : }

	pop	ebp
	ret	0
$LN14@xmlRelaxNG:

; 2061 :         case XML_RELAXNG_DEF:
; 2062 :             return ("def");

	mov	eax, OFFSET ??_C@_03BHEEIFFN@def@

; 2089 : }

	pop	ebp
	ret	0
$LN15@xmlRelaxNG:

; 2063 :         case XML_RELAXNG_REF:
; 2064 :             return ("ref");

	mov	eax, OFFSET ??_C@_03GCDGINBO@ref@

; 2089 : }

	pop	ebp
	ret	0
$LN16@xmlRelaxNG:

; 2065 :         case XML_RELAXNG_EXTERNALREF:
; 2066 :             return ("externalRef");

	mov	eax, OFFSET ??_C@_0M@CPEFJFBC@externalRef@

; 2089 : }

	pop	ebp
	ret	0
$LN17@xmlRelaxNG:

; 2067 :         case XML_RELAXNG_PARENTREF:
; 2068 :             return ("parentRef");

	mov	eax, OFFSET ??_C@_09LEMMFILP@parentRef@

; 2089 : }

	pop	ebp
	ret	0
$LN18@xmlRelaxNG:

; 2069 :         case XML_RELAXNG_OPTIONAL:
; 2070 :             return ("optional");

	mov	eax, OFFSET ??_C@_08EBGGHLAO@optional@

; 2089 : }

	pop	ebp
	ret	0
$LN19@xmlRelaxNG:

; 2071 :         case XML_RELAXNG_ZEROORMORE:
; 2072 :             return ("zeroOrMore");

	mov	eax, OFFSET ??_C@_0L@BANFCDDP@zeroOrMore@

; 2089 : }

	pop	ebp
	ret	0
$LN20@xmlRelaxNG:

; 2073 :         case XML_RELAXNG_ONEORMORE:
; 2074 :             return ("oneOrMore");

	mov	eax, OFFSET ??_C@_09EIEDMNLG@oneOrMore@

; 2089 : }

	pop	ebp
	ret	0
$LN21@xmlRelaxNG:

; 2075 :         case XML_RELAXNG_CHOICE:
; 2076 :             return ("choice");

	mov	eax, OFFSET ??_C@_06DDDNEJEA@choice@

; 2089 : }

	pop	ebp
	ret	0
$LN22@xmlRelaxNG:

; 2077 :         case XML_RELAXNG_GROUP:
; 2078 :             return ("group");

	mov	eax, OFFSET ??_C@_05MGJOOGAJ@group@

; 2089 : }

	pop	ebp
	ret	0
$LN23@xmlRelaxNG:

; 2079 :         case XML_RELAXNG_INTERLEAVE:
; 2080 :             return ("interleave");

	mov	eax, OFFSET ??_C@_0L@NLPEADBD@interleave@

; 2089 : }

	pop	ebp
	ret	0
$LN24@xmlRelaxNG:

; 2081 :         case XML_RELAXNG_START:
; 2082 :             return ("start");

	mov	eax, OFFSET ??_C@_05FAGFPHJG@start@

; 2089 : }

	pop	ebp
	ret	0
$LN25@xmlRelaxNG:

; 2083 :         case XML_RELAXNG_NOOP:
; 2084 :             return ("noop");

	mov	eax, OFFSET ??_C@_04BACONDHA@noop@

; 2089 : }

	pop	ebp
	ret	0
$LN26@xmlRelaxNG:

; 2085 :         case XML_RELAXNG_PARAM:
; 2086 :             return ("param");

	mov	eax, OFFSET ??_C@_05LJDNNBIK@param@

; 2089 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:

; 2087 :     }
; 2088 :     return ("unknown");

	mov	eax, OFFSET ??_C@_07CIFAGBMG@unknown@

; 2089 : }

	pop	ebp
	ret	0
	npad	1
$LN29@xmlRelaxNG:
	DD	$LN25@xmlRelaxNG
	DD	$LN5@xmlRelaxNG
	DD	$LN6@xmlRelaxNG
	DD	$LN7@xmlRelaxNG
	DD	$LN8@xmlRelaxNG
	DD	$LN9@xmlRelaxNG
	DD	$LN10@xmlRelaxNG
	DD	$LN26@xmlRelaxNG
	DD	$LN11@xmlRelaxNG
	DD	$LN12@xmlRelaxNG
	DD	$LN13@xmlRelaxNG
	DD	$LN14@xmlRelaxNG
	DD	$LN15@xmlRelaxNG
	DD	$LN16@xmlRelaxNG
	DD	$LN17@xmlRelaxNG
	DD	$LN18@xmlRelaxNG
	DD	$LN19@xmlRelaxNG
	DD	$LN20@xmlRelaxNG
	DD	$LN21@xmlRelaxNG
	DD	$LN22@xmlRelaxNG
	DD	$LN23@xmlRelaxNG
	DD	$LN24@xmlRelaxNG
_xmlRelaxNGDefName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGLoadExternalRef
_TEXT	SEGMENT
_root$1$ = 8						; size = 4
_doc$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_URL$ = 12						; size = 4
_ns$ = 16						; size = 4
_xmlRelaxNGLoadExternalRef PROC				; COMDAT

; 1949 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	mov	ebx, DWORD PTR _URL$[ebp]
	cmp	DWORD PTR [esi+100], edi
	jle	SHORT $LN3@xmlRelaxNG
	npad	3
$LL4@xmlRelaxNG:

; 1959 :         if (xmlStrEqual(ctxt->docTab[i]->href, URL)) {

	mov	eax, DWORD PTR [esi+108]
	push	ebx
	mov	eax, DWORD PTR [eax+edi*4]
	push	DWORD PTR [eax+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN62@xmlRelaxNG

; 1950 :     xmlRelaxNGDocumentPtr ret = NULL;
; 1951 :     xmlDocPtr doc;
; 1952 :     xmlNodePtr root;
; 1953 :     int i;
; 1954 : 
; 1955 :     /*
; 1956 :      * check against recursion in the stack
; 1957 :      */
; 1958 :     for (i = 0; i < ctxt->docNr; i++) {

	inc	edi
	cmp	edi, DWORD PTR [esi+100]
	jl	SHORT $LL4@xmlRelaxNG
$LN3@xmlRelaxNG:

; 1964 :         }
; 1965 :     }
; 1966 : 
; 1967 :     /*
; 1968 :      * load the document
; 1969 :      */
; 1970 :     doc = xmlReadFile((const char *) URL,NULL,0);

	push	0
	push	0
	push	ebx
	call	_xmlReadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _doc$1$[ebp], eax

; 1971 :     if (doc == NULL) {

	test	eax, eax
	jne	$LN6@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN21@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN21@xmlRelaxNG:

; 524  :         data = ctxt->userData;
; 525  :         ctxt->nbErrors++;
; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	ebx
	push	OFFSET ??_C@_0BP@BDBHMEOE@xmlRelaxNG?3?5could?5not?5load?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+36]
	push	ebx
	push	0
	push	0
	push	2
	push	1065					; 00000429H
	push	18					; 00000012H
	push	0
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 1972 :         xmlRngPErr(ctxt, NULL, XML_RNGP_PARSE_ERROR,
; 1973 :                    "xmlRelaxNG: could not load %s\n", URL, NULL);
; 1974 :         return (NULL);

	xor	eax, eax
	pop	edi

; 2023 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN62@xmlRelaxNG:

; 520  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	xor	eax, eax
	test	ecx, ecx
	jne	SHORT $LN16@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN16@xmlRelaxNG:

; 524  :         data = ctxt->userData;
; 525  :         ctxt->nbErrors++;
; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	ebx
	push	OFFSET ??_C@_0CK@BCCMNNOD@Detected?5an?5externalRef?5recursi@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+36]
	push	ebx
	push	0
	push	0
	push	2
	push	1033					; 00000409H
	push	18					; 00000012H
	push	0
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 1960 :             xmlRngPErr(ctxt, NULL, XML_RNGP_EXTERNALREF_RECURSE,
; 1961 :                        "Detected an externalRef recursion for %s\n", URL,
; 1962 :                        NULL);
; 1963 :             return (NULL);

	xor	eax, eax
	pop	edi

; 2023 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlRelaxNG:

; 1975 :     }
; 1976 : 
; 1977 :     /*
; 1978 :      * Allocate the document structures and register it first.
; 1979 :      */
; 1980 :     ret = (xmlRelaxNGDocumentPtr) xmlMalloc(sizeof(xmlRelaxNGDocument));

	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 1981 :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN7@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN26@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN26@xmlRelaxNG:

; 524  :         data = ctxt->userData;
; 525  :         ctxt->nbErrors++;
; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	ebx
	push	OFFSET ??_C@_0CI@PEJCGLNC@xmlRelaxNG?3?5allocate?5memory?5for@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+36]
	push	ebx
	mov	ebx, DWORD PTR _doc$1$[ebp]
	push	0
	push	0
	push	2
	push	2
	push	18					; 00000012H
	push	ebx
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError

; 1982 :         xmlRngPErr(ctxt, (xmlNodePtr) doc, XML_ERR_NO_MEMORY,
; 1983 :                    "xmlRelaxNG: allocate memory for doc %s\n", URL, NULL);
; 1984 :         xmlFreeDoc(doc);

	push	ebx
	call	_xmlFreeDoc
	add	esp, 76					; 0000004cH

; 1985 :         return (NULL);

	xor	eax, eax
	pop	edi

; 2023 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlRelaxNG:

; 1986 :     }
; 1987 :     memset(ret, 0, sizeof(xmlRelaxNGDocument));
; 1988 :     ret->doc = doc;

	mov	eax, DWORD PTR _doc$1$[ebp]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [edi], xmm0

; 1989 :     ret->href = xmlStrdup(URL);

	push	ebx
	movq	QWORD PTR [edi+16], xmm0
	mov	DWORD PTR [edi+8], eax
	call	_xmlStrdup

; 1990 :     ret->next = ctxt->documents;
; 1991 :     ret->externalRef = 1;
; 1992 :     ctxt->documents = ret;
; 1993 : 
; 1994 :     /*
; 1995 :      * transmit the ns if needed
; 1996 :      */
; 1997 :     if (ns != NULL) {

	mov	ebx, DWORD PTR _doc$1$[ebp]
	add	esp, 4
	cmp	DWORD PTR _ns$[ebp], 0
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+20], 1
	mov	DWORD PTR [esi+60], edi
	je	SHORT $LN10@xmlRelaxNG

; 1998 :         root = xmlDocGetRootElement(doc);

	push	ebx
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$1$[ebp], eax

; 1999 :         if (root != NULL) {

	test	eax, eax
	je	SHORT $LN10@xmlRelaxNG

; 2000 :             if (xmlHasProp(root, BAD_CAST "ns") == NULL) {

	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	eax
	call	_xmlHasProp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@xmlRelaxNG

; 2001 :                 xmlSetProp(root, BAD_CAST "ns", ns);

	push	DWORD PTR _ns$[ebp]
	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	DWORD PTR _root$1$[ebp]
	call	_xmlSetProp
	add	esp, 12					; 0000000cH
$LN10@xmlRelaxNG:

; 1882 :     if (ctxt->docTab == NULL) {

	mov	ecx, DWORD PTR [esi+108]
	test	ecx, ecx
	jne	SHORT $LN67@xmlRelaxNG

; 1883 :         ctxt->docMax = 4;
; 1884 :         ctxt->docNr = 0;
; 1885 :         ctxt->docTab =

	push	16					; 00000010H
	mov	DWORD PTR [esi+104], 4
	mov	DWORD PTR [esi+100], ecx
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [esi+108], ecx

; 1886 :             (xmlRelaxNGDocumentPtr *) xmlMalloc(ctxt->docMax *
; 1887 :                                                 sizeof(ctxt->docTab[0]));
; 1888 :         if (ctxt->docTab == NULL) {

	test	ecx, ecx
	jne	SHORT $LN67@xmlRelaxNG

; 445  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN37@xmlRelaxNG

; 446  : 	    schannel = ctxt->serror;
; 447  : 	else
; 448  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN37@xmlRelaxNG:

; 449  :         data = ctxt->userData;
; 450  :         ctxt->nbErrors++;
; 451  :     }
; 452  :     if (extra)
; 453  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BB@MHBNCBHM@adding?5document?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+36]
	push	OFFSET ??_C@_0BB@MHBNCBHM@adding?5document?6@
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1890 :             return (0);

	jmp	SHORT $LN28@xmlRelaxNG
$LN67@xmlRelaxNG:

; 1891 :         }
; 1892 :     }
; 1893 :     if (ctxt->docNr >= ctxt->docMax) {

	mov	eax, DWORD PTR [esi+100]
	mov	edx, DWORD PTR [esi+104]
	cmp	eax, edx
	jl	SHORT $LN32@xmlRelaxNG

; 1894 :         ctxt->docMax *= 2;

	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR [esi+104], eax

; 1895 :         ctxt->docTab =

	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR [esi+108], ecx

; 1896 :             (xmlRelaxNGDocumentPtr *) xmlRealloc(ctxt->docTab,
; 1897 :                                                  ctxt->docMax *
; 1898 :                                                  sizeof(ctxt->docTab[0]));
; 1899 :         if (ctxt->docTab == NULL) {

	test	ecx, ecx
	jne	SHORT $LN65@xmlRelaxNG

; 445  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN44@xmlRelaxNG

; 446  : 	    schannel = ctxt->serror;
; 447  : 	else
; 448  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN44@xmlRelaxNG:

; 449  :         data = ctxt->userData;
; 450  :         ctxt->nbErrors++;
; 451  :     }
; 452  :     if (extra)
; 453  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BB@MHBNCBHM@adding?5document?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+36]
	push	OFFSET ??_C@_0BB@MHBNCBHM@adding?5document?6@
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1901 :             return (0);

	jmp	SHORT $LN28@xmlRelaxNG
$LN65@xmlRelaxNG:
	mov	eax, DWORD PTR [esi+100]
$LN32@xmlRelaxNG:

; 1902 :         }
; 1903 :     }
; 1904 :     ctxt->docTab[ctxt->docNr] = value;

	mov	DWORD PTR [ecx+eax*4], edi

; 1905 :     ctxt->doc = value;
; 1906 :     return (ctxt->docNr++);

	inc	DWORD PTR [esi+100]
	mov	DWORD PTR [esi+96], edi
$LN28@xmlRelaxNG:

; 2002 :             }
; 2003 :         }
; 2004 :     }
; 2005 : 
; 2006 :     /*
; 2007 :      * push it on the stack and register it in the hash table
; 2008 :      */
; 2009 :     xmlRelaxNGDocumentPush(ctxt, ret);
; 2010 : 
; 2011 :     /*
; 2012 :      * Some preprocessing of the document content
; 2013 :      */
; 2014 :     doc = xmlRelaxNGCleanupDoc(ctxt, doc);

	push	ebx
	push	esi
	call	_xmlRelaxNGCleanupDoc
	add	esp, 8

; 2015 :     if (doc == NULL) {

	test	eax, eax
	jne	SHORT $LN11@xmlRelaxNG

; 2016 :         ctxt->doc = NULL;

	pop	edi
	mov	DWORD PTR [esi+96], eax

; 2023 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlRelaxNG:

; 1922 :     if (ctxt->docNr <= 0)

	mov	ecx, DWORD PTR [esi+100]
	test	ecx, ecx
	jle	SHORT $LN56@xmlRelaxNG

; 1923 :         return (NULL);
; 1924 :     ctxt->docNr--;

	dec	ecx
	mov	DWORD PTR [esi+100], ecx

; 1925 :     if (ctxt->docNr > 0)

	test	ecx, ecx
	jle	SHORT $LN58@xmlRelaxNG

; 1926 :         ctxt->doc = ctxt->docTab[ctxt->docNr - 1];

	mov	eax, DWORD PTR [esi+108]
	mov	eax, DWORD PTR [eax+ecx*4-4]

; 1929 :     ret = ctxt->docTab[ctxt->docNr];
; 1930 :     ctxt->docTab[ctxt->docNr] = NULL;

	mov	DWORD PTR [esi+96], eax
	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [eax+ecx*4], 0

; 2017 :         return (NULL);
; 2018 :     }
; 2019 : 
; 2020 :     xmlRelaxNGDocumentPop(ctxt);
; 2021 : 
; 2022 :     return (ret);

	mov	eax, edi
	pop	edi

; 2023 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN58@xmlRelaxNG:

; 1928 :         ctxt->doc = NULL;

	xor	eax, eax

; 1929 :     ret = ctxt->docTab[ctxt->docNr];
; 1930 :     ctxt->docTab[ctxt->docNr] = NULL;

	mov	DWORD PTR [esi+96], eax
	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [eax+ecx*4], 0
$LN56@xmlRelaxNG:

; 2017 :         return (NULL);
; 2018 :     }
; 2019 : 
; 2020 :     xmlRelaxNGDocumentPop(ctxt);
; 2021 : 
; 2022 :     return (ret);

	mov	eax, edi
	pop	edi

; 2023 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlRelaxNGLoadExternalRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGDocumentPop
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlRelaxNGDocumentPop PROC				; COMDAT

; 1919 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+100]
	test	ecx, ecx
	jg	SHORT $LN2@xmlRelaxNG

; 1920 :     xmlRelaxNGDocumentPtr ret;
; 1921 : 
; 1922 :     if (ctxt->docNr <= 0)
; 1923 :         return (NULL);

	xor	eax, eax

; 1932 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:

; 1924 :     ctxt->docNr--;

	dec	ecx
	mov	DWORD PTR [edx+100], ecx

; 1925 :     if (ctxt->docNr > 0)

	test	ecx, ecx
	jle	SHORT $LN3@xmlRelaxNG

; 1926 :         ctxt->doc = ctxt->docTab[ctxt->docNr - 1];

	mov	eax, DWORD PTR [edx+108]
	mov	eax, DWORD PTR [eax+ecx*4-4]

; 1929 :     ret = ctxt->docTab[ctxt->docNr];

	mov	DWORD PTR [edx+96], eax
	mov	eax, DWORD PTR [edx+108]
	mov	edx, DWORD PTR [eax+ecx*4]

; 1930 :     ctxt->docTab[ctxt->docNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 1931 :     return (ret);

	mov	eax, edx

; 1932 : }

	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 1927 :     else
; 1928 :         ctxt->doc = NULL;

	xor	eax, eax

; 1929 :     ret = ctxt->docTab[ctxt->docNr];

	mov	DWORD PTR [edx+96], eax
	mov	eax, DWORD PTR [edx+108]
	mov	edx, DWORD PTR [eax+ecx*4]

; 1930 :     ctxt->docTab[ctxt->docNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 1931 :     return (ret);

	mov	eax, edx

; 1932 : }

	pop	ebp
	ret	0
_xmlRelaxNGDocumentPop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGDocumentPush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlRelaxNGDocumentPush PROC				; COMDAT

; 1881 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi+108]
	test	ecx, ecx
	jne	SHORT $LN3@xmlRelaxNG

; 1882 :     if (ctxt->docTab == NULL) {
; 1883 :         ctxt->docMax = 4;

	push	16					; 00000010H
	mov	DWORD PTR [esi+104], 4

; 1884 :         ctxt->docNr = 0;

	mov	DWORD PTR [esi+100], ecx

; 1885 :         ctxt->docTab =

	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [esi+108], ecx

; 1886 :             (xmlRelaxNGDocumentPtr *) xmlMalloc(ctxt->docMax *
; 1887 :                                                 sizeof(ctxt->docTab[0]));
; 1888 :         if (ctxt->docTab == NULL) {

	test	ecx, ecx
	jne	SHORT $LN3@xmlRelaxNG

; 445  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN10@xmlRelaxNG

; 446  : 	    schannel = ctxt->serror;
; 447  : 	else
; 448  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN10@xmlRelaxNG:

; 449  :         data = ctxt->userData;
; 450  :         ctxt->nbErrors++;
; 451  :     }
; 452  :     if (extra)
; 453  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BB@MHBNCBHM@adding?5document?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+36]
	push	OFFSET ??_C@_0BB@MHBNCBHM@adding?5document?6@
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1889 :             xmlRngPErrMemory(ctxt, "adding document\n");
; 1890 :             return (0);

	xor	eax, eax
	pop	esi

; 1907 : }

	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 1891 :         }
; 1892 :     }
; 1893 :     if (ctxt->docNr >= ctxt->docMax) {

	mov	edx, DWORD PTR [esi+100]
	mov	eax, DWORD PTR [esi+104]
	cmp	edx, eax
	jl	SHORT $LN5@xmlRelaxNG

; 1894 :         ctxt->docMax *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+104], eax

; 1895 :         ctxt->docTab =

	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR [esi+108], ecx

; 1896 :             (xmlRelaxNGDocumentPtr *) xmlRealloc(ctxt->docTab,
; 1897 :                                                  ctxt->docMax *
; 1898 :                                                  sizeof(ctxt->docTab[0]));
; 1899 :         if (ctxt->docTab == NULL) {

	test	ecx, ecx
	jne	SHORT $LN21@xmlRelaxNG

; 445  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN17@xmlRelaxNG

; 446  : 	    schannel = ctxt->serror;
; 447  : 	else
; 448  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN17@xmlRelaxNG:

; 449  :         data = ctxt->userData;
; 450  :         ctxt->nbErrors++;
; 451  :     }
; 452  :     if (extra)
; 453  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BB@MHBNCBHM@adding?5document?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+36]
	push	OFFSET ??_C@_0BB@MHBNCBHM@adding?5document?6@
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1900 :             xmlRngPErrMemory(ctxt, "adding document\n");
; 1901 :             return (0);

	xor	eax, eax
	pop	esi

; 1907 : }

	pop	ebp
	ret	0
$LN21@xmlRelaxNG:
	mov	edx, DWORD PTR [esi+100]
$LN5@xmlRelaxNG:

; 1902 :         }
; 1903 :     }
; 1904 :     ctxt->docTab[ctxt->docNr] = value;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1905 :     ctxt->doc = value;

	mov	DWORD PTR [esi+96], eax

; 1906 :     return (ctxt->docNr++);

	mov	eax, DWORD PTR [esi+100]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+100], ecx
	pop	esi

; 1907 : }

	pop	ebp
	ret	0
_xmlRelaxNGDocumentPush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidErrorPop
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlRelaxNGValidErrorPop PROC				; COMDAT

; 1845 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+48]
	test	eax, eax
	jg	SHORT $LN2@xmlRelaxNG

; 1846 :     xmlRelaxNGValidErrorPtr cur;
; 1847 : 
; 1848 :     if (ctxt->errNr <= 0) {
; 1849 :         ctxt->err = NULL;

	mov	DWORD PTR [edx+44], 0

; 1866 :     }
; 1867 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:

; 1850 :         return;
; 1851 :     }
; 1852 :     ctxt->errNr--;

	dec	eax
	mov	DWORD PTR [edx+48], eax

; 1853 :     if (ctxt->errNr > 0)

	test	eax, eax
	jle	SHORT $LN3@xmlRelaxNG

; 1854 :         ctxt->err = &ctxt->errTab[ctxt->errNr - 1];

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edx+56]
	lea	eax, DWORD PTR [eax+ecx*8]
	add	eax, -24				; ffffffe8H
	jmp	SHORT $LN4@xmlRelaxNG
$LN3@xmlRelaxNG:

; 1855 :     else
; 1856 :         ctxt->err = NULL;

	xor	eax, eax
$LN4@xmlRelaxNG:

; 1857 :     cur = &ctxt->errTab[ctxt->errNr];

	mov	DWORD PTR [edx+44], eax
	mov	eax, DWORD PTR [edx+48]
	push	esi
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edx+56]

; 1858 :     if (cur->flags & ERROR_IS_DUP) {

	test	BYTE PTR [eax+ecx*8+4], 1
	lea	esi, DWORD PTR [eax+ecx*8]
	je	SHORT $LN9@xmlRelaxNG

; 1859 :         if (cur->arg1 != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG

; 1860 :             xmlFree((xmlChar *) cur->arg1);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlRelaxNG:

; 1861 :         cur->arg1 = NULL;
; 1862 :         if (cur->arg2 != NULL)

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+16], 0
	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG

; 1863 :             xmlFree((xmlChar *) cur->arg2);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlRelaxNG:

; 1864 :         cur->arg2 = NULL;

	mov	DWORD PTR [esi+20], 0

; 1865 :         cur->flags = 0;

	mov	DWORD PTR [esi+4], 0
$LN9@xmlRelaxNG:
	pop	esi

; 1866 :     }
; 1867 : }

	pop	ebp
	ret	0
_xmlRelaxNGValidErrorPop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidErrorPush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_err$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_dup$ = 24						; size = 4
_xmlRelaxNGValidErrorPush PROC				; COMDAT

; 1779 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR [esi+56]
	test	edx, edx
	jne	SHORT $LN28@xmlRelaxNG

; 1780 :     xmlRelaxNGValidErrorPtr cur;
; 1781 : 
; 1782 : #ifdef DEBUG_ERROR
; 1783 :     xmlGenericError(xmlGenericErrorContext,
; 1784 :                     "Pushing error %d at %d on stack\n", err, ctxt->errNr);
; 1785 : #endif
; 1786 :     if (ctxt->errTab == NULL) {
; 1787 :         ctxt->errMax = 8;

	push	192					; 000000c0H
	mov	DWORD PTR [esi+52], 8

; 1788 :         ctxt->errNr = 0;

	mov	DWORD PTR [esi+48], edx

; 1789 :         ctxt->errTab =

	call	DWORD PTR _xmlMalloc
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR [esi+56], edx

; 1790 :             (xmlRelaxNGValidErrorPtr) xmlMalloc(ctxt->errMax *
; 1791 :                                                 sizeof
; 1792 :                                                 (xmlRelaxNGValidError));
; 1793 :         if (ctxt->errTab == NULL) {

	test	edx, edx
	jne	SHORT $LN3@xmlRelaxNG

; 480  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN15@xmlRelaxNG

; 481  : 	    schannel = ctxt->serror;
; 482  : 	else
; 483  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN15@xmlRelaxNG:

; 484  :         data = ctxt->userData;
; 485  :         ctxt->nbErrors++;
; 486  :     }
; 487  :     if (extra)
; 488  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0P@JOLGCMKD@pushing?5error?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+16]
	push	OFFSET ??_C@_0P@JOLGCMKD@pushing?5error?6@
	push	0
	push	0
	push	3
	push	2
	push	19					; 00000013H
	push	0
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1794 :             xmlRngVErrMemory(ctxt, "pushing error\n");
; 1795 :             return (0);

	xor	eax, eax
	pop	esi

; 1835 : }

	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 1796 :         }
; 1797 :         ctxt->err = NULL;

	mov	DWORD PTR [esi+44], 0
$LN28@xmlRelaxNG:

; 1798 :     }
; 1799 :     if (ctxt->errNr >= ctxt->errMax) {

	mov	eax, DWORD PTR [esi+52]
	push	edi
	mov	edi, DWORD PTR [esi+48]
	cmp	edi, eax
	jl	SHORT $LN27@xmlRelaxNG

; 1800 :         ctxt->errMax *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+52], eax

; 1801 :         ctxt->errTab =

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 3
	push	eax
	push	edx
	call	DWORD PTR _xmlRealloc
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR [esi+56], edx

; 1802 :             (xmlRelaxNGValidErrorPtr) xmlRealloc(ctxt->errTab,
; 1803 :                                                  ctxt->errMax *
; 1804 :                                                  sizeof
; 1805 :                                                  (xmlRelaxNGValidError));
; 1806 :         if (ctxt->errTab == NULL) {

	test	edx, edx
	jne	SHORT $LN5@xmlRelaxNG

; 480  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN22@xmlRelaxNG

; 481  : 	    schannel = ctxt->serror;
; 482  : 	else
; 483  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN22@xmlRelaxNG:

; 484  :         data = ctxt->userData;
; 485  :         ctxt->nbErrors++;
; 486  :     }
; 487  :     if (extra)
; 488  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0P@JOLGCMKD@pushing?5error?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+16]
	push	OFFSET ??_C@_0P@JOLGCMKD@pushing?5error?6@
	push	0
	push	0
	push	3
	push	2
	push	19					; 00000013H
	push	0
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1807 :             xmlRngVErrMemory(ctxt, "pushing error\n");
; 1808 :             return (0);

	xor	eax, eax
	pop	edi
	pop	esi

; 1835 : }

	pop	ebp
	ret	0
$LN5@xmlRelaxNG:

; 1809 :         }
; 1810 :         ctxt->err = &ctxt->errTab[ctxt->errNr - 1];

	mov	edi, DWORD PTR [esi+48]
	lea	eax, DWORD PTR [edi-1]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	DWORD PTR [esi+44], eax
	jmp	SHORT $LN4@xmlRelaxNG
$LN27@xmlRelaxNG:
	mov	eax, DWORD PTR [esi+44]
$LN4@xmlRelaxNG:
	push	ebx

; 1811 :     }
; 1812 :     if ((ctxt->err != NULL) && (ctxt->state != NULL) &&
; 1813 :         (ctxt->err->node == ctxt->state->node) && (ctxt->err->err == err))

	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG
	mov	ebx, DWORD PTR [esi+60]
	test	ebx, ebx
	je	SHORT $LN6@xmlRelaxNG
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR [ebx]
	jne	SHORT $LN6@xmlRelaxNG
	mov	ecx, DWORD PTR _err$[ebp]
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN6@xmlRelaxNG

; 1814 :         return (ctxt->errNr);

	pop	ebx
	mov	eax, edi
	pop	edi
	pop	esi

; 1835 : }

	pop	ebp
	ret	0
$LN6@xmlRelaxNG:

; 1815 :     cur = &ctxt->errTab[ctxt->errNr];
; 1816 :     cur->err = err;
; 1817 :     if (dup) {

	cmp	DWORD PTR _dup$[ebp], 0
	lea	eax, DWORD PTR [edi+edi*2]
	lea	edi, DWORD PTR [edx+eax*8]
	mov	eax, DWORD PTR _err$[ebp]
	mov	DWORD PTR [edi], eax
	je	SHORT $LN7@xmlRelaxNG

; 1818 :         cur->arg1 = xmlStrdup(arg1);

	push	DWORD PTR _arg1$[ebp]
	call	_xmlStrdup

; 1819 :         cur->arg2 = xmlStrdup(arg2);

	push	DWORD PTR _arg2$[ebp]
	mov	DWORD PTR [edi+16], eax
	call	_xmlStrdup
	add	esp, 8

; 1820 :         cur->flags = ERROR_IS_DUP;

	mov	ecx, 1

; 1821 :     } else {

	jmp	SHORT $LN8@xmlRelaxNG
$LN7@xmlRelaxNG:

; 1822 :         cur->arg1 = arg1;

	mov	eax, DWORD PTR _arg1$[ebp]

; 1823 :         cur->arg2 = arg2;
; 1824 :         cur->flags = 0;

	xor	ecx, ecx
	mov	DWORD PTR [edi+16], eax
	mov	eax, DWORD PTR _arg2$[ebp]
$LN8@xmlRelaxNG:

; 1825 :     }
; 1826 :     if (ctxt->state != NULL) {

	mov	DWORD PTR [edi+4], ecx
	mov	DWORD PTR [edi+20], eax
	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN9@xmlRelaxNG

; 1827 :         cur->node = ctxt->state->node;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edi+8], eax

; 1828 :         cur->seq = ctxt->state->seq;

	mov	eax, DWORD PTR [esi+60]
	pop	ebx
	mov	eax, DWORD PTR [eax+4]

; 1832 :     }
; 1833 :     ctxt->err = cur;

	mov	DWORD PTR [edi+12], eax

; 1834 :     return (ctxt->errNr++);

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+44], edi
	pop	edi
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+48], ecx
	pop	esi

; 1835 : }

	pop	ebp
	ret	0
$LN9@xmlRelaxNG:

; 1829 :     } else {
; 1830 :         cur->node = NULL;

	mov	DWORD PTR [edi+8], 0

; 1831 :         cur->seq = NULL;

	xor	eax, eax

; 1832 :     }
; 1833 :     ctxt->err = cur;

	mov	DWORD PTR [edi+12], eax

; 1834 :     return (ctxt->errNr++);

	mov	eax, DWORD PTR [esi+48]
	pop	ebx
	mov	DWORD PTR [esi+44], edi
	pop	edi
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+48], ecx
	pop	esi

; 1835 : }

	pop	ebp
	ret	0
_xmlRelaxNGValidErrorPush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGLoadInclude
_TEXT	SEGMENT
_root$2$ = -8						; size = 4
_ret$1$ = -4						; size = 4
_name$1$ = 8						; size = 4
_root$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_URL$ = 12						; size = 4
_node$ = 16						; size = 4
_ns$ = 20						; size = 4
_xmlRelaxNGLoadInclude PROC				; COMDAT

; 1601 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	mov	ebx, DWORD PTR _URL$[ebp]
	cmp	DWORD PTR [edi+116], esi
	jle	SHORT $LN3@xmlRelaxNG
$LL4@xmlRelaxNG:

; 1616 :         if (xmlStrEqual(ctxt->incTab[i]->href, URL)) {

	mov	eax, DWORD PTR [edi+124]
	push	ebx
	mov	eax, DWORD PTR [eax+esi*4]
	push	DWORD PTR [eax+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN86@xmlRelaxNG

; 1602 :     xmlRelaxNGIncludePtr ret = NULL;
; 1603 :     xmlDocPtr doc;
; 1604 :     int i;
; 1605 :     xmlNodePtr root, cur;
; 1606 : 
; 1607 : #ifdef DEBUG_INCLUDE
; 1608 :     xmlGenericError(xmlGenericErrorContext,
; 1609 :                     "xmlRelaxNGLoadInclude(%s)\n", URL);
; 1610 : #endif
; 1611 : 
; 1612 :     /*
; 1613 :      * check against recursion in the stack
; 1614 :      */
; 1615 :     for (i = 0; i < ctxt->incNr; i++) {

	inc	esi
	cmp	esi, DWORD PTR [edi+116]
	jl	SHORT $LL4@xmlRelaxNG
$LN3@xmlRelaxNG:

; 1617 :             xmlRngPErr(ctxt, NULL, XML_RNGP_INCLUDE_RECURSE,
; 1618 :                        "Detected an Include recursion for %s\n", URL,
; 1619 :                        NULL);
; 1620 :             return (NULL);
; 1621 :         }
; 1622 :     }
; 1623 : 
; 1624 :     /*
; 1625 :      * load the document
; 1626 :      */
; 1627 :     doc = xmlReadFile((const char *) URL,NULL,0);

	push	0
	push	0
	push	ebx
	call	_xmlReadFile
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 1628 :     if (doc == NULL) {

	test	esi, esi
	jne	$LN10@xmlRelaxNG

; 520  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [edi+12]
	test	ecx, ecx
	jne	SHORT $LN41@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [edi+4]
$LN41@xmlRelaxNG:

; 524  :         data = ctxt->userData;
; 525  :         ctxt->nbErrors++;
; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	ebx
	push	OFFSET ??_C@_0BP@BDBHMEOE@xmlRelaxNG?3?5could?5not?5load?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [edi+36]
	push	ebx
	push	0
	push	0
	push	2
	push	1065					; 00000429H
	push	18					; 00000012H
	push	DWORD PTR _node$[ebp]
	push	0
	push	DWORD PTR [edi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 1761 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN86@xmlRelaxNG:

; 520  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [edi+12]
	xor	eax, eax
	test	ecx, ecx
	jne	SHORT $LN36@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [edi+4]
$LN36@xmlRelaxNG:

; 524  :         data = ctxt->userData;
; 525  :         ctxt->nbErrors++;
; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	ebx
	push	OFFSET ??_C@_0CG@MLBLJJIG@Detected?5an?5Include?5recursion?5f@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [edi+36]
	push	ebx
	push	0
	push	0
	push	2
	push	1044					; 00000414H
	push	18					; 00000012H
	push	0
	push	0
	push	DWORD PTR [edi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 1761 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlRelaxNG:

; 1629 :         xmlRngPErr(ctxt, node, XML_RNGP_PARSE_ERROR,
; 1630 :                    "xmlRelaxNG: could not load %s\n", URL, NULL);
; 1631 :         return (NULL);
; 1632 :     }
; 1633 : #ifdef DEBUG_INCLUDE
; 1634 :     xmlGenericError(xmlGenericErrorContext, "Parsed %s Okay\n", URL);
; 1635 : #endif
; 1636 : 
; 1637 :     /*
; 1638 :      * Allocate the document structures and register it first.
; 1639 :      */
; 1640 :     ret = (xmlRelaxNGIncludePtr) xmlMalloc(sizeof(xmlRelaxNGInclude));

	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _ret$1$[ebp], eax

; 1641 :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN11@xmlRelaxNG

; 445  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [edi+12]
	test	ecx, ecx
	jne	SHORT $LN46@xmlRelaxNG

; 446  : 	    schannel = ctxt->serror;
; 447  : 	else
; 448  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [edi+4]
$LN46@xmlRelaxNG:

; 449  :         data = ctxt->userData;
; 450  :         ctxt->nbErrors++;
; 451  :     }
; 452  :     if (extra)
; 453  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BE@NICNHGJN@allocating?5include?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [edi+36]
	push	OFFSET ??_C@_0BE@NICNHGJN@allocating?5include?6@
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	DWORD PTR [edi]
	push	eax
	push	ecx
	call	___xmlRaiseError

; 1642 :         xmlRngPErrMemory(ctxt, "allocating include\n");
; 1643 :         xmlFreeDoc(doc);

	push	esi
	call	_xmlFreeDoc
	add	esp, 72					; 00000048H

; 1761 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlRelaxNG:

; 1644 :         return (NULL);
; 1645 :     }
; 1646 :     memset(ret, 0, sizeof(xmlRelaxNGInclude));

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0

; 1647 :     ret->doc = doc;
; 1648 :     ret->href = xmlStrdup(URL);

	push	ebx
	mov	DWORD PTR [eax+8], esi
	call	_xmlStrdup
	mov	ecx, DWORD PTR _ret$1$[ebp]
	add	esp, 4

; 1649 :     ret->next = ctxt->includes;
; 1650 :     ctxt->includes = ret;
; 1651 : 
; 1652 :     /*
; 1653 :      * transmit the ns if needed
; 1654 :      */
; 1655 :     if (ns != NULL) {

	cmp	DWORD PTR _ns$[ebp], 0
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edi+64]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [edi+64], ecx
	je	SHORT $LN14@xmlRelaxNG

; 1656 :         root = xmlDocGetRootElement(doc);

	push	esi
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$1$[ebp], eax

; 1657 :         if (root != NULL) {

	test	eax, eax
	je	SHORT $LN14@xmlRelaxNG

; 1658 :             if (xmlHasProp(root, BAD_CAST "ns") == NULL) {

	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	eax
	call	_xmlHasProp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlRelaxNG

; 1659 :                 xmlSetProp(root, BAD_CAST "ns", ns);

	push	DWORD PTR _ns$[ebp]
	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	DWORD PTR _root$1$[ebp]
	call	_xmlSetProp
	add	esp, 12					; 0000000cH
$LN14@xmlRelaxNG:

; 1454 :     if (ctxt->incTab == NULL) {

	mov	ecx, DWORD PTR [edi+124]
	test	ecx, ecx
	jne	SHORT $LN97@xmlRelaxNG

; 1455 :         ctxt->incMax = 4;
; 1456 :         ctxt->incNr = 0;
; 1457 :         ctxt->incTab =

	push	16					; 00000010H
	mov	DWORD PTR [edi+120], 4
	mov	DWORD PTR [edi+116], ecx
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [edi+124], ecx

; 1458 :             (xmlRelaxNGIncludePtr *) xmlMalloc(ctxt->incMax *
; 1459 :                                                sizeof(ctxt->incTab[0]));
; 1460 :         if (ctxt->incTab == NULL) {

	test	ecx, ecx
	jne	SHORT $LN97@xmlRelaxNG

; 445  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [edi+12]
	test	ecx, ecx
	jne	SHORT $LN59@xmlRelaxNG

; 446  : 	    schannel = ctxt->serror;
; 447  : 	else
; 448  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [edi+4]
$LN59@xmlRelaxNG:

; 449  :         data = ctxt->userData;
; 450  :         ctxt->nbErrors++;
; 451  :     }
; 452  :     if (extra)
; 453  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BE@NICNHGJN@allocating?5include?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [edi+36]
	push	OFFSET ??_C@_0BE@NICNHGJN@allocating?5include?6@
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	DWORD PTR [edi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1462 :             return (0);

	jmp	SHORT $LN50@xmlRelaxNG
$LN97@xmlRelaxNG:

; 1463 :         }
; 1464 :     }
; 1465 :     if (ctxt->incNr >= ctxt->incMax) {

	mov	eax, DWORD PTR [edi+116]
	mov	edx, DWORD PTR [edi+120]
	cmp	eax, edx
	jl	SHORT $LN54@xmlRelaxNG

; 1466 :         ctxt->incMax *= 2;

	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR [edi+120], eax

; 1467 :         ctxt->incTab =

	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR [edi+124], ecx

; 1468 :             (xmlRelaxNGIncludePtr *) xmlRealloc(ctxt->incTab,
; 1469 :                                                 ctxt->incMax *
; 1470 :                                                 sizeof(ctxt->incTab[0]));
; 1471 :         if (ctxt->incTab == NULL) {

	test	ecx, ecx
	jne	SHORT $LN92@xmlRelaxNG

; 445  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [edi+12]
	test	ecx, ecx
	jne	SHORT $LN66@xmlRelaxNG

; 446  : 	    schannel = ctxt->serror;
; 447  : 	else
; 448  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [edi+4]
$LN66@xmlRelaxNG:

; 449  :         data = ctxt->userData;
; 450  :         ctxt->nbErrors++;
; 451  :     }
; 452  :     if (extra)
; 453  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BE@NICNHGJN@allocating?5include?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [edi+36]
	push	OFFSET ??_C@_0BE@NICNHGJN@allocating?5include?6@
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	DWORD PTR [edi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1473 :             return (0);

	jmp	SHORT $LN50@xmlRelaxNG
$LN92@xmlRelaxNG:
	mov	eax, DWORD PTR [edi+116]
$LN54@xmlRelaxNG:

; 1474 :         }
; 1475 :     }
; 1476 :     ctxt->incTab[ctxt->incNr] = value;

	mov	edx, DWORD PTR _ret$1$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 1477 :     ctxt->inc = value;
; 1478 :     return (ctxt->incNr++);

	inc	DWORD PTR [edi+116]
	mov	DWORD PTR [edi+112], edx
$LN50@xmlRelaxNG:

; 1660 :             }
; 1661 :         }
; 1662 :     }
; 1663 : 
; 1664 :     /*
; 1665 :      * push it on the stack
; 1666 :      */
; 1667 :     xmlRelaxNGIncludePush(ctxt, ret);
; 1668 : 
; 1669 :     /*
; 1670 :      * Some preprocessing of the document content, this include recursing
; 1671 :      * in the include stack.
; 1672 :      */
; 1673 : #ifdef DEBUG_INCLUDE
; 1674 :     xmlGenericError(xmlGenericErrorContext, "cleanup of %s\n", URL);
; 1675 : #endif
; 1676 : 
; 1677 :     doc = xmlRelaxNGCleanupDoc(ctxt, doc);

	push	esi
	push	edi
	call	_xmlRelaxNGCleanupDoc
	mov	edx, eax
	add	esp, 8

; 1678 :     if (doc == NULL) {

	test	edx, edx
	jne	SHORT $LN15@xmlRelaxNG

; 1679 :         ctxt->inc = NULL;

	mov	DWORD PTR [edi+112], eax
	pop	edi

; 1761 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlRelaxNG:

; 1494 :     if (ctxt->incNr <= 0)

	mov	ecx, DWORD PTR [edi+116]
	test	ecx, ecx
	jle	SHORT $LN78@xmlRelaxNG

; 1495 :         return (NULL);
; 1496 :     ctxt->incNr--;

	dec	ecx
	mov	DWORD PTR [edi+116], ecx

; 1497 :     if (ctxt->incNr > 0)

	test	ecx, ecx
	jle	SHORT $LN80@xmlRelaxNG

; 1498 :         ctxt->inc = ctxt->incTab[ctxt->incNr - 1];

	mov	eax, DWORD PTR [edi+124]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN81@xmlRelaxNG
$LN80@xmlRelaxNG:

; 1499 :     else
; 1500 :         ctxt->inc = NULL;

	xor	eax, eax
$LN81@xmlRelaxNG:

; 1501 :     ret = ctxt->incTab[ctxt->incNr];
; 1502 :     ctxt->incTab[ctxt->incNr] = NULL;

	mov	DWORD PTR [edi+112], eax
	mov	eax, DWORD PTR [edi+124]
	mov	DWORD PTR [eax+ecx*4], 0
$LN78@xmlRelaxNG:

; 1680 :         return (NULL);
; 1681 :     }
; 1682 : 
; 1683 :     /*
; 1684 :      * Pop up the include from the stack
; 1685 :      */
; 1686 :     xmlRelaxNGIncludePop(ctxt);
; 1687 : 
; 1688 : #ifdef DEBUG_INCLUDE
; 1689 :     xmlGenericError(xmlGenericErrorContext, "Checking of %s\n", URL);
; 1690 : #endif
; 1691 :     /*
; 1692 :      * Check that the top element is a grammar
; 1693 :      */
; 1694 :     root = xmlDocGetRootElement(doc);

	push	edx
	call	_xmlDocGetRootElement
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _root$2$[ebp], esi

; 1695 :     if (root == NULL) {

	test	esi, esi
	jne	SHORT $LN16@xmlRelaxNG

; 1696 :         xmlRngPErr(ctxt, node, XML_RNGP_EMPTY,

	push	eax
	push	ebx
	push	OFFSET ??_C@_0CL@MDFAGPKO@xmlRelaxNG?3?5included?5document?5i@
	push	1022					; 000003feH

; 1697 :                    "xmlRelaxNG: included document is empty %s\n", URL,
; 1698 :                    NULL);
; 1699 :         return (NULL);

	jmp	$LN101@xmlRelaxNG
$LN16@xmlRelaxNG:

; 1700 :     }
; 1701 :     if (!IS_RELAXNG(root, "grammar")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN18@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	$LN18@xmlRelaxNG
	push	OFFSET ??_C@_07EFOLCII@grammar@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN18@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN18@xmlRelaxNG

; 1703 :                    "xmlRelaxNG: included document %s root is not a grammar\n",
; 1704 :                    URL, NULL);
; 1705 :         return (NULL);
; 1706 :     }
; 1707 : 
; 1708 :     /*
; 1709 :      * Elimination of redefined rules in the include.
; 1710 :      */
; 1711 :     cur = node->children;

	mov	ebx, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [ebx+12]

; 1712 :     while (cur != NULL) {

	test	esi, esi
	je	$LN99@xmlRelaxNG
$LL5@xmlRelaxNG:

; 1713 :         if (IS_RELAXNG(cur, "start")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN26@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN19@xmlRelaxNG
	push	OFFSET ??_C@_05FAGFPHJG@start@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@xmlRelaxNG

; 1714 :             int found = 0;
; 1715 : 
; 1716 :             found =

	mov	eax, DWORD PTR _root$2$[ebp]
	push	0
	push	DWORD PTR [eax+12]
	push	DWORD PTR _URL$[ebp]
	push	edi
	call	_xmlRelaxNGRemoveRedefine
	add	esp, 16					; 00000010H

; 1717 :                 xmlRelaxNGRemoveRedefine(ctxt, URL, root->children, NULL);
; 1718 :             if (!found) {

	test	eax, eax
	jne	$LN24@xmlRelaxNG

; 1719 :                 xmlRngPErr(ctxt, node, XML_RNGP_START_MISSING,

	push	eax
	push	DWORD PTR _URL$[ebp]
	push	OFFSET ??_C@_0EB@LAOLKJIK@xmlRelaxNG?3?5include?5?$CFs?5has?5a?5st@
	push	1107					; 00000453H
	push	ebx
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 1720 :                            "xmlRelaxNG: include %s has a start but not the included grammar\n",
; 1721 :                            URL, NULL);
; 1722 :             }

	jmp	$LN24@xmlRelaxNG
$LN19@xmlRelaxNG:

; 1723 :         } else if (IS_RELAXNG(cur, "define")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN26@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	$LN24@xmlRelaxNG
	push	OFFSET ??_C@_06EPMMJFDC@define@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN24@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@xmlRelaxNG

; 1724 :             xmlChar *name;
; 1725 : 
; 1726 :             name = xmlGetProp(cur, BAD_CAST "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	esi
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _name$1$[ebp], eax

; 1727 :             if (name == NULL) {

	test	eax, eax
	jne	SHORT $LN23@xmlRelaxNG

; 1728 :                 xmlRngPErr(ctxt, node, XML_RNGP_NAME_MISSING,

	push	eax
	push	DWORD PTR _URL$[ebp]
	push	OFFSET ??_C@_0DA@OCDIDEDL@xmlRelaxNG?3?5include?5?$CFs?5has?5defi@
	push	1053					; 0000041dH
	push	ebx
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 1729 :                            "xmlRelaxNG: include %s has define without name\n",
; 1730 :                            URL, NULL);
; 1731 :             } else {

	jmp	SHORT $LN24@xmlRelaxNG
$LN23@xmlRelaxNG:

; 1732 :                 int found;
; 1733 : 
; 1734 :                 xmlRelaxNGNormExtSpace(name);

	push	eax
	call	_xmlRelaxNGNormExtSpace

; 1735 :                 found = xmlRelaxNGRemoveRedefine(ctxt, URL,

	mov	eax, DWORD PTR _root$2$[ebp]
	push	DWORD PTR _name$1$[ebp]
	push	DWORD PTR [eax+12]
	push	DWORD PTR _URL$[ebp]
	push	edi
	call	_xmlRelaxNGRemoveRedefine
	add	esp, 20					; 00000014H

; 1736 :                                                  root->children, name);
; 1737 :                 if (!found) {

	test	eax, eax
	jne	SHORT $LN25@xmlRelaxNG

; 1738 :                     xmlRngPErr(ctxt, node, XML_RNGP_DEFINE_MISSING,

	push	DWORD PTR _name$1$[ebp]
	push	DWORD PTR _URL$[ebp]
	push	OFFSET ??_C@_0EF@PNICLKOF@xmlRelaxNG?3?5include?5?$CFs?5has?5a?5de@
	push	1013					; 000003f5H
	push	ebx
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
$LN25@xmlRelaxNG:

; 1739 :                                "xmlRelaxNG: include %s has a define %s but not the included grammar\n",
; 1740 :                                URL, name);
; 1741 :                 }
; 1742 :                 xmlFree(name);

	push	DWORD PTR _name$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN24@xmlRelaxNG:

; 1743 :             }
; 1744 :         }
; 1745 :         if (IS_RELAXNG(cur, "div") && cur->children != NULL) {

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN26@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN26@xmlRelaxNG
	push	OFFSET ??_C@_03FEJMGOGI@div@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN26@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN26@xmlRelaxNG
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN26@xmlRelaxNG

; 1746 :             cur = cur->children;

	mov	esi, eax

; 1747 :         } else {

	jmp	SHORT $LN32@xmlRelaxNG
$LN26@xmlRelaxNG:

; 1748 :             if (cur->next != NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN85@xmlRelaxNG

; 1749 :                 cur = cur->next;

	mov	esi, eax

; 1750 :             } else {

	jmp	SHORT $LN32@xmlRelaxNG
$LN85@xmlRelaxNG:

; 1751 :                 while (cur->parent != node && cur->parent->next == NULL) {

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, ebx
	je	SHORT $LN98@xmlRelaxNG
$LL7@xmlRelaxNG:
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN98@xmlRelaxNG

; 1752 :                     cur = cur->parent;

	mov	esi, eax
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, ebx
	jne	SHORT $LL7@xmlRelaxNG
$LN98@xmlRelaxNG:

; 1753 :                 }
; 1754 :                 cur = cur->parent != node ? cur->parent->next : NULL;

	mov	esi, DWORD PTR [esi+20]
	cmp	esi, ebx
	je	SHORT $LN99@xmlRelaxNG
	mov	esi, DWORD PTR [esi+24]
$LN32@xmlRelaxNG:

; 1712 :     while (cur != NULL) {

	test	esi, esi
	jne	$LL5@xmlRelaxNG
$LN99@xmlRelaxNG:

; 1755 :             }
; 1756 :         }
; 1757 :     }
; 1758 : 
; 1759 : 
; 1760 :     return (ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 1761 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlRelaxNG:

; 1702 :         xmlRngPErr(ctxt, node, XML_RNGP_GRAMMAR_MISSING,

	push	0
	push	ebx
	push	OFFSET ??_C@_0DI@NNDELAMP@xmlRelaxNG?3?5included?5document?5?$CF@
	push	1038					; 0000040eH
$LN101@xmlRelaxNG:

; 1761 : }

	push	DWORD PTR _node$[ebp]
	push	edi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGLoadInclude ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGRemoveRedefine
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_URL$ = 12						; size = 4
_tmp2$1$ = 16						; size = 4
_target$ = 16						; size = 4
_name$ = 20						; size = 4
_xmlRelaxNGRemoveRedefine PROC				; COMDAT

; 1521 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _target$[ebp]
	xor	edi, edi
	test	esi, esi
	je	$LN21@xmlRelaxNG
	push	ebx
	npad	3
$LL2@xmlRelaxNG:

; 1522 :     int found = 0;
; 1523 :     xmlNodePtr tmp, tmp2;
; 1524 :     xmlChar *name2;
; 1525 : 
; 1526 : #ifdef DEBUG_INCLUDE
; 1527 :     if (name == NULL)
; 1528 :         xmlGenericError(xmlGenericErrorContext,
; 1529 :                         "Elimination of <include> start from %s\n", URL);
; 1530 :     else
; 1531 :         xmlGenericError(xmlGenericErrorContext,
; 1532 :                         "Elimination of <include> define %s from %s\n",
; 1533 :                         name, URL);
; 1534 : #endif
; 1535 :     tmp = target;
; 1536 :     while (tmp != NULL) {
; 1537 :         tmp2 = tmp->next;
; 1538 :         if ((name == NULL) && (IS_RELAXNG(tmp, "start"))) {

	cmp	DWORD PTR _name$[ebp], 0
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _tmp2$1$[ebp], eax
	mov	eax, DWORD PTR [esi+36]
	jne	SHORT $LN20@xmlRelaxNG
	test	eax, eax
	je	$LN6@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	$LN6@xmlRelaxNG
	push	OFFSET ??_C@_05FAGFPHJG@start@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN6@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN6@xmlRelaxNG

; 1539 :             found = 1;
; 1540 :             xmlUnlinkNode(tmp);

	push	esi
	mov	edi, 1
	call	_xmlUnlinkNode

; 1541 :             xmlFreeNode(tmp);

	push	esi
	call	_xmlFreeNode
	add	esp, 8
	jmp	$LN14@xmlRelaxNG
$LN20@xmlRelaxNG:

; 1542 :         } else if ((name != NULL) && (IS_RELAXNG(tmp, "define"))) {

	test	eax, eax
	je	$LN6@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN6@xmlRelaxNG
	push	OFFSET ??_C@_06EPMMJFDC@define@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG

; 1543 :             name2 = xmlGetProp(tmp, BAD_CAST "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	esi
	call	_xmlGetProp
	mov	ebx, eax

; 1544 :             xmlRelaxNGNormExtSpace(name2);

	push	ebx
	call	_xmlRelaxNGNormExtSpace
	add	esp, 12					; 0000000cH

; 1545 :             if (name2 != NULL) {

	test	ebx, ebx
	je	$LN14@xmlRelaxNG

; 1546 :                 if (xmlStrEqual(name, name2)) {

	mov	eax, DWORD PTR _name$[ebp]
	push	ebx
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlRelaxNG

; 1547 :                     found = 1;
; 1548 :                     xmlUnlinkNode(tmp);

	push	esi
	mov	edi, 1
	call	_xmlUnlinkNode

; 1549 :                     xmlFreeNode(tmp);

	push	esi
	call	_xmlFreeNode
	add	esp, 8
$LN9@xmlRelaxNG:

; 1550 :                 }
; 1551 :                 xmlFree(name2);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1552 :             }

	jmp	$LN14@xmlRelaxNG
$LN6@xmlRelaxNG:

; 1553 :         } else if (IS_RELAXNG(tmp, "include")) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN14@xmlRelaxNG
	cmp	DWORD PTR [esi+4], 1
	jne	$LN14@xmlRelaxNG
	push	OFFSET ??_C@_07FHOHOHLG@include@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN14@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlRelaxNGNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlRelaxNG

; 1554 :             xmlChar *href = NULL;
; 1555 :             xmlRelaxNGDocumentPtr inc = tmp->psvi;

	mov	ebx, DWORD PTR [esi+52]

; 1556 : 
; 1557 :             if ((inc != NULL) && (inc->doc != NULL) &&

	test	ebx, ebx
	je	SHORT $LN13@xmlRelaxNG
	mov	eax, DWORD PTR [ebx+8]
	test	eax, eax
	je	SHORT $LN13@xmlRelaxNG
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN13@xmlRelaxNG

; 1558 :                 (inc->doc->children != NULL)) {
; 1559 : 
; 1560 :                 if (xmlStrEqual
; 1561 :                     (inc->doc->children->name, BAD_CAST "grammar")) {

	push	OFFSET ??_C@_07EFOLCII@grammar@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlRelaxNG

; 1562 : #ifdef DEBUG_INCLUDE
; 1563 :                     href = xmlGetProp(tmp, BAD_CAST "href");
; 1564 : #endif
; 1565 :                     if (xmlRelaxNGRemoveRedefine(ctxt, href,
; 1566 :                                                  xmlDocGetRootElement(inc->doc)->children,
; 1567 :                                                  name) == 1) {

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	DWORD PTR [ebx+8]
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	eax, DWORD PTR [eax+12]
	push	eax
	push	0
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGRemoveRedefine
	add	esp, 16					; 00000010H
	cmp	eax, 1
	mov	eax, 1
	cmove	edi, eax
$LN13@xmlRelaxNG:

; 1568 :                         found = 1;
; 1569 :                     }
; 1570 : #ifdef DEBUG_INCLUDE
; 1571 :                     if (href != NULL)
; 1572 :                         xmlFree(href);
; 1573 : #endif
; 1574 :                 }
; 1575 :             }
; 1576 :             if (xmlRelaxNGRemoveRedefine(ctxt, URL, tmp->children, name) == 1) {

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [esi+12]
	push	DWORD PTR _URL$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGRemoveRedefine
	add	esp, 16					; 00000010H
	cmp	eax, 1
	mov	eax, 1
	cmove	edi, eax
$LN14@xmlRelaxNG:

; 1577 :                 found = 1;
; 1578 :             }
; 1579 :         }
; 1580 :         tmp = tmp2;

	mov	eax, DWORD PTR _tmp2$1$[ebp]
	mov	esi, eax
	test	eax, eax
	jne	$LL2@xmlRelaxNG

; 1581 :     }
; 1582 :     return (found);

	pop	ebx
$LN21@xmlRelaxNG:

; 1583 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlRelaxNGRemoveRedefine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGIncludePop
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlRelaxNGIncludePop PROC				; COMDAT

; 1491 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+116]
	test	ecx, ecx
	jg	SHORT $LN2@xmlRelaxNG

; 1492 :     xmlRelaxNGIncludePtr ret;
; 1493 : 
; 1494 :     if (ctxt->incNr <= 0)
; 1495 :         return (NULL);

	xor	eax, eax

; 1504 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:

; 1496 :     ctxt->incNr--;

	dec	ecx
	mov	DWORD PTR [edx+116], ecx

; 1497 :     if (ctxt->incNr > 0)

	test	ecx, ecx
	jle	SHORT $LN3@xmlRelaxNG

; 1498 :         ctxt->inc = ctxt->incTab[ctxt->incNr - 1];

	mov	eax, DWORD PTR [edx+124]
	mov	eax, DWORD PTR [eax+ecx*4-4]

; 1501 :     ret = ctxt->incTab[ctxt->incNr];

	mov	DWORD PTR [edx+112], eax
	mov	eax, DWORD PTR [edx+124]
	mov	edx, DWORD PTR [eax+ecx*4]

; 1502 :     ctxt->incTab[ctxt->incNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 1503 :     return (ret);

	mov	eax, edx

; 1504 : }

	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 1499 :     else
; 1500 :         ctxt->inc = NULL;

	xor	eax, eax

; 1501 :     ret = ctxt->incTab[ctxt->incNr];

	mov	DWORD PTR [edx+112], eax
	mov	eax, DWORD PTR [edx+124]
	mov	edx, DWORD PTR [eax+ecx*4]

; 1502 :     ctxt->incTab[ctxt->incNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 1503 :     return (ret);

	mov	eax, edx

; 1504 : }

	pop	ebp
	ret	0
_xmlRelaxNGIncludePop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGIncludePush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlRelaxNGIncludePush PROC				; COMDAT

; 1453 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi+124]
	test	ecx, ecx
	jne	SHORT $LN3@xmlRelaxNG

; 1454 :     if (ctxt->incTab == NULL) {
; 1455 :         ctxt->incMax = 4;

	push	16					; 00000010H
	mov	DWORD PTR [esi+120], 4

; 1456 :         ctxt->incNr = 0;

	mov	DWORD PTR [esi+116], ecx

; 1457 :         ctxt->incTab =

	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [esi+124], ecx

; 1458 :             (xmlRelaxNGIncludePtr *) xmlMalloc(ctxt->incMax *
; 1459 :                                                sizeof(ctxt->incTab[0]));
; 1460 :         if (ctxt->incTab == NULL) {

	test	ecx, ecx
	jne	SHORT $LN3@xmlRelaxNG

; 445  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN10@xmlRelaxNG

; 446  : 	    schannel = ctxt->serror;
; 447  : 	else
; 448  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN10@xmlRelaxNG:

; 449  :         data = ctxt->userData;
; 450  :         ctxt->nbErrors++;
; 451  :     }
; 452  :     if (extra)
; 453  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BE@NICNHGJN@allocating?5include?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+36]
	push	OFFSET ??_C@_0BE@NICNHGJN@allocating?5include?6@
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1461 :             xmlRngPErrMemory(ctxt, "allocating include\n");
; 1462 :             return (0);

	xor	eax, eax
	pop	esi

; 1479 : }

	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 1463 :         }
; 1464 :     }
; 1465 :     if (ctxt->incNr >= ctxt->incMax) {

	mov	edx, DWORD PTR [esi+116]
	mov	eax, DWORD PTR [esi+120]
	cmp	edx, eax
	jl	SHORT $LN5@xmlRelaxNG

; 1466 :         ctxt->incMax *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+120], eax

; 1467 :         ctxt->incTab =

	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR [esi+124], ecx

; 1468 :             (xmlRelaxNGIncludePtr *) xmlRealloc(ctxt->incTab,
; 1469 :                                                 ctxt->incMax *
; 1470 :                                                 sizeof(ctxt->incTab[0]));
; 1471 :         if (ctxt->incTab == NULL) {

	test	ecx, ecx
	jne	SHORT $LN21@xmlRelaxNG

; 445  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN17@xmlRelaxNG

; 446  : 	    schannel = ctxt->serror;
; 447  : 	else
; 448  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN17@xmlRelaxNG:

; 449  :         data = ctxt->userData;
; 450  :         ctxt->nbErrors++;
; 451  :     }
; 452  :     if (extra)
; 453  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BE@NICNHGJN@allocating?5include?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+36]
	push	OFFSET ??_C@_0BE@NICNHGJN@allocating?5include?6@
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1472 :             xmlRngPErrMemory(ctxt, "allocating include\n");
; 1473 :             return (0);

	xor	eax, eax
	pop	esi

; 1479 : }

	pop	ebp
	ret	0
$LN21@xmlRelaxNG:
	mov	edx, DWORD PTR [esi+116]
$LN5@xmlRelaxNG:

; 1474 :         }
; 1475 :     }
; 1476 :     ctxt->incTab[ctxt->incNr] = value;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1477 :     ctxt->inc = value;

	mov	DWORD PTR [esi+112], eax

; 1478 :     return (ctxt->incNr++);

	mov	eax, DWORD PTR [esi+116]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+116], ecx
	pop	esi

; 1479 : }

	pop	ebp
	ret	0
_xmlRelaxNGIncludePush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGCleanupDoc
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlRelaxNGCleanupDoc PROC				; COMDAT

; 7472 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _doc$[ebp]
	push	esi
	call	_xmlDocGetRootElement
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlRelaxNG

; 7473 :     xmlNodePtr root;
; 7474 : 
; 7475 :     /*
; 7476 :      * Extract the root
; 7477 :      */
; 7478 :     root = xmlDocGetRootElement(doc);
; 7479 :     if (root == NULL) {
; 7480 :         xmlRngPErr(ctxt, (xmlNodePtr) doc, XML_RNGP_EMPTY, "xmlRelaxNGParse: %s is empty\n",

	mov	eax, DWORD PTR _ctxt$[ebp]

; 516  :     xmlGenericErrorFunc channel = NULL;

	xor	ecx, ecx

; 517  :     void *data = NULL;
; 518  : 
; 519  :     if (ctxt != NULL) {
; 520  :         if (ctxt->serror != NULL)

	mov	edx, DWORD PTR [eax+12]
	test	edx, edx
	jne	SHORT $LN7@xmlRelaxNG

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	ecx, DWORD PTR [eax+4]
$LN7@xmlRelaxNG:

; 524  :         data = ctxt->userData;
; 525  :         ctxt->nbErrors++;
; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	push	0
	push	DWORD PTR [eax+68]
	inc	DWORD PTR [eax+36]
	push	OFFSET ??_C@_0BO@JMOIDLLM@xmlRelaxNGParse?3?5?$CFs?5is?5empty?6@
	push	0
	push	0
	push	0
	push	0
	push	DWORD PTR [eax+68]
	push	0
	push	0
	push	2
	push	1022					; 000003feH
	push	18					; 00000012H
	push	esi
	push	0
	push	DWORD PTR [eax]
	push	ecx
	push	edx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 7481 :                    ctxt->URL, NULL);
; 7482 :         return (NULL);

	xor	eax, eax
	pop	esi

; 7486 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:

; 7483 :     }
; 7484 :     xmlRelaxNGCleanupTree(ctxt, root);

	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGCleanupTree
	add	esp, 8

; 7485 :     return (doc);

	mov	eax, esi
	pop	esi

; 7486 : }

	pop	ebp
	ret	0
_xmlRelaxNGCleanupDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGCopyValidState
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_state$ = 12						; size = 4
_xmlRelaxNGCopyValidState PROC				; COMDAT

; 1281 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _state$[ebp]
	test	ebx, ebx
	jne	SHORT $LN2@xmlRelaxNG

; 1282 :     xmlRelaxNGValidStatePtr ret;
; 1283 :     unsigned int maxAttrs;
; 1284 :     xmlAttrPtr *attrs;
; 1285 : 
; 1286 :     if (state == NULL)
; 1287 :         return (NULL);

	xor	eax, eax
	pop	ebx

; 1333 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:
	push	esi
	push	edi

; 1288 :     if ((ctxt->freeState != NULL) && (ctxt->freeState->nbState > 0)) {

	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edi+68]
	test	ecx, ecx
	je	SHORT $LN3@xmlRelaxNG
	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jle	SHORT $LN3@xmlRelaxNG

; 1289 :         ctxt->freeState->nbState--;

	dec	eax
	mov	DWORD PTR [ecx], eax

; 1290 :         ret = ctxt->freeState->tabState[ctxt->freeState->nbState];

	mov	eax, DWORD PTR [edi+68]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+ecx*4]

; 1291 :     } else {

	jmp	SHORT $LN4@xmlRelaxNG
$LN3@xmlRelaxNG:

; 1292 :         ret =

	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 1293 :             (xmlRelaxNGValidStatePtr)
; 1294 :             xmlMalloc(sizeof(xmlRelaxNGValidState));
; 1295 :         if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN5@xmlRelaxNG

; 480  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [edi+12]
	test	ecx, ecx
	jne	SHORT $LN16@xmlRelaxNG

; 481  : 	    schannel = ctxt->serror;
; 482  : 	else
; 483  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [edi+4]
$LN16@xmlRelaxNG:

; 484  :         data = ctxt->userData;
; 485  :         ctxt->nbErrors++;
; 486  :     }
; 487  :     if (extra)
; 488  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BD@FIBAKIJP@allocating?5states?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [edi+16]
	push	OFFSET ??_C@_0BD@FIBAKIJP@allocating?5states?6@
	push	0
	push	0
	push	3
	push	2
	push	19					; 00000013H
	push	0
	push	0
	push	DWORD PTR [edi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1296 :             xmlRngVErrMemory(ctxt, "allocating states\n");
; 1297 :             return (NULL);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 1333 : }

	pop	ebp
	ret	0
$LN5@xmlRelaxNG:
	xorps	xmm0, xmm0

; 1298 :         }
; 1299 :         memset(ret, 0, sizeof(xmlRelaxNGValidState));

	movups	XMMWORD PTR [esi], xmm0
	movups	XMMWORD PTR [esi+16], xmm0
$LN4@xmlRelaxNG:

; 1300 :     }
; 1301 :     attrs = ret->attrs;
; 1302 :     maxAttrs = ret->maxAttrs;
; 1303 :     memcpy(ret, state, sizeof(xmlRelaxNGValidState));

	movups	xmm0, XMMWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [esi+12]
	movups	XMMWORD PTR [esi], xmm0
	movups	xmm0, XMMWORD PTR [ebx+16]
	movups	XMMWORD PTR [esi+16], xmm0

; 1304 :     ret->attrs = attrs;

	mov	DWORD PTR [esi+28], ecx

; 1305 :     ret->maxAttrs = maxAttrs;

	mov	DWORD PTR [esi+12], eax

; 1306 :     if (state->nbAttrs > 0) {

	mov	edx, DWORD PTR [ebx+8]
	test	edx, edx
	jle	SHORT $LN6@xmlRelaxNG

; 1307 :         if (ret->attrs == NULL) {

	test	ecx, ecx
	jne	SHORT $LN7@xmlRelaxNG

; 1308 :             ret->maxAttrs = state->maxAttrs;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [esi+12], eax

; 1309 :             ret->attrs = (xmlAttrPtr *) xmlMalloc(ret->maxAttrs *

	shl	eax, 2
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [esi+28], ecx

; 1310 :                                                   sizeof(xmlAttrPtr));
; 1311 :             if (ret->attrs == NULL) {

	test	ecx, ecx
	je	SHORT $LN20@xmlRelaxNG

; 1312 :                 xmlRngVErrMemory(ctxt, "allocating states\n");
; 1313 :                 ret->nbAttrs = 0;
; 1314 :                 return (ret);
; 1315 :             }

	jmp	SHORT $LN10@xmlRelaxNG
$LN7@xmlRelaxNG:

; 1316 :         } else if (ret->maxAttrs < state->nbAttrs) {

	cmp	eax, edx
	jge	SHORT $LN10@xmlRelaxNG

; 1317 :             xmlAttrPtr *tmp;
; 1318 : 
; 1319 :             tmp = (xmlAttrPtr *) xmlRealloc(ret->attrs, state->maxAttrs *

	mov	eax, DWORD PTR [ebx+12]
	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8

; 1320 :                                             sizeof(xmlAttrPtr));
; 1321 :             if (tmp == NULL) {

	test	ecx, ecx
	jne	SHORT $LN11@xmlRelaxNG
$LN20@xmlRelaxNG:

; 1322 :                 xmlRngVErrMemory(ctxt, "allocating states\n");

	push	OFFSET ??_C@_0BD@FIBAKIJP@allocating?5states?6@
	push	edi
	call	_xmlRngVErrMemory
	add	esp, 8

; 1323 :                 ret->nbAttrs = 0;

	mov	DWORD PTR [esi+8], 0

; 1330 :                state->nbAttrs * sizeof(xmlAttrPtr));
; 1331 :     }
; 1332 :     return (ret);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1333 : }

	pop	ebp
	ret	0
$LN11@xmlRelaxNG:

; 1324 :                 return (ret);
; 1325 :             }
; 1326 :             ret->maxAttrs = state->maxAttrs;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [esi+12], eax

; 1327 :             ret->attrs = tmp;

	mov	DWORD PTR [esi+28], ecx
$LN10@xmlRelaxNG:

; 1328 :         }
; 1329 :         memcpy(ret->attrs, state->attrs,

	mov	eax, DWORD PTR [ebx+8]
	shl	eax, 2
	push	eax
	push	DWORD PTR [ebx+28]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN6@xmlRelaxNG:

; 1330 :                state->nbAttrs * sizeof(xmlAttrPtr));
; 1331 :     }
; 1332 :     return (ret);

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 1333 : }

	pop	ebp
	ret	0
_xmlRelaxNGCopyValidState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGNewValidState
_TEXT	SEGMENT
_attrs$ = -84						; size = 80
$T1 = -4						; size = 4
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlRelaxNGNewValidState PROC				; COMDAT

; 1185 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _node$[ebp]
	xor	edi, edi
	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR $T1[ebp], edi
	test	eax, eax
	jne	SHORT $LN6@xmlRelaxNG

; 1186 :     xmlRelaxNGValidStatePtr ret;
; 1187 :     xmlAttrPtr attr;
; 1188 :     xmlAttrPtr attrs[MAX_ATTR];
; 1189 :     int nbAttrs = 0;
; 1190 :     xmlNodePtr root = NULL;
; 1191 : 
; 1192 :     if (node == NULL) {
; 1193 :         root = xmlDocGetRootElement(ctxt->doc);

	push	DWORD PTR [ebx+24]
	call	_xmlDocGetRootElement
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T1[ebp], edx

; 1194 :         if (root == NULL)

	test	edx, edx
	jne	SHORT $LN3@xmlRelaxNG

; 1267 : }

	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlRelaxNG:

; 1195 :             return (NULL);
; 1196 :     } else {
; 1197 :         attr = node->properties;

	mov	eax, DWORD PTR [eax+44]

; 1198 :         while (attr != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG
$LL2@xmlRelaxNG:

; 1199 :             if (nbAttrs < MAX_ATTR)

	lea	ecx, DWORD PTR [edi+1]
	cmp	edi, 20					; 00000014H
	jge	SHORT $LN9@xmlRelaxNG

; 1200 :                 attrs[nbAttrs++] = attr;

	mov	DWORD PTR _attrs$[ebp+edi*4], eax
$LN9@xmlRelaxNG:

; 1201 :             else
; 1202 :                 nbAttrs++;
; 1203 :             attr = attr->next;

	mov	eax, DWORD PTR [eax+24]
	mov	edi, ecx
	test	eax, eax
	jne	SHORT $LL2@xmlRelaxNG
$LN3@xmlRelaxNG:

; 1204 :         }
; 1205 :     }
; 1206 :     if ((ctxt->freeState != NULL) && (ctxt->freeState->nbState > 0)) {

	mov	ecx, DWORD PTR [ebx+68]
	push	esi
	test	ecx, ecx
	je	SHORT $LN11@xmlRelaxNG
	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jle	SHORT $LN11@xmlRelaxNG

; 1207 :         ctxt->freeState->nbState--;

	dec	eax
	mov	DWORD PTR [ecx], eax

; 1208 :         ret = ctxt->freeState->tabState[ctxt->freeState->nbState];

	mov	eax, DWORD PTR [ebx+68]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+ecx*4]

; 1209 :     } else {

	jmp	SHORT $LN12@xmlRelaxNG
$LN11@xmlRelaxNG:

; 1210 :         ret =

	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 1211 :             (xmlRelaxNGValidStatePtr)
; 1212 :             xmlMalloc(sizeof(xmlRelaxNGValidState));
; 1213 :         if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN13@xmlRelaxNG

; 480  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [ebx+12]
	test	ecx, ecx
	jne	SHORT $LN30@xmlRelaxNG

; 481  : 	    schannel = ctxt->serror;
; 482  : 	else
; 483  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [ebx+4]
$LN30@xmlRelaxNG:

; 484  :         data = ctxt->userData;
; 485  :         ctxt->nbErrors++;
; 486  :     }
; 487  :     if (extra)
; 488  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BD@FIBAKIJP@allocating?5states?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [ebx+16]
	push	OFFSET ??_C@_0BD@FIBAKIJP@allocating?5states?6@
	push	0
	push	0
	push	3
	push	2
	push	19					; 00000013H
	push	0
	push	0
	push	DWORD PTR [ebx]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1214 :             xmlRngVErrMemory(ctxt, "allocating states\n");
; 1215 :             return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 1267 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlRelaxNG:
	xorps	xmm0, xmm0

; 1216 :         }
; 1217 :         memset(ret, 0, sizeof(xmlRelaxNGValidState));

	movups	XMMWORD PTR [esi], xmm0
	movups	XMMWORD PTR [esi+16], xmm0
$LN12@xmlRelaxNG:

; 1218 :     }
; 1219 :     ret->value = NULL;
; 1220 :     ret->endvalue = NULL;
; 1221 :     if (node == NULL) {

	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	test	edx, edx
	jne	SHORT $LN14@xmlRelaxNG

; 1222 :         ret->node = (xmlNodePtr) ctxt->doc;

	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR [esi], eax

; 1223 :         ret->seq = root;
; 1224 :     } else {

	mov	eax, DWORD PTR $T1[ebp]
	jmp	SHORT $LN15@xmlRelaxNG
$LN14@xmlRelaxNG:

; 1225 :         ret->node = node;

	mov	DWORD PTR [esi], edx

; 1226 :         ret->seq = node->children;

	mov	eax, DWORD PTR [edx+12]
$LN15@xmlRelaxNG:

; 1227 :     }
; 1228 :     ret->nbAttrs = 0;

	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], 0

; 1229 :     if (nbAttrs > 0) {

	test	edi, edi
	jle	$LN5@xmlRelaxNG

; 1230 :         if (ret->attrs == NULL) {

	mov	ecx, DWORD PTR [esi+28]
	test	ecx, ecx
	jne	SHORT $LN17@xmlRelaxNG

; 1231 :             if (nbAttrs < 4)

	mov	ecx, 4
	mov	eax, edi
	cmp	edi, ecx
	cmovl	eax, ecx

; 1232 :                 ret->maxAttrs = 4;
; 1233 :             else
; 1234 :                 ret->maxAttrs = nbAttrs;
; 1235 :             ret->attrs = (xmlAttrPtr *) xmlMalloc(ret->maxAttrs *

	mov	DWORD PTR [esi+12], eax
	shl	eax, 2
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [esi+28], ecx

; 1236 :                                                   sizeof(xmlAttrPtr));
; 1237 :             if (ret->attrs == NULL) {

	test	ecx, ecx
	je	SHORT $LN42@xmlRelaxNG

; 1238 :                 xmlRngVErrMemory(ctxt, "allocating states\n");
; 1239 :                 return (ret);
; 1240 :             }

	jmp	SHORT $LN44@xmlRelaxNG
$LN17@xmlRelaxNG:

; 1241 :         } else if (ret->maxAttrs < nbAttrs) {

	cmp	DWORD PTR [esi+12], edi
	jge	SHORT $LN22@xmlRelaxNG

; 1242 :             xmlAttrPtr *tmp;
; 1243 : 
; 1244 :             tmp = (xmlAttrPtr *) xmlRealloc(ret->attrs, nbAttrs *

	lea	eax, DWORD PTR [edi*4]
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8

; 1245 :                                             sizeof(xmlAttrPtr));
; 1246 :             if (tmp == NULL) {

	test	ecx, ecx
	jne	SHORT $LN23@xmlRelaxNG
$LN42@xmlRelaxNG:

; 1247 :                 xmlRngVErrMemory(ctxt, "allocating states\n");

	push	OFFSET ??_C@_0BD@FIBAKIJP@allocating?5states?6@
	push	ebx
	call	_xmlRngVErrMemory
	add	esp, 8

; 1266 :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 1267 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@xmlRelaxNG:

; 1248 :                 return (ret);
; 1249 :             }
; 1250 :             ret->attrs = tmp;

	mov	DWORD PTR [esi+28], ecx

; 1251 :             ret->maxAttrs = nbAttrs;

	mov	DWORD PTR [esi+12], edi
$LN44@xmlRelaxNG:

; 1252 :         }
; 1253 :         ret->nbAttrs = nbAttrs;

	mov	edx, DWORD PTR _node$[ebp]
$LN22@xmlRelaxNG:
	mov	DWORD PTR [esi+8], edi

; 1254 :         if (nbAttrs < MAX_ATTR) {

	cmp	edi, 20					; 00000014H
	jge	SHORT $LN24@xmlRelaxNG

; 1255 :             memcpy(ret->attrs, attrs, sizeof(xmlAttrPtr) * nbAttrs);

	lea	eax, DWORD PTR [edi*4]
	push	eax
	lea	eax, DWORD PTR _attrs$[ebp]
	push	eax
	push	ecx
	call	_memcpy

; 1262 :             }
; 1263 :         }
; 1264 :     }
; 1265 :     ret->nbAttrLeft = ret->nbAttrs;

	mov	eax, DWORD PTR [esi+8]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+16], eax

; 1266 :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 1267 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlRelaxNG:

; 1256 :         } else {
; 1257 :             attr = node->properties;

	mov	ecx, DWORD PTR [edx+44]

; 1258 :             nbAttrs = 0;
; 1259 :             while (attr != NULL) {

	test	ecx, ecx
	je	SHORT $LN5@xmlRelaxNG

; 1256 :         } else {
; 1257 :             attr = node->properties;

	xor	edx, edx
	npad	3
$LL4@xmlRelaxNG:

; 1260 :                 ret->attrs[nbAttrs++] = attr;

	mov	eax, DWORD PTR [esi+28]
	lea	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [edx+eax-4], ecx

; 1261 :                 attr = attr->next;

	mov	ecx, DWORD PTR [ecx+24]
	test	ecx, ecx
	jne	SHORT $LL4@xmlRelaxNG
$LN5@xmlRelaxNG:

; 1262 :             }
; 1263 :         }
; 1264 :     }
; 1265 :     ret->nbAttrLeft = ret->nbAttrs;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+16], eax

; 1266 :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 1267 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRelaxNGNewValidState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGFreeStates
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_states$ = 12						; size = 4
_xmlRelaxNGFreeStates PROC				; COMDAT

; 1138 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _states$[ebp]
	test	edi, edi
	je	$LN9@xmlRelaxNG

; 1139 :     if (states == NULL)
; 1140 :         return;
; 1141 :     if ((ctxt != NULL) && (ctxt->freeStates == NULL)) {

	test	esi, esi
	je	$LN10@xmlRelaxNG
	mov	ecx, DWORD PTR [esi+80]
	test	ecx, ecx
	jne	SHORT $LN12@xmlRelaxNG

; 1142 :         ctxt->freeStatesMax = 40;
; 1143 :         ctxt->freeStatesNr = 0;
; 1144 :         ctxt->freeStates = (xmlRelaxNGStatesPtr *)

	push	160					; 000000a0H
	mov	DWORD PTR [esi+76], 40			; 00000028H
	mov	DWORD PTR [esi+72], ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+80], eax

; 1145 :             xmlMalloc(ctxt->freeStatesMax * sizeof(xmlRelaxNGStatesPtr));
; 1146 :         if (ctxt->freeStates == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlRelaxNG

; 1147 :             xmlRngVErrMemory(ctxt, "storing states\n");

	push	OFFSET ??_C@_0BA@DKBKEJJK@storing?5states?6@
	push	esi
	call	_xmlRngVErrMemory
	add	esp, 8
$LN5@xmlRelaxNG:

; 1148 :         }
; 1149 :     } else if ((ctxt != NULL)

	mov	ecx, DWORD PTR [esi+80]
	jmp	SHORT $LN6@xmlRelaxNG
$LN12@xmlRelaxNG:

; 1150 :                && (ctxt->freeStatesNr >= ctxt->freeStatesMax)) {

	mov	eax, DWORD PTR [esi+76]
	cmp	DWORD PTR [esi+72], eax
	jl	SHORT $LN6@xmlRelaxNG

; 1151 :         xmlRelaxNGStatesPtr *tmp;
; 1152 : 
; 1153 :         tmp = (xmlRelaxNGStatesPtr *) xmlRealloc(ctxt->freeStates,

	shl	eax, 3
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8

; 1154 :                                                  2 * ctxt->freeStatesMax *
; 1155 :                                                  sizeof
; 1156 :                                                  (xmlRelaxNGStatesPtr));
; 1157 :         if (tmp == NULL) {

	test	ecx, ecx
	jne	SHORT $LN7@xmlRelaxNG

; 1158 :             xmlRngVErrMemory(ctxt, "storing states\n");

	push	OFFSET ??_C@_0BA@DKBKEJJK@storing?5states?6@
	push	esi
	call	_xmlRngVErrMemory

; 1159 :             xmlFree(states->tabState);

	push	DWORD PTR [edi+8]
	call	DWORD PTR _xmlFree

; 1160 :             xmlFree(states);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H
	pop	edi

; 1171 :     }
; 1172 : }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlRelaxNG:

; 1161 :             return;
; 1162 :         }
; 1163 :         ctxt->freeStates = tmp;
; 1164 :         ctxt->freeStatesMax *= 2;

	mov	eax, DWORD PTR [esi+76]
	add	eax, eax
	mov	DWORD PTR [esi+80], ecx
	mov	DWORD PTR [esi+76], eax
$LN6@xmlRelaxNG:

; 1165 :     }
; 1166 :     if ((ctxt == NULL) || (ctxt->freeStates == NULL)) {

	test	ecx, ecx
	je	SHORT $LN10@xmlRelaxNG

; 1169 :     } else {
; 1170 :         ctxt->freeStates[ctxt->freeStatesNr++] = states;

	mov	eax, DWORD PTR [esi+72]
	mov	DWORD PTR [ecx+eax*4], edi
	inc	DWORD PTR [esi+72]
	pop	edi

; 1171 :     }
; 1172 : }

	pop	esi
	pop	ebp
	ret	0
$LN10@xmlRelaxNG:

; 1167 :         xmlFree(states->tabState);

	push	DWORD PTR [edi+8]
	call	DWORD PTR _xmlFree

; 1168 :         xmlFree(states);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 8
$LN9@xmlRelaxNG:

; 1171 :     }
; 1172 : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlRelaxNGFreeStates ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGAddStates
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_states$ = 12						; size = 4
_i$1$ = 16						; size = 4
_state$ = 16						; size = 4
_xmlRelaxNGAddStates PROC				; COMDAT

; 1096 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _state$[ebp]
	test	edi, edi
	je	$LN6@xmlRelaxNG

; 1097 :     int i;
; 1098 : 
; 1099 :     if (state == NULL || states == NULL) {

	mov	ebx, DWORD PTR _states$[ebp]
	test	ebx, ebx
	je	$LN6@xmlRelaxNG

; 1101 :     }
; 1102 :     if (states->nbState >= states->maxState) {

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx+4]
	push	esi
	cmp	ecx, eax
	jl	SHORT $LN42@xmlRelaxNG

; 1103 :         xmlRelaxNGValidStatePtr *tmp;
; 1104 :         int size;
; 1105 : 
; 1106 :         size = states->maxState * 2;

	lea	esi, DWORD PTR [eax+eax]

; 1107 :         tmp = (xmlRelaxNGValidStatePtr *) xmlRealloc(states->tabState,

	lea	eax, DWORD PTR [esi*4]
	push	eax
	push	DWORD PTR [ebx+8]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1108 :                                                      (size) *
; 1109 :                                                      sizeof
; 1110 :                                                      (xmlRelaxNGValidStatePtr));
; 1111 :         if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN8@xmlRelaxNG

; 1112 :             xmlRngVErrMemory(ctxt, "adding states\n");

	push	OFFSET ??_C@_0P@NLODGFON@adding?5states?6@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRngVErrMemory
	add	esp, 8

; 1113 :             return (-1);

	or	eax, -1
	pop	esi
	pop	edi

; 1126 : }

	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlRelaxNG:

; 1114 :         }
; 1115 :         states->tabState = tmp;
; 1116 :         states->maxState = size;

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [ebx+8], eax
	mov	DWORD PTR [ebx+4], esi
$LN42@xmlRelaxNG:

; 1117 :     }
; 1118 :     for (i = 0; i < states->nbState; i++) {

	xor	esi, esi
	mov	DWORD PTR _i$1$[ebp], esi
	test	ecx, ecx
	jle	$LN44@xmlRelaxNG
$LL4@xmlRelaxNG:

; 1119 :         if (xmlRelaxNGEqualValidState(ctxt, state, states->tabState[i])) {

	mov	eax, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [eax+esi*4]

; 1352 :     if ((state1 == NULL) || (state2 == NULL))

	test	esi, esi
	je	$LN16@xmlRelaxNG

; 1353 :         return (0);
; 1354 :     if (state1 == state2)

	cmp	edi, esi
	je	SHORT $LN29@xmlRelaxNG

; 1355 :         return (1);
; 1356 :     if (state1->node != state2->node)

	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN16@xmlRelaxNG

; 1357 :         return (0);
; 1358 :     if (state1->seq != state2->seq)

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [esi+4]
	jne	SHORT $LN16@xmlRelaxNG

; 1359 :         return (0);
; 1360 :     if (state1->nbAttrLeft != state2->nbAttrLeft)

	mov	eax, DWORD PTR [edi+16]
	cmp	eax, DWORD PTR [esi+16]
	jne	SHORT $LN16@xmlRelaxNG

; 1361 :         return (0);
; 1362 :     if (state1->nbAttrs != state2->nbAttrs)

	mov	eax, DWORD PTR [edi+8]
	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN16@xmlRelaxNG

; 1363 :         return (0);
; 1364 :     if (state1->endvalue != state2->endvalue)

	mov	eax, DWORD PTR [edi+24]
	cmp	eax, DWORD PTR [esi+24]
	jne	SHORT $LN16@xmlRelaxNG

; 1365 :         return (0);
; 1366 :     if ((state1->value != state2->value) &&

	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [esi+20]
	cmp	eax, ecx
	je	SHORT $LN43@xmlRelaxNG
	push	ecx
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlRelaxNG
$LN43@xmlRelaxNG:

; 1367 :         (!xmlStrEqual(state1->value, state2->value)))
; 1368 :         return (0);
; 1369 :     for (i = 0; i < state1->nbAttrs; i++) {

	mov	ebx, DWORD PTR [edi+8]
	xor	edx, edx
	test	ebx, ebx
	jle	SHORT $LN29@xmlRelaxNG

; 1370 :         if (state1->attrs[i] != state2->attrs[i])

	mov	eax, DWORD PTR [esi+28]
	mov	esi, DWORD PTR [edi+28]
	sub	esi, eax
$LL14@xmlRelaxNG:
	mov	ecx, DWORD PTR [esi+eax]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN45@xmlRelaxNG

; 1367 :         (!xmlStrEqual(state1->value, state2->value)))
; 1368 :         return (0);
; 1369 :     for (i = 0; i < state1->nbAttrs; i++) {

	inc	edx
	add	eax, 4
	cmp	edx, ebx
	jl	SHORT $LL14@xmlRelaxNG
$LN29@xmlRelaxNG:

; 1120 :             xmlRelaxNGFreeValidState(ctxt, state);

	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRelaxNGFreeValidState
	add	esp, 8

; 1121 :             return (0);

	xor	eax, eax
	pop	esi
	pop	edi

; 1126 : }

	pop	ebx
	pop	ebp
	ret	0
$LN45@xmlRelaxNG:

; 1370 :         if (state1->attrs[i] != state2->attrs[i])

	mov	ebx, DWORD PTR _states$[ebp]
$LN16@xmlRelaxNG:

; 1117 :     }
; 1118 :     for (i = 0; i < states->nbState; i++) {

	mov	esi, DWORD PTR _i$1$[ebp]
	mov	ecx, DWORD PTR [ebx]
	inc	esi
	mov	DWORD PTR _i$1$[ebp], esi
	cmp	esi, ecx
	jl	$LL4@xmlRelaxNG
$LN44@xmlRelaxNG:

; 1122 :         }
; 1123 :     }
; 1124 :     states->tabState[states->nbState++] = state;

	mov	eax, DWORD PTR [ebx+8]
	pop	esi
	mov	DWORD PTR [eax+ecx*4], edi

; 1125 :     return (1);

	mov	eax, 1
	inc	DWORD PTR [ebx]
	pop	edi

; 1126 : }

	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlRelaxNG:
	pop	edi

; 1100 :         return (-1);

	or	eax, -1

; 1126 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlRelaxNGAddStates ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGAddStatesUniq
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_states$ = 12						; size = 4
_state$ = 16						; size = 4
_xmlRelaxNGAddStatesUniq PROC				; COMDAT

; 1058 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _state$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlRelaxNG

; 1059 :     if (state == NULL) {
; 1060 :         return (-1);

	or	eax, -1
	pop	edi

; 1080 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:
	push	ebx
	push	esi

; 1061 :     }
; 1062 :     if (states->nbState >= states->maxState) {

	mov	esi, DWORD PTR _states$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	cmp	ecx, eax
	jl	SHORT $LN7@xmlRelaxNG

; 1063 :         xmlRelaxNGValidStatePtr *tmp;
; 1064 :         int size;
; 1065 : 
; 1066 :         size = states->maxState * 2;

	lea	ebx, DWORD PTR [eax+eax]

; 1067 :         tmp = (xmlRelaxNGValidStatePtr *) xmlRealloc(states->tabState,

	lea	eax, DWORD PTR [ebx*4]
	push	eax
	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1068 :                                                      (size) *
; 1069 :                                                      sizeof
; 1070 :                                                      (xmlRelaxNGValidStatePtr));
; 1071 :         if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlRelaxNG

; 1072 :             xmlRngVErrMemory(ctxt, "adding states\n");

	push	OFFSET ??_C@_0P@NLODGFON@adding?5states?6@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRngVErrMemory
	add	esp, 8

; 1073 :             return (-1);

	or	eax, -1
	pop	esi
	pop	ebx
	pop	edi

; 1080 : }

	pop	ebp
	ret	0
$LN4@xmlRelaxNG:

; 1074 :         }
; 1075 :         states->tabState = tmp;
; 1076 :         states->maxState = size;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+4], ebx
$LN7@xmlRelaxNG:

; 1077 :     }
; 1078 :     states->tabState[states->nbState++] = state;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+ecx*4], edi

; 1079 :     return (1);

	mov	eax, 1
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebx
	pop	edi

; 1080 : }

	pop	ebp
	ret	0
_xmlRelaxNGAddStatesUniq ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGNewStates
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlRelaxNGNewStates PROC				; COMDAT

; 1009 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN2@xmlRelaxNG

; 1010 :     xmlRelaxNGStatesPtr ret;
; 1011 : 
; 1012 :     if ((ctxt != NULL) &&
; 1013 :         (ctxt->freeStates != NULL) && (ctxt->freeStatesNr > 0)) {

	mov	ecx, DWORD PTR [esi+80]
	test	ecx, ecx
	je	SHORT $LN2@xmlRelaxNG
	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	jle	SHORT $LN2@xmlRelaxNG

; 1014 :         ctxt->freeStatesNr--;

	dec	eax
	mov	DWORD PTR [esi+72], eax
	pop	esi

; 1015 :         ret = ctxt->freeStates[ctxt->freeStatesNr];

	mov	eax, DWORD PTR [ecx+eax*4]

; 1016 :         ret->nbState = 0;

	mov	DWORD PTR [eax], 0

; 1041 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:
	push	ebx

; 1017 :         return (ret);
; 1018 :     }
; 1019 :     if (size < 16)
; 1020 :         size = 16;
; 1021 : 
; 1022 :     ret = (xmlRelaxNGStatesPtr) xmlMalloc(sizeof(xmlRelaxNGStates) +

	mov	ebx, 16					; 00000010H
	cmp	DWORD PTR _size$[ebp], ebx
	push	edi
	cmovge	ebx, DWORD PTR _size$[ebp]
	lea	eax, DWORD PTR [ebx*4+8]
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 1023 :                                           (size -
; 1024 :                                            1) *
; 1025 :                                           sizeof(xmlRelaxNGValidStatePtr));
; 1026 :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN4@xmlRelaxNG

; 476  :     xmlGenericErrorFunc channel = NULL;

	xor	ecx, ecx

; 477  :     void *data = NULL;

	xor	edx, edx

; 478  : 
; 479  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN8@xmlRelaxNG

; 480  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN10@xmlRelaxNG

; 481  : 	    schannel = ctxt->serror;
; 482  : 	else
; 483  : 	    channel = ctxt->error;

	mov	ecx, DWORD PTR [esi+4]
$LN10@xmlRelaxNG:

; 484  :         data = ctxt->userData;

	mov	edx, DWORD PTR [esi]

; 485  :         ctxt->nbErrors++;

	inc	DWORD PTR [esi+16]
$LN8@xmlRelaxNG:

; 486  :     }
; 487  :     if (extra)
; 488  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BD@FIBAKIJP@allocating?5states?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BD@FIBAKIJP@allocating?5states?6@
	push	0
	push	0
	push	3
	push	2
	push	19					; 00000013H
	push	0
	push	0
	push	edx
	push	ecx
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1027 :         xmlRngVErrMemory(ctxt, "allocating states\n");
; 1028 :         return (NULL);

	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 1041 : }

	pop	ebp
	ret	0
$LN4@xmlRelaxNG:

; 1029 :     }
; 1030 :     ret->nbState = 0;
; 1031 :     ret->maxState = size;
; 1032 :     ret->tabState = (xmlRelaxNGValidStatePtr *) xmlMalloc((size) *

	lea	eax, DWORD PTR [ebx*4]
	mov	DWORD PTR [edi], 0
	push	eax
	mov	DWORD PTR [edi+4], ebx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi+8], eax

; 1033 :                                                           sizeof
; 1034 :                                                           (xmlRelaxNGValidStatePtr));
; 1035 :     if (ret->tabState == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlRelaxNG

; 476  :     xmlGenericErrorFunc channel = NULL;

	xor	ecx, ecx

; 477  :     void *data = NULL;

	xor	edx, edx

; 478  : 
; 479  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN15@xmlRelaxNG

; 480  :         if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN17@xmlRelaxNG

; 481  : 	    schannel = ctxt->serror;
; 482  : 	else
; 483  : 	    channel = ctxt->error;

	mov	ecx, DWORD PTR [esi+4]
$LN17@xmlRelaxNG:

; 484  :         data = ctxt->userData;

	mov	edx, DWORD PTR [esi]

; 485  :         ctxt->nbErrors++;

	inc	DWORD PTR [esi+16]
$LN15@xmlRelaxNG:

; 486  :     }
; 487  :     if (extra)
; 488  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BD@FIBAKIJP@allocating?5states?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BD@FIBAKIJP@allocating?5states?6@
	push	0
	push	0
	push	3
	push	2
	push	19					; 00000013H
	push	0
	push	0
	push	edx
	push	ecx
	push	eax
	call	___xmlRaiseError

; 1036 :         xmlRngVErrMemory(ctxt, "allocating states\n");
; 1037 :         xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 72					; 00000048H

; 1038 :         return (NULL);

	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 1041 : }

	pop	ebp
	ret	0
$LN5@xmlRelaxNG:

; 1039 :     }
; 1040 :     return (ret);

	mov	eax, edi
	pop	edi
	pop	ebx
	pop	esi

; 1041 : }

	pop	ebp
	ret	0
_xmlRelaxNGNewStates ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGFreePartition
_TEXT	SEGMENT
_partitions$ = 8					; size = 4
_xmlRelaxNGFreePartition PROC				; COMDAT

; 939  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _partitions$[ebp]
	test	ebx, ebx
	je	SHORT $LN5@xmlRelaxNG

; 940  :     xmlRelaxNGInterleaveGroupPtr group;
; 941  :     int j;
; 942  : 
; 943  :     if (partitions != NULL) {
; 944  :         if (partitions->groups != NULL) {

	cmp	DWORD PTR [ebx+12], 0
	je	SHORT $LN6@xmlRelaxNG

; 945  :             for (j = 0; j < partitions->nbgroups; j++) {

	push	esi
	xor	esi, esi
	cmp	DWORD PTR [ebx], esi
	jle	SHORT $LN3@xmlRelaxNG
	push	edi
$LL4@xmlRelaxNG:

; 946  :                 group = partitions->groups[j];

	mov	eax, DWORD PTR [ebx+12]
	mov	edi, DWORD PTR [eax+esi*4]

; 947  :                 if (group != NULL) {

	test	edi, edi
	je	SHORT $LN2@xmlRelaxNG

; 948  :                     if (group->defs != NULL)

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN8@xmlRelaxNG

; 949  :                         xmlFree(group->defs);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlRelaxNG:

; 950  :                     if (group->attrs != NULL)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN9@xmlRelaxNG

; 951  :                         xmlFree(group->attrs);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlRelaxNG:

; 952  :                     xmlFree(group);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlRelaxNG:

; 945  :             for (j = 0; j < partitions->nbgroups; j++) {

	inc	esi
	cmp	esi, DWORD PTR [ebx]
	jl	SHORT $LL4@xmlRelaxNG
	pop	edi
$LN3@xmlRelaxNG:

; 953  :                 }
; 954  :             }
; 955  :             xmlFree(partitions->groups);

	push	DWORD PTR [ebx+12]
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi
$LN6@xmlRelaxNG:

; 956  :         }
; 957  :         if (partitions->triage != NULL) {

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN10@xmlRelaxNG

; 958  :             xmlHashFree(partitions->triage, NULL);

	push	0
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN10@xmlRelaxNG:

; 959  :         }
; 960  :         xmlFree(partitions);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlRelaxNG:
	pop	ebx

; 961  :     }
; 962  : }

	pop	ebp
	ret	0
_xmlRelaxNGFreePartition ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGNewDefine
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlRelaxNGNewDefine PROC				; COMDAT

; 893  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+80]
	test	eax, eax
	jne	SHORT $LN2@xmlRelaxNG

; 894  :     xmlRelaxNGDefinePtr ret;
; 895  : 
; 896  :     if (ctxt->defMax == 0) {
; 897  :         ctxt->defMax = 16;

	push	64					; 00000040H
	mov	DWORD PTR [esi+80], 16			; 00000010H

; 898  :         ctxt->defNr = 0;

	mov	DWORD PTR [esi+76], eax

; 899  :         ctxt->defTab = (xmlRelaxNGDefinePtr *)

	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+84], eax

; 900  :             xmlMalloc(ctxt->defMax * sizeof(xmlRelaxNGDefinePtr));
; 901  :         if (ctxt->defTab == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlRelaxNG

; 445  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN12@xmlRelaxNG

; 446  : 	    schannel = ctxt->serror;
; 447  : 	else
; 448  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN12@xmlRelaxNG:

; 449  :         data = ctxt->userData;
; 450  :         ctxt->nbErrors++;
; 451  :     }
; 452  :     if (extra)
; 453  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BD@KFBIDMJP@allocating?5define?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+36]
	push	OFFSET ??_C@_0BD@KFBIDMJP@allocating?5define?6@
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 902  :             xmlRngPErrMemory(ctxt, "allocating define\n");
; 903  :             return (NULL);

	xor	eax, eax
	pop	esi

; 929  : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:

; 904  :         }
; 905  :     } else if (ctxt->defMax <= ctxt->defNr) {

	cmp	eax, DWORD PTR [esi+76]
	jg	SHORT $LN5@xmlRelaxNG

; 906  :         xmlRelaxNGDefinePtr *tmp;
; 907  : 
; 908  :         ctxt->defMax *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+80], eax

; 909  :         tmp = (xmlRelaxNGDefinePtr *) xmlRealloc(ctxt->defTab,

	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+84]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 910  :                                                  ctxt->defMax *
; 911  :                                                  sizeof
; 912  :                                                  (xmlRelaxNGDefinePtr));
; 913  :         if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlRelaxNG

; 914  :             xmlRngPErrMemory(ctxt, "allocating define\n");

	push	OFFSET ??_C@_0BD@KFBIDMJP@allocating?5define?6@
	push	esi
	call	_xmlRngPErrMemory
	add	esp, 8

; 915  :             return (NULL);

	xor	eax, eax
	pop	esi

; 929  : }

	pop	ebp
	ret	0
$LN6@xmlRelaxNG:

; 916  :         }
; 917  :         ctxt->defTab = tmp;

	mov	DWORD PTR [esi+84], eax
$LN5@xmlRelaxNG:
	push	edi

; 918  :     }
; 919  :     ret = (xmlRelaxNGDefinePtr) xmlMalloc(sizeof(xmlRelaxNGDefine));

	push	56					; 00000038H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 920  :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN7@xmlRelaxNG

; 445  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN19@xmlRelaxNG

; 446  : 	    schannel = ctxt->serror;
; 447  : 	else
; 448  : 	    channel = ctxt->error;

	mov	eax, DWORD PTR [esi+4]
$LN19@xmlRelaxNG:

; 449  :         data = ctxt->userData;
; 450  :         ctxt->nbErrors++;
; 451  :     }
; 452  :     if (extra)
; 453  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BD@KFBIDMJP@allocating?5define?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+36]
	push	OFFSET ??_C@_0BD@KFBIDMJP@allocating?5define?6@
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	DWORD PTR [esi]
	push	eax
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 921  :         xmlRngPErrMemory(ctxt, "allocating define\n");
; 922  :         return (NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 929  : }

	pop	ebp
	ret	0
$LN7@xmlRelaxNG:

; 923  :     }
; 924  :     memset(ret, 0, sizeof(xmlRelaxNGDefine));

	push	56					; 00000038H
	push	0
	push	edi
	call	_memset

; 925  :     ctxt->defTab[ctxt->defNr++] = ret;

	mov	ecx, DWORD PTR [esi+76]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [esi+84]
	mov	DWORD PTR [eax+ecx*4], edi
	inc	DWORD PTR [esi+76]

; 926  :     ret->node = node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edi+4], eax

; 927  :     ret->depth = -1;

	or	eax, -1
	mov	WORD PTR [edi+48], ax

; 928  :     return (ret);

	mov	eax, edi
	pop	edi
	pop	esi

; 929  : }

	pop	ebp
	ret	0
_xmlRelaxNGNewDefine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGNewGrammar
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlRelaxNGNewGrammar PROC				; COMDAT

; 841  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlRelaxNG

; 444  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	push	esi
	xor	edx, edx
	xor	esi, esi
	test	eax, eax
	je	SHORT $LN5@xmlRelaxNG

; 445  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN7@xmlRelaxNG

; 446  : 	    schannel = ctxt->serror;
; 447  : 	else
; 448  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [eax+4]
$LN7@xmlRelaxNG:

; 449  :         data = ctxt->userData;

	mov	esi, DWORD PTR [eax]

; 450  :         ctxt->nbErrors++;

	inc	DWORD PTR [eax+36]
$LN5@xmlRelaxNG:

; 451  :     }
; 452  :     if (extra)
; 453  :         __xmlRaiseError(schannel, channel, data,
; 454  :                         NULL, NULL, XML_FROM_RELAXNGP,
; 455  :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,
; 456  :                         NULL, NULL, 0, 0,
; 457  :                         "Memory allocation failed : %s\n", extra);
; 458  :     else
; 459  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	esi
	push	edx
	push	ecx
	call	___xmlRaiseError
	add	esp, 64					; 00000040H

; 842  :     xmlRelaxNGGrammarPtr ret;
; 843  : 
; 844  :     ret = (xmlRelaxNGGrammarPtr) xmlMalloc(sizeof(xmlRelaxNGGrammar));
; 845  :     if (ret == NULL) {
; 846  :         xmlRngPErrMemory(ctxt, NULL);
; 847  :         return (NULL);

	xor	eax, eax
	pop	esi

; 850  : 
; 851  :     return (ret);
; 852  : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:
	xorps	xmm0, xmm0

; 848  :     }
; 849  :     memset(ret, 0, sizeof(xmlRelaxNGGrammar));

	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0

; 850  : 
; 851  :     return (ret);
; 852  : }

	pop	ebp
	ret	0
_xmlRelaxNGNewGrammar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGNewRelaxNG
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlRelaxNGNewRelaxNG PROC				; COMDAT

; 762  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlRelaxNG

; 444  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	push	esi
	xor	edx, edx
	xor	esi, esi
	test	eax, eax
	je	SHORT $LN5@xmlRelaxNG

; 445  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN7@xmlRelaxNG

; 446  : 	    schannel = ctxt->serror;
; 447  : 	else
; 448  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [eax+4]
$LN7@xmlRelaxNG:

; 449  :         data = ctxt->userData;

	mov	esi, DWORD PTR [eax]

; 450  :         ctxt->nbErrors++;

	inc	DWORD PTR [eax+36]
$LN5@xmlRelaxNG:

; 451  :     }
; 452  :     if (extra)
; 453  :         __xmlRaiseError(schannel, channel, data,
; 454  :                         NULL, NULL, XML_FROM_RELAXNGP,
; 455  :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,
; 456  :                         NULL, NULL, 0, 0,
; 457  :                         "Memory allocation failed : %s\n", extra);
; 458  :     else
; 459  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	esi
	push	edx
	push	ecx
	call	___xmlRaiseError
	add	esp, 64					; 00000040H

; 763  :     xmlRelaxNGPtr ret;
; 764  : 
; 765  :     ret = (xmlRelaxNGPtr) xmlMalloc(sizeof(xmlRelaxNG));
; 766  :     if (ret == NULL) {
; 767  :         xmlRngPErrMemory(ctxt, NULL);
; 768  :         return (NULL);

	xor	eax, eax
	pop	esi

; 771  : 
; 772  :     return (ret);
; 773  : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:
	xorps	xmm0, xmm0

; 769  :     }
; 770  :     memset(ret, 0, sizeof(xmlRelaxNG));

	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0

; 771  : 
; 772  :     return (ret);
; 773  : }

	pop	ebp
	ret	0
_xmlRelaxNGNewRelaxNG ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGFreeIncludeList
_TEXT	SEGMENT
_incl$ = 8						; size = 4
_xmlRelaxNGFreeIncludeList PROC				; COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _incl$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlRelaxNG
	push	edi
$LL2@xmlRelaxNG:

; 725  :     if (incl->href != NULL)

	mov	eax, DWORD PTR [esi+4]

; 743  :     xmlRelaxNGIncludePtr next;
; 744  : 
; 745  :     while (incl != NULL) {
; 746  :         next = incl->next;

	mov	edi, DWORD PTR [esi]

; 725  :     if (incl->href != NULL)

	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG

; 726  :         xmlFree(incl->href);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlRelaxNG:

; 727  :     if (incl->doc != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN8@xmlRelaxNG

; 728  :         xmlFreeDoc(incl->doc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN8@xmlRelaxNG:

; 729  :     if (incl->schema != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN9@xmlRelaxNG

; 730  :         xmlRelaxNGFree(incl->schema);

	push	eax
	call	_xmlRelaxNGFree
	add	esp, 4
$LN9@xmlRelaxNG:

; 731  :     xmlFree(incl);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 747  :         xmlRelaxNGFreeInclude(incl);
; 748  :         incl = next;

	mov	esi, edi
	test	edi, edi
	jne	SHORT $LL2@xmlRelaxNG
	pop	edi
$LN3@xmlRelaxNG:
	pop	esi

; 749  :     }
; 750  : }

	pop	ebp
	ret	0
_xmlRelaxNGFreeIncludeList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGFreeInclude
_TEXT	SEGMENT
_incl$ = 8						; size = 4
_xmlRelaxNGFreeInclude PROC				; COMDAT

; 721  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _incl$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlRelaxNG

; 722  :     if (incl == NULL)
; 723  :         return;
; 724  : 
; 725  :     if (incl->href != NULL)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG

; 726  :         xmlFree(incl->href);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlRelaxNG:

; 727  :     if (incl->doc != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN4@xmlRelaxNG

; 728  :         xmlFreeDoc(incl->doc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN4@xmlRelaxNG:

; 729  :     if (incl->schema != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN5@xmlRelaxNG

; 730  :         xmlRelaxNGFree(incl->schema);

	push	eax
	call	_xmlRelaxNGFree
	add	esp, 4
$LN5@xmlRelaxNG:

; 731  :     xmlFree(incl);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlRelaxNG:
	pop	esi

; 732  : }

	pop	ebp
	ret	0
_xmlRelaxNGFreeInclude ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGFreeDocumentList
_TEXT	SEGMENT
_next$1$ = 8						; size = 4
_docu$ = 8						; size = 4
_xmlRelaxNGFreeDocumentList PROC			; COMDAT

; 703  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _docu$[ebp]
	test	ebx, ebx
	je	$LN3@xmlRelaxNG
	push	esi
	push	edi
	npad	5
$LL2@xmlRelaxNG:

; 686  :     if (docu->href != NULL)

	mov	eax, DWORD PTR [ebx+4]

; 704  :     xmlRelaxNGDocumentPtr next;
; 705  : 
; 706  :     while (docu != NULL) {
; 707  :         next = docu->next;

	mov	edi, DWORD PTR [ebx]
	mov	DWORD PTR _next$1$[ebp], edi

; 686  :     if (docu->href != NULL)

	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG

; 687  :         xmlFree(docu->href);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlRelaxNG:

; 688  :     if (docu->doc != NULL)

	mov	eax, DWORD PTR [ebx+8]
	test	eax, eax
	je	SHORT $LN8@xmlRelaxNG

; 689  :         xmlFreeDoc(docu->doc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN8@xmlRelaxNG:

; 690  :     if (docu->schema != NULL)

	mov	esi, DWORD PTR [ebx+16]
	test	esi, esi
	je	SHORT $LN11@xmlRelaxNG

; 787  :     if (schema->doc != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN16@xmlRelaxNG

; 788  :         xmlFreeDoc(schema->doc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN16@xmlRelaxNG:

; 789  :     if (schema->defTab != NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN17@xmlRelaxNG

; 790  :         int i;
; 791  : 
; 792  :         for (i = 0; i < schema->defNr; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+32], edi
	jle	SHORT $LN13@xmlRelaxNG
	npad	5
$LL14@xmlRelaxNG:

; 793  :             xmlRelaxNGFreeDefine(schema->defTab[i]);

	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR [eax+edi*4]
	call	_xmlRelaxNGFreeDefine
	inc	edi
	add	esp, 4
	cmp	edi, DWORD PTR [esi+32]
	jl	SHORT $LL14@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
$LN13@xmlRelaxNG:

; 794  :         xmlFree(schema->defTab);

	push	eax
	call	DWORD PTR _xmlFree
	mov	edi, DWORD PTR _next$1$[ebp]
	add	esp, 4
$LN17@xmlRelaxNG:

; 795  :     }
; 796  : 
; 797  :     xmlFree(schema);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlRelaxNG:

; 692  :     xmlFree(docu);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 708  :         xmlRelaxNGFreeDocument(docu);
; 709  :         docu = next;

	mov	ebx, edi
	test	edi, edi
	jne	$LL2@xmlRelaxNG
	pop	edi
	pop	esi
$LN3@xmlRelaxNG:
	pop	ebx

; 710  :     }
; 711  : }

	pop	ebp
	ret	0
_xmlRelaxNGFreeDocumentList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGFreeDocument
_TEXT	SEGMENT
_docu$ = 8						; size = 4
_xmlRelaxNGFreeDocument PROC				; COMDAT

; 682  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _docu$[ebp]
	test	ebx, ebx
	je	$LN1@xmlRelaxNG

; 683  :     if (docu == NULL)
; 684  :         return;
; 685  : 
; 686  :     if (docu->href != NULL)

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG

; 687  :         xmlFree(docu->href);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlRelaxNG:

; 688  :     if (docu->doc != NULL)

	mov	eax, DWORD PTR [ebx+8]
	test	eax, eax
	je	SHORT $LN4@xmlRelaxNG

; 689  :         xmlFreeDoc(docu->doc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN4@xmlRelaxNG:

; 690  :     if (docu->schema != NULL)

	push	esi
	mov	esi, DWORD PTR [ebx+16]
	test	esi, esi
	je	SHORT $LN7@xmlRelaxNG

; 787  :     if (schema->doc != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN12@xmlRelaxNG

; 788  :         xmlFreeDoc(schema->doc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN12@xmlRelaxNG:

; 789  :     if (schema->defTab != NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN13@xmlRelaxNG

; 790  :         int i;
; 791  : 
; 792  :         for (i = 0; i < schema->defNr; i++)

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [esi+32], edi
	jle	SHORT $LN9@xmlRelaxNG
$LL10@xmlRelaxNG:

; 793  :             xmlRelaxNGFreeDefine(schema->defTab[i]);

	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR [eax+edi*4]
	call	_xmlRelaxNGFreeDefine
	inc	edi
	add	esp, 4
	cmp	edi, DWORD PTR [esi+32]
	jl	SHORT $LL10@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
$LN9@xmlRelaxNG:

; 794  :         xmlFree(schema->defTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
$LN13@xmlRelaxNG:

; 795  :     }
; 796  : 
; 797  :     xmlFree(schema);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlRelaxNG:

; 691  :         xmlRelaxNGFreeInnerSchema(docu->schema);
; 692  :     xmlFree(docu);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi
$LN1@xmlRelaxNG:
	pop	ebx

; 693  : }

	pop	ebp
	ret	0
_xmlRelaxNGFreeDocument ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGFreeValidState
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_size$1$ = 12						; size = 4
_state$ = 12						; size = 4
_xmlRelaxNGFreeValidState PROC				; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _state$[ebp]
	test	ebx, ebx
	je	$LN9@xmlRelaxNG

; 1386 :     if (state == NULL)
; 1387 :         return;
; 1388 : 
; 1389 :     if ((ctxt != NULL) && (ctxt->freeState == NULL)) {

	push	esi
	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	SHORT $LN6@xmlRelaxNG
	mov	esi, DWORD PTR [edi+68]
	test	esi, esi
	jne	SHORT $LN19@xmlRelaxNG

; 1390 :         ctxt->freeState = xmlRelaxNGNewStates(ctxt, 40);

	push	40					; 00000028H
	push	edi
	call	_xmlRelaxNGNewStates
	mov	esi, eax
	mov	DWORD PTR [edi+68], eax
	add	esp, 8

; 1391 :     }
; 1392 :     if ((ctxt == NULL) || (ctxt->freeState == NULL)) {

	test	esi, esi
	je	SHORT $LN6@xmlRelaxNG
$LN19@xmlRelaxNG:

; 1062 :     if (states->nbState >= states->maxState) {

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	cmp	ecx, eax
	jl	SHORT $LN15@xmlRelaxNG

; 1063 :         xmlRelaxNGValidStatePtr *tmp;
; 1064 :         int size;
; 1065 : 
; 1066 :         size = states->maxState * 2;

	add	eax, eax
	mov	DWORD PTR _size$1$[ebp], eax

; 1067 :         tmp = (xmlRelaxNGValidStatePtr *) xmlRealloc(states->tabState,

	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1068 :                                                      (size) *
; 1069 :                                                      sizeof
; 1070 :                                                      (xmlRelaxNGValidStatePtr));
; 1071 :         if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlRelaxNG

; 1072 :             xmlRngVErrMemory(ctxt, "adding states\n");

	push	OFFSET ??_C@_0P@NLODGFON@adding?5states?6@
	push	edi
	call	_xmlRngVErrMemory
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 1396 :     } else {
; 1397 :         xmlRelaxNGAddStatesUniq(ctxt, ctxt->freeState, state);
; 1398 :     }
; 1399 : }

	pop	ebp
	ret	0
$LN12@xmlRelaxNG:

; 1076 :         states->maxState = size;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR _size$1$[ebp]
	mov	DWORD PTR [esi+4], eax
$LN15@xmlRelaxNG:

; 1077 :     }
; 1078 :     states->tabState[states->nbState++] = state;

	mov	eax, DWORD PTR [esi+8]
	pop	edi
	mov	DWORD PTR [eax+ecx*4], ebx
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebx

; 1396 :     } else {
; 1397 :         xmlRelaxNGAddStatesUniq(ctxt, ctxt->freeState, state);
; 1398 :     }
; 1399 : }

	pop	ebp
	ret	0
$LN6@xmlRelaxNG:

; 1393 :         if (state->attrs != NULL)

	mov	eax, DWORD PTR [ebx+28]
	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG

; 1394 :             xmlFree(state->attrs);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlRelaxNG:

; 1395 :         xmlFree(state);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
	pop	esi
$LN9@xmlRelaxNG:
	pop	ebx

; 1396 :     } else {
; 1397 :         xmlRelaxNGAddStatesUniq(ctxt, ctxt->freeState, state);
; 1398 :     }
; 1399 : }

	pop	ebp
	ret	0
_xmlRelaxNGFreeValidState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGEqualValidState
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_state1$ = 12						; size = 4
_state2$ = 16						; size = 4
_xmlRelaxNGEqualValidState PROC				; COMDAT

; 1349 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _state1$[ebp]
	test	esi, esi
	je	SHORT $LN6@xmlRelaxNG

; 1350 :     int i;
; 1351 : 
; 1352 :     if ((state1 == NULL) || (state2 == NULL))

	mov	edi, DWORD PTR _state2$[ebp]
	test	edi, edi
	je	SHORT $LN6@xmlRelaxNG

; 1353 :         return (0);
; 1354 :     if (state1 == state2)

	cmp	esi, edi
	je	SHORT $LN3@xmlRelaxNG

; 1355 :         return (1);
; 1356 :     if (state1->node != state2->node)

	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [edi]
	jne	SHORT $LN6@xmlRelaxNG

; 1357 :         return (0);
; 1358 :     if (state1->seq != state2->seq)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [edi+4]
	jne	SHORT $LN6@xmlRelaxNG

; 1359 :         return (0);
; 1360 :     if (state1->nbAttrLeft != state2->nbAttrLeft)

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, DWORD PTR [edi+16]
	jne	SHORT $LN6@xmlRelaxNG

; 1361 :         return (0);
; 1362 :     if (state1->nbAttrs != state2->nbAttrs)

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [edi+8]
	jne	SHORT $LN6@xmlRelaxNG

; 1363 :         return (0);
; 1364 :     if (state1->endvalue != state2->endvalue)

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, DWORD PTR [edi+24]
	jne	SHORT $LN6@xmlRelaxNG

; 1365 :         return (0);
; 1366 :     if ((state1->value != state2->value) &&

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [edi+20]
	cmp	eax, ecx
	je	SHORT $LN22@xmlRelaxNG
	push	ecx
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG
$LN22@xmlRelaxNG:

; 1367 :         (!xmlStrEqual(state1->value, state2->value)))
; 1368 :         return (0);
; 1369 :     for (i = 0; i < state1->nbAttrs; i++) {

	mov	ebx, DWORD PTR [esi+8]
	xor	edx, edx
	test	ebx, ebx
	jle	SHORT $LN3@xmlRelaxNG

; 1370 :         if (state1->attrs[i] != state2->attrs[i])

	mov	ecx, DWORD PTR [esi+28]
	mov	esi, DWORD PTR [edi+28]
	sub	esi, ecx
$LL4@xmlRelaxNG:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [esi+ecx]
	jne	SHORT $LN6@xmlRelaxNG

; 1367 :         (!xmlStrEqual(state1->value, state2->value)))
; 1368 :         return (0);
; 1369 :     for (i = 0; i < state1->nbAttrs; i++) {

	inc	edx
	add	ecx, 4
	cmp	edx, ebx
	jl	SHORT $LL4@xmlRelaxNG
$LN3@xmlRelaxNG:
	pop	edi

; 1371 :             return (0);
; 1372 :     }
; 1373 :     return (1);
; 1374 : }

	pop	esi
	mov	eax, 1
	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlRelaxNG:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlRelaxNGEqualValidState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGFreeInnerSchema
_TEXT	SEGMENT
_schema$ = 8						; size = 4
_xmlRelaxNGFreeInnerSchema PROC				; COMDAT

; 783  : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _schema$[ebp]
	test	edi, edi
	je	$LN1@xmlRelaxNG

; 784  :     if (schema == NULL)
; 785  :         return;
; 786  : 
; 787  :     if (schema->doc != NULL)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG

; 788  :         xmlFreeDoc(schema->doc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN6@xmlRelaxNG:

; 789  :     if (schema->defTab != NULL) {

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	$LN7@xmlRelaxNG

; 790  :         int i;
; 791  : 
; 792  :         for (i = 0; i < schema->defNr; i++)

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [edi+32], ebx
	jle	$LN3@xmlRelaxNG
	push	esi
$LL4@xmlRelaxNG:

; 793  :             xmlRelaxNGFreeDefine(schema->defTab[i]);

	mov	esi, DWORD PTR [eax+ebx*4]
	mov	ecx, eax

; 973  :     if (define == NULL)

	test	esi, esi
	je	$LN2@xmlRelaxNG

; 974  :         return;
; 975  : 
; 976  :     if ((define->type == XML_RELAXNG_VALUE) && (define->attrs != NULL)) {

	cmp	DWORD PTR [esi], 7
	jne	SHORT $LN12@xmlRelaxNG
	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	je	SHORT $LN12@xmlRelaxNG

; 977  :         xmlRelaxNGTypeLibraryPtr lib;
; 978  : 
; 979  :         lib = (xmlRelaxNGTypeLibraryPtr) define->data;

	mov	eax, DWORD PTR [esi+20]

; 980  :         if ((lib != NULL) && (lib->freef != NULL))

	test	eax, eax
	je	SHORT $LN12@xmlRelaxNG
	mov	edx, DWORD PTR [eax+24]
	test	edx, edx
	je	SHORT $LN12@xmlRelaxNG

; 981  :             lib->freef(lib->data, (void *) define->attrs);

	push	ecx
	push	DWORD PTR [eax+4]
	call	edx
	add	esp, 8
$LN12@xmlRelaxNG:

; 982  :     }
; 983  :     if ((define->data != NULL) && (define->type == XML_RELAXNG_INTERLEAVE))

	mov	ecx, DWORD PTR [esi+20]
	mov	eax, ecx
	test	ecx, ecx
	je	SHORT $LN13@xmlRelaxNG
	cmp	DWORD PTR [esi], 19			; 00000013H
	jne	SHORT $LN13@xmlRelaxNG

; 984  :         xmlRelaxNGFreePartition((xmlRelaxNGPartitionPtr) define->data);

	push	ecx
	call	_xmlRelaxNGFreePartition
	mov	eax, DWORD PTR [esi+20]
	add	esp, 4
$LN13@xmlRelaxNG:

; 985  :     if ((define->data != NULL) && (define->type == XML_RELAXNG_CHOICE))

	test	eax, eax
	je	SHORT $LN14@xmlRelaxNG
	cmp	DWORD PTR [esi], 17			; 00000011H
	jne	SHORT $LN14@xmlRelaxNG

; 986  :         xmlHashFree((xmlHashTablePtr) define->data, NULL);

	push	0
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN14@xmlRelaxNG:

; 987  :     if (define->name != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN15@xmlRelaxNG

; 988  :         xmlFree(define->name);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlRelaxNG:

; 989  :     if (define->ns != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN16@xmlRelaxNG

; 990  :         xmlFree(define->ns);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlRelaxNG:

; 991  :     if (define->value != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN17@xmlRelaxNG

; 992  :         xmlFree(define->value);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlRelaxNG:

; 993  :     if (define->contModel != NULL)

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN18@xmlRelaxNG

; 994  :         xmlRegFreeRegexp(define->contModel);

	push	eax
	call	_xmlRegFreeRegexp
	add	esp, 4
$LN18@xmlRelaxNG:

; 995  :     xmlFree(define);

	push	esi
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [edi+36]
	add	esp, 4
	mov	ecx, eax
$LN2@xmlRelaxNG:

; 790  :         int i;
; 791  : 
; 792  :         for (i = 0; i < schema->defNr; i++)

	inc	ebx
	cmp	ebx, DWORD PTR [edi+32]
	jl	$LL4@xmlRelaxNG
	mov	eax, ecx
	pop	esi
$LN3@xmlRelaxNG:

; 794  :         xmlFree(schema->defTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	ebx
$LN7@xmlRelaxNG:

; 795  :     }
; 796  : 
; 797  :     xmlFree(schema);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlRelaxNG:
	pop	edi

; 798  : }

	pop	ebp
	ret	0
_xmlRelaxNGFreeInnerSchema ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGNormExtSpace
_TEXT	SEGMENT
_value$ = 8						; size = 4
_xmlRelaxNGNormExtSpace PROC				; COMDAT

; 6889 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _value$[ebp]
	mov	ecx, esi
	test	esi, esi
	je	$LN12@xmlRelaxNG
	npad	5
$LL2@xmlRelaxNG:

; 6890 :     xmlChar *start = value;
; 6891 :     xmlChar *cur = value;
; 6892 : 
; 6893 :     if (value == NULL)
; 6894 :         return;
; 6895 : 
; 6896 :     while (IS_BLANK_CH(*cur))

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN19@xmlRelaxNG
	cmp	al, 9
	jb	SHORT $LN20@xmlRelaxNG
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN19@xmlRelaxNG
$LN20@xmlRelaxNG:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN3@xmlRelaxNG
$LN19@xmlRelaxNG:

; 6897 :         cur++;

	inc	ecx
	jmp	SHORT $LL2@xmlRelaxNG
$LN3@xmlRelaxNG:

; 6898 :     if (cur == start) {

	cmp	ecx, esi
	jne	SHORT $LL13@xmlRelaxNG

; 6899 :         do {
; 6900 :             while ((*cur != 0) && (!IS_BLANK_CH(*cur)))

	test	al, al
	je	$LN12@xmlRelaxNG
$LN80@xmlRelaxNG:
	mov	dl, al
$LL7@xmlRelaxNG:
	mov	al, dl
	cmp	dl, 32					; 00000020H
	je	SHORT $LN8@xmlRelaxNG
	cmp	dl, 9
	jb	SHORT $LN23@xmlRelaxNG
	cmp	dl, 10					; 0000000aH
	jbe	SHORT $LN8@xmlRelaxNG
$LN23@xmlRelaxNG:
	mov	al, dl
	cmp	dl, 13					; 0000000dH
	je	SHORT $LN8@xmlRelaxNG
	mov	al, BYTE PTR [ecx+1]

; 6901 :                 cur++;

	inc	ecx
	mov	dl, al
	test	al, al
	jne	SHORT $LL7@xmlRelaxNG
$LN8@xmlRelaxNG:

; 6902 :             if (*cur == 0)

	test	al, al
	je	SHORT $LN12@xmlRelaxNG

; 6903 :                 return;
; 6904 :             start = cur;

	mov	edx, ecx
	npad	5
$LL9@xmlRelaxNG:

; 6905 :             while (IS_BLANK_CH(*cur))

	cmp	al, 32					; 00000020H
	je	SHORT $LN25@xmlRelaxNG
	cmp	al, 9
	jb	SHORT $LN26@xmlRelaxNG
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN25@xmlRelaxNG
$LN26@xmlRelaxNG:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN10@xmlRelaxNG
$LN25@xmlRelaxNG:

; 6906 :                 cur++;

	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	jmp	SHORT $LL9@xmlRelaxNG
$LN10@xmlRelaxNG:

; 6907 :             if (*cur == 0) {

	test	al, al
	jne	SHORT $LN80@xmlRelaxNG

; 6908 :                 *start = 0;

	mov	BYTE PTR [edx], al
	pop	esi

; 6928 :         } while (1);
; 6929 :     }
; 6930 : }

	pop	ebp
	ret	0
	npad	1
$LL13@xmlRelaxNG:

; 6909 :                 return;
; 6910 :             }
; 6911 :         } while (1);
; 6912 :     } else {
; 6913 :         do {
; 6914 :             while ((*cur != 0) && (!IS_BLANK_CH(*cur)))

	test	al, al
	je	SHORT $LN46@xmlRelaxNG
$LL14@xmlRelaxNG:
	mov	dl, al
	cmp	al, 32					; 00000020H
	je	SHORT $LN15@xmlRelaxNG
	cmp	al, 9
	jb	SHORT $LN28@xmlRelaxNG
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN15@xmlRelaxNG
$LN28@xmlRelaxNG:
	mov	dl, al
	cmp	al, 13					; 0000000dH
	je	SHORT $LN15@xmlRelaxNG

; 6915 :                 *start++ = *cur++;

	inc	ecx
	mov	BYTE PTR [esi], al
	inc	esi
	mov	al, BYTE PTR [ecx]
	mov	dl, al
	test	al, al
	jne	SHORT $LL14@xmlRelaxNG
$LN15@xmlRelaxNG:

; 6916 :             if (*cur == 0) {

	test	dl, dl
	je	SHORT $LN46@xmlRelaxNG
$LL16@xmlRelaxNG:

; 6917 :                 *start = 0;
; 6918 :                 return;
; 6919 :             }
; 6920 :             /* don't try to normalize the inner spaces */
; 6921 :             while (IS_BLANK_CH(*cur))

	cmp	dl, 32					; 00000020H
	je	SHORT $LN30@xmlRelaxNG
	cmp	dl, 9
	jb	SHORT $LN31@xmlRelaxNG
	cmp	dl, 10					; 0000000aH
	jbe	SHORT $LN30@xmlRelaxNG
$LN31@xmlRelaxNG:
	cmp	dl, 13					; 0000000dH
	jne	SHORT $LN17@xmlRelaxNG
$LN30@xmlRelaxNG:

; 6922 :                 cur++;

	mov	dl, BYTE PTR [ecx+1]
	inc	ecx
	jmp	SHORT $LL16@xmlRelaxNG
$LN17@xmlRelaxNG:

; 6923 :             if (*cur == 0) {

	test	dl, dl
	je	SHORT $LN46@xmlRelaxNG

; 6924 :                 *start = 0;
; 6925 :                 return;
; 6926 :             }
; 6927 :             *start++ = *cur++;

	mov	BYTE PTR [esi], dl
	inc	esi
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	jmp	SHORT $LL13@xmlRelaxNG
$LN46@xmlRelaxNG:

; 6928 :         } while (1);
; 6929 :     }
; 6930 : }

	mov	BYTE PTR [esi], 0
$LN12@xmlRelaxNG:
	pop	esi
	pop	ebp
	ret	0
_xmlRelaxNGNormExtSpace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGFreeDefine
_TEXT	SEGMENT
_define$ = 8						; size = 4
_xmlRelaxNGFreeDefine PROC				; COMDAT

; 972  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _define$[ebp]
	test	esi, esi
	je	$LN1@xmlRelaxNG

; 973  :     if (define == NULL)
; 974  :         return;
; 975  : 
; 976  :     if ((define->type == XML_RELAXNG_VALUE) && (define->attrs != NULL)) {

	cmp	DWORD PTR [esi], 7
	jne	SHORT $LN4@xmlRelaxNG
	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	je	SHORT $LN4@xmlRelaxNG

; 977  :         xmlRelaxNGTypeLibraryPtr lib;
; 978  : 
; 979  :         lib = (xmlRelaxNGTypeLibraryPtr) define->data;

	mov	eax, DWORD PTR [esi+20]

; 980  :         if ((lib != NULL) && (lib->freef != NULL))

	test	eax, eax
	je	SHORT $LN4@xmlRelaxNG
	mov	edx, DWORD PTR [eax+24]
	test	edx, edx
	je	SHORT $LN4@xmlRelaxNG

; 981  :             lib->freef(lib->data, (void *) define->attrs);

	push	ecx
	push	DWORD PTR [eax+4]
	call	edx
	add	esp, 8
$LN4@xmlRelaxNG:

; 982  :     }
; 983  :     if ((define->data != NULL) && (define->type == XML_RELAXNG_INTERLEAVE))

	mov	ecx, DWORD PTR [esi+20]
	mov	eax, ecx
	test	ecx, ecx
	je	SHORT $LN5@xmlRelaxNG
	cmp	DWORD PTR [esi], 19			; 00000013H
	jne	SHORT $LN5@xmlRelaxNG

; 984  :         xmlRelaxNGFreePartition((xmlRelaxNGPartitionPtr) define->data);

	push	ecx
	call	_xmlRelaxNGFreePartition
	mov	eax, DWORD PTR [esi+20]
	add	esp, 4
$LN5@xmlRelaxNG:

; 985  :     if ((define->data != NULL) && (define->type == XML_RELAXNG_CHOICE))

	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG
	cmp	DWORD PTR [esi], 17			; 00000011H
	jne	SHORT $LN6@xmlRelaxNG

; 986  :         xmlHashFree((xmlHashTablePtr) define->data, NULL);

	push	0
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN6@xmlRelaxNG:

; 987  :     if (define->name != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG

; 988  :         xmlFree(define->name);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlRelaxNG:

; 989  :     if (define->ns != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN8@xmlRelaxNG

; 990  :         xmlFree(define->ns);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlRelaxNG:

; 991  :     if (define->value != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN9@xmlRelaxNG

; 992  :         xmlFree(define->value);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlRelaxNG:

; 993  :     if (define->contModel != NULL)

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN10@xmlRelaxNG

; 994  :         xmlRegFreeRegexp(define->contModel);

	push	eax
	call	_xmlRegFreeRegexp
	add	esp, 4
$LN10@xmlRelaxNG:

; 995  :     xmlFree(define);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlRelaxNG:
	pop	esi

; 996  : }

	pop	ebp
	ret	0
_xmlRelaxNGFreeDefine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGFreeGrammar
_TEXT	SEGMENT
_grammar$ = 8						; size = 4
_xmlRelaxNGFreeGrammar PROC				; COMDAT

; 862  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _grammar$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlRelaxNG

; 863  :     if (grammar == NULL)
; 864  :         return;
; 865  : 
; 866  :     if (grammar->children != NULL) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG

; 867  :         xmlRelaxNGFreeGrammar(grammar->children);

	push	eax
	call	_xmlRelaxNGFreeGrammar
	add	esp, 4
$LN3@xmlRelaxNG:

; 868  :     }
; 869  :     if (grammar->next != NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN4@xmlRelaxNG

; 870  :         xmlRelaxNGFreeGrammar(grammar->next);

	push	eax
	call	_xmlRelaxNGFreeGrammar
	add	esp, 4
$LN4@xmlRelaxNG:

; 871  :     }
; 872  :     if (grammar->refs != NULL) {

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN5@xmlRelaxNG

; 873  :         xmlHashFree(grammar->refs, NULL);

	push	0
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN5@xmlRelaxNG:

; 874  :     }
; 875  :     if (grammar->defs != NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG

; 876  :         xmlHashFree(grammar->defs, NULL);

	push	0
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN6@xmlRelaxNG:

; 877  :     }
; 878  : 
; 879  :     xmlFree(grammar);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlRelaxNG:
	pop	esi

; 880  : }

	pop	ebp
	ret	0
_xmlRelaxNGFreeGrammar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRngVErr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_error$ = 16						; size = 4
_msg$ = 20						; size = 4
_str1$ = 24						; size = 4
_str2$ = 28						; size = 4
_xmlRngVErr PROC					; COMDAT

; 548  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	edx, edx
	xor	esi, esi
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN2@xmlRngVErr

; 549  :     xmlStructuredErrorFunc schannel = NULL;
; 550  :     xmlGenericErrorFunc channel = NULL;
; 551  :     void *data = NULL;
; 552  : 
; 553  :     if (ctxt != NULL) {
; 554  :         if (ctxt->serror != NULL)

	mov	edx, DWORD PTR [eax+12]
	test	edx, edx
	jne	SHORT $LN4@xmlRngVErr

; 555  : 	    schannel = ctxt->serror;
; 556  : 	else
; 557  : 	    channel = ctxt->error;

	mov	esi, DWORD PTR [eax+4]
$LN4@xmlRngVErr:

; 558  :         data = ctxt->userData;

	mov	edi, DWORD PTR [eax]

; 559  :         ctxt->nbErrors++;

	inc	DWORD PTR [eax+16]
$LN2@xmlRngVErr:

; 560  :     }
; 561  :     __xmlRaiseError(schannel, channel, data,

	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	19					; 00000013H
	push	DWORD PTR _node$[ebp]
	push	0
	push	edi
	push	esi
	push	edx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
	pop	edi
	pop	esi

; 562  :                     NULL, node, XML_FROM_RELAXNGV,
; 563  :                     error, XML_ERR_ERROR, NULL, 0,
; 564  :                     (const char *) str1, (const char *) str2, NULL, 0, 0,
; 565  :                     msg, str1, str2);
; 566  : }

	pop	ebp
	ret	0
_xmlRngVErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRngPErr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_error$ = 16						; size = 4
_msg$ = 20						; size = 4
_str1$ = 24						; size = 4
_str2$ = 28						; size = 4
_xmlRngPErr PROC					; COMDAT

; 514  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	edx, edx
	xor	esi, esi
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN2@xmlRngPErr

; 515  :     xmlStructuredErrorFunc schannel = NULL;
; 516  :     xmlGenericErrorFunc channel = NULL;
; 517  :     void *data = NULL;
; 518  : 
; 519  :     if (ctxt != NULL) {
; 520  :         if (ctxt->serror != NULL)

	mov	edx, DWORD PTR [eax+12]
	test	edx, edx
	jne	SHORT $LN4@xmlRngPErr

; 521  : 	    schannel = ctxt->serror;
; 522  : 	else
; 523  : 	    channel = ctxt->error;

	mov	esi, DWORD PTR [eax+4]
$LN4@xmlRngPErr:

; 524  :         data = ctxt->userData;

	mov	edi, DWORD PTR [eax]

; 525  :         ctxt->nbErrors++;

	inc	DWORD PTR [eax+36]
$LN2@xmlRngPErr:

; 526  :     }
; 527  :     __xmlRaiseError(schannel, channel, data,

	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	18					; 00000012H
	push	DWORD PTR _node$[ebp]
	push	0
	push	edi
	push	esi
	push	edx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
	pop	edi
	pop	esi

; 528  :                     NULL, node, XML_FROM_RELAXNGP,
; 529  :                     error, XML_ERR_ERROR, NULL, 0,
; 530  :                     (const char *) str1, (const char *) str2, NULL, 0, 0,
; 531  :                     msg, str1, str2);
; 532  : }

	pop	ebp
	ret	0
_xmlRngPErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRngVErrMemory
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlRngVErrMemory PROC					; COMDAT

; 474  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	xor	edx, edx
	xor	esi, esi
	test	eax, eax
	je	SHORT $LN2@xmlRngVErr

; 475  :     xmlStructuredErrorFunc schannel = NULL;
; 476  :     xmlGenericErrorFunc channel = NULL;
; 477  :     void *data = NULL;
; 478  : 
; 479  :     if (ctxt != NULL) {
; 480  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN4@xmlRngVErr

; 481  : 	    schannel = ctxt->serror;
; 482  : 	else
; 483  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [eax+4]
$LN4@xmlRngVErr:

; 484  :         data = ctxt->userData;

	mov	esi, DWORD PTR [eax]

; 485  :         ctxt->nbErrors++;

	inc	DWORD PTR [eax+16]
$LN2@xmlRngVErr:

; 486  :     }
; 487  :     if (extra)

	mov	eax, DWORD PTR _extra$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlRngVErr

; 488  :         __xmlRaiseError(schannel, channel, data,

	push	eax
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	3
	push	2
	push	19					; 00000013H
	push	0
	push	0
	push	esi
	push	edx
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	esi

; 495  :                         NULL, NULL, XML_FROM_RELAXNGV,
; 496  :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, NULL,
; 497  :                         NULL, NULL, 0, 0, "Memory allocation failed\n");
; 498  : }

	pop	ebp
	ret	0
$LN5@xmlRngVErr:

; 489  :                         NULL, NULL, XML_FROM_RELAXNGV,
; 490  :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,
; 491  :                         NULL, NULL, 0, 0,
; 492  :                         "Memory allocation failed : %s\n", extra);
; 493  :     else
; 494  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	2
	push	19					; 00000013H
	push	0
	push	0
	push	esi
	push	edx
	push	ecx
	call	___xmlRaiseError
	add	esp, 64					; 00000040H
	pop	esi

; 495  :                         NULL, NULL, XML_FROM_RELAXNGV,
; 496  :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, NULL,
; 497  :                         NULL, NULL, 0, 0, "Memory allocation failed\n");
; 498  : }

	pop	ebp
	ret	0
_xmlRngVErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRngPErrMemory
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlRngPErrMemory PROC					; COMDAT

; 439  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	xor	edx, edx
	xor	esi, esi
	test	eax, eax
	je	SHORT $LN2@xmlRngPErr

; 440  :     xmlStructuredErrorFunc schannel = NULL;
; 441  :     xmlGenericErrorFunc channel = NULL;
; 442  :     void *data = NULL;
; 443  : 
; 444  :     if (ctxt != NULL) {
; 445  :         if (ctxt->serror != NULL)

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN4@xmlRngPErr

; 446  : 	    schannel = ctxt->serror;
; 447  : 	else
; 448  : 	    channel = ctxt->error;

	mov	edx, DWORD PTR [eax+4]
$LN4@xmlRngPErr:

; 449  :         data = ctxt->userData;

	mov	esi, DWORD PTR [eax]

; 450  :         ctxt->nbErrors++;

	inc	DWORD PTR [eax+36]
$LN2@xmlRngPErr:

; 451  :     }
; 452  :     if (extra)

	mov	eax, DWORD PTR _extra$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlRngPErr

; 453  :         __xmlRaiseError(schannel, channel, data,

	push	eax
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	esi
	push	edx
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	esi

; 460  :                         NULL, NULL, XML_FROM_RELAXNGP,
; 461  :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, NULL,
; 462  :                         NULL, NULL, 0, 0, "Memory allocation failed\n");
; 463  : }

	pop	ebp
	ret	0
$LN5@xmlRngPErr:

; 454  :                         NULL, NULL, XML_FROM_RELAXNGP,
; 455  :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,
; 456  :                         NULL, NULL, 0, 0,
; 457  :                         "Memory allocation failed : %s\n", extra);
; 458  :     else
; 459  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	2
	push	18					; 00000012H
	push	0
	push	0
	push	esi
	push	edx
	push	ecx
	call	___xmlRaiseError
	add	esp, 64					; 00000040H
	pop	esi

; 460  :                         NULL, NULL, XML_FROM_RELAXNGP,
; 461  :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, NULL,
; 462  :                         NULL, NULL, 0, 0, "Memory allocation failed\n");
; 463  : }

	pop	ebp
	ret	0
_xmlRngPErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidateFullElement
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_elem$ = 16						; size = 4
_xmlRelaxNGValidateFullElement PROC			; COMDAT

; 8484 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlRelaxNG

; 8485 :     int ret;
; 8486 :     xmlRelaxNGValidStatePtr state;
; 8487 : 
; 8488 :     if ((ctxt == NULL) || (ctxt->pdef == NULL) || (elem == NULL))

	cmp	DWORD PTR [esi+108], 0
	je	SHORT $LN3@xmlRelaxNG
	mov	edi, DWORD PTR _elem$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlRelaxNG

; 8490 : #ifdef DEBUG_PROGRESSIVE
; 8491 :     xmlGenericError(xmlGenericErrorContext, "FullElem %s\n", elem->name);
; 8492 : #endif
; 8493 :     state = xmlRelaxNGNewValidState(ctxt, elem->parent);

	push	DWORD PTR [edi+20]
	push	esi
	call	_xmlRelaxNGNewValidState
	add	esp, 8

; 8494 :     if (state == NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG

; 8495 :         return (-1);
; 8496 :     }
; 8497 :     state->seq = elem;

	mov	DWORD PTR [eax+4], edi

; 8498 :     ctxt->state = state;
; 8499 :     ctxt->errNo = XML_RELAXNG_OK;
; 8500 :     ret = xmlRelaxNGValidateDefinition(ctxt, ctxt->pdef);

	push	DWORD PTR [esi+108]
	mov	DWORD PTR [esi+60], eax
	push	esi
	mov	DWORD PTR [esi+40], 0
	call	_xmlRelaxNGValidateDefinition
	add	esp, 8

; 8501 :     if ((ret != 0) || (ctxt->errNo != XML_RELAXNG_OK))

	test	eax, eax
	jne	SHORT $LN7@xmlRelaxNG
	cmp	DWORD PTR [esi+40], eax
	jne	SHORT $LN7@xmlRelaxNG

; 8503 :     else
; 8504 :         ret = 1;

	lea	edi, DWORD PTR [eax+1]
	jmp	SHORT $LN6@xmlRelaxNG
$LN7@xmlRelaxNG:

; 8502 :         ret = -1;

	or	edi, -1
$LN6@xmlRelaxNG:

; 8505 :     xmlRelaxNGFreeValidState(ctxt, ctxt->state);

	push	DWORD PTR [esi+60]
	push	esi
	call	_xmlRelaxNGFreeValidState
	add	esp, 8

; 8506 :     ctxt->state = NULL;

	mov	DWORD PTR [esi+60], 0

; 8507 : #ifdef DEBUG_PROGRESSIVE
; 8508 :     if (ret < 0)
; 8509 :         xmlGenericError(xmlGenericErrorContext, "FullElem %s failed\n",
; 8510 :                         elem->name);
; 8511 : #endif
; 8512 :     return (ret);

	mov	eax, edi
	pop	edi

; 8513 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlRelaxNG:
	pop	edi

; 8489 :         return (-1);

	or	eax, -1

; 8513 : }

	pop	esi
	pop	ebp
	ret	0
_xmlRelaxNGValidateFullElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidatePopElement
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_elem$ = 16						; size = 4
_xmlRelaxNGValidatePopElement PROC			; COMDAT

; 8435 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlRelaxNG

; 8436 :     int ret;
; 8437 :     xmlRegExecCtxtPtr exec;
; 8438 : 
; 8439 :     if ((ctxt == NULL) || (ctxt->elem == NULL) || (elem == NULL))

	cmp	DWORD PTR [esi+84], 0
	je	SHORT $LN3@xmlRelaxNG
	cmp	DWORD PTR _elem$[ebp], 0
	je	SHORT $LN3@xmlRelaxNG

; 8441 : #ifdef DEBUG_PROGRESSIVE
; 8442 :     xmlGenericError(xmlGenericErrorContext, "PopElem %s\n", elem->name);
; 8443 : #endif
; 8444 :     /*
; 8445 :      * verify that we reached a terminal state of the content model.
; 8446 :      */
; 8447 :     exec = xmlRelaxNGElemPop(ctxt);

	push	ebx
	push	edi
	push	esi
	call	_xmlRelaxNGElemPop

; 8448 :     ret = xmlRegExecPushString(exec, NULL, NULL);

	push	0
	mov	edi, eax
	push	0
	push	edi
	call	_xmlRegExecPushString
	add	esp, 16					; 00000010H

; 8449 :     if (ret == 0) {

	test	eax, eax
	jne	SHORT $LN4@xmlRelaxNG

; 8450 :         /*
; 8451 :          * TODO: get some of the names needed to exit the current state of exec
; 8452 :          */
; 8453 :         VALID_ERR2(XML_RELAXNG_ERR_NOELEM, BAD_CAST "");

	push	eax
	push	eax
	push	OFFSET ??_C@_00CNPNBAHC@@
	push	22					; 00000016H
	push	esi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 8454 :         ret = -1;

	or	ebx, -1

; 8456 :         ret = -1;
; 8457 :     } else {
; 8458 :         ret = 1;
; 8459 :     }
; 8460 :     xmlRegFreeExecCtxt(exec);

	push	edi
	call	_xmlRegFreeExecCtxt
	add	esp, 4

; 8461 : #ifdef DEBUG_PROGRESSIVE
; 8462 :     if (ret < 0)
; 8463 :         xmlGenericError(xmlGenericErrorContext, "PopElem %s failed\n",
; 8464 :                         elem->name);
; 8465 : #endif
; 8466 :     return (ret);

	mov	eax, ebx
	pop	edi
	pop	ebx
	pop	esi

; 8467 : }

	pop	ebp
	ret	0
$LN4@xmlRelaxNG:

; 8455 :     } else if (ret < 0) {

	xor	ebx, ebx
	test	eax, eax

; 8456 :         ret = -1;
; 8457 :     } else {
; 8458 :         ret = 1;
; 8459 :     }
; 8460 :     xmlRegFreeExecCtxt(exec);

	push	edi
	setns	bl
	lea	ebx, DWORD PTR [ebx*2-1]
	call	_xmlRegFreeExecCtxt
	add	esp, 4

; 8461 : #ifdef DEBUG_PROGRESSIVE
; 8462 :     if (ret < 0)
; 8463 :         xmlGenericError(xmlGenericErrorContext, "PopElem %s failed\n",
; 8464 :                         elem->name);
; 8465 : #endif
; 8466 :     return (ret);

	mov	eax, ebx
	pop	edi
	pop	ebx
	pop	esi

; 8467 : }

	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 8440 :         return (-1);

	or	eax, -1
	pop	esi

; 8467 : }

	pop	ebp
	ret	0
_xmlRelaxNGValidatePopElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidatePushCData
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_data$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlRelaxNGValidatePushCData PROC			; COMDAT

; 8391 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlRelaxNG

; 8392 :     int ret = 1;
; 8393 : 
; 8394 :     if ((ctxt == NULL) || (ctxt->elem == NULL) || (data == NULL))

	cmp	DWORD PTR [esi+84], 0
	je	SHORT $LN5@xmlRelaxNG
	mov	edx, DWORD PTR _data$[ebp]
	test	edx, edx
	je	SHORT $LN5@xmlRelaxNG

; 8395 :         return (-1);
; 8396 : 
; 8397 : #ifdef DEBUG_PROGRESSIVE
; 8398 :     xmlGenericError(xmlGenericErrorContext, "CDATA %s %d\n", data, len);
; 8399 : #endif
; 8400 : 
; 8401 :     while (*data != 0) {

	mov	cl, BYTE PTR [edx]
	test	cl, cl
	je	SHORT $LN18@xmlRelaxNG
	mov	al, cl
	npad	6
$LL2@xmlRelaxNG:

; 8402 :         if (!IS_BLANK_CH(*data))

	cmp	al, 32					; 00000020H
	je	SHORT $LN6@xmlRelaxNG
	cmp	al, 9
	jb	SHORT $LN7@xmlRelaxNG
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN6@xmlRelaxNG
$LN7@xmlRelaxNG:
	mov	cl, al
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN16@xmlRelaxNG
$LN6@xmlRelaxNG:

; 8395 :         return (-1);
; 8396 : 
; 8397 : #ifdef DEBUG_PROGRESSIVE
; 8398 :     xmlGenericError(xmlGenericErrorContext, "CDATA %s %d\n", data, len);
; 8399 : #endif
; 8400 : 
; 8401 :     while (*data != 0) {

	mov	cl, BYTE PTR [edx+1]

; 8403 :             break;
; 8404 :         data++;

	inc	edx
	mov	al, cl
	test	cl, cl
	jne	SHORT $LL2@xmlRelaxNG
$LN16@xmlRelaxNG:

; 8405 :     }
; 8406 :     if (*data == 0)

	test	cl, cl
	jne	SHORT $LN8@xmlRelaxNG
$LN18@xmlRelaxNG:

; 8412 : #ifdef DEBUG_PROGRESSIVE
; 8413 :         xmlGenericError(xmlGenericErrorContext, "CDATA failed\n");
; 8414 : #endif
; 8415 : 
; 8416 :         return (-1);
; 8417 :     }
; 8418 :     return (1);
; 8419 : }

	mov	eax, 1
	pop	esi
	pop	ebp
	ret	0
$LN8@xmlRelaxNG:

; 8407 :         return (1);
; 8408 : 
; 8409 :     ret = xmlRegExecPushString(ctxt->elem, BAD_CAST "#text", ctxt);

	push	esi
	push	OFFSET ??_C@_05NOBOONOA@?$CDtext@
	push	DWORD PTR [esi+84]
	call	_xmlRegExecPushString
	add	esp, 12					; 0000000cH

; 8410 :     if (ret < 0) {

	test	eax, eax
	jns	SHORT $LN18@xmlRelaxNG

; 8411 :         VALID_ERR2(XML_RELAXNG_ERR_TEXTWRONG, BAD_CAST " TODO ");

	push	0
	push	0
	push	OFFSET ??_C@_06BKKGLNFB@?5TODO?5@
	push	39					; 00000027H
	push	esi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H
$LN5@xmlRelaxNG:

; 8412 : #ifdef DEBUG_PROGRESSIVE
; 8413 :         xmlGenericError(xmlGenericErrorContext, "CDATA failed\n");
; 8414 : #endif
; 8415 : 
; 8416 :         return (-1);
; 8417 :     }
; 8418 :     return (1);
; 8419 : }

	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
_xmlRelaxNGValidatePushCData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidatePushElement
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_elem$ = 16						; size = 4
_xmlRelaxNGValidatePushElement PROC			; COMDAT

; 8313 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN3@xmlRelaxNG

; 8314 :     int ret = 1;
; 8315 : 
; 8316 :     if ((ctxt == NULL) || (elem == NULL))

	mov	edi, DWORD PTR _elem$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlRelaxNG

; 8317 :         return (-1);
; 8318 : 
; 8319 : #ifdef DEBUG_PROGRESSIVE
; 8320 :     xmlGenericError(xmlGenericErrorContext, "PushElem %s\n", elem->name);
; 8321 : #endif
; 8322 :     if (ctxt->elem == 0) {

	cmp	DWORD PTR [esi+84], 0
	jne	SHORT $LN4@xmlRelaxNG

; 8323 :         xmlRelaxNGPtr schema;
; 8324 :         xmlRelaxNGGrammarPtr grammar;
; 8325 :         xmlRegExecCtxtPtr exec;
; 8326 :         xmlRelaxNGDefinePtr define;
; 8327 : 
; 8328 :         schema = ctxt->schema;

	mov	eax, DWORD PTR [esi+20]

; 8329 :         if (schema == NULL) {

	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG

; 8330 :             VALID_ERR(XML_RELAXNG_ERR_NOGRAMMAR);
; 8331 :             return (-1);
; 8332 :         }
; 8333 :         grammar = schema->topgrammar;

	mov	eax, DWORD PTR [eax+4]

; 8334 :         if ((grammar == NULL) || (grammar->start == NULL)) {

	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG

; 8336 :             return (-1);
; 8337 :         }
; 8338 :         define = grammar->start;
; 8339 :         if (define->contModel == NULL) {

	mov	ecx, DWORD PTR [eax+52]
	test	ecx, ecx
	jne	SHORT $LN8@xmlRelaxNG

; 8340 :             ctxt->pdef = define;

	mov	DWORD PTR [esi+108], eax

; 8341 :             return (0);

	xor	eax, eax
	pop	edi

; 8376 : }

	pop	esi
	pop	ebp
	ret	0
$LN8@xmlRelaxNG:

; 8342 :         }
; 8343 :         exec = xmlRegNewExecCtxt(define->contModel,

	push	esi
	push	OFFSET _xmlRelaxNGValidateProgressiveCallback
	push	ecx
	call	_xmlRegNewExecCtxt
	add	esp, 12					; 0000000cH

; 8344 :                                  xmlRelaxNGValidateProgressiveCallback,
; 8345 :                                  ctxt);
; 8346 :         if (exec == NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG

; 8347 :             return (-1);
; 8348 :         }
; 8349 :         xmlRelaxNGElemPush(ctxt, exec);

	push	eax
	push	esi
	call	_xmlRelaxNGElemPush
	add	esp, 8
$LN4@xmlRelaxNG:

; 8350 :     }
; 8351 :     ctxt->pnode = elem;

	mov	DWORD PTR [esi+104], edi

; 8352 :     ctxt->pstate = 0;

	mov	DWORD PTR [esi+100], 0

; 8353 :     if (elem->ns != NULL) {

	mov	eax, DWORD PTR [edi+36]
	push	ebx
	push	esi
	test	eax, eax
	je	SHORT $LN10@xmlRelaxNG

; 8354 :         ret =

	push	DWORD PTR [eax+8]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [esi+84]
	call	_xmlRegExecPushString2
	add	esp, 16					; 00000010H

; 8355 :             xmlRegExecPushString2(ctxt->elem, elem->name, elem->ns->href,
; 8356 :                                   ctxt);
; 8357 :     } else {

	jmp	SHORT $LN19@xmlRelaxNG
$LN7@xmlRelaxNG:

; 8335 :             VALID_ERR(XML_RELAXNG_ERR_NOGRAMMAR);

	push	0
	push	0
	push	0
	push	34					; 00000022H
	push	esi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H
$LN3@xmlRelaxNG:

; 8376 : }

	pop	edi
	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN10@xmlRelaxNG:

; 8358 :         ret = xmlRegExecPushString(ctxt->elem, elem->name, ctxt);

	push	DWORD PTR [edi+8]
	push	DWORD PTR [esi+84]
	call	_xmlRegExecPushString
	add	esp, 12					; 0000000cH
$LN19@xmlRelaxNG:

; 8359 :     }
; 8360 :     if (ret < 0) {

	mov	ebx, eax
	test	ebx, ebx
	jns	SHORT $LN12@xmlRelaxNG

; 8361 :         VALID_ERR2(XML_RELAXNG_ERR_ELEMWRONG, elem->name);

	push	0
	push	0
	push	DWORD PTR [edi+8]
	push	38					; 00000026H
	push	esi
	call	_xmlRelaxNGAddValidError
	add	esp, 20					; 00000014H

; 8366 :             ret = -1;
; 8367 :         else
; 8368 :             ret = 1;
; 8369 :     }
; 8370 : #ifdef DEBUG_PROGRESSIVE
; 8371 :     if (ret < 0)
; 8372 :         xmlGenericError(xmlGenericErrorContext, "PushElem %s failed\n",
; 8373 :                         elem->name);
; 8374 : #endif
; 8375 :     return (ret);

	mov	eax, ebx
	pop	ebx
	pop	edi

; 8376 : }

	pop	esi
	pop	ebp
	ret	0
$LN12@xmlRelaxNG:

; 8362 :     } else {
; 8363 :         if (ctxt->pstate == 0)

	mov	eax, DWORD PTR [esi+100]
	xor	ebx, ebx
	test	eax, eax
	je	SHORT $LN16@xmlRelaxNG

; 8364 :             ret = 0;
; 8365 :         else if (ctxt->pstate < 0)

	setns	bl
	lea	ebx, DWORD PTR [ebx*2-1]
$LN16@xmlRelaxNG:

; 8366 :             ret = -1;
; 8367 :         else
; 8368 :             ret = 1;
; 8369 :     }
; 8370 : #ifdef DEBUG_PROGRESSIVE
; 8371 :     if (ret < 0)
; 8372 :         xmlGenericError(xmlGenericErrorContext, "PushElem %s failed\n",
; 8373 :                         elem->name);
; 8374 : #endif
; 8375 :     return (ret);

	mov	eax, ebx
	pop	ebx
	pop	edi

; 8376 : }

	pop	esi
	pop	ebp
	ret	0
_xmlRelaxNGValidatePushElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGValidateDoc
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlRelaxNGValidateDoc PROC				; COMDAT

; 11061: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG

; 11062:     int ret;
; 11063: 
; 11064:     if ((ctxt == NULL) || (doc == NULL))

	mov	esi, DWORD PTR _doc$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlRelaxNG

; 11066: 
; 11067:     ctxt->doc = doc;
; 11068: 
; 11069:     ret = xmlRelaxNGValidateDocument(ctxt, doc);

	push	esi
	push	eax
	mov	DWORD PTR [eax+24], esi
	call	_xmlRelaxNGValidateDocument

; 10860:     if ((node == NULL) ||

	mov	ecx, DWORD PTR [esi+4]

; 11066: 
; 11067:     ctxt->doc = doc;
; 11068: 
; 11069:     ret = xmlRelaxNGValidateDocument(ctxt, doc);

	add	esp, 8
	mov	edx, eax

; 10860:     if ((node == NULL) ||

	cmp	ecx, 1
	je	SHORT $LN37@xmlRelaxNG
	cmp	ecx, 9
	je	SHORT $LN14@xmlRelaxNG
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN44@xmlRelaxNG

; 10861:         ((node->type != XML_ELEMENT_NODE) &&
; 10862:          (node->type != XML_DOCUMENT_NODE) &&
; 10863:          (node->type != XML_HTML_DOCUMENT_NODE)))
; 10864: 	return;
; 10865:     if (node->type == XML_ELEMENT_NODE)

	jmp	SHORT $LN14@xmlRelaxNG
$LN37@xmlRelaxNG:

; 10866:         node->psvi = NULL;

	mov	DWORD PTR [esi+52], 0
$LN14@xmlRelaxNG:

; 10867: 
; 10868:     cur = node->children;

	mov	eax, DWORD PTR [esi+12]

; 10869:     while (cur != NULL) {

	test	eax, eax
	je	SHORT $LN44@xmlRelaxNG
	npad	3
$LL7@xmlRelaxNG:

; 10870: 	if (cur->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN16@xmlRelaxNG

; 10871: 	    cur->psvi = NULL;
; 10872: 	    if (cur->children != NULL) {

	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+52], 0
	test	ecx, ecx
	jne	SHORT $LN46@xmlRelaxNG

; 10873: 		cur = cur->children;
; 10874: 		continue;
; 10875: 	    }
; 10876: 	}
; 10877: 	if (cur->next != NULL) {
; 10878: 	    cur = cur->next;
; 10879: 	    continue;

	jmp	SHORT $LN16@xmlRelaxNG
$LL11@xmlRelaxNG:

; 10880: 	}
; 10881: 	do {
; 10882: 	    cur = cur->parent;

	mov	eax, DWORD PTR [eax+20]

; 10883: 	    if (cur == NULL)

	test	eax, eax
	je	SHORT $LN44@xmlRelaxNG

; 10884: 		break;
; 10885: 	    if (cur == node) {

	cmp	eax, esi
	je	SHORT $LN44@xmlRelaxNG
$LN16@xmlRelaxNG:

; 10869:     while (cur != NULL) {

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LL11@xmlRelaxNG
$LN46@xmlRelaxNG:
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LL7@xmlRelaxNG
$LN44@xmlRelaxNG:

; 11070:     /*
; 11071:      * Remove all left PSVI
; 11072:      */
; 11073:     xmlRelaxNGCleanPSVI((xmlNodePtr) doc);
; 11074: 
; 11075:     /*
; 11076:      * TODO: build error codes
; 11077:      */
; 11078:     if (ret == -1)

	mov	eax, 1
	cmp	edx, -1
	pop	esi
	cmove	edx, eax
	mov	eax, edx

; 11079:         return (1);
; 11080:     return (ret);
; 11081: }

	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 11065:         return (-1);

	or	eax, -1
	pop	esi

; 11079:         return (1);
; 11080:     return (ret);
; 11081: }

	pop	ebp
	ret	0
_xmlRelaxNGValidateDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGFreeValidCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlRelaxNGFreeValidCtxt PROC				; COMDAT

; 10946: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN1@xmlRelaxNG

; 10947:     int k;
; 10948: 
; 10949:     if (ctxt == NULL)
; 10950:         return;
; 10951:     if (ctxt->states != NULL)

	push	ebx
	push	edi
	mov	edi, DWORD PTR [esi+64]
	test	edi, edi
	je	SHORT $LN25@xmlRelaxNG

; 1167 :         xmlFree(states->tabState);

	push	DWORD PTR [edi+8]
	call	DWORD PTR _xmlFree

; 1168 :         xmlFree(states);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 8
$LN25@xmlRelaxNG:

; 10952:         xmlRelaxNGFreeStates(NULL, ctxt->states);
; 10953:     if (ctxt->freeState != NULL) {

	mov	edi, DWORD PTR [esi+68]
	test	edi, edi
	je	SHORT $LN49@xmlRelaxNG

; 10954:         for (k = 0; k < ctxt->freeState->nbState; k++) {

	xor	ebx, ebx
	cmp	DWORD PTR [edi], ebx
	jle	SHORT $LN3@xmlRelaxNG
$LL4@xmlRelaxNG:

; 10955:             xmlRelaxNGFreeValidState(NULL, ctxt->freeState->tabState[k]);

	mov	eax, DWORD PTR [edi+8]
	mov	edi, DWORD PTR [eax+ebx*4]

; 1386 :     if (state == NULL)

	test	edi, edi
	je	SHORT $LN2@xmlRelaxNG

; 1387 :         return;
; 1388 : 
; 1389 :     if ((ctxt != NULL) && (ctxt->freeState == NULL)) {
; 1390 :         ctxt->freeState = xmlRelaxNGNewStates(ctxt, 40);
; 1391 :     }
; 1392 :     if ((ctxt == NULL) || (ctxt->freeState == NULL)) {
; 1393 :         if (state->attrs != NULL)

	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	je	SHORT $LN34@xmlRelaxNG

; 1394 :             xmlFree(state->attrs);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN34@xmlRelaxNG:

; 1395 :         xmlFree(state);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlRelaxNG:

; 10954:         for (k = 0; k < ctxt->freeState->nbState; k++) {

	mov	edi, DWORD PTR [esi+68]
	inc	ebx
	cmp	ebx, DWORD PTR [edi]
	jl	SHORT $LL4@xmlRelaxNG
$LN3@xmlRelaxNG:

; 1139 :     if (states == NULL)

	test	edi, edi
	je	SHORT $LN49@xmlRelaxNG

; 1140 :         return;
; 1141 :     if ((ctxt != NULL) && (ctxt->freeStates == NULL)) {
; 1142 :         ctxt->freeStatesMax = 40;
; 1143 :         ctxt->freeStatesNr = 0;
; 1144 :         ctxt->freeStates = (xmlRelaxNGStatesPtr *)
; 1145 :             xmlMalloc(ctxt->freeStatesMax * sizeof(xmlRelaxNGStatesPtr));
; 1146 :         if (ctxt->freeStates == NULL) {
; 1147 :             xmlRngVErrMemory(ctxt, "storing states\n");
; 1148 :         }
; 1149 :     } else if ((ctxt != NULL)
; 1150 :                && (ctxt->freeStatesNr >= ctxt->freeStatesMax)) {
; 1151 :         xmlRelaxNGStatesPtr *tmp;
; 1152 : 
; 1153 :         tmp = (xmlRelaxNGStatesPtr *) xmlRealloc(ctxt->freeStates,
; 1154 :                                                  2 * ctxt->freeStatesMax *
; 1155 :                                                  sizeof
; 1156 :                                                  (xmlRelaxNGStatesPtr));
; 1157 :         if (tmp == NULL) {
; 1158 :             xmlRngVErrMemory(ctxt, "storing states\n");
; 1159 :             xmlFree(states->tabState);
; 1160 :             xmlFree(states);
; 1161 :             return;
; 1162 :         }
; 1163 :         ctxt->freeStates = tmp;
; 1164 :         ctxt->freeStatesMax *= 2;
; 1165 :     }
; 1166 :     if ((ctxt == NULL) || (ctxt->freeStates == NULL)) {
; 1167 :         xmlFree(states->tabState);

	push	DWORD PTR [edi+8]
	call	DWORD PTR _xmlFree

; 1168 :         xmlFree(states);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 8
$LN49@xmlRelaxNG:

; 10956:         }
; 10957:         xmlRelaxNGFreeStates(NULL, ctxt->freeState);
; 10958:     }
; 10959:     if (ctxt->freeStates != NULL) {

	mov	eax, DWORD PTR [esi+80]
	test	eax, eax
	je	SHORT $LN13@xmlRelaxNG

; 10960:         for (k = 0; k < ctxt->freeStatesNr; k++) {

	xor	edi, edi
	cmp	DWORD PTR [esi+72], edi
	jle	SHORT $LN6@xmlRelaxNG

; 10961:             xmlRelaxNGFreeStates(NULL, ctxt->freeStates[k]);

	mov	ecx, eax
$LL7@xmlRelaxNG:
	mov	ebx, DWORD PTR [eax+edi*4]

; 1139 :     if (states == NULL)

	test	ebx, ebx
	je	SHORT $LN5@xmlRelaxNG

; 1140 :         return;
; 1141 :     if ((ctxt != NULL) && (ctxt->freeStates == NULL)) {
; 1142 :         ctxt->freeStatesMax = 40;
; 1143 :         ctxt->freeStatesNr = 0;
; 1144 :         ctxt->freeStates = (xmlRelaxNGStatesPtr *)
; 1145 :             xmlMalloc(ctxt->freeStatesMax * sizeof(xmlRelaxNGStatesPtr));
; 1146 :         if (ctxt->freeStates == NULL) {
; 1147 :             xmlRngVErrMemory(ctxt, "storing states\n");
; 1148 :         }
; 1149 :     } else if ((ctxt != NULL)
; 1150 :                && (ctxt->freeStatesNr >= ctxt->freeStatesMax)) {
; 1151 :         xmlRelaxNGStatesPtr *tmp;
; 1152 : 
; 1153 :         tmp = (xmlRelaxNGStatesPtr *) xmlRealloc(ctxt->freeStates,
; 1154 :                                                  2 * ctxt->freeStatesMax *
; 1155 :                                                  sizeof
; 1156 :                                                  (xmlRelaxNGStatesPtr));
; 1157 :         if (tmp == NULL) {
; 1158 :             xmlRngVErrMemory(ctxt, "storing states\n");
; 1159 :             xmlFree(states->tabState);
; 1160 :             xmlFree(states);
; 1161 :             return;
; 1162 :         }
; 1163 :         ctxt->freeStates = tmp;
; 1164 :         ctxt->freeStatesMax *= 2;
; 1165 :     }
; 1166 :     if ((ctxt == NULL) || (ctxt->freeStates == NULL)) {
; 1167 :         xmlFree(states->tabState);

	push	DWORD PTR [ebx+8]
	call	DWORD PTR _xmlFree

; 1168 :         xmlFree(states);

	push	ebx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [esi+80]
	add	esp, 8
	mov	ecx, eax
$LN5@xmlRelaxNG:

; 10960:         for (k = 0; k < ctxt->freeStatesNr; k++) {

	inc	edi
	cmp	edi, DWORD PTR [esi+72]
	jl	SHORT $LL7@xmlRelaxNG
	mov	eax, ecx
$LN6@xmlRelaxNG:

; 10962:         }
; 10963:         xmlFree(ctxt->freeStates);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlRelaxNG:

; 10964:     }
; 10965:     if (ctxt->errTab != NULL)

	mov	eax, DWORD PTR [esi+56]
	pop	edi
	pop	ebx
	test	eax, eax
	je	SHORT $LN14@xmlRelaxNG

; 10966:         xmlFree(ctxt->errTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlRelaxNG:

; 10967:     if (ctxt->elemTab != NULL) {

	mov	ecx, DWORD PTR [esi+96]
	test	ecx, ecx
	je	SHORT $LN15@xmlRelaxNG

; 8141 :     if (ctxt->elemNr <= 0)

	mov	eax, DWORD PTR [esi+88]
	test	eax, eax
	jle	SHORT $LN100@xmlRelaxNG

; 8142 :         return (NULL);
; 8143 :     ctxt->elemNr--;

	dec	eax
	mov	DWORD PTR [esi+88], eax

; 8144 :     ret = ctxt->elemTab[ctxt->elemNr];

	mov	edx, DWORD PTR [ecx+eax*4]

; 8145 :     ctxt->elemTab[ctxt->elemNr] = NULL;

	mov	DWORD PTR [ecx+eax*4], 0

; 8146 :     if (ctxt->elemNr > 0)

	mov	ecx, DWORD PTR [esi+88]
	test	ecx, ecx
	jle	SHORT $LN79@xmlRelaxNG

; 8147 :         ctxt->elem = ctxt->elemTab[ctxt->elemNr - 1];

	mov	eax, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN80@xmlRelaxNG
$LN79@xmlRelaxNG:

; 8148 :     else
; 8149 :         ctxt->elem = NULL;

	xor	eax, eax
$LN80@xmlRelaxNG:

; 8150 :     return (ret);

	mov	DWORD PTR [esi+84], eax

; 10968:         xmlRegExecCtxtPtr exec;
; 10969: 
; 10970:         exec = xmlRelaxNGElemPop(ctxt);
; 10971:         while (exec != NULL) {

	test	edx, edx
	je	SHORT $LN100@xmlRelaxNG
	npad	1
$LL8@xmlRelaxNG:

; 10972:             xmlRegFreeExecCtxt(exec);

	push	edx
	call	_xmlRegFreeExecCtxt

; 8141 :     if (ctxt->elemNr <= 0)

	mov	ecx, DWORD PTR [esi+88]

; 10972:             xmlRegFreeExecCtxt(exec);

	add	esp, 4

; 8141 :     if (ctxt->elemNr <= 0)

	test	ecx, ecx
	jle	SHORT $LN100@xmlRelaxNG

; 8144 :     ret = ctxt->elemTab[ctxt->elemNr];

	mov	eax, DWORD PTR [esi+96]
	dec	ecx
	mov	DWORD PTR [esi+88], ecx
	mov	edx, DWORD PTR [eax+ecx*4]

; 8145 :     ctxt->elemTab[ctxt->elemNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 8146 :     if (ctxt->elemNr > 0)

	mov	ecx, DWORD PTR [esi+88]
	test	ecx, ecx
	jle	SHORT $LN84@xmlRelaxNG

; 8147 :         ctxt->elem = ctxt->elemTab[ctxt->elemNr - 1];

	mov	eax, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN85@xmlRelaxNG
$LN84@xmlRelaxNG:

; 8148 :     else
; 8149 :         ctxt->elem = NULL;

	xor	eax, eax
$LN85@xmlRelaxNG:

; 8150 :     return (ret);

	mov	DWORD PTR [esi+84], eax

; 10968:         xmlRegExecCtxtPtr exec;
; 10969: 
; 10970:         exec = xmlRelaxNGElemPop(ctxt);
; 10971:         while (exec != NULL) {

	test	edx, edx
	jne	SHORT $LL8@xmlRelaxNG
$LN100@xmlRelaxNG:

; 10973:             exec = xmlRelaxNGElemPop(ctxt);
; 10974:         }
; 10975:         xmlFree(ctxt->elemTab);

	push	DWORD PTR [esi+96]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlRelaxNG:

; 10976:     }
; 10977:     xmlFree(ctxt);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlRelaxNG:
	pop	esi

; 10978: }

	pop	ebp
	ret	0
_xmlRelaxNGFreeValidCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGNewValidCtxt
_TEXT	SEGMENT
_schema$ = 8						; size = 4
_xmlRelaxNGNewValidCtxt PROC				; COMDAT

; 10913: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	push	116					; 00000074H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlRelaxNG

; 488  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BC@JDIHBOGI@building?5context?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@JDIHBOGI@building?5context?6@
	push	eax
	push	eax
	push	3
	push	2
	push	19					; 00000013H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 10914:     xmlRelaxNGValidCtxtPtr ret;
; 10915: 
; 10916:     ret = (xmlRelaxNGValidCtxtPtr) xmlMalloc(sizeof(xmlRelaxNGValidCtxt));
; 10917:     if (ret == NULL) {
; 10918:         xmlRngVErrMemory(NULL, "building context\n");
; 10919:         return (NULL);

	xor	eax, eax
	pop	esi

; 10936: }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:
	push	edi

; 10920:     }
; 10921:     memset(ret, 0, sizeof(xmlRelaxNGValidCtxt));

	push	116					; 00000074H
	push	0
	push	esi
	call	_memset

; 10922:     ret->schema = schema;

	mov	edi, DWORD PTR _schema$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+20], edi

; 10923:     ret->error = xmlGenericError;

	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+4], eax

; 10924:     ret->userData = xmlGenericErrorContext;

	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax

; 10925:     ret->errNr = 0;

	mov	DWORD PTR [esi+48], 0

; 10926:     ret->errMax = 0;

	mov	DWORD PTR [esi+52], 0

; 10927:     ret->err = NULL;

	mov	DWORD PTR [esi+44], 0

; 10928:     ret->errTab = NULL;

	mov	DWORD PTR [esi+56], 0

; 10929:     if (schema != NULL)

	test	edi, edi
	je	SHORT $LN3@xmlRelaxNG

; 10930: 	ret->idref = schema->idref;

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+36], eax
$LN3@xmlRelaxNG:

; 10931:     ret->states = NULL;
; 10932:     ret->freeState = NULL;
; 10933:     ret->freeStates = NULL;
; 10934:     ret->errNo = XML_RELAXNG_OK;
; 10935:     return (ret);

	pop	edi
	mov	DWORD PTR [esi+64], 0
	mov	eax, esi
	mov	DWORD PTR [esi+68], 0
	mov	DWORD PTR [esi+80], 0
	mov	DWORD PTR [esi+40], 0
	pop	esi

; 10936: }

	pop	ebp
	ret	0
_xmlRelaxNGNewValidCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGSetValidStructuredErrors
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_serror$ = 12						; size = 4
_ctx$ = 16						; size = 4
_xmlRelaxNGSetValidStructuredErrors PROC		; COMDAT

; 11013: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@xmlRelaxNG

; 11014:     if (ctxt == NULL)
; 11015:         return;
; 11016:     ctxt->serror = serror;

	mov	eax, DWORD PTR _serror$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 11017:     ctxt->error = NULL;
; 11018:     ctxt->warning = NULL;
; 11019:     ctxt->userData = ctx;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx], eax
$LN1@xmlRelaxNG:

; 11020: }

	pop	ebp
	ret	0
_xmlRelaxNGSetValidStructuredErrors ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGGetValidErrors
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_err$ = 12						; size = 4
_warn$ = 16						; size = 4
_ctx$ = 20						; size = 4
_xmlRelaxNGGetValidErrors PROC				; COMDAT

; 11037: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@xmlRelaxNG

; 11038:     if (ctxt == NULL)
; 11039:         return (-1);

	or	eax, -1

; 11047: }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:

; 11040:     if (err != NULL)

	mov	edx, DWORD PTR _err$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlRelaxNG

; 11041:         *err = ctxt->error;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN3@xmlRelaxNG:

; 11042:     if (warn != NULL)

	mov	edx, DWORD PTR _warn$[ebp]
	test	edx, edx
	je	SHORT $LN4@xmlRelaxNG

; 11043:         *warn = ctxt->warning;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax
$LN4@xmlRelaxNG:

; 11044:     if (ctx != NULL)

	mov	edx, DWORD PTR _ctx$[ebp]
	test	edx, edx
	je	SHORT $LN5@xmlRelaxNG

; 11045:         *ctx = ctxt->userData;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
$LN5@xmlRelaxNG:

; 11046:     return (0);

	xor	eax, eax

; 11047: }

	pop	ebp
	ret	0
_xmlRelaxNGGetValidErrors ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGSetValidErrors
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_err$ = 12						; size = 4
_warn$ = 16						; size = 4
_ctx$ = 20						; size = 4
_xmlRelaxNGSetValidErrors PROC				; COMDAT

; 10993: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@xmlRelaxNG

; 10994:     if (ctxt == NULL)
; 10995:         return;
; 10996:     ctxt->error = err;

	mov	eax, DWORD PTR _err$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 10997:     ctxt->warning = warn;

	mov	eax, DWORD PTR _warn$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 10998:     ctxt->userData = ctx;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [ecx], eax

; 10999:     ctxt->serror = NULL;

	mov	DWORD PTR [ecx+12], 0
$LN1@xmlRelaxNG:

; 11000: }

	pop	ebp
	ret	0
_xmlRelaxNGSetValidErrors ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGDumpTree
_TEXT	SEGMENT
_output$ = 8						; size = 4
_schema$ = 12						; size = 4
_xmlRelaxNGDumpTree PROC				; COMDAT

; 7919 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _output$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlRelaxNG

; 7920 :     if (output == NULL)
; 7921 :         return;
; 7922 :     if (schema == NULL) {

	mov	ecx, DWORD PTR _schema$[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@xmlRelaxNG

; 7923 :         fprintf(output, "RelaxNG empty or failed to compile\n");

	mov	DWORD PTR _schema$[ebp], OFFSET ??_C@_0CE@LIIBEOG@RelaxNG?5empty?5or?5failed?5to?5comp@
	mov	DWORD PTR _output$[ebp], eax

; 7930 :     }
; 7931 : }

	pop	ebp

; 7923 :         fprintf(output, "RelaxNG empty or failed to compile\n");

	jmp	_fprintf
$LN3@xmlRelaxNG:

; 7924 :         return;
; 7925 :     }
; 7926 :     if (schema->doc == NULL) {

	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	jne	SHORT $LN4@xmlRelaxNG

; 7927 :         fprintf(output, "no document\n");

	mov	DWORD PTR _schema$[ebp], OFFSET ??_C@_0N@PEHAONBJ@no?5document?6@
	mov	DWORD PTR _output$[ebp], eax

; 7930 :     }
; 7931 : }

	pop	ebp

; 7927 :         fprintf(output, "no document\n");

	jmp	_fprintf
$LN4@xmlRelaxNG:

; 7928 :     } else {
; 7929 :         xmlDocDump(output, schema->doc);

	mov	DWORD PTR _schema$[ebp], ecx
	mov	DWORD PTR _output$[ebp], eax

; 7930 :     }
; 7931 : }

	pop	ebp

; 7928 :     } else {
; 7929 :         xmlDocDump(output, schema->doc);

	jmp	_xmlDocDump
$LN5@xmlRelaxNG:

; 7930 :     }
; 7931 : }

	pop	ebp
	ret	0
_xmlRelaxNGDumpTree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGDump
_TEXT	SEGMENT
_output$ = 8						; size = 4
_schema$ = 12						; size = 4
_xmlRelaxNGDump PROC					; COMDAT

; 7888 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	test	esi, esi
	je	$LN10@xmlRelaxNG

; 7889 :     if (output == NULL)
; 7890 :         return;
; 7891 :     if (schema == NULL) {

	push	edi
	mov	edi, DWORD PTR _schema$[ebp]
	test	edi, edi
	jne	SHORT $LN3@xmlRelaxNG

; 7892 :         fprintf(output, "RelaxNG empty or failed to compile\n");

	push	OFFSET ??_C@_0CE@LIIBEOG@RelaxNG?5empty?5or?5failed?5to?5comp@
	push	esi
	call	_fprintf
	add	esp, 8
	pop	edi
	pop	esi

; 7905 :         return;
; 7906 :     }
; 7907 :     xmlRelaxNGDumpGrammar(output, schema->topgrammar, 1);
; 7908 : }

	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 7893 :         return;
; 7894 :     }
; 7895 :     fprintf(output, "RelaxNG: ");

	push	OFFSET ??_C@_09KHOMLKFG@RelaxNG?3?5@
	push	esi
	call	_fprintf

; 7896 :     if (schema->doc == NULL) {

	mov	eax, DWORD PTR [edi+8]
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@xmlRelaxNG

; 7897 :         fprintf(output, "no document\n");

	push	OFFSET ??_C@_0N@PEHAONBJ@no?5document?6@
	jmp	SHORT $LN23@xmlRelaxNG
$LN4@xmlRelaxNG:

; 7898 :     } else if (schema->doc->URL != NULL) {

	mov	eax, DWORD PTR [eax+72]
	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG

; 7899 :         fprintf(output, "%s\n", schema->doc->URL);

	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH

; 7900 :     } else {

	jmp	SHORT $LN7@xmlRelaxNG
$LN6@xmlRelaxNG:

; 7901 :         fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
$LN23@xmlRelaxNG:

; 7902 :     }
; 7903 :     if (schema->topgrammar == NULL) {

	push	esi
	call	_fprintf
	add	esp, 8
$LN7@xmlRelaxNG:
	mov	edi, DWORD PTR [edi+4]
	test	edi, edi
	jne	SHORT $LN8@xmlRelaxNG

; 7904 :         fprintf(output, "RelaxNG has no top grammar\n");

	push	OFFSET ??_C@_0BM@HEJEDHAB@RelaxNG?5has?5no?5top?5grammar?6@
	push	esi
	call	_fprintf
	add	esp, 8
	pop	edi
	pop	esi

; 7905 :         return;
; 7906 :     }
; 7907 :     xmlRelaxNGDumpGrammar(output, schema->topgrammar, 1);
; 7908 : }

	pop	ebp
	ret	0
$LN8@xmlRelaxNG:

; 7852 :     fprintf(output, "<grammar");

	push	OFFSET ??_C@_08EPHAEKIJ@?$DMgrammar@
	push	esi
	call	_fprintf

; 7853 :     if (top)
; 7854 :         fprintf(output, " xmlns=\"http://relaxng.org/ns/structure/1.0\"");

	push	OFFSET ??_C@_0CN@MGKJIEH@?5xmlns?$DN?$CChttp?3?1?1relaxng?4org?1ns?1s@
	push	esi
	call	_fprintf

; 7855 :     switch (grammar->combine) {

	mov	eax, DWORD PTR [edi+16]
	add	esp, 16					; 00000010H
	sub	eax, 0
	je	SHORT $LN15@xmlRelaxNG
	sub	eax, 1
	je	SHORT $LN16@xmlRelaxNG
	sub	eax, 1
	je	SHORT $LN17@xmlRelaxNG

; 7864 :         default:
; 7865 :             fprintf(output, " <!-- invalid combine value -->");

	push	OFFSET ??_C@_0CA@NOBFJPON@?5?$DM?$CB?9?9?5invalid?5combine?5value?5?9?9?$DO@
	jmp	SHORT $LN24@xmlRelaxNG
$LN17@xmlRelaxNG:

; 7860 :             break;
; 7861 :         case XML_RELAXNG_COMBINE_INTERLEAVE:
; 7862 :             fprintf(output, " combine=\"interleave\"");

	push	OFFSET ??_C@_0BG@DIIHEMFB@?5combine?$DN?$CCinterleave?$CC@

; 7863 :             break;

	jmp	SHORT $LN24@xmlRelaxNG
$LN16@xmlRelaxNG:

; 7856 :         case XML_RELAXNG_COMBINE_UNDEFINED:
; 7857 :             break;
; 7858 :         case XML_RELAXNG_COMBINE_CHOICE:
; 7859 :             fprintf(output, " combine=\"choice\"");

	push	OFFSET ??_C@_0BC@JCPJPOMG@?5combine?$DN?$CCchoice?$CC@
$LN24@xmlRelaxNG:

; 7866 :     }
; 7867 :     fprintf(output, ">\n");

	push	esi
	call	_fprintf
	add	esp, 8
$LN15@xmlRelaxNG:
	push	OFFSET ??_C@_02NEKEAGPN@?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 8

; 7868 :     if (grammar->start == NULL) {

	cmp	DWORD PTR [edi+12], 0
	jne	SHORT $LN19@xmlRelaxNG

; 7869 :         fprintf(output, " <!-- grammar had no start -->");

	mov	eax, OFFSET ??_C@_0BP@HDPMIPMJ@?5?$DM?$CB?9?9?5grammar?5had?5no?5start?5?9?9?$DO@

; 7870 :     } else {

	jmp	SHORT $LN20@xmlRelaxNG
$LN19@xmlRelaxNG:

; 7871 :         fprintf(output, "<start>\n");

	push	OFFSET ??_C@_08JLPGMCFH@?$DMstart?$DO?6@
	push	esi
	call	_fprintf

; 7872 :         xmlRelaxNGDumpDefine(output, grammar->start);

	push	DWORD PTR [edi+12]
	push	esi
	call	_xmlRelaxNGDumpDefine
	add	esp, 16					; 00000010H

; 7873 :         fprintf(output, "</start>\n");

	mov	eax, OFFSET ??_C@_09HJPHKCIN@?$DM?1start?$DO?6@
$LN20@xmlRelaxNG:

; 7874 :     }
; 7875 :     /* TODO ? Dump the defines ? */
; 7876 :     fprintf(output, "</grammar>\n");

	push	eax
	push	esi
	call	_fprintf
	push	OFFSET ??_C@_0M@JODHEKCA@?$DM?1grammar?$DO?6@
	push	esi
	call	_fprintf
	add	esp, 16					; 00000010H
	pop	edi
$LN10@xmlRelaxNG:
	pop	esi

; 7905 :         return;
; 7906 :     }
; 7907 :     xmlRelaxNGDumpGrammar(output, schema->topgrammar, 1);
; 7908 : }

	pop	ebp
	ret	0
_xmlRelaxNGDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGFree
_TEXT	SEGMENT
_schema$ = 8						; size = 4
_xmlRelaxNGFree PROC					; COMDAT

; 808  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _schema$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlRelaxNG

; 809  :     if (schema == NULL)
; 810  :         return;
; 811  : 
; 812  :     if (schema->topgrammar != NULL)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG

; 813  :         xmlRelaxNGFreeGrammar(schema->topgrammar);

	push	eax
	call	_xmlRelaxNGFreeGrammar
	add	esp, 4
$LN6@xmlRelaxNG:

; 814  :     if (schema->doc != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG

; 815  :         xmlFreeDoc(schema->doc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN7@xmlRelaxNG:

; 816  :     if (schema->documents != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN8@xmlRelaxNG

; 817  :         xmlRelaxNGFreeDocumentList(schema->documents);

	push	eax
	call	_xmlRelaxNGFreeDocumentList
	add	esp, 4
$LN8@xmlRelaxNG:

; 818  :     if (schema->includes != NULL)

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN9@xmlRelaxNG

; 819  :         xmlRelaxNGFreeIncludeList(schema->includes);

	push	eax
	call	_xmlRelaxNGFreeIncludeList
	add	esp, 4
$LN9@xmlRelaxNG:

; 820  :     if (schema->defTab != NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN10@xmlRelaxNG

; 821  :         int i;
; 822  : 
; 823  :         for (i = 0; i < schema->defNr; i++)

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [esi+32], edi
	jle	SHORT $LN3@xmlRelaxNG
$LL4@xmlRelaxNG:

; 824  :             xmlRelaxNGFreeDefine(schema->defTab[i]);

	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR [eax+edi*4]
	call	_xmlRelaxNGFreeDefine
	inc	edi
	add	esp, 4
	cmp	edi, DWORD PTR [esi+32]
	jl	SHORT $LL4@xmlRelaxNG
	mov	eax, DWORD PTR [esi+36]
$LN3@xmlRelaxNG:

; 825  :         xmlFree(schema->defTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
$LN10@xmlRelaxNG:

; 826  :     }
; 827  : 
; 828  :     xmlFree(schema);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlRelaxNG:
	pop	esi

; 829  : }

	pop	ebp
	ret	0
_xmlRelaxNGFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGParse
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlRelaxNGParse PROC					; COMDAT

; 7500 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlRelaxNGInitTypes
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlRelaxNG

; 7501 :     xmlRelaxNGPtr ret = NULL;
; 7502 :     xmlDocPtr doc;
; 7503 :     xmlNodePtr root;
; 7504 : 
; 7505 :     xmlRelaxNGInitTypes();
; 7506 : 
; 7507 :     if (ctxt == NULL)
; 7508 :         return (NULL);

	xor	eax, eax
	pop	esi

; 7624 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:

; 7509 : 
; 7510 :     /*
; 7511 :      * First step is to parse the input document into an DOM/Infoset
; 7512 :      */
; 7513 :     if (ctxt->URL != NULL) {

	mov	eax, DWORD PTR [esi+68]
	push	edi
	test	eax, eax
	je	SHORT $LN3@xmlRelaxNG

; 7514 :         doc = xmlReadFile((const char *) ctxt->URL,NULL,0);

	push	0
	push	0
	push	eax
	call	_xmlReadFile
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 7515 :         if (doc == NULL) {

	test	edi, edi
	jne	SHORT $LN10@xmlRelaxNG

; 7516 :             xmlRngPErr(ctxt, NULL, XML_RNGP_PARSE_ERROR,

	push	eax
	push	DWORD PTR [esi+68]
	push	OFFSET ??_C@_0CE@JEGPHEEO@xmlRelaxNGParse?3?5could?5not?5load@

; 7517 :                        "xmlRelaxNGParse: could not load %s\n", ctxt->URL,
; 7518 :                        NULL);
; 7519 :             return (NULL);

	jmp	SHORT $LN27@xmlRelaxNG
$LN3@xmlRelaxNG:

; 7520 :         }
; 7521 :     } else if (ctxt->buffer != NULL) {

	mov	eax, DWORD PTR [esi+88]
	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG

; 7522 :         doc = xmlReadMemory(ctxt->buffer, ctxt->size,NULL,NULL,0);

	push	0
	push	0
	push	0
	push	DWORD PTR [esi+92]
	push	eax
	call	_xmlReadMemory
	mov	edi, eax
	add	esp, 20					; 00000014H

; 7523 :         if (doc == NULL) {

	test	edi, edi
	jne	SHORT $LN8@xmlRelaxNG

; 7524 :             xmlRngPErr(ctxt, NULL, XML_RNGP_PARSE_ERROR,

	push	eax
	push	eax
	push	OFFSET ??_C@_0CK@DLIMDDCN@xmlRelaxNGParse?3?5could?5not?5pars@
$LN27@xmlRelaxNG:
	push	1065					; 00000429H
	push	0
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 7525 :                        "xmlRelaxNGParse: could not parse schemas\n", NULL,
; 7526 :                        NULL);
; 7527 :             return (NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 7624 : }

	pop	ebp
	ret	0
$LN8@xmlRelaxNG:

; 7528 :         }
; 7529 :         doc->URL = xmlStrdup(BAD_CAST "in_memory_buffer");

	push	OFFSET ??_C@_0BB@IEONCAEH@in_memory_buffer@
	call	_xmlStrdup

; 7530 :         ctxt->URL = xmlStrdup(BAD_CAST "in_memory_buffer");

	push	OFFSET ??_C@_0BB@IEONCAEH@in_memory_buffer@
	mov	DWORD PTR [edi+72], eax
	call	_xmlStrdup
	add	esp, 8
	mov	DWORD PTR [esi+68], eax
	jmp	SHORT $LN10@xmlRelaxNG
$LN6@xmlRelaxNG:

; 7531 :     } else if (ctxt->document != NULL) {

	mov	edi, DWORD PTR [esi+72]
	test	edi, edi
	je	$LN9@xmlRelaxNG
$LN10@xmlRelaxNG:
	push	ebx

; 7537 :     }
; 7538 :     ctxt->document = doc;
; 7539 : 
; 7540 :     /*
; 7541 :      * Some preprocessing of the document content
; 7542 :      */
; 7543 :     doc = xmlRelaxNGCleanupDoc(ctxt, doc);

	push	edi
	push	esi
	mov	DWORD PTR [esi+72], edi
	call	_xmlRelaxNGCleanupDoc
	mov	ebx, eax
	add	esp, 8

; 7544 :     if (doc == NULL) {

	test	ebx, ebx
	je	SHORT $LN25@xmlRelaxNG

; 7545 :         xmlFreeDoc(ctxt->document);
; 7546 :         ctxt->document = NULL;
; 7547 :         return (NULL);
; 7548 :     }
; 7549 : 
; 7550 :     /*
; 7551 :      * Then do the parsing for good
; 7552 :      */
; 7553 :     root = xmlDocGetRootElement(doc);

	push	ebx
	call	_xmlDocGetRootElement
	add	esp, 4

; 7554 :     if (root == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlRelaxNG

; 7555 :         xmlRngPErr(ctxt, (xmlNodePtr) doc,

	mov	eax, DWORD PTR [esi+68]
	mov	ecx, OFFSET ??_C@_07DDGCDBGL@schemas@
	test	eax, eax
	push	0
	cmovne	ecx, eax
	push	ecx
	push	OFFSET ??_C@_0BO@JMOIDLLM@xmlRelaxNGParse?3?5?$CFs?5is?5empty?6@
	push	1022					; 000003feH
	push	ebx
	push	esi
	call	_xmlRngPErr

; 7556 : 	           XML_RNGP_EMPTY, "xmlRelaxNGParse: %s is empty\n",
; 7557 :                    (ctxt->URL ? ctxt->URL : BAD_CAST "schemas"), NULL);
; 7558 : 
; 7559 :         xmlFreeDoc(ctxt->document);

	push	DWORD PTR [esi+72]
	call	_xmlFreeDoc
	add	esp, 28					; 0000001cH

; 7566 :         ctxt->document = NULL;
; 7567 :         return (NULL);

	mov	DWORD PTR [esi+72], 0
	xor	eax, eax
	pop	ebx
	pop	edi
	pop	esi

; 7624 : }

	pop	ebp
	ret	0
$LN12@xmlRelaxNG:

; 7560 :         ctxt->document = NULL;
; 7561 :         return (NULL);
; 7562 :     }
; 7563 :     ret = xmlRelaxNGParseDocument(ctxt, root);

	push	eax
	push	esi
	call	_xmlRelaxNGParseDocument
	mov	edi, eax
	add	esp, 8

; 7564 :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN13@xmlRelaxNG
$LN25@xmlRelaxNG:

; 7565 :         xmlFreeDoc(ctxt->document);

	push	DWORD PTR [esi+72]
	call	_xmlFreeDoc
	add	esp, 4

; 7566 :         ctxt->document = NULL;
; 7567 :         return (NULL);

	mov	DWORD PTR [esi+72], 0
	xor	eax, eax
	pop	ebx
	pop	edi
	pop	esi

; 7624 : }

	pop	ebp
	ret	0
$LN13@xmlRelaxNG:

; 7568 :     }
; 7569 : 
; 7570 :     /*
; 7571 :      * Check the ref/defines links
; 7572 :      */
; 7573 :     /*
; 7574 :      * try to preprocess interleaves
; 7575 :      */
; 7576 :     if (ctxt->interleaves != NULL) {

	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN14@xmlRelaxNG

; 7577 :         xmlHashScan(ctxt->interleaves, xmlRelaxNGComputeInterleaves, ctxt);

	push	esi
	push	OFFSET _xmlRelaxNGComputeInterleaves
	push	eax
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN14@xmlRelaxNG:

; 7578 :     }
; 7579 : 
; 7580 :     /*
; 7581 :      * if there was a parsing error return NULL
; 7582 :      */
; 7583 :     if (ctxt->nbErrors > 0) {

	cmp	DWORD PTR [esi+36], 0
	jle	SHORT $LN15@xmlRelaxNG

; 7584 :         xmlRelaxNGFree(ret);

	push	edi
	call	_xmlRelaxNGFree

; 7585 :         ctxt->document = NULL;
; 7586 :         xmlFreeDoc(doc);

	push	ebx
	mov	DWORD PTR [esi+72], 0
	call	_xmlFreeDoc
	add	esp, 8
	xor	eax, eax
	pop	ebx
	pop	edi
	pop	esi

; 7624 : }

	pop	ebp
	ret	0
$LN15@xmlRelaxNG:

; 7587 :         return (NULL);
; 7588 :     }
; 7589 : 
; 7590 :     /*
; 7591 :      * try to compile (parts of) the schemas
; 7592 :      */
; 7593 :     if ((ret->topgrammar != NULL) && (ret->topgrammar->start != NULL)) {

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN16@xmlRelaxNG
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN16@xmlRelaxNG

; 7594 :         if (ret->topgrammar->start->type != XML_RELAXNG_START) {

	cmp	DWORD PTR [eax], 20			; 00000014H
	je	SHORT $LN18@xmlRelaxNG

; 7595 :             xmlRelaxNGDefinePtr def;
; 7596 : 
; 7597 :             def = xmlRelaxNGNewDefine(ctxt, NULL);

	push	0
	push	esi
	call	_xmlRelaxNGNewDefine
	add	esp, 8

; 7598 :             if (def != NULL) {

	test	eax, eax
	je	SHORT $LN18@xmlRelaxNG

; 7599 :                 def->type = XML_RELAXNG_START;

	mov	DWORD PTR [eax], 20			; 00000014H

; 7600 :                 def->content = ret->topgrammar->start;

	mov	ecx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+24], ecx

; 7601 :                 ret->topgrammar->start = def;

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+12], eax
$LN18@xmlRelaxNG:

; 7602 :             }
; 7603 :         }
; 7604 :         xmlRelaxNGTryCompile(ctxt, ret->topgrammar->start);

	mov	eax, DWORD PTR [edi+4]
	push	DWORD PTR [eax+12]
	push	esi
	call	_xmlRelaxNGTryCompile
	add	esp, 8
$LN16@xmlRelaxNG:

; 7605 :     }
; 7606 : 
; 7607 :     /*
; 7608 :      * Transfer the pointer for cleanup at the schema level.
; 7609 :      */
; 7610 :     ret->doc = doc;

	mov	DWORD PTR [edi+8], ebx

; 7611 :     ctxt->document = NULL;
; 7612 :     ret->documents = ctxt->documents;

	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [esi+72], 0
	mov	DWORD PTR [edi+24], eax

; 7613 :     ctxt->documents = NULL;
; 7614 : 
; 7615 :     ret->includes = ctxt->includes;

	mov	eax, DWORD PTR [esi+64]
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [edi+28], eax

; 7616 :     ctxt->includes = NULL;
; 7617 :     ret->defNr = ctxt->defNr;

	mov	eax, DWORD PTR [esi+76]
	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [edi+32], eax

; 7618 :     ret->defTab = ctxt->defTab;

	mov	eax, DWORD PTR [esi+84]
	mov	DWORD PTR [edi+36], eax

; 7619 :     ctxt->defTab = NULL;
; 7620 :     if (ctxt->idref == 1)

	cmp	DWORD PTR [esi+128], 1
	mov	DWORD PTR [esi+84], 0
	jne	SHORT $LN19@xmlRelaxNG

; 7621 :         ret->idref = 1;

	mov	DWORD PTR [edi+12], 1
$LN19@xmlRelaxNG:
	pop	ebx

; 7622 : 
; 7623 :     return (ret);

	mov	eax, edi
	pop	edi
	pop	esi

; 7624 : }

	pop	ebp
	ret	0
$LN9@xmlRelaxNG:

; 7532 :         doc = ctxt->document;
; 7533 :     } else {
; 7534 :         xmlRngPErr(ctxt, NULL, XML_RNGP_EMPTY,

	push	0
	push	0
	push	OFFSET ??_C@_0CD@ECFNFIDE@xmlRelaxNGParse?3?5nothing?5to?5par@
	push	1022					; 000003feH
	push	0
	push	esi
	call	_xmlRngPErr
	add	esp, 24					; 00000018H

; 7535 :                    "xmlRelaxNGParse: nothing to parse\n", NULL, NULL);
; 7536 :         return (NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 7624 : }

	pop	ebp
	ret	0
_xmlRelaxNGParse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGSetParserStructuredErrors
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_serror$ = 12						; size = 4
_ctx$ = 16						; size = 4
_xmlRelaxNGSetParserStructuredErrors PROC		; COMDAT

; 7687 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@xmlRelaxNG

; 7688 :     if (ctxt == NULL)
; 7689 :         return;
; 7690 :     ctxt->serror = serror;

	mov	eax, DWORD PTR _serror$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 7691 :     ctxt->error = NULL;
; 7692 :     ctxt->warning = NULL;
; 7693 :     ctxt->userData = ctx;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx], eax
$LN1@xmlRelaxNG:

; 7694 : }

	pop	ebp
	ret	0
_xmlRelaxNGSetParserStructuredErrors ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGGetParserErrors
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_err$ = 12						; size = 4
_warn$ = 16						; size = 4
_ctx$ = 20						; size = 4
_xmlRelaxNGGetParserErrors PROC				; COMDAT

; 7663 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@xmlRelaxNG

; 7664 :     if (ctxt == NULL)
; 7665 :         return (-1);

	or	eax, -1

; 7673 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:

; 7666 :     if (err != NULL)

	mov	edx, DWORD PTR _err$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlRelaxNG

; 7667 :         *err = ctxt->error;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN3@xmlRelaxNG:

; 7668 :     if (warn != NULL)

	mov	edx, DWORD PTR _warn$[ebp]
	test	edx, edx
	je	SHORT $LN4@xmlRelaxNG

; 7669 :         *warn = ctxt->warning;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax
$LN4@xmlRelaxNG:

; 7670 :     if (ctx != NULL)

	mov	edx, DWORD PTR _ctx$[ebp]
	test	edx, edx
	je	SHORT $LN5@xmlRelaxNG

; 7671 :         *ctx = ctxt->userData;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
$LN5@xmlRelaxNG:

; 7672 :     return (0);

	xor	eax, eax

; 7673 : }

	pop	ebp
	ret	0
_xmlRelaxNGGetParserErrors ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGSetParserErrors
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_err$ = 12						; size = 4
_warn$ = 16						; size = 4
_ctx$ = 20						; size = 4
_xmlRelaxNGSetParserErrors PROC				; COMDAT

; 7639 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@xmlRelaxNG

; 7640 :     if (ctxt == NULL)
; 7641 :         return;
; 7642 :     ctxt->error = err;

	mov	eax, DWORD PTR _err$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 7643 :     ctxt->warning = warn;

	mov	eax, DWORD PTR _warn$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 7644 :     ctxt->serror = NULL;
; 7645 :     ctxt->userData = ctx;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx], eax
$LN1@xmlRelaxNG:

; 7646 : }

	pop	ebp
	ret	0
_xmlRelaxNGSetParserErrors ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGFreeParserCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlRelaxNGFreeParserCtxt PROC				; COMDAT

; 6851 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN1@xmlRelaxNG

; 6852 :     if (ctxt == NULL)
; 6853 :         return;
; 6854 :     if (ctxt->URL != NULL)

	mov	eax, DWORD PTR [esi+68]
	test	eax, eax
	je	SHORT $LN6@xmlRelaxNG

; 6855 :         xmlFree(ctxt->URL);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlRelaxNG:

; 6856 :     if (ctxt->doc != NULL)

	mov	eax, DWORD PTR [esi+96]
	test	eax, eax
	je	SHORT $LN7@xmlRelaxNG

; 6857 :         xmlRelaxNGFreeDocument(ctxt->doc);

	push	eax
	call	_xmlRelaxNGFreeDocument
	add	esp, 4
$LN7@xmlRelaxNG:

; 6858 :     if (ctxt->interleaves != NULL)

	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN8@xmlRelaxNG

; 6859 :         xmlHashFree(ctxt->interleaves, NULL);

	push	0
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN8@xmlRelaxNG:

; 6860 :     if (ctxt->documents != NULL)

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN9@xmlRelaxNG

; 6861 :         xmlRelaxNGFreeDocumentList(ctxt->documents);

	push	eax
	call	_xmlRelaxNGFreeDocumentList
	add	esp, 4
$LN9@xmlRelaxNG:

; 6862 :     if (ctxt->includes != NULL)

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN10@xmlRelaxNG

; 6863 :         xmlRelaxNGFreeIncludeList(ctxt->includes);

	push	eax
	call	_xmlRelaxNGFreeIncludeList
	add	esp, 4
$LN10@xmlRelaxNG:

; 6864 :     if (ctxt->docTab != NULL)

	mov	eax, DWORD PTR [esi+108]
	test	eax, eax
	je	SHORT $LN11@xmlRelaxNG

; 6865 :         xmlFree(ctxt->docTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlRelaxNG:

; 6866 :     if (ctxt->incTab != NULL)

	mov	eax, DWORD PTR [esi+124]
	test	eax, eax
	je	SHORT $LN12@xmlRelaxNG

; 6867 :         xmlFree(ctxt->incTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlRelaxNG:

; 6868 :     if (ctxt->defTab != NULL) {

	mov	eax, DWORD PTR [esi+84]
	test	eax, eax
	je	SHORT $LN13@xmlRelaxNG

; 6869 :         int i;
; 6870 : 
; 6871 :         for (i = 0; i < ctxt->defNr; i++)

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [esi+76], edi
	jle	SHORT $LN3@xmlRelaxNG
	npad	3
$LL4@xmlRelaxNG:

; 6872 :             xmlRelaxNGFreeDefine(ctxt->defTab[i]);

	mov	eax, DWORD PTR [esi+84]
	push	DWORD PTR [eax+edi*4]
	call	_xmlRelaxNGFreeDefine
	inc	edi
	add	esp, 4
	cmp	edi, DWORD PTR [esi+76]
	jl	SHORT $LL4@xmlRelaxNG
	mov	eax, DWORD PTR [esi+84]
$LN3@xmlRelaxNG:

; 6873 :         xmlFree(ctxt->defTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
$LN13@xmlRelaxNG:

; 6874 :     }
; 6875 :     if ((ctxt->document != NULL) && (ctxt->freedoc))

	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	je	SHORT $LN14@xmlRelaxNG
	cmp	DWORD PTR [esi+144], 0
	je	SHORT $LN14@xmlRelaxNG

; 6876 :         xmlFreeDoc(ctxt->document);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN14@xmlRelaxNG:

; 6877 :     xmlFree(ctxt);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlRelaxNG:
	pop	esi

; 6878 : }

	pop	ebp
	ret	0
_xmlRelaxNGFreeParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxParserSetFlag
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_flags$ = 12						; size = 4
_xmlRelaxParserSetFlag PROC				; COMDAT

; 1419 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN9@xmlRelaxPa

; 1420 :     if (ctxt == NULL) return(-1);
; 1421 :     if (flags & XML_RELAXNGP_FREE_DOC) {

	mov	eax, DWORD PTR _flags$[ebp]
	test	al, 1
	je	SHORT $LN8@xmlRelaxPa

; 1422 :         ctxt->crng |= XML_RELAXNGP_FREE_DOC;

	or	DWORD PTR [ecx+140], 1

; 1423 : 	flags -= XML_RELAXNGP_FREE_DOC;

	dec	eax
$LN8@xmlRelaxPa:

; 1424 :     }
; 1425 :     if (flags & XML_RELAXNGP_CRNG) {

	test	al, 2
	je	SHORT $LN4@xmlRelaxPa

; 1426 :         ctxt->crng |= XML_RELAXNGP_CRNG;

	or	DWORD PTR [ecx+140], 2

; 1427 : 	flags -= XML_RELAXNGP_CRNG;

	sub	eax, 2
$LN4@xmlRelaxPa:

; 1428 :     }
; 1429 :     if (flags != 0) return(-1);

	test	eax, eax
	jne	SHORT $LN9@xmlRelaxPa

; 1430 :     return(0);
; 1431 : }

	pop	ebp
	ret	0
$LN9@xmlRelaxPa:

; 1428 :     }
; 1429 :     if (flags != 0) return(-1);

	or	eax, -1

; 1430 :     return(0);
; 1431 : }

	pop	ebp
	ret	0
_xmlRelaxParserSetFlag ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGNewDocParserCtxt
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_xmlRelaxNGNewDocParserCtxt PROC			; COMDAT

; 6820 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	je	$LN13@xmlRelaxNG

; 6821 :     xmlRelaxNGParserCtxtPtr ret;
; 6822 :     xmlDocPtr copy;
; 6823 : 
; 6824 :     if (doc == NULL)
; 6825 :         return (NULL);
; 6826 :     copy = xmlCopyDoc(doc, 1);

	push	1
	push	eax
	call	_xmlCopyDoc
	mov	edi, eax
	add	esp, 8

; 6827 :     if (copy == NULL)

	test	edi, edi
	je	SHORT $LN13@xmlRelaxNG

; 6829 : 
; 6830 :     ret =

	push	esi
	push	148					; 00000094H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 6831 :         (xmlRelaxNGParserCtxtPtr) xmlMalloc(sizeof(xmlRelaxNGParserCtxt));
; 6832 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlRelaxNG

; 453  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BB@LGCAJOFI@building?5parser?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BB@LGCAJOFI@building?5parser?6@
	push	eax
	push	eax
	push	3
	push	2
	push	18					; 00000012H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 6833 :         xmlRngPErrMemory(NULL, "building parser\n");
; 6834 :         return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 6841 : }

	pop	ebp
	ret	0
$LN4@xmlRelaxNG:

; 6835 :     }
; 6836 :     memset(ret, 0, sizeof(xmlRelaxNGParserCtxt));

	push	148					; 00000094H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 6837 :     ret->document = copy;

	mov	DWORD PTR [esi+72], edi

; 6838 :     ret->freedoc = 1;

	mov	DWORD PTR [esi+144], 1

; 6839 :     ret->userData = xmlGenericErrorContext;

	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax

; 6840 :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 6841 : }

	pop	ebp
	ret	0
$LN13@xmlRelaxNG:

; 6828 :         return (NULL);

	xor	eax, eax
	pop	edi

; 6841 : }

	pop	ebp
	ret	0
_xmlRelaxNGNewDocParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGNewMemParserCtxt
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlRelaxNGNewMemParserCtxt PROC			; COMDAT

; 6788 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _buffer$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@xmlRelaxNG

; 6789 :     xmlRelaxNGParserCtxtPtr ret;
; 6790 : 
; 6791 :     if ((buffer == NULL) || (size <= 0))

	mov	edi, DWORD PTR _size$[ebp]
	test	edi, edi
	jle	SHORT $LN3@xmlRelaxNG

; 6793 : 
; 6794 :     ret =

	push	esi
	push	148					; 00000094H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 6795 :         (xmlRelaxNGParserCtxtPtr) xmlMalloc(sizeof(xmlRelaxNGParserCtxt));
; 6796 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlRelaxNG

; 453  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BB@LGCAJOFI@building?5parser?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BB@LGCAJOFI@building?5parser?6@
	push	eax
	push	eax
	push	3
	push	2
	push	18					; 00000012H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 6797 :         xmlRngPErrMemory(NULL, "building parser\n");
; 6798 :         return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 6806 : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlRelaxNG:

; 6799 :     }
; 6800 :     memset(ret, 0, sizeof(xmlRelaxNGParserCtxt));

	push	148					; 00000094H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 6801 :     ret->buffer = buffer;

	mov	DWORD PTR [esi+88], ebx

; 6802 :     ret->size = size;

	mov	DWORD PTR [esi+92], edi

; 6803 :     ret->error = xmlGenericError;

	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+4], eax

; 6804 :     ret->userData = xmlGenericErrorContext;

	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax

; 6805 :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 6806 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlRelaxNG:
	pop	edi

; 6792 :         return (NULL);

	xor	eax, eax

; 6806 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlRelaxNGNewMemParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGNewParserCtxt
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_xmlRelaxNGNewParserCtxt PROC				; COMDAT

; 6757 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _URL$[ebp], 0
	jne	SHORT $LN2@xmlRelaxNG

; 6758 :     xmlRelaxNGParserCtxtPtr ret;
; 6759 : 
; 6760 :     if (URL == NULL)
; 6761 :         return (NULL);

	xor	eax, eax

; 6774 : }

	pop	ebp
	ret	0
$LN2@xmlRelaxNG:
	push	esi

; 6762 : 
; 6763 :     ret =

	push	148					; 00000094H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 6764 :         (xmlRelaxNGParserCtxtPtr) xmlMalloc(sizeof(xmlRelaxNGParserCtxt));
; 6765 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN3@xmlRelaxNG

; 453  :         __xmlRaiseError(schannel, channel, data,

	push	OFFSET ??_C@_0BB@LGCAJOFI@building?5parser?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BB@LGCAJOFI@building?5parser?6@
	push	eax
	push	eax
	push	3
	push	2
	push	18					; 00000012H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 6766 :         xmlRngPErrMemory(NULL, "building parser\n");
; 6767 :         return (NULL);

	xor	eax, eax
	pop	esi

; 6774 : }

	pop	ebp
	ret	0
$LN3@xmlRelaxNG:

; 6768 :     }
; 6769 :     memset(ret, 0, sizeof(xmlRelaxNGParserCtxt));

	push	148					; 00000094H
	push	0
	push	esi
	call	_memset

; 6770 :     ret->URL = xmlStrdup((const xmlChar *) URL);

	push	DWORD PTR _URL$[ebp]
	call	_xmlStrdup
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+68], eax

; 6771 :     ret->error = xmlGenericError;

	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+4], eax

; 6772 :     ret->userData = xmlGenericErrorContext;

	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax

; 6773 :     return (ret);

	mov	eax, esi
	pop	esi

; 6774 : }

	pop	ebp
	ret	0
_xmlRelaxNGNewParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGCleanupTypes
_TEXT	SEGMENT
_xmlRelaxNGCleanupTypes PROC				; COMDAT
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlSchemaCleanupTypes
	cmp	DWORD PTR _xmlRelaxNGTypeInitialized, 0
	je	SHORT $LN1@xmlRelaxNG

; 2857 :     xmlSchemaCleanupTypes();
; 2858 :     if (xmlRelaxNGTypeInitialized == 0)
; 2859 :         return;
; 2860 :     xmlHashFree(xmlRelaxNGRegisteredTypes, xmlRelaxNGFreeTypeLibrary);

	push	OFFSET _xmlRelaxNGFreeTypeLibrary
	push	DWORD PTR _xmlRelaxNGRegisteredTypes
	call	_xmlHashFree
	add	esp, 8

; 2861 :     xmlRelaxNGTypeInitialized = 0;

	mov	DWORD PTR _xmlRelaxNGTypeInitialized, 0
$LN1@xmlRelaxNG:

; 2862 : }

	ret	0
_xmlRelaxNGCleanupTypes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\relaxng.c
;	COMDAT _xmlRelaxNGInitTypes
_TEXT	SEGMENT
_xmlRelaxNGInitTypes PROC				; COMDAT
	mov	ecx, OFFSET __49DBE4F2_relaxng@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlRelaxNGTypeInitialized, 0
	jne	$LN5@xmlRelaxNG

; 2825 :     if (xmlRelaxNGTypeInitialized != 0)
; 2826 :         return (0);
; 2827 :     xmlRelaxNGRegisteredTypes = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR _xmlRelaxNGRegisteredTypes, eax

; 2828 :     if (xmlRelaxNGRegisteredTypes == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlRelaxNG

; 2829 :         xmlGenericError(xmlGenericErrorContext,

	push	esi
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0DA@BNBDCCII@Failed?5to?5allocate?5sh?5table?5for@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 2830 :                         "Failed to allocate sh table for Relax-NG types\n");
; 2831 :         return (-1);

	or	eax, -1
	pop	esi

; 2846 :     return (0);
; 2847 : }

	ret	0
$LN3@xmlRelaxNG:

; 2832 :     }
; 2833 :     xmlRelaxNGRegisterTypeLibrary(BAD_CAST

	push	OFFSET _xmlRelaxNGSchemaFreeValue
	push	OFFSET _xmlRelaxNGSchemaFacetCheck
	push	OFFSET _xmlRelaxNGSchemaTypeCompare
	push	OFFSET _xmlRelaxNGSchemaTypeCheck
	push	OFFSET _xmlRelaxNGSchemaTypeHave
	push	0
	push	OFFSET ??_C@_0CL@MAOGIMDF@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	call	_xmlRelaxNGRegisterTypeLibrary

; 2834 :                                   "http://www.w3.org/2001/XMLSchema-datatypes",
; 2835 :                                   NULL, xmlRelaxNGSchemaTypeHave,
; 2836 :                                   xmlRelaxNGSchemaTypeCheck,
; 2837 :                                   xmlRelaxNGSchemaTypeCompare,
; 2838 :                                   xmlRelaxNGSchemaFacetCheck,
; 2839 :                                   xmlRelaxNGSchemaFreeValue);
; 2840 :     xmlRelaxNGRegisterTypeLibrary(xmlRelaxNGNs, NULL,

	push	0
	push	0
	push	OFFSET _xmlRelaxNGDefaultTypeCompare
	push	OFFSET _xmlRelaxNGDefaultTypeCheck
	push	OFFSET _xmlRelaxNGDefaultTypeHave
	push	0
	push	DWORD PTR _xmlRelaxNGNs
	call	_xmlRelaxNGRegisterTypeLibrary
	add	esp, 56					; 00000038H

; 2841 :                                   xmlRelaxNGDefaultTypeHave,
; 2842 :                                   xmlRelaxNGDefaultTypeCheck,
; 2843 :                                   xmlRelaxNGDefaultTypeCompare, NULL,
; 2844 :                                   NULL);
; 2845 :     xmlRelaxNGTypeInitialized = 1;

	mov	DWORD PTR _xmlRelaxNGTypeInitialized, 1
$LN5@xmlRelaxNG:

; 2846 :     return (0);
; 2847 : }

	xor	eax, eax
	ret	0
_xmlRelaxNGInitTypes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	or	ecx, 2
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;

	pop	esi

; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);
; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;

	pop	esi

; 842  :     }

	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
; 644  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
