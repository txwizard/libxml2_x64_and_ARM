; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xmlcatalog.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__6F93E186_xmlcatalog@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_printf
PUBLIC	_main
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_02LLMPMKNF@?$DO?5@			; `string'
PUBLIC	??_C@_04MKNBDEPB@exit@				; `string'
PUBLIC	??_C@_04KNNLNNGO@quit@				; `string'
PUBLIC	??_C@_03MDONDFG@bye@				; `string'
PUBLIC	??_C@_06EOMAMIIF@public@			; `string'
PUBLIC	??_C@_0BN@DCAIANKH@public?5requires?51?5arguments?6@ ; `string'
PUBLIC	??_C@_0BI@FFIBJMM@No?5entry?5for?5PUBLIC?5?$CFs?6@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_06FHFOAHML@system@			; `string'
PUBLIC	??_C@_0BN@OGHNALCF@system?5requires?51?5arguments?6@ ; `string'
PUBLIC	??_C@_0BI@GPMJOIOL@No?5entry?5for?5SYSTEM?5?$CFs?6@ ; `string'
PUBLIC	??_C@_03BDGOHNNK@add@				; `string'
PUBLIC	??_C@_0BP@EHJKBIMI@add?5requires?52?5or?53?5arguments?6@ ; `string'
PUBLIC	??_C@_0BE@JELHPCAG@add?5command?5failed?6@	; `string'
PUBLIC	??_C@_03ONKLGNNH@del@				; `string'
PUBLIC	??_C@_0BA@PNPKCAGJ@del?5requires?51?6@		; `string'
PUBLIC	??_C@_0BE@HPIOAMEN@del?5command?5failed?6@	; `string'
PUBLIC	??_C@_07CPEIJHB@resolve@			; `string'
PUBLIC	??_C@_0BO@FIFGKLE@resolve?5requires?52?5arguments?6@ ; `string'
PUBLIC	??_C@_0CD@FLKMEIPD@Resolver?5failed?5to?5find?5an?5answ@ ; `string'
PUBLIC	??_C@_04GGLOKIEE@dump@				; `string'
PUBLIC	??_C@_0BH@GHHAHJGB@dump?5has?5no?5arguments?6@	; `string'
PUBLIC	??_C@_05GFCDIDHO@debug@				; `string'
PUBLIC	??_C@_0BI@DPNEIFGM@debug?5has?5no?5arguments?6@	; `string'
PUBLIC	??_C@_05PMBAOCDH@quiet@				; `string'
PUBLIC	??_C@_0BI@CNFOPICG@quiet?5has?5no?5arguments?6@	; `string'
PUBLIC	??_C@_04PCJFHION@help@				; `string'
PUBLIC	??_C@_0BJ@LCFAJBIE@Unrecognized?5command?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BF@CNPPMLEL@Commands?5available?3?6@	; `string'
PUBLIC	??_C@_0DD@BNENJECC@?7public?5PublicID?3?5make?5a?5PUBLIC@ ; `string'
PUBLIC	??_C@_0DD@BFGOGPGB@?7system?5SystemID?3?5make?5a?5SYSTEM@ ; `string'
PUBLIC	??_C@_0DH@FFOBCHBO@?7resolve?5PublicID?5SystemID?3?5do?5@ ; `string'
PUBLIC	??_C@_0CN@PJBHDJPC@?7add?5?8type?8?5?8orig?8?5?8replace?8?5?3?5@ ; `string'
PUBLIC	??_C@_0BP@BCHNOEJB@?7del?5?8values?8?5?3?5remove?5values?6@ ; `string'
PUBLIC	??_C@_0CI@ECEJDHEJ@?7dump?3?5print?5the?5current?5catalo@ ; `string'
PUBLIC	??_C@_0CG@OIIIIIDP@?7debug?3?5increase?5the?5verbosity?5@ ; `string'
PUBLIC	??_C@_0CG@JNOLBMIB@?7quiet?3?5decrease?5the?5verbosity?5@ ; `string'
PUBLIC	??_C@_0BI@GHCHHEEB@?7exit?3?5?5quit?5the?5shell?6@ ; `string'
PUBLIC	??_C@_0BJG@IFOIFJDI@Usage?5?3?5?$CFs?5?$FLoptions?$FN?5catalogfil@ ; `string'
PUBLIC	??_C@_0BDI@HBPONJIE@?7?9?9del?5?8values?8?5?3?5remove?5values@ ; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_08FBJJFDKJ@?9verbose@			; `string'
PUBLIC	??_C@_02EJEOCNCO@?9v@				; `string'
PUBLIC	??_C@_09OOLJKHBB@?9?9verbose@			; `string'
PUBLIC	??_C@_06JPEJAHHH@?9noout@			; `string'
PUBLIC	??_C@_07FHEHAOH@?9?9noout@			; `string'
PUBLIC	??_C@_06GMHACKOA@?9shell@			; `string'
PUBLIC	??_C@_07PGENFNHA@?9?9shell@			; `string'
PUBLIC	??_C@_05GEMLGBMJ@?9sgml@			; `string'
PUBLIC	??_C@_06OGAPEHEI@?9?9sgml@			; `string'
PUBLIC	??_C@_07JNCAJKJG@?9create@			; `string'
PUBLIC	??_C@_08GNLFDEKF@?9?9create@			; `string'
PUBLIC	??_C@_08BNGAGJEJ@?9convert@			; `string'
PUBLIC	??_C@_09KCEAJNPB@?9?9convert@			; `string'
PUBLIC	??_C@_0BB@KANDGBAO@?9no?9super?9update@		; `string'
PUBLIC	??_C@_0BC@KAMKCICF@?9?9no?9super?9update@	; `string'
PUBLIC	??_C@_04MNFJLOGO@?9add@				; `string'
PUBLIC	??_C@_05BILPODI@?9?9add@			; `string'
PUBLIC	??_C@_04DDJMKOGD@?9del@				; `string'
PUBLIC	??_C@_05PPEOOODF@?9?9del@			; `string'
PUBLIC	??_C@_0BD@PDLGMOIG@Unknown?5option?5?$CFs?6@	; `string'
PUBLIC	??_C@_0CL@LMPCJLGA@No?5catalog?5entry?5specified?5to?5r@ ; `string'
PUBLIC	??_C@_07MFFOOIHD@catalog@			; `string'
PUBLIC	??_C@_07DIADFEPH@CATALOG@			; `string'
PUBLIC	??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@	; `string'
PUBLIC	??_C@_0CA@DECJMEJL@Failed?5to?5remove?5entry?5from?5?$CFs?6@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0BO@LDFMPMFC@could?5not?5open?5?$CFs?5for?5saving?6@ ; `string'
PUBLIC	??_C@_0BL@MKGCOLNC@Failed?5to?5remove?5entry?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BF@IAFAHEGC@No?5entry?5for?5URI?5?$CFs?6@ ; `string'
EXTRN	_xmlCheckVersion:PROC
EXTRN	__imp__remove:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fgets:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_xmlMemoryDump:PROC
EXTRN	_xmlCleanupParser:PROC
EXTRN	_xmlParseURI:PROC
EXTRN	_xmlFreeURI:PROC
EXTRN	_xmlNewCatalog:PROC
EXTRN	_xmlLoadSGMLSuperCatalog:PROC
EXTRN	_xmlACatalogAdd:PROC
EXTRN	_xmlACatalogRemove:PROC
EXTRN	_xmlACatalogDump:PROC
EXTRN	_xmlCatalogIsEmpty:PROC
EXTRN	_xmlInitializeCatalog:PROC
EXTRN	_xmlLoadCatalog:PROC
EXTRN	_xmlCatalogDump:PROC
EXTRN	_xmlCatalogResolve:PROC
EXTRN	_xmlCatalogResolveSystem:PROC
EXTRN	_xmlCatalogResolvePublic:PROC
EXTRN	_xmlCatalogResolveURI:PROC
EXTRN	_xmlCatalogAdd:PROC
EXTRN	_xmlCatalogRemove:PROC
EXTRN	_xmlCatalogConvert:PROC
EXTRN	_xmlCatalogSetDebug:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__xmlFree:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_shell	DD	01H DUP (?)
_sgml	DD	01H DUP (?)
_noout	DD	01H DUP (?)
_create	DD	01H DUP (?)
_add	DD	01H DUP (?)
_del	DD	01H DUP (?)
_convert DD	01H DUP (?)
_no_super_update DD 01H DUP (?)
_verbose DD	01H DUP (?)
_filename DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BF@IAFAHEGC@No?5entry?5for?5URI?5?$CFs?6@
CONST	SEGMENT
??_C@_0BF@IAFAHEGC@No?5entry?5for?5URI?5?$CFs?6@ DB 'No entry for URI %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MKGCOLNC@Failed?5to?5remove?5entry?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@MKGCOLNC@Failed?5to?5remove?5entry?5?$CFs?6@ DB 'Failed to remo'
	DB	've entry %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LDFMPMFC@could?5not?5open?5?$CFs?5for?5saving?6@
CONST	SEGMENT
??_C@_0BO@LDFMPMFC@could?5not?5open?5?$CFs?5for?5saving?6@ DB 'could not '
	DB	'open %s for saving', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DECJMEJL@Failed?5to?5remove?5entry?5from?5?$CFs?6@
CONST	SEGMENT
??_C@_0CA@DECJMEJL@Failed?5to?5remove?5entry?5from?5?$CFs?6@ DB 'Failed t'
	DB	'o remove entry from %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@
CONST	SEGMENT
??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@ DB '/etc/sgml/catalog', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DIADFEPH@CATALOG@
CONST	SEGMENT
??_C@_07DIADFEPH@CATALOG@ DB 'CATALOG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MFFOOIHD@catalog@
CONST	SEGMENT
??_C@_07MFFOOIHD@catalog@ DB 'catalog', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LMPCJLGA@No?5catalog?5entry?5specified?5to?5r@
CONST	SEGMENT
??_C@_0CL@LMPCJLGA@No?5catalog?5entry?5specified?5to?5r@ DB 'No catalog e'
	DB	'ntry specified to remove from', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PDLGMOIG@Unknown?5option?5?$CFs?6@
CONST	SEGMENT
??_C@_0BD@PDLGMOIG@Unknown?5option?5?$CFs?6@ DB 'Unknown option %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPEOOODF@?9?9del@
CONST	SEGMENT
??_C@_05PPEOOODF@?9?9del@ DB '--del', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DDJMKOGD@?9del@
CONST	SEGMENT
??_C@_04DDJMKOGD@?9del@ DB '-del', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BILPODI@?9?9add@
CONST	SEGMENT
??_C@_05BILPODI@?9?9add@ DB '--add', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MNFJLOGO@?9add@
CONST	SEGMENT
??_C@_04MNFJLOGO@?9add@ DB '-add', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KAMKCICF@?9?9no?9super?9update@
CONST	SEGMENT
??_C@_0BC@KAMKCICF@?9?9no?9super?9update@ DB '--no-super-update', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KANDGBAO@?9no?9super?9update@
CONST	SEGMENT
??_C@_0BB@KANDGBAO@?9no?9super?9update@ DB '-no-super-update', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KCEAJNPB@?9?9convert@
CONST	SEGMENT
??_C@_09KCEAJNPB@?9?9convert@ DB '--convert', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BNGAGJEJ@?9convert@
CONST	SEGMENT
??_C@_08BNGAGJEJ@?9convert@ DB '-convert', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GNLFDEKF@?9?9create@
CONST	SEGMENT
??_C@_08GNLFDEKF@?9?9create@ DB '--create', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JNCAJKJG@?9create@
CONST	SEGMENT
??_C@_07JNCAJKJG@?9create@ DB '-create', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OGAPEHEI@?9?9sgml@
CONST	SEGMENT
??_C@_06OGAPEHEI@?9?9sgml@ DB '--sgml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GEMLGBMJ@?9sgml@
CONST	SEGMENT
??_C@_05GEMLGBMJ@?9sgml@ DB '-sgml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PGENFNHA@?9?9shell@
CONST	SEGMENT
??_C@_07PGENFNHA@?9?9shell@ DB '--shell', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GMHACKOA@?9shell@
CONST	SEGMENT
??_C@_06GMHACKOA@?9shell@ DB '-shell', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FHEHAOH@?9?9noout@
CONST	SEGMENT
??_C@_07FHEHAOH@?9?9noout@ DB '--noout', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JPEJAHHH@?9noout@
CONST	SEGMENT
??_C@_06JPEJAHHH@?9noout@ DB '-noout', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OOLJKHBB@?9?9verbose@
CONST	SEGMENT
??_C@_09OOLJKHBB@?9?9verbose@ DB '--verbose', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02EJEOCNCO@?9v@
CONST	SEGMENT
??_C@_02EJEOCNCO@?9v@ DB '-v', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08FBJJFDKJ@?9verbose@
CONST	SEGMENT
??_C@_08FBJJFDKJ@?9verbose@ DB '-verbose', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BDI@HBPONJIE@?7?9?9del?5?8values?8?5?3?5remove?5values@
CONST	SEGMENT
??_C@_0BDI@HBPONJIE@?7?9?9del?5?8values?8?5?3?5remove?5values@ DB 09H, '-'
	DB	'-del ''values'' : remove values', 0aH, 09H, '--noout: avoid d'
	DB	'umping the result on stdout', 0aH, 09H, '         used with -'
	DB	'-add or --del, it saves the catalog changes', 0aH, 09H, '    '
	DB	'     and with --sgml it automatically updates the super catal'
	DB	'og', 0aH, 09H, '--no-super-update: do not update the SGML sup'
	DB	'er catalog', 0aH, 09H, '-v --verbose : provide debug informat'
	DB	'ions', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJG@IFOIFJDI@Usage?5?3?5?$CFs?5?$FLoptions?$FN?5catalogfil@
CONST	SEGMENT
??_C@_0BJG@IFOIFJDI@Usage?5?3?5?$CFs?5?$FLoptions?$FN?5catalogfil@ DB 'Us'
	DB	'age : %s [options] catalogfile entities...', 0aH, 09H, 'Parse'
	DB	' the catalog file (void specification possibly expressed as "'
	DB	'"', 0aH, 09H, 'appoints the default system one) and query it '
	DB	'for the entities', 0aH, 09H, '--sgml : handle SGML Super cata'
	DB	'logs for --add and --del', 0aH, 09H, '--shell : run a shell a'
	DB	'llowing interactive queries', 0aH, 09H, '--create : create a '
	DB	'new catalog', 0aH, 09H, '--add ''type'' ''orig'' ''replace'' '
	DB	': add an XML entry', 0aH, 09H, '--add ''entry'' : add an SGML'
	DB	' entry', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GHCHHEEB@?7exit?3?5?5quit?5the?5shell?6@
CONST	SEGMENT
??_C@_0BI@GHCHHEEB@?7exit?3?5?5quit?5the?5shell?6@ DB 09H, 'exit:  quit t'
	DB	'he shell', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JNOLBMIB@?7quiet?3?5decrease?5the?5verbosity?5@
CONST	SEGMENT
??_C@_0CG@JNOLBMIB@?7quiet?3?5decrease?5the?5verbosity?5@ DB 09H, 'quiet:'
	DB	' decrease the verbosity level', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OIIIIIDP@?7debug?3?5increase?5the?5verbosity?5@
CONST	SEGMENT
??_C@_0CG@OIIIIIDP@?7debug?3?5increase?5the?5verbosity?5@ DB 09H, 'debug:'
	DB	' increase the verbosity level', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@ECEJDHEJ@?7dump?3?5print?5the?5current?5catalo@
CONST	SEGMENT
??_C@_0CI@ECEJDHEJ@?7dump?3?5print?5the?5current?5catalo@ DB 09H, 'dump: '
	DB	'print the current catalog state', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BCHNOEJB@?7del?5?8values?8?5?3?5remove?5values?6@
CONST	SEGMENT
??_C@_0BP@BCHNOEJB@?7del?5?8values?8?5?3?5remove?5values?6@ DB 09H, 'del '
	DB	'''values'' : remove values', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@PJBHDJPC@?7add?5?8type?8?5?8orig?8?5?8replace?8?5?3?5@
CONST	SEGMENT
??_C@_0CN@PJBHDJPC@?7add?5?8type?8?5?8orig?8?5?8replace?8?5?3?5@ DB 09H, 'a'
	DB	'dd ''type'' ''orig'' ''replace'' : add an entry', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@FFOBCHBO@?7resolve?5PublicID?5SystemID?3?5do?5@
CONST	SEGMENT
??_C@_0DH@FFOBCHBO@?7resolve?5PublicID?5SystemID?3?5do?5@ DB 09H, 'resolv'
	DB	'e PublicID SystemID: do a full resolver lookup', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@BFGOGPGB@?7system?5SystemID?3?5make?5a?5SYSTEM@
CONST	SEGMENT
??_C@_0DD@BFGOGPGB@?7system?5SystemID?3?5make?5a?5SYSTEM@ DB 09H, 'system'
	DB	' SystemID: make a SYSTEM identifier lookup', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@BNENJECC@?7public?5PublicID?3?5make?5a?5PUBLIC@
CONST	SEGMENT
??_C@_0DD@BNENJECC@?7public?5PublicID?3?5make?5a?5PUBLIC@ DB 09H, 'public'
	DB	' PublicID: make a PUBLIC identifier lookup', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CNPPMLEL@Commands?5available?3?6@
CONST	SEGMENT
??_C@_0BF@CNPPMLEL@Commands?5available?3?6@ DB 'Commands available:', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LCFAJBIE@Unrecognized?5command?5?$CFs?6@
CONST	SEGMENT
??_C@_0BJ@LCFAJBIE@Unrecognized?5command?5?$CFs?6@ DB 'Unrecognized comma'
	DB	'nd %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJFHION@help@
CONST	SEGMENT
??_C@_04PCJFHION@help@ DB 'help', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CNFOPICG@quiet?5has?5no?5arguments?6@
CONST	SEGMENT
??_C@_0BI@CNFOPICG@quiet?5has?5no?5arguments?6@ DB 'quiet has no argument'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05PMBAOCDH@quiet@
CONST	SEGMENT
??_C@_05PMBAOCDH@quiet@ DB 'quiet', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DPNEIFGM@debug?5has?5no?5arguments?6@
CONST	SEGMENT
??_C@_0BI@DPNEIFGM@debug?5has?5no?5arguments?6@ DB 'debug has no argument'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFCDIDHO@debug@
CONST	SEGMENT
??_C@_05GFCDIDHO@debug@ DB 'debug', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GHHAHJGB@dump?5has?5no?5arguments?6@
CONST	SEGMENT
??_C@_0BH@GHHAHJGB@dump?5has?5no?5arguments?6@ DB 'dump has no arguments', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04GGLOKIEE@dump@
CONST	SEGMENT
??_C@_04GGLOKIEE@dump@ DB 'dump', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FLKMEIPD@Resolver?5failed?5to?5find?5an?5answ@
CONST	SEGMENT
??_C@_0CD@FLKMEIPD@Resolver?5failed?5to?5find?5an?5answ@ DB 'Resolver fai'
	DB	'led to find an answer', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FIFGKLE@resolve?5requires?52?5arguments?6@
CONST	SEGMENT
??_C@_0BO@FIFGKLE@resolve?5requires?52?5arguments?6@ DB 'resolve requires'
	DB	' 2 arguments', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CPEIJHB@resolve@
CONST	SEGMENT
??_C@_07CPEIJHB@resolve@ DB 'resolve', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HPIOAMEN@del?5command?5failed?6@
CONST	SEGMENT
??_C@_0BE@HPIOAMEN@del?5command?5failed?6@ DB 'del command failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PNPKCAGJ@del?5requires?51?6@
CONST	SEGMENT
??_C@_0BA@PNPKCAGJ@del?5requires?51?6@ DB 'del requires 1', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03ONKLGNNH@del@
CONST	SEGMENT
??_C@_03ONKLGNNH@del@ DB 'del', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JELHPCAG@add?5command?5failed?6@
CONST	SEGMENT
??_C@_0BE@JELHPCAG@add?5command?5failed?6@ DB 'add command failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EHJKBIMI@add?5requires?52?5or?53?5arguments?6@
CONST	SEGMENT
??_C@_0BP@EHJKBIMI@add?5requires?52?5or?53?5arguments?6@ DB 'add requires'
	DB	' 2 or 3 arguments', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BDGOHNNK@add@
CONST	SEGMENT
??_C@_03BDGOHNNK@add@ DB 'add', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GPMJOIOL@No?5entry?5for?5SYSTEM?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@GPMJOIOL@No?5entry?5for?5SYSTEM?5?$CFs?6@ DB 'No entry for SYST'
	DB	'EM %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OGHNALCF@system?5requires?51?5arguments?6@
CONST	SEGMENT
??_C@_0BN@OGHNALCF@system?5requires?51?5arguments?6@ DB 'system requires '
	DB	'1 arguments', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system@
CONST	SEGMENT
??_C@_06FHFOAHML@system@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FFIBJMM@No?5entry?5for?5PUBLIC?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@FFIBJMM@No?5entry?5for?5PUBLIC?5?$CFs?6@ DB 'No entry for PUBLI'
	DB	'C %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DCAIANKH@public?5requires?51?5arguments?6@
CONST	SEGMENT
??_C@_0BN@DCAIANKH@public?5requires?51?5arguments?6@ DB 'public requires '
	DB	'1 arguments', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06EOMAMIIF@public@
CONST	SEGMENT
??_C@_06EOMAMIIF@public@ DB 'public', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MDONDFG@bye@
CONST	SEGMENT
??_C@_03MDONDFG@bye@ DB 'bye', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KNNLNNGO@quit@
CONST	SEGMENT
??_C@_04KNNLNNGO@quit@ DB 'quit', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKNBDEPB@exit@
CONST	SEGMENT
??_C@_04MKNBDEPB@exit@ DB 'exit', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LLMPMKNF@?$DO?5@
CONST	SEGMENT
??_C@_02LLMPMKNF@?$DO?5@ DB '> ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlcatalog.c
;	COMDAT _main
_TEXT	SEGMENT
tv519 = -20						; size = 4
_i$3$ = -16						; size = 4
_exit_value$1$ = -12					; size = 4
tv514 = -8						; size = 4
tv807 = -4						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 330  : int main(int argc, char **argv) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	mov	ecx, OFFSET __6F93E186_xmlcatalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _argc$[ebp]
	mov	DWORD PTR _exit_value$1$[ebp], 0
	cmp	ebx, 1
	jg	SHORT $LN14@main

; 313  :     printf("\

	mov	eax, DWORD PTR _argv$[ebp]
	push	DWORD PTR [eax]
	push	OFFSET ??_C@_0BJG@IFOIFJDI@Usage?5?3?5?$CFs?5?$FLoptions?$FN?5catalogfil@
	call	_printf

; 314  : Usage : %s [options] catalogfile entities...\n\
; 315  : \tParse the catalog file (void specification possibly expressed as \"\"\n\
; 316  : \tappoints the default system one) and query it for the entities\n\
; 317  : \t--sgml : handle SGML Super catalogs for --add and --del\n\
; 318  : \t--shell : run a shell allowing interactive queries\n\
; 319  : \t--create : create a new catalog\n\
; 320  : \t--add 'type' 'orig' 'replace' : add an XML entry\n\
; 321  : \t--add 'entry' : add an SGML entry\n", name);
; 322  :     printf("\

	push	OFFSET ??_C@_0BDI@HBPONJIE@?7?9?9del?5?8values?8?5?3?5remove?5values@
	call	_printf
	add	esp, 12					; 0000000cH

; 331  :     int i;
; 332  :     int ret;
; 333  :     int exit_value = 0;
; 334  : 
; 335  : 
; 336  :     if (argc <= 1) {
; 337  : 	usage(argv[0]);
; 338  : 	return(1);

	mov	eax, 1
	pop	ebx

; 618  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@main:
	push	edi

; 339  :     }
; 340  : 
; 341  :     LIBXML_TEST_VERSION

	push	20909					; 000051adH
	call	_xmlCheckVersion
	add	esp, 4

; 342  :     for (i = 1; i < argc ; i++) {

	mov	edi, 1
	push	esi
	npad	6
$LL4@main:

; 343  : 	if (!strcmp(argv[i], "-"))

	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, OFFSET ??_C@_01JOAMLHOP@?9@
	mov	esi, DWORD PTR [eax+edi*4]
	mov	eax, esi
	npad	3
$LL146@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN147@main
	test	dl, dl
	je	SHORT $LN148@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN147@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL146@main
$LN148@main:
	xor	eax, eax
	jmp	SHORT $LN149@main
$LN147@main:
	sbb	eax, eax
	or	eax, 1
$LN149@main:
	test	eax, eax
	je	$LN144@main

; 344  : 	    break;
; 345  : 
; 346  : 	if (argv[i][0] != '-')

	cmp	BYTE PTR [esi], 45			; 0000002dH
	jne	$LN144@main

; 347  : 	    break;
; 348  : 	if ((!strcmp(argv[i], "-verbose")) ||
; 349  : 	    (!strcmp(argv[i], "-v")) ||

	mov	ecx, OFFSET ??_C@_08FBJJFDKJ@?9verbose@
	mov	eax, esi
	npad	3
$LL150@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN151@main
	test	dl, dl
	je	SHORT $LN152@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN151@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL150@main
$LN152@main:
	xor	eax, eax
	jmp	SHORT $LN153@main
$LN151@main:
	sbb	eax, eax
	or	eax, 1
$LN153@main:
	test	eax, eax
	je	$LN19@main
	mov	ecx, OFFSET ??_C@_02EJEOCNCO@?9v@
	mov	eax, esi
$LL154@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN155@main
	test	dl, dl
	je	SHORT $LN156@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN155@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL154@main
$LN156@main:
	xor	eax, eax
	jmp	SHORT $LN157@main
$LN155@main:
	sbb	eax, eax
	or	eax, 1
$LN157@main:
	test	eax, eax
	je	$LN19@main
	mov	ecx, OFFSET ??_C@_09OOLJKHBB@?9?9verbose@
	mov	eax, esi
$LL158@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN159@main
	test	dl, dl
	je	SHORT $LN160@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN159@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL158@main
$LN160@main:
	xor	eax, eax
	jmp	SHORT $LN161@main
$LN159@main:
	sbb	eax, eax
	or	eax, 1
$LN161@main:
	test	eax, eax
	je	$LN19@main

; 353  : 	} else if ((!strcmp(argv[i], "-noout")) ||

	mov	ecx, OFFSET ??_C@_06JPEJAHHH@?9noout@
	mov	eax, esi
	npad	4
$LL162@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN163@main
	test	dl, dl
	je	SHORT $LN164@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN163@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL162@main
$LN164@main:
	xor	eax, eax
	jmp	SHORT $LN165@main
$LN163@main:
	sbb	eax, eax
	or	eax, 1
$LN165@main:
	test	eax, eax
	je	$LN22@main
	mov	ecx, OFFSET ??_C@_07FHEHAOH@?9?9noout@
	mov	eax, esi
$LL166@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN167@main
	test	dl, dl
	je	SHORT $LN168@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN167@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL166@main
$LN168@main:
	xor	eax, eax
	jmp	SHORT $LN169@main
$LN167@main:
	sbb	eax, eax
	or	eax, 1
$LN169@main:
	test	eax, eax
	je	$LN22@main

; 354  : 	    (!strcmp(argv[i], "--noout"))) {
; 355  :             noout = 1;
; 356  : 	} else if ((!strcmp(argv[i], "-shell")) ||

	mov	ecx, OFFSET ??_C@_06GMHACKOA@?9shell@
	mov	eax, esi
$LL170@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN171@main
	test	dl, dl
	je	SHORT $LN172@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN171@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL170@main
$LN172@main:
	xor	eax, eax
	jmp	SHORT $LN173@main
$LN171@main:
	sbb	eax, eax
	or	eax, 1
$LN173@main:
	test	eax, eax
	je	$LN25@main
	mov	ecx, OFFSET ??_C@_07PGENFNHA@?9?9shell@
	mov	eax, esi
	npad	4
$LL174@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN175@main
	test	dl, dl
	je	SHORT $LN176@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN175@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL174@main
$LN176@main:
	xor	eax, eax
	jmp	SHORT $LN177@main
$LN175@main:
	sbb	eax, eax
	or	eax, 1
$LN177@main:
	test	eax, eax
	je	$LN25@main

; 359  :             noout = 1;
; 360  : 	} else if ((!strcmp(argv[i], "-sgml")) ||

	mov	ecx, OFFSET ??_C@_05GEMLGBMJ@?9sgml@
	mov	eax, esi
$LL178@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN179@main
	test	dl, dl
	je	SHORT $LN180@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN179@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL178@main
$LN180@main:
	xor	eax, eax
	jmp	SHORT $LN181@main
$LN179@main:
	sbb	eax, eax
	or	eax, 1
$LN181@main:
	test	eax, eax
	je	$LN28@main
	mov	ecx, OFFSET ??_C@_06OGAPEHEI@?9?9sgml@
	mov	eax, esi
$LL182@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN183@main
	test	dl, dl
	je	SHORT $LN184@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN183@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL182@main
$LN184@main:
	xor	eax, eax
	jmp	SHORT $LN185@main
$LN183@main:
	sbb	eax, eax
	or	eax, 1
$LN185@main:
	test	eax, eax
	je	$LN28@main

; 363  : 	} else if ((!strcmp(argv[i], "-create")) ||

	mov	ecx, OFFSET ??_C@_07JNCAJKJG@?9create@
	mov	eax, esi
	npad	4
$LL186@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN187@main
	test	dl, dl
	je	SHORT $LN188@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN187@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL186@main
$LN188@main:
	xor	eax, eax
	jmp	SHORT $LN189@main
$LN187@main:
	sbb	eax, eax
	or	eax, 1
$LN189@main:
	test	eax, eax
	je	$LN31@main
	mov	ecx, OFFSET ??_C@_08GNLFDEKF@?9?9create@
	mov	eax, esi
$LL190@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN191@main
	test	dl, dl
	je	SHORT $LN192@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN191@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL190@main
$LN192@main:
	xor	eax, eax
	jmp	SHORT $LN193@main
$LN191@main:
	sbb	eax, eax
	or	eax, 1
$LN193@main:
	test	eax, eax
	je	$LN31@main

; 366  : 	} else if ((!strcmp(argv[i], "-convert")) ||

	mov	ecx, OFFSET ??_C@_08BNGAGJEJ@?9convert@
	mov	eax, esi
$LL194@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN195@main
	test	dl, dl
	je	SHORT $LN196@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN195@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL194@main
$LN196@main:
	xor	eax, eax
	jmp	SHORT $LN197@main
$LN195@main:
	sbb	eax, eax
	or	eax, 1
$LN197@main:
	test	eax, eax
	je	$LN34@main
	mov	ecx, OFFSET ??_C@_09KCEAJNPB@?9?9convert@
	mov	eax, esi
	npad	4
$LL198@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN199@main
	test	dl, dl
	je	SHORT $LN200@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN199@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL198@main
$LN200@main:
	xor	eax, eax
	jmp	SHORT $LN201@main
$LN199@main:
	sbb	eax, eax
	or	eax, 1
$LN201@main:
	test	eax, eax
	je	$LN34@main

; 369  : 	} else if ((!strcmp(argv[i], "-no-super-update")) ||

	mov	ecx, OFFSET ??_C@_0BB@KANDGBAO@?9no?9super?9update@
	mov	eax, esi
$LL202@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN203@main
	test	dl, dl
	je	SHORT $LN204@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN203@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL202@main
$LN204@main:
	xor	eax, eax
	jmp	SHORT $LN205@main
$LN203@main:
	sbb	eax, eax
	or	eax, 1
$LN205@main:
	test	eax, eax
	je	$LN37@main
	mov	ecx, OFFSET ??_C@_0BC@KAMKCICF@?9?9no?9super?9update@
	mov	eax, esi
$LL206@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN207@main
	test	dl, dl
	je	SHORT $LN208@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN207@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL206@main
$LN208@main:
	xor	eax, eax
	jmp	SHORT $LN209@main
$LN207@main:
	sbb	eax, eax
	or	eax, 1
$LN209@main:
	test	eax, eax
	je	$LN37@main

; 372  : 	} else if ((!strcmp(argv[i], "-add")) ||

	mov	ecx, OFFSET ??_C@_04MNFJLOGO@?9add@
	mov	eax, esi
	npad	4
$LL210@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN211@main
	test	dl, dl
	je	SHORT $LN212@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN211@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL210@main
$LN212@main:
	xor	eax, eax
	jmp	SHORT $LN213@main
$LN211@main:
	sbb	eax, eax
	or	eax, 1
$LN213@main:
	test	eax, eax
	je	$LN40@main
	mov	ecx, OFFSET ??_C@_05BILPODI@?9?9add@
	mov	eax, esi
$LL214@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN215@main
	test	dl, dl
	je	SHORT $LN216@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN215@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL214@main
$LN216@main:
	xor	eax, eax
	jmp	SHORT $LN217@main
$LN215@main:
	sbb	eax, eax
	or	eax, 1
$LN217@main:
	test	eax, eax
	je	SHORT $LN40@main

; 379  : 	} else if ((!strcmp(argv[i], "-del")) ||

	mov	ecx, OFFSET ??_C@_04DDJMKOGD@?9del@
	mov	eax, esi
$LL218@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN219@main
	test	dl, dl
	je	SHORT $LN220@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN219@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL218@main
$LN220@main:
	xor	eax, eax
	jmp	SHORT $LN221@main
$LN219@main:
	sbb	eax, eax
	or	eax, 1
$LN221@main:
	test	eax, eax
	je	SHORT $LN45@main
	mov	ecx, OFFSET ??_C@_05PPEOOODF@?9?9del@
	mov	eax, esi
$LL222@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN223@main
	test	dl, dl
	je	SHORT $LN224@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN223@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL222@main
$LN224@main:
	xor	eax, eax
	jmp	SHORT $LN225@main
$LN223@main:
	sbb	eax, eax
	or	eax, 1
$LN225@main:
	test	eax, eax
	jne	$LN43@main
$LN45@main:

; 380  : 	    (!strcmp(argv[i], "--del"))) {
; 381  : 	    i += 1;

	inc	edi

; 382  : 	    del++;

	inc	DWORD PTR _del

; 383  : 	} else {

	jmp	SHORT $LN2@main
$LN40@main:

; 373  : 	    (!strcmp(argv[i], "--add"))) {
; 374  : 	    if (sgml)

	mov	eax, DWORD PTR _sgml
	neg	eax
	sbb	eax, eax

; 375  : 		i += 2;
; 376  : 	    else
; 377  : 		i += 3;
; 378  : 	    add++;

	inc	DWORD PTR _add
	add	eax, 3
	add	edi, eax
	jmp	SHORT $LN2@main
$LN37@main:

; 370  : 	    (!strcmp(argv[i], "--no-super-update"))) {
; 371  : 	    no_super_update++;

	inc	DWORD PTR _no_super_update
	jmp	SHORT $LN2@main
$LN34@main:

; 367  : 	    (!strcmp(argv[i], "--convert"))) {
; 368  : 	    convert++;

	inc	DWORD PTR _convert
	jmp	SHORT $LN2@main
$LN31@main:

; 364  : 	    (!strcmp(argv[i], "--create"))) {
; 365  : 	    create++;

	inc	DWORD PTR _create
	jmp	SHORT $LN2@main
$LN28@main:

; 361  : 	    (!strcmp(argv[i], "--sgml"))) {
; 362  : 	    sgml++;

	inc	DWORD PTR _sgml
	jmp	SHORT $LN2@main
$LN25@main:

; 357  : 	    (!strcmp(argv[i], "--shell"))) {
; 358  : 	    shell++;

	inc	DWORD PTR _shell
$LN22@main:

; 342  :     for (i = 1; i < argc ; i++) {

	mov	DWORD PTR _noout, 1
	jmp	SHORT $LN2@main
$LN19@main:

; 350  : 	    (!strcmp(argv[i], "--verbose"))) {
; 351  : 	    verbose++;

	mov	eax, DWORD PTR _verbose
	inc	eax

; 352  : 	    xmlCatalogSetDebug(verbose);

	push	eax
	mov	DWORD PTR _verbose, eax
	call	_xmlCatalogSetDebug
	add	esp, 4
$LN2@main:

; 342  :     for (i = 1; i < argc ; i++) {

	inc	edi
	cmp	edi, ebx
	jl	$LL4@main
$LN144@main:

; 387  : 	}
; 388  :     }
; 389  : 
; 390  :     for (i = 1; i < argc; i++) {

	mov	esi, 1
	cmp	ebx, esi
	jle	$LN302@main
	lea	edi, DWORD PTR [esi+1]
	npad	1
$LL7@main:

; 391  : 	if ((!strcmp(argv[i], "-add")) ||

	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, OFFSET ??_C@_04MNFJLOGO@?9add@
	mov	ebx, DWORD PTR [eax+esi*4]
	mov	eax, ebx
	npad	3
$LL226@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN227@main
	test	dl, dl
	je	SHORT $LN228@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN227@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL226@main
$LN228@main:
	xor	eax, eax
	jmp	SHORT $LN229@main
$LN43@main:

; 384  : 	    fprintf(stderr, "Unknown option %s\n", argv[i]);

	push	esi
	push	OFFSET ??_C@_0BD@PDLGMOIG@Unknown?5option?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf

; 385  : 	    usage(argv[0]);

	mov	eax, DWORD PTR _argv$[ebp]
	push	DWORD PTR [eax]
	call	_usage
	add	esp, 16					; 00000010H

; 386  : 	    return(1);

	mov	eax, 1
	pop	esi
	pop	edi
	pop	ebx

; 618  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN227@main:

; 391  : 	if ((!strcmp(argv[i], "-add")) ||

	sbb	eax, eax
	or	eax, 1
$LN229@main:
	test	eax, eax
	je	$LN48@main
	mov	ecx, OFFSET ??_C@_05BILPODI@?9?9add@
	mov	eax, ebx
$LL230@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN231@main
	test	dl, dl
	je	SHORT $LN232@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN231@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL230@main
$LN232@main:
	xor	eax, eax
	jmp	SHORT $LN233@main
$LN231@main:
	sbb	eax, eax
	or	eax, 1
$LN233@main:
	test	eax, eax
	je	$LN48@main

; 397  : 	    continue;
; 398  : 	} else if ((!strcmp(argv[i], "-del")) ||

	mov	ecx, OFFSET ??_C@_04DDJMKOGD@?9del@
	mov	eax, ebx
$LL234@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN235@main
	test	dl, dl
	je	SHORT $LN236@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN235@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL234@main
$LN236@main:
	xor	eax, eax
	jmp	SHORT $LN237@main
$LN235@main:
	sbb	eax, eax
	or	eax, 1
$LN237@main:
	test	eax, eax
	je	$LN53@main
	mov	ecx, OFFSET ??_C@_05PPEOOODF@?9?9del@
	mov	eax, ebx
	npad	4
$LL238@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN239@main
	test	dl, dl
	je	SHORT $LN240@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN239@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL238@main
$LN240@main:
	xor	eax, eax
	jmp	SHORT $LN241@main
$LN239@main:
	sbb	eax, eax
	or	eax, 1
$LN241@main:
	test	eax, eax
	je	SHORT $LN53@main

; 407  : 	    }
; 408  : 
; 409  : 	    continue;
; 410  : 	} else if (argv[i][0] == '-')

	mov	al, BYTE PTR [ebx]
	cmp	al, 45					; 0000002dH
	je	$LN305@main

; 411  : 	    continue;
; 412  : 
; 413  : 	if (filename == NULL && argv[i][0] == '\0') {

	cmp	DWORD PTR _filename, 0
	jne	$LN57@main
	test	al, al
	jne	$LN57@main

; 414  : 	    /* Interpret empty-string catalog specification as
; 415  : 	       a shortcut for a default system catalog. */
; 416  : 	    xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN302@main:

; 422  : 	    }
; 423  : 	}
; 424  : 	break;
; 425  :     }
; 426  : 
; 427  :     if (convert)

	mov	edi, DWORD PTR _argv$[ebp]
$LN145@main:
	cmp	DWORD PTR _convert, 0
	je	SHORT $LN60@main

; 428  :         ret = xmlCatalogConvert();

	call	_xmlCatalogConvert
$LN60@main:

; 429  : 
; 430  :     if ((add) || (del)) {

	cmp	DWORD PTR _add, 0
	mov	ebx, DWORD PTR __imp____acrt_iob_func
	jne	$LN63@main
	cmp	DWORD PTR _del, 0
	jne	$LN63@main

; 554  : 		}
; 555  : 	    }
; 556  : 	}
; 557  : 
; 558  :     } else if (shell) {

	cmp	DWORD PTR _shell, 0
	je	$LN102@main

; 559  : 	usershell();

	call	_usershell

; 560  :     } else {

	jmp	$LN289@main
$LN53@main:

; 399  : 	    (!strcmp(argv[i], "--del"))) {
; 400  : 	    i += 1;
; 401  : 
; 402  : 	    /* No catalog entry specified */
; 403  : 	    if (i == argc || (sgml && i + 1 == argc)) {

	mov	ebx, DWORD PTR _argc$[ebp]
	inc	esi
	inc	edi
	cmp	esi, ebx
	je	SHORT $LN129@main
	cmp	DWORD PTR _sgml, 0
	je	SHORT $LN5@main
	cmp	edi, ebx
	jne	SHORT $LN5@main
$LN129@main:

; 404  : 		fprintf(stderr, "No catalog entry specified to remove from\n");

	push	OFFSET ??_C@_0CL@LMPCJLGA@No?5catalog?5entry?5specified?5to?5r@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf

; 313  :     printf("\

	mov	eax, DWORD PTR _argv$[ebp]
	push	DWORD PTR [eax]
	push	OFFSET ??_C@_0BJG@IFOIFJDI@Usage?5?3?5?$CFs?5?$FLoptions?$FN?5catalogfil@
	call	_printf

; 314  : Usage : %s [options] catalogfile entities...\n\
; 315  : \tParse the catalog file (void specification possibly expressed as \"\"\n\
; 316  : \tappoints the default system one) and query it for the entities\n\
; 317  : \t--sgml : handle SGML Super catalogs for --add and --del\n\
; 318  : \t--shell : run a shell allowing interactive queries\n\
; 319  : \t--create : create a new catalog\n\
; 320  : \t--add 'type' 'orig' 'replace' : add an XML entry\n\
; 321  : \t--add 'entry' : add an SGML entry\n", name);
; 322  :     printf("\

	push	OFFSET ??_C@_0BDI@HBPONJIE@?7?9?9del?5?8values?8?5?3?5remove?5values@
	call	_printf
	add	esp, 20					; 00000014H

; 405  : 		usage (argv[0]);
; 406  : 		return(1);

	mov	eax, 1
	pop	esi
	pop	edi
	pop	ebx

; 618  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@main:

; 392  : 	    (!strcmp(argv[i], "--add"))) {
; 393  : 	    if (sgml)

	cmp	DWORD PTR _sgml, 0
	je	SHORT $LN49@main

; 394  : 		i += 2;

	add	esi, 2
	add	edi, 2
	jmp	SHORT $LN305@main
$LN49@main:

; 395  : 	    else
; 396  : 		i += 3;

	add	esi, 3
	add	edi, 3
$LN305@main:

; 387  : 	}
; 388  :     }
; 389  : 
; 390  :     for (i = 1; i < argc; i++) {

	mov	ebx, DWORD PTR _argc$[ebp]
$LN5@main:
	inc	esi
	inc	edi
	cmp	esi, ebx
	jl	$LL7@main
	jmp	$LN302@main
$LN57@main:

; 417  : 	} else {
; 418  : 	    filename = argv[i];
; 419  : 	    ret = xmlLoadCatalog(argv[i]);

	push	ebx
	mov	DWORD PTR _filename, ebx
	call	_xmlLoadCatalog
	add	esp, 4

; 420  : 	    if ((ret < 0) && (create)) {

	test	eax, eax
	jns	$LN302@main
	cmp	DWORD PTR _create, 0
	mov	edi, DWORD PTR _argv$[ebp]
	je	$LN145@main

; 421  : 		xmlCatalogAdd(BAD_CAST "catalog", BAD_CAST argv[i], NULL);

	push	0
	push	DWORD PTR [edi+esi*4]
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	call	_xmlCatalogAdd
	add	esp, 12					; 0000000cH
	jmp	$LN145@main
$LN102@main:

; 561  : 	for (i++; i < argc; i++) {

	inc	esi
	cmp	esi, DWORD PTR _argc$[ebp]
	jge	$LN289@main
	npad	6
$LL13@main:

; 562  : 	    xmlURIPtr uri;
; 563  : 	    xmlChar *ans;
; 564  : 
; 565  : 	    uri = xmlParseURI(argv[i]);

	push	DWORD PTR [edi+esi*4]
	call	_xmlParseURI
	add	esp, 4

; 566  : 	    if (uri == NULL) {

	test	eax, eax
	jne	SHORT $LN104@main

; 567  : 		ans = xmlCatalogResolvePublic((const xmlChar *) argv[i]);

	push	DWORD PTR [edi+esi*4]
	call	_xmlCatalogResolvePublic
	mov	edi, eax
	add	esp, 4

; 568  : 		if (ans == NULL) {

	test	edi, edi
	jne	SHORT $LN108@main

; 569  : 		    printf("No entry for PUBLIC %s\n", argv[i]);

	mov	edi, DWORD PTR _argv$[ebp]
	push	DWORD PTR [edi+esi*4]
	push	OFFSET ??_C@_0BI@FFIBJMM@No?5entry?5for?5PUBLIC?5?$CFs?6@
	call	_printf
	add	esp, 8

; 570  : 		    exit_value = 4;

	mov	DWORD PTR _exit_value$1$[ebp], 4

; 571  : 		} else {
; 572  : 		    printf("%s\n", (char *) ans);
; 573  : 		    xmlFree(ans);
; 574  : 		}
; 575  : 	    } else {

	jmp	SHORT $LN11@main
$LN104@main:

; 576  :                 xmlFreeURI(uri);

	push	eax
	call	_xmlFreeURI

; 577  : 		ans = xmlCatalogResolveSystem((const xmlChar *) argv[i]);

	push	DWORD PTR [edi+esi*4]
	call	_xmlCatalogResolveSystem
	mov	edi, eax
	add	esp, 8

; 578  : 		if (ans == NULL) {

	test	edi, edi
	jne	SHORT $LN108@main

; 579  : 		    printf("No entry for SYSTEM %s\n", argv[i]);

	mov	edi, DWORD PTR _argv$[ebp]
	push	DWORD PTR [edi+esi*4]
	push	OFFSET ??_C@_0BI@GPMJOIOL@No?5entry?5for?5SYSTEM?5?$CFs?6@
	call	_printf

; 580  : 		    ans = xmlCatalogResolveURI ((const xmlChar *) argv[i]);

	push	DWORD PTR [edi+esi*4]
	call	_xmlCatalogResolveURI
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 581  : 		    if (ans == NULL) {

	test	edi, edi
	jne	SHORT $LN108@main

; 582  : 			printf ("No entry for URI %s\n", argv[i]);

	mov	edi, DWORD PTR _argv$[ebp]
	push	DWORD PTR [edi+esi*4]
	push	OFFSET ??_C@_0BF@IAFAHEGC@No?5entry?5for?5URI?5?$CFs?6@
	call	_printf
	add	esp, 8

; 583  : 		        exit_value = 4;

	mov	DWORD PTR _exit_value$1$[ebp], 4

; 584  : 		    } else {

	jmp	SHORT $LN11@main
$LN108@main:

; 561  : 	for (i++; i < argc; i++) {

	push	edi
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	call	_printf
	mov	eax, DWORD PTR __imp__xmlFree
	push	edi
	mov	eax, DWORD PTR [eax]
	call	eax
	mov	edi, DWORD PTR _argv$[ebp]
	add	esp, 12					; 0000000cH
$LN11@main:
	inc	esi
	cmp	esi, DWORD PTR _argc$[ebp]
	jl	$LL13@main

; 432  : 	    if (!strcmp(argv[i], "-"))

	jmp	$LN289@main
$LN63@main:

; 431  : 	for (i = 1; i < argc ; i++) {

	mov	esi, 1
	mov	DWORD PTR _i$3$[ebp], esi
	cmp	DWORD PTR _argc$[ebp], esi
	jle	$LN289@main
	lea	ebx, DWORD PTR [edi+12]
	lea	eax, DWORD PTR [edi+16]
	mov	DWORD PTR tv519[ebp], ebx
	mov	DWORD PTR tv514[ebp], eax
	npad	9
$LL10@main:

; 432  : 	    if (!strcmp(argv[i], "-"))

	mov	eax, DWORD PTR _argv$[ebp]
	lea	edi, DWORD PTR [esi*4]
	mov	DWORD PTR tv807[ebp], edi
	mov	ecx, OFFSET ??_C@_01JOAMLHOP@?9@
	mov	esi, DWORD PTR [edi+eax]
	mov	eax, esi
$LL242@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN243@main
	test	dl, dl
	je	SHORT $LN244@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN243@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL242@main
$LN244@main:
	xor	eax, eax
	jmp	SHORT $LN245@main
$LN243@main:
	sbb	eax, eax
	or	eax, 1
$LN245@main:
	test	eax, eax
	je	$LN290@main

; 433  : 		break;
; 434  : 
; 435  : 	    if (argv[i][0] != '-')

	cmp	BYTE PTR [esi], 45			; 0000002dH
	jne	$LN300@main

; 436  : 		continue;
; 437  : 	    if (strcmp(argv[i], "-add") && strcmp(argv[i], "--add") &&
; 438  : 		strcmp(argv[i], "-del") && strcmp(argv[i], "--del"))

	mov	ecx, OFFSET ??_C@_04MNFJLOGO@?9add@
	mov	eax, esi
$LL246@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN247@main
	test	dl, dl
	je	SHORT $LN248@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN247@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL246@main
$LN248@main:
	xor	eax, eax
	jmp	SHORT $LN249@main
$LN247@main:
	sbb	eax, eax
	or	eax, 1
$LN249@main:
	test	eax, eax
	je	$LN66@main
	mov	ecx, OFFSET ??_C@_05BILPODI@?9?9add@
	mov	eax, esi
$LL250@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN251@main
	test	dl, dl
	je	SHORT $LN252@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN251@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL250@main
$LN252@main:
	xor	eax, eax
	jmp	SHORT $LN253@main
$LN251@main:
	sbb	eax, eax
	or	eax, 1
$LN253@main:
	test	eax, eax
	je	SHORT $LN66@main
	mov	ecx, OFFSET ??_C@_04DDJMKOGD@?9del@
	mov	eax, esi
$LL254@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN255@main
	test	dl, dl
	je	SHORT $LN256@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN255@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL254@main
$LN256@main:
	xor	eax, eax
	jmp	SHORT $LN257@main
$LN255@main:
	sbb	eax, eax
	or	eax, 1
$LN257@main:
	test	eax, eax
	je	SHORT $LN66@main
	mov	ecx, OFFSET ??_C@_05PPEOOODF@?9?9del@
	mov	eax, esi
$LL258@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN259@main
	test	dl, dl
	je	SHORT $LN260@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN259@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL258@main
$LN260@main:
	xor	eax, eax
	jmp	SHORT $LN261@main
$LN259@main:
	sbb	eax, eax
	or	eax, 1
$LN261@main:
	test	eax, eax
	jne	$LN300@main
$LN66@main:

; 439  : 		continue;
; 440  : 
; 441  : 	    if (sgml) {

	cmp	DWORD PTR _sgml, 0
	je	$LN67@main

; 442  : 		/*
; 443  : 		 * Maintenance of SGML catalogs.
; 444  : 		 */
; 445  : 		xmlCatalogPtr catal = NULL;
; 446  : 		xmlCatalogPtr super = NULL;
; 447  : 
; 448  : 		catal = xmlLoadSGMLSuperCatalog(argv[i + 1]);

	mov	esi, DWORD PTR _argv$[ebp]
	xor	ebx, ebx
	push	DWORD PTR [edi+esi+4]
	call	_xmlLoadSGMLSuperCatalog
	mov	edi, eax
	add	esp, 4

; 449  : 
; 450  : 		if ((!strcmp(argv[i], "-add")) ||

	mov	eax, DWORD PTR tv807[ebp]
	mov	ecx, OFFSET ??_C@_04MNFJLOGO@?9add@
	mov	esi, DWORD PTR [eax+esi]
	mov	eax, esi
$LL262@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN263@main
	test	dl, dl
	je	SHORT $LN264@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN263@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL262@main
$LN264@main:
	xor	eax, eax
	jmp	SHORT $LN265@main
$LN263@main:
	sbb	eax, eax
	or	eax, 1
$LN265@main:
	test	eax, eax
	je	$LN71@main
	mov	eax, OFFSET ??_C@_05BILPODI@?9?9add@
$LL266@main:
	mov	cl, BYTE PTR [esi]
	cmp	cl, BYTE PTR [eax]
	jne	SHORT $LN267@main
	test	cl, cl
	je	SHORT $LN268@main
	mov	cl, BYTE PTR [esi+1]
	cmp	cl, BYTE PTR [eax+1]
	jne	SHORT $LN267@main
	add	esi, 2
	add	eax, 2
	test	cl, cl
	jne	SHORT $LL266@main
$LN268@main:
	xor	eax, eax
	jmp	SHORT $LN269@main
$LN267@main:
	sbb	eax, eax
	or	eax, 1
$LN269@main:
	test	eax, eax
	je	$LN71@main

; 463  : 					     BAD_CAST argv[i + 1], NULL);
; 464  : 		    }
; 465  : 		} else {
; 466  : 		    if (catal != NULL)

	test	edi, edi
	je	SHORT $LN143@main

; 467  : 			ret = xmlACatalogRemove(catal, BAD_CAST argv[i + 2]);

	mov	eax, DWORD PTR tv519[ebp]
	push	DWORD PTR [eax]
	push	edi
	call	_xmlACatalogRemove
	add	esp, 8

; 468  : 		    else
; 469  : 			ret = -1;
; 470  : 		    if (ret < 0) {

	test	eax, eax
	jns	SHORT $LN291@main
$LN143@main:

; 471  : 			fprintf(stderr, "Failed to remove entry from %s\n",

	mov	eax, DWORD PTR _argv$[ebp]
	mov	esi, DWORD PTR tv807[ebp]
	push	DWORD PTR [esi+eax+4]
	push	OFFSET ??_C@_0CA@DECJMEJL@Failed?5to?5remove?5entry?5from?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 472  : 				argv[i + 1]);
; 473  : 			exit_value = 1;

	mov	DWORD PTR _exit_value$1$[ebp], 1
	jmp	SHORT $LN77@main
$LN291@main:

; 468  : 		    else
; 469  : 			ret = -1;
; 470  : 		    if (ret < 0) {

	mov	esi, DWORD PTR tv807[ebp]
$LN77@main:

; 474  : 		    }
; 475  : 		    if ((!no_super_update) && (noout) && (catal != NULL) &&

	cmp	DWORD PTR _no_super_update, ebx
	jne	SHORT $LN297@main
	cmp	DWORD PTR _noout, ebx
	je	$LN81@main
	test	edi, edi
	je	SHORT $LN297@main
	push	edi
	call	_xmlCatalogIsEmpty
	add	esp, 4
	test	eax, eax
	je	SHORT $LN297@main

; 476  : 			(xmlCatalogIsEmpty(catal))) {
; 477  : 			super = xmlLoadSGMLSuperCatalog(

	push	OFFSET ??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@
	call	_xmlLoadSGMLSuperCatalog
	mov	ebx, eax
	add	esp, 4

; 478  : 				   XML_SGML_DEFAULT_CATALOG);
; 479  : 			if (super != NULL) {

	test	ebx, ebx
	je	SHORT $LN297@main

; 480  : 			    ret = xmlACatalogRemove(super,

	mov	eax, DWORD PTR _argv$[ebp]
	push	DWORD PTR [esi+eax+4]
	push	ebx
	call	_xmlACatalogRemove
	add	esp, 8

; 481  : 				    BAD_CAST argv[i + 1]);
; 482  : 			    if (ret < 0) {

	test	eax, eax
	jns	SHORT $LN297@main

; 483  : 				fprintf(stderr,

	push	OFFSET ??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@
	push	OFFSET ??_C@_0CA@DECJMEJL@Failed?5to?5remove?5entry?5from?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 484  : 					"Failed to remove entry from %s\n",
; 485  : 					XML_SGML_DEFAULT_CATALOG);
; 486  : 				exit_value = 1;

	mov	DWORD PTR _exit_value$1$[ebp], 1
$LN297@main:

; 487  : 			    }
; 488  : 			}
; 489  : 		    }
; 490  : 		}
; 491  : 		if (noout) {

	mov	esi, DWORD PTR tv807[ebp]
$LN288@main:
	cmp	DWORD PTR _noout, 0
	je	$LN81@main

; 492  : 		    FILE *out;
; 493  : 
; 494  : 		    if (xmlCatalogIsEmpty(catal)) {

	push	edi
	call	_xmlCatalogIsEmpty
	mov	ecx, DWORD PTR _argv$[ebp]
	add	esp, 4
	mov	ecx, DWORD PTR [esi+ecx+4]
	test	eax, eax
	je	SHORT $LN83@main

; 495  : 			remove(argv[i + 1]);

	mov	esi, DWORD PTR __imp__remove
	push	ecx
	call	esi
	add	esp, 4

; 496  : 		    } else {

	jmp	$LN309@main
$LN71@main:

; 451  : 		    (!strcmp(argv[i], "--add"))) {
; 452  : 		    if (catal == NULL)

	test	edi, edi
	jne	SHORT $LN72@main

; 453  : 			catal = xmlNewCatalog(1);

	push	1
	call	_xmlNewCatalog
	add	esp, 4
	mov	edi, eax
$LN72@main:

; 454  : 		    xmlACatalogAdd(catal, BAD_CAST "CATALOG",

	mov	eax, DWORD PTR tv519[ebp]
	push	0
	push	DWORD PTR [eax]
	push	OFFSET ??_C@_07DIADFEPH@CATALOG@
	push	edi
	call	_xmlACatalogAdd
	add	esp, 16					; 00000010H

; 455  : 					 BAD_CAST argv[i + 2], NULL);
; 456  : 
; 457  : 		    if (!no_super_update) {

	cmp	DWORD PTR _no_super_update, ebx
	jne	SHORT $LN297@main

; 458  : 			super = xmlLoadSGMLSuperCatalog(XML_SGML_DEFAULT_CATALOG);

	push	OFFSET ??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@
	call	_xmlLoadSGMLSuperCatalog
	mov	ebx, eax
	add	esp, 4

; 459  : 			if (super == NULL)

	test	ebx, ebx
	jne	SHORT $LN74@main

; 460  : 			    super = xmlNewCatalog(1);

	push	1
	call	_xmlNewCatalog
	add	esp, 4
	mov	ebx, eax
$LN74@main:

; 461  : 
; 462  : 			xmlACatalogAdd(super, BAD_CAST "CATALOG",

	mov	eax, DWORD PTR _argv$[ebp]
	mov	esi, DWORD PTR tv807[ebp]
	push	0
	push	DWORD PTR [esi+eax+4]
	push	OFFSET ??_C@_07DIADFEPH@CATALOG@
	push	ebx
	call	_xmlACatalogAdd
	add	esp, 16					; 00000010H

; 474  : 		    }
; 475  : 		    if ((!no_super_update) && (noout) && (catal != NULL) &&

	jmp	$LN288@main
$LN83@main:

; 497  : 			out = fopen(argv[i + 1], "w");

	push	OFFSET ??_C@_01NOFIACDB@w@
	push	ecx
	call	DWORD PTR __imp__fopen
	mov	esi, eax
	add	esp, 8

; 498  : 			if (out == NULL) {

	test	esi, esi
	jne	SHORT $LN85@main

; 499  : 			    fprintf(stderr, "could not open %s for saving\n",

	mov	eax, DWORD PTR tv807[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edi, DWORD PTR __imp____acrt_iob_func
	push	DWORD PTR [eax+ecx+4]
	push	OFFSET ??_C@_0BO@LDFMPMFC@could?5not?5open?5?$CFs?5for?5saving?6@
	push	2
	call	edi
	add	esp, 4
	push	eax
	call	_fprintf

; 500  : 				    argv[i + 1]);
; 501  : 			    exit_value = 2;
; 502  : 			    noout = 0;

	mov	DWORD PTR _noout, esi
	add	esp, 12					; 0000000cH

; 503  : 			} else {

	mov	esi, DWORD PTR __imp__remove
	mov	DWORD PTR _exit_value$1$[ebp], 2
	jmp	SHORT $LN86@main
$LN85@main:

; 504  : 			    xmlACatalogDump(catal, out);

	push	esi
	push	edi
	call	_xmlACatalogDump

; 505  : 			    fclose(out);

	push	esi
	call	DWORD PTR __imp__fclose
	mov	esi, DWORD PTR __imp__remove
	add	esp, 12					; 0000000cH
$LN309@main:

; 506  : 			}
; 507  : 		    }
; 508  : 		    if (!no_super_update && super != NULL) {

	mov	edi, DWORD PTR __imp____acrt_iob_func
$LN86@main:
	cmp	DWORD PTR _no_super_update, 0
	jne	SHORT $LN82@main
	test	ebx, ebx
	je	SHORT $LN82@main

; 509  : 			if (xmlCatalogIsEmpty(super)) {

	push	ebx
	call	_xmlCatalogIsEmpty
	add	esp, 4
	test	eax, eax
	je	SHORT $LN88@main

; 510  : 			    remove(XML_SGML_DEFAULT_CATALOG);

	push	OFFSET ??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@
	call	esi
	add	esp, 4

; 511  : 			} else {

	jmp	SHORT $LN82@main
$LN88@main:

; 512  : 			    out = fopen(XML_SGML_DEFAULT_CATALOG, "w");

	push	OFFSET ??_C@_01NOFIACDB@w@
	push	OFFSET ??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@
	call	DWORD PTR __imp__fopen
	mov	esi, eax
	add	esp, 8

; 513  : 			    if (out == NULL) {

	test	esi, esi
	jne	SHORT $LN90@main

; 514  : 				fprintf(stderr,

	push	OFFSET ??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@
	push	OFFSET ??_C@_0BO@LDFMPMFC@could?5not?5open?5?$CFs?5for?5saving?6@
	push	2
	call	edi
	add	esp, 4
	push	eax
	call	_fprintf

; 515  : 					"could not open %s for saving\n",
; 516  : 					XML_SGML_DEFAULT_CATALOG);
; 517  : 				exit_value = 2;

	mov	DWORD PTR _exit_value$1$[ebp], 2

; 518  : 				noout = 0;

	mov	DWORD PTR _noout, esi

; 519  : 			    } else {

	jmp	SHORT $LN310@main
$LN90@main:

; 520  : 
; 521  : 				xmlACatalogDump(super, out);

	push	esi
	push	ebx
	call	_xmlACatalogDump

; 522  : 				fclose(out);

	push	esi
	call	DWORD PTR __imp__fclose

; 523  : 			    }
; 524  : 			}
; 525  : 		    }
; 526  : 		} else {

	jmp	SHORT $LN310@main
$LN81@main:

; 527  : 		    xmlACatalogDump(catal, stdout);

	push	1
	call	DWORD PTR __imp____acrt_iob_func
	push	eax
	push	edi
	call	_xmlACatalogDump
$LN310@main:

; 528  : 		}
; 529  : 		i += 2;

	add	esp, 12					; 0000000cH
$LN82@main:
	mov	esi, DWORD PTR _i$3$[ebp]
	mov	ebx, DWORD PTR tv519[ebp]
	add	esi, 2
	add	DWORD PTR tv514[ebp], 8
	add	ebx, 8

; 530  : 	    } else {

	jmp	$LN311@main
$LN67@main:

; 531  : 		if ((!strcmp(argv[i], "-add")) ||

	mov	ecx, OFFSET ??_C@_04MNFJLOGO@?9add@
	mov	eax, esi
$LL270@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN271@main
	test	dl, dl
	je	SHORT $LN272@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN271@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL270@main
$LN272@main:
	xor	eax, eax
	jmp	SHORT $LN273@main
$LN271@main:
	sbb	eax, eax
	or	eax, 1
$LN273@main:
	test	eax, eax
	je	$LN94@main
	mov	ecx, OFFSET ??_C@_05BILPODI@?9?9add@
	mov	eax, esi
	npad	6
$LL274@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN275@main
	test	dl, dl
	je	SHORT $LN276@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN275@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL274@main
$LN276@main:
	xor	eax, eax
	jmp	SHORT $LN277@main
$LN275@main:
	sbb	eax, eax
	or	eax, 1
$LN277@main:
	test	eax, eax
	je	$LN94@main

; 545  : 		} else if ((!strcmp(argv[i], "-del")) ||

	mov	ecx, OFFSET ??_C@_04DDJMKOGD@?9del@
	mov	eax, esi
$LL278@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN279@main
	test	dl, dl
	je	SHORT $LN280@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN279@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL278@main
$LN280@main:
	xor	eax, eax
	jmp	SHORT $LN281@main
$LN279@main:
	sbb	eax, eax
	or	eax, 1
$LN281@main:
	test	eax, eax
	je	SHORT $LN100@main
	mov	eax, OFFSET ??_C@_05PPEOOODF@?9?9del@
$LL282@main:
	mov	cl, BYTE PTR [esi]
	cmp	cl, BYTE PTR [eax]
	jne	SHORT $LN283@main
	test	cl, cl
	je	SHORT $LN284@main
	mov	cl, BYTE PTR [esi+1]
	cmp	cl, BYTE PTR [eax+1]
	jne	SHORT $LN283@main
	add	esi, 2
	add	eax, 2
	test	cl, cl
	jne	SHORT $LL282@main
$LN284@main:
	xor	eax, eax
	jmp	SHORT $LN285@main
$LN283@main:
	sbb	eax, eax
	or	eax, 1
$LN285@main:
	test	eax, eax
	jne	$LN300@main
$LN100@main:

; 546  : 		    (!strcmp(argv[i], "--del"))) {
; 547  : 		    ret = xmlCatalogRemove(BAD_CAST argv[i + 1]);

	mov	esi, DWORD PTR _argv$[ebp]
	push	DWORD PTR [edi+esi+4]
	call	_xmlCatalogRemove
	add	esp, 4

; 548  : 		    if (ret < 0) {

	test	eax, eax
	jns	SHORT $LN101@main

; 549  : 			fprintf(stderr, "Failed to remove entry %s\n",

	push	DWORD PTR [edi+esi+4]
	push	OFFSET ??_C@_0BL@MKGCOLNC@Failed?5to?5remove?5entry?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 550  : 				argv[i + 1]);
; 551  : 			exit_value = 1;

	mov	DWORD PTR _exit_value$1$[ebp], 1
$LN101@main:

; 552  : 		    }
; 553  : 		    i += 1;

	mov	esi, DWORD PTR _i$3$[ebp]
	mov	eax, DWORD PTR tv514[ebp]
	inc	esi
	add	eax, 4
	add	ebx, 4
	jmp	SHORT $LN8@main
$LN94@main:

; 532  : 		    (!strcmp(argv[i], "--add"))) {
; 533  : 			if ((argv[i + 3] == NULL) || (argv[i + 3][0] == 0))

	mov	eax, DWORD PTR tv514[ebp]
	mov	esi, DWORD PTR _i$3$[ebp]
	add	esi, 3
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN97@main
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN97@main

; 535  : 						BAD_CAST argv[i + 2]);
; 536  : 			else
; 537  : 			    ret = xmlCatalogAdd(BAD_CAST argv[i + 1],

	mov	ecx, DWORD PTR [ebx]
	jmp	SHORT $LN96@main
$LN97@main:

; 534  : 			    ret = xmlCatalogAdd(BAD_CAST argv[i + 1], NULL,

	mov	eax, DWORD PTR [ebx]
	xor	ecx, ecx
$LN96@main:

; 538  : 						BAD_CAST argv[i + 2],
; 539  : 						BAD_CAST argv[i + 3]);
; 540  : 			if (ret != 0) {

	push	eax
	mov	eax, DWORD PTR _argv$[ebp]
	push	ecx
	mov	eax, DWORD PTR [edi+eax+4]
	push	eax
	call	_xmlCatalogAdd
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN98@main

; 541  : 			    printf("add command failed\n");

	push	OFFSET ??_C@_0BE@JELHPCAG@add?5command?5failed?6@
	call	_printf
	add	esp, 4

; 542  : 			    exit_value = 3;

	mov	DWORD PTR _exit_value$1$[ebp], 3
$LN98@main:

; 543  : 			}
; 544  : 			i += 3;

	mov	eax, DWORD PTR tv514[ebp]
	add	eax, 12					; 0000000cH
	add	ebx, 12					; 0000000cH

; 545  : 		} else if ((!strcmp(argv[i], "-del")) ||

	jmp	SHORT $LN8@main
$LN300@main:

; 431  : 	for (i = 1; i < argc ; i++) {

	mov	esi, DWORD PTR _i$3$[ebp]
$LN311@main:
	mov	eax, DWORD PTR tv514[ebp]
$LN8@main:
	inc	esi
	add	eax, 4
	add	ebx, 4
	mov	DWORD PTR _i$3$[ebp], esi
	mov	DWORD PTR tv514[ebp], eax
	mov	DWORD PTR tv519[ebp], ebx
	cmp	esi, DWORD PTR _argc$[ebp]
	jl	$LL10@main
$LN290@main:
	mov	ebx, DWORD PTR __imp____acrt_iob_func
$LN289@main:

; 585  : 		        printf("%s\n", (char *) ans);
; 586  : 			xmlFree (ans);
; 587  : 		    }
; 588  : 		} else {
; 589  : 		    printf("%s\n", (char *) ans);
; 590  : 		    xmlFree(ans);
; 591  : 		}
; 592  : 	    }
; 593  : 	}
; 594  :     }
; 595  :     if ((!sgml) && ((add) || (del) || (create) || (convert))) {

	cmp	DWORD PTR _sgml, 0
	jne	$LN115@main
	cmp	DWORD PTR _add, 0
	jne	SHORT $LN113@main
	cmp	DWORD PTR _del, 0
	jne	SHORT $LN113@main
	cmp	DWORD PTR _create, 0
	jne	SHORT $LN113@main
	cmp	DWORD PTR _convert, 0
	je	$LN115@main
$LN113@main:

; 596  : 	if (noout && filename && *filename) {

	cmp	DWORD PTR _noout, 0
	je	SHORT $LN114@main
	mov	eax, DWORD PTR _filename
	test	eax, eax
	je	SHORT $LN114@main
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN114@main

; 597  : 	    FILE *out;
; 598  : 
; 599  : 	    out = fopen(filename, "w");

	push	OFFSET ??_C@_01NOFIACDB@w@
	push	eax
	call	DWORD PTR __imp__fopen
	add	esp, 8

; 600  : 	    if (out == NULL) {

	test	eax, eax
	jne	SHORT $LN116@main

; 601  : 		fprintf(stderr, "could not open %s for saving\n", filename);

	push	DWORD PTR _filename
	push	OFFSET ??_C@_0BO@LDFMPMFC@could?5not?5open?5?$CFs?5for?5saving?6@
	push	2
	call	ebx
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 602  : 		exit_value = 2;

	mov	DWORD PTR _exit_value$1$[ebp], 2

; 603  : 		noout = 0;

	mov	DWORD PTR _noout, 0

; 609  : 	}
; 610  :     }
; 611  : 
; 612  :     /*
; 613  :      * Cleanup and check for memory leaks
; 614  :      */
; 615  :     xmlCleanupParser();

	call	_xmlCleanupParser

; 616  :     xmlMemoryDump();

	call	_xmlMemoryDump

; 617  :     return(exit_value);

	mov	eax, DWORD PTR _exit_value$1$[ebp]
	pop	esi
	pop	edi
	pop	ebx

; 618  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN116@main:

; 604  : 	    } else {
; 605  : 		xmlCatalogDump(out);

	push	eax
	call	_xmlCatalogDump
	add	esp, 4

; 609  : 	}
; 610  :     }
; 611  : 
; 612  :     /*
; 613  :      * Cleanup and check for memory leaks
; 614  :      */
; 615  :     xmlCleanupParser();

	call	_xmlCleanupParser

; 616  :     xmlMemoryDump();

	call	_xmlMemoryDump

; 617  :     return(exit_value);

	mov	eax, DWORD PTR _exit_value$1$[ebp]
	pop	esi
	pop	edi
	pop	ebx

; 618  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN114@main:

; 606  : 	    }
; 607  : 	} else {
; 608  : 	    xmlCatalogDump(stdout);

	push	1
	call	ebx
	push	eax
	call	_xmlCatalogDump
	add	esp, 8
$LN115@main:

; 609  : 	}
; 610  :     }
; 611  : 
; 612  :     /*
; 613  :      * Cleanup and check for memory leaks
; 614  :      */
; 615  :     xmlCleanupParser();

	call	_xmlCleanupParser

; 616  :     xmlMemoryDump();

	call	_xmlMemoryDump

; 617  :     return(exit_value);

	mov	eax, DWORD PTR _exit_value$1$[ebp]
	pop	esi
	pop	edi
	pop	ebx

; 618  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlcatalog.c
;	COMDAT _usage
_TEXT	SEGMENT
_name$ = 8						; size = 4
_usage	PROC						; COMDAT

; 311  : static void usage(const char *name) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6F93E186_xmlcatalog@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0BJG@IFOIFJDI@Usage?5?3?5?$CFs?5?$FLoptions?$FN?5catalogfil@
	call	_printf
	add	esp, 8

; 312  :     /* split into 2 printf's to avoid overly long string (gcc warning) */
; 313  :     printf("\
; 314  : Usage : %s [options] catalogfile entities...\n\
; 315  : \tParse the catalog file (void specification possibly expressed as \"\"\n\
; 316  : \tappoints the default system one) and query it for the entities\n\
; 317  : \t--sgml : handle SGML Super catalogs for --add and --del\n\
; 318  : \t--shell : run a shell allowing interactive queries\n\
; 319  : \t--create : create a new catalog\n\
; 320  : \t--add 'type' 'orig' 'replace' : add an XML entry\n\
; 321  : \t--add 'entry' : add an SGML entry\n", name);
; 322  :     printf("\

	mov	DWORD PTR _name$[ebp], OFFSET ??_C@_0BDI@HBPONJIE@?7?9?9del?5?8values?8?5?3?5remove?5values@

; 323  : \t--del 'values' : remove values\n\
; 324  : \t--noout: avoid dumping the result on stdout\n\
; 325  : \t         used with --add or --del, it saves the catalog changes\n\
; 326  : \t         and with --sgml it automatically updates the super catalog\n\
; 327  : \t--no-super-update: do not update the SGML super catalog\n\
; 328  : \t-v --verbose : provide debug informations\n");
; 329  : }

	pop	ebp

; 312  :     /* split into 2 printf's to avoid overly long string (gcc warning) */
; 313  :     printf("\
; 314  : Usage : %s [options] catalogfile entities...\n\
; 315  : \tParse the catalog file (void specification possibly expressed as \"\"\n\
; 316  : \tappoints the default system one) and query it for the entities\n\
; 317  : \t--sgml : handle SGML Super catalogs for --add and --del\n\
; 318  : \t--shell : run a shell allowing interactive queries\n\
; 319  : \t--create : create a new catalog\n\
; 320  : \t--add 'type' 'orig' 'replace' : add an XML entry\n\
; 321  : \t--add 'entry' : add an SGML entry\n", name);
; 322  :     printf("\

	jmp	_printf
_usage	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlcatalog.c
;	COMDAT _usershell
_TEXT	SEGMENT
_line_read$1 = -1084					; size = 501
_arg$ = -580						; size = 400
_command$ = -180					; size = 100
_argv$ = -80						; size = 80
_usershell PROC						; COMDAT

; 96   : static void usershell(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 1084				; 0000043cH
	mov	ecx, OFFSET __6F93E186_xmlcatalog@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR __imp__free
$LN204@usershell:

; 82   : 	fprintf(stdout, "%s", prompt);

	mov	ebx, DWORD PTR __imp____acrt_iob_func
	push	OFFSET ??_C@_02LLMPMKNF@?$DO?5@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	1
	call	ebx
	add	esp, 4
	push	eax
	call	_fprintf

; 83   :     fflush(stdout);

	push	1
	call	ebx
	push	eax
	call	DWORD PTR __imp__fflush

; 84   :     if (!fgets(line_read, 500, stdin))

	push	0
	call	ebx
	push	eax
	lea	eax, DWORD PTR _line_read$1[ebp]
	push	500					; 000001f4H
	push	eax
	call	DWORD PTR __imp__fgets
	add	esp, 36					; 00000024H
	test	eax, eax
	je	$LN3@usershell

; 85   :         return(NULL);
; 86   :     line_read[500] = 0;
; 87   :     len = strlen(line_read);

	lea	ecx, DWORD PTR _line_read$1[ebp]
	mov	BYTE PTR _line_read$1[ebp+500], 0
	lea	edx, DWORD PTR [ecx+1]
$LL147@usershell:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL147@usershell
	sub	ecx, edx

; 88   :     ret = (char *) malloc(len + 1);

	lea	esi, DWORD PTR [ecx+1]
	push	esi
	call	DWORD PTR __imp__malloc
	mov	ebx, eax
	add	esp, 4

; 89   :     if (ret != NULL) {

	test	ebx, ebx
	je	$LN3@usershell

; 90   : 	memcpy (ret, line_read, len + 1);

	push	esi
	lea	eax, DWORD PTR _line_read$1[ebp]
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 97   :     char *cmdline = NULL, *cur;
; 98   :     int nbargs;
; 99   :     char command[100];
; 100  :     char arg[400];
; 101  :     char *argv[20];
; 102  :     int i, ret;
; 103  :     xmlChar *ans;
; 104  : 
; 105  :     while (1) {
; 106  : 	cmdline = xmlShellReadline("> ");
; 107  : 	if (cmdline == NULL)
; 108  : 	    return;
; 109  : 
; 110  : 	/*
; 111  : 	 * Parse the command itself
; 112  : 	 */
; 113  : 	cur = cmdline;

	mov	esi, ebx
	npad	7
$LL4@usershell:

; 114  : 	nbargs = 0;
; 115  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN127@usershell
	cmp	al, 9
	jne	SHORT $LN5@usershell
$LN127@usershell:
	inc	esi
	jmp	SHORT $LL4@usershell
$LN5@usershell:

; 116  : 	i = 0;

	lea	edx, DWORD PTR _command$[ebp]
	xor	ecx, ecx
	sub	edx, esi
$LL6@usershell:

; 117  : 	while ((*cur != ' ') && (*cur != '\t') &&
; 118  : 	       (*cur != '\n') && (*cur != '\r')) {

	cmp	al, 9
	je	SHORT $LN108@usershell
	cmp	al, 10					; 0000000aH
	je	SHORT $LN108@usershell
	cmp	al, 13					; 0000000dH
	je	SHORT $LN108@usershell

; 119  : 	    if (*cur == 0)

	test	al, al
	je	SHORT $LN108@usershell

; 120  : 		break;
; 121  : 	    command[i++] = *cur++;

	mov	BYTE PTR [edx+esi], al
	inc	ecx
	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 32					; 00000020H
	jne	SHORT $LL6@usershell
$LN108@usershell:

; 122  : 	}
; 123  : 	command[i] = 0;

	mov	BYTE PTR _command$[ebp+ecx], 0

; 124  : 	if (i == 0) {

	test	ecx, ecx
	jne	SHORT $LN25@usershell

; 125  : 	    free(cmdline);

	push	ebx
	call	edi
	add	esp, 4

; 126  : 	    continue;

	jmp	$LN204@usershell
$LN25@usershell:

; 127  : 	}
; 128  : 
; 129  : 	/*
; 130  : 	 * Parse the argument string
; 131  : 	 */
; 132  : 	memset(arg, 0, sizeof(arg));

	push	400					; 00000190H
	lea	eax, DWORD PTR _arg$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LL8@usershell:

; 133  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN128@usershell
	cmp	al, 9
	jne	SHORT $LN9@usershell
$LN128@usershell:
	inc	esi
	jmp	SHORT $LL8@usershell
$LN9@usershell:

; 134  : 	i = 0;

	xor	ecx, ecx

; 135  : 	while ((*cur != '\n') && (*cur != '\r') && (*cur != 0)) {

	cmp	al, 10					; 0000000aH
	je	SHORT $LN202@usershell

; 133  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	lea	edx, DWORD PTR _arg$[ebp]
	sub	edx, esi
	npad	5
$LL10@usershell:

; 135  : 	while ((*cur != '\n') && (*cur != '\r') && (*cur != 0)) {

	cmp	al, 13					; 0000000dH
	je	SHORT $LN202@usershell
	test	al, al
	je	SHORT $LN202@usershell

; 136  : 	    if (*cur == 0)
; 137  : 		break;
; 138  : 	    arg[i++] = *cur++;

	mov	BYTE PTR [edx+esi], al
	inc	ecx
	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 10					; 0000000aH
	jne	SHORT $LL10@usershell
$LN202@usershell:

; 141  : 
; 142  : 	/*
; 143  : 	 * Parse the arguments
; 144  : 	 */
; 145  : 	i = 0;
; 146  : 	nbargs = 0;
; 147  : 	cur = arg;
; 148  : 	memset(argv, 0, sizeof(argv));

	push	80					; 00000050H
	xor	edi, edi
	mov	BYTE PTR _arg$[ebp+ecx], 0
	lea	eax, DWORD PTR _argv$[ebp]
	push	edi
	push	eax
	lea	esi, DWORD PTR _arg$[ebp]
	call	_memset
	add	esp, 12					; 0000000cH

; 149  : 	while (*cur != 0) {

	cmp	BYTE PTR _arg$[ebp], 0
	je	SHORT $LN146@usershell

; 139  : 	}
; 140  : 	arg[i] = 0;

	lea	ecx, DWORD PTR _argv$[ebp]
	npad	1
$LL14@usershell:

; 150  : 	    while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN129@usershell
	cmp	al, 9
	jne	SHORT $LN15@usershell
$LN129@usershell:
	inc	esi
	jmp	SHORT $LL14@usershell
$LN15@usershell:

; 151  : 	    if (*cur == '\'') {

	cmp	al, 39					; 00000027H
	jne	SHORT $LN29@usershell

; 152  : 		cur++;
; 153  : 		argv[i] = cur;
; 154  : 		while ((*cur != 0) && (*cur != '\'')) cur++;

	mov	al, BYTE PTR [esi+1]
	inc	esi
	mov	DWORD PTR [ecx], esi
	test	al, al
	je	SHORT $LN17@usershell
	npad	5
$LL16@usershell:
	cmp	al, 39					; 00000027H
	je	SHORT $LN203@usershell
	mov	al, BYTE PTR [esi+1]
	inc	esi
	test	al, al
	jne	SHORT $LL16@usershell
$LN17@usershell:

; 155  : 		if (*cur == '\'') {

	cmp	al, 39					; 00000027H
	jne	SHORT $LN33@usershell

; 156  : 		    *cur = 0;
; 157  : 		    nbargs++;
; 158  : 		    i++;
; 159  : 		    cur++;
; 160  : 		}

	jmp	SHORT $LN203@usershell
$LN29@usershell:

; 161  : 	    } else if (*cur == '"') {

	cmp	al, 34					; 00000022H
	jne	SHORT $LN32@usershell

; 162  : 		cur++;
; 163  : 		argv[i] = cur;
; 164  : 		while ((*cur != 0) && (*cur != '"')) cur++;

	mov	al, BYTE PTR [esi+1]
	inc	esi
	mov	DWORD PTR [ecx], esi
	test	al, al
	je	SHORT $LN19@usershell
$LL18@usershell:
	cmp	al, 34					; 00000022H
	je	SHORT $LN203@usershell
	mov	al, BYTE PTR [esi+1]
	inc	esi
	test	al, al
	jne	SHORT $LL18@usershell
$LN19@usershell:

; 165  : 		if (*cur == '"') {

	cmp	al, 34					; 00000022H
	jne	SHORT $LN33@usershell

; 166  : 		    *cur = 0;
; 167  : 		    nbargs++;
; 168  : 		    i++;
; 169  : 		    cur++;
; 170  : 		}
; 171  : 	    } else {

	jmp	SHORT $LN203@usershell
$LN32@usershell:

; 172  : 		argv[i] = cur;

	mov	DWORD PTR [ecx], esi

; 173  : 		while ((*cur != 0) && (*cur != ' ') && (*cur != '\t'))

	test	al, al
	je	SHORT $LN203@usershell
$LL20@usershell:
	cmp	al, 32					; 00000020H
	je	SHORT $LN203@usershell
	cmp	al, 9
	je	SHORT $LN203@usershell
	mov	al, BYTE PTR [esi+1]

; 174  : 		    cur++;

	inc	esi
	test	al, al
	jne	SHORT $LL20@usershell
$LN203@usershell:

; 149  : 	while (*cur != 0) {

	inc	edi
	mov	BYTE PTR [esi], 0
	add	ecx, 4
	inc	esi
$LN33@usershell:
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LL14@usershell
$LN146@usershell:

; 175  : 		*cur = 0;
; 176  : 		nbargs++;
; 177  : 		i++;
; 178  : 		cur++;
; 179  : 	    }
; 180  : 	}
; 181  : 
; 182  : 	/*
; 183  : 	 * start interpreting the command
; 184  : 	 */
; 185  : 	if (!strcmp(command, "exit") ||
; 186  : 	    !strcmp(command, "quit") ||

	mov	ecx, OFFSET ??_C@_04MKNBDEPB@exit@
	lea	eax, DWORD PTR _command$[ebp]
$LL148@usershell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN149@usershell
	test	dl, dl
	je	SHORT $LN150@usershell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN149@usershell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL148@usershell
$LN150@usershell:
	xor	eax, eax
	jmp	SHORT $LN151@usershell
$LN149@usershell:
	sbb	eax, eax
	or	eax, 1
$LN151@usershell:
	test	eax, eax
	je	$LN111@usershell
	mov	ecx, OFFSET ??_C@_04KNNLNNGO@quit@
	lea	eax, DWORD PTR _command$[ebp]
$LL152@usershell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN153@usershell
	test	dl, dl
	je	SHORT $LN154@usershell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN153@usershell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL152@usershell
$LN154@usershell:
	xor	eax, eax
	jmp	SHORT $LN155@usershell
$LN153@usershell:
	sbb	eax, eax
	or	eax, 1
$LN155@usershell:
	test	eax, eax
	je	$LN111@usershell
	mov	ecx, OFFSET ??_C@_03MDONDFG@bye@
	lea	eax, DWORD PTR _command$[ebp]
$LL156@usershell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN157@usershell
	test	dl, dl
	je	SHORT $LN158@usershell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN157@usershell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL156@usershell
$LN158@usershell:
	xor	eax, eax
	jmp	SHORT $LN159@usershell
$LN157@usershell:
	sbb	eax, eax
	or	eax, 1
$LN159@usershell:
	test	eax, eax
	je	$LN111@usershell

; 189  : 	    break;
; 190  : 	}
; 191  : 
; 192  : 	if (!strcmp(command, "public")) {

	mov	ecx, OFFSET ??_C@_06EOMAMIIF@public@
	lea	eax, DWORD PTR _command$[ebp]
$LL160@usershell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN161@usershell
	test	dl, dl
	je	SHORT $LN162@usershell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN161@usershell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL160@usershell
$LN162@usershell:
	xor	eax, eax
	jmp	SHORT $LN163@usershell
$LN161@usershell:
	sbb	eax, eax
	or	eax, 1
$LN163@usershell:
	test	eax, eax
	jne	SHORT $LN37@usershell

; 193  : 	    if (nbargs != 1) {

	cmp	edi, 1
	je	SHORT $LN39@usershell

; 194  : 		printf("public requires 1 arguments\n");

	push	OFFSET ??_C@_0BN@DCAIANKH@public?5requires?51?5arguments?6@
	call	_printf

; 301  : 	}
; 302  : 	free(cmdline); /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free
	add	esp, 4
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN39@usershell:

; 195  : 	    } else {
; 196  : 		ans = xmlCatalogResolvePublic((const xmlChar *) argv[0]);

	mov	edi, DWORD PTR _argv$[ebp]
	push	edi
	call	_xmlCatalogResolvePublic
	mov	esi, eax
	add	esp, 4

; 197  : 		if (ans == NULL) {

	test	esi, esi
	jne	$LN72@usershell

; 198  : 		    printf("No entry for PUBLIC %s\n", argv[0]);

	push	edi
	push	OFFSET ??_C@_0BI@FFIBJMM@No?5entry?5for?5PUBLIC?5?$CFs?6@
	call	_printf

; 301  : 	}
; 302  : 	free(cmdline); /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free
	add	esp, 8
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN37@usershell:

; 199  : 		} else {
; 200  : 		    printf("%s\n", (char *) ans);
; 201  : 		    xmlFree(ans);
; 202  : 		}
; 203  : 	    }
; 204  : 	} else if (!strcmp(command, "system")) {

	mov	ecx, OFFSET ??_C@_06FHFOAHML@system@
	lea	eax, DWORD PTR _command$[ebp]
$LL164@usershell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN165@usershell
	test	dl, dl
	je	SHORT $LN166@usershell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN165@usershell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL164@usershell
$LN166@usershell:
	xor	eax, eax
	jmp	SHORT $LN167@usershell
$LN165@usershell:
	sbb	eax, eax
	or	eax, 1
$LN167@usershell:
	test	eax, eax
	jne	SHORT $LN43@usershell

; 205  : 	    if (nbargs != 1) {

	cmp	edi, 1
	je	SHORT $LN45@usershell

; 206  : 		printf("system requires 1 arguments\n");

	push	OFFSET ??_C@_0BN@OGHNALCF@system?5requires?51?5arguments?6@
	call	_printf

; 301  : 	}
; 302  : 	free(cmdline); /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free
	add	esp, 4
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN45@usershell:

; 207  : 	    } else {
; 208  : 		ans = xmlCatalogResolveSystem((const xmlChar *) argv[0]);

	mov	edi, DWORD PTR _argv$[ebp]
	push	edi
	call	_xmlCatalogResolveSystem
	mov	esi, eax
	add	esp, 4

; 209  : 		if (ans == NULL) {

	test	esi, esi
	jne	$LN72@usershell

; 210  : 		    printf("No entry for SYSTEM %s\n", argv[0]);

	push	edi
	push	OFFSET ??_C@_0BI@GPMJOIOL@No?5entry?5for?5SYSTEM?5?$CFs?6@
	call	_printf

; 301  : 	}
; 302  : 	free(cmdline); /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free
	add	esp, 8
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN43@usershell:

; 211  : 		} else {
; 212  : 		    printf("%s\n", (char *) ans);
; 213  : 		    xmlFree(ans);
; 214  : 		}
; 215  : 	    }
; 216  : 	} else if (!strcmp(command, "add")) {

	mov	ecx, OFFSET ??_C@_03BDGOHNNK@add@
	lea	eax, DWORD PTR _command$[ebp]
$LL168@usershell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN169@usershell
	test	dl, dl
	je	SHORT $LN170@usershell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN169@usershell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL168@usershell
$LN170@usershell:
	xor	eax, eax
	jmp	SHORT $LN171@usershell
$LN169@usershell:
	sbb	eax, eax
	or	eax, 1
$LN171@usershell:
	test	eax, eax
	jne	SHORT $LN49@usershell

; 301  : 	}
; 302  : 	free(cmdline); /* not xmlFree here ! */

	cmp	edi, 3
	je	SHORT $LN58@usershell
	cmp	edi, 2
	je	SHORT $LN58@usershell
	push	OFFSET ??_C@_0BP@EHJKBIMI@add?5requires?52?5or?53?5arguments?6@
	call	_printf
	mov	edi, DWORD PTR __imp__free
	add	esp, 4
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN58@usershell:
	mov	eax, DWORD PTR _argv$[ebp+8]
	test	eax, eax
	jne	SHORT $LN60@usershell
	push	DWORD PTR _argv$[ebp+4]
	push	eax
	jmp	SHORT $LN206@usershell
$LN60@usershell:
	push	eax
	push	DWORD PTR _argv$[ebp+4]
$LN206@usershell:
	push	DWORD PTR _argv$[ebp]
	call	_xmlCatalogAdd
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN83@usershell
	push	OFFSET ??_C@_0BE@JELHPCAG@add?5command?5failed?6@
	call	_printf
	mov	edi, DWORD PTR __imp__free
	add	esp, 4
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN49@usershell:

; 217  : 	    if (sgml) {
; 218  : 		if ((nbargs != 3) && (nbargs != 2)) {
; 219  : 		    printf("add requires 2 or 3 arguments\n");
; 220  : 		} else {
; 221  : 		    if (argv[2] == NULL)
; 222  : 			ret = xmlCatalogAdd(BAD_CAST argv[0], NULL,
; 223  : 					    BAD_CAST argv[1]);
; 224  : 		    else
; 225  : 			ret = xmlCatalogAdd(BAD_CAST argv[0], BAD_CAST argv[1],
; 226  : 					    BAD_CAST argv[2]);
; 227  : 		    if (ret != 0)
; 228  : 			printf("add command failed\n");
; 229  : 		}
; 230  : 	    } else {
; 231  : 		if ((nbargs != 3) && (nbargs != 2)) {
; 232  : 		    printf("add requires 2 or 3 arguments\n");
; 233  : 		} else {
; 234  : 		    if (argv[2] == NULL)
; 235  : 			ret = xmlCatalogAdd(BAD_CAST argv[0], NULL,
; 236  : 					    BAD_CAST argv[1]);
; 237  : 		    else
; 238  : 			ret = xmlCatalogAdd(BAD_CAST argv[0], BAD_CAST argv[1],
; 239  : 					    BAD_CAST argv[2]);
; 240  : 		    if (ret != 0)
; 241  : 			printf("add command failed\n");
; 242  : 		}
; 243  : 	    }
; 244  : 	} else if (!strcmp(command, "del")) {

	mov	ecx, OFFSET ??_C@_03ONKLGNNH@del@
	lea	eax, DWORD PTR _command$[ebp]
	npad	2
$LL172@usershell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN173@usershell
	test	dl, dl
	je	SHORT $LN174@usershell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN173@usershell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL172@usershell
$LN174@usershell:
	xor	eax, eax
	jmp	SHORT $LN175@usershell
$LN173@usershell:
	sbb	eax, eax
	or	eax, 1
$LN175@usershell:
	test	eax, eax
	jne	SHORT $LN63@usershell

; 245  : 	    if (nbargs != 1) {

	cmp	edi, 1
	je	SHORT $LN65@usershell

; 246  : 		printf("del requires 1\n");

	push	OFFSET ??_C@_0BA@PNPKCAGJ@del?5requires?51?6@
	call	_printf

; 301  : 	}
; 302  : 	free(cmdline); /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free
	add	esp, 4
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN65@usershell:

; 247  : 	    } else {
; 248  : 		ret = xmlCatalogRemove(BAD_CAST argv[0]);

	push	DWORD PTR _argv$[ebp]
	call	_xmlCatalogRemove
	add	esp, 4

; 249  : 		if (ret <= 0)

	test	eax, eax
	jg	$LN83@usershell

; 250  : 		    printf("del command failed\n");

	push	OFFSET ??_C@_0BE@HPIOAMEN@del?5command?5failed?6@
	call	_printf

; 301  : 	}
; 302  : 	free(cmdline); /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free
	add	esp, 4
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN63@usershell:

; 251  : 
; 252  : 	    }
; 253  : 	} else if (!strcmp(command, "resolve")) {

	mov	ecx, OFFSET ??_C@_07CPEIJHB@resolve@
	lea	eax, DWORD PTR _command$[ebp]
$LL176@usershell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN177@usershell
	test	dl, dl
	je	SHORT $LN178@usershell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN177@usershell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL176@usershell
$LN178@usershell:
	xor	eax, eax
	jmp	SHORT $LN179@usershell
$LN177@usershell:
	sbb	eax, eax
	or	eax, 1
$LN179@usershell:
	test	eax, eax
	jne	SHORT $LN68@usershell

; 254  : 	    if (nbargs != 2) {

	cmp	edi, 2
	je	SHORT $LN70@usershell

; 255  : 		printf("resolve requires 2 arguments\n");

	push	OFFSET ??_C@_0BO@FIFGKLE@resolve?5requires?52?5arguments?6@
	call	_printf

; 301  : 	}
; 302  : 	free(cmdline); /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free
	add	esp, 4
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN70@usershell:

; 256  : 	    } else {
; 257  : 		ans = xmlCatalogResolve(BAD_CAST argv[0],

	push	DWORD PTR _argv$[ebp+4]
	push	DWORD PTR _argv$[ebp]
	call	_xmlCatalogResolve
	mov	esi, eax
	add	esp, 8

; 258  : 			                BAD_CAST argv[1]);
; 259  : 		if (ans == NULL) {

	test	esi, esi
	jne	SHORT $LN72@usershell

; 260  : 		    printf("Resolver failed to find an answer\n");

	push	OFFSET ??_C@_0CD@FLKMEIPD@Resolver?5failed?5to?5find?5an?5answ@
	call	_printf

; 301  : 	}
; 302  : 	free(cmdline); /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free
	add	esp, 4
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN72@usershell:
	push	esi
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	call	_printf
	mov	eax, DWORD PTR __imp__xmlFree
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	mov	edi, DWORD PTR __imp__free
	add	esp, 12					; 0000000cH
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN68@usershell:

; 261  : 		} else {
; 262  : 		    printf("%s\n", (char *) ans);
; 263  : 		    xmlFree(ans);
; 264  : 		}
; 265  : 	    }
; 266  : 	} else if (!strcmp(command, "dump")) {

	mov	ecx, OFFSET ??_C@_04GGLOKIEE@dump@
	lea	eax, DWORD PTR _command$[ebp]
	npad	6
$LL180@usershell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN181@usershell
	test	dl, dl
	je	SHORT $LN182@usershell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN181@usershell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL180@usershell
$LN182@usershell:
	xor	eax, eax
	jmp	SHORT $LN183@usershell
$LN181@usershell:
	sbb	eax, eax
	or	eax, 1
$LN183@usershell:
	test	eax, eax
	jne	SHORT $LN74@usershell

; 267  : 	    if (nbargs != 0) {

	test	edi, edi
	je	SHORT $LN76@usershell

; 268  : 		printf("dump has no arguments\n");

	push	OFFSET ??_C@_0BH@GHHAHJGB@dump?5has?5no?5arguments?6@
	call	_printf

; 301  : 	}
; 302  : 	free(cmdline); /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free
	add	esp, 4
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN76@usershell:

; 269  : 	    } else {
; 270  : 		xmlCatalogDump(stdout);

	push	1
	call	DWORD PTR __imp____acrt_iob_func
	push	eax
	call	_xmlCatalogDump

; 301  : 	}
; 302  : 	free(cmdline); /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free
	add	esp, 8
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN74@usershell:

; 271  : 	    }
; 272  : 	} else if (!strcmp(command, "debug")) {

	mov	ecx, OFFSET ??_C@_05GFCDIDHO@debug@
	lea	eax, DWORD PTR _command$[ebp]
$LL184@usershell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN185@usershell
	test	dl, dl
	je	SHORT $LN186@usershell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN185@usershell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL184@usershell
$LN186@usershell:
	xor	eax, eax
	jmp	SHORT $LN187@usershell
$LN185@usershell:
	sbb	eax, eax
	or	eax, 1
$LN187@usershell:
	test	eax, eax
	jne	SHORT $LN78@usershell

; 273  : 	    if (nbargs != 0) {

	test	edi, edi
	je	SHORT $LN80@usershell

; 274  : 		printf("debug has no arguments\n");

	push	OFFSET ??_C@_0BI@DPNEIFGM@debug?5has?5no?5arguments?6@
	call	_printf

; 301  : 	}
; 302  : 	free(cmdline); /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free
	add	esp, 4
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN80@usershell:

; 275  : 	    } else {
; 276  : 		verbose++;

	mov	eax, DWORD PTR _verbose
	inc	eax

; 277  : 		xmlCatalogSetDebug(verbose);

	push	eax
	mov	DWORD PTR _verbose, eax
	call	_xmlCatalogSetDebug

; 301  : 	}
; 302  : 	free(cmdline); /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free
	add	esp, 4
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN78@usershell:

; 278  : 	    }
; 279  : 	} else if (!strcmp(command, "quiet")) {

	mov	ecx, OFFSET ??_C@_05PMBAOCDH@quiet@
	lea	eax, DWORD PTR _command$[ebp]
$LL188@usershell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN189@usershell
	test	dl, dl
	je	SHORT $LN190@usershell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN189@usershell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL188@usershell
$LN190@usershell:
	xor	eax, eax
	jmp	SHORT $LN191@usershell
$LN189@usershell:
	sbb	eax, eax
	or	eax, 1
$LN191@usershell:
	test	eax, eax
	jne	SHORT $LN82@usershell

; 280  : 	    if (nbargs != 0) {

	test	edi, edi
	je	SHORT $LN84@usershell

; 281  : 		printf("quiet has no arguments\n");

	push	OFFSET ??_C@_0BI@CNFOPICG@quiet?5has?5no?5arguments?6@
	call	_printf

; 301  : 	}
; 302  : 	free(cmdline); /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free
	add	esp, 4
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN84@usershell:

; 282  : 	    } else {
; 283  : 		if (verbose > 0)

	mov	eax, DWORD PTR _verbose
	test	eax, eax
	jle	SHORT $LN86@usershell

; 284  : 		    verbose--;

	dec	eax
	mov	DWORD PTR _verbose, eax
$LN86@usershell:

; 285  : 		xmlCatalogSetDebug(verbose);

	push	eax
	call	_xmlCatalogSetDebug

; 301  : 	}
; 302  : 	free(cmdline); /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free
	add	esp, 4
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN82@usershell:

; 286  : 	    }
; 287  : 	} else {
; 288  : 	    if (strcmp(command, "help")) {

	mov	ecx, OFFSET ??_C@_04PCJFHION@help@
	lea	eax, DWORD PTR _command$[ebp]
$LL192@usershell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN193@usershell
	test	dl, dl
	je	SHORT $LN194@usershell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN193@usershell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL192@usershell
$LN194@usershell:
	xor	eax, eax
	jmp	SHORT $LN195@usershell
$LN193@usershell:
	sbb	eax, eax
	or	eax, 1
$LN195@usershell:
	test	eax, eax
	je	SHORT $LN87@usershell

; 289  : 		printf("Unrecognized command %s\n", command);

	lea	eax, DWORD PTR _command$[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@LCFAJBIE@Unrecognized?5command?5?$CFs?6@
	call	_printf
	add	esp, 8
$LN87@usershell:

; 290  : 	    }
; 291  : 	    printf("Commands available:\n");

	push	OFFSET ??_C@_0BF@CNPPMLEL@Commands?5available?3?6@
	call	_printf

; 292  : 	    printf("\tpublic PublicID: make a PUBLIC identifier lookup\n");

	push	OFFSET ??_C@_0DD@BNENJECC@?7public?5PublicID?3?5make?5a?5PUBLIC@
	call	_printf

; 293  : 	    printf("\tsystem SystemID: make a SYSTEM identifier lookup\n");

	push	OFFSET ??_C@_0DD@BFGOGPGB@?7system?5SystemID?3?5make?5a?5SYSTEM@
	call	_printf

; 294  : 	    printf("\tresolve PublicID SystemID: do a full resolver lookup\n");

	push	OFFSET ??_C@_0DH@FFOBCHBO@?7resolve?5PublicID?5SystemID?3?5do?5@
	call	_printf

; 295  : 	    printf("\tadd 'type' 'orig' 'replace' : add an entry\n");

	push	OFFSET ??_C@_0CN@PJBHDJPC@?7add?5?8type?8?5?8orig?8?5?8replace?8?5?3?5@
	call	_printf

; 296  : 	    printf("\tdel 'values' : remove values\n");

	push	OFFSET ??_C@_0BP@BCHNOEJB@?7del?5?8values?8?5?3?5remove?5values?6@
	call	_printf

; 297  : 	    printf("\tdump: print the current catalog state\n");

	push	OFFSET ??_C@_0CI@ECEJDHEJ@?7dump?3?5print?5the?5current?5catalo@
	call	_printf

; 298  : 	    printf("\tdebug: increase the verbosity level\n");

	push	OFFSET ??_C@_0CG@OIIIIIDP@?7debug?3?5increase?5the?5verbosity?5@
	call	_printf

; 299  : 	    printf("\tquiet: decrease the verbosity level\n");

	push	OFFSET ??_C@_0CG@JNOLBMIB@?7quiet?3?5decrease?5the?5verbosity?5@
	call	_printf

; 300  : 	    printf("\texit:  quit the shell\n");

	push	OFFSET ??_C@_0BI@GHCHHEEB@?7exit?3?5?5quit?5the?5shell?6@
	call	_printf
	add	esp, 40					; 00000028H
$LN83@usershell:

; 301  : 	}
; 302  : 	free(cmdline); /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free
	push	ebx
	call	edi
	add	esp, 4
	jmp	$LN204@usershell
$LN111@usershell:

; 187  : 	    !strcmp(command, "bye")) {
; 188  : 	    free(cmdline);

	push	ebx
	call	DWORD PTR __imp__free
	add	esp, 4
$LN3@usershell:

; 303  :     }
; 304  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_usershell ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlcatalog.c
;	COMDAT _xmlShellReadline
_TEXT	SEGMENT
_line_read$ = -504					; size = 501
_prompt$ = 8						; size = 4
_xmlShellReadline PROC					; COMDAT

; 64   : xmlShellReadline(const char *prompt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 504				; 000001f8H
	mov	ecx, OFFSET __6F93E186_xmlcatalog@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _prompt$[ebp]
	mov	esi, DWORD PTR __imp____acrt_iob_func
	test	eax, eax
	je	SHORT $LN2@xmlShellRe

; 65   : #ifdef HAVE_LIBREADLINE
; 66   :     char *line_read;
; 67   : 
; 68   :     /* Get a line from the user. */
; 69   :     line_read = readline (prompt);
; 70   : 
; 71   :     /* If the line has any text in it, save it on the history. */
; 72   :     if (line_read && *line_read)
; 73   : 	add_history (line_read);
; 74   : 
; 75   :     return (line_read);
; 76   : #else
; 77   :     char line_read[501];
; 78   :     char *ret;
; 79   :     int len;
; 80   : 
; 81   :     if (prompt != NULL)
; 82   : 	fprintf(stdout, "%s", prompt);

	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	1
	call	esi
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN2@xmlShellRe:

; 83   :     fflush(stdout);

	push	1
	call	esi
	push	eax
	call	DWORD PTR __imp__fflush

; 84   :     if (!fgets(line_read, 500, stdin))

	push	0
	call	esi
	push	eax
	lea	eax, DWORD PTR _line_read$[ebp]
	push	500					; 000001f4H
	push	eax
	call	DWORD PTR __imp__fgets
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN3@xmlShellRe
	pop	esi

; 93   : #endif
; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlShellRe:

; 85   :         return(NULL);
; 86   :     line_read[500] = 0;
; 87   :     len = strlen(line_read);

	lea	ecx, DWORD PTR _line_read$[ebp]
	mov	BYTE PTR _line_read$[ebp+500], 0
	lea	edx, DWORD PTR [ecx+1]
$LL6@xmlShellRe:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL6@xmlShellRe
	sub	ecx, edx
	push	edi

; 88   :     ret = (char *) malloc(len + 1);

	lea	edi, DWORD PTR [ecx+1]
	push	edi
	call	DWORD PTR __imp__malloc
	mov	esi, eax
	add	esp, 4

; 89   :     if (ret != NULL) {

	test	esi, esi
	je	SHORT $LN4@xmlShellRe

; 90   : 	memcpy (ret, line_read, len + 1);

	push	edi
	lea	eax, DWORD PTR _line_read$[ebp]
	push	eax
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN4@xmlShellRe:

; 91   :     }
; 92   :     return(ret);

	pop	edi
	mov	eax, esi
	pop	esi

; 93   : #endif
; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlShellReadline ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR __Format$[ebp]
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	mov	esi, eax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	edi
	push	esi
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 28					; 0000001cH

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);
; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);
; 959  :         __crt_va_end(_ArgList);
; 960  :         return _Result;

	pop	edi
	pop	esi

; 961  :     }

	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);
; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;

	pop	esi

; 842  :     }

	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
; 644  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
