; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\hash.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__C0802A2B_corecrt_wtime@h DB 01H
__04AA828A_time@h DB 01H
__776982E1_hash@c DB 01H
msvcjmc	ENDS
PUBLIC	_xmlHashCreate
PUBLIC	_xmlHashCreateDict
PUBLIC	_xmlHashFree
PUBLIC	_xmlHashDefaultDeallocator
PUBLIC	_xmlHashAddEntry
PUBLIC	_xmlHashUpdateEntry
PUBLIC	_xmlHashAddEntry2
PUBLIC	_xmlHashUpdateEntry2
PUBLIC	_xmlHashAddEntry3
PUBLIC	_xmlHashUpdateEntry3
PUBLIC	_xmlHashRemoveEntry
PUBLIC	_xmlHashRemoveEntry2
PUBLIC	_xmlHashRemoveEntry3
PUBLIC	_xmlHashLookup
PUBLIC	_xmlHashLookup2
PUBLIC	_xmlHashLookup3
PUBLIC	_xmlHashQLookup
PUBLIC	_xmlHashQLookup2
PUBLIC	_xmlHashQLookup3
PUBLIC	_xmlHashCopy
PUBLIC	_xmlHashSize
PUBLIC	_xmlHashScan
PUBLIC	_xmlHashScan3
PUBLIC	_xmlHashScanFull
PUBLIC	_xmlHashScanFull3
PUBLIC	__JustMyCode_Default
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrQEqual:PROC
EXTRN	_xmlDictReference:PROC
EXTRN	_xmlDictFree:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlDictOwns:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memset:PROC
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _stubHashScannerFull
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_name2$ = 20						; size = 4
_name3$ = 24						; size = 4
_stubHashScannerFull PROC				; COMDAT

; 843  : 		     const xmlChar *name3 ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _data$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR _payload$[ebp]
	call	eax
	add	esp, 12					; 0000000cH

; 844  :     stubData *stubdata = (stubData *) data;
; 845  :     stubdata->hashscanner (payload, stubdata->data, (xmlChar *) name);
; 846  : }

	pop	ebp
	ret	0
_stubHashScannerFull ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashGrow
_TEXT	SEGMENT
tv528 = -8						; size = 4
tv518 = -8						; size = 4
_oldsize$1$ = -4					; size = 4
_oldtable$1$ = 8					; size = 4
_table$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlHashGrow PROC					; COMDAT

; 229  : xmlHashGrow(xmlHashTablePtr table, int size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __776982E1_hash@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _table$[ebp]
	test	edi, edi
	je	SHORT $LN31@xmlHashGro

; 230  :     unsigned long key;
; 231  :     int oldsize, i;
; 232  :     xmlHashEntryPtr iter, next;
; 233  :     struct _xmlHashEntry *oldtable;
; 234  : #ifdef DEBUG_GROW
; 235  :     unsigned long nbElem = 0;
; 236  : #endif
; 237  : 
; 238  :     if (table == NULL)
; 239  : 	return(-1);
; 240  :     if (size < 8)

	mov	esi, DWORD PTR _size$[ebp]
	cmp	esi, 8
	jl	SHORT $LN31@xmlHashGro

; 241  :         return(-1);
; 242  :     if (size > 8 * 2048)

	cmp	esi, 16384				; 00004000H
	jg	SHORT $LN31@xmlHashGro

; 243  : 	return(-1);
; 244  : 
; 245  :     oldsize = table->size;
; 246  :     oldtable = table->table;

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [edi+4]
	mov	DWORD PTR _oldsize$1$[ebp], ebx
	mov	DWORD PTR _oldtable$1$[ebp], eax

; 247  :     if (oldtable == NULL)

	test	eax, eax
	je	SHORT $LN31@xmlHashGro

; 248  :         return(-1);
; 249  : 
; 250  :     table->table = xmlMalloc(size * sizeof(xmlHashEntry));

	lea	eax, DWORD PTR [esi+esi*2]
	shl	eax, 3
	push	eax
	mov	DWORD PTR tv528[ebp], eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi], eax

; 251  :     if (table->table == NULL) {

	test	eax, eax
	jne	SHORT $LN14@xmlHashGro

; 252  : 	table->table = oldtable;

	mov	esi, DWORD PTR _oldtable$1$[ebp]
	mov	DWORD PTR [edi], esi
$LN31@xmlHashGro:

; 309  : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlHashGro:

; 253  : 	return(-1);
; 254  :     }
; 255  :     memset(table->table, 0, size * sizeof(xmlHashEntry));

	push	DWORD PTR tv528[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 256  :     table->size = size;

	mov	DWORD PTR [edi+4], esi

; 257  : 
; 258  :     /*	If the two loops are merged, there would be situations where
; 259  : 	a new entry needs to allocated and data copied into it from
; 260  : 	the main table. So instead, we run through the array twice, first
; 261  : 	copying all the elements in the main array (where we can't get
; 262  : 	conflicts) and then the rest, so we only free (and don't allocate)
; 263  :     */
; 264  :     for (i = 0; i < oldsize; i++) {

	test	ebx, ebx
	jle	$LN6@xmlHashGro

; 253  : 	return(-1);
; 254  :     }
; 255  :     memset(table->table, 0, size * sizeof(xmlHashEntry));

	mov	esi, DWORD PTR _oldtable$1$[ebp]
	add	esi, 12					; 0000000cH
$LL4@xmlHashGro:

; 265  : 	if (oldtable[i].valid == 0)

	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN2@xmlHashGro

; 266  : 	    continue;
; 267  : 	key = xmlHashComputeKey(table, oldtable[i].name, oldtable[i].name2,

	push	DWORD PTR [esi]
	push	DWORD PTR [esi-4]
	push	DWORD PTR [esi-8]
	push	edi
	call	_xmlHashComputeKey

; 268  : 				oldtable[i].name3);
; 269  : 	memcpy(&(table->table[key]), &(oldtable[i]), sizeof(xmlHashEntry));

	movups	xmm0, XMMWORD PTR [esi-12]
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edi]
	movups	XMMWORD PTR [eax+ecx*8], xmm0
	movq	xmm0, QWORD PTR [esi+4]
	movq	QWORD PTR [eax+ecx*8+16], xmm0

; 270  : 	table->table[key].next = NULL;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+ecx*8], 0
$LN2@xmlHashGro:

; 257  : 
; 258  :     /*	If the two loops are merged, there would be situations where
; 259  : 	a new entry needs to allocated and data copied into it from
; 260  : 	the main table. So instead, we run through the array twice, first
; 261  : 	copying all the elements in the main array (where we can't get
; 262  : 	conflicts) and then the rest, so we only free (and don't allocate)
; 263  :     */
; 264  :     for (i = 0; i < oldsize; i++) {

	add	esi, 24					; 00000018H
	sub	ebx, 1
	jne	SHORT $LL4@xmlHashGro

; 271  :     }
; 272  : 
; 273  :     for (i = 0; i < oldsize; i++) {

	mov	eax, DWORD PTR _oldtable$1$[ebp]
	mov	ecx, DWORD PTR _oldsize$1$[ebp]
	mov	DWORD PTR tv518[ebp], eax
	npad	7
$LL7@xmlHashGro:

; 274  : 	iter = oldtable[i].next;

	mov	esi, DWORD PTR [eax]

; 275  : 	while (iter) {

	test	esi, esi
	je	SHORT $LN5@xmlHashGro
$LL8@xmlHashGro:

; 276  : 	    next = iter->next;
; 277  : 
; 278  : 	    /*
; 279  : 	     * put back the entry in the new table
; 280  : 	     */
; 281  : 
; 282  : 	    key = xmlHashComputeKey(table, iter->name, iter->name2,

	push	DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+4]
	push	edi
	call	_xmlHashComputeKey
	add	esp, 16					; 00000010H

; 283  : 		                    iter->name3);
; 284  : 	    if (table->table[key].valid == 0) {

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edi]
	shl	ecx, 3
	add	eax, ecx
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN16@xmlHashGro

; 285  : 		memcpy(&(table->table[key]), iter, sizeof(xmlHashEntry));

	movups	xmm0, XMMWORD PTR [esi]

; 286  : 		table->table[key].next = NULL;
; 287  : 		xmlFree(iter);

	push	esi
	movups	XMMWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR [esi+16]
	movq	QWORD PTR [eax+16], xmm0
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx+eax], 0
	call	DWORD PTR _xmlFree
	add	esp, 4

; 288  : 	    } else {

	jmp	SHORT $LN17@xmlHashGro
$LN16@xmlHashGro:

; 289  : 		iter->next = table->table[key].next;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax

; 290  : 		table->table[key].next = iter;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx+eax], esi
$LN17@xmlHashGro:

; 291  : 	    }
; 292  : 
; 293  : #ifdef DEBUG_GROW
; 294  : 	    nbElem++;
; 295  : #endif
; 296  : 
; 297  : 	    iter = next;

	mov	esi, ebx
	test	ebx, ebx
	jne	SHORT $LL8@xmlHashGro
	mov	eax, DWORD PTR tv518[ebp]
	mov	ecx, DWORD PTR _oldsize$1$[ebp]
$LN5@xmlHashGro:

; 271  :     }
; 272  : 
; 273  :     for (i = 0; i < oldsize; i++) {

	add	eax, 24					; 00000018H
	sub	ecx, 1
	mov	DWORD PTR tv518[ebp], eax
	mov	DWORD PTR _oldsize$1$[ebp], ecx
	jne	SHORT $LL7@xmlHashGro
$LN6@xmlHashGro:

; 298  : 	}
; 299  :     }
; 300  : 
; 301  :     xmlFree(oldtable);

	push	DWORD PTR _oldtable$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 302  : 
; 303  : #ifdef DEBUG_GROW
; 304  :     xmlGenericError(xmlGenericErrorContext,
; 305  : 	    "xmlHashGrow : from %d to %d, %d elems\n", oldsize, size, nbElem);
; 306  : #endif
; 307  : 
; 308  :     return(0);

	xor	eax, eax
	pop	edi

; 309  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashGrow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashComputeQKey
_TEXT	SEGMENT
_table$ = 8						; size = 4
_prefix$ = 12						; size = 4
_name$ = 16						; size = 4
_prefix2$ = 20						; size = 4
_name2$ = 24						; size = 4
_prefix3$ = 28						; size = 4
_name3$ = 32						; size = 4
_xmlHashComputeQKey PROC				; COMDAT

; 115  : 		   const xmlChar *prefix3, const xmlChar *name3) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _prefix$[ebp]
	mov	eax, edi
	mov	esi, DWORD PTR _name$[ebp]
	test	edi, edi
	cmove	eax, esi
	movzx	eax, BYTE PTR [eax]
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	add	ecx, ecx
	mov	eax, ecx
	test	edi, edi
	je	SHORT $LN16@xmlHashCom

; 116  :     unsigned long value = 0L;
; 117  :     char ch;
; 118  : 
; 119  : #ifdef HASH_RANDOMIZATION
; 120  :     value = table->random_seed;
; 121  : #endif
; 122  :     if (prefix != NULL)
; 123  : 	value += 30 * (*prefix);
; 124  :     else
; 125  : 	value += 30 * (*name);
; 126  : 
; 127  :     if (prefix != NULL) {
; 128  : 	while ((ch = *prefix++) != 0) {

	mov	bl, BYTE PTR [edi]
	test	bl, bl
	je	SHORT $LN29@xmlHashCom
$LL2@xmlHashCom:

; 129  : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	edx, eax
	lea	edi, DWORD PTR [edi+1]
	mov	ecx, eax
	shl	edx, 5
	shr	ecx, 3
	add	edx, ecx
	movsx	ecx, bl
	mov	bl, BYTE PTR [edi]
	add	edx, ecx
	xor	eax, edx
	test	bl, bl
	jne	SHORT $LL2@xmlHashCom
$LN29@xmlHashCom:

; 130  : 	}
; 131  : 	value = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');

	mov	ecx, eax
	mov	edx, eax
	shr	ecx, 3
	shl	edx, 5
	add	ecx, 58					; 0000003aH
	add	ecx, edx
	xor	eax, ecx
$LN16@xmlHashCom:

; 132  :     }
; 133  :     if (name != NULL) {

	test	esi, esi
	je	SHORT $LN31@xmlHashCom

; 134  : 	while ((ch = *name++) != 0) {

	mov	bl, BYTE PTR [esi]
	test	bl, bl
	je	SHORT $LN31@xmlHashCom
	npad	4
$LL4@xmlHashCom:

; 135  : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	edx, eax
	lea	esi, DWORD PTR [esi+1]
	mov	ecx, eax
	shl	edx, 5
	shr	ecx, 3
	add	edx, ecx
	movsx	ecx, bl
	mov	bl, BYTE PTR [esi]
	add	edx, ecx
	xor	eax, edx
	test	bl, bl
	jne	SHORT $LL4@xmlHashCom
$LN31@xmlHashCom:

; 136  : 	}
; 137  :     }
; 138  :     value = value ^ ((value << 5) + (value >> 3));
; 139  :     if (prefix2 != NULL) {

	mov	esi, DWORD PTR _prefix2$[ebp]
	mov	edx, eax
	mov	ecx, eax
	shl	edx, 5
	shr	ecx, 3
	add	edx, ecx
	xor	eax, edx
	test	esi, esi
	je	SHORT $LN18@xmlHashCom

; 140  : 	while ((ch = *prefix2++) != 0) {

	mov	bl, BYTE PTR [esi]
	test	bl, bl
	je	SHORT $LN33@xmlHashCom
$LL6@xmlHashCom:

; 141  : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	edx, eax
	lea	esi, DWORD PTR [esi+1]
	mov	ecx, eax
	shl	edx, 5
	shr	ecx, 3
	add	edx, ecx
	movsx	ecx, bl
	mov	bl, BYTE PTR [esi]
	add	edx, ecx
	xor	eax, edx
	test	bl, bl
	jne	SHORT $LL6@xmlHashCom
$LN33@xmlHashCom:

; 142  : 	}
; 143  : 	value = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');

	mov	ecx, eax
	mov	edx, eax
	shr	ecx, 3
	shl	edx, 5
	add	ecx, 58					; 0000003aH
	add	ecx, edx
	xor	eax, ecx
$LN18@xmlHashCom:

; 144  :     }
; 145  :     if (name2 != NULL) {

	mov	esi, DWORD PTR _name2$[ebp]
	test	esi, esi
	je	SHORT $LN35@xmlHashCom

; 146  : 	while ((ch = *name2++) != 0) {

	mov	bl, BYTE PTR [esi]
	test	bl, bl
	je	SHORT $LN35@xmlHashCom
$LL8@xmlHashCom:

; 147  : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	edx, eax
	lea	esi, DWORD PTR [esi+1]
	mov	ecx, eax
	shl	edx, 5
	shr	ecx, 3
	add	edx, ecx
	movsx	ecx, bl
	mov	bl, BYTE PTR [esi]
	add	edx, ecx
	xor	eax, edx
	test	bl, bl
	jne	SHORT $LL8@xmlHashCom
$LN35@xmlHashCom:

; 148  : 	}
; 149  :     }
; 150  :     value = value ^ ((value << 5) + (value >> 3));
; 151  :     if (prefix3 != NULL) {

	mov	esi, DWORD PTR _prefix3$[ebp]
	mov	edx, eax
	mov	ecx, eax
	shl	edx, 5
	shr	ecx, 3
	add	edx, ecx
	xor	eax, edx
	test	esi, esi
	je	SHORT $LN20@xmlHashCom

; 152  : 	while ((ch = *prefix3++) != 0) {

	mov	bl, BYTE PTR [esi]
	test	bl, bl
	je	SHORT $LN37@xmlHashCom
$LL10@xmlHashCom:

; 153  : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	edx, eax
	lea	esi, DWORD PTR [esi+1]
	mov	ecx, eax
	shl	edx, 5
	shr	ecx, 3
	add	edx, ecx
	movsx	ecx, bl
	mov	bl, BYTE PTR [esi]
	add	edx, ecx
	xor	eax, edx
	test	bl, bl
	jne	SHORT $LL10@xmlHashCom
$LN37@xmlHashCom:

; 154  : 	}
; 155  : 	value = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');

	mov	ecx, eax
	mov	edx, eax
	shr	ecx, 3
	shl	edx, 5
	add	ecx, 58					; 0000003aH
	add	ecx, edx
	xor	eax, ecx
$LN20@xmlHashCom:

; 156  :     }
; 157  :     if (name3 != NULL) {

	mov	esi, DWORD PTR _name3$[ebp]
	test	esi, esi
	je	SHORT $LN39@xmlHashCom

; 158  : 	while ((ch = *name3++) != 0) {

	mov	bl, BYTE PTR [esi]
	test	bl, bl
	je	SHORT $LN39@xmlHashCom
$LL12@xmlHashCom:

; 159  : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	edx, eax
	lea	esi, DWORD PTR [esi+1]
	mov	ecx, eax
	shl	edx, 5
	shr	ecx, 3
	add	edx, ecx
	movsx	ecx, bl
	mov	bl, BYTE PTR [esi]
	add	edx, ecx
	xor	eax, edx
	test	bl, bl
	jne	SHORT $LL12@xmlHashCom
$LN39@xmlHashCom:

; 160  : 	}
; 161  :     }
; 162  :     return (value % table->size);

	mov	ecx, DWORD PTR _table$[ebp]
	xor	edx, edx
	pop	edi
	pop	esi
	pop	ebx
	div	DWORD PTR [ecx+4]
	mov	eax, edx

; 163  : }

	pop	ebp
	ret	0
_xmlHashComputeQKey ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashComputeKey
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_name3$ = 20						; size = 4
_xmlHashComputeKey PROC					; COMDAT

; 83   : 	          const xmlChar *name2, const xmlChar *name3) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _name$[ebp]
	xor	eax, eax
	test	esi, esi
	je	SHORT $LN15@xmlHashCom

; 84   :     unsigned long value = 0L;
; 85   :     char ch;
; 86   : 
; 87   : #ifdef HASH_RANDOMIZATION
; 88   :     value = table->random_seed;
; 89   : #endif
; 90   :     if (name != NULL) {
; 91   : 	value += 30 * (*name);

	mov	bl, BYTE PTR [esi]
	movzx	ecx, bl
	mov	eax, ecx
	shl	eax, 4
	sub	eax, ecx
	add	eax, eax

; 92   : 	while ((ch = *name++) != 0) {

	test	bl, bl
	je	SHORT $LN15@xmlHashCom
	npad	6
$LL2@xmlHashCom:

; 93   : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	edx, eax
	lea	esi, DWORD PTR [esi+1]
	mov	ecx, eax
	shl	edx, 5
	shr	ecx, 3
	add	edx, ecx
	movsx	ecx, bl
	mov	bl, BYTE PTR [esi]
	add	edx, ecx
	xor	eax, edx
	test	bl, bl
	jne	SHORT $LL2@xmlHashCom
$LN15@xmlHashCom:

; 94   : 	}
; 95   :     }
; 96   :     value = value ^ ((value << 5) + (value >> 3));
; 97   :     if (name2 != NULL) {

	mov	esi, DWORD PTR _name2$[ebp]
	mov	edx, eax
	mov	ecx, eax
	shl	edx, 5
	shr	ecx, 3
	add	edx, ecx
	xor	eax, edx
	test	esi, esi
	je	SHORT $LN17@xmlHashCom

; 98   : 	while ((ch = *name2++) != 0) {

	mov	bl, BYTE PTR [esi]
	test	bl, bl
	je	SHORT $LN17@xmlHashCom
$LL4@xmlHashCom:

; 99   : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	edx, eax
	lea	esi, DWORD PTR [esi+1]
	mov	ecx, eax
	shl	edx, 5
	shr	ecx, 3
	add	edx, ecx
	movsx	ecx, bl
	mov	bl, BYTE PTR [esi]
	add	edx, ecx
	xor	eax, edx
	test	bl, bl
	jne	SHORT $LL4@xmlHashCom
$LN17@xmlHashCom:

; 100  : 	}
; 101  :     }
; 102  :     value = value ^ ((value << 5) + (value >> 3));
; 103  :     if (name3 != NULL) {

	mov	esi, DWORD PTR _name3$[ebp]
	mov	edx, eax
	mov	ecx, eax
	shl	edx, 5
	shr	ecx, 3
	add	edx, ecx
	xor	eax, edx
	test	esi, esi
	je	SHORT $LN19@xmlHashCom

; 104  : 	while ((ch = *name3++) != 0) {

	mov	bl, BYTE PTR [esi]
	test	bl, bl
	je	SHORT $LN19@xmlHashCom
	npad	2
$LL6@xmlHashCom:

; 105  : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	edx, eax
	lea	esi, DWORD PTR [esi+1]
	mov	ecx, eax
	shl	edx, 5
	shr	ecx, 3
	add	edx, ecx
	movsx	ecx, bl
	mov	bl, BYTE PTR [esi]
	add	edx, ecx
	xor	eax, edx
	test	bl, bl
	jne	SHORT $LL6@xmlHashCom
$LN19@xmlHashCom:

; 106  : 	}
; 107  :     }
; 108  :     return (value % table->size);

	mov	ecx, DWORD PTR _table$[ebp]
	xor	edx, edx
	pop	esi
	pop	ebx
	div	DWORD PTR [ecx+4]
	mov	eax, edx

; 109  : }

	pop	ebp
	ret	0
_xmlHashComputeKey ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashScanFull3
_TEXT	SEGMENT
tv273 = -8						; size = 4
_i$1$ = -4						; size = 4
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_name3$ = 20						; size = 4
_f$ = 24						; size = 4
_data$ = 28						; size = 4
_xmlHashScanFull3 PROC					; COMDAT

; 950  : 		 xmlHashScannerFull f, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _table$[ebp]
	test	eax, eax
	je	$LN3@xmlHashSca

; 951  :     int i;
; 952  :     xmlHashEntryPtr iter;
; 953  :     xmlHashEntryPtr next;
; 954  : 
; 955  :     if (table == NULL)
; 956  : 	return;
; 957  :     if (f == NULL)

	cmp	DWORD PTR _f$[ebp], 0
	je	$LN3@xmlHashSca

; 958  : 	return;
; 959  : 
; 960  :     if (table->table) {

	cmp	DWORD PTR [eax], 0
	je	$LN3@xmlHashSca

; 961  : 	for(i = 0; i < table->size; i++) {

	push	edi
	xor	edi, edi
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	DWORD PTR [eax+4], edi
	jle	$LN24@xmlHashSca
	mov	ecx, DWORD PTR _name2$[ebp]
	mov	edx, DWORD PTR _name$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _name3$[ebp]
	push	esi
	xor	esi, esi
	mov	DWORD PTR tv273[ebp], esi
	npad	3
$LL4@xmlHashSca:

; 962  : 	    if (table->table[i].valid == 0)

	mov	eax, DWORD PTR [eax]
	add	esi, eax
	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN2@xmlHashSca

; 963  : 		continue;
; 964  : 	    iter = &(table->table[i]);
; 965  : 	    while (iter) {

	test	esi, esi
	je	SHORT $LN2@xmlHashSca
	npad	2
$LL5@xmlHashSca:

; 966  : 		next = iter->next;

	mov	edi, DWORD PTR [esi]

; 967  : 		if (((name == NULL) || (xmlStrEqual(name, iter->name))) &&
; 968  : 		    ((name2 == NULL) || (xmlStrEqual(name2, iter->name2))) &&
; 969  : 		    ((name3 == NULL) || (xmlStrEqual(name3, iter->name3))) &&

	test	edx, edx
	je	SHORT $LN12@xmlHashSca
	push	DWORD PTR [esi+4]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlHashSca
	mov	ecx, DWORD PTR _name2$[ebp]
$LN12@xmlHashSca:
	test	ecx, ecx
	je	SHORT $LN13@xmlHashSca
	push	DWORD PTR [esi+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlHashSca
$LN13@xmlHashSca:
	test	ebx, ebx
	je	SHORT $LN14@xmlHashSca
	push	DWORD PTR [esi+12]
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlHashSca
$LN14@xmlHashSca:
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN11@xmlHashSca

; 970  : 		    (iter->payload != NULL)) {
; 971  : 		    f(iter->payload, data, iter->name,

	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+4]
	push	DWORD PTR _data$[ebp]
	push	eax
	call	DWORD PTR _f$[ebp]
	add	esp, 20					; 00000014H
$LN11@xmlHashSca:

; 972  : 		      iter->name2, iter->name3);
; 973  : 		}
; 974  : 		iter = next;

	mov	ecx, DWORD PTR _name2$[ebp]
	mov	esi, edi
	mov	edx, DWORD PTR _name$[ebp]
	test	edi, edi
	jne	SHORT $LL5@xmlHashSca
	mov	edi, DWORD PTR _i$1$[ebp]
$LN2@xmlHashSca:

; 961  : 	for(i = 0; i < table->size; i++) {

	mov	eax, DWORD PTR _table$[ebp]
	inc	edi
	mov	esi, DWORD PTR tv273[ebp]
	add	esi, 24					; 00000018H
	mov	DWORD PTR _i$1$[ebp], edi
	mov	DWORD PTR tv273[ebp], esi
	cmp	edi, DWORD PTR [eax+4]
	jl	$LL4@xmlHashSca
	pop	esi
	pop	ebx
$LN24@xmlHashSca:
	pop	edi
$LN3@xmlHashSca:

; 975  : 	    }
; 976  : 	}
; 977  :     }
; 978  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashScanFull3 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashScanFull
_TEXT	SEGMENT
_next$1$ = -12						; size = 4
_i$1$ = -8						; size = 4
tv509 = -4						; size = 4
_table$ = 8						; size = 4
_f$ = 12						; size = 4
_data$ = 16						; size = 4
_xmlHashScanFull PROC					; COMDAT

; 873  : xmlHashScanFull(xmlHashTablePtr table, xmlHashScannerFull f, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _table$[ebp]
	test	edx, edx
	je	$LN3@xmlHashSca

; 874  :     int i, nb;
; 875  :     xmlHashEntryPtr iter;
; 876  :     xmlHashEntryPtr next;
; 877  : 
; 878  :     if (table == NULL)
; 879  : 	return;
; 880  :     if (f == NULL)

	cmp	DWORD PTR _f$[ebp], 0
	je	$LN3@xmlHashSca

; 881  : 	return;
; 882  : 
; 883  :     if (table->table) {

	cmp	DWORD PTR [edx], 0
	je	$LN3@xmlHashSca

; 884  : 	for(i = 0; i < table->size; i++) {

	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR _i$1$[ebp], ebx
	cmp	DWORD PTR [edx+4], ebx
	jle	$LN26@xmlHashSca
	xor	ecx, ecx
	push	esi
	mov	DWORD PTR tv509[ebp], ecx
	push	edi
$LL4@xmlHashSca:

; 885  : 	    if (table->table[i].valid == 0)

	mov	esi, DWORD PTR [edx]
	add	esi, ecx
	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN2@xmlHashSca

; 886  : 		continue;
; 887  : 	    iter = &(table->table[i]);
; 888  : 	    while (iter) {

	test	esi, esi
	je	SHORT $LN2@xmlHashSca
	mov	edi, DWORD PTR [edx+8]
$LL5@xmlHashSca:

; 889  : 		next = iter->next;
; 890  :                 nb = table->nbElems;
; 891  : 		if ((f != NULL) && (iter->payload != NULL))

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, edi
	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR _next$1$[ebp], ebx
	test	eax, eax
	je	SHORT $LN12@xmlHashSca

; 892  : 		    f(iter->payload, data, iter->name,

	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+4]
	push	DWORD PTR _data$[ebp]
	push	eax
	call	DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR _table$[ebp]
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [edx+8]

; 893  : 		      iter->name2, iter->name3);
; 894  :                 if (nb != table->nbElems) {

	cmp	edi, ecx
	je	SHORT $LN12@xmlHashSca

; 895  :                     /* table was modified by the callback, be careful */
; 896  :                     if (iter == &(table->table[i])) {

	mov	edi, DWORD PTR [edx]
	mov	edx, DWORD PTR tv509[ebp]
	add	edx, edi
	cmp	esi, edx
	jne	SHORT $LN12@xmlHashSca

; 897  :                         if (table->table[i].valid == 0)
; 898  :                             iter = NULL;
; 899  :                         if (table->table[i].next != next)

	mov	ebx, DWORD PTR tv509[ebp]
	xor	eax, eax
	cmp	DWORD PTR [ebx+edi+20], eax

; 900  : 			    iter = &(table->table[i]);
; 901  :                     } else

	mov	ebx, DWORD PTR _next$1$[ebp]
	cmovne	eax, esi
	cmp	DWORD PTR [edx], ebx
	mov	esi, edx
	cmove	esi, eax
	jmp	SHORT $LN15@xmlHashSca
$LN12@xmlHashSca:

; 886  : 		continue;
; 887  : 	    iter = &(table->table[i]);
; 888  : 	    while (iter) {

	mov	esi, ebx
$LN15@xmlHashSca:
	mov	edi, ecx
	test	esi, esi
	jne	SHORT $LL5@xmlHashSca
	mov	edx, DWORD PTR _table$[ebp]
	mov	ecx, DWORD PTR tv509[ebp]
	mov	ebx, DWORD PTR _i$1$[ebp]
$LN2@xmlHashSca:

; 884  : 	for(i = 0; i < table->size; i++) {

	inc	ebx
	add	ecx, 24					; 00000018H
	mov	DWORD PTR _i$1$[ebp], ebx
	mov	DWORD PTR tv509[ebp], ecx
	cmp	ebx, DWORD PTR [edx+4]
	jl	SHORT $LL4@xmlHashSca
	pop	edi
	pop	esi
$LN26@xmlHashSca:
	pop	ebx
$LN3@xmlHashSca:

; 902  : 		        iter = next;
; 903  :                 } else
; 904  : 		    iter = next;
; 905  : 	    }
; 906  : 	}
; 907  :     }
; 908  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashScanFull ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashScan3
_TEXT	SEGMENT
_stubdata$ = -8						; size = 8
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_name3$ = 20						; size = 4
_f$ = 24						; size = 4
_data$ = 28						; size = 4
_xmlHashScan3 PROC					; COMDAT

; 926  : 	     xmlHashScanner f, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _stubdata$[ebp+4], eax
	mov	eax, DWORD PTR _f$[ebp]
	mov	DWORD PTR _stubdata$[ebp], eax
	lea	eax, DWORD PTR _stubdata$[ebp]
	push	eax
	push	OFFSET _stubHashScannerFull
	push	DWORD PTR _name3$[ebp]
	push	DWORD PTR _name2$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _table$[ebp]
	call	_xmlHashScanFull3
	add	esp, 24					; 00000018H

; 927  :     stubData stubdata;
; 928  :     stubdata.data = data;
; 929  :     stubdata.hashscanner = f;
; 930  :     xmlHashScanFull3(table, name, name2, name3, stubHashScannerFull,
; 931  :                      &stubdata);
; 932  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashScan3 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashScan
_TEXT	SEGMENT
_stubdata$ = -8						; size = 8
_table$ = 8						; size = 4
_f$ = 12						; size = 4
_data$ = 16						; size = 4
_xmlHashScan PROC					; COMDAT

; 857  : xmlHashScan(xmlHashTablePtr table, xmlHashScanner f, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _stubdata$[ebp+4], eax
	mov	eax, DWORD PTR _f$[ebp]
	mov	DWORD PTR _stubdata$[ebp], eax
	lea	eax, DWORD PTR _stubdata$[ebp]
	push	eax
	push	OFFSET _stubHashScannerFull
	push	DWORD PTR _table$[ebp]
	call	_xmlHashScanFull
	add	esp, 12					; 0000000cH

; 858  :     stubData stubdata;
; 859  :     stubdata.data = data;
; 860  :     stubdata.hashscanner = f;
; 861  :     xmlHashScanFull (table, stubHashScannerFull, &stubdata);
; 862  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashScan ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashSize
_TEXT	SEGMENT
_table$ = 8						; size = 4
_xmlHashSize PROC					; COMDAT

; 1032 : xmlHashSize(xmlHashTablePtr table) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _table$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlHashSiz

; 1033 :     if (table == NULL)
; 1034 : 	return(-1);

	or	eax, -1

; 1036 : }

	pop	ebp
	ret	0
$LN2@xmlHashSiz:

; 1035 :     return(table->nbElems);

	mov	eax, DWORD PTR [eax+8]

; 1036 : }

	pop	ebp
	ret	0
_xmlHashSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashCopy
_TEXT	SEGMENT
_ret$1$ = -12						; size = 4
tv236 = -8						; size = 4
_i$1$ = -4						; size = 4
_table$ = 8						; size = 4
_f$ = 12						; size = 4
_xmlHashCopy PROC					; COMDAT

; 990  : xmlHashCopy(xmlHashTablePtr table, xmlHashCopier f) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __776982E1_hash@c
	push	ebx
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _table$[ebp]
	test	ebx, ebx
	je	$LN21@xmlHashCop

; 991  :     int i;
; 992  :     xmlHashEntryPtr iter;
; 993  :     xmlHashEntryPtr next;
; 994  :     xmlHashTablePtr ret;
; 995  : 
; 996  :     if (table == NULL)
; 997  : 	return(NULL);
; 998  :     if (f == NULL)

	cmp	DWORD PTR _f$[ebp], 0
	je	$LN21@xmlHashCop

; 999  : 	return(NULL);
; 1000 : 
; 1001 :     ret = xmlHashCreate(table->size);

	push	DWORD PTR [ebx+4]
	call	_xmlHashCreate
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _ret$1$[ebp], edi

; 1002 :     if (ret == NULL)

	test	edi, edi
	je	SHORT $LN21@xmlHashCop

; 1004 : 
; 1005 :     if (table->table) {

	cmp	DWORD PTR [ebx], 0
	je	SHORT $LN3@xmlHashCop

; 1006 : 	for(i = 0; i < table->size; i++) {

	xor	ecx, ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	DWORD PTR [ebx+4], ecx
	jle	SHORT $LN3@xmlHashCop
	xor	edx, edx
	mov	DWORD PTR tv236[ebp], edx
	push	esi
$LL4@xmlHashCop:

; 1007 : 	    if (table->table[i].valid == 0)

	mov	esi, DWORD PTR [ebx]
	add	esi, edx
	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN2@xmlHashCop

; 1008 : 		continue;
; 1009 : 	    iter = &(table->table[i]);
; 1010 : 	    while (iter) {

	test	esi, esi
	je	SHORT $LN2@xmlHashCop
	mov	ebx, DWORD PTR _ret$1$[ebp]
$LL5@xmlHashCop:

; 1011 : 		next = iter->next;
; 1012 : 		xmlHashAddEntry3(ret, iter->name, iter->name2,

	push	DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi]
	push	DWORD PTR [esi+16]
	call	DWORD PTR _f$[ebp]
	push	eax
	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+4]
	push	ebx
	call	_xmlHashAddEntry3
	add	esp, 28					; 0000001cH

; 1013 : 			         iter->name3, f(iter->payload, iter->name));
; 1014 : 		iter = next;

	mov	esi, edi
	test	edi, edi
	jne	SHORT $LL5@xmlHashCop
	mov	ebx, DWORD PTR _table$[ebp]
	mov	ecx, DWORD PTR _i$1$[ebp]
	mov	edx, DWORD PTR tv236[ebp]
$LN2@xmlHashCop:

; 1006 : 	for(i = 0; i < table->size; i++) {

	inc	ecx
	add	edx, 24					; 00000018H
	mov	DWORD PTR _i$1$[ebp], ecx
	mov	DWORD PTR tv236[ebp], edx
	cmp	ecx, DWORD PTR [ebx+4]
	jl	SHORT $LL4@xmlHashCop
	mov	edi, DWORD PTR _ret$1$[ebp]
	pop	esi
$LN3@xmlHashCop:

; 1015 : 	    }
; 1016 : 	}
; 1017 :     }
; 1018 :     ret->nbElems = table->nbElems;

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [edi+8], eax

; 1019 :     return(ret);

	mov	eax, edi
	pop	edi

; 1020 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlHashCop:
	pop	edi

; 1003 :         return(NULL);

	xor	eax, eax

; 1020 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashQLookup3
_TEXT	SEGMENT
_table$ = 8						; size = 4
_prefix$ = 12						; size = 4
_name$ = 16						; size = 4
_prefix2$ = 20						; size = 4
_name2$ = 24						; size = 4
_prefix3$ = 28						; size = 4
_name3$ = 32						; size = 4
_xmlHashQLookup3 PROC					; COMDAT

; 814  : 		const xmlChar *prefix3, const xmlChar *name3) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _table$[ebp]
	test	esi, esi
	je	SHORT $LN15@xmlHashQLo

; 815  :     unsigned long key;
; 816  :     xmlHashEntryPtr entry;
; 817  : 
; 818  :     if (table == NULL)
; 819  : 	return(NULL);
; 820  :     if (name == NULL)

	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	je	SHORT $LN15@xmlHashQLo

; 821  : 	return(NULL);
; 822  :     key = xmlHashComputeQKey(table, prefix, name, prefix2,

	mov	ebx, DWORD PTR _name3$[ebp]
	push	ebx
	push	DWORD PTR _prefix3$[ebp]
	push	DWORD PTR _name2$[ebp]
	push	DWORD PTR _prefix2$[ebp]
	push	edi
	push	DWORD PTR _prefix$[ebp]
	push	esi
	call	_xmlHashComputeQKey
	add	esp, 28					; 0000001cH

; 823  :                              name2, prefix3, name3);
; 824  :     if (table->table[key].valid == 0)

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+ecx*8+20], 0
	lea	esi, DWORD PTR [eax+ecx*8]
	je	SHORT $LN15@xmlHashQLo

; 825  : 	return(NULL);
; 826  :     for (entry = &(table->table[key]); entry != NULL; entry = entry->next) {

	test	esi, esi
	je	SHORT $LN15@xmlHashQLo
	npad	5
$LL4@xmlHashQLo:

; 827  : 	if ((xmlStrQEqual(prefix, name, entry->name)) &&
; 828  : 	    (xmlStrQEqual(prefix2, name2, entry->name2)) &&

	push	DWORD PTR [esi+4]
	push	edi
	push	DWORD PTR _prefix$[ebp]
	call	_xmlStrQEqual
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@xmlHashQLo
	push	DWORD PTR [esi+8]
	push	DWORD PTR _name2$[ebp]
	push	DWORD PTR _prefix2$[ebp]
	call	_xmlStrQEqual
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@xmlHashQLo
	push	DWORD PTR [esi+12]
	push	ebx
	push	DWORD PTR _prefix3$[ebp]
	call	_xmlStrQEqual
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@xmlHashQLo
$LN2@xmlHashQLo:

; 825  : 	return(NULL);
; 826  :     for (entry = &(table->table[key]); entry != NULL; entry = entry->next) {

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL4@xmlHashQLo
$LN15@xmlHashQLo:
	pop	edi

; 831  :     }
; 832  :     return(NULL);
; 833  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlHashQLo:

; 829  : 	    (xmlStrQEqual(prefix3, name3, entry->name3)))
; 830  : 	    return(entry->payload);

	mov	eax, DWORD PTR [esi+16]
	pop	edi

; 831  :     }
; 832  :     return(NULL);
; 833  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlHashQLookup3 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashQLookup2
_TEXT	SEGMENT
_table$ = 8						; size = 4
_prefix$ = 12						; size = 4
_name$ = 16						; size = 4
_prefix2$ = 20						; size = 4
_name2$ = 24						; size = 4
_xmlHashQLookup2 PROC					; COMDAT

; 510  : 	        const xmlChar *name2) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	0
	push	DWORD PTR _name2$[ebp]
	push	DWORD PTR _prefix2$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _prefix$[ebp]
	push	DWORD PTR _table$[ebp]
	call	_xmlHashQLookup3
	add	esp, 28					; 0000001cH

; 511  :     return(xmlHashQLookup3(table, prefix, name, prefix2, name2, NULL, NULL));
; 512  : }

	pop	ebp
	ret	0
_xmlHashQLookup2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashQLookup
_TEXT	SEGMENT
_table$ = 8						; size = 4
_prefix$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlHashQLookup PROC					; COMDAT

; 491  :                const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	0
	push	0
	push	0
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _prefix$[ebp]
	push	DWORD PTR _table$[ebp]
	call	_xmlHashQLookup3
	add	esp, 28					; 0000001cH

; 492  :     return(xmlHashQLookup3(table, prefix, name, NULL, NULL, NULL, NULL));
; 493  : }

	pop	ebp
	ret	0
_xmlHashQLookup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashLookup3
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_name3$ = 20						; size = 4
_xmlHashLookup3 PROC					; COMDAT

; 768  : 	       const xmlChar *name2, const xmlChar *name3) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _table$[ebp]
	test	esi, esi
	je	$LN26@xmlHashLoo

; 769  :     unsigned long key;
; 770  :     xmlHashEntryPtr entry;
; 771  : 
; 772  :     if (table == NULL)
; 773  : 	return(NULL);
; 774  :     if (name == NULL)

	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	je	$LN26@xmlHashLoo

; 775  : 	return(NULL);
; 776  :     key = xmlHashComputeKey(table, name, name2, name3);

	mov	ebx, DWORD PTR _name3$[ebp]
	push	ebx
	push	DWORD PTR _name2$[ebp]
	push	edi
	push	esi
	call	_xmlHashComputeKey
	add	esp, 16					; 00000010H

; 777  :     if (table->table[key].valid == 0)

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+ecx*8+20], 0
	lea	esi, DWORD PTR [eax+ecx*8]
	je	SHORT $LN26@xmlHashLoo

; 778  : 	return(NULL);
; 779  :     if (table->dict) {

	mov	eax, DWORD PTR _table$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN25@xmlHashLoo

; 780  : 	for (entry = &(table->table[key]); entry != NULL; entry = entry->next) {

	mov	eax, esi
	test	eax, eax
	je	SHORT $LN25@xmlHashLoo
	mov	ecx, DWORD PTR _name2$[ebp]
$LL4@xmlHashLoo:

; 781  : 	    if ((entry->name == name) &&
; 782  : 		(entry->name2 == name2) &&

	cmp	DWORD PTR [eax+4], edi
	jne	SHORT $LN2@xmlHashLoo
	cmp	DWORD PTR [eax+8], ecx
	jne	SHORT $LN2@xmlHashLoo
	cmp	DWORD PTR [eax+12], ebx
	je	SHORT $LN17@xmlHashLoo
$LN2@xmlHashLoo:

; 780  : 	for (entry = &(table->table[key]); entry != NULL; entry = entry->next) {

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL4@xmlHashLoo
$LN25@xmlHashLoo:

; 785  : 	}
; 786  :     }
; 787  :     for (entry = &(table->table[key]); entry != NULL; entry = entry->next) {

	test	esi, esi
	je	SHORT $LN26@xmlHashLoo
$LL7@xmlHashLoo:

; 788  : 	if ((xmlStrEqual(entry->name, name)) &&
; 789  : 	    (xmlStrEqual(entry->name2, name2)) &&

	push	edi
	push	DWORD PTR [esi+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlHashLoo
	push	DWORD PTR _name2$[ebp]
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlHashLoo
	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN18@xmlHashLoo
$LN5@xmlHashLoo:

; 785  : 	}
; 786  :     }
; 787  :     for (entry = &(table->table[key]); entry != NULL; entry = entry->next) {

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL7@xmlHashLoo
$LN26@xmlHashLoo:
	pop	edi

; 792  :     }
; 793  :     return(NULL);
; 794  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN17@xmlHashLoo:

; 783  : 		(entry->name3 == name3))
; 784  : 		return(entry->payload);

	mov	eax, DWORD PTR [eax+16]
	pop	edi

; 792  :     }
; 793  :     return(NULL);
; 794  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN18@xmlHashLoo:

; 790  : 	    (xmlStrEqual(entry->name3, name3)))
; 791  : 	    return(entry->payload);

	mov	eax, DWORD PTR [esi+16]
	pop	edi

; 792  :     }
; 793  :     return(NULL);
; 794  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlHashLookup3 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashLookup2
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_xmlHashLookup2 PROC					; COMDAT

; 475  : 	      const xmlChar *name2) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _name2$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _table$[ebp]
	call	_xmlHashLookup3
	add	esp, 16					; 00000010H

; 476  :     return(xmlHashLookup3(table, name, name2, NULL));
; 477  : }

	pop	ebp
	ret	0
_xmlHashLookup2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashLookup
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlHashLookup PROC					; COMDAT

; 459  : xmlHashLookup(xmlHashTablePtr table, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	0
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _table$[ebp]
	call	_xmlHashLookup3
	add	esp, 16					; 00000010H

; 460  :     return(xmlHashLookup3(table, name, NULL, NULL));
; 461  : }

	pop	ebp
	ret	0
_xmlHashLookup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashRemoveEntry3
_TEXT	SEGMENT
tv309 = 8						; size = 4
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_name3$ = 20						; size = 4
_f$ = 24						; size = 4
_xmlHashRemoveEntry3 PROC				; COMDAT

; 1090 :     const xmlChar *name2, const xmlChar *name3, xmlHashDeallocator f) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _table$[ebp]
	xor	ebx, ebx
	test	edi, edi
	je	SHORT $LN25@xmlHashRem

; 1091 :     unsigned long key;
; 1092 :     xmlHashEntryPtr entry;
; 1093 :     xmlHashEntryPtr prev = NULL;
; 1094 : 
; 1095 :     if (table == NULL || name == NULL)

	mov	eax, DWORD PTR _name$[ebp]
	test	eax, eax
	je	SHORT $LN25@xmlHashRem

; 1096 :         return(-1);
; 1097 : 
; 1098 :     key = xmlHashComputeKey(table, name, name2, name3);

	push	DWORD PTR _name3$[ebp]
	push	DWORD PTR _name2$[ebp]
	push	eax
	push	edi
	call	_xmlHashComputeKey

; 1099 :     if (table->table[key].valid == 0) {

	mov	esi, DWORD PTR [edi]
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 3
	add	esi, ecx
	mov	DWORD PTR tv309[ebp], ecx
	cmp	DWORD PTR [esi+20], ebx
	je	SHORT $LN25@xmlHashRem

; 1100 :         return(-1);
; 1101 :     } else {
; 1102 :         for (entry = &(table->table[key]); entry != NULL; entry = entry->next) {

	test	esi, esi
	je	SHORT $LN25@xmlHashRem
	npad	10
$LL4@xmlHashRem:

; 1103 :             if (xmlStrEqual(entry->name, name) &&
; 1104 :                     xmlStrEqual(entry->name2, name2) &&

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [esi+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlHashRem
	push	DWORD PTR _name2$[ebp]
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlHashRem
	push	DWORD PTR _name3$[ebp]
	push	DWORD PTR [esi+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@xmlHashRem
$LN9@xmlHashRem:

; 1131 :             }
; 1132 :             prev = entry;

	mov	ebx, esi
	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL4@xmlHashRem
$LN25@xmlHashRem:
	pop	edi

; 1133 :         }
; 1134 :         return(-1);
; 1135 :     }
; 1136 : }

	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN21@xmlHashRem:

; 1105 :                     xmlStrEqual(entry->name3, name3)) {
; 1106 :                 if ((f != NULL) && (entry->payload != NULL))

	mov	eax, DWORD PTR _f$[ebp]
	test	eax, eax
	je	SHORT $LN10@xmlHashRem
	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	je	SHORT $LN10@xmlHashRem

; 1107 :                     f(entry->payload, entry->name);

	push	DWORD PTR [esi+4]
	push	ecx
	call	eax
	add	esp, 8
$LN10@xmlHashRem:

; 1108 :                 entry->payload = NULL;

	mov	DWORD PTR [esi+16], 0

; 1109 : 		if (table->dict == NULL) {

	cmp	DWORD PTR [edi+12], 0
	jne	SHORT $LN14@xmlHashRem

; 1110 : 		    if(entry->name)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN12@xmlHashRem

; 1111 : 			xmlFree(entry->name);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlHashRem:

; 1112 : 		    if(entry->name2)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN13@xmlHashRem

; 1113 : 			xmlFree(entry->name2);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlHashRem:

; 1114 : 		    if(entry->name3)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN14@xmlHashRem

; 1115 : 			xmlFree(entry->name3);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlHashRem:

; 1116 : 		}
; 1117 :                 if(prev) {

	test	ebx, ebx
	je	SHORT $LN15@xmlHashRem

; 1118 :                     prev->next = entry->next;

	mov	eax, DWORD PTR [esi]

; 1119 : 		    xmlFree(entry);

	push	esi
	mov	DWORD PTR [ebx], eax

; 1127 : 		    }
; 1128 : 		}
; 1129 :                 table->nbElems--;

	call	DWORD PTR _xmlFree
	dec	DWORD PTR [edi+8]
	add	esp, 4

; 1130 :                 return(0);

	xor	eax, eax
	pop	edi

; 1133 :         }
; 1134 :         return(-1);
; 1135 :     }
; 1136 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN15@xmlHashRem:

; 1120 : 		} else {
; 1121 : 		    if (entry->next == NULL) {

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	jne	SHORT $LN17@xmlHashRem

; 1122 : 			entry->valid = 0;

	mov	DWORD PTR [esi+20], ecx

; 1127 : 		    }
; 1128 : 		}
; 1129 :                 table->nbElems--;

	dec	DWORD PTR [edi+8]

; 1130 :                 return(0);

	xor	eax, eax
	pop	edi

; 1133 :         }
; 1134 :         return(-1);
; 1135 :     }
; 1136 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN17@xmlHashRem:

; 1123 : 		    } else {
; 1124 : 			entry = entry->next;
; 1125 : 			memcpy(&(table->table[key]), entry, sizeof(xmlHashEntry));

	mov	eax, DWORD PTR [edi]
	add	eax, DWORD PTR tv309[ebp]
	movups	xmm0, XMMWORD PTR [ecx]

; 1126 : 			xmlFree(entry);

	push	ecx
	movups	XMMWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR [ecx+16]
	movq	QWORD PTR [eax+16], xmm0

; 1127 : 		    }
; 1128 : 		}
; 1129 :                 table->nbElems--;

	call	DWORD PTR _xmlFree
	dec	DWORD PTR [edi+8]
	add	esp, 4

; 1130 :                 return(0);

	xor	eax, eax
	pop	edi

; 1133 :         }
; 1134 :         return(-1);
; 1135 :     }
; 1136 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlHashRemoveEntry3 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashRemoveEntry2
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_f$ = 20						; size = 4
_xmlHashRemoveEntry2 PROC				; COMDAT

; 1070 : 			const xmlChar *name2, xmlHashDeallocator f) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _f$[ebp]
	push	0
	push	DWORD PTR _name2$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _table$[ebp]
	call	_xmlHashRemoveEntry3
	add	esp, 20					; 00000014H

; 1071 :     return(xmlHashRemoveEntry3(table, name, name2, NULL, f));
; 1072 : }

	pop	ebp
	ret	0
_xmlHashRemoveEntry2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashRemoveEntry
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_f$ = 16						; size = 4
_xmlHashRemoveEntry PROC				; COMDAT

; 1051 : 		       xmlHashDeallocator f) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _f$[ebp]
	push	0
	push	0
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _table$[ebp]
	call	_xmlHashRemoveEntry3
	add	esp, 20					; 00000014H

; 1052 :     return(xmlHashRemoveEntry3(table, name, NULL, NULL, f));
; 1053 : }

	pop	ebp
	ret	0
_xmlHashRemoveEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashUpdateEntry3
_TEXT	SEGMENT
_entry$1$ = -4						; size = 4
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_name3$ = 20						; size = 4
_userdata$ = 24						; size = 4
_f$ = 28						; size = 4
_xmlHashUpdateEntry3 PROC				; COMDAT

; 647  : 		   void *userdata, xmlHashDeallocator f) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _table$[ebp]
	test	edi, edi
	je	$LN9@xmlHashUpd

; 648  :     unsigned long key;
; 649  :     xmlHashEntryPtr entry;
; 650  :     xmlHashEntryPtr insert;
; 651  : 
; 652  :     if ((table == NULL) || name == NULL)

	mov	esi, DWORD PTR _name$[ebp]
	test	esi, esi
	je	$LN9@xmlHashUpd

; 653  : 	return(-1);
; 654  : 
; 655  :     /*
; 656  :      * If using a dict internalize if needed
; 657  :      */
; 658  :     if (table->dict) {

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	$LN49@xmlHashUpd

; 659  :         if (!xmlDictOwns(table->dict, name)) {

	push	esi
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlHashUpd

; 660  : 	    name = xmlDictLookup(table->dict, name, -1);

	push	-1
	push	esi
	push	DWORD PTR [edi+12]
	call	_xmlDictLookup
	mov	esi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _name$[ebp], esi

; 661  : 	    if (name == NULL)

	test	esi, esi
	je	SHORT $LN9@xmlHashUpd
$LN12@xmlHashUpd:

; 662  : 	        return(-1);
; 663  : 	}
; 664  :         if ((name2 != NULL) && (!xmlDictOwns(table->dict, name2))) {

	mov	ebx, DWORD PTR _name2$[ebp]
	test	ebx, ebx
	je	SHORT $LN14@xmlHashUpd
	push	ebx
	push	DWORD PTR [edi+12]
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlHashUpd

; 665  : 	    name2 = xmlDictLookup(table->dict, name2, -1);

	push	-1
	push	ebx
	push	DWORD PTR [edi+12]
	call	_xmlDictLookup
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 666  : 	    if (name2 == NULL)

	test	ebx, ebx
	je	SHORT $LN9@xmlHashUpd
$LN14@xmlHashUpd:

; 667  : 	        return(-1);
; 668  : 	}
; 669  :         if ((name3 != NULL) && (!xmlDictOwns(table->dict, name3))) {

	mov	edi, DWORD PTR _name3$[ebp]
	test	edi, edi
	je	SHORT $LN16@xmlHashUpd
	mov	eax, DWORD PTR _table$[ebp]
	push	edi
	push	DWORD PTR [eax+12]
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@xmlHashUpd

; 670  : 	    name3 = xmlDictLookup(table->dict, name3, -1);

	mov	eax, DWORD PTR _table$[ebp]
	push	-1
	push	edi
	push	DWORD PTR [eax+12]
	call	_xmlDictLookup
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 671  : 	    if (name3 == NULL)

	test	edi, edi
	jne	SHORT $LN16@xmlHashUpd
$LN9@xmlHashUpd:
	pop	edi

; 751  :     }
; 752  :     return(0);
; 753  : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@xmlHashUpd:

; 653  : 	return(-1);
; 654  : 
; 655  :     /*
; 656  :      * If using a dict internalize if needed
; 657  :      */
; 658  :     if (table->dict) {

	mov	edi, DWORD PTR _name3$[ebp]
	mov	ebx, DWORD PTR _name2$[ebp]
$LN16@xmlHashUpd:

; 672  : 	        return(-1);
; 673  : 	}
; 674  :     }
; 675  : 
; 676  :     /*
; 677  :      * Check for duplicate and insertion location.
; 678  :      */
; 679  :     key = xmlHashComputeKey(table, name, name2, name3);

	push	edi
	push	ebx
	push	esi
	push	DWORD PTR _table$[ebp]
	call	_xmlHashComputeKey

; 680  :     if (table->table[key].valid == 0) {

	mov	edx, DWORD PTR _table$[ebp]
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 3
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _entry$1$[ebp], ecx
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN17@xmlHashUpd

; 681  : 	insert = NULL;

	xor	esi, esi

; 717  : 		(xmlStrEqual(insert->name3, name3))) {
; 718  : 		if (f)
; 719  : 		    f(insert->payload, insert->name);
; 720  : 		insert->payload = userdata;
; 721  : 		return(0);
; 722  : 	    }
; 723  : 	}
; 724  :     }
; 725  : 
; 726  :     if (insert == NULL) {
; 727  : 	entry =  &(table->table[key]);
; 728  :     } else {

	jmp	$LN31@xmlHashUpd
$LN17@xmlHashUpd:

; 682  :     } else {
; 683  :         if (table ->dict) {

	cmp	DWORD PTR [edx+12], 0
	mov	esi, ecx
	je	SHORT $LN19@xmlHashUpd

; 684  : 	    for (insert = &(table->table[key]); insert->next != NULL;

	cmp	DWORD PTR [esi], 0
	mov	eax, DWORD PTR _name$[ebp]
	je	SHORT $LN47@xmlHashUpd
	npad	4
$LL4@xmlHashUpd:

; 686  : 		if ((insert->name == name) &&
; 687  : 		    (insert->name2 == name2) &&

	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	jne	SHORT $LN2@xmlHashUpd
	cmp	DWORD PTR [esi+8], ebx
	jne	SHORT $LN2@xmlHashUpd
	cmp	DWORD PTR [esi+12], edi
	je	SHORT $LN38@xmlHashUpd
$LN2@xmlHashUpd:

; 685  : 		 insert = insert->next) {

	mov	esi, DWORD PTR [esi]
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LL4@xmlHashUpd
$LN47@xmlHashUpd:

; 688  : 		    (insert->name3 == name3)) {
; 689  : 		    if (f)
; 690  : 			f(insert->payload, insert->name);
; 691  : 		    insert->payload = userdata;
; 692  : 		    return(0);
; 693  : 		}
; 694  : 	    }
; 695  : 	    if ((insert->name == name) &&
; 696  : 		(insert->name2 == name2) &&

	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	jne	$LN29@xmlHashUpd
	cmp	DWORD PTR [esi+8], ebx
	jne	$LN29@xmlHashUpd
	cmp	DWORD PTR [esi+12], edi
	jne	$LN29@xmlHashUpd
$LN38@xmlHashUpd:

; 751  :     }
; 752  :     return(0);
; 753  : }

	mov	eax, DWORD PTR _f$[ebp]
	test	eax, eax
	je	SHORT $LN22@xmlHashUpd
	push	ecx
$LN51@xmlHashUpd:
	push	DWORD PTR [esi+16]
	call	eax
	add	esp, 8
$LN22@xmlHashUpd:
	mov	eax, DWORD PTR _userdata$[ebp]
	mov	DWORD PTR [esi+16], eax
$LN34@xmlHashUpd:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlHashUpd:

; 697  : 		(insert->name3 == name3)) {
; 698  : 		if (f)
; 699  : 		    f(insert->payload, insert->name);
; 700  : 		insert->payload = userdata;
; 701  : 		return(0);
; 702  : 	    }
; 703  : 	} else {
; 704  : 	    for (insert = &(table->table[key]); insert->next != NULL;

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN48@xmlHashUpd
	npad	7
$LL7@xmlHashUpd:

; 706  : 		if ((xmlStrEqual(insert->name, name)) &&
; 707  : 		    (xmlStrEqual(insert->name2, name2)) &&

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [esi+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlHashUpd
	push	ebx
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlHashUpd
	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN39@xmlHashUpd
$LN5@xmlHashUpd:

; 705  : 		 insert = insert->next) {

	mov	esi, DWORD PTR [esi]
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LL7@xmlHashUpd
$LN48@xmlHashUpd:

; 708  : 		    (xmlStrEqual(insert->name3, name3))) {
; 709  : 		    if (f)
; 710  : 			f(insert->payload, insert->name);
; 711  : 		    insert->payload = userdata;
; 712  : 		    return(0);
; 713  : 		}
; 714  : 	    }
; 715  : 	    if ((xmlStrEqual(insert->name, name)) &&
; 716  : 		(xmlStrEqual(insert->name2, name2)) &&

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [esi+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN29@xmlHashUpd
	push	ebx
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN29@xmlHashUpd
	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN39@xmlHashUpd
$LN29@xmlHashUpd:

; 729  : 	entry = xmlMalloc(sizeof(xmlHashEntry));

	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _entry$1$[ebp], ecx

; 730  : 	if (entry == NULL)

	test	ecx, ecx
	je	$LN9@xmlHashUpd
	mov	edx, DWORD PTR _table$[ebp]
$LN31@xmlHashUpd:

; 731  : 	     return(-1);
; 732  :     }
; 733  : 
; 734  :     if (table->dict != NULL) {

	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN32@xmlHashUpd

; 735  :         entry->name = (xmlChar *) name;

	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 736  :         entry->name2 = (xmlChar *) name2;

	mov	DWORD PTR [ecx+8], ebx

; 737  :         entry->name3 = (xmlChar *) name3;
; 738  :     } else {

	jmp	SHORT $LN33@xmlHashUpd
$LN39@xmlHashUpd:

; 751  :     }
; 752  :     return(0);
; 753  : }

	mov	eax, DWORD PTR _f$[ebp]
	test	eax, eax
	je	$LN22@xmlHashUpd
	push	DWORD PTR [esi+4]
	jmp	$LN51@xmlHashUpd
$LN32@xmlHashUpd:

; 739  : 	entry->name = xmlStrdup(name);

	push	DWORD PTR _name$[ebp]
	call	_xmlStrdup
	mov	ecx, DWORD PTR _entry$1$[ebp]

; 740  : 	entry->name2 = xmlStrdup(name2);

	push	ebx
	mov	DWORD PTR [ecx+4], eax
	call	_xmlStrdup
	mov	ecx, DWORD PTR _entry$1$[ebp]

; 741  : 	entry->name3 = xmlStrdup(name3);

	push	edi
	mov	DWORD PTR [ecx+8], eax
	call	_xmlStrdup
	mov	ecx, DWORD PTR _entry$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _table$[ebp]
	mov	edi, eax
$LN33@xmlHashUpd:

; 742  :     }
; 743  :     entry->payload = userdata;

	mov	eax, DWORD PTR _userdata$[ebp]
	mov	DWORD PTR [ecx+12], edi
	mov	DWORD PTR [ecx+16], eax

; 744  :     entry->next = NULL;

	mov	DWORD PTR [ecx], 0

; 745  :     entry->valid = 1;

	mov	DWORD PTR [ecx+20], 1

; 746  :     table->nbElems++;

	inc	DWORD PTR [edx+8]

; 747  : 
; 748  : 
; 749  :     if (insert != NULL) {

	test	esi, esi
	je	$LN34@xmlHashUpd

; 750  : 	insert->next = entry;

	pop	edi
	mov	DWORD PTR [esi], ecx

; 751  :     }
; 752  :     return(0);
; 753  : }

	xor	eax, eax
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashUpdateEntry3 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashAddEntry3
_TEXT	SEGMENT
_oldsize$1$ = -8					; size = 4
_len$1$ = -8						; size = 4
tv870 = -4						; size = 4
tv866 = -4						; size = 4
tv853 = -4						; size = 4
_entry$1$ = -4						; size = 4
_oldtable$1$ = 8					; size = 4
_name2$1$ = 8						; size = 4
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_name3$ = 20						; size = 4
_userdata$ = 24						; size = 4
_xmlHashAddEntry3 PROC					; COMDAT

; 531  : 		 void *userdata) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _table$[ebp]
	mov	DWORD PTR _len$1$[ebp], 0
	test	edi, edi
	je	$LN9@xmlHashAdd

; 532  :     unsigned long key, len = 0;
; 533  :     xmlHashEntryPtr entry;
; 534  :     xmlHashEntryPtr insert;
; 535  : 
; 536  :     if ((table == NULL) || (name == NULL))

	mov	ebx, DWORD PTR _name$[ebp]
	test	ebx, ebx
	je	$LN9@xmlHashAdd

; 537  : 	return(-1);
; 538  : 
; 539  :     /*
; 540  :      * If using a dict internalize if needed
; 541  :      */
; 542  :     if (table->dict) {

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	$LN76@xmlHashAdd

; 543  :         if (!xmlDictOwns(table->dict, name)) {

	push	ebx
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlHashAdd

; 544  : 	    name = xmlDictLookup(table->dict, name, -1);

	push	-1
	push	ebx
	push	DWORD PTR [edi+12]
	call	_xmlDictLookup
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _name$[ebp], ebx

; 545  : 	    if (name == NULL)

	test	ebx, ebx
	je	SHORT $LN9@xmlHashAdd
$LN12@xmlHashAdd:

; 546  : 	        return(-1);
; 547  : 	}
; 548  :         if ((name2 != NULL) && (!xmlDictOwns(table->dict, name2))) {

	mov	esi, DWORD PTR _name2$[ebp]
	mov	DWORD PTR _name2$1$[ebp], esi
	test	esi, esi
	je	SHORT $LN14@xmlHashAdd
	push	esi
	push	DWORD PTR [edi+12]
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlHashAdd

; 549  : 	    name2 = xmlDictLookup(table->dict, name2, -1);

	push	-1
	push	esi
	push	DWORD PTR [edi+12]
	call	_xmlDictLookup
	mov	esi, eax
	mov	DWORD PTR _name2$1$[ebp], eax
	add	esp, 12					; 0000000cH

; 550  : 	    if (name2 == NULL)

	test	esi, esi
	je	SHORT $LN9@xmlHashAdd
$LN14@xmlHashAdd:

; 551  : 	        return(-1);
; 552  : 	}
; 553  :         if ((name3 != NULL) && (!xmlDictOwns(table->dict, name3))) {

	mov	ebx, DWORD PTR _name3$[ebp]
	test	ebx, ebx
	je	SHORT $LN16@xmlHashAdd
	push	ebx
	push	DWORD PTR [edi+12]
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@xmlHashAdd

; 554  : 	    name3 = xmlDictLookup(table->dict, name3, -1);

	push	-1
	push	ebx
	push	DWORD PTR [edi+12]
	call	_xmlDictLookup
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 555  : 	    if (name3 == NULL)

	test	ebx, ebx
	jne	SHORT $LN16@xmlHashAdd
$LN9@xmlHashAdd:
	pop	edi

; 625  : 
; 626  :     return(0);
; 627  : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN76@xmlHashAdd:

; 537  : 	return(-1);
; 538  : 
; 539  :     /*
; 540  :      * If using a dict internalize if needed
; 541  :      */
; 542  :     if (table->dict) {

	mov	esi, DWORD PTR _name2$[ebp]
	mov	ebx, DWORD PTR _name3$[ebp]
	mov	DWORD PTR _name2$1$[ebp], esi
$LN16@xmlHashAdd:

; 556  : 	        return(-1);
; 557  : 	}
; 558  :     }
; 559  : 
; 560  :     /*
; 561  :      * Check for duplicate and insertion location.
; 562  :      */
; 563  :     key = xmlHashComputeKey(table, name, name2, name3);

	push	ebx
	push	esi
	push	DWORD PTR _name$[ebp]
	push	edi
	call	_xmlHashComputeKey
	add	esp, 16					; 00000010H

; 564  :     if (table->table[key].valid == 0) {

	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 3
	add	ecx, DWORD PTR [edi]
	mov	DWORD PTR _entry$1$[ebp], ecx
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN17@xmlHashAdd

; 565  : 	insert = NULL;

	xor	esi, esi

; 591  : 		(xmlStrEqual(insert->name3, name3)))
; 592  : 		return(-1);
; 593  : 	}
; 594  :     }
; 595  : 
; 596  :     if (insert == NULL) {
; 597  : 	entry = &(table->table[key]);
; 598  :     } else {

	jmp	$LN75@xmlHashAdd
$LN17@xmlHashAdd:

; 566  :     } else {
; 567  :         if (table->dict) {

	cmp	DWORD PTR [edi+12], 0
	mov	esi, ecx
	je	SHORT $LN19@xmlHashAdd

; 568  : 	    for (insert = &(table->table[key]); insert->next != NULL;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	mov	ecx, DWORD PTR _name$[ebp]
	mov	DWORD PTR tv870[ebp], eax
	mov	eax, DWORD PTR _name2$1$[ebp]
	je	SHORT $LN3@xmlHashAdd
	xor	edx, edx
	npad	2
$LL4@xmlHashAdd:

; 570  : 		if ((insert->name == name) &&
; 571  : 		    (insert->name2 == name2) &&

	cmp	DWORD PTR [esi+4], ecx
	jne	SHORT $LN21@xmlHashAdd
	cmp	DWORD PTR [esi+8], eax
	jne	SHORT $LN21@xmlHashAdd
	cmp	DWORD PTR [esi+12], ebx
	je	SHORT $LN9@xmlHashAdd
$LN21@xmlHashAdd:

; 569  : 		 insert = insert->next) {

	mov	esi, DWORD PTR tv870[ebp]

; 572  : 		    (insert->name3 == name3))
; 573  : 		    return(-1);
; 574  : 		len++;

	inc	edx
	mov	DWORD PTR _len$1$[ebp], edx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR tv870[ebp], ecx
	mov	ecx, DWORD PTR _name$[ebp]
	jne	SHORT $LL4@xmlHashAdd
$LN3@xmlHashAdd:

; 575  : 	    }
; 576  : 	    if ((insert->name == name) &&
; 577  : 		(insert->name2 == name2) &&

	cmp	DWORD PTR [esi+4], ecx
	jne	$LN25@xmlHashAdd
	cmp	DWORD PTR [esi+8], eax
	jne	$LN25@xmlHashAdd
	cmp	DWORD PTR [esi+12], ebx
	jne	$LN25@xmlHashAdd

; 625  : 
; 626  :     return(0);
; 627  : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlHashAdd:

; 578  : 		(insert->name3 == name3))
; 579  : 		return(-1);
; 580  : 	} else {
; 581  : 	    for (insert = &(table->table[key]); insert->next != NULL;

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN6@xmlHashAdd
	npad	4
$LL7@xmlHashAdd:

; 583  : 		if ((xmlStrEqual(insert->name, name)) &&
; 584  : 		    (xmlStrEqual(insert->name2, name2)) &&

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [esi+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xmlHashAdd
	push	DWORD PTR _name2$1$[ebp]
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xmlHashAdd
	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN9@xmlHashAdd
$LN23@xmlHashAdd:

; 582  : 		 insert = insert->next) {

	mov	esi, DWORD PTR [esi]

; 585  : 		    (xmlStrEqual(insert->name3, name3)))
; 586  : 		    return(-1);
; 587  : 		len++;

	inc	DWORD PTR _len$1$[ebp]
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LL7@xmlHashAdd
$LN6@xmlHashAdd:

; 588  : 	    }
; 589  : 	    if ((xmlStrEqual(insert->name, name)) &&
; 590  : 		(xmlStrEqual(insert->name2, name2)) &&

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [esi+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlHashAdd
	push	DWORD PTR _name2$1$[ebp]
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlHashAdd
	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN9@xmlHashAdd
$LN25@xmlHashAdd:

; 599  : 	entry = xmlMalloc(sizeof(xmlHashEntry));

	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _entry$1$[ebp], ecx

; 600  : 	if (entry == NULL)

	test	ecx, ecx
	je	$LN9@xmlHashAdd
$LN75@xmlHashAdd:

; 601  : 	     return(-1);
; 602  :     }
; 603  : 
; 604  :     if (table->dict != NULL) {

	cmp	DWORD PTR [edi+12], 0
	je	SHORT $LN28@xmlHashAdd

; 605  :         entry->name = (xmlChar *) name;

	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 606  :         entry->name2 = (xmlChar *) name2;

	mov	eax, DWORD PTR _name2$1$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 607  :         entry->name3 = (xmlChar *) name3;
; 608  :     } else {

	jmp	SHORT $LN29@xmlHashAdd
$LN28@xmlHashAdd:

; 609  : 	entry->name = xmlStrdup(name);

	push	DWORD PTR _name$[ebp]
	call	_xmlStrdup
	mov	ecx, DWORD PTR _entry$1$[ebp]

; 610  : 	entry->name2 = xmlStrdup(name2);

	push	DWORD PTR _name2$1$[ebp]
	mov	DWORD PTR [ecx+4], eax
	call	_xmlStrdup
	mov	ecx, DWORD PTR _entry$1$[ebp]

; 611  : 	entry->name3 = xmlStrdup(name3);

	push	ebx
	mov	DWORD PTR [ecx+8], eax
	call	_xmlStrdup
	mov	ecx, DWORD PTR _entry$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	ebx, eax
$LN29@xmlHashAdd:

; 612  :     }
; 613  :     entry->payload = userdata;

	mov	eax, DWORD PTR _userdata$[ebp]
	mov	DWORD PTR [ecx+12], ebx
	mov	DWORD PTR [ecx+16], eax

; 614  :     entry->next = NULL;

	mov	DWORD PTR [ecx], 0

; 615  :     entry->valid = 1;

	mov	DWORD PTR [ecx+20], 1

; 616  : 
; 617  : 
; 618  :     if (insert != NULL)

	test	esi, esi
	je	SHORT $LN30@xmlHashAdd

; 619  : 	insert->next = entry;

	mov	DWORD PTR [esi], ecx
$LN30@xmlHashAdd:

; 620  : 
; 621  :     table->nbElems++;

	inc	DWORD PTR [edi+8]

; 622  : 
; 623  :     if (len > MAX_HASH_LEN)

	cmp	DWORD PTR _len$1$[ebp], 8
	jbe	$LN33@xmlHashAdd

; 624  : 	xmlHashGrow(table, MAX_HASH_LEN * table->size);

	mov	ebx, DWORD PTR [edi+4]
	mov	DWORD PTR _oldsize$1$[ebp], ebx
	lea	esi, DWORD PTR [ebx*8]

; 240  :     if (size < 8)

	lea	eax, DWORD PTR [esi-8]
	cmp	eax, 16376				; 00003ff8H
	ja	$LN33@xmlHashAdd

; 241  :         return(-1);
; 242  :     if (size > 8 * 2048)
; 243  : 	return(-1);
; 244  : 
; 245  :     oldsize = table->size;
; 246  :     oldtable = table->table;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _oldtable$1$[ebp], eax

; 247  :     if (oldtable == NULL)

	test	eax, eax
	je	$LN33@xmlHashAdd

; 248  :         return(-1);
; 249  : 
; 250  :     table->table = xmlMalloc(size * sizeof(xmlHashEntry));

	lea	eax, DWORD PTR [esi+esi*2]
	shl	eax, 3
	push	eax
	mov	DWORD PTR tv866[ebp], eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi], eax

; 251  :     if (table->table == NULL) {

	test	eax, eax
	jne	SHORT $LN46@xmlHashAdd

; 252  : 	table->table = oldtable;

	mov	esi, DWORD PTR _oldtable$1$[ebp]
	mov	DWORD PTR [edi], esi
	pop	edi

; 625  : 
; 626  :     return(0);
; 627  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@xmlHashAdd:

; 255  :     memset(table->table, 0, size * sizeof(xmlHashEntry));

	push	DWORD PTR tv866[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 256  :     table->size = size;

	mov	DWORD PTR [edi+4], esi

; 257  : 
; 258  :     /*	If the two loops are merged, there would be situations where
; 259  : 	a new entry needs to allocated and data copied into it from
; 260  : 	the main table. So instead, we run through the array twice, first
; 261  : 	copying all the elements in the main array (where we can't get
; 262  : 	conflicts) and then the rest, so we only free (and don't allocate)
; 263  :     */
; 264  :     for (i = 0; i < oldsize; i++) {

	test	ebx, ebx
	jle	$LN38@xmlHashAdd

; 253  : 	return(-1);
; 254  :     }
; 255  :     memset(table->table, 0, size * sizeof(xmlHashEntry));

	mov	esi, DWORD PTR _oldtable$1$[ebp]
	add	esi, 12					; 0000000cH
$LL36@xmlHashAdd:

; 265  : 	if (oldtable[i].valid == 0)

	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN34@xmlHashAdd

; 266  : 	    continue;
; 267  : 	key = xmlHashComputeKey(table, oldtable[i].name, oldtable[i].name2,

	push	DWORD PTR [esi]
	push	DWORD PTR [esi-4]
	push	DWORD PTR [esi-8]
	push	edi
	call	_xmlHashComputeKey

; 268  : 				oldtable[i].name3);
; 269  : 	memcpy(&(table->table[key]), &(oldtable[i]), sizeof(xmlHashEntry));

	movups	xmm0, XMMWORD PTR [esi-12]
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edi]
	movups	XMMWORD PTR [eax+ecx*8], xmm0
	movq	xmm0, QWORD PTR [esi+4]
	movq	QWORD PTR [eax+ecx*8+16], xmm0

; 270  : 	table->table[key].next = NULL;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+ecx*8], 0
$LN34@xmlHashAdd:

; 257  : 
; 258  :     /*	If the two loops are merged, there would be situations where
; 259  : 	a new entry needs to allocated and data copied into it from
; 260  : 	the main table. So instead, we run through the array twice, first
; 261  : 	copying all the elements in the main array (where we can't get
; 262  : 	conflicts) and then the rest, so we only free (and don't allocate)
; 263  :     */
; 264  :     for (i = 0; i < oldsize; i++) {

	add	esi, 24					; 00000018H
	sub	ebx, 1
	jne	SHORT $LL36@xmlHashAdd

; 271  :     }
; 272  : 
; 273  :     for (i = 0; i < oldsize; i++) {

	mov	eax, DWORD PTR _oldtable$1$[ebp]
	mov	ecx, DWORD PTR _oldsize$1$[ebp]
	mov	DWORD PTR tv853[ebp], eax
	npad	2
$LL39@xmlHashAdd:

; 274  : 	iter = oldtable[i].next;

	mov	esi, DWORD PTR [eax]

; 275  : 	while (iter) {

	test	esi, esi
	je	SHORT $LN37@xmlHashAdd
$LL40@xmlHashAdd:

; 276  : 	    next = iter->next;
; 277  : 
; 278  : 	    /*
; 279  : 	     * put back the entry in the new table
; 280  : 	     */
; 281  : 
; 282  : 	    key = xmlHashComputeKey(table, iter->name, iter->name2,

	push	DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+4]
	push	edi
	call	_xmlHashComputeKey
	add	esp, 16					; 00000010H

; 283  : 		                    iter->name3);
; 284  : 	    if (table->table[key].valid == 0) {

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edi]
	shl	ecx, 3
	add	eax, ecx
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN48@xmlHashAdd

; 285  : 		memcpy(&(table->table[key]), iter, sizeof(xmlHashEntry));

	movups	xmm0, XMMWORD PTR [esi]

; 286  : 		table->table[key].next = NULL;
; 287  : 		xmlFree(iter);

	push	esi
	movups	XMMWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR [esi+16]
	movq	QWORD PTR [eax+16], xmm0
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx+eax], 0
	call	DWORD PTR _xmlFree
	add	esp, 4

; 288  : 	    } else {

	jmp	SHORT $LN49@xmlHashAdd
$LN48@xmlHashAdd:

; 289  : 		iter->next = table->table[key].next;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax

; 290  : 		table->table[key].next = iter;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx+eax], esi
$LN49@xmlHashAdd:

; 291  : 	    }
; 292  : 
; 293  : #ifdef DEBUG_GROW
; 294  : 	    nbElem++;
; 295  : #endif
; 296  : 
; 297  : 	    iter = next;

	mov	esi, ebx
	test	ebx, ebx
	jne	SHORT $LL40@xmlHashAdd
	mov	eax, DWORD PTR tv853[ebp]
	mov	ecx, DWORD PTR _oldsize$1$[ebp]
$LN37@xmlHashAdd:

; 271  :     }
; 272  : 
; 273  :     for (i = 0; i < oldsize; i++) {

	add	eax, 24					; 00000018H
	sub	ecx, 1
	mov	DWORD PTR tv853[ebp], eax
	mov	DWORD PTR _oldsize$1$[ebp], ecx
	jne	SHORT $LL39@xmlHashAdd
$LN38@xmlHashAdd:

; 298  : 	}
; 299  :     }
; 300  : 
; 301  :     xmlFree(oldtable);

	push	DWORD PTR _oldtable$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN33@xmlHashAdd:
	pop	edi

; 625  : 
; 626  :     return(0);
; 627  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashAddEntry3 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashUpdateEntry2
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_userdata$ = 20						; size = 4
_f$ = 24						; size = 4
_xmlHashUpdateEntry2 PROC				; COMDAT

; 445  : 		   xmlHashDeallocator f) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _f$[ebp]
	push	DWORD PTR _userdata$[ebp]
	push	0
	push	DWORD PTR _name2$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _table$[ebp]
	call	_xmlHashUpdateEntry3
	add	esp, 24					; 00000018H

; 446  :     return(xmlHashUpdateEntry3(table, name, name2, NULL, userdata, f));
; 447  : }

	pop	ebp
	ret	0
_xmlHashUpdateEntry2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashAddEntry2
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_userdata$ = 20						; size = 4
_xmlHashAddEntry2 PROC					; COMDAT

; 405  : 	        const xmlChar *name2, void *userdata) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _userdata$[ebp]
	push	0
	push	DWORD PTR _name2$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _table$[ebp]
	call	_xmlHashAddEntry3
	add	esp, 20					; 00000014H

; 406  :     return(xmlHashAddEntry3(table, name, name2, NULL, userdata));
; 407  : }

	pop	ebp
	ret	0
_xmlHashAddEntry2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashUpdateEntry
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_userdata$ = 16						; size = 4
_f$ = 20						; size = 4
_xmlHashUpdateEntry PROC				; COMDAT

; 424  : 	           void *userdata, xmlHashDeallocator f) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _f$[ebp]
	push	DWORD PTR _userdata$[ebp]
	push	0
	push	0
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _table$[ebp]
	call	_xmlHashUpdateEntry3
	add	esp, 24					; 00000018H

; 425  :     return(xmlHashUpdateEntry3(table, name, NULL, NULL, userdata, f));
; 426  : }

	pop	ebp
	ret	0
_xmlHashUpdateEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashAddEntry
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_userdata$ = 16						; size = 4
_xmlHashAddEntry PROC					; COMDAT

; 387  : xmlHashAddEntry(xmlHashTablePtr table, const xmlChar *name, void *userdata) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _userdata$[ebp]
	push	0
	push	0
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _table$[ebp]
	call	_xmlHashAddEntry3
	add	esp, 20					; 00000014H

; 388  :     return(xmlHashAddEntry3(table, name, NULL, NULL, userdata));
; 389  : }

	pop	ebp
	ret	0
_xmlHashAddEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashDefaultDeallocator
_TEXT	SEGMENT
_entry$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlHashDefaultDeallocator PROC				; COMDAT

; 371  : xmlHashDefaultDeallocator(void *entry, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _entry$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 372  :     xmlFree(entry);
; 373  : }

	pop	ebp
	ret	0
_xmlHashDefaultDeallocator ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashFree
_TEXT	SEGMENT
tv294 = -12						; size = 4
_i$1$ = -8						; size = 4
_inside_table$1$ = -4					; size = 4
_nbElems$1$ = 8						; size = 4
_table$ = 8						; size = 4
_f$ = 12						; size = 4
_xmlHashFree PROC					; COMDAT

; 320  : xmlHashFree(xmlHashTablePtr table, xmlHashDeallocator f) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __776982E1_hash@c
	push	ebx
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _table$[ebp]
	test	ebx, ebx
	je	$LN1@xmlHashFre

; 321  :     int i;
; 322  :     xmlHashEntryPtr iter;
; 323  :     xmlHashEntryPtr next;
; 324  :     int inside_table = 0;
; 325  :     int nbElems;
; 326  : 
; 327  :     if (table == NULL)
; 328  : 	return;
; 329  :     if (table->table) {

	cmp	DWORD PTR [ebx], 0
	je	$LN8@xmlHashFre

; 330  : 	nbElems = table->nbElems;

	mov	eax, DWORD PTR [ebx+8]

; 331  : 	for(i = 0; (i < table->size) && (nbElems > 0); i++) {

	xor	edx, edx
	mov	DWORD PTR _nbElems$1$[ebp], eax
	mov	DWORD PTR _i$1$[ebp], edx
	cmp	DWORD PTR [ebx+4], edx
	jle	$LN26@xmlHashFre

; 330  : 	nbElems = table->nbElems;

	mov	ecx, DWORD PTR _f$[ebp]
	push	edi
	xor	edi, edi
	mov	DWORD PTR tv294[ebp], edi
	push	esi
$LL4@xmlHashFre:

; 331  : 	for(i = 0; (i < table->size) && (nbElems > 0); i++) {

	test	eax, eax
	jle	$LN28@xmlHashFre

; 332  : 	    iter = &(table->table[i]);

	mov	esi, DWORD PTR [ebx]
	add	esi, edi

; 333  : 	    if (iter->valid == 0)

	cmp	DWORD PTR [esi+20], 0
	je	$LN2@xmlHashFre

; 334  : 		continue;
; 335  : 	    inside_table = 1;

	mov	DWORD PTR _inside_table$1$[ebp], 1
$LL5@xmlHashFre:

; 336  : 	    while (iter) {
; 337  : 		next = iter->next;

	mov	edi, DWORD PTR [esi]

; 338  : 		if ((f != NULL) && (iter->payload != NULL))

	test	ecx, ecx
	je	SHORT $LN10@xmlHashFre
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN10@xmlHashFre

; 339  : 		    f(iter->payload, iter->name);

	push	DWORD PTR [esi+4]
	push	eax
	call	ecx
	add	esp, 8
$LN10@xmlHashFre:

; 340  : 		if (table->dict == NULL) {

	cmp	DWORD PTR [ebx+12], 0
	jne	SHORT $LN14@xmlHashFre

; 341  : 		    if (iter->name)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN12@xmlHashFre

; 342  : 			xmlFree(iter->name);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlHashFre:

; 343  : 		    if (iter->name2)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN13@xmlHashFre

; 344  : 			xmlFree(iter->name2);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlHashFre:

; 345  : 		    if (iter->name3)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN14@xmlHashFre

; 346  : 			xmlFree(iter->name3);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlHashFre:

; 347  : 		}
; 348  : 		iter->payload = NULL;
; 349  : 		if (!inside_table)

	cmp	DWORD PTR _inside_table$1$[ebp], 0
	mov	DWORD PTR [esi+16], 0
	jne	SHORT $LN15@xmlHashFre

; 350  : 		    xmlFree(iter);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlHashFre:

; 351  : 		nbElems--;

	mov	eax, DWORD PTR _nbElems$1$[ebp]

; 352  : 		inside_table = 0;
; 353  : 		iter = next;

	mov	esi, edi
	mov	ecx, DWORD PTR _f$[ebp]
	dec	eax
	mov	DWORD PTR _nbElems$1$[ebp], eax
	mov	DWORD PTR _inside_table$1$[ebp], 0
	test	edi, edi
	jne	SHORT $LL5@xmlHashFre
	mov	edx, DWORD PTR _i$1$[ebp]
	mov	edi, DWORD PTR tv294[ebp]
$LN2@xmlHashFre:

; 331  : 	for(i = 0; (i < table->size) && (nbElems > 0); i++) {

	inc	edx
	add	edi, 24					; 00000018H
	mov	DWORD PTR _i$1$[ebp], edx
	mov	DWORD PTR tv294[ebp], edi
	cmp	edx, DWORD PTR [ebx+4]
	jl	$LL4@xmlHashFre
$LN28@xmlHashFre:
	pop	esi
	pop	edi
$LN26@xmlHashFre:

; 354  : 	    }
; 355  : 	}
; 356  : 	xmlFree(table->table);

	push	DWORD PTR [ebx]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlHashFre:

; 357  :     }
; 358  :     if (table->dict)

	mov	eax, DWORD PTR [ebx+12]
	test	eax, eax
	je	SHORT $LN16@xmlHashFre

; 359  :         xmlDictFree(table->dict);

	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN16@xmlHashFre:

; 360  :     xmlFree(table);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlHashFre:
	pop	ebx

; 361  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashCreateDict
_TEXT	SEGMENT
_size$ = 8						; size = 4
_dict$ = 12						; size = 4
_xmlHashCreateDict PROC					; COMDAT

; 208  : xmlHashCreateDict(int size, xmlDictPtr dict) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _size$[ebp]
	call	_xmlHashCreate
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN2@xmlHashCre

; 209  :     xmlHashTablePtr table;
; 210  : 
; 211  :     table = xmlHashCreate(size);
; 212  :     if (table != NULL) {
; 213  :         table->dict = dict;
; 214  : 	xmlDictReference(dict);

	mov	ecx, DWORD PTR _dict$[ebp]
	push	ecx
	mov	DWORD PTR [esi+12], ecx
	call	_xmlDictReference
	add	esp, 4

; 215  :     }
; 216  :     return(table);

	mov	eax, esi
$LN2@xmlHashCre:
	pop	esi

; 217  : }

	pop	ebp
	ret	0
_xmlHashCreateDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashCreate
_TEXT	SEGMENT
_size$ = 8						; size = 4
_xmlHashCreate PROC					; COMDAT

; 174  : xmlHashCreate(int size) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _size$[ebp]
	mov	edi, 256				; 00000100H
	test	eax, eax
	push	16					; 00000010H
	cmovg	edi, eax
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN3@xmlHashCre

; 175  :     xmlHashTablePtr table;
; 176  : 
; 177  :     if (size <= 0)
; 178  :         size = 256;
; 179  : 
; 180  :     table = xmlMalloc(sizeof(xmlHashTable));
; 181  :     if (table) {
; 182  :         table->dict = NULL;
; 183  :         table->size = size;
; 184  : 	table->nbElems = 0;
; 185  :         table->table = xmlMalloc(size * sizeof(xmlHashEntry));

	mov	DWORD PTR [esi+4], edi
	lea	edi, DWORD PTR [edi+edi*2]
	shl	edi, 3
	push	edi
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+8], 0
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 186  :         if (table->table) {

	test	eax, eax
	je	SHORT $LN4@xmlHashCre

; 187  : 	    memset(table->table, 0, size * sizeof(xmlHashEntry));

	push	edi
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 188  : #ifdef HASH_RANDOMIZATION
; 189  :             table->random_seed = __xmlRandom();
; 190  : #endif
; 191  : 	    return(table);

	mov	eax, esi
	pop	edi

; 196  : }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlHashCre:

; 192  :         }
; 193  :         xmlFree(table);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlHashCre:

; 194  :     }
; 195  :     return(NULL);

	pop	edi
	xor	eax, eax

; 196  : }

	pop	esi
	pop	ebp
	ret	0
_xmlHashCreate ENDP
_TEXT	ENDS
END
