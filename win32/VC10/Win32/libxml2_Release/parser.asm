; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\parser.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_xmlParserMaxDepth
PUBLIC	??_C@_0P@HPOCOPDB@xml?9stylesheet@		; `string'
PUBLIC	??_C@_09OBPBGIJC@xml?9model@			; `string'
_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlXPathNAN:QWORD
COMM	_xmlXPathPINF:QWORD
COMM	_xmlXPathNINF:QWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__7B7A869E_ctype@h DB 01H
__A40A425D_stat@h DB 01H
__B9AC27D5_parser@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_09OBPBGIJC@xml?9model@
CONST	SEGMENT
??_C@_09OBPBGIJC@xml?9model@ DB 'xml-model', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HPOCOPDB@xml?9stylesheet@
CONST	SEGMENT
??_C@_0P@HPOCOPDB@xml?9stylesheet@ DB 'xml-stylesheet', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_xmlParserMaxDepth DD 0100H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_snprintf
PUBLIC	_xmlInitParser
PUBLIC	_xmlCleanupParser
PUBLIC	_xmlParseDoc
PUBLIC	_xmlParseFile
PUBLIC	_xmlParseMemory
PUBLIC	_xmlStopParser
PUBLIC	_xmlRecoverDoc
PUBLIC	_xmlRecoverMemory
PUBLIC	_xmlRecoverFile
PUBLIC	_xmlParseDocument
PUBLIC	_xmlParseExtParsedEnt
PUBLIC	_xmlSAXUserParseFile
PUBLIC	_xmlSAXUserParseMemory
PUBLIC	_xmlSAXParseDoc
PUBLIC	_xmlSAXParseMemory
PUBLIC	_xmlSAXParseMemoryWithData
PUBLIC	_xmlSAXParseFile
PUBLIC	_xmlSAXParseFileWithData
PUBLIC	_xmlSAXParseEntity
PUBLIC	_xmlParseEntity
PUBLIC	_xmlSAXParseDTD
PUBLIC	_xmlParseDTD
PUBLIC	_xmlIOParseDTD
PUBLIC	_xmlParseBalancedChunkMemory
PUBLIC	_xmlParseInNodeContext
PUBLIC	_xmlParseBalancedChunkMemoryRecover
PUBLIC	_xmlParseExternalEntity
PUBLIC	_xmlParseCtxtExternalEntity
PUBLIC	_xmlSetupParserForBuffer
PUBLIC	_xmlCreateDocParserCtxt
PUBLIC	_xmlCreatePushParserCtxt
PUBLIC	_xmlParseChunk
PUBLIC	_xmlCreateIOParserCtxt
PUBLIC	_xmlCtxtReset
PUBLIC	_xmlCtxtResetPush
PUBLIC	_xmlCtxtUseOptions
PUBLIC	_xmlReadDoc
PUBLIC	_xmlReadFile
PUBLIC	_xmlReadMemory
PUBLIC	_xmlReadFd
PUBLIC	_xmlReadIO
PUBLIC	_xmlCtxtReadDoc
PUBLIC	_xmlCtxtReadFile
PUBLIC	_xmlCtxtReadMemory
PUBLIC	_xmlCtxtReadFd
PUBLIC	_xmlCtxtReadIO
PUBLIC	_xmlHasFeature
PUBLIC	_xmlCreateFileParserCtxt
PUBLIC	_xmlCreateURLParserCtxt
PUBLIC	_xmlCreateMemoryParserCtxt
PUBLIC	_xmlCreateEntityParserCtxt
PUBLIC	_xmlPushInput
PUBLIC	_xmlPopInput
PUBLIC	_xmlSplitQName
PUBLIC	_xmlParseName
PUBLIC	_xmlParseNmtoken
PUBLIC	_xmlParseEntityValue
PUBLIC	_xmlParseAttValue
PUBLIC	_xmlParseSystemLiteral
PUBLIC	_xmlParsePubidLiteral
PUBLIC	_xmlParseCharData
PUBLIC	_xmlParseExternalID
PUBLIC	_xmlParseComment
PUBLIC	_xmlParsePITarget
PUBLIC	_xmlParsePI
PUBLIC	_xmlParseNotationDecl
PUBLIC	_xmlParseEntityDecl
PUBLIC	_xmlParseDefaultDecl
PUBLIC	_xmlParseNotationType
PUBLIC	_xmlParseEnumerationType
PUBLIC	_xmlParseEnumeratedType
PUBLIC	_xmlParseAttributeType
PUBLIC	_xmlParseAttributeListDecl
PUBLIC	_xmlParseElementMixedContentDecl
PUBLIC	_xmlParseElementChildrenContentDecl
PUBLIC	_xmlParseElementContentDecl
PUBLIC	_xmlParseElementDecl
PUBLIC	_xmlParseMarkupDecl
PUBLIC	_xmlParseCharRef
PUBLIC	_xmlParseEntityRef
PUBLIC	_xmlParseReference
PUBLIC	_xmlParsePEReference
PUBLIC	_xmlParseDocTypeDecl
PUBLIC	_xmlParseAttribute
PUBLIC	_xmlParseStartTag
PUBLIC	_xmlParseEndTag
PUBLIC	_xmlParseCDSect
PUBLIC	_xmlParseContent
PUBLIC	_xmlParseElement
PUBLIC	_xmlParseVersionNum
PUBLIC	_xmlParseVersionInfo
PUBLIC	_xmlParseEncName
PUBLIC	_xmlParseEncodingDecl
PUBLIC	_xmlParseSDDecl
PUBLIC	_xmlParseXMLDecl
PUBLIC	_xmlParseTextDecl
PUBLIC	_xmlParseMisc
PUBLIC	_xmlParseExternalSubset
PUBLIC	_xmlStringDecodeEntities
PUBLIC	_xmlStringLenDecodeEntities
PUBLIC	_nodePush
PUBLIC	_nodePop
PUBLIC	_inputPush
PUBLIC	_inputPop
PUBLIC	_namePop
PUBLIC	_namePush
PUBLIC	_xmlSkipBlankChars
PUBLIC	_xmlParserHandlePEReference
PUBLIC	_xmlCheckLanguageID
PUBLIC	_xmlSetEntityReferenceFunc
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BI@LJKBJNKP@Attribute?5?$CFs?5redefined?6@ ; `string'
PUBLIC	??_C@_0BL@GJOEMOIC@Attribute?5?$CFs?3?$CFs?5redefined?6@ ; `string'
PUBLIC	??_C@_0CD@IIBKOMHK@CharRef?3?5invalid?5hexadecimal?5va@ ; `string'
PUBLIC	??_C@_0BP@DEJKBBIB@CharRef?3?5invalid?5decimal?5value@ ; `string'
PUBLIC	??_C@_0BH@OCLALBPG@CharRef?3?5invalid?5value@	; `string'
PUBLIC	??_C@_0P@LPIEGNHB@internal?5error@		; `string'
PUBLIC	??_C@_0BP@MALDLPDI@PEReference?5at?5end?5of?5document@ ; `string'
PUBLIC	??_C@_0BG@GLMIGPKG@PEReference?5in?5prolog@	; `string'
PUBLIC	??_C@_0BG@JMKGIIGE@PEReference?5in?5epilog@	; `string'
PUBLIC	??_C@_0BF@DCHKIALM@PEReference?3?5no?5name@	; `string'
PUBLIC	??_C@_0BL@PFALGNCI@PEReference?3?5expecting?5?8?$DL?8@ ; `string'
PUBLIC	??_C@_0CC@LFHGNGFD@Detected?5an?5entity?5reference?5lo@ ; `string'
PUBLIC	??_C@_0BN@DPACNJHE@EntityValue?3?5?$CC?5or?5?8?5expected@ ; `string'
PUBLIC	??_C@_0CK@GAJOCPOL@PEReferences?5forbidden?5in?5inter@ ; `string'
PUBLIC	??_C@_0BK@ELBMECGA@AttValue?3?5?$CC?5or?5?8?5expected@ ; `string'
PUBLIC	??_C@_0CP@FNIFNHDI@Unescaped?5?8?$DM?8?5not?5allowed?5in?5at@ ; `string'
PUBLIC	??_C@_0BO@NINNHDOL@SystemLiteral?5?$CC?5or?5?8?5expected@ ; `string'
PUBLIC	??_C@_0CP@PIPOCKJD@Unfinished?5System?5or?5Public?5ID?5@ ; `string'
PUBLIC	??_C@_0CG@PLPMIKHI@Sequence?5?8?$FN?$FN?$DO?8?5not?5allowed?5in?5c@ ; `string'
PUBLIC	??_C@_0CF@GDPMMHJJ@SYSTEM?5or?5PUBLIC?0?5the?5URI?5is?5mi@ ; `string'
PUBLIC	??_C@_0CJ@ICNPKBIN@PUBLIC?0?5the?5Public?5Identifier?5i@ ; `string'
PUBLIC	??_C@_0CO@IKEFGBAE@Comment?5must?5not?5contain?5?8?9?9?8?5?$CI@ ; `string'
PUBLIC	??_C@_0BM@HPBPCNCM@xmlParsePI?5?3?5no?5target?5name@ ; `string'
PUBLIC	??_C@_0BA@KMPMBNCM@Invalid?5PI?5name@		; `string'
PUBLIC	??_C@_0BN@HECCFNBP@NOTATION?3?5Name?5expected?5here@ ; `string'
PUBLIC	??_C@_0CL@MHMGOJAD@?8?$DO?8?5required?5to?5close?5NOTATION?5@ ; `string'
PUBLIC	??_C@_0BG@LMNHCPFE@Entity?5value?5required@	; `string'
PUBLIC	??_C@_0BF@DMGJOFPK@Fragment?5not?5allowed@	; `string'
PUBLIC	??_C@_0CK@NNFMCGNH@?8?$CI?8?5required?5to?5start?5ATTLIST?5e@ ; `string'
PUBLIC	??_C@_0CI@EHCBGKID@NmToken?5expected?5in?5ATTLIST?5enu@ ; `string'
PUBLIC	??_C@_0CL@KPIIIINI@?8?$CJ?8?5required?5to?5finish?5ATTLIST?5@ ; `string'
PUBLIC	??_C@_0CI@LOAMKAA@MixedContentDecl?5?3?5?8?$HM?8?5or?5?8?$CJ?$CK?8?5@ ; `string'
PUBLIC	??_C@_0CG@HEHENOGB@MixedContentDecl?5?3?5?8?$CDPCDATA?8?5ex@ ; `string'
PUBLIC	??_C@_0CD@NHADBOBB@ContentDecl?5?3?5Name?5or?5?8?$CI?8?5expec@ ; `string'
PUBLIC	??_C@_0CG@EHNJPHMB@ContentDecl?5?3?5?8?0?8?5?8?$HM?8?5or?5?8?$CJ?8?5ex@ ; `string'
PUBLIC	??_C@_0DN@CEDHFOGD@PEReference?3?5forbidden?5within?5m@ ; `string'
PUBLIC	??_C@_0N@HPGHEIE@expected?5?8?$DO?8@		; `string'
PUBLIC	??_C@_0CF@GGBMHDE@XML?5conditional?5section?5?8?$FL?8?5exp@ ; `string'
PUBLIC	??_C@_0CF@HHCGNGIK@Content?5error?5in?5the?5external?5s@ ; `string'
PUBLIC	??_C@_0DH@JDEKAAA@conditional?5section?5INCLUDE?5or?5@ ; `string'
PUBLIC	??_C@_0CD@OHPJFFIN@XML?5conditional?5section?5not?5clo@ ; `string'
PUBLIC	??_C@_0CC@HHECNJCA@Text?5declaration?5?8?$DM?$DPxml?8?5requir@ ; `string'
PUBLIC	??_C@_0CH@DOCCAFM@parsing?5XML?5declaration?3?5?8?$DP?$DO?8?5e@ ; `string'
PUBLIC	??_C@_0CO@LJALGGHL@external?5parsed?5entities?5cannot@ ; `string'
PUBLIC	??_C@_0BJ@KLEMOBLL@EntityRef?3?5expecting?5?8?$DL?8@ ; `string'
PUBLIC	??_C@_0BO@NIFLODD@DOCTYPE?5improperly?5terminated@ ; `string'
PUBLIC	??_C@_0BH@ELMJBAIC@EndTag?3?5?8?$DM?1?8?5not?5found@ ; `string'
PUBLIC	??_C@_0N@FLAMKNN@expected?5?8?$DN?8@		; `string'
PUBLIC	??_C@_0CD@GLDIEMIA@String?5not?5closed?5expecting?5?$CC?5o@ ; `string'
PUBLIC	??_C@_0CE@EGHHEGNE@String?5not?5started?5expecting?5?8?5@ ; `string'
PUBLIC	??_C@_0BK@CMOJKGNC@Invalid?5XML?5encoding?5name@ ; `string'
PUBLIC	??_C@_0CG@MBLHCBEE@standalone?5accepts?5only?5?8yes?8?5o@ ; `string'
PUBLIC	??_C@_0BC@LDMJLCHP@Document?5is?5empty@		; `string'
PUBLIC	??_C@_0CJ@JKANOFNI@Extra?5content?5at?5the?5end?5of?5the@ ; `string'
PUBLIC	??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@ ; `string'
PUBLIC	??_C@_0DA@BPKCCNLP@extra?5content?5at?5the?5end?5of?5wel@ ; `string'
PUBLIC	??_C@_0CI@FHFOLBEM@Malformed?5declaration?5expecting@ ; `string'
PUBLIC	??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@ ; `string'
PUBLIC	??_C@_0BL@COECCIID@Unregistered?5error?5message@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_03PJHHNEEI@xml@				; `string'
PUBLIC	??_C@_05PPEFOGKI@xmlns@				; `string'
PUBLIC	??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ ; `string'
PUBLIC	??_C@_08OIBPHJGN@external@			; `string'
PUBLIC	??_C@_0BD@KIFBOAFI@Pbm?5popping?5?$CFd?5NS?6@	; `string'
PUBLIC	??_C@_0DL@HADOBDDE@Excessive?5depth?5in?5document?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0BC@BAMNGBKO@Huge?5input?5lookup@		; `string'
PUBLIC	??_C@_0BH@JOKBAJC@cur?5index?5out?5of?5bound@	; `string'
PUBLIC	??_C@_0BC@LEKDBCEK@Popping?5input?5?$CFd?6@	; `string'
PUBLIC	??_C@_0CC@JODEMIEP@Unfinished?5entity?5outside?5the?5D@ ; `string'
PUBLIC	??_C@_08FFIMCMGN@?$CFs?$CI?$CFd?$CJ?3?5@	; `string'
PUBLIC	??_C@_0BK@IPLLKNJK@Pushing?5input?5?$CFd?5?3?5?$CF?430s?6@ ; `string'
PUBLIC	??_C@_0CL@KEGPHPPF@xmlParseCharRef?3?5invalid?5xmlCha@ ; `string'
PUBLIC	??_C@_0DB@EJFBNJEE@xmlParseStringCharRef?3?5invalid?5@ ; `string'
PUBLIC	??_C@_0CJ@JICBMJMM@String?5decoding?5Entity?5Referenc@ ; `string'
PUBLIC	??_C@_0CC@KGDPFIJL@predefined?5entity?5has?5no?5conten@ ; `string'
PUBLIC	??_C@_0CF@DIAKJGNK@String?5decoding?5PE?5Reference?3?5?$CF@ ; `string'
PUBLIC	??_C@_0DH@IENLJLFO@not?5validating?5will?5not?5read?5co@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0CI@GHNHPHHB@Name?5?$CFs?5is?5not?5XML?5Namespace?5co@ ; `string'
PUBLIC	??_C@_04FABLJDN@Name@				; `string'
PUBLIC	??_C@_0CC@JIBKNHBD@unexpected?5change?5of?5input?5buff@ ; `string'
PUBLIC	??_C@_06MDLHOHLI@NCName@			; `string'
PUBLIC	??_C@_07JJJDEIPB@NmToken@			; `string'
PUBLIC	??_C@_0DM@GJGLHMKL@EntityValue?3?5?8?$CFc?8?5forbidden?5exc@ ; `string'
PUBLIC	??_C@_0BK@JCFIEKOP@AttValue?5length?5too?5long?6@ ; `string'
PUBLIC	??_C@_0CG@LEIKKIHB@invalid?5character?5in?5attribute?5@ ; `string'
PUBLIC	??_C@_0BG@NKOFEMFC@AttValue?3?5?8?5expected?6@	; `string'
PUBLIC	??_C@_0O@CPJEEBHF@SystemLiteral@		; `string'
PUBLIC	??_C@_09HLIINGHD@Public?5ID@			; `string'
PUBLIC	??_C@_0BO@IODKMKKF@PCDATA?5invalid?5Char?5value?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BP@CCMMHADN@Space?5required?5after?5?8SYSTEM?8?6@ ; `string'
PUBLIC	??_C@_0BP@EHONNEAJ@Space?5required?5after?5?8PUBLIC?8?6@ ; `string'
PUBLIC	??_C@_0CM@PJLPICDD@Space?5required?5after?5the?5Public@ ; `string'
PUBLIC	??_C@_0CL@FHECENFI@xmlParseComment?3?5invalid?5xmlCha@ ; `string'
PUBLIC	??_C@_0BG@BAOBDEOI@Comment?5too?5big?5found@	; `string'
PUBLIC	??_C@_0CD@MHPLKFMN@Comment?5not?5terminated?5?6?$DM?$CB?9?9?$CF?45@ ; `string'
PUBLIC	??_C@_0DD@BIJIOHJJ@Comment?5doesn?8t?5start?5and?5stop?5@ ; `string'
PUBLIC	??_C@_0BI@ELKFFAAB@Comment?5not?5terminated?6@	; `string'
PUBLIC	??_C@_0DD@DDHAOEGP@comment?5doesn?8t?5start?5and?5stop?5@ ; `string'
PUBLIC	??_C@_0CJ@CBOBCJAG@Double?5hyphen?5within?5comment?3?5?$DM@ ; `string'
PUBLIC	??_C@_0BO@PENANJHM@Double?5hyphen?5within?5comment?6@ ; `string'
PUBLIC	??_C@_0DL@PMHMGOPA@XML?5declaration?5allowed?5only?5at@ ; `string'
PUBLIC	??_C@_0CN@KJOCGNCM@xmlParsePITarget?3?5invalid?5name?5@ ; `string'
PUBLIC	??_C@_0CJ@KOKAGEDL@colons?5are?5forbidden?5from?5PI?5na@ ; `string'
PUBLIC	??_C@_07MFFOOIHD@catalog@			; `string'
PUBLIC	??_C@_0BN@MALFACIE@Catalog?5PI?5syntax?5error?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0DK@LAKAFNGA@PI?5declaration?5doesn?8t?5start?5an@ ; `string'
PUBLIC	??_C@_0BP@KBNJPEOK@ParsePI?3?5PI?5?$CFs?5space?5expected?6@ ; `string'
PUBLIC	??_C@_0BE@KDNCGJGM@PI?5?$CFs?5too?5big?5found@	; `string'
PUBLIC	??_C@_0BO@OGPJFKEP@ParsePI?3?5PI?5?$CFs?5never?5end?5?4?4?4?6@ ; `string'
PUBLIC	??_C@_0BC@IDENENGP@oasis?9xml?9catalog@		; `string'
PUBLIC	??_C@_0CD@ILKLDDEI@Space?5required?5after?5?8?$DM?$CBNOTATIO@ ; `string'
PUBLIC	??_C@_0CP@BOHPCDLP@colons?5are?5forbidden?5from?5notat@ ; `string'
PUBLIC	??_C@_0CJ@PMDGLIHG@Space?5required?5after?5the?5NOTATI@ ; `string'
PUBLIC	??_C@_0EA@DCHCOJDP@Notation?5declaration?5doesn?8t?5st@ ; `string'
PUBLIC	??_C@_0CB@NEOBPNBE@Space?5required?5after?5?8?$DM?$CBENTITY?8@ ; `string'
PUBLIC	??_C@_0BL@KGADBCMF@Space?5required?5after?5?8?$CF?$CF?8?6@ ; `string'
PUBLIC	??_C@_0BN@GJOFDJCB@xmlParseEntityDecl?3?5no?5name?6@ ; `string'
PUBLIC	??_C@_0CP@IEOCAMEB@colons?5are?5forbidden?5from?5entit@ ; `string'
PUBLIC	??_C@_0CG@IGJCKADK@Space?5required?5after?5the?5entity@ ; `string'
PUBLIC	??_C@_0BB@JHEINHI@Invalid?5URI?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_0CA@CHJJOFGL@SAX?5compatibility?5mode?5document@ ; `string'
PUBLIC	??_C@_0P@IDBIGKBI@New?5Doc?5failed@		; `string'
PUBLIC	??_C@_04PADNKBEK@fake@				; `string'
PUBLIC	??_C@_0BP@NPDMAEIM@Space?5required?5before?5?8NDATA?8?6@ ; `string'
PUBLIC	??_C@_0BO@GLBCJEIC@Space?5required?5after?5?8NDATA?8?6@ ; `string'
PUBLIC	??_C@_0CO@GFOAPJBJ@xmlParseEntityDecl?3?5entity?5?$CFs?5n@ ; `string'
PUBLIC	??_C@_0DO@BLCODNOK@Entity?5declaration?5doesn?8t?5star@ ; `string'
PUBLIC	??_C@_0BP@LOJANMBO@Space?5required?5after?5?8?$CDFIXED?8?6@ ; `string'
PUBLIC	??_C@_0CL@MHGJEBGE@Attribute?5default?5value?5declara@ ; `string'
PUBLIC	??_C@_0CH@MHDABFNP@Name?5expected?5in?5NOTATION?5decla@ ; `string'
PUBLIC	??_C@_0DK@HOPAGHFB@standalone?3?5attribute?5notation?5@ ; `string'
PUBLIC	??_C@_0DN@GKJDABEM@standalone?3?5attribute?5enumerati@ ; `string'
PUBLIC	??_C@_0CB@FOEKPMO@Space?5required?5after?5?8NOTATION?8@ ; `string'
PUBLIC	??_C@_0CC@DODLEJBN@Space?5required?5after?5?8?$DM?$CBATTLIST@ ; `string'
PUBLIC	??_C@_0BO@PIKFFONH@ATTLIST?3?5no?5name?5for?5Element?6@ ; `string'
PUBLIC	??_C@_0CA@GKDLKFPE@ATTLIST?3?5no?5name?5for?5Attribute?6@ ; `string'
PUBLIC	??_C@_0CJ@BMNHNBNL@Space?5required?5after?5the?5attrib@ ; `string'
PUBLIC	??_C@_0CJ@EMHJKDCH@Space?5required?5after?5the?5attrib@ ; `string'
PUBLIC	??_C@_0DC@NGABIAJF@Space?5required?5after?5the?5attrib@ ; `string'
PUBLIC	??_C@_0EG@JGLJABBC@Attribute?5list?5declaration?5does@ ; `string'
PUBLIC	??_C@_0EH@KGLJHJPD@Element?5content?5declaration?5doe@ ; `string'
PUBLIC	??_C@_0DB@BEFMOJIK@xmlParseElementMixedContentDecl@ ; `string'
PUBLIC	??_C@_0EM@OINCFINP@xmlParseElementChildrenContentD@ ; `string'
PUBLIC	??_C@_0DE@IJONAOBP@xmlParseElementChildrenContentD@ ; `string'
PUBLIC	??_C@_0CO@FLMKOMHK@xmlParseElementContentDecl?5?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0CA@CIGPNPNK@Space?5required?5after?5?8ELEMENT?8?6@ ; `string'
PUBLIC	??_C@_0CK@LMDMNJGO@xmlParseElementDecl?3?5no?5name?5fo@ ; `string'
PUBLIC	??_C@_0CH@MFBAJJC@Space?5required?5after?5the?5elemen@ ; `string'
PUBLIC	??_C@_0DO@COHAOPDG@PEReference?3?5forbidden?5within?5m@ ; `string'
PUBLIC	??_C@_0DF@CHNHOLDO@xmlParseElementDecl?3?5?8EMPTY?8?0?5?8@ ; `string'
PUBLIC	??_C@_0DP@KIKIPMFE@Element?5declaration?5doesn?8t?5sta@ ; `string'
PUBLIC	??_C@_0EB@LPINKGGA@All?5markup?5of?5the?5conditional?5s@ ; `string'
PUBLIC	??_C@_0CG@FMCBAD@Entering?5INCLUDE?5Conditional?5Se@ ; `string'
PUBLIC	??_C@_0CF@KBFPDCLM@Leaving?5INCLUDE?5Conditional?5Sec@ ; `string'
PUBLIC	??_C@_0CF@BNLECKJM@Entering?5IGNORE?5Conditional?5Sec@ ; `string'
PUBLIC	??_C@_0CE@MPDEOLDN@Leaving?5IGNORE?5Conditional?5Sect@ ; `string'
PUBLIC	??_C@_0BM@OIPNJGND@Space?5needed?5after?5?8?$DM?$DPxml?8?6@ ; `string'
PUBLIC	??_C@_03HLLJOCDO@1?40@				; `string'
PUBLIC	??_C@_0BD@LJKHCJDH@Space?5needed?5here?6@	; `string'
PUBLIC	??_C@_0CG@OFFEFIEL@Missing?5encoding?5in?5text?5declar@ ; `string'
PUBLIC	??_C@_04FNNDIGBC@?$CDx?$CFX@			; `string'
PUBLIC	??_C@_03FDCLAKJL@?$CD?$CFd@			; `string'
PUBLIC	??_C@_0BL@EBFCDHBG@invalid?5entity?5type?5found?6@ ; `string'
PUBLIC	??_C@_0BN@EOPGEOPH@Entity?5?8?$CFs?8?5failed?5to?5parse?6@ ; `string'
PUBLIC	??_C@_07DALNPEGO@nbktext@			; `string'
PUBLIC	??_C@_0BM@NMGBIIDP@xmlParseEntityRef?3?5no?5name?6@ ; `string'
PUBLIC	??_C@_0BJ@KIKIJMLK@Entity?5?8?$CFs?8?5not?5defined?6@ ; `string'
PUBLIC	??_C@_0CI@ILCMJJAO@Entity?5reference?5to?5unparsed?5en@ ; `string'
PUBLIC	??_C@_0CL@HLODLGOA@Attribute?5references?5external?5e@ ; `string'
PUBLIC	??_C@_0DI@FDECCCAO@?8?$DM?8?5in?5entity?5?8?$CFs?8?5is?5not?5allow@ ; `string'
PUBLIC	??_C@_0DA@CCPGIFBP@Attempt?5to?5reference?5the?5parame@ ; `string'
PUBLIC	??_C@_0CC@PKJKLMCM@xmlParseStringEntityRef?3?5no?5nam@ ; `string'
PUBLIC	??_C@_0BG@DIAKGNKN@PEReference?3?5no?5name?6@	; `string'
PUBLIC	??_C@_0BB@MFPJKDDB@PEReference?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BO@KINMDPMC@PEReference?3?5?$CF?$CF?$CFs?$DL?5not?5found?6@ ; `string'
PUBLIC	??_C@_0CL@BLGDJGPF@Internal?3?5?$CF?$CF?$CFs?$DL?5is?5not?5a?5parame@ ; `string'
PUBLIC	??_C@_0CF@PMEPEHIL@xmlLoadEntityContent?5parameter?5@ ; `string'
PUBLIC	??_C@_0CB@NCAMLBBH@Reading?5?$CFs?5entity?5content?5input@ ; `string'
PUBLIC	??_C@_0CB@HEAOEFBK@xmlLoadEntityContent?5input?5erro@ ; `string'
PUBLIC	??_C@_0CN@NHLEKBNA@xmlLoadEntityContent?3?5invalid?5c@ ; `string'
PUBLIC	??_C@_0CE@PLGLFALL@xmlParseStringPEReference?3?5no?5n@ ; `string'
PUBLIC	??_C@_0CB@HMFAEMHO@?$CF?$CF?$CFs?$DL?5is?5not?5a?5parameter?5entity@ ; `string'
PUBLIC	??_C@_0CJ@JPAMJNGL@xmlParseDocTypeDecl?5?3?5no?5DOCTYP@ ; `string'
PUBLIC	??_C@_0DO@IJLBCNCA@xmlParseInternalSubset?3?5error?5d@ ; `string'
PUBLIC	??_C@_0BO@BHLKDNI@error?5parsing?5attribute?5name?6@ ; `string'
PUBLIC	??_C@_0CP@LHHGCLP@Specification?5mandates?5value?5fo@ ; `string'
PUBLIC	??_C@_08EHDJCMMM@xml?3lang@			; `string'
PUBLIC	??_C@_0CD@OAOAJGL@Malformed?5value?5for?5xml?3lang?5?3?5@ ; `string'
PUBLIC	??_C@_09HKHFJOKD@xml?3space@			; `string'
PUBLIC	??_C@_07DLHCIBDH@default@			; `string'
PUBLIC	??_C@_08ILAKLJGO@preserve@			; `string'
PUBLIC	??_C@_0EF@GNALPKCP@Invalid?5value?5?$CC?$CFs?$CC?5for?5xml?3spac@ ; `string'
PUBLIC	??_C@_0CI@FEOPKDBB@xmlParseStartTag?3?5invalid?5eleme@ ; `string'
PUBLIC	??_C@_0BM@FKPAGOOK@attributes?5construct?5error?6@ ; `string'
PUBLIC	??_C@_0CO@KAECIKGE@xmlParseStartTag?3?5problem?5parsi@ ; `string'
PUBLIC	??_C@_0CA@PJGJPBIH@xmlParseEndTag?3?5?8?$DM?1?8?5not?5found?6@ ; `string'
PUBLIC	??_C@_0M@IAMGGMFE@unparseable@			; `string'
PUBLIC	??_C@_0DE@OCMDIBAP@Opening?5and?5ending?5tag?5mismatch@ ; `string'
PUBLIC	??_C@_0BM@DBJGDKCH@Failed?5to?5parse?5QName?5?8?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0BN@MNDCJBCK@Failed?5to?5parse?5QName?5?8?$CFs?3?8?6@ ; `string'
PUBLIC	??_C@_0CA@HECGKKLP@Failed?5to?5parse?5QName?5?8?$CFs?3?$CFs?3?8?6@ ; `string'
PUBLIC	??_C@_04IOHABJIC@lang@				; `string'
PUBLIC	??_C@_05OLNILLAB@space@				; `string'
PUBLIC	??_C@_0CA@LKOHNLNN@StartTag?3?5invalid?5element?5name?6@ ; `string'
PUBLIC	??_C@_0BO@NHFMDAKF@dictionary?5allocation?5failure@ ; `string'
PUBLIC	??_C@_0CA@IPMJMNFH@xmlns?3?5?8?$CFs?8?5is?5not?5a?5valid?5URI?6@ ; `string'
PUBLIC	??_C@_0BP@JFBGAFGI@xmlns?3?5URI?5?$CFs?5is?5not?5absolute?6@ ; `string'
PUBLIC	??_C@_0DD@IPHAILAA@xml?5namespace?5URI?5cannot?5be?5the@ ; `string'
PUBLIC	??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@ ; `string'
PUBLIC	??_C@_0DA@DPCHHACL@reuse?5of?5the?5xmlns?5namespace?5na@ ; `string'
PUBLIC	??_C@_0CK@HOGKMNCM@xml?5namespace?5prefix?5mapped?5to?5@ ; `string'
PUBLIC	??_C@_0CK@HFNNIPGF@xml?5namespace?5URI?5mapped?5to?5wro@ ; `string'
PUBLIC	??_C@_0CP@FCHEBDCM@redefinition?5of?5the?5xmlns?5prefi@ ; `string'
PUBLIC	??_C@_0CO@JLGJJKB@xmlns?3?$CFs?3?5Empty?5XML?5namespace?5i@ ; `string'
PUBLIC	??_C@_0CD@IMLPGLBN@xmlns?3?$CFs?3?5?8?$CFs?8?5is?5not?5a?5valid?5U@ ; `string'
PUBLIC	??_C@_0CC@FFFCEDOK@xmlns?3?$CFs?3?5URI?5?$CFs?5is?5not?5absolut@ ; `string'
PUBLIC	??_C@_0BM@HDEBIHCG@Unexpected?5change?5of?5input?6@ ; `string'
PUBLIC	??_C@_0DP@KFNFGALP@standalone?3?5attribute?5?$CFs?5on?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0DB@GMKAHOEK@Namespace?5prefix?5?$CFs?5for?5?$CFs?5on?5?$CF@ ; `string'
PUBLIC	??_C@_0CL@BDHHCEFP@Namespaced?5Attribute?5?$CFs?5in?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_0CK@EJLCFGPG@Namespace?5prefix?5?$CFs?5on?5?$CFs?5is?5no@ ; `string'
PUBLIC	??_C@_0BM@HGOGNNNB@CData?5section?5too?5big?5found@ ; `string'
PUBLIC	??_C@_0CC@HAEHMHLE@CData?5section?5not?5finished?6?$CF?450@ ; `string'
PUBLIC	??_C@_0CG@FCFCBOFE@detected?5an?5error?5in?5element?5co@ ; `string'
PUBLIC	??_C@_0CL@LKDFGLKB@Couldn?8t?5find?5end?5of?5Start?5Tag?5@ ; `string'
PUBLIC	??_C@_0CJ@JPBGMEM@Premature?5end?5of?5data?5in?5tag?5?$CFs@ ; `string'
PUBLIC	??_C@_06KNDPGIKI@UTF?916@			; `string'
PUBLIC	??_C@_05MNCHLHCA@UTF16@				; `string'
PUBLIC	??_C@_0DA@MEEPFAA@Document?5labelled?5UTF?916?5but?5ha@ ; `string'
PUBLIC	??_C@_05EGJIMALK@UTF?98@			; `string'
PUBLIC	??_C@_04OOMJJNCF@UTF8@				; `string'
PUBLIC	??_C@_0BJ@FCHADMKI@Unsupported?5encoding?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BM@BPKNILCI@Blank?5needed?5after?5?8?$DM?$DPxml?8?6@ ; `string'
PUBLIC	??_C@_0BK@MGCDLOCB@Unsupported?5version?5?8?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0BD@KLGEONFL@Blank?5needed?5here?6@	; `string'
PUBLIC	??_C@_0CD@NCHPNICC@Start?5tag?5expected?0?5?8?$DM?8?5not?5fou@ ; `string'
PUBLIC	??_C@_0CC@HDEJLGKL@Internal?5error?3?5xmlParseGetLast@ ; `string'
PUBLIC	??_C@_0CD@HIMAKCPA@Couldn?8t?5find?5end?5of?5Start?5Tag?5@ ; `string'
PUBLIC	??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@		; `string'
PUBLIC	??_C@_0CG@PHGFCMFA@PP?3?5internal?5error?0?5state?5?$DN?$DN?5CO@ ; `string'
PUBLIC	??_C@_0CE@CFNIBLKF@PP?3?5internal?5error?0?5state?5?$DN?$DN?5IG@ ; `string'
PUBLIC	??_C@_0CB@LNKCECMO@PP?3?5internal?5error?0?5state?5?$DN?$DN?5PI@ ; `string'
PUBLIC	??_C@_0CK@EGFEGMNP@PP?3?5internal?5error?0?5state?5?$DN?$DN?5EN@ ; `string'
PUBLIC	??_C@_0CL@FDJCPJGL@PP?3?5internal?5error?0?5state?5?$DN?$DN?5EN@ ; `string'
PUBLIC	??_C@_0CO@BNGPOFIK@PP?3?5internal?5error?0?5state?5?$DN?$DN?5AT@ ; `string'
PUBLIC	??_C@_0CN@JHJPBNDP@PP?3?5internal?5error?0?5state?5?$DN?$DN?5SY@ ; `string'
PUBLIC	??_C@_0CN@LJGHMOAD@PP?3?5internal?5error?0?5state?5?$DN?$DN?5PU@ ; `string'
PUBLIC	??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@ ; `string'
PUBLIC	??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@ ; `string'
PUBLIC	??_C@_05FPCKGDIJ@UCS?94@			; `string'
PUBLIC	??_C@_04JFFPNMJE@UCS4@				; `string'
PUBLIC	??_C@_0BO@IBAMLEHI@xmlParseChunk?3?5encoder?5error?6@ ; `string'
PUBLIC	??_C@_01LIIJDEN@?$AN@				; `string'
PUBLIC	??_C@_0CA@CCOLJACP@creating?5parser?3?5out?5of?5memory?6@ ; `string'
PUBLIC	??_C@_04CGFJFPFD@none@				; `string'
PUBLIC	??_C@_0L@OLLEMIAI@pseudoroot@			; `string'
PUBLIC	??_C@_0CO@FDJENMMD@Version?5mismatch?5between?5docume@ ; `string'
PUBLIC	??_C@_0BP@IGCIIMIK@cannot?5allocate?5parser?5context@ ; `string'
PUBLIC	??_C@_0CD@FOJADJIB@parsing?5new?5buffer?3?5out?5of?5memo@ ; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlCharStrdup:PROC
EXTRN	_xmlStrchr:PROC
EXTRN	_xmlStrcasestr:PROC
EXTRN	_xmlStrncmp:PROC
EXTRN	_xmlStrcasecmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	___htmlParseContent:PROC
EXTRN	___xmlGlobalInitMutexLock:PROC
EXTRN	___xmlGlobalInitMutexUnlock:PROC
EXTRN	_xmlInputReadCallbackNop:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	_xmlInitMemory:PROC
EXTRN	_xmlCleanupMemory:PROC
EXTRN	_xmlBufContent:PROC
EXTRN	_xmlBufUse:PROC
EXTRN	_xmlInitializeDict:PROC
EXTRN	_xmlDictSetLimit:PROC
EXTRN	_xmlDictReference:PROC
EXTRN	_xmlDictFree:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlDictOwns:PROC
EXTRN	_xmlDictCleanup:PROC
EXTRN	_xmlBuildQName:PROC
EXTRN	_xmlSplitQName3:PROC
EXTRN	_xmlBufferCreate:PROC
EXTRN	_xmlBufferFree:PROC
EXTRN	_xmlBufferAdd:PROC
EXTRN	_xmlCreateIntSubset:PROC
EXTRN	_xmlNewDtd:PROC
EXTRN	_xmlNewDoc:PROC
EXTRN	_xmlFreeDoc:PROC
EXTRN	_xmlNewDocNode:PROC
EXTRN	_xmlNewComment:PROC
EXTRN	_xmlDocCopyNode:PROC
EXTRN	_xmlGetLastChild:PROC
EXTRN	_xmlNodeIsText:PROC
EXTRN	_xmlAddChild:PROC
EXTRN	_xmlAddChildList:PROC
EXTRN	_xmlUnlinkNode:PROC
EXTRN	_xmlFreeNodeList:PROC
EXTRN	_xmlFreeNode:PROC
EXTRN	_xmlSetTreeDoc:PROC
EXTRN	_xmlSearchNsByHref:PROC
EXTRN	_xmlHashCreateDict:PROC
EXTRN	_xmlHashFree:PROC
EXTRN	_xmlHashDefaultDeallocator:PROC
EXTRN	_xmlHashAddEntry2:PROC
EXTRN	_xmlHashUpdateEntry2:PROC
EXTRN	_xmlHashRemoveEntry2:PROC
EXTRN	_xmlHashLookup2:PROC
EXTRN	_xmlHashQLookup2:PROC
EXTRN	_xmlHashSize:PROC
EXTRN	_xmlHashScanFull:PROC
EXTRN	_initGenericErrorDefaultFunc:PROC
EXTRN	_xmlResetLastError:PROC
EXTRN	_xmlResetError:PROC
EXTRN	_xmlCopyError:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	_xmlNewDocElementContent:PROC
EXTRN	_xmlFreeDocElementContent:PROC
EXTRN	_xmlCreateEnumeration:PROC
EXTRN	_xmlFreeEnumeration:PROC
EXTRN	_xmlValidateRoot:PROC
EXTRN	_xmlValidateElement:PROC
EXTRN	_xmlIsMixedElement:PROC
EXTRN	_xmlGetPredefinedEntity:PROC
EXTRN	_xmlInitCharEncodingHandlers:PROC
EXTRN	_xmlCleanupCharEncodingHandlers:PROC
EXTRN	_xmlFindCharEncodingHandler:PROC
EXTRN	_xmlDetectCharEncoding:PROC
EXTRN	_xmlCleanupInputCallbacks:PROC
EXTRN	_xmlRegisterDefaultInputCallbacks:PROC
EXTRN	_xmlAllocParserInputBuffer:PROC
EXTRN	_xmlParserInputBufferCreateFd:PROC
EXTRN	_xmlParserInputBufferCreateMem:PROC
EXTRN	_xmlParserInputBufferCreateIO:PROC
EXTRN	_xmlParserInputBufferPush:PROC
EXTRN	_xmlFreeParserInputBuffer:PROC
EXTRN	_xmlParserGetDirectory:PROC
EXTRN	_xmlCleanupOutputCallbacks:PROC
EXTRN	_xmlRegisterDefaultOutputCallbacks:PROC
EXTRN	_xmlParserInputGrow:PROC
EXTRN	_xmlNewParserCtxt:PROC
EXTRN	_xmlClearParserCtxt:PROC
EXTRN	_xmlFreeParserCtxt:PROC
EXTRN	_xmlNewIOInputStream:PROC
EXTRN	_xmlInitNodeInfoSeq:PROC
EXTRN	_xmlParserAddNodeInfo:PROC
EXTRN	_xmlLoadExternalEntity:PROC
EXTRN	_xmlSAX2GetEntity:PROC
EXTRN	_xmlSAX2EntityDecl:PROC
EXTRN	_xmlSAX2StartElement:PROC
EXTRN	_xmlSAX2EndElement:PROC
EXTRN	_xmlSAX2IgnorableWhitespace:PROC
EXTRN	_htmlDefaultSAXHandlerInit:PROC
EXTRN	_xmlDefaultSAXHandlerInit:PROC
EXTRN	_xmlInitGlobals:PROC
EXTRN	_xmlCleanupGlobals:PROC
EXTRN	___xmlDefaultSAXHandler:PROC
EXTRN	___xmlDefaultSAXLocator:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	___xmlParserDebugEntities:PROC
EXTRN	_xmlInitThreads:PROC
EXTRN	_xmlCleanupThreads:PROC
EXTRN	_htmlCreateMemoryParserCtxt:PROC
EXTRN	_xmlCharInRange:PROC
EXTRN	_xmlSwitchEncoding:PROC
EXTRN	_xmlSwitchToEncoding:PROC
EXTRN	___xmlErrEncoding:PROC
EXTRN	_xmlNewStringInputStream:PROC
EXTRN	_xmlNewEntityInputStream:PROC
EXTRN	_xmlFreeInputStream:PROC
EXTRN	_xmlNewInputStream:PROC
EXTRN	_xmlStringCurrentChar:PROC
EXTRN	_xmlCurrentChar:PROC
EXTRN	_xmlCopyCharMultiByte:PROC
EXTRN	_xmlCopyChar:PROC
EXTRN	_xmlNextChar:PROC
EXTRN	_xmlParserInputShrink:PROC
EXTRN	_htmlInitAutoClose:PROC
EXTRN	_xmlErrMemory:PROC
EXTRN	_xmlBuildURI:PROC
EXTRN	_xmlParseURI:PROC
EXTRN	_xmlFreeURI:PROC
EXTRN	_xmlCanonicPath:PROC
EXTRN	_xmlCatalogCleanup:PROC
EXTRN	_xmlCatalogFreeLocal:PROC
EXTRN	_xmlCatalogAddLocal:PROC
EXTRN	_xmlCatalogGetDefaults:PROC
EXTRN	_xmlSchemaCleanupTypes:PROC
EXTRN	_xmlRelaxNGCleanupTypes:PROC
EXTRN	_xmlBufIsEmpty:PROC
EXTRN	_xmlBufResetInput:PROC
EXTRN	_xmlBufGetInputBase:PROC
EXTRN	_xmlBufSetInputBaseCur:PROC
EXTRN	_xmlCharEncInput:PROC
EXTRN	_xmlXPathInit:PROC
EXTRN	_xmlGenericErrorDefaultFunc:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memchr:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_xmlEntityRefFunc DD 01H DUP (?)
_xmlParserInitialized DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CD@FOJADJIB@parsing?5new?5buffer?3?5out?5of?5memo@
CONST	SEGMENT
??_C@_0CD@FOJADJIB@parsing?5new?5buffer?3?5out?5of?5memo@ DB 'parsing new'
	DB	' buffer: out of memory', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IGCIIMIK@cannot?5allocate?5parser?5context@
CONST	SEGMENT
??_C@_0BP@IGCIIMIK@cannot?5allocate?5parser?5context@ DB 'cannot allocate'
	DB	' parser context', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FDJENMMD@Version?5mismatch?5between?5docume@
CONST	SEGMENT
??_C@_0CO@FDJENMMD@Version?5mismatch?5between?5docume@ DB 'Version mismat'
	DB	'ch between document and entity', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OLLEMIAI@pseudoroot@
CONST	SEGMENT
??_C@_0L@OLLEMIAI@pseudoroot@ DB 'pseudoroot', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGFJFPFD@none@
CONST	SEGMENT
??_C@_04CGFJFPFD@none@ DB 'none', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CCOLJACP@creating?5parser?3?5out?5of?5memory?6@
CONST	SEGMENT
??_C@_0CA@CCOLJACP@creating?5parser?3?5out?5of?5memory?6@ DB 'creating pa'
	DB	'rser: out of memory', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01LIIJDEN@?$AN@
CONST	SEGMENT
??_C@_01LIIJDEN@?$AN@ DB 0dH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IBAMLEHI@xmlParseChunk?3?5encoder?5error?6@
CONST	SEGMENT
??_C@_0BO@IBAMLEHI@xmlParseChunk?3?5encoder?5error?6@ DB 'xmlParseChunk: '
	DB	'encoder error', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFFPNMJE@UCS4@
CONST	SEGMENT
??_C@_04JFFPNMJE@UCS4@ DB 'UCS4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FPCKGDIJ@UCS?94@
CONST	SEGMENT
??_C@_05FPCKGDIJ@UCS?94@ DB 'UCS-4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@
CONST	SEGMENT
??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@ DB 'Input is no'
	DB	't proper UTF-8, indicate encoding !', 0aH, '%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@
CONST	SEGMENT
??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@ DB 'B'
	DB	'ytes: 0x%02X 0x%02X 0x%02X 0x%02X', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LJGHMOAD@PP?3?5internal?5error?0?5state?5?$DN?$DN?5PU@
CONST	SEGMENT
??_C@_0CN@LJGHMOAD@PP?3?5internal?5error?0?5state?5?$DN?$DN?5PU@ DB 'PP: '
	DB	'internal error, state == PUBLIC_LITERAL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JHJPBNDP@PP?3?5internal?5error?0?5state?5?$DN?$DN?5SY@
CONST	SEGMENT
??_C@_0CN@JHJPBNDP@PP?3?5internal?5error?0?5state?5?$DN?$DN?5SY@ DB 'PP: '
	DB	'internal error, state == SYSTEM_LITERAL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BNGPOFIK@PP?3?5internal?5error?0?5state?5?$DN?$DN?5AT@
CONST	SEGMENT
??_C@_0CO@BNGPOFIK@PP?3?5internal?5error?0?5state?5?$DN?$DN?5AT@ DB 'PP: '
	DB	'internal error, state == ATTRIBUTE_VALUE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FDJCPJGL@PP?3?5internal?5error?0?5state?5?$DN?$DN?5EN@
CONST	SEGMENT
??_C@_0CL@FDJCPJGL@PP?3?5internal?5error?0?5state?5?$DN?$DN?5EN@ DB 'PP: '
	DB	'internal error, state == ENTITY_VALUE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@EGFEGMNP@PP?3?5internal?5error?0?5state?5?$DN?$DN?5EN@
CONST	SEGMENT
??_C@_0CK@EGFEGMNP@PP?3?5internal?5error?0?5state?5?$DN?$DN?5EN@ DB 'PP: '
	DB	'internal error, state == ENTITY_DECL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LNKCECMO@PP?3?5internal?5error?0?5state?5?$DN?$DN?5PI@
CONST	SEGMENT
??_C@_0CB@LNKCECMO@PP?3?5internal?5error?0?5state?5?$DN?$DN?5PI@ DB 'PP: '
	DB	'internal error, state == PI', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CFNIBLKF@PP?3?5internal?5error?0?5state?5?$DN?$DN?5IG@
CONST	SEGMENT
??_C@_0CE@CFNIBLKF@PP?3?5internal?5error?0?5state?5?$DN?$DN?5IG@ DB 'PP: '
	DB	'internal error, state == IGNORE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PHGFCMFA@PP?3?5internal?5error?0?5state?5?$DN?$DN?5CO@
CONST	SEGMENT
??_C@_0CG@PHGFCMFA@PP?3?5internal?5error?0?5state?5?$DN?$DN?5CO@ DB 'PP: '
	DB	'internal error, state == COMMENT', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@
CONST	SEGMENT
??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@ DB '<![CDATA[', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HIMAKCPA@Couldn?8t?5find?5end?5of?5Start?5Tag?5@
CONST	SEGMENT
??_C@_0CD@HIMAKCPA@Couldn?8t?5find?5end?5of?5Start?5Tag?5@ DB 'Couldn''t '
	DB	'find end of Start Tag %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HDEJLGKL@Internal?5error?3?5xmlParseGetLast@
CONST	SEGMENT
??_C@_0CC@HDEJLGKL@Internal?5error?3?5xmlParseGetLast@ DB 'Internal error'
	DB	': xmlParseGetLasts', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NCHPNICC@Start?5tag?5expected?0?5?8?$DM?8?5not?5fou@
CONST	SEGMENT
??_C@_0CD@NCHPNICC@Start?5tag?5expected?0?5?8?$DM?8?5not?5fou@ DB 'Start '
	DB	'tag expected, ''<'' not found', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KLGEONFL@Blank?5needed?5here?6@
CONST	SEGMENT
??_C@_0BD@KLGEONFL@Blank?5needed?5here?6@ DB 'Blank needed here', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MGCDLOCB@Unsupported?5version?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BK@MGCDLOCB@Unsupported?5version?5?8?$CFs?8?6@ DB 'Unsupported ver'
	DB	'sion ''%s''', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BPKNILCI@Blank?5needed?5after?5?8?$DM?$DPxml?8?6@
CONST	SEGMENT
??_C@_0BM@BPKNILCI@Blank?5needed?5after?5?8?$DM?$DPxml?8?6@ DB 'Blank nee'
	DB	'ded after ''<?xml''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FCHADMKI@Unsupported?5encoding?5?$CFs?6@
CONST	SEGMENT
??_C@_0BJ@FCHADMKI@Unsupported?5encoding?5?$CFs?6@ DB 'Unsupported encodi'
	DB	'ng %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04OOMJJNCF@UTF8@
CONST	SEGMENT
??_C@_04OOMJJNCF@UTF8@ DB 'UTF8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05EGJIMALK@UTF?98@
CONST	SEGMENT
??_C@_05EGJIMALK@UTF?98@ DB 'UTF-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@MEEPFAA@Document?5labelled?5UTF?916?5but?5ha@
CONST	SEGMENT
??_C@_0DA@MEEPFAA@Document?5labelled?5UTF?916?5but?5ha@ DB 'Document labe'
	DB	'lled UTF-16 but has UTF-8 content', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MNCHLHCA@UTF16@
CONST	SEGMENT
??_C@_05MNCHLHCA@UTF16@ DB 'UTF16', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KNDPGIKI@UTF?916@
CONST	SEGMENT
??_C@_06KNDPGIKI@UTF?916@ DB 'UTF-16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JPBGMEM@Premature?5end?5of?5data?5in?5tag?5?$CFs@
CONST	SEGMENT
??_C@_0CJ@JPBGMEM@Premature?5end?5of?5data?5in?5tag?5?$CFs@ DB 'Premature'
	DB	' end of data in tag %s line %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LKDFGLKB@Couldn?8t?5find?5end?5of?5Start?5Tag?5@
CONST	SEGMENT
??_C@_0CL@LKDFGLKB@Couldn?8t?5find?5end?5of?5Start?5Tag?5@ DB 'Couldn''t '
	DB	'find end of Start Tag %s line %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FCFCBOFE@detected?5an?5error?5in?5element?5co@
CONST	SEGMENT
??_C@_0CG@FCFCBOFE@detected?5an?5error?5in?5element?5co@ DB 'detected an '
	DB	'error in element content', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HAEHMHLE@CData?5section?5not?5finished?6?$CF?450@
CONST	SEGMENT
??_C@_0CC@HAEHMHLE@CData?5section?5not?5finished?6?$CF?450@ DB 'CData sec'
	DB	'tion not finished', 0aH, '%.50s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HGOGNNNB@CData?5section?5too?5big?5found@
CONST	SEGMENT
??_C@_0BM@HGOGNNNB@CData?5section?5too?5big?5found@ DB 'CData section too'
	DB	' big found', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@EJLCFGPG@Namespace?5prefix?5?$CFs?5on?5?$CFs?5is?5no@
CONST	SEGMENT
??_C@_0CK@EJLCFGPG@Namespace?5prefix?5?$CFs?5on?5?$CFs?5is?5no@ DB 'Names'
	DB	'pace prefix %s on %s is not defined', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BDHHCEFP@Namespaced?5Attribute?5?$CFs?5in?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0CL@BDHHCEFP@Namespaced?5Attribute?5?$CFs?5in?5?8?$CFs?8@ DB 'Names'
	DB	'paced Attribute %s in ''%s'' redefined', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GMKAHOEK@Namespace?5prefix?5?$CFs?5for?5?$CFs?5on?5?$CF@
CONST	SEGMENT
??_C@_0DB@GMKAHOEK@Namespace?5prefix?5?$CFs?5for?5?$CFs?5on?5?$CF@ DB 'Na'
	DB	'mespace prefix %s for %s on %s is not defined', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KFNFGALP@standalone?3?5attribute?5?$CFs?5on?5?$CFs?5@
CONST	SEGMENT
??_C@_0DP@KFNFGALP@standalone?3?5attribute?5?$CFs?5on?5?$CFs?5@ DB 'stand'
	DB	'alone: attribute %s on %s defaulted from external subset', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HDEBIHCG@Unexpected?5change?5of?5input?6@
CONST	SEGMENT
??_C@_0BM@HDEBIHCG@Unexpected?5change?5of?5input?6@ DB 'Unexpected change'
	DB	' of input', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FFFCEDOK@xmlns?3?$CFs?3?5URI?5?$CFs?5is?5not?5absolut@
CONST	SEGMENT
??_C@_0CC@FFFCEDOK@xmlns?3?$CFs?3?5URI?5?$CFs?5is?5not?5absolut@ DB 'xmln'
	DB	's:%s: URI %s is not absolute', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IMLPGLBN@xmlns?3?$CFs?3?5?8?$CFs?8?5is?5not?5a?5valid?5U@
CONST	SEGMENT
??_C@_0CD@IMLPGLBN@xmlns?3?$CFs?3?5?8?$CFs?8?5is?5not?5a?5valid?5U@ DB 'x'
	DB	'mlns:%s: ''%s'' is not a valid URI', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JLGJJKB@xmlns?3?$CFs?3?5Empty?5XML?5namespace?5i@
CONST	SEGMENT
??_C@_0CO@JLGJJKB@xmlns?3?$CFs?3?5Empty?5XML?5namespace?5i@ DB 'xmlns:%s:'
	DB	' Empty XML namespace is not allowed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FCHEBDCM@redefinition?5of?5the?5xmlns?5prefi@
CONST	SEGMENT
??_C@_0CP@FCHEBDCM@redefinition?5of?5the?5xmlns?5prefi@ DB 'redefinition '
	DB	'of the xmlns prefix is forbidden', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@HFNNIPGF@xml?5namespace?5URI?5mapped?5to?5wro@
CONST	SEGMENT
??_C@_0CK@HFNNIPGF@xml?5namespace?5URI?5mapped?5to?5wro@ DB 'xml namespac'
	DB	'e URI mapped to wrong prefix', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@HOGKMNCM@xml?5namespace?5prefix?5mapped?5to?5@
CONST	SEGMENT
??_C@_0CK@HOGKMNCM@xml?5namespace?5prefix?5mapped?5to?5@ DB 'xml namespac'
	DB	'e prefix mapped to wrong URI', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DPCHHACL@reuse?5of?5the?5xmlns?5namespace?5na@
CONST	SEGMENT
??_C@_0DA@DPCHHACL@reuse?5of?5the?5xmlns?5namespace?5na@ DB 'reuse of the'
	DB	' xmlns namespace name is forbidden', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@
CONST	SEGMENT
??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@ DB 'http://www.'
	DB	'w3.org/2000/xmlns/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@IPHAILAA@xml?5namespace?5URI?5cannot?5be?5the@
CONST	SEGMENT
??_C@_0DD@IPHAILAA@xml?5namespace?5URI?5cannot?5be?5the@ DB 'xml namespac'
	DB	'e URI cannot be the default namespace', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JFBGAFGI@xmlns?3?5URI?5?$CFs?5is?5not?5absolute?6@
CONST	SEGMENT
??_C@_0BP@JFBGAFGI@xmlns?3?5URI?5?$CFs?5is?5not?5absolute?6@ DB 'xmlns: U'
	DB	'RI %s is not absolute', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IPMJMNFH@xmlns?3?5?8?$CFs?8?5is?5not?5a?5valid?5URI?6@
CONST	SEGMENT
??_C@_0CA@IPMJMNFH@xmlns?3?5?8?$CFs?8?5is?5not?5a?5valid?5URI?6@ DB 'xmln'
	DB	's: ''%s'' is not a valid URI', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NHFMDAKF@dictionary?5allocation?5failure@
CONST	SEGMENT
??_C@_0BO@NHFMDAKF@dictionary?5allocation?5failure@ DB 'dictionary alloca'
	DB	'tion failure', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LKOHNLNN@StartTag?3?5invalid?5element?5name?6@
CONST	SEGMENT
??_C@_0CA@LKOHNLNN@StartTag?3?5invalid?5element?5name?6@ DB 'StartTag: in'
	DB	'valid element name', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OLNILLAB@space@
CONST	SEGMENT
??_C@_05OLNILLAB@space@ DB 'space', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IOHABJIC@lang@
CONST	SEGMENT
??_C@_04IOHABJIC@lang@ DB 'lang', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HECGKKLP@Failed?5to?5parse?5QName?5?8?$CFs?3?$CFs?3?8?6@
CONST	SEGMENT
??_C@_0CA@HECGKKLP@Failed?5to?5parse?5QName?5?8?$CFs?3?$CFs?3?8?6@ DB 'Fa'
	DB	'iled to parse QName ''%s:%s:''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MNDCJBCK@Failed?5to?5parse?5QName?5?8?$CFs?3?8?6@
CONST	SEGMENT
??_C@_0BN@MNDCJBCK@Failed?5to?5parse?5QName?5?8?$CFs?3?8?6@ DB 'Failed to'
	DB	' parse QName ''%s:''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DBJGDKCH@Failed?5to?5parse?5QName?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BM@DBJGDKCH@Failed?5to?5parse?5QName?5?8?$CFs?8?6@ DB 'Failed to p'
	DB	'arse QName ''%s''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@OCMDIBAP@Opening?5and?5ending?5tag?5mismatch@
CONST	SEGMENT
??_C@_0DE@OCMDIBAP@Opening?5and?5ending?5tag?5mismatch@ DB 'Opening and e'
	DB	'nding tag mismatch: %s line %d and %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IAMGGMFE@unparseable@
CONST	SEGMENT
??_C@_0M@IAMGGMFE@unparseable@ DB 'unparseable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PJGJPBIH@xmlParseEndTag?3?5?8?$DM?1?8?5not?5found?6@
CONST	SEGMENT
??_C@_0CA@PJGJPBIH@xmlParseEndTag?3?5?8?$DM?1?8?5not?5found?6@ DB 'xmlPar'
	DB	'seEndTag: ''</'' not found', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KAECIKGE@xmlParseStartTag?3?5problem?5parsi@
CONST	SEGMENT
??_C@_0CO@KAECIKGE@xmlParseStartTag?3?5problem?5parsi@ DB 'xmlParseStartT'
	DB	'ag: problem parsing attributes', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FKPAGOOK@attributes?5construct?5error?6@
CONST	SEGMENT
??_C@_0BM@FKPAGOOK@attributes?5construct?5error?6@ DB 'attributes constru'
	DB	'ct error', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FEOPKDBB@xmlParseStartTag?3?5invalid?5eleme@
CONST	SEGMENT
??_C@_0CI@FEOPKDBB@xmlParseStartTag?3?5invalid?5eleme@ DB 'xmlParseStartT'
	DB	'ag: invalid element name', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@GNALPKCP@Invalid?5value?5?$CC?$CFs?$CC?5for?5xml?3spac@
CONST	SEGMENT
??_C@_0EF@GNALPKCP@Invalid?5value?5?$CC?$CFs?$CC?5for?5xml?3spac@ DB 'Inv'
	DB	'alid value "%s" for xml:space : "default" or "preserve" expec'
	DB	'ted', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08ILAKLJGO@preserve@
CONST	SEGMENT
??_C@_08ILAKLJGO@preserve@ DB 'preserve', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DLHCIBDH@default@
CONST	SEGMENT
??_C@_07DLHCIBDH@default@ DB 'default', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HKHFJOKD@xml?3space@
CONST	SEGMENT
??_C@_09HKHFJOKD@xml?3space@ DB 'xml:space', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@OAOAJGL@Malformed?5value?5for?5xml?3lang?5?3?5@
CONST	SEGMENT
??_C@_0CD@OAOAJGL@Malformed?5value?5for?5xml?3lang?5?3?5@ DB 'Malformed v'
	DB	'alue for xml:lang : %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EHDJCMMM@xml?3lang@
CONST	SEGMENT
??_C@_08EHDJCMMM@xml?3lang@ DB 'xml:lang', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LHHGCLP@Specification?5mandates?5value?5fo@
CONST	SEGMENT
??_C@_0CP@LHHGCLP@Specification?5mandates?5value?5fo@ DB 'Specification m'
	DB	'andates value for attribute %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BHLKDNI@error?5parsing?5attribute?5name?6@
CONST	SEGMENT
??_C@_0BO@BHLKDNI@error?5parsing?5attribute?5name?6@ DB 'error parsing at'
	DB	'tribute name', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@IJLBCNCA@xmlParseInternalSubset?3?5error?5d@
CONST	SEGMENT
??_C@_0DO@IJLBCNCA@xmlParseInternalSubset?3?5error?5d@ DB 'xmlParseIntern'
	DB	'alSubset: error detected in Markup declaration', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JPAMJNGL@xmlParseDocTypeDecl?5?3?5no?5DOCTYP@
CONST	SEGMENT
??_C@_0CJ@JPAMJNGL@xmlParseDocTypeDecl?5?3?5no?5DOCTYP@ DB 'xmlParseDocTy'
	DB	'peDecl : no DOCTYPE name !', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HMFAEMHO@?$CF?$CF?$CFs?$DL?5is?5not?5a?5parameter?5entity@
CONST	SEGMENT
??_C@_0CB@HMFAEMHO@?$CF?$CF?$CFs?$DL?5is?5not?5a?5parameter?5entity@ DB '%'
	DB	'%%s; is not a parameter entity', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PLGLFALL@xmlParseStringPEReference?3?5no?5n@
CONST	SEGMENT
??_C@_0CE@PLGLFALL@xmlParseStringPEReference?3?5no?5n@ DB 'xmlParseString'
	DB	'PEReference: no name', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NHLEKBNA@xmlLoadEntityContent?3?5invalid?5c@
CONST	SEGMENT
??_C@_0CN@NHLEKBNA@xmlLoadEntityContent?3?5invalid?5c@ DB 'xmlLoadEntityC'
	DB	'ontent: invalid char value %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HEAOEFBK@xmlLoadEntityContent?5input?5erro@
CONST	SEGMENT
??_C@_0CB@HEAOEFBK@xmlLoadEntityContent?5input?5erro@ DB 'xmlLoadEntityCo'
	DB	'ntent input error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NCAMLBBH@Reading?5?$CFs?5entity?5content?5input@
CONST	SEGMENT
??_C@_0CB@NCAMLBBH@Reading?5?$CFs?5entity?5content?5input@ DB 'Reading %s'
	DB	' entity content input', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PMEPEHIL@xmlLoadEntityContent?5parameter?5@
CONST	SEGMENT
??_C@_0CF@PMEPEHIL@xmlLoadEntityContent?5parameter?5@ DB 'xmlLoadEntityCo'
	DB	'ntent parameter error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BLGDJGPF@Internal?3?5?$CF?$CF?$CFs?$DL?5is?5not?5a?5parame@
CONST	SEGMENT
??_C@_0CL@BLGDJGPF@Internal?3?5?$CF?$CF?$CFs?$DL?5is?5not?5a?5parame@ DB 'I'
	DB	'nternal: %%%s; is not a parameter entity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KINMDPMC@PEReference?3?5?$CF?$CF?$CFs?$DL?5not?5found?6@
CONST	SEGMENT
??_C@_0BO@KINMDPMC@PEReference?3?5?$CF?$CF?$CFs?$DL?5not?5found?6@ DB 'PE'
	DB	'Reference: %%%s; not found', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MFPJKDDB@PEReference?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BB@MFPJKDDB@PEReference?3?5?$CFs?6@ DB 'PEReference: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DIAKGNKN@PEReference?3?5no?5name?6@
CONST	SEGMENT
??_C@_0BG@DIAKGNKN@PEReference?3?5no?5name?6@ DB 'PEReference: no name', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PKJKLMCM@xmlParseStringEntityRef?3?5no?5nam@
CONST	SEGMENT
??_C@_0CC@PKJKLMCM@xmlParseStringEntityRef?3?5no?5nam@ DB 'xmlParseString'
	DB	'EntityRef: no name', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@CCPGIFBP@Attempt?5to?5reference?5the?5parame@
CONST	SEGMENT
??_C@_0DA@CCPGIFBP@Attempt?5to?5reference?5the?5parame@ DB 'Attempt to re'
	DB	'ference the parameter entity ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@FDECCCAO@?8?$DM?8?5in?5entity?5?8?$CFs?8?5is?5not?5allow@
CONST	SEGMENT
??_C@_0DI@FDECCCAO@?8?$DM?8?5in?5entity?5?8?$CFs?8?5is?5not?5allow@ DB ''''
	DB	'<'' in entity ''%s'' is not allowed in attributes values', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HLODLGOA@Attribute?5references?5external?5e@
CONST	SEGMENT
??_C@_0CL@HLODLGOA@Attribute?5references?5external?5e@ DB 'Attribute refe'
	DB	'rences external entity ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@ILCMJJAO@Entity?5reference?5to?5unparsed?5en@
CONST	SEGMENT
??_C@_0CI@ILCMJJAO@Entity?5reference?5to?5unparsed?5en@ DB 'Entity refere'
	DB	'nce to unparsed entity %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KIKIJMLK@Entity?5?8?$CFs?8?5not?5defined?6@
CONST	SEGMENT
??_C@_0BJ@KIKIJMLK@Entity?5?8?$CFs?8?5not?5defined?6@ DB 'Entity ''%s'' n'
	DB	'ot defined', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NMGBIIDP@xmlParseEntityRef?3?5no?5name?6@
CONST	SEGMENT
??_C@_0BM@NMGBIIDP@xmlParseEntityRef?3?5no?5name?6@ DB 'xmlParseEntityRef'
	DB	': no name', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DALNPEGO@nbktext@
CONST	SEGMENT
??_C@_07DALNPEGO@nbktext@ DB 'nbktext', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EOPGEOPH@Entity?5?8?$CFs?8?5failed?5to?5parse?6@
CONST	SEGMENT
??_C@_0BN@EOPGEOPH@Entity?5?8?$CFs?8?5failed?5to?5parse?6@ DB 'Entity ''%'
	DB	's'' failed to parse', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EBFCDHBG@invalid?5entity?5type?5found?6@
CONST	SEGMENT
??_C@_0BL@EBFCDHBG@invalid?5entity?5type?5found?6@ DB 'invalid entity typ'
	DB	'e found', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03FDCLAKJL@?$CD?$CFd@
CONST	SEGMENT
??_C@_03FDCLAKJL@?$CD?$CFd@ DB '#%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FNNDIGBC@?$CDx?$CFX@
CONST	SEGMENT
??_C@_04FNNDIGBC@?$CDx?$CFX@ DB '#x%X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OFFEFIEL@Missing?5encoding?5in?5text?5declar@
CONST	SEGMENT
??_C@_0CG@OFFEFIEL@Missing?5encoding?5in?5text?5declar@ DB 'Missing encod'
	DB	'ing in text declaration', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LJKHCJDH@Space?5needed?5here?6@
CONST	SEGMENT
??_C@_0BD@LJKHCJDH@Space?5needed?5here?6@ DB 'Space needed here', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HLLJOCDO@1?40@
CONST	SEGMENT
??_C@_03HLLJOCDO@1?40@ DB '1.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OIPNJGND@Space?5needed?5after?5?8?$DM?$DPxml?8?6@
CONST	SEGMENT
??_C@_0BM@OIPNJGND@Space?5needed?5after?5?8?$DM?$DPxml?8?6@ DB 'Space nee'
	DB	'ded after ''<?xml''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MPDEOLDN@Leaving?5IGNORE?5Conditional?5Sect@
CONST	SEGMENT
??_C@_0CE@MPDEOLDN@Leaving?5IGNORE?5Conditional?5Sect@ DB 'Leaving IGNORE'
	DB	' Conditional Section', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BNLECKJM@Entering?5IGNORE?5Conditional?5Sec@
CONST	SEGMENT
??_C@_0CF@BNLECKJM@Entering?5IGNORE?5Conditional?5Sec@ DB 'Entering IGNOR'
	DB	'E Conditional Section', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KBFPDCLM@Leaving?5INCLUDE?5Conditional?5Sec@
CONST	SEGMENT
??_C@_0CF@KBFPDCLM@Leaving?5INCLUDE?5Conditional?5Sec@ DB 'Leaving INCLUD'
	DB	'E Conditional Section', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FMCBAD@Entering?5INCLUDE?5Conditional?5Se@
CONST	SEGMENT
??_C@_0CG@FMCBAD@Entering?5INCLUDE?5Conditional?5Se@ DB 'Entering INCLUDE'
	DB	' Conditional Section', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@LPINKGGA@All?5markup?5of?5the?5conditional?5s@
CONST	SEGMENT
??_C@_0EB@LPINKGGA@All?5markup?5of?5the?5conditional?5s@ DB 'All markup o'
	DB	'f the conditional section is not in the same entity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KIKIPMFE@Element?5declaration?5doesn?8t?5sta@
CONST	SEGMENT
??_C@_0DP@KIKIPMFE@Element?5declaration?5doesn?8t?5sta@ DB 'Element decla'
	DB	'ration doesn''t start and stop in the same entity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@CHNHOLDO@xmlParseElementDecl?3?5?8EMPTY?8?0?5?8@
CONST	SEGMENT
??_C@_0DF@CHNHOLDO@xmlParseElementDecl?3?5?8EMPTY?8?0?5?8@ DB 'xmlParseEl'
	DB	'ementDecl: ''EMPTY'', ''ANY'' or ''('' expected', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@COHAOPDG@PEReference?3?5forbidden?5within?5m@
CONST	SEGMENT
??_C@_0DO@COHAOPDG@PEReference?3?5forbidden?5within?5m@ DB 'PEReference: '
	DB	'forbidden within markup decl in internal subset', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MFBAJJC@Space?5required?5after?5the?5elemen@
CONST	SEGMENT
??_C@_0CH@MFBAJJC@Space?5required?5after?5the?5elemen@ DB 'Space required'
	DB	' after the element name', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LMDMNJGO@xmlParseElementDecl?3?5no?5name?5fo@
CONST	SEGMENT
??_C@_0CK@LMDMNJGO@xmlParseElementDecl?3?5no?5name?5fo@ DB 'xmlParseEleme'
	DB	'ntDecl: no name for Element', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CIGPNPNK@Space?5required?5after?5?8ELEMENT?8?6@
CONST	SEGMENT
??_C@_0CA@CIGPNPNK@Space?5required?5after?5?8ELEMENT?8?6@ DB 'Space requi'
	DB	'red after ''ELEMENT''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FLMKOMHK@xmlParseElementContentDecl?5?3?5?$CFs@
CONST	SEGMENT
??_C@_0CO@FLMKOMHK@xmlParseElementContentDecl?5?3?5?$CFs@ DB 'xmlParseEle'
	DB	'mentContentDecl : %s ''('' expected', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@IJONAOBP@xmlParseElementChildrenContentD@
CONST	SEGMENT
??_C@_0DE@IJONAOBP@xmlParseElementChildrenContentD@ DB 'xmlParseElementCh'
	DB	'ildrenContentDecl : ''%c'' expected', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@OINCFINP@xmlParseElementChildrenContentD@
CONST	SEGMENT
??_C@_0EM@OINCFINP@xmlParseElementChildrenContentD@ DB 'xmlParseElementCh'
	DB	'ildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@BEFMOJIK@xmlParseElementMixedContentDecl@
CONST	SEGMENT
??_C@_0DB@BEFMOJIK@xmlParseElementMixedContentDecl@ DB 'xmlParseElementMi'
	DB	'xedContentDecl : Name expected', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@KGLJHJPD@Element?5content?5declaration?5doe@
CONST	SEGMENT
??_C@_0EH@KGLJHJPD@Element?5content?5declaration?5doe@ DB 'Element conten'
	DB	't declaration doesn''t start and stop in the same entity', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@JGLJABBC@Attribute?5list?5declaration?5does@
CONST	SEGMENT
??_C@_0EG@JGLJABBC@Attribute?5list?5declaration?5does@ DB 'Attribute list'
	DB	' declaration doesn''t start and stop in the same entity', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@NGABIAJF@Space?5required?5after?5the?5attrib@
CONST	SEGMENT
??_C@_0DC@NGABIAJF@Space?5required?5after?5the?5attrib@ DB 'Space require'
	DB	'd after the attribute default value', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EMHJKDCH@Space?5required?5after?5the?5attrib@
CONST	SEGMENT
??_C@_0CJ@EMHJKDCH@Space?5required?5after?5the?5attrib@ DB 'Space require'
	DB	'd after the attribute type', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BMNHNBNL@Space?5required?5after?5the?5attrib@
CONST	SEGMENT
??_C@_0CJ@BMNHNBNL@Space?5required?5after?5the?5attrib@ DB 'Space require'
	DB	'd after the attribute name', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GKDLKFPE@ATTLIST?3?5no?5name?5for?5Attribute?6@
CONST	SEGMENT
??_C@_0CA@GKDLKFPE@ATTLIST?3?5no?5name?5for?5Attribute?6@ DB 'ATTLIST: no'
	DB	' name for Attribute', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PIKFFONH@ATTLIST?3?5no?5name?5for?5Element?6@
CONST	SEGMENT
??_C@_0BO@PIKFFONH@ATTLIST?3?5no?5name?5for?5Element?6@ DB 'ATTLIST: no n'
	DB	'ame for Element', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DODLEJBN@Space?5required?5after?5?8?$DM?$CBATTLIST@
CONST	SEGMENT
??_C@_0CC@DODLEJBN@Space?5required?5after?5?8?$DM?$CBATTLIST@ DB 'Space r'
	DB	'equired after ''<!ATTLIST''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FOEKPMO@Space?5required?5after?5?8NOTATION?8@
CONST	SEGMENT
??_C@_0CB@FOEKPMO@Space?5required?5after?5?8NOTATION?8@ DB 'Space require'
	DB	'd after ''NOTATION''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@GKJDABEM@standalone?3?5attribute?5enumerati@
CONST	SEGMENT
??_C@_0DN@GKJDABEM@standalone?3?5attribute?5enumerati@ DB 'standalone: at'
	DB	'tribute enumeration value token %s duplicated', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HOPAGHFB@standalone?3?5attribute?5notation?5@
CONST	SEGMENT
??_C@_0DK@HOPAGHFB@standalone?3?5attribute?5notation?5@ DB 'standalone: a'
	DB	'ttribute notation value token %s duplicated', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MHDABFNP@Name?5expected?5in?5NOTATION?5decla@
CONST	SEGMENT
??_C@_0CH@MHDABFNP@Name?5expected?5in?5NOTATION?5decla@ DB 'Name expected'
	DB	' in NOTATION declaration', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MHGJEBGE@Attribute?5default?5value?5declara@
CONST	SEGMENT
??_C@_0CL@MHGJEBGE@Attribute?5default?5value?5declara@ DB 'Attribute defa'
	DB	'ult value declaration error', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LOJANMBO@Space?5required?5after?5?8?$CDFIXED?8?6@
CONST	SEGMENT
??_C@_0BP@LOJANMBO@Space?5required?5after?5?8?$CDFIXED?8?6@ DB 'Space req'
	DB	'uired after ''#FIXED''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@BLCODNOK@Entity?5declaration?5doesn?8t?5star@
CONST	SEGMENT
??_C@_0DO@BLCODNOK@Entity?5declaration?5doesn?8t?5star@ DB 'Entity declar'
	DB	'ation doesn''t start and stop in the same entity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GFOAPJBJ@xmlParseEntityDecl?3?5entity?5?$CFs?5n@
CONST	SEGMENT
??_C@_0CO@GFOAPJBJ@xmlParseEntityDecl?3?5entity?5?$CFs?5n@ DB 'xmlParseEn'
	DB	'tityDecl: entity %s not terminated', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GLBCJEIC@Space?5required?5after?5?8NDATA?8?6@
CONST	SEGMENT
??_C@_0BO@GLBCJEIC@Space?5required?5after?5?8NDATA?8?6@ DB 'Space require'
	DB	'd after ''NDATA''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NPDMAEIM@Space?5required?5before?5?8NDATA?8?6@
CONST	SEGMENT
??_C@_0BP@NPDMAEIM@Space?5required?5before?5?8NDATA?8?6@ DB 'Space requir'
	DB	'ed before ''NDATA''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PADNKBEK@fake@
CONST	SEGMENT
??_C@_04PADNKBEK@fake@ DB 'fake', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IDBIGKBI@New?5Doc?5failed@
CONST	SEGMENT
??_C@_0P@IDBIGKBI@New?5Doc?5failed@ DB 'New Doc failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CHJJOFGL@SAX?5compatibility?5mode?5document@
CONST	SEGMENT
??_C@_0CA@CHJJOFGL@SAX?5compatibility?5mode?5document@ DB 'SAX compatibil'
	DB	'ity mode document', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JHEINHI@Invalid?5URI?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BB@JHEINHI@Invalid?5URI?3?5?$CFs?6@ DB 'Invalid URI: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IGJCKADK@Space?5required?5after?5the?5entity@
CONST	SEGMENT
??_C@_0CG@IGJCKADK@Space?5required?5after?5the?5entity@ DB 'Space require'
	DB	'd after the entity name', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@IEOCAMEB@colons?5are?5forbidden?5from?5entit@
CONST	SEGMENT
??_C@_0CP@IEOCAMEB@colons?5are?5forbidden?5from?5entit@ DB 'colons are fo'
	DB	'rbidden from entities names ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GJOFDJCB@xmlParseEntityDecl?3?5no?5name?6@
CONST	SEGMENT
??_C@_0BN@GJOFDJCB@xmlParseEntityDecl?3?5no?5name?6@ DB 'xmlParseEntityDe'
	DB	'cl: no name', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KGADBCMF@Space?5required?5after?5?8?$CF?$CF?8?6@
CONST	SEGMENT
??_C@_0BL@KGADBCMF@Space?5required?5after?5?8?$CF?$CF?8?6@ DB 'Space requ'
	DB	'ired after ''%%''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NEOBPNBE@Space?5required?5after?5?8?$DM?$CBENTITY?8@
CONST	SEGMENT
??_C@_0CB@NEOBPNBE@Space?5required?5after?5?8?$DM?$CBENTITY?8@ DB 'Space '
	DB	'required after ''<!ENTITY''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@DCHCOJDP@Notation?5declaration?5doesn?8t?5st@
CONST	SEGMENT
??_C@_0EA@DCHCOJDP@Notation?5declaration?5doesn?8t?5st@ DB 'Notation decl'
	DB	'aration doesn''t start and stop in the same entity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PMDGLIHG@Space?5required?5after?5the?5NOTATI@
CONST	SEGMENT
??_C@_0CJ@PMDGLIHG@Space?5required?5after?5the?5NOTATI@ DB 'Space require'
	DB	'd after the NOTATION name''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BOHPCDLP@colons?5are?5forbidden?5from?5notat@
CONST	SEGMENT
??_C@_0CP@BOHPCDLP@colons?5are?5forbidden?5from?5notat@ DB 'colons are fo'
	DB	'rbidden from notation names ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@ILKLDDEI@Space?5required?5after?5?8?$DM?$CBNOTATIO@
CONST	SEGMENT
??_C@_0CD@ILKLDDEI@Space?5required?5after?5?8?$DM?$CBNOTATIO@ DB 'Space r'
	DB	'equired after ''<!NOTATION''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IDENENGP@oasis?9xml?9catalog@
CONST	SEGMENT
??_C@_0BC@IDENENGP@oasis?9xml?9catalog@ DB 'oasis-xml-catalog', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OGPJFKEP@ParsePI?3?5PI?5?$CFs?5never?5end?5?4?4?4?6@
CONST	SEGMENT
??_C@_0BO@OGPJFKEP@ParsePI?3?5PI?5?$CFs?5never?5end?5?4?4?4?6@ DB 'ParseP'
	DB	'I: PI %s never end ...', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KDNCGJGM@PI?5?$CFs?5too?5big?5found@
CONST	SEGMENT
??_C@_0BE@KDNCGJGM@PI?5?$CFs?5too?5big?5found@ DB 'PI %s too big found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KBNJPEOK@ParsePI?3?5PI?5?$CFs?5space?5expected?6@
CONST	SEGMENT
??_C@_0BP@KBNJPEOK@ParsePI?3?5PI?5?$CFs?5space?5expected?6@ DB 'ParsePI: '
	DB	'PI %s space expected', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@LAKAFNGA@PI?5declaration?5doesn?8t?5start?5an@
CONST	SEGMENT
??_C@_0DK@LAKAFNGA@PI?5declaration?5doesn?8t?5start?5an@ DB 'PI declarati'
	DB	'on doesn''t start and stop in the same entity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MALFACIE@Catalog?5PI?5syntax?5error?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BN@MALFACIE@Catalog?5PI?5syntax?5error?3?5?$CFs?6@ DB 'Catalog PI '
	DB	'syntax error: %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MFFOOIHD@catalog@
CONST	SEGMENT
??_C@_07MFFOOIHD@catalog@ DB 'catalog', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KOKAGEDL@colons?5are?5forbidden?5from?5PI?5na@
CONST	SEGMENT
??_C@_0CJ@KOKAGEDL@colons?5are?5forbidden?5from?5PI?5na@ DB 'colons are f'
	DB	'orbidden from PI names ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KJOCGNCM@xmlParsePITarget?3?5invalid?5name?5@
CONST	SEGMENT
??_C@_0CN@KJOCGNCM@xmlParsePITarget?3?5invalid?5name?5@ DB 'xmlParsePITar'
	DB	'get: invalid name prefix ''xml''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@PMHMGOPA@XML?5declaration?5allowed?5only?5at@
CONST	SEGMENT
??_C@_0DL@PMHMGOPA@XML?5declaration?5allowed?5only?5at@ DB 'XML declarati'
	DB	'on allowed only at the start of the document', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PENANJHM@Double?5hyphen?5within?5comment?6@
CONST	SEGMENT
??_C@_0BO@PENANJHM@Double?5hyphen?5within?5comment?6@ DB 'Double hyphen w'
	DB	'ithin comment', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CBOBCJAG@Double?5hyphen?5within?5comment?3?5?$DM@
CONST	SEGMENT
??_C@_0CJ@CBOBCJAG@Double?5hyphen?5within?5comment?3?5?$DM@ DB 'Double hy'
	DB	'phen within comment: <!--%.50s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@DDHAOEGP@comment?5doesn?8t?5start?5and?5stop?5@
CONST	SEGMENT
??_C@_0DD@DDHAOEGP@comment?5doesn?8t?5start?5and?5stop?5@ DB 'comment doe'
	DB	'sn''t start and stop in the same entity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ELKFFAAB@Comment?5not?5terminated?6@
CONST	SEGMENT
??_C@_0BI@ELKFFAAB@Comment?5not?5terminated?6@ DB 'Comment not terminated'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@BIJIOHJJ@Comment?5doesn?8t?5start?5and?5stop?5@
CONST	SEGMENT
??_C@_0DD@BIJIOHJJ@Comment?5doesn?8t?5start?5and?5stop?5@ DB 'Comment doe'
	DB	'sn''t start and stop in the same entity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MHPLKFMN@Comment?5not?5terminated?5?6?$DM?$CB?9?9?$CF?45@
CONST	SEGMENT
??_C@_0CD@MHPLKFMN@Comment?5not?5terminated?5?6?$DM?$CB?9?9?$CF?45@ DB 'C'
	DB	'omment not terminated ', 0aH, '<!--%.50s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BAOBDEOI@Comment?5too?5big?5found@
CONST	SEGMENT
??_C@_0BG@BAOBDEOI@Comment?5too?5big?5found@ DB 'Comment too big found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FHECENFI@xmlParseComment?3?5invalid?5xmlCha@
CONST	SEGMENT
??_C@_0CL@FHECENFI@xmlParseComment?3?5invalid?5xmlCha@ DB 'xmlParseCommen'
	DB	't: invalid xmlChar value %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PJLPICDD@Space?5required?5after?5the?5Public@
CONST	SEGMENT
??_C@_0CM@PJLPICDD@Space?5required?5after?5the?5Public@ DB 'Space require'
	DB	'd after the Public Identifier', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EHONNEAJ@Space?5required?5after?5?8PUBLIC?8?6@
CONST	SEGMENT
??_C@_0BP@EHONNEAJ@Space?5required?5after?5?8PUBLIC?8?6@ DB 'Space requir'
	DB	'ed after ''PUBLIC''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CCMMHADN@Space?5required?5after?5?8SYSTEM?8?6@
CONST	SEGMENT
??_C@_0BP@CCMMHADN@Space?5required?5after?5?8SYSTEM?8?6@ DB 'Space requir'
	DB	'ed after ''SYSTEM''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IODKMKKF@PCDATA?5invalid?5Char?5value?5?$CFd?6@
CONST	SEGMENT
??_C@_0BO@IODKMKKF@PCDATA?5invalid?5Char?5value?5?$CFd?6@ DB 'PCDATA inva'
	DB	'lid Char value %d', 0aH, 00H		; `string'
CONST	ENDS
CONST	SEGMENT
_test_char_data DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	09H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	00H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	00H
	DB	03dH
	DB	03eH
	DB	03fH
	DB	040H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	05bH
	DB	05cH
	DB	00H
	DB	05eH
	DB	05fH
	DB	060H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	07bH
	DB	07cH
	DB	07dH
	DB	07eH
	DB	07fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_09HLIINGHD@Public?5ID@
CONST	SEGMENT
??_C@_09HLIINGHD@Public?5ID@ DB 'Public ID', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CPJEEBHF@SystemLiteral@
CONST	SEGMENT
??_C@_0O@CPJEEBHF@SystemLiteral@ DB 'SystemLiteral', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NKOFEMFC@AttValue?3?5?8?5expected?6@
CONST	SEGMENT
??_C@_0BG@NKOFEMFC@AttValue?3?5?8?5expected?6@ DB 'AttValue: '' expected', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LEIKKIHB@invalid?5character?5in?5attribute?5@
CONST	SEGMENT
??_C@_0CG@LEIKKIHB@invalid?5character?5in?5attribute?5@ DB 'invalid chara'
	DB	'cter in attribute value', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JCFIEKOP@AttValue?5length?5too?5long?6@
CONST	SEGMENT
??_C@_0BK@JCFIEKOP@AttValue?5length?5too?5long?6@ DB 'AttValue length too'
	DB	' long', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@GJGLHMKL@EntityValue?3?5?8?$CFc?8?5forbidden?5exc@
CONST	SEGMENT
??_C@_0DM@GJGLHMKL@EntityValue?3?5?8?$CFc?8?5forbidden?5exc@ DB 'EntityVa'
	DB	'lue: ''%c'' forbidden except for entities references', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07JJJDEIPB@NmToken@
CONST	SEGMENT
??_C@_07JJJDEIPB@NmToken@ DB 'NmToken', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MDLHOHLI@NCName@
CONST	SEGMENT
??_C@_06MDLHOHLI@NCName@ DB 'NCName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JIBKNHBD@unexpected?5change?5of?5input?5buff@
CONST	SEGMENT
??_C@_0CC@JIBKNHBD@unexpected?5change?5of?5input?5buff@ DB 'unexpected ch'
	DB	'ange of input buffer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FABLJDN@Name@
CONST	SEGMENT
??_C@_04FABLJDN@Name@ DB 'Name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GHNHPHHB@Name?5?$CFs?5is?5not?5XML?5Namespace?5co@
CONST	SEGMENT
??_C@_0CI@GHNHPHHB@Name?5?$CFs?5is?5not?5XML?5Namespace?5co@ DB 'Name %s '
	DB	'is not XML Namespace compliant', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@IENLJLFO@not?5validating?5will?5not?5read?5co@
CONST	SEGMENT
??_C@_0DH@IENLJLFO@not?5validating?5will?5not?5read?5co@ DB 'not validati'
	DB	'ng will not read content for PE entity %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DIAKJGNK@String?5decoding?5PE?5Reference?3?5?$CF@
CONST	SEGMENT
??_C@_0CF@DIAKJGNK@String?5decoding?5PE?5Reference?3?5?$CF@ DB 'String de'
	DB	'coding PE Reference: %.30s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KGDPFIJL@predefined?5entity?5has?5no?5conten@
CONST	SEGMENT
??_C@_0CC@KGDPFIJL@predefined?5entity?5has?5no?5conten@ DB 'predefined en'
	DB	'tity has no content', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JICBMJMM@String?5decoding?5Entity?5Referenc@
CONST	SEGMENT
??_C@_0CJ@JICBMJMM@String?5decoding?5Entity?5Referenc@ DB 'String decodin'
	DB	'g Entity Reference: %.30s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@EJFBNJEE@xmlParseStringCharRef?3?5invalid?5@
CONST	SEGMENT
??_C@_0DB@EJFBNJEE@xmlParseStringCharRef?3?5invalid?5@ DB 'xmlParseString'
	DB	'CharRef: invalid xmlChar value %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KEGPHPPF@xmlParseCharRef?3?5invalid?5xmlCha@
CONST	SEGMENT
??_C@_0CL@KEGPHPPF@xmlParseCharRef?3?5invalid?5xmlCha@ DB 'xmlParseCharRe'
	DB	'f: invalid xmlChar value %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IPLLKNJK@Pushing?5input?5?$CFd?5?3?5?$CF?430s?6@
CONST	SEGMENT
??_C@_0BK@IPLLKNJK@Pushing?5input?5?$CFd?5?3?5?$CF?430s?6@ DB 'Pushing in'
	DB	'put %d : %.30s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08FFIMCMGN@?$CFs?$CI?$CFd?$CJ?3?5@
CONST	SEGMENT
??_C@_08FFIMCMGN@?$CFs?$CI?$CFd?$CJ?3?5@ DB '%s(%d): ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JODEMIEP@Unfinished?5entity?5outside?5the?5D@
CONST	SEGMENT
??_C@_0CC@JODEMIEP@Unfinished?5entity?5outside?5the?5D@ DB 'Unfinished en'
	DB	'tity outside the DTD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LEKDBCEK@Popping?5input?5?$CFd?6@
CONST	SEGMENT
??_C@_0BC@LEKDBCEK@Popping?5input?5?$CFd?6@ DB 'Popping input %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JOKBAJC@cur?5index?5out?5of?5bound@
CONST	SEGMENT
??_C@_0BH@JOKBAJC@cur?5index?5out?5of?5bound@ DB 'cur index out of bound', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BAMNGBKO@Huge?5input?5lookup@
CONST	SEGMENT
??_C@_0BC@BAMNGBKO@Huge?5input?5lookup@ DB 'Huge input lookup', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@HADOBDDE@Excessive?5depth?5in?5document?3?5?$CFd@
CONST	SEGMENT
??_C@_0DL@HADOBDDE@Excessive?5depth?5in?5document?3?5?$CFd@ DB 'Excessive'
	DB	' depth in document: %d use XML_PARSE_HUGE option', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KIFBOAFI@Pbm?5popping?5?$CFd?5NS?6@
CONST	SEGMENT
??_C@_0BD@KIFBOAFI@Pbm?5popping?5?$CFd?5NS?6@ DB 'Pbm popping %d NS', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08OIBPHJGN@external@
CONST	SEGMENT
??_C@_08OIBPHJGN@external@ DB 'external', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
CONST	SEGMENT
??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ DB 'http://ww'
	DB	'w.w3.org/XML/1998/namespace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPEFOGKI@xmlns@
CONST	SEGMENT
??_C@_05PPEFOGKI@xmlns@ DB 'xmlns', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJHHNEEI@xml@
CONST	SEGMENT
??_C@_03PJHHNEEI@xml@ DB 'xml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@
CONST	SEGMENT
??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@ DB '%s: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@COECCIID@Unregistered?5error?5message@
CONST	SEGMENT
??_C@_0BL@COECCIID@Unregistered?5error?5message@ DB 'Unregistered error m'
	DB	'essage', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@
CONST	SEGMENT
??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@ DB 'Name too long'
	DB	' use XML_PARSE_HUGE option', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FHFOLBEM@Malformed?5declaration?5expecting@
CONST	SEGMENT
??_C@_0CI@FHFOLBEM@Malformed?5declaration?5expecting@ DB 'Malformed decla'
	DB	'ration expecting version', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BPKCCNLP@extra?5content?5at?5the?5end?5of?5wel@
CONST	SEGMENT
??_C@_0DA@BPKCCNLP@extra?5content?5at?5the?5end?5of?5wel@ DB 'extra conte'
	DB	'nt at the end of well balanced chunk', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@
CONST	SEGMENT
??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@ DB 'chunk is not well '
	DB	'balanced', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JKANOFNI@Extra?5content?5at?5the?5end?5of?5the@
CONST	SEGMENT
??_C@_0CJ@JKANOFNI@Extra?5content?5at?5the?5end?5of?5the@ DB 'Extra conte'
	DB	'nt at the end of the document', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LDMJLCHP@Document?5is?5empty@
CONST	SEGMENT
??_C@_0BC@LDMJLCHP@Document?5is?5empty@ DB 'Document is empty', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MBLHCBEE@standalone?5accepts?5only?5?8yes?8?5o@
CONST	SEGMENT
??_C@_0CG@MBLHCBEE@standalone?5accepts?5only?5?8yes?8?5o@ DB 'standalone '
	DB	'accepts only ''yes'' or ''no''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CMOJKGNC@Invalid?5XML?5encoding?5name@
CONST	SEGMENT
??_C@_0BK@CMOJKGNC@Invalid?5XML?5encoding?5name@ DB 'Invalid XML encoding'
	DB	' name', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGHHEGNE@String?5not?5started?5expecting?5?8?5@
CONST	SEGMENT
??_C@_0CE@EGHHEGNE@String?5not?5started?5expecting?5?8?5@ DB 'String not '
	DB	'started expecting '' or "', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GLDIEMIA@String?5not?5closed?5expecting?5?$CC?5o@
CONST	SEGMENT
??_C@_0CD@GLDIEMIA@String?5not?5closed?5expecting?5?$CC?5o@ DB 'String no'
	DB	't closed expecting " or ''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FLAMKNN@expected?5?8?$DN?8@
CONST	SEGMENT
??_C@_0N@FLAMKNN@expected?5?8?$DN?8@ DB 'expected ''=''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ELMJBAIC@EndTag?3?5?8?$DM?1?8?5not?5found@
CONST	SEGMENT
??_C@_0BH@ELMJBAIC@EndTag?3?5?8?$DM?1?8?5not?5found@ DB 'EndTag: ''</'' n'
	DB	'ot found', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NIFLODD@DOCTYPE?5improperly?5terminated@
CONST	SEGMENT
??_C@_0BO@NIFLODD@DOCTYPE?5improperly?5terminated@ DB 'DOCTYPE improperly'
	DB	' terminated', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KLEMOBLL@EntityRef?3?5expecting?5?8?$DL?8@
CONST	SEGMENT
??_C@_0BJ@KLEMOBLL@EntityRef?3?5expecting?5?8?$DL?8@ DB 'EntityRef: expec'
	DB	'ting '';''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@LJALGGHL@external?5parsed?5entities?5cannot@
CONST	SEGMENT
??_C@_0CO@LJALGGHL@external?5parsed?5entities?5cannot@ DB 'external parse'
	DB	'd entities cannot be standalone', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DOCCAFM@parsing?5XML?5declaration?3?5?8?$DP?$DO?8?5e@
CONST	SEGMENT
??_C@_0CH@DOCCAFM@parsing?5XML?5declaration?3?5?8?$DP?$DO?8?5e@ DB 'parsi'
	DB	'ng XML declaration: ''?>'' expected', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HHECNJCA@Text?5declaration?5?8?$DM?$DPxml?8?5requir@
CONST	SEGMENT
??_C@_0CC@HHECNJCA@Text?5declaration?5?8?$DM?$DPxml?8?5requir@ DB 'Text d'
	DB	'eclaration ''<?xml'' required', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@OHPJFFIN@XML?5conditional?5section?5not?5clo@
CONST	SEGMENT
??_C@_0CD@OHPJFFIN@XML?5conditional?5section?5not?5clo@ DB 'XML condition'
	DB	'al section not closed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@JDEKAAA@conditional?5section?5INCLUDE?5or?5@
CONST	SEGMENT
??_C@_0DH@JDEKAAA@conditional?5section?5INCLUDE?5or?5@ DB 'conditional se'
	DB	'ction INCLUDE or IGNORE keyword expected', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HHCGNGIK@Content?5error?5in?5the?5external?5s@
CONST	SEGMENT
??_C@_0CF@HHCGNGIK@Content?5error?5in?5the?5external?5s@ DB 'Content erro'
	DB	'r in the external subset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GGBMHDE@XML?5conditional?5section?5?8?$FL?8?5exp@
CONST	SEGMENT
??_C@_0CF@GGBMHDE@XML?5conditional?5section?5?8?$FL?8?5exp@ DB 'XML condi'
	DB	'tional section ''['' expected', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HPGHEIE@expected?5?8?$DO?8@
CONST	SEGMENT
??_C@_0N@HPGHEIE@expected?5?8?$DO?8@ DB 'expected ''>''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@CEDHFOGD@PEReference?3?5forbidden?5within?5m@
CONST	SEGMENT
??_C@_0DN@CEDHFOGD@PEReference?3?5forbidden?5within?5m@ DB 'PEReference: '
	DB	'forbidden within markup decl in internal subset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@EHNJPHMB@ContentDecl?5?3?5?8?0?8?5?8?$HM?8?5or?5?8?$CJ?8?5ex@
CONST	SEGMENT
??_C@_0CG@EHNJPHMB@ContentDecl?5?3?5?8?0?8?5?8?$HM?8?5or?5?8?$CJ?8?5ex@ DB 'C'
	DB	'ontentDecl : '','' ''|'' or '')'' expected', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NHADBOBB@ContentDecl?5?3?5Name?5or?5?8?$CI?8?5expec@
CONST	SEGMENT
??_C@_0CD@NHADBOBB@ContentDecl?5?3?5Name?5or?5?8?$CI?8?5expec@ DB 'Conten'
	DB	'tDecl : Name or ''('' expected', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HEHENOGB@MixedContentDecl?5?3?5?8?$CDPCDATA?8?5ex@
CONST	SEGMENT
??_C@_0CG@HEHENOGB@MixedContentDecl?5?3?5?8?$CDPCDATA?8?5ex@ DB 'MixedCon'
	DB	'tentDecl : ''#PCDATA'' expected', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LOAMKAA@MixedContentDecl?5?3?5?8?$HM?8?5or?5?8?$CJ?$CK?8?5@
CONST	SEGMENT
??_C@_0CI@LOAMKAA@MixedContentDecl?5?3?5?8?$HM?8?5or?5?8?$CJ?$CK?8?5@ DB 'M'
	DB	'ixedContentDecl : ''|'' or '')*'' expected', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KPIIIINI@?8?$CJ?8?5required?5to?5finish?5ATTLIST?5@
CONST	SEGMENT
??_C@_0CL@KPIIIINI@?8?$CJ?8?5required?5to?5finish?5ATTLIST?5@ DB ''')'' r'
	DB	'equired to finish ATTLIST enumeration', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EHCBGKID@NmToken?5expected?5in?5ATTLIST?5enu@
CONST	SEGMENT
??_C@_0CI@EHCBGKID@NmToken?5expected?5in?5ATTLIST?5enu@ DB 'NmToken expec'
	DB	'ted in ATTLIST enumeration', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NNFMCGNH@?8?$CI?8?5required?5to?5start?5ATTLIST?5e@
CONST	SEGMENT
??_C@_0CK@NNFMCGNH@?8?$CI?8?5required?5to?5start?5ATTLIST?5e@ DB '''('' r'
	DB	'equired to start ATTLIST enumeration', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DMGJOFPK@Fragment?5not?5allowed@
CONST	SEGMENT
??_C@_0BF@DMGJOFPK@Fragment?5not?5allowed@ DB 'Fragment not allowed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LMNHCPFE@Entity?5value?5required@
CONST	SEGMENT
??_C@_0BG@LMNHCPFE@Entity?5value?5required@ DB 'Entity value required', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MHMGOJAD@?8?$DO?8?5required?5to?5close?5NOTATION?5@
CONST	SEGMENT
??_C@_0CL@MHMGOJAD@?8?$DO?8?5required?5to?5close?5NOTATION?5@ DB '''>'' r'
	DB	'equired to close NOTATION declaration', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HECCFNBP@NOTATION?3?5Name?5expected?5here@
CONST	SEGMENT
??_C@_0BN@HECCFNBP@NOTATION?3?5Name?5expected?5here@ DB 'NOTATION: Name e'
	DB	'xpected here', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KMPMBNCM@Invalid?5PI?5name@
CONST	SEGMENT
??_C@_0BA@KMPMBNCM@Invalid?5PI?5name@ DB 'Invalid PI name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HPBPCNCM@xmlParsePI?5?3?5no?5target?5name@
CONST	SEGMENT
??_C@_0BM@HPBPCNCM@xmlParsePI?5?3?5no?5target?5name@ DB 'xmlParsePI : no '
	DB	'target name', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IKEFGBAE@Comment?5must?5not?5contain?5?8?9?9?8?5?$CI@
CONST	SEGMENT
??_C@_0CO@IKEFGBAE@Comment?5must?5not?5contain?5?8?9?9?8?5?$CI@ DB 'Comme'
	DB	'nt must not contain ''--'' (double-hyphen)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@ICNPKBIN@PUBLIC?0?5the?5Public?5Identifier?5i@
CONST	SEGMENT
??_C@_0CJ@ICNPKBIN@PUBLIC?0?5the?5Public?5Identifier?5i@ DB 'PUBLIC, the '
	DB	'Public Identifier is missing', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GDPMMHJJ@SYSTEM?5or?5PUBLIC?0?5the?5URI?5is?5mi@
CONST	SEGMENT
??_C@_0CF@GDPMMHJJ@SYSTEM?5or?5PUBLIC?0?5the?5URI?5is?5mi@ DB 'SYSTEM or '
	DB	'PUBLIC, the URI is missing', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PLPMIKHI@Sequence?5?8?$FN?$FN?$DO?8?5not?5allowed?5in?5c@
CONST	SEGMENT
??_C@_0CG@PLPMIKHI@Sequence?5?8?$FN?$FN?$DO?8?5not?5allowed?5in?5c@ DB 'S'
	DB	'equence '']]>'' not allowed in content', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@PIPOCKJD@Unfinished?5System?5or?5Public?5ID?5@
CONST	SEGMENT
??_C@_0CP@PIPOCKJD@Unfinished?5System?5or?5Public?5ID?5@ DB 'Unfinished S'
	DB	'ystem or Public ID " or '' expected', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NINNHDOL@SystemLiteral?5?$CC?5or?5?8?5expected@
CONST	SEGMENT
??_C@_0BO@NINNHDOL@SystemLiteral?5?$CC?5or?5?8?5expected@ DB 'SystemLiter'
	DB	'al " or '' expected', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FNIFNHDI@Unescaped?5?8?$DM?8?5not?5allowed?5in?5at@
CONST	SEGMENT
??_C@_0CP@FNIFNHDI@Unescaped?5?8?$DM?8?5not?5allowed?5in?5at@ DB 'Unescap'
	DB	'ed ''<'' not allowed in attributes values', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ELBMECGA@AttValue?3?5?$CC?5or?5?8?5expected@
CONST	SEGMENT
??_C@_0BK@ELBMECGA@AttValue?3?5?$CC?5or?5?8?5expected@ DB 'AttValue: " or'
	DB	' '' expected', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GAJOCPOL@PEReferences?5forbidden?5in?5inter@
CONST	SEGMENT
??_C@_0CK@GAJOCPOL@PEReferences?5forbidden?5in?5inter@ DB 'PEReferences f'
	DB	'orbidden in internal subset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DPACNJHE@EntityValue?3?5?$CC?5or?5?8?5expected@
CONST	SEGMENT
??_C@_0BN@DPACNJHE@EntityValue?3?5?$CC?5or?5?8?5expected@ DB 'EntityValue'
	DB	': " or '' expected', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LFHGNGFD@Detected?5an?5entity?5reference?5lo@
CONST	SEGMENT
??_C@_0CC@LFHGNGFD@Detected?5an?5entity?5reference?5lo@ DB 'Detected an e'
	DB	'ntity reference loop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PFALGNCI@PEReference?3?5expecting?5?8?$DL?8@
CONST	SEGMENT
??_C@_0BL@PFALGNCI@PEReference?3?5expecting?5?8?$DL?8@ DB 'PEReference: e'
	DB	'xpecting '';''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DCHKIALM@PEReference?3?5no?5name@
CONST	SEGMENT
??_C@_0BF@DCHKIALM@PEReference?3?5no?5name@ DB 'PEReference: no name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JMKGIIGE@PEReference?5in?5epilog@
CONST	SEGMENT
??_C@_0BG@JMKGIIGE@PEReference?5in?5epilog@ DB 'PEReference in epilog', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GLMIGPKG@PEReference?5in?5prolog@
CONST	SEGMENT
??_C@_0BG@GLMIGPKG@PEReference?5in?5prolog@ DB 'PEReference in prolog', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MALDLPDI@PEReference?5at?5end?5of?5document@
CONST	SEGMENT
??_C@_0BP@MALDLPDI@PEReference?5at?5end?5of?5document@ DB 'PEReference at'
	DB	' end of document', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LPIEGNHB@internal?5error@
CONST	SEGMENT
??_C@_0P@LPIEGNHB@internal?5error@ DB 'internal error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OCLALBPG@CharRef?3?5invalid?5value@
CONST	SEGMENT
??_C@_0BH@OCLALBPG@CharRef?3?5invalid?5value@ DB 'CharRef: invalid value', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DEJKBBIB@CharRef?3?5invalid?5decimal?5value@
CONST	SEGMENT
??_C@_0BP@DEJKBBIB@CharRef?3?5invalid?5decimal?5value@ DB 'CharRef: inval'
	DB	'id decimal value', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IIBKOMHK@CharRef?3?5invalid?5hexadecimal?5va@
CONST	SEGMENT
??_C@_0CD@IIBKOMHK@CharRef?3?5invalid?5hexadecimal?5va@ DB 'CharRef: inva'
	DB	'lid hexadecimal value', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GJOEMOIC@Attribute?5?$CFs?3?$CFs?5redefined?6@
CONST	SEGMENT
??_C@_0BL@GJOEMOIC@Attribute?5?$CFs?3?$CFs?5redefined?6@ DB 'Attribute %s'
	DB	':%s redefined', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LJKBJNKP@Attribute?5?$CFs?5redefined?6@
CONST	SEGMENT
??_C@_0BI@LJKBJNKP@Attribute?5?$CFs?5redefined?6@ DB 'Attribute %s redefi'
	DB	'ned', 0aH, 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
_xmlW3CPIs DD	FLAT:??_C@_0P@HPOCOPDB@xml?9stylesheet@
	DD	FLAT:??_C@_09OBPBGIJC@xml?9model@
	DD	00H
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlDoRead
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_URL$ = 12						; size = 4
_encoding$ = 16						; size = 4
_options$ = 20						; size = 4
_reuse$ = 24						; size = 4
_xmlDoRead PROC						; COMDAT

; 15184: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _encoding$[ebp]
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	edi
	push	DWORD PTR _options$[ebp]
	push	esi
	call	_xmlCtxtUseOptionsInternal
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN3@xmlDoRead

; 15185:     xmlDocPtr ret;
; 15186: 
; 15187:     xmlCtxtUseOptionsInternal(ctxt, options, encoding);
; 15188:     if (encoding != NULL) {
; 15189:         xmlCharEncodingHandlerPtr hdlr;
; 15190: 
; 15191: 	hdlr = xmlFindCharEncodingHandler(encoding);

	push	edi
	call	_xmlFindCharEncodingHandler
	add	esp, 4

; 15192: 	if (hdlr != NULL)

	test	eax, eax
	je	SHORT $LN3@xmlDoRead

; 15193: 	    xmlSwitchToEncoding(ctxt, hdlr);

	push	eax
	push	esi
	call	_xmlSwitchToEncoding
	add	esp, 8
$LN3@xmlDoRead:

; 15194:     }
; 15195:     if ((URL != NULL) && (ctxt->input != NULL) &&

	mov	eax, DWORD PTR _URL$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlDoRead
	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	je	SHORT $LN4@xmlDoRead
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN4@xmlDoRead

; 15196:         (ctxt->input->filename == NULL))
; 15197:         ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);

	push	eax
	call	_xmlStrdup
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
	mov	DWORD PTR [ecx+4], eax
$LN4@xmlDoRead:

; 15198:     xmlParseDocument(ctxt);

	push	esi
	call	_xmlParseDocument
	add	esp, 4

; 15199:     if ((ctxt->wellFormed) || ctxt->recovery)

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN7@xmlDoRead
	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN7@xmlDoRead

; 15201:     else {
; 15202:         ret = NULL;
; 15203: 	if (ctxt->myDoc != NULL) {

	mov	eax, DWORD PTR [esi+8]
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN8@xmlDoRead

; 15204: 	    xmlFreeDoc(ctxt->myDoc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
	jmp	SHORT $LN8@xmlDoRead
$LN7@xmlDoRead:

; 15200:         ret = ctxt->myDoc;

	mov	edi, DWORD PTR [esi+8]
$LN8@xmlDoRead:

; 15205: 	}
; 15206:     }
; 15207:     ctxt->myDoc = NULL;
; 15208:     if (!reuse) {

	cmp	DWORD PTR _reuse$[ebp], 0
	mov	DWORD PTR [esi+8], 0
	jne	SHORT $LN11@xmlDoRead

; 15209: 	xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4
$LN11@xmlDoRead:

; 15210:     }
; 15211: 
; 15212:     return (ret);
; 15213: }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlDoRead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseCheckTransition
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_chunk$ = 12						; size = 4
_size$ = 16						; size = 4
_xmlParseCheckTransition PROC				; COMDAT

; 12084: xmlParseCheckTransition(xmlParserCtxtPtr ctxt, const char *chunk, int size) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlParseCh

; 12085:     if ((ctxt == NULL) || (chunk == NULL) || (size < 0))

	mov	eax, DWORD PTR _chunk$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlParseCh
	mov	ecx, DWORD PTR _size$[ebp]
	test	ecx, ecx
	js	SHORT $LN3@xmlParseCh

; 12087:     if (ctxt->instate == XML_PARSER_START_TAG) {

	mov	edx, DWORD PTR [esi+172]
	cmp	edx, 6
	je	SHORT $LN15@xmlParseCh

; 12088:         if (memchr(chunk, '>', size) != NULL)
; 12089:             return(1);
; 12090:         return(0);
; 12091:     }
; 12092:     if (ctxt->progressive == XML_PARSER_COMMENT) {

	mov	esi, DWORD PTR [esi+292]
	cmp	esi, 5
	je	SHORT $LN15@xmlParseCh

; 12093:         if (memchr(chunk, '>', size) != NULL)
; 12094:             return(1);
; 12095:         return(0);
; 12096:     }
; 12097:     if (ctxt->instate == XML_PARSER_CDATA_SECTION) {

	cmp	edx, 8
	je	SHORT $LN15@xmlParseCh

; 12098:         if (memchr(chunk, '>', size) != NULL)
; 12099:             return(1);
; 12100:         return(0);
; 12101:     }
; 12102:     if (ctxt->progressive == XML_PARSER_PI) {

	cmp	esi, 2
	je	SHORT $LN15@xmlParseCh

; 12103:         if (memchr(chunk, '>', size) != NULL)
; 12104:             return(1);
; 12105:         return(0);
; 12106:     }
; 12107:     if (ctxt->instate == XML_PARSER_END_TAG) {

	cmp	edx, 9
	je	SHORT $LN15@xmlParseCh

; 12108:         if (memchr(chunk, '>', size) != NULL)
; 12109:             return(1);
; 12110:         return(0);
; 12111:     }
; 12112:     if ((ctxt->progressive == XML_PARSER_DTD) ||

	cmp	esi, 3
	je	SHORT $LN15@xmlParseCh
	cmp	edx, 3
	jne	SHORT $LN20@xmlParseCh
$LN15@xmlParseCh:

; 12113:         (ctxt->instate == XML_PARSER_DTD)) {
; 12114:         if (memchr(chunk, '>', size) != NULL)
; 12115:             return(1);

	push	ecx
	push	62					; 0000003eH
	push	eax
	call	_memchr
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN16@xmlParseCh
$LN20@xmlParseCh:

; 12117:     }
; 12118:     return(1);
; 12119: }

	mov	eax, 1
	pop	esi
	pop	ebp
	ret	0
$LN16@xmlParseCh:

; 12116:         return(0);

	xor	eax, eax
	pop	esi

; 12117:     }
; 12118:     return(1);
; 12119: }

	pop	ebp
	ret	0
$LN3@xmlParseCh:

; 12086:         return(-1);

	or	eax, -1
	pop	esi

; 12117:     }
; 12118:     return(1);
; 12119: }

	pop	ebp
	ret	0
_xmlParseCheckTransition ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseTryOrFinish
_TEXT	SEGMENT
_buffer$1 = -188					; size = 150
tv7442 = -36						; size = 4
_lastlt$ = -32						; size = 4
_cons$1$ = -28						; size = 4
_nsNr$1$ = -28						; size = 4
_lastgt$1$ = -24					; size = 4
_start$2 = -20						; size = 4
_lastgt$ = -16						; size = 4
_buf$1$ = -12						; size = 4
_URI$3 = -12						; size = 4
_buf$1$ = -8						; size = 4
_buf$1$ = -8						; size = 4
_buf$1$ = -8						; size = 4
_buf$1$ = -8						; size = 4
_base$1$ = -8						; size = 4
_tlen$ = -8						; size = 4
_ret$1$ = -4						; size = 4
$T4 = 8							; size = 4
$T5 = 8							; size = 4
$T6 = 8							; size = 4
$T7 = 8							; size = 4
_buf$1$ = 8						; size = 4
_test$1$ = 8						; size = 4
_prefix$8 = 8						; size = 4
_ctxt$ = 8						; size = 4
_quote$1$ = 11						; size = 1
_terminate$ = 12					; size = 4
_xmlParseTryOrFinish PROC				; COMDAT

; 11089: xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int terminate) {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	mov	DWORD PTR _ret$1$[ebp], esi
	mov	ecx, DWORD PTR [ebx+36]
	test	ecx, ecx
	je	$LN530@xmlParseTr

; 11090:     int ret = 0;
; 11091:     int avail, tlen;
; 11092:     xmlChar cur, next;
; 11093:     const xmlChar *lastlt, *lastgt;
; 11094: 
; 11095:     if (ctxt->input == NULL)
; 11096:         return(0);
; 11097: 
; 11098: #ifdef DEBUG_PUSH
; 11099:     switch (ctxt->instate) {
; 11100: 	case XML_PARSER_EOF:
; 11101: 	    xmlGenericError(xmlGenericErrorContext,
; 11102: 		    "PP: try EOF\n"); break;
; 11103: 	case XML_PARSER_START:
; 11104: 	    xmlGenericError(xmlGenericErrorContext,
; 11105: 		    "PP: try START\n"); break;
; 11106: 	case XML_PARSER_MISC:
; 11107: 	    xmlGenericError(xmlGenericErrorContext,
; 11108: 		    "PP: try MISC\n");break;
; 11109: 	case XML_PARSER_COMMENT:
; 11110: 	    xmlGenericError(xmlGenericErrorContext,
; 11111: 		    "PP: try COMMENT\n");break;
; 11112: 	case XML_PARSER_PROLOG:
; 11113: 	    xmlGenericError(xmlGenericErrorContext,
; 11114: 		    "PP: try PROLOG\n");break;
; 11115: 	case XML_PARSER_START_TAG:
; 11116: 	    xmlGenericError(xmlGenericErrorContext,
; 11117: 		    "PP: try START_TAG\n");break;
; 11118: 	case XML_PARSER_CONTENT:
; 11119: 	    xmlGenericError(xmlGenericErrorContext,
; 11120: 		    "PP: try CONTENT\n");break;
; 11121: 	case XML_PARSER_CDATA_SECTION:
; 11122: 	    xmlGenericError(xmlGenericErrorContext,
; 11123: 		    "PP: try CDATA_SECTION\n");break;
; 11124: 	case XML_PARSER_END_TAG:
; 11125: 	    xmlGenericError(xmlGenericErrorContext,
; 11126: 		    "PP: try END_TAG\n");break;
; 11127: 	case XML_PARSER_ENTITY_DECL:
; 11128: 	    xmlGenericError(xmlGenericErrorContext,
; 11129: 		    "PP: try ENTITY_DECL\n");break;
; 11130: 	case XML_PARSER_ENTITY_VALUE:
; 11131: 	    xmlGenericError(xmlGenericErrorContext,
; 11132: 		    "PP: try ENTITY_VALUE\n");break;
; 11133: 	case XML_PARSER_ATTRIBUTE_VALUE:
; 11134: 	    xmlGenericError(xmlGenericErrorContext,
; 11135: 		    "PP: try ATTRIBUTE_VALUE\n");break;
; 11136: 	case XML_PARSER_DTD:
; 11137: 	    xmlGenericError(xmlGenericErrorContext,
; 11138: 		    "PP: try DTD\n");break;
; 11139: 	case XML_PARSER_EPILOG:
; 11140: 	    xmlGenericError(xmlGenericErrorContext,
; 11141: 		    "PP: try EPILOG\n");break;
; 11142: 	case XML_PARSER_PI:
; 11143: 	    xmlGenericError(xmlGenericErrorContext,
; 11144: 		    "PP: try PI\n");break;
; 11145:         case XML_PARSER_IGNORE:
; 11146:             xmlGenericError(xmlGenericErrorContext,
; 11147: 		    "PP: try IGNORE\n");break;
; 11148:     }
; 11149: #endif
; 11150: 
; 11151:     if ((ctxt->input != NULL) &&

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 4096				; 00001000H
	jle	SHORT $LN34@xmlParseTr

; 11152:         (ctxt->input->cur - ctxt->input->base > 4096)) {
; 11153: 	xmlSHRINK(ctxt);

	push	ebx
	call	_xmlSHRINK
	add	esp, 4

; 11154: 	ctxt->checkIndex = 0;

	mov	DWORD PTR [ebx+204], esi
$LN34@xmlParseTr:

; 11155:     }
; 11156:     xmlParseGetLasts(ctxt, &lastlt, &lastgt);

	lea	eax, DWORD PTR _lastgt$[ebp]
	push	eax
	lea	eax, DWORD PTR _lastlt$[ebp]
	push	eax
	push	ebx
	call	_xmlParseGetLasts

; 11157: 
; 11158:     while (ctxt->instate != XML_PARSER_EOF) {

	mov	eax, DWORD PTR [ebx+172]
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	je	$done$729
	mov	ecx, DWORD PTR __imp__strncmp
	mov	DWORD PTR tv7442[ebp], ecx
	mov	ecx, DWORD PTR _lastgt$[ebp]
	mov	DWORD PTR _lastgt$1$[ebp], ecx
$LN717@xmlParseTr:

; 11159: 	if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))

	cmp	DWORD PTR [ebx+84], 0
	mov	edx, DWORD PTR _terminate$[ebp]
	je	SHORT $LN35@xmlParseTr
	cmp	DWORD PTR [ebx+212], 1
	je	$LN530@xmlParseTr
$LN35@xmlParseTr:

; 11160: 	    return(0);
; 11161: 
; 11162: 	if (ctxt->input == NULL) break;

	mov	edi, DWORD PTR [ebx+36]
	mov	DWORD PTR $T7[ebp], edi
	test	edi, edi
	je	$LN699@xmlParseTr

; 11163: 	if (ctxt->input->buf == NULL)

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN37@xmlParseTr

; 11164: 	    avail = ctxt->input->length -

	mov	esi, DWORD PTR [edi+24]
	sub	esi, DWORD PTR [edi+16]
	add	esi, DWORD PTR [edi+12]
	jmp	SHORT $LN38@xmlParseTr
$LN37@xmlParseTr:

; 11165: 	            (ctxt->input->cur - ctxt->input->base);
; 11166: 	else {
; 11167: 	    /*
; 11168: 	     * If we are operating on converted input, try to flush
; 11169: 	     * remainng chars to avoid them stalling in the non-converted
; 11170: 	     * buffer. But do not do this in document start where
; 11171: 	     * encoding="..." may not have been read and we work on a
; 11172: 	     * guessed encoding.
; 11173: 	     */
; 11174: 	    if ((ctxt->instate != XML_PARSER_START) &&
; 11175: 	        (ctxt->input->buf->raw != NULL) &&

	test	eax, eax
	je	SHORT $LN39@xmlParseTr
	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN39@xmlParseTr
	push	eax
	call	_xmlBufIsEmpty
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN39@xmlParseTr

; 11176: 		(xmlBufIsEmpty(ctxt->input->buf->raw) == 0)) {
; 11177:                 size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer,

	mov	eax, DWORD PTR [ebx+36]
	push	eax
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+16]
	call	_xmlBufGetInputBase
	mov	edi, eax

; 11178:                                                  ctxt->input);
; 11179: 		size_t current = ctxt->input->cur - ctxt->input->base;

	mov	eax, DWORD PTR [ebx+36]

; 11180: 
; 11181: 		xmlParserInputBufferPush(ctxt->input->buf, 0, "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	0
	mov	esi, DWORD PTR [eax+16]
	push	DWORD PTR [eax]
	sub	esi, DWORD PTR [eax+12]
	call	_xmlParserInputBufferPush

; 11182:                 xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input,

	mov	eax, DWORD PTR [ebx+36]
	push	esi
	push	edi
	push	eax
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+16]
	call	_xmlBufSetInputBaseCur
	add	esp, 36					; 00000024H
$LN39@xmlParseTr:

; 11183:                                       base, current);
; 11184: 	    }
; 11185: 	    avail = xmlBufUse(ctxt->input->buf->buffer) -

	mov	edi, DWORD PTR [ebx+36]
	mov	eax, edi
	mov	DWORD PTR $T7[ebp], edi
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	mov	edx, DWORD PTR _terminate$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR [edi+12]
	add	esp, 4
	sub	eax, DWORD PTR [edi+16]
	add	esi, eax
$LN38@xmlParseTr:

; 11186: 		    (ctxt->input->cur - ctxt->input->base);
; 11187: 	}
; 11188:         if (avail < 1)

	cmp	esi, 1
	jl	$LN699@xmlParseTr

; 11189: 	    goto done;
; 11190:         switch (ctxt->instate) {

	mov	eax, DWORD PTR [ebx+172]
	inc	eax
	cmp	eax, 17					; 00000011H
	ja	$LN4@xmlParseTr
	jmp	DWORD PTR $LN728@xmlParseTr[eax*4]
$LN42@xmlParseTr:

; 11191:             case XML_PARSER_EOF:
; 11192: 	        /*
; 11193: 		 * Document parsing is done !
; 11194: 		 */
; 11195: 	        goto done;
; 11196:             case XML_PARSER_START:
; 11197: 		if (ctxt->charset == XML_CHAR_ENCODING_NONE) {

	cmp	DWORD PTR [ebx+256], 0
	jne	SHORT $LN43@xmlParseTr

; 11198: 		    xmlChar start[4];
; 11199: 		    xmlCharEncoding enc;
; 11200: 
; 11201: 		    /*
; 11202: 		     * Very first chars read from the document flow.
; 11203: 		     */
; 11204: 		    if (avail < 4)

	cmp	esi, 4
	jl	$LN699@xmlParseTr

; 11205: 			goto done;
; 11206: 
; 11207: 		    /*
; 11208: 		     * Get the 4 first bytes and decode the charset
; 11209: 		     * if enc != XML_CHAR_ENCODING_NONE
; 11210: 		     * plug some encoding conversion routines,
; 11211: 		     * else xmlSwitchEncoding will set to (default)
; 11212: 		     * UTF8.
; 11213: 		     */
; 11214: 		    start[0] = RAW;

	mov	eax, DWORD PTR [edi+16]

; 11215: 		    start[1] = NXT(1);
; 11216: 		    start[2] = NXT(2);
; 11217: 		    start[3] = NXT(3);
; 11218: 		    enc = xmlDetectCharEncoding(start, 4);

	push	4
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR _start$2[ebp], al
	mov	eax, DWORD PTR [edi+16]
	mov	al, BYTE PTR [eax+1]
	mov	BYTE PTR _start$2[ebp+1], al
	mov	eax, DWORD PTR [edi+16]
	mov	al, BYTE PTR [eax+2]
	mov	BYTE PTR _start$2[ebp+2], al
	mov	eax, DWORD PTR [edi+16]
	mov	al, BYTE PTR [eax+3]
	mov	BYTE PTR _start$2[ebp+3], al
	lea	eax, DWORD PTR _start$2[ebp]
	push	eax
	call	_xmlDetectCharEncoding

; 11219: 		    xmlSwitchEncoding(ctxt, enc);

	push	eax
	push	ebx
	call	_xmlSwitchEncoding
	add	esp, 16					; 00000010H

; 11220: 		    break;

	jmp	$LN4@xmlParseTr
$LN43@xmlParseTr:

; 11221: 		}
; 11222: 
; 11223: 		if (avail < 2)

	cmp	esi, 2
	jl	$LN699@xmlParseTr

; 11224: 		    goto done;
; 11225: 		cur = ctxt->input->cur[0];

	mov	eax, DWORD PTR [edi+16]
	mov	cl, BYTE PTR [eax]

; 11226: 		next = ctxt->input->cur[1];
; 11227: 		if (cur == 0) {

	test	cl, cl
	je	$LN486@xmlParseTr

; 11230: 						      &xmlDefaultSAXLocator);
; 11231: 		    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
; 11232: 		    xmlHaltParser(ctxt);
; 11233: #ifdef DEBUG_PUSH
; 11234: 		    xmlGenericError(xmlGenericErrorContext,
; 11235: 			    "PP: entering EOF\n");
; 11236: #endif
; 11237: 		    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
; 11238: 			ctxt->sax->endDocument(ctxt->userData);
; 11239: 		    goto done;
; 11240: 		}
; 11241: 	        if ((cur == '<') && (next == '?')) {

	cmp	cl, 60					; 0000003cH
	jne	$LN49@xmlParseTr
	cmp	BYTE PTR [eax+1], 63			; 0000003fH
	jne	$LN49@xmlParseTr

; 11242: 		    /* PI or XML decl */
; 11243: 		    if (avail < 5) return(ret);

	cmp	esi, 5
	jl	SHORT $LN488@xmlParseTr

; 11244: 		    if ((!terminate) &&

	test	edx, edx
	jne	SHORT $LN52@xmlParseTr

; 10899:     base = in->cur - in->base;

	mov	edi, DWORD PTR [edi+12]
	sub	eax, edi

; 10900:     if (base < 0) return(-1);

	js	SHORT $LN488@xmlParseTr

; 10901:     if (ctxt->checkIndex > base)

	mov	esi, DWORD PTR [ebx+204]

; 10902:         base = ctxt->checkIndex;
; 10903:     if (in->buf == NULL) {

	cmp	esi, eax
	cmovle	esi, eax
	mov	eax, DWORD PTR $T7[ebp]
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN257@xmlParseTr

; 10904: 	buf = in->base;
; 10905: 	len = in->length;

	mov	ecx, DWORD PTR [eax+24]

; 10906:     } else {

	jmp	SHORT $LN258@xmlParseTr
$LN257@xmlParseTr:

; 10907: 	buf = xmlBufContent(in->buf->buffer);

	push	DWORD PTR [ecx+16]
	call	_xmlBufContent
	mov	edi, eax

; 10908: 	len = xmlBufUse(in->buf->buffer);

	mov	eax, DWORD PTR $T7[ebp]
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	mov	ecx, eax
	add	esp, 8
	mov	eax, DWORD PTR $T7[ebp]
$LN258@xmlParseTr:

; 10909:     }
; 10910:     /* take into account the sequence length */
; 10911:     if (third) len -= 2;
; 10912:     else if (next) len --;

	dec	ecx

; 10913:     for (;base < len;base++) {

	cmp	esi, ecx
	jge	SHORT $LN605@xmlParseTr
$LL253@xmlParseTr:

; 10914:         if (buf[base] == first) {

	cmp	BYTE PTR [edi+esi], 63			; 0000003fH
	jne	SHORT $LN251@xmlParseTr

; 10915: 	    if (third != 0) {
; 10916: 		if ((buf[base + 1] != next) ||
; 10917: 		    (buf[base + 2] != third)) continue;
; 10918: 	    } else if (next != 0) {
; 10919: 		if (buf[base + 1] != next) continue;

	cmp	BYTE PTR [edi+esi+1], 62		; 0000003eH
	je	SHORT $LN265@xmlParseTr
$LN251@xmlParseTr:

; 10913:     for (;base < len;base++) {

	inc	esi
	cmp	esi, ecx
	jl	SHORT $LL253@xmlParseTr
$LN605@xmlParseTr:

; 10937: 	}
; 10938:     }
; 10939:     ctxt->checkIndex = base;

	mov	DWORD PTR [ebx+204], esi
$LN488@xmlParseTr:

; 11245: 		        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))
; 11246: 			return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 12066: 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 12067: 		     BAD_CAST buffer, NULL);
; 12068:     }
; 12069:     return(0);
; 12070: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN265@xmlParseTr:

; 10921: 	    ctxt->checkIndex = 0;

	mov	DWORD PTR [ebx+204], 0

; 10922: #ifdef DEBUG_PUSH
; 10923: 	    if (next == 0)
; 10924: 		xmlGenericError(xmlGenericErrorContext,
; 10925: 			"PP: lookup '%c' found at %d\n",
; 10926: 			first, base);
; 10927: 	    else if (third == 0)
; 10928: 		xmlGenericError(xmlGenericErrorContext,
; 10929: 			"PP: lookup '%c%c' found at %d\n",
; 10930: 			first, next, base);
; 10931: 	    else
; 10932: 		xmlGenericError(xmlGenericErrorContext,
; 10933: 			"PP: lookup '%c%c%c' found at %d\n",
; 10934: 			first, next, third, base);
; 10935: #endif
; 10936: 	    return(base - (in->cur - in->base));

	sub	esi, DWORD PTR [eax+16]
	add	esi, DWORD PTR [eax+12]

; 11244: 		    if ((!terminate) &&

	js	SHORT $LN488@xmlParseTr
$LN52@xmlParseTr:

; 11247: 		    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))

	mov	esi, DWORD PTR [ebx]
	test	esi, esi
	je	SHORT $LN53@xmlParseTr
	cmp	DWORD PTR [esi+44], 0
	je	SHORT $LN53@xmlParseTr

; 11248: 			ctxt->sax->setDocumentLocator(ctxt->userData,

	call	___xmlDefaultSAXLocator
	push	eax
	push	DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [esi+44]
	call	eax
	add	esp, 8
$LN53@xmlParseTr:

; 11249: 						      &xmlDefaultSAXLocator);
; 11250: 		    if ((ctxt->input->cur[2] == 'x') &&
; 11251: 			(ctxt->input->cur[3] == 'm') &&
; 11252: 			(ctxt->input->cur[4] == 'l') &&

	mov	eax, DWORD PTR [ebx+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax+2], 120			; 00000078H
	jne	$LN54@xmlParseTr
	cmp	BYTE PTR [eax+3], 109			; 0000006dH
	jne	SHORT $LN54@xmlParseTr
	cmp	BYTE PTR [eax+4], 108			; 0000006cH
	jne	SHORT $LN54@xmlParseTr
	mov	al, BYTE PTR [eax+5]
	cmp	al, 32					; 00000020H
	je	SHORT $LN56@xmlParseTr
	cmp	al, 9
	jb	SHORT $LN57@xmlParseTr
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN56@xmlParseTr
$LN57@xmlParseTr:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN54@xmlParseTr
$LN56@xmlParseTr:

; 11253: 			(IS_BLANK_CH(ctxt->input->cur[5]))) {
; 11254: 			ret += 5;

	add	DWORD PTR _ret$1$[ebp], 5

; 11255: #ifdef DEBUG_PUSH
; 11256: 			xmlGenericError(xmlGenericErrorContext,
; 11257: 				"PP: Parsing XML Decl\n");
; 11258: #endif
; 11259: 			xmlParseXMLDecl(ctxt);

	push	ebx
	call	_xmlParseXMLDecl
	add	esp, 4

; 11260: 			if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {

	cmp	DWORD PTR [ebx+84], 32			; 00000020H
	je	$LN489@xmlParseTr

; 11266: 			    return(0);
; 11267: 			}
; 11268: 			ctxt->standalone = ctxt->input->standalone;
; 11269: 			if ((ctxt->encoding == NULL) &&

	cmp	DWORD PTR [ebx+24], 0
	mov	ecx, DWORD PTR [ebx+36]
	mov	eax, DWORD PTR [ecx+52]
	mov	DWORD PTR [ebx+28], eax
	jne	SHORT $LN63@xmlParseTr
	mov	eax, DWORD PTR [ecx+44]
	test	eax, eax
	je	SHORT $LN63@xmlParseTr

; 11270: 			    (ctxt->input->encoding != NULL))
; 11271: 			    ctxt->encoding = xmlStrdup(ctxt->input->encoding);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+24], eax
$LN63@xmlParseTr:

; 11299: 		    }
; 11300: 		    if ((ctxt->sax) && (ctxt->sax->startDocument) &&
; 11301: 		        (!ctxt->disableSAX))
; 11302: 			ctxt->sax->startDocument(ctxt->userData);
; 11303: 		    ctxt->instate = XML_PARSER_MISC;
; 11304: #ifdef DEBUG_PUSH
; 11305: 		    xmlGenericError(xmlGenericErrorContext,
; 11306: 			    "PP: entering MISC\n");
; 11307: #endif
; 11308: 		}
; 11309: 		break;

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN64@xmlParseTr
	mov	eax, DWORD PTR [eax+48]
	test	eax, eax
	je	SHORT $LN64@xmlParseTr
	cmp	DWORD PTR [ebx+212], 0
	jne	SHORT $LN64@xmlParseTr
	push	DWORD PTR [ebx+4]
	call	eax
	add	esp, 4
$LN64@xmlParseTr:
	mov	DWORD PTR [ebx+172], 1
	jmp	$LN4@xmlParseTr
$LN54@xmlParseTr:

; 11272: 			if ((ctxt->sax) && (ctxt->sax->startDocument) &&
; 11273: 			    (!ctxt->disableSAX))
; 11274: 			    ctxt->sax->startDocument(ctxt->userData);
; 11275: 			ctxt->instate = XML_PARSER_MISC;
; 11276: #ifdef DEBUG_PUSH
; 11277: 			xmlGenericError(xmlGenericErrorContext,
; 11278: 				"PP: entering MISC\n");
; 11279: #endif
; 11280: 		    } else {
; 11281: 			ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlCharStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+20], eax

; 11282: 			if ((ctxt->sax) && (ctxt->sax->startDocument) &&
; 11283: 			    (!ctxt->disableSAX))
; 11284: 			    ctxt->sax->startDocument(ctxt->userData);
; 11285: 			ctxt->instate = XML_PARSER_MISC;
; 11286: #ifdef DEBUG_PUSH
; 11287: 			xmlGenericError(xmlGenericErrorContext,
; 11288: 				"PP: entering MISC\n");
; 11289: #endif
; 11290: 		    }
; 11291: 		} else {

	jmp	SHORT $LN63@xmlParseTr
$LN49@xmlParseTr:

; 11292: 		    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))

	mov	esi, DWORD PTR [ebx]
	test	esi, esi
	je	SHORT $LN62@xmlParseTr
	cmp	DWORD PTR [esi+44], 0
	je	SHORT $LN62@xmlParseTr

; 11293: 			ctxt->sax->setDocumentLocator(ctxt->userData,

	call	___xmlDefaultSAXLocator
	push	eax
	push	DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [esi+44]
	call	eax
	add	esp, 8
$LN62@xmlParseTr:

; 11294: 						      &xmlDefaultSAXLocator);
; 11295: 		    ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlCharStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+20], eax

; 11296: 		    if (ctxt->version == NULL) {

	test	eax, eax
	jne	SHORT $LN63@xmlParseTr

; 11297: 		        xmlErrMemory(ctxt, NULL);

	push	eax
	push	ebx
	call	_xmlErrMemory

; 11298: 			break;

	jmp	$LN705@xmlParseTr
$LN65@xmlParseTr:

; 11310:             case XML_PARSER_START_TAG: {
; 11311: 	        const xmlChar *name;
; 11312: 		const xmlChar *prefix = NULL;
; 11313: 		const xmlChar *URI = NULL;
; 11314: 		int nsNr = ctxt->nsNr;

	mov	eax, DWORD PTR [ebx+328]
	mov	DWORD PTR _prefix$8[ebp], 0
	mov	DWORD PTR _URI$3[ebp], 0
	mov	DWORD PTR _nsNr$1$[ebp], eax

; 11315: 
; 11316: 		if ((avail < 2) && (ctxt->inputNr == 1))

	cmp	esi, 2
	jge	SHORT $LN66@xmlParseTr
	cmp	DWORD PTR [ebx+40], 1
	je	$LN699@xmlParseTr
$LN66@xmlParseTr:

; 11317: 		    goto done;
; 11318: 		cur = ctxt->input->cur[0];

	mov	eax, DWORD PTR [edi+16]

; 11319: 	        if (cur != '<') {

	cmp	BYTE PTR [eax], 60			; 0000003cH
	jne	$LN47@xmlParseTr

; 11320: 		    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
; 11321: 		    xmlHaltParser(ctxt);
; 11322: 		    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
; 11323: 			ctxt->sax->endDocument(ctxt->userData);
; 11324: 		    goto done;
; 11325: 		}
; 11326: 		if (!terminate) {

	test	edx, edx
	jne	$LN74@xmlParseTr

; 11327: 		    if (ctxt->progressive) {

	cmp	DWORD PTR [ebx+292], edx
	je	SHORT $LN70@xmlParseTr

; 11328: 		        /* > can be found unescaped in attribute values */
; 11329: 		        if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))

	mov	ecx, DWORD PTR _lastgt$1$[ebp]
	test	ecx, ecx
	je	$LN699@xmlParseTr
	cmp	eax, ecx
	jae	$LN699@xmlParseTr

; 11330: 			    goto done;
; 11331: 		    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {

	jmp	SHORT $LN74@xmlParseTr
$LN70@xmlParseTr:

; 10899:     base = in->cur - in->base;

	mov	ecx, DWORD PTR [edi+12]
	sub	eax, ecx

; 10900:     if (base < 0) return(-1);

	js	$LN699@xmlParseTr

; 10901:     if (ctxt->checkIndex > base)

	mov	esi, DWORD PTR [ebx+204]

; 10902:         base = ctxt->checkIndex;
; 10903:     if (in->buf == NULL) {

	cmp	esi, eax
	cmovle	esi, eax
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN277@xmlParseTr

; 10904: 	buf = in->base;
; 10905: 	len = in->length;

	mov	eax, DWORD PTR [edi+24]

; 10906:     } else {

	jmp	SHORT $LN278@xmlParseTr
$LN277@xmlParseTr:

; 10907: 	buf = xmlBufContent(in->buf->buffer);

	push	DWORD PTR [eax+16]
	call	_xmlBufContent
	mov	DWORD PTR _buf$1$[ebp], eax

; 10908: 	len = xmlBufUse(in->buf->buffer);

	mov	eax, DWORD PTR [edi]
	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	mov	ecx, DWORD PTR _buf$1$[ebp]
	add	esp, 8
$LN278@xmlParseTr:

; 10913:     for (;base < len;base++) {

	cmp	esi, eax
	jge	SHORT $LN594@xmlParseTr
	npad	2
$LL273@xmlParseTr:

; 10914:         if (buf[base] == first) {

	cmp	BYTE PTR [ecx+esi], 62			; 0000003eH
	je	SHORT $LN593@xmlParseTr

; 10913:     for (;base < len;base++) {

	inc	esi
	cmp	esi, eax
	jl	SHORT $LL273@xmlParseTr
$LN594@xmlParseTr:

; 12044: 			"PP: internal error, state == PUBLIC_LITERAL\n");
; 12045: 		ctxt->instate = XML_PARSER_START_TAG;
; 12046: #ifdef DEBUG_PUSH
; 12047: 		xmlGenericError(xmlGenericErrorContext,
; 12048: 			"PP: entering START_TAG\n");
; 12049: #endif
; 12050: 		break;
; 12051: 	}
; 12052:     }
; 12053: done:
; 12054: #ifdef DEBUG_PUSH
; 12055:     xmlGenericError(xmlGenericErrorContext, "PP: done %d\n", ret);
; 12056: #endif
; 12057:     return(ret);

	mov	DWORD PTR [ebx+204], esi
	mov	esi, DWORD PTR _ret$1$[ebp]
	mov	eax, esi
	pop	edi

; 12066: 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 12067: 		     BAD_CAST buffer, NULL);
; 12068:     }
; 12069:     return(0);
; 12070: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN593@xmlParseTr:

; 10921: 	    ctxt->checkIndex = 0;

	mov	DWORD PTR [ebx+204], 0

; 10922: #ifdef DEBUG_PUSH
; 10923: 	    if (next == 0)
; 10924: 		xmlGenericError(xmlGenericErrorContext,
; 10925: 			"PP: lookup '%c' found at %d\n",
; 10926: 			first, base);
; 10927: 	    else if (third == 0)
; 10928: 		xmlGenericError(xmlGenericErrorContext,
; 10929: 			"PP: lookup '%c%c' found at %d\n",
; 10930: 			first, next, base);
; 10931: 	    else
; 10932: 		xmlGenericError(xmlGenericErrorContext,
; 10933: 			"PP: lookup '%c%c%c' found at %d\n",
; 10934: 			first, next, third, base);
; 10935: #endif
; 10936: 	    return(base - (in->cur - in->base));

	sub	esi, DWORD PTR [edi+16]
	add	esi, DWORD PTR [edi+12]

; 11330: 			    goto done;
; 11331: 		    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {

	js	$LN699@xmlParseTr
$LN74@xmlParseTr:

; 11332: 			goto done;
; 11333: 		    }
; 11334: 		}
; 11335: 		if (ctxt->spaceNr == 0)

	cmp	DWORD PTR [ebx+236], 0
	jne	SHORT $LN75@xmlParseTr

; 11336: 		    spacePush(ctxt, -1);

	or	eax, -1
	jmp	SHORT $LN77@xmlParseTr
$LN75@xmlParseTr:

; 11337: 		else if (*ctxt->space == -2)

	mov	eax, DWORD PTR [ebx+232]
	mov	ecx, -1
	mov	eax, DWORD PTR [eax]
	cmp	eax, -2					; fffffffeH
	cmove	eax, ecx
$LN77@xmlParseTr:

; 11338: 		    spacePush(ctxt, -1);
; 11339: 		else
; 11340: 		    spacePush(ctxt, *ctxt->space);
; 11341: #ifdef LIBXML_SAX1_ENABLED
; 11342: 		if (ctxt->sax2)

	push	eax
	push	ebx
	call	_spacePush
	add	esp, 8
	cmp	DWORD PTR [ebx+324], 0
	je	SHORT $LN79@xmlParseTr

; 11343: #endif /* LIBXML_SAX1_ENABLED */
; 11344: 		    name = xmlParseStartTag2(ctxt, &prefix, &URI, &tlen);

	lea	eax, DWORD PTR _tlen$[ebp]
	push	eax
	lea	eax, DWORD PTR _URI$3[ebp]
	push	eax
	lea	eax, DWORD PTR _prefix$8[ebp]
	push	eax
	push	ebx
	call	_xmlParseStartTag2
	add	esp, 16					; 00000010H
	jmp	SHORT $LN706@xmlParseTr
$LN79@xmlParseTr:

; 11345: #ifdef LIBXML_SAX1_ENABLED
; 11346: 		else
; 11347: 		    name = xmlParseStartTag(ctxt);

	push	ebx
	call	_xmlParseStartTag
	add	esp, 4
$LN706@xmlParseTr:

; 11348: #endif /* LIBXML_SAX1_ENABLED */
; 11349: 		if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [ebx+172], -1
	mov	esi, eax
	je	$LN699@xmlParseTr

; 11350: 		    goto done;
; 11351: 		if (name == NULL) {

	test	esi, esi
	je	$LN495@xmlParseTr

; 11357: 		}
; 11358: #ifdef LIBXML_VALID_ENABLED
; 11359: 		/*
; 11360: 		 * [ VC: Root Element Type ]
; 11361: 		 * The Name in the document type declaration must match
; 11362: 		 * the element type of the root element.
; 11363: 		 */
; 11364: 		if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&
; 11365: 		    ctxt->node && (ctxt->node == ctxt->myDoc->children))

	cmp	DWORD PTR [ebx+104], 0
	je	SHORT $LN84@xmlParseTr
	cmp	DWORD PTR [ebx+12], 0
	je	SHORT $LN84@xmlParseTr
	mov	eax, DWORD PTR [ebx+8]
	test	eax, eax
	je	SHORT $LN84@xmlParseTr
	mov	ecx, DWORD PTR [ebx+52]
	test	ecx, ecx
	je	SHORT $LN84@xmlParseTr
	cmp	ecx, DWORD PTR [eax+12]
	jne	SHORT $LN84@xmlParseTr

; 11366: 		    ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);

	push	eax
	lea	eax, DWORD PTR [ebx+108]
	push	eax
	call	_xmlValidateRoot
	add	esp, 8
	and	DWORD PTR [ebx+100], eax
$LN84@xmlParseTr:

; 11367: #endif /* LIBXML_VALID_ENABLED */
; 11368: 
; 11369: 		/*
; 11370: 		 * Check for an Empty Element.
; 11371: 		 */
; 11372: 		if ((RAW == '/') && (NXT(1) == '>')) {

	mov	eax, DWORD PTR [ebx+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	dl, BYTE PTR [ecx]
	cmp	dl, 47					; 0000002fH
	jne	$LN85@xmlParseTr
	cmp	BYTE PTR [ecx+1], 62			; 0000003eH
	jne	$LN85@xmlParseTr

; 11373: 		    SKIP(2);

	add	DWORD PTR [ebx+200], 2
	add	DWORD PTR [eax+16], 2
	mov	eax, DWORD PTR [ebx+36]
	add	DWORD PTR [eax+32], 2
	mov	ecx, DWORD PTR [ebx+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN6@xmlParseTr
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN6@xmlParseTr:

; 11374: 
; 11375: 		    if (ctxt->sax2) {

	cmp	DWORD PTR [ebx+324], 0
	mov	eax, DWORD PTR [ebx]
	je	SHORT $LN87@xmlParseTr

; 11376: 			if ((ctxt->sax != NULL) &&
; 11377: 			    (ctxt->sax->endElementNs != NULL) &&

	test	eax, eax
	je	SHORT $LN89@xmlParseTr
	mov	eax, DWORD PTR [eax+120]
	test	eax, eax
	je	SHORT $LN89@xmlParseTr
	cmp	DWORD PTR [ebx+212], 0
	jne	SHORT $LN89@xmlParseTr

; 11378: 			    (!ctxt->disableSAX))
; 11379: 			    ctxt->sax->endElementNs(ctxt->userData, name,

	mov	edx, DWORD PTR _URI$3[ebp]
	push	edx
	mov	edx, DWORD PTR _prefix$8[ebp]
	push	edx
	push	esi
	push	DWORD PTR [ebx+4]
	call	eax
	add	esp, 16					; 00000010H
$LN89@xmlParseTr:

; 11380: 			                            prefix, URI);
; 11381: 			if (ctxt->nsNr - nsNr > 0)

	mov	eax, DWORD PTR [ebx+328]
	sub	eax, DWORD PTR _nsNr$1$[ebp]
	test	eax, eax
	jle	SHORT $LN91@xmlParseTr

; 11382: 			    nsPop(ctxt, ctxt->nsNr - nsNr);

	push	eax
	push	ebx
	call	_nsPop

; 11383: #ifdef LIBXML_SAX1_ENABLED
; 11384: 		    } else {

	jmp	SHORT $LN707@xmlParseTr
$LN87@xmlParseTr:

; 11385: 			if ((ctxt->sax != NULL) &&
; 11386: 			    (ctxt->sax->endElement != NULL) &&

	test	eax, eax
	je	SHORT $LN91@xmlParseTr
	mov	eax, DWORD PTR [eax+60]
	test	eax, eax
	je	SHORT $LN91@xmlParseTr
	cmp	DWORD PTR [ebx+212], 0
	jne	SHORT $LN91@xmlParseTr

; 11387: 			    (!ctxt->disableSAX))
; 11388: 			    ctxt->sax->endElement(ctxt->userData, name);

	push	esi
	push	DWORD PTR [ebx+4]
	call	eax
$LN707@xmlParseTr:

; 11389: #endif /* LIBXML_SAX1_ENABLED */
; 11390: 		    }
; 11391: 		    if (ctxt->instate == XML_PARSER_EOF)

	add	esp, 8
$LN91@xmlParseTr:
	cmp	DWORD PTR [ebx+172], -1
	je	$LN699@xmlParseTr

; 11392: 			goto done;
; 11393: 		    spacePop(ctxt);

	push	ebx
	call	_spacePop
	add	esp, 4

; 11394: 		    if (ctxt->nameNr == 0) {
; 11395: 			ctxt->instate = XML_PARSER_EPILOG;
; 11396: 		    } else {
; 11397: 			ctxt->instate = XML_PARSER_CONTENT;
; 11398: 		    }
; 11399:                     ctxt->progressive = 1;

	mov	eax, 14					; 0000000eH
	cmp	DWORD PTR [ebx+188], 0
	mov	ecx, 7
	cmovne	eax, ecx
	mov	DWORD PTR [ebx+172], eax
	mov	DWORD PTR [ebx+292], 1

; 11400: 		    break;

	jmp	$LN4@xmlParseTr
$LN85@xmlParseTr:

; 11401: 		}
; 11402: 		if (RAW == '>') {

	cmp	dl, 62					; 0000003eH
	jne	SHORT $LN95@xmlParseTr

; 11403: 		    NEXT;

	push	ebx
	call	_xmlNextChar
	add	esp, 4

; 11404: 		} else {

	jmp	SHORT $LN96@xmlParseTr
$LN95@xmlParseTr:

; 11405: 		    xmlFatalErrMsgStr(ctxt, XML_ERR_GT_REQUIRED,

	push	esi
	push	OFFSET ??_C@_0CD@HIMAKCPA@Couldn?8t?5find?5end?5of?5Start?5Tag?5@
	push	73					; 00000049H
	push	ebx
	call	_xmlFatalErrMsgStr

; 11406: 					 "Couldn't find end of Start Tag %s\n",
; 11407: 					 name);
; 11408: 		    nodePop(ctxt);

	push	ebx
	call	_nodePop

; 11409: 		    spacePop(ctxt);

	push	ebx
	call	_spacePop
	add	esp, 24					; 00000018H
$LN96@xmlParseTr:

; 11410: 		}
; 11411: 		if (ctxt->sax2)

	cmp	DWORD PTR [ebx+324], 0
	je	$LN97@xmlParseTr

; 11412: 		    nameNsPush(ctxt, name, prefix, URI, ctxt->nsNr - nsNr);

	mov	edi, DWORD PTR [ebx+328]
	sub	edi, DWORD PTR _nsNr$1$[ebp]

; 1840 :     if (ctxt->nameNr >= ctxt->nameMax) {

	mov	ecx, DWORD PTR [ebx+188]
	mov	eax, DWORD PTR [ebx+192]
	cmp	ecx, eax
	jl	SHORT $LN638@xmlParseTr

; 1841 :         const xmlChar * *tmp;
; 1842 :         void **tmp2;
; 1843 :         ctxt->nameMax *= 2;

	add	eax, eax
	mov	DWORD PTR [ebx+192], eax

; 1844 :         tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt->nameTab,

	shl	eax, 2
	push	eax
	push	DWORD PTR [ebx+196]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1845 :                                     ctxt->nameMax *
; 1846 :                                     sizeof(ctxt->nameTab[0]));
; 1847 :         if (tmp == NULL) {

	test	eax, eax
	je	SHORT $LN708@xmlParseTr

; 1848 : 	    ctxt->nameMax /= 2;
; 1849 : 	    goto mem_error;
; 1850 :         }
; 1851 : 	ctxt->nameTab = tmp;

	mov	DWORD PTR [ebx+196], eax

; 1852 :         tmp2 = (void **) xmlRealloc((void * *)ctxt->pushTab,

	mov	eax, DWORD PTR [ebx+192]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	push	eax
	push	DWORD PTR [ebx+344]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1853 :                                     ctxt->nameMax * 3 *
; 1854 :                                     sizeof(ctxt->pushTab[0]));
; 1855 :         if (tmp2 == NULL) {

	test	eax, eax
	jne	SHORT $LN293@xmlParseTr
$LN708@xmlParseTr:

; 1867 : mem_error:
; 1868 :     xmlErrMemory(ctxt, NULL);

	mov	eax, DWORD PTR [ebx+192]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [ebx+192], eax
$mem_error$730:
	push	0
	push	ebx
	call	_xmlErrMemory
	jmp	SHORT $LN709@xmlParseTr
$LN293@xmlParseTr:

; 1856 : 	    ctxt->nameMax /= 2;
; 1857 : 	    goto mem_error;
; 1858 :         }
; 1859 : 	ctxt->pushTab = tmp2;

	mov	ecx, DWORD PTR [ebx+188]
	mov	DWORD PTR [ebx+344], eax
$LN638@xmlParseTr:

; 1860 :     }
; 1861 :     ctxt->nameTab[ctxt->nameNr] = value;

	mov	eax, DWORD PTR [ebx+196]

; 1862 :     ctxt->name = value;
; 1863 :     ctxt->pushTab[ctxt->nameNr * 3] = (void *) prefix;

	mov	edx, DWORD PTR _prefix$8[ebp]
	mov	DWORD PTR [eax+ecx*4], esi
	mov	eax, DWORD PTR [ebx+188]
	mov	DWORD PTR [ebx+184], esi
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ebx+344]
	mov	DWORD PTR [eax+ecx*4], edx

; 1864 :     ctxt->pushTab[ctxt->nameNr * 3 + 1] = (void *) URI;

	mov	eax, DWORD PTR [ebx+188]
	mov	edx, DWORD PTR _URI$3[ebp]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ebx+344]
	mov	DWORD PTR [eax+ecx*4+4], edx

; 1865 :     ctxt->pushTab[ctxt->nameNr * 3 + 2] = (void *) (ptrdiff_t) nsNr;

	mov	eax, DWORD PTR [ebx+188]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ebx+344]
	mov	DWORD PTR [eax+ecx*4+8], edi

; 1866 :     return (ctxt->nameNr++);

	inc	DWORD PTR [ebx+188]

; 11412: 		    nameNsPush(ctxt, name, prefix, URI, ctxt->nsNr - nsNr);

	jmp	SHORT $LN98@xmlParseTr
$LN97@xmlParseTr:

; 11413: #ifdef LIBXML_SAX1_ENABLED
; 11414: 		else
; 11415: 		    namePush(ctxt, name);

	push	esi
	push	ebx
	call	_namePush
$LN709@xmlParseTr:

; 11416: #endif /* LIBXML_SAX1_ENABLED */
; 11417: 
; 11418: 		ctxt->instate = XML_PARSER_CONTENT;

	add	esp, 8
$LN98@xmlParseTr:
	mov	DWORD PTR [ebx+172], 7

; 11419:                 ctxt->progressive = 1;

	mov	DWORD PTR [ebx+292], 1

; 11420:                 break;

	jmp	$LN4@xmlParseTr
$LN99@xmlParseTr:

; 11421: 	    }
; 11422:             case XML_PARSER_CONTENT: {
; 11423: 		const xmlChar *test;
; 11424: 		unsigned int cons;
; 11425: 		if ((avail < 2) && (ctxt->inputNr == 1))

	cmp	esi, 2
	jge	SHORT $LN640@xmlParseTr
	cmp	DWORD PTR [ebx+40], 1
	je	$LN699@xmlParseTr
$LN640@xmlParseTr:

; 11426: 		    goto done;
; 11427: 		cur = ctxt->input->cur[0];

	mov	edx, DWORD PTR [edi+16]
	mov	DWORD PTR _test$1$[ebp], edx
	mov	cl, BYTE PTR [edx]

; 11428: 		next = ctxt->input->cur[1];

	mov	al, BYTE PTR [edx+1]

; 11429: 
; 11430: 		test = CUR_PTR;
; 11431: 	        cons = ctxt->input->consumed;

	mov	edx, DWORD PTR [edi+36]
	mov	DWORD PTR _cons$1$[ebp], edx

; 11432: 		if ((cur == '<') && (next == '/')) {

	mov	edx, DWORD PTR _test$1$[ebp]
	cmp	cl, 60					; 0000003cH
	jne	$LN115@xmlParseTr
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN628@xmlParseTr

; 11433: 		    ctxt->instate = XML_PARSER_END_TAG;

	mov	DWORD PTR [ebx+172], 9

; 11434: 		    break;

	jmp	$LN4@xmlParseTr
$LN628@xmlParseTr:

; 11435: 	        } else if ((cur == '<') && (next == '?')) {

	cmp	al, 63					; 0000003fH
	jne	$LN629@xmlParseTr

; 11436: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	$LN105@xmlParseTr

; 10899:     base = in->cur - in->base;

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, edx
	sub	ecx, eax

; 10900:     if (base < 0) return(-1);

	js	SHORT $LN498@xmlParseTr

; 10901:     if (ctxt->checkIndex > base)

	mov	esi, DWORD PTR [ebx+204]

; 10902:         base = ctxt->checkIndex;
; 10903:     if (in->buf == NULL) {

	cmp	esi, ecx
	cmovle	esi, ecx
	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN302@xmlParseTr

; 10904: 	buf = in->base;
; 10905: 	len = in->length;

	mov	ecx, DWORD PTR [edi+24]

; 10906:     } else {

	jmp	SHORT $LN303@xmlParseTr
$LN302@xmlParseTr:

; 10907: 	buf = xmlBufContent(in->buf->buffer);

	push	DWORD PTR [ecx+16]
	call	_xmlBufContent
	mov	DWORD PTR _buf$1$[ebp], eax

; 10908: 	len = xmlBufUse(in->buf->buffer);

	mov	eax, DWORD PTR [edi]
	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	mov	ecx, eax
	add	esp, 8
	mov	eax, DWORD PTR _buf$1$[ebp]
$LN303@xmlParseTr:

; 10909:     }
; 10910:     /* take into account the sequence length */
; 10911:     if (third) len -= 2;
; 10912:     else if (next) len --;

	dec	ecx

; 10913:     for (;base < len;base++) {

	cmp	esi, ecx
	jge	SHORT $LN610@xmlParseTr
	npad	2
$LL298@xmlParseTr:

; 10914:         if (buf[base] == first) {

	cmp	BYTE PTR [eax+esi], 63			; 0000003fH
	jne	SHORT $LN296@xmlParseTr

; 10915: 	    if (third != 0) {
; 10916: 		if ((buf[base + 1] != next) ||
; 10917: 		    (buf[base + 2] != third)) continue;
; 10918: 	    } else if (next != 0) {
; 10919: 		if (buf[base + 1] != next) continue;

	cmp	BYTE PTR [eax+esi+1], 62		; 0000003eH
	je	SHORT $LN310@xmlParseTr
$LN296@xmlParseTr:

; 10913:     for (;base < len;base++) {

	inc	esi
	cmp	esi, ecx
	jl	SHORT $LL298@xmlParseTr
$LN610@xmlParseTr:

; 12044: 			"PP: internal error, state == PUBLIC_LITERAL\n");
; 12045: 		ctxt->instate = XML_PARSER_START_TAG;
; 12046: #ifdef DEBUG_PUSH
; 12047: 		xmlGenericError(xmlGenericErrorContext,
; 12048: 			"PP: entering START_TAG\n");
; 12049: #endif
; 12050: 		break;
; 12051: 	}
; 12052:     }
; 12053: done:
; 12054: #ifdef DEBUG_PUSH
; 12055:     xmlGenericError(xmlGenericErrorContext, "PP: done %d\n", ret);
; 12056: #endif
; 12057:     return(ret);

	mov	DWORD PTR [ebx+204], esi
$LN498@xmlParseTr:
	mov	esi, DWORD PTR _ret$1$[ebp]
	mov	eax, esi
	pop	edi

; 12066: 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 12067: 		     BAD_CAST buffer, NULL);
; 12068:     }
; 12069:     return(0);
; 12070: }

	pop	esi
	mov	DWORD PTR [ebx+292], 2
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN310@xmlParseTr:

; 10921: 	    ctxt->checkIndex = 0;

	mov	DWORD PTR [ebx+204], 0

; 10922: #ifdef DEBUG_PUSH
; 10923: 	    if (next == 0)
; 10924: 		xmlGenericError(xmlGenericErrorContext,
; 10925: 			"PP: lookup '%c' found at %d\n",
; 10926: 			first, base);
; 10927: 	    else if (third == 0)
; 10928: 		xmlGenericError(xmlGenericErrorContext,
; 10929: 			"PP: lookup '%c%c' found at %d\n",
; 10930: 			first, next, base);
; 10931: 	    else
; 10932: 		xmlGenericError(xmlGenericErrorContext,
; 10933: 			"PP: lookup '%c%c%c' found at %d\n",
; 10934: 			first, next, third, base);
; 10935: #endif
; 10936: 	    return(base - (in->cur - in->base));

	sub	esi, DWORD PTR [edi+16]
	add	esi, DWORD PTR [edi+12]

; 11436: 		    if ((!terminate) &&

	js	SHORT $LN498@xmlParseTr
$LN105@xmlParseTr:

; 11437: 		        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {
; 11438:                         ctxt->progressive = XML_PARSER_PI;
; 11439: 			goto done;
; 11440:                     }
; 11441: 		    xmlParsePI(ctxt);

	push	ebx
	call	_xmlParsePI

; 11442: 		    ctxt->instate = XML_PARSER_CONTENT;
; 11443:                     ctxt->progressive = 1;

	jmp	SHORT $LN710@xmlParseTr
$LN629@xmlParseTr:

; 11444: 		} else if ((cur == '<') && (next != '!')) {

	cmp	al, 33					; 00000021H
	je	SHORT $LN631@xmlParseTr

; 11445: 		    ctxt->instate = XML_PARSER_START_TAG;

	mov	DWORD PTR [ebx+172], 6

; 11446: 		    break;

	jmp	$LN4@xmlParseTr
$LN631@xmlParseTr:

; 11447: 		} else if ((cur == '<') && (next == '!') &&
; 11448: 		           (ctxt->input->cur[2] == '-') &&

	mov	cl, BYTE PTR [edx+2]
	cmp	cl, 45					; 0000002dH
	jne	SHORT $LN639@xmlParseTr
	cmp	BYTE PTR [edx+3], cl
	jne	SHORT $LN639@xmlParseTr

; 11449: 			   (ctxt->input->cur[3] == '-')) {
; 11450: 		    int term;
; 11451: 
; 11452: 	            if (avail < 4)

	cmp	esi, 4
	jl	$LN699@xmlParseTr

; 11453: 		        goto done;
; 11454: 		    ctxt->input->cur += 4;
; 11455: 		    term = xmlParseLookupSequence(ctxt, '-', '-', '>');

	push	62					; 0000003eH
	push	45					; 0000002dH
	lea	eax, DWORD PTR [edx+4]
	push	45					; 0000002dH
	push	ebx
	mov	DWORD PTR [edi+16], eax
	call	_xmlParseLookupSequence
	mov	ecx, eax
	add	esp, 16					; 00000010H

; 11456: 		    ctxt->input->cur -= 4;

	mov	eax, DWORD PTR [ebx+36]
	add	DWORD PTR [eax+16], -4			; fffffffcH

; 11457: 		    if ((!terminate) && (term < 0)) {

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN111@xmlParseTr
	test	ecx, ecx
	js	$LN500@xmlParseTr
$LN111@xmlParseTr:

; 11458:                         ctxt->progressive = XML_PARSER_COMMENT;
; 11459: 			goto done;
; 11460:                     }
; 11461: 		    xmlParseComment(ctxt);

	push	ebx
	call	_xmlParseComment
$LN710@xmlParseTr:

; 11511: 		}
; 11512: 		if ((cons == ctxt->input->consumed) && (test == CUR_PTR)) {

	add	esp, 4
	mov	DWORD PTR [ebx+172], 7
	mov	DWORD PTR [ebx+292], 1
	jmp	$LN118@xmlParseTr
$LN639@xmlParseTr:

; 11462: 		    ctxt->instate = XML_PARSER_CONTENT;
; 11463:                     ctxt->progressive = 1;
; 11464: 		} else if ((cur == '<') && (ctxt->input->cur[1] == '!') &&
; 11465: 		    (ctxt->input->cur[2] == '[') &&
; 11466: 		    (ctxt->input->cur[3] == 'C') &&
; 11467: 		    (ctxt->input->cur[4] == 'D') &&
; 11468: 		    (ctxt->input->cur[5] == 'A') &&
; 11469: 		    (ctxt->input->cur[6] == 'T') &&
; 11470: 		    (ctxt->input->cur[7] == 'A') &&

	cmp	al, 33					; 00000021H
	jne	SHORT $LN633@xmlParseTr
	cmp	cl, 91					; 0000005bH
	jne	SHORT $LN633@xmlParseTr
	cmp	BYTE PTR [edx+3], 67			; 00000043H
	jne	SHORT $LN633@xmlParseTr
	cmp	BYTE PTR [edx+4], 68			; 00000044H
	jne	SHORT $LN633@xmlParseTr
	cmp	BYTE PTR [edx+5], 65			; 00000041H
	jne	SHORT $LN633@xmlParseTr
	cmp	BYTE PTR [edx+6], 84			; 00000054H
	jne	SHORT $LN633@xmlParseTr
	cmp	BYTE PTR [edx+7], 65			; 00000041H
	jne	SHORT $LN633@xmlParseTr
	cmp	BYTE PTR [edx+8], cl
	jne	SHORT $LN633@xmlParseTr

; 11471: 		    (ctxt->input->cur[8] == '[')) {
; 11472: 		    SKIP(9);

	add	DWORD PTR [ebx+200], 9
	add	DWORD PTR [edi+16], 9
	mov	eax, DWORD PTR [ebx+36]
	add	DWORD PTR [eax+32], 9
	mov	ecx, DWORD PTR [ebx+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN9@xmlParseTr
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN9@xmlParseTr:

; 11473: 		    ctxt->instate = XML_PARSER_CDATA_SECTION;

	mov	DWORD PTR [ebx+172], 8

; 11474: 		    break;

	jmp	$LN4@xmlParseTr
$LN633@xmlParseTr:

; 11475: 		} else if ((cur == '<') && (next == '!') &&

	cmp	esi, 9
	jl	$LN699@xmlParseTr
$LN117@xmlParseTr:

; 11484: 		    /* TODO Avoid the extra copy, handle directly !!! */
; 11485: 		    /*
; 11486: 		     * Goal of the following test is:
; 11487: 		     *  - minimize calls to the SAX 'character' callback
; 11488: 		     *    when they are mergeable
; 11489: 		     *  - handle an problem for isBlank when we only parse
; 11490: 		     *    a sequence of blank chars and the next one is
; 11491: 		     *    not available to check against '<' presence.
; 11492: 		     *  - tries to homogenize the differences in SAX
; 11493: 		     *    callbacks between the push and pull versions
; 11494: 		     *    of the parser.
; 11495: 		     */
; 11496: 		    if ((ctxt->inputNr == 1) &&

	cmp	DWORD PTR [ebx+40], 1
	jne	$LN126@xmlParseTr
	cmp	esi, 300				; 0000012cH
	jge	$LN126@xmlParseTr

; 11497: 		        (avail < XML_PARSER_BIG_BUFFER_SIZE)) {
; 11498: 			if (!terminate) {

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	$LN126@xmlParseTr

; 11499: 			    if (ctxt->progressive) {

	cmp	DWORD PTR [ebx+292], 0
	je	$LN122@xmlParseTr

; 11500: 				if ((lastlt == NULL) ||

	mov	eax, DWORD PTR _lastlt$[ebp]
	test	eax, eax
	je	$LN699@xmlParseTr
	cmp	edx, eax
	ja	$LN699@xmlParseTr

; 11501: 				    (ctxt->input->cur > lastlt))
; 11502: 				    goto done;
; 11503: 			    } else if (xmlParseLookupSequence(ctxt,

	jmp	$LN126@xmlParseTr
$LN115@xmlParseTr:

; 11476: 		           (avail < 9)) {
; 11477: 		    goto done;
; 11478: 		} else if (cur == '&') {

	cmp	cl, 38					; 00000026H
	jne	SHORT $LN117@xmlParseTr

; 11479: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN119@xmlParseTr

; 10899:     base = in->cur - in->base;

	mov	ecx, DWORD PTR [edi+12]
	mov	eax, edx
	sub	eax, ecx

; 10900:     if (base < 0) return(-1);

	js	$LN699@xmlParseTr

; 10901:     if (ctxt->checkIndex > base)

	mov	esi, DWORD PTR [ebx+204]

; 10902:         base = ctxt->checkIndex;
; 10903:     if (in->buf == NULL) {

	cmp	esi, eax
	cmovle	esi, eax
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN322@xmlParseTr

; 10904: 	buf = in->base;
; 10905: 	len = in->length;

	mov	eax, DWORD PTR [edi+24]

; 10906:     } else {

	jmp	SHORT $LN323@xmlParseTr
$LN322@xmlParseTr:

; 10907: 	buf = xmlBufContent(in->buf->buffer);

	push	DWORD PTR [eax+16]
	call	_xmlBufContent
	mov	DWORD PTR _buf$1$[ebp], eax

; 10908: 	len = xmlBufUse(in->buf->buffer);

	mov	eax, DWORD PTR [edi]
	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	mov	ecx, DWORD PTR _buf$1$[ebp]
	add	esp, 8
$LN323@xmlParseTr:

; 10913:     for (;base < len;base++) {

	cmp	esi, eax
	jge	$LN594@xmlParseTr
$LL318@xmlParseTr:

; 10914:         if (buf[base] == first) {

	cmp	BYTE PTR [ecx+esi], 59			; 0000003bH
	je	SHORT $LN595@xmlParseTr

; 10913:     for (;base < len;base++) {

	inc	esi
	cmp	esi, eax
	jl	SHORT $LL318@xmlParseTr

; 12044: 			"PP: internal error, state == PUBLIC_LITERAL\n");
; 12045: 		ctxt->instate = XML_PARSER_START_TAG;
; 12046: #ifdef DEBUG_PUSH
; 12047: 		xmlGenericError(xmlGenericErrorContext,
; 12048: 			"PP: entering START_TAG\n");
; 12049: #endif
; 12050: 		break;
; 12051: 	}
; 12052:     }
; 12053: done:
; 12054: #ifdef DEBUG_PUSH
; 12055:     xmlGenericError(xmlGenericErrorContext, "PP: done %d\n", ret);
; 12056: #endif
; 12057:     return(ret);

	mov	DWORD PTR [ebx+204], esi
	mov	esi, DWORD PTR _ret$1$[ebp]
	mov	eax, esi
	pop	edi

; 12066: 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 12067: 		     BAD_CAST buffer, NULL);
; 12068:     }
; 12069:     return(0);
; 12070: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN595@xmlParseTr:

; 10921: 	    ctxt->checkIndex = 0;

	mov	DWORD PTR [ebx+204], 0

; 10922: #ifdef DEBUG_PUSH
; 10923: 	    if (next == 0)
; 10924: 		xmlGenericError(xmlGenericErrorContext,
; 10925: 			"PP: lookup '%c' found at %d\n",
; 10926: 			first, base);
; 10927: 	    else if (third == 0)
; 10928: 		xmlGenericError(xmlGenericErrorContext,
; 10929: 			"PP: lookup '%c%c' found at %d\n",
; 10930: 			first, next, base);
; 10931: 	    else
; 10932: 		xmlGenericError(xmlGenericErrorContext,
; 10933: 			"PP: lookup '%c%c%c' found at %d\n",
; 10934: 			first, next, third, base);
; 10935: #endif
; 10936: 	    return(base - (in->cur - in->base));

	sub	esi, DWORD PTR [edi+16]
	add	esi, DWORD PTR [edi+12]

; 11479: 		    if ((!terminate) &&

	js	$LN699@xmlParseTr
$LN119@xmlParseTr:

; 11480: 		        (xmlParseLookupSequence(ctxt, ';', 0, 0) < 0))
; 11481: 			goto done;
; 11482: 		    xmlParseReference(ctxt);

	push	ebx
	call	_xmlParseReference
	add	esp, 4

; 11483: 		} else {

	jmp	$LN118@xmlParseTr
$LN122@xmlParseTr:

; 10899:     base = in->cur - in->base;

	mov	ecx, DWORD PTR [edi+12]
	mov	eax, edx
	sub	eax, ecx

; 10900:     if (base < 0) return(-1);

	js	$LN699@xmlParseTr

; 10901:     if (ctxt->checkIndex > base)

	mov	esi, DWORD PTR [ebx+204]

; 10902:         base = ctxt->checkIndex;
; 10903:     if (in->buf == NULL) {

	cmp	esi, eax
	cmovle	esi, eax
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN342@xmlParseTr

; 10904: 	buf = in->base;
; 10905: 	len = in->length;

	mov	eax, DWORD PTR [edi+24]

; 10906:     } else {

	jmp	SHORT $LN343@xmlParseTr
$LN342@xmlParseTr:

; 10907: 	buf = xmlBufContent(in->buf->buffer);

	push	DWORD PTR [eax+16]
	call	_xmlBufContent
	mov	DWORD PTR _buf$1$[ebp], eax

; 10908: 	len = xmlBufUse(in->buf->buffer);

	mov	eax, DWORD PTR [edi]
	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	mov	ecx, DWORD PTR _buf$1$[ebp]
	add	esp, 8
$LN343@xmlParseTr:

; 10913:     for (;base < len;base++) {

	cmp	esi, eax
	jge	$LN594@xmlParseTr
	npad	5
$LL338@xmlParseTr:

; 10914:         if (buf[base] == first) {

	cmp	BYTE PTR [ecx+esi], 60			; 0000003cH
	je	SHORT $LN597@xmlParseTr

; 10913:     for (;base < len;base++) {

	inc	esi
	cmp	esi, eax
	jl	SHORT $LL338@xmlParseTr

; 12044: 			"PP: internal error, state == PUBLIC_LITERAL\n");
; 12045: 		ctxt->instate = XML_PARSER_START_TAG;
; 12046: #ifdef DEBUG_PUSH
; 12047: 		xmlGenericError(xmlGenericErrorContext,
; 12048: 			"PP: entering START_TAG\n");
; 12049: #endif
; 12050: 		break;
; 12051: 	}
; 12052:     }
; 12053: done:
; 12054: #ifdef DEBUG_PUSH
; 12055:     xmlGenericError(xmlGenericErrorContext, "PP: done %d\n", ret);
; 12056: #endif
; 12057:     return(ret);

	mov	DWORD PTR [ebx+204], esi
	mov	esi, DWORD PTR _ret$1$[ebp]
	mov	eax, esi
	pop	edi

; 12066: 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 12067: 		     BAD_CAST buffer, NULL);
; 12068:     }
; 12069:     return(0);
; 12070: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN597@xmlParseTr:

; 10921: 	    ctxt->checkIndex = 0;

	mov	DWORD PTR [ebx+204], 0

; 10922: #ifdef DEBUG_PUSH
; 10923: 	    if (next == 0)
; 10924: 		xmlGenericError(xmlGenericErrorContext,
; 10925: 			"PP: lookup '%c' found at %d\n",
; 10926: 			first, base);
; 10927: 	    else if (third == 0)
; 10928: 		xmlGenericError(xmlGenericErrorContext,
; 10929: 			"PP: lookup '%c%c' found at %d\n",
; 10930: 			first, next, base);
; 10931: 	    else
; 10932: 		xmlGenericError(xmlGenericErrorContext,
; 10933: 			"PP: lookup '%c%c%c' found at %d\n",
; 10934: 			first, next, third, base);
; 10935: #endif
; 10936: 	    return(base - (in->cur - in->base));

	sub	esi, DWORD PTR [edi+16]
	add	esi, DWORD PTR [edi+12]

; 11504: 			                                      '<', 0, 0) < 0) {

	js	$LN699@xmlParseTr
$LN126@xmlParseTr:

; 11505: 				goto done;
; 11506: 			    }
; 11507: 			}
; 11508:                     }
; 11509: 		    ctxt->checkIndex = 0;
; 11510: 		    xmlParseCharData(ctxt, 0);

	push	0
	push	ebx
	mov	DWORD PTR [ebx+204], 0
	call	_xmlParseCharData
	add	esp, 8
$LN118@xmlParseTr:

; 11511: 		}
; 11512: 		if ((cons == ctxt->input->consumed) && (test == CUR_PTR)) {

	mov	eax, DWORD PTR [ebx+36]
	mov	ecx, DWORD PTR _cons$1$[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jne	$LN4@xmlParseTr
	mov	ecx, DWORD PTR _test$1$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jne	$LN4@xmlParseTr

; 11513: 		    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CG@FCFCBOFE@detected?5an?5error?5in?5element?5co@
	push	1
	push	ebx
	call	_xmlFatalErr

; 11514: 		                "detected an error in element content\n");
; 11515: 		    xmlHaltParser(ctxt);

	push	ebx
	call	_xmlHaltParser
	add	esp, 16					; 00000010H

; 11516: 		    break;

	jmp	$LN4@xmlParseTr
$LN128@xmlParseTr:

; 11517: 		}
; 11518: 		break;
; 11519: 	    }
; 11520:             case XML_PARSER_END_TAG:
; 11521: 		if (avail < 2)

	cmp	esi, 2
	jl	$LN699@xmlParseTr

; 11522: 		    goto done;
; 11523: 		if (!terminate) {

	test	edx, edx
	jne	$LN135@xmlParseTr

; 11524: 		    if (ctxt->progressive) {

	cmp	DWORD PTR [ebx+292], edx
	je	SHORT $LN131@xmlParseTr

; 11525: 		        /* > can be found unescaped in attribute values */
; 11526: 		        if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))

	mov	eax, DWORD PTR _lastgt$1$[ebp]
	test	eax, eax
	je	$LN699@xmlParseTr
	cmp	DWORD PTR [edi+16], eax
	jae	$LN699@xmlParseTr

; 11527: 			    goto done;
; 11528: 		    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {

	jmp	$LN135@xmlParseTr
$LN131@xmlParseTr:

; 10898:     if (in == NULL) return(-1);

	test	edi, edi
	je	$LN699@xmlParseTr

; 10899:     base = in->cur - in->base;

	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR [edi+12]
	sub	eax, ecx

; 10900:     if (base < 0) return(-1);

	js	$LN699@xmlParseTr

; 10901:     if (ctxt->checkIndex > base)

	mov	esi, DWORD PTR [ebx+204]

; 10902:         base = ctxt->checkIndex;
; 10903:     if (in->buf == NULL) {

	cmp	esi, eax
	cmovle	esi, eax
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN362@xmlParseTr

; 10904: 	buf = in->base;
; 10905: 	len = in->length;

	mov	eax, DWORD PTR [edi+24]

; 10906:     } else {

	jmp	SHORT $LN363@xmlParseTr
$LN362@xmlParseTr:

; 10907: 	buf = xmlBufContent(in->buf->buffer);

	push	DWORD PTR [eax+16]
	call	_xmlBufContent
	mov	DWORD PTR _buf$1$[ebp], eax

; 10908: 	len = xmlBufUse(in->buf->buffer);

	mov	eax, DWORD PTR [edi]
	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	mov	ecx, DWORD PTR _buf$1$[ebp]
	add	esp, 8
$LN363@xmlParseTr:

; 10913:     for (;base < len;base++) {

	cmp	esi, eax
	jge	$LN594@xmlParseTr
	npad	1
$LL358@xmlParseTr:

; 10914:         if (buf[base] == first) {

	cmp	BYTE PTR [ecx+esi], 62			; 0000003eH
	je	SHORT $LN599@xmlParseTr

; 10913:     for (;base < len;base++) {

	inc	esi
	cmp	esi, eax
	jl	SHORT $LL358@xmlParseTr

; 12044: 			"PP: internal error, state == PUBLIC_LITERAL\n");
; 12045: 		ctxt->instate = XML_PARSER_START_TAG;
; 12046: #ifdef DEBUG_PUSH
; 12047: 		xmlGenericError(xmlGenericErrorContext,
; 12048: 			"PP: entering START_TAG\n");
; 12049: #endif
; 12050: 		break;
; 12051: 	}
; 12052:     }
; 12053: done:
; 12054: #ifdef DEBUG_PUSH
; 12055:     xmlGenericError(xmlGenericErrorContext, "PP: done %d\n", ret);
; 12056: #endif
; 12057:     return(ret);

	mov	DWORD PTR [ebx+204], esi
	mov	esi, DWORD PTR _ret$1$[ebp]
	mov	eax, esi
	pop	edi

; 12066: 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 12067: 		     BAD_CAST buffer, NULL);
; 12068:     }
; 12069:     return(0);
; 12070: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN599@xmlParseTr:

; 10921: 	    ctxt->checkIndex = 0;

	mov	DWORD PTR [ebx+204], 0

; 10922: #ifdef DEBUG_PUSH
; 10923: 	    if (next == 0)
; 10924: 		xmlGenericError(xmlGenericErrorContext,
; 10925: 			"PP: lookup '%c' found at %d\n",
; 10926: 			first, base);
; 10927: 	    else if (third == 0)
; 10928: 		xmlGenericError(xmlGenericErrorContext,
; 10929: 			"PP: lookup '%c%c' found at %d\n",
; 10930: 			first, next, base);
; 10931: 	    else
; 10932: 		xmlGenericError(xmlGenericErrorContext,
; 10933: 			"PP: lookup '%c%c%c' found at %d\n",
; 10934: 			first, next, third, base);
; 10935: #endif
; 10936: 	    return(base - (in->cur - in->base));

	sub	esi, DWORD PTR [edi+16]
	add	esi, DWORD PTR [edi+12]

; 11527: 			    goto done;
; 11528: 		    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {

	js	$LN699@xmlParseTr
$LN135@xmlParseTr:

; 11529: 			goto done;
; 11530: 		    }
; 11531: 		}
; 11532: 		if (ctxt->sax2) {

	cmp	DWORD PTR [ebx+324], 0
	push	0
	je	SHORT $LN136@xmlParseTr

; 11533: 		    xmlParseEndTag2(ctxt,

	mov	eax, DWORD PTR [ebx+188]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ebx+344]
	push	DWORD PTR [eax+ecx*4-4]
	push	0
	push	DWORD PTR [eax+ecx*4-8]
	push	DWORD PTR [eax+ecx*4-12]
	push	ebx
	call	_xmlParseEndTag2

; 1884 :     if (ctxt->nameNr <= 0)

	mov	ecx, DWORD PTR [ebx+188]

; 11533: 		    xmlParseEndTag2(ctxt,

	add	esp, 24					; 00000018H

; 1884 :     if (ctxt->nameNr <= 0)

	test	ecx, ecx
	jle	SHORT $LN137@xmlParseTr

; 1885 :         return (NULL);
; 1886 :     ctxt->nameNr--;

	dec	ecx
	mov	DWORD PTR [ebx+188], ecx

; 1887 :     if (ctxt->nameNr > 0)

	test	ecx, ecx
	jle	SHORT $LN377@xmlParseTr

; 1888 :         ctxt->name = ctxt->nameTab[ctxt->nameNr - 1];

	mov	eax, DWORD PTR [ebx+196]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN378@xmlParseTr
$LN377@xmlParseTr:

; 1889 :     else
; 1890 :         ctxt->name = NULL;

	xor	eax, eax
$LN378@xmlParseTr:

; 1891 :     ret = ctxt->nameTab[ctxt->nameNr];
; 1892 :     ctxt->nameTab[ctxt->nameNr] = NULL;

	mov	DWORD PTR [ebx+184], eax
	mov	ecx, DWORD PTR [ebx+188]
	mov	eax, DWORD PTR [ebx+196]
	mov	DWORD PTR [eax+ecx*4], 0

; 11534: 		            (void *) ctxt->pushTab[ctxt->nameNr * 3 - 3],
; 11535: 		            (void *) ctxt->pushTab[ctxt->nameNr * 3 - 2], 0,
; 11536: 		            (int) (ptrdiff_t)
; 11537:                                 ctxt->pushTab[ctxt->nameNr * 3 - 1], 0);
; 11538: 		    nameNsPop(ctxt);
; 11539: 		}

	jmp	SHORT $LN137@xmlParseTr
$LN136@xmlParseTr:

; 11540: #ifdef LIBXML_SAX1_ENABLED
; 11541: 		  else
; 11542: 		    xmlParseEndTag1(ctxt, 0);

	push	ebx
	call	_xmlParseEndTag1
	add	esp, 8
$LN137@xmlParseTr:

; 11543: #endif /* LIBXML_SAX1_ENABLED */
; 11544: 		if (ctxt->instate == XML_PARSER_EOF) {

	cmp	DWORD PTR [ebx+172], -1
	je	$LN4@xmlParseTr

; 11545: 		    /* Nothing */
; 11546: 		} else if (ctxt->nameNr == 0) {

	cmp	DWORD PTR [ebx+188], 0
	mov	eax, 7
	mov	ecx, 14					; 0000000eH
	cmove	eax, ecx
	mov	DWORD PTR [ebx+172], eax

; 11547: 		    ctxt->instate = XML_PARSER_EPILOG;
; 11548: 		} else {
; 11549: 		    ctxt->instate = XML_PARSER_CONTENT;
; 11550: 		}
; 11551: 		break;

	jmp	$LN4@xmlParseTr
$LN142@xmlParseTr:

; 11552:             case XML_PARSER_CDATA_SECTION: {
; 11553: 	        /*
; 11554: 		 * The Push mode need to have the SAX callback for
; 11555: 		 * cdataBlock merge back contiguous callbacks.
; 11556: 		 */
; 11557: 		int base;
; 11558: 
; 11559: 		base = xmlParseLookupSequence(ctxt, ']', ']', '>');

	push	62					; 0000003eH
	push	93					; 0000005dH
	push	93					; 0000005dH
	push	ebx
	call	_xmlParseLookupSequence
	mov	edi, eax
	add	esp, 16					; 00000010H

; 11560: 		if (base < 0) {

	test	edi, edi
	js	$LN508@xmlParseTr

; 11582: 			ctxt->checkIndex = 0;
; 11583: 		    }
; 11584: 		    goto done;
; 11585: 		} else {
; 11586: 		    int tmp;
; 11587: 
; 11588: 		    tmp = xmlCheckCdataPush(ctxt->input->cur, base, 1);

	mov	eax, DWORD PTR [ebx+36]
	push	1
	push	edi
	push	DWORD PTR [eax+16]
	call	_xmlCheckCdataPush
	mov	ecx, eax
	add	esp, 12					; 0000000cH

; 11589: 		    if ((tmp < 0) || (tmp != base)) {

	test	ecx, ecx
	js	$LN156@xmlParseTr
	cmp	ecx, edi
	jne	$LN156@xmlParseTr

; 11592: 			goto encoding_error;
; 11593: 		    }
; 11594: 		    if ((ctxt->sax != NULL) && (base == 0) &&
; 11595: 		        (ctxt->sax->cdataBlock != NULL) &&

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN163@xmlParseTr
	test	edi, edi
	jne	SHORT $LN711@xmlParseTr
	cmp	DWORD PTR [eax+100], edi
	je	SHORT $LN163@xmlParseTr
	cmp	DWORD PTR [ebx+212], edi
	jne	SHORT $LN163@xmlParseTr

; 11596: 		        (!ctxt->disableSAX)) {
; 11597: 			/*
; 11598: 			 * Special case to provide identical behaviour
; 11599: 			 * between pull and push parsers on enpty CDATA
; 11600: 			 * sections
; 11601: 			 */
; 11602: 			 if ((ctxt->input->cur - ctxt->input->base >= 9) &&

	mov	ecx, DWORD PTR [ebx+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 9
	jl	SHORT $LN163@xmlParseTr
	push	9
	lea	eax, DWORD PTR [edx-9]
	push	OFFSET ??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@
	push	eax
	call	DWORD PTR tv7442[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN163@xmlParseTr

; 11603: 			     (!strncmp((const char *)&ctxt->input->cur[-9],
; 11604: 			               "<![CDATA[", 9)))
; 11605: 			     ctxt->sax->cdataBlock(ctxt->userData,

	mov	eax, DWORD PTR [ebx]
	push	edi
	push	OFFSET ??_C@_00CNPNBAHC@@
	push	DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [eax+100]
	call	eax

; 11606: 			                           BAD_CAST "", 0);
; 11607: 		    } else if ((ctxt->sax != NULL) && (base > 0) &&

	jmp	SHORT $LN712@xmlParseTr
$LN711@xmlParseTr:
	jle	SHORT $LN163@xmlParseTr
	cmp	DWORD PTR [ebx+212], 0
	jne	SHORT $LN163@xmlParseTr

; 11608: 			(!ctxt->disableSAX)) {
; 11609: 			if (ctxt->sax->cdataBlock != NULL)

	mov	ecx, DWORD PTR [eax+100]
	test	ecx, ecx
	jne	SHORT $LN713@xmlParseTr

; 11610: 			    ctxt->sax->cdataBlock(ctxt->userData,
; 11611: 						  ctxt->input->cur, base);
; 11612: 			else if (ctxt->sax->characters != NULL)

	mov	ecx, DWORD PTR [eax+68]
	test	ecx, ecx
	je	SHORT $LN163@xmlParseTr
$LN713@xmlParseTr:

; 11613: 			    ctxt->sax->characters(ctxt->userData,
; 11614: 						  ctxt->input->cur, base);
; 11615: 		    }
; 11616: 		    if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR [ebx+36]
	push	edi
	push	DWORD PTR [eax+16]
	push	DWORD PTR [ebx+4]
	call	ecx
$LN712@xmlParseTr:
	add	esp, 12					; 0000000cH
$LN163@xmlParseTr:
	cmp	DWORD PTR [ebx+172], -1
	je	$LN699@xmlParseTr

; 11617: 			goto done;
; 11618: 		    SKIPL(base + 3);

	lea	edx, DWORD PTR [edi+3]
	test	edx, edx
	jle	SHORT $LN22@xmlParseTr
	npad	3
$LL23@xmlParseTr:
	mov	ecx, DWORD PTR [ebx+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN165@xmlParseTr
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [ebx+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN166@xmlParseTr
$LN165@xmlParseTr:
	inc	DWORD PTR [ecx+32]
$LN166@xmlParseTr:
	mov	eax, DWORD PTR [ebx+36]
	inc	DWORD PTR [ebx+200]
	inc	DWORD PTR [eax+16]
	sub	edx, 1
	jne	SHORT $LL23@xmlParseTr
$LN22@xmlParseTr:
	mov	ecx, DWORD PTR [ebx+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN18@xmlParseTr
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN18@xmlParseTr:

; 11619: 		    ctxt->checkIndex = 0;

	mov	DWORD PTR [ebx+204], 0

; 11620: 		    ctxt->instate = XML_PARSER_CONTENT;

	mov	DWORD PTR [ebx+172], 7

; 11621: #ifdef DEBUG_PUSH
; 11622: 		    xmlGenericError(xmlGenericErrorContext,
; 11623: 			    "PP: entering CONTENT\n");
; 11624: #endif
; 11625: 		}
; 11626: 		break;

	jmp	$LN4@xmlParseTr
$LN168@xmlParseTr:

; 11627: 	    }
; 11628:             case XML_PARSER_MISC:
; 11629: 		SKIP_BLANKS;

	push	ebx
	call	_xmlSkipBlankChars

; 11630: 		if (ctxt->input->buf == NULL)

	mov	esi, DWORD PTR [ebx+36]
	add	esp, 4
	mov	DWORD PTR $T6[ebp], esi
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN169@xmlParseTr

; 11631: 		    avail = ctxt->input->length -

	mov	edx, DWORD PTR [esi+24]
	sub	edx, DWORD PTR [esi+16]
	add	edx, DWORD PTR [esi+12]
	jmp	SHORT $LN170@xmlParseTr
$LN169@xmlParseTr:

; 11632: 		            (ctxt->input->cur - ctxt->input->base);
; 11633: 		else
; 11634: 		    avail = xmlBufUse(ctxt->input->buf->buffer) -

	mov	esi, DWORD PTR [ebx+36]
	push	DWORD PTR [eax+16]
	mov	DWORD PTR $T6[ebp], esi
	call	_xmlBufUse
	mov	edx, eax
	add	esp, 4
	mov	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+16]
	add	edx, eax
$LN170@xmlParseTr:

; 11635: 		            (ctxt->input->cur - ctxt->input->base);
; 11636: 		if (avail < 2)

	cmp	edx, 2
	jl	$LN699@xmlParseTr

; 11637: 		    goto done;
; 11638: 		cur = ctxt->input->cur[0];

	mov	ecx, DWORD PTR [esi+16]
	mov	al, BYTE PTR [ecx]

; 11639: 		next = ctxt->input->cur[1];

	mov	ah, BYTE PTR [ecx+1]

; 11640: 	        if ((cur == '<') && (next == '?')) {

	cmp	al, 60					; 0000003cH
	jne	$LN187@xmlParseTr
	cmp	ah, 63					; 0000003fH
	jne	$LN635@xmlParseTr

; 11641: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	$LN174@xmlParseTr

; 10899:     base = in->cur - in->base;

	mov	edi, DWORD PTR [esi+12]
	sub	ecx, edi

; 10900:     if (base < 0) return(-1);

	js	$LN498@xmlParseTr

; 10901:     if (ctxt->checkIndex > base)

	mov	esi, DWORD PTR [ebx+204]

; 10902:         base = ctxt->checkIndex;
; 10903:     if (in->buf == NULL) {

	cmp	esi, ecx
	cmovle	esi, ecx
	mov	ecx, DWORD PTR $T6[ebp]
	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN387@xmlParseTr

; 10904: 	buf = in->base;
; 10905: 	len = in->length;

	mov	eax, DWORD PTR [ecx+24]

; 10906:     } else {

	jmp	SHORT $LN388@xmlParseTr
$LN387@xmlParseTr:

; 10907: 	buf = xmlBufContent(in->buf->buffer);

	push	DWORD PTR [eax+16]
	call	_xmlBufContent
	mov	edi, eax

; 10908: 	len = xmlBufUse(in->buf->buffer);

	mov	eax, DWORD PTR $T6[ebp]
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	mov	ecx, DWORD PTR $T6[ebp]
	add	esp, 8
$LN388@xmlParseTr:

; 10909:     }
; 10910:     /* take into account the sequence length */
; 10911:     if (third) len -= 2;
; 10912:     else if (next) len --;

	dec	eax

; 10913:     for (;base < len;base++) {

	cmp	esi, eax
	jge	$LN610@xmlParseTr
$LL383@xmlParseTr:

; 10914:         if (buf[base] == first) {

	cmp	BYTE PTR [edi+esi], 63			; 0000003fH
	jne	SHORT $LN381@xmlParseTr

; 10915: 	    if (third != 0) {
; 10916: 		if ((buf[base + 1] != next) ||
; 10917: 		    (buf[base + 2] != third)) continue;
; 10918: 	    } else if (next != 0) {
; 10919: 		if (buf[base + 1] != next) continue;

	cmp	BYTE PTR [edi+esi+1], 62		; 0000003eH
	je	SHORT $LN395@xmlParseTr
$LN381@xmlParseTr:

; 10913:     for (;base < len;base++) {

	inc	esi
	cmp	esi, eax
	jl	SHORT $LL383@xmlParseTr
	jmp	$LN610@xmlParseTr
$LN395@xmlParseTr:

; 10920: 	    }
; 10921: 	    ctxt->checkIndex = 0;

	mov	DWORD PTR [ebx+204], 0

; 10922: #ifdef DEBUG_PUSH
; 10923: 	    if (next == 0)
; 10924: 		xmlGenericError(xmlGenericErrorContext,
; 10925: 			"PP: lookup '%c' found at %d\n",
; 10926: 			first, base);
; 10927: 	    else if (third == 0)
; 10928: 		xmlGenericError(xmlGenericErrorContext,
; 10929: 			"PP: lookup '%c%c' found at %d\n",
; 10930: 			first, next, base);
; 10931: 	    else
; 10932: 		xmlGenericError(xmlGenericErrorContext,
; 10933: 			"PP: lookup '%c%c%c' found at %d\n",
; 10934: 			first, next, third, base);
; 10935: #endif
; 10936: 	    return(base - (in->cur - in->base));

	sub	esi, DWORD PTR [ecx+16]
	add	esi, DWORD PTR [ecx+12]

; 11641: 		    if ((!terminate) &&

	js	$LN498@xmlParseTr
$LN174@xmlParseTr:

; 11642: 		        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {
; 11643:                         ctxt->progressive = XML_PARSER_PI;
; 11644: 			goto done;
; 11645:                     }
; 11646: #ifdef DEBUG_PUSH
; 11647: 		    xmlGenericError(xmlGenericErrorContext,
; 11648: 			    "PP: Parsing PI\n");
; 11649: #endif
; 11650: 		    xmlParsePI(ctxt);

	push	ebx
	call	_xmlParsePI
	jmp	SHORT $LN722@xmlParseTr
$LN635@xmlParseTr:

; 11651: 		    if (ctxt->instate == XML_PARSER_EOF)
; 11652: 			goto done;
; 11653: 		    ctxt->instate = XML_PARSER_MISC;
; 11654:                     ctxt->progressive = 1;
; 11655: 		    ctxt->checkIndex = 0;
; 11656: 		} else if ((cur == '<') && (next == '!') &&
; 11657: 		    (ctxt->input->cur[2] == '-') &&

	cmp	ah, 33					; 00000021H
	jne	$LN187@xmlParseTr
	mov	al, BYTE PTR [ecx+2]
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN641@xmlParseTr
	cmp	BYTE PTR [ecx+3], al
	jne	SHORT $LN641@xmlParseTr

; 11658: 		    (ctxt->input->cur[3] == '-')) {
; 11659: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN178@xmlParseTr
	push	62					; 0000003eH
	push	45					; 0000002dH
	push	45					; 0000002dH
	push	ebx
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	test	eax, eax
	js	$LN500@xmlParseTr
$LN178@xmlParseTr:

; 11660: 		        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {
; 11661:                         ctxt->progressive = XML_PARSER_COMMENT;
; 11662: 			goto done;
; 11663:                     }
; 11664: #ifdef DEBUG_PUSH
; 11665: 		    xmlGenericError(xmlGenericErrorContext,
; 11666: 			    "PP: Parsing Comment\n");
; 11667: #endif
; 11668: 		    xmlParseComment(ctxt);

	push	ebx
	call	_xmlParseComment
$LN722@xmlParseTr:

; 11669: 		    if (ctxt->instate == XML_PARSER_EOF)
; 11670: 			goto done;
; 11671: 		    ctxt->instate = XML_PARSER_MISC;

	add	esp, 4
	cmp	DWORD PTR [ebx+172], -1
	je	$LN699@xmlParseTr
	mov	DWORD PTR [ebx+172], 1

; 11672:                     ctxt->progressive = 1;

	mov	DWORD PTR [ebx+292], 1

; 11673: 		    ctxt->checkIndex = 0;

	mov	DWORD PTR [ebx+204], 0

; 11674: 		} else if ((cur == '<') && (next == '!') &&

	jmp	$LN4@xmlParseTr
$LN641@xmlParseTr:

; 11675: 		    (ctxt->input->cur[2] == 'D') &&
; 11676: 		    (ctxt->input->cur[3] == 'O') &&
; 11677: 		    (ctxt->input->cur[4] == 'C') &&
; 11678: 		    (ctxt->input->cur[5] == 'T') &&
; 11679: 		    (ctxt->input->cur[6] == 'Y') &&
; 11680: 		    (ctxt->input->cur[7] == 'P') &&

	cmp	al, 68					; 00000044H
	jne	$LN585@xmlParseTr
	cmp	BYTE PTR [ecx+3], 79			; 0000004fH
	jne	$LN585@xmlParseTr
	cmp	BYTE PTR [ecx+4], 67			; 00000043H
	jne	$LN585@xmlParseTr
	cmp	BYTE PTR [ecx+5], 84			; 00000054H
	jne	$LN585@xmlParseTr
	cmp	BYTE PTR [ecx+6], 89			; 00000059H
	jne	$LN585@xmlParseTr
	cmp	BYTE PTR [ecx+7], 80			; 00000050H
	jne	$LN585@xmlParseTr
	cmp	BYTE PTR [ecx+8], 69			; 00000045H
	jne	$LN585@xmlParseTr

; 11681: 		    (ctxt->input->cur[8] == 'E')) {
; 11682: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	$LN182@xmlParseTr

; 10899:     base = in->cur - in->base;

	mov	edi, DWORD PTR [esi+12]
	sub	ecx, edi

; 10900:     if (base < 0) return(-1);

	js	SHORT $LN516@xmlParseTr

; 10901:     if (ctxt->checkIndex > base)

	mov	esi, DWORD PTR [ebx+204]

; 10902:         base = ctxt->checkIndex;
; 10903:     if (in->buf == NULL) {

	cmp	esi, ecx
	cmovle	esi, ecx
	mov	ecx, DWORD PTR $T6[ebp]
	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN407@xmlParseTr

; 10904: 	buf = in->base;
; 10905: 	len = in->length;

	mov	eax, DWORD PTR [ecx+24]

; 10906:     } else {

	jmp	SHORT $LN408@xmlParseTr
$LN407@xmlParseTr:

; 10907: 	buf = xmlBufContent(in->buf->buffer);

	push	DWORD PTR [eax+16]
	call	_xmlBufContent
	mov	edi, eax

; 10908: 	len = xmlBufUse(in->buf->buffer);

	mov	eax, DWORD PTR $T6[ebp]
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	mov	ecx, DWORD PTR $T6[ebp]
	add	esp, 8
$LN408@xmlParseTr:

; 10913:     for (;base < len;base++) {

	cmp	esi, eax
	jge	SHORT $LN602@xmlParseTr
$LL403@xmlParseTr:

; 10914:         if (buf[base] == first) {

	cmp	BYTE PTR [edi+esi], 62			; 0000003eH
	je	SHORT $LN601@xmlParseTr

; 10913:     for (;base < len;base++) {

	inc	esi
	cmp	esi, eax
	jl	SHORT $LL403@xmlParseTr
$LN602@xmlParseTr:

; 10937: 	}
; 10938:     }
; 10939:     ctxt->checkIndex = base;

	mov	DWORD PTR [ebx+204], esi
$LN516@xmlParseTr:

; 12044: 			"PP: internal error, state == PUBLIC_LITERAL\n");
; 12045: 		ctxt->instate = XML_PARSER_START_TAG;
; 12046: #ifdef DEBUG_PUSH
; 12047: 		xmlGenericError(xmlGenericErrorContext,
; 12048: 			"PP: entering START_TAG\n");
; 12049: #endif
; 12050: 		break;
; 12051: 	}
; 12052:     }
; 12053: done:
; 12054: #ifdef DEBUG_PUSH
; 12055:     xmlGenericError(xmlGenericErrorContext, "PP: done %d\n", ret);
; 12056: #endif
; 12057:     return(ret);

	mov	esi, DWORD PTR _ret$1$[ebp]
	mov	eax, esi
	pop	edi

; 12066: 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 12067: 		     BAD_CAST buffer, NULL);
; 12068:     }
; 12069:     return(0);
; 12070: }

	pop	esi
	mov	DWORD PTR [ebx+292], 3
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN601@xmlParseTr:

; 10921: 	    ctxt->checkIndex = 0;

	mov	DWORD PTR [ebx+204], 0

; 10922: #ifdef DEBUG_PUSH
; 10923: 	    if (next == 0)
; 10924: 		xmlGenericError(xmlGenericErrorContext,
; 10925: 			"PP: lookup '%c' found at %d\n",
; 10926: 			first, base);
; 10927: 	    else if (third == 0)
; 10928: 		xmlGenericError(xmlGenericErrorContext,
; 10929: 			"PP: lookup '%c%c' found at %d\n",
; 10930: 			first, next, base);
; 10931: 	    else
; 10932: 		xmlGenericError(xmlGenericErrorContext,
; 10933: 			"PP: lookup '%c%c%c' found at %d\n",
; 10934: 			first, next, third, base);
; 10935: #endif
; 10936: 	    return(base - (in->cur - in->base));

	sub	esi, DWORD PTR [ecx+16]
	add	esi, DWORD PTR [ecx+12]

; 11681: 		    (ctxt->input->cur[8] == 'E')) {
; 11682: 		    if ((!terminate) &&

	js	SHORT $LN516@xmlParseTr
$LN182@xmlParseTr:

; 11683: 		        (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0)) {
; 11684:                         ctxt->progressive = XML_PARSER_DTD;
; 11685: 			goto done;
; 11686:                     }
; 11687: #ifdef DEBUG_PUSH
; 11688: 		    xmlGenericError(xmlGenericErrorContext,
; 11689: 			    "PP: Parsing internal subset\n");
; 11690: #endif
; 11691: 		    ctxt->inSubset = 1;
; 11692:                     ctxt->progressive = 0;
; 11693: 		    ctxt->checkIndex = 0;
; 11694: 		    xmlParseDocTypeDecl(ctxt);

	push	ebx
	mov	DWORD PTR [ebx+216], 1
	mov	DWORD PTR [ebx+292], 0
	mov	DWORD PTR [ebx+204], 0
	call	_xmlParseDocTypeDecl
	add	esp, 4

; 11695: 		    if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [ebx+172], -1
	je	$LN699@xmlParseTr

; 11696: 			goto done;
; 11697: 		    if (RAW == '[') {

	mov	eax, DWORD PTR [ebx+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 91			; 0000005bH
	jne	SHORT $LN184@xmlParseTr

; 11698: 			ctxt->instate = XML_PARSER_DTD;

	mov	eax, 3

; 11716: #ifdef DEBUG_PUSH
; 11717: 			xmlGenericError(xmlGenericErrorContext,
; 11718: 				"PP: entering PROLOG\n");
; 11719: #endif
; 11720: 		    }

	mov	DWORD PTR [ebx+172], eax
	jmp	$LN4@xmlParseTr
$LN184@xmlParseTr:

; 11699: #ifdef DEBUG_PUSH
; 11700: 			xmlGenericError(xmlGenericErrorContext,
; 11701: 				"PP: entering DTD\n");
; 11702: #endif
; 11703: 		    } else {
; 11704: 			/*
; 11705: 			 * Create and update the external subset.
; 11706: 			 */
; 11707: 			ctxt->inSubset = 2;
; 11708: 			if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ebx+216], 2
	test	eax, eax
	je	SHORT $LN186@xmlParseTr
	cmp	DWORD PTR [ebx+212], 0
	jne	SHORT $LN186@xmlParseTr
	mov	eax, DWORD PTR [eax+104]
	test	eax, eax
	je	SHORT $LN186@xmlParseTr

; 11709: 			    (ctxt->sax->externalSubset != NULL))
; 11710: 			    ctxt->sax->externalSubset(ctxt->userData,

	push	DWORD PTR [ebx+224]
	push	DWORD PTR [ebx+228]
	push	DWORD PTR [ebx+220]
	push	DWORD PTR [ebx+4]
	call	eax
	add	esp, 16					; 00000010H
$LN186@xmlParseTr:

; 11711: 				    ctxt->intSubName, ctxt->extSubSystem,
; 11712: 				    ctxt->extSubURI);
; 11713: 			ctxt->inSubset = 0;
; 11714: 			xmlCleanSpecialAttr(ctxt);

	push	ebx
	mov	DWORD PTR [ebx+216], 0
	call	_xmlCleanSpecialAttr

; 11715: 			ctxt->instate = XML_PARSER_PROLOG;

	mov	eax, 4
	add	esp, 4

; 11716: #ifdef DEBUG_PUSH
; 11717: 			xmlGenericError(xmlGenericErrorContext,
; 11718: 				"PP: entering PROLOG\n");
; 11719: #endif
; 11720: 		    }

	mov	DWORD PTR [ebx+172], eax
	jmp	$LN4@xmlParseTr
$LN585@xmlParseTr:

; 11721: 		} else if ((cur == '<') && (next == '!') &&

	cmp	edx, 9
	jl	$LN699@xmlParseTr
$LN187@xmlParseTr:

; 11722: 		           (avail < 9)) {
; 11723: 		    goto done;
; 11724: 		} else {
; 11725: 		    ctxt->instate = XML_PARSER_START_TAG;
; 11726: 		    ctxt->progressive = XML_PARSER_START_TAG;
; 11727: 		    xmlParseGetLasts(ctxt, &lastlt, &lastgt);

	lea	eax, DWORD PTR _lastgt$[ebp]
	mov	DWORD PTR [ebx+172], 6
	push	eax
	lea	eax, DWORD PTR _lastlt$[ebp]
	mov	DWORD PTR [ebx+292], 6
	push	eax
	push	ebx
	call	_xmlParseGetLasts

; 11728: #ifdef DEBUG_PUSH
; 11729: 		    xmlGenericError(xmlGenericErrorContext,
; 11730: 			    "PP: entering START_TAG\n");
; 11731: #endif
; 11732: 		}
; 11733: 		break;

	mov	ecx, DWORD PTR _lastgt$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lastgt$1$[ebp], ecx
	jmp	$LN4@xmlParseTr
$LN189@xmlParseTr:

; 11734:             case XML_PARSER_PROLOG:
; 11735: 		SKIP_BLANKS;

	push	ebx
	call	_xmlSkipBlankChars

; 11736: 		if (ctxt->input->buf == NULL)

	mov	esi, DWORD PTR [ebx+36]
	add	esp, 4
	mov	DWORD PTR $T5[ebp], esi
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN190@xmlParseTr

; 11737: 		    avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);

	mov	ecx, DWORD PTR [esi+24]
	sub	ecx, DWORD PTR [esi+16]
	add	ecx, DWORD PTR [esi+12]
	jmp	SHORT $LN191@xmlParseTr
$LN190@xmlParseTr:

; 11738: 		else
; 11739: 		    avail = xmlBufUse(ctxt->input->buf->buffer) -

	mov	esi, DWORD PTR [ebx+36]
	push	DWORD PTR [eax+16]
	mov	DWORD PTR $T5[ebp], esi
	call	_xmlBufUse
	mov	ecx, eax
	add	esp, 4
	mov	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+16]
	add	ecx, eax
$LN191@xmlParseTr:

; 11740:                             (ctxt->input->cur - ctxt->input->base);
; 11741: 		if (avail < 2)

	cmp	ecx, 2
	jl	$LN699@xmlParseTr

; 11742: 		    goto done;
; 11743: 		cur = ctxt->input->cur[0];

	mov	edx, DWORD PTR [esi+16]
	mov	al, BYTE PTR [edx]

; 11744: 		next = ctxt->input->cur[1];

	mov	ah, BYTE PTR [edx+1]

; 11745: 	        if ((cur == '<') && (next == '?')) {

	cmp	al, 60					; 0000003cH
	jne	$LN201@xmlParseTr
	cmp	ah, 63					; 0000003fH
	jne	$LN586@xmlParseTr

; 11746: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	$LN195@xmlParseTr

; 10899:     base = in->cur - in->base;

	mov	edi, DWORD PTR [esi+12]
	sub	edx, edi

; 10900:     if (base < 0) return(-1);

	js	$LN498@xmlParseTr

; 10901:     if (ctxt->checkIndex > base)

	mov	esi, DWORD PTR [ebx+204]

; 10902:         base = ctxt->checkIndex;
; 10903:     if (in->buf == NULL) {

	cmp	esi, edx
	mov	ecx, DWORD PTR $T5[ebp]
	cmovle	esi, edx
	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN427@xmlParseTr

; 10904: 	buf = in->base;
; 10905: 	len = in->length;

	mov	eax, DWORD PTR [ecx+24]

; 10906:     } else {

	jmp	SHORT $LN428@xmlParseTr
$LN427@xmlParseTr:

; 10907: 	buf = xmlBufContent(in->buf->buffer);

	push	DWORD PTR [eax+16]
	call	_xmlBufContent
	mov	edi, eax

; 10908: 	len = xmlBufUse(in->buf->buffer);

	mov	eax, DWORD PTR $T5[ebp]
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	mov	ecx, DWORD PTR $T5[ebp]
	add	esp, 8
$LN428@xmlParseTr:

; 10909:     }
; 10910:     /* take into account the sequence length */
; 10911:     if (third) len -= 2;
; 10912:     else if (next) len --;

	dec	eax

; 10913:     for (;base < len;base++) {

	cmp	esi, eax
	jge	$LN610@xmlParseTr
	npad	1
$LL423@xmlParseTr:

; 10914:         if (buf[base] == first) {

	cmp	BYTE PTR [edi+esi], 63			; 0000003fH
	jne	SHORT $LN421@xmlParseTr

; 10915: 	    if (third != 0) {
; 10916: 		if ((buf[base + 1] != next) ||
; 10917: 		    (buf[base + 2] != third)) continue;
; 10918: 	    } else if (next != 0) {
; 10919: 		if (buf[base + 1] != next) continue;

	cmp	BYTE PTR [edi+esi+1], 62		; 0000003eH
	je	SHORT $LN435@xmlParseTr
$LN421@xmlParseTr:

; 10913:     for (;base < len;base++) {

	inc	esi
	cmp	esi, eax
	jl	SHORT $LL423@xmlParseTr
	jmp	$LN610@xmlParseTr
$LN435@xmlParseTr:

; 10920: 	    }
; 10921: 	    ctxt->checkIndex = 0;

	mov	DWORD PTR [ebx+204], 0

; 10922: #ifdef DEBUG_PUSH
; 10923: 	    if (next == 0)
; 10924: 		xmlGenericError(xmlGenericErrorContext,
; 10925: 			"PP: lookup '%c' found at %d\n",
; 10926: 			first, base);
; 10927: 	    else if (third == 0)
; 10928: 		xmlGenericError(xmlGenericErrorContext,
; 10929: 			"PP: lookup '%c%c' found at %d\n",
; 10930: 			first, next, base);
; 10931: 	    else
; 10932: 		xmlGenericError(xmlGenericErrorContext,
; 10933: 			"PP: lookup '%c%c%c' found at %d\n",
; 10934: 			first, next, third, base);
; 10935: #endif
; 10936: 	    return(base - (in->cur - in->base));

	sub	esi, DWORD PTR [ecx+16]
	add	esi, DWORD PTR [ecx+12]

; 11746: 		    if ((!terminate) &&

	js	$LN498@xmlParseTr
$LN195@xmlParseTr:

; 11747: 		        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {
; 11748:                         ctxt->progressive = XML_PARSER_PI;
; 11749: 			goto done;
; 11750:                     }
; 11751: #ifdef DEBUG_PUSH
; 11752: 		    xmlGenericError(xmlGenericErrorContext,
; 11753: 			    "PP: Parsing PI\n");
; 11754: #endif
; 11755: 		    xmlParsePI(ctxt);

	push	ebx
	call	_xmlParsePI
	jmp	SHORT $LN724@xmlParseTr
$LN586@xmlParseTr:

; 11756: 		    if (ctxt->instate == XML_PARSER_EOF)
; 11757: 			goto done;
; 11758: 		    ctxt->instate = XML_PARSER_PROLOG;
; 11759:                     ctxt->progressive = 1;
; 11760: 		} else if ((cur == '<') && (next == '!') &&
; 11761: 		    (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {

	cmp	ah, 33					; 00000021H
	jne	SHORT $LN201@xmlParseTr
	cmp	BYTE PTR [edx+2], 45			; 0000002dH
	jne	SHORT $LN588@xmlParseTr
	cmp	BYTE PTR [edx+3], 45			; 0000002dH
	jne	SHORT $LN588@xmlParseTr

; 11762: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN199@xmlParseTr
	push	62					; 0000003eH
	push	45					; 0000002dH
	push	45					; 0000002dH
	push	ebx
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	test	eax, eax
	js	$LN500@xmlParseTr
$LN199@xmlParseTr:

; 11763: 		        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {
; 11764:                         ctxt->progressive = XML_PARSER_COMMENT;
; 11765: 			goto done;
; 11766:                     }
; 11767: #ifdef DEBUG_PUSH
; 11768: 		    xmlGenericError(xmlGenericErrorContext,
; 11769: 			    "PP: Parsing Comment\n");
; 11770: #endif
; 11771: 		    xmlParseComment(ctxt);

	push	ebx
	call	_xmlParseComment
$LN724@xmlParseTr:

; 11772: 		    if (ctxt->instate == XML_PARSER_EOF)
; 11773: 			goto done;
; 11774: 		    ctxt->instate = XML_PARSER_PROLOG;

	add	esp, 4
	cmp	DWORD PTR [ebx+172], -1
	je	$LN699@xmlParseTr
	mov	DWORD PTR [ebx+172], 4

; 11775:                     ctxt->progressive = 1;

	mov	DWORD PTR [ebx+292], 1
	jmp	$LN4@xmlParseTr
$LN588@xmlParseTr:

; 11776: 		} else if ((cur == '<') && (next == '!') &&

	cmp	ecx, 4
	jl	$LN699@xmlParseTr
$LN201@xmlParseTr:

; 11777: 		           (avail < 4)) {
; 11778: 		    goto done;
; 11779: 		} else {
; 11780: 		    ctxt->instate = XML_PARSER_START_TAG;
; 11781: 		    if (ctxt->progressive == 0)

	cmp	DWORD PTR [ebx+292], 0
	mov	DWORD PTR [ebx+172], 6
	jne	SHORT $LN203@xmlParseTr

; 11782: 			ctxt->progressive = XML_PARSER_START_TAG;

	mov	DWORD PTR [ebx+292], 6
$LN203@xmlParseTr:

; 11783: 		    xmlParseGetLasts(ctxt, &lastlt, &lastgt);

	lea	eax, DWORD PTR _lastgt$[ebp]
	push	eax
	lea	eax, DWORD PTR _lastlt$[ebp]
	push	eax
	push	ebx
	call	_xmlParseGetLasts

; 11784: #ifdef DEBUG_PUSH
; 11785: 		    xmlGenericError(xmlGenericErrorContext,
; 11786: 			    "PP: entering START_TAG\n");
; 11787: #endif
; 11788: 		}
; 11789: 		break;

	mov	eax, DWORD PTR _lastgt$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lastgt$1$[ebp], eax
	jmp	$LN4@xmlParseTr
$LN204@xmlParseTr:

; 11790:             case XML_PARSER_EPILOG:
; 11791: 		SKIP_BLANKS;

	push	ebx
	call	_xmlSkipBlankChars

; 11792: 		if (ctxt->input->buf == NULL)

	mov	esi, DWORD PTR [ebx+36]
	add	esp, 4
	mov	DWORD PTR $T4[ebp], esi
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN205@xmlParseTr

; 11793: 		    avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);

	mov	ecx, DWORD PTR [esi+24]
	sub	ecx, DWORD PTR [esi+16]
	add	ecx, DWORD PTR [esi+12]
	jmp	SHORT $LN206@xmlParseTr
$LN205@xmlParseTr:

; 11794: 		else
; 11795: 		    avail = xmlBufUse(ctxt->input->buf->buffer) -

	mov	esi, DWORD PTR [ebx+36]
	push	DWORD PTR [eax+16]
	mov	DWORD PTR $T4[ebp], esi
	call	_xmlBufUse
	mov	ecx, eax
	add	esp, 4
	mov	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+16]
	add	ecx, eax
$LN206@xmlParseTr:

; 11796:                             (ctxt->input->cur - ctxt->input->base);
; 11797: 		if (avail < 2)

	cmp	ecx, 2
	jl	$LN699@xmlParseTr

; 11798: 		    goto done;
; 11799: 		cur = ctxt->input->cur[0];

	mov	edx, DWORD PTR [esi+16]
	mov	al, BYTE PTR [edx]

; 11800: 		next = ctxt->input->cur[1];

	mov	ah, BYTE PTR [edx+1]

; 11801: 	        if ((cur == '<') && (next == '?')) {

	cmp	al, 60					; 0000003cH
	jne	$LN216@xmlParseTr
	cmp	ah, 63					; 0000003fH
	jne	$LN589@xmlParseTr

; 11802: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	$LN210@xmlParseTr

; 10899:     base = in->cur - in->base;

	mov	edi, DWORD PTR [esi+12]
	sub	edx, edi

; 10900:     if (base < 0) return(-1);

	js	$LN498@xmlParseTr

; 10901:     if (ctxt->checkIndex > base)

	mov	esi, DWORD PTR [ebx+204]

; 10902:         base = ctxt->checkIndex;
; 10903:     if (in->buf == NULL) {

	cmp	esi, edx
	mov	ecx, DWORD PTR $T4[ebp]
	cmovle	esi, edx
	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN447@xmlParseTr

; 10904: 	buf = in->base;
; 10905: 	len = in->length;

	mov	eax, DWORD PTR [ecx+24]

; 10906:     } else {

	jmp	SHORT $LN448@xmlParseTr
$LN447@xmlParseTr:

; 10907: 	buf = xmlBufContent(in->buf->buffer);

	push	DWORD PTR [eax+16]
	call	_xmlBufContent
	mov	edi, eax

; 10908: 	len = xmlBufUse(in->buf->buffer);

	mov	eax, DWORD PTR $T4[ebp]
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	mov	ecx, DWORD PTR $T4[ebp]
	add	esp, 8
$LN448@xmlParseTr:

; 10909:     }
; 10910:     /* take into account the sequence length */
; 10911:     if (third) len -= 2;
; 10912:     else if (next) len --;

	dec	eax

; 10913:     for (;base < len;base++) {

	cmp	esi, eax
	jge	$LN610@xmlParseTr
$LL443@xmlParseTr:

; 10914:         if (buf[base] == first) {

	cmp	BYTE PTR [edi+esi], 63			; 0000003fH
	jne	SHORT $LN441@xmlParseTr

; 10915: 	    if (third != 0) {
; 10916: 		if ((buf[base + 1] != next) ||
; 10917: 		    (buf[base + 2] != third)) continue;
; 10918: 	    } else if (next != 0) {
; 10919: 		if (buf[base + 1] != next) continue;

	cmp	BYTE PTR [edi+esi+1], 62		; 0000003eH
	je	SHORT $LN455@xmlParseTr
$LN441@xmlParseTr:

; 10913:     for (;base < len;base++) {

	inc	esi
	cmp	esi, eax
	jl	SHORT $LL443@xmlParseTr
	jmp	$LN610@xmlParseTr
$LN455@xmlParseTr:

; 10920: 	    }
; 10921: 	    ctxt->checkIndex = 0;

	mov	DWORD PTR [ebx+204], 0

; 10922: #ifdef DEBUG_PUSH
; 10923: 	    if (next == 0)
; 10924: 		xmlGenericError(xmlGenericErrorContext,
; 10925: 			"PP: lookup '%c' found at %d\n",
; 10926: 			first, base);
; 10927: 	    else if (third == 0)
; 10928: 		xmlGenericError(xmlGenericErrorContext,
; 10929: 			"PP: lookup '%c%c' found at %d\n",
; 10930: 			first, next, base);
; 10931: 	    else
; 10932: 		xmlGenericError(xmlGenericErrorContext,
; 10933: 			"PP: lookup '%c%c%c' found at %d\n",
; 10934: 			first, next, third, base);
; 10935: #endif
; 10936: 	    return(base - (in->cur - in->base));

	sub	esi, DWORD PTR [ecx+16]
	add	esi, DWORD PTR [ecx+12]

; 11802: 		    if ((!terminate) &&

	js	$LN498@xmlParseTr
$LN210@xmlParseTr:

; 11803: 		        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {
; 11804:                         ctxt->progressive = XML_PARSER_PI;
; 11805: 			goto done;
; 11806:                     }
; 11807: #ifdef DEBUG_PUSH
; 11808: 		    xmlGenericError(xmlGenericErrorContext,
; 11809: 			    "PP: Parsing PI\n");
; 11810: #endif
; 11811: 		    xmlParsePI(ctxt);

	push	ebx
	call	_xmlParsePI

; 11812: 		    if (ctxt->instate == XML_PARSER_EOF)
; 11813: 			goto done;
; 11814: 		    ctxt->instate = XML_PARSER_EPILOG;
; 11815:                     ctxt->progressive = 1;
; 11816: 		} else if ((cur == '<') && (next == '!') &&

	jmp	SHORT $LN726@xmlParseTr
$LN589@xmlParseTr:

; 11817: 		    (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {

	cmp	ah, 33					; 00000021H
	jne	$LN216@xmlParseTr
	cmp	BYTE PTR [edx+2], 45			; 0000002dH
	jne	$LN591@xmlParseTr
	cmp	BYTE PTR [edx+3], 45			; 0000002dH
	jne	$LN591@xmlParseTr

; 11818: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN214@xmlParseTr
	push	62					; 0000003eH
	push	45					; 0000002dH
	push	45					; 0000002dH
	push	ebx
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	test	eax, eax
	js	$LN500@xmlParseTr
$LN214@xmlParseTr:

; 11819: 		        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {
; 11820:                         ctxt->progressive = XML_PARSER_COMMENT;
; 11821: 			goto done;
; 11822:                     }
; 11823: #ifdef DEBUG_PUSH
; 11824: 		    xmlGenericError(xmlGenericErrorContext,
; 11825: 			    "PP: Parsing Comment\n");
; 11826: #endif
; 11827: 		    xmlParseComment(ctxt);

	push	ebx
	call	_xmlParseComment
$LN726@xmlParseTr:

; 11845: 		}
; 11846: 		break;

	add	esp, 4
	cmp	DWORD PTR [ebx+172], -1
	je	$LN699@xmlParseTr
	mov	DWORD PTR [ebx+172], 14			; 0000000eH
	mov	DWORD PTR [ebx+292], 1
	jmp	$LN4@xmlParseTr
$LN219@xmlParseTr:

; 11847:             case XML_PARSER_DTD: {
; 11848: 	        /*
; 11849: 		 * Sorry but progressive parsing of the internal subset
; 11850: 		 * is not expected to be supported. We first check that
; 11851: 		 * the full content of the internal subset is available and
; 11852: 		 * the parsing is launched only at that point.
; 11853: 		 * Internal subset ends up with "']' S? '>'" in an unescaped
; 11854: 		 * section and not in a ']]>' sequence which are conditional
; 11855: 		 * sections (whoever argued to keep that crap in XML deserve
; 11856: 		 * a place in hell !).
; 11857: 		 */
; 11858: 		int base, i;
; 11859: 		xmlChar *buf;
; 11860: 	        xmlChar quote = 0;

	xor	al, al
	mov	BYTE PTR _quote$1$[ebp], al

; 11861:                 size_t use;
; 11862: 
; 11863: 		base = ctxt->input->cur - ctxt->input->base;

	mov	eax, DWORD PTR [edi+16]
	sub	eax, DWORD PTR [edi+12]
	mov	DWORD PTR _base$1$[ebp], eax

; 11864: 		if (base < 0) return(0);

	js	$LN530@xmlParseTr

; 11865: 		if (ctxt->checkIndex > base)
; 11866: 		    base = ctxt->checkIndex;
; 11867: 		buf = xmlBufContent(ctxt->input->buf->buffer);

	mov	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR [ebx+204]
	push	DWORD PTR [eax+16]
	call	_xmlBufContent
	mov	DWORD PTR _buf$1$[ebp], eax

; 11868:                 use = xmlBufUse(ctxt->input->buf->buffer);

	mov	eax, DWORD PTR [ebx+36]
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	add	esp, 8
	mov	edi, eax
	cmp	esi, DWORD PTR _base$1$[ebp]
	cmovle	esi, DWORD PTR _base$1$[ebp]
$LL26@xmlParseTr:

; 11869: 		for (;(unsigned int) base < use; base++) {

	mov	dh, BYTE PTR _quote$1$[ebp]
	cmp	esi, edi
	jae	$LN31@xmlParseTr

; 11870: 		    if (quote != 0) {

	mov	eax, DWORD PTR _buf$1$[ebp]
	mov	dl, BYTE PTR [eax+esi]
	test	dh, dh
	je	SHORT $LN222@xmlParseTr

; 11871: 		        if (buf[base] == quote)
; 11872: 			    quote = 0;
; 11873: 			continue;

	xor	ecx, ecx
	movzx	eax, dh
	cmp	dl, dh
	cmovne	ecx, eax
	mov	BYTE PTR _quote$1$[ebp], cl
$not_end_of_int_subset$731:

; 11869: 		for (;(unsigned int) base < use; base++) {

	inc	esi
	jmp	SHORT $LL26@xmlParseTr
$LN222@xmlParseTr:

; 11874: 		    }
; 11875: 		    if ((quote == 0) && (buf[base] == '<')) {

	cmp	dl, 60					; 0000003cH
	jne	$LN225@xmlParseTr

; 11876: 		        int found  = 0;
; 11877: 			/* special handling of comments */
; 11878: 		        if (((unsigned int) base + 4 < use) &&
; 11879: 			    (buf[base + 1] == '!') &&
; 11880: 			    (buf[base + 2] == '-') &&

	lea	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	mov	eax, DWORD PTR _buf$1$[ebp]
	jae	SHORT $LN225@xmlParseTr
	cmp	BYTE PTR [eax+esi+1], 33		; 00000021H
	jne	SHORT $LN225@xmlParseTr
	cmp	BYTE PTR [eax+esi+2], 45		; 0000002dH
	jne	SHORT $LN225@xmlParseTr
	cmp	BYTE PTR [eax+esi+3], 45		; 0000002dH
	jne	SHORT $LN225@xmlParseTr

; 11881: 			    (buf[base + 3] == '-')) {
; 11882: 			    for (;(unsigned int) base + 3 < use; base++) {

	lea	eax, DWORD PTR [esi+3]
	cmp	eax, edi
	jae	$LN594@xmlParseTr
	mov	eax, DWORD PTR _buf$1$[ebp]
	mov	edx, 2
	lea	ecx, DWORD PTR [eax+1]
	add	ecx, esi
	sub	edx, eax
	npad	6
$LL29@xmlParseTr:

; 11883: 				if ((buf[base] == '-') &&
; 11884: 				    (buf[base + 1] == '-') &&

	cmp	BYTE PTR [ecx-1], 45			; 0000002dH
	jne	SHORT $LN27@xmlParseTr
	cmp	BYTE PTR [ecx], 45			; 0000002dH
	jne	SHORT $LN27@xmlParseTr
	cmp	BYTE PTR [ecx+1], 62			; 0000003eH
	je	SHORT $LN476@xmlParseTr
$LN27@xmlParseTr:

; 11881: 			    (buf[base + 3] == '-')) {
; 11882: 			    for (;(unsigned int) base + 3 < use; base++) {

	inc	ecx
	inc	esi
	lea	eax, DWORD PTR [edx+ecx]
	cmp	eax, edi
	jb	SHORT $LL29@xmlParseTr

; 12044: 			"PP: internal error, state == PUBLIC_LITERAL\n");
; 12045: 		ctxt->instate = XML_PARSER_START_TAG;
; 12046: #ifdef DEBUG_PUSH
; 12047: 		xmlGenericError(xmlGenericErrorContext,
; 12048: 			"PP: entering START_TAG\n");
; 12049: #endif
; 12050: 		break;
; 12051: 	}
; 12052:     }
; 12053: done:
; 12054: #ifdef DEBUG_PUSH
; 12055:     xmlGenericError(xmlGenericErrorContext, "PP: done %d\n", ret);
; 12056: #endif
; 12057:     return(ret);

	mov	DWORD PTR [ebx+204], esi
	mov	esi, DWORD PTR _ret$1$[ebp]
	mov	eax, esi
	pop	edi

; 12066: 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 12067: 		     BAD_CAST buffer, NULL);
; 12068:     }
; 12069:     return(0);
; 12070: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN476@xmlParseTr:

; 11885: 				    (buf[base + 2] == '>')) {
; 11886: 				    found = 1;
; 11887: 				    base += 2;

	add	esi, 2
	inc	esi
	jmp	$LL26@xmlParseTr
$LN225@xmlParseTr:

; 11888: 				    break;
; 11889: 				}
; 11890: 		            }
; 11891: 			    if (!found) {
; 11892: #if 0
; 11893: 			        fprintf(stderr, "unfinished comment\n");
; 11894: #endif
; 11895: 			        break; /* for */
; 11896: 		            }
; 11897: 		            continue;
; 11898: 			}
; 11899: 		    }
; 11900: 		    if (buf[base] == '"') {

	cmp	dl, 34					; 00000022H
	jne	SHORT $LN228@xmlParseTr

; 11901: 		        quote = '"';

	mov	BYTE PTR _quote$1$[ebp], dl
	inc	esi
	jmp	$LL26@xmlParseTr
$LN228@xmlParseTr:

; 11902: 			continue;
; 11903: 		    }
; 11904: 		    if (buf[base] == '\'') {

	cmp	dl, 39					; 00000027H
	jne	SHORT $LN229@xmlParseTr

; 11905: 		        quote = '\'';

	mov	BYTE PTR _quote$1$[ebp], dl
	inc	esi
	jmp	$LL26@xmlParseTr
$LN229@xmlParseTr:

; 11906: 			continue;
; 11907: 		    }
; 11908: 		    if (buf[base] == ']') {

	cmp	dl, 93					; 0000005dH
	jne	$not_end_of_int_subset$731

; 11909: #if 0
; 11910: 		        fprintf(stderr, "%c%c%c%c: ", buf[base],
; 11911: 			        buf[base + 1], buf[base + 2], buf[base + 3]);
; 11912: #endif
; 11913: 		        if ((unsigned int) base +1 >= use)

	lea	ecx, DWORD PTR [esi+1]
	cmp	ecx, edi
	jae	$LN594@xmlParseTr

; 11914: 			    break;
; 11915: 			if (buf[base + 1] == ']') {

	cmp	BYTE PTR [eax+esi+1], dl
	jne	SHORT $LL232@xmlParseTr

; 11916: 			    /* conditional crap, skip both ']' ! */
; 11917: 			    base++;

	mov	esi, ecx
	inc	esi
	jmp	$LL26@xmlParseTr
$LL232@xmlParseTr:

; 11918: 			    continue;
; 11919: 			}
; 11920: 		        for (i = 1; (unsigned int) base + i < use; i++) {

	cmp	ecx, edi
	jae	$LN31@xmlParseTr

; 11921: 			    if (buf[base + i] == '>') {

	mov	al, BYTE PTR [ecx+eax]
	cmp	al, 62					; 0000003eH
	je	SHORT $found_end_int_subset$732

; 11922: #if 0
; 11923: 			        fprintf(stderr, "found\n");
; 11924: #endif
; 11925: 			        goto found_end_int_subset;
; 11926: 			    }
; 11927: 			    if (!IS_BLANK_CH(buf[base + i])) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN30@xmlParseTr
	cmp	al, 9
	jb	SHORT $LN235@xmlParseTr
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN30@xmlParseTr
$LN235@xmlParseTr:
	cmp	al, 13					; 0000000dH
	jne	$not_end_of_int_subset$731
$LN30@xmlParseTr:

; 11918: 			    continue;
; 11919: 			}
; 11920: 		        for (i = 1; (unsigned int) base + i < use; i++) {

	mov	eax, DWORD PTR _buf$1$[ebp]
	inc	ecx
	jmp	SHORT $LL232@xmlParseTr
$found_end_int_subset$732:

; 11947:                     ctxt->checkIndex = base;
; 11948:                 else
; 11949:                     ctxt->checkIndex = 0;
; 11950: #ifdef DEBUG_PUSH
; 11951: 		if (next == 0)
; 11952: 		    xmlGenericError(xmlGenericErrorContext,
; 11953: 			    "PP: lookup of int subset end filed\n");
; 11954: #endif
; 11955: 	        goto done;
; 11956: 
; 11957: found_end_int_subset:
; 11958:                 ctxt->checkIndex = 0;
; 11959: 		xmlParseInternalSubset(ctxt);

	push	ebx
	mov	DWORD PTR [ebx+204], 0
	call	_xmlParseInternalSubset
	add	esp, 4

; 11960: 		if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [ebx+172], -1
	je	$LN699@xmlParseTr

; 11961: 		    goto done;
; 11962: 		ctxt->inSubset = 2;
; 11963: 		if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ebx+216], 2
	test	eax, eax
	je	SHORT $LN239@xmlParseTr
	cmp	DWORD PTR [ebx+212], 0
	jne	SHORT $LN239@xmlParseTr
	mov	eax, DWORD PTR [eax+104]
	test	eax, eax
	je	SHORT $LN239@xmlParseTr

; 11964: 		    (ctxt->sax->externalSubset != NULL))
; 11965: 		    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,

	push	DWORD PTR [ebx+224]
	push	DWORD PTR [ebx+228]
	push	DWORD PTR [ebx+220]
	push	DWORD PTR [ebx+4]
	call	eax
	add	esp, 16					; 00000010H
$LN239@xmlParseTr:

; 11966: 			    ctxt->extSubSystem, ctxt->extSubURI);
; 11967: 		ctxt->inSubset = 0;
; 11968: 		xmlCleanSpecialAttr(ctxt);

	push	ebx
	mov	DWORD PTR [ebx+216], 0
	call	_xmlCleanSpecialAttr
	add	esp, 4

; 11969: 		if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [ebx+172], -1
	je	$LN699@xmlParseTr

; 11970: 		    goto done;
; 11971: 		ctxt->instate = XML_PARSER_PROLOG;

	mov	DWORD PTR [ebx+172], 4

; 11972: 		ctxt->checkIndex = 0;

	mov	DWORD PTR [ebx+204], 0

; 11973: #ifdef DEBUG_PUSH
; 11974: 		xmlGenericError(xmlGenericErrorContext,
; 11975: 			"PP: entering PROLOG\n");
; 11976: #endif
; 11977:                 break;

	jmp	$LN4@xmlParseTr
$LN241@xmlParseTr:

; 11978: 	    }
; 11979:             case XML_PARSER_COMMENT:
; 11980: 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CG@PHGFCMFA@PP?3?5internal?5error?0?5state?5?$DN?$DN?5CO@
$LN715@xmlParseTr:

; 11157: 
; 11158:     while (ctxt->instate != XML_PARSER_EOF) {

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	mov	DWORD PTR [ebx+172], 7
	jmp	$LN705@xmlParseTr
$LN242@xmlParseTr:

; 11981: 			"PP: internal error, state == COMMENT\n");
; 11982: 		ctxt->instate = XML_PARSER_CONTENT;
; 11983: #ifdef DEBUG_PUSH
; 11984: 		xmlGenericError(xmlGenericErrorContext,
; 11985: 			"PP: entering CONTENT\n");
; 11986: #endif
; 11987: 		break;
; 11988:             case XML_PARSER_IGNORE:
; 11989: 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CE@CFNIBLKF@PP?3?5internal?5error?0?5state?5?$DN?$DN?5IG@
$LN716@xmlParseTr:

; 11157: 
; 11158:     while (ctxt->instate != XML_PARSER_EOF) {

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	mov	DWORD PTR [ebx+172], 3
	jmp	$LN705@xmlParseTr
$LN243@xmlParseTr:

; 11990: 			"PP: internal error, state == IGNORE");
; 11991: 	        ctxt->instate = XML_PARSER_DTD;
; 11992: #ifdef DEBUG_PUSH
; 11993: 		xmlGenericError(xmlGenericErrorContext,
; 11994: 			"PP: entering DTD\n");
; 11995: #endif
; 11996: 	        break;
; 11997:             case XML_PARSER_PI:
; 11998: 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CB@LNKCECMO@PP?3?5internal?5error?0?5state?5?$DN?$DN?5PI@

; 11999: 			"PP: internal error, state == PI\n");
; 12000: 		ctxt->instate = XML_PARSER_CONTENT;
; 12001: #ifdef DEBUG_PUSH
; 12002: 		xmlGenericError(xmlGenericErrorContext,
; 12003: 			"PP: entering CONTENT\n");
; 12004: #endif
; 12005: 		break;

	jmp	SHORT $LN715@xmlParseTr
$LN244@xmlParseTr:

; 12006:             case XML_PARSER_ENTITY_DECL:
; 12007: 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CK@EGFEGMNP@PP?3?5internal?5error?0?5state?5?$DN?$DN?5EN@

; 12008: 			"PP: internal error, state == ENTITY_DECL\n");
; 12009: 		ctxt->instate = XML_PARSER_DTD;
; 12010: #ifdef DEBUG_PUSH
; 12011: 		xmlGenericError(xmlGenericErrorContext,
; 12012: 			"PP: entering DTD\n");
; 12013: #endif
; 12014: 		break;

	jmp	SHORT $LN716@xmlParseTr
$LN245@xmlParseTr:

; 12015:             case XML_PARSER_ENTITY_VALUE:
; 12016: 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CL@FDJCPJGL@PP?3?5internal?5error?0?5state?5?$DN?$DN?5EN@

; 12017: 			"PP: internal error, state == ENTITY_VALUE\n");
; 12018: 		ctxt->instate = XML_PARSER_CONTENT;
; 12019: #ifdef DEBUG_PUSH
; 12020: 		xmlGenericError(xmlGenericErrorContext,
; 12021: 			"PP: entering DTD\n");
; 12022: #endif
; 12023: 		break;

	jmp	SHORT $LN715@xmlParseTr
$LN246@xmlParseTr:

; 12024:             case XML_PARSER_ATTRIBUTE_VALUE:
; 12025: 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CO@BNGPOFIK@PP?3?5internal?5error?0?5state?5?$DN?$DN?5AT@

; 12026: 			"PP: internal error, state == ATTRIBUTE_VALUE\n");
; 12027: 		ctxt->instate = XML_PARSER_START_TAG;
; 12028: #ifdef DEBUG_PUSH
; 12029: 		xmlGenericError(xmlGenericErrorContext,
; 12030: 			"PP: entering START_TAG\n");
; 12031: #endif
; 12032: 		break;

	jmp	SHORT $LN714@xmlParseTr
$LN247@xmlParseTr:

; 12033:             case XML_PARSER_SYSTEM_LITERAL:
; 12034: 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CN@JHJPBNDP@PP?3?5internal?5error?0?5state?5?$DN?$DN?5SY@

; 12035: 			"PP: internal error, state == SYSTEM_LITERAL\n");
; 12036: 		ctxt->instate = XML_PARSER_START_TAG;
; 12037: #ifdef DEBUG_PUSH
; 12038: 		xmlGenericError(xmlGenericErrorContext,
; 12039: 			"PP: entering START_TAG\n");
; 12040: #endif
; 12041: 		break;

	jmp	SHORT $LN714@xmlParseTr
$LN248@xmlParseTr:

; 12042:             case XML_PARSER_PUBLIC_LITERAL:
; 12043: 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CN@LJGHMOAD@PP?3?5internal?5error?0?5state?5?$DN?$DN?5PU@
$LN714@xmlParseTr:

; 11157: 
; 11158:     while (ctxt->instate != XML_PARSER_EOF) {

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	mov	DWORD PTR [ebx+172], 6
$LN705@xmlParseTr:
	add	esp, 8
$LN4@xmlParseTr:
	mov	eax, DWORD PTR [ebx+172]
	cmp	eax, -1
	je	$LN699@xmlParseTr
	jmp	$LN717@xmlParseTr
$LN489@xmlParseTr:

; 11261: 			    /*
; 11262: 			     * The XML REC instructs us to stop parsing right
; 11263: 			     * here
; 11264: 			     */
; 11265: 			    xmlHaltParser(ctxt);

	push	ebx
	call	_xmlHaltParser
	add	esp, 4
$LN530@xmlParseTr:

; 12066: 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 12067: 		     BAD_CAST buffer, NULL);
; 12068:     }
; 12069:     return(0);
; 12070: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN486@xmlParseTr:

; 11228: 		    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))

	mov	esi, DWORD PTR [ebx]
	test	esi, esi
	je	SHORT $LN47@xmlParseTr
	cmp	DWORD PTR [esi+44], 0
	je	SHORT $LN47@xmlParseTr

; 11229: 			ctxt->sax->setDocumentLocator(ctxt->userData,

	call	___xmlDefaultSAXLocator
	push	eax
	push	DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [esi+44]
	call	eax
	add	esp, 8
$LN47@xmlParseTr:

; 12044: 			"PP: internal error, state == PUBLIC_LITERAL\n");
; 12045: 		ctxt->instate = XML_PARSER_START_TAG;
; 12046: #ifdef DEBUG_PUSH
; 12047: 		xmlGenericError(xmlGenericErrorContext,
; 12048: 			"PP: entering START_TAG\n");
; 12049: #endif
; 12050: 		break;
; 12051: 	}
; 12052:     }
; 12053: done:
; 12054: #ifdef DEBUG_PUSH
; 12055:     xmlGenericError(xmlGenericErrorContext, "PP: done %d\n", ret);
; 12056: #endif
; 12057:     return(ret);

	push	0
	push	4
$LN720@xmlParseTr:
	push	ebx
	call	_xmlFatalErr
	push	ebx
	call	_xmlHaltParser
	add	esp, 16					; 00000010H
$LN719@xmlParseTr:
	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	$LN699@xmlParseTr
	mov	eax, DWORD PTR [eax+52]
	test	eax, eax
	je	$LN699@xmlParseTr
	push	DWORD PTR [ebx+4]
	call	eax
	mov	esi, DWORD PTR _ret$1$[ebp]
	add	esp, 4
	mov	eax, esi
	pop	edi

; 12066: 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 12067: 		     BAD_CAST buffer, NULL);
; 12068:     }
; 12069:     return(0);
; 12070: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN495@xmlParseTr:

; 11352: 		    spacePop(ctxt);

	push	ebx
	call	_spacePop

; 11353: 		    xmlHaltParser(ctxt);

	push	ebx
	call	_xmlHaltParser
	add	esp, 8

; 11354: 		    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
; 11355: 			ctxt->sax->endDocument(ctxt->userData);
; 11356: 		    goto done;

	jmp	SHORT $LN719@xmlParseTr
$LN500@xmlParseTr:

; 12044: 			"PP: internal error, state == PUBLIC_LITERAL\n");
; 12045: 		ctxt->instate = XML_PARSER_START_TAG;
; 12046: #ifdef DEBUG_PUSH
; 12047: 		xmlGenericError(xmlGenericErrorContext,
; 12048: 			"PP: entering START_TAG\n");
; 12049: #endif
; 12050: 		break;
; 12051: 	}
; 12052:     }
; 12053: done:
; 12054: #ifdef DEBUG_PUSH
; 12055:     xmlGenericError(xmlGenericErrorContext, "PP: done %d\n", ret);
; 12056: #endif
; 12057:     return(ret);

	mov	esi, DWORD PTR _ret$1$[ebp]
	mov	eax, esi
	pop	edi

; 12066: 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 12067: 		     BAD_CAST buffer, NULL);
; 12068:     }
; 12069:     return(0);
; 12070: }

	pop	esi
	mov	DWORD PTR [ebx+292], 5
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN156@xmlParseTr:

; 11590: 			tmp = -tmp;
; 11591: 			ctxt->input->cur += tmp;

	mov	eax, DWORD PTR [ebx+36]
	sub	DWORD PTR [eax+16], ecx
	jmp	SHORT $encoding_error$733
$LN508@xmlParseTr:

; 11561: 		    if (avail >= XML_PARSER_BIG_BUFFER_SIZE + 2) {

	cmp	esi, 302				; 0000012eH
	jl	$LN699@xmlParseTr

; 11562: 		        int tmp;
; 11563: 
; 11564: 			tmp = xmlCheckCdataPush(ctxt->input->cur,

	mov	eax, DWORD PTR [ebx+36]
	push	0
	push	300					; 0000012cH
	push	DWORD PTR [eax+16]
	call	_xmlCheckCdataPush
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 11565: 			                        XML_PARSER_BIG_BUFFER_SIZE, 0);
; 11566: 			if (tmp < 0) {

	test	esi, esi
	jns	SHORT $LN146@xmlParseTr

; 11567: 			    tmp = -tmp;
; 11568: 			    ctxt->input->cur += tmp;

	mov	ecx, DWORD PTR [ebx+36]
	sub	DWORD PTR [ecx+16], esi
$encoding_error$733:

; 12058: encoding_error:
; 12059:     {
; 12060:         char buffer[150];
; 12061: 
; 12062: 	snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",

	mov	eax, DWORD PTR [ebx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [ecx+3]
	push	eax
	movzx	eax, BYTE PTR [ecx+2]
	push	eax
	movzx	eax, BYTE PTR [ecx+1]
	push	eax
	movzx	eax, BYTE PTR [ecx]
	push	eax
	push	OFFSET ??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@
	lea	eax, DWORD PTR _buffer$1[ebp]
	push	149					; 00000095H
	push	eax
	call	_snprintf

; 12063: 			ctxt->input->cur[0], ctxt->input->cur[1],
; 12064: 			ctxt->input->cur[2], ctxt->input->cur[3]);
; 12065: 	__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,

	push	0
	lea	eax, DWORD PTR _buffer$1[ebp]
	push	eax
	push	OFFSET ??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@
	push	9
	push	ebx
	call	___xmlErrEncoding
	add	esp, 48					; 00000030H

; 12066: 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 12067: 		     BAD_CAST buffer, NULL);
; 12068:     }
; 12069:     return(0);
; 12070: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN146@xmlParseTr:

; 11569: 			    goto encoding_error;
; 11570: 			}
; 11571: 			if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN150@xmlParseTr
	cmp	DWORD PTR [ebx+212], 0
	jne	SHORT $LN150@xmlParseTr

; 11572: 			    if (ctxt->sax->cdataBlock != NULL)

	mov	ecx, DWORD PTR [eax+100]
	test	ecx, ecx
	jne	SHORT $LN718@xmlParseTr

; 11573: 				ctxt->sax->cdataBlock(ctxt->userData,
; 11574: 				                      ctxt->input->cur, tmp);
; 11575: 			    else if (ctxt->sax->characters != NULL)

	mov	ecx, DWORD PTR [eax+68]
	test	ecx, ecx
	je	SHORT $LN150@xmlParseTr
$LN718@xmlParseTr:

; 11576: 				ctxt->sax->characters(ctxt->userData,
; 11577: 				                      ctxt->input->cur, tmp);
; 11578: 			}
; 11579: 			if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR [ebx+36]
	push	esi
	push	DWORD PTR [eax+16]
	push	DWORD PTR [ebx+4]
	call	ecx
	add	esp, 12					; 0000000cH
$LN150@xmlParseTr:
	cmp	DWORD PTR [ebx+172], -1
	je	$LN699@xmlParseTr

; 11580: 			    goto done;
; 11581: 			SKIPL(tmp);

	test	esi, esi
	jle	SHORT $LN16@xmlParseTr
$LL17@xmlParseTr:
	mov	ecx, DWORD PTR [ebx+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN152@xmlParseTr
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [ebx+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN153@xmlParseTr
$LN152@xmlParseTr:
	inc	DWORD PTR [ecx+32]
$LN153@xmlParseTr:
	mov	eax, DWORD PTR [ebx+36]
	inc	DWORD PTR [ebx+200]
	inc	DWORD PTR [eax+16]
	sub	esi, 1
	jne	SHORT $LL17@xmlParseTr
$LN16@xmlParseTr:
	mov	ecx, DWORD PTR [ebx+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN236@xmlParseTr
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow

; 12044: 			"PP: internal error, state == PUBLIC_LITERAL\n");
; 12045: 		ctxt->instate = XML_PARSER_START_TAG;
; 12046: #ifdef DEBUG_PUSH
; 12047: 		xmlGenericError(xmlGenericErrorContext,
; 12048: 			"PP: entering START_TAG\n");
; 12049: #endif
; 12050: 		break;
; 12051: 	}
; 12052:     }
; 12053: done:
; 12054: #ifdef DEBUG_PUSH
; 12055:     xmlGenericError(xmlGenericErrorContext, "PP: done %d\n", ret);
; 12056: #endif
; 12057:     return(ret);

	mov	esi, DWORD PTR _ret$1$[ebp]
	add	esp, 8
	mov	eax, esi
	mov	DWORD PTR [ebx+204], 0
	pop	edi

; 12066: 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 12067: 		     BAD_CAST buffer, NULL);
; 12068:     }
; 12069:     return(0);
; 12070: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN591@xmlParseTr:

; 11828: 		    if (ctxt->instate == XML_PARSER_EOF)
; 11829: 			goto done;
; 11830: 		    ctxt->instate = XML_PARSER_EPILOG;
; 11831:                     ctxt->progressive = 1;
; 11832: 		} else if ((cur == '<') && (next == '!') &&

	cmp	ecx, 4
	jl	SHORT $LN699@xmlParseTr
$LN216@xmlParseTr:

; 11833: 		           (avail < 4)) {
; 11834: 		    goto done;
; 11835: 		} else {
; 11836: 		    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);

	push	0
	push	5

; 11837: 		    xmlHaltParser(ctxt);
; 11838: #ifdef DEBUG_PUSH
; 11839: 		    xmlGenericError(xmlGenericErrorContext,
; 11840: 			    "PP: entering EOF\n");
; 11841: #endif
; 11842: 		    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
; 11843: 			ctxt->sax->endDocument(ctxt->userData);
; 11844: 		    goto done;

	jmp	$LN720@xmlParseTr
$LN31@xmlParseTr:

; 11928: #if 0
; 11929: 			        fprintf(stderr, "not found\n");
; 11930: #endif
; 11931: 			        goto not_end_of_int_subset;
; 11932: 			    }
; 11933: 			}
; 11934: #if 0
; 11935: 			fprintf(stderr, "end of stream\n");
; 11936: #endif
; 11937: 		        break;
; 11938: 
; 11939: 		    }
; 11940: not_end_of_int_subset:
; 11941:                     continue; /* for */
; 11942: 		}
; 11943: 		/*
; 11944: 		 * We didn't found the end of the Internal subset
; 11945: 		 */
; 11946:                 if (quote == 0)

	test	dh, dh
	je	$LN594@xmlParseTr
$LN236@xmlParseTr:

; 12044: 			"PP: internal error, state == PUBLIC_LITERAL\n");
; 12045: 		ctxt->instate = XML_PARSER_START_TAG;
; 12046: #ifdef DEBUG_PUSH
; 12047: 		xmlGenericError(xmlGenericErrorContext,
; 12048: 			"PP: entering START_TAG\n");
; 12049: #endif
; 12050: 		break;
; 12051: 	}
; 12052:     }
; 12053: done:
; 12054: #ifdef DEBUG_PUSH
; 12055:     xmlGenericError(xmlGenericErrorContext, "PP: done %d\n", ret);
; 12056: #endif
; 12057:     return(ret);

	mov	DWORD PTR [ebx+204], 0
$LN699@xmlParseTr:
	mov	esi, DWORD PTR _ret$1$[ebp]
$done$729:
	pop	edi
	mov	eax, esi

; 12066: 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 12067: 		     BAD_CAST buffer, NULL);
; 12068:     }
; 12069:     return(0);
; 12070: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN728@xmlParseTr:
	DD	$LN699@xmlParseTr
	DD	$LN42@xmlParseTr
	DD	$LN168@xmlParseTr
	DD	$LN243@xmlParseTr
	DD	$LN219@xmlParseTr
	DD	$LN189@xmlParseTr
	DD	$LN241@xmlParseTr
	DD	$LN65@xmlParseTr
	DD	$LN99@xmlParseTr
	DD	$LN142@xmlParseTr
	DD	$LN128@xmlParseTr
	DD	$LN244@xmlParseTr
	DD	$LN245@xmlParseTr
	DD	$LN246@xmlParseTr
	DD	$LN247@xmlParseTr
	DD	$LN204@xmlParseTr
	DD	$LN242@xmlParseTr
	DD	$LN248@xmlParseTr
_xmlParseTryOrFinish ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCheckCdataPush
_TEXT	SEGMENT
_utf$ = 8						; size = 4
tv972 = 11						; size = 1
_len$ = 12						; size = 4
_complete$ = 16						; size = 4
_xmlCheckCdataPush PROC					; COMDAT

; 11023: xmlCheckCdataPush(const xmlChar *utf, int len, int complete) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _utf$[ebp]
	test	esi, esi
	je	$LN6@xmlCheckCd

; 11024:     int ix;
; 11025:     unsigned char c;
; 11026:     int codepoint;
; 11027: 
; 11028:     if ((utf == NULL) || (len <= 0))

	mov	edi, DWORD PTR _len$[ebp]
	test	edi, edi
	jle	$LN6@xmlCheckCd

; 11030: 
; 11031:     for (ix = 0; ix < len;) {      /* string is 0-terminated */

	xor	edx, edx
	push	ebx
$LL2@xmlCheckCd:

; 11032:         c = utf[ix];

	mov	cl, BYTE PTR [edx+esi]

; 11033:         if ((c & 0x80) == 0x00) {	/* 1-byte code, starts with 10 */

	test	cl, cl
	js	SHORT $LN7@xmlCheckCd

; 11034: 	    if (c >= 0x20)

	cmp	cl, 32					; 00000020H
	jae	SHORT $LN13@xmlCheckCd

; 11035: 		ix++;
; 11036: 	    else if ((c == 0xA) || (c == 0xD) || (c == 0x9))

	cmp	cl, 10					; 0000000aH
	je	SHORT $LN13@xmlCheckCd
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN13@xmlCheckCd
	cmp	cl, 9
	jne	$LN25@xmlCheckCd
$LN13@xmlCheckCd:

; 11037: 	        ix++;
; 11038: 	    else
; 11039: 	        return(-ix);
; 11040: 	} else if ((c & 0xe0) == 0xc0) {/* 2-byte code, starts with 110 */

	mov	eax, 1
	jmp	$LN26@xmlCheckCd
$LN7@xmlCheckCd:
	mov	al, cl
	and	al, 224					; 000000e0H
	cmp	al, 192					; 000000c0H
	jne	SHORT $LN14@xmlCheckCd

; 11041: 	    if (ix + 2 > len) return(complete ? -ix : ix);

	lea	eax, DWORD PTR [edx+2]
	cmp	eax, edi
	jg	$LN75@xmlCheckCd

; 11042: 	    if ((utf[ix+1] & 0xc0 ) != 0x80)

	mov	bl, BYTE PTR [edx+esi+1]
	mov	al, bl
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	$LN25@xmlCheckCd

; 11043: 	        return(-ix);
; 11044: 	    codepoint = (utf[ix] & 0x1f) << 6;
; 11045: 	    codepoint |= utf[ix+1] & 0x3f;

	movzx	ecx, cl
	and	ecx, 31					; 0000001fH
	movzx	eax, bl
	shl	ecx, 6
	and	eax, 63					; 0000003fH
	or	ecx, eax

; 11046: 	    if (!xmlIsCharQ(codepoint))

	cmp	ecx, 256				; 00000100H
	jae	SHORT $LN42@xmlCheckCd
	cmp	ecx, 9
	jb	SHORT $LN34@xmlCheckCd
	cmp	ecx, 10					; 0000000aH
	jbe	SHORT $LN42@xmlCheckCd
$LN34@xmlCheckCd:
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN42@xmlCheckCd
	cmp	ecx, 32					; 00000020H
	jb	SHORT $LN25@xmlCheckCd
$LN42@xmlCheckCd:

; 11047: 	        return(-ix);
; 11048: 	    ix += 2;

	mov	eax, 2
	jmp	$LN26@xmlCheckCd
$LN14@xmlCheckCd:

; 11049: 	} else if ((c & 0xf0) == 0xe0) {/* 3-byte code, starts with 1110 */

	mov	al, cl
	and	al, 240					; 000000f0H
	cmp	al, 224					; 000000e0H
	jne	$LN19@xmlCheckCd

; 11050: 	    if (ix + 3 > len) return(complete ? -ix : ix);

	lea	eax, DWORD PTR [edx+3]
	cmp	eax, edi
	jg	$LN75@xmlCheckCd

; 11051: 	    if (((utf[ix+1] & 0xc0) != 0x80) ||

	mov	bl, BYTE PTR [edx+esi+1]
	mov	al, bl
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	SHORT $LN25@xmlCheckCd
	mov	bh, BYTE PTR [edx+esi+2]
	mov	al, bh
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	SHORT $LN25@xmlCheckCd

; 11052: 	        ((utf[ix+2] & 0xc0) != 0x80))
; 11053: 		    return(-ix);
; 11054: 	    codepoint = (utf[ix] & 0xf) << 12;
; 11055: 	    codepoint |= (utf[ix+1] & 0x3f) << 6;
; 11056: 	    codepoint |= utf[ix+2] & 0x3f;

	movzx	ecx, cl
	and	ecx, 15					; 0000000fH
	movzx	eax, bl
	shl	ecx, 6
	and	eax, 63					; 0000003fH
	or	ecx, eax
	movzx	eax, bh
	shl	ecx, 6
	and	eax, 63					; 0000003fH
	or	ecx, eax

; 11057: 	    if (!xmlIsCharQ(codepoint))

	cmp	ecx, 256				; 00000100H
	jae	SHORT $LN54@xmlCheckCd
	cmp	ecx, 9
	jb	SHORT $LN46@xmlCheckCd
	cmp	ecx, 10					; 0000000aH
	jbe	SHORT $LN50@xmlCheckCd
$LN46@xmlCheckCd:
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN50@xmlCheckCd
	cmp	ecx, 32					; 00000020H
	jae	SHORT $LN50@xmlCheckCd
$LN25@xmlCheckCd:
	pop	ebx

; 11073: 	} else				/* unknown encoding */
; 11074: 	    return(-ix);

	neg	edx
	pop	edi

; 11075:       }
; 11076:       return(ix);

	mov	eax, edx

; 11077: }

	pop	esi
	pop	ebp
	ret	0
$LN54@xmlCheckCd:

; 11057: 	    if (!xmlIsCharQ(codepoint))

	cmp	ecx, 55295				; 0000d7ffH
	jbe	SHORT $LN50@xmlCheckCd
	cmp	ecx, 57344				; 0000e000H
	jb	SHORT $LN25@xmlCheckCd
	cmp	ecx, 65533				; 0000fffdH
	ja	SHORT $LN25@xmlCheckCd
$LN50@xmlCheckCd:

; 11058: 	        return(-ix);
; 11059: 	    ix += 3;

	mov	eax, 3
	jmp	$LN26@xmlCheckCd
$LN19@xmlCheckCd:

; 11060: 	} else if ((c & 0xf8) == 0xf0) {/* 4-byte code, starts with 11110 */

	mov	al, cl
	and	al, 248					; 000000f8H
	cmp	al, 240					; 000000f0H
	jne	SHORT $LN25@xmlCheckCd

; 11061: 	    if (ix + 4 > len) return(complete ? -ix : ix);

	lea	eax, DWORD PTR [edx+4]
	cmp	eax, edi
	jg	$LN75@xmlCheckCd

; 11062: 	    if (((utf[ix+1] & 0xc0) != 0x80) ||
; 11063: 	        ((utf[ix+2] & 0xc0) != 0x80) ||

	mov	bl, BYTE PTR [edx+esi+1]
	mov	al, bl
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	SHORT $LN25@xmlCheckCd
	mov	bh, BYTE PTR [edx+esi+2]
	mov	al, bh
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	SHORT $LN25@xmlCheckCd
	mov	al, BYTE PTR [edx+esi+3]
	mov	BYTE PTR tv972[ebp], al
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	SHORT $LN25@xmlCheckCd

; 11064: 		((utf[ix+3] & 0xc0) != 0x80))
; 11065: 		    return(-ix);
; 11066: 	    codepoint = (utf[ix] & 0x7) << 18;
; 11067: 	    codepoint |= (utf[ix+1] & 0x3f) << 12;
; 11068: 	    codepoint |= (utf[ix+2] & 0x3f) << 6;
; 11069: 	    codepoint |= utf[ix+3] & 0x3f;

	movzx	eax, cl
	and	eax, 7
	movzx	ecx, bl
	shl	eax, 6
	and	ecx, 63					; 0000003fH
	or	eax, ecx
	movzx	ecx, bh
	shl	eax, 6
	and	ecx, 63					; 0000003fH
	or	eax, ecx
	movzx	ecx, BYTE PTR tv972[ebp]
	shl	eax, 6
	and	ecx, 63					; 0000003fH
	or	eax, ecx

; 11070: 	    if (!xmlIsCharQ(codepoint))

	cmp	eax, 256				; 00000100H
	jae	SHORT $LN66@xmlCheckCd
	cmp	eax, 9
	jb	SHORT $LN58@xmlCheckCd
	cmp	eax, 10					; 0000000aH
	jbe	SHORT $LN62@xmlCheckCd
$LN58@xmlCheckCd:
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN62@xmlCheckCd
	cmp	eax, 32					; 00000020H
	jb	$LN25@xmlCheckCd
	jmp	SHORT $LN62@xmlCheckCd
$LN66@xmlCheckCd:
	cmp	eax, 55295				; 0000d7ffH
	jbe	SHORT $LN62@xmlCheckCd
	cmp	eax, 57344				; 0000e000H
	jb	SHORT $LN61@xmlCheckCd
	cmp	eax, 65533				; 0000fffdH
	jbe	SHORT $LN62@xmlCheckCd
$LN61@xmlCheckCd:
	add	eax, -65536				; ffff0000H
	cmp	eax, 1048575				; 000fffffH
	ja	$LN25@xmlCheckCd
$LN62@xmlCheckCd:

; 11071: 	        return(-ix);
; 11072: 	    ix += 4;

	mov	eax, 4
$LN26@xmlCheckCd:

; 11030: 
; 11031:     for (ix = 0; ix < len;) {      /* string is 0-terminated */

	add	edx, eax
	cmp	edx, edi
	jl	$LL2@xmlCheckCd

; 11075:       }
; 11076:       return(ix);

	pop	ebx
	pop	edi
	mov	eax, edx

; 11077: }

	pop	esi
	pop	ebp
	ret	0
$LN75@xmlCheckCd:

; 11061: 	    if (ix + 4 > len) return(complete ? -ix : ix);

	mov	eax, edx
	neg	eax
	cmp	DWORD PTR _complete$[ebp], 0
	pop	ebx
	pop	edi
	cmove	eax, edx

; 11077: }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlCheckCd:
	pop	edi

; 11029:         return(0);

	xor	eax, eax

; 11077: }

	pop	esi
	pop	ebp
	ret	0
_xmlCheckCdataPush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseGetLasts
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_lastlt$ = 12						; size = 4
_lastgt$ = 16						; size = 4
_xmlParseGetLasts PROC					; COMDAT

; 10964:                  const xmlChar **lastgt) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	test	edx, edx
	je	$LN13@xmlParseGe

; 10965:     const xmlChar *tmp;
; 10966: 
; 10967:     if ((ctxt == NULL) || (lastlt == NULL) || (lastgt == NULL)) {

	mov	esi, DWORD PTR _lastlt$[ebp]
	test	esi, esi
	je	$LN13@xmlParseGe
	mov	edi, DWORD PTR _lastgt$[ebp]
	test	edi, edi
	je	$LN13@xmlParseGe

; 10969: 		    "Internal error: xmlParseGetLasts\n");
; 10970: 	return;
; 10971:     }
; 10972:     if ((ctxt->progressive != 0) && (ctxt->inputNr == 1)) {

	cmp	DWORD PTR [edx+292], 0
	je	$LN14@xmlParseGe
	cmp	DWORD PTR [edx+40], 1
	jne	$LN14@xmlParseGe

; 10973:         tmp = ctxt->input->end;

	mov	eax, DWORD PTR [edx+36]

; 10974: 	tmp--;

	mov	ecx, DWORD PTR [eax+20]

; 10975: 	while ((tmp >= ctxt->input->base) && (*tmp != '<')) tmp--;

	mov	eax, DWORD PTR [eax+12]
	dec	ecx
	cmp	ecx, eax
	jb	SHORT $LN55@xmlParseGe
$LL2@xmlParseGe:
	cmp	BYTE PTR [ecx], 60			; 0000003cH
	je	SHORT $LN48@xmlParseGe
	dec	ecx
	cmp	ecx, eax
	jae	SHORT $LL2@xmlParseGe
$LN48@xmlParseGe:

; 10976: 	if (tmp < ctxt->input->base) {

	cmp	ecx, eax
	jae	SHORT $LN16@xmlParseGe
$LN55@xmlParseGe:

; 10977: 	    *lastlt = NULL;

	mov	DWORD PTR [esi], 0

; 10978: 	    *lastgt = NULL;

	xor	ecx, ecx

; 11001: 		    *lastgt = tmp;
; 11002: 		else
; 11003: 		    *lastgt = NULL;
; 11004: 	    }
; 11005: 	}
; 11006:     } else {

	mov	DWORD PTR [edi], ecx
	pop	edi

; 11009:     }
; 11010: }

	pop	esi
	pop	ebp
	ret	0
$LN16@xmlParseGe:

; 10979: 	} else {
; 10980: 	    *lastlt = tmp;

	mov	DWORD PTR [esi], ecx

; 10981: 	    tmp++;

	inc	ecx
	push	ebx

; 10982: 	    while ((tmp < ctxt->input->end) && (*tmp != '>')) {

	mov	ebx, DWORD PTR [edx+36]
	mov	edx, DWORD PTR [ebx+20]
	cmp	ecx, edx
	jae	SHORT $LN57@xmlParseGe
	npad	1
$LL4@xmlParseGe:
	mov	al, BYTE PTR [ecx]
	cmp	al, 62					; 0000003eH
	je	SHORT $LN51@xmlParseGe

; 10983: 	        if (*tmp == '\'') {

	inc	ecx
	cmp	al, 39					; 00000027H
	jne	SHORT $LN18@xmlParseGe

; 10984: 		    tmp++;

	mov	eax, ecx

; 10985: 		    while ((tmp < ctxt->input->end) && (*tmp != '\'')) tmp++;

	cmp	eax, edx
	jae	SHORT $LN50@xmlParseGe
$LL6@xmlParseGe:
	cmp	BYTE PTR [eax], 39			; 00000027H
	je	SHORT $LN50@xmlParseGe
	inc	eax
	cmp	eax, edx
	jb	SHORT $LL6@xmlParseGe

; 10986: 		    if (tmp < ctxt->input->end) tmp++;
; 10987: 		} else if (*tmp == '"') {

	jmp	SHORT $LN50@xmlParseGe
$LN18@xmlParseGe:
	cmp	al, 34					; 00000022H
	jne	SHORT $LN21@xmlParseGe

; 10988: 		    tmp++;

	mov	eax, ecx

; 10989: 		    while ((tmp < ctxt->input->end) && (*tmp != '"')) tmp++;

	cmp	eax, edx
	jae	SHORT $LN50@xmlParseGe
$LL8@xmlParseGe:
	cmp	BYTE PTR [eax], 34			; 00000022H
	je	SHORT $LN50@xmlParseGe
	inc	eax
	cmp	eax, edx
	jb	SHORT $LL8@xmlParseGe
$LN50@xmlParseGe:

; 10982: 	    while ((tmp < ctxt->input->end) && (*tmp != '>')) {

	cmp	eax, edx
	lea	ecx, DWORD PTR [eax+1]
	cmovae	ecx, eax
$LN21@xmlParseGe:
	cmp	ecx, edx
	jb	SHORT $LL4@xmlParseGe
$LN51@xmlParseGe:

; 10990: 		    if (tmp < ctxt->input->end) tmp++;
; 10991: 		} else
; 10992: 		    tmp++;
; 10993: 	    }
; 10994: 	    if (tmp < ctxt->input->end)

	cmp	ecx, edx
	jb	SHORT $LN53@xmlParseGe
$LN57@xmlParseGe:

; 10995: 	        *lastgt = tmp;
; 10996: 	    else {
; 10997: 	        tmp = *lastlt;
; 10998: 		tmp--;

	mov	eax, DWORD PTR [esi]

; 10999: 		while ((tmp >= ctxt->input->base) && (*tmp != '>')) tmp--;

	mov	edx, DWORD PTR [ebx+12]
	dec	eax
	cmp	eax, edx
	jb	SHORT $LN52@xmlParseGe
	npad	5
$LL10@xmlParseGe:
	cmp	BYTE PTR [eax], 62			; 0000003eH
	je	SHORT $LN52@xmlParseGe
	dec	eax
	cmp	eax, edx
	jae	SHORT $LL10@xmlParseGe
$LN52@xmlParseGe:

; 11000: 		if (tmp >= ctxt->input->base)

	xor	ecx, ecx
	cmp	eax, edx
	cmovae	ecx, eax
$LN53@xmlParseGe:

; 11001: 		    *lastgt = tmp;
; 11002: 		else
; 11003: 		    *lastgt = NULL;
; 11004: 	    }
; 11005: 	}
; 11006:     } else {

	pop	ebx
	mov	DWORD PTR [edi], ecx
	pop	edi

; 11009:     }
; 11010: }

	pop	esi
	pop	ebp
	ret	0
$LN14@xmlParseGe:

; 11007:         *lastlt = NULL;

	mov	DWORD PTR [esi], 0

; 11008: 	*lastgt = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi

; 11009:     }
; 11010: }

	pop	esi
	pop	ebp
	ret	0
$LN13@xmlParseGe:

; 10968: 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericErrorContext
	mov	esi, DWORD PTR [eax]
	call	___xmlGenericError
	push	OFFSET ??_C@_0CC@HDEJLGKL@Internal?5error?3?5xmlParseGetLast@
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 8
	pop	edi

; 11009:     }
; 11010: }

	pop	esi
	pop	ebp
	ret	0
_xmlParseGetLasts ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseLookupSequence
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_first$ = 12						; size = 1
_next$ = 16						; size = 1
_third$ = 20						; size = 1
_xmlParseLookupSequence PROC				; COMDAT

; 10892:                        xmlChar next, xmlChar third) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	ebx, DWORD PTR [ecx+36]
	test	ebx, ebx
	je	$LN25@xmlParseLo

; 10893:     int base, len;
; 10894:     xmlParserInputPtr in;
; 10895:     const xmlChar *buf;
; 10896: 
; 10897:     in = ctxt->input;
; 10898:     if (in == NULL) return(-1);
; 10899:     base = in->cur - in->base;

	mov	eax, DWORD PTR [ebx+16]
	mov	edi, DWORD PTR [ebx+12]
	sub	eax, edi

; 10900:     if (base < 0) return(-1);

	js	$LN25@xmlParseLo

; 10901:     if (ctxt->checkIndex > base)

	push	esi
	mov	esi, DWORD PTR [ecx+204]

; 10902:         base = ctxt->checkIndex;
; 10903:     if (in->buf == NULL) {

	cmp	esi, eax
	cmovle	esi, eax
	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	jne	SHORT $LN8@xmlParseLo

; 10904: 	buf = in->base;
; 10905: 	len = in->length;

	mov	eax, DWORD PTR [ebx+24]

; 10906:     } else {

	jmp	SHORT $LN9@xmlParseLo
$LN8@xmlParseLo:

; 10907: 	buf = xmlBufContent(in->buf->buffer);

	push	DWORD PTR [eax+16]
	call	_xmlBufContent

; 10908: 	len = xmlBufUse(in->buf->buffer);

	mov	ecx, DWORD PTR [ebx]
	mov	edi, eax
	push	DWORD PTR [ecx+16]
	call	_xmlBufUse
	add	esp, 8
$LN9@xmlParseLo:

; 10909:     }
; 10910:     /* take into account the sequence length */
; 10911:     if (third) len -= 2;

	mov	dl, BYTE PTR _third$[ebp]
	mov	cl, BYTE PTR _next$[ebp]
	test	dl, dl
	je	SHORT $LN10@xmlParseLo
	sub	eax, 2
	jmp	SHORT $LN12@xmlParseLo
$LN10@xmlParseLo:

; 10912:     else if (next) len --;

	test	cl, cl
	je	SHORT $LN12@xmlParseLo
	dec	eax
$LN12@xmlParseLo:

; 10913:     for (;base < len;base++) {

	cmp	esi, eax
	jge	SHORT $LN26@xmlParseLo
	mov	ch, BYTE PTR _first$[ebp]
$LL4@xmlParseLo:

; 10914:         if (buf[base] == first) {

	cmp	BYTE PTR [edi+esi], ch
	jne	SHORT $LN2@xmlParseLo

; 10915: 	    if (third != 0) {

	test	dl, dl
	je	SHORT $LN14@xmlParseLo

; 10916: 		if ((buf[base + 1] != next) ||

	cmp	BYTE PTR [edi+esi+1], cl
	jne	SHORT $LN2@xmlParseLo
	cmp	BYTE PTR [edi+esi+2], dl

; 10917: 		    (buf[base + 2] != third)) continue;

	jmp	SHORT $LN28@xmlParseLo
$LN14@xmlParseLo:

; 10918: 	    } else if (next != 0) {

	test	cl, cl
	je	SHORT $LN16@xmlParseLo

; 10919: 		if (buf[base + 1] != next) continue;

	cmp	BYTE PTR [edi+esi+1], cl
$LN28@xmlParseLo:

; 10913:     for (;base < len;base++) {

	je	SHORT $LN16@xmlParseLo
$LN2@xmlParseLo:
	inc	esi
	cmp	esi, eax
	jl	SHORT $LL4@xmlParseLo
$LN26@xmlParseLo:

; 10937: 	}
; 10938:     }
; 10939:     ctxt->checkIndex = base;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+204], esi

; 10940: #ifdef DEBUG_PUSH
; 10941:     if (next == 0)
; 10942: 	xmlGenericError(xmlGenericErrorContext,
; 10943: 		"PP: lookup '%c' failed\n", first);
; 10944:     else if (third == 0)
; 10945: 	xmlGenericError(xmlGenericErrorContext,
; 10946: 		"PP: lookup '%c%c' failed\n", first, next);
; 10947:     else
; 10948: 	xmlGenericError(xmlGenericErrorContext,
; 10949: 		"PP: lookup '%c%c%c' failed\n", first, next, third);
; 10950: #endif
; 10951:     return(-1);

	or	eax, -1
	pop	esi
	pop	edi

; 10952: }

	pop	ebx
	pop	ebp
	ret	0
$LN16@xmlParseLo:

; 10920: 	    }
; 10921: 	    ctxt->checkIndex = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+204], 0

; 10922: #ifdef DEBUG_PUSH
; 10923: 	    if (next == 0)
; 10924: 		xmlGenericError(xmlGenericErrorContext,
; 10925: 			"PP: lookup '%c' found at %d\n",
; 10926: 			first, base);
; 10927: 	    else if (third == 0)
; 10928: 		xmlGenericError(xmlGenericErrorContext,
; 10929: 			"PP: lookup '%c%c' found at %d\n",
; 10930: 			first, next, base);
; 10931: 	    else
; 10932: 		xmlGenericError(xmlGenericErrorContext,
; 10933: 			"PP: lookup '%c%c%c' found at %d\n",
; 10934: 			first, next, third, base);
; 10935: #endif
; 10936: 	    return(base - (in->cur - in->base));

	mov	eax, DWORD PTR [ebx+12]
	sub	eax, DWORD PTR [ebx+16]
	add	eax, esi
	pop	esi
	pop	edi

; 10952: }

	pop	ebx
	pop	ebp
	ret	0
$LN25@xmlParseLo:
	pop	edi

; 10900:     if (base < 0) return(-1);

	or	eax, -1

; 10952: }

	pop	ebx
	pop	ebp
	ret	0
_xmlParseLookupSequence ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEndTag2
_TEXT	SEGMENT
_prefix2$1 = 8						; size = 4
_ctxt$ = 8						; size = 4
_prefix$ = 12						; size = 4
_URI$ = 16						; size = 4
_line$ = 20						; size = 4
_nsNr$ = 24						; size = 4
_tlen$ = 28						; size = 4
_xmlParseEndTag2 PROC					; COMDAT

; 9619 :                 const xmlChar *URI, int line, int nsNr, int tlen) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN5@xmlParseEn

; 9620 :     const xmlChar *name;
; 9621 :     size_t curLength;
; 9622 : 
; 9623 :     GROW;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN5@xmlParseEn
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN5@xmlParseEn:

; 9624 :     if ((RAW != '<') || (NXT(1) != '/')) {

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	cmp	BYTE PTR [ecx], 60			; 0000003cH
	jne	$LN7@xmlParseEn
	cmp	BYTE PTR [ecx+1], 47			; 0000002fH
	jne	$LN7@xmlParseEn

; 9625 : 	xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);
; 9626 : 	return;
; 9627 :     }
; 9628 :     SKIP(2);

	add	DWORD PTR [esi+200], 2
	add	DWORD PTR [eax+16], 2
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 2
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseEn
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 8
$LN2@xmlParseEn:

; 9629 : 
; 9630 :     curLength = ctxt->input->end - ctxt->input->cur;

	mov	eax, DWORD PTR [ecx+16]
	push	ebx
	push	edi

; 9631 :     if ((tlen > 0) && (curLength >= (size_t)tlen) &&

	mov	edi, DWORD PTR _tlen$[ebp]
	test	edi, edi
	jle	SHORT $LN9@xmlParseEn

; 9629 : 
; 9630 :     curLength = ctxt->input->end - ctxt->input->cur;

	mov	ebx, DWORD PTR [ecx+20]
	sub	ebx, eax

; 9631 :     if ((tlen > 0) && (curLength >= (size_t)tlen) &&

	cmp	ebx, edi
	jb	SHORT $LN9@xmlParseEn
	push	edi
	push	DWORD PTR [esi+184]
	push	eax
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@xmlParseEn

; 9632 :         (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
; 9633 :         if ((curLength >= (size_t)(tlen + 1)) &&

	lea	eax, DWORD PTR [edi+1]
	cmp	ebx, eax
	jb	SHORT $LN187@xmlParseEn
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax+edi], 62			; 0000003eH
	jne	SHORT $LN187@xmlParseEn

; 9634 : 	    (ctxt->input->cur[tlen] == '>')) {
; 9635 : 	    ctxt->input->cur += tlen + 1;

	inc	eax
	add	eax, edi
	mov	DWORD PTR [ecx+16], eax

; 9636 : 	    ctxt->input->col += tlen + 1;

	lea	eax, DWORD PTR [edi+1]
	mov	ecx, DWORD PTR [esi+36]
	add	DWORD PTR [ecx+32], eax

; 9637 : 	    goto done;

	jmp	$done$194
$LN187@xmlParseEn:

; 9638 : 	}
; 9639 : 	ctxt->input->cur += tlen;

	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+16], edi

; 9640 : 	ctxt->input->col += tlen;

	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], edi

; 9641 : 	name = (xmlChar*)1;
; 9642 :     } else {

	jmp	$LN192@xmlParseEn
$LN9@xmlParseEn:

; 9643 : 	if (prefix == NULL)

	cmp	DWORD PTR _prefix$[ebp], 0
	mov	ebx, DWORD PTR [esi+184]
	jne	SHORT $LN12@xmlParseEn

; 9644 : 	    name = xmlParseNameAndCompare(ctxt, ctxt->name);

	push	ebx
	push	esi
	call	_xmlParseNameAndCompare
	add	esp, 8
	mov	edi, eax
	jmp	$LN108@xmlParseEn
$LN12@xmlParseEn:

; 8781 :     GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN102@xmlParseEn
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN102@xmlParseEn
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN102@xmlParseEn:

; 8782 :     in = ctxt->input->cur;

	mov	edi, DWORD PTR [esi+36]

; 8783 : 
; 8784 :     cmp = prefix;

	mov	ecx, DWORD PTR _prefix$[ebp]
	mov	eax, DWORD PTR [edi+16]

; 8785 :     while (*in != 0 && *in == *cmp) {

	mov	dl, BYTE PTR [eax]
	test	dl, dl
	je	SHORT $LN188@xmlParseEn
	npad	5
$LL97@xmlParseEn:
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN188@xmlParseEn
	mov	dl, BYTE PTR [eax+1]

; 8786 : 	++in;

	inc	eax

; 8787 : 	++cmp;

	inc	ecx
	test	dl, dl
	jne	SHORT $LL97@xmlParseEn
$LN188@xmlParseEn:

; 8788 :     }
; 8789 :     if ((*cmp == 0) && (*in == ':')) {

	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN104@xmlParseEn
	cmp	BYTE PTR [eax], 58			; 0000003aH
	jne	SHORT $LN104@xmlParseEn

; 8790 :         in++;
; 8791 : 	cmp = name;
; 8792 : 	while (*in != 0 && *in == *cmp) {

	mov	cl, BYTE PTR [eax+1]
	inc	eax
	mov	edx, ebx
	test	cl, cl
	je	SHORT $LN189@xmlParseEn
$LL99@xmlParseEn:
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN189@xmlParseEn
	mov	cl, BYTE PTR [eax+1]

; 8793 : 	    ++in;

	inc	eax

; 8794 : 	    ++cmp;

	inc	edx
	test	cl, cl
	jne	SHORT $LL99@xmlParseEn
$LN189@xmlParseEn:

; 8795 : 	}
; 8796 : 	if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN104@xmlParseEn
	mov	cl, BYTE PTR [eax]
	cmp	cl, 62					; 0000003eH
	je	SHORT $LN106@xmlParseEn
	cmp	cl, 32					; 00000020H
	je	SHORT $LN106@xmlParseEn
	cmp	cl, 9
	jb	SHORT $LN107@xmlParseEn
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN106@xmlParseEn
$LN107@xmlParseEn:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN104@xmlParseEn
$LN106@xmlParseEn:

; 8797 : 	    /* success */
; 8798 : 	    ctxt->input->cur = in;

	mov	DWORD PTR [edi+16], eax

; 8799 : 	    return((const xmlChar*) 1);

	jmp	SHORT $LN192@xmlParseEn
$LN104@xmlParseEn:

; 8800 : 	}
; 8801 :     }
; 8802 :     /*
; 8803 :      * all strings coms from the dictionary, equality can be done directly
; 8804 :      */
; 8805 :     ret = xmlParseQName (ctxt, &prefix2);

	lea	eax, DWORD PTR _prefix2$1[ebp]
	push	eax
	push	esi
	call	_xmlParseQName
	mov	edi, eax
	add	esp, 8

; 8806 :     if ((ret == name) && (prefix == prefix2))

	cmp	edi, ebx
	jne	SHORT $LN108@xmlParseEn
	mov	eax, DWORD PTR _prefix$[ebp]
	cmp	eax, DWORD PTR _prefix2$1[ebp]
	jne	SHORT $LN108@xmlParseEn
$LN192@xmlParseEn:

; 9645 : 	else
; 9646 : 	    name = xmlParseQNameAndCompare(ctxt, ctxt->name, prefix);
; 9647 :     }
; 9648 : 
; 9649 :     /*
; 9650 :      * We should definitely be at the ending "S? '>'" part
; 9651 :      */
; 9652 :     GROW;

	mov	edi, 1
$LN108@xmlParseEn:
	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN14@xmlParseEn
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN14@xmlParseEn
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN14@xmlParseEn:

; 9653 :     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	$LN190@xmlParseEn

; 9654 :         return;
; 9655 :     SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 9656 :     if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [ecx+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 9
	jb	SHORT $LN20@xmlParseEn
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN19@xmlParseEn
$LN20@xmlParseEn:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN19@xmlParseEn
	cmp	al, 32					; 00000020H
	jb	SHORT $LN18@xmlParseEn
$LN19@xmlParseEn:
	cmp	al, 62					; 0000003eH
	je	SHORT $LN16@xmlParseEn
$LN18@xmlParseEn:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN113@xmlParseEn
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN21@xmlParseEn
$LN113@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0N@HPGHEIE@expected?5?8?$DO?8@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	73					; 00000049H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 73			; 00000049H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN21@xmlParseEn

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1

; 9657 : 	xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
; 9658 :     } else

	jmp	SHORT $LN21@xmlParseEn
$LN16@xmlParseEn:

; 9659 : 	NEXT1;

	inc	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [esi+36]
	inc	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [esi+36]
	inc	DWORD PTR [esi+200]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN21@xmlParseEn
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN21@xmlParseEn:

; 9660 : 
; 9661 :     /*
; 9662 :      * [ WFC: Element Type Match ]
; 9663 :      * The Name in an element's end-tag must match the element type in the
; 9664 :      * start-tag.
; 9665 :      *
; 9666 :      */
; 9667 :     if (name != (xmlChar*)1) {

	cmp	edi, 1
	je	SHORT $done$194

; 9668 :         if (name == NULL) name = BAD_CAST "unparseable";
; 9669 :         if ((line == 0) && (ctxt->node != NULL))

	mov	eax, DWORD PTR _line$[ebp]
	test	edi, edi
	mov	ecx, OFFSET ??_C@_0M@IAMGGMFE@unparseable@
	cmovne	ecx, edi
	test	eax, eax
	jne	SHORT $LN24@xmlParseEn
	mov	edx, DWORD PTR [esi+52]
	test	edx, edx
	je	SHORT $LN24@xmlParseEn

; 9670 :             line = ctxt->node->line;

	movzx	eax, WORD PTR [edx+56]
$LN24@xmlParseEn:

; 9671 :         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,

	push	ecx
	push	eax
	push	DWORD PTR [esi+184]
	push	OFFSET ??_C@_0DE@OCMDIBAP@Opening?5and?5ending?5tag?5mismatch@
	push	76					; 0000004cH
	push	esi
	call	_xmlFatalErrMsgStrIntStr
	add	esp, 24					; 00000018H
$done$194:

; 9672 : 		     "Opening and ending tag mismatch: %s line %d and %s\n",
; 9673 : 		                ctxt->name, line, name);
; 9674 :     }
; 9675 : 
; 9676 :     /*
; 9677 :      * SAX: End of Tag
; 9678 :      */
; 9679 : done:
; 9680 :     if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN25@xmlParseEn
	mov	eax, DWORD PTR [eax+120]
	test	eax, eax
	je	SHORT $LN25@xmlParseEn
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN25@xmlParseEn

; 9681 : 	(!ctxt->disableSAX))
; 9682 : 	ctxt->sax->endElementNs(ctxt->userData, ctxt->name, prefix, URI);

	push	DWORD PTR _URI$[ebp]
	push	DWORD PTR _prefix$[ebp]
	push	DWORD PTR [esi+184]
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 16					; 00000010H
$LN25@xmlParseEn:

; 9683 : 
; 9684 :     spacePop(ctxt);

	push	esi
	call	_spacePop

; 9685 :     if (nsNr != 0)

	mov	eax, DWORD PTR _nsNr$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN190@xmlParseEn

; 9686 : 	nsPop(ctxt, nsNr);

	push	eax
	push	esi
	call	_nsPop
	add	esp, 8
$LN190@xmlParseEn:
	pop	edi
	pop	ebx
$LN94@xmlParseEn:
	pop	esi

; 9687 :     return;
; 9688 : }

	pop	ebp
	ret	0
$LN7@xmlParseEn:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN31@xmlParseEn
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN94@xmlParseEn
$LN31@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BH@ELMJBAIC@EndTag?3?5?8?$DM?1?8?5not?5found@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	74					; 0000004aH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 74			; 0000004aH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN94@xmlParseEn

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
	pop	esi

; 9687 :     return;
; 9688 : }

	pop	ebp
	ret	0
_xmlParseEndTag2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseStartTag2
_TEXT	SEGMENT
tv4624 = -68						; size = 4
_inputid$1$ = -68					; size = 4
_q$1$ = -64						; size = 4
_cons$1$ = -60						; size = 4
_attval$1$ = -56					; size = 4
_i$1$ = -52						; size = 4
_attvalue$ = -52					; size = 4
_len$1$ = -48						; size = 4
_len$1 = -48						; size = 4
_nbdef$1$ = -44						; size = 4
_i$2$ = -40						; size = 4
_maxatts$1$ = -40					; size = 4
_alloc$2 = -36						; size = 4
_prefix$1$ = -32					; size = 4
tv4309 = -28						; size = 4
_aprefix$ = -28						; size = 4
_nratts$1$ = -24					; size = 4
tv4311 = -20						; size = 4
_attname$1$ = -20					; size = 4
_nbNs$1$ = -16						; size = 4
_localname$1$ = -12					; size = 4
_atts$1$ = -8						; size = 4
_nbatts$1$ = -4						; size = 4
_info1$1$ = 8						; size = 4
_defaults$1$ = 8					; size = 4
_attvalue$1$ = 8					; size = 4
_prefix$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_pref$ = 12						; size = 4
_URI$ = 16						; size = 4
_tlen$ = 20						; size = 4
_xmlParseStartTag2 PROC					; COMDAT

; 9180 :                   const xmlChar **URI, int *tlen) {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+300]
	mov	ecx, DWORD PTR [esi+36]
	mov	ebx, DWORD PTR [esi+328]
	mov	DWORD PTR _atts$1$[ebp], eax
	mov	eax, DWORD PTR [esi+304]
	mov	DWORD PTR _maxatts$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 60			; 0000003cH
	jne	$LN213@xmlParseSt

; 9181 :     const xmlChar *localname;
; 9182 :     const xmlChar *prefix;
; 9183 :     const xmlChar *attname;
; 9184 :     const xmlChar *aprefix;
; 9185 :     const xmlChar *nsname;
; 9186 :     xmlChar *attvalue;
; 9187 :     const xmlChar **atts = ctxt->atts;
; 9188 :     int maxatts = ctxt->maxatts;
; 9189 :     int nratts, nbatts, nbdef, inputid;
; 9190 :     int i, j, nbNs, attval;
; 9191 :     unsigned long cur;
; 9192 :     int nsNr = ctxt->nsNr;
; 9193 : 
; 9194 :     if (RAW != '<') return(NULL);
; 9195 :     NEXT1;

	inc	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [esi+36]
	inc	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [esi+36]
	inc	DWORD PTR [esi+200]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN35@xmlParseSt
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 8
$LN35@xmlParseSt:

; 9196 : 
; 9197 :     /*
; 9198 :      * NOTE: it is crucial with the SAX2 API to never call SHRINK beyond that
; 9199 :      *       point since the attribute values may be stored as pointers to
; 9200 :      *       the buffer and calling SHRINK would destroy them !
; 9201 :      *       The Shrinking is only possible once the full set of attribute
; 9202 :      *       callbacks have been done.
; 9203 :      */
; 9204 :     SHRINK;

	cmp	DWORD PTR [esi+292], 0
	mov	edx, ecx
	jne	SHORT $LN36@xmlParseSt
	mov	edi, DWORD PTR [ecx+16]
	mov	eax, edi
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN36@xmlParseSt
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edi
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN36@xmlParseSt
	push	esi
	call	_xmlSHRINK
	mov	edx, DWORD PTR [esi+36]
	add	esp, 4
$LN36@xmlParseSt:

; 9205 :     cur = ctxt->input->cur - ctxt->input->base;
; 9206 :     inputid = ctxt->input->id;

	mov	eax, DWORD PTR [edx+56]
	mov	edi, DWORD PTR [edx+16]
	sub	edi, DWORD PTR [edx+12]
	mov	DWORD PTR _inputid$1$[ebp], eax

; 9207 :     nbatts = 0;
; 9208 :     nratts = 0;
; 9209 :     nbdef = 0;
; 9210 :     nbNs = 0;
; 9211 :     attval = 0;
; 9212 :     /* Forget any namespaces added during an earlier parse of this element. */
; 9213 :     ctxt->nsNr = nsNr;
; 9214 : 
; 9215 :     localname = xmlParseQName(ctxt, &prefix);

	lea	eax, DWORD PTR _prefix$[ebp]
	push	eax
	push	esi
	mov	DWORD PTR _nbatts$1$[ebp], 0
	mov	DWORD PTR _nratts$1$[ebp], 0
	mov	DWORD PTR _nbdef$1$[ebp], 0
	mov	DWORD PTR _nbNs$1$[ebp], 0
	mov	DWORD PTR _attval$1$[ebp], 0
	mov	DWORD PTR [esi+328], ebx
	call	_xmlParseQName
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _localname$1$[ebp], ebx

; 9216 :     if (localname == NULL) {

	test	ebx, ebx
	jne	SHORT $LN37@xmlParseSt

; 9217 : 	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0CA@LKOHNLNN@StartTag?3?5invalid?5element?5name?6@
	push	68					; 00000044H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN213@xmlParseSt:

; 9600 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@xmlParseSt:

; 9218 : 		       "StartTag: invalid element name\n");
; 9219 :         return(NULL);
; 9220 :     }
; 9221 :     *tlen = ctxt->input->cur - ctxt->input->base - cur;

	mov	eax, DWORD PTR [esi+36]

; 9222 : 
; 9223 :     /*
; 9224 :      * Now parse the attributes, it ends up with the ending
; 9225 :      *
; 9226 :      * (S Attribute)* S?
; 9227 :      */
; 9228 :     SKIP_BLANKS;

	push	esi
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _tlen$[ebp]
	sub	ecx, edi
	mov	DWORD PTR [eax], ecx
	call	_xmlSkipBlankChars
	add	esp, 4

; 9229 :     GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN184@xmlParseSt
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN184@xmlParseSt
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN184@xmlParseSt:

; 9230 : 
; 9231 :     while (((RAW != '>') &&
; 9232 : 	   ((RAW != '/') || (NXT(1) != '>')) &&
; 9233 : 	   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {

	mov	edx, DWORD PTR [esi+36]
	mov	edi, DWORD PTR _prefix$[ebp]
	mov	DWORD PTR _prefix$1$[ebp], edi
	mov	eax, DWORD PTR [edx+16]
	cmp	BYTE PTR [eax], 62			; 0000003eH
	je	$LN88@xmlParseSt
	npad	1
$LL2@xmlParseSt:
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR _q$1$[ebp], ecx
	mov	al, BYTE PTR [ecx]
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN39@xmlParseSt
	cmp	BYTE PTR [ecx+1], 62			; 0000003eH
	je	$LN88@xmlParseSt
$LN39@xmlParseSt:
	cmp	al, 9
	jb	SHORT $LN41@xmlParseSt
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN40@xmlParseSt
$LN41@xmlParseSt:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN40@xmlParseSt
	cmp	al, 32					; 00000020H
	jb	$LN88@xmlParseSt
$LN40@xmlParseSt:
	cmp	DWORD PTR [esi+172], -1
	je	$LN88@xmlParseSt

; 9234 : 	const xmlChar *q = CUR_PTR;
; 9235 : 	unsigned int cons = ctxt->input->consumed;

	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _cons$1$[ebp], eax

; 9236 : 	int len = -1, alloc = 0;
; 9237 : 
; 9238 : 	attname = xmlParseAttribute2(ctxt, prefix, localname,

	lea	eax, DWORD PTR _alloc$2[ebp]
	push	eax
	lea	eax, DWORD PTR _len$1[ebp]
	mov	DWORD PTR _len$1[ebp], -1
	push	eax
	lea	eax, DWORD PTR _attvalue$[ebp]
	mov	DWORD PTR _alloc$2[ebp], 0
	push	eax
	lea	eax, DWORD PTR _aprefix$[ebp]
	push	eax
	push	ebx
	push	edi
	push	esi
	call	_xmlParseAttribute2
	mov	ebx, eax
	add	esp, 28					; 0000001cH

; 9239 : 	                             &aprefix, &attvalue, &len, &alloc);
; 9240 :         if ((attname == NULL) || (attvalue == NULL))

	mov	eax, DWORD PTR _attvalue$[ebp]
	mov	DWORD PTR _attname$1$[ebp], ebx
	mov	DWORD PTR _attvalue$1$[ebp], eax
	test	ebx, ebx
	je	$next_attr$307
	test	eax, eax
	je	$LN84@xmlParseSt

; 9241 :             goto next_attr;
; 9242 : 	if (len < 0) len = xmlStrlen(attvalue);

	mov	ebx, DWORD PTR _len$1[ebp]
	mov	DWORD PTR _len$1$[ebp], ebx
	test	ebx, ebx
	jns	SHORT $LN44@xmlParseSt
	push	eax
	call	_xmlStrlen
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _len$1$[ebp], ebx
$LN44@xmlParseSt:

; 9243 : 
; 9244 :         if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {

	mov	eax, DWORD PTR [esi+316]
	mov	edi, DWORD PTR _attname$1$[ebp]
	mov	ecx, DWORD PTR _aprefix$[ebp]
	cmp	edi, eax
	jne	$LN45@xmlParseSt
	test	ecx, ecx
	jne	$LN45@xmlParseSt

; 9245 :             const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len);

	push	ebx
	push	DWORD PTR _attvalue$1$[ebp]
	push	DWORD PTR [esi+296]
	call	_xmlDictLookup
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 9246 :             xmlURIPtr uri;
; 9247 : 
; 9248 :             if (URL == NULL) {

	test	edi, edi
	je	$LN202@xmlParseSt

; 9252 :                 return(NULL);
; 9253 :             }
; 9254 :             if (*URL != 0) {

	cmp	BYTE PTR [edi], 0
	je	$LN55@xmlParseSt

; 9255 :                 uri = xmlParseURI((const char *) URL);

	push	edi
	call	_xmlParseURI
	mov	ebx, eax
	add	esp, 4

; 9256 :                 if (uri == NULL) {

	test	ebx, ebx
	jne	SHORT $LN50@xmlParseSt

; 9257 :                     xmlNsErr(ctxt, XML_WAR_NS_URI,

	push	eax
	push	eax
	push	edi
	push	OFFSET ??_C@_0CA@IPMJMNFH@xmlns?3?5?8?$CFs?8?5is?5not?5a?5valid?5URI?6@
	push	99					; 00000063H
	push	esi
	call	_xmlNsErr
	add	esp, 24					; 00000018H

; 9258 :                              "xmlns: '%s' is not a valid URI\n",
; 9259 :                                        URL, NULL, NULL);
; 9260 :                 } else {

	jmp	SHORT $LN51@xmlParseSt
$LN50@xmlParseSt:

; 9261 :                     if (uri->scheme == NULL) {

	cmp	DWORD PTR [ebx], 0
	jne	SHORT $LN52@xmlParseSt

; 9262 :                         xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,

	push	0
	push	0
	push	edi
	push	OFFSET ??_C@_0BP@JFBGAFGI@xmlns?3?5URI?5?$CFs?5is?5not?5absolute?6@
	push	100					; 00000064H
	push	esi
	call	_xmlNsWarn
	add	esp, 24					; 00000018H
$LN52@xmlParseSt:

; 9263 :                                   "xmlns: URI %s is not absolute\n",
; 9264 :                                   URL, NULL, NULL);
; 9265 :                     }
; 9266 :                     xmlFreeURI(uri);

	push	ebx
	call	_xmlFreeURI
	add	esp, 4
$LN51@xmlParseSt:

; 9267 :                 }
; 9268 :                 if (URL == ctxt->str_xml_ns) {

	cmp	edi, DWORD PTR [esi+320]
	jne	$LN53@xmlParseSt

; 9269 :                     if (attname != ctxt->str_xml) {

	mov	ecx, DWORD PTR _attname$1$[ebp]
	cmp	ecx, DWORD PTR [esi+312]
	je	SHORT $LN288@xmlParseSt

; 9270 :                         xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0DD@IPHAILAA@xml?5namespace?5URI?5cannot?5be?5the@
$LN301@xmlParseSt:

; 9396 :             attvalue = NULL; /* moved into atts */
; 9397 :         }
; 9398 : 
; 9399 : next_attr:
; 9400 :         if ((attvalue != NULL) && (alloc != 0)) {

	push	200					; 000000c8H
	push	esi
	call	_xmlNsErr
	add	esp, 24					; 00000018H
$LN288@xmlParseSt:
	mov	eax, DWORD PTR _attvalue$1$[ebp]
$next_attr$307:
	test	eax, eax
	je	SHORT $LN84@xmlParseSt
	cmp	DWORD PTR _alloc$2[ebp], 0
	je	SHORT $LN84@xmlParseSt

; 9401 :             xmlFree(attvalue);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN299@xmlParseSt:

; 9402 :             attvalue = NULL;
; 9403 :         }
; 9404 : 
; 9405 : 	GROW

	xor	eax, eax
	mov	DWORD PTR _attvalue$[ebp], eax
	mov	DWORD PTR _attvalue$1$[ebp], eax
$LN84@xmlParseSt:
	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN85@xmlParseSt
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN85@xmlParseSt
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN85@xmlParseSt:

; 9406 :         if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	$LN298@xmlParseSt

; 9407 :             break;
; 9408 : 	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	al, BYTE PTR [ecx]
	cmp	al, 62					; 0000003eH
	je	$LN298@xmlParseSt
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN87@xmlParseSt
	cmp	BYTE PTR [ecx+1], 62			; 0000003eH
	je	$LN298@xmlParseSt
$LN87@xmlParseSt:

; 9409 : 	    break;
; 9410 : 	if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	je	$LN205@xmlParseSt

; 9412 : 			   "attributes construct error\n");
; 9413 : 	    break;
; 9414 : 	}
; 9415 :         if ((cons == ctxt->input->consumed) && (q == CUR_PTR) &&
; 9416 :             (attname == NULL) && (attvalue == NULL)) {

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _cons$1$[ebp]
	cmp	eax, DWORD PTR [ecx+36]
	jne	SHORT $LN90@xmlParseSt
	mov	eax, DWORD PTR _q$1$[ebp]
	cmp	eax, DWORD PTR [ecx+16]
	jne	SHORT $LN90@xmlParseSt
	cmp	DWORD PTR _attname$1$[ebp], 0
	jne	SHORT $LN90@xmlParseSt
	cmp	DWORD PTR _attvalue$1$[ebp], 0
	je	$LN206@xmlParseSt
$LN90@xmlParseSt:

; 9418 : 	         "xmlParseStartTag: problem parsing attributes\n");
; 9419 : 	    break;
; 9420 : 	}
; 9421 :         GROW;

	cmp	DWORD PTR [esi+292], 0
	mov	edx, ecx
	jne	SHORT $LN91@xmlParseSt
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [ecx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN91@xmlParseSt
	push	esi
	call	_xmlGROW
	mov	edx, DWORD PTR [esi+36]
	add	esp, 4
$LN91@xmlParseSt:

; 9230 : 
; 9231 :     while (((RAW != '>') &&
; 9232 : 	   ((RAW != '/') || (NXT(1) != '>')) &&
; 9233 : 	   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {

	mov	eax, DWORD PTR [edx+16]
	mov	ebx, DWORD PTR _localname$1$[ebp]
	cmp	BYTE PTR [eax], 62			; 0000003eH
	je	$LN88@xmlParseSt
	mov	edi, DWORD PTR _prefix$1$[ebp]
	jmp	$LL2@xmlParseSt
$LN53@xmlParseSt:

; 9271 :                      "xml namespace URI cannot be the default namespace\n",
; 9272 :                                  NULL, NULL, NULL);
; 9273 :                     }
; 9274 :                     goto next_attr;
; 9275 :                 }
; 9276 :                 if ((len == 29) &&

	cmp	DWORD PTR _len$1$[ebp], 29		; 0000001dH
	jne	SHORT $LN55@xmlParseSt
	push	OFFSET ??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN55@xmlParseSt
$LN300@xmlParseSt:

; 9396 :             attvalue = NULL; /* moved into atts */
; 9397 :         }
; 9398 : 
; 9399 : next_attr:
; 9400 :         if ((attvalue != NULL) && (alloc != 0)) {

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0DA@DPCHHACL@reuse?5of?5the?5xmlns?5namespace?5na@
	jmp	$LN301@xmlParseSt
$LN55@xmlParseSt:

; 9277 :                     (xmlStrEqual(URL,
; 9278 :                              BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
; 9279 :                     xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
; 9280 :                          "reuse of the xmlns namespace name is forbidden\n",
; 9281 :                              NULL, NULL, NULL);
; 9282 :                     goto next_attr;
; 9283 :                 }
; 9284 :             }
; 9285 :             /*
; 9286 :              * check that it's not a defined namespace
; 9287 :              */
; 9288 :             for (j = 1;j <= nbNs;j++)

	mov	ebx, DWORD PTR _nbNs$1$[ebp]
	mov	edx, 1
	cmp	ebx, edx
	jl	SHORT $LN57@xmlParseSt

; 9289 :                 if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL)

	mov	ecx, DWORD PTR [esi+328]
	mov	eax, DWORD PTR [esi+336]
	lea	eax, DWORD PTR [eax+ecx*4]
	add	eax, -8					; fffffff8H
$LL6@xmlParseSt:
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN200@xmlParseSt

; 9277 :                     (xmlStrEqual(URL,
; 9278 :                              BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
; 9279 :                     xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
; 9280 :                          "reuse of the xmlns namespace name is forbidden\n",
; 9281 :                              NULL, NULL, NULL);
; 9282 :                     goto next_attr;
; 9283 :                 }
; 9284 :             }
; 9285 :             /*
; 9286 :              * check that it's not a defined namespace
; 9287 :              */
; 9288 :             for (j = 1;j <= nbNs;j++)

	inc	edx
	sub	eax, 8
	cmp	edx, ebx
	jle	SHORT $LL6@xmlParseSt
$LN57@xmlParseSt:

; 9293 :             else
; 9294 :                 if (nsPush(ctxt, NULL, URL) > 0) nbNs++;

	push	edi
	push	0
	push	esi
	call	_nsPush
	add	esp, 12					; 0000000cH
	test	eax, eax
	mov	eax, DWORD PTR _attvalue$1$[ebp]
	jle	$next_attr$307
	inc	ebx
	mov	DWORD PTR _nbNs$1$[ebp], ebx

; 9295 : 
; 9296 :         } else if (aprefix == ctxt->str_xmlns) {

	jmp	$next_attr$307
$LN200@xmlParseSt:

; 9290 :                     break;
; 9291 :             if (j <= nbNs)

	cmp	edx, ebx
	jg	SHORT $LN57@xmlParseSt

; 9292 :                 xmlErrAttributeDup(ctxt, NULL, attname);

	push	DWORD PTR _attname$1$[ebp]
	push	0
	push	esi
	call	_xmlErrAttributeDup
	add	esp, 12					; 0000000cH
	jmp	$LN288@xmlParseSt
$LN45@xmlParseSt:

; 9295 : 
; 9296 :         } else if (aprefix == ctxt->str_xmlns) {

	cmp	ecx, eax
	jne	$LN60@xmlParseSt

; 9297 :             const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len);

	push	ebx
	push	DWORD PTR _attvalue$1$[ebp]
	push	DWORD PTR [esi+296]
	call	_xmlDictLookup

; 9298 :             xmlURIPtr uri;
; 9299 : 
; 9300 :             if (attname == ctxt->str_xml) {

	mov	ecx, DWORD PTR _attname$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	edi, eax
	mov	eax, DWORD PTR [esi+320]
	cmp	ecx, DWORD PTR [esi+312]
	jne	SHORT $LN62@xmlParseSt

; 9301 :                 if (URL != ctxt->str_xml_ns) {

	cmp	edi, eax
	je	$LN288@xmlParseSt

; 9302 :                     xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CK@HOGKMNCM@xml?5namespace?5prefix?5mapped?5to?5@

; 9303 :                              "xml namespace prefix mapped to wrong URI\n",
; 9304 :                              NULL, NULL, NULL);
; 9305 :                 }
; 9306 :                 /*
; 9307 :                  * Do not keep a namespace definition node
; 9308 :                  */
; 9309 :                 goto next_attr;

	jmp	$LN301@xmlParseSt
$LN62@xmlParseSt:

; 9310 :             }
; 9311 :             if (URL == ctxt->str_xml_ns) {

	cmp	edi, eax
	jne	SHORT $LN64@xmlParseSt

; 9312 :                 if (attname != ctxt->str_xml) {
; 9313 :                     xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CK@HFNNIPGF@xml?5namespace?5URI?5mapped?5to?5wro@

; 9314 :                              "xml namespace URI mapped to wrong prefix\n",
; 9315 :                              NULL, NULL, NULL);
; 9316 :                 }
; 9317 :                 goto next_attr;

	jmp	$LN301@xmlParseSt
$LN64@xmlParseSt:

; 9318 :             }
; 9319 :             if (attname == ctxt->str_xmlns) {

	cmp	ecx, DWORD PTR [esi+316]
	jne	SHORT $LN66@xmlParseSt

; 9320 :                 xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CP@FCHEBDCM@redefinition?5of?5the?5xmlns?5prefi@

; 9321 :                          "redefinition of the xmlns prefix is forbidden\n",
; 9322 :                          NULL, NULL, NULL);
; 9323 :                 goto next_attr;

	jmp	$LN301@xmlParseSt
$LN66@xmlParseSt:

; 9324 :             }
; 9325 :             if ((len == 29) &&

	cmp	ebx, 29					; 0000001dH
	jne	SHORT $LN67@xmlParseSt
	push	OFFSET ??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN300@xmlParseSt
	mov	ecx, DWORD PTR _attname$1$[ebp]
$LN67@xmlParseSt:

; 9326 :                 (xmlStrEqual(URL,
; 9327 :                              BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
; 9328 :                 xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
; 9329 :                          "reuse of the xmlns namespace name is forbidden\n",
; 9330 :                          NULL, NULL, NULL);
; 9331 :                 goto next_attr;
; 9332 :             }
; 9333 :             if ((URL == NULL) || (URL[0] == 0)) {

	test	edi, edi
	je	$LN70@xmlParseSt
	cmp	BYTE PTR [edi], 0
	je	$LN70@xmlParseSt

; 9338 :             } else {
; 9339 :                 uri = xmlParseURI((const char *) URL);

	push	edi
	call	_xmlParseURI
	mov	ebx, eax
	add	esp, 4

; 9340 :                 if (uri == NULL) {

	test	ebx, ebx
	jne	SHORT $LN71@xmlParseSt

; 9341 :                     xmlNsErr(ctxt, XML_WAR_NS_URI,

	mov	ebx, DWORD PTR _attname$1$[ebp]
	push	eax
	push	edi
	push	ebx
	push	OFFSET ??_C@_0CD@IMLPGLBN@xmlns?3?$CFs?3?5?8?$CFs?8?5is?5not?5a?5valid?5U@
	push	99					; 00000063H
	push	esi
	call	_xmlNsErr
	add	esp, 24					; 00000018H

; 9342 :                          "xmlns:%s: '%s' is not a valid URI\n",
; 9343 :                                        attname, URL, NULL);
; 9344 :                 } else {

	jmp	SHORT $LN72@xmlParseSt
$LN71@xmlParseSt:

; 9345 :                     if ((ctxt->pedantic) && (uri->scheme == NULL)) {

	cmp	DWORD PTR [esi+268], 0
	je	SHORT $LN73@xmlParseSt
	cmp	DWORD PTR [ebx], 0
	jne	SHORT $LN73@xmlParseSt

; 9346 :                         xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,

	push	0
	push	edi
	push	DWORD PTR _attname$1$[ebp]
	push	OFFSET ??_C@_0CC@FFFCEDOK@xmlns?3?$CFs?3?5URI?5?$CFs?5is?5not?5absolut@
	push	100					; 00000064H
	push	esi
	call	_xmlNsWarn
	add	esp, 24					; 00000018H
$LN73@xmlParseSt:

; 9347 :                                   "xmlns:%s: URI %s is not absolute\n",
; 9348 :                                   attname, URL, NULL);
; 9349 :                     }
; 9350 :                     xmlFreeURI(uri);

	push	ebx
	call	_xmlFreeURI
	mov	ebx, DWORD PTR _attname$1$[ebp]
	add	esp, 4
$LN72@xmlParseSt:

; 9351 :                 }
; 9352 :             }
; 9353 : 
; 9354 :             /*
; 9355 :              * check that it's not a defined namespace
; 9356 :              */
; 9357 :             for (j = 1;j <= nbNs;j++)

	mov	edx, 1
	cmp	DWORD PTR _nbNs$1$[ebp], edx
	jl	SHORT $LN75@xmlParseSt

; 9358 :                 if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname)

	mov	ecx, DWORD PTR [esi+328]
	mov	eax, DWORD PTR [esi+336]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _nbNs$1$[ebp]
	add	eax, -8					; fffffff8H
	npad	3
$LL9@xmlParseSt:
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN201@xmlParseSt

; 9351 :                 }
; 9352 :             }
; 9353 : 
; 9354 :             /*
; 9355 :              * check that it's not a defined namespace
; 9356 :              */
; 9357 :             for (j = 1;j <= nbNs;j++)

	inc	edx
	sub	eax, 8
	cmp	edx, ecx
	jle	SHORT $LL9@xmlParseSt
$LN75@xmlParseSt:

; 9362 :             else
; 9363 :                 if (nsPush(ctxt, attname, URL) > 0) nbNs++;

	push	edi
	push	ebx
	push	esi
	call	_nsPush
	add	esp, 12					; 0000000cH
	test	eax, eax
	mov	eax, DWORD PTR _attvalue$1$[ebp]
	jle	$next_attr$307
	inc	DWORD PTR _nbNs$1$[ebp]

; 9364 : 
; 9365 :         } else {

	jmp	$next_attr$307
$LN201@xmlParseSt:

; 9359 :                     break;
; 9360 :             if (j <= nbNs)

	cmp	edx, ecx
	jg	SHORT $LN75@xmlParseSt

; 9361 :                 xmlErrAttributeDup(ctxt, aprefix, attname);

	push	ebx
	push	DWORD PTR _aprefix$[ebp]
	push	esi
	call	_xmlErrAttributeDup
	add	esp, 12					; 0000000cH
	jmp	$LN288@xmlParseSt
$LN70@xmlParseSt:

; 9334 :                 xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,

	push	0
	push	0
	push	ecx
	push	OFFSET ??_C@_0CO@JLGJJKB@xmlns?3?$CFs?3?5Empty?5XML?5namespace?5i@

; 9335 :                          "xmlns:%s: Empty XML namespace is not allowed\n",
; 9336 :                               attname, NULL, NULL);
; 9337 :                 goto next_attr;

	jmp	$LN301@xmlParseSt
$LN60@xmlParseSt:

; 9366 :             /*
; 9367 :              * Add the pair to atts
; 9368 :              */
; 9369 :             if ((atts == NULL) || (nbatts + 5 > maxatts)) {

	mov	edx, DWORD PTR _atts$1$[ebp]
	test	edx, edx
	je	SHORT $LN79@xmlParseSt
	mov	eax, DWORD PTR _nbatts$1$[ebp]
	add	eax, 5
	cmp	eax, DWORD PTR _maxatts$1$[ebp]
	jle	SHORT $LN78@xmlParseSt
$LN79@xmlParseSt:

; 9370 :                 if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {

	mov	eax, DWORD PTR _nbatts$1$[ebp]
	add	eax, 5
	push	eax
	push	esi
	call	_xmlCtxtGrowAttrs
	add	esp, 8
	test	eax, eax
	js	$LN288@xmlParseSt

; 9371 :                     goto next_attr;
; 9372 :                 }
; 9373 :                 maxatts = ctxt->maxatts;

	mov	eax, DWORD PTR [esi+304]

; 9374 :                 atts = ctxt->atts;

	mov	edx, DWORD PTR [esi+300]
	mov	DWORD PTR _maxatts$1$[ebp], eax
	mov	DWORD PTR _atts$1$[ebp], edx
$LN78@xmlParseSt:

; 9375 :             }
; 9376 :             ctxt->attallocs[nratts++] = alloc;

	mov	eax, DWORD PTR [esi+340]
	mov	ebx, DWORD PTR _nratts$1$[ebp]
	mov	ecx, DWORD PTR _alloc$2[ebp]
	inc	DWORD PTR _nratts$1$[ebp]
	mov	DWORD PTR [eax+ebx*4], ecx

; 9377 :             atts[nbatts++] = attname;

	mov	eax, DWORD PTR _nbatts$1$[ebp]

; 9378 :             atts[nbatts++] = aprefix;
; 9379 :             /*
; 9380 :              * The namespace URI field is used temporarily to point at the
; 9381 :              * base of the current input buffer for non-alloced attributes.
; 9382 :              * When the input buffer is reallocated, all the pointers become
; 9383 :              * invalid, but they can be reconstructed later.
; 9384 :              */
; 9385 :             if (alloc)

	mov	ebx, DWORD PTR _len$1$[ebp]
	mov	DWORD PTR [edx+eax*4], edi
	mov	edi, DWORD PTR _nbatts$1$[ebp]
	mov	eax, DWORD PTR _aprefix$[ebp]
	mov	DWORD PTR [edx+edi*4+4], eax
	test	ecx, ecx
	je	SHORT $LN81@xmlParseSt

; 9386 :                 atts[nbatts++] = NULL;

	xor	eax, eax
	jmp	SHORT $LN82@xmlParseSt
$LN81@xmlParseSt:

; 9387 :             else
; 9388 :                 atts[nbatts++] = ctxt->input->base;

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+12]
$LN82@xmlParseSt:

; 9389 :             atts[nbatts++] = attvalue;

	mov	DWORD PTR [edx+edi*4+8], eax
	mov	eax, DWORD PTR _attvalue$1$[ebp]
	mov	DWORD PTR [edx+edi*4+12], eax

; 9390 :             attvalue += len;

	add	eax, ebx

; 9391 :             atts[nbatts++] = attvalue;

	mov	DWORD PTR [edx+edi*4+16], eax
	add	edi, 5

; 9392 :             /*
; 9393 :              * tag if some deallocation is needed
; 9394 :              */
; 9395 :             if (alloc != 0) attval = 1;

	mov	eax, DWORD PTR _attval$1$[ebp]
	test	ecx, ecx
	mov	ecx, 1
	mov	DWORD PTR _nbatts$1$[ebp], edi
	cmovne	eax, ecx
	mov	DWORD PTR _attval$1$[ebp], eax

; 9396 :             attvalue = NULL; /* moved into atts */
; 9397 :         }
; 9398 : 
; 9399 : next_attr:
; 9400 :         if ((attvalue != NULL) && (alloc != 0)) {

	jmp	$LN299@xmlParseSt
$LN202@xmlParseSt:

; 9249 :                 xmlErrMemory(ctxt, "dictionary allocation failure");

	push	OFFSET ??_C@_0BO@NHFMDAKF@dictionary?5allocation?5failure@
	push	esi
	call	_xmlErrMemory
	add	esp, 8

; 9250 :                 if ((attvalue != NULL) && (alloc != 0))

	cmp	DWORD PTR _alloc$2[ebp], 0
	je	$LN213@xmlParseSt

; 9251 :                     xmlFree(attvalue);

	push	DWORD PTR _attvalue$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 9600 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN206@xmlParseSt:

; 9417 : 	    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CO@KAECIKGE@xmlParseStartTag?3?5problem?5parsi@
	push	1
	push	esi
	call	_xmlFatalErr
	jmp	SHORT $LN305@xmlParseSt
$LN205@xmlParseSt:

; 9411 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BM@FKPAGOOK@attributes?5construct?5error?6@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
$LN305@xmlParseSt:

; 9422 :     }
; 9423 : 
; 9424 :     if (ctxt->input->id != inputid) {

	add	esp, 12					; 0000000cH
$LN298@xmlParseSt:
	mov	ebx, DWORD PTR _localname$1$[ebp]
$LN88@xmlParseSt:
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR _inputid$1$[ebp]
	cmp	DWORD PTR [eax+56], ecx
	je	SHORT $LN92@xmlParseSt

; 9425 :         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0BM@HDEBIHCG@Unexpected?5change?5of?5input?6@
	push	1
	push	esi
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 9426 :                     "Unexpected change of input\n");
; 9427 :         localname = NULL;

	mov	DWORD PTR _localname$1$[ebp], 0

; 9428 :         goto done;

	jmp	$done$308
$LN92@xmlParseSt:

; 9429 :     }
; 9430 : 
; 9431 :     /* Reconstruct attribute value pointers. */
; 9432 :     for (i = 0, j = 0; j < nratts; i += 5, j++) {

	mov	edx, DWORD PTR _nratts$1$[ebp]
	test	edx, edx
	jle	SHORT $LN11@xmlParseSt
	mov	ecx, DWORD PTR _atts$1$[ebp]
	mov	edi, edx
	add	ecx, 12					; 0000000cH
	npad	1
$LL12@xmlParseSt:

; 9433 :         if (atts[i+2] != NULL) {

	mov	edx, DWORD PTR [ecx-4]
	test	edx, edx
	je	SHORT $LN10@xmlParseSt

; 9434 :             /*
; 9435 :              * Arithmetic on dangling pointers is technically undefined
; 9436 :              * behavior, but well...
; 9437 :              */
; 9438 :             ptrdiff_t offset = ctxt->input->base - atts[i+2];

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, edx

; 9439 :             atts[i+2]  = NULL;    /* Reset repurposed namespace URI */

	mov	DWORD PTR [ecx-4], 0

; 9440 :             atts[i+3] += offset;  /* value */

	add	DWORD PTR [ecx], eax

; 9441 :             atts[i+4] += offset;  /* valuend */

	add	DWORD PTR [ecx+4], eax
$LN10@xmlParseSt:

; 9429 :     }
; 9430 : 
; 9431 :     /* Reconstruct attribute value pointers. */
; 9432 :     for (i = 0, j = 0; j < nratts; i += 5, j++) {

	add	ecx, 20					; 00000014H
	sub	edi, 1
	jne	SHORT $LL12@xmlParseSt
$LN11@xmlParseSt:

; 9442 :         }
; 9443 :     }
; 9444 : 
; 9445 :     /*
; 9446 :      * The attributes defaulting
; 9447 :      */
; 9448 :     if (ctxt->attsDefault != NULL) {

	mov	eax, DWORD PTR [esi+348]
	test	eax, eax
	je	$LN14@xmlParseSt

; 9449 :         xmlDefAttrsPtr defaults;
; 9450 : 
; 9451 : 	defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);

	push	DWORD PTR _prefix$1$[ebp]
	push	ebx
	push	eax
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _defaults$1$[ebp], eax

; 9452 : 	if (defaults != NULL) {

	test	eax, eax
	je	$LN14@xmlParseSt

; 9453 : 	    for (i = 0;i < defaults->nbAttrs;i++) {

	cmp	DWORD PTR [eax], 0
	mov	DWORD PTR _i$1$[ebp], 0
	jle	$LN14@xmlParseSt

; 9465 : 		        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL)

	mov	ecx, DWORD PTR _nbatts$1$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR tv4624[ebp], eax
	mov	DWORD PTR tv4309[ebp], eax
	lea	edx, DWORD PTR [ecx*4]
	mov	DWORD PTR tv4311[ebp], edx
	npad	1
$LL15@xmlParseSt:

; 9454 : 	        attname = defaults->values[5 * i];
; 9455 : 		aprefix = defaults->values[5 * i + 1];

	mov	ebx, DWORD PTR [eax-8]
	mov	edi, DWORD PTR [eax-4]

; 9456 : 
; 9457 :                 /*
; 9458 : 		 * special work for namespaces defaulted defs
; 9459 : 		 */
; 9460 : 		if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {

	mov	eax, DWORD PTR [esi+316]
	cmp	ebx, eax
	jne	$LN96@xmlParseSt
	test	edi, edi
	jne	$LN96@xmlParseSt

; 9461 : 		    /*
; 9462 : 		     * check that it's not a defined namespace
; 9463 : 		     */
; 9464 : 		    for (j = 1;j <= nbNs;j++)

	lea	edx, DWORD PTR [edi+1]
	mov	edi, DWORD PTR _nbNs$1$[ebp]
	cmp	edi, edx
	jl	SHORT $LN272@xmlParseSt

; 9465 : 		        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL)

	mov	ecx, DWORD PTR [esi+328]
	mov	eax, DWORD PTR [esi+336]
	lea	eax, DWORD PTR [eax+ecx*4]
	add	eax, -8					; fffffff8H
$LL18@xmlParseSt:
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN207@xmlParseSt

; 9461 : 		    /*
; 9462 : 		     * check that it's not a defined namespace
; 9463 : 		     */
; 9464 : 		    for (j = 1;j <= nbNs;j++)

	inc	edx
	sub	eax, 8
	cmp	edx, edi
	jle	SHORT $LL18@xmlParseSt

; 9466 : 			    break;
; 9467 : 	            if (j <= nbNs) continue;

	jmp	SHORT $LN272@xmlParseSt
$LN207@xmlParseSt:
	cmp	edx, edi
	jle	$LN294@xmlParseSt
$LN272@xmlParseSt:

; 8668 :     if (prefix == ctxt->str_xml) return(ctxt->str_xml_ns);

	cmp	DWORD PTR [esi+312], 0
	jne	SHORT $LN133@xmlParseSt
	mov	eax, DWORD PTR [esi+320]
	jmp	SHORT $LN129@xmlParseSt
$LN133@xmlParseSt:

; 8669 :     for (i = ctxt->nsNr - 2;i >= 0;i-=2)

	mov	eax, DWORD PTR [esi+328]
	sub	eax, 2
	js	SHORT $LN131@xmlParseSt

; 8670 :         if (ctxt->nsTab[i] == prefix) {

	mov	ecx, DWORD PTR [esi+336]
$LL132@xmlParseSt:
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN208@xmlParseSt

; 8669 :     for (i = ctxt->nsNr - 2;i >= 0;i-=2)

	sub	eax, 2
	jns	SHORT $LL132@xmlParseSt
$LN131@xmlParseSt:

; 8674 : 	}
; 8675 :     return(NULL);

	xor	eax, eax
$LN129@xmlParseSt:

; 9468 : 
; 9469 : 		    nsname = xmlGetNamespace(ctxt, NULL);
; 9470 : 		    if (nsname != defaults->values[5 * i + 2]) {

	mov	ecx, DWORD PTR tv4309[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	eax, ecx
	je	$LN294@xmlParseSt

; 9471 : 			if (nsPush(ctxt, NULL,
; 9472 : 			           defaults->values[5 * i + 2]) > 0)

	push	ecx
	push	0

; 9473 : 			    nbNs++;
; 9474 : 		    }

	jmp	$LN303@xmlParseSt
$LN208@xmlParseSt:

; 8671 : 	    if ((prefix == NULL) && (*ctxt->nsTab[i + 1] == 0))

	mov	eax, DWORD PTR [ecx+eax*4+4]
	xor	ecx, ecx
	cmp	BYTE PTR [eax], cl
	cmove	eax, ecx

; 8673 : 	    return(ctxt->nsTab[i + 1]);

	jmp	SHORT $LN129@xmlParseSt
$LN96@xmlParseSt:

; 9475 : 		} else if (aprefix == ctxt->str_xmlns) {

	cmp	edi, eax
	jne	$LN102@xmlParseSt

; 9476 : 		    /*
; 9477 : 		     * check that it's not a defined namespace
; 9478 : 		     */
; 9479 : 		    for (j = 1;j <= nbNs;j++)

	mov	edi, DWORD PTR _nbNs$1$[ebp]
	mov	edx, 1
	cmp	edi, edx
	jl	SHORT $LN271@xmlParseSt

; 9480 : 		        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname)

	mov	ecx, DWORD PTR [esi+328]
	mov	eax, DWORD PTR [esi+336]
	lea	eax, DWORD PTR [eax+ecx*4]
	add	eax, -8					; fffffff8H
$LL21@xmlParseSt:
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN209@xmlParseSt

; 9476 : 		    /*
; 9477 : 		     * check that it's not a defined namespace
; 9478 : 		     */
; 9479 : 		    for (j = 1;j <= nbNs;j++)

	inc	edx
	sub	eax, 8
	cmp	edx, edi
	jle	SHORT $LL21@xmlParseSt

; 9481 : 			    break;
; 9482 : 	            if (j <= nbNs) continue;

	jmp	SHORT $LN271@xmlParseSt
$LN209@xmlParseSt:
	cmp	edx, edi
	jle	$LN294@xmlParseSt
$LN271@xmlParseSt:

; 8668 :     if (prefix == ctxt->str_xml) return(ctxt->str_xml_ns);

	cmp	ebx, DWORD PTR [esi+312]
	jne	SHORT $LN141@xmlParseSt
	mov	eax, DWORD PTR [esi+320]
	jmp	SHORT $LN137@xmlParseSt
$LN141@xmlParseSt:

; 8669 :     for (i = ctxt->nsNr - 2;i >= 0;i-=2)

	mov	ecx, DWORD PTR [esi+328]
	sub	ecx, 2
	js	SHORT $LN139@xmlParseSt

; 8670 :         if (ctxt->nsTab[i] == prefix) {

	mov	edx, DWORD PTR [esi+336]
	npad	3
$LL140@xmlParseSt:
	cmp	DWORD PTR [edx+ecx*4], ebx
	je	SHORT $LN210@xmlParseSt

; 8669 :     for (i = ctxt->nsNr - 2;i >= 0;i-=2)

	sub	ecx, 2
	jns	SHORT $LL140@xmlParseSt
$LN139@xmlParseSt:

; 9483 : 
; 9484 : 		    nsname = xmlGetNamespace(ctxt, attname);
; 9485 : 		    if (nsname != defaults->values[2]) {

	xor	eax, eax
$LN137@xmlParseSt:
	mov	ecx, DWORD PTR tv4624[ebp]
	cmp	eax, DWORD PTR [ecx]
	je	$LN294@xmlParseSt

; 9486 : 			if (nsPush(ctxt, attname,
; 9487 : 			           defaults->values[5 * i + 2]) > 0)

	mov	ecx, DWORD PTR tv4309[ebp]
	push	DWORD PTR [ecx]
	push	ebx
$LN303@xmlParseSt:

; 9453 : 	    for (i = 0;i < defaults->nbAttrs;i++) {

	push	esi
	call	_nsPush
	mov	edx, DWORD PTR tv4311[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _defaults$1$[ebp]
	test	eax, eax
	jle	$LN13@xmlParseSt
	inc	edi
	mov	DWORD PTR _nbNs$1$[ebp], edi
	jmp	$LN13@xmlParseSt
$LN210@xmlParseSt:

; 8671 : 	    if ((prefix == NULL) && (*ctxt->nsTab[i + 1] == 0))

	test	ebx, ebx
	jne	SHORT $LN275@xmlParseSt
	mov	eax, DWORD PTR [edx+ecx*4+4]
	cmp	BYTE PTR [eax], bl
	je	SHORT $LN139@xmlParseSt
$LN275@xmlParseSt:

; 8673 : 	    return(ctxt->nsTab[i + 1]);

	mov	eax, DWORD PTR [edx+ecx*4+4]
	jmp	SHORT $LN137@xmlParseSt
$LN102@xmlParseSt:

; 9488 : 			    nbNs++;
; 9489 : 		    }
; 9490 : 		} else {
; 9491 : 		    /*
; 9492 : 		     * check that it's not a defined attribute
; 9493 : 		     */
; 9494 : 		    for (j = 0;j < nbatts;j+=5) {

	xor	eax, eax
	cmp	DWORD PTR _nbatts$1$[ebp], eax
	jle	SHORT $LN278@xmlParseSt
$LL24@xmlParseSt:

; 9495 : 			if ((attname == atts[j]) && (aprefix == atts[j+1]))

	mov	ecx, DWORD PTR _atts$1$[ebp]
	cmp	ebx, DWORD PTR [ecx+eax*4]
	jne	SHORT $LN22@xmlParseSt
	cmp	edi, DWORD PTR [ecx+eax*4+4]
	mov	ecx, DWORD PTR _defaults$1$[ebp]
	je	SHORT $LN211@xmlParseSt
$LN22@xmlParseSt:

; 9488 : 			    nbNs++;
; 9489 : 		    }
; 9490 : 		} else {
; 9491 : 		    /*
; 9492 : 		     * check that it's not a defined attribute
; 9493 : 		     */
; 9494 : 		    for (j = 0;j < nbatts;j+=5) {

	add	eax, 5
	cmp	eax, DWORD PTR _nbatts$1$[ebp]
	jl	SHORT $LL24@xmlParseSt
	jmp	SHORT $LN278@xmlParseSt
$LN211@xmlParseSt:

; 9496 : 			    break;
; 9497 : 		    }
; 9498 : 		    if (j < nbatts) continue;

	cmp	eax, DWORD PTR _nbatts$1$[ebp]
	jl	$LN13@xmlParseSt
$LN278@xmlParseSt:

; 9499 : 
; 9500 : 		    if ((atts == NULL) || (nbatts + 5 > maxatts)) {

	cmp	DWORD PTR _atts$1$[ebp], 0
	je	SHORT $LN111@xmlParseSt
	mov	eax, DWORD PTR _nbatts$1$[ebp]
	add	eax, 5
	cmp	eax, DWORD PTR _maxatts$1$[ebp]
	jle	SHORT $LN295@xmlParseSt
$LN111@xmlParseSt:

; 9501 : 			if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {

	mov	eax, DWORD PTR _nbatts$1$[ebp]
	add	eax, 5
	push	eax
	push	esi
	call	_xmlCtxtGrowAttrs
	add	esp, 8
	test	eax, eax
	js	$LN213@xmlParseSt

; 9502 : 			    return(NULL);
; 9503 : 			}
; 9504 : 			maxatts = ctxt->maxatts;

	mov	eax, DWORD PTR [esi+304]
	mov	edx, DWORD PTR tv4311[ebp]
	mov	DWORD PTR _maxatts$1$[ebp], eax

; 9505 : 			atts = ctxt->atts;

	mov	eax, DWORD PTR [esi+300]
	mov	DWORD PTR _atts$1$[ebp], eax
	jmp	SHORT $LN110@xmlParseSt
$LN295@xmlParseSt:

; 9499 : 
; 9500 : 		    if ((atts == NULL) || (nbatts + 5 > maxatts)) {

	mov	eax, DWORD PTR _atts$1$[ebp]
$LN110@xmlParseSt:

; 9506 : 		    }
; 9507 : 		    atts[nbatts++] = attname;

	mov	DWORD PTR [edx+eax], ebx

; 9508 : 		    atts[nbatts++] = aprefix;

	mov	DWORD PTR [edx+eax+4], edi

; 9509 : 		    if (aprefix == NULL)

	test	edi, edi
	je	SHORT $LN147@xmlParseSt

; 8668 :     if (prefix == ctxt->str_xml) return(ctxt->str_xml_ns);

	cmp	edi, DWORD PTR [esi+312]
	jne	SHORT $LN149@xmlParseSt
	mov	eax, DWORD PTR [esi+320]
	jmp	SHORT $LN145@xmlParseSt
$LN149@xmlParseSt:

; 8669 :     for (i = ctxt->nsNr - 2;i >= 0;i-=2)

	mov	eax, DWORD PTR [esi+328]
	sub	eax, 2
	js	SHORT $LN147@xmlParseSt

; 8670 :         if (ctxt->nsTab[i] == prefix) {

	mov	ecx, DWORD PTR [esi+336]
	npad	7
$LL148@xmlParseSt:
	cmp	DWORD PTR [ecx+eax*4], edi
	je	SHORT $LN212@xmlParseSt

; 8669 :     for (i = ctxt->nsNr - 2;i >= 0;i-=2)

	sub	eax, 2
	jns	SHORT $LL148@xmlParseSt
$LN147@xmlParseSt:

; 9510 : 			atts[nbatts++] = NULL;
; 9511 : 		    else
; 9512 : 		        atts[nbatts++] = xmlGetNamespace(ctxt, aprefix);
; 9513 : 		    atts[nbatts++] = defaults->values[5 * i + 2];

	xor	eax, eax
$LN145@xmlParseSt:
	mov	edi, DWORD PTR _atts$1$[ebp]

; 9514 : 		    atts[nbatts++] = defaults->values[5 * i + 3];

	add	DWORD PTR _nbatts$1$[ebp], 5
	mov	DWORD PTR [edx+edi+8], eax
	mov	ecx, DWORD PTR tv4309[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+edi+12], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+edi+16], eax
	add	edx, 20					; 00000014H

; 9515 : 		    if ((ctxt->standalone == 1) &&

	cmp	DWORD PTR [esi+28], 1
	mov	DWORD PTR tv4311[ebp], edx
	jne	SHORT $LN115@xmlParseSt
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN115@xmlParseSt

; 9516 : 		        (defaults->values[5 * i + 4] != NULL)) {
; 9517 : 			xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,

	push	DWORD PTR _localname$1$[ebp]
	push	ebx
	push	OFFSET ??_C@_0DP@KFNFGALP@standalone?3?5attribute?5?$CFs?5on?5?$CFs?5@
	push	538					; 0000021aH
	push	esi
	call	_xmlValidityError
	mov	edx, DWORD PTR tv4311[ebp]
	add	esp, 20					; 00000014H
$LN115@xmlParseSt:

; 9518 : 	  "standalone: attribute %s on %s defaulted from external subset\n",
; 9519 : 	                                 attname, localname);
; 9520 : 		    }
; 9521 : 		    nbdef++;

	inc	DWORD PTR _nbdef$1$[ebp]
	jmp	SHORT $LN302@xmlParseSt
$LN212@xmlParseSt:

; 8673 : 	    return(ctxt->nsTab[i + 1]);

	mov	eax, DWORD PTR [ecx+eax*4+4]
	jmp	SHORT $LN145@xmlParseSt
$LN294@xmlParseSt:

; 9453 : 	    for (i = 0;i < defaults->nbAttrs;i++) {

	mov	edx, DWORD PTR tv4311[ebp]
$LN302@xmlParseSt:
	mov	ecx, DWORD PTR _defaults$1$[ebp]
$LN13@xmlParseSt:
	mov	ebx, DWORD PTR _i$1$[ebp]
	mov	eax, DWORD PTR tv4309[ebp]
	inc	ebx
	add	eax, 20					; 00000014H
	mov	DWORD PTR _i$1$[ebp], ebx
	mov	DWORD PTR tv4309[ebp], eax
	cmp	ebx, DWORD PTR [ecx]
	jl	$LL15@xmlParseSt
$LN14@xmlParseSt:

; 9522 : 		}
; 9523 : 	    }
; 9524 : 	}
; 9525 :     }
; 9526 : 
; 9527 :     /*
; 9528 :      * The attributes checkings
; 9529 :      */
; 9530 :     for (i = 0; i < nbatts;i += 5) {

	cmp	DWORD PTR _nbatts$1$[ebp], 0
	mov	DWORD PTR _i$2$[ebp], 0
	jle	$LN26@xmlParseSt

; 8670 :         if (ctxt->nsTab[i] == prefix) {

	mov	eax, DWORD PTR _atts$1$[ebp]
	lea	ebx, DWORD PTR [eax+4]
$LL27@xmlParseSt:

; 9531 :         /*
; 9532 : 	* The default namespace does not apply to attribute names.
; 9533 : 	*/
; 9534 : 	if (atts[i + 1] != NULL) {

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	$LN116@xmlParseSt

; 8668 :     if (prefix == ctxt->str_xml) return(ctxt->str_xml_ns);

	cmp	ecx, DWORD PTR [esi+312]
	jne	SHORT $LN157@xmlParseSt
	mov	edi, DWORD PTR [esi+320]
	jmp	$LN153@xmlParseSt
$LN157@xmlParseSt:

; 8669 :     for (i = ctxt->nsNr - 2;i >= 0;i-=2)

	mov	eax, DWORD PTR [esi+328]
	sub	eax, 2
	js	SHORT $LN155@xmlParseSt

; 8670 :         if (ctxt->nsTab[i] == prefix) {

	mov	edi, DWORD PTR [esi+336]
$LL156@xmlParseSt:
	cmp	DWORD PTR [edi+eax*4], ecx
	je	SHORT $LN214@xmlParseSt

; 8669 :     for (i = ctxt->nsNr - 2;i >= 0;i-=2)

	sub	eax, 2
	jns	SHORT $LL156@xmlParseSt
$LN155@xmlParseSt:

; 8674 : 	}
; 8675 :     return(NULL);

	xor	edi, edi
$LN273@xmlParseSt:

; 793  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0

; 9537 : 		xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,

	mov	eax, DWORD PTR [ebx-4]

; 793  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	je	SHORT $LN162@xmlParseSt
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN164@xmlParseSt
$LN162@xmlParseSt:

; 794  :         (ctxt->instate == XML_PARSER_EOF))
; 795  : 	return;
; 796  :     if (ctxt != NULL)
; 797  : 	ctxt->errNo = error;
; 798  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,

	mov	edx, DWORD PTR _localname$1$[ebp]
	push	edx
	push	eax
	push	ecx
	push	OFFSET ??_C@_0DB@GMKAHOEK@Namespace?5prefix?5?$CFs?5for?5?$CFs?5on?5?$CF@
	push	0
	push	0
	push	edx
	push	eax
	push	ecx
	push	0
	push	0
	push	2
	push	201					; 000000c9H
	push	3
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 201			; 000000c9H
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH

; 799  :                     XML_ERR_ERROR, NULL, 0, (const char *) info1,
; 800  :                     (const char *) info2, (const char *) info3, 0, 0, msg,
; 801  :                     info1, info2, info3);
; 802  :     if (ctxt != NULL)
; 803  : 	ctxt->nsWellFormed = 0;

	mov	DWORD PTR [esi+356], 0
$LN164@xmlParseSt:

; 9538 : 		    "Namespace prefix %s for %s on %s is not defined\n",
; 9539 : 		    atts[i + 1], atts[i], localname);
; 9540 : 	    }
; 9541 : 	    atts[i + 2] = nsname;
; 9542 : 	} else

	mov	eax, DWORD PTR _atts$1$[ebp]
	mov	DWORD PTR [ebx+4], edi
	jmp	SHORT $LN117@xmlParseSt
$LN214@xmlParseSt:

; 8673 : 	    return(ctxt->nsTab[i + 1]);

	mov	edi, DWORD PTR [edi+eax*4+4]
$LN153@xmlParseSt:

; 9535 : 	    nsname = xmlGetNamespace(ctxt, atts[i + 1]);
; 9536 : 	    if (nsname == NULL) {

	test	edi, edi
	jne	SHORT $LN164@xmlParseSt
	jmp	SHORT $LN273@xmlParseSt
$LN116@xmlParseSt:

; 9543 : 	    nsname = NULL;

	xor	edi, edi
$LN117@xmlParseSt:

; 9544 : 	/*
; 9545 : 	 * [ WFC: Unique Att Spec ]
; 9546 : 	 * No attribute name may appear more than once in the same
; 9547 : 	 * start-tag or empty-element tag.
; 9548 : 	 * As extended by the Namespace in XML REC.
; 9549 : 	 */
; 9550 :         for (j = 0; j < i;j += 5) {

	xor	ecx, ecx
	cmp	DWORD PTR _i$2$[ebp], ecx
	jle	$LN25@xmlParseSt

; 9551 : 	    if (atts[i] == atts[j]) {

	mov	edx, DWORD PTR [ebx-4]
	add	eax, 8
	mov	DWORD PTR _info1$1$[ebp], edx
	npad	5
$LL30@xmlParseSt:
	cmp	edx, DWORD PTR [eax-8]
	jne	SHORT $LN28@xmlParseSt

; 9552 : 	        if (atts[i+1] == atts[j+1]) {

	mov	edx, DWORD PTR [ebx]
	cmp	edx, DWORD PTR [eax-4]
	je	SHORT $LN215@xmlParseSt

; 9554 : 		    break;
; 9555 : 		}
; 9556 : 		if ((nsname != NULL) && (atts[j + 2] == nsname)) {

	test	edi, edi
	je	SHORT $LN281@xmlParseSt
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN216@xmlParseSt
$LN281@xmlParseSt:

; 9544 : 	/*
; 9545 : 	 * [ WFC: Unique Att Spec ]
; 9546 : 	 * No attribute name may appear more than once in the same
; 9547 : 	 * start-tag or empty-element tag.
; 9548 : 	 * As extended by the Namespace in XML REC.
; 9549 : 	 */
; 9550 :         for (j = 0; j < i;j += 5) {

	mov	edx, DWORD PTR _info1$1$[ebp]
$LN28@xmlParseSt:
	add	ecx, 5
	add	eax, 20					; 00000014H
	cmp	ecx, DWORD PTR _i$2$[ebp]
	jl	SHORT $LL30@xmlParseSt
	jmp	SHORT $LN25@xmlParseSt
$LN216@xmlParseSt:

; 793  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN167@xmlParseSt
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN25@xmlParseSt
$LN167@xmlParseSt:

; 794  :         (ctxt->instate == XML_PARSER_EOF))
; 795  : 	return;
; 796  :     if (ctxt != NULL)
; 797  : 	ctxt->errNo = error;
; 798  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,

	mov	eax, DWORD PTR _info1$1$[ebp]
	push	0
	push	edi
	push	eax
	push	OFFSET ??_C@_0CL@BDHHCEFP@Namespaced?5Attribute?5?$CFs?5in?5?8?$CFs?8@
	push	0
	push	0
	push	0
	push	edi
	push	eax
	push	0
	push	0
	push	2
	push	203					; 000000cbH
	push	3
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 203			; 000000cbH
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH

; 799  :                     XML_ERR_ERROR, NULL, 0, (const char *) info1,
; 800  :                     (const char *) info2, (const char *) info3, 0, 0, msg,
; 801  :                     info1, info2, info3);
; 802  :     if (ctxt != NULL)
; 803  : 	ctxt->nsWellFormed = 0;

	mov	DWORD PTR [esi+356], 0
	jmp	SHORT $LN25@xmlParseSt
$LN215@xmlParseSt:

; 9553 : 		    xmlErrAttributeDup(ctxt, atts[i+1], atts[i]);

	mov	eax, DWORD PTR _info1$1$[ebp]
	push	eax
	push	edx
	push	esi
	call	_xmlErrAttributeDup
	add	esp, 12					; 0000000cH
$LN25@xmlParseSt:

; 9522 : 		}
; 9523 : 	    }
; 9524 : 	}
; 9525 :     }
; 9526 : 
; 9527 :     /*
; 9528 :      * The attributes checkings
; 9529 :      */
; 9530 :     for (i = 0; i < nbatts;i += 5) {

	mov	edi, DWORD PTR _i$2$[ebp]
	add	ebx, 20					; 00000014H
	mov	eax, DWORD PTR _atts$1$[ebp]
	add	edi, 5
	mov	DWORD PTR _i$2$[ebp], edi
	cmp	edi, DWORD PTR _nbatts$1$[ebp]
	jl	$LL27@xmlParseSt
$LN26@xmlParseSt:

; 8668 :     if (prefix == ctxt->str_xml) return(ctxt->str_xml_ns);

	mov	ebx, DWORD PTR _prefix$1$[ebp]
	cmp	ebx, DWORD PTR [esi+312]
	jne	SHORT $LN175@xmlParseSt
	mov	edi, DWORD PTR [esi+320]
	jmp	SHORT $LN171@xmlParseSt
$LN175@xmlParseSt:

; 8669 :     for (i = ctxt->nsNr - 2;i >= 0;i-=2)

	mov	ecx, DWORD PTR [esi+328]
	sub	ecx, 2
	js	SHORT $LN173@xmlParseSt

; 8670 :         if (ctxt->nsTab[i] == prefix) {

	mov	edi, DWORD PTR [esi+336]
$LL174@xmlParseSt:
	cmp	DWORD PTR [edi+ecx*4], ebx
	je	$LN217@xmlParseSt

; 8669 :     for (i = ctxt->nsNr - 2;i >= 0;i-=2)

	sub	ecx, 2
	jns	SHORT $LL174@xmlParseSt
$LN173@xmlParseSt:

; 8674 : 	}
; 8675 :     return(NULL);

	xor	edi, edi
$LN171@xmlParseSt:

; 9557 : 		    xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,
; 9558 : 			     "Namespaced Attribute %s in '%s' redefined\n",
; 9559 : 			     atts[i], nsname, NULL);
; 9560 : 		    break;
; 9561 : 		}
; 9562 : 	    }
; 9563 : 	}
; 9564 :     }
; 9565 : 
; 9566 :     nsname = xmlGetNamespace(ctxt, prefix);
; 9567 :     if ((prefix != NULL) && (nsname == NULL)) {

	test	ebx, ebx
	je	SHORT $LN182@xmlParseSt
	test	edi, edi
	jne	SHORT $LN182@xmlParseSt

; 793  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], edi
	je	SHORT $LN180@xmlParseSt
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN182@xmlParseSt
$LN180@xmlParseSt:

; 794  :         (ctxt->instate == XML_PARSER_EOF))
; 795  : 	return;
; 796  :     if (ctxt != NULL)
; 797  : 	ctxt->errNo = error;
; 798  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,

	mov	eax, DWORD PTR _localname$1$[ebp]
	push	0
	push	eax
	push	ebx
	push	OFFSET ??_C@_0CK@EJLCFGPG@Namespace?5prefix?5?$CFs?5on?5?$CFs?5is?5no@
	push	0
	push	0
	push	0
	push	eax
	push	ebx
	push	0
	push	0
	push	2
	push	201					; 000000c9H
	push	3
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 201			; 000000c9H
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH

; 799  :                     XML_ERR_ERROR, NULL, 0, (const char *) info1,
; 800  :                     (const char *) info2, (const char *) info3, 0, 0, msg,
; 801  :                     info1, info2, info3);
; 802  :     if (ctxt != NULL)
; 803  : 	ctxt->nsWellFormed = 0;

	mov	DWORD PTR [esi+356], 0
$LN182@xmlParseSt:

; 9568 : 	xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
; 9569 : 	         "Namespace prefix %s on %s is not defined\n",
; 9570 : 		 prefix, localname, NULL);
; 9571 :     }
; 9572 :     *pref = prefix;

	mov	eax, DWORD PTR _pref$[ebp]
	mov	DWORD PTR [eax], ebx

; 9573 :     *URI = nsname;

	mov	eax, DWORD PTR _URI$[ebp]
	mov	DWORD PTR [eax], edi

; 9574 : 
; 9575 :     /*
; 9576 :      * SAX: Start of Element !
; 9577 :      */
; 9578 :     if ((ctxt->sax != NULL) && (ctxt->sax->startElementNs != NULL) &&

	mov	ebx, DWORD PTR [esi]
	test	ebx, ebx
	je	$done$308
	mov	ebx, DWORD PTR [ebx+116]
	test	ebx, ebx
	je	SHORT $done$308
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $done$308

; 9579 : 	(!ctxt->disableSAX)) {
; 9580 : 	if (nbNs > 0)

	push	DWORD PTR _atts$1$[ebp]
	mov	ecx, DWORD PTR _nbNs$1$[ebp]
	mov	eax, 1717986919				; 66666667H
	imul	DWORD PTR _nbatts$1$[ebp]
	push	DWORD PTR _nbdef$1$[ebp]
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, DWORD PTR [esi+4]
	push	eax
	test	ecx, ecx
	jle	SHORT $LN124@xmlParseSt

; 9581 : 	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix,

	lea	eax, DWORD PTR [ecx+ecx]
	mov	ecx, DWORD PTR [esi+328]
	sub	ecx, eax
	mov	eax, DWORD PTR [esi+336]
	lea	eax, DWORD PTR [eax+ecx*4]
	push	eax
	push	DWORD PTR _nbNs$1$[ebp]
	jmp	SHORT $LN304@xmlParseSt
$LN217@xmlParseSt:

; 8671 : 	    if ((prefix == NULL) && (*ctxt->nsTab[i + 1] == 0))

	test	ebx, ebx
	jne	SHORT $LN276@xmlParseSt
	mov	eax, DWORD PTR [edi+ecx*4+4]
	cmp	BYTE PTR [eax], bl
	jne	SHORT $LN276@xmlParseSt

; 8672 : 	        return(NULL);

	xor	edi, edi
	jmp	SHORT $LN182@xmlParseSt
$LN276@xmlParseSt:

; 8673 : 	    return(ctxt->nsTab[i + 1]);

	mov	edi, DWORD PTR [edi+ecx*4+4]
	jmp	$LN171@xmlParseSt
$LN124@xmlParseSt:

; 9582 : 			  nsname, nbNs, &ctxt->nsTab[ctxt->nsNr - 2 * nbNs],
; 9583 : 			  nbatts / 5, nbdef, atts);
; 9584 : 	else
; 9585 : 	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix,

	push	0
	push	0
$LN304@xmlParseSt:

; 9586 : 	                  nsname, 0, NULL, nbatts / 5, nbdef, atts);
; 9587 :     }
; 9588 : 
; 9589 : done:
; 9590 :     /*
; 9591 :      * Free up attribute allocated strings if needed
; 9592 :      */
; 9593 :     if (attval != 0) {

	push	edi
	push	DWORD PTR _prefix$1$[ebp]
	push	DWORD PTR _localname$1$[ebp]
	push	edx
	call	ebx
	add	esp, 36					; 00000024H
$done$308:
	cmp	DWORD PTR _attval$1$[ebp], 0
	je	SHORT $LN32@xmlParseSt

; 9594 : 	for (i = 3,j = 0; j < nratts;i += 5,j++)

	xor	edi, edi
	cmp	DWORD PTR _nratts$1$[ebp], edi
	jle	SHORT $LN32@xmlParseSt
	mov	ebx, DWORD PTR _atts$1$[ebp]
	add	ebx, 12					; 0000000cH
	npad	2
$LL33@xmlParseSt:

; 9595 : 	    if ((ctxt->attallocs[j] != 0) && (atts[i] != NULL))

	mov	eax, DWORD PTR [esi+340]
	cmp	DWORD PTR [eax+edi*4], 0
	je	SHORT $LN31@xmlParseSt
	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN31@xmlParseSt

; 9596 : 	        xmlFree((xmlChar *) atts[i]);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN31@xmlParseSt:

; 9594 : 	for (i = 3,j = 0; j < nratts;i += 5,j++)

	inc	edi
	add	ebx, 20					; 00000014H
	cmp	edi, DWORD PTR _nratts$1$[ebp]
	jl	SHORT $LL33@xmlParseSt
$LN32@xmlParseSt:

; 9597 :     }
; 9598 : 
; 9599 :     return(localname);

	mov	eax, DWORD PTR _localname$1$[ebp]
	pop	edi

; 9600 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseStartTag2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseAttribute2
_TEXT	SEGMENT
_i$1$ = -4						; size = 4
_name$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_pref$ = 12						; size = 4
_elem$ = 16						; size = 4
_prefix$ = 20						; size = 4
_value$ = 24						; size = 4
_len$ = 28						; size = 4
_alloc$ = 32						; size = 4
_xmlParseAttribute2 PROC				; COMDAT

; 9052 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _value$[ebp]
	xor	edi, edi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edi
	cmp	DWORD PTR [esi+292], edi
	jne	SHORT $LN2@xmlParseAt

; 9053 :     const xmlChar *name;
; 9054 :     xmlChar *val, *internal_val = NULL;
; 9055 :     int normalize = 0;
; 9056 : 
; 9057 :     *value = NULL;
; 9058 :     GROW;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN2@xmlParseAt
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN2@xmlParseAt:

; 9059 :     name = xmlParseQName(ctxt, prefix);

	push	DWORD PTR _prefix$[ebp]
	push	esi
	call	_xmlParseQName
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _name$1$[ebp], ebx

; 9060 :     if (name == NULL) {

	test	ebx, ebx
	jne	SHORT $LN3@xmlParseAt

; 9061 :         xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0BO@BHLKDNI@error?5parsing?5attribute?5name?6@
	push	68					; 00000044H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 9147 :     return (name);
; 9148 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlParseAt:

; 9062 :                        "error parsing attribute name\n");
; 9063 :         return (NULL);
; 9064 :     }
; 9065 : 
; 9066 :     /*
; 9067 :      * get the type if needed
; 9068 :      */
; 9069 :     if (ctxt->attsSpecial != NULL) {

	mov	eax, DWORD PTR [esi+352]
	test	eax, eax
	je	SHORT $LN5@xmlParseAt

; 9070 :         int type;
; 9071 : 
; 9072 :         type = (int) (ptrdiff_t) xmlHashQLookup2(ctxt->attsSpecial,

	mov	ecx, DWORD PTR _prefix$[ebp]
	push	ebx
	push	DWORD PTR [ecx]
	push	DWORD PTR _elem$[ebp]
	push	DWORD PTR _pref$[ebp]
	push	eax
	call	_xmlHashQLookup2
	add	esp, 20					; 00000014H

; 9073 :                                                  pref, elem, *prefix, name);
; 9074 :         if (type != 0)

	mov	ecx, 1
	test	eax, eax
	cmovne	edi, ecx
$LN5@xmlParseAt:

; 9075 :             normalize = 1;
; 9076 :     }
; 9077 : 
; 9078 :     /*
; 9079 :      * read the value
; 9080 :      */
; 9081 :     SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 9082 :     if (RAW == '=') {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 61			; 0000003dH
	jne	$LN6@xmlParseAt

; 9083 :         NEXT;

	push	esi
	call	_xmlNextChar

; 9084 :         SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 9085 :         val = xmlParseAttValueInternal(ctxt, len, alloc, normalize);

	mov	edx, DWORD PTR _len$[ebp]
	push	edi
	push	DWORD PTR _alloc$[ebp]
	push	edx
	push	esi
	call	_xmlParseAttValueInternal
	add	esp, 24					; 00000018H
	mov	ebx, eax

; 9086 : 	if (normalize) {

	test	edi, edi
	je	$LN10@xmlParseAt

; 9087 : 	    /*
; 9088 : 	     * Sometimes a second normalisation pass for spaces is needed
; 9089 : 	     * but that only happens if charrefs or entities refernces
; 9090 : 	     * have been used in the attribute value, i.e. the attribute
; 9091 : 	     * value have been extracted in an allocated string already.
; 9092 : 	     */
; 9093 : 	    if (*alloc) {

	mov	eax, DWORD PTR _alloc$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN10@xmlParseAt

; 1154 :     int remove_head = 0;

	xor	edi, edi

; 1155 :     int need_realloc = 0;
; 1156 :     const xmlChar *cur;
; 1157 : 
; 1158 :     if ((ctxt == NULL) || (src == NULL) || (len == NULL))

	test	ebx, ebx
	je	$LN10@xmlParseAt
	mov	eax, DWORD PTR _len$[ebp]
	test	eax, eax
	je	SHORT $LN10@xmlParseAt

; 1159 :         return(NULL);
; 1160 :     i = *len;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _i$1$[ebp], eax

; 1161 :     if (i <= 0)

	test	eax, eax
	jle	SHORT $LN10@xmlParseAt

; 1162 :         return(NULL);
; 1163 : 
; 1164 :     cur = src;
; 1165 :     while (*cur == 0x20) {

	mov	dl, BYTE PTR [ebx]
	mov	ecx, ebx
	cmp	dl, 32					; 00000020H
	jne	SHORT $LN39@xmlParseAt
$LL22@xmlParseAt:
	mov	dl, BYTE PTR [ecx+1]

; 1166 :         cur++;

	inc	ecx

; 1167 : 	remove_head++;

	inc	edi
	cmp	dl, 32					; 00000020H
	je	SHORT $LL22@xmlParseAt
$LN39@xmlParseAt:

; 1168 :     }
; 1169 :     while (*cur != 0) {

	test	dl, dl
	je	SHORT $LN47@xmlParseAt
$LL24@xmlParseAt:

; 1170 : 	if (*cur == 0x20) {

	mov	al, BYTE PTR [ecx+1]
	lea	ecx, DWORD PTR [ecx+1]
	cmp	dl, 32					; 00000020H
	jne	SHORT $LN29@xmlParseAt

; 1171 : 	    cur++;
; 1172 : 	    if ((*cur == 0x20) || (*cur == 0)) {

	cmp	al, dl
	je	$LN40@xmlParseAt
	test	al, al
	je	$LN40@xmlParseAt
$LN29@xmlParseAt:

; 1168 :     }
; 1169 :     while (*cur != 0) {

	mov	dl, al
	test	al, al
	jne	SHORT $LL24@xmlParseAt
	mov	eax, DWORD PTR _i$1$[ebp]
$LN47@xmlParseAt:

; 1190 :     } else if (remove_head) {

	test	edi, edi
	je	SHORT $LN10@xmlParseAt

; 1191 :         *len -= remove_head;

	mov	edx, DWORD PTR _len$[ebp]
	sub	eax, edi
	mov	DWORD PTR [edx], eax

; 1192 :         memmove(src, src + remove_head, 1 + *len);

	inc	eax
	push	eax
	lea	eax, DWORD PTR [edi+ebx]
	push	eax
	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH

; 1193 : 	return(src);

	mov	edi, ebx
$LN21@xmlParseAt:

; 9094 : 	        const xmlChar *val2;
; 9095 : 
; 9096 : 	        val2 = xmlAttrNormalizeSpace2(ctxt, val, len);
; 9097 : 		if ((val2 != NULL) && (val2 != val)) {

	test	edi, edi
	je	SHORT $LN10@xmlParseAt
	cmp	edi, ebx
	je	SHORT $LN10@xmlParseAt

; 9098 : 		    xmlFree(val);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 9099 : 		    val = (xmlChar *) val2;

	mov	ebx, edi
$LN10@xmlParseAt:

; 9106 :                           "Specification mandates value for attribute %s\n",
; 9107 :                           name);
; 9108 :         return (NULL);
; 9109 :     }
; 9110 : 
; 9111 :     if (*prefix == ctxt->str_xml) {

	mov	eax, DWORD PTR _prefix$[ebp]
	mov	DWORD PTR [esi+172], 7
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [esi+312]
	jne	$LN19@xmlParseAt

; 9112 :         /*
; 9113 :          * Check that xml:lang conforms to the specification
; 9114 :          * No more registered as an error, just generate a warning now
; 9115 :          * since this was deprecated in XML second edition
; 9116 :          */
; 9117 :         if ((ctxt->pedantic) && (xmlStrEqual(name, BAD_CAST "lang"))) {

	cmp	DWORD PTR [esi+268], 0
	je	$LN50@xmlParseAt
	push	OFFSET ??_C@_04IOHABJIC@lang@
	push	DWORD PTR _name$1$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN50@xmlParseAt

; 9118 :             internal_val = xmlStrndup(val, *len);

	mov	eax, DWORD PTR _len$[ebp]
	push	DWORD PTR [eax]
	push	ebx
	call	_xmlStrndup
	mov	edi, eax

; 9119 :             if (!xmlCheckLanguageID(internal_val)) {

	push	edi
	call	_xmlCheckLanguageID
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN13@xmlParseAt

; 9120 :                 xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,

	push	eax
	push	edi
	push	OFFSET ??_C@_0CD@OAOAJGL@Malformed?5value?5for?5xml?3lang?5?3?5@
	push	98					; 00000062H
	push	esi
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H
	jmp	SHORT $LN13@xmlParseAt
$LN40@xmlParseAt:

; 1182 : 	ret = xmlStrndup(src + remove_head, i - remove_head + 1);

	mov	eax, DWORD PTR _i$1$[ebp]
	sub	eax, edi
	inc	eax
	push	eax
	lea	eax, DWORD PTR [edi+ebx]
	push	eax
	call	_xmlStrndup
	mov	edi, eax
	add	esp, 8

; 1183 : 	if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN35@xmlParseAt

; 1184 : 	    xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory
	add	esp, 8

; 1185 : 	    return(NULL);

	jmp	$LN10@xmlParseAt
$LN35@xmlParseAt:

; 1186 : 	}
; 1187 : 	xmlAttrNormalizeSpace(ret, ret);

	push	edi
	push	edi
	call	_xmlAttrNormalizeSpace

; 1188 : 	*len = (int) strlen((const char *)ret);

	mov	ecx, edi
	add	esp, 8
	lea	edx, DWORD PTR [ecx+1]
	npad	7
$LL48@xmlParseAt:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL48@xmlParseAt
	sub	ecx, edx
	mov	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [edx], ecx

; 1189 :         return(ret);

	jmp	$LN21@xmlParseAt
$LN50@xmlParseAt:

; 9121 :                               "Malformed value for xml:lang : %s\n",
; 9122 :                               internal_val, NULL);
; 9123 :             }
; 9124 :         }
; 9125 : 
; 9126 :         /*
; 9127 :          * Check that xml:space conforms to the specification
; 9128 :          */
; 9129 :         if (xmlStrEqual(name, BAD_CAST "space")) {

	xor	edi, edi
$LN13@xmlParseAt:
	push	OFFSET ??_C@_05OLNILLAB@space@
	push	DWORD PTR _name$1$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlParseAt

; 9130 :             internal_val = xmlStrndup(val, *len);

	mov	eax, DWORD PTR _len$[ebp]
	push	DWORD PTR [eax]
	push	ebx
	call	_xmlStrndup
	mov	edi, eax

; 9131 :             if (xmlStrEqual(internal_val, BAD_CAST "default"))

	push	OFFSET ??_C@_07DLHCIBDH@default@
	push	edi
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN15@xmlParseAt

; 9132 :                 *(ctxt->space) = 0;

	mov	eax, DWORD PTR [esi+232]
	mov	DWORD PTR [eax], 0
	jmp	SHORT $LN18@xmlParseAt
$LN15@xmlParseAt:

; 9133 :             else if (xmlStrEqual(internal_val, BAD_CAST "preserve"))

	push	OFFSET ??_C@_08ILAKLJGO@preserve@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlParseAt

; 9134 :                 *(ctxt->space) = 1;

	mov	eax, DWORD PTR [esi+232]
	mov	DWORD PTR [eax], 1
	jmp	SHORT $LN18@xmlParseAt
$LN17@xmlParseAt:

; 9135 :             else {
; 9136 :                 xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,

	push	0
	push	edi
	push	OFFSET ??_C@_0EF@GNALPKCP@Invalid?5value?5?$CC?$CFs?$CC?5for?5xml?3spac@
	push	102					; 00000066H
	push	esi
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H
$LN18@xmlParseAt:

; 9137 :                               "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n",
; 9138 :                               internal_val, NULL);
; 9139 :             }
; 9140 :         }
; 9141 :         if (internal_val) {

	test	edi, edi
	je	SHORT $LN19@xmlParseAt

; 9142 :             xmlFree(internal_val);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN19@xmlParseAt:

; 9143 :         }
; 9144 :     }
; 9145 : 
; 9146 :     *value = val;

	mov	eax, DWORD PTR _value$[ebp]
	pop	edi

; 9147 :     return (name);
; 9148 : }

	pop	esi
	mov	DWORD PTR [eax], ebx
	mov	eax, DWORD PTR _name$1$[ebp]
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlParseAt:

; 9100 : 		}
; 9101 : 	    }
; 9102 : 	}
; 9103 :         ctxt->instate = XML_PARSER_CONTENT;
; 9104 :     } else {
; 9105 :         xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,

	push	ebx
	push	OFFSET ??_C@_0CP@LHHGCLP@Specification?5mandates?5value?5fo@
	push	41					; 00000029H
	push	esi
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 9147 :     return (name);
; 9148 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseAttribute2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseQNameAndCompare
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
tv314 = 16						; size = 4
_prefix2$ = 16						; size = 4
_prefix$ = 16						; size = 4
_xmlParseQNameAndCompare PROC				; COMDAT

; 8773 :                         xmlChar const *prefix) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _prefix$[ebp]
	test	edi, edi
	jne	SHORT $LN6@xmlParseQN

; 8774 :     const xmlChar *cmp;
; 8775 :     const xmlChar *in;
; 8776 :     const xmlChar *ret;
; 8777 :     const xmlChar *prefix2;
; 8778 : 
; 8779 :     if (prefix == NULL) return(xmlParseNameAndCompare(ctxt, name));

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlParseNameAndCompare
	add	esp, 8
	pop	edi

; 8808 :     return ret;
; 8809 : }

	pop	ebp
	ret	0
$LN6@xmlParseQN:
	push	esi

; 8780 : 
; 8781 :     GROW;

	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN7@xmlParseQN
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN7@xmlParseQN
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN7@xmlParseQN:

; 8782 :     in = ctxt->input->cur;

	mov	eax, DWORD PTR [esi+36]

; 8783 : 
; 8784 :     cmp = prefix;

	mov	ecx, edi
	mov	eax, DWORD PTR [eax+16]

; 8785 :     while (*in != 0 && *in == *cmp) {

	mov	dl, BYTE PTR [eax]
	test	dl, dl
	je	SHORT $LN23@xmlParseQN
	npad	5
$LL2@xmlParseQN:
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN23@xmlParseQN
	mov	dl, BYTE PTR [eax+1]

; 8786 : 	++in;

	inc	eax

; 8787 : 	++cmp;

	inc	ecx
	test	dl, dl
	jne	SHORT $LL2@xmlParseQN
$LN23@xmlParseQN:

; 8788 :     }
; 8789 :     if ((*cmp == 0) && (*in == ':')) {

	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN9@xmlParseQN
	cmp	BYTE PTR [eax], 58			; 0000003aH
	jne	SHORT $LN9@xmlParseQN

; 8790 :         in++;
; 8791 : 	cmp = name;
; 8792 : 	while (*in != 0 && *in == *cmp) {

	mov	dl, BYTE PTR [eax+1]
	inc	eax
	mov	ecx, DWORD PTR _name$[ebp]
	test	dl, dl
	je	SHORT $LN24@xmlParseQN
$LL4@xmlParseQN:
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN24@xmlParseQN
	mov	dl, BYTE PTR [eax+1]

; 8793 : 	    ++in;

	inc	eax

; 8794 : 	    ++cmp;

	inc	ecx
	test	dl, dl
	jne	SHORT $LL4@xmlParseQN
$LN24@xmlParseQN:

; 8795 : 	}
; 8796 : 	if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {

	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN9@xmlParseQN
	mov	cl, BYTE PTR [eax]
	cmp	cl, 62					; 0000003eH
	je	SHORT $LN11@xmlParseQN
	cmp	cl, 32					; 00000020H
	je	SHORT $LN11@xmlParseQN
	cmp	cl, 9
	jb	SHORT $LN12@xmlParseQN
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN11@xmlParseQN
$LN12@xmlParseQN:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN9@xmlParseQN
$LN11@xmlParseQN:

; 8797 : 	    /* success */
; 8798 : 	    ctxt->input->cur = in;

	mov	ecx, DWORD PTR [esi+36]
	pop	esi
	pop	edi
	mov	DWORD PTR [ecx+16], eax

; 8807 : 	return((const xmlChar*) 1);

	mov	eax, 1

; 8808 :     return ret;
; 8809 : }

	pop	ebp
	ret	0
$LN9@xmlParseQN:

; 8799 : 	    return((const xmlChar*) 1);
; 8800 : 	}
; 8801 :     }
; 8802 :     /*
; 8803 :      * all strings coms from the dictionary, equality can be done directly
; 8804 :      */
; 8805 :     ret = xmlParseQName (ctxt, &prefix2);

	lea	eax, DWORD PTR _prefix2$[ebp]
	push	eax
	push	esi
	call	_xmlParseQName
	add	esp, 8

; 8806 :     if ((ret == name) && (prefix == prefix2))

	cmp	eax, DWORD PTR _name$[ebp]
	jne	SHORT $LN25@xmlParseQN
	cmp	edi, DWORD PTR _prefix2$[ebp]
	jne	SHORT $LN25@xmlParseQN

; 8807 : 	return((const xmlChar*) 1);

	mov	eax, 1
$LN25@xmlParseQN:
	pop	esi
	pop	edi

; 8808 :     return ret;
; 8809 : }

	pop	ebp
	ret	0
_xmlParseQNameAndCompare ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseQName
_TEXT	SEGMENT
$T1 = 8							; size = 4
_l$2$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_prefix$ = 12						; size = 4
_xmlParseQName PROC					; COMDAT

; 8693 : xmlParseQName(xmlParserCtxtPtr ctxt, const xmlChar **prefix) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN2@xmlParseQN

; 8694 :     const xmlChar *l, *p;
; 8695 : 
; 8696 :     GROW;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN2@xmlParseQN
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN2@xmlParseQN:

; 8697 : 
; 8698 :     l = xmlParseNCName(ctxt);

	push	esi
	call	_xmlParseNCName
	mov	ecx, DWORD PTR [esi+36]
	mov	edi, eax
	add	esp, 4
	mov	eax, DWORD PTR [ecx+16]

; 8699 :     if (l == NULL) {

	test	edi, edi
	jne	SHORT $LN3@xmlParseQN

; 8700 :         if (CUR == ':') {

	cmp	BYTE PTR [eax], 58			; 0000003aH
	jne	SHORT $LN5@xmlParseQN

; 8701 : 	    l = xmlParseName(ctxt);

	push	esi
	call	_xmlParseName
	mov	edi, eax
	add	esp, 4

; 8702 : 	    if (l != NULL) {

	test	edi, edi
	je	SHORT $LN5@xmlParseQN

; 8703 : 	        xmlNsErr(ctxt, XML_NS_ERR_QNAME,

	push	0
	push	0
	push	edi
	push	OFFSET ??_C@_0BM@DBJGDKCH@Failed?5to?5parse?5QName?5?8?$CFs?8?6@
	push	202					; 000000caH
	push	esi
	call	_xmlNsErr

; 8704 : 		         "Failed to parse QName '%s'\n", l, NULL, NULL);
; 8705 : 		*prefix = NULL;

	mov	eax, DWORD PTR _prefix$[ebp]
	add	esp, 24					; 00000018H
	mov	DWORD PTR [eax], 0

; 8706 : 		return(l);

	mov	eax, edi
	pop	edi

; 8756 : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlParseQN:
	pop	edi

; 8707 : 	    }
; 8708 : 	}
; 8709 :         return(NULL);

	xor	eax, eax

; 8756 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlParseQN:

; 8710 :     }
; 8711 :     if (CUR == ':') {

	cmp	BYTE PTR [eax], 58			; 0000003aH
	push	ebx
	jne	$LN6@xmlParseQN

; 8712 :         NEXT;

	push	esi
	call	_xmlNextChar

; 8713 : 	p = l;
; 8714 : 	l = xmlParseNCName(ctxt);

	push	esi
	mov	ebx, edi
	mov	DWORD PTR $T1[ebp], edi
	call	_xmlParseNCName
	mov	edi, eax
	add	esp, 8

; 8715 : 	if (l == NULL) {

	test	edi, edi
	jne	SHORT $LN8@xmlParseQN

; 8716 : 	    xmlChar *tmp;
; 8717 : 
; 8718 :             xmlNsErr(ctxt, XML_NS_ERR_QNAME,

	push	eax
	push	eax
	push	ebx
	push	OFFSET ??_C@_0BN@MNDCJBCK@Failed?5to?5parse?5QName?5?8?$CFs?3?8?6@
	push	202					; 000000caH
	push	esi
	call	_xmlNsErr

; 8719 : 	             "Failed to parse QName '%s:'\n", p, NULL, NULL);
; 8720 : 	    l = xmlParseNmtoken(ctxt);

	push	esi
	call	_xmlParseNmtoken
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _l$2$[ebp], eax

; 8721 : 	    if (l == NULL)

	push	edi
	push	edi
	push	ebx
	test	eax, eax
	jne	SHORT $LN9@xmlParseQN

; 8722 : 		tmp = xmlBuildQName(BAD_CAST "", p, NULL, 0);

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlBuildQName
	add	esp, 16					; 00000010H
	mov	edi, eax
	jmp	SHORT $LN10@xmlParseQN
$LN9@xmlParseQN:

; 8723 : 	    else {
; 8724 : 		tmp = xmlBuildQName(l, p, NULL, 0);

	push	eax
	call	_xmlBuildQName

; 8725 : 		xmlFree((char *)l);

	push	DWORD PTR _l$2$[ebp]
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H
$LN10@xmlParseQN:

; 8726 : 	    }
; 8727 : 	    p = xmlDictLookup(ctxt->dict, tmp, -1);

	push	-1
	push	edi
	push	DWORD PTR [esi+296]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 8728 : 	    if (tmp != NULL) xmlFree(tmp);

	test	edi, edi
	je	SHORT $LN11@xmlParseQN
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlParseQN:

; 8729 : 	    *prefix = NULL;

	mov	ecx, DWORD PTR _prefix$[ebp]

; 8750 : 	    return(l);

	mov	eax, esi
	pop	ebx
	pop	edi

; 8756 : }

	pop	esi
	mov	DWORD PTR [ecx], 0
	pop	ebp
	ret	0
$LN8@xmlParseQN:

; 8730 : 	    return(p);
; 8731 : 	}
; 8732 : 	if (CUR == ':') {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 58			; 0000003aH
	jne	SHORT $LN7@xmlParseQN

; 8733 : 	    xmlChar *tmp;
; 8734 : 
; 8735 :             xmlNsErr(ctxt, XML_NS_ERR_QNAME,

	push	0
	push	edi
	push	ebx
	push	OFFSET ??_C@_0CA@HECGKKLP@Failed?5to?5parse?5QName?5?8?$CFs?3?$CFs?3?8?6@
	push	202					; 000000caH
	push	esi
	call	_xmlNsErr

; 8736 : 	             "Failed to parse QName '%s:%s:'\n", p, l, NULL);
; 8737 : 	    NEXT;

	push	esi
	call	_xmlNextChar

; 8738 : 	    tmp = (xmlChar *) xmlParseName(ctxt);

	push	esi
	call	_xmlParseName
	add	esp, 32					; 00000020H

; 8739 : 	    if (tmp != NULL) {

	push	0
	push	0
	push	edi
	test	eax, eax
	je	SHORT $LN13@xmlParseQN

; 8740 : 	        tmp = xmlBuildQName(tmp, l, NULL, 0);

	push	eax

; 8741 : 		l = xmlDictLookup(ctxt->dict, tmp, -1);
; 8742 : 		if (tmp != NULL) xmlFree(tmp);
; 8743 : 		*prefix = p;
; 8744 : 		return(l);

	jmp	SHORT $LN18@xmlParseQN
$LN13@xmlParseQN:

; 8745 : 	    }
; 8746 : 	    tmp = xmlBuildQName(BAD_CAST "", l, NULL, 0);

	push	OFFSET ??_C@_00CNPNBAHC@@
$LN18@xmlParseQN:
	call	_xmlBuildQName
	mov	edi, eax

; 8747 : 	    l = xmlDictLookup(ctxt->dict, tmp, -1);

	push	-1
	push	edi
	push	DWORD PTR [esi+296]
	call	_xmlDictLookup
	add	esp, 28					; 0000001cH
	mov	esi, eax

; 8748 : 	    if (tmp != NULL) xmlFree(tmp);

	test	edi, edi
	je	SHORT $LN15@xmlParseQN
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlParseQN:

; 8749 : 	    *prefix = p;

	mov	ecx, DWORD PTR _prefix$[ebp]

; 8750 : 	    return(l);

	mov	eax, esi
	mov	DWORD PTR [ecx], ebx
	pop	ebx
	pop	edi

; 8756 : }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlParseQN:

; 8751 : 	}
; 8752 : 	*prefix = p;
; 8753 :     } else
; 8754 :         *prefix = NULL;

	mov	DWORD PTR $T1[ebp], 0
$LN7@xmlParseQN:

; 8755 :     return(l);

	mov	eax, DWORD PTR _prefix$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	pop	ebx
	mov	DWORD PTR [eax], ecx
	mov	eax, edi
	pop	edi

; 8756 : }

	pop	esi
	pop	ebp
	ret	0
_xmlParseQName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlGetNamespace
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_prefix$ = 12						; size = 4
_xmlGetNamespace PROC					; COMDAT

; 8665 : xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _prefix$[ebp]
	cmp	ecx, DWORD PTR [edx+312]
	jne	SHORT $LN5@xmlGetName

; 8666 :     int i;
; 8667 : 
; 8668 :     if (prefix == ctxt->str_xml) return(ctxt->str_xml_ns);

	mov	eax, DWORD PTR [edx+320]

; 8676 : }

	pop	ebp
	ret	0
$LN5@xmlGetName:

; 8669 :     for (i = ctxt->nsNr - 2;i >= 0;i-=2)

	mov	eax, DWORD PTR [edx+328]
	sub	eax, 2
	js	SHORT $LN3@xmlGetName

; 8670 :         if (ctxt->nsTab[i] == prefix) {

	mov	edx, DWORD PTR [edx+336]
$LL4@xmlGetName:
	cmp	DWORD PTR [edx+eax*4], ecx
	je	SHORT $LN10@xmlGetName

; 8669 :     for (i = ctxt->nsNr - 2;i >= 0;i-=2)

	sub	eax, 2
	jns	SHORT $LL4@xmlGetName
$LN3@xmlGetName:

; 8674 : 	}
; 8675 :     return(NULL);

	xor	eax, eax

; 8676 : }

	pop	ebp
	ret	0
$LN10@xmlGetName:

; 8671 : 	    if ((prefix == NULL) && (*ctxt->nsTab[i + 1] == 0))

	test	ecx, ecx
	jne	SHORT $LN15@xmlGetName
	mov	ecx, DWORD PTR [edx+eax*4+4]
	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN3@xmlGetName
$LN15@xmlGetName:

; 8672 : 	        return(NULL);
; 8673 : 	    return(ctxt->nsTab[i + 1]);

	mov	eax, DWORD PTR [edx+eax*4+4]

; 8676 : }

	pop	ebp
	ret	0
_xmlGetNamespace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEndTag1
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_line$ = 12						; size = 4
_xmlParseEndTag1 PROC					; COMDAT

; 8581 : xmlParseEndTag1(xmlParserCtxtPtr ctxt, int line) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN5@xmlParseEn

; 8582 :     const xmlChar *name;
; 8583 : 
; 8584 :     GROW;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN5@xmlParseEn
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN5@xmlParseEn:

; 8585 :     if ((RAW != '<') || (NXT(1) != '/')) {

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	cmp	BYTE PTR [ecx], 60			; 0000003cH
	jne	$LN7@xmlParseEn
	cmp	BYTE PTR [ecx+1], 47			; 0000002fH
	jne	$LN7@xmlParseEn

; 8587 : 		       "xmlParseEndTag: '</' not found\n");
; 8588 : 	return;
; 8589 :     }
; 8590 :     SKIP(2);

	add	DWORD PTR [esi+200], 2
	add	DWORD PTR [eax+16], 2
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 2
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseEn
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseEn:

; 8591 : 
; 8592 :     name = xmlParseNameAndCompare(ctxt,ctxt->name);

	push	edi
	push	DWORD PTR [esi+184]
	push	esi
	call	_xmlParseNameAndCompare
	add	esp, 8
	mov	edi, eax

; 8593 : 
; 8594 :     /*
; 8595 :      * We should definitely be at the ending "S? '>'" part
; 8596 :      */
; 8597 :     GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN9@xmlParseEn
	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN9@xmlParseEn
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN9@xmlParseEn:

; 8598 :     SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 8599 :     if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [ecx+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 9
	jb	SHORT $LN14@xmlParseEn
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN13@xmlParseEn
$LN14@xmlParseEn:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN13@xmlParseEn
	cmp	al, 32					; 00000020H
	jb	SHORT $LN12@xmlParseEn
$LN13@xmlParseEn:
	cmp	al, 62					; 0000003eH
	je	SHORT $LN10@xmlParseEn
$LN12@xmlParseEn:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN23@xmlParseEn
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN15@xmlParseEn
$LN23@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0N@HPGHEIE@expected?5?8?$DO?8@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	73					; 00000049H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 73			; 00000049H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN15@xmlParseEn

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1

; 8600 : 	xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
; 8601 :     } else

	jmp	SHORT $LN15@xmlParseEn
$LN10@xmlParseEn:

; 8602 : 	NEXT1;

	inc	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [esi+36]
	inc	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [esi+36]
	inc	DWORD PTR [esi+200]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN15@xmlParseEn
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN15@xmlParseEn:

; 8603 : 
; 8604 :     /*
; 8605 :      * [ WFC: Element Type Match ]
; 8606 :      * The Name in an element's end-tag must match the element type in the
; 8607 :      * start-tag.
; 8608 :      *
; 8609 :      */
; 8610 :     if (name != (xmlChar*)1) {

	cmp	edi, 1
	je	SHORT $LN16@xmlParseEn

; 8611 :         if (name == NULL) name = BAD_CAST "unparseable";

	test	edi, edi
	mov	eax, OFFSET ??_C@_0M@IAMGGMFE@unparseable@
	cmovne	eax, edi

; 8612 :         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,

	push	eax
	push	DWORD PTR _line$[ebp]
	push	DWORD PTR [esi+184]
	push	OFFSET ??_C@_0DE@OCMDIBAP@Opening?5and?5ending?5tag?5mismatch@
	push	76					; 0000004cH
	push	esi
	call	_xmlFatalErrMsgStrIntStr
	add	esp, 24					; 00000018H
$LN16@xmlParseEn:

; 8613 : 		     "Opening and ending tag mismatch: %s line %d and %s\n",
; 8614 : 		                ctxt->name, line, name);
; 8615 :     }
; 8616 : 
; 8617 :     /*
; 8618 :      * SAX: End of Tag
; 8619 :      */
; 8620 :     if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL) &&

	mov	eax, DWORD PTR [esi]
	pop	edi
	test	eax, eax
	je	SHORT $LN18@xmlParseEn
	mov	eax, DWORD PTR [eax+60]
	test	eax, eax
	je	SHORT $LN18@xmlParseEn
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN18@xmlParseEn

; 8621 : 	(!ctxt->disableSAX))
; 8622 :         ctxt->sax->endElement(ctxt->userData, ctxt->name);

	push	DWORD PTR [esi+184]
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 8
$LN18@xmlParseEn:

; 8623 : 
; 8624 :     namePop(ctxt);

	push	esi
	call	_namePop

; 8625 :     spacePop(ctxt);

	push	esi
	call	_spacePop
	add	esp, 8
	pop	esi

; 8626 :     return;
; 8627 : }

	pop	ebp
	ret	0
$LN7@xmlParseEn:

; 8586 : 	xmlFatalErrMsg(ctxt, XML_ERR_LTSLASH_REQUIRED,

	push	OFFSET ??_C@_0CA@PJGJPBIH@xmlParseEndTag?3?5?8?$DM?1?8?5not?5found?6@
	push	74					; 0000004aH
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
	pop	esi

; 8626 :     return;
; 8627 : }

	pop	ebp
	ret	0
_xmlParseEndTag1 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseInternalSubset
_TEXT	SEGMENT
_cons$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseInternalSubset PROC				; COMDAT

; 8268 : xmlParseInternalSubset(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 91			; 0000005bH
	jne	$LN9@xmlParseIn

; 8269 :     /*
; 8270 :      * Is there any DTD definition ?
; 8271 :      */
; 8272 :     if (RAW == '[') {
; 8273 :         int baseInputNr = ctxt->inputNr;

	push	ebx
	mov	ebx, DWORD PTR [esi+40]
	push	edi

; 8274 :         ctxt->instate = XML_PARSER_DTD;
; 8275 :         NEXT;

	push	esi
	mov	DWORD PTR [esi+172], 3
	call	_xmlNextChar
$LN85@xmlParseIn:

; 8276 : 	/*
; 8277 : 	 * Parse the succession of Markup declarations and
; 8278 : 	 * PEReferences.
; 8279 : 	 * Subsequence (markupdecl | PEReference | S)*
; 8280 : 	 */
; 8281 : 	while (((RAW != ']') || (ctxt->inputNr > baseInputNr)) &&

	add	esp, 4
	npad	8
$LL2@xmlParseIn:
	mov	eax, DWORD PTR [esi+36]
	mov	edi, DWORD PTR [eax+16]
	cmp	BYTE PTR [edi], 93			; 0000005dH
	jne	SHORT $LN84@xmlParseIn
	cmp	DWORD PTR [esi+40], ebx
	jle	SHORT $LN7@xmlParseIn
$LN84@xmlParseIn:
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN7@xmlParseIn

; 8282 :                (ctxt->instate != XML_PARSER_EOF)) {
; 8283 : 	    const xmlChar *check = CUR_PTR;
; 8284 : 	    unsigned int cons = ctxt->input->consumed;

	mov	eax, DWORD PTR [eax+36]

; 8285 : 
; 8286 : 	    SKIP_BLANKS;

	push	esi
	mov	DWORD PTR _cons$1$[ebp], eax
	call	_xmlSkipBlankChars

; 8287 : 	    xmlParseMarkupDecl(ctxt);

	push	esi
	call	_xmlParseMarkupDecl

; 8288 : 	    xmlParsePEReference(ctxt);

	push	esi
	call	_xmlParsePEReference

; 8289 : 
; 8290 : 	    if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [eax+16], edi
	jne	SHORT $LL2@xmlParseIn
	mov	ecx, DWORD PTR _cons$1$[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jne	SHORT $LL2@xmlParseIn

; 8291 : 		xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0DO@IJLBCNCA@xmlParseInternalSubset?3?5error?5d@
	push	1
	push	esi
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 8292 : 	     "xmlParseInternalSubset: error detected in Markup declaration\n");
; 8293 :                 if (ctxt->inputNr > baseInputNr)

	cmp	DWORD PTR [esi+40], ebx
	jle	SHORT $LN7@xmlParseIn

; 8294 :                     xmlPopInput(ctxt);

	push	esi
	call	_xmlPopInput

; 8295 :                 else
; 8296 : 		    break;
; 8297 : 	    }
; 8298 : 	}

	jmp	SHORT $LN85@xmlParseIn
$LN7@xmlParseIn:

; 8299 : 	if (RAW == ']') {

	mov	ecx, DWORD PTR [esi+36]
	pop	edi
	pop	ebx
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 93			; 0000005dH
	jne	SHORT $LN9@xmlParseIn

; 8300 : 	    NEXT;

	push	esi
	call	_xmlNextChar

; 8301 : 	    SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 8
$LN9@xmlParseIn:

; 8302 : 	}
; 8303 :     }
; 8304 : 
; 8305 :     /*
; 8306 :      * We should be at the end of the DOCTYPE declaration.
; 8307 :      */
; 8308 :     if (RAW != '>') {

	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 62			; 0000003eH
	je	SHORT $LN10@xmlParseIn

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN15@xmlParseIn
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN1@xmlParseIn
$LN15@xmlParseIn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BO@NIFLODD@DOCTYPE?5improperly?5terminated@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	61					; 0000003dH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 61			; 0000003dH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN1@xmlParseIn

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
	pop	esi

; 8313 : }

	pop	ebp
	ret	0
$LN10@xmlParseIn:

; 8309 : 	xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
; 8310 : 	return;
; 8311 :     }
; 8312 :     NEXT;

	push	esi
	call	_xmlNextChar
	add	esp, 4
$LN1@xmlParseIn:
	pop	esi

; 8313 : }

	pop	ebp
	ret	0
_xmlParseInternalSubset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseConditionalSections
_TEXT	SEGMENT
_id$1$ = -4						; size = 4
tv2507 = 8						; size = 4
tv2500 = 8						; size = 4
tv2462 = 8						; size = 4
tv2456 = 8						; size = 4
_instate$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseConditionalSections PROC			; COMDAT

; 6615 : xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+36]
	mov	edi, DWORD PTR [eax+56]
	add	DWORD PTR [esi+200], 3
	add	DWORD PTR [eax+16], 3
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR _id$1$[ebp], edi
	add	DWORD PTR [eax+32], 3
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseCo

; 6616 :     int id = ctxt->input->id;
; 6617 : 
; 6618 :     SKIP(3);

	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseCo:

; 6619 :     SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 6620 :     if (CMP7(CUR_PTR, 'I', 'N', 'C', 'L', 'U', 'D', 'E')) {

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 73			; 00000049H
	jne	$LN41@xmlParseCo
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, 78					; 0000004eH
	jne	$LN25@xmlParseCo
	cmp	BYTE PTR [eax+2], 67			; 00000043H
	jne	$LN25@xmlParseCo
	cmp	BYTE PTR [eax+3], 76			; 0000004cH
	jne	$LN25@xmlParseCo
	cmp	BYTE PTR [eax+4], 85			; 00000055H
	jne	$LN25@xmlParseCo
	cmp	BYTE PTR [eax+5], 68			; 00000044H
	jne	$LN25@xmlParseCo
	cmp	BYTE PTR [eax+6], 69			; 00000045H
	jne	$LN25@xmlParseCo

; 6621 : 	SKIP(7);

	add	DWORD PTR [esi+200], 7
	add	DWORD PTR [ecx+16], 7
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 7
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN5@xmlParseCo
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN5@xmlParseCo:

; 6622 : 	SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 6623 : 	if (RAW != '[') {

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 91			; 0000005bH
	je	SHORT $LN28@xmlParseCo

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN72@xmlParseCo
	cmp	DWORD PTR [esi+172], -1
	je	$LN359@xmlParseCo
$LN72@xmlParseCo:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CF@GGBMHDE@XML?5conditional?5section?5?8?$FL?8?5exp@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 83			; 00000053H
	push	83					; 00000053H

; 6658 : 
; 6659 : 	    if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {

	jmp	$LN441@xmlParseCo
$LN28@xmlParseCo:

; 6624 : 	    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
; 6625 : 	    xmlHaltParser(ctxt);
; 6626 : 	    return;
; 6627 : 	} else {
; 6628 : 	    if (ctxt->input->id != id) {

	cmp	DWORD PTR [ecx+56], edi
	je	SHORT $LN30@xmlParseCo

; 6629 : 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0EB@LPINKGGA@All?5markup?5of?5the?5conditional?5s@
	push	90					; 0000005aH
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN30@xmlParseCo:

; 6630 : 	                       "All markup of the conditional section is not"
; 6631 :                                " in the same entity\n");
; 6632 : 	    }
; 6633 : 	    NEXT;

	push	esi
	call	_xmlNextChar
	add	esp, 4

; 6634 : 	}
; 6635 : 	if (xmlParserDebugEntities) {

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN31@xmlParseCo

; 6636 : 	    if ((ctxt->input != NULL) && (ctxt->input->filename))

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN32@xmlParseCo
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN32@xmlParseCo

; 6637 : 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR tv2507[ebp], eax
	mov	edi, DWORD PTR [ecx+28]
	mov	ebx, DWORD PTR [ecx+4]
	call	___xmlGenericErrorContext
	push	edi
	push	ebx
	push	OFFSET ??_C@_08FFIMCMGN@?$CFs?$CI?$CFd?$CJ?3?5@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR tv2507[ebp]
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 16					; 00000010H
$LN32@xmlParseCo:

; 6638 : 			"%s(%d): ", ctxt->input->filename,
; 6639 : 			ctxt->input->line);
; 6640 : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CG@FMCBAD@Entering?5INCLUDE?5Conditional?5Se@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 8
$LN31@xmlParseCo:

; 6641 : 		    "Entering INCLUDE Conditional Section\n");
; 6642 : 	}
; 6643 : 
; 6644 :         SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4

; 6645 :         GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN431@xmlParseCo
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN431@xmlParseCo
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN431@xmlParseCo:

; 6646 : 	while (((RAW != 0) && ((RAW != ']') || (NXT(1) != ']') ||
; 6647 : 	        (NXT(2) != '>'))) && (ctxt->instate != XML_PARSER_EOF)) {

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	je	$LN439@xmlParseCo
	npad	2
$LL8@xmlParseCo:
	mov	edi, DWORD PTR [ecx+16]
	mov	al, BYTE PTR [edi]
	cmp	al, 93					; 0000005dH
	jne	SHORT $LN34@xmlParseCo
	cmp	BYTE PTR [edi+1], al
	jne	SHORT $LN34@xmlParseCo
	cmp	BYTE PTR [edi+2], 62			; 0000003eH
	je	$LN439@xmlParseCo
$LN34@xmlParseCo:
	cmp	DWORD PTR [esi+172], -1
	je	$LN439@xmlParseCo

; 6648 : 	    const xmlChar *check = CUR_PTR;
; 6649 : 	    unsigned int cons = ctxt->input->consumed;

	mov	ebx, DWORD PTR [ecx+36]

; 6650 : 
; 6651 : 	    if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {

	cmp	al, 60					; 0000003cH
	jne	SHORT $LN35@xmlParseCo
	cmp	BYTE PTR [edi+1], 33			; 00000021H
	jne	SHORT $LN35@xmlParseCo
	cmp	BYTE PTR [edi+2], 91			; 0000005bH
	jne	SHORT $LN35@xmlParseCo

; 6652 : 		xmlParseConditionalSections(ctxt);

	push	esi
	call	_xmlParseConditionalSections

; 6653 : 	    } else

	jmp	SHORT $LN442@xmlParseCo
$LN35@xmlParseCo:

; 6654 : 		xmlParseMarkupDecl(ctxt);

	push	esi
	call	_xmlParseMarkupDecl
$LN442@xmlParseCo:

; 6655 : 
; 6656 :             SKIP_BLANKS;

	add	esp, 4
	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4

; 6657 :             GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN37@xmlParseCo
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN37@xmlParseCo
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN37@xmlParseCo:

; 6658 : 
; 6659 : 	    if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, edi
	jne	SHORT $LN38@xmlParseCo
	cmp	ebx, DWORD PTR [ecx+36]
	je	SHORT $LN433@xmlParseCo
$LN38@xmlParseCo:

; 6646 : 	while (((RAW != 0) && ((RAW != ']') || (NXT(1) != ']') ||
; 6647 : 	        (NXT(2) != '>'))) && (ctxt->instate != XML_PARSER_EOF)) {

	cmp	BYTE PTR [eax], 0
	jne	$LL8@xmlParseCo
	jmp	SHORT $LN439@xmlParseCo
$LN433@xmlParseCo:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN160@xmlParseCo
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN223@xmlParseCo
$LN160@xmlParseCo:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CF@HHCGNGIK@Content?5error?5in?5the?5external?5s@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	60					; 0000003cH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 60			; 0000003cH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN223@xmlParseCo

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN223@xmlParseCo:

; 6660 : 		xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
; 6661 : 		xmlHaltParser(ctxt);

	push	esi
	call	_xmlHaltParser
	add	esp, 4
$LN439@xmlParseCo:

; 6662 : 		break;
; 6663 : 	    }
; 6664 : 	}
; 6665 : 	if (xmlParserDebugEntities) {

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	$LN55@xmlParseCo

; 6666 : 	    if ((ctxt->input != NULL) && (ctxt->input->filename))

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN40@xmlParseCo
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN40@xmlParseCo

; 6667 : 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR tv2500[ebp], eax
	mov	edi, DWORD PTR [ecx+28]
	mov	ebx, DWORD PTR [ecx+4]
	call	___xmlGenericErrorContext
	push	edi
	push	ebx
	push	OFFSET ??_C@_08FFIMCMGN@?$CFs?$CI?$CFd?$CJ?3?5@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR tv2500[ebp]
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 16					; 00000010H
$LN40@xmlParseCo:

; 6668 : 			"%s(%d): ", ctxt->input->filename,
; 6669 : 			ctxt->input->line);
; 6670 : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CF@KBFPDCLM@Leaving?5INCLUDE?5Conditional?5Sec@

; 6671 : 		    "Leaving INCLUDE Conditional Section\n");
; 6672 : 	}

	jmp	$LN443@xmlParseCo
$LN25@xmlParseCo:

; 6673 : 
; 6674 :     } else if (CMP6(CUR_PTR, 'I', 'G', 'N', 'O', 'R', 'E')) {

	cmp	dl, 71					; 00000047H
	jne	$LN41@xmlParseCo
	cmp	BYTE PTR [eax+2], 78			; 0000004eH
	jne	$LN41@xmlParseCo
	cmp	BYTE PTR [eax+3], 79			; 0000004fH
	jne	$LN41@xmlParseCo
	cmp	BYTE PTR [eax+4], 82			; 00000052H
	jne	$LN41@xmlParseCo
	cmp	BYTE PTR [eax+5], 69			; 00000045H
	jne	$LN41@xmlParseCo

; 6675 : 	int state;
; 6676 : 	xmlParserInputState instate;
; 6677 : 	int depth = 0;
; 6678 : 
; 6679 : 	SKIP(6);

	add	DWORD PTR [esi+200], 6
	xor	ebx, ebx
	add	DWORD PTR [ecx+16], 6
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 6
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], bl
	jne	SHORT $LN10@xmlParseCo
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN10@xmlParseCo:

; 6680 : 	SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 6681 : 	if (RAW != '[') {

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 91			; 0000005bH
	je	SHORT $LN44@xmlParseCo

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], ebx
	je	SHORT $LN228@xmlParseCo
	cmp	DWORD PTR [esi+172], -1
	je	$LN359@xmlParseCo
$LN228@xmlParseCo:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CF@GGBMHDE@XML?5conditional?5section?5?8?$FL?8?5exp@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	83					; 00000053H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 83			; 00000053H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], ebx

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], ebx

; 6658 : 
; 6659 : 	    if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {

	jmp	$LN440@xmlParseCo
$LN44@xmlParseCo:

; 6682 : 	    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
; 6683 : 	    xmlHaltParser(ctxt);
; 6684 : 	    return;
; 6685 : 	} else {
; 6686 : 	    if (ctxt->input->id != id) {

	cmp	DWORD PTR [ecx+56], edi
	je	SHORT $LN46@xmlParseCo

; 6687 : 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0EB@LPINKGGA@All?5markup?5of?5the?5conditional?5s@
	push	90					; 0000005aH
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN46@xmlParseCo:

; 6688 : 	                       "All markup of the conditional section is not"
; 6689 :                                " in the same entity\n");
; 6690 : 	    }
; 6691 : 	    NEXT;

	push	esi
	call	_xmlNextChar
	add	esp, 4

; 6692 : 	}
; 6693 : 	if (xmlParserDebugEntities) {

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN47@xmlParseCo

; 6694 : 	    if ((ctxt->input != NULL) && (ctxt->input->filename))

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN48@xmlParseCo
	cmp	DWORD PTR [eax+4], ebx
	je	SHORT $LN48@xmlParseCo

; 6695 : 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR tv2462[ebp], eax
	mov	edi, DWORD PTR [ecx+28]
	mov	ebx, DWORD PTR [ecx+4]
	call	___xmlGenericErrorContext
	push	edi
	push	ebx
	push	OFFSET ??_C@_08FFIMCMGN@?$CFs?$CI?$CFd?$CJ?3?5@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR tv2462[ebp]
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 16					; 00000010H
	xor	ebx, ebx
$LN48@xmlParseCo:

; 6696 : 			"%s(%d): ", ctxt->input->filename,
; 6697 : 			ctxt->input->line);
; 6698 : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CF@BNLECKJM@Entering?5IGNORE?5Conditional?5Sec@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 8
$LN47@xmlParseCo:

; 6699 : 		    "Entering IGNORE Conditional Section\n");
; 6700 : 	}
; 6701 : 
; 6702 : 	/*
; 6703 : 	 * Parse up to the end of the conditional section
; 6704 : 	 * But disable SAX event generating DTD building in the meantime
; 6705 : 	 */
; 6706 : 	state = ctxt->disableSAX;
; 6707 : 	instate = ctxt->instate;
; 6708 : 	if (ctxt->recovery == 0) ctxt->disableSAX = 1;

	cmp	DWORD PTR [esi+288], 0
	mov	eax, DWORD PTR [esi+172]
	mov	edi, DWORD PTR [esi+212]
	mov	DWORD PTR _instate$1$[ebp], eax
	jne	SHORT $LN49@xmlParseCo
	mov	DWORD PTR [esi+212], 1
$LN49@xmlParseCo:

; 6709 : 	ctxt->instate = XML_PARSER_IGNORE;

	mov	DWORD PTR [esi+172], 15			; 0000000fH
$LL13@xmlParseCo:

; 6710 : 
; 6711 : 	while (((depth >= 0) && (RAW != 0)) &&

	mov	edx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [edx+16]
	mov	cl, BYTE PTR [eax]
	test	cl, cl
	je	SHORT $LN14@xmlParseCo
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN14@xmlParseCo

; 6712 :                (ctxt->instate != XML_PARSER_EOF)) {
; 6713 : 	  if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {

	cmp	cl, 60					; 0000003cH
	jne	SHORT $LN50@xmlParseCo
	cmp	BYTE PTR [eax+1], 33			; 00000021H
	jne	SHORT $LN50@xmlParseCo
	cmp	BYTE PTR [eax+2], 91			; 0000005bH
	jne	SHORT $LN50@xmlParseCo

; 6714 : 	    depth++;

	inc	ebx
$LN444@xmlParseCo:

; 6710 : 
; 6711 : 	while (((depth >= 0) && (RAW != 0)) &&

	add	DWORD PTR [esi+200], 3
	add	DWORD PTR [edx+16], 3
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 3
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN434@xmlParseCo
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
	jmp	SHORT $LN434@xmlParseCo
$LN50@xmlParseCo:

; 6715 : 	    SKIP(3);
; 6716 : 	    continue;
; 6717 : 	  }
; 6718 : 	  if ((RAW == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {

	cmp	cl, 93					; 0000005dH
	jne	SHORT $LN52@xmlParseCo
	cmp	BYTE PTR [eax+1], cl
	jne	SHORT $LN52@xmlParseCo
	cmp	BYTE PTR [eax+2], 62			; 0000003eH
	jne	SHORT $LN52@xmlParseCo

; 6719 : 	    if (--depth >= 0) SKIP(3);

	sub	ebx, 1
	js	SHORT $LN14@xmlParseCo

; 6720 : 	    continue;

	jmp	SHORT $LN444@xmlParseCo
$LN52@xmlParseCo:

; 6721 : 	  }
; 6722 : 	  NEXT;

	push	esi
	call	_xmlNextChar
	add	esp, 4
$LN434@xmlParseCo:

; 6710 : 
; 6711 : 	while (((depth >= 0) && (RAW != 0)) &&

	test	ebx, ebx
	jns	SHORT $LL13@xmlParseCo
$LN14@xmlParseCo:

; 6723 : 	  continue;
; 6724 : 	}
; 6725 : 
; 6726 : 	ctxt->disableSAX = state;
; 6727 : 	ctxt->instate = instate;

	mov	eax, DWORD PTR _instate$1$[ebp]
	mov	DWORD PTR [esi+212], edi
	mov	DWORD PTR [esi+172], eax

; 6728 : 
; 6729 : 	if (xmlParserDebugEntities) {

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN55@xmlParseCo

; 6730 : 	    if ((ctxt->input != NULL) && (ctxt->input->filename))

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN56@xmlParseCo
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN56@xmlParseCo

; 6731 : 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR tv2456[ebp], eax
	mov	edi, DWORD PTR [ecx+28]
	mov	ebx, DWORD PTR [ecx+4]
	call	___xmlGenericErrorContext
	push	edi
	push	ebx
	push	OFFSET ??_C@_08FFIMCMGN@?$CFs?$CI?$CFd?$CJ?3?5@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR tv2456[ebp]
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 16					; 00000010H
$LN56@xmlParseCo:

; 6732 : 			"%s(%d): ", ctxt->input->filename,
; 6733 : 			ctxt->input->line);
; 6734 : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CE@MPDEOLDN@Leaving?5IGNORE?5Conditional?5Sect@
$LN443@xmlParseCo:

; 6741 : 	return;
; 6742 :     }
; 6743 : 
; 6744 :     if (RAW == 0)

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 8
$LN55@xmlParseCo:
	mov	ecx, DWORD PTR [esi+36]
	mov	edx, ecx
	mov	edi, DWORD PTR [ecx+16]
	cmp	BYTE PTR [edi], 0
	jne	SHORT $LN58@xmlParseCo

; 6745 :         SHRINK;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN58@xmlParseCo
	mov	eax, edi
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN58@xmlParseCo
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edi
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN58@xmlParseCo
	push	esi
	call	_xmlSHRINK
	mov	edx, DWORD PTR [esi+36]
	add	esp, 4
$LN58@xmlParseCo:

; 6746 : 
; 6747 :     if (RAW == 0) {

	mov	eax, DWORD PTR [edx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN59@xmlParseCo

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN364@xmlParseCo
	cmp	DWORD PTR [esi+172], -1
	je	$LN22@xmlParseCo
$LN364@xmlParseCo:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CD@OHPJFFIN@XML?5conditional?5section?5not?5clo@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	59					; 0000003bH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 59			; 0000003bH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	$LN22@xmlParseCo
	pop	edi

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1

; 6758 :     }
; 6759 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@xmlParseCo:

; 6748 : 	xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);
; 6749 :     } else {
; 6750 : 	if (ctxt->input->id != id) {

	mov	eax, DWORD PTR _id$1$[ebp]
	cmp	DWORD PTR [edx+56], eax
	je	SHORT $LN61@xmlParseCo

; 6751 : 	    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0EB@LPINKGGA@All?5markup?5of?5the?5conditional?5s@
	push	90					; 0000005aH
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN61@xmlParseCo:

; 6752 : 	                   "All markup of the conditional section is not in"
; 6753 :                            " the same entity\n");
; 6754 : 	}
; 6755 : 	if ((ctxt-> instate != XML_PARSER_EOF) &&

	cmp	DWORD PTR [esi+172], -1
	je	$LN22@xmlParseCo
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	add	eax, 3
	cmp	eax, DWORD PTR [ecx+20]
	ja	$LN22@xmlParseCo

; 6756 : 	    ((ctxt->input->cur + 3) <= ctxt->input->end))
; 6757 : 	    SKIP(3);

	add	DWORD PTR [esi+200], 3
	add	DWORD PTR [ecx+16], 3
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 3
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	$LN22@xmlParseCo
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
	pop	edi

; 6758 :     }
; 6759 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@xmlParseCo:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN296@xmlParseCo
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN359@xmlParseCo
$LN296@xmlParseCo:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0DH@JDEKAAA@conditional?5section?5INCLUDE?5or?5@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 95			; 0000005fH
	push	95					; 0000005fH
$LN441@xmlParseCo:

; 6735 : 		    "Leaving IGNORE Conditional Section\n");
; 6736 : 	}
; 6737 : 
; 6738 :     } else {
; 6739 : 	xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
; 6740 : 	xmlHaltParser(ctxt);

	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	mov	DWORD PTR [esi+12], 0
	cmp	DWORD PTR [esi+288], 0
$LN440@xmlParseCo:
	jne	SHORT $LN359@xmlParseCo
	mov	DWORD PTR [esi+212], 1
$LN359@xmlParseCo:
	push	esi
	call	_xmlHaltParser
	add	esp, 4
$LN22@xmlParseCo:

; 6758 :     }
; 6759 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseConditionalSections ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseElementChildrenContentDeclPriv
_TEXT	SEGMENT
_cur$2$ = -12						; size = 4
_last$1$ = -8						; size = 4
_type$1$ = -1						; size = 1
_ctxt$ = 8						; size = 4
_inputchk$ = 12						; size = 4
_found$1$ = 16						; size = 4
_depth$ = 16						; size = 4
_xmlParseElementChildrenContentDeclPriv PROC		; COMDAT

; 6150 :                                        int depth) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _depth$[ebp]
	xor	eax, eax
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _last$1$[ebp], eax
	xor	al, al
	mov	BYTE PTR _type$1$[ebp], al
	cmp	ebx, 128				; 00000080H
	jle	SHORT $LN10@xmlParseEl

; 6151 :     xmlElementContentPtr ret = NULL, cur = NULL, last = NULL, op = NULL;
; 6152 :     const xmlChar *elem;
; 6153 :     xmlChar type = 0;
; 6154 : 
; 6155 :     if (((depth > 128) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||

	test	DWORD PTR [edi+360], 524288		; 00080000H
	je	SHORT $LN9@xmlParseEl
$LN10@xmlParseEl:
	cmp	ebx, 2048				; 00000800H
	jle	SHORT $LN8@xmlParseEl
$LN9@xmlParseEl:

; 6156 :         (depth >  2048)) {
; 6157 :         xmlFatalErrMsgInt(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED,

	push	ebx
	push	OFFSET ??_C@_0EM@OINCFINP@xmlParseElementChildrenContentD@
	push	55					; 00000037H
	push	edi
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H

; 6158 : "xmlParseElementChildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE\n",
; 6159 :                           depth);
; 6160 : 	return(NULL);

	xor	eax, eax
	pop	edi

; 6412 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlParseEl:

; 6161 :     }
; 6162 :     SKIP_BLANKS;

	push	edi
	call	_xmlSkipBlankChars
	add	esp, 4

; 6163 :     GROW;

	cmp	DWORD PTR [edi+292], 0
	jne	SHORT $LN11@xmlParseEl
	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN11@xmlParseEl
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN11@xmlParseEl:

; 6164 :     if (RAW == '(') {

	push	esi
	mov	esi, DWORD PTR [edi+36]
	push	edi
	mov	eax, DWORD PTR [esi+16]
	cmp	BYTE PTR [eax], 40			; 00000028H
	jne	SHORT $LN12@xmlParseEl

; 6165 : 	int inputid = ctxt->input->id;

	mov	esi, DWORD PTR [esi+56]

; 6166 : 
; 6167 :         /* Recurse on first child */
; 6168 : 	NEXT;

	call	_xmlNextChar

; 6169 : 	SKIP_BLANKS;

	push	edi
	call	_xmlSkipBlankChars

; 6170 :         cur = ret = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,

	lea	eax, DWORD PTR [ebx+1]
	push	eax
	push	esi
	push	edi
	call	_xmlParseElementChildrenContentDeclPriv

; 6171 :                                                            depth + 1);
; 6172 : 	SKIP_BLANKS;

	push	edi
	mov	ebx, eax
	call	_xmlSkipBlankChars
	add	esp, 24					; 00000018H

; 6173 : 	GROW;
; 6174 :     } else {

	jmp	$LN23@xmlParseEl
$LN12@xmlParseEl:

; 6175 : 	elem = xmlParseName(ctxt);

	call	_xmlParseName
	add	esp, 4

; 6176 : 	if (elem == NULL) {

	test	eax, eax
	jne	SHORT $LN15@xmlParseEl

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edi+212], eax
	je	SHORT $LN102@xmlParseEl
	cmp	DWORD PTR [edi+172], -1
	je	$LN56@xmlParseEl
$LN102@xmlParseEl:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CD@NHADBOBB@ContentDecl?5?3?5Name?5or?5?8?$CI?8?5expec@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	54					; 00000036H
	push	1
	push	0
	push	edi
	push	0
	push	0
	push	0
	mov	DWORD PTR [edi+84], 54			; 00000036H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [edi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [edi+288], 0
	jne	$LN56@xmlParseEl
	pop	esi

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [edi+212], 1

; 6278 : 	        cur->c2 = op;
; 6279 : 		if (op != NULL)
; 6280 : 		    op->parent = cur;
; 6281 : 		op->c1 = last;
; 6282 : 		if (last != NULL)
; 6283 : 		    last->parent = op;
; 6284 : 		cur =op;
; 6285 : 		last = NULL;
; 6286 : 	    }
; 6287 : 	} else {
; 6288 : 	    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED, NULL);
; 6289 : 	    if ((last != NULL) && (last != ret))
; 6290 : 	        xmlFreeDocElementContent(ctxt->myDoc, last);
; 6291 : 	    if (ret != NULL)
; 6292 : 		xmlFreeDocElementContent(ctxt->myDoc, ret);
; 6293 : 	    return(NULL);

	xor	eax, eax
	pop	edi

; 6412 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlParseEl:

; 6177 : 	    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);
; 6178 : 	    return(NULL);
; 6179 : 	}
; 6180 :         cur = ret = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);

	push	2
	push	eax
	push	DWORD PTR [edi+8]
	call	_xmlNewDocElementContent
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 6181 : 	if (cur == NULL) {

	test	ebx, ebx
	jne	SHORT $LN16@xmlParseEl

; 6182 : 	    xmlErrMemory(ctxt, NULL);

	push	eax
	push	edi
	call	_xmlErrMemory
	add	esp, 8

; 6183 : 	    return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 6412 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlParseEl:

; 6184 : 	}
; 6185 : 	GROW;

	cmp	DWORD PTR [edi+292], 0
	jne	SHORT $LN17@xmlParseEl
	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN17@xmlParseEl
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN17@xmlParseEl:

; 6186 : 	if (RAW == '?') {

	mov	eax, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 63					; 0000003fH
	jne	SHORT $LN18@xmlParseEl

; 6187 : 	    cur->ocur = XML_ELEMENT_CONTENT_OPT;
; 6188 : 	    NEXT;

	push	edi
	mov	DWORD PTR [ebx+4], 2
	call	_xmlNextChar
	add	esp, 4
	jmp	SHORT $LN23@xmlParseEl
$LN18@xmlParseEl:

; 6189 : 	} else if (RAW == '*') {

	cmp	al, 42					; 0000002aH
	jne	SHORT $LN20@xmlParseEl

; 6190 : 	    cur->ocur = XML_ELEMENT_CONTENT_MULT;
; 6191 : 	    NEXT;

	push	edi
	mov	DWORD PTR [ebx+4], 3
	call	_xmlNextChar
	add	esp, 4
	jmp	SHORT $LN23@xmlParseEl
$LN20@xmlParseEl:

; 6192 : 	} else if (RAW == '+') {

	cmp	al, 43					; 0000002bH
	jne	SHORT $LN22@xmlParseEl

; 6193 : 	    cur->ocur = XML_ELEMENT_CONTENT_PLUS;
; 6194 : 	    NEXT;

	push	edi
	mov	DWORD PTR [ebx+4], 4
	call	_xmlNextChar
	add	esp, 4

; 6195 : 	} else {

	jmp	SHORT $LN23@xmlParseEl
$LN22@xmlParseEl:

; 6196 : 	    cur->ocur = XML_ELEMENT_CONTENT_ONCE;

	mov	DWORD PTR [ebx+4], 1
$LN23@xmlParseEl:

; 6197 : 	}
; 6198 : 	GROW;
; 6199 :     }
; 6200 :     SKIP_BLANKS;

	cmp	DWORD PTR [edi+292], 0
	jne	SHORT $LN24@xmlParseEl
	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN24@xmlParseEl
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN24@xmlParseEl:
	push	edi
	call	_xmlSkipBlankChars
	add	esp, 4

; 6201 :     SHRINK;

	cmp	DWORD PTR [edi+292], 0
	jne	SHORT $LN303@xmlParseEl
	mov	ecx, DWORD PTR [edi+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN303@xmlParseEl
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN303@xmlParseEl
	push	edi
	call	_xmlSHRINK
	add	esp, 4
$LN303@xmlParseEl:

; 6202 :     while ((RAW != ')') && (ctxt->instate != XML_PARSER_EOF)) {

	mov	ecx, DWORD PTR [edi+36]
	mov	esi, ebx
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 41			; 00000029H
	je	$LN3@xmlParseEl
	mov	edx, ecx
$LL2@xmlParseEl:
	cmp	DWORD PTR [edi+172], -1
	je	$LN3@xmlParseEl

; 6203 :         /*
; 6204 : 	 * Each loop we parse one separator and one element.
; 6205 : 	 */
; 6206 :         if (RAW == ',') {

	mov	eax, DWORD PTR [edx+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 44					; 0000002cH
	jne	SHORT $LN26@xmlParseEl

; 6207 : 	    if (type == 0) type = CUR;

	mov	al, BYTE PTR _type$1$[ebp]
	test	al, al
	jne	SHORT $LN28@xmlParseEl
	mov	BYTE PTR _type$1$[ebp], 44		; 0000002cH
	jmp	SHORT $LN30@xmlParseEl
$LN28@xmlParseEl:

; 6208 : 
; 6209 : 	    /*
; 6210 : 	     * Detect "Name | Name , Name" error
; 6211 : 	     */
; 6212 : 	    else if (type != CUR) {

	cmp	al, 44					; 0000002cH
	jne	$LN306@xmlParseEl
$LN30@xmlParseEl:

; 6213 : 		xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
; 6214 : 		    "xmlParseElementChildrenContentDecl : '%c' expected\n",
; 6215 : 		                  type);
; 6216 : 		if ((last != NULL) && (last != ret))
; 6217 : 		    xmlFreeDocElementContent(ctxt->myDoc, last);
; 6218 : 		if (ret != NULL)
; 6219 : 		    xmlFreeDocElementContent(ctxt->myDoc, ret);
; 6220 : 		return(NULL);
; 6221 : 	    }
; 6222 : 	    NEXT;

	push	edi
	call	_xmlNextChar

; 6223 : 
; 6224 : 	    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_SEQ);

	push	3
	push	0
	push	DWORD PTR [edi+8]
	call	_xmlNewDocElementContent
	mov	ecx, eax
	add	esp, 16					; 00000010H

; 6225 : 	    if (op == NULL) {

	mov	eax, DWORD PTR _last$1$[ebp]
	test	ecx, ecx
	je	$LN307@xmlParseEl
$LN327@xmlParseEl:

; 6294 : 	}
; 6295 : 	GROW;

	test	eax, eax
	jne	SHORT $LN50@xmlParseEl
	mov	DWORD PTR [ecx+12], ebx
	test	ebx, ebx
	je	SHORT $LN37@xmlParseEl
	mov	DWORD PTR [ebx+20], ecx
$LN37@xmlParseEl:
	mov	ebx, ecx
	jmp	SHORT $LN326@xmlParseEl
$LN26@xmlParseEl:

; 6230 : 	    }
; 6231 : 	    if (last == NULL) {
; 6232 : 		op->c1 = ret;
; 6233 : 		if (ret != NULL)
; 6234 : 		    ret->parent = op;
; 6235 : 		ret = cur = op;
; 6236 : 	    } else {
; 6237 : 	        cur->c2 = op;
; 6238 : 		if (op != NULL)
; 6239 : 		    op->parent = cur;
; 6240 : 		op->c1 = last;
; 6241 : 		if (last != NULL)
; 6242 : 		    last->parent = op;
; 6243 : 		cur =op;
; 6244 : 		last = NULL;
; 6245 : 	    }
; 6246 : 	} else if (RAW == '|') {

	cmp	al, 124					; 0000007cH
	jne	$LN40@xmlParseEl

; 6247 : 	    if (type == 0) type = CUR;

	mov	al, BYTE PTR _type$1$[ebp]
	test	al, al
	jne	SHORT $LN42@xmlParseEl
	mov	BYTE PTR _type$1$[ebp], 124		; 0000007cH
	jmp	SHORT $LN44@xmlParseEl
$LN42@xmlParseEl:

; 6248 : 
; 6249 : 	    /*
; 6250 : 	     * Detect "Name , Name | Name" error
; 6251 : 	     */
; 6252 : 	    else if (type != CUR) {

	cmp	al, 124					; 0000007cH
	jne	$LN306@xmlParseEl
$LN44@xmlParseEl:

; 6253 : 		xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
; 6254 : 		    "xmlParseElementChildrenContentDecl : '%c' expected\n",
; 6255 : 				  type);
; 6256 : 		if ((last != NULL) && (last != ret))
; 6257 : 		    xmlFreeDocElementContent(ctxt->myDoc, last);
; 6258 : 		if (ret != NULL)
; 6259 : 		    xmlFreeDocElementContent(ctxt->myDoc, ret);
; 6260 : 		return(NULL);
; 6261 : 	    }
; 6262 : 	    NEXT;

	push	edi
	call	_xmlNextChar

; 6263 : 
; 6264 : 	    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);

	push	4
	push	0
	push	DWORD PTR [edi+8]
	call	_xmlNewDocElementContent
	mov	ecx, eax
	add	esp, 16					; 00000010H

; 6265 : 	    if (op == NULL) {

	mov	eax, DWORD PTR _last$1$[ebp]
	test	ecx, ecx
	je	$LN309@xmlParseEl

; 6266 : 		if ((last != NULL) && (last != ret))
; 6267 : 		    xmlFreeDocElementContent(ctxt->myDoc, last);
; 6268 : 		if (ret != NULL)
; 6269 : 		    xmlFreeDocElementContent(ctxt->myDoc, ret);
; 6270 : 		return(NULL);
; 6271 : 	    }
; 6272 : 	    if (last == NULL) {
; 6273 : 		op->c1 = ret;
; 6274 : 		if (ret != NULL)
; 6275 : 		    ret->parent = op;
; 6276 : 		ret = cur = op;
; 6277 : 	    } else {

	jmp	SHORT $LN327@xmlParseEl
$LN50@xmlParseEl:

; 6294 : 	}
; 6295 : 	GROW;

	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [ecx+20], esi
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [eax+20], ecx
$LN326@xmlParseEl:
	cmp	DWORD PTR [edi+292], 0
	mov	DWORD PTR _cur$2$[ebp], ecx
	jne	SHORT $LN57@xmlParseEl
	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN57@xmlParseEl
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN57@xmlParseEl:

; 6296 : 	SKIP_BLANKS;

	push	edi
	call	_xmlSkipBlankChars
	add	esp, 4

; 6297 : 	GROW;

	cmp	DWORD PTR [edi+292], 0
	jne	SHORT $LN58@xmlParseEl
	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN58@xmlParseEl
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN58@xmlParseEl:

; 6298 : 	if (RAW == '(') {

	mov	esi, DWORD PTR [edi+36]
	push	edi
	mov	eax, DWORD PTR [esi+16]
	cmp	BYTE PTR [eax], 40			; 00000028H
	jne	SHORT $LN59@xmlParseEl

; 6299 : 	    int inputid = ctxt->input->id;

	mov	esi, DWORD PTR [esi+56]

; 6300 : 	    /* Recurse on second child */
; 6301 : 	    NEXT;

	call	_xmlNextChar

; 6302 : 	    SKIP_BLANKS;

	push	edi
	call	_xmlSkipBlankChars

; 6303 : 	    last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,

	mov	eax, DWORD PTR _depth$[ebp]
	inc	eax
	push	eax
	push	esi
	push	edi
	call	_xmlParseElementChildrenContentDeclPriv

; 6304 :                                                           depth + 1);
; 6305 : 	    SKIP_BLANKS;

	push	edi
	mov	DWORD PTR _last$1$[ebp], eax
	call	_xmlSkipBlankChars
	add	esp, 24					; 00000018H

; 6306 : 	} else {

	jmp	SHORT $LN70@xmlParseEl
$LN59@xmlParseEl:

; 6307 : 	    elem = xmlParseName(ctxt);

	call	_xmlParseName
	add	esp, 4

; 6308 : 	    if (elem == NULL) {

	test	eax, eax
	je	$LN310@xmlParseEl

; 6309 : 		xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);
; 6310 : 		if (ret != NULL)
; 6311 : 		    xmlFreeDocElementContent(ctxt->myDoc, ret);
; 6312 : 		return(NULL);
; 6313 : 	    }
; 6314 : 	    last = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);

	push	2
	push	eax
	push	DWORD PTR [edi+8]
	call	_xmlNewDocElementContent
	mov	esi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _last$1$[ebp], esi

; 6315 : 	    if (last == NULL) {

	test	esi, esi
	je	$LN55@xmlParseEl

; 6316 : 		if (ret != NULL)
; 6317 : 		    xmlFreeDocElementContent(ctxt->myDoc, ret);
; 6318 : 		return(NULL);
; 6319 : 	    }
; 6320 : 	    if (RAW == '?') {

	mov	eax, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 63					; 0000003fH
	jne	SHORT $LN65@xmlParseEl

; 6321 : 		last->ocur = XML_ELEMENT_CONTENT_OPT;
; 6322 : 		NEXT;

	push	edi
	mov	DWORD PTR [esi+4], 2
	call	_xmlNextChar
	add	esp, 4
	jmp	SHORT $LN70@xmlParseEl
$LN65@xmlParseEl:

; 6323 : 	    } else if (RAW == '*') {

	cmp	al, 42					; 0000002aH
	jne	SHORT $LN67@xmlParseEl

; 6324 : 		last->ocur = XML_ELEMENT_CONTENT_MULT;
; 6325 : 		NEXT;

	push	edi
	mov	DWORD PTR [esi+4], 3
	call	_xmlNextChar
	add	esp, 4
	jmp	SHORT $LN70@xmlParseEl
$LN67@xmlParseEl:

; 6326 : 	    } else if (RAW == '+') {

	cmp	al, 43					; 0000002bH
	jne	SHORT $LN69@xmlParseEl

; 6327 : 		last->ocur = XML_ELEMENT_CONTENT_PLUS;
; 6328 : 		NEXT;

	push	edi
	mov	DWORD PTR [esi+4], 4
	call	_xmlNextChar
	add	esp, 4

; 6329 : 	    } else {

	jmp	SHORT $LN70@xmlParseEl
$LN69@xmlParseEl:

; 6330 : 		last->ocur = XML_ELEMENT_CONTENT_ONCE;

	mov	DWORD PTR [esi+4], 1
$LN70@xmlParseEl:

; 6331 : 	    }
; 6332 : 	}
; 6333 : 	SKIP_BLANKS;

	push	edi
	call	_xmlSkipBlankChars
	add	esp, 4

; 6334 : 	GROW;

	cmp	DWORD PTR [edi+292], 0
	jne	SHORT $LN71@xmlParseEl
	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN71@xmlParseEl
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN71@xmlParseEl:

; 6202 :     while ((RAW != ')') && (ctxt->instate != XML_PARSER_EOF)) {

	mov	ecx, DWORD PTR [edi+36]
	mov	edx, ecx
	mov	esi, DWORD PTR _cur$2$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 41			; 00000029H
	jne	$LL2@xmlParseEl
$LN3@xmlParseEl:

; 6335 :     }
; 6336 :     if ((cur != NULL) && (last != NULL)) {

	test	esi, esi
	je	SHORT $LN73@xmlParseEl
	mov	eax, DWORD PTR _last$1$[ebp]
	test	eax, eax
	je	SHORT $LN73@xmlParseEl

; 6337 :         cur->c2 = last;

	mov	DWORD PTR [esi+16], eax

; 6338 : 	if (last != NULL)
; 6339 : 	    last->parent = cur;

	mov	DWORD PTR [eax+20], esi
	mov	ecx, DWORD PTR [edi+36]
$LN73@xmlParseEl:

; 6340 :     }
; 6341 :     if (ctxt->input->id != inputchk) {

	mov	eax, DWORD PTR [ecx+56]
	cmp	eax, DWORD PTR _inputchk$[ebp]
	je	SHORT $LN74@xmlParseEl

; 6342 : 	xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0EH@KGLJHJPD@Element?5content?5declaration?5doe@
	push	90					; 0000005aH
	push	edi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN74@xmlParseEl:

; 6343 :                        "Element content declaration doesn't start and stop in"
; 6344 :                        " the same entity\n");
; 6345 :     }
; 6346 :     NEXT;

	push	edi
	call	_xmlNextChar

; 6347 :     if (RAW == '?') {

	mov	eax, DWORD PTR [edi+36]
	add	esp, 4
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 63					; 0000003fH
	jne	$LN75@xmlParseEl

; 6348 : 	if (ret != NULL) {

	test	ebx, ebx
	je	$LN97@xmlParseEl

; 6349 : 	    if ((ret->ocur == XML_ELEMENT_CONTENT_PLUS) ||

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, 4
	je	$LN80@xmlParseEl
	cmp	eax, 3
	je	$LN80@xmlParseEl

; 6407 : 		ret->ocur = XML_ELEMENT_CONTENT_MULT;
; 6408 : 	}
; 6409 : 	NEXT;

	push	edi
	mov	DWORD PTR [ebx+4], 2
	call	_xmlNextChar
	add	esp, 4

; 6410 :     }
; 6411 :     return(ret);

	mov	eax, ebx
	pop	esi
	pop	edi

; 6412 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN307@xmlParseEl:

; 6226 : 		if ((last != NULL) && (last != ret))

	test	eax, eax
	je	SHORT $LN34@xmlParseEl
	cmp	eax, ebx
	je	SHORT $LN34@xmlParseEl

; 6227 : 		    xmlFreeDocElementContent(ctxt->myDoc, last);

	push	eax
	push	DWORD PTR [edi+8]
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN34@xmlParseEl:

; 6228 : 	        xmlFreeDocElementContent(ctxt->myDoc, ret);

	push	ebx
	push	DWORD PTR [edi+8]
	call	_xmlFreeDocElementContent
	add	esp, 8

; 6229 : 		return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 6412 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN306@xmlParseEl:

; 6278 : 	        cur->c2 = op;
; 6279 : 		if (op != NULL)
; 6280 : 		    op->parent = cur;
; 6281 : 		op->c1 = last;
; 6282 : 		if (last != NULL)
; 6283 : 		    last->parent = op;
; 6284 : 		cur =op;
; 6285 : 		last = NULL;
; 6286 : 	    }
; 6287 : 	} else {
; 6288 : 	    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED, NULL);
; 6289 : 	    if ((last != NULL) && (last != ret))
; 6290 : 	        xmlFreeDocElementContent(ctxt->myDoc, last);
; 6291 : 	    if (ret != NULL)
; 6292 : 		xmlFreeDocElementContent(ctxt->myDoc, ret);
; 6293 : 	    return(NULL);

	movzx	eax, al
	push	eax
	push	OFFSET ??_C@_0DE@IJONAOBP@xmlParseElementChildrenContentD@
	push	66					; 00000042H
	push	edi
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H
	jmp	$LN233@xmlParseEl
$LN310@xmlParseEl:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edi+212], 0
	je	SHORT $LN238@xmlParseEl
	cmp	DWORD PTR [edi+172], -1
	je	$LN55@xmlParseEl
$LN238@xmlParseEl:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CD@NHADBOBB@ContentDecl?5?3?5Name?5or?5?8?$CI?8?5expec@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	54					; 00000036H
	push	1
	push	0
	push	edi
	push	0
	push	0
	push	0
	mov	DWORD PTR [edi+84], 54			; 00000036H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [edi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [edi+288], 0
	jne	SHORT $LN55@xmlParseEl

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [edi+212], 1
	jmp	SHORT $LN55@xmlParseEl
$LN40@xmlParseEl:

; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CG@EHNJPHMB@ContentDecl?5?3?5?8?0?8?5?8?$HM?8?5or?5?8?$CJ?8?5ex@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	55					; 00000037H
	push	1
	push	0
	push	edi
	push	0
	push	0
	push	0
	mov	DWORD PTR [edi+84], 55			; 00000037H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [edi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [edi+288], 0
	jne	SHORT $LN233@xmlParseEl

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [edi+212], 1
$LN233@xmlParseEl:

; 6278 : 	        cur->c2 = op;
; 6279 : 		if (op != NULL)
; 6280 : 		    op->parent = cur;
; 6281 : 		op->c1 = last;
; 6282 : 		if (last != NULL)
; 6283 : 		    last->parent = op;
; 6284 : 		cur =op;
; 6285 : 		last = NULL;
; 6286 : 	    }
; 6287 : 	} else {
; 6288 : 	    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED, NULL);
; 6289 : 	    if ((last != NULL) && (last != ret))
; 6290 : 	        xmlFreeDocElementContent(ctxt->myDoc, last);
; 6291 : 	    if (ret != NULL)
; 6292 : 		xmlFreeDocElementContent(ctxt->myDoc, ret);
; 6293 : 	    return(NULL);

	mov	eax, DWORD PTR _last$1$[ebp]
$LN309@xmlParseEl:
	test	eax, eax
	je	SHORT $LN55@xmlParseEl
	cmp	eax, ebx
	je	SHORT $LN55@xmlParseEl
	push	eax
	push	DWORD PTR [edi+8]
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN55@xmlParseEl:
	test	ebx, ebx
	je	SHORT $LN56@xmlParseEl
	push	ebx
	push	DWORD PTR [edi+8]
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN56@xmlParseEl:
	pop	esi
	pop	edi
	xor	eax, eax

; 6412 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN75@xmlParseEl:

; 6350 : 	        (ret->ocur == XML_ELEMENT_CONTENT_MULT))
; 6351 : 	        ret->ocur = XML_ELEMENT_CONTENT_MULT;
; 6352 : 	    else
; 6353 : 	        ret->ocur = XML_ELEMENT_CONTENT_OPT;
; 6354 : 	}
; 6355 : 	NEXT;
; 6356 :     } else if (RAW == '*') {

	cmp	al, 42					; 0000002aH
	jne	SHORT $LN81@xmlParseEl

; 6357 : 	if (ret != NULL) {

	test	ebx, ebx
	je	$LN97@xmlParseEl

; 6358 : 	    ret->ocur = XML_ELEMENT_CONTENT_MULT;

	mov	DWORD PTR [ebx+4], 3

; 6359 : 	    cur = ret;

	mov	eax, ebx
	npad	7
$LL4@xmlParseEl:

; 6360 : 	    /*
; 6361 : 	     * Some normalization:
; 6362 : 	     * (a | b* | c?)* == (a | b | c)*
; 6363 : 	     */
; 6364 : 	    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {

	cmp	DWORD PTR [eax], 4
	jne	$LN97@xmlParseEl

; 6365 : 		if ((cur->c1 != NULL) &&

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN84@xmlParseEl
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, 2
	je	SHORT $LN85@xmlParseEl
	cmp	edx, 3
	jne	SHORT $LN84@xmlParseEl
$LN85@xmlParseEl:

; 6366 : 	            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||
; 6367 : 		     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT)))
; 6368 : 		    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;

	mov	DWORD PTR [ecx+4], 1
$LN84@xmlParseEl:

; 6369 : 		if ((cur->c2 != NULL) &&

	lea	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	$LN97@xmlParseEl
	mov	esi, DWORD PTR [eax+4]
	cmp	esi, 2
	je	SHORT $LN87@xmlParseEl
	cmp	esi, 3
	jne	SHORT $LN86@xmlParseEl
$LN87@xmlParseEl:

; 6370 : 	            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||
; 6371 : 		     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT)))
; 6372 : 		    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;

	mov	DWORD PTR [eax+4], 1
	mov	eax, DWORD PTR [edx]
$LN86@xmlParseEl:

; 6360 : 	    /*
; 6361 : 	     * Some normalization:
; 6362 : 	     * (a | b* | c?)* == (a | b | c)*
; 6363 : 	     */
; 6364 : 	    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {

	test	eax, eax
	jne	SHORT $LL4@xmlParseEl

; 6407 : 		ret->ocur = XML_ELEMENT_CONTENT_MULT;
; 6408 : 	}
; 6409 : 	NEXT;

	push	edi
	call	_xmlNextChar
	add	esp, 4

; 6410 :     }
; 6411 :     return(ret);

	mov	eax, ebx
	pop	esi
	pop	edi

; 6412 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN81@xmlParseEl:

; 6373 : 		cur = cur->c2;
; 6374 : 	    }
; 6375 : 	}
; 6376 : 	NEXT;
; 6377 :     } else if (RAW == '+') {

	cmp	al, 43					; 0000002bH
	jne	$LN88@xmlParseEl

; 6378 : 	if (ret != NULL) {

	test	ebx, ebx
	je	$LN97@xmlParseEl

; 6379 : 	    int found = 0;
; 6380 : 
; 6381 : 	    if ((ret->ocur == XML_ELEMENT_CONTENT_OPT) ||

	mov	eax, DWORD PTR [ebx+4]
	xor	ecx, ecx
	mov	DWORD PTR _found$1$[ebp], ecx
	cmp	eax, 2
	je	SHORT $LN92@xmlParseEl
	cmp	eax, 3

; 6384 : 	    else
; 6385 : 	        ret->ocur = XML_ELEMENT_CONTENT_PLUS;

	lea	eax, DWORD PTR [ecx+4]
	jne	SHORT $LN305@xmlParseEl
$LN92@xmlParseEl:

; 6382 : 	        (ret->ocur == XML_ELEMENT_CONTENT_MULT))
; 6383 : 	        ret->ocur = XML_ELEMENT_CONTENT_MULT;

	mov	eax, 3
$LN305@xmlParseEl:

; 6386 : 	    /*
; 6387 : 	     * Some normalization:
; 6388 : 	     * (a | b*)+ == (a | b)*
; 6389 : 	     * (a | b?)+ == (a | b)*
; 6390 : 	     */
; 6391 : 	    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {

	mov	DWORD PTR [ebx+4], eax
	test	esi, esi
	je	SHORT $LN97@xmlParseEl
	npad	2
$LL6@xmlParseEl:
	cmp	DWORD PTR [esi], 4
	jne	SHORT $LN7@xmlParseEl

; 6392 : 		if ((cur->c1 != NULL) &&

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN93@xmlParseEl
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 2
	je	SHORT $LN94@xmlParseEl
	cmp	ecx, 3
	jne	SHORT $LN322@xmlParseEl
$LN94@xmlParseEl:

; 6393 : 	            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||
; 6394 : 		     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {
; 6395 : 		    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;
; 6396 : 		    found = 1;

	mov	ecx, 1
	mov	DWORD PTR [eax+4], 1
	mov	DWORD PTR _found$1$[ebp], ecx
	jmp	SHORT $LN93@xmlParseEl
$LN322@xmlParseEl:

; 6392 : 		if ((cur->c1 != NULL) &&

	mov	ecx, DWORD PTR _found$1$[ebp]
$LN93@xmlParseEl:

; 6397 : 		}
; 6398 : 		if ((cur->c2 != NULL) &&

	lea	edx, DWORD PTR [esi+16]
	mov	esi, DWORD PTR [edx]
	test	esi, esi
	je	SHORT $LN7@xmlParseEl
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, 2
	je	SHORT $LN96@xmlParseEl
	cmp	ecx, 3
	jne	SHORT $LN321@xmlParseEl
$LN96@xmlParseEl:

; 6399 : 	            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||
; 6400 : 		     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT))) {
; 6401 : 		    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;
; 6402 : 		    found = 1;

	mov	ecx, 1
	mov	DWORD PTR [esi+4], 1
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR _found$1$[ebp], ecx
	jmp	SHORT $LN95@xmlParseEl
$LN321@xmlParseEl:

; 6397 : 		}
; 6398 : 		if ((cur->c2 != NULL) &&

	mov	ecx, DWORD PTR _found$1$[ebp]
$LN95@xmlParseEl:

; 6386 : 	    /*
; 6387 : 	     * Some normalization:
; 6388 : 	     * (a | b*)+ == (a | b)*
; 6389 : 	     * (a | b?)+ == (a | b)*
; 6390 : 	     */
; 6391 : 	    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {

	test	esi, esi
	jne	SHORT $LL6@xmlParseEl
$LN7@xmlParseEl:

; 6403 : 		}
; 6404 : 		cur = cur->c2;
; 6405 : 	    }
; 6406 : 	    if (found)

	test	ecx, ecx
	je	SHORT $LN97@xmlParseEl
$LN80@xmlParseEl:

; 6407 : 		ret->ocur = XML_ELEMENT_CONTENT_MULT;
; 6408 : 	}
; 6409 : 	NEXT;

	mov	DWORD PTR [ebx+4], 3
$LN97@xmlParseEl:
	push	edi
	call	_xmlNextChar
	add	esp, 4
$LN88@xmlParseEl:

; 6410 :     }
; 6411 :     return(ret);

	pop	esi
	pop	edi
	mov	eax, ebx

; 6412 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseElementChildrenContentDeclPriv ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseCatalogPI
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_catalog$ = 12						; size = 4
_xmlParseCatalogPI PROC					; COMDAT

; 5037 : xmlParseCatalogPI(xmlParserCtxtPtr ctxt, const xmlChar *catalog) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _catalog$[ebp]
	xor	ebx, ebx
$LL2@xmlParseCa:

; 5038 :     xmlChar *URL = NULL;
; 5039 :     const xmlChar *tmp, *base;
; 5040 :     xmlChar marker;
; 5041 : 
; 5042 :     tmp = catalog;
; 5043 :     while (IS_BLANK_CH(*tmp)) tmp++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN12@xmlParseCa
	cmp	al, 9
	jb	SHORT $LN13@xmlParseCa
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN12@xmlParseCa
$LN13@xmlParseCa:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN3@xmlParseCa
$LN12@xmlParseCa:
	inc	esi
	jmp	SHORT $LL2@xmlParseCa
$LN3@xmlParseCa:

; 5044 :     if (xmlStrncmp(tmp, BAD_CAST"catalog", 7))

	push	7
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	esi
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$error$50

; 5045 : 	goto error;
; 5046 :     tmp += 7;

	add	esi, 7
$LL4@xmlParseCa:

; 5047 :     while (IS_BLANK_CH(*tmp)) tmp++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN15@xmlParseCa
	cmp	al, 9
	jb	SHORT $LN16@xmlParseCa
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN15@xmlParseCa
$LN16@xmlParseCa:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN5@xmlParseCa
$LN15@xmlParseCa:
	inc	esi
	jmp	SHORT $LL4@xmlParseCa
$LN5@xmlParseCa:

; 5048 :     if (*tmp != '=') {

	cmp	al, 61					; 0000003dH
	jne	$LN25@xmlParseCa
$LN18@xmlParseCa:

; 5049 : 	return;
; 5050 :     }
; 5051 :     tmp++;
; 5052 :     while (IS_BLANK_CH(*tmp)) tmp++;

	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 32					; 00000020H
	je	SHORT $LN18@xmlParseCa
	cmp	al, 9
	jb	SHORT $LN19@xmlParseCa
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN18@xmlParseCa
$LN19@xmlParseCa:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN18@xmlParseCa

; 5053 :     marker = *tmp;
; 5054 :     if ((marker != '\'') && (marker != '"'))

	cmp	al, 39					; 00000027H
	je	SHORT $LN20@xmlParseCa
	cmp	al, 34					; 00000022H
	jne	SHORT $error$50
$LN20@xmlParseCa:

; 5055 : 	goto error;
; 5056 :     tmp++;
; 5057 :     base = tmp;
; 5058 :     while ((*tmp != 0) && (*tmp != marker)) tmp++;

	mov	cl, BYTE PTR [esi+1]
	inc	esi
	mov	edi, esi
	test	cl, cl
	je	SHORT $error$50
	mov	dl, cl
	npad	6
$LL8@xmlParseCa:
	mov	cl, dl
	cmp	dl, al
	je	SHORT $LN47@xmlParseCa
	mov	cl, BYTE PTR [esi+1]
	inc	esi
	mov	dl, cl
	test	cl, cl
	jne	SHORT $LL8@xmlParseCa
$LN47@xmlParseCa:

; 5059 :     if (*tmp == 0)

	test	cl, cl
	je	SHORT $error$50

; 5060 : 	goto error;
; 5061 :     URL = xmlStrndup(base, tmp - base);

	mov	eax, esi
	sub	eax, edi
	push	eax
	push	edi
	call	_xmlStrndup
	add	esp, 8
	mov	ebx, eax
$LN22@xmlParseCa:

; 5062 :     tmp++;
; 5063 :     while (IS_BLANK_CH(*tmp)) tmp++;

	mov	cl, BYTE PTR [esi+1]
	inc	esi
	cmp	cl, 32					; 00000020H
	je	SHORT $LN22@xmlParseCa
	cmp	cl, 9
	jb	SHORT $LN23@xmlParseCa
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN22@xmlParseCa
$LN23@xmlParseCa:
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN22@xmlParseCa

; 5064 :     if (*tmp != 0)

	test	cl, cl
	jne	SHORT $error$50

; 5065 : 	goto error;
; 5066 : 
; 5067 :     if (URL != NULL) {

	test	ebx, ebx
	je	SHORT $LN25@xmlParseCa

; 5068 : 	ctxt->catalogs = xmlCatalogAddLocal(ctxt->catalogs, URL);

	mov	esi, DWORD PTR _ctxt$[ebp]
	push	ebx
	push	DWORD PTR [esi+284]
	call	_xmlCatalogAddLocal

; 5069 : 	xmlFree(URL);

	push	ebx
	mov	DWORD PTR [esi+284], eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
	pop	edi

; 5079 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$error$50:

; 5070 :     }
; 5071 :     return;
; 5072 : 
; 5073 : error:
; 5074 :     xmlWarningMsg(ctxt, XML_WAR_CATALOG_PI,

	push	0
	push	DWORD PTR _catalog$[ebp]
	push	OFFSET ??_C@_0BN@MALFACIE@Catalog?5PI?5syntax?5error?3?5?$CFs?6@
	push	93					; 0000005dH
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H

; 5075 : 	          "Catalog PI syntax error: %s\n",
; 5076 : 		  catalog, NULL);
; 5077 :     if (URL != NULL)

	test	ebx, ebx
	je	SHORT $LN25@xmlParseCa

; 5078 : 	xmlFree(URL);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN25@xmlParseCa:

; 5079 : }

	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlParseCatalogPI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseCommentComplex
_TEXT	SEGMENT
_inputid$1$ = -28					; size = 4
_count$1$ = -24						; size = 4
_rl$ = -20						; size = 4
_ql$ = -16						; size = 4
_size$1$ = -12						; size = 4
_l$ = -8						; size = 4
_r$1$ = -4						; size = 4
_len$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_size$ = 20						; size = 4
_xmlParseCommentComplex PROC				; COMDAT

; 4681 :                        size_t len, size_t size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	mov	edi, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _count$1$[ebp], eax
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+56]
	mov	DWORD PTR _inputid$1$[ebp], eax
	test	edi, edi
	jne	SHORT $LN178@xmlParseCo

; 4691 :         len = 0;
; 4692 : 	size = XML_PARSER_BUFFER_SIZE;

	xor	eax, eax
	mov	DWORD PTR _size$1$[ebp], 100		; 00000064H

; 4693 : 	buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	push	100					; 00000064H
	mov	DWORD PTR _len$1$[ebp], eax
	call	DWORD PTR _xmlMallocAtomic
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _buf$[ebp], edi

; 4694 : 	if (buf == NULL) {

	test	edi, edi
	jne	SHORT $LN174@xmlParseCo

; 4695 : 	    xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory
	add	esp, 8
	pop	edi

; 4800 :     return;
; 4801 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN178@xmlParseCo:

; 4682 :     int q, ql;
; 4683 :     int r, rl;
; 4684 :     int cur, l;
; 4685 :     size_t count = 0;
; 4686 :     int inputid;
; 4687 : 
; 4688 :     inputid = ctxt->input->id;
; 4689 : 
; 4690 :     if (buf == NULL) {

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$1$[ebp], eax
	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$1$[ebp], eax
$LN174@xmlParseCo:

; 4696 : 	    return;
; 4697 : 	}
; 4698 :     }
; 4699 :     GROW;	/* Assure there's enough input data */

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN15@xmlParseCo
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN15@xmlParseCo
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN15@xmlParseCo:

; 4700 :     q = CUR_CHAR(ql);

	push	ebx
	lea	eax, DWORD PTR _ql$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	mov	ebx, eax
	add	esp, 8

; 4701 :     if (q == 0)

	test	ebx, ebx
	je	$not_terminated$185

; 4702 :         goto not_terminated;
; 4703 :     if (!IS_CHAR(q)) {

	cmp	ebx, 256				; 00000100H
	jge	SHORT $LN167@xmlParseCo
	cmp	ebx, 9
	jl	SHORT $LN47@xmlParseCo
	cmp	ebx, 10					; 0000000aH
	jle	SHORT $LN4@xmlParseCo
$LN47@xmlParseCo:
	cmp	ebx, 13					; 0000000dH
	je	SHORT $LN4@xmlParseCo
	cmp	ebx, 32					; 00000020H
	jge	SHORT $LN4@xmlParseCo

; 4715 :         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,

	push	ebx
	push	OFFSET ??_C@_0CL@FHECENFI@xmlParseComment?3?5invalid?5xmlCha@
	push	9
	push	esi
	call	_xmlFatalErrMsgInt

; 4716 :                           "xmlParseComment: invalid xmlChar value %d\n",
; 4717 : 	                  q);
; 4718 : 	xmlFree (buf);

	push	edi

; 4798 : 			 "Comment not terminated\n", NULL);
; 4799 :     xmlFree(buf);

	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H
	pop	ebx
	pop	edi

; 4800 :     return;
; 4801 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN167@xmlParseCo:

; 4702 :         goto not_terminated;
; 4703 :     if (!IS_CHAR(q)) {

	cmp	ebx, 55295				; 0000d7ffH
	jle	SHORT $LN4@xmlParseCo
	cmp	ebx, 57344				; 0000e000H
	jl	SHORT $LN50@xmlParseCo
	cmp	ebx, 65533				; 0000fffdH
	jle	SHORT $LN4@xmlParseCo
$LN50@xmlParseCo:
	cmp	ebx, 65536				; 00010000H
	jl	$LN62@xmlParseCo
	cmp	ebx, 1114111				; 0010ffffH
	jg	$LN62@xmlParseCo
$LN4@xmlParseCo:

; 4704 :         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
; 4705 :                           "xmlParseComment: invalid xmlChar value %d\n",
; 4706 : 	                  q);
; 4707 : 	xmlFree (buf);
; 4708 : 	return;
; 4709 :     }
; 4710 :     NEXTL(ql);

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN18@xmlParseCo
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN19@xmlParseCo
$LN18@xmlParseCo:
	inc	DWORD PTR [ecx+32]
$LN19@xmlParseCo:
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _ql$[ebp]
	add	DWORD PTR [ecx+16], eax

; 4711 :     r = CUR_CHAR(rl);

	lea	eax, DWORD PTR _rl$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _r$1$[ebp], eax

; 4712 :     if (r == 0)

	test	eax, eax
	je	$not_terminated$185

; 4713 :         goto not_terminated;
; 4714 :     if (!IS_CHAR(r)) {

	cmp	eax, 256				; 00000100H
	jge	SHORT $LN65@xmlParseCo
	cmp	eax, 9
	jl	SHORT $LN57@xmlParseCo
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN7@xmlParseCo
$LN57@xmlParseCo:
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN7@xmlParseCo
	cmp	eax, 32					; 00000020H
	jl	SHORT $LN62@xmlParseCo
$LN7@xmlParseCo:

; 4719 : 	return;
; 4720 :     }
; 4721 :     NEXTL(rl);

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN22@xmlParseCo
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN23@xmlParseCo
$LN65@xmlParseCo:

; 4713 :         goto not_terminated;
; 4714 :     if (!IS_CHAR(r)) {

	cmp	eax, 55295				; 0000d7ffH
	jle	SHORT $LN7@xmlParseCo
	cmp	eax, 57344				; 0000e000H
	jl	SHORT $LN60@xmlParseCo
	cmp	eax, 65533				; 0000fffdH
	jle	SHORT $LN7@xmlParseCo
$LN60@xmlParseCo:
	add	eax, -65536				; ffff0000H
	cmp	eax, 1048575				; 000fffffH
	jbe	SHORT $LN7@xmlParseCo
$LN62@xmlParseCo:

; 4715 :         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,

	push	ebx
	push	OFFSET ??_C@_0CL@FHECENFI@xmlParseComment?3?5invalid?5xmlCha@
	push	9
	push	esi
	call	_xmlFatalErrMsgInt

; 4716 :                           "xmlParseComment: invalid xmlChar value %d\n",
; 4717 : 	                  q);
; 4718 : 	xmlFree (buf);

	push	edi

; 4798 : 			 "Comment not terminated\n", NULL);
; 4799 :     xmlFree(buf);

	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H
	pop	ebx
	pop	edi

; 4800 :     return;
; 4801 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@xmlParseCo:

; 4719 : 	return;
; 4720 :     }
; 4721 :     NEXTL(rl);

	inc	DWORD PTR [ecx+32]
$LN23@xmlParseCo:
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _rl$[ebp]
	add	DWORD PTR [ecx+16], eax

; 4722 :     cur = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	mov	edi, eax
	add	esp, 8

; 4723 :     if (cur == 0)

	test	edi, edi
	je	$not_terminated$185
$LL8@xmlParseCo:

; 4724 :         goto not_terminated;
; 4725 :     while (IS_CHAR(cur) && /* checked */

	cmp	edi, 256				; 00000100H
	jge	SHORT $LN75@xmlParseCo
	cmp	edi, 9
	jl	SHORT $LN67@xmlParseCo
	cmp	edi, 10					; 0000000aH
	jle	SHORT $LN71@xmlParseCo
$LN67@xmlParseCo:
	cmp	edi, 13					; 0000000dH
	je	SHORT $LN71@xmlParseCo
	cmp	edi, 32					; 00000020H
	jge	SHORT $LN71@xmlParseCo
$LN9@xmlParseCo:

; 4775 :     buf[len] = 0;

	mov	ebx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _len$1$[ebp]
	mov	BYTE PTR [ebx+eax], 0

; 4776 :     if (cur == 0) {

	test	edi, edi
	jne	$LN40@xmlParseCo

; 4777 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,

	push	ebx
	push	OFFSET ??_C@_0CD@MHPLKFMN@Comment?5not?5terminated?5?6?$DM?$CB?9?9?$CF?45@
	push	45					; 0000002dH
	push	esi
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 4793 :     }
; 4794 :     xmlFree(buf);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	ebx
	pop	edi

; 4800 :     return;
; 4801 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN75@xmlParseCo:

; 4724 :         goto not_terminated;
; 4725 :     while (IS_CHAR(cur) && /* checked */

	cmp	edi, 55295				; 0000d7ffH
	jle	SHORT $LN71@xmlParseCo
	cmp	edi, 57344				; 0000e000H
	jl	SHORT $LN70@xmlParseCo
	cmp	edi, 65533				; 0000fffdH
	jle	SHORT $LN71@xmlParseCo
$LN70@xmlParseCo:
	lea	eax, DWORD PTR [edi-65536]
	cmp	eax, 1048575				; 000fffffH
	ja	SHORT $LN9@xmlParseCo
$LN71@xmlParseCo:
	cmp	edi, 62					; 0000003eH
	jne	SHORT $LN25@xmlParseCo
	cmp	DWORD PTR _r$1$[ebp], 45		; 0000002dH
	jne	SHORT $LN153@xmlParseCo
	cmp	ebx, 45					; 0000002dH
	je	SHORT $LN9@xmlParseCo

; 4726 :            ((cur != '>') ||
; 4727 : 	    (r != '-') || (q != '-'))) {
; 4728 : 	if ((r == '-') && (q == '-')) {

	jmp	SHORT $LN153@xmlParseCo
$LN25@xmlParseCo:
	cmp	DWORD PTR _r$1$[ebp], 45		; 0000002dH
	jne	SHORT $LN153@xmlParseCo
	cmp	ebx, 45					; 0000002dH
	jne	SHORT $LN153@xmlParseCo

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN175@xmlParseCo
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN153@xmlParseCo
$LN175@xmlParseCo:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CO@IKEFGBAE@Comment?5must?5not?5contain?5?8?9?9?8?5?$CI@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	80					; 00000050H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 80			; 00000050H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN153@xmlParseCo

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN153@xmlParseCo:

; 4729 : 	    xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL);
; 4730 : 	}
; 4731 :         if ((len > XML_MAX_TEXT_LENGTH) &&

	mov	ecx, DWORD PTR _len$1$[ebp]
	cmp	ecx, 10000000				; 00989680H
	jbe	SHORT $LN27@xmlParseCo
	test	DWORD PTR [esi+360], 524288		; 00080000H
	je	$LN156@xmlParseCo
$LN27@xmlParseCo:

; 4737 :         }
; 4738 : 	if (len + 5 >= size) {

	mov	edx, DWORD PTR _size$1$[ebp]
	lea	eax, DWORD PTR [ecx+5]
	cmp	eax, edx
	jb	SHORT $LN179@xmlParseCo

; 4739 : 	    xmlChar *new_buf;
; 4740 :             size_t new_size;
; 4741 : 
; 4742 : 	    new_size = size * 2;

	add	edx, edx

; 4743 : 	    new_buf = (xmlChar *) xmlRealloc(buf, new_size);

	push	edx
	push	DWORD PTR _buf$[ebp]
	mov	DWORD PTR _size$1$[ebp], edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 4744 : 	    if (new_buf == NULL) {

	test	eax, eax
	je	$LN157@xmlParseCo

; 4747 : 		return;
; 4748 : 	    }
; 4749 : 	    buf = new_buf;

	mov	ecx, DWORD PTR _len$1$[ebp]
	mov	DWORD PTR _buf$[ebp], eax
	jmp	SHORT $LN28@xmlParseCo
$LN179@xmlParseCo:

; 4737 :         }
; 4738 : 	if (len + 5 >= size) {

	mov	eax, DWORD PTR _buf$[ebp]
$LN28@xmlParseCo:

; 4750 :             size = new_size;
; 4751 : 	}
; 4752 : 	COPY_BUF(ql,buf,len,q);

	add	eax, ecx
	cmp	DWORD PTR _ql$[ebp], 1
	jne	SHORT $LN30@xmlParseCo
	inc	ecx
	mov	BYTE PTR [eax], bl
	mov	DWORD PTR _len$1$[ebp], ecx
	jmp	SHORT $LN31@xmlParseCo
$LN30@xmlParseCo:
	push	ebx
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	DWORD PTR _len$1$[ebp], eax
$LN31@xmlParseCo:

; 4753 : 	q = r;
; 4754 : 	ql = rl;
; 4755 : 	r = cur;
; 4756 : 	rl = l;
; 4757 : 
; 4758 : 	count++;

	mov	edx, DWORD PTR _count$1$[ebp]
	mov	eax, DWORD PTR _rl$[ebp]
	inc	edx
	mov	ebx, DWORD PTR _r$1$[ebp]
	mov	DWORD PTR _ql$[ebp], eax
	mov	eax, DWORD PTR _l$[ebp]
	mov	DWORD PTR _r$1$[ebp], edi
	mov	DWORD PTR _rl$[ebp], eax
	mov	DWORD PTR _count$1$[ebp], edx

; 4759 : 	if (count > 50) {

	cmp	edx, 50					; 00000032H
	jbe	SHORT $LN12@xmlParseCo

; 4760 : 	    GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN33@xmlParseCo
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN33@xmlParseCo
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN33@xmlParseCo:

; 4761 : 	    count = 0;

	xor	eax, eax

; 4762 :             if (ctxt->instate == XML_PARSER_EOF) {

	cmp	DWORD PTR [esi+172], -1
	mov	DWORD PTR _count$1$[ebp], eax
	je	$LN158@xmlParseCo
$LN12@xmlParseCo:

; 4764 : 		return;
; 4765 :             }
; 4766 : 	}
; 4767 : 	NEXTL(l);

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN35@xmlParseCo
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN36@xmlParseCo
$LN35@xmlParseCo:
	inc	DWORD PTR [ecx+32]
$LN36@xmlParseCo:
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax

; 4768 : 	cur = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	mov	edi, eax
	add	esp, 8

; 4769 : 	if (cur == 0) {

	test	edi, edi
	jne	$LL8@xmlParseCo

; 4770 : 	    SHRINK;

	mov	eax, DWORD PTR [esi+292]
	test	eax, eax
	jne	SHORT $LN39@xmlParseCo
	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN171@xmlParseCo
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN171@xmlParseCo
	push	esi
	call	_xmlSHRINK
	mov	eax, DWORD PTR [esi+292]
	add	esp, 4

; 4771 : 	    GROW;

	test	eax, eax
	jne	SHORT $LN39@xmlParseCo
$LN171@xmlParseCo:
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN39@xmlParseCo
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN39@xmlParseCo:

; 4772 : 	    cur = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	add	esp, 8
	mov	edi, eax

; 4773 : 	}
; 4774 :     }

	jmp	$LL8@xmlParseCo
$LN40@xmlParseCo:

; 4778 : 	                     "Comment not terminated \n<!--%.50s\n", buf);
; 4779 :     } else if (!IS_CHAR(cur)) {

	cmp	edi, 256				; 00000100H
	jge	SHORT $LN85@xmlParseCo
	cmp	edi, 9
	jl	SHORT $LN77@xmlParseCo
	cmp	edi, 10					; 0000000aH
	jle	SHORT $LN42@xmlParseCo
$LN77@xmlParseCo:
	cmp	edi, 13					; 0000000dH
	je	SHORT $LN42@xmlParseCo
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN82@xmlParseCo
$LN42@xmlParseCo:

; 4781 :                           "xmlParseComment: invalid xmlChar value %d\n",
; 4782 : 	                  cur);
; 4783 :     } else {
; 4784 : 	if (inputid != ctxt->input->id) {

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR _inputid$1$[ebp]
	cmp	ecx, DWORD PTR [eax+56]
	je	SHORT $LN44@xmlParseCo

; 4785 : 	    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0DD@BIJIOHJJ@Comment?5doesn?8t?5start?5and?5stop?5@
	push	90					; 0000005aH
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN44@xmlParseCo:

; 4786 : 		           "Comment doesn't start and stop in the same"
; 4787 :                            " entity\n");
; 4788 : 	}
; 4789 :         NEXT;

	push	esi
	call	_xmlNextChar

; 4790 : 	if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&

	mov	eax, DWORD PTR [esi]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN45@xmlParseCo
	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $LN45@xmlParseCo
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN45@xmlParseCo

; 4791 : 	    (!ctxt->disableSAX))
; 4792 : 	    ctxt->sax->comment(ctxt->userData, buf);

	push	ebx
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 8
$LN45@xmlParseCo:

; 4793 :     }
; 4794 :     xmlFree(buf);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	ebx
	pop	edi

; 4800 :     return;
; 4801 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN85@xmlParseCo:

; 4778 : 	                     "Comment not terminated \n<!--%.50s\n", buf);
; 4779 :     } else if (!IS_CHAR(cur)) {

	cmp	edi, 55295				; 0000d7ffH
	jle	SHORT $LN42@xmlParseCo
	cmp	edi, 57344				; 0000e000H
	jl	SHORT $LN80@xmlParseCo
	cmp	edi, 65533				; 0000fffdH
	jle	SHORT $LN42@xmlParseCo
$LN80@xmlParseCo:
	lea	eax, DWORD PTR [edi-65536]
	cmp	eax, 1048575				; 000fffffH
	jbe	SHORT $LN42@xmlParseCo
$LN82@xmlParseCo:

; 4780 :         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,

	push	edi
	push	OFFSET ??_C@_0CL@FHECENFI@xmlParseComment?3?5invalid?5xmlCha@
	push	9
	push	esi
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H

; 4793 :     }
; 4794 :     xmlFree(buf);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	ebx
	pop	edi

; 4800 :     return;
; 4801 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN156@xmlParseCo:

; 4732 :             ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 4733 :             xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,

	push	0
	push	OFFSET ??_C@_0BG@BAOBDEOI@Comment?5too?5big?5found@

; 4734 :                          "Comment too big found", NULL);
; 4735 :             xmlFree (buf);
; 4736 :             return;

	jmp	SHORT $LN183@xmlParseCo
$LN157@xmlParseCo:

; 4745 : 		xmlFree (buf);

	push	DWORD PTR _buf$[ebp]
	call	DWORD PTR _xmlFree

; 4746 : 		xmlErrMemory(ctxt, NULL);

	push	0
	push	esi
	call	_xmlErrMemory
	add	esp, 12					; 0000000cH
	pop	ebx
	pop	edi

; 4800 :     return;
; 4801 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN158@xmlParseCo:

; 4763 : 		xmlFree(buf);

	push	DWORD PTR _buf$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	ebx
	pop	edi

; 4800 :     return;
; 4801 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$not_terminated$185:

; 4795 :     return;
; 4796 : not_terminated:
; 4797 :     xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,

	push	0
	push	OFFSET ??_C@_0BI@ELKFFAAB@Comment?5not?5terminated?6@
$LN183@xmlParseCo:
	push	45					; 0000002dH
	push	esi
	call	_xmlFatalErrMsgStr

; 4798 : 			 "Comment not terminated\n", NULL);
; 4799 :     xmlFree(buf);

	push	DWORD PTR _buf$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H
	pop	ebx
	pop	edi

; 4800 :     return;
; 4801 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseCommentComplex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseCharDataComplex
_TEXT	SEGMENT
_buf$ = -316						; size = 305
_count$1$ = -8						; size = 4
_l$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_cdata$ = 12						; size = 4
_xmlParseCharDataComplex PROC				; COMDAT

; 4508 : xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int cdata) {

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	mov	DWORD PTR _count$1$[ebp], eax
	xor	edi, edi
	mov	eax, DWORD PTR [esi+292]
	test	eax, eax
	jne	SHORT $LN11@xmlParseCh

; 4509 :     xmlChar buf[XML_PARSER_BIG_BUFFER_SIZE + 5];
; 4510 :     int nbchar = 0;
; 4511 :     int cur, l;
; 4512 :     int count = 0;
; 4513 : 
; 4514 :     SHRINK;

	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN137@xmlParseCh
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN137@xmlParseCh
	push	esi
	call	_xmlSHRINK
	mov	eax, DWORD PTR [esi+292]
	add	esp, 4

; 4515 :     GROW;

	test	eax, eax
	jne	SHORT $LN11@xmlParseCh
$LN137@xmlParseCh:
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN11@xmlParseCh
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN11@xmlParseCh:

; 4516 :     cur = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	mov	ebx, eax
	add	esp, 8

; 4517 :     while ((cur != '<') && /* checked */
; 4518 :            (cur != '&') &&

	cmp	ebx, 60					; 0000003cH
	je	$LN36@xmlParseCh
	npad	3
$LL2@xmlParseCh:
	cmp	ebx, 38					; 00000026H
	je	$LN3@xmlParseCh
	cmp	ebx, 256				; 00000100H
	jge	SHORT $LN138@xmlParseCh
	cmp	ebx, 9
	jl	SHORT $LN41@xmlParseCh
	cmp	ebx, 10					; 0000000aH
	jle	SHORT $LN45@xmlParseCh
$LN41@xmlParseCh:
	cmp	ebx, 13					; 0000000dH
	je	SHORT $LN45@xmlParseCh
	cmp	ebx, 32					; 00000020H
	jl	$LN3@xmlParseCh
	jmp	SHORT $LN45@xmlParseCh
$LN138@xmlParseCh:
	cmp	ebx, 55295				; 0000d7ffH
	jle	SHORT $LN45@xmlParseCh
	cmp	ebx, 57344				; 0000e000H
	jl	SHORT $LN44@xmlParseCh
	cmp	ebx, 65533				; 0000fffdH
	jle	SHORT $LN45@xmlParseCh
$LN44@xmlParseCh:
	lea	eax, DWORD PTR [ebx-65536]
	cmp	eax, 1048575				; 000fffffH
	ja	$LN3@xmlParseCh
$LN45@xmlParseCh:

; 4519 : 	   (IS_CHAR(cur))) /* test also done in xmlCurrentChar() */ {
; 4520 : 	if ((cur == ']') && (NXT(1) == ']') &&

	cmp	ebx, 93					; 0000005dH
	jne	SHORT $LN127@xmlParseCh
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax+1], bl
	jne	SHORT $LN127@xmlParseCh
	cmp	BYTE PTR [eax+2], 62			; 0000003eH
	jne	SHORT $LN127@xmlParseCh

; 4521 : 	    (NXT(2) == '>')) {
; 4522 : 	    if (cdata) break;

	cmp	DWORD PTR _cdata$[ebp], 0
	jne	$LN3@xmlParseCh

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN144@xmlParseCh
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN127@xmlParseCh
$LN144@xmlParseCh:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CG@PLPMIKHI@Sequence?5?8?$FN?$FN?$DO?8?5not?5allowed?5in?5c@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	62					; 0000003eH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 62			; 0000003eH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN127@xmlParseCh

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN127@xmlParseCh:

; 4523 : 	    else {
; 4524 : 		xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
; 4525 : 	    }
; 4526 : 	}
; 4527 : 	COPY_BUF(l,buf,nbchar,cur);

	lea	eax, DWORD PTR _buf$[ebp]
	add	eax, edi
	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN15@xmlParseCh
	mov	BYTE PTR [eax], bl
	inc	edi
	jmp	SHORT $LN16@xmlParseCh
$LN15@xmlParseCh:
	push	ebx
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	edi, eax
$LN16@xmlParseCh:

; 4528 : 	if (nbchar >= XML_PARSER_BIG_BUFFER_SIZE) {

	cmp	edi, 300				; 0000012cH
	jl	$LN145@xmlParseCh

; 4529 : 	    buf[nbchar] = 0;
; 4530 : 
; 4531 : 	    /*
; 4532 : 	     * OK the segment is to be consumed as chars.
; 4533 : 	     */
; 4534 : 	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {

	cmp	DWORD PTR [esi], 0
	mov	BYTE PTR _buf$[ebp+edi], 0
	je	SHORT $LN23@xmlParseCh
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN23@xmlParseCh

; 4535 : 		if (areBlanks(ctxt, buf, nbchar, 0)) {

	push	0
	push	edi
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	esi
	call	_areBlanks
	mov	ecx, DWORD PTR [esi]
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN19@xmlParseCh

; 4536 : 		    if (ctxt->sax->ignorableWhitespace != NULL)

	mov	eax, DWORD PTR [ecx+72]
	test	eax, eax
	je	SHORT $LN23@xmlParseCh

; 4537 : 			ctxt->sax->ignorableWhitespace(ctxt->userData,

	push	edi
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 12					; 0000000cH

; 4538 : 			                               buf, nbchar);
; 4539 : 		} else {

	jmp	SHORT $LN23@xmlParseCh
$LN19@xmlParseCh:

; 4540 : 		    if (ctxt->sax->characters != NULL)

	mov	eax, DWORD PTR [ecx+68]
	test	eax, eax
	je	SHORT $LN22@xmlParseCh

; 4541 : 			ctxt->sax->characters(ctxt->userData, buf, nbchar);

	push	edi
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	push	DWORD PTR [esi+4]
	call	eax
	mov	ecx, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
$LN22@xmlParseCh:

; 4542 : 		    if ((ctxt->sax->characters !=
; 4543 : 		         ctxt->sax->ignorableWhitespace) &&

	mov	eax, DWORD PTR [ecx+68]
	cmp	eax, DWORD PTR [ecx+72]
	je	SHORT $LN23@xmlParseCh
	mov	eax, DWORD PTR [esi+232]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN23@xmlParseCh

; 4544 : 			(*ctxt->space == -1))
; 4545 : 			*ctxt->space = -2;

	mov	DWORD PTR [eax], -2			; fffffffeH
$LN23@xmlParseCh:

; 4546 : 		}
; 4547 : 	    }
; 4548 : 	    nbchar = 0;

	xor	edi, edi

; 4549 :             /* something really bad happened in the SAX callback */
; 4550 :             if (ctxt->instate != XML_PARSER_CONTENT)

	cmp	DWORD PTR [esi+172], 7
	jne	$LN8@xmlParseCh
$LN145@xmlParseCh:

; 4551 :                 return;
; 4552 : 	}
; 4553 : 	count++;

	mov	edx, DWORD PTR _count$1$[ebp]
	inc	edx
	mov	DWORD PTR _count$1$[ebp], edx

; 4554 : 	if (count > 50) {

	cmp	edx, 50					; 00000032H
	jle	SHORT $LN6@xmlParseCh

; 4555 : 	    GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN26@xmlParseCh
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN26@xmlParseCh
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN26@xmlParseCh:

; 4556 : 	    count = 0;

	xor	eax, eax

; 4557 :             if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	mov	DWORD PTR _count$1$[ebp], eax
	je	$LN8@xmlParseCh
$LN6@xmlParseCh:

; 4558 : 		return;
; 4559 : 	}
; 4560 : 	NEXTL(l);

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN28@xmlParseCh
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN29@xmlParseCh
$LN28@xmlParseCh:
	inc	DWORD PTR [ecx+32]
$LN29@xmlParseCh:
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax

; 4561 : 	cur = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	mov	ebx, eax
	add	esp, 8
	cmp	ebx, 60					; 0000003cH
	jne	$LL2@xmlParseCh
$LN3@xmlParseCh:

; 4562 :     }
; 4563 :     if (nbchar != 0) {

	test	edi, edi
	je	SHORT $LN36@xmlParseCh

; 4564 :         buf[nbchar] = 0;
; 4565 : 	/*
; 4566 : 	 * OK the segment is to be consumed as chars.
; 4567 : 	 */
; 4568 : 	if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {

	cmp	DWORD PTR [esi], 0
	mov	BYTE PTR _buf$[ebp+edi], 0
	je	SHORT $LN36@xmlParseCh
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN36@xmlParseCh

; 4569 : 	    if (areBlanks(ctxt, buf, nbchar, 0)) {

	push	0
	push	edi
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	esi
	call	_areBlanks
	mov	ecx, DWORD PTR [esi]
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN32@xmlParseCh

; 4570 : 		if (ctxt->sax->ignorableWhitespace != NULL)

	mov	eax, DWORD PTR [ecx+72]
	test	eax, eax
	je	SHORT $LN36@xmlParseCh

; 4571 : 		    ctxt->sax->ignorableWhitespace(ctxt->userData, buf, nbchar);

	push	edi
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 12					; 0000000cH

; 4572 : 	    } else {

	jmp	SHORT $LN36@xmlParseCh
$LN32@xmlParseCh:

; 4573 : 		if (ctxt->sax->characters != NULL)

	mov	eax, DWORD PTR [ecx+68]
	test	eax, eax
	je	SHORT $LN35@xmlParseCh

; 4574 : 		    ctxt->sax->characters(ctxt->userData, buf, nbchar);

	push	edi
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	push	DWORD PTR [esi+4]
	call	eax
	mov	ecx, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
$LN35@xmlParseCh:

; 4575 : 		if ((ctxt->sax->characters != ctxt->sax->ignorableWhitespace) &&

	mov	eax, DWORD PTR [ecx+68]
	cmp	eax, DWORD PTR [ecx+72]
	je	SHORT $LN36@xmlParseCh
	mov	eax, DWORD PTR [esi+232]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN36@xmlParseCh

; 4576 : 		    (*ctxt->space == -1))
; 4577 : 		    *ctxt->space = -2;

	mov	DWORD PTR [eax], -2			; fffffffeH
$LN36@xmlParseCh:

; 4578 : 	    }
; 4579 : 	}
; 4580 :     }
; 4581 :     if ((cur != 0) && (!IS_CHAR(cur))) {

	test	ebx, ebx
	je	$LN8@xmlParseCh
	cmp	ebx, 256				; 00000100H
	jge	SHORT $LN140@xmlParseCh
	cmp	ebx, 9
	jl	SHORT $LN51@xmlParseCh
	cmp	ebx, 10					; 0000000aH
	jle	SHORT $LN8@xmlParseCh
$LN51@xmlParseCh:
	cmp	ebx, 13					; 0000000dH
	je	SHORT $LN8@xmlParseCh
	cmp	ebx, 32					; 00000020H
	jge	SHORT $LN8@xmlParseCh
	jmp	SHORT $LN56@xmlParseCh
$LN140@xmlParseCh:
	cmp	ebx, 55295				; 0000d7ffH
	jle	SHORT $LN8@xmlParseCh
	cmp	ebx, 57344				; 0000e000H
	jl	SHORT $LN54@xmlParseCh
	cmp	ebx, 65533				; 0000fffdH
	jle	SHORT $LN8@xmlParseCh
$LN54@xmlParseCh:
	cmp	ebx, 65536				; 00010000H
	jl	SHORT $LN56@xmlParseCh
	cmp	ebx, 1114111				; 0010ffffH
	jle	SHORT $LN8@xmlParseCh
$LN56@xmlParseCh:

; 4582 : 	/* Generate the error and skip the offending character */
; 4583 :         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,

	push	ebx
	push	OFFSET ??_C@_0BO@IODKMKKF@PCDATA?5invalid?5Char?5value?5?$CFd?6@
	push	9
	push	esi
	call	_xmlFatalErrMsgInt

; 4584 :                           "PCDATA invalid Char value %d\n",
; 4585 : 	                  cur);
; 4586 : 	NEXTL(l);

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN38@xmlParseCh
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	pop	edi
	mov	DWORD PTR [eax+32], 1
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _l$[ebp]

; 4587 :     }
; 4588 : }

	pop	esi
	pop	ebx
	add	DWORD PTR [ecx+16], eax
	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@xmlParseCh:

; 4584 :                           "PCDATA invalid Char value %d\n",
; 4585 : 	                  cur);
; 4586 : 	NEXTL(l);

	inc	DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax
$LN8@xmlParseCh:

; 4587 :     }
; 4588 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseCharDataComplex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseAttValueComplex
_TEXT	SEGMENT
_new_size$1$ = -36					; size = 4
_new_size$1$ = -36					; size = 4
_cur$1$ = -36						; size = 4
tv2034 = -32						; size = 4
tv2061 = -28						; size = 4
_i$1$ = -28						; size = 4
_new_size$1$ = -28					; size = 4
_new_size$1$ = -28					; size = 4
_new_size$1$ = -28					; size = 4
_new_size$1$ = -28					; size = 4
_current$1$ = -28					; size = 4
_new_size$1$ = -24					; size = 4
tv2048 = -24						; size = 4
_ent$1$ = -24						; size = 4
_val$1$ = -24						; size = 4
_l$ = -20						; size = 4
_in_space$1$ = -16					; size = 4
_rep$1$ = -12						; size = 4
_buf$1$ = -8						; size = 4
_limit$1$ = -1						; size = 1
_ctxt$ = 8						; size = 4
_attlen$ = 12						; size = 4
_normalize$ = 16					; size = 4
_xmlParseAttValueComplex PROC				; COMDAT

; 3849 : xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	mov	DWORD PTR _rep$1$[ebp], eax
	xor	esi, esi
	mov	DWORD PTR _in_space$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+36]
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 34					; 00000022H
	jne	SHORT $LN18@xmlParseAt

; 3850 :     xmlChar limit = 0;
; 3851 :     xmlChar *buf = NULL;
; 3852 :     xmlChar *rep = NULL;
; 3853 :     size_t len = 0;
; 3854 :     size_t buf_size = 0;
; 3855 :     int c, l, in_space = 0;
; 3856 :     xmlChar *current = NULL;
; 3857 :     xmlEntityPtr ent;
; 3858 : 
; 3859 :     if (NXT(0) == '"') {
; 3860 : 	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
; 3861 : 	limit = '"';
; 3862 :         NEXT;

	mov	BYTE PTR _limit$1$[ebp], al
	jmp	SHORT $LN21@xmlParseAt
$LN18@xmlParseAt:

; 3863 :     } else if (NXT(0) == '\'') {

	cmp	al, 39					; 00000027H
	jne	$LN20@xmlParseAt

; 3864 : 	limit = '\'';

	mov	BYTE PTR _limit$1$[ebp], al
$LN21@xmlParseAt:

; 3865 : 	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
; 3866 :         NEXT;
; 3867 :     } else {
; 3868 : 	xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
; 3869 : 	return(NULL);
; 3870 :     }
; 3871 : 
; 3872 :     /*
; 3873 :      * allocate a translation buffer.
; 3874 :      */
; 3875 :     buf_size = XML_PARSER_BUFFER_SIZE;

	push	ebx
	mov	DWORD PTR [ebx+172], 12			; 0000000cH
	call	_xmlNextChar
	mov	ebx, 100				; 00000064H

; 3876 :     buf = (xmlChar *) xmlMallocAtomic(buf_size);

	push	ebx
	call	DWORD PTR _xmlMallocAtomic
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR _buf$1$[ebp], edi

; 3877 :     if (buf == NULL) goto mem_error;

	test	edi, edi
	je	$mem_error$322

; 3878 : 
; 3879 :     /*
; 3880 :      * OK loop until we reach one of the ending char or a size limit.
; 3881 :      */
; 3882 :     c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	DWORD PTR _ctxt$[ebp]
$LN319@xmlParseAt:

; 3883 :     while (((NXT(0) != limit) && /* checked */
; 3884 :             (IS_CHAR(c)) && (c != '<')) &&

	call	_xmlCurrentChar
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	ecx, eax
	add	esp, 8
	mov	eax, DWORD PTR [edx+36]
	mov	dl, BYTE PTR _limit$1$[ebp]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], dl
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _normalize$[ebp]
	je	SHORT $LN3@xmlParseAt
	cmp	ecx, 256				; 00000100H
	jge	$LN306@xmlParseAt
	cmp	ecx, 9
	jl	SHORT $LN105@xmlParseAt
	cmp	ecx, 10					; 0000000aH
	jle	$LN109@xmlParseAt
$LN105@xmlParseAt:
	cmp	ecx, 13					; 0000000dH
	je	$LN109@xmlParseAt
	cmp	ecx, 32					; 00000020H
	jge	$LN109@xmlParseAt
$LN3@xmlParseAt:

; 4041 :     }
; 4042 :     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [edx+172], -1
	je	$error$323

; 4043 :         goto error;
; 4044 : 
; 4045 :     if ((in_space) && (normalize)) {

	cmp	DWORD PTR _in_space$1$[ebp], 0
	je	SHORT $LN313@xmlParseAt
	test	eax, eax
	je	SHORT $LN313@xmlParseAt

; 4046 :         while ((len > 0) && (buf[len - 1] == 0x20)) len--;

	test	esi, esi
	je	SHORT $LN313@xmlParseAt
$LL16@xmlParseAt:
	cmp	BYTE PTR [esi+edi-1], 32		; 00000020H
	jne	SHORT $LN313@xmlParseAt
	sub	esi, 1
	jne	SHORT $LL16@xmlParseAt
$LN313@xmlParseAt:

; 4047 :     }
; 4048 :     buf[len] = 0;

	mov	BYTE PTR [esi+edi], 0

; 4049 :     if (RAW == '<') {

	mov	eax, DWORD PTR [edx+36]
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 60					; 0000003cH
	jne	$LN94@xmlParseAt

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edx+212], 0
	je	SHORT $LN196@xmlParseAt
	cmp	DWORD PTR [edx+172], -1
	je	$LN97@xmlParseAt
$LN196@xmlParseAt:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CP@FNIFNHDI@Unescaped?5?8?$DM?8?5not?5allowed?5in?5at@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	38					; 00000026H
	push	1
	push	0
	push	edx
	push	0
	push	0
	push	0
	mov	DWORD PTR [edx+84], 38			; 00000026H
	call	___xmlRaiseError

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	add	esp, 68					; 00000044H

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [edx+288], 0
	mov	DWORD PTR [edx+12], 0
	jne	$LN97@xmlParseAt

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [edx+212], 1

; 556  :     }
; 557  : }

	jmp	$LN97@xmlParseAt
$LN306@xmlParseAt:

; 3883 :     while (((NXT(0) != limit) && /* checked */
; 3884 :             (IS_CHAR(c)) && (c != '<')) &&

	cmp	ecx, 55295				; 0000d7ffH
	jle	SHORT $LN109@xmlParseAt
	cmp	ecx, 57344				; 0000e000H
	jl	SHORT $LN108@xmlParseAt
	cmp	ecx, 65533				; 0000fffdH
	jle	SHORT $LN109@xmlParseAt
$LN108@xmlParseAt:
	cmp	ecx, 65536				; 00010000H
	jl	$LN3@xmlParseAt
	cmp	ecx, 1114111				; 0010ffffH
	jg	$LN3@xmlParseAt
$LN109@xmlParseAt:
	cmp	ecx, 60					; 0000003cH
	je	$LN3@xmlParseAt
	cmp	DWORD PTR [edx+172], -1
	je	$error$323

; 3885 :             (ctxt->instate != XML_PARSER_EOF)) {
; 3886 :         /*
; 3887 :          * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE
; 3888 :          * special option is given
; 3889 :          */
; 3890 :         if ((len > XML_MAX_TEXT_LENGTH) &&

	cmp	esi, 10000000				; 00989680H
	jbe	SHORT $LN23@xmlParseAt
	test	DWORD PTR [edx+360], 524288		; 00080000H
	je	$LN273@xmlParseAt
$LN23@xmlParseAt:

; 3891 :             ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3892 :             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
; 3893 :                            "AttValue length too long\n");
; 3894 :             goto mem_error;
; 3895 :         }
; 3896 : 	if (c == 0) break;

	test	ecx, ecx
	je	$LN3@xmlParseAt

; 3897 : 	if (c == '&') {

	cmp	ecx, 38					; 00000026H
	jne	$LN25@xmlParseAt

; 3898 : 	    in_space = 0;
; 3899 : 	    if (NXT(1) == '#') {

	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _in_space$1$[ebp], 0
	push	edx
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax+1], 35			; 00000023H
	jne	$LN27@xmlParseAt

; 3900 : 		int val = xmlParseCharRef(ctxt);

	call	_xmlParseCharRef
	add	esp, 4
	mov	DWORD PTR _val$1$[ebp], eax

; 3901 : 
; 3902 : 		if (val == '&') {

	cmp	eax, 38					; 00000026H
	jne	$LN29@xmlParseAt

; 3903 : 		    if (ctxt->replaceEntities) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	lea	ecx, DWORD PTR [esi+10]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN31@xmlParseAt

; 3904 : 			if (len + 10 > buf_size) {

	cmp	ecx, ebx
	jbe	SHORT $LN33@xmlParseAt

; 3905 : 			    growBuffer(buf, 10);

	lea	eax, DWORD PTR [ebx*2+10]
	mov	DWORD PTR _new_size$1$[ebp], eax
	cmp	eax, ebx
	jb	$mem_error$322
	push	eax
	push	edi
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	$mem_error$322
	mov	ebx, DWORD PTR _new_size$1$[ebp]
	mov	edi, eax
	mov	DWORD PTR _buf$1$[ebp], edi
$LN33@xmlParseAt:

; 3906 : 			}
; 3907 : 			buf[len++] = '&';

	mov	BYTE PTR [esi+edi], 38			; 00000026H

; 3921 : 		    }

	inc	esi
	jmp	$LN314@xmlParseAt
$LN31@xmlParseAt:

; 3908 : 		    } else {
; 3909 : 			/*
; 3910 : 			 * The reparsing will be done in xmlStringGetNodeList()
; 3911 : 			 * called by the attribute() function in SAX.c
; 3912 : 			 */
; 3913 : 			if (len + 10 > buf_size) {

	cmp	ecx, ebx
	jbe	SHORT $LN36@xmlParseAt

; 3914 : 			    growBuffer(buf, 10);

	lea	eax, DWORD PTR [ebx*2+10]
	mov	DWORD PTR _new_size$1$[ebp], eax
	cmp	eax, ebx
	jb	$mem_error$322
	push	eax
	push	edi
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	$mem_error$322
	mov	ebx, DWORD PTR _new_size$1$[ebp]
	mov	edi, eax
	mov	DWORD PTR _buf$1$[ebp], edi
$LN36@xmlParseAt:

; 3915 : 			}
; 3916 : 			buf[len++] = '&';

	mov	DWORD PTR [esi+edi], 942875430		; 38332326H

; 3917 : 			buf[len++] = '#';
; 3918 : 			buf[len++] = '3';
; 3919 : 			buf[len++] = '8';

	add	esi, 4
$LN9@xmlParseAt:

; 3920 : 			buf[len++] = ';';

	mov	BYTE PTR [esi+edi], 59			; 0000003bH

; 3921 : 		    }

	inc	esi
	jmp	$LN314@xmlParseAt
$LN29@xmlParseAt:

; 3922 : 		} else if (val != 0) {

	test	eax, eax
	je	$LN314@xmlParseAt

; 3923 : 		    if (len + 10 > buf_size) {

	lea	eax, DWORD PTR [esi+10]
	cmp	eax, ebx
	jbe	SHORT $LN40@xmlParseAt

; 3924 : 			growBuffer(buf, 10);

	lea	eax, DWORD PTR [ebx*2+10]
	mov	DWORD PTR _new_size$1$[ebp], eax
	cmp	eax, ebx
	jb	$mem_error$322
	push	eax
	push	edi
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	$mem_error$322
	mov	ebx, DWORD PTR _new_size$1$[ebp]
	mov	edi, eax
	mov	DWORD PTR _buf$1$[ebp], edi
$LN40@xmlParseAt:

; 3925 : 		    }
; 3926 : 		    len += xmlCopyChar(0, &buf[len], val);

	push	DWORD PTR _val$1$[ebp]
	lea	eax, DWORD PTR [esi+edi]
	push	eax
	push	0
	call	_xmlCopyChar
	add	esp, 12					; 0000000cH
	add	esi, eax

; 3927 : 		}
; 3928 : 	    } else {

	jmp	$LN314@xmlParseAt
$LN27@xmlParseAt:

; 3929 : 		ent = xmlParseEntityRef(ctxt);

	call	_xmlParseEntityRef

; 3930 : 		ctxt->nbentities++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	add	esp, 4
	mov	DWORD PTR _ent$1$[ebp], ecx
	mov	eax, DWORD PTR [eax+440]
	inc	eax
	mov	DWORD PTR tv2061[ebp], eax
	mov	DWORD PTR [edx+440], eax

; 3931 : 		if (ent != NULL)

	test	ecx, ecx
	je	$LN14@xmlParseAt

; 3932 : 		    ctxt->nbentities += ent->owner;

	mov	eax, DWORD PTR [ecx+68]
	add	eax, DWORD PTR tv2061[ebp]
	mov	DWORD PTR [edx+440], eax

; 3933 : 		if ((ent != NULL) &&

	cmp	DWORD PTR [ecx+48], 6
	jne	SHORT $LN299@xmlParseAt

; 3934 : 		    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
; 3935 : 		    if (len + 10 > buf_size) {

	lea	eax, DWORD PTR [esi+10]
	cmp	eax, ebx
	jbe	SHORT $LN46@xmlParseAt

; 3936 : 			growBuffer(buf, 10);

	lea	eax, DWORD PTR [ebx*2+10]
	mov	DWORD PTR _new_size$1$[ebp], eax
	cmp	eax, ebx
	jb	$mem_error$322
	push	eax
	push	edi
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	$mem_error$322
	mov	ebx, DWORD PTR _new_size$1$[ebp]
	mov	edi, eax
	mov	ecx, DWORD PTR _ent$1$[ebp]
	mov	DWORD PTR _buf$1$[ebp], edi
$LN46@xmlParseAt:

; 3937 : 		    }
; 3938 : 		    if ((ctxt->replaceEntities == 0) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN312@xmlParseAt
	mov	eax, DWORD PTR [ecx+40]
	cmp	BYTE PTR [eax], 38			; 00000026H
	jne	SHORT $LN312@xmlParseAt

; 3939 : 		        (ent->content[0] == '&')) {
; 3940 : 			buf[len++] = '&';

	mov	DWORD PTR [esi+edi], 942875430		; 38332326H

; 3941 : 			buf[len++] = '#';
; 3942 : 			buf[len++] = '3';
; 3943 : 			buf[len++] = '8';

	add	esi, 4

; 3944 : 			buf[len++] = ';';

	mov	BYTE PTR [esi+edi], 59			; 0000003bH

; 3947 : 		    }

	inc	esi
	jmp	$LN314@xmlParseAt
$LN312@xmlParseAt:

; 3945 : 		    } else {
; 3946 : 			buf[len++] = ent->content[0];

	mov	eax, DWORD PTR [ecx+40]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [esi+edi], al

; 3947 : 		    }

	inc	esi
	jmp	$LN314@xmlParseAt
$LN299@xmlParseAt:

; 3948 : 		} else if ((ent != NULL) &&

	mov	eax, edx
	cmp	DWORD PTR [eax+16], 0
	je	$LN51@xmlParseAt

; 3949 : 		           (ctxt->replaceEntities != 0)) {
; 3950 : 		    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {
; 3951 : 			++ctxt->depth;

	inc	DWORD PTR [eax+248]

; 3952 : 			rep = xmlStringDecodeEntities(ctxt, ent->content,

	push	0
	push	0
	push	0
	push	1
	push	DWORD PTR [ecx+40]
	push	eax
	call	_xmlStringDecodeEntities

; 3953 : 						      XML_SUBSTITUTE_REF,
; 3954 : 						      0, 0, 0);
; 3955 : 			--ctxt->depth;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	ecx, eax
	add	esp, 24					; 00000018H
	mov	DWORD PTR _rep$1$[ebp], ecx
	dec	DWORD PTR [edx+248]

; 3956 : 			if (rep != NULL) {

	test	ecx, ecx
	je	$LN14@xmlParseAt

; 3957 : 			    current = rep;
; 3958 : 			    while (*current != 0) { /* non input consuming */

	mov	cl, BYTE PTR [ecx]
	test	cl, cl
	je	SHORT $LN5@xmlParseAt
	npad	4
$LL4@xmlParseAt:

; 3959 :                                 if ((*current == 0xD) || (*current == 0xA) ||

	cmp	cl, 13					; 0000000dH
	je	SHORT $LN58@xmlParseAt
	cmp	cl, 10					; 0000000aH
	je	SHORT $LN58@xmlParseAt
	cmp	cl, 9
	jne	SHORT $LN57@xmlParseAt
$LN58@xmlParseAt:

; 3960 :                                     (*current == 0x9)) {
; 3961 :                                     buf[len++] = 0x20;
; 3962 :                                     current++;

	mov	cl, 32					; 00000020H
$LN57@xmlParseAt:

; 3963 :                                 } else
; 3964 :                                     buf[len++] = *current++;
; 3965 : 				if (len + 10 > buf_size) {

	inc	eax
	mov	BYTE PTR [esi+edi], cl
	mov	DWORD PTR _current$1$[ebp], eax
	lea	eax, DWORD PTR [esi+1]
	mov	DWORD PTR tv2048[ebp], eax
	add	eax, 10					; 0000000aH
	cmp	eax, ebx
	jbe	SHORT $LN59@xmlParseAt

; 3966 : 				    growBuffer(buf, 10);

	lea	esi, DWORD PTR [ebx*2+10]
	cmp	esi, ebx
	jb	$mem_error$322
	push	esi
	push	edi
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	$mem_error$322
	mov	edi, eax
	mov	ebx, esi
	mov	DWORD PTR _buf$1$[ebp], edi
$LN59@xmlParseAt:

; 3957 : 			    current = rep;
; 3958 : 			    while (*current != 0) { /* non input consuming */

	mov	eax, DWORD PTR _current$1$[ebp]
	mov	esi, DWORD PTR tv2048[ebp]
	mov	cl, BYTE PTR [eax]
	test	cl, cl
	jne	SHORT $LL4@xmlParseAt
$LN5@xmlParseAt:

; 3967 : 				}
; 3968 : 			    }
; 3969 : 			    xmlFree(rep);

	mov	eax, DWORD PTR _rep$1$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3970 : 			    rep = NULL;

	mov	DWORD PTR _rep$1$[ebp], 0

; 3971 : 			}
; 3972 : 		    } else {
; 3973 : 			if (len + 10 > buf_size) {
; 3974 : 			    growBuffer(buf, 10);
; 3975 : 			}
; 3976 : 			if (ent->content != NULL)
; 3977 : 			    buf[len++] = ent->content[0];
; 3978 : 		    }

	jmp	$LN314@xmlParseAt
$LN51@xmlParseAt:

; 3979 : 		} else if (ent != NULL) {
; 3980 : 		    int i = xmlStrlen(ent->name);

	push	DWORD PTR [ecx+8]
	call	_xmlStrlen

; 3981 : 		    const xmlChar *cur = ent->name;

	mov	edx, DWORD PTR _ent$1$[ebp]
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _i$1$[ebp], ecx

; 3982 : 
; 3983 : 		    /*
; 3984 : 		     * This may look absurd but is needed to detect
; 3985 : 		     * entities problems
; 3986 : 		     */
; 3987 : 		    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
; 3988 : 			(ent->content != NULL) && (ent->checked == 0)) {

	cmp	DWORD PTR [edx+48], 6
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _cur$1$[ebp], eax
	je	$LN69@xmlParseAt
	cmp	DWORD PTR [edx+40], 0
	je	$LN69@xmlParseAt
	cmp	DWORD PTR [edx+72], 0
	jne	$LN69@xmlParseAt

; 3989 : 			unsigned long oldnbent = ctxt->nbentities;

	mov	eax, DWORD PTR _ctxt$[ebp]

; 3990 : 
; 3991 : 			++ctxt->depth;
; 3992 : 			rep = xmlStringDecodeEntities(ctxt, ent->content,

	push	0
	push	0
	push	0
	inc	DWORD PTR [eax+248]
	mov	edi, DWORD PTR [eax+440]
	push	1
	push	DWORD PTR [edx+40]
	push	eax
	call	_xmlStringDecodeEntities
	mov	edx, eax
	add	esp, 24					; 00000018H

; 3993 : 						  XML_SUBSTITUTE_REF, 0, 0, 0);
; 3994 : 			--ctxt->depth;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _rep$1$[ebp], edx
	dec	DWORD PTR [eax+248]

; 3995 : 
; 3996 : 			ent->checked = (ctxt->nbentities - oldnbent + 1) * 2;

	mov	eax, DWORD PTR [eax+440]
	sub	eax, edi
	mov	edi, DWORD PTR _ent$1$[ebp]
	lea	eax, DWORD PTR [eax*2+2]
	mov	DWORD PTR [edi+72], eax

; 3997 : 			if (rep != NULL) {

	test	edx, edx
	je	SHORT $LN68@xmlParseAt

; 3998 : 			    if (xmlStrchr(rep, '<'))

	push	60					; 0000003cH
	push	edx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN70@xmlParseAt

; 3999 : 			        ent->checked |= 1;

	or	DWORD PTR [edi+72], 1
$LN70@xmlParseAt:

; 4000 : 			    xmlFree(rep);

	mov	eax, DWORD PTR _rep$1$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 4001 : 			    rep = NULL;

	mov	DWORD PTR _rep$1$[ebp], 0

; 4002 : 			} else {

	jmp	SHORT $LN317@xmlParseAt
$LN68@xmlParseAt:

; 4003 :                             ent->content[0] = 0;

	mov	eax, DWORD PTR [edi+40]
	mov	BYTE PTR [eax], 0
$LN317@xmlParseAt:

; 4004 :                         }
; 4005 : 		    }
; 4006 : 
; 4007 : 		    /*
; 4008 : 		     * Just output the reference
; 4009 : 		     */
; 4010 : 		    buf[len++] = '&';

	mov	ecx, DWORD PTR _i$1$[ebp]
	mov	edi, DWORD PTR _buf$1$[ebp]
$LN69@xmlParseAt:
	mov	BYTE PTR [esi+edi], 38			; 00000026H
	inc	esi

; 4011 : 		    while (len + i + 10 > buf_size) {

	lea	eax, DWORD PTR [esi+10]
	add	eax, ecx
	mov	DWORD PTR tv2034[ebp], eax
	cmp	eax, ebx
	jbe	SHORT $LN7@xmlParseAt
	npad	6
$LL6@xmlParseAt:

; 4012 : 			growBuffer(buf, i + 10);

	lea	eax, DWORD PTR [ebx+5]
	lea	eax, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _new_size$1$[ebp], eax
	cmp	eax, ebx
	jb	$mem_error$322
	push	eax
	push	edi
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	$mem_error$322
	mov	ecx, DWORD PTR _i$1$[ebp]
	mov	edi, eax
	mov	eax, DWORD PTR _new_size$1$[ebp]
	mov	ebx, eax
	mov	DWORD PTR _buf$1$[ebp], edi
	cmp	DWORD PTR tv2034[ebp], eax
	ja	SHORT $LL6@xmlParseAt
$LN7@xmlParseAt:

; 4013 : 		    }
; 4014 : 		    for (;i > 0;i--)

	test	ecx, ecx
	jle	$LN9@xmlParseAt
	mov	edx, DWORD PTR _cur$1$[ebp]
$LL10@xmlParseAt:

; 4015 : 			buf[len++] = *cur++;

	mov	al, BYTE PTR [edx]
	lea	edx, DWORD PTR [edx+1]
	mov	BYTE PTR [esi+edi], al
	dec	ecx
	inc	esi
	test	ecx, ecx
	jg	SHORT $LL10@xmlParseAt

; 4016 : 		    buf[len++] = ';';

	mov	BYTE PTR [esi+edi], 59			; 0000003bH
	inc	esi

; 4017 : 		}
; 4018 : 	    }
; 4019 : 	} else {

	jmp	$LN314@xmlParseAt
$LN25@xmlParseAt:

; 4020 : 	    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {

	cmp	ecx, 32					; 00000020H
	je	SHORT $LN75@xmlParseAt
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN75@xmlParseAt
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN75@xmlParseAt
	cmp	ecx, 9
	je	SHORT $LN75@xmlParseAt

; 4029 : 		}
; 4030 : 	    } else {
; 4031 : 	        in_space = 0;
; 4032 : 		COPY_BUF(l,buf,len,c);

	cmp	DWORD PTR _l$[ebp], 1
	lea	eax, DWORD PTR [esi+edi]
	mov	DWORD PTR _in_space$1$[ebp], 0
	jne	SHORT $LN84@xmlParseAt
	mov	BYTE PTR [eax], cl
	inc	esi
	jmp	SHORT $LN85@xmlParseAt
$LN84@xmlParseAt:
	push	ecx
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	esi, eax
$LN85@xmlParseAt:

; 4033 : 		if (len + 10 > buf_size) {

	lea	eax, DWORD PTR [esi+10]
	cmp	eax, ebx
	jbe	$LN15@xmlParseAt

; 4034 : 		    growBuffer(buf, 10);

	lea	eax, DWORD PTR [ebx*2+10]
	mov	DWORD PTR _new_size$1$[ebp], eax
	cmp	eax, ebx
	jb	$mem_error$322
	push	eax
	push	edi
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	$mem_error$322
	mov	ebx, DWORD PTR _new_size$1$[ebp]
	mov	edi, eax
	mov	DWORD PTR _buf$1$[ebp], edi
	jmp	SHORT $LN15@xmlParseAt
$LN75@xmlParseAt:

; 4021 : 	        if ((len != 0) || (!normalize)) {

	test	esi, esi
	jne	SHORT $LN77@xmlParseAt
	test	eax, eax
	jne	SHORT $LN15@xmlParseAt

; 4022 : 		    if ((!normalize) || (!in_space)) {

	jmp	SHORT $LN79@xmlParseAt
$LN77@xmlParseAt:
	test	eax, eax
	je	SHORT $LN79@xmlParseAt
	cmp	DWORD PTR _in_space$1$[ebp], 0
	jne	SHORT $LN12@xmlParseAt
$LN79@xmlParseAt:

; 4023 : 			COPY_BUF(l,buf,len,0x20);

	cmp	DWORD PTR _l$[ebp], 1
	lea	eax, DWORD PTR [esi+edi]
	jne	SHORT $LN80@xmlParseAt
	mov	BYTE PTR [eax], 32			; 00000020H
	inc	esi
	jmp	SHORT $LN265@xmlParseAt
$LN80@xmlParseAt:
	push	32					; 00000020H
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	esi, eax
$LN265@xmlParseAt:

; 4024 : 			while (len + 10 > buf_size) {

	lea	eax, DWORD PTR [esi+10]
	cmp	eax, ebx
	jbe	SHORT $LN12@xmlParseAt
	npad	1
$LL11@xmlParseAt:

; 4025 : 			    growBuffer(buf, 10);

	lea	eax, DWORD PTR [ebx*2+10]
	mov	DWORD PTR _new_size$1$[ebp], eax
	cmp	eax, ebx
	jb	$mem_error$322
	push	eax
	push	edi
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	$mem_error$322
	mov	ebx, DWORD PTR _new_size$1$[ebp]
	lea	ecx, DWORD PTR [esi+10]
	mov	edi, eax
	mov	DWORD PTR _buf$1$[ebp], edi
	cmp	ecx, ebx
	ja	SHORT $LL11@xmlParseAt
$LN12@xmlParseAt:

; 4026 : 			}
; 4027 : 		    }
; 4028 : 		    in_space = 1;

	mov	DWORD PTR _in_space$1$[ebp], 1
$LN15@xmlParseAt:

; 4035 : 		}
; 4036 : 	    }
; 4037 : 	    NEXTL(l);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN89@xmlParseAt
	inc	DWORD PTR [edx+28]
	mov	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN90@xmlParseAt
$LN89@xmlParseAt:
	inc	DWORD PTR [edx+32]
$LN90@xmlParseAt:
	mov	ecx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax
$LN314@xmlParseAt:

; 4038 : 	}
; 4039 : 	GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
$LN14@xmlParseAt:
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN91@xmlParseAt
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN91@xmlParseAt
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlGROW
	mov	edx, DWORD PTR _ctxt$[ebp]
	add	esp, 4
$LN91@xmlParseAt:

; 4040 : 	c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edx
	jmp	$LN319@xmlParseAt
$LN94@xmlParseAt:

; 4050 : 	xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
; 4051 :     } else if (RAW != limit) {

	cmp	al, BYTE PTR _limit$1$[ebp]
	je	$LN96@xmlParseAt

; 4052 : 	if ((c != 0) && (!IS_CHAR(c))) {

	test	ecx, ecx
	je	SHORT $LN98@xmlParseAt
	cmp	ecx, 256				; 00000100H
	jge	SHORT $LN308@xmlParseAt
	cmp	ecx, 9
	jl	SHORT $LN115@xmlParseAt
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN98@xmlParseAt
$LN115@xmlParseAt:
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN98@xmlParseAt
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN120@xmlParseAt
$LN98@xmlParseAt:

; 4054 : 			   "invalid character in attribute value\n");
; 4055 : 	} else {
; 4056 : 	    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,

	mov	ecx, OFFSET ??_C@_0BG@NKOFEMFC@AttValue?3?5?8?5expected?6@
	mov	eax, 40					; 00000028H

; 4057 : 			   "AttValue: ' expected\n");
; 4058 :         }
; 4059 :     } else

	push	ecx
	push	eax
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN320@xmlParseAt
$LN308@xmlParseAt:

; 4052 : 	if ((c != 0) && (!IS_CHAR(c))) {

	cmp	ecx, 55295				; 0000d7ffH
	jle	SHORT $LN98@xmlParseAt
	cmp	ecx, 57344				; 0000e000H
	jl	SHORT $LN118@xmlParseAt
	cmp	ecx, 65533				; 0000fffdH
	jle	SHORT $LN98@xmlParseAt
$LN118@xmlParseAt:
	cmp	ecx, 65536				; 00010000H
	jl	SHORT $LN120@xmlParseAt
	cmp	ecx, 1114111				; 0010ffffH
	jle	SHORT $LN98@xmlParseAt
$LN120@xmlParseAt:

; 4053 : 	    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,

	mov	ecx, OFFSET ??_C@_0CG@LEIKKIHB@invalid?5character?5in?5attribute?5@
	mov	eax, 9

; 4057 : 			   "AttValue: ' expected\n");
; 4058 :         }
; 4059 :     } else

	push	ecx
	push	eax
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN320@xmlParseAt
$LN96@xmlParseAt:

; 4060 : 	NEXT;

	push	edx
	call	_xmlNextChar
	add	esp, 4
$LN320@xmlParseAt:

; 4061 : 
; 4062 :     /*
; 4063 :      * There we potentially risk an overflow, don't allow attribute value of
; 4064 :      * length more than INT_MAX it is a very reasonnable assumption !
; 4065 :      */
; 4066 :     if (len >= INT_MAX) {

	mov	edx, DWORD PTR _ctxt$[ebp]
$LN97@xmlParseAt:
	cmp	esi, 2147483647				; 7fffffffH
	jb	SHORT $LN100@xmlParseAt
$LN273@xmlParseAt:

; 4074 : 
; 4075 : mem_error:
; 4076 :     xmlErrMemory(ctxt, NULL);

	push	OFFSET ??_C@_0BK@JCFIEKOP@AttValue?5length?5too?5long?6@
	push	40					; 00000028H
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$mem_error$322:
	push	0
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrMemory
	add	esp, 8
$error$323:

; 4077 : error:
; 4078 :     if (buf != NULL)

	test	edi, edi
	je	SHORT $LN102@xmlParseAt

; 4079 :         xmlFree(buf);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN102@xmlParseAt:

; 4080 :     if (rep != NULL)

	mov	eax, DWORD PTR _rep$1$[ebp]
	test	eax, eax
	je	$LN191@xmlParseAt

; 4081 :         xmlFree(rep);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	edi

; 4082 :     return(NULL);
; 4083 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN100@xmlParseAt:

; 4067 :         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
; 4068 :                        "AttValue length too long\n");
; 4069 :         goto mem_error;
; 4070 :     }
; 4071 : 
; 4072 :     if (attlen != NULL) *attlen = (int) len;

	mov	eax, DWORD PTR _attlen$[ebp]
	test	eax, eax
	je	SHORT $LN101@xmlParseAt
	mov	DWORD PTR [eax], esi
$LN101@xmlParseAt:

; 4073 :     return(buf);

	mov	eax, edi
	pop	edi

; 4082 :     return(NULL);
; 4083 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlParseAt:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [ebx+212], esi
	je	SHORT $LN128@xmlParseAt
	cmp	DWORD PTR [ebx+172], -1
	je	SHORT $LN191@xmlParseAt
$LN128@xmlParseAt:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BK@ELBMECGA@AttValue?3?5?$CC?5or?5?8?5expected@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	39					; 00000027H
	push	1
	push	0
	push	ebx
	push	0
	push	0
	push	0
	mov	DWORD PTR [ebx+84], 39			; 00000027H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [ebx+12], esi

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [ebx+288], esi
	jne	SHORT $LN191@xmlParseAt

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [ebx+212], 1
$LN191@xmlParseAt:
	pop	edi

; 4082 :     return(NULL);
; 4083 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseAttValueComplex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseStringName
_TEXT	SEGMENT
_buf$ = -124						; size = 105
_max$1$ = -16						; size = 4
_c$1$ = -12						; size = 4
_cur$1$ = -12						; size = 4
_buffer$1$ = -8						; size = 4
_l$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParseStringName PROC				; COMDAT

; 3512 : xmlParseStringName(xmlParserCtxtPtr ctxt, const xmlChar** str) {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _str$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	ebx, DWORD PTR [eax]
	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	ebx
	push	edi
	call	_xmlStringCurrentChar
	push	eax
	push	edi
	mov	DWORD PTR _c$1$[ebp], eax
	call	_xmlIsNameStartChar
	add	esp, 20					; 00000014H
	test	eax, eax
	je	$LN154@xmlParseSt

; 3513 :     xmlChar buf[XML_MAX_NAMELEN + 5];
; 3514 :     const xmlChar *cur = *str;
; 3515 :     int len = 0, l;
; 3516 :     int c;
; 3517 : 
; 3518 : #ifdef DEBUG
; 3519 :     nbParseStringName++;
; 3520 : #endif
; 3521 : 
; 3522 :     c = CUR_SCHAR(cur, l);
; 3523 :     if (!xmlIsNameStartChar(ctxt, c)) {
; 3524 : 	return(NULL);
; 3525 :     }
; 3526 : 
; 3527 :     COPY_BUF(l,buf,len,c);

	mov	ecx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR _c$1$[ebp]
	cmp	ecx, 1
	jne	SHORT $LN7@xmlParseSt
	mov	BYTE PTR _buf$[ebp], al
	mov	esi, ecx
	jmp	SHORT $LN8@xmlParseSt
$LN7@xmlParseSt:
	push	eax
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlCopyCharMultiByte
	mov	ecx, DWORD PTR _l$[ebp]
	add	esp, 8
	mov	esi, eax
$LN8@xmlParseSt:

; 3528 :     cur += l;
; 3529 :     c = CUR_SCHAR(cur, l);

	lea	eax, DWORD PTR _l$[ebp]
	add	ebx, ecx
	push	eax
	push	ebx
	push	edi
	mov	DWORD PTR _cur$1$[ebp], ebx
	call	_xmlStringCurrentChar
	mov	ebx, eax

; 3530 :     while (xmlIsNameChar(ctxt, c)) {

	push	ebx
	push	edi
	call	_xmlIsNameChar
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN3@xmlParseSt
	npad	1
$LL2@xmlParseSt:

; 3531 : 	COPY_BUF(l,buf,len,c);

	mov	ecx, DWORD PTR _l$[ebp]
	lea	eax, DWORD PTR _buf$[ebp]
	add	eax, esi
	cmp	ecx, 1
	jne	SHORT $LN9@xmlParseSt
	mov	BYTE PTR [eax], bl
	inc	esi
	jmp	SHORT $LN10@xmlParseSt
$LN9@xmlParseSt:
	push	ebx
	push	eax
	call	_xmlCopyCharMultiByte
	mov	ecx, DWORD PTR _l$[ebp]
	add	esp, 8
	add	esi, eax
$LN10@xmlParseSt:

; 3532 : 	cur += l;

	mov	eax, DWORD PTR _cur$1$[ebp]
	add	eax, ecx

; 3533 : 	c = CUR_SCHAR(cur, l);

	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	push	eax
	push	edi
	mov	DWORD PTR _cur$1$[ebp], eax
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	ebx, eax

; 3534 : 	if (len >= XML_MAX_NAMELEN) { /* test bigentname.xml */

	cmp	esi, 100				; 00000064H
	jge	$LN158@xmlParseSt

; 3530 :     while (xmlIsNameChar(ctxt, c)) {

	push	ebx
	push	edi
	call	_xmlIsNameChar
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL2@xmlParseSt
$LN3@xmlParseSt:

; 3574 : 	    return(buffer);
; 3575 : 	}
; 3576 :     }
; 3577 :     if ((len > XML_MAX_NAME_LENGTH) &&

	cmp	esi, 50000				; 0000c350H
	jle	$LN18@xmlParseSt
	test	DWORD PTR [edi+360], 524288		; 00080000H
	jne	$LN18@xmlParseSt

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edi+212], 0
	je	SHORT $LN91@xmlParseSt
	cmp	DWORD PTR [edi+172], -1
	je	SHORT $LN154@xmlParseSt
$LN91@xmlParseSt:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_06MDLHOHLI@NCName@
	push	OFFSET ??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@
	push	OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_06MDLHOHLI@NCName@
	push	0
	push	0
	push	3
	push	110					; 0000006eH
	push	1
	push	0
	push	edi
	push	0
	push	0
	push	0
	mov	DWORD PTR [edi+84], 110			; 0000006eH
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [edi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [edi+288], 0
	jne	SHORT $LN154@xmlParseSt

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [edi+212], 1
$LN154@xmlParseSt:
	pop	edi

; 3584 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN158@xmlParseSt:

; 3535 : 	    /*
; 3536 : 	     * Okay someone managed to make a huge name, so he's ready to pay
; 3537 : 	     * for the processing speed.
; 3538 : 	     */
; 3539 : 	    xmlChar *buffer;
; 3540 : 	    int max = len * 2;

	lea	eax, DWORD PTR [esi+esi]

; 3541 : 
; 3542 : 	    buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));

	push	eax
	mov	DWORD PTR _max$1$[ebp], eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR _buffer$1$[ebp], eax

; 3543 : 	    if (buffer == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlParseSt

; 3544 : 	        xmlErrMemory(ctxt, NULL);

	push	eax
	push	edi
	call	_xmlErrMemory
	add	esp, 8

; 3584 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlParseSt:

; 3545 : 		return(NULL);
; 3546 : 	    }
; 3547 : 	    memcpy(buffer, buf, len);

	push	esi
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	push	eax
	call	_memcpy

; 3548 : 	    while (xmlIsNameChar(ctxt, c)) {

	push	ebx
	push	edi
	call	_xmlIsNameChar
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN166@xmlParseSt
$LL4@xmlParseSt:

; 3549 : 		if (len + 10 > max) {

	mov	ecx, DWORD PTR _max$1$[ebp]
	lea	eax, DWORD PTR [esi+10]
	cmp	eax, ecx
	jle	SHORT $LN167@xmlParseSt

; 3550 : 		    xmlChar *tmp;
; 3551 : 
; 3552 :                     if ((len > XML_MAX_NAME_LENGTH) &&

	cmp	esi, 50000				; 0000c350H
	jle	SHORT $LN14@xmlParseSt
	test	DWORD PTR [edi+360], 524288		; 00080000H
	je	SHORT $LN159@xmlParseSt
$LN14@xmlParseSt:

; 3556 :                         return(NULL);
; 3557 :                     }
; 3558 : 		    max *= 2;

	add	ecx, ecx

; 3559 : 		    tmp = (xmlChar *) xmlRealloc(buffer,

	push	ecx
	push	DWORD PTR _buffer$1$[ebp]
	mov	DWORD PTR _max$1$[ebp], ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 3560 : 			                            max * sizeof(xmlChar));
; 3561 : 		    if (tmp == NULL) {

	test	eax, eax
	je	$LN160@xmlParseSt

; 3564 : 			return(NULL);
; 3565 : 		    }
; 3566 : 		    buffer = tmp;

	mov	DWORD PTR _buffer$1$[ebp], eax
	jmp	SHORT $LN13@xmlParseSt
$LN167@xmlParseSt:

; 3549 : 		if (len + 10 > max) {

	mov	eax, DWORD PTR _buffer$1$[ebp]
$LN13@xmlParseSt:

; 3567 : 		}
; 3568 : 		COPY_BUF(l,buffer,len,c);

	add	eax, esi
	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN16@xmlParseSt
	mov	BYTE PTR [eax], bl
	inc	esi
	jmp	SHORT $LN17@xmlParseSt
$LN16@xmlParseSt:
	push	ebx
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	esi, eax
$LN17@xmlParseSt:

; 3569 : 		cur += l;

	mov	eax, DWORD PTR _cur$1$[ebp]

; 3570 : 		c = CUR_SCHAR(cur, l);

	lea	ecx, DWORD PTR _l$[ebp]
	add	eax, DWORD PTR _l$[ebp]
	push	ecx
	push	eax
	push	edi
	mov	DWORD PTR _cur$1$[ebp], eax
	call	_xmlStringCurrentChar
	mov	ebx, eax
	push	ebx
	push	edi
	call	_xmlIsNameChar
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LL4@xmlParseSt
$LN166@xmlParseSt:

; 3571 : 	    }
; 3572 : 	    buffer[len] = 0;

	mov	ecx, DWORD PTR _buffer$1$[ebp]

; 3573 : 	    *str = cur;

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$1$[ebp]
	pop	edi
	mov	BYTE PTR [ecx+esi], 0

; 3584 : }

	pop	esi
	mov	DWORD PTR [edx], eax
	mov	eax, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN159@xmlParseSt:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edi+212], 0
	je	SHORT $LN23@xmlParseSt
	cmp	DWORD PTR [edi+172], -1
	je	SHORT $LN86@xmlParseSt
$LN23@xmlParseSt:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_06MDLHOHLI@NCName@
	push	OFFSET ??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@
	push	OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_06MDLHOHLI@NCName@
	push	0
	push	0
	push	3
	push	110					; 0000006eH
	push	1
	push	0
	push	edi
	push	0
	push	0
	push	0
	mov	DWORD PTR [edi+84], 110			; 0000006eH
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [edi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [edi+288], 0
	jne	SHORT $LN86@xmlParseSt

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [edi+212], 1
$LN86@xmlParseSt:

; 3553 :                         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3554 :                         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
; 3555 : 			xmlFree(buffer);

	push	DWORD PTR _buffer$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3584 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN160@xmlParseSt:

; 3562 : 			xmlErrMemory(ctxt, NULL);

	push	0
	push	edi
	call	_xmlErrMemory

; 3563 : 			xmlFree(buffer);

	push	DWORD PTR _buffer$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 3584 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlParseSt:

; 3578 :         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3579 :         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
; 3580 :         return(NULL);
; 3581 :     }
; 3582 :     *str = cur;

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$1$[ebp]

; 3583 :     return(xmlStrndup(buf, len));

	push	esi
	mov	DWORD PTR [edx], eax
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlStrndup
	add	esp, 8
	pop	edi

; 3584 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseStringName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseNameAndCompare
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_other$ = 12						; size = 4
_xmlParseNameAndCompare PROC				; COMDAT

; 3464 : xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	edi, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN4@xmlParseNa

; 3465 :     register const xmlChar *cmp = other;
; 3466 :     register const xmlChar *in;
; 3467 :     const xmlChar *ret;
; 3468 : 
; 3469 :     GROW;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN4@xmlParseNa
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN4@xmlParseNa:

; 3470 :     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	jne	SHORT $LN5@xmlParseNa

; 3471 :         return(NULL);

	pop	edi
	xor	eax, eax

; 3488 : 	return (const xmlChar*) 1;
; 3489 :     }
; 3490 :     return ret;
; 3491 : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlParseNa:

; 3472 : 
; 3473 :     in = ctxt->input->cur;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]

; 3474 :     while (*in != 0 && *in == *cmp) {

	mov	al, BYTE PTR [ecx]
	test	al, al
	je	SHORT $LN16@xmlParseNa
$LL2@xmlParseNa:
	cmp	al, BYTE PTR [edi]
	jne	SHORT $LN16@xmlParseNa

; 3475 : 	++in;
; 3476 : 	++cmp;
; 3477 : 	ctxt->input->col++;

	mov	eax, DWORD PTR [esi+36]
	inc	ecx
	inc	edi
	inc	DWORD PTR [eax+32]
	mov	al, BYTE PTR [ecx]
	test	al, al
	jne	SHORT $LL2@xmlParseNa
$LN16@xmlParseNa:

; 3478 :     }
; 3479 :     if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {

	cmp	BYTE PTR [edi], 0
	jne	SHORT $LN6@xmlParseNa
	mov	al, BYTE PTR [ecx]
	cmp	al, 62					; 0000003eH
	je	SHORT $LN8@xmlParseNa
	cmp	al, 32					; 00000020H
	je	SHORT $LN8@xmlParseNa
	cmp	al, 9
	jb	SHORT $LN9@xmlParseNa
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN8@xmlParseNa
$LN9@xmlParseNa:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN6@xmlParseNa
$LN8@xmlParseNa:

; 3480 : 	/* success */
; 3481 : 	ctxt->input->cur = in;

	mov	eax, DWORD PTR [esi+36]
	pop	edi

; 3488 : 	return (const xmlChar*) 1;
; 3489 :     }
; 3490 :     return ret;
; 3491 : }

	pop	esi
	mov	DWORD PTR [eax+16], ecx
	mov	eax, 1
	pop	ebp
	ret	0
$LN6@xmlParseNa:

; 3482 : 	return (const xmlChar*) 1;
; 3483 :     }
; 3484 :     /* failure (or end of input buffer), check with full function */
; 3485 :     ret = xmlParseName (ctxt);

	push	esi
	call	_xmlParseName
	add	esp, 4

; 3486 :     /* strings coming from the dictionary direct compare possible */
; 3487 :     if (ret == other) {

	mov	ecx, 1
	cmp	eax, DWORD PTR _other$[ebp]
	cmove	eax, ecx
	pop	edi

; 3488 : 	return (const xmlChar*) 1;
; 3489 :     }
; 3490 :     return ret;
; 3491 : }

	pop	esi
	pop	ebp
	ret	0
_xmlParseNameAndCompare ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseNCName
_TEXT	SEGMENT
_ret$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseNCName PROC					; COMDAT

; 3405 : xmlParseNCName(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edi+36]
	mov	edx, DWORD PTR [eax+16]
	mov	esi, edx
	mov	ecx, DWORD PTR [eax+20]
	mov	al, BYTE PTR [esi]
	cmp	al, 97					; 00000061H
	jb	SHORT $LN6@xmlParseNC

; 3406 :     const xmlChar *in, *e;
; 3407 :     const xmlChar *ret;
; 3408 :     int count = 0;
; 3409 : 
; 3410 : #ifdef DEBUG
; 3411 :     nbParseNCName++;
; 3412 : #endif
; 3413 : 
; 3414 :     /*
; 3415 :      * Accelerator for simple ASCII names
; 3416 :      */
; 3417 :     in = ctxt->input->cur;
; 3418 :     e = ctxt->input->end;
; 3419 :     if ((((*in >= 0x61) && (*in <= 0x7A)) ||
; 3420 : 	 ((*in >= 0x41) && (*in <= 0x5A)) ||
; 3421 : 	 (*in == '_')) && (in < e)) {

	cmp	al, 122					; 0000007aH
	jbe	SHORT $LN5@xmlParseNC
$LN6@xmlParseNC:
	cmp	al, 65					; 00000041H
	jb	SHORT $LN7@xmlParseNC
	cmp	al, 90					; 0000005aH
	jbe	SHORT $LN5@xmlParseNC
$LN7@xmlParseNC:
	cmp	al, 95					; 0000005fH
	jne	$_complex$91
$LN5@xmlParseNC:

; 3422 : 	in++;
; 3423 : 	while ((((*in >= 0x61) && (*in <= 0x7A)) ||
; 3424 : 	        ((*in >= 0x41) && (*in <= 0x5A)) ||
; 3425 : 	        ((*in >= 0x30) && (*in <= 0x39)) ||
; 3426 : 	        (*in == '_') || (*in == '-') ||
; 3427 : 	        (*in == '.')) && (in < e))

	cmp	esi, ecx
	jae	$_complex$91
	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 97					; 00000061H
	jb	SHORT $LN9@xmlParseNC
	cmp	al, 122					; 0000007aH
	jbe	SHORT $LN5@xmlParseNC
$LN9@xmlParseNC:
	cmp	al, 65					; 00000041H
	jb	SHORT $LN10@xmlParseNC
	cmp	al, 90					; 0000005aH
	jbe	SHORT $LN5@xmlParseNC
$LN10@xmlParseNC:
	cmp	al, 48					; 00000030H
	jb	SHORT $LN11@xmlParseNC
	cmp	al, 57					; 00000039H
	jbe	SHORT $LN5@xmlParseNC
$LN11@xmlParseNC:
	cmp	al, 95					; 0000005fH
	je	SHORT $LN5@xmlParseNC
	cmp	al, 45					; 0000002dH
	je	SHORT $LN5@xmlParseNC
	cmp	al, 46					; 0000002eH
	je	SHORT $LN5@xmlParseNC

; 3428 : 	    in++;
; 3429 : 	if (in >= e)

	cmp	esi, ecx
	jae	$_complex$91

; 3430 : 	    goto complex;
; 3431 : 	if ((*in > 0) && (*in < 0x80)) {

	dec	al
	cmp	al, 126					; 0000007eH
	ja	$_complex$91

; 3432 : 	    count = in - ctxt->input->cur;

	push	ebx
	mov	ebx, esi
	sub	ebx, edx

; 3433 :             if ((count > XML_MAX_NAME_LENGTH) &&

	cmp	ebx, 50000				; 0000c350H
	jle	SHORT $LN14@xmlParseNC
	test	DWORD PTR [edi+360], 524288		; 00080000H
	jne	SHORT $LN14@xmlParseNC

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edi+212], 0
	je	SHORT $LN20@xmlParseNC
	cmp	DWORD PTR [edi+172], -1
	je	SHORT $LN83@xmlParseNC
$LN20@xmlParseNC:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_06MDLHOHLI@NCName@
	push	OFFSET ??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@
	push	OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_06MDLHOHLI@NCName@
	push	0
	push	0
	push	3
	push	110					; 0000006eH
	push	1
	push	0
	push	edi
	push	0
	push	0
	push	0
	mov	DWORD PTR [edi+84], 110			; 0000006eH
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [edi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [edi+288], 0
	jne	SHORT $LN83@xmlParseNC

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [edi+212], 1
$LN83@xmlParseNC:

; 3434 :                 ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3435 :                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
; 3436 :                 return(NULL);

	xor	eax, eax
$LN88@xmlParseNC:
	pop	ebx
	pop	edi

; 3450 : }

	pop	esi
	pop	ebp
	ret	0
$LN14@xmlParseNC:

; 3437 :             }
; 3438 : 	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);

	push	ebx
	push	edx
	push	DWORD PTR [edi+296]
	call	_xmlDictLookup

; 3439 : 	    ctxt->input->cur = in;

	mov	ecx, DWORD PTR [edi+36]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$1$[ebp], eax
	mov	DWORD PTR [ecx+16], esi

; 3440 : 	    ctxt->nbChars += count;
; 3441 : 	    ctxt->input->col += count;

	mov	ecx, DWORD PTR [edi+36]
	add	DWORD PTR [edi+200], ebx
	add	DWORD PTR [ecx+32], ebx

; 3442 : 	    if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN88@xmlParseNC

; 3443 : 	        xmlErrMemory(ctxt, NULL);

	push	eax
	push	edi
	call	_xmlErrMemory
	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 8
	pop	ebx
	pop	edi

; 3450 : }

	pop	esi
	pop	ebp
	ret	0
$_complex$91:

; 3444 : 	    }
; 3445 : 	    return(ret);
; 3446 : 	}
; 3447 :     }
; 3448 : complex:
; 3449 :     return(xmlParseNCNameComplex(ctxt));

	push	edi
	call	_xmlParseNCNameComplex
	add	esp, 4
	pop	edi

; 3450 : }

	pop	esi
	pop	ebp
	ret	0
_xmlParseNCName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseNCNameComplex
_TEXT	SEGMENT
_len$1$ = -8						; size = 4
_l$ = -4						; size = 4
_startPosition$1$ = 8					; size = 4
_ctxt$ = 8						; size = 4
_xmlParseNCNameComplex PROC				; COMDAT

; 3329 : xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _len$1$[ebp], 0
	cmp	DWORD PTR [esi+292], ebx
	jne	SHORT $LN7@xmlParseNC

; 3330 :     int len = 0, l;
; 3331 :     int c;
; 3332 :     int count = 0;
; 3333 :     size_t startPosition = 0;
; 3334 : 
; 3335 : #ifdef DEBUG
; 3336 :     nbParseNCNameComplex++;
; 3337 : #endif
; 3338 : 
; 3339 :     /*
; 3340 :      * Handler for more complex cases
; 3341 :      */
; 3342 :     GROW;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN7@xmlParseNC
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN7@xmlParseNC:

; 3343 :     startPosition = CUR_PTR - BASE_PTR;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR [eax+12]

; 3344 :     c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	mov	DWORD PTR _startPosition$1$[ebp], ecx
	call	_xmlCurrentChar
	mov	edi, eax
	add	esp, 8

; 3345 :     if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */

	cmp	edi, 32					; 00000020H
	je	$LN10@xmlParseNC
	cmp	edi, 62					; 0000003eH
	je	$LN10@xmlParseNC
	cmp	edi, 47					; 0000002fH
	je	$LN10@xmlParseNC
	push	edi
	push	esi
	call	_xmlIsNameStartChar
	add	esp, 8
	test	eax, eax
	je	$LN10@xmlParseNC
	cmp	edi, 58					; 0000003aH
	je	$LN10@xmlParseNC
$LL2@xmlParseNC:

; 3348 :     }
; 3349 : 
; 3350 :     while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */

	cmp	edi, 62					; 0000003eH
	je	$LN166@xmlParseNC
	cmp	edi, 47					; 0000002fH
	je	$LN166@xmlParseNC
	push	edi
	push	esi
	call	_xmlIsNameChar
	add	esp, 8
	test	eax, eax
	je	$LN166@xmlParseNC
	cmp	edi, 58					; 0000003aH
	je	$LN166@xmlParseNC

; 3351 : 	   (xmlIsNameChar(ctxt, c) && (c != ':'))) {
; 3352 : 	if (count++ > XML_PARSER_CHUNK_SIZE) {

	mov	eax, ebx
	inc	ebx
	cmp	eax, 100				; 00000064H
	jle	SHORT $LN165@xmlParseNC

; 3353 :             if ((len > XML_MAX_NAME_LENGTH) &&

	cmp	DWORD PTR _len$1$[ebp], 50000		; 0000c350H
	jle	SHORT $LN12@xmlParseNC
	test	DWORD PTR [esi+360], 524288		; 00080000H
	je	$LN159@xmlParseNC
$LN12@xmlParseNC:

; 3354 :                 ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3355 :                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
; 3356 :                 return(NULL);
; 3357 :             }
; 3358 : 	    count = 0;

	xor	ebx, ebx

; 3359 : 	    GROW;

	cmp	DWORD PTR [esi+292], ebx
	jne	SHORT $LN13@xmlParseNC
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN13@xmlParseNC
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN13@xmlParseNC:

; 3360 :             if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	$LN10@xmlParseNC
$LN165@xmlParseNC:

; 3361 :                 return(NULL);
; 3362 : 	}
; 3363 : 	len += l;

	mov	eax, DWORD PTR _len$1$[ebp]
	add	eax, DWORD PTR _l$[ebp]

; 3364 : 	NEXTL(l);

	mov	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR _len$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN15@xmlParseNC
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN16@xmlParseNC
$LN15@xmlParseNC:
	inc	DWORD PTR [ecx+32]
$LN16@xmlParseNC:
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax

; 3365 : 	c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	mov	edi, eax
	add	esp, 8

; 3366 : 	if (c == 0) {

	test	edi, edi
	jne	SHORT $LN17@xmlParseNC

; 3367 : 	    count = 0;
; 3368 : 	    /*
; 3369 : 	     * when shrinking to extend the buffer we really need to preserve
; 3370 : 	     * the part of the name we already parsed. Hence rolling back
; 3371 : 	     * by current lenght.
; 3372 : 	     */
; 3373 : 	    ctxt->input->cur -= l;

	mov	ecx, DWORD PTR [esi+36]
	xor	ebx, ebx
	mov	eax, DWORD PTR _l$[ebp]
	sub	DWORD PTR [ecx+16], eax

; 3374 : 	    GROW;

	cmp	DWORD PTR [esi+292], ebx
	jne	SHORT $LN18@xmlParseNC
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN18@xmlParseNC
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN18@xmlParseNC:

; 3375 :             if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	$LN10@xmlParseNC

; 3376 :                 return(NULL);
; 3377 : 	    ctxt->input->cur += l;

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax

; 3378 : 	    c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	add	esp, 8
	mov	edi, eax
$LN17@xmlParseNC:

; 3348 :     }
; 3349 : 
; 3350 :     while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */

	cmp	edi, 32					; 00000020H
	jne	$LL2@xmlParseNC
$LN166@xmlParseNC:

; 3379 : 	}
; 3380 :     }
; 3381 :     if ((len > XML_MAX_NAME_LENGTH) &&

	mov	eax, DWORD PTR _len$1$[ebp]
	cmp	eax, 50000				; 0000c350H
	jle	$LN20@xmlParseNC
	test	DWORD PTR [esi+360], 524288		; 00080000H
	jne	SHORT $LN20@xmlParseNC
$LN159@xmlParseNC:

; 3346 : 	(!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {
; 3347 : 	return(NULL);

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN25@xmlParseNC
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN10@xmlParseNC
$LN25@xmlParseNC:
	push	OFFSET ??_C@_06MDLHOHLI@NCName@
	push	OFFSET ??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@
	push	OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_06MDLHOHLI@NCName@
	push	0
	push	0
	push	3
	push	110					; 0000006eH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 110			; 0000006eH
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
	mov	DWORD PTR [esi+12], 0
	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN10@xmlParseNC
	mov	DWORD PTR [esi+212], 1
$LN10@xmlParseNC:
	pop	edi

; 3387 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlParseNC:

; 3382 :         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3383 :         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
; 3384 :         return(NULL);
; 3385 :     }
; 3386 :     return(xmlDictLookup(ctxt->dict, (BASE_PTR + startPosition), len));

	push	eax
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+12]
	add	eax, DWORD PTR _startPosition$1$[ebp]
	push	eax
	push	DWORD PTR [esi+296]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	pop	edi

; 3387 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseNCNameComplex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseNameComplex
_TEXT	SEGMENT
_l$ = -4						; size = 4
_len$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseNameComplex PROC				; COMDAT

; 3146 : xmlParseNameComplex(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	cmp	DWORD PTR [edi+292], ebx
	jne	SHORT $LN18@xmlParseNa

; 3147 :     int len = 0, l;
; 3148 :     int c;
; 3149 :     int count = 0;
; 3150 : 
; 3151 : #ifdef DEBUG
; 3152 :     nbParseNameComplex++;
; 3153 : #endif
; 3154 : 
; 3155 :     /*
; 3156 :      * Handler for more complex cases
; 3157 :      */
; 3158 :     GROW;

	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN18@xmlParseNa
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN18@xmlParseNa:

; 3159 :     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [edi+172], -1
	je	$LN63@xmlParseNa

; 3160 :         return(NULL);
; 3161 :     c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	call	_xmlCurrentChar
	mov	esi, eax
	add	esp, 8

; 3162 :     if ((ctxt->options & XML_PARSE_OLD10) == 0) {

	mov	eax, DWORD PTR [edi+360]
	and	eax, 131072				; 00020000H

; 3163 :         /*
; 3164 : 	 * Use the new checks of production [4] [4a] amd [5] of the
; 3165 : 	 * Update 5 of XML-1.0
; 3166 : 	 */
; 3167 : 	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */

	cmp	esi, 32					; 00000020H
	je	$LN63@xmlParseNa

; 3162 :     if ((ctxt->options & XML_PARSE_OLD10) == 0) {

	test	eax, eax
	jne	$LN20@xmlParseNa

; 3163 :         /*
; 3164 : 	 * Use the new checks of production [4] [4a] amd [5] of the
; 3165 : 	 * Update 5 of XML-1.0
; 3166 : 	 */
; 3167 : 	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */

	cmp	esi, 62					; 0000003eH
	je	$LN63@xmlParseNa
	cmp	esi, 47					; 0000002fH
	je	$LN63@xmlParseNa
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN24@xmlParseNa
	cmp	esi, 122				; 0000007aH
	jle	$LN22@xmlParseNa
$LN24@xmlParseNa:
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN25@xmlParseNa
	cmp	esi, 90					; 0000005aH
	jle	$LN22@xmlParseNa
$LN25@xmlParseNa:
	cmp	esi, 95					; 0000005fH
	je	$LN22@xmlParseNa
	cmp	esi, 58					; 0000003aH
	je	$LN22@xmlParseNa
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN26@xmlParseNa
	cmp	esi, 214				; 000000d6H
	jle	$LN22@xmlParseNa
$LN26@xmlParseNa:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN27@xmlParseNa
	cmp	esi, 246				; 000000f6H
	jle	$LN22@xmlParseNa
$LN27@xmlParseNa:
	cmp	esi, 248				; 000000f8H
	jl	SHORT $LN28@xmlParseNa
	cmp	esi, 767				; 000002ffH
	jle	$LN22@xmlParseNa
$LN28@xmlParseNa:
	cmp	esi, 880				; 00000370H
	jl	SHORT $LN29@xmlParseNa
	cmp	esi, 893				; 0000037dH
	jle	$LN22@xmlParseNa
$LN29@xmlParseNa:
	cmp	esi, 895				; 0000037fH
	jl	SHORT $LN30@xmlParseNa
	cmp	esi, 8191				; 00001fffH
	jle	SHORT $LN22@xmlParseNa
$LN30@xmlParseNa:
	cmp	esi, 8204				; 0000200cH
	jl	SHORT $LN31@xmlParseNa
	cmp	esi, 8205				; 0000200dH
	jle	SHORT $LN22@xmlParseNa
$LN31@xmlParseNa:
	cmp	esi, 8304				; 00002070H
	jl	SHORT $LN32@xmlParseNa
	cmp	esi, 8591				; 0000218fH
	jle	SHORT $LN22@xmlParseNa
$LN32@xmlParseNa:
	cmp	esi, 11264				; 00002c00H
	jl	SHORT $LN33@xmlParseNa
	cmp	esi, 12271				; 00002fefH
	jle	SHORT $LN22@xmlParseNa
$LN33@xmlParseNa:
	cmp	esi, 12289				; 00003001H
	jl	SHORT $LN34@xmlParseNa
	cmp	esi, 55295				; 0000d7ffH
	jle	SHORT $LN22@xmlParseNa
$LN34@xmlParseNa:
	cmp	esi, 63744				; 0000f900H
	jl	SHORT $LN35@xmlParseNa
	cmp	esi, 64975				; 0000fdcfH
	jle	SHORT $LN22@xmlParseNa
$LN35@xmlParseNa:
	cmp	esi, 65008				; 0000fdf0H
	jl	SHORT $LN36@xmlParseNa
	cmp	esi, 65533				; 0000fffdH
	jle	SHORT $LN22@xmlParseNa
$LN36@xmlParseNa:
	lea	eax, DWORD PTR [esi-65536]
	cmp	eax, 917503				; 000dffffH
	ja	$LN63@xmlParseNa
$LN22@xmlParseNa:

; 3168 : 	    (!(((c >= 'a') && (c <= 'z')) ||
; 3169 : 	       ((c >= 'A') && (c <= 'Z')) ||
; 3170 : 	       (c == '_') || (c == ':') ||
; 3171 : 	       ((c >= 0xC0) && (c <= 0xD6)) ||
; 3172 : 	       ((c >= 0xD8) && (c <= 0xF6)) ||
; 3173 : 	       ((c >= 0xF8) && (c <= 0x2FF)) ||
; 3174 : 	       ((c >= 0x370) && (c <= 0x37D)) ||
; 3175 : 	       ((c >= 0x37F) && (c <= 0x1FFF)) ||
; 3176 : 	       ((c >= 0x200C) && (c <= 0x200D)) ||
; 3177 : 	       ((c >= 0x2070) && (c <= 0x218F)) ||
; 3178 : 	       ((c >= 0x2C00) && (c <= 0x2FEF)) ||
; 3179 : 	       ((c >= 0x3001) && (c <= 0xD7FF)) ||
; 3180 : 	       ((c >= 0xF900) && (c <= 0xFDCF)) ||
; 3181 : 	       ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
; 3182 : 	       ((c >= 0x10000) && (c <= 0xEFFFF))))) {
; 3183 : 	    return(NULL);
; 3184 : 	}
; 3185 : 	len += l;
; 3186 : 	NEXTL(l);

	mov	ecx, DWORD PTR [edi+36]
	mov	esi, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN38@xmlParseNa
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN39@xmlParseNa
$LN38@xmlParseNa:
	inc	DWORD PTR [ecx+32]
$LN39@xmlParseNa:
	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax

; 3187 : 	c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	call	_xmlCurrentChar
	add	esp, 8

; 3188 : 	while ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */

	cmp	eax, 32					; 00000020H
	je	$LN14@xmlParseNa
$LL5@xmlParseNa:
	cmp	eax, 62					; 0000003eH
	je	$LN14@xmlParseNa
	cmp	eax, 47					; 0000002fH
	je	$LN14@xmlParseNa
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN41@xmlParseNa
	cmp	eax, 122				; 0000007aH
	jle	$LN40@xmlParseNa
$LN41@xmlParseNa:
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN42@xmlParseNa
	cmp	eax, 90					; 0000005aH
	jle	$LN40@xmlParseNa
$LN42@xmlParseNa:
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN43@xmlParseNa
	cmp	eax, 57					; 00000039H
	jle	$LN40@xmlParseNa
$LN43@xmlParseNa:
	cmp	eax, 95					; 0000005fH
	je	$LN40@xmlParseNa
	cmp	eax, 58					; 0000003aH
	je	$LN40@xmlParseNa
	cmp	eax, 45					; 0000002dH
	je	$LN40@xmlParseNa
	cmp	eax, 46					; 0000002eH
	je	$LN40@xmlParseNa
	cmp	eax, 183				; 000000b7H
	je	$LN40@xmlParseNa
	cmp	eax, 192				; 000000c0H
	jl	SHORT $LN44@xmlParseNa
	cmp	eax, 214				; 000000d6H
	jle	$LN40@xmlParseNa
$LN44@xmlParseNa:
	cmp	eax, 216				; 000000d8H
	jl	SHORT $LN45@xmlParseNa
	cmp	eax, 246				; 000000f6H
	jle	$LN40@xmlParseNa
$LN45@xmlParseNa:
	cmp	eax, 248				; 000000f8H
	jl	SHORT $LN46@xmlParseNa
	cmp	eax, 767				; 000002ffH
	jle	$LN40@xmlParseNa
$LN46@xmlParseNa:
	cmp	eax, 768				; 00000300H
	jl	SHORT $LN47@xmlParseNa
	cmp	eax, 879				; 0000036fH
	jle	$LN40@xmlParseNa
$LN47@xmlParseNa:
	cmp	eax, 880				; 00000370H
	jl	SHORT $LN48@xmlParseNa
	cmp	eax, 893				; 0000037dH
	jle	$LN40@xmlParseNa
$LN48@xmlParseNa:
	cmp	eax, 895				; 0000037fH
	jl	SHORT $LN49@xmlParseNa
	cmp	eax, 8191				; 00001fffH
	jle	SHORT $LN40@xmlParseNa
$LN49@xmlParseNa:
	cmp	eax, 8204				; 0000200cH
	jl	SHORT $LN50@xmlParseNa
	cmp	eax, 8205				; 0000200dH
	jle	SHORT $LN40@xmlParseNa
$LN50@xmlParseNa:
	cmp	eax, 8255				; 0000203fH
	jl	SHORT $LN51@xmlParseNa
	cmp	eax, 8256				; 00002040H
	jle	SHORT $LN40@xmlParseNa
$LN51@xmlParseNa:
	cmp	eax, 8304				; 00002070H
	jl	SHORT $LN52@xmlParseNa
	cmp	eax, 8591				; 0000218fH
	jle	SHORT $LN40@xmlParseNa
$LN52@xmlParseNa:
	cmp	eax, 11264				; 00002c00H
	jl	SHORT $LN53@xmlParseNa
	cmp	eax, 12271				; 00002fefH
	jle	SHORT $LN40@xmlParseNa
$LN53@xmlParseNa:
	cmp	eax, 12289				; 00003001H
	jl	SHORT $LN54@xmlParseNa
	cmp	eax, 55295				; 0000d7ffH
	jle	SHORT $LN40@xmlParseNa
$LN54@xmlParseNa:
	cmp	eax, 63744				; 0000f900H
	jl	SHORT $LN55@xmlParseNa
	cmp	eax, 64975				; 0000fdcfH
	jle	SHORT $LN40@xmlParseNa
$LN55@xmlParseNa:
	cmp	eax, 65008				; 0000fdf0H
	jl	SHORT $LN56@xmlParseNa
	cmp	eax, 65533				; 0000fffdH
	jle	SHORT $LN40@xmlParseNa
$LN56@xmlParseNa:
	add	eax, -65536				; ffff0000H
	cmp	eax, 917503				; 000dffffH
	ja	$LN14@xmlParseNa
$LN40@xmlParseNa:

; 3189 : 	       (((c >= 'a') && (c <= 'z')) ||
; 3190 : 	        ((c >= 'A') && (c <= 'Z')) ||
; 3191 : 	        ((c >= '0') && (c <= '9')) || /* !start */
; 3192 : 	        (c == '_') || (c == ':') ||
; 3193 : 	        (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
; 3194 : 	        ((c >= 0xC0) && (c <= 0xD6)) ||
; 3195 : 	        ((c >= 0xD8) && (c <= 0xF6)) ||
; 3196 : 	        ((c >= 0xF8) && (c <= 0x2FF)) ||
; 3197 : 	        ((c >= 0x300) && (c <= 0x36F)) || /* !start */
; 3198 : 	        ((c >= 0x370) && (c <= 0x37D)) ||
; 3199 : 	        ((c >= 0x37F) && (c <= 0x1FFF)) ||
; 3200 : 	        ((c >= 0x200C) && (c <= 0x200D)) ||
; 3201 : 	        ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
; 3202 : 	        ((c >= 0x2070) && (c <= 0x218F)) ||
; 3203 : 	        ((c >= 0x2C00) && (c <= 0x2FEF)) ||
; 3204 : 	        ((c >= 0x3001) && (c <= 0xD7FF)) ||
; 3205 : 	        ((c >= 0xF900) && (c <= 0xFDCF)) ||
; 3206 : 	        ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
; 3207 : 	        ((c >= 0x10000) && (c <= 0xEFFFF))
; 3208 : 		)) {
; 3209 : 	    if (count++ > XML_PARSER_CHUNK_SIZE) {

	mov	eax, ebx
	inc	ebx
	cmp	eax, 100				; 00000064H
	jle	SHORT $LN59@xmlParseNa

; 3210 : 		count = 0;

	xor	ebx, ebx

; 3211 : 		GROW;

	cmp	DWORD PTR [edi+292], ebx
	jne	SHORT $LN58@xmlParseNa
	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN58@xmlParseNa
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN58@xmlParseNa:

; 3212 :                 if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [edi+172], -1
	je	$LN63@xmlParseNa
$LN59@xmlParseNa:

; 3213 :                     return(NULL);
; 3214 : 	    }
; 3215 : 	    len += l;
; 3216 : 	    NEXTL(l);

	mov	ecx, DWORD PTR [edi+36]
	add	esi, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN60@xmlParseNa
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN61@xmlParseNa
$LN60@xmlParseNa:
	inc	DWORD PTR [ecx+32]
$LN61@xmlParseNa:
	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax

; 3217 : 	    c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	call	_xmlCurrentChar
	add	esp, 8
	cmp	eax, 32					; 00000020H
	jne	$LL5@xmlParseNa

; 3238 :                 if (ctxt->instate == XML_PARSER_EOF)

	jmp	$LN14@xmlParseNa
$LN20@xmlParseNa:

; 3218 : 	}
; 3219 :     } else {
; 3220 : 	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */

	cmp	esi, 62					; 0000003eH
	je	$LN63@xmlParseNa
	cmp	esi, 47					; 0000002fH
	je	$LN63@xmlParseNa
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN82@xmlParseNa
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN76@xmlParseNa
	cmp	esi, 90					; 0000005aH
	jle	$LN62@xmlParseNa
$LN76@xmlParseNa:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN77@xmlParseNa
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LN62@xmlParseNa
$LN77@xmlParseNa:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN79@xmlParseNa
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LN62@xmlParseNa
$LN79@xmlParseNa:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN80@xmlParseNa
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LN62@xmlParseNa
$LN80@xmlParseNa:
	cmp	esi, 248				; 000000f8H
	jge	SHORT $LN62@xmlParseNa
	jmp	SHORT $LN191@xmlParseNa
$LN82@xmlParseNa:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN62@xmlParseNa
$LN191@xmlParseNa:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN195@xmlParseNa
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN84@xmlParseNa
	cmp	esi, 40869				; 00009fa5H
	jle	SHORT $LN62@xmlParseNa
$LN84@xmlParseNa:
	cmp	esi, 12295				; 00003007H
	je	SHORT $LN62@xmlParseNa
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN195@xmlParseNa
	cmp	esi, 12329				; 00003029H
	jle	SHORT $LN62@xmlParseNa
$LN195@xmlParseNa:
	cmp	esi, 95					; 0000005fH
	je	SHORT $LN62@xmlParseNa
	cmp	esi, 58					; 0000003aH
	jne	$LN63@xmlParseNa
$LN62@xmlParseNa:

; 3221 : 	    (!IS_LETTER(c) && (c != '_') &&
; 3222 : 	     (c != ':'))) {
; 3223 : 	    return(NULL);
; 3224 : 	}
; 3225 : 	len += l;
; 3226 : 	NEXTL(l);

	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR _l$[ebp]
	mov	DWORD PTR _len$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN64@xmlParseNa
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN65@xmlParseNa
$LN64@xmlParseNa:
	inc	DWORD PTR [ecx+32]
$LN65@xmlParseNa:
	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax

; 3227 : 	c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	call	_xmlCurrentChar
	mov	esi, eax
	add	esp, 8

; 3228 : 
; 3229 : 	while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */

	cmp	esi, 32					; 00000020H
	je	$LN202@xmlParseNa
$LL13@xmlParseNa:
	cmp	esi, 62					; 0000003eH
	je	$LN202@xmlParseNa
	cmp	esi, 47					; 0000002fH
	je	$LN202@xmlParseNa
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN96@xmlParseNa
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN90@xmlParseNa
	cmp	esi, 90					; 0000005aH
	jle	$LN66@xmlParseNa
$LN90@xmlParseNa:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN91@xmlParseNa
	cmp	esi, 122				; 0000007aH
	jle	$LN66@xmlParseNa
$LN91@xmlParseNa:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN93@xmlParseNa
	cmp	esi, 214				; 000000d6H
	jle	$LN66@xmlParseNa
$LN93@xmlParseNa:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN94@xmlParseNa
	cmp	esi, 246				; 000000f6H
	jle	$LN66@xmlParseNa
$LN94@xmlParseNa:
	cmp	esi, 248				; 000000f8H
	jge	$LN66@xmlParseNa
	jmp	SHORT $LN192@xmlParseNa
$LN96@xmlParseNa:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN66@xmlParseNa
$LN192@xmlParseNa:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN204@xmlParseNa
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN98@xmlParseNa
	cmp	esi, 40869				; 00009fa5H
	jle	$LN66@xmlParseNa
$LN98@xmlParseNa:
	cmp	esi, 12295				; 00003007H
	je	$LN66@xmlParseNa
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN196@xmlParseNa
	cmp	esi, 12329				; 00003029H
	jle	SHORT $LN66@xmlParseNa
$LN196@xmlParseNa:
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN106@xmlParseNa
$LN204@xmlParseNa:
	lea	eax, DWORD PTR [esi-48]
	cmp	eax, 9
	ja	SHORT $LN193@xmlParseNa
	jmp	SHORT $LN66@xmlParseNa
$LN106@xmlParseNa:
	push	OFFSET _xmlIsDigitGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN66@xmlParseNa
$LN193@xmlParseNa:
	cmp	esi, 46					; 0000002eH
	je	SHORT $LN66@xmlParseNa
	cmp	esi, 45					; 0000002dH
	je	SHORT $LN66@xmlParseNa
	cmp	esi, 95					; 0000005fH
	je	SHORT $LN66@xmlParseNa
	cmp	esi, 58					; 0000003aH
	je	SHORT $LN66@xmlParseNa
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN197@xmlParseNa
	push	OFFSET _xmlIsCombiningGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN66@xmlParseNa
	push	OFFSET _xmlIsExtenderGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	jmp	SHORT $LN111@xmlParseNa
$LN197@xmlParseNa:
	xor	eax, eax
	cmp	esi, 183				; 000000b7H
	sete	al
$LN111@xmlParseNa:
	test	eax, eax
	je	$LN202@xmlParseNa
$LN66@xmlParseNa:

; 3230 : 	       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
; 3231 : 		(c == '.') || (c == '-') ||
; 3232 : 		(c == '_') || (c == ':') ||
; 3233 : 		(IS_COMBINING(c)) ||
; 3234 : 		(IS_EXTENDER(c)))) {
; 3235 : 	    if (count++ > XML_PARSER_CHUNK_SIZE) {

	mov	eax, ebx
	inc	ebx
	cmp	eax, 100				; 00000064H
	jle	SHORT $LN198@xmlParseNa

; 3236 : 		count = 0;

	xor	ebx, ebx

; 3237 : 		GROW;

	cmp	DWORD PTR [edi+292], ebx
	jne	SHORT $LN68@xmlParseNa
	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN68@xmlParseNa
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN68@xmlParseNa:

; 3238 :                 if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [edi+172], -1
	je	$LN63@xmlParseNa
$LN198@xmlParseNa:

; 3239 :                     return(NULL);
; 3240 : 	    }
; 3241 : 	    len += l;

	mov	eax, DWORD PTR _len$1$[ebp]
	add	eax, DWORD PTR _l$[ebp]

; 3242 : 	    NEXTL(l);

	mov	ecx, DWORD PTR [edi+36]
	mov	DWORD PTR _len$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN70@xmlParseNa
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN71@xmlParseNa
$LN70@xmlParseNa:
	inc	DWORD PTR [ecx+32]
$LN71@xmlParseNa:
	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax

; 3243 : 	    c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	call	_xmlCurrentChar
	mov	esi, eax
	add	esp, 8
	cmp	esi, 32					; 00000020H
	jne	$LL13@xmlParseNa
$LN202@xmlParseNa:

; 3244 : 	}
; 3245 :     }
; 3246 :     if ((len > XML_MAX_NAME_LENGTH) &&

	mov	esi, DWORD PTR _len$1$[ebp]
$LN14@xmlParseNa:
	cmp	esi, 50000				; 0000c350H
	jle	$LN72@xmlParseNa
	test	DWORD PTR [edi+360], 524288		; 00080000H
	jne	SHORT $LN72@xmlParseNa

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edi+212], 0
	je	SHORT $LN115@xmlParseNa
	cmp	DWORD PTR [edi+172], -1
	je	SHORT $LN63@xmlParseNa
$LN115@xmlParseNa:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_04FABLJDN@Name@
	push	OFFSET ??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@
	push	OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04FABLJDN@Name@
	push	0
	push	0
	push	3
	push	110					; 0000006eH
	push	1
	push	0
	push	edi
	push	0
	push	0
	push	0
	mov	DWORD PTR [edi+84], 110			; 0000006eH
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [edi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [edi+288], 0
	jne	SHORT $LN63@xmlParseNa

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [edi+212], 1
$LN63@xmlParseNa:
	pop	edi

; 3264 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN72@xmlParseNa:

; 3247 :         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3248 :         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Name");
; 3249 :         return(NULL);
; 3250 :     }
; 3251 :     if (ctxt->input->cur - ctxt->input->base < len) {

	mov	ecx, DWORD PTR [edi+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, esi
	jge	SHORT $LN73@xmlParseNa

; 3252 :         /*
; 3253 :          * There were a couple of bugs where PERefs lead to to a change
; 3254 :          * of the buffer. Check the buffer size to avoid passing an invalid
; 3255 :          * pointer to xmlDictLookup.
; 3256 :          */
; 3257 :         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CC@JIBKNHBD@unexpected?5change?5of?5input?5buff@
	push	1
	push	edi
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 3264 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN73@xmlParseNa:

; 3258 :                     "unexpected change of input buffer");
; 3259 :         return (NULL);
; 3260 :     }
; 3261 :     if ((*ctxt->input->cur == '\n') && (ctxt->input->cur[-1] == '\r'))

	cmp	BYTE PTR [edx], 10			; 0000000aH
	jne	SHORT $LN74@xmlParseNa
	cmp	BYTE PTR [edx-1], 13			; 0000000dH
	jne	SHORT $LN74@xmlParseNa

; 3262 :         return(xmlDictLookup(ctxt->dict, ctxt->input->cur - (len + 1), len));

	sub	edx, esi
	push	esi
	dec	edx
	push	edx
	push	DWORD PTR [edi+296]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	pop	edi

; 3264 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@xmlParseNa:

; 3263 :     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));

	push	esi
	sub	edx, esi
	push	edx
	push	DWORD PTR [edi+296]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	pop	edi

; 3264 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseNameComplex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseAttValueInternal
_TEXT	SEGMENT
_oldbase$1$ = -20					; size = 4
_line$1$ = -16						; size = 4
_last$1$ = -12						; size = 4
_oldbase$1$ = -12					; size = 4
_ret$1$ = -12						; size = 4
_col$1$ = -8						; size = 4
_limit$1$ = -1						; size = 1
_ctxt$ = 8						; size = 4
_len$ = 12						; size = 4
_alloc$ = 16						; size = 4
_normalize$ = 20					; size = 4
_xmlParseAttValueInternal PROC				; COMDAT

; 8848 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	ecx, OFFSET __B9AC27D5_parser@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edi+292], 0
	jne	SHORT $LN12@xmlParseAt

; 8849 :     xmlChar limit = 0;
; 8850 :     const xmlChar *in = NULL, *start, *end, *last;
; 8851 :     xmlChar *ret = NULL;
; 8852 :     int line, col;
; 8853 : 
; 8854 :     GROW;

	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN12@xmlParseAt
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN12@xmlParseAt:

; 8855 :     in = (xmlChar *) CUR_PTR;

	mov	ecx, DWORD PTR [edi+36]
	mov	esi, DWORD PTR [ecx+16]

; 8856 :     line = ctxt->input->line;

	mov	eax, DWORD PTR [ecx+28]

; 8857 :     col = ctxt->input->col;

	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _line$1$[ebp], eax

; 8858 :     if (*in != '"' && *in != '\'') {

	mov	al, BYTE PTR [esi]
	cmp	al, 34					; 00000022H
	je	SHORT $LN13@xmlParseAt
	cmp	al, 39					; 00000027H
	je	SHORT $LN13@xmlParseAt

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edi+212], 0
	je	SHORT $LN59@xmlParseAt
	cmp	DWORD PTR [edi+172], -1
	je	$LN136@xmlParseAt
$LN59@xmlParseAt:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BK@ELBMECGA@AttValue?3?5?$CC?5or?5?8?5expected@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	39					; 00000027H
	push	1
	push	0
	push	edi
	push	0
	push	0
	push	0
	mov	DWORD PTR [edi+84], 39			; 00000027H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [edi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [edi+288], 0
	jne	$LN136@xmlParseAt

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [edi+212], 1

; 9030 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlParseAt:

; 8859 :         xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
; 8860 :         return (NULL);
; 8861 :     }
; 8862 :     ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
; 8863 : 
; 8864 :     /*
; 8865 :      * try to handle in this routine the most common case where no
; 8866 :      * allocation of a new string is required and where content is
; 8867 :      * pure ASCII.
; 8868 :      */
; 8869 :     limit = *in++;
; 8870 :     col++;

	inc	edx
	mov	DWORD PTR [edi+172], 12			; 0000000cH
	mov	al, BYTE PTR [esi]
	inc	esi
	mov	DWORD PTR _col$1$[ebp], edx

; 8871 :     end = ctxt->input->end;

	mov	edx, DWORD PTR [ecx+20]
	mov	BYTE PTR _limit$1$[ebp], al

; 8872 :     start = in;
; 8873 :     if (in >= end) {

	cmp	esi, edx
	jb	SHORT $LN14@xmlParseAt

; 8874 :         const xmlChar *oldbase = ctxt->input->base;
; 8875 : 	GROW;

	cmp	DWORD PTR [edi+292], 0
	mov	eax, ecx
	mov	ebx, DWORD PTR [ecx+12]
	jne	SHORT $LN15@xmlParseAt
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN15@xmlParseAt
	push	edi
	call	_xmlGROW
	mov	ecx, DWORD PTR [edi+36]
	add	esp, 4
	mov	eax, ecx
$LN15@xmlParseAt:

; 8876 : 	if (oldbase != ctxt->input->base) {

	mov	edx, DWORD PTR [eax+12]
	cmp	ebx, edx
	je	SHORT $LN16@xmlParseAt

; 8877 : 	    long delta = ctxt->input->base - oldbase;
; 8878 : 	    start = start + delta;

	sub	edx, ebx

; 8879 : 	    in = in + delta;

	add	esi, edx
$LN16@xmlParseAt:

; 8880 : 	}
; 8881 : 	end = ctxt->input->end;

	mov	edx, DWORD PTR [eax+20]
$LN14@xmlParseAt:

; 8882 :     }
; 8883 :     if (normalize) {

	cmp	DWORD PTR _normalize$[ebp], 0
	mov	ebx, esi
	je	$LN128@xmlParseAt

; 8884 :         /*
; 8885 : 	 * Skip any leading spaces
; 8886 : 	 */
; 8887 : 	while ((in < end) && (*in != limit) &&

	cmp	esi, edx
	jae	$LN5@xmlParseAt
	mov	eax, esi
	mov	DWORD PTR _ret$1$[ebp], eax
	npad	2
$LL2@xmlParseAt:
	mov	bl, BYTE PTR [esi]
	mov	al, BYTE PTR _limit$1$[ebp]
	cmp	bl, al
	je	$LN159@xmlParseAt
	cmp	bl, 32					; 00000020H
	je	SHORT $LN19@xmlParseAt
	cmp	bl, 9
	je	SHORT $LN19@xmlParseAt
	cmp	bl, 10					; 0000000aH
	je	SHORT $LN19@xmlParseAt
	cmp	bl, 13					; 0000000dH
	jne	$LN159@xmlParseAt
$LN19@xmlParseAt:

; 8888 : 	       ((*in == 0x20) || (*in == 0x9) ||
; 8889 : 	        (*in == 0xA) || (*in == 0xD))) {
; 8890 : 	    if (*in == 0xA) {
; 8891 : 	        line++; col = 1;
; 8892 : 	    } else {
; 8893 : 	        col++;
; 8894 : 	    }
; 8895 : 	    in++;

	mov	eax, DWORD PTR _col$1$[ebp]
	mov	edi, 1
	inc	eax
	cmp	bl, 10					; 0000000aH
	cmovne	edi, eax
	mov	DWORD PTR _col$1$[ebp], edi
	mov	edi, DWORD PTR _line$1$[ebp]
	lea	eax, DWORD PTR [edi+1]
	cmovne	eax, edi

; 8896 : 	    start = in;
; 8897 : 	    if (in >= end) {

	mov	edi, DWORD PTR _ctxt$[ebp]
	inc	esi
	mov	DWORD PTR _line$1$[ebp], eax
	cmp	esi, edx
	jb	SHORT $LN26@xmlParseAt

; 8898 : 		const xmlChar *oldbase = ctxt->input->base;
; 8899 : 		GROW;

	cmp	DWORD PTR [edi+292], 0
	mov	ebx, DWORD PTR [ecx+12]
	jne	SHORT $LN23@xmlParseAt
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [ecx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN23@xmlParseAt
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN23@xmlParseAt:

; 8900 :                 if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [edi+172], -1
	je	$LN136@xmlParseAt

; 8901 :                     return(NULL);
; 8902 : 		if (oldbase != ctxt->input->base) {

	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [ecx+12]
	cmp	ebx, eax
	je	SHORT $LN25@xmlParseAt

; 8903 : 		    long delta = ctxt->input->base - oldbase;
; 8904 : 		    start = start + delta;

	sub	eax, ebx

; 8905 : 		    in = in + delta;

	add	esi, eax
$LN25@xmlParseAt:

; 8906 : 		}
; 8907 : 		end = ctxt->input->end;

	mov	edx, DWORD PTR [ecx+20]
$LN26@xmlParseAt:

; 8884 :         /*
; 8885 : 	 * Skip any leading spaces
; 8886 : 	 */
; 8887 : 	while ((in < end) && (*in != limit) &&

	mov	DWORD PTR _ret$1$[ebp], esi
	mov	eax, esi
	cmp	esi, edx
	jb	$LL2@xmlParseAt

; 8996 :                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&

	mov	eax, DWORD PTR _line$1$[ebp]
	mov	ebx, esi
	mov	DWORD PTR _line$1$[ebp], eax
	mov	eax, DWORD PTR _col$1$[ebp]
	mov	DWORD PTR _col$1$[ebp], eax
	mov	al, BYTE PTR _limit$1$[ebp]
	jmp	SHORT $LN125@xmlParseAt
$LN159@xmlParseAt:

; 8908 :                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&
; 8909 :                     ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 8910 :                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
; 8911 :                                    "AttValue length too long\n");
; 8912 :                     return(NULL);
; 8913 :                 }
; 8914 : 	    }
; 8915 : 	}
; 8916 : 	while ((in < end) && (*in != limit) && (*in >= 0x20) &&
; 8917 : 	       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {

	mov	ebx, DWORD PTR _ret$1$[ebp]
$LN125@xmlParseAt:
	cmp	esi, edx
	jae	$LN5@xmlParseAt
$LL4@xmlParseAt:
	mov	cl, BYTE PTR [esi]
	cmp	cl, al
	je	$LN5@xmlParseAt
	lea	eax, DWORD PTR [ecx-32]
	cmp	al, 95					; 0000005fH
	ja	$LN5@xmlParseAt
	cmp	cl, 38					; 00000026H
	je	$LN5@xmlParseAt
	cmp	cl, 60					; 0000003cH
	je	$LN5@xmlParseAt

; 8918 : 	    col++;

	inc	DWORD PTR _col$1$[ebp]

; 8919 : 	    if ((*in++ == 0x20) && (*in == 0x20)) break;

	inc	esi
	cmp	cl, 32					; 00000020H
	jne	SHORT $LN27@xmlParseAt
	cmp	BYTE PTR [esi], cl
	je	SHORT $LN5@xmlParseAt
$LN27@xmlParseAt:

; 8920 : 	    if (in >= end) {

	mov	al, BYTE PTR _limit$1$[ebp]
	cmp	esi, edx
	jb	SHORT $LL4@xmlParseAt

; 8921 : 		const xmlChar *oldbase = ctxt->input->base;
; 8922 : 		GROW;

	cmp	DWORD PTR [edi+292], 0
	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _oldbase$1$[ebp], eax
	jne	SHORT $LN29@xmlParseAt
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [ecx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN29@xmlParseAt
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN29@xmlParseAt:

; 8923 :                 if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [edi+172], -1
	je	$LN136@xmlParseAt

; 8924 :                     return(NULL);
; 8925 : 		if (oldbase != ctxt->input->base) {

	mov	edx, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR _oldbase$1$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	ecx, eax
	je	SHORT $LN31@xmlParseAt

; 8926 : 		    long delta = ctxt->input->base - oldbase;

	sub	eax, ecx

; 8927 : 		    start = start + delta;

	add	ebx, eax

; 8928 : 		    in = in + delta;

	add	esi, eax
$LN31@xmlParseAt:

; 8929 : 		}
; 8930 : 		end = ctxt->input->end;

	mov	edx, DWORD PTR [edx+20]

; 8931 :                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&

	mov	eax, esi
	sub	eax, ebx
	cmp	eax, 10000000				; 00989680H
	jle	SHORT $LN149@xmlParseAt
	test	DWORD PTR [edi+360], 524288		; 00080000H
	je	$LN151@xmlParseAt
$LN149@xmlParseAt:

; 8908 :                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&
; 8909 :                     ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 8910 :                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
; 8911 :                                    "AttValue length too long\n");
; 8912 :                     return(NULL);
; 8913 :                 }
; 8914 : 	    }
; 8915 : 	}
; 8916 : 	while ((in < end) && (*in != limit) && (*in >= 0x20) &&
; 8917 : 	       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {

	mov	al, BYTE PTR _limit$1$[ebp]
	cmp	esi, edx
	jb	$LL4@xmlParseAt
$LN5@xmlParseAt:

; 8932 :                     ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 8933 :                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
; 8934 :                                    "AttValue length too long\n");
; 8935 :                     return(NULL);
; 8936 :                 }
; 8937 : 	    }
; 8938 : 	}
; 8939 : 	last = in;
; 8940 : 	/*
; 8941 : 	 * skip the trailing blanks
; 8942 : 	 */
; 8943 : 	while ((last[-1] == 0x20) && (last > start)) last--;

	cmp	BYTE PTR [esi-1], 32			; 00000020H
	lea	ecx, DWORD PTR [esi-1]
	mov	eax, esi
	mov	DWORD PTR _last$1$[ebp], eax
	jne	SHORT $LN152@xmlParseAt
$LL6@xmlParseAt:
	cmp	eax, ebx
	jbe	SHORT $LN152@xmlParseAt
	mov	eax, ecx
	cmp	BYTE PTR [eax-1], 32			; 00000020H
	lea	ecx, DWORD PTR [eax-1]
	mov	DWORD PTR _last$1$[ebp], eax
	je	SHORT $LL6@xmlParseAt
$LN152@xmlParseAt:

; 8944 : 	while ((in < end) && (*in != limit) &&

	cmp	esi, edx
	jae	$LN9@xmlParseAt
	npad	6
$LL8@xmlParseAt:
	mov	cl, BYTE PTR [esi]
	cmp	cl, BYTE PTR _limit$1$[ebp]
	je	$LN9@xmlParseAt
	cmp	cl, 32					; 00000020H
	je	SHORT $LN33@xmlParseAt
	cmp	cl, 9
	je	SHORT $LN33@xmlParseAt
	cmp	cl, 10					; 0000000aH
	je	SHORT $LN33@xmlParseAt
	cmp	cl, 13					; 0000000dH
	jne	$LN9@xmlParseAt
$LN33@xmlParseAt:

; 8945 : 	       ((*in == 0x20) || (*in == 0x9) ||
; 8946 : 	        (*in == 0xA) || (*in == 0xD))) {
; 8947 : 	    if (*in == 0xA) {
; 8948 : 	        line++, col = 1;
; 8949 : 	    } else {
; 8950 : 	        col++;
; 8951 : 	    }
; 8952 : 	    in++;

	mov	eax, DWORD PTR _col$1$[ebp]
	mov	edi, 1
	inc	eax
	cmp	cl, 10					; 0000000aH
	cmovne	edi, eax
	mov	DWORD PTR _col$1$[ebp], edi
	mov	edi, DWORD PTR _line$1$[ebp]
	lea	eax, DWORD PTR [edi+1]
	cmovne	eax, edi

; 8953 : 	    if (in >= end) {

	mov	edi, DWORD PTR _ctxt$[ebp]
	inc	esi
	mov	DWORD PTR _line$1$[ebp], eax
	cmp	esi, edx
	jb	SHORT $LL8@xmlParseAt

; 8954 : 		const xmlChar *oldbase = ctxt->input->base;
; 8955 : 		GROW;

	cmp	DWORD PTR [edi+292], 0
	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _oldbase$1$[ebp], eax
	jne	SHORT $LN37@xmlParseAt
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [ecx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN37@xmlParseAt
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN37@xmlParseAt:

; 8956 :                 if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [edi+172], -1
	je	$LN136@xmlParseAt

; 8957 :                     return(NULL);
; 8958 : 		if (oldbase != ctxt->input->base) {

	mov	edx, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR _oldbase$1$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	ecx, eax
	je	SHORT $LN39@xmlParseAt

; 8959 : 		    long delta = ctxt->input->base - oldbase;

	sub	eax, ecx

; 8960 : 		    start = start + delta;

	add	ebx, eax

; 8961 : 		    in = in + delta;

	add	esi, eax

; 8962 : 		    last = last + delta;

	add	DWORD PTR _last$1$[ebp], eax
$LN39@xmlParseAt:

; 8963 : 		}
; 8964 : 		end = ctxt->input->end;

	mov	edx, DWORD PTR [edx+20]

; 8965 :                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&

	mov	eax, esi
	sub	eax, ebx
	cmp	eax, 10000000				; 00989680H
	jle	SHORT $LN160@xmlParseAt
	test	DWORD PTR [edi+360], 524288		; 00080000H
	je	$LN151@xmlParseAt
$LN160@xmlParseAt:

; 8944 : 	while ((in < end) && (*in != limit) &&

	mov	eax, DWORD PTR _line$1$[ebp]
	cmp	esi, edx
	jb	$LL8@xmlParseAt

; 8996 :                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&

	mov	DWORD PTR _line$1$[ebp], eax
	mov	eax, DWORD PTR _col$1$[ebp]
	mov	DWORD PTR _col$1$[ebp], eax
$LN9@xmlParseAt:

; 8966 :                     ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 8967 :                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
; 8968 :                                    "AttValue length too long\n");
; 8969 :                     return(NULL);
; 8970 :                 }
; 8971 : 	    }
; 8972 : 	}
; 8973 :         if (((in - start) > XML_MAX_TEXT_LENGTH) &&

	mov	eax, esi
	sub	eax, ebx
	cmp	eax, 10000000				; 00989680H
	jle	SHORT $LN41@xmlParseAt
	test	DWORD PTR [edi+360], 524288		; 00080000H
	je	$LN151@xmlParseAt
$LN41@xmlParseAt:

; 8974 :             ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 8975 :             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
; 8976 :                            "AttValue length too long\n");
; 8977 :             return(NULL);
; 8978 :         }
; 8979 : 	if (*in != limit) goto need_complex;

	mov	al, BYTE PTR _limit$1$[ebp]
	cmp	BYTE PTR [esi], al
	jne	$need_complex$163

; 8980 :     } else {

	mov	ecx, DWORD PTR _last$1$[ebp]
$LN49@xmlParseAt:

; 9012 :     }
; 9013 :     in++;
; 9014 :     col++;

	inc	DWORD PTR _col$1$[ebp]
	inc	esi

; 9015 :     if (len != NULL) {

	mov	eax, DWORD PTR _len$[ebp]
	test	eax, eax
	je	$LN50@xmlParseAt

; 9016 :         *len = last - start;

	sub	ecx, ebx
	mov	DWORD PTR [eax], ecx

; 9017 :         ret = (xmlChar *) start;
; 9018 :     } else {

	jmp	$LN51@xmlParseAt
$LN128@xmlParseAt:

; 8981 : 	while ((in < end) && (*in != limit) && (*in >= 0x20) &&
; 8982 : 	       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {

	cmp	esi, edx
	jae	$LN11@xmlParseAt
	mov	DWORD PTR _ret$1$[ebp], esi
$LL10@xmlParseAt:
	mov	bl, BYTE PTR [esi]
	cmp	bl, BYTE PTR _limit$1$[ebp]
	je	$LN156@xmlParseAt
	lea	eax, DWORD PTR [ebx-32]
	cmp	al, 95					; 0000005fH
	ja	SHORT $LN156@xmlParseAt
	cmp	bl, 38					; 00000026H
	je	SHORT $LN156@xmlParseAt
	cmp	bl, 60					; 0000003cH
	je	SHORT $LN156@xmlParseAt

; 8983 : 	    in++;
; 8984 : 	    col++;

	inc	DWORD PTR _col$1$[ebp]
	inc	esi

; 8985 : 	    if (in >= end) {

	cmp	esi, edx
	jb	SHORT $LL10@xmlParseAt

; 8986 : 		const xmlChar *oldbase = ctxt->input->base;
; 8987 : 		GROW;

	cmp	DWORD PTR [edi+292], 0
	mov	ebx, DWORD PTR [ecx+12]
	jne	SHORT $LN44@xmlParseAt
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [ecx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN44@xmlParseAt
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN44@xmlParseAt:

; 8988 :                 if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [edi+172], -1
	je	SHORT $LN136@xmlParseAt

; 8989 :                     return(NULL);
; 8990 : 		if (oldbase != ctxt->input->base) {

	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [ecx+12]
	cmp	ebx, eax
	je	SHORT $LN157@xmlParseAt

; 8991 : 		    long delta = ctxt->input->base - oldbase;

	sub	eax, ebx

; 8992 : 		    start = start + delta;

	mov	ebx, DWORD PTR _ret$1$[ebp]
	add	ebx, eax

; 8993 : 		    in = in + delta;

	add	esi, eax
	mov	DWORD PTR _ret$1$[ebp], ebx
	jmp	SHORT $LN46@xmlParseAt
$LN157@xmlParseAt:

; 8989 :                     return(NULL);
; 8990 : 		if (oldbase != ctxt->input->base) {

	mov	ebx, DWORD PTR _ret$1$[ebp]
$LN46@xmlParseAt:

; 8994 : 		}
; 8995 : 		end = ctxt->input->end;

	mov	edx, DWORD PTR [ecx+20]

; 8996 :                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&

	mov	eax, esi
	sub	eax, ebx
	cmp	eax, 10000000				; 00989680H
	jle	SHORT $LN150@xmlParseAt
	test	DWORD PTR [edi+360], 524288		; 00080000H
	je	SHORT $LN151@xmlParseAt
$LN150@xmlParseAt:

; 8981 : 	while ((in < end) && (*in != limit) && (*in >= 0x20) &&
; 8982 : 	       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {

	cmp	esi, edx
	jb	$LL10@xmlParseAt

; 8996 :                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&

	jmp	SHORT $LN11@xmlParseAt
$LN156@xmlParseAt:

; 8997 :                     ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 8998 :                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
; 8999 :                                    "AttValue length too long\n");
; 9000 :                     return(NULL);
; 9001 :                 }
; 9002 : 	    }
; 9003 : 	}
; 9004 : 	last = in;

	mov	ebx, DWORD PTR _ret$1$[ebp]
$LN11@xmlParseAt:

; 9005 :         if (((in - start) > XML_MAX_TEXT_LENGTH) &&

	mov	eax, esi
	mov	ecx, esi
	sub	eax, ebx
	cmp	eax, 10000000				; 00989680H
	jle	SHORT $LN48@xmlParseAt
	test	DWORD PTR [edi+360], 524288		; 00080000H
	jne	SHORT $LN48@xmlParseAt
$LN151@xmlParseAt:

; 9006 :             ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 9007 :             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,

	push	OFFSET ??_C@_0BK@JCFIEKOP@AttValue?5length?5too?5long?6@
	push	40					; 00000028H
	push	edi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN136@xmlParseAt:

; 9030 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@xmlParseAt:

; 9008 :                            "AttValue length too long\n");
; 9009 :             return(NULL);
; 9010 :         }
; 9011 : 	if (*in != limit) goto need_complex;

	mov	al, BYTE PTR _limit$1$[ebp]
	cmp	BYTE PTR [esi], al
	je	$LN49@xmlParseAt
$need_complex$163:

; 9026 :     return ret;
; 9027 : need_complex:
; 9028 :     if (alloc) *alloc = 1;

	mov	eax, DWORD PTR _alloc$[ebp]
	test	eax, eax
	je	SHORT $LN54@xmlParseAt
	mov	DWORD PTR [eax], 1
$LN54@xmlParseAt:

; 9029 :     return xmlParseAttValueComplex(ctxt, len, normalize);

	push	DWORD PTR _normalize$[ebp]
	push	DWORD PTR _len$[ebp]
	push	edi
	call	_xmlParseAttValueComplex
	add	esp, 12					; 0000000cH
	pop	edi

; 9030 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@xmlParseAt:

; 9019 :         if (alloc) *alloc = 1;

	mov	eax, DWORD PTR _alloc$[ebp]
	test	eax, eax
	je	SHORT $LN52@xmlParseAt
	mov	DWORD PTR [eax], 1
$LN52@xmlParseAt:

; 9020 :         ret = xmlStrndup(start, last - start);

	sub	ecx, ebx
	push	ecx
	push	ebx
	call	_xmlStrndup
	add	esp, 8
	mov	ebx, eax
$LN51@xmlParseAt:

; 9021 :     }
; 9022 :     CUR_PTR = in;

	mov	ecx, DWORD PTR [edi+36]

; 9023 :     ctxt->input->line = line;

	mov	eax, DWORD PTR _line$1$[ebp]
	mov	DWORD PTR [ecx+16], esi
	mov	ecx, DWORD PTR [edi+36]
	mov	DWORD PTR [ecx+28], eax

; 9024 :     ctxt->input->col = col;

	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR _col$1$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 9025 :     if (alloc) *alloc = 0;

	mov	eax, DWORD PTR _alloc$[ebp]
	test	eax, eax
	je	SHORT $LN53@xmlParseAt
	mov	DWORD PTR [eax], 0
$LN53@xmlParseAt:
	pop	edi

; 9030 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseAttValueInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlIsNameChar
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_c$ = 12						; size = 4
_xmlIsNameChar PROC					; COMDAT

; 3104 : xmlIsNameChar(xmlParserCtxtPtr ctxt, int c) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	DWORD PTR [eax+360], 131072		; 00020000H
	jne	$LN2@xmlIsNameC

; 3105 :     if ((ctxt->options & XML_PARSE_OLD10) == 0) {
; 3106 :         /*
; 3107 : 	 * Use the new checks of production [4] [4a] amd [5] of the
; 3108 : 	 * Update 5 of XML-1.0
; 3109 : 	 */
; 3110 : 	if ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */

	mov	eax, DWORD PTR _c$[ebp]
	cmp	eax, 32					; 00000020H
	je	$LN22@xmlIsNameC
	cmp	eax, 62					; 0000003eH
	je	$LN22@xmlIsNameC
	cmp	eax, 47					; 0000002fH
	je	$LN22@xmlIsNameC
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN6@xmlIsNameC
	cmp	eax, 122				; 0000007aH
	jle	$LN23@xmlIsNameC
$LN6@xmlIsNameC:
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN7@xmlIsNameC
	cmp	eax, 90					; 0000005aH
	jle	$LN23@xmlIsNameC
$LN7@xmlIsNameC:
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN8@xmlIsNameC
	cmp	eax, 57					; 00000039H
	jle	$LN23@xmlIsNameC
$LN8@xmlIsNameC:
	cmp	eax, 95					; 0000005fH
	je	$LN23@xmlIsNameC
	cmp	eax, 58					; 0000003aH
	je	$LN23@xmlIsNameC
	cmp	eax, 45					; 0000002dH
	je	$LN23@xmlIsNameC
	cmp	eax, 46					; 0000002eH
	je	$LN23@xmlIsNameC
	cmp	eax, 183				; 000000b7H
	je	$LN23@xmlIsNameC
	cmp	eax, 192				; 000000c0H
	jl	SHORT $LN9@xmlIsNameC
	cmp	eax, 214				; 000000d6H
	jle	$LN23@xmlIsNameC
$LN9@xmlIsNameC:
	cmp	eax, 216				; 000000d8H
	jl	SHORT $LN10@xmlIsNameC
	cmp	eax, 246				; 000000f6H
	jle	$LN23@xmlIsNameC
$LN10@xmlIsNameC:
	cmp	eax, 248				; 000000f8H
	jl	SHORT $LN11@xmlIsNameC
	cmp	eax, 767				; 000002ffH
	jle	$LN23@xmlIsNameC
$LN11@xmlIsNameC:
	cmp	eax, 768				; 00000300H
	jl	SHORT $LN12@xmlIsNameC
	cmp	eax, 879				; 0000036fH
	jle	$LN23@xmlIsNameC
$LN12@xmlIsNameC:
	cmp	eax, 880				; 00000370H
	jl	SHORT $LN13@xmlIsNameC
	cmp	eax, 893				; 0000037dH
	jle	$LN23@xmlIsNameC
$LN13@xmlIsNameC:
	cmp	eax, 895				; 0000037fH
	jl	SHORT $LN14@xmlIsNameC
	cmp	eax, 8191				; 00001fffH
	jle	SHORT $LN23@xmlIsNameC
$LN14@xmlIsNameC:
	cmp	eax, 8204				; 0000200cH
	jl	SHORT $LN15@xmlIsNameC
	cmp	eax, 8205				; 0000200dH
	jle	SHORT $LN23@xmlIsNameC
$LN15@xmlIsNameC:
	cmp	eax, 8255				; 0000203fH
	jl	SHORT $LN16@xmlIsNameC
	cmp	eax, 8256				; 00002040H
	jle	SHORT $LN23@xmlIsNameC
$LN16@xmlIsNameC:
	cmp	eax, 8304				; 00002070H
	jl	SHORT $LN17@xmlIsNameC
	cmp	eax, 8591				; 0000218fH
	jle	SHORT $LN23@xmlIsNameC
$LN17@xmlIsNameC:
	cmp	eax, 11264				; 00002c00H
	jl	SHORT $LN18@xmlIsNameC
	cmp	eax, 12271				; 00002fefH
	jle	SHORT $LN23@xmlIsNameC
$LN18@xmlIsNameC:
	cmp	eax, 12289				; 00003001H
	jl	SHORT $LN19@xmlIsNameC
	cmp	eax, 55295				; 0000d7ffH
	jle	SHORT $LN23@xmlIsNameC
$LN19@xmlIsNameC:
	cmp	eax, 63744				; 0000f900H
	jl	SHORT $LN20@xmlIsNameC
	cmp	eax, 64975				; 0000fdcfH
	jle	SHORT $LN23@xmlIsNameC
$LN20@xmlIsNameC:
	cmp	eax, 65008				; 0000fdf0H
	jl	SHORT $LN21@xmlIsNameC
	cmp	eax, 65533				; 0000fffdH
	jle	SHORT $LN23@xmlIsNameC
$LN21@xmlIsNameC:
	add	eax, -65536				; ffff0000H
	cmp	eax, 917503				; 000dffffH
	ja	$LN22@xmlIsNameC
$LN23@xmlIsNameC:

; 3136 : 	    (IS_EXTENDER(c)))
; 3137 : 	    return(1);

	mov	eax, 1
	pop	esi

; 3140 : }

	pop	ebp
	ret	0
$LN2@xmlIsNameC:

; 3111 : 	    (((c >= 'a') && (c <= 'z')) ||
; 3112 : 	     ((c >= 'A') && (c <= 'Z')) ||
; 3113 : 	     ((c >= '0') && (c <= '9')) || /* !start */
; 3114 : 	     (c == '_') || (c == ':') ||
; 3115 : 	     (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
; 3116 : 	     ((c >= 0xC0) && (c <= 0xD6)) ||
; 3117 : 	     ((c >= 0xD8) && (c <= 0xF6)) ||
; 3118 : 	     ((c >= 0xF8) && (c <= 0x2FF)) ||
; 3119 : 	     ((c >= 0x300) && (c <= 0x36F)) || /* !start */
; 3120 : 	     ((c >= 0x370) && (c <= 0x37D)) ||
; 3121 : 	     ((c >= 0x37F) && (c <= 0x1FFF)) ||
; 3122 : 	     ((c >= 0x200C) && (c <= 0x200D)) ||
; 3123 : 	     ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
; 3124 : 	     ((c >= 0x2070) && (c <= 0x218F)) ||
; 3125 : 	     ((c >= 0x2C00) && (c <= 0x2FEF)) ||
; 3126 : 	     ((c >= 0x3001) && (c <= 0xD7FF)) ||
; 3127 : 	     ((c >= 0xF900) && (c <= 0xFDCF)) ||
; 3128 : 	     ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
; 3129 : 	     ((c >= 0x10000) && (c <= 0xEFFFF))))
; 3130 : 	     return(1);
; 3131 :     } else {
; 3132 :         if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
; 3133 :             (c == '.') || (c == '-') ||
; 3134 : 	    (c == '_') || (c == ':') ||
; 3135 : 	    (IS_COMBINING(c)) ||

	mov	esi, DWORD PTR _c$[ebp]
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN31@xmlIsNameC
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN25@xmlIsNameC
	cmp	esi, 90					; 0000005aH
	jle	SHORT $LN23@xmlIsNameC
$LN25@xmlIsNameC:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN26@xmlIsNameC
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LN23@xmlIsNameC
$LN26@xmlIsNameC:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN28@xmlIsNameC
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LN23@xmlIsNameC
$LN28@xmlIsNameC:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN29@xmlIsNameC
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LN23@xmlIsNameC
$LN29@xmlIsNameC:
	cmp	esi, 248				; 000000f8H
	jge	SHORT $LN23@xmlIsNameC
	jmp	SHORT $LN47@xmlIsNameC
$LN31@xmlIsNameC:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN23@xmlIsNameC
$LN47@xmlIsNameC:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN53@xmlIsNameC
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN33@xmlIsNameC
	cmp	esi, 40869				; 00009fa5H
	jle	SHORT $LN23@xmlIsNameC
$LN33@xmlIsNameC:
	cmp	esi, 12295				; 00003007H
	je	$LN23@xmlIsNameC
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN50@xmlIsNameC
	cmp	esi, 12329				; 00003029H
	jle	$LN23@xmlIsNameC
$LN50@xmlIsNameC:
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN41@xmlIsNameC
$LN53@xmlIsNameC:
	lea	eax, DWORD PTR [esi-48]
	cmp	eax, 9
	ja	SHORT $LN48@xmlIsNameC

; 3136 : 	    (IS_EXTENDER(c)))
; 3137 : 	    return(1);

	mov	eax, 1
	pop	esi

; 3140 : }

	pop	ebp
	ret	0
$LN41@xmlIsNameC:

; 3111 : 	    (((c >= 'a') && (c <= 'z')) ||
; 3112 : 	     ((c >= 'A') && (c <= 'Z')) ||
; 3113 : 	     ((c >= '0') && (c <= '9')) || /* !start */
; 3114 : 	     (c == '_') || (c == ':') ||
; 3115 : 	     (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
; 3116 : 	     ((c >= 0xC0) && (c <= 0xD6)) ||
; 3117 : 	     ((c >= 0xD8) && (c <= 0xF6)) ||
; 3118 : 	     ((c >= 0xF8) && (c <= 0x2FF)) ||
; 3119 : 	     ((c >= 0x300) && (c <= 0x36F)) || /* !start */
; 3120 : 	     ((c >= 0x370) && (c <= 0x37D)) ||
; 3121 : 	     ((c >= 0x37F) && (c <= 0x1FFF)) ||
; 3122 : 	     ((c >= 0x200C) && (c <= 0x200D)) ||
; 3123 : 	     ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
; 3124 : 	     ((c >= 0x2070) && (c <= 0x218F)) ||
; 3125 : 	     ((c >= 0x2C00) && (c <= 0x2FEF)) ||
; 3126 : 	     ((c >= 0x3001) && (c <= 0xD7FF)) ||
; 3127 : 	     ((c >= 0xF900) && (c <= 0xFDCF)) ||
; 3128 : 	     ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
; 3129 : 	     ((c >= 0x10000) && (c <= 0xEFFFF))))
; 3130 : 	     return(1);
; 3131 :     } else {
; 3132 :         if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
; 3133 :             (c == '.') || (c == '-') ||
; 3134 : 	    (c == '_') || (c == ':') ||
; 3135 : 	    (IS_COMBINING(c)) ||

	push	OFFSET _xmlIsDigitGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN23@xmlIsNameC
$LN48@xmlIsNameC:
	cmp	esi, 46					; 0000002eH
	je	$LN23@xmlIsNameC
	cmp	esi, 45					; 0000002dH
	je	$LN23@xmlIsNameC
	cmp	esi, 95					; 0000005fH
	je	$LN23@xmlIsNameC
	cmp	esi, 58					; 0000003aH
	je	$LN23@xmlIsNameC
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN51@xmlIsNameC
	push	OFFSET _xmlIsCombiningGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN23@xmlIsNameC
	push	OFFSET _xmlIsExtenderGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	jmp	SHORT $LN46@xmlIsNameC
$LN51@xmlIsNameC:
	xor	eax, eax
	cmp	esi, 183				; 000000b7H
	sete	al
$LN46@xmlIsNameC:
	test	eax, eax
	jne	$LN23@xmlIsNameC
$LN22@xmlIsNameC:

; 3138 :     }
; 3139 :     return(0);

	xor	eax, eax
	pop	esi

; 3140 : }

	pop	ebp
	ret	0
_xmlIsNameChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlIsNameStartChar
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_c$ = 12						; size = 4
_xmlIsNameStartChar PROC				; COMDAT

; 3073 : xmlIsNameStartChar(xmlParserCtxtPtr ctxt, int c) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	DWORD PTR [eax+360], 131072		; 00020000H
	jne	$LN2@xmlIsNameS

; 3074 :     if ((ctxt->options & XML_PARSE_OLD10) == 0) {
; 3075 :         /*
; 3076 : 	 * Use the new checks of production [4] [4a] amd [5] of the
; 3077 : 	 * Update 5 of XML-1.0
; 3078 : 	 */
; 3079 : 	if ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */

	mov	eax, DWORD PTR _c$[ebp]
	cmp	eax, 32					; 00000020H
	je	$LN19@xmlIsNameS
	cmp	eax, 62					; 0000003eH
	je	$LN19@xmlIsNameS
	cmp	eax, 47					; 0000002fH
	je	$LN19@xmlIsNameS
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN6@xmlIsNameS
	cmp	eax, 122				; 0000007aH
	jle	$LN20@xmlIsNameS
$LN6@xmlIsNameS:
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN7@xmlIsNameS
	cmp	eax, 90					; 0000005aH
	jle	$LN20@xmlIsNameS
$LN7@xmlIsNameS:
	cmp	eax, 95					; 0000005fH
	je	$LN20@xmlIsNameS
	cmp	eax, 58					; 0000003aH
	je	$LN20@xmlIsNameS
	cmp	eax, 192				; 000000c0H
	jl	SHORT $LN8@xmlIsNameS
	cmp	eax, 214				; 000000d6H
	jle	$LN20@xmlIsNameS
$LN8@xmlIsNameS:
	cmp	eax, 216				; 000000d8H
	jl	SHORT $LN9@xmlIsNameS
	cmp	eax, 246				; 000000f6H
	jle	$LN20@xmlIsNameS
$LN9@xmlIsNameS:
	cmp	eax, 248				; 000000f8H
	jl	SHORT $LN10@xmlIsNameS
	cmp	eax, 767				; 000002ffH
	jle	$LN20@xmlIsNameS
$LN10@xmlIsNameS:
	cmp	eax, 880				; 00000370H
	jl	SHORT $LN11@xmlIsNameS
	cmp	eax, 893				; 0000037dH
	jle	SHORT $LN20@xmlIsNameS
$LN11@xmlIsNameS:
	cmp	eax, 895				; 0000037fH
	jl	SHORT $LN12@xmlIsNameS
	cmp	eax, 8191				; 00001fffH
	jle	SHORT $LN20@xmlIsNameS
$LN12@xmlIsNameS:
	cmp	eax, 8204				; 0000200cH
	jl	SHORT $LN13@xmlIsNameS
	cmp	eax, 8205				; 0000200dH
	jle	SHORT $LN20@xmlIsNameS
$LN13@xmlIsNameS:
	cmp	eax, 8304				; 00002070H
	jl	SHORT $LN14@xmlIsNameS
	cmp	eax, 8591				; 0000218fH
	jle	SHORT $LN20@xmlIsNameS
$LN14@xmlIsNameS:
	cmp	eax, 11264				; 00002c00H
	jl	SHORT $LN15@xmlIsNameS
	cmp	eax, 12271				; 00002fefH
	jle	SHORT $LN20@xmlIsNameS
$LN15@xmlIsNameS:
	cmp	eax, 12289				; 00003001H
	jl	SHORT $LN16@xmlIsNameS
	cmp	eax, 55295				; 0000d7ffH
	jle	SHORT $LN20@xmlIsNameS
$LN16@xmlIsNameS:
	cmp	eax, 63744				; 0000f900H
	jl	SHORT $LN17@xmlIsNameS
	cmp	eax, 64975				; 0000fdcfH
	jle	SHORT $LN20@xmlIsNameS
$LN17@xmlIsNameS:
	cmp	eax, 65008				; 0000fdf0H
	jl	SHORT $LN18@xmlIsNameS
	cmp	eax, 65533				; 0000fffdH
	jle	SHORT $LN20@xmlIsNameS
$LN18@xmlIsNameS:
	add	eax, -65536				; ffff0000H
	cmp	eax, 917503				; 000dffffH
	ja	$LN19@xmlIsNameS
$LN20@xmlIsNameS:

; 3098 : 	    return(1);

	mov	eax, 1
	pop	esi

; 3101 : }

	pop	ebp
	ret	0
$LN2@xmlIsNameS:

; 3080 : 	    (((c >= 'a') && (c <= 'z')) ||
; 3081 : 	     ((c >= 'A') && (c <= 'Z')) ||
; 3082 : 	     (c == '_') || (c == ':') ||
; 3083 : 	     ((c >= 0xC0) && (c <= 0xD6)) ||
; 3084 : 	     ((c >= 0xD8) && (c <= 0xF6)) ||
; 3085 : 	     ((c >= 0xF8) && (c <= 0x2FF)) ||
; 3086 : 	     ((c >= 0x370) && (c <= 0x37D)) ||
; 3087 : 	     ((c >= 0x37F) && (c <= 0x1FFF)) ||
; 3088 : 	     ((c >= 0x200C) && (c <= 0x200D)) ||
; 3089 : 	     ((c >= 0x2070) && (c <= 0x218F)) ||
; 3090 : 	     ((c >= 0x2C00) && (c <= 0x2FEF)) ||
; 3091 : 	     ((c >= 0x3001) && (c <= 0xD7FF)) ||
; 3092 : 	     ((c >= 0xF900) && (c <= 0xFDCF)) ||
; 3093 : 	     ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
; 3094 : 	     ((c >= 0x10000) && (c <= 0xEFFFF))))
; 3095 : 	    return(1);
; 3096 :     } else {
; 3097 :         if (IS_LETTER(c) || (c == '_') || (c == ':'))

	mov	esi, DWORD PTR _c$[ebp]
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN28@xmlIsNameS
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN22@xmlIsNameS
	cmp	esi, 90					; 0000005aH
	jle	SHORT $LN20@xmlIsNameS
$LN22@xmlIsNameS:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN23@xmlIsNameS
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LN20@xmlIsNameS
$LN23@xmlIsNameS:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN25@xmlIsNameS
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LN20@xmlIsNameS
$LN25@xmlIsNameS:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN26@xmlIsNameS
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LN20@xmlIsNameS
$LN26@xmlIsNameS:
	cmp	esi, 248				; 000000f8H
	jge	SHORT $LN20@xmlIsNameS
	jmp	SHORT $LN36@xmlIsNameS
$LN28@xmlIsNameS:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@xmlIsNameS
$LN36@xmlIsNameS:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN37@xmlIsNameS
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN30@xmlIsNameS
	cmp	esi, 40869				; 00009fa5H
	jle	SHORT $LN20@xmlIsNameS
$LN30@xmlIsNameS:
	cmp	esi, 12295				; 00003007H
	je	$LN20@xmlIsNameS
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN37@xmlIsNameS
	cmp	esi, 12329				; 00003029H
	jle	$LN20@xmlIsNameS
$LN37@xmlIsNameS:
	cmp	esi, 95					; 0000005fH
	je	$LN20@xmlIsNameS
	cmp	esi, 58					; 0000003aH
	je	$LN20@xmlIsNameS
$LN19@xmlIsNameS:

; 3099 :     }
; 3100 :     return(0);

	xor	eax, eax
	pop	esi

; 3101 : }

	pop	ebp
	ret	0
_xmlIsNameStartChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _areBlanks
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_len$ = 16						; size = 4
_blank_chars$ = 20					; size = 4
_areBlanks PROC						; COMDAT

; 2808 :                      int blank_chars) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+72]
	cmp	eax, DWORD PTR [ecx+68]
	je	$LN7@areBlanks

; 2809 :     int i, ret;
; 2810 :     xmlNodePtr lastChild;
; 2811 : 
; 2812 :     /*
; 2813 :      * Don't spend time trying to differentiate them, the same callback is
; 2814 :      * used !
; 2815 :      */
; 2816 :     if (ctxt->sax->ignorableWhitespace == ctxt->sax->characters)
; 2817 : 	return(0);
; 2818 : 
; 2819 :     /*
; 2820 :      * Check for xml:space value.
; 2821 :      */
; 2822 :     if ((ctxt->space == NULL) || (*(ctxt->space) == 1) ||

	mov	eax, DWORD PTR [esi+232]
	test	eax, eax
	je	$LN7@areBlanks
	mov	eax, DWORD PTR [eax]
	cmp	eax, 1
	je	$LN7@areBlanks
	cmp	eax, -2					; fffffffeH
	je	$LN7@areBlanks

; 2825 : 
; 2826 :     /*
; 2827 :      * Check that the string is made of blanks
; 2828 :      */
; 2829 :     if (blank_chars == 0) {

	cmp	DWORD PTR _blank_chars$[ebp], 0
	jne	SHORT $LN3@areBlanks

; 2830 : 	for (i = 0;i < len;i++)

	mov	edx, DWORD PTR _len$[ebp]
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN3@areBlanks
	mov	edi, DWORD PTR _str$[ebp]
$LL4@areBlanks:

; 2831 : 	    if (!(IS_BLANK_CH(str[i]))) return(0);

	mov	al, BYTE PTR [ecx+edi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN2@areBlanks
	cmp	al, 9
	jb	SHORT $LN10@areBlanks
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN2@areBlanks
$LN10@areBlanks:
	cmp	al, 13					; 0000000dH
	jne	$LN7@areBlanks
$LN2@areBlanks:

; 2830 : 	for (i = 0;i < len;i++)

	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LL4@areBlanks
$LN3@areBlanks:

; 2832 :     }
; 2833 : 
; 2834 :     /*
; 2835 :      * Look if the element is mixed content in the DTD if available
; 2836 :      */
; 2837 :     if (ctxt->node == NULL) return(0);

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	$LN7@areBlanks

; 2838 :     if (ctxt->myDoc != NULL) {

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN30@areBlanks

; 2839 : 	ret = xmlIsMixedElement(ctxt->myDoc, ctxt->node->name);

	push	DWORD PTR [eax+8]
	push	ecx
	call	_xmlIsMixedElement
	add	esp, 8

; 2840 :         if (ret == 0) return(1);

	test	eax, eax
	jne	SHORT $LN13@areBlanks
$LN22@areBlanks:
	pop	edi

; 2858 :              (xmlNodeIsText(ctxt->node->children)))
; 2859 :         return(0);
; 2860 :     return(1);
; 2861 : }

	mov	eax, 1
	pop	esi
	pop	ebp
	ret	0
$LN13@areBlanks:

; 2841 :         if (ret == 1) return(0);

	cmp	eax, 1
	je	SHORT $LN7@areBlanks
$LN30@areBlanks:

; 2842 :     }
; 2843 : 
; 2844 :     /*
; 2845 :      * Otherwise, heuristic :-\
; 2846 :      */
; 2847 :     if ((RAW != '<') && (RAW != 0xD)) return(0);

	mov	eax, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [eax+16]
	mov	al, BYTE PTR [edx]
	cmp	al, 60					; 0000003cH
	je	SHORT $LN15@areBlanks
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN7@areBlanks
$LN15@areBlanks:

; 2848 :     if ((ctxt->node->children == NULL) &&
; 2849 : 	(RAW == '<') && (NXT(1) == '/')) return(0);

	mov	ecx, DWORD PTR [esi+52]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN16@areBlanks
	cmp	al, 60					; 0000003cH
	jne	SHORT $LN16@areBlanks
	cmp	BYTE PTR [edx+1], 47			; 0000002fH
	je	SHORT $LN7@areBlanks
$LN16@areBlanks:

; 2850 : 
; 2851 :     lastChild = xmlGetLastChild(ctxt->node);

	push	ecx
	call	_xmlGetLastChild
	add	esp, 4

; 2852 :     if (lastChild == NULL) {

	test	eax, eax
	jne	SHORT $LN17@areBlanks

; 2853 :         if ((ctxt->node->type != XML_ELEMENT_NODE) &&

	mov	eax, DWORD PTR [esi+52]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN22@areBlanks
	cmp	DWORD PTR [eax+40], 0
	jmp	SHORT $LN31@areBlanks
$LN17@areBlanks:

; 2854 :             (ctxt->node->content != NULL)) return(0);
; 2855 :     } else if (xmlNodeIsText(lastChild))

	push	eax
	call	_xmlNodeIsText
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN7@areBlanks

; 2856 :         return(0);
; 2857 :     else if ((ctxt->node->children != NULL) &&

	mov	eax, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN22@areBlanks
	push	eax
	call	_xmlNodeIsText
	add	esp, 4
	test	eax, eax
$LN31@areBlanks:

; 2823 :         (*(ctxt->space) == -2))
; 2824 : 	return(0);

	je	SHORT $LN22@areBlanks
$LN7@areBlanks:
	pop	edi
	xor	eax, eax

; 2858 :              (xmlNodeIsText(ctxt->node->children)))
; 2859 :         return(0);
; 2860 :     return(1);
; 2861 : }

	pop	esi
	pop	ebp
	ret	0
_areBlanks ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseStringCharRef
_TEXT	SEGMENT
_outofrange$1$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParseStringCharRef PROC				; COMDAT

; 2394 : xmlParseStringCharRef(xmlParserCtxtPtr ctxt, const xmlChar **str) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _str$[ebp]
	xor	edx, edx
	xor	eax, eax
	mov	DWORD PTR _outofrange$1$[ebp], edx
	test	ecx, ecx
	je	$LN7@xmlParseSt

; 2395 :     const xmlChar *ptr;
; 2396 :     xmlChar cur;
; 2397 :     unsigned int val = 0;
; 2398 :     unsigned int outofrange = 0;
; 2399 : 
; 2400 :     if ((str == NULL) || (*str == NULL)) return(0);

	mov	esi, DWORD PTR [ecx]
	test	esi, esi
	je	$LN7@xmlParseSt

; 2401 :     ptr = *str;
; 2402 :     cur = *ptr;

	mov	cl, BYTE PTR [esi]

; 2403 :     if ((cur == '&') && (ptr[1] == '#') && (ptr[2] == 'x')) {

	cmp	cl, 38					; 00000026H
	jne	$LN18@xmlParseSt
	mov	cl, BYTE PTR [esi+1]
	lea	edi, DWORD PTR [esi+2]
	cmp	cl, 35					; 00000023H
	jne	$LN18@xmlParseSt
	cmp	BYTE PTR [edi], 120			; 00000078H
	jne	SHORT $LN116@xmlParseSt

; 2404 : 	ptr += 3;
; 2405 : 	cur = *ptr;

	mov	bl, BYTE PTR [esi+3]
	add	esi, 3

; 2406 : 	while (cur != ';') { /* Non input consuming loop */

	cmp	bl, 59					; 0000003bH
	je	SHORT $LN3@xmlParseSt
$LL2@xmlParseSt:

; 2407 : 	    if ((cur >= '0') && (cur <= '9'))

	lea	ecx, DWORD PTR [ebx-48]
	cmp	cl, 9
	ja	SHORT $LN10@xmlParseSt

; 2408 : 	        val = val * 16 + (cur - '0');

	shl	eax, 4
	add	eax, -48				; ffffffd0H
	jmp	SHORT $LN118@xmlParseSt
$LN10@xmlParseSt:

; 2409 : 	    else if ((cur >= 'a') && (cur <= 'f'))

	lea	ecx, DWORD PTR [ebx-97]
	cmp	cl, 5
	ja	SHORT $LN12@xmlParseSt

; 2410 : 	        val = val * 16 + (cur - 'a') + 10;

	shl	eax, 4
	add	eax, -87				; ffffffa9H
	jmp	SHORT $LN118@xmlParseSt
$LN12@xmlParseSt:

; 2411 : 	    else if ((cur >= 'A') && (cur <= 'F'))

	lea	ecx, DWORD PTR [ebx-65]
	cmp	cl, 5
	ja	SHORT $LN14@xmlParseSt

; 2412 : 	        val = val * 16 + (cur - 'A') + 10;

	shl	eax, 4
	add	eax, -55				; ffffffc9H
$LN118@xmlParseSt:

; 2416 : 		break;
; 2417 : 	    }
; 2418 : 	    if (val > 0x10FFFF)
; 2419 : 	        outofrange = val;
; 2420 : 
; 2421 : 	    ptr++;

	movzx	ecx, bl

; 2422 : 	    cur = *ptr;

	mov	bl, BYTE PTR [esi+1]
	add	eax, ecx
	cmp	eax, 1114111				; 0010ffffH
	mov	ecx, eax
	cmovbe	ecx, edx
	inc	esi
	mov	edx, ecx
	mov	DWORD PTR _outofrange$1$[ebp], edx
	cmp	bl, 59					; 0000003bH
	jne	SHORT $LL2@xmlParseSt

; 2423 : 	}
; 2424 : 	if (cur == ';')
; 2425 : 	    ptr++;
; 2426 :     } else if  ((cur == '&') && (ptr[1] == '#')){

	cmp	bl, bl
	mov	DWORD PTR _outofrange$1$[ebp], edx
	lea	edi, DWORD PTR [esi+1]
	cmovne	edi, esi
	jmp	SHORT $LN23@xmlParseSt
$LN14@xmlParseSt:

; 2413 : 	    else {
; 2414 : 		xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);

	push	0
	push	6
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 2415 : 		val = 0;

	xor	eax, eax
$LN3@xmlParseSt:

; 2423 : 	}
; 2424 : 	if (cur == ';')
; 2425 : 	    ptr++;
; 2426 :     } else if  ((cur == '&') && (ptr[1] == '#')){

	cmp	bl, 59					; 0000003bH
	lea	edi, DWORD PTR [esi+1]
	cmovne	edi, esi
	jmp	SHORT $LN23@xmlParseSt
$LN116@xmlParseSt:
	cmp	cl, 35					; 00000023H
	jne	$LN18@xmlParseSt

; 2427 : 	ptr += 2;
; 2428 : 	cur = *ptr;

	mov	bl, BYTE PTR [edi]

; 2429 : 	while (cur != ';') { /* Non input consuming loops */

	cmp	bl, 59					; 0000003bH
	je	SHORT $LN113@xmlParseSt
	npad	5
$LL4@xmlParseSt:

; 2430 : 	    if ((cur >= '0') && (cur <= '9'))

	lea	ecx, DWORD PTR [ebx-48]
	cmp	cl, 9
	ja	SHORT $LN20@xmlParseSt

; 2431 : 	        val = val * 10 + (cur - '0');

	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, bl

; 2435 : 		break;
; 2436 : 	    }
; 2437 : 	    if (val > 0x10FFFF)
; 2438 : 	        outofrange = val;
; 2439 : 
; 2440 : 	    ptr++;
; 2441 : 	    cur = *ptr;

	mov	bl, BYTE PTR [edi+1]
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, -48				; ffffffd0H
	cmp	eax, 1114111				; 0010ffffH
	mov	ecx, eax
	cmovbe	ecx, edx
	inc	edi
	mov	edx, ecx
	mov	DWORD PTR _outofrange$1$[ebp], edx
	cmp	bl, 59					; 0000003bH
	jne	SHORT $LL4@xmlParseSt

; 2395 :     const xmlChar *ptr;
; 2396 :     xmlChar cur;
; 2397 :     unsigned int val = 0;
; 2398 :     unsigned int outofrange = 0;
; 2399 : 
; 2400 :     if ((str == NULL) || (*str == NULL)) return(0);

	mov	DWORD PTR _outofrange$1$[ebp], edx
	jmp	SHORT $LN113@xmlParseSt
$LN20@xmlParseSt:

; 2432 : 	    else {
; 2433 : 		xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);

	push	0
	push	7
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 2434 : 		val = 0;

	xor	eax, eax

; 2442 : 	}
; 2443 : 	if (cur == ';')

	cmp	bl, 59					; 0000003bH
	jne	SHORT $LN23@xmlParseSt
$LN113@xmlParseSt:

; 2444 : 	    ptr++;

	inc	edi
$LN23@xmlParseSt:

; 2445 :     } else {
; 2446 : 	xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
; 2447 : 	return(0);
; 2448 :     }
; 2449 :     *str = ptr;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	DWORD PTR [ecx], edi

; 2450 : 
; 2451 :     /*
; 2452 :      * [ WFC: Legal Character ]
; 2453 :      * Characters referred to using character references must match the
; 2454 :      * production for Char.
; 2455 :      */
; 2456 :     if ((IS_CHAR(val) && (outofrange == 0))) {

	cmp	eax, 256				; 00000100H
	jae	SHORT $LN35@xmlParseSt
	cmp	eax, 9
	jb	SHORT $LN27@xmlParseSt
	cmp	eax, 10					; 0000000aH
	jbe	SHORT $LN115@xmlParseSt
$LN27@xmlParseSt:
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN115@xmlParseSt
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN115@xmlParseSt
	jmp	SHORT $LN24@xmlParseSt
$LN35@xmlParseSt:
	cmp	eax, 55295				; 0000d7ffH
	jbe	SHORT $LN115@xmlParseSt
	cmp	eax, 57344				; 0000e000H
	jb	SHORT $LN30@xmlParseSt
	cmp	eax, 65533				; 0000fffdH
	jbe	SHORT $LN115@xmlParseSt
$LN30@xmlParseSt:
	lea	ecx, DWORD PTR [eax-65536]
	cmp	ecx, 1048575				; 000fffffH
	ja	SHORT $LN24@xmlParseSt
$LN115@xmlParseSt:
	cmp	DWORD PTR _outofrange$1$[ebp], 0
	je	$LN1@xmlParseSt
$LN24@xmlParseSt:

; 2457 :         return(val);
; 2458 :     } else {
; 2459 :         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,

	push	eax
	push	OFFSET ??_C@_0DB@EJFBNJEE@xmlParseStringCharRef?3?5invalid?5@
	push	9
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H

; 2460 : 			  "xmlParseStringCharRef: invalid xmlChar value %d\n",
; 2461 : 			  val);
; 2462 :     }
; 2463 :     return(0);
; 2464 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlParseSt:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN99@xmlParseSt
	cmp	DWORD PTR [esi+212], eax
	je	SHORT $LN40@xmlParseSt
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN7@xmlParseSt
$LN40@xmlParseSt:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;

	mov	DWORD PTR [esi+84], 8
$LN99@xmlParseSt:

; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BH@OCLALBPG@CharRef?3?5invalid?5value@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	8
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN7@xmlParseSt

; 553  : 	ctxt->wellFormed = 0;
; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+12], 0
	jne	SHORT $LN7@xmlParseSt

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN7@xmlParseSt:

; 2460 : 			  "xmlParseStringCharRef: invalid xmlChar value %d\n",
; 2461 : 			  val);
; 2462 :     }
; 2463 :     return(0);
; 2464 : }

	xor	eax, eax
$LN1@xmlParseSt:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseStringCharRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlGROW
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlGROW PROC						; COMDAT

; 2079 : static void xmlGROW (xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [ecx+16]
	sub	eax, edx
	cmp	eax, 10000000				; 00989680H
	ja	SHORT $LN3@xmlGROW

; 2080 :     unsigned long curEnd = ctxt->input->end - ctxt->input->cur;
; 2081 :     unsigned long curBase = ctxt->input->cur - ctxt->input->base;
; 2082 : 
; 2083 :     if (((curEnd > (unsigned long) XML_MAX_LOOKUP_LIMIT) ||
; 2084 :          (curBase > (unsigned long) XML_MAX_LOOKUP_LIMIT)) &&
; 2085 :          ((ctxt->input->buf) &&
; 2086 :           (ctxt->input->buf->readcallback != xmlInputReadCallbackNop)) &&

	sub	edx, DWORD PTR [ecx+12]
	cmp	edx, 10000000				; 00989680H
	jbe	SHORT $LN2@xmlGROW
$LN3@xmlGROW:
	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN2@xmlGROW
	cmp	DWORD PTR [eax+4], OFFSET _xmlInputReadCallbackNop
	je	SHORT $LN2@xmlGROW
	test	DWORD PTR [esi+360], 524288		; 00080000H
	jne	SHORT $LN2@xmlGROW

; 2087 :         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 2088 :         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "Huge input lookup");

	push	OFFSET ??_C@_0BC@BAMNGBKO@Huge?5input?5lookup@
	push	1
	push	esi
	call	_xmlFatalErr

; 2089 :         xmlHaltParser(ctxt);

	push	esi
	call	_xmlHaltParser

; 2101 : }

	add	esp, 16					; 00000010H
	pop	esi
	pop	ebp
	ret	0
$LN2@xmlGROW:

; 2090 : 	return;
; 2091 :     }
; 2092 :     xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow

; 2093 :     if ((ctxt->input->cur > ctxt->input->end) ||

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 8
	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [ecx+20]
	ja	SHORT $LN5@xmlGROW
	cmp	eax, DWORD PTR [ecx+12]
	jb	SHORT $LN5@xmlGROW

; 2097 : 	return;
; 2098 :     }
; 2099 :     if ((ctxt->input->cur != NULL) && (*ctxt->input->cur == 0))

	test	eax, eax
	je	SHORT $LN6@xmlGROW
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN6@xmlGROW

; 2100 :         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
	pop	esi

; 2101 : }

	pop	ebp
	ret	0
$LN5@xmlGROW:

; 2094 :         (ctxt->input->cur < ctxt->input->base)) {
; 2095 :         xmlHaltParser(ctxt);

	push	esi
	call	_xmlHaltParser

; 2096 :         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "cur index out of bound");

	push	OFFSET ??_C@_0BH@JOKBAJC@cur?5index?5out?5of?5bound@
	push	1
	push	esi
	call	_xmlFatalErr

; 2101 : }

	add	esp, 16					; 00000010H
$LN6@xmlGROW:
	pop	esi
	pop	ebp
	ret	0
_xmlGROW ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSHRINK
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSHRINK PROC						; COMDAT

; 2069 : static void xmlSHRINK (xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [esi+36]
	call	_xmlParserInputShrink
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [ecx+16]
	pop	esi
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlSHRINK

; 2070 :     xmlParserInputShrink(ctxt->input);
; 2071 :     if (*ctxt->input->cur == 0)
; 2072 :         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlSHRINK:

; 2073 : }

	pop	ebp
	ret	0
_xmlSHRINK ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _spacePop
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_spacePop PROC						; COMDAT

; 1973 : static int spacePop(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	test	ecx, ecx
	jg	SHORT $LN2@spacePop

; 1974 :     int ret;
; 1975 :     if (ctxt->spaceNr <= 0) return(0);

	xor	eax, eax

; 1984 : }

	pop	ebp
	ret	0
$LN2@spacePop:

; 1976 :     ctxt->spaceNr--;
; 1977 :     if (ctxt->spaceNr > 0)

	mov	edx, DWORD PTR [eax+244]
	dec	ecx
	mov	DWORD PTR [eax+236], ecx
	test	ecx, ecx
	jle	SHORT $LN4@spacePop

; 1978 : 	ctxt->space = &ctxt->spaceTab[ctxt->spaceNr - 1];

	lea	edx, DWORD PTR [edx+ecx*4]
	add	edx, -4					; fffffffcH
$LN4@spacePop:

; 1979 :     else
; 1980 :         ctxt->space = &ctxt->spaceTab[0];
; 1981 :     ret = ctxt->spaceTab[ctxt->spaceNr];

	mov	DWORD PTR [eax+232], edx
	mov	eax, DWORD PTR [eax+244]
	mov	edx, DWORD PTR [eax+ecx*4]

; 1982 :     ctxt->spaceTab[ctxt->spaceNr] = -1;

	mov	DWORD PTR [eax+ecx*4], -1

; 1983 :     return(ret);

	mov	eax, edx

; 1984 : }

	pop	ebp
	ret	0
_spacePop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _spacePush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_val$ = 12						; size = 4
_spacePush PROC						; COMDAT

; 1954 : static int spacePush(xmlParserCtxtPtr ctxt, int val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [esi+236]
	mov	eax, DWORD PTR [esi+240]
	cmp	edx, eax
	jl	SHORT $LN6@spacePush

; 1955 :     if (ctxt->spaceNr >= ctxt->spaceMax) {
; 1956 :         int *tmp;
; 1957 : 
; 1958 : 	ctxt->spaceMax *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+240], eax

; 1959 :         tmp = (int *) xmlRealloc(ctxt->spaceTab,

	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+244]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1960 : 	                         ctxt->spaceMax * sizeof(ctxt->spaceTab[0]));
; 1961 :         if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN3@spacePush

; 1962 : 	    xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory

; 1963 : 	    ctxt->spaceMax /=2;

	mov	eax, DWORD PTR [esi+240]
	add	esp, 8
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [esi+240], eax

; 1964 : 	    return(-1);

	or	eax, -1
	pop	esi

; 1971 : }

	pop	ebp
	ret	0
$LN3@spacePush:

; 1965 : 	}
; 1966 : 	ctxt->spaceTab = tmp;

	mov	edx, DWORD PTR [esi+236]
	mov	DWORD PTR [esi+244], eax
$LN6@spacePush:

; 1967 :     }
; 1968 :     ctxt->spaceTab[ctxt->spaceNr] = val;

	mov	ecx, DWORD PTR [esi+244]
	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1969 :     ctxt->space = &ctxt->spaceTab[ctxt->spaceNr];

	mov	eax, DWORD PTR [esi+236]
	mov	ecx, DWORD PTR [esi+244]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+232], ecx

; 1970 :     return(ctxt->spaceNr++);

	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+236], ecx
	pop	esi

; 1971 : }

	pop	ebp
	ret	0
_spacePush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _nameNsPop
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nameNsPop PROC						; COMDAT

; 1881 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+188]
	test	ecx, ecx
	jg	SHORT $LN2@nameNsPop

; 1882 :     const xmlChar *ret;
; 1883 : 
; 1884 :     if (ctxt->nameNr <= 0)
; 1885 :         return (NULL);

	xor	eax, eax

; 1894 : }

	pop	ebp
	ret	0
$LN2@nameNsPop:

; 1886 :     ctxt->nameNr--;

	dec	ecx
	mov	DWORD PTR [edx+188], ecx

; 1887 :     if (ctxt->nameNr > 0)

	test	ecx, ecx
	jle	SHORT $LN3@nameNsPop

; 1888 :         ctxt->name = ctxt->nameTab[ctxt->nameNr - 1];

	mov	eax, DWORD PTR [edx+196]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN4@nameNsPop
$LN3@nameNsPop:

; 1889 :     else
; 1890 :         ctxt->name = NULL;

	xor	eax, eax
$LN4@nameNsPop:

; 1891 :     ret = ctxt->nameTab[ctxt->nameNr];

	mov	DWORD PTR [edx+184], eax
	mov	eax, DWORD PTR [edx+196]
	mov	edx, DWORD PTR [eax+ecx*4]

; 1892 :     ctxt->nameTab[ctxt->nameNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 1893 :     return (ret);

	mov	eax, edx

; 1894 : }

	pop	ebp
	ret	0
_nameNsPop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _nameNsPush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_prefix$ = 16						; size = 4
_URI$ = 20						; size = 4
_nsNr$ = 24						; size = 4
_nameNsPush PROC					; COMDAT

; 1839 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [esi+188]
	mov	eax, DWORD PTR [esi+192]
	cmp	edx, eax
	jl	SHORT $LN7@nameNsPush

; 1840 :     if (ctxt->nameNr >= ctxt->nameMax) {
; 1841 :         const xmlChar * *tmp;
; 1842 :         void **tmp2;
; 1843 :         ctxt->nameMax *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+192], eax

; 1844 :         tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt->nameTab,

	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+196]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1845 :                                     ctxt->nameMax *
; 1846 :                                     sizeof(ctxt->nameTab[0]));
; 1847 :         if (tmp == NULL) {

	test	eax, eax
	je	SHORT $LN8@nameNsPush

; 1848 : 	    ctxt->nameMax /= 2;
; 1849 : 	    goto mem_error;
; 1850 :         }
; 1851 : 	ctxt->nameTab = tmp;

	mov	DWORD PTR [esi+196], eax

; 1852 :         tmp2 = (void **) xmlRealloc((void * *)ctxt->pushTab,

	mov	eax, DWORD PTR [esi+192]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+344]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1853 :                                     ctxt->nameMax * 3 *
; 1854 :                                     sizeof(ctxt->pushTab[0]));
; 1855 :         if (tmp2 == NULL) {

	test	eax, eax
	jne	SHORT $LN4@nameNsPush
$LN8@nameNsPush:

; 1867 : mem_error:
; 1868 :     xmlErrMemory(ctxt, NULL);

	mov	eax, DWORD PTR [esi+192]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [esi+192], eax
$mem_error$10:
	push	0
	push	esi
	call	_xmlErrMemory
	add	esp, 8

; 1869 :     return (-1);

	or	eax, -1
	pop	esi

; 1870 : }

	pop	ebp
	ret	0
$LN4@nameNsPush:

; 1856 : 	    ctxt->nameMax /= 2;
; 1857 : 	    goto mem_error;
; 1858 :         }
; 1859 : 	ctxt->pushTab = tmp2;

	mov	edx, DWORD PTR [esi+188]
	mov	DWORD PTR [esi+344], eax
$LN7@nameNsPush:

; 1860 :     }
; 1861 :     ctxt->nameTab[ctxt->nameNr] = value;

	mov	eax, DWORD PTR [esi+196]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1862 :     ctxt->name = value;
; 1863 :     ctxt->pushTab[ctxt->nameNr * 3] = (void *) prefix;

	mov	eax, DWORD PTR [esi+188]
	mov	DWORD PTR [esi+184], ecx
	mov	ecx, DWORD PTR [esi+344]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR _prefix$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1864 :     ctxt->pushTab[ctxt->nameNr * 3 + 1] = (void *) URI;

	mov	eax, DWORD PTR [esi+188]
	mov	ecx, DWORD PTR [esi+344]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR _URI$[ebp]
	mov	DWORD PTR [ecx+edx*4+4], eax

; 1865 :     ctxt->pushTab[ctxt->nameNr * 3 + 2] = (void *) (ptrdiff_t) nsNr;

	mov	eax, DWORD PTR [esi+188]
	mov	ecx, DWORD PTR [esi+344]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR _nsNr$[ebp]
	mov	DWORD PTR [ecx+edx*4+8], eax

; 1866 :     return (ctxt->nameNr++);

	mov	eax, DWORD PTR [esi+188]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+188], ecx
	pop	esi

; 1870 : }

	pop	ebp
	ret	0
_nameNsPush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtGrowAttrs
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nr$ = 12						; size = 4
_xmlCtxtGrowAttrs PROC					; COMDAT

; 1668 : xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi+300]
	test	ecx, ecx
	jne	SHORT $LN2@xmlCtxtGro

; 1669 :     const xmlChar **atts;
; 1670 :     int *attallocs;
; 1671 :     int maxatts;
; 1672 : 
; 1673 :     if (ctxt->atts == NULL) {
; 1674 : 	maxatts = 55; /* allow for 10 attrs by default */
; 1675 : 	atts = (const xmlChar **)

	push	220					; 000000dcH
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 1676 : 	       xmlMalloc(maxatts * sizeof(xmlChar *));
; 1677 : 	if (atts == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$11

; 1678 : 	ctxt->atts = atts;
; 1679 : 	attallocs = (int *) xmlMalloc((maxatts / 5) * sizeof(int));

	push	44					; 0000002cH
	mov	DWORD PTR [esi+300], eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 1680 : 	if (attallocs == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$11

; 1681 : 	ctxt->attallocs = attallocs;

	mov	DWORD PTR [esi+340], eax

; 1682 : 	ctxt->maxatts = maxatts;

	mov	edi, 55					; 00000037H
	mov	DWORD PTR [esi+304], 55			; 00000037H
$LN6@xmlCtxtGro:

; 1693 : 	ctxt->maxatts = maxatts;
; 1694 :     }
; 1695 :     return(ctxt->maxatts);

	mov	eax, edi
	pop	edi

; 1699 : }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlCtxtGro:

; 1683 :     } else if (nr + 5 > ctxt->maxatts) {

	mov	eax, DWORD PTR _nr$[ebp]
	mov	edi, DWORD PTR [esi+304]
	add	eax, 5
	cmp	eax, edi
	jle	SHORT $LN6@xmlCtxtGro

; 1684 : 	maxatts = (nr + 5) * 2;

	lea	edi, DWORD PTR [eax+eax]

; 1685 : 	atts = (const xmlChar **) xmlRealloc((void *) ctxt->atts,

	lea	eax, DWORD PTR [edi*4]
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1686 : 				     maxatts * sizeof(const xmlChar *));
; 1687 : 	if (atts == NULL) goto mem_error;

	test	eax, eax
	je	SHORT $mem_error$11

; 1688 : 	ctxt->atts = atts;

	mov	DWORD PTR [esi+300], eax

; 1689 : 	attallocs = (int *) xmlRealloc((void *) ctxt->attallocs,

	mov	eax, 1717986919				; 66666667H
	imul	edi
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+340]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1690 : 	                             (maxatts / 5) * sizeof(int));
; 1691 : 	if (attallocs == NULL) goto mem_error;

	test	eax, eax
	je	SHORT $mem_error$11

; 1692 : 	ctxt->attallocs = attallocs;

	mov	DWORD PTR [esi+340], eax

; 1693 : 	ctxt->maxatts = maxatts;
; 1694 :     }
; 1695 :     return(ctxt->maxatts);

	mov	eax, edi
	mov	DWORD PTR [esi+304], edi
	pop	edi

; 1699 : }

	pop	esi
	pop	ebp
	ret	0
$mem_error$11:

; 1696 : mem_error:
; 1697 :     xmlErrMemory(ctxt, NULL);

	push	0
	push	esi
	call	_xmlErrMemory
	add	esp, 8

; 1698 :     return(-1);

	or	eax, -1
	pop	edi

; 1699 : }

	pop	esi
	pop	ebp
	ret	0
_xmlCtxtGrowAttrs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _nsPop
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nr$ = 12						; size = 4
_nsPop	PROC						; COMDAT

; 1648 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+336], 0
	je	SHORT $LN13@nsPop

; 1649 :     int i;
; 1650 : 
; 1651 :     if (ctxt->nsTab == NULL) return(0);
; 1652 :     if (ctxt->nsNr < nr) {

	mov	eax, DWORD PTR [esi+328]
	mov	ebx, DWORD PTR _nr$[ebp]
	cmp	eax, ebx
	jge	SHORT $LN6@nsPop

; 1653 :         xmlGenericError(xmlGenericErrorContext, "Pbm popping %d NS\n", nr);

	call	___xmlGenericErrorContext
	mov	edi, DWORD PTR [eax]
	call	___xmlGenericError
	push	ebx
	push	OFFSET ??_C@_0BD@KIFBOAFI@Pbm?5popping?5?$CFd?5NS?6@
	push	edi
	mov	eax, DWORD PTR [eax]
	call	eax

; 1654 :         nr = ctxt->nsNr;

	mov	eax, DWORD PTR [esi+328]
	add	esp, 12					; 0000000cH
	mov	ebx, eax
$LN6@nsPop:

; 1655 :     }
; 1656 :     if (ctxt->nsNr <= 0)

	test	eax, eax
	jle	SHORT $LN13@nsPop

; 1657 :         return (0);
; 1658 : 
; 1659 :     for (i = 0;i < nr;i++) {

	test	ebx, ebx
	jle	SHORT $LN3@nsPop
	mov	edi, ebx
	npad	11
$LL4@nsPop:

; 1660 :          ctxt->nsNr--;

	dec	DWORD PTR [esi+328]
	mov	edx, DWORD PTR [esi+328]

; 1661 : 	 ctxt->nsTab[ctxt->nsNr] = NULL;

	mov	ecx, DWORD PTR [esi+336]
	mov	DWORD PTR [ecx+edx*4], 0
	sub	edi, 1
	jne	SHORT $LL4@nsPop
$LN3@nsPop:
	pop	edi

; 1662 :     }
; 1663 :     return(nr);
; 1664 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	0
$LN13@nsPop:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_nsPop	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _nsPush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_prefix$ = 12						; size = 4
_URL$ = 16						; size = 4
_nsPush	PROC						; COMDAT

; 1598 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	test	DWORD PTR [esi+360], 8192		; 00002000H
	mov	ebx, DWORD PTR _prefix$[ebp]
	je	SHORT $LN7@nsPush

; 1599 :     if (ctxt->options & XML_PARSE_NSCLEAN) {
; 1600 :         int i;
; 1601 : 	for (i = ctxt->nsNr - 2;i >= 0;i -= 2) {

	mov	eax, DWORD PTR [esi+328]
	sub	eax, 2
	js	SHORT $LN7@nsPush

; 1602 : 	    if (ctxt->nsTab[i] == prefix) {

	mov	ecx, DWORD PTR [esi+336]
$LL4@nsPush:
	cmp	DWORD PTR [ecx+eax*4], ebx
	je	SHORT $LN16@nsPush

; 1599 :     if (ctxt->options & XML_PARSE_NSCLEAN) {
; 1600 :         int i;
; 1601 : 	for (i = ctxt->nsNr - 2;i >= 0;i -= 2) {

	sub	eax, 2
	jns	SHORT $LL4@nsPush
$LN7@nsPush:

; 1606 : 		/* out of scope keep it */
; 1607 : 		break;
; 1608 : 	    }
; 1609 : 	}
; 1610 :     }
; 1611 :     if ((ctxt->nsMax == 0) || (ctxt->nsTab == NULL)) {

	mov	eax, DWORD PTR [esi+332]
	push	edi
	test	eax, eax
	je	$LN21@nsPush
	mov	ecx, DWORD PTR [esi+336]
	test	ecx, ecx
	je	$LN21@nsPush

; 1620 : 	}
; 1621 :     } else if (ctxt->nsNr >= ctxt->nsMax) {

	cmp	DWORD PTR [esi+328], eax
	jl	SHORT $LN11@nsPush

; 1622 :         const xmlChar ** tmp;
; 1623 :         ctxt->nsMax *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+332], eax

; 1624 :         tmp = (const xmlChar **) xmlRealloc((char *) ctxt->nsTab,

	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8

; 1625 : 				    ctxt->nsMax * sizeof(ctxt->nsTab[0]));
; 1626 :         if (tmp == NULL) {

	test	ecx, ecx
	jne	SHORT $LN13@nsPush

; 1627 :             xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory

; 1628 : 	    ctxt->nsMax /= 2;

	mov	eax, DWORD PTR [esi+332]
	add	esp, 8
	cdq
	sub	eax, edx
	sar	eax, 1
	pop	edi
	mov	DWORD PTR [esi+332], eax

; 1629 :             return (-1);

	or	eax, -1
	pop	esi

; 1635 :     return (ctxt->nsNr);
; 1636 : }

	pop	ebx
	pop	ebp
	ret	0
$LN16@nsPush:

; 1603 : 		/* in scope */
; 1604 : 	        if (ctxt->nsTab[i + 1] == URL)

	mov	edx, DWORD PTR _URL$[ebp]
	cmp	DWORD PTR [ecx+eax*4+4], edx
	jne	SHORT $LN7@nsPush

; 1605 : 		    return(-2);

	pop	esi
	mov	eax, -2					; fffffffeH

; 1635 :     return (ctxt->nsNr);
; 1636 : }

	pop	ebx
	pop	ebp
	ret	0
$LN13@nsPush:

; 1630 :         }
; 1631 : 	ctxt->nsTab = tmp;

	mov	DWORD PTR [esi+336], ecx
$LN11@nsPush:

; 1632 :     }
; 1633 :     ctxt->nsTab[ctxt->nsNr++] = prefix;

	mov	eax, DWORD PTR [esi+328]

; 1634 :     ctxt->nsTab[ctxt->nsNr++] = URL;

	mov	edx, DWORD PTR _URL$[ebp]
	pop	edi
	mov	DWORD PTR [ecx+eax*4], ebx
	inc	DWORD PTR [esi+328]
	mov	ecx, DWORD PTR [esi+328]
	mov	eax, DWORD PTR [esi+336]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR [esi+328]
	inc	eax
	mov	DWORD PTR [esi+328], eax
	pop	esi

; 1635 :     return (ctxt->nsNr);
; 1636 : }

	pop	ebx
	pop	ebp
	ret	0
$LN21@nsPush:

; 1612 : 	ctxt->nsMax = 10;
; 1613 : 	ctxt->nsNr = 0;
; 1614 : 	ctxt->nsTab = (const xmlChar **)

	push	40					; 00000028H
	mov	DWORD PTR [esi+332], 10			; 0000000aH
	mov	DWORD PTR [esi+328], 0
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [esi+336], ecx

; 1615 : 	              xmlMalloc(ctxt->nsMax * sizeof(xmlChar *));
; 1616 : 	if (ctxt->nsTab == NULL) {

	test	ecx, ecx
	jne	SHORT $LN11@nsPush

; 1617 : 	    xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory
	add	esp, 8

; 1618 : 	    ctxt->nsMax = 0;

	mov	DWORD PTR [esi+332], 0

; 1619 :             return (-1);

	or	eax, -1
	pop	edi
	pop	esi

; 1635 :     return (ctxt->nsNr);
; 1636 : }

	pop	ebx
	pop	ebp
	ret	0
_nsPush	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseStringEntityRef
_TEXT	SEGMENT
_ptr$2$ = -4						; size = 4
_ptr$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParseStringEntityRef PROC				; COMDAT

; 7637 : xmlParseStringEntityRef(xmlParserCtxtPtr ctxt, const xmlChar ** str) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _str$[ebp]
	xor	ebx, ebx
	test	eax, eax
	je	$LN5@xmlParseSt

; 7638 :     xmlChar *name;
; 7639 :     const xmlChar *ptr;
; 7640 :     xmlChar cur;
; 7641 :     xmlEntityPtr ent = NULL;
; 7642 : 
; 7643 :     if ((str == NULL) || (*str == NULL))

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	$LN5@xmlParseSt

; 7645 :     ptr = *str;
; 7646 :     cur = *ptr;
; 7647 :     if (cur != '&')

	cmp	BYTE PTR [eax], 38			; 00000026H
	jne	$LN5@xmlParseSt

; 7648 : 	return(NULL);
; 7649 : 
; 7650 :     ptr++;

	push	esi

; 7651 :     name = xmlParseStringName(ctxt, &ptr);

	mov	esi, DWORD PTR _ctxt$[ebp]
	inc	eax
	mov	DWORD PTR _ptr$[ebp], eax
	lea	eax, DWORD PTR _ptr$[ebp]
	push	edi
	push	eax
	push	esi
	call	_xmlParseStringName
	mov	edi, eax
	add	esp, 8

; 7652 :     if (name == NULL) {

	test	edi, edi
	jne	SHORT $LN7@xmlParseSt

; 7653 : 	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0CC@PKJKLMCM@xmlParseStringEntityRef?3?5no?5nam@
	push	68					; 00000044H
	push	esi
	call	_xmlFatalErrMsg

; 7654 : 		       "xmlParseStringEntityRef: no name\n");
; 7655 : 	*str = ptr;

	mov	ecx, DWORD PTR _str$[ebp]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _ptr$[ebp]
	pop	edi
	pop	esi

; 7662 : 	return(NULL);

	mov	DWORD PTR [ecx], eax
	xor	eax, eax
	pop	ebx

; 7799 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlParseSt:

; 7656 : 	return(NULL);
; 7657 :     }
; 7658 :     if (*ptr != ';') {

	mov	eax, DWORD PTR _ptr$[ebp]
	cmp	BYTE PTR [eax], 59			; 0000003bH
	je	SHORT $LN8@xmlParseSt

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	test	esi, esi
	je	SHORT $LN92@xmlParseSt
	cmp	DWORD PTR [esi+212], ebx
	je	SHORT $LN33@xmlParseSt
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN96@xmlParseSt
$LN33@xmlParseSt:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;

	mov	DWORD PTR [esi+84], 23			; 00000017H
$LN92@xmlParseSt:

; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BJ@KLEMOBLL@EntityRef?3?5expecting?5?8?$DL?8@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	23					; 00000017H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN96@xmlParseSt

; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], ebx

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], ebx
	jne	SHORT $LN96@xmlParseSt

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN96@xmlParseSt:

; 7659 : 	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
; 7660 :         xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree

; 7661 : 	*str = ptr;

	mov	ecx, DWORD PTR _str$[ebp]
	add	esp, 4
	mov	eax, DWORD PTR _ptr$[ebp]
	pop	edi
	pop	esi

; 7662 : 	return(NULL);

	mov	DWORD PTR [ecx], eax
	xor	eax, eax
	pop	ebx

; 7799 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlParseSt:

; 7663 :     }
; 7664 :     ptr++;

	inc	eax

; 7665 : 
; 7666 : 
; 7667 :     /*
; 7668 :      * Predefined entities override any extra definition
; 7669 :      */
; 7670 :     if ((ctxt->options & XML_PARSE_OLDSAX) == 0) {

	test	DWORD PTR [esi+360], 1048576		; 00100000H
	mov	DWORD PTR _ptr$2$[ebp], eax
	jne	SHORT $LN199@xmlParseSt

; 7671 :         ent = xmlGetPredefinedEntity(name);

	push	edi
	call	_xmlGetPredefinedEntity
	mov	ebx, eax
	add	esp, 4

; 7672 :         if (ent != NULL) {

	test	ebx, ebx
	jne	$LN28@xmlParseSt
$LN199@xmlParseSt:

; 7673 :             xmlFree(name);
; 7674 :             *str = ptr;
; 7675 :             return(ent);
; 7676 :         }
; 7677 :     }
; 7678 : 
; 7679 :     /*
; 7680 :      * Increate the number of entity references parsed
; 7681 :      */
; 7682 :     ctxt->nbentities++;

	inc	DWORD PTR [esi+440]

; 7683 : 
; 7684 :     /*
; 7685 :      * Ask first SAX for entity resolution, otherwise try the
; 7686 :      * entities which may have stored in the parser context.
; 7687 :      */
; 7688 :     if (ctxt->sax != NULL) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN14@xmlParseSt

; 7689 : 	if (ctxt->sax->getEntity != NULL)

	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	je	SHORT $LN12@xmlParseSt

; 7690 : 	    ent = ctxt->sax->getEntity(ctxt->userData, name);

	push	edi
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 8
	mov	ebx, eax
$LN12@xmlParseSt:

; 7691 : 	if ((ent == NULL) && (ctxt->options & XML_PARSE_OLDSAX))

	test	ebx, ebx
	jne	SHORT $LN14@xmlParseSt
	test	DWORD PTR [esi+360], 1048576		; 00100000H
	je	SHORT $LN198@xmlParseSt

; 7692 : 	    ent = xmlGetPredefinedEntity(name);

	push	edi
	call	_xmlGetPredefinedEntity
	mov	ebx, eax
	add	esp, 4

; 7693 : 	if ((ent == NULL) && (ctxt->userData==ctxt)) {

	test	ebx, ebx
	jne	SHORT $LN14@xmlParseSt
$LN198@xmlParseSt:
	cmp	DWORD PTR [esi+4], esi
	jne	SHORT $LN14@xmlParseSt

; 7694 : 	    ent = xmlSAX2GetEntity(ctxt, name);

	push	edi
	push	esi
	call	_xmlSAX2GetEntity
	add	esp, 8
	mov	ebx, eax
$LN14@xmlParseSt:

; 7695 : 	}
; 7696 :     }
; 7697 :     if (ctxt->instate == XML_PARSER_EOF) {

	mov	ecx, DWORD PTR [esi+172]
	cmp	ecx, -1
	jne	SHORT $LN15@xmlParseSt

; 7698 : 	xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 7799 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlParseSt:

; 7699 : 	return(NULL);
; 7700 :     }
; 7701 : 
; 7702 :     /*
; 7703 :      * [ WFC: Entity Declared ]
; 7704 :      * In a document without any DTD, a document with only an
; 7705 :      * internal DTD subset which contains no parameter entity
; 7706 :      * references, or a document with "standalone='yes'", the
; 7707 :      * Name given in the entity reference must match that in an
; 7708 :      * entity declaration, except that well-formed documents
; 7709 :      * need not declare any of the following entities: amp, lt,
; 7710 :      * gt, apos, quot.
; 7711 :      * The declaration of a parameter entity must precede any
; 7712 :      * reference to it.
; 7713 :      * Similarly, the declaration of a general entity must
; 7714 :      * precede any reference to it which appears in a default
; 7715 :      * value in an attribute-list declaration. Note that if
; 7716 :      * entities are declared in the external subset or in
; 7717 :      * external parameter entities, a non-validating processor
; 7718 :      * is not obligated to read and process their declarations;
; 7719 :      * for such documents, the rule that an entity must be
; 7720 :      * declared is a well-formedness constraint only if
; 7721 :      * standalone='yes'.
; 7722 :      */
; 7723 :     if (ent == NULL) {

	test	ebx, ebx
	jne	SHORT $LN16@xmlParseSt

; 7724 : 	if ((ctxt->standalone == 1) ||

	cmp	DWORD PTR [esi+28], 1
	je	SHORT $LN20@xmlParseSt
	cmp	DWORD PTR [esi+88], ebx
	jne	SHORT $LN18@xmlParseSt
	cmp	DWORD PTR [esi+92], ebx
	je	SHORT $LN20@xmlParseSt
$LN18@xmlParseSt:

; 7728 : 		     "Entity '%s' not defined\n", name);
; 7729 : 	} else {
; 7730 : 	    xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,

	push	edi
	push	OFFSET ??_C@_0BJ@KIKIJMLK@Entity?5?8?$CFs?8?5not?5defined?6@
	push	27					; 0000001bH
	push	esi
	call	_xmlErrMsgStr

; 7731 : 			  "Entity '%s' not defined\n",
; 7732 : 			  name);
; 7733 : 	}
; 7734 : 	xmlParserEntityCheck(ctxt, 0, ent, 0);

	add	esp, 16					; 00000010H
	push	0
	push	0
	push	0
	push	esi
	call	_xmlParserEntityCheck

; 7735 : 	/* TODO ? check regressions ctxt->valid = 0; */
; 7736 :     }

	jmp	$LN203@xmlParseSt
$LN20@xmlParseSt:

; 7725 : 	    ((ctxt->hasExternalSubset == 0) &&
; 7726 : 	     (ctxt->hasPErefs == 0))) {
; 7727 : 	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,

	push	edi
	push	OFFSET ??_C@_0BJ@KIKIJMLK@Entity?5?8?$CFs?8?5not?5defined?6@
	push	26					; 0000001aH
	push	esi
	call	_xmlFatalErrMsgStr

; 7731 : 			  "Entity '%s' not defined\n",
; 7732 : 			  name);
; 7733 : 	}
; 7734 : 	xmlParserEntityCheck(ctxt, 0, ent, 0);

	add	esp, 16					; 00000010H
	push	0
	push	0
	push	0
	push	esi
	call	_xmlParserEntityCheck

; 7735 : 	/* TODO ? check regressions ctxt->valid = 0; */
; 7736 :     }

	jmp	SHORT $LN203@xmlParseSt
$LN16@xmlParseSt:

; 7737 : 
; 7738 :     /*
; 7739 :      * [ WFC: Parsed Entity ]
; 7740 :      * An entity reference must not contain the name of an
; 7741 :      * unparsed entity
; 7742 :      */
; 7743 :     else if (ent->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {

	mov	eax, DWORD PTR [ebx+48]
	cmp	eax, 3
	jne	SHORT $LN21@xmlParseSt

; 7744 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,

	push	edi
	push	OFFSET ??_C@_0CI@ILCMJJAO@Entity?5reference?5to?5unparsed?5en@
	push	28					; 0000001cH

; 7745 : 		 "Entity reference to unparsed entity %s\n", name);
; 7746 :     }

	jmp	SHORT $LN204@xmlParseSt
$LN21@xmlParseSt:

; 7747 : 
; 7748 :     /*
; 7749 :      * [ WFC: No External Entity References ]
; 7750 :      * Attribute values cannot contain direct or indirect
; 7751 :      * entity references to external entities.
; 7752 :      */
; 7753 :     else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&

	cmp	ecx, 12					; 0000000cH
	jne	SHORT $LN25@xmlParseSt
	cmp	eax, 2
	jne	SHORT $LN23@xmlParseSt

; 7754 : 	     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
; 7755 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,

	push	edi
	push	OFFSET ??_C@_0CL@HLODLGOA@Attribute?5references?5external?5e@
	push	29					; 0000001dH

; 7756 : 	 "Attribute references external entity '%s'\n", name);
; 7757 :     }

	jmp	SHORT $LN204@xmlParseSt
$LN23@xmlParseSt:

; 7758 :     /*
; 7759 :      * [ WFC: No < in Attribute Values ]
; 7760 :      * The replacement text of any entity referred to directly or
; 7761 :      * indirectly in an attribute value (other than "&lt;") must
; 7762 :      * not contain a <.
; 7763 :      */
; 7764 :     else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
; 7765 : 	     (ent != NULL) && (ent->content != NULL) &&
; 7766 : 	     (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&

	mov	ecx, DWORD PTR [ebx+40]
	test	ecx, ecx
	je	SHORT $LN25@xmlParseSt
	cmp	eax, 6
	je	SHORT $LN25@xmlParseSt
	push	60					; 0000003cH
	push	ecx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlParseSt

; 7767 : 	     (xmlStrchr(ent->content, '<'))) {
; 7768 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,

	push	edi
	push	OFFSET ??_C@_0DI@FDECCCAO@?8?$DM?8?5in?5entity?5?8?$CFs?8?5is?5not?5allow@
	push	38					; 00000026H

; 7769 :      "'<' in entity '%s' is not allowed in attributes values\n",
; 7770 : 			  name);
; 7771 :     }

	jmp	SHORT $LN204@xmlParseSt
$LN25@xmlParseSt:

; 7772 : 
; 7773 :     /*
; 7774 :      * Internal check, no parameter entities here ...
; 7775 :      */
; 7776 :     else {
; 7777 : 	switch (ent->etype) {

	mov	eax, DWORD PTR [ebx+48]
	add	eax, -4					; fffffffcH
	cmp	eax, 1
	ja	SHORT $LN28@xmlParseSt

; 7778 : 	    case XML_INTERNAL_PARAMETER_ENTITY:
; 7779 : 	    case XML_EXTERNAL_PARAMETER_ENTITY:
; 7780 : 		xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,

	push	edi
	push	OFFSET ??_C@_0DA@CCPGIFBP@Attempt?5to?5reference?5the?5parame@
	push	30					; 0000001eH
$LN204@xmlParseSt:

; 7781 : 	     "Attempt to reference the parameter entity '%s'\n",
; 7782 : 				  name);
; 7783 : 	    break;
; 7784 : 	    default:
; 7785 : 	    break;
; 7786 : 	}
; 7787 :     }
; 7788 : 
; 7789 :     /*
; 7790 :      * [ WFC: No Recursion ]
; 7791 :      * A parsed entity must not contain a recursive reference
; 7792 :      * to itself, either directly or indirectly.
; 7793 :      * Done somewhere else
; 7794 :      */
; 7795 : 
; 7796 :     xmlFree(name);

	push	esi
	call	_xmlFatalErrMsgStr
$LN203@xmlParseSt:
	add	esp, 16					; 00000010H
$LN28@xmlParseSt:
	push	edi
	call	DWORD PTR _xmlFree

; 7797 :     *str = ptr;

	mov	ecx, DWORD PTR _str$[ebp]
	add	esp, 4
	mov	eax, DWORD PTR _ptr$2$[ebp]
	pop	edi
	mov	DWORD PTR [ecx], eax

; 7798 :     return(ent);

	mov	eax, ebx
	pop	esi
	pop	ebx

; 7799 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlParseSt:

; 7644 :         return(NULL);

	xor	eax, eax
	pop	ebx

; 7799 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseStringEntityRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCleanSpecialAttr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlCleanSpecialAttr PROC				; COMDAT

; 1368 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+352]
	test	eax, eax
	je	SHORT $LN3@xmlCleanSp

; 1369 :     if (ctxt->attsSpecial == NULL)
; 1370 :         return;
; 1371 : 
; 1372 :     xmlHashScanFull(ctxt->attsSpecial, xmlCleanSpecialAttrCallback, ctxt);

	push	esi
	push	OFFSET _xmlCleanSpecialAttrCallback
	push	eax
	call	_xmlHashScanFull

; 1373 : 
; 1374 :     if (xmlHashSize(ctxt->attsSpecial) == 0) {

	push	DWORD PTR [esi+352]
	call	_xmlHashSize
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN3@xmlCleanSp

; 1375 :         xmlHashFree(ctxt->attsSpecial, NULL);

	push	eax
	push	DWORD PTR [esi+352]
	call	_xmlHashFree
	add	esp, 8

; 1376 :         ctxt->attsSpecial = NULL;

	mov	DWORD PTR [esi+352], 0
$LN3@xmlCleanSp:
	pop	esi

; 1377 :     }
; 1378 :     return;
; 1379 : }

	pop	ebp
	ret	0
_xmlCleanSpecialAttr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCleanSpecialAttrCallback
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_fullname$ = 16						; size = 4
_fullattr$ = 20						; size = 4
_unused$ = 24						; size = 4
_xmlCleanSpecialAttrCallback PROC			; COMDAT

; 1350 :                             const xmlChar *unused ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _payload$[ebp], 1
	jne	SHORT $LN2@xmlCleanSp

; 1351 :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) data;
; 1352 : 
; 1353 :     if (((ptrdiff_t) payload) == XML_ATTRIBUTE_CDATA) {
; 1354 :         xmlHashRemoveEntry2(ctxt->attsSpecial, fullname, fullattr, NULL);

	mov	eax, DWORD PTR _data$[ebp]
	push	0
	push	DWORD PTR _fullattr$[ebp]
	push	DWORD PTR _fullname$[ebp]
	push	DWORD PTR [eax+352]
	call	_xmlHashRemoveEntry2
	add	esp, 16					; 00000010H
$LN2@xmlCleanSp:

; 1355 :     }
; 1356 : }

	pop	ebp
	ret	0
_xmlCleanSpecialAttrCallback ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlAddSpecialAttr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_fullname$ = 12						; size = 4
_fullattr$ = 16						; size = 4
_type$ = 20						; size = 4
_xmlAddSpecialAttr PROC					; COMDAT

; 1323 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+352]
	test	eax, eax
	jne	SHORT $LN6@xmlAddSpec

; 1324 :     if (ctxt->attsSpecial == NULL) {
; 1325 :         ctxt->attsSpecial = xmlHashCreateDict(10, ctxt->dict);

	push	DWORD PTR [esi+296]
	push	10					; 0000000aH
	call	_xmlHashCreateDict
	add	esp, 8
	mov	DWORD PTR [esi+352], eax

; 1326 : 	if (ctxt->attsSpecial == NULL)

	test	eax, eax
	jne	SHORT $LN6@xmlAddSpec
$mem_error$8:

; 1334 :                      (void *) (ptrdiff_t) type);
; 1335 :     return;
; 1336 : 
; 1337 : mem_error:
; 1338 :     xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory
	add	esp, 8
	pop	esi

; 1339 :     return;
; 1340 : }

	pop	ebp
	ret	0
$LN6@xmlAddSpec:

; 1327 : 	    goto mem_error;
; 1328 :     }
; 1329 : 
; 1330 :     if (xmlHashLookup2(ctxt->attsSpecial, fullname, fullattr) != NULL)

	push	DWORD PTR _fullattr$[ebp]
	push	DWORD PTR _fullname$[ebp]
	push	eax
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@xmlAddSpec

; 1331 :         return;
; 1332 : 
; 1333 :     xmlHashAddEntry2(ctxt->attsSpecial, fullname, fullattr,

	push	DWORD PTR _type$[ebp]
	push	DWORD PTR _fullattr$[ebp]
	push	DWORD PTR _fullname$[ebp]
	push	DWORD PTR [esi+352]
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN1@xmlAddSpec:
	pop	esi

; 1339 :     return;
; 1340 : }

	pop	ebp
	ret	0
_xmlAddSpecialAttr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlAddDefAttrs
_TEXT	SEGMENT
_name$2$ = -8						; size = 4
_len$ = -4						; size = 4
_prefix$1$ = 8						; size = 4
_name$4$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_fullname$ = 12						; size = 4
_fullattr$ = 16						; size = 4
_value$ = 20						; size = 4
_xmlAddDefAttrs PROC					; COMDAT

; 1211 :                const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __B9AC27D5_parser@c
	push	ebx
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	esi, DWORD PTR _fullname$[ebp]
	mov	eax, DWORD PTR [ebx+352]
	test	eax, eax
	je	SHORT $LN3@xmlAddDefA

; 1212 :     xmlDefAttrsPtr defaults;
; 1213 :     int len;
; 1214 :     const xmlChar *name;
; 1215 :     const xmlChar *prefix;
; 1216 : 
; 1217 :     /*
; 1218 :      * Allows to detect attribute redefinitions
; 1219 :      */
; 1220 :     if (ctxt->attsSpecial != NULL) {
; 1221 :         if (xmlHashLookup2(ctxt->attsSpecial, fullname, fullattr) != NULL)

	push	DWORD PTR _fullattr$[ebp]
	push	esi
	push	eax
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN1@xmlAddDefA
$LN3@xmlAddDefA:

; 1222 : 	    return;
; 1223 :     }
; 1224 : 
; 1225 :     if (ctxt->attsDefault == NULL) {

	cmp	DWORD PTR [ebx+348], 0
	push	edi
	jne	SHORT $LN5@xmlAddDefA

; 1226 :         ctxt->attsDefault = xmlHashCreateDict(10, ctxt->dict);

	push	DWORD PTR [ebx+296]
	push	10					; 0000000aH
	call	_xmlHashCreateDict
	add	esp, 8
	mov	DWORD PTR [ebx+348], eax

; 1227 : 	if (ctxt->attsDefault == NULL)

	test	eax, eax
	je	$mem_error$25
$LN5@xmlAddDefA:

; 1228 : 	    goto mem_error;
; 1229 :     }
; 1230 : 
; 1231 :     /*
; 1232 :      * split the element name into prefix:localname , the string found
; 1233 :      * are within the DTD and then not associated to namespace names.
; 1234 :      */
; 1235 :     name = xmlSplitQName3(fullname, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	esi
	call	_xmlSplitQName3
	mov	ecx, DWORD PTR [ebx+296]
	add	esp, 8

; 1236 :     if (name == NULL) {

	push	-1
	test	eax, eax
	jne	SHORT $LN6@xmlAddDefA

; 1237 :         name = xmlDictLookup(ctxt->dict, fullname, -1);

	push	esi
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 1238 : 	prefix = NULL;

	xor	eax, eax

; 1239 :     } else {

	jmp	SHORT $LN21@xmlAddDefA
$LN6@xmlAddDefA:

; 1240 :         name = xmlDictLookup(ctxt->dict, name, -1);

	push	eax
	push	ecx
	call	_xmlDictLookup

; 1241 : 	prefix = xmlDictLookup(ctxt->dict, fullname, len);

	push	DWORD PTR _len$[ebp]
	mov	DWORD PTR _name$2$[ebp], eax
	push	esi
	push	DWORD PTR [ebx+296]
	call	_xmlDictLookup
	mov	esi, DWORD PTR _name$2$[ebp]
	add	esp, 24					; 00000018H
$LN21@xmlAddDefA:

; 1242 :     }
; 1243 : 
; 1244 :     /*
; 1245 :      * make sure there is some storage
; 1246 :      */
; 1247 :     defaults = xmlHashLookup2(ctxt->attsDefault, name, prefix);

	push	eax
	push	esi
	push	DWORD PTR [ebx+348]
	mov	DWORD PTR _prefix$1$[ebp], eax
	call	_xmlHashLookup2
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 1248 :     if (defaults == NULL) {

	test	edi, edi
	jne	SHORT $LN8@xmlAddDefA

; 1249 :         defaults = (xmlDefAttrsPtr) xmlMalloc(sizeof(xmlDefAttrs) +

	push	108					; 0000006cH
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 1250 : 	                   (4 * 5) * sizeof(const xmlChar *));
; 1251 : 	if (defaults == NULL)

	test	edi, edi
	je	SHORT $mem_error$25

; 1252 : 	    goto mem_error;
; 1253 : 	defaults->nbAttrs = 0;

	mov	DWORD PTR [edi], 0

; 1254 : 	defaults->maxAttrs = 4;

	mov	DWORD PTR [edi+4], 4

; 1255 : 	if (xmlHashUpdateEntry2(ctxt->attsDefault, name, prefix,
; 1256 : 	                        defaults, NULL) < 0) {
; 1257 : 	    xmlFree(defaults);
; 1258 : 	    goto mem_error;

	jmp	SHORT $LN23@xmlAddDefA
$LN8@xmlAddDefA:

; 1259 : 	}
; 1260 :     } else if (defaults->nbAttrs >= defaults->maxAttrs) {

	mov	eax, DWORD PTR [edi+4]
	cmp	DWORD PTR [edi], eax
	jl	SHORT $LN14@xmlAddDefA

; 1261 :         xmlDefAttrsPtr temp;
; 1262 : 
; 1263 :         temp = (xmlDefAttrsPtr) xmlRealloc(defaults, sizeof(xmlDefAttrs) +

	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [eax*8+28]
	push	eax
	push	edi
	call	DWORD PTR _xmlRealloc
	mov	edi, eax
	add	esp, 8

; 1264 : 		       (2 * defaults->maxAttrs * 5) * sizeof(const xmlChar *));
; 1265 : 	if (temp == NULL)

	test	edi, edi
	je	SHORT $mem_error$25

; 1266 : 	    goto mem_error;
; 1267 : 	defaults = temp;
; 1268 : 	defaults->maxAttrs *= 2;

	mov	eax, DWORD PTR [edi+4]
	add	eax, eax
	mov	DWORD PTR [edi+4], eax
$LN23@xmlAddDefA:

; 1301 : 
; 1302 :     return;
; 1303 : 
; 1304 : mem_error:
; 1305 :     xmlErrMemory(ctxt, NULL);

	push	0
	push	edi
	push	DWORD PTR _prefix$1$[ebp]
	push	esi
	push	DWORD PTR [ebx+348]
	call	_xmlHashUpdateEntry2
	add	esp, 20					; 00000014H
	test	eax, eax
	jns	SHORT $LN14@xmlAddDefA
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$mem_error$25:
	push	0
	push	ebx
	call	_xmlErrMemory
	add	esp, 8
	pop	edi
	pop	esi

; 1306 :     return;
; 1307 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlAddDefA:

; 1269 : 	if (xmlHashUpdateEntry2(ctxt->attsDefault, name, prefix,
; 1270 : 	                        defaults, NULL) < 0) {
; 1271 : 	    xmlFree(defaults);
; 1272 : 	    goto mem_error;
; 1273 : 	}
; 1274 :     }
; 1275 : 
; 1276 :     /*
; 1277 :      * Split the element name into prefix:localname , the string found
; 1278 :      * are within the DTD and hen not associated to namespace names.
; 1279 :      */
; 1280 :     name = xmlSplitQName3(fullattr, &len);

	mov	esi, DWORD PTR _fullattr$[ebp]
	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	esi
	call	_xmlSplitQName3
	mov	ecx, DWORD PTR [ebx+296]
	add	esp, 8

; 1281 :     if (name == NULL) {

	push	-1
	test	eax, eax
	jne	SHORT $LN15@xmlAddDefA

; 1282 :         name = xmlDictLookup(ctxt->dict, fullattr, -1);

	push	esi
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 1283 : 	prefix = NULL;

	xor	edx, edx

; 1284 :     } else {

	jmp	SHORT $LN16@xmlAddDefA
$LN15@xmlAddDefA:

; 1285 :         name = xmlDictLookup(ctxt->dict, name, -1);

	push	eax
	push	ecx
	call	_xmlDictLookup

; 1286 : 	prefix = xmlDictLookup(ctxt->dict, fullattr, len);

	push	DWORD PTR _len$[ebp]
	mov	DWORD PTR _name$4$[ebp], eax
	push	esi
	push	DWORD PTR [ebx+296]
	call	_xmlDictLookup
	mov	edx, eax
	add	esp, 24					; 00000018H
	mov	eax, DWORD PTR _name$4$[ebp]
$LN16@xmlAddDefA:

; 1287 :     }
; 1288 : 
; 1289 :     defaults->values[5 * defaults->nbAttrs] = name;

	mov	ecx, DWORD PTR [edi]

; 1290 :     defaults->values[5 * defaults->nbAttrs + 1] = prefix;
; 1291 :     /* intern the string and precompute the end */
; 1292 :     len = xmlStrlen(value);

	mov	esi, DWORD PTR _value$[ebp]
	push	esi
	lea	ecx, DWORD PTR [ecx+ecx*4]
	mov	DWORD PTR [edi+ecx*4+8], eax
	mov	ecx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	mov	DWORD PTR [edi+ecx*4+12], edx
	call	_xmlStrlen

; 1293 :     value = xmlDictLookup(ctxt->dict, value, len);

	push	eax
	push	esi
	push	DWORD PTR [ebx+296]
	mov	DWORD PTR _len$[ebp], eax
	call	_xmlDictLookup

; 1294 :     defaults->values[5 * defaults->nbAttrs + 2] = value;

	mov	ecx, DWORD PTR [edi]
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR [ecx+ecx*4]
	mov	DWORD PTR [edi+ecx*4+16], eax

; 1295 :     defaults->values[5 * defaults->nbAttrs + 3] = value + len;

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, eax
	mov	eax, DWORD PTR [edi]
	inc	eax
	lea	eax, DWORD PTR [eax+eax*4]
	mov	DWORD PTR [edi+eax*4], ecx

; 1296 :     if (ctxt->external)
; 1297 :         defaults->values[5 * defaults->nbAttrs + 4] = BAD_CAST "external";
; 1298 :     else
; 1299 :         defaults->values[5 * defaults->nbAttrs + 4] = NULL;
; 1300 :     defaults->nbAttrs++;

	xor	eax, eax
	cmp	DWORD PTR [ebx+96], eax
	mov	ecx, OFFSET ??_C@_08OIBPHJGN@external@
	cmove	ecx, eax
	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+eax*4]
	mov	DWORD PTR [edi+eax*4+24], ecx
	inc	DWORD PTR [edi]
	pop	edi
$LN1@xmlAddDefA:

; 1306 :     return;
; 1307 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAddDefAttrs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlAttrNormalizeSpace2
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_src$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlAttrNormalizeSpace2 PROC				; COMDAT

; 1152 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	esi, esi
	cmp	DWORD PTR _ctxt$[ebp], esi
	je	$LN7@xmlAttrNor

; 1153 :     int i;
; 1154 :     int remove_head = 0;
; 1155 :     int need_realloc = 0;
; 1156 :     const xmlChar *cur;
; 1157 : 
; 1158 :     if ((ctxt == NULL) || (src == NULL) || (len == NULL))

	mov	ebx, DWORD PTR _src$[ebp]
	test	ebx, ebx
	je	$LN7@xmlAttrNor
	mov	ecx, DWORD PTR _len$[ebp]
	test	ecx, ecx
	je	$LN7@xmlAttrNor

; 1159 :         return(NULL);
; 1160 :     i = *len;

	mov	edi, DWORD PTR [ecx]

; 1161 :     if (i <= 0)

	test	edi, edi
	jle	SHORT $LN7@xmlAttrNor

; 1162 :         return(NULL);
; 1163 : 
; 1164 :     cur = src;
; 1165 :     while (*cur == 0x20) {

	mov	dl, BYTE PTR [ebx]
	mov	eax, ebx
	cmp	dl, 32					; 00000020H
	jne	SHORT $LN19@xmlAttrNor
$LL2@xmlAttrNor:
	mov	dl, BYTE PTR [eax+1]

; 1166 :         cur++;

	inc	eax

; 1167 : 	remove_head++;

	inc	esi
	cmp	dl, 32					; 00000020H
	je	SHORT $LL2@xmlAttrNor
$LN19@xmlAttrNor:

; 1168 :     }
; 1169 :     while (*cur != 0) {

	test	dl, dl
	je	SHORT $LN27@xmlAttrNor
	npad	2
$LL4@xmlAttrNor:

; 1170 : 	if (*cur == 0x20) {

	mov	cl, BYTE PTR [eax+1]
	lea	eax, DWORD PTR [eax+1]
	cmp	dl, 32					; 00000020H
	jne	SHORT $LN9@xmlAttrNor

; 1171 : 	    cur++;
; 1172 : 	    if ((*cur == 0x20) || (*cur == 0)) {

	cmp	cl, dl
	je	SHORT $LN20@xmlAttrNor
	test	cl, cl
	je	SHORT $LN20@xmlAttrNor
$LN9@xmlAttrNor:

; 1168 :     }
; 1169 :     while (*cur != 0) {

	mov	dl, cl
	test	cl, cl
	jne	SHORT $LL4@xmlAttrNor
	mov	ecx, DWORD PTR _len$[ebp]
$LN27@xmlAttrNor:

; 1190 :     } else if (remove_head) {

	test	esi, esi
	je	SHORT $LN7@xmlAttrNor

; 1191 :         *len -= remove_head;

	sub	edi, esi
	mov	DWORD PTR [ecx], edi

; 1192 :         memmove(src, src + remove_head, 1 + *len);

	lea	ecx, DWORD PTR [edi+1]
	push	ecx
	lea	ecx, DWORD PTR [esi+ebx]
	push	ecx
	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH

; 1193 : 	return(src);

	mov	eax, ebx
	pop	edi

; 1194 :     }
; 1195 :     return(NULL);
; 1196 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN20@xmlAttrNor:

; 1173 : 	        need_realloc = 1;
; 1174 : 		break;
; 1175 : 	    }
; 1176 : 	} else
; 1177 : 	    cur++;
; 1178 :     }
; 1179 :     if (need_realloc) {
; 1180 :         xmlChar *ret;
; 1181 : 
; 1182 : 	ret = xmlStrndup(src + remove_head, i - remove_head + 1);

	sub	edi, esi
	lea	eax, DWORD PTR [esi+ebx]
	inc	edi
	push	edi
	push	eax
	call	_xmlStrndup
	mov	esi, eax
	add	esp, 8

; 1183 : 	if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN15@xmlAttrNor

; 1184 : 	    xmlErrMemory(ctxt, NULL);

	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrMemory
	add	esp, 8
$LN7@xmlAttrNor:

; 1194 :     }
; 1195 :     return(NULL);
; 1196 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN15@xmlAttrNor:

; 1185 : 	    return(NULL);
; 1186 : 	}
; 1187 : 	xmlAttrNormalizeSpace(ret, ret);

	push	esi
	push	esi
	call	_xmlAttrNormalizeSpace

; 1188 : 	*len = (int) strlen((const char *)ret);

	mov	ecx, esi
	add	esp, 8
	lea	edx, DWORD PTR [ecx+1]
$LL28@xmlAttrNor:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL28@xmlAttrNor
	mov	eax, DWORD PTR _len$[ebp]
	sub	ecx, edx
	pop	edi
	mov	DWORD PTR [eax], ecx

; 1189 :         return(ret);

	mov	eax, esi

; 1194 :     }
; 1195 :     return(NULL);
; 1196 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlAttrNormalizeSpace2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlAttrNormalizeSpace
_TEXT	SEGMENT
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_xmlAttrNormalizeSpace PROC				; COMDAT

; 1119 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _src$[ebp]
	test	eax, eax
	je	SHORT $LN9@xmlAttrNor

; 1120 :     if ((src == NULL) || (dst == NULL))

	mov	edx, DWORD PTR _dst$[ebp]
	test	edx, edx
	je	SHORT $LN9@xmlAttrNor

; 1122 : 
; 1123 :     while (*src == 0x20) src++;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	jne	SHORT $LN16@xmlAttrNor
$LL2@xmlAttrNor:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	cmp	cl, 32					; 00000020H
	je	SHORT $LL2@xmlAttrNor
$LN16@xmlAttrNor:

; 1124 :     while (*src != 0) {

	test	cl, cl
	je	SHORT $LN5@xmlAttrNor
	push	esi
$LL4@xmlAttrNor:

; 1125 : 	if (*src == 0x20) {

	cmp	cl, 32					; 00000020H
	jne	SHORT $LN10@xmlAttrNor
$LL6@xmlAttrNor:

; 1126 : 	    while (*src == 0x20) src++;

	mov	cl, BYTE PTR [eax+1]
	mov	esi, eax
	inc	eax
	cmp	cl, 32					; 00000020H
	je	SHORT $LL6@xmlAttrNor

; 1127 : 	    if (*src != 0)

	test	cl, cl
	je	SHORT $LN11@xmlAttrNor

; 1128 : 		*dst++ = 0x20;

	mov	BYTE PTR [edx], 32			; 00000020H

; 1129 : 	} else {

	jmp	SHORT $LN26@xmlAttrNor
$LN10@xmlAttrNor:

; 1130 : 	    *dst++ = *src++;

	mov	BYTE PTR [edx], cl
	mov	esi, eax
$LN26@xmlAttrNor:

; 1124 :     while (*src != 0) {

	inc	edx
$LN11@xmlAttrNor:
	mov	cl, BYTE PTR [esi+1]
	lea	eax, DWORD PTR [esi+1]
	test	cl, cl
	jne	SHORT $LL4@xmlAttrNor
	pop	esi
$LN5@xmlAttrNor:

; 1131 : 	}
; 1132 :     }
; 1133 :     *dst = 0;

	mov	BYTE PTR [edx], 0

; 1134 :     if (dst == src)

	cmp	edx, eax
	je	SHORT $LN9@xmlAttrNor

; 1135 :        return(NULL);
; 1136 :     return(dst);

	mov	eax, edx

; 1137 : }

	pop	ebp
	ret	0
$LN9@xmlAttrNor:

; 1121 :         return(NULL);

	xor	eax, eax

; 1137 : }

	pop	ebp
	ret	0
_xmlAttrNormalizeSpace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlDetectSAX2
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlDetectSAX2 PROC					; COMDAT

; 1068 : xmlDetectSAX2(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN5@xmlDetectS

; 1069 :     if (ctxt == NULL) return;
; 1070 : #ifdef LIBXML_SAX1_ENABLED
; 1071 :     if ((ctxt->sax) &&  (ctxt->sax->initialized == XML_SAX2_MAGIC) &&

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@xmlDetectS
	cmp	DWORD PTR [eax+108], -554844497		; deedbeafH
	jne	SHORT $LN3@xmlDetectS
	cmp	DWORD PTR [eax+116], 0
	jne	SHORT $LN4@xmlDetectS
	cmp	DWORD PTR [eax+120], 0
	je	SHORT $LN3@xmlDetectS
$LN4@xmlDetectS:

; 1072 :         ((ctxt->sax->startElementNs != NULL) ||
; 1073 :          (ctxt->sax->endElementNs != NULL))) ctxt->sax2 = 1;

	mov	DWORD PTR [esi+324], 1
$LN3@xmlDetectS:

; 1074 : #else
; 1075 :     ctxt->sax2 = 1;
; 1076 : #endif /* LIBXML_SAX1_ENABLED */
; 1077 : 
; 1078 :     ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);

	push	3
	push	OFFSET ??_C@_03PJHHNEEI@xml@
	push	DWORD PTR [esi+296]
	call	_xmlDictLookup

; 1079 :     ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);

	push	5
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR [esi+296]
	mov	DWORD PTR [esi+312], eax
	call	_xmlDictLookup

; 1080 :     ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);

	push	36					; 00000024H
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	DWORD PTR [esi+296]
	mov	DWORD PTR [esi+316], eax
	call	_xmlDictLookup
	add	esp, 36					; 00000024H
	mov	DWORD PTR [esi+320], eax

; 1081 :     if ((ctxt->str_xml==NULL) || (ctxt->str_xmlns==NULL) ||

	cmp	DWORD PTR [esi+312], 0
	je	SHORT $LN6@xmlDetectS
	cmp	DWORD PTR [esi+316], 0
	je	SHORT $LN6@xmlDetectS
	test	eax, eax
	jne	SHORT $LN5@xmlDetectS
$LN6@xmlDetectS:

; 1082 : 		(ctxt->str_xml_ns == NULL)) {
; 1083 :         xmlErrMemory(ctxt, NULL);

	push	0
	push	esi
	call	_xmlErrMemory
	add	esp, 8
$LN5@xmlDetectS:
	pop	esi

; 1084 :     }
; 1085 : }

	pop	ebp
	ret	0
_xmlDetectSAX2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlNsWarn
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_info1$ = 20						; size = 4
_info2$ = 24						; size = 4
_info3$ = 28						; size = 4
_xmlNsWarn PROC						; COMDAT

; 821  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN2@xmlNsWarn

; 822  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN2@xmlNsWarn
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN1@xmlNsWarn
$LN2@xmlNsWarn:

; 823  :         (ctxt->instate == XML_PARSER_EOF))
; 824  : 	return;
; 825  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,

	mov	edx, DWORD PTR _info3$[ebp]
	mov	ecx, DWORD PTR _info2$[ebp]
	mov	eax, DWORD PTR _info1$[ebp]
	push	edx
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	edx
	push	ecx
	push	eax
	push	0
	push	0
	push	1
	push	DWORD PTR _error$[ebp]
	push	3
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH
$LN1@xmlNsWarn:
	pop	esi

; 826  :                     XML_ERR_WARNING, NULL, 0, (const char *) info1,
; 827  :                     (const char *) info2, (const char *) info3, 0, 0, msg,
; 828  :                     info1, info2, info3);
; 829  : }

	pop	ebp
	ret	0
_xmlNsWarn ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlNsErr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_info1$ = 20						; size = 4
_info2$ = 24						; size = 4
_info3$ = 28						; size = 4
_xmlNsErr PROC						; COMDAT

; 792  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	edi, DWORD PTR _error$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlNsErr

; 793  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN2@xmlNsErr
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN4@xmlNsErr
$LN2@xmlNsErr:

; 794  :         (ctxt->instate == XML_PARSER_EOF))
; 795  : 	return;
; 796  :     if (ctxt != NULL)
; 797  : 	ctxt->errNo = error;

	mov	DWORD PTR [esi+84], edi
$LN3@xmlNsErr:

; 798  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,

	mov	edx, DWORD PTR _info3$[ebp]
	mov	ecx, DWORD PTR _info2$[ebp]
	mov	eax, DWORD PTR _info1$[ebp]
	push	edx
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	edx
	push	ecx
	push	eax
	push	0
	push	0
	push	2
	push	edi
	push	3
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH

; 799  :                     XML_ERR_ERROR, NULL, 0, (const char *) info1,
; 800  :                     (const char *) info2, (const char *) info3, 0, 0, msg,
; 801  :                     info1, info2, info3);
; 802  :     if (ctxt != NULL)

	test	esi, esi
	je	SHORT $LN4@xmlNsErr

; 803  : 	ctxt->nsWellFormed = 0;

	mov	DWORD PTR [esi+356], 0
$LN4@xmlNsErr:
	pop	edi

; 804  : }

	pop	esi
	pop	ebp
	ret	0
_xmlNsErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlErrMsgStr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_val$ = 20						; size = 4
_xmlErrMsgStr PROC					; COMDAT

; 765  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _error$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlErrMsgS

; 766  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [ecx+212], 0
	je	SHORT $LN2@xmlErrMsgS
	cmp	DWORD PTR [ecx+172], -1
	je	SHORT $LN1@xmlErrMsgS
$LN2@xmlErrMsgS:

; 767  :         (ctxt->instate == XML_PARSER_EOF))
; 768  : 	return;
; 769  :     if (ctxt != NULL)
; 770  : 	ctxt->errNo = error;

	mov	DWORD PTR [ecx+84], edx
$LN3@xmlErrMsgS:

; 771  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL,

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	2
	push	edx
	push	1
	push	0
	push	ecx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN1@xmlErrMsgS:

; 772  :                     XML_FROM_PARSER, error, XML_ERR_ERROR,
; 773  :                     NULL, 0, (const char *) val, NULL, NULL, 0, 0, msg,
; 774  :                     val);
; 775  : }

	pop	ebp
	ret	0
_xmlErrMsgStr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlFatalErrMsgStr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_val$ = 20						; size = 4
_xmlFatalErrMsgStr PROC					; COMDAT

; 736  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _error$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlFatalEr

; 737  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN2@xmlFatalEr
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN5@xmlFatalEr
$LN2@xmlFatalEr:

; 738  :         (ctxt->instate == XML_PARSER_EOF))
; 739  : 	return;
; 740  :     if (ctxt != NULL)
; 741  : 	ctxt->errNo = error;

	mov	DWORD PTR [esi+84], ecx
$LN3@xmlFatalEr:

; 742  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL,

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	3
	push	ecx
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 743  :                     XML_FROM_PARSER, error, XML_ERR_FATAL,
; 744  :                     NULL, 0, (const char *) val, NULL, NULL, 0, 0, msg,
; 745  :                     val);
; 746  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlFatalEr

; 747  : 	ctxt->wellFormed = 0;
; 748  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+12], 0
	jne	SHORT $LN5@xmlFatalEr

; 749  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN5@xmlFatalEr:
	pop	esi

; 750  :     }
; 751  : }

	pop	ebp
	ret	0
_xmlFatalErrMsgStr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlFatalErrMsgStrIntStr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_str1$ = 20						; size = 4
_val$ = 24						; size = 4
_str2$ = 28						; size = 4
_xmlFatalErrMsgStrIntStr PROC				; COMDAT

; 707  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	edi, DWORD PTR _error$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlFatalEr

; 708  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN2@xmlFatalEr
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN5@xmlFatalEr
$LN2@xmlFatalEr:

; 709  :         (ctxt->instate == XML_PARSER_EOF))
; 710  : 	return;
; 711  :     if (ctxt != NULL)
; 712  : 	ctxt->errNo = error;

	mov	DWORD PTR [esi+84], edi
$LN3@xmlFatalEr:

; 713  :     __xmlRaiseError(NULL, NULL, NULL,

	mov	edx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR _str1$[ebp]
	push	edx
	push	eax
	push	ecx
	push	DWORD PTR _msg$[ebp]
	push	0
	push	eax
	push	0
	push	edx
	push	ecx
	push	0
	push	0
	push	3
	push	edi
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH

; 714  :                     ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
; 715  :                     NULL, 0, (const char *) str1, (const char *) str2,
; 716  : 		    NULL, val, 0, msg, str1, val, str2);
; 717  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlFatalEr

; 718  : 	ctxt->wellFormed = 0;
; 719  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+12], 0
	jne	SHORT $LN5@xmlFatalEr

; 720  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN5@xmlFatalEr:
	pop	edi

; 721  :     }
; 722  : }

	pop	esi
	pop	ebp
	ret	0
_xmlFatalErrMsgStrIntStr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlFatalErrMsgInt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_val$ = 20						; size = 4
_xmlFatalErrMsgInt PROC					; COMDAT

; 676  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _error$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlFatalEr

; 677  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN2@xmlFatalEr
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN5@xmlFatalEr
$LN2@xmlFatalEr:

; 678  :         (ctxt->instate == XML_PARSER_EOF))
; 679  : 	return;
; 680  :     if (ctxt != NULL)
; 681  : 	ctxt->errNo = error;

	mov	DWORD PTR [esi+84], ecx
$LN3@xmlFatalEr:

; 682  :     __xmlRaiseError(NULL, NULL, NULL,

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	ecx
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 683  :                     ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
; 684  :                     NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
; 685  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlFatalEr

; 686  : 	ctxt->wellFormed = 0;
; 687  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+12], 0
	jne	SHORT $LN5@xmlFatalEr

; 688  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN5@xmlFatalEr:
	pop	esi

; 689  :     }
; 690  : }

	pop	ebp
	ret	0
_xmlFatalErrMsgInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlValidityError
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_str1$ = 20						; size = 4
_str2$ = 24						; size = 4
_xmlValidityError PROC					; COMDAT

; 636  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edx, edx
	test	esi, esi
	je	SHORT $LN5@xmlValidit

; 637  :     xmlStructuredErrorFunc schannel = NULL;
; 638  : 
; 639  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], edx
	je	SHORT $LN2@xmlValidit
	cmp	DWORD PTR [esi+172], -1
	je	$LN6@xmlValidit
$LN2@xmlValidit:

; 640  :         (ctxt->instate == XML_PARSER_EOF))
; 641  : 	return;
; 642  :     if (ctxt != NULL) {
; 643  : 	ctxt->errNo = error;
; 644  : 	if ((ctxt->sax != NULL) && (ctxt->sax->initialized == XML_SAX2_MAGIC))

	mov	eax, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR _error$[ebp]
	mov	DWORD PTR [esi+84], edi
	test	eax, eax
	je	SHORT $LN4@xmlValidit
	cmp	DWORD PTR [eax+108], -554844497		; deedbeafH
	jne	SHORT $LN4@xmlValidit

; 645  : 	    schannel = ctxt->sax->serror;

	mov	edx, DWORD PTR [eax+124]
$LN4@xmlValidit:

; 646  :     }
; 647  :     if (ctxt != NULL) {
; 648  :         __xmlRaiseError(schannel,

	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	push	0
	push	0
	push	2
	push	edi
	push	4
	push	0
	push	esi
	push	DWORD PTR [esi+108]
	push	DWORD PTR [esi+112]
	push	edx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 649  :                     ctxt->vctxt.error, ctxt->vctxt.userData,
; 650  :                     ctxt, NULL, XML_FROM_DTD, error,
; 651  :                     XML_ERR_ERROR, NULL, 0, (const char *) str1,
; 652  : 		    (const char *) str2, NULL, 0, 0,
; 653  : 		    msg, (const char *) str1, (const char *) str2);
; 654  : 	ctxt->valid = 0;

	mov	DWORD PTR [esi+100], 0
	pop	edi
	pop	esi

; 657  :                     ctxt, NULL, XML_FROM_DTD, error,
; 658  :                     XML_ERR_ERROR, NULL, 0, (const char *) str1,
; 659  : 		    (const char *) str2, NULL, 0, 0,
; 660  : 		    msg, (const char *) str1, (const char *) str2);
; 661  :     }
; 662  : }

	pop	ebp
	ret	0
$LN5@xmlValidit:

; 655  :     } else {
; 656  :         __xmlRaiseError(schannel, NULL, NULL,

	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	4
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN6@xmlValidit:
	pop	esi

; 657  :                     ctxt, NULL, XML_FROM_DTD, error,
; 658  :                     XML_ERR_ERROR, NULL, 0, (const char *) str1,
; 659  : 		    (const char *) str2, NULL, 0, 0,
; 660  : 		    msg, (const char *) str1, (const char *) str2);
; 661  :     }
; 662  : }

	pop	ebp
	ret	0
_xmlValidityError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlWarningMsg
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_str1$ = 20						; size = 4
_str2$ = 24						; size = 4
_xmlWarningMsg PROC					; COMDAT

; 598  : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	test	edx, edx
	je	SHORT $LN4@xmlWarning

; 599  :     xmlStructuredErrorFunc schannel = NULL;
; 600  : 
; 601  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edx+212], edi
	je	SHORT $LN2@xmlWarning
	cmp	DWORD PTR [edx+172], -1
	je	SHORT $LN5@xmlWarning
$LN2@xmlWarning:

; 602  :         (ctxt->instate == XML_PARSER_EOF))
; 603  : 	return;
; 604  :     if ((ctxt != NULL) && (ctxt->sax != NULL) &&

	mov	eax, DWORD PTR [edx]
	push	esi
	test	eax, eax
	je	SHORT $LN7@xmlWarning
	cmp	DWORD PTR [eax+108], -554844497		; deedbeafH
	jne	SHORT $LN3@xmlWarning

; 605  :         (ctxt->sax->initialized == XML_SAX2_MAGIC))
; 606  :         schannel = ctxt->sax->serror;

	mov	edi, DWORD PTR [eax+124]
$LN3@xmlWarning:

; 607  :     if (ctxt != NULL) {
; 608  :         __xmlRaiseError(schannel,

	mov	esi, DWORD PTR [eax+84]
	jmp	SHORT $LN8@xmlWarning
$LN7@xmlWarning:
	xor	esi, esi
$LN8@xmlWarning:
	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	push	0
	push	0
	push	1
	push	DWORD PTR _error$[ebp]
	push	1
	push	0
	push	edx
	push	DWORD PTR [edx+4]
	push	esi
	push	edi
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
	pop	esi
	pop	edi

; 617  :                     ctxt, NULL, XML_FROM_PARSER, error,
; 618  :                     XML_ERR_WARNING, NULL, 0,
; 619  : 		    (const char *) str1, (const char *) str2, NULL, 0, 0,
; 620  : 		    msg, (const char *) str1, (const char *) str2);
; 621  :     }
; 622  : }

	pop	ebp
	ret	0
$LN4@xmlWarning:

; 609  :                     (ctxt->sax) ? ctxt->sax->warning : NULL,
; 610  :                     ctxt->userData,
; 611  :                     ctxt, NULL, XML_FROM_PARSER, error,
; 612  :                     XML_ERR_WARNING, NULL, 0,
; 613  : 		    (const char *) str1, (const char *) str2, NULL, 0, 0,
; 614  : 		    msg, (const char *) str1, (const char *) str2);
; 615  :     } else {
; 616  :         __xmlRaiseError(schannel, NULL, NULL,

	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	push	0
	push	0
	push	1
	push	DWORD PTR _error$[ebp]
	push	1
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN5@xmlWarning:
	pop	edi

; 617  :                     ctxt, NULL, XML_FROM_PARSER, error,
; 618  :                     XML_ERR_WARNING, NULL, 0,
; 619  : 		    (const char *) str1, (const char *) str2, NULL, 0, 0,
; 620  : 		    msg, (const char *) str1, (const char *) str2);
; 621  :     }
; 622  : }

	pop	ebp
	ret	0
_xmlWarningMsg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlFatalErrMsg
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_xmlFatalErrMsg PROC					; COMDAT

; 570  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _error$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlFatalEr

; 571  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN2@xmlFatalEr
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN5@xmlFatalEr
$LN2@xmlFatalEr:

; 572  :         (ctxt->instate == XML_PARSER_EOF))
; 573  : 	return;
; 574  :     if (ctxt != NULL)
; 575  : 	ctxt->errNo = error;

	mov	DWORD PTR [esi+84], eax
$LN3@xmlFatalEr:

; 576  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	DWORD PTR _msg$[ebp]
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	eax
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 577  :                     XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, "%s", msg);
; 578  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlFatalEr

; 579  : 	ctxt->wellFormed = 0;
; 580  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+12], 0
	jne	SHORT $LN5@xmlFatalEr

; 581  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN5@xmlFatalEr:
	pop	esi

; 582  :     }
; 583  : }

	pop	ebp
	ret	0
_xmlFatalErrMsg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlErrAttributeDup
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_prefix$ = 12						; size = 4
_localname$ = 16					; size = 4
_xmlErrAttributeDup PROC				; COMDAT

; 318  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlErrAttr

; 319  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN2@xmlErrAttr
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN7@xmlErrAttr
$LN2@xmlErrAttr:

; 320  :         (ctxt->instate == XML_PARSER_EOF))
; 321  : 	return;
; 322  :     if (ctxt != NULL)
; 323  : 	ctxt->errNo = XML_ERR_ATTRIBUTE_REDEFINED;

	mov	DWORD PTR [esi+84], 42			; 0000002aH
$LN3@xmlErrAttr:

; 324  : 
; 325  :     if (prefix == NULL)

	mov	ecx, DWORD PTR _prefix$[ebp]
	mov	eax, DWORD PTR _localname$[ebp]
	push	eax
	test	ecx, ecx
	jne	SHORT $LN4@xmlErrAttr

; 326  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,

	push	OFFSET ??_C@_0BI@LJKBJNKP@Attribute?5?$CFs?5redefined?6@
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	push	eax
	push	ecx
	push	ecx
	push	3
	push	42					; 0000002aH
	push	1
	push	ecx
	push	esi
	push	ecx
	push	ecx
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	jmp	SHORT $LN5@xmlErrAttr
$LN4@xmlErrAttr:

; 327  :                         XML_ERR_ATTRIBUTE_REDEFINED, XML_ERR_FATAL, NULL, 0,
; 328  :                         (const char *) localname, NULL, NULL, 0, 0,
; 329  :                         "Attribute %s redefined\n", localname);
; 330  :     else
; 331  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,

	push	ecx
	push	OFFSET ??_C@_0BL@GJOEMOIC@Attribute?5?$CFs?3?$CFs?5redefined?6@
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	push	0
	push	0
	push	3
	push	42					; 0000002aH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN5@xmlErrAttr:

; 332  :                         XML_ERR_ATTRIBUTE_REDEFINED, XML_ERR_FATAL, NULL, 0,
; 333  :                         (const char *) prefix, (const char *) localname,
; 334  :                         NULL, 0, 0, "Attribute %s:%s redefined\n", prefix,
; 335  :                         localname);
; 336  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN7@xmlErrAttr

; 337  : 	ctxt->wellFormed = 0;
; 338  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+12], 0
	jne	SHORT $LN7@xmlErrAttr

; 339  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN7@xmlErrAttr:
	pop	esi

; 340  :     }
; 341  : }

	pop	ebp
	ret	0
_xmlErrAttributeDup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlLoadEntityContent
_TEXT	SEGMENT
_input$1$ = -8						; size = 4
_l$ = -4						; size = 4
_buf$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_entity$ = 12						; size = 4
_xmlLoadEntityContent PROC				; COMDAT

; 7976 : xmlLoadEntityContent(xmlParserCtxtPtr ctxt, xmlEntityPtr entity) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __B9AC27D5_parser@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	test	ebx, ebx
	je	$LN8@xmlLoadEnt

; 7977 :     xmlParserInputPtr input;
; 7978 :     xmlBufferPtr buf;
; 7979 :     int l, c;
; 7980 :     int count = 0;
; 7981 : 
; 7982 :     if ((ctxt == NULL) || (entity == NULL) ||
; 7983 :         ((entity->etype != XML_EXTERNAL_PARAMETER_ENTITY) &&
; 7984 : 	 (entity->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)) ||

	mov	ecx, DWORD PTR _entity$[ebp]
	test	ecx, ecx
	je	$LN8@xmlLoadEnt
	mov	eax, DWORD PTR [ecx+48]
	cmp	eax, 5
	je	SHORT $LN9@xmlLoadEnt
	cmp	eax, 2
	jne	$LN8@xmlLoadEnt
$LN9@xmlLoadEnt:
	cmp	DWORD PTR [ecx+40], esi
	jne	$LN8@xmlLoadEnt

; 7987 : 	            "xmlLoadEntityContent parameter error");
; 7988 :         return(-1);
; 7989 :     }
; 7990 : 
; 7991 :     if (xmlParserDebugEntities)

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], esi
	je	SHORT $LN10@xmlLoadEnt

; 7992 : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	ecx, DWORD PTR _entity$[ebp]
	mov	edi, eax
	mov	esi, DWORD PTR [ecx+8]
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0CB@NCAMLBBH@Reading?5?$CFs?5entity?5content?5input@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 12					; 0000000cH
	xor	esi, esi
$LN10@xmlLoadEnt:

; 7993 : 		"Reading %s entity content input\n", entity->name);
; 7994 : 
; 7995 :     buf = xmlBufferCreate();

	call	_xmlBufferCreate
	mov	edi, eax
	mov	DWORD PTR _buf$1$[ebp], edi

; 7996 :     if (buf == NULL) {

	test	edi, edi
	je	$LN8@xmlLoadEnt

; 7997 : 	xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
; 7998 : 	            "xmlLoadEntityContent parameter error");
; 7999 :         return(-1);
; 8000 :     }
; 8001 : 
; 8002 :     input = xmlNewEntityInputStream(ctxt, entity);

	push	DWORD PTR _entity$[ebp]
	push	ebx
	call	_xmlNewEntityInputStream
	add	esp, 8
	mov	DWORD PTR _input$1$[ebp], eax

; 8003 :     if (input == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlLoadEnt

; 8004 : 	xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CB@HEAOEFBK@xmlLoadEntityContent?5input?5erro@
	push	1
	push	ebx
	call	_xmlFatalErr

; 8005 : 	            "xmlLoadEntityContent input error");
; 8006 : 	xmlBufferFree(buf);

	push	edi
	call	_xmlBufferFree
	add	esp, 16					; 00000010H

; 8059 : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlLoadEnt:

; 8007 :         return(-1);
; 8008 :     }
; 8009 : 
; 8010 :     /*
; 8011 :      * Push the entity as the current input, read char by char
; 8012 :      * saving to the buffer until the end of the entity or an error
; 8013 :      */
; 8014 :     if (xmlPushInput(ctxt, input) < 0) {

	push	eax
	push	ebx
	call	_xmlPushInput
	add	esp, 8
	test	eax, eax
	js	$LN49@xmlLoadEnt

; 8015 :         xmlBufferFree(buf);
; 8016 : 	return(-1);
; 8017 :     }
; 8018 : 
; 8019 :     GROW;

	cmp	DWORD PTR [ebx+292], 0
	jne	SHORT $LN14@xmlLoadEnt
	mov	eax, DWORD PTR [ebx+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN14@xmlLoadEnt
	push	ebx
	call	_xmlGROW
	add	esp, 4
$LN14@xmlLoadEnt:

; 8020 :     c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	ebx
	call	_xmlCurrentChar

; 8021 :     while ((ctxt->input == input) && (ctxt->input->cur < ctxt->input->end) &&

	mov	edx, DWORD PTR [ebx+36]
	add	esp, 8
	mov	ecx, eax
	cmp	edx, DWORD PTR _input$1$[ebp]
	jne	$LN23@xmlLoadEnt
	npad	10
$LL2@xmlLoadEnt:
	mov	edi, DWORD PTR [edx+16]
	cmp	edi, DWORD PTR [edx+20]
	jae	$LN56@xmlLoadEnt
	cmp	ecx, 256				; 00000100H
	jge	$LN35@xmlLoadEnt
	cmp	ecx, 9
	jl	SHORT $LN27@xmlLoadEnt
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN31@xmlLoadEnt
$LN27@xmlLoadEnt:
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN31@xmlLoadEnt
	cmp	ecx, 32					; 00000020H
	jl	$LN59@xmlLoadEnt
$LN31@xmlLoadEnt:
	mov	eax, 1
$LN33@xmlLoadEnt:
	test	eax, eax
	je	$LN56@xmlLoadEnt

; 8022 :            (IS_CHAR(c))) {
; 8023 :         xmlBufferAdd(buf, ctxt->input->cur, l);

	push	DWORD PTR _l$[ebp]
	push	edi
	mov	edi, DWORD PTR _buf$1$[ebp]
	push	edi
	call	_xmlBufferAdd

; 8024 : 	if (count++ > XML_PARSER_CHUNK_SIZE) {

	mov	eax, esi
	add	esp, 12					; 0000000cH
	inc	esi
	cmp	eax, 100				; 00000064H
	jle	SHORT $LN6@xmlLoadEnt

; 8025 : 	    count = 0;

	xor	esi, esi

; 8026 : 	    GROW;

	cmp	DWORD PTR [ebx+292], esi
	jne	SHORT $LN16@xmlLoadEnt
	mov	eax, DWORD PTR [ebx+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN16@xmlLoadEnt
	push	ebx
	call	_xmlGROW
	add	esp, 4
$LN16@xmlLoadEnt:

; 8027 :             if (ctxt->instate == XML_PARSER_EOF) {

	cmp	DWORD PTR [ebx+172], -1
	je	$LN49@xmlLoadEnt
$LN6@xmlLoadEnt:

; 8028 :                 xmlBufferFree(buf);
; 8029 :                 return(-1);
; 8030 :             }
; 8031 : 	}
; 8032 : 	NEXTL(l);

	mov	ecx, DWORD PTR [ebx+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN18@xmlLoadEnt
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [ebx+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN19@xmlLoadEnt
$LN35@xmlLoadEnt:

; 8021 :     while ((ctxt->input == input) && (ctxt->input->cur < ctxt->input->end) &&

	cmp	ecx, 55295				; 0000d7ffH
	jle	SHORT $LN31@xmlLoadEnt
	cmp	ecx, 57344				; 0000e000H
	jl	SHORT $LN30@xmlLoadEnt
	cmp	ecx, 65533				; 0000fffdH
	jle	$LN31@xmlLoadEnt
$LN30@xmlLoadEnt:
	lea	eax, DWORD PTR [ecx-65536]
	cmp	eax, 1048575				; 000fffffH
	jbe	$LN31@xmlLoadEnt
$LN59@xmlLoadEnt:
	xor	eax, eax
	jmp	$LN33@xmlLoadEnt
$LN18@xmlLoadEnt:

; 8028 :                 xmlBufferFree(buf);
; 8029 :                 return(-1);
; 8030 :             }
; 8031 : 	}
; 8032 : 	NEXTL(l);

	inc	DWORD PTR [ecx+32]
$LN19@xmlLoadEnt:
	mov	ecx, DWORD PTR [ebx+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax

; 8033 : 	c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	ebx
	call	_xmlCurrentChar
	mov	ecx, eax
	add	esp, 8

; 8034 : 	if (c == 0) {

	test	ecx, ecx
	jne	SHORT $LN20@xmlLoadEnt

; 8035 : 	    count = 0;

	xor	esi, esi

; 8036 : 	    GROW;

	cmp	DWORD PTR [ebx+292], esi
	jne	SHORT $LN21@xmlLoadEnt
	mov	eax, DWORD PTR [ebx+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN21@xmlLoadEnt
	push	ebx
	call	_xmlGROW
	add	esp, 4
$LN21@xmlLoadEnt:

; 8037 :             if (ctxt->instate == XML_PARSER_EOF) {

	cmp	DWORD PTR [ebx+172], -1
	je	$LN49@xmlLoadEnt

; 8039 :                 return(-1);
; 8040 :             }
; 8041 : 	    c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	ebx
	call	_xmlCurrentChar
	add	esp, 8
	mov	ecx, eax
$LN20@xmlLoadEnt:

; 8021 :     while ((ctxt->input == input) && (ctxt->input->cur < ctxt->input->end) &&

	mov	edx, DWORD PTR [ebx+36]
	cmp	edx, DWORD PTR _input$1$[ebp]
	je	$LL2@xmlLoadEnt
	jmp	SHORT $LN3@xmlLoadEnt
$LN56@xmlLoadEnt:

; 8042 : 	}
; 8043 :     }
; 8044 : 
; 8045 :     if ((ctxt->input == input) && (ctxt->input->cur >= ctxt->input->end)) {

	mov	edi, DWORD PTR _buf$1$[ebp]
$LN3@xmlLoadEnt:
	cmp	edx, DWORD PTR _input$1$[ebp]
	jne	SHORT $LN23@xmlLoadEnt
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR [edx+20]
	jb	SHORT $LN23@xmlLoadEnt

; 8046 :         xmlPopInput(ctxt);

	push	ebx
	call	_xmlPopInput
	add	esp, 4
$LN25@xmlLoadEnt:

; 8052 : 	return(-1);
; 8053 :     }
; 8054 :     entity->content = buf->content;

	mov	ecx, DWORD PTR _entity$[ebp]
	mov	eax, DWORD PTR [edi]

; 8055 :     buf->content = NULL;
; 8056 :     xmlBufferFree(buf);

	push	edi
	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [edi], 0
	call	_xmlBufferFree
	add	esp, 4

; 8057 : 
; 8058 :     return(0);

	xor	eax, eax
	pop	edi

; 8059 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@xmlLoadEnt:

; 8047 :     } else if (!IS_CHAR(c)) {

	cmp	ecx, 256				; 00000100H
	jge	SHORT $LN45@xmlLoadEnt
	cmp	ecx, 9
	jl	SHORT $LN37@xmlLoadEnt
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN25@xmlLoadEnt
$LN37@xmlLoadEnt:
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN25@xmlLoadEnt
	cmp	ecx, 32					; 00000020H
	jge	SHORT $LN25@xmlLoadEnt
	jmp	SHORT $LN42@xmlLoadEnt
$LN45@xmlLoadEnt:
	cmp	ecx, 55295				; 0000d7ffH
	jle	SHORT $LN25@xmlLoadEnt
	cmp	ecx, 57344				; 0000e000H
	jl	SHORT $LN40@xmlLoadEnt
	cmp	ecx, 65533				; 0000fffdH
	jle	SHORT $LN25@xmlLoadEnt
$LN40@xmlLoadEnt:
	lea	eax, DWORD PTR [ecx-65536]
	cmp	eax, 1048575				; 000fffffH
	jbe	SHORT $LN25@xmlLoadEnt
$LN42@xmlLoadEnt:

; 8048 :         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,

	push	ecx
	push	OFFSET ??_C@_0CN@NHLEKBNA@xmlLoadEntityContent?3?5invalid?5c@
	push	9
	push	ebx
	call	_xmlFatalErrMsgInt

; 8049 :                           "xmlLoadEntityContent: invalid char value %d\n",
; 8050 : 	                  c);
; 8051 : 	xmlBufferFree(buf);

	push	edi
	call	_xmlBufferFree
	add	esp, 20					; 00000014H

; 8059 : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@xmlLoadEnt:

; 8038 :                 xmlBufferFree(buf);

	push	edi
	call	_xmlBufferFree
	add	esp, 4

; 8059 : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlLoadEnt:

; 7985 : 	(entity->content != NULL)) {
; 7986 : 	xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CF@PMEPEHIL@xmlLoadEntityContent?5parameter?5@
	push	1
	push	ebx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 8059 : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlLoadEntityContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseBalancedChunkMemoryInternal
_TEXT	SEGMENT
_ret$1$ = -16						; size = 4
_newDoc$1$ = -12					; size = 4
_last$1$ = -8						; size = 4
_content$1$ = -4					; size = 4
_oldsax$1$ = 8						; size = 4
_oldctxt$ = 8						; size = 4
_string$ = 12						; size = 4
_user_data$ = 16					; size = 4
_lst$ = 20						; size = 4
_xmlParseBalancedChunkMemoryInternal PROC		; COMDAT

; 13343: 	const xmlChar *string, void *user_data, xmlNodePtr *lst) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _oldctxt$[ebp]
	xor	eax, eax
	mov	DWORD PTR _newDoc$1$[ebp], eax
	mov	DWORD PTR _content$1$[ebp], eax
	mov	DWORD PTR _last$1$[ebp], eax
	mov	eax, DWORD PTR [edi+248]
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN280@xmlParseBa

; 13344:     xmlParserCtxtPtr ctxt;
; 13345:     xmlDocPtr newDoc = NULL;
; 13346:     xmlNodePtr newRoot;
; 13347:     xmlSAXHandlerPtr oldsax = NULL;
; 13348:     xmlNodePtr content = NULL;
; 13349:     xmlNodePtr last = NULL;
; 13350:     int size;
; 13351:     xmlParserErrors ret = XML_ERR_OK;
; 13352: #ifdef SAX2
; 13353:     int i;
; 13354: #endif
; 13355: 
; 13356:     if (((oldctxt->depth > 40) && ((oldctxt->options & XML_PARSE_HUGE) == 0)) ||

	test	DWORD PTR [edi+360], 524288		; 00080000H
	je	SHORT $LN8@xmlParseBa
$LN280@xmlParseBa:
	cmp	eax, 1024				; 00000400H
	jle	SHORT $LN7@xmlParseBa
$LN8@xmlParseBa:

; 13357:         (oldctxt->depth >  1024)) {
; 13358: 	return(XML_ERR_ENTITY_LOOP);

	mov	eax, 89					; 00000059H
	pop	edi

; 13513: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlParseBa:

; 13359:     }
; 13360: 
; 13361: 
; 13362:     if (lst != NULL)

	mov	eax, DWORD PTR _lst$[ebp]
	test	eax, eax
	je	SHORT $LN10@xmlParseBa

; 13363:         *lst = NULL;

	mov	DWORD PTR [eax], 0
$LN10@xmlParseBa:
	push	ebx
	push	esi

; 13364:     if (string == NULL)

	mov	esi, DWORD PTR _string$[ebp]
	test	esi, esi
	je	$LN20@xmlParseBa

; 13365:         return(XML_ERR_INTERNAL_ERROR);
; 13366: 
; 13367:     size = xmlStrlen(string);

	push	esi
	call	_xmlStrlen

; 13368: 
; 13369:     ctxt = xmlCreateMemoryParserCtxt((char *) string, size);

	push	eax
	push	esi
	call	_xmlCreateMemoryParserCtxt
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 13370:     if (ctxt == NULL) return(XML_WAR_UNDECLARED_ENTITY);

	test	esi, esi
	jne	SHORT $LN12@xmlParseBa
	lea	eax, DWORD PTR [esi+27]
	pop	esi
	pop	ebx
	pop	edi

; 13513: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlParseBa:

; 13371:     if (user_data != NULL)

	mov	eax, DWORD PTR _user_data$[ebp]
	mov	ecx, esi
	test	eax, eax
	cmovne	ecx, eax

; 13372: 	ctxt->userData = user_data;
; 13373:     else
; 13374: 	ctxt->userData = ctxt;
; 13375:     if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);

	mov	DWORD PTR [esi+4], ecx
	mov	eax, DWORD PTR [esi+296]
	test	eax, eax
	je	SHORT $LN15@xmlParseBa
	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN15@xmlParseBa:

; 13376:     ctxt->dict = oldctxt->dict;

	mov	ecx, DWORD PTR [edi+296]
	mov	DWORD PTR [esi+296], ecx

; 13377:     ctxt->input_id = oldctxt->input_id + 1;

	mov	eax, DWORD PTR [edi+464]

; 13378:     ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);

	push	3
	inc	eax
	push	OFFSET ??_C@_03PJHHNEEI@xml@
	push	ecx
	mov	DWORD PTR [esi+464], eax
	call	_xmlDictLookup

; 13379:     ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);

	push	5
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR [esi+296]
	mov	DWORD PTR [esi+312], eax
	call	_xmlDictLookup

; 13380:     ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);

	push	36					; 00000024H
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	DWORD PTR [esi+296]
	mov	DWORD PTR [esi+316], eax
	call	_xmlDictLookup

; 13381: 
; 13382: #ifdef SAX2
; 13383:     /* propagate namespaces down the entity */
; 13384:     for (i = 0;i < oldctxt->nsNr;i += 2) {

	xor	ebx, ebx
	mov	DWORD PTR [esi+320], eax
	add	esp, 36					; 00000024H
	cmp	DWORD PTR [edi+328], ebx
	jle	SHORT $LN3@xmlParseBa
	npad	6
$LL4@xmlParseBa:

; 13385:         nsPush(ctxt, oldctxt->nsTab[i], oldctxt->nsTab[i+1]);

	mov	eax, DWORD PTR [edi+336]
	push	DWORD PTR [eax+ebx*4+4]
	push	DWORD PTR [eax+ebx*4]
	push	esi
	call	_nsPush
	add	ebx, 2
	add	esp, 12					; 0000000cH
	cmp	ebx, DWORD PTR [edi+328]
	jl	SHORT $LL4@xmlParseBa
$LN3@xmlParseBa:

; 13386:     }
; 13387: #endif
; 13388: 
; 13389:     oldsax = ctxt->sax;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _oldsax$1$[ebp], eax

; 13390:     ctxt->sax = oldctxt->sax;

	mov	eax, DWORD PTR [edi]

; 13391:     xmlDetectSAX2(ctxt);

	push	esi
	mov	DWORD PTR [esi], eax
	call	_xmlDetectSAX2

; 13392:     ctxt->replaceEntities = oldctxt->replaceEntities;

	mov	eax, DWORD PTR [edi+16]
	add	esp, 4
	mov	DWORD PTR [esi+16], eax

; 13393:     ctxt->options = oldctxt->options;

	mov	eax, DWORD PTR [edi+360]
	mov	DWORD PTR [esi+360], eax

; 13394: 
; 13395:     ctxt->_private = oldctxt->_private;

	mov	eax, DWORD PTR [edi+272]
	mov	DWORD PTR [esi+272], eax

; 13396:     if (oldctxt->myDoc == NULL) {

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	jne	SHORT $LN16@xmlParseBa

; 13397: 	newDoc = xmlNewDoc(BAD_CAST "1.0");

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlNewDoc
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _newDoc$1$[ebp], ebx

; 13398: 	if (newDoc == NULL) {

	test	ebx, ebx
	jne	SHORT $LN18@xmlParseBa

; 13399: 	    ctxt->sax = oldsax;

	mov	eax, DWORD PTR _oldsax$1$[ebp]

; 13400: 	    ctxt->dict = NULL;
; 13401: 	    xmlFreeParserCtxt(ctxt);

	push	esi
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+296], ebx
	call	_xmlFreeParserCtxt

; 13420: 	}
; 13421: 	return(XML_ERR_INTERNAL_ERROR);

	add	esp, 4
$LN20@xmlParseBa:
	pop	esi
	pop	ebx
	mov	eax, 1
	pop	edi

; 13513: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlParseBa:

; 13402: 	    return(XML_ERR_INTERNAL_ERROR);
; 13403: 	}
; 13404: 	newDoc->properties = XML_DOC_INTERNAL;

	mov	DWORD PTR [ebx+92], 64			; 00000040H

; 13405: 	newDoc->dict = ctxt->dict;

	mov	eax, DWORD PTR [esi+296]

; 13406: 	xmlDictReference(newDoc->dict);

	push	eax
	mov	DWORD PTR [ebx+80], eax
	call	_xmlDictReference
	add	esp, 4

; 13407: 	ctxt->myDoc = newDoc;

	mov	DWORD PTR [esi+8], ebx
	mov	eax, ebx

; 13408:     } else {

	jmp	SHORT $LN17@xmlParseBa
$LN16@xmlParseBa:

; 13409: 	ctxt->myDoc = oldctxt->myDoc;

	mov	DWORD PTR [esi+8], eax

; 13410:         content = ctxt->myDoc->children;
; 13411: 	last = ctxt->myDoc->last;

	xor	ebx, ebx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _content$1$[ebp], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _last$1$[ebp], ecx
$LN17@xmlParseBa:

; 13412:     }
; 13413:     newRoot = xmlNewDocNode(ctxt->myDoc, NULL, BAD_CAST "pseudoroot", NULL);

	push	0
	push	OFFSET ??_C@_0L@OLLEMIAI@pseudoroot@
	push	0
	push	eax
	call	_xmlNewDocNode
	mov	ecx, eax
	add	esp, 16					; 00000010H

; 13414:     if (newRoot == NULL) {

	test	ecx, ecx
	jne	SHORT $LN19@xmlParseBa

; 13415: 	ctxt->sax = oldsax;

	mov	eax, DWORD PTR _oldsax$1$[ebp]

; 13416: 	ctxt->dict = NULL;
; 13417: 	xmlFreeParserCtxt(ctxt);

	push	esi
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+296], ecx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13418: 	if (newDoc != NULL) {

	test	ebx, ebx
	je	SHORT $LN20@xmlParseBa

; 13419: 	    xmlFreeDoc(newDoc);

	push	ebx
	call	_xmlFreeDoc

; 13420: 	}
; 13421: 	return(XML_ERR_INTERNAL_ERROR);

	add	esp, 4
	mov	eax, 1
	pop	esi
	pop	ebx
	pop	edi

; 13513: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlParseBa:

; 13422:     }
; 13423:     ctxt->myDoc->children = NULL;

	mov	eax, DWORD PTR [esi+8]

; 13424:     ctxt->myDoc->last = NULL;
; 13425:     xmlAddChild((xmlNodePtr) ctxt->myDoc, newRoot);

	push	ecx
	mov	DWORD PTR [eax+12], 0
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+16], 0
	push	DWORD PTR [esi+8]
	call	_xmlAddChild

; 13426:     nodePush(ctxt, ctxt->myDoc->children);

	mov	eax, DWORD PTR [esi+8]
	push	DWORD PTR [eax+12]
	push	esi
	call	_nodePush

; 13427:     ctxt->instate = XML_PARSER_CONTENT;

	mov	DWORD PTR [esi+172], 7
	add	esp, 16					; 00000010H

; 13428:     ctxt->depth = oldctxt->depth + 1;

	mov	eax, DWORD PTR [edi+248]
	inc	eax

; 13429: 
; 13430:     ctxt->validate = 0;

	mov	DWORD PTR [esi+104], 0
	mov	DWORD PTR [esi+248], eax

; 13431:     ctxt->loadsubset = oldctxt->loadsubset;

	mov	eax, DWORD PTR [edi+276]
	mov	DWORD PTR [esi+276], eax

; 13432:     if ((oldctxt->validate) || (oldctxt->replaceEntities != 0)) {

	cmp	DWORD PTR [edi+104], 0
	jne	SHORT $LN22@xmlParseBa
	cmp	DWORD PTR [edi+16], 0
	je	SHORT $LN21@xmlParseBa
$LN22@xmlParseBa:

; 13433: 	/*
; 13434: 	 * ID/IDREF registration will be done in xmlValidateElement below
; 13435: 	 */
; 13436: 	ctxt->loadsubset |= XML_SKIP_IDS;

	or	eax, 8
	mov	DWORD PTR [esi+276], eax
$LN21@xmlParseBa:

; 13437:     }
; 13438:     ctxt->dictNames = oldctxt->dictNames;

	mov	eax, DWORD PTR [edi+364]
	mov	DWORD PTR [esi+364], eax

; 13439:     ctxt->attsDefault = oldctxt->attsDefault;

	mov	eax, DWORD PTR [edi+348]
	mov	DWORD PTR [esi+348], eax

; 13440:     ctxt->attsSpecial = oldctxt->attsSpecial;

	mov	eax, DWORD PTR [edi+352]

; 13441: 
; 13442:     xmlParseContent(ctxt);

	push	esi
	mov	DWORD PTR [esi+352], eax
	call	_xmlParseContent

; 13443:     if ((RAW == '<') && (NXT(1) == '/')) {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [eax+16]
	mov	cl, BYTE PTR [eax]
	cmp	cl, 60					; 0000003cH
	jne	SHORT $LN23@xmlParseBa
	cmp	BYTE PTR [eax+1], 47			; 0000002fH
	jne	SHORT $LN23@xmlParseBa

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN70@xmlParseBa
	cmp	DWORD PTR [esi+172], -1
	je	$LN201@xmlParseBa
$LN70@xmlParseBa:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 85			; 00000055H
	push	85					; 00000055H

; 556  :     }
; 557  : }

	jmp	SHORT $LN285@xmlParseBa
$LN23@xmlParseBa:

; 13444: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
; 13445:     } else if (RAW != 0) {

	test	cl, cl
	je	SHORT $LN201@xmlParseBa

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN281@xmlParseBa
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN201@xmlParseBa
$LN281@xmlParseBa:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0DA@BPKCCNLP@extra?5content?5at?5the?5end?5of?5wel@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 86			; 00000056H
	push	86					; 00000056H
$LN285@xmlParseBa:

; 13446: 	xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
; 13447:     }
; 13448:     if (ctxt->node != ctxt->myDoc->children) {

	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	mov	DWORD PTR [esi+12], 0
	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN201@xmlParseBa
	mov	DWORD PTR [esi+212], 1
$LN201@xmlParseBa:
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+52]
	cmp	eax, DWORD PTR [ecx+12]
	je	SHORT $LN269@xmlParseBa

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN206@xmlParseBa
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN269@xmlParseBa
$LN206@xmlParseBa:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	85					; 00000055H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 85			; 00000055H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN269@xmlParseBa

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN269@xmlParseBa:

; 13449: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
; 13450:     }
; 13451: 
; 13452:     if (!ctxt->wellFormed) {

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN27@xmlParseBa

; 13453:         if (ctxt->errNo == 0)

	mov	eax, DWORD PTR [esi+84]
	mov	ecx, 1
	test	eax, eax
	cmove	eax, ecx

; 13454: 	    ret = XML_ERR_INTERNAL_ERROR;
; 13455: 	else
; 13456: 	    ret = (xmlParserErrors)ctxt->errNo;
; 13457:     } else {

	jmp	SHORT $LN286@xmlParseBa
$LN27@xmlParseBa:

; 13458:       ret = XML_ERR_OK;

	xor	eax, eax
$LN286@xmlParseBa:

; 13459:     }
; 13460: 
; 13461:     if ((lst != NULL) && (ret == XML_ERR_OK)) {

	mov	ecx, DWORD PTR _lst$[ebp]
	mov	DWORD PTR _ret$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN31@xmlParseBa
	test	eax, eax
	jne	SHORT $LN31@xmlParseBa

; 13462: 	xmlNodePtr cur;
; 13463: 
; 13464: 	/*
; 13465: 	 * Return the newly created nodeset after unlinking it from
; 13466: 	 * they pseudo parent.
; 13467: 	 */
; 13468: 	cur = ctxt->myDoc->children->children;

	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax+12]
	mov	ebx, DWORD PTR [eax+12]

; 13469: 	*lst = cur;

	mov	DWORD PTR [ecx], ebx

; 13470: 	while (cur != NULL) {

	test	ebx, ebx
	je	SHORT $LN6@xmlParseBa
$LL5@xmlParseBa:

; 13471: #ifdef LIBXML_VALID_ENABLED
; 13472: 	    if ((oldctxt->validate) && (oldctxt->wellFormed) &&
; 13473: 		(oldctxt->myDoc) && (oldctxt->myDoc->intSubset) &&

	cmp	DWORD PTR [edi+104], 0
	je	SHORT $LN32@xmlParseBa
	cmp	DWORD PTR [edi+12], 0
	je	SHORT $LN32@xmlParseBa
	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN32@xmlParseBa
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN32@xmlParseBa
	cmp	DWORD PTR [ebx+4], 1
	jne	SHORT $LN32@xmlParseBa

; 13474: 		(cur->type == XML_ELEMENT_NODE)) {
; 13475: 		oldctxt->valid &= xmlValidateElement(&oldctxt->vctxt,

	push	ebx
	push	eax
	lea	eax, DWORD PTR [edi+108]
	push	eax
	call	_xmlValidateElement
	add	esp, 12					; 0000000cH
	and	DWORD PTR [edi+100], eax
$LN32@xmlParseBa:

; 13476: 			oldctxt->myDoc, cur);
; 13477: 	    }
; 13478: #endif /* LIBXML_VALID_ENABLED */
; 13479: 	    cur->parent = NULL;

	mov	DWORD PTR [ebx+20], 0

; 13480: 	    cur = cur->next;

	mov	ebx, DWORD PTR [ebx+24]
	test	ebx, ebx
	jne	SHORT $LL5@xmlParseBa
$LN6@xmlParseBa:

; 13481: 	}
; 13482: 	ctxt->myDoc->children->children = NULL;

	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], 0
$LN31@xmlParseBa:

; 13483:     }
; 13484:     if (ctxt->myDoc != NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN33@xmlParseBa

; 13485: 	xmlFreeNode(ctxt->myDoc->children);

	push	DWORD PTR [eax+12]
	call	_xmlFreeNode

; 13486:         ctxt->myDoc->children = content;

	mov	eax, DWORD PTR [esi+8]
	add	esp, 4
	mov	ecx, DWORD PTR _content$1$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 13487:         ctxt->myDoc->last = last;

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _last$1$[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN33@xmlParseBa:

; 13488:     }
; 13489: 
; 13490:     /*
; 13491:      * Record in the parent context the number of entities replacement
; 13492:      * done when parsing that reference.
; 13493:      */
; 13494:     if (oldctxt != NULL)
; 13495:         oldctxt->nbentities += ctxt->nbentities;

	mov	eax, DWORD PTR [esi+440]
	add	DWORD PTR [edi+440], eax

; 13496: 
; 13497:     /*
; 13498:      * Also record the last error if any
; 13499:      */
; 13500:     if (ctxt->lastError.code != XML_ERR_OK)

	cmp	DWORD PTR [esi+388], 0
	je	SHORT $LN35@xmlParseBa

; 13501:         xmlCopyError(&ctxt->lastError, &oldctxt->lastError);

	lea	eax, DWORD PTR [edi+384]
	push	eax
	lea	eax, DWORD PTR [esi+384]
	push	eax
	call	_xmlCopyError
	add	esp, 8
$LN35@xmlParseBa:

; 13502: 
; 13503:     ctxt->sax = oldsax;

	mov	eax, DWORD PTR _oldsax$1$[ebp]

; 13504:     ctxt->dict = NULL;
; 13505:     ctxt->attsDefault = NULL;
; 13506:     ctxt->attsSpecial = NULL;
; 13507:     xmlFreeParserCtxt(ctxt);

	push	esi
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+296], 0
	mov	DWORD PTR [esi+348], 0
	mov	DWORD PTR [esi+352], 0
	call	_xmlFreeParserCtxt

; 13508:     if (newDoc != NULL) {

	mov	eax, DWORD PTR _newDoc$1$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN36@xmlParseBa

; 13509: 	xmlFreeDoc(newDoc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN36@xmlParseBa:

; 13510:     }
; 13511: 
; 13512:     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	esi
	pop	ebx
	pop	edi

; 13513: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseBalancedChunkMemoryInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlAddEntityReference
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_firstNode$ = 12					; size = 4
_lastNode$ = 16						; size = 4
_xmlAddEntityReference PROC				; COMDAT

; 14666: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _xmlEntityRefFunc
	test	eax, eax
	je	SHORT $LN2@xmlAddEnti

; 14669:     }
; 14670: }

	pop	ebp

; 14667:     if (xmlEntityRefFunc != NULL) {
; 14668:         (*xmlEntityRefFunc) (ent, firstNode, lastNode);

	jmp	eax
$LN2@xmlAddEnti:

; 14669:     }
; 14670: }

	pop	ebp
	ret	0
_xmlAddEntityReference ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtUseOptionsInternal
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_options$ = 12						; size = 4
_encoding$ = 16						; size = 4
_xmlCtxtUseOptionsInternal PROC				; COMDAT

; 15024: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlCtxtUse

; 15025:     if (ctxt == NULL)
; 15026:         return(-1);

	or	eax, -1
	pop	esi

; 15151: }

	pop	ebp
	ret	0
$LN2@xmlCtxtUse:

; 15027:     if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN3@xmlCtxtUse

; 15028:         if (ctxt->encoding != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN4@xmlCtxtUse

; 15029: 	    xmlFree((xmlChar *) ctxt->encoding);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlCtxtUse:

; 15030:         ctxt->encoding = xmlStrdup((const xmlChar *) encoding);

	push	DWORD PTR _encoding$[ebp]
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+24], eax
$LN3@xmlCtxtUse:

; 15031:     }
; 15032:     if (options & XML_PARSE_RECOVER) {

	push	ebx
	mov	ebx, DWORD PTR _options$[ebp]
	test	bl, 1
	je	SHORT $LN5@xmlCtxtUse

; 15033:         ctxt->recovery = 1;
; 15034:         options -= XML_PARSE_RECOVER;

	dec	ebx

; 15035: 	ctxt->options |= XML_PARSE_RECOVER;

	mov	eax, 1
	or	DWORD PTR [esi+360], 1

; 15036:     } else

	jmp	SHORT $LN6@xmlCtxtUse
$LN5@xmlCtxtUse:

; 15037:         ctxt->recovery = 0;

	xor	eax, eax
$LN6@xmlCtxtUse:

; 15038:     if (options & XML_PARSE_DTDLOAD) {

	mov	DWORD PTR [esi+288], eax
	test	bl, 4
	je	SHORT $LN7@xmlCtxtUse

; 15039:         ctxt->loadsubset = XML_DETECT_IDS;
; 15040:         options -= XML_PARSE_DTDLOAD;

	sub	ebx, 4

; 15041: 	ctxt->options |= XML_PARSE_DTDLOAD;

	mov	eax, 2
	or	DWORD PTR [esi+360], 4

; 15042:     } else

	jmp	SHORT $LN8@xmlCtxtUse
$LN7@xmlCtxtUse:

; 15043:         ctxt->loadsubset = 0;

	xor	eax, eax
$LN8@xmlCtxtUse:

; 15044:     if (options & XML_PARSE_DTDATTR) {

	mov	DWORD PTR [esi+276], eax
	test	bl, 8
	je	SHORT $LN47@xmlCtxtUse

; 15045:         ctxt->loadsubset |= XML_COMPLETE_ATTRS;

	or	eax, 4

; 15046:         options -= XML_PARSE_DTDATTR;

	sub	ebx, 8

; 15047: 	ctxt->options |= XML_PARSE_DTDATTR;

	or	DWORD PTR [esi+360], 8
	mov	DWORD PTR [esi+276], eax
$LN47@xmlCtxtUse:

; 15048:     }
; 15049:     if (options & XML_PARSE_NOENT) {

	test	bl, 2
	je	SHORT $LN10@xmlCtxtUse

; 15050:         ctxt->replaceEntities = 1;
; 15051:         /* ctxt->loadsubset |= XML_DETECT_IDS; */
; 15052:         options -= XML_PARSE_NOENT;

	sub	ebx, 2

; 15053: 	ctxt->options |= XML_PARSE_NOENT;

	mov	eax, 1
	or	DWORD PTR [esi+360], 2

; 15054:     } else

	jmp	SHORT $LN11@xmlCtxtUse
$LN10@xmlCtxtUse:

; 15055:         ctxt->replaceEntities = 0;

	xor	eax, eax
$LN11@xmlCtxtUse:

; 15056:     if (options & XML_PARSE_PEDANTIC) {

	mov	DWORD PTR [esi+16], eax
	test	bl, bl
	jns	SHORT $LN12@xmlCtxtUse

; 15057:         ctxt->pedantic = 1;
; 15058:         options -= XML_PARSE_PEDANTIC;

	add	ebx, -128				; ffffff80H

; 15059: 	ctxt->options |= XML_PARSE_PEDANTIC;

	mov	eax, 1
	or	DWORD PTR [esi+360], 128		; 00000080H

; 15060:     } else

	jmp	SHORT $LN13@xmlCtxtUse
$LN12@xmlCtxtUse:

; 15061:         ctxt->pedantic = 0;

	xor	eax, eax
$LN13@xmlCtxtUse:

; 15062:     if (options & XML_PARSE_NOBLANKS) {

	mov	DWORD PTR [esi+268], eax
	test	ebx, 256				; 00000100H
	je	SHORT $LN14@xmlCtxtUse

; 15063:         ctxt->keepBlanks = 0;
; 15064:         ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;

	mov	eax, DWORD PTR [esi]

; 15065:         options -= XML_PARSE_NOBLANKS;

	sub	ebx, 256				; 00000100H
	mov	DWORD PTR [esi+208], 0
	mov	DWORD PTR [eax+72], OFFSET _xmlSAX2IgnorableWhitespace

; 15066: 	ctxt->options |= XML_PARSE_NOBLANKS;

	or	DWORD PTR [esi+360], 256		; 00000100H

; 15067:     } else

	jmp	SHORT $LN15@xmlCtxtUse
$LN14@xmlCtxtUse:

; 15068:         ctxt->keepBlanks = 1;

	mov	DWORD PTR [esi+208], 1
$LN15@xmlCtxtUse:

; 15069:     if (options & XML_PARSE_DTDVALID) {

	test	bl, 16					; 00000010H
	je	SHORT $LN16@xmlCtxtUse

; 15070:         ctxt->validate = 1;

	mov	DWORD PTR [esi+104], 1

; 15071:         if (options & XML_PARSE_NOWARNING)

	test	bl, 64					; 00000040H
	je	SHORT $LN18@xmlCtxtUse

; 15072:             ctxt->vctxt.warning = NULL;

	mov	DWORD PTR [esi+116], 0
$LN18@xmlCtxtUse:

; 15073:         if (options & XML_PARSE_NOERROR)

	test	bl, 32					; 00000020H
	je	SHORT $LN19@xmlCtxtUse

; 15074:             ctxt->vctxt.error = NULL;

	mov	DWORD PTR [esi+112], 0
$LN19@xmlCtxtUse:

; 15075:         options -= XML_PARSE_DTDVALID;

	sub	ebx, 16					; 00000010H

; 15076: 	ctxt->options |= XML_PARSE_DTDVALID;

	or	DWORD PTR [esi+360], 16			; 00000010H

; 15077:     } else

	jmp	SHORT $LN17@xmlCtxtUse
$LN16@xmlCtxtUse:

; 15078:         ctxt->validate = 0;

	mov	DWORD PTR [esi+104], 0
$LN17@xmlCtxtUse:

; 15079:     if (options & XML_PARSE_NOWARNING) {

	test	bl, 64					; 00000040H
	je	SHORT $LN20@xmlCtxtUse

; 15080:         ctxt->sax->warning = NULL;

	mov	eax, DWORD PTR [esi]

; 15081:         options -= XML_PARSE_NOWARNING;

	sub	ebx, 64					; 00000040H
	mov	DWORD PTR [eax+84], 0
$LN20@xmlCtxtUse:

; 15082:     }
; 15083:     if (options & XML_PARSE_NOERROR) {

	test	bl, 32					; 00000020H
	je	SHORT $LN21@xmlCtxtUse

; 15084:         ctxt->sax->error = NULL;

	mov	eax, DWORD PTR [esi]

; 15085:         ctxt->sax->fatalError = NULL;
; 15086:         options -= XML_PARSE_NOERROR;

	sub	ebx, 32					; 00000020H
	mov	DWORD PTR [eax+88], 0
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+92], 0
$LN21@xmlCtxtUse:

; 15087:     }
; 15088: #ifdef LIBXML_SAX1_ENABLED
; 15089:     if (options & XML_PARSE_SAX1) {

	test	ebx, 512				; 00000200H
	je	SHORT $LN48@xmlCtxtUse

; 15090:         ctxt->sax->startElement = xmlSAX2StartElement;

	mov	eax, DWORD PTR [esi]

; 15091:         ctxt->sax->endElement = xmlSAX2EndElement;
; 15092:         ctxt->sax->startElementNs = NULL;
; 15093:         ctxt->sax->endElementNs = NULL;
; 15094:         ctxt->sax->initialized = 1;
; 15095:         options -= XML_PARSE_SAX1;

	sub	ebx, 512				; 00000200H
	mov	DWORD PTR [eax+56], OFFSET _xmlSAX2StartElement
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+60], OFFSET _xmlSAX2EndElement
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+116], 0
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+120], 0
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+108], 1

; 15096: 	ctxt->options |= XML_PARSE_SAX1;

	or	DWORD PTR [esi+360], 512		; 00000200H
$LN48@xmlCtxtUse:

; 15097:     }
; 15098: #endif /* LIBXML_SAX1_ENABLED */
; 15099:     if (options & XML_PARSE_NODICT) {

	test	ebx, 4096				; 00001000H
	je	SHORT $LN23@xmlCtxtUse

; 15100:         ctxt->dictNames = 0;
; 15101:         options -= XML_PARSE_NODICT;
; 15102: 	ctxt->options |= XML_PARSE_NODICT;

	or	DWORD PTR [esi+360], 4096		; 00001000H
	sub	ebx, 4096				; 00001000H
	xor	eax, eax

; 15103:     } else {

	jmp	SHORT $LN24@xmlCtxtUse
$LN23@xmlCtxtUse:

; 15104:         ctxt->dictNames = 1;

	mov	eax, 1
$LN24@xmlCtxtUse:

; 15105:     }
; 15106:     if (options & XML_PARSE_NOCDATA) {

	mov	DWORD PTR [esi+364], eax
	test	ebx, 16384				; 00004000H
	je	SHORT $LN49@xmlCtxtUse

; 15107:         ctxt->sax->cdataBlock = NULL;

	mov	eax, DWORD PTR [esi]

; 15108:         options -= XML_PARSE_NOCDATA;

	sub	ebx, 16384				; 00004000H
	mov	DWORD PTR [eax+100], 0

; 15109: 	ctxt->options |= XML_PARSE_NOCDATA;

	or	DWORD PTR [esi+360], 16384		; 00004000H
$LN49@xmlCtxtUse:

; 15110:     }
; 15111:     if (options & XML_PARSE_NSCLEAN) {

	test	ebx, 8192				; 00002000H
	je	SHORT $LN50@xmlCtxtUse

; 15112: 	ctxt->options |= XML_PARSE_NSCLEAN;

	or	DWORD PTR [esi+360], 8192		; 00002000H

; 15113:         options -= XML_PARSE_NSCLEAN;

	sub	ebx, 8192				; 00002000H
$LN50@xmlCtxtUse:

; 15114:     }
; 15115:     if (options & XML_PARSE_NONET) {

	test	ebx, 2048				; 00000800H
	je	SHORT $LN51@xmlCtxtUse

; 15116: 	ctxt->options |= XML_PARSE_NONET;

	or	DWORD PTR [esi+360], 2048		; 00000800H

; 15117:         options -= XML_PARSE_NONET;

	sub	ebx, 2048				; 00000800H
$LN51@xmlCtxtUse:

; 15118:     }
; 15119:     if (options & XML_PARSE_COMPACT) {

	test	ebx, 65536				; 00010000H
	je	SHORT $LN52@xmlCtxtUse

; 15120: 	ctxt->options |= XML_PARSE_COMPACT;

	or	DWORD PTR [esi+360], 65536		; 00010000H

; 15121:         options -= XML_PARSE_COMPACT;

	sub	ebx, 65536				; 00010000H
$LN52@xmlCtxtUse:

; 15122:     }
; 15123:     if (options & XML_PARSE_OLD10) {

	test	ebx, 131072				; 00020000H
	je	SHORT $LN53@xmlCtxtUse

; 15124: 	ctxt->options |= XML_PARSE_OLD10;

	or	DWORD PTR [esi+360], 131072		; 00020000H

; 15125:         options -= XML_PARSE_OLD10;

	sub	ebx, 131072				; 00020000H
$LN53@xmlCtxtUse:

; 15126:     }
; 15127:     if (options & XML_PARSE_NOBASEFIX) {

	test	ebx, 262144				; 00040000H
	je	SHORT $LN54@xmlCtxtUse

; 15128: 	ctxt->options |= XML_PARSE_NOBASEFIX;

	or	DWORD PTR [esi+360], 262144		; 00040000H

; 15129:         options -= XML_PARSE_NOBASEFIX;

	sub	ebx, 262144				; 00040000H
$LN54@xmlCtxtUse:

; 15130:     }
; 15131:     if (options & XML_PARSE_HUGE) {

	test	ebx, 524288				; 00080000H
	je	SHORT $LN32@xmlCtxtUse

; 15132: 	ctxt->options |= XML_PARSE_HUGE;

	or	DWORD PTR [esi+360], 524288		; 00080000H

; 15133:         options -= XML_PARSE_HUGE;

	sub	ebx, 524288				; 00080000H

; 15134:         if (ctxt->dict != NULL)

	mov	eax, DWORD PTR [esi+296]
	test	eax, eax
	je	SHORT $LN32@xmlCtxtUse

; 15135:             xmlDictSetLimit(ctxt->dict, 0);

	push	0
	push	eax
	call	_xmlDictSetLimit
	add	esp, 8
$LN32@xmlCtxtUse:

; 15136:     }
; 15137:     if (options & XML_PARSE_OLDSAX) {

	test	ebx, 1048576				; 00100000H
	je	SHORT $LN55@xmlCtxtUse

; 15138: 	ctxt->options |= XML_PARSE_OLDSAX;

	or	DWORD PTR [esi+360], 1048576		; 00100000H

; 15139:         options -= XML_PARSE_OLDSAX;

	sub	ebx, 1048576				; 00100000H
$LN55@xmlCtxtUse:

; 15140:     }
; 15141:     if (options & XML_PARSE_IGNORE_ENC) {

	test	ebx, 2097152				; 00200000H
	je	SHORT $LN56@xmlCtxtUse

; 15142: 	ctxt->options |= XML_PARSE_IGNORE_ENC;

	or	DWORD PTR [esi+360], 2097152		; 00200000H

; 15143:         options -= XML_PARSE_IGNORE_ENC;

	sub	ebx, 2097152				; 00200000H
$LN56@xmlCtxtUse:

; 15144:     }
; 15145:     if (options & XML_PARSE_BIG_LINES) {

	test	ebx, 4194304				; 00400000H
	je	SHORT $LN35@xmlCtxtUse

; 15146: 	ctxt->options |= XML_PARSE_BIG_LINES;

	or	DWORD PTR [esi+360], 4194304		; 00400000H

; 15147:         options -= XML_PARSE_BIG_LINES;

	sub	ebx, 4194304				; 00400000H
$LN35@xmlCtxtUse:

; 15148:     }
; 15149:     ctxt->linenumbers = 1;
; 15150:     return (options);

	mov	eax, ebx
	mov	DWORD PTR [esi+280], 1
	pop	ebx
	pop	esi

; 15151: }

	pop	ebp
	ret	0
_xmlCtxtUseOptionsInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseExternalEntityPrivate
_TEXT	SEGMENT
_newRoot$1$ = -12					; size = 4
_oldsax$1$ = -8						; size = 4
_start$ = -4						; size = 4
_doc$ = 8						; size = 4
_oldctxt$ = 12						; size = 4
_sax$ = 16						; size = 4
_user_data$ = 20					; size = 4
_ret$1$ = 24						; size = 4
_depth$ = 24						; size = 4
_URL$ = 28						; size = 4
_ID$ = 32						; size = 4
_list$ = 36						; size = 4
_xmlParseExternalEntityPrivate PROC			; COMDAT

; 13077: 		      const xmlChar *ID, xmlNodePtr *list) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _depth$[ebp]
	mov	edi, DWORD PTR _oldctxt$[ebp]
	mov	DWORD PTR _oldsax$1$[ebp], 0
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN6@xmlParseEx

; 13078:     xmlParserCtxtPtr ctxt;
; 13079:     xmlDocPtr newDoc;
; 13080:     xmlNodePtr newRoot;
; 13081:     xmlSAXHandlerPtr oldsax = NULL;
; 13082:     xmlParserErrors ret = XML_ERR_OK;
; 13083:     xmlChar start[4];
; 13084:     xmlCharEncoding enc;
; 13085: 
; 13086:     if (((depth > 40) &&
; 13087: 	((oldctxt == NULL) || (oldctxt->options & XML_PARSE_HUGE) == 0)) ||

	test	edi, edi
	je	SHORT $LN5@xmlParseEx
	test	DWORD PTR [edi+360], 524288		; 00080000H
	je	SHORT $LN5@xmlParseEx
$LN6@xmlParseEx:
	cmp	eax, 1024				; 00000400H
	jle	SHORT $LN4@xmlParseEx
$LN5@xmlParseEx:

; 13088: 	(depth > 1024)) {
; 13089: 	return(XML_ERR_ENTITY_LOOP);

	mov	eax, 89					; 00000059H
	pop	edi

; 13262: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlParseEx:

; 13090:     }
; 13091: 
; 13092:     if (list != NULL)

	mov	eax, DWORD PTR _list$[ebp]
	test	eax, eax
	je	SHORT $LN7@xmlParseEx

; 13093:         *list = NULL;

	mov	DWORD PTR [eax], 0
$LN7@xmlParseEx:

; 13094:     if ((URL == NULL) && (ID == NULL))

	mov	edx, DWORD PTR _URL$[ebp]
	mov	ecx, DWORD PTR _ID$[ebp]
	test	edx, edx
	jne	SHORT $LN8@xmlParseEx
	test	ecx, ecx
	je	SHORT $LN272@xmlParseEx
$LN8@xmlParseEx:

; 13095: 	return(XML_ERR_INTERNAL_ERROR);
; 13096:     if (doc == NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN9@xmlParseEx
$LN272@xmlParseEx:

; 13097: 	return(XML_ERR_INTERNAL_ERROR);

	mov	eax, 1
	pop	edi

; 13262: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlParseEx:
	push	esi

; 13098: 
; 13099: 
; 13100:     ctxt = xmlCreateEntityParserCtxtInternal(URL, ID, NULL, oldctxt);

	push	edi
	push	0
	push	ecx
	push	edx
	call	_xmlCreateEntityParserCtxtInternal
	mov	esi, eax
	add	esp, 16					; 00000010H

; 13101:     if (ctxt == NULL) return(XML_WAR_UNDECLARED_ENTITY);

	test	esi, esi
	jne	SHORT $LN10@xmlParseEx
	lea	eax, DWORD PTR [esi+27]
	pop	esi
	pop	edi

; 13262: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlParseEx:

; 13102:     ctxt->userData = ctxt;

	mov	DWORD PTR [esi+4], esi

; 13103:     if (oldctxt != NULL) {

	test	edi, edi
	je	SHORT $LN11@xmlParseEx

; 13104: 	ctxt->_private = oldctxt->_private;

	mov	eax, DWORD PTR [edi+272]
	mov	DWORD PTR [esi+272], eax

; 13105: 	ctxt->loadsubset = oldctxt->loadsubset;

	mov	eax, DWORD PTR [edi+276]
	mov	DWORD PTR [esi+276], eax

; 13106: 	ctxt->validate = oldctxt->validate;

	mov	eax, DWORD PTR [edi+104]
	mov	DWORD PTR [esi+104], eax

; 13107: 	ctxt->external = oldctxt->external;

	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], eax

; 13108: 	ctxt->record_info = oldctxt->record_info;

	mov	eax, DWORD PTR [edi+68]
	mov	DWORD PTR [esi+68], eax

; 13109: 	ctxt->node_seq.maximum = oldctxt->node_seq.maximum;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+72], eax

; 13110: 	ctxt->node_seq.length = oldctxt->node_seq.length;

	mov	eax, DWORD PTR [edi+76]
	mov	DWORD PTR [esi+76], eax

; 13111: 	ctxt->node_seq.buffer = oldctxt->node_seq.buffer;

	mov	eax, DWORD PTR [edi+80]
	mov	DWORD PTR [esi+80], eax

; 13112:     } else {

	jmp	SHORT $LN12@xmlParseEx
$LN11@xmlParseEx:

; 13113: 	/*
; 13114: 	 * Doing validity checking on chunk without context
; 13115: 	 * doesn't make sense
; 13116: 	 */
; 13117: 	ctxt->_private = NULL;

	mov	DWORD PTR [esi+272], 0

; 13118: 	ctxt->validate = 0;

	mov	DWORD PTR [esi+104], 0

; 13119: 	ctxt->external = 2;

	mov	DWORD PTR [esi+96], 2

; 13120: 	ctxt->loadsubset = 0;

	mov	DWORD PTR [esi+276], 0
$LN12@xmlParseEx:

; 13121:     }
; 13122:     if (sax != NULL) {

	mov	eax, DWORD PTR _sax$[ebp]
	test	eax, eax
	je	SHORT $LN14@xmlParseEx

; 13123: 	oldsax = ctxt->sax;

	mov	ecx, DWORD PTR [esi]

; 13124:         ctxt->sax = sax;

	mov	DWORD PTR [esi], eax

; 13125: 	if (user_data != NULL)

	mov	eax, DWORD PTR _user_data$[ebp]
	mov	DWORD PTR _oldsax$1$[ebp], ecx
	test	eax, eax
	je	SHORT $LN14@xmlParseEx

; 13126: 	    ctxt->userData = user_data;

	mov	DWORD PTR [esi+4], eax
$LN14@xmlParseEx:
	push	ebx

; 13127:     }
; 13128:     xmlDetectSAX2(ctxt);

	push	esi
	call	_xmlDetectSAX2

; 13129:     newDoc = xmlNewDoc(BAD_CAST "1.0");

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlNewDoc
	mov	ebx, eax
	add	esp, 8

; 13130:     if (newDoc == NULL) {

	test	ebx, ebx
	jne	SHORT $LN15@xmlParseEx

; 13131: 	ctxt->node_seq.maximum = 0;
; 13132: 	ctxt->node_seq.length = 0;
; 13133: 	ctxt->node_seq.buffer = NULL;
; 13134: 	xmlFreeParserCtxt(ctxt);

	push	esi
	mov	DWORD PTR [esi+72], eax
	mov	DWORD PTR [esi+76], eax
	mov	DWORD PTR [esi+80], eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13135: 	return(XML_ERR_INTERNAL_ERROR);

	lea	eax, DWORD PTR [ebx+1]
	pop	ebx
	pop	esi
	pop	edi

; 13262: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlParseEx:

; 13136:     }
; 13137:     newDoc->properties = XML_DOC_INTERNAL;
; 13138:     newDoc->intSubset = doc->intSubset;

	mov	ecx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [ebx+92], 64			; 00000040H
	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [ebx+44], eax

; 13139:     newDoc->extSubset = doc->extSubset;

	mov	eax, DWORD PTR [ecx+48]
	mov	DWORD PTR [ebx+48], eax

; 13140:     newDoc->dict = doc->dict;

	mov	eax, DWORD PTR [ecx+80]

; 13141:     xmlDictReference(newDoc->dict);

	push	eax
	mov	DWORD PTR [ebx+80], eax
	call	_xmlDictReference

; 13142: 
; 13143:     if (doc->URL != NULL) {

	mov	eax, DWORD PTR _doc$[ebp]
	add	esp, 4
	mov	eax, DWORD PTR [eax+72]
	test	eax, eax
	je	SHORT $LN16@xmlParseEx

; 13144: 	newDoc->URL = xmlStrdup(doc->URL);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+72], eax
$LN16@xmlParseEx:

; 13145:     }
; 13146:     newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST "pseudoroot", NULL);

	push	0
	push	OFFSET ??_C@_0L@OLLEMIAI@pseudoroot@
	push	0
	push	ebx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _newRoot$1$[ebp], eax

; 13147:     if (newRoot == NULL) {

	test	eax, eax
	jne	SHORT $LN17@xmlParseEx

; 13148: 	if (sax != NULL)

	cmp	DWORD PTR _sax$[ebp], eax
	je	SHORT $LN18@xmlParseEx

; 13149: 	    ctxt->sax = oldsax;

	mov	eax, DWORD PTR _oldsax$1$[ebp]
	mov	DWORD PTR [esi], eax
$LN18@xmlParseEx:

; 13150: 	ctxt->node_seq.maximum = 0;
; 13151: 	ctxt->node_seq.length = 0;
; 13152: 	ctxt->node_seq.buffer = NULL;
; 13153: 	xmlFreeParserCtxt(ctxt);

	push	esi
	mov	DWORD PTR [esi+72], 0
	mov	DWORD PTR [esi+76], 0
	mov	DWORD PTR [esi+80], 0
	call	_xmlFreeParserCtxt

; 13154: 	newDoc->intSubset = NULL;
; 13155: 	newDoc->extSubset = NULL;
; 13156:         xmlFreeDoc(newDoc);

	push	ebx
	mov	DWORD PTR [ebx+44], 0
	mov	DWORD PTR [ebx+48], 0
	call	_xmlFreeDoc

; 13257:     newDoc->intSubset = NULL;
; 13258:     newDoc->extSubset = NULL;
; 13259:     xmlFreeDoc(newDoc);

	add	esp, 8
	mov	eax, 1
	pop	ebx
	pop	esi
	pop	edi

; 13262: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlParseEx:

; 13157: 	return(XML_ERR_INTERNAL_ERROR);
; 13158:     }
; 13159:     xmlAddChild((xmlNodePtr) newDoc, newRoot);

	push	eax
	push	ebx
	call	_xmlAddChild

; 13160:     nodePush(ctxt, newDoc->children);

	push	DWORD PTR [ebx+12]
	push	esi
	call	_nodePush

; 13161:     ctxt->myDoc = doc;
; 13162:     newRoot->doc = doc;

	mov	ecx, DWORD PTR _newRoot$1$[ebp]
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [ecx+32], eax

; 13163: 
; 13164:     /*
; 13165:      * Get the 4 first bytes and decode the charset
; 13166:      * if enc != XML_CHAR_ENCODING_NONE
; 13167:      * plug some encoding conversion routines.
; 13168:      */
; 13169:     GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN19@xmlParseEx
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN19@xmlParseEx
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN19@xmlParseEx:

; 13170:     if ((ctxt->input->end - ctxt->input->cur) >= 4) {

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	cmp	eax, 4
	jl	SHORT $LN21@xmlParseEx

; 13171: 	start[0] = RAW;

	movzx	eax, BYTE PTR [ecx]
	mov	BYTE PTR _start$[ebp], al

; 13172: 	start[1] = NXT(1);

	mov	eax, DWORD PTR [esi+36]

; 13173: 	start[2] = NXT(2);
; 13174: 	start[3] = NXT(3);
; 13175: 	enc = xmlDetectCharEncoding(start, 4);

	push	4
	mov	eax, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [eax+1]
	mov	BYTE PTR _start$[ebp+1], al
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [eax+2]
	mov	BYTE PTR _start$[ebp+2], al
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [eax+3]
	mov	BYTE PTR _start$[ebp+3], al
	lea	eax, DWORD PTR _start$[ebp]
	push	eax
	call	_xmlDetectCharEncoding
	add	esp, 8

; 13176: 	if (enc != XML_CHAR_ENCODING_NONE) {

	test	eax, eax
	je	SHORT $LN21@xmlParseEx

; 13177: 	    xmlSwitchEncoding(ctxt, enc);

	push	eax
	push	esi
	call	_xmlSwitchEncoding
	add	esp, 8
$LN21@xmlParseEx:

; 13178: 	}
; 13179:     }
; 13180: 
; 13181:     /*
; 13182:      * Parse a possible text declaration first
; 13183:      */
; 13184:     if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 60			; 0000003cH
	jne	SHORT $LN22@xmlParseEx
	cmp	BYTE PTR [eax+1], 63			; 0000003fH
	jne	SHORT $LN22@xmlParseEx
	cmp	BYTE PTR [eax+2], 120			; 00000078H
	jne	SHORT $LN22@xmlParseEx
	cmp	BYTE PTR [eax+3], 109			; 0000006dH
	jne	SHORT $LN22@xmlParseEx
	cmp	BYTE PTR [eax+4], 108			; 0000006cH
	jne	SHORT $LN22@xmlParseEx
	mov	al, BYTE PTR [eax+5]
	cmp	al, 32					; 00000020H
	je	SHORT $LN23@xmlParseEx
	cmp	al, 9
	jb	SHORT $LN24@xmlParseEx
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN23@xmlParseEx
$LN24@xmlParseEx:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN22@xmlParseEx
$LN23@xmlParseEx:

; 13185: 	xmlParseTextDecl(ctxt);

	push	esi
	call	_xmlParseTextDecl
	add	esp, 4
$LN22@xmlParseEx:

; 13186:     }
; 13187: 
; 13188:     ctxt->instate = XML_PARSER_CONTENT;
; 13189:     ctxt->depth = depth;

	mov	eax, DWORD PTR _depth$[ebp]

; 13190: 
; 13191:     xmlParseContent(ctxt);

	push	esi
	mov	DWORD PTR [esi+172], 7
	mov	DWORD PTR [esi+248], eax
	call	_xmlParseContent

; 13192: 
; 13193:     if ((RAW == '<') && (NXT(1) == '/')) {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [eax+16]
	mov	cl, BYTE PTR [eax]
	cmp	cl, 60					; 0000003cH
	jne	SHORT $LN25@xmlParseEx
	cmp	BYTE PTR [eax+1], 47			; 0000002fH
	jne	SHORT $LN25@xmlParseEx

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN65@xmlParseEx
	cmp	DWORD PTR [esi+172], -1
	je	$LN196@xmlParseEx
$LN65@xmlParseEx:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 85			; 00000055H
	push	85					; 00000055H

; 556  :     }
; 557  : }

	jmp	SHORT $LN277@xmlParseEx
$LN25@xmlParseEx:

; 13194: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
; 13195:     } else if (RAW != 0) {

	test	cl, cl
	je	SHORT $LN196@xmlParseEx

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN271@xmlParseEx
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN196@xmlParseEx
$LN271@xmlParseEx:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0DA@BPKCCNLP@extra?5content?5at?5the?5end?5of?5wel@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 86			; 00000056H
	push	86					; 00000056H
$LN277@xmlParseEx:

; 13196: 	xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
; 13197:     }
; 13198:     if (ctxt->node != newDoc->children) {

	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	mov	DWORD PTR [esi+12], 0
	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN196@xmlParseEx
	mov	DWORD PTR [esi+212], 1
$LN196@xmlParseEx:
	mov	eax, DWORD PTR [esi+52]
	cmp	eax, DWORD PTR [ebx+12]
	je	SHORT $LN264@xmlParseEx

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN201@xmlParseEx
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN264@xmlParseEx
$LN201@xmlParseEx:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	85					; 00000055H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 85			; 00000055H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN264@xmlParseEx

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN264@xmlParseEx:

; 13199: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
; 13200:     }
; 13201: 
; 13202:     if (!ctxt->wellFormed) {

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN29@xmlParseEx

; 13203:         if (ctxt->errNo == 0)

	mov	eax, DWORD PTR [esi+84]
	mov	ecx, 1
	test	eax, eax
	cmove	eax, ecx
	mov	DWORD PTR _ret$1$[ebp], eax

; 13204: 	    ret = XML_ERR_INTERNAL_ERROR;
; 13205: 	else
; 13206: 	    ret = (xmlParserErrors)ctxt->errNo;
; 13207:     } else {

	jmp	SHORT $LN30@xmlParseEx
$LN29@xmlParseEx:

; 13208: 	if (list != NULL) {

	mov	ecx, DWORD PTR _list$[ebp]
	test	ecx, ecx
	je	SHORT $LN33@xmlParseEx

; 13209: 	    xmlNodePtr cur;
; 13210: 
; 13211: 	    /*
; 13212: 	     * Return the newly created nodeset after unlinking it from
; 13213: 	     * they pseudo parent.
; 13214: 	     */
; 13215: 	    cur = newDoc->children->children;

	mov	eax, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [eax+12]

; 13216: 	    *list = cur;

	mov	DWORD PTR [ecx], eax

; 13217: 	    while (cur != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlParseEx
	npad	4
$LL2@xmlParseEx:

; 13218: 		cur->parent = NULL;

	mov	DWORD PTR [eax+20], 0

; 13219: 		cur = cur->next;

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL2@xmlParseEx
$LN3@xmlParseEx:

; 13220: 	    }
; 13221:             newDoc->children->children = NULL;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+12], 0
$LN33@xmlParseEx:

; 13222: 	}
; 13223: 	ret = XML_ERR_OK;

	mov	DWORD PTR _ret$1$[ebp], 0
$LN30@xmlParseEx:

; 13224:     }
; 13225: 
; 13226:     /*
; 13227:      * Record in the parent context the number of entities replacement
; 13228:      * done when parsing that reference.
; 13229:      */
; 13230:     if (oldctxt != NULL)

	test	edi, edi
	je	SHORT $LN34@xmlParseEx

; 13231:         oldctxt->nbentities += ctxt->nbentities;

	mov	eax, DWORD PTR [esi+440]
	add	DWORD PTR [edi+440], eax
$LN34@xmlParseEx:

; 13232: 
; 13233:     /*
; 13234:      * Also record the size of the entity parsed
; 13235:      */
; 13236:     if (ctxt->input != NULL && oldctxt != NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN35@xmlParseEx
	test	edi, edi
	je	SHORT $LN36@xmlParseEx

; 13237: 	oldctxt->sizeentities += ctxt->input->consumed;

	mov	eax, DWORD PTR [eax+36]
	add	DWORD PTR [edi+444], eax

; 13238: 	oldctxt->sizeentities += (ctxt->input->cur - ctxt->input->base);

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR [eax+12]
	add	DWORD PTR [edi+444], ecx
$LN35@xmlParseEx:

; 13239:     }
; 13240:     /*
; 13241:      * And record the last error if any
; 13242:      */
; 13243:     if ((oldctxt != NULL) && (ctxt->lastError.code != XML_ERR_OK))

	test	edi, edi
	je	SHORT $LN36@xmlParseEx
	cmp	DWORD PTR [esi+388], 0
	je	SHORT $LN36@xmlParseEx

; 13244:         xmlCopyError(&ctxt->lastError, &oldctxt->lastError);

	lea	eax, DWORD PTR [edi+384]
	push	eax
	lea	eax, DWORD PTR [esi+384]
	push	eax
	call	_xmlCopyError
	add	esp, 8
$LN36@xmlParseEx:

; 13245: 
; 13246:     if (sax != NULL)

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN37@xmlParseEx

; 13247: 	ctxt->sax = oldsax;

	mov	eax, DWORD PTR _oldsax$1$[ebp]
	mov	DWORD PTR [esi], eax
$LN37@xmlParseEx:

; 13248:     if (oldctxt != NULL) {

	test	edi, edi
	je	SHORT $LN38@xmlParseEx

; 13249:         oldctxt->node_seq.maximum = ctxt->node_seq.maximum;

	mov	eax, DWORD PTR [esi+72]
	mov	DWORD PTR [edi+72], eax

; 13250:         oldctxt->node_seq.length = ctxt->node_seq.length;

	mov	eax, DWORD PTR [esi+76]
	mov	DWORD PTR [edi+76], eax

; 13251:         oldctxt->node_seq.buffer = ctxt->node_seq.buffer;

	mov	eax, DWORD PTR [esi+80]
	mov	DWORD PTR [edi+80], eax
$LN38@xmlParseEx:

; 13252:     }
; 13253:     ctxt->node_seq.maximum = 0;
; 13254:     ctxt->node_seq.length = 0;
; 13255:     ctxt->node_seq.buffer = NULL;
; 13256:     xmlFreeParserCtxt(ctxt);

	push	esi
	mov	DWORD PTR [esi+72], 0
	mov	DWORD PTR [esi+76], 0
	mov	DWORD PTR [esi+80], 0
	call	_xmlFreeParserCtxt

; 13257:     newDoc->intSubset = NULL;
; 13258:     newDoc->extSubset = NULL;
; 13259:     xmlFreeDoc(newDoc);

	push	ebx
	mov	DWORD PTR [ebx+44], 0
	mov	DWORD PTR [ebx+48], 0
	call	_xmlFreeDoc

; 13260: 
; 13261:     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 8
	pop	ebx
	pop	esi
	pop	edi

; 13262: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseExternalEntityPrivate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseStringPEReference
_TEXT	SEGMENT
_entity$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_ptr$2$ = 12						; size = 4
_ptr$ = 12						; size = 4
_str$ = 12						; size = 4
_xmlParseStringPEReference PROC				; COMDAT

; 8093 : xmlParseStringPEReference(xmlParserCtxtPtr ctxt, const xmlChar **str) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _str$[ebp]
	xor	eax, eax
	mov	DWORD PTR _entity$1$[ebp], eax
	test	ebx, ebx
	je	$LN3@xmlParseSt

; 8094 :     const xmlChar *ptr;
; 8095 :     xmlChar cur;
; 8096 :     xmlChar *name;
; 8097 :     xmlEntityPtr entity = NULL;
; 8098 : 
; 8099 :     if ((str == NULL) || (*str == NULL)) return(NULL);

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	$LN3@xmlParseSt

; 8100 :     ptr = *str;
; 8101 :     cur = *ptr;
; 8102 :     if (cur != '%')

	cmp	BYTE PTR [eax], 37			; 00000025H
	jne	$LN3@xmlParseSt

; 8103 :         return(NULL);
; 8104 :     ptr++;

	push	esi

; 8105 :     name = xmlParseStringName(ctxt, &ptr);

	mov	esi, DWORD PTR _ctxt$[ebp]
	inc	eax
	mov	DWORD PTR _ptr$[ebp], eax
	lea	eax, DWORD PTR _ptr$[ebp]
	push	edi
	push	eax
	push	esi
	call	_xmlParseStringName
	mov	edi, eax
	add	esp, 8

; 8106 :     if (name == NULL) {

	test	edi, edi
	jne	SHORT $LN5@xmlParseSt

; 8107 : 	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0CE@PLGLFALL@xmlParseStringPEReference?3?5no?5n@
	push	68					; 00000044H
	push	esi
	call	_xmlFatalErrMsg

; 8108 : 		       "xmlParseStringPEReference: no name\n");
; 8109 : 	*str = ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebx], eax

; 8110 : 	return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 8179 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlParseSt:

; 8111 :     }
; 8112 :     cur = *ptr;
; 8113 :     if (cur != ';') {

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _ptr$2$[ebp], eax
	cmp	BYTE PTR [eax], 59			; 0000003bH
	je	$LN6@xmlParseSt

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	test	esi, esi
	je	SHORT $LN78@xmlParseSt
	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN19@xmlParseSt
	cmp	DWORD PTR [esi+172], -1
	je	$LN183@xmlParseSt
$LN19@xmlParseSt:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;

	mov	DWORD PTR [esi+84], 23			; 00000017H
$LN78@xmlParseSt:

; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BJ@KLEMOBLL@EntityRef?3?5expecting?5?8?$DL?8@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	23					; 00000017H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN183@xmlParseSt

; 553  : 	ctxt->wellFormed = 0;
; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+12], 0
	jne	SHORT $LN183@xmlParseSt

; 8133 : 	xmlFree(name);

	push	edi

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1

; 8133 : 	xmlFree(name);

	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _ptr$[ebp]
	add	esp, 4
	mov	DWORD PTR [ebx], eax
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 8179 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlParseSt:

; 8114 : 	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
; 8115 : 	xmlFree(name);
; 8116 : 	*str = ptr;
; 8117 : 	return(NULL);
; 8118 :     }
; 8119 :     ptr++;
; 8120 : 
; 8121 :     /*
; 8122 :      * Increate the number of entity references parsed
; 8123 :      */
; 8124 :     ctxt->nbentities++;

	inc	DWORD PTR [esi+440]
	inc	eax
	mov	DWORD PTR _ptr$2$[ebp], eax

; 8125 : 
; 8126 :     /*
; 8127 :      * Request the entity from SAX
; 8128 :      */
; 8129 :     if ((ctxt->sax != NULL) &&

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN185@xmlParseSt
	mov	eax, DWORD PTR [eax+96]
	test	eax, eax
	je	SHORT $LN185@xmlParseSt

; 8130 : 	(ctxt->sax->getParameterEntity != NULL))
; 8131 : 	entity = ctxt->sax->getParameterEntity(ctxt->userData, name);

	push	edi
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 8
	mov	DWORD PTR _entity$1$[ebp], eax
	jmp	SHORT $LN7@xmlParseSt
$LN185@xmlParseSt:

; 8132 :     if (ctxt->instate == XML_PARSER_EOF) {

	xor	eax, eax
$LN7@xmlParseSt:
	cmp	DWORD PTR [esi+172], -1
	jne	SHORT $LN8@xmlParseSt
$LN183@xmlParseSt:

; 8133 : 	xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _ptr$[ebp]
	add	esp, 4
	mov	DWORD PTR [ebx], eax
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 8179 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlParseSt:

; 8134 : 	*str = ptr;
; 8135 : 	return(NULL);
; 8136 :     }
; 8137 :     if (entity == NULL) {

	test	eax, eax
	jne	SHORT $LN9@xmlParseSt

; 8138 : 	/*
; 8139 : 	 * [ WFC: Entity Declared ]
; 8140 : 	 * In a document without any DTD, a document with only an
; 8141 : 	 * internal DTD subset which contains no parameter entity
; 8142 : 	 * references, or a document with "standalone='yes'", ...
; 8143 : 	 * ... The declaration of a parameter entity must precede
; 8144 : 	 * any reference to it...
; 8145 : 	 */
; 8146 : 	if ((ctxt->standalone == 1) ||

	cmp	DWORD PTR [esi+28], 1
	je	SHORT $LN13@xmlParseSt
	cmp	DWORD PTR [esi+88], eax
	jne	SHORT $LN11@xmlParseSt
	cmp	DWORD PTR [esi+92], eax
	je	SHORT $LN13@xmlParseSt
$LN11@xmlParseSt:

; 8149 : 		 "PEReference: %%%s; not found\n", name);
; 8150 : 	} else {
; 8151 : 	    /*
; 8152 : 	     * [ VC: Entity Declared ]
; 8153 : 	     * In a document with an external subset or external
; 8154 : 	     * parameter entities with "standalone='no'", ...
; 8155 : 	     * ... The declaration of a parameter entity must
; 8156 : 	     * precede any reference to it...
; 8157 : 	     */
; 8158 : 	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,

	push	0
	push	edi
	push	OFFSET ??_C@_0BO@KINMDPMC@PEReference?3?5?$CF?$CF?$CFs?$DL?5not?5found?6@
	push	27					; 0000001bH
	push	esi
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H

; 8159 : 			  "PEReference: %%%s; not found\n",
; 8160 : 			  name, NULL);
; 8161 : 	    ctxt->valid = 0;

	mov	DWORD PTR [esi+100], 0

; 8162 : 	}
; 8163 : 	xmlParserEntityCheck(ctxt, 0, NULL, 0);

	push	0
	push	0
	push	0
	push	esi
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H

; 8164 :     } else {

	jmp	SHORT $LN14@xmlParseSt
$LN13@xmlParseSt:

; 8147 : 	    ((ctxt->hasExternalSubset == 0) && (ctxt->hasPErefs == 0))) {
; 8148 : 	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,

	push	edi
	push	OFFSET ??_C@_0BO@KINMDPMC@PEReference?3?5?$CF?$CF?$CFs?$DL?5not?5found?6@
	push	26					; 0000001aH
	push	esi
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 8162 : 	}
; 8163 : 	xmlParserEntityCheck(ctxt, 0, NULL, 0);

	push	0
	push	0
	push	0
	push	esi
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H

; 8164 :     } else {

	jmp	SHORT $LN14@xmlParseSt
$LN9@xmlParseSt:

; 8165 : 	/*
; 8166 : 	 * Internal checking in case the entity quest barfed
; 8167 : 	 */
; 8168 : 	if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&

	mov	eax, DWORD PTR [eax+48]
	cmp	eax, 4
	je	SHORT $LN14@xmlParseSt
	cmp	eax, 5
	je	SHORT $LN14@xmlParseSt

; 8169 : 	    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
; 8170 : 	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,

	push	0
	push	edi
	push	OFFSET ??_C@_0CB@HMFAEMHO@?$CF?$CF?$CFs?$DL?5is?5not?5a?5parameter?5entity@
	push	27					; 0000001bH
	push	esi
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H
$LN14@xmlParseSt:

; 8171 : 			  "%%%s; is not a parameter entity\n",
; 8172 : 			  name, NULL);
; 8173 : 	}
; 8174 :     }
; 8175 :     ctxt->hasPErefs = 1;
; 8176 :     xmlFree(name);

	push	edi
	mov	DWORD PTR [esi+92], 1
	call	DWORD PTR _xmlFree

; 8177 :     *str = ptr;

	mov	eax, DWORD PTR _ptr$2$[ebp]
	add	esp, 4
	mov	DWORD PTR [ebx], eax

; 8178 :     return(entity);

	mov	eax, DWORD PTR _entity$1$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 8179 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlParseSt:

; 8094 :     const xmlChar *ptr;
; 8095 :     xmlChar cur;
; 8096 :     xmlChar *name;
; 8097 :     xmlEntityPtr entity = NULL;
; 8098 : 
; 8099 :     if ((str == NULL) || (*str == NULL)) return(NULL);

	xor	eax, eax
	pop	ebx

; 8179 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseStringPEReference ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParserEntityCheck
_TEXT	SEGMENT
_rep$1$ = -4						; size = 4
_oldnbent$1$ = 8					; size = 4
_ctxt$ = 8						; size = 4
_size$ = 12						; size = 4
_ent$ = 16						; size = 4
_replacement$ = 20					; size = 4
_xmlParserEntityCheck PROC				; COMDAT

; 130  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	test	esi, esi
	je	$LN3@xmlParserE

; 131  :     size_t consumed = 0;
; 132  : 
; 133  :     if ((ctxt == NULL) || (ctxt->options & XML_PARSE_HUGE))

	test	DWORD PTR [esi+360], 524288		; 00080000H
	jne	$LN3@xmlParserE

; 135  :     if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)

	cmp	DWORD PTR [esi+388], 89			; 00000059H
	je	$LN94@xmlParserE

; 136  :         return (1);
; 137  : 
; 138  :     /*
; 139  :      * This may look absurd but is needed to detect
; 140  :      * entities problems
; 141  :      */
; 142  :     if ((ent != NULL) && (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
; 143  : 	(ent->content != NULL) && (ent->checked == 0) &&

	mov	ebx, DWORD PTR _ent$[ebp]
	test	ebx, ebx
	je	$LN8@xmlParserE
	cmp	DWORD PTR [ebx+48], 6
	je	$LN8@xmlParserE
	cmp	DWORD PTR [ebx+40], edi
	je	$LN8@xmlParserE
	cmp	DWORD PTR [ebx+72], edi
	jne	SHORT $LN8@xmlParserE
	cmp	DWORD PTR [esi+84], 89			; 00000059H
	je	SHORT $LN8@xmlParserE

; 144  : 	(ctxt->errNo != XML_ERR_ENTITY_LOOP)) {
; 145  : 	unsigned long oldnbent = ctxt->nbentities;

	mov	eax, DWORD PTR [esi+440]

; 146  : 	xmlChar *rep;
; 147  : 
; 148  : 	ent->checked = 1;
; 149  : 
; 150  :         ++ctxt->depth;
; 151  : 	rep = xmlStringDecodeEntities(ctxt, ent->content,

	push	edi
	push	edi
	push	edi
	mov	DWORD PTR [ebx+72], 1
	inc	DWORD PTR [esi+248]
	push	1
	push	DWORD PTR [ebx+40]
	mov	DWORD PTR _oldnbent$1$[ebp], eax
	push	esi
	call	_xmlStringDecodeEntities

; 152  : 				  XML_SUBSTITUTE_REF, 0, 0, 0);
; 153  :         --ctxt->depth;

	dec	DWORD PTR [esi+248]
	mov	ecx, eax
	add	esp, 24					; 00000018H
	mov	DWORD PTR _rep$1$[ebp], ecx

; 154  : 	if ((rep == NULL) || (ctxt->errNo == XML_ERR_ENTITY_LOOP)) {

	test	ecx, ecx
	je	SHORT $LN7@xmlParserE
	cmp	DWORD PTR [esi+84], 89			; 00000059H
	jne	SHORT $LN6@xmlParserE
$LN7@xmlParserE:

; 155  : 	    ent->content[0] = 0;

	mov	eax, DWORD PTR [ebx+40]
	mov	BYTE PTR [eax], 0
$LN6@xmlParserE:

; 156  : 	}
; 157  : 
; 158  : 	ent->checked = (ctxt->nbentities - oldnbent + 1) * 2;

	mov	eax, DWORD PTR [esi+440]
	sub	eax, DWORD PTR _oldnbent$1$[ebp]
	lea	eax, DWORD PTR [eax*2+2]
	mov	DWORD PTR [ebx+72], eax

; 159  : 	if (rep != NULL) {

	test	ecx, ecx
	je	SHORT $LN8@xmlParserE

; 160  : 	    if (xmlStrchr(rep, '<'))

	push	60					; 0000003cH
	push	ecx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlParserE

; 161  : 		ent->checked |= 1;

	or	DWORD PTR [ebx+72], 1
$LN9@xmlParserE:

; 162  : 	    xmlFree(rep);

	push	DWORD PTR _rep$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlParserE:

; 163  : 	    rep = NULL;
; 164  : 	}
; 165  :     }
; 166  :     if (replacement != 0) {

	mov	ecx, DWORD PTR _replacement$[ebp]
	test	ecx, ecx
	je	SHORT $LN10@xmlParserE

; 167  : 	if (replacement < XML_MAX_TEXT_LENGTH)

	cmp	ecx, 10000000				; 00989680H
	jb	SHORT $LN3@xmlParserE

; 168  : 	    return(0);
; 169  : 
; 170  :         /*
; 171  : 	 * If the volume of entity copy reaches 10 times the
; 172  : 	 * amount of parsed data and over the large text threshold
; 173  : 	 * then that's very likely to be an abuse.
; 174  : 	 */
; 175  :         if (ctxt->input != NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN13@xmlParserE

; 176  : 	    consumed = ctxt->input->consumed +

	mov	edi, DWORD PTR [eax+36]
	sub	edi, DWORD PTR [eax+12]
	add	edi, DWORD PTR [eax+16]
$LN13@xmlParserE:

; 177  : 	               (ctxt->input->cur - ctxt->input->base);
; 178  : 	}
; 179  :         consumed += ctxt->sizeentities;
; 180  : 
; 181  :         if (replacement < XML_PARSER_NON_LINEAR * consumed)

	mov	eax, DWORD PTR [esi+444]
	add	eax, edi
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	cmp	ecx, eax
	jmp	SHORT $LN97@xmlParserE
$LN10@xmlParserE:

; 182  : 	    return(0);
; 183  :     } else if (size != 0) {

	mov	edx, DWORD PTR _size$[ebp]
	test	edx, edx
	je	SHORT $LN15@xmlParserE

; 184  :         /*
; 185  :          * Do the check based on the replacement size of the entity
; 186  :          */
; 187  :         if (size < XML_PARSER_BIG_ENTITY)

	cmp	edx, 1000				; 000003e8H
	jb	SHORT $LN3@xmlParserE

; 188  : 	    return(0);
; 189  : 
; 190  :         /*
; 191  :          * A limit on the amount of text data reasonably used
; 192  :          */
; 193  :         if (ctxt->input != NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN18@xmlParserE

; 194  :             consumed = ctxt->input->consumed +

	mov	edi, DWORD PTR [eax+36]
	sub	edi, DWORD PTR [eax+12]
	add	edi, DWORD PTR [eax+16]
$LN18@xmlParserE:

; 195  :                 (ctxt->input->cur - ctxt->input->base);
; 196  :         }
; 197  :         consumed += ctxt->sizeentities;
; 198  : 
; 199  :         if ((size < XML_PARSER_NON_LINEAR * consumed) &&

	mov	eax, DWORD PTR [esi+444]
	add	eax, edi
	lea	ecx, DWORD PTR [eax+eax*4]
	add	ecx, ecx
	cmp	edx, ecx
	jae	SHORT $LN24@xmlParserE
	mov	eax, DWORD PTR [esi+440]
	lea	eax, DWORD PTR [eax+eax*2]
$LN96@xmlParserE:

; 134  :         return (0);

	cmp	eax, ecx
$LN97@xmlParserE:
	jae	SHORT $LN24@xmlParserE
$LN3@xmlParserE:
	pop	edi

; 229  : 	    (ctxt->nbentities <= 10000))
; 230  : 	    return (0);
; 231  :     }
; 232  :     xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
; 233  :     return (1);
; 234  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlParserE:

; 200  : 	    (ctxt->nbentities * 3 < XML_PARSER_NON_LINEAR * consumed))
; 201  :             return (0);
; 202  :     } else if (ent != NULL) {

	test	ebx, ebx
	je	SHORT $LN20@xmlParserE

; 203  :         /*
; 204  :          * use the number of parsed entities in the replacement
; 205  :          */
; 206  :         size = ent->checked / 2;

	mov	eax, DWORD PTR [ebx+72]

; 207  : 
; 208  :         /*
; 209  :          * The amount of data parsed counting entities size only once
; 210  :          */
; 211  :         if (ctxt->input != NULL) {

	mov	ecx, DWORD PTR [esi+36]
	cdq
	sub	eax, edx
	mov	edx, eax
	sar	edx, 1
	test	ecx, ecx
	je	SHORT $LN22@xmlParserE

; 212  :             consumed = ctxt->input->consumed +

	mov	edi, DWORD PTR [ecx+36]
	sub	edi, DWORD PTR [ecx+12]
	add	edi, DWORD PTR [ecx+16]
$LN22@xmlParserE:

; 213  :                 (ctxt->input->cur - ctxt->input->base);
; 214  :         }
; 215  :         consumed += ctxt->sizeentities;
; 216  : 
; 217  :         /*
; 218  :          * Check the density of entities for the amount of data
; 219  : 	 * knowing an entity reference will take at least 3 bytes
; 220  :          */
; 221  :         if (size * 3 < consumed * XML_PARSER_NON_LINEAR)

	mov	eax, DWORD PTR [esi+444]
	add	eax, edi
	lea	ecx, DWORD PTR [eax+eax*4]
	add	ecx, ecx
	lea	eax, DWORD PTR [edx+edx*2]
	jmp	SHORT $LN96@xmlParserE
$LN20@xmlParserE:

; 222  :             return (0);
; 223  :     } else {
; 224  :         /*
; 225  :          * strange we got no data for checking
; 226  :          */
; 227  : 	if (((ctxt->lastError.code != XML_ERR_UNDECLARED_ENTITY) &&
; 228  : 	     (ctxt->lastError.code != XML_WAR_UNDECLARED_ENTITY)) ||

	mov	eax, DWORD PTR [esi+388]
	cmp	eax, 26					; 0000001aH
	je	SHORT $LN26@xmlParserE
	cmp	eax, 27					; 0000001bH
	jne	SHORT $LN3@xmlParserE
$LN26@xmlParserE:
	cmp	DWORD PTR [esi+440], 10000		; 00002710H
	jbe	SHORT $LN3@xmlParserE
$LN24@xmlParserE:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN31@xmlParserE
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN94@xmlParserE
$LN31@xmlParserE:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CC@LFHGNGFD@Detected?5an?5entity?5reference?5lo@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	89					; 00000059H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 89			; 00000059H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN94@xmlParserE

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN94@xmlParserE:
	pop	edi

; 229  : 	    (ctxt->nbentities <= 10000))
; 230  : 	    return (0);
; 231  :     }
; 232  :     xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
; 233  :     return (1);
; 234  : }

	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParserEntityCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlHaltParser
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlHaltParser PROC					; COMDAT

; 12451: xmlHaltParser(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN5@xmlHaltPar

; 12452:     if (ctxt == NULL)
; 12453:         return;
; 12454:     ctxt->instate = XML_PARSER_EOF;

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+172], -1

; 12455:     ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1

; 12456:     while (ctxt->inputNr > 1)

	cmp	eax, 1
	jle	SHORT $LN3@xmlHaltPar
$LL2@xmlHaltPar:

; 1748 :     if (ctxt->inputNr <= 0)

	test	eax, eax
	jg	SHORT $LN11@xmlHaltPar

; 1749 :         return (NULL);

	xor	edx, edx
	jmp	SHORT $LN9@xmlHaltPar
$LN11@xmlHaltPar:

; 1750 :     ctxt->inputNr--;

	lea	ecx, DWORD PTR [eax-1]
	mov	DWORD PTR [esi+40], ecx

; 1751 :     if (ctxt->inputNr > 0)

	test	ecx, ecx
	jle	SHORT $LN12@xmlHaltPar

; 1752 :         ctxt->input = ctxt->inputTab[ctxt->inputNr - 1];

	mov	eax, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN13@xmlHaltPar
$LN12@xmlHaltPar:

; 1753 :     else
; 1754 :         ctxt->input = NULL;

	xor	eax, eax
$LN13@xmlHaltPar:

; 1755 :     ret = ctxt->inputTab[ctxt->inputNr];

	mov	DWORD PTR [esi+36], eax
	mov	eax, DWORD PTR [esi+48]
	mov	edx, DWORD PTR [eax+ecx*4]

; 1756 :     ctxt->inputTab[ctxt->inputNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0
$LN9@xmlHaltPar:

; 12457:         xmlFreeInputStream(inputPop(ctxt));

	push	edx
	call	_xmlFreeInputStream
	mov	eax, DWORD PTR [esi+40]
	add	esp, 4
	cmp	eax, 1
	jg	SHORT $LL2@xmlHaltPar
$LN3@xmlHaltPar:

; 12458:     if (ctxt->input != NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN5@xmlHaltPar

; 12459:         /*
; 12460: 	 * in case there was a specific allocation deallocate before
; 12461: 	 * overriding base
; 12462: 	 */
; 12463:         if (ctxt->input->free != NULL) {

	mov	ecx, DWORD PTR [eax+40]
	test	ecx, ecx
	je	SHORT $LN6@xmlHaltPar

; 12464: 	    ctxt->input->free((xmlChar *) ctxt->input->base);

	push	DWORD PTR [eax+12]
	call	ecx

; 12465: 	    ctxt->input->free = NULL;

	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	mov	DWORD PTR [eax+40], 0
	mov	eax, DWORD PTR [esi+36]
$LN6@xmlHaltPar:

; 12466: 	}
; 12467:         if (ctxt->input->buf != NULL) {

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN7@xmlHaltPar

; 12468:             xmlFreeParserInputBuffer(ctxt->input->buf);

	push	ecx
	call	_xmlFreeParserInputBuffer

; 12469:             ctxt->input->buf = NULL;

	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR [esi+36]
$LN7@xmlHaltPar:

; 12470:         }
; 12471: 	ctxt->input->cur = BAD_CAST"";

	mov	DWORD PTR [eax+16], OFFSET ??_C@_00CNPNBAHC@@

; 12472:         ctxt->input->length = 0;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+24], 0

; 12473: 	ctxt->input->base = ctxt->input->cur;

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx+12], eax

; 12474:         ctxt->input->end = ctxt->input->cur;

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx+20], eax
$LN5@xmlHaltPar:
	pop	esi

; 12475:     }
; 12476: }

	pop	ebp
	ret	0
_xmlHaltParser ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCreateEntityParserCtxtInternal
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_ID$ = 12						; size = 4
_base$ = 16						; size = 4
_pctx$ = 20						; size = 4
_xmlCreateEntityParserCtxtInternal PROC			; COMDAT

; 13991: 	                  const xmlChar *base, xmlParserCtxtPtr pctx) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	edi, edi
	call	_xmlNewParserCtxt
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN2@xmlCreateE

; 14044: }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN2@xmlCreateE:

; 13992:     xmlParserCtxtPtr ctxt;
; 13993:     xmlParserInputPtr inputStream;
; 13994:     char *directory = NULL;
; 13995:     xmlChar *uri;
; 13996: 
; 13997:     ctxt = xmlNewParserCtxt();
; 13998:     if (ctxt == NULL) {
; 13999: 	return(NULL);
; 14000:     }
; 14001: 
; 14002:     if (pctx != NULL) {

	mov	ecx, DWORD PTR _pctx$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlCreateE

; 14003:         ctxt->options = pctx->options;

	mov	eax, DWORD PTR [ecx+360]
	mov	DWORD PTR [esi+360], eax

; 14004:         ctxt->_private = pctx->_private;

	mov	eax, DWORD PTR [ecx+272]
	mov	DWORD PTR [esi+272], eax

; 14005: 	/*
; 14006: 	 * this is a subparser of pctx, so the input_id should be
; 14007: 	 * incremented to distinguish from main entity
; 14008: 	 */
; 14009: 	ctxt->input_id = pctx->input_id + 1;

	mov	eax, DWORD PTR [ecx+464]
	inc	eax
	mov	DWORD PTR [esi+464], eax
$LN3@xmlCreateE:

; 14010:     }
; 14011: 
; 14012:     uri = xmlBuildURI(URL, base);

	push	ebx
	push	DWORD PTR _base$[ebp]
	push	DWORD PTR _URL$[ebp]
	call	_xmlBuildURI
	add	esp, 8
	mov	ebx, eax

; 14013: 
; 14014:     if (uri == NULL) {

	push	esi
	push	DWORD PTR _ID$[ebp]
	test	ebx, ebx
	jne	SHORT $LN4@xmlCreateE

; 14015: 	inputStream = xmlLoadExternalEntity((char *)URL, (char *)ID, ctxt);

	mov	ebx, DWORD PTR _URL$[ebp]
	push	ebx
	call	_xmlLoadExternalEntity
	add	esp, 12					; 0000000cH

; 14016: 	if (inputStream == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlCreateE

; 14017: 	    xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14018: 	    return(NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 14044: }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlCreateE:

; 14019: 	}
; 14020: 
; 14021: 	inputPush(ctxt, inputStream);

	push	eax
	push	esi
	call	_inputPush

; 14022: 
; 14023: 	if ((ctxt->directory == NULL) && (directory == NULL))

	mov	eax, DWORD PTR [esi+180]
	add	esp, 8
	test	eax, eax
	jne	$LN5@xmlCreateE

; 14024: 	    directory = xmlParserGetDirectory((char *)URL);

	push	ebx
	call	_xmlParserGetDirectory
	mov	edi, eax
	add	esp, 4
	mov	eax, DWORD PTR [esi+180]

; 14025: 	if ((ctxt->directory == NULL) && (directory != NULL))

	test	eax, eax
	jne	SHORT $LN5@xmlCreateE
	test	edi, edi
	je	SHORT $LN5@xmlCreateE

; 14026: 	    ctxt->directory = directory;

	pop	ebx
	mov	DWORD PTR [esi+180], edi

; 14042:     }
; 14043:     return(ctxt);

	mov	eax, esi
	pop	edi

; 14044: }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlCreateE:

; 14027:     } else {
; 14028: 	inputStream = xmlLoadExternalEntity((char *)uri, (char *)ID, ctxt);

	push	ebx
	call	_xmlLoadExternalEntity
	add	esp, 12					; 0000000cH

; 14029: 	if (inputStream == NULL) {

	test	eax, eax
	jne	SHORT $LN9@xmlCreateE

; 14030: 	    xmlFree(uri);

	push	ebx
	call	DWORD PTR _xmlFree

; 14031: 	    xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 8

; 14032: 	    return(NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 14044: }

	pop	esi
	pop	ebp
	ret	0
$LN9@xmlCreateE:

; 14033: 	}
; 14034: 
; 14035: 	inputPush(ctxt, inputStream);

	push	eax
	push	esi
	call	_inputPush

; 14036: 
; 14037: 	if ((ctxt->directory == NULL) && (directory == NULL))

	mov	eax, DWORD PTR [esi+180]
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlCreateE

; 14038: 	    directory = xmlParserGetDirectory((char *)uri);

	push	ebx
	call	_xmlParserGetDirectory
	mov	edi, eax
	add	esp, 4
	mov	eax, DWORD PTR [esi+180]

; 14039: 	if ((ctxt->directory == NULL) && (directory != NULL))

	test	eax, eax
	jne	SHORT $LN11@xmlCreateE
	test	edi, edi
	je	SHORT $LN11@xmlCreateE

; 14040: 	    ctxt->directory = directory;

	mov	DWORD PTR [esi+180], edi
$LN11@xmlCreateE:

; 14041: 	xmlFree(uri);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlCreateE:

; 14042:     }
; 14043:     return(ctxt);

	pop	ebx
	pop	edi
	mov	eax, esi

; 14044: }

	pop	esi
	pop	ebp
	ret	0
_xmlCreateEntityParserCtxtInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlFatalErr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_info$ = 16						; size = 4
_xmlFatalErr PROC					; COMDAT

; 353  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN4@xmlFatalEr

; 354  :     const char *errmsg;
; 355  : 
; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN4@xmlFatalEr
	cmp	DWORD PTR [esi+172], -1
	je	$LN67@xmlFatalEr
$LN4@xmlFatalEr:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {

	mov	edx, DWORD PTR _error$[ebp]
	lea	eax, DWORD PTR [edx-1]
	cmp	eax, 109				; 0000006dH
	ja	$LN62@xmlFatalEr
	movzx	eax, BYTE PTR $LN69@xmlFatalEr[eax]
	jmp	DWORD PTR $LN71@xmlFatalEr[eax*4]
$LN5@xmlFatalEr:

; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";

	mov	eax, OFFSET ??_C@_0CD@IIBKOMHK@CharRef?3?5invalid?5hexadecimal?5va@

; 362  :             break;

	jmp	$LN2@xmlFatalEr
$LN6@xmlFatalEr:

; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";

	mov	eax, OFFSET ??_C@_0BP@DEJKBBIB@CharRef?3?5invalid?5decimal?5value@

; 365  :             break;

	jmp	$LN2@xmlFatalEr
$LN7@xmlFatalEr:

; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";

	mov	eax, OFFSET ??_C@_0BH@OCLALBPG@CharRef?3?5invalid?5value@

; 368  :             break;

	jmp	$LN2@xmlFatalEr
$LN8@xmlFatalEr:

; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";

	mov	eax, OFFSET ??_C@_0P@LPIEGNHB@internal?5error@

; 371  :             break;

	jmp	$LN2@xmlFatalEr
$LN9@xmlFatalEr:

; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";

	mov	eax, OFFSET ??_C@_0BP@MALDLPDI@PEReference?5at?5end?5of?5document@

; 374  :             break;

	jmp	$LN2@xmlFatalEr
$LN10@xmlFatalEr:

; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";

	mov	eax, OFFSET ??_C@_0BG@GLMIGPKG@PEReference?5in?5prolog@

; 377  :             break;

	jmp	$LN2@xmlFatalEr
$LN11@xmlFatalEr:

; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";

	mov	eax, OFFSET ??_C@_0BG@JMKGIIGE@PEReference?5in?5epilog@

; 380  :             break;

	jmp	$LN2@xmlFatalEr
$LN12@xmlFatalEr:

; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";

	mov	eax, OFFSET ??_C@_0BF@DCHKIALM@PEReference?3?5no?5name@

; 383  :             break;

	jmp	$LN2@xmlFatalEr
$LN13@xmlFatalEr:

; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";

	mov	eax, OFFSET ??_C@_0BL@PFALGNCI@PEReference?3?5expecting?5?8?$DL?8@

; 386  :             break;

	jmp	$LN2@xmlFatalEr
$LN14@xmlFatalEr:

; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";

	mov	eax, OFFSET ??_C@_0CC@LFHGNGFD@Detected?5an?5entity?5reference?5lo@

; 389  :             break;

	jmp	$LN2@xmlFatalEr
$LN15@xmlFatalEr:

; 540  :     }
; 541  :     if (ctxt != NULL)

	mov	eax, OFFSET ??_C@_0BN@DPACNJHE@EntityValue?3?5?$CC?5or?5?8?5expected@
	jmp	$LN2@xmlFatalEr
$LN16@xmlFatalEr:

; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";

	mov	eax, OFFSET ??_C@_0CK@GAJOCPOL@PEReferences?5forbidden?5in?5inter@

; 395  :             break;

	jmp	$LN2@xmlFatalEr
$LN18@xmlFatalEr:

; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";

	mov	eax, OFFSET ??_C@_0BK@ELBMECGA@AttValue?3?5?$CC?5or?5?8?5expected@

; 401  :             break;

	jmp	$LN2@xmlFatalEr
$LN19@xmlFatalEr:

; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";

	mov	eax, OFFSET ??_C@_0CP@FNIFNHDI@Unescaped?5?8?$DM?8?5not?5allowed?5in?5at@

; 404  :             break;

	jmp	$LN2@xmlFatalEr
$LN20@xmlFatalEr:

; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";

	mov	eax, OFFSET ??_C@_0BO@NINNHDOL@SystemLiteral?5?$CC?5or?5?8?5expected@

; 407  :             break;

	jmp	$LN2@xmlFatalEr
$LN21@xmlFatalEr:

; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";

	mov	eax, OFFSET ??_C@_0CP@PIPOCKJD@Unfinished?5System?5or?5Public?5ID?5@

; 410  :             break;

	jmp	$LN2@xmlFatalEr
$LN22@xmlFatalEr:

; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";

	mov	eax, OFFSET ??_C@_0CG@PLPMIKHI@Sequence?5?8?$FN?$FN?$DO?8?5not?5allowed?5in?5c@

; 413  :             break;

	jmp	$LN2@xmlFatalEr
$LN23@xmlFatalEr:

; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";

	mov	eax, OFFSET ??_C@_0CF@GDPMMHJJ@SYSTEM?5or?5PUBLIC?0?5the?5URI?5is?5mi@

; 416  :             break;

	jmp	$LN2@xmlFatalEr
$LN24@xmlFatalEr:

; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";

	mov	eax, OFFSET ??_C@_0CJ@ICNPKBIN@PUBLIC?0?5the?5Public?5Identifier?5i@

; 419  :             break;

	jmp	$LN2@xmlFatalEr
$LN25@xmlFatalEr:

; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";

	mov	eax, OFFSET ??_C@_0CO@IKEFGBAE@Comment?5must?5not?5contain?5?8?9?9?8?5?$CI@

; 422  :             break;

	jmp	$LN2@xmlFatalEr
$LN26@xmlFatalEr:

; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";

	mov	eax, OFFSET ??_C@_0BM@HPBPCNCM@xmlParsePI?5?3?5no?5target?5name@

; 425  :             break;

	jmp	$LN2@xmlFatalEr
$LN27@xmlFatalEr:

; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";

	mov	eax, OFFSET ??_C@_0BA@KMPMBNCM@Invalid?5PI?5name@

; 428  :             break;

	jmp	$LN2@xmlFatalEr
$LN28@xmlFatalEr:

; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";

	mov	eax, OFFSET ??_C@_0BN@HECCFNBP@NOTATION?3?5Name?5expected?5here@

; 431  :             break;

	jmp	$LN2@xmlFatalEr
$LN29@xmlFatalEr:

; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";

	mov	eax, OFFSET ??_C@_0CL@MHMGOJAD@?8?$DO?8?5required?5to?5close?5NOTATION?5@

; 434  :             break;

	jmp	$LN2@xmlFatalEr
$LN30@xmlFatalEr:

; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";

	mov	eax, OFFSET ??_C@_0BG@LMNHCPFE@Entity?5value?5required@

; 437  :             break;

	jmp	$LN2@xmlFatalEr
$LN31@xmlFatalEr:

; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";

	mov	eax, OFFSET ??_C@_0BF@DMGJOFPK@Fragment?5not?5allowed@

; 440  :             break;

	jmp	$LN2@xmlFatalEr
$LN32@xmlFatalEr:

; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";

	mov	eax, OFFSET ??_C@_0CK@NNFMCGNH@?8?$CI?8?5required?5to?5start?5ATTLIST?5e@

; 443  :             break;

	jmp	$LN2@xmlFatalEr
$LN33@xmlFatalEr:

; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";

	mov	eax, OFFSET ??_C@_0CI@EHCBGKID@NmToken?5expected?5in?5ATTLIST?5enu@

; 446  :             break;

	jmp	$LN2@xmlFatalEr
$LN34@xmlFatalEr:

; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";

	mov	eax, OFFSET ??_C@_0CL@KPIIIINI@?8?$CJ?8?5required?5to?5finish?5ATTLIST?5@

; 449  :             break;

	jmp	$LN2@xmlFatalEr
$LN35@xmlFatalEr:

; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";

	mov	eax, OFFSET ??_C@_0CI@LOAMKAA@MixedContentDecl?5?3?5?8?$HM?8?5or?5?8?$CJ?$CK?8?5@

; 452  :             break;

	jmp	$LN2@xmlFatalEr
$LN36@xmlFatalEr:

; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";

	mov	eax, OFFSET ??_C@_0CG@HEHENOGB@MixedContentDecl?5?3?5?8?$CDPCDATA?8?5ex@

; 455  :             break;

	jmp	$LN2@xmlFatalEr
$LN37@xmlFatalEr:

; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";

	mov	eax, OFFSET ??_C@_0CD@NHADBOBB@ContentDecl?5?3?5Name?5or?5?8?$CI?8?5expec@

; 458  :             break;

	jmp	$LN2@xmlFatalEr
$LN38@xmlFatalEr:

; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";

	mov	eax, OFFSET ??_C@_0CG@EHNJPHMB@ContentDecl?5?3?5?8?0?8?5?8?$HM?8?5or?5?8?$CJ?8?5ex@

; 461  :             break;

	jmp	$LN2@xmlFatalEr
$LN39@xmlFatalEr:

; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =

	mov	eax, OFFSET ??_C@_0DN@CEDHFOGD@PEReference?3?5forbidden?5within?5m@

; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;

	jmp	$LN2@xmlFatalEr
$LN40@xmlFatalEr:

; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";

	mov	eax, OFFSET ??_C@_0N@HPGHEIE@expected?5?8?$DO?8@

; 468  :             break;

	jmp	$LN2@xmlFatalEr
$LN41@xmlFatalEr:

; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";

	mov	eax, OFFSET ??_C@_0CF@GGBMHDE@XML?5conditional?5section?5?8?$FL?8?5exp@

; 471  :             break;

	jmp	$LN2@xmlFatalEr
$LN42@xmlFatalEr:

; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";

	mov	eax, OFFSET ??_C@_0CF@HHCGNGIK@Content?5error?5in?5the?5external?5s@

; 474  :             break;

	jmp	$LN2@xmlFatalEr
$LN43@xmlFatalEr:

; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =

	mov	eax, OFFSET ??_C@_0DH@JDEKAAA@conditional?5section?5INCLUDE?5or?5@

; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;

	jmp	$LN2@xmlFatalEr
$LN44@xmlFatalEr:

; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";

	mov	eax, OFFSET ??_C@_0CD@OHPJFFIN@XML?5conditional?5section?5not?5clo@

; 481  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN45@xmlFatalEr:

; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";

	mov	eax, OFFSET ??_C@_0CC@HHECNJCA@Text?5declaration?5?8?$DM?$DPxml?8?5requir@

; 484  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN46@xmlFatalEr:

; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";

	mov	eax, OFFSET ??_C@_0CH@DOCCAFM@parsing?5XML?5declaration?3?5?8?$DP?$DO?8?5e@

; 487  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN47@xmlFatalEr:

; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";

	mov	eax, OFFSET ??_C@_0CO@LJALGGHL@external?5parsed?5entities?5cannot@

; 490  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN48@xmlFatalEr:

; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";

	mov	eax, OFFSET ??_C@_0BJ@KLEMOBLL@EntityRef?3?5expecting?5?8?$DL?8@

; 493  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN49@xmlFatalEr:

; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";

	mov	eax, OFFSET ??_C@_0BO@NIFLODD@DOCTYPE?5improperly?5terminated@

; 496  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN50@xmlFatalEr:

; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";

	mov	eax, OFFSET ??_C@_0BH@ELMJBAIC@EndTag?3?5?8?$DM?1?8?5not?5found@

; 499  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN51@xmlFatalEr:

; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";

	mov	eax, OFFSET ??_C@_0N@FLAMKNN@expected?5?8?$DN?8@

; 502  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN52@xmlFatalEr:

; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";

	mov	eax, OFFSET ??_C@_0CD@GLDIEMIA@String?5not?5closed?5expecting?5?$CC?5o@

; 505  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN53@xmlFatalEr:

; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";

	mov	eax, OFFSET ??_C@_0CE@EGHHEGNE@String?5not?5started?5expecting?5?8?5@

; 508  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN54@xmlFatalEr:

; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";

	mov	eax, OFFSET ??_C@_0BK@CMOJKGNC@Invalid?5XML?5encoding?5name@

; 511  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN55@xmlFatalEr:

; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";

	mov	eax, OFFSET ??_C@_0CG@MBLHCBEE@standalone?5accepts?5only?5?8yes?8?5o@

; 514  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN56@xmlFatalEr:

; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";

	mov	eax, OFFSET ??_C@_0BC@LDMJLCHP@Document?5is?5empty@

; 517  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN57@xmlFatalEr:

; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";

	mov	eax, OFFSET ??_C@_0CJ@JKANOFNI@Extra?5content?5at?5the?5end?5of?5the@

; 520  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN58@xmlFatalEr:

; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";

	mov	eax, OFFSET ??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@

; 523  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN59@xmlFatalEr:

; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";

	mov	eax, OFFSET ??_C@_0DA@BPKCCNLP@extra?5content?5at?5the?5end?5of?5wel@

; 526  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN60@xmlFatalEr:

; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";

	mov	eax, OFFSET ??_C@_0CI@FHFOLBEM@Malformed?5declaration?5expecting@

; 529  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN61@xmlFatalEr:

; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";

	mov	eax, OFFSET ??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@

; 532  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN62@xmlFatalEr:

; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";

	mov	eax, OFFSET ??_C@_0BL@COECCIID@Unregistered?5error?5message@
$LN2@xmlFatalEr:

; 540  :     }
; 541  :     if (ctxt != NULL)

	test	esi, esi
	je	SHORT $LN63@xmlFatalEr

; 542  : 	ctxt->errNo = error;

	mov	DWORD PTR [esi+84], edx
$LN63@xmlFatalEr:

; 543  :     if (info == NULL) {

	mov	ecx, DWORD PTR _info$[ebp]
	test	ecx, ecx
	jne	SHORT $LN64@xmlFatalEr

; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	push	3
	push	edx
	push	1
	push	ecx
	push	esi
	push	ecx
	push	ecx
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {

	jmp	SHORT $LN65@xmlFatalEr
$LN64@xmlFatalEr:

; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	ecx
	push	eax
	push	OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	ecx
	push	0
	push	0
	push	3
	push	edx
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN65@xmlFatalEr:

; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN67@xmlFatalEr

; 553  : 	ctxt->wellFormed = 0;
; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+12], 0
	jne	SHORT $LN67@xmlFatalEr

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN67@xmlFatalEr:
	pop	esi

; 556  :     }
; 557  : }

	pop	ebp
	ret	0
	npad	3
$LN71@xmlFatalEr:
	DD	$LN8@xmlFatalEr
	DD	$LN56@xmlFatalEr
	DD	$LN57@xmlFatalEr
	DD	$LN5@xmlFatalEr
	DD	$LN6@xmlFatalEr
	DD	$LN7@xmlFatalEr
	DD	$LN9@xmlFatalEr
	DD	$LN10@xmlFatalEr
	DD	$LN11@xmlFatalEr
	DD	$LN39@xmlFatalEr
	DD	$LN48@xmlFatalEr
	DD	$LN12@xmlFatalEr
	DD	$LN13@xmlFatalEr
	DD	$LN53@xmlFatalEr
	DD	$LN52@xmlFatalEr
	DD	$LN15@xmlFatalEr
	DD	$LN19@xmlFatalEr
	DD	$LN18@xmlFatalEr
	DD	$LN20@xmlFatalEr
	DD	$LN21@xmlFatalEr
	DD	$LN26@xmlFatalEr
	DD	$LN28@xmlFatalEr
	DD	$LN29@xmlFatalEr
	DD	$LN32@xmlFatalEr
	DD	$LN34@xmlFatalEr
	DD	$LN35@xmlFatalEr
	DD	$LN37@xmlFatalEr
	DD	$LN38@xmlFatalEr
	DD	$LN45@xmlFatalEr
	DD	$LN46@xmlFatalEr
	DD	$LN44@xmlFatalEr
	DD	$LN42@xmlFatalEr
	DD	$LN49@xmlFatalEr
	DD	$LN22@xmlFatalEr
	DD	$LN27@xmlFatalEr
	DD	$LN33@xmlFatalEr
	DD	$LN36@xmlFatalEr
	DD	$LN23@xmlFatalEr
	DD	$LN24@xmlFatalEr
	DD	$LN40@xmlFatalEr
	DD	$LN50@xmlFatalEr
	DD	$LN51@xmlFatalEr
	DD	$LN55@xmlFatalEr
	DD	$LN54@xmlFatalEr
	DD	$LN25@xmlFatalEr
	DD	$LN47@xmlFatalEr
	DD	$LN41@xmlFatalEr
	DD	$LN30@xmlFatalEr
	DD	$LN58@xmlFatalEr
	DD	$LN59@xmlFatalEr
	DD	$LN16@xmlFatalEr
	DD	$LN14@xmlFatalEr
	DD	$LN31@xmlFatalEr
	DD	$LN43@xmlFatalEr
	DD	$LN60@xmlFatalEr
	DD	$LN61@xmlFatalEr
	DD	$LN62@xmlFatalEr
$LN69@xmlFatalEr:
	DB	0
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	6
	DB	7
	DB	8
	DB	9
	DB	56					; 00000038H
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	56					; 00000038H
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	56					; 00000038H
	DB	20					; 00000014H
	DB	56					; 00000038H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	56					; 00000038H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	56					; 00000038H
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	56					; 00000038H
	DB	34					; 00000022H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	35					; 00000023H
	DB	56					; 00000038H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	56					; 00000038H
	DB	39					; 00000027H
	DB	40					; 00000028H
	DB	41					; 00000029H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	42					; 0000002aH
	DB	43					; 0000002bH
	DB	44					; 0000002cH
	DB	56					; 00000038H
	DB	45					; 0000002dH
	DB	46					; 0000002eH
	DB	47					; 0000002fH
	DB	48					; 00000030H
	DB	49					; 00000031H
	DB	56					; 00000038H
	DB	50					; 00000032H
	DB	51					; 00000033H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	52					; 00000034H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	53					; 00000035H
	DB	54					; 00000036H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	56					; 00000038H
	DB	55					; 00000037H
_xmlFatalErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSetEntityReferenceFunc
_TEXT	SEGMENT
_func$ = 8						; size = 4
_xmlSetEntityReferenceFunc PROC				; COMDAT

; 14681: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _func$[ebp]
	mov	DWORD PTR _xmlEntityRefFunc, eax

; 14682:     xmlEntityRefFunc = func;
; 14683: }

	pop	ebp
	ret	0
_xmlSetEntityReferenceFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCheckLanguageID
_TEXT	SEGMENT
_lang$ = 8						; size = 4
_xmlCheckLanguageID PROC				; COMDAT

; 1441 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _lang$[ebp]
	test	esi, esi
	je	$LN57@xmlCheckLa

; 1442 :     const xmlChar *cur = lang, *nxt;
; 1443 : 
; 1444 :     if (cur == NULL)
; 1445 :         return (0);
; 1446 :     if (((cur[0] == 'i') && (cur[1] == '-')) ||
; 1447 :         ((cur[0] == 'I') && (cur[1] == '-')) ||
; 1448 :         ((cur[0] == 'x') && (cur[1] == '-')) ||

	mov	dl, BYTE PTR [esi]
	cmp	dl, 105					; 00000069H
	je	SHORT $LN95@xmlCheckLa
	cmp	dl, 73					; 00000049H
	je	SHORT $LN95@xmlCheckLa
	cmp	dl, 120					; 00000078H
	je	SHORT $LN95@xmlCheckLa
	cmp	dl, 88					; 00000058H
	jne	SHORT $LN15@xmlCheckLa
	cmp	BYTE PTR [esi+1], 45			; 0000002dH
	jne	SHORT $LN15@xmlCheckLa
$LN16@xmlCheckLa:

; 1449 :         ((cur[0] == 'X') && (cur[1] == '-'))) {
; 1450 :         /*
; 1451 :          * Still allow IANA code and user code which were coming
; 1452 :          * from the previous version of the XML-1.0 specification
; 1453 :          * it's deprecated but we should not fail
; 1454 :          */
; 1455 :         cur += 2;

	lea	edx, DWORD PTR [esi+2]
	npad	7
$LL2@xmlCheckLa:

; 1456 :         while (((cur[0] >= 'A') && (cur[0] <= 'Z')) ||

	mov	cl, BYTE PTR [edx]
	cmp	cl, 65					; 00000041H
	jb	SHORT $LN21@xmlCheckLa
	cmp	cl, 90					; 0000005aH
	jbe	SHORT $LN20@xmlCheckLa
$LN21@xmlCheckLa:
	lea	eax, DWORD PTR [ecx-97]
	cmp	al, 25					; 00000019H
	ja	SHORT $LN3@xmlCheckLa
$LN20@xmlCheckLa:

; 1457 :                ((cur[0] >= 'a') && (cur[0] <= 'z')))
; 1458 :             cur++;

	inc	edx
	jmp	SHORT $LL2@xmlCheckLa
$LN3@xmlCheckLa:

; 1459 :         return(cur[0] == 0);

	xor	eax, eax
	test	cl, cl
	pop	esi
	sete	al

; 1571 :     }
; 1572 :     return(0);
; 1573 : }

	pop	ebx
	pop	ebp
	ret	0
$LN95@xmlCheckLa:

; 1460 :     }
; 1461 :     nxt = cur;

	cmp	BYTE PTR [esi+1], 45			; 0000002dH
	je	SHORT $LN16@xmlCheckLa
$LN15@xmlCheckLa:
	mov	ecx, esi
	npad	7
$LL4@xmlCheckLa:

; 1462 :     while (((nxt[0] >= 'A') && (nxt[0] <= 'Z')) ||

	cmp	dl, 65					; 00000041H
	jb	SHORT $LN23@xmlCheckLa
	cmp	dl, 90					; 0000005aH
	jbe	SHORT $LN22@xmlCheckLa
$LN23@xmlCheckLa:
	lea	eax, DWORD PTR [edx-97]
	cmp	al, 25					; 00000019H
	ja	SHORT $LN5@xmlCheckLa
$LN22@xmlCheckLa:

; 1463 :            ((nxt[0] >= 'a') && (nxt[0] <= 'z')))
; 1464 :            nxt++;

	mov	dl, BYTE PTR [ecx+1]
	inc	ecx
	jmp	SHORT $LL4@xmlCheckLa
$LN5@xmlCheckLa:

; 1465 :     if (nxt - cur >= 4) {

	mov	eax, ecx
	sub	eax, esi
	cmp	eax, 4
	jl	SHORT $LN24@xmlCheckLa

; 1466 :         /*
; 1467 :          * Reserved
; 1468 :          */
; 1469 :         if ((nxt - cur > 8) || (nxt[0] != 0))

	cmp	eax, 8
	jg	$LN57@xmlCheckLa
	test	dl, dl
	jmp	$LN96@xmlCheckLa
$LN24@xmlCheckLa:

; 1470 :             return(0);
; 1471 :         return(1);
; 1472 :     }
; 1473 :     if (nxt - cur < 2)

	cmp	eax, 2
	jl	$LN57@xmlCheckLa

; 1474 :         return(0);
; 1475 :     /* we got an ISO 639 code */
; 1476 :     if (nxt[0] == 0)

	test	dl, dl
	je	$LN59@xmlCheckLa

; 1477 :         return(1);
; 1478 :     if (nxt[0] != '-')

	cmp	dl, 45					; 0000002dH
	jne	$LN57@xmlCheckLa

; 1479 :         return(0);
; 1480 : 
; 1481 :     nxt++;
; 1482 :     cur = nxt;
; 1483 :     /* now we can have extlang or script or region or variant */
; 1484 :     if ((nxt[0] >= '0') && (nxt[0] <= '9'))

	mov	dl, BYTE PTR [ecx+1]
	inc	ecx
	mov	esi, ecx
	cmp	dl, 48					; 00000030H
	jb	SHORT $LL6@xmlCheckLa
	cmp	dl, 57					; 00000039H
	jbe	$region_m49$99
	npad	2
$LL6@xmlCheckLa:

; 1485 :         goto region_m49;
; 1486 : 
; 1487 :     while (((nxt[0] >= 'A') && (nxt[0] <= 'Z')) ||

	cmp	dl, 65					; 00000041H
	jb	SHORT $LN32@xmlCheckLa
	cmp	dl, 90					; 0000005aH
	jbe	SHORT $LN31@xmlCheckLa
$LN32@xmlCheckLa:
	lea	eax, DWORD PTR [edx-97]
	cmp	al, 25					; 00000019H
	ja	SHORT $LN7@xmlCheckLa
$LN31@xmlCheckLa:

; 1488 :            ((nxt[0] >= 'a') && (nxt[0] <= 'z')))
; 1489 :            nxt++;

	mov	dl, BYTE PTR [ecx+1]
	inc	ecx
	jmp	SHORT $LL6@xmlCheckLa
$LN7@xmlCheckLa:

; 1490 :     if (nxt - cur == 4)

	mov	eax, ecx
	sub	eax, esi
	cmp	eax, 4
	je	SHORT $script$100

; 1491 :         goto script;
; 1492 :     if (nxt - cur == 2)

	mov	bl, dl
	cmp	eax, 2
	je	$region$101

; 1493 :         goto region;
; 1494 :     if ((nxt - cur >= 5) && (nxt - cur <= 8))

	cmp	eax, 5
	jl	SHORT $LN35@xmlCheckLa
	cmp	eax, 8
	jle	$variant$102
$LN35@xmlCheckLa:

; 1495 :         goto variant;
; 1496 :     if (nxt - cur != 3)

	cmp	eax, 3
	jne	$LN57@xmlCheckLa

; 1497 :         return(0);
; 1498 :     /* we parsed an extlang */
; 1499 :     if (nxt[0] == 0)

	test	dl, dl
	je	$LN59@xmlCheckLa

; 1500 :         return(1);
; 1501 :     if (nxt[0] != '-')

	cmp	dl, 45					; 0000002dH
	jne	$LN57@xmlCheckLa

; 1502 :         return(0);
; 1503 : 
; 1504 :     nxt++;
; 1505 :     cur = nxt;
; 1506 :     /* now we can have script or region or variant */
; 1507 :     if ((nxt[0] >= '0') && (nxt[0] <= '9'))

	mov	dl, BYTE PTR [ecx+1]
	inc	ecx
	mov	esi, ecx
	cmp	dl, 48					; 00000030H
	jb	SHORT $LL8@xmlCheckLa
	cmp	dl, 57					; 00000039H
	jbe	SHORT $region_m49$99
$LL8@xmlCheckLa:

; 1508 :         goto region_m49;
; 1509 : 
; 1510 :     while (((nxt[0] >= 'A') && (nxt[0] <= 'Z')) ||

	cmp	dl, 65					; 00000041H
	jb	SHORT $LN41@xmlCheckLa
	cmp	dl, 90					; 0000005aH
	jbe	SHORT $LN40@xmlCheckLa
$LN41@xmlCheckLa:
	lea	eax, DWORD PTR [edx-97]
	cmp	al, 25					; 00000019H
	ja	SHORT $LN9@xmlCheckLa
$LN40@xmlCheckLa:

; 1511 :            ((nxt[0] >= 'a') && (nxt[0] <= 'z')))
; 1512 :            nxt++;

	mov	dl, BYTE PTR [ecx+1]
	inc	ecx
	jmp	SHORT $LL8@xmlCheckLa
$LN9@xmlCheckLa:

; 1513 :     if (nxt - cur == 2)

	mov	eax, ecx
	mov	bl, dl
	sub	eax, esi
	cmp	eax, 2
	je	SHORT $region$101

; 1514 :         goto region;
; 1515 :     if ((nxt - cur >= 5) && (nxt - cur <= 8))

	cmp	eax, 5
	jl	SHORT $LN43@xmlCheckLa
	cmp	eax, 8
	jle	$variant$102
$LN43@xmlCheckLa:

; 1516 :         goto variant;
; 1517 :     if (nxt - cur != 4)

	cmp	eax, 4
	jne	$LN57@xmlCheckLa
$script$100:

; 1518 :         return(0);
; 1519 :     /* we parsed a script */
; 1520 : script:
; 1521 :     if (nxt[0] == 0)

	test	dl, dl
	je	$LN59@xmlCheckLa

; 1522 :         return(1);
; 1523 :     if (nxt[0] != '-')

	cmp	dl, 45					; 0000002dH
	jne	$LN57@xmlCheckLa

; 1524 :         return(0);
; 1525 : 
; 1526 :     nxt++;
; 1527 :     cur = nxt;
; 1528 :     /* now we can have region or variant */
; 1529 :     if ((nxt[0] >= '0') && (nxt[0] <= '9'))

	mov	bl, BYTE PTR [ecx+1]
	inc	ecx
	mov	edx, ecx
	lea	eax, DWORD PTR [ebx-48]
	cmp	al, 9
	ja	SHORT $LL10@xmlCheckLa
$region_m49$99:

; 1565 : 
; 1566 : region_m49:
; 1567 :     if (((nxt[1] >= '0') && (nxt[1] <= '9')) &&

	mov	al, BYTE PTR [ecx+1]
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	$LN57@xmlCheckLa
	mov	al, BYTE PTR [ecx+2]
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN57@xmlCheckLa

; 1568 :         ((nxt[2] >= '0') && (nxt[2] <= '9'))) {
; 1569 :         nxt += 3;

	mov	bl, BYTE PTR [ecx+3]
	add	ecx, 3

; 1570 :         goto region;

	jmp	SHORT $region$101
$LL10@xmlCheckLa:

; 1530 :         goto region_m49;
; 1531 : 
; 1532 :     while (((nxt[0] >= 'A') && (nxt[0] <= 'Z')) ||

	cmp	bl, 65					; 00000041H
	jb	SHORT $LN49@xmlCheckLa
	cmp	bl, 90					; 0000005aH
	jbe	SHORT $LN48@xmlCheckLa
$LN49@xmlCheckLa:
	lea	eax, DWORD PTR [ebx-97]
	cmp	al, 25					; 00000019H
	ja	SHORT $LN11@xmlCheckLa
$LN48@xmlCheckLa:

; 1533 :            ((nxt[0] >= 'a') && (nxt[0] <= 'z')))
; 1534 :            nxt++;

	mov	bl, BYTE PTR [ecx+1]
	inc	ecx
	jmp	SHORT $LL10@xmlCheckLa
$LN11@xmlCheckLa:

; 1535 : 
; 1536 :     if ((nxt - cur >= 5) && (nxt - cur <= 8))

	mov	eax, ecx
	sub	eax, edx
	cmp	eax, 5
	jl	SHORT $LN50@xmlCheckLa
	cmp	eax, 8
	jle	SHORT $variant$102
$LN50@xmlCheckLa:

; 1537 :         goto variant;
; 1538 :     if (nxt - cur != 2)

	cmp	eax, 2
	jne	SHORT $LN57@xmlCheckLa
$region$101:

; 1539 :         return(0);
; 1540 :     /* we parsed a region */
; 1541 : region:
; 1542 :     if (nxt[0] == 0)

	test	bl, bl
	je	SHORT $LN59@xmlCheckLa

; 1543 :         return(1);
; 1544 :     if (nxt[0] != '-')

	cmp	bl, 45					; 0000002dH
	jne	SHORT $LN57@xmlCheckLa

; 1545 :         return(0);
; 1546 : 
; 1547 :     nxt++;

	inc	ecx

; 1548 :     cur = nxt;

	mov	edx, ecx
	npad	2
$LL12@xmlCheckLa:

; 1549 :     /* now we can just have a variant */
; 1550 :     while (((nxt[0] >= 'A') && (nxt[0] <= 'Z')) ||

	mov	bl, BYTE PTR [ecx]
	cmp	bl, 65					; 00000041H
	jb	SHORT $LN55@xmlCheckLa
	cmp	bl, 90					; 0000005aH
	jbe	SHORT $LN54@xmlCheckLa
$LN55@xmlCheckLa:
	lea	eax, DWORD PTR [ebx-97]
	cmp	al, 25					; 00000019H
	ja	SHORT $LN13@xmlCheckLa
$LN54@xmlCheckLa:

; 1551 :            ((nxt[0] >= 'a') && (nxt[0] <= 'z')))
; 1552 :            nxt++;

	inc	ecx
	jmp	SHORT $LL12@xmlCheckLa
$LN13@xmlCheckLa:

; 1553 : 
; 1554 :     if ((nxt - cur < 5) || (nxt - cur > 8))

	sub	ecx, edx
	cmp	ecx, 5
	jl	SHORT $LN57@xmlCheckLa
	cmp	ecx, 8
	jg	SHORT $LN57@xmlCheckLa
$variant$102:

; 1556 : 
; 1557 :     /* we parsed a variant */
; 1558 : variant:
; 1559 :     if (nxt[0] == 0)

	test	bl, bl
	je	SHORT $LN59@xmlCheckLa

; 1560 :         return(1);
; 1561 :     if (nxt[0] != '-')

	cmp	bl, 45					; 0000002dH
$LN96@xmlCheckLa:

; 1562 :         return(0);
; 1563 :     /* extensions and private use subtags not checked */
; 1564 :     return (1);

	jne	SHORT $LN57@xmlCheckLa
$LN59@xmlCheckLa:
	pop	esi
	mov	eax, 1

; 1571 :     }
; 1572 :     return(0);
; 1573 : }

	pop	ebx
	pop	ebp
	ret	0
$LN57@xmlCheckLa:
	pop	esi

; 1555 :         return(0);

	xor	eax, eax

; 1571 :     }
; 1572 :     return(0);
; 1573 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlCheckLanguageID ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParserHandlePEReference
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlParserHandlePEReference PROC			; COMDAT

; 2499 : xmlParserHandlePEReference(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi+172]
	lea	eax, DWORD PTR [ecx+1]
	cmp	eax, 17					; 00000011H
	ja	$LN2@xmlParserH

; 2500 :     switch(ctxt->instate) {

	movzx	eax, BYTE PTR $LN224@xmlParserH[eax]
	jmp	DWORD PTR $LN227@xmlParserH[eax*4]
$LN8@xmlParserH:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN23@xmlParserH
	cmp	ecx, -1
	je	$LN1@xmlParserH
$LN23@xmlParserH:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BP@MALDLPDI@PEReference?5at?5end?5of?5document@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 18			; 00000012H
	push	18					; 00000012H
$LN225@xmlParserH:

; 2555 : }

	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	mov	DWORD PTR [esi+12], 0
	cmp	DWORD PTR [esi+288], 0
	jne	$LN1@xmlParserH
	mov	DWORD PTR [esi+212], 1
	pop	esi
	pop	ebp
	ret	0
$LN9@xmlParserH:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN91@xmlParserH
	cmp	ecx, -1
	je	$LN1@xmlParserH
$LN91@xmlParserH:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BG@GLMIGPKG@PEReference?5in?5prolog@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 19			; 00000013H
	push	19					; 00000013H

; 2501 : 	case XML_PARSER_CDATA_SECTION:
; 2502 : 	    return;
; 2503 :         case XML_PARSER_COMMENT:
; 2504 : 	    return;
; 2505 : 	case XML_PARSER_START_TAG:
; 2506 : 	    return;
; 2507 : 	case XML_PARSER_END_TAG:
; 2508 : 	    return;
; 2509 :         case XML_PARSER_EOF:
; 2510 : 	    xmlFatalErr(ctxt, XML_ERR_PEREF_AT_EOF, NULL);
; 2511 : 	    return;
; 2512 :         case XML_PARSER_PROLOG:
; 2513 : 	case XML_PARSER_START:
; 2514 : 	case XML_PARSER_MISC:
; 2515 : 	    xmlFatalErr(ctxt, XML_ERR_PEREF_IN_PROLOG, NULL);
; 2516 : 	    return;

	jmp	SHORT $LN225@xmlParserH
$LN11@xmlParserH:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN159@xmlParserH
	cmp	ecx, -1
	je	SHORT $LN1@xmlParserH
$LN159@xmlParserH:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BG@JMKGIIGE@PEReference?5in?5epilog@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 20			; 00000014H
	push	20					; 00000014H

; 2517 : 	case XML_PARSER_ENTITY_DECL:
; 2518 :         case XML_PARSER_CONTENT:
; 2519 :         case XML_PARSER_ATTRIBUTE_VALUE:
; 2520 :         case XML_PARSER_PI:
; 2521 : 	case XML_PARSER_SYSTEM_LITERAL:
; 2522 : 	case XML_PARSER_PUBLIC_LITERAL:
; 2523 : 	    /* we just ignore it there */
; 2524 : 	    return;
; 2525 :         case XML_PARSER_EPILOG:
; 2526 : 	    xmlFatalErr(ctxt, XML_ERR_PEREF_IN_EPILOG, NULL);
; 2527 : 	    return;

	jmp	$LN225@xmlParserH
$LN13@xmlParserH:

; 2528 : 	case XML_PARSER_ENTITY_VALUE:
; 2529 : 	    /*
; 2530 : 	     * NOTE: in the case of entity values, we don't do the
; 2531 : 	     *       substitution here since we need the literal
; 2532 : 	     *       entity value to be able to save the internal
; 2533 : 	     *       subset of the document.
; 2534 : 	     *       This will be handled by xmlStringDecodeEntities
; 2535 : 	     */
; 2536 : 	    return;
; 2537 :         case XML_PARSER_DTD:
; 2538 : 	    /*
; 2539 : 	     * [WFC: Well-Formedness Constraint: PEs in Internal Subset]
; 2540 : 	     * In the internal DTD subset, parameter-entity references
; 2541 : 	     * can occur only where markup declarations can occur, not
; 2542 : 	     * within markup declarations.
; 2543 : 	     * In that case this is handled in xmlParseMarkupDecl
; 2544 : 	     */
; 2545 : 	    if ((ctxt->external == 0) && (ctxt->inputNr == 1))

	cmp	DWORD PTR [esi+96], 0
	jne	SHORT $LN14@xmlParserH
	cmp	DWORD PTR [esi+40], 1
	je	SHORT $LN1@xmlParserH
$LN14@xmlParserH:

; 2546 : 		return;
; 2547 : 	    if (IS_BLANK_CH(NXT(1)) || NXT(1) == 0)

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax+1]
	cmp	al, 32					; 00000020H
	je	SHORT $LN1@xmlParserH
	cmp	al, 9
	jb	SHORT $LN17@xmlParserH
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN1@xmlParserH
$LN17@xmlParserH:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN1@xmlParserH
	test	al, al
	je	SHORT $LN1@xmlParserH
$LN2@xmlParserH:

; 2548 : 		return;
; 2549 :             break;
; 2550 :         case XML_PARSER_IGNORE:
; 2551 :             return;
; 2552 :     }
; 2553 : 
; 2554 :     xmlParsePEReference(ctxt);

	push	esi
	call	_xmlParsePEReference
	add	esp, 4
$LN1@xmlParserH:
	pop	esi

; 2555 : }

	pop	ebp
	ret	0
$LN227@xmlParserH:
	DD	$LN8@xmlParserH
	DD	$LN9@xmlParserH
	DD	$LN1@xmlParserH
	DD	$LN13@xmlParserH
	DD	$LN11@xmlParserH
$LN224@xmlParserH:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	3
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	4
	DB	2
	DB	2
_xmlParserHandlePEReference ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSkipBlankChars
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSkipBlankChars PROC					; COMDAT

; 2140 : xmlSkipBlankChars(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	mov	eax, DWORD PTR [esi+40]
	cmp	eax, 1
	jne	SHORT $LN42@xmlSkipBla

; 2141 :     int res = 0;
; 2142 : 
; 2143 :     /*
; 2144 :      * It's Okay to use CUR/NEXT here since all the blanks are on
; 2145 :      * the ASCII range.
; 2146 :      */
; 2147 :     if ((ctxt->inputNr == 1) && (ctxt->instate != XML_PARSER_DTD)) {

	cmp	DWORD PTR [esi+172], 3
	je	SHORT $LN42@xmlSkipBla
$LN54@xmlSkipBla:

; 2148 : 	const xmlChar *cur;
; 2149 : 	/*
; 2150 : 	 * if we are in the document content, go really fast
; 2151 : 	 */
; 2152 : 	cur = ctxt->input->cur;
; 2153 : 	while (IS_BLANK_CH(*cur)) {

	mov	eax, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [eax+16]
	npad	5
$LL2@xmlSkipBla:
	mov	al, BYTE PTR [edx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN8@xmlSkipBla
	cmp	al, 9
	jb	SHORT $LN9@xmlSkipBla
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN8@xmlSkipBla
$LN9@xmlSkipBla:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN3@xmlSkipBla
$LN8@xmlSkipBla:

; 2154 : 	    if (*cur == '\n') {

	mov	ecx, DWORD PTR [esi+36]
	cmp	al, 10					; 0000000aH
	jne	SHORT $LN10@xmlSkipBla

; 2155 : 		ctxt->input->line++; ctxt->input->col = 1;

	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+32], 1

; 2156 : 	    } else {

	jmp	SHORT $LN11@xmlSkipBla
$LN10@xmlSkipBla:

; 2157 : 		ctxt->input->col++;

	inc	DWORD PTR [ecx+32]
$LN11@xmlSkipBla:

; 2158 : 	    }
; 2159 : 	    cur++;

	inc	edx

; 2160 : 	    res++;

	inc	edi

; 2161 : 	    if (*cur == 0) {

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LL2@xmlSkipBla

; 2162 : 		ctxt->input->cur = cur;

	mov	eax, DWORD PTR [esi+36]

; 2163 : 		xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	mov	DWORD PTR [eax+16], edx
	push	DWORD PTR [esi+36]
	call	_xmlParserInputGrow
	add	esp, 8

; 2164 : 		cur = ctxt->input->cur;

	jmp	SHORT $LN54@xmlSkipBla
$LN3@xmlSkipBla:

; 2165 : 	    }
; 2166 : 	}
; 2167 : 	ctxt->input->cur = cur;

	mov	ecx, DWORD PTR [esi+36]

; 2198 :     }
; 2199 :     return(res);
; 2200 : }

	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+16], edx
	pop	ebp
	ret	0
$LN42@xmlSkipBla:
	push	ebx

; 2168 :     } else {
; 2169 :         int expandPE = ((ctxt->external != 0) || (ctxt->inputNr != 1));

	cmp	DWORD PTR [esi+96], edi
	jne	SHORT $LN38@xmlSkipBla
	cmp	eax, 1
	jne	SHORT $LN38@xmlSkipBla
	xor	ebx, ebx
	jmp	SHORT $LL4@xmlSkipBla
$LN38@xmlSkipBla:
	mov	ebx, 1
	npad	6
$LL4@xmlSkipBla:

; 2170 : 
; 2171 : 	while (1) {
; 2172 :             if (IS_BLANK_CH(CUR)) { /* CHECKED tstblanks.xml */

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN15@xmlSkipBla
	cmp	al, 9
	jb	SHORT $LN16@xmlSkipBla
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN15@xmlSkipBla
$LN16@xmlSkipBla:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN15@xmlSkipBla

; 2174 : 	    } else if (CUR == '%') {

	cmp	al, 37					; 00000025H
	jne	SHORT $LN17@xmlSkipBla

; 2175 :                 /*
; 2176 :                  * Need to handle support of entities branching here
; 2177 :                  */
; 2178 : 	        if ((expandPE == 0) || (IS_BLANK_CH(NXT(1))) || (NXT(1) == 0))

	test	ebx, ebx
	je	SHORT $LN46@xmlSkipBla
	mov	al, BYTE PTR [ecx+1]
	cmp	al, 32					; 00000020H
	je	SHORT $LN46@xmlSkipBla
	cmp	al, 9
	jb	SHORT $LN21@xmlSkipBla
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN46@xmlSkipBla
$LN21@xmlSkipBla:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN46@xmlSkipBla
	test	al, al
	je	SHORT $LN46@xmlSkipBla

; 2179 :                     break;
; 2180 : 	        xmlParsePEReference(ctxt);

	push	esi
	call	_xmlParsePEReference

; 2185 :             } else {
; 2186 :                 break;
; 2187 :             }
; 2188 : 
; 2189 :             /*
; 2190 :              * Also increase the counter when entering or exiting a PERef.
; 2191 :              * The spec says: "When a parameter-entity reference is recognized
; 2192 :              * in the DTD and included, its replacement text MUST be enlarged
; 2193 :              * by the attachment of one leading and one following space (#x20)
; 2194 :              * character."
; 2195 :              */
; 2196 : 	    res++;

	add	esp, 4
	inc	edi

; 2197 :         }

	jmp	SHORT $LL4@xmlSkipBla
$LN17@xmlSkipBla:

; 2181 :             } else if (CUR == 0) {

	test	al, al
	jne	SHORT $LN46@xmlSkipBla

; 2182 :                 if (ctxt->inputNr <= 1)

	cmp	DWORD PTR [esi+40], 1
	jle	SHORT $LN46@xmlSkipBla

; 2183 :                     break;
; 2184 :                 xmlPopInput(ctxt);

	push	esi
	call	_xmlPopInput

; 2185 :             } else {
; 2186 :                 break;
; 2187 :             }
; 2188 : 
; 2189 :             /*
; 2190 :              * Also increase the counter when entering or exiting a PERef.
; 2191 :              * The spec says: "When a parameter-entity reference is recognized
; 2192 :              * in the DTD and included, its replacement text MUST be enlarged
; 2193 :              * by the attachment of one leading and one following space (#x20)
; 2194 :              * character."
; 2195 :              */
; 2196 : 	    res++;

	add	esp, 4
	inc	edi

; 2197 :         }

	jmp	SHORT $LL4@xmlSkipBla
$LN15@xmlSkipBla:

; 2173 : 		NEXT;

	push	esi
	call	_xmlNextChar

; 2185 :             } else {
; 2186 :                 break;
; 2187 :             }
; 2188 : 
; 2189 :             /*
; 2190 :              * Also increase the counter when entering or exiting a PERef.
; 2191 :              * The spec says: "When a parameter-entity reference is recognized
; 2192 :              * in the DTD and included, its replacement text MUST be enlarged
; 2193 :              * by the attachment of one leading and one following space (#x20)
; 2194 :              * character."
; 2195 :              */
; 2196 : 	    res++;

	add	esp, 4
	inc	edi

; 2197 :         }

	jmp	SHORT $LL4@xmlSkipBla
$LN46@xmlSkipBla:
	pop	ebx

; 2198 :     }
; 2199 :     return(res);
; 2200 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlSkipBlankChars ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _namePush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_namePush PROC						; COMDAT

; 1908 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN8@namePush

; 1909 :     if (ctxt == NULL) return (-1);
; 1910 : 
; 1911 :     if (ctxt->nameNr >= ctxt->nameMax) {

	mov	edx, DWORD PTR [esi+188]
	mov	eax, DWORD PTR [esi+192]
	cmp	edx, eax
	jl	SHORT $LN7@namePush

; 1912 :         const xmlChar * *tmp;
; 1913 :         tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt->nameTab,

	shl	eax, 3
	push	eax
	push	DWORD PTR [esi+196]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1914 :                                     ctxt->nameMax * 2 *
; 1915 :                                     sizeof(ctxt->nameTab[0]));
; 1916 :         if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN4@namePush
$mem_error$10:

; 1925 : mem_error:
; 1926 :     xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory
	add	esp, 8
$LN8@namePush:

; 1927 :     return (-1);
; 1928 : }

	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN4@namePush:

; 1917 : 	    goto mem_error;
; 1918 :         }
; 1919 : 	ctxt->nameTab = tmp;
; 1920 :         ctxt->nameMax *= 2;

	mov	edx, DWORD PTR [esi+188]
	mov	DWORD PTR [esi+196], eax
	mov	eax, DWORD PTR [esi+192]
	add	eax, eax
	mov	DWORD PTR [esi+192], eax
$LN7@namePush:

; 1921 :     }
; 1922 :     ctxt->nameTab[ctxt->nameNr] = value;

	mov	eax, DWORD PTR [esi+196]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1923 :     ctxt->name = value;
; 1924 :     return (ctxt->nameNr++);

	mov	eax, DWORD PTR [esi+188]
	mov	DWORD PTR [esi+184], ecx
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+188], ecx
	pop	esi

; 1927 :     return (-1);
; 1928 : }

	pop	ebp
	ret	0
_namePush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _namePop
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_namePop PROC						; COMDAT

; 1939 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	test	edx, edx
	je	SHORT $LN3@namePop

; 1940 :     const xmlChar *ret;
; 1941 : 
; 1942 :     if ((ctxt == NULL) || (ctxt->nameNr <= 0))

	mov	ecx, DWORD PTR [edx+188]
	test	ecx, ecx
	jle	SHORT $LN3@namePop

; 1944 :     ctxt->nameNr--;

	dec	ecx
	mov	DWORD PTR [edx+188], ecx

; 1945 :     if (ctxt->nameNr > 0)

	test	ecx, ecx
	jle	SHORT $LN4@namePop

; 1946 :         ctxt->name = ctxt->nameTab[ctxt->nameNr - 1];

	mov	eax, DWORD PTR [edx+196]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN5@namePop
$LN4@namePop:

; 1947 :     else
; 1948 :         ctxt->name = NULL;

	xor	eax, eax
$LN5@namePop:

; 1949 :     ret = ctxt->nameTab[ctxt->nameNr];

	mov	DWORD PTR [edx+184], eax
	mov	eax, DWORD PTR [edx+196]
	mov	edx, DWORD PTR [eax+ecx*4]

; 1950 :     ctxt->nameTab[ctxt->nameNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 1951 :     return (ret);

	mov	eax, edx

; 1952 : }

	pop	ebp
	ret	0
$LN3@namePop:

; 1943 :         return (NULL);

	xor	eax, eax

; 1952 : }

	pop	ebp
	ret	0
_namePop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _inputPop
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_inputPop PROC						; COMDAT

; 1743 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	test	edx, edx
	je	SHORT $LN7@inputPop

; 1744 :     xmlParserInputPtr ret;
; 1745 : 
; 1746 :     if (ctxt == NULL)
; 1747 :         return(NULL);
; 1748 :     if (ctxt->inputNr <= 0)

	mov	ecx, DWORD PTR [edx+40]
	test	ecx, ecx
	jle	SHORT $LN7@inputPop

; 1750 :     ctxt->inputNr--;

	dec	ecx
	mov	DWORD PTR [edx+40], ecx

; 1751 :     if (ctxt->inputNr > 0)

	test	ecx, ecx
	jle	SHORT $LN4@inputPop

; 1752 :         ctxt->input = ctxt->inputTab[ctxt->inputNr - 1];

	mov	eax, DWORD PTR [edx+48]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN5@inputPop
$LN4@inputPop:

; 1753 :     else
; 1754 :         ctxt->input = NULL;

	xor	eax, eax
$LN5@inputPop:

; 1755 :     ret = ctxt->inputTab[ctxt->inputNr];

	mov	DWORD PTR [edx+36], eax
	mov	eax, DWORD PTR [edx+48]
	mov	edx, DWORD PTR [eax+ecx*4]

; 1756 :     ctxt->inputTab[ctxt->inputNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 1757 :     return (ret);

	mov	eax, edx

; 1758 : }

	pop	ebp
	ret	0
$LN7@inputPop:

; 1749 :         return (NULL);

	xor	eax, eax

; 1758 : }

	pop	ebp
	ret	0
_inputPop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _inputPush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_inputPush PROC						; COMDAT

; 1712 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN3@inputPush

; 1713 :     if ((ctxt == NULL) || (value == NULL))

	mov	edi, DWORD PTR _value$[ebp]
	test	edi, edi
	je	SHORT $LN3@inputPush

; 1714 :         return(-1);
; 1715 :     if (ctxt->inputNr >= ctxt->inputMax) {

	mov	eax, DWORD PTR [esi+44]
	cmp	DWORD PTR [esi+40], eax
	jl	SHORT $LN9@inputPush

; 1716 :         ctxt->inputMax *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+44], eax

; 1717 :         ctxt->inputTab =

	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+48]
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	DWORD PTR [esi+48], eax

; 1718 :             (xmlParserInputPtr *) xmlRealloc(ctxt->inputTab,
; 1719 :                                              ctxt->inputMax *
; 1720 :                                              sizeof(ctxt->inputTab[0]));
; 1721 :         if (ctxt->inputTab == NULL) {

	test	eax, eax
	jne	SHORT $LN9@inputPush

; 1722 :             xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory

; 1723 : 	    xmlFreeInputStream(value);

	push	edi
	call	_xmlFreeInputStream

; 1724 : 	    ctxt->inputMax /= 2;

	mov	eax, DWORD PTR [esi+44]
	add	esp, 12					; 0000000cH
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [esi+44], eax
$LN3@inputPush:

; 1732 : }

	pop	edi
	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN9@inputPush:

; 1725 : 	    value = NULL;
; 1726 :             return (-1);
; 1727 :         }
; 1728 :     }
; 1729 :     ctxt->inputTab[ctxt->inputNr] = value;

	mov	ecx, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [eax+ecx*4], edi

; 1730 :     ctxt->input = value;
; 1731 :     return (ctxt->inputNr++);

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+36], edi
	pop	edi
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+40], ecx

; 1732 : }

	pop	esi
	pop	ebp
	ret	0
_inputPush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _nodePop
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nodePop PROC						; COMDAT

; 1808 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	test	edx, edx
	je	SHORT $LN7@nodePop

; 1809 :     xmlNodePtr ret;
; 1810 : 
; 1811 :     if (ctxt == NULL) return(NULL);
; 1812 :     if (ctxt->nodeNr <= 0)

	mov	ecx, DWORD PTR [edx+56]
	test	ecx, ecx
	jle	SHORT $LN7@nodePop

; 1814 :     ctxt->nodeNr--;

	dec	ecx
	mov	DWORD PTR [edx+56], ecx

; 1815 :     if (ctxt->nodeNr > 0)

	test	ecx, ecx
	jle	SHORT $LN4@nodePop

; 1816 :         ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];

	mov	eax, DWORD PTR [edx+64]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN5@nodePop
$LN4@nodePop:

; 1817 :     else
; 1818 :         ctxt->node = NULL;

	xor	eax, eax
$LN5@nodePop:

; 1819 :     ret = ctxt->nodeTab[ctxt->nodeNr];

	mov	DWORD PTR [edx+52], eax
	mov	eax, DWORD PTR [edx+64]
	mov	edx, DWORD PTR [eax+ecx*4]

; 1820 :     ctxt->nodeTab[ctxt->nodeNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 1821 :     return (ret);

	mov	eax, edx

; 1822 : }

	pop	ebp
	ret	0
$LN7@nodePop:

; 1813 :         return (NULL);

	xor	eax, eax

; 1822 : }

	pop	ebp
	ret	0
_nodePop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _nodePush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_nodePush PROC						; COMDAT

; 1770 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	jne	SHORT $LN2@nodePush

; 1771 :     if (ctxt == NULL) return(0);

	xor	eax, eax
	pop	esi

; 1796 : }

	pop	ebp
	ret	0
$LN2@nodePush:

; 1772 :     if (ctxt->nodeNr >= ctxt->nodeMax) {

	mov	edx, DWORD PTR [esi+56]
	mov	eax, DWORD PTR [esi+60]
	cmp	edx, eax
	jl	SHORT $LN8@nodePush

; 1773 :         xmlNodePtr *tmp;
; 1774 : 
; 1775 : 	tmp = (xmlNodePtr *) xmlRealloc(ctxt->nodeTab,

	shl	eax, 3
	push	eax
	push	DWORD PTR [esi+64]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1776 :                                       ctxt->nodeMax * 2 *
; 1777 :                                       sizeof(ctxt->nodeTab[0]));
; 1778 :         if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN4@nodePush

; 1779 :             xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory
	add	esp, 8

; 1780 :             return (-1);

	or	eax, -1
	pop	esi

; 1796 : }

	pop	ebp
	ret	0
$LN4@nodePush:

; 1781 :         }
; 1782 :         ctxt->nodeTab = tmp;
; 1783 : 	ctxt->nodeMax *= 2;

	mov	edx, DWORD PTR [esi+56]
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR [esi+60]
	add	eax, eax
	mov	DWORD PTR [esi+60], eax
$LN8@nodePush:

; 1784 :     }
; 1785 :     if ((((unsigned int) ctxt->nodeNr) > xmlParserMaxDepth) &&

	mov	eax, DWORD PTR _xmlParserMaxDepth
	cmp	edx, eax
	jbe	SHORT $LN5@nodePush
	test	DWORD PTR [esi+360], 524288		; 00080000H
	jne	SHORT $LN5@nodePush

; 1786 :         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 1787 : 	xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,

	push	eax
	push	OFFSET ??_C@_0DL@HADOBDDE@Excessive?5depth?5in?5document?3?5?$CFd@
	push	1
	push	esi
	call	_xmlFatalErrMsgInt

; 1788 : 		 "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
; 1789 : 			  xmlParserMaxDepth);
; 1790 : 	xmlHaltParser(ctxt);

	push	esi
	call	_xmlHaltParser
	add	esp, 20					; 00000014H

; 1791 : 	return(-1);

	or	eax, -1
	pop	esi

; 1796 : }

	pop	ebp
	ret	0
$LN5@nodePush:

; 1792 :     }
; 1793 :     ctxt->nodeTab[ctxt->nodeNr] = value;

	mov	eax, DWORD PTR [esi+64]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1794 :     ctxt->node = value;
; 1795 :     return (ctxt->nodeNr++);

	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR [esi+52], ecx
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+56], ecx
	pop	esi

; 1796 : }

	pop	ebp
	ret	0
_nodePush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlStringLenDecodeEntities
_TEXT	SEGMENT
tv1225 = -36						; size = 4
_str$1$ = -32						; size = 4
_new_size$1$ = -32					; size = 4
_new_size$1$ = -32					; size = 4
_new_size$1$ = -32					; size = 4
tv1214 = -32						; size = 4
_last$1$ = -28						; size = 4
_l$ = -24						; size = 4
$T1 = -20						; size = 4
_str$1$ = -20						; size = 4
_i$1$ = -20						; size = 4
_new_size$1$ = -20					; size = 4
_new_size$1$ = -20					; size = 4
_new_size$1$ = -20					; size = 4
_current$1$ = -20					; size = 4
_cur$1$ = -16						; size = 4
_ent$2$ = -16						; size = 4
_ent$1$ = -16						; size = 4
_buffer_size$1$ = -12					; size = 4
_buffer$1$ = -8						; size = 4
_rep$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_len$ = 16						; size = 4
_what$ = 20						; size = 4
_end$ = 24						; size = 1
_end2$ = 28						; size = 1
_end3$ = 32						; size = 1
_xmlStringLenDecodeEntities PROC			; COMDAT

; 2593 : 		      int what, xmlChar end, xmlChar  end2, xmlChar end3) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	xor	esi, esi
	mov	DWORD PTR _rep$1$[ebp], eax
	test	ebx, ebx
	je	$LN12@xmlStringL

; 2594 :     xmlChar *buffer = NULL;
; 2595 :     size_t buffer_size = 0;
; 2596 :     size_t nbchars = 0;
; 2597 : 
; 2598 :     xmlChar *current = NULL;
; 2599 :     xmlChar *rep = NULL;
; 2600 :     const xmlChar *last;
; 2601 :     xmlEntityPtr ent;
; 2602 :     int c,l;
; 2603 : 
; 2604 :     if ((ctxt == NULL) || (str == NULL) || (len < 0))

	mov	eax, DWORD PTR _str$[ebp]
	test	eax, eax
	je	$LN12@xmlStringL
	mov	ecx, DWORD PTR _len$[ebp]
	test	ecx, ecx
	js	$LN12@xmlStringL

; 2606 :     last = str + len;

	add	eax, ecx
	mov	DWORD PTR _last$1$[ebp], eax

; 2607 : 
; 2608 :     if (((ctxt->depth > 40) &&
; 2609 :          ((ctxt->options & XML_PARSE_HUGE) == 0)) ||

	mov	eax, DWORD PTR [ebx+248]
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN15@xmlStringL
	test	DWORD PTR [ebx+360], 524288		; 00080000H
	je	SHORT $LN14@xmlStringL
$LN15@xmlStringL:
	cmp	eax, 1024				; 00000400H
	jle	SHORT $LN13@xmlStringL
$LN14@xmlStringL:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [ebx+212], esi
	je	SHORT $LN79@xmlStringL
	cmp	DWORD PTR [ebx+172], -1
	je	$LN12@xmlStringL
$LN79@xmlStringL:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CC@LFHGNGFD@Detected?5an?5entity?5reference?5lo@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	89					; 00000059H
	push	1
	push	0
	push	ebx
	push	0
	push	0
	push	0
	mov	DWORD PTR [ebx+84], 89			; 00000059H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [ebx+12], esi

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [ebx+288], esi
	jne	$LN12@xmlStringL

; 2760 :     return(NULL);
; 2761 : }

	pop	edi
	pop	esi

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [ebx+212], 1

; 2605 : 	return(NULL);

	xor	eax, eax

; 2760 :     return(NULL);
; 2761 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlStringL:

; 2610 : 	(ctxt->depth > 1024)) {
; 2611 : 	xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
; 2612 : 	return(NULL);
; 2613 :     }
; 2614 : 
; 2615 :     /*
; 2616 :      * allocate a translation buffer.
; 2617 :      */
; 2618 :     buffer_size = XML_PARSER_BIG_BUFFER_SIZE;

	mov	ebx, 300				; 0000012cH

; 2619 :     buffer = (xmlChar *) xmlMallocAtomic(buffer_size);

	push	ebx
	mov	DWORD PTR _buffer_size$1$[ebp], ebx
	call	DWORD PTR _xmlMallocAtomic
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _buffer$1$[ebp], edi

; 2620 :     if (buffer == NULL) goto mem_error;

	test	edi, edi
	je	$mem_error$586

; 2621 : 
; 2622 :     /*
; 2623 :      * OK loop until we reach one of the ending char or a size limit.
; 2624 :      * we are operating on already parsed values.
; 2625 :      */
; 2626 :     if (str < last)

	mov	eax, DWORD PTR _str$[ebp]
	cmp	eax, DWORD PTR _last$1$[ebp]
	jae	$LN3@xmlStringL

; 2627 : 	c = CUR_SCHAR(str, l);

	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlStringCurrentChar
	mov	ecx, eax
	add	esp, 12					; 0000000cH

; 2628 :     else
; 2629 :         c = 0;
; 2630 :     while ((c != 0) && (c != end) && /* non input consuming loop */
; 2631 : 	   (c != end2) && (c != end3)) {

	test	ecx, ecx
	je	$LN3@xmlStringL
	movzx	eax, BYTE PTR _end$[ebp]
	mov	DWORD PTR tv1225[ebp], eax
$LN584@xmlStringL:
	mov	edx, DWORD PTR _what$[ebp]
	cmp	ecx, eax
	je	$LN3@xmlStringL
	movzx	eax, BYTE PTR _end2$[ebp]
	cmp	ecx, eax
	je	$LN3@xmlStringL
	movzx	eax, BYTE PTR _end3$[ebp]
	cmp	ecx, eax
	je	$LN3@xmlStringL

; 2632 : 
; 2633 : 	if (c == 0) break;

	test	ecx, ecx
	je	$LN3@xmlStringL

; 2634 :         if ((c == '&') && (str[1] == '#')) {

	cmp	ecx, 38					; 00000026H
	jne	$LN28@xmlStringL
	mov	eax, DWORD PTR _str$[ebp]
	cmp	BYTE PTR [eax+1], 35			; 00000023H
	jne	SHORT $LN579@xmlStringL

; 2635 : 	    int val = xmlParseStringCharRef(ctxt, &str);

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlParseStringCharRef
	add	esp, 8

; 2636 : 	    if (val == 0)

	test	eax, eax
	je	$LN73@xmlStringL

; 2637 :                 goto int_error;
; 2638 : 	    COPY_BUF(0,buffer,nbchars,val);

	push	eax
	lea	eax, DWORD PTR [esi+edi]
	push	eax
	call	_xmlCopyCharMultiByte
	add	esi, eax
	add	esp, 8

; 2639 : 	    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {

	lea	eax, DWORD PTR [esi+100]
	cmp	eax, ebx
	jbe	$LN68@xmlStringL

; 2640 : 	        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);

	lea	eax, DWORD PTR [ebx*2+100]
	mov	DWORD PTR _new_size$1$[ebp], eax
	cmp	eax, ebx
	jb	$LN560@xmlStringL
	push	eax
	push	edi
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	$LN560@xmlStringL
	mov	ebx, DWORD PTR _new_size$1$[ebp]

; 2641 : 	    }

	jmp	$LN582@xmlStringL
$LN579@xmlStringL:

; 2642 : 	} else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) {

	test	dl, 1
	je	$LN52@xmlStringL

; 2643 : 	    if (xmlParserDebugEntities)

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN30@xmlStringL

; 2644 : 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	DWORD PTR _str$[ebp]
	push	OFFSET ??_C@_0CJ@JICBMJMM@String?5decoding?5Entity?5Referenc@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	mov	edi, DWORD PTR _buffer$1$[ebp]
	add	esp, 12					; 0000000cH
$LN30@xmlStringL:

; 2645 : 			"String decoding Entity Reference: %.30s\n",
; 2646 : 			str);
; 2647 : 	    ent = xmlParseStringEntityRef(ctxt, &str);

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlParseStringEntityRef

; 2648 : 	    xmlParserEntityCheck(ctxt, 0, ent, 0);

	push	0
	push	eax
	push	0
	push	DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _ent$1$[ebp], eax
	call	_xmlParserEntityCheck

; 2649 : 	    if (ent != NULL)

	mov	eax, DWORD PTR _ent$1$[ebp]
	add	esp, 24					; 00000018H
	test	eax, eax
	je	$LN68@xmlStringL

; 2650 : 	        ctxt->nbentities += ent->checked / 2;

	mov	eax, DWORD PTR [eax+72]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cdq
	sub	eax, edx

; 2651 : 	    if ((ent != NULL) &&

	mov	edx, DWORD PTR _ent$1$[ebp]
	sar	eax, 1
	add	DWORD PTR [ecx+440], eax
	cmp	DWORD PTR [edx+48], 6
	mov	eax, DWORD PTR [edx+40]
	jne	SHORT $LN32@xmlStringL

; 2652 : 		(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
; 2653 : 		if (ent->content != NULL) {

	test	eax, eax
	je	$LN34@xmlStringL

; 2654 : 		    COPY_BUF(0,buffer,nbchars,ent->content[0]);

	movzx	eax, BYTE PTR [eax]
	push	eax
	lea	eax, DWORD PTR [esi+edi]
	push	eax
	call	_xmlCopyCharMultiByte
	add	esi, eax
	add	esp, 8

; 2655 : 		    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {

	lea	eax, DWORD PTR [esi+100]
	cmp	eax, ebx
	jbe	$LN68@xmlStringL

; 2656 : 			growBuffer(buffer, XML_PARSER_BUFFER_SIZE);

	lea	eax, DWORD PTR [ebx*2+100]
	mov	DWORD PTR _new_size$1$[ebp], eax
	cmp	eax, ebx
	jb	$LN560@xmlStringL
	push	eax
	push	edi
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	$LN560@xmlStringL
	mov	ebx, DWORD PTR _new_size$1$[ebp]

; 2662 : 		}

	jmp	$LN582@xmlStringL
$LN32@xmlStringL:

; 2663 : 	    } else if ((ent != NULL) && (ent->content != NULL)) {

	test	eax, eax
	je	$LN41@xmlStringL

; 2664 : 		ctxt->depth++;

	mov	eax, DWORD PTR [ecx+248]
	inc	eax
	mov	DWORD PTR [ecx+248], eax

; 2665 : 		rep = xmlStringDecodeEntities(ctxt, ent->content, what,

	mov	edx, DWORD PTR [edx+40]
	mov	DWORD PTR _str$1$[ebp], edx

; 2784 :     if ((ctxt == NULL) || (str == NULL)) return(NULL);

	test	edx, edx
	je	SHORT $LN245@xmlStringL

; 2785 :     return(xmlStringLenDecodeEntities(ctxt, str, xmlStrlen(str), what,

	mov	ecx, DWORD PTR _what$[ebp]
	push	0
	push	0
	push	0
	push	ecx
	push	edx
	call	_xmlStrlen
	add	esp, 4
	push	eax
	push	DWORD PTR _str$1$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlStringLenDecodeEntities
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, eax
	mov	DWORD PTR _rep$1$[ebp], eax
	add	esp, 28					; 0000001cH
	mov	eax, DWORD PTR [ecx+248]
	jmp	SHORT $LN243@xmlStringL
$LN245@xmlStringL:

; 2762 : 
; 2763 : /**
; 2764 :  * xmlStringDecodeEntities:
; 2765 :  * @ctxt:  the parser context
; 2766 :  * @str:  the input string
; 2767 :  * @what:  combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF
; 2768 :  * @end:  an end marker xmlChar, 0 if none
; 2769 :  * @end2:  an end marker xmlChar, 0 if none
; 2770 :  * @end3:  an end marker xmlChar, 0 if none
; 2771 :  *
; 2772 :  * Takes a entity string content and process to do the adequate substitutions.
; 2773 :  *
; 2774 :  * [67] Reference ::= EntityRef | CharRef
; 2775 :  *
; 2776 :  * [69] PEReference ::= '%' Name ';'
; 2777 :  *
; 2778 :  * Returns A newly allocated string with the substitution done. The caller
; 2779 :  *      must deallocate it !
; 2780 :  */
; 2781 : xmlChar *
; 2782 : xmlStringDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int what,
; 2783 : 		        xmlChar end, xmlChar  end2, xmlChar end3) {
; 2784 :     if ((ctxt == NULL) || (str == NULL)) return(NULL);

	xor	edx, edx
	mov	DWORD PTR _rep$1$[ebp], edx
$LN243@xmlStringL:

; 2666 : 			                      0, 0, 0);
; 2667 : 		ctxt->depth--;

	dec	eax
	mov	DWORD PTR [ecx+248], eax

; 2668 : 		if (rep == NULL)

	test	edx, edx
	je	$LN73@xmlStringL

; 2669 :                     goto int_error;
; 2670 : 
; 2671 :                 current = rep;
; 2672 :                 while (*current != 0) { /* non input consuming loop */

	mov	al, BYTE PTR [edx]
	test	al, al
	je	SHORT $LN5@xmlStringL
	sub	edx, esi
	mov	DWORD PTR tv1214[ebp], edx
	npad	2
$LL4@xmlStringL:

; 2673 :                     buffer[nbchars++] = *current++;

	mov	BYTE PTR [esi+edi], al
	inc	esi

; 2674 :                     if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {

	lea	eax, DWORD PTR [esi+100]
	cmp	eax, ebx
	jbe	SHORT $LN44@xmlStringL

; 2675 :                         if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))

	push	0
	push	DWORD PTR _ent$1$[ebp]
	push	esi
	push	ecx
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$int_error$587

; 2676 :                             goto int_error;
; 2677 :                         growBuffer(buffer, XML_PARSER_BUFFER_SIZE);

	lea	eax, DWORD PTR [ebx*2+100]
	mov	DWORD PTR _new_size$1$[ebp], eax
	cmp	eax, ebx
	jb	$mem_error$586
	push	eax
	push	edi
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	$mem_error$586
	mov	ebx, DWORD PTR _new_size$1$[ebp]
	mov	edi, eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR tv1214[ebp]
	mov	DWORD PTR _buffer$1$[ebp], edi
	mov	DWORD PTR _buffer_size$1$[ebp], ebx
$LN44@xmlStringL:

; 2669 :                     goto int_error;
; 2670 : 
; 2671 :                 current = rep;
; 2672 :                 while (*current != 0) { /* non input consuming loop */

	mov	al, BYTE PTR [edx+esi]
	test	al, al
	jne	SHORT $LL4@xmlStringL
	mov	edx, DWORD PTR _rep$1$[ebp]
$LN5@xmlStringL:

; 2678 :                     }
; 2679 :                 }
; 2680 :                 xmlFree(rep);

	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2681 :                 rep = NULL;

	jmp	$LN68@xmlStringL
$LN41@xmlStringL:

; 2682 : 	    } else if (ent != NULL) {
; 2683 : 		int i = xmlStrlen(ent->name);

	push	DWORD PTR [edx+8]
	call	_xmlStrlen
	mov	edx, eax
	add	esp, 4

; 2684 : 		const xmlChar *cur = ent->name;

	mov	eax, DWORD PTR _ent$1$[ebp]
	mov	DWORD PTR _i$1$[ebp], edx

; 2685 : 
; 2686 : 		buffer[nbchars++] = '&';
; 2687 : 		if (nbchars + i + XML_PARSER_BUFFER_SIZE > buffer_size) {

	lea	ecx, DWORD PTR [edx+100]
	mov	eax, DWORD PTR [eax+8]
	mov	BYTE PTR [esi+edi], 38			; 00000026H
	inc	esi
	add	ecx, esi
	mov	DWORD PTR _cur$1$[ebp], eax
	cmp	ecx, ebx
	jbe	SHORT $LN49@xmlStringL

; 2688 : 		    growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);

	lea	eax, DWORD PTR [edx+100]
	lea	eax, DWORD PTR [eax+ebx*2]
	mov	DWORD PTR _new_size$1$[ebp], eax
	cmp	eax, ebx
	jb	$LN565@xmlStringL
	push	eax
	push	edi
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	$LN560@xmlStringL
	mov	ebx, DWORD PTR _new_size$1$[ebp]
	mov	edi, eax
	mov	edx, DWORD PTR _i$1$[ebp]
	mov	DWORD PTR _buffer$1$[ebp], edi
	mov	DWORD PTR _buffer_size$1$[ebp], ebx
$LN49@xmlStringL:

; 2689 : 		}
; 2690 : 		for (;i > 0;i--)

	test	edx, edx
	jle	SHORT $LN7@xmlStringL
	mov	ebx, DWORD PTR _cur$1$[ebp]
$LL8@xmlStringL:

; 2691 : 		    buffer[nbchars++] = *cur++;

	mov	al, BYTE PTR [ebx]
	lea	ebx, DWORD PTR [ebx+1]
	mov	BYTE PTR [esi+edi], al
	dec	edx
	inc	esi
	test	edx, edx
	jg	SHORT $LL8@xmlStringL
	mov	ebx, DWORD PTR _buffer_size$1$[ebp]
$LN7@xmlStringL:

; 2692 : 		buffer[nbchars++] = ';';

	mov	BYTE PTR [esi+edi], 59			; 0000003bH
	inc	esi

; 2693 : 	    }

	jmp	$LN68@xmlStringL
$LN28@xmlStringL:

; 2694 : 	} else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) {

	cmp	ecx, 37					; 00000025H
	jne	$LN52@xmlStringL
	test	dl, 2
	je	$LN52@xmlStringL

; 2695 : 	    if (xmlParserDebugEntities)

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN54@xmlStringL

; 2696 : 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	DWORD PTR _str$[ebp]
	push	OFFSET ??_C@_0CF@DIAKJGNK@String?5decoding?5PE?5Reference?3?5?$CF@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	mov	edi, DWORD PTR _buffer$1$[ebp]
	add	esp, 12					; 0000000cH
$LN54@xmlStringL:

; 2697 : 			"String decoding PE Reference: %.30s\n", str);
; 2698 : 	    ent = xmlParseStringPEReference(ctxt, &str);

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlParseStringPEReference

; 2699 : 	    xmlParserEntityCheck(ctxt, 0, ent, 0);

	push	0
	push	eax
	push	0
	push	DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _ent$2$[ebp], eax
	call	_xmlParserEntityCheck

; 2700 : 	    if (ent != NULL)

	mov	eax, DWORD PTR _ent$2$[ebp]
	add	esp, 24					; 00000018H
	test	eax, eax
	je	$LN68@xmlStringL

; 2701 : 	        ctxt->nbentities += ent->checked / 2;

	mov	eax, DWORD PTR [eax+72]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	DWORD PTR [ecx+440], eax

; 2702 : 	    if (ent != NULL) {
; 2703 :                 if (ent->content == NULL) {

	mov	eax, DWORD PTR _ent$2$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN59@xmlStringL

; 2704 : 		    /*
; 2705 : 		     * Note: external parsed entities will not be loaded,
; 2706 : 		     * it is not required for a non-validating parser to
; 2707 : 		     * complete external PEreferences coming from the
; 2708 : 		     * internal subset
; 2709 : 		     */
; 2710 : 		    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||
; 2711 : 			((ctxt->options & XML_PARSE_DTDVALID) != 0) ||

	test	BYTE PTR [ecx+360], 18			; 00000012H
	jne	SHORT $LN60@xmlStringL
	cmp	DWORD PTR [ecx+104], 0
	jne	SHORT $LN60@xmlStringL

; 2714 : 		    } else {
; 2715 : 			xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,

	push	0
	push	DWORD PTR [eax+8]
	push	OFFSET ??_C@_0DH@IENLJLFO@not?5validating?5will?5not?5read?5co@
	push	104					; 00000068H
	push	ecx
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H
	jmp	SHORT $LN583@xmlStringL
$LN60@xmlStringL:

; 2712 : 			(ctxt->validate != 0)) {
; 2713 : 			xmlLoadEntityContent(ctxt, ent);

	push	eax
	push	ecx
	call	_xmlLoadEntityContent
	add	esp, 8
$LN583@xmlStringL:

; 2716 : 		  "not validating will not read content for PE entity %s\n",
; 2717 : 		                      ent->name, NULL);
; 2718 : 		    }
; 2719 : 		}
; 2720 : 		ctxt->depth++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
$LN59@xmlStringL:
	mov	eax, DWORD PTR [ecx+248]
	inc	eax
	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR [ecx+248], eax

; 2721 : 		rep = xmlStringDecodeEntities(ctxt, ent->content, what,

	mov	eax, DWORD PTR _ent$2$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	DWORD PTR _str$1$[ebp], eax

; 2784 :     if ((ctxt == NULL) || (str == NULL)) return(NULL);

	test	eax, eax
	je	SHORT $LN447@xmlStringL

; 2785 :     return(xmlStringLenDecodeEntities(ctxt, str, xmlStrlen(str), what,

	mov	ecx, DWORD PTR _what$[ebp]
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	call	_xmlStrlen
	add	esp, 4
	push	eax
	push	DWORD PTR _str$1$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlStringLenDecodeEntities
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, eax
	mov	DWORD PTR _rep$1$[ebp], eax
	add	esp, 28					; 0000001cH
	mov	eax, DWORD PTR [ecx+248]
	jmp	SHORT $LN445@xmlStringL
$LN447@xmlStringL:
	mov	eax, DWORD PTR $T1[ebp]

; 2762 : 
; 2763 : /**
; 2764 :  * xmlStringDecodeEntities:
; 2765 :  * @ctxt:  the parser context
; 2766 :  * @str:  the input string
; 2767 :  * @what:  combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF
; 2768 :  * @end:  an end marker xmlChar, 0 if none
; 2769 :  * @end2:  an end marker xmlChar, 0 if none
; 2770 :  * @end3:  an end marker xmlChar, 0 if none
; 2771 :  *
; 2772 :  * Takes a entity string content and process to do the adequate substitutions.
; 2773 :  *
; 2774 :  * [67] Reference ::= EntityRef | CharRef
; 2775 :  *
; 2776 :  * [69] PEReference ::= '%' Name ';'
; 2777 :  *
; 2778 :  * Returns A newly allocated string with the substitution done. The caller
; 2779 :  *      must deallocate it !
; 2780 :  */
; 2781 : xmlChar *
; 2782 : xmlStringDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int what,
; 2783 : 		        xmlChar end, xmlChar  end2, xmlChar end3) {
; 2784 :     if ((ctxt == NULL) || (str == NULL)) return(NULL);

	xor	edx, edx
	mov	DWORD PTR _rep$1$[ebp], edx
$LN445@xmlStringL:

; 2722 : 			                      0, 0, 0);
; 2723 : 		ctxt->depth--;

	dec	eax
	mov	DWORD PTR [ecx+248], eax

; 2724 : 		if (rep == NULL)

	test	edx, edx
	je	$LN73@xmlStringL

; 2725 :                     goto int_error;
; 2726 :                 current = rep;

	mov	eax, edx
	mov	DWORD PTR _current$1$[ebp], eax

; 2727 :                 while (*current != 0) { /* non input consuming loop */

	mov	al, BYTE PTR [edx]
	test	al, al
	je	SHORT $LN10@xmlStringL
$LL9@xmlStringL:

; 2728 :                     buffer[nbchars++] = *current++;

	inc	DWORD PTR _current$1$[ebp]
	mov	BYTE PTR [esi+edi], al
	inc	esi

; 2729 :                     if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {

	lea	eax, DWORD PTR [esi+100]
	cmp	eax, ebx
	jbe	SHORT $LN62@xmlStringL

; 2730 :                         if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))

	push	0
	push	DWORD PTR _ent$2$[ebp]
	push	esi
	push	ecx
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$int_error$587

; 2731 :                             goto int_error;
; 2732 :                         growBuffer(buffer, XML_PARSER_BUFFER_SIZE);

	lea	eax, DWORD PTR [ebx*2+100]
	mov	DWORD PTR _new_size$1$[ebp], eax
	cmp	eax, ebx
	jb	$mem_error$586
	push	eax
	push	edi
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	$mem_error$586
	mov	ebx, DWORD PTR _new_size$1$[ebp]
	mov	edi, eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _buffer$1$[ebp], edi
	mov	DWORD PTR _buffer_size$1$[ebp], ebx
$LN62@xmlStringL:

; 2727 :                 while (*current != 0) { /* non input consuming loop */

	mov	eax, DWORD PTR _current$1$[ebp]
	mov	al, BYTE PTR [eax]
	test	al, al
	jne	SHORT $LL9@xmlStringL
	mov	edx, DWORD PTR _rep$1$[ebp]
$LN10@xmlStringL:

; 2733 :                     }
; 2734 :                 }
; 2735 :                 xmlFree(rep);

	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2736 :                 rep = NULL;
; 2737 : 	    }
; 2738 : 	} else {

	jmp	SHORT $LN68@xmlStringL
$LN52@xmlStringL:

; 2739 : 	    COPY_BUF(l,buffer,nbchars,c);

	cmp	DWORD PTR _l$[ebp], 1
	lea	eax, DWORD PTR [esi+edi]
	jne	SHORT $LN66@xmlStringL
	mov	BYTE PTR [eax], cl
	inc	esi
	jmp	SHORT $LN67@xmlStringL
$LN66@xmlStringL:
	push	ecx
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	esi, eax
$LN67@xmlStringL:

; 2740 : 	    str += l;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _l$[ebp]
	mov	DWORD PTR _str$[ebp], eax

; 2741 : 	    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {

	lea	eax, DWORD PTR [esi+100]
	cmp	eax, ebx
	jbe	SHORT $LN68@xmlStringL

; 2742 : 	        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);

	lea	eax, DWORD PTR [ebx*2+100]
	mov	DWORD PTR _rep$1$[ebp], 0
	mov	DWORD PTR _new_size$1$[ebp], eax
	cmp	eax, ebx
	jb	SHORT $mem_error$586
	push	eax
	push	edi
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	DWORD PTR _rep$1$[ebp], 0
	test	eax, eax
	je	SHORT $mem_error$586
	mov	ebx, DWORD PTR _new_size$1$[ebp]
$LN582@xmlStringL:

; 2743 : 	    }
; 2744 : 	}
; 2745 : 	if (str < last)

	mov	edi, eax
	mov	DWORD PTR _buffer_size$1$[ebp], ebx
	mov	DWORD PTR _buffer$1$[ebp], edi
$LN68@xmlStringL:
	mov	eax, DWORD PTR _str$[ebp]
	cmp	eax, DWORD PTR _last$1$[ebp]
	jae	SHORT $LN3@xmlStringL

; 2746 : 	    c = CUR_SCHAR(str, l);

	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlStringCurrentChar
	mov	ecx, eax
	add	esp, 12					; 0000000cH
	test	ecx, ecx
	je	SHORT $LN3@xmlStringL

; 2628 :     else
; 2629 :         c = 0;
; 2630 :     while ((c != 0) && (c != end) && /* non input consuming loop */
; 2631 : 	   (c != end2) && (c != end3)) {

	mov	eax, DWORD PTR tv1225[ebp]
	jmp	$LN584@xmlStringL
$LN560@xmlStringL:

; 2752 : 
; 2753 : mem_error:
; 2754 :     xmlErrMemory(ctxt, NULL);

	mov	DWORD PTR _rep$1$[ebp], 0
$mem_error$586:
	push	0
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrMemory
	add	esp, 8
$int_error$587:

; 2755 : int_error:
; 2756 :     if (rep != NULL)

	mov	eax, DWORD PTR _rep$1$[ebp]
	test	eax, eax
	je	SHORT $LN73@xmlStringL

; 2757 :         xmlFree(rep);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN73@xmlStringL:

; 2758 :     if (buffer != NULL)

	test	edi, edi
	je	SHORT $LN12@xmlStringL

; 2759 :         xmlFree(buffer);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlStringL:

; 2760 :     return(NULL);
; 2761 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xmlStringL:

; 2657 : 		    }
; 2658 : 		} else {
; 2659 : 		    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CC@KGDPFIJL@predefined?5entity?5has?5no?5conten@
	push	1
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 2660 : 			    "predefined entity has no content\n");
; 2661 :                     goto int_error;

	jmp	SHORT $LN73@xmlStringL
$LN565@xmlStringL:

; 2688 : 		    growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);

	xor	eax, eax
	mov	DWORD PTR _rep$1$[ebp], eax
	jmp	SHORT $mem_error$586
$LN3@xmlStringL:

; 2747 : 	else
; 2748 : 	    c = 0;
; 2749 :     }
; 2750 :     buffer[nbchars] = 0;

	mov	BYTE PTR [esi+edi], 0

; 2751 :     return(buffer);

	mov	eax, edi
	pop	edi

; 2760 :     return(NULL);
; 2761 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStringLenDecodeEntities ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlStringDecodeEntities
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_what$ = 16						; size = 4
_end$ = 20						; size = 1
_end2$ = 24						; size = 1
_end3$ = 28						; size = 1
_xmlStringDecodeEntities PROC				; COMDAT

; 2783 : 		        xmlChar end, xmlChar  end2, xmlChar end3) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlStringD

; 2784 :     if ((ctxt == NULL) || (str == NULL)) return(NULL);

	mov	esi, DWORD PTR _str$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlStringD

; 2785 :     return(xmlStringLenDecodeEntities(ctxt, str, xmlStrlen(str), what,

	push	DWORD PTR _end3$[ebp]
	push	DWORD PTR _end2$[ebp]
	push	DWORD PTR _end$[ebp]
	push	DWORD PTR _what$[ebp]
	push	esi
	call	_xmlStrlen
	add	esp, 4
	push	eax
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlStringLenDecodeEntities
	add	esp, 28					; 0000001cH
	pop	esi

; 2786 :            end, end2, end3));
; 2787 : }

	pop	ebp
	ret	0
$LN3@xmlStringD:

; 2784 :     if ((ctxt == NULL) || (str == NULL)) return(NULL);

	xor	eax, eax
	pop	esi

; 2786 :            end, end2, end3));
; 2787 : }

	pop	ebp
	ret	0
_xmlStringDecodeEntities ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseExternalSubset
_TEXT	SEGMENT
_start$1 = 8						; size = 4
_ctxt$ = 8						; size = 4
_ExternalID$ = 12					; size = 4
_SystemID$ = 16						; size = 4
_xmlParseExternalSubset PROC				; COMDAT

; 6919 :                        const xmlChar *SystemID) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlDetectSAX2
	add	esp, 4
	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN4@xmlParseEx

; 6920 :     xmlDetectSAX2(ctxt);
; 6921 :     GROW;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN4@xmlParseEx
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN4@xmlParseEx:

; 6922 : 
; 6923 :     if ((ctxt->encoding == NULL) &&

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN6@xmlParseEx
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	cmp	eax, 4
	jl	SHORT $LN6@xmlParseEx

; 6924 :         (ctxt->input->end - ctxt->input->cur >= 4)) {
; 6925 :         xmlChar start[4];
; 6926 : 	xmlCharEncoding enc;
; 6927 : 
; 6928 : 	start[0] = RAW;

	movzx	eax, BYTE PTR [ecx]
	mov	BYTE PTR _start$1[ebp], al

; 6929 : 	start[1] = NXT(1);

	movzx	eax, BYTE PTR [ecx+1]
	mov	BYTE PTR _start$1[ebp+1], al

; 6930 : 	start[2] = NXT(2);

	movzx	eax, BYTE PTR [ecx+2]
	mov	BYTE PTR _start$1[ebp+2], al

; 6931 : 	start[3] = NXT(3);

	movzx	eax, BYTE PTR [ecx+3]
	mov	BYTE PTR _start$1[ebp+3], al

; 6932 : 	enc = xmlDetectCharEncoding(start, 4);

	lea	eax, DWORD PTR _start$1[ebp]
	push	4
	push	eax
	call	_xmlDetectCharEncoding
	add	esp, 8

; 6933 : 	if (enc != XML_CHAR_ENCODING_NONE)

	test	eax, eax
	je	SHORT $LN6@xmlParseEx

; 6934 : 	    xmlSwitchEncoding(ctxt, enc);

	push	eax
	push	esi
	call	_xmlSwitchEncoding
	add	esp, 8
$LN6@xmlParseEx:

; 6935 :     }
; 6936 : 
; 6937 :     if (CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 60			; 0000003cH
	jne	SHORT $LN8@xmlParseEx
	cmp	BYTE PTR [eax+1], 63			; 0000003fH
	jne	SHORT $LN8@xmlParseEx
	cmp	BYTE PTR [eax+2], 120			; 00000078H
	jne	SHORT $LN8@xmlParseEx
	cmp	BYTE PTR [eax+3], 109			; 0000006dH
	jne	SHORT $LN8@xmlParseEx
	cmp	BYTE PTR [eax+4], 108			; 0000006cH
	jne	SHORT $LN8@xmlParseEx

; 6938 : 	xmlParseTextDecl(ctxt);

	push	esi
	call	_xmlParseTextDecl
	add	esp, 4

; 6939 : 	if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {

	cmp	DWORD PTR [esi+84], 32			; 00000020H
	jne	SHORT $LN8@xmlParseEx

; 6940 : 	    /*
; 6941 : 	     * The XML REC instructs us to stop parsing right here
; 6942 : 	     */
; 6943 : 	    xmlHaltParser(ctxt);

	push	esi
	call	_xmlHaltParser
	add	esp, 4
	pop	esi

; 6981 : 	xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
; 6982 :     }
; 6983 : 
; 6984 : }

	pop	ebp
	ret	0
$LN8@xmlParseEx:

; 6944 : 	    return;
; 6945 : 	}
; 6946 :     }
; 6947 :     if (ctxt->myDoc == NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jne	SHORT $LN164@xmlParseEx

; 6948 :         ctxt->myDoc = xmlNewDoc(BAD_CAST "1.0");

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 6949 : 	if (ctxt->myDoc == NULL) {

	test	eax, eax
	jne	SHORT $LN10@xmlParseEx

; 6950 : 	    xmlErrMemory(ctxt, "New Doc failed");

	push	OFFSET ??_C@_0P@IDBIGKBI@New?5Doc?5failed@
	push	esi
	call	_xmlErrMemory
	add	esp, 8
	pop	esi

; 6981 : 	xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
; 6982 :     }
; 6983 : 
; 6984 : }

	pop	ebp
	ret	0
$LN10@xmlParseEx:

; 6951 : 	    return;
; 6952 : 	}
; 6953 : 	ctxt->myDoc->properties = XML_DOC_INTERNAL;

	mov	DWORD PTR [eax+92], 64			; 00000040H
	mov	eax, DWORD PTR [esi+8]

; 6954 :     }
; 6955 :     if ((ctxt->myDoc != NULL) && (ctxt->myDoc->intSubset == NULL))

	test	eax, eax
	je	SHORT $LN11@xmlParseEx
$LN164@xmlParseEx:
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN11@xmlParseEx

; 6956 :         xmlCreateIntSubset(ctxt->myDoc, NULL, ExternalID, SystemID);

	push	DWORD PTR _SystemID$[ebp]
	push	DWORD PTR _ExternalID$[ebp]
	push	0
	push	eax
	call	_xmlCreateIntSubset
	add	esp, 16					; 00000010H
$LN11@xmlParseEx:

; 6957 : 
; 6958 :     ctxt->instate = XML_PARSER_DTD;
; 6959 :     ctxt->external = 1;
; 6960 :     SKIP_BLANKS;

	push	esi
	mov	DWORD PTR [esi+172], 3
	mov	DWORD PTR [esi+96], 1
	call	_xmlSkipBlankChars
	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	push	ebx
	push	edi
$LL2@xmlParseEx:

; 6961 :     while (((RAW == '<') && (NXT(1) == '?')) ||
; 6962 :            ((RAW == '<') && (NXT(1) == '!')) ||

	mov	edi, DWORD PTR [eax+16]
	mov	cl, BYTE PTR [edi]
	cmp	cl, 60					; 0000003cH
	jne	SHORT $LN14@xmlParseEx
	mov	dl, BYTE PTR [edi+1]
	cmp	dl, 63					; 0000003fH
	je	SHORT $LN12@xmlParseEx
	cmp	dl, 33					; 00000021H
	je	SHORT $LN12@xmlParseEx
$LN14@xmlParseEx:
	cmp	cl, 37					; 00000025H
	jne	$LN87@xmlParseEx
$LN12@xmlParseEx:

; 6963 : 	   (RAW == '%')) {
; 6964 : 	const xmlChar *check = CUR_PTR;
; 6965 : 	unsigned int cons = ctxt->input->consumed;
; 6966 : 
; 6967 : 	GROW;

	cmp	DWORD PTR [esi+292], 0
	mov	ecx, eax
	mov	ebx, DWORD PTR [eax+36]
	jne	SHORT $LN15@xmlParseEx
	mov	eax, DWORD PTR [eax+20]
	sub	eax, edi
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN15@xmlParseEx
	push	esi
	call	_xmlGROW
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
$LN15@xmlParseEx:

; 6968 :         if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {

	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 60			; 0000003cH
	jne	SHORT $LN16@xmlParseEx
	cmp	BYTE PTR [eax+1], 33			; 00000021H
	jne	SHORT $LN16@xmlParseEx
	cmp	BYTE PTR [eax+2], 91			; 0000005bH
	jne	SHORT $LN16@xmlParseEx

; 6969 : 	    xmlParseConditionalSections(ctxt);

	push	esi
	call	_xmlParseConditionalSections

; 6970 : 	} else

	jmp	SHORT $LN165@xmlParseEx
$LN16@xmlParseEx:

; 6971 : 	    xmlParseMarkupDecl(ctxt);

	push	esi
	call	_xmlParseMarkupDecl
$LN165@xmlParseEx:

; 6972 :         SKIP_BLANKS;

	add	esp, 4
	push	esi
	call	_xmlSkipBlankChars

; 6973 : 
; 6974 : 	if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	cmp	DWORD PTR [eax+16], edi
	jne	SHORT $LL2@xmlParseEx
	cmp	ebx, DWORD PTR [eax+36]
	jne	$LL2@xmlParseEx

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN162@xmlParseEx
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN87@xmlParseEx
$LN162@xmlParseEx:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CF@HHCGNGIK@Content?5error?5in?5the?5external?5s@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	60					; 0000003cH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 60			; 0000003cH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN87@xmlParseEx

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN87@xmlParseEx:

; 6975 : 	    xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
; 6976 : 	    break;
; 6977 : 	}
; 6978 :     }
; 6979 : 
; 6980 :     if (RAW != 0) {

	mov	eax, DWORD PTR [esi+36]
	pop	edi
	pop	ebx
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN155@xmlParseEx

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN92@xmlParseEx
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN155@xmlParseEx
$LN92@xmlParseEx:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CF@HHCGNGIK@Content?5error?5in?5the?5external?5s@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	60					; 0000003cH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 60			; 0000003cH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN155@xmlParseEx

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN155@xmlParseEx:
	pop	esi

; 6981 : 	xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
; 6982 :     }
; 6983 : 
; 6984 : }

	pop	ebp
	ret	0
_xmlParseExternalSubset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseMisc
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlParseMisc PROC					; COMDAT

; 10551: xmlParseMisc(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN22@xmlParseMi
	npad	6
$LL2@xmlParseMi:

; 10552:     while ((ctxt->instate != XML_PARSER_EOF) &&

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	al, BYTE PTR [ecx]
	cmp	al, 60					; 0000003cH
	jne	SHORT $LN6@xmlParseMi
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, 63					; 0000003fH
	je	SHORT $LN7@xmlParseMi
	cmp	dl, 33					; 00000021H
	jne	SHORT $LN6@xmlParseMi
	cmp	BYTE PTR [ecx+2], 45			; 0000002dH
	jne	SHORT $LN6@xmlParseMi
	cmp	BYTE PTR [ecx+3], 45			; 0000002dH
	je	SHORT $LN7@xmlParseMi
$LN6@xmlParseMi:
	cmp	al, 32					; 00000020H
	je	SHORT $LN7@xmlParseMi
	cmp	al, 9
	jb	SHORT $LN8@xmlParseMi
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN7@xmlParseMi
$LN8@xmlParseMi:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN22@xmlParseMi
$LN7@xmlParseMi:

; 10553:            (((RAW == '<') && (NXT(1) == '?')) ||
; 10554:             (CMP4(CUR_PTR, '<', '!', '-', '-')) ||
; 10555:             IS_BLANK_CH(CUR))) {
; 10556:         if ((RAW == '<') && (NXT(1) == '?')) {

	cmp	al, 60					; 0000003cH
	jne	SHORT $LN21@xmlParseMi
	cmp	BYTE PTR [ecx+1], 63			; 0000003fH
	jne	SHORT $LN21@xmlParseMi

; 10557: 	    xmlParsePI(ctxt);

	push	esi
	call	_xmlParsePI
	jmp	SHORT $LN23@xmlParseMi
$LN21@xmlParseMi:

; 10558: 	} else if (IS_BLANK_CH(CUR)) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN13@xmlParseMi
	cmp	al, 9
	jb	SHORT $LN14@xmlParseMi
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN13@xmlParseMi
$LN14@xmlParseMi:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN13@xmlParseMi

; 10560: 	} else
; 10561: 	    xmlParseComment(ctxt);

	push	esi
	call	_xmlParseComment
	jmp	SHORT $LN23@xmlParseMi
$LN13@xmlParseMi:

; 10559: 	    NEXT;

	push	esi
	call	_xmlNextChar
$LN23@xmlParseMi:

; 10552:     while ((ctxt->instate != XML_PARSER_EOF) &&

	add	esp, 4
	cmp	DWORD PTR [esi+172], -1
	jne	SHORT $LL2@xmlParseMi
$LN22@xmlParseMi:
	pop	esi

; 10562:     }
; 10563: }

	pop	ebp
	ret	0
_xmlParseMisc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseTextDecl
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlParseTextDecl PROC					; COMDAT

; 6843 : xmlParseTextDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 60			; 0000003cH
	jne	$LN10@xmlParseTe

; 6844 :     xmlChar *version;
; 6845 :     const xmlChar *encoding;
; 6846 : 
; 6847 :     /*
; 6848 :      * We know that '<?xml' is here.
; 6849 :      */
; 6850 :     if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {

	cmp	BYTE PTR [eax+1], 63			; 0000003fH
	jne	$LN10@xmlParseTe
	cmp	BYTE PTR [eax+2], 120			; 00000078H
	jne	$LN10@xmlParseTe
	cmp	BYTE PTR [eax+3], 109			; 0000006dH
	jne	$LN10@xmlParseTe
	cmp	BYTE PTR [eax+4], 108			; 0000006cH
	jne	$LN10@xmlParseTe
	mov	al, BYTE PTR [eax+5]
	cmp	al, 32					; 00000020H
	je	SHORT $LN4@xmlParseTe
	cmp	al, 9
	jb	SHORT $LN13@xmlParseTe
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN4@xmlParseTe
$LN13@xmlParseTe:
	cmp	al, 13					; 0000000dH
	jne	$LN10@xmlParseTe
$LN4@xmlParseTe:

; 6851 : 	SKIP(5);

	add	DWORD PTR [esi+200], 5
	add	DWORD PTR [ecx+16], 5
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 5
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseTe
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseTe:

; 6852 :     } else {
; 6853 : 	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_STARTED, NULL);
; 6854 : 	return;
; 6855 :     }
; 6856 : 
; 6857 :     if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN15@xmlParseTe

; 6858 : 	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BM@OIPNJGND@Space?5needed?5after?5?8?$DM?$DPxml?8?6@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN15@xmlParseTe:

; 6859 : 		       "Space needed after '<?xml'\n");
; 6860 :     }
; 6861 : 
; 6862 :     /*
; 6863 :      * We may have the VersionInfo here.
; 6864 :      */
; 6865 :     version = xmlParseVersionInfo(ctxt);

	push	edi
	push	esi
	call	_xmlParseVersionInfo
	mov	edi, eax
	add	esp, 4

; 6866 :     if (version == NULL)

	test	edi, edi
	jne	SHORT $LN16@xmlParseTe

; 6867 : 	version = xmlCharStrdup(XML_DEFAULT_VERSION);

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlCharStrdup
	add	esp, 4
	mov	edi, eax
	jmp	SHORT $LN18@xmlParseTe
$LN16@xmlParseTe:

; 6868 :     else {
; 6869 : 	if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN18@xmlParseTe

; 6870 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BD@LJKHCJDH@Space?5needed?5here?6@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN18@xmlParseTe:

; 6871 : 		           "Space needed here\n");
; 6872 : 	}
; 6873 :     }
; 6874 :     ctxt->input->version = version;

	mov	eax, DWORD PTR [esi+36]

; 6875 : 
; 6876 :     /*
; 6877 :      * We must have the encoding declaration
; 6878 :      */
; 6879 :     encoding = xmlParseEncodingDecl(ctxt);

	push	esi
	mov	DWORD PTR [eax+48], edi
	call	_xmlParseEncodingDecl

; 6880 :     if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {

	mov	ecx, DWORD PTR [esi+84]
	add	esp, 4
	pop	edi
	cmp	ecx, 32					; 00000020H
	je	$LN93@xmlParseTe

; 6881 : 	/*
; 6882 : 	 * The XML REC instructs us to stop parsing right here
; 6883 : 	 */
; 6884 :         return;
; 6885 :     }
; 6886 :     if ((encoding == NULL) && (ctxt->errNo == XML_ERR_OK)) {

	test	eax, eax
	jne	SHORT $LN20@xmlParseTe
	test	ecx, ecx
	jne	SHORT $LN20@xmlParseTe

; 6887 : 	xmlFatalErrMsg(ctxt, XML_ERR_MISSING_ENCODING,

	push	OFFSET ??_C@_0CG@OFFEFIEL@Missing?5encoding?5in?5text?5declar@
	push	101					; 00000065H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN20@xmlParseTe:

; 6888 : 		       "Missing encoding in text declaration\n");
; 6889 :     }
; 6890 : 
; 6891 :     SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 6892 :     if ((RAW == '?') && (NXT(1) == '>')) {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	mov	ecx, DWORD PTR [eax+16]
	mov	dl, BYTE PTR [ecx]
	cmp	dl, 63					; 0000003fH
	jne	SHORT $LN21@xmlParseTe
	cmp	BYTE PTR [ecx+1], 62			; 0000003eH
	jne	SHORT $LN21@xmlParseTe

; 6893 :         SKIP(2);

	add	DWORD PTR [esi+200], 2
	add	DWORD PTR [eax+16], 2
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 2
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	$LN93@xmlParseTe
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
	pop	esi

; 6902 :     }
; 6903 : }

	pop	ebp
	ret	0
$LN21@xmlParseTe:

; 6894 :     } else if (RAW == '>') {

	mov	eax, DWORD PTR [esi+212]
	cmp	dl, 62					; 0000003eH
	jne	SHORT $LN24@xmlParseTe

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	test	eax, eax
	je	SHORT $LN125@xmlParseTe
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN188@xmlParseTe
$LN125@xmlParseTe:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CH@DOCCAFM@parsing?5XML?5declaration?3?5?8?$DP?$DO?8?5e@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	57					; 00000039H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 57			; 00000039H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN188@xmlParseTe

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN188@xmlParseTe:

; 6895 :         /* Deprecated old WD ... */
; 6896 : 	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
; 6897 : 	NEXT;

	push	esi
	call	_xmlNextChar
	add	esp, 4
	pop	esi

; 6902 :     }
; 6903 : }

	pop	ebp
	ret	0
$LN24@xmlParseTe:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	test	eax, eax
	je	SHORT $LN193@xmlParseTe
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN258@xmlParseTe
$LN193@xmlParseTe:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CH@DOCCAFM@parsing?5XML?5declaration?3?5?8?$DP?$DO?8?5e@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	57					; 00000039H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 57			; 00000039H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN258@xmlParseTe

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN258@xmlParseTe:

; 6898 :     } else {
; 6899 : 	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
; 6900 : 	MOVETO_ENDTAG(CUR_PTR);

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN262@xmlParseTe
$LL8@xmlParseTe:
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 62			; 0000003eH
	je	SHORT $LN262@xmlParseTe
	inc	eax
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL8@xmlParseTe
$LN262@xmlParseTe:

; 6901 : 	NEXT;

	push	esi
	call	_xmlNextChar
	add	esp, 4
	pop	esi

; 6902 :     }
; 6903 : }

	pop	ebp
	ret	0
$LN10@xmlParseTe:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN30@xmlParseTe
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN93@xmlParseTe
$LN30@xmlParseTe:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CC@HHECNJCA@Text?5declaration?5?8?$DM?$DPxml?8?5requir@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	56					; 00000038H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 56			; 00000038H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN93@xmlParseTe

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN93@xmlParseTe:
	pop	esi

; 6902 :     }
; 6903 : }

	pop	ebp
	ret	0
_xmlParseTextDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseXMLDecl
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlParseXMLDecl PROC					; COMDAT

; 10436: xmlParseXMLDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __B9AC27D5_parser@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+52], -2			; fffffffeH
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [esi+200], 5
	add	DWORD PTR [eax+16], 5
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 5
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseXM

; 10437:     xmlChar *version;
; 10438: 
; 10439:     /*
; 10440:      * This value for standalone indicates that the document has an
; 10441:      * XML declaration but it does not have a standalone attribute.
; 10442:      * It will be overwritten later if a standalone attribute is found.
; 10443:      */
; 10444:     ctxt->input->standalone = -2;
; 10445: 
; 10446:     /*
; 10447:      * We know that '<?xml' is here.
; 10448:      */
; 10449:     SKIP(5);

	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 8
$LN2@xmlParseXM:

; 10450: 
; 10451:     if (!IS_BLANK_CH(RAW)) {

	mov	eax, DWORD PTR [ecx+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 32					; 00000020H
	je	SHORT $LN17@xmlParseXM
	cmp	al, 9
	jb	SHORT $LN18@xmlParseXM
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN17@xmlParseXM
$LN18@xmlParseXM:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN17@xmlParseXM

; 10452: 	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BM@BPKNILCI@Blank?5needed?5after?5?8?$DM?$DPxml?8?6@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN17@xmlParseXM:

; 10453: 	               "Blank needed after '<?xml'\n");
; 10454:     }
; 10455:     SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 10456: 
; 10457:     /*
; 10458:      * We must have the VersionInfo here.
; 10459:      */
; 10460:     version = xmlParseVersionInfo(ctxt);

	push	esi
	call	_xmlParseVersionInfo
	mov	edi, eax
	add	esp, 8

; 10461:     if (version == NULL) {

	test	edi, edi
	jne	SHORT $LN19@xmlParseXM

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], eax
	je	SHORT $LN253@xmlParseXM
	cmp	DWORD PTR [esi+172], -1
	je	$LN20@xmlParseXM
$LN253@xmlParseXM:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CI@FHFOLBEM@Malformed?5declaration?5expecting@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	96					; 00000060H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 96			; 00000060H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN20@xmlParseXM

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1

; 10462: 	xmlFatalErr(ctxt, XML_ERR_VERSION_MISSING, NULL);
; 10463:     } else {

	jmp	SHORT $LN20@xmlParseXM
$LN19@xmlParseXM:

; 10464: 	if (!xmlStrEqual(version, (const xmlChar *) XML_DEFAULT_VERSION)) {

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@xmlParseXM

; 10465: 	    /*
; 10466: 	     * Changed here for XML-1.0 5th edition
; 10467: 	     */
; 10468: 	    if (ctxt->options & XML_PARSE_OLD10) {

	test	DWORD PTR [esi+360], 131072		; 00020000H
	jne	SHORT $LN24@xmlParseXM

; 10469: 		xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,
; 10470: 			          "Unsupported version '%s'\n",
; 10471: 			          version);
; 10472: 	    } else {
; 10473: 	        if ((version[0] == '1') && ((version[1] == '.'))) {

	cmp	BYTE PTR [edi], 49			; 00000031H
	jne	SHORT $LN24@xmlParseXM
	cmp	BYTE PTR [edi+1], 46			; 0000002eH
	jne	SHORT $LN24@xmlParseXM

; 10474: 		    xmlWarningMsg(ctxt, XML_WAR_UNKNOWN_VERSION,

	push	eax
	push	edi
	push	OFFSET ??_C@_0BK@MGCDLOCB@Unsupported?5version?5?8?$CFs?8?6@
	push	97					; 00000061H
	push	esi
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H

; 10475: 		                  "Unsupported version '%s'\n",
; 10476: 				  version, NULL);
; 10477: 		} else {

	jmp	SHORT $LN25@xmlParseXM
$LN24@xmlParseXM:

; 10478: 		    xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,

	push	edi
	push	OFFSET ??_C@_0BK@MGCDLOCB@Unsupported?5version?5?8?$CFs?8?6@
	push	108					; 0000006cH
	push	esi
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H
$LN25@xmlParseXM:

; 10479: 				      "Unsupported version '%s'\n",
; 10480: 				      version);
; 10481: 		}
; 10482: 	    }
; 10483: 	}
; 10484: 	if (ctxt->version != NULL)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN26@xmlParseXM

; 10485: 	    xmlFree((void *) ctxt->version);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN26@xmlParseXM:

; 10486: 	ctxt->version = version;

	mov	DWORD PTR [esi+20], edi
$LN20@xmlParseXM:

; 10487:     }
; 10488: 
; 10489:     /*
; 10490:      * We may have the encoding declaration
; 10491:      */
; 10492:     if (!IS_BLANK_CH(RAW)) {

	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	al, BYTE PTR [edx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN27@xmlParseXM
	cmp	al, 9
	jb	SHORT $LN28@xmlParseXM
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN27@xmlParseXM
$LN28@xmlParseXM:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN27@xmlParseXM

; 10493:         if ((RAW == '?') && (NXT(1) == '>')) {

	cmp	al, 63					; 0000003fH
	jne	SHORT $LN29@xmlParseXM
	cmp	BYTE PTR [edx+1], 62			; 0000003eH
	jne	SHORT $LN29@xmlParseXM

; 10494: 	    SKIP(2);

	add	DWORD PTR [esi+200], 2
	add	DWORD PTR [ecx+16], 2

; 10495: 	    return;

	jmp	$LN255@xmlParseXM
$LN29@xmlParseXM:

; 10496: 	}
; 10497: 	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Blank needed here\n");

	push	OFFSET ??_C@_0BD@KLGEONFL@Blank?5needed?5here?6@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN27@xmlParseXM:

; 10498:     }
; 10499:     xmlParseEncodingDecl(ctxt);

	push	esi
	call	_xmlParseEncodingDecl
	add	esp, 4

; 10500:     if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||

	cmp	DWORD PTR [esi+84], 32			; 00000020H
	je	$LN32@xmlParseXM
	cmp	DWORD PTR [esi+172], -1
	je	$LN32@xmlParseXM

; 10501:          (ctxt->instate == XML_PARSER_EOF)) {
; 10502: 	/*
; 10503: 	 * The XML REC instructs us to stop parsing right here
; 10504: 	 */
; 10505:         return;
; 10506:     }
; 10507: 
; 10508:     /*
; 10509:      * We may have the standalone status.
; 10510:      */
; 10511:     if ((ctxt->input->encoding != NULL) && (!IS_BLANK_CH(RAW))) {

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, eax
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN33@xmlParseXM
	mov	edi, DWORD PTR [eax+16]
	mov	dl, BYTE PTR [edi]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN33@xmlParseXM
	cmp	dl, 9
	jb	SHORT $LN34@xmlParseXM
	cmp	dl, 10					; 0000000aH
	jbe	SHORT $LN33@xmlParseXM
$LN34@xmlParseXM:
	mov	ecx, eax
	cmp	dl, 13					; 0000000dH
	je	SHORT $LN33@xmlParseXM

; 10512:         if ((RAW == '?') && (NXT(1) == '>')) {

	cmp	dl, 63					; 0000003fH
	jne	SHORT $LN35@xmlParseXM
	cmp	BYTE PTR [edi+1], 62			; 0000003eH
	je	SHORT $LN256@xmlParseXM
$LN35@xmlParseXM:

; 10513: 	    SKIP(2);
; 10514: 	    return;
; 10515: 	}
; 10516: 	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Blank needed here\n");

	push	OFFSET ??_C@_0BD@KLGEONFL@Blank?5needed?5here?6@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
$LN33@xmlParseXM:

; 10517:     }
; 10518: 
; 10519:     /*
; 10520:      * We can grow the input buffer freely at that point
; 10521:      */
; 10522:     GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN37@xmlParseXM
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [ecx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN37@xmlParseXM
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN37@xmlParseXM:

; 10523: 
; 10524:     SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 10525:     ctxt->input->standalone = xmlParseSDDecl(ctxt);

	push	esi
	call	_xmlParseSDDecl
	mov	ecx, DWORD PTR [esi+36]

; 10526: 
; 10527:     SKIP_BLANKS;

	push	esi
	mov	DWORD PTR [ecx+52], eax
	call	_xmlSkipBlankChars

; 10528:     if ((RAW == '?') && (NXT(1) == '>')) {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax+16]
	mov	dl, BYTE PTR [ecx]
	cmp	dl, 63					; 0000003fH
	jne	SHORT $LN38@xmlParseXM
	cmp	BYTE PTR [ecx+1], 62			; 0000003eH
	jne	SHORT $LN38@xmlParseXM
$LN256@xmlParseXM:

; 10538:     }
; 10539: }

	add	DWORD PTR [esi+200], 2
	add	DWORD PTR [eax+16], 2
$LN255@xmlParseXM:
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 2
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	$LN32@xmlParseXM
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN38@xmlParseXM:

; 10529:         SKIP(2);
; 10530:     } else if (RAW == '>') {

	mov	eax, DWORD PTR [esi+212]
	cmp	dl, 62					; 0000003eH
	jne	SHORT $LN41@xmlParseXM

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	test	eax, eax
	je	SHORT $LN115@xmlParseXM
	cmp	DWORD PTR [esi+172], -1
	je	$LN254@xmlParseXM
$LN115@xmlParseXM:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CH@DOCCAFM@parsing?5XML?5declaration?3?5?8?$DP?$DO?8?5e@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	57					; 00000039H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 57			; 00000039H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	$LN254@xmlParseXM

; 10537: 	NEXT;

	push	esi

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1

; 10537: 	NEXT;

	call	_xmlNextChar
	add	esp, 4
	pop	edi

; 10538:     }
; 10539: }

	pop	esi
	pop	ebp
	ret	0
$LN41@xmlParseXM:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	test	eax, eax
	je	SHORT $LN183@xmlParseXM
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN248@xmlParseXM
$LN183@xmlParseXM:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CH@DOCCAFM@parsing?5XML?5declaration?3?5?8?$DP?$DO?8?5e@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	57					; 00000039H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 57			; 00000039H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN248@xmlParseXM

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN248@xmlParseXM:

; 10531:         /* Deprecated old WD ... */
; 10532: 	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
; 10533: 	NEXT;
; 10534:     } else {
; 10535: 	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
; 10536: 	MOVETO_ENDTAG(CUR_PTR);

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN254@xmlParseXM
	npad	5
$LL14@xmlParseXM:
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 62			; 0000003eH
	je	SHORT $LN254@xmlParseXM
	inc	eax
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL14@xmlParseXM
$LN254@xmlParseXM:

; 10537: 	NEXT;

	push	esi
	call	_xmlNextChar
	add	esp, 4
$LN32@xmlParseXM:

; 10538:     }
; 10539: }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlParseXMLDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseSDDecl
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlParseSDDecl PROC					; COMDAT

; 10374: xmlParseSDDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	edi, -2					; fffffffeH
	push	esi
	call	_xmlSkipBlankChars
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 115			; 00000073H
	jne	$LN447@xmlParseSD

; 10375:     int standalone = -2;
; 10376: 
; 10377:     SKIP_BLANKS;
; 10378:     if (CMP10(CUR_PTR, 's', 't', 'a', 'n', 'd', 'a', 'l', 'o', 'n', 'e')) {

	cmp	BYTE PTR [eax+1], 116			; 00000074H
	jne	$LN447@xmlParseSD
	cmp	BYTE PTR [eax+2], 97			; 00000061H
	jne	$LN447@xmlParseSD
	cmp	BYTE PTR [eax+3], 110			; 0000006eH
	jne	$LN447@xmlParseSD
	cmp	BYTE PTR [eax+4], 100			; 00000064H
	jne	$LN447@xmlParseSD
	cmp	BYTE PTR [eax+5], 97			; 00000061H
	jne	$LN447@xmlParseSD
	cmp	BYTE PTR [eax+6], 108			; 0000006cH
	jne	$LN447@xmlParseSD
	cmp	BYTE PTR [eax+7], 111			; 0000006fH
	jne	$LN447@xmlParseSD
	cmp	BYTE PTR [eax+8], 110			; 0000006eH
	jne	$LN447@xmlParseSD
	cmp	BYTE PTR [eax+9], 101			; 00000065H
	jne	$LN447@xmlParseSD

; 10379: 	SKIP(10);

	add	DWORD PTR [esi+200], 10			; 0000000aH
	add	DWORD PTR [ecx+16], 10			; 0000000aH
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 10			; 0000000aH
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseSD
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseSD:

; 10380:         SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 10381: 	if (RAW != '=') {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 61			; 0000003dH
	je	SHORT $LN19@xmlParseSD

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN44@xmlParseSD
	cmp	DWORD PTR [esi+172], -1
	je	$LN447@xmlParseSD
$LN44@xmlParseSD:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0N@FLAMKNN@expected?5?8?$DN?8@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 75			; 0000004bH
	push	75					; 0000004bH

; 10382: 	    xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
; 10383: 	    return(standalone);

	jmp	$LN456@xmlParseSD
$LN19@xmlParseSD:

; 10384:         }
; 10385: 	NEXT;

	push	esi
	call	_xmlNextChar

; 10386: 	SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 10387:         if (RAW == '\''){

	mov	eax, DWORD PTR [esi+36]
	add	esp, 8
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 39					; 00000027H
	jne	$LN20@xmlParseSD

; 10388: 	    NEXT;

	push	esi
	call	_xmlNextChar

; 10389: 	    if ((RAW == 'n') && (NXT(1) == 'o')) {

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [ecx+16]
	mov	dl, BYTE PTR [eax]
	cmp	dl, 110					; 0000006eH
	jne	SHORT $LN450@xmlParseSD
	cmp	BYTE PTR [eax+1], 111			; 0000006fH
	jne	SHORT $LN450@xmlParseSD

; 10390: 	        standalone = 0;
; 10391:                 SKIP(2);

	add	DWORD PTR [esi+200], 2
	xor	edi, edi
	add	DWORD PTR [ecx+16], 2
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 2
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	$LN175@xmlParseSD
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8

; 10392: 	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&

	jmp	$LN175@xmlParseSD
$LN450@xmlParseSD:
	cmp	dl, 121					; 00000079H
	jne	SHORT $LN25@xmlParseSD
	cmp	BYTE PTR [eax+1], 101			; 00000065H
	jne	SHORT $LN25@xmlParseSD
	cmp	BYTE PTR [eax+2], 115			; 00000073H
	jne	SHORT $LN25@xmlParseSD

; 10393: 	               (NXT(2) == 's')) {
; 10394: 	        standalone = 1;
; 10395: 		SKIP(3);

	add	DWORD PTR [esi+200], 3
	mov	edi, 1
	add	DWORD PTR [ecx+16], 3
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 3
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN175@xmlParseSD
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8

; 10396:             } else {

	jmp	SHORT $LN175@xmlParseSD
$LN25@xmlParseSD:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN451@xmlParseSD
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN175@xmlParseSD
$LN451@xmlParseSD:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CG@MBLHCBEE@standalone?5accepts?5only?5?8yes?8?5o@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	78					; 0000004eH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 78			; 0000004eH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN175@xmlParseSD

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN175@xmlParseSD:

; 10397: 		xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
; 10398: 	    }
; 10399: 	    if (RAW != '\'') {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 39			; 00000027H
$LN457@xmlParseSD:

; 10418: 	        NEXT;
; 10419: 	} else {
; 10420: 	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
; 10421:         }
; 10422:     }
; 10423:     return(standalone);
; 10424: }

	je	$LN38@xmlParseSD
	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN180@xmlParseSD
	cmp	DWORD PTR [esi+172], -1
	je	$LN447@xmlParseSD
$LN180@xmlParseSD:
	push	OFFSET ??_C@_0CD@GLDIEMIA@String?5not?5closed?5expecting?5?$CC?5o@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 34			; 00000022H
	push	34					; 00000022H
	jmp	$LN456@xmlParseSD
$LN20@xmlParseSD:

; 10400: 		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
; 10401: 	    } else
; 10402: 	        NEXT;
; 10403: 	} else if (RAW == '"'){

	cmp	al, 34					; 00000022H
	jne	$LN30@xmlParseSD

; 10404: 	    NEXT;

	push	esi
	call	_xmlNextChar

; 10405: 	    if ((RAW == 'n') && (NXT(1) == 'o')) {

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [ecx+16]
	mov	dl, BYTE PTR [eax]
	cmp	dl, 110					; 0000006eH
	jne	SHORT $LN452@xmlParseSD
	cmp	BYTE PTR [eax+1], 111			; 0000006fH
	jne	SHORT $LN452@xmlParseSD

; 10406: 	        standalone = 0;
; 10407: 		SKIP(2);

	add	DWORD PTR [esi+200], 2
	xor	edi, edi
	add	DWORD PTR [ecx+16], 2
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 2
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	$LN311@xmlParseSD
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow

; 10412:             } else {
; 10413: 		xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
; 10414: 	    }
; 10415: 	    if (RAW != '"') {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 8
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 34			; 00000022H

; 10416: 		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
; 10417: 	    } else

	jmp	$LN457@xmlParseSD
$LN452@xmlParseSD:

; 10408: 	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&

	cmp	dl, 121					; 00000079H
	jne	SHORT $LN35@xmlParseSD
	cmp	BYTE PTR [eax+1], 101			; 00000065H
	jne	SHORT $LN35@xmlParseSD
	cmp	BYTE PTR [eax+2], 115			; 00000073H
	jne	SHORT $LN35@xmlParseSD

; 10409: 	               (NXT(2) == 's')) {
; 10410: 	        standalone = 1;
; 10411:                 SKIP(3);

	add	DWORD PTR [esi+200], 3
	mov	edi, 1
	add	DWORD PTR [ecx+16], 3
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 3
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN311@xmlParseSD
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow

; 10412:             } else {
; 10413: 		xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
; 10414: 	    }
; 10415: 	    if (RAW != '"') {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 8
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 34			; 00000022H

; 10416: 		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
; 10417: 	    } else

	jmp	$LN457@xmlParseSD
$LN35@xmlParseSD:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN453@xmlParseSD
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN311@xmlParseSD
$LN453@xmlParseSD:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CG@MBLHCBEE@standalone?5accepts?5only?5?8yes?8?5o@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	78					; 0000004eH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 78			; 0000004eH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN311@xmlParseSD

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN311@xmlParseSD:

; 10412:             } else {
; 10413: 		xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
; 10414: 	    }
; 10415: 	    if (RAW != '"') {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 34			; 00000022H

; 10416: 		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
; 10417: 	    } else

	jmp	$LN457@xmlParseSD
$LN38@xmlParseSD:

; 10418: 	        NEXT;
; 10419: 	} else {
; 10420: 	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
; 10421:         }
; 10422:     }
; 10423:     return(standalone);
; 10424: }

	push	esi
	call	_xmlNextChar
	add	esp, 4
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN30@xmlParseSD:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN384@xmlParseSD
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN447@xmlParseSD
$LN384@xmlParseSD:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CE@EGHHEGNE@String?5not?5started?5expecting?5?8?5@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 33			; 00000021H
	push	33					; 00000021H
$LN456@xmlParseSD:

; 10418: 	        NEXT;
; 10419: 	} else {
; 10420: 	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
; 10421:         }
; 10422:     }
; 10423:     return(standalone);
; 10424: }

	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	mov	DWORD PTR [esi+12], 0
	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN447@xmlParseSD
	mov	DWORD PTR [esi+212], 1
$LN447@xmlParseSD:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlParseSDDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEncodingDecl
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlParseEncodingDecl PROC				; COMDAT

; 10242: xmlParseEncodingDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	push	esi
	call	_xmlSkipBlankChars
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 101			; 00000065H
	jne	$LN29@xmlParseEn

; 10243:     xmlChar *encoding = NULL;
; 10244: 
; 10245:     SKIP_BLANKS;
; 10246:     if (CMP8(CUR_PTR, 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g')) {

	cmp	BYTE PTR [eax+1], 110			; 0000006eH
	jne	$LN29@xmlParseEn
	cmp	BYTE PTR [eax+2], 99			; 00000063H
	jne	$LN29@xmlParseEn
	cmp	BYTE PTR [eax+3], 111			; 0000006fH
	jne	$LN29@xmlParseEn
	cmp	BYTE PTR [eax+4], 100			; 00000064H
	jne	$LN29@xmlParseEn
	cmp	BYTE PTR [eax+5], 105			; 00000069H
	jne	$LN29@xmlParseEn
	cmp	BYTE PTR [eax+6], 110			; 0000006eH
	jne	$LN29@xmlParseEn
	cmp	BYTE PTR [eax+7], 103			; 00000067H
	jne	$LN29@xmlParseEn

; 10247: 	SKIP(8);

	add	DWORD PTR [esi+200], 8
	add	DWORD PTR [ecx+16], 8
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 8
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseEn
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseEn:

; 10248: 	SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 10249: 	if (RAW != '=') {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 61			; 0000003dH
	je	SHORT $LN7@xmlParseEn

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], edi
	je	SHORT $LN89@xmlParseEn
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN152@xmlParseEn
$LN89@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0N@FLAMKNN@expected?5?8?$DN?8@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	75					; 0000004bH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 75			; 0000004bH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], edi

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], edi
	jne	SHORT $LN152@xmlParseEn

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN152@xmlParseEn:
	pop	edi

; 10250: 	    xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
; 10251: 	    return(NULL);

	xor	eax, eax

; 10340: }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlParseEn:

; 10252:         }
; 10253: 	NEXT;

	push	esi
	call	_xmlNextChar

; 10254: 	SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 10255: 	if (RAW == '"') {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 8
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 34					; 00000022H
	jne	$LN8@xmlParseEn

; 10256: 	    NEXT;

	push	esi
	call	_xmlNextChar

; 10257: 	    encoding = xmlParseEncName(ctxt);

	push	esi
	call	_xmlParseEncName

; 10258: 	    if (RAW != '"') {

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 8
	mov	edi, eax
	mov	ecx, DWORD PTR [ecx+16]
	cmp	BYTE PTR [ecx], 34			; 00000022H
	je	$LN14@xmlParseEn

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN157@xmlParseEn
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN220@xmlParseEn
$LN157@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CD@GLDIEMIA@String?5not?5closed?5expecting?5?$CC?5o@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	34					; 00000022H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 34			; 00000022H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN220@xmlParseEn

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN220@xmlParseEn:

; 10340: }

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN8@xmlParseEn:

; 10259: 		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
; 10260: 		xmlFree((xmlChar *) encoding);
; 10261: 		return(NULL);
; 10262: 	    } else
; 10263: 	        NEXT;
; 10264: 	} else if (RAW == '\''){

	cmp	al, 39					; 00000027H
	jne	$LN12@xmlParseEn

; 10265: 	    NEXT;

	push	esi
	call	_xmlNextChar

; 10266: 	    encoding = xmlParseEncName(ctxt);

	push	esi
	call	_xmlParseEncName
	mov	edi, eax
	add	esp, 8

; 10267: 	    if (RAW != '\'') {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 39			; 00000027H
	je	SHORT $LN14@xmlParseEn

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN225@xmlParseEn
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN288@xmlParseEn
$LN225@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CD@GLDIEMIA@String?5not?5closed?5expecting?5?$CC?5o@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	34					; 00000022H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 34			; 00000022H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN288@xmlParseEn

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN288@xmlParseEn:

; 10268: 		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
; 10269: 		xmlFree((xmlChar *) encoding);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 10270: 		return(NULL);

	xor	eax, eax
	pop	edi

; 10340: }

	pop	esi
	pop	ebp
	ret	0
$LN14@xmlParseEn:

; 10271: 	    } else
; 10272: 	        NEXT;
; 10273: 	} else {
; 10274: 	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
; 10275: 	}
; 10276: 
; 10277:         /*
; 10278:          * Non standard parsing, allowing the user to ignore encoding
; 10279:          */
; 10280:         if (ctxt->options & XML_PARSE_IGNORE_ENC) {

	push	esi
	call	_xmlNextChar
	add	esp, 4
	jmp	SHORT $LN356@xmlParseEn
$LN12@xmlParseEn:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], edi
	je	SHORT $LN293@xmlParseEn
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN356@xmlParseEn
$LN293@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CE@EGHHEGNE@String?5not?5started?5expecting?5?8?5@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	33					; 00000021H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 33			; 00000021H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], edi

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], edi
	jne	SHORT $LN356@xmlParseEn

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN356@xmlParseEn:

; 10271: 	    } else
; 10272: 	        NEXT;
; 10273: 	} else {
; 10274: 	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
; 10275: 	}
; 10276: 
; 10277:         /*
; 10278:          * Non standard parsing, allowing the user to ignore encoding
; 10279:          */
; 10280:         if (ctxt->options & XML_PARSE_IGNORE_ENC) {

	test	DWORD PTR [esi+360], 2097152		; 00200000H
	jne	$LN220@xmlParseEn

; 10281: 	    xmlFree((xmlChar *) encoding);
; 10282:             return(NULL);
; 10283: 	}
; 10284: 
; 10285: 	/*
; 10286: 	 * UTF-16 encoding stwich has already taken place at this stage,
; 10287: 	 * more over the little-endian/big-endian selection is already done
; 10288: 	 */
; 10289:         if ((encoding != NULL) &&

	test	edi, edi
	je	$LN29@xmlParseEn
	push	OFFSET ??_C@_06KNDPGIKI@UTF?916@
	push	edi
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	$LN19@xmlParseEn
	push	OFFSET ??_C@_05MNCHLHCA@UTF16@
	push	edi
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	$LN19@xmlParseEn

; 10302: 		  "Document labelled UTF-16 but has UTF-8 content\n");
; 10303: 	    }
; 10304: 	    if (ctxt->encoding != NULL)
; 10305: 		xmlFree((xmlChar *) ctxt->encoding);
; 10306: 	    ctxt->encoding = encoding;
; 10307: 	}
; 10308: 	/*
; 10309: 	 * UTF-8 encoding is handled natively
; 10310: 	 */
; 10311:         else if ((encoding != NULL) &&

	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	push	edi
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	$LN24@xmlParseEn
	push	OFFSET ??_C@_04OOMJJNCF@UTF8@
	push	edi
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@xmlParseEn

; 10312: 	    ((!xmlStrcasecmp(encoding, BAD_CAST "UTF-8")) ||
; 10313: 	     (!xmlStrcasecmp(encoding, BAD_CAST "UTF8")))) {
; 10314: 	    if (ctxt->encoding != NULL)
; 10315: 		xmlFree((xmlChar *) ctxt->encoding);
; 10316: 	    ctxt->encoding = encoding;
; 10317: 	}
; 10318: 	else if (encoding != NULL) {
; 10319: 	    xmlCharEncodingHandlerPtr handler;
; 10320: 
; 10321: 	    if (ctxt->input->encoding != NULL)

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+44]
	test	ecx, ecx
	je	SHORT $LN27@xmlParseEn

; 10322: 		xmlFree((xmlChar *) ctxt->input->encoding);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
$LN27@xmlParseEn:

; 10323: 	    ctxt->input->encoding = encoding;
; 10324: 
; 10325:             handler = xmlFindCharEncodingHandler((const char *) encoding);

	push	edi
	mov	DWORD PTR [eax+44], edi
	call	_xmlFindCharEncodingHandler
	add	esp, 4

; 10326: 	    if (handler != NULL) {

	test	eax, eax
	je	SHORT $LN28@xmlParseEn

; 10327: 		if (xmlSwitchToEncoding(ctxt, handler) < 0) {

	push	eax
	push	esi
	call	_xmlSwitchToEncoding
	add	esp, 8
	test	eax, eax
	jns	SHORT $LN29@xmlParseEn

; 10328: 		    /* failed to convert */
; 10329: 		    ctxt->errNo = XML_ERR_UNSUPPORTED_ENCODING;

	pop	edi
	mov	DWORD PTR [esi+84], 32			; 00000020H

; 10330: 		    return(NULL);

	xor	eax, eax

; 10340: }

	pop	esi
	pop	ebp
	ret	0
$LN28@xmlParseEn:

; 10331: 		}
; 10332: 	    } else {
; 10333: 		xmlFatalErrMsgStr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	edi
	push	OFFSET ??_C@_0BJ@FCHADMKI@Unsupported?5encoding?5?$CFs?6@
	push	32					; 00000020H
	push	esi
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 10334: 			"Unsupported encoding %s\n", encoding);
; 10335: 		return(NULL);

	xor	eax, eax
	pop	edi

; 10340: }

	pop	esi
	pop	ebp
	ret	0
$LN19@xmlParseEn:

; 10290: 	    ((!xmlStrcasecmp(encoding, BAD_CAST "UTF-16")) ||
; 10291: 	     (!xmlStrcasecmp(encoding, BAD_CAST "UTF16")))) {
; 10292: 	    /*
; 10293: 	     * If no encoding was passed to the parser, that we are
; 10294: 	     * using UTF-16 and no decoder is present i.e. the
; 10295: 	     * document is apparently UTF-8 compatible, then raise an
; 10296: 	     * encoding mismatch fatal error
; 10297: 	     */
; 10298: 	    if ((ctxt->encoding == NULL) &&
; 10299: 	        (ctxt->input->buf != NULL) &&

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LN358@xmlParseEn
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN21@xmlParseEn
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN21@xmlParseEn

; 10300: 	        (ctxt->input->buf->encoder == NULL)) {
; 10301: 		xmlFatalErrMsg(ctxt, XML_ERR_INVALID_ENCODING,

	push	OFFSET ??_C@_0DA@MEEPFAA@Document?5labelled?5UTF?916?5but?5ha@
	push	81					; 00000051H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN24@xmlParseEn:

; 10336: 	    }
; 10337: 	}
; 10338:     }
; 10339:     return(encoding);

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN21@xmlParseEn
$LN358@xmlParseEn:
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN21@xmlParseEn:
	mov	DWORD PTR [esi+24], edi
$LN29@xmlParseEn:
	mov	eax, edi
	pop	edi

; 10340: }

	pop	esi
	pop	ebp
	ret	0
_xmlParseEncodingDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEncName
_TEXT	SEGMENT
_size$1$ = -8						; size = 4
_buf$1$ = -4						; size = 4
_len$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseEncName PROC					; COMDAT

; 10177: xmlParseEncName(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	mov	DWORD PTR _size$1$[ebp], 10		; 0000000aH
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	mov	bl, BYTE PTR [eax]
	cmp	bl, 97					; 00000061H
	jb	SHORT $LN7@xmlParseEn

; 10178:     xmlChar *buf = NULL;
; 10179:     int len = 0;
; 10180:     int size = 10;
; 10181:     xmlChar cur;
; 10182: 
; 10183:     cur = CUR;
; 10184:     if (((cur >= 'a') && (cur <= 'z')) ||

	cmp	bl, 122					; 0000007aH
	jbe	SHORT $LN6@xmlParseEn
$LN7@xmlParseEn:
	lea	eax, DWORD PTR [ebx-65]
	cmp	al, 25					; 00000019H
	ja	$LN4@xmlParseEn
$LN6@xmlParseEn:

; 10185:         ((cur >= 'A') && (cur <= 'Z'))) {
; 10186: 	buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	push	10					; 0000000aH
	call	DWORD PTR _xmlMallocAtomic
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _buf$1$[ebp], edi

; 10187: 	if (buf == NULL) {

	test	edi, edi
	jne	SHORT $LN8@xmlParseEn

; 10188: 	    xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory
	add	esp, 8

; 10189: 	    return(NULL);

	xor	eax, eax
	pop	edi

; 10226: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlParseEn:

; 10190: 	}
; 10191: 
; 10192: 	buf[len++] = cur;

	mov	BYTE PTR [edi], bl
	mov	edi, 1

; 10193: 	NEXT;

	push	esi
	mov	DWORD PTR _len$1$[ebp], edi
	call	_xmlNextChar

; 10194: 	cur = CUR;

	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [eax+16]
	mov	bl, BYTE PTR [eax]

; 10215: 	    if (cur == 0) {

	jmp	SHORT $LL2@xmlParseEn
$LL93@xmlParseEn:

; 10195: 	while (((cur >= 'a') && (cur <= 'z')) ||
; 10196: 	       ((cur >= 'A') && (cur <= 'Z')) ||
; 10197: 	       ((cur >= '0') && (cur <= '9')) ||
; 10198: 	       (cur == '.') || (cur == '_') ||

	mov	edi, DWORD PTR _len$1$[ebp]
$LL2@xmlParseEn:
	cmp	bl, 97					; 00000061H
	jb	SHORT $LN10@xmlParseEn
	cmp	bl, 122					; 0000007aH
	jbe	SHORT $LN9@xmlParseEn
$LN10@xmlParseEn:
	cmp	bl, 65					; 00000041H
	jb	SHORT $LN11@xmlParseEn
	cmp	bl, 90					; 0000005aH
	jbe	SHORT $LN9@xmlParseEn
$LN11@xmlParseEn:
	cmp	bl, 48					; 00000030H
	jb	SHORT $LN12@xmlParseEn
	cmp	bl, 57					; 00000039H
	jbe	SHORT $LN9@xmlParseEn
$LN12@xmlParseEn:
	cmp	bl, 46					; 0000002eH
	je	SHORT $LN9@xmlParseEn
	cmp	bl, 95					; 0000005fH
	je	SHORT $LN9@xmlParseEn
	cmp	bl, 45					; 0000002dH
	jne	$LN3@xmlParseEn
$LN9@xmlParseEn:

; 10199: 	       (cur == '-')) {
; 10200: 	    if (len + 1 >= size) {

	mov	eax, DWORD PTR _size$1$[ebp]
	inc	edi
	cmp	edi, eax
	jl	SHORT $LN92@xmlParseEn

; 10201: 	        xmlChar *tmp;
; 10202: 
; 10203: 		size *= 2;

	add	eax, eax

; 10204: 		tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));

	push	eax
	push	DWORD PTR _buf$1$[ebp]
	mov	DWORD PTR _size$1$[ebp], eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 10205: 		if (tmp == NULL) {

	test	eax, eax
	je	$LN88@xmlParseEn

; 10209: 		}
; 10210: 		buf = tmp;

	mov	DWORD PTR _buf$1$[ebp], eax
	jmp	SHORT $LN13@xmlParseEn
$LN92@xmlParseEn:

; 10199: 	       (cur == '-')) {
; 10200: 	    if (len + 1 >= size) {

	mov	eax, DWORD PTR _buf$1$[ebp]
$LN13@xmlParseEn:

; 10211: 	    }
; 10212: 	    buf[len++] = cur;

	mov	ecx, DWORD PTR _len$1$[ebp]

; 10213: 	    NEXT;

	push	esi
	mov	DWORD PTR _len$1$[ebp], edi
	mov	BYTE PTR [ecx+eax], bl
	call	_xmlNextChar

; 10214: 	    cur = CUR;

	mov	edi, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [edi+16]
	mov	bl, BYTE PTR [eax]

; 10215: 	    if (cur == 0) {

	test	bl, bl
	jne	SHORT $LL93@xmlParseEn

; 10216: 	        SHRINK;

	mov	edx, DWORD PTR [esi+292]
	mov	ecx, edi
	test	edx, edx
	jne	SHORT $LN16@xmlParseEn
	sub	eax, DWORD PTR [edi+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN16@xmlParseEn
	mov	eax, DWORD PTR [edi+20]
	sub	eax, DWORD PTR [edi+16]
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN16@xmlParseEn
	push	esi
	call	_xmlSHRINK
	mov	edx, DWORD PTR [esi+292]
	add	esp, 4
	mov	ecx, DWORD PTR [esi+36]
$LN16@xmlParseEn:

; 10217: 		GROW;

	mov	edi, ecx
	test	edx, edx
	jne	SHORT $LN17@xmlParseEn
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [ecx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN17@xmlParseEn
	push	esi
	call	_xmlGROW
	mov	edi, DWORD PTR [esi+36]
	add	esp, 4
$LN17@xmlParseEn:

; 10218: 		cur = CUR;

	mov	eax, DWORD PTR [edi+16]
	mov	bl, BYTE PTR [eax]

; 10219: 	    }
; 10220:         }

	jmp	$LL93@xmlParseEn
$LN3@xmlParseEn:

; 10221: 	buf[len] = 0;

	mov	edi, DWORD PTR _buf$1$[ebp]

; 10222:     } else {
; 10223: 	xmlFatalErr(ctxt, XML_ERR_ENCODING_NAME, NULL);
; 10224:     }
; 10225:     return(buf);

	mov	eax, edi
	mov	ecx, DWORD PTR _len$1$[ebp]
	mov	BYTE PTR [ecx+edi], 0
	pop	edi

; 10226: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN88@xmlParseEn:

; 10206: 		    xmlErrMemory(ctxt, NULL);

	push	0
	push	esi
	call	_xmlErrMemory

; 10207: 		    xmlFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 10208: 		    return(NULL);

	xor	eax, eax
	pop	edi

; 10226: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlParseEn:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], edi
	je	SHORT $LN22@xmlParseEn
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN85@xmlParseEn
$LN22@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BK@CMOJKGNC@Invalid?5XML?5encoding?5name@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	79					; 0000004fH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 79			; 0000004fH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], edi

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], edi
	jne	SHORT $LN85@xmlParseEn

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN85@xmlParseEn:

; 10222:     } else {
; 10223: 	xmlFatalErr(ctxt, XML_ERR_ENCODING_NAME, NULL);
; 10224:     }
; 10225:     return(buf);

	mov	eax, edi
	pop	edi

; 10226: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseEncName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseVersionInfo
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlParseVersionInfo PROC				; COMDAT

; 10133: xmlParseVersionInfo(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 118			; 00000076H
	jne	$LN314@xmlParseVe

; 10134:     xmlChar *version = NULL;
; 10135: 
; 10136:     if (CMP7(CUR_PTR, 'v', 'e', 'r', 's', 'i', 'o', 'n')) {

	cmp	BYTE PTR [eax+1], 101			; 00000065H
	jne	$LN314@xmlParseVe
	cmp	BYTE PTR [eax+2], 114			; 00000072H
	jne	$LN314@xmlParseVe
	cmp	BYTE PTR [eax+3], 115			; 00000073H
	jne	$LN314@xmlParseVe
	cmp	BYTE PTR [eax+4], 105			; 00000069H
	jne	$LN314@xmlParseVe
	cmp	BYTE PTR [eax+5], 111			; 0000006fH
	jne	$LN314@xmlParseVe
	cmp	BYTE PTR [eax+6], 110			; 0000006eH
	jne	$LN314@xmlParseVe

; 10137: 	SKIP(7);

	add	DWORD PTR [esi+200], 7
	add	DWORD PTR [ecx+16], 7
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 7
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseVe
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseVe:

; 10138: 	SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 10139: 	if (RAW != '=') {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 61			; 0000003dH
	je	SHORT $LN7@xmlParseVe

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], edi
	je	SHORT $LN47@xmlParseVe
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN110@xmlParseVe
$LN47@xmlParseVe:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0N@FLAMKNN@expected?5?8?$DN?8@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	75					; 0000004bH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 75			; 0000004bH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], edi

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], edi
	jne	SHORT $LN110@xmlParseVe

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN110@xmlParseVe:
	pop	edi

; 10140: 	    xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
; 10141: 	    return(NULL);

	xor	eax, eax

; 10164: }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlParseVe:

; 10142:         }
; 10143: 	NEXT;

	push	esi
	call	_xmlNextChar

; 10144: 	SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 10145: 	if (RAW == '"') {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 8
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 34					; 00000022H
	jne	SHORT $LN8@xmlParseVe

; 10146: 	    NEXT;

	push	esi
	call	_xmlNextChar

; 10147: 	    version = xmlParseVersionNum(ctxt);

	push	esi
	call	_xmlParseVersionNum

; 10148: 	    if (RAW != '"') {

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 8
	mov	edi, eax
	mov	ecx, DWORD PTR [ecx+16]
	cmp	BYTE PTR [ecx], 34			; 00000022H
	je	$LN14@xmlParseVe

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN115@xmlParseVe
	cmp	DWORD PTR [esi+172], -1
	je	$LN314@xmlParseVe
$LN115@xmlParseVe:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CD@GLDIEMIA@String?5not?5closed?5expecting?5?$CC?5o@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	34					; 00000022H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 34			; 00000022H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0

; 10149: 		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
; 10150: 	    } else

	jmp	$LN316@xmlParseVe
$LN8@xmlParseVe:

; 10151: 	        NEXT;
; 10152: 	} else if (RAW == '\''){

	cmp	al, 39					; 00000027H
	jne	$LN12@xmlParseVe

; 10153: 	    NEXT;

	push	esi
	call	_xmlNextChar

; 10154: 	    version = xmlParseVersionNum(ctxt);

	push	esi
	call	_xmlParseVersionNum
	mov	edi, eax
	add	esp, 8

; 10155: 	    if (RAW != '\'') {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 39			; 00000027H
	je	SHORT $LN14@xmlParseVe

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN183@xmlParseVe
	cmp	DWORD PTR [esi+172], -1
	je	$LN314@xmlParseVe
$LN183@xmlParseVe:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CD@GLDIEMIA@String?5not?5closed?5expecting?5?$CC?5o@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	34					; 00000022H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 34			; 00000022H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0

; 10156: 		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
; 10157: 	    } else

	jmp	SHORT $LN316@xmlParseVe
$LN14@xmlParseVe:

; 10158: 	        NEXT;
; 10159: 	} else {
; 10160: 	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
; 10161: 	}
; 10162:     }
; 10163:     return(version);

	push	esi
	call	_xmlNextChar
	add	esp, 4
	mov	eax, edi
	pop	edi

; 10164: }

	pop	esi
	pop	ebp
	ret	0
$LN12@xmlParseVe:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], edi
	je	SHORT $LN251@xmlParseVe
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN314@xmlParseVe
$LN251@xmlParseVe:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CE@EGHHEGNE@String?5not?5started?5expecting?5?8?5@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	33					; 00000021H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 33			; 00000021H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], edi

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], edi
$LN316@xmlParseVe:

; 10158: 	        NEXT;
; 10159: 	} else {
; 10160: 	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
; 10161: 	}
; 10162:     }
; 10163:     return(version);

	jne	SHORT $LN314@xmlParseVe
	mov	DWORD PTR [esi+212], 1
$LN314@xmlParseVe:
	mov	eax, edi
	pop	edi

; 10164: }

	pop	esi
	pop	ebp
	ret	0
_xmlParseVersionInfo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseVersionNum
_TEXT	SEGMENT
tv192 = -8						; size = 4
_len$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseVersionNum PROC				; COMDAT

; 10072: xmlParseVersionNum(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __B9AC27D5_parser@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, 10					; 0000000aH
	push	edi
	call	DWORD PTR _xmlMallocAtomic
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN4@xmlParseVe

; 10073:     xmlChar *buf = NULL;
; 10074:     int len = 0;
; 10075:     int size = 10;
; 10076:     xmlChar cur;
; 10077: 
; 10078:     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
; 10079:     if (buf == NULL) {
; 10080: 	xmlErrMemory(ctxt, NULL);

	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrMemory
	add	esp, 8

; 10081: 	return(NULL);

	xor	eax, eax
	pop	edi

; 10117: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlParseVe:
	push	ebx

; 10082:     }
; 10083:     cur = CUR;

	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ebx+36]
	mov	eax, DWORD PTR [eax+16]
	mov	cl, BYTE PTR [eax]

; 10084:     if (!((cur >= '0') && (cur <= '9'))) {

	lea	eax, DWORD PTR [ecx-48]
	cmp	al, 9
	ja	$LN6@xmlParseVe

; 10087:     }
; 10088:     buf[len++] = cur;
; 10089:     NEXT;

	push	ebx
	mov	BYTE PTR [esi], cl
	call	_xmlNextChar

; 10090:     cur=CUR;

	mov	eax, DWORD PTR [ebx+36]
	add	esp, 4
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax]

; 10091:     if (cur != '.') {

	cmp	al, 46					; 0000002eH
	jne	$LN6@xmlParseVe

; 10092: 	xmlFree(buf);
; 10093: 	return(NULL);
; 10094:     }
; 10095:     buf[len++] = cur;
; 10096:     NEXT;

	push	ebx
	mov	BYTE PTR [esi+1], al
	mov	DWORD PTR _len$1$[ebp], 2
	call	_xmlNextChar

; 10097:     cur=CUR;

	mov	eax, DWORD PTR [ebx+36]
	add	esp, 4
	mov	eax, DWORD PTR [eax+16]
	mov	bl, BYTE PTR [eax]

; 10098:     while ((cur >= '0') && (cur <= '9')) {

	cmp	bl, 48					; 00000030H
	jb	SHORT $LN16@xmlParseVe
	npad	3
$LL2@xmlParseVe:
	cmp	bl, 57					; 00000039H
	ja	SHORT $LN16@xmlParseVe

; 10099: 	if (len + 1 >= size) {

	mov	eax, DWORD PTR _len$1$[ebp]
	inc	eax
	mov	DWORD PTR tv192[ebp], eax
	cmp	eax, edi
	jl	SHORT $LN8@xmlParseVe

; 10100: 	    xmlChar *tmp;
; 10101: 
; 10102: 	    size *= 2;

	add	edi, edi

; 10103: 	    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));

	push	edi
	push	esi
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 10104: 	    if (tmp == NULL) {

	test	eax, eax
	je	SHORT $LN12@xmlParseVe

; 10107: 		return(NULL);
; 10108: 	    }
; 10109: 	    buf = tmp;

	mov	esi, eax
	mov	eax, DWORD PTR tv192[ebp]
$LN8@xmlParseVe:

; 10110: 	}
; 10111: 	buf[len++] = cur;

	mov	ecx, DWORD PTR _len$1$[ebp]
	mov	DWORD PTR _len$1$[ebp], eax
	mov	BYTE PTR [ecx+esi], bl

; 10112: 	NEXT;

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	ebx
	call	_xmlNextChar

; 10113: 	cur=CUR;

	mov	eax, DWORD PTR [ebx+36]
	add	esp, 4
	mov	eax, DWORD PTR [eax+16]
	mov	bl, BYTE PTR [eax]
	cmp	bl, 48					; 00000030H
	jae	SHORT $LL2@xmlParseVe
$LN16@xmlParseVe:

; 10114:     }
; 10115:     buf[len] = 0;

	mov	eax, DWORD PTR _len$1$[ebp]
	pop	ebx
	pop	edi
	mov	BYTE PTR [eax+esi], 0

; 10116:     return(buf);

	mov	eax, esi

; 10117: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlParseVe:

; 10105: 	        xmlFree(buf);

	push	esi
	call	DWORD PTR _xmlFree

; 10106: 		xmlErrMemory(ctxt, NULL);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	0
	push	ebx
	call	_xmlErrMemory
	add	esp, 12					; 0000000cH
	xor	eax, eax
	pop	ebx
	pop	edi

; 10117: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlParseVe:

; 10085: 	xmlFree(buf);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 10086: 	return(NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 10117: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseVersionNum ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseElement
_TEXT	SEGMENT
_node_info$ = -36					; size = 20
_tlen$ = -16						; size = 4
_prefix$ = -12						; size = 4
_URI$ = -8						; size = 4
_line$1$ = -4						; size = 4
_name$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseElement PROC					; COMDAT

; 9894 : xmlParseElement(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _xmlParserMaxDepth
	mov	DWORD PTR _prefix$[ebp], 0
	mov	DWORD PTR _URI$[ebp], 0
	mov	ebx, DWORD PTR [esi+328]
	mov	DWORD PTR _tlen$[ebp], 0
	cmp	DWORD PTR [esi+188], eax
	jbe	SHORT $LN5@xmlParseEl

; 9895 :     const xmlChar *name;
; 9896 :     const xmlChar *prefix = NULL;
; 9897 :     const xmlChar *URI = NULL;
; 9898 :     xmlParserNodeInfo node_info;
; 9899 :     int line, tlen = 0;
; 9900 :     xmlNodePtr ret;
; 9901 :     int nsNr = ctxt->nsNr;
; 9902 : 
; 9903 :     if (((unsigned int) ctxt->nameNr > xmlParserMaxDepth) &&

	test	DWORD PTR [esi+360], 524288		; 00080000H
	jne	SHORT $LN5@xmlParseEl

; 9904 :         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 9905 : 	xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,

	push	eax
	push	OFFSET ??_C@_0DL@HADOBDDE@Excessive?5depth?5in?5document?3?5?$CFd@
	push	1
	push	esi
	call	_xmlFatalErrMsgInt

; 9906 : 		 "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
; 9907 : 			  xmlParserMaxDepth);
; 9908 : 	xmlHaltParser(ctxt);

	push	esi
	call	_xmlHaltParser
	add	esp, 20					; 00000014H
	pop	esi

; 10056:     }
; 10057: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlParseEl:

; 9909 : 	return;
; 9910 :     }
; 9911 : 
; 9912 :     /* Capture start position */
; 9913 :     if (ctxt->record_info) {

	cmp	DWORD PTR [esi+68], 0
	je	SHORT $LN60@xmlParseEl

; 9914 :         node_info.begin_pos = ctxt->input->consumed +

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+36]
	sub	eax, DWORD PTR [ecx+12]
	add	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR _node_info$[ebp+4], eax

; 9915 :                           (CUR_PTR - ctxt->input->base);
; 9916 : 	node_info.begin_line = ctxt->input->line;

	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _node_info$[ebp+8], eax
$LN60@xmlParseEl:

; 9917 :     }
; 9918 : 
; 9919 :     if (ctxt->spaceNr == 0)

	cmp	DWORD PTR [esi+236], 0
	jne	SHORT $LN7@xmlParseEl

; 9920 : 	spacePush(ctxt, -1);

	or	eax, -1
	jmp	SHORT $LN9@xmlParseEl
$LN7@xmlParseEl:

; 9921 :     else if (*ctxt->space == -2)

	mov	eax, DWORD PTR [esi+232]
	or	ecx, -1
	mov	eax, DWORD PTR [eax]
	cmp	eax, -2					; fffffffeH
	cmove	eax, ecx
$LN9@xmlParseEl:

; 9922 : 	spacePush(ctxt, -1);
; 9923 :     else
; 9924 : 	spacePush(ctxt, *ctxt->space);
; 9925 : 
; 9926 :     line = ctxt->input->line;

	push	eax
	push	esi
	call	_spacePush
	mov	eax, DWORD PTR [esi+36]
	add	esp, 8

; 9927 : #ifdef LIBXML_SAX1_ENABLED
; 9928 :     if (ctxt->sax2)

	cmp	DWORD PTR [esi+324], 0
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR _line$1$[ebp], eax
	je	SHORT $LN11@xmlParseEl

; 9929 : #endif /* LIBXML_SAX1_ENABLED */
; 9930 :         name = xmlParseStartTag2(ctxt, &prefix, &URI, &tlen);

	lea	eax, DWORD PTR _tlen$[ebp]
	push	eax
	lea	eax, DWORD PTR _URI$[ebp]
	push	eax
	lea	eax, DWORD PTR _prefix$[ebp]
	push	eax
	push	esi
	call	_xmlParseStartTag2
	add	esp, 16					; 00000010H
	jmp	SHORT $LN62@xmlParseEl
$LN11@xmlParseEl:

; 9931 : #ifdef LIBXML_SAX1_ENABLED
; 9932 :     else
; 9933 : 	name = xmlParseStartTag(ctxt);

	push	esi
	call	_xmlParseStartTag
	add	esp, 4
$LN62@xmlParseEl:

; 9934 : #endif /* LIBXML_SAX1_ENABLED */
; 9935 :     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	mov	DWORD PTR _name$1$[ebp], eax
	je	$LN28@xmlParseEl

; 9936 : 	return;
; 9937 :     if (name == NULL) {

	test	eax, eax
	jne	SHORT $LN14@xmlParseEl

; 9938 : 	spacePop(ctxt);

	push	esi
	call	_spacePop
	add	esp, 4
	pop	esi

; 10056:     }
; 10057: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlParseEl:
	push	edi

; 9939 :         return;
; 9940 :     }
; 9941 :     namePush(ctxt, name);

	push	eax
	push	esi
	call	_namePush

; 9942 :     ret = ctxt->node;

	mov	edi, DWORD PTR [esi+52]
	add	esp, 8

; 9943 : 
; 9944 : #ifdef LIBXML_VALID_ENABLED
; 9945 :     /*
; 9946 :      * [ VC: Root Element Type ]
; 9947 :      * The Name in the document type declaration must match the element
; 9948 :      * type of the root element.
; 9949 :      */
; 9950 :     if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&
; 9951 :         ctxt->node && (ctxt->node == ctxt->myDoc->children))

	cmp	DWORD PTR [esi+104], 0
	je	SHORT $LN15@xmlParseEl
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN15@xmlParseEl
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN15@xmlParseEl
	test	edi, edi
	je	SHORT $LN15@xmlParseEl
	cmp	edi, DWORD PTR [eax+12]
	jne	SHORT $LN15@xmlParseEl

; 9952 :         ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);

	push	eax
	lea	eax, DWORD PTR [esi+108]
	push	eax
	call	_xmlValidateRoot
	add	esp, 8
	and	DWORD PTR [esi+100], eax
$LN15@xmlParseEl:

; 9953 : #endif /* LIBXML_VALID_ENABLED */
; 9954 : 
; 9955 :     /*
; 9956 :      * Check for an Empty Element.
; 9957 :      */
; 9958 :     if ((RAW == '/') && (NXT(1) == '>')) {

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	dl, BYTE PTR [ecx]
	cmp	dl, 47					; 0000002fH
	jne	$LN16@xmlParseEl
	cmp	BYTE PTR [ecx+1], 62			; 0000003eH
	jne	$LN16@xmlParseEl

; 9959 :         SKIP(2);

	add	DWORD PTR [esi+200], 2
	add	DWORD PTR [eax+16], 2
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 2
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseEl
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseEl:

; 9960 : 	if (ctxt->sax2) {

	mov	eax, DWORD PTR [esi]

; 9961 : 	    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&

	test	eax, eax
	je	SHORT $LN21@xmlParseEl

; 9960 : 	if (ctxt->sax2) {

	cmp	DWORD PTR [esi+324], 0
	je	SHORT $LN18@xmlParseEl

; 9961 : 	    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&

	mov	eax, DWORD PTR [eax+120]
	test	eax, eax
	je	SHORT $LN21@xmlParseEl
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN21@xmlParseEl

; 9962 : 		(!ctxt->disableSAX))
; 9963 : 		ctxt->sax->endElementNs(ctxt->userData, name, prefix, URI);

	push	DWORD PTR _URI$[ebp]
	push	DWORD PTR _prefix$[ebp]
	push	DWORD PTR _name$1$[ebp]
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 16					; 00000010H

; 9969 : #endif /* LIBXML_SAX1_ENABLED */
; 9970 : 	}
; 9971 : 	namePop(ctxt);

	push	esi
	call	_namePop

; 9972 : 	spacePop(ctxt);

	push	esi
	call	_spacePop
	add	esp, 8

; 9973 : 	if (nsNr != ctxt->nsNr)
; 9974 : 	    nsPop(ctxt, ctxt->nsNr - nsNr);
; 9975 : 	if ( ret != NULL && ctxt->record_info ) {
; 9976 : 	   node_info.end_pos = ctxt->input->consumed +
; 9977 : 			      (CUR_PTR - ctxt->input->base);
; 9978 : 	   node_info.end_line = ctxt->input->line;
; 9979 : 	   node_info.node = ret;
; 9980 : 	   xmlParserAddNodeInfo(ctxt, &node_info);
; 9981 : 	}
; 9982 : 	return;

	jmp	$LN67@xmlParseEl
$LN18@xmlParseEl:

; 9964 : #ifdef LIBXML_SAX1_ENABLED
; 9965 : 	} else {
; 9966 : 	    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL) &&

	mov	eax, DWORD PTR [eax+60]
	test	eax, eax
	je	SHORT $LN21@xmlParseEl
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN21@xmlParseEl

; 9967 : 		(!ctxt->disableSAX))
; 9968 : 		ctxt->sax->endElement(ctxt->userData, name);

	push	DWORD PTR _name$1$[ebp]
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 8
$LN21@xmlParseEl:

; 9969 : #endif /* LIBXML_SAX1_ENABLED */
; 9970 : 	}
; 9971 : 	namePop(ctxt);

	push	esi
	call	_namePop

; 9972 : 	spacePop(ctxt);

	push	esi
	call	_spacePop
	add	esp, 8

; 9973 : 	if (nsNr != ctxt->nsNr)
; 9974 : 	    nsPop(ctxt, ctxt->nsNr - nsNr);
; 9975 : 	if ( ret != NULL && ctxt->record_info ) {
; 9976 : 	   node_info.end_pos = ctxt->input->consumed +
; 9977 : 			      (CUR_PTR - ctxt->input->base);
; 9978 : 	   node_info.end_line = ctxt->input->line;
; 9979 : 	   node_info.node = ret;
; 9980 : 	   xmlParserAddNodeInfo(ctxt, &node_info);
; 9981 : 	}
; 9982 : 	return;

	jmp	$LN67@xmlParseEl
$LN16@xmlParseEl:

; 9983 :     }
; 9984 :     if (RAW == '>') {

	cmp	dl, 62					; 0000003eH
	jne	$LN24@xmlParseEl

; 9985 :         NEXT1;

	inc	DWORD PTR [eax+32]
	mov	eax, DWORD PTR [esi+36]
	inc	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [esi+36]
	inc	DWORD PTR [esi+200]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN26@xmlParseEl
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN26@xmlParseEl:

; 10009: 	}
; 10010: 	return;
; 10011:     }
; 10012: 
; 10013:     /*
; 10014:      * Parse the content of the element:
; 10015:      */
; 10016:     xmlParseContent(ctxt);

	push	esi
	call	_xmlParseContent
	add	esp, 4

; 10017:     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	$LN61@xmlParseEl

; 10018: 	return;
; 10019:     if (!IS_BYTE_CHAR(RAW)) {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 9
	jb	SHORT $LN31@xmlParseEl
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN30@xmlParseEl
$LN31@xmlParseEl:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN30@xmlParseEl
	cmp	al, 32					; 00000020H
	jae	SHORT $LN30@xmlParseEl

; 10020:         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,

	push	0
	push	DWORD PTR _line$1$[ebp]
	push	DWORD PTR _name$1$[ebp]
	push	OFFSET ??_C@_0CJ@JPBGMEM@Premature?5end?5of?5data?5in?5tag?5?$CFs@
	push	77					; 0000004dH
	push	esi
	call	_xmlFatalErrMsgStrIntStr

; 10021: 	 "Premature end of data in tag %s line %d\n",
; 10022: 		                name, line, NULL);
; 10023: 
; 10024: 	/*
; 10025: 	 * end of parsing of this node.
; 10026: 	 */
; 10027: 	nodePop(ctxt);

	push	esi
	call	_nodePop

; 10028: 	namePop(ctxt);

	push	esi
	call	_namePop

; 10029: 	spacePop(ctxt);

	push	esi
	call	_spacePop

; 10030: 	if (nsNr != ctxt->nsNr)

	mov	eax, DWORD PTR [esi+328]
	add	esp, 36					; 00000024H
	cmp	ebx, eax
	je	$LN61@xmlParseEl

; 10031: 	    nsPop(ctxt, ctxt->nsNr - nsNr);

	sub	eax, ebx
	push	eax
	push	esi
	call	_nsPop
	add	esp, 8
	pop	edi
	pop	esi

; 10056:     }
; 10057: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@xmlParseEl:

; 10032: 	return;
; 10033:     }
; 10034: 
; 10035:     /*
; 10036:      * parse the end of tag: '</' should be here.
; 10037:      */
; 10038:     if (ctxt->sax2) {

	cmp	DWORD PTR [esi+324], 0
	je	SHORT $LN33@xmlParseEl

; 10039: 	xmlParseEndTag2(ctxt, prefix, URI, line, ctxt->nsNr - nsNr, tlen);

	push	DWORD PTR _tlen$[ebp]
	mov	eax, DWORD PTR [esi+328]
	sub	eax, ebx
	push	eax
	push	DWORD PTR _line$1$[ebp]
	push	DWORD PTR _URI$[ebp]
	push	DWORD PTR _prefix$[ebp]
	push	esi
	call	_xmlParseEndTag2

; 10040: 	namePop(ctxt);

	push	esi
	call	_namePop
	add	esp, 28					; 0000001cH

; 10041:     }

	jmp	SHORT $LN27@xmlParseEl
$LN33@xmlParseEl:

; 10042: #ifdef LIBXML_SAX1_ENABLED
; 10043:       else
; 10044: 	xmlParseEndTag1(ctxt, line);

	push	DWORD PTR _line$1$[ebp]
	push	esi
	call	_xmlParseEndTag1

; 10045: #endif /* LIBXML_SAX1_ENABLED */
; 10046: 
; 10047:     /*
; 10048:      * Capture end position and add node
; 10049:      */
; 10050:     if ( ret != NULL && ctxt->record_info ) {
; 10051:        node_info.end_pos = ctxt->input->consumed +
; 10052:                           (CUR_PTR - ctxt->input->base);
; 10053:        node_info.end_line = ctxt->input->line;
; 10054:        node_info.node = ret;
; 10055:        xmlParserAddNodeInfo(ctxt, &node_info);

	jmp	SHORT $LN69@xmlParseEl
$LN24@xmlParseEl:

; 9986 :     } else {
; 9987 :         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,

	push	0
	push	DWORD PTR _line$1$[ebp]
	push	DWORD PTR _name$1$[ebp]
	push	OFFSET ??_C@_0CL@LKDFGLKB@Couldn?8t?5find?5end?5of?5Start?5Tag?5@
	push	73					; 00000049H
	push	esi
	call	_xmlFatalErrMsgStrIntStr

; 9988 : 		     "Couldn't find end of Start Tag %s line %d\n",
; 9989 : 		                name, line, NULL);
; 9990 : 
; 9991 : 	/*
; 9992 : 	 * end of parsing of this node.
; 9993 : 	 */
; 9994 : 	nodePop(ctxt);

	push	esi
	call	_nodePop

; 9995 : 	namePop(ctxt);

	push	esi
	call	_namePop

; 9996 : 	spacePop(ctxt);

	push	esi
	call	_spacePop
	add	esp, 36					; 00000024H
$LN67@xmlParseEl:

; 9997 : 	if (nsNr != ctxt->nsNr)
; 9998 : 	    nsPop(ctxt, ctxt->nsNr - nsNr);
; 9999 : 
; 10000: 	/*
; 10001: 	 * Capture end position and add node
; 10002: 	 */
; 10003: 	if ( ret != NULL && ctxt->record_info ) {

	mov	eax, DWORD PTR [esi+328]
	cmp	ebx, eax
	je	SHORT $LN27@xmlParseEl
	sub	eax, ebx
	push	eax
	push	esi
	call	_nsPop
$LN69@xmlParseEl:
	add	esp, 8
$LN27@xmlParseEl:
	test	edi, edi
	je	SHORT $LN61@xmlParseEl
	cmp	DWORD PTR [esi+68], 0
	je	SHORT $LN61@xmlParseEl

; 10004: 	   node_info.end_pos = ctxt->input->consumed +

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+36]
	sub	eax, DWORD PTR [ecx+12]
	add	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR _node_info$[ebp+12], eax

; 10005: 			      (CUR_PTR - ctxt->input->base);
; 10006: 	   node_info.end_line = ctxt->input->line;

	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _node_info$[ebp+16], eax

; 10007: 	   node_info.node = ret;
; 10008: 	   xmlParserAddNodeInfo(ctxt, &node_info);

	lea	eax, DWORD PTR _node_info$[ebp]
	push	eax
	push	esi
	mov	DWORD PTR _node_info$[ebp], edi
	call	_xmlParserAddNodeInfo
	add	esp, 8
$LN61@xmlParseEl:
	pop	edi
$LN28@xmlParseEl:
	pop	esi

; 10056:     }
; 10057: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseContent
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlParseContent PROC					; COMDAT

; 9811 : xmlParseContent(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN23@xmlParseCo

; 9812 :     GROW;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN23@xmlParseCo
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN23@xmlParseCo:

; 9813 :     while ((RAW != 0) &&
; 9814 : 	   ((RAW != '<') || (NXT(1) != '/')) &&

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	je	$LN35@xmlParseCo
	push	ebx
	push	edi
$LL2@xmlParseCo:
	mov	edi, DWORD PTR [ecx+16]
	mov	al, BYTE PTR [edi]
	cmp	al, 60					; 0000003cH
	jne	SHORT $LN33@xmlParseCo
	cmp	BYTE PTR [edi+1], 47			; 0000002fH
	je	$LN36@xmlParseCo
$LN33@xmlParseCo:
	cmp	DWORD PTR [esi+172], -1
	je	$LN36@xmlParseCo

; 9815 : 	   (ctxt->instate != XML_PARSER_EOF)) {
; 9816 : 	const xmlChar *test = CUR_PTR;
; 9817 : 	unsigned int cons = ctxt->input->consumed;

	mov	ebx, DWORD PTR [ecx+36]

; 9818 : 	const xmlChar *cur = ctxt->input->cur;
; 9819 : 
; 9820 : 	/*
; 9821 : 	 * First case : a Processing Instruction.
; 9822 : 	 */
; 9823 : 	if ((*cur == '<') && (cur[1] == '?')) {

	cmp	al, 60					; 0000003cH
	jne	SHORT $LN12@xmlParseCo
	mov	al, BYTE PTR [edi+1]
	cmp	al, 63					; 0000003fH
	jne	SHORT $LN27@xmlParseCo

; 9824 : 	    xmlParsePI(ctxt);

	push	esi
	call	_xmlParsePI
	add	esp, 4

; 9825 : 	}

	jmp	$LN15@xmlParseCo
$LN27@xmlParseCo:

; 9826 : 
; 9827 : 	/*
; 9828 : 	 * Second case : a CDSection
; 9829 : 	 */
; 9830 : 	/* 2.6.0 test was *cur not RAW */
; 9831 : 	else if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {

	cmp	al, 33					; 00000021H
	jne	SHORT $LN31@xmlParseCo
	cmp	BYTE PTR [edi+2], 91			; 0000005bH
	jne	SHORT $LN30@xmlParseCo
	cmp	BYTE PTR [edi+3], 67			; 00000043H
	jne	SHORT $LN30@xmlParseCo
	cmp	BYTE PTR [edi+4], 68			; 00000044H
	jne	SHORT $LN30@xmlParseCo
	cmp	BYTE PTR [edi+5], 65			; 00000041H
	jne	SHORT $LN30@xmlParseCo
	cmp	BYTE PTR [edi+6], 84			; 00000054H
	jne	SHORT $LN30@xmlParseCo
	cmp	BYTE PTR [edi+7], 65			; 00000041H
	jne	SHORT $LN30@xmlParseCo
	cmp	BYTE PTR [edi+8], 91			; 0000005bH
	jne	SHORT $LN30@xmlParseCo

; 9832 : 	    xmlParseCDSect(ctxt);

	push	esi
	call	_xmlParseCDSect
	add	esp, 4

; 9833 : 	}

	jmp	SHORT $LN15@xmlParseCo
$LN30@xmlParseCo:

; 9834 : 
; 9835 : 	/*
; 9836 : 	 * Third case :  a comment
; 9837 : 	 */
; 9838 : 	else if ((*cur == '<') && (NXT(1) == '!') &&
; 9839 : 		 (NXT(2) == '-') && (NXT(3) == '-')) {

	cmp	al, 33					; 00000021H
	jne	SHORT $LN31@xmlParseCo
	cmp	BYTE PTR [edi+2], 45			; 0000002dH
	jne	SHORT $LN31@xmlParseCo
	cmp	BYTE PTR [edi+3], 45			; 0000002dH
	jne	SHORT $LN31@xmlParseCo

; 9840 : 	    xmlParseComment(ctxt);

	push	esi
	call	_xmlParseComment
	add	esp, 4

; 9841 : 	    ctxt->instate = XML_PARSER_CONTENT;

	mov	DWORD PTR [esi+172], 7

; 9842 : 	}

	jmp	SHORT $LN15@xmlParseCo
$LN31@xmlParseCo:

; 9843 : 
; 9844 : 	/*
; 9845 : 	 * Fourth case :  a sub-element.
; 9846 : 	 */
; 9847 : 	else if (*cur == '<') {
; 9848 : 	    xmlParseElement(ctxt);

	push	esi
	call	_xmlParseElement
	add	esp, 4

; 9849 : 	}

	jmp	SHORT $LN15@xmlParseCo
$LN12@xmlParseCo:

; 9850 : 
; 9851 : 	/*
; 9852 : 	 * Fifth case : a reference. If if has not been resolved,
; 9853 : 	 *    parsing returns it's Name, create the node
; 9854 : 	 */
; 9855 : 
; 9856 : 	else if (*cur == '&') {

	cmp	al, 38					; 00000026H
	jne	SHORT $LN14@xmlParseCo

; 9857 : 	    xmlParseReference(ctxt);

	push	esi
	call	_xmlParseReference
	add	esp, 4

; 9858 : 	}

	jmp	SHORT $LN15@xmlParseCo
$LN14@xmlParseCo:

; 9859 : 
; 9860 : 	/*
; 9861 : 	 * Last case, text. Note that References are handled directly.
; 9862 : 	 */
; 9863 : 	else {
; 9864 : 	    xmlParseCharData(ctxt, 0);

	push	0
	push	esi
	call	_xmlParseCharData
	add	esp, 8
$LN15@xmlParseCo:

; 9865 : 	}
; 9866 : 
; 9867 : 	GROW;

	mov	eax, DWORD PTR [esi+292]
	test	eax, eax
	jne	SHORT $LN21@xmlParseCo
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [ecx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN32@xmlParseCo
	push	esi
	call	_xmlGROW
	mov	eax, DWORD PTR [esi+292]
	add	esp, 4

; 9868 : 	SHRINK;

	test	eax, eax
	jne	SHORT $LN21@xmlParseCo
	mov	ecx, DWORD PTR [esi+36]
$LN32@xmlParseCo:
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN21@xmlParseCo
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN21@xmlParseCo

; 2070 :     xmlParserInputShrink(ctxt->input);

	push	ecx
	call	_xmlParserInputShrink

; 2071 :     if (*ctxt->input->cur == 0)

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN21@xmlParseCo

; 2072 :         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN21@xmlParseCo:

; 9869 : 
; 9870 : 	if ((cons == ctxt->input->consumed) && (test == CUR_PTR)) {

	mov	ecx, DWORD PTR [esi+36]
	cmp	ebx, DWORD PTR [ecx+36]
	jne	SHORT $LN34@xmlParseCo
	cmp	edi, DWORD PTR [ecx+16]
	je	SHORT $LN24@xmlParseCo
$LN34@xmlParseCo:

; 9813 :     while ((RAW != 0) &&
; 9814 : 	   ((RAW != '<') || (NXT(1) != '/')) &&

	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	$LL2@xmlParseCo
	pop	edi
	pop	ebx
	pop	esi

; 9874 :             break;
; 9875 : 	}
; 9876 :     }
; 9877 : }

	pop	ebp
	ret	0
$LN24@xmlParseCo:

; 9871 : 	    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CG@FCFCBOFE@detected?5an?5error?5in?5element?5co@
	push	1
	push	esi
	call	_xmlFatalErr

; 9872 : 	                "detected an error in element content\n");
; 9873 : 	    xmlHaltParser(ctxt);

	push	esi
	call	_xmlHaltParser
	add	esp, 16					; 00000010H
$LN36@xmlParseCo:
	pop	edi
	pop	ebx
$LN35@xmlParseCo:
	pop	esi

; 9874 :             break;
; 9875 : 	}
; 9876 :     }
; 9877 : }

	pop	ebp
	ret	0
_xmlParseContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseCDSect
_TEXT	SEGMENT
_count$1$ = -28						; size = 4
_sl$ = -24						; size = 4
_s$1$ = -20						; size = 4
_rl$ = -16						; size = 4
_size$1$ = -12						; size = 4
_l$ = -8						; size = 4
_len$1$ = -4						; size = 4
_buf$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseCDSect PROC					; COMDAT

; 9705 : xmlParseCDSect(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	mov	DWORD PTR _count$1$[ebp], eax
	xor	ebx, ebx
	mov	DWORD PTR _len$1$[ebp], ebx
	mov	DWORD PTR _size$1$[ebp], 100		; 00000064H
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 60			; 0000003cH
	jne	$LN19@xmlParseCD

; 9706 :     xmlChar *buf = NULL;
; 9707 :     int len = 0;
; 9708 :     int size = XML_PARSER_BUFFER_SIZE;
; 9709 :     int r, rl;
; 9710 :     int	s, sl;
; 9711 :     int cur, l;
; 9712 :     int count = 0;
; 9713 : 
; 9714 :     /* Check 2.6.0 was NXT(0) not RAW */
; 9715 :     if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {

	cmp	BYTE PTR [eax+1], 33			; 00000021H
	jne	$LN19@xmlParseCD
	cmp	BYTE PTR [eax+2], 91			; 0000005bH
	jne	$LN19@xmlParseCD
	cmp	BYTE PTR [eax+3], 67			; 00000043H
	jne	$LN19@xmlParseCD
	cmp	BYTE PTR [eax+4], 68			; 00000044H
	jne	$LN19@xmlParseCD
	cmp	BYTE PTR [eax+5], 65			; 00000041H
	jne	$LN19@xmlParseCD
	cmp	BYTE PTR [eax+6], 84			; 00000054H
	jne	$LN19@xmlParseCD
	cmp	BYTE PTR [eax+7], 65			; 00000041H
	jne	$LN19@xmlParseCD
	cmp	BYTE PTR [eax+8], 91			; 0000005bH
	jne	$LN19@xmlParseCD

; 9716 : 	SKIP(9);

	add	DWORD PTR [esi+200], 9
	add	DWORD PTR [ecx+16], 9
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 9
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], bl
	jne	SHORT $LN2@xmlParseCD
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseCD:

; 9717 :     } else
; 9718 :         return;
; 9719 : 
; 9720 :     ctxt->instate = XML_PARSER_CDATA_SECTION;
; 9721 :     r = CUR_CHAR(rl);

	lea	eax, DWORD PTR _rl$[ebp]
	mov	DWORD PTR [esi+172], 8
	push	eax
	push	esi
	call	_xmlCurrentChar
	mov	ebx, eax
	add	esp, 8

; 9722 :     if (!IS_CHAR(r)) {

	cmp	ebx, 256				; 00000100H
	jge	SHORT $LN223@xmlParseCD
	cmp	ebx, 9
	jl	SHORT $LN48@xmlParseCD
	cmp	ebx, 10					; 0000000aH
	jle	SHORT $LN7@xmlParseCD
$LN48@xmlParseCD:
	cmp	ebx, 13					; 0000000dH
	je	SHORT $LN7@xmlParseCD
	cmp	ebx, 32					; 00000020H
	jge	SHORT $LN7@xmlParseCD
	jmp	$LN63@xmlParseCD
$LN223@xmlParseCD:
	cmp	ebx, 55295				; 0000d7ffH
	jle	SHORT $LN7@xmlParseCD
	cmp	ebx, 57344				; 0000e000H
	jl	SHORT $LN51@xmlParseCD
	cmp	ebx, 65533				; 0000fffdH
	jle	SHORT $LN7@xmlParseCD
$LN51@xmlParseCD:
	cmp	ebx, 65536				; 00010000H
	jl	$LN63@xmlParseCD
	cmp	ebx, 1114111				; 0010ffffH
	jg	$LN63@xmlParseCD
$LN7@xmlParseCD:

; 9723 : 	xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);
; 9724 : 	ctxt->instate = XML_PARSER_CONTENT;
; 9725 :         return;
; 9726 :     }
; 9727 :     NEXTL(rl);

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN23@xmlParseCD
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN24@xmlParseCD
$LN23@xmlParseCD:
	inc	DWORD PTR [ecx+32]
$LN24@xmlParseCD:
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _rl$[ebp]
	add	DWORD PTR [ecx+16], eax

; 9728 :     s = CUR_CHAR(sl);

	lea	eax, DWORD PTR _sl$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _s$1$[ebp], eax

; 9729 :     if (!IS_CHAR(s)) {

	cmp	eax, 256				; 00000100H
	jge	SHORT $LN66@xmlParseCD
	cmp	eax, 9
	jl	SHORT $LN58@xmlParseCD
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN10@xmlParseCD
$LN58@xmlParseCD:
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN10@xmlParseCD
	cmp	eax, 32					; 00000020H
	jl	SHORT $LN63@xmlParseCD
$LN10@xmlParseCD:

; 9732 :         return;
; 9733 :     }
; 9734 :     NEXTL(sl);

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	$LN26@xmlParseCD
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	$LN27@xmlParseCD
$LN66@xmlParseCD:

; 9729 :     if (!IS_CHAR(s)) {

	cmp	eax, 55295				; 0000d7ffH
	jle	SHORT $LN10@xmlParseCD
	cmp	eax, 57344				; 0000e000H
	jl	SHORT $LN61@xmlParseCD
	cmp	eax, 65533				; 0000fffdH
	jle	SHORT $LN10@xmlParseCD
$LN61@xmlParseCD:
	add	eax, -65536				; ffff0000H
	cmp	eax, 1048575				; 000fffffH
	jbe	SHORT $LN10@xmlParseCD
$LN63@xmlParseCD:

; 9730 : 	xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);
; 9731 : 	ctxt->instate = XML_PARSER_CONTENT;

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN149@xmlParseCD
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN212@xmlParseCD
$LN149@xmlParseCD:
	push	OFFSET ??_C@_0BL@COECCIID@Unregistered?5error?5message@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	63					; 0000003fH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 63			; 0000003fH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	mov	DWORD PTR [esi+12], 0
	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN212@xmlParseCD
	mov	DWORD PTR [esi+212], 1
$LN212@xmlParseCD:
	mov	DWORD PTR [esi+172], 7
	pop	esi

; 9799 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlParseCD:

; 9732 :         return;
; 9733 :     }
; 9734 :     NEXTL(sl);

	inc	DWORD PTR [ecx+32]
$LN27@xmlParseCD:
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _sl$[ebp]
	push	edi
	add	DWORD PTR [ecx+16], eax

; 9735 :     cur = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar

; 9736 :     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	push	100					; 00000064H
	mov	edi, eax
	call	DWORD PTR _xmlMallocAtomic
	mov	edx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buf$1$[ebp], edx

; 9737 :     if (buf == NULL) {

	test	edx, edx
	jne	SHORT $LL11@xmlParseCD

; 9738 : 	xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory
	add	esp, 8
	pop	edi
	pop	esi

; 9799 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	4
$LL11@xmlParseCD:

; 9739 : 	return;
; 9740 :     }
; 9741 :     while (IS_CHAR(cur) &&

	cmp	edi, 256				; 00000100H
	jge	SHORT $LN76@xmlParseCD
	cmp	edi, 9
	jl	SHORT $LN68@xmlParseCD
	cmp	edi, 10					; 0000000aH
	jle	SHORT $LN72@xmlParseCD
$LN68@xmlParseCD:
	cmp	edi, 13					; 0000000dH
	je	SHORT $LN72@xmlParseCD
	cmp	edi, 32					; 00000020H
	jge	SHORT $LN72@xmlParseCD
$LN12@xmlParseCD:

; 9779 :     buf[len] = 0;

	mov	ebx, DWORD PTR _len$1$[ebp]
	mov	BYTE PTR [ebx+edx], 0

; 9780 :     ctxt->instate = XML_PARSER_CONTENT;

	mov	DWORD PTR [esi+172], 7

; 9781 :     if (cur != '>') {

	cmp	edi, 62					; 0000003eH
	je	$LN18@xmlParseCD

; 9782 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,

	push	edx
	push	OFFSET ??_C@_0CC@HAEHMHLE@CData?5section?5not?5finished?6?$CF?450@
	push	63					; 0000003fH
	push	esi
	call	_xmlFatalErrMsgStr

; 9783 : 	                     "CData section not finished\n%.50s\n", buf);
; 9784 : 	xmlFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi

; 9799 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN76@xmlParseCD:

; 9739 : 	return;
; 9740 :     }
; 9741 :     while (IS_CHAR(cur) &&

	cmp	edi, 55295				; 0000d7ffH
	jle	SHORT $LN72@xmlParseCD
	cmp	edi, 57344				; 0000e000H
	jl	SHORT $LN71@xmlParseCD
	cmp	edi, 65533				; 0000fffdH
	jle	SHORT $LN72@xmlParseCD
$LN71@xmlParseCD:
	lea	eax, DWORD PTR [edi-65536]
	cmp	eax, 1048575				; 000fffffH
	ja	SHORT $LN12@xmlParseCD
$LN72@xmlParseCD:
	cmp	ebx, 93					; 0000005dH
	jne	SHORT $LN29@xmlParseCD
	cmp	DWORD PTR _s$1$[ebp], ebx
	jne	SHORT $LN29@xmlParseCD
	cmp	edi, 62					; 0000003eH
	je	SHORT $LN12@xmlParseCD
$LN29@xmlParseCD:

; 9742 :            ((r != ']') || (s != ']') || (cur != '>'))) {
; 9743 : 	if (len + 5 >= size) {

	mov	ecx, DWORD PTR _len$1$[ebp]
	lea	eax, DWORD PTR [ecx+5]
	cmp	eax, DWORD PTR _size$1$[ebp]
	jl	SHORT $LN30@xmlParseCD

; 9744 : 	    xmlChar *tmp;
; 9745 : 
; 9746 :             if ((size > XML_MAX_TEXT_LENGTH) &&

	mov	eax, DWORD PTR _size$1$[ebp]
	cmp	eax, 10000000				; 00989680H
	jle	SHORT $LN31@xmlParseCD
	test	DWORD PTR [esi+360], 524288		; 00080000H
	je	$LN215@xmlParseCD
$LN31@xmlParseCD:

; 9751 :                 return;
; 9752 :             }
; 9753 : 	    tmp = (xmlChar *) xmlRealloc(buf, size * 2 * sizeof(xmlChar));

	add	eax, eax
	push	eax
	push	edx
	mov	DWORD PTR _size$1$[ebp], eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 9754 : 	    if (tmp == NULL) {

	test	eax, eax
	je	$LN216@xmlParseCD

; 9757 : 		return;
; 9758 : 	    }
; 9759 : 	    buf = tmp;

	mov	ecx, DWORD PTR _len$1$[ebp]
	mov	edx, eax
	mov	DWORD PTR _buf$1$[ebp], edx
$LN30@xmlParseCD:

; 9760 : 	    size *= 2;
; 9761 : 	}
; 9762 : 	COPY_BUF(rl,buf,len,r);

	cmp	DWORD PTR _rl$[ebp], 1
	lea	eax, DWORD PTR [ecx+edx]
	jne	SHORT $LN33@xmlParseCD
	inc	ecx
	mov	BYTE PTR [eax], bl
	mov	DWORD PTR _len$1$[ebp], ecx
	jmp	SHORT $LN34@xmlParseCD
$LN33@xmlParseCD:
	push	ebx
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	DWORD PTR _len$1$[ebp], eax
$LN34@xmlParseCD:

; 9763 : 	r = s;
; 9764 : 	rl = sl;
; 9765 : 	s = cur;
; 9766 : 	sl = l;
; 9767 : 	count++;

	mov	edx, DWORD PTR _count$1$[ebp]
	mov	eax, DWORD PTR _sl$[ebp]
	inc	edx
	mov	ebx, DWORD PTR _s$1$[ebp]
	mov	DWORD PTR _rl$[ebp], eax
	mov	eax, DWORD PTR _l$[ebp]
	mov	DWORD PTR _s$1$[ebp], edi
	mov	DWORD PTR _sl$[ebp], eax
	mov	DWORD PTR _count$1$[ebp], edx

; 9768 : 	if (count > 50) {

	cmp	edx, 50					; 00000032H
	jle	SHORT $LN15@xmlParseCD

; 9769 : 	    GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN36@xmlParseCD
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN36@xmlParseCD
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN36@xmlParseCD:

; 9770 :             if (ctxt->instate == XML_PARSER_EOF) {

	cmp	DWORD PTR [esi+172], -1
	je	$LN217@xmlParseCD

; 9772 : 		return;
; 9773 :             }
; 9774 : 	    count = 0;

	xor	eax, eax
	mov	DWORD PTR _count$1$[ebp], eax
$LN15@xmlParseCD:

; 9775 : 	}
; 9776 : 	NEXTL(l);

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN38@xmlParseCD
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN39@xmlParseCD
$LN38@xmlParseCD:
	inc	DWORD PTR [ecx+32]
$LN39@xmlParseCD:
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax

; 9777 : 	cur = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar

; 9778 :     }

	mov	edx, DWORD PTR _buf$1$[ebp]
	add	esp, 8
	mov	edi, eax
	jmp	$LL11@xmlParseCD
$LN18@xmlParseCD:

; 9785 :         return;
; 9786 :     }
; 9787 :     NEXTL(l);

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN41@xmlParseCD
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN42@xmlParseCD
$LN41@xmlParseCD:
	inc	DWORD PTR [ecx+32]
$LN42@xmlParseCD:
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax

; 9788 : 
; 9789 :     /*
; 9790 :      * OK the buffer is to be consumed as cdata.
; 9791 :      */
; 9792 :     if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN46@xmlParseCD
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN46@xmlParseCD

; 9793 : 	if (ctxt->sax->cdataBlock != NULL)

	mov	ecx, DWORD PTR [eax+100]
	test	ecx, ecx
	je	SHORT $LN44@xmlParseCD

; 9794 : 	    ctxt->sax->cdataBlock(ctxt->userData, buf, len);

	push	ebx
	push	edx
	push	DWORD PTR [esi+4]
	call	ecx

; 9797 :     }
; 9798 :     xmlFree(buf);

	mov	edx, DWORD PTR _buf$1$[ebp]
	add	esp, 12					; 0000000cH
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
	pop	esi

; 9799 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@xmlParseCD:

; 9795 : 	else if (ctxt->sax->characters != NULL)

	mov	eax, DWORD PTR [eax+68]
	test	eax, eax
	je	SHORT $LN46@xmlParseCD

; 9796 : 	    ctxt->sax->characters(ctxt->userData, buf, len);

	push	ebx
	push	edx
	push	DWORD PTR [esi+4]
	call	eax

; 9797 :     }
; 9798 :     xmlFree(buf);

	mov	edx, DWORD PTR _buf$1$[ebp]
	add	esp, 12					; 0000000cH
$LN46@xmlParseCD:
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
	pop	esi

; 9799 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN215@xmlParseCD:

; 9747 :                 ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 9748 :                 xmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,

	push	0
	push	OFFSET ??_C@_0BM@HGOGNNNB@CData?5section?5too?5big?5found@
	push	63					; 0000003fH
	push	esi
	call	_xmlFatalErrMsgStr

; 9749 :                              "CData section too big found", NULL);
; 9750 :                 xmlFree (buf);

	push	DWORD PTR _buf$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi

; 9799 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN216@xmlParseCD:

; 9755 : 	        xmlFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	DWORD PTR _xmlFree

; 9756 : 		xmlErrMemory(ctxt, NULL);

	push	0
	push	esi
	call	_xmlErrMemory
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 9799 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN217@xmlParseCD:

; 9771 : 		xmlFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
$LN19@xmlParseCD:

; 9799 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseCDSect ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEndTag
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlParseEndTag PROC					; COMDAT

; 8643 : xmlParseEndTag(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlParseEndTag1
	add	esp, 8

; 8644 :     xmlParseEndTag1(ctxt, 0);
; 8645 : }

	pop	ebp
	ret	0
_xmlParseEndTag ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseStartTag
_TEXT	SEGMENT
_q$1$ = -28						; size = 4
_cons$1$ = -24						; size = 4
_attvalue$ = -20					; size = 4
_name$1$ = -16						; size = 4
_maxatts$1$ = -12					; size = 4
_attname$1$ = -8					; size = 4
_atts$1$ = -4						; size = 4
_nbatts$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseStartTag PROC					; COMDAT

; 8439 : xmlParseStartTag(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	mov	DWORD PTR _nbatts$1$[ebp], edi
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [esi+304]
	mov	ebx, DWORD PTR [esi+300]
	mov	DWORD PTR _maxatts$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR _atts$1$[ebp], ebx
	cmp	BYTE PTR [eax], 60			; 0000003cH
	jne	SHORT $LN67@xmlParseSt

; 8440 :     const xmlChar *name;
; 8441 :     const xmlChar *attname;
; 8442 :     xmlChar *attvalue;
; 8443 :     const xmlChar **atts = ctxt->atts;
; 8444 :     int nbatts = 0;
; 8445 :     int maxatts = ctxt->maxatts;
; 8446 :     int i;
; 8447 : 
; 8448 :     if (RAW != '<') return(NULL);
; 8449 :     NEXT1;

	inc	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [esi+36]
	inc	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [esi+36]
	inc	DWORD PTR [esi+200]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN11@xmlParseSt
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN11@xmlParseSt:

; 8450 : 
; 8451 :     name = xmlParseName(ctxt);

	push	esi
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _name$1$[ebp], eax

; 8452 :     if (name == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlParseSt

; 8453 : 	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0CI@FEOPKDBB@xmlParseStartTag?3?5invalid?5eleme@
	push	68					; 00000044H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN67@xmlParseSt:

; 8563 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlParseSt:

; 8454 : 	     "xmlParseStartTag: invalid element name\n");
; 8455 :         return(NULL);
; 8456 :     }
; 8457 : 
; 8458 :     /*
; 8459 :      * Now parse the attributes, it ends up with the ending
; 8460 :      *
; 8461 :      * (S Attribute)* S?
; 8462 :      */
; 8463 :     SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4

; 8464 :     GROW;

	cmp	DWORD PTR [esi+292], edi
	jne	SHORT $LN41@xmlParseSt
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN41@xmlParseSt
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN41@xmlParseSt:

; 8465 : 
; 8466 :     while (((RAW != '>') &&
; 8467 : 	   ((RAW != '/') || (NXT(1) != '>')) &&
; 8468 : 	   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {

	mov	edx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [edx+16]
	cmp	BYTE PTR [eax], 62			; 0000003eH
	je	$LN55@xmlParseSt
$LL2@xmlParseSt:
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR _q$1$[ebp], ecx
	mov	al, BYTE PTR [ecx]
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN14@xmlParseSt
	cmp	BYTE PTR [ecx+1], 62			; 0000003eH
	je	$LN61@xmlParseSt
$LN14@xmlParseSt:
	cmp	al, 9
	jb	SHORT $LN16@xmlParseSt
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN15@xmlParseSt
$LN16@xmlParseSt:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN15@xmlParseSt
	cmp	al, 32					; 00000020H
	jb	$LN61@xmlParseSt
$LN15@xmlParseSt:
	cmp	DWORD PTR [esi+172], -1
	je	$LN61@xmlParseSt

; 8469 : 	const xmlChar *q = CUR_PTR;
; 8470 : 	unsigned int cons = ctxt->input->consumed;

	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _cons$1$[ebp], eax

; 8471 : 
; 8472 : 	attname = xmlParseAttribute(ctxt, &attvalue);

	lea	eax, DWORD PTR _attvalue$[ebp]
	push	eax
	push	esi
	call	_xmlParseAttribute

; 8473 :         if ((attname != NULL) && (attvalue != NULL)) {

	mov	ebx, DWORD PTR _attvalue$[ebp]
	add	esp, 8
	mov	DWORD PTR _attname$1$[ebp], eax
	test	eax, eax
	je	$LN17@xmlParseSt
	test	ebx, ebx
	je	$LN63@xmlParseSt

; 8474 : 	    /*
; 8475 : 	     * [ WFC: Unique Att Spec ]
; 8476 : 	     * No attribute name may appear more than once in the same
; 8477 : 	     * start-tag or empty-element tag.
; 8478 : 	     */
; 8479 : 	    for (i = 0; i < nbatts;i += 2) {

	mov	ecx, DWORD PTR _nbatts$1$[ebp]
	xor	edi, edi
	test	ecx, ecx
	jle	SHORT $LN5@xmlParseSt
	npad	4
$LL6@xmlParseSt:

; 8480 : 	        if (xmlStrEqual(atts[i], attname)) {

	push	eax
	mov	eax, DWORD PTR _atts$1$[ebp]
	push	DWORD PTR [eax+edi*4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN44@xmlParseSt

; 8474 : 	    /*
; 8475 : 	     * [ WFC: Unique Att Spec ]
; 8476 : 	     * No attribute name may appear more than once in the same
; 8477 : 	     * start-tag or empty-element tag.
; 8478 : 	     */
; 8479 : 	    for (i = 0; i < nbatts;i += 2) {

	mov	ecx, DWORD PTR _nbatts$1$[ebp]
	add	edi, 2
	mov	eax, DWORD PTR _attname$1$[ebp]
	cmp	edi, ecx
	jl	SHORT $LL6@xmlParseSt
$LN5@xmlParseSt:

; 8484 : 		}
; 8485 : 	    }
; 8486 : 	    /*
; 8487 : 	     * Add the pair to atts
; 8488 : 	     */
; 8489 : 	    if (atts == NULL) {

	mov	edi, DWORD PTR _atts$1$[ebp]
	test	edi, edi
	jne	SHORT $LN20@xmlParseSt

; 8490 : 	        maxatts = 22; /* allow for 10 attrs by default */
; 8491 : 	        atts = (const xmlChar **)

	push	88					; 00000058H
	mov	DWORD PTR _maxatts$1$[ebp], 22		; 00000016H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _atts$1$[ebp], edi

; 8492 : 		       xmlMalloc(maxatts * sizeof(xmlChar *));
; 8493 : 		if (atts == NULL) {

	test	edi, edi
	jne	SHORT $LN22@xmlParseSt
$LN65@xmlParseSt:

; 8524 : 	}
; 8525 : 
; 8526 : failed:
; 8527 : 
; 8528 : 	GROW

	push	0
	push	esi
	call	_xmlErrMemory
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
	jmp	$LN63@xmlParseSt
$LN44@xmlParseSt:

; 8481 : 		    xmlErrAttributeDup(ctxt, NULL, attname);

	mov	edi, DWORD PTR _attname$1$[ebp]
	push	edi
	push	0
	push	esi
	call	_xmlErrAttributeDup

; 8482 : 		    xmlFree(attvalue);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H

; 8483 : 		    goto failed;

	jmp	$failed$69
$LN22@xmlParseSt:

; 8494 : 		    xmlErrMemory(ctxt, NULL);
; 8495 : 		    if (attvalue != NULL)
; 8496 : 			xmlFree(attvalue);
; 8497 : 		    goto failed;
; 8498 : 		}
; 8499 : 		ctxt->atts = atts;

	mov	DWORD PTR [esi+300], edi

; 8500 : 		ctxt->maxatts = maxatts;

	mov	DWORD PTR [esi+304], 22			; 00000016H
	jmp	SHORT $LN64@xmlParseSt
$LN20@xmlParseSt:

; 8501 : 	    } else if (nbatts + 4 > maxatts) {

	mov	edx, DWORD PTR _maxatts$1$[ebp]
	lea	eax, DWORD PTR [ecx+4]
	cmp	eax, edx
	jle	SHORT $LN24@xmlParseSt

; 8502 : 	        const xmlChar **n;
; 8503 : 
; 8504 : 	        maxatts *= 2;

	add	edx, edx
	mov	DWORD PTR _maxatts$1$[ebp], edx

; 8505 : 	        n = (const xmlChar **) xmlRealloc((void *) atts,

	lea	eax, DWORD PTR [edx*4]
	push	eax
	push	edi
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 8506 : 					     maxatts * sizeof(const xmlChar *));
; 8507 : 		if (n == NULL) {

	test	eax, eax
	je	SHORT $LN65@xmlParseSt

; 8508 : 		    xmlErrMemory(ctxt, NULL);
; 8509 : 		    if (attvalue != NULL)
; 8510 : 			xmlFree(attvalue);
; 8511 : 		    goto failed;
; 8512 : 		}
; 8513 : 		atts = n;

	mov	edi, eax

; 8514 : 		ctxt->atts = atts;

	mov	DWORD PTR [esi+300], eax

; 8515 : 		ctxt->maxatts = maxatts;

	mov	eax, DWORD PTR _maxatts$1$[ebp]
	mov	DWORD PTR _atts$1$[ebp], edi
	mov	DWORD PTR [esi+304], eax
$LN64@xmlParseSt:

; 8516 : 	    }
; 8517 : 	    atts[nbatts++] = attname;

	mov	ecx, DWORD PTR _nbatts$1$[ebp]
$LN24@xmlParseSt:
	mov	eax, DWORD PTR _attname$1$[ebp]
	mov	DWORD PTR [edi+ecx*4], eax

; 8518 : 	    atts[nbatts++] = attvalue;

	mov	DWORD PTR [edi+ecx*4+4], ebx

; 8519 : 	    atts[nbatts] = NULL;

	mov	DWORD PTR [edi+ecx*4+8], 0

; 8520 : 	    atts[nbatts + 1] = NULL;

	mov	DWORD PTR [edi+ecx*4+12], 0
	add	ecx, 2
	mov	DWORD PTR _nbatts$1$[ebp], ecx

; 8521 : 	} else {

	jmp	SHORT $LN63@xmlParseSt
$LN17@xmlParseSt:

; 8522 : 	    if (attvalue != NULL)

	test	ebx, ebx
	je	SHORT $LN63@xmlParseSt

; 8523 : 		xmlFree(attvalue);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN63@xmlParseSt:

; 8524 : 	}
; 8525 : 
; 8526 : failed:
; 8527 : 
; 8528 : 	GROW

	mov	edi, DWORD PTR _attname$1$[ebp]
$failed$69:
	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN28@xmlParseSt
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN28@xmlParseSt
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN28@xmlParseSt:

; 8529 : 	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	al, BYTE PTR [ecx]
	cmp	al, 62					; 0000003eH
	je	$LN61@xmlParseSt
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN29@xmlParseSt
	cmp	BYTE PTR [ecx+1], 62			; 0000003eH
	je	$LN61@xmlParseSt
$LN29@xmlParseSt:

; 8530 : 	    break;
; 8531 : 	if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN31@xmlParseSt

; 8532 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BM@FKPAGOOK@attributes?5construct?5error?6@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN31@xmlParseSt:

; 8533 : 			   "attributes construct error\n");
; 8534 : 	}
; 8535 :         if ((cons == ctxt->input->consumed) && (q == CUR_PTR) &&
; 8536 :             (attname == NULL) && (attvalue == NULL)) {

	mov	edx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _cons$1$[ebp]
	cmp	eax, DWORD PTR [edx+36]
	jne	SHORT $LN32@xmlParseSt
	mov	eax, DWORD PTR _q$1$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jne	SHORT $LN32@xmlParseSt
	test	edi, edi
	jne	SHORT $LN32@xmlParseSt
	test	ebx, ebx
	je	SHORT $LN46@xmlParseSt
$LN32@xmlParseSt:

; 8538 : 			   "xmlParseStartTag: problem parsing attributes\n");
; 8539 : 	    break;
; 8540 : 	}
; 8541 : 	SHRINK;

	mov	edi, DWORD PTR [esi+292]
	mov	ecx, edx
	test	edi, edi
	jne	SHORT $LN33@xmlParseSt
	mov	ebx, DWORD PTR [edx+16]
	mov	eax, ebx
	sub	eax, DWORD PTR [edx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN33@xmlParseSt
	mov	eax, DWORD PTR [edx+20]
	sub	eax, ebx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN33@xmlParseSt
	push	esi
	call	_xmlSHRINK
	mov	edi, DWORD PTR [esi+292]
	add	esp, 4
	mov	ecx, DWORD PTR [esi+36]
$LN33@xmlParseSt:

; 8542 :         GROW;

	mov	edx, ecx
	test	edi, edi
	jne	SHORT $LN34@xmlParseSt
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [ecx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN34@xmlParseSt
	push	esi
	call	_xmlGROW
	mov	edx, DWORD PTR [esi+36]
	add	esp, 4
$LN34@xmlParseSt:

; 8465 : 
; 8466 :     while (((RAW != '>') &&
; 8467 : 	   ((RAW != '/') || (NXT(1) != '>')) &&
; 8468 : 	   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {

	mov	eax, DWORD PTR [edx+16]
	cmp	BYTE PTR [eax], 62			; 0000003eH
	jne	$LL2@xmlParseSt
	jmp	SHORT $LN61@xmlParseSt
$LN46@xmlParseSt:

; 8537 : 	    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CO@KAECIKGE@xmlParseStartTag?3?5problem?5parsi@
	push	1
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN61@xmlParseSt:

; 8543 :     }
; 8544 : 
; 8545 :     /*
; 8546 :      * SAX: Start of Element !
; 8547 :      */
; 8548 :     if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL) &&

	mov	ebx, DWORD PTR _atts$1$[ebp]
	mov	edi, DWORD PTR _nbatts$1$[ebp]
$LN55@xmlParseSt:
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN37@xmlParseSt
	mov	eax, DWORD PTR [eax+56]
	test	eax, eax
	je	SHORT $LN37@xmlParseSt
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN37@xmlParseSt

; 8549 : 	(!ctxt->disableSAX)) {
; 8550 : 	if (nbatts > 0)

	mov	ecx, DWORD PTR [esi+4]
	test	edi, edi
	jle	SHORT $LN36@xmlParseSt

; 8551 : 	    ctxt->sax->startElement(ctxt->userData, name, atts);

	push	ebx
	jmp	SHORT $LN66@xmlParseSt
$LN36@xmlParseSt:

; 8552 : 	else
; 8553 : 	    ctxt->sax->startElement(ctxt->userData, name, NULL);

	push	0
$LN66@xmlParseSt:

; 8554 :     }
; 8555 : 
; 8556 :     if (atts != NULL) {

	push	DWORD PTR _name$1$[ebp]
	push	ecx
	call	eax
	add	esp, 12					; 0000000cH
$LN37@xmlParseSt:
	test	ebx, ebx
	je	SHORT $LN8@xmlParseSt

; 8557 :         /* Free only the content strings */
; 8558 :         for (i = 1;i < nbatts;i+=2)

	mov	esi, 1
	cmp	edi, esi
	jle	SHORT $LN8@xmlParseSt
$LL9@xmlParseSt:

; 8559 : 	    if (atts[i] != NULL)

	mov	eax, DWORD PTR [ebx+esi*4]
	test	eax, eax
	je	SHORT $LN7@xmlParseSt

; 8560 : 	       xmlFree((xmlChar *) atts[i]);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlParseSt:

; 8557 :         /* Free only the content strings */
; 8558 :         for (i = 1;i < nbatts;i+=2)

	add	esi, 2
	cmp	esi, edi
	jl	SHORT $LL9@xmlParseSt
$LN8@xmlParseSt:

; 8561 :     }
; 8562 :     return(name);

	mov	eax, DWORD PTR _name$1$[ebp]
	pop	edi

; 8563 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseStartTag ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseAttribute
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlParseAttribute PROC					; COMDAT

; 8350 : xmlParseAttribute(xmlParserCtxtPtr ctxt, xmlChar **value) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _value$[ebp]
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], 0
	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN2@xmlParseAt

; 8351 :     const xmlChar *name;
; 8352 :     xmlChar *val;
; 8353 : 
; 8354 :     *value = NULL;
; 8355 :     GROW;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN2@xmlParseAt
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN2@xmlParseAt:

; 8356 :     name = xmlParseName(ctxt);

	push	esi
	call	_xmlParseName
	mov	ebx, eax
	add	esp, 4

; 8357 :     if (name == NULL) {

	test	ebx, ebx
	jne	SHORT $LN3@xmlParseAt

; 8358 : 	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0BO@BHLKDNI@error?5parsing?5attribute?5name?6@
	push	68					; 00000044H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 8408 : }

	xor	eax, eax
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlParseAt:

; 8359 : 	               "error parsing attribute name\n");
; 8360 :         return(NULL);
; 8361 :     }
; 8362 : 
; 8363 :     /*
; 8364 :      * read the value
; 8365 :      */
; 8366 :     SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 8367 :     if (RAW == '=') {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 61			; 0000003dH
	jne	$LN4@xmlParseAt

; 8368 :         NEXT;

	push	edi
	push	esi
	call	_xmlNextChar

; 8369 : 	SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 8

; 4121 :     if ((ctxt == NULL) || (ctxt->input == NULL)) return(NULL);

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN16@xmlParseAt

; 4122 :     return(xmlParseAttValueInternal(ctxt, NULL, NULL, 0));

	push	0
	push	0
	push	0
	push	esi
	call	_xmlParseAttValueInternal
	add	esp, 16					; 00000010H
	mov	edi, eax
	jmp	SHORT $LN14@xmlParseAt
$LN16@xmlParseAt:

; 4121 :     if ((ctxt == NULL) || (ctxt->input == NULL)) return(NULL);

	xor	edi, edi
$LN14@xmlParseAt:

; 8374 : 	       "Specification mandates value for attribute %s\n", name);
; 8375 : 	return(NULL);
; 8376 :     }
; 8377 : 
; 8378 :     /*
; 8379 :      * Check that xml:lang conforms to the specification
; 8380 :      * No more registered as an error, just generate a warning now
; 8381 :      * since this was deprecated in XML second edition
; 8382 :      */
; 8383 :     if ((ctxt->pedantic) && (xmlStrEqual(name, BAD_CAST "xml:lang"))) {

	cmp	DWORD PTR [esi+268], 0
	mov	DWORD PTR [esi+172], 7
	je	SHORT $LN7@xmlParseAt
	push	OFFSET ??_C@_08EHDJCMMM@xml?3lang@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@xmlParseAt

; 8384 : 	if (!xmlCheckLanguageID(val)) {

	push	edi
	call	_xmlCheckLanguageID
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN7@xmlParseAt

; 8385 : 	    xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,

	push	eax
	push	edi
	push	OFFSET ??_C@_0CD@OAOAJGL@Malformed?5value?5for?5xml?3lang?5?3?5@
	push	98					; 00000062H
	push	esi
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H
$LN7@xmlParseAt:

; 8386 : 		          "Malformed value for xml:lang : %s\n",
; 8387 : 			  val, NULL);
; 8388 : 	}
; 8389 :     }
; 8390 : 
; 8391 :     /*
; 8392 :      * Check that xml:space conforms to the specification
; 8393 :      */
; 8394 :     if (xmlStrEqual(name, BAD_CAST "xml:space")) {

	push	OFFSET ??_C@_09HKHFJOKD@xml?3space@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlParseAt

; 8395 : 	if (xmlStrEqual(val, BAD_CAST "default"))

	push	OFFSET ??_C@_07DLHCIBDH@default@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlParseAt

; 8396 : 	    *(ctxt->space) = 0;

	mov	eax, DWORD PTR [esi+232]
	mov	DWORD PTR [eax], 0

; 8401 : "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n",
; 8402 :                                  val, NULL);
; 8403 : 	}
; 8404 :     }
; 8405 : 
; 8406 :     *value = val;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax], edi

; 8407 :     return(name);

	mov	eax, ebx
	pop	edi
	pop	esi

; 8408 : }

	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlParseAt:

; 8397 : 	else if (xmlStrEqual(val, BAD_CAST "preserve"))

	push	OFFSET ??_C@_08ILAKLJGO@preserve@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlParseAt

; 8398 : 	    *(ctxt->space) = 1;

	mov	eax, DWORD PTR [esi+232]
	mov	DWORD PTR [eax], 1

; 8401 : "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n",
; 8402 :                                  val, NULL);
; 8403 : 	}
; 8404 :     }
; 8405 : 
; 8406 :     *value = val;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax], edi

; 8407 :     return(name);

	mov	eax, ebx
	pop	edi
	pop	esi

; 8408 : }

	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlParseAt:

; 8399 : 	else {
; 8400 : 		xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,

	push	0
	push	edi
	push	OFFSET ??_C@_0EF@GNALPKCP@Invalid?5value?5?$CC?$CFs?$CC?5for?5xml?3spac@
	push	102					; 00000066H
	push	esi
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H
$LN12@xmlParseAt:

; 8401 : "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n",
; 8402 :                                  val, NULL);
; 8403 : 	}
; 8404 :     }
; 8405 : 
; 8406 :     *value = val;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax], edi

; 8407 :     return(name);

	mov	eax, ebx
	pop	edi
	pop	esi

; 8408 : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlParseAt:

; 8370 : 	val = xmlParseAttValue(ctxt);
; 8371 : 	ctxt->instate = XML_PARSER_CONTENT;
; 8372 :     } else {
; 8373 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,

	push	ebx
	push	OFFSET ??_C@_0CP@LHHGCLP@Specification?5mandates?5value?5fo@
	push	41					; 00000029H
	push	esi
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 8408 : }

	xor	eax, eax
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlParseAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseDocTypeDecl
_TEXT	SEGMENT
_ExternalID$ = -4					; size = 4
_URI$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseDocTypeDecl PROC				; COMDAT

; 8196 : xmlParseDocTypeDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _ExternalID$[ebp], 0
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [esi+200], 9
	add	DWORD PTR [eax+16], 9
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 9
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseDo

; 8197 :     const xmlChar *name = NULL;
; 8198 :     xmlChar *ExternalID = NULL;
; 8199 :     xmlChar *URI = NULL;
; 8200 : 
; 8201 :     /*
; 8202 :      * We know that '<!DOCTYPE' has been detected.
; 8203 :      */
; 8204 :     SKIP(9);

	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseDo:

; 8205 : 
; 8206 :     SKIP_BLANKS;

	push	ebx
	push	edi
	push	esi
	call	_xmlSkipBlankChars

; 8207 : 
; 8208 :     /*
; 8209 :      * Parse the DOCTYPE name.
; 8210 :      */
; 8211 :     name = xmlParseName(ctxt);

	push	esi
	call	_xmlParseName
	mov	edi, eax
	add	esp, 8

; 8212 :     if (name == NULL) {

	test	edi, edi
	jne	SHORT $LN6@xmlParseDo

; 8213 : 	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0CJ@JPAMJNGL@xmlParseDocTypeDecl?5?3?5no?5DOCTYP@
	push	68					; 00000044H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN6@xmlParseDo:

; 8214 : 		       "xmlParseDocTypeDecl : no DOCTYPE name !\n");
; 8215 :     }
; 8216 :     ctxt->intSubName = name;
; 8217 : 
; 8218 :     SKIP_BLANKS;

	push	esi
	mov	DWORD PTR [esi+220], edi
	call	_xmlSkipBlankChars

; 8219 : 
; 8220 :     /*
; 8221 :      * Check for SystemID and ExternalID
; 8222 :      */
; 8223 :     URI = xmlParseExternalID(ctxt, &ExternalID, 1);

	push	1
	lea	eax, DWORD PTR _ExternalID$[ebp]
	push	eax
	push	esi
	call	_xmlParseExternalID

; 8224 : 
; 8225 :     if ((URI != NULL) || (ExternalID != NULL)) {

	mov	ebx, DWORD PTR _ExternalID$[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _URI$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LN8@xmlParseDo
	test	ebx, ebx
	je	SHORT $LN7@xmlParseDo
$LN8@xmlParseDo:

; 8226 :         ctxt->hasExternalSubset = 1;

	mov	DWORD PTR [esi+88], 1
$LN7@xmlParseDo:

; 8227 :     }
; 8228 :     ctxt->extSubURI = URI;
; 8229 :     ctxt->extSubSystem = ExternalID;
; 8230 : 
; 8231 :     SKIP_BLANKS;

	push	esi
	mov	DWORD PTR [esi+224], eax
	mov	DWORD PTR [esi+228], ebx
	call	_xmlSkipBlankChars

; 8232 : 
; 8233 :     /*
; 8234 :      * Create and update the internal subset.
; 8235 :      */
; 8236 :     if ((ctxt->sax != NULL) && (ctxt->sax->internalSubset != NULL) &&

	mov	eax, DWORD PTR [esi]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@xmlParseDo
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN9@xmlParseDo
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN9@xmlParseDo

; 8237 : 	(!ctxt->disableSAX))
; 8238 : 	ctxt->sax->internalSubset(ctxt->userData, name, ExternalID, URI);

	push	DWORD PTR _URI$1$[ebp]
	push	ebx
	push	edi
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 16					; 00000010H
$LN9@xmlParseDo:

; 8239 :     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	pop	edi
	pop	ebx
	je	SHORT $LN1@xmlParseDo

; 8240 : 	return;
; 8241 : 
; 8242 :     /*
; 8243 :      * Is there any internal subset declarations ?
; 8244 :      * they are handled separately in xmlParseInternalSubset()
; 8245 :      */
; 8246 :     if (RAW == '[')

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 91					; 0000005bH
	je	SHORT $LN1@xmlParseDo

; 8247 : 	return;
; 8248 : 
; 8249 :     /*
; 8250 :      * We should be at the end of the DOCTYPE declaration.
; 8251 :      */
; 8252 :     if (RAW != '>') {

	cmp	al, 62					; 0000003eH
	je	SHORT $LN80@xmlParseDo

; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BO@NIFLODD@DOCTYPE?5improperly?5terminated@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	61					; 0000003dH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 61			; 0000003dH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN80@xmlParseDo

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN80@xmlParseDo:

; 8253 : 	xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
; 8254 :     }
; 8255 :     NEXT;

	push	esi
	call	_xmlNextChar
	add	esp, 4
$LN1@xmlParseDo:
	pop	esi

; 8256 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseDocTypeDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParsePEReference
_TEXT	SEGMENT
_start$1 = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParsePEReference PROC				; COMDAT

; 7832 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	mov	eax, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 37			; 00000025H
	jne	$LN1@xmlParsePE

; 7833 :     const xmlChar *name;
; 7834 :     xmlEntityPtr entity = NULL;
; 7835 :     xmlParserInputPtr input;
; 7836 : 
; 7837 :     if (RAW != '%')
; 7838 :         return;
; 7839 :     NEXT;

	push	ebx
	push	edi
	call	_xmlNextChar

; 7840 :     name = xmlParseName(ctxt);

	push	edi
	call	_xmlParseName
	mov	ebx, eax
	add	esp, 8

; 7841 :     if (name == NULL) {

	test	ebx, ebx
	jne	SHORT $LN3@xmlParsePE

; 7842 : 	xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, "PEReference: no name\n");

	push	OFFSET ??_C@_0BG@DIAKGNKN@PEReference?3?5no?5name?6@
	push	24					; 00000018H
	push	edi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
	pop	ebx
	pop	edi

; 7962 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlParsePE:

; 7843 : 	return;
; 7844 :     }
; 7845 :     if (xmlParserDebugEntities)

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], esi
	je	SHORT $LN4@xmlParsePE

; 7846 : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	ebx
	push	OFFSET ??_C@_0BB@MFPJKDDB@PEReference?3?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
	xor	esi, esi
$LN4@xmlParsePE:

; 7847 : 		"PEReference: %s\n", name);
; 7848 :     if (RAW != ';') {

	mov	eax, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 59			; 0000003bH
	je	SHORT $LN5@xmlParsePE

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edi+212], 0
	je	SHORT $LN31@xmlParsePE
	cmp	DWORD PTR [edi+172], -1
	je	$LN97@xmlParsePE
$LN31@xmlParsePE:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BL@PFALGNCI@PEReference?3?5expecting?5?8?$DL?8@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	25					; 00000019H
	push	1
	push	0
	push	edi
	push	0
	push	0
	push	0
	mov	DWORD PTR [edi+84], 25			; 00000019H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [edi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [edi+288], 0
	jne	$LN97@xmlParsePE
	pop	ebx

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [edi+212], 1
	pop	edi

; 7962 : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlParsePE:

; 7849 : 	xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);
; 7850 :         return;
; 7851 :     }
; 7852 : 
; 7853 :     NEXT;

	push	edi
	call	_xmlNextChar

; 7854 : 
; 7855 :     /*
; 7856 :      * Increate the number of entity references parsed
; 7857 :      */
; 7858 :     ctxt->nbentities++;

	inc	DWORD PTR [edi+440]
	add	esp, 4

; 7859 : 
; 7860 :     /*
; 7861 :      * Request the entity from SAX
; 7862 :      */
; 7863 :     if ((ctxt->sax != NULL) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN6@xmlParsePE
	mov	eax, DWORD PTR [eax+96]
	test	eax, eax
	je	SHORT $LN6@xmlParsePE

; 7864 : 	(ctxt->sax->getParameterEntity != NULL))
; 7865 : 	entity = ctxt->sax->getParameterEntity(ctxt->userData, name);

	push	ebx
	push	DWORD PTR [edi+4]
	call	eax
	add	esp, 8
	mov	esi, eax
$LN6@xmlParsePE:

; 7866 :     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [edi+172], -1
	je	$LN97@xmlParsePE

; 7867 : 	return;
; 7868 :     if (entity == NULL) {

	test	esi, esi
	jne	$LN8@xmlParsePE

; 7869 : 	/*
; 7870 : 	 * [ WFC: Entity Declared ]
; 7871 : 	 * In a document without any DTD, a document with only an
; 7872 : 	 * internal DTD subset which contains no parameter entity
; 7873 : 	 * references, or a document with "standalone='yes'", ...
; 7874 : 	 * ... The declaration of a parameter entity must precede
; 7875 : 	 * any reference to it...
; 7876 : 	 */
; 7877 : 	if ((ctxt->standalone == 1) ||

	cmp	DWORD PTR [edi+28], 1
	je	$LN12@xmlParsePE
	cmp	DWORD PTR [edi+88], esi
	jne	SHORT $LN10@xmlParsePE
	cmp	DWORD PTR [edi+92], esi
	je	SHORT $LN12@xmlParsePE
$LN10@xmlParsePE:

; 7881 : 			      "PEReference: %%%s; not found\n",
; 7882 : 			      name);
; 7883 : 	} else {
; 7884 : 	    /*
; 7885 : 	     * [ VC: Entity Declared ]
; 7886 : 	     * In a document with an external subset or external
; 7887 : 	     * parameter entities with "standalone='no'", ...
; 7888 : 	     * ... The declaration of a parameter entity must
; 7889 : 	     * precede any reference to it...
; 7890 : 	     */
; 7891 :             if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {

	cmp	DWORD PTR [edi+104], 0
	je	SHORT $LN13@xmlParsePE
	cmp	DWORD PTR [edi+112], 0
	je	SHORT $LN13@xmlParsePE

; 7892 :                 xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,

	push	0
	push	ebx
	push	OFFSET ??_C@_0BO@KINMDPMC@PEReference?3?5?$CF?$CF?$CFs?$DL?5not?5found?6@
	push	27					; 0000001bH
	push	edi
	call	_xmlValidityError

; 7897 :                               "PEReference: %%%s; not found\n",
; 7898 :                               name, NULL);
; 7899 :             ctxt->valid = 0;

	add	esp, 20					; 00000014H
	mov	DWORD PTR [edi+100], 0

; 7900 : 	}
; 7901 : 	xmlParserEntityCheck(ctxt, 0, NULL, 0);

	push	0
	push	0
	push	0
	push	edi
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H

; 7957 :                 }
; 7958 :             }
; 7959 : 	}
; 7960 :     }
; 7961 :     ctxt->hasPErefs = 1;

	mov	DWORD PTR [edi+92], 1
	pop	ebx
	pop	edi

; 7962 : }

	pop	esi
	pop	ebp
	ret	0
$LN13@xmlParsePE:

; 7893 :                                  "PEReference: %%%s; not found\n",
; 7894 :                                  name, NULL);
; 7895 :             } else
; 7896 :                 xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,

	push	0
	push	ebx
	push	OFFSET ??_C@_0BO@KINMDPMC@PEReference?3?5?$CF?$CF?$CFs?$DL?5not?5found?6@
	push	27					; 0000001bH
	push	edi
	call	_xmlWarningMsg

; 7897 :                               "PEReference: %%%s; not found\n",
; 7898 :                               name, NULL);
; 7899 :             ctxt->valid = 0;

	add	esp, 20					; 00000014H
	mov	DWORD PTR [edi+100], 0

; 7900 : 	}
; 7901 : 	xmlParserEntityCheck(ctxt, 0, NULL, 0);

	push	0
	push	0
	push	0
	push	edi
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H

; 7957 :                 }
; 7958 :             }
; 7959 : 	}
; 7960 :     }
; 7961 :     ctxt->hasPErefs = 1;

	mov	DWORD PTR [edi+92], 1
	pop	ebx
	pop	edi

; 7962 : }

	pop	esi
	pop	ebp
	ret	0
$LN12@xmlParsePE:

; 7878 : 	    ((ctxt->hasExternalSubset == 0) &&
; 7879 : 	     (ctxt->hasPErefs == 0))) {
; 7880 : 	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,

	push	ebx
	push	OFFSET ??_C@_0BO@KINMDPMC@PEReference?3?5?$CF?$CF?$CFs?$DL?5not?5found?6@
	push	26					; 0000001aH
	push	edi
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 7900 : 	}
; 7901 : 	xmlParserEntityCheck(ctxt, 0, NULL, 0);

	push	0
	push	0
	push	0
	push	edi
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H

; 7957 :                 }
; 7958 :             }
; 7959 : 	}
; 7960 :     }
; 7961 :     ctxt->hasPErefs = 1;

	mov	DWORD PTR [edi+92], 1
	pop	ebx
	pop	edi

; 7962 : }

	pop	esi
	pop	ebp
	ret	0
$LN8@xmlParsePE:

; 7902 :     } else {
; 7903 : 	/*
; 7904 : 	 * Internal checking in case the entity quest barfed
; 7905 : 	 */
; 7906 : 	if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&

	mov	eax, DWORD PTR [esi+48]
	cmp	eax, 4
	je	SHORT $LN17@xmlParsePE
	cmp	eax, 5
	je	SHORT $LN96@xmlParsePE

; 7907 : 	    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
; 7908 : 	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,

	push	0
	push	ebx
	push	OFFSET ??_C@_0CL@BLGDJGPF@Internal?3?5?$CF?$CF?$CFs?$DL?5is?5not?5a?5parame@
	push	27					; 0000001bH
	push	edi
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H

; 7957 :                 }
; 7958 :             }
; 7959 : 	}
; 7960 :     }
; 7961 :     ctxt->hasPErefs = 1;

	mov	DWORD PTR [edi+92], 1
	pop	ebx
	pop	edi

; 7962 : }

	pop	esi
	pop	ebp
	ret	0
$LN96@xmlParsePE:
	test	BYTE PTR [edi+360], 30			; 0000001eH

; 7909 : 		  "Internal: %%%s; is not a parameter entity\n",
; 7910 : 			  name, NULL);
; 7911 : 	} else {
; 7912 :             xmlChar start[4];
; 7913 :             xmlCharEncoding enc;
; 7914 : 
; 7915 : 	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
; 7916 : 	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
; 7917 : 		((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
; 7918 : 		((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
; 7919 : 		((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
; 7920 : 		(ctxt->replaceEntities == 0) &&

	jne	SHORT $LN17@xmlParsePE
	cmp	DWORD PTR [edi+16], 0
	jne	SHORT $LN17@xmlParsePE
	cmp	DWORD PTR [edi+104], 0
	je	$LN97@xmlParsePE
$LN17@xmlParsePE:

; 7921 : 		(ctxt->validate == 0))
; 7922 : 		return;
; 7923 : 
; 7924 : 	    input = xmlNewEntityInputStream(ctxt, entity);

	push	esi
	push	edi
	call	_xmlNewEntityInputStream
	mov	ebx, eax

; 7925 : 	    if (xmlPushInput(ctxt, input) < 0) {

	push	ebx
	push	edi
	call	_xmlPushInput
	add	esp, 16					; 00000010H
	test	eax, eax
	jns	SHORT $LN18@xmlParsePE

; 7926 :                 xmlFreeInputStream(input);

	push	ebx
	call	_xmlFreeInputStream
	add	esp, 4
	pop	ebx
	pop	edi

; 7962 : }

	pop	esi
	pop	ebp
	ret	0
$LN18@xmlParsePE:

; 7927 : 		return;
; 7928 :             }
; 7929 : 
; 7930 : 	    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {

	cmp	DWORD PTR [esi+48], 5
	jne	$LN24@xmlParsePE

; 7931 :                 /*
; 7932 :                  * Get the 4 first bytes and decode the charset
; 7933 :                  * if enc != XML_CHAR_ENCODING_NONE
; 7934 :                  * plug some encoding conversion routines.
; 7935 :                  * Note that, since we may have some non-UTF8
; 7936 :                  * encoding (like UTF16, bug 135229), the 'length'
; 7937 :                  * is not known, but we can calculate based upon
; 7938 :                  * the amount of data in the buffer.
; 7939 :                  */
; 7940 :                 GROW

	cmp	DWORD PTR [edi+292], 0
	jne	SHORT $LN20@xmlParsePE
	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN20@xmlParsePE
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN20@xmlParsePE:

; 7941 :                 if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [edi+172], -1
	je	$LN97@xmlParsePE

; 7942 :                     return;
; 7943 :                 if ((ctxt->input->end - ctxt->input->cur)>=4) {

	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [ecx+16]
	sub	eax, edx
	cmp	eax, 4
	jl	SHORT $LN23@xmlParsePE

; 7944 :                     start[0] = RAW;

	movzx	eax, BYTE PTR [edx]
	mov	BYTE PTR _start$1[ebp], al

; 7945 :                     start[1] = NXT(1);

	mov	eax, DWORD PTR [ecx+16]

; 7946 :                     start[2] = NXT(2);
; 7947 :                     start[3] = NXT(3);
; 7948 :                     enc = xmlDetectCharEncoding(start, 4);

	push	4
	movzx	eax, BYTE PTR [eax+1]
	mov	BYTE PTR _start$1[ebp+1], al
	mov	eax, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [eax+2]
	mov	BYTE PTR _start$1[ebp+2], al
	mov	eax, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [eax+3]
	mov	BYTE PTR _start$1[ebp+3], al
	lea	eax, DWORD PTR _start$1[ebp]
	push	eax
	call	_xmlDetectCharEncoding
	add	esp, 8

; 7949 :                     if (enc != XML_CHAR_ENCODING_NONE) {

	test	eax, eax
	je	SHORT $LN23@xmlParsePE

; 7950 :                         xmlSwitchEncoding(ctxt, enc);

	push	eax
	push	edi
	call	_xmlSwitchEncoding
	add	esp, 8
$LN23@xmlParsePE:

; 7951 :                     }
; 7952 :                 }
; 7953 : 
; 7954 :                 if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&

	mov	eax, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 60			; 0000003cH
	jne	SHORT $LN24@xmlParsePE
	cmp	BYTE PTR [eax+1], 63			; 0000003fH
	jne	SHORT $LN24@xmlParsePE
	cmp	BYTE PTR [eax+2], 120			; 00000078H
	jne	SHORT $LN24@xmlParsePE
	cmp	BYTE PTR [eax+3], 109			; 0000006dH
	jne	SHORT $LN24@xmlParsePE
	cmp	BYTE PTR [eax+4], 108			; 0000006cH
	jne	SHORT $LN24@xmlParsePE
	mov	al, BYTE PTR [eax+5]
	cmp	al, 32					; 00000020H
	je	SHORT $LN25@xmlParsePE
	cmp	al, 9
	jb	SHORT $LN26@xmlParsePE
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN25@xmlParsePE
$LN26@xmlParsePE:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN24@xmlParsePE
$LN25@xmlParsePE:

; 7955 :                     (IS_BLANK_CH(NXT(5)))) {
; 7956 :                     xmlParseTextDecl(ctxt);

	push	edi
	call	_xmlParseTextDecl
	add	esp, 4
$LN24@xmlParsePE:

; 7957 :                 }
; 7958 :             }
; 7959 : 	}
; 7960 :     }
; 7961 :     ctxt->hasPErefs = 1;

	mov	DWORD PTR [edi+92], 1
$LN97@xmlParsePE:
	pop	ebx
$LN1@xmlParsePE:
	pop	edi

; 7962 : }

	pop	esi
	pop	ebp
	ret	0
_xmlParsePEReference ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseReference
_TEXT	SEGMENT
_out$1 = -24						; size = 10
_next$1$ = -12						; size = 4
_last$1$ = -8						; size = 4
_oldnbent$1$ = -8					; size = 4
_nw$1$ = -4						; size = 4
_firstChild$1$ = -4					; size = 4
_list$ = -4						; size = 4
_firstChild$1$ = 8					; size = 4
_cur$1$ = 8						; size = 4
_ret$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseReference PROC					; COMDAT

; 6998 : xmlParseReference(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _list$[ebp], ebx
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 38			; 00000026H
	jne	$LN30@xmlParseRe

; 6999 :     xmlEntityPtr ent;
; 7000 :     xmlChar *val;
; 7001 :     int was_checked;
; 7002 :     xmlNodePtr list = NULL;
; 7003 :     xmlParserErrors ret = XML_ERR_OK;
; 7004 : 
; 7005 : 
; 7006 :     if (RAW != '&')
; 7007 :         return;
; 7008 : 
; 7009 :     /*
; 7010 :      * Simple case of a CharRef
; 7011 :      */
; 7012 :     if (NXT(1) == '#') {

	cmp	BYTE PTR [eax+1], 35			; 00000023H
	jne	$LN11@xmlParseRe

; 7013 : 	int i = 0;
; 7014 : 	xmlChar out[10];
; 7015 : 	int hex = NXT(2);

	mov	bl, BYTE PTR [eax+2]

; 7016 : 	int value = xmlParseCharRef(ctxt);

	push	esi
	call	_xmlParseCharRef
	add	esp, 4

; 7017 : 
; 7018 : 	if (value == 0)

	test	eax, eax
	je	$LN30@xmlParseRe

; 7019 : 	    return;
; 7020 : 	if (ctxt->charset != XML_CHAR_ENCODING_UTF8) {

	cmp	DWORD PTR [esi+256], 1
	je	$LN13@xmlParseRe

; 7021 : 	    /*
; 7022 : 	     * So we are using non-UTF-8 buffers
; 7023 : 	     * Check that the char fit on 8bits, if not
; 7024 : 	     * generate a CharRef.
; 7025 : 	     */
; 7026 : 	    if (value <= 0xFF) {

	cmp	eax, 255				; 000000ffH
	jg	SHORT $LN15@xmlParseRe

; 7027 : 		out[0] = value;

	mov	BYTE PTR _out$1[ebp], al

; 7028 : 		out[1] = 0;
; 7029 : 		if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&

	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR _out$1[ebp+1], 0
	test	eax, eax
	je	$LN30@xmlParseRe
	mov	eax, DWORD PTR [eax+68]
	test	eax, eax
	je	$LN30@xmlParseRe
	cmp	DWORD PTR [esi+212], 0
	jne	$LN30@xmlParseRe

; 7030 : 		    (!ctxt->disableSAX))
; 7031 : 		    ctxt->sax->characters(ctxt->userData, out, 1);

	push	1
	lea	ecx, DWORD PTR _out$1[ebp]
	push	ecx
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 12					; 0000000cH
	pop	esi

; 7416 : 	    return;
; 7417 : 	}
; 7418 :     }
; 7419 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlParseRe:

; 7032 : 	    } else {
; 7033 : 		if ((hex == 'x') || (hex == 'X'))

	cmp	bl, 120					; 00000078H
	je	SHORT $LN20@xmlParseRe

; 7035 : 		else
; 7036 : 		    snprintf((char *)out, sizeof(out), "#%d", value);

	mov	ecx, OFFSET ??_C@_03FDCLAKJL@?$CD?$CFd@
	cmp	bl, 88					; 00000058H
	jne	SHORT $LN19@xmlParseRe
$LN20@xmlParseRe:

; 7034 : 		    snprintf((char *)out, sizeof(out), "#x%X", value);

	mov	ecx, OFFSET ??_C@_04FNNDIGBC@?$CDx?$CFX@
$LN19@xmlParseRe:

; 7037 : 		if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&

	push	eax
	push	ecx
	lea	eax, DWORD PTR _out$1[ebp]
	push	10					; 0000000aH
	push	eax
	call	_snprintf
	mov	eax, DWORD PTR [esi]
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN30@xmlParseRe
	mov	eax, DWORD PTR [eax+64]
	test	eax, eax
	je	$LN30@xmlParseRe
	cmp	DWORD PTR [esi+212], 0
	jne	$LN30@xmlParseRe

; 7038 : 		    (!ctxt->disableSAX))
; 7039 : 		    ctxt->sax->reference(ctxt->userData, out);

	lea	ecx, DWORD PTR _out$1[ebp]
	push	ecx
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 8
	pop	esi

; 7416 : 	    return;
; 7417 : 	}
; 7418 :     }
; 7419 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlParseRe:

; 7040 : 	    }
; 7041 : 	} else {
; 7042 : 	    /*
; 7043 : 	     * Just encode the value in UTF-8
; 7044 : 	     */
; 7045 : 	    COPY_BUF(0 ,out, i, value);

	push	eax
	lea	eax, DWORD PTR _out$1[ebp]
	push	eax
	call	_xmlCopyCharMultiByte

; 7046 : 	    out[i] = 0;
; 7047 : 	    if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&

	mov	ecx, DWORD PTR [esi]
	add	esp, 8
	mov	BYTE PTR _out$1[ebp+eax], 0
	test	ecx, ecx
	je	$LN30@xmlParseRe
	mov	ecx, DWORD PTR [ecx+68]
	test	ecx, ecx
	je	$LN30@xmlParseRe
	cmp	DWORD PTR [esi+212], 0
	jne	$LN30@xmlParseRe

; 7048 : 		(!ctxt->disableSAX))
; 7049 : 		ctxt->sax->characters(ctxt->userData, out, i);

	push	eax
	lea	eax, DWORD PTR _out$1[ebp]
	push	eax
	push	DWORD PTR [esi+4]
	call	ecx
	add	esp, 12					; 0000000cH
	pop	esi

; 7416 : 	    return;
; 7417 : 	}
; 7418 :     }
; 7419 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlParseRe:
	push	edi

; 7050 : 	}
; 7051 : 	return;
; 7052 :     }
; 7053 : 
; 7054 :     /*
; 7055 :      * We are seeing an entity reference
; 7056 :      */
; 7057 :     ent = xmlParseEntityRef(ctxt);

	push	esi
	call	_xmlParseEntityRef
	mov	edi, eax
	add	esp, 4

; 7058 :     if (ent == NULL) return;

	test	edi, edi
	je	$LN273@xmlParseRe

; 7059 :     if (!ctxt->wellFormed)

	cmp	DWORD PTR [esi+12], ebx
	je	$LN273@xmlParseRe

; 7060 : 	return;
; 7061 :     was_checked = ent->checked;

	mov	ecx, DWORD PTR [edi+72]

; 7062 : 
; 7063 :     /* special case of predefined entities */
; 7064 :     if ((ent->name == NULL) ||

	cmp	DWORD PTR [edi+8], ebx
	je	$LN28@xmlParseRe
	mov	eax, DWORD PTR [edi+48]
	cmp	eax, 6
	je	$LN28@xmlParseRe

; 7074 : 	return;
; 7075 :     }
; 7076 : 
; 7077 :     /*
; 7078 :      * The first reference to the entity trigger a parsing phase
; 7079 :      * where the ent->children is filled with the result from
; 7080 :      * the parsing.
; 7081 :      * Note: external parsed entities will not be loaded, it is not
; 7082 :      * required for a non-validating parser, unless the parsing option
; 7083 :      * of validating, or substituting entities were given. Doing so is
; 7084 :      * far more secure as the parser will only process data coming from
; 7085 :      * the document entity by default.
; 7086 :      */
; 7087 :     if (((ent->checked == 0) ||
; 7088 :          ((ent->children == NULL) && (ctxt->options & XML_PARSE_NOENT))) &&

	test	ecx, ecx
	je	SHORT $LN269@xmlParseRe
	cmp	DWORD PTR [edi+12], ebx
	jne	SHORT $LN31@xmlParseRe
	test	BYTE PTR [esi+360], 2
	je	SHORT $LN31@xmlParseRe
$LN269@xmlParseRe:
	cmp	eax, 2
	jne	SHORT $LN34@xmlParseRe
	test	BYTE PTR [esi+360], 18			; 00000012H
	jne	SHORT $LN34@xmlParseRe
$LN31@xmlParseRe:

; 7206 :     } else if (ent->checked != 1) {

	cmp	ecx, 1
	je	$LN63@xmlParseRe

; 7207 : 	ctxt->nbentities += ent->checked / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	DWORD PTR [esi+440], eax
	jmp	$LN63@xmlParseRe
$LN34@xmlParseRe:

; 7089 :         ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
; 7090 :          (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {
; 7091 : 	unsigned long oldnbent = ctxt->nbentities;

	mov	ecx, DWORD PTR [esi+440]

; 7092 : 
; 7093 : 	/*
; 7094 : 	 * This is a bit hackish but this seems the best
; 7095 : 	 * way to make sure both SAX and DOM entity support
; 7096 : 	 * behaves okay.
; 7097 : 	 */
; 7098 : 	void *user_data;
; 7099 : 	if (ctxt->userData == ctxt)

	xor	edx, edx
	mov	DWORD PTR _oldnbent$1$[ebp], ecx
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, esi
	cmove	ecx, edx

; 7100 : 	    user_data = NULL;
; 7101 : 	else
; 7102 : 	    user_data = ctxt->userData;
; 7103 : 
; 7104 : 	/*
; 7105 : 	 * Check that this entity is well formed
; 7106 : 	 * 4.3.2: An internal general parsed entity is well-formed
; 7107 : 	 * if its replacement text matches the production labeled
; 7108 : 	 * content.
; 7109 : 	 */
; 7110 : 	if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {

	cmp	eax, 1
	jne	SHORT $LN37@xmlParseRe

; 7111 : 	    ctxt->depth++;

	inc	DWORD PTR [esi+248]

; 7112 : 	    ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent->content,

	lea	eax, DWORD PTR _list$[ebp]
	push	eax
	push	ecx
	push	DWORD PTR [edi+40]
	push	esi
	call	_xmlParseBalancedChunkMemoryInternal

; 7113 : 	                                              user_data, &list);
; 7114 : 	    ctxt->depth--;

	mov	ebx, DWORD PTR _list$[ebp]
	add	esp, 16					; 00000010H
	dec	DWORD PTR [esi+248]
	mov	DWORD PTR _ret$1$[ebp], eax
	jmp	SHORT $LN40@xmlParseRe
$LN37@xmlParseRe:

; 7115 : 
; 7116 : 	} else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {

	cmp	eax, 2
	jne	SHORT $LN39@xmlParseRe

; 7117 : 	    ctxt->depth++;

	inc	DWORD PTR [esi+248]

; 7118 : 	    ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt, ctxt->sax,

	lea	eax, DWORD PTR _list$[ebp]
	push	eax
	push	DWORD PTR [edi+52]
	push	DWORD PTR [edi+64]
	push	DWORD PTR [esi+248]
	push	ecx
	push	DWORD PTR [esi]
	push	esi
	push	DWORD PTR [esi+8]
	call	_xmlParseExternalEntityPrivate

; 7119 : 	                                   user_data, ctxt->depth, ent->URI,
; 7120 : 					   ent->ExternalID, &list);
; 7121 : 	    ctxt->depth--;
; 7122 : 	} else {

	mov	ebx, DWORD PTR _list$[ebp]
	add	esp, 32					; 00000020H
	dec	DWORD PTR [esi+248]
	mov	DWORD PTR _ret$1$[ebp], eax
	jmp	SHORT $LN40@xmlParseRe
$LN39@xmlParseRe:

; 7123 : 	    ret = XML_ERR_ENTITY_PE_INTERNAL;
; 7124 : 	    xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	0
	push	OFFSET ??_C@_0BL@EBFCDHBG@invalid?5entity?5type?5found?6@
	push	1
	push	esi
	mov	DWORD PTR _ret$1$[ebp], 88		; 00000058H
	call	_xmlErrMsgStr
	add	esp, 16					; 00000010H
$LN40@xmlParseRe:

; 7125 : 			 "invalid entity type found\n", NULL);
; 7126 : 	}
; 7127 : 
; 7128 : 	/*
; 7129 : 	 * Store the number of entities needing parsing for this entity
; 7130 : 	 * content and do checkings
; 7131 : 	 */
; 7132 : 	ent->checked = (ctxt->nbentities - oldnbent + 1) * 2;

	mov	eax, DWORD PTR [esi+440]
	sub	eax, DWORD PTR _oldnbent$1$[ebp]
	lea	eax, DWORD PTR [eax*2+2]
	mov	DWORD PTR [edi+72], eax

; 7133 : 	if ((ent->content != NULL) && (xmlStrchr(ent->content, '<')))

	mov	eax, DWORD PTR [edi+40]
	test	eax, eax
	je	SHORT $LN41@xmlParseRe
	push	60					; 0000003cH
	push	eax
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN41@xmlParseRe

; 7134 : 	    ent->checked |= 1;

	or	DWORD PTR [edi+72], 1
$LN41@xmlParseRe:

; 7135 : 	if (ret == XML_ERR_ENTITY_LOOP) {

	cmp	DWORD PTR _ret$1$[ebp], 89		; 00000059H
	jne	SHORT $LN42@xmlParseRe

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN105@xmlParseRe
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN168@xmlParseRe
$LN105@xmlParseRe:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CC@LFHGNGFD@Detected?5an?5entity?5reference?5lo@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	89					; 00000059H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 89			; 00000059H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN168@xmlParseRe

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN168@xmlParseRe:

; 7136 : 	    xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
; 7137 : 	    xmlFreeNodeList(list);

	push	ebx
	call	_xmlFreeNodeList
	add	esp, 4
	pop	edi
	pop	esi

; 7416 : 	    return;
; 7417 : 	}
; 7418 :     }
; 7419 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@xmlParseRe:

; 7138 : 	    return;
; 7139 : 	}
; 7140 : 	if (xmlParserEntityCheck(ctxt, 0, ent, 0)) {

	push	0
	push	edi
	push	0
	push	esi
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN168@xmlParseRe

; 7141 : 	    xmlFreeNodeList(list);
; 7142 : 	    return;
; 7143 : 	}
; 7144 : 
; 7145 : 	if ((ret == XML_ERR_OK) && (list != NULL)) {

	mov	eax, DWORD PTR _ret$1$[ebp]
	test	eax, eax
	jne	$LN268@xmlParseRe
	test	ebx, ebx
	je	$LN61@xmlParseRe

; 7146 : 	    if (((ent->etype == XML_INTERNAL_GENERAL_ENTITY) ||
; 7147 : 	     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY))&&

	mov	eax, DWORD PTR [edi+48]
	cmp	eax, 1
	je	SHORT $LN48@xmlParseRe
	cmp	eax, 2
	jne	$LN46@xmlParseRe
$LN48@xmlParseRe:
	cmp	DWORD PTR [edi+12], 0
	jne	$LN46@xmlParseRe

; 7148 : 		(ent->children == NULL)) {
; 7149 : 		ent->children = list;

	mov	DWORD PTR [edi+12], ebx

; 7150 : 		if (ctxt->replaceEntities) {

	cmp	DWORD PTR [esi+16], 0
	je	SHORT $LN49@xmlParseRe

; 7151 : 		    /*
; 7152 : 		     * Prune it directly in the generated document
; 7153 : 		     * except for single text nodes.
; 7154 : 		     */
; 7155 : 		    if (((list->type == XML_TEXT_NODE) &&
; 7156 : 			 (list->next == NULL)) ||

	cmp	DWORD PTR [ebx+4], 3
	jne	SHORT $LN54@xmlParseRe
	cmp	DWORD PTR [ebx+24], 0
	je	SHORT $LN53@xmlParseRe
$LN54@xmlParseRe:
	cmp	DWORD PTR [esi+436], 5
	jne	SHORT $LN51@xmlParseRe
$LN53@xmlParseRe:

; 7157 : 			(ctxt->parseMode == XML_PARSE_READER)) {
; 7158 : 			list->parent = (xmlNodePtr) ent;

	mov	DWORD PTR [ebx+20], edi

; 7159 : 			list = NULL;
; 7160 : 			ent->owner = 1;

	mov	DWORD PTR [edi+68], 1

; 7161 : 		    } else {

	jmp	$LN274@xmlParseRe
$LN51@xmlParseRe:

; 7162 : 			ent->owner = 0;

	mov	DWORD PTR [edi+68], 0
	npad	2
$LL2@xmlParseRe:

; 7163 : 			while (list != NULL) {
; 7164 : 			    list->parent = (xmlNodePtr) ctxt->node;

	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [ebx+20], eax

; 7165 : 			    list->doc = ctxt->myDoc;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ebx+32], eax

; 7166 : 			    if (list->next == NULL)

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	jne	SHORT $LN55@xmlParseRe

; 7167 : 				ent->last = list;

	mov	DWORD PTR [edi+16], ebx
	mov	eax, DWORD PTR [ebx+24]
$LN55@xmlParseRe:

; 7168 : 			    list = list->next;

	mov	ebx, eax
	test	ebx, ebx
	jne	SHORT $LL2@xmlParseRe

; 7169 : 			}
; 7170 : 			list = ent->children;
; 7171 : #ifdef LIBXML_LEGACY_ENABLED
; 7172 : 			if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)

	cmp	DWORD PTR [edi+48], 2
	mov	ebx, DWORD PTR [edi+12]
	jne	$LN61@xmlParseRe

; 14667:     if (xmlEntityRefFunc != NULL) {

	mov	eax, DWORD PTR _xmlEntityRefFunc
	test	eax, eax
	je	SHORT $LN61@xmlParseRe

; 14668:         (*xmlEntityRefFunc) (ent, firstNode, lastNode);

	push	0
	push	ebx
	push	edi
	call	eax
	add	esp, 12					; 0000000cH

; 7173 : 			  xmlAddEntityReference(ent, list, NULL);
; 7174 : #endif /* LIBXML_LEGACY_ENABLED */
; 7175 : 		    }
; 7176 : 		} else {

	jmp	SHORT $LN61@xmlParseRe
$LN49@xmlParseRe:

; 7177 : 		    ent->owner = 1;

	mov	DWORD PTR [edi+68], 1
$LL4@xmlParseRe:

; 7178 : 		    while (list != NULL) {
; 7179 : 			list->parent = (xmlNodePtr) ent;

	mov	DWORD PTR [ebx+20], edi

; 7180 : 			xmlSetTreeDoc(list, ent->doc);

	push	DWORD PTR [edi+32]
	push	ebx
	call	_xmlSetTreeDoc

; 7181 : 			if (list->next == NULL)

	mov	eax, DWORD PTR [ebx+24]
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN57@xmlParseRe

; 7182 : 			    ent->last = list;

	mov	DWORD PTR [edi+16], ebx
	mov	eax, DWORD PTR [ebx+24]
$LN57@xmlParseRe:

; 7183 : 			list = list->next;

	mov	ebx, eax
	test	ebx, ebx
	jne	SHORT $LL4@xmlParseRe

; 7184 : 		    }
; 7185 : 		}
; 7186 : 	    } else {

	jmp	SHORT $LN61@xmlParseRe
$LN268@xmlParseRe:

; 7187 : 		xmlFreeNodeList(list);
; 7188 : 		list = NULL;
; 7189 : 	    }
; 7190 : 	} else if ((ret != XML_ERR_OK) &&

	cmp	eax, 27					; 0000001bH
	je	SHORT $LN58@xmlParseRe

; 7191 : 		   (ret != XML_WAR_UNDECLARED_ENTITY)) {
; 7192 : 	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,

	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_0BN@EOPGEOPH@Entity?5?8?$CFs?8?5failed?5to?5parse?6@
	push	26					; 0000001aH
	push	esi
	call	_xmlFatalErrMsgStr

; 7193 : 		     "Entity '%s' failed to parse\n", ent->name);
; 7194 :             if (ent->content != NULL)

	mov	eax, DWORD PTR [edi+40]
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN60@xmlParseRe

; 7195 :                 ent->content[0] = 0;

	mov	BYTE PTR [eax], 0
$LN60@xmlParseRe:

; 7196 : 	    xmlParserEntityCheck(ctxt, 0, ent, 0);

	push	0
	push	edi
	push	0
	push	esi
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H
	jmp	SHORT $LN61@xmlParseRe
$LN58@xmlParseRe:

; 7197 : 	} else if (list != NULL) {

	test	ebx, ebx
	je	SHORT $LN61@xmlParseRe
$LN46@xmlParseRe:

; 7198 : 	    xmlFreeNodeList(list);
; 7199 : 	    list = NULL;
; 7200 : 	}
; 7201 : 	if (ent->checked == 0)

	push	ebx
	call	_xmlFreeNodeList
	add	esp, 4
$LN274@xmlParseRe:
	xor	ebx, ebx
$LN61@xmlParseRe:
	cmp	DWORD PTR [edi+72], 0
	jne	SHORT $LN62@xmlParseRe

; 7202 : 	    ent->checked = 2;

	mov	DWORD PTR [edi+72], 2
$LN62@xmlParseRe:

; 7203 : 
; 7204 :         /* Prevent entity from being parsed and expanded twice (Bug 760367). */
; 7205 :         was_checked = 0;

	xor	ecx, ecx
$LN63@xmlParseRe:

; 7208 :     }
; 7209 : 
; 7210 :     /*
; 7211 :      * Now that the entity content has been gathered
; 7212 :      * provide it to the application, this can take different forms based
; 7213 :      * on the parsing modes.
; 7214 :      */
; 7215 :     if (ent->children == NULL) {

	cmp	DWORD PTR [edi+12], 0
	jne	$LN64@xmlParseRe

; 7216 : 	/*
; 7217 : 	 * Probably running in SAX mode and the callbacks don't
; 7218 : 	 * build the entity content. So unless we already went
; 7219 : 	 * though parsing for first checking go though the entity
; 7220 : 	 * content to generate callbacks associated to the entity
; 7221 : 	 */
; 7222 : 	if (was_checked != 0) {

	test	ecx, ecx
	je	$LN72@xmlParseRe

; 7223 : 	    void *user_data;
; 7224 : 	    /*
; 7225 : 	     * This is a bit hackish but this seems the best
; 7226 : 	     * way to make sure both SAX and DOM entity support
; 7227 : 	     * behaves okay.
; 7228 : 	     */
; 7229 : 	    if (ctxt->userData == ctxt)

	mov	eax, DWORD PTR [esi+4]
	xor	ecx, ecx
	cmp	eax, esi

; 7230 : 		user_data = NULL;
; 7231 : 	    else
; 7232 : 		user_data = ctxt->userData;
; 7233 : 
; 7234 : 	    if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {

	push	0
	cmove	eax, ecx
	mov	ecx, DWORD PTR [edi+48]
	cmp	ecx, 1
	jne	SHORT $LN68@xmlParseRe

; 7235 : 		ctxt->depth++;

	inc	DWORD PTR [esi+248]

; 7236 : 		ret = xmlParseBalancedChunkMemoryInternal(ctxt,

	push	eax
	push	DWORD PTR [edi+40]
	push	esi
	call	_xmlParseBalancedChunkMemoryInternal
	add	esp, 16					; 00000010H

; 7237 : 				   ent->content, user_data, NULL);
; 7238 : 		ctxt->depth--;

	jmp	SHORT $LN275@xmlParseRe
$LN68@xmlParseRe:

; 7239 : 	    } else if (ent->etype ==

	cmp	ecx, 2
	jne	$LN70@xmlParseRe

; 7240 : 		       XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
; 7241 : 		ctxt->depth++;

	inc	DWORD PTR [esi+248]

; 7242 : 		ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt,

	push	DWORD PTR [edi+52]
	push	DWORD PTR [edi+64]
	push	DWORD PTR [esi+248]
	push	eax
	push	DWORD PTR [esi]
	push	esi
	push	DWORD PTR [esi+8]
	call	_xmlParseExternalEntityPrivate
	add	esp, 32					; 00000020H
$LN275@xmlParseRe:

; 7249 : 			     "invalid entity type found\n", NULL);
; 7250 : 	    }
; 7251 : 	    if (ret == XML_ERR_ENTITY_LOOP) {

	dec	DWORD PTR [esi+248]
	cmp	eax, 89					; 00000059H
	jne	$LN72@xmlParseRe

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN176@xmlParseRe
	cmp	DWORD PTR [esi+172], -1
	je	$LN273@xmlParseRe
$LN176@xmlParseRe:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CC@LFHGNGFD@Detected?5an?5entity?5reference?5lo@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	89					; 00000059H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 89			; 00000059H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	$LN273@xmlParseRe
	pop	edi

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
	pop	esi

; 7416 : 	    return;
; 7417 : 	}
; 7418 :     }
; 7419 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN70@xmlParseRe:

; 7243 : 			   ctxt->sax, user_data, ctxt->depth,
; 7244 : 			   ent->URI, ent->ExternalID, NULL);
; 7245 : 		ctxt->depth--;
; 7246 : 	    } else {
; 7247 : 		ret = XML_ERR_ENTITY_PE_INTERNAL;
; 7248 : 		xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0BL@EBFCDHBG@invalid?5entity?5type?5found?6@
	push	1
	push	esi
	call	_xmlErrMsgStr
	add	esp, 16					; 00000010H
$LN72@xmlParseRe:

; 7252 : 		xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
; 7253 : 		return;
; 7254 : 	    }
; 7255 : 	}
; 7256 : 	if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&
; 7257 : 	    (ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	$LN273@xmlParseRe
	mov	eax, DWORD PTR [eax+64]
	test	eax, eax
	je	$LN273@xmlParseRe
	cmp	DWORD PTR [esi+16], 0
	jne	$LN273@xmlParseRe
	cmp	DWORD PTR [esi+212], 0
	jne	$LN273@xmlParseRe
$LN279@xmlParseRe:

; 7258 : 	    /*
; 7259 : 	     * Entity reference callback comes second, it's somewhat
; 7260 : 	     * superfluous but a compatibility to historical behaviour
; 7261 : 	     */
; 7262 : 	    ctxt->sax->reference(ctxt->userData, ent->name);

	push	DWORD PTR [edi+8]
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 8
	pop	edi
	pop	esi

; 7416 : 	    return;
; 7417 : 	}
; 7418 :     }
; 7419 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN64@xmlParseRe:

; 7263 : 	}
; 7264 : 	return;
; 7265 :     }
; 7266 : 
; 7267 :     /*
; 7268 :      * If we didn't get any children for the entity being built
; 7269 :      */
; 7270 :     if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&
; 7271 : 	(ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN74@xmlParseRe
	mov	eax, DWORD PTR [eax+64]
	test	eax, eax
	je	SHORT $LN74@xmlParseRe
	cmp	DWORD PTR [esi+16], 0
	jne	SHORT $LN277@xmlParseRe
	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN279@xmlParseRe
$LN74@xmlParseRe:

; 7272 : 	/*
; 7273 : 	 * Create a node.
; 7274 : 	 */
; 7275 : 	ctxt->sax->reference(ctxt->userData, ent->name);
; 7276 : 	return;
; 7277 :     }
; 7278 : 
; 7279 :     if ((ctxt->replaceEntities) || (ent->children == NULL))  {

	cmp	DWORD PTR [esi+16], 0
	je	$LN273@xmlParseRe
$LN277@xmlParseRe:

; 7280 : 	/*
; 7281 : 	 * There is a problem on the handling of _private for entities
; 7282 : 	 * (bug 155816): Should we copy the content of the field from
; 7283 : 	 * the entity (possibly overwriting some value set by the user
; 7284 : 	 * when a copy is created), should we leave it alone, or should
; 7285 : 	 * we try to take care of different situations?  The problem
; 7286 : 	 * is exacerbated by the usage of this field by the xmlReader.
; 7287 : 	 * To fix this bug, we look at _private on the created node
; 7288 : 	 * and, if it's NULL, we copy in whatever was in the entity.
; 7289 : 	 * If it's not NULL we leave it alone.  This is somewhat of a
; 7290 : 	 * hack - maybe we should have further tests to determine
; 7291 : 	 * what to do.
; 7292 : 	 */
; 7293 : 	if ((ctxt->node != NULL) && (ent->children != NULL)) {

	cmp	DWORD PTR [esi+52], 0
	je	$LN273@xmlParseRe

; 7294 : 	    /*
; 7295 : 	     * Seems we are generating the DOM content, do
; 7296 : 	     * a simple tree copy for all references except the first
; 7297 : 	     * In the first occurrence list contains the replacement.
; 7298 : 	     */
; 7299 : 	    if (((list == NULL) && (ent->owner == 0)) ||

	test	ebx, ebx
	jne	SHORT $LN271@xmlParseRe
	cmp	DWORD PTR [edi+68], ebx
	je	SHORT $LN270@xmlParseRe
$LN271@xmlParseRe:
	cmp	DWORD PTR [esi+436], 5
	jne	$LN78@xmlParseRe
$LN270@xmlParseRe:

; 7300 : 		(ctxt->parseMode == XML_PARSE_READER)) {
; 7301 : 		xmlNodePtr nw = NULL, cur, firstChild = NULL;
; 7302 : 
; 7303 : 		/*
; 7304 : 		 * We are copying here, make sure there is no abuse
; 7305 : 		 */
; 7306 : 		ctxt->sizeentcopy += ent->length + 5;

	mov	eax, DWORD PTR [edi+44]
	xor	ebx, ebx
	add	eax, 5
	mov	DWORD PTR _firstChild$1$[ebp], ebx
	add	DWORD PTR [esi+468], eax

; 7307 : 		if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))

	push	DWORD PTR [esi+468]
	push	edi
	push	ebx
	push	esi
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN273@xmlParseRe

; 7308 : 		    return;
; 7309 : 
; 7310 : 		/*
; 7311 : 		 * when operating on a reader, the entities definitions
; 7312 : 		 * are always owning the entities subtree.
; 7313 : 		if (ctxt->parseMode == XML_PARSE_READER)
; 7314 : 		    ent->owner = 1;
; 7315 : 		 */
; 7316 : 
; 7317 : 		cur = ent->children;

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR _cur$1$[ebp], eax

; 7318 : 		while (cur != NULL) {

	test	eax, eax
	je	SHORT $LN87@xmlParseRe
$LL6@xmlParseRe:

; 7319 : 		    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);

	push	1
	push	DWORD PTR [esi+8]
	push	eax
	call	_xmlDocCopyNode
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 7320 : 		    if (nw != NULL) {

	test	ebx, ebx
	je	SHORT $LN83@xmlParseRe

; 7321 : 			if (nw->_private == NULL)

	cmp	DWORD PTR [ebx], 0
	jne	SHORT $LN84@xmlParseRe

; 7322 : 			    nw->_private = cur->_private;

	mov	ecx, DWORD PTR _cur$1$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [ebx], ecx
$LN84@xmlParseRe:

; 7323 : 			if (firstChild == NULL){

	mov	eax, DWORD PTR _firstChild$1$[ebp]
	test	eax, eax

; 7324 : 			    firstChild = nw;
; 7325 : 			}
; 7326 : 			nw = xmlAddChild(ctxt->node, nw);

	push	ebx
	push	DWORD PTR [esi+52]
	cmove	eax, ebx
	mov	DWORD PTR _firstChild$1$[ebp], eax
	call	_xmlAddChild
	add	esp, 8
	mov	ebx, eax
$LN83@xmlParseRe:

; 7327 : 		    }
; 7328 : 		    if (cur == ent->last) {

	mov	eax, DWORD PTR _cur$1$[ebp]
	cmp	eax, DWORD PTR [edi+16]
	je	SHORT $LN251@xmlParseRe

; 7338 : 
; 7339 : 			break;
; 7340 : 		    }
; 7341 : 		    cur = cur->next;

	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LL6@xmlParseRe

; 7381 : 		    }
; 7382 : 		    if (cur == last)

	jmp	SHORT $LN87@xmlParseRe
$LN251@xmlParseRe:

; 7329 : 			/*
; 7330 : 			 * needed to detect some strange empty
; 7331 : 			 * node cases in the reader tests
; 7332 : 			 */
; 7333 : 			if ((ctxt->parseMode == XML_PARSE_READER) &&
; 7334 : 			    (nw != NULL) &&
; 7335 : 			    (nw->type == XML_ELEMENT_NODE) &&

	cmp	DWORD PTR [esi+436], 5
	jne	SHORT $LN87@xmlParseRe
	test	ebx, ebx
	je	SHORT $LN87@xmlParseRe
	cmp	DWORD PTR [ebx+4], 1
	jne	SHORT $LN87@xmlParseRe
	cmp	DWORD PTR [ebx+12], 0
	jne	SHORT $LN87@xmlParseRe

; 7336 : 			    (nw->children == NULL))
; 7337 : 			    nw->extra = 1;

	mov	eax, 1
	mov	WORD PTR [ebx+58], ax
$LN87@xmlParseRe:

; 7342 : 		}
; 7343 : #ifdef LIBXML_LEGACY_ENABLED
; 7344 : 		if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)

	cmp	DWORD PTR [edi+48], 2
	jne	$LN245@xmlParseRe

; 14667:     if (xmlEntityRefFunc != NULL) {

	mov	eax, DWORD PTR _xmlEntityRefFunc
	test	eax, eax
	je	$LN245@xmlParseRe

; 14668:         (*xmlEntityRefFunc) (ent, firstNode, lastNode);

	push	ebx
	push	DWORD PTR _firstChild$1$[ebp]

; 14669:     }
; 14670: }

	jmp	$LN278@xmlParseRe
$LN78@xmlParseRe:

; 7345 : 		  xmlAddEntityReference(ent, firstChild, nw);
; 7346 : #endif /* LIBXML_LEGACY_ENABLED */
; 7347 : 	    } else if ((list == NULL) || (ctxt->inputNr > 0)) {

	test	ebx, ebx
	je	SHORT $LN91@xmlParseRe
	cmp	DWORD PTR [esi+40], 0
	jg	SHORT $LN91@xmlParseRe

; 7390 : 		  xmlAddEntityReference(ent, firstChild, nw);
; 7391 : #endif /* LIBXML_LEGACY_ENABLED */
; 7392 : 	    } else {
; 7393 : 		const xmlChar *nbktext;
; 7394 : 
; 7395 : 		/*
; 7396 : 		 * the name change is to avoid coalescing of the
; 7397 : 		 * node with a possible previous text one which
; 7398 : 		 * would make ent->children a dangling pointer
; 7399 : 		 */
; 7400 : 		nbktext = xmlDictLookup(ctxt->dict, BAD_CAST "nbktext",

	push	-1
	push	OFFSET ??_C@_07DALNPEGO@nbktext@
	push	DWORD PTR [esi+296]
	call	_xmlDictLookup

; 7401 : 					-1);
; 7402 : 		if (ent->children->type == XML_TEXT_NODE)

	mov	ecx, DWORD PTR [edi+12]
	add	esp, 12					; 0000000cH
	mov	edx, eax
	cmp	DWORD PTR [ecx+4], 3
	jne	SHORT $LN99@xmlParseRe

; 7403 : 		    ent->children->name = nbktext;

	mov	DWORD PTR [ecx+8], edx
	mov	ecx, DWORD PTR [edi+12]
$LN99@xmlParseRe:

; 7404 : 		if ((ent->last != ent->children) &&

	mov	eax, DWORD PTR [edi+16]
	cmp	eax, ecx
	je	SHORT $LN100@xmlParseRe
	cmp	DWORD PTR [eax+4], 3
	jne	SHORT $LN100@xmlParseRe

; 7405 : 		    (ent->last->type == XML_TEXT_NODE))
; 7406 : 		    ent->last->name = nbktext;

	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [edi+12]
$LN100@xmlParseRe:

; 7407 : 		xmlAddChildList(ctxt->node, ent->children);

	push	ecx
	push	DWORD PTR [esi+52]
	call	_xmlAddChildList
	add	esp, 8
	jmp	$LN245@xmlParseRe
$LN91@xmlParseRe:

; 7348 : 		xmlNodePtr nw = NULL, cur, next, last,
; 7349 : 			   firstChild = NULL;
; 7350 : 
; 7351 : 		/*
; 7352 : 		 * We are copying here, make sure there is no abuse
; 7353 : 		 */
; 7354 : 		ctxt->sizeentcopy += ent->length + 5;

	mov	eax, DWORD PTR [edi+44]
	add	eax, 5
	mov	DWORD PTR _nw$1$[ebp], 0
	add	DWORD PTR [esi+468], eax

; 7355 : 		if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))

	push	DWORD PTR [esi+468]
	mov	DWORD PTR _firstChild$1$[ebp], 0
	push	edi
	push	0
	push	esi
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN273@xmlParseRe

; 7356 : 		    return;
; 7357 : 
; 7358 : 		/*
; 7359 : 		 * Copy the entity child list and make it the new
; 7360 : 		 * entity child list. The goal is to make sure any
; 7361 : 		 * ID or REF referenced will be the one from the
; 7362 : 		 * document content and not the entity copy.
; 7363 : 		 */
; 7364 : 		cur = ent->children;

	mov	ebx, DWORD PTR [edi+12]

; 7365 : 		ent->children = NULL;

	mov	DWORD PTR [edi+12], eax

; 7366 : 		last = ent->last;

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR _last$1$[ebp], eax

; 7367 : 		ent->last = NULL;

	mov	DWORD PTR [edi+16], 0

; 7368 : 		while (cur != NULL) {

	test	ebx, ebx
	je	SHORT $LN272@xmlParseRe
	npad	10
$LL8@xmlParseRe:

; 7369 : 		    next = cur->next;

	mov	eax, DWORD PTR [ebx+24]

; 7370 : 		    cur->next = NULL;
; 7371 : 		    cur->parent = NULL;
; 7372 : 		    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);

	push	1
	mov	DWORD PTR [ebx+24], 0
	mov	DWORD PTR [ebx+20], 0
	push	DWORD PTR [esi+8]
	mov	DWORD PTR _next$1$[ebp], eax
	push	ebx
	call	_xmlDocCopyNode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _nw$1$[ebp], eax

; 7373 : 		    if (nw != NULL) {

	test	eax, eax
	je	SHORT $LN93@xmlParseRe

; 7374 : 			if (nw->_private == NULL)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN94@xmlParseRe

; 7375 : 			    nw->_private = cur->_private;

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ecx
$LN94@xmlParseRe:

; 7376 : 			if (firstChild == NULL){
; 7377 : 			    firstChild = cur;
; 7378 : 			}
; 7379 : 			xmlAddChild((xmlNodePtr) ent, nw);

	push	eax
	push	edi
	call	_xmlAddChild

; 7380 : 			xmlAddChild(ctxt->node, cur);

	push	ebx
	push	DWORD PTR [esi+52]
	call	_xmlAddChild
	mov	ecx, DWORD PTR _firstChild$1$[ebp]
	add	esp, 16					; 00000010H
	test	ecx, ecx
	mov	eax, ebx
	cmovne	eax, ecx
	mov	DWORD PTR _firstChild$1$[ebp], eax
$LN93@xmlParseRe:

; 7381 : 		    }
; 7382 : 		    if (cur == last)

	cmp	ebx, DWORD PTR _last$1$[ebp]
	je	SHORT $LN272@xmlParseRe

; 7383 : 			break;
; 7384 : 		    cur = next;

	mov	eax, DWORD PTR _next$1$[ebp]
	mov	ebx, eax
	test	eax, eax
	jne	SHORT $LL8@xmlParseRe
$LN272@xmlParseRe:

; 7385 : 		}
; 7386 : 		if (ent->owner == 0)

	cmp	DWORD PTR [edi+68], 0
	jne	SHORT $LN97@xmlParseRe

; 7387 : 		    ent->owner = 1;

	mov	DWORD PTR [edi+68], 1
$LN97@xmlParseRe:

; 7388 : #ifdef LIBXML_LEGACY_ENABLED
; 7389 : 		if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)

	cmp	DWORD PTR [edi+48], 2
	jne	SHORT $LN245@xmlParseRe

; 14667:     if (xmlEntityRefFunc != NULL) {

	mov	eax, DWORD PTR _xmlEntityRefFunc
	test	eax, eax
	je	SHORT $LN245@xmlParseRe

; 14668:         (*xmlEntityRefFunc) (ent, firstNode, lastNode);

	push	DWORD PTR _nw$1$[ebp]
	push	DWORD PTR _firstChild$1$[ebp]
$LN278@xmlParseRe:

; 7408 : 	    }
; 7409 : 
; 7410 : 	    /*
; 7411 : 	     * This is to avoid a nasty side effect, see
; 7412 : 	     * characters() in SAX.c
; 7413 : 	     */
; 7414 : 	    ctxt->nodemem = 0;

	push	edi
	call	eax
	add	esp, 12					; 0000000cH
$LN245@xmlParseRe:
	pop	edi
	mov	DWORD PTR [esi+264], 0

; 7415 : 	    ctxt->nodelen = 0;

	mov	DWORD PTR [esi+260], 0
	pop	esi

; 7416 : 	    return;
; 7417 : 	}
; 7418 :     }
; 7419 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlParseRe:

; 7065 :         (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
; 7066 : 	val = ent->content;

	mov	ebx, DWORD PTR [edi+40]

; 7067 : 	if (val == NULL) return;

	test	ebx, ebx
	je	SHORT $LN273@xmlParseRe

; 7068 : 	/*
; 7069 : 	 * inline the entity.
; 7070 : 	 */
; 7071 : 	if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN273@xmlParseRe
	cmp	DWORD PTR [edi+68], 0
	je	SHORT $LN273@xmlParseRe
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN273@xmlParseRe

; 7072 : 	    (!ctxt->disableSAX))
; 7073 : 	    ctxt->sax->characters(ctxt->userData, val, xmlStrlen(val));

	push	ebx
	call	_xmlStrlen
	push	eax
	mov	eax, DWORD PTR [edi+68]
	push	ebx
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 16					; 00000010H
$LN273@xmlParseRe:
	pop	edi
$LN30@xmlParseRe:
	pop	esi

; 7416 : 	    return;
; 7417 : 	}
; 7418 :     }
; 7419 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseReference ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEntityRef
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlParseEntityRef PROC					; COMDAT

; 7450 : xmlParseEntityRef(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	cmp	DWORD PTR [esi+292], edi
	jne	SHORT $LN4@xmlParseEn

; 7451 :     const xmlChar *name;
; 7452 :     xmlEntityPtr ent = NULL;
; 7453 : 
; 7454 :     GROW;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN4@xmlParseEn
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN4@xmlParseEn:

; 7455 :     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN105@xmlParseEn

; 7456 :         return(NULL);
; 7457 : 
; 7458 :     if (RAW != '&')

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 38			; 00000026H
	jne	SHORT $LN105@xmlParseEn

; 7459 :         return(NULL);
; 7460 :     NEXT;

	push	esi
	call	_xmlNextChar

; 7461 :     name = xmlParseName(ctxt);

	push	esi
	call	_xmlParseName
	mov	ebx, eax
	add	esp, 8

; 7462 :     if (name == NULL) {

	test	ebx, ebx
	jne	SHORT $LN7@xmlParseEn

; 7463 : 	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0BM@NMGBIIDP@xmlParseEntityRef?3?5no?5name?6@
	push	68					; 00000044H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN105@xmlParseEn:

; 7603 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlParseEn:

; 7464 : 		       "xmlParseEntityRef: no name\n");
; 7465 :         return(NULL);
; 7466 :     }
; 7467 :     if (RAW != ';') {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 59			; 0000003bH
	je	SHORT $LN8@xmlParseEn

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], edi
	je	SHORT $LN36@xmlParseEn
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN105@xmlParseEn
$LN36@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BJ@KLEMOBLL@EntityRef?3?5expecting?5?8?$DL?8@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	23					; 00000017H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 23			; 00000017H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], edi

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], edi
	jne	SHORT $LN105@xmlParseEn
	pop	edi

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1

; 7603 : }

	xor	eax, eax
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlParseEn:

; 7468 : 	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
; 7469 : 	return(NULL);
; 7470 :     }
; 7471 :     NEXT;

	push	esi
	call	_xmlNextChar
	add	esp, 4

; 7472 : 
; 7473 :     /*
; 7474 :      * Predefined entities override any extra definition
; 7475 :      */
; 7476 :     if ((ctxt->options & XML_PARSE_OLDSAX) == 0) {

	test	DWORD PTR [esi+360], 1048576		; 00100000H
	jne	SHORT $LN104@xmlParseEn

; 7477 :         ent = xmlGetPredefinedEntity(name);

	push	ebx
	call	_xmlGetPredefinedEntity
	mov	edi, eax
	add	esp, 4

; 7478 :         if (ent != NULL)

	test	edi, edi
	jne	$LN31@xmlParseEn
$LN104@xmlParseEn:

; 7479 :             return(ent);
; 7480 :     }
; 7481 : 
; 7482 :     /*
; 7483 :      * Increase the number of entity references parsed
; 7484 :      */
; 7485 :     ctxt->nbentities++;

	inc	DWORD PTR [esi+440]

; 7486 : 
; 7487 :     /*
; 7488 :      * Ask first SAX for entity resolution, otherwise try the
; 7489 :      * entities which may have stored in the parser context.
; 7490 :      */
; 7491 :     if (ctxt->sax != NULL) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN14@xmlParseEn

; 7492 : 	if (ctxt->sax->getEntity != NULL)

	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	je	SHORT $LN12@xmlParseEn

; 7493 : 	    ent = ctxt->sax->getEntity(ctxt->userData, name);

	push	ebx
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 8
	mov	edi, eax
$LN12@xmlParseEn:

; 7494 : 	if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, 1
	jne	SHORT $LN14@xmlParseEn
	test	edi, edi
	jne	SHORT $LN14@xmlParseEn
	test	DWORD PTR [esi+360], 1048576		; 00100000H
	je	SHORT $LN103@xmlParseEn

; 7495 : 	    (ctxt->options & XML_PARSE_OLDSAX))
; 7496 : 	    ent = xmlGetPredefinedEntity(name);

	push	ebx
	call	_xmlGetPredefinedEntity
	mov	edi, eax
	add	esp, 4
	mov	eax, DWORD PTR [esi+12]

; 7497 : 	if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&

	cmp	eax, 1
	jne	SHORT $LN14@xmlParseEn
	test	edi, edi
	jne	SHORT $LN14@xmlParseEn
$LN103@xmlParseEn:
	cmp	DWORD PTR [esi+4], esi
	jne	SHORT $LN14@xmlParseEn

; 7498 : 	    (ctxt->userData==ctxt)) {
; 7499 : 	    ent = xmlSAX2GetEntity(ctxt, name);

	push	ebx
	push	esi
	call	_xmlSAX2GetEntity
	add	esp, 8
	mov	edi, eax
$LN14@xmlParseEn:

; 7500 : 	}
; 7501 :     }
; 7502 :     if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR [esi+172]
	cmp	ecx, -1
	je	$LN105@xmlParseEn

; 7503 : 	return(NULL);
; 7504 :     /*
; 7505 :      * [ WFC: Entity Declared ]
; 7506 :      * In a document without any DTD, a document with only an
; 7507 :      * internal DTD subset which contains no parameter entity
; 7508 :      * references, or a document with "standalone='yes'", the
; 7509 :      * Name given in the entity reference must match that in an
; 7510 :      * entity declaration, except that well-formed documents
; 7511 :      * need not declare any of the following entities: amp, lt,
; 7512 :      * gt, apos, quot.
; 7513 :      * The declaration of a parameter entity must precede any
; 7514 :      * reference to it.
; 7515 :      * Similarly, the declaration of a general entity must
; 7516 :      * precede any reference to it which appears in a default
; 7517 :      * value in an attribute-list declaration. Note that if
; 7518 :      * entities are declared in the external subset or in
; 7519 :      * external parameter entities, a non-validating processor
; 7520 :      * is not obligated to read and process their declarations;
; 7521 :      * for such documents, the rule that an entity must be
; 7522 :      * declared is a well-formedness constraint only if
; 7523 :      * standalone='yes'.
; 7524 :      */
; 7525 :     if (ent == NULL) {

	test	edi, edi
	jne	SHORT $LN16@xmlParseEn

; 7526 : 	if ((ctxt->standalone == 1) ||

	cmp	DWORD PTR [esi+28], 1
	je	SHORT $LN20@xmlParseEn
	cmp	DWORD PTR [esi+88], edi
	jne	SHORT $LN18@xmlParseEn
	cmp	DWORD PTR [esi+92], edi
	je	SHORT $LN20@xmlParseEn
$LN18@xmlParseEn:

; 7530 : 		     "Entity '%s' not defined\n", name);
; 7531 : 	} else {
; 7532 : 	    xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,

	push	ebx
	push	OFFSET ??_C@_0BJ@KIKIJMLK@Entity?5?8?$CFs?8?5not?5defined?6@
	push	27					; 0000001bH
	push	esi
	call	_xmlErrMsgStr
	add	esp, 16					; 00000010H

; 7533 : 		     "Entity '%s' not defined\n", name);
; 7534 : 	    if ((ctxt->inSubset == 0) &&
; 7535 : 		(ctxt->sax != NULL) &&

	cmp	DWORD PTR [esi+216], 0
	jne	SHORT $LN21@xmlParseEn
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN21@xmlParseEn
	mov	eax, DWORD PTR [eax+64]
	test	eax, eax
	je	SHORT $LN21@xmlParseEn

; 7536 : 		(ctxt->sax->reference != NULL)) {
; 7537 : 		ctxt->sax->reference(ctxt->userData, name);

	push	ebx
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 8
	jmp	SHORT $LN21@xmlParseEn
$LN20@xmlParseEn:

; 7527 : 	    ((ctxt->hasExternalSubset == 0) &&
; 7528 : 	     (ctxt->hasPErefs == 0))) {
; 7529 : 	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,

	push	ebx
	push	OFFSET ??_C@_0BJ@KIKIJMLK@Entity?5?8?$CFs?8?5not?5defined?6@
	push	26					; 0000001aH
	push	esi
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H
$LN21@xmlParseEn:

; 7538 : 	    }
; 7539 : 	}
; 7540 : 	xmlParserEntityCheck(ctxt, 0, ent, 0);

	push	0
	push	0
	push	0
	push	esi
	call	_xmlParserEntityCheck

; 7588 : 	     "Attempt to reference the parameter entity '%s'\n",
; 7589 : 			      name);
; 7590 : 	    break;
; 7591 : 	    default:
; 7592 : 	    break;
; 7593 : 	}
; 7594 :     }
; 7595 : 
; 7596 :     /*
; 7597 :      * [ WFC: No Recursion ]
; 7598 :      * A parsed entity must not contain a recursive reference
; 7599 :      * to itself, either directly or indirectly.
; 7600 :      * Done somewhere else
; 7601 :      */
; 7602 :     return(ent);

	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+100], 0

; 7603 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN16@xmlParseEn:

; 7541 : 	ctxt->valid = 0;
; 7542 :     }
; 7543 : 
; 7544 :     /*
; 7545 :      * [ WFC: Parsed Entity ]
; 7546 :      * An entity reference must not contain the name of an
; 7547 :      * unparsed entity
; 7548 :      */
; 7549 :     else if (ent->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {

	mov	eax, DWORD PTR [edi+48]
	cmp	eax, 3
	jne	SHORT $LN22@xmlParseEn

; 7550 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,

	push	ebx
	push	OFFSET ??_C@_0CI@ILCMJJAO@Entity?5reference?5to?5unparsed?5en@
	push	28					; 0000001cH

; 7588 : 	     "Attempt to reference the parameter entity '%s'\n",
; 7589 : 			      name);
; 7590 : 	    break;
; 7591 : 	    default:
; 7592 : 	    break;
; 7593 : 	}
; 7594 :     }
; 7595 : 
; 7596 :     /*
; 7597 :      * [ WFC: No Recursion ]
; 7598 :      * A parsed entity must not contain a recursive reference
; 7599 :      * to itself, either directly or indirectly.
; 7600 :      * Done somewhere else
; 7601 :      */
; 7602 :     return(ent);

	push	esi
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 7603 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN22@xmlParseEn:

; 7551 : 		 "Entity reference to unparsed entity %s\n", name);
; 7552 :     }
; 7553 : 
; 7554 :     /*
; 7555 :      * [ WFC: No External Entity References ]
; 7556 :      * Attribute values cannot contain direct or indirect
; 7557 :      * entity references to external entities.
; 7558 :      */
; 7559 :     else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&

	cmp	ecx, 12					; 0000000cH
	jne	SHORT $LN26@xmlParseEn
	cmp	eax, 2
	jne	SHORT $LN24@xmlParseEn

; 7560 : 	     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
; 7561 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,

	push	ebx
	push	OFFSET ??_C@_0CL@HLODLGOA@Attribute?5references?5external?5e@
	push	29					; 0000001dH

; 7588 : 	     "Attempt to reference the parameter entity '%s'\n",
; 7589 : 			      name);
; 7590 : 	    break;
; 7591 : 	    default:
; 7592 : 	    break;
; 7593 : 	}
; 7594 :     }
; 7595 : 
; 7596 :     /*
; 7597 :      * [ WFC: No Recursion ]
; 7598 :      * A parsed entity must not contain a recursive reference
; 7599 :      * to itself, either directly or indirectly.
; 7600 :      * Done somewhere else
; 7601 :      */
; 7602 :     return(ent);

	push	esi
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 7603 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN24@xmlParseEn:

; 7562 : 	     "Attribute references external entity '%s'\n", name);
; 7563 :     }
; 7564 :     /*
; 7565 :      * [ WFC: No < in Attribute Values ]
; 7566 :      * The replacement text of any entity referred to directly or
; 7567 :      * indirectly in an attribute value (other than "&lt;") must
; 7568 :      * not contain a <.
; 7569 :      */
; 7570 :     else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
; 7571 : 	     (ent != NULL) && 

	cmp	eax, 6
	je	SHORT $LN26@xmlParseEn

; 7572 : 	     (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY)) {
; 7573 : 	if (((ent->checked & 1) || (ent->checked == 0)) &&
; 7574 : 	     (ent->content != NULL) && (xmlStrchr(ent->content, '<'))) {

	mov	eax, DWORD PTR [edi+72]
	test	al, 1
	jne	SHORT $LN29@xmlParseEn
	test	eax, eax
	jne	SHORT $LN31@xmlParseEn
$LN29@xmlParseEn:
	mov	eax, DWORD PTR [edi+40]
	test	eax, eax
	je	SHORT $LN31@xmlParseEn
	push	60					; 0000003cH
	push	eax
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN31@xmlParseEn

; 7575 : 	    xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,

	push	ebx
	push	OFFSET ??_C@_0DI@FDECCCAO@?8?$DM?8?5in?5entity?5?8?$CFs?8?5is?5not?5allow@
	push	38					; 00000026H

; 7588 : 	     "Attempt to reference the parameter entity '%s'\n",
; 7589 : 			      name);
; 7590 : 	    break;
; 7591 : 	    default:
; 7592 : 	    break;
; 7593 : 	}
; 7594 :     }
; 7595 : 
; 7596 :     /*
; 7597 :      * [ WFC: No Recursion ]
; 7598 :      * A parsed entity must not contain a recursive reference
; 7599 :      * to itself, either directly or indirectly.
; 7600 :      * Done somewhere else
; 7601 :      */
; 7602 :     return(ent);

	push	esi
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 7603 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN26@xmlParseEn:

; 7576 : 	"'<' in entity '%s' is not allowed in attributes values\n", name);
; 7577 :         }
; 7578 :     }
; 7579 : 
; 7580 :     /*
; 7581 :      * Internal check, no parameter entities here ...
; 7582 :      */
; 7583 :     else {
; 7584 : 	switch (ent->etype) {

	add	eax, -4					; fffffffcH
	cmp	eax, 1
	ja	SHORT $LN31@xmlParseEn

; 7585 : 	    case XML_INTERNAL_PARAMETER_ENTITY:
; 7586 : 	    case XML_EXTERNAL_PARAMETER_ENTITY:
; 7587 : 	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,

	push	ebx
	push	OFFSET ??_C@_0DA@CCPGIFBP@Attempt?5to?5reference?5the?5parame@
	push	30					; 0000001eH

; 7588 : 	     "Attempt to reference the parameter entity '%s'\n",
; 7589 : 			      name);
; 7590 : 	    break;
; 7591 : 	    default:
; 7592 : 	    break;
; 7593 : 	}
; 7594 :     }
; 7595 : 
; 7596 :     /*
; 7597 :      * [ WFC: No Recursion ]
; 7598 :      * A parsed entity must not contain a recursive reference
; 7599 :      * to itself, either directly or indirectly.
; 7600 :      * Done somewhere else
; 7601 :      */
; 7602 :     return(ent);

	push	esi
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H
$LN31@xmlParseEn:

; 7603 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlParseEntityRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseCharRef
_TEXT	SEGMENT
_outofrange$1$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_xmlParseCharRef PROC					; COMDAT

; 2285 : xmlParseCharRef(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	xor	edi, edi
	mov	DWORD PTR _outofrange$1$[ebp], ebx
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	cmp	BYTE PTR [ecx], 38			; 00000026H
	jne	$LN27@xmlParseCh

; 2286 :     unsigned int val = 0;
; 2287 :     int count = 0;
; 2288 :     unsigned int outofrange = 0;
; 2289 : 
; 2290 :     /*
; 2291 :      * Using RAW/CUR/NEXT is okay since we are working on ASCII range here
; 2292 :      */
; 2293 :     if ((RAW == '&') && (NXT(1) == '#') &&

	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, 35					; 00000023H
	jne	$LN27@xmlParseCh
	cmp	BYTE PTR [ecx+2], 120			; 00000078H
	jne	$LN12@xmlParseCh

; 2294 :         (NXT(2) == 'x')) {
; 2295 : 	SKIP(3);

	add	DWORD PTR [esi+200], 3
	add	DWORD PTR [eax+16], 3
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 3
	mov	edx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [edx+16]
	cmp	BYTE PTR [eax], bl
	jne	SHORT $LN2@xmlParseCh
	push	250					; 000000faH
	push	edx
	call	_xmlParserInputGrow
	mov	edx, DWORD PTR [esi+36]
	add	esp, 8
$LN2@xmlParseCh:

; 2296 : 	GROW;

	mov	ecx, edx
	cmp	DWORD PTR [esi+292], ebx
	jne	SHORT $LN119@xmlParseCh
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN119@xmlParseCh
	push	esi
	call	_xmlGROW
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
$LN119@xmlParseCh:

; 2297 : 	while (RAW != ';') { /* loop blocked by count */

	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 59			; 0000003bH
	je	$LN11@xmlParseCh
	npad	4
$LL5@xmlParseCh:

; 2298 : 	    if (count++ > 20) {

	mov	eax, ebx
	inc	ebx
	cmp	eax, 20					; 00000014H
	jle	SHORT $LN18@xmlParseCh

; 2299 : 		count = 0;

	xor	ebx, ebx

; 2300 : 		GROW;

	cmp	DWORD PTR [esi+292], ebx
	jne	SHORT $LN17@xmlParseCh
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [ecx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN17@xmlParseCh
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN17@xmlParseCh:

; 2301 :                 if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	$LN122@xmlParseCh
$LN18@xmlParseCh:

; 2302 :                     return(0);
; 2303 : 	    }
; 2304 : 	    if ((RAW >= '0') && (RAW <= '9'))

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	mov	cl, BYTE PTR [eax]
	lea	eax, DWORD PTR [ecx-48]
	cmp	al, 9
	ja	SHORT $LN19@xmlParseCh

; 2305 : 	        val = val * 16 + (CUR - '0');

	shl	edi, 4
	add	edi, -48				; ffffffd0H
	jmp	SHORT $LN135@xmlParseCh
$LN19@xmlParseCh:

; 2306 : 	    else if ((RAW >= 'a') && (RAW <= 'f') && (count < 20))

	cmp	cl, 97					; 00000061H
	jb	SHORT $LN21@xmlParseCh
	cmp	cl, 102					; 00000066H
	ja	SHORT $LN21@xmlParseCh
	cmp	ebx, 20					; 00000014H
	jge	SHORT $LN21@xmlParseCh

; 2307 : 	        val = val * 16 + (CUR - 'a') + 10;

	shl	edi, 4
	add	edi, -87				; ffffffa9H
	jmp	SHORT $LN135@xmlParseCh
$LN21@xmlParseCh:

; 2308 : 	    else if ((RAW >= 'A') && (RAW <= 'F') && (count < 20))

	cmp	cl, 65					; 00000041H
	jb	SHORT $LN23@xmlParseCh
	cmp	cl, 70					; 00000046H
	ja	SHORT $LN23@xmlParseCh
	cmp	ebx, 20					; 00000014H
	jge	SHORT $LN23@xmlParseCh

; 2309 : 	        val = val * 16 + (CUR - 'A') + 10;

	shl	edi, 4
	add	edi, -55				; ffffffc9H
$LN135@xmlParseCh:

; 2312 : 		val = 0;
; 2313 : 		break;
; 2314 : 	    }
; 2315 : 	    if (val > 0x10FFFF)
; 2316 : 	        outofrange = val;
; 2317 : 
; 2318 : 	    NEXT;

	movzx	eax, cl
	add	edi, eax
	cmp	edi, 1114111				; 0010ffffH
	mov	eax, edi
	push	esi
	cmovbe	eax, DWORD PTR _outofrange$1$[ebp]
	mov	DWORD PTR _outofrange$1$[ebp], eax
	call	_xmlNextChar
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4

; 2319 : 	    count++;

	inc	ebx
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 59			; 0000003bH
	jne	$LL5@xmlParseCh

; 2334 :                 if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _outofrange$1$[ebp]
	mov	DWORD PTR _outofrange$1$[ebp], eax
	jmp	$LN11@xmlParseCh
$LN23@xmlParseCh:

; 2310 : 	    else {
; 2311 : 		xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);

	push	0
	push	6

; 2320 : 	}
; 2321 : 	if (RAW == ';') {
; 2322 : 	    /* on purpose to avoid reentrancy problems with NEXT and SKIP */
; 2323 : 	    ctxt->input->col++;
; 2324 : 	    ctxt->nbChars ++;
; 2325 : 	    ctxt->input->cur++;
; 2326 : 	}

	jmp	$LN137@xmlParseCh
$LN12@xmlParseCh:

; 2327 :     } else if  ((RAW == '&') && (NXT(1) == '#')) {

	cmp	dl, 35					; 00000023H
	jne	$LN27@xmlParseCh

; 2328 : 	SKIP(2);

	add	DWORD PTR [esi+200], 2
	add	DWORD PTR [eax+16], 2
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 2
	mov	edx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [edx+16]
	cmp	BYTE PTR [eax], bl
	jne	SHORT $LN7@xmlParseCh
	push	250					; 000000faH
	push	edx
	call	_xmlParserInputGrow
	mov	edx, DWORD PTR [esi+36]
	add	esp, 8
$LN7@xmlParseCh:

; 2329 : 	GROW;

	mov	ecx, edx
	cmp	DWORD PTR [esi+292], ebx
	jne	SHORT $LN120@xmlParseCh
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN120@xmlParseCh
	push	esi
	call	_xmlGROW
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
$LN120@xmlParseCh:

; 2330 : 	while (RAW != ';') { /* loop blocked by count */

	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 59			; 0000003bH
	je	$LN11@xmlParseCh
	npad	2
$LL10@xmlParseCh:

; 2331 : 	    if (count++ > 20) {

	mov	eax, ebx
	inc	ebx
	cmp	eax, 20					; 00000014H
	jle	SHORT $LN33@xmlParseCh

; 2332 : 		count = 0;

	xor	ebx, ebx

; 2333 : 		GROW;

	cmp	DWORD PTR [esi+292], ebx
	jne	SHORT $LN32@xmlParseCh
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [ecx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN32@xmlParseCh
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN32@xmlParseCh:

; 2334 :                 if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	$LN122@xmlParseCh
$LN33@xmlParseCh:

; 2335 :                     return(0);
; 2336 : 	    }
; 2337 : 	    if ((RAW >= '0') && (RAW <= '9'))

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	mov	dl, BYTE PTR [eax]
	lea	eax, DWORD PTR [edx-48]
	cmp	al, 9
	ja	SHORT $LN34@xmlParseCh

; 2338 : 	        val = val * 10 + (CUR - '0');

	movzx	eax, dl
	lea	ecx, DWORD PTR [edi-6]
	lea	ecx, DWORD PTR [edi+ecx*4]

; 2341 : 		val = 0;
; 2342 : 		break;
; 2343 : 	    }
; 2344 : 	    if (val > 0x10FFFF)
; 2345 : 	        outofrange = val;
; 2346 : 
; 2347 : 	    NEXT;

	push	esi
	lea	edi, DWORD PTR [eax+ecx*2]
	cmp	edi, 1114111				; 0010ffffH
	mov	eax, edi
	cmovbe	eax, DWORD PTR _outofrange$1$[ebp]
	mov	DWORD PTR _outofrange$1$[ebp], eax
	call	_xmlNextChar
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4

; 2348 : 	    count++;

	inc	ebx
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 59			; 0000003bH
	jne	SHORT $LL10@xmlParseCh

; 2334 :                 if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _outofrange$1$[ebp]
	mov	DWORD PTR _outofrange$1$[ebp], eax
	jmp	SHORT $LN11@xmlParseCh
$LN34@xmlParseCh:

; 2339 : 	    else {
; 2340 : 		xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);

	push	0
	push	7
$LN137@xmlParseCh:

; 2349 : 	}
; 2350 : 	if (RAW == ';') {
; 2351 : 	    /* on purpose to avoid reentrancy problems with NEXT and SKIP */
; 2352 : 	    ctxt->input->col++;
; 2353 : 	    ctxt->nbChars ++;
; 2354 : 	    ctxt->input->cur++;
; 2355 : 	}
; 2356 :     } else {
; 2357 :         xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
; 2358 :     }
; 2359 : 
; 2360 :     /*
; 2361 :      * [ WFC: Legal Character ]
; 2362 :      * Characters referred to using character references must match the
; 2363 :      * production for Char.
; 2364 :      */
; 2365 :     if ((IS_CHAR(val) && (outofrange == 0))) {

	push	esi
	call	_xmlFatalErr
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
	xor	edi, edi
$LN11@xmlParseCh:
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 59			; 0000003bH
	jne	SHORT $LN117@xmlParseCh
	inc	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [esi+36]
	inc	DWORD PTR [esi+200]
	inc	DWORD PTR [eax+16]
$LN117@xmlParseCh:
	cmp	edi, 256				; 00000100H
	jae	SHORT $LN49@xmlParseCh
	cmp	edi, 9
	jb	SHORT $LN41@xmlParseCh
	cmp	edi, 10					; 0000000aH
	jbe	SHORT $LN132@xmlParseCh
$LN41@xmlParseCh:
	cmp	edi, 13					; 0000000dH
	je	SHORT $LN132@xmlParseCh
	cmp	edi, 32					; 00000020H
	jae	SHORT $LN132@xmlParseCh
	jmp	$LN38@xmlParseCh
$LN49@xmlParseCh:
	cmp	edi, 55295				; 0000d7ffH
	jbe	SHORT $LN132@xmlParseCh
	cmp	edi, 57344				; 0000e000H
	jb	SHORT $LN44@xmlParseCh
	cmp	edi, 65533				; 0000fffdH
	jbe	SHORT $LN132@xmlParseCh
$LN44@xmlParseCh:
	lea	ecx, DWORD PTR [edi-65536]
	cmp	ecx, 1048575				; 000fffffH
	ja	SHORT $LN38@xmlParseCh
$LN132@xmlParseCh:
	cmp	DWORD PTR _outofrange$1$[ebp], 0
	jne	SHORT $LN38@xmlParseCh

; 2366 :         return(val);

	mov	eax, edi
	pop	edi

; 2369 :                           "xmlParseCharRef: invalid xmlChar value %d\n",
; 2370 : 	                  val);
; 2371 :     }
; 2372 :     return(0);
; 2373 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlParseCh:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], ebx
	je	SHORT $LN54@xmlParseCh
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN38@xmlParseCh
$LN54@xmlParseCh:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BH@OCLALBPG@CharRef?3?5invalid?5value@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	8
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 8
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], ebx

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], ebx
	jne	SHORT $LN38@xmlParseCh

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN38@xmlParseCh:

; 2367 :     } else {
; 2368 :         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,

	push	edi
	push	OFFSET ??_C@_0CL@KEGPHPPF@xmlParseCharRef?3?5invalid?5xmlCha@
	push	9
	push	esi
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H
$LN122@xmlParseCh:

; 2369 :                           "xmlParseCharRef: invalid xmlChar value %d\n",
; 2370 : 	                  val);
; 2371 :     }
; 2372 :     return(0);
; 2373 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseCharRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseMarkupDecl
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlParseMarkupDecl PROC				; COMDAT

; 6784 : xmlParseMarkupDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN4@xmlParseMa

; 6785 :     GROW;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN4@xmlParseMa
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN4@xmlParseMa:

; 6786 :     if (CUR == '<') {

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	cmp	BYTE PTR [ecx], 60			; 0000003cH
	jne	SHORT $LN16@xmlParseMa

; 6787 :         if (NXT(1) == '!') {

	mov	al, BYTE PTR [ecx+1]
	cmp	al, 33					; 00000021H
	jne	SHORT $LN6@xmlParseMa

; 6788 : 	    switch (NXT(2)) {

	movzx	eax, BYTE PTR [ecx+2]
	add	eax, -45				; ffffffd3H
	cmp	eax, 33					; 00000021H
	ja	SHORT $LN16@xmlParseMa
	movzx	eax, BYTE PTR $LN21@xmlParseMa[eax]
	jmp	DWORD PTR $LN24@xmlParseMa[eax*4]
$LN8@xmlParseMa:

; 6789 : 	        case 'E':
; 6790 : 		    if (NXT(3) == 'L')

	mov	al, BYTE PTR [ecx+3]
	cmp	al, 76					; 0000004cH
	jne	SHORT $LN9@xmlParseMa

; 6791 : 			xmlParseElementDecl(ctxt);

	push	esi
	call	_xmlParseElementDecl
	jmp	SHORT $LN22@xmlParseMa
$LN9@xmlParseMa:

; 6792 : 		    else if (NXT(3) == 'N')

	cmp	al, 78					; 0000004eH
	jne	SHORT $LN16@xmlParseMa

; 6793 : 			xmlParseEntityDecl(ctxt);

	push	esi
	call	_xmlParseEntityDecl

; 6794 : 		    break;

	jmp	SHORT $LN22@xmlParseMa
$LN12@xmlParseMa:

; 6795 : 	        case 'A':
; 6796 : 		    xmlParseAttributeListDecl(ctxt);

	push	esi
	call	_xmlParseAttributeListDecl

; 6797 : 		    break;

	jmp	SHORT $LN22@xmlParseMa
$LN13@xmlParseMa:

; 6798 : 	        case 'N':
; 6799 : 		    xmlParseNotationDecl(ctxt);

	push	esi
	call	_xmlParseNotationDecl

; 6800 : 		    break;

	jmp	SHORT $LN22@xmlParseMa
$LN14@xmlParseMa:

; 6801 : 	        case '-':
; 6802 : 		    xmlParseComment(ctxt);

	push	esi
	call	_xmlParseComment

; 6803 : 		    break;
; 6804 : 		default:
; 6805 : 		    /* there is an error but it will be detected later */
; 6806 : 		    break;
; 6807 : 	    }
; 6808 : 	} else if (NXT(1) == '?') {

	jmp	SHORT $LN22@xmlParseMa
$LN6@xmlParseMa:
	cmp	al, 63					; 0000003fH
	jne	SHORT $LN16@xmlParseMa

; 6809 : 	    xmlParsePI(ctxt);

	push	esi
	call	_xmlParsePI
$LN22@xmlParseMa:

; 6810 : 	}
; 6811 :     }
; 6812 : 
; 6813 :     /*
; 6814 :      * detect requirement to exit there and act accordingly
; 6815 :      * and avoid having instate overriden later on
; 6816 :      */
; 6817 :     if (ctxt->instate == XML_PARSER_EOF)

	add	esp, 4
$LN16@xmlParseMa:
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN1@xmlParseMa

; 6818 :         return;
; 6819 : 
; 6820 :     /*
; 6821 :      * Conditional sections are allowed from entities included
; 6822 :      * by PE References in the internal subset.
; 6823 :      */
; 6824 :     if ((ctxt->external == 0) && (ctxt->inputNr > 1)) {

	cmp	DWORD PTR [esi+96], 0
	jne	SHORT $LN19@xmlParseMa
	cmp	DWORD PTR [esi+40], 1
	jle	SHORT $LN19@xmlParseMa

; 6825 :         if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 60			; 0000003cH
	jne	SHORT $LN19@xmlParseMa
	cmp	BYTE PTR [eax+1], 33			; 00000021H
	jne	SHORT $LN19@xmlParseMa
	cmp	BYTE PTR [eax+2], 91			; 0000005bH
	jne	SHORT $LN19@xmlParseMa

; 6826 : 	    xmlParseConditionalSections(ctxt);

	push	esi
	call	_xmlParseConditionalSections
	add	esp, 4
$LN19@xmlParseMa:

; 6827 : 	}
; 6828 :     }
; 6829 : 
; 6830 :     ctxt->instate = XML_PARSER_DTD;

	mov	DWORD PTR [esi+172], 3
$LN1@xmlParseMa:
	pop	esi

; 6831 : }

	pop	ebp
	ret	0
	npad	2
$LN24@xmlParseMa:
	DD	$LN14@xmlParseMa
	DD	$LN12@xmlParseMa
	DD	$LN8@xmlParseMa
	DD	$LN13@xmlParseMa
	DD	$LN16@xmlParseMa
$LN21@xmlParseMa:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_xmlParseMarkupDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseElementDecl
_TEXT	SEGMENT
_name$1$ = -8						; size = 4
_content$ = -4						; size = 4
_inputid$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseElementDecl PROC				; COMDAT

; 6510 : xmlParseElementDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	or	ebx, -1
	mov	DWORD PTR _content$[ebp], edi
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 60			; 0000003cH
	jne	$LN34@xmlParseEl

; 6511 :     const xmlChar *name;
; 6512 :     int ret = -1;
; 6513 :     xmlElementContentPtr content  = NULL;
; 6514 : 
; 6515 :     /* GROW; done in the caller */
; 6516 :     if (CMP9(CUR_PTR, '<', '!', 'E', 'L', 'E', 'M', 'E', 'N', 'T')) {

	cmp	BYTE PTR [eax+1], 33			; 00000021H
	jne	$LN34@xmlParseEl
	cmp	BYTE PTR [eax+2], 69			; 00000045H
	jne	$LN34@xmlParseEl
	cmp	BYTE PTR [eax+3], 76			; 0000004cH
	jne	$LN34@xmlParseEl
	cmp	BYTE PTR [eax+4], 69			; 00000045H
	jne	$LN34@xmlParseEl
	cmp	BYTE PTR [eax+5], 77			; 0000004dH
	jne	$LN34@xmlParseEl
	cmp	BYTE PTR [eax+6], 69			; 00000045H
	jne	$LN34@xmlParseEl
	cmp	BYTE PTR [eax+7], 78			; 0000004eH
	jne	$LN34@xmlParseEl
	cmp	BYTE PTR [eax+8], 84			; 00000054H
	jne	$LN34@xmlParseEl

; 6517 : 	int inputid = ctxt->input->id;

	mov	eax, DWORD PTR [ecx+56]

; 6518 : 
; 6519 : 	SKIP(9);

	add	DWORD PTR [esi+200], 9
	add	DWORD PTR [ecx+16], 9
	mov	DWORD PTR _inputid$1$[ebp], eax
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 9
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseEl
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseEl:

; 6520 : 	if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN13@xmlParseEl

; 6521 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CA@CIGPNPNK@Space?5required?5after?5?8ELEMENT?8?6@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 6522 : 		           "Space required after 'ELEMENT'\n");
; 6523 : 	    return(-1);

	or	eax, -1
	pop	edi

; 6601 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlParseEl:

; 6524 : 	}
; 6525 :         name = xmlParseName(ctxt);

	push	esi
	call	_xmlParseName
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _name$1$[ebp], ebx

; 6526 : 	if (name == NULL) {

	test	ebx, ebx
	jne	SHORT $LN14@xmlParseEl

; 6527 : 	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0CK@LMDMNJGO@xmlParseElementDecl?3?5no?5name?5fo@
	push	68					; 00000044H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 6528 : 			   "xmlParseElementDecl: no name for Element\n");
; 6529 : 	    return(-1);

	or	eax, -1
	pop	edi

; 6601 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlParseEl:

; 6530 : 	}
; 6531 : 	if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN15@xmlParseEl

; 6532 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CH@MFBAJJC@Space?5required?5after?5the?5elemen@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN15@xmlParseEl:

; 6533 : 			   "Space required after the element name\n");
; 6534 : 	}
; 6535 : 	if (CMP5(CUR_PTR, 'E', 'M', 'P', 'T', 'Y')) {

	mov	edx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [edx+16]
	mov	cl, BYTE PTR [eax]
	cmp	cl, 69					; 00000045H
	jne	SHORT $LN16@xmlParseEl
	cmp	BYTE PTR [eax+1], 77			; 0000004dH
	jne	SHORT $LN16@xmlParseEl
	cmp	BYTE PTR [eax+2], 80			; 00000050H
	jne	SHORT $LN16@xmlParseEl
	cmp	BYTE PTR [eax+3], 84			; 00000054H
	jne	SHORT $LN16@xmlParseEl
	cmp	BYTE PTR [eax+4], 89			; 00000059H
	jne	SHORT $LN16@xmlParseEl

; 6536 : 	    SKIP(5);

	add	DWORD PTR [esi+200], 5
	add	DWORD PTR [edx+16], 5
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 5
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN5@xmlParseEl
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN5@xmlParseEl:

; 6537 : 	    /*
; 6538 : 	     * Element must always be empty.
; 6539 : 	     */
; 6540 : 	    ret = XML_ELEMENT_TYPE_EMPTY;

	mov	ebx, 1
	jmp	SHORT $LN23@xmlParseEl
$LN16@xmlParseEl:

; 6541 : 	} else if ((RAW == 'A') && (NXT(1) == 'N') &&

	cmp	cl, 65					; 00000041H
	jne	SHORT $LN19@xmlParseEl
	cmp	BYTE PTR [eax+1], 78			; 0000004eH
	jne	SHORT $LN19@xmlParseEl
	cmp	BYTE PTR [eax+2], 89			; 00000059H
	jne	SHORT $LN19@xmlParseEl

; 6542 : 	           (NXT(2) == 'Y')) {
; 6543 : 	    SKIP(3);

	add	DWORD PTR [esi+200], 3
	add	DWORD PTR [edx+16], 3
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 3
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN8@xmlParseEl
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN8@xmlParseEl:

; 6544 : 	    /*
; 6545 : 	     * Element is a generic container.
; 6546 : 	     */
; 6547 : 	    ret = XML_ELEMENT_TYPE_ANY;

	mov	ebx, 2
	jmp	SHORT $LN23@xmlParseEl
$LN19@xmlParseEl:

; 6548 : 	} else if (RAW == '(') {

	cmp	cl, 40					; 00000028H
	jne	$LN22@xmlParseEl

; 6549 : 	    ret = xmlParseElementContentDecl(ctxt, name, &content);

	lea	eax, DWORD PTR _content$[ebp]
	push	eax
	push	ebx
	push	esi
	call	_xmlParseElementContentDecl
	mov	edi, DWORD PTR _content$[ebp]
	add	esp, 12					; 0000000cH
	mov	ebx, eax
$LN23@xmlParseEl:

; 6563 : 	}
; 6564 : 
; 6565 : 	SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 6566 : 
; 6567 : 	if (RAW != '>') {

	mov	edx, DWORD PTR [esi+36]
	add	esp, 4
	mov	ecx, DWORD PTR [edx+16]
	cmp	BYTE PTR [ecx], 62			; 0000003eH
	je	SHORT $LN26@xmlParseEl

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN39@xmlParseEl
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN102@xmlParseEl
$LN39@xmlParseEl:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0N@HPGHEIE@expected?5?8?$DO?8@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	73					; 00000049H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 73			; 00000049H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN102@xmlParseEl

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN102@xmlParseEl:

; 6595 : 	    } else if (content != NULL) {
; 6596 : 		xmlFreeDocElementContent(ctxt->myDoc, content);
; 6597 : 	    }
; 6598 : 	}
; 6599 :     }
; 6600 :     return(ret);

	test	edi, edi
	je	SHORT $LN34@xmlParseEl
$LN104@xmlParseEl:
	push	edi
	push	DWORD PTR [esi+8]
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN34@xmlParseEl:

; 6601 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlParseEl:

; 6568 : 	    xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
; 6569 : 	    if (content != NULL) {
; 6570 : 		xmlFreeDocElementContent(ctxt->myDoc, content);
; 6571 : 	    }
; 6572 : 	} else {
; 6573 : 	    if (inputid != ctxt->input->id) {

	mov	eax, DWORD PTR _inputid$1$[ebp]
	cmp	eax, DWORD PTR [edx+56]
	je	SHORT $LN29@xmlParseEl

; 6574 : 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0DP@KIKIPMFE@Element?5declaration?5doesn?8t?5sta@
	push	90					; 0000005aH
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN29@xmlParseEl:

; 6575 :                                "Element declaration doesn't start and stop in"
; 6576 :                                " the same entity\n");
; 6577 : 	    }
; 6578 : 
; 6579 : 	    NEXT;

	push	esi
	call	_xmlNextChar

; 6580 : 	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&

	mov	eax, DWORD PTR [esi]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN102@xmlParseEl
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN102@xmlParseEl
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN102@xmlParseEl

; 6581 : 		(ctxt->sax->elementDecl != NULL)) {
; 6582 : 		if (content != NULL)

	test	edi, edi
	je	SHORT $LN32@xmlParseEl

; 6583 : 		    content->parent = NULL;

	mov	DWORD PTR [edi+20], 0
	mov	eax, DWORD PTR [esi]
$LN32@xmlParseEl:

; 6584 : 	        ctxt->sax->elementDecl(ctxt->userData, name, ret,

	mov	eax, DWORD PTR [eax+36]
	push	edi
	push	ebx
	push	DWORD PTR _name$1$[ebp]
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 16					; 00000010H

; 6585 : 		                       content);
; 6586 : 		if ((content != NULL) && (content->parent == NULL)) {

	test	edi, edi
	je	SHORT $LN34@xmlParseEl
	cmp	DWORD PTR [edi+20], 0
	jne	SHORT $LN34@xmlParseEl

; 6587 : 		    /*
; 6588 : 		     * this is a trick: if xmlAddElementDecl is called,
; 6589 : 		     * instead of copying the full tree it is plugged directly
; 6590 : 		     * if called from the parser. Avoid duplicating the
; 6591 : 		     * interfaces or change the API/ABI
; 6592 : 		     */
; 6593 : 		    xmlFreeDocElementContent(ctxt->myDoc, content);
; 6594 : 		}

	jmp	SHORT $LN104@xmlParseEl
$LN22@xmlParseEl:

; 6550 : 	} else {
; 6551 : 	    /*
; 6552 : 	     * [ WFC: PEs in Internal Subset ] error handling.
; 6553 : 	     */
; 6554 : 	    if ((RAW == '%') && (ctxt->external == 0) &&

	cmp	cl, 37					; 00000025H
	jne	SHORT $LN24@xmlParseEl
	cmp	DWORD PTR [esi+96], edi
	jne	SHORT $LN24@xmlParseEl
	cmp	DWORD PTR [esi+40], 1
	jne	SHORT $LN24@xmlParseEl

; 6555 : 	        (ctxt->inputNr == 1)) {
; 6556 : 		xmlFatalErrMsg(ctxt, XML_ERR_PEREF_IN_INT_SUBSET,

	mov	ecx, OFFSET ??_C@_0DO@COHAOPDG@PEReference?3?5forbidden?5within?5m@
	mov	eax, 21					; 00000015H

; 6560 : 		      "xmlParseElementDecl: 'EMPTY', 'ANY' or '(' expected\n");
; 6561 :             }
; 6562 : 	    return(-1);

	push	ecx
	push	eax
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
	or	eax, -1
	pop	edi

; 6601 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlParseEl:

; 6557 : 	  "PEReference: forbidden within markup decl in internal subset\n");
; 6558 : 	    } else {
; 6559 : 		xmlFatalErrMsg(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,

	mov	ecx, OFFSET ??_C@_0DF@CHNHOLDO@xmlParseElementDecl?3?5?8EMPTY?8?0?5?8@
	mov	eax, 54					; 00000036H

; 6560 : 		      "xmlParseElementDecl: 'EMPTY', 'ANY' or '(' expected\n");
; 6561 :             }
; 6562 : 	    return(-1);

	push	ecx
	push	eax
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
	or	eax, -1
	pop	edi

; 6601 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseElementDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseElementContentDecl
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_result$ = 16						; size = 4
_xmlParseElementContentDecl PROC			; COMDAT

; 6466 :                            xmlElementContentPtr *result) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+36]
	mov	edi, DWORD PTR [eax+56]
	mov	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 40			; 00000028H
	je	SHORT $LN2@xmlParseEl

; 6467 : 
; 6468 :     xmlElementContentPtr tree = NULL;
; 6469 :     int inputid = ctxt->input->id;
; 6470 :     int res;
; 6471 : 
; 6472 :     *result = NULL;
; 6473 : 
; 6474 :     if (RAW != '(') {
; 6475 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,

	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0CO@FLMKOMHK@xmlParseElementContentDecl?5?3?5?$CFs@
	push	54					; 00000036H
	push	esi
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H
$LN9@xmlParseEl:

; 6494 : }

	pop	edi
	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN2@xmlParseEl:

; 6476 : 		"xmlParseElementContentDecl : %s '(' expected\n", name);
; 6477 : 	return(-1);
; 6478 :     }
; 6479 :     NEXT;

	push	esi
	call	_xmlNextChar
	add	esp, 4

; 6480 :     GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN3@xmlParseEl
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN3@xmlParseEl
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN3@xmlParseEl:

; 6481 :     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN9@xmlParseEl

; 6482 :         return(-1);
; 6483 :     SKIP_BLANKS;

	push	ebx
	push	esi
	call	_xmlSkipBlankChars

; 6484 :     if (CMP7(CUR_PTR, '#', 'P', 'C', 'D', 'A', 'T', 'A')) {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 35			; 00000023H
	jne	SHORT $LN5@xmlParseEl
	cmp	BYTE PTR [eax+1], 80			; 00000050H
	jne	SHORT $LN5@xmlParseEl
	cmp	BYTE PTR [eax+2], 67			; 00000043H
	jne	SHORT $LN5@xmlParseEl
	cmp	BYTE PTR [eax+3], 68			; 00000044H
	jne	SHORT $LN5@xmlParseEl
	cmp	BYTE PTR [eax+4], 65			; 00000041H
	jne	SHORT $LN5@xmlParseEl
	cmp	BYTE PTR [eax+5], 84			; 00000054H
	jne	SHORT $LN5@xmlParseEl
	cmp	BYTE PTR [eax+6], 65			; 00000041H
	jne	SHORT $LN5@xmlParseEl

; 6485 :         tree = xmlParseElementMixedContentDecl(ctxt, inputid);

	push	edi
	push	esi
	call	_xmlParseElementMixedContentDecl
	add	esp, 8

; 6486 : 	res = XML_ELEMENT_TYPE_MIXED;

	mov	ebx, 3

; 6487 :     } else {

	jmp	SHORT $LN8@xmlParseEl
$LN5@xmlParseEl:

; 6488 :         tree = xmlParseElementChildrenContentDeclPriv(ctxt, inputid, 1);

	push	1
	push	edi
	push	esi
	call	_xmlParseElementChildrenContentDeclPriv
	add	esp, 12					; 0000000cH

; 6489 : 	res = XML_ELEMENT_TYPE_ELEMENT;

	mov	ebx, 4
$LN8@xmlParseEl:

; 6490 :     }
; 6491 :     SKIP_BLANKS;

	push	esi
	mov	edi, eax
	call	_xmlSkipBlankChars

; 6492 :     *result = tree;

	mov	eax, DWORD PTR _result$[ebp]
	add	esp, 4
	mov	DWORD PTR [eax], edi

; 6493 :     return(res);

	mov	eax, ebx
	pop	ebx
	pop	edi

; 6494 : }

	pop	esi
	pop	ebp
	ret	0
_xmlParseElementContentDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseElementChildrenContentDecl
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_inputchk$ = 12						; size = 4
_xmlParseElementChildrenContentDecl PROC		; COMDAT

; 6445 : xmlParseElementChildrenContentDecl(xmlParserCtxtPtr ctxt, int inputchk) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	push	1
	push	DWORD PTR _inputchk$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlParseElementChildrenContentDeclPriv
	add	esp, 12					; 0000000cH

; 6446 :     /* stub left for API/ABI compat */
; 6447 :     return(xmlParseElementChildrenContentDeclPriv(ctxt, inputchk, 1));
; 6448 : }

	pop	ebp
	ret	0
_xmlParseElementChildrenContentDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseElementMixedContentDecl
_TEXT	SEGMENT
_elem$1$ = -8						; size = 4
_ret$2$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_inputchk$ = 12						; size = 4
_xmlParseElementMixedContentDecl PROC			; COMDAT

; 6029 : xmlParseElementMixedContentDecl(xmlParserCtxtPtr ctxt, int inputchk) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _ret$2$[ebp], ebx
	mov	DWORD PTR _elem$1$[ebp], ebx
	cmp	DWORD PTR [esi+292], ebx
	jne	SHORT $LN10@xmlParseEl

; 6030 :     xmlElementContentPtr ret = NULL, cur = NULL, n;
; 6031 :     const xmlChar *elem = NULL;
; 6032 : 
; 6033 :     GROW;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN10@xmlParseEl
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN10@xmlParseEl:

; 6034 :     if (CMP7(CUR_PTR, '#', 'P', 'C', 'D', 'A', 'T', 'A')) {

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 35			; 00000023H
	jne	$LN11@xmlParseEl
	cmp	BYTE PTR [eax+1], 80			; 00000050H
	jne	$LN11@xmlParseEl
	cmp	BYTE PTR [eax+2], 67			; 00000043H
	jne	$LN11@xmlParseEl
	cmp	BYTE PTR [eax+3], 68			; 00000044H
	jne	$LN11@xmlParseEl
	cmp	BYTE PTR [eax+4], 65			; 00000041H
	jne	$LN11@xmlParseEl
	cmp	BYTE PTR [eax+5], 84			; 00000054H
	jne	$LN11@xmlParseEl
	cmp	BYTE PTR [eax+6], 65			; 00000041H
	jne	$LN11@xmlParseEl

; 6035 : 	SKIP(7);

	add	DWORD PTR [esi+200], 7
	add	DWORD PTR [ecx+16], 7
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 7
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], bl
	jne	SHORT $LN2@xmlParseEl
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseEl:

; 6036 : 	SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4

; 6037 : 	SHRINK;

	cmp	DWORD PTR [esi+292], ebx
	jne	SHORT $LN14@xmlParseEl
	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN14@xmlParseEl
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN14@xmlParseEl
	push	esi
	call	_xmlSHRINK
	add	esp, 4
$LN14@xmlParseEl:

; 6038 : 	if (RAW == ')') {

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 41					; 00000029H
	jne	SHORT $LN15@xmlParseEl

; 6039 : 	    if (ctxt->input->id != inputchk) {

	mov	eax, DWORD PTR [ecx+56]
	cmp	eax, DWORD PTR _inputchk$[ebp]
	je	SHORT $LN16@xmlParseEl

; 6040 : 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0EH@KGLJHJPD@Element?5content?5declaration?5doe@
	push	90					; 0000005aH
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN16@xmlParseEl:

; 6041 :                                "Element content declaration doesn't start and"
; 6042 :                                " stop in the same entity\n");
; 6043 : 	    }
; 6044 : 	    NEXT;

	push	esi
	call	_xmlNextChar

; 6045 : 	    ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);

	push	1
	push	0
	push	DWORD PTR [esi+8]
	call	_xmlNewDocElementContent
	mov	edi, eax
	add	esp, 16					; 00000010H

; 6046 : 	    if (ret == NULL)

	test	edi, edi
	je	$LN105@xmlParseEl

; 6047 : 	        return(NULL);
; 6048 : 	    if (RAW == '*') {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 42			; 0000002aH
	jne	SHORT $LN18@xmlParseEl

; 6049 : 		ret->ocur = XML_ELEMENT_CONTENT_MULT;
; 6050 : 		NEXT;

	push	esi
	mov	DWORD PTR [edi+4], 3
	call	_xmlNextChar
	add	esp, 4
$LN18@xmlParseEl:

; 6051 : 	    }
; 6052 : 	    return(ret);

	mov	eax, edi
	pop	edi

; 6114 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlParseEl:

; 6053 : 	}
; 6054 : 	if ((RAW == '(') || (RAW == '|')) {

	cmp	al, 40					; 00000028H
	je	SHORT $LN20@xmlParseEl
	cmp	al, 124					; 0000007cH
	jne	SHORT $LN182@xmlParseEl
$LN20@xmlParseEl:

; 6055 : 	    ret = cur = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);

	push	1
	push	0
	push	DWORD PTR [esi+8]
	call	_xmlNewDocElementContent
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$2$[ebp], ebx

; 6056 : 	    if (ret == NULL) return(NULL);

	test	ebx, ebx
	je	$LN105@xmlParseEl
$LN182@xmlParseEl:

; 6057 : 	}
; 6058 : 	while ((RAW == '|') && (ctxt->instate != XML_PARSER_EOF)) {

	mov	edx, DWORD PTR [esi+36]
	mov	edi, ebx
	mov	ecx, DWORD PTR [edx+16]
	cmp	BYTE PTR [ecx], 124			; 0000007cH
	jne	$LN6@xmlParseEl
	npad	7
$LL5@xmlParseEl:
	cmp	DWORD PTR [esi+172], -1
	je	$LN6@xmlParseEl

; 6059 : 	    NEXT;

	push	esi
	call	_xmlNextChar
	push	4
	push	0
	push	DWORD PTR [esi+8]
	call	_xmlNewDocElementContent
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 6060 : 	    if (elem == NULL) {

	mov	eax, DWORD PTR _elem$1$[ebp]
	test	eax, eax
	jne	SHORT $LN22@xmlParseEl

; 6061 : 	        ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);

	mov	DWORD PTR _ret$2$[ebp], ebx

; 6062 : 		if (ret == NULL) return(NULL);

	test	ebx, ebx
	je	$LN105@xmlParseEl

; 6063 : 		ret->c1 = cur;

	mov	DWORD PTR [ebx+12], edi

; 6064 : 		if (cur != NULL)

	test	edi, edi
	je	SHORT $LN25@xmlParseEl

; 6065 : 		    cur->parent = ret;

	mov	DWORD PTR [edi+20], ebx
$LN25@xmlParseEl:

; 6066 : 		cur = ret;

	mov	edi, ebx

; 6067 : 	    } else {

	jmp	SHORT $LN23@xmlParseEl
$LN22@xmlParseEl:

; 6068 : 	        n = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);
; 6069 : 		if (n == NULL) return(NULL);

	test	ebx, ebx
	je	$LN105@xmlParseEl

; 6070 : 		n->c1 = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);

	push	2
	push	eax
	push	DWORD PTR [esi+8]
	call	_xmlNewDocElementContent
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebx+12], eax

; 6071 : 		if (n->c1 != NULL)

	test	eax, eax
	je	SHORT $LN27@xmlParseEl

; 6072 : 		    n->c1->parent = n;

	mov	DWORD PTR [eax+20], ebx
$LN27@xmlParseEl:

; 6073 : 	        cur->c2 = n;

	mov	DWORD PTR [edi+16], ebx

; 6074 : 		if (n != NULL)
; 6075 : 		    n->parent = cur;

	mov	DWORD PTR [ebx+20], edi

; 6076 : 		cur = n;

	mov	edi, ebx
	mov	ebx, DWORD PTR _ret$2$[ebp]
$LN23@xmlParseEl:

; 6077 : 	    }
; 6078 : 	    SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 6079 : 	    elem = xmlParseName(ctxt);

	push	esi
	call	_xmlParseName
	add	esp, 8
	mov	DWORD PTR _elem$1$[ebp], eax

; 6080 : 	    if (elem == NULL) {

	test	eax, eax
	je	$LN178@xmlParseEl

; 6085 : 	    }
; 6086 : 	    SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4

; 6087 : 	    GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN30@xmlParseEl
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN30@xmlParseEl
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN30@xmlParseEl:

; 6057 : 	}
; 6058 : 	while ((RAW == '|') && (ctxt->instate != XML_PARSER_EOF)) {

	mov	edx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [edx+16]
	cmp	BYTE PTR [eax], 124			; 0000007cH
	je	$LL5@xmlParseEl
$LN6@xmlParseEl:

; 6088 : 	}
; 6089 : 	if ((RAW == ')') && (NXT(1) == '*')) {

	mov	eax, DWORD PTR [edx+16]
	cmp	BYTE PTR [eax], 41			; 00000029H
	jne	$LN31@xmlParseEl
	cmp	BYTE PTR [eax+1], 42			; 0000002aH
	jne	$LN31@xmlParseEl

; 6090 : 	    if (elem != NULL) {

	mov	eax, DWORD PTR _elem$1$[ebp]
	test	eax, eax
	je	SHORT $LN34@xmlParseEl

; 6091 : 		cur->c2 = xmlNewDocElementContent(ctxt->myDoc, elem,

	push	2
	push	eax
	push	DWORD PTR [esi+8]
	call	_xmlNewDocElementContent
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+16], eax

; 6092 : 		                               XML_ELEMENT_CONTENT_ELEMENT);
; 6093 : 		if (cur->c2 != NULL)

	test	eax, eax
	je	SHORT $LN34@xmlParseEl

; 6094 : 		    cur->c2->parent = cur;

	mov	DWORD PTR [eax+20], edi
$LN34@xmlParseEl:

; 6095 :             }
; 6096 :             if (ret != NULL)

	test	ebx, ebx
	je	SHORT $LN35@xmlParseEl

; 6097 :                 ret->ocur = XML_ELEMENT_CONTENT_MULT;

	mov	DWORD PTR [ebx+4], 3
$LN35@xmlParseEl:

; 6098 : 	    if (ctxt->input->id != inputchk) {

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+56]
	cmp	eax, DWORD PTR _inputchk$[ebp]
	je	SHORT $LN9@xmlParseEl

; 6099 : 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0EH@KGLJHJPD@Element?5content?5declaration?5doe@
	push	90					; 0000005aH
	push	esi
	call	_xmlFatalErrMsg
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
$LN9@xmlParseEl:

; 6100 :                                "Element content declaration doesn't start and"
; 6101 :                                " stop in the same entity\n");
; 6102 : 	    }
; 6103 : 	    SKIP(2);

	add	DWORD PTR [esi+200], 2
	add	DWORD PTR [ecx+16], 2
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 2
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	$LN173@xmlParseEl
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8

; 6106 : 	    xmlFatalErr(ctxt, XML_ERR_MIXED_NOT_STARTED, NULL);
; 6107 : 	    return(NULL);
; 6108 : 	}
; 6109 : 
; 6110 :     } else {
; 6111 : 	xmlFatalErr(ctxt, XML_ERR_PCDATA_REQUIRED, NULL);
; 6112 :     }
; 6113 :     return(ret);

	mov	eax, ebx
	pop	edi

; 6114 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN178@xmlParseEl:

; 6081 : 		xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0DB@BEFMOJIK@xmlParseElementMixedContentDecl@
	push	68					; 00000044H
	push	esi
	call	_xmlFatalErrMsg

; 6082 : 			"xmlParseElementMixedContentDecl : Name expected\n");
; 6083 : 		xmlFreeDocElementContent(ctxt->myDoc, ret);

	push	ebx
	push	DWORD PTR [esi+8]
	call	_xmlFreeDocElementContent
	add	esp, 20					; 00000014H

; 6084 : 		return(NULL);

	xor	eax, eax
	pop	edi

; 6114 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlParseEl:

; 6104 : 	} else {
; 6105 : 	    xmlFreeDocElementContent(ctxt->myDoc, ret);

	push	ebx
	push	DWORD PTR [esi+8]
	call	_xmlFreeDocElementContent
	add	esp, 8

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN42@xmlParseEl
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN105@xmlParseEl
$LN42@xmlParseEl:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CI@LOAMKAA@MixedContentDecl?5?3?5?8?$HM?8?5or?5?8?$CJ?$CK?8?5@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	52					; 00000034H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 52			; 00000034H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN105@xmlParseEl

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN105@xmlParseEl:
	pop	edi

; 6114 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlParseEl:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], ebx
	je	SHORT $LN110@xmlParseEl
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN173@xmlParseEl
$LN110@xmlParseEl:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CG@HEHENOGB@MixedContentDecl?5?3?5?8?$CDPCDATA?8?5ex@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	69					; 00000045H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 69			; 00000045H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], ebx

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], ebx
	jne	SHORT $LN173@xmlParseEl

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN173@xmlParseEl:
	pop	edi

; 6114 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseElementMixedContentDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseAttributeListDecl
_TEXT	SEGMENT
_type$1$ = -20						; size = 4
_defaultValue$1 = -16					; size = 4
_elemName$1$ = -12					; size = 4
_tree$ = -8						; size = 4
_attrName$1$ = -4					; size = 4
_inputid$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseAttributeListDecl PROC				; COMDAT

; 5901 : xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	ecx, OFFSET __B9AC27D5_parser@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 60			; 0000003cH
	jne	$LN36@xmlParseAt

; 5902 :     const xmlChar *elemName;
; 5903 :     const xmlChar *attrName;
; 5904 :     xmlEnumerationPtr tree;
; 5905 : 
; 5906 :     if (CMP9(CUR_PTR, '<', '!', 'A', 'T', 'T', 'L', 'I', 'S', 'T')) {

	cmp	BYTE PTR [eax+1], 33			; 00000021H
	jne	$LN36@xmlParseAt
	cmp	BYTE PTR [eax+2], 65			; 00000041H
	jne	$LN36@xmlParseAt
	cmp	BYTE PTR [eax+3], 84			; 00000054H
	jne	$LN36@xmlParseAt
	cmp	BYTE PTR [eax+4], 84			; 00000054H
	jne	$LN36@xmlParseAt
	cmp	BYTE PTR [eax+5], 76			; 0000004cH
	jne	$LN36@xmlParseAt
	cmp	BYTE PTR [eax+6], 73			; 00000049H
	jne	$LN36@xmlParseAt
	cmp	BYTE PTR [eax+7], 83			; 00000053H
	jne	$LN36@xmlParseAt
	cmp	BYTE PTR [eax+8], 84			; 00000054H
	jne	$LN36@xmlParseAt

; 5907 : 	int inputid = ctxt->input->id;

	push	ebx
	mov	ebx, DWORD PTR [ecx+56]

; 5908 : 
; 5909 : 	SKIP(9);

	add	DWORD PTR [esi+200], 9
	add	DWORD PTR [ecx+16], 9
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR _inputid$1$[ebp], ebx
	add	DWORD PTR [eax+32], 9
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseAt
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseAt:

; 5910 : 	if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN9@xmlParseAt

; 5911 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CC@DODLEJBN@Space?5required?5after?5?8?$DM?$CBATTLIST@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN9@xmlParseAt:

; 5912 : 		                 "Space required after '<!ATTLIST'\n");
; 5913 : 	}
; 5914 :         elemName = xmlParseName(ctxt);

	push	esi
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _elemName$1$[ebp], eax

; 5915 : 	if (elemName == NULL) {

	test	eax, eax
	jne	SHORT $LN10@xmlParseAt

; 5916 : 	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0BO@PIKFFONH@ATTLIST?3?5no?5name?5for?5Element?6@
	push	68					; 00000044H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
	pop	ebx
	pop	esi

; 6005 : 	}
; 6006 :     }
; 6007 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlParseAt:

; 5917 : 			   "ATTLIST: no name for Element\n");
; 5918 : 	    return;
; 5919 : 	}
; 5920 : 	SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4

; 5921 : 	GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN44@xmlParseAt
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN44@xmlParseAt
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN44@xmlParseAt:

; 5922 : 	while ((RAW != '>') && (ctxt->instate != XML_PARSER_EOF)) {

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 62			; 0000003eH
	je	$LN28@xmlParseAt
	push	edi
	npad	12
$LL5@xmlParseAt:
	cmp	DWORD PTR [esi+172], -1
	je	$LN63@xmlParseAt

; 5923 : 	    int type;
; 5924 : 	    int def;
; 5925 : 	    xmlChar *defaultValue = NULL;
; 5926 : 
; 5927 : 	    GROW;

	cmp	DWORD PTR [esi+292], 0
	mov	DWORD PTR _defaultValue$1[ebp], 0
	jne	SHORT $LN12@xmlParseAt
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [ecx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN12@xmlParseAt
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN12@xmlParseAt:

; 5928 :             tree = NULL;
; 5929 : 	    attrName = xmlParseName(ctxt);

	push	esi
	mov	DWORD PTR _tree$[ebp], 0
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _attrName$1$[ebp], eax

; 5930 : 	    if (attrName == NULL) {

	test	eax, eax
	je	$LN45@xmlParseAt

; 5932 : 			       "ATTLIST: no name for Attribute\n");
; 5933 : 		break;
; 5934 : 	    }
; 5935 : 	    GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN14@xmlParseAt
	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN14@xmlParseAt
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN14@xmlParseAt:

; 5936 : 	    if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	je	$LN46@xmlParseAt

; 5940 : 	    }
; 5941 : 
; 5942 : 	    type = xmlParseAttributeType(ctxt, &tree);

	lea	eax, DWORD PTR _tree$[ebp]
	push	eax
	push	esi
	call	_xmlParseAttributeType
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR _type$1$[ebp], edi

; 5943 : 	    if (type <= 0) {

	test	edi, edi
	jle	$LN63@xmlParseAt

; 5944 : 	        break;
; 5945 : 	    }
; 5946 : 
; 5947 : 	    GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN17@xmlParseAt
	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN17@xmlParseAt
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN17@xmlParseAt:

; 5948 : 	    if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	je	$LN48@xmlParseAt

; 5954 : 	    }
; 5955 : 
; 5956 : 	    def = xmlParseDefaultDecl(ctxt, &defaultValue);

	lea	eax, DWORD PTR _defaultValue$1[ebp]
	push	eax
	push	esi
	call	_xmlParseDefaultDecl
	mov	ebx, eax
	add	esp, 8

; 5957 : 	    if (def <= 0) {

	test	ebx, ebx
	jle	$LN49@xmlParseAt

; 5963 : 	    }
; 5964 : 	    if ((type != XML_ATTRIBUTE_CDATA) && (defaultValue != NULL))

	cmp	edi, 1
	mov	edi, DWORD PTR _defaultValue$1[ebp]
	je	SHORT $LN23@xmlParseAt
	test	edi, edi
	je	SHORT $LN23@xmlParseAt

; 5965 : 	        xmlAttrNormalizeSpace(defaultValue, defaultValue);

	push	edi
	push	edi
	call	_xmlAttrNormalizeSpace
	add	esp, 8
$LN23@xmlParseAt:

; 5966 : 
; 5967 : 	    GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN24@xmlParseAt
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN24@xmlParseAt
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN24@xmlParseAt:

; 5968 :             if (RAW != '>') {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 62			; 0000003eH
	je	SHORT $LN26@xmlParseAt

; 5969 : 		if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	je	$LN50@xmlParseAt
$LN26@xmlParseAt:

; 5976 : 		    break;
; 5977 : 		}
; 5978 : 	    }
; 5979 : 	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN29@xmlParseAt
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN29@xmlParseAt
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN29@xmlParseAt

; 5980 : 		(ctxt->sax->attributeDecl != NULL))
; 5981 : 		ctxt->sax->attributeDecl(ctxt->userData, elemName, attrName,

	push	DWORD PTR _tree$[ebp]
	push	edi
	push	ebx
	push	DWORD PTR _type$1$[ebp]
	push	DWORD PTR _attrName$1$[ebp]
	push	DWORD PTR _elemName$1$[ebp]
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN31@xmlParseAt
$LN29@xmlParseAt:

; 5982 : 	                        type, def, defaultValue, tree);
; 5983 : 	    else if (tree != NULL)

	mov	eax, DWORD PTR _tree$[ebp]
	test	eax, eax
	je	SHORT $LN31@xmlParseAt

; 5984 : 		xmlFreeEnumeration(tree);

	push	eax
	call	_xmlFreeEnumeration
	add	esp, 4
$LN31@xmlParseAt:

; 5985 : 
; 5986 : 	    if ((ctxt->sax2) && (defaultValue != NULL) &&
; 5987 : 	        (def != XML_ATTRIBUTE_IMPLIED) &&

	mov	ecx, DWORD PTR [esi+324]
	mov	eax, ecx
	test	ecx, ecx
	je	SHORT $LN58@xmlParseAt
	test	edi, edi
	je	SHORT $LN58@xmlParseAt
	cmp	ebx, 3
	je	SHORT $LN58@xmlParseAt
	cmp	ebx, 2
	mov	ebx, DWORD PTR _attrName$1$[ebp]
	je	SHORT $LN32@xmlParseAt

; 5988 : 		(def != XML_ATTRIBUTE_REQUIRED)) {
; 5989 : 		xmlAddDefAttrs(ctxt, elemName, attrName, defaultValue);

	push	edi
	push	ebx
	push	DWORD PTR _elemName$1$[ebp]
	push	esi
	call	_xmlAddDefAttrs
	mov	eax, DWORD PTR [esi+324]
	add	esp, 16					; 00000010H
	jmp	SHORT $LN32@xmlParseAt
$LN58@xmlParseAt:

; 5990 : 	    }
; 5991 : 	    if (ctxt->sax2) {

	mov	ebx, DWORD PTR _attrName$1$[ebp]
$LN32@xmlParseAt:
	test	eax, eax
	je	SHORT $LN39@xmlParseAt

; 1324 :     if (ctxt->attsSpecial == NULL) {

	mov	eax, DWORD PTR [esi+352]
	test	eax, eax
	jne	SHORT $LN53@xmlParseAt

; 1325 :         ctxt->attsSpecial = xmlHashCreateDict(10, ctxt->dict);

	push	DWORD PTR [esi+296]
	push	10					; 0000000aH
	call	_xmlHashCreateDict
	add	esp, 8
	mov	DWORD PTR [esi+352], eax

; 1326 : 	if (ctxt->attsSpecial == NULL)

	test	eax, eax
	jne	SHORT $LN53@xmlParseAt
$mem_error$69:

; 1334 :                      (void *) (ptrdiff_t) type);
; 1335 :     return;
; 1336 : 
; 1337 : mem_error:
; 1338 :     xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory
	add	esp, 8
	jmp	SHORT $LN39@xmlParseAt
$LN53@xmlParseAt:

; 1327 : 	    goto mem_error;
; 1328 :     }
; 1329 : 
; 1330 :     if (xmlHashLookup2(ctxt->attsSpecial, fullname, fullattr) != NULL)

	push	ebx
	push	DWORD PTR _elemName$1$[ebp]
	push	eax
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN39@xmlParseAt

; 1331 :         return;
; 1332 : 
; 1333 :     xmlHashAddEntry2(ctxt->attsSpecial, fullname, fullattr,

	push	DWORD PTR _type$1$[ebp]
	push	ebx
	push	DWORD PTR _elemName$1$[ebp]
	push	DWORD PTR [esi+352]
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN39@xmlParseAt:

; 5992 : 		xmlAddSpecialAttr(ctxt, elemName, attrName, type);
; 5993 : 	    }
; 5994 : 	    if (defaultValue != NULL)

	test	edi, edi
	je	SHORT $LN34@xmlParseAt

; 5995 : 	        xmlFree(defaultValue);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN34@xmlParseAt:

; 5996 : 	    GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN35@xmlParseAt
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN35@xmlParseAt
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN35@xmlParseAt:

; 5922 : 	while ((RAW != '>') && (ctxt->instate != XML_PARSER_EOF)) {

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 62			; 0000003eH
	jne	$LL5@xmlParseAt
	jmp	$LN63@xmlParseAt
$LN50@xmlParseAt:

; 5970 : 		    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0DC@NGABIAJF@Space?5required?5after?5the?5attrib@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 5971 : 			"Space required after the attribute default value\n");
; 5972 : 		    if (defaultValue != NULL)

	test	edi, edi
	je	SHORT $LN27@xmlParseAt

; 5973 : 			xmlFree(defaultValue);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN27@xmlParseAt:

; 5974 : 		    if (tree != NULL)

	mov	eax, DWORD PTR _tree$[ebp]
	test	eax, eax
	je	SHORT $LN63@xmlParseAt

; 5975 : 			xmlFreeEnumeration(tree);

	push	eax
	call	_xmlFreeEnumeration
	add	esp, 4
	jmp	SHORT $LN63@xmlParseAt
$LN49@xmlParseAt:

; 5958 :                 if (defaultValue != NULL)

	mov	eax, DWORD PTR _defaultValue$1[ebp]
	test	eax, eax
	je	SHORT $LN21@xmlParseAt

; 5959 : 		    xmlFree(defaultValue);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN21@xmlParseAt:

; 5960 : 	        if (tree != NULL)

	mov	eax, DWORD PTR _tree$[ebp]
	test	eax, eax
	je	SHORT $LN63@xmlParseAt

; 5961 : 		    xmlFreeEnumeration(tree);

	push	eax
	call	_xmlFreeEnumeration
	add	esp, 4

; 5962 : 	        break;

	jmp	SHORT $LN63@xmlParseAt
$LN48@xmlParseAt:

; 5949 : 		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CJ@EMHJKDCH@Space?5required?5after?5the?5attrib@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg

; 5950 : 			       "Space required after the attribute type\n");
; 5951 : 	        if (tree != NULL)

	mov	eax, DWORD PTR _tree$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN63@xmlParseAt

; 5952 : 		    xmlFreeEnumeration(tree);

	push	eax
	call	_xmlFreeEnumeration
	add	esp, 4

; 5953 : 		break;

	jmp	SHORT $LN63@xmlParseAt
$LN46@xmlParseAt:

; 5937 : 		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CJ@BMNHNBNL@Space?5required?5after?5the?5attrib@
	push	65					; 00000041H

; 5938 : 		        "Space required after the attribute name\n");
; 5939 : 		break;

	jmp	SHORT $LN67@xmlParseAt
$LN45@xmlParseAt:

; 5931 : 		xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0CA@GKDLKFPE@ATTLIST?3?5no?5name?5for?5Attribute?6@
	push	68					; 00000044H
$LN67@xmlParseAt:

; 5974 : 		    if (tree != NULL)

	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN63@xmlParseAt:
	mov	ebx, DWORD PTR _inputid$1$[ebp]
	pop	edi
$LN28@xmlParseAt:

; 5997 : 	}
; 5998 : 	if (RAW == '>') {

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 62			; 0000003eH
	jne	SHORT $LN64@xmlParseAt

; 5999 : 	    if (inputid != ctxt->input->id) {

	cmp	ebx, DWORD PTR [ecx+56]
	je	SHORT $LN37@xmlParseAt

; 6000 : 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0EG@JGLJABBC@Attribute?5list?5declaration?5does@
	push	90					; 0000005aH
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN37@xmlParseAt:

; 6001 :                                "Attribute list declaration doesn't start and"
; 6002 :                                " stop in the same entity\n");
; 6003 : 	    }
; 6004 : 	    NEXT;

	push	esi
	call	_xmlNextChar
	add	esp, 4
$LN64@xmlParseAt:
	pop	ebx
$LN36@xmlParseAt:
	pop	esi

; 6005 : 	}
; 6006 :     }
; 6007 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseAttributeListDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseAttributeType
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_tree$ = 12						; size = 4
_xmlParseAttributeType PROC				; COMDAT

; 5859 : xmlParseAttributeType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN26@xmlParseAt

; 5860 :     SHRINK;

	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN26@xmlParseAt
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN26@xmlParseAt
	push	esi
	call	_xmlSHRINK
	add	esp, 4
$LN26@xmlParseAt:

; 5861 :     if (CMP5(CUR_PTR, 'C', 'D', 'A', 'T', 'A')) {

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	mov	bl, BYTE PTR [eax]
	cmp	bl, 67					; 00000043H
	jne	SHORT $LN27@xmlParseAt
	cmp	BYTE PTR [eax+1], 68			; 00000044H
	jne	SHORT $LN27@xmlParseAt
	cmp	BYTE PTR [eax+2], 65			; 00000041H
	jne	SHORT $LN27@xmlParseAt
	cmp	BYTE PTR [eax+3], 84			; 00000054H
	jne	SHORT $LN27@xmlParseAt
	cmp	BYTE PTR [eax+4], 65			; 00000041H
	jne	SHORT $LN27@xmlParseAt

; 5862 : 	SKIP(5);

	add	DWORD PTR [esi+200], 5
	add	DWORD PTR [ecx+16], 5
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 5
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseAt
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseAt:

; 5863 : 	return(XML_ATTRIBUTE_CDATA);

	pop	esi
	mov	eax, 1

; 5887 : }

	pop	ebx
	pop	ebp
	ret	0
$LN27@xmlParseAt:

; 5864 :      } else if (CMP6(CUR_PTR, 'I', 'D', 'R', 'E', 'F', 'S')) {

	cmp	bl, 73					; 00000049H
	jne	$LN52@xmlParseAt
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, 68					; 00000044H
	jne	$LN52@xmlParseAt
	cmp	BYTE PTR [eax+2], 82			; 00000052H
	jne	SHORT $LN30@xmlParseAt
	cmp	BYTE PTR [eax+3], 69			; 00000045H
	jne	SHORT $LN30@xmlParseAt
	cmp	BYTE PTR [eax+4], 70			; 00000046H
	jne	SHORT $LN30@xmlParseAt
	cmp	BYTE PTR [eax+5], 83			; 00000053H
	jne	SHORT $LN30@xmlParseAt

; 5865 : 	SKIP(6);

	add	DWORD PTR [esi+200], 6
	add	DWORD PTR [ecx+16], 6
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 6
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN5@xmlParseAt
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN5@xmlParseAt:

; 5866 : 	return(XML_ATTRIBUTE_IDREFS);

	pop	esi
	mov	eax, 4

; 5887 : }

	pop	ebx
	pop	ebp
	ret	0
$LN30@xmlParseAt:

; 5867 :      } else if (CMP5(CUR_PTR, 'I', 'D', 'R', 'E', 'F')) {

	cmp	dl, 68					; 00000044H
	jne	SHORT $LN52@xmlParseAt
	cmp	BYTE PTR [eax+2], 82			; 00000052H
	jne	SHORT $LN33@xmlParseAt
	cmp	BYTE PTR [eax+3], 69			; 00000045H
	jne	SHORT $LN33@xmlParseAt
	cmp	BYTE PTR [eax+4], 70			; 00000046H
	jne	SHORT $LN33@xmlParseAt

; 5868 : 	SKIP(5);

	add	DWORD PTR [esi+200], 5
	add	DWORD PTR [ecx+16], 5
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 5
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN8@xmlParseAt
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN8@xmlParseAt:

; 5869 : 	return(XML_ATTRIBUTE_IDREF);

	pop	esi
	mov	eax, 3

; 5887 : }

	pop	ebx
	pop	ebp
	ret	0
$LN33@xmlParseAt:

; 5870 :      } else if ((RAW == 'I') && (NXT(1) == 'D')) {

	cmp	dl, 68					; 00000044H
	jne	SHORT $LN52@xmlParseAt

; 5871 :         SKIP(2);

	add	DWORD PTR [esi+200], 2
	add	DWORD PTR [ecx+16], 2
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 2
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN11@xmlParseAt
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN11@xmlParseAt:

; 5872 : 	return(XML_ATTRIBUTE_ID);

	pop	esi
	mov	eax, 2

; 5887 : }

	pop	ebx
	pop	ebp
	ret	0
$LN52@xmlParseAt:

; 5873 :      } else if (CMP6(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'Y')) {

	cmp	bl, 69					; 00000045H
	jne	$LN42@xmlParseAt
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, 78					; 0000004eH
	jne	$LN42@xmlParseAt
	cmp	BYTE PTR [eax+2], 84			; 00000054H
	jne	SHORT $LN39@xmlParseAt
	cmp	BYTE PTR [eax+3], 73			; 00000049H
	jne	SHORT $LN39@xmlParseAt
	cmp	BYTE PTR [eax+4], 84			; 00000054H
	jne	SHORT $LN39@xmlParseAt
	cmp	BYTE PTR [eax+5], 89			; 00000059H
	jne	SHORT $LN39@xmlParseAt

; 5874 : 	SKIP(6);

	add	DWORD PTR [esi+200], 6
	add	DWORD PTR [ecx+16], 6
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 6
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN14@xmlParseAt
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN14@xmlParseAt:

; 5875 : 	return(XML_ATTRIBUTE_ENTITY);

	pop	esi
	mov	eax, 5

; 5887 : }

	pop	ebx
	pop	ebp
	ret	0
$LN39@xmlParseAt:

; 5876 :      } else if (CMP8(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'I', 'E', 'S')) {

	cmp	dl, 78					; 0000004eH
	jne	SHORT $LN42@xmlParseAt
	cmp	BYTE PTR [eax+2], 84			; 00000054H
	jne	SHORT $LN42@xmlParseAt
	cmp	BYTE PTR [eax+3], 73			; 00000049H
	jne	SHORT $LN42@xmlParseAt
	cmp	BYTE PTR [eax+4], 84			; 00000054H
	jne	SHORT $LN42@xmlParseAt
	cmp	BYTE PTR [eax+5], 73			; 00000049H
	jne	SHORT $LN42@xmlParseAt
	cmp	BYTE PTR [eax+6], 69			; 00000045H
	jne	SHORT $LN42@xmlParseAt
	cmp	BYTE PTR [eax+7], 83			; 00000053H
	jne	SHORT $LN42@xmlParseAt

; 5877 : 	SKIP(8);

	add	DWORD PTR [esi+200], 8
	add	DWORD PTR [ecx+16], 8
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 8
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN17@xmlParseAt
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN17@xmlParseAt:

; 5878 : 	return(XML_ATTRIBUTE_ENTITIES);

	pop	esi
	mov	eax, 6

; 5887 : }

	pop	ebx
	pop	ebp
	ret	0
$LN42@xmlParseAt:

; 5879 :      } else if (CMP8(CUR_PTR, 'N', 'M', 'T', 'O', 'K', 'E', 'N', 'S')) {

	cmp	bl, 78					; 0000004eH
	jne	$LN48@xmlParseAt
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, 77					; 0000004dH
	jne	$LN48@xmlParseAt
	cmp	BYTE PTR [eax+2], 84			; 00000054H
	jne	SHORT $LN45@xmlParseAt
	cmp	BYTE PTR [eax+3], 79			; 0000004fH
	jne	SHORT $LN45@xmlParseAt
	cmp	BYTE PTR [eax+4], 75			; 0000004bH
	jne	SHORT $LN45@xmlParseAt
	cmp	BYTE PTR [eax+5], 69			; 00000045H
	jne	SHORT $LN45@xmlParseAt
	cmp	BYTE PTR [eax+6], bl
	jne	SHORT $LN45@xmlParseAt
	cmp	BYTE PTR [eax+7], 83			; 00000053H
	jne	SHORT $LN45@xmlParseAt

; 5880 : 	SKIP(8);

	add	DWORD PTR [esi+200], 8
	add	DWORD PTR [ecx+16], 8
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 8
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN20@xmlParseAt
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN20@xmlParseAt:

; 5881 : 	return(XML_ATTRIBUTE_NMTOKENS);

	pop	esi
	mov	eax, 8

; 5887 : }

	pop	ebx
	pop	ebp
	ret	0
$LN45@xmlParseAt:

; 5882 :      } else if (CMP7(CUR_PTR, 'N', 'M', 'T', 'O', 'K', 'E', 'N')) {

	cmp	dl, 77					; 0000004dH
	jne	SHORT $LN48@xmlParseAt
	cmp	BYTE PTR [eax+2], 84			; 00000054H
	jne	SHORT $LN48@xmlParseAt
	cmp	BYTE PTR [eax+3], 79			; 0000004fH
	jne	SHORT $LN48@xmlParseAt
	cmp	BYTE PTR [eax+4], 75			; 0000004bH
	jne	SHORT $LN48@xmlParseAt
	cmp	BYTE PTR [eax+5], 69			; 00000045H
	jne	SHORT $LN48@xmlParseAt
	cmp	BYTE PTR [eax+6], 78			; 0000004eH
	jne	SHORT $LN48@xmlParseAt

; 5883 : 	SKIP(7);

	add	DWORD PTR [esi+200], 7
	add	DWORD PTR [ecx+16], 7
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 7
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN23@xmlParseAt
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN23@xmlParseAt:

; 5884 : 	return(XML_ATTRIBUTE_NMTOKEN);

	pop	esi
	mov	eax, 7

; 5887 : }

	pop	ebx
	pop	ebp
	ret	0
$LN48@xmlParseAt:

; 5885 :      }
; 5886 :      return(xmlParseEnumeratedType(ctxt, tree));

	push	DWORD PTR _tree$[ebp]
	push	esi
	call	_xmlParseEnumeratedType
	add	esp, 8
	pop	esi

; 5887 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlParseAttributeType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEnumeratedType
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_tree$ = 12						; size = 4
_xmlParseEnumeratedType PROC				; COMDAT

; 5796 : xmlParseEnumeratedType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 78			; 0000004eH
	jne	$LN5@xmlParseEn

; 5797 :     if (CMP8(CUR_PTR, 'N', 'O', 'T', 'A', 'T', 'I', 'O', 'N')) {

	cmp	BYTE PTR [eax+1], 79			; 0000004fH
	jne	$LN5@xmlParseEn
	cmp	BYTE PTR [eax+2], 84			; 00000054H
	jne	$LN5@xmlParseEn
	cmp	BYTE PTR [eax+3], 65			; 00000041H
	jne	SHORT $LN5@xmlParseEn
	cmp	BYTE PTR [eax+4], 84			; 00000054H
	jne	SHORT $LN5@xmlParseEn
	cmp	BYTE PTR [eax+5], 73			; 00000049H
	jne	SHORT $LN5@xmlParseEn
	cmp	BYTE PTR [eax+6], 79			; 0000004fH
	jne	SHORT $LN5@xmlParseEn
	cmp	BYTE PTR [eax+7], 78			; 0000004eH
	jne	SHORT $LN5@xmlParseEn

; 5798 : 	SKIP(8);

	add	DWORD PTR [esi+200], 8
	add	DWORD PTR [ecx+16], 8
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 8
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseEn
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseEn:

; 5799 : 	if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN7@xmlParseEn

; 5800 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CB@FOEKPMO@Space?5required?5after?5?8NOTATION?8@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN11@xmlParseEn:

; 5811 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN7@xmlParseEn:

; 5801 : 			   "Space required after 'NOTATION'\n");
; 5802 : 	    return(0);
; 5803 : 	}
; 5804 : 	*tree = xmlParseNotationType(ctxt);

	push	esi
	call	_xmlParseNotationType
	mov	ecx, DWORD PTR _tree$[ebp]
	add	esp, 4
	mov	DWORD PTR [ecx], eax

; 5805 : 	if (*tree == NULL) return(0);

	test	eax, eax
	je	SHORT $LN11@xmlParseEn

; 5806 : 	return(XML_ATTRIBUTE_NOTATION);

	mov	eax, 10					; 0000000aH
	pop	esi

; 5811 : }

	pop	ebp
	ret	0
$LN5@xmlParseEn:

; 5807 :     }
; 5808 :     *tree = xmlParseEnumerationType(ctxt);

	push	esi
	call	_xmlParseEnumerationType
	mov	ecx, DWORD PTR _tree$[ebp]
	add	esp, 4
	mov	DWORD PTR [ecx], eax

; 5809 :     if (*tree == NULL) return(0);

	test	eax, eax
	je	SHORT $LN11@xmlParseEn

; 5810 :     return(XML_ATTRIBUTE_ENUMERATION);

	mov	eax, 9
	pop	esi

; 5811 : }

	pop	ebp
	ret	0
_xmlParseEnumeratedType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEnumerationType
_TEXT	SEGMENT
_last$1$ = -8						; size = 4
_ret$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseEnumerationType PROC				; COMDAT

; 5727 : xmlParseEnumerationType(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	mov	DWORD PTR _ret$1$[ebp], esi
	mov	DWORD PTR _last$1$[ebp], esi
	mov	ecx, DWORD PTR [edi+36]
	mov	edx, DWORD PTR [ecx+16]
	cmp	BYTE PTR [edx], 40			; 00000028H
	je	SHORT $LN7@xmlParseEn

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edi+212], esi
	je	SHORT $LN22@xmlParseEn
	cmp	DWORD PTR [edi+172], -1
	je	SHORT $LN85@xmlParseEn
$LN22@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CK@NNFMCGNH@?8?$CI?8?5required?5to?5start?5ATTLIST?5e@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	50					; 00000032H
	push	1
	push	0
	push	edi
	push	0
	push	0
	push	0
	mov	DWORD PTR [edi+84], 50			; 00000032H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [edi+12], esi

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [edi+288], esi
	jne	SHORT $LN85@xmlParseEn

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [edi+212], 1
$LN85@xmlParseEn:
	pop	edi

; 5728 :     xmlChar *name;
; 5729 :     xmlEnumerationPtr ret = NULL, last = NULL, cur, tmp;
; 5730 : 
; 5731 :     if (RAW != '(') {
; 5732 : 	xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_STARTED, NULL);
; 5733 : 	return(NULL);

	xor	eax, eax

; 5777 :     return(ret);
; 5778 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlParseEn:

; 5734 :     }
; 5735 :     SHRINK;

	cmp	DWORD PTR [edi+292], esi
	jne	SHORT $LN256@xmlParseEn
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN256@xmlParseEn
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN256@xmlParseEn
	push	edi
	call	_xmlSHRINK
	add	esp, 4
$LN256@xmlParseEn:
	push	ebx
$LL4@xmlParseEn:

; 5736 :     do {
; 5737 :         NEXT;

	push	edi
	call	_xmlNextChar

; 5738 : 	SKIP_BLANKS;

	push	edi
	call	_xmlSkipBlankChars

; 5739 :         name = xmlParseNmtoken(ctxt);

	push	edi
	call	_xmlParseNmtoken
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 5740 : 	if (name == NULL) {

	test	ebx, ebx
	je	$LN226@xmlParseEn

; 5743 : 	}
; 5744 : 	tmp = ret;
; 5745 : 	while (tmp != NULL) {

	cmp	DWORD PTR _ret$1$[ebp], 0
	je	SHORT $LN238@xmlParseEn
	npad	5
$LL5@xmlParseEn:

; 5746 : 	    if (xmlStrEqual(name, tmp->name)) {

	push	DWORD PTR [esi+4]
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN225@xmlParseEn

; 5752 : 		break;
; 5753 : 	    }
; 5754 : 	    tmp = tmp->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL5@xmlParseEn
$LN238@xmlParseEn:

; 5757 : 	    cur = xmlCreateEnumeration(name);

	push	ebx
	call	_xmlCreateEnumeration

; 5758 : 	    if (!xmlDictOwns(ctxt->dict, name))

	push	ebx
	push	DWORD PTR [edi+296]
	mov	esi, eax
	call	_xmlDictOwns
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN13@xmlParseEn

; 5759 : 		xmlFree(name);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlParseEn:

; 5760 : 	    if (cur == NULL) {

	test	esi, esi
	je	$LN228@xmlParseEn

; 5763 :             }
; 5764 : 	    if (last == NULL) ret = last = cur;

	mov	eax, DWORD PTR _last$1$[ebp]
	mov	DWORD PTR _last$1$[ebp], esi
	test	eax, eax
	jne	SHORT $LN15@xmlParseEn
	mov	DWORD PTR _ret$1$[ebp], esi
	jmp	SHORT $LN16@xmlParseEn
$LN225@xmlParseEn:

; 5747 : 		xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,

	push	0
	push	ebx
	push	OFFSET ??_C@_0DN@GKJDABEM@standalone?3?5attribute?5enumerati@
	push	541					; 0000021dH
	push	edi
	call	_xmlValidityError

; 5748 : 	  "standalone: attribute enumeration value token %s duplicated\n",
; 5749 : 				 name, NULL);
; 5750 : 		if (!xmlDictOwns(ctxt->dict, name))

	push	ebx
	push	DWORD PTR [edi+296]
	call	_xmlDictOwns
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	SHORT $LN255@xmlParseEn

; 5751 : 		    xmlFree(name);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 5755 : 	}
; 5756 : 	if (tmp == NULL) {

	jmp	SHORT $LN255@xmlParseEn
$LN15@xmlParseEn:

; 5765 : 	    else {
; 5766 : 		last->next = cur;

	mov	DWORD PTR [eax], esi
$LN255@xmlParseEn:

; 5767 : 		last = cur;
; 5768 : 	    }
; 5769 : 	}
; 5770 : 	SKIP_BLANKS;

	mov	esi, DWORD PTR _ret$1$[ebp]
$LN16@xmlParseEn:
	push	edi
	call	_xmlSkipBlankChars

; 5771 :     } while (RAW == '|');

	mov	eax, DWORD PTR [edi+36]
	add	esp, 4
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 124					; 0000007cH
	je	$LL4@xmlParseEn

; 5772 :     if (RAW != ')') {

	cmp	al, 41					; 00000029H
	je	SHORT $LN17@xmlParseEn

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edi+212], 0
	je	SHORT $LN158@xmlParseEn
	cmp	DWORD PTR [edi+172], -1
	je	$LN153@xmlParseEn
$LN158@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CL@KPIIIINI@?8?$CJ?8?5required?5to?5finish?5ATTLIST?5@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [edi+84], 51			; 00000033H
	push	51					; 00000033H

; 5773 : 	xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_FINISHED, NULL);
; 5774 : 	return(ret);

	jmp	SHORT $LN261@xmlParseEn
$LN17@xmlParseEn:

; 5775 :     }
; 5776 :     NEXT;

	push	edi
	call	_xmlNextChar
	add	esp, 4
	mov	eax, esi
	pop	ebx
	pop	edi

; 5777 :     return(ret);
; 5778 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN228@xmlParseEn:

; 5761 :                 xmlFreeEnumeration(ret);

	push	DWORD PTR _ret$1$[ebp]
	call	_xmlFreeEnumeration
	add	esp, 4

; 5762 :                 return(NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 5777 :     return(ret);
; 5778 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN226@xmlParseEn:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edi+212], 0
	je	SHORT $LN90@xmlParseEn
	cmp	DWORD PTR [edi+172], -1
	je	SHORT $LN153@xmlParseEn
$LN90@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CI@EHCBGKID@NmToken?5expected?5in?5ATTLIST?5enu@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [edi+84], 67			; 00000043H
	push	67					; 00000043H
$LN261@xmlParseEn:

; 555  : 	    ctxt->disableSAX = 1;

	push	1
	push	0
	push	edi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	mov	DWORD PTR [edi+12], 0
	cmp	DWORD PTR [edi+288], 0
	jne	SHORT $LN153@xmlParseEn
	mov	DWORD PTR [edi+212], 1
$LN153@xmlParseEn:
	pop	ebx
	pop	edi

; 5741 : 	    xmlFatalErr(ctxt, XML_ERR_NMTOKEN_REQUIRED, NULL);
; 5742 : 	    return(ret);

	mov	eax, esi

; 5777 :     return(ret);
; 5778 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseEnumerationType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseNotationType
_TEXT	SEGMENT
_last$1$ = -8						; size = 4
_ret$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseNotationType PROC				; COMDAT

; 5657 : xmlParseNotationType(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	mov	DWORD PTR _ret$1$[ebp], esi
	mov	DWORD PTR _last$1$[ebp], esi
	mov	ecx, DWORD PTR [edi+36]
	mov	edx, DWORD PTR [ecx+16]
	cmp	BYTE PTR [edx], 40			; 00000028H
	je	SHORT $LN7@xmlParseNo

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edi+212], esi
	je	SHORT $LN21@xmlParseNo
	cmp	DWORD PTR [edi+172], -1
	je	SHORT $LN84@xmlParseNo
$LN21@xmlParseNo:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BN@HECCFNBP@NOTATION?3?5Name?5expected?5here@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	48					; 00000030H
	push	1
	push	0
	push	edi
	push	0
	push	0
	push	0
	mov	DWORD PTR [edi+84], 48			; 00000030H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [edi+12], esi

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [edi+288], esi
	jne	SHORT $LN84@xmlParseNo

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [edi+212], 1
$LN84@xmlParseNo:
	pop	edi

; 5658 :     const xmlChar *name;
; 5659 :     xmlEnumerationPtr ret = NULL, last = NULL, cur, tmp;
; 5660 : 
; 5661 :     if (RAW != '(') {
; 5662 : 	xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);
; 5663 : 	return(NULL);

	xor	eax, eax

; 5709 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlParseNo:

; 5664 :     }
; 5665 :     SHRINK;

	cmp	DWORD PTR [edi+292], esi
	jne	SHORT $LN187@xmlParseNo
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN187@xmlParseNo
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN187@xmlParseNo
	push	edi
	call	_xmlSHRINK
	add	esp, 4
$LN187@xmlParseNo:
	push	ebx
$LL4@xmlParseNo:

; 5666 :     do {
; 5667 :         NEXT;

	push	edi
	call	_xmlNextChar

; 5668 : 	SKIP_BLANKS;

	push	edi
	call	_xmlSkipBlankChars

; 5669 :         name = xmlParseName(ctxt);

	push	edi
	call	_xmlParseName
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 5670 : 	if (name == NULL) {

	test	ebx, ebx
	je	$LN157@xmlParseNo

; 5675 : 	}
; 5676 : 	tmp = ret;
; 5677 : 	while (tmp != NULL) {

	cmp	DWORD PTR _ret$1$[ebp], 0
	je	SHORT $LN169@xmlParseNo
	npad	5
$LL5@xmlParseNo:

; 5678 : 	    if (xmlStrEqual(name, tmp->name)) {

	push	DWORD PTR [esi+4]
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN156@xmlParseNo

; 5684 : 		break;
; 5685 : 	    }
; 5686 : 	    tmp = tmp->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL5@xmlParseNo
$LN169@xmlParseNo:

; 5689 : 	    cur = xmlCreateEnumeration(name);

	push	ebx
	call	_xmlCreateEnumeration
	add	esp, 4

; 5690 : 	    if (cur == NULL) {

	test	eax, eax
	je	$LN159@xmlParseNo

; 5692 :                 return(NULL);
; 5693 :             }
; 5694 : 	    if (last == NULL) ret = last = cur;

	mov	ecx, DWORD PTR _last$1$[ebp]
	mov	DWORD PTR _last$1$[ebp], eax
	test	ecx, ecx
	jne	SHORT $LN14@xmlParseNo
	mov	esi, eax
	mov	DWORD PTR _ret$1$[ebp], esi
	jmp	SHORT $LN15@xmlParseNo
$LN156@xmlParseNo:

; 5679 : 		xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,

	push	0
	push	ebx
	push	OFFSET ??_C@_0DK@HOPAGHFB@standalone?3?5attribute?5notation?5@
	push	541					; 0000021dH
	push	edi
	call	_xmlValidityError

; 5680 : 	  "standalone: attribute notation value token %s duplicated\n",
; 5681 : 				 name, NULL);
; 5682 : 		if (!xmlDictOwns(ctxt->dict, name))

	push	ebx
	push	DWORD PTR [edi+296]
	call	_xmlDictOwns
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	SHORT $LN186@xmlParseNo

; 5683 : 		    xmlFree((xmlChar *) name);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 5687 : 	}
; 5688 : 	if (tmp == NULL) {

	jmp	SHORT $LN186@xmlParseNo
$LN14@xmlParseNo:

; 5695 : 	    else {
; 5696 : 		last->next = cur;

	mov	DWORD PTR [ecx], eax
$LN186@xmlParseNo:

; 5697 : 		last = cur;
; 5698 : 	    }
; 5699 : 	}
; 5700 : 	SKIP_BLANKS;

	mov	esi, DWORD PTR _ret$1$[ebp]
$LN15@xmlParseNo:
	push	edi
	call	_xmlSkipBlankChars

; 5701 :     } while (RAW == '|');

	mov	eax, DWORD PTR [edi+36]
	add	esp, 4
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 124					; 0000007cH
	je	$LL4@xmlParseNo

; 5702 :     if (RAW != ')') {

	cmp	al, 41					; 00000029H
	je	SHORT $LN16@xmlParseNo

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edi+212], 0
	je	SHORT $LN89@xmlParseNo
	cmp	DWORD PTR [edi+172], -1
	je	SHORT $LN152@xmlParseNo
$LN89@xmlParseNo:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CL@MHMGOJAD@?8?$DO?8?5required?5to?5close?5NOTATION?5@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	49					; 00000031H
	push	1
	push	0
	push	edi
	push	0
	push	0
	push	0
	mov	DWORD PTR [edi+84], 49			; 00000031H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [edi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [edi+288], 0
	jne	SHORT $LN152@xmlParseNo

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [edi+212], 1
$LN152@xmlParseNo:

; 5703 : 	xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);
; 5704 :         xmlFreeEnumeration(ret);

	push	esi
	call	_xmlFreeEnumeration
	add	esp, 4
	xor	eax, eax
	pop	ebx
	pop	edi

; 5709 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlParseNo:

; 5705 : 	return(NULL);
; 5706 :     }
; 5707 :     NEXT;

	push	edi
	call	_xmlNextChar
	add	esp, 4

; 5708 :     return(ret);

	mov	eax, esi
	pop	ebx
	pop	edi

; 5709 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN159@xmlParseNo:

; 5691 :                 xmlFreeEnumeration(ret);

	push	DWORD PTR _ret$1$[ebp]
	call	_xmlFreeEnumeration
	add	esp, 4
	xor	eax, eax
	pop	ebx
	pop	edi

; 5709 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN157@xmlParseNo:

; 5671 : 	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0CH@MHDABFNP@Name?5expected?5in?5NOTATION?5decla@
	push	68					; 00000044H
	push	edi
	call	_xmlFatalErrMsg

; 5672 : 			   "Name expected in NOTATION declaration\n");
; 5673 :             xmlFreeEnumeration(ret);

	push	esi
	call	_xmlFreeEnumeration
	add	esp, 16					; 00000010H

; 5674 : 	    return(NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 5709 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseNotationType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseDefaultDecl
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlParseDefaultDecl PROC				; COMDAT

; 5607 : xmlParseDefaultDecl(xmlParserCtxtPtr ctxt, xmlChar **value) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _value$[ebp]
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	mov	bl, BYTE PTR [eax]
	cmp	bl, 35					; 00000023H
	jne	$LN13@xmlParseDe

; 5608 :     int val;
; 5609 :     xmlChar *ret;
; 5610 : 
; 5611 :     *value = NULL;
; 5612 :     if (CMP9(CUR_PTR, '#', 'R', 'E', 'Q', 'U', 'I', 'R', 'E', 'D')) {

	mov	dl, BYTE PTR [eax+1]
	cmp	dl, 82					; 00000052H
	jne	SHORT $LN11@xmlParseDe
	cmp	BYTE PTR [eax+2], 69			; 00000045H
	jne	SHORT $LN11@xmlParseDe
	cmp	BYTE PTR [eax+3], 81			; 00000051H
	jne	SHORT $LN11@xmlParseDe
	cmp	BYTE PTR [eax+4], 85			; 00000055H
	jne	SHORT $LN11@xmlParseDe
	cmp	BYTE PTR [eax+5], 73			; 00000049H
	jne	SHORT $LN11@xmlParseDe
	cmp	BYTE PTR [eax+6], dl
	jne	SHORT $LN11@xmlParseDe
	cmp	BYTE PTR [eax+7], 69			; 00000045H
	jne	SHORT $LN11@xmlParseDe
	cmp	BYTE PTR [eax+8], 68			; 00000044H
	jne	SHORT $LN11@xmlParseDe

; 5613 : 	SKIP(9);

	add	DWORD PTR [esi+200], 9
	add	DWORD PTR [ecx+16], 9
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 9
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseDe
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseDe:

; 5614 : 	return(XML_ATTRIBUTE_REQUIRED);

	pop	esi
	mov	eax, 2

; 5637 : }

	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlParseDe:

; 5615 :     }
; 5616 :     if (CMP8(CUR_PTR, '#', 'I', 'M', 'P', 'L', 'I', 'E', 'D')) {

	cmp	dl, 73					; 00000049H
	jne	SHORT $LN13@xmlParseDe
	cmp	BYTE PTR [eax+2], 77			; 0000004dH
	jne	SHORT $LN13@xmlParseDe
	cmp	BYTE PTR [eax+3], 80			; 00000050H
	jne	SHORT $LN13@xmlParseDe
	cmp	BYTE PTR [eax+4], 76			; 0000004cH
	jne	SHORT $LN13@xmlParseDe
	cmp	BYTE PTR [eax+5], dl
	jne	SHORT $LN13@xmlParseDe
	cmp	BYTE PTR [eax+6], 69			; 00000045H
	jne	SHORT $LN13@xmlParseDe
	cmp	BYTE PTR [eax+7], 68			; 00000044H
	jne	SHORT $LN13@xmlParseDe

; 5617 : 	SKIP(8);

	add	DWORD PTR [esi+200], 8
	add	DWORD PTR [ecx+16], 8
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 8
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN5@xmlParseDe
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN5@xmlParseDe:

; 5618 : 	return(XML_ATTRIBUTE_IMPLIED);

	pop	esi
	mov	eax, 3

; 5637 : }

	pop	ebx
	pop	ebp
	ret	0
$LN13@xmlParseDe:
	push	edi

; 5619 :     }
; 5620 :     val = XML_ATTRIBUTE_NONE;

	mov	edi, 1

; 5621 :     if (CMP6(CUR_PTR, '#', 'F', 'I', 'X', 'E', 'D')) {

	cmp	bl, 35					; 00000023H
	jne	SHORT $LN17@xmlParseDe
	cmp	BYTE PTR [eax+1], 70			; 00000046H
	jne	SHORT $LN17@xmlParseDe
	cmp	BYTE PTR [eax+2], 73			; 00000049H
	jne	SHORT $LN17@xmlParseDe
	cmp	BYTE PTR [eax+3], 88			; 00000058H
	jne	SHORT $LN17@xmlParseDe
	cmp	BYTE PTR [eax+4], 69			; 00000045H
	jne	SHORT $LN17@xmlParseDe
	cmp	BYTE PTR [eax+5], 68			; 00000044H
	jne	SHORT $LN17@xmlParseDe

; 5622 : 	SKIP(6);

	add	DWORD PTR [esi+200], 6
	add	DWORD PTR [ecx+16], 6
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 6
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN8@xmlParseDe
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN8@xmlParseDe:

; 5623 : 	val = XML_ATTRIBUTE_FIXED;
; 5624 : 	if (SKIP_BLANKS == 0) {

	push	esi
	mov	edi, 4
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN17@xmlParseDe

; 5625 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BP@LOJANMBO@Space?5required?5after?5?8?$CDFIXED?8?6@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN17@xmlParseDe:

; 4121 :     if ((ctxt == NULL) || (ctxt->input == NULL)) return(NULL);

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN23@xmlParseDe

; 4122 :     return(xmlParseAttValueInternal(ctxt, NULL, NULL, 0));

	push	0
	push	0
	push	0
	push	esi
	call	_xmlParseAttValueInternal
	add	esp, 16					; 00000010H
	jmp	SHORT $LN21@xmlParseDe
$LN23@xmlParseDe:

; 4121 :     if ((ctxt == NULL) || (ctxt->input == NULL)) return(NULL);

	xor	eax, eax
$LN21@xmlParseDe:

; 5626 : 			   "Space required after '#FIXED'\n");
; 5627 : 	}
; 5628 :     }
; 5629 :     ret = xmlParseAttValue(ctxt);
; 5630 :     ctxt->instate = XML_PARSER_DTD;

	mov	DWORD PTR [esi+172], 3

; 5631 :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN18@xmlParseDe

; 5632 : 	xmlFatalErrMsg(ctxt, (xmlParserErrors)ctxt->errNo,

	push	OFFSET ??_C@_0CL@MHGJEBGE@Attribute?5default?5value?5declara@
	push	DWORD PTR [esi+84]
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 5636 :     return(val);

	mov	eax, edi
	pop	edi
	pop	esi

; 5637 : }

	pop	ebx
	pop	ebp
	ret	0
$LN18@xmlParseDe:

; 5633 : 		       "Attribute default value declaration error\n");
; 5634 :     } else
; 5635 :         *value = ret;

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax

; 5636 :     return(val);

	mov	eax, edi
	pop	edi
	pop	esi

; 5637 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlParseDefaultDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEntityDecl
_TEXT	SEGMENT
_inputid$1$ = -24					; size = 4
_isParameter$1$ = -20					; size = 4
_value$1$ = -16						; size = 4
_orig$ = -12						; size = 4
_literal$ = -8						; size = 4
_orig$1$ = -4						; size = 4
_URI$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseEntityDecl PROC				; COMDAT

; 5334 : xmlParseEntityDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _isParameter$1$[ebp], ecx
	xor	eax, eax
	mov	DWORD PTR _value$1$[ebp], 0
	mov	DWORD PTR _literal$[ebp], 0
	mov	edx, DWORD PTR [esi+36]
	mov	DWORD PTR _orig$1$[ebp], eax
	mov	DWORD PTR _orig$[ebp], eax
	mov	ecx, DWORD PTR [edx+16]
	cmp	BYTE PTR [ecx], 60			; 0000003cH
	jne	$LN71@xmlParseEn

; 5335 :     const xmlChar *name = NULL;
; 5336 :     xmlChar *value = NULL;
; 5337 :     xmlChar *URI = NULL, *literal = NULL;
; 5338 :     const xmlChar *ndata = NULL;
; 5339 :     int isParameter = 0;
; 5340 :     xmlChar *orig = NULL;
; 5341 : 
; 5342 :     /* GROW; done in the caller */
; 5343 :     if (CMP8(CUR_PTR, '<', '!', 'E', 'N', 'T', 'I', 'T', 'Y')) {

	cmp	BYTE PTR [ecx+1], 33			; 00000021H
	jne	$LN71@xmlParseEn
	cmp	BYTE PTR [ecx+2], 69			; 00000045H
	jne	$LN71@xmlParseEn
	cmp	BYTE PTR [ecx+3], 78			; 0000004eH
	jne	$LN71@xmlParseEn
	cmp	BYTE PTR [ecx+4], 84			; 00000054H
	jne	$LN71@xmlParseEn
	cmp	BYTE PTR [ecx+5], 73			; 00000049H
	jne	$LN71@xmlParseEn
	cmp	BYTE PTR [ecx+6], 84			; 00000054H
	jne	$LN71@xmlParseEn
	cmp	BYTE PTR [ecx+7], 89			; 00000059H
	jne	$LN71@xmlParseEn

; 5344 : 	int inputid = ctxt->input->id;
; 5345 : 	SHRINK;

	cmp	DWORD PTR [esi+292], 0
	mov	eax, DWORD PTR [edx+56]
	push	edi
	mov	DWORD PTR _inputid$1$[ebp], eax
	mov	edi, edx
	jne	SHORT $LN4@xmlParseEn
	mov	eax, ecx
	sub	eax, DWORD PTR [edx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN4@xmlParseEn
	mov	eax, DWORD PTR [edx+20]
	sub	eax, ecx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN4@xmlParseEn
	push	esi
	call	_xmlSHRINK
	mov	edi, DWORD PTR [esi+36]
	add	esp, 4
$LN4@xmlParseEn:

; 5346 : 	SKIP(8);

	add	DWORD PTR [esi+200], 8
	add	DWORD PTR [edi+16], 8
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 8
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseEn
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseEn:

; 5347 : 	if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@xmlParseEn

; 5348 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CB@NEOBPNBE@Space?5required?5after?5?8?$DM?$CBENTITY?8@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN11@xmlParseEn:

; 5349 : 			   "Space required after '<!ENTITY'\n");
; 5350 : 	}
; 5351 : 
; 5352 : 	if (RAW == '%') {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 37			; 00000025H
	jne	SHORT $LN358@xmlParseEn

; 5353 : 	    NEXT;

	push	esi
	call	_xmlNextChar

; 5354 : 	    if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlParseEn

; 5355 : 		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BL@KGADBCMF@Space?5required?5after?5?8?$CF?$CF?8?6@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN13@xmlParseEn:

; 5356 : 			       "Space required after '%%'\n");
; 5357 : 	    }
; 5358 : 	    isParameter = 1;

	mov	edi, 1
	mov	DWORD PTR _isParameter$1$[ebp], edi
	jmp	SHORT $LN12@xmlParseEn
$LN358@xmlParseEn:

; 5349 : 			   "Space required after '<!ENTITY'\n");
; 5350 : 	}
; 5351 : 
; 5352 : 	if (RAW == '%') {

	xor	edi, edi
$LN12@xmlParseEn:
	push	ebx

; 5359 : 	}
; 5360 : 
; 5361 :         name = xmlParseName(ctxt);

	push	esi
	call	_xmlParseName
	mov	ebx, eax
	add	esp, 4

; 5362 : 	if (name == NULL) {

	test	ebx, ebx
	jne	SHORT $LN14@xmlParseEn

; 5363 : 	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0BN@GJOFDJCB@xmlParseEntityDecl?3?5no?5name?6@
	push	68					; 00000044H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
	pop	ebx
	pop	edi
	pop	esi

; 5574 :     }
; 5575 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlParseEn:

; 5364 : 	                   "xmlParseEntityDecl: no name\n");
; 5365 :             return;
; 5366 : 	}
; 5367 : 	if (xmlStrchr(name, ':') != NULL) {

	push	58					; 0000003aH
	push	ebx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlParseEn

; 5368 : 	    xmlNsErr(ctxt, XML_NS_ERR_COLON,

	push	0
	push	0
	push	ebx
	push	OFFSET ??_C@_0CP@IEOCAMEB@colons?5are?5forbidden?5from?5entit@
	push	205					; 000000cdH
	push	esi
	call	_xmlNsErr
	add	esp, 24					; 00000018H
$LN15@xmlParseEn:

; 5369 : 		     "colons are forbidden from entities names '%s'\n",
; 5370 : 		     name, NULL, NULL);
; 5371 : 	}
; 5372 : 	if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN16@xmlParseEn

; 5373 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CG@IGJCKADK@Space?5required?5after?5the?5entity@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN16@xmlParseEn:

; 5374 : 			   "Space required after the entity name\n");
; 5375 : 	}
; 5376 : 
; 5377 : 	ctxt->instate = XML_PARSER_ENTITY_DECL;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+172], 10			; 0000000aH
	mov	eax, DWORD PTR [eax+16]

; 5378 : 	/*
; 5379 : 	 * handle the various case of definitions...
; 5380 : 	 */
; 5381 : 	if (isParameter) {

	mov	al, BYTE PTR [eax]
	test	edi, edi
	je	$LN17@xmlParseEn

; 5382 : 	    if ((RAW == '"') || (RAW == '\'')) {

	cmp	al, 34					; 00000022H
	je	$LN21@xmlParseEn
	cmp	al, 39					; 00000027H
	je	$LN21@xmlParseEn

; 5388 : 		                    XML_INTERNAL_PARAMETER_ENTITY,
; 5389 : 				    NULL, NULL, value);
; 5390 : 		}
; 5391 : 	    } else {
; 5392 : 	        URI = xmlParseExternalID(ctxt, &literal, 1);

	push	1
	lea	eax, DWORD PTR _literal$[ebp]
	push	eax
	push	esi
	call	_xmlParseExternalID
	mov	edi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _URI$1$[ebp], edi

; 5393 : 		if ((URI == NULL) && (literal == NULL)) {

	test	edi, edi
	jne	SHORT $LN347@xmlParseEn
	cmp	DWORD PTR _literal$[ebp], eax
	jne	$LN35@xmlParseEn

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], eax
	je	SHORT $LN76@xmlParseEn
	cmp	DWORD PTR [esi+172], -1
	je	$LN357@xmlParseEn
$LN76@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BG@LMNHCPFE@Entity?5value?5required@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	84					; 00000054H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 84			; 00000054H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	$LN35@xmlParseEn

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1

; 5394 : 		    xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);
; 5395 : 		}
; 5396 : 		if (URI) {

	jmp	$LN35@xmlParseEn
$LN347@xmlParseEn:

; 5397 : 		    xmlURIPtr uri;
; 5398 : 
; 5399 : 		    uri = xmlParseURI((const char *) URI);

	push	edi
	call	_xmlParseURI
	mov	edi, eax
	add	esp, 4

; 5400 : 		    if (uri == NULL) {

	test	edi, edi
	jne	SHORT $LN26@xmlParseEn

; 5401 : 		        xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,

	mov	edi, DWORD PTR _URI$1$[ebp]
	push	edi
	push	OFFSET ??_C@_0BB@JHEINHI@Invalid?5URI?3?5?$CFs?6@
	push	91					; 0000005bH
	push	esi
	call	_xmlErrMsgStr
	add	esp, 16					; 00000010H

; 5402 : 				     "Invalid URI: %s\n", URI);
; 5403 : 			/*
; 5404 : 			 * This really ought to be a well formedness error
; 5405 : 			 * but the XML Core WG decided otherwise c.f. issue
; 5406 : 			 * E26 of the XML erratas.
; 5407 : 			 */
; 5408 : 		    } else {

	jmp	$LN35@xmlParseEn
$LN26@xmlParseEn:

; 5409 : 			if (uri->fragment != NULL) {

	cmp	DWORD PTR [edi+32], 0
	je	SHORT $LN28@xmlParseEn

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN144@xmlParseEn
	cmp	DWORD PTR [esi+172], -1
	je	$LN30@xmlParseEn
$LN144@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BF@DMGJOFPK@Fragment?5not?5allowed@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	92					; 0000005cH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 92			; 0000005cH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN30@xmlParseEn

; 5420 : 					    XML_EXTERNAL_PARAMETER_ENTITY,
; 5421 : 					    literal, URI, NULL);
; 5422 : 			}
; 5423 : 			xmlFreeURI(uri);

	push	edi

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1

; 5420 : 					    XML_EXTERNAL_PARAMETER_ENTITY,
; 5421 : 					    literal, URI, NULL);
; 5422 : 			}
; 5423 : 			xmlFreeURI(uri);

	call	_xmlFreeURI
	mov	edi, DWORD PTR _URI$1$[ebp]
	add	esp, 4
	jmp	$LN35@xmlParseEn
$LN28@xmlParseEn:

; 5410 : 			    /*
; 5411 : 			     * Okay this is foolish to block those but not
; 5412 : 			     * invalid URIs.
; 5413 : 			     */
; 5414 : 			    xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);
; 5415 : 			} else {
; 5416 : 			    if ((ctxt->sax != NULL) &&
; 5417 : 				(!ctxt->disableSAX) &&

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN30@xmlParseEn
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN30@xmlParseEn
	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	je	SHORT $LN30@xmlParseEn

; 5418 : 				(ctxt->sax->entityDecl != NULL))
; 5419 : 				ctxt->sax->entityDecl(ctxt->userData, name,

	mov	ecx, DWORD PTR _URI$1$[ebp]
	push	0
	push	ecx
	push	DWORD PTR _literal$[ebp]
	push	5
	push	ebx
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 24					; 00000018H
$LN30@xmlParseEn:

; 5420 : 					    XML_EXTERNAL_PARAMETER_ENTITY,
; 5421 : 					    literal, URI, NULL);
; 5422 : 			}
; 5423 : 			xmlFreeURI(uri);

	push	edi
	call	_xmlFreeURI
	mov	edi, DWORD PTR _URI$1$[ebp]
	add	esp, 4
	jmp	$LN35@xmlParseEn
$LN21@xmlParseEn:

; 5383 : 	        value = xmlParseEntityValue(ctxt, &orig);

	lea	eax, DWORD PTR _orig$[ebp]
	push	eax
	push	esi
	call	_xmlParseEntityValue
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR _value$1$[ebp], edi

; 5384 : 		if (value) {

	test	edi, edi
	je	$LN350@xmlParseEn

; 5385 : 		    if ((ctxt->sax != NULL) &&
; 5386 : 			(!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	$LN350@xmlParseEn
	cmp	DWORD PTR [esi+212], 0
	jne	$LN350@xmlParseEn
	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	je	$LN350@xmlParseEn

; 5387 : 			ctxt->sax->entityDecl(ctxt->userData, name,

	push	edi
	push	0
	push	0
	push	4
	push	ebx
	push	DWORD PTR [esi+4]
	call	eax

; 5424 : 		    }
; 5425 : 		}
; 5426 : 	    }
; 5427 : 	} else {

	jmp	$LN362@xmlParseEn
$LN17@xmlParseEn:

; 5428 : 	    if ((RAW == '"') || (RAW == '\'')) {

	cmp	al, 34					; 00000022H
	je	$LN33@xmlParseEn
	cmp	al, 39					; 00000027H
	je	$LN33@xmlParseEn

; 5453 : 			              NULL, NULL, value);
; 5454 : 		}
; 5455 : 	    } else {
; 5456 : 	        URI = xmlParseExternalID(ctxt, &literal, 1);

	push	1
	lea	eax, DWORD PTR _literal$[ebp]
	push	eax
	push	esi
	call	_xmlParseExternalID
	mov	edi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _URI$1$[ebp], edi

; 5457 : 		if ((URI == NULL) && (literal == NULL)) {

	test	edi, edi
	jne	SHORT $LN346@xmlParseEn
	cmp	DWORD PTR _literal$[ebp], eax
	jne	$LN43@xmlParseEn

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], eax
	je	SHORT $LN212@xmlParseEn
	cmp	DWORD PTR [esi+172], -1
	je	$LN43@xmlParseEn
$LN212@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BG@LMNHCPFE@Entity?5value?5required@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	84					; 00000054H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 84			; 00000054H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	$LN43@xmlParseEn

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1

; 5458 : 		    xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);
; 5459 : 		}
; 5460 : 		if (URI) {

	jmp	$LN43@xmlParseEn
$LN346@xmlParseEn:

; 5461 : 		    xmlURIPtr uri;
; 5462 : 
; 5463 : 		    uri = xmlParseURI((const char *)URI);

	push	edi
	call	_xmlParseURI
	mov	edi, eax
	add	esp, 4

; 5464 : 		    if (uri == NULL) {

	test	edi, edi
	jne	SHORT $LN42@xmlParseEn

; 5465 : 		        xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,

	mov	edi, DWORD PTR _URI$1$[ebp]
	push	edi
	push	OFFSET ??_C@_0BB@JHEINHI@Invalid?5URI?3?5?$CFs?6@
	push	91					; 0000005bH
	push	esi
	call	_xmlErrMsgStr
	add	esp, 16					; 00000010H

; 5466 : 				     "Invalid URI: %s\n", URI);
; 5467 : 			/*
; 5468 : 			 * This really ought to be a well formedness error
; 5469 : 			 * but the XML Core WG decided otherwise c.f. issue
; 5470 : 			 * E26 of the XML erratas.
; 5471 : 			 */
; 5472 : 		    } else {

	jmp	SHORT $LN43@xmlParseEn
$LN42@xmlParseEn:

; 5473 : 			if (uri->fragment != NULL) {

	cmp	DWORD PTR [edi+32], 0
	je	SHORT $LN343@xmlParseEn

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN280@xmlParseEn
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN343@xmlParseEn
$LN280@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BF@DMGJOFPK@Fragment?5not?5allowed@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	92					; 0000005cH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 92			; 0000005cH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN343@xmlParseEn

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN343@xmlParseEn:

; 5474 : 			    /*
; 5475 : 			     * Okay this is foolish to block those but not
; 5476 : 			     * invalid URIs.
; 5477 : 			     */
; 5478 : 			    xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);
; 5479 : 			}
; 5480 : 			xmlFreeURI(uri);

	push	edi
	call	_xmlFreeURI
	mov	edi, DWORD PTR _URI$1$[ebp]
	add	esp, 4
$LN43@xmlParseEn:

; 5481 : 		    }
; 5482 : 		}
; 5483 : 		if ((RAW != '>') && (SKIP_BLANKS == 0)) {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 62			; 0000003eH
	je	SHORT $LN45@xmlParseEn
	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN45@xmlParseEn

; 5484 : 		    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BP@NPDMAEIM@Space?5required?5before?5?8NDATA?8?6@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN45@xmlParseEn:

; 5485 : 				   "Space required before 'NDATA'\n");
; 5486 : 		}
; 5487 : 		if (CMP5(CUR_PTR, 'N', 'D', 'A', 'T', 'A')) {

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 78			; 0000004eH
	jne	$LN46@xmlParseEn
	cmp	BYTE PTR [eax+1], 68			; 00000044H
	jne	$LN46@xmlParseEn
	cmp	BYTE PTR [eax+2], 65			; 00000041H
	jne	$LN46@xmlParseEn
	cmp	BYTE PTR [eax+3], 84			; 00000054H
	jne	$LN46@xmlParseEn
	cmp	BYTE PTR [eax+4], 65			; 00000041H
	jne	$LN46@xmlParseEn

; 5488 : 		    SKIP(5);

	add	DWORD PTR [esi+200], 5
	add	DWORD PTR [ecx+16], 5
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 5
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN5@xmlParseEn
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN5@xmlParseEn:

; 5489 : 		    if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN49@xmlParseEn

; 5490 : 			xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BO@GLBCJEIC@Space?5required?5after?5?8NDATA?8?6@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN49@xmlParseEn:

; 5491 : 				       "Space required after 'NDATA'\n");
; 5492 : 		    }
; 5493 : 		    ndata = xmlParseName(ctxt);

	push	esi
	call	_xmlParseName

; 5494 : 		    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&

	mov	ecx, DWORD PTR [esi]
	add	esp, 4
	test	ecx, ecx
	je	$LN35@xmlParseEn
	cmp	DWORD PTR [esi+212], 0
	jne	$LN35@xmlParseEn
	mov	ecx, DWORD PTR [ecx+40]
	test	ecx, ecx
	je	$LN35@xmlParseEn

; 5495 : 		        (ctxt->sax->unparsedEntityDecl != NULL))
; 5496 : 			ctxt->sax->unparsedEntityDecl(ctxt->userData, name,

	push	eax
	push	edi
	push	DWORD PTR _literal$[ebp]
	push	ebx
	push	DWORD PTR [esi+4]
	call	ecx
	add	esp, 20					; 00000014H

; 5497 : 				    literal, URI, ndata);
; 5498 : 		} else {

	jmp	$LN35@xmlParseEn
$LN46@xmlParseEn:

; 5499 : 		    if ((ctxt->sax != NULL) &&
; 5500 : 		        (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN51@xmlParseEn
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN51@xmlParseEn
	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	je	SHORT $LN51@xmlParseEn

; 5501 : 			ctxt->sax->entityDecl(ctxt->userData, name,

	push	0
	push	edi
	push	DWORD PTR _literal$[ebp]
	push	2
	push	ebx
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 24					; 00000018H
$LN51@xmlParseEn:

; 5502 : 				    XML_EXTERNAL_GENERAL_PARSED_ENTITY,
; 5503 : 				    literal, URI, NULL);
; 5504 : 		    /*
; 5505 : 		     * For expat compatibility in SAX mode.
; 5506 : 		     * assuming the entity repalcement was asked for
; 5507 : 		     */
; 5508 : 		    if ((ctxt->replaceEntities != 0) &&

	cmp	DWORD PTR [esi+16], 0
	je	$LN35@xmlParseEn
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN53@xmlParseEn
	push	OFFSET ??_C@_0CA@CHJJOFGL@SAX?5compatibility?5mode?5document@
	push	DWORD PTR [eax+56]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN35@xmlParseEn
$LN53@xmlParseEn:

; 5509 : 			((ctxt->myDoc == NULL) ||
; 5510 : 			(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE)))) {
; 5511 : 			if (ctxt->myDoc == NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jne	SHORT $LN54@xmlParseEn

; 5512 : 			    ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);

	push	OFFSET ??_C@_0CA@CHJJOFGL@SAX?5compatibility?5mode?5document@
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 5513 : 			    if (ctxt->myDoc == NULL) {

	test	eax, eax
	je	$LN349@xmlParseEn

; 5514 : 			        xmlErrMemory(ctxt, "New Doc failed");
; 5515 : 				return;
; 5516 : 			    }
; 5517 : 			    ctxt->myDoc->properties = XML_DOC_INTERNAL;

	mov	DWORD PTR [eax+92], 64			; 00000040H
	mov	eax, DWORD PTR [esi+8]
$LN54@xmlParseEn:

; 5518 : 			}
; 5519 : 
; 5520 : 			if (ctxt->myDoc->intSubset == NULL)

	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN56@xmlParseEn

; 5521 : 			    ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,

	push	0
	push	0
	push	OFFSET ??_C@_04PADNKBEK@fake@
	push	eax
	call	_xmlNewDtd
	mov	ecx, DWORD PTR [esi+8]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx+44], eax
$LN56@xmlParseEn:

; 5522 : 						BAD_CAST "fake", NULL, NULL);
; 5523 : 			xmlSAX2EntityDecl(ctxt, name,

	push	0
	push	edi
	push	DWORD PTR _literal$[ebp]
	push	2
	push	ebx
	push	esi
	call	_xmlSAX2EntityDecl
	add	esp, 24					; 00000018H
	jmp	$LN35@xmlParseEn
$LN33@xmlParseEn:

; 5429 : 	        value = xmlParseEntityValue(ctxt, &orig);

	lea	eax, DWORD PTR _orig$[ebp]
	push	eax
	push	esi
	call	_xmlParseEntityValue
	mov	edi, eax
	add	esp, 8

; 5430 : 		if ((ctxt->sax != NULL) &&
; 5431 : 		    (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _value$1$[ebp], edi
	test	eax, eax
	je	SHORT $LN34@xmlParseEn
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN34@xmlParseEn
	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	je	SHORT $LN34@xmlParseEn

; 5432 : 		    ctxt->sax->entityDecl(ctxt->userData, name,

	push	edi
	push	0
	push	0
	push	1
	push	ebx
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 24					; 00000018H
$LN34@xmlParseEn:

; 5433 : 				XML_INTERNAL_GENERAL_ENTITY,
; 5434 : 				NULL, NULL, value);
; 5435 : 		/*
; 5436 : 		 * For expat compatibility in SAX mode.
; 5437 : 		 */
; 5438 : 		if ((ctxt->myDoc == NULL) ||

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN36@xmlParseEn
	push	OFFSET ??_C@_0CA@CHJJOFGL@SAX?5compatibility?5mode?5document@
	push	DWORD PTR [eax+56]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN350@xmlParseEn
$LN36@xmlParseEn:

; 5439 : 		    (xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {
; 5440 : 		    if (ctxt->myDoc == NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jne	SHORT $LN37@xmlParseEn

; 5441 : 			ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);

	push	OFFSET ??_C@_0CA@CHJJOFGL@SAX?5compatibility?5mode?5document@
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 5442 : 			if (ctxt->myDoc == NULL) {

	test	eax, eax
	jne	SHORT $LN38@xmlParseEn
$LN349@xmlParseEn:

; 5443 : 			    xmlErrMemory(ctxt, "New Doc failed");

	push	OFFSET ??_C@_0P@IDBIGKBI@New?5Doc?5failed@
	push	esi
	call	_xmlErrMemory
	add	esp, 8
	pop	ebx
	pop	edi
	pop	esi

; 5574 :     }
; 5575 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@xmlParseEn:

; 5444 : 			    return;
; 5445 : 			}
; 5446 : 			ctxt->myDoc->properties = XML_DOC_INTERNAL;

	mov	DWORD PTR [eax+92], 64			; 00000040H
	mov	eax, DWORD PTR [esi+8]
$LN37@xmlParseEn:

; 5447 : 		    }
; 5448 : 		    if (ctxt->myDoc->intSubset == NULL)

	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN39@xmlParseEn

; 5449 : 			ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,

	push	0
	push	0
	push	OFFSET ??_C@_04PADNKBEK@fake@
	push	eax
	call	_xmlNewDtd
	mov	ecx, DWORD PTR [esi+8]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx+44], eax
$LN39@xmlParseEn:

; 5450 : 					    BAD_CAST "fake", NULL, NULL);
; 5451 : 
; 5452 : 		    xmlSAX2EntityDecl(ctxt, name, XML_INTERNAL_GENERAL_ENTITY,

	push	edi
	push	0
	push	0
	push	1
	push	ebx
	push	esi
	call	_xmlSAX2EntityDecl
$LN362@xmlParseEn:

; 5524 : 				          XML_EXTERNAL_GENERAL_PARSED_ENTITY,
; 5525 : 				          literal, URI, NULL);
; 5526 : 		    }
; 5527 : 		}
; 5528 : 	    }
; 5529 : 	}
; 5530 : 	if (ctxt->instate == XML_PARSER_EOF)

	add	esp, 24					; 00000018H
$LN350@xmlParseEn:
	mov	eax, DWORD PTR _orig$[ebp]
	xor	edi, edi
	mov	DWORD PTR _orig$1$[ebp], eax
$LN35@xmlParseEn:
	cmp	DWORD PTR [esi+172], -1
	je	$LN357@xmlParseEn

; 5531 : 	    goto done;
; 5532 : 	SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 5533 : 	if (RAW != '>') {

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 62			; 0000003eH
	je	SHORT $LN58@xmlParseEn

; 5534 : 	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,

	push	ebx
	push	OFFSET ??_C@_0CO@GFOAPJBJ@xmlParseEntityDecl?3?5entity?5?$CFs?5n@
	push	37					; 00000025H
	push	esi
	call	_xmlFatalErrMsgStr

; 5535 : 	            "xmlParseEntityDecl: entity %s not terminated\n", name);
; 5536 : 	    xmlHaltParser(ctxt);

	push	esi
	call	_xmlHaltParser
	add	esp, 20					; 00000014H

; 5537 : 	} else {

	jmp	SHORT $LN59@xmlParseEn
$LN58@xmlParseEn:

; 5538 : 	    if (inputid != ctxt->input->id) {

	mov	eax, DWORD PTR _inputid$1$[ebp]
	cmp	eax, DWORD PTR [ecx+56]
	je	SHORT $LN60@xmlParseEn

; 5539 : 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0DO@BLCODNOK@Entity?5declaration?5doesn?8t?5star@
	push	90					; 0000005aH
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN60@xmlParseEn:

; 5540 : 	                       "Entity declaration doesn't start and stop in"
; 5541 :                                " the same entity\n");
; 5542 : 	    }
; 5543 : 	    NEXT;

	push	esi
	call	_xmlNextChar
	add	esp, 4
$LN59@xmlParseEn:

; 5544 : 	}
; 5545 : 	if (orig != NULL) {

	cmp	DWORD PTR _orig$1$[ebp], 0
	je	SHORT $LN357@xmlParseEn

; 5546 : 	    /*
; 5547 : 	     * Ugly mechanism to save the raw entity value.
; 5548 : 	     */
; 5549 : 	    xmlEntityPtr cur = NULL;
; 5550 : 
; 5551 : 	    if (isParameter) {

	cmp	DWORD PTR _isParameter$1$[ebp], 0
	mov	eax, DWORD PTR [esi]
	je	SHORT $LN62@xmlParseEn

; 5552 : 	        if ((ctxt->sax != NULL) &&

	test	eax, eax
	je	SHORT $LN357@xmlParseEn
	mov	eax, DWORD PTR [eax+96]
	test	eax, eax
	je	SHORT $LN357@xmlParseEn

; 5553 : 		    (ctxt->sax->getParameterEntity != NULL))
; 5554 : 		    cur = ctxt->sax->getParameterEntity(ctxt->userData, name);

	push	ebx
	push	DWORD PTR [esi+4]
	call	eax

; 5555 : 	    } else {

	jmp	SHORT $LN363@xmlParseEn
$LN62@xmlParseEn:

; 5556 : 	        if ((ctxt->sax != NULL) &&

	test	eax, eax
	je	SHORT $LN348@xmlParseEn
	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	je	SHORT $LN348@xmlParseEn

; 5557 : 		    (ctxt->sax->getEntity != NULL))
; 5558 : 		    cur = ctxt->sax->getEntity(ctxt->userData, name);

	push	ebx
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 8

; 5559 : 		if ((cur == NULL) && (ctxt->userData==ctxt)) {

	test	eax, eax
	jne	SHORT $LN345@xmlParseEn
$LN348@xmlParseEn:
	cmp	DWORD PTR [esi+4], esi
	jne	SHORT $LN357@xmlParseEn

; 5560 : 		    cur = xmlSAX2GetEntity(ctxt, name);

	push	ebx
	push	esi
	call	_xmlSAX2GetEntity
$LN363@xmlParseEn:

; 5561 : 		}
; 5562 : 	    }
; 5563 :             if ((cur != NULL) && (cur->orig == NULL)) {

	add	esp, 8
	test	eax, eax
	je	SHORT $LN357@xmlParseEn
$LN345@xmlParseEn:
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN357@xmlParseEn

; 5564 : 		cur->orig = orig;

	mov	ecx, DWORD PTR _orig$1$[ebp]

; 5565 :                 orig = NULL;

	xor	ebx, ebx
	mov	DWORD PTR [eax+36], ecx
	jmp	SHORT $done$366
$LN357@xmlParseEn:

; 5566 : 	    }
; 5567 : 	}
; 5568 : 
; 5569 : done:
; 5570 : 	if (value != NULL) xmlFree(value);

	mov	ebx, DWORD PTR _orig$1$[ebp]
$done$366:
	mov	eax, DWORD PTR _value$1$[ebp]
	test	eax, eax
	je	SHORT $LN68@xmlParseEn
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN68@xmlParseEn:

; 5571 : 	if (URI != NULL) xmlFree(URI);

	test	edi, edi
	je	SHORT $LN69@xmlParseEn
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN69@xmlParseEn:

; 5572 : 	if (literal != NULL) xmlFree(literal);

	mov	eax, DWORD PTR _literal$[ebp]
	test	eax, eax
	je	SHORT $LN70@xmlParseEn
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN70@xmlParseEn:

; 5573 :         if (orig != NULL) xmlFree(orig);

	test	ebx, ebx
	je	SHORT $LN360@xmlParseEn
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN360@xmlParseEn:
	pop	ebx
	pop	edi
$LN71@xmlParseEn:
	pop	esi

; 5574 :     }
; 5575 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseEntityDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseNotationDecl
_TEXT	SEGMENT
_inputid$1$ = -8					; size = 4
_Pubid$ = -4						; size = 4
_Systemid$1$ = 8					; size = 4
_ctxt$ = 8						; size = 4
_xmlParseNotationDecl PROC				; COMDAT

; 5256 : xmlParseNotationDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __B9AC27D5_parser@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [edx+16]
	cmp	BYTE PTR [ecx], 60			; 0000003cH
	jne	$LN17@xmlParseNo

; 5257 :     const xmlChar *name;
; 5258 :     xmlChar *Pubid;
; 5259 :     xmlChar *Systemid;
; 5260 : 
; 5261 :     if (CMP10(CUR_PTR, '<', '!', 'N', 'O', 'T', 'A', 'T', 'I', 'O', 'N')) {

	cmp	BYTE PTR [ecx+1], 33			; 00000021H
	jne	$LN17@xmlParseNo
	cmp	BYTE PTR [ecx+2], 78			; 0000004eH
	jne	$LN17@xmlParseNo
	cmp	BYTE PTR [ecx+3], 79			; 0000004fH
	jne	$LN17@xmlParseNo
	cmp	BYTE PTR [ecx+4], 84			; 00000054H
	jne	$LN17@xmlParseNo
	cmp	BYTE PTR [ecx+5], 65			; 00000041H
	jne	$LN17@xmlParseNo
	cmp	BYTE PTR [ecx+6], 84			; 00000054H
	jne	$LN17@xmlParseNo
	cmp	BYTE PTR [ecx+7], 73			; 00000049H
	jne	$LN17@xmlParseNo
	cmp	BYTE PTR [ecx+8], 79			; 0000004fH
	jne	$LN17@xmlParseNo
	cmp	BYTE PTR [ecx+9], 78			; 0000004eH
	jne	$LN17@xmlParseNo

; 5262 : 	int inputid = ctxt->input->id;
; 5263 : 	SHRINK;

	cmp	DWORD PTR [esi+292], 0
	mov	eax, DWORD PTR [edx+56]
	push	edi
	mov	DWORD PTR _inputid$1$[ebp], eax
	mov	edi, edx
	jne	SHORT $LN4@xmlParseNo
	mov	eax, ecx
	sub	eax, DWORD PTR [edx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN4@xmlParseNo
	mov	eax, DWORD PTR [edx+20]
	sub	eax, ecx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN4@xmlParseNo
	push	esi
	call	_xmlSHRINK
	mov	edi, DWORD PTR [esi+36]
	add	esp, 4
$LN4@xmlParseNo:

; 5264 : 	SKIP(10);

	add	DWORD PTR [esi+200], 10			; 0000000aH
	add	DWORD PTR [edi+16], 10			; 0000000aH
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 10			; 0000000aH
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseNo
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseNo:

; 5265 : 	if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@xmlParseNo

; 5266 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CD@ILKLDDEI@Space?5required?5after?5?8?$DM?$CBNOTATIO@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 5308 :     }
; 5309 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlParseNo:

; 5267 : 			   "Space required after '<!NOTATION'\n");
; 5268 : 	    return;
; 5269 : 	}
; 5270 : 
; 5271 :         name = xmlParseName(ctxt);

	push	esi
	call	_xmlParseName
	mov	edi, eax
	add	esp, 4

; 5272 : 	if (name == NULL) {

	test	edi, edi
	jne	SHORT $LN9@xmlParseNo

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], eax
	je	SHORT $LN22@xmlParseNo
	cmp	DWORD PTR [esi+172], -1
	je	$LN155@xmlParseNo
$LN22@xmlParseNo:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BN@HECCFNBP@NOTATION?3?5Name?5expected?5here@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	48					; 00000030H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 48			; 00000030H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	$LN155@xmlParseNo
	pop	edi

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
	pop	esi

; 5308 :     }
; 5309 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlParseNo:

; 5273 : 	    xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);
; 5274 : 	    return;
; 5275 : 	}
; 5276 : 	if (xmlStrchr(name, ':') != NULL) {

	push	58					; 0000003aH
	push	edi
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlParseNo

; 5277 : 	    xmlNsErr(ctxt, XML_NS_ERR_COLON,

	push	0
	push	0
	push	edi
	push	OFFSET ??_C@_0CP@BOHPCDLP@colons?5are?5forbidden?5from?5notat@
	push	205					; 000000cdH
	push	esi
	call	_xmlNsErr
	add	esp, 24					; 00000018H
$LN10@xmlParseNo:

; 5278 : 		     "colons are forbidden from notation names '%s'\n",
; 5279 : 		     name, NULL, NULL);
; 5280 : 	}
; 5281 : 	if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@xmlParseNo

; 5282 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CJ@PMDGLIHG@Space?5required?5after?5the?5NOTATI@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 5308 :     }
; 5309 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlParseNo:
	push	ebx

; 5283 : 		     "Space required after the NOTATION name'\n");
; 5284 : 	    return;
; 5285 : 	}
; 5286 : 
; 5287 : 	/*
; 5288 : 	 * Parse the IDs.
; 5289 : 	 */
; 5290 : 	Systemid = xmlParseExternalID(ctxt, &Pubid, 0);

	push	0
	lea	eax, DWORD PTR _Pubid$[ebp]
	push	eax
	push	esi
	call	_xmlParseExternalID

; 5291 : 	SKIP_BLANKS;

	push	esi
	mov	DWORD PTR _Systemid$1$[ebp], eax
	call	_xmlSkipBlankChars

; 5292 : 
; 5293 : 	if (RAW == '>') {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 16					; 00000010H
	mov	ebx, DWORD PTR _Pubid$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	BYTE PTR [ecx], 62			; 0000003eH
	jne	SHORT $LN12@xmlParseNo

; 5294 : 	    if (inputid != ctxt->input->id) {

	mov	ecx, DWORD PTR _inputid$1$[ebp]
	cmp	ecx, DWORD PTR [eax+56]
	je	SHORT $LN14@xmlParseNo

; 5295 : 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0EA@DCHCOJDP@Notation?5declaration?5doesn?8t?5st@
	push	90					; 0000005aH
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN14@xmlParseNo:

; 5296 : 	                       "Notation declaration doesn't start and stop"
; 5297 :                                " in the same entity\n");
; 5298 : 	    }
; 5299 : 	    NEXT;

	push	esi
	call	_xmlNextChar

; 5300 : 	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&

	mov	eax, DWORD PTR [esi]
	add	esp, 4
	test	eax, eax
	je	$LN153@xmlParseNo
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN153@xmlParseNo
	mov	eax, DWORD PTR [eax+28]
	test	eax, eax
	je	SHORT $LN153@xmlParseNo

; 5301 : 		(ctxt->sax->notationDecl != NULL))
; 5302 : 		ctxt->sax->notationDecl(ctxt->userData, name, Pubid, Systemid);

	push	DWORD PTR _Systemid$1$[ebp]
	push	ebx
	push	edi
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 16					; 00000010H

; 5303 : 	} else {

	jmp	SHORT $LN153@xmlParseNo
$LN12@xmlParseNo:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN90@xmlParseNo
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN153@xmlParseNo
$LN90@xmlParseNo:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CL@MHMGOJAD@?8?$DO?8?5required?5to?5close?5NOTATION?5@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	49					; 00000031H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 49			; 00000031H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN153@xmlParseNo

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN153@xmlParseNo:

; 5304 : 	    xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);
; 5305 : 	}
; 5306 : 	if (Systemid != NULL) xmlFree(Systemid);

	mov	eax, DWORD PTR _Systemid$1$[ebp]
	test	eax, eax
	je	SHORT $LN16@xmlParseNo
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlParseNo:

; 5307 : 	if (Pubid != NULL) xmlFree(Pubid);

	test	ebx, ebx
	je	SHORT $LN156@xmlParseNo
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN156@xmlParseNo:
	pop	ebx
$LN155@xmlParseNo:
	pop	edi
$LN17@xmlParseNo:
	pop	esi

; 5308 :     }
; 5309 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseNotationDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParsePI
_TEXT	SEGMENT
_inputid$1$ = -24					; size = 4
_size$1$ = -20						; size = 4
_count$1$ = -16						; size = 4
_l$ = -12						; size = 4
_state$1$ = -8						; size = 4
_target$1$ = -4						; size = 4
_buf$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParsePI PROC					; COMDAT

; 5094 : xmlParsePI(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	mov	DWORD PTR _count$1$[ebp], eax
	xor	edi, edi
	mov	DWORD PTR _size$1$[ebp], 100		; 00000064H
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	cmp	BYTE PTR [ecx], 60			; 0000003cH
	jne	$LN52@xmlParsePI

; 5095 :     xmlChar *buf = NULL;
; 5096 :     size_t len = 0;
; 5097 :     size_t size = XML_PARSER_BUFFER_SIZE;
; 5098 :     int cur, l;
; 5099 :     const xmlChar *target;
; 5100 :     xmlParserInputState state;
; 5101 :     int count = 0;
; 5102 : 
; 5103 :     if ((RAW == '<') && (NXT(1) == '?')) {

	cmp	BYTE PTR [ecx+1], 63			; 0000003fH
	jne	$LN52@xmlParsePI

; 5104 : 	int inputid = ctxt->input->id;

	mov	ecx, DWORD PTR [eax+56]

; 5105 : 	state = ctxt->instate;
; 5106 :         ctxt->instate = XML_PARSER_PI;
; 5107 : 	/*
; 5108 : 	 * this is a Processing Instruction.
; 5109 : 	 */
; 5110 : 	SKIP(2);

	add	DWORD PTR [esi+200], 2
	push	ebx
	mov	ebx, DWORD PTR [esi+172]
	mov	DWORD PTR [esi+172], 2
	add	DWORD PTR [eax+16], 2
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR _inputid$1$[ebp], ecx
	mov	DWORD PTR _state$1$[ebp], ebx
	add	DWORD PTR [eax+32], 2
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParsePI
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParsePI:

; 5111 : 	SHRINK;

	cmp	DWORD PTR [esi+292], edi
	jne	SHORT $LN18@xmlParsePI
	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN18@xmlParsePI
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN18@xmlParsePI
	push	esi
	call	_xmlSHRINK
	add	esp, 4
$LN18@xmlParsePI:

; 5112 : 
; 5113 : 	/*
; 5114 : 	 * Parse the target name and check for special support like
; 5115 : 	 * namespace.
; 5116 : 	 */
; 5117 :         target = xmlParsePITarget(ctxt);

	push	esi
	call	_xmlParsePITarget
	add	esp, 4
	mov	DWORD PTR _target$1$[ebp], eax

; 5118 : 	if (target != NULL) {

	test	eax, eax
	je	$LN19@xmlParsePI

; 5119 : 	    if ((RAW == '?') && (NXT(1) == '>')) {

	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+16]
	cmp	BYTE PTR [edx], 63			; 0000003fH
	jne	SHORT $LN21@xmlParsePI
	cmp	BYTE PTR [edx+1], 62			; 0000003eH
	jne	SHORT $LN21@xmlParsePI

; 5120 : 		if (inputid != ctxt->input->id) {

	mov	edx, DWORD PTR _inputid$1$[ebp]
	cmp	edx, DWORD PTR [ecx+56]
	je	SHORT $LN7@xmlParsePI

; 5121 : 		    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0DK@LAKAFNGA@PI?5declaration?5doesn?8t?5start?5an@
	push	90					; 0000005aH
	push	esi
	call	_xmlFatalErrMsg
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
$LN7@xmlParsePI:

; 5122 : 	                           "PI declaration doesn't start and stop in"
; 5123 :                                    " the same entity\n");
; 5124 : 		}
; 5125 : 		SKIP(2);

	add	DWORD PTR [esi+200], 2
	add	DWORD PTR [ecx+16], 2
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 2
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN5@xmlParsePI
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN5@xmlParsePI:

; 5126 : 
; 5127 : 		/*
; 5128 : 		 * SAX: PI detected.
; 5129 : 		 */
; 5130 : 		if ((ctxt->sax) && (!ctxt->disableSAX) &&

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	$LN130@xmlParsePI
	cmp	DWORD PTR [esi+212], edi
	jne	$LN130@xmlParsePI
	mov	eax, DWORD PTR [eax+76]
	test	eax, eax
	je	$LN130@xmlParsePI

; 5131 : 		    (ctxt->sax->processingInstruction != NULL))
; 5132 : 		    ctxt->sax->processingInstruction(ctxt->userData,

	push	0
	push	DWORD PTR _target$1$[ebp]
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 12					; 0000000cH

; 5133 : 		                                     target, NULL);
; 5134 : 		if (ctxt->instate != XML_PARSER_EOF)
; 5135 : 		    ctxt->instate = state;
; 5136 : 		return;

	jmp	$LN130@xmlParsePI
$LN21@xmlParsePI:

; 5137 : 	    }
; 5138 : 	    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	push	100					; 00000064H
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR _buf$1$[ebp], eax

; 5139 : 	    if (buf == NULL) {

	test	eax, eax
	jne	SHORT $LN26@xmlParsePI

; 5140 : 		xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory
	add	esp, 8

; 5235 : 	    ctxt->instate = state;

	mov	DWORD PTR [esi+172], ebx
	pop	ebx
	pop	edi

; 5236 :     }
; 5237 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlParsePI:

; 5141 : 		ctxt->instate = state;
; 5142 : 		return;
; 5143 : 	    }
; 5144 : 	    if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN27@xmlParsePI

; 5145 : 		xmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,

	push	DWORD PTR _target$1$[ebp]
	push	OFFSET ??_C@_0BP@KBNJPEOK@ParsePI?3?5PI?5?$CFs?5space?5expected?6@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H
$LN27@xmlParsePI:

; 5146 : 			  "ParsePI: PI %s space expected\n", target);
; 5147 : 	    }
; 5148 : 	    cur = CUR_CHAR(l);
; 5149 : 	    while (IS_CHAR(cur) && /* checked */

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	mov	ebx, eax
	add	esp, 8
$LL8@xmlParsePI:
	cmp	ebx, 256				; 00000100H
	jge	SHORT $LN140@xmlParsePI
	cmp	ebx, 9
	jl	SHORT $LN54@xmlParsePI
	cmp	ebx, 10					; 0000000aH
	jle	SHORT $LN58@xmlParsePI
$LN54@xmlParsePI:
	cmp	ebx, 13					; 0000000dH
	je	SHORT $LN58@xmlParsePI
	cmp	ebx, 32					; 00000020H
	jge	SHORT $LN58@xmlParsePI
$LN138@xmlParsePI:

; 5190 :             if ((len > XML_MAX_TEXT_LENGTH) &&

	cmp	edi, 10000000				; 00989680H
	jbe	$LN42@xmlParsePI
	test	DWORD PTR [esi+360], 524288		; 00080000H
	jne	$LN42@xmlParsePI
$LN135@xmlParsePI:

; 5191 :                 ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 5192 :                 xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,

	push	DWORD PTR _target$1$[ebp]
	push	OFFSET ??_C@_0BE@KDNCGJGM@PI?5?$CFs?5too?5big?5found@
	push	47					; 0000002fH
	push	esi
	call	_xmlFatalErrMsgStr

; 5193 :                                   "PI %s too big found", target);
; 5194 :                 xmlFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	DWORD PTR _xmlFree

; 5195 :                 ctxt->instate = state;

	mov	eax, DWORD PTR _state$1$[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR [esi+172], eax
	pop	ebx
	pop	edi

; 5236 :     }
; 5237 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN140@xmlParsePI:

; 5146 : 			  "ParsePI: PI %s space expected\n", target);
; 5147 : 	    }
; 5148 : 	    cur = CUR_CHAR(l);
; 5149 : 	    while (IS_CHAR(cur) && /* checked */

	cmp	ebx, 55295				; 0000d7ffH
	jle	SHORT $LN58@xmlParsePI
	cmp	ebx, 57344				; 0000e000H
	jl	SHORT $LN57@xmlParsePI
	cmp	ebx, 65533				; 0000fffdH
	jle	SHORT $LN58@xmlParsePI
$LN57@xmlParsePI:
	lea	eax, DWORD PTR [ebx-65536]
	cmp	eax, 1048575				; 000fffffH
	ja	SHORT $LN138@xmlParsePI
$LN58@xmlParsePI:
	cmp	ebx, 63					; 0000003fH
	jne	SHORT $LN144@xmlParsePI
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax+1], 62			; 0000003eH
	je	SHORT $LN138@xmlParsePI
$LN144@xmlParsePI:

; 5150 : 		   ((cur != '?') || (NXT(1) != '>'))) {
; 5151 : 		if (len + 5 >= size) {

	mov	ecx, DWORD PTR _size$1$[ebp]
	lea	eax, DWORD PTR [edi+5]
	cmp	eax, ecx
	jb	SHORT $LN29@xmlParsePI

; 5152 : 		    xmlChar *tmp;
; 5153 :                     size_t new_size = size * 2;

	add	ecx, ecx

; 5154 : 		    tmp = (xmlChar *) xmlRealloc(buf, new_size);

	push	ecx
	push	DWORD PTR _buf$1$[ebp]
	mov	DWORD PTR _size$1$[ebp], ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 5155 : 		    if (tmp == NULL) {

	test	eax, eax
	je	$LN133@xmlParsePI

; 5159 : 			return;
; 5160 : 		    }
; 5161 : 		    buf = tmp;

	mov	DWORD PTR _buf$1$[ebp], eax
$LN29@xmlParsePI:

; 5162 :                     size = new_size;
; 5163 : 		}
; 5164 : 		count++;

	mov	ecx, DWORD PTR _count$1$[ebp]
	inc	ecx
	mov	DWORD PTR _count$1$[ebp], ecx

; 5165 : 		if (count > 50) {

	cmp	ecx, 50					; 00000032H
	jle	SHORT $LN34@xmlParsePI

; 5166 : 		    GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN32@xmlParsePI
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN32@xmlParsePI
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN32@xmlParsePI:

; 5167 :                     if (ctxt->instate == XML_PARSER_EOF) {

	cmp	DWORD PTR [esi+172], -1
	je	$LN134@xmlParsePI

; 5169 :                         return;
; 5170 :                     }
; 5171 : 		    count = 0;

	xor	eax, eax
	mov	DWORD PTR _count$1$[ebp], eax

; 5172 :                     if ((len > XML_MAX_TEXT_LENGTH) &&

	cmp	edi, 10000000				; 00989680H
	jbe	SHORT $LN34@xmlParsePI
	test	DWORD PTR [esi+360], 524288		; 00080000H
	je	$LN135@xmlParsePI
$LN34@xmlParsePI:

; 5173 :                         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 5174 :                         xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
; 5175 :                                           "PI %s too big found", target);
; 5176 :                         xmlFree(buf);
; 5177 :                         ctxt->instate = state;
; 5178 :                         return;
; 5179 :                     }
; 5180 : 		}
; 5181 : 		COPY_BUF(l,buf,len,cur);

	mov	eax, DWORD PTR _buf$1$[ebp]
	add	eax, edi
	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN35@xmlParsePI
	mov	BYTE PTR [eax], bl
	inc	edi
	jmp	SHORT $LN12@xmlParsePI
$LN35@xmlParsePI:
	push	ebx
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	edi, eax
$LN12@xmlParsePI:

; 5182 : 		NEXTL(l);

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN37@xmlParsePI
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN38@xmlParsePI
$LN37@xmlParsePI:
	inc	DWORD PTR [ecx+32]
$LN38@xmlParsePI:
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax

; 5183 : 		cur = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	mov	ebx, eax
	add	esp, 8

; 5184 : 		if (cur == 0) {

	test	ebx, ebx
	jne	$LL8@xmlParsePI

; 5185 : 		    SHRINK;

	mov	eax, DWORD PTR [esi+292]
	test	eax, eax
	jne	$LN27@xmlParsePI
	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN142@xmlParsePI
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN142@xmlParsePI
	push	esi
	call	_xmlSHRINK
	mov	eax, DWORD PTR [esi+292]
	add	esp, 4

; 5186 : 		    GROW;

	test	eax, eax
	jne	$LN27@xmlParsePI
$LN142@xmlParsePI:
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	$LN27@xmlParsePI
	push	esi
	call	_xmlGROW
	add	esp, 4

; 5187 : 		    cur = CUR_CHAR(l);
; 5188 : 		}
; 5189 : 	    }

	jmp	$LN27@xmlParsePI
$LN42@xmlParsePI:

; 5196 :                 return;
; 5197 :             }
; 5198 : 	    buf[len] = 0;

	mov	eax, DWORD PTR _buf$1$[ebp]
	mov	BYTE PTR [edi+eax], 0

; 5199 : 	    if (cur != '?') {

	cmp	ebx, 63					; 0000003fH
	je	SHORT $LN43@xmlParsePI

; 5200 : 		xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,

	push	DWORD PTR _target$1$[ebp]
	push	OFFSET ??_C@_0BO@OGPJFKEP@ParsePI?3?5PI?5?$CFs?5never?5end?5?4?4?4?6@
	push	47					; 0000002fH
	push	esi
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 5228 : 		                                     target, buf);
; 5229 : 	    }
; 5230 : 	    xmlFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	DWORD PTR _xmlFree

; 5231 : 	} else {

	mov	ebx, DWORD PTR _state$1$[ebp]
	add	esp, 4
	jmp	$LN130@xmlParsePI
$LN43@xmlParsePI:

; 5201 : 		      "ParsePI: PI %s never end ...\n", target);
; 5202 : 	    } else {
; 5203 : 		if (inputid != ctxt->input->id) {

	mov	eax, DWORD PTR [esi+36]
	mov	edx, DWORD PTR _inputid$1$[ebp]
	cmp	edx, DWORD PTR [eax+56]
	je	SHORT $LN15@xmlParsePI

; 5204 : 		    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0DK@LAKAFNGA@PI?5declaration?5doesn?8t?5start?5an@
	push	90					; 0000005aH
	push	esi
	call	_xmlFatalErrMsg
	mov	eax, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
$LN15@xmlParsePI:

; 5205 : 	                           "PI declaration doesn't start and stop in"
; 5206 :                                    " the same entity\n");
; 5207 : 		}
; 5208 : 		SKIP(2);

	add	DWORD PTR [esi+200], 2
	add	DWORD PTR [eax+16], 2
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 2
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN13@xmlParsePI
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN13@xmlParsePI:

; 5209 : 
; 5210 : #ifdef LIBXML_CATALOG_ENABLED
; 5211 : 		if (((state == XML_PARSER_MISC) ||
; 5212 : 	             (state == XML_PARSER_START)) &&

	mov	eax, DWORD PTR _state$1$[ebp]
	cmp	eax, 1
	je	SHORT $LN48@xmlParsePI
	test	eax, eax
	jne	SHORT $LN147@xmlParsePI
$LN48@xmlParsePI:
	mov	edi, DWORD PTR _target$1$[ebp]
	push	OFFSET ??_C@_0BC@IDENENGP@oasis?9xml?9catalog@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN148@xmlParsePI

; 5213 : 		    (xmlStrEqual(target, XML_CATALOG_PI))) {
; 5214 : 		    xmlCatalogAllow allow = xmlCatalogGetDefaults();

	call	_xmlCatalogGetDefaults

; 5215 : 		    if ((allow == XML_CATA_ALLOW_DOCUMENT) ||

	cmp	eax, 2
	je	SHORT $LN50@xmlParsePI
	cmp	eax, 3
	jne	SHORT $LN148@xmlParsePI
$LN50@xmlParsePI:

; 5216 : 			(allow == XML_CATA_ALLOW_ALL))
; 5217 : 			xmlParseCatalogPI(ctxt, buf);

	mov	ebx, DWORD PTR _buf$1$[ebp]
	push	ebx
	push	esi
	call	_xmlParseCatalogPI
	add	esp, 8
	jmp	SHORT $LN49@xmlParsePI
$LN147@xmlParsePI:

; 5209 : 
; 5210 : #ifdef LIBXML_CATALOG_ENABLED
; 5211 : 		if (((state == XML_PARSER_MISC) ||
; 5212 : 	             (state == XML_PARSER_START)) &&

	mov	edi, DWORD PTR _target$1$[ebp]
$LN148@xmlParsePI:

; 5218 : 		}
; 5219 : #endif
; 5220 : 
; 5221 : 
; 5222 : 		/*
; 5223 : 		 * SAX: PI detected.
; 5224 : 		 */
; 5225 : 		if ((ctxt->sax) && (!ctxt->disableSAX) &&

	mov	ebx, DWORD PTR _buf$1$[ebp]
$LN49@xmlParsePI:
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN51@xmlParsePI
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN51@xmlParsePI
	mov	eax, DWORD PTR [eax+76]
	test	eax, eax
	je	SHORT $LN51@xmlParsePI

; 5226 : 		    (ctxt->sax->processingInstruction != NULL))
; 5227 : 		    ctxt->sax->processingInstruction(ctxt->userData,

	push	ebx
	push	edi
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 12					; 0000000cH
$LN51@xmlParsePI:

; 5228 : 		                                     target, buf);
; 5229 : 	    }
; 5230 : 	    xmlFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	DWORD PTR _xmlFree

; 5231 : 	} else {

	mov	ebx, DWORD PTR _state$1$[ebp]
	add	esp, 4
	jmp	$LN130@xmlParsePI
$LN133@xmlParsePI:

; 5156 : 			xmlErrMemory(ctxt, NULL);

	push	0
	push	esi
	call	_xmlErrMemory

; 5157 : 			xmlFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	DWORD PTR _xmlFree

; 5158 : 			ctxt->instate = state;

	mov	eax, DWORD PTR _state$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+172], eax
	pop	ebx
	pop	edi

; 5236 :     }
; 5237 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN134@xmlParsePI:

; 5168 :                         xmlFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	ebx
	pop	edi

; 5236 :     }
; 5237 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlParsePI:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], edi
	je	SHORT $LN145@xmlParsePI
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN149@xmlParsePI
$LN145@xmlParsePI:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BM@HPBPCNCM@xmlParsePI?5?3?5no?5target?5name@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	46					; 0000002eH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 46			; 0000002eH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], edi

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], edi
	jne	SHORT $LN130@xmlParsePI

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN130@xmlParsePI:

; 5232 : 	    xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);
; 5233 : 	}
; 5234 : 	if (ctxt->instate != XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN149@xmlParsePI

; 5235 : 	    ctxt->instate = state;

	mov	DWORD PTR [esi+172], ebx
$LN149@xmlParsePI:
	pop	ebx
$LN52@xmlParsePI:
	pop	edi

; 5236 :     }
; 5237 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParsePI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParsePITarget
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlParsePITarget PROC					; COMDAT

; 4986 : xmlParsePITarget(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlParseName
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	$LN14@xmlParsePI

; 4987 :     const xmlChar *name;
; 4988 : 
; 4989 :     name = xmlParseName(ctxt);
; 4990 :     if ((name != NULL) &&
; 4991 :         ((name[0] == 'x') || (name[0] == 'X')) &&
; 4992 :         ((name[1] == 'm') || (name[1] == 'M')) &&

	mov	al, BYTE PTR [edi]
	cmp	al, 120					; 00000078H
	je	SHORT $LN6@xmlParsePI
	cmp	al, 88					; 00000058H
	jne	$LN5@xmlParsePI
$LN6@xmlParsePI:
	mov	cl, BYTE PTR [edi+1]
	cmp	cl, 109					; 0000006dH
	je	SHORT $LN7@xmlParsePI
	cmp	cl, 77					; 0000004dH
	jne	$LN5@xmlParsePI
$LN7@xmlParsePI:
	mov	dl, BYTE PTR [edi+2]
	cmp	dl, 108					; 0000006cH
	je	SHORT $LN8@xmlParsePI
	cmp	dl, 76					; 0000004cH
	jne	$LN5@xmlParsePI
$LN8@xmlParsePI:

; 4993 :         ((name[2] == 'l') || (name[2] == 'L'))) {
; 4994 : 	int i;
; 4995 : 	if ((name[0] == 'x') && (name[1] == 'm') &&
; 4996 : 	    (name[2] == 'l') && (name[3] == 0)) {

	cmp	al, 120					; 00000078H
	jne	SHORT $LN9@xmlParsePI
	cmp	cl, 109					; 0000006dH
	jne	SHORT $LN9@xmlParsePI
	cmp	dl, 108					; 0000006cH
	jne	SHORT $LN9@xmlParsePI
	cmp	BYTE PTR [edi+3], 0
	jne	$LN11@xmlParsePI

; 4997 : 	    xmlFatalErrMsg(ctxt, XML_ERR_RESERVED_XML_NAME,

	push	OFFSET ??_C@_0DL@PMHMGOPA@XML?5declaration?5allowed?5only?5at@
	push	64					; 00000040H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 5015 : 		 "colons are forbidden from PI names '%s'\n", name, NULL, NULL);
; 5016 :     }
; 5017 :     return(name);
; 5018 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlParsePI:

; 4998 : 		 "XML declaration allowed only at the start of the document\n");
; 4999 : 	    return(name);
; 5000 : 	} else if (name[3] == 0) {

	cmp	BYTE PTR [edi+3], 0
	jne	SHORT $LN11@xmlParsePI

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	test	esi, esi
	je	SHORT $LN78@xmlParsePI
	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN19@xmlParsePI
	cmp	DWORD PTR [esi+172], -1
	je	$LN14@xmlParsePI
$LN19@xmlParsePI:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;

	mov	DWORD PTR [esi+84], 64			; 00000040H
$LN78@xmlParsePI:

; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BA@KMPMBNCM@Invalid?5PI?5name@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	64					; 00000040H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {

	test	esi, esi
	je	$LN14@xmlParsePI

; 553  : 	ctxt->wellFormed = 0;
; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+12], 0
	jne	SHORT $LN14@xmlParsePI

; 5015 : 		 "colons are forbidden from PI names '%s'\n", name, NULL, NULL);
; 5016 :     }
; 5017 :     return(name);
; 5018 : }

	mov	eax, edi

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
	pop	edi

; 5015 : 		 "colons are forbidden from PI names '%s'\n", name, NULL, NULL);
; 5016 :     }
; 5017 :     return(name);
; 5018 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlParsePI:

; 5005 : 	    if (xmlW3CPIs[i] == NULL) break;

	mov	eax, DWORD PTR _xmlW3CPIs
	xor	ebx, ebx
	test	eax, eax
	je	SHORT $LN85@xmlParsePI
	npad	1
$LL4@xmlParsePI:

; 5006 : 	    if (xmlStrEqual(name, (const xmlChar *)xmlW3CPIs[i]))

	push	eax
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlParsePI

; 5001 : 	    xmlFatalErr(ctxt, XML_ERR_RESERVED_XML_NAME, NULL);
; 5002 : 	    return(name);
; 5003 : 	}
; 5004 : 	for (i = 0;;i++) {

	mov	eax, DWORD PTR _xmlW3CPIs[ebx*4+4]
	inc	ebx

; 5005 : 	    if (xmlW3CPIs[i] == NULL) break;

	test	eax, eax
	jne	SHORT $LL4@xmlParsePI
$LN85@xmlParsePI:

; 5007 : 	        return(name);
; 5008 : 	}
; 5009 : 	xmlWarningMsg(ctxt, XML_ERR_RESERVED_XML_NAME,

	push	0
	push	0
	push	OFFSET ??_C@_0CN@KJOCGNCM@xmlParsePITarget?3?5invalid?5name?5@
	push	64					; 00000040H
	push	esi
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H
$LN5@xmlParsePI:

; 5010 : 		      "xmlParsePITarget: invalid name prefix 'xml'\n",
; 5011 : 		      NULL, NULL);
; 5012 :     }
; 5013 :     if ((name != NULL) && (xmlStrchr(name, ':') != NULL)) {

	push	58					; 0000003aH
	push	edi
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlParsePI

; 5014 : 	xmlNsErr(ctxt, XML_NS_ERR_COLON,

	push	0
	push	0
	push	edi
	push	OFFSET ??_C@_0CJ@KOKAGEDL@colons?5are?5forbidden?5from?5PI?5na@
	push	205					; 000000cdH
	push	esi
	call	_xmlNsErr
	add	esp, 24					; 00000018H
$LN14@xmlParsePI:

; 5015 : 		 "colons are forbidden from PI names '%s'\n", name, NULL, NULL);
; 5016 :     }
; 5017 :     return(name);
; 5018 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlParsePITarget ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseComment
_TEXT	SEGMENT
_inputid$1$ = -16					; size = 4
_size$1$ = -12						; size = 4
_len$1$ = -8						; size = 4
_buf$1$ = -4						; size = 4
_state$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseComment PROC					; COMDAT

; 4814 : xmlParseComment(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	mov	DWORD PTR _buf$1$[ebp], esi
	mov	DWORD PTR _size$1$[ebp], 100		; 00000064H
	mov	DWORD PTR _len$1$[ebp], esi
	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 60			; 0000003cH
	jne	$LN20@xmlParseCo

; 4815 :     xmlChar *buf = NULL;
; 4816 :     size_t size = XML_PARSER_BUFFER_SIZE;
; 4817 :     size_t len = 0;
; 4818 :     xmlParserInputState state;
; 4819 :     const xmlChar *in;
; 4820 :     size_t nbchar = 0;
; 4821 :     int ccol;
; 4822 :     int inputid;
; 4823 : 
; 4824 :     /*
; 4825 :      * Check that there is a comment right here.
; 4826 :      */
; 4827 :     if ((RAW != '<') || (NXT(1) != '!') ||
; 4828 :         (NXT(2) != '-') || (NXT(3) != '-')) return;

	cmp	BYTE PTR [eax+1], 33			; 00000021H
	jne	$LN20@xmlParseCo
	cmp	BYTE PTR [eax+2], 45			; 0000002dH
	jne	$LN20@xmlParseCo
	cmp	BYTE PTR [eax+3], 45			; 0000002dH
	jne	$LN20@xmlParseCo

; 4829 :     state = ctxt->instate;

	mov	eax, DWORD PTR [edi+172]

; 4830 :     ctxt->instate = XML_PARSER_COMMENT;

	mov	DWORD PTR [edi+172], 5
	mov	DWORD PTR _state$1$[ebp], eax

; 4831 :     inputid = ctxt->input->id;

	mov	eax, DWORD PTR [ecx+56]

; 4832 :     SKIP(4);

	add	DWORD PTR [edi+200], 4
	add	DWORD PTR [ecx+16], 4
	mov	DWORD PTR _inputid$1$[ebp], eax
	mov	eax, DWORD PTR [edi+36]
	add	DWORD PTR [eax+32], 4
	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseCo
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	mov	ecx, DWORD PTR [edi+36]
	add	esp, 8
$LN2@xmlParseCo:

; 4833 :     SHRINK;

	mov	esi, DWORD PTR [edi+292]
	mov	edx, ecx
	push	ebx
	test	esi, esi
	jne	SHORT $LN22@xmlParseCo
	mov	ebx, DWORD PTR [ecx+16]
	mov	eax, ebx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN22@xmlParseCo
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, ebx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN22@xmlParseCo
	push	edi
	call	_xmlSHRINK
	mov	esi, DWORD PTR [edi+292]
	add	esp, 4
	mov	edx, DWORD PTR [edi+36]
$LN22@xmlParseCo:

; 4834 :     GROW;

	mov	ecx, edx
	test	esi, esi
	jne	SHORT $LN23@xmlParseCo
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN23@xmlParseCo
	push	edi
	call	_xmlGROW
	mov	ecx, DWORD PTR [edi+36]
	add	esp, 4
$LN23@xmlParseCo:

; 4835 : 
; 4836 :     /*
; 4837 :      * Accelerated common case where input don't need to be
; 4838 :      * modified before passing it to the handler.
; 4839 :      */
; 4840 :     in = ctxt->input->cur;

	mov	esi, DWORD PTR [ecx+16]
	mov	cl, BYTE PTR [esi]
$LL7@xmlParseCo:

; 4841 :     do {
; 4842 : 	if (*in == 0xA) {

	cmp	cl, 10					; 0000000aH
	jne	SHORT $get_more$142
	npad	5
$LL10@xmlParseCo:

; 4843 : 	    do {
; 4844 : 		ctxt->input->line++; ctxt->input->col = 1;

	mov	eax, DWORD PTR [edi+36]

; 4845 : 		in++;

	inc	esi
	inc	DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+32], 1

; 4846 : 	    } while (*in == 0xA);

	cmp	BYTE PTR [esi], 10			; 0000000aH
	je	SHORT $LL10@xmlParseCo
$get_more$142:

; 4847 : 	}
; 4848 : get_more:
; 4849 :         ccol = ctxt->input->col;

	mov	edx, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [edx+32]
	npad	4
$LL11@xmlParseCo:

; 4850 : 	while (((*in > '-') && (*in <= 0x7F)) ||
; 4851 : 	       ((*in >= 0x20) && (*in < '-')) ||

	mov	al, BYTE PTR [esi]
	cmp	al, 45					; 0000002dH
	jbe	SHORT $LN26@xmlParseCo
	cmp	al, 127					; 0000007fH
	jbe	SHORT $LN25@xmlParseCo
$LN26@xmlParseCo:
	cmp	al, 32					; 00000020H
	jb	SHORT $LN27@xmlParseCo
	cmp	al, 45					; 0000002dH
	jb	SHORT $LN25@xmlParseCo
$LN27@xmlParseCo:
	cmp	al, 9
	jne	SHORT $LN12@xmlParseCo
$LN25@xmlParseCo:

; 4852 : 	       (*in == 0x09)) {
; 4853 : 		    in++;

	inc	esi

; 4854 : 		    ccol++;

	inc	ecx

; 4855 : 	}

	jmp	SHORT $LL11@xmlParseCo
$LN12@xmlParseCo:

; 4856 : 	ctxt->input->col = ccol;

	mov	DWORD PTR [edx+32], ecx

; 4857 : 	if (*in == 0xA) {

	mov	cl, BYTE PTR [esi]
	cmp	cl, 10					; 0000000aH
	jne	SHORT $LN28@xmlParseCo
$LL15@xmlParseCo:

; 4858 : 	    do {
; 4859 : 		ctxt->input->line++; ctxt->input->col = 1;

	mov	eax, DWORD PTR [edi+36]

; 4860 : 		in++;

	inc	esi
	inc	DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+32], 1

; 4861 : 	    } while (*in == 0xA);

	cmp	BYTE PTR [esi], 10			; 0000000aH
	je	SHORT $LL15@xmlParseCo

; 4862 : 	    goto get_more;

	jmp	SHORT $get_more$142
$LN28@xmlParseCo:

; 4863 : 	}
; 4864 : 	nbchar = in - ctxt->input->cur;

	mov	eax, DWORD PTR [edi+36]
	mov	ebx, esi
	sub	ebx, DWORD PTR [eax+16]

; 4865 : 	/*
; 4866 : 	 * save current set of data
; 4867 : 	 */
; 4868 : 	if (nbchar > 0) {

	je	$LN30@xmlParseCo

; 4869 : 	    if ((ctxt->sax != NULL) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	$LN30@xmlParseCo
	cmp	DWORD PTR [eax+80], 0
	je	$LN30@xmlParseCo

; 4870 : 		(ctxt->sax->comment != NULL)) {
; 4871 : 		if (buf == NULL) {

	mov	edx, DWORD PTR _buf$1$[ebp]
	test	edx, edx
	jne	SHORT $LN31@xmlParseCo

; 4872 : 		    if ((*in == '-') && (in[1] == '-'))

	cmp	cl, 45					; 0000002dH
	jne	SHORT $LN33@xmlParseCo

; 4873 : 		        size = nbchar + 1;

	lea	eax, DWORD PTR [edx+1]
	cmp	BYTE PTR [esi+1], cl
	je	SHORT $LN34@xmlParseCo
$LN33@xmlParseCo:

; 4874 : 		    else
; 4875 : 		        size = XML_PARSER_BUFFER_SIZE + nbchar;

	mov	eax, 100				; 00000064H
$LN34@xmlParseCo:

; 4876 : 		    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	add	eax, ebx
	push	eax
	mov	DWORD PTR _size$1$[ebp], eax
	call	DWORD PTR _xmlMallocAtomic
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR _buf$1$[ebp], edx

; 4877 : 		    if (buf == NULL) {

	test	edx, edx
	je	$LN70@xmlParseCo

; 4880 : 			return;
; 4881 : 		    }
; 4882 : 		    len = 0;

	mov	DWORD PTR _len$1$[ebp], 0
	jmp	SHORT $LN36@xmlParseCo
$LN31@xmlParseCo:

; 4883 : 		} else if (len + nbchar + 1 >= size) {

	mov	ecx, DWORD PTR _len$1$[ebp]
	add	ecx, ebx
	lea	eax, DWORD PTR [ecx+1]
	cmp	eax, DWORD PTR _size$1$[ebp]
	jb	SHORT $LN36@xmlParseCo

; 4884 : 		    xmlChar *new_buf;
; 4885 : 		    size  += len + nbchar + XML_PARSER_BUFFER_SIZE;

	mov	eax, DWORD PTR _size$1$[ebp]
	add	eax, 100				; 00000064H
	add	eax, ecx

; 4886 : 		    new_buf = (xmlChar *) xmlRealloc(buf,

	push	eax
	push	edx
	mov	DWORD PTR _size$1$[ebp], eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 4887 : 		                                     size * sizeof(xmlChar));
; 4888 : 		    if (new_buf == NULL) {

	test	eax, eax
	je	$LN71@xmlParseCo

; 4892 : 			return;
; 4893 : 		    }
; 4894 : 		    buf = new_buf;

	mov	edx, eax
	mov	DWORD PTR _buf$1$[ebp], edx
$LN36@xmlParseCo:

; 4895 : 		}
; 4896 : 		memcpy(&buf[len], ctxt->input->cur, nbchar);

	mov	eax, DWORD PTR [edi+36]
	push	ebx
	push	DWORD PTR [eax+16]
	mov	eax, DWORD PTR _len$1$[ebp]
	add	eax, edx
	push	eax
	call	_memcpy

; 4897 : 		len += nbchar;

	mov	eax, DWORD PTR _len$1$[ebp]
	add	esp, 12					; 0000000cH
	add	eax, ebx

; 4898 : 		buf[len] = 0;

	mov	ebx, DWORD PTR _buf$1$[ebp]
	mov	DWORD PTR _len$1$[ebp], eax
	mov	BYTE PTR [eax+ebx], 0
$LN30@xmlParseCo:

; 4899 : 	    }
; 4900 : 	}
; 4901 :         if ((len > XML_MAX_TEXT_LENGTH) &&

	mov	ebx, DWORD PTR _len$1$[ebp]
	cmp	ebx, 10000000				; 00989680H
	jbe	SHORT $LN38@xmlParseCo
	test	DWORD PTR [edi+360], 524288		; 00080000H
	je	$LN72@xmlParseCo
$LN38@xmlParseCo:

; 4906 :             return;
; 4907 :         }
; 4908 : 	ctxt->input->cur = in;

	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+16], esi

; 4909 : 	if (*in == 0xA) {

	mov	al, BYTE PTR [esi]
	cmp	al, 10					; 0000000aH
	jne	SHORT $LN39@xmlParseCo

; 4910 : 	    in++;
; 4911 : 	    ctxt->input->line++; ctxt->input->col = 1;

	mov	eax, DWORD PTR [edi+36]
	inc	esi
	inc	DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+32], 1
	mov	al, BYTE PTR [esi]
$LN39@xmlParseCo:

; 4912 : 	}
; 4913 : 	if (*in == 0xD) {

	cmp	al, 13					; 0000000dH
	jne	SHORT $LN40@xmlParseCo

; 4914 : 	    in++;

	inc	esi

; 4915 : 	    if (*in == 0xA) {

	cmp	BYTE PTR [esi], 10			; 0000000aH
	je	$LN73@xmlParseCo
$LN40@xmlParseCo:

; 4919 : 		continue; /* while */
; 4920 : 	    }
; 4921 : 	    in--;
; 4922 : 	}
; 4923 : 	SHRINK;

	cmp	DWORD PTR [edi+292], 0
	jne	SHORT $LN43@xmlParseCo
	mov	ecx, DWORD PTR [edi+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN60@xmlParseCo
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN60@xmlParseCo

; 2070 :     xmlParserInputShrink(ctxt->input);

	push	ecx
	call	_xmlParserInputShrink

; 2071 :     if (*ctxt->input->cur == 0)

	mov	ecx, DWORD PTR [edi+36]
	add	esp, 4
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN60@xmlParseCo

; 2072 :         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN60@xmlParseCo:

; 4924 : 	GROW;

	cmp	DWORD PTR [edi+292], 0
	jne	SHORT $LN43@xmlParseCo
	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN43@xmlParseCo
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN43@xmlParseCo:

; 4925 :         if (ctxt->instate == XML_PARSER_EOF) {

	cmp	DWORD PTR [edi+172], -1
	je	$LN74@xmlParseCo

; 4927 :             return;
; 4928 :         }
; 4929 : 	in = ctxt->input->cur;

	mov	eax, DWORD PTR [edi+36]
	mov	esi, DWORD PTR [eax+16]

; 4930 : 	if (*in == '-') {

	mov	cl, BYTE PTR [esi]
	cmp	cl, 45					; 0000002dH
	jne	SHORT $LN5@xmlParseCo

; 4931 : 	    if (in[1] == '-') {

	cmp	BYTE PTR [esi+1], cl
	jne	SHORT $LN46@xmlParseCo

; 4932 : 	        if (in[2] == '>') {

	cmp	BYTE PTR [esi+2], 62			; 0000003eH
	je	$LN75@xmlParseCo

; 4950 : 		    return;
; 4951 : 		}
; 4952 : 		if (buf != NULL) {
; 4953 : 		    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
; 4954 : 		                      "Double hyphen within comment: "
; 4955 :                                       "<!--%.50s\n",
; 4956 : 				      buf);
; 4957 : 		} else
; 4958 : 		    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
; 4959 : 		                      "Double hyphen within comment\n", NULL);
; 4960 : 		in++;

	mov	ecx, DWORD PTR _buf$1$[ebp]
	mov	eax, OFFSET ??_C@_0BO@PENANJHM@Double?5hyphen?5within?5comment?6@
	push	ecx
	test	ecx, ecx
	mov	ecx, OFFSET ??_C@_0CJ@CBOBCJAG@Double?5hyphen?5within?5comment?3?5?$DM@
	cmovne	eax, ecx
	push	eax
	push	80					; 00000050H
	push	edi
	call	_xmlFatalErrMsgStr

; 4961 : 		ctxt->input->col++;

	mov	eax, DWORD PTR [edi+36]
	add	esp, 16					; 00000010H
	inc	esi
	inc	DWORD PTR [eax+32]
	mov	eax, DWORD PTR [edi+36]
$LN46@xmlParseCo:

; 4962 : 	    }
; 4963 : 	    in++;

	inc	esi

; 4964 : 	    ctxt->input->col++;

	inc	DWORD PTR [eax+32]

; 4965 : 	    goto get_more;

	jmp	$get_more$142
$LN73@xmlParseCo:

; 4916 : 		ctxt->input->cur = in;

	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+16], esi

; 4917 : 		in++;

	inc	esi

; 4918 : 		ctxt->input->line++; ctxt->input->col = 1;

	mov	eax, DWORD PTR [edi+36]
	inc	DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+32], 1
	mov	cl, BYTE PTR [esi]
$LN5@xmlParseCo:

; 4966 : 	}
; 4967 :     } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09));

	cmp	cl, 32					; 00000020H
	jb	SHORT $LN57@xmlParseCo
	cmp	cl, 127					; 0000007fH
	jbe	$LL7@xmlParseCo
$LN57@xmlParseCo:
	cmp	cl, 9
	jne	$LN76@xmlParseCo
	jmp	$LL7@xmlParseCo
$LN70@xmlParseCo:

; 4878 : 		        xmlErrMemory(ctxt, NULL);

	push	0
	push	edi
	call	_xmlErrMemory

; 4879 : 			ctxt->instate = state;

	mov	eax, DWORD PTR _state$1$[ebp]
	add	esp, 8
	mov	DWORD PTR [edi+172], eax
	pop	ebx
	pop	edi

; 4970 :     return;
; 4971 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@xmlParseCo:

; 4889 : 		        xmlFree (buf);

	mov	esi, DWORD PTR _buf$1$[ebp]
	push	esi
	call	DWORD PTR _xmlFree

; 4890 : 			xmlErrMemory(ctxt, NULL);

	push	0
	push	edi
	call	_xmlErrMemory

; 4891 : 			ctxt->instate = state;

	mov	eax, DWORD PTR _state$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+172], eax
	pop	ebx
	pop	edi

; 4970 :     return;
; 4971 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN72@xmlParseCo:

; 4902 :             ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 4903 :             xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,

	push	0
	push	OFFSET ??_C@_0BG@BAOBDEOI@Comment?5too?5big?5found@
	push	45					; 0000002dH
	push	edi
	call	_xmlFatalErrMsgStr

; 4904 :                          "Comment too big found", NULL);
; 4905 :             xmlFree (buf);

	mov	esi, DWORD PTR _buf$1$[ebp]
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H
	pop	ebx
	pop	edi

; 4970 :     return;
; 4971 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN75@xmlParseCo:

; 4933 : 		    if (ctxt->input->id != inputid) {

	mov	ecx, DWORD PTR _inputid$1$[ebp]
	cmp	DWORD PTR [eax+56], ecx
	je	SHORT $LN18@xmlParseCo

; 4934 : 			xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0DD@DDHAOEGP@comment?5doesn?8t?5start?5and?5stop?5@
	push	90					; 0000005aH
	push	edi
	call	_xmlFatalErrMsg
	mov	eax, DWORD PTR [edi+36]
	add	esp, 12					; 0000000cH
$LN18@xmlParseCo:

; 4935 : 			               "comment doesn't start and stop in the"
; 4936 :                                        " same entity\n");
; 4937 : 		    }
; 4938 : 		    SKIP(3);

	add	DWORD PTR [edi+200], 3
	add	DWORD PTR [eax+16], 3
	mov	eax, DWORD PTR [edi+36]
	add	DWORD PTR [eax+32], 3
	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN16@xmlParseCo
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN16@xmlParseCo:

; 4939 : 		    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN135@xmlParseCo
	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $LN135@xmlParseCo
	cmp	DWORD PTR [edi+212], 0
	mov	esi, DWORD PTR _buf$1$[ebp]
	jne	SHORT $LN52@xmlParseCo

; 4940 : 		        (!ctxt->disableSAX)) {
; 4941 : 			if (buf != NULL)

	mov	ecx, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN51@xmlParseCo

; 4942 : 			    ctxt->sax->comment(ctxt->userData, buf);

	push	esi
	push	ecx
	call	eax
	add	esp, 8
	jmp	SHORT $LN52@xmlParseCo
$LN51@xmlParseCo:

; 4943 : 			else
; 4944 : 			    ctxt->sax->comment(ctxt->userData, BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	ecx
	call	eax
	add	esp, 8

; 4945 : 		    }
; 4946 : 		    if (buf != NULL)

	jmp	SHORT $LN53@xmlParseCo
$LN135@xmlParseCo:
	mov	esi, DWORD PTR _buf$1$[ebp]
$LN52@xmlParseCo:
	test	esi, esi
	je	SHORT $LN53@xmlParseCo

; 4947 : 		        xmlFree(buf);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN53@xmlParseCo:

; 4948 : 		    if (ctxt->instate != XML_PARSER_EOF)

	cmp	DWORD PTR [edi+172], -1
	je	SHORT $LN140@xmlParseCo

; 4949 : 			ctxt->instate = state;

	mov	eax, DWORD PTR _state$1$[ebp]
	pop	ebx
	mov	DWORD PTR [edi+172], eax
	pop	edi

; 4970 :     return;
; 4971 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN76@xmlParseCo:

; 4968 :     xmlParseCommentComplex(ctxt, buf, len, size);

	push	DWORD PTR _size$1$[ebp]
	mov	esi, DWORD PTR _buf$1$[ebp]
	push	ebx
	push	esi
	push	edi
	call	_xmlParseCommentComplex

; 4969 :     ctxt->instate = state;

	mov	eax, DWORD PTR _state$1$[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [edi+172], eax
	pop	ebx
	pop	edi

; 4970 :     return;
; 4971 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@xmlParseCo:

; 4926 :             xmlFree(buf);

	mov	esi, DWORD PTR _buf$1$[ebp]
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN140@xmlParseCo:
	pop	ebx
$LN20@xmlParseCo:
	pop	edi

; 4970 :     return;
; 4971 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseComment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseExternalID
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_publicID$ = 12						; size = 4
_strict$ = 16						; size = 4
_xmlParseExternalID PROC				; COMDAT

; 4613 : xmlParseExternalID(xmlParserCtxtPtr ctxt, xmlChar **publicID, int strict) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	cmp	DWORD PTR [esi+292], edi
	jne	SHORT $LN8@xmlParseEx

; 4614 :     xmlChar *URI = NULL;
; 4615 : 
; 4616 :     SHRINK;

	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN8@xmlParseEx
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN8@xmlParseEx
	push	esi
	call	_xmlSHRINK
	add	esp, 4
$LN8@xmlParseEx:

; 4617 : 
; 4618 :     *publicID = NULL;

	mov	ebx, DWORD PTR _publicID$[ebp]
	mov	DWORD PTR [ebx], edi

; 4619 :     if (CMP6(CUR_PTR, 'S', 'Y', 'S', 'T', 'E', 'M')) {

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	mov	dl, BYTE PTR [eax]
	cmp	dl, 83					; 00000053H
	jne	$LN9@xmlParseEx
	cmp	BYTE PTR [eax+1], 89			; 00000059H
	jne	$LN9@xmlParseEx
	cmp	BYTE PTR [eax+2], dl
	jne	$LN9@xmlParseEx
	cmp	BYTE PTR [eax+3], 84			; 00000054H
	jne	$LN9@xmlParseEx
	cmp	BYTE PTR [eax+4], 69			; 00000045H
	jne	$LN9@xmlParseEx
	cmp	BYTE PTR [eax+5], 77			; 0000004dH
	jne	$LN9@xmlParseEx

; 4620 :         SKIP(6);

	add	DWORD PTR [esi+200], 6
	add	DWORD PTR [ecx+16], 6
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 6
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@xmlParseEx
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseEx:

; 4621 : 	if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN12@xmlParseEx

; 4622 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BP@CCMMHADN@Space?5required?5after?5?8SYSTEM?8?6@
$LN232@xmlParseEx:

; 4656 : 	}
; 4657 : 	URI = xmlParseSystemLiteral(ctxt);
; 4658 : 	if (URI == NULL) {
; 4659 : 	    xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
; 4660 :         }
; 4661 :     }
; 4662 :     return(URI);

	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN12@xmlParseEx:
	push	esi
	call	_xmlParseSystemLiteral
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN227@xmlParseEx
	cmp	DWORD PTR [esi+212], eax
	je	SHORT $LN164@xmlParseEx
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN227@xmlParseEx
$LN164@xmlParseEx:
	push	OFFSET ??_C@_0CF@GDPMMHJJ@SYSTEM?5or?5PUBLIC?0?5the?5URI?5is?5mi@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	70					; 00000046H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 70			; 00000046H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	mov	DWORD PTR [esi+12], 0
	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN227@xmlParseEx
	mov	DWORD PTR [esi+212], 1
$LN227@xmlParseEx:
	mov	eax, edi
	pop	edi

; 4663 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlParseEx:

; 4623 : 	                   "Space required after 'SYSTEM'\n");
; 4624 : 	}
; 4625 : 	URI = xmlParseSystemLiteral(ctxt);
; 4626 : 	if (URI == NULL) {
; 4627 : 	    xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
; 4628 :         }
; 4629 :     } else if (CMP6(CUR_PTR, 'P', 'U', 'B', 'L', 'I', 'C')) {

	cmp	dl, 80					; 00000050H
	jne	SHORT $LN227@xmlParseEx
	cmp	BYTE PTR [eax+1], 85			; 00000055H
	jne	SHORT $LN227@xmlParseEx
	cmp	BYTE PTR [eax+2], 66			; 00000042H
	jne	SHORT $LN227@xmlParseEx
	cmp	BYTE PTR [eax+3], 76			; 0000004cH
	jne	SHORT $LN227@xmlParseEx
	cmp	BYTE PTR [eax+4], 73			; 00000049H
	jne	SHORT $LN227@xmlParseEx
	cmp	BYTE PTR [eax+5], 67			; 00000043H
	jne	SHORT $LN227@xmlParseEx

; 4630 :         SKIP(6);

	add	DWORD PTR [esi+200], 6
	add	DWORD PTR [ecx+16], 6
	mov	eax, DWORD PTR [esi+36]
	add	DWORD PTR [eax+32], 6
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN5@xmlParseEx
	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN5@xmlParseEx:

; 4631 : 	if (SKIP_BLANKS == 0) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN16@xmlParseEx

; 4632 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BP@EHONNEAJ@Space?5required?5after?5?8PUBLIC?8?6@
	push	65					; 00000041H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN16@xmlParseEx:

; 4633 : 		    "Space required after 'PUBLIC'\n");
; 4634 : 	}
; 4635 : 	*publicID = xmlParsePubidLiteral(ctxt);

	push	esi
	call	_xmlParsePubidLiteral
	add	esp, 4
	mov	DWORD PTR [ebx], eax

; 4636 : 	if (*publicID == NULL) {

	test	eax, eax
	jne	SHORT $LN159@xmlParseEx

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], edi
	je	SHORT $LN229@xmlParseEx
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN159@xmlParseEx
$LN229@xmlParseEx:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CJ@ICNPKBIN@PUBLIC?0?5the?5Public?5Identifier?5i@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	71					; 00000047H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 71			; 00000047H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], edi

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], edi
	jne	SHORT $LN159@xmlParseEx

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN159@xmlParseEx:

; 4637 : 	    xmlFatalErr(ctxt, XML_ERR_PUBID_REQUIRED, NULL);
; 4638 : 	}
; 4639 : 	if (strict) {

	push	esi
	call	_xmlSkipBlankChars
	add	esp, 4
	cmp	DWORD PTR _strict$[ebp], edi
	je	SHORT $LN18@xmlParseEx

; 4640 : 	    /*
; 4641 : 	     * We don't handle [83] so "S SystemLiteral" is required.
; 4642 : 	     */
; 4643 : 	    if (SKIP_BLANKS == 0) {

	test	eax, eax
	jne	$LN12@xmlParseEx

; 4644 : 		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CM@PJLPICDD@Space?5required?5after?5the?5Public@

; 4645 : 			"Space required after the Public Identifier\n");
; 4646 : 	    }
; 4647 : 	} else {

	jmp	$LN232@xmlParseEx
$LN18@xmlParseEx:

; 4648 : 	    /*
; 4649 : 	     * We handle [83] so we return immediately, if
; 4650 : 	     * "S SystemLiteral" is not detected. We skip blanks if no
; 4651 :              * system literal was found, but this is harmless since we must
; 4652 :              * be at the end of a NotationDecl.
; 4653 : 	     */
; 4654 : 	    if (SKIP_BLANKS == 0) return(NULL);

	test	eax, eax
	je	SHORT $LN230@xmlParseEx

; 4655 : 	    if ((CUR != '\'') && (CUR != '"')) return(NULL);

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 39					; 00000027H
	je	$LN12@xmlParseEx
	cmp	al, 34					; 00000022H
	je	$LN12@xmlParseEx
$LN230@xmlParseEx:
	pop	edi

; 4663 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlParseExternalID ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseCharData
_TEXT	SEGMENT
tv1559 = -16						; size = 4
_tmp$1$ = -12						; size = 4
_col$1$ = -8						; size = 4
_line$1$ = -4						; size = 4
_tmp$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_cdata$ = 12						; size = 4
_xmlParseCharData PROC					; COMDAT

; 4357 : xmlParseCharData(xmlParserCtxtPtr ctxt, int cdata) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [edi+292]
	mov	esi, DWORD PTR [ecx+28]
	mov	ebx, DWORD PTR [ecx+32]
	mov	DWORD PTR _line$1$[ebp], esi
	mov	DWORD PTR _col$1$[ebp], ebx
	test	eax, eax
	jne	SHORT $LN16@xmlParseCh

; 4358 :     const xmlChar *in;
; 4359 :     int nbchar = 0;
; 4360 :     int line = ctxt->input->line;
; 4361 :     int col = ctxt->input->col;
; 4362 :     int ccol;
; 4363 : 
; 4364 :     SHRINK;

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN158@xmlParseCh
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN158@xmlParseCh
	push	edi
	call	_xmlSHRINK
	mov	eax, DWORD PTR [edi+292]
	add	esp, 4

; 4365 :     GROW;

	test	eax, eax
	jne	SHORT $LN16@xmlParseCh
$LN158@xmlParseCh:
	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN16@xmlParseCh
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN16@xmlParseCh:

; 4366 :     /*
; 4367 :      * Accelerated common case where input don't need to be
; 4368 :      * modified before passing it to the handler.
; 4369 :      */
; 4370 :     if (!cdata) {

	cmp	DWORD PTR _cdata$[ebp], 0
	jne	$LN136@xmlParseCh

; 4371 : 	in = ctxt->input->cur;

	mov	esi, DWORD PTR [edi+36]
	mov	esi, DWORD PTR [esi+16]
	mov	al, BYTE PTR [esi]
	npad	7
$get_more_space$166:

; 4372 : 	do {
; 4373 : get_more_space:
; 4374 : 	    while (*in == 0x20) { in++; ctxt->input->col++; }

	cmp	al, 32					; 00000020H
	jne	SHORT $LN6@xmlParseCh
$LL5@xmlParseCh:
	mov	eax, DWORD PTR [edi+36]
	inc	esi
	inc	DWORD PTR [eax+32]
	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LL5@xmlParseCh
$LN6@xmlParseCh:

; 4375 : 	    if (*in == 0xA) {

	cmp	al, 10					; 0000000aH
	jne	SHORT $LN18@xmlParseCh
$LL9@xmlParseCh:

; 4376 : 		do {
; 4377 : 		    ctxt->input->line++; ctxt->input->col = 1;

	mov	eax, DWORD PTR [edi+36]

; 4378 : 		    in++;

	inc	esi
	inc	DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+32], 1

; 4379 : 		} while (*in == 0xA);

	mov	al, BYTE PTR [esi]
	cmp	al, 10					; 0000000aH
	je	SHORT $LL9@xmlParseCh

; 4380 : 		goto get_more_space;

	jmp	SHORT $get_more_space$166
$LN18@xmlParseCh:

; 4381 : 	    }
; 4382 : 	    if (*in == '<') {

	cmp	al, 60					; 0000003cH
	je	$LN135@xmlParseCh
$get_more$167:

; 4405 : 					      tmp, nbchar);
; 4406 : 		    }
; 4407 : 		}
; 4408 : 		return;
; 4409 : 	    }
; 4410 : 
; 4411 : get_more:
; 4412 :             ccol = ctxt->input->col;

	mov	edx, DWORD PTR [edi+36]

; 4413 : 	    while (test_char_data[*in]) {

	movzx	eax, al
	mov	ecx, DWORD PTR [edx+32]
	cmp	BYTE PTR _test_char_data[eax], 0
	je	SHORT $LN11@xmlParseCh
$LL10@xmlParseCh:
	movzx	eax, BYTE PTR [esi+1]

; 4414 : 		in++;

	inc	esi

; 4415 : 		ccol++;

	inc	ecx
	cmp	BYTE PTR _test_char_data[eax], 0
	jne	SHORT $LL10@xmlParseCh
$LN11@xmlParseCh:

; 4416 : 	    }
; 4417 : 	    ctxt->input->col = ccol;

	mov	DWORD PTR [edx+32], ecx

; 4418 : 	    if (*in == 0xA) {

	mov	al, BYTE PTR [esi]
	cmp	al, 10					; 0000000aH
	jne	SHORT $LN29@xmlParseCh
$LL14@xmlParseCh:

; 4419 : 		do {
; 4420 : 		    ctxt->input->line++; ctxt->input->col = 1;

	mov	eax, DWORD PTR [edi+36]

; 4421 : 		    in++;

	inc	esi
	inc	DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+32], 1

; 4422 : 		} while (*in == 0xA);

	mov	al, BYTE PTR [esi]
	cmp	al, 10					; 0000000aH
	je	SHORT $LL14@xmlParseCh

; 4423 : 		goto get_more;

	jmp	SHORT $get_more$167
$LN29@xmlParseCh:

; 4424 : 	    }
; 4425 : 	    if (*in == ']') {

	cmp	al, 93					; 0000005dH
	jne	SHORT $LN30@xmlParseCh

; 4426 : 		if ((in[1] == ']') && (in[2] == '>')) {

	cmp	BYTE PTR [esi+1], al
	lea	ebx, DWORD PTR [esi+1]
	jne	SHORT $LN31@xmlParseCh
	cmp	BYTE PTR [esi+2], 62			; 0000003eH
	je	$LN134@xmlParseCh
$LN31@xmlParseCh:

; 4429 : 		    return;
; 4430 : 		}
; 4431 : 		in++;
; 4432 : 		ctxt->input->col++;

	mov	eax, DWORD PTR [edi+36]
	mov	esi, ebx
	inc	DWORD PTR [eax+32]
	mov	al, BYTE PTR [ebx]

; 4433 : 		goto get_more;

	jmp	SHORT $get_more$167
$LN30@xmlParseCh:

; 4434 : 	    }
; 4435 : 	    nbchar = in - ctxt->input->cur;

	mov	ecx, DWORD PTR [edi+36]
	mov	ebx, esi
	mov	edx, DWORD PTR [ecx+16]
	sub	ebx, edx
	mov	DWORD PTR _tmp$1$[ebp], edx

; 4436 : 	    if (nbchar > 0) {

	test	ebx, ebx
	jle	$LN150@xmlParseCh

; 4437 : 		if ((ctxt->sax != NULL) &&
; 4438 : 		    (ctxt->sax->ignorableWhitespace !=
; 4439 : 		     ctxt->sax->characters) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	$LN42@xmlParseCh
	mov	edi, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+72]
	cmp	eax, DWORD PTR [edi+68]
	mov	edi, DWORD PTR _ctxt$[ebp]
	je	SHORT $LN160@xmlParseCh
	mov	al, BYTE PTR [edx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN35@xmlParseCh
	cmp	al, 9
	jb	SHORT $LN36@xmlParseCh
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN35@xmlParseCh
$LN36@xmlParseCh:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN160@xmlParseCh
$LN35@xmlParseCh:

; 4440 : 		    (IS_BLANK_CH(*ctxt->input->cur))) {
; 4441 : 		    const xmlChar *tmp = ctxt->input->cur;
; 4442 : 		    ctxt->input->cur = in;
; 4443 : 
; 4444 : 		    if (areBlanks(ctxt, tmp, nbchar, 0)) {

	push	0
	push	ebx
	push	edx
	push	edi
	mov	DWORD PTR [ecx+16], esi
	call	_areBlanks
	mov	ecx, DWORD PTR [edi]
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN37@xmlParseCh

; 4445 : 		        if (ctxt->sax->ignorableWhitespace != NULL)

	mov	eax, DWORD PTR [ecx+72]
	test	eax, eax
	je	SHORT $LN41@xmlParseCh

; 4446 : 			    ctxt->sax->ignorableWhitespace(ctxt->userData,

	push	ebx
	push	DWORD PTR _tmp$1$[ebp]

; 4447 : 							   tmp, nbchar);
; 4448 : 		    } else {

	jmp	SHORT $LN164@xmlParseCh
$LN37@xmlParseCh:

; 4449 : 		        if (ctxt->sax->characters != NULL)

	mov	eax, DWORD PTR [ecx+68]
	test	eax, eax
	je	SHORT $LN40@xmlParseCh

; 4450 : 			    ctxt->sax->characters(ctxt->userData,

	push	ebx
	push	DWORD PTR _tmp$1$[ebp]
	push	DWORD PTR [edi+4]
	call	eax
	add	esp, 12					; 0000000cH
$LN40@xmlParseCh:

; 4451 : 						  tmp, nbchar);
; 4452 : 			if (*ctxt->space == -1)

	mov	eax, DWORD PTR [edi+232]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN41@xmlParseCh

; 4453 : 			    *ctxt->space = -2;

	mov	DWORD PTR [eax], -2			; fffffffeH

; 4454 : 		    }
; 4455 :                     line = ctxt->input->line;
; 4456 :                     col = ctxt->input->col;

	jmp	SHORT $LN41@xmlParseCh
$LN160@xmlParseCh:

; 4457 : 		} else if (ctxt->sax != NULL) {

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN42@xmlParseCh

; 4458 : 		    if (ctxt->sax->characters != NULL)

	mov	eax, DWORD PTR [eax+68]
	test	eax, eax
	je	SHORT $LN43@xmlParseCh

; 4459 : 			ctxt->sax->characters(ctxt->userData,

	push	ebx
	push	edx
$LN164@xmlParseCh:

; 4460 : 					      ctxt->input->cur, nbchar);
; 4461 :                     line = ctxt->input->line;
; 4462 :                     col = ctxt->input->col;
; 4463 : 		}
; 4464 :                 /* something really bad happened in the SAX callback */
; 4465 :                 if (ctxt->instate != XML_PARSER_CONTENT)

	push	DWORD PTR [edi+4]
	call	eax
	add	esp, 12					; 0000000cH
$LN41@xmlParseCh:
	mov	ecx, DWORD PTR [edi+36]
$LN43@xmlParseCh:
	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _line$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR _col$1$[ebp], eax
$LN42@xmlParseCh:
	cmp	DWORD PTR [edi+172], 7
	jne	$LN1@xmlParseCh
$LN150@xmlParseCh:

; 4466 :                     return;
; 4467 : 	    }
; 4468 : 	    ctxt->input->cur = in;

	mov	DWORD PTR [ecx+16], esi

; 4469 : 	    if (*in == 0xD) {

	mov	al, BYTE PTR [esi]
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN46@xmlParseCh

; 4470 : 		in++;

	inc	esi

; 4471 : 		if (*in == 0xA) {

	cmp	BYTE PTR [esi], 10			; 0000000aH
	jne	SHORT $LN46@xmlParseCh

; 4472 : 		    ctxt->input->cur = in;

	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+16], esi

; 4473 : 		    in++;

	inc	esi

; 4474 : 		    ctxt->input->line++; ctxt->input->col = 1;

	mov	eax, DWORD PTR [edi+36]
	inc	DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+32], 1

; 4475 : 		    continue; /* while */

	jmp	$LN2@xmlParseCh
$LN46@xmlParseCh:

; 4476 : 		}
; 4477 : 		in--;
; 4478 : 	    }
; 4479 : 	    if (*in == '<') {

	cmp	al, 60					; 0000003cH
	je	$LN1@xmlParseCh

; 4480 : 		return;
; 4481 : 	    }
; 4482 : 	    if (*in == '&') {

	cmp	al, 38					; 00000026H
	je	$LN1@xmlParseCh

; 4483 : 		return;
; 4484 : 	    }
; 4485 : 	    SHRINK;

	cmp	DWORD PTR [edi+292], 0
	jne	SHORT $LN50@xmlParseCh
	mov	ecx, DWORD PTR [edi+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN123@xmlParseCh
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN123@xmlParseCh

; 2070 :     xmlParserInputShrink(ctxt->input);

	push	ecx
	call	_xmlParserInputShrink

; 2071 :     if (*ctxt->input->cur == 0)

	mov	ecx, DWORD PTR [edi+36]
	add	esp, 4
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN123@xmlParseCh

; 2072 :         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN123@xmlParseCh:

; 4486 : 	    GROW;

	cmp	DWORD PTR [edi+292], 0
	jne	SHORT $LN50@xmlParseCh
	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN50@xmlParseCh
	push	edi
	call	_xmlGROW
	add	esp, 4
$LN50@xmlParseCh:

; 4487 :             if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [edi+172], -1
	je	SHORT $LN1@xmlParseCh

; 4488 : 		return;
; 4489 : 	    in = ctxt->input->cur;

	mov	esi, DWORD PTR [edi+36]
	mov	esi, DWORD PTR [esi+16]
$LN2@xmlParseCh:

; 4490 : 	} while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09));

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	jb	SHORT $LN52@xmlParseCh
	cmp	al, 127					; 0000007fH
	jbe	$get_more_space$166
$LN52@xmlParseCh:
	cmp	al, 9
	je	$get_more_space$166
	mov	esi, DWORD PTR _line$1$[ebp]
	mov	ebx, DWORD PTR _col$1$[ebp]
$LN136@xmlParseCh:

; 4491 : 	nbchar = 0;
; 4492 :     }
; 4493 :     ctxt->input->line = line;

	mov	eax, DWORD PTR [edi+36]

; 4494 :     ctxt->input->col = col;
; 4495 :     xmlParseCharDataComplex(ctxt, cdata);

	push	DWORD PTR _cdata$[ebp]
	push	edi
	mov	DWORD PTR [eax+28], esi
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+32], ebx
	call	_xmlParseCharDataComplex
	add	esp, 8
$LN1@xmlParseCh:

; 4496 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN134@xmlParseCh:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edi+212], 0
	je	SHORT $LN57@xmlParseCh
	cmp	DWORD PTR [edi+172], -1
	je	SHORT $LN120@xmlParseCh
$LN57@xmlParseCh:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CG@PLPMIKHI@Sequence?5?8?$FN?$FN?$DO?8?5not?5allowed?5in?5c@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	62					; 0000003eH
	push	1
	push	0
	push	edi
	push	0
	push	0
	push	0
	mov	DWORD PTR [edi+84], 62			; 0000003eH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [edi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [edi+288], 0
	jne	SHORT $LN120@xmlParseCh

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [edi+212], 1
$LN120@xmlParseCh:

; 4427 : 		    xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
; 4428 : 		    ctxt->input->cur = in + 1;

	mov	eax, DWORD PTR [edi+36]
	pop	edi

; 4496 : }

	pop	esi
	mov	DWORD PTR [eax+16], ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN135@xmlParseCh:

; 4383 : 		nbchar = in - ctxt->input->cur;

	mov	ecx, DWORD PTR [edi+36]
	mov	ebx, esi
	mov	eax, DWORD PTR [ecx+16]
	sub	ebx, eax
	mov	DWORD PTR _tmp$1$[ebp], eax

; 4384 : 		if (nbchar > 0) {

	test	ebx, ebx
	jle	$LN1@xmlParseCh

; 4385 : 		    const xmlChar *tmp = ctxt->input->cur;
; 4386 : 		    ctxt->input->cur = in;

	mov	DWORD PTR [ecx+16], esi

; 4387 : 
; 4388 : 		    if ((ctxt->sax != NULL) &&

	mov	edx, DWORD PTR [edi]
	test	edx, edx
	je	$LN1@xmlParseCh
	mov	ecx, DWORD PTR [edx+68]
	cmp	DWORD PTR [edx+72], ecx
	je	SHORT $LN21@xmlParseCh

; 4389 : 		        (ctxt->sax->ignorableWhitespace !=
; 4390 : 		         ctxt->sax->characters)) {
; 4391 : 			if (areBlanks(ctxt, tmp, nbchar, 1)) {

	push	1
	push	ebx
	push	eax
	push	edi
	call	_areBlanks
	mov	ecx, DWORD PTR [edi]
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN23@xmlParseCh

; 4392 : 			    if (ctxt->sax->ignorableWhitespace != NULL)

	mov	eax, DWORD PTR [ecx+72]
	test	eax, eax
	je	$LN1@xmlParseCh

; 4393 : 				ctxt->sax->ignorableWhitespace(ctxt->userData,

	push	ebx
	push	DWORD PTR _tmp$1$[ebp]
	push	DWORD PTR [edi+4]
	call	eax
	add	esp, 12					; 0000000cH
	pop	edi

; 4496 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@xmlParseCh:

; 4394 : 						       tmp, nbchar);
; 4395 : 			} else {
; 4396 : 			    if (ctxt->sax->characters != NULL)

	mov	eax, DWORD PTR [ecx+68]
	test	eax, eax
	je	SHORT $LN26@xmlParseCh

; 4397 : 				ctxt->sax->characters(ctxt->userData,

	push	ebx
	push	DWORD PTR _tmp$1$[ebp]
	push	DWORD PTR [edi+4]
	call	eax
	add	esp, 12					; 0000000cH
$LN26@xmlParseCh:

; 4398 : 						      tmp, nbchar);
; 4399 : 			    if (*ctxt->space == -1)

	mov	eax, DWORD PTR [edi+232]
	cmp	DWORD PTR [eax], -1
	jne	$LN1@xmlParseCh

; 4496 : }

	pop	edi
	pop	esi
	mov	DWORD PTR [eax], -2			; fffffffeH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlParseCh:

; 4400 : 			        *ctxt->space = -2;
; 4401 : 			}
; 4402 : 		    } else if ((ctxt->sax != NULL) &&

	test	ecx, ecx
	je	$LN1@xmlParseCh

; 4403 : 		               (ctxt->sax->characters != NULL)) {
; 4404 : 			ctxt->sax->characters(ctxt->userData,

	push	ebx
	push	eax
	push	DWORD PTR [edi+4]
	call	ecx
	add	esp, 12					; 0000000cH
	pop	edi

; 4496 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseCharData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParsePubidLiteral
_TEXT	SEGMENT
_oldstate$1$ = -16					; size = 4
_size$1$ = -12						; size = 4
_count$1$ = -8						; size = 4
_len$1$ = -4						; size = 4
_buf$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParsePubidLiteral PROC				; COMDAT

; 4226 : xmlParsePubidLiteral(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	xor	edi, edi
	mov	DWORD PTR _count$1$[ebp], eax
	mov	DWORD PTR _len$1$[ebp], edi
	mov	DWORD PTR _size$1$[ebp], 100		; 00000064H
	mov	eax, DWORD PTR [esi+172]
	mov	DWORD PTR _oldstate$1$[ebp], eax
	cmp	DWORD PTR [esi+292], edi
	jne	SHORT $LN4@xmlParsePu

; 4227 :     xmlChar *buf = NULL;
; 4228 :     int len = 0;
; 4229 :     int size = XML_PARSER_BUFFER_SIZE;
; 4230 :     xmlChar cur;
; 4231 :     xmlChar stop;
; 4232 :     int count = 0;
; 4233 :     xmlParserInputState oldstate = ctxt->instate;
; 4234 : 
; 4235 :     SHRINK;

	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN4@xmlParsePu
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN4@xmlParsePu
	push	esi
	call	_xmlSHRINK
	add	esp, 4
$LN4@xmlParsePu:

; 4236 :     if (RAW == '"') {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 34					; 00000022H
	jne	SHORT $LN5@xmlParsePu

; 4237 :         NEXT;
; 4238 : 	stop = '"';

	mov	bh, al
	jmp	SHORT $LN8@xmlParsePu
$LN5@xmlParsePu:

; 4239 :     } else if (RAW == '\'') {

	cmp	al, 39					; 00000027H
	jne	$LN7@xmlParsePu

; 4240 :         NEXT;
; 4241 : 	stop = '\'';

	mov	bh, al
$LN8@xmlParsePu:

; 4242 :     } else {
; 4243 : 	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);
; 4244 : 	return(NULL);
; 4245 :     }
; 4246 :     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	push	esi
	call	_xmlNextChar
	push	100					; 00000064H
	call	DWORD PTR _xmlMallocAtomic
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR _buf$1$[ebp], ecx

; 4247 :     if (buf == NULL) {

	test	ecx, ecx
	jne	SHORT $LN9@xmlParsePu

; 4248 : 	xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory
	add	esp, 8

; 4298 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlParsePu:

; 4249 : 	return(NULL);
; 4250 :     }
; 4251 :     ctxt->instate = XML_PARSER_PUBLIC_LITERAL;
; 4252 :     cur = CUR;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+172], 16			; 00000010H
	mov	eax, DWORD PTR [eax+16]
	mov	bl, BYTE PTR [eax]
$LN243@xmlParsePu:

; 4253 :     while ((IS_PUBIDCHAR_CH(cur)) && (cur != stop)) { /* checked */

	movzx	eax, bl
	cmp	BYTE PTR _xmlIsPubidChar_tab[eax], 0
	je	$LN237@xmlParsePu
	cmp	bl, bh
	je	$LN237@xmlParsePu

; 4254 : 	if (len + 1 >= size) {

	mov	eax, DWORD PTR _size$1$[ebp]
	inc	edi
	cmp	edi, eax
	jl	SHORT $LN10@xmlParsePu

; 4255 : 	    xmlChar *tmp;
; 4256 : 
; 4257 :             if ((size > XML_MAX_NAME_LENGTH) &&

	cmp	eax, 50000				; 0000c350H
	jle	SHORT $LN11@xmlParsePu
	test	DWORD PTR [esi+360], 524288		; 00080000H
	je	$LN230@xmlParsePu
$LN11@xmlParsePu:

; 4258 :                 ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 4259 :                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Public ID");
; 4260 :                 xmlFree(buf);
; 4261 :                 return(NULL);
; 4262 :             }
; 4263 : 	    size *= 2;

	add	eax, eax

; 4264 : 	    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));

	push	eax
	push	ecx
	mov	DWORD PTR _size$1$[ebp], eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 4265 : 	    if (tmp == NULL) {

	test	eax, eax
	je	$LN231@xmlParsePu

; 4268 : 		return(NULL);
; 4269 : 	    }
; 4270 : 	    buf = tmp;

	mov	ecx, eax
	mov	DWORD PTR _buf$1$[ebp], ecx
$LN10@xmlParsePu:

; 4271 : 	}
; 4272 : 	buf[len++] = cur;

	mov	eax, DWORD PTR _len$1$[ebp]
	mov	DWORD PTR _len$1$[ebp], edi

; 4273 : 	count++;

	mov	edi, DWORD PTR _count$1$[ebp]
	inc	edi
	mov	BYTE PTR [eax+ecx], bl
	mov	DWORD PTR _count$1$[ebp], edi

; 4274 : 	if (count > 50) {

	cmp	edi, 50					; 00000032H
	jle	SHORT $LN236@xmlParsePu

; 4275 : 	    GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN14@xmlParsePu
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN241@xmlParsePu
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN241@xmlParsePu:

; 4276 : 	    count = 0;

	mov	ecx, DWORD PTR _buf$1$[ebp]
$LN14@xmlParsePu:
	xor	eax, eax

; 4277 :             if (ctxt->instate == XML_PARSER_EOF) {

	cmp	DWORD PTR [esi+172], -1
	mov	DWORD PTR _count$1$[ebp], eax
	je	$LN156@xmlParsePu
$LN236@xmlParsePu:

; 4278 : 		xmlFree(buf);
; 4279 : 		return(NULL);
; 4280 :             }
; 4281 : 	}
; 4282 : 	NEXT;

	push	esi
	call	_xmlNextChar

; 4283 : 	cur = CUR;

	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	mov	edx, DWORD PTR [eax+16]
	mov	bl, BYTE PTR [edx]

; 4284 : 	if (cur == 0) {

	test	bl, bl
	jne	SHORT $LN16@xmlParsePu

; 4285 : 	    GROW;

	mov	edi, DWORD PTR [esi+292]
	mov	ecx, eax
	test	edi, edi
	jne	SHORT $LN17@xmlParsePu
	mov	eax, DWORD PTR [eax+20]
	sub	eax, edx
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN17@xmlParsePu
	push	esi
	call	_xmlGROW
	mov	edi, DWORD PTR [esi+292]
	add	esp, 4
	mov	ecx, DWORD PTR [esi+36]
$LN17@xmlParsePu:

; 4286 : 	    SHRINK;

	mov	edx, ecx
	test	edi, edi
	jne	SHORT $LN159@xmlParsePu
	mov	edi, DWORD PTR [ecx+16]
	mov	eax, edi
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN159@xmlParsePu
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edi
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN159@xmlParsePu

; 2070 :     xmlParserInputShrink(ctxt->input);

	push	ecx
	call	_xmlParserInputShrink

; 2071 :     if (*ctxt->input->cur == 0)

	mov	edx, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [edx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN159@xmlParsePu

; 2072 :         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	push	edx
	call	_xmlParserInputGrow
	mov	edx, DWORD PTR [esi+36]
	add	esp, 8
$LN159@xmlParsePu:

; 4287 : 	    cur = CUR;

	mov	eax, DWORD PTR [edx+16]
	mov	bl, BYTE PTR [eax]
$LN16@xmlParsePu:

; 4253 :     while ((IS_PUBIDCHAR_CH(cur)) && (cur != stop)) { /* checked */

	mov	ecx, DWORD PTR _buf$1$[ebp]
	mov	edi, DWORD PTR _len$1$[ebp]
	jmp	$LN243@xmlParsePu
$LN230@xmlParsePu:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN93@xmlParsePu
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN156@xmlParsePu
$LN93@xmlParsePu:

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_09HLIINGHD@Public?5ID@
	push	OFFSET ??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@
	push	OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_09HLIINGHD@Public?5ID@
	push	0
	push	0
	push	3
	push	110					; 0000006eH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 110			; 0000006eH
	call	___xmlRaiseError

; 554  : 	if (ctxt->recovery == 0)

	mov	ecx, DWORD PTR _buf$1$[ebp]
	add	esp, 72					; 00000048H
	cmp	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+12], 0
	jne	SHORT $LN156@xmlParsePu

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN156@xmlParsePu:

; 4298 : }

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN231@xmlParsePu:

; 4266 : 		xmlErrMemory(ctxt, NULL);

	push	0
	push	esi
	call	_xmlErrMemory

; 4267 : 		xmlFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 4298 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN237@xmlParsePu:

; 4288 : 	}
; 4289 :     }
; 4290 :     buf[len] = 0;

	mov	BYTE PTR [edi+ecx], 0

; 4291 :     if (cur != stop) {

	cmp	bl, bh
	je	SHORT $LN19@xmlParsePu

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN164@xmlParsePu
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN20@xmlParsePu
$LN164@xmlParsePu:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CP@PIPOCKJD@Unfinished?5System?5or?5Public?5ID?5@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	44					; 0000002cH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 44			; 0000002cH
	call	___xmlRaiseError

; 554  : 	if (ctxt->recovery == 0)

	mov	ecx, DWORD PTR _buf$1$[ebp]
	add	esp, 68					; 00000044H
	cmp	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+12], 0
	jne	SHORT $LN20@xmlParsePu

; 4295 :     }
; 4296 :     ctxt->instate = oldstate;

	mov	eax, DWORD PTR _oldstate$1$[ebp]
	pop	edi
	mov	DWORD PTR [esi+172], eax

; 4297 :     return(buf);

	mov	eax, ecx

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1

; 4298 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlParsePu:

; 4292 : 	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);
; 4293 :     } else {
; 4294 : 	NEXT;

	push	esi
	call	_xmlNextChar
	mov	ecx, DWORD PTR _buf$1$[ebp]
	add	esp, 4
$LN20@xmlParsePu:

; 4295 :     }
; 4296 :     ctxt->instate = oldstate;

	mov	eax, DWORD PTR _oldstate$1$[ebp]
	pop	edi
	mov	DWORD PTR [esi+172], eax

; 4297 :     return(buf);

	mov	eax, ecx

; 4298 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlParsePu:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], edi
	je	SHORT $LN25@xmlParsePu
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN88@xmlParsePu
$LN25@xmlParsePu:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BO@NINNHDOL@SystemLiteral?5?$CC?5or?5?8?5expected@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	43					; 0000002bH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 43			; 0000002bH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], edi

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], edi
	jne	SHORT $LN88@xmlParsePu

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN88@xmlParsePu:
	pop	edi

; 4298 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParsePubidLiteral ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseSystemLiteral
_TEXT	SEGMENT
_size$1$ = -20						; size = 4
$T1 = -16						; size = 4
_state$1$ = -12						; size = 4
_count$1$ = -8						; size = 4
_l$ = -4						; size = 4
_buf$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseSystemLiteral PROC				; COMDAT

; 4137 : xmlParseSystemLiteral(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	mov	DWORD PTR _size$1$[ebp], 100		; 00000064H
	mov	eax, DWORD PTR [esi+172]
	mov	DWORD PTR _state$1$[ebp], eax
	xor	eax, eax
	mov	DWORD PTR _count$1$[ebp], eax
	cmp	DWORD PTR [esi+292], eax
	jne	SHORT $LN7@xmlParseSy

; 4138 :     xmlChar *buf = NULL;
; 4139 :     int len = 0;
; 4140 :     int size = XML_PARSER_BUFFER_SIZE;
; 4141 :     int cur, l;
; 4142 :     xmlChar stop;
; 4143 :     int state = ctxt->instate;
; 4144 :     int count = 0;
; 4145 : 
; 4146 :     SHRINK;

	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN7@xmlParseSy
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN7@xmlParseSy
	push	esi
	call	_xmlSHRINK
	add	esp, 4
$LN7@xmlParseSy:

; 4147 :     if (RAW == '"') {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 34					; 00000022H
	jne	SHORT $LN8@xmlParseSy

; 4148 :         NEXT;
; 4149 : 	stop = '"';

	mov	DWORD PTR $T1[ebp], 34			; 00000022H
	jmp	SHORT $LN11@xmlParseSy
$LN8@xmlParseSy:

; 4150 :     } else if (RAW == '\'') {

	cmp	al, 39					; 00000027H
	jne	$LN10@xmlParseSy

; 4151 :         NEXT;
; 4152 : 	stop = '\'';

	mov	DWORD PTR $T1[ebp], 39			; 00000027H
$LN11@xmlParseSy:

; 4156 :     }
; 4157 : 
; 4158 :     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	push	esi
	call	_xmlNextChar
	push	100					; 00000064H
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 8
	mov	DWORD PTR _buf$1$[ebp], eax

; 4159 :     if (buf == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlParseSy

; 4160 :         xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory
	add	esp, 8

; 4161 : 	return(NULL);

	xor	eax, eax
	pop	edi

; 4212 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlParseSy:
	push	ebx

; 4162 :     }
; 4163 :     ctxt->instate = XML_PARSER_SYSTEM_LITERAL;

	mov	DWORD PTR [esi+172], 13			; 0000000dH
$LN186@xmlParseSy:

; 4164 :     cur = CUR_CHAR(l);
; 4165 :     while ((IS_CHAR(cur)) && (cur != stop)) { /* checked */

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	mov	ebx, eax
	add	esp, 8
$LL2@xmlParseSy:
	cmp	ebx, 256				; 00000100H
	jge	SHORT $LN262@xmlParseSy
	cmp	ebx, 9
	jl	SHORT $LN29@xmlParseSy
	cmp	ebx, 10					; 0000000aH
	jle	SHORT $LN33@xmlParseSy
$LN29@xmlParseSy:
	cmp	ebx, 13					; 0000000dH
	je	SHORT $LN33@xmlParseSy
	cmp	ebx, 32					; 00000020H
	jge	SHORT $LN33@xmlParseSy
$LN3@xmlParseSy:

; 4204 :     buf[len] = 0;

	mov	eax, DWORD PTR _buf$1$[ebp]
	mov	BYTE PTR [edi+eax], 0

; 4205 :     ctxt->instate = (xmlParserInputState) state;

	mov	eax, DWORD PTR _state$1$[ebp]
	mov	DWORD PTR [esi+172], eax

; 4206 :     if (!IS_CHAR(cur)) {

	cmp	ebx, 256				; 00000100H
	jge	$LN265@xmlParseSy
	cmp	ebx, 9
	jl	SHORT $LN39@xmlParseSy
	cmp	ebx, 10					; 0000000aH
	jle	SHORT $LN26@xmlParseSy
$LN39@xmlParseSy:
	cmp	ebx, 13					; 0000000dH
	je	SHORT $LN26@xmlParseSy
	cmp	ebx, 32					; 00000020H
	jl	$LN44@xmlParseSy
$LN26@xmlParseSy:

; 4207 : 	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);
; 4208 :     } else {
; 4209 : 	NEXT;

	push	esi
	call	_xmlNextChar
	add	esp, 4
$LN27@xmlParseSy:

; 4210 :     }
; 4211 :     return(buf);

	mov	eax, DWORD PTR _buf$1$[ebp]
	pop	ebx
	pop	edi

; 4212 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN262@xmlParseSy:

; 4164 :     cur = CUR_CHAR(l);
; 4165 :     while ((IS_CHAR(cur)) && (cur != stop)) { /* checked */

	cmp	ebx, 55295				; 0000d7ffH
	jle	SHORT $LN33@xmlParseSy
	cmp	ebx, 57344				; 0000e000H
	jl	SHORT $LN32@xmlParseSy
	cmp	ebx, 65533				; 0000fffdH
	jle	SHORT $LN33@xmlParseSy
$LN32@xmlParseSy:
	lea	eax, DWORD PTR [ebx-65536]
	cmp	eax, 1048575				; 000fffffH
	ja	SHORT $LN3@xmlParseSy
$LN33@xmlParseSy:
	cmp	ebx, DWORD PTR $T1[ebp]
	je	SHORT $LN3@xmlParseSy

; 4166 : 	if (len + 5 >= size) {

	mov	ecx, DWORD PTR _size$1$[ebp]
	lea	eax, DWORD PTR [edi+5]
	cmp	eax, ecx
	jl	SHORT $LN13@xmlParseSy

; 4167 : 	    xmlChar *tmp;
; 4168 : 
; 4169 :             if ((size > XML_MAX_NAME_LENGTH) &&

	cmp	ecx, 50000				; 0000c350H
	jle	SHORT $LN14@xmlParseSy
	test	DWORD PTR [esi+360], 524288		; 00080000H
	je	$LN257@xmlParseSy
$LN14@xmlParseSy:

; 4173 : 		ctxt->instate = (xmlParserInputState) state;
; 4174 :                 return(NULL);
; 4175 :             }
; 4176 : 	    size *= 2;

	add	ecx, ecx

; 4177 : 	    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));

	push	ecx
	push	DWORD PTR _buf$1$[ebp]
	mov	DWORD PTR _size$1$[ebp], ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 4178 : 	    if (tmp == NULL) {

	test	eax, eax
	je	$LN258@xmlParseSy

; 4183 : 	    }
; 4184 : 	    buf = tmp;

	mov	DWORD PTR _buf$1$[ebp], eax
$LN13@xmlParseSy:

; 4185 : 	}
; 4186 : 	count++;

	mov	ecx, DWORD PTR _count$1$[ebp]
	inc	ecx
	mov	DWORD PTR _count$1$[ebp], ecx

; 4187 : 	if (count > 50) {

	cmp	ecx, 50					; 00000032H
	jle	SHORT $LN18@xmlParseSy

; 4188 : 	    GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN17@xmlParseSy
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN17@xmlParseSy
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN17@xmlParseSy:

; 4189 : 	    count = 0;

	xor	eax, eax

; 4190 :             if (ctxt->instate == XML_PARSER_EOF) {

	cmp	DWORD PTR [esi+172], -1
	mov	DWORD PTR _count$1$[ebp], eax
	je	$LN259@xmlParseSy
$LN18@xmlParseSy:

; 4192 : 		return(NULL);
; 4193 :             }
; 4194 : 	}
; 4195 : 	COPY_BUF(l,buf,len,cur);

	mov	eax, DWORD PTR _buf$1$[ebp]
	add	eax, edi
	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN19@xmlParseSy
	mov	BYTE PTR [eax], bl
	inc	edi
	jmp	SHORT $LN6@xmlParseSy
$LN19@xmlParseSy:
	push	ebx
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	edi, eax
$LN6@xmlParseSy:

; 4196 : 	NEXTL(l);

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN21@xmlParseSy
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN22@xmlParseSy
$LN21@xmlParseSy:
	inc	DWORD PTR [ecx+32]
$LN22@xmlParseSy:
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax

; 4197 : 	cur = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	mov	ebx, eax
	add	esp, 8

; 4198 : 	if (cur == 0) {

	test	ebx, ebx
	jne	$LL2@xmlParseSy

; 4199 : 	    GROW;

	mov	eax, DWORD PTR [esi+292]
	test	eax, eax
	jne	$LN186@xmlParseSy
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN264@xmlParseSy
	push	esi
	call	_xmlGROW
	mov	eax, DWORD PTR [esi+292]
	add	esp, 4

; 4200 : 	    SHRINK;

	test	eax, eax
	jne	$LN186@xmlParseSy
$LN264@xmlParseSy:
	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 500				; 000001f4H
	jle	$LN186@xmlParseSy
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 500				; 000001f4H
	jge	$LN186@xmlParseSy

; 2070 :     xmlParserInputShrink(ctxt->input);

	push	ecx
	call	_xmlParserInputShrink

; 2071 :     if (*ctxt->input->cur == 0)

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	$LN186@xmlParseSy

; 2072 :         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8

; 4201 : 	    cur = CUR_CHAR(l);
; 4202 : 	}
; 4203 :     }

	jmp	$LN186@xmlParseSy
$LN257@xmlParseSy:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN120@xmlParseSy
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN183@xmlParseSy
$LN120@xmlParseSy:

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0O@CPJEEBHF@SystemLiteral@
	push	OFFSET ??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@
	push	OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0O@CPJEEBHF@SystemLiteral@
	push	0
	push	0
	push	3
	push	110					; 0000006eH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 110			; 0000006eH
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN183@xmlParseSy

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN183@xmlParseSy:

; 4170 :                 ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 4171 :                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "SystemLiteral");
; 4172 :                 xmlFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	DWORD PTR _xmlFree

; 4181 : 		ctxt->instate = (xmlParserInputState) state;
; 4182 : 		return(NULL);

	mov	eax, DWORD PTR _state$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+172], eax
	xor	eax, eax
	pop	ebx
	pop	edi

; 4212 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN258@xmlParseSy:

; 4179 : 	        xmlFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	DWORD PTR _xmlFree

; 4180 : 		xmlErrMemory(ctxt, NULL);

	push	0
	push	esi
	call	_xmlErrMemory

; 4181 : 		ctxt->instate = (xmlParserInputState) state;
; 4182 : 		return(NULL);

	mov	eax, DWORD PTR _state$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+172], eax
	xor	eax, eax
	pop	ebx
	pop	edi

; 4212 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN259@xmlParseSy:

; 4191 : 	        xmlFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	ebx
	pop	edi

; 4212 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN265@xmlParseSy:

; 4206 :     if (!IS_CHAR(cur)) {

	cmp	ebx, 55295				; 0000d7ffH
	jle	$LN26@xmlParseSy
	cmp	ebx, 57344				; 0000e000H
	jl	SHORT $LN42@xmlParseSy
	cmp	ebx, 65533				; 0000fffdH
	jle	$LN26@xmlParseSy
$LN42@xmlParseSy:
	cmp	ebx, 65536				; 00010000H
	jl	SHORT $LN44@xmlParseSy
	cmp	ebx, 1114111				; 0010ffffH
	jle	$LN26@xmlParseSy
$LN44@xmlParseSy:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN191@xmlParseSy
	cmp	eax, -1
	je	$LN27@xmlParseSy
$LN191@xmlParseSy:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CP@PIPOCKJD@Unfinished?5System?5or?5Public?5ID?5@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	44					; 0000002cH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 44			; 0000002cH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	$LN27@xmlParseSy

; 4210 :     }
; 4211 :     return(buf);

	mov	eax, DWORD PTR _buf$1$[ebp]
	pop	ebx
	pop	edi

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1

; 4212 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlParseSy:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], edi
	je	SHORT $LN52@xmlParseSy
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN115@xmlParseSy
$LN52@xmlParseSy:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BO@NINNHDOL@SystemLiteral?5?$CC?5or?5?8?5expected@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	43					; 0000002bH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 43			; 0000002bH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], edi

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], edi
	jne	SHORT $LN115@xmlParseSy

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN115@xmlParseSy:
	pop	edi

; 4153 :     } else {
; 4154 : 	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);
; 4155 : 	return(NULL);

	xor	eax, eax

; 4212 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseSystemLiteral ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseAttValue
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlParseAttValue PROC					; COMDAT

; 4120 : xmlParseAttValue(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlParseAt

; 4121 :     if ((ctxt == NULL) || (ctxt->input == NULL)) return(NULL);

	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN3@xmlParseAt

; 4122 :     return(xmlParseAttValueInternal(ctxt, NULL, NULL, 0));

	push	0
	push	0
	push	0
	push	eax
	call	_xmlParseAttValueInternal
	add	esp, 16					; 00000010H

; 4123 : }

	pop	ebp
	ret	0
$LN3@xmlParseAt:

; 4121 :     if ((ctxt == NULL) || (ctxt->input == NULL)) return(NULL);

	xor	eax, eax

; 4123 : }

	pop	ebp
	ret	0
_xmlParseAttValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEntityValue
_TEXT	SEGMENT
_input$1$ = -16						; size = 4
_size$1$ = -12						; size = 4
_cur$ = -12						; size = 4
$T1 = -8						; size = 4
_l$ = -4						; size = 4
_buf$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_orig$ = 12						; size = 4
_xmlParseEntityValue PROC				; COMDAT

; 3704 : xmlParseEntityValue(xmlParserCtxtPtr ctxt, xmlChar **orig) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	mov	DWORD PTR _size$1$[ebp], 100		; 00000064H
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	mov	al, BYTE PTR [eax]
	cmp	al, 34					; 00000022H
	jne	SHORT $LN9@xmlParseEn

; 3705 :     xmlChar *buf = NULL;
; 3706 :     int len = 0;
; 3707 :     int size = XML_PARSER_BUFFER_SIZE;
; 3708 :     int c, l;
; 3709 :     xmlChar stop;
; 3710 :     xmlChar *ret = NULL;
; 3711 :     const xmlChar *cur = NULL;
; 3712 :     xmlParserInputPtr input;
; 3713 : 
; 3714 :     if (RAW == '"') stop = '"';

	mov	DWORD PTR $T1[ebp], 34			; 00000022H
	jmp	SHORT $LN12@xmlParseEn
$LN9@xmlParseEn:

; 3715 :     else if (RAW == '\'') stop = '\'';

	cmp	al, 39					; 00000027H
	jne	$LN11@xmlParseEn
	mov	DWORD PTR $T1[ebp], 39			; 00000027H
$LN12@xmlParseEn:

; 3716 :     else {
; 3717 : 	xmlFatalErr(ctxt, XML_ERR_ENTITY_NOT_STARTED, NULL);
; 3718 : 	return(NULL);
; 3719 :     }
; 3720 :     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	push	100					; 00000064H
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR _buf$1$[ebp], eax

; 3721 :     if (buf == NULL) {

	test	eax, eax
	jne	SHORT $LN13@xmlParseEn

; 3722 : 	xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory
	add	esp, 8

; 3834 : }

	xor	eax, eax
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlParseEn:

; 3723 : 	return(NULL);
; 3724 :     }
; 3725 : 
; 3726 :     /*
; 3727 :      * The content of the entity definition is copied in a buffer.
; 3728 :      */
; 3729 : 
; 3730 :     ctxt->instate = XML_PARSER_ENTITY_VALUE;
; 3731 :     input = ctxt->input;

	mov	ecx, DWORD PTR [esi+36]
	push	ebx
	mov	DWORD PTR [esi+172], 11			; 0000000bH
	mov	DWORD PTR _input$1$[ebp], ecx

; 3732 :     GROW;

	cmp	DWORD PTR [esi+292], edi
	jne	SHORT $LN264@xmlParseEn
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [ecx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN264@xmlParseEn
	push	esi
	call	_xmlGROW
	add	esp, 4

; 3733 :     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	$LN278@xmlParseEn
$LN264@xmlParseEn:

; 3734 :         goto error;
; 3735 :     NEXT;

	push	esi
	call	_xmlNextChar

; 3736 :     c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	add	esp, 12					; 0000000cH
$LN279@xmlParseEn:

; 3737 :     /*
; 3738 :      * NOTE: 4.4.5 Included in Literal
; 3739 :      * When a parameter entity reference appears in a literal entity
; 3740 :      * value, ... a single or double quote character in the replacement
; 3741 :      * text is always treated as a normal data character and will not
; 3742 :      * terminate the literal.
; 3743 :      * In practice it means we stop the loop only when back at parsing
; 3744 :      * the initial entity and the quote is found
; 3745 :      */
; 3746 :     while (((IS_CHAR(c)) && ((c != stop) || /* checked */
; 3747 : 	    (ctxt->input != input))) && (ctxt->instate != XML_PARSER_EOF)) {

	mov	ebx, eax
	npad	9
$LL2@xmlParseEn:
	cmp	ebx, 256				; 00000100H
	jge	$LN265@xmlParseEn
	cmp	ebx, 9
	jl	SHORT $LN38@xmlParseEn
	cmp	ebx, 10					; 0000000aH
	jle	$LN42@xmlParseEn
$LN38@xmlParseEn:
	cmp	ebx, 13					; 0000000dH
	je	$LN42@xmlParseEn
	cmp	ebx, 32					; 00000020H
	jge	$LN42@xmlParseEn
$LN273@xmlParseEn:

; 3769 :     buf[len] = 0;

	mov	ecx, DWORD PTR $T1[ebp]
$LN3@xmlParseEn:
	mov	eax, DWORD PTR _buf$1$[ebp]
	mov	BYTE PTR [edi+eax], 0

; 3770 :     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	$LN278@xmlParseEn

; 3771 :         goto error;
; 3772 :     if (c != stop) {

	cmp	ebx, ecx
	je	$LN27@xmlParseEn

; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BN@DPACNJHE@EntityValue?3?5?$CC?5or?5?8?5expected@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 37			; 00000025H
	push	37					; 00000025H
$LN280@xmlParseEn:

; 3827 :         buf = NULL;
; 3828 :     }
; 3829 : 
; 3830 : error:
; 3831 :     if (buf != NULL)

	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	xor	edi, edi
	mov	DWORD PTR [esi+12], 0
	add	esp, 68					; 00000044H
	cmp	DWORD PTR [esi+288], edi
	jne	$error$282
	mov	DWORD PTR [esi+212], 1
	jmp	$error$282
$LN265@xmlParseEn:

; 3737 :     /*
; 3738 :      * NOTE: 4.4.5 Included in Literal
; 3739 :      * When a parameter entity reference appears in a literal entity
; 3740 :      * value, ... a single or double quote character in the replacement
; 3741 :      * text is always treated as a normal data character and will not
; 3742 :      * terminate the literal.
; 3743 :      * In practice it means we stop the loop only when back at parsing
; 3744 :      * the initial entity and the quote is found
; 3745 :      */
; 3746 :     while (((IS_CHAR(c)) && ((c != stop) || /* checked */
; 3747 : 	    (ctxt->input != input))) && (ctxt->instate != XML_PARSER_EOF)) {

	cmp	ebx, 55295				; 0000d7ffH
	jle	SHORT $LN42@xmlParseEn
	cmp	ebx, 57344				; 0000e000H
	jl	SHORT $LN41@xmlParseEn
	cmp	ebx, 65533				; 0000fffdH
	jle	SHORT $LN42@xmlParseEn
$LN41@xmlParseEn:
	lea	eax, DWORD PTR [ebx-65536]
	cmp	eax, 1048575				; 000fffffH
	ja	$LN273@xmlParseEn
$LN42@xmlParseEn:
	mov	ecx, DWORD PTR $T1[ebp]
	cmp	ebx, ecx
	jne	SHORT $LN269@xmlParseEn
	mov	eax, DWORD PTR _input$1$[ebp]
	cmp	DWORD PTR [esi+36], eax
	je	$LN3@xmlParseEn
$LN269@xmlParseEn:
	cmp	DWORD PTR [esi+172], -1
	je	$LN3@xmlParseEn

; 3748 : 	if (len + 5 >= size) {

	mov	ecx, DWORD PTR _size$1$[ebp]
	lea	eax, DWORD PTR [edi+5]
	cmp	eax, ecx
	mov	eax, DWORD PTR _buf$1$[ebp]
	jl	SHORT $LN17@xmlParseEn

; 3749 : 	    xmlChar *tmp;
; 3750 : 
; 3751 : 	    size *= 2;

	add	ecx, ecx

; 3752 : 	    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));

	push	ecx
	push	eax
	mov	DWORD PTR _size$1$[ebp], ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 3753 : 	    if (tmp == NULL) {

	test	eax, eax
	je	$LN254@xmlParseEn

; 3755 :                 goto error;
; 3756 : 	    }
; 3757 : 	    buf = tmp;

	mov	DWORD PTR _buf$1$[ebp], eax
$LN17@xmlParseEn:

; 3758 : 	}
; 3759 : 	COPY_BUF(l,buf,len,c);

	add	eax, edi
	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN19@xmlParseEn
	mov	BYTE PTR [eax], bl
	inc	edi
	jmp	SHORT $LN6@xmlParseEn
$LN19@xmlParseEn:
	push	ebx
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	edi, eax
$LN6@xmlParseEn:

; 3760 : 	NEXTL(l);

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN21@xmlParseEn
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN22@xmlParseEn
$LN21@xmlParseEn:
	inc	DWORD PTR [ecx+32]
$LN22@xmlParseEn:
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax

; 3761 : 
; 3762 : 	GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN23@xmlParseEn
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN23@xmlParseEn
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN23@xmlParseEn:

; 3763 : 	c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	mov	ebx, eax
	add	esp, 8

; 3764 : 	if (c == 0) {

	test	ebx, ebx
	jne	$LL2@xmlParseEn

; 3765 : 	    GROW;

	cmp	DWORD PTR [esi+292], eax
	jne	SHORT $LN25@xmlParseEn
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN25@xmlParseEn
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN25@xmlParseEn:

; 3766 : 	    c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	add	esp, 8

; 3767 : 	}
; 3768 :     }

	jmp	$LN279@xmlParseEn
$LN254@xmlParseEn:

; 3754 : 		xmlErrMemory(ctxt, NULL);

	push	0
	push	esi
	call	_xmlErrMemory
	add	esp, 8
$LN278@xmlParseEn:

; 3827 :         buf = NULL;
; 3828 :     }
; 3829 : 
; 3830 : error:
; 3831 :     if (buf != NULL)

	xor	edi, edi
$error$282:
	mov	ebx, DWORD PTR _buf$1$[ebp]
	test	ebx, ebx
	je	SHORT $LN36@xmlParseEn

; 3832 :         xmlFree(buf);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN36@xmlParseEn:

; 3833 :     return(ret);

	pop	ebx
	mov	eax, edi
	pop	edi

; 3834 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlParseEn:

; 3773 :         xmlFatalErr(ctxt, XML_ERR_ENTITY_NOT_FINISHED, NULL);
; 3774 :         goto error;
; 3775 :     }
; 3776 :     NEXT;

	push	esi
	call	_xmlNextChar

; 3777 : 
; 3778 :     /*
; 3779 :      * Raise problem w.r.t. '&' and '%' being used in non-entities
; 3780 :      * reference constructs. Note Charref will be handled in
; 3781 :      * xmlStringDecodeEntities()
; 3782 :      */
; 3783 :     cur = buf;

	mov	ecx, DWORD PTR _buf$1$[ebp]
	add	esp, 4
	mov	eax, ecx

; 3784 :     while (*cur != 0) { /* non input consuming */

	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN8@xmlParseEn
	npad	3
$LL7@xmlParseEn:

; 3785 : 	if ((*cur == '%') || ((*cur == '&') && (cur[1] != '#'))) {

	mov	bl, BYTE PTR [eax]
	cmp	bl, 37					; 00000025H
	je	SHORT $LN29@xmlParseEn
	cmp	bl, 38					; 00000026H
	jne	SHORT $LN33@xmlParseEn
	cmp	BYTE PTR [eax+1], 35			; 00000023H
	je	SHORT $LN33@xmlParseEn
$LN29@xmlParseEn:

; 3786 : 	    xmlChar *name;
; 3787 : 	    xmlChar tmp = *cur;
; 3788 :             int nameOk = 0;

	lea	eax, DWORD PTR [ecx+1]

; 3789 : 
; 3790 : 	    cur++;

	mov	DWORD PTR _cur$[ebp], eax

; 3791 : 	    name = xmlParseStringName(ctxt, &cur);

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	esi
	call	_xmlParseStringName
	add	esp, 8

; 3792 :             if (name != NULL) {

	test	eax, eax
	je	$LN32@xmlParseEn

; 3793 :                 nameOk = 1;
; 3794 :                 xmlFree(name);

	push	eax
	call	DWORD PTR _xmlFree

; 3795 :             }
; 3796 :             if ((nameOk == 0) || (*cur != ';')) {

	mov	eax, DWORD PTR _cur$[ebp]
	add	esp, 4
	cmp	BYTE PTR [eax], 59			; 0000003bH
	jne	$LN32@xmlParseEn

; 3801 : 	    }
; 3802 : 	    if ((tmp == '%') && (ctxt->inSubset == 1) &&

	cmp	bl, 37					; 00000025H
	jne	SHORT $LN33@xmlParseEn
	cmp	DWORD PTR [esi+216], 1
	jne	SHORT $LN33@xmlParseEn
	cmp	DWORD PTR [esi+40], 1
	je	SHORT $LN256@xmlParseEn
$LN33@xmlParseEn:

; 3808 : 	        break;
; 3809 : 	}
; 3810 : 	cur++;

	inc	eax
	mov	ecx, eax
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL7@xmlParseEn

; 3806 : 	    }
; 3807 : 	    if (*cur == 0)

	mov	ecx, DWORD PTR _buf$1$[ebp]
$LN8@xmlParseEn:

; 3811 :     }
; 3812 : 
; 3813 :     /*
; 3814 :      * Then PEReference entities are substituted.
; 3815 :      *
; 3816 :      * NOTE: 4.4.7 Bypassed
; 3817 :      * When a general entity reference appears in the EntityValue in
; 3818 :      * an entity declaration, it is bypassed and left as is.
; 3819 :      * so XML_SUBSTITUTE_REF is not set here.
; 3820 :      */
; 3821 :     ++ctxt->depth;

	inc	DWORD PTR [esi+248]

; 3822 :     ret = xmlStringDecodeEntities(ctxt, buf, XML_SUBSTITUTE_PEREF,

	push	0
	push	0
	push	0
	push	2
	push	ecx
	push	esi
	call	_xmlStringDecodeEntities

; 3823 :                                   0, 0, 0);
; 3824 :     --ctxt->depth;

	dec	DWORD PTR [esi+248]
	add	esp, 24					; 00000018H

; 3825 :     if (orig != NULL) {

	mov	ecx, DWORD PTR _orig$[ebp]
	mov	edi, eax
	test	ecx, ecx
	je	$error$282

; 3826 :         *orig = buf;

	mov	eax, DWORD PTR _buf$1$[ebp]

; 3833 :     return(ret);

	pop	ebx
	mov	DWORD PTR [ecx], eax
	mov	eax, edi
	pop	edi

; 3834 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN256@xmlParseEn:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN187@xmlParseEn
	cmp	DWORD PTR [esi+172], -1
	je	$LN278@xmlParseEn
$LN187@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CK@GAJOCPOL@PEReferences?5forbidden?5in?5inter@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 88			; 00000058H
	push	88					; 00000058H

; 3803 : 		(ctxt->inputNr == 1)) {
; 3804 : 		xmlFatalErr(ctxt, XML_ERR_ENTITY_PE_INTERNAL, NULL);
; 3805 :                 goto error;

	jmp	$LN280@xmlParseEn
$LN32@xmlParseEn:

; 3797 : 		xmlFatalErrMsgInt(ctxt, XML_ERR_ENTITY_CHAR_ERROR,

	movzx	eax, bl
	push	eax
	push	OFFSET ??_C@_0DM@GJGLHMKL@EntityValue?3?5?8?$CFc?8?5forbidden?5exc@
	push	87					; 00000057H
	push	esi
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H

; 3798 : 	    "EntityValue: '%c' forbidden except for entities references\n",
; 3799 : 	                          tmp);
; 3800 :                 goto error;

	jmp	$LN278@xmlParseEn
$LN11@xmlParseEn:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], edi
	je	SHORT $LN51@xmlParseEn
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN114@xmlParseEn
$LN51@xmlParseEn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BN@DPACNJHE@EntityValue?3?5?$CC?5or?5?8?5expected@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	36					; 00000024H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 36			; 00000024H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], edi

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], edi
	jne	SHORT $LN114@xmlParseEn

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN114@xmlParseEn:
	pop	edi

; 3834 : }

	xor	eax, eax
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseEntityValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseNmtoken
_TEXT	SEGMENT
_buf$ = -120						; size = 105
_max$1$ = -12						; size = 4
_l$ = -8						; size = 4
_count$1$ = -4						; size = 4
_buffer$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseNmtoken PROC					; COMDAT

; 3600 : xmlParseNmtoken(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	xor	edi, edi
	mov	DWORD PTR _count$1$[ebp], eax
	cmp	DWORD PTR [esi+292], eax
	jne	SHORT $LN12@xmlParseNm

; 3601 :     xmlChar buf[XML_MAX_NAMELEN + 5];
; 3602 :     int len = 0, l;
; 3603 :     int c;
; 3604 :     int count = 0;
; 3605 : 
; 3606 : #ifdef DEBUG
; 3607 :     nbParseNmToken++;
; 3608 : #endif
; 3609 : 
; 3610 :     GROW;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN12@xmlParseNm
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN12@xmlParseNm:

; 3611 :     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	$LN172@xmlParseNm

; 3612 :         return(NULL);
; 3613 :     c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	mov	ebx, eax

; 3614 : 
; 3615 :     while (xmlIsNameChar(ctxt, c)) {

	push	ebx
	push	esi
	call	_xmlIsNameChar
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN172@xmlParseNm
	npad	6
$LL2@xmlParseNm:

; 3616 : 	if (count++ > XML_PARSER_CHUNK_SIZE) {

	mov	ecx, DWORD PTR _count$1$[ebp]
	mov	eax, ecx
	inc	ecx
	mov	DWORD PTR _count$1$[ebp], ecx
	cmp	eax, 100				; 00000064H
	jle	SHORT $LN15@xmlParseNm

; 3617 : 	    count = 0;

	xor	eax, eax
	mov	DWORD PTR _count$1$[ebp], eax

; 3618 : 	    GROW;

	cmp	DWORD PTR [esi+292], eax
	jne	SHORT $LN15@xmlParseNm
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN15@xmlParseNm
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN15@xmlParseNm:

; 3619 : 	}
; 3620 : 	COPY_BUF(l,buf,len,c);

	lea	eax, DWORD PTR _buf$[ebp]
	add	eax, edi
	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN16@xmlParseNm
	mov	BYTE PTR [eax], bl
	inc	edi
	jmp	SHORT $LN6@xmlParseNm
$LN16@xmlParseNm:
	push	ebx
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	edi, eax
$LN6@xmlParseNm:

; 3621 : 	NEXTL(l);

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN18@xmlParseNm
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN19@xmlParseNm
$LN18@xmlParseNm:
	inc	DWORD PTR [ecx+32]
$LN19@xmlParseNm:
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax

; 3622 : 	c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	mov	ebx, eax
	add	esp, 8

; 3623 : 	if (c == 0) {

	test	ebx, ebx
	jne	SHORT $LN20@xmlParseNm

; 3624 : 	    count = 0;

	mov	DWORD PTR _count$1$[ebp], eax

; 3625 : 	    GROW;

	cmp	DWORD PTR [esi+292], eax
	jne	SHORT $LN21@xmlParseNm
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN21@xmlParseNm
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN21@xmlParseNm:

; 3626 : 	    if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	$LN172@xmlParseNm

; 3627 : 		return(NULL);
; 3628 :             c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	add	esp, 8
	mov	ebx, eax
$LN20@xmlParseNm:

; 3629 : 	}
; 3630 : 	if (len >= XML_MAX_NAMELEN) {

	cmp	edi, 100				; 00000064H
	jge	$LN177@xmlParseNm

; 3614 : 
; 3615 :     while (xmlIsNameChar(ctxt, c)) {

	push	ebx
	push	esi
	call	_xmlIsNameChar
	add	esp, 8
	test	eax, eax
	jne	$LL2@xmlParseNm

; 3677 : 	    return(buffer);
; 3678 : 	}
; 3679 :     }
; 3680 :     if (len == 0)

	test	edi, edi
	je	SHORT $LN172@xmlParseNm

; 3681 :         return(NULL);
; 3682 :     if ((len > XML_MAX_NAME_LENGTH) &&

	cmp	edi, 50000				; 0000c350H
	jle	SHORT $LN36@xmlParseNm
	test	DWORD PTR [esi+360], 524288		; 00080000H
	jne	SHORT $LN36@xmlParseNm

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], eax
	je	SHORT $LN109@xmlParseNm
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN172@xmlParseNm
$LN109@xmlParseNm:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_07JJJDEIPB@NmToken@
	push	OFFSET ??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@
	push	OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_07JJJDEIPB@NmToken@
	push	0
	push	0
	push	3
	push	110					; 0000006eH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 110			; 0000006eH
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN172@xmlParseNm

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN172@xmlParseNm:
	pop	edi

; 3688 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@xmlParseNm:

; 3683 :         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3684 :         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NmToken");
; 3685 :         return(NULL);
; 3686 :     }
; 3687 :     return(xmlStrndup(buf, len));

	lea	eax, DWORD PTR _buf$[ebp]
	push	edi
	push	eax
	call	_xmlStrndup
	add	esp, 8
	pop	edi

; 3688 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN177@xmlParseNm:

; 3631 : 	    /*
; 3632 : 	     * Okay someone managed to make a huge token, so he's ready to pay
; 3633 : 	     * for the processing speed.
; 3634 : 	     */
; 3635 : 	    xmlChar *buffer;
; 3636 : 	    int max = len * 2;

	lea	eax, DWORD PTR [edi+edi]

; 3637 : 
; 3638 : 	    buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));

	push	eax
	mov	DWORD PTR _max$1$[ebp], eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR _buffer$1$[ebp], eax

; 3639 : 	    if (buffer == NULL) {

	test	eax, eax
	jne	SHORT $LN24@xmlParseNm

; 3640 : 	        xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory
	add	esp, 8

; 3688 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlParseNm:

; 3641 : 		return(NULL);
; 3642 : 	    }
; 3643 : 	    memcpy(buffer, buf, len);

	push	edi
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	push	eax
	call	_memcpy

; 3644 : 	    while (xmlIsNameChar(ctxt, c)) {

	push	ebx
	push	esi
	call	_xmlIsNameChar
	add	esp, 20					; 00000014H
	test	eax, eax
	je	$LN189@xmlParseNm
	npad	5
$LL7@xmlParseNm:

; 3645 : 		if (count++ > XML_PARSER_CHUNK_SIZE) {

	mov	ecx, DWORD PTR _count$1$[ebp]
	mov	eax, ecx
	inc	ecx
	mov	DWORD PTR _count$1$[ebp], ecx
	cmp	eax, 100				; 00000064H
	jle	SHORT $LN188@xmlParseNm

; 3646 : 		    count = 0;

	xor	eax, eax
	mov	DWORD PTR _count$1$[ebp], eax

; 3647 : 		    GROW;

	cmp	DWORD PTR [esi+292], eax
	jne	SHORT $LN26@xmlParseNm
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN26@xmlParseNm
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN26@xmlParseNm:

; 3648 :                     if (ctxt->instate == XML_PARSER_EOF) {

	cmp	DWORD PTR [esi+172], -1
	je	$LN104@xmlParseNm
$LN188@xmlParseNm:

; 3649 :                         xmlFree(buffer);
; 3650 :                         return(NULL);
; 3651 :                     }
; 3652 : 		}
; 3653 : 		if (len + 10 > max) {

	mov	ecx, DWORD PTR _max$1$[ebp]
	lea	eax, DWORD PTR [edi+10]
	cmp	eax, ecx
	jle	SHORT $LN190@xmlParseNm

; 3654 : 		    xmlChar *tmp;
; 3655 : 
; 3656 :                     if ((max > XML_MAX_NAME_LENGTH) &&

	cmp	ecx, 50000				; 0000c350H
	jle	SHORT $LN29@xmlParseNm
	test	DWORD PTR [esi+360], 524288		; 00080000H
	je	$LN179@xmlParseNm
$LN29@xmlParseNm:

; 3660 :                         return(NULL);
; 3661 :                     }
; 3662 : 		    max *= 2;

	add	ecx, ecx

; 3663 : 		    tmp = (xmlChar *) xmlRealloc(buffer,

	push	ecx
	push	DWORD PTR _buffer$1$[ebp]
	mov	DWORD PTR _max$1$[ebp], ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 3664 : 			                            max * sizeof(xmlChar));
; 3665 : 		    if (tmp == NULL) {

	test	eax, eax
	je	$LN180@xmlParseNm

; 3668 : 			return(NULL);
; 3669 : 		    }
; 3670 : 		    buffer = tmp;

	mov	DWORD PTR _buffer$1$[ebp], eax
	jmp	SHORT $LN28@xmlParseNm
$LN190@xmlParseNm:

; 3649 :                         xmlFree(buffer);
; 3650 :                         return(NULL);
; 3651 :                     }
; 3652 : 		}
; 3653 : 		if (len + 10 > max) {

	mov	eax, DWORD PTR _buffer$1$[ebp]
$LN28@xmlParseNm:

; 3671 : 		}
; 3672 : 		COPY_BUF(l,buffer,len,c);

	add	eax, edi
	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN31@xmlParseNm
	mov	BYTE PTR [eax], bl
	inc	edi
	jmp	SHORT $LN11@xmlParseNm
$LN31@xmlParseNm:
	push	ebx
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	edi, eax
$LN11@xmlParseNm:

; 3673 : 		NEXTL(l);

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $LN33@xmlParseNm
	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN34@xmlParseNm
$LN33@xmlParseNm:
	inc	DWORD PTR [ecx+32]
$LN34@xmlParseNm:
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [ecx+16], eax

; 3674 : 		c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	esi
	call	_xmlCurrentChar
	mov	ebx, eax
	push	ebx
	push	esi
	call	_xmlIsNameChar
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LL7@xmlParseNm
$LN189@xmlParseNm:

; 3675 : 	    }
; 3676 : 	    buffer[len] = 0;

	mov	eax, DWORD PTR _buffer$1$[ebp]
	mov	BYTE PTR [eax+edi], 0
	pop	edi

; 3688 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN179@xmlParseNm:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN41@xmlParseNm
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN104@xmlParseNm
$LN41@xmlParseNm:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_07JJJDEIPB@NmToken@
	push	OFFSET ??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@
	push	OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_07JJJDEIPB@NmToken@
	push	0
	push	0
	push	3
	push	110					; 0000006eH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 110			; 0000006eH
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN104@xmlParseNm

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN104@xmlParseNm:

; 3657 :                         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3658 :                         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NmToken");
; 3659 :                         xmlFree(buffer);

	push	DWORD PTR _buffer$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3688 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN180@xmlParseNm:

; 3666 : 			xmlErrMemory(ctxt, NULL);

	push	0
	push	esi
	call	_xmlErrMemory

; 3667 : 			xmlFree(buffer);

	push	DWORD PTR _buffer$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 3688 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseNmtoken ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseName
_TEXT	SEGMENT
_ret$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseName PROC					; COMDAT

; 3283 : xmlParseName(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN4@xmlParseNa

; 3284 :     const xmlChar *in;
; 3285 :     const xmlChar *ret;
; 3286 :     int count = 0;
; 3287 : 
; 3288 :     GROW;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN4@xmlParseNa
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN4@xmlParseNa:

; 3289 : 
; 3290 : #ifdef DEBUG
; 3291 :     nbParseName++;
; 3292 : #endif
; 3293 : 
; 3294 :     /*
; 3295 :      * Accelerator for simple ASCII names
; 3296 :      */
; 3297 :     in = ctxt->input->cur;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	edi, ecx

; 3298 :     if (((*in >= 0x61) && (*in <= 0x7A)) ||
; 3299 : 	((*in >= 0x41) && (*in <= 0x5A)) ||
; 3300 : 	(*in == '_') || (*in == ':')) {

	mov	al, BYTE PTR [edi]
	cmp	al, 97					; 00000061H
	jb	SHORT $LN7@xmlParseNa
	cmp	al, 122					; 0000007aH
	jbe	SHORT $LN6@xmlParseNa
$LN7@xmlParseNa:
	cmp	al, 65					; 00000041H
	jb	SHORT $LN8@xmlParseNa
	cmp	al, 90					; 0000005aH
	jbe	SHORT $LN6@xmlParseNa
$LN8@xmlParseNa:
	cmp	al, 95					; 0000005fH
	je	SHORT $LN6@xmlParseNa
	cmp	al, 58					; 0000003aH
	jne	$LN13@xmlParseNa
$LN6@xmlParseNa:

; 3301 : 	in++;
; 3302 : 	while (((*in >= 0x61) && (*in <= 0x7A)) ||
; 3303 : 	       ((*in >= 0x41) && (*in <= 0x5A)) ||
; 3304 : 	       ((*in >= 0x30) && (*in <= 0x39)) ||
; 3305 : 	       (*in == '_') || (*in == '-') ||
; 3306 : 	       (*in == ':') || (*in == '.'))

	mov	al, BYTE PTR [edi+1]
	inc	edi
	cmp	al, 97					; 00000061H
	jb	SHORT $LN10@xmlParseNa
	cmp	al, 122					; 0000007aH
	jbe	SHORT $LN6@xmlParseNa
$LN10@xmlParseNa:
	cmp	al, 65					; 00000041H
	jb	SHORT $LN11@xmlParseNa
	cmp	al, 90					; 0000005aH
	jbe	SHORT $LN6@xmlParseNa
$LN11@xmlParseNa:
	cmp	al, 48					; 00000030H
	jb	SHORT $LN12@xmlParseNa
	cmp	al, 57					; 00000039H
	jbe	SHORT $LN6@xmlParseNa
$LN12@xmlParseNa:
	cmp	al, 95					; 0000005fH
	je	SHORT $LN6@xmlParseNa
	cmp	al, 45					; 0000002dH
	je	SHORT $LN6@xmlParseNa
	cmp	al, 58					; 0000003aH
	je	SHORT $LN6@xmlParseNa
	cmp	al, 46					; 0000002eH
	je	SHORT $LN6@xmlParseNa

; 3307 : 	    in++;
; 3308 : 	if ((*in > 0) && (*in < 0x80)) {

	dec	al
	cmp	al, 126					; 0000007eH
	ja	$LN13@xmlParseNa

; 3309 : 	    count = in - ctxt->input->cur;

	push	ebx
	mov	ebx, edi
	sub	ebx, ecx

; 3310 :             if ((count > XML_MAX_NAME_LENGTH) &&

	cmp	ebx, 50000				; 0000c350H
	jle	SHORT $LN14@xmlParseNa
	test	DWORD PTR [esi+360], 524288		; 00080000H
	jne	SHORT $LN14@xmlParseNa

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN20@xmlParseNa
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN83@xmlParseNa
$LN20@xmlParseNa:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_04FABLJDN@Name@
	push	OFFSET ??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@
	push	OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04FABLJDN@Name@
	push	0
	push	0
	push	3
	push	110					; 0000006eH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 110			; 0000006eH
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN83@xmlParseNa

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN83@xmlParseNa:

; 3311 :                 ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3312 :                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Name");
; 3313 :                 return(NULL);

	xor	eax, eax
$LN91@xmlParseNa:
	pop	ebx
	pop	edi

; 3326 : }

	pop	esi
	pop	ebp
	ret	0
$LN14@xmlParseNa:

; 3314 :             }
; 3315 : 	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);

	push	ebx
	push	ecx
	push	DWORD PTR [esi+296]
	call	_xmlDictLookup

; 3316 : 	    ctxt->input->cur = in;

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$1$[ebp], eax
	mov	DWORD PTR [ecx+16], edi

; 3317 : 	    ctxt->nbChars += count;
; 3318 : 	    ctxt->input->col += count;

	mov	ecx, DWORD PTR [esi+36]
	add	DWORD PTR [esi+200], ebx
	add	DWORD PTR [ecx+32], ebx

; 3319 : 	    if (ret == NULL)

	test	eax, eax
	jne	SHORT $LN91@xmlParseNa

; 3320 : 	        xmlErrMemory(ctxt, NULL);

	push	eax
	push	esi
	call	_xmlErrMemory
	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 8
	pop	ebx
	pop	edi

; 3326 : }

	pop	esi
	pop	ebp
	ret	0
$LN13@xmlParseNa:

; 3321 : 	    return(ret);
; 3322 : 	}
; 3323 :     }
; 3324 :     /* accelerator for special cases */
; 3325 :     return(xmlParseNameComplex(ctxt));

	push	esi
	call	_xmlParseNameComplex
	add	esp, 4
	pop	edi

; 3326 : }

	pop	esi
	pop	ebp
	ret	0
_xmlParseName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSplitQName
_TEXT	SEGMENT
_buf$ = -120						; size = 105
_max$1$ = -12						; size = 4
_c$2$ = -8						; size = 4
_c$1$ = -8						; size = 4
tv683 = -1						; size = 1
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_max$2$ = 16						; size = 4
_l$1 = 16						; size = 4
_prefix$ = 16						; size = 4
_xmlSplitQName PROC					; COMDAT

; 2889 : xmlSplitQName(xmlParserCtxtPtr ctxt, const xmlChar *name, xmlChar **prefix) {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _prefix$[ebp]
	xor	ebx, ebx
	xor	edi, edi
	mov	DWORD PTR _max$1$[ebp], 100		; 00000064H
	test	eax, eax
	je	$LN74@xmlSplitQN

; 2890 :     xmlChar buf[XML_MAX_NAMELEN + 5];
; 2891 :     xmlChar *buffer = NULL;
; 2892 :     int len = 0;
; 2893 :     int max = XML_MAX_NAMELEN;
; 2894 :     xmlChar *ret = NULL;
; 2895 :     const xmlChar *cur = name;
; 2896 :     int c;
; 2897 : 
; 2898 :     if (prefix == NULL) return(NULL);
; 2899 :     *prefix = NULL;

	mov	ecx, DWORD PTR _name$[ebp]
	mov	DWORD PTR [eax], ebx

; 2900 : 
; 2901 :     if (cur == NULL) return(NULL);

	test	ecx, ecx
	je	$LN74@xmlSplitQN

; 2902 : 
; 2903 : #ifndef XML_XML_NAMESPACE
; 2904 :     /* xml: prefix is not really a namespace */
; 2905 :     if ((cur[0] == 'x') && (cur[1] == 'm') &&
; 2906 :         (cur[2] == 'l') && (cur[3] == ':'))
; 2907 : 	return(xmlStrdup(name));
; 2908 : #endif
; 2909 : 
; 2910 :     /* nasty but well=formed */
; 2911 :     if (cur[0] == ':')

	mov	al, BYTE PTR [ecx]
	cmp	al, 58					; 0000003aH
	jne	SHORT $LN12@xmlSplitQN

; 2912 : 	return(xmlStrdup(name));

	push	ecx
	call	_xmlStrdup
	add	esp, 4
	pop	edi

; 3039 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlSplitQN:

; 2913 : 
; 2914 :     c = *cur++;

	movzx	eax, al
	mov	DWORD PTR _c$1$[ebp], eax
	push	esi
	lea	esi, DWORD PTR [ecx+1]

; 2915 :     while ((c != 0) && (c != ':') && (len < max)) { /* tested bigname.xml */

	test	eax, eax
	je	$LN13@xmlSplitQN

; 2913 : 
; 2914 :     c = *cur++;

	lea	ecx, DWORD PTR _buf$[ebp]
	sub	ecx, esi
$LL2@xmlSplitQN:

; 2915 :     while ((c != 0) && (c != ':') && (len < max)) { /* tested bigname.xml */

	cmp	eax, 58					; 0000003aH
	je	SHORT $LN3@xmlSplitQN
	cmp	edi, 100				; 00000064H
	jge	SHORT $LN68@xmlSplitQN

; 2916 : 	buf[len++] = c;

	mov	BYTE PTR [ecx+esi], al
	inc	edi

; 2917 : 	c = *cur++;

	movzx	eax, BYTE PTR [esi]
	inc	esi
	mov	DWORD PTR _c$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LL2@xmlSplitQN
$LN3@xmlSplitQN:

; 2918 :     }
; 2919 :     if (len >= max) {

	cmp	edi, 100				; 00000064H
	jl	SHORT $LN13@xmlSplitQN
$LN68@xmlSplitQN:

; 2920 : 	/*
; 2921 : 	 * Okay someone managed to make a huge name, so he's ready to pay
; 2922 : 	 * for the processing speed.
; 2923 : 	 */
; 2924 : 	max = len * 2;

	lea	eax, DWORD PTR [edi+edi]

; 2925 : 
; 2926 : 	buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));

	push	eax
	mov	DWORD PTR _max$1$[ebp], eax
	call	DWORD PTR _xmlMallocAtomic
	mov	ebx, eax
	add	esp, 4

; 2927 : 	if (buffer == NULL) {

	test	ebx, ebx
	je	$LN73@xmlSplitQN

; 2928 : 	    xmlErrMemory(ctxt, NULL);
; 2929 : 	    return(NULL);
; 2930 : 	}
; 2931 : 	memcpy(buffer, buf, len);

	push	edi
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	ebx
	call	_memcpy

; 2932 : 	while ((c != 0) && (c != ':')) { /* tested bigname.xml */

	mov	eax, DWORD PTR _c$1$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN75@xmlSplitQN
	npad	2
$LL4@xmlSplitQN:
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN75@xmlSplitQN

; 2933 : 	    if (len + 10 > max) {

	mov	ecx, DWORD PTR _max$1$[ebp]
	lea	eax, DWORD PTR [edi+10]
	cmp	eax, ecx
	jle	SHORT $LN15@xmlSplitQN

; 2934 : 	        xmlChar *tmp;
; 2935 : 
; 2936 : 		max *= 2;

	add	ecx, ecx

; 2937 : 		tmp = (xmlChar *) xmlRealloc(buffer,

	push	ecx
	push	ebx
	mov	DWORD PTR _max$1$[ebp], ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 2938 : 						max * sizeof(xmlChar));
; 2939 : 		if (tmp == NULL) {

	test	eax, eax
	je	SHORT $LN52@xmlSplitQN

; 2942 : 		    return(NULL);
; 2943 : 		}
; 2944 : 		buffer = tmp;

	mov	ebx, eax
$LN15@xmlSplitQN:

; 2945 : 	    }
; 2946 : 	    buffer[len++] = c;

	mov	eax, DWORD PTR _c$1$[ebp]
	mov	BYTE PTR [edi+ebx], al
	inc	edi

; 2947 : 	    c = *cur++;

	movzx	eax, BYTE PTR [esi]
	inc	esi
	mov	DWORD PTR _c$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LL4@xmlSplitQN
$LN75@xmlSplitQN:

; 2948 : 	}
; 2949 : 	buffer[len] = 0;

	mov	BYTE PTR [edi+ebx], 0
$LN13@xmlSplitQN:

; 2950 :     }
; 2951 : 
; 2952 :     if ((c == ':') && (*cur == 0)) {

	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN72@xmlSplitQN
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN72@xmlSplitQN

; 2953 :         if (buffer != NULL)

	test	ebx, ebx
	je	SHORT $LN18@xmlSplitQN

; 2954 : 	    xmlFree(buffer);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN18@xmlSplitQN:

; 2955 : 	*prefix = NULL;

	mov	ecx, DWORD PTR _prefix$[ebp]

; 2956 : 	return(xmlStrdup(name));

	push	DWORD PTR _name$[ebp]
	mov	DWORD PTR [ecx], 0
	call	_xmlStrdup
	add	esp, 4
	pop	esi
	pop	edi

; 3039 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@xmlSplitQN:

; 2940 : 		    xmlFree(buffer);

	push	ebx
	call	DWORD PTR _xmlFree

; 2941 : 		    xmlErrMemory(ctxt, NULL);

	push	0
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrMemory

; 3008 : 		return(NULL);

	add	esp, 12					; 0000000cH
	xor	eax, eax
	pop	esi
	pop	edi

; 3039 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN72@xmlSplitQN:

; 2957 :     }
; 2958 : 
; 2959 :     if (buffer == NULL)

	test	ebx, ebx
	jne	SHORT $LN19@xmlSplitQN

; 2960 : 	ret = xmlStrndup(buf, len);

	lea	eax, DWORD PTR _buf$[ebp]
	push	edi
	push	eax
	call	_xmlStrndup
	mov	ebx, eax
	add	esp, 8
	mov	eax, DWORD PTR _c$1$[ebp]
	jmp	SHORT $LN20@xmlSplitQN
$LN19@xmlSplitQN:

; 2961 :     else {
; 2962 : 	ret = buffer;
; 2963 : 	buffer = NULL;
; 2964 : 	max = XML_MAX_NAMELEN;

	mov	DWORD PTR _max$1$[ebp], 100		; 00000064H
$LN20@xmlSplitQN:

; 2965 :     }
; 2966 : 
; 2967 : 
; 2968 :     if (c == ':') {

	cmp	eax, 58					; 0000003aH
	jne	$LN32@xmlSplitQN

; 2969 : 	c = *cur;

	mov	al, BYTE PTR [esi]

; 2970 :         *prefix = ret;

	mov	ecx, DWORD PTR _prefix$[ebp]
	mov	BYTE PTR tv683[ebp], al
	movzx	eax, al
	mov	DWORD PTR _c$2$[ebp], eax
	mov	DWORD PTR [ecx], ebx

; 2971 : 	if (c == 0) {

	test	eax, eax
	jne	SHORT $LN22@xmlSplitQN

; 2972 : 	    return(xmlStrndup(BAD_CAST "", 0));

	push	eax
	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrndup
	add	esp, 8
	pop	esi
	pop	edi

; 3039 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@xmlSplitQN:

; 2973 : 	}
; 2974 : 	len = 0;
; 2975 : 
; 2976 : 	/*
; 2977 : 	 * Check that the first character is proper to start
; 2978 : 	 * a new name
; 2979 : 	 */
; 2980 : 	if (!(((c >= 0x61) && (c <= 0x7A)) ||

	mov	cl, BYTE PTR tv683[ebp]
	xor	edi, edi
	cmp	cl, 97					; 00000061H
	jb	SHORT $LN24@xmlSplitQN
	cmp	cl, 122					; 0000007aH
	jbe	$LN26@xmlSplitQN
$LN24@xmlSplitQN:
	cmp	cl, 65					; 00000041H
	jb	SHORT $LN25@xmlSplitQN
	cmp	cl, 90					; 0000005aH
	jbe	$LN26@xmlSplitQN
$LN25@xmlSplitQN:
	cmp	cl, 95					; 0000005fH
	je	$LN26@xmlSplitQN
	cmp	cl, 58					; 0000003aH
	je	$LN26@xmlSplitQN

; 2981 : 	      ((c >= 0x41) && (c <= 0x5A)) ||
; 2982 : 	      (c == '_') || (c == ':'))) {
; 2983 : 	    int l;
; 2984 : 	    int first = CUR_SCHAR(cur, l);

	lea	eax, DWORD PTR _l$1[ebp]
	push	eax
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlStringCurrentChar
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 2985 : 
; 2986 : 	    if (!IS_LETTER(first) && (first != '_')) {

	cmp	ebx, 256				; 00000100H
	jge	SHORT $LN40@xmlSplitQN
	cmp	ebx, 65					; 00000041H
	jl	SHORT $LN34@xmlSplitQN
	cmp	ebx, 90					; 0000005aH
	jle	$LN86@xmlSplitQN
$LN34@xmlSplitQN:
	cmp	ebx, 97					; 00000061H
	jl	SHORT $LN35@xmlSplitQN
	cmp	ebx, 122				; 0000007aH
	jle	$LN86@xmlSplitQN
$LN35@xmlSplitQN:
	cmp	ebx, 192				; 000000c0H
	jl	SHORT $LN37@xmlSplitQN
	cmp	ebx, 214				; 000000d6H
	jle	SHORT $LN86@xmlSplitQN
$LN37@xmlSplitQN:
	cmp	ebx, 216				; 000000d8H
	jl	SHORT $LN38@xmlSplitQN
	cmp	ebx, 246				; 000000f6H
	jle	SHORT $LN86@xmlSplitQN
$LN38@xmlSplitQN:
	cmp	ebx, 248				; 000000f8H
	jge	SHORT $LN86@xmlSplitQN
	jmp	SHORT $LN69@xmlSplitQN
$LN40@xmlSplitQN:
	push	OFFSET _xmlIsBaseCharGroup
	push	ebx
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN86@xmlSplitQN
$LN69@xmlSplitQN:
	cmp	ebx, 256				; 00000100H
	jl	SHORT $LN71@xmlSplitQN
	cmp	ebx, 19968				; 00004e00H
	jl	SHORT $LN42@xmlSplitQN
	cmp	ebx, 40869				; 00009fa5H
	jle	SHORT $LN86@xmlSplitQN
$LN42@xmlSplitQN:
	cmp	ebx, 12295				; 00003007H
	je	SHORT $LN86@xmlSplitQN
	cmp	ebx, 12321				; 00003021H
	jl	SHORT $LN71@xmlSplitQN
	cmp	ebx, 12329				; 00003029H
	jle	SHORT $LN86@xmlSplitQN
$LN71@xmlSplitQN:
	cmp	ebx, 95					; 0000005fH
	je	SHORT $LN86@xmlSplitQN

; 2987 : 		xmlFatalErrMsgStr(ctxt, XML_NS_ERR_QNAME,

	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0CI@GHNHPHHB@Name?5?$CFs?5is?5not?5XML?5Namespace?5co@
	push	202					; 000000caH
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H
$LN86@xmlSplitQN:

; 2988 : 			    "Name %s is not XML Namespace compliant\n",
; 2989 : 				  name);
; 2990 : 	    }
; 2991 : 	}
; 2992 : 	cur++;

	mov	eax, DWORD PTR _c$2$[ebp]
	mov	cl, BYTE PTR tv683[ebp]
$LN26@xmlSplitQN:
	inc	esi

; 2993 : 
; 2994 : 	while ((c != 0) && (len < max)) { /* tested bigname2.xml */

	test	cl, cl
	mov	ecx, DWORD PTR _max$1$[ebp]
	je	SHORT $LN7@xmlSplitQN
	npad	4
$LL6@xmlSplitQN:
	cmp	edi, ecx
	jge	SHORT $LN67@xmlSplitQN

; 2995 : 	    buf[len++] = c;

	mov	BYTE PTR _buf$[ebp+edi], al
	inc	edi

; 2996 : 	    c = *cur++;

	movzx	eax, BYTE PTR [esi]
	inc	esi
	mov	DWORD PTR _c$2$[ebp], eax
	test	eax, eax
	jne	SHORT $LL6@xmlSplitQN
$LN7@xmlSplitQN:

; 2997 : 	}
; 2998 : 	if (len >= max) {

	cmp	edi, ecx
	jl	$LN70@xmlSplitQN
$LN67@xmlSplitQN:

; 2999 : 	    /*
; 3000 : 	     * Okay someone managed to make a huge name, so he's ready to pay
; 3001 : 	     * for the processing speed.
; 3002 : 	     */
; 3003 : 	    max = len * 2;

	lea	eax, DWORD PTR [edi+edi]

; 3004 : 
; 3005 : 	    buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));

	push	eax
	mov	DWORD PTR _max$2$[ebp], eax
	call	DWORD PTR _xmlMallocAtomic
	mov	ebx, eax
	add	esp, 4

; 3006 : 	    if (buffer == NULL) {

	test	ebx, ebx
	jne	SHORT $LN28@xmlSplitQN
$LN73@xmlSplitQN:

; 3007 : 	        xmlErrMemory(ctxt, NULL);

	push	0
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrMemory
	add	esp, 8

; 3008 : 		return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 3039 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlSplitQN:

; 3009 : 	    }
; 3010 : 	    memcpy(buffer, buf, len);

	push	edi
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3011 : 	    while (c != 0) { /* tested bigname2.xml */

	cmp	DWORD PTR _c$2$[ebp], 0
	je	SHORT $LN76@xmlSplitQN
	mov	ecx, DWORD PTR _max$2$[ebp]
	npad	1
$LL8@xmlSplitQN:

; 3012 : 		if (len + 10 > max) {

	lea	eax, DWORD PTR [edi+10]
	cmp	eax, ecx
	jle	SHORT $LN29@xmlSplitQN

; 3013 : 		    xmlChar *tmp;
; 3014 : 
; 3015 : 		    max *= 2;

	add	ecx, ecx

; 3016 : 		    tmp = (xmlChar *) xmlRealloc(buffer,

	push	ecx
	push	ebx
	mov	DWORD PTR _max$2$[ebp], ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 3017 : 						    max * sizeof(xmlChar));
; 3018 : 		    if (tmp == NULL) {

	test	eax, eax
	je	SHORT $LN53@xmlSplitQN

; 3021 : 			return(NULL);
; 3022 : 		    }
; 3023 : 		    buffer = tmp;

	mov	ecx, DWORD PTR _max$2$[ebp]
	mov	ebx, eax
$LN29@xmlSplitQN:

; 3024 : 		}
; 3025 : 		buffer[len++] = c;

	mov	eax, DWORD PTR _c$2$[ebp]
	mov	BYTE PTR [edi+ebx], al
	inc	edi

; 3026 : 		c = *cur++;

	movzx	eax, BYTE PTR [esi]
	inc	esi
	mov	DWORD PTR _c$2$[ebp], eax
	test	eax, eax
	jne	SHORT $LL8@xmlSplitQN
$LN76@xmlSplitQN:

; 3027 : 	    }
; 3028 : 	    buffer[len] = 0;

	mov	BYTE PTR [edi+ebx], 0

; 3029 : 	}
; 3030 : 
; 3031 : 	if (buffer == NULL)

	test	ebx, ebx
	jne	SHORT $LN32@xmlSplitQN
$LN70@xmlSplitQN:

; 3032 : 	    ret = xmlStrndup(buf, len);

	lea	eax, DWORD PTR _buf$[ebp]
	push	edi
	push	eax
	call	_xmlStrndup
	add	esp, 8
	mov	ebx, eax
$LN32@xmlSplitQN:

; 3033 : 	else {
; 3034 : 	    ret = buffer;
; 3035 : 	}
; 3036 :     }
; 3037 : 
; 3038 :     return(ret);

	pop	esi
	pop	edi
	mov	eax, ebx

; 3039 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@xmlSplitQN:

; 3019 : 			xmlErrMemory(ctxt, NULL);

	push	0
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrMemory

; 3020 : 			xmlFree(buffer);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
	xor	eax, eax
	pop	esi
	pop	edi

; 3039 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@xmlSplitQN:
	pop	edi

; 2900 : 
; 2901 :     if (cur == NULL) return(NULL);

	xor	eax, eax

; 3039 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSplitQName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlPopInput
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlPopInput PROC					; COMDAT

; 2218 : xmlPopInput(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	je	$LN3@xmlPopInpu

; 2219 :     if ((ctxt == NULL) || (ctxt->inputNr <= 1)) return(0);

	cmp	DWORD PTR [ebx+40], 1
	jle	$LN3@xmlPopInpu

; 2220 :     if (xmlParserDebugEntities)

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@xmlPopInpu

; 2221 : 	xmlGenericError(xmlGenericErrorContext,

	push	esi
	push	edi
	call	___xmlGenericError
	mov	esi, DWORD PTR [ebx+40]
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0BC@LEKDBCEK@Popping?5input?5?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
$LN4@xmlPopInpu:

; 2222 : 		"Popping input %d\n", ctxt->inputNr);
; 2223 :     if ((ctxt->inputNr > 1) && (ctxt->inSubset == 0) &&

	cmp	DWORD PTR [ebx+40], 1
	jle	SHORT $LN5@xmlPopInpu
	cmp	DWORD PTR [ebx+216], 0
	jne	SHORT $LN5@xmlPopInpu
	cmp	DWORD PTR [ebx+172], -1
	je	SHORT $LN5@xmlPopInpu

; 2224 :         (ctxt->instate != XML_PARSER_EOF))
; 2225 :         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CC@JODEMIEP@Unfinished?5entity?5outside?5the?5D@
	push	1
	push	ebx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN5@xmlPopInpu:

; 2226 :                     "Unfinished entity outside the DTD");
; 2227 :     xmlFreeInputStream(inputPop(ctxt));

	push	ebx
	call	_inputPop
	push	eax
	call	_xmlFreeInputStream

; 2228 :     if (*ctxt->input->cur == 0)

	mov	ecx, DWORD PTR [ebx+36]
	add	esp, 8
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN6@xmlPopInpu

; 2229 :         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	mov	ecx, DWORD PTR [ebx+36]
	add	esp, 8
$LN6@xmlPopInpu:

; 2230 :     return(CUR);

	mov	eax, DWORD PTR [ecx+16]
	pop	ebx
	mov	al, BYTE PTR [eax]

; 2231 : }

	pop	ebp
	ret	0
$LN3@xmlPopInpu:

; 2219 :     if ((ctxt == NULL) || (ctxt->inputNr <= 1)) return(0);

	xor	al, al
	pop	ebx

; 2231 : }

	pop	ebp
	ret	0
_xmlPopInput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlPushInput
_TEXT	SEGMENT
tv598 = -4						; size = 4
tv595 = -4						; size = 4
_ctxt$ = 8						; size = 4
_input$ = 12						; size = 4
_xmlPushInput PROC					; COMDAT

; 2243 : xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _input$[ebp]
	test	ebx, ebx
	je	$LN91@xmlPushInp

; 2244 :     int ret;
; 2245 :     if (input == NULL) return(-1);
; 2246 : 
; 2247 :     if (xmlParserDebugEntities) {

	call	___xmlParserDebugEntities
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@xmlPushInp

; 2248 : 	if ((ctxt->input != NULL) && (ctxt->input->filename))

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN6@xmlPushInp
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN6@xmlPushInp

; 2249 : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR tv598[ebp], eax
	mov	edi, DWORD PTR [ecx+28]
	mov	ebx, DWORD PTR [ecx+4]
	call	___xmlGenericErrorContext
	push	edi
	push	ebx
	push	OFFSET ??_C@_08FFIMCMGN@?$CFs?$CI?$CFd?$CJ?3?5@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR tv598[ebp]
	mov	eax, DWORD PTR [eax]
	call	eax
	mov	ebx, DWORD PTR _input$[ebp]
	add	esp, 16					; 00000010H
$LN6@xmlPushInp:

; 2250 : 		    "%s(%d): ", ctxt->input->filename,
; 2251 : 		    ctxt->input->line);
; 2252 : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, DWORD PTR [ebx+16]
	mov	ebx, DWORD PTR [esi+40]
	mov	DWORD PTR tv595[ebp], eax
	call	___xmlGenericErrorContext
	push	edi
	lea	ecx, DWORD PTR [ebx+1]
	push	ecx
	push	OFFSET ??_C@_0BK@IPLLKNJK@Pushing?5input?5?$CFd?5?3?5?$CF?430s?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR tv595[ebp]
	mov	eax, DWORD PTR [eax]
	call	eax
	mov	ebx, DWORD PTR _input$[ebp]
	add	esp, 16					; 00000010H
$LN5@xmlPushInp:

; 2253 : 		"Pushing input %d : %.30s\n", ctxt->inputNr+1, input->cur);
; 2254 :     }
; 2255 :     if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||

	mov	eax, DWORD PTR [esi+40]
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN9@xmlPushInp
	test	DWORD PTR [esi+360], 524288		; 00080000H
	je	SHORT $LN8@xmlPushInp
$LN9@xmlPushInp:
	cmp	eax, 1024				; 00000400H
	jle	$LN7@xmlPushInp
$LN8@xmlPushInp:

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN16@xmlPushInp
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN87@xmlPushInp
$LN16@xmlPushInp:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0CC@LFHGNGFD@Detected?5an?5entity?5reference?5lo@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	89					; 00000059H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 89			; 00000059H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN87@xmlPushInp

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN87@xmlPushInp:

; 2256 :         (ctxt->inputNr > 1024)) {
; 2257 :         xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
; 2258 :         while (ctxt->inputNr > 1)

	mov	eax, DWORD PTR [esi+40]
	cmp	eax, 1
	jle	SHORT $LN91@xmlPushInp
$LL2@xmlPushInp:

; 1748 :     if (ctxt->inputNr <= 0)

	test	eax, eax
	jg	SHORT $LN83@xmlPushInp

; 1749 :         return (NULL);

	xor	edx, edx
	jmp	SHORT $LN81@xmlPushInp
$LN83@xmlPushInp:

; 1750 :     ctxt->inputNr--;

	lea	ecx, DWORD PTR [eax-1]
	mov	DWORD PTR [esi+40], ecx

; 1751 :     if (ctxt->inputNr > 0)

	test	ecx, ecx
	jle	SHORT $LN84@xmlPushInp

; 1752 :         ctxt->input = ctxt->inputTab[ctxt->inputNr - 1];

	mov	eax, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN85@xmlPushInp
$LN84@xmlPushInp:

; 1753 :     else
; 1754 :         ctxt->input = NULL;

	xor	eax, eax
$LN85@xmlPushInp:

; 1755 :     ret = ctxt->inputTab[ctxt->inputNr];

	mov	DWORD PTR [esi+36], eax
	mov	eax, DWORD PTR [esi+48]
	mov	edx, DWORD PTR [eax+ecx*4]

; 1756 :     ctxt->inputTab[ctxt->inputNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0
$LN81@xmlPushInp:

; 2259 :             xmlFreeInputStream(inputPop(ctxt));

	push	edx
	call	_xmlFreeInputStream
	mov	eax, DWORD PTR [esi+40]
	add	esp, 4
	cmp	eax, 1
	jg	SHORT $LL2@xmlPushInp
$LN91@xmlPushInp:
	pop	edi

; 2267 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlPushInp:

; 2260 : 	return(-1);
; 2261 :     }
; 2262 :     ret = inputPush(ctxt, input);

	push	ebx
	push	esi
	call	_inputPush
	add	esp, 8
	mov	edi, eax

; 2263 :     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN91@xmlPushInp

; 2264 :         return(-1);
; 2265 :     GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN11@xmlPushInp
	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN11@xmlPushInp
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN11@xmlPushInp:

; 2266 :     return(ret);

	mov	eax, edi
	pop	edi

; 2267 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlPushInput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCreateEntityParserCtxt
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_ID$ = 12						; size = 4
_base$ = 16						; size = 4
_xmlCreateEntityParserCtxt PROC				; COMDAT

; 14060: 	                  const xmlChar *base) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _base$[ebp]
	push	DWORD PTR _ID$[ebp]
	push	DWORD PTR _URL$[ebp]
	call	_xmlCreateEntityParserCtxtInternal
	add	esp, 16					; 00000010H

; 14061:     return xmlCreateEntityParserCtxtInternal(URL, ID, base, NULL);
; 14062: 
; 14063: }

	pop	ebp
	ret	0
_xmlCreateEntityParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCreateMemoryParserCtxt
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlCreateMemoryParserCtxt PROC				; COMDAT

; 14371: xmlCreateMemoryParserCtxt(const char *buffer, int size) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _buffer$[ebp]
	test	ebx, ebx
	je	SHORT $LN8@xmlCreateM

; 14372:     xmlParserCtxtPtr ctxt;
; 14373:     xmlParserInputPtr input;
; 14374:     xmlParserInputBufferPtr buf;
; 14375: 
; 14376:     if (buffer == NULL)
; 14377: 	return(NULL);
; 14378:     if (size <= 0)

	mov	edi, DWORD PTR _size$[ebp]
	test	edi, edi
	jle	SHORT $LN8@xmlCreateM

; 14379: 	return(NULL);
; 14380: 
; 14381:     ctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	esi, eax

; 14382:     if (ctxt == NULL)

	test	esi, esi
	je	SHORT $LN8@xmlCreateM

; 14383: 	return(NULL);
; 14384: 
; 14385:     /* TODO: xmlParserInputBufferCreateStatic, requires some serious changes */
; 14386:     buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);

	push	0
	push	edi
	push	ebx
	call	_xmlParserInputBufferCreateMem
	add	esp, 12					; 0000000cH
	mov	ebx, eax

; 14387:     if (buf == NULL) {

	push	esi
	test	ebx, ebx
	jne	SHORT $LN5@xmlCreateM

; 14388: 	xmlFreeParserCtxt(ctxt);

	call	_xmlFreeParserCtxt
	add	esp, 4
$LN8@xmlCreateM:

; 14405: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlCreateM:

; 14389: 	return(NULL);
; 14390:     }
; 14391: 
; 14392:     input = xmlNewInputStream(ctxt);

	call	_xmlNewInputStream
	mov	edi, eax
	add	esp, 4

; 14393:     if (input == NULL) {

	test	edi, edi
	jne	SHORT $LN6@xmlCreateM

; 14394: 	xmlFreeParserInputBuffer(buf);

	push	ebx
	call	_xmlFreeParserInputBuffer

; 14395: 	xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 8

; 14405: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlCreateM:

; 14396: 	return(NULL);
; 14397:     }
; 14398: 
; 14399:     input->filename = NULL;

	mov	DWORD PTR [edi+4], 0

; 14400:     input->buf = buf;

	mov	DWORD PTR [edi], ebx

; 14401:     xmlBufResetInput(input->buf->buffer, input);

	push	edi
	push	DWORD PTR [ebx+16]
	call	_xmlBufResetInput

; 14402: 
; 14403:     inputPush(ctxt, input);

	push	edi
	push	esi
	call	_inputPush
	add	esp, 16					; 00000010H

; 14404:     return(ctxt);

	mov	eax, esi
	pop	edi

; 14405: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlCreateMemoryParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCreateURLParserCtxt
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_options$ = 12						; size = 4
_xmlCreateURLParserCtxt PROC				; COMDAT

; 14084: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	edi, edi
	call	_xmlNewParserCtxt
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN2@xmlCreateU

; 14085:     xmlParserCtxtPtr ctxt;
; 14086:     xmlParserInputPtr inputStream;
; 14087:     char *directory = NULL;
; 14088: 
; 14089:     ctxt = xmlNewParserCtxt();
; 14090:     if (ctxt == NULL) {
; 14091: 	xmlErrMemory(NULL, "cannot allocate parser context");

	push	OFFSET ??_C@_0BP@IGCIIMIK@cannot?5allocate?5parser?5context@
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 14092: 	return(NULL);

	xor	eax, eax
	pop	edi

; 14112: }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlCreateU:

; 14093:     }
; 14094: 
; 14095:     if (options)

	mov	eax, DWORD PTR _options$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlCreateU

; 14096: 	xmlCtxtUseOptionsInternal(ctxt, options, NULL);

	push	0
	push	eax
	push	esi
	call	_xmlCtxtUseOptionsInternal
	add	esp, 12					; 0000000cH
$LN3@xmlCreateU:

; 14097:     ctxt->linenumbers = 1;
; 14098: 
; 14099:     inputStream = xmlLoadExternalEntity(filename, NULL, ctxt);

	push	esi
	push	0
	push	DWORD PTR _filename$[ebp]
	mov	DWORD PTR [esi+280], 1
	call	_xmlLoadExternalEntity
	add	esp, 12					; 0000000cH

; 14100:     if (inputStream == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlCreateU

; 14101: 	xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14102: 	return(NULL);

	xor	eax, eax
	pop	edi

; 14112: }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlCreateU:

; 14103:     }
; 14104: 
; 14105:     inputPush(ctxt, inputStream);

	push	eax
	push	esi
	call	_inputPush

; 14106:     if ((ctxt->directory == NULL) && (directory == NULL))

	mov	eax, DWORD PTR [esi+180]
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@xmlCreateU

; 14107:         directory = xmlParserGetDirectory(filename);

	push	DWORD PTR _filename$[ebp]
	call	_xmlParserGetDirectory
	mov	edi, eax
	add	esp, 4
	mov	eax, DWORD PTR [esi+180]

; 14108:     if ((ctxt->directory == NULL) && (directory != NULL))

	test	eax, eax
	jne	SHORT $LN6@xmlCreateU
	test	edi, edi
	je	SHORT $LN6@xmlCreateU

; 14109:         ctxt->directory = directory;

	mov	DWORD PTR [esi+180], edi
$LN6@xmlCreateU:
	pop	edi

; 14110: 
; 14111:     return(ctxt);

	mov	eax, esi

; 14112: }

	pop	esi
	pop	ebp
	ret	0
_xmlCreateURLParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCreateFileParserCtxt
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlCreateFileParserCtxt PROC				; COMDAT

; 14126: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _filename$[ebp]
	call	_xmlCreateURLParserCtxt
	add	esp, 8

; 14127:     return(xmlCreateURLParserCtxt(filename, 0));
; 14128: }

	pop	ebp
	ret	0
_xmlCreateFileParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlHasFeature
_TEXT	SEGMENT
_feature$ = 8						; size = 4
_xmlHasFeature PROC					; COMDAT

; 849  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _feature$[ebp]
	dec	eax
	cmp	eax, 32					; 00000020H
	ja	SHORT $LN37@xmlHasFeat

; 850  :     switch (feature) {

	movzx	eax, BYTE PTR $LN39@xmlHasFeat[eax]
	jmp	DWORD PTR $LN41@xmlHasFeat[eax*4]
$LN35@xmlHasFeat:

; 851  : 	case XML_WITH_THREAD:
; 852  : #ifdef LIBXML_THREAD_ENABLED
; 853  : 	    return(1);
; 854  : #else
; 855  : 	    return(0);
; 856  : #endif
; 857  :         case XML_WITH_TREE:
; 858  : #ifdef LIBXML_TREE_ENABLED
; 859  :             return(1);
; 860  : #else
; 861  :             return(0);
; 862  : #endif
; 863  :         case XML_WITH_OUTPUT:
; 864  : #ifdef LIBXML_OUTPUT_ENABLED
; 865  :             return(1);
; 866  : #else
; 867  :             return(0);
; 868  : #endif
; 869  :         case XML_WITH_PUSH:
; 870  : #ifdef LIBXML_PUSH_ENABLED
; 871  :             return(1);
; 872  : #else
; 873  :             return(0);
; 874  : #endif
; 875  :         case XML_WITH_READER:
; 876  : #ifdef LIBXML_READER_ENABLED
; 877  :             return(1);
; 878  : #else
; 879  :             return(0);
; 880  : #endif
; 881  :         case XML_WITH_PATTERN:
; 882  : #ifdef LIBXML_PATTERN_ENABLED
; 883  :             return(1);
; 884  : #else
; 885  :             return(0);
; 886  : #endif
; 887  :         case XML_WITH_WRITER:
; 888  : #ifdef LIBXML_WRITER_ENABLED
; 889  :             return(1);
; 890  : #else
; 891  :             return(0);
; 892  : #endif
; 893  :         case XML_WITH_SAX1:
; 894  : #ifdef LIBXML_SAX1_ENABLED
; 895  :             return(1);
; 896  : #else
; 897  :             return(0);
; 898  : #endif
; 899  :         case XML_WITH_FTP:
; 900  : #ifdef LIBXML_FTP_ENABLED
; 901  :             return(1);
; 902  : #else
; 903  :             return(0);
; 904  : #endif
; 905  :         case XML_WITH_HTTP:
; 906  : #ifdef LIBXML_HTTP_ENABLED
; 907  :             return(1);
; 908  : #else
; 909  :             return(0);
; 910  : #endif
; 911  :         case XML_WITH_VALID:
; 912  : #ifdef LIBXML_VALID_ENABLED
; 913  :             return(1);
; 914  : #else
; 915  :             return(0);
; 916  : #endif
; 917  :         case XML_WITH_HTML:
; 918  : #ifdef LIBXML_HTML_ENABLED
; 919  :             return(1);
; 920  : #else
; 921  :             return(0);
; 922  : #endif
; 923  :         case XML_WITH_LEGACY:
; 924  : #ifdef LIBXML_LEGACY_ENABLED
; 925  :             return(1);
; 926  : #else
; 927  :             return(0);
; 928  : #endif
; 929  :         case XML_WITH_C14N:
; 930  : #ifdef LIBXML_C14N_ENABLED
; 931  :             return(1);
; 932  : #else
; 933  :             return(0);
; 934  : #endif
; 935  :         case XML_WITH_CATALOG:
; 936  : #ifdef LIBXML_CATALOG_ENABLED
; 937  :             return(1);
; 938  : #else
; 939  :             return(0);
; 940  : #endif
; 941  :         case XML_WITH_XPATH:
; 942  : #ifdef LIBXML_XPATH_ENABLED
; 943  :             return(1);
; 944  : #else
; 945  :             return(0);
; 946  : #endif
; 947  :         case XML_WITH_XPTR:
; 948  : #ifdef LIBXML_XPTR_ENABLED
; 949  :             return(1);
; 950  : #else
; 951  :             return(0);
; 952  : #endif
; 953  :         case XML_WITH_XINCLUDE:
; 954  : #ifdef LIBXML_XINCLUDE_ENABLED
; 955  :             return(1);
; 956  : #else
; 957  :             return(0);
; 958  : #endif
; 959  :         case XML_WITH_ICONV:
; 960  : #ifdef LIBXML_ICONV_ENABLED
; 961  :             return(1);
; 962  : #else
; 963  :             return(0);
; 964  : #endif
; 965  :         case XML_WITH_ISO8859X:
; 966  : #ifdef LIBXML_ISO8859X_ENABLED
; 967  :             return(1);
; 968  : #else
; 969  :             return(0);
; 970  : #endif
; 971  :         case XML_WITH_UNICODE:
; 972  : #ifdef LIBXML_UNICODE_ENABLED
; 973  :             return(1);
; 974  : #else
; 975  :             return(0);
; 976  : #endif
; 977  :         case XML_WITH_REGEXP:
; 978  : #ifdef LIBXML_REGEXP_ENABLED
; 979  :             return(1);
; 980  : #else
; 981  :             return(0);
; 982  : #endif
; 983  :         case XML_WITH_AUTOMATA:
; 984  : #ifdef LIBXML_AUTOMATA_ENABLED
; 985  :             return(1);
; 986  : #else
; 987  :             return(0);
; 988  : #endif
; 989  :         case XML_WITH_EXPR:
; 990  : #ifdef LIBXML_EXPR_ENABLED
; 991  :             return(1);
; 992  : #else
; 993  :             return(0);
; 994  : #endif
; 995  :         case XML_WITH_SCHEMAS:
; 996  : #ifdef LIBXML_SCHEMAS_ENABLED
; 997  :             return(1);
; 998  : #else
; 999  :             return(0);
; 1000 : #endif
; 1001 :         case XML_WITH_SCHEMATRON:
; 1002 : #ifdef LIBXML_SCHEMATRON_ENABLED
; 1003 :             return(1);
; 1004 : #else
; 1005 :             return(0);
; 1006 : #endif
; 1007 :         case XML_WITH_MODULES:
; 1008 : #ifdef LIBXML_MODULES_ENABLED
; 1009 :             return(1);
; 1010 : #else
; 1011 :             return(0);
; 1012 : #endif
; 1013 :         case XML_WITH_DEBUG:
; 1014 : #ifdef LIBXML_DEBUG_ENABLED
; 1015 :             return(1);
; 1016 : #else
; 1017 :             return(0);
; 1018 : #endif
; 1019 :         case XML_WITH_DEBUG_MEM:
; 1020 : #ifdef DEBUG_MEMORY_LOCATION
; 1021 :             return(1);
; 1022 : #else
; 1023 :             return(0);
; 1024 : #endif
; 1025 :         case XML_WITH_DEBUG_RUN:
; 1026 : #ifdef LIBXML_DEBUG_RUNTIME
; 1027 :             return(1);
; 1028 : #else
; 1029 :             return(0);
; 1030 : #endif
; 1031 :         case XML_WITH_ZLIB:
; 1032 : #ifdef LIBXML_ZLIB_ENABLED
; 1033 :             return(1);
; 1034 : #else
; 1035 :             return(0);
; 1036 : #endif
; 1037 :         case XML_WITH_LZMA:
; 1038 : #ifdef LIBXML_LZMA_ENABLED
; 1039 :             return(1);

	mov	eax, 1

; 1053 : }

	pop	ebp
	ret	0
$LN37@xmlHasFeat:

; 1040 : #else
; 1041 :             return(0);
; 1042 : #endif
; 1043 :         case XML_WITH_ICU:
; 1044 : #ifdef LIBXML_ICU_ENABLED
; 1045 :             return(1);
; 1046 : #else
; 1047 :             return(0);
; 1048 : #endif
; 1049 :         default:
; 1050 : 	    break;
; 1051 :      }
; 1052 :      return(0);

	xor	eax, eax

; 1053 : }

	pop	ebp
	ret	0
	npad	1
$LN41@xmlHasFeat:
	DD	$LN35@xmlHasFeat
	DD	$LN37@xmlHasFeat
$LN39@xmlHasFeat:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
_xmlHasFeature ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtReadIO
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_ioread$ = 12						; size = 4
_ioclose$ = 16						; size = 4
_ioctx$ = 20						; size = 4
_URL$ = 24						; size = 4
_encoding$ = 28						; size = 4
_options$ = 32						; size = 4
_xmlCtxtReadIO PROC					; COMDAT

; 15554: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ioread$[ebp]
	test	ebx, ebx
	je	SHORT $LN5@xmlCtxtRea

; 15555:     xmlParserInputBufferPtr input;
; 15556:     xmlParserInputPtr stream;
; 15557: 
; 15558:     if (ioread == NULL)
; 15559:         return (NULL);
; 15560:     if (ctxt == NULL)

	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlCtxtRea

; 15561:         return (NULL);
; 15562:     xmlInitParser();

	call	_xmlInitParser

; 15563: 
; 15564:     xmlCtxtReset(ctxt);

	push	esi
	call	_xmlCtxtReset

; 15565: 
; 15566:     input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,

	mov	edi, DWORD PTR _ioclose$[ebp]
	push	0
	push	DWORD PTR _ioctx$[ebp]
	push	edi
	push	ebx
	call	_xmlParserInputBufferCreateIO
	mov	ebx, eax
	add	esp, 20					; 00000014H

; 15567:                                          XML_CHAR_ENCODING_NONE);
; 15568:     if (input == NULL) {

	test	ebx, ebx
	jne	SHORT $LN4@xmlCtxtRea

; 15569:         if (ioclose != NULL)

	test	edi, edi
	je	SHORT $LN5@xmlCtxtRea

; 15570:             ioclose(ioctx);

	push	DWORD PTR _ioctx$[ebp]
	call	edi

; 15580: }

	add	esp, 4
$LN5@xmlCtxtRea:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlCtxtRea:

; 15571:         return (NULL);
; 15572:     }
; 15573:     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);

	push	0
	push	ebx
	push	esi
	call	_xmlNewIOInputStream
	add	esp, 12					; 0000000cH

; 15574:     if (stream == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlCtxtRea

; 15575:         xmlFreeParserInputBuffer(input);

	push	ebx
	call	_xmlFreeParserInputBuffer

; 15580: }

	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlCtxtRea:

; 15576:         return (NULL);
; 15577:     }
; 15578:     inputPush(ctxt, stream);

	push	eax
	push	esi
	call	_inputPush

; 15579:     return (xmlDoRead(ctxt, URL, encoding, options, 1));

	push	1
	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _encoding$[ebp]
	push	DWORD PTR _URL$[ebp]
	push	esi
	call	_xmlDoRead
	add	esp, 28					; 0000001cH
	pop	edi

; 15580: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlCtxtReadIO ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtReadFd
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_fd$ = 12						; size = 4
_URL$ = 16						; size = 4
_encoding$ = 20						; size = 4
_options$ = 24						; size = 4
_xmlCtxtReadFd PROC					; COMDAT

; 15508: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _fd$[ebp]
	test	edi, edi
	js	SHORT $LN7@xmlCtxtRea

; 15509:     xmlParserInputBufferPtr input;
; 15510:     xmlParserInputPtr stream;
; 15511: 
; 15512:     if (fd < 0)
; 15513:         return (NULL);
; 15514:     if (ctxt == NULL)

	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN7@xmlCtxtRea

; 15515:         return (NULL);
; 15516:     xmlInitParser();

	call	_xmlInitParser

; 15517: 
; 15518:     xmlCtxtReset(ctxt);

	push	esi
	call	_xmlCtxtReset

; 15519: 
; 15520: 
; 15521:     input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);

	push	0
	push	edi
	call	_xmlParserInputBufferCreateFd
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 15522:     if (input == NULL)

	test	edi, edi
	je	SHORT $LN7@xmlCtxtRea

; 15523:         return (NULL);
; 15524:     input->closecallback = NULL;
; 15525:     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);

	push	0
	push	edi
	push	esi
	mov	DWORD PTR [edi+8], 0
	call	_xmlNewIOInputStream
	add	esp, 12					; 0000000cH

; 15526:     if (stream == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlCtxtRea

; 15527:         xmlFreeParserInputBuffer(input);

	push	edi
	call	_xmlFreeParserInputBuffer
	add	esp, 4
$LN7@xmlCtxtRea:

; 15532: }

	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN5@xmlCtxtRea:

; 15528:         return (NULL);
; 15529:     }
; 15530:     inputPush(ctxt, stream);

	push	eax
	push	esi
	call	_inputPush

; 15531:     return (xmlDoRead(ctxt, URL, encoding, options, 1));

	push	1
	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _encoding$[ebp]
	push	DWORD PTR _URL$[ebp]
	push	esi
	call	_xmlDoRead
	add	esp, 28					; 0000001cH
	pop	edi

; 15532: }

	pop	esi
	pop	ebp
	ret	0
_xmlCtxtReadFd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtReadMemory
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_URL$ = 20						; size = 4
_encoding$ = 24						; size = 4
_options$ = 28						; size = 4
_xmlCtxtReadMemory PROC					; COMDAT

; 15463: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN7@xmlCtxtRea

; 15464:     xmlParserInputBufferPtr input;
; 15465:     xmlParserInputPtr stream;
; 15466: 
; 15467:     if (ctxt == NULL)
; 15468:         return (NULL);
; 15469:     if (buffer == NULL)

	mov	edi, DWORD PTR _buffer$[ebp]
	test	edi, edi
	je	SHORT $LN7@xmlCtxtRea

; 15470:         return (NULL);
; 15471:     xmlInitParser();

	call	_xmlInitParser

; 15472: 
; 15473:     xmlCtxtReset(ctxt);

	push	esi
	call	_xmlCtxtReset

; 15474: 
; 15475:     input = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);

	push	0
	push	DWORD PTR _size$[ebp]
	push	edi
	call	_xmlParserInputBufferCreateMem
	mov	edi, eax
	add	esp, 16					; 00000010H

; 15476:     if (input == NULL) {

	test	edi, edi
	je	SHORT $LN7@xmlCtxtRea

; 15477: 	return(NULL);
; 15478:     }
; 15479: 
; 15480:     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);

	push	0
	push	edi
	push	esi
	call	_xmlNewIOInputStream
	add	esp, 12					; 0000000cH

; 15481:     if (stream == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlCtxtRea

; 15482: 	xmlFreeParserInputBuffer(input);

	push	edi
	call	_xmlFreeParserInputBuffer
	add	esp, 4
$LN7@xmlCtxtRea:

; 15488: }

	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN5@xmlCtxtRea:

; 15483: 	return(NULL);
; 15484:     }
; 15485: 
; 15486:     inputPush(ctxt, stream);

	push	eax
	push	esi
	call	_inputPush

; 15487:     return (xmlDoRead(ctxt, URL, encoding, options, 1));

	push	1
	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _encoding$[ebp]
	push	DWORD PTR _URL$[ebp]
	push	esi
	call	_xmlDoRead
	add	esp, 28					; 0000001cH
	pop	edi

; 15488: }

	pop	esi
	pop	ebp
	ret	0
_xmlCtxtReadMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtReadFile
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_filename$ = 12						; size = 4
_encoding$ = 16						; size = 4
_options$ = 20						; size = 4
_xmlCtxtReadFile PROC					; COMDAT

; 15427: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _filename$[ebp]
	test	edi, edi
	je	$LN16@xmlCtxtRea

; 15428:     xmlParserInputPtr stream;
; 15429: 
; 15430:     if (filename == NULL)
; 15431:         return (NULL);
; 15432:     if (ctxt == NULL)

	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN16@xmlCtxtRea

; 15433:         return (NULL);
; 15434:     xmlInitParser();

	call	_xmlInitParser

; 15435: 
; 15436:     xmlCtxtReset(ctxt);

	push	esi
	call	_xmlCtxtReset

; 15437: 
; 15438:     stream = xmlLoadExternalEntity(filename, NULL, ctxt);

	push	esi
	push	0
	push	edi
	call	_xmlLoadExternalEntity
	add	esp, 16					; 00000010H

; 15439:     if (stream == NULL) {

	test	eax, eax
	je	SHORT $LN16@xmlCtxtRea

; 15441:     }
; 15442:     inputPush(ctxt, stream);

	push	eax
	push	esi
	call	_inputPush

; 15187:     xmlCtxtUseOptionsInternal(ctxt, options, encoding);

	mov	edi, DWORD PTR _encoding$[ebp]
	push	edi
	push	DWORD PTR _options$[ebp]
	push	esi
	call	_xmlCtxtUseOptionsInternal
	add	esp, 20					; 00000014H

; 15188:     if (encoding != NULL) {

	test	edi, edi
	je	SHORT $LN8@xmlCtxtRea

; 15189:         xmlCharEncodingHandlerPtr hdlr;
; 15190: 
; 15191: 	hdlr = xmlFindCharEncodingHandler(encoding);

	push	edi
	call	_xmlFindCharEncodingHandler
	add	esp, 4

; 15192: 	if (hdlr != NULL)

	test	eax, eax
	je	SHORT $LN8@xmlCtxtRea

; 15193: 	    xmlSwitchToEncoding(ctxt, hdlr);

	push	eax
	push	esi
	call	_xmlSwitchToEncoding
	add	esp, 8
$LN8@xmlCtxtRea:

; 15194:     }
; 15195:     if ((URL != NULL) && (ctxt->input != NULL) &&
; 15196:         (ctxt->input->filename == NULL))
; 15197:         ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);
; 15198:     xmlParseDocument(ctxt);

	push	esi
	call	_xmlParseDocument
	add	esp, 4

; 15199:     if ((ctxt->wellFormed) || ctxt->recovery)

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN12@xmlCtxtRea
	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN12@xmlCtxtRea

; 15201:     else {
; 15202:         ret = NULL;
; 15203: 	if (ctxt->myDoc != NULL) {

	mov	eax, DWORD PTR [esi+8]
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN13@xmlCtxtRea

; 15204: 	    xmlFreeDoc(ctxt->myDoc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 15205: 	}
; 15206:     }
; 15207:     ctxt->myDoc = NULL;

	mov	DWORD PTR [esi+8], edi

; 15443:     return (xmlDoRead(ctxt, NULL, encoding, options, 1));

	mov	eax, edi
	pop	edi

; 15444: }

	pop	esi
	pop	ebp
	ret	0
$LN12@xmlCtxtRea:

; 15200:         ret = ctxt->myDoc;

	mov	edi, DWORD PTR [esi+8]
$LN13@xmlCtxtRea:

; 15443:     return (xmlDoRead(ctxt, NULL, encoding, options, 1));

	mov	eax, edi

; 15207:     ctxt->myDoc = NULL;

	mov	DWORD PTR [esi+8], 0
	pop	edi

; 15444: }

	pop	esi
	pop	ebp
	ret	0
$LN16@xmlCtxtRea:
	pop	edi

; 15440:         return (NULL);

	xor	eax, eax

; 15444: }

	pop	esi
	pop	ebp
	ret	0
_xmlCtxtReadFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtReadDoc
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_URL$ = 16						; size = 4
_encoding$ = 20						; size = 4
_options$ = 24						; size = 4
_xmlCtxtReadDoc PROC					; COMDAT

; 15393: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN6@xmlCtxtRea

; 15394:     xmlParserInputPtr stream;
; 15395: 
; 15396:     if (cur == NULL)
; 15397:         return (NULL);
; 15398:     if (ctxt == NULL)

	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN6@xmlCtxtRea

; 15399:         return (NULL);
; 15400:     xmlInitParser();

	call	_xmlInitParser

; 15401: 
; 15402:     xmlCtxtReset(ctxt);

	push	esi
	call	_xmlCtxtReset

; 15403: 
; 15404:     stream = xmlNewStringInputStream(ctxt, cur);

	push	DWORD PTR _cur$[ebp]
	push	esi
	call	_xmlNewStringInputStream
	add	esp, 12					; 0000000cH

; 15405:     if (stream == NULL) {

	test	eax, eax
	je	SHORT $LN6@xmlCtxtRea

; 15407:     }
; 15408:     inputPush(ctxt, stream);

	push	eax
	push	esi
	call	_inputPush

; 15409:     return (xmlDoRead(ctxt, URL, encoding, options, 1));

	push	1
	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _encoding$[ebp]
	push	DWORD PTR _URL$[ebp]
	push	esi
	call	_xmlDoRead
	add	esp, 28					; 0000001cH
	pop	esi

; 15410: }

	pop	ebp
	ret	0
$LN6@xmlCtxtRea:

; 15406:         return (NULL);

	xor	eax, eax
	pop	esi

; 15410: }

	pop	ebp
	ret	0
_xmlCtxtReadDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlReadIO
_TEXT	SEGMENT
_ioread$ = 8						; size = 4
_ioclose$ = 12						; size = 4
_ioctx$ = 16						; size = 4
_URL$ = 20						; size = 4
_encoding$ = 24						; size = 4
_options$ = 28						; size = 4
_xmlReadIO PROC						; COMDAT

; 15346: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ioread$[ebp]
	test	edi, edi
	je	SHORT $LN4@xmlReadIO

; 15347:     xmlParserCtxtPtr ctxt;
; 15348:     xmlParserInputBufferPtr input;
; 15349:     xmlParserInputPtr stream;
; 15350: 
; 15351:     if (ioread == NULL)
; 15352:         return (NULL);
; 15353:     xmlInitParser();
; 15354: 
; 15355:     input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,

	call	_xmlInitParser
	mov	esi, DWORD PTR _ioclose$[ebp]
	push	0
	push	DWORD PTR _ioctx$[ebp]
	push	esi
	push	edi
	call	_xmlParserInputBufferCreateIO
	mov	edi, eax
	add	esp, 16					; 00000010H

; 15356:                                          XML_CHAR_ENCODING_NONE);
; 15357:     if (input == NULL) {

	test	edi, edi
	jne	SHORT $LN3@xmlReadIO

; 15358:         if (ioclose != NULL)

	test	esi, esi
	je	SHORT $LN4@xmlReadIO

; 15359:             ioclose(ioctx);

	push	DWORD PTR _ioctx$[ebp]
	call	esi

; 15375: }

	add	esp, 4
$LN4@xmlReadIO:
	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlReadIO:

; 15360:         return (NULL);
; 15361:     }
; 15362:     ctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	esi, eax

; 15363:     if (ctxt == NULL) {

	test	esi, esi
	jne	SHORT $LN5@xmlReadIO

; 15364:         xmlFreeParserInputBuffer(input);

	push	edi
	call	_xmlFreeParserInputBuffer

; 15375: }

	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN5@xmlReadIO:

; 15365:         return (NULL);
; 15366:     }
; 15367:     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);

	push	0
	push	edi
	push	esi
	call	_xmlNewIOInputStream
	add	esp, 12					; 0000000cH

; 15368:     if (stream == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlReadIO

; 15369:         xmlFreeParserInputBuffer(input);

	push	edi
	call	_xmlFreeParserInputBuffer

; 15370: 	xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 8

; 15375: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN6@xmlReadIO:

; 15371:         return (NULL);
; 15372:     }
; 15373:     inputPush(ctxt, stream);

	push	eax
	push	esi
	call	_inputPush

; 15374:     return (xmlDoRead(ctxt, URL, encoding, options, 0));

	push	0
	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _encoding$[ebp]
	push	DWORD PTR _URL$[ebp]
	push	esi
	call	_xmlDoRead
	add	esp, 28					; 0000001cH
	pop	edi

; 15375: }

	pop	esi
	pop	ebp
	ret	0
_xmlReadIO ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlReadFd
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_URL$ = 12						; size = 4
_encoding$ = 16						; size = 4
_options$ = 20						; size = 4
_xmlReadFd PROC						; COMDAT

; 15302: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _fd$[ebp]
	test	esi, esi
	js	SHORT $LN7@xmlReadFd

; 15303:     xmlParserCtxtPtr ctxt;
; 15304:     xmlParserInputBufferPtr input;
; 15305:     xmlParserInputPtr stream;
; 15306: 
; 15307:     if (fd < 0)
; 15308:         return (NULL);
; 15309:     xmlInitParser();
; 15310: 
; 15311:     input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);

	call	_xmlInitParser
	push	0
	push	esi
	call	_xmlParserInputBufferCreateFd
	mov	esi, eax
	add	esp, 8

; 15312:     if (input == NULL)

	test	esi, esi
	je	SHORT $LN7@xmlReadFd

; 15314:     input->closecallback = NULL;

	push	edi
	mov	DWORD PTR [esi+8], 0

; 15315:     ctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	edi, eax

; 15316:     if (ctxt == NULL) {

	test	edi, edi
	jne	SHORT $LN4@xmlReadFd

; 15317:         xmlFreeParserInputBuffer(input);

	push	esi
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 15318:         return (NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 15328: }

	pop	ebp
	ret	0
$LN4@xmlReadFd:

; 15319:     }
; 15320:     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);

	push	0
	push	esi
	push	edi
	call	_xmlNewIOInputStream
	add	esp, 12					; 0000000cH

; 15321:     if (stream == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlReadFd

; 15322:         xmlFreeParserInputBuffer(input);

	push	esi
	call	_xmlFreeParserInputBuffer

; 15323: 	xmlFreeParserCtxt(ctxt);

	push	edi
	call	_xmlFreeParserCtxt
	add	esp, 8
	xor	eax, eax
	pop	edi
	pop	esi

; 15328: }

	pop	ebp
	ret	0
$LN5@xmlReadFd:

; 15324:         return (NULL);
; 15325:     }
; 15326:     inputPush(ctxt, stream);

	push	eax
	push	edi
	call	_inputPush

; 15327:     return (xmlDoRead(ctxt, URL, encoding, options, 0));

	push	0
	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _encoding$[ebp]
	push	DWORD PTR _URL$[ebp]
	push	edi
	call	_xmlDoRead
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi

; 15328: }

	pop	ebp
	ret	0
$LN7@xmlReadFd:

; 15313:         return (NULL);

	xor	eax, eax
	pop	esi

; 15328: }

	pop	ebp
	ret	0
_xmlReadFd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlReadMemory
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_URL$ = 16						; size = 4
_encoding$ = 20						; size = 4
_options$ = 24						; size = 4
_xmlReadMemory PROC					; COMDAT

; 15277: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlInitParser
	push	DWORD PTR _size$[ebp]
	push	DWORD PTR _buffer$[ebp]
	call	_xmlCreateMemoryParserCtxt
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@xmlReadMem

; 15285: }

	pop	ebp
	ret	0
$LN2@xmlReadMem:

; 15278:     xmlParserCtxtPtr ctxt;
; 15279: 
; 15280:     xmlInitParser();
; 15281:     ctxt = xmlCreateMemoryParserCtxt(buffer, size);
; 15282:     if (ctxt == NULL)
; 15283:         return (NULL);
; 15284:     return (xmlDoRead(ctxt, URL, encoding, options, 0));

	push	0
	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _encoding$[ebp]
	push	DWORD PTR _URL$[ebp]
	push	eax
	call	_xmlDoRead
	add	esp, 20					; 00000014H

; 15285: }

	pop	ebp
	ret	0
_xmlReadMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlReadFile
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_encoding$ = 12						; size = 4
_options$ = 16						; size = 4
_xmlReadFile PROC					; COMDAT

; 15253: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlInitParser
	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _filename$[ebp]
	call	_xmlCreateURLParserCtxt
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	SHORT $LN2@xmlReadFil
	pop	esi

; 15261: }

	pop	ebp
	ret	0
$LN2@xmlReadFil:
	push	edi

; 15187:     xmlCtxtUseOptionsInternal(ctxt, options, encoding);

	mov	edi, DWORD PTR _encoding$[ebp]
	push	edi
	push	DWORD PTR _options$[ebp]
	push	esi
	call	_xmlCtxtUseOptionsInternal
	add	esp, 12					; 0000000cH

; 15188:     if (encoding != NULL) {

	test	edi, edi
	je	SHORT $LN6@xmlReadFil

; 15189:         xmlCharEncodingHandlerPtr hdlr;
; 15190: 
; 15191: 	hdlr = xmlFindCharEncodingHandler(encoding);

	push	edi
	call	_xmlFindCharEncodingHandler
	add	esp, 4

; 15192: 	if (hdlr != NULL)

	test	eax, eax
	je	SHORT $LN6@xmlReadFil

; 15193: 	    xmlSwitchToEncoding(ctxt, hdlr);

	push	eax
	push	esi
	call	_xmlSwitchToEncoding
	add	esp, 8
$LN6@xmlReadFil:

; 15194:     }
; 15195:     if ((URL != NULL) && (ctxt->input != NULL) &&
; 15196:         (ctxt->input->filename == NULL))
; 15197:         ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);
; 15198:     xmlParseDocument(ctxt);

	push	esi
	call	_xmlParseDocument
	add	esp, 4

; 15199:     if ((ctxt->wellFormed) || ctxt->recovery)

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN10@xmlReadFil
	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN10@xmlReadFil

; 15201:     else {
; 15202:         ret = NULL;
; 15203: 	if (ctxt->myDoc != NULL) {

	mov	eax, DWORD PTR [esi+8]
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN11@xmlReadFil

; 15204: 	    xmlFreeDoc(ctxt->myDoc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
	jmp	SHORT $LN11@xmlReadFil
$LN10@xmlReadFil:

; 15200:         ret = ctxt->myDoc;

	mov	edi, DWORD PTR [esi+8]
$LN11@xmlReadFil:

; 15205: 	}
; 15206:     }
; 15207:     ctxt->myDoc = NULL;
; 15208:     if (!reuse) {
; 15209: 	xmlFreeParserCtxt(ctxt);

	push	esi
	mov	DWORD PTR [esi+8], 0
	call	_xmlFreeParserCtxt
	add	esp, 4

; 15254:     xmlParserCtxtPtr ctxt;
; 15255: 
; 15256:     xmlInitParser();
; 15257:     ctxt = xmlCreateURLParserCtxt(filename, options);
; 15258:     if (ctxt == NULL)
; 15259:         return (NULL);
; 15260:     return (xmlDoRead(ctxt, NULL, encoding, options, 0));

	mov	eax, edi
	pop	edi
	pop	esi

; 15261: }

	pop	ebp
	ret	0
_xmlReadFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlReadDoc
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_URL$ = 12						; size = 4
_encoding$ = 16						; size = 4
_options$ = 20						; size = 4
_xmlReadDoc PROC					; COMDAT

; 15228: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN8@xmlReadDoc

; 15229:     xmlParserCtxtPtr ctxt;
; 15230: 
; 15231:     if (cur == NULL)
; 15232:         return (NULL);
; 15233:     xmlInitParser();

	call	_xmlInitParser

; 14579:     len = xmlStrlen(cur);

	push	esi
	call	_xmlStrlen

; 14580:     return(xmlCreateMemoryParserCtxt((const char *)cur, len));

	push	eax
	push	esi
	call	_xmlCreateMemoryParserCtxt
	add	esp, 12					; 0000000cH

; 15234: 
; 15235:     ctxt = xmlCreateDocParserCtxt(cur);
; 15236:     if (ctxt == NULL)

	test	eax, eax
	je	SHORT $LN8@xmlReadDoc

; 15238:     return (xmlDoRead(ctxt, URL, encoding, options, 0));

	push	0
	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _encoding$[ebp]
	push	DWORD PTR _URL$[ebp]
	push	eax
	call	_xmlDoRead
	add	esp, 20					; 00000014H
	pop	esi

; 15239: }

	pop	ebp
	ret	0
$LN8@xmlReadDoc:

; 15237:         return (NULL);

	xor	eax, eax
	pop	esi

; 15239: }

	pop	ebp
	ret	0
_xmlReadDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtUseOptions
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_options$ = 12						; size = 4
_xmlCtxtUseOptions PROC					; COMDAT

; 15165: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlCtxtUseOptionsInternal
	add	esp, 12					; 0000000cH

; 15166:    return(xmlCtxtUseOptionsInternal(ctxt, options, NULL));
; 15167: }

	pop	ebp
	ret	0
_xmlCtxtUseOptions ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtResetPush
_TEXT	SEGMENT
_enc$1$ = -4						; size = 4
_inputStream$1$ = 8					; size = 4
_ctxt$ = 8						; size = 4
_chunk$ = 12						; size = 4
_size$ = 16						; size = 4
_filename$ = 20						; size = 4
_encoding$ = 24						; size = 4
_xmlCtxtResetPush PROC					; COMDAT

; 14922: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	mov	DWORD PTR _enc$1$[ebp], eax
	test	ebx, ebx
	je	SHORT $LN21@xmlCtxtRes

; 14923:     xmlParserInputPtr inputStream;
; 14924:     xmlParserInputBufferPtr buf;
; 14925:     xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
; 14926: 
; 14927:     if (ctxt == NULL)
; 14928:         return(1);
; 14929: 
; 14930:     if ((encoding == NULL) && (chunk != NULL) && (size >= 4))

	mov	esi, DWORD PTR _encoding$[ebp]
	mov	edx, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _chunk$[ebp]
	test	esi, esi
	jne	SHORT $LN3@xmlCtxtRes
	test	ecx, ecx
	je	SHORT $LN3@xmlCtxtRes
	cmp	edx, 4
	jl	SHORT $LN3@xmlCtxtRes

; 14931:         enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);

	push	edx
	push	ecx
	call	_xmlDetectCharEncoding
	add	esp, 8
	mov	DWORD PTR _enc$1$[ebp], eax
$LN3@xmlCtxtRes:

; 14932: 
; 14933:     buf = xmlAllocParserInputBuffer(enc);

	push	eax
	call	_xmlAllocParserInputBuffer
	mov	edi, eax
	add	esp, 4

; 14934:     if (buf == NULL)

	test	edi, edi
	je	SHORT $LN21@xmlCtxtRes

; 14935:         return(1);
; 14936: 
; 14937:     if (ctxt == NULL) {
; 14938:         xmlFreeParserInputBuffer(buf);
; 14939:         return(1);
; 14940:     }
; 14941: 
; 14942:     xmlCtxtReset(ctxt);

	push	ebx
	call	_xmlCtxtReset
	add	esp, 4

; 14943: 
; 14944:     if (ctxt->pushTab == NULL) {

	cmp	DWORD PTR [ebx+344], 0
	jne	SHORT $LN7@xmlCtxtRes

; 14945:         ctxt->pushTab = (void **) xmlMalloc(ctxt->nameMax * 3 *

	mov	eax, DWORD PTR [ebx+192]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [ebx+344], eax

; 14946: 	                                    sizeof(xmlChar *));
; 14947:         if (ctxt->pushTab == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlCtxtRes

; 14948: 	    xmlErrMemory(ctxt, NULL);

	push	eax
	push	ebx
	call	_xmlErrMemory

; 14949:             xmlFreeParserInputBuffer(buf);

	push	edi
	call	_xmlFreeParserInputBuffer
	add	esp, 12					; 0000000cH
$LN21@xmlCtxtRes:

; 15008: }

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlCtxtRes:

; 14950:             return(1);
; 14951:         }
; 14952:     }
; 14953: 
; 14954:     if (filename == NULL) {

	mov	eax, DWORD PTR _filename$[ebp]
	test	eax, eax
	je	SHORT $LN9@xmlCtxtRes
$LN8@xmlCtxtRes:

; 14955:         ctxt->directory = NULL;
; 14956:     } else {
; 14957:         ctxt->directory = xmlParserGetDirectory(filename);

	push	eax
	call	_xmlParserGetDirectory
	add	esp, 4
$LN9@xmlCtxtRes:

; 14958:     }
; 14959: 
; 14960:     inputStream = xmlNewInputStream(ctxt);

	push	ebx
	mov	DWORD PTR [ebx+180], eax
	call	_xmlNewInputStream
	add	esp, 4
	mov	DWORD PTR _inputStream$1$[ebp], eax

; 14961:     if (inputStream == NULL) {

	test	eax, eax
	jne	SHORT $LN10@xmlCtxtRes

; 14962:         xmlFreeParserInputBuffer(buf);

	push	edi
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 15008: }

	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlCtxtRes:

; 14963:         return(1);
; 14964:     }
; 14965: 
; 14966:     if (filename == NULL)

	mov	ecx, DWORD PTR _filename$[ebp]
	test	ecx, ecx
	je	SHORT $LN12@xmlCtxtRes
$LN11@xmlCtxtRes:

; 14967:         inputStream->filename = NULL;
; 14968:     else
; 14969:         inputStream->filename = (char *)

	push	ecx
	call	_xmlCanonicPath
	mov	ecx, eax
	add	esp, 4
	mov	eax, DWORD PTR _inputStream$1$[ebp]
$LN12@xmlCtxtRes:

; 14970:             xmlCanonicPath((const xmlChar *) filename);
; 14971:     inputStream->buf = buf;

	mov	DWORD PTR [eax+4], ecx

; 14972:     xmlBufResetInput(buf->buffer, inputStream);

	push	eax
	mov	DWORD PTR [eax], edi
	push	DWORD PTR [edi+16]
	call	_xmlBufResetInput

; 14973: 
; 14974:     inputPush(ctxt, inputStream);

	push	DWORD PTR _inputStream$1$[ebp]
	push	ebx
	call	_inputPush
	add	esp, 16					; 00000010H

; 14975: 
; 14976:     if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&

	cmp	DWORD PTR _size$[ebp], 0
	jle	SHORT $LN13@xmlCtxtRes
	cmp	DWORD PTR _chunk$[ebp], 0
	je	SHORT $LN13@xmlCtxtRes
	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	je	SHORT $LN13@xmlCtxtRes
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN13@xmlCtxtRes

; 14977:         (ctxt->input->buf != NULL)) {
; 14978: 	size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);

	push	eax
	push	DWORD PTR [ecx+16]
	call	_xmlBufGetInputBase

; 14979:         size_t cur = ctxt->input->cur - ctxt->input->base;

	mov	ecx, DWORD PTR [ebx+36]
	mov	edi, eax

; 14980: 
; 14981:         xmlParserInputBufferPush(ctxt->input->buf, size, chunk);

	push	DWORD PTR _chunk$[ebp]
	push	DWORD PTR _size$[ebp]
	mov	esi, DWORD PTR [ecx+16]
	push	DWORD PTR [ecx]
	sub	esi, DWORD PTR [ecx+12]
	call	_xmlParserInputBufferPush

; 14982: 
; 14983:         xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);

	mov	eax, DWORD PTR [ebx+36]
	push	esi
	push	edi
	push	eax
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+16]
	call	_xmlBufSetInputBaseCur
	mov	esi, DWORD PTR _encoding$[ebp]
	add	esp, 36					; 00000024H
$LN13@xmlCtxtRes:

; 14984: #ifdef DEBUG_PUSH
; 14985:         xmlGenericError(xmlGenericErrorContext, "PP: pushed %d\n", size);
; 14986: #endif
; 14987:     }
; 14988: 
; 14989:     if (encoding != NULL) {

	test	esi, esi
	je	SHORT $LN14@xmlCtxtRes

; 14990:         xmlCharEncodingHandlerPtr hdlr;
; 14991: 
; 14992:         if (ctxt->encoding != NULL)

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN16@xmlCtxtRes

; 14993: 	    xmlFree((xmlChar *) ctxt->encoding);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlCtxtRes:

; 14994:         ctxt->encoding = xmlStrdup((const xmlChar *) encoding);

	push	esi
	call	_xmlStrdup

; 14995: 
; 14996:         hdlr = xmlFindCharEncodingHandler(encoding);

	push	esi
	mov	DWORD PTR [ebx+24], eax
	call	_xmlFindCharEncodingHandler
	add	esp, 8

; 14997:         if (hdlr != NULL) {

	test	eax, eax
	je	SHORT $LN17@xmlCtxtRes

; 14998:             xmlSwitchToEncoding(ctxt, hdlr);

	push	eax
	push	ebx
	call	_xmlSwitchToEncoding

; 15005:     }
; 15006: 
; 15007:     return(0);

	add	esp, 8
	xor	eax, eax
	pop	edi

; 15008: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlCtxtRes:

; 14999: 	} else {
; 15000: 	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	esi
	push	OFFSET ??_C@_0BJ@FCHADMKI@Unsupported?5encoding?5?$CFs?6@
	push	32					; 00000020H
	push	ebx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 15005:     }
; 15006: 
; 15007:     return(0);

	xor	eax, eax
	pop	edi

; 15008: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlCtxtRes:

; 15001: 			      "Unsupported encoding %s\n", BAD_CAST encoding);
; 15002:         }
; 15003:     } else if (enc != XML_CHAR_ENCODING_NONE) {

	mov	eax, DWORD PTR _enc$1$[ebp]
	test	eax, eax
	je	SHORT $LN19@xmlCtxtRes

; 15004:         xmlSwitchEncoding(ctxt, enc);

	push	eax
	push	ebx
	call	_xmlSwitchEncoding

; 15005:     }
; 15006: 
; 15007:     return(0);

	add	esp, 8
$LN19@xmlCtxtRes:

; 15008: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCtxtResetPush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtReset
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlCtxtReset PROC					; COMDAT

; 14816: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN21@xmlCtxtRes

; 14817:     xmlParserInputPtr input;
; 14818:     xmlDictPtr dict;
; 14819: 
; 14820:     if (ctxt == NULL)
; 14821:         return;
; 14822: 
; 14823:     dict = ctxt->dict;

	push	edi
	mov	edi, DWORD PTR [esi+296]
$LL2@xmlCtxtRes:

; 1748 :     if (ctxt->inputNr <= 0)

	mov	ecx, DWORD PTR [esi+40]
	test	ecx, ecx
	jle	SHORT $LN32@xmlCtxtRes

; 1749 :         return (NULL);
; 1750 :     ctxt->inputNr--;

	dec	ecx
	mov	DWORD PTR [esi+40], ecx

; 1751 :     if (ctxt->inputNr > 0)

	test	ecx, ecx
	jle	SHORT $LN26@xmlCtxtRes

; 1752 :         ctxt->input = ctxt->inputTab[ctxt->inputNr - 1];

	mov	eax, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN27@xmlCtxtRes
$LN26@xmlCtxtRes:

; 1753 :     else
; 1754 :         ctxt->input = NULL;

	xor	eax, eax
$LN27@xmlCtxtRes:

; 1755 :     ret = ctxt->inputTab[ctxt->inputNr];

	mov	DWORD PTR [esi+36], eax
	mov	eax, DWORD PTR [esi+48]
	mov	edx, DWORD PTR [eax+ecx*4]

; 1756 :     ctxt->inputTab[ctxt->inputNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 14824: 
; 14825:     while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */

	test	edx, edx
	je	SHORT $LN32@xmlCtxtRes

; 14826:         xmlFreeInputStream(input);

	push	edx
	call	_xmlFreeInputStream
	add	esp, 4

; 14827:     }

	jmp	SHORT $LL2@xmlCtxtRes
$LN32@xmlCtxtRes:

; 14828:     ctxt->inputNr = 0;
; 14829:     ctxt->input = NULL;
; 14830: 
; 14831:     ctxt->spaceNr = 0;
; 14832:     if (ctxt->spaceTab != NULL) {

	mov	eax, DWORD PTR [esi+244]
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+236], 0
	test	eax, eax
	je	SHORT $LN5@xmlCtxtRes

; 14833: 	ctxt->spaceTab[0] = -1;

	mov	DWORD PTR [eax], -1

; 14834: 	ctxt->space = &ctxt->spaceTab[0];

	mov	eax, DWORD PTR [esi+244]

; 14835:     } else {

	jmp	SHORT $LN6@xmlCtxtRes
$LN5@xmlCtxtRes:

; 14836:         ctxt->space = NULL;

	xor	eax, eax
$LN6@xmlCtxtRes:

; 14837:     }
; 14838: 
; 14839: 
; 14840:     ctxt->nodeNr = 0;

	mov	DWORD PTR [esi+232], eax

; 14841:     ctxt->node = NULL;
; 14842: 
; 14843:     ctxt->nameNr = 0;
; 14844:     ctxt->name = NULL;
; 14845: 
; 14846:     DICT_FREE(ctxt->version);

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+188], 0
	mov	DWORD PTR [esi+184], 0
	test	eax, eax
	je	SHORT $LN7@xmlCtxtRes
	test	edi, edi
	je	SHORT $LN8@xmlCtxtRes
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@xmlCtxtRes
$LN8@xmlCtxtRes:
	push	DWORD PTR [esi+20]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlCtxtRes:

; 14847:     ctxt->version = NULL;
; 14848:     DICT_FREE(ctxt->encoding);

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+20], 0
	test	eax, eax
	je	SHORT $LN9@xmlCtxtRes
	test	edi, edi
	je	SHORT $LN10@xmlCtxtRes
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlCtxtRes
$LN10@xmlCtxtRes:
	push	DWORD PTR [esi+24]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlCtxtRes:

; 14849:     ctxt->encoding = NULL;
; 14850:     DICT_FREE(ctxt->directory);

	mov	eax, DWORD PTR [esi+180]
	mov	DWORD PTR [esi+24], 0
	test	eax, eax
	je	SHORT $LN11@xmlCtxtRes
	test	edi, edi
	je	SHORT $LN12@xmlCtxtRes
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlCtxtRes
$LN12@xmlCtxtRes:
	push	DWORD PTR [esi+180]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlCtxtRes:

; 14851:     ctxt->directory = NULL;
; 14852:     DICT_FREE(ctxt->extSubURI);

	mov	eax, DWORD PTR [esi+224]
	mov	DWORD PTR [esi+180], 0
	test	eax, eax
	je	SHORT $LN13@xmlCtxtRes
	test	edi, edi
	je	SHORT $LN14@xmlCtxtRes
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlCtxtRes
$LN14@xmlCtxtRes:
	push	DWORD PTR [esi+224]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlCtxtRes:

; 14853:     ctxt->extSubURI = NULL;
; 14854:     DICT_FREE(ctxt->extSubSystem);

	mov	eax, DWORD PTR [esi+228]
	mov	DWORD PTR [esi+224], 0
	test	eax, eax
	je	SHORT $LN15@xmlCtxtRes
	test	edi, edi
	je	SHORT $LN16@xmlCtxtRes
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN15@xmlCtxtRes
$LN16@xmlCtxtRes:
	push	DWORD PTR [esi+228]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlCtxtRes:

; 14855:     ctxt->extSubSystem = NULL;
; 14856:     if (ctxt->myDoc != NULL)

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+228], 0
	pop	edi
	test	eax, eax
	je	SHORT $LN17@xmlCtxtRes

; 14857:         xmlFreeDoc(ctxt->myDoc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN17@xmlCtxtRes:

; 14858:     ctxt->myDoc = NULL;
; 14859: 
; 14860:     ctxt->standalone = -1;
; 14861:     ctxt->hasExternalSubset = 0;
; 14862:     ctxt->hasPErefs = 0;
; 14863:     ctxt->html = 0;
; 14864:     ctxt->external = 0;
; 14865:     ctxt->instate = XML_PARSER_START;
; 14866:     ctxt->token = 0;
; 14867: 
; 14868:     ctxt->wellFormed = 1;
; 14869:     ctxt->nsWellFormed = 1;
; 14870:     ctxt->disableSAX = 0;
; 14871:     ctxt->valid = 1;
; 14872: #if 0
; 14873:     ctxt->vctxt.userData = ctxt;
; 14874:     ctxt->vctxt.error = xmlParserValidityError;
; 14875:     ctxt->vctxt.warning = xmlParserValidityWarning;
; 14876: #endif
; 14877:     ctxt->record_info = 0;
; 14878:     ctxt->nbChars = 0;
; 14879:     ctxt->checkIndex = 0;
; 14880:     ctxt->inSubset = 0;
; 14881:     ctxt->errNo = XML_ERR_OK;
; 14882:     ctxt->depth = 0;
; 14883:     ctxt->charset = XML_CHAR_ENCODING_UTF8;
; 14884:     ctxt->catalogs = NULL;
; 14885:     ctxt->nbentities = 0;
; 14886:     ctxt->sizeentities = 0;
; 14887:     ctxt->sizeentcopy = 0;
; 14888:     xmlInitNodeInfoSeq(&ctxt->node_seq);

	lea	eax, DWORD PTR [esi+72]
	mov	DWORD PTR [esi+8], 0
	push	eax
	mov	DWORD PTR [esi+28], -1
	mov	DWORD PTR [esi+88], 0
	mov	DWORD PTR [esi+92], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+96], 0
	mov	DWORD PTR [esi+172], 0
	mov	DWORD PTR [esi+176], 0
	mov	DWORD PTR [esi+12], 1
	mov	DWORD PTR [esi+356], 1
	mov	DWORD PTR [esi+212], 0
	mov	DWORD PTR [esi+100], 1
	mov	DWORD PTR [esi+68], 0
	mov	DWORD PTR [esi+200], 0
	mov	DWORD PTR [esi+204], 0
	mov	DWORD PTR [esi+216], 0
	mov	DWORD PTR [esi+84], 0
	mov	DWORD PTR [esi+248], 0
	mov	DWORD PTR [esi+256], 1
	mov	DWORD PTR [esi+284], 0
	mov	DWORD PTR [esi+440], 0
	mov	DWORD PTR [esi+444], 0
	mov	DWORD PTR [esi+468], 0
	call	_xmlInitNodeInfoSeq

; 14889: 
; 14890:     if (ctxt->attsDefault != NULL) {

	mov	eax, DWORD PTR [esi+348]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@xmlCtxtRes

; 14891:         xmlHashFree(ctxt->attsDefault, xmlHashDefaultDeallocator);

	push	OFFSET _xmlHashDefaultDeallocator
	push	eax
	call	_xmlHashFree
	add	esp, 8

; 14892:         ctxt->attsDefault = NULL;

	mov	DWORD PTR [esi+348], 0
$LN18@xmlCtxtRes:

; 14893:     }
; 14894:     if (ctxt->attsSpecial != NULL) {

	mov	eax, DWORD PTR [esi+352]
	test	eax, eax
	je	SHORT $LN19@xmlCtxtRes

; 14895:         xmlHashFree(ctxt->attsSpecial, NULL);

	push	0
	push	eax
	call	_xmlHashFree
	add	esp, 8

; 14896:         ctxt->attsSpecial = NULL;

	mov	DWORD PTR [esi+352], 0
$LN19@xmlCtxtRes:

; 14897:     }
; 14898: 
; 14899: #ifdef LIBXML_CATALOG_ENABLED
; 14900:     if (ctxt->catalogs != NULL)

	mov	eax, DWORD PTR [esi+284]
	test	eax, eax
	je	SHORT $LN20@xmlCtxtRes

; 14901: 	xmlCatalogFreeLocal(ctxt->catalogs);

	push	eax
	call	_xmlCatalogFreeLocal
	add	esp, 4
$LN20@xmlCtxtRes:

; 14902: #endif
; 14903:     if (ctxt->lastError.code != XML_ERR_OK)

	cmp	DWORD PTR [esi+388], 0
	je	SHORT $LN21@xmlCtxtRes

; 14904:         xmlResetError(&ctxt->lastError);

	add	esi, 384				; 00000180H
	push	esi
	call	_xmlResetError
	add	esp, 4
$LN21@xmlCtxtRes:
	pop	esi

; 14905: }

	pop	ebp
	ret	0
_xmlCtxtReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCreateIOParserCtxt
_TEXT	SEGMENT
_sax$ = 8						; size = 4
_user_data$ = 12					; size = 4
_buf$1$ = 16						; size = 4
_ioread$ = 16						; size = 4
_ioclose$ = 20						; size = 4
_ioctx$ = 24						; size = 4
_enc$ = 28						; size = 4
_xmlCreateIOParserCtxt PROC				; COMDAT

; 12509: 	void *ioctx, xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ioread$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlCreateI

; 12510:     xmlParserCtxtPtr ctxt;
; 12511:     xmlParserInputPtr inputStream;
; 12512:     xmlParserInputBufferPtr buf;
; 12513: 
; 12514:     if (ioread == NULL) return(NULL);
; 12515: 
; 12516:     buf = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, enc);

	push	DWORD PTR _enc$[ebp]
	mov	edi, DWORD PTR _ioctx$[ebp]
	mov	esi, DWORD PTR _ioclose$[ebp]
	push	edi
	push	esi
	push	eax
	call	_xmlParserInputBufferCreateIO
	add	esp, 16					; 00000010H
	mov	DWORD PTR _buf$1$[ebp], eax

; 12517:     if (buf == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlCreateI

; 12518:         if (ioclose != NULL)

	test	esi, esi
	je	SHORT $LN4@xmlCreateI

; 12519:             ioclose(ioctx);

	push	edi
	call	esi
	add	esp, 4
$LN4@xmlCreateI:

; 12520:         return (NULL);

	pop	edi
	xor	eax, eax

; 12556: }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlCreateI:
	push	ebx

; 12521:     }
; 12522: 
; 12523:     ctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	ebx, eax

; 12524:     if (ctxt == NULL) {

	test	ebx, ebx
	jne	SHORT $LN5@xmlCreateI

; 12525: 	xmlFreeParserInputBuffer(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	_xmlFreeParserInputBuffer

; 12537: 	    return(NULL);

	add	esp, 4
	xor	eax, eax
	pop	ebx
	pop	edi

; 12556: }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlCreateI:

; 12526: 	return(NULL);
; 12527:     }
; 12528:     if (sax != NULL) {

	mov	esi, DWORD PTR _sax$[ebp]
	test	esi, esi
	je	SHORT $LN11@xmlCreateI

; 12529: #ifdef LIBXML_SAX1_ENABLED
; 12530: 	if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)

	mov	edi, DWORD PTR [ebx]
	call	___xmlDefaultSAXHandler
	cmp	edi, eax
	je	SHORT $LN7@xmlCreateI

; 12531: #endif /* LIBXML_SAX1_ENABLED */
; 12532: 	    xmlFree(ctxt->sax);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlCreateI:

; 12533: 	ctxt->sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));

	push	128					; 00000080H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [ebx], eax

; 12534: 	if (ctxt->sax == NULL) {

	test	eax, eax
	jne	SHORT $LN8@xmlCreateI

; 12535: 	    xmlErrMemory(ctxt, NULL);

	push	eax
	push	ebx
	call	_xmlErrMemory

; 12536: 	    xmlFreeParserCtxt(ctxt);

	push	ebx
	call	_xmlFreeParserCtxt
	add	esp, 12					; 0000000cH

; 12537: 	    return(NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 12556: }

	pop	esi
	pop	ebp
	ret	0
$LN8@xmlCreateI:

; 12538: 	}
; 12539: 	memset(ctxt->sax, 0, sizeof(xmlSAXHandler));

	push	128					; 00000080H
	push	0
	push	eax
	call	_memset

; 12540: 	if (sax->initialized == XML_SAX2_MAGIC)

	mov	edi, DWORD PTR [ebx]
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+108], -554844497		; deedbeafH

; 12541: 	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));

	mov	ecx, 32					; 00000020H
	je	SHORT $LN15@xmlCreateI

; 12542: 	else
; 12543: 	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));

	mov	ecx, 28					; 0000001cH
$LN15@xmlCreateI:

; 12544: 	if (user_data != NULL)

	mov	eax, DWORD PTR _user_data$[ebp]
	rep movsd
	test	eax, eax
	je	SHORT $LN11@xmlCreateI

; 12545: 	    ctxt->userData = user_data;

	mov	DWORD PTR [ebx+4], eax
$LN11@xmlCreateI:

; 12546:     }
; 12547: 
; 12548:     inputStream = xmlNewIOInputStream(ctxt, buf, enc);

	push	DWORD PTR _enc$[ebp]
	push	DWORD PTR _buf$1$[ebp]
	push	ebx
	call	_xmlNewIOInputStream
	add	esp, 12					; 0000000cH

; 12549:     if (inputStream == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlCreateI

; 12550: 	xmlFreeParserCtxt(ctxt);

	push	ebx
	call	_xmlFreeParserCtxt
	add	esp, 4
	xor	eax, eax
	pop	ebx
	pop	edi

; 12556: }

	pop	esi
	pop	ebp
	ret	0
$LN12@xmlCreateI:

; 12551: 	return(NULL);
; 12552:     }
; 12553:     inputPush(ctxt, inputStream);

	push	eax
	push	ebx
	call	_inputPush
	add	esp, 8

; 12554: 
; 12555:     return(ctxt);

	mov	eax, ebx
	pop	ebx
	pop	edi

; 12556: }

	pop	esi
	pop	ebp
	ret	0
_xmlCreateIOParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseChunk
_TEXT	SEGMENT
_end_in_lf$1$ = -12					; size = 4
_old_avail$1$ = -8					; size = 4
_avail$1$ = -4						; size = 4
_base$1$ = 8						; size = 4
_base$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_chunk$ = 12						; size = 4
_size$ = 16						; size = 4
_terminate$ = 20					; size = 4
_xmlParseChunk PROC					; COMDAT

; 12134:               int terminate) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	xor	ebx, ebx
	mov	DWORD PTR _end_in_lf$1$[ebp], 0
	mov	DWORD PTR _old_avail$1$[ebp], eax
	mov	DWORD PTR _avail$1$[ebp], ebx
	test	esi, esi
	jne	SHORT $LN2@xmlParseCh

; 12135:     int end_in_lf = 0;
; 12136:     int remain = 0;
; 12137:     size_t old_avail = 0;
; 12138:     size_t avail = 0;
; 12139: 
; 12140:     if (ctxt == NULL)
; 12141:         return(XML_ERR_INTERNAL_ERROR);

	pop	esi
	lea	eax, DWORD PTR [ebx+1]

; 12310: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlParseCh:

; 12142:     if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))

	mov	eax, DWORD PTR [esi+84]
	test	eax, eax
	je	SHORT $LN3@xmlParseCh
	cmp	DWORD PTR [esi+212], 1
	je	$LN43@xmlParseCh
$LN3@xmlParseCh:

; 12143:         return(ctxt->errNo);
; 12144:     if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR [esi+172]
	cmp	eax, -1
	jne	SHORT $LN4@xmlParseCh

; 12145:         return(-1);

	pop	esi
	or	eax, eax

; 12310: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlParseCh:

; 12146:     if (ctxt->instate == XML_PARSER_START)

	test	eax, eax
	jne	SHORT $LN5@xmlParseCh

; 12147:         xmlDetectSAX2(ctxt);

	push	esi
	call	_xmlDetectSAX2
	add	esp, 4
$LN5@xmlParseCh:

; 12148:     if ((size > 0) && (chunk != NULL) && (!terminate) &&

	mov	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _chunk$[ebp]
	test	eax, eax
	jle	SHORT $LN88@xmlParseCh
	test	ecx, ecx
	je	SHORT $LN88@xmlParseCh
	cmp	DWORD PTR _terminate$[ebp], ebx
	jne	SHORT $LN88@xmlParseCh
	cmp	BYTE PTR [ecx+eax-1], 13		; 0000000dH
	jne	SHORT $LN88@xmlParseCh

; 12149:         (chunk[size - 1] == '\r')) {
; 12150: 	end_in_lf = 1;
; 12151: 	size--;

	dec	eax
	mov	DWORD PTR _end_in_lf$1$[ebp], 1
	mov	DWORD PTR _size$[ebp], eax
$LN88@xmlParseCh:
	push	edi
	npad	3
$xmldecl_done$93:

; 12152:     }
; 12153: 
; 12154: xmldecl_done:
; 12155: 
; 12156:     if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&
; 12157:         (ctxt->input->buf != NULL) && (ctxt->instate != XML_PARSER_EOF))  {

	test	eax, eax
	jle	$LN7@xmlParseCh
	test	ecx, ecx
	je	$LN7@xmlParseCh
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	$LN7@xmlParseCh
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	$LN7@xmlParseCh
	cmp	DWORD PTR [esi+172], -1
	je	$LN7@xmlParseCh

; 12158: 	size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);

	push	eax
	push	DWORD PTR [ecx+16]
	call	_xmlBufGetInputBase
	mov	DWORD PTR _base$1$[ebp], eax

; 12159: 	size_t cur = ctxt->input->cur - ctxt->input->base;

	mov	eax, DWORD PTR [esi+36]
	mov	ebx, DWORD PTR [eax+16]
	sub	ebx, DWORD PTR [eax+12]

; 12160: 	int res;
; 12161: 
; 12162:         old_avail = xmlBufUse(ctxt->input->buf->buffer);

	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+16]
	call	_xmlBufUse

; 12163:         /*
; 12164:          * Specific handling if we autodetected an encoding, we should not
; 12165:          * push more than the first line ... which depend on the encoding
; 12166:          * And only push the rest once the final encoding was detected
; 12167:          */
; 12168:         if ((ctxt->instate == XML_PARSER_START) && (ctxt->input != NULL) &&
; 12169:             (ctxt->input->buf != NULL) && (ctxt->input->buf->encoder != NULL)) {

	xor	edi, edi
	mov	DWORD PTR _old_avail$1$[ebp], eax
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+172], edi
	jne	$LN81@xmlParseCh
	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	je	$LN81@xmlParseCh
	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	$LN81@xmlParseCh
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	$LN81@xmlParseCh

; 12170:             unsigned int len = 45;
; 12171: 
; 12172:             if ((xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,
; 12173:                                BAD_CAST "UTF-16")) ||

	push	OFFSET ??_C@_06KNDPGIKI@UTF?916@
	push	DWORD PTR [eax]
	mov	edi, 45					; 0000002dH
	call	_xmlStrcasestr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlParseCh
	mov	eax, DWORD PTR [esi+36]
	push	OFFSET ??_C@_05MNCHLHCA@UTF16@
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+12]
	push	DWORD PTR [eax]
	call	_xmlStrcasestr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlParseCh

; 12177:             else if ((xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,
; 12178:                                     BAD_CAST "UCS-4")) ||

	mov	eax, DWORD PTR [esi+36]
	push	OFFSET ??_C@_05FPCKGDIJ@UCS?94@
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+12]
	push	DWORD PTR [eax]
	call	_xmlStrcasestr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlParseCh
	mov	eax, DWORD PTR [esi+36]
	push	OFFSET ??_C@_04JFFPNMJE@UCS4@
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+12]
	push	DWORD PTR [eax]
	call	_xmlStrcasestr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlParseCh
$LN14@xmlParseCh:

; 12179:                      (xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,
; 12180:                                     BAD_CAST "UCS4")))
; 12181:                 len = 180;

	mov	edi, 180				; 000000b4H
	jmp	SHORT $LN13@xmlParseCh
$LN12@xmlParseCh:

; 12174:                 (xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,
; 12175:                                BAD_CAST "UTF16")))
; 12176:                 len = 90;

	mov	edi, 90					; 0000005aH
$LN13@xmlParseCh:

; 12182: 
; 12183:             if (ctxt->input->buf->rawconsumed < len)

	mov	eax, DWORD PTR [esi+36]

; 12184:                 len -= ctxt->input->buf->rawconsumed;
; 12185: 
; 12186:             /*
; 12187:              * Change size for reading the initial declaration only
; 12188:              * if size is greater than len. Otherwise, memmove in xmlBufferAdd
; 12189:              * will blindly copy extra bytes from memory.
; 12190:              */
; 12191:             if ((unsigned int) size > len) {

	mov	ecx, edi
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+32]
	sub	ecx, eax
	cmp	eax, edi
	cmovae	ecx, edi
	mov	edi, DWORD PTR _size$[ebp]
	cmp	edi, ecx
	jbe	SHORT $LN16@xmlParseCh

; 12192:                 remain = size - len;

	sub	edi, ecx

; 12193:                 size = len;

	mov	DWORD PTR _size$[ebp], ecx

; 12194:             } else {

	jmp	SHORT $LN17@xmlParseCh
$LN16@xmlParseCh:

; 12195:                 remain = 0;

	xor	edi, edi
$LN81@xmlParseCh:

; 12196:             }
; 12197:         }
; 12198: 	res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);

	mov	ecx, DWORD PTR _size$[ebp]
$LN17@xmlParseCh:
	push	DWORD PTR _chunk$[ebp]
	mov	eax, DWORD PTR [esi+36]
	push	ecx
	push	DWORD PTR [eax]
	call	_xmlParserInputBufferPush
	add	esp, 12					; 0000000cH

; 12199: 	if (res < 0) {

	test	eax, eax
	js	$LN63@xmlParseCh

; 12203: 	}
; 12204:         xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);

	mov	eax, DWORD PTR [esi+36]
	push	ebx
	push	DWORD PTR _base$1$[ebp]
	push	eax
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+16]
	call	_xmlBufSetInputBaseCur
	add	esp, 16					; 00000010H

; 12227: 	    }
; 12228: 	}
; 12229:     }
; 12230:     if (remain != 0) {

	test	edi, edi
	je	SHORT $LN87@xmlParseCh

; 12231:         xmlParseTryOrFinish(ctxt, 0);

	push	0

; 12232:     } else {

	jmp	$LN90@xmlParseCh
$LN7@xmlParseCh:

; 12205: #ifdef DEBUG_PUSH
; 12206: 	xmlGenericError(xmlGenericErrorContext, "PP: pushed %d\n", size);
; 12207: #endif
; 12208: 
; 12209:     } else if (ctxt->instate != XML_PARSER_EOF) {

	xor	edi, edi
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN23@xmlParseCh

; 12210: 	if ((ctxt->input != NULL) && ctxt->input->buf != NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN23@xmlParseCh
	mov	ebx, DWORD PTR [eax]
	test	ebx, ebx
	je	SHORT $LN87@xmlParseCh

; 12211: 	    xmlParserInputBufferPtr in = ctxt->input->buf;
; 12212: 	    if ((in->encoder != NULL) && (in->buffer != NULL) &&

	cmp	DWORD PTR [ebx+12], edi
	je	SHORT $LN87@xmlParseCh
	mov	ecx, DWORD PTR [ebx+16]
	test	ecx, ecx
	je	SHORT $LN87@xmlParseCh
	cmp	DWORD PTR [ebx+20], edi
	je	SHORT $LN87@xmlParseCh

; 12213: 		    (in->raw != NULL)) {
; 12214: 		int nbchars;
; 12215: 		size_t base = xmlBufGetInputBase(in->buffer, ctxt->input);

	push	eax
	push	ecx
	call	_xmlBufGetInputBase

; 12216: 		size_t current = ctxt->input->cur - ctxt->input->base;

	mov	ecx, DWORD PTR [esi+36]

; 12217: 
; 12218: 		nbchars = xmlCharEncInput(in, terminate);

	push	DWORD PTR _terminate$[ebp]
	mov	DWORD PTR _base$1$[ebp], eax
	push	ebx
	mov	edi, DWORD PTR [ecx+16]
	sub	edi, DWORD PTR [ecx+12]
	call	_xmlCharEncInput
	add	esp, 16					; 00000010H

; 12219: 		if (nbchars < 0) {

	test	eax, eax
	js	$LN64@xmlParseCh

; 12225: 		}
; 12226: 		xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);

	push	edi
	push	DWORD PTR _base$1$[ebp]
	push	DWORD PTR [esi+36]
	push	DWORD PTR [ebx+16]
	call	_xmlBufSetInputBaseCur
	add	esp, 16					; 00000010H
	xor	edi, edi
$LN87@xmlParseCh:

; 12233:         if ((ctxt->input != NULL) && (ctxt->input->buf != NULL))

	mov	ebx, DWORD PTR _avail$1$[ebp]
$LN23@xmlParseCh:
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN25@xmlParseCh
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN25@xmlParseCh

; 12234:             avail = xmlBufUse(ctxt->input->buf->buffer);

	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _avail$1$[ebp], ebx
$LN25@xmlParseCh:

; 12235:         /*
; 12236:          * Depending on the current state it may not be such
; 12237:          * a good idea to try parsing if there is nothing in the chunk
; 12238:          * which would be worth doing a parser state transition and we
; 12239:          * need to wait for more data
; 12240:          */
; 12241:         if ((terminate) || (avail > XML_MAX_TEXT_LENGTH) ||
; 12242:             (old_avail == 0) || (avail == 0) ||

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN47@xmlParseCh
	cmp	ebx, 10000000				; 00989680H
	ja	SHORT $LN47@xmlParseCh
	mov	edx, DWORD PTR _old_avail$1$[ebp]
	test	edx, edx
	je	SHORT $LN47@xmlParseCh
	test	ebx, ebx
	je	SHORT $LN47@xmlParseCh
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, ebx
	sub	ecx, edx
	mov	eax, DWORD PTR [eax+12]
	add	eax, edx

; 12085:     if ((ctxt == NULL) || (chunk == NULL) || (size < 0))

	je	SHORT $LN47@xmlParseCh
	test	ecx, ecx
	js	SHORT $LN47@xmlParseCh

; 12086:         return(-1);
; 12087:     if (ctxt->instate == XML_PARSER_START_TAG) {

	mov	edx, DWORD PTR [esi+172]
	cmp	edx, 6
	je	SHORT $LN59@xmlParseCh

; 12088:         if (memchr(chunk, '>', size) != NULL)
; 12089:             return(1);
; 12090:         return(0);
; 12091:     }
; 12092:     if (ctxt->progressive == XML_PARSER_COMMENT) {

	mov	ebx, DWORD PTR [esi+292]
	cmp	ebx, 5
	je	SHORT $LN59@xmlParseCh

; 12093:         if (memchr(chunk, '>', size) != NULL)
; 12094:             return(1);
; 12095:         return(0);
; 12096:     }
; 12097:     if (ctxt->instate == XML_PARSER_CDATA_SECTION) {

	cmp	edx, 8
	je	SHORT $LN59@xmlParseCh

; 12098:         if (memchr(chunk, '>', size) != NULL)
; 12099:             return(1);
; 12100:         return(0);
; 12101:     }
; 12102:     if (ctxt->progressive == XML_PARSER_PI) {

	cmp	ebx, 2
	je	SHORT $LN59@xmlParseCh

; 12103:         if (memchr(chunk, '>', size) != NULL)
; 12104:             return(1);
; 12105:         return(0);
; 12106:     }
; 12107:     if (ctxt->instate == XML_PARSER_END_TAG) {

	cmp	edx, 9
	je	SHORT $LN59@xmlParseCh

; 12108:         if (memchr(chunk, '>', size) != NULL)
; 12109:             return(1);
; 12110:         return(0);
; 12111:     }
; 12112:     if ((ctxt->progressive == XML_PARSER_DTD) ||

	cmp	ebx, 3
	je	SHORT $LN59@xmlParseCh
	cmp	edx, 3
	jne	SHORT $LN47@xmlParseCh
$LN59@xmlParseCh:

; 12243:             (xmlParseCheckTransition(ctxt,
; 12244:                        (const char *)&ctxt->input->base[old_avail],
; 12245:                                      avail - old_avail)))
; 12246:             xmlParseTryOrFinish(ctxt, terminate);

	push	ecx
	push	62					; 0000003eH
	push	eax
	call	_memchr
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN26@xmlParseCh
$LN47@xmlParseCh:
	push	DWORD PTR _terminate$[ebp]
$LN90@xmlParseCh:

; 12247:     }
; 12248:     if (ctxt->instate == XML_PARSER_EOF)

	push	esi
	call	_xmlParseTryOrFinish
	add	esp, 8
$LN26@xmlParseCh:
	cmp	DWORD PTR [esi+172], -1
	je	$LN65@xmlParseCh

; 12250: 
; 12251:     if ((ctxt->input != NULL) &&
; 12252:          (((ctxt->input->end - ctxt->input->cur) > XML_MAX_LOOKUP_LIMIT) ||
; 12253:          ((ctxt->input->cur - ctxt->input->base) > XML_MAX_LOOKUP_LIMIT)) &&

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	je	SHORT $LN29@xmlParseCh
	mov	eax, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [ecx+16]
	sub	eax, edx
	cmp	eax, 10000000				; 00989680H
	jg	SHORT $LN30@xmlParseCh
	sub	edx, DWORD PTR [ecx+12]
	cmp	edx, 10000000				; 00989680H
	jle	SHORT $LN29@xmlParseCh
$LN30@xmlParseCh:
	test	DWORD PTR [esi+360], 524288		; 00080000H
	jne	SHORT $LN29@xmlParseCh

; 12254:         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 12255:         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "Huge input lookup");

	push	OFFSET ??_C@_0BC@BAMNGBKO@Huge?5input?5lookup@
	push	1
	push	esi
	call	_xmlFatalErr

; 12256:         xmlHaltParser(ctxt);

	push	esi
	call	_xmlHaltParser
	add	esp, 16					; 00000010H
$LN29@xmlParseCh:

; 12257:     }
; 12258:     if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))

	mov	eax, DWORD PTR [esi+84]
	test	eax, eax
	je	SHORT $LN31@xmlParseCh
	cmp	DWORD PTR [esi+212], 1
	je	$LN89@xmlParseCh
$LN31@xmlParseCh:

; 12259:         return(ctxt->errNo);
; 12260: 
; 12261:     if (remain != 0) {

	test	edi, edi
	je	SHORT $LN32@xmlParseCh

; 12262:         chunk += size;

	mov	ecx, DWORD PTR _chunk$[ebp]

; 12263:         size = remain;

	mov	eax, edi
	add	ecx, DWORD PTR _size$[ebp]

; 12264:         remain = 0;
; 12265:         goto xmldecl_done;

	mov	ebx, DWORD PTR _avail$1$[ebp]
	mov	DWORD PTR _chunk$[ebp], ecx
	mov	DWORD PTR _size$[ebp], eax
	jmp	$xmldecl_done$93
$LN63@xmlParseCh:

; 12200: 	    ctxt->errNo = XML_PARSER_EOF;
; 12201: 	    xmlHaltParser(ctxt);

	push	esi
	mov	DWORD PTR [esi+84], -1
	call	_xmlHaltParser
	add	esp, 4

; 12202: 	    return (XML_PARSER_EOF);

	or	eax, -1
	pop	edi
	pop	esi

; 12310: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN64@xmlParseCh:

; 12220: 		    /* TODO 2.6.0 */
; 12221: 		    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BO@IBAMLEHI@xmlParseChunk?3?5encoder?5error?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax

; 12222: 				    "xmlParseChunk: encoder error\n");
; 12223:                     xmlHaltParser(ctxt);

	push	esi
	call	_xmlHaltParser
	add	esp, 12					; 0000000cH

; 12224: 		    return(XML_ERR_INVALID_ENCODING);

	mov	eax, 81					; 00000051H
	pop	edi
	pop	esi

; 12310: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@xmlParseCh:

; 12266:     }
; 12267:     if ((end_in_lf == 1) && (ctxt->input != NULL) &&

	cmp	DWORD PTR _end_in_lf$1$[ebp], 1
	jne	SHORT $LN33@xmlParseCh
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN33@xmlParseCh
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN33@xmlParseCh

; 12268:         (ctxt->input->buf != NULL)) {
; 12269: 	size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer,

	push	eax
	push	DWORD PTR [ecx+16]
	call	_xmlBufGetInputBase

; 12270: 					 ctxt->input);
; 12271: 	size_t current = ctxt->input->cur - ctxt->input->base;

	mov	ecx, DWORD PTR [esi+36]
	mov	ebx, eax

; 12272: 
; 12273: 	xmlParserInputBufferPush(ctxt->input->buf, 1, "\r");

	push	OFFSET ??_C@_01LIIJDEN@?$AN@
	push	1
	mov	edi, DWORD PTR [ecx+16]
	push	DWORD PTR [ecx]
	sub	edi, DWORD PTR [ecx+12]
	call	_xmlParserInputBufferPush

; 12274: 
; 12275: 	xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input,

	mov	eax, DWORD PTR [esi+36]
	push	edi
	push	ebx
	push	eax
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+16]
	call	_xmlBufSetInputBaseCur
	add	esp, 36					; 00000024H
$LN33@xmlParseCh:

; 12276: 			      base, current);
; 12277:     }
; 12278:     if (terminate) {

	cmp	DWORD PTR _terminate$[ebp], 0
	je	$LN34@xmlParseCh

; 12279: 	/*
; 12280: 	 * Check for termination
; 12281: 	 */
; 12282: 	int cur_avail = 0;
; 12283: 
; 12284: 	if (ctxt->input != NULL) {

	mov	eax, DWORD PTR [esi+36]
	xor	ebx, ebx
	test	eax, eax
	je	SHORT $LN37@xmlParseCh

; 12285: 	    if (ctxt->input->buf == NULL)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN36@xmlParseCh

; 12286: 		cur_avail = ctxt->input->length -

	mov	ebx, DWORD PTR [eax+24]
	sub	ebx, DWORD PTR [eax+16]
	add	ebx, DWORD PTR [eax+12]
	jmp	SHORT $LN37@xmlParseCh
$LN36@xmlParseCh:

; 12287: 			    (ctxt->input->cur - ctxt->input->base);
; 12288: 	    else
; 12289: 		cur_avail = xmlBufUse(ctxt->input->buf->buffer) -

	push	DWORD PTR [ecx+16]
	mov	edi, eax
	call	_xmlBufUse
	mov	ebx, DWORD PTR [edi+12]
	add	esp, 4
	sub	ebx, DWORD PTR [edi+16]
	add	ebx, eax
$LN37@xmlParseCh:

; 12290: 			              (ctxt->input->cur - ctxt->input->base);
; 12291: 	}
; 12292: 
; 12293: 	if ((ctxt->instate != XML_PARSER_EOF) &&

	mov	ecx, DWORD PTR [esi+172]
	mov	eax, ecx
	cmp	ecx, -1
	je	SHORT $LN38@xmlParseCh
	cmp	ecx, 14					; 0000000eH
	je	SHORT $LN38@xmlParseCh

; 12294: 	    (ctxt->instate != XML_PARSER_EPILOG)) {
; 12295: 	    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);

	push	0
	push	5
	push	esi
	call	_xmlFatalErr
	mov	eax, DWORD PTR [esi+172]
	add	esp, 12					; 0000000cH
$LN38@xmlParseCh:

; 12296: 	}
; 12297: 	if ((ctxt->instate == XML_PARSER_EPILOG) && (cur_avail > 0)) {

	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN39@xmlParseCh
	test	ebx, ebx
	jle	SHORT $LN71@xmlParseCh

; 12298: 	    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);

	push	0
	push	5
	push	esi
	call	_xmlFatalErr
	mov	eax, DWORD PTR [esi+172]
	add	esp, 12					; 0000000cH
$LN39@xmlParseCh:

; 12299: 	}
; 12300: 	if (ctxt->instate != XML_PARSER_EOF) {

	cmp	eax, -1
	je	SHORT $LN41@xmlParseCh
$LN71@xmlParseCh:

; 12301: 	    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN41@xmlParseCh
	mov	eax, DWORD PTR [eax+52]
	test	eax, eax
	je	SHORT $LN41@xmlParseCh

; 12302: 		ctxt->sax->endDocument(ctxt->userData);

	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 4
$LN41@xmlParseCh:

; 12303: 	}
; 12304: 	ctxt->instate = XML_PARSER_EOF;

	mov	DWORD PTR [esi+172], -1
$LN34@xmlParseCh:

; 12305:     }
; 12306:     if (ctxt->wellFormed == 0)

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN65@xmlParseCh

; 12307: 	return((xmlParserErrors) ctxt->errNo);
; 12308:     else
; 12309:         return(0);

	pop	edi
	pop	esi
	xor	eax, eax

; 12310: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN65@xmlParseCh:

; 12249:         return(ctxt->errNo);

	mov	eax, DWORD PTR [esi+84]
$LN89@xmlParseCh:
	pop	edi
$LN43@xmlParseCh:
	pop	esi

; 12310: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseChunk ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCreatePushParserCtxt
_TEXT	SEGMENT
tv463 = -12						; size = 4
_enc$1$ = -8						; size = 4
_buf$1$ = -4						; size = 4
_sax$ = 8						; size = 4
_user_data$ = 12					; size = 4
_chunk$ = 16						; size = 4
_size$ = 20						; size = 4
_filename$ = 24						; size = 4
_xmlCreatePushParserCtxt PROC				; COMDAT

; 12339:                         const char *chunk, int size, const char *filename) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _chunk$[ebp]
	xor	eax, eax
	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _enc$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN2@xmlCreateP

; 12340:     xmlParserCtxtPtr ctxt;
; 12341:     xmlParserInputPtr inputStream;
; 12342:     xmlParserInputBufferPtr buf;
; 12343:     xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
; 12344: 
; 12345:     /*
; 12346:      * plug some encoding conversion routines
; 12347:      */
; 12348:     if ((chunk != NULL) && (size >= 4))

	cmp	edx, 4
	jl	SHORT $LN2@xmlCreateP

; 12349: 	enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);

	push	edx
	push	ecx
	call	_xmlDetectCharEncoding
	add	esp, 8
	mov	DWORD PTR _enc$1$[ebp], eax
$LN2@xmlCreateP:

; 12350: 
; 12351:     buf = xmlAllocParserInputBuffer(enc);

	push	esi
	push	eax
	call	_xmlAllocParserInputBuffer
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _buf$1$[ebp], esi

; 12352:     if (buf == NULL) return(NULL);

	test	esi, esi
	jne	SHORT $LN3@xmlCreateP
	pop	esi

; 12440: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlCreateP:
	push	ebx

; 12353: 
; 12354:     ctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	ebx, eax

; 12355:     if (ctxt == NULL) {

	test	ebx, ebx
	jne	SHORT $LN4@xmlCreateP

; 12356:         xmlErrMemory(NULL, "creating parser: out of memory\n");

	push	OFFSET ??_C@_0CA@CCOLJACP@creating?5parser?3?5out?5of?5memory?6@
	push	eax
	call	_xmlErrMemory

; 12357: 	xmlFreeParserInputBuffer(buf);

	push	esi
	call	_xmlFreeParserInputBuffer
	add	esp, 12					; 0000000cH

; 12358: 	return(NULL);

	xor	eax, eax
	pop	ebx
	pop	esi

; 12440: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlCreateP:

; 12359:     }
; 12360:     ctxt->dictNames = 1;
; 12361:     ctxt->pushTab = (void **) xmlMalloc(ctxt->nameMax * 3 * sizeof(xmlChar *));

	mov	eax, DWORD PTR [ebx+192]
	push	edi
	mov	DWORD PTR [ebx+364], 1
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [ebx+344], eax

; 12362:     if (ctxt->pushTab == NULL) {

	test	eax, eax
	je	$LN25@xmlCreateP

; 12363:         xmlErrMemory(ctxt, NULL);
; 12364: 	xmlFreeParserInputBuffer(buf);
; 12365: 	xmlFreeParserCtxt(ctxt);
; 12366: 	return(NULL);
; 12367:     }
; 12368:     if (sax != NULL) {

	mov	edi, DWORD PTR _sax$[ebp]
	test	edi, edi
	je	SHORT $LN11@xmlCreateP

; 12369: #ifdef LIBXML_SAX1_ENABLED
; 12370: 	if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR tv463[ebp], eax
	call	___xmlDefaultSAXHandler
	mov	ecx, DWORD PTR tv463[ebp]
	cmp	ecx, eax
	je	SHORT $LN7@xmlCreateP

; 12371: #endif /* LIBXML_SAX1_ENABLED */
; 12372: 	    xmlFree(ctxt->sax);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlCreateP:

; 12373: 	ctxt->sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));

	push	128					; 00000080H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [ebx], eax

; 12374: 	if (ctxt->sax == NULL) {

	test	eax, eax
	je	$LN25@xmlCreateP

; 12379: 	}
; 12380: 	memset(ctxt->sax, 0, sizeof(xmlSAXHandler));

	push	128					; 00000080H
	push	0
	push	eax
	call	_memset

; 12381: 	if (sax->initialized == XML_SAX2_MAGIC)

	mov	eax, DWORD PTR [ebx]
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [edi+108], -554844497		; deedbeafH
	mov	esi, edi
	mov	edi, eax

; 12382: 	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));

	mov	ecx, 32					; 00000020H
	je	SHORT $LN29@xmlCreateP

; 12383: 	else
; 12384: 	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));

	mov	ecx, 28					; 0000001cH
$LN29@xmlCreateP:

; 12385: 	if (user_data != NULL)

	mov	eax, DWORD PTR _user_data$[ebp]
	rep movsd
	mov	esi, DWORD PTR _buf$1$[ebp]
	test	eax, eax
	je	SHORT $LN11@xmlCreateP

; 12386: 	    ctxt->userData = user_data;

	mov	DWORD PTR [ebx+4], eax
$LN11@xmlCreateP:

; 12387:     }
; 12388:     if (filename == NULL) {

	mov	eax, DWORD PTR _filename$[ebp]
	test	eax, eax
	je	SHORT $LN13@xmlCreateP
$LN12@xmlCreateP:

; 12389: 	ctxt->directory = NULL;
; 12390:     } else {
; 12391:         ctxt->directory = xmlParserGetDirectory(filename);

	push	eax
	call	_xmlParserGetDirectory
	add	esp, 4
$LN13@xmlCreateP:

; 12392:     }
; 12393: 
; 12394:     inputStream = xmlNewInputStream(ctxt);

	push	ebx
	mov	DWORD PTR [ebx+180], eax
	call	_xmlNewInputStream
	mov	edi, eax
	add	esp, 4

; 12395:     if (inputStream == NULL) {

	test	edi, edi
	je	$LN24@xmlCreateP

; 12396: 	xmlFreeParserCtxt(ctxt);
; 12397: 	xmlFreeParserInputBuffer(buf);
; 12398: 	return(NULL);
; 12399:     }
; 12400: 
; 12401:     if (filename == NULL)

	mov	eax, DWORD PTR _filename$[ebp]
	test	eax, eax
	jne	SHORT $LN15@xmlCreateP

; 12402: 	inputStream->filename = NULL;

	mov	DWORD PTR [edi+4], eax
	jmp	SHORT $LN17@xmlCreateP
$LN15@xmlCreateP:

; 12403:     else {
; 12404: 	inputStream->filename = (char *)

	push	eax
	call	_xmlCanonicPath
	add	esp, 4
	mov	DWORD PTR [edi+4], eax

; 12405: 	    xmlCanonicPath((const xmlChar *) filename);
; 12406: 	if (inputStream->filename == NULL) {

	test	eax, eax
	je	$LN24@xmlCreateP
$LN17@xmlCreateP:

; 12409: 	    return(NULL);
; 12410: 	}
; 12411:     }
; 12412:     inputStream->buf = buf;

	mov	DWORD PTR [edi], esi

; 12413:     xmlBufResetInput(inputStream->buf->buffer, inputStream);

	push	edi
	push	DWORD PTR [esi+16]
	call	_xmlBufResetInput

; 12414:     inputPush(ctxt, inputStream);

	push	edi
	push	ebx
	call	_inputPush
	add	esp, 16					; 00000010H

; 12415: 
; 12416:     /*
; 12417:      * If the caller didn't provide an initial 'chunk' for determining
; 12418:      * the encoding, we set the context to XML_CHAR_ENCODING_NONE so
; 12419:      * that it can be automatically determined later
; 12420:      */
; 12421:     if ((size == 0) || (chunk == NULL)) {

	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN20@xmlCreateP
	cmp	DWORD PTR _chunk$[ebp], 0
	je	SHORT $LN20@xmlCreateP

; 12423:     } else if ((ctxt->input != NULL) && (ctxt->input->buf != NULL)) {

	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	je	SHORT $LN21@xmlCreateP
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN21@xmlCreateP

; 12424: 	size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);

	push	eax
	push	DWORD PTR [ecx+16]
	call	_xmlBufGetInputBase

; 12425: 	size_t cur = ctxt->input->cur - ctxt->input->base;

	mov	ecx, DWORD PTR [ebx+36]
	mov	edi, eax

; 12426: 
; 12427: 	xmlParserInputBufferPush(ctxt->input->buf, size, chunk);

	push	DWORD PTR _chunk$[ebp]
	push	DWORD PTR _size$[ebp]
	mov	esi, DWORD PTR [ecx+16]
	push	DWORD PTR [ecx]
	sub	esi, DWORD PTR [ecx+12]
	call	_xmlParserInputBufferPush

; 12428: 
; 12429:         xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);

	mov	eax, DWORD PTR [ebx+36]
	push	esi
	push	edi
	push	eax
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+16]
	call	_xmlBufSetInputBaseCur
	add	esp, 36					; 00000024H
	jmp	SHORT $LN21@xmlCreateP
$LN20@xmlCreateP:

; 12422: 	ctxt->charset = XML_CHAR_ENCODING_NONE;

	mov	DWORD PTR [ebx+256], 0
$LN21@xmlCreateP:

; 12430: #ifdef DEBUG_PUSH
; 12431: 	xmlGenericError(xmlGenericErrorContext, "PP: pushed %d\n", size);
; 12432: #endif
; 12433:     }
; 12434: 
; 12435:     if (enc != XML_CHAR_ENCODING_NONE) {

	mov	eax, DWORD PTR _enc$1$[ebp]
	test	eax, eax
	je	SHORT $LN22@xmlCreateP

; 12436:         xmlSwitchEncoding(ctxt, enc);

	push	eax
	push	ebx
	call	_xmlSwitchEncoding
	add	esp, 8
$LN22@xmlCreateP:

; 12437:     }
; 12438: 
; 12439:     return(ctxt);

	pop	edi
	mov	eax, ebx
	pop	ebx
	pop	esi

; 12440: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlCreateP:

; 12407: 	    xmlFreeParserCtxt(ctxt);

	push	ebx
	call	_xmlFreeParserCtxt

; 12408: 	    xmlFreeParserInputBuffer(buf);

	push	esi
	call	_xmlFreeParserInputBuffer
	add	esp, 8
	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 12440: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlCreateP:

; 12375: 	    xmlErrMemory(ctxt, NULL);

	push	0
	push	ebx
	call	_xmlErrMemory

; 12376: 	    xmlFreeParserInputBuffer(buf);

	push	esi
	call	_xmlFreeParserInputBuffer

; 12377: 	    xmlFreeParserCtxt(ctxt);

	push	ebx
	call	_xmlFreeParserCtxt
	add	esp, 16					; 00000010H

; 12378: 	    return(NULL);

	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 12440: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCreatePushParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCreateDocParserCtxt
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlCreateDocParserCtxt PROC				; COMDAT

; 14574: xmlCreateDocParserCtxt(const xmlChar *cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlCreateD

; 14575:     int len;
; 14576: 
; 14577:     if (cur == NULL)
; 14578: 	return(NULL);

	xor	eax, eax
	pop	esi

; 14581: }

	pop	ebp
	ret	0
$LN2@xmlCreateD:

; 14579:     len = xmlStrlen(cur);

	push	esi
	call	_xmlStrlen

; 14580:     return(xmlCreateMemoryParserCtxt((const char *)cur, len));

	push	eax
	push	esi
	call	_xmlCreateMemoryParserCtxt
	add	esp, 12					; 0000000cH
	pop	esi

; 14581: }

	pop	ebp
	ret	0
_xmlCreateDocParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSetupParserForBuffer
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_buffer$ = 12						; size = 4
_filename$ = 16						; size = 4
_xmlSetupParserForBuffer PROC				; COMDAT

; 14284: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSetupPa

; 14285:     xmlParserInputPtr input;
; 14286: 
; 14287:     if ((ctxt == NULL) || (buffer == NULL))

	push	ebx
	mov	ebx, DWORD PTR _buffer$[ebp]
	test	ebx, ebx
	je	SHORT $LN7@xmlSetupPa

; 14288:         return;
; 14289: 
; 14290:     input = xmlNewInputStream(ctxt);

	push	edi
	push	esi
	call	_xmlNewInputStream
	mov	edi, eax
	add	esp, 4

; 14291:     if (input == NULL) {

	test	edi, edi
	jne	SHORT $LN4@xmlSetupPa

; 14292:         xmlErrMemory(NULL, "parsing new buffer: out of memory\n");

	push	OFFSET ??_C@_0CD@FOJADJIB@parsing?5new?5buffer?3?5out?5of?5memo@
	push	eax
	call	_xmlErrMemory

; 14293:         xmlClearParserCtxt(ctxt);

	push	esi
	call	_xmlClearParserCtxt

; 14303:     inputPush(ctxt, input);

	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebx
	pop	esi

; 14304: }

	pop	ebp
	ret	0
$LN4@xmlSetupPa:

; 14294:         return;
; 14295:     }
; 14296: 
; 14297:     xmlClearParserCtxt(ctxt);

	push	esi
	call	_xmlClearParserCtxt

; 14298:     if (filename != NULL)

	mov	eax, DWORD PTR _filename$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@xmlSetupPa

; 14299:         input->filename = (char *) xmlCanonicPath((const xmlChar *)filename);

	push	eax
	call	_xmlCanonicPath
	add	esp, 4
	mov	DWORD PTR [edi+4], eax
$LN5@xmlSetupPa:

; 14300:     input->base = buffer;
; 14301:     input->cur = buffer;
; 14302:     input->end = &buffer[xmlStrlen(buffer)];

	push	ebx
	mov	DWORD PTR [edi+12], ebx
	mov	DWORD PTR [edi+16], ebx
	call	_xmlStrlen
	add	eax, ebx

; 14303:     inputPush(ctxt, input);

	push	edi
	push	esi
	mov	DWORD PTR [edi+20], eax
	call	_inputPush
	add	esp, 12					; 0000000cH
	pop	edi
$LN7@xmlSetupPa:
	pop	ebx
$LN3@xmlSetupPa:
	pop	esi

; 14304: }

	pop	ebp
	ret	0
_xmlSetupParserForBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseCtxtExternalEntity
_TEXT	SEGMENT
_start$ = -4						; size = 4
_oldsax$1$ = 8						; size = 4
_ctx$ = 8						; size = 4
_URL$ = 12						; size = 4
_ID$ = 16						; size = 4
_lst$ = 20						; size = 4
_xmlParseCtxtExternalEntity PROC			; COMDAT

; 12870: 	               const xmlChar *ID, xmlNodePtr *lst) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctx$[ebp]
	test	edi, edi
	je	$LN251@xmlParseCt

; 12871:     xmlParserCtxtPtr ctxt;
; 12872:     xmlDocPtr newDoc;
; 12873:     xmlNodePtr newRoot;
; 12874:     xmlSAXHandlerPtr oldsax = NULL;
; 12875:     int ret = 0;
; 12876:     xmlChar start[4];
; 12877:     xmlCharEncoding enc;
; 12878: 
; 12879:     if (ctx == NULL) return(-1);
; 12880: 
; 12881:     if (((ctx->depth > 40) && ((ctx->options & XML_PARSE_HUGE) == 0)) ||

	mov	eax, DWORD PTR [edi+248]
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN7@xmlParseCt
	test	DWORD PTR [edi+360], 524288		; 00080000H
	je	SHORT $LN6@xmlParseCt
$LN7@xmlParseCt:
	cmp	eax, 1024				; 00000400H
	jle	SHORT $LN5@xmlParseCt
$LN6@xmlParseCt:
	pop	edi

; 12882:         (ctx->depth > 1024)) {
; 12883: 	return(XML_ERR_ENTITY_LOOP);

	mov	eax, 89					; 00000059H

; 13054: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlParseCt:

; 12884:     }
; 12885: 
; 12886:     if (lst != NULL)

	mov	eax, DWORD PTR _lst$[ebp]
	test	eax, eax
	je	SHORT $LN8@xmlParseCt

; 12887:         *lst = NULL;

	mov	DWORD PTR [eax], 0
$LN8@xmlParseCt:

; 12888:     if ((URL == NULL) && (ID == NULL))

	mov	ecx, DWORD PTR _URL$[ebp]
	mov	eax, DWORD PTR _ID$[ebp]
	test	ecx, ecx
	jne	SHORT $LN9@xmlParseCt
	test	eax, eax
	je	$LN251@xmlParseCt
$LN9@xmlParseCt:

; 12889: 	return(-1);
; 12890:     if (ctx->myDoc == NULL) /* @@ relax but check for dereferences */

	cmp	DWORD PTR [edi+8], 0
	je	$LN251@xmlParseCt

; 12891: 	return(-1);
; 12892: 
; 12893:     ctxt = xmlCreateEntityParserCtxtInternal(URL, ID, NULL, ctx);

	push	edi
	push	0
	push	eax
	push	ecx
	call	_xmlCreateEntityParserCtxtInternal
	mov	esi, eax
	add	esp, 16					; 00000010H

; 12894:     if (ctxt == NULL) {

	test	esi, esi
	je	$LN251@xmlParseCt

; 12896:     }
; 12897: 
; 12898:     oldsax = ctxt->sax;

	mov	eax, DWORD PTR [esi]
	push	ebx
	mov	DWORD PTR _oldsax$1$[ebp], eax

; 12899:     ctxt->sax = ctx->sax;

	mov	eax, DWORD PTR [edi]

; 12900:     xmlDetectSAX2(ctxt);

	push	esi
	mov	DWORD PTR [esi], eax
	call	_xmlDetectSAX2

; 12901:     newDoc = xmlNewDoc(BAD_CAST "1.0");

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlNewDoc
	mov	ebx, eax
	add	esp, 8

; 12902:     if (newDoc == NULL) {

	test	ebx, ebx
	jne	SHORT $LN12@xmlParseCt

; 12903: 	xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12904: 	return(-1);

	or	eax, -1
	pop	ebx
	pop	edi

; 13054: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlParseCt:

; 12905:     }
; 12906:     newDoc->properties = XML_DOC_INTERNAL;

	mov	DWORD PTR [ebx+92], 64			; 00000040H

; 12907:     if (ctx->myDoc->dict) {

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [eax+80]
	test	ecx, ecx
	je	SHORT $LN13@xmlParseCt

; 12908: 	newDoc->dict = ctx->myDoc->dict;
; 12909: 	xmlDictReference(newDoc->dict);

	push	ecx
	mov	DWORD PTR [ebx+80], ecx
	call	_xmlDictReference
	mov	eax, DWORD PTR [edi+8]
	add	esp, 4
$LN13@xmlParseCt:

; 12910:     }
; 12911:     if (ctx->myDoc != NULL) {

	test	eax, eax
	je	SHORT $LN14@xmlParseCt

; 12912: 	newDoc->intSubset = ctx->myDoc->intSubset;

	mov	eax, DWORD PTR [eax+44]
	mov	DWORD PTR [ebx+44], eax

; 12913: 	newDoc->extSubset = ctx->myDoc->extSubset;

	mov	eax, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [eax+48]
	mov	DWORD PTR [ebx+48], eax
	mov	eax, DWORD PTR [edi+8]
$LN14@xmlParseCt:

; 12914:     }
; 12915:     if (ctx->myDoc->URL != NULL) {

	mov	eax, DWORD PTR [eax+72]
	test	eax, eax
	je	SHORT $LN15@xmlParseCt

; 12916: 	newDoc->URL = xmlStrdup(ctx->myDoc->URL);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+72], eax
$LN15@xmlParseCt:

; 12917:     }
; 12918:     newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST "pseudoroot", NULL);

	push	0
	push	OFFSET ??_C@_0L@OLLEMIAI@pseudoroot@
	push	0
	push	ebx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H

; 12919:     if (newRoot == NULL) {

	test	eax, eax
	jne	SHORT $LN16@xmlParseCt

; 12920: 	ctxt->sax = oldsax;

	mov	eax, DWORD PTR _oldsax$1$[ebp]

; 12921: 	xmlFreeParserCtxt(ctxt);

	push	esi
	mov	DWORD PTR [esi], eax
	call	_xmlFreeParserCtxt

; 12922: 	newDoc->intSubset = NULL;
; 12923: 	newDoc->extSubset = NULL;
; 12924:         xmlFreeDoc(newDoc);

	push	ebx
	mov	DWORD PTR [ebx+44], 0
	mov	DWORD PTR [ebx+48], 0
	call	_xmlFreeDoc
	add	esp, 8
	or	eax, -1
	pop	ebx
	pop	edi

; 13054: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlParseCt:

; 12925: 	return(-1);
; 12926:     }
; 12927:     xmlAddChild((xmlNodePtr) newDoc, newRoot);

	push	eax
	push	ebx
	call	_xmlAddChild

; 12928:     nodePush(ctxt, newDoc->children);

	push	DWORD PTR [ebx+12]
	push	esi
	call	_nodePush

; 12929:     if (ctx->myDoc == NULL) {

	mov	eax, DWORD PTR [edi+8]
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN17@xmlParseCt

; 12930: 	ctxt->myDoc = newDoc;

	mov	DWORD PTR [esi+8], ebx

; 12931:     } else {

	jmp	SHORT $LN18@xmlParseCt
$LN17@xmlParseCt:

; 12932: 	ctxt->myDoc = ctx->myDoc;

	mov	DWORD PTR [esi+8], eax

; 12933: 	newDoc->children->doc = ctx->myDoc;

	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [ecx+32], eax
$LN18@xmlParseCt:

; 12934:     }
; 12935: 
; 12936:     /*
; 12937:      * Get the 4 first bytes and decode the charset
; 12938:      * if enc != XML_CHAR_ENCODING_NONE
; 12939:      * plug some encoding conversion routines.
; 12940:      */
; 12941:     GROW

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN19@xmlParseCt
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN19@xmlParseCt
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN19@xmlParseCt:

; 12942:     if ((ctxt->input->end - ctxt->input->cur) >= 4) {

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	cmp	eax, 4
	jl	SHORT $LN21@xmlParseCt

; 12943: 	start[0] = RAW;

	movzx	eax, BYTE PTR [ecx]
	mov	BYTE PTR _start$[ebp], al

; 12944: 	start[1] = NXT(1);

	mov	eax, DWORD PTR [esi+36]

; 12945: 	start[2] = NXT(2);
; 12946: 	start[3] = NXT(3);
; 12947: 	enc = xmlDetectCharEncoding(start, 4);

	push	4
	mov	eax, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [eax+1]
	mov	BYTE PTR _start$[ebp+1], al
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [eax+2]
	mov	BYTE PTR _start$[ebp+2], al
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [eax+3]
	mov	BYTE PTR _start$[ebp+3], al
	lea	eax, DWORD PTR _start$[ebp]
	push	eax
	call	_xmlDetectCharEncoding
	add	esp, 8

; 12948: 	if (enc != XML_CHAR_ENCODING_NONE) {

	test	eax, eax
	je	SHORT $LN21@xmlParseCt

; 12949: 	    xmlSwitchEncoding(ctxt, enc);

	push	eax
	push	esi
	call	_xmlSwitchEncoding
	add	esp, 8
$LN21@xmlParseCt:

; 12950: 	}
; 12951:     }
; 12952: 
; 12953:     /*
; 12954:      * Parse a possible text declaration first
; 12955:      */
; 12956:     if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 60			; 0000003cH
	jne	SHORT $LN25@xmlParseCt
	cmp	BYTE PTR [eax+1], 63			; 0000003fH
	jne	SHORT $LN25@xmlParseCt
	cmp	BYTE PTR [eax+2], 120			; 00000078H
	jne	SHORT $LN25@xmlParseCt
	cmp	BYTE PTR [eax+3], 109			; 0000006dH
	jne	SHORT $LN25@xmlParseCt
	cmp	BYTE PTR [eax+4], 108			; 0000006cH
	jne	SHORT $LN25@xmlParseCt
	mov	al, BYTE PTR [eax+5]
	cmp	al, 32					; 00000020H
	je	SHORT $LN23@xmlParseCt
	cmp	al, 9
	jb	SHORT $LN24@xmlParseCt
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN23@xmlParseCt
$LN24@xmlParseCt:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN25@xmlParseCt
$LN23@xmlParseCt:

; 12957: 	xmlParseTextDecl(ctxt);

	push	esi
	call	_xmlParseTextDecl

; 12958: 	/*
; 12959: 	 * An XML-1.0 document can't reference an entity not XML-1.0
; 12960: 	 */
; 12961: 	if ((xmlStrEqual(ctx->version, BAD_CAST "1.0")) &&

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	push	DWORD PTR [edi+20]
	call	_xmlStrEqual
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN25@xmlParseCt
	mov	eax, DWORD PTR [esi+36]
	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	push	DWORD PTR [eax+48]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@xmlParseCt

; 12962: 	    (!xmlStrEqual(ctxt->input->version, BAD_CAST "1.0"))) {
; 12963: 	    xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,

	push	OFFSET ??_C@_0CO@FDJENMMD@Version?5mismatch?5between?5docume@
	push	109					; 0000006dH
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN25@xmlParseCt:

; 12964: 	                   "Version mismatch between document and entity\n");
; 12965: 	}
; 12966:     }
; 12967: 
; 12968:     /*
; 12969:      * If the user provided its own SAX callbacks then reuse the
; 12970:      * useData callback field, otherwise the expected setup in a
; 12971:      * DOM builder is to have userData == ctxt
; 12972:      */
; 12973:     if (ctx->userData == ctx)

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, edi
	cmove	eax, esi

; 12974:         ctxt->userData = ctxt;
; 12975:     else
; 12976:         ctxt->userData = ctx->userData;
; 12977: 
; 12978:     /*
; 12979:      * Doing validity checking on chunk doesn't make sense
; 12980:      */
; 12981:     ctxt->instate = XML_PARSER_CONTENT;

	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+172], 7

; 12982:     ctxt->validate = ctx->validate;

	mov	ecx, DWORD PTR [edi+104]
	mov	DWORD PTR [esi+104], ecx

; 12983:     ctxt->valid = ctx->valid;

	mov	eax, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+100], eax

; 12984:     ctxt->loadsubset = ctx->loadsubset;

	mov	eax, DWORD PTR [edi+276]
	mov	DWORD PTR [esi+276], eax

; 12985:     ctxt->depth = ctx->depth + 1;

	mov	eax, DWORD PTR [edi+248]
	inc	eax
	mov	DWORD PTR [esi+248], eax

; 12986:     ctxt->replaceEntities = ctx->replaceEntities;

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], eax

; 12987:     if (ctxt->validate) {

	test	ecx, ecx
	je	SHORT $LN28@xmlParseCt

; 12988: 	ctxt->vctxt.error = ctx->vctxt.error;

	mov	eax, DWORD PTR [edi+112]
	mov	DWORD PTR [esi+112], eax

; 12989: 	ctxt->vctxt.warning = ctx->vctxt.warning;

	mov	eax, DWORD PTR [edi+116]

; 12990:     } else {

	jmp	SHORT $LN29@xmlParseCt
$LN28@xmlParseCt:

; 12991: 	ctxt->vctxt.error = NULL;

	mov	DWORD PTR [esi+112], 0

; 12992: 	ctxt->vctxt.warning = NULL;

	xor	eax, eax
$LN29@xmlParseCt:

; 12993:     }
; 12994:     ctxt->vctxt.nodeTab = NULL;

	mov	DWORD PTR [esi+116], eax

; 12995:     ctxt->vctxt.nodeNr = 0;
; 12996:     ctxt->vctxt.nodeMax = 0;
; 12997:     ctxt->vctxt.node = NULL;
; 12998:     if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);

	mov	eax, DWORD PTR [esi+296]
	mov	DWORD PTR [esi+132], 0
	mov	DWORD PTR [esi+124], 0
	mov	DWORD PTR [esi+128], 0
	mov	DWORD PTR [esi+120], 0
	test	eax, eax
	je	SHORT $LN30@xmlParseCt
	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN30@xmlParseCt:

; 12999:     ctxt->dict = ctx->dict;

	mov	eax, DWORD PTR [edi+296]

; 13000:     ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);

	push	3
	push	OFFSET ??_C@_03PJHHNEEI@xml@
	push	eax
	mov	DWORD PTR [esi+296], eax
	call	_xmlDictLookup

; 13001:     ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);

	push	5
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR [esi+296]
	mov	DWORD PTR [esi+312], eax
	call	_xmlDictLookup

; 13002:     ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);

	push	36					; 00000024H
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	DWORD PTR [esi+296]
	mov	DWORD PTR [esi+316], eax
	call	_xmlDictLookup
	mov	DWORD PTR [esi+320], eax

; 13003:     ctxt->dictNames = ctx->dictNames;

	mov	eax, DWORD PTR [edi+364]
	mov	DWORD PTR [esi+364], eax

; 13004:     ctxt->attsDefault = ctx->attsDefault;

	mov	eax, DWORD PTR [edi+348]
	mov	DWORD PTR [esi+348], eax

; 13005:     ctxt->attsSpecial = ctx->attsSpecial;

	mov	eax, DWORD PTR [edi+352]
	mov	DWORD PTR [esi+352], eax

; 13006:     ctxt->linenumbers = ctx->linenumbers;

	mov	eax, DWORD PTR [edi+280]

; 13007: 
; 13008:     xmlParseContent(ctxt);

	push	esi
	mov	DWORD PTR [esi+280], eax
	call	_xmlParseContent

; 13009: 
; 13010:     ctx->validate = ctxt->validate;

	mov	eax, DWORD PTR [esi+104]
	add	esp, 40					; 00000028H
	mov	DWORD PTR [edi+104], eax

; 13011:     ctx->valid = ctxt->valid;

	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR [edi+100], eax

; 13012:     if ((RAW == '<') && (NXT(1) == '/')) {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	mov	cl, BYTE PTR [eax]
	cmp	cl, 60					; 0000003cH
	jne	SHORT $LN31@xmlParseCt
	cmp	BYTE PTR [eax+1], 47			; 0000002fH
	jne	SHORT $LN31@xmlParseCt

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN44@xmlParseCt
	cmp	DWORD PTR [esi+172], -1
	je	$LN175@xmlParseCt
$LN44@xmlParseCt:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 85			; 00000055H
	push	85					; 00000055H

; 556  :     }
; 557  : }

	jmp	SHORT $LN254@xmlParseCt
$LN31@xmlParseCt:

; 13013: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
; 13014:     } else if (RAW != 0) {

	test	cl, cl
	je	SHORT $LN175@xmlParseCt

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN250@xmlParseCt
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN175@xmlParseCt
$LN250@xmlParseCt:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0DA@BPKCCNLP@extra?5content?5at?5the?5end?5of?5wel@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 86			; 00000056H
	push	86					; 00000056H
$LN254@xmlParseCt:

; 13015: 	xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
; 13016:     }
; 13017:     if (ctxt->node != newDoc->children) {

	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	mov	DWORD PTR [esi+12], 0
	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN175@xmlParseCt
	mov	DWORD PTR [esi+212], 1
$LN175@xmlParseCt:
	mov	eax, DWORD PTR [esi+52]
	cmp	eax, DWORD PTR [ebx+12]
	je	SHORT $LN243@xmlParseCt

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN180@xmlParseCt
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN243@xmlParseCt
$LN180@xmlParseCt:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	85					; 00000055H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 85			; 00000055H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN243@xmlParseCt

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN243@xmlParseCt:

; 13018: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
; 13019:     }
; 13020: 
; 13021:     if (!ctxt->wellFormed) {

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN35@xmlParseCt

; 13022:         if (ctxt->errNo == 0)

	mov	edi, DWORD PTR [esi+84]
	mov	eax, 1
	test	edi, edi
	cmove	edi, eax

; 13023: 	    ret = 1;
; 13024: 	else
; 13025: 	    ret = ctxt->errNo;
; 13026:     } else {

	jmp	SHORT $LN36@xmlParseCt
$LN35@xmlParseCt:

; 13027: 	if (lst != NULL) {

	mov	ecx, DWORD PTR _lst$[ebp]
	test	ecx, ecx
	je	SHORT $LN39@xmlParseCt

; 13028: 	    xmlNodePtr cur;
; 13029: 
; 13030: 	    /*
; 13031: 	     * Return the newly created nodeset after unlinking it from
; 13032: 	     * they pseudo parent.
; 13033: 	     */
; 13034: 	    cur = newDoc->children->children;

	mov	eax, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [eax+12]

; 13035: 	    *lst = cur;

	mov	DWORD PTR [ecx], eax

; 13036: 	    while (cur != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlParseCt
	npad	3
$LL2@xmlParseCt:

; 13037: 		cur->parent = NULL;

	mov	DWORD PTR [eax+20], 0

; 13038: 		cur = cur->next;

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL2@xmlParseCt
$LN3@xmlParseCt:

; 13039: 	    }
; 13040:             newDoc->children->children = NULL;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+12], 0
$LN39@xmlParseCt:

; 13041: 	}
; 13042: 	ret = 0;

	xor	edi, edi
$LN36@xmlParseCt:

; 13043:     }
; 13044:     ctxt->sax = oldsax;

	mov	eax, DWORD PTR _oldsax$1$[ebp]

; 13045:     ctxt->dict = NULL;
; 13046:     ctxt->attsDefault = NULL;
; 13047:     ctxt->attsSpecial = NULL;
; 13048:     xmlFreeParserCtxt(ctxt);

	push	esi
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+296], 0
	mov	DWORD PTR [esi+348], 0
	mov	DWORD PTR [esi+352], 0
	call	_xmlFreeParserCtxt

; 13049:     newDoc->intSubset = NULL;
; 13050:     newDoc->extSubset = NULL;
; 13051:     xmlFreeDoc(newDoc);

	push	ebx
	mov	DWORD PTR [ebx+44], 0
	mov	DWORD PTR [ebx+48], 0
	call	_xmlFreeDoc
	add	esp, 8

; 13052: 
; 13053:     return(ret);

	mov	eax, edi
	pop	ebx
	pop	edi

; 13054: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN251@xmlParseCt:
	pop	edi

; 12895: 	return(-1);

	or	eax, -1

; 13054: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseCtxtExternalEntity ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseExternalEntity
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_sax$ = 12						; size = 4
_user_data$ = 16					; size = 4
_depth$ = 20						; size = 4
_URL$ = 24						; size = 4
_ID$ = 28						; size = 4
_lst$ = 32						; size = 4
_xmlParseExternalEntity PROC				; COMDAT

; 13287: 	  int depth, const xmlChar *URL, const xmlChar *ID, xmlNodePtr *lst) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _lst$[ebp]
	push	DWORD PTR _ID$[ebp]
	push	DWORD PTR _URL$[ebp]
	push	DWORD PTR _depth$[ebp]
	push	DWORD PTR _user_data$[ebp]
	push	DWORD PTR _sax$[ebp]
	push	0
	push	DWORD PTR _doc$[ebp]
	call	_xmlParseExternalEntityPrivate
	add	esp, 32					; 00000020H

; 13288:     return(xmlParseExternalEntityPrivate(doc, NULL, sax, user_data, depth, URL,
; 13289: 		                       ID, lst));
; 13290: }

	pop	ebp
	ret	0
_xmlParseExternalEntity ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseBalancedChunkMemoryRecover
_TEXT	SEGMENT
_ctxt$1$ = -12						; size = 4
_newRoot$1$ = -8					; size = 4
_oldsax$1$ = -4						; size = 4
_doc$ = 8						; size = 4
_sax$ = 12						; size = 4
_user_data$ = 16					; size = 4
_ret$1$ = 20						; size = 4
_depth$ = 20						; size = 4
_string$ = 24						; size = 4
_lst$ = 28						; size = 4
_recover$ = 32						; size = 4
_xmlParseBalancedChunkMemoryRecover PROC		; COMDAT

; 13772:      int recover) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _depth$[ebp], 40		; 00000028H
	mov	DWORD PTR _oldsax$1$[ebp], 0
	jle	SHORT $LN4@xmlParseBa

; 13773:     xmlParserCtxtPtr ctxt;
; 13774:     xmlDocPtr newDoc;
; 13775:     xmlSAXHandlerPtr oldsax = NULL;
; 13776:     xmlNodePtr content, newRoot;
; 13777:     int size;
; 13778:     int ret = 0;
; 13779: 
; 13780:     if (depth > 40) {
; 13781: 	return(XML_ERR_ENTITY_LOOP);

	mov	eax, 89					; 00000059H

; 13907: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlParseBa:

; 13782:     }
; 13783: 
; 13784: 
; 13785:     if (lst != NULL)

	mov	eax, DWORD PTR _lst$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlParseBa

; 13786:         *lst = NULL;

	mov	DWORD PTR [eax], 0
$LN5@xmlParseBa:
	push	esi

; 13787:     if (string == NULL)

	mov	esi, DWORD PTR _string$[ebp]
	push	edi
	test	esi, esi
	je	$LN242@xmlParseBa

; 13788:         return(-1);
; 13789: 
; 13790:     size = xmlStrlen(string);

	push	esi
	call	_xmlStrlen

; 13791: 
; 13792:     ctxt = xmlCreateMemoryParserCtxt((char *) string, size);

	push	eax
	push	esi
	call	_xmlCreateMemoryParserCtxt
	mov	edi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ctxt$1$[ebp], edi

; 13793:     if (ctxt == NULL) return(-1);

	test	edi, edi
	je	$LN242@xmlParseBa

; 13794:     ctxt->userData = ctxt;
; 13795:     if (sax != NULL) {

	mov	eax, DWORD PTR _sax$[ebp]
	mov	DWORD PTR [edi+4], edi
	test	eax, eax
	je	SHORT $LN9@xmlParseBa

; 13796: 	oldsax = ctxt->sax;

	mov	ecx, DWORD PTR [edi]

; 13797:         ctxt->sax = sax;

	mov	DWORD PTR [edi], eax

; 13798: 	if (user_data != NULL)

	mov	eax, DWORD PTR _user_data$[ebp]
	mov	DWORD PTR _oldsax$1$[ebp], ecx
	test	eax, eax
	je	SHORT $LN9@xmlParseBa

; 13799: 	    ctxt->userData = user_data;

	mov	DWORD PTR [edi+4], eax
$LN9@xmlParseBa:
	push	ebx

; 13800:     }
; 13801:     newDoc = xmlNewDoc(BAD_CAST "1.0");

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlNewDoc
	mov	ebx, eax
	add	esp, 4

; 13802:     if (newDoc == NULL) {

	test	ebx, ebx
	jne	SHORT $LN10@xmlParseBa

; 13803: 	xmlFreeParserCtxt(ctxt);

	push	edi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13804: 	return(-1);

	or	eax, -1
	pop	ebx
	pop	edi
	pop	esi

; 13907: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlParseBa:

; 13805:     }
; 13806:     newDoc->properties = XML_DOC_INTERNAL;
; 13807:     if ((doc != NULL) && (doc->dict != NULL)) {

	mov	esi, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [ebx+92], 64			; 00000040H
	test	esi, esi
	je	SHORT $LN11@xmlParseBa
	cmp	DWORD PTR [esi+80], 0
	je	SHORT $LN11@xmlParseBa

; 13808:         xmlDictFree(ctxt->dict);

	push	DWORD PTR [edi+296]
	call	_xmlDictFree

; 13809: 	ctxt->dict = doc->dict;

	mov	eax, DWORD PTR [esi+80]

; 13810: 	xmlDictReference(ctxt->dict);

	push	eax
	mov	DWORD PTR [edi+296], eax
	call	_xmlDictReference

; 13811: 	ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);

	push	3
	push	OFFSET ??_C@_03PJHHNEEI@xml@
	push	DWORD PTR [edi+296]
	call	_xmlDictLookup

; 13812: 	ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);

	push	5
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR [edi+296]
	mov	DWORD PTR [edi+312], eax
	call	_xmlDictLookup

; 13813: 	ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);

	push	36					; 00000024H
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	DWORD PTR [edi+296]
	mov	DWORD PTR [edi+316], eax
	call	_xmlDictLookup
	add	esp, 44					; 0000002cH
	mov	DWORD PTR [edi+320], eax

; 13814: 	ctxt->dictNames = 1;

	mov	DWORD PTR [edi+364], 1

; 13815:     } else {

	jmp	SHORT $LN12@xmlParseBa
$LN11@xmlParseBa:

; 13816: 	xmlCtxtUseOptionsInternal(ctxt, XML_PARSE_NODICT, NULL);

	push	0
	push	4096					; 00001000H
	push	edi
	call	_xmlCtxtUseOptionsInternal
	add	esp, 12					; 0000000cH
$LN12@xmlParseBa:

; 13817:     }
; 13818:     if (doc != NULL) {

	test	esi, esi
	je	SHORT $LN13@xmlParseBa

; 13819: 	newDoc->intSubset = doc->intSubset;

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [ebx+44], eax

; 13820: 	newDoc->extSubset = doc->extSubset;

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [ebx+48], eax
$LN13@xmlParseBa:

; 13821:     }
; 13822:     newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST "pseudoroot", NULL);

	push	0
	push	OFFSET ??_C@_0L@OLLEMIAI@pseudoroot@
	push	0
	push	ebx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _newRoot$1$[ebp], eax

; 13823:     if (newRoot == NULL) {

	test	eax, eax
	jne	SHORT $LN14@xmlParseBa

; 13824: 	if (sax != NULL)

	cmp	DWORD PTR _sax$[ebp], eax
	je	SHORT $LN15@xmlParseBa

; 13825: 	    ctxt->sax = oldsax;

	mov	eax, DWORD PTR _oldsax$1$[ebp]
	mov	DWORD PTR [edi], eax
$LN15@xmlParseBa:

; 13826: 	xmlFreeParserCtxt(ctxt);

	push	edi
	call	_xmlFreeParserCtxt

; 13827: 	newDoc->intSubset = NULL;
; 13828: 	newDoc->extSubset = NULL;
; 13829:         xmlFreeDoc(newDoc);

	push	ebx
	mov	DWORD PTR [ebx+44], 0
	mov	DWORD PTR [ebx+48], 0
	call	_xmlFreeDoc
	add	esp, 8
	or	eax, -1
	pop	ebx
	pop	edi
	pop	esi

; 13907: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlParseBa:

; 13830: 	return(-1);
; 13831:     }
; 13832:     xmlAddChild((xmlNodePtr) newDoc, newRoot);

	push	eax
	push	ebx
	call	_xmlAddChild

; 13833:     nodePush(ctxt, newRoot);

	push	DWORD PTR _newRoot$1$[ebp]
	push	edi
	call	_nodePush
	add	esp, 16					; 00000010H
	mov	DWORD PTR [edi+8], ebx

; 13834:     if (doc == NULL) {

	test	esi, esi
	je	SHORT $LN17@xmlParseBa

; 13835: 	ctxt->myDoc = newDoc;
; 13836:     } else {
; 13837: 	ctxt->myDoc = newDoc;
; 13838: 	newDoc->children->doc = doc;

	mov	eax, DWORD PTR [ebx+12]

; 13839: 	/* Ensure that doc has XML spec namespace */
; 13840: 	xmlSearchNsByHref(doc, (xmlNodePtr)doc, XML_XML_NAMESPACE);

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	esi
	push	esi
	mov	DWORD PTR [eax+32], esi
	call	_xmlSearchNsByHref

; 13841: 	newDoc->oldNs = doc->oldNs;

	mov	eax, DWORD PTR [esi+52]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebx+52], eax
$LN17@xmlParseBa:

; 13842:     }
; 13843:     ctxt->instate = XML_PARSER_CONTENT;
; 13844:     ctxt->input_id = 2;
; 13845:     ctxt->depth = depth;

	mov	eax, DWORD PTR _depth$[ebp]

; 13846: 
; 13847:     /*
; 13848:      * Doing validity checking on chunk doesn't make sense
; 13849:      */
; 13850:     ctxt->validate = 0;
; 13851:     ctxt->loadsubset = 0;
; 13852:     xmlDetectSAX2(ctxt);

	push	edi
	mov	DWORD PTR [edi+172], 7
	mov	DWORD PTR [edi+464], 2
	mov	DWORD PTR [edi+248], eax
	mov	DWORD PTR [edi+104], 0
	mov	DWORD PTR [edi+276], 0
	call	_xmlDetectSAX2
	add	esp, 4

; 13853: 
; 13854:     if ( doc != NULL ){

	push	edi
	test	esi, esi
	je	SHORT $LN18@xmlParseBa

; 13855:         content = doc->children;
; 13856:         doc->children = NULL;

	mov	eax, DWORD PTR _doc$[ebp]
	mov	esi, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], 0

; 13857:         xmlParseContent(ctxt);

	call	_xmlParseContent

; 13858:         doc->children = content;

	mov	eax, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [eax+12], esi

; 13859:     }

	jmp	SHORT $LN246@xmlParseBa
$LN18@xmlParseBa:

; 13860:     else {
; 13861:         xmlParseContent(ctxt);

	call	_xmlParseContent
$LN246@xmlParseBa:

; 13862:     }
; 13863:     if ((RAW == '<') && (NXT(1) == '/')) {

	mov	eax, DWORD PTR [edi+36]
	add	esp, 4
	mov	eax, DWORD PTR [eax+16]
	mov	cl, BYTE PTR [eax]
	cmp	cl, 60					; 0000003cH
	jne	SHORT $LN20@xmlParseBa
	cmp	BYTE PTR [eax+1], 47			; 0000002fH
	jne	SHORT $LN20@xmlParseBa

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edi+212], 0
	je	SHORT $LN35@xmlParseBa
	cmp	DWORD PTR [edi+172], -1
	je	$LN166@xmlParseBa
$LN35@xmlParseBa:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [edi+84], 85			; 00000055H
	push	85					; 00000055H

; 556  :     }
; 557  : }

	jmp	SHORT $LN248@xmlParseBa
$LN20@xmlParseBa:

; 13864: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
; 13865:     } else if (RAW != 0) {

	test	cl, cl
	je	SHORT $LN166@xmlParseBa

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edi+212], 0
	je	SHORT $LN241@xmlParseBa
	cmp	DWORD PTR [edi+172], -1
	je	SHORT $LN166@xmlParseBa
$LN241@xmlParseBa:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0DA@BPKCCNLP@extra?5content?5at?5the?5end?5of?5wel@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [edi+84], 86			; 00000056H
	push	86					; 00000056H
$LN248@xmlParseBa:

; 13866: 	xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
; 13867:     }
; 13868:     if (ctxt->node != newDoc->children) {

	push	1
	push	0
	push	edi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	mov	DWORD PTR [edi+12], 0
	cmp	DWORD PTR [edi+288], 0
	jne	SHORT $LN166@xmlParseBa
	mov	DWORD PTR [edi+212], 1
$LN166@xmlParseBa:
	mov	eax, DWORD PTR [edi+52]
	cmp	eax, DWORD PTR [ebx+12]
	je	SHORT $LN234@xmlParseBa

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edi+212], 0
	je	SHORT $LN171@xmlParseBa
	cmp	DWORD PTR [edi+172], -1
	je	SHORT $LN234@xmlParseBa
$LN171@xmlParseBa:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	85					; 00000055H
	push	1
	push	0
	push	edi
	push	0
	push	0
	push	0
	mov	DWORD PTR [edi+84], 85			; 00000055H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;

	mov	DWORD PTR [edi+12], 0

; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [edi+288], 0
	jne	SHORT $LN234@xmlParseBa

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [edi+212], 1
$LN234@xmlParseBa:

; 13869: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
; 13870:     }
; 13871: 
; 13872:     if (!ctxt->wellFormed) {

	cmp	DWORD PTR [edi+12], 0
	jne	SHORT $LN24@xmlParseBa

; 13873:         if (ctxt->errNo == 0)

	mov	eax, DWORD PTR [edi+84]
	mov	ecx, 1
	test	eax, eax
	cmove	eax, ecx

; 13874: 	    ret = 1;
; 13875: 	else
; 13876: 	    ret = ctxt->errNo;
; 13877:     } else {

	jmp	SHORT $LN249@xmlParseBa
$LN24@xmlParseBa:

; 13878:       ret = 0;

	xor	eax, eax
$LN249@xmlParseBa:

; 13879:     }
; 13880: 
; 13881:     if ((lst != NULL) && ((ret == 0) || (recover == 1))) {

	mov	ecx, DWORD PTR _lst$[ebp]
	mov	DWORD PTR _ret$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN28@xmlParseBa
	test	eax, eax
	je	SHORT $LN29@xmlParseBa
	cmp	DWORD PTR _recover$[ebp], 1
	jne	SHORT $LN28@xmlParseBa
$LN29@xmlParseBa:

; 13882: 	xmlNodePtr cur;
; 13883: 
; 13884: 	/*
; 13885: 	 * Return the newly created nodeset after unlinking it from
; 13886: 	 * they pseudo parent.
; 13887: 	 */
; 13888: 	cur = newDoc->children->children;

	mov	eax, DWORD PTR [ebx+12]
	mov	esi, DWORD PTR [eax+12]

; 13889: 	*lst = cur;

	mov	DWORD PTR [ecx], esi

; 13890: 	while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlParseBa
	mov	edi, DWORD PTR _doc$[ebp]
	npad	7
$LL2@xmlParseBa:

; 13891: 	    xmlSetTreeDoc(cur, doc);

	push	edi
	push	esi
	call	_xmlSetTreeDoc

; 13892: 	    cur->parent = NULL;

	mov	DWORD PTR [esi+20], 0
	add	esp, 8

; 13893: 	    cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlParseBa
	mov	edi, DWORD PTR _ctxt$1$[ebp]
$LN3@xmlParseBa:

; 13894: 	}
; 13895: 	newDoc->children->children = NULL;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+12], 0
$LN28@xmlParseBa:

; 13896:     }
; 13897: 
; 13898:     if (sax != NULL)

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN30@xmlParseBa

; 13899: 	ctxt->sax = oldsax;

	mov	eax, DWORD PTR _oldsax$1$[ebp]
	mov	DWORD PTR [edi], eax
$LN30@xmlParseBa:

; 13900:     xmlFreeParserCtxt(ctxt);

	push	edi
	call	_xmlFreeParserCtxt

; 13901:     newDoc->intSubset = NULL;
; 13902:     newDoc->extSubset = NULL;
; 13903:     newDoc->oldNs = NULL;
; 13904:     xmlFreeDoc(newDoc);

	push	ebx
	mov	DWORD PTR [ebx+44], 0
	mov	DWORD PTR [ebx+48], 0
	mov	DWORD PTR [ebx+52], 0
	call	_xmlFreeDoc

; 13905: 
; 13906:     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 8
	pop	ebx
	pop	edi
	pop	esi

; 13907: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN242@xmlParseBa:
	pop	edi

; 13793:     if (ctxt == NULL) return(-1);

	or	eax, -1
	pop	esi

; 13907: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseBalancedChunkMemoryRecover ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseInNodeContext
_TEXT	SEGMENT
_fake$1$ = -20						; size = 4
_cur$1$ = -16						; size = 4
_nsnr$1$ = -12						; size = 4
_ihref$1$ = -8						; size = 4
_options$1$ = -8					; size = 4
_doc$1$ = -4						; size = 4
_node$ = 8						; size = 4
_data$ = 12						; size = 4
_datalen$ = 16						; size = 4
_options$ = 20						; size = 4
_lst$ = 24						; size = 4
_xmlParseInNodeContext PROC				; COMDAT

; 13536:                       int options, xmlNodePtr *lst) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	edi, edi
	mov	DWORD PTR _nsnr$1$[ebp], edi
	cmp	DWORD PTR _lst$[ebp], edi
	je	SHORT $LN13@xmlParseIn

; 13537: #ifdef SAX2
; 13538:     xmlParserCtxtPtr ctxt;
; 13539:     xmlDocPtr doc = NULL;
; 13540:     xmlNodePtr fake, cur;
; 13541:     int nsnr = 0;
; 13542: 
; 13543:     xmlParserErrors ret = XML_ERR_OK;
; 13544: 
; 13545:     /*
; 13546:      * check all input parameters, grab the document
; 13547:      */
; 13548:     if ((lst == NULL) || (node == NULL) || (data == NULL) || (datalen < 0))

	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	SHORT $LN13@xmlParseIn
	mov	ecx, DWORD PTR _data$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@xmlParseIn
	mov	edx, DWORD PTR _datalen$[ebp]
	test	edx, edx
	js	SHORT $LN13@xmlParseIn

; 13549:         return(XML_ERR_INTERNAL_ERROR);
; 13550:     switch (node->type) {

	mov	eax, DWORD PTR [ebx+4]
	dec	eax
	cmp	eax, 12					; 0000000cH
	ja	SHORT $LN13@xmlParseIn
	movzx	eax, BYTE PTR $LN288@xmlParseIn[eax]
	jmp	DWORD PTR $LN315@xmlParseIn[eax*4]
	npad	7
$LL4@xmlParseIn:

; 13551:         case XML_ELEMENT_NODE:
; 13552:         case XML_ATTRIBUTE_NODE:
; 13553:         case XML_TEXT_NODE:
; 13554:         case XML_CDATA_SECTION_NODE:
; 13555:         case XML_ENTITY_REF_NODE:
; 13556:         case XML_PI_NODE:
; 13557:         case XML_COMMENT_NODE:
; 13558:         case XML_DOCUMENT_NODE:
; 13559:         case XML_HTML_DOCUMENT_NODE:
; 13560: 	    break;
; 13561: 	default:
; 13562: 	    return(XML_ERR_INTERNAL_ERROR);
; 13563: 
; 13564:     }
; 13565:     while ((node != NULL) && (node->type != XML_ELEMENT_NODE) &&
; 13566:            (node->type != XML_DOCUMENT_NODE) &&

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, 1
	je	SHORT $LN307@xmlParseIn
	cmp	eax, 9
	je	SHORT $LN16@xmlParseIn
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN16@xmlParseIn

; 13567: 	   (node->type != XML_HTML_DOCUMENT_NODE))
; 13568: 	node = node->parent;

	mov	ebx, DWORD PTR [ebx+20]
	mov	DWORD PTR _node$[ebp], ebx
	test	ebx, ebx
	jne	SHORT $LL4@xmlParseIn
$LN13@xmlParseIn:
	pop	edi

; 13738: #else /* !SAX2 */
; 13739:     return(XML_ERR_INTERNAL_ERROR);
; 13740: #endif
; 13741: }

	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlParseIn:

; 13569:     if (node == NULL)
; 13570: 	return(XML_ERR_INTERNAL_ERROR);
; 13571:     if (node->type == XML_ELEMENT_NODE)

	cmp	eax, 1
	jne	SHORT $LN17@xmlParseIn
$LN307@xmlParseIn:

; 13572: 	doc = node->doc;

	mov	eax, DWORD PTR [ebx+32]
	mov	DWORD PTR _doc$1$[ebp], eax
	jmp	SHORT $LN18@xmlParseIn
$LN17@xmlParseIn:

; 13573:     else
; 13574:         doc = (xmlDocPtr) node;

	mov	eax, ebx
	mov	DWORD PTR _doc$1$[ebp], ebx
$LN18@xmlParseIn:

; 13575:     if (doc == NULL)

	test	eax, eax
	je	SHORT $LN13@xmlParseIn

; 13576: 	return(XML_ERR_INTERNAL_ERROR);
; 13577: 
; 13578:     /*
; 13579:      * allocate a context and set-up everything not related to the
; 13580:      * node position in the tree
; 13581:      */
; 13582:     if (doc->type == XML_DOCUMENT_NODE)

	mov	eax, DWORD PTR [eax+4]
	cmp	eax, 9
	jne	SHORT $LN20@xmlParseIn

; 13583: 	ctxt = xmlCreateMemoryParserCtxt((char *) data, datalen);

	push	edx
	push	ecx
	call	_xmlCreateMemoryParserCtxt
	mov	esi, eax
	add	esp, 8
	mov	eax, DWORD PTR _options$[ebp]
	jmp	SHORT $LN308@xmlParseIn
$LN20@xmlParseIn:

; 13584: #ifdef LIBXML_HTML_ENABLED
; 13585:     else if (doc->type == XML_HTML_DOCUMENT_NODE) {

	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN13@xmlParseIn

; 13586: 	ctxt = htmlCreateMemoryParserCtxt((char *) data, datalen);

	push	edx
	push	ecx
	call	_htmlCreateMemoryParserCtxt
	mov	esi, eax
	add	esp, 8

; 13587:         /*
; 13588:          * When parsing in context, it makes no sense to add implied
; 13589:          * elements like html/body/etc...
; 13590:          */
; 13591:         options |= HTML_PARSE_NOIMPLIED;

	mov	eax, DWORD PTR _options$[ebp]
	or	eax, 8192				; 00002000H
$LN308@xmlParseIn:

; 13592:     }
; 13593: #endif
; 13594:     else
; 13595:         return(XML_ERR_INTERNAL_ERROR);
; 13596: 
; 13597:     if (ctxt == NULL)

	mov	DWORD PTR _options$1$[ebp], eax
	test	esi, esi
	je	$LN313@xmlParseIn

; 13598:         return(XML_ERR_NO_MEMORY);
; 13599: 
; 13600:     /*
; 13601:      * Use input doc's dict if present, else assure XML_PARSE_NODICT is set.
; 13602:      * We need a dictionary for xmlDetectSAX2, so if there's no doc dict
; 13603:      * we must wait until the last moment to free the original one.
; 13604:      */
; 13605:     if (doc->dict != NULL) {

	mov	edx, DWORD PTR _doc$1$[ebp]
	mov	ecx, DWORD PTR [edx+80]
	test	ecx, ecx
	je	SHORT $LN25@xmlParseIn

; 13606:         if (ctxt->dict != NULL)

	mov	eax, DWORD PTR [esi+296]
	test	eax, eax
	je	SHORT $LN27@xmlParseIn

; 13607: 	    xmlDictFree(ctxt->dict);

	push	eax
	call	_xmlDictFree
	mov	edx, DWORD PTR _doc$1$[ebp]
	add	esp, 4
	mov	ecx, DWORD PTR [edx+80]
$LN27@xmlParseIn:

; 13608: 	ctxt->dict = doc->dict;

	mov	DWORD PTR [esi+296], ecx

; 13609:     } else

	jmp	SHORT $LN26@xmlParseIn
$LN25@xmlParseIn:

; 13610:         options |= XML_PARSE_NODICT;

	or	eax, 4096				; 00001000H
	mov	DWORD PTR _options$1$[ebp], eax
$LN26@xmlParseIn:

; 13611: 
; 13612:     if (doc->encoding != NULL) {

	mov	eax, DWORD PTR [edx+60]
	test	eax, eax
	je	SHORT $LN31@xmlParseIn

; 13613:         xmlCharEncodingHandlerPtr hdlr;
; 13614: 
; 13615:         if (ctxt->encoding != NULL)

	mov	ecx, DWORD PTR [esi+24]
	test	ecx, ecx
	je	SHORT $LN29@xmlParseIn

; 13616: 	    xmlFree((xmlChar *) ctxt->encoding);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _doc$1$[ebp]
	add	esp, 4
	mov	eax, DWORD PTR [eax+60]
$LN29@xmlParseIn:

; 13617:         ctxt->encoding = xmlStrdup((const xmlChar *) doc->encoding);

	push	eax
	call	_xmlStrdup
	mov	DWORD PTR [esi+24], eax

; 13618: 
; 13619:         hdlr = xmlFindCharEncodingHandler((const char *) doc->encoding);

	mov	eax, DWORD PTR _doc$1$[ebp]
	push	DWORD PTR [eax+60]
	call	_xmlFindCharEncodingHandler
	add	esp, 8

; 13620:         if (hdlr != NULL) {

	test	eax, eax
	je	SHORT $LN30@xmlParseIn

; 13621:             xmlSwitchToEncoding(ctxt, hdlr);

	push	eax
	push	esi
	call	_xmlSwitchToEncoding
	add	esp, 8
$LN31@xmlParseIn:

; 13622: 	} else {
; 13623:             return(XML_ERR_UNSUPPORTED_ENCODING);
; 13624:         }
; 13625:     }
; 13626: 
; 13627:     xmlCtxtUseOptionsInternal(ctxt, options, NULL);

	push	0
	push	DWORD PTR _options$1$[ebp]
	push	esi
	call	_xmlCtxtUseOptionsInternal

; 13628:     xmlDetectSAX2(ctxt);

	push	esi
	call	_xmlDetectSAX2

; 13629:     ctxt->myDoc = doc;

	mov	eax, DWORD PTR _doc$1$[ebp]

; 13630:     /* parsing in context, i.e. as within existing content */
; 13631:     ctxt->input_id = 2;
; 13632:     ctxt->instate = XML_PARSER_CONTENT;
; 13633: 
; 13634:     fake = xmlNewComment(NULL);

	push	0
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+464], 2
	mov	DWORD PTR [esi+172], 7
	call	_xmlNewComment
	add	esp, 20					; 00000014H
	mov	DWORD PTR _fake$1$[ebp], eax

; 13635:     if (fake == NULL) {

	test	eax, eax
	jne	SHORT $LN32@xmlParseIn

; 13636:         xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4
$LN313@xmlParseIn:

; 13738: #else /* !SAX2 */
; 13739:     return(XML_ERR_INTERNAL_ERROR);
; 13740: #endif
; 13741: }

	pop	edi
	pop	esi
	mov	eax, 2
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@xmlParseIn:
	pop	edi
	pop	esi
	mov	eax, 32					; 00000020H
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@xmlParseIn:

; 13637: 	return(XML_ERR_NO_MEMORY);
; 13638:     }
; 13639:     xmlAddChild(node, fake);

	push	eax
	push	ebx
	call	_xmlAddChild
	add	esp, 8

; 13640: 
; 13641:     if (node->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [ebx+4], 1
	jne	$LN7@xmlParseIn

; 13642: 	nodePush(ctxt, node);

	push	ebx
	push	esi
	call	_nodePush
	add	esp, 8

; 13643: 	/*
; 13644: 	 * initialize the SAX2 namespaces stack
; 13645: 	 */
; 13646: 	cur = node;

	mov	DWORD PTR _cur$1$[ebp], ebx
	mov	eax, ebx
$LL6@xmlParseIn:

; 13647: 	while ((cur != NULL) && (cur->type == XML_ELEMENT_NODE)) {

	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN301@xmlParseIn

; 13648: 	    xmlNsPtr ns = cur->nsDef;

	mov	edi, DWORD PTR [eax+48]

; 13649: 	    const xmlChar *iprefix, *ihref;
; 13650: 
; 13651: 	    while (ns != NULL) {

	test	edi, edi
	je	SHORT $LN9@xmlParseIn
	npad	2
$LL8@xmlParseIn:

; 13652: 		if (ctxt->dict) {

	mov	eax, DWORD PTR [esi+296]
	mov	ebx, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN34@xmlParseIn

; 13653: 		    iprefix = xmlDictLookup(ctxt->dict, ns->prefix, -1);

	push	-1
	push	ebx
	push	eax
	call	_xmlDictLookup

; 13654: 		    ihref = xmlDictLookup(ctxt->dict, ns->href, -1);

	push	-1
	push	DWORD PTR [edi+8]
	mov	ebx, eax
	push	DWORD PTR [esi+296]
	call	_xmlDictLookup
	add	esp, 24					; 00000018H

; 13655: 		} else {

	jmp	SHORT $LN309@xmlParseIn
$LN34@xmlParseIn:

; 13656: 		    iprefix = ns->prefix;
; 13657: 		    ihref = ns->href;

	mov	eax, DWORD PTR [edi+8]
$LN309@xmlParseIn:

; 13658: 		}
; 13659: 
; 13660: 	        if (xmlGetNamespace(ctxt, iprefix) == NULL) {

	push	ebx
	push	esi
	mov	DWORD PTR _ihref$1$[ebp], eax
	call	_xmlGetNamespace
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN36@xmlParseIn

; 13661: 		    nsPush(ctxt, iprefix, ihref);

	push	DWORD PTR _ihref$1$[ebp]
	push	ebx
	push	esi
	call	_nsPush
	add	esp, 12					; 0000000cH

; 13662: 		    nsnr++;

	inc	DWORD PTR _nsnr$1$[ebp]
$LN36@xmlParseIn:

; 13663: 		}
; 13664: 		ns = ns->next;

	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	SHORT $LL8@xmlParseIn
	mov	eax, DWORD PTR _cur$1$[ebp]
$LN9@xmlParseIn:

; 13665: 	    }
; 13666: 	    cur = cur->parent;

	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _cur$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LL6@xmlParseIn
$LN301@xmlParseIn:
	mov	ebx, DWORD PTR _node$[ebp]
	mov	edi, DWORD PTR _nsnr$1$[ebp]
$LN7@xmlParseIn:

; 13667: 	}
; 13668:     }
; 13669: 
; 13670:     if ((ctxt->validate) || (ctxt->replaceEntities != 0)) {

	cmp	DWORD PTR [esi+104], 0
	jne	SHORT $LN38@xmlParseIn
	cmp	DWORD PTR [esi+16], 0
	je	SHORT $LN37@xmlParseIn
$LN38@xmlParseIn:

; 13671: 	/*
; 13672: 	 * ID/IDREF registration will be done in xmlValidateElement below
; 13673: 	 */
; 13674: 	ctxt->loadsubset |= XML_SKIP_IDS;

	or	DWORD PTR [esi+276], 8
$LN37@xmlParseIn:

; 13675:     }
; 13676: 
; 13677: #ifdef LIBXML_HTML_ENABLED
; 13678:     if (doc->type == XML_HTML_DOCUMENT_NODE)

	mov	eax, DWORD PTR _doc$1$[ebp]
	push	esi
	cmp	DWORD PTR [eax+4], 13			; 0000000dH
	jne	SHORT $LN39@xmlParseIn

; 13679:         __htmlParseContent(ctxt);

	call	___htmlParseContent
	jmp	SHORT $LN310@xmlParseIn
$LN39@xmlParseIn:

; 13680:     else
; 13681: #endif
; 13682: 	xmlParseContent(ctxt);

	call	_xmlParseContent
$LN310@xmlParseIn:

; 13683: 
; 13684:     nsPop(ctxt, nsnr);

	add	esp, 4
	push	edi
	push	esi
	call	_nsPop

; 13685:     if ((RAW == '<') && (NXT(1) == '/')) {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 8
	mov	eax, DWORD PTR [eax+16]
	mov	cl, BYTE PTR [eax]
	cmp	cl, 60					; 0000003cH
	jne	SHORT $LN41@xmlParseIn
	cmp	BYTE PTR [eax+1], 47			; 0000002fH
	jne	SHORT $LN41@xmlParseIn

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN56@xmlParseIn
	cmp	DWORD PTR [esi+172], -1
	je	$LN187@xmlParseIn
$LN56@xmlParseIn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 85			; 00000055H
	push	85					; 00000055H

; 556  :     }
; 557  : }

	jmp	SHORT $LN312@xmlParseIn
$LN41@xmlParseIn:

; 13686: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
; 13687:     } else if (RAW != 0) {

	test	cl, cl
	je	SHORT $LN187@xmlParseIn

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN279@xmlParseIn
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN187@xmlParseIn
$LN279@xmlParseIn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0DA@BPKCCNLP@extra?5content?5at?5the?5end?5of?5wel@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 86			; 00000056H
	push	86					; 00000056H
$LN312@xmlParseIn:

; 13688: 	xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
; 13689:     }
; 13690:     if ((ctxt->node != NULL) && (ctxt->node != node)) {

	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	mov	DWORD PTR [esi+12], 0
	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN187@xmlParseIn
	mov	DWORD PTR [esi+212], 1
$LN187@xmlParseIn:
	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN44@xmlParseIn
	cmp	eax, ebx
	je	SHORT $LN44@xmlParseIn

; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN192@xmlParseIn
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN255@xmlParseIn
$LN192@xmlParseIn:

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;
; 359  :     switch (error) {
; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";
; 362  :             break;
; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";
; 365  :             break;
; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";
; 368  :             break;
; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";
; 371  :             break;
; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";
; 374  :             break;
; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";
; 377  :             break;
; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";
; 380  :             break;
; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";
; 383  :             break;
; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";
; 386  :             break;
; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";
; 389  :             break;
; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";
; 392  :             break;
; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";
; 395  :             break;
; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";
; 398  :             break;
; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";
; 401  :             break;
; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";
; 404  :             break;
; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";
; 407  :             break;
; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";
; 410  :             break;
; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";
; 413  :             break;
; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";
; 416  :             break;
; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";
; 419  :             break;
; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";
; 422  :             break;
; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";
; 425  :             break;
; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";
; 428  :             break;
; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";
; 431  :             break;
; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";
; 434  :             break;
; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";
; 437  :             break;
; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";
; 440  :             break;
; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";
; 443  :             break;
; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";
; 446  :             break;
; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";
; 449  :             break;
; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";
; 452  :             break;
; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";
; 455  :             break;
; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";
; 458  :             break;
; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";
; 461  :             break;
; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =
; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;
; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";
; 468  :             break;
; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";
; 471  :             break;
; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";
; 474  :             break;
; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =
; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;
; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";
; 481  :             break;
; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";
; 484  :             break;
; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";
; 487  :             break;
; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";
; 490  :             break;
; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";
; 493  :             break;
; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";
; 496  :             break;
; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";
; 499  :             break;
; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";
; 502  :             break;
; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";
; 505  :             break;
; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";
; 508  :             break;
; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";
; 511  :             break;
; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";
; 514  :             break;
; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";
; 517  :             break;
; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";
; 520  :             break;
; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";
; 523  :             break;
; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";
; 526  :             break;
; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";
; 529  :             break;
; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";
; 532  :             break;
; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";
; 540  :     }
; 541  :     if (ctxt != NULL)
; 542  : 	ctxt->errNo = error;
; 543  :     if (info == NULL) {
; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	85					; 00000055H
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 85			; 00000055H
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;
; 554  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN255@xmlParseIn

; 555  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN255@xmlParseIn:

; 13691: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
; 13692: 	ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0
$LN44@xmlParseIn:

; 13693:     }
; 13694: 
; 13695:     if (!ctxt->wellFormed) {

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN45@xmlParseIn

; 13696:         if (ctxt->errNo == 0)

	mov	edi, DWORD PTR [esi+84]
	mov	eax, 1
	test	edi, edi
	cmove	edi, eax

; 13697: 	    ret = XML_ERR_INTERNAL_ERROR;
; 13698: 	else
; 13699: 	    ret = (xmlParserErrors)ctxt->errNo;
; 13700:     } else {

	jmp	SHORT $LN46@xmlParseIn
$LN45@xmlParseIn:

; 13701:         ret = XML_ERR_OK;

	xor	edi, edi
$LN46@xmlParseIn:

; 13702:     }
; 13703: 
; 13704:     /*
; 13705:      * Return the newly created nodeset after unlinking it from
; 13706:      * the pseudo sibling.
; 13707:      */
; 13708: 
; 13709:     cur = fake->next;

	mov	ecx, DWORD PTR _fake$1$[ebp]
	mov	eax, DWORD PTR [ecx+24]

; 13710:     fake->next = NULL;

	mov	DWORD PTR [ecx+24], 0

; 13711:     node->last = fake;

	mov	DWORD PTR [ebx+16], ecx

; 13712: 
; 13713:     if (cur != NULL) {

	test	eax, eax
	je	SHORT $LN49@xmlParseIn

; 13714: 	cur->prev = NULL;

	mov	DWORD PTR [eax+28], 0
$LN49@xmlParseIn:

; 13715:     }
; 13716: 
; 13717:     *lst = cur;

	mov	ebx, DWORD PTR _lst$[ebp]
	mov	DWORD PTR [ebx], eax

; 13718: 
; 13719:     while (cur != NULL) {

	test	eax, eax
	je	SHORT $LN11@xmlParseIn
	npad	4
$LL10@xmlParseIn:

; 13720: 	cur->parent = NULL;

	mov	DWORD PTR [eax+20], 0

; 13721: 	cur = cur->next;

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL10@xmlParseIn
$LN11@xmlParseIn:

; 13722:     }
; 13723: 
; 13724:     xmlUnlinkNode(fake);

	push	ecx
	call	_xmlUnlinkNode

; 13725:     xmlFreeNode(fake);

	push	DWORD PTR _fake$1$[ebp]
	call	_xmlFreeNode
	add	esp, 8

; 13726: 
; 13727: 
; 13728:     if (ret != XML_ERR_OK) {

	test	edi, edi
	je	SHORT $LN50@xmlParseIn

; 13729:         xmlFreeNodeList(*lst);

	push	DWORD PTR [ebx]
	call	_xmlFreeNodeList
	add	esp, 4

; 13730: 	*lst = NULL;

	mov	DWORD PTR [ebx], 0
$LN50@xmlParseIn:

; 13731:     }
; 13732: 
; 13733:     if (doc->dict != NULL)

	mov	eax, DWORD PTR _doc$1$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN51@xmlParseIn

; 13734:         ctxt->dict = NULL;

	mov	DWORD PTR [esi+296], 0
$LN51@xmlParseIn:

; 13735:     xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13736: 
; 13737:     return(ret);

	mov	eax, edi
	pop	edi

; 13738: #else /* !SAX2 */
; 13739:     return(XML_ERR_INTERNAL_ERROR);
; 13740: #endif
; 13741: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN315@xmlParseIn:
	DD	$LL4@xmlParseIn
	DD	$LN13@xmlParseIn
$LN288@xmlParseIn:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	0
_xmlParseInNodeContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseBalancedChunkMemory
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_sax$ = 12						; size = 4
_user_data$ = 16					; size = 4
_depth$ = 20						; size = 4
_string$ = 24						; size = 4
_lst$ = 28						; size = 4
_xmlParseBalancedChunkMemory PROC			; COMDAT

; 13314:      void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _lst$[ebp]
	push	DWORD PTR _string$[ebp]
	push	DWORD PTR _depth$[ebp]
	push	DWORD PTR _user_data$[ebp]
	push	DWORD PTR _sax$[ebp]
	push	DWORD PTR _doc$[ebp]
	call	_xmlParseBalancedChunkMemoryRecover
	add	esp, 28					; 0000001cH

; 13315:     return xmlParseBalancedChunkMemoryRecover( doc, sax, user_data,
; 13316:                                                 depth, string, lst, 0 );
; 13317: }

	pop	ebp
	ret	0
_xmlParseBalancedChunkMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlIOParseDTD
_TEXT	SEGMENT
_start$ = -4						; size = 4
_sax$ = 8						; size = 4
_input$ = 12						; size = 4
_enc$ = 16						; size = 4
_xmlIOParseDTD PROC					; COMDAT

; 12579: 	      xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _input$[ebp]
	xor	ebx, ebx
	test	edi, edi
	jne	SHORT $LN4@xmlIOParse

; 12580:     xmlDtdPtr ret = NULL;
; 12581:     xmlParserCtxtPtr ctxt;
; 12582:     xmlParserInputPtr pinput = NULL;
; 12583:     xmlChar start[4];
; 12584: 
; 12585:     if (input == NULL)
; 12586: 	return(NULL);

	pop	edi
	xor	eax, eax

; 12695: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlIOParse:
	push	esi

; 12587: 
; 12588:     ctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	esi, eax

; 12589:     if (ctxt == NULL) {

	test	esi, esi
	jne	SHORT $LN5@xmlIOParse

; 12590:         xmlFreeParserInputBuffer(input);

	push	edi
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 12591: 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 12695: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlIOParse:

; 12592:     }
; 12593: 
; 12594:     /* We are loading a DTD */
; 12595:     ctxt->options |= XML_PARSE_DTDLOAD;

	or	DWORD PTR [esi+360], 4

; 12596: 
; 12597:     /*
; 12598:      * Set-up the SAX context
; 12599:      */
; 12600:     if (sax != NULL) {

	mov	eax, DWORD PTR _sax$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlIOParse

; 12601: 	if (ctxt->sax != NULL)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN7@xmlIOParse

; 12602: 	    xmlFree(ctxt->sax);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _sax$[ebp]
	add	esp, 4
$LN7@xmlIOParse:

; 12603:         ctxt->sax = sax;

	mov	DWORD PTR [esi], eax

; 12604:         ctxt->userData = ctxt;

	mov	DWORD PTR [esi+4], esi
$LN6@xmlIOParse:

; 12605:     }
; 12606:     xmlDetectSAX2(ctxt);

	push	esi
	call	_xmlDetectSAX2

; 12607: 
; 12608:     /*
; 12609:      * generate a parser input from the I/O handler
; 12610:      */
; 12611: 
; 12612:     pinput = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);

	push	0
	push	edi
	push	esi
	call	_xmlNewIOInputStream
	mov	edi, eax
	add	esp, 16					; 00000010H

; 12613:     if (pinput == NULL) {

	test	edi, edi
	jne	SHORT $LN8@xmlIOParse

; 12614:         if (sax != NULL) ctxt->sax = NULL;

	cmp	DWORD PTR _sax$[ebp], ebx
	je	SHORT $LN9@xmlIOParse
	mov	DWORD PTR [esi], ebx
$LN9@xmlIOParse:

; 12615:         xmlFreeParserInputBuffer(input);

	push	DWORD PTR _input$[ebp]
	call	_xmlFreeParserInputBuffer

; 12616: 	xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 8

; 12617: 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 12695: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlIOParse:

; 12618:     }
; 12619: 
; 12620:     /*
; 12621:      * plug some encoding conversion routines here.
; 12622:      */
; 12623:     if (xmlPushInput(ctxt, pinput) < 0) {

	push	edi
	push	esi
	call	_xmlPushInput
	add	esp, 8
	test	eax, eax
	jns	SHORT $LN10@xmlIOParse

; 12624:         if (sax != NULL) ctxt->sax = NULL;

	cmp	DWORD PTR _sax$[ebp], ebx
	je	SHORT $LN11@xmlIOParse
	mov	DWORD PTR [esi], ebx
$LN11@xmlIOParse:

; 12625: 	xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12626: 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 12695: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlIOParse:

; 12627:     }
; 12628:     if (enc != XML_CHAR_ENCODING_NONE) {

	mov	eax, DWORD PTR _enc$[ebp]
	test	eax, eax
	je	SHORT $LN12@xmlIOParse

; 12629:         xmlSwitchEncoding(ctxt, enc);

	push	eax
	push	esi
	call	_xmlSwitchEncoding
	add	esp, 8
$LN12@xmlIOParse:

; 12630:     }
; 12631: 
; 12632:     pinput->filename = NULL;

	mov	DWORD PTR [edi+4], ebx

; 12633:     pinput->line = 1;

	mov	DWORD PTR [edi+28], 1

; 12634:     pinput->col = 1;

	mov	DWORD PTR [edi+32], 1

; 12635:     pinput->base = ctxt->input->cur;

	mov	eax, DWORD PTR [esi+36]

; 12636:     pinput->cur = ctxt->input->cur;
; 12637:     pinput->free = NULL;
; 12638: 
; 12639:     /*
; 12640:      * let's parse that entity knowing it's an external subset.
; 12641:      */
; 12642:     ctxt->inSubset = 2;
; 12643:     ctxt->myDoc = xmlNewDoc(BAD_CAST "1.0");

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+40], ebx
	mov	DWORD PTR [esi+216], 2
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 12644:     if (ctxt->myDoc == NULL) {

	test	eax, eax
	jne	SHORT $LN13@xmlIOParse

; 12645: 	xmlErrMemory(ctxt, "New Doc failed");

	push	OFFSET ??_C@_0P@IDBIGKBI@New?5Doc?5failed@
	push	esi
	call	_xmlErrMemory
	add	esp, 8

; 12646: 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 12695: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlIOParse:

; 12647:     }
; 12648:     ctxt->myDoc->properties = XML_DOC_INTERNAL;
; 12649:     ctxt->myDoc->extSubset = xmlNewDtd(ctxt->myDoc, BAD_CAST "none",

	push	OFFSET ??_C@_04CGFJFPFD@none@
	push	OFFSET ??_C@_04CGFJFPFD@none@
	mov	DWORD PTR [eax+92], 64			; 00000040H
	push	OFFSET ??_C@_04CGFJFPFD@none@
	push	DWORD PTR [esi+8]
	call	_xmlNewDtd
	mov	ecx, DWORD PTR [esi+8]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx+48], eax

; 12650: 	                               BAD_CAST "none", BAD_CAST "none");
; 12651: 
; 12652:     if ((enc == XML_CHAR_ENCODING_NONE) &&

	cmp	DWORD PTR _enc$[ebp], ebx
	jne	SHORT $LN15@xmlIOParse
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	cmp	eax, 4
	jl	SHORT $LN15@xmlIOParse

; 12653:         ((ctxt->input->end - ctxt->input->cur) >= 4)) {
; 12654: 	/*
; 12655: 	 * Get the 4 first bytes and decode the charset
; 12656: 	 * if enc != XML_CHAR_ENCODING_NONE
; 12657: 	 * plug some encoding conversion routines.
; 12658: 	 */
; 12659: 	start[0] = RAW;

	movzx	eax, BYTE PTR [ecx]
	mov	BYTE PTR _start$[ebp], al

; 12660: 	start[1] = NXT(1);

	mov	eax, DWORD PTR [esi+36]

; 12661: 	start[2] = NXT(2);
; 12662: 	start[3] = NXT(3);
; 12663: 	enc = xmlDetectCharEncoding(start, 4);

	push	4
	mov	eax, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [eax+1]
	mov	BYTE PTR _start$[ebp+1], al
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [eax+2]
	mov	BYTE PTR _start$[ebp+2], al
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [eax+3]
	mov	BYTE PTR _start$[ebp+3], al
	lea	eax, DWORD PTR _start$[ebp]
	push	eax
	call	_xmlDetectCharEncoding
	add	esp, 8

; 12664: 	if (enc != XML_CHAR_ENCODING_NONE) {

	test	eax, eax
	je	SHORT $LN15@xmlIOParse

; 12665: 	    xmlSwitchEncoding(ctxt, enc);

	push	eax
	push	esi
	call	_xmlSwitchEncoding
	add	esp, 8
$LN15@xmlIOParse:

; 12666: 	}
; 12667:     }
; 12668: 
; 12669:     xmlParseExternalSubset(ctxt, BAD_CAST "none", BAD_CAST "none");

	push	OFFSET ??_C@_04CGFJFPFD@none@
	push	OFFSET ??_C@_04CGFJFPFD@none@
	push	esi
	call	_xmlParseExternalSubset

; 12670: 
; 12671:     if (ctxt->myDoc != NULL) {

	mov	eax, DWORD PTR [esi+8]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN16@xmlIOParse

; 12672: 	if (ctxt->wellFormed) {

	cmp	DWORD PTR [esi+12], ebx
	je	SHORT $LN17@xmlIOParse

; 12673: 	    ret = ctxt->myDoc->extSubset;

	mov	ebx, DWORD PTR [eax+48]

; 12674: 	    ctxt->myDoc->extSubset = NULL;

	mov	DWORD PTR [eax+48], 0

; 12675: 	    if (ret != NULL) {

	test	ebx, ebx
	je	SHORT $LN3@xmlIOParse

; 12676: 		xmlNodePtr tmp;
; 12677: 
; 12678: 		ret->doc = NULL;
; 12679: 		tmp = ret->children;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [ebx+32], 0

; 12680: 		while (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlIOParse
$LL2@xmlIOParse:

; 12681: 		    tmp->doc = NULL;

	mov	DWORD PTR [eax+32], 0

; 12682: 		    tmp = tmp->next;

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL2@xmlIOParse
$LN3@xmlIOParse:

; 12683: 		}
; 12684: 	    }
; 12685: 	} else {

	mov	eax, DWORD PTR [esi+8]
	jmp	SHORT $LN18@xmlIOParse
$LN17@xmlIOParse:

; 12686: 	    ret = NULL;

	xor	ebx, ebx
$LN18@xmlIOParse:

; 12687: 	}
; 12688:         xmlFreeDoc(ctxt->myDoc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 12689:         ctxt->myDoc = NULL;

	mov	DWORD PTR [esi+8], 0
$LN16@xmlIOParse:

; 12690:     }
; 12691:     if (sax != NULL) ctxt->sax = NULL;

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN20@xmlIOParse
	mov	DWORD PTR [esi], 0
$LN20@xmlIOParse:

; 12692:     xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12693: 
; 12694:     return(ret);

	mov	eax, ebx
	pop	esi
	pop	edi

; 12695: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlIOParseDTD ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseDTD
_TEXT	SEGMENT
_ExternalID$ = 8					; size = 4
_SystemID$ = 12						; size = 4
_xmlParseDTD PROC					; COMDAT

; 12840: xmlParseDTD(const xmlChar *ExternalID, const xmlChar *SystemID) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _SystemID$[ebp]
	push	DWORD PTR _ExternalID$[ebp]
	push	0
	call	_xmlSAXParseDTD
	add	esp, 12					; 0000000cH

; 12841:     return(xmlSAXParseDTD(NULL, ExternalID, SystemID));
; 12842: }

	pop	ebp
	ret	0
_xmlParseDTD ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXParseDTD
_TEXT	SEGMENT
_input$1$ = -8						; size = 4
_ret$1$ = -4						; size = 4
_sax$ = 8						; size = 4
_ExternalID$ = 12					; size = 4
_SystemID$ = 16						; size = 4
_xmlSAXParseDTD PROC					; COMDAT

; 12710:                           const xmlChar *SystemID) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _ExternalID$[ebp], 0
	mov	edi, DWORD PTR _SystemID$[ebp]
	mov	DWORD PTR _ret$1$[ebp], 0
	jne	SHORT $LN4@xmlSAXPars

; 12711:     xmlDtdPtr ret = NULL;
; 12712:     xmlParserCtxtPtr ctxt;
; 12713:     xmlParserInputPtr input = NULL;
; 12714:     xmlCharEncoding enc;
; 12715:     xmlChar* systemIdCanonic;
; 12716: 
; 12717:     if ((ExternalID == NULL) && (SystemID == NULL)) return(NULL);

	test	edi, edi
	je	$LN15@xmlSAXPars
$LN4@xmlSAXPars:

; 12718: 
; 12719:     ctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	esi, eax

; 12720:     if (ctxt == NULL) {

	test	esi, esi
	je	$LN15@xmlSAXPars

; 12721: 	return(NULL);
; 12722:     }
; 12723: 
; 12724:     /* We are loading a DTD */
; 12725:     ctxt->options |= XML_PARSE_DTDLOAD;

	or	DWORD PTR [esi+360], 4

; 12726: 
; 12727:     /*
; 12728:      * Set-up the SAX context
; 12729:      */
; 12730:     if (sax != NULL) {

	mov	ebx, DWORD PTR _sax$[ebp]
	test	ebx, ebx
	je	SHORT $LN33@xmlSAXPars

; 12731: 	if (ctxt->sax != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@xmlSAXPars

; 12732: 	    xmlFree(ctxt->sax);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlSAXPars:

; 12733:         ctxt->sax = sax;

	mov	DWORD PTR [esi], ebx

; 12734:         ctxt->userData = ctxt;

	mov	DWORD PTR [esi+4], esi
$LN33@xmlSAXPars:

; 12735:     }
; 12736: 
; 12737:     /*
; 12738:      * Canonicalise the system ID
; 12739:      */
; 12740:     systemIdCanonic = xmlCanonicPath(SystemID);

	push	edi
	call	_xmlCanonicPath
	add	esp, 4
	mov	edi, eax

; 12741:     if ((SystemID != NULL) && (systemIdCanonic == NULL)) {

	cmp	DWORD PTR _SystemID$[ebp], 0
	je	SHORT $LN8@xmlSAXPars
	test	edi, edi
	je	$LN20@xmlSAXPars
$LN8@xmlSAXPars:

; 12742: 	xmlFreeParserCtxt(ctxt);
; 12743: 	return(NULL);
; 12744:     }
; 12745: 
; 12746:     /*
; 12747:      * Ask the Entity resolver to load the damn thing
; 12748:      */
; 12749: 
; 12750:     if ((ctxt->sax != NULL) && (ctxt->sax->resolveEntity != NULL))

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	$LN32@xmlSAXPars
	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	je	$LN32@xmlSAXPars

; 12751: 	input = ctxt->sax->resolveEntity(ctxt->userData, ExternalID,

	push	edi
	push	DWORD PTR _ExternalID$[ebp]
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _input$1$[ebp], eax

; 12752: 	                                 systemIdCanonic);
; 12753:     if (input == NULL) {

	test	eax, eax
	je	$LN32@xmlSAXPars

; 12754:         if (sax != NULL) ctxt->sax = NULL;
; 12755: 	xmlFreeParserCtxt(ctxt);
; 12756: 	if (systemIdCanonic != NULL)
; 12757: 	    xmlFree(systemIdCanonic);
; 12758: 	return(NULL);
; 12759:     }
; 12760: 
; 12761:     /*
; 12762:      * plug some encoding conversion routines here.
; 12763:      */
; 12764:     if (xmlPushInput(ctxt, input) < 0) {

	push	eax
	push	esi
	call	_xmlPushInput
	add	esp, 8
	test	eax, eax
	js	$LN32@xmlSAXPars

; 12770:     }
; 12771:     if ((ctxt->input->end - ctxt->input->cur) >= 4) {

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	cmp	eax, 4
	jl	SHORT $LN16@xmlSAXPars

; 12772: 	enc = xmlDetectCharEncoding(ctxt->input->cur, 4);

	push	4
	push	ecx
	call	_xmlDetectCharEncoding

; 12773: 	xmlSwitchEncoding(ctxt, enc);

	push	eax
	push	esi
	call	_xmlSwitchEncoding
	add	esp, 16					; 00000010H
$LN16@xmlSAXPars:

; 12774:     }
; 12775: 
; 12776:     if (input->filename == NULL)

	mov	ecx, DWORD PTR _input$1$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN17@xmlSAXPars

; 12777: 	input->filename = (char *) systemIdCanonic;

	mov	DWORD PTR [ecx+4], edi
	jmp	SHORT $LN18@xmlSAXPars
$LN17@xmlSAXPars:

; 12778:     else
; 12779: 	xmlFree(systemIdCanonic);

	push	edi
	call	DWORD PTR _xmlFree
	mov	ecx, DWORD PTR _input$1$[ebp]
	add	esp, 4
$LN18@xmlSAXPars:

; 12780:     input->line = 1;

	mov	DWORD PTR [ecx+28], 1

; 12781:     input->col = 1;

	mov	DWORD PTR [ecx+32], 1

; 12782:     input->base = ctxt->input->cur;

	mov	eax, DWORD PTR [esi+36]

; 12783:     input->cur = ctxt->input->cur;
; 12784:     input->free = NULL;
; 12785: 
; 12786:     /*
; 12787:      * let's parse that entity knowing it's an external subset.
; 12788:      */
; 12789:     ctxt->inSubset = 2;
; 12790:     ctxt->myDoc = xmlNewDoc(BAD_CAST "1.0");

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [esi+216], 2
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 12791:     if (ctxt->myDoc == NULL) {

	test	eax, eax
	jne	SHORT $LN19@xmlSAXPars

; 12792: 	xmlErrMemory(ctxt, "New Doc failed");

	push	OFFSET ??_C@_0P@IDBIGKBI@New?5Doc?5failed@
	push	esi
	call	_xmlErrMemory
	add	esp, 8

; 12793:         if (sax != NULL) ctxt->sax = NULL;

	test	ebx, ebx
	je	SHORT $LN20@xmlSAXPars
	mov	DWORD PTR [esi], 0
$LN20@xmlSAXPars:

; 12794: 	xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt

; 12826: }

	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlSAXPars:

; 12795: 	return(NULL);
; 12796:     }
; 12797:     ctxt->myDoc->properties = XML_DOC_INTERNAL;
; 12798:     ctxt->myDoc->extSubset = xmlNewDtd(ctxt->myDoc, BAD_CAST "none",

	mov	edi, DWORD PTR _SystemID$[ebp]
	push	edi
	push	DWORD PTR _ExternalID$[ebp]
	mov	DWORD PTR [eax+92], 64			; 00000040H
	push	OFFSET ??_C@_04CGFJFPFD@none@
	push	DWORD PTR [esi+8]
	call	_xmlNewDtd
	mov	ecx, DWORD PTR [esi+8]

; 12799: 	                               ExternalID, SystemID);
; 12800:     xmlParseExternalSubset(ctxt, ExternalID, SystemID);

	push	edi
	push	DWORD PTR _ExternalID$[ebp]
	push	esi
	mov	DWORD PTR [ecx+48], eax
	call	_xmlParseExternalSubset

; 12801: 
; 12802:     if (ctxt->myDoc != NULL) {

	mov	eax, DWORD PTR [esi+8]
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	SHORT $LN21@xmlSAXPars

; 12803: 	if (ctxt->wellFormed) {

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN22@xmlSAXPars

; 12804: 	    ret = ctxt->myDoc->extSubset;

	mov	edi, DWORD PTR [eax+48]
	mov	DWORD PTR _ret$1$[ebp], edi

; 12805: 	    ctxt->myDoc->extSubset = NULL;

	mov	DWORD PTR [eax+48], 0

; 12806: 	    if (ret != NULL) {

	test	edi, edi
	je	SHORT $LN3@xmlSAXPars

; 12807: 		xmlNodePtr tmp;
; 12808: 
; 12809: 		ret->doc = NULL;
; 12810: 		tmp = ret->children;

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [edi+32], 0

; 12811: 		while (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlSAXPars
	npad	6
$LL2@xmlSAXPars:

; 12812: 		    tmp->doc = NULL;

	mov	DWORD PTR [eax+32], 0

; 12813: 		    tmp = tmp->next;

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL2@xmlSAXPars
$LN3@xmlSAXPars:

; 12814: 		}
; 12815: 	    }
; 12816: 	} else {

	mov	eax, DWORD PTR [esi+8]
	jmp	SHORT $LN23@xmlSAXPars
$LN22@xmlSAXPars:

; 12817: 	    ret = NULL;

	mov	DWORD PTR _ret$1$[ebp], 0
$LN23@xmlSAXPars:

; 12818: 	}
; 12819:         xmlFreeDoc(ctxt->myDoc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 12820:         ctxt->myDoc = NULL;

	mov	DWORD PTR [esi+8], 0
$LN21@xmlSAXPars:

; 12821:     }
; 12822:     if (sax != NULL) ctxt->sax = NULL;

	test	ebx, ebx
	je	SHORT $LN25@xmlSAXPars
	mov	DWORD PTR [esi], 0
$LN25@xmlSAXPars:

; 12823:     xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt

; 12824: 
; 12825:     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 4
	pop	edi

; 12826: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@xmlSAXPars:

; 12765:         if (sax != NULL) ctxt->sax = NULL;
; 12766: 	xmlFreeParserCtxt(ctxt);
; 12767: 	if (systemIdCanonic != NULL)
; 12768: 	    xmlFree(systemIdCanonic);
; 12769: 	return(NULL);

	test	ebx, ebx
	je	SHORT $LN11@xmlSAXPars
	mov	DWORD PTR [esi], 0
$LN11@xmlSAXPars:
	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4
	test	edi, edi
	je	SHORT $LN15@xmlSAXPars
	push	edi
	call	DWORD PTR _xmlFree

; 12826: }

	add	esp, 4
$LN15@xmlSAXPars:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSAXParseDTD ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEntity
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlParseEntity PROC					; COMDAT

; 13971: xmlParseEntity(const char *filename) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14127:     return(xmlCreateURLParserCtxt(filename, 0));

	push	0
	push	DWORD PTR _filename$[ebp]
	call	_xmlCreateURLParserCtxt

; 13930:     ctxt = xmlCreateFileParserCtxt(filename);

	mov	esi, eax

; 14127:     return(xmlCreateURLParserCtxt(filename, 0));

	add	esp, 8

; 13931:     if (ctxt == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlParseEn
	pop	esi

; 13973: }

	pop	ebp
	ret	0
$LN4@xmlParseEn:
	push	edi

; 13941:     xmlParseExtParsedEnt(ctxt);

	push	esi
	call	_xmlParseExtParsedEnt

; 13942: 
; 13943:     if (ctxt->wellFormed)

	mov	eax, DWORD PTR [esi+8]
	add	esp, 4
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN7@xmlParseEn

; 13949:     }
; 13950:     if (sax != NULL)
; 13951:         ctxt->sax = NULL;
; 13952:     xmlFreeParserCtxt(ctxt);

	push	esi
	mov	edi, eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13972:     return(xmlSAXParseEntity(NULL, filename));

	mov	eax, edi
	pop	edi
	pop	esi

; 13973: }

	pop	ebp
	ret	0
$LN7@xmlParseEn:

; 13947:         xmlFreeDoc(ctxt->myDoc);

	push	eax
	xor	edi, edi
	call	_xmlFreeDoc
	add	esp, 4

; 13948:         ctxt->myDoc = NULL;

	mov	DWORD PTR [esi+8], edi

; 13949:     }
; 13950:     if (sax != NULL)
; 13951:         ctxt->sax = NULL;
; 13952:     xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13972:     return(xmlSAXParseEntity(NULL, filename));

	mov	eax, edi
	pop	edi
	pop	esi

; 13973: }

	pop	ebp
	ret	0
_xmlParseEntity ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXParseEntity
_TEXT	SEGMENT
_sax$ = 8						; size = 4
_filename$ = 12						; size = 4
_xmlSAXParseEntity PROC					; COMDAT

; 13926: xmlSAXParseEntity(xmlSAXHandlerPtr sax, const char *filename) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14127:     return(xmlCreateURLParserCtxt(filename, 0));

	push	0
	push	DWORD PTR _filename$[ebp]
	call	_xmlCreateURLParserCtxt

; 13927:     xmlDocPtr ret;
; 13928:     xmlParserCtxtPtr ctxt;
; 13929: 
; 13930:     ctxt = xmlCreateFileParserCtxt(filename);

	mov	esi, eax

; 14127:     return(xmlCreateURLParserCtxt(filename, 0));

	add	esp, 8

; 13931:     if (ctxt == NULL) {

	test	esi, esi
	jne	SHORT $LN2@xmlSAXPars
	pop	esi

; 13955: }

	pop	ebp
	ret	0
$LN2@xmlSAXPars:
	push	ebx
	push	edi

; 13932: 	return(NULL);
; 13933:     }
; 13934:     if (sax != NULL) {

	mov	edi, DWORD PTR _sax$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlSAXPars

; 13935: 	if (ctxt->sax != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@xmlSAXPars

; 13936: 	    xmlFree(ctxt->sax);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlSAXPars:

; 13937:         ctxt->sax = sax;

	mov	DWORD PTR [esi], edi

; 13938:         ctxt->userData = NULL;

	mov	DWORD PTR [esi+4], 0
$LN3@xmlSAXPars:

; 13939:     }
; 13940: 
; 13941:     xmlParseExtParsedEnt(ctxt);

	push	esi
	call	_xmlParseExtParsedEnt

; 13942: 
; 13943:     if (ctxt->wellFormed)

	mov	eax, DWORD PTR [esi+8]
	add	esp, 4
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN5@xmlSAXPars

; 13944: 	ret = ctxt->myDoc;

	mov	ebx, eax
	jmp	SHORT $LN6@xmlSAXPars
$LN5@xmlSAXPars:

; 13945:     else {
; 13946:         ret = NULL;
; 13947:         xmlFreeDoc(ctxt->myDoc);

	push	eax
	xor	ebx, ebx
	call	_xmlFreeDoc
	add	esp, 4

; 13948:         ctxt->myDoc = NULL;

	mov	DWORD PTR [esi+8], ebx
$LN6@xmlSAXPars:

; 13949:     }
; 13950:     if (sax != NULL)

	test	edi, edi
	je	SHORT $LN7@xmlSAXPars

; 13951:         ctxt->sax = NULL;

	mov	DWORD PTR [esi], 0
$LN7@xmlSAXPars:

; 13952:     xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13953: 
; 13954:     return(ret);

	mov	eax, ebx
	pop	edi
	pop	ebx
	pop	esi

; 13955: }

	pop	ebp
	ret	0
_xmlSAXParseEntity ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXParseFileWithData
_TEXT	SEGMENT
_sax$ = 8						; size = 4
_filename$ = 12						; size = 4
_recovery$ = 16						; size = 4
_data$ = 20						; size = 4
_xmlSAXParseFileWithData PROC				; COMDAT

; 14152:                         int recovery, void *data) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlInitParser

; 14127:     return(xmlCreateURLParserCtxt(filename, 0));

	mov	edi, DWORD PTR _filename$[ebp]
	push	0
	push	edi
	call	_xmlCreateURLParserCtxt

; 14153:     xmlDocPtr ret;
; 14154:     xmlParserCtxtPtr ctxt;
; 14155: 
; 14156:     xmlInitParser();
; 14157: 
; 14158:     ctxt = xmlCreateFileParserCtxt(filename);

	mov	esi, eax

; 14127:     return(xmlCreateURLParserCtxt(filename, 0));

	add	esp, 8

; 14159:     if (ctxt == NULL) {

	test	esi, esi
	jne	SHORT $LN2@xmlSAXPars

; 14198: }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN2@xmlSAXPars:
	push	ebx

; 14160: 	return(NULL);
; 14161:     }
; 14162:     if (sax != NULL) {

	mov	ebx, DWORD PTR _sax$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@xmlSAXPars

; 14163: 	if (ctxt->sax != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@xmlSAXPars

; 14164: 	    xmlFree(ctxt->sax);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlSAXPars:

; 14165:         ctxt->sax = sax;

	mov	DWORD PTR [esi], ebx
$LN3@xmlSAXPars:

; 14166:     }
; 14167:     xmlDetectSAX2(ctxt);

	push	esi
	call	_xmlDetectSAX2

; 14168:     if (data!=NULL) {

	mov	eax, DWORD PTR _data$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@xmlSAXPars

; 14169: 	ctxt->_private = data;

	mov	DWORD PTR [esi+272], eax
$LN5@xmlSAXPars:

; 14170:     }
; 14171: 
; 14172:     if (ctxt->directory == NULL)

	cmp	DWORD PTR [esi+180], 0
	jne	SHORT $LN6@xmlSAXPars

; 14173:         ctxt->directory = xmlParserGetDirectory(filename);

	push	edi
	call	_xmlParserGetDirectory
	add	esp, 4
	mov	DWORD PTR [esi+180], eax
$LN6@xmlSAXPars:

; 14174: 
; 14175:     ctxt->recovery = recovery;

	mov	edi, DWORD PTR _recovery$[ebp]

; 14176: 
; 14177:     xmlParseDocument(ctxt);

	push	esi
	mov	DWORD PTR [esi+288], edi
	call	_xmlParseDocument
	add	esp, 4

; 14178: 
; 14179:     if ((ctxt->wellFormed) || recovery) {

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN9@xmlSAXPars
	test	edi, edi
	jne	SHORT $LN9@xmlSAXPars

; 14183: 		ret->compression = 9;
; 14184: 	    else
; 14185: 		ret->compression = ctxt->input->buf->compressed;
; 14186: 	}
; 14187:     }
; 14188:     else {
; 14189:        ret = NULL;
; 14190:        xmlFreeDoc(ctxt->myDoc);

	push	DWORD PTR [esi+8]
	call	_xmlFreeDoc
	add	esp, 4

; 14191:        ctxt->myDoc = NULL;

	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN11@xmlSAXPars
$LN9@xmlSAXPars:

; 14180:         ret = ctxt->myDoc;

	mov	edi, DWORD PTR [esi+8]

; 14181: 	if (ret != NULL) {

	test	edi, edi
	je	SHORT $LN11@xmlSAXPars

; 14182: 	    if (ctxt->input->buf->compressed > 0)

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, 9
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	cmovg	eax, ecx
	mov	DWORD PTR [edi+36], eax
$LN11@xmlSAXPars:

; 14192:     }
; 14193:     if (sax != NULL)

	test	ebx, ebx
	pop	ebx
	je	SHORT $LN13@xmlSAXPars

; 14194:         ctxt->sax = NULL;

	mov	DWORD PTR [esi], 0
$LN13@xmlSAXPars:

; 14195:     xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14196: 
; 14197:     return(ret);

	mov	eax, edi
	pop	edi

; 14198: }

	pop	esi
	pop	ebp
	ret	0
_xmlSAXParseFileWithData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXParseFile
_TEXT	SEGMENT
_sax$ = 8						; size = 4
_filename$ = 12						; size = 4
_recovery$ = 16						; size = 4
_xmlSAXParseFile PROC					; COMDAT

; 14217:                           int recovery) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _recovery$[ebp]
	push	DWORD PTR _filename$[ebp]
	push	DWORD PTR _sax$[ebp]
	call	_xmlSAXParseFileWithData
	add	esp, 16					; 00000010H

; 14218:     return(xmlSAXParseFileWithData(sax,filename,recovery,NULL));
; 14219: }

	pop	ebp
	ret	0
_xmlSAXParseFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXParseMemoryWithData
_TEXT	SEGMENT
_sax$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_recovery$ = 20						; size = 4
_data$ = 24						; size = 4
_xmlSAXParseMemoryWithData PROC				; COMDAT

; 14429: 	          int size, int recovery, void *data) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlInitParser
	push	DWORD PTR _size$[ebp]
	push	DWORD PTR _buffer$[ebp]
	call	_xmlCreateMemoryParserCtxt
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	SHORT $LN2@xmlSAXPars
	pop	esi

; 14462: }

	pop	ebp
	ret	0
$LN2@xmlSAXPars:
	push	ebx
	push	edi

; 14430:     xmlDocPtr ret;
; 14431:     xmlParserCtxtPtr ctxt;
; 14432: 
; 14433:     xmlInitParser();
; 14434: 
; 14435:     ctxt = xmlCreateMemoryParserCtxt(buffer, size);
; 14436:     if (ctxt == NULL) return(NULL);
; 14437:     if (sax != NULL) {

	mov	edi, DWORD PTR _sax$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlSAXPars

; 14438: 	if (ctxt->sax != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@xmlSAXPars

; 14439: 	    xmlFree(ctxt->sax);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlSAXPars:

; 14440:         ctxt->sax = sax;

	mov	DWORD PTR [esi], edi
$LN3@xmlSAXPars:

; 14441:     }
; 14442:     xmlDetectSAX2(ctxt);

	push	esi
	call	_xmlDetectSAX2

; 14443:     if (data!=NULL) {

	mov	eax, DWORD PTR _data$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@xmlSAXPars

; 14444: 	ctxt->_private=data;

	mov	DWORD PTR [esi+272], eax
$LN5@xmlSAXPars:

; 14445:     }
; 14446: 
; 14447:     ctxt->recovery = recovery;

	mov	ebx, DWORD PTR _recovery$[ebp]

; 14448: 
; 14449:     xmlParseDocument(ctxt);

	push	esi
	mov	DWORD PTR [esi+288], ebx
	call	_xmlParseDocument
	add	esp, 4

; 14450: 
; 14451:     if ((ctxt->wellFormed) || recovery) ret = ctxt->myDoc;

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN8@xmlSAXPars
	test	ebx, ebx
	jne	SHORT $LN8@xmlSAXPars

; 14452:     else {
; 14453:        ret = NULL;
; 14454:        xmlFreeDoc(ctxt->myDoc);

	push	DWORD PTR [esi+8]
	call	_xmlFreeDoc
	add	esp, 4

; 14455:        ctxt->myDoc = NULL;

	mov	DWORD PTR [esi+8], ebx
	jmp	SHORT $LN7@xmlSAXPars
$LN8@xmlSAXPars:

; 14450: 
; 14451:     if ((ctxt->wellFormed) || recovery) ret = ctxt->myDoc;

	mov	ebx, DWORD PTR [esi+8]
$LN7@xmlSAXPars:

; 14456:     }
; 14457:     if (sax != NULL)

	test	edi, edi
	je	SHORT $LN9@xmlSAXPars

; 14458: 	ctxt->sax = NULL;

	mov	DWORD PTR [esi], 0
$LN9@xmlSAXPars:

; 14459:     xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14460: 
; 14461:     return(ret);

	mov	eax, ebx
	pop	edi
	pop	ebx
	pop	esi

; 14462: }

	pop	ebp
	ret	0
_xmlSAXParseMemoryWithData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXParseMemory
_TEXT	SEGMENT
_sax$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_recovery$ = 20						; size = 4
_xmlSAXParseMemory PROC					; COMDAT

; 14480: 	          int size, int recovery) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _recovery$[ebp]
	push	DWORD PTR _size$[ebp]
	push	DWORD PTR _buffer$[ebp]
	push	DWORD PTR _sax$[ebp]
	call	_xmlSAXParseMemoryWithData
	add	esp, 20					; 00000014H

; 14481:     return xmlSAXParseMemoryWithData(sax, buffer, size, recovery, NULL);
; 14482: }

	pop	ebp
	ret	0
_xmlSAXParseMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXParseDoc
_TEXT	SEGMENT
_sax$ = 8						; size = 4
_ret$1$ = 12						; size = 4
_cur$ = 12						; size = 4
_recovery$ = 16						; size = 4
_xmlSAXParseDoc PROC					; COMDAT

; 14599: xmlSAXParseDoc(xmlSAXHandlerPtr sax, const xmlChar *cur, int recovery) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	xor	ebx, ebx
	test	esi, esi
	je	SHORT $LN13@xmlSAXPars

; 14579:     len = xmlStrlen(cur);

	push	esi
	call	_xmlStrlen

; 14580:     return(xmlCreateMemoryParserCtxt((const char *)cur, len));

	push	eax
	push	esi
	call	_xmlCreateMemoryParserCtxt
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 14600:     xmlDocPtr ret;
; 14601:     xmlParserCtxtPtr ctxt;
; 14602:     xmlSAXHandlerPtr oldsax = NULL;
; 14603: 
; 14604:     if (cur == NULL) return(NULL);
; 14605: 
; 14606: 
; 14607:     ctxt = xmlCreateDocParserCtxt(cur);
; 14608:     if (ctxt == NULL) return(NULL);

	test	esi, esi
	je	SHORT $LN13@xmlSAXPars

; 14609:     if (sax != NULL) {

	push	edi
	mov	edi, DWORD PTR _sax$[ebp]
	test	edi, edi
	je	SHORT $LN4@xmlSAXPars

; 14610:         oldsax = ctxt->sax;

	mov	ebx, DWORD PTR [esi]

; 14611:         ctxt->sax = sax;

	mov	DWORD PTR [esi], edi

; 14612:         ctxt->userData = NULL;

	mov	DWORD PTR [esi+4], 0
$LN4@xmlSAXPars:

; 14613:     }
; 14614:     xmlDetectSAX2(ctxt);

	push	esi
	call	_xmlDetectSAX2

; 14615: 
; 14616:     xmlParseDocument(ctxt);

	push	esi
	call	_xmlParseDocument
	add	esp, 8

; 14617:     if ((ctxt->wellFormed) || recovery) ret = ctxt->myDoc;

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN7@xmlSAXPars
	cmp	DWORD PTR _recovery$[ebp], 0
	jne	SHORT $LN7@xmlSAXPars

; 14618:     else {
; 14619:        ret = NULL;
; 14620:        xmlFreeDoc(ctxt->myDoc);

	push	DWORD PTR [esi+8]
	mov	DWORD PTR _ret$1$[ebp], 0
	call	_xmlFreeDoc
	add	esp, 4

; 14621:        ctxt->myDoc = NULL;

	mov	DWORD PTR [esi+8], 0
	jmp	SHORT $LN6@xmlSAXPars
$LN7@xmlSAXPars:

; 14617:     if ((ctxt->wellFormed) || recovery) ret = ctxt->myDoc;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _ret$1$[ebp], eax
$LN6@xmlSAXPars:

; 14622:     }
; 14623:     if (sax != NULL)

	test	edi, edi
	pop	edi
	je	SHORT $LN8@xmlSAXPars

; 14624: 	ctxt->sax = oldsax;

	mov	DWORD PTR [esi], ebx
$LN8@xmlSAXPars:

; 14625:     xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt

; 14626: 
; 14627:     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 4
	pop	esi

; 14628: }

	pop	ebx
	pop	ebp
	ret	0
$LN13@xmlSAXPars:
	pop	esi

; 14600:     xmlDocPtr ret;
; 14601:     xmlParserCtxtPtr ctxt;
; 14602:     xmlSAXHandlerPtr oldsax = NULL;
; 14603: 
; 14604:     if (cur == NULL) return(NULL);
; 14605: 
; 14606: 
; 14607:     ctxt = xmlCreateDocParserCtxt(cur);
; 14608:     if (ctxt == NULL) return(NULL);

	xor	eax, eax

; 14628: }

	pop	ebx
	pop	ebp
	ret	0
_xmlSAXParseDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXUserParseMemory
_TEXT	SEGMENT
_sax$ = 8						; size = 4
_user_data$ = 12					; size = 4
_buffer$ = 16						; size = 4
_size$ = 20						; size = 4
_xmlSAXUserParseMemory PROC				; COMDAT

; 14527: 			  const char *buffer, int size) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlInitParser
	push	DWORD PTR _size$[ebp]
	push	DWORD PTR _buffer$[ebp]
	call	_xmlCreateMemoryParserCtxt
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	SHORT $LN2@xmlSAXUser

; 14528:     int ret = 0;
; 14529:     xmlParserCtxtPtr ctxt;
; 14530: 
; 14531:     xmlInitParser();
; 14532: 
; 14533:     ctxt = xmlCreateMemoryParserCtxt(buffer, size);
; 14534:     if (ctxt == NULL) return -1;

	or	eax, -1
	pop	esi

; 14562: }

	pop	ebp
	ret	0
$LN2@xmlSAXUser:
	push	edi

; 14535:     if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)

	mov	edi, DWORD PTR [esi]
	call	___xmlDefaultSAXHandler
	cmp	edi, eax
	je	SHORT $LN3@xmlSAXUser

; 14536:         xmlFree(ctxt->sax);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlSAXUser:

; 14537:     ctxt->sax = sax;

	push	ebx
	mov	ebx, DWORD PTR _sax$[ebp]

; 14538:     xmlDetectSAX2(ctxt);

	push	esi
	mov	DWORD PTR [esi], ebx
	call	_xmlDetectSAX2

; 14539: 
; 14540:     if (user_data != NULL)

	mov	eax, DWORD PTR _user_data$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@xmlSAXUser

; 14541: 	ctxt->userData = user_data;

	mov	DWORD PTR [esi+4], eax
$LN4@xmlSAXUser:

; 14542: 
; 14543:     xmlParseDocument(ctxt);

	push	esi
	call	_xmlParseDocument
	add	esp, 4

; 14544: 
; 14545:     if (ctxt->wellFormed)

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN5@xmlSAXUser

; 14546: 	ret = 0;

	xor	edi, edi
	jmp	SHORT $LN7@xmlSAXUser
$LN5@xmlSAXUser:

; 14547:     else {
; 14548:         if (ctxt->errNo != 0)

	mov	eax, DWORD PTR [esi+84]
	or	edi, -1
	test	eax, eax
	cmovne	edi, eax
$LN7@xmlSAXUser:

; 14549: 	    ret = ctxt->errNo;
; 14550: 	else
; 14551: 	    ret = -1;
; 14552:     }
; 14553:     if (sax != NULL)

	test	ebx, ebx
	pop	ebx
	je	SHORT $LN9@xmlSAXUser

; 14554:         ctxt->sax = NULL;

	mov	DWORD PTR [esi], 0
$LN9@xmlSAXUser:

; 14555:     if (ctxt->myDoc != NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@xmlSAXUser

; 14556:         xmlFreeDoc(ctxt->myDoc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 14557: 	ctxt->myDoc = NULL;

	mov	DWORD PTR [esi+8], 0
$LN10@xmlSAXUser:

; 14558:     }
; 14559:     xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14560: 
; 14561:     return ret;

	mov	eax, edi
	pop	edi
	pop	esi

; 14562: }

	pop	ebp
	ret	0
_xmlSAXUserParseMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXUserParseFile
_TEXT	SEGMENT
_sax$ = 8						; size = 4
_user_data$ = 12					; size = 4
_filename$ = 16						; size = 4
_xmlSAXUserParseFile PROC				; COMDAT

; 14319:                     const char *filename) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14127:     return(xmlCreateURLParserCtxt(filename, 0));

	push	0
	push	DWORD PTR _filename$[ebp]
	call	_xmlCreateURLParserCtxt

; 14320:     int ret = 0;
; 14321:     xmlParserCtxtPtr ctxt;
; 14322: 
; 14323:     ctxt = xmlCreateFileParserCtxt(filename);

	mov	esi, eax

; 14127:     return(xmlCreateURLParserCtxt(filename, 0));

	add	esp, 8

; 14324:     if (ctxt == NULL) return -1;

	test	esi, esi
	jne	SHORT $LN2@xmlSAXUser
	or	eax, -1
	pop	esi

; 14352: }

	pop	ebp
	ret	0
$LN2@xmlSAXUser:
	push	edi

; 14325:     if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)

	mov	edi, DWORD PTR [esi]
	call	___xmlDefaultSAXHandler
	cmp	edi, eax
	je	SHORT $LN3@xmlSAXUser

; 14326: 	xmlFree(ctxt->sax);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlSAXUser:

; 14327:     ctxt->sax = sax;

	push	ebx
	mov	ebx, DWORD PTR _sax$[ebp]

; 14328:     xmlDetectSAX2(ctxt);

	push	esi
	mov	DWORD PTR [esi], ebx
	call	_xmlDetectSAX2

; 14329: 
; 14330:     if (user_data != NULL)

	mov	eax, DWORD PTR _user_data$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@xmlSAXUser

; 14331: 	ctxt->userData = user_data;

	mov	DWORD PTR [esi+4], eax
$LN4@xmlSAXUser:

; 14332: 
; 14333:     xmlParseDocument(ctxt);

	push	esi
	call	_xmlParseDocument
	add	esp, 4

; 14334: 
; 14335:     if (ctxt->wellFormed)

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN5@xmlSAXUser

; 14336: 	ret = 0;

	xor	edi, edi
	jmp	SHORT $LN7@xmlSAXUser
$LN5@xmlSAXUser:

; 14337:     else {
; 14338:         if (ctxt->errNo != 0)

	mov	eax, DWORD PTR [esi+84]
	or	edi, -1
	test	eax, eax
	cmovne	edi, eax
$LN7@xmlSAXUser:

; 14339: 	    ret = ctxt->errNo;
; 14340: 	else
; 14341: 	    ret = -1;
; 14342:     }
; 14343:     if (sax != NULL)

	test	ebx, ebx
	pop	ebx
	je	SHORT $LN9@xmlSAXUser

; 14344: 	ctxt->sax = NULL;

	mov	DWORD PTR [esi], 0
$LN9@xmlSAXUser:

; 14345:     if (ctxt->myDoc != NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@xmlSAXUser

; 14346:         xmlFreeDoc(ctxt->myDoc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 14347: 	ctxt->myDoc = NULL;

	mov	DWORD PTR [esi+8], 0
$LN10@xmlSAXUser:

; 14348:     }
; 14349:     xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14350: 
; 14351:     return ret;

	mov	eax, edi
	pop	edi
	pop	esi

; 14352: }

	pop	ebp
	ret	0
_xmlSAXUserParseFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseExtParsedEnt
_TEXT	SEGMENT
_start$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseExtParsedEnt PROC				; COMDAT

; 10774: xmlParseExtParsedEnt(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN3@xmlParseEx

; 10775:     xmlChar start[4];
; 10776:     xmlCharEncoding enc;
; 10777: 
; 10778:     if ((ctxt == NULL) || (ctxt->input == NULL))

	cmp	DWORD PTR [esi+36], 0
	je	$LN3@xmlParseEx

; 10780: 
; 10781:     xmlDefaultSAXHandlerInit();

	call	_xmlDefaultSAXHandlerInit

; 10782: 
; 10783:     xmlDetectSAX2(ctxt);

	push	esi
	call	_xmlDetectSAX2
	add	esp, 4

; 10784: 
; 10785:     GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN4@xmlParseEx
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN4@xmlParseEx
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN4@xmlParseEx:

; 10786: 
; 10787:     /*
; 10788:      * SAX: beginning of the document processing.
; 10789:      */
; 10790:     if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))

	push	edi
	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN5@xmlParseEx
	cmp	DWORD PTR [edi+44], 0
	je	SHORT $LN5@xmlParseEx

; 10791:         ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);

	call	___xmlDefaultSAXLocator
	push	eax
	push	DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+44]
	call	eax
	add	esp, 8
$LN5@xmlParseEx:

; 10792: 
; 10793:     /*
; 10794:      * Get the 4 first bytes and decode the charset
; 10795:      * if enc != XML_CHAR_ENCODING_NONE
; 10796:      * plug some encoding conversion routines.
; 10797:      */
; 10798:     if ((ctxt->input->end - ctxt->input->cur) >= 4) {

	mov	ecx, DWORD PTR [esi+36]
	pop	edi
	mov	eax, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [ecx+16]
	sub	eax, edx
	cmp	eax, 4
	jl	SHORT $LN7@xmlParseEx

; 10799: 	start[0] = RAW;

	movzx	eax, BYTE PTR [edx]
	mov	BYTE PTR _start$[ebp], al

; 10800: 	start[1] = NXT(1);

	mov	eax, DWORD PTR [ecx+16]

; 10801: 	start[2] = NXT(2);
; 10802: 	start[3] = NXT(3);
; 10803: 	enc = xmlDetectCharEncoding(start, 4);

	push	4
	movzx	eax, BYTE PTR [eax+1]
	mov	BYTE PTR _start$[ebp+1], al
	mov	eax, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [eax+2]
	mov	BYTE PTR _start$[ebp+2], al
	mov	eax, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [eax+3]
	mov	BYTE PTR _start$[ebp+3], al
	lea	eax, DWORD PTR _start$[ebp]
	push	eax
	call	_xmlDetectCharEncoding
	add	esp, 8

; 10804: 	if (enc != XML_CHAR_ENCODING_NONE) {

	test	eax, eax
	je	SHORT $LN7@xmlParseEx

; 10805: 	    xmlSwitchEncoding(ctxt, enc);

	push	eax
	push	esi
	call	_xmlSwitchEncoding
	add	esp, 8
$LN7@xmlParseEx:

; 10806: 	}
; 10807:     }
; 10808: 
; 10809: 
; 10810:     if (CUR == 0) {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN8@xmlParseEx

; 10811: 	xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);

	push	0
	push	4
	push	esi
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN8@xmlParseEx:

; 10812:     }
; 10813: 
; 10814:     /*
; 10815:      * Check for the XMLDecl in the Prolog.
; 10816:      */
; 10817:     GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN9@xmlParseEx
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN9@xmlParseEx
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN9@xmlParseEx:

; 10818:     if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 60			; 0000003cH
	jne	SHORT $LN10@xmlParseEx
	cmp	BYTE PTR [eax+1], 63			; 0000003fH
	jne	SHORT $LN10@xmlParseEx
	cmp	BYTE PTR [eax+2], 120			; 00000078H
	jne	SHORT $LN10@xmlParseEx
	cmp	BYTE PTR [eax+3], 109			; 0000006dH
	jne	SHORT $LN10@xmlParseEx
	cmp	BYTE PTR [eax+4], 108			; 0000006cH
	jne	SHORT $LN10@xmlParseEx
	mov	al, BYTE PTR [eax+5]
	cmp	al, 32					; 00000020H
	je	SHORT $LN12@xmlParseEx
	cmp	al, 9
	jb	SHORT $LN13@xmlParseEx
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN12@xmlParseEx
$LN13@xmlParseEx:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN10@xmlParseEx
$LN12@xmlParseEx:

; 10819: 
; 10820: 	/*
; 10821: 	 * Note that we will switch encoding on the fly.
; 10822: 	 */
; 10823: 	xmlParseXMLDecl(ctxt);

	push	esi
	call	_xmlParseXMLDecl
	add	esp, 4

; 10824: 	if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {

	cmp	DWORD PTR [esi+84], 32			; 00000020H
	je	$LN3@xmlParseEx

; 10825: 	    /*
; 10826: 	     * The XML REC instructs us to stop parsing right here
; 10827: 	     */
; 10828: 	    return(-1);
; 10829: 	}
; 10830: 	SKIP_BLANKS;

	push	esi
	call	_xmlSkipBlankChars

; 10831:     } else {

	jmp	SHORT $LN160@xmlParseEx
$LN10@xmlParseEx:

; 10832: 	ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlCharStrdup
	mov	DWORD PTR [esi+20], eax
$LN160@xmlParseEx:

; 10833:     }
; 10834:     if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))

	mov	eax, DWORD PTR [esi]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN15@xmlParseEx
	mov	eax, DWORD PTR [eax+48]
	test	eax, eax
	je	SHORT $LN15@xmlParseEx
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN15@xmlParseEx

; 10835:         ctxt->sax->startDocument(ctxt->userData);

	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 4
$LN15@xmlParseEx:

; 10836:     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	$LN3@xmlParseEx

; 10837: 	return(-1);
; 10838: 
; 10839:     /*
; 10840:      * Doing validity checking on chunk doesn't make sense
; 10841:      */
; 10842:     ctxt->instate = XML_PARSER_CONTENT;
; 10843:     ctxt->validate = 0;
; 10844:     ctxt->loadsubset = 0;
; 10845:     ctxt->depth = 0;
; 10846: 
; 10847:     xmlParseContent(ctxt);

	push	esi
	mov	DWORD PTR [esi+172], 7
	mov	DWORD PTR [esi+104], 0
	mov	DWORD PTR [esi+276], 0
	mov	DWORD PTR [esi+248], 0
	call	_xmlParseContent
	add	esp, 4

; 10848:     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	$LN3@xmlParseEx

; 10849: 	return(-1);
; 10850: 
; 10851:     if ((RAW == '<') && (NXT(1) == '/')) {

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	al, BYTE PTR [ecx]
	cmp	al, 60					; 0000003cH
	jne	SHORT $LN18@xmlParseEx
	cmp	BYTE PTR [ecx+1], 47			; 0000002fH
	jne	SHORT $LN18@xmlParseEx

; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 85			; 00000055H
	push	85					; 00000055H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {
; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {
; 553  : 	ctxt->wellFormed = 0;
; 554  : 	if (ctxt->recovery == 0)
; 555  : 	    ctxt->disableSAX = 1;
; 556  :     }
; 557  : }

	jmp	SHORT $LN162@xmlParseEx
$LN18@xmlParseEx:

; 10852: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
; 10853:     } else if (RAW != 0) {

	test	al, al
	je	SHORT $LN158@xmlParseEx

; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	OFFSET ??_C@_0DA@BPKCCNLP@extra?5content?5at?5the?5end?5of?5wel@
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	DWORD PTR [esi+84], 86			; 00000056H
	push	86					; 00000056H
$LN162@xmlParseEx:

; 10854: 	xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
; 10855:     }
; 10856: 
; 10857:     /*
; 10858:      * SAX: end of the document processing.
; 10859:      */
; 10860:     if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))

	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	mov	DWORD PTR [esi+12], 0
	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN158@xmlParseEx
	mov	DWORD PTR [esi+212], 1
$LN158@xmlParseEx:
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN21@xmlParseEx
	mov	eax, DWORD PTR [eax+52]
	test	eax, eax
	je	SHORT $LN21@xmlParseEx

; 10861:         ctxt->sax->endDocument(ctxt->userData);

	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 4
$LN21@xmlParseEx:

; 10862: 
; 10863:     if (! ctxt->wellFormed) return(-1);

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN3@xmlParseEx

; 10864:     return(0);

	xor	eax, eax
	pop	esi

; 10865: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlParseEx:

; 10779:         return(-1);

	or	eax, -1
	pop	esi

; 10865: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseExtParsedEnt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseDocument
_TEXT	SEGMENT
_start$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseDocument PROC					; COMDAT

; 10581: xmlParseDocument(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlInitParser
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN3@xmlParseDo

; 10582:     xmlChar start[4];
; 10583:     xmlCharEncoding enc;
; 10584: 
; 10585:     xmlInitParser();
; 10586: 
; 10587:     if ((ctxt == NULL) || (ctxt->input == NULL))

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	je	$LN3@xmlParseDo

; 10588:         return(-1);
; 10589: 
; 10590:     GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN4@xmlParseDo
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [ecx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN4@xmlParseDo
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN4@xmlParseDo:

; 10591: 
; 10592:     /*
; 10593:      * SAX: detecting the level.
; 10594:      */
; 10595:     xmlDetectSAX2(ctxt);

	push	edi
	push	esi
	call	_xmlDetectSAX2

; 10596: 
; 10597:     /*
; 10598:      * SAX: beginning of the document processing.
; 10599:      */
; 10600:     if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))

	mov	edi, DWORD PTR [esi]
	add	esp, 4
	test	edi, edi
	je	SHORT $LN5@xmlParseDo
	cmp	DWORD PTR [edi+44], 0
	je	SHORT $LN5@xmlParseDo

; 10601:         ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);

	call	___xmlDefaultSAXLocator
	push	eax
	push	DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+44]
	call	eax
	add	esp, 8
$LN5@xmlParseDo:

; 10602:     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	pop	edi
	je	SHORT $LN3@xmlParseDo

; 10603: 	return(-1);
; 10604: 
; 10605:     if ((ctxt->encoding == NULL) &&

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN8@xmlParseDo
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [ecx+16]
	sub	eax, edx
	cmp	eax, 4
	jl	SHORT $LN8@xmlParseDo

; 10606:         ((ctxt->input->end - ctxt->input->cur) >= 4)) {
; 10607: 	/*
; 10608: 	 * Get the 4 first bytes and decode the charset
; 10609: 	 * if enc != XML_CHAR_ENCODING_NONE
; 10610: 	 * plug some encoding conversion routines.
; 10611: 	 */
; 10612: 	start[0] = RAW;

	movzx	eax, BYTE PTR [edx]
	mov	BYTE PTR _start$[ebp], al

; 10613: 	start[1] = NXT(1);

	mov	eax, DWORD PTR [ecx+16]

; 10614: 	start[2] = NXT(2);
; 10615: 	start[3] = NXT(3);
; 10616: 	enc = xmlDetectCharEncoding(&start[0], 4);

	push	4
	movzx	eax, BYTE PTR [eax+1]
	mov	BYTE PTR _start$[ebp+1], al
	mov	eax, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [eax+2]
	mov	BYTE PTR _start$[ebp+2], al
	mov	eax, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [eax+3]
	mov	BYTE PTR _start$[ebp+3], al
	lea	eax, DWORD PTR _start$[ebp]
	push	eax
	call	_xmlDetectCharEncoding
	add	esp, 8

; 10617: 	if (enc != XML_CHAR_ENCODING_NONE) {

	test	eax, eax
	je	SHORT $LN8@xmlParseDo

; 10618: 	    xmlSwitchEncoding(ctxt, enc);

	push	eax
	push	esi
	call	_xmlSwitchEncoding
	add	esp, 8
$LN8@xmlParseDo:

; 10619: 	}
; 10620:     }
; 10621: 
; 10622: 
; 10623:     if (CUR == 0) {

	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+16]
	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN9@xmlParseDo

; 10624: 	xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);

	push	0
	push	4
	push	esi
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN3@xmlParseDo:

; 10757: }

	or	eax, -1
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlParseDo:

; 10625: 	return(-1);
; 10626:     }
; 10627: 
; 10628:     /*
; 10629:      * Check for the XMLDecl in the Prolog.
; 10630:      * do not GROW here to avoid the detected encoder to decode more
; 10631:      * than just the first line, unless the amount of data is really
; 10632:      * too small to hold "<?xml version="1.0" encoding="foo"
; 10633:      */
; 10634:     if ((ctxt->input->end - ctxt->input->cur) < 35) {

	mov	eax, DWORD PTR [ecx+20]
	sub	eax, edx
	cmp	eax, 35					; 00000023H
	jge	SHORT $LN11@xmlParseDo

; 10635:        GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN11@xmlParseDo
	push	esi
	call	_xmlGROW
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 4
$LN11@xmlParseDo:

; 10636:     }
; 10637:     if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {

	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 60			; 0000003cH
	jne	SHORT $LN12@xmlParseDo
	cmp	BYTE PTR [eax+1], 63			; 0000003fH
	jne	SHORT $LN12@xmlParseDo
	cmp	BYTE PTR [eax+2], 120			; 00000078H
	jne	SHORT $LN12@xmlParseDo
	cmp	BYTE PTR [eax+3], 109			; 0000006dH
	jne	SHORT $LN12@xmlParseDo
	cmp	BYTE PTR [eax+4], 108			; 0000006cH
	jne	SHORT $LN12@xmlParseDo
	mov	al, BYTE PTR [eax+5]
	cmp	al, 32					; 00000020H
	je	SHORT $LN14@xmlParseDo
	cmp	al, 9
	jb	SHORT $LN15@xmlParseDo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN14@xmlParseDo
$LN15@xmlParseDo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN12@xmlParseDo
$LN14@xmlParseDo:

; 10638: 
; 10639: 	/*
; 10640: 	 * Note that we will switch encoding on the fly.
; 10641: 	 */
; 10642: 	xmlParseXMLDecl(ctxt);

	push	esi
	call	_xmlParseXMLDecl
	add	esp, 4

; 10643: 	if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||

	cmp	DWORD PTR [esi+84], 32			; 00000020H
	je	SHORT $LN3@xmlParseDo
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN3@xmlParseDo

; 10644: 	    (ctxt->instate == XML_PARSER_EOF)) {
; 10645: 	    /*
; 10646: 	     * The XML REC instructs us to stop parsing right here
; 10647: 	     */
; 10648: 	    return(-1);
; 10649: 	}
; 10650: 	ctxt->standalone = ctxt->input->standalone;

	mov	eax, DWORD PTR [esi+36]

; 10651: 	SKIP_BLANKS;

	push	esi
	mov	eax, DWORD PTR [eax+52]
	mov	DWORD PTR [esi+28], eax
	call	_xmlSkipBlankChars

; 10652:     } else {

	jmp	SHORT $LN44@xmlParseDo
$LN12@xmlParseDo:

; 10653: 	ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlCharStrdup
	mov	DWORD PTR [esi+20], eax
$LN44@xmlParseDo:

; 10654:     }
; 10655:     if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))

	mov	eax, DWORD PTR [esi]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@xmlParseDo
	mov	eax, DWORD PTR [eax+48]
	test	eax, eax
	je	SHORT $LN18@xmlParseDo
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN18@xmlParseDo

; 10656:         ctxt->sax->startDocument(ctxt->userData);

	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 4
$LN18@xmlParseDo:

; 10657:     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	$LN3@xmlParseDo

; 10658: 	return(-1);
; 10659:     if ((ctxt->myDoc != NULL) && (ctxt->input != NULL) &&
; 10660:         (ctxt->input->buf != NULL) && (ctxt->input->buf->compressed >= 0)) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN20@xmlParseDo
	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	je	SHORT $LN20@xmlParseDo
	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN20@xmlParseDo
	mov	ecx, DWORD PTR [ecx+24]
	test	ecx, ecx
	js	SHORT $LN20@xmlParseDo

; 10661: 	ctxt->myDoc->compression = ctxt->input->buf->compressed;

	mov	DWORD PTR [eax+36], ecx
$LN20@xmlParseDo:

; 10662:     }
; 10663: 
; 10664:     /*
; 10665:      * The Misc part of the Prolog
; 10666:      */
; 10667:     GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN21@xmlParseDo
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN21@xmlParseDo
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN21@xmlParseDo:

; 10668:     xmlParseMisc(ctxt);

	push	esi
	call	_xmlParseMisc
	add	esp, 4

; 10669: 
; 10670:     /*
; 10671:      * Then possibly doc type declaration(s) and more Misc
; 10672:      * (doctypedecl Misc*)?
; 10673:      */
; 10674:     GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN22@xmlParseDo
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN22@xmlParseDo
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN22@xmlParseDo:

; 10675:     if (CMP9(CUR_PTR, '<', '!', 'D', 'O', 'C', 'T', 'Y', 'P', 'E')) {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 60			; 0000003cH
	jne	$LN23@xmlParseDo
	cmp	BYTE PTR [eax+1], 33			; 00000021H
	jne	$LN23@xmlParseDo
	cmp	BYTE PTR [eax+2], 68			; 00000044H
	jne	$LN23@xmlParseDo
	cmp	BYTE PTR [eax+3], 79			; 0000004fH
	jne	$LN23@xmlParseDo
	cmp	BYTE PTR [eax+4], 67			; 00000043H
	jne	$LN23@xmlParseDo
	cmp	BYTE PTR [eax+5], 84			; 00000054H
	jne	$LN23@xmlParseDo
	cmp	BYTE PTR [eax+6], 89			; 00000059H
	jne	$LN23@xmlParseDo
	cmp	BYTE PTR [eax+7], 80			; 00000050H
	jne	$LN23@xmlParseDo
	cmp	BYTE PTR [eax+8], 69			; 00000045H
	jne	$LN23@xmlParseDo

; 10676: 
; 10677: 	ctxt->inSubset = 1;
; 10678: 	xmlParseDocTypeDecl(ctxt);

	push	esi
	mov	DWORD PTR [esi+216], 1
	call	_xmlParseDocTypeDecl

; 10679: 	if (RAW == '[') {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 91			; 0000005bH
	jne	SHORT $LN43@xmlParseDo

; 10680: 	    ctxt->instate = XML_PARSER_DTD;
; 10681: 	    xmlParseInternalSubset(ctxt);

	push	esi
	mov	DWORD PTR [esi+172], 3
	call	_xmlParseInternalSubset
	add	esp, 4

; 10682: 	    if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	$LN3@xmlParseDo
$LN43@xmlParseDo:

; 10683: 		return(-1);
; 10684: 	}
; 10685: 
; 10686: 	/*
; 10687: 	 * Create and update the external subset.
; 10688: 	 */
; 10689: 	ctxt->inSubset = 2;
; 10690: 	if ((ctxt->sax != NULL) && (ctxt->sax->externalSubset != NULL) &&

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+216], 2
	test	eax, eax
	je	SHORT $LN26@xmlParseDo
	mov	eax, DWORD PTR [eax+104]
	test	eax, eax
	je	SHORT $LN26@xmlParseDo
	cmp	DWORD PTR [esi+212], 0
	jne	SHORT $LN26@xmlParseDo

; 10691: 	    (!ctxt->disableSAX))
; 10692: 	    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,

	push	DWORD PTR [esi+224]
	push	DWORD PTR [esi+228]
	push	DWORD PTR [esi+220]
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 16					; 00000010H
$LN26@xmlParseDo:

; 10693: 	                              ctxt->extSubSystem, ctxt->extSubURI);
; 10694: 	if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [esi+172], -1
	je	$LN3@xmlParseDo

; 10695: 	    return(-1);
; 10696: 	ctxt->inSubset = 0;
; 10697: 
; 10698:         xmlCleanSpecialAttr(ctxt);

	push	esi
	mov	DWORD PTR [esi+216], 0
	call	_xmlCleanSpecialAttr

; 10699: 
; 10700: 	ctxt->instate = XML_PARSER_PROLOG;
; 10701: 	xmlParseMisc(ctxt);

	push	esi
	mov	DWORD PTR [esi+172], 4
	call	_xmlParseMisc
	add	esp, 8
$LN23@xmlParseDo:

; 10702:     }
; 10703: 
; 10704:     /*
; 10705:      * Time to start parsing the tree itself
; 10706:      */
; 10707:     GROW;

	cmp	DWORD PTR [esi+292], 0
	jne	SHORT $LN28@xmlParseDo
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN28@xmlParseDo
	push	esi
	call	_xmlGROW
	add	esp, 4
$LN28@xmlParseDo:

; 10708:     if (RAW != '<') {

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 60			; 0000003cH
	je	SHORT $LN29@xmlParseDo

; 10709: 	xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,

	push	OFFSET ??_C@_0CD@NCHPNICC@Start?5tag?5expected?0?5?8?$DM?8?5not?5fou@
	push	4
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 10710: 		       "Start tag expected, '<' not found\n");
; 10711:     } else {

	jmp	SHORT $LN30@xmlParseDo
$LN29@xmlParseDo:

; 10712: 	ctxt->instate = XML_PARSER_CONTENT;
; 10713: 	xmlParseElement(ctxt);

	push	esi
	mov	DWORD PTR [esi+172], 7
	call	_xmlParseElement

; 10714: 	ctxt->instate = XML_PARSER_EPILOG;
; 10715: 
; 10716: 
; 10717: 	/*
; 10718: 	 * The Misc part at the end
; 10719: 	 */
; 10720: 	xmlParseMisc(ctxt);

	push	esi
	mov	DWORD PTR [esi+172], 14			; 0000000eH
	call	_xmlParseMisc

; 10721: 
; 10722: 	if (RAW != 0) {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 8
	mov	eax, DWORD PTR [eax+16]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN31@xmlParseDo

; 10723: 	    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);

	push	0
	push	5
	push	esi
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN31@xmlParseDo:

; 10724: 	}
; 10725: 	ctxt->instate = XML_PARSER_EOF;

	mov	DWORD PTR [esi+172], -1
$LN30@xmlParseDo:

; 10726:     }
; 10727: 
; 10728:     /*
; 10729:      * SAX: end of the document processing.
; 10730:      */
; 10731:     if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN32@xmlParseDo
	mov	eax, DWORD PTR [eax+52]
	test	eax, eax
	je	SHORT $LN32@xmlParseDo

; 10732:         ctxt->sax->endDocument(ctxt->userData);

	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 4
$LN32@xmlParseDo:

; 10733: 
; 10734:     /*
; 10735:      * Remove locally kept entity definitions if the tree was not built
; 10736:      */
; 10737:     if ((ctxt->myDoc != NULL) &&

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN33@xmlParseDo
	push	OFFSET ??_C@_0CA@CHJJOFGL@SAX?5compatibility?5mode?5document@
	push	DWORD PTR [eax+56]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@xmlParseDo

; 10738: 	(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {
; 10739: 	xmlFreeDoc(ctxt->myDoc);

	push	DWORD PTR [esi+8]
	call	_xmlFreeDoc
	add	esp, 4

; 10740: 	ctxt->myDoc = NULL;

	mov	DWORD PTR [esi+8], 0
$LN33@xmlParseDo:

; 10741:     }
; 10742: 
; 10743:     if ((ctxt->wellFormed) && (ctxt->myDoc != NULL)) {

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN46@xmlParseDo
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN37@xmlParseDo

; 10744:         ctxt->myDoc->properties |= XML_DOC_WELLFORMED;

	or	DWORD PTR [eax+92], 1

; 10745: 	if (ctxt->valid)

	cmp	DWORD PTR [esi+100], 0
	je	SHORT $LN35@xmlParseDo

; 10746: 	    ctxt->myDoc->properties |= XML_DOC_DTDVALID;

	mov	eax, DWORD PTR [esi+8]
	or	DWORD PTR [eax+92], 8
$LN35@xmlParseDo:

; 10747: 	if (ctxt->nsWellFormed)

	cmp	DWORD PTR [esi+356], 0
	je	SHORT $LN36@xmlParseDo

; 10748: 	    ctxt->myDoc->properties |= XML_DOC_NSVALID;

	mov	eax, DWORD PTR [esi+8]
	or	DWORD PTR [eax+92], 2
$LN36@xmlParseDo:

; 10749: 	if (ctxt->options & XML_PARSE_OLD10)

	test	DWORD PTR [esi+360], 131072		; 00020000H
	je	SHORT $LN37@xmlParseDo

; 10750: 	    ctxt->myDoc->properties |= XML_DOC_OLD10;

	mov	eax, DWORD PTR [esi+8]
	or	DWORD PTR [eax+92], 4
$LN37@xmlParseDo:

; 10751:     }
; 10752:     if (! ctxt->wellFormed) {

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN38@xmlParseDo
$LN46@xmlParseDo:

; 10753: 	ctxt->valid = 0;

	mov	DWORD PTR [esi+100], 0

; 10757: }

	or	eax, -1
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@xmlParseDo:

; 10754: 	return(-1);
; 10755:     }
; 10756:     return(0);

	xor	eax, eax
	pop	esi

; 10757: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseDocument ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlRecoverFile
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlRecoverFile PROC					; COMDAT

; 14266: xmlRecoverFile(const char *filename) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14156:     xmlInitParser();

	call	_xmlInitParser

; 14127:     return(xmlCreateURLParserCtxt(filename, 0));

	mov	edi, DWORD PTR _filename$[ebp]
	push	0
	push	edi
	call	_xmlCreateURLParserCtxt

; 14158:     ctxt = xmlCreateFileParserCtxt(filename);

	mov	esi, eax

; 14127:     return(xmlCreateURLParserCtxt(filename, 0));

	add	esp, 8

; 14159:     if (ctxt == NULL) {

	test	esi, esi
	jne	SHORT $LN6@xmlRecover

; 14268: }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN6@xmlRecover:

; 14167:     xmlDetectSAX2(ctxt);

	push	esi
	call	_xmlDetectSAX2
	add	esp, 4

; 14168:     if (data!=NULL) {
; 14169: 	ctxt->_private = data;
; 14170:     }
; 14171: 
; 14172:     if (ctxt->directory == NULL)

	cmp	DWORD PTR [esi+180], 0
	jne	SHORT $LN10@xmlRecover

; 14173:         ctxt->directory = xmlParserGetDirectory(filename);

	push	edi
	call	_xmlParserGetDirectory
	add	esp, 4
	mov	DWORD PTR [esi+180], eax
$LN10@xmlRecover:

; 14174: 
; 14175:     ctxt->recovery = recovery;
; 14176: 
; 14177:     xmlParseDocument(ctxt);

	push	esi
	mov	DWORD PTR [esi+288], 1
	call	_xmlParseDocument

; 14178: 
; 14179:     if ((ctxt->wellFormed) || recovery) {
; 14180:         ret = ctxt->myDoc;

	mov	edi, DWORD PTR [esi+8]
	add	esp, 4

; 14181: 	if (ret != NULL) {

	test	edi, edi
	je	SHORT $LN15@xmlRecover

; 14182: 	    if (ctxt->input->buf->compressed > 0)

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	mov	eax, 9
	cmovg	ecx, eax
	mov	DWORD PTR [edi+36], ecx
$LN15@xmlRecover:

; 14183: 		ret->compression = 9;
; 14184: 	    else
; 14185: 		ret->compression = ctxt->input->buf->compressed;
; 14186: 	}
; 14187:     }
; 14188:     else {
; 14189:        ret = NULL;
; 14190:        xmlFreeDoc(ctxt->myDoc);
; 14191:        ctxt->myDoc = NULL;
; 14192:     }
; 14193:     if (sax != NULL)
; 14194:         ctxt->sax = NULL;
; 14195:     xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14267:     return(xmlSAXParseFile(NULL, filename, 1));

	mov	eax, edi
	pop	edi

; 14268: }

	pop	esi
	pop	ebp
	ret	0
_xmlRecoverFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlRecoverMemory
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlRecoverMemory PROC					; COMDAT

; 14510: xmlDocPtr xmlRecoverMemory(const char *buffer, int size) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14433:     xmlInitParser();

	call	_xmlInitParser

; 14434: 
; 14435:     ctxt = xmlCreateMemoryParserCtxt(buffer, size);

	push	DWORD PTR _size$[ebp]
	push	DWORD PTR _buffer$[ebp]
	call	_xmlCreateMemoryParserCtxt
	mov	edi, eax
	add	esp, 8

; 14436:     if (ctxt == NULL) return(NULL);

	test	edi, edi
	jne	SHORT $LN6@xmlRecover
	pop	edi

; 14512: }

	pop	ebp
	ret	0
$LN6@xmlRecover:
	push	esi

; 14442:     xmlDetectSAX2(ctxt);

	push	edi
	call	_xmlDetectSAX2

; 14443:     if (data!=NULL) {
; 14444: 	ctxt->_private=data;
; 14445:     }
; 14446: 
; 14447:     ctxt->recovery = recovery;
; 14448: 
; 14449:     xmlParseDocument(ctxt);

	push	edi
	mov	DWORD PTR [edi+288], 1
	call	_xmlParseDocument

; 14450: 
; 14451:     if ((ctxt->wellFormed) || recovery) ret = ctxt->myDoc;

	mov	esi, DWORD PTR [edi+8]

; 14452:     else {
; 14453:        ret = NULL;
; 14454:        xmlFreeDoc(ctxt->myDoc);
; 14455:        ctxt->myDoc = NULL;
; 14456:     }
; 14457:     if (sax != NULL)
; 14458: 	ctxt->sax = NULL;
; 14459:     xmlFreeParserCtxt(ctxt);

	push	edi
	call	_xmlFreeParserCtxt
	add	esp, 12					; 0000000cH

; 14511:    return(xmlSAXParseMemory(NULL, buffer, size, 1));

	mov	eax, esi
	pop	esi
	pop	edi

; 14512: }

	pop	ebp
	ret	0
_xmlRecoverMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlRecoverDoc
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlRecoverDoc PROC					; COMDAT

; 14233: xmlRecoverDoc(const xmlChar *cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14604:     if (cur == NULL) return(NULL);

	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	jne	SHORT $LN4@xmlRecover

; 14234:     return(xmlSAXParseDoc(NULL, cur, 1));

	xor	eax, eax
	pop	esi

; 14235: }

	pop	ebp
	ret	0
$LN4@xmlRecover:
	push	edi

; 14579:     len = xmlStrlen(cur);

	push	esi
	call	_xmlStrlen

; 14580:     return(xmlCreateMemoryParserCtxt((const char *)cur, len));

	push	eax
	push	esi
	call	_xmlCreateMemoryParserCtxt
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 14608:     if (ctxt == NULL) return(NULL);

	test	edi, edi
	jne	SHORT $LN5@xmlRecover
	pop	edi
	pop	esi

; 14235: }

	pop	ebp
	ret	0
$LN5@xmlRecover:

; 14614:     xmlDetectSAX2(ctxt);

	push	edi
	call	_xmlDetectSAX2

; 14615: 
; 14616:     xmlParseDocument(ctxt);

	push	edi
	call	_xmlParseDocument

; 14617:     if ((ctxt->wellFormed) || recovery) ret = ctxt->myDoc;

	mov	esi, DWORD PTR [edi+8]

; 14618:     else {
; 14619:        ret = NULL;
; 14620:        xmlFreeDoc(ctxt->myDoc);
; 14621:        ctxt->myDoc = NULL;
; 14622:     }
; 14623:     if (sax != NULL)
; 14624: 	ctxt->sax = oldsax;
; 14625:     xmlFreeParserCtxt(ctxt);

	push	edi
	call	_xmlFreeParserCtxt
	add	esp, 12					; 0000000cH

; 14234:     return(xmlSAXParseDoc(NULL, cur, 1));

	mov	eax, esi
	pop	edi
	pop	esi

; 14235: }

	pop	ebp
	ret	0
_xmlRecoverDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlStopParser
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlStopParser PROC					; COMDAT

; 12485: xmlStopParser(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlStopPar

; 12486:     if (ctxt == NULL)
; 12487:         return;
; 12488:     xmlHaltParser(ctxt);

	push	esi
	call	_xmlHaltParser
	add	esp, 4

; 12489:     ctxt->errNo = XML_ERR_USER_STOP;

	mov	DWORD PTR [esi+84], 111			; 0000006fH
$LN1@xmlStopPar:
	pop	esi

; 12490: }

	pop	ebp
	ret	0
_xmlStopParser ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseMemory
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlParseMemory PROC					; COMDAT

; 14494: xmlDocPtr xmlParseMemory(const char *buffer, int size) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14433:     xmlInitParser();

	call	_xmlInitParser

; 14434: 
; 14435:     ctxt = xmlCreateMemoryParserCtxt(buffer, size);

	push	DWORD PTR _size$[ebp]
	push	DWORD PTR _buffer$[ebp]
	call	_xmlCreateMemoryParserCtxt
	mov	esi, eax
	add	esp, 8

; 14436:     if (ctxt == NULL) return(NULL);

	test	esi, esi
	jne	SHORT $LN6@xmlParseMe
	pop	esi

; 14496: }

	pop	ebp
	ret	0
$LN6@xmlParseMe:
	push	edi

; 14442:     xmlDetectSAX2(ctxt);

	push	esi
	call	_xmlDetectSAX2

; 14443:     if (data!=NULL) {
; 14444: 	ctxt->_private=data;
; 14445:     }
; 14446: 
; 14447:     ctxt->recovery = recovery;
; 14448: 
; 14449:     xmlParseDocument(ctxt);

	push	esi
	mov	DWORD PTR [esi+288], 0
	call	_xmlParseDocument

; 14450: 
; 14451:     if ((ctxt->wellFormed) || recovery) ret = ctxt->myDoc;

	mov	eax, DWORD PTR [esi+8]
	add	esp, 8
	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN12@xmlParseMe

; 14452:     else {
; 14453:        ret = NULL;
; 14454:        xmlFreeDoc(ctxt->myDoc);

	push	eax
	xor	edi, edi
	call	_xmlFreeDoc
	add	esp, 4

; 14455:        ctxt->myDoc = NULL;

	mov	DWORD PTR [esi+8], edi

; 14456:     }
; 14457:     if (sax != NULL)
; 14458: 	ctxt->sax = NULL;
; 14459:     xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14495:    return(xmlSAXParseMemory(NULL, buffer, size, 0));

	mov	eax, edi
	pop	edi
	pop	esi

; 14496: }

	pop	ebp
	ret	0
$LN12@xmlParseMe:

; 14459:     xmlFreeParserCtxt(ctxt);

	push	esi
	mov	edi, eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14495:    return(xmlSAXParseMemory(NULL, buffer, size, 0));

	mov	eax, edi
	pop	edi
	pop	esi

; 14496: }

	pop	ebp
	ret	0
_xmlParseMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseFile
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlParseFile PROC					; COMDAT

; 14249: xmlParseFile(const char *filename) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14156:     xmlInitParser();

	call	_xmlInitParser

; 14127:     return(xmlCreateURLParserCtxt(filename, 0));

	mov	edi, DWORD PTR _filename$[ebp]
	push	0
	push	edi
	call	_xmlCreateURLParserCtxt

; 14158:     ctxt = xmlCreateFileParserCtxt(filename);

	mov	esi, eax

; 14127:     return(xmlCreateURLParserCtxt(filename, 0));

	add	esp, 8

; 14159:     if (ctxt == NULL) {

	test	esi, esi
	jne	SHORT $LN6@xmlParseFi

; 14251: }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN6@xmlParseFi:

; 14167:     xmlDetectSAX2(ctxt);

	push	esi
	call	_xmlDetectSAX2
	add	esp, 4

; 14168:     if (data!=NULL) {
; 14169: 	ctxt->_private = data;
; 14170:     }
; 14171: 
; 14172:     if (ctxt->directory == NULL)

	cmp	DWORD PTR [esi+180], 0
	jne	SHORT $LN10@xmlParseFi

; 14173:         ctxt->directory = xmlParserGetDirectory(filename);

	push	edi
	call	_xmlParserGetDirectory
	add	esp, 4
	mov	DWORD PTR [esi+180], eax
$LN10@xmlParseFi:

; 14174: 
; 14175:     ctxt->recovery = recovery;
; 14176: 
; 14177:     xmlParseDocument(ctxt);

	push	esi
	mov	DWORD PTR [esi+288], 0
	call	_xmlParseDocument

; 14178: 
; 14179:     if ((ctxt->wellFormed) || recovery) {

	mov	eax, DWORD PTR [esi+8]
	add	esp, 4
	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN13@xmlParseFi

; 14183: 		ret->compression = 9;
; 14184: 	    else
; 14185: 		ret->compression = ctxt->input->buf->compressed;
; 14186: 	}
; 14187:     }
; 14188:     else {
; 14189:        ret = NULL;
; 14190:        xmlFreeDoc(ctxt->myDoc);

	push	eax
	xor	edi, edi
	call	_xmlFreeDoc
	add	esp, 4

; 14191:        ctxt->myDoc = NULL;

	mov	DWORD PTR [esi+8], edi

; 14192:     }
; 14193:     if (sax != NULL)
; 14194:         ctxt->sax = NULL;
; 14195:     xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14250:     return(xmlSAXParseFile(NULL, filename, 0));

	mov	eax, edi
	pop	edi

; 14251: }

	pop	esi
	pop	ebp
	ret	0
$LN13@xmlParseFi:

; 14180:         ret = ctxt->myDoc;

	mov	edi, eax

; 14181: 	if (ret != NULL) {

	test	edi, edi
	je	SHORT $LN15@xmlParseFi

; 14182: 	    if (ctxt->input->buf->compressed > 0)

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	mov	eax, 9
	cmovg	ecx, eax
	mov	DWORD PTR [edi+36], ecx
$LN15@xmlParseFi:

; 14192:     }
; 14193:     if (sax != NULL)
; 14194:         ctxt->sax = NULL;
; 14195:     xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14250:     return(xmlSAXParseFile(NULL, filename, 0));

	mov	eax, edi
	pop	edi

; 14251: }

	pop	esi
	pop	ebp
	ret	0
_xmlParseFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseDoc
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlParseDoc PROC					; COMDAT

; 14640: xmlParseDoc(const xmlChar *cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14604:     if (cur == NULL) return(NULL);

	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	jne	SHORT $LN4@xmlParseDo
$LN15@xmlParseDo:

; 14642: }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlParseDo:

; 14579:     len = xmlStrlen(cur);

	push	esi
	call	_xmlStrlen

; 14580:     return(xmlCreateMemoryParserCtxt((const char *)cur, len));

	push	eax
	push	esi
	call	_xmlCreateMemoryParserCtxt
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 14608:     if (ctxt == NULL) return(NULL);

	test	esi, esi
	je	SHORT $LN15@xmlParseDo
	push	edi

; 14609:     if (sax != NULL) {
; 14610:         oldsax = ctxt->sax;
; 14611:         ctxt->sax = sax;
; 14612:         ctxt->userData = NULL;
; 14613:     }
; 14614:     xmlDetectSAX2(ctxt);

	push	esi
	call	_xmlDetectSAX2

; 14615: 
; 14616:     xmlParseDocument(ctxt);

	push	esi
	call	_xmlParseDocument

; 14617:     if ((ctxt->wellFormed) || recovery) ret = ctxt->myDoc;

	mov	eax, DWORD PTR [esi+8]
	add	esp, 8
	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN9@xmlParseDo

; 14618:     else {
; 14619:        ret = NULL;
; 14620:        xmlFreeDoc(ctxt->myDoc);

	push	eax
	xor	edi, edi
	call	_xmlFreeDoc
	add	esp, 4

; 14621:        ctxt->myDoc = NULL;

	mov	DWORD PTR [esi+8], edi

; 14622:     }
; 14623:     if (sax != NULL)
; 14624: 	ctxt->sax = oldsax;
; 14625:     xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14641:     return(xmlSAXParseDoc(NULL, cur, 0));

	mov	eax, edi
	pop	edi
	pop	esi

; 14642: }

	pop	ebp
	ret	0
$LN9@xmlParseDo:

; 14625:     xmlFreeParserCtxt(ctxt);

	push	esi
	mov	edi, eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14641:     return(xmlSAXParseDoc(NULL, cur, 0));

	mov	eax, edi
	pop	edi
	pop	esi

; 14642: }

	pop	ebp
	ret	0
_xmlParseDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCleanupParser
_TEXT	SEGMENT
_xmlCleanupParser PROC					; COMDAT
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlParserInitialized, 0
	je	SHORT $LN1@xmlCleanup

; 14767:     if (!xmlParserInitialized)
; 14768: 	return;
; 14769: 
; 14770:     xmlCleanupCharEncodingHandlers();
; 14771: #ifdef LIBXML_CATALOG_ENABLED
; 14772:     xmlCatalogCleanup();

	call	_xmlCleanupCharEncodingHandlers
	call	_xmlCatalogCleanup

; 14773: #endif
; 14774:     xmlDictCleanup();

	call	_xmlDictCleanup

; 14775:     xmlCleanupInputCallbacks();

	call	_xmlCleanupInputCallbacks

; 14776: #ifdef LIBXML_OUTPUT_ENABLED
; 14777:     xmlCleanupOutputCallbacks();

	call	_xmlCleanupOutputCallbacks

; 14778: #endif
; 14779: #ifdef LIBXML_SCHEMAS_ENABLED
; 14780:     xmlSchemaCleanupTypes();

	call	_xmlSchemaCleanupTypes

; 14781:     xmlRelaxNGCleanupTypes();

	call	_xmlRelaxNGCleanupTypes

; 14782: #endif
; 14783:     xmlResetLastError();

	call	_xmlResetLastError

; 14784:     xmlCleanupGlobals();

	call	_xmlCleanupGlobals

; 14785:     xmlCleanupThreads(); /* must be last if called not from the main thread */

	call	_xmlCleanupThreads

; 14786:     xmlCleanupMemory();

	call	_xmlCleanupMemory

; 14787:     xmlParserInitialized = 0;

	mov	DWORD PTR _xmlParserInitialized, 0
$LN1@xmlCleanup:

; 14788: }

	ret	0
_xmlCleanupParser ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlInitParser
_TEXT	SEGMENT
_xmlInitParser PROC					; COMDAT
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlParserInitialized, 0
	jne	SHORT $LN1@xmlInitPar

; 14709:     if (xmlParserInitialized != 0)
; 14710: 	return;
; 14711: 
; 14712: #ifdef LIBXML_THREAD_ENABLED
; 14713:     __xmlGlobalInitMutexLock();
; 14714:     if (xmlParserInitialized == 0) {

	call	___xmlGlobalInitMutexLock
	cmp	DWORD PTR _xmlParserInitialized, 0
	jne	SHORT $LN3@xmlInitPar

; 14715: #endif
; 14716: 	xmlInitThreads();

	call	_xmlInitThreads

; 14717: 	xmlInitGlobals();

	call	_xmlInitGlobals

; 14718: 	if ((xmlGenericError == xmlGenericErrorDefaultFunc) ||

	call	___xmlGenericError
	cmp	DWORD PTR [eax], OFFSET _xmlGenericErrorDefaultFunc
	je	SHORT $LN5@xmlInitPar
	call	___xmlGenericError
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@xmlInitPar
$LN5@xmlInitPar:

; 14719: 	    (xmlGenericError == NULL))
; 14720: 	    initGenericErrorDefaultFunc(NULL);

	push	0
	call	_initGenericErrorDefaultFunc
	add	esp, 4
$LN4@xmlInitPar:

; 14721: 	xmlInitMemory();

	call	_xmlInitMemory

; 14722:         xmlInitializeDict();

	call	_xmlInitializeDict

; 14723: 	xmlInitCharEncodingHandlers();

	call	_xmlInitCharEncodingHandlers

; 14724: 	xmlDefaultSAXHandlerInit();

	call	_xmlDefaultSAXHandlerInit

; 14725: 	xmlRegisterDefaultInputCallbacks();

	call	_xmlRegisterDefaultInputCallbacks

; 14726: #ifdef LIBXML_OUTPUT_ENABLED
; 14727: 	xmlRegisterDefaultOutputCallbacks();

	call	_xmlRegisterDefaultOutputCallbacks

; 14728: #endif /* LIBXML_OUTPUT_ENABLED */
; 14729: #ifdef LIBXML_HTML_ENABLED
; 14730: 	htmlInitAutoClose();

	call	_htmlInitAutoClose

; 14731: 	htmlDefaultSAXHandlerInit();

	call	_htmlDefaultSAXHandlerInit

; 14732: #endif
; 14733: #ifdef LIBXML_XPATH_ENABLED
; 14734: 	xmlXPathInit();

	call	_xmlXPathInit

; 14735: #endif
; 14736: 	xmlParserInitialized = 1;

	mov	DWORD PTR _xmlParserInitialized, 1
$LN3@xmlInitPar:

; 14737: #ifdef LIBXML_THREAD_ENABLED
; 14738:     }
; 14739:     __xmlGlobalInitMutexUnlock();

	jmp	___xmlGlobalInitMutexUnlock
$LN1@xmlInitPar:

; 14740: #endif
; 14741: }

	ret	0
_xmlInitParser ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	or	ecx, 2
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;

	pop	esi

; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
