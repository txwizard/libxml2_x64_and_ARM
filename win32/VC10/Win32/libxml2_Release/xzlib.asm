; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xzlib.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__A40A425D_stat@h DB 01H
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__6B55C7C2_xzlib@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	___libxml2_xzopen
PUBLIC	___libxml2_xzdopen
PUBLIC	___libxml2_xzread
PUBLIC	___libxml2_xzclose
PUBLIC	___libxml2_xzcompressed
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory@		; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@		; `string'
PUBLIC	??_C@_06CJNJFBNP@1?42?411@			; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ ; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@	; `string'
PUBLIC	??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@	; `string'
PUBLIC	??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@ ; `string'
PUBLIC	??_C@_0BG@HCKBMIHF@compressed?5data?5error@	; `string'
PUBLIC	??_C@_0BC@NKDLBFJI@compression?5error@		; `string'
PUBLIC	??_C@_0L@BFJCHCMP@lzma?5error@			; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check@	; `string'
PUBLIC	??_C@_0BB@LGIBDOHL@trailing?5garbage@		; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@ ; `string'
EXTRN	__imp__close:PROC
EXTRN	__imp__lseek:PROC
EXTRN	__imp__open:PROC
EXTRN	__imp__read:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__strerror:PROC
EXTRN	__imp__free:PROC
EXTRN	_inflate@8:PROC
EXTRN	_inflateEnd@4:PROC
EXTRN	_inflateReset@4:PROC
EXTRN	_crc32@12:PROC
EXTRN	_inflateInit2_@16:PROC
EXTRN	__imp__lzma_code:PROC
EXTRN	__imp__lzma_end:PROC
EXTRN	__imp__lzma_properties_decode:PROC
EXTRN	__imp__lzma_auto_decoder:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memcpy:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@ DB 'requested le'
	DB	'ngth does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LGIBDOHL@trailing?5garbage@
CONST	SEGMENT
??_C@_0BB@LGIBDOHL@trailing?5garbage@ DB 'trailing garbage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check@ DB 'incorrect length check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BFJCHCMP@lzma?5error@
CONST	SEGMENT
??_C@_0L@BFJCHCMP@lzma?5error@ DB 'lzma error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NKDLBFJI@compression?5error@
CONST	SEGMENT
??_C@_0BC@NKDLBFJI@compression?5error@ DB 'compression error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCKBMIHF@compressed?5data?5error@
CONST	SEGMENT
??_C@_0BG@HCKBMIHF@compressed?5data?5error@ DB 'compressed data error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@
CONST	SEGMENT
??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@ DB 'internal err'
	DB	'or: inflate stream corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@
CONST	SEGMENT
??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@ DB 'unexpected end of file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@ DB 'unknown header flags '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ DB 'unknown compression '
	DB	'method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06CJNJFBNP@1?42?411@
CONST	SEGMENT
??_C@_06CJNJFBNP@1?42?411@ DB '1.2.11', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@ DB '<fd:%d>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory@ DB 'out of memory', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_skip
_TEXT	SEGMENT
_state$ = 8						; size = 4
_len$ = 12						; size = 8
_len$2$ = 16						; size = 4
_xz_skip PROC						; COMDAT

; 669  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _len$[ebp]
	mov	eax, edi
	mov	edx, DWORD PTR _len$[ebp+4]
	or	eax, edx
	mov	DWORD PTR _len$2$[ebp], edx
	je	$LN3@xz_skip
	mov	esi, DWORD PTR _state$[ebp]
	lea	ebx, DWORD PTR [esi+44]
	npad	7
$LL2@xz_skip:

; 674  :         /* skip over whatever is in output buffer */
; 675  :         if (state->have) {

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN4@xz_skip

; 676  :             n = (uint64_t) state->have > len ?

	xor	ecx, ecx
	cmp	ecx, edx
	jb	SHORT $LN10@xz_skip
	ja	SHORT $LN36@xz_skip
	cmp	eax, edi
	jbe	SHORT $LN10@xz_skip
$LN36@xz_skip:
	mov	ecx, edi
	jmp	SHORT $LN11@xz_skip
$LN10@xz_skip:
	mov	ecx, eax
$LN11@xz_skip:

; 677  :                 (unsigned) len : state->have;
; 678  :             state->have -= n;
; 679  :             state->next += n;

	add	DWORD PTR [esi+40], ecx
	sub	eax, ecx

; 680  :             state->pos += n;

	add	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [ebx], eax
	adc	DWORD PTR [esi+20], 0

; 681  :             len -= n;

	sub	edi, ecx
	sbb	edx, 0
	mov	DWORD PTR _len$2$[ebp], edx

; 682  :         }

	jmp	SHORT $LN21@xz_skip
$LN4@xz_skip:

; 683  : 
; 684  :     /* output buffer empty -- return if we're at the end of the input */
; 685  :         else if (state->eof && state->strm.avail_in == 0)

	cmp	DWORD PTR [esi+48], 0
	je	SHORT $LN6@xz_skip
	cmp	DWORD PTR [esi+108], 0
	je	SHORT $LN3@xz_skip
$LN6@xz_skip:

; 647  :     if (state->how == LOOK) {   /* look for lzma / gzip header */

	cmp	DWORD PTR [esi+72], 0
	jne	SHORT $LN35@xz_skip

; 648  :         if (xz_head(state) == -1)

	push	esi
	call	_xz_head
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN25@xz_skip

; 649  :             return -1;
; 650  :         if (state->have)        /* got some data from xz_head() */

	cmp	DWORD PTR [ebx], 0
	mov	edx, DWORD PTR _len$2$[ebp]
	jne	SHORT $LN21@xz_skip
$LN35@xz_skip:

; 651  :             return 0;
; 652  :     }
; 653  :     if (state->how == COPY) {   /* straight copy */

	mov	eax, DWORD PTR [esi+72]
	cmp	eax, 1
	jne	SHORT $LN16@xz_skip

; 654  :         if (xz_load(state, state->out, state->size << 1, &(state->have)) ==

	mov	eax, DWORD PTR [esi+24]
	push	ebx
	add	eax, eax
	push	eax
	push	DWORD PTR [esi+36]
	push	esi
	call	_xz_load
	add	esp, 16					; 00000010H
	cmp	eax, -1
	je	SHORT $LN25@xz_skip

; 655  :             -1)
; 656  :             return -1;
; 657  :         state->next = state->out;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+40], eax
	jmp	SHORT $LN38@xz_skip
$LN16@xz_skip:

; 658  :     } else if (state->how == LZMA || state->how == GZIP) {      /* decompress */

	cmp	eax, 3
	je	SHORT $LN20@xz_skip
	cmp	eax, 2
	jne	SHORT $LN21@xz_skip
$LN20@xz_skip:

; 659  :         strm->avail_out = state->size << 1;

	mov	eax, DWORD PTR [esi+24]
	add	eax, eax
	mov	DWORD PTR [esi+124], eax

; 660  :         strm->next_out = state->out;

	mov	eax, DWORD PTR [esi+36]

; 661  :         if (xz_decomp(state) == -1)

	push	esi
	mov	DWORD PTR [esi+120], eax
	call	_xz_decomp
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN25@xz_skip
$LN38@xz_skip:

; 670  :     unsigned n;
; 671  : 
; 672  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 673  :     while (len)

	mov	edx, DWORD PTR _len$2$[ebp]
$LN21@xz_skip:
	mov	eax, edi
	or	eax, edx
	jne	$LL2@xz_skip
$LN3@xz_skip:
	pop	edi

; 686  :             break;
; 687  : 
; 688  :     /* need more data to skip -- load up output buffer */
; 689  :         else {
; 690  :             /* get more output, looking for header if required */
; 691  :             if (xz_make(state) == -1)
; 692  :                 return -1;
; 693  :         }
; 694  :     return 0;
; 695  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN25@xz_skip:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
_xz_skip ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_make
_TEXT	SEGMENT
_state$ = 8						; size = 4
_xz_make PROC						; COMDAT

; 644  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	jne	SHORT $LN13@xz_make

; 645  :     lzma_stream *strm = &(state->strm);
; 646  : 
; 647  :     if (state->how == LOOK) {   /* look for lzma / gzip header */
; 648  :         if (xz_head(state) == -1)

	push	esi
	call	_xz_head
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN14@xz_make

; 649  :             return -1;
; 650  :         if (state->have)        /* got some data from xz_head() */

	cmp	DWORD PTR [esi+44], 0
	lea	ecx, DWORD PTR [esi+44]
	jne	SHORT $LN10@xz_make
	mov	eax, DWORD PTR [esi+72]
	jmp	SHORT $LN4@xz_make
$LN13@xz_make:
	lea	ecx, DWORD PTR [esi+44]
$LN4@xz_make:

; 651  :             return 0;
; 652  :     }
; 653  :     if (state->how == COPY) {   /* straight copy */

	cmp	eax, 1
	jne	SHORT $LN5@xz_make

; 654  :         if (xz_load(state, state->out, state->size << 1, &(state->have)) ==

	mov	eax, DWORD PTR [esi+24]
	push	ecx
	add	eax, eax
	push	eax
	push	DWORD PTR [esi+36]
	push	esi
	call	_xz_load
	add	esp, 16					; 00000010H
	cmp	eax, -1
	je	SHORT $LN14@xz_make

; 655  :             -1)
; 656  :             return -1;
; 657  :         state->next = state->out;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+40], eax
$LN10@xz_make:

; 663  :     }
; 664  :     return 0;

	xor	eax, eax
	pop	esi

; 665  : }

	pop	ebp
	ret	0
$LN5@xz_make:

; 658  :     } else if (state->how == LZMA || state->how == GZIP) {      /* decompress */

	cmp	eax, 3
	je	SHORT $LN9@xz_make
	cmp	eax, 2
	jne	SHORT $LN10@xz_make
$LN9@xz_make:

; 659  :         strm->avail_out = state->size << 1;

	mov	eax, DWORD PTR [esi+24]
	add	eax, eax
	mov	DWORD PTR [esi+124], eax

; 660  :         strm->next_out = state->out;

	mov	eax, DWORD PTR [esi+36]

; 661  :         if (xz_decomp(state) == -1)

	push	esi
	mov	DWORD PTR [esi+120], eax
	call	_xz_decomp
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN10@xz_make
$LN14@xz_make:

; 662  :             return -1;

	or	eax, -1
	pop	esi

; 665  : }

	pop	ebp
	ret	0
_xz_make ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_decomp
_TEXT	SEGMENT
_had$1$ = -8						; size = 4
_len$ = -8						; size = 4
_tmp$1 = -4						; size = 4
_action$1$ = 8						; size = 4
_crc$ = 8						; size = 4
_state$ = 8						; size = 4
_xz_decomp PROC						; COMDAT

; 531  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _state$[ebp]
	xor	ecx, ecx
	mov	eax, DWORD PTR [esi+124]
	lea	ebx, DWORD PTR [esi+104]
	mov	DWORD PTR _action$1$[ebp], ecx
	mov	DWORD PTR _had$1$[ebp], eax
$LN57@xz_decomp:

; 532  :     int ret;
; 533  :     unsigned had;
; 534  :     unsigned long crc, len;
; 535  :     lzma_stream *strm = &(state->strm);
; 536  : 
; 537  :     lzma_action action = LZMA_RUN;
; 538  : 
; 539  :     /* fill output buffer up to end of deflate stream */
; 540  :     had = strm->avail_out;
; 541  :     do {
; 542  :         /* get more input for inflate() */
; 543  :         if (strm->avail_in == 0 && xz_avail(state) == -1)

	mov	eax, DWORD PTR [ebx+4]
	mov	edx, 3
	test	eax, eax
	jne	SHORT $LN55@xz_decomp

; 259  :     if (state->err != LZMA_OK)

	cmp	DWORD PTR [esi+92], eax
	jne	$LN44@xz_decomp

; 260  :         return -1;
; 261  :     if (state->eof == 0) {

	cmp	DWORD PTR [esi+48], eax
	jne	SHORT $LN56@xz_decomp

; 262  :         /* avail_in is size_t, which is not necessary sizeof(unsigned) */
; 263  :         unsigned tmp = strm->avail_in;

	mov	DWORD PTR _tmp$1[ebp], eax

; 264  : 
; 265  :         if (xz_load(state, state->in, state->size, &tmp) == -1) {

	lea	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	push	DWORD PTR [esi+24]
	push	DWORD PTR [esi+32]
	push	esi
	call	_xz_load
	add	esp, 16					; 00000010H
	cmp	eax, -1
	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [ebx+4], eax
	je	$LN44@xz_decomp

; 266  :             strm->avail_in = tmp;
; 267  :             return -1;
; 268  :         }
; 269  :         strm->avail_in = tmp;
; 270  :         strm->next_in = state->in;

	mov	eax, DWORD PTR [esi+32]
	mov	edx, 3
	mov	ecx, DWORD PTR _action$1$[ebp]
	mov	DWORD PTR [ebx], eax
	mov	eax, DWORD PTR [ebx+4]
$LN56@xz_decomp:

; 544  :             return -1;
; 545  :         if (strm->avail_in == 0) {

	test	eax, eax
	je	$LN24@xz_decomp
$LN55@xz_decomp:

; 546  :             xz_error(state, LZMA_DATA_ERROR, "unexpected end of file");
; 547  :             return -1;
; 548  :         }
; 549  :         if (state->eof)

	cmp	DWORD PTR [esi+48], 0
	cmovne	ecx, edx

; 550  :             action = LZMA_FINISH;
; 551  : 
; 552  :         /* decompress and handle errors */
; 553  : #ifdef LIBXML_ZLIB_ENABLED
; 554  :         if (state->how == GZIP) {

	cmp	DWORD PTR [esi+72], 2
	mov	DWORD PTR _action$1$[ebp], ecx
	jne	$LN8@xz_decomp

; 555  :             state->zstrm.avail_in = (uInt) state->strm.avail_in;

	mov	eax, DWORD PTR [esi+108]

; 556  :             state->zstrm.next_in = (Bytef *) state->strm.next_in;

	lea	ecx, DWORD PTR [esi+224]
	mov	DWORD PTR [esi+228], eax
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ecx], eax

; 557  :             state->zstrm.avail_out = (uInt) state->strm.avail_out;

	mov	eax, DWORD PTR [esi+124]

; 558  :             state->zstrm.next_out = (Bytef *) state->strm.next_out;
; 559  :             ret = inflate(&state->zstrm, Z_NO_FLUSH);

	push	0
	mov	DWORD PTR [esi+240], eax
	mov	eax, DWORD PTR [esi+120]
	push	ecx
	mov	DWORD PTR [esi+236], eax
	call	_inflate@8
	mov	edi, eax

; 560  :             if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {

	cmp	edi, -2					; fffffffeH
	je	$LN46@xz_decomp
	cmp	edi, 2
	je	$LN46@xz_decomp

; 562  :                          "internal error: inflate stream corrupt");
; 563  :                 return -1;
; 564  :             }
; 565  :             /*
; 566  :              * FIXME: Remapping a couple of error codes and falling through
; 567  :              * to the LZMA error handling looks fragile.
; 568  :              */
; 569  :             if (ret == Z_MEM_ERROR)

	cmp	edi, -4					; fffffffcH
	jne	SHORT $LN12@xz_decomp

; 570  :                 ret = LZMA_MEM_ERROR;

	lea	edi, DWORD PTR [eax+9]

; 571  :             if (ret == Z_DATA_ERROR)

	jmp	SHORT $LN14@xz_decomp
$LN12@xz_decomp:
	cmp	edi, -3					; fffffffdH
	jne	SHORT $LN13@xz_decomp

; 572  :                 ret = LZMA_DATA_ERROR;

	mov	edi, 9

; 573  :             if (ret == Z_STREAM_END)

	jmp	SHORT $LN14@xz_decomp
$LN13@xz_decomp:
	cmp	edi, 1
	mov	eax, 1
	cmove	edi, eax
$LN14@xz_decomp:

; 574  :                 ret = LZMA_STREAM_END;
; 575  :             state->strm.avail_in = state->zstrm.avail_in;

	mov	eax, DWORD PTR [esi+228]
	mov	DWORD PTR [esi+108], eax

; 576  :             state->strm.next_in = state->zstrm.next_in;

	mov	eax, DWORD PTR [esi+224]
	mov	DWORD PTR [ebx], eax

; 577  :             state->strm.avail_out = state->zstrm.avail_out;

	mov	eax, DWORD PTR [esi+240]
	mov	DWORD PTR [esi+124], eax

; 578  :             state->strm.next_out = state->zstrm.next_out;

	mov	eax, DWORD PTR [esi+236]
	mov	DWORD PTR [esi+120], eax

; 579  :         } else                  /* state->how == LZMA */

	jmp	SHORT $LN9@xz_decomp
$LN8@xz_decomp:

; 580  : #endif
; 581  :             ret = lzma_code(strm, action);

	push	ecx
	push	ebx
	call	DWORD PTR __imp__lzma_code
	add	esp, 8
	mov	edi, eax
$LN9@xz_decomp:

; 582  :         if (ret == LZMA_MEM_ERROR) {

	cmp	edi, 5
	je	$LN47@xz_decomp

; 583  :             xz_error(state, LZMA_MEM_ERROR, "out of memory");
; 584  :             return -1;
; 585  :         }
; 586  :         if (ret == LZMA_DATA_ERROR) {

	cmp	edi, 9
	je	$LN48@xz_decomp

; 588  :             return -1;
; 589  :         }
; 590  :         if (ret == LZMA_PROG_ERROR) {

	cmp	edi, 11					; 0000000bH
	je	$LN49@xz_decomp

; 592  :             return -1;
; 593  :         }
; 594  :         if ((state->how != GZIP) &&
; 595  :             (ret != LZMA_OK) && (ret != LZMA_STREAM_END)) {

	cmp	DWORD PTR [esi+72], 2
	je	SHORT $LN2@xz_decomp
	test	edi, edi
	je	SHORT $LN2@xz_decomp
	cmp	edi, 1
	jne	SHORT $LN50@xz_decomp
$LN2@xz_decomp:

; 597  :             return -1;
; 598  :         }
; 599  :     } while (strm->avail_out && ret != LZMA_STREAM_END);

	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	je	SHORT $LN19@xz_decomp
	cmp	edi, 1
	je	SHORT $LN19@xz_decomp
	mov	ecx, DWORD PTR _action$1$[ebp]
	jmp	$LN57@xz_decomp
$LN46@xz_decomp:

; 561  :                 xz_error(state, Z_STREAM_ERROR,

	push	OFFSET ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@
	push	-2					; fffffffeH
	push	esi
	call	_xz_error
	add	esp, 12					; 0000000cH

; 640  : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@xz_decomp:

; 596  :             xz_error(state, ret, "lzma error");

	push	OFFSET ??_C@_0L@BFJCHCMP@lzma?5error@
	push	edi
	push	esi
	call	_xz_error
	add	esp, 12					; 0000000cH

; 640  : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xz_decomp:

; 600  : 
; 601  :     /* update available output and crc check value */
; 602  :     state->have = had - strm->avail_out;

	mov	ecx, DWORD PTR _had$1$[ebp]
	sub	ecx, eax
	mov	DWORD PTR [esi+44], ecx

; 603  :     state->next = strm->next_out - state->have;

	mov	eax, DWORD PTR [ebx+16]
	sub	eax, ecx

; 604  : #ifdef LIBXML_ZLIB_ENABLED
; 605  :     state->zstrm.adler =

	push	ecx
	push	eax
	push	DWORD PTR [esi+272]
	mov	DWORD PTR [esi+40], eax
	call	_crc32@12
	mov	DWORD PTR [esi+272], eax

; 606  :         crc32(state->zstrm.adler, state->next, state->have);
; 607  : #endif
; 608  : 
; 609  :     if (ret == LZMA_STREAM_END) {

	cmp	edi, 1
	jne	$LN20@xz_decomp

; 610  : #ifdef LIBXML_ZLIB_ENABLED
; 611  :         if (state->how == GZIP) {

	cmp	DWORD PTR [esi+72], 2
	jne	$LN21@xz_decomp

; 612  :             if (gz_next4(state, &crc) == -1 || gz_next4(state, &len) == -1) {

	lea	eax, DWORD PTR _crc$[ebp]
	push	eax
	push	esi
	call	_gz_next4
	add	esp, 8
	cmp	eax, -1
	je	$LN24@xz_decomp
	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	esi
	call	_gz_next4
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN24@xz_decomp

; 614  :                 return -1;
; 615  :             }
; 616  :             if (crc != state->zstrm.adler) {

	mov	eax, DWORD PTR _crc$[ebp]
	cmp	eax, DWORD PTR [esi+272]
	je	SHORT $LN25@xz_decomp

; 617  :                 xz_error(state, LZMA_DATA_ERROR, "incorrect data check");

	push	OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
	push	9
	push	esi
	call	_xz_error
	add	esp, 12					; 0000000cH

; 640  : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xz_decomp:

; 618  :                 return -1;
; 619  :             }
; 620  :             if (len != (state->zstrm.total_out & 0xffffffffL)) {

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR [esi+244]
	je	SHORT $LN26@xz_decomp

; 621  :                 xz_error(state, LZMA_DATA_ERROR, "incorrect length check");

	push	OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
	push	9
	push	esi
	call	_xz_error
	add	esp, 12					; 0000000cH

; 640  : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xz_decomp:
	pop	edi

; 622  :                 return -1;
; 623  :             }
; 624  :             state->strm.avail_in = 0;

	mov	DWORD PTR [esi+108], 0

; 635  :                                  * state->direct unchanged to remember how) */
; 636  :     }
; 637  : 
; 638  :     /* good decompression */
; 639  :     return 0;

	xor	eax, eax
	mov	DWORD PTR [esi+124], 0
	mov	DWORD PTR [esi+120], 0
	mov	DWORD PTR [esi+72], 0

; 640  : }

	pop	esi
	mov	DWORD PTR [ebx], 0
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xz_decomp:

; 613  :                 xz_error(state, LZMA_DATA_ERROR, "unexpected end of file");

	push	OFFSET ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@
	push	9
	push	esi
	call	_xz_error
	add	esp, 12					; 0000000cH

; 640  : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xz_decomp:

; 625  :             state->strm.next_in = NULL;
; 626  :             state->strm.avail_out = 0;
; 627  :             state->strm.next_out = NULL;
; 628  :         } else
; 629  : #endif
; 630  :         if (strm->avail_in != 0 || !state->eof) {

	cmp	DWORD PTR [ebx+4], 0
	jne	SHORT $LN28@xz_decomp
	cmp	DWORD PTR [esi+48], 0
	je	SHORT $LN28@xz_decomp

; 632  :             return -1;
; 633  :         }
; 634  :         state->how = LOOK;      /* ready for next stream, once have is 0 (leave

	mov	DWORD PTR [esi+72], 0
$LN20@xz_decomp:
	pop	edi

; 640  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xz_decomp:

; 631  :             xz_error(state, LZMA_DATA_ERROR, "trailing garbage");

	push	OFFSET ??_C@_0BB@LGIBDOHL@trailing?5garbage@
	push	9
	push	esi
	call	_xz_error
	add	esp, 12					; 0000000cH

; 640  : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@xz_decomp:

; 591  :             xz_error(state, LZMA_PROG_ERROR, "compression error");

	push	OFFSET ??_C@_0BC@NKDLBFJI@compression?5error@
	push	11					; 0000000bH
	push	esi
	call	_xz_error
	add	esp, 12					; 0000000cH

; 640  : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@xz_decomp:

; 587  :             xz_error(state, LZMA_DATA_ERROR, "compressed data error");

	push	OFFSET ??_C@_0BG@HCKBMIHF@compressed?5data?5error@
	push	9
	push	esi
	call	_xz_error
	add	esp, 12					; 0000000cH

; 640  : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@xz_decomp:

; 92   :     if (state->msg != NULL) {

	mov	eax, DWORD PTR [esi+96]
	test	eax, eax
	je	SHORT $LN37@xz_decomp

; 93   :         if (state->err != LZMA_MEM_ERROR)

	cmp	DWORD PTR [esi+92], 5
	je	SHORT $LN37@xz_decomp

; 94   :             xmlFree(state->msg);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN37@xz_decomp:

; 95   :         state->msg = NULL;
; 96   :     }
; 97   : 
; 98   :     /* set error code, and if no message, then done */
; 99   :     state->err = err;

	mov	DWORD PTR [esi+92], 5

; 100  :     if (msg == NULL)
; 101  :         return;
; 102  : 
; 103  :     /* for an out of memory error, save as static string */
; 104  :     if (err == LZMA_MEM_ERROR) {
; 105  :         state->msg = (char *) msg;

	mov	DWORD PTR [esi+96], OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
$LN44@xz_decomp:
	pop	edi

; 640  : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xz_decomp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_head
_TEXT	SEGMENT
_init$ = -104						; size = 88
_filter$1 = -16						; size = 16
_uncompressed_size$1$ = 8				; size = 4
_flags$1$ = 8						; size = 4
_state$ = 8						; size = 4
_xz_head PROC						; COMDAT

; 386  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	esi
	push	edi
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _state$[ebp]
	xorps	xmm0, xmm0
	mov	DWORD PTR _init$[ebp], 0
	mov	DWORD PTR _init$[ebp+4], 0
	movlpd	QWORD PTR _init$[ebp+8], xmm0
	cmp	DWORD PTR [edi+24], 0
	lea	esi, DWORD PTR [edi+104]
	mov	DWORD PTR _init$[ebp+16], 0
	mov	DWORD PTR _init$[ebp+20], 0
	movlpd	QWORD PTR _init$[ebp+24], xmm0
	mov	DWORD PTR _init$[ebp+48], 0
	mov	DWORD PTR _init$[ebp+52], 0
	movlpd	QWORD PTR _init$[ebp+56], xmm0
	movlpd	QWORD PTR _init$[ebp+64], xmm0
	mov	DWORD PTR _init$[ebp+72], 0
	mov	DWORD PTR _init$[ebp+76], 0
	mov	DWORD PTR _init$[ebp+80], 0
	mov	DWORD PTR _init$[ebp+84], 0
	jne	$LN14@xz_head

; 387  :     lzma_stream *strm = &(state->strm);
; 388  :     lzma_stream init = LZMA_STREAM_INIT;
; 389  :     int flags;
; 390  :     unsigned len;
; 391  : 
; 392  :     /* allocate read buffers and inflate memory */
; 393  :     if (state->size == 0) {
; 394  :         /* allocate buffers */
; 395  :         state->in = xmlMalloc(state->want);

	push	DWORD PTR [edi+28]
	call	DWORD PTR _xmlMalloc
	mov	DWORD PTR [edi+32], eax

; 396  :         state->out = xmlMalloc(state->want << 1);

	mov	eax, DWORD PTR [edi+28]
	add	eax, eax
	push	eax
	call	DWORD PTR _xmlMalloc

; 397  :         if (state->in == NULL || state->out == NULL) {

	mov	ecx, DWORD PTR [edi+32]
	add	esp, 8
	mov	DWORD PTR [edi+36], eax
	test	ecx, ecx
	je	$LN10@xz_head
	test	eax, eax
	je	$LN11@xz_head

; 402  :             xz_error(state, LZMA_MEM_ERROR, "out of memory");
; 403  :             return -1;
; 404  :         }
; 405  :         state->size = state->want;
; 406  : 
; 407  :         /* allocate decoder memory */
; 408  :         state->strm = init;

	movups	xmm0, XMMWORD PTR _init$[ebp]
	mov	eax, DWORD PTR [edi+28]

; 409  :         state->strm.avail_in = 0;
; 410  :         state->strm.next_in = NULL;
; 411  :         if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {

	push	0
	movups	XMMWORD PTR [esi], xmm0
	push	0
	movups	xmm0, XMMWORD PTR _init$[ebp+16]
	push	100000000				; 05f5e100H
	push	esi
	movups	XMMWORD PTR [esi+16], xmm0
	mov	DWORD PTR [edi+24], eax
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [esi+32], xmm0
	movups	xmm0, XMMWORD PTR _init$[ebp+48]
	movups	XMMWORD PTR [esi+48], xmm0
	movups	xmm0, XMMWORD PTR _init$[ebp+64]
	movups	XMMWORD PTR [esi+64], xmm0
	movq	xmm0, QWORD PTR _init$[ebp+80]
	movq	QWORD PTR [esi+80], xmm0
	mov	DWORD PTR [edi+108], 0
	mov	DWORD PTR [esi], 0
	call	DWORD PTR __imp__lzma_auto_decoder
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN13@xz_head
$LN213@xz_head:

; 527  : }

	push	DWORD PTR [edi+36]
	call	DWORD PTR _xmlFree
	push	DWORD PTR [edi+32]
	call	DWORD PTR _xmlFree
	add	esp, 8
	mov	DWORD PTR [edi+24], 0
	jmp	$LN12@xz_head
$LN13@xz_head:

; 412  :             xmlFree(state->out);
; 413  :             xmlFree(state->in);
; 414  :             state->size = 0;
; 415  :             xz_error(state, LZMA_MEM_ERROR, "out of memory");
; 416  :             return -1;
; 417  :         }
; 418  : #ifdef LIBXML_ZLIB_ENABLED
; 419  :         /* allocate inflate memory */
; 420  :         state->zstrm.zalloc = Z_NULL;
; 421  :         state->zstrm.zfree = Z_NULL;
; 422  :         state->zstrm.opaque = Z_NULL;
; 423  :         state->zstrm.avail_in = 0;
; 424  :         state->zstrm.next_in = Z_NULL;
; 425  :         if (state->init == 0) {

	cmp	DWORD PTR [edi+100], 0
	lea	eax, DWORD PTR [edi+224]
	mov	DWORD PTR [edi+256], 0
	mov	DWORD PTR [edi+260], 0
	mov	DWORD PTR [edi+264], 0
	mov	DWORD PTR [edi+228], 0
	mov	DWORD PTR [eax], 0
	jne	SHORT $LN14@xz_head

; 426  :             if (inflateInit2(&(state->zstrm), -15) != Z_OK) {/* raw inflate */

	push	56					; 00000038H
	push	OFFSET ??_C@_06CJNJFBNP@1?42?411@
	push	-15					; fffffff1H
	push	eax
	call	_inflateInit2_@16
	test	eax, eax
	jne	SHORT $LN213@xz_head

; 427  :                 xmlFree(state->out);
; 428  :                 xmlFree(state->in);
; 429  :                 state->size = 0;
; 430  :                 xz_error(state, LZMA_MEM_ERROR, "out of memory");
; 431  :                 return -1;
; 432  :             }
; 433  :             state->init = 1;

	mov	DWORD PTR [edi+100], 1
$LN14@xz_head:

; 434  :         }
; 435  : #endif
; 436  :     }
; 437  : 
; 438  :     /* get some data in the input buffer */
; 439  :     if (strm->avail_in == 0) {

	cmp	DWORD PTR [esi+4], 0
	push	ebx
	jne	SHORT $LN18@xz_head

; 440  :         if (xz_avail(state) == -1)

	push	edi
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	je	$LN189@xz_head

; 441  :             return -1;
; 442  :         if (strm->avail_in == 0)

	cmp	DWORD PTR [esi+4], 0
	je	$LN198@xz_head
$LN18@xz_head:

; 294  :     return strm->avail_in >= 6 && memcmp(state->in, "\3757zXZ", 6) == 0;

	mov	ecx, DWORD PTR [edi+108]
	cmp	ecx, 6
	jb	SHORT $LN190@xz_head
	mov	eax, DWORD PTR [edi+32]
	cmp	DWORD PTR [eax], 1484404733		; 587a37fdH
	jne	SHORT $LN190@xz_head
	cmp	WORD PTR [eax+4], 90			; 0000005aH
	je	$LN191@xz_head
$LN190@xz_head:

; 308  :     if (strm->avail_in < 13)

	cmp	ecx, 13					; 0000000dH
	jb	$LN179@xz_head

; 309  :         return 0;
; 310  : 
; 311  :     filter.id = LZMA_FILTER_LZMA1;
; 312  :     if (lzma_properties_decode(&filter, NULL, state->in, 5) != LZMA_OK)

	push	5
	push	DWORD PTR [edi+32]
	lea	eax, DWORD PTR _filter$1[ebp]
	mov	DWORD PTR _filter$1[ebp], 1
	push	0
	push	eax
	mov	DWORD PTR _filter$1[ebp+4], 1073741824	; 40000000H
	call	DWORD PTR __imp__lzma_properties_decode
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN179@xz_head

; 313  :         return 0;
; 314  : 
; 315  :     opt = filter.options;
; 316  :     dict_size = opt->dict_size;

	mov	eax, DWORD PTR _filter$1[ebp+8]

; 317  :     free(opt); /* we can't use xmlFree on a string returned by zlib */

	push	eax
	mov	ebx, DWORD PTR [eax]
	call	DWORD PTR __imp__free
	add	esp, 4

; 318  : 
; 319  :     /* A hack to ditch tons of false positives: We allow only dictionary
; 320  :      * sizes that are 2^n or 2^n + 2^(n-1) or UINT32_MAX. LZMA_Alone
; 321  :      * created only files with 2^n, but accepts any dictionary size.
; 322  :      * If someone complains, this will be reconsidered.
; 323  :      */
; 324  :     if (dict_size != UINT32_MAX) {

	cmp	ebx, -1
	je	SHORT $LN129@xz_head

; 325  :         uint32_t d = dict_size - 1;

	lea	ecx, DWORD PTR [ebx-1]

; 326  : 
; 327  :         d |= d >> 2;

	mov	eax, ecx
	shr	eax, 2
	or	ecx, eax

; 328  :         d |= d >> 3;

	mov	eax, ecx
	shr	eax, 3
	or	ecx, eax

; 329  :         d |= d >> 4;

	mov	eax, ecx
	shr	eax, 4
	or	ecx, eax

; 330  :         d |= d >> 8;

	mov	eax, ecx
	shr	eax, 8
	or	ecx, eax

; 331  :         d |= d >> 16;

	mov	eax, ecx
	shr	eax, 16					; 00000010H
	or	eax, ecx

; 332  :         ++d;

	inc	eax

; 333  :         if (d != dict_size || dict_size == 0)

	cmp	eax, ebx
	jne	$LN179@xz_head
	test	ebx, ebx
	je	$LN179@xz_head
$LN129@xz_head:

; 334  :             return 0;
; 335  :     }
; 336  : 
; 337  :     /* Another hack to ditch false positives: Assume that if the
; 338  :      * uncompressed size is known, it must be less than 256 GiB.
; 339  :      * Again, if someone complains, this will be reconsidered.
; 340  :      */
; 341  :     uncompressed_size = 0;
; 342  :     for (i = 0; i < 8; ++i)
; 343  :         uncompressed_size |= (uint64_t) (state->in[5 + i]) << (i * 8);

	mov	ecx, DWORD PTR [edi+32]
	movzx	eax, BYTE PTR [ecx+12]
	cdq
	mov	ebx, eax
	mov	eax, edx
	shld	eax, ebx, 8
	mov	DWORD PTR _uncompressed_size$1$[ebp], eax
	movzx	eax, BYTE PTR [ecx+11]
	cdq
	shl	ebx, 8
	or	ebx, eax
	mov	eax, DWORD PTR _uncompressed_size$1$[ebp]
	or	eax, edx
	shld	eax, ebx, 8
	mov	DWORD PTR _uncompressed_size$1$[ebp], eax
	movzx	eax, BYTE PTR [ecx+10]
	cdq
	shl	ebx, 8
	or	ebx, eax
	mov	eax, DWORD PTR _uncompressed_size$1$[ebp]
	or	eax, edx
	shld	eax, ebx, 8
	mov	DWORD PTR _uncompressed_size$1$[ebp], eax
	movzx	eax, BYTE PTR [ecx+9]
	cdq
	shl	ebx, 8
	or	ebx, eax
	mov	eax, DWORD PTR _uncompressed_size$1$[ebp]
	or	eax, edx
	shld	eax, ebx, 8
	mov	DWORD PTR _uncompressed_size$1$[ebp], eax
	movzx	eax, BYTE PTR [ecx+8]
	cdq
	shl	ebx, 8
	or	ebx, eax
	mov	eax, DWORD PTR _uncompressed_size$1$[ebp]
	or	eax, edx
	shld	eax, ebx, 8
	mov	DWORD PTR _uncompressed_size$1$[ebp], eax
	movzx	eax, BYTE PTR [ecx+7]
	cdq
	shl	ebx, 8
	or	ebx, eax
	mov	eax, DWORD PTR _uncompressed_size$1$[ebp]
	or	eax, edx
	shld	eax, ebx, 8
	mov	DWORD PTR _uncompressed_size$1$[ebp], eax
	movzx	eax, BYTE PTR [ecx+6]
	cdq
	shl	ebx, 8
	or	ebx, eax
	mov	eax, DWORD PTR _uncompressed_size$1$[ebp]
	or	eax, edx
	shld	eax, ebx, 8
	mov	DWORD PTR _uncompressed_size$1$[ebp], eax
	movzx	eax, BYTE PTR [ecx+5]
	mov	ecx, DWORD PTR _uncompressed_size$1$[ebp]
	cdq
	shl	ebx, 8
	or	ecx, edx
	or	ebx, eax

; 344  : 
; 345  :     if (uncompressed_size != UINT64_MAX
; 346  :         && uncompressed_size > (UINT64_C(1) << 38))

	mov	eax, ebx
	and	eax, ecx
	cmp	eax, -1
	je	SHORT $LN191@xz_head
	cmp	ecx, 64					; 00000040H
	ja	SHORT $LN179@xz_head
	jb	SHORT $LN191@xz_head
	test	ebx, ebx
	jne	SHORT $LN179@xz_head
$LN191@xz_head:
	pop	ebx

; 443  :             return 0;
; 444  :     }
; 445  : 
; 446  :     /* look for the xz magic header bytes */
; 447  :     if (is_format_xz(state) || is_format_lzma(state)) {
; 448  :         state->how = LZMA;

	mov	DWORD PTR [edi+72], 3

; 526  :     return 0;

	xor	eax, eax
	mov	DWORD PTR [edi+76], 0
	pop	edi

; 527  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xz_head:

; 398  :             if (state->out != NULL)

	test	eax, eax
	je	SHORT $LN11@xz_head

; 399  :                 xmlFree(state->out);

	push	eax
	call	DWORD PTR _xmlFree
	mov	ecx, DWORD PTR [edi+32]
	add	esp, 4
$LN11@xz_head:

; 400  :             if (state->in != NULL)

	test	ecx, ecx
	je	SHORT $LN12@xz_head

; 401  :                 xmlFree(state->in);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xz_head:

; 527  : }

	mov	eax, DWORD PTR [edi+96]
	test	eax, eax
	je	SHORT $LN96@xz_head
	cmp	DWORD PTR [edi+92], 5
	je	SHORT $LN96@xz_head
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN96@xz_head:
	mov	DWORD PTR [edi+92], 5
	or	eax, -1
	mov	DWORD PTR [edi+96], OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN179@xz_head:

; 449  :         state->direct = 0;
; 450  :         return 0;
; 451  :     }
; 452  : #ifdef LIBXML_ZLIB_ENABLED
; 453  :     /* look for the gzip magic header bytes 31 and 139 */
; 454  :     if (strm->next_in[0] == 31) {

	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx], 31			; 0000001fH
	jne	$LN188@xz_head

; 455  :         strm->avail_in--;

	sub	DWORD PTR [esi+4], 1

; 456  :         strm->next_in++;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi], eax

; 457  :         if (strm->avail_in == 0 && xz_avail(state) == -1)

	jne	SHORT $LN185@xz_head
	push	edi
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	je	$LN189@xz_head
$LN185@xz_head:

; 458  :             return -1;
; 459  :         if (strm->avail_in && strm->next_in[0] == 139) {

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	$LN187@xz_head
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 139			; 0000008bH
	jne	$LN187@xz_head

; 460  :             /* we have a gzip header, woo hoo! */
; 461  :             strm->avail_in--;

	dec	ecx

; 462  :             strm->next_in++;

	inc	eax
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi], eax

; 463  : 
; 464  :             /* skip rest of header */
; 465  :             if (NEXT() != 8) {  /* compression method */

	test	ecx, ecx
	jne	SHORT $LN157@xz_head
	push	edi
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	je	$LN169@xz_head
$LN157@xz_head:
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	$LN169@xz_head
	lea	edx, DWORD PTR [eax-1]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], edx
	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi], eax
	cmp	cl, 8
	jne	$LN169@xz_head

; 469  :             }
; 470  :             flags = NEXT();

	test	edx, edx
	jne	SHORT $LN186@xz_head
	push	edi
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN186@xz_head
	or	ebx, eax
	jmp	SHORT $LN199@xz_head
$LN186@xz_head:
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN39@xz_head
	or	ebx, -1
	jmp	SHORT $LN199@xz_head
$LN39@xz_head:
	dec	eax
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [esi]
	movzx	ebx, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi], eax
$LN199@xz_head:

; 471  :             if (flags & 0xe0) { /* reserved flag bits */

	mov	DWORD PTR _flags$1$[ebp], ebx
	test	bl, 224					; 000000e0H
	je	SHORT $LN26@xz_head

; 472  :                 xz_error(state, LZMA_DATA_ERROR,

	push	OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
	push	9
	push	edi
	call	_xz_error
	add	esp, 12					; 0000000cH

; 473  :                          "unknown header flags set");
; 474  :                 return -1;

	or	eax, -1
	pop	ebx
	pop	edi

; 527  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xz_head:

; 475  :             }
; 476  :             NEXT();             /* modification time */

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN201@xz_head
	push	edi
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN44@xz_head
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN44@xz_head
$LN201@xz_head:
	dec	eax
	inc	DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
$LN44@xz_head:

; 477  :             NEXT();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN203@xz_head
	push	edi
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN48@xz_head
	mov	eax, DWORD PTR [edi+108]
	test	eax, eax
	je	SHORT $LN48@xz_head
$LN203@xz_head:
	dec	eax
	inc	DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
$LN48@xz_head:

; 478  :             NEXT();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN205@xz_head
	push	edi
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN52@xz_head
	mov	eax, DWORD PTR [edi+108]
	test	eax, eax
	je	SHORT $LN52@xz_head
$LN205@xz_head:
	dec	eax
	inc	DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
$LN52@xz_head:

; 479  :             NEXT();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN207@xz_head
	push	edi
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN56@xz_head
	mov	eax, DWORD PTR [edi+108]
	test	eax, eax
	je	SHORT $LN56@xz_head
$LN207@xz_head:
	dec	eax
	inc	DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
$LN56@xz_head:

; 480  :             NEXT();             /* extra flags */

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN209@xz_head
	push	edi
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN60@xz_head
	mov	eax, DWORD PTR [edi+108]
	test	eax, eax
	je	SHORT $LN60@xz_head
$LN209@xz_head:
	dec	eax
	inc	DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
$LN60@xz_head:

; 481  :             NEXT();             /* operating system */

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN62@xz_head
	push	edi
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN64@xz_head
$LN62@xz_head:
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN64@xz_head
	dec	eax
	inc	DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
$LN64@xz_head:

; 482  :             if (flags & 4) {    /* extra field */

	test	bl, 4
	je	$LN173@xz_head

; 483  :                 len = (unsigned) NEXT();

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	jne	SHORT $LN67@xz_head
	push	edi
	call	_xz_avail
	mov	ecx, DWORD PTR [edi+108]
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN159@xz_head
	or	ebx, eax
	jmp	SHORT $LN68@xz_head
$LN159@xz_head:
	test	ecx, ecx
	jne	SHORT $LN67@xz_head
	or	ebx, -1
	jmp	SHORT $LN180@xz_head
$LN67@xz_head:
	mov	eax, DWORD PTR [esi]
	dec	ecx
	mov	DWORD PTR [esi+4], ecx
	movzx	ebx, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi], eax
$LN68@xz_head:

; 484  :                 len += (unsigned) NEXT() << 8;

	test	ecx, ecx
	jne	SHORT $LN160@xz_head
$LN180@xz_head:
	push	edi
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN160@xz_head
	or	ecx, eax
	jmp	SHORT $LN72@xz_head
$LN160@xz_head:
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN71@xz_head
	or	ecx, -1
	jmp	SHORT $LN72@xz_head
$LN71@xz_head:
	dec	eax
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [esi]
	movzx	ecx, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi], eax
$LN72@xz_head:
	shl	ecx, 8
	add	ebx, ecx

; 485  :                 while (len--)

	je	SHORT $LN195@xz_head

; 481  :             NEXT();             /* operating system */

	mov	eax, DWORD PTR [esi+4]
$LL2@xz_head:

; 485  :                 while (len--)

	dec	ebx

; 486  :                     if (NEXT() < 0)

	test	eax, eax
	jne	SHORT $LN181@xz_head
	push	edi
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN195@xz_head
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN195@xz_head
$LN181@xz_head:
	inc	DWORD PTR [esi]
	dec	eax
	mov	DWORD PTR [esi+4], eax
	test	ebx, ebx
	jne	SHORT $LL2@xz_head
$LN195@xz_head:

; 487  :                         break;
; 488  :             }
; 489  :             if (flags & 8)      /* file name */

	mov	ebx, DWORD PTR _flags$1$[ebp]
$LN173@xz_head:
	test	bl, 8
	je	SHORT $LN193@xz_head

; 481  :             NEXT();             /* operating system */

	mov	edx, DWORD PTR [esi+4]
$LL4@xz_head:

; 490  :                 while (NEXT() > 0) ;

	test	edx, edx
	jne	SHORT $LN182@xz_head
	push	edi
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN193@xz_head
	mov	edx, DWORD PTR [esi+4]
	test	edx, edx
	je	SHORT $LN193@xz_head
$LN182@xz_head:
	mov	eax, DWORD PTR [esi]
	dec	edx
	mov	DWORD PTR [esi+4], edx
	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi], eax
	test	cl, cl
	jne	SHORT $LL4@xz_head
$LN193@xz_head:

; 491  :             if (flags & 16)     /* comment */

	test	bl, 16					; 00000010H
	je	SHORT $LN194@xz_head

; 481  :             NEXT();             /* operating system */

	mov	edx, DWORD PTR [esi+4]
$LL6@xz_head:

; 492  :                 while (NEXT() > 0) ;

	test	edx, edx
	jne	SHORT $LN183@xz_head
	push	edi
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN194@xz_head
	mov	edx, DWORD PTR [esi+4]
	test	edx, edx
	je	SHORT $LN194@xz_head
$LN183@xz_head:
	mov	eax, DWORD PTR [esi]
	dec	edx
	mov	DWORD PTR [esi+4], edx
	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi], eax
	test	cl, cl
	jne	SHORT $LL6@xz_head
$LN194@xz_head:

; 493  :             if (flags & 2) {    /* header crc */

	test	bl, 2
	je	SHORT $LN92@xz_head

; 494  :                 NEXT();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN212@xz_head
	push	edi
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN88@xz_head
	mov	eax, DWORD PTR [edi+108]
	test	eax, eax
	je	SHORT $LN88@xz_head
$LN212@xz_head:
	dec	eax
	inc	DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
$LN88@xz_head:

; 495  :                 NEXT();

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN90@xz_head
	push	edi
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN92@xz_head
$LN90@xz_head:
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN92@xz_head
	dec	eax
	inc	DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
$LN92@xz_head:

; 496  :             }
; 497  :             /* an unexpected end of file is not checked for here -- it will be
; 498  :              * noticed on the first request for uncompressed data */
; 499  : 
; 500  :             /* set up for decompression */
; 501  :             inflateReset(&state->zstrm);

	lea	eax, DWORD PTR [edi+224]
	push	eax
	call	_inflateReset@4

; 502  :             state->zstrm.adler = crc32(0L, Z_NULL, 0);

	push	0
	push	0
	push	0
	call	_crc32@12
	pop	ebx
	mov	DWORD PTR [edi+272], eax

; 526  :     return 0;

	xor	eax, eax
	mov	DWORD PTR [edi+72], 2
	mov	DWORD PTR [edi+76], 0
	pop	edi

; 527  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN169@xz_head:

; 466  :                 xz_error(state, LZMA_DATA_ERROR,

	push	OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
	push	9
	push	edi
	call	_xz_error
	add	esp, 12					; 0000000cH
$LN189@xz_head:

; 467  :                          "unknown compression method");
; 468  :                 return -1;

	pop	ebx
	pop	edi
	or	eax, -1

; 527  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN187@xz_head:

; 503  :             state->how = GZIP;
; 504  :             state->direct = 0;
; 505  :             return 0;
; 506  :         } else {
; 507  :             /* not a gzip file -- save first byte (31) and fall to raw i/o */
; 508  :             state->out[0] = 31;

	mov	eax, DWORD PTR [edi+36]
	mov	BYTE PTR [eax], 31			; 0000001fH

; 509  :             state->have = 1;

	mov	DWORD PTR [edi+44], 1
$LN188@xz_head:

; 510  :         }
; 511  :     }
; 512  : #endif
; 513  : 
; 514  :     /* doing raw i/o, save start of raw data for seeking, copy any leftover
; 515  :      * input to output -- this assumes that the output buffer is larger than
; 516  :      * the input buffer, which also assures space for gzungetc() */
; 517  :     state->raw = state->pos;

	mov	eax, DWORD PTR [edi+16]

; 518  :     state->next = state->out;

	mov	ecx, DWORD PTR [edi+36]
	mov	DWORD PTR [edi+64], eax
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [edi+68], eax
	mov	DWORD PTR [edi+40], ecx

; 519  :     if (strm->avail_in) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN32@xz_head

; 520  :         memcpy(state->next + state->have, strm->next_in, strm->avail_in);

	push	eax
	mov	eax, DWORD PTR [edi+44]
	push	DWORD PTR [esi]
	add	eax, ecx
	push	eax
	call	_memcpy

; 521  :         state->have += strm->avail_in;

	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	add	DWORD PTR [edi+44], eax

; 522  :         strm->avail_in = 0;

	mov	DWORD PTR [esi+4], 0
$LN32@xz_head:

; 523  :     }
; 524  :     state->how = COPY;

	mov	DWORD PTR [edi+72], 1

; 525  :     state->direct = 1;

	mov	DWORD PTR [edi+76], 1
$LN198@xz_head:

; 526  :     return 0;

	pop	ebx
	pop	edi
	xor	eax, eax

; 527  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xz_head ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _gz_next4
_TEXT	SEGMENT
_state$ = 8						; size = 4
_ret$ = 12						; size = 4
_gz_next4 PROC						; COMDAT

; 367  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [esi+228], 0
	jne	SHORT $LN25@gz_next4

; 368  :     int ch;
; 369  :     unsigned long val;
; 370  :     z_streamp strm = &(state->zstrm);
; 371  : 
; 372  :     val = NEXTZ();

	push	esi
	call	_xz_avail_zstrm
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN25@gz_next4
	mov	ecx, DWORD PTR [esi+228]
	or	edi, eax
	jmp	SHORT $LN6@gz_next4
$LN25@gz_next4:
	mov	ecx, DWORD PTR [esi+228]
	test	ecx, ecx
	jne	SHORT $LN5@gz_next4
	or	edi, -1
	jmp	SHORT $LN6@gz_next4
$LN5@gz_next4:
	mov	eax, DWORD PTR [esi+224]
	dec	ecx
	mov	DWORD PTR [esi+228], ecx
	movzx	edi, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi+224], eax
$LN6@gz_next4:

; 373  :     val += (unsigned) NEXTZ() << 8;

	test	ecx, ecx
	jne	SHORT $LN26@gz_next4
	push	esi
	call	_xz_avail_zstrm
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN26@gz_next4
	mov	edx, DWORD PTR [esi+228]
	or	ecx, eax
	jmp	SHORT $LN10@gz_next4
$LN26@gz_next4:
	mov	edx, DWORD PTR [esi+228]
	test	edx, edx
	jne	SHORT $LN9@gz_next4
	or	ecx, -1
	jmp	SHORT $LN10@gz_next4
$LN9@gz_next4:
	mov	eax, DWORD PTR [esi+224]
	dec	edx
	mov	DWORD PTR [esi+228], edx
	movzx	ecx, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi+224], eax
$LN10@gz_next4:
	shl	ecx, 8
	add	edi, ecx

; 374  :     val += (unsigned long) NEXTZ() << 16;

	test	edx, edx
	jne	SHORT $LN22@gz_next4
	push	esi
	call	_xz_avail_zstrm
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN22@gz_next4
	mov	edx, DWORD PTR [esi+228]
	or	ecx, eax
	jmp	SHORT $LN14@gz_next4
$LN22@gz_next4:
	mov	edx, DWORD PTR [esi+228]
	test	edx, edx
	jne	SHORT $LN13@gz_next4
	or	ecx, -1
	jmp	SHORT $LN14@gz_next4
$LN13@gz_next4:
	mov	eax, DWORD PTR [esi+224]
	dec	edx
	mov	DWORD PTR [esi+228], edx
	movzx	ecx, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi+224], eax
$LN14@gz_next4:
	shl	ecx, 16					; 00000010H
	add	edi, ecx

; 375  :     ch = NEXTZ();

	test	edx, edx
	jne	SHORT $LN23@gz_next4
	push	esi
	call	_xz_avail_zstrm
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN24@gz_next4
$LN23@gz_next4:
	mov	eax, DWORD PTR [esi+228]
	test	eax, eax
	je	SHORT $LN24@gz_next4
	dec	eax
	mov	DWORD PTR [esi+228], eax
	mov	eax, DWORD PTR [esi+224]
	movzx	ecx, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi+224], eax

; 378  :     val += (unsigned long) ch << 24;
; 379  :     *ret = val;

	mov	eax, DWORD PTR _ret$[ebp]
	shl	ecx, 24					; 00000018H
	add	ecx, edi
	pop	edi
	mov	DWORD PTR [eax], ecx

; 380  :     return 0;

	xor	eax, eax

; 381  : }

	pop	esi
	pop	ebp
	ret	0
$LN24@gz_next4:
	pop	edi

; 376  :     if (ch == -1)
; 377  :         return -1;

	or	eax, -1

; 381  : }

	pop	esi
	pop	ebp
	ret	0
_gz_next4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _is_format_lzma
_TEXT	SEGMENT
_filter$ = -16						; size = 16
_state$ = 8						; size = 4
_is_format_lzma PROC					; COMDAT

; 299  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edi+108], 13			; 0000000dH
	jb	$LN26@is_format_

; 300  :     lzma_stream *strm = &(state->strm);
; 301  : 
; 302  :     lzma_filter filter;
; 303  :     lzma_options_lzma *opt;
; 304  :     uint32_t dict_size;
; 305  :     uint64_t uncompressed_size;
; 306  :     size_t i;
; 307  : 
; 308  :     if (strm->avail_in < 13)
; 309  :         return 0;
; 310  : 
; 311  :     filter.id = LZMA_FILTER_LZMA1;
; 312  :     if (lzma_properties_decode(&filter, NULL, state->in, 5) != LZMA_OK)

	push	5
	push	DWORD PTR [edi+32]
	lea	eax, DWORD PTR _filter$[ebp]
	mov	DWORD PTR _filter$[ebp], 1
	push	0
	push	eax
	mov	DWORD PTR _filter$[ebp+4], 1073741824	; 40000000H
	call	DWORD PTR __imp__lzma_properties_decode
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN26@is_format_

; 313  :         return 0;
; 314  : 
; 315  :     opt = filter.options;
; 316  :     dict_size = opt->dict_size;

	mov	eax, DWORD PTR _filter$[ebp+8]

; 317  :     free(opt); /* we can't use xmlFree on a string returned by zlib */

	push	eax
	mov	esi, DWORD PTR [eax]
	call	DWORD PTR __imp__free
	add	esp, 4

; 318  : 
; 319  :     /* A hack to ditch tons of false positives: We allow only dictionary
; 320  :      * sizes that are 2^n or 2^n + 2^(n-1) or UINT32_MAX. LZMA_Alone
; 321  :      * created only files with 2^n, but accepts any dictionary size.
; 322  :      * If someone complains, this will be reconsidered.
; 323  :      */
; 324  :     if (dict_size != UINT32_MAX) {

	cmp	esi, -1
	je	SHORT $LN8@is_format_

; 325  :         uint32_t d = dict_size - 1;

	lea	ecx, DWORD PTR [esi-1]

; 326  : 
; 327  :         d |= d >> 2;

	mov	eax, ecx
	shr	eax, 2
	or	ecx, eax

; 328  :         d |= d >> 3;

	mov	eax, ecx
	shr	eax, 3
	or	ecx, eax

; 329  :         d |= d >> 4;

	mov	eax, ecx
	shr	eax, 4
	or	ecx, eax

; 330  :         d |= d >> 8;

	mov	eax, ecx
	shr	eax, 8
	or	ecx, eax

; 331  :         d |= d >> 16;

	mov	eax, ecx
	shr	eax, 16					; 00000010H
	or	eax, ecx

; 332  :         ++d;

	inc	eax

; 333  :         if (d != dict_size || dict_size == 0)

	cmp	eax, esi
	jne	$LN26@is_format_
	test	esi, esi
	je	$LN26@is_format_
$LN8@is_format_:

; 334  :             return 0;
; 335  :     }
; 336  : 
; 337  :     /* Another hack to ditch false positives: Assume that if the
; 338  :      * uncompressed size is known, it must be less than 256 GiB.
; 339  :      * Again, if someone complains, this will be reconsidered.
; 340  :      */
; 341  :     uncompressed_size = 0;
; 342  :     for (i = 0; i < 8; ++i)
; 343  :         uncompressed_size |= (uint64_t) (state->in[5 + i]) << (i * 8);

	mov	ecx, DWORD PTR [edi+32]
	movzx	eax, BYTE PTR [ecx+12]
	cdq
	mov	esi, eax
	mov	edi, edx
	movzx	eax, BYTE PTR [ecx+11]
	shld	edi, esi, 8
	cdq
	shl	esi, 8
	or	edi, edx
	or	esi, eax
	movzx	eax, BYTE PTR [ecx+10]
	shld	edi, esi, 8
	cdq
	shl	esi, 8
	or	edi, edx
	or	esi, eax
	movzx	eax, BYTE PTR [ecx+9]
	shld	edi, esi, 8
	cdq
	shl	esi, 8
	or	edi, edx
	or	esi, eax
	movzx	eax, BYTE PTR [ecx+8]
	shld	edi, esi, 8
	cdq
	shl	esi, 8
	or	edi, edx
	or	esi, eax
	movzx	eax, BYTE PTR [ecx+7]
	shld	edi, esi, 8
	cdq
	shl	esi, 8
	or	edi, edx
	or	esi, eax
	movzx	eax, BYTE PTR [ecx+6]
	shld	edi, esi, 8
	cdq
	shl	esi, 8
	or	edi, edx
	or	esi, eax
	movzx	eax, BYTE PTR [ecx+5]
	shld	edi, esi, 8
	cdq
	shl	esi, 8
	or	edi, edx
	or	esi, eax

; 344  : 
; 345  :     if (uncompressed_size != UINT64_MAX
; 346  :         && uncompressed_size > (UINT64_C(1) << 38))

	mov	eax, esi
	and	eax, edi
	cmp	eax, -1
	je	SHORT $LN27@is_format_
	cmp	edi, 64					; 00000040H
	ja	SHORT $LN26@is_format_
	jb	SHORT $LN27@is_format_
	test	esi, esi
	jne	SHORT $LN26@is_format_
$LN27@is_format_:
	pop	edi

; 348  : 
; 349  :     return 1;

	mov	eax, 1

; 350  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@is_format_:
	pop	edi

; 347  :         return 0;

	xor	eax, eax

; 350  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_is_format_lzma ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _is_format_xz
_TEXT	SEGMENT
_state$ = 8						; size = 4
_is_format_xz PROC					; COMDAT

; 291  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+108], 6
	jb	SHORT $LN3@is_format_

; 292  :     lzma_stream *strm = &(state->strm);
; 293  : 
; 294  :     return strm->avail_in >= 6 && memcmp(state->in, "\3757zXZ", 6) == 0;

	mov	eax, DWORD PTR [eax+32]
	cmp	DWORD PTR [eax], 1484404733		; 587a37fdH
	jne	SHORT $LN3@is_format_
	cmp	WORD PTR [eax+4], 90			; 0000005aH
	jne	SHORT $LN3@is_format_
	mov	eax, 1

; 295  : }

	pop	ebp
	ret	0
$LN3@is_format_:

; 292  :     lzma_stream *strm = &(state->strm);
; 293  : 
; 294  :     return strm->avail_in >= 6 && memcmp(state->in, "\3757zXZ", 6) == 0;

	xor	eax, eax

; 295  : }

	pop	ebp
	ret	0
_is_format_xz ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_avail_zstrm
_TEXT	SEGMENT
_tmp$1 = 8						; size = 4
_state$ = 8						; size = 4
_xz_avail_zstrm PROC					; COMDAT

; 278  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _state$[ebp]

; 259  :     if (state->err != LZMA_OK)

	cmp	DWORD PTR [esi+92], 0

; 279  :     int ret;
; 280  :     state->strm.avail_in = state->zstrm.avail_in;

	mov	eax, DWORD PTR [esi+228]
	mov	DWORD PTR [esi+108], eax

; 281  :     state->strm.next_in = state->zstrm.next_in;

	mov	eax, DWORD PTR [esi+224]
	mov	DWORD PTR [esi+104], eax

; 259  :     if (state->err != LZMA_OK)

	je	SHORT $LN4@xz_avail_z
$LN8@xz_avail_z:

; 282  :     ret = xz_avail(state);
; 283  :     state->zstrm.avail_in = (uInt) state->strm.avail_in;

	or	eax, -1
	jmp	SHORT $LN3@xz_avail_z
$LN4@xz_avail_z:

; 261  :     if (state->eof == 0) {

	cmp	DWORD PTR [esi+48], 0
	jne	SHORT $LN5@xz_avail_z

; 262  :         /* avail_in is size_t, which is not necessary sizeof(unsigned) */
; 263  :         unsigned tmp = strm->avail_in;

	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR _tmp$1[ebp], eax

; 264  : 
; 265  :         if (xz_load(state, state->in, state->size, &tmp) == -1) {

	lea	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	push	DWORD PTR [esi+24]
	push	DWORD PTR [esi+32]
	push	esi
	call	_xz_load
	add	esp, 16					; 00000010H
	cmp	eax, -1
	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [esi+108], eax
	je	SHORT $LN8@xz_avail_z

; 266  :             strm->avail_in = tmp;
; 267  :             return -1;
; 268  :         }
; 269  :         strm->avail_in = tmp;
; 270  :         strm->next_in = state->in;

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [esi+104], eax
$LN5@xz_avail_z:

; 271  :     }
; 272  :     return 0;

	xor	eax, eax
$LN3@xz_avail_z:

; 282  :     ret = xz_avail(state);
; 283  :     state->zstrm.avail_in = (uInt) state->strm.avail_in;

	mov	ecx, DWORD PTR [esi+108]
	mov	DWORD PTR [esi+228], ecx

; 284  :     state->zstrm.next_in = (Bytef *) state->strm.next_in;

	mov	ecx, DWORD PTR [esi+104]
	mov	DWORD PTR [esi+224], ecx

; 285  :     return ret;

	pop	esi

; 286  : }

	pop	ebp
	ret	0
_xz_avail_zstrm ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_avail
_TEXT	SEGMENT
_tmp$1 = 8						; size = 4
_state$ = 8						; size = 4
_xz_avail PROC						; COMDAT

; 256  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [esi+92], 0
	je	SHORT $LN2@xz_avail
$LN6@xz_avail:

; 273  : }

	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN2@xz_avail:

; 257  :     lzma_stream *strm = &(state->strm);
; 258  : 
; 259  :     if (state->err != LZMA_OK)
; 260  :         return -1;
; 261  :     if (state->eof == 0) {

	cmp	DWORD PTR [esi+48], 0
	jne	SHORT $LN3@xz_avail

; 262  :         /* avail_in is size_t, which is not necessary sizeof(unsigned) */
; 263  :         unsigned tmp = strm->avail_in;

	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR _tmp$1[ebp], eax

; 264  : 
; 265  :         if (xz_load(state, state->in, state->size, &tmp) == -1) {

	lea	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	push	DWORD PTR [esi+24]
	push	DWORD PTR [esi+32]
	push	esi
	call	_xz_load
	add	esp, 16					; 00000010H
	cmp	eax, -1
	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [esi+108], eax
	je	SHORT $LN6@xz_avail

; 266  :             strm->avail_in = tmp;
; 267  :             return -1;
; 268  :         }
; 269  :         strm->avail_in = tmp;
; 270  :         strm->next_in = state->in;

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [esi+104], eax
$LN3@xz_avail:

; 271  :     }
; 272  :     return 0;

	xor	eax, eax
	pop	esi

; 273  : }

	pop	ebp
	ret	0
_xz_avail ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_load
_TEXT	SEGMENT
_state$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_have$ = 20						; size = 4
_xz_load PROC						; COMDAT

; 235  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _have$[ebp]
	xor	ecx, ecx
	mov	ebx, DWORD PTR _state$[ebp]
	mov	edi, DWORD PTR _len$[ebp]
	mov	DWORD PTR [esi], 0
$LL4@xz_load:

; 236  :     int ret;
; 237  : 
; 238  :     *have = 0;
; 239  :     do {
; 240  :         ret = read(state->fd, buf + *have, len - *have);

	mov	eax, edi
	sub	eax, ecx
	push	eax
	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, ecx
	push	eax
	push	DWORD PTR [ebx+4]
	call	DWORD PTR __imp__read
	add	esp, 12					; 0000000cH

; 241  :         if (ret <= 0)

	test	eax, eax
	jle	SHORT $LN13@xz_load

; 242  :             break;
; 243  :         *have += ret;

	mov	ecx, DWORD PTR [esi]
	add	ecx, eax
	mov	DWORD PTR [esi], ecx

; 244  :     } while (*have < len);

	cmp	ecx, edi
	jb	SHORT $LL4@xz_load

; 245  :     if (ret < 0) {

	test	eax, eax
$LN13@xz_load:
	jns	SHORT $LN6@xz_load

; 246  :         xz_error(state, -1, strerror(errno));

	call	DWORD PTR __imp___errno
	push	DWORD PTR [eax]
	call	DWORD PTR __imp__strerror
	push	eax
	push	-1
	push	ebx
	call	_xz_error
	add	esp, 16					; 00000010H

; 247  :         return -1;

	or	eax, -1
	pop	edi

; 251  :     return 0;
; 252  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN6@xz_load:

; 248  :     }
; 249  :     if (ret == 0)

	test	eax, eax
	jne	SHORT $LN7@xz_load

; 250  :         state->eof = 1;

	mov	DWORD PTR [ebx+48], 1
$LN7@xz_load:
	pop	edi

; 251  :     return 0;
; 252  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xz_load ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_compressed
_TEXT	SEGMENT
_f$ = 8							; size = 4
_xz_compressed PROC					; COMDAT

; 188  : xz_compressed(xzFile f) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _f$[ebp]
	test	eax, eax
	je	SHORT $LN9@xz_compres

; 189  :     xz_statep state;
; 190  : 
; 191  :     if (f == NULL)
; 192  :         return(-1);
; 193  :     state = (xz_statep) f;
; 194  :     if (state->init <= 0)

	cmp	DWORD PTR [eax+100], 0
	jle	SHORT $LN9@xz_compres

; 196  : 
; 197  :     switch (state->how) {

	mov	eax, DWORD PTR [eax+72]
	cmp	eax, 1
	je	SHORT $LN6@xz_compres
	add	eax, -2					; fffffffeH
	mov	ecx, 1
	cmp	ecx, eax
	sbb	eax, eax
	and	eax, -2					; fffffffeH
	inc	eax

; 200  : 	case GZIP:
; 201  : 	case LZMA:
; 202  : 	    return(1);
; 203  :     }
; 204  :     return(-1);
; 205  : }

	pop	ebp
	ret	0
$LN6@xz_compres:

; 198  :         case COPY:
; 199  : 	    return(0);

	xor	eax, eax

; 200  : 	case GZIP:
; 201  : 	case LZMA:
; 202  : 	    return(1);
; 203  :     }
; 204  :     return(-1);
; 205  : }

	pop	ebp
	ret	0
$LN9@xz_compres:

; 195  :         return(-1);

	or	eax, -1

; 200  : 	case GZIP:
; 201  : 	case LZMA:
; 202  : 	    return(1);
; 203  :     }
; 204  :     return(-1);
; 205  : }

	pop	ebp
	ret	0
_xz_compressed ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_open
_TEXT	SEGMENT
_path$ = 8						; size = 4
_fd$ = 12						; size = 4
_mode$ = 16						; size = 4
_xz_open PROC						; COMDAT

; 140  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
	push	312					; 00000138H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xz_open
	pop	esi

; 185  : }

	pop	ebp
	ret	0
$LN2@xz_open:
	push	edi

; 141  :     xz_statep state;
; 142  : 
; 143  :     /* allocate xzFile structure to return */
; 144  :     state = xmlMalloc(sizeof(xz_state));
; 145  :     if (state == NULL)
; 146  :         return NULL;
; 147  :     state->size = 0;            /* no buffers allocated yet */
; 148  :     state->want = BUFSIZ;       /* requested buffer size */
; 149  :     state->msg = NULL;          /* no error message yet */
; 150  :     state->init = 0;            /* initialization of zlib data */
; 151  : 
; 152  :     /* save the path name for error messages */
; 153  :     state->path = xmlMalloc(strlen(path) + 1);

	mov	edi, DWORD PTR _path$[ebp]
	mov	ecx, edi
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 512			; 00000200H
	mov	DWORD PTR [esi+96], 0
	mov	DWORD PTR [esi+100], 0
	lea	edx, DWORD PTR [ecx+1]
	npad	6
$LL23@xz_open:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL23@xz_open
	sub	ecx, edx
	lea	eax, DWORD PTR [ecx+1]
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [esi+8], ecx

; 154  :     if (state->path == NULL) {

	test	ecx, ecx
	jne	SHORT $LN3@xz_open

; 155  :         xmlFree(state);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 156  :         return NULL;

	xor	eax, eax
	pop	edi
	pop	esi

; 185  : }

	pop	ebp
	ret	0
$LN3@xz_open:

; 157  :     }
; 158  :     strcpy(state->path, path);

	mov	edx, edi
$LL7@xz_open:
	mov	al, BYTE PTR [edx]
	lea	edx, DWORD PTR [edx+1]
	mov	BYTE PTR [ecx], al
	lea	ecx, DWORD PTR [ecx+1]
	test	al, al
	jne	SHORT $LL7@xz_open

; 159  : 
; 160  :     /* open the file with the appropriate mode (or just use fd) */
; 161  :     state->fd = fd != -1 ? fd : open(path,

	mov	eax, DWORD PTR _fd$[ebp]
	cmp	eax, -1
	jne	SHORT $LN9@xz_open
	push	438					; 000001b6H
	push	32768					; 00008000H
	push	edi
	call	DWORD PTR __imp__open
	add	esp, 12					; 0000000cH
$LN9@xz_open:
	mov	DWORD PTR [esi+4], eax

; 162  : #ifdef O_LARGEFILE
; 163  :                                      O_LARGEFILE |
; 164  : #endif
; 165  : #ifdef O_BINARY
; 166  :                                      O_BINARY |
; 167  : #endif
; 168  :                                      O_RDONLY, 0666);
; 169  :     if (state->fd == -1) {

	cmp	eax, -1
	jne	SHORT $LN4@xz_open

; 170  :         xmlFree(state->path);

	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlFree

; 171  :         xmlFree(state);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 8

; 172  :         return NULL;

	xor	eax, eax
	pop	edi
	pop	esi

; 185  : }

	pop	ebp
	ret	0
$LN4@xz_open:

; 173  :     }
; 174  : 
; 175  :     /* save the current position for rewinding (only if reading) */
; 176  :     state->start = lseek(state->fd, 0, SEEK_CUR);

	push	1
	push	0
	push	eax
	call	DWORD PTR __imp__lseek
	cdq
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+56], eax

; 177  :     if (state->start == (uint64_t) - 1)

	and	eax, edx
	mov	DWORD PTR [esi+60], edx
	cmp	eax, -1
	jne	SHORT $LN5@xz_open

; 178  :         state->start = 0;

	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+60], 0
$LN5@xz_open:

; 92   :     if (state->msg != NULL) {

	mov	eax, DWORD PTR [esi+96]

; 125  :     state->have = 0;            /* no output data available */

	mov	DWORD PTR [esi+44], 0

; 126  :     state->eof = 0;             /* not at end of file */

	mov	DWORD PTR [esi+48], 0

; 127  :     state->how = LOOK;          /* look for gzip header */

	mov	DWORD PTR [esi+72], 0

; 128  :     state->direct = 1;          /* default for empty file */

	mov	DWORD PTR [esi+76], 1

; 129  :     state->seek = 0;            /* no seek request pending */

	mov	DWORD PTR [esi+88], 0

; 92   :     if (state->msg != NULL) {

	test	eax, eax
	je	SHORT $LN13@xz_open

; 93   :         if (state->err != LZMA_MEM_ERROR)

	cmp	DWORD PTR [esi+92], 5
	je	SHORT $LN14@xz_open

; 94   :             xmlFree(state->msg);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xz_open:

; 95   :         state->msg = NULL;

	mov	DWORD PTR [esi+96], 0
$LN13@xz_open:
	pop	edi

; 96   :     }
; 97   : 
; 98   :     /* set error code, and if no message, then done */
; 99   :     state->err = err;

	mov	DWORD PTR [esi+92], 0

; 179  : 
; 180  :     /* initialize stream */
; 181  :     xz_reset(state);
; 182  : 
; 183  :     /* return stream */
; 184  :     return (xzFile) state;

	mov	eax, esi

; 131  :     state->pos = 0;             /* no uncompressed data yet */

	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 132  :     state->strm.avail_in = 0;   /* no input data yet */

	mov	DWORD PTR [esi+108], 0

; 133  : #ifdef LIBXML_ZLIB_ENABLED
; 134  :     state->zstrm.avail_in = 0;  /* no input data yet */

	mov	DWORD PTR [esi+228], 0
	pop	esi

; 185  : }

	pop	ebp
	ret	0
_xz_open ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_reset
_TEXT	SEGMENT
_state$ = 8						; size = 4
_xz_reset PROC						; COMDAT

; 124  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _state$[ebp]

; 92   :     if (state->msg != NULL) {

	mov	eax, DWORD PTR [esi+96]

; 125  :     state->have = 0;            /* no output data available */

	mov	DWORD PTR [esi+44], 0

; 126  :     state->eof = 0;             /* not at end of file */

	mov	DWORD PTR [esi+48], 0

; 127  :     state->how = LOOK;          /* look for gzip header */

	mov	DWORD PTR [esi+72], 0

; 128  :     state->direct = 1;          /* default for empty file */

	mov	DWORD PTR [esi+76], 1

; 129  :     state->seek = 0;            /* no seek request pending */

	mov	DWORD PTR [esi+88], 0

; 92   :     if (state->msg != NULL) {

	test	eax, eax
	je	SHORT $LN4@xz_reset

; 93   :         if (state->err != LZMA_MEM_ERROR)

	cmp	DWORD PTR [esi+92], 5
	je	SHORT $LN5@xz_reset

; 94   :             xmlFree(state->msg);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xz_reset:

; 95   :         state->msg = NULL;

	mov	DWORD PTR [esi+96], 0
$LN4@xz_reset:

; 96   :     }
; 97   : 
; 98   :     /* set error code, and if no message, then done */
; 99   :     state->err = err;

	mov	DWORD PTR [esi+92], 0

; 130  :     xz_error(state, LZMA_OK, NULL);     /* clear error */
; 131  :     state->pos = 0;             /* no uncompressed data yet */

	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 132  :     state->strm.avail_in = 0;   /* no input data yet */

	mov	DWORD PTR [esi+108], 0

; 133  : #ifdef LIBXML_ZLIB_ENABLED
; 134  :     state->zstrm.avail_in = 0;  /* no input data yet */

	mov	DWORD PTR [esi+228], 0
	pop	esi

; 135  : #endif
; 136  : }

	pop	ebp
	ret	0
_xz_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_error
_TEXT	SEGMENT
_state$ = 8						; size = 4
_err$ = 12						; size = 4
_msg$ = 16						; size = 4
_xz_error PROC						; COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edi+96]
	test	eax, eax
	je	SHORT $LN2@xz_error

; 91   :     /* free previously allocated message and clear */
; 92   :     if (state->msg != NULL) {
; 93   :         if (state->err != LZMA_MEM_ERROR)

	cmp	DWORD PTR [edi+92], 5
	je	SHORT $LN3@xz_error

; 94   :             xmlFree(state->msg);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xz_error:

; 95   :         state->msg = NULL;

	mov	DWORD PTR [edi+96], 0
$LN2@xz_error:

; 96   :     }
; 97   : 
; 98   :     /* set error code, and if no message, then done */
; 99   :     state->err = err;
; 100  :     if (msg == NULL)

	mov	ebx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR _err$[ebp]
	mov	DWORD PTR [edi+92], eax
	test	ebx, ebx
	je	$LN1@xz_error

; 101  :         return;
; 102  : 
; 103  :     /* for an out of memory error, save as static string */
; 104  :     if (err == LZMA_MEM_ERROR) {

	cmp	eax, 5
	jne	SHORT $LN5@xz_error

; 105  :         state->msg = (char *) msg;

	mov	DWORD PTR [edi+96], ebx
	pop	edi

; 119  :     return;
; 120  : }

	pop	ebx
	pop	ebp
	ret	0
$LN5@xz_error:

; 106  :         return;
; 107  :     }
; 108  : 
; 109  :     /* construct error message with path */
; 110  :     if ((state->msg =
; 111  :          xmlMalloc(strlen(state->path) + strlen(msg) + 3)) == NULL) {

	mov	ecx, DWORD PTR [edi+8]
	lea	edx, DWORD PTR [ecx+1]
$LL12@xz_error:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL12@xz_error
	sub	ecx, edx
	mov	edx, ebx
	push	esi
	lea	esi, DWORD PTR [edx+1]
$LL13@xz_error:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL13@xz_error
	sub	edx, esi
	lea	eax, DWORD PTR [ecx+3]
	add	eax, edx
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [edi+96], ecx
	test	ecx, ecx
	jne	SHORT $LN6@xz_error

; 112  :         state->err = LZMA_MEM_ERROR;

	pop	esi
	mov	DWORD PTR [edi+92], 5

; 113  :         state->msg = (char *) "out of memory";

	mov	DWORD PTR [edi+96], OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
	pop	edi

; 119  :     return;
; 120  : }

	pop	ebx
	pop	ebp
	ret	0
$LN6@xz_error:

; 114  :         return;
; 115  :     }
; 116  :     strcpy(state->msg, state->path);

	mov	edx, DWORD PTR [edi+8]
	npad	7
$LL8@xz_error:
	mov	al, BYTE PTR [edx]
	lea	edx, DWORD PTR [edx+1]
	mov	BYTE PTR [ecx], al
	lea	ecx, DWORD PTR [ecx+1]
	test	al, al
	jne	SHORT $LL8@xz_error

; 117  :     strcat(state->msg, ": ");

	mov	ecx, DWORD PTR [edi+96]
	dec	ecx
$LL14@xz_error:
	mov	al, BYTE PTR [ecx+1]
	lea	ecx, DWORD PTR [ecx+1]
	test	al, al
	jne	SHORT $LL14@xz_error
	mov	ax, WORD PTR ??_C@_02LMMGGCAJ@?3?5@

; 118  :     strcat(state->msg, msg);

	mov	esi, ebx
	mov	WORD PTR [ecx], ax
	mov	al, BYTE PTR ??_C@_02LMMGGCAJ@?3?5@+2
	mov	BYTE PTR [ecx+2], al
	npad	1
$LL15@xz_error:
	mov	al, BYTE PTR [ebx]
	inc	ebx
	test	al, al
	jne	SHORT $LL15@xz_error
	mov	edi, DWORD PTR [edi+96]
	sub	ebx, esi
	dec	edi
	npad	3
$LL16@xz_error:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL16@xz_error
	mov	ecx, ebx
	shr	ecx, 2
	rep movsd
	mov	ecx, ebx
	and	ecx, 3
	rep movsb
	pop	esi
$LN1@xz_error:

; 119  :     return;
; 120  : }

	pop	edi
	pop	ebx
	pop	ebp
	ret	0
_xz_error ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT ___libxml2_xzcompressed
_TEXT	SEGMENT
_f$ = 8							; size = 4
___libxml2_xzcompressed PROC				; COMDAT

; 214  : __libxml2_xzcompressed(xzFile f) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 191  :     if (f == NULL)

	mov	eax, DWORD PTR _f$[ebp]
	test	eax, eax
	jne	SHORT $LN6@libxml2_xz
$LN11@libxml2_xz:

; 216  : }

	or	eax, -1
	pop	ebp
	ret	0
$LN6@libxml2_xz:

; 194  :     if (state->init <= 0)

	cmp	DWORD PTR [eax+100], 0
	jle	SHORT $LN11@libxml2_xz

; 195  :         return(-1);
; 196  : 
; 197  :     switch (state->how) {

	mov	eax, DWORD PTR [eax+72]
	cmp	eax, 1
	je	SHORT $LN8@libxml2_xz
	add	eax, -2					; fffffffeH
	mov	ecx, 1
	cmp	ecx, eax
	sbb	eax, eax
	and	eax, -2					; fffffffeH
	inc	eax

; 216  : }

	pop	ebp
	ret	0
$LN8@libxml2_xz:

; 215  :     return xz_compressed(f);

	xor	eax, eax

; 216  : }

	pop	ebp
	ret	0
___libxml2_xzcompressed ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT ___libxml2_xzclose
_TEXT	SEGMENT
_file$ = 8						; size = 4
___libxml2_xzclose PROC					; COMDAT

; 788  : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _file$[ebp]
	test	edi, edi
	jne	SHORT $LN2@libxml2_xz

; 789  :     int ret;
; 790  :     xz_statep state;
; 791  : 
; 792  :     /* get internal structure */
; 793  :     if (file == NULL)
; 794  :         return LZMA_DATA_ERROR;

	lea	eax, DWORD PTR [edi+9]
	pop	edi

; 814  : }

	pop	ebp
	ret	0
$LN2@libxml2_xz:

; 795  :     state = (xz_statep) file;
; 796  : 
; 797  :     /* free memory and close file */
; 798  :     if (state->size) {

	cmp	DWORD PTR [edi+24], 0
	je	SHORT $LN3@libxml2_xz

; 799  :         lzma_end(&(state->strm));

	lea	eax, DWORD PTR [edi+104]
	push	eax
	call	DWORD PTR __imp__lzma_end
	add	esp, 4

; 800  : #ifdef LIBXML_ZLIB_ENABLED
; 801  :         if (state->init == 1)

	cmp	DWORD PTR [edi+100], 1
	jne	SHORT $LN4@libxml2_xz

; 802  :             inflateEnd(&(state->zstrm));

	lea	eax, DWORD PTR [edi+224]
	push	eax
	call	_inflateEnd@4
$LN4@libxml2_xz:

; 803  :         state->init = 0;
; 804  : #endif
; 805  :         xmlFree(state->out);

	push	DWORD PTR [edi+36]
	mov	DWORD PTR [edi+100], 0
	call	DWORD PTR _xmlFree

; 806  :         xmlFree(state->in);

	push	DWORD PTR [edi+32]
	call	DWORD PTR _xmlFree
	add	esp, 8
$LN3@libxml2_xz:

; 807  :     }
; 808  :     xmlFree(state->path);

	push	DWORD PTR [edi+8]
	call	DWORD PTR _xmlFree

; 809  :     if ((state->msg != NULL) && (state->err != LZMA_MEM_ERROR))

	mov	eax, DWORD PTR [edi+96]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@libxml2_xz
	cmp	DWORD PTR [edi+92], 5
	je	SHORT $LN5@libxml2_xz

; 810  :         xmlFree(state->msg);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@libxml2_xz:

; 811  :     ret = close(state->fd);

	push	esi
	push	DWORD PTR [edi+4]
	call	DWORD PTR __imp__close

; 812  :     xmlFree(state);

	push	edi
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 8

; 813  :     return ret ? ret : LZMA_OK;

	mov	eax, esi
	pop	esi
	pop	edi

; 814  : }

	pop	ebp
	ret	0
___libxml2_xzclose ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT ___libxml2_xzread
_TEXT	SEGMENT
_got$1$ = -4						; size = 4
_len$2$ = 8						; size = 4
_n$ = 8							; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
___libxml2_xzread PROC					; COMDAT

; 699  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _file$[ebp]
	test	esi, esi
	je	SHORT $LN44@libxml2_xz

; 700  :     unsigned got, n;
; 701  :     xz_statep state;
; 702  :     lzma_stream *strm;
; 703  : 
; 704  :     /* get internal structure */
; 705  :     if (file == NULL)
; 706  :         return -1;
; 707  :     state = (xz_statep) file;
; 708  :     strm = &(state->strm);
; 709  : 
; 710  :     /* check that we're reading and that there's no error */
; 711  :     if (state->err != LZMA_OK)

	cmp	DWORD PTR [esi+92], 0
	jne	SHORT $LN44@libxml2_xz

; 712  :         return -1;
; 713  : 
; 714  :     /* since an int is returned, make sure len fits in one, otherwise return
; 715  :      * with an error (this avoids the flaw in the interface) */
; 716  :     if ((int) len < 0) {

	mov	ebx, DWORD PTR _len$[ebp]
	test	ebx, ebx
	jns	SHORT $LN51@libxml2_xz

; 717  :         xz_error(state, LZMA_BUF_ERROR,

	push	OFFSET ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@
	push	10					; 0000000aH
	push	esi
	call	_xz_error
	add	esp, 12					; 0000000cH
$LN44@libxml2_xz:

; 781  : 
; 782  :     /* return number of bytes read into user buffer (will fit in int) */
; 783  :     return (int) got;
; 784  : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@libxml2_xz:

; 718  :                  "requested length does not fit in int");
; 719  :         return -1;
; 720  :     }
; 721  : 
; 722  :     /* if len is zero, avoid unnecessary operations */
; 723  :     if (len == 0)

	jne	SHORT $LN8@libxml2_xz

; 781  : 
; 782  :     /* return number of bytes read into user buffer (will fit in int) */
; 783  :     return (int) got;
; 784  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@libxml2_xz:

; 724  :         return 0;
; 725  : 
; 726  :     /* process a skip request */
; 727  :     if (state->seek) {

	cmp	DWORD PTR [esi+88], 0
	je	SHORT $LN10@libxml2_xz

; 729  :         if (xz_skip(state, state->skip) == -1)

	mov	edi, DWORD PTR [esi+80]

; 673  :     while (len)

	mov	eax, edi

; 729  :         if (xz_skip(state, state->skip) == -1)

	mov	edx, DWORD PTR [esi+84]

; 673  :     while (len)

	or	eax, edx

; 728  :         state->seek = 0;

	mov	DWORD PTR [esi+88], 0

; 729  :         if (xz_skip(state, state->skip) == -1)

	mov	DWORD PTR _len$2$[ebp], edx

; 673  :     while (len)

	je	SHORT $LN10@libxml2_xz
$LL27@libxml2_xz:

; 674  :         /* skip over whatever is in output buffer */
; 675  :         if (state->have) {

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN29@libxml2_xz

; 676  :             n = (uint64_t) state->have > len ?

	xor	ecx, ecx
	cmp	ecx, edx
	jb	SHORT $LN35@libxml2_xz
	ja	SHORT $LN50@libxml2_xz
	cmp	eax, edi
	jbe	SHORT $LN35@libxml2_xz
$LN50@libxml2_xz:
	mov	ecx, edi
	jmp	SHORT $LN36@libxml2_xz
$LN35@libxml2_xz:
	mov	ecx, eax
$LN36@libxml2_xz:

; 677  :                 (unsigned) len : state->have;
; 678  :             state->have -= n;
; 679  :             state->next += n;

	add	DWORD PTR [esi+40], ecx
	sub	eax, ecx

; 680  :             state->pos += n;

	add	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+44], eax
	adc	DWORD PTR [esi+20], 0

; 681  :             len -= n;

	sub	edi, ecx
	sbb	edx, 0
	mov	DWORD PTR _len$2$[ebp], edx

; 682  :         }

	jmp	SHORT $LN33@libxml2_xz
$LN29@libxml2_xz:

; 683  : 
; 684  :     /* output buffer empty -- return if we're at the end of the input */
; 685  :         else if (state->eof && state->strm.avail_in == 0)

	cmp	DWORD PTR [esi+48], 0
	je	SHORT $LN31@libxml2_xz
	cmp	DWORD PTR [esi+108], 0
	je	SHORT $LN10@libxml2_xz
$LN31@libxml2_xz:

; 686  :             break;
; 687  : 
; 688  :     /* need more data to skip -- load up output buffer */
; 689  :         else {
; 690  :             /* get more output, looking for header if required */
; 691  :             if (xz_make(state) == -1)

	push	esi
	call	_xz_make
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN44@libxml2_xz
	mov	edx, DWORD PTR _len$2$[ebp]
$LN33@libxml2_xz:

; 673  :     while (len)

	mov	eax, edi
	or	eax, edx
	jne	SHORT $LL27@libxml2_xz
$LN10@libxml2_xz:

; 730  :             return -1;
; 731  :     }
; 732  : 
; 733  :     /* get len bytes to buf, or less than len if at the end */
; 734  :     got = 0;

	xor	ecx, ecx
	mov	DWORD PTR _got$1$[ebp], ecx
$LL4@libxml2_xz:

; 735  :     do {
; 736  :         /* first just try copying data from the output buffer */
; 737  :         if (state->have) {

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN11@libxml2_xz

; 738  :             n = state->have > len ? len : state->have;
; 739  :             memcpy(buf, state->next, n);

	cmp	eax, ebx
	mov	edi, ebx
	cmovbe	edi, eax
	mov	eax, DWORD PTR _buf$[ebp]
	push	edi
	push	DWORD PTR [esi+40]
	mov	DWORD PTR _n$[ebp], edi
	push	eax
	call	_memcpy

; 740  :             state->next += n;

	add	DWORD PTR [esi+40], edi
	add	esp, 12					; 0000000cH

; 741  :             state->have -= n;

	sub	DWORD PTR [esi+44], edi

; 742  :         }

	jmp	SHORT $LN20@libxml2_xz
$LN11@libxml2_xz:

; 743  : 
; 744  :         /* output buffer empty -- return if we're at the end of the input */
; 745  :         else if (state->eof && strm->avail_in == 0)

	cmp	DWORD PTR [esi+48], 0
	je	SHORT $LN13@libxml2_xz
	cmp	DWORD PTR [esi+108], 0
	je	$LN3@libxml2_xz
$LN13@libxml2_xz:

; 746  :             break;
; 747  : 
; 748  :         /* need output data -- for small len or new stream load up our output
; 749  :          * buffer */
; 750  :         else if (state->how == LOOK || len < (state->size << 1)) {

	mov	ecx, DWORD PTR [esi+72]
	test	ecx, ecx
	je	SHORT $LN17@libxml2_xz
	mov	eax, DWORD PTR [esi+24]
	add	eax, eax
	cmp	ebx, eax
	jb	SHORT $LN17@libxml2_xz

; 753  :                 return -1;
; 754  :             continue;           /* no progress yet -- go back to memcpy() above */
; 755  :             /* the copy above assures that we will leave with space in the
; 756  :              * output buffer, allowing at least one gzungetc() to succeed */
; 757  :         }
; 758  : 
; 759  :         /* large len -- read directly into user buffer */
; 760  :         else if (state->how == COPY) {  /* read directly */

	cmp	ecx, 1
	jne	SHORT $LN19@libxml2_xz

; 761  :             if (xz_load(state, buf, len, &n) == -1)

	lea	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	eax, DWORD PTR _buf$[ebp]
	push	ebx
	push	eax
	push	esi
	call	_xz_load
	add	esp, 16					; 00000010H
	cmp	eax, -1
	je	$LN44@libxml2_xz

; 762  :                 return -1;
; 763  :         }

	mov	edi, DWORD PTR _n$[ebp]
	jmp	SHORT $LN20@libxml2_xz
$LN19@libxml2_xz:

; 764  : 
; 765  :         /* large len -- decompress directly into user buffer */
; 766  :         else {                  /* state->how == LZMA */
; 767  :             strm->avail_out = len;
; 768  :             strm->next_out = buf;

	mov	eax, DWORD PTR _buf$[ebp]

; 769  :             if (xz_decomp(state) == -1)

	push	esi
	mov	DWORD PTR [esi+124], ebx
	mov	DWORD PTR [esi+120], eax
	call	_xz_decomp
	add	esp, 4
	cmp	eax, -1
	je	$LN44@libxml2_xz

; 770  :                 return -1;
; 771  :             n = state->have;

	mov	edi, DWORD PTR [esi+44]
	mov	DWORD PTR _n$[ebp], edi

; 772  :             state->have = 0;

	mov	DWORD PTR [esi+44], 0
$LN20@libxml2_xz:

; 773  :         }
; 774  : 
; 775  :         /* update progress */
; 776  :         len -= n;
; 777  :         buf = (char *) buf + n;
; 778  :         got += n;

	mov	ecx, DWORD PTR _got$1$[ebp]
	sub	ebx, edi
	add	DWORD PTR _buf$[ebp], edi
	add	ecx, edi

; 779  :         state->pos += n;

	add	DWORD PTR [esi+16], edi
	mov	DWORD PTR _got$1$[ebp], ecx
	adc	DWORD PTR [esi+20], 0
	jmp	SHORT $LN2@libxml2_xz
$LN17@libxml2_xz:

; 751  :             /* get more output, looking for header if required */
; 752  :             if (xz_make(state) == -1)

	push	esi
	call	_xz_make
	add	esp, 4
	cmp	eax, -1
	je	$LN44@libxml2_xz
	mov	ecx, DWORD PTR _got$1$[ebp]
$LN2@libxml2_xz:

; 780  :     } while (len);

	test	ebx, ebx
	jne	$LL4@libxml2_xz
$LN3@libxml2_xz:
	pop	edi

; 781  : 
; 782  :     /* return number of bytes read into user buffer (will fit in int) */
; 783  :     return (int) got;
; 784  : }

	pop	esi
	mov	eax, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
___libxml2_xzread ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT ___libxml2_xzdopen
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_mode$ = 12						; size = 4
___libxml2_xzdopen PROC					; COMDAT

; 220  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _fd$[ebp]
	cmp	esi, -1
	je	SHORT $LN3@libxml2_xz

; 221  :     char *path;                 /* identifier for error messages */
; 222  :     xzFile xz;
; 223  : 
; 224  :     if (fd == -1 || (path = xmlMalloc(7 + 3 * sizeof(int))) == NULL)

	push	19					; 00000013H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN3@libxml2_xz

; 226  :     sprintf(path, "<fd:%d>", fd);       /* for debugging */

	push	esi
	push	OFFSET ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@
	push	edi
	call	_sprintf

; 227  :     xz = xz_open(path, fd, mode);

	push	DWORD PTR _mode$[ebp]
	push	esi
	push	edi
	call	_xz_open

; 228  :     xmlFree(path);

	push	edi
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 28					; 0000001cH

; 229  :     return xz;

	mov	eax, esi
	pop	edi

; 230  : }

	pop	esi
	pop	ebp
	ret	0
$LN3@libxml2_xz:
	pop	edi

; 225  :         return NULL;

	xor	eax, eax

; 230  : }

	pop	esi
	pop	ebp
	ret	0
___libxml2_xzdopen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT ___libxml2_xzopen
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
___libxml2_xzopen PROC					; COMDAT

; 209  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _mode$[ebp]
	push	-1
	push	DWORD PTR _path$[ebp]
	call	_xz_open
	add	esp, 12					; 0000000cH

; 210  :     return xz_open(path, -1, mode);
; 211  : }

	pop	ebp
	ret	0
___libxml2_xzopen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1390 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	or	ecx, 1
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);
; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);
; 1792 :         return _Result;

	pop	esi

; 1793 :     }

	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1459 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1390 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 1
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1460 :         #pragma warning(push)
; 1461 :         #pragma warning(disable: 4996) // Deprecation
; 1462 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1463 :         #pragma warning(pop)
; 1464 :     }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1389 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __BufferCount$[ebp]
	or	eax, 1
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1390 :         int const _Result = __stdio_common_vsprintf(
; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;
; 1395 :     }

	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
