; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\valid.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__56F63275_valid@c DB 01H
msvcjmc	ENDS
PUBLIC	_xmlAddNotationDecl
PUBLIC	_xmlCopyNotationTable
PUBLIC	_xmlFreeNotationTable
PUBLIC	_xmlDumpNotationDecl
PUBLIC	_xmlDumpNotationTable
PUBLIC	_xmlNewElementContent
PUBLIC	_xmlCopyElementContent
PUBLIC	_xmlFreeElementContent
PUBLIC	_xmlNewDocElementContent
PUBLIC	_xmlCopyDocElementContent
PUBLIC	_xmlFreeDocElementContent
PUBLIC	_xmlSnprintfElementContent
PUBLIC	_xmlSprintfElementContent
PUBLIC	_xmlAddElementDecl
PUBLIC	_xmlCopyElementTable
PUBLIC	_xmlFreeElementTable
PUBLIC	_xmlDumpElementTable
PUBLIC	_xmlDumpElementDecl
PUBLIC	_xmlCreateEnumeration
PUBLIC	_xmlFreeEnumeration
PUBLIC	_xmlCopyEnumeration
PUBLIC	_xmlAddAttributeDecl
PUBLIC	_xmlCopyAttributeTable
PUBLIC	_xmlFreeAttributeTable
PUBLIC	_xmlDumpAttributeTable
PUBLIC	_xmlDumpAttributeDecl
PUBLIC	_xmlAddID
PUBLIC	_xmlFreeIDTable
PUBLIC	_xmlGetID
PUBLIC	_xmlIsID
PUBLIC	_xmlRemoveID
PUBLIC	_xmlAddRef
PUBLIC	_xmlFreeRefTable
PUBLIC	_xmlIsRef
PUBLIC	_xmlRemoveRef
PUBLIC	_xmlGetRefs
PUBLIC	_xmlNewValidCtxt
PUBLIC	_xmlFreeValidCtxt
PUBLIC	_xmlValidateRoot
PUBLIC	_xmlValidateElementDecl
PUBLIC	_xmlValidNormalizeAttributeValue
PUBLIC	_xmlValidCtxtNormalizeAttributeValue
PUBLIC	_xmlValidateAttributeDecl
PUBLIC	_xmlValidateAttributeValue
PUBLIC	_xmlValidateNotationDecl
PUBLIC	_xmlValidateDtd
PUBLIC	_xmlValidateDtdFinal
PUBLIC	_xmlValidateDocument
PUBLIC	_xmlValidateElement
PUBLIC	_xmlValidateOneElement
PUBLIC	_xmlValidateOneAttribute
PUBLIC	_xmlValidateOneNamespace
PUBLIC	_xmlValidateDocumentFinal
PUBLIC	_xmlValidateNotationUse
PUBLIC	_xmlIsMixedElement
PUBLIC	_xmlGetDtdAttrDesc
PUBLIC	_xmlGetDtdQAttrDesc
PUBLIC	_xmlGetDtdNotationDesc
PUBLIC	_xmlGetDtdQElementDesc
PUBLIC	_xmlGetDtdElementDesc
PUBLIC	_xmlValidGetPotentialChildren
PUBLIC	_xmlValidGetValidElements
PUBLIC	_xmlValidateNameValue
PUBLIC	_xmlValidateNamesValue
PUBLIC	_xmlValidateNmtokenValue
PUBLIC	_xmlValidateNmtokensValue
PUBLIC	_xmlValidBuildContentModel
PUBLIC	_xmlValidatePushElement
PUBLIC	_xmlValidatePushCData
PUBLIC	_xmlValidatePopElement
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0O@IMHFIAOC@malloc?5failed@		; `string'
PUBLIC	??_C@_0P@BHJOIPMJ@realloc?5failed@		; `string'
PUBLIC	??_C@_0CN@GEBFHDLO@Failed?5to?5build?5content?5model?5r@ ; `string'
PUBLIC	??_C@_0CL@FIAOIAHN@Found?5NULL?5content?5in?5content?5m@ ; `string'
PUBLIC	??_C@_0CF@IIHAKBAI@Found?5PCDATA?5in?5content?5model?5o@ ; `string'
PUBLIC	??_C@_0BH@INHICIGB@Building?5content?5model@	; `string'
PUBLIC	??_C@_0CE@LMBMADBI@ContentModel?5broken?5for?5element@ ; `string'
PUBLIC	??_C@_0CH@LILACHHH@Cannot?5create?5automata?5for?5elem@ ; `string'
PUBLIC	??_C@_0CM@GHMIMING@Content?5model?5of?5?$CFs?5is?5not?5dete@ ; `string'
PUBLIC	??_C@_0CH@ODCBAOPP@xmlNewElementContent?5?3?5name?5?$DN?$DN?5@ ; `string'
PUBLIC	??_C@_0CH@EHMNFIPD@xmlNewElementContent?5?3?5name?5?$CB?$DN?5@ ; `string'
PUBLIC	??_C@_0DC@GLPLFDD@Internal?3?5ELEMENT?5content?5corru@ ; `string'
PUBLIC	??_C@_01ODHLEDKK@?$CI@				; `string'
PUBLIC	??_C@_07ELDBONKP@?$CDPCDATA@			; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_03NKFKBEPL@?5?0?5@			; `string'
PUBLIC	??_C@_03LGOGDKEL@?5?$HM?5@			; `string'
PUBLIC	??_C@_01PKGAHCOL@?$CJ@				; `string'
PUBLIC	??_C@_01OGPIMHDM@?$DP@				; `string'
PUBLIC	??_C@_01NBENCBCI@?$CK@				; `string'
PUBLIC	??_C@_01MIFGBAGJ@?$CL@				; `string'
PUBLIC	??_C@_04IBCFJNCN@?5?4?4?4@			; `string'
PUBLIC	??_C@_0CO@BLBNCGCL@xmlAddElementDecl?3?5content?5?$CB?$DN?5N@ ; `string'
PUBLIC	??_C@_0CM@DBFKJMHA@xmlAddElementDecl?3?5content?5?$CB?$DN?5N@ ; `string'
PUBLIC	??_C@_0CO@IMMDEKCP@xmlAddElementDecl?3?5content?5?$DN?$DN?5N@ ; `string'
PUBLIC	??_C@_0DA@CFDLEHAD@xmlAddElementDecl?3?5content?5?$DN?$DN?5N@ ; `string'
PUBLIC	??_C@_0CP@HFIOBKAA@Internal?3?5ELEMENT?5decl?5corrupte@ ; `string'
PUBLIC	??_C@_0CL@IICJECDN@xmlAddElementDecl?3?5Table?5creati@ ; `string'
PUBLIC	??_C@_0BM@DLJMKEJ@Redefinition?5of?5element?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0L@EMLMHHFJ@?$DM?$CBELEMENT?5@		; `string'
PUBLIC	??_C@_08HMKELAAG@?5EMPTY?$DO?6@			; `string'
PUBLIC	??_C@_06OMPGEGME@?5ANY?$DO?6@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_02NEKEAGPN@?$DO?6@			; `string'
PUBLIC	??_C@_0DB@NFLGBMMC@Internal?3?5ELEMENT?5struct?5corrup@ ; `string'
PUBLIC	??_C@_0DE@EJGKGKMH@Element?5?$CFs?5has?5too?5many?5ID?5attr@ ; `string'
PUBLIC	??_C@_0DD@NLJCGIHL@Internal?3?5ATTRIBUTE?5struct?5corr@ ; `string'
PUBLIC	??_C@_0CL@IHGCOODJ@Attribute?5?$CFs?5of?5?$CFs?3?5invalid?5def@ ; `string'
PUBLIC	??_C@_0CN@LFDBMMCB@xmlAddAttributeDecl?3?5Table?5crea@ ; `string'
PUBLIC	??_C@_0CN@HJBCFPNE@Attribute?5?$CFs?5of?5element?5?$CFs?3?5alr@ ; `string'
PUBLIC	??_C@_0DD@GEPJIIIF@Element?5?$CFs?5has?5too?5may?5ID?5attri@ ; `string'
PUBLIC	??_C@_05PPEFOGKI@xmlns@				; `string'
PUBLIC	??_C@_0L@NDHICKFH@?$DM?$CBATTLIST?5@		; `string'
PUBLIC	??_C@_06CIOOFICG@?5CDATA@			; `string'
PUBLIC	??_C@_03JFNHLDJD@?5ID@				; `string'
PUBLIC	??_C@_06JJHMNMLB@?5IDREF@			; `string'
PUBLIC	??_C@_07CNGJPBFB@?5IDREFS@			; `string'
PUBLIC	??_C@_07GLIJGNMP@?5ENTITY@			; `string'
PUBLIC	??_C@_09MILPKLMO@?5ENTITIES@			; `string'
PUBLIC	??_C@_08JLMONKHB@?5NMTOKEN@			; `string'
PUBLIC	??_C@_09LGAPIBOH@?5NMTOKENS@			; `string'
PUBLIC	??_C@_02GFKOMOKH@?5?$CI@			; `string'
PUBLIC	??_C@_0M@IGKIMAHJ@?5NOTATION?5?$CI@		; `string'
PUBLIC	??_C@_0L@IEBFJPBC@?5?$CDREQUIRED@		; `string'
PUBLIC	??_C@_09GOIPIIGC@?5?$CDIMPLIED@			; `string'
PUBLIC	??_C@_07PNOBFAOP@?5?$CDFIXED@			; `string'
PUBLIC	??_C@_0DC@EJJFJDDL@Internal?3?5ATTRIBUTE?5struct?5corr@ ; `string'
PUBLIC	??_C@_0CM@PJBPJANJ@xmlAddNotationDecl?3?5Table?5creat@ ; `string'
PUBLIC	??_C@_0CI@HFJJKKEO@xmlAddNotationDecl?3?5?$CFs?5already?5@ ; `string'
PUBLIC	??_C@_0M@IOFINGOM@?$DM?$CBNOTATION?5@		; `string'
PUBLIC	??_C@_08GBBLECIH@?5PUBLIC?5@			; `string'
PUBLIC	??_C@_08PAGGLANP@?5SYSTEM?5@			; `string'
PUBLIC	??_C@_03KKJDKPMN@?5?$DO?6@			; `string'
PUBLIC	??_C@_0CC@HPFDMDEK@xmlAddID?3?5Table?5creation?5failed@ ; `string'
PUBLIC	??_C@_0BH@JKIFIOPN@ID?5?$CFs?5already?5defined?6@ ; `string'
PUBLIC	??_C@_02EGCJHIOB@id@				; `string'
PUBLIC	??_C@_03PJHHNEEI@xml@				; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_01MCMALHOG@a@				; `string'
PUBLIC	??_C@_0CD@JKLLCBGN@xmlAddRef?3?5Table?5creation?5faile@ ; `string'
PUBLIC	??_C@_0CM@EILGCMCJ@xmlAddRef?3?5Reference?5list?5creat@ ; `string'
PUBLIC	??_C@_0CN@CLGHPEIK@xmlAddRef?3?5Reference?5list?5inser@ ; `string'
PUBLIC	??_C@_0CA@OJAJCLMD@element?5table?5allocation?5failed@ ; `string'
PUBLIC	??_C@_0BN@NONOBNKE@NOTATION?5?$CFs?5is?5not?5declared?6@ ; `string'
PUBLIC	??_C@_0DG@NHAJHAEC@ENTITY?5attribute?5?$CFs?5reference?5a@ ; `string'
PUBLIC	??_C@_0DM@CBMBENAH@ENTITY?5attribute?5?$CFs?5reference?5a@ ; `string'
PUBLIC	??_C@_0DI@MOCJGONA@ENTITIES?5attribute?5?$CFs?5reference@ ; `string'
PUBLIC	??_C@_0DO@BNHKOEGN@ENTITIES?5attribute?5?$CFs?5reference@ ; `string'
PUBLIC	??_C@_0DK@HMAANMLE@NOTATION?5attribute?5?$CFs?5reference@ ; `string'
PUBLIC	??_C@_0FG@CJEJIEOP@standalone?3?5?$CFs?5on?5?$CFs?5value?5had?5@ ; `string'
PUBLIC	??_C@_0DN@MJLCEKEK@Syntax?5of?5default?5value?5for?5att@ ; `string'
PUBLIC	??_C@_0EC@DNHDHDCI@ID?5attribute?5?$CFs?5of?5?$CFs?5is?5not?5va@ ; `string'
PUBLIC	??_C@_0EE@MLJMMKCM@Element?5?$CFs?5has?5?$CFd?5ID?5attribute?5@ ; `string'
PUBLIC	??_C@_0EE@JDKHGIAG@Element?5?$CFs?5has?5?$CFd?5ID?5attribute?5@ ; `string'
PUBLIC	??_C@_0EP@CFLHEJLO@Element?5?$CFs?5has?5ID?5attributes?5de@ ; `string'
PUBLIC	??_C@_0EL@MPNELAFE@Default?5value?5?$CC?$CFs?$CC?5for?5attribut@ ; `string'
PUBLIC	??_C@_0DB@DPGOOPFF@Definition?5of?5?$CFs?5has?5duplicate?5@ ; `string'
PUBLIC	??_C@_0DE@IDAOJGBB@Definition?5of?5?$CFs?5has?5duplicate?5@ ; `string'
PUBLIC	??_C@_0DB@HNLIHGKJ@Definition?5of?5?$CFs?5has?5duplicate?5@ ; `string'
PUBLIC	??_C@_0DE@PAODFKFF@Definition?5of?5?$CFs?5has?5duplicate?5@ ; `string'
PUBLIC	??_C@_0CP@IDGJHJLH@No?5declaration?5for?5attribute?5?$CFs@ ; `string'
PUBLIC	??_C@_0DF@PPLCGADM@Syntax?5of?5value?5for?5attribute?5?$CF@ ; `string'
PUBLIC	??_C@_0DN@BPCEOAOB@Value?5for?5attribute?5?$CFs?5of?5?$CFs?5is@ ; `string'
PUBLIC	??_C@_0DO@HAIKKCN@Value?5?$CC?$CFs?$CC?5for?5attribute?5?$CFs?5of?5@ ; `string'
PUBLIC	??_C@_0EJ@LLDEHINL@Value?5?$CC?$CFs?$CC?5for?5attribute?5?$CFs?5of?5@ ; `string'
PUBLIC	??_C@_0ED@GMECILPN@Value?5?$CC?$CFs?$CC?5for?5attribute?5?$CFs?5of?5@ ; `string'
PUBLIC	??_C@_0CL@KKBPHLEC@Value?5for?5attribute?5?$CFs?5of?5?$CFs?5mu@ ; `string'
PUBLIC	??_C@_0BF@INLCBMIM@Validating?5namespace@	; `string'
PUBLIC	??_C@_0DF@GJIDMPBO@No?5declaration?5for?5attribute?5xm@ ; `string'
PUBLIC	??_C@_0DC@FPONLEAN@No?5declaration?5for?5attribute?5xm@ ; `string'
PUBLIC	??_C@_0DL@CBOACJEL@Syntax?5of?5value?5for?5attribute?5x@ ; `string'
PUBLIC	??_C@_0DI@HAHGLIKC@Syntax?5of?5value?5for?5attribute?5x@ ; `string'
PUBLIC	??_C@_0ED@KAGANNGH@Value?5for?5attribute?5xmlns?3?$CFs?5of@ ; `string'
PUBLIC	??_C@_0EA@HGOHDHBG@Value?5for?5attribute?5xmlns?5of?5?$CFs@ ; `string'
PUBLIC	??_C@_0EE@ENPHOLHF@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?3@ ; `string'
PUBLIC	??_C@_0EB@IKNIAELF@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?5@ ; `string'
PUBLIC	??_C@_0EP@PJCDPKEK@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?3@ ; `string'
PUBLIC	??_C@_0EM@LDEIIDJK@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?5@ ; `string'
PUBLIC	??_C@_0EJ@PDIHKDMN@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?3@ ; `string'
PUBLIC	??_C@_0EG@CDCEFKCM@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?5@ ; `string'
PUBLIC	??_C@_0DB@DPJFCMMB@Value?5for?5attribute?5xmlns?3?$CFs?5of@ ; `string'
PUBLIC	??_C@_0CO@DNGFHLPE@Value?5for?5attribute?5xmlns?5of?5?$CFs@ ; `string'
PUBLIC	??_C@_05MLPNBPGH@CDATA@				; `string'
PUBLIC	??_C@_03BBKEAIF@?$DP?$DP?$DP@			; `string'
PUBLIC	??_C@_0EC@IAKGOMPC@Element?5?$CFs?5content?5does?5not?5fol@ ; `string'
PUBLIC	??_C@_0DP@CBELDNAH@Element?5content?5does?5not?5follow@ ; `string'
PUBLIC	??_C@_0CC@LMJFIFCG@Internal?3?5MIXED?5struct?5corrupte@ ; `string'
PUBLIC	??_C@_0BP@CMBGNCIM@No?5declaration?5for?5element?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0DE@KLKCMFPH@Element?5?$CFs?5was?5declared?5EMPTY?5t@ ; `string'
PUBLIC	??_C@_0DN@CFJCCMLK@Element?5?$CFs?5was?5declared?5?$CDPCDATA@ ; `string'
PUBLIC	??_C@_0DM@IPIENEI@Element?5?$CFs?5is?5not?5declared?5in?5?$CF@ ; `string'
PUBLIC	??_C@_0DK@BGIDCAIC@Element?5?$CFs?5content?5does?5not?5fol@ ; `string'
PUBLIC	??_C@_0DO@HNMIGKJO@Element?5?$CFs?5content?5does?5not?5fol@ ; `string'
PUBLIC	??_C@_0EC@JDBIOCJK@Element?5?$CFs?5content?5does?5not?5fol@ ; `string'
PUBLIC	??_C@_0CA@EPFCDFAG@Attribute?5element?5not?5expected?6@ ; `string'
PUBLIC	??_C@_0BN@JALMDBBB@Text?5element?5has?5children?5?$CB?6@ ; `string'
PUBLIC	??_C@_0BO@NIGEHALL@Text?5element?5has?5namespace?5?$CB?6@ ; `string'
PUBLIC	??_C@_0BP@DPPADDEP@Text?5element?5has?5no?5content?5?$CB?6@ ; `string'
PUBLIC	??_C@_0BN@CJFFIPOP@Entity?5element?5not?5expected?6@ ; `string'
PUBLIC	??_C@_0BP@FEDJMKLA@Notation?5element?5not?5expected?6@ ; `string'
PUBLIC	??_C@_0BP@LPODOPI@Document?5element?5not?5expected?6@ ; `string'
PUBLIC	??_C@_0BM@DIBMDMIN@HTML?5Document?5not?5expected?6@ ; `string'
PUBLIC	??_C@_0BG@CJHPKHPI@unknown?5element?5type?6@	; `string'
PUBLIC	??_C@_0EM@LHPMEFBO@standalone?3?5?$CFs?5declared?5in?5the?5@ ; `string'
PUBLIC	??_C@_0CI@KOGIECMM@Element?5?$CFs?5does?5not?5carry?5attri@ ; `string'
PUBLIC	??_C@_0CL@IDAGHCGO@Element?5?$CFs?5does?5not?5carry?5attri@ ; `string'
PUBLIC	??_C@_0DD@KAGCOGBM@Element?5?$CFs?5required?5attribute?5?$CF@ ; `string'
PUBLIC	??_C@_0DK@IGLOKJLK@Element?5?$CFs?5required?5attribute?5?$CF@ ; `string'
PUBLIC	??_C@_0EI@BIBADMEK@Element?5?$CFs?5namespace?5name?5for?5d@ ; `string'
PUBLIC	??_C@_0DJ@DDNBGMLL@Element?5?$CFs?5namespace?5name?5for?5?$CF@ ; `string'
PUBLIC	??_C@_0BB@JNDFICHA@no?5root?5element?6@		; `string'
PUBLIC	??_C@_04DBLPJNAF@HTML@				; `string'
PUBLIC	??_C@_04PNIFHPHN@html@				; `string'
PUBLIC	??_C@_0CO@PMJDAMAF@root?5and?5DTD?5name?5do?5not?5match?5@ ; `string'
PUBLIC	??_C@_0DE@GLBIFDCC@attribute?5?$CFs?5line?5?$CFd?5references@ ; `string'
PUBLIC	??_C@_0DC@HOBCELJH@IDREF?5attribute?5?$CFs?5references?5a@ ; `string'
PUBLIC	??_C@_0N@BBOKCKMC@IDREFS?5split@		; `string'
PUBLIC	??_C@_0DD@JBMPIAIH@IDREFS?5attribute?5?$CFs?5references?5@ ; `string'
PUBLIC	??_C@_0CH@PKJJCFEM@xmlValidateDocumentFinal?3?5doc?5?$DN@ ; `string'
PUBLIC	??_C@_0DC@EEKBOKHB@xmlValidateAttributeCallback?$CI?$CFs@ ; `string'
PUBLIC	??_C@_0DC@CHBKELEG@attribute?5?$CFs?3?5could?5not?5find?5de@ ; `string'
PUBLIC	??_C@_0DF@KBMCJLCB@NOTATION?5attribute?5?$CFs?5declared?5@ ; `string'
PUBLIC	??_C@_0P@GBEHLCJD@no?5DTD?5found?$CB?6@		; `string'
PUBLIC	??_C@_0CO@FGGICOAP@Could?5not?5build?5URI?5for?5externa@ ; `string'
PUBLIC	??_C@_0CJ@BNOHLKCI@Could?5not?5load?5the?5external?5sub@ ; `string'
PUBLIC	??_C@_09LMMMMLKM@?$DM?$CBdummy?$DP?$DO@		; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrncmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlDictOwns:PROC
EXTRN	_xmlRegFreeRegexp:PROC
EXTRN	_xmlRegexpIsDeterminist:PROC
EXTRN	_xmlRegNewExecCtxt:PROC
EXTRN	_xmlRegFreeExecCtxt:PROC
EXTRN	_xmlRegExecPushString:PROC
EXTRN	_xmlBuildQName:PROC
EXTRN	_xmlSplitQName2:PROC
EXTRN	_xmlSplitQName3:PROC
EXTRN	_xmlNewDocNode:PROC
EXTRN	_xmlGetLineNo:PROC
EXTRN	_xmlDocGetRootElement:PROC
EXTRN	_xmlIsBlankNode:PROC
EXTRN	_xmlUnlinkNode:PROC
EXTRN	_xmlFreeNode:PROC
EXTRN	_xmlNodeListGetString:PROC
EXTRN	_xmlBufferWriteCHAR:PROC
EXTRN	_xmlBufferWriteChar:PROC
EXTRN	_xmlBufferWriteQuotedString:PROC
EXTRN	_xmlHashCreateDict:PROC
EXTRN	_xmlHashFree:PROC
EXTRN	_xmlHashAddEntry:PROC
EXTRN	_xmlHashUpdateEntry:PROC
EXTRN	_xmlHashAddEntry2:PROC
EXTRN	_xmlHashAddEntry3:PROC
EXTRN	_xmlHashRemoveEntry:PROC
EXTRN	_xmlHashRemoveEntry2:PROC
EXTRN	_xmlHashLookup:PROC
EXTRN	_xmlHashLookup2:PROC
EXTRN	_xmlHashLookup3:PROC
EXTRN	_xmlHashCopy:PROC
EXTRN	_xmlHashScan:PROC
EXTRN	_xmlHashScan3:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	_xmlListCreate:PROC
EXTRN	_xmlListDelete:PROC
EXTRN	_xmlListAppend:PROC
EXTRN	_xmlListRemoveFirst:PROC
EXTRN	_xmlListEmpty:PROC
EXTRN	_xmlListWalk:PROC
EXTRN	_xmlLinkGetData:PROC
EXTRN	_xmlNewAutomata:PROC
EXTRN	_xmlFreeAutomata:PROC
EXTRN	_xmlAutomataGetInitState:PROC
EXTRN	_xmlAutomataSetFinalState:PROC
EXTRN	_xmlAutomataNewState:PROC
EXTRN	_xmlAutomataNewTransition:PROC
EXTRN	_xmlAutomataNewEpsilon:PROC
EXTRN	_xmlAutomataCompile:PROC
EXTRN	_xmlGetDocEntity:PROC
EXTRN	_xmlParseDTD:PROC
EXTRN	_xmlBuildURI:PROC
EXTRN	_xmlCharInRange:PROC
EXTRN	_xmlStringCurrentChar:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_09LMMMMLKM@?$DM?$CBdummy?$DP?$DO@
CONST	SEGMENT
??_C@_09LMMMMLKM@?$DM?$CBdummy?$DP?$DO@ DB '<!dummy?>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BNOHLKCI@Could?5not?5load?5the?5external?5sub@
CONST	SEGMENT
??_C@_0CJ@BNOHLKCI@Could?5not?5load?5the?5external?5sub@ DB 'Could not lo'
	DB	'ad the external subset "%s"', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FGGICOAP@Could?5not?5build?5URI?5for?5externa@
CONST	SEGMENT
??_C@_0CO@FGGICOAP@Could?5not?5build?5URI?5for?5externa@ DB 'Could not bu'
	DB	'ild URI for external subset "%s"', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GBEHLCJD@no?5DTD?5found?$CB?6@
CONST	SEGMENT
??_C@_0P@GBEHLCJD@no?5DTD?5found?$CB?6@ DB 'no DTD found!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@KBMCJLCB@NOTATION?5attribute?5?$CFs?5declared?5@
CONST	SEGMENT
??_C@_0DF@KBMCJLCB@NOTATION?5attribute?5?$CFs?5declared?5@ DB 'NOTATION a'
	DB	'ttribute %s declared for EMPTY element %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@CHBKELEG@attribute?5?$CFs?3?5could?5not?5find?5de@
CONST	SEGMENT
??_C@_0DC@CHBKELEG@attribute?5?$CFs?3?5could?5not?5find?5de@ DB 'attribut'
	DB	'e %s: could not find decl for element %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@EEKBOKHB@xmlValidateAttributeCallback?$CI?$CFs@
CONST	SEGMENT
??_C@_0DC@EEKBOKHB@xmlValidateAttributeCallback?$CI?$CFs@ DB 'xmlValidate'
	DB	'AttributeCallback(%s): internal error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PKJJCFEM@xmlValidateDocumentFinal?3?5doc?5?$DN@
CONST	SEGMENT
??_C@_0CH@PKJJCFEM@xmlValidateDocumentFinal?3?5doc?5?$DN@ DB 'xmlValidate'
	DB	'DocumentFinal: doc == NULL', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JBMPIAIH@IDREFS?5attribute?5?$CFs?5references?5@
CONST	SEGMENT
??_C@_0DD@JBMPIAIH@IDREFS?5attribute?5?$CFs?5references?5@ DB 'IDREFS att'
	DB	'ribute %s references an unknown ID "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BBOKCKMC@IDREFS?5split@
CONST	SEGMENT
??_C@_0N@BBOKCKMC@IDREFS?5split@ DB 'IDREFS split', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HOBCELJH@IDREF?5attribute?5?$CFs?5references?5a@
CONST	SEGMENT
??_C@_0DC@HOBCELJH@IDREF?5attribute?5?$CFs?5references?5a@ DB 'IDREF attr'
	DB	'ibute %s references an unknown ID "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@GLBIFDCC@attribute?5?$CFs?5line?5?$CFd?5references@
CONST	SEGMENT
??_C@_0DE@GLBIFDCC@attribute?5?$CFs?5line?5?$CFd?5references@ DB 'attribu'
	DB	'te %s line %d references an unknown ID "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PMJDAMAF@root?5and?5DTD?5name?5do?5not?5match?5@
CONST	SEGMENT
??_C@_0CO@PMJDAMAF@root?5and?5DTD?5name?5do?5not?5match?5@ DB 'root and D'
	DB	'TD name do not match ''%s'' and ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNIFHPHN@html@
CONST	SEGMENT
??_C@_04PNIFHPHN@html@ DB 'html', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DBLPJNAF@HTML@
CONST	SEGMENT
??_C@_04DBLPJNAF@HTML@ DB 'HTML', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JNDFICHA@no?5root?5element?6@
CONST	SEGMENT
??_C@_0BB@JNDFICHA@no?5root?5element?6@ DB 'no root element', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@DDNBGMLL@Element?5?$CFs?5namespace?5name?5for?5?$CF@
CONST	SEGMENT
??_C@_0DJ@DDNBGMLL@Element?5?$CFs?5namespace?5name?5for?5?$CF@ DB 'Elemen'
	DB	't %s namespace name for %s does not match the DTD', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@BIBADMEK@Element?5?$CFs?5namespace?5name?5for?5d@
CONST	SEGMENT
??_C@_0EI@BIBADMEK@Element?5?$CFs?5namespace?5name?5for?5d@ DB 'Element %'
	DB	's namespace name for default namespace does not match the DTD'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@IGLOKJLK@Element?5?$CFs?5required?5attribute?5?$CF@
CONST	SEGMENT
??_C@_0DK@IGLOKJLK@Element?5?$CFs?5required?5attribute?5?$CF@ DB 'Element'
	DB	' %s required attribute %s:%s has different prefix', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@KAGCOGBM@Element?5?$CFs?5required?5attribute?5?$CF@
CONST	SEGMENT
??_C@_0DD@KAGCOGBM@Element?5?$CFs?5required?5attribute?5?$CF@ DB 'Element'
	DB	' %s required attribute %s:%s has no prefix', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IDAGHCGO@Element?5?$CFs?5does?5not?5carry?5attri@
CONST	SEGMENT
??_C@_0CL@IDAGHCGO@Element?5?$CFs?5does?5not?5carry?5attri@ DB 'Element %'
	DB	's does not carry attribute %s:%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KOGIECMM@Element?5?$CFs?5does?5not?5carry?5attri@
CONST	SEGMENT
??_C@_0CI@KOGIECMM@Element?5?$CFs?5does?5not?5carry?5attri@ DB 'Element %'
	DB	's does not carry attribute %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@LHPMEFBO@standalone?3?5?$CFs?5declared?5in?5the?5@
CONST	SEGMENT
??_C@_0EM@LHPMEFBO@standalone?3?5?$CFs?5declared?5in?5the?5@ DB 'standalo'
	DB	'ne: %s declared in the external subset contains white spaces '
	DB	'nodes', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CJHPKHPI@unknown?5element?5type?6@
CONST	SEGMENT
??_C@_0BG@CJHPKHPI@unknown?5element?5type?6@ DB 'unknown element type', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DIBMDMIN@HTML?5Document?5not?5expected?6@
CONST	SEGMENT
??_C@_0BM@DIBMDMIN@HTML?5Document?5not?5expected?6@ DB 'HTML Document not'
	DB	' expected', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LPODOPI@Document?5element?5not?5expected?6@
CONST	SEGMENT
??_C@_0BP@LPODOPI@Document?5element?5not?5expected?6@ DB 'Document elemen'
	DB	't not expected', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FEDJMKLA@Notation?5element?5not?5expected?6@
CONST	SEGMENT
??_C@_0BP@FEDJMKLA@Notation?5element?5not?5expected?6@ DB 'Notation eleme'
	DB	'nt not expected', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CJFFIPOP@Entity?5element?5not?5expected?6@
CONST	SEGMENT
??_C@_0BN@CJFFIPOP@Entity?5element?5not?5expected?6@ DB 'Entity element n'
	DB	'ot expected', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DPPADDEP@Text?5element?5has?5no?5content?5?$CB?6@
CONST	SEGMENT
??_C@_0BP@DPPADDEP@Text?5element?5has?5no?5content?5?$CB?6@ DB 'Text elem'
	DB	'ent has no content !', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NIGEHALL@Text?5element?5has?5namespace?5?$CB?6@
CONST	SEGMENT
??_C@_0BO@NIGEHALL@Text?5element?5has?5namespace?5?$CB?6@ DB 'Text elemen'
	DB	't has namespace !', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JALMDBBB@Text?5element?5has?5children?5?$CB?6@
CONST	SEGMENT
??_C@_0BN@JALMDBBB@Text?5element?5has?5children?5?$CB?6@ DB 'Text element'
	DB	' has children !', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EPFCDFAG@Attribute?5element?5not?5expected?6@
CONST	SEGMENT
??_C@_0CA@EPFCDFAG@Attribute?5element?5not?5expected?6@ DB 'Attribute ele'
	DB	'ment not expected', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@JDBIOCJK@Element?5?$CFs?5content?5does?5not?5fol@
CONST	SEGMENT
??_C@_0EC@JDBIOCJK@Element?5?$CFs?5content?5does?5not?5fol@ DB 'Element %'
	DB	's content does not follow the DTD, Expecting more child', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@HNMIGKJO@Element?5?$CFs?5content?5does?5not?5fol@
CONST	SEGMENT
??_C@_0DO@HNMIGKJO@Element?5?$CFs?5content?5does?5not?5fol@ DB 'Element %'
	DB	's content does not follow the DTD, Text not allowed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@BGIDCAIC@Element?5?$CFs?5content?5does?5not?5fol@
CONST	SEGMENT
??_C@_0DK@BGIDCAIC@Element?5?$CFs?5content?5does?5not?5fol@ DB 'Element %'
	DB	's content does not follow the DTD, Misplaced %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@IPIENEI@Element?5?$CFs?5is?5not?5declared?5in?5?$CF@
CONST	SEGMENT
??_C@_0DM@IPIENEI@Element?5?$CFs?5is?5not?5declared?5in?5?$CF@ DB 'Elemen'
	DB	't %s is not declared in %s list of possible children', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@CFJCCMLK@Element?5?$CFs?5was?5declared?5?$CDPCDATA@
CONST	SEGMENT
??_C@_0DN@CFJCCMLK@Element?5?$CFs?5was?5declared?5?$CDPCDATA@ DB 'Element'
	DB	' %s was declared #PCDATA but contains non text nodes', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@KLKCMFPH@Element?5?$CFs?5was?5declared?5EMPTY?5t@
CONST	SEGMENT
??_C@_0DE@KLKCMFPH@Element?5?$CFs?5was?5declared?5EMPTY?5t@ DB 'Element %'
	DB	's was declared EMPTY this one has content', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CMBGNCIM@No?5declaration?5for?5element?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@CMBGNCIM@No?5declaration?5for?5element?5?$CFs?6@ DB 'No declara'
	DB	'tion for element %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LMJFIFCG@Internal?3?5MIXED?5struct?5corrupte@
CONST	SEGMENT
??_C@_0CC@LMJFIFCG@Internal?3?5MIXED?5struct?5corrupte@ DB 'Internal: MIX'
	DB	'ED struct corrupted', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@CBELDNAH@Element?5content?5does?5not?5follow@
CONST	SEGMENT
??_C@_0DP@CBELDNAH@Element?5content?5does?5not?5follow@ DB 'Element conte'
	DB	'nt does not follow the DTD, expecting %s, got %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@IAKGOMPC@Element?5?$CFs?5content?5does?5not?5fol@
CONST	SEGMENT
??_C@_0EC@IAKGOMPC@Element?5?$CFs?5content?5does?5not?5fol@ DB 'Element %'
	DB	's content does not follow the DTD, expecting %s, got %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03BBKEAIF@?$DP?$DP?$DP@
CONST	SEGMENT
??_C@_03BBKEAIF@?$DP?$DP?$DP@ DB '???', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MLPNBPGH@CDATA@
CONST	SEGMENT
??_C@_05MLPNBPGH@CDATA@ DB 'CDATA', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@DNGFHLPE@Value?5for?5attribute?5xmlns?5of?5?$CFs@
CONST	SEGMENT
??_C@_0CO@DNGFHLPE@Value?5for?5attribute?5xmlns?5of?5?$CFs@ DB 'Value for'
	DB	' attribute xmlns of %s must be "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@DPJFCMMB@Value?5for?5attribute?5xmlns?3?$CFs?5of@
CONST	SEGMENT
??_C@_0DB@DPJFCMMB@Value?5for?5attribute?5xmlns?3?$CFs?5of@ DB 'Value for'
	DB	' attribute xmlns:%s of %s must be "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@CDCEFKCM@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?5@
CONST	SEGMENT
??_C@_0EG@CDCEFKCM@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?5@ DB 'Val'
	DB	'ue "%s" for attribute xmlns of %s is not among the enumerated'
	DB	' set', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@PDIHKDMN@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?3@
CONST	SEGMENT
??_C@_0EJ@PDIHKDMN@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?3@ DB 'Val'
	DB	'ue "%s" for attribute xmlns:%s of %s is not among the enumera'
	DB	'ted set', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@LDEIIDJK@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?5@
CONST	SEGMENT
??_C@_0EM@LDEIIDJK@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?5@ DB 'Val'
	DB	'ue "%s" for attribute xmlns of %s is not among the enumerated'
	DB	' notations', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@PJCDPKEK@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?3@
CONST	SEGMENT
??_C@_0EP@PJCDPKEK@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?3@ DB 'Val'
	DB	'ue "%s" for attribute xmlns:%s of %s is not among the enumera'
	DB	'ted notations', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@IKNIAELF@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?5@
CONST	SEGMENT
??_C@_0EB@IKNIAELF@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?5@ DB 'Val'
	DB	'ue "%s" for attribute xmlns of %s is not a declared Notation', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@ENPHOLHF@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?3@
CONST	SEGMENT
??_C@_0EE@ENPHOLHF@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?3@ DB 'Val'
	DB	'ue "%s" for attribute xmlns:%s of %s is not a declared Notati'
	DB	'on', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@HGOHDHBG@Value?5for?5attribute?5xmlns?5of?5?$CFs@
CONST	SEGMENT
??_C@_0EA@HGOHDHBG@Value?5for?5attribute?5xmlns?5of?5?$CFs@ DB 'Value for'
	DB	' attribute xmlns of %s is different from default "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@KAGANNGH@Value?5for?5attribute?5xmlns?3?$CFs?5of@
CONST	SEGMENT
??_C@_0ED@KAGANNGH@Value?5for?5attribute?5xmlns?3?$CFs?5of@ DB 'Value for'
	DB	' attribute xmlns:%s of %s is different from default "%s"', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@HAHGLIKC@Syntax?5of?5value?5for?5attribute?5x@
CONST	SEGMENT
??_C@_0DI@HAHGLIKC@Syntax?5of?5value?5for?5attribute?5x@ DB 'Syntax of va'
	DB	'lue for attribute xmlns of %s is not valid', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@CBOACJEL@Syntax?5of?5value?5for?5attribute?5x@
CONST	SEGMENT
??_C@_0DL@CBOACJEL@Syntax?5of?5value?5for?5attribute?5x@ DB 'Syntax of va'
	DB	'lue for attribute xmlns:%s of %s is not valid', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@FPONLEAN@No?5declaration?5for?5attribute?5xm@
CONST	SEGMENT
??_C@_0DC@FPONLEAN@No?5declaration?5for?5attribute?5xm@ DB 'No declaratio'
	DB	'n for attribute xmlns of element %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GJIDMPBO@No?5declaration?5for?5attribute?5xm@
CONST	SEGMENT
??_C@_0DF@GJIDMPBO@No?5declaration?5for?5attribute?5xm@ DB 'No declaratio'
	DB	'n for attribute xmlns:%s of element %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@INLCBMIM@Validating?5namespace@
CONST	SEGMENT
??_C@_0BF@INLCBMIM@Validating?5namespace@ DB 'Validating namespace', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KKBPHLEC@Value?5for?5attribute?5?$CFs?5of?5?$CFs?5mu@
CONST	SEGMENT
??_C@_0CL@KKBPHLEC@Value?5for?5attribute?5?$CFs?5of?5?$CFs?5mu@ DB 'Value'
	DB	' for attribute %s of %s must be "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@GMECILPN@Value?5?$CC?$CFs?$CC?5for?5attribute?5?$CFs?5of?5@
CONST	SEGMENT
??_C@_0ED@GMECILPN@Value?5?$CC?$CFs?$CC?5for?5attribute?5?$CFs?5of?5@ DB 'V'
	DB	'alue "%s" for attribute %s of %s is not among the enumerated '
	DB	'set', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@LLDEHINL@Value?5?$CC?$CFs?$CC?5for?5attribute?5?$CFs?5of?5@
CONST	SEGMENT
??_C@_0EJ@LLDEHINL@Value?5?$CC?$CFs?$CC?5for?5attribute?5?$CFs?5of?5@ DB 'V'
	DB	'alue "%s" for attribute %s of %s is not among the enumerated '
	DB	'notations', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@HAIKKCN@Value?5?$CC?$CFs?$CC?5for?5attribute?5?$CFs?5of?5@
CONST	SEGMENT
??_C@_0DO@HAIKKCN@Value?5?$CC?$CFs?$CC?5for?5attribute?5?$CFs?5of?5@ DB 'V'
	DB	'alue "%s" for attribute %s of %s is not a declared Notation', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@BPCEOAOB@Value?5for?5attribute?5?$CFs?5of?5?$CFs?5is@
CONST	SEGMENT
??_C@_0DN@BPCEOAOB@Value?5for?5attribute?5?$CFs?5of?5?$CFs?5is@ DB 'Value'
	DB	' for attribute %s of %s is different from default "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PPLCGADM@Syntax?5of?5value?5for?5attribute?5?$CF@
CONST	SEGMENT
??_C@_0DF@PPLCGADM@Syntax?5of?5value?5for?5attribute?5?$CF@ DB 'Syntax of'
	DB	' value for attribute %s of %s is not valid', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@IDGJHJLH@No?5declaration?5for?5attribute?5?$CFs@
CONST	SEGMENT
??_C@_0CP@IDGJHJLH@No?5declaration?5for?5attribute?5?$CFs@ DB 'No declara'
	DB	'tion for attribute %s of element %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PAODFKFF@Definition?5of?5?$CFs?5has?5duplicate?5@
CONST	SEGMENT
??_C@_0DE@PAODFKFF@Definition?5of?5?$CFs?5has?5duplicate?5@ DB 'Definitio'
	DB	'n of %s has duplicate references to %s:%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HNLIHGKJ@Definition?5of?5?$CFs?5has?5duplicate?5@
CONST	SEGMENT
??_C@_0DB@HNLIHGKJ@Definition?5of?5?$CFs?5has?5duplicate?5@ DB 'Definitio'
	DB	'n of %s has duplicate references to %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@IDAOJGBB@Definition?5of?5?$CFs?5has?5duplicate?5@
CONST	SEGMENT
??_C@_0DE@IDAOJGBB@Definition?5of?5?$CFs?5has?5duplicate?5@ DB 'Definitio'
	DB	'n of %s has duplicate references of %s:%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@DPGOOPFF@Definition?5of?5?$CFs?5has?5duplicate?5@
CONST	SEGMENT
??_C@_0DB@DPGOOPFF@Definition?5of?5?$CFs?5has?5duplicate?5@ DB 'Definitio'
	DB	'n of %s has duplicate references of %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@MPNELAFE@Default?5value?5?$CC?$CFs?$CC?5for?5attribut@
CONST	SEGMENT
??_C@_0EL@MPNELAFE@Default?5value?5?$CC?$CFs?$CC?5for?5attribut@ DB 'Defa'
	DB	'ult value "%s" for attribute %s of %s is not among the enumer'
	DB	'ated set', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@CFLHEJLO@Element?5?$CFs?5has?5ID?5attributes?5de@
CONST	SEGMENT
??_C@_0EP@CFLHEJLO@Element?5?$CFs?5has?5ID?5attributes?5de@ DB 'Element %'
	DB	's has ID attributes defined in the internal and external subs'
	DB	'et : %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@JDKHGIAG@Element?5?$CFs?5has?5?$CFd?5ID?5attribute?5@
CONST	SEGMENT
??_C@_0EE@JDKHGIAG@Element?5?$CFs?5has?5?$CFd?5ID?5attribute?5@ DB 'Eleme'
	DB	'nt %s has %d ID attribute defined in the external subset : %s'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@MLJMMKCM@Element?5?$CFs?5has?5?$CFd?5ID?5attribute?5@
CONST	SEGMENT
??_C@_0EE@MLJMMKCM@Element?5?$CFs?5has?5?$CFd?5ID?5attribute?5@ DB 'Eleme'
	DB	'nt %s has %d ID attribute defined in the internal subset : %s'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@DNHDHDCI@ID?5attribute?5?$CFs?5of?5?$CFs?5is?5not?5va@
CONST	SEGMENT
??_C@_0EC@DNHDHDCI@ID?5attribute?5?$CFs?5of?5?$CFs?5is?5not?5va@ DB 'ID a'
	DB	'ttribute %s of %s is not valid must be #IMPLIED or #REQUIRED', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@MJLCEKEK@Syntax?5of?5default?5value?5for?5att@
CONST	SEGMENT
??_C@_0DN@MJLCEKEK@Syntax?5of?5default?5value?5for?5att@ DB 'Syntax of de'
	DB	'fault value for attribute %s of %s is not valid', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@CJEJIEOP@standalone?3?5?$CFs?5on?5?$CFs?5value?5had?5@
CONST	SEGMENT
??_C@_0FG@CJEJIEOP@standalone?3?5?$CFs?5on?5?$CFs?5value?5had?5@ DB 'stan'
	DB	'dalone: %s on %s value had to be normalized based on external'
	DB	' subset declaration', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HMAANMLE@NOTATION?5attribute?5?$CFs?5reference@
CONST	SEGMENT
??_C@_0DK@HMAANMLE@NOTATION?5attribute?5?$CFs?5reference@ DB 'NOTATION at'
	DB	'tribute %s reference an unknown notation "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@BNHKOEGN@ENTITIES?5attribute?5?$CFs?5reference@
CONST	SEGMENT
??_C@_0DO@BNHKOEGN@ENTITIES?5attribute?5?$CFs?5reference@ DB 'ENTITIES at'
	DB	'tribute %s reference an entity "%s" of wrong type', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@MOCJGONA@ENTITIES?5attribute?5?$CFs?5reference@
CONST	SEGMENT
??_C@_0DI@MOCJGONA@ENTITIES?5attribute?5?$CFs?5reference@ DB 'ENTITIES at'
	DB	'tribute %s reference an unknown entity "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@CBMBENAH@ENTITY?5attribute?5?$CFs?5reference?5a@
CONST	SEGMENT
??_C@_0DM@CBMBENAH@ENTITY?5attribute?5?$CFs?5reference?5a@ DB 'ENTITY att'
	DB	'ribute %s reference an entity "%s" of wrong type', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@NHAJHAEC@ENTITY?5attribute?5?$CFs?5reference?5a@
CONST	SEGMENT
??_C@_0DG@NHAJHAEC@ENTITY?5attribute?5?$CFs?5reference?5a@ DB 'ENTITY att'
	DB	'ribute %s reference an unknown entity "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NONOBNKE@NOTATION?5?$CFs?5is?5not?5declared?6@
CONST	SEGMENT
??_C@_0BN@NONOBNKE@NOTATION?5?$CFs?5is?5not?5declared?6@ DB 'NOTATION %s '
	DB	'is not declared', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OJAJCLMD@element?5table?5allocation?5failed@
CONST	SEGMENT
??_C@_0CA@OJAJCLMD@element?5table?5allocation?5failed@ DB 'element table '
	DB	'allocation failed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CLGHPEIK@xmlAddRef?3?5Reference?5list?5inser@
CONST	SEGMENT
??_C@_0CN@CLGHPEIK@xmlAddRef?3?5Reference?5list?5inser@ DB 'xmlAddRef: Re'
	DB	'ference list insertion failed!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@EILGCMCJ@xmlAddRef?3?5Reference?5list?5creat@
CONST	SEGMENT
??_C@_0CM@EILGCMCJ@xmlAddRef?3?5Reference?5list?5creat@ DB 'xmlAddRef: Re'
	DB	'ference list creation failed!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JKLLCBGN@xmlAddRef?3?5Table?5creation?5faile@
CONST	SEGMENT
??_C@_0CD@JKLLCBGN@xmlAddRef?3?5Table?5creation?5faile@ DB 'xmlAddRef: Ta'
	DB	'ble creation failed!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a@
CONST	SEGMENT
??_C@_01MCMALHOG@a@ DB 'a', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJHHNEEI@xml@
CONST	SEGMENT
??_C@_03PJHHNEEI@xml@ DB 'xml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGCJHIOB@id@
CONST	SEGMENT
??_C@_02EGCJHIOB@id@ DB 'id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JKIFIOPN@ID?5?$CFs?5already?5defined?6@
CONST	SEGMENT
??_C@_0BH@JKIFIOPN@ID?5?$CFs?5already?5defined?6@ DB 'ID %s already defin'
	DB	'ed', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HPFDMDEK@xmlAddID?3?5Table?5creation?5failed@
CONST	SEGMENT
??_C@_0CC@HPFDMDEK@xmlAddID?3?5Table?5creation?5failed@ DB 'xmlAddID: Tab'
	DB	'le creation failed!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KKJDKPMN@?5?$DO?6@
CONST	SEGMENT
??_C@_03KKJDKPMN@?5?$DO?6@ DB ' >', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PAGGLANP@?5SYSTEM?5@
CONST	SEGMENT
??_C@_08PAGGLANP@?5SYSTEM?5@ DB ' SYSTEM ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GBBLECIH@?5PUBLIC?5@
CONST	SEGMENT
??_C@_08GBBLECIH@?5PUBLIC?5@ DB ' PUBLIC ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IOFINGOM@?$DM?$CBNOTATION?5@
CONST	SEGMENT
??_C@_0M@IOFINGOM@?$DM?$CBNOTATION?5@ DB '<!NOTATION ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HFJJKKEO@xmlAddNotationDecl?3?5?$CFs?5already?5@
CONST	SEGMENT
??_C@_0CI@HFJJKKEO@xmlAddNotationDecl?3?5?$CFs?5already?5@ DB 'xmlAddNota'
	DB	'tionDecl: %s already defined', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PJBPJANJ@xmlAddNotationDecl?3?5Table?5creat@
CONST	SEGMENT
??_C@_0CM@PJBPJANJ@xmlAddNotationDecl?3?5Table?5creat@ DB 'xmlAddNotation'
	DB	'Decl: Table creation failed!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@EJJFJDDL@Internal?3?5ATTRIBUTE?5struct?5corr@
CONST	SEGMENT
??_C@_0DC@EJJFJDDL@Internal?3?5ATTRIBUTE?5struct?5corr@ DB 'Internal: ATT'
	DB	'RIBUTE struct corrupted invalid def', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PNOBFAOP@?5?$CDFIXED@
CONST	SEGMENT
??_C@_07PNOBFAOP@?5?$CDFIXED@ DB ' #FIXED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GOIPIIGC@?5?$CDIMPLIED@
CONST	SEGMENT
??_C@_09GOIPIIGC@?5?$CDIMPLIED@ DB ' #IMPLIED', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IEBFJPBC@?5?$CDREQUIRED@
CONST	SEGMENT
??_C@_0L@IEBFJPBC@?5?$CDREQUIRED@ DB ' #REQUIRED', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IGKIMAHJ@?5NOTATION?5?$CI@
CONST	SEGMENT
??_C@_0M@IGKIMAHJ@?5NOTATION?5?$CI@ DB ' NOTATION (', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GFKOMOKH@?5?$CI@
CONST	SEGMENT
??_C@_02GFKOMOKH@?5?$CI@ DB ' (', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09LGAPIBOH@?5NMTOKENS@
CONST	SEGMENT
??_C@_09LGAPIBOH@?5NMTOKENS@ DB ' NMTOKENS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JLMONKHB@?5NMTOKEN@
CONST	SEGMENT
??_C@_08JLMONKHB@?5NMTOKEN@ DB ' NMTOKEN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MILPKLMO@?5ENTITIES@
CONST	SEGMENT
??_C@_09MILPKLMO@?5ENTITIES@ DB ' ENTITIES', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GLIJGNMP@?5ENTITY@
CONST	SEGMENT
??_C@_07GLIJGNMP@?5ENTITY@ DB ' ENTITY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNGJPBFB@?5IDREFS@
CONST	SEGMENT
??_C@_07CNGJPBFB@?5IDREFS@ DB ' IDREFS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JJHMNMLB@?5IDREF@
CONST	SEGMENT
??_C@_06JJHMNMLB@?5IDREF@ DB ' IDREF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JFNHLDJD@?5ID@
CONST	SEGMENT
??_C@_03JFNHLDJD@?5ID@ DB ' ID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CIOOFICG@?5CDATA@
CONST	SEGMENT
??_C@_06CIOOFICG@?5CDATA@ DB ' CDATA', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NDHICKFH@?$DM?$CBATTLIST?5@
CONST	SEGMENT
??_C@_0L@NDHICKFH@?$DM?$CBATTLIST?5@ DB '<!ATTLIST ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPEFOGKI@xmlns@
CONST	SEGMENT
??_C@_05PPEFOGKI@xmlns@ DB 'xmlns', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@GEPJIIIF@Element?5?$CFs?5has?5too?5may?5ID?5attri@
CONST	SEGMENT
??_C@_0DD@GEPJIIIF@Element?5?$CFs?5has?5too?5may?5ID?5attri@ DB 'Element '
	DB	'%s has too may ID attributes defined : %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HJBCFPNE@Attribute?5?$CFs?5of?5element?5?$CFs?3?5alr@
CONST	SEGMENT
??_C@_0CN@HJBCFPNE@Attribute?5?$CFs?5of?5element?5?$CFs?3?5alr@ DB 'Attri'
	DB	'bute %s of element %s: already defined', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LFDBMMCB@xmlAddAttributeDecl?3?5Table?5crea@
CONST	SEGMENT
??_C@_0CN@LFDBMMCB@xmlAddAttributeDecl?3?5Table?5crea@ DB 'xmlAddAttribut'
	DB	'eDecl: Table creation failed!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IHGCOODJ@Attribute?5?$CFs?5of?5?$CFs?3?5invalid?5def@
CONST	SEGMENT
??_C@_0CL@IHGCOODJ@Attribute?5?$CFs?5of?5?$CFs?3?5invalid?5def@ DB 'Attri'
	DB	'bute %s of %s: invalid default value', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@NLJCGIHL@Internal?3?5ATTRIBUTE?5struct?5corr@
CONST	SEGMENT
??_C@_0DD@NLJCGIHL@Internal?3?5ATTRIBUTE?5struct?5corr@ DB 'Internal: ATT'
	DB	'RIBUTE struct corrupted invalid type', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@EJGKGKMH@Element?5?$CFs?5has?5too?5many?5ID?5attr@
CONST	SEGMENT
??_C@_0DE@EJGKGKMH@Element?5?$CFs?5has?5too?5many?5ID?5attr@ DB 'Element '
	DB	'%s has too many ID attributes defined : %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@NFLGBMMC@Internal?3?5ELEMENT?5struct?5corrup@
CONST	SEGMENT
??_C@_0DB@NFLGBMMC@Internal?3?5ELEMENT?5struct?5corrup@ DB 'Internal: ELE'
	DB	'MENT struct corrupted invalid type', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02NEKEAGPN@?$DO?6@
CONST	SEGMENT
??_C@_02NEKEAGPN@?$DO?6@ DB '>', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06OMPGEGME@?5ANY?$DO?6@
CONST	SEGMENT
??_C@_06OMPGEGME@?5ANY?$DO?6@ DB ' ANY>', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HMKELAAG@?5EMPTY?$DO?6@
CONST	SEGMENT
??_C@_08HMKELAAG@?5EMPTY?$DO?6@ DB ' EMPTY>', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EMLMHHFJ@?$DM?$CBELEMENT?5@
CONST	SEGMENT
??_C@_0L@EMLMHHFJ@?$DM?$CBELEMENT?5@ DB '<!ELEMENT ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DLJMKEJ@Redefinition?5of?5element?5?$CFs?6@
CONST	SEGMENT
??_C@_0BM@DLJMKEJ@Redefinition?5of?5element?5?$CFs?6@ DB 'Redefinition of'
	DB	' element %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IICJECDN@xmlAddElementDecl?3?5Table?5creati@
CONST	SEGMENT
??_C@_0CL@IICJECDN@xmlAddElementDecl?3?5Table?5creati@ DB 'xmlAddElementD'
	DB	'ecl: Table creation failed!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HFIOBKAA@Internal?3?5ELEMENT?5decl?5corrupte@
CONST	SEGMENT
??_C@_0CP@HFIOBKAA@Internal?3?5ELEMENT?5decl?5corrupte@ DB 'Internal: ELE'
	DB	'MENT decl corrupted invalid type', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@CFDLEHAD@xmlAddElementDecl?3?5content?5?$DN?$DN?5N@
CONST	SEGMENT
??_C@_0DA@CFDLEHAD@xmlAddElementDecl?3?5content?5?$DN?$DN?5N@ DB 'xmlAddE'
	DB	'lementDecl: content == NULL for ELEMENT', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IMMDEKCP@xmlAddElementDecl?3?5content?5?$DN?$DN?5N@
CONST	SEGMENT
??_C@_0CO@IMMDEKCP@xmlAddElementDecl?3?5content?5?$DN?$DN?5N@ DB 'xmlAddE'
	DB	'lementDecl: content == NULL for MIXED', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DBFKJMHA@xmlAddElementDecl?3?5content?5?$CB?$DN?5N@
CONST	SEGMENT
??_C@_0CM@DBFKJMHA@xmlAddElementDecl?3?5content?5?$CB?$DN?5N@ DB 'xmlAddE'
	DB	'lementDecl: content != NULL for ANY', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BLBNCGCL@xmlAddElementDecl?3?5content?5?$CB?$DN?5N@
CONST	SEGMENT
??_C@_0CO@BLBNCGCL@xmlAddElementDecl?3?5content?5?$CB?$DN?5N@ DB 'xmlAddE'
	DB	'lementDecl: content != NULL for EMPTY', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IBCFJNCN@?5?4?4?4@
CONST	SEGMENT
??_C@_04IBCFJNCN@?5?4?4?4@ DB ' ...', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01MIFGBAGJ@?$CL@
CONST	SEGMENT
??_C@_01MIFGBAGJ@?$CL@ DB '+', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP@
CONST	SEGMENT
??_C@_01OGPIMHDM@?$DP@ DB '?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ@ DB ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LGOGDKEL@?5?$HM?5@
CONST	SEGMENT
??_C@_03LGOGDKEL@?5?$HM?5@ DB ' | ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NKFKBEPL@?5?0?5@
CONST	SEGMENT
??_C@_03NKFKBEPL@?5?0?5@ DB ' , ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07ELDBONKP@?$CDPCDATA@
CONST	SEGMENT
??_C@_07ELDBONKP@?$CDPCDATA@ DB '#PCDATA', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01ODHLEDKK@?$CI@
CONST	SEGMENT
??_C@_01ODHLEDKK@?$CI@ DB '(', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@GLPLFDD@Internal?3?5ELEMENT?5content?5corru@
CONST	SEGMENT
??_C@_0DC@GLPLFDD@Internal?3?5ELEMENT?5content?5corru@ DB 'Internal: ELEM'
	DB	'ENT content corrupted invalid type', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EHMNFIPD@xmlNewElementContent?5?3?5name?5?$CB?$DN?5@
CONST	SEGMENT
??_C@_0CH@EHMNFIPD@xmlNewElementContent?5?3?5name?5?$CB?$DN?5@ DB 'xmlNew'
	DB	'ElementContent : name != NULL !', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@ODCBAOPP@xmlNewElementContent?5?3?5name?5?$DN?$DN?5@
CONST	SEGMENT
??_C@_0CH@ODCBAOPP@xmlNewElementContent?5?3?5name?5?$DN?$DN?5@ DB 'xmlNew'
	DB	'ElementContent : name == NULL !', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@GHMIMING@Content?5model?5of?5?$CFs?5is?5not?5dete@
CONST	SEGMENT
??_C@_0CM@GHMIMING@Content?5model?5of?5?$CFs?5is?5not?5dete@ DB 'Content '
	DB	'model of %s is not determinist: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LILACHHH@Cannot?5create?5automata?5for?5elem@
CONST	SEGMENT
??_C@_0CH@LILACHHH@Cannot?5create?5automata?5for?5elem@ DB 'Cannot create'
	DB	' automata for element %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LMBMADBI@ContentModel?5broken?5for?5element@
CONST	SEGMENT
??_C@_0CE@LMBMADBI@ContentModel?5broken?5for?5element@ DB 'ContentModel b'
	DB	'roken for element %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@INHICIGB@Building?5content?5model@
CONST	SEGMENT
??_C@_0BH@INHICIGB@Building?5content?5model@ DB 'Building content model', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IIHAKBAI@Found?5PCDATA?5in?5content?5model?5o@
CONST	SEGMENT
??_C@_0CF@IIHAKBAI@Found?5PCDATA?5in?5content?5model?5o@ DB 'Found PCDATA'
	DB	' in content model of %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FIAOIAHN@Found?5NULL?5content?5in?5content?5m@
CONST	SEGMENT
??_C@_0CL@FIAOIAHN@Found?5NULL?5content?5in?5content?5m@ DB 'Found NULL c'
	DB	'ontent in content model of %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GEBFHDLO@Failed?5to?5build?5content?5model?5r@
CONST	SEGMENT
??_C@_0CN@GEBFHDLO@Failed?5to?5build?5content?5model?5r@ DB 'Failed to bu'
	DB	'ild content model regexp for %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BHJOIPMJ@realloc?5failed@
CONST	SEGMENT
??_C@_0P@BHJOIPMJ@realloc?5failed@ DB 'realloc failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IMHFIAOC@malloc?5failed@
CONST	SEGMENT
??_C@_0O@IMHFIAOC@malloc?5failed@ DB 'malloc failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
CONST	SEGMENT
??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@ DB 'Memory allocation fa'
	DB	'iled', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ DB 'Memory al'
	DB	'location failed : %s', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlNoValidityErr
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_msg$ = 12						; size = 4
_xmlNoValidityErr PROC					; COMDAT
	mov	ecx, OFFSET __56F63275_valid@c
	jmp	@__CheckForDebuggerJustMyCode@4
_xmlNoValidityErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateAttributeCallback
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlValidateAttributeCallback PROC			; COMDAT

; 6710 : 	                     const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _payload$[ebp]
	test	esi, esi
	je	$LN19@xmlValidat

; 6711 :     xmlAttributePtr cur = (xmlAttributePtr) payload;
; 6712 :     xmlValidCtxtPtr ctxt = (xmlValidCtxtPtr) data;
; 6713 :     int ret;
; 6714 :     xmlDocPtr doc;
; 6715 :     xmlElementPtr elem = NULL;
; 6716 : 
; 6717 :     if (cur == NULL)
; 6718 : 	return;
; 6719 :     switch (cur->atype) {

	mov	eax, DWORD PTR [esi+40]
	push	ebx
	push	edi
	mov	edi, DWORD PTR _data$[ebp]
	cmp	eax, 5
	jl	SHORT $LN5@xmlValidat
	cmp	eax, 6
	jle	SHORT $LN8@xmlValidat
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN5@xmlValidat
$LN8@xmlValidat:

; 6720 : 	case XML_ATTRIBUTE_CDATA:
; 6721 : 	case XML_ATTRIBUTE_ID:
; 6722 : 	case XML_ATTRIBUTE_IDREF	:
; 6723 : 	case XML_ATTRIBUTE_IDREFS:
; 6724 : 	case XML_ATTRIBUTE_NMTOKEN:
; 6725 : 	case XML_ATTRIBUTE_NMTOKENS:
; 6726 : 	case XML_ATTRIBUTE_ENUMERATION:
; 6727 : 	    break;
; 6728 : 	case XML_ATTRIBUTE_ENTITY:
; 6729 : 	case XML_ATTRIBUTE_ENTITIES:
; 6730 : 	case XML_ATTRIBUTE_NOTATION:
; 6731 : 	    if (cur->defaultValue != NULL) {

	mov	ecx, DWORD PTR [esi+48]
	test	ecx, ecx
	je	SHORT $LN10@xmlValidat

; 6732 : 
; 6733 : 		ret = xmlValidateAttributeValue2(ctxt, ctxt->doc, cur->name,

	push	ecx
	push	eax
	push	DWORD PTR [esi+8]
	push	DWORD PTR [edi+32]
	push	edi
	call	_xmlValidateAttributeValue2
	add	esp, 20					; 00000014H

; 6734 : 			                         cur->atype, cur->defaultValue);
; 6735 : 		if ((ret == 0) && (ctxt->valid == 1))

	test	eax, eax
	jne	SHORT $LN10@xmlValidat
	cmp	DWORD PTR [edi+36], 1
	jne	SHORT $LN10@xmlValidat

; 6736 : 		    ctxt->valid = 0;

	mov	DWORD PTR [edi+36], eax
$LN10@xmlValidat:

; 6737 : 	    }
; 6738 : 	    if (cur->tree != NULL) {

	mov	ebx, DWORD PTR [esi+52]
	test	ebx, ebx
	je	SHORT $LN5@xmlValidat
	npad	4
$LL4@xmlValidat:

; 6739 : 		xmlEnumerationPtr tree = cur->tree;
; 6740 : 		while (tree != NULL) {
; 6741 : 		    ret = xmlValidateAttributeValue2(ctxt, ctxt->doc,

	push	DWORD PTR [ebx+4]
	push	DWORD PTR [esi+40]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [edi+32]
	push	edi
	call	_xmlValidateAttributeValue2
	add	esp, 20					; 00000014H

; 6742 : 				    cur->name, cur->atype, tree->name);
; 6743 : 		    if ((ret == 0) && (ctxt->valid == 1))

	test	eax, eax
	jne	SHORT $LN12@xmlValidat
	cmp	DWORD PTR [edi+36], 1
	jne	SHORT $LN12@xmlValidat

; 6744 : 			ctxt->valid = 0;

	mov	DWORD PTR [edi+36], eax
$LN12@xmlValidat:

; 6745 : 		    tree = tree->next;

	mov	ebx, DWORD PTR [ebx]
	test	ebx, ebx
	jne	SHORT $LL4@xmlValidat
$LN5@xmlValidat:

; 6746 : 		}
; 6747 : 	    }
; 6748 :     }
; 6749 :     if (cur->atype == XML_ATTRIBUTE_NOTATION) {

	cmp	DWORD PTR [esi+40], 10			; 0000000aH
	jne	$LN28@xmlValidat

; 6750 : 	doc = cur->doc;
; 6751 : 	if (cur->elem == NULL) {

	mov	eax, DWORD PTR [esi+60]
	mov	ebx, DWORD PTR [esi+32]
	test	eax, eax
	jne	SHORT $LN14@xmlValidat

; 6752 : 	    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,

	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0DC@EEKBOKHB@xmlValidateAttributeCallback?$CI?$CFs@
	push	1
	push	edi
	call	_xmlErrValid
	add	esp, 16					; 00000010H
	pop	edi
	pop	ebx
	pop	esi

; 6776 : 	}
; 6777 :     }
; 6778 : }

	pop	ebp
	ret	0
$LN14@xmlValidat:

; 6753 : 		   "xmlValidateAttributeCallback(%s): internal error\n",
; 6754 : 		   (const char *) cur->name);
; 6755 : 	    return;
; 6756 : 	}
; 6757 : 
; 6758 : 	if (doc != NULL)

	test	ebx, ebx
	je	SHORT $LN26@xmlValidat

; 6759 : 	    elem = xmlGetDtdElementDesc(doc->intSubset, cur->elem);

	push	eax
	push	DWORD PTR [ebx+44]
	call	_xmlGetDtdElementDesc
	add	esp, 8

; 6760 : 	if ((elem == NULL) && (doc != NULL))

	test	eax, eax
	jne	SHORT $LN18@xmlValidat

; 6761 : 	    elem = xmlGetDtdElementDesc(doc->extSubset, cur->elem);

	push	DWORD PTR [esi+60]
	push	DWORD PTR [ebx+48]
	call	_xmlGetDtdElementDesc
	add	esp, 8

; 6762 : 	if ((elem == NULL) && (cur->parent != NULL) &&

	test	eax, eax
	jne	SHORT $LN18@xmlValidat
$LN26@xmlValidat:
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN27@xmlValidat
	cmp	DWORD PTR [eax+4], 14			; 0000000eH
	jne	SHORT $LN27@xmlValidat

; 6763 : 	    (cur->parent->type == XML_DTD_NODE))
; 6764 : 	    elem = xmlGetDtdElementDesc((xmlDtdPtr) cur->parent, cur->elem);

	push	DWORD PTR [esi+60]
	push	eax
	call	_xmlGetDtdElementDesc
	add	esp, 8

; 6765 : 	if (elem == NULL) {

	test	eax, eax
	je	SHORT $LN27@xmlValidat
$LN18@xmlValidat:

; 6767 : 		   "attribute %s: could not find decl for element %s\n",
; 6768 : 		   cur->name, cur->elem, NULL);
; 6769 : 	    return;
; 6770 : 	}
; 6771 : 	if (elem->etype == XML_ELEMENT_TYPE_EMPTY) {

	cmp	DWORD PTR [eax+36], 1
	jne	SHORT $LN28@xmlValidat

; 6772 : 	    xmlErrValidNode(ctxt, NULL, XML_DTD_EMPTY_NOTATION,

	push	0
	push	DWORD PTR [esi+60]
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0DF@KBMCJLCB@NOTATION?5attribute?5?$CFs?5declared?5@
	push	510					; 000001feH
	push	0
	push	edi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 6773 : 		   "NOTATION attribute %s declared for EMPTY element %s\n",
; 6774 : 		   cur->name, cur->elem, NULL);
; 6775 : 	    ctxt->valid = 0;

	mov	DWORD PTR [edi+36], 0
	pop	edi
	pop	ebx
	pop	esi

; 6776 : 	}
; 6777 :     }
; 6778 : }

	pop	ebp
	ret	0
$LN27@xmlValidat:

; 6766 : 	    xmlErrValidNode(ctxt, NULL, XML_DTD_UNKNOWN_ELEM,

	push	0
	push	DWORD PTR [esi+60]
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0DC@CHBKELEG@attribute?5?$CFs?3?5could?5not?5find?5de@
	push	534					; 00000216H
	push	0
	push	edi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
$LN28@xmlValidat:
	pop	edi
	pop	ebx
$LN19@xmlValidat:
	pop	esi

; 6776 : 	}
; 6777 :     }
; 6778 : }

	pop	ebp
	ret	0
_xmlValidateAttributeCallback ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateNotationCallback
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlValidateNotationCallback PROC			; COMDAT

; 6689 : 	                    const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _payload$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlValidat

; 6690 :     xmlEntityPtr cur = (xmlEntityPtr) payload;
; 6691 :     xmlValidCtxtPtr ctxt = (xmlValidCtxtPtr) data;
; 6692 :     if (cur == NULL)
; 6693 : 	return;
; 6694 :     if (cur->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {

	cmp	DWORD PTR [eax+48], 3
	jne	SHORT $LN5@xmlValidat

; 6695 : 	xmlChar *notation = cur->content;

	mov	ecx, DWORD PTR [eax+40]

; 6696 : 
; 6697 : 	if (notation != NULL) {

	test	ecx, ecx
	je	SHORT $LN5@xmlValidat

; 6698 : 	    int ret;
; 6699 : 
; 6700 : 	    ret = xmlValidateNotationUse(ctxt, cur->doc, notation);

	push	esi
	mov	esi, DWORD PTR _data$[ebp]
	push	ecx
	push	DWORD PTR [eax+32]
	push	esi
	call	_xmlValidateNotationUse
	add	esp, 12					; 0000000cH

; 6701 : 	    if (ret != 1) {

	cmp	eax, 1
	je	SHORT $LN7@xmlValidat

; 6702 : 		ctxt->valid = 0;

	mov	DWORD PTR [esi+36], 0
$LN7@xmlValidat:
	pop	esi
$LN5@xmlValidat:

; 6703 : 	    }
; 6704 : 	}
; 6705 :     }
; 6706 : }

	pop	ebp
	ret	0
_xmlValidateNotationCallback ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateCheckRefCallback
_TEXT	SEGMENT
_memo$ = -8						; size = 8
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlValidateCheckRefCallback PROC			; COMDAT

; 6573 : xmlValidateCheckRefCallback(void *payload, void *data, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _payload$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@xmlValidat

; 6574 :     xmlListPtr ref_list = (xmlListPtr) payload;
; 6575 :     xmlValidCtxtPtr ctxt = (xmlValidCtxtPtr) data;
; 6576 :     xmlValidateMemo memo;
; 6577 : 
; 6578 :     if (ref_list == NULL)
; 6579 : 	return;
; 6580 :     memo.ctxt = ctxt;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _memo$[ebp], eax

; 6581 :     memo.name = name;

	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR _memo$[ebp+4], eax

; 6582 : 
; 6583 :     xmlListWalk(ref_list, xmlWalkValidateList, &memo);

	lea	eax, DWORD PTR _memo$[ebp]
	push	eax
	push	OFFSET _xmlWalkValidateList
	push	ecx
	call	_xmlListWalk
	add	esp, 12					; 0000000cH
$LN1@xmlValidat:

; 6584 : 
; 6585 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidateCheckRefCallback ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlWalkValidateList
_TEXT	SEGMENT
_data$ = 8						; size = 4
_user$ = 12						; size = 4
_xmlWalkValidateList PROC				; COMDAT

; 6559 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _user$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	push	DWORD PTR _data$[ebp]
	call	_xmlValidateRef
	add	esp, 12					; 0000000cH
	mov	eax, 1

; 6560 : 	xmlValidateMemoPtr memo = (xmlValidateMemoPtr)user;
; 6561 : 	xmlValidateRef((xmlRefPtr)data, memo->ctxt, memo->name);
; 6562 : 	return 1;
; 6563 : }

	pop	ebp
	ret	0
_xmlWalkValidateList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateRef
_TEXT	SEGMENT
_dup$1$ = -8						; size = 4
_attr$1$ = -8						; size = 4
_str$1$ = -4						; size = 4
_dup$1$ = 8						; size = 4
_ref$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlValidateRef PROC					; COMDAT

; 6475 : 	                   const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __56F63275_valid@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ref$[ebp]
	test	edi, edi
	je	$LN27@xmlValidat

; 6476 :     xmlAttrPtr id;
; 6477 :     xmlAttrPtr attr;
; 6478 : 
; 6479 :     if (ref == NULL)
; 6480 : 	return;
; 6481 :     if ((ref->attr == NULL) && (ref->name == NULL))

	push	ebx
	mov	ebx, DWORD PTR [edi+8]
	mov	DWORD PTR _attr$1$[ebp], ebx
	test	ebx, ebx
	jne	SHORT $LN68@xmlValidat
	cmp	DWORD PTR [edi+12], ebx
	je	$LN85@xmlValidat
$LN68@xmlValidat:
	push	esi

; 6482 : 	return;
; 6483 :     attr = ref->attr;
; 6484 :     if (attr == NULL) {

	test	ebx, ebx
	jne	$LN16@xmlValidat

; 6485 : 	xmlChar *dup, *str = NULL, *cur, save;
; 6486 : 
; 6487 : 	dup = xmlStrdup(name);

	push	DWORD PTR _name$[ebp]
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _dup$1$[ebp], eax

; 6488 : 	if (dup == NULL) {

	test	eax, eax
	jne	SHORT $LN18@xmlValidat

; 6489 : 	    ctxt->valid = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	pop	esi
	mov	DWORD PTR [eax+36], ebx
	pop	ebx
	pop	edi

; 6547 :     }
; 6548 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlValidat:

; 6490 : 	    return;
; 6491 : 	}
; 6492 : 	cur = dup;
; 6493 : 	while (*cur != 0) {

	mov	bl, BYTE PTR [eax]
	mov	esi, eax
	test	bl, bl
	je	$LN80@xmlValidat
$LL2@xmlValidat:

; 6494 : 	    str = cur;

	mov	eax, esi
	mov	DWORD PTR _str$1$[ebp], eax

; 6495 : 	    while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;

	test	bl, bl
	je	SHORT $LN5@xmlValidat
	mov	al, bl
	npad	1
$LL4@xmlValidat:
	mov	bl, al
	cmp	al, 32					; 00000020H
	je	SHORT $LN81@xmlValidat
	cmp	al, 9
	jb	SHORT $LN19@xmlValidat
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN81@xmlValidat
$LN19@xmlValidat:
	mov	bl, al
	cmp	al, 13					; 0000000dH
	je	SHORT $LN81@xmlValidat
	mov	bl, BYTE PTR [esi+1]
	inc	esi
	mov	al, bl
	test	bl, bl
	jne	SHORT $LL4@xmlValidat
$LN81@xmlValidat:
	mov	eax, DWORD PTR _str$1$[ebp]
$LN5@xmlValidat:

; 6496 : 	    save = *cur;
; 6497 : 	    *cur = 0;
; 6498 : 	    id = xmlGetID(ctxt->doc, str);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	BYTE PTR [esi], 0
	mov	edi, DWORD PTR [ecx+32]

; 2807 :     if (doc == NULL) {

	test	edi, edi
	je	SHORT $LN67@xmlValidat

; 2808 : 	return(NULL);
; 2809 :     }
; 2810 : 
; 2811 :     if (ID == NULL) {

	test	eax, eax
	je	SHORT $LN67@xmlValidat

; 2812 : 	return(NULL);
; 2813 :     }
; 2814 : 
; 2815 :     table = (xmlIDTablePtr) doc->ids;

	mov	eax, DWORD PTR [edi+64]

; 2816 :     if (table == NULL)

	test	eax, eax
	je	SHORT $LN67@xmlValidat

; 2817 :         return(NULL);
; 2818 : 
; 2819 :     id = xmlHashLookup(table, ID);

	push	DWORD PTR _str$1$[ebp]
	push	eax
	call	_xmlHashLookup
	add	esp, 8

; 2820 :     if (id == NULL)

	test	eax, eax
	je	SHORT $LN67@xmlValidat

; 2821 : 	return(NULL);
; 2822 :     if (id->attr == NULL) {

	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	cmove	eax, edi

; 6499 : 	    if (id == NULL) {

	test	eax, eax
	jne	SHORT $LN20@xmlValidat
$LN67@xmlValidat:

; 6500 : 		xmlErrValidNodeNr(ctxt, NULL, XML_DTD_UNKNOWN_ID,

	push	DWORD PTR _str$1$[ebp]
	mov	edi, DWORD PTR _ref$[ebp]
	push	DWORD PTR [edi+16]
	push	DWORD PTR [edi+12]
	mov	edi, DWORD PTR _ctxt$[ebp]
	push	OFFSET ??_C@_0DE@GLBIFDCC@attribute?5?$CFs?5line?5?$CFd?5references@
	push	536					; 00000218H
	push	0
	push	edi
	call	_xmlErrValidNodeNr
	add	esp, 28					; 0000001cH

; 6501 : 	   "attribute %s line %d references an unknown ID \"%s\"\n",
; 6502 : 		       ref->name, ref->lineno, str);
; 6503 : 		ctxt->valid = 0;

	mov	DWORD PTR [edi+36], 0
$LN20@xmlValidat:

; 6504 : 	    }
; 6505 : 	    if (save == 0)

	test	bl, bl
	je	SHORT $LN82@xmlValidat

; 6506 : 		break;
; 6507 : 	    *cur = save;

	mov	BYTE PTR [esi], bl
$LL6@xmlValidat:

; 6508 : 	    while (IS_BLANK_CH(*cur)) cur++;

	cmp	bl, 32					; 00000020H
	je	SHORT $LN22@xmlValidat
	cmp	bl, 9
	jb	SHORT $LN23@xmlValidat
	cmp	bl, 10					; 0000000aH
	jbe	SHORT $LN22@xmlValidat
$LN23@xmlValidat:
	cmp	bl, 13					; 0000000dH
	jne	SHORT $LN7@xmlValidat
$LN22@xmlValidat:
	mov	bl, BYTE PTR [esi+1]
	inc	esi
	jmp	SHORT $LL6@xmlValidat
$LN7@xmlValidat:

; 6490 : 	    return;
; 6491 : 	}
; 6492 : 	cur = dup;
; 6493 : 	while (*cur != 0) {

	test	bl, bl
	jne	$LL2@xmlValidat
$LN82@xmlValidat:
	mov	eax, DWORD PTR _dup$1$[ebp]

; 6545 : 	}
; 6546 : 	xmlFree(dup);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi
	pop	ebx
	pop	edi

; 6547 :     }
; 6548 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlValidat:

; 6509 : 	}
; 6510 : 	xmlFree(dup);
; 6511 :     } else if (attr->atype == XML_ATTRIBUTE_IDREF) {

	mov	eax, DWORD PTR [ebx+40]
	cmp	eax, 3
	jne	SHORT $LN24@xmlValidat

; 6512 : 	id = xmlGetID(ctxt->doc, name);

	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	edi, DWORD PTR _name$[ebp]
	push	edi
	push	DWORD PTR [esi+32]
	call	_xmlGetID
	add	esp, 8

; 6513 : 	if (id == NULL) {

	test	eax, eax
	jne	$LN86@xmlValidat

; 6514 : 	    xmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,

	push	eax
	push	edi
	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0DC@HOBCELJH@IDREF?5attribute?5?$CFs?5references?5a@
	push	536					; 00000218H
	push	DWORD PTR [ebx+20]
	push	esi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 6515 : 	   "IDREF attribute %s references an unknown ID \"%s\"\n",
; 6516 : 		   attr->name, name, NULL);
; 6517 : 	    ctxt->valid = 0;

	mov	DWORD PTR [esi+36], 0
	pop	esi
	pop	ebx
	pop	edi

; 6547 :     }
; 6548 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlValidat:

; 6518 : 	}
; 6519 :     } else if (attr->atype == XML_ATTRIBUTE_IDREFS) {

	cmp	eax, 4
	jne	$LN86@xmlValidat

; 6520 : 	xmlChar *dup, *str = NULL, *cur, save;
; 6521 : 
; 6522 : 	dup = xmlStrdup(name);

	push	DWORD PTR _name$[ebp]
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _dup$1$[ebp], eax

; 6523 : 	if (dup == NULL) {

	test	eax, eax
	jne	SHORT $LN28@xmlValidat

; 6524 : 	    xmlVErrMemory(ctxt, "IDREFS split");

	mov	esi, DWORD PTR _ctxt$[ebp]
	push	OFFSET ??_C@_0N@BBOKCKMC@IDREFS?5split@
	push	esi
	call	_xmlVErrMemory
	add	esp, 8

; 6525 : 	    ctxt->valid = 0;

	mov	DWORD PTR [esi+36], 0
	pop	esi
	pop	ebx
	pop	edi

; 6547 :     }
; 6548 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlValidat:

; 6526 : 	    return;
; 6527 : 	}
; 6528 : 	cur = dup;
; 6529 : 	while (*cur != 0) {

	mov	bl, BYTE PTR [eax]
	mov	esi, eax
	test	bl, bl
	je	$LN80@xmlValidat
	npad	3
$LL8@xmlValidat:

; 6530 : 	    str = cur;

	mov	edi, esi

; 6531 : 	    while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;

	test	bl, bl
	je	SHORT $LN83@xmlValidat

; 6476 :     xmlAttrPtr id;
; 6477 :     xmlAttrPtr attr;
; 6478 : 
; 6479 :     if (ref == NULL)
; 6480 : 	return;
; 6481 :     if ((ref->attr == NULL) && (ref->name == NULL))

	mov	al, bl
$LL10@xmlValidat:

; 6531 : 	    while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;

	mov	bl, al
	cmp	al, 32					; 00000020H
	je	SHORT $LN83@xmlValidat
	cmp	al, 9
	jb	SHORT $LN29@xmlValidat
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN83@xmlValidat
$LN29@xmlValidat:
	mov	bl, al
	cmp	al, 13					; 0000000dH
	je	SHORT $LN83@xmlValidat
	mov	bl, BYTE PTR [esi+1]
	inc	esi
	mov	al, bl
	test	bl, bl
	jne	SHORT $LL10@xmlValidat
$LN83@xmlValidat:

; 6532 : 	    save = *cur;
; 6533 : 	    *cur = 0;
; 6534 : 	    id = xmlGetID(ctxt->doc, str);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	BYTE PTR [esi], 0
	push	edi
	push	DWORD PTR [eax+32]
	call	_xmlGetID
	add	esp, 8

; 6535 : 	    if (id == NULL) {

	test	eax, eax
	jne	SHORT $LN30@xmlValidat

; 6536 : 		xmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,

	push	eax
	mov	eax, DWORD PTR _attr$1$[ebp]
	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [eax+8]
	push	OFFSET ??_C@_0DD@JBMPIAIH@IDREFS?5attribute?5?$CFs?5references?5@
	push	536					; 00000218H
	push	DWORD PTR [eax+20]
	push	edi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 6537 : 	   "IDREFS attribute %s references an unknown ID \"%s\"\n",
; 6538 : 			     attr->name, str, NULL);
; 6539 : 		ctxt->valid = 0;

	mov	DWORD PTR [edi+36], 0
$LN30@xmlValidat:

; 6540 : 	    }
; 6541 : 	    if (save == 0)

	test	bl, bl
	je	SHORT $LN84@xmlValidat

; 6542 : 		break;
; 6543 : 	    *cur = save;

	mov	BYTE PTR [esi], bl
	npad	6
$LL12@xmlValidat:

; 6544 : 	    while (IS_BLANK_CH(*cur)) cur++;

	cmp	bl, 32					; 00000020H
	je	SHORT $LN32@xmlValidat
	cmp	bl, 9
	jb	SHORT $LN33@xmlValidat
	cmp	bl, 10					; 0000000aH
	jbe	SHORT $LN32@xmlValidat
$LN33@xmlValidat:
	cmp	bl, 13					; 0000000dH
	jne	SHORT $LN13@xmlValidat
$LN32@xmlValidat:
	mov	bl, BYTE PTR [esi+1]
	inc	esi
	jmp	SHORT $LL12@xmlValidat
$LN13@xmlValidat:

; 6526 : 	    return;
; 6527 : 	}
; 6528 : 	cur = dup;
; 6529 : 	while (*cur != 0) {

	test	bl, bl
	jne	$LL8@xmlValidat
$LN84@xmlValidat:
	mov	eax, DWORD PTR _dup$1$[ebp]
$LN80@xmlValidat:

; 6545 : 	}
; 6546 : 	xmlFree(dup);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN86@xmlValidat:
	pop	esi
$LN85@xmlValidat:
	pop	ebx
$LN27@xmlValidat:
	pop	edi

; 6547 :     }
; 6548 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidateRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidGetElemDecl
_TEXT	SEGMENT
_prefix$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_elem$ = 16						; size = 4
_extsubset$ = 20					; size = 4
_xmlValidGetElemDecl PROC				; COMDAT

; 5691 : 	            xmlNodePtr elem, int *extsubset) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _ctxt$[ebp], 0
	je	$LN3@xmlValidGe

; 5692 :     xmlElementPtr elemDecl = NULL;
; 5693 :     const xmlChar *prefix = NULL;
; 5694 : 
; 5695 :     if ((ctxt == NULL) || (doc == NULL) ||
; 5696 :         (elem == NULL) || (elem->name == NULL))

	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	je	$LN3@xmlValidGe
	mov	esi, DWORD PTR _elem$[ebp]
	test	esi, esi
	je	$LN3@xmlValidGe
	cmp	DWORD PTR [esi+8], 0
	je	$LN3@xmlValidGe

; 5698 :     if (extsubset != NULL)

	push	ebx
	push	edi
	mov	edi, DWORD PTR _extsubset$[ebp]
	test	edi, edi
	je	SHORT $LN4@xmlValidGe

; 5699 : 	*extsubset = 0;

	mov	DWORD PTR [edi], 0
$LN4@xmlValidGe:

; 5700 : 
; 5701 :     /*
; 5702 :      * Fetch the declaration for the qualified name
; 5703 :      */
; 5704 :     if ((elem->ns != NULL) && (elem->ns->prefix != NULL))

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	je	SHORT $LN15@xmlValidGe
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR _prefix$1$[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN15@xmlValidGe

; 5705 : 	prefix = elem->ns->prefix;
; 5706 : 
; 5707 :     if (prefix != NULL) {
; 5708 : 	elemDecl = xmlGetDtdQElementDesc(doc->intSubset,

	push	ecx
	push	DWORD PTR [esi+8]
	push	DWORD PTR [eax+44]
	call	_xmlGetDtdQElementDesc
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 5709 : 		                         elem->name, prefix);
; 5710 : 	if ((elemDecl == NULL) && (doc->extSubset != NULL)) {

	test	ebx, ebx
	jne	$LN12@xmlValidGe
	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	test	ecx, ecx
	je	SHORT $LN15@xmlValidGe

; 5711 : 	    elemDecl = xmlGetDtdQElementDesc(doc->extSubset,

	push	DWORD PTR _prefix$1$[ebp]
	push	DWORD PTR [esi+8]
	push	ecx
	call	_xmlGetDtdQElementDesc
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 5712 : 		                             elem->name, prefix);
; 5713 : 	    if ((elemDecl != NULL) && (extsubset != NULL))

	test	ebx, ebx
	jne	SHORT $LN17@xmlValidGe
	mov	eax, DWORD PTR _doc$[ebp]
$LN15@xmlValidGe:

; 5714 : 		*extsubset = 1;
; 5715 : 	}
; 5716 :     }
; 5717 : 
; 5718 :     /*
; 5719 :      * Fetch the declaration for the non qualified name
; 5720 :      * This is "non-strict" validation should be done on the
; 5721 :      * full QName but in that case being flexible makes sense.
; 5722 :      */
; 5723 :     if (elemDecl == NULL) {
; 5724 : 	elemDecl = xmlGetDtdElementDesc(doc->intSubset, elem->name);

	push	DWORD PTR [esi+8]
	push	DWORD PTR [eax+44]
	call	_xmlGetDtdElementDesc
	mov	ebx, eax
	add	esp, 8

; 5725 : 	if ((elemDecl == NULL) && (doc->extSubset != NULL)) {

	test	ebx, ebx
	jne	SHORT $LN12@xmlValidGe
	mov	eax, DWORD PTR _doc$[ebp]
	mov	eax, DWORD PTR [eax+48]
	test	eax, eax
	je	SHORT $LN14@xmlValidGe

; 5726 : 	    elemDecl = xmlGetDtdElementDesc(doc->extSubset, elem->name);

	push	DWORD PTR [esi+8]
	push	eax
	call	_xmlGetDtdElementDesc
	mov	ebx, eax
	add	esp, 8

; 5727 : 	    if ((elemDecl != NULL) && (extsubset != NULL))

	test	ebx, ebx
	je	SHORT $LN14@xmlValidGe
$LN17@xmlValidGe:

; 5733 : 			XML_DTD_UNKNOWN_ELEM,
; 5734 : 	       "No declaration for element %s\n",
; 5735 : 	       elem->name, NULL, NULL);
; 5736 :     }
; 5737 :     return(elemDecl);

	test	edi, edi
	je	SHORT $LN12@xmlValidGe
	mov	DWORD PTR [edi], 1
	mov	eax, ebx
	pop	edi
	pop	ebx
	pop	esi

; 5738 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlValidGe:

; 5728 : 		*extsubset = 1;
; 5729 : 	}
; 5730 :     }
; 5731 :     if (elemDecl == NULL) {
; 5732 : 	xmlErrValidNode(ctxt, elem,

	push	0
	push	0
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0BP@CMBGNCIM@No?5declaration?5for?5element?5?$CFs?6@
	push	534					; 00000216H
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
$LN12@xmlValidGe:

; 5733 : 			XML_DTD_UNKNOWN_ELEM,
; 5734 : 	       "No declaration for element %s\n",
; 5735 : 	       elem->name, NULL, NULL);
; 5736 :     }
; 5737 :     return(elemDecl);

	pop	edi
	mov	eax, ebx
	pop	ebx
	pop	esi

; 5738 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlValidGe:

; 5697 :         return(NULL);

	xor	eax, eax
	pop	esi

; 5738 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidGetElemDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateCheckMixed
_TEXT	SEGMENT
_plen$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_cont$ = 12						; size = 4
_qname$ = 16						; size = 4
_xmlValidateCheckMixed PROC				; COMDAT

; 5623 : 	              xmlElementContentPtr cont, const xmlChar *qname) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _qname$[ebp]
	lea	eax, DWORD PTR _plen$[ebp]
	push	eax
	push	edi
	call	_xmlSplitQName3
	mov	esi, DWORD PTR _cont$[ebp]
	add	esp, 8
	mov	ebx, eax
	test	esi, esi
	je	$LN39@xmlValidat

; 5624 :     const xmlChar *name;
; 5625 :     int plen;
; 5626 :     name = xmlSplitQName3(qname, &plen);
; 5627 : 
; 5628 :     if (name == NULL) {

	test	ebx, ebx
	jne	$LL4@xmlValidat
$LL2@xmlValidat:

; 5629 : 	while (cont != NULL) {
; 5630 : 	    if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {

	mov	eax, DWORD PTR [esi]
	cmp	eax, 2
	jne	SHORT $LN8@xmlValidat

; 5631 : 		if ((cont->prefix == NULL) && (xmlStrEqual(cont->name, qname)))

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN14@xmlValidat
	push	edi
	push	DWORD PTR [esi+8]
$LN65@xmlValidat:

; 5641 : 		(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){
; 5642 : 		xmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,
; 5643 : 			"Internal: MIXED struct corrupted\n",
; 5644 : 			NULL);
; 5645 : 		break;
; 5646 : 	    }
; 5647 : 	    cont = cont->c2;

	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlValidat
$LN47@xmlValidat:
	pop	edi

; 5675 : }

	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlValidat:

; 5632 : 		    return(1);
; 5633 : 	    } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&
; 5634 : 	       (cont->c1 != NULL) &&

	cmp	eax, 4
	jne	SHORT $LN45@xmlValidat
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN45@xmlValidat
	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN55@xmlValidat

; 5635 : 	       (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){
; 5636 : 		if ((cont->c1->prefix == NULL) &&

	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN14@xmlValidat
	push	edi
	push	DWORD PTR [eax+8]
	jmp	SHORT $LN65@xmlValidat
$LN55@xmlValidat:

; 5637 : 		    (xmlStrEqual(cont->c1->name, qname)))
; 5638 : 		    return(1);
; 5639 : 	    } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||
; 5640 : 		(cont->c1 == NULL) ||

	test	eax, eax
	je	SHORT $LN45@xmlValidat
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN45@xmlValidat
$LN14@xmlValidat:

; 5641 : 		(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){
; 5642 : 		xmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,
; 5643 : 			"Internal: MIXED struct corrupted\n",
; 5644 : 			NULL);
; 5645 : 		break;
; 5646 : 	    }
; 5647 : 	    cont = cont->c2;

	mov	esi, DWORD PTR [esi+16]
	test	esi, esi
	jne	SHORT $LL2@xmlValidat

; 5675 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@xmlValidat:

; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0CC@LMJFIFCG@Internal?3?5MIXED?5struct?5corrupte@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	519					; 00000207H
	push	23					; 00000017H
	push	0
	push	0
	push	0
	push	0

; 5672 : 	}
; 5673 :     }
; 5674 :     return(0);

	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	xor	eax, eax
	pop	edi

; 5675 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LL4@xmlValidat:

; 5648 : 	}
; 5649 :     } else {
; 5650 : 	while (cont != NULL) {
; 5651 : 	    if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {

	mov	eax, DWORD PTR [esi]
	cmp	eax, 2
	jne	SHORT $LN16@xmlValidat

; 5652 : 		if ((cont->prefix != NULL) &&
; 5653 : 		    (xmlStrncmp(cont->prefix, qname, plen) == 0) &&

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN22@xmlValidat
	push	DWORD PTR _plen$[ebp]
	push	edi
	push	eax
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN22@xmlValidat
	push	ebx
	push	DWORD PTR [esi+8]

; 5654 : 		    (xmlStrEqual(cont->name, name)))
; 5655 : 		    return(1);
; 5656 : 	    } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&

	jmp	SHORT $LN68@xmlValidat
$LN16@xmlValidat:

; 5657 : 	       (cont->c1 != NULL) &&

	cmp	eax, 4
	jne	SHORT $LN48@xmlValidat
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN48@xmlValidat
	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN56@xmlValidat

; 5658 : 	       (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){
; 5659 : 		if ((cont->c1->prefix != NULL) &&
; 5660 : 		    (xmlStrncmp(cont->c1->prefix, qname, plen) == 0) &&

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	je	SHORT $LN22@xmlValidat
	push	DWORD PTR _plen$[ebp]
	push	edi
	push	eax
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN22@xmlValidat
	mov	eax, DWORD PTR [esi+12]
	push	ebx
	push	DWORD PTR [eax+8]
$LN68@xmlValidat:

; 5665 : 		(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){
; 5666 : 		xmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,
; 5667 : 			"Internal: MIXED struct corrupted\n",
; 5668 : 			NULL);
; 5669 : 		break;
; 5670 : 	    }
; 5671 : 	    cont = cont->c2;

	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN47@xmlValidat
	jmp	SHORT $LN22@xmlValidat
$LN56@xmlValidat:

; 5661 : 		    (xmlStrEqual(cont->c1->name, name)))
; 5662 : 		    return(1);
; 5663 : 	    } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||
; 5664 : 		(cont->c1 == NULL) ||

	test	eax, eax
	je	SHORT $LN48@xmlValidat
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN48@xmlValidat
$LN22@xmlValidat:

; 5665 : 		(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){
; 5666 : 		xmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,
; 5667 : 			"Internal: MIXED struct corrupted\n",
; 5668 : 			NULL);
; 5669 : 		break;
; 5670 : 	    }
; 5671 : 	    cont = cont->c2;

	mov	esi, DWORD PTR [esi+16]
	test	esi, esi
	jne	SHORT $LL4@xmlValidat

; 5675 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@xmlValidat:

; 104  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	xor	edx, edx
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN37@xmlValidat

; 105  :         channel = ctxt->error;
; 106  :         data = ctxt->userData;
; 107  : 	/* Use the special values to detect if it is part of a parsing
; 108  : 	   context */
; 109  : 	if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||

	mov	edi, DWORD PTR [eax+28]
	mov	esi, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	cmp	edi, -1412623820			; abcd1234H
	je	SHORT $LN36@xmlValidat
	cmp	edi, -1412623819			; abcd1235H
	jne	SHORT $LN37@xmlValidat
$LN36@xmlValidat:

; 110  : 	    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {
; 111  : 	    long delta = (char *) ctxt - (char *) ctxt->userData;

	sub	eax, ecx

; 112  : 	    if ((delta > 0) && (delta < 250))

	dec	eax
	cmp	eax, 248				; 000000f8H
	cmovbe	edx, ecx
$LN37@xmlValidat:

; 113  : 		pctxt = ctxt->userData;
; 114  : 	}
; 115  :     }
; 116  :     if (extra)
; 117  :         __xmlRaiseError(NULL, channel, data,
; 118  :                         pctxt, NULL, XML_FROM_VALID, error,
; 119  :                         XML_ERR_ERROR, NULL, 0, extra, NULL, NULL, 0, 0,
; 120  :                         msg, extra);
; 121  :     else
; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0CC@LMJFIFCG@Internal?3?5MIXED?5struct?5corrupte@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	519					; 00000207H
	push	23					; 00000017H
	push	0
	push	edx
	push	ecx
	push	esi

; 5672 : 	}
; 5673 :     }
; 5674 :     return(0);

	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN39@xmlValidat:

; 5675 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidateCheckMixed ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateOneCdataElement
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_elem$ = 16						; size = 4
_xmlValidateOneCdataElement PROC			; COMDAT

; 5556 :                            xmlNodePtr elem) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ebx, 1
	test	esi, esi
	je	$LN9@xmlValidat

; 5557 :     int ret = 1;
; 5558 :     xmlNodePtr cur, child;
; 5559 : 
; 5560 :     if ((ctxt == NULL) || (doc == NULL) || (elem == NULL) ||

	cmp	DWORD PTR _doc$[ebp], 0
	je	$LN9@xmlValidat
	mov	edi, DWORD PTR _elem$[ebp]
	test	edi, edi
	je	$LN9@xmlValidat
	cmp	DWORD PTR [edi+4], ebx
	jne	$LN9@xmlValidat

; 5561 :         (elem->type != XML_ELEMENT_NODE))
; 5562 : 	return(0);
; 5563 : 
; 5564 :     child = elem->children;
; 5565 : 
; 5566 :     cur = child;

	mov	edi, DWORD PTR [edi+12]

; 5567 :     while (cur != NULL) {

	test	edi, edi
	je	SHORT $done$36
$LL2@xmlValidat:

; 5568 : 	switch (cur->type) {

	mov	eax, DWORD PTR [edi+4]
	add	eax, -3					; fffffffdH
	cmp	eax, 5
	ja	SHORT $LN13@xmlValidat
	jmp	DWORD PTR $LN35@xmlValidat[eax*4]
$LN10@xmlValidat:

; 5569 : 	    case XML_ENTITY_REF_NODE:
; 5570 : 		/*
; 5571 : 		 * Push the current node to be able to roll back
; 5572 : 		 * and process within the entity
; 5573 : 		 */
; 5574 : 		if ((cur->children != NULL) &&

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN11@xmlValidat
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN11@xmlValidat

; 5575 : 		    (cur->children->children != NULL)) {
; 5576 : 		    nodeVPush(ctxt, cur);

	push	edi
	push	esi
	call	_nodeVPush

; 5577 : 		    cur = cur->children->children;

	mov	eax, DWORD PTR [edi+12]
	add	esp, 8
	mov	edi, DWORD PTR [eax+12]
	test	edi, edi
	jne	SHORT $LL2@xmlValidat

; 5567 :     while (cur != NULL) {

	jmp	SHORT $done$36
$LN11@xmlValidat:

; 5588 : 		goto done;
; 5589 : 	}
; 5590 : 	/*
; 5591 : 	 * Switch to next element
; 5592 : 	 */
; 5593 : 	cur = cur->next;

	mov	edi, DWORD PTR [edi+24]

; 5594 : 	while (cur == NULL) {

	test	edi, edi
	jne	SHORT $LL2@xmlValidat
$LL6@xmlValidat:

; 470  :     if (ctxt->nodeNr <= 0)

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	jle	SHORT $done$36

; 471  :         return (NULL);
; 472  :     ctxt->nodeNr--;

	dec	ecx
	mov	DWORD PTR [esi+16], ecx

; 473  :     if (ctxt->nodeNr > 0)

	test	ecx, ecx
	jle	SHORT $LN19@xmlValidat

; 474  :         ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];

	mov	eax, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN20@xmlValidat
$LN19@xmlValidat:

; 475  :     else
; 476  :         ctxt->node = NULL;

	xor	eax, eax
$LN20@xmlValidat:

; 477  :     ret = ctxt->nodeTab[ctxt->nodeNr];

	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [eax+ecx*4]

; 478  :     ctxt->nodeTab[ctxt->nodeNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 5595 : 	    cur = nodeVPop(ctxt);
; 5596 : 	    if (cur == NULL)

	test	edi, edi
	je	SHORT $done$36

; 5597 : 		break;
; 5598 : 	    cur = cur->next;

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	je	SHORT $LL6@xmlValidat

; 5567 :     while (cur != NULL) {

	jmp	SHORT $LL2@xmlValidat
$LN13@xmlValidat:

; 5578 : 		    continue;
; 5579 : 		}
; 5580 : 		break;
; 5581 : 	    case XML_COMMENT_NODE:
; 5582 : 	    case XML_PI_NODE:
; 5583 : 	    case XML_TEXT_NODE:
; 5584 : 	    case XML_CDATA_SECTION_NODE:
; 5585 : 		break;
; 5586 : 	    default:
; 5587 : 		ret = 0;

	xor	ebx, ebx
$done$36:

; 5599 : 	}
; 5600 :     }
; 5601 : done:
; 5602 :     ctxt->nodeMax = 0;
; 5603 :     ctxt->nodeNr = 0;
; 5604 :     if (ctxt->nodeTab != NULL) {

	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+16], 0
	test	ecx, ecx
	je	SHORT $LN15@xmlValidat

; 5605 : 	xmlFree(ctxt->nodeTab);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 5606 : 	ctxt->nodeTab = NULL;

	mov	DWORD PTR [esi+24], 0
$LN15@xmlValidat:

; 5607 :     }
; 5608 :     return(ret);
; 5609 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlValidat:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
	npad	2
$LN35@xmlValidat:
	DD	$LN11@xmlValidat
	DD	$LN11@xmlValidat
	DD	$LN10@xmlValidat
	DD	$LN13@xmlValidat
	DD	$LN11@xmlValidat
	DD	$LN11@xmlValidat
_xmlValidateOneCdataElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateElementContent
_TEXT	SEGMENT
_expr$1 = -10060					; size = 5000
_list$2 = -5060						; size = 5000
_fn$3 = -60						; size = 50
_name$1$ = -8						; size = 4
_cont$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_child$ = 12						; size = 4
_exec$1$ = 16						; size = 4
_elemDecl$ = 16						; size = 4
_warn$ = 20						; size = 4
_parent$ = 24						; size = 4
_xmlValidateElementContent PROC				; COMDAT

; 5270 :        xmlElementPtr elemDecl, int warn, xmlNodePtr parent) {

	push	ebp
	mov	ebp, esp
	mov	eax, 10060				; 0000274cH
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _elemDecl$[ebp]
	mov	edi, 1
	test	ebx, ebx
	je	$LN9@xmlValidat

; 5271 :     int ret = 1;
; 5272 : #ifndef  LIBXML_REGEXP_ENABLED
; 5273 :     xmlNodePtr repl = NULL, last = NULL, tmp;
; 5274 : #endif
; 5275 :     xmlNodePtr cur;
; 5276 :     xmlElementContentPtr cont;
; 5277 :     const xmlChar *name;
; 5278 : 
; 5279 :     if ((elemDecl == NULL) || (parent == NULL) || (ctxt == NULL))

	cmp	DWORD PTR _parent$[ebp], 0
	je	$LN9@xmlValidat
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN9@xmlValidat

; 5280 : 	return(-1);
; 5281 :     cont = elemDecl->content;

	mov	eax, DWORD PTR [ebx+40]
	mov	DWORD PTR _cont$1$[ebp], eax

; 5282 :     name = elemDecl->name;

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR _name$1$[ebp], eax

; 5283 : 
; 5284 : #ifdef LIBXML_REGEXP_ENABLED
; 5285 :     /* Build the regexp associated to the content model */
; 5286 :     if (elemDecl->contModel == NULL)

	mov	eax, DWORD PTR [ebx+52]
	test	eax, eax
	jne	SHORT $LN59@xmlValidat

; 5287 : 	ret = xmlValidBuildContentModel(ctxt, elemDecl);

	push	ebx
	push	esi
	call	_xmlValidBuildContentModel
	mov	edi, eax
	add	esp, 8
	mov	eax, DWORD PTR [ebx+52]

; 5288 :     if (elemDecl->contModel == NULL) {

	test	eax, eax
	je	$LN9@xmlValidat
$LN59@xmlValidat:

; 5289 : 	return(-1);
; 5290 :     } else {
; 5291 : 	xmlRegExecCtxtPtr exec;
; 5292 : 
; 5293 : 	if (!xmlRegexpIsDeterminist(elemDecl->contModel)) {

	push	eax
	call	_xmlRegexpIsDeterminist
	add	esp, 4
	test	eax, eax
	je	$LN9@xmlValidat

; 5294 : 	    return(-1);
; 5295 : 	}
; 5296 : 	ctxt->nodeMax = 0;
; 5297 : 	ctxt->nodeNr = 0;
; 5298 : 	ctxt->nodeTab = NULL;
; 5299 : 	exec = xmlRegNewExecCtxt(elemDecl->contModel, NULL, NULL);

	push	0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+24], 0
	push	0
	push	DWORD PTR [ebx+52]
	call	_xmlRegNewExecCtxt
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 5300 : 	if (exec != NULL) {

	mov	eax, DWORD PTR _child$[ebp]
	mov	DWORD PTR _exec$1$[ebp], ebx
	test	ebx, ebx
	je	SHORT $LN14@xmlValidat

; 5301 : 	    cur = child;

	mov	edi, eax

; 5302 : 	    while (cur != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlValidat
$LL2@xmlValidat:

; 5303 : 		switch (cur->type) {

	mov	eax, DWORD PTR [edi+4]
	dec	eax
	cmp	eax, 4
	ja	$LN22@xmlValidat
	jmp	DWORD PTR $LN61@xmlValidat[eax*4]
$LN15@xmlValidat:

; 5304 : 		    case XML_ENTITY_REF_NODE:
; 5305 : 			/*
; 5306 : 			 * Push the current node to be able to roll back
; 5307 : 			 * and process within the entity
; 5308 : 			 */
; 5309 : 			if ((cur->children != NULL) &&

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	$LN22@xmlValidat
	cmp	DWORD PTR [eax+12], 0
	je	$LN22@xmlValidat

; 5310 : 			    (cur->children->children != NULL)) {
; 5311 : 			    nodeVPush(ctxt, cur);

	push	edi
	push	esi
	call	_nodeVPush

; 5312 : 			    cur = cur->children->children;

	mov	eax, DWORD PTR [edi+12]
	add	esp, 8
	mov	edi, DWORD PTR [eax+12]
	test	edi, edi
	jne	SHORT $LL2@xmlValidat
$LN3@xmlValidat:

; 5355 : 		}
; 5356 : 	    }
; 5357 : 	    ret = xmlRegExecPushString(exec, NULL, NULL);

	push	0
	push	0
	push	ebx
	call	_xmlRegExecPushString
	add	esp, 12					; 0000000cH
	mov	edi, eax
$fail$62:

; 5358 : fail:
; 5359 : 	    xmlRegFreeExecCtxt(exec);

	push	ebx
	call	_xmlRegFreeExecCtxt
	add	esp, 4
$LN14@xmlValidat:

; 5360 : 	}
; 5361 :     }
; 5362 : #else  /* LIBXML_REGEXP_ENABLED */
; 5363 :     /*
; 5364 :      * Allocate the stack
; 5365 :      */
; 5366 :     ctxt->vstateMax = 8;
; 5367 :     ctxt->vstateTab = (xmlValidState *) xmlMalloc(
; 5368 : 		 ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));
; 5369 :     if (ctxt->vstateTab == NULL) {
; 5370 : 	xmlVErrMemory(ctxt, "malloc failed");
; 5371 : 	return(-1);
; 5372 :     }
; 5373 :     /*
; 5374 :      * The first entry in the stack is reserved to the current state
; 5375 :      */
; 5376 :     ctxt->nodeMax = 0;
; 5377 :     ctxt->nodeNr = 0;
; 5378 :     ctxt->nodeTab = NULL;
; 5379 :     ctxt->vstate = &ctxt->vstateTab[0];
; 5380 :     ctxt->vstateNr = 1;
; 5381 :     CONT = cont;
; 5382 :     NODE = child;
; 5383 :     DEPTH = 0;
; 5384 :     OCCURS = 0;
; 5385 :     STATE = 0;
; 5386 :     ret = xmlValidateElementType(ctxt);
; 5387 :     if ((ret == -3) && (warn)) {
; 5388 : 	xmlErrValidWarning(ctxt, child, XML_DTD_CONTENT_NOT_DETERMINIST,
; 5389 : 	       "Content model for Element %s is ambiguous\n",
; 5390 : 	                   name, NULL, NULL);
; 5391 :     } else if (ret == -2) {
; 5392 : 	/*
; 5393 : 	 * An entities reference appeared at this level.
; 5394 : 	 * Buid a minimal representation of this node content
; 5395 : 	 * sufficient to run the validation process on it
; 5396 : 	 */
; 5397 : 	DEBUG_VALID_MSG("Found an entity reference, linearizing");
; 5398 : 	cur = child;
; 5399 : 	while (cur != NULL) {
; 5400 : 	    switch (cur->type) {
; 5401 : 		case XML_ENTITY_REF_NODE:
; 5402 : 		    /*
; 5403 : 		     * Push the current node to be able to roll back
; 5404 : 		     * and process within the entity
; 5405 : 		     */
; 5406 : 		    if ((cur->children != NULL) &&
; 5407 : 			(cur->children->children != NULL)) {
; 5408 : 			nodeVPush(ctxt, cur);
; 5409 : 			cur = cur->children->children;
; 5410 : 			continue;
; 5411 : 		    }
; 5412 : 		    break;
; 5413 : 		case XML_TEXT_NODE:
; 5414 : 		    if (xmlIsBlankNode(cur))
; 5415 : 			break;
; 5416 : 		    /* no break on purpose */
; 5417 : 		case XML_CDATA_SECTION_NODE:
; 5418 : 		    /* no break on purpose */
; 5419 : 		case XML_ELEMENT_NODE:
; 5420 : 		    /*
; 5421 : 		     * Allocate a new node and minimally fills in
; 5422 : 		     * what's required
; 5423 : 		     */
; 5424 : 		    tmp = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
; 5425 : 		    if (tmp == NULL) {
; 5426 : 			xmlVErrMemory(ctxt, "malloc failed");
; 5427 : 			xmlFreeNodeList(repl);
; 5428 : 			ret = -1;
; 5429 : 			goto done;
; 5430 : 		    }
; 5431 : 		    tmp->type = cur->type;
; 5432 : 		    tmp->name = cur->name;
; 5433 : 		    tmp->ns = cur->ns;
; 5434 : 		    tmp->next = NULL;
; 5435 : 		    tmp->content = NULL;
; 5436 : 		    if (repl == NULL)
; 5437 : 			repl = last = tmp;
; 5438 : 		    else {
; 5439 : 			last->next = tmp;
; 5440 : 			last = tmp;
; 5441 : 		    }
; 5442 : 		    if (cur->type == XML_CDATA_SECTION_NODE) {
; 5443 : 			/*
; 5444 : 			 * E59 spaces in CDATA does not match the
; 5445 : 			 * nonterminal S
; 5446 : 			 */
; 5447 : 			tmp->content = xmlStrdup(BAD_CAST "CDATA");
; 5448 : 		    }
; 5449 : 		    break;
; 5450 : 		default:
; 5451 : 		    break;
; 5452 : 	    }
; 5453 : 	    /*
; 5454 : 	     * Switch to next element
; 5455 : 	     */
; 5456 : 	    cur = cur->next;
; 5457 : 	    while (cur == NULL) {
; 5458 : 		cur = nodeVPop(ctxt);
; 5459 : 		if (cur == NULL)
; 5460 : 		    break;
; 5461 : 		cur = cur->next;
; 5462 : 	    }
; 5463 : 	}
; 5464 : 
; 5465 : 	/*
; 5466 : 	 * Relaunch the validation
; 5467 : 	 */
; 5468 : 	ctxt->vstate = &ctxt->vstateTab[0];
; 5469 : 	ctxt->vstateNr = 1;
; 5470 : 	CONT = cont;
; 5471 : 	NODE = repl;
; 5472 : 	DEPTH = 0;
; 5473 : 	OCCURS = 0;
; 5474 : 	STATE = 0;
; 5475 : 	ret = xmlValidateElementType(ctxt);
; 5476 :     }
; 5477 : #endif /* LIBXML_REGEXP_ENABLED */
; 5478 :     if ((warn) && ((ret != 1) && (ret != -3))) {

	cmp	DWORD PTR _warn$[ebp], 0
	je	$LN27@xmlValidat
	cmp	edi, 1
	je	$LN27@xmlValidat
	cmp	edi, -3					; fffffffdH
	je	$LN52@xmlValidat

; 5479 : 	if (ctxt != NULL) {
; 5480 : 	    char expr[5000];
; 5481 : 	    char list[5000];
; 5482 : 
; 5483 : 	    expr[0] = 0;
; 5484 : 	    xmlSnprintfElementContent(&expr[0], 5000, cont, 1);

	push	1
	push	DWORD PTR _cont$1$[ebp]
	lea	eax, DWORD PTR _expr$1[ebp]
	mov	BYTE PTR _expr$1[ebp], 0
	push	5000					; 00001388H
	push	eax
	call	_xmlSnprintfElementContent

; 5485 : 	    list[0] = 0;
; 5486 : #ifndef LIBXML_REGEXP_ENABLED
; 5487 : 	    if (repl != NULL)
; 5488 : 		xmlSnprintfElements(&list[0], 5000, repl, 1);
; 5489 : 	    else
; 5490 : #endif /* LIBXML_REGEXP_ENABLED */
; 5491 : 		xmlSnprintfElements(&list[0], 5000, child, 1);

	push	1
	push	DWORD PTR _child$[ebp]
	lea	eax, DWORD PTR _list$2[ebp]
	mov	BYTE PTR _list$2[ebp], 0
	push	5000					; 00001388H
	push	eax
	call	_xmlSnprintfElements

; 5492 : 
; 5493 : 	    if (name != NULL) {

	mov	edx, DWORD PTR _name$1$[ebp]
	lea	ecx, DWORD PTR _expr$1[ebp]
	test	edx, edx

; 5494 : 		xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,
; 5495 : 	   "Element %s content does not follow the DTD, expecting %s, got %s\n",
; 5496 : 		       name, BAD_CAST expr, BAD_CAST list);
; 5497 : 	    } else {
; 5498 : 		xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,
; 5499 : 	   "Element content does not follow the DTD, expecting %s, got %s\n",
; 5500 : 		       BAD_CAST expr, BAD_CAST list, NULL);
; 5501 : 	    }
; 5502 : 	} else {

	lea	eax, DWORD PTR _list$2[ebp]
	cmovne	ecx, edx
	xor	edi, edi
	test	edx, edx
	cmove	eax, edi
	lea	edi, DWORD PTR _expr$1[ebp]
	push	eax
	lea	eax, DWORD PTR _list$2[ebp]
	cmovne	eax, edi
	push	eax
	push	ecx
	mov	ecx, OFFSET ??_C@_0EC@IAKGOMPC@Element?5?$CFs?5content?5does?5not?5fol@
	mov	eax, OFFSET ??_C@_0DP@CBELDNAH@Element?5content?5does?5not?5follow@
	cmovne	eax, ecx
	push	eax
	push	504					; 000001f8H
	push	DWORD PTR _parent$[ebp]
	push	esi
	call	_xmlErrValidNode
	add	esp, 60					; 0000003cH

; 5503 : 	    if (name != NULL) {
; 5504 : 		xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,
; 5505 : 		       "Element %s content does not follow the DTD\n",
; 5506 : 		       name, NULL, NULL);
; 5507 : 	    } else {
; 5508 : 		xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,
; 5509 : 		       "Element content does not follow the DTD\n",
; 5510 : 		                NULL, NULL, NULL);
; 5511 : 	    }
; 5512 : 	}
; 5513 : 	ret = 0;

	xor	edi, edi

; 5514 :     }
; 5515 :     if (ret == -3)

	jmp	$LN34@xmlValidat
$LN17@xmlValidat:

; 5313 : 			    continue;
; 5314 : 			}
; 5315 : 			break;
; 5316 : 		    case XML_TEXT_NODE:
; 5317 : 			if (xmlIsBlankNode(cur))

	push	edi
	call	_xmlIsBlankNode
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN22@xmlValidat
$LN18@xmlValidat:

; 5358 : fail:
; 5359 : 	    xmlRegFreeExecCtxt(exec);

	xor	edi, edi
	jmp	$fail$62
$LN20@xmlValidat:

; 5318 : 			    break;
; 5319 : 			ret = 0;
; 5320 : 			goto fail;
; 5321 : 		    case XML_CDATA_SECTION_NODE:
; 5322 : 			/* TODO */
; 5323 : 			ret = 0;
; 5324 : 			goto fail;
; 5325 : 		    case XML_ELEMENT_NODE:
; 5326 : 			if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN21@xmlValidat
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN21@xmlValidat

; 5327 : 			    xmlChar fn[50];
; 5328 : 			    xmlChar *fullname;
; 5329 : 
; 5330 : 			    fullname = xmlBuildQName(cur->name,

	push	50					; 00000032H
	lea	ecx, DWORD PTR _fn$3[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [edi+8]
	call	_xmlBuildQName
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 5331 : 				                     cur->ns->prefix, fn, 50);
; 5332 : 			    if (fullname == NULL) {

	test	ebx, ebx
	je	$LN46@xmlValidat

; 5335 : 			    }
; 5336 :                             ret = xmlRegExecPushString(exec, fullname, NULL);

	push	0
	push	ebx
	push	DWORD PTR _exec$1$[ebp]
	call	_xmlRegExecPushString

; 5337 : 			    if ((fullname != fn) && (fullname != cur->name))

	lea	eax, DWORD PTR _fn$3[ebp]
	add	esp, 12					; 0000000cH
	cmp	ebx, eax
	je	SHORT $LN57@xmlValidat
	cmp	ebx, DWORD PTR [edi+8]
	je	SHORT $LN57@xmlValidat

; 5338 : 				xmlFree(fullname);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN57@xmlValidat:

; 5341 : 			}
; 5342 : 			break;
; 5343 : 		    default:
; 5344 : 			break;
; 5345 : 		}
; 5346 : 		/*
; 5347 : 		 * Switch to next element
; 5348 : 		 */
; 5349 : 		cur = cur->next;

	mov	ebx, DWORD PTR _exec$1$[ebp]
$LN22@xmlValidat:
	mov	edi, DWORD PTR [edi+24]

; 5350 : 		while (cur == NULL) {

	test	edi, edi
	jne	$LL2@xmlValidat
	npad	2
$LL6@xmlValidat:

; 470  :     if (ctxt->nodeNr <= 0)

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	jle	$LN3@xmlValidat

; 471  :         return (NULL);
; 472  :     ctxt->nodeNr--;

	dec	ecx
	mov	DWORD PTR [esi+16], ecx

; 473  :     if (ctxt->nodeNr > 0)

	test	ecx, ecx
	jle	SHORT $LN39@xmlValidat

; 474  :         ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];

	mov	eax, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN40@xmlValidat
$LN21@xmlValidat:

; 5339 : 			} else {
; 5340 : 			    ret = xmlRegExecPushString(exec, cur->name, NULL);

	push	0
	push	DWORD PTR [edi+8]
	push	ebx
	call	_xmlRegExecPushString
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN22@xmlValidat
$LN39@xmlValidat:

; 476  :         ctxt->node = NULL;

	xor	eax, eax
$LN40@xmlValidat:

; 477  :     ret = ctxt->nodeTab[ctxt->nodeNr];

	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [eax+ecx*4]

; 478  :     ctxt->nodeTab[ctxt->nodeNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 5351 : 		    cur = nodeVPop(ctxt);
; 5352 : 		    if (cur == NULL)

	test	edi, edi
	je	$LN3@xmlValidat

; 5353 : 			break;
; 5354 : 		    cur = cur->next;

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	je	SHORT $LL6@xmlValidat

; 5302 : 	    while (cur != NULL) {

	jmp	$LL2@xmlValidat
$LN46@xmlValidat:

; 5333 : 				ret = -1;
; 5334 : 				goto fail;

	mov	ebx, DWORD PTR _exec$1$[ebp]
	or	edi, -1
	jmp	$fail$62
$LN27@xmlValidat:

; 5514 :     }
; 5515 :     if (ret == -3)

	cmp	edi, -3					; fffffffdH
	jne	SHORT $LN34@xmlValidat
$LN52@xmlValidat:

; 5516 : 	ret = 1;

	mov	edi, 1
$LN34@xmlValidat:

; 5517 : 
; 5518 : #ifndef  LIBXML_REGEXP_ENABLED
; 5519 : done:
; 5520 :     /*
; 5521 :      * Deallocate the copy if done, and free up the validation stack
; 5522 :      */
; 5523 :     while (repl != NULL) {
; 5524 : 	tmp = repl->next;
; 5525 : 	xmlFree(repl);
; 5526 : 	repl = tmp;
; 5527 :     }
; 5528 :     ctxt->vstateMax = 0;
; 5529 :     if (ctxt->vstateTab != NULL) {
; 5530 : 	xmlFree(ctxt->vstateTab);
; 5531 : 	ctxt->vstateTab = NULL;
; 5532 :     }
; 5533 : #endif
; 5534 :     ctxt->nodeMax = 0;
; 5535 :     ctxt->nodeNr = 0;
; 5536 :     if (ctxt->nodeTab != NULL) {

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+16], 0
	test	eax, eax
	je	SHORT $LN35@xmlValidat

; 5537 : 	xmlFree(ctxt->nodeTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 5538 : 	ctxt->nodeTab = NULL;

	mov	DWORD PTR [esi+24], 0
$LN35@xmlValidat:

; 5539 :     }
; 5540 :     return(ret);

	mov	eax, edi
	pop	edi

; 5541 : 
; 5542 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlValidat:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@xmlValidat:
	DD	$LN20@xmlValidat
	DD	$LN22@xmlValidat
	DD	$LN17@xmlValidat
	DD	$LN18@xmlValidat
	DD	$LN15@xmlValidat
_xmlValidateElementContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlSnprintfElements
_TEXT	SEGMENT
tv447 = -8						; size = 4
_len$1$ = -4						; size = 4
_buf$ = 8						; size = 4
_size$ = 12						; size = 4
_node$ = 16						; size = 4
_glob$ = 20						; size = 4
_xmlSnprintfElements PROC				; COMDAT

; 5181 : xmlSnprintfElements(char *buf, int size, xmlNodePtr node, int glob) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _node$[ebp]
	test	edx, edx
	je	$LN24@xmlSnprint

; 5182 :     xmlNodePtr cur;
; 5183 :     int len;
; 5184 : 
; 5185 :     if (node == NULL) return;
; 5186 :     if (glob) strcat(buf, "(");

	cmp	DWORD PTR _glob$[ebp], 0
	push	ebx
	mov	ebx, DWORD PTR _buf$[ebp]
	push	edi
	je	SHORT $LN52@xmlSnprint
	lea	edi, DWORD PTR [ebx-1]
	npad	7
$LL34@xmlSnprint:
	mov	al, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	test	al, al
	jne	SHORT $LL34@xmlSnprint
	mov	ax, WORD PTR ??_C@_01ODHLEDKK@?$CI@
	mov	WORD PTR [edi], ax
$LN52@xmlSnprint:
	push	esi
$LL2@xmlSnprint:

; 5187 :     cur = node;
; 5188 :     while (cur != NULL) {
; 5189 : 	len = strlen(buf);

	mov	esi, ebx
	lea	ecx, DWORD PTR [esi+1]
	npad	7
$LL35@xmlSnprint:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL35@xmlSnprint

; 5190 : 	if (size - len < 50) {

	mov	edi, DWORD PTR _size$[ebp]
	sub	esi, ecx
	sub	edi, esi
	mov	DWORD PTR _len$1$[ebp], esi
	mov	DWORD PTR tv447[ebp], edi
	cmp	edi, 50					; 00000032H
	jl	$LN27@xmlSnprint

; 5193 : 	    return;
; 5194 : 	}
; 5195 :         switch (cur->type) {

	mov	eax, DWORD PTR [edx+4]
	dec	eax
	cmp	eax, 20					; 00000014H
	ja	$LN22@xmlSnprint
	movzx	eax, BYTE PTR $LN36@xmlSnprint[eax]
	jmp	DWORD PTR $LN74@xmlSnprint[eax*4]
$LN10@xmlSnprint:

; 5196 :             case XML_ELEMENT_NODE:
; 5197 : 		if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [edx+36]
	test	eax, eax
	je	SHORT $LN11@xmlSnprint
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN11@xmlSnprint

; 5198 : 		    if (size - len < xmlStrlen(cur->ns->prefix) + 10) {

	push	eax
	call	_xmlStrlen
	add	eax, 10					; 0000000aH
	add	esp, 4
	cmp	edi, eax
	jl	$LN28@xmlSnprint

; 5202 : 		    }
; 5203 : 		    strcat(buf, (char *) cur->ns->prefix);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR [eax+12]
	mov	esi, edx
$LL37@xmlSnprint:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL37@xmlSnprint
	sub	edx, esi
	lea	edi, DWORD PTR [ebx-1]
$LL38@xmlSnprint:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL38@xmlSnprint
	mov	ecx, edx
	shr	ecx, 2
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb

; 5204 : 		    strcat(buf, ":");

	lea	edi, DWORD PTR [ebx-1]
	npad	6
$LL39@xmlSnprint:
	mov	al, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	test	al, al
	jne	SHORT $LL39@xmlSnprint
	mov	ax, WORD PTR ??_C@_01JLIPDDHJ@?3@
	mov	esi, DWORD PTR _len$1$[ebp]
	mov	edx, DWORD PTR _node$[ebp]
	mov	WORD PTR [edi], ax
	mov	edi, DWORD PTR tv447[ebp]
$LN11@xmlSnprint:

; 5205 : 		}
; 5206 :                 if (size - len < xmlStrlen(cur->name) + 10) {

	push	DWORD PTR [edx+8]
	call	_xmlStrlen
	add	eax, 10					; 0000000aH
	add	esp, 4
	cmp	edi, eax
	jl	$LN29@xmlSnprint

; 5210 : 		}
; 5211 : 	        strcat(buf, (char *) cur->name);

	mov	edx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	esi, edx
	npad	6
$LL40@xmlSnprint:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL40@xmlSnprint
	sub	edx, esi
	lea	edi, DWORD PTR [ebx-1]
	npad	4
$LL41@xmlSnprint:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL41@xmlSnprint
	mov	ecx, edx
	shr	ecx, 2
	rep movsd
	mov	ecx, edx

; 5212 : 		if (cur->next != NULL)

	mov	edx, DWORD PTR _node$[ebp]
	and	ecx, 3
	rep movsb
	cmp	DWORD PTR [edx+24], 0
	je	$LN22@xmlSnprint

; 5213 : 		    strcat(buf, " ");

	lea	edi, DWORD PTR [ebx-1]
$LL42@xmlSnprint:
	mov	al, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	test	al, al
	jne	SHORT $LL42@xmlSnprint

; 5214 : 		break;

	jmp	SHORT $LN72@xmlSnprint
$LN17@xmlSnprint:

; 5215 :             case XML_TEXT_NODE:
; 5216 : 		if (xmlIsBlankNode(cur))

	push	edx
	call	_xmlIsBlankNode
	mov	edx, DWORD PTR _node$[ebp]
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN22@xmlSnprint
$LN18@xmlSnprint:

; 5217 : 		    break;
; 5218 :                 /* Falls through. */
; 5219 :             case XML_CDATA_SECTION_NODE:
; 5220 :             case XML_ENTITY_REF_NODE:
; 5221 : 	        strcat(buf, "CDATA");

	lea	ecx, DWORD PTR [ebx-1]
$LL43@xmlSnprint:
	mov	al, BYTE PTR [ecx+1]
	lea	ecx, DWORD PTR [ecx+1]
	test	al, al
	jne	SHORT $LL43@xmlSnprint
	mov	eax, DWORD PTR ??_C@_05MLPNBPGH@CDATA@
	mov	DWORD PTR [ecx], eax
	mov	ax, WORD PTR ??_C@_05MLPNBPGH@CDATA@+4
	mov	WORD PTR [ecx+4], ax

; 5222 : 		if (cur->next != NULL)

	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN22@xmlSnprint

; 5223 : 		    strcat(buf, " ");

	lea	edi, DWORD PTR [ebx-1]
	npad	7
$LL44@xmlSnprint:
	mov	al, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	test	al, al
	jne	SHORT $LL44@xmlSnprint

; 5224 : 		break;

	jmp	SHORT $LN72@xmlSnprint
$LN21@xmlSnprint:

; 5225 :             case XML_ATTRIBUTE_NODE:
; 5226 :             case XML_DOCUMENT_NODE:
; 5227 : #ifdef LIBXML_DOCB_ENABLED
; 5228 : 	    case XML_DOCB_DOCUMENT_NODE:
; 5229 : #endif
; 5230 : 	    case XML_HTML_DOCUMENT_NODE:
; 5231 :             case XML_DOCUMENT_TYPE_NODE:
; 5232 :             case XML_DOCUMENT_FRAG_NODE:
; 5233 :             case XML_NOTATION_NODE:
; 5234 : 	    case XML_NAMESPACE_DECL:
; 5235 : 	        strcat(buf, "???");

	lea	edi, DWORD PTR [ebx-1]
	npad	1
$LL45@xmlSnprint:
	mov	al, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	test	al, al
	jne	SHORT $LL45@xmlSnprint
	mov	eax, DWORD PTR ??_C@_03BBKEAIF@?$DP?$DP?$DP@
	mov	DWORD PTR [edi], eax

; 5236 : 		if (cur->next != NULL)

	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN22@xmlSnprint

; 5237 : 		    strcat(buf, " ");

	lea	edi, DWORD PTR [ebx-1]
	npad	6
$LL46@xmlSnprint:
	mov	al, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	test	al, al
	jne	SHORT $LL46@xmlSnprint
$LN72@xmlSnprint:

; 5238 : 		break;
; 5239 :             case XML_ENTITY_NODE:
; 5240 :             case XML_PI_NODE:
; 5241 :             case XML_DTD_NODE:
; 5242 :             case XML_COMMENT_NODE:
; 5243 : 	    case XML_ELEMENT_DECL:
; 5244 : 	    case XML_ATTRIBUTE_DECL:
; 5245 : 	    case XML_ENTITY_DECL:
; 5246 : 	    case XML_XINCLUDE_START:
; 5247 : 	    case XML_XINCLUDE_END:
; 5248 : 		break;
; 5249 : 	}
; 5250 : 	cur = cur->next;

	mov	ax, WORD PTR ??_C@_01CLKCMJKC@?5@
	mov	WORD PTR [edi], ax
$LN22@xmlSnprint:
	mov	edx, DWORD PTR [edx+24]
	mov	DWORD PTR _node$[ebp], edx
	test	edx, edx
	jne	$LL2@xmlSnprint

; 5251 :     }
; 5252 :     if (glob) strcat(buf, ")");

	cmp	DWORD PTR _glob$[ebp], edx
	je	$LN70@xmlSnprint
	dec	ebx
	npad	5
$LL49@xmlSnprint:
	mov	al, BYTE PTR [ebx+1]
	inc	ebx
	test	al, al
	jne	SHORT $LL49@xmlSnprint
	mov	ax, WORD PTR ??_C@_01PKGAHCOL@?$CJ@
	mov	edi, ebx
	pop	esi
	mov	WORD PTR [edi], ax
	pop	edi
	pop	ebx

; 5253 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlSnprint:

; 5199 : 			if ((size - len > 4) && (buf[len - 1] != '.'))

	cmp	edi, 4
	jle	SHORT $LN70@xmlSnprint
	cmp	BYTE PTR [esi+ebx-1], 46		; 0000002eH
	je	SHORT $LN70@xmlSnprint

; 5200 : 			    strcat(buf, " ...");

	dec	ebx
$LL47@xmlSnprint:
	mov	al, BYTE PTR [ebx+1]
	lea	ebx, DWORD PTR [ebx+1]
	test	al, al
	jne	SHORT $LL47@xmlSnprint

; 5201 : 			return;

	jmp	SHORT $LN71@xmlSnprint
$LN29@xmlSnprint:

; 5207 : 		    if ((size - len > 4) && (buf[len - 1] != '.'))

	cmp	edi, 4
	jle	SHORT $LN70@xmlSnprint
	cmp	BYTE PTR [esi+ebx-1], 46		; 0000002eH
	je	SHORT $LN70@xmlSnprint

; 5208 : 			strcat(buf, " ...");

	dec	ebx
$LL48@xmlSnprint:
	mov	al, BYTE PTR [ebx+1]
	lea	ebx, DWORD PTR [ebx+1]
	test	al, al
	jne	SHORT $LL48@xmlSnprint

; 5209 : 		    return;

	jmp	SHORT $LN71@xmlSnprint
$LN27@xmlSnprint:

; 5191 : 	    if ((size - len > 4) && (buf[len - 1] != '.'))

	cmp	edi, 4
	jle	SHORT $LN70@xmlSnprint
	cmp	BYTE PTR [esi+ebx-1], 46		; 0000002eH
	je	SHORT $LN70@xmlSnprint

; 5192 : 		strcat(buf, " ...");

	dec	ebx
	npad	7
$LL50@xmlSnprint:
	mov	al, BYTE PTR [ebx+1]
	lea	ebx, DWORD PTR [ebx+1]
	test	al, al
	jne	SHORT $LL50@xmlSnprint
$LN71@xmlSnprint:
	mov	eax, DWORD PTR ??_C@_04IBCFJNCN@?5?4?4?4@
	mov	DWORD PTR [ebx], eax
	mov	al, BYTE PTR ??_C@_04IBCFJNCN@?5?4?4?4@+4
	mov	BYTE PTR [ebx+4], al
$LN70@xmlSnprint:
	pop	esi
	pop	edi
	pop	ebx
$LN24@xmlSnprint:

; 5253 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@xmlSnprint:
	DD	$LN10@xmlSnprint
	DD	$LN21@xmlSnprint
	DD	$LN17@xmlSnprint
	DD	$LN18@xmlSnprint
	DD	$LN22@xmlSnprint
$LN36@xmlSnprint:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	3
	DB	4
	DB	4
	DB	4
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	1
_xmlSnprintfElements ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateAttributeIdCallback
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlValidateAttributeIdCallback PROC			; COMDAT

; 4123 : 	                       const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _payload$[ebp]
	cmp	DWORD PTR [eax+40], 2
	jne	SHORT $LN2@xmlValidat

; 4124 :     xmlAttributePtr attr = (xmlAttributePtr) payload;
; 4125 :     int *count = (int *) data;
; 4126 :     if (attr->atype == XML_ATTRIBUTE_ID) (*count)++;

	mov	eax, DWORD PTR _data$[ebp]
	inc	DWORD PTR [eax]
$LN2@xmlValidat:

; 4127 : }

	pop	ebp
	ret	0
_xmlValidateAttributeIdCallback ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateAttributeValue2
_TEXT	SEGMENT
_ret$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_name$ = 16						; size = 4
_dup$1$ = 20						; size = 4
_type$ = 20						; size = 4
_value$ = 24						; size = 4
_xmlValidateAttributeValue2 PROC			; COMDAT

; 3871 :       const xmlChar *name, xmlAttributeType type, const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR _ret$1$[ebp], 1
	sub	eax, 5
	je	$LN11@xmlValidat

; 3872 :     int ret = 1;
; 3873 :     switch (type) {

	sub	eax, 1
	je	SHORT $LN16@xmlValidat
	sub	eax, 4
	jne	$LN59@xmlValidat

; 3940 : 	}
; 3941 : 	case XML_ATTRIBUTE_NOTATION: {
; 3942 : 	    xmlNotationPtr nota;
; 3943 : 
; 3944 : 	    nota = xmlGetDtdNotationDesc(doc->intSubset, value);

	mov	esi, DWORD PTR _doc$[ebp]

; 3360 :     if (dtd == NULL) return(NULL);

	mov	edi, DWORD PTR _value$[ebp]

; 3940 : 	}
; 3941 : 	case XML_ATTRIBUTE_NOTATION: {
; 3942 : 	    xmlNotationPtr nota;
; 3943 : 
; 3944 : 	    nota = xmlGetDtdNotationDesc(doc->intSubset, value);

	mov	eax, DWORD PTR [esi+44]

; 3360 :     if (dtd == NULL) return(NULL);

	test	eax, eax
	je	SHORT $LN45@xmlValidat

; 3361 :     if (dtd->notations == NULL) return(NULL);

	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	SHORT $LN45@xmlValidat

; 3362 :     table = (xmlNotationTablePtr) dtd->notations;
; 3363 : 
; 3364 :     return(xmlHashLookup(table, name));

	push	edi
	push	eax
	call	_xmlHashLookup
	add	esp, 8

; 3945 : 	    if ((nota == NULL) && (doc->extSubset != NULL))

	test	eax, eax
	jne	$LN59@xmlValidat
$LN45@xmlValidat:
	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN46@xmlValidat

; 3946 : 		nota = xmlGetDtdNotationDesc(doc->extSubset, value);

	push	edi
	push	eax
	call	_xmlGetDtdNotationDesc
	add	esp, 8

; 3947 : 
; 3948 : 	    if (nota == NULL) {

	test	eax, eax
	jne	$LN59@xmlValidat
$LN46@xmlValidat:

; 3949 : 		xmlErrValidNode(ctxt, (xmlNodePtr) doc,

	push	0
	push	edi
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0DK@HMAANMLE@NOTATION?5attribute?5?$CFs?5reference@
	push	537					; 00000219H
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 3950 : 		                XML_DTD_UNKNOWN_NOTATION,
; 3951 :        "NOTATION attribute %s reference an unknown notation \"%s\"\n",
; 3952 : 		       name, value, NULL);
; 3953 : 		ret = 0;

	xor	eax, eax
	pop	edi

; 3954 : 	    }
; 3955 : 	    break;
; 3956 :         }
; 3957 :     }
; 3958 :     return(ret);
; 3959 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlValidat:

; 3903 : 	    }
; 3904 : 	    break;
; 3905 :         }
; 3906 : 	case XML_ATTRIBUTE_ENTITIES: {
; 3907 : 	    xmlChar *dup, *nam = NULL, *cur, save;
; 3908 : 	    xmlEntityPtr ent;
; 3909 : 
; 3910 : 	    dup = xmlStrdup(value);

	push	DWORD PTR _value$[ebp]
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _dup$1$[ebp], eax

; 3911 : 	    if (dup == NULL)

	test	eax, eax
	je	$LN62@xmlValidat

; 3912 : 		return(0);
; 3913 : 	    cur = dup;
; 3914 : 	    while (*cur != 0) {

	push	ebx
	mov	bl, BYTE PTR [eax]
	mov	esi, eax
	test	bl, bl
	je	$LN53@xmlValidat
$LL4@xmlValidat:

; 3915 : 		nam = cur;

	mov	edi, esi

; 3916 : 		while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;

	test	bl, bl
	je	SHORT $LN54@xmlValidat
	mov	al, bl
	npad	1
$LL6@xmlValidat:
	mov	bl, al
	cmp	al, 32					; 00000020H
	je	SHORT $LN54@xmlValidat
	cmp	al, 9
	jb	SHORT $LN18@xmlValidat
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN54@xmlValidat
$LN18@xmlValidat:
	mov	bl, al
	cmp	al, 13					; 0000000dH
	je	SHORT $LN54@xmlValidat
	mov	bl, BYTE PTR [esi+1]
	inc	esi
	mov	al, bl
	test	bl, bl
	jne	SHORT $LL6@xmlValidat
$LN54@xmlValidat:

; 3917 : 		save = *cur;
; 3918 : 		*cur = 0;
; 3919 : 		ent = xmlGetDocEntity(doc, nam);

	push	edi
	push	DWORD PTR _doc$[ebp]
	mov	BYTE PTR [esi], 0
	call	_xmlGetDocEntity
	add	esp, 8

; 3920 : 		if (ent == NULL) {

	test	eax, eax
	jne	SHORT $LN19@xmlValidat

; 3921 : 		    xmlErrValidNode(ctxt, (xmlNodePtr) doc,

	push	eax
	push	edi
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0DI@MOCJGONA@ENTITIES?5attribute?5?$CFs?5reference@
	push	535					; 00000217H

; 3922 : 				    XML_DTD_UNKNOWN_ENTITY,
; 3923 :        "ENTITIES attribute %s reference an unknown entity \"%s\"\n",
; 3924 : 			   name, nam, NULL);
; 3925 : 		    ret = 0;

	jmp	SHORT $LN60@xmlValidat
$LN19@xmlValidat:

; 3926 : 		} else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {

	cmp	DWORD PTR [eax+48], 3
	je	SHORT $LN21@xmlValidat

; 3927 : 		    xmlErrValidNode(ctxt, (xmlNodePtr) doc,

	push	0
	push	edi
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0DO@BNHKOEGN@ENTITIES?5attribute?5?$CFs?5reference@
	push	511					; 000001ffH
$LN60@xmlValidat:

; 3928 : 				    XML_DTD_ENTITY_TYPE,
; 3929 :        "ENTITIES attribute %s reference an entity \"%s\" of wrong type\n",
; 3930 : 			   name, nam, NULL);
; 3931 : 		    ret = 0;
; 3932 : 		}
; 3933 : 		if (save == 0)

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	mov	DWORD PTR _ret$1$[ebp], 0
	add	esp, 28					; 0000001cH
$LN21@xmlValidat:
	test	bl, bl
	je	SHORT $LN55@xmlValidat

; 3934 : 		    break;
; 3935 : 		*cur = save;

	mov	BYTE PTR [esi], bl
$LL8@xmlValidat:

; 3936 : 		while (IS_BLANK_CH(*cur)) cur++;

	cmp	bl, 32					; 00000020H
	je	SHORT $LN23@xmlValidat
	cmp	bl, 9
	jb	SHORT $LN24@xmlValidat
	cmp	bl, 10					; 0000000aH
	jbe	SHORT $LN23@xmlValidat
$LN24@xmlValidat:
	cmp	bl, 13					; 0000000dH
	jne	SHORT $LN9@xmlValidat
$LN23@xmlValidat:
	mov	bl, BYTE PTR [esi+1]
	inc	esi
	jmp	SHORT $LL8@xmlValidat
$LN9@xmlValidat:

; 3912 : 		return(0);
; 3913 : 	    cur = dup;
; 3914 : 	    while (*cur != 0) {

	test	bl, bl
	jne	$LL4@xmlValidat
$LN55@xmlValidat:
	mov	eax, DWORD PTR _dup$1$[ebp]
$LN53@xmlValidat:

; 3937 : 	    }
; 3938 : 	    xmlFree(dup);

	push	eax
	call	DWORD PTR _xmlFree

; 3939 : 	    break;

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 4
	pop	ebx
	pop	edi

; 3954 : 	    }
; 3955 : 	    break;
; 3956 :         }
; 3957 :     }
; 3958 :     return(ret);
; 3959 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlValidat:

; 3874 : 	case XML_ATTRIBUTE_IDREFS:
; 3875 : 	case XML_ATTRIBUTE_IDREF:
; 3876 : 	case XML_ATTRIBUTE_ID:
; 3877 : 	case XML_ATTRIBUTE_NMTOKENS:
; 3878 : 	case XML_ATTRIBUTE_ENUMERATION:
; 3879 : 	case XML_ATTRIBUTE_NMTOKEN:
; 3880 :         case XML_ATTRIBUTE_CDATA:
; 3881 : 	    break;
; 3882 : 	case XML_ATTRIBUTE_ENTITY: {
; 3883 : 	    xmlEntityPtr ent;
; 3884 : 
; 3885 : 	    ent = xmlGetDocEntity(doc, value);

	mov	edi, DWORD PTR _value$[ebp]
	mov	esi, DWORD PTR _doc$[ebp]
	push	edi
	push	esi
	call	_xmlGetDocEntity
	add	esp, 8

; 3886 : 	    /* yeah it's a bit messy... */
; 3887 : 	    if ((ent == NULL) && (doc->standalone == 1)) {

	test	eax, eax
	jne	SHORT $LN13@xmlValidat
	cmp	DWORD PTR [esi+40], 1
	jne	SHORT $LN47@xmlValidat

; 3888 : 		doc->standalone = 0;
; 3889 : 		ent = xmlGetDocEntity(doc, value);

	push	edi
	push	esi
	mov	DWORD PTR [esi+40], eax
	call	_xmlGetDocEntity
	add	esp, 8

; 3890 : 	    }
; 3891 : 	    if (ent == NULL) {

	test	eax, eax
	jne	SHORT $LN13@xmlValidat
$LN47@xmlValidat:

; 3892 : 		xmlErrValidNode(ctxt, (xmlNodePtr) doc,

	push	0
	push	edi
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0DG@NHAJHAEC@ENTITY?5attribute?5?$CFs?5reference?5a@
	push	535					; 00000217H
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
$LN62@xmlValidat:

; 3954 : 	    }
; 3955 : 	    break;
; 3956 :         }
; 3957 :     }
; 3958 :     return(ret);
; 3959 : }

	pop	edi
	xor	eax, eax
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlValidat:

; 3893 : 				XML_DTD_UNKNOWN_ENTITY,
; 3894 :    "ENTITY attribute %s reference an unknown entity \"%s\"\n",
; 3895 : 		       name, value, NULL);
; 3896 : 		ret = 0;
; 3897 : 	    } else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {

	cmp	DWORD PTR [eax+48], 3
	je	SHORT $LN59@xmlValidat

; 3898 : 		xmlErrValidNode(ctxt, (xmlNodePtr) doc,

	push	0
	push	edi
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0DM@CBMBENAH@ENTITY?5attribute?5?$CFs?5reference?5a@
	push	511					; 000001ffH
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 3899 : 				XML_DTD_ENTITY_TYPE,
; 3900 :    "ENTITY attribute %s reference an entity \"%s\" of wrong type\n",
; 3901 : 		       name, value, NULL);
; 3902 : 		ret = 0;

	xor	eax, eax
	pop	edi

; 3954 : 	    }
; 3955 : 	    break;
; 3956 :         }
; 3957 :     }
; 3958 :     return(ret);
; 3959 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@xmlValidat:
	pop	edi

; 3893 : 				XML_DTD_UNKNOWN_ENTITY,
; 3894 :    "ENTITY attribute %s reference an unknown entity \"%s\"\n",
; 3895 : 		       name, value, NULL);
; 3896 : 		ret = 0;
; 3897 : 	    } else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {

	mov	eax, 1

; 3954 : 	    }
; 3955 : 	    break;
; 3956 :         }
; 3957 :     }
; 3958 :     return(ret);
; 3959 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidateAttributeValue2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateNmtokensValueInternal
_TEXT	SEGMENT
_len$ = -4						; size = 4
_doc$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlValidateNmtokensValueInternal PROC			; COMDAT

; 3691 : xmlValidateNmtokensValueInternal(xmlDocPtr doc, const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _value$[ebp]
	test	edi, edi
	je	$LN45@xmlValidat
$LN19@xmlValidat:

; 3692 :     const xmlChar *cur;
; 3693 :     int val, len;
; 3694 : 
; 3695 :     if (value == NULL) return(0);
; 3696 :     cur = value;
; 3697 :     val = xmlStringCurrentChar(NULL, cur, &len);
; 3698 :     cur += len;
; 3699 : 
; 3700 :     while (IS_BLANK(val)) {

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	add	edi, DWORD PTR _len$[ebp]
	mov	esi, eax
	add	esp, 12					; 0000000cH
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN21@xmlValidat
	cmp	esi, 32					; 00000020H
	je	SHORT $LN19@xmlValidat
	cmp	esi, 9
	jl	SHORT $LN18@xmlValidat
	cmp	esi, 10					; 0000000aH
	jle	SHORT $LN19@xmlValidat
$LN18@xmlValidat:
	cmp	esi, 13					; 0000000dH
	je	SHORT $LN19@xmlValidat
$LN21@xmlValidat:

; 3701 : 	val = xmlStringCurrentChar(NULL, cur, &len);
; 3702 : 	cur += len;
; 3703 :     }
; 3704 : 
; 3705 :     if (!xmlIsDocNameChar(doc, val))

	mov	ebx, DWORD PTR _doc$[ebp]
	push	esi
	push	ebx
	call	_xmlIsDocNameChar
	add	esp, 8
	test	eax, eax
	je	$LN45@xmlValidat

; 3706 : 	return(0);
; 3707 : 
; 3708 :     while (xmlIsDocNameChar(doc, val)) {

	push	esi
	push	ebx
	call	_xmlIsDocNameChar
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlValidat
	npad	1
$LL4@xmlValidat:

; 3709 : 	val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar

; 3710 : 	cur += len;

	add	edi, DWORD PTR _len$[ebp]
	mov	esi, eax
	push	esi
	push	ebx
	call	_xmlIsDocNameChar
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LL4@xmlValidat
$LN25@xmlValidat:

; 3711 :     }
; 3712 : 
; 3713 :     /* Should not test IS_BLANK(val) here -- see erratum E20*/
; 3714 :     while (val == 0x20) {

	cmp	esi, 32					; 00000020H
	jne	SHORT $LN7@xmlValidat
$LL8@xmlValidat:

; 3715 : 	while (val == 0x20) {
; 3716 : 	    val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar

; 3717 : 	    cur += len;

	add	edi, DWORD PTR _len$[ebp]
	mov	esi, eax
	add	esp, 12					; 0000000cH
	cmp	esi, 32					; 00000020H
	je	SHORT $LL8@xmlValidat

; 3718 : 	}
; 3719 : 	if (val == 0) return(1);

	test	esi, esi
	je	SHORT $LN16@xmlValidat

; 3720 : 
; 3721 : 	if (!xmlIsDocNameChar(doc, val))

	push	esi
	push	ebx
	call	_xmlIsDocNameChar
	add	esp, 8
	test	eax, eax
	je	SHORT $LN45@xmlValidat

; 3722 : 	    return(0);
; 3723 : 
; 3724 : 	val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar

; 3725 : 	cur += len;

	add	edi, DWORD PTR _len$[ebp]
	mov	esi, eax

; 3726 : 
; 3727 : 	while (xmlIsDocNameChar(doc, val)) {

	push	esi
	push	ebx
	call	_xmlIsDocNameChar
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN11@xmlValidat
	npad	2
$LL10@xmlValidat:

; 3728 : 	    val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar

; 3729 : 	    cur += len;

	add	edi, DWORD PTR _len$[ebp]
	mov	esi, eax
	push	esi
	push	ebx
	call	_xmlIsDocNameChar
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LL10@xmlValidat
$LN11@xmlValidat:

; 3711 :     }
; 3712 : 
; 3713 :     /* Should not test IS_BLANK(val) here -- see erratum E20*/
; 3714 :     while (val == 0x20) {

	cmp	esi, 32					; 00000020H
	je	SHORT $LL8@xmlValidat
$LN7@xmlValidat:

; 3730 : 	}
; 3731 :     }
; 3732 : 
; 3733 :     if (val != 0) return(0);

	test	esi, esi
	jne	SHORT $LN45@xmlValidat
$LN16@xmlValidat:
	pop	edi

; 3734 : 
; 3735 :     return(1);
; 3736 : }

	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@xmlValidat:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidateNmtokensValueInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateNmtokenValueInternal
_TEXT	SEGMENT
_len$ = -4						; size = 4
_doc$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlValidateNmtokenValueInternal PROC			; COMDAT

; 3638 : xmlValidateNmtokenValueInternal(xmlDocPtr doc, const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _value$[ebp]
	test	esi, esi
	je	$LN64@xmlValidat

; 3639 :     const xmlChar *cur;
; 3640 :     int val, len;
; 3641 : 
; 3642 :     if (value == NULL) return(0);
; 3643 :     cur = value;
; 3644 :     val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	esi
	push	0
	call	_xmlStringCurrentChar

; 3645 :     cur += len;

	mov	edi, DWORD PTR _len$[ebp]

; 3646 : 
; 3647 :     if (!xmlIsDocNameChar(doc, val))

	mov	ebx, DWORD PTR _doc$[ebp]
	add	edi, esi
	push	eax
	push	ebx
	call	_xmlIsDocNameChar
	add	esp, 20					; 00000014H
	test	eax, eax
	je	$LN64@xmlValidat
$LN13@xmlValidat:

; 3473 :     if ((doc == NULL) || (doc->properties & XML_DOC_OLD10) == 0) {

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	add	edi, DWORD PTR _len$[ebp]
	add	esp, 12					; 0000000cH
	mov	esi, eax
	test	ebx, ebx
	je	$LN11@xmlValidat
	test	BYTE PTR [ebx+92], 4
	je	$LN11@xmlValidat

; 3496 : 	    ((c >= 0x10000) && (c <= 0xEFFFF)))
; 3497 : 	     return(1);
; 3498 :     } else {
; 3499 :         if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
; 3500 :             (c == '.') || (c == '-') ||
; 3501 : 	    (c == '_') || (c == ':') ||
; 3502 : 	    (IS_COMBINING(c)) ||

	cmp	esi, 256				; 00000100H
	jge	SHORT $LN39@xmlValidat
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN33@xmlValidat
	cmp	esi, 90					; 0000005aH
	jle	SHORT $LN13@xmlValidat
$LN33@xmlValidat:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN34@xmlValidat
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LN13@xmlValidat
$LN34@xmlValidat:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN36@xmlValidat
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LN13@xmlValidat
$LN36@xmlValidat:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN37@xmlValidat
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LN13@xmlValidat
$LN37@xmlValidat:
	cmp	esi, 248				; 000000f8H
	jge	SHORT $LN13@xmlValidat
	jmp	SHORT $LN58@xmlValidat
$LN39@xmlValidat:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlValidat
$LN58@xmlValidat:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN66@xmlValidat
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN41@xmlValidat
	cmp	esi, 40869				; 00009fa5H
	jle	$LN13@xmlValidat
$LN41@xmlValidat:
	cmp	esi, 12295				; 00003007H
	je	$LN13@xmlValidat
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN61@xmlValidat
	cmp	esi, 12329				; 00003029H
	jle	$LN13@xmlValidat
$LN61@xmlValidat:
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN49@xmlValidat
$LN66@xmlValidat:
	lea	eax, DWORD PTR [esi-48]
	cmp	eax, 9
	ja	SHORT $LN59@xmlValidat
	jmp	$LN13@xmlValidat
$LN49@xmlValidat:
	push	OFFSET _xmlIsDigitGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN13@xmlValidat
$LN59@xmlValidat:
	cmp	esi, 46					; 0000002eH
	je	$LN13@xmlValidat
	cmp	esi, 45					; 0000002dH
	je	$LN13@xmlValidat
	cmp	esi, 95					; 0000005fH
	je	$LN13@xmlValidat
	cmp	esi, 58					; 0000003aH
	je	$LN13@xmlValidat
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN62@xmlValidat
	push	OFFSET _xmlIsCombiningGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN13@xmlValidat
	push	OFFSET _xmlIsExtenderGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	jmp	SHORT $LN54@xmlValidat
$LN62@xmlValidat:
	xor	eax, eax
	cmp	esi, 183				; 000000b7H
	sete	al
$LN54@xmlValidat:
	test	eax, eax
	je	$LN12@xmlValidat

; 3503 : 	    (IS_EXTENDER(c)))
; 3504 : 	    return(1);

	jmp	$LN13@xmlValidat
$LN11@xmlValidat:

; 3474 :         /*
; 3475 : 	 * Use the new checks of production [4] [4a] amd [5] of the
; 3476 : 	 * Update 5 of XML-1.0
; 3477 : 	 */
; 3478 : 	if (((c >= 'a') && (c <= 'z')) ||
; 3479 : 	    ((c >= 'A') && (c <= 'Z')) ||
; 3480 : 	    ((c >= '0') && (c <= '9')) || /* !start */
; 3481 : 	    (c == '_') || (c == ':') ||
; 3482 : 	    (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
; 3483 : 	    ((c >= 0xC0) && (c <= 0xD6)) ||
; 3484 : 	    ((c >= 0xD8) && (c <= 0xF6)) ||
; 3485 : 	    ((c >= 0xF8) && (c <= 0x2FF)) ||
; 3486 : 	    ((c >= 0x300) && (c <= 0x36F)) || /* !start */
; 3487 : 	    ((c >= 0x370) && (c <= 0x37D)) ||
; 3488 : 	    ((c >= 0x37F) && (c <= 0x1FFF)) ||
; 3489 : 	    ((c >= 0x200C) && (c <= 0x200D)) ||
; 3490 : 	    ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
; 3491 : 	    ((c >= 0x2070) && (c <= 0x218F)) ||
; 3492 : 	    ((c >= 0x2C00) && (c <= 0x2FEF)) ||
; 3493 : 	    ((c >= 0x3001) && (c <= 0xD7FF)) ||
; 3494 : 	    ((c >= 0xF900) && (c <= 0xFDCF)) ||
; 3495 : 	    ((c >= 0xFDF0) && (c <= 0xFFFD)) ||

	cmp	esi, 97					; 00000061H
	jl	SHORT $LN14@xmlValidat
	cmp	esi, 122				; 0000007aH
	jle	$LN13@xmlValidat
$LN14@xmlValidat:
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN15@xmlValidat
	cmp	esi, 90					; 0000005aH
	jle	$LN13@xmlValidat
$LN15@xmlValidat:
	cmp	esi, 48					; 00000030H
	jl	SHORT $LN16@xmlValidat
	cmp	esi, 57					; 00000039H
	jle	$LN13@xmlValidat
$LN16@xmlValidat:
	cmp	esi, 95					; 0000005fH
	je	$LN13@xmlValidat
	cmp	esi, 58					; 0000003aH
	je	$LN13@xmlValidat
	cmp	esi, 45					; 0000002dH
	je	$LN13@xmlValidat
	cmp	esi, 46					; 0000002eH
	je	$LN13@xmlValidat
	cmp	esi, 183				; 000000b7H
	je	$LN13@xmlValidat
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN17@xmlValidat
	cmp	esi, 214				; 000000d6H
	jle	$LN13@xmlValidat
$LN17@xmlValidat:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN18@xmlValidat
	cmp	esi, 246				; 000000f6H
	jle	$LN13@xmlValidat
$LN18@xmlValidat:
	cmp	esi, 248				; 000000f8H
	jl	SHORT $LN19@xmlValidat
	cmp	esi, 767				; 000002ffH
	jle	$LN13@xmlValidat
$LN19@xmlValidat:
	cmp	esi, 768				; 00000300H
	jl	SHORT $LN20@xmlValidat
	cmp	esi, 879				; 0000036fH
	jle	$LN13@xmlValidat
$LN20@xmlValidat:
	cmp	esi, 880				; 00000370H
	jl	SHORT $LN21@xmlValidat
	cmp	esi, 893				; 0000037dH
	jle	$LN13@xmlValidat
$LN21@xmlValidat:
	cmp	esi, 895				; 0000037fH
	jl	SHORT $LN22@xmlValidat
	cmp	esi, 8191				; 00001fffH
	jle	$LN13@xmlValidat
$LN22@xmlValidat:
	cmp	esi, 8204				; 0000200cH
	jl	SHORT $LN23@xmlValidat
	cmp	esi, 8205				; 0000200dH
	jle	$LN13@xmlValidat
$LN23@xmlValidat:
	cmp	esi, 8255				; 0000203fH
	jl	SHORT $LN24@xmlValidat
	cmp	esi, 8256				; 00002040H
	jle	$LN13@xmlValidat
$LN24@xmlValidat:
	cmp	esi, 8304				; 00002070H
	jl	SHORT $LN25@xmlValidat
	cmp	esi, 8591				; 0000218fH
	jle	$LN13@xmlValidat
$LN25@xmlValidat:
	cmp	esi, 11264				; 00002c00H
	jl	SHORT $LN26@xmlValidat
	cmp	esi, 12271				; 00002fefH
	jle	$LN13@xmlValidat
$LN26@xmlValidat:
	cmp	esi, 12289				; 00003001H
	jl	SHORT $LN27@xmlValidat
	cmp	esi, 55295				; 0000d7ffH
	jle	$LN13@xmlValidat
$LN27@xmlValidat:
	cmp	esi, 63744				; 0000f900H
	jl	SHORT $LN28@xmlValidat
	cmp	esi, 64975				; 0000fdcfH
	jle	$LN13@xmlValidat
$LN28@xmlValidat:
	cmp	esi, 65008				; 0000fdf0H
	jl	SHORT $LN29@xmlValidat
	cmp	esi, 65533				; 0000fffdH
	jle	$LN13@xmlValidat
$LN29@xmlValidat:
	cmp	esi, 65536				; 00010000H
	jl	SHORT $LN12@xmlValidat
	cmp	esi, 983039				; 000effffH
	jle	$LN13@xmlValidat
$LN12@xmlValidat:

; 3648 : 	return(0);
; 3649 : 
; 3650 :     val = xmlStringCurrentChar(NULL, cur, &len);
; 3651 :     cur += len;
; 3652 :     while (xmlIsDocNameChar(doc, val)) {
; 3653 : 	val = xmlStringCurrentChar(NULL, cur, &len);
; 3654 : 	cur += len;
; 3655 :     }
; 3656 : 
; 3657 :     if (val != 0) return(0);

	test	esi, esi
	jne	SHORT $LN64@xmlValidat

; 3658 : 
; 3659 :     return(1);

	pop	edi
	lea	eax, DWORD PTR [esi+1]

; 3660 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN64@xmlValidat:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidateNmtokenValueInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateNamesValueInternal
_TEXT	SEGMENT
_len$ = -4						; size = 4
_doc$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlValidateNamesValueInternal PROC			; COMDAT

; 3568 : xmlValidateNamesValueInternal(xmlDocPtr doc, const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _value$[ebp]
	test	esi, esi
	je	$LN31@xmlValidat

; 3569 :     const xmlChar *cur;
; 3570 :     int val, len;
; 3571 : 
; 3572 :     if (value == NULL) return(0);
; 3573 :     cur = value;
; 3574 :     val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	esi
	push	0
	call	_xmlStringCurrentChar

; 3575 :     cur += len;
; 3576 : 
; 3577 :     if (!xmlIsDocNameStartChar(doc, val))

	mov	ebx, DWORD PTR _doc$[ebp]
	add	esi, DWORD PTR _len$[ebp]
	push	eax
	push	ebx
	call	_xmlIsDocNameStartChar
	add	esp, 20					; 00000014H
	test	eax, eax
	je	$LN31@xmlValidat

; 3578 : 	return(0);
; 3579 : 
; 3580 :     val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	esi
	push	0
	call	_xmlStringCurrentChar

; 3581 :     cur += len;

	add	esi, DWORD PTR _len$[ebp]
	mov	edi, eax

; 3582 :     while (xmlIsDocNameChar(doc, val)) {

	push	edi
	push	ebx
	call	_xmlIsDocNameChar
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN16@xmlValidat
	npad	1
$LL2@xmlValidat:

; 3583 : 	val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	esi
	push	0
	call	_xmlStringCurrentChar

; 3584 : 	cur += len;

	add	esi, DWORD PTR _len$[ebp]
	mov	edi, eax
	push	edi
	push	ebx
	call	_xmlIsDocNameChar
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LL2@xmlValidat
$LN16@xmlValidat:

; 3585 :     }
; 3586 : 
; 3587 :     /* Should not test IS_BLANK(val) here -- see erratum E20*/
; 3588 :     while (val == 0x20) {

	cmp	edi, 32					; 00000020H
	jne	SHORT $LN5@xmlValidat
$LL6@xmlValidat:

; 3589 : 	while (val == 0x20) {
; 3590 : 	    val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	esi
	push	0
	call	_xmlStringCurrentChar

; 3591 : 	    cur += len;

	add	esi, DWORD PTR _len$[ebp]
	mov	edi, eax
	add	esp, 12					; 0000000cH
	cmp	edi, 32					; 00000020H
	je	SHORT $LL6@xmlValidat

; 3592 : 	}
; 3593 : 
; 3594 : 	if (!xmlIsDocNameStartChar(doc, val))

	push	edi
	push	ebx
	call	_xmlIsDocNameStartChar
	add	esp, 8
	test	eax, eax
	je	SHORT $LN31@xmlValidat

; 3595 : 	    return(0);
; 3596 : 
; 3597 : 	val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	esi
	push	0
	call	_xmlStringCurrentChar

; 3598 : 	cur += len;

	add	esi, DWORD PTR _len$[ebp]
	mov	edi, eax

; 3599 : 
; 3600 : 	while (xmlIsDocNameChar(doc, val)) {

	push	edi
	push	ebx
	call	_xmlIsDocNameChar
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN9@xmlValidat
	npad	6
$LL8@xmlValidat:

; 3601 : 	    val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	esi
	push	0
	call	_xmlStringCurrentChar

; 3602 : 	    cur += len;

	add	esi, DWORD PTR _len$[ebp]
	mov	edi, eax
	push	edi
	push	ebx
	call	_xmlIsDocNameChar
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LL8@xmlValidat
$LN9@xmlValidat:

; 3585 :     }
; 3586 : 
; 3587 :     /* Should not test IS_BLANK(val) here -- see erratum E20*/
; 3588 :     while (val == 0x20) {

	cmp	edi, 32					; 00000020H
	je	SHORT $LL6@xmlValidat
$LN5@xmlValidat:

; 3603 : 	}
; 3604 :     }
; 3605 : 
; 3606 :     if (val != 0) return(0);

	test	edi, edi
	jne	SHORT $LN31@xmlValidat

; 3607 : 
; 3608 :     return(1);

	lea	eax, DWORD PTR [edi+1]
	pop	edi

; 3609 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlValidat:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidateNamesValueInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateNameValueInternal
_TEXT	SEGMENT
_len$ = -4						; size = 4
_doc$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlValidateNameValueInternal PROC			; COMDAT

; 3520 : xmlValidateNameValueInternal(xmlDocPtr doc, const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _value$[ebp]
	test	esi, esi
	je	SHORT $LN12@xmlValidat

; 3521 :     const xmlChar *cur;
; 3522 :     int val, len;
; 3523 : 
; 3524 :     if (value == NULL) return(0);
; 3525 :     cur = value;
; 3526 :     val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	esi
	push	0
	call	_xmlStringCurrentChar

; 3527 :     cur += len;
; 3528 :     if (!xmlIsDocNameStartChar(doc, val))

	mov	ebx, DWORD PTR _doc$[ebp]
	add	esi, DWORD PTR _len$[ebp]
	push	eax
	push	ebx
	call	_xmlIsDocNameStartChar
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN12@xmlValidat

; 3529 : 	return(0);
; 3530 : 
; 3531 :     val = xmlStringCurrentChar(NULL, cur, &len);

	push	edi
	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	esi
	push	0
	call	_xmlStringCurrentChar

; 3532 :     cur += len;

	add	esi, DWORD PTR _len$[ebp]
	mov	edi, eax

; 3533 :     while (xmlIsDocNameChar(doc, val)) {

	push	edi
	push	ebx
	call	_xmlIsDocNameChar
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN3@xmlValidat
$LL2@xmlValidat:

; 3534 : 	val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	esi
	push	0
	call	_xmlStringCurrentChar

; 3535 : 	cur += len;

	add	esi, DWORD PTR _len$[ebp]
	mov	edi, eax
	push	edi
	push	ebx
	call	_xmlIsDocNameChar
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LL2@xmlValidat
$LN3@xmlValidat:

; 3536 :     }
; 3537 : 
; 3538 :     if (val != 0) return(0);

	test	edi, edi
	pop	edi
	jne	SHORT $LN12@xmlValidat

; 3539 : 
; 3540 :     return(1);

	pop	esi
	mov	eax, 1

; 3541 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlValidat:
	pop	esi

; 3536 :     }
; 3537 : 
; 3538 :     if (val != 0) return(0);

	xor	eax, eax

; 3541 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidateNameValueInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlIsDocNameChar
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_c$ = 12						; size = 4
_xmlIsDocNameChar PROC					; COMDAT

; 3472 : xmlIsDocNameChar(xmlDocPtr doc, int c) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	je	$LN4@xmlIsDocNa

; 3473 :     if ((doc == NULL) || (doc->properties & XML_DOC_OLD10) == 0) {

	test	BYTE PTR [eax+92], 4
	je	$LN4@xmlIsDocNa

; 3498 :     } else {
; 3499 :         if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
; 3500 :             (c == '.') || (c == '-') ||
; 3501 : 	    (c == '_') || (c == ':') ||
; 3502 : 	    (IS_COMBINING(c)) ||

	mov	esi, DWORD PTR _c$[ebp]
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN32@xmlIsDocNa
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN26@xmlIsDocNa
	cmp	esi, 90					; 0000005aH
	jle	SHORT $LN6@xmlIsDocNa
$LN26@xmlIsDocNa:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN27@xmlIsDocNa
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LN6@xmlIsDocNa
$LN27@xmlIsDocNa:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN29@xmlIsDocNa
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LN6@xmlIsDocNa
$LN29@xmlIsDocNa:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN30@xmlIsDocNa
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LN6@xmlIsDocNa
$LN30@xmlIsDocNa:
	cmp	esi, 248				; 000000f8H
	jl	SHORT $LN48@xmlIsDocNa
$LN6@xmlIsDocNa:

; 3496 : 	    ((c >= 0x10000) && (c <= 0xEFFFF)))
; 3497 : 	     return(1);

	mov	eax, 1
	pop	esi

; 3507 : }

	pop	ebp
	ret	0
$LN32@xmlIsDocNa:

; 3498 :     } else {
; 3499 :         if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
; 3500 :             (c == '.') || (c == '-') ||
; 3501 : 	    (c == '_') || (c == ':') ||
; 3502 : 	    (IS_COMBINING(c)) ||

	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@xmlIsDocNa
$LN48@xmlIsDocNa:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN54@xmlIsDocNa
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN34@xmlIsDocNa
	cmp	esi, 40869				; 00009fa5H
	jle	SHORT $LN6@xmlIsDocNa
$LN34@xmlIsDocNa:
	cmp	esi, 12295				; 00003007H
	je	SHORT $LN6@xmlIsDocNa
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN51@xmlIsDocNa
	cmp	esi, 12329				; 00003029H
	jle	SHORT $LN6@xmlIsDocNa
$LN51@xmlIsDocNa:
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN42@xmlIsDocNa
$LN54@xmlIsDocNa:
	lea	eax, DWORD PTR [esi-48]
	cmp	eax, 9
	ja	SHORT $LN49@xmlIsDocNa

; 3496 : 	    ((c >= 0x10000) && (c <= 0xEFFFF)))
; 3497 : 	     return(1);

	mov	eax, 1
	pop	esi

; 3507 : }

	pop	ebp
	ret	0
$LN42@xmlIsDocNa:

; 3498 :     } else {
; 3499 :         if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
; 3500 :             (c == '.') || (c == '-') ||
; 3501 : 	    (c == '_') || (c == ':') ||
; 3502 : 	    (IS_COMBINING(c)) ||

	push	OFFSET _xmlIsDigitGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@xmlIsDocNa
$LN49@xmlIsDocNa:
	cmp	esi, 46					; 0000002eH
	je	SHORT $LN6@xmlIsDocNa
	cmp	esi, 45					; 0000002dH
	je	SHORT $LN6@xmlIsDocNa
	cmp	esi, 95					; 0000005fH
	je	$LN6@xmlIsDocNa
	cmp	esi, 58					; 0000003aH
	je	$LN6@xmlIsDocNa
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN52@xmlIsDocNa
	push	OFFSET _xmlIsCombiningGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN6@xmlIsDocNa
	push	OFFSET _xmlIsExtenderGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	jmp	SHORT $LN47@xmlIsDocNa
$LN52@xmlIsDocNa:
	xor	eax, eax
	cmp	esi, 183				; 000000b7H
	sete	al
$LN47@xmlIsDocNa:
	test	eax, eax
	je	$LN5@xmlIsDocNa

; 3496 : 	    ((c >= 0x10000) && (c <= 0xEFFFF)))
; 3497 : 	     return(1);

	mov	eax, 1
	pop	esi

; 3507 : }

	pop	ebp
	ret	0
$LN4@xmlIsDocNa:

; 3474 :         /*
; 3475 : 	 * Use the new checks of production [4] [4a] amd [5] of the
; 3476 : 	 * Update 5 of XML-1.0
; 3477 : 	 */
; 3478 : 	if (((c >= 'a') && (c <= 'z')) ||
; 3479 : 	    ((c >= 'A') && (c <= 'Z')) ||
; 3480 : 	    ((c >= '0') && (c <= '9')) || /* !start */
; 3481 : 	    (c == '_') || (c == ':') ||
; 3482 : 	    (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
; 3483 : 	    ((c >= 0xC0) && (c <= 0xD6)) ||
; 3484 : 	    ((c >= 0xD8) && (c <= 0xF6)) ||
; 3485 : 	    ((c >= 0xF8) && (c <= 0x2FF)) ||
; 3486 : 	    ((c >= 0x300) && (c <= 0x36F)) || /* !start */
; 3487 : 	    ((c >= 0x370) && (c <= 0x37D)) ||
; 3488 : 	    ((c >= 0x37F) && (c <= 0x1FFF)) ||
; 3489 : 	    ((c >= 0x200C) && (c <= 0x200D)) ||
; 3490 : 	    ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
; 3491 : 	    ((c >= 0x2070) && (c <= 0x218F)) ||
; 3492 : 	    ((c >= 0x2C00) && (c <= 0x2FEF)) ||
; 3493 : 	    ((c >= 0x3001) && (c <= 0xD7FF)) ||
; 3494 : 	    ((c >= 0xF900) && (c <= 0xFDCF)) ||
; 3495 : 	    ((c >= 0xFDF0) && (c <= 0xFFFD)) ||

	mov	eax, DWORD PTR _c$[ebp]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN7@xmlIsDocNa
	cmp	eax, 122				; 0000007aH
	jle	$LN6@xmlIsDocNa
$LN7@xmlIsDocNa:
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN8@xmlIsDocNa
	cmp	eax, 90					; 0000005aH
	jle	$LN6@xmlIsDocNa
$LN8@xmlIsDocNa:
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN9@xmlIsDocNa
	cmp	eax, 57					; 00000039H
	jle	$LN6@xmlIsDocNa
$LN9@xmlIsDocNa:
	cmp	eax, 95					; 0000005fH
	je	$LN6@xmlIsDocNa
	cmp	eax, 58					; 0000003aH
	je	$LN6@xmlIsDocNa
	cmp	eax, 45					; 0000002dH
	je	$LN6@xmlIsDocNa
	cmp	eax, 46					; 0000002eH
	je	$LN6@xmlIsDocNa
	cmp	eax, 183				; 000000b7H
	je	$LN6@xmlIsDocNa
	cmp	eax, 192				; 000000c0H
	jl	SHORT $LN10@xmlIsDocNa
	cmp	eax, 214				; 000000d6H
	jle	$LN6@xmlIsDocNa
$LN10@xmlIsDocNa:
	cmp	eax, 216				; 000000d8H
	jl	SHORT $LN11@xmlIsDocNa
	cmp	eax, 246				; 000000f6H
	jle	$LN6@xmlIsDocNa
$LN11@xmlIsDocNa:
	cmp	eax, 248				; 000000f8H
	jl	SHORT $LN12@xmlIsDocNa
	cmp	eax, 767				; 000002ffH
	jle	$LN6@xmlIsDocNa
$LN12@xmlIsDocNa:
	cmp	eax, 768				; 00000300H
	jl	SHORT $LN13@xmlIsDocNa
	cmp	eax, 879				; 0000036fH
	jle	$LN6@xmlIsDocNa
$LN13@xmlIsDocNa:
	cmp	eax, 880				; 00000370H
	jl	SHORT $LN14@xmlIsDocNa
	cmp	eax, 893				; 0000037dH
	jle	$LN6@xmlIsDocNa
$LN14@xmlIsDocNa:
	cmp	eax, 895				; 0000037fH
	jl	SHORT $LN15@xmlIsDocNa
	cmp	eax, 8191				; 00001fffH
	jle	$LN6@xmlIsDocNa
$LN15@xmlIsDocNa:
	cmp	eax, 8204				; 0000200cH
	jl	SHORT $LN16@xmlIsDocNa
	cmp	eax, 8205				; 0000200dH
	jle	$LN6@xmlIsDocNa
$LN16@xmlIsDocNa:
	cmp	eax, 8255				; 0000203fH
	jl	SHORT $LN17@xmlIsDocNa
	cmp	eax, 8256				; 00002040H
	jle	$LN6@xmlIsDocNa
$LN17@xmlIsDocNa:
	cmp	eax, 8304				; 00002070H
	jl	SHORT $LN18@xmlIsDocNa
	cmp	eax, 8591				; 0000218fH
	jle	$LN6@xmlIsDocNa
$LN18@xmlIsDocNa:
	cmp	eax, 11264				; 00002c00H
	jl	SHORT $LN19@xmlIsDocNa
	cmp	eax, 12271				; 00002fefH
	jle	$LN6@xmlIsDocNa
$LN19@xmlIsDocNa:
	cmp	eax, 12289				; 00003001H
	jl	SHORT $LN20@xmlIsDocNa
	cmp	eax, 55295				; 0000d7ffH
	jle	$LN6@xmlIsDocNa
$LN20@xmlIsDocNa:
	cmp	eax, 63744				; 0000f900H
	jl	SHORT $LN21@xmlIsDocNa
	cmp	eax, 64975				; 0000fdcfH
	jle	$LN6@xmlIsDocNa
$LN21@xmlIsDocNa:
	cmp	eax, 65008				; 0000fdf0H
	jl	SHORT $LN22@xmlIsDocNa
	cmp	eax, 65533				; 0000fffdH
	jle	$LN6@xmlIsDocNa
$LN22@xmlIsDocNa:
	cmp	eax, 65536				; 00010000H
	jl	SHORT $LN5@xmlIsDocNa
	cmp	eax, 983039				; 000effffH
	jle	$LN6@xmlIsDocNa
$LN5@xmlIsDocNa:

; 3503 : 	    (IS_EXTENDER(c)))
; 3504 : 	    return(1);
; 3505 :     }
; 3506 :     return(0);

	xor	eax, eax
	pop	esi

; 3507 : }

	pop	ebp
	ret	0
_xmlIsDocNameChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlIsDocNameStartChar
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_c$ = 12						; size = 4
_xmlIsDocNameStartChar PROC				; COMDAT

; 3442 : xmlIsDocNameStartChar(xmlDocPtr doc, int c) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	je	$LN4@xmlIsDocNa

; 3443 :     if ((doc == NULL) || (doc->properties & XML_DOC_OLD10) == 0) {

	test	BYTE PTR [eax+92], 4
	je	$LN4@xmlIsDocNa

; 3464 :     } else {
; 3465 :         if (IS_LETTER(c) || (c == '_') || (c == ':'))

	mov	esi, DWORD PTR _c$[ebp]
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN29@xmlIsDocNa
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN23@xmlIsDocNa
	cmp	esi, 90					; 0000005aH
	jle	SHORT $LN6@xmlIsDocNa
$LN23@xmlIsDocNa:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN24@xmlIsDocNa
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LN6@xmlIsDocNa
$LN24@xmlIsDocNa:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN26@xmlIsDocNa
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LN6@xmlIsDocNa
$LN26@xmlIsDocNa:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN27@xmlIsDocNa
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LN6@xmlIsDocNa
$LN27@xmlIsDocNa:
	cmp	esi, 248				; 000000f8H
	jl	SHORT $LN37@xmlIsDocNa
$LN6@xmlIsDocNa:

; 3462 : 	    ((c >= 0x10000) && (c <= 0xEFFFF)))
; 3463 : 	    return(1);

	mov	eax, 1
	pop	esi

; 3469 : }

	pop	ebp
	ret	0
$LN29@xmlIsDocNa:

; 3464 :     } else {
; 3465 :         if (IS_LETTER(c) || (c == '_') || (c == ':'))

	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@xmlIsDocNa
$LN37@xmlIsDocNa:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN38@xmlIsDocNa
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN31@xmlIsDocNa
	cmp	esi, 40869				; 00009fa5H
	jle	SHORT $LN6@xmlIsDocNa
$LN31@xmlIsDocNa:
	cmp	esi, 12295				; 00003007H
	je	SHORT $LN6@xmlIsDocNa
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN38@xmlIsDocNa
	cmp	esi, 12329				; 00003029H
	jle	SHORT $LN6@xmlIsDocNa
$LN38@xmlIsDocNa:
	cmp	esi, 95					; 0000005fH
	je	SHORT $LN6@xmlIsDocNa
	cmp	esi, 58					; 0000003aH
	jne	$LN5@xmlIsDocNa

; 3462 : 	    ((c >= 0x10000) && (c <= 0xEFFFF)))
; 3463 : 	    return(1);

	lea	eax, DWORD PTR [esi-57]
	pop	esi

; 3469 : }

	pop	ebp
	ret	0
$LN4@xmlIsDocNa:

; 3444 :         /*
; 3445 : 	 * Use the new checks of production [4] [4a] amd [5] of the
; 3446 : 	 * Update 5 of XML-1.0
; 3447 : 	 */
; 3448 : 	if (((c >= 'a') && (c <= 'z')) ||
; 3449 : 	    ((c >= 'A') && (c <= 'Z')) ||
; 3450 : 	    (c == '_') || (c == ':') ||
; 3451 : 	    ((c >= 0xC0) && (c <= 0xD6)) ||
; 3452 : 	    ((c >= 0xD8) && (c <= 0xF6)) ||
; 3453 : 	    ((c >= 0xF8) && (c <= 0x2FF)) ||
; 3454 : 	    ((c >= 0x370) && (c <= 0x37D)) ||
; 3455 : 	    ((c >= 0x37F) && (c <= 0x1FFF)) ||
; 3456 : 	    ((c >= 0x200C) && (c <= 0x200D)) ||
; 3457 : 	    ((c >= 0x2070) && (c <= 0x218F)) ||
; 3458 : 	    ((c >= 0x2C00) && (c <= 0x2FEF)) ||
; 3459 : 	    ((c >= 0x3001) && (c <= 0xD7FF)) ||
; 3460 : 	    ((c >= 0xF900) && (c <= 0xFDCF)) ||
; 3461 : 	    ((c >= 0xFDF0) && (c <= 0xFFFD)) ||

	mov	eax, DWORD PTR _c$[ebp]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN7@xmlIsDocNa
	cmp	eax, 122				; 0000007aH
	jle	SHORT $LN6@xmlIsDocNa
$LN7@xmlIsDocNa:
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN8@xmlIsDocNa
	cmp	eax, 90					; 0000005aH
	jle	SHORT $LN6@xmlIsDocNa
$LN8@xmlIsDocNa:
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN6@xmlIsDocNa
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN6@xmlIsDocNa
	cmp	eax, 192				; 000000c0H
	jl	SHORT $LN9@xmlIsDocNa
	cmp	eax, 214				; 000000d6H
	jle	$LN6@xmlIsDocNa
$LN9@xmlIsDocNa:
	cmp	eax, 216				; 000000d8H
	jl	SHORT $LN10@xmlIsDocNa
	cmp	eax, 246				; 000000f6H
	jle	$LN6@xmlIsDocNa
$LN10@xmlIsDocNa:
	cmp	eax, 248				; 000000f8H
	jl	SHORT $LN11@xmlIsDocNa
	cmp	eax, 767				; 000002ffH
	jle	$LN6@xmlIsDocNa
$LN11@xmlIsDocNa:
	cmp	eax, 880				; 00000370H
	jl	SHORT $LN12@xmlIsDocNa
	cmp	eax, 893				; 0000037dH
	jle	$LN6@xmlIsDocNa
$LN12@xmlIsDocNa:
	cmp	eax, 895				; 0000037fH
	jl	SHORT $LN13@xmlIsDocNa
	cmp	eax, 8191				; 00001fffH
	jle	$LN6@xmlIsDocNa
$LN13@xmlIsDocNa:
	cmp	eax, 8204				; 0000200cH
	jl	SHORT $LN14@xmlIsDocNa
	cmp	eax, 8205				; 0000200dH
	jle	$LN6@xmlIsDocNa
$LN14@xmlIsDocNa:
	cmp	eax, 8304				; 00002070H
	jl	SHORT $LN15@xmlIsDocNa
	cmp	eax, 8591				; 0000218fH
	jle	$LN6@xmlIsDocNa
$LN15@xmlIsDocNa:
	cmp	eax, 11264				; 00002c00H
	jl	SHORT $LN16@xmlIsDocNa
	cmp	eax, 12271				; 00002fefH
	jle	$LN6@xmlIsDocNa
$LN16@xmlIsDocNa:
	cmp	eax, 12289				; 00003001H
	jl	SHORT $LN17@xmlIsDocNa
	cmp	eax, 55295				; 0000d7ffH
	jle	$LN6@xmlIsDocNa
$LN17@xmlIsDocNa:
	cmp	eax, 63744				; 0000f900H
	jl	SHORT $LN18@xmlIsDocNa
	cmp	eax, 64975				; 0000fdcfH
	jle	$LN6@xmlIsDocNa
$LN18@xmlIsDocNa:
	cmp	eax, 65008				; 0000fdf0H
	jl	SHORT $LN19@xmlIsDocNa
	cmp	eax, 65533				; 0000fffdH
	jle	$LN6@xmlIsDocNa
$LN19@xmlIsDocNa:
	cmp	eax, 65536				; 00010000H
	jl	SHORT $LN5@xmlIsDocNa
	cmp	eax, 983039				; 000effffH
	jle	$LN6@xmlIsDocNa
$LN5@xmlIsDocNa:

; 3466 : 	    return(1);
; 3467 :     }
; 3468 :     return(0);

	xor	eax, eax
	pop	esi

; 3469 : }

	pop	ebp
	ret	0
_xmlIsDocNameStartChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlDummyCompare
_TEXT	SEGMENT
_data0$ = 8						; size = 4
_data1$ = 12						; size = 4
_xmlDummyCompare PROC					; COMDAT
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	ret	0
_xmlDummyCompare ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlWalkRemoveRef
_TEXT	SEGMENT
_data$ = 8						; size = 4
_user$ = 12						; size = 4
_xmlWalkRemoveRef PROC					; COMDAT

; 2892 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR _user$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN2@xmlWalkRem

; 2893 :     xmlAttrPtr attr0 = ((xmlRefPtr)data)->attr;
; 2894 :     xmlAttrPtr attr1 = ((xmlRemoveMemoPtr)user)->ap;
; 2895 :     xmlListPtr ref_list = ((xmlRemoveMemoPtr)user)->l;
; 2896 : 
; 2897 :     if (attr0 == attr1) { /* Matched: remove and terminate walk */
; 2898 :         xmlListRemoveFirst(ref_list, (void *)data);

	push	ecx
	push	DWORD PTR [edx]
	call	_xmlListRemoveFirst
	add	esp, 8

; 2899 :         return 0;

	xor	eax, eax

; 2902 : }

	pop	ebp
	ret	0
$LN2@xmlWalkRem:

; 2900 :     }
; 2901 :     return 1;

	mov	eax, 1

; 2902 : }

	pop	ebp
	ret	0
_xmlWalkRemoveRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeRefTableEntry
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlFreeRefTableEntry PROC				; COMDAT

; 2877 : xmlFreeRefTableEntry(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _payload$[ebp]
	test	eax, eax
	je	SHORT $LN1@xmlFreeRef

; 2878 :     xmlListPtr list_ref = (xmlListPtr) payload;
; 2879 :     if (list_ref == NULL) return;
; 2880 :     xmlListDelete(list_ref);

	push	eax
	call	_xmlListDelete
	add	esp, 4
$LN1@xmlFreeRef:

; 2881 : }

	pop	ebp
	ret	0
_xmlFreeRefTableEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeRef
_TEXT	SEGMENT
_lk$ = 8						; size = 4
_xmlFreeRef PROC					; COMDAT

; 2860 : xmlFreeRef(xmlLinkPtr lk) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _lk$[ebp]
	call	_xmlLinkGetData
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN1@xmlFreeRef

; 2861 :     xmlRefPtr ref = (xmlRefPtr)xmlLinkGetData(lk);
; 2862 :     if (ref == NULL) return;
; 2863 :     if (ref->value != NULL)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN3@xmlFreeRef

; 2864 :         xmlFree((xmlChar *)ref->value);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlFreeRef:

; 2865 :     if (ref->name != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@xmlFreeRef

; 2866 :         xmlFree((xmlChar *)ref->name);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlFreeRef:

; 2867 :     xmlFree(ref);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreeRef:
	pop	esi

; 2868 : }

	pop	ebp
	ret	0
_xmlFreeRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeIDTableEntry
_TEXT	SEGMENT
_id$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlFreeIDTableEntry PROC				; COMDAT

; 2675 : xmlFreeIDTableEntry(void *id, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _id$[ebp]
	call	_xmlFreeID
	add	esp, 4

; 2676 :     xmlFreeID((xmlIDPtr) id);
; 2677 : }

	pop	ebp
	ret	0
_xmlFreeIDTableEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeID
_TEXT	SEGMENT
_id$ = 8						; size = 4
_xmlFreeID PROC						; COMDAT

; 2574 : xmlFreeID(xmlIDPtr id) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _id$[ebp]
	xor	edi, edi
	test	esi, esi
	je	SHORT $LN1@xmlFreeID

; 2575 :     xmlDictPtr dict = NULL;
; 2576 : 
; 2577 :     if (id == NULL) return;
; 2578 : 
; 2579 :     if (id->doc != NULL)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN3@xmlFreeID

; 2580 :         dict = id->doc->dict;

	mov	edi, DWORD PTR [eax+80]
$LN3@xmlFreeID:

; 2581 : 
; 2582 :     if (id->value != NULL)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN5@xmlFreeID

; 2583 : 	DICT_FREE(id->value)

	test	edi, edi
	je	SHORT $LN6@xmlFreeID
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@xmlFreeID
$LN6@xmlFreeID:
	push	DWORD PTR [esi+4]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlFreeID:

; 2584 :     if (id->name != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN8@xmlFreeID

; 2585 : 	DICT_FREE(id->name)

	test	edi, edi
	je	SHORT $LN9@xmlFreeID
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@xmlFreeID
$LN9@xmlFreeID:
	push	DWORD PTR [esi+12]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlFreeID:

; 2586 :     xmlFree(id);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreeID:

; 2587 : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlFreeID ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlDumpNotationDeclScan
_TEXT	SEGMENT
_nota$ = 8						; size = 4
_buf$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlDumpNotationDeclScan PROC				; COMDAT

; 2531 :                         const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _nota$[ebp]
	push	DWORD PTR _buf$[ebp]
	call	_xmlDumpNotationDecl
	add	esp, 8

; 2532 :     xmlDumpNotationDecl((xmlBufferPtr) buf, (xmlNotationPtr) nota);
; 2533 : }

	pop	ebp
	ret	0
_xmlDumpNotationDeclScan ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlCopyNotation
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlCopyNotation PROC					; COMDAT

; 2456 : xmlCopyNotation(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlCopyNot

; 77   :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	eax
	push	eax
	push	3
	push	2
	push	23					; 00000017H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 2457 :     xmlNotationPtr nota = (xmlNotationPtr) payload;
; 2458 :     xmlNotationPtr cur;
; 2459 : 
; 2460 :     cur = (xmlNotationPtr) xmlMalloc(sizeof(xmlNotation));
; 2461 :     if (cur == NULL) {
; 2462 : 	xmlVErrMemory(NULL, "malloc failed");
; 2463 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 2478 : }

	pop	ebp
	ret	0
$LN2@xmlCopyNot:
	push	edi

; 2464 :     }
; 2465 :     if (nota->name != NULL)

	mov	edi, DWORD PTR _payload$[ebp]
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@xmlCopyNot

; 2466 : 	cur->name = xmlStrdup(nota->name);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	jmp	SHORT $LN4@xmlCopyNot
$LN3@xmlCopyNot:

; 2467 :     else
; 2468 : 	cur->name = NULL;

	xor	eax, eax
$LN4@xmlCopyNot:

; 2469 :     if (nota->PublicID != NULL)

	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN5@xmlCopyNot

; 2470 : 	cur->PublicID = xmlStrdup(nota->PublicID);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	jmp	SHORT $LN6@xmlCopyNot
$LN5@xmlCopyNot:

; 2471 :     else
; 2472 : 	cur->PublicID = NULL;

	xor	eax, eax
$LN6@xmlCopyNot:

; 2473 :     if (nota->SystemID != NULL)

	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edi+8]
	pop	edi
	test	eax, eax
	je	SHORT $LN7@xmlCopyNot

; 2474 : 	cur->SystemID = xmlStrdup(nota->SystemID);

	push	eax
	call	_xmlStrdup
	add	esp, 4

; 2477 :     return(cur);

	mov	DWORD PTR [esi+8], eax
	mov	eax, esi
	pop	esi

; 2478 : }

	pop	ebp
	ret	0
$LN7@xmlCopyNot:

; 2475 :     else
; 2476 : 	cur->SystemID = NULL;

	xor	eax, eax

; 2477 :     return(cur);

	mov	DWORD PTR [esi+8], eax
	mov	eax, esi
	pop	esi

; 2478 : }

	pop	ebp
	ret	0
_xmlCopyNotation ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeNotationTableEntry
_TEXT	SEGMENT
_nota$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlFreeNotationTableEntry PROC				; COMDAT

; 2431 : xmlFreeNotationTableEntry(void *nota, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4

; 2341 :     if (nota == NULL) return;

	mov	esi, DWORD PTR _nota$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlFreeNot

; 2342 :     if (nota->name != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN5@xmlFreeNot

; 2343 : 	xmlFree((xmlChar *) nota->name);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlFreeNot:

; 2344 :     if (nota->PublicID != NULL)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@xmlFreeNot

; 2345 : 	xmlFree((xmlChar *) nota->PublicID);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlFreeNot:

; 2346 :     if (nota->SystemID != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN7@xmlFreeNot

; 2347 : 	xmlFree((xmlChar *) nota->SystemID);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlFreeNot:

; 2348 :     xmlFree(nota);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlFreeNot:
	pop	esi

; 2432 :     xmlFreeNotation((xmlNotationPtr) nota);
; 2433 : }

	pop	ebp
	ret	0
_xmlFreeNotationTableEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeNotation
_TEXT	SEGMENT
_nota$ = 8						; size = 4
_xmlFreeNotation PROC					; COMDAT

; 2340 : xmlFreeNotation(xmlNotationPtr nota) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _nota$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlFreeNot

; 2341 :     if (nota == NULL) return;
; 2342 :     if (nota->name != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@xmlFreeNot

; 2343 : 	xmlFree((xmlChar *) nota->name);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlFreeNot:

; 2344 :     if (nota->PublicID != NULL)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@xmlFreeNot

; 2345 : 	xmlFree((xmlChar *) nota->PublicID);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlFreeNot:

; 2346 :     if (nota->SystemID != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN5@xmlFreeNot

; 2347 : 	xmlFree((xmlChar *) nota->SystemID);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlFreeNot:

; 2348 :     xmlFree(nota);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreeNot:
	pop	esi

; 2349 : }

	pop	ebp
	ret	0
_xmlFreeNotation ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlDumpAttributeDeclScan
_TEXT	SEGMENT
_attr$ = 8						; size = 4
_buf$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlDumpAttributeDeclScan PROC				; COMDAT

; 2309 :                          const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _attr$[ebp]
	push	DWORD PTR _buf$[ebp]
	call	_xmlDumpAttributeDecl
	add	esp, 8

; 2310 :     xmlDumpAttributeDecl((xmlBufferPtr) buf, (xmlAttributePtr) attr);
; 2311 : }

	pop	ebp
	ret	0
_xmlDumpAttributeDeclScan ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlCopyAttribute
_TEXT	SEGMENT
_cur$1$ = 8						; size = 4
_payload$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlCopyAttribute PROC					; COMDAT

; 2178 : xmlCopyAttribute(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	64					; 00000040H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlCopyAtt

; 77   :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	eax
	push	eax
	push	3
	push	2
	push	23					; 00000017H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 2179 :     xmlAttributePtr attr = (xmlAttributePtr) payload;
; 2180 :     xmlAttributePtr cur;
; 2181 : 
; 2182 :     cur = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));
; 2183 :     if (cur == NULL) {
; 2184 : 	xmlVErrMemory(NULL, "malloc failed");
; 2185 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 2201 : }

	pop	ebp
	ret	0
$LN2@xmlCopyAtt:
	push	ebx
	push	edi

; 2186 :     }
; 2187 :     memset(cur, 0, sizeof(xmlAttribute));

	push	64					; 00000040H
	push	0
	push	esi
	call	_memset

; 2188 :     cur->type = XML_ATTRIBUTE_DECL;
; 2189 :     cur->atype = attr->atype;

	mov	edi, DWORD PTR _payload$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+4], 16			; 00000010H
	mov	eax, DWORD PTR [edi+40]
	mov	DWORD PTR [esi+40], eax

; 2190 :     cur->def = attr->def;

	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [esi+44], eax

; 2191 :     cur->tree = xmlCopyEnumeration(attr->tree);

	mov	eax, DWORD PTR [edi+52]
	mov	DWORD PTR _cur$1$[ebp], eax

; 1811 :     if (cur == NULL) return(NULL);

	test	eax, eax
	jne	SHORT $LN17@xmlCopyAtt
	xor	ebx, ebx
	jmp	SHORT $LN16@xmlCopyAtt
$LN17@xmlCopyAtt:

; 1812 :     ret = xmlCreateEnumeration((xmlChar *) cur->name);

	push	DWORD PTR [eax+4]
	call	_xmlCreateEnumeration
	mov	ebx, eax
	add	esp, 4

; 1813 :     if (ret == NULL) return(NULL);

	test	ebx, ebx
	je	SHORT $LN16@xmlCopyAtt
$LN18@xmlCopyAtt:

; 1814 : 
; 1815 :     if (cur->next != NULL) ret->next = xmlCopyEnumeration(cur->next);

	mov	eax, DWORD PTR _cur$1$[ebp]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN19@xmlCopyAtt
	push	eax
	call	_xmlCopyEnumeration
	add	esp, 4
	jmp	SHORT $LN20@xmlCopyAtt
$LN19@xmlCopyAtt:

; 1816 :     else ret->next = NULL;

	xor	eax, eax
$LN20@xmlCopyAtt:

; 1817 : 
; 1818 :     return(ret);

	mov	DWORD PTR [ebx], eax
$LN16@xmlCopyAtt:

; 2191 :     cur->tree = xmlCopyEnumeration(attr->tree);

	mov	DWORD PTR [esi+52], ebx

; 2192 :     if (attr->elem != NULL)

	mov	eax, DWORD PTR [edi+60]
	test	eax, eax
	je	SHORT $LN3@xmlCopyAtt

; 2193 : 	cur->elem = xmlStrdup(attr->elem);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+60], eax
$LN3@xmlCopyAtt:

; 2194 :     if (attr->name != NULL)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN4@xmlCopyAtt

; 2195 : 	cur->name = xmlStrdup(attr->name);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+8], eax
$LN4@xmlCopyAtt:

; 2196 :     if (attr->prefix != NULL)

	mov	eax, DWORD PTR [edi+56]
	test	eax, eax
	je	SHORT $LN5@xmlCopyAtt

; 2197 : 	cur->prefix = xmlStrdup(attr->prefix);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+56], eax
$LN5@xmlCopyAtt:

; 2198 :     if (attr->defaultValue != NULL)

	mov	eax, DWORD PTR [edi+48]
	pop	edi
	pop	ebx
	test	eax, eax
	je	SHORT $LN6@xmlCopyAtt

; 2199 : 	cur->defaultValue = xmlStrdup(attr->defaultValue);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+48], eax
$LN6@xmlCopyAtt:

; 2200 :     return(cur);

	mov	eax, esi
	pop	esi

; 2201 : }

	pop	ebp
	ret	0
_xmlCopyAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeAttributeTableEntry
_TEXT	SEGMENT
_attr$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlFreeAttributeTableEntry PROC			; COMDAT

; 2153 : xmlFreeAttributeTableEntry(void *attr, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _attr$[ebp]
	call	_xmlFreeAttribute
	add	esp, 4

; 2154 :     xmlFreeAttribute((xmlAttributePtr) attr);
; 2155 : }

	pop	ebp
	ret	0
_xmlFreeAttributeTableEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeAttribute
_TEXT	SEGMENT
_attr$ = 8						; size = 4
_xmlFreeAttribute PROC					; COMDAT

; 1885 : xmlFreeAttribute(xmlAttributePtr attr) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _attr$[ebp]
	test	esi, esi
	je	$LN1@xmlFreeAtt

; 1886 :     xmlDictPtr dict;
; 1887 : 
; 1888 :     if (attr == NULL) return;
; 1889 :     if (attr->doc != NULL)

	push	edi
	mov	edi, DWORD PTR [esi+32]
	test	edi, edi
	je	SHORT $LN3@xmlFreeAtt

; 1890 : 	dict = attr->doc->dict;

	mov	edi, DWORD PTR [edi+80]
	jmp	SHORT $LN4@xmlFreeAtt
$LN3@xmlFreeAtt:

; 1891 :     else
; 1892 : 	dict = NULL;

	xor	edi, edi
$LN4@xmlFreeAtt:

; 1893 :     xmlUnlinkNode((xmlNodePtr) attr);

	push	esi
	call	_xmlUnlinkNode

; 1894 :     if (attr->tree != NULL)

	mov	eax, DWORD PTR [esi+52]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@xmlFreeAtt

; 1895 :         xmlFreeEnumeration(attr->tree);

	push	eax
	call	_xmlFreeEnumeration
	add	esp, 4
$LN5@xmlFreeAtt:

; 1896 :     if (dict) {

	mov	eax, DWORD PTR [esi+60]
	test	edi, edi
	je	SHORT $LN6@xmlFreeAtt

; 1897 :         if ((attr->elem != NULL) && (!xmlDictOwns(dict, attr->elem)))

	test	eax, eax
	je	SHORT $LN8@xmlFreeAtt
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@xmlFreeAtt

; 1898 : 	    xmlFree((xmlChar *) attr->elem);

	push	DWORD PTR [esi+60]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlFreeAtt:

; 1899 :         if ((attr->name != NULL) && (!xmlDictOwns(dict, attr->name)))

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN9@xmlFreeAtt
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlFreeAtt

; 1900 : 	    xmlFree((xmlChar *) attr->name);

	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlFreeAtt:

; 1901 :         if ((attr->prefix != NULL) && (!xmlDictOwns(dict, attr->prefix)))

	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN10@xmlFreeAtt
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@xmlFreeAtt

; 1902 : 	    xmlFree((xmlChar *) attr->prefix);

	push	DWORD PTR [esi+56]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlFreeAtt:

; 1903 :         if ((attr->defaultValue != NULL) &&

	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN15@xmlFreeAtt
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN15@xmlFreeAtt

; 1904 : 	    (!xmlDictOwns(dict, attr->defaultValue)))
; 1905 : 	    xmlFree((xmlChar *) attr->defaultValue);

	push	DWORD PTR [esi+48]

; 1906 :     } else {

	jmp	SHORT $LN17@xmlFreeAtt
$LN6@xmlFreeAtt:

; 1907 : 	if (attr->elem != NULL)

	test	eax, eax
	je	SHORT $LN12@xmlFreeAtt

; 1908 : 	    xmlFree((xmlChar *) attr->elem);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlFreeAtt:

; 1909 : 	if (attr->name != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN13@xmlFreeAtt

; 1910 : 	    xmlFree((xmlChar *) attr->name);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlFreeAtt:

; 1911 : 	if (attr->defaultValue != NULL)

	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN14@xmlFreeAtt

; 1912 : 	    xmlFree((xmlChar *) attr->defaultValue);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlFreeAtt:

; 1913 : 	if (attr->prefix != NULL)

	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN15@xmlFreeAtt

; 1914 : 	    xmlFree((xmlChar *) attr->prefix);

	push	eax
$LN17@xmlFreeAtt:

; 1915 :     }
; 1916 :     xmlFree(attr);

	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlFreeAtt:
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
$LN1@xmlFreeAtt:
	pop	esi

; 1917 : }

	pop	ebp
	ret	0
_xmlFreeAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlScanIDAttributeDecl
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_elem$ = 12						; size = 4
_err$ = 16						; size = 4
_xmlScanIDAttributeDecl PROC				; COMDAT

; 1858 : xmlScanIDAttributeDecl(xmlValidCtxtPtr ctxt, xmlElementPtr elem, int err) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _elem$[ebp]
	xor	edi, edi
	test	ebx, ebx
	jne	SHORT $LN4@xmlScanIDA

; 1859 :     xmlAttributePtr cur;
; 1860 :     int ret = 0;
; 1861 : 
; 1862 :     if (elem == NULL) return(0);

	pop	edi
	xor	eax, eax

; 1875 : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlScanIDA:
	push	esi

; 1863 :     cur = elem->attributes;

	mov	esi, DWORD PTR [ebx+44]

; 1864 :     while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlScanIDA
$LL2@xmlScanIDA:

; 1865 :         if (cur->atype == XML_ATTRIBUTE_ID) {

	cmp	DWORD PTR [esi+40], 2
	jne	SHORT $LN6@xmlScanIDA

; 1866 : 	    ret ++;

	inc	edi

; 1867 : 	    if ((ret > 1) && (err))

	cmp	edi, 1
	jle	SHORT $LN6@xmlScanIDA
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN6@xmlScanIDA

; 1868 : 		xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_MULTIPLE_ID,

	push	0
	push	DWORD PTR [esi+8]
	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0DE@EJGKGKMH@Element?5?$CFs?5has?5too?5many?5ID?5attr@
	push	520					; 00000208H
	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
$LN6@xmlScanIDA:

; 1869 : 	       "Element %s has too many ID attributes defined : %s\n",
; 1870 : 		       elem->name, cur->name, NULL);
; 1871 : 	}
; 1872 : 	cur = cur->nexth;

	mov	esi, DWORD PTR [esi+36]
	test	esi, esi
	jne	SHORT $LL2@xmlScanIDA
$LN3@xmlScanIDA:

; 1873 :     }
; 1874 :     return(ret);

	pop	esi
	mov	eax, edi
	pop	edi

; 1875 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlScanIDAttributeDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlDumpEnumeration
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlDumpEnumeration PROC				; COMDAT

; 1831 : xmlDumpEnumeration(xmlBufferPtr buf, xmlEnumerationPtr cur) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _buf$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlDumpEnu
	push	esi
	mov	esi, DWORD PTR _cur$[ebp]
	npad	7
$LL7@xmlDumpEnu:

; 1832 :     if ((buf == NULL) || (cur == NULL))

	test	esi, esi
	je	SHORT $LN14@xmlDumpEnu

; 1833 :         return;
; 1834 : 
; 1835 :     xmlBufferWriteCHAR(buf, cur->name);

	push	DWORD PTR [esi+4]
	push	edi
	call	_xmlBufferWriteCHAR
	add	esp, 8

; 1836 :     if (cur->next == NULL)

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN10@xmlDumpEnu

; 1838 :     else {
; 1839 : 	xmlBufferWriteChar(buf, " | ");

	push	OFFSET ??_C@_03LGOGDKEL@?5?$HM?5@
	push	edi
	call	_xmlBufferWriteChar

; 1840 : 	xmlDumpEnumeration(buf, cur->next);

	mov	esi, DWORD PTR [esi]
	add	esp, 8
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	jmp	SHORT $LL7@xmlDumpEnu
$LN10@xmlDumpEnu:

; 1837 : 	xmlBufferWriteChar(buf, ")");

	push	OFFSET ??_C@_01PKGAHCOL@?$CJ@
	push	edi
	call	_xmlBufferWriteChar
	add	esp, 8
$LN14@xmlDumpEnu:
	pop	esi
$LN3@xmlDumpEnu:
	pop	edi

; 1841 :     }
; 1842 : }

	pop	ebp
	ret	0
_xmlDumpEnumeration ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlDumpElementDeclScan
_TEXT	SEGMENT
_elem$ = 8						; size = 4
_buf$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlDumpElementDeclScan PROC				; COMDAT

; 1737 :                        const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _elem$[ebp]
	push	DWORD PTR _buf$[ebp]
	call	_xmlDumpElementDecl
	add	esp, 8

; 1738 :     xmlDumpElementDecl((xmlBufferPtr) buf, (xmlElementPtr) elem);
; 1739 : }

	pop	ebp
	ret	0
_xmlDumpElementDeclScan ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlCopyElement
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlCopyElement PROC					; COMDAT

; 1626 : xmlCopyElement(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	56					; 00000038H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlCopyEle

; 77   :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	eax
	push	eax
	push	3
	push	2
	push	23					; 00000017H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1627 :     xmlElementPtr elem = (xmlElementPtr) payload;
; 1628 :     xmlElementPtr cur;
; 1629 : 
; 1630 :     cur = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));
; 1631 :     if (cur == NULL) {
; 1632 : 	xmlVErrMemory(NULL, "malloc failed");
; 1633 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 1650 : }

	pop	ebp
	ret	0
$LN2@xmlCopyEle:
	push	edi

; 1634 :     }
; 1635 :     memset(cur, 0, sizeof(xmlElement));

	push	56					; 00000038H
	push	0
	push	esi
	call	_memset

; 1636 :     cur->type = XML_ELEMENT_DECL;
; 1637 :     cur->etype = elem->etype;

	mov	edi, DWORD PTR _payload$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+4], 15			; 0000000fH
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [esi+36], eax

; 1638 :     if (elem->name != NULL)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN3@xmlCopyEle

; 1639 : 	cur->name = xmlStrdup(elem->name);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	jmp	SHORT $LN4@xmlCopyEle
$LN3@xmlCopyEle:

; 1640 :     else
; 1641 : 	cur->name = NULL;

	xor	eax, eax
$LN4@xmlCopyEle:

; 1642 :     if (elem->prefix != NULL)

	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edi+48]
	test	eax, eax
	je	SHORT $LN5@xmlCopyEle

; 1643 : 	cur->prefix = xmlStrdup(elem->prefix);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	jmp	SHORT $LN6@xmlCopyEle
$LN5@xmlCopyEle:

; 1644 :     else
; 1645 : 	cur->prefix = NULL;

	xor	eax, eax
$LN6@xmlCopyEle:

; 1646 :     cur->content = xmlCopyElementContent(elem->content);

	mov	DWORD PTR [esi+48], eax

; 1090 :     return(xmlCopyDocElementContent(NULL, cur));

	push	DWORD PTR [edi+40]
	push	0
	call	_xmlCopyDocElementContent
	add	esp, 8

; 1646 :     cur->content = xmlCopyElementContent(elem->content);

	mov	DWORD PTR [esi+40], eax

; 1647 :     /* TODO : rebuild the attribute list on the copy */
; 1648 :     cur->attributes = NULL;

	mov	DWORD PTR [esi+44], 0

; 1649 :     return(cur);

	mov	eax, esi
	pop	edi
	pop	esi

; 1650 : }

	pop	ebp
	ret	0
_xmlCopyElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeElementTableEntry
_TEXT	SEGMENT
_elem$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlFreeElementTableEntry PROC				; COMDAT

; 1601 : xmlFreeElementTableEntry(void *elem, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _elem$[ebp]
	call	_xmlFreeElement
	add	esp, 4

; 1602 :     xmlFreeElement((xmlElementPtr) elem);
; 1603 : }

	pop	ebp
	ret	0
_xmlFreeElementTableEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeElement
_TEXT	SEGMENT
_elem$ = 8						; size = 4
_xmlFreeElement PROC					; COMDAT

; 1358 : xmlFreeElement(xmlElementPtr elem) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _elem$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlFreeEle

; 1359 :     if (elem == NULL) return;
; 1360 :     xmlUnlinkNode((xmlNodePtr) elem);

	push	esi
	call	_xmlUnlinkNode

; 1361 :     xmlFreeDocElementContent(elem->doc, elem->content);

	push	DWORD PTR [esi+40]
	push	DWORD PTR [esi+32]
	call	_xmlFreeDocElementContent

; 1362 :     if (elem->name != NULL)

	mov	eax, DWORD PTR [esi+8]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@xmlFreeEle

; 1363 : 	xmlFree((xmlChar *) elem->name);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlFreeEle:

; 1364 :     if (elem->prefix != NULL)

	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN4@xmlFreeEle

; 1365 : 	xmlFree((xmlChar *) elem->prefix);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlFreeEle:

; 1366 : #ifdef LIBXML_REGEXP_ENABLED
; 1367 :     if (elem->contModel != NULL)

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN5@xmlFreeEle

; 1368 : 	xmlRegFreeRegexp(elem->contModel);

	push	eax
	call	_xmlRegFreeRegexp
	add	esp, 4
$LN5@xmlFreeEle:

; 1369 : #endif
; 1370 :     xmlFree(elem);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreeEle:
	pop	esi

; 1371 : }

	pop	ebp
	ret	0
_xmlFreeElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlDumpElementContent
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_content$ = 12						; size = 4
_glob$ = 16						; size = 4
_xmlDumpElementContent PROC				; COMDAT

; 1159 : xmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _content$[ebp]
	test	edi, edi
	je	$LN4@xmlDumpEle

; 1160 :     if (content == NULL) return;
; 1161 : 
; 1162 :     if (glob) xmlBufferWriteChar(buf, "(");

	cmp	DWORD PTR _glob$[ebp], 0
	push	esi
	mov	esi, DWORD PTR _buf$[ebp]
	je	SHORT $LN7@xmlDumpEle
	push	OFFSET ??_C@_01ODHLEDKK@?$CI@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8
$LN7@xmlDumpEle:

; 1163 :     switch (content->type) {

	mov	eax, DWORD PTR [edi]
	dec	eax
	cmp	eax, 3
	ja	$LN25@xmlDumpEle
	jmp	DWORD PTR $LN44@xmlDumpEle[eax*4]
$LN8@xmlDumpEle:

; 1164 :         case XML_ELEMENT_CONTENT_PCDATA:
; 1165 :             xmlBufferWriteChar(buf, "#PCDATA");

	push	OFFSET ??_C@_07ELDBONKP@?$CDPCDATA@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8

; 1166 : 	    break;

	jmp	$LN38@xmlDumpEle
$LN9@xmlDumpEle:

; 1167 : 	case XML_ELEMENT_CONTENT_ELEMENT:
; 1168 : 	    if (content->prefix != NULL) {

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN10@xmlDumpEle

; 1169 : 		xmlBufferWriteCHAR(buf, content->prefix);

	push	eax
	push	esi
	call	_xmlBufferWriteCHAR

; 1170 : 		xmlBufferWriteChar(buf, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 16					; 00000010H
$LN10@xmlDumpEle:

; 1171 : 	    }
; 1172 : 	    xmlBufferWriteCHAR(buf, content->name);

	push	DWORD PTR [edi+8]
	push	esi
	call	_xmlBufferWriteCHAR
	add	esp, 8

; 1173 : 	    break;

	jmp	$LN38@xmlDumpEle
$LN11@xmlDumpEle:

; 1174 : 	case XML_ELEMENT_CONTENT_SEQ:
; 1175 : 	    if ((content->c1 != NULL) &&

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN12@xmlDumpEle
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	SHORT $LN14@xmlDumpEle
	cmp	ecx, 3
	jne	SHORT $LN12@xmlDumpEle
$LN14@xmlDumpEle:

; 1176 : 	        ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
; 1177 : 	         (content->c1->type == XML_ELEMENT_CONTENT_SEQ)))
; 1178 : 		xmlDumpElementContent(buf, content->c1, 1);

	mov	ecx, 1
	jmp	SHORT $LN13@xmlDumpEle
$LN12@xmlDumpEle:

; 1179 : 	    else
; 1180 : 		xmlDumpElementContent(buf, content->c1, 0);

	xor	ecx, ecx
$LN13@xmlDumpEle:

; 1181 :             xmlBufferWriteChar(buf, " , ");

	push	ecx
	push	eax
	push	esi
	call	_xmlDumpElementContent
	push	OFFSET ??_C@_03NKFKBEPL@?5?0?5@
	push	esi
	call	_xmlBufferWriteChar

; 1182 : 	    if ((content->c2 != NULL) &&

	mov	eax, DWORD PTR [edi+16]
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN15@xmlDumpEle
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	SHORT $LN17@xmlDumpEle
	cmp	ecx, 3
$LN42@xmlDumpEle:

; 1203 : 	    else
; 1204 : 		xmlDumpElementContent(buf, content->c2, 0);
; 1205 : 	    break;
; 1206 : 	default:
; 1207 : 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
; 1208 : 		    "Internal: ELEMENT content corrupted invalid type\n",
; 1209 : 		    NULL);
; 1210 :     }
; 1211 :     if (glob)

	jne	SHORT $LN15@xmlDumpEle
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN15@xmlDumpEle
$LN17@xmlDumpEle:
	mov	ecx, 1
	push	ecx
	push	eax
	push	esi
	call	_xmlDumpElementContent
	add	esp, 12					; 0000000cH
	jmp	$LN38@xmlDumpEle
$LN15@xmlDumpEle:
	xor	ecx, ecx
	push	ecx
	push	eax
	push	esi
	call	_xmlDumpElementContent
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN38@xmlDumpEle
$LN18@xmlDumpEle:

; 1183 : 	        ((content->c2->type == XML_ELEMENT_CONTENT_OR) ||
; 1184 : 	         ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) &&
; 1185 : 		  (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE))))
; 1186 : 		xmlDumpElementContent(buf, content->c2, 1);
; 1187 : 	    else
; 1188 : 		xmlDumpElementContent(buf, content->c2, 0);
; 1189 : 	    break;
; 1190 : 	case XML_ELEMENT_CONTENT_OR:
; 1191 : 	    if ((content->c1 != NULL) &&

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN19@xmlDumpEle
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	SHORT $LN21@xmlDumpEle
	cmp	ecx, 3
	jne	SHORT $LN19@xmlDumpEle
$LN21@xmlDumpEle:

; 1192 : 	        ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
; 1193 : 	         (content->c1->type == XML_ELEMENT_CONTENT_SEQ)))
; 1194 : 		xmlDumpElementContent(buf, content->c1, 1);

	mov	ecx, 1
	jmp	SHORT $LN20@xmlDumpEle
$LN19@xmlDumpEle:

; 1195 : 	    else
; 1196 : 		xmlDumpElementContent(buf, content->c1, 0);

	xor	ecx, ecx
$LN20@xmlDumpEle:

; 1197 :             xmlBufferWriteChar(buf, " | ");

	push	ecx
	push	eax
	push	esi
	call	_xmlDumpElementContent
	push	OFFSET ??_C@_03LGOGDKEL@?5?$HM?5@
	push	esi
	call	_xmlBufferWriteChar

; 1198 : 	    if ((content->c2 != NULL) &&

	mov	eax, DWORD PTR [edi+16]
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN15@xmlDumpEle
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 3
	je	SHORT $LN17@xmlDumpEle
	cmp	ecx, 4

; 1199 : 	        ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||
; 1200 : 	         ((content->c2->type == XML_ELEMENT_CONTENT_OR) &&
; 1201 : 		  (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE))))
; 1202 : 		xmlDumpElementContent(buf, content->c2, 1);

	jmp	SHORT $LN42@xmlDumpEle
$LN25@xmlDumpEle:

; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0DC@GLPLFDD@Internal?3?5ELEMENT?5content?5corru@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1
	push	23					; 00000017H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN38@xmlDumpEle:

; 1203 : 	    else
; 1204 : 		xmlDumpElementContent(buf, content->c2, 0);
; 1205 : 	    break;
; 1206 : 	default:
; 1207 : 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
; 1208 : 		    "Internal: ELEMENT content corrupted invalid type\n",
; 1209 : 		    NULL);
; 1210 :     }
; 1211 :     if (glob)

	cmp	DWORD PTR _glob$[ebp], 0
	je	SHORT $LN26@xmlDumpEle

; 1212 :         xmlBufferWriteChar(buf, ")");

	push	OFFSET ??_C@_01PKGAHCOL@?$CJ@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8
$LN26@xmlDumpEle:

; 1213 :     switch (content->ocur) {

	mov	eax, DWORD PTR [edi+4]
	sub	eax, 2
	je	SHORT $LN28@xmlDumpEle
	sub	eax, 1
	je	SHORT $LN29@xmlDumpEle
	sub	eax, 1
	jne	SHORT $LN40@xmlDumpEle

; 1221 : 	    break;
; 1222 :         case XML_ELEMENT_CONTENT_PLUS:
; 1223 : 	    xmlBufferWriteChar(buf, "+");

	push	OFFSET ??_C@_01MIFGBAGJ@?$CL@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8
	pop	esi
	pop	edi

; 1224 : 	    break;
; 1225 :     }
; 1226 : }

	pop	ebp
	ret	0
$LN29@xmlDumpEle:

; 1218 : 	    break;
; 1219 :         case XML_ELEMENT_CONTENT_MULT:
; 1220 : 	    xmlBufferWriteChar(buf, "*");

	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8
	pop	esi
	pop	edi

; 1224 : 	    break;
; 1225 :     }
; 1226 : }

	pop	ebp
	ret	0
$LN28@xmlDumpEle:

; 1214 :         case XML_ELEMENT_CONTENT_ONCE:
; 1215 : 	    break;
; 1216 :         case XML_ELEMENT_CONTENT_OPT:
; 1217 : 	    xmlBufferWriteChar(buf, "?");

	push	OFFSET ??_C@_01OGPIMHDM@?$DP@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8
$LN40@xmlDumpEle:
	pop	esi
$LN4@xmlDumpEle:
	pop	edi

; 1224 : 	    break;
; 1225 :     }
; 1226 : }

	pop	ebp
	ret	0
$LN44@xmlDumpEle:
	DD	$LN8@xmlDumpEle
	DD	$LN9@xmlDumpEle
	DD	$LN11@xmlDumpEle
	DD	$LN18@xmlDumpEle
_xmlDumpElementContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidBuildAContentModel
_TEXT	SEGMENT
_fn$1 = -60						; size = 50
_ocur$1$ = -8						; size = 4
_oldend$1$ = -4						; size = 4
_oldend$1$ = -4						; size = 4
_oldstate$1$ = 8					; size = 4
_oldstate$1$ = 8					; size = 4
_oldstate$1$ = 8					; size = 4
_content$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlValidBuildAContentModel PROC			; COMDAT

; 661  : 		           const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	ecx, OFFSET __56F63275_valid@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _content$[ebp]
	test	esi, esi
	jne	SHORT $LN16@xmlValidBu

; 662  :     if (content == NULL) {
; 663  : 	xmlErrValidNode(ctxt, NULL, XML_ERR_INTERNAL_ERROR,

	push	esi
	push	esi
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0CL@FIAOIAHN@Found?5NULL?5content?5in?5content?5m@
	push	1
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 664  : 			"Found NULL content in content model of %s\n",
; 665  : 			name, NULL, NULL);
; 666  : 	return(0);

	xor	eax, eax
	pop	esi

; 801  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlValidBu:

; 667  :     }
; 668  :     switch (content->type) {

	mov	eax, DWORD PTR [esi]
	dec	eax
	push	ebx
	push	edi
	cmp	eax, 3
	ja	$LN40@xmlValidBu
	jmp	DWORD PTR $LN70@xmlValidBu[eax*4]
$LN17@xmlValidBu:

; 669  : 	case XML_ELEMENT_CONTENT_PCDATA:
; 670  : 	    xmlErrValidNode(ctxt, NULL, XML_ERR_INTERNAL_ERROR,

	push	0
	push	0
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0CF@IIHAKBAI@Found?5PCDATA?5in?5content?5model?5o@
	push	1
	push	0
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 796  : 	                "ContentModel broken for element %s\n",
; 797  : 			(const char *) name);
; 798  : 	    return(0);

	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 801  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlValidBu:

; 671  : 			    "Found PCDATA in content model of %s\n",
; 672  : 		            name, NULL, NULL);
; 673  : 	    return(0);
; 674  : 	    break;
; 675  : 	case XML_ELEMENT_CONTENT_ELEMENT: {
; 676  : 	    xmlAutomataStatePtr oldstate = ctxt->state;

	mov	edi, DWORD PTR _ctxt$[ebp]

; 677  : 	    xmlChar fn[50];
; 678  : 	    xmlChar *fullname;
; 679  : 
; 680  : 	    fullname = xmlBuildQName(content->name, content->prefix, fn, 50);

	push	50					; 00000032H
	mov	eax, DWORD PTR [edi+60]
	mov	DWORD PTR _oldstate$1$[ebp], eax
	lea	eax, DWORD PTR _fn$1[ebp]
	push	eax
	push	DWORD PTR [esi+24]
	push	DWORD PTR [esi+8]
	call	_xmlBuildQName
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 681  : 	    if (fullname == NULL) {

	test	ebx, ebx
	jne	SHORT $LN19@xmlValidBu

; 682  : 	        xmlVErrMemory(ctxt, "Building content model");

	push	OFFSET ??_C@_0BH@INHICIGB@Building?5content?5model@
	push	edi
	call	_xmlVErrMemory
	add	esp, 8

; 796  : 	                "ContentModel broken for element %s\n",
; 797  : 			(const char *) name);
; 798  : 	    return(0);

	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 801  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlValidBu:

; 683  : 		return(0);
; 684  : 	    }
; 685  : 
; 686  : 	    switch (content->ocur) {

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	cmp	eax, 3
	ja	$LN4@xmlValidBu
	jmp	DWORD PTR $LN71@xmlValidBu[eax*4]
$LN20@xmlValidBu:

; 687  : 		case XML_ELEMENT_CONTENT_ONCE:
; 688  : 		    ctxt->state = xmlAutomataNewTransition(ctxt->am,

	push	0
	push	ebx
	push	0
	push	DWORD PTR [edi+60]
	push	DWORD PTR [edi+56]
	call	_xmlAutomataNewTransition
	add	esp, 20					; 00000014H
	mov	DWORD PTR [edi+60], eax

; 689  : 			    ctxt->state, NULL, fullname, NULL);
; 690  : 		    break;

	jmp	SHORT $LN4@xmlValidBu
$LN21@xmlValidBu:

; 691  : 		case XML_ELEMENT_CONTENT_OPT:
; 692  : 		    ctxt->state = xmlAutomataNewTransition(ctxt->am,

	push	0
	push	ebx
	push	0
	push	DWORD PTR [edi+60]
	push	DWORD PTR [edi+56]
	call	_xmlAutomataNewTransition

; 693  : 			    ctxt->state, NULL, fullname, NULL);
; 694  : 		    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);

	push	eax
	push	DWORD PTR _oldstate$1$[ebp]
	mov	DWORD PTR [edi+60], eax
	push	DWORD PTR [edi+56]
	call	_xmlAutomataNewEpsilon

; 695  : 		    break;

	jmp	SHORT $LN67@xmlValidBu
$LN22@xmlValidBu:

; 696  : 		case XML_ELEMENT_CONTENT_PLUS:
; 697  : 		    ctxt->state = xmlAutomataNewTransition(ctxt->am,

	push	0
	push	ebx
	push	0
	push	DWORD PTR [edi+60]
	push	DWORD PTR [edi+56]
	call	_xmlAutomataNewTransition

; 698  : 			    ctxt->state, NULL, fullname, NULL);
; 699  : 		    xmlAutomataNewTransition(ctxt->am, ctxt->state,

	push	0
	push	ebx
	push	eax
	push	eax
	push	DWORD PTR [edi+56]
	mov	DWORD PTR [edi+60], eax
	call	_xmlAutomataNewTransition
	add	esp, 40					; 00000028H

; 700  : 			                     ctxt->state, fullname, NULL);
; 701  : 		    break;

	jmp	SHORT $LN4@xmlValidBu
$LN23@xmlValidBu:

; 702  : 		case XML_ELEMENT_CONTENT_MULT:
; 703  : 		    ctxt->state = xmlAutomataNewEpsilon(ctxt->am,

	push	0
	push	DWORD PTR [edi+60]
	push	DWORD PTR [edi+56]
	call	_xmlAutomataNewEpsilon

; 704  : 					    ctxt->state, NULL);
; 705  : 		    xmlAutomataNewTransition(ctxt->am,

	push	0
	push	ebx
	push	eax
	push	eax
	push	DWORD PTR [edi+56]
	mov	DWORD PTR [edi+60], eax
	call	_xmlAutomataNewTransition
$LN67@xmlValidBu:

; 706  : 			    ctxt->state, ctxt->state, fullname, NULL);
; 707  : 		    break;
; 708  : 	    }
; 709  : 	    if ((fullname != fn) && (fullname != content->name))

	add	esp, 32					; 00000020H
$LN4@xmlValidBu:
	lea	eax, DWORD PTR _fn$1[ebp]
	cmp	ebx, eax
	je	$LN14@xmlValidBu
	cmp	ebx, DWORD PTR [esi+8]
	je	$LN14@xmlValidBu

; 710  : 		xmlFree(fullname);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 799  :     }
; 800  :     return(1);

	mov	eax, 1
	pop	edi
	pop	ebx
	pop	esi

; 801  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlValidBu:

; 711  : 	    break;
; 712  : 	}
; 713  : 	case XML_ELEMENT_CONTENT_SEQ: {
; 714  : 	    xmlAutomataStatePtr oldstate, oldend;
; 715  : 	    xmlElementContentOccur ocur;
; 716  : 
; 717  : 	    /*
; 718  : 	     * Simply iterate over the content
; 719  : 	     */
; 720  : 	    oldstate = ctxt->state;

	mov	edi, DWORD PTR _ctxt$[ebp]

; 721  : 	    ocur = content->ocur;

	mov	ebx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+60]
	mov	DWORD PTR _oldstate$1$[ebp], eax

; 722  : 	    if (ocur != XML_ELEMENT_CONTENT_ONCE) {

	cmp	ebx, 1
	je	SHORT $LL8@xmlValidBu

; 723  : 		ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldstate, NULL);

	push	0
	push	eax
	push	DWORD PTR [edi+56]
	call	_xmlAutomataNewEpsilon
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _oldstate$1$[ebp], eax
	mov	DWORD PTR [edi+60], eax
	npad	5
$LL8@xmlValidBu:

; 724  : 		oldstate = ctxt->state;
; 725  : 	    }
; 726  : 	    do {
; 727  : 		xmlValidBuildAContentModel(content->c1, ctxt, name);

	push	DWORD PTR _name$[ebp]
	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlValidBuildAContentModel

; 728  : 		content = content->c2;

	mov	esi, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH

; 729  : 	    } while ((content->type == XML_ELEMENT_CONTENT_SEQ) &&

	cmp	DWORD PTR [esi], 3
	jne	SHORT $LN27@xmlValidBu
	cmp	DWORD PTR [esi+4], 1
	je	SHORT $LL8@xmlValidBu
$LN27@xmlValidBu:

; 730  : 		     (content->ocur == XML_ELEMENT_CONTENT_ONCE));
; 731  : 	    xmlValidBuildAContentModel(content, ctxt, name);

	push	DWORD PTR _name$[ebp]
	push	edi
	push	esi
	call	_xmlValidBuildAContentModel

; 732  : 	    oldend = ctxt->state;

	mov	eax, DWORD PTR [edi+60]

; 733  : 	    ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldend, NULL);

	push	0
	push	eax
	push	DWORD PTR [edi+56]
	mov	DWORD PTR _oldend$1$[ebp], eax
	call	_xmlAutomataNewEpsilon
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+60], eax

; 734  : 	    switch (ocur) {

	sub	ebx, 2
	je	SHORT $LN29@xmlValidBu
	sub	ebx, 1
	je	SHORT $LN30@xmlValidBu
	sub	ebx, 1
	jne	$LN14@xmlValidBu

; 743  : 		    break;
; 744  : 		case XML_ELEMENT_CONTENT_PLUS:
; 745  : 		    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);

	mov	esi, DWORD PTR _oldstate$1$[ebp]
	push	esi
	push	DWORD PTR _oldend$1$[ebp]
	jmp	$LN68@xmlValidBu
$LN30@xmlValidBu:

; 739  : 		    break;
; 740  : 		case XML_ELEMENT_CONTENT_MULT:
; 741  : 		    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);

	mov	esi, DWORD PTR _oldstate$1$[ebp]
	push	eax
	push	esi
	push	DWORD PTR [edi+56]
	call	_xmlAutomataNewEpsilon

; 742  : 		    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);

	push	esi
	push	DWORD PTR _oldend$1$[ebp]
	push	DWORD PTR [edi+56]
	call	_xmlAutomataNewEpsilon
	add	esp, 24					; 00000018H

; 799  :     }
; 800  :     return(1);

	mov	eax, 1
	pop	edi
	pop	ebx
	pop	esi

; 801  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlValidBu:

; 735  : 		case XML_ELEMENT_CONTENT_ONCE:
; 736  : 		    break;
; 737  : 		case XML_ELEMENT_CONTENT_OPT:
; 738  : 		    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);

	mov	esi, DWORD PTR _oldstate$1$[ebp]
	push	eax
	push	esi

; 746  : 		    break;
; 747  : 	    }
; 748  : 	    break;

	jmp	$LN68@xmlValidBu
$LN32@xmlValidBu:

; 749  : 	}
; 750  : 	case XML_ELEMENT_CONTENT_OR: {
; 751  : 	    xmlAutomataStatePtr oldstate, oldend;
; 752  : 	    xmlElementContentOccur ocur;
; 753  : 
; 754  : 	    ocur = content->ocur;

	mov	ebx, DWORD PTR [esi+4]

; 755  : 	    if ((ocur == XML_ELEMENT_CONTENT_PLUS) ||

	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _ocur$1$[ebp], ebx
	cmp	ebx, 4
	je	SHORT $LN34@xmlValidBu
	cmp	ebx, 3
	jne	SHORT $LN33@xmlValidBu
$LN34@xmlValidBu:

; 756  : 		(ocur == XML_ELEMENT_CONTENT_MULT)) {
; 757  : 		ctxt->state = xmlAutomataNewEpsilon(ctxt->am,

	push	0
	push	DWORD PTR [edi+60]
	push	DWORD PTR [edi+56]
	call	_xmlAutomataNewEpsilon
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+60], eax
$LN33@xmlValidBu:

; 758  : 			ctxt->state, NULL);
; 759  : 	    }
; 760  : 	    oldstate = ctxt->state;

	mov	eax, DWORD PTR [edi+60]

; 761  : 	    oldend = xmlAutomataNewState(ctxt->am);

	push	DWORD PTR [edi+56]
	mov	DWORD PTR _oldstate$1$[ebp], eax
	call	_xmlAutomataNewState
	mov	ebx, DWORD PTR _oldstate$1$[ebp]
	add	esp, 4
	mov	DWORD PTR _oldend$1$[ebp], eax
	npad	4
$LL13@xmlValidBu:

; 762  : 
; 763  : 	    /*
; 764  : 	     * iterate over the subtypes and remerge the end with an
; 765  : 	     * epsilon transition
; 766  : 	     */
; 767  : 	    do {
; 768  : 		ctxt->state = oldstate;
; 769  : 		xmlValidBuildAContentModel(content->c1, ctxt, name);

	push	DWORD PTR _name$[ebp]
	mov	DWORD PTR [edi+60], ebx
	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlValidBuildAContentModel

; 770  : 		xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldend);

	push	DWORD PTR _oldend$1$[ebp]
	push	DWORD PTR [edi+60]
	push	DWORD PTR [edi+56]
	call	_xmlAutomataNewEpsilon

; 771  : 		content = content->c2;

	mov	esi, DWORD PTR [esi+16]
	add	esp, 24					; 00000018H

; 772  : 	    } while ((content->type == XML_ELEMENT_CONTENT_OR) &&

	cmp	DWORD PTR [esi], 4
	jne	SHORT $LN35@xmlValidBu
	cmp	DWORD PTR [esi+4], 1
	je	SHORT $LL13@xmlValidBu
$LN35@xmlValidBu:

; 773  : 		     (content->ocur == XML_ELEMENT_CONTENT_ONCE));
; 774  : 	    ctxt->state = oldstate;
; 775  : 	    xmlValidBuildAContentModel(content, ctxt, name);

	push	DWORD PTR _name$[ebp]
	mov	eax, ebx
	push	edi
	push	esi
	mov	DWORD PTR [edi+60], eax
	call	_xmlValidBuildAContentModel

; 776  : 	    xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldend);

	mov	esi, DWORD PTR _oldend$1$[ebp]
	push	esi
	push	DWORD PTR [edi+60]
	push	DWORD PTR [edi+56]
	call	_xmlAutomataNewEpsilon

; 777  : 	    ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldend, NULL);

	push	0
	push	esi
	push	DWORD PTR [edi+56]
	call	_xmlAutomataNewEpsilon

; 778  : 	    switch (ocur) {

	mov	ebx, DWORD PTR _ocur$1$[ebp]
	add	esp, 36					; 00000024H
	mov	DWORD PTR [edi+60], eax
	sub	ebx, 2
	je	SHORT $LN37@xmlValidBu
	sub	ebx, 1
	je	SHORT $LN38@xmlValidBu
	sub	ebx, 1
	jne	SHORT $LN14@xmlValidBu

; 787  : 		    break;
; 788  : 		case XML_ELEMENT_CONTENT_PLUS:
; 789  : 		    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);

	push	DWORD PTR _oldstate$1$[ebp]
	push	esi
	jmp	SHORT $LN68@xmlValidBu
$LN38@xmlValidBu:

; 783  : 		    break;
; 784  : 		case XML_ELEMENT_CONTENT_MULT:
; 785  : 		    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);

	mov	ebx, DWORD PTR _oldstate$1$[ebp]
	push	eax
	push	ebx
	push	DWORD PTR [edi+56]
	call	_xmlAutomataNewEpsilon

; 786  : 		    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);

	push	ebx
	push	esi
	push	DWORD PTR [edi+56]
	call	_xmlAutomataNewEpsilon
	add	esp, 24					; 00000018H

; 799  :     }
; 800  :     return(1);

	mov	eax, 1
	pop	edi
	pop	ebx
	pop	esi

; 801  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@xmlValidBu:

; 779  : 		case XML_ELEMENT_CONTENT_ONCE:
; 780  : 		    break;
; 781  : 		case XML_ELEMENT_CONTENT_OPT:
; 782  : 		    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);

	push	eax
	push	DWORD PTR _oldstate$1$[ebp]
$LN68@xmlValidBu:

; 799  :     }
; 800  :     return(1);

	push	DWORD PTR [edi+56]
	call	_xmlAutomataNewEpsilon
	add	esp, 12					; 0000000cH
$LN14@xmlValidBu:
	pop	edi
	pop	ebx
	mov	eax, 1
	pop	esi

; 801  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@xmlValidBu:

; 790  : 		    break;
; 791  : 	    }
; 792  : 	    break;
; 793  : 	}
; 794  : 	default:
; 795  : 	    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,

	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0CE@LMBMADBI@ContentModel?5broken?5for?5element@
	push	1
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValid
	add	esp, 16					; 00000010H

; 796  : 	                "ContentModel broken for element %s\n",
; 797  : 			(const char *) name);
; 798  : 	    return(0);

	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 801  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN70@xmlValidBu:
	DD	$LN17@xmlValidBu
	DD	$LN18@xmlValidBu
	DD	$LN25@xmlValidBu
	DD	$LN32@xmlValidBu
$LN71@xmlValidBu:
	DD	$LN20@xmlValidBu
	DD	$LN21@xmlValidBu
	DD	$LN23@xmlValidBu
	DD	$LN22@xmlValidBu
_xmlValidBuildAContentModel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _nodeVPop
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nodeVPop PROC						; COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	test	ecx, ecx
	jg	SHORT $LN2@nodeVPop

; 468  :     xmlNodePtr ret;
; 469  : 
; 470  :     if (ctxt->nodeNr <= 0)
; 471  :         return (NULL);

	xor	eax, eax

; 480  : }

	pop	ebp
	ret	0
$LN2@nodeVPop:

; 472  :     ctxt->nodeNr--;

	dec	ecx
	mov	DWORD PTR [edx+16], ecx

; 473  :     if (ctxt->nodeNr > 0)

	test	ecx, ecx
	jle	SHORT $LN3@nodeVPop

; 474  :         ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];

	mov	eax, DWORD PTR [edx+24]
	mov	eax, DWORD PTR [eax+ecx*4-4]

; 477  :     ret = ctxt->nodeTab[ctxt->nodeNr];

	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [edx+24]
	mov	edx, DWORD PTR [eax+ecx*4]

; 478  :     ctxt->nodeTab[ctxt->nodeNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 479  :     return (ret);

	mov	eax, edx

; 480  : }

	pop	ebp
	ret	0
$LN3@nodeVPop:

; 475  :     else
; 476  :         ctxt->node = NULL;

	xor	eax, eax

; 477  :     ret = ctxt->nodeTab[ctxt->nodeNr];

	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [edx+24]
	mov	edx, DWORD PTR [eax+ecx*4]

; 478  :     ctxt->nodeTab[ctxt->nodeNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 479  :     return (ret);

	mov	eax, edx

; 480  : }

	pop	ebp
	ret	0
_nodeVPop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _nodeVPush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_nodeVPush PROC						; COMDAT

; 438  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+20], 0
	jg	SHORT $LN10@nodeVPush

; 439  :     if (ctxt->nodeMax <= 0) {
; 440  :         ctxt->nodeMax = 4;

	push	16					; 00000010H
	mov	DWORD PTR [esi+20], 4

; 441  :         ctxt->nodeTab =

	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+24], eax

; 442  :             (xmlNodePtr *) xmlMalloc(ctxt->nodeMax *
; 443  :                                      sizeof(ctxt->nodeTab[0]));
; 444  :         if (ctxt->nodeTab == NULL) {

	test	eax, eax
	jne	SHORT $LN10@nodeVPush

; 445  : 	    xmlVErrMemory(ctxt, "malloc failed");

	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	esi
	call	_xmlVErrMemory
	add	esp, 8

; 446  :             ctxt->nodeMax = 0;

	mov	DWORD PTR [esi+20], 0

; 447  :             return (0);

	xor	eax, eax
	pop	esi

; 464  : }

	pop	ebp
	ret	0
$LN10@nodeVPush:

; 448  :         }
; 449  :     }
; 450  :     if (ctxt->nodeNr >= ctxt->nodeMax) {

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+20]
	cmp	edx, eax
	jl	SHORT $LN11@nodeVPush

; 451  :         xmlNodePtr *tmp;
; 452  :         tmp = (xmlNodePtr *) xmlRealloc(ctxt->nodeTab,

	shl	eax, 3
	push	eax
	push	DWORD PTR [esi+24]
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8

; 453  : 			      ctxt->nodeMax * 2 * sizeof(ctxt->nodeTab[0]));
; 454  :         if (tmp == NULL) {

	test	ecx, ecx
	jne	SHORT $LN5@nodeVPush

; 455  : 	    xmlVErrMemory(ctxt, "realloc failed");

	push	OFFSET ??_C@_0P@BHJOIPMJ@realloc?5failed@
	push	esi
	call	_xmlVErrMemory
	add	esp, 8

; 456  :             return (0);

	xor	eax, eax
	pop	esi

; 464  : }

	pop	ebp
	ret	0
$LN5@nodeVPush:

; 457  :         }
; 458  :         ctxt->nodeMax *= 2;

	mov	eax, DWORD PTR [esi+20]

; 459  : 	ctxt->nodeTab = tmp;

	mov	edx, DWORD PTR [esi+16]
	add	eax, eax
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], ecx
$LN11@nodeVPush:

; 460  :     }
; 461  :     ctxt->nodeTab[ctxt->nodeNr] = value;

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 462  :     ctxt->node = value;
; 463  :     return (ctxt->nodeNr++);

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+12], ecx
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+16], ecx
	pop	esi

; 464  : }

	pop	ebp
	ret	0
_nodeVPush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _vstateVPop
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_vstateVPop PROC					; COMDAT

; 318  : vstateVPop(xmlValidCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [esi+44]
	cmp	edx, 1
	jge	SHORT $LN2@vstateVPop

; 319  :     xmlElementPtr elemDecl;
; 320  : 
; 321  :     if (ctxt->vstateNr < 1) return(-1);

	or	eax, -1
	pop	esi

; 335  : }

	pop	ebp
	ret	0
$LN2@vstateVPop:

; 322  :     ctxt->vstateNr--;
; 323  :     elemDecl = ctxt->vstateTab[ctxt->vstateNr].elemDecl;

	mov	ecx, DWORD PTR [esi+52]
	dec	edx
	mov	DWORD PTR [esi+44], edx
	push	edi
	lea	eax, DWORD PTR [edx+edx*2]
	mov	edi, DWORD PTR [ecx+eax*4]

; 324  :     ctxt->vstateTab[ctxt->vstateNr].elemDecl = NULL;

	lea	eax, DWORD PTR [edx+edx*2]
	mov	DWORD PTR [ecx+eax*4], 0

; 325  :     ctxt->vstateTab[ctxt->vstateNr].node = NULL;

	mov	eax, DWORD PTR [esi+44]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [eax+ecx*4+4], 0

; 326  :     if ((elemDecl != NULL) && (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT)) {

	test	edi, edi
	je	SHORT $LN3@vstateVPop
	cmp	DWORD PTR [edi+36], 4
	jne	SHORT $LN3@vstateVPop

; 327  : 	xmlRegFreeExecCtxt(ctxt->vstateTab[ctxt->vstateNr].exec);

	mov	eax, DWORD PTR [esi+44]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+52]
	push	DWORD PTR [eax+ecx*4+8]
	call	_xmlRegFreeExecCtxt
	add	esp, 4
$LN3@vstateVPop:

; 328  :     }
; 329  :     ctxt->vstateTab[ctxt->vstateNr].exec = NULL;

	mov	eax, DWORD PTR [esi+44]

; 330  :     if (ctxt->vstateNr >= 1)

	pop	edi
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [eax+ecx*4+8], 0
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 1
	jl	SHORT $LN4@vstateVPop

; 331  : 	ctxt->vstate = &ctxt->vstateTab[ctxt->vstateNr - 1];

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+52]
	lea	eax, DWORD PTR [eax+ecx*4]
	add	eax, -12				; fffffff4H

; 334  :     return(ctxt->vstateNr);

	mov	DWORD PTR [esi+40], eax
	mov	eax, DWORD PTR [esi+44]
	pop	esi

; 335  : }

	pop	ebp
	ret	0
$LN4@vstateVPop:

; 332  :     else
; 333  : 	ctxt->vstate = NULL;

	xor	eax, eax

; 334  :     return(ctxt->vstateNr);

	mov	DWORD PTR [esi+40], eax
	mov	eax, DWORD PTR [esi+44]
	pop	esi

; 335  : }

	pop	ebp
	ret	0
_vstateVPop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _vstateVPush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_elemDecl$ = 12						; size = 4
_node$ = 16						; size = 4
_vstateVPush PROC					; COMDAT

; 274  : vstateVPush(xmlValidCtxtPtr ctxt, xmlElementPtr elemDecl, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN14@vstateVPus

; 275  :     if ((ctxt->vstateMax == 0) || (ctxt->vstateTab == NULL)) {

	mov	ecx, DWORD PTR [esi+52]
	test	ecx, ecx
	jne	SHORT $LN4@vstateVPus
$LN14@vstateVPus:

; 276  : 	ctxt->vstateMax = 10;
; 277  : 	ctxt->vstateTab = (xmlValidState *) xmlMalloc(ctxt->vstateMax *

	push	120					; 00000078H
	mov	DWORD PTR [esi+48], 10			; 0000000aH
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [esi+52], ecx

; 278  : 		              sizeof(ctxt->vstateTab[0]));
; 279  :         if (ctxt->vstateTab == NULL) {

	test	ecx, ecx
	jne	SHORT $LN13@vstateVPus

; 280  : 	    xmlVErrMemory(ctxt, "malloc failed");

	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	esi
	call	_xmlVErrMemory
	add	esp, 8

; 281  : 	    return(-1);

	or	eax, -1
	pop	edi

; 315  : }

	pop	esi
	pop	ebp
	ret	0
$LN13@vstateVPus:

; 275  :     if ((ctxt->vstateMax == 0) || (ctxt->vstateTab == NULL)) {

	mov	eax, DWORD PTR [esi+48]
$LN4@vstateVPus:

; 282  : 	}
; 283  :     }
; 284  : 
; 285  :     if (ctxt->vstateNr >= ctxt->vstateMax) {

	mov	edx, DWORD PTR [esi+44]
	cmp	edx, eax
	jl	SHORT $LN15@vstateVPus

; 286  :         xmlValidState *tmp;
; 287  : 
; 288  : 	tmp = (xmlValidState *) xmlRealloc(ctxt->vstateTab,

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 3
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8

; 289  : 	             2 * ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));
; 290  :         if (tmp == NULL) {

	test	ecx, ecx
	jne	SHORT $LN6@vstateVPus

; 291  : 	    xmlVErrMemory(ctxt, "realloc failed");

	push	OFFSET ??_C@_0P@BHJOIPMJ@realloc?5failed@
	push	esi
	call	_xmlVErrMemory
	add	esp, 8

; 292  : 	    return(-1);

	or	eax, -1
	pop	edi

; 315  : }

	pop	esi
	pop	ebp
	ret	0
$LN6@vstateVPus:

; 293  : 	}
; 294  : 	ctxt->vstateMax *= 2;

	mov	eax, DWORD PTR [esi+48]

; 295  : 	ctxt->vstateTab = tmp;

	mov	edx, DWORD PTR [esi+44]
	add	eax, eax
	mov	DWORD PTR [esi+48], eax
	mov	DWORD PTR [esi+52], ecx
$LN15@vstateVPus:

; 296  :     }
; 297  :     ctxt->vstate = &ctxt->vstateTab[ctxt->vstateNr];

	lea	eax, DWORD PTR [edx+edx*2]

; 298  :     ctxt->vstateTab[ctxt->vstateNr].elemDecl = elemDecl;
; 299  :     ctxt->vstateTab[ctxt->vstateNr].node = node;

	mov	edx, DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+40], eax
	push	ebx
	mov	ebx, DWORD PTR _elemDecl$[ebp]
	mov	DWORD PTR [eax], ebx
	mov	eax, DWORD PTR [esi+44]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [eax+ecx*4+4], edx

; 300  :     if ((elemDecl != NULL) && (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT)) {

	test	ebx, ebx
	je	SHORT $LN10@vstateVPus
	cmp	DWORD PTR [ebx+36], 4
	jne	SHORT $LN10@vstateVPus

; 301  : 	if (elemDecl->contModel == NULL)

	mov	eax, DWORD PTR [ebx+52]
	test	eax, eax
	jne	SHORT $LN17@vstateVPus

; 302  : 	    xmlValidBuildContentModel(ctxt, elemDecl);

	push	ebx
	push	esi
	call	_xmlValidBuildContentModel
	mov	eax, DWORD PTR [ebx+52]
	add	esp, 8
	mov	edx, DWORD PTR _node$[ebp]

; 303  : 	if (elemDecl->contModel != NULL) {

	test	eax, eax
	je	SHORT $LN9@vstateVPus
$LN17@vstateVPus:

; 304  : 	    ctxt->vstateTab[ctxt->vstateNr].exec =

	push	0
	push	0
	push	eax
	call	_xmlRegNewExecCtxt
	mov	ecx, DWORD PTR [esi+44]
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR [esi+52]

; 309  : 	                    XML_ERR_INTERNAL_ERROR,
; 310  : 			    "Failed to build content model regexp for %s\n",
; 311  : 			    node->name, NULL, NULL);
; 312  : 	}
; 313  :     }
; 314  :     return(ctxt->vstateNr++);

	pop	ebx
	pop	edi
	mov	DWORD PTR [ecx+edx*4+8], eax
	mov	eax, DWORD PTR [esi+44]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+44], ecx

; 315  : }

	pop	esi
	pop	ebp
	ret	0
$LN9@vstateVPus:

; 305  : 		xmlRegNewExecCtxt(elemDecl->contModel, NULL, NULL);
; 306  : 	} else {
; 307  : 	    ctxt->vstateTab[ctxt->vstateNr].exec = NULL;

	mov	eax, DWORD PTR [esi+44]

; 308  : 	    xmlErrValidNode(ctxt, (xmlNodePtr) elemDecl,

	push	0
	push	0
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [eax+ecx*4+8], 0
	push	DWORD PTR [edx+8]
	push	OFFSET ??_C@_0CN@GEBFHDLO@Failed?5to?5build?5content?5model?5r@
	push	1
	push	ebx
	push	esi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
$LN10@vstateVPus:

; 309  : 	                    XML_ERR_INTERNAL_ERROR,
; 310  : 			    "Failed to build content model regexp for %s\n",
; 311  : 			    node->name, NULL, NULL);
; 312  : 	}
; 313  :     }
; 314  :     return(ctxt->vstateNr++);

	mov	eax, DWORD PTR [esi+44]
	pop	ebx
	pop	edi
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+44], ecx

; 315  : }

	pop	esi
	pop	ebp
	ret	0
_vstateVPush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlErrValidWarning
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_error$ = 16						; size = 4
_msg$ = 20						; size = 4
_str1$ = 24						; size = 4
_str2$ = 28						; size = 4
_str3$ = 32						; size = 4
_xmlErrValidWarning PROC				; COMDAT

; 229  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	xor	edi, edi
	xor	esi, esi
	test	eax, eax
	je	SHORT $LN5@xmlErrVali

; 230  :     xmlStructuredErrorFunc schannel = NULL;
; 231  :     xmlGenericErrorFunc channel = NULL;
; 232  :     xmlParserCtxtPtr pctxt = NULL;
; 233  :     void *data = NULL;
; 234  : 
; 235  :     if (ctxt != NULL) {
; 236  :         channel = ctxt->warning;

	mov	ecx, DWORD PTR [eax+28]
	mov	ebx, DWORD PTR [eax+8]

; 237  :         data = ctxt->userData;

	mov	esi, DWORD PTR [eax]

; 238  : 	/* Use the special values to detect if it is part of a parsing
; 239  : 	   context */
; 240  : 	if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||

	cmp	ecx, -1412623820			; abcd1234H
	je	SHORT $LN4@xmlErrVali
	cmp	ecx, -1412623819			; abcd1235H
	jne	SHORT $LN5@xmlErrVali
$LN4@xmlErrVali:

; 241  : 	    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {
; 242  : 	    long delta = (char *) ctxt - (char *) ctxt->userData;

	sub	eax, esi

; 243  : 	    if ((delta > 0) && (delta < 250))

	dec	eax
	cmp	eax, 248				; 000000f8H
	cmovbe	edi, esi
$LN5@xmlErrVali:

; 244  : 		pctxt = ctxt->userData;
; 245  : 	}
; 246  :     }
; 247  :     __xmlRaiseError(schannel, channel, data, pctxt, node, XML_FROM_VALID, error,

	mov	edx, DWORD PTR _str3$[ebp]
	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	edx
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	edx
	push	ecx
	push	eax
	push	0
	push	0
	push	1
	push	DWORD PTR _error$[ebp]
	push	23					; 00000017H
	push	DWORD PTR _node$[ebp]
	push	edi
	push	esi
	push	ebx
	push	0
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH
	pop	edi
	pop	esi
	pop	ebx

; 248  :                     XML_ERR_WARNING, NULL, 0,
; 249  :                     (const char *) str1,
; 250  :                     (const char *) str2,
; 251  :                     (const char *) str3, 0, 0, msg, str1, str2, str3);
; 252  : }

	pop	ebp
	ret	0
_xmlErrValidWarning ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlErrValidNodeNr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_error$ = 16						; size = 4
_msg$ = 20						; size = 4
_str1$ = 24						; size = 4
_int2$ = 28						; size = 4
_str3$ = 32						; size = 4
_xmlErrValidNodeNr PROC					; COMDAT

; 188  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	xor	edi, edi
	xor	esi, esi
	test	eax, eax
	je	SHORT $LN5@xmlErrVali

; 189  :     xmlStructuredErrorFunc schannel = NULL;
; 190  :     xmlGenericErrorFunc channel = NULL;
; 191  :     xmlParserCtxtPtr pctxt = NULL;
; 192  :     void *data = NULL;
; 193  : 
; 194  :     if (ctxt != NULL) {
; 195  :         channel = ctxt->error;

	mov	ecx, DWORD PTR [eax+28]
	mov	ebx, DWORD PTR [eax+4]

; 196  :         data = ctxt->userData;

	mov	esi, DWORD PTR [eax]

; 197  : 	/* Use the special values to detect if it is part of a parsing
; 198  : 	   context */
; 199  : 	if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||

	cmp	ecx, -1412623820			; abcd1234H
	je	SHORT $LN4@xmlErrVali
	cmp	ecx, -1412623819			; abcd1235H
	jne	SHORT $LN5@xmlErrVali
$LN4@xmlErrVali:

; 200  : 	    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {
; 201  : 	    long delta = (char *) ctxt - (char *) ctxt->userData;

	sub	eax, esi

; 202  : 	    if ((delta > 0) && (delta < 250))

	dec	eax
	cmp	eax, 248				; 000000f8H
	cmovbe	edi, esi
$LN5@xmlErrVali:

; 203  : 		pctxt = ctxt->userData;
; 204  : 	}
; 205  :     }
; 206  :     __xmlRaiseError(schannel, channel, data, pctxt, node, XML_FROM_VALID, error,

	mov	edx, DWORD PTR _str3$[ebp]
	mov	eax, DWORD PTR _int2$[ebp]
	mov	ecx, DWORD PTR _str1$[ebp]
	push	edx
	push	eax
	push	ecx
	push	DWORD PTR _msg$[ebp]
	push	0
	push	eax
	push	0
	push	edx
	push	ecx
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	23					; 00000017H
	push	DWORD PTR _node$[ebp]
	push	edi
	push	esi
	push	ebx
	push	0
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH
	pop	edi
	pop	esi
	pop	ebx

; 207  :                     XML_ERR_ERROR, NULL, 0,
; 208  :                     (const char *) str1,
; 209  :                     (const char *) str3,
; 210  :                     NULL, int2, 0, msg, str1, int2, str3);
; 211  : }

	pop	ebp
	ret	0
_xmlErrValidNodeNr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlErrValidNode
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_error$ = 16						; size = 4
_msg$ = 20						; size = 4
_str1$ = 24						; size = 4
_str2$ = 28						; size = 4
_str3$ = 32						; size = 4
_xmlErrValidNode PROC					; COMDAT

; 145  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	xor	edi, edi
	xor	esi, esi
	test	eax, eax
	je	SHORT $LN5@xmlErrVali

; 146  :     xmlStructuredErrorFunc schannel = NULL;
; 147  :     xmlGenericErrorFunc channel = NULL;
; 148  :     xmlParserCtxtPtr pctxt = NULL;
; 149  :     void *data = NULL;
; 150  : 
; 151  :     if (ctxt != NULL) {
; 152  :         channel = ctxt->error;

	mov	ecx, DWORD PTR [eax+28]
	mov	ebx, DWORD PTR [eax+4]

; 153  :         data = ctxt->userData;

	mov	esi, DWORD PTR [eax]

; 154  : 	/* Use the special values to detect if it is part of a parsing
; 155  : 	   context */
; 156  : 	if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||

	cmp	ecx, -1412623820			; abcd1234H
	je	SHORT $LN4@xmlErrVali
	cmp	ecx, -1412623819			; abcd1235H
	jne	SHORT $LN5@xmlErrVali
$LN4@xmlErrVali:

; 157  : 	    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {
; 158  : 	    long delta = (char *) ctxt - (char *) ctxt->userData;

	sub	eax, esi

; 159  : 	    if ((delta > 0) && (delta < 250))

	dec	eax
	cmp	eax, 248				; 000000f8H
	cmovbe	edi, esi
$LN5@xmlErrVali:

; 160  : 		pctxt = ctxt->userData;
; 161  : 	}
; 162  :     }
; 163  :     __xmlRaiseError(schannel, channel, data, pctxt, node, XML_FROM_VALID, error,

	mov	edx, DWORD PTR _str3$[ebp]
	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	edx
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	edx
	push	ecx
	push	eax
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	23					; 00000017H
	push	DWORD PTR _node$[ebp]
	push	edi
	push	esi
	push	ebx
	push	0
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH
	pop	edi
	pop	esi
	pop	ebx

; 164  :                     XML_ERR_ERROR, NULL, 0,
; 165  :                     (const char *) str1,
; 166  :                     (const char *) str2,
; 167  :                     (const char *) str3, 0, 0, msg, str1, str2, str3);
; 168  : }

	pop	ebp
	ret	0
_xmlErrValidNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlErrValid
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_extra$ = 20						; size = 4
_xmlErrValid PROC					; COMDAT

; 99   : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	xor	edx, edx
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN5@xmlErrVali

; 100  :     xmlGenericErrorFunc channel = NULL;
; 101  :     xmlParserCtxtPtr pctxt = NULL;
; 102  :     void *data = NULL;
; 103  : 
; 104  :     if (ctxt != NULL) {
; 105  :         channel = ctxt->error;

	cmp	DWORD PTR [eax+28], -1412623820		; abcd1234H
	mov	esi, DWORD PTR [eax+4]

; 106  :         data = ctxt->userData;

	mov	ecx, DWORD PTR [eax]

; 107  : 	/* Use the special values to detect if it is part of a parsing
; 108  : 	   context */
; 109  : 	if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||

	je	SHORT $LN4@xmlErrVali
	cmp	DWORD PTR [eax+28], -1412623819		; abcd1235H
	jne	SHORT $LN5@xmlErrVali
$LN4@xmlErrVali:

; 110  : 	    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {
; 111  : 	    long delta = (char *) ctxt - (char *) ctxt->userData;

	sub	eax, ecx

; 112  : 	    if ((delta > 0) && (delta < 250))

	dec	eax
	cmp	eax, 248				; 000000f8H
	cmovbe	edx, ecx
$LN5@xmlErrVali:

; 113  : 		pctxt = ctxt->userData;
; 114  : 	}
; 115  :     }
; 116  :     if (extra)

	mov	eax, DWORD PTR _extra$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlErrVali

; 117  :         __xmlRaiseError(NULL, channel, data,

	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	0
	push	eax
	jmp	SHORT $LN9@xmlErrVali
$LN6@xmlErrVali:

; 118  :                         pctxt, NULL, XML_FROM_VALID, error,
; 119  :                         XML_ERR_ERROR, NULL, 0, extra, NULL, NULL, 0, 0,
; 120  :                         msg, extra);
; 121  :     else
; 122  :         __xmlRaiseError(NULL, channel, data,

	push	DWORD PTR _msg$[ebp]
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
$LN9@xmlErrVali:

; 123  :                         pctxt, NULL, XML_FROM_VALID, error,
; 124  :                         XML_ERR_ERROR, NULL, 0, NULL, NULL, NULL, 0, 0,
; 125  :                         "%s", msg);
; 126  : }

	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	23					; 00000017H
	push	0
	push	edx
	push	ecx
	push	esi
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	esi
	pop	ebp
	ret	0
_xmlErrValid ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlVErrMemory
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlVErrMemory PROC					; COMDAT

; 59   : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	xor	edx, edx
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN5@xmlVErrMem

; 60   :     xmlGenericErrorFunc channel = NULL;
; 61   :     xmlParserCtxtPtr pctxt = NULL;
; 62   :     void *data = NULL;
; 63   : 
; 64   :     if (ctxt != NULL) {
; 65   :         channel = ctxt->error;

	cmp	DWORD PTR [eax+28], -1412623820		; abcd1234H
	mov	esi, DWORD PTR [eax+4]

; 66   :         data = ctxt->userData;

	mov	ecx, DWORD PTR [eax]

; 67   : 	/* Use the special values to detect if it is part of a parsing
; 68   : 	   context */
; 69   : 	if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||

	je	SHORT $LN4@xmlVErrMem
	cmp	DWORD PTR [eax+28], -1412623819		; abcd1235H
	jne	SHORT $LN5@xmlVErrMem
$LN4@xmlVErrMem:

; 70   : 	    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {
; 71   : 	    long delta = (char *) ctxt - (char *) ctxt->userData;

	sub	eax, ecx

; 72   : 	    if ((delta > 0) && (delta < 250))

	dec	eax
	cmp	eax, 248				; 000000f8H
	cmovbe	edx, ecx
$LN5@xmlVErrMem:

; 73   : 		pctxt = ctxt->userData;
; 74   : 	}
; 75   :     }
; 76   :     if (extra)

	mov	eax, DWORD PTR _extra$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlVErrMem

; 77   :         __xmlRaiseError(NULL, channel, data,

	push	eax
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	3
	push	2
	push	23					; 00000017H
	push	0
	push	edx
	push	ecx
	push	esi
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	esi

; 83   :                         pctxt, NULL, XML_FROM_VALID, XML_ERR_NO_MEMORY,
; 84   :                         XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0,
; 85   :                         "Memory allocation failed\n");
; 86   : }

	pop	ebp
	ret	0
$LN6@xmlVErrMem:

; 78   :                         pctxt, NULL, XML_FROM_VALID, XML_ERR_NO_MEMORY,
; 79   :                         XML_ERR_FATAL, NULL, 0, extra, NULL, NULL, 0, 0,
; 80   :                         "Memory allocation failed : %s\n", extra);
; 81   :     else
; 82   :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	2
	push	23					; 00000017H
	push	0
	push	edx
	push	ecx
	push	esi
	push	0
	call	___xmlRaiseError
	add	esp, 64					; 00000040H
	pop	esi

; 83   :                         pctxt, NULL, XML_FROM_VALID, XML_ERR_NO_MEMORY,
; 84   :                         XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0,
; 85   :                         "Memory allocation failed\n");
; 86   : }

	pop	ebp
	ret	0
_xmlVErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateAttributeValueInternal
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_type$ = 12						; size = 4
_value$ = 16						; size = 4
_xmlValidateAttributeValueInternal PROC			; COMDAT

; 3790 :                                   const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	add	eax, -2					; fffffffeH
	cmp	eax, 8
	ja	SHORT $LN8@xmlValidat

; 3791 :     switch (type) {

	jmp	DWORD PTR $LN11@xmlValidat[eax*4]
$LN4@xmlValidat:

; 3792 : 	case XML_ATTRIBUTE_ENTITIES:
; 3793 : 	case XML_ATTRIBUTE_IDREFS:
; 3794 : 	    return(xmlValidateNamesValueInternal(doc, value));

	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _doc$[ebp]
	call	_xmlValidateNamesValueInternal
	add	esp, 8

; 3809 : }

	pop	ebp
	ret	0
$LN5@xmlValidat:

; 3795 : 	case XML_ATTRIBUTE_ENTITY:
; 3796 : 	case XML_ATTRIBUTE_IDREF:
; 3797 : 	case XML_ATTRIBUTE_ID:
; 3798 : 	case XML_ATTRIBUTE_NOTATION:
; 3799 : 	    return(xmlValidateNameValueInternal(doc, value));

	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _doc$[ebp]
	call	_xmlValidateNameValueInternal
	add	esp, 8

; 3809 : }

	pop	ebp
	ret	0
$LN6@xmlValidat:

; 3800 : 	case XML_ATTRIBUTE_NMTOKENS:
; 3801 : 	case XML_ATTRIBUTE_ENUMERATION:
; 3802 : 	    return(xmlValidateNmtokensValueInternal(doc, value));

	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _doc$[ebp]
	call	_xmlValidateNmtokensValueInternal
	add	esp, 8

; 3809 : }

	pop	ebp
	ret	0
$LN7@xmlValidat:

; 3803 : 	case XML_ATTRIBUTE_NMTOKEN:
; 3804 : 	    return(xmlValidateNmtokenValueInternal(doc, value));

	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _doc$[ebp]
	call	_xmlValidateNmtokenValueInternal
	add	esp, 8

; 3809 : }

	pop	ebp
	ret	0
$LN8@xmlValidat:

; 3805 :         case XML_ATTRIBUTE_CDATA:
; 3806 : 	    break;
; 3807 :     }
; 3808 :     return(1);

	mov	eax, 1

; 3809 : }

	pop	ebp
	ret	0
	npad	2
$LN11@xmlValidat:
	DD	$LN5@xmlValidat
	DD	$LN5@xmlValidat
	DD	$LN4@xmlValidat
	DD	$LN5@xmlValidat
	DD	$LN4@xmlValidat
	DD	$LN7@xmlValidat
	DD	$LN6@xmlValidat
	DD	$LN6@xmlValidat
	DD	$LN5@xmlValidat
_xmlValidateAttributeValueInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlGetDtdElementDesc2
_TEXT	SEGMENT
_prefix$ = -4						; size = 4
_dtd$ = 8						; size = 4
_name$ = 12						; size = 4
_create$ = 16						; size = 4
_xmlGetDtdElementDesc2 PROC				; COMDAT

; 3206 : xmlGetDtdElementDesc2(xmlDtdPtr dtd, const xmlChar *name, int create) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _dtd$[ebp]
	mov	DWORD PTR _prefix$[ebp], 0
	test	esi, esi
	je	SHORT $LN30@xmlGetDtdE

; 3207 :     xmlElementTablePtr table;
; 3208 :     xmlElementPtr cur;
; 3209 :     xmlChar *uqname = NULL, *prefix = NULL;
; 3210 : 
; 3211 :     if (dtd == NULL) return(NULL);
; 3212 :     if (dtd->elements == NULL) {

	mov	edi, DWORD PTR [esi+40]
	test	edi, edi
	jne	SHORT $LN7@xmlGetDtdE

; 3213 : 	xmlDictPtr dict = NULL;
; 3214 : 
; 3215 : 	if (dtd->doc != NULL)

	mov	eax, DWORD PTR [esi+32]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN4@xmlGetDtdE

; 3216 : 	    dict = dtd->doc->dict;

	mov	ecx, DWORD PTR [eax+80]
$LN4@xmlGetDtdE:

; 3217 : 
; 3218 : 	if (!create)

	cmp	DWORD PTR _create$[ebp], 0
	je	SHORT $LN30@xmlGetDtdE

; 3219 : 	    return(NULL);
; 3220 : 	/*
; 3221 : 	 * Create the Element table if needed.
; 3222 : 	 */
; 3223 : 	table = (xmlElementTablePtr) dtd->elements;
; 3224 : 	if (table == NULL) {
; 3225 : 	    table = xmlHashCreateDict(0, dict);

	push	ecx
	push	0
	call	_xmlHashCreateDict
	mov	edi, eax
	add	esp, 8

; 3226 : 	    dtd->elements = (void *) table;

	mov	DWORD PTR [esi+40], edi

; 3227 : 	}
; 3228 : 	if (table == NULL) {

	test	edi, edi
	jne	SHORT $LN7@xmlGetDtdE

; 77   :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0CA@OJAJCLMD@element?5table?5allocation?5failed@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0CA@OJAJCLMD@element?5table?5allocation?5failed@
	push	eax
	push	eax
	push	3
	push	2
	push	23					; 00000017H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN30@xmlGetDtdE:
	pop	edi

; 3260 : }

	xor	eax, eax
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlGetDtdE:

; 3229 : 	    xmlVErrMemory(NULL, "element table allocation failed");
; 3230 : 	    return(NULL);
; 3231 : 	}
; 3232 :     }
; 3233 :     table = (xmlElementTablePtr) dtd->elements;
; 3234 : 
; 3235 :     uqname = xmlSplitQName2(name, &prefix);

	mov	esi, DWORD PTR _name$[ebp]
	lea	eax, DWORD PTR _prefix$[ebp]
	push	ebx
	push	eax
	push	esi
	call	_xmlSplitQName2

; 3236 :     if (uqname != NULL)
; 3237 :         name = uqname;
; 3238 :     cur = xmlHashLookup2(table, name, prefix);

	push	DWORD PTR _prefix$[ebp]
	mov	ebx, eax
	test	ebx, ebx
	cmovne	esi, ebx
	push	esi
	push	edi
	mov	DWORD PTR _name$[ebp], esi
	call	_xmlHashLookup2
	mov	esi, eax
	add	esp, 20					; 00000014H

; 3239 :     if ((cur == NULL) && (create)) {

	test	esi, esi
	jne	$LN9@xmlGetDtdE
	cmp	DWORD PTR _create$[ebp], eax
	je	$LN9@xmlGetDtdE

; 3240 : 	cur = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));

	push	56					; 00000038H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 3241 : 	if (cur == NULL) {

	test	esi, esi
	jne	SHORT $LN10@xmlGetDtdE

; 77   :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	eax
	push	eax
	push	3
	push	2
	push	23					; 00000017H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 3242 : 	    xmlVErrMemory(NULL, "malloc failed");
; 3243 : 	    return(NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 3260 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlGetDtdE:

; 3244 : 	}
; 3245 : 	memset(cur, 0, sizeof(xmlElement));

	push	56					; 00000038H
	push	0
	push	esi
	call	_memset

; 3246 : 	cur->type = XML_ELEMENT_DECL;
; 3247 : 
; 3248 : 	/*
; 3249 : 	 * fill the structure.
; 3250 : 	 */
; 3251 : 	cur->name = xmlStrdup(name);

	push	DWORD PTR _name$[ebp]
	mov	DWORD PTR [esi+4], 15			; 0000000fH
	call	_xmlStrdup
	mov	DWORD PTR [esi+8], eax

; 3252 : 	cur->prefix = xmlStrdup(prefix);

	push	DWORD PTR _prefix$[ebp]
	call	_xmlStrdup

; 3253 : 	cur->etype = XML_ELEMENT_TYPE_UNDEFINED;
; 3254 : 
; 3255 : 	xmlHashAddEntry2(table, name, prefix, cur);

	push	esi
	mov	DWORD PTR [esi+48], eax
	mov	DWORD PTR [esi+36], 0
	push	DWORD PTR _prefix$[ebp]
	push	DWORD PTR _name$[ebp]
	push	edi
	call	_xmlHashAddEntry2
	add	esp, 36					; 00000024H
$LN9@xmlGetDtdE:

; 3256 :     }
; 3257 :     if (prefix != NULL) xmlFree(prefix);

	mov	eax, DWORD PTR _prefix$[ebp]
	test	eax, eax
	je	SHORT $LN11@xmlGetDtdE
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlGetDtdE:

; 3258 :     if (uqname != NULL) xmlFree(uqname);

	test	ebx, ebx
	je	SHORT $LN12@xmlGetDtdE
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlGetDtdE:

; 3259 :     return(cur);

	pop	ebx
	pop	edi
	mov	eax, esi

; 3260 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlGetDtdElementDesc2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidatePopElement
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_elem$ = 16						; size = 4
_qname$ = 20						; size = 4
_xmlValidatePopElement PROC				; COMDAT

; 5922 : 		      const xmlChar *qname ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ebx, 1
	test	esi, esi
	jne	SHORT $LN2@xmlValidat

; 5923 :     int ret = 1;
; 5924 : 
; 5925 :     if (ctxt == NULL)
; 5926 :         return(0);

	pop	esi
	xor	eax, eax

; 5959 : }

	pop	ebx
	pop	ebp
	ret	0
$LN2@xmlValidat:

; 5927 : /* printf("PopElem %s\n", qname); */
; 5928 :     if ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {

	cmp	DWORD PTR [esi+44], 0
	jle	$LN14@xmlValidat
	push	edi
	mov	edi, DWORD PTR [esi+40]
	test	edi, edi
	je	$LN16@xmlValidat

; 5929 : 	xmlValidStatePtr state = ctxt->vstate;
; 5930 : 	xmlElementPtr elemDecl;
; 5931 : 
; 5932 : 	/*
; 5933 : 	 * Check the new element against the content model of the new elem.
; 5934 : 	 */
; 5935 : 	if (state->elemDecl != NULL) {

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN8@xmlValidat

; 5936 : 	    elemDecl = state->elemDecl;
; 5937 : 
; 5938 : 	    if (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT) {

	cmp	DWORD PTR [eax+36], 4
	jne	SHORT $LN8@xmlValidat

; 5939 : 		if (state->exec != NULL) {

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN8@xmlValidat

; 5940 : 		    ret = xmlRegExecPushString(state->exec, NULL, NULL);

	push	0
	push	0
	push	eax
	call	_xmlRegExecPushString
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 5941 : 		    if (ret == 0) {

	test	ebx, ebx
	jne	SHORT $LN7@xmlValidat

; 5942 : 			xmlErrValidNode(ctxt, state->node,

	mov	ecx, DWORD PTR [edi+4]
	push	eax
	push	eax
	push	DWORD PTR [ecx+8]
	push	OFFSET ??_C@_0EC@JDBIOCJK@Element?5?$CFs?5content?5does?5not?5fol@
	push	504					; 000001f8H
	push	ecx
	push	esi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 5943 : 			                XML_DTD_CONTENT_MODEL,
; 5944 : 	   "Element %s content does not follow the DTD, Expecting more child\n",
; 5945 : 			       state->node->name, NULL,NULL);
; 5946 : 		    } else {

	jmp	SHORT $LN8@xmlValidat
$LN7@xmlValidat:

; 5947 : 			/*
; 5948 : 			 * previous validation errors should not generate
; 5949 : 			 * a new one here
; 5950 : 			 */
; 5951 : 			ret = 1;

	mov	ebx, 1
$LN8@xmlValidat:

; 321  :     if (ctxt->vstateNr < 1) return(-1);

	mov	edx, DWORD PTR [esi+44]
	cmp	edx, 1
	jl	SHORT $LN16@xmlValidat

; 322  :     ctxt->vstateNr--;
; 323  :     elemDecl = ctxt->vstateTab[ctxt->vstateNr].elemDecl;

	mov	ecx, DWORD PTR [esi+52]
	dec	edx
	mov	DWORD PTR [esi+44], edx
	lea	eax, DWORD PTR [edx+edx*2]
	mov	edi, DWORD PTR [ecx+eax*4]

; 324  :     ctxt->vstateTab[ctxt->vstateNr].elemDecl = NULL;

	lea	eax, DWORD PTR [edx+edx*2]
	mov	DWORD PTR [ecx+eax*4], 0

; 325  :     ctxt->vstateTab[ctxt->vstateNr].node = NULL;

	mov	eax, DWORD PTR [esi+44]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [eax+ecx*4+4], 0

; 326  :     if ((elemDecl != NULL) && (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT)) {

	test	edi, edi
	je	SHORT $LN12@xmlValidat
	cmp	DWORD PTR [edi+36], 4
	jne	SHORT $LN12@xmlValidat

; 327  : 	xmlRegFreeExecCtxt(ctxt->vstateTab[ctxt->vstateNr].exec);

	mov	eax, DWORD PTR [esi+44]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+52]
	push	DWORD PTR [eax+ecx*4+8]
	call	_xmlRegFreeExecCtxt
	add	esp, 4
$LN12@xmlValidat:

; 328  :     }
; 329  :     ctxt->vstateTab[ctxt->vstateNr].exec = NULL;

	mov	eax, DWORD PTR [esi+44]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [eax+ecx*4+8], 0

; 330  :     if (ctxt->vstateNr >= 1)

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 1
	jl	SHORT $LN13@xmlValidat

; 331  : 	ctxt->vstate = &ctxt->vstateTab[ctxt->vstateNr - 1];

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+52]
	pop	edi
	lea	eax, DWORD PTR [eax+ecx*4]
	add	eax, -12				; fffffff4H
	mov	DWORD PTR [esi+40], eax

; 5952 : 		    }
; 5953 : 		}
; 5954 : 	    }
; 5955 : 	}
; 5956 : 	vstateVPop(ctxt);
; 5957 :     }
; 5958 :     return(ret);

	mov	eax, ebx
	pop	esi

; 5959 : }

	pop	ebx
	pop	ebp
	ret	0
$LN13@xmlValidat:

; 333  : 	ctxt->vstate = NULL;

	mov	DWORD PTR [esi+40], 0
$LN16@xmlValidat:
	pop	edi
$LN14@xmlValidat:
	pop	esi

; 5952 : 		    }
; 5953 : 		}
; 5954 : 	    }
; 5955 : 	}
; 5956 : 	vstateVPop(ctxt);
; 5957 :     }
; 5958 :     return(ret);

	mov	eax, ebx

; 5959 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlValidatePopElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidatePushCData
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_data$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlValidatePushCData PROC				; COMDAT

; 5846 : xmlValidatePushCData(xmlValidCtxtPtr ctxt, const xmlChar *data, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	edi, 1
	test	esi, esi
	jne	SHORT $LN7@xmlValidat

; 5847 :     int ret = 1;
; 5848 : 
; 5849 : /* printf("CDATA %s %d\n", data, len); */
; 5850 :     if (ctxt == NULL)
; 5851 :         return(0);

	pop	edi
	xor	eax, eax

; 5886 : 						XML_DTD_CONTENT_MODEL,
; 5887 : 	   "Element %s content does not follow the DTD, Text not allowed\n",
; 5888 : 				       state->node->name, NULL, NULL);
; 5889 : 				ret = 0;
; 5890 : 				goto done;
; 5891 : 			    }
; 5892 : 			}
; 5893 : 			/*
; 5894 : 			 * TODO:
; 5895 : 			 * VC: Standalone Document Declaration
; 5896 : 			 *  element types with element content, if white space
; 5897 : 			 *  occurs directly within any instance of those types.
; 5898 : 			 */
; 5899 : 		    }
; 5900 : 		    break;
; 5901 : 	    }
; 5902 : 	}
; 5903 :     }
; 5904 : done:
; 5905 :     return(ret);
; 5906 : }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlValidat:

; 5852 :     if (len <= 0)

	mov	edx, DWORD PTR _len$[ebp]
	test	edx, edx
	jle	$done$29

; 5853 : 	return(ret);
; 5854 :     if ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {

	cmp	DWORD PTR [esi+44], 0
	jle	$done$29
	push	ebx
	mov	ebx, DWORD PTR [esi+40]
	test	ebx, ebx
	je	$LN26@xmlValidat

; 5855 : 	xmlValidStatePtr state = ctxt->vstate;
; 5856 : 	xmlElementPtr elemDecl;
; 5857 : 
; 5858 : 	/*
; 5859 : 	 * Check the new element against the content model of the new elem.
; 5860 : 	 */
; 5861 : 	if (state->elemDecl != NULL) {

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	$LN26@xmlValidat

; 5862 : 	    elemDecl = state->elemDecl;
; 5863 : 
; 5864 : 	    switch(elemDecl->etype) {

	mov	eax, DWORD PTR [eax+36]
	sub	eax, 0
	je	SHORT $LN11@xmlValidat
	sub	eax, 1
	je	SHORT $LN12@xmlValidat
	sub	eax, 3
	jne	SHORT $LN26@xmlValidat

; 5870 : 				    XML_DTD_NOT_EMPTY,
; 5871 : 	       "Element %s was declared EMPTY this one has content\n",
; 5872 : 			   state->node->name, NULL, NULL);
; 5873 : 		    ret = 0;
; 5874 : 		    break;
; 5875 : 		case XML_ELEMENT_TYPE_ANY:
; 5876 : 		    break;
; 5877 : 		case XML_ELEMENT_TYPE_MIXED:
; 5878 : 		    break;
; 5879 : 		case XML_ELEMENT_TYPE_ELEMENT:
; 5880 : 		    if (len > 0) {
; 5881 : 			int i;
; 5882 : 
; 5883 : 			for (i = 0;i < len;i++) {

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN26@xmlValidat
$LL6@xmlValidat:

; 5884 : 			    if (!IS_BLANK_CH(data[i])) {

	mov	eax, DWORD PTR _data$[ebp]
	mov	al, BYTE PTR [ecx+eax]
	cmp	al, 32					; 00000020H
	je	SHORT $LN4@xmlValidat
	cmp	al, 9
	jb	SHORT $LN18@xmlValidat
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN4@xmlValidat
$LN18@xmlValidat:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN21@xmlValidat
$LN4@xmlValidat:

; 5870 : 				    XML_DTD_NOT_EMPTY,
; 5871 : 	       "Element %s was declared EMPTY this one has content\n",
; 5872 : 			   state->node->name, NULL, NULL);
; 5873 : 		    ret = 0;
; 5874 : 		    break;
; 5875 : 		case XML_ELEMENT_TYPE_ANY:
; 5876 : 		    break;
; 5877 : 		case XML_ELEMENT_TYPE_MIXED:
; 5878 : 		    break;
; 5879 : 		case XML_ELEMENT_TYPE_ELEMENT:
; 5880 : 		    if (len > 0) {
; 5881 : 			int i;
; 5882 : 
; 5883 : 			for (i = 0;i < len;i++) {

	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LL6@xmlValidat

; 5886 : 						XML_DTD_CONTENT_MODEL,
; 5887 : 	   "Element %s content does not follow the DTD, Text not allowed\n",
; 5888 : 				       state->node->name, NULL, NULL);
; 5889 : 				ret = 0;
; 5890 : 				goto done;
; 5891 : 			    }
; 5892 : 			}
; 5893 : 			/*
; 5894 : 			 * TODO:
; 5895 : 			 * VC: Standalone Document Declaration
; 5896 : 			 *  element types with element content, if white space
; 5897 : 			 *  occurs directly within any instance of those types.
; 5898 : 			 */
; 5899 : 		    }
; 5900 : 		    break;
; 5901 : 	    }
; 5902 : 	}
; 5903 :     }
; 5904 : done:
; 5905 :     return(ret);
; 5906 : }

	pop	ebx
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN21@xmlValidat:

; 5885 : 				xmlErrValidNode(ctxt, state->node,

	mov	eax, DWORD PTR [ebx+4]
	push	0
	push	0
	push	DWORD PTR [eax+8]
	push	OFFSET ??_C@_0DO@HNMIGKJO@Element?5?$CFs?5content?5does?5not?5fol@
	push	504					; 000001f8H
	push	eax
	push	esi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
	xor	edi, edi

; 5886 : 						XML_DTD_CONTENT_MODEL,
; 5887 : 	   "Element %s content does not follow the DTD, Text not allowed\n",
; 5888 : 				       state->node->name, NULL, NULL);
; 5889 : 				ret = 0;
; 5890 : 				goto done;
; 5891 : 			    }
; 5892 : 			}
; 5893 : 			/*
; 5894 : 			 * TODO:
; 5895 : 			 * VC: Standalone Document Declaration
; 5896 : 			 *  element types with element content, if white space
; 5897 : 			 *  occurs directly within any instance of those types.
; 5898 : 			 */
; 5899 : 		    }
; 5900 : 		    break;
; 5901 : 	    }
; 5902 : 	}
; 5903 :     }
; 5904 : done:
; 5905 :     return(ret);
; 5906 : }

	mov	eax, edi
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN12@xmlValidat:

; 5867 : 		    break;
; 5868 : 		case XML_ELEMENT_TYPE_EMPTY:
; 5869 : 		    xmlErrValidNode(ctxt, state->node,

	mov	eax, DWORD PTR [ebx+4]
	push	0
	push	0
	push	DWORD PTR [eax+8]
	push	OFFSET ??_C@_0DE@KLKCMFPH@Element?5?$CFs?5was?5declared?5EMPTY?5t@
	push	528					; 00000210H
	push	eax
	push	esi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
$LN11@xmlValidat:

; 5865 : 		case XML_ELEMENT_TYPE_UNDEFINED:
; 5866 : 		    ret = 0;

	xor	edi, edi
$LN26@xmlValidat:
	pop	ebx
$done$29:

; 5886 : 						XML_DTD_CONTENT_MODEL,
; 5887 : 	   "Element %s content does not follow the DTD, Text not allowed\n",
; 5888 : 				       state->node->name, NULL, NULL);
; 5889 : 				ret = 0;
; 5890 : 				goto done;
; 5891 : 			    }
; 5892 : 			}
; 5893 : 			/*
; 5894 : 			 * TODO:
; 5895 : 			 * VC: Standalone Document Declaration
; 5896 : 			 *  element types with element content, if white space
; 5897 : 			 *  occurs directly within any instance of those types.
; 5898 : 			 */
; 5899 : 		    }
; 5900 : 		    break;
; 5901 : 	    }
; 5902 : 	}
; 5903 :     }
; 5904 : done:
; 5905 :     return(ret);
; 5906 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlValidatePushCData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidatePushElement
_TEXT	SEGMENT
_extsubset$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_elem$ = 16						; size = 4
_qname$ = 20						; size = 4
_xmlValidatePushElement PROC				; COMDAT

; 5754 :                        xmlNodePtr elem, const xmlChar *qname) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	ebx, 1
	test	edi, edi
	jne	SHORT $LN4@xmlValidat

; 5755 :     int ret = 1;
; 5756 :     xmlElementPtr eDecl;
; 5757 :     int extsubset = 0;
; 5758 : 
; 5759 :     if (ctxt == NULL)
; 5760 :         return(0);

	pop	edi
	xor	eax, eax

; 5833 : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlValidat:

; 5761 : /* printf("PushElem %s\n", qname); */
; 5762 :     if ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {

	cmp	DWORD PTR [edi+44], 0
	push	esi
	jle	$LN17@xmlValidat
	mov	esi, DWORD PTR [edi+40]
	test	esi, esi
	je	$LN17@xmlValidat

; 5763 : 	xmlValidStatePtr state = ctxt->vstate;
; 5764 : 	xmlElementPtr elemDecl;
; 5765 : 
; 5766 : 	/*
; 5767 : 	 * Check the new element against the content model of the new elem.
; 5768 : 	 */
; 5769 : 	if (state->elemDecl != NULL) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	$LN17@xmlValidat

; 5770 : 	    elemDecl = state->elemDecl;
; 5771 : 
; 5772 : 	    switch(elemDecl->etype) {

	mov	ecx, DWORD PTR [eax+36]
	cmp	ecx, 4
	ja	$LN17@xmlValidat
	jmp	DWORD PTR $LN21@xmlValidat[ecx*4]
$LN8@xmlValidat:

; 5773 : 		case XML_ELEMENT_TYPE_UNDEFINED:
; 5774 : 		    ret = 0;
; 5775 : 		    break;
; 5776 : 		case XML_ELEMENT_TYPE_EMPTY:
; 5777 : 		    xmlErrValidNode(ctxt, state->node,

	mov	eax, DWORD PTR [esi+4]
	push	0
	push	0
	push	DWORD PTR [eax+8]
	push	OFFSET ??_C@_0DE@KLKCMFPH@Element?5?$CFs?5was?5declared?5EMPTY?5t@
	push	528					; 00000210H

; 5824 : 			}
; 5825 : 		    }
; 5826 : 		    break;
; 5827 : 	    }
; 5828 : 	}
; 5829 :     }
; 5830 :     eDecl = xmlValidGetElemDecl(ctxt, doc, elem, &extsubset);

	push	eax
	push	edi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
	xor	ebx, ebx
	jmp	$LN17@xmlValidat
$LN10@xmlValidat:

; 5778 : 				    XML_DTD_NOT_EMPTY,
; 5779 : 	       "Element %s was declared EMPTY this one has content\n",
; 5780 : 			   state->node->name, NULL, NULL);
; 5781 : 		    ret = 0;
; 5782 : 		    break;
; 5783 : 		case XML_ELEMENT_TYPE_ANY:
; 5784 : 		    /* I don't think anything is required then */
; 5785 : 		    break;
; 5786 : 		case XML_ELEMENT_TYPE_MIXED:
; 5787 : 		    /* simple case of declared as #PCDATA */
; 5788 : 		    if ((elemDecl->content != NULL) &&

	mov	eax, DWORD PTR [eax+40]
	test	eax, eax
	je	SHORT $LN11@xmlValidat
	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN11@xmlValidat

; 5789 : 			(elemDecl->content->type ==
; 5790 : 			 XML_ELEMENT_CONTENT_PCDATA)) {
; 5791 : 			xmlErrValidNode(ctxt, state->node,

	mov	eax, DWORD PTR [esi+4]
	push	0
	push	0
	push	DWORD PTR [eax+8]
	push	OFFSET ??_C@_0DN@CFJCCMLK@Element?5?$CFs?5was?5declared?5?$CDPCDATA@
	push	529					; 00000211H

; 5824 : 			}
; 5825 : 		    }
; 5826 : 		    break;
; 5827 : 	    }
; 5828 : 	}
; 5829 :     }
; 5830 :     eDecl = xmlValidGetElemDecl(ctxt, doc, elem, &extsubset);

	push	eax
	push	edi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
	xor	ebx, ebx
	jmp	SHORT $LN17@xmlValidat
$LN11@xmlValidat:

; 5792 : 					XML_DTD_NOT_PCDATA,
; 5793 : 	       "Element %s was declared #PCDATA but contains non text nodes\n",
; 5794 : 				state->node->name, NULL, NULL);
; 5795 : 			ret = 0;
; 5796 : 		    } else {
; 5797 : 			ret = xmlValidateCheckMixed(ctxt, elemDecl->content,

	push	DWORD PTR _qname$[ebp]
	push	eax
	push	edi
	call	_xmlValidateCheckMixed
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 5798 : 				                    qname);
; 5799 : 			if (ret != 1) {

	cmp	ebx, 1
	je	SHORT $LN17@xmlValidat

; 5800 : 			    xmlErrValidNode(ctxt, state->node,

	mov	ecx, DWORD PTR [esi+4]
	push	0
	push	DWORD PTR [ecx+8]
	push	DWORD PTR _qname$[ebp]
	push	OFFSET ??_C@_0DM@IPIENEI@Element?5?$CFs?5is?5not?5declared?5in?5?$CF@
	push	515					; 00000203H
	push	ecx
	push	edi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 5801 : 					    XML_DTD_INVALID_CHILD,
; 5802 : 	       "Element %s is not declared in %s list of possible children\n",
; 5803 : 				    qname, state->node->name, NULL);
; 5804 : 			}
; 5805 : 		    }
; 5806 : 		    break;

	jmp	SHORT $LN17@xmlValidat
$LN14@xmlValidat:

; 5807 : 		case XML_ELEMENT_TYPE_ELEMENT:
; 5808 : 		    /*
; 5809 : 		     * TODO:
; 5810 : 		     * VC: Standalone Document Declaration
; 5811 : 		     *     - element types with element content, if white space
; 5812 : 		     *       occurs directly within any instance of those types.
; 5813 : 		     */
; 5814 : 		    if (state->exec != NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN17@xmlValidat

; 5815 : 			ret = xmlRegExecPushString(state->exec, qname, NULL);

	mov	ebx, DWORD PTR _qname$[ebp]
	push	0
	push	ebx
	push	eax
	call	_xmlRegExecPushString
	add	esp, 12					; 0000000cH

; 5816 : 			if (ret < 0) {

	test	eax, eax
	jns	SHORT $LN16@xmlValidat

; 5817 : 			    xmlErrValidNode(ctxt, state->node,

	mov	eax, DWORD PTR [esi+4]
	push	0
	push	ebx
	push	DWORD PTR [eax+8]
	push	OFFSET ??_C@_0DK@BGIDCAIC@Element?5?$CFs?5content?5does?5not?5fol@
	push	504					; 000001f8H

; 5824 : 			}
; 5825 : 		    }
; 5826 : 		    break;
; 5827 : 	    }
; 5828 : 	}
; 5829 :     }
; 5830 :     eDecl = xmlValidGetElemDecl(ctxt, doc, elem, &extsubset);

	push	eax
	push	edi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
$LN7@xmlValidat:
	xor	ebx, ebx
	jmp	SHORT $LN17@xmlValidat
$LN16@xmlValidat:

; 5818 : 					    XML_DTD_CONTENT_MODEL,
; 5819 : 	       "Element %s content does not follow the DTD, Misplaced %s\n",
; 5820 : 				   state->node->name, qname, NULL);
; 5821 : 			    ret = 0;
; 5822 : 			} else {
; 5823 : 			    ret = 1;

	mov	ebx, 1
$LN17@xmlValidat:

; 5824 : 			}
; 5825 : 		    }
; 5826 : 		    break;
; 5827 : 	    }
; 5828 : 	}
; 5829 :     }
; 5830 :     eDecl = xmlValidGetElemDecl(ctxt, doc, elem, &extsubset);

	mov	esi, DWORD PTR _elem$[ebp]
	lea	eax, DWORD PTR _extsubset$[ebp]
	push	eax
	push	esi
	push	DWORD PTR _doc$[ebp]
	push	edi
	call	_xmlValidGetElemDecl

; 5831 :     vstateVPush(ctxt, eDecl, elem);

	push	esi
	push	eax
	push	edi
	call	_vstateVPush
	add	esp, 28					; 0000001cH

; 5832 :     return(ret);

	mov	eax, ebx
	pop	esi
	pop	edi

; 5833 : }

	pop	ebx
	pop	ebp
	ret	0
	npad	2
$LN21@xmlValidat:
	DD	$LN7@xmlValidat
	DD	$LN8@xmlValidat
	DD	$LN17@xmlValidat
	DD	$LN10@xmlValidat
	DD	$LN14@xmlValidat
_xmlValidatePushElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidBuildContentModel
_TEXT	SEGMENT
_expr$1 = -5000						; size = 5000
_ctxt$ = 8						; size = 4
_elem$ = 12						; size = 4
_xmlValidBuildContentModel PROC				; COMDAT

; 813  : xmlValidBuildContentModel(xmlValidCtxtPtr ctxt, xmlElementPtr elem) {

	push	ebp
	mov	ebp, esp
	mov	eax, 5000				; 00001388H
	call	__chkstk
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlValidBu

; 814  : 
; 815  :     if ((ctxt == NULL) || (elem == NULL))

	mov	edi, DWORD PTR _elem$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlValidBu

; 816  : 	return(0);
; 817  :     if (elem->type != XML_ELEMENT_DECL)

	cmp	DWORD PTR [edi+4], 15			; 0000000fH
	jne	SHORT $LN3@xmlValidBu

; 818  : 	return(0);
; 819  :     if (elem->etype != XML_ELEMENT_TYPE_ELEMENT)

	cmp	DWORD PTR [edi+36], 4
	jne	$LN7@xmlValidBu

; 820  : 	return(1);
; 821  :     /* TODO: should we rebuild in this case ? */
; 822  :     if (elem->contModel != NULL) {

	mov	eax, DWORD PTR [edi+52]
	test	eax, eax
	je	SHORT $LN6@xmlValidBu

; 823  : 	if (!xmlRegexpIsDeterminist(elem->contModel)) {

	push	eax
	call	_xmlRegexpIsDeterminist
	add	esp, 4
	test	eax, eax
	jne	$LN7@xmlValidBu

; 824  : 	    ctxt->valid = 0;

	mov	DWORD PTR [esi+36], eax
$LN3@xmlValidBu:
	pop	edi

; 862  :     return(1);
; 863  : }

	xor	eax, eax
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlValidBu:

; 825  : 	    return(0);
; 826  : 	}
; 827  : 	return(1);
; 828  :     }
; 829  : 
; 830  :     ctxt->am = xmlNewAutomata();

	call	_xmlNewAutomata
	mov	DWORD PTR [esi+56], eax

; 831  :     if (ctxt->am == NULL) {

	test	eax, eax
	jne	SHORT $LN8@xmlValidBu

; 832  : 	xmlErrValidNode(ctxt, (xmlNodePtr) elem,

	push	eax
	push	eax
	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_0CH@LILACHHH@Cannot?5create?5automata?5for?5elem@
	push	1
	push	edi
	push	esi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 862  :     return(1);
; 863  : }

	xor	eax, eax
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlValidBu:

; 833  : 	                XML_ERR_INTERNAL_ERROR,
; 834  : 	                "Cannot create automata for element %s\n",
; 835  : 		        elem->name, NULL, NULL);
; 836  : 	return(0);
; 837  :     }
; 838  :     ctxt->state = xmlAutomataGetInitState(ctxt->am);

	push	eax
	call	_xmlAutomataGetInitState
	mov	DWORD PTR [esi+60], eax

; 839  :     xmlValidBuildAContentModel(elem->content, ctxt, elem->name);

	push	DWORD PTR [edi+8]
	push	esi
	push	DWORD PTR [edi+40]
	call	_xmlValidBuildAContentModel

; 840  :     xmlAutomataSetFinalState(ctxt->am, ctxt->state);

	push	DWORD PTR [esi+60]
	push	DWORD PTR [esi+56]
	call	_xmlAutomataSetFinalState

; 841  :     elem->contModel = xmlAutomataCompile(ctxt->am);

	push	DWORD PTR [esi+56]
	call	_xmlAutomataCompile

; 842  :     if (xmlRegexpIsDeterminist(elem->contModel) != 1) {

	push	eax
	mov	DWORD PTR [edi+52], eax
	call	_xmlRegexpIsDeterminist
	add	esp, 32					; 00000020H
	cmp	eax, 1
	je	SHORT $LN9@xmlValidBu

; 843  : 	char expr[5000];
; 844  : 	expr[0] = 0;
; 845  : 	xmlSnprintfElementContent(expr, 5000, elem->content, 1);

	push	1
	push	DWORD PTR [edi+40]
	lea	eax, DWORD PTR _expr$1[ebp]
	mov	BYTE PTR _expr$1[ebp], 0
	push	5000					; 00001388H
	push	eax
	call	_xmlSnprintfElementContent

; 846  : 	xmlErrValidNode(ctxt, (xmlNodePtr) elem,

	push	0
	lea	eax, DWORD PTR _expr$1[ebp]
	push	eax
	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_0CM@GHMIMING@Content?5model?5of?5?$CFs?5is?5not?5dete@
	push	505					; 000001f9H
	push	edi
	push	esi
	call	_xmlErrValidNode

; 847  : 	                XML_DTD_CONTENT_NOT_DETERMINIST,
; 848  : 	       "Content model of %s is not determinist: %s\n",
; 849  : 	       elem->name, BAD_CAST expr, NULL);
; 850  : #ifdef DEBUG_REGEXP_ALGO
; 851  :         xmlRegexpPrint(stderr, elem->contModel);
; 852  : #endif
; 853  :         ctxt->valid = 0;
; 854  : 	ctxt->state = NULL;
; 855  : 	xmlFreeAutomata(ctxt->am);

	push	DWORD PTR [esi+56]
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+60], 0
	call	_xmlFreeAutomata
	add	esp, 48					; 00000030H

; 856  : 	ctxt->am = NULL;

	mov	DWORD PTR [esi+56], 0

; 862  :     return(1);
; 863  : }

	xor	eax, eax
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlValidBu:

; 857  : 	return(0);
; 858  :     }
; 859  :     ctxt->state = NULL;
; 860  :     xmlFreeAutomata(ctxt->am);

	push	DWORD PTR [esi+56]
	mov	DWORD PTR [esi+60], 0
	call	_xmlFreeAutomata
	add	esp, 4

; 861  :     ctxt->am = NULL;

	mov	DWORD PTR [esi+56], 0
$LN7@xmlValidBu:

; 862  :     return(1);
; 863  : }

	pop	edi
	mov	eax, 1
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidBuildContentModel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateNmtokensValue
_TEXT	SEGMENT
_value$ = 8						; size = 4
_xmlValidateNmtokensValue PROC				; COMDAT

; 3750 : xmlValidateNmtokensValue(const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _value$[ebp]
	push	0
	call	_xmlValidateNmtokensValueInternal
	add	esp, 8

; 3751 :     return(xmlValidateNmtokensValueInternal(NULL, value));
; 3752 : }

	pop	ebp
	ret	0
_xmlValidateNmtokensValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateNmtokenValue
_TEXT	SEGMENT
_value$ = 8						; size = 4
_xmlValidateNmtokenValue PROC				; COMDAT

; 3674 : xmlValidateNmtokenValue(const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _value$[ebp]
	push	0
	call	_xmlValidateNmtokenValueInternal
	add	esp, 8

; 3675 :     return(xmlValidateNmtokenValueInternal(NULL, value));
; 3676 : }

	pop	ebp
	ret	0
_xmlValidateNmtokenValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateNamesValue
_TEXT	SEGMENT
_value$ = 8						; size = 4
_xmlValidateNamesValue PROC				; COMDAT

; 3621 : xmlValidateNamesValue(const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _value$[ebp]
	push	0
	call	_xmlValidateNamesValueInternal
	add	esp, 8

; 3622 :     return(xmlValidateNamesValueInternal(NULL, value));
; 3623 : }

	pop	ebp
	ret	0
_xmlValidateNamesValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateNameValue
_TEXT	SEGMENT
_value$ = 8						; size = 4
_xmlValidateNameValue PROC				; COMDAT

; 3553 : xmlValidateNameValue(const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _value$[ebp]
	push	0
	call	_xmlValidateNameValueInternal
	add	esp, 8

; 3554 :     return(xmlValidateNameValueInternal(NULL, value));
; 3555 : }

	pop	ebp
	ret	0
_xmlValidateNameValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidGetValidElements
_TEXT	SEGMENT
_elements$ = -1124					; size = 1024
_vctxt$ = -100						; size = 64
_name$1$ = -36						; size = 4
_parent_last$1$ = -32					; size = 4
_parent_childs$1$ = -28					; size = 4
_test_node$1$ = -24					; size = 4
_next_prev$1$ = -20					; size = 4
_prev_next$1$ = -16					; size = 4
_i$1$ = -12						; size = 4
_nb_elements$ = -8					; size = 4
_parent$1$ = -4						; size = 4
_prev$ = 8						; size = 4
_next$ = 12						; size = 4
_names$ = 16						; size = 4
_max$ = 20						; size = 4
_xmlValidGetValidElements PROC				; COMDAT

; 6991 :                          int max) {

	push	ebp
	mov	ebp, esp
	sub	esp, 1124				; 00000464H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	1024					; 00000400H
	lea	eax, DWORD PTR _elements$[ebp]
	push	0
	push	eax
	call	_memset
	mov	ebx, DWORD PTR _prev$[ebp]
	add	esp, 12					; 0000000cH
	mov	esi, DWORD PTR _next$[ebp]
	mov	DWORD PTR _nb_elements$[ebp], 0
	test	ebx, ebx
	jne	SHORT $LN8@xmlValidGe

; 6992 :     xmlValidCtxt vctxt;
; 6993 :     int nb_valid_elements = 0;
; 6994 :     const xmlChar *elements[256]={0};
; 6995 :     int nb_elements = 0, i;
; 6996 :     const xmlChar *name;
; 6997 : 
; 6998 :     xmlNode *ref_node;
; 6999 :     xmlNode *parent;
; 7000 :     xmlNode *test_node;
; 7001 : 
; 7002 :     xmlNode *prev_next;
; 7003 :     xmlNode *next_prev;
; 7004 :     xmlNode *parent_childs;
; 7005 :     xmlNode *parent_last;
; 7006 : 
; 7007 :     xmlElement *element_desc;
; 7008 : 
; 7009 :     if (prev == NULL && next == NULL)

	test	esi, esi
	je	$LN41@xmlValidGe
$LN8@xmlValidGe:

; 7010 :         return(-1);
; 7011 : 
; 7012 :     if (names == NULL) return(-1);

	cmp	DWORD PTR _names$[ebp], 0
	je	$LN41@xmlValidGe

; 7013 :     if (max <= 0) return(-1);

	cmp	DWORD PTR _max$[ebp], 0
	jle	$LN41@xmlValidGe

; 7014 : 
; 7015 :     memset(&vctxt, 0, sizeof (xmlValidCtxt));

	push	64					; 00000040H
	lea	eax, DWORD PTR _vctxt$[ebp]
	push	0
	push	eax
	call	_memset

; 7016 :     vctxt.error = xmlNoValidityErr;	/* this suppresses err/warn output */
; 7017 : 
; 7018 :     nb_valid_elements = 0;

	xor	edi, edi
	mov	DWORD PTR _vctxt$[ebp+4], OFFSET _xmlNoValidityErr

; 7019 :     ref_node = prev ? prev : next;

	test	ebx, ebx
	cmovne	esi, ebx

; 7020 :     parent = ref_node->parent;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR _parent$1$[ebp], eax

; 7021 : 
; 7022 :     /*
; 7023 :      * Retrieves the parent element declaration
; 7024 :      */
; 7025 :     element_desc = xmlGetDtdElementDesc(parent->doc->intSubset,

	push	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+32]
	push	DWORD PTR [eax+44]
	call	_xmlGetDtdElementDesc
	mov	ebx, eax
	add	esp, 20					; 00000014H

; 7026 :                                          parent->name);
; 7027 :     if ((element_desc == NULL) && (parent->doc->extSubset != NULL))

	test	ebx, ebx
	jne	SHORT $LN12@xmlValidGe
	mov	ecx, DWORD PTR _parent$1$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [eax+48]
	test	eax, eax
	je	$LN41@xmlValidGe

; 7028 :         element_desc = xmlGetDtdElementDesc(parent->doc->extSubset,

	push	DWORD PTR [ecx+8]
	push	eax
	call	_xmlGetDtdElementDesc
	mov	ebx, eax
	add	esp, 8

; 7029 :                                              parent->name);
; 7030 :     if (element_desc == NULL) return(-1);

	test	ebx, ebx
	je	$LN41@xmlValidGe
$LN12@xmlValidGe:

; 7031 : 
; 7032 :     /*
; 7033 :      * Do a backup of the current tree structure
; 7034 :      */
; 7035 :     prev_next = prev ? prev->next : NULL;

	mov	eax, DWORD PTR _prev$[ebp]
	test	eax, eax
	je	SHORT $LN24@xmlValidGe
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _prev_next$1$[ebp], ecx
	jmp	SHORT $LN25@xmlValidGe
$LN24@xmlValidGe:
	mov	DWORD PTR _prev_next$1$[ebp], edi
$LN25@xmlValidGe:

; 7036 :     next_prev = next ? next->prev : NULL;

	mov	eax, DWORD PTR _next$[ebp]
	test	eax, eax
	je	SHORT $LN26@xmlValidGe
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR _next_prev$1$[ebp], eax
	jmp	SHORT $LN27@xmlValidGe
$LN26@xmlValidGe:
	mov	DWORD PTR _next_prev$1$[ebp], edi
$LN27@xmlValidGe:

; 7037 :     parent_childs = parent->children;

	mov	eax, DWORD PTR _parent$1$[ebp]

; 7038 :     parent_last = parent->last;
; 7039 : 
; 7040 :     /*
; 7041 :      * Creates a dummy node and insert it into the tree
; 7042 :      */
; 7043 :     test_node = xmlNewDocNode (ref_node->doc, NULL, BAD_CAST "<!dummy?>", NULL);

	push	0
	push	OFFSET ??_C@_09LMMMMLKM@?$DM?$CBdummy?$DP?$DO@
	push	0
	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax+16]
	push	DWORD PTR [esi+32]
	mov	DWORD PTR _parent_childs$1$[ebp], ecx
	mov	DWORD PTR _parent_last$1$[ebp], eax
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _test_node$1$[ebp], eax

; 7044 :     if (test_node == NULL)

	test	eax, eax
	je	$LN41@xmlValidGe

; 7045 :         return(-1);
; 7046 : 
; 7047 :     test_node->parent = parent;
; 7048 :     test_node->prev = prev;
; 7049 :     test_node->next = next;

	mov	edx, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR _prev$[ebp]
	mov	esi, DWORD PTR _parent$1$[ebp]
	mov	DWORD PTR [eax+24], edx

; 7050 :     name = test_node->name;

	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+20], esi
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR _name$1$[ebp], edx

; 7051 : 
; 7052 :     if (prev) prev->next = test_node;

	test	ecx, ecx
	je	SHORT $LN14@xmlValidGe
	mov	DWORD PTR [ecx+24], eax
	jmp	SHORT $LN15@xmlValidGe
$LN14@xmlValidGe:

; 7053 :     else parent->children = test_node;

	mov	DWORD PTR [esi+12], eax
$LN15@xmlValidGe:

; 7054 : 
; 7055 :     if (next) next->prev = test_node;

	mov	edx, DWORD PTR _next$[ebp]
	test	edx, edx
	je	SHORT $LN16@xmlValidGe
	mov	DWORD PTR [edx+28], eax
	jmp	SHORT $LN17@xmlValidGe
$LN16@xmlValidGe:

; 7056 :     else parent->last = test_node;

	mov	DWORD PTR [esi+16], eax
$LN17@xmlValidGe:

; 7057 : 
; 7058 :     /*
; 7059 :      * Insert each potential child node and check if the parent is
; 7060 :      * still valid
; 7061 :      */
; 7062 :     nb_elements = xmlValidGetPotentialChildren(element_desc->content,

	push	256					; 00000100H
	lea	eax, DWORD PTR _nb_elements$[ebp]
	push	eax
	lea	eax, DWORD PTR _elements$[ebp]
	push	eax
	push	DWORD PTR [ebx+40]
	call	_xmlValidGetPotentialChildren
	add	esp, 16					; 00000010H
	mov	DWORD PTR _nb_elements$[ebp], eax

; 7063 : 		       elements, &nb_elements, 256);
; 7064 : 
; 7065 :     for (i = 0;i < nb_elements;i++) {

	mov	DWORD PTR _i$1$[ebp], edi
	test	eax, eax
	jle	SHORT $LN31@xmlValidGe

; 7057 : 
; 7058 :     /*
; 7059 :      * Insert each potential child node and check if the parent is
; 7060 :      * still valid
; 7061 :      */
; 7062 :     nb_elements = xmlValidGetPotentialChildren(element_desc->content,

	lea	ebx, DWORD PTR _elements$[ebp]
$LL4@xmlValidGe:

; 7066 : 	test_node->name = elements[i];

	mov	ecx, DWORD PTR _test_node$1$[ebp]
	mov	eax, DWORD PTR [ebx]

; 7067 : 	if (xmlValidateOneElement(&vctxt, parent->doc, parent)) {

	push	esi
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR _vctxt$[ebp]
	push	DWORD PTR [esi+32]
	push	eax
	call	_xmlValidateOneElement
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@xmlValidGe

; 7068 : 	    int j;
; 7069 : 
; 7070 : 	    for (j = 0; j < nb_valid_elements;j++)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN42@xmlValidGe
	npad	6
$LL7@xmlValidGe:

; 7071 : 		if (xmlStrEqual(elements[i], names[j])) break;

	mov	eax, DWORD PTR _names$[ebp]
	push	DWORD PTR [eax+esi*4]
	push	DWORD PTR [ebx]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN42@xmlValidGe

; 7068 : 	    int j;
; 7069 : 
; 7070 : 	    for (j = 0; j < nb_valid_elements;j++)

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL7@xmlValidGe
$LN42@xmlValidGe:

; 7072 : 	    names[nb_valid_elements++] = elements[i];

	mov	ecx, DWORD PTR _names$[ebp]
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ecx+edi*4], eax
	inc	edi

; 7073 : 	    if (nb_valid_elements >= max) break;

	cmp	edi, DWORD PTR _max$[ebp]
	jge	SHORT $LN43@xmlValidGe
	mov	esi, DWORD PTR _parent$1$[ebp]
$LN2@xmlValidGe:

; 7063 : 		       elements, &nb_elements, 256);
; 7064 : 
; 7065 :     for (i = 0;i < nb_elements;i++) {

	mov	eax, DWORD PTR _i$1$[ebp]
	add	ebx, 4
	inc	eax
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, DWORD PTR _nb_elements$[ebp]
	jl	SHORT $LL4@xmlValidGe
$LN43@xmlValidGe:
	mov	esi, DWORD PTR _parent$1$[ebp]
$LN31@xmlValidGe:

; 7074 : 	}
; 7075 :     }
; 7076 : 
; 7077 :     /*
; 7078 :      * Restore the tree structure
; 7079 :      */
; 7080 :     if (prev) prev->next = prev_next;

	mov	eax, DWORD PTR _prev$[ebp]
	test	eax, eax
	je	SHORT $LN21@xmlValidGe
	mov	ecx, DWORD PTR _prev_next$1$[ebp]
	mov	DWORD PTR [eax+24], ecx
$LN21@xmlValidGe:

; 7081 :     if (next) next->prev = next_prev;

	mov	eax, DWORD PTR _next$[ebp]
	test	eax, eax
	je	SHORT $LN22@xmlValidGe
	mov	ecx, DWORD PTR _next_prev$1$[ebp]
	mov	DWORD PTR [eax+28], ecx
$LN22@xmlValidGe:

; 7082 :     parent->children = parent_childs;

	mov	eax, DWORD PTR _parent_childs$1$[ebp]

; 7083 :     parent->last = parent_last;
; 7084 : 
; 7085 :     /*
; 7086 :      * Free up the dummy node
; 7087 :      */
; 7088 :     test_node->name = name;

	mov	ecx, DWORD PTR _name$1$[ebp]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR _parent_last$1$[ebp]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR _test_node$1$[ebp]

; 7089 :     xmlFreeNode(test_node);

	push	eax
	mov	DWORD PTR [eax+8], ecx
	call	_xmlFreeNode
	add	esp, 4

; 7090 : 
; 7091 :     return(nb_valid_elements);

	mov	eax, edi
	pop	edi

; 7092 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@xmlValidGe:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidGetValidElements ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidGetPotentialChildren
_TEXT	SEGMENT
_ctree$ = 8						; size = 4
_names$ = 12						; size = 4
_len$ = 16						; size = 4
_max$ = 20						; size = 4
_xmlValidGetPotentialChildren PROC			; COMDAT

; 6925 :                              int *len, int max) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctree$[ebp]
	test	edx, edx
	je	$LN11@xmlValidGe

; 6926 :     int i;
; 6927 : 
; 6928 :     if ((ctree == NULL) || (names == NULL) || (len == NULL))

	mov	ebx, DWORD PTR _names$[ebp]
	test	ebx, ebx
	je	$LN11@xmlValidGe
	mov	edi, DWORD PTR _len$[ebp]
	test	edi, edi
	je	$LN11@xmlValidGe

; 6930 :     if (*len >= max) return(*len);

	mov	ecx, DWORD PTR [edi]
	push	esi
	mov	esi, DWORD PTR _max$[ebp]
	cmp	ecx, esi
	jge	SHORT $LN23@xmlValidGe

; 6931 : 
; 6932 :     switch (ctree->type) {

	mov	eax, DWORD PTR [edx]
	dec	eax
	cmp	eax, 3
	ja	$LN2@xmlValidGe
	jmp	DWORD PTR $LN32@xmlValidGe[eax*4]
$LN13@xmlValidGe:

; 6933 : 	case XML_ELEMENT_CONTENT_PCDATA:
; 6934 : 	    for (i = 0; i < *len;i++)

	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN5@xmlValidGe
$LL6@xmlValidGe:

; 6935 : 		if (xmlStrEqual(BAD_CAST "#PCDATA", names[i])) return(*len);

	push	DWORD PTR [ebx+esi*4]
	push	OFFSET ??_C@_07ELDBONKP@?$CDPCDATA@
	call	_xmlStrEqual
	mov	ecx, DWORD PTR [edi]
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN23@xmlValidGe

; 6933 : 	case XML_ELEMENT_CONTENT_PCDATA:
; 6934 : 	    for (i = 0; i < *len;i++)

	inc	esi
	cmp	esi, ecx
	jl	SHORT $LL6@xmlValidGe
$LN5@xmlValidGe:

; 6936 : 	    names[(*len)++] = BAD_CAST "#PCDATA";

	mov	DWORD PTR [ebx+ecx*4], OFFSET ??_C@_07ELDBONKP@?$CDPCDATA@
	inc	DWORD PTR [edi]

; 6942 : 	    break;
; 6943 : 	case XML_ELEMENT_CONTENT_SEQ:
; 6944 : 	    xmlValidGetPotentialChildren(ctree->c1, names, len, max);
; 6945 : 	    xmlValidGetPotentialChildren(ctree->c2, names, len, max);
; 6946 : 	    break;
; 6947 : 	case XML_ELEMENT_CONTENT_OR:
; 6948 : 	    xmlValidGetPotentialChildren(ctree->c1, names, len, max);
; 6949 : 	    xmlValidGetPotentialChildren(ctree->c2, names, len, max);
; 6950 : 	    break;
; 6951 :    }
; 6952 : 
; 6953 :    return(*len);

	mov	eax, DWORD PTR [edi]
	pop	esi
	pop	edi

; 6954 : }

	pop	ebx
	pop	ebp
	ret	0
$LN15@xmlValidGe:

; 6937 : 	    break;
; 6938 : 	case XML_ELEMENT_CONTENT_ELEMENT:
; 6939 : 	    for (i = 0; i < *len;i++)

	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN8@xmlValidGe
$LL9@xmlValidGe:

; 6940 : 		if (xmlStrEqual(ctree->name, names[i])) return(*len);

	push	DWORD PTR [ebx+esi*4]
	push	DWORD PTR [edx+8]
	call	_xmlStrEqual
	mov	ecx, DWORD PTR [edi]
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN23@xmlValidGe

; 6937 : 	    break;
; 6938 : 	case XML_ELEMENT_CONTENT_ELEMENT:
; 6939 : 	    for (i = 0; i < *len;i++)

	mov	edx, DWORD PTR _ctree$[ebp]
	inc	esi
	cmp	esi, ecx
	jl	SHORT $LL9@xmlValidGe
$LN8@xmlValidGe:

; 6941 : 	    names[(*len)++] = ctree->name;

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ebx+ecx*4], eax
	inc	DWORD PTR [edi]

; 6942 : 	    break;
; 6943 : 	case XML_ELEMENT_CONTENT_SEQ:
; 6944 : 	    xmlValidGetPotentialChildren(ctree->c1, names, len, max);
; 6945 : 	    xmlValidGetPotentialChildren(ctree->c2, names, len, max);
; 6946 : 	    break;
; 6947 : 	case XML_ELEMENT_CONTENT_OR:
; 6948 : 	    xmlValidGetPotentialChildren(ctree->c1, names, len, max);
; 6949 : 	    xmlValidGetPotentialChildren(ctree->c2, names, len, max);
; 6950 : 	    break;
; 6951 :    }
; 6952 : 
; 6953 :    return(*len);

	mov	eax, DWORD PTR [edi]
	pop	esi
	pop	edi

; 6954 : }

	pop	ebx
	pop	ebp
	ret	0
$LN23@xmlValidGe:
	pop	esi
	pop	edi

; 6940 : 		if (xmlStrEqual(ctree->name, names[i])) return(*len);

	mov	eax, ecx

; 6954 : }

	pop	ebx
	pop	ebp
	ret	0
$LN18@xmlValidGe:

; 6942 : 	    break;
; 6943 : 	case XML_ELEMENT_CONTENT_SEQ:
; 6944 : 	    xmlValidGetPotentialChildren(ctree->c1, names, len, max);
; 6945 : 	    xmlValidGetPotentialChildren(ctree->c2, names, len, max);
; 6946 : 	    break;
; 6947 : 	case XML_ELEMENT_CONTENT_OR:
; 6948 : 	    xmlValidGetPotentialChildren(ctree->c1, names, len, max);
; 6949 : 	    xmlValidGetPotentialChildren(ctree->c2, names, len, max);
; 6950 : 	    break;
; 6951 :    }
; 6952 : 
; 6953 :    return(*len);

	push	esi
	push	edi
	push	ebx
	push	DWORD PTR [edx+12]
	call	_xmlValidGetPotentialChildren
	mov	eax, DWORD PTR _ctree$[ebp]
	push	esi
	push	edi
	push	ebx
	push	DWORD PTR [eax+16]
	call	_xmlValidGetPotentialChildren
	add	esp, 32					; 00000020H
$LN2@xmlValidGe:
	mov	eax, DWORD PTR [edi]
	pop	esi
	pop	edi

; 6954 : }

	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlValidGe:
	pop	edi

; 6929 :         return(-1);

	or	eax, -1

; 6954 : }

	pop	ebx
	pop	ebp
	ret	0
$LN32@xmlValidGe:
	DD	$LN13@xmlValidGe
	DD	$LN15@xmlValidGe
	DD	$LN18@xmlValidGe
	DD	$LN18@xmlValidGe
_xmlValidGetPotentialChildren ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlGetDtdElementDesc
_TEXT	SEGMENT
_prefix$ = -4						; size = 4
_dtd$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlGetDtdElementDesc PROC				; COMDAT

; 3176 : xmlGetDtdElementDesc(xmlDtdPtr dtd, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _dtd$[ebp]
	mov	DWORD PTR _prefix$[ebp], 0
	test	eax, eax
	je	SHORT $LN3@xmlGetDtdE

; 3177 :     xmlElementTablePtr table;
; 3178 :     xmlElementPtr cur;
; 3179 :     xmlChar *uqname = NULL, *prefix = NULL;
; 3180 : 
; 3181 :     if ((dtd == NULL) || (name == NULL)) return(NULL);

	mov	esi, DWORD PTR _name$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlGetDtdE

; 3182 :     if (dtd->elements == NULL)

	mov	ebx, DWORD PTR [eax+40]
	test	ebx, ebx
	je	SHORT $LN3@xmlGetDtdE

; 3183 : 	return(NULL);
; 3184 :     table = (xmlElementTablePtr) dtd->elements;
; 3185 : 
; 3186 :     uqname = xmlSplitQName2(name, &prefix);

	push	edi
	lea	eax, DWORD PTR _prefix$[ebp]
	push	eax
	push	esi
	call	_xmlSplitQName2

; 3187 :     if (uqname != NULL)
; 3188 :         name = uqname;
; 3189 :     cur = xmlHashLookup2(table, name, prefix);

	push	DWORD PTR _prefix$[ebp]
	mov	edi, eax
	test	edi, edi
	cmovne	esi, edi
	push	esi
	push	ebx
	call	_xmlHashLookup2

; 3190 :     if (prefix != NULL) xmlFree(prefix);

	mov	ecx, DWORD PTR _prefix$[ebp]
	add	esp, 20					; 00000014H
	mov	esi, eax
	test	ecx, ecx
	je	SHORT $LN6@xmlGetDtdE
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlGetDtdE:

; 3191 :     if (uqname != NULL) xmlFree(uqname);

	test	edi, edi
	je	SHORT $LN7@xmlGetDtdE
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlGetDtdE:

; 3192 :     return(cur);

	pop	edi
	mov	eax, esi
	pop	esi

; 3193 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlGetDtdE:
	pop	esi

; 3177 :     xmlElementTablePtr table;
; 3178 :     xmlElementPtr cur;
; 3179 :     xmlChar *uqname = NULL, *prefix = NULL;
; 3180 : 
; 3181 :     if ((dtd == NULL) || (name == NULL)) return(NULL);

	xor	eax, eax

; 3193 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlGetDtdElementDesc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlGetDtdQElementDesc
_TEXT	SEGMENT
_dtd$ = 8						; size = 4
_name$ = 12						; size = 4
_prefix$ = 16						; size = 4
_xmlGetDtdQElementDesc PROC				; COMDAT

; 3275 : 	              const xmlChar *prefix) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _dtd$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlGetDtdQ

; 3276 :     xmlElementTablePtr table;
; 3277 : 
; 3278 :     if (dtd == NULL) return(NULL);
; 3279 :     if (dtd->elements == NULL) return(NULL);

	mov	eax, DWORD PTR [eax+40]
	test	eax, eax
	je	SHORT $LN5@xmlGetDtdQ

; 3280 :     table = (xmlElementTablePtr) dtd->elements;
; 3281 : 
; 3282 :     return(xmlHashLookup2(table, name, prefix));

	mov	DWORD PTR _dtd$[ebp], eax

; 3283 : }

	pop	ebp

; 3280 :     table = (xmlElementTablePtr) dtd->elements;
; 3281 : 
; 3282 :     return(xmlHashLookup2(table, name, prefix));

	jmp	_xmlHashLookup2
$LN5@xmlGetDtdQ:

; 3276 :     xmlElementTablePtr table;
; 3277 : 
; 3278 :     if (dtd == NULL) return(NULL);
; 3279 :     if (dtd->elements == NULL) return(NULL);

	xor	eax, eax

; 3283 : }

	pop	ebp
	ret	0
_xmlGetDtdQElementDesc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlGetDtdNotationDesc
_TEXT	SEGMENT
_dtd$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlGetDtdNotationDesc PROC				; COMDAT

; 3357 : xmlGetDtdNotationDesc(xmlDtdPtr dtd, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _dtd$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlGetDtdN

; 3358 :     xmlNotationTablePtr table;
; 3359 : 
; 3360 :     if (dtd == NULL) return(NULL);
; 3361 :     if (dtd->notations == NULL) return(NULL);

	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	SHORT $LN5@xmlGetDtdN

; 3362 :     table = (xmlNotationTablePtr) dtd->notations;
; 3363 : 
; 3364 :     return(xmlHashLookup(table, name));

	mov	DWORD PTR _dtd$[ebp], eax

; 3365 : }

	pop	ebp

; 3362 :     table = (xmlNotationTablePtr) dtd->notations;
; 3363 : 
; 3364 :     return(xmlHashLookup(table, name));

	jmp	_xmlHashLookup
$LN5@xmlGetDtdN:

; 3358 :     xmlNotationTablePtr table;
; 3359 : 
; 3360 :     if (dtd == NULL) return(NULL);
; 3361 :     if (dtd->notations == NULL) return(NULL);

	xor	eax, eax

; 3365 : }

	pop	ebp
	ret	0
_xmlGetDtdNotationDesc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlGetDtdQAttrDesc
_TEXT	SEGMENT
_dtd$ = 8						; size = 4
_elem$ = 12						; size = 4
_name$ = 16						; size = 4
_prefix$ = 20						; size = 4
_xmlGetDtdQAttrDesc PROC				; COMDAT

; 3336 : 	          const xmlChar *prefix) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _dtd$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlGetDtdQ

; 3337 :     xmlAttributeTablePtr table;
; 3338 : 
; 3339 :     if (dtd == NULL) return(NULL);
; 3340 :     if (dtd->attributes == NULL) return(NULL);

	mov	eax, DWORD PTR [eax+44]
	test	eax, eax
	je	SHORT $LN5@xmlGetDtdQ

; 3341 :     table = (xmlAttributeTablePtr) dtd->attributes;
; 3342 : 
; 3343 :     return(xmlHashLookup3(table, name, prefix, elem));

	push	DWORD PTR _elem$[ebp]
	push	DWORD PTR _prefix$[ebp]
	push	DWORD PTR _name$[ebp]
	push	eax
	call	_xmlHashLookup3
	add	esp, 16					; 00000010H

; 3344 : }

	pop	ebp
	ret	0
$LN5@xmlGetDtdQ:

; 3337 :     xmlAttributeTablePtr table;
; 3338 : 
; 3339 :     if (dtd == NULL) return(NULL);
; 3340 :     if (dtd->attributes == NULL) return(NULL);

	xor	eax, eax

; 3344 : }

	pop	ebp
	ret	0
_xmlGetDtdQAttrDesc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlGetDtdAttrDesc
_TEXT	SEGMENT
_prefix$ = -4						; size = 4
_dtd$ = 8						; size = 4
_elem$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlGetDtdAttrDesc PROC					; COMDAT

; 3298 : xmlGetDtdAttrDesc(xmlDtdPtr dtd, const xmlChar *elem, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _dtd$[ebp]
	mov	DWORD PTR _prefix$[ebp], 0
	test	esi, esi
	je	SHORT $LN10@xmlGetDtdA

; 3299 :     xmlAttributeTablePtr table;
; 3300 :     xmlAttributePtr cur;
; 3301 :     xmlChar *uqname = NULL, *prefix = NULL;
; 3302 : 
; 3303 :     if (dtd == NULL) return(NULL);
; 3304 :     if (dtd->attributes == NULL) return(NULL);

	mov	esi, DWORD PTR [esi+44]
	test	esi, esi
	je	SHORT $LN10@xmlGetDtdA

; 3305 : 
; 3306 :     table = (xmlAttributeTablePtr) dtd->attributes;
; 3307 :     if (table == NULL)
; 3308 : 	return(NULL);
; 3309 : 
; 3310 :     uqname = xmlSplitQName2(name, &prefix);

	push	edi
	lea	eax, DWORD PTR _prefix$[ebp]
	push	eax
	push	DWORD PTR _name$[ebp]
	call	_xmlSplitQName2
	add	esp, 8
	mov	edi, eax

; 3311 : 
; 3312 :     if (uqname != NULL) {

	push	DWORD PTR _elem$[ebp]
	test	edi, edi
	je	SHORT $LN5@xmlGetDtdA

; 3313 : 	cur = xmlHashLookup3(table, uqname, prefix, elem);

	push	DWORD PTR _prefix$[ebp]
	push	edi
	push	esi
	call	_xmlHashLookup3
	mov	esi, eax
	add	esp, 16					; 00000010H

; 3314 : 	if (prefix != NULL) xmlFree(prefix);

	mov	eax, DWORD PTR _prefix$[ebp]
	test	eax, eax
	je	SHORT $LN7@xmlGetDtdA
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlGetDtdA:

; 3315 : 	if (uqname != NULL) xmlFree(uqname);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3318 :     return(cur);

	mov	eax, esi
	pop	edi
	pop	esi

; 3319 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlGetDtdA:

; 3316 :     } else
; 3317 : 	cur = xmlHashLookup3(table, name, NULL, elem);

	push	0
	push	DWORD PTR _name$[ebp]
	push	esi
	call	_xmlHashLookup3
	add	esp, 16					; 00000010H
	mov	esi, eax

; 3318 :     return(cur);

	pop	edi
	pop	esi

; 3319 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlGetDtdA:

; 3299 :     xmlAttributeTablePtr table;
; 3300 :     xmlAttributePtr cur;
; 3301 :     xmlChar *uqname = NULL, *prefix = NULL;
; 3302 : 
; 3303 :     if (dtd == NULL) return(NULL);
; 3304 :     if (dtd->attributes == NULL) return(NULL);

	xor	eax, eax
	pop	esi

; 3319 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlGetDtdAttrDesc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlIsMixedElement
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlIsMixedElement PROC					; COMDAT

; 3413 : xmlIsMixedElement(xmlDocPtr doc, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _doc$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlIsMixed

; 3414 :     xmlElementPtr elemDecl;
; 3415 : 
; 3416 :     if ((doc == NULL) || (doc->intSubset == NULL)) return(-1);

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN5@xmlIsMixed

; 3417 : 
; 3418 :     elemDecl = xmlGetDtdElementDesc(doc->intSubset, name);

	push	DWORD PTR _name$[ebp]
	push	eax
	call	_xmlGetDtdElementDesc
	add	esp, 8

; 3419 :     if ((elemDecl == NULL) && (doc->extSubset != NULL))

	test	eax, eax
	jne	SHORT $LN7@xmlIsMixed
	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN5@xmlIsMixed

; 3420 : 	elemDecl = xmlGetDtdElementDesc(doc->extSubset, name);

	push	DWORD PTR _name$[ebp]
	push	eax
	call	_xmlGetDtdElementDesc
	add	esp, 8

; 3421 :     if (elemDecl == NULL) return(-1);

	test	eax, eax
	je	SHORT $LN5@xmlIsMixed
$LN7@xmlIsMixed:

; 3422 :     switch (elemDecl->etype) {

	mov	eax, DWORD PTR [eax+36]
	cmp	eax, 4
	ja	SHORT $LN10@xmlIsMixed
	jmp	DWORD PTR $LN14@xmlIsMixed[eax*4]
$LN9@xmlIsMixed:

; 3423 : 	case XML_ELEMENT_TYPE_UNDEFINED:
; 3424 : 	    return(-1);
; 3425 : 	case XML_ELEMENT_TYPE_ELEMENT:
; 3426 : 	    return(0);

	xor	eax, eax
	pop	esi

; 3427 :         case XML_ELEMENT_TYPE_EMPTY:
; 3428 : 	    /*
; 3429 : 	     * return 1 for EMPTY since we want VC error to pop up
; 3430 : 	     * on <empty>     </empty> for example
; 3431 : 	     */
; 3432 : 	case XML_ELEMENT_TYPE_ANY:
; 3433 : 	case XML_ELEMENT_TYPE_MIXED:
; 3434 : 	    return(1);
; 3435 :     }
; 3436 :     return(1);
; 3437 : }

	pop	ebp
	ret	0
$LN10@xmlIsMixed:
	mov	eax, 1
	pop	esi
	pop	ebp
	ret	0
$LN5@xmlIsMixed:

; 3414 :     xmlElementPtr elemDecl;
; 3415 : 
; 3416 :     if ((doc == NULL) || (doc->intSubset == NULL)) return(-1);

	or	eax, -1
	pop	esi

; 3427 :         case XML_ELEMENT_TYPE_EMPTY:
; 3428 : 	    /*
; 3429 : 	     * return 1 for EMPTY since we want VC error to pop up
; 3430 : 	     * on <empty>     </empty> for example
; 3431 : 	     */
; 3432 : 	case XML_ELEMENT_TYPE_ANY:
; 3433 : 	case XML_ELEMENT_TYPE_MIXED:
; 3434 : 	    return(1);
; 3435 :     }
; 3436 :     return(1);
; 3437 : }

	pop	ebp
	ret	0
	npad	3
$LN14@xmlIsMixed:
	DD	$LN5@xmlIsMixed
	DD	$LN10@xmlIsMixed
	DD	$LN10@xmlIsMixed
	DD	$LN10@xmlIsMixed
	DD	$LN9@xmlIsMixed
_xmlIsMixedElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateNotationUse
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_notationName$ = 16					; size = 4
_xmlValidateNotationUse PROC				; COMDAT

; 3382 :                        const xmlChar *notationName) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _doc$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlValidat

; 3383 :     xmlNotationPtr notaDecl;
; 3384 :     if ((doc == NULL) || (doc->intSubset == NULL) ||

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN3@xmlValidat
	mov	edi, DWORD PTR _notationName$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlValidat

; 3361 :     if (dtd->notations == NULL) return(NULL);

	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	SHORT $LN11@xmlValidat

; 3362 :     table = (xmlNotationTablePtr) dtd->notations;
; 3363 : 
; 3364 :     return(xmlHashLookup(table, name));

	push	edi
	push	eax
	call	_xmlHashLookup
	add	esp, 8

; 3386 : 
; 3387 :     notaDecl = xmlGetDtdNotationDesc(doc->intSubset, notationName);
; 3388 :     if ((notaDecl == NULL) && (doc->extSubset != NULL))

	test	eax, eax
	jne	SHORT $LN5@xmlValidat
$LN11@xmlValidat:
	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN12@xmlValidat

; 3389 : 	notaDecl = xmlGetDtdNotationDesc(doc->extSubset, notationName);

	push	edi
	push	eax
	call	_xmlGetDtdNotationDesc
	add	esp, 8

; 3390 : 
; 3391 :     if ((notaDecl == NULL) && (ctxt != NULL)) {

	test	eax, eax
	jne	SHORT $LN5@xmlValidat
$LN12@xmlValidat:
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlValidat

; 3392 : 	xmlErrValidNode(ctxt, (xmlNodePtr) doc, XML_DTD_UNKNOWN_NOTATION,

	push	0
	push	0
	push	edi
	push	OFFSET ??_C@_0BN@NONOBNKE@NOTATION?5?$CFs?5is?5not?5declared?6@
	push	537					; 00000219H
	push	esi
	push	eax
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 3393 : 	                "NOTATION %s is not declared\n",
; 3394 : 		        notationName, NULL, NULL);
; 3395 : 	return(0);

	xor	eax, eax
	pop	edi

; 3398 : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlValidat:
	pop	edi

; 3396 :     }
; 3397 :     return(1);

	mov	eax, 1

; 3398 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlValidat:
	pop	edi

; 3385 :         (notationName == NULL)) return(-1);

	or	eax, -1

; 3398 : }

	pop	esi
	pop	ebp
	ret	0
_xmlValidateNotationUse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateDocumentFinal
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlValidateDocumentFinal PROC				; COMDAT

; 6603 : xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	test	esi, esi
	jne	SHORT $LN2@xmlValidat

; 6604 :     xmlRefTablePtr table;
; 6605 :     unsigned int save;
; 6606 : 
; 6607 :     if (ctxt == NULL)
; 6608 :         return(0);

	xor	eax, eax
	pop	esi

; 6635 : }

	pop	ebp
	ret	0
$LN2@xmlValidat:

; 6609 :     if (doc == NULL) {

	mov	ecx, DWORD PTR _doc$[ebp]
	push	edi
	mov	edi, DWORD PTR [esi+28]
	test	ecx, ecx
	jne	SHORT $LN3@xmlValidat

; 106  :         data = ctxt->userData;

	mov	edx, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR [esi+4]

; 107  : 	/* Use the special values to detect if it is part of a parsing
; 108  : 	   context */
; 109  : 	if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||

	cmp	edi, -1412623820			; abcd1234H
	je	SHORT $LN8@xmlValidat
	cmp	edi, -1412623819			; abcd1235H
	jne	SHORT $LN9@xmlValidat
$LN8@xmlValidat:

; 110  : 	    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {
; 111  : 	    long delta = (char *) ctxt - (char *) ctxt->userData;

	sub	esi, edx

; 112  : 	    if ((delta > 0) && (delta < 250))

	lea	eax, DWORD PTR [esi-1]
	cmp	eax, 248				; 000000f8H
	cmovbe	ecx, edx
$LN9@xmlValidat:

; 113  : 		pctxt = ctxt->userData;
; 114  : 	}
; 115  :     }
; 116  :     if (extra)
; 117  :         __xmlRaiseError(NULL, channel, data,
; 118  :                         pctxt, NULL, XML_FROM_VALID, error,
; 119  :                         XML_ERR_ERROR, NULL, 0, extra, NULL, NULL, 0, 0,
; 120  :                         msg, extra);
; 121  :     else
; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0CH@PKJJCFEM@xmlValidateDocumentFinal?3?5doc?5?$DN@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	521					; 00000209H
	push	23					; 00000017H
	push	0
	push	ecx
	push	edx
	push	ebx
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 6610 :         xmlErrValid(ctxt, XML_DTD_NO_DOC,
; 6611 : 		"xmlValidateDocumentFinal: doc == NULL\n", NULL);
; 6612 : 	return(0);

	xor	eax, eax
	pop	ebx
	pop	edi
	pop	esi

; 6635 : }

	pop	ebp
	ret	0
$LN3@xmlValidat:

; 6613 :     }
; 6614 : 
; 6615 :     /* trick to get correct line id report */
; 6616 :     save = ctxt->finishDtd;
; 6617 :     ctxt->finishDtd = 0;
; 6618 : 
; 6619 :     /*
; 6620 :      * Check all the NOTATION/NOTATIONS attributes
; 6621 :      */
; 6622 :     /*
; 6623 :      * Check all the ENTITY/ENTITIES attributes definition for validity
; 6624 :      */
; 6625 :     /*
; 6626 :      * Check all the IDREF/IDREFS attributes definition for validity
; 6627 :      */
; 6628 :     table = (xmlRefTablePtr) doc->refs;
; 6629 :     ctxt->doc = doc;
; 6630 :     ctxt->valid = 1;
; 6631 :     xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);

	push	esi
	mov	DWORD PTR [esi+28], 0
	mov	eax, DWORD PTR [ecx+68]
	push	OFFSET _xmlValidateCheckRefCallback
	push	eax
	mov	DWORD PTR [esi+32], ecx
	mov	DWORD PTR [esi+36], 1
	call	_xmlHashScan

; 6632 : 
; 6633 :     ctxt->finishDtd = save;
; 6634 :     return(ctxt->valid);

	mov	eax, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+28], edi
	pop	edi
	pop	esi

; 6635 : }

	pop	ebp
	ret	0
_xmlValidateDocumentFinal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateOneNamespace
_TEXT	SEGMENT
_fn$1 = -64						; size = 50
tv1239 = -12						; size = 4
tv1197 = -12						; size = 4
tv1191 = -12						; size = 4
tv1185 = -12						; size = 4
tv1179 = -12						; size = 4
tv1171 = -12						; size = 4
tv1165 = -12						; size = 4
_fullname$1$ = -12					; size = 4
_ret$1$ = -8						; size = 4
$T2 = -4						; size = 4
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_elem$ = 16						; size = 4
_prefix$ = 20						; size = 4
_ns$ = 24						; size = 4
_value$ = 28						; size = 4
_xmlValidateOneNamespace PROC				; COMDAT

; 4559 : xmlNodePtr elem, const xmlChar *prefix, xmlNsPtr ns, const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	mov	ebx, DWORD PTR _ns$[ebp]
	mov	ecx, OFFSET __56F63275_valid@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _doc$[ebp]
	mov	DWORD PTR _ret$1$[ebp], 1
	test	esi, esi
	je	SHORT $LN10@xmlValidat

; 4560 :     /* xmlElementPtr elemDecl; */
; 4561 :     xmlAttributePtr attrDecl =  NULL;
; 4562 :     int val;
; 4563 :     int ret = 1;
; 4564 : 
; 4565 :     CHECK_DTD;

	cmp	DWORD PTR [esi+44], 0
	jne	SHORT $LN70@xmlValidat
	cmp	DWORD PTR [esi+48], 0
	je	SHORT $LN10@xmlValidat
$LN70@xmlValidat:

; 4566 :     if ((elem == NULL) || (elem->name == NULL)) return(0);

	mov	edi, DWORD PTR _elem$[ebp]
	test	edi, edi
	je	SHORT $LN10@xmlValidat
	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN10@xmlValidat

; 4567 :     if ((ns == NULL) || (ns->href == NULL)) return(0);

	test	ebx, ebx
	je	SHORT $LN10@xmlValidat
	cmp	DWORD PTR [ebx+8], 0
	je	SHORT $LN10@xmlValidat

; 4568 : 
; 4569 :     if (prefix != NULL) {

	mov	eax, DWORD PTR _prefix$[ebp]
	test	eax, eax
	je	$LN71@xmlValidat

; 4570 : 	xmlChar fn[50];
; 4571 : 	xmlChar *fullname;
; 4572 : 
; 4573 : 	fullname = xmlBuildQName(elem->name, prefix, fn, 50);

	push	50					; 00000032H
	lea	edx, DWORD PTR _fn$1[ebp]
	push	edx
	push	eax
	push	ecx
	call	_xmlBuildQName
	mov	ecx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _fullname$1$[ebp], ecx

; 4574 : 	if (fullname == NULL) {

	test	ecx, ecx
	jne	SHORT $LN14@xmlValidat

; 4575 : 	    xmlVErrMemory(ctxt, "Validating namespace");

	push	OFFSET ??_C@_0BF@INLCBMIM@Validating?5namespace@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlVErrMemory
	add	esp, 8
$LN10@xmlValidat:

; 4762 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlValidat:

; 4576 : 	    return(0);
; 4577 : 	}
; 4578 : 	if (ns->prefix != NULL) {

	mov	edx, DWORD PTR [esi+44]
	lea	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR [eax]
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	test	eax, eax
	je	SHORT $LN15@xmlValidat

; 4579 : 	    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,

	push	eax
	push	ecx
	push	edx
	call	_xmlGetDtdQAttrDesc
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 4580 : 		                          ns->prefix, BAD_CAST "xmlns");
; 4581 : 	    if ((attrDecl == NULL) && (doc->extSubset != NULL))

	test	ebx, ebx
	jne	SHORT $LN18@xmlValidat
	mov	ecx, DWORD PTR [esi+48]
	test	ecx, ecx
	je	SHORT $LN18@xmlValidat

; 4582 : 		attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,

	mov	eax, DWORD PTR $T2[ebp]
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR [eax]
	push	DWORD PTR _fullname$1$[ebp]
	push	ecx
	call	_xmlGetDtdQAttrDesc
	add	esp, 16					; 00000010H

; 4583 : 					  ns->prefix, BAD_CAST "xmlns");
; 4584 : 	} else {

	jmp	SHORT $LN77@xmlValidat
$LN15@xmlValidat:

; 4585 : 	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname,

	push	ecx
	push	edx
	call	_xmlGetDtdAttrDesc
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 4586 : 		                         BAD_CAST "xmlns");
; 4587 : 	    if ((attrDecl == NULL) && (doc->extSubset != NULL))

	test	ebx, ebx
	jne	SHORT $LN18@xmlValidat
	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN18@xmlValidat

; 4588 : 		attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname,

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR _fullname$1$[ebp]
	push	eax
	call	_xmlGetDtdAttrDesc
	add	esp, 12					; 0000000cH
$LN77@xmlValidat:

; 4589 : 			                 BAD_CAST "xmlns");
; 4590 : 	}
; 4591 : 	if ((fullname != fn) && (fullname != elem->name))

	mov	ebx, eax
$LN18@xmlValidat:
	mov	eax, DWORD PTR _fullname$1$[ebp]
	lea	ecx, DWORD PTR _fn$1[ebp]
	cmp	eax, ecx
	je	SHORT $LN19@xmlValidat
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN19@xmlValidat

; 4592 : 	    xmlFree(fullname);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN19@xmlValidat:

; 4593 :     }
; 4594 :     if (attrDecl == NULL) {

	test	ebx, ebx
	jne	$LN25@xmlValidat
	mov	eax, DWORD PTR $T2[ebp]
	jmp	SHORT $LN68@xmlValidat
$LN71@xmlValidat:
	lea	eax, DWORD PTR [ebx+12]
$LN68@xmlValidat:

; 4595 : 	if (ns->prefix != NULL) {

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR tv1239[ebp], eax
	mov	eax, DWORD PTR [edi+8]
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	test	edx, edx
	je	SHORT $LN21@xmlValidat

; 4596 : 	    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,

	push	edx
	push	eax
	push	ecx
	call	_xmlGetDtdQAttrDesc
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR tv1239[ebp]
	mov	DWORD PTR $T2[ebp], eax

; 4597 : 		                          ns->prefix, BAD_CAST "xmlns");
; 4598 : 	    if ((attrDecl == NULL) && (doc->extSubset != NULL))

	test	ebx, ebx
	jne	$LN25@xmlValidat
	mov	ecx, DWORD PTR [esi+48]
	test	ecx, ecx
	je	SHORT $LN69@xmlValidat

; 4599 : 		attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR [eax]
	push	DWORD PTR [edi+8]
	push	ecx
	call	_xmlGetDtdQAttrDesc
	add	esp, 16					; 00000010H

; 4600 : 					      ns->prefix, BAD_CAST "xmlns");
; 4601 : 	} else {

	jmp	SHORT $LN78@xmlValidat
$LN21@xmlValidat:

; 4602 : 	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset,

	push	eax
	push	ecx
	call	_xmlGetDtdAttrDesc
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR tv1239[ebp]
	mov	DWORD PTR $T2[ebp], eax

; 4603 : 		                         elem->name, BAD_CAST "xmlns");
; 4604 : 	    if ((attrDecl == NULL) && (doc->extSubset != NULL))

	test	ebx, ebx
	jne	SHORT $LN25@xmlValidat
	mov	ecx, DWORD PTR [esi+48]
	test	ecx, ecx
	je	SHORT $LN69@xmlValidat

; 4605 : 		attrDecl = xmlGetDtdAttrDesc(doc->extSubset,

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR [edi+8]
	push	ecx
	call	_xmlGetDtdAttrDesc
	add	esp, 12					; 0000000cH
$LN78@xmlValidat:

; 4606 : 					     elem->name, BAD_CAST "xmlns");
; 4607 : 	}
; 4608 :     }
; 4609 : 
; 4610 : 
; 4611 :     /* Validity Constraint: Attribute Value Type */
; 4612 :     if (attrDecl == NULL) {

	mov	ebx, eax
	mov	eax, DWORD PTR tv1239[ebp]
	mov	DWORD PTR $T2[ebp], eax
	test	ebx, ebx
	jne	SHORT $LN25@xmlValidat
$LN69@xmlValidat:

; 4613 : 	if (ns->prefix != NULL) {

	mov	edx, DWORD PTR [eax]
	test	edx, edx
	mov	ecx, DWORD PTR [edi+8]
	mov	eax, ecx
	cmovne	eax, edx

; 4614 : 	    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,
; 4615 : 		   "No declaration for attribute xmlns:%s of element %s\n",
; 4616 : 		   ns->prefix, elem->name, NULL);
; 4617 : 	} else {
; 4618 : 	    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,
; 4619 : 		   "No declaration for attribute xmlns of element %s\n",
; 4620 : 		   elem->name, NULL, NULL);
; 4621 : 	}
; 4622 : 	return(0);

	xor	esi, esi
	push	0
	test	edx, edx
	cmove	ecx, esi
	push	ecx
	push	eax
	mov	ecx, OFFSET ??_C@_0DF@GJIDMPBO@No?5declaration?5for?5attribute?5xm@
	mov	eax, OFFSET ??_C@_0DC@FPONLEAN@No?5declaration?5for?5attribute?5xm@
	cmovne	eax, ecx
	push	eax
	push	533					; 00000215H
	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 4762 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlValidat:

; 4623 :     }
; 4624 : 
; 4625 :     val = xmlValidateAttributeValueInternal(doc, attrDecl->atype, value);

	mov	edi, DWORD PTR _value$[ebp]
	push	edi
	push	DWORD PTR [ebx+40]
	push	esi
	call	_xmlValidateAttributeValueInternal

; 4626 :     if (val == 0) {

	mov	esi, DWORD PTR _elem$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN28@xmlValidat

; 4627 : 	if (ns->prefix != NULL) {

	mov	eax, DWORD PTR $T2[ebp]
	mov	ecx, DWORD PTR [esi+8]

; 4628 : 	    xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,
; 4629 : 	       "Syntax of value for attribute xmlns:%s of %s is not valid\n",
; 4630 : 		   ns->prefix, elem->name, NULL);
; 4631 : 	} else {
; 4632 : 	    xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,
; 4633 : 	       "Syntax of value for attribute xmlns of %s is not valid\n",
; 4634 : 		   elem->name, NULL, NULL);
; 4635 : 	}
; 4636 :         ret = 0;

	push	0
	mov	DWORD PTR tv1165[ebp], 0
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	mov	eax, ecx
	cmove	ecx, DWORD PTR tv1165[ebp]
	cmovne	eax, edx
	push	ecx
	push	eax
	mov	ecx, OFFSET ??_C@_0DL@CBOACJEL@Syntax?5of?5value?5for?5attribute?5x@
	mov	eax, OFFSET ??_C@_0DI@HAHGLIKC@Syntax?5of?5value?5for?5attribute?5x@
	cmovne	eax, ecx
	push	eax
	push	516					; 00000204H
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
	xor	eax, eax
	mov	DWORD PTR _ret$1$[ebp], eax
$LN28@xmlValidat:

; 4637 :     }
; 4638 : 
; 4639 :     /* Validity constraint: Fixed Attribute Default */
; 4640 :     if (attrDecl->def == XML_ATTRIBUTE_FIXED) {

	cmp	DWORD PTR [ebx+44], 4
	jne	SHORT $LN32@xmlValidat

; 4641 : 	if (!xmlStrEqual(value, attrDecl->defaultValue)) {

	push	DWORD PTR [ebx+48]
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN32@xmlValidat

; 4642 : 	    if (ns->prefix != NULL) {

	mov	eax, DWORD PTR $T2[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	ecx, esi

; 4643 : 		xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,
; 4644 :        "Value for attribute xmlns:%s of %s is different from default \"%s\"\n",
; 4645 : 		       ns->prefix, elem->name, attrDecl->defaultValue);
; 4646 : 	    } else {
; 4647 : 		xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,
; 4648 :        "Value for attribute xmlns of %s is different from default \"%s\"\n",
; 4649 : 		       elem->name, attrDecl->defaultValue, NULL);
; 4650 : 	    }
; 4651 : 	    ret = 0;

	mov	DWORD PTR tv1171[ebp], 0
	mov	edi, DWORD PTR [eax]
	test	edi, edi
	mov	eax, DWORD PTR [ebx+48]
	cmove	eax, DWORD PTR tv1171[ebp]
	cmovne	ecx, edi
	cmove	esi, DWORD PTR [ebx+48]
	push	eax
	push	esi
	push	ecx
	mov	ecx, OFFSET ??_C@_0ED@KAGANNGH@Value?5for?5attribute?5xmlns?3?$CFs?5of@
	mov	eax, OFFSET ??_C@_0EA@HGOHDHBG@Value?5for?5attribute?5xmlns?5of?5?$CFs@
	cmovne	eax, ecx
	push	eax
	push	500					; 000001f4H
	push	DWORD PTR _elem$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	mov	edi, DWORD PTR _value$[ebp]
	add	esp, 28					; 0000001cH
	xor	eax, eax
	mov	DWORD PTR _ret$1$[ebp], eax
$LN32@xmlValidat:

; 4652 : 	}
; 4653 :     }
; 4654 : 
; 4655 :     /*
; 4656 :      * Casting ns to xmlAttrPtr is wrong. We'd need separate functions
; 4657 :      * xmlAddID and xmlAddRef for namespace declarations, but it makes
; 4658 :      * no practical sense to use ID types anyway.
; 4659 :      */
; 4660 : #if 0
; 4661 :     /* Validity Constraint: ID uniqueness */
; 4662 :     if (attrDecl->atype == XML_ATTRIBUTE_ID) {
; 4663 :         if (xmlAddID(ctxt, doc, value, (xmlAttrPtr) ns) == NULL)
; 4664 : 	    ret = 0;
; 4665 :     }
; 4666 : 
; 4667 :     if ((attrDecl->atype == XML_ATTRIBUTE_IDREF) ||
; 4668 : 	(attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {
; 4669 :         if (xmlAddRef(ctxt, doc, value, (xmlAttrPtr) ns) == NULL)
; 4670 : 	    ret = 0;
; 4671 :     }
; 4672 : #endif
; 4673 : 
; 4674 :     /* Validity Constraint: Notation Attributes */
; 4675 :     if (attrDecl->atype == XML_ATTRIBUTE_NOTATION) {

	cmp	DWORD PTR [ebx+40], 10			; 0000000aH
	jne	$LN41@xmlValidat

; 4676 :         xmlEnumerationPtr tree = attrDecl->tree;
; 4677 :         xmlNotationPtr nota;
; 4678 : 
; 4679 :         /* First check that the given NOTATION was declared */
; 4680 : 	nota = xmlGetDtdNotationDesc(doc->intSubset, value);

	mov	eax, DWORD PTR _doc$[ebp]
	mov	esi, DWORD PTR [ebx+52]
	push	edi
	push	DWORD PTR [eax+44]
	call	_xmlGetDtdNotationDesc
	add	esp, 8

; 4681 : 	if (nota == NULL)

	test	eax, eax
	jne	SHORT $LN55@xmlValidat

; 4682 : 	    nota = xmlGetDtdNotationDesc(doc->extSubset, value);

	mov	eax, DWORD PTR _doc$[ebp]
	push	edi
	push	DWORD PTR [eax+48]
	call	_xmlGetDtdNotationDesc
	add	esp, 8

; 4683 : 
; 4684 : 	if (nota == NULL) {

	test	eax, eax
	jne	SHORT $LN55@xmlValidat

; 4685 : 	    if (ns->prefix != NULL) {

	mov	eax, DWORD PTR $T2[ebp]

; 4686 : 		xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,
; 4687 :        "Value \"%s\" for attribute xmlns:%s of %s is not a declared Notation\n",
; 4688 : 		       value, ns->prefix, elem->name);
; 4689 : 	    } else {
; 4690 : 		xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,
; 4691 :        "Value \"%s\" for attribute xmlns of %s is not a declared Notation\n",
; 4692 : 		       value, elem->name, NULL);
; 4693 : 	    }
; 4694 : 	    ret = 0;

	mov	DWORD PTR tv1179[ebp], 0
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	mov	eax, DWORD PTR _elem$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, ecx
	cmove	ecx, DWORD PTR tv1179[ebp]
	cmovne	eax, edx
	push	ecx
	push	eax
	push	edi
	mov	ecx, OFFSET ??_C@_0EE@ENPHOLHF@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?3@
	mov	eax, OFFSET ??_C@_0EB@IKNIAELF@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?5@
	cmovne	eax, ecx
	push	eax
	push	537					; 00000219H
	push	DWORD PTR _elem$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
	xor	eax, eax
	mov	DWORD PTR _ret$1$[ebp], eax
$LN55@xmlValidat:

; 4695 :         }
; 4696 : 
; 4697 : 	/* Second, verify that it's among the list */
; 4698 : 	while (tree != NULL) {

	test	esi, esi
	je	SHORT $LN67@xmlValidat
	npad	7
$LL2@xmlValidat:

; 4699 : 	    if (xmlStrEqual(tree->name, value)) break;

	push	edi
	push	DWORD PTR [esi+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN41@xmlValidat

; 4700 : 	    tree = tree->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL2@xmlValidat
$LN67@xmlValidat:

; 4701 : 	}
; 4702 : 	if (tree == NULL) {
; 4703 : 	    if (ns->prefix != NULL) {

	mov	eax, DWORD PTR $T2[ebp]
	mov	esi, DWORD PTR _elem$[ebp]

; 4704 : 		xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,
; 4705 : "Value \"%s\" for attribute xmlns:%s of %s is not among the enumerated notations\n",
; 4706 : 		       value, ns->prefix, elem->name);
; 4707 : 	    } else {
; 4708 : 		xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,
; 4709 : "Value \"%s\" for attribute xmlns of %s is not among the enumerated notations\n",
; 4710 : 		       value, elem->name, NULL);
; 4711 : 	    }
; 4712 : 	    ret = 0;

	mov	DWORD PTR tv1185[ebp], 0
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, ecx
	cmove	ecx, DWORD PTR tv1185[ebp]
	cmovne	eax, edx
	push	ecx
	push	eax
	push	edi
	mov	ecx, OFFSET ??_C@_0EP@PJCDPKEK@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?3@
	mov	eax, OFFSET ??_C@_0EM@LDEIIDJK@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?5@
	cmovne	eax, ecx
	push	eax
	push	527					; 0000020fH
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
	xor	eax, eax
	mov	DWORD PTR _ret$1$[ebp], eax
$LN41@xmlValidat:

; 4713 : 	}
; 4714 :     }
; 4715 : 
; 4716 :     /* Validity Constraint: Enumeration */
; 4717 :     if (attrDecl->atype == XML_ATTRIBUTE_ENUMERATION) {

	cmp	DWORD PTR [ebx+40], 9
	jne	SHORT $LN73@xmlValidat

; 4718 :         xmlEnumerationPtr tree = attrDecl->tree;

	mov	esi, DWORD PTR [ebx+52]

; 4719 : 	while (tree != NULL) {

	test	esi, esi
	je	SHORT $LN66@xmlValidat
$LL4@xmlValidat:

; 4720 : 	    if (xmlStrEqual(tree->name, value)) break;

	push	edi
	push	DWORD PTR [esi+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN73@xmlValidat

; 4721 : 	    tree = tree->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL4@xmlValidat
$LN66@xmlValidat:

; 4722 : 	}
; 4723 : 	if (tree == NULL) {
; 4724 : 	    if (ns->prefix != NULL) {

	mov	eax, DWORD PTR $T2[ebp]
	mov	esi, DWORD PTR _elem$[ebp]

; 4725 : 		xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,
; 4726 : "Value \"%s\" for attribute xmlns:%s of %s is not among the enumerated set\n",
; 4727 : 		       value, ns->prefix, elem->name);
; 4728 : 	    } else {
; 4729 : 		xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,
; 4730 : "Value \"%s\" for attribute xmlns of %s is not among the enumerated set\n",
; 4731 : 		       value, elem->name, NULL);
; 4732 : 	    }
; 4733 : 	    ret = 0;

	mov	DWORD PTR tv1191[ebp], 0
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, ecx
	cmove	ecx, DWORD PTR tv1191[ebp]
	cmovne	eax, edx
	push	ecx
	push	eax
	push	edi
	mov	ecx, OFFSET ??_C@_0EJ@PDIHKDMN@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?3@
	mov	eax, OFFSET ??_C@_0EG@CDCEFKCM@Value?5?$CC?$CFs?$CC?5for?5attribute?5xmlns?5@
	cmovne	eax, ecx
	push	eax
	push	502					; 000001f6H
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
	xor	eax, eax
	mov	DWORD PTR _ret$1$[ebp], eax
	jmp	SHORT $LN46@xmlValidat
$LN73@xmlValidat:

; 4734 : 	}
; 4735 :     }
; 4736 : 
; 4737 :     /* Fixed Attribute Default */
; 4738 :     if ((attrDecl->def == XML_ATTRIBUTE_FIXED) &&

	mov	esi, DWORD PTR _elem$[ebp]
$LN46@xmlValidat:
	cmp	DWORD PTR [ebx+44], 4
	jne	SHORT $LN76@xmlValidat
	push	edi
	push	DWORD PTR [ebx+48]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN76@xmlValidat

; 4739 :         (!xmlStrEqual(attrDecl->defaultValue, value))) {
; 4740 : 	if (ns->prefix != NULL) {

	mov	eax, DWORD PTR $T2[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	ecx, esi

; 4741 : 	    xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,
; 4742 : 		   "Value for attribute xmlns:%s of %s must be \"%s\"\n",
; 4743 : 		   ns->prefix, elem->name, attrDecl->defaultValue);
; 4744 : 	} else {
; 4745 : 	    xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,
; 4746 : 		   "Value for attribute xmlns of %s must be \"%s\"\n",
; 4747 : 		   elem->name, attrDecl->defaultValue, NULL);
; 4748 : 	}
; 4749 :         ret = 0;

	mov	DWORD PTR tv1197[ebp], 0
	mov	edi, DWORD PTR [eax]
	test	edi, edi
	mov	eax, DWORD PTR [ebx+48]
	cmove	eax, DWORD PTR tv1197[ebp]
	cmovne	ecx, edi
	cmove	esi, DWORD PTR [ebx+48]
	mov	edi, DWORD PTR _ctxt$[ebp]
	push	eax
	push	esi
	push	ecx
	mov	ecx, OFFSET ??_C@_0DB@DPJFCMMB@Value?5for?5attribute?5xmlns?3?$CFs?5of@
	mov	eax, OFFSET ??_C@_0CO@DNGFHLPE@Value?5for?5attribute?5xmlns?5of?5?$CFs@
	cmovne	eax, ecx
	push	eax
	push	508					; 000001fcH
	push	DWORD PTR _elem$[ebp]
	push	edi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
	xor	esi, esi
	jmp	SHORT $LN49@xmlValidat
$LN76@xmlValidat:

; 4750 :     }
; 4751 : 
; 4752 :     /* Extra check for the attribute value */
; 4753 :     if (ns->prefix != NULL) {

	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	esi, DWORD PTR _ret$1$[ebp]
$LN49@xmlValidat:
	mov	eax, DWORD PTR $T2[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	push	ecx
	test	edx, edx
	je	SHORT $LN52@xmlValidat

; 4754 : 	ret &= xmlValidateAttributeValue2(ctxt, doc, ns->prefix,

	push	edx

; 4755 : 					  attrDecl->atype, value);
; 4756 :     } else {

	jmp	SHORT $LN79@xmlValidat
$LN52@xmlValidat:

; 4757 : 	ret &= xmlValidateAttributeValue2(ctxt, doc, BAD_CAST "xmlns",

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
$LN79@xmlValidat:

; 4758 : 					  attrDecl->atype, value);
; 4759 :     }
; 4760 : 
; 4761 :     return(ret);

	push	DWORD PTR _doc$[ebp]
	push	edi
	call	_xmlValidateAttributeValue2
	add	esp, 20					; 00000014H
	and	esi, eax
	mov	eax, esi
	pop	edi

; 4762 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidateOneNamespace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateOneAttribute
_TEXT	SEGMENT
_fn$1 = -60						; size = 50
_fullname$1$ = -8					; size = 4
_ret$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_elem$ = 16						; size = 4
_attr$ = 20						; size = 4
_value$ = 24						; size = 4
_xmlValidateOneAttribute PROC				; COMDAT

; 4383 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _doc$[ebp]
	mov	DWORD PTR _ret$1$[ebp], 1
	test	esi, esi
	je	$LN10@xmlValidat

; 4384 :     xmlAttributePtr attrDecl =  NULL;
; 4385 :     int val;
; 4386 :     int ret = 1;
; 4387 : 
; 4388 :     CHECK_DTD;

	cmp	DWORD PTR [esi+44], 0
	jne	SHORT $LN60@xmlValidat
	cmp	DWORD PTR [esi+48], 0
	je	$LN10@xmlValidat
$LN60@xmlValidat:

; 4389 :     if ((elem == NULL) || (elem->name == NULL)) return(0);

	mov	edi, DWORD PTR _elem$[ebp]
	test	edi, edi
	je	$LN10@xmlValidat
	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	$LN10@xmlValidat

; 4390 :     if ((attr == NULL) || (attr->name == NULL)) return(0);

	mov	ebx, DWORD PTR _attr$[ebp]
	test	ebx, ebx
	je	$LN10@xmlValidat
	cmp	DWORD PTR [ebx+8], 0
	je	$LN10@xmlValidat

; 4391 : 
; 4392 :     if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	$LN57@xmlValidat
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	$LN57@xmlValidat

; 4393 : 	xmlChar fn[50];
; 4394 : 	xmlChar *fullname;
; 4395 : 
; 4396 : 	fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);

	push	50					; 00000032H
	lea	edx, DWORD PTR _fn$1[ebp]
	push	edx
	push	eax
	push	ecx
	call	_xmlBuildQName
	add	esp, 16					; 00000010H
	mov	DWORD PTR _fullname$1$[ebp], eax

; 4397 : 	if (fullname == NULL)

	test	eax, eax
	je	$LN10@xmlValidat

; 4398 : 	    return(0);
; 4399 : 	if (attr->ns != NULL) {

	mov	ecx, DWORD PTR [ebx+36]
	test	ecx, ecx
	je	SHORT $LN15@xmlValidat

; 4400 : 	    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,

	push	DWORD PTR [ecx+12]
	push	DWORD PTR [ebx+8]
	push	eax
	push	DWORD PTR [esi+44]
	call	_xmlGetDtdQAttrDesc
	mov	esi, eax
	add	esp, 16					; 00000010H

; 4401 : 		                          attr->name, attr->ns->prefix);
; 4402 : 	    if ((attrDecl == NULL) && (doc->extSubset != NULL))

	test	esi, esi
	jne	SHORT $LN18@xmlValidat
	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	test	ecx, ecx
	je	SHORT $LN18@xmlValidat

; 4403 : 		attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,

	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR [eax+12]
	push	DWORD PTR [ebx+8]
	push	DWORD PTR _fullname$1$[ebp]
	push	ecx
	call	_xmlGetDtdQAttrDesc
	add	esp, 16					; 00000010H

; 4404 : 					      attr->name, attr->ns->prefix);
; 4405 : 	} else {

	jmp	SHORT $LN64@xmlValidat
$LN15@xmlValidat:

; 4406 : 	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, attr->name);

	push	DWORD PTR [ebx+8]
	push	eax
	push	DWORD PTR [esi+44]
	call	_xmlGetDtdAttrDesc
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 4407 : 	    if ((attrDecl == NULL) && (doc->extSubset != NULL))

	test	esi, esi
	jne	SHORT $LN18@xmlValidat
	mov	eax, DWORD PTR _doc$[ebp]
	mov	eax, DWORD PTR [eax+48]
	test	eax, eax
	je	SHORT $LN18@xmlValidat

; 4408 : 		attrDecl = xmlGetDtdAttrDesc(doc->extSubset,

	push	DWORD PTR [ebx+8]
	push	DWORD PTR _fullname$1$[ebp]
	push	eax
	call	_xmlGetDtdAttrDesc
	add	esp, 12					; 0000000cH
$LN64@xmlValidat:

; 4409 : 					     fullname, attr->name);
; 4410 : 	}
; 4411 : 	if ((fullname != fn) && (fullname != elem->name))

	mov	esi, eax
$LN18@xmlValidat:
	mov	eax, DWORD PTR _fullname$1$[ebp]
	lea	ecx, DWORD PTR _fn$1[ebp]
	cmp	eax, ecx
	je	SHORT $LN19@xmlValidat
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN19@xmlValidat

; 4412 : 	    xmlFree(fullname);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN19@xmlValidat:

; 4413 :     }
; 4414 :     if (attrDecl == NULL) {

	test	esi, esi
	jne	$LN25@xmlValidat
	mov	esi, DWORD PTR _doc$[ebp]
$LN57@xmlValidat:

; 4415 : 	if (attr->ns != NULL) {

	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	je	SHORT $LN21@xmlValidat

; 4416 : 	    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,

	push	DWORD PTR [eax+12]
	push	DWORD PTR [ebx+8]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [esi+44]
	call	_xmlGetDtdQAttrDesc
	mov	esi, eax
	add	esp, 16					; 00000010H

; 4417 : 		                          attr->name, attr->ns->prefix);
; 4418 : 	    if ((attrDecl == NULL) && (doc->extSubset != NULL))

	test	esi, esi
	jne	SHORT $LN25@xmlValidat
	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	test	ecx, ecx
	je	SHORT $LN58@xmlValidat

; 4419 : 		attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,

	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR [eax+12]
	push	DWORD PTR [ebx+8]
	push	DWORD PTR [edi+8]
	push	ecx
	call	_xmlGetDtdQAttrDesc
	add	esp, 16					; 00000010H

; 4420 : 					      attr->name, attr->ns->prefix);
; 4421 : 	} else {

	jmp	SHORT $LN65@xmlValidat
$LN21@xmlValidat:

; 4422 : 	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset,

	push	DWORD PTR [ebx+8]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [esi+44]
	call	_xmlGetDtdAttrDesc
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 4423 : 		                         elem->name, attr->name);
; 4424 : 	    if ((attrDecl == NULL) && (doc->extSubset != NULL))

	test	esi, esi
	jne	SHORT $LN25@xmlValidat
	mov	eax, DWORD PTR _doc$[ebp]
	mov	eax, DWORD PTR [eax+48]
	test	eax, eax
	je	SHORT $LN58@xmlValidat

; 4425 : 		attrDecl = xmlGetDtdAttrDesc(doc->extSubset,

	push	DWORD PTR [ebx+8]
	push	DWORD PTR [edi+8]
	push	eax
	call	_xmlGetDtdAttrDesc
	add	esp, 12					; 0000000cH
$LN65@xmlValidat:

; 4426 : 					     elem->name, attr->name);
; 4427 : 	}
; 4428 :     }
; 4429 : 
; 4430 : 
; 4431 :     /* Validity Constraint: Attribute Value Type */
; 4432 :     if (attrDecl == NULL) {

	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN25@xmlValidat
$LN58@xmlValidat:

; 4433 : 	xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,

	push	0
	push	DWORD PTR [edi+8]
	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0CP@IDGJHJLH@No?5declaration?5for?5attribute?5?$CFs@
	push	533					; 00000215H
	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
$LN10@xmlValidat:

; 4526 : 				      attrDecl->atype, value);
; 4527 : 
; 4528 :     return(ret);
; 4529 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlValidat:

; 4434 : 	       "No declaration for attribute %s of element %s\n",
; 4435 : 	       attr->name, elem->name, NULL);
; 4436 : 	return(0);
; 4437 :     }
; 4438 :     attr->atype = attrDecl->atype;
; 4439 : 
; 4440 :     val = xmlValidateAttributeValueInternal(doc, attrDecl->atype, value);

	push	DWORD PTR _value$[ebp]
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [ebx+40], eax
	push	DWORD PTR [esi+40]
	push	DWORD PTR _doc$[ebp]
	call	_xmlValidateAttributeValueInternal
	add	esp, 12					; 0000000cH

; 4441 :     if (val == 0) {

	test	eax, eax
	jne	SHORT $LN26@xmlValidat

; 4442 : 	    xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,

	push	eax
	push	DWORD PTR [edi+8]
	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0DF@PPLCGADM@Syntax?5of?5value?5for?5attribute?5?$CF@
	push	502					; 000001f6H
	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 4443 : 	   "Syntax of value for attribute %s of %s is not valid\n",
; 4444 : 	       attr->name, elem->name, NULL);
; 4445 :         ret = 0;

	mov	DWORD PTR _ret$1$[ebp], 0
$LN26@xmlValidat:

; 4446 :     }
; 4447 : 
; 4448 :     /* Validity constraint: Fixed Attribute Default */
; 4449 :     if (attrDecl->def == XML_ATTRIBUTE_FIXED) {

	cmp	DWORD PTR [esi+44], 4
	jne	SHORT $LN28@xmlValidat

; 4450 : 	if (!xmlStrEqual(value, attrDecl->defaultValue)) {

	push	DWORD PTR [esi+48]
	push	DWORD PTR _value$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN28@xmlValidat

; 4451 : 	    xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,

	push	DWORD PTR [esi+48]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0DN@BPCEOAOB@Value?5for?5attribute?5?$CFs?5of?5?$CFs?5is@
	push	500					; 000001f4H
	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 4452 : 	   "Value for attribute %s of %s is different from default \"%s\"\n",
; 4453 : 		   attr->name, elem->name, attrDecl->defaultValue);
; 4454 : 	    ret = 0;

	mov	DWORD PTR _ret$1$[ebp], 0
$LN28@xmlValidat:

; 4455 : 	}
; 4456 :     }
; 4457 : 
; 4458 :     /* Validity Constraint: ID uniqueness */
; 4459 :     if (attrDecl->atype == XML_ATTRIBUTE_ID) {

	cmp	DWORD PTR [esi+40], 2
	mov	edi, DWORD PTR _value$[ebp]
	jne	SHORT $LN30@xmlValidat

; 4460 :         if (xmlAddID(ctxt, doc, value, attr) == NULL)

	push	ebx
	push	edi
	push	DWORD PTR _doc$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlAddID
	add	esp, 16					; 00000010H
	neg	eax
	sbb	eax, eax
	and	DWORD PTR _ret$1$[ebp], eax
$LN30@xmlValidat:

; 4461 : 	    ret = 0;
; 4462 :     }
; 4463 : 
; 4464 :     if ((attrDecl->atype == XML_ATTRIBUTE_IDREF) ||

	mov	eax, DWORD PTR [esi+40]
	cmp	eax, 3
	je	SHORT $LN32@xmlValidat
	cmp	eax, 4
	jne	SHORT $LN33@xmlValidat
$LN32@xmlValidat:

; 4465 : 	(attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {
; 4466 :         if (xmlAddRef(ctxt, doc, value, attr) == NULL)

	push	ebx
	push	edi
	push	DWORD PTR _doc$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlAddRef
	add	esp, 16					; 00000010H
	neg	eax
	sbb	eax, eax
	and	DWORD PTR _ret$1$[ebp], eax
$LN33@xmlValidat:

; 4467 : 	    ret = 0;
; 4468 :     }
; 4469 : 
; 4470 :     /* Validity Constraint: Notation Attributes */
; 4471 :     if (attrDecl->atype == XML_ATTRIBUTE_NOTATION) {

	cmp	DWORD PTR [esi+40], 10			; 0000000aH
	jne	$LN38@xmlValidat

; 4472 :         xmlEnumerationPtr tree = attrDecl->tree;
; 4473 :         xmlNotationPtr nota;
; 4474 : 
; 4475 :         /* First check that the given NOTATION was declared */
; 4476 : 	nota = xmlGetDtdNotationDesc(doc->intSubset, value);

	mov	eax, DWORD PTR _doc$[ebp]
	push	DWORD PTR _value$[ebp]
	mov	edi, DWORD PTR [esi+52]
	push	DWORD PTR [eax+44]
	call	_xmlGetDtdNotationDesc
	add	esp, 8

; 4477 : 	if (nota == NULL)

	test	eax, eax
	jne	SHORT $LN44@xmlValidat

; 4478 : 	    nota = xmlGetDtdNotationDesc(doc->extSubset, value);

	mov	eax, DWORD PTR _doc$[ebp]
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR [eax+48]
	call	_xmlGetDtdNotationDesc
	add	esp, 8

; 4479 : 
; 4480 : 	if (nota == NULL) {

	test	eax, eax
	jne	SHORT $LN44@xmlValidat

; 4481 : 	    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,

	mov	eax, DWORD PTR _elem$[ebp]
	push	DWORD PTR [eax+8]
	push	DWORD PTR [ebx+8]
	push	DWORD PTR _value$[ebp]
	push	OFFSET ??_C@_0DO@HAIKKCN@Value?5?$CC?$CFs?$CC?5for?5attribute?5?$CFs?5of?5@
	push	537					; 00000219H
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 4482 :        "Value \"%s\" for attribute %s of %s is not a declared Notation\n",
; 4483 : 		   value, attr->name, elem->name);
; 4484 : 	    ret = 0;

	mov	DWORD PTR _ret$1$[ebp], 0
$LN44@xmlValidat:

; 4485 :         }
; 4486 : 
; 4487 : 	/* Second, verify that it's among the list */
; 4488 : 	while (tree != NULL) {

	test	edi, edi
	je	SHORT $LN56@xmlValidat
	npad	7
$LL2@xmlValidat:

; 4489 : 	    if (xmlStrEqual(tree->name, value)) break;

	push	DWORD PTR _value$[ebp]
	push	DWORD PTR [edi+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN38@xmlValidat

; 4490 : 	    tree = tree->next;

	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	SHORT $LL2@xmlValidat
$LN56@xmlValidat:

; 4491 : 	}
; 4492 : 	if (tree == NULL) {
; 4493 : 	    xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,

	mov	eax, DWORD PTR _elem$[ebp]
	push	DWORD PTR [eax+8]
	push	DWORD PTR [ebx+8]
	push	DWORD PTR _value$[ebp]
	push	OFFSET ??_C@_0EJ@LLDEHINL@Value?5?$CC?$CFs?$CC?5for?5attribute?5?$CFs?5of?5@
	push	527					; 0000020fH
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 4494 : "Value \"%s\" for attribute %s of %s is not among the enumerated notations\n",
; 4495 : 		   value, attr->name, elem->name);
; 4496 : 	    ret = 0;

	mov	DWORD PTR _ret$1$[ebp], 0
$LN38@xmlValidat:

; 4497 : 	}
; 4498 :     }
; 4499 : 
; 4500 :     /* Validity Constraint: Enumeration */
; 4501 :     if (attrDecl->atype == XML_ATTRIBUTE_ENUMERATION) {

	cmp	DWORD PTR [esi+40], 9
	jne	SHORT $LN62@xmlValidat

; 4502 :         xmlEnumerationPtr tree = attrDecl->tree;

	mov	edi, DWORD PTR [esi+52]

; 4503 : 	while (tree != NULL) {

	test	edi, edi
	je	SHORT $LN55@xmlValidat
	npad	2
$LL4@xmlValidat:

; 4504 : 	    if (xmlStrEqual(tree->name, value)) break;

	push	DWORD PTR _value$[ebp]
	push	DWORD PTR [edi+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN62@xmlValidat

; 4505 : 	    tree = tree->next;

	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	SHORT $LL4@xmlValidat
$LN55@xmlValidat:

; 4506 : 	}
; 4507 : 	if (tree == NULL) {
; 4508 : 	    xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,

	mov	edi, DWORD PTR _elem$[ebp]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [ebx+8]
	push	DWORD PTR _value$[ebp]
	push	OFFSET ??_C@_0ED@GMECILPN@Value?5?$CC?$CFs?$CC?5for?5attribute?5?$CFs?5of?5@
	push	502					; 000001f6H
	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 4509 :        "Value \"%s\" for attribute %s of %s is not among the enumerated set\n",
; 4510 : 		   value, attr->name, elem->name);
; 4511 : 	    ret = 0;

	mov	DWORD PTR _ret$1$[ebp], 0
	jmp	SHORT $LN41@xmlValidat
$LN62@xmlValidat:

; 4512 : 	}
; 4513 :     }
; 4514 : 
; 4515 :     /* Fixed Attribute Default */
; 4516 :     if ((attrDecl->def == XML_ATTRIBUTE_FIXED) &&

	mov	edi, DWORD PTR _elem$[ebp]
$LN41@xmlValidat:
	cmp	DWORD PTR [esi+44], 4
	jne	SHORT $LN42@xmlValidat
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR [esi+48]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN42@xmlValidat

; 4517 :         (!xmlStrEqual(attrDecl->defaultValue, value))) {
; 4518 : 	xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,

	push	DWORD PTR [esi+48]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0CL@KKBPHLEC@Value?5for?5attribute?5?$CFs?5of?5?$CFs?5mu@
	push	502					; 000001f6H
	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 4519 : 	   "Value for attribute %s of %s must be \"%s\"\n",
; 4520 : 	       attr->name, elem->name, attrDecl->defaultValue);
; 4521 :         ret = 0;

	mov	DWORD PTR _ret$1$[ebp], 0
$LN42@xmlValidat:

; 4522 :     }
; 4523 : 
; 4524 :     /* Extra check for the attribute value */
; 4525 :     ret &= xmlValidateAttributeValue2(ctxt, doc, attr->name,

	push	DWORD PTR _value$[ebp]
	push	DWORD PTR [esi+40]
	push	DWORD PTR [ebx+8]
	push	DWORD PTR _doc$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlValidateAttributeValue2
	add	esp, 20					; 00000014H
	and	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 4526 : 				      attrDecl->atype, value);
; 4527 : 
; 4528 :     return(ret);
; 4529 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidateOneAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateOneElement
_TEXT	SEGMENT
_fn$1 = -68						; size = 50
_name$1$ = -16						; size = 4
_extsubset$ = -16					; size = 4
_fullname$1$ = -12					; size = 4
_child$1$ = -8						; size = 4
_ret$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_attrib$1$ = 12						; size = 4
_elemDecl$1$ = 12					; size = 4
_doc$ = 12						; size = 4
_elem$ = 16						; size = 4
_xmlValidateOneElement PROC				; COMDAT

; 5982 :                       xmlNodePtr elem) {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _doc$[ebp]
	mov	DWORD PTR _ret$1$[ebp], 1
	mov	DWORD PTR _extsubset$[ebp], 0
	test	esi, esi
	je	$LN167@xmlValidat

; 5983 :     xmlElementPtr elemDecl = NULL;
; 5984 :     xmlElementContentPtr cont;
; 5985 :     xmlAttributePtr attr;
; 5986 :     xmlNodePtr child;
; 5987 :     int ret = 1, tmp;
; 5988 :     const xmlChar *name;
; 5989 :     int extsubset = 0;
; 5990 : 
; 5991 :     CHECK_DTD;

	cmp	DWORD PTR [esi+44], 0
	jne	SHORT $LN30@xmlValidat
	cmp	DWORD PTR [esi+48], 0
	je	$LN167@xmlValidat
$LN30@xmlValidat:

; 5992 : 
; 5993 :     if (elem == NULL) return(0);

	mov	ebx, DWORD PTR _elem$[ebp]
	test	ebx, ebx
	je	$LN167@xmlValidat

; 5994 :     switch (elem->type) {

	mov	eax, DWORD PTR [ebx+4]
	dec	eax
	cmp	eax, 19					; 00000013H
	ja	$LN44@xmlValidat
	movzx	eax, BYTE PTR $LN223@xmlValidat[eax]
	jmp	DWORD PTR $LN253@xmlValidat[eax*4]
$LN32@xmlValidat:

; 5995 :         case XML_ATTRIBUTE_NODE:
; 5996 : 	    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CA@EPFCDFAG@Attribute?5element?5not?5expected?6@

; 5997 : 		   "Attribute element not expected\n", NULL, NULL ,NULL);
; 5998 : 	    return(0);

	jmp	$LN249@xmlValidat
$LN33@xmlValidat:

; 5999 :         case XML_TEXT_NODE:
; 6000 : 	    if (elem->children != NULL) {

	cmp	DWORD PTR [ebx+12], 0
	je	SHORT $LN34@xmlValidat

; 6001 : 		xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BN@JALMDBBB@Text?5element?5has?5children?5?$CB?6@

; 6002 : 		                "Text element has children !\n",
; 6003 : 				NULL,NULL,NULL);
; 6004 : 		return(0);

	jmp	$LN249@xmlValidat
$LN34@xmlValidat:

; 6005 : 	    }
; 6006 : 	    if (elem->ns != NULL) {

	cmp	DWORD PTR [ebx+36], 0
	je	SHORT $LN35@xmlValidat

; 6007 : 		xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BO@NIGEHALL@Text?5element?5has?5namespace?5?$CB?6@

; 6008 : 		                "Text element has namespace !\n",
; 6009 : 				NULL,NULL,NULL);
; 6010 : 		return(0);

	jmp	$LN249@xmlValidat
$LN35@xmlValidat:

; 6011 : 	    }
; 6012 : 	    if (elem->content == NULL) {

	cmp	DWORD PTR [ebx+40], 0
	jne	SHORT $LN38@xmlValidat

; 6013 : 		xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BP@DPPADDEP@Text?5element?5has?5no?5content?5?$CB?6@

; 6014 : 		                "Text element has no content !\n",
; 6015 : 				NULL,NULL,NULL);
; 6016 : 		return(0);

	jmp	$LN249@xmlValidat
$LN38@xmlValidat:
	pop	edi

; 6326 :     }
; 6327 :     return(ret);
; 6328 : }

	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@xmlValidat:

; 6017 : 	    }
; 6018 : 	    return(1);
; 6019 :         case XML_XINCLUDE_START:
; 6020 :         case XML_XINCLUDE_END:
; 6021 :             return(1);
; 6022 :         case XML_CDATA_SECTION_NODE:
; 6023 :         case XML_ENTITY_REF_NODE:
; 6024 :         case XML_PI_NODE:
; 6025 :         case XML_COMMENT_NODE:
; 6026 : 	    return(1);
; 6027 :         case XML_ENTITY_NODE:
; 6028 : 	    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BN@CJFFIPOP@Entity?5element?5not?5expected?6@

; 6029 : 		   "Entity element not expected\n", NULL, NULL ,NULL);
; 6030 : 	    return(0);

	jmp	$LN249@xmlValidat
$LN40@xmlValidat:

; 6031 :         case XML_NOTATION_NODE:
; 6032 : 	    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BP@FEDJMKLA@Notation?5element?5not?5expected?6@

; 6033 : 		   "Notation element not expected\n", NULL, NULL ,NULL);
; 6034 : 	    return(0);

	jmp	$LN249@xmlValidat
$LN41@xmlValidat:

; 6035 :         case XML_DOCUMENT_NODE:
; 6036 :         case XML_DOCUMENT_TYPE_NODE:
; 6037 :         case XML_DOCUMENT_FRAG_NODE:
; 6038 : 	    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BP@LPODOPI@Document?5element?5not?5expected?6@

; 6039 : 		   "Document element not expected\n", NULL, NULL ,NULL);
; 6040 : 	    return(0);

	jmp	$LN249@xmlValidat
$LN42@xmlValidat:

; 6041 :         case XML_HTML_DOCUMENT_NODE:
; 6042 : 	    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BM@DIBMDMIN@HTML?5Document?5not?5expected?6@

; 6043 : 		   "HTML Document not expected\n", NULL, NULL ,NULL);
; 6044 : 	    return(0);

	jmp	$LN249@xmlValidat
$LN43@xmlValidat:

; 6049 : 		   "unknown element type\n", NULL, NULL ,NULL);
; 6050 : 	    return(0);
; 6051 :     }
; 6052 : 
; 6053 :     /*
; 6054 :      * Fetch the declaration
; 6055 :      */
; 6056 :     elemDecl = xmlValidGetElemDecl(ctxt, doc, elem, &extsubset);

	mov	edi, DWORD PTR _ctxt$[ebp]
	lea	eax, DWORD PTR _extsubset$[ebp]
	push	eax
	push	ebx
	push	esi
	push	edi
	call	_xmlValidGetElemDecl
	add	esp, 16					; 00000010H
	mov	DWORD PTR _elemDecl$1$[ebp], eax

; 6057 :     if (elemDecl == NULL)

	test	eax, eax
	je	$LN167@xmlValidat

; 6058 : 	return(0);
; 6059 : 
; 6060 :     /*
; 6061 :      * If vstateNr is not zero that means continuous validation is
; 6062 :      * activated, do not try to check the content model at that level.
; 6063 :      */
; 6064 :     if (ctxt->vstateNr == 0) {

	cmp	DWORD PTR [edi+44], 0
	jne	$LN241@xmlValidat

; 6065 :     /* Check that the element content matches the definition */
; 6066 :     switch (elemDecl->etype) {

	mov	eax, DWORD PTR [eax+36]
	cmp	eax, 4
	ja	$LN241@xmlValidat
	jmp	DWORD PTR $LN254@xmlValidat[eax*4]
$LN47@xmlValidat:

; 6067 :         case XML_ELEMENT_TYPE_UNDEFINED:
; 6068 : 	    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ELEM,

	push	0
	push	0
	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0BP@CMBGNCIM@No?5declaration?5for?5element?5?$CFs?6@
	push	534					; 00000216H
	push	ebx
	push	edi

; 6326 :     }
; 6327 :     return(ret);
; 6328 : }

	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@xmlValidat:

; 6069 : 	                    "No declaration for element %s\n",
; 6070 : 		   elem->name, NULL, NULL);
; 6071 : 	    return(0);
; 6072 :         case XML_ELEMENT_TYPE_EMPTY:
; 6073 : 	    if (elem->children != NULL) {

	cmp	DWORD PTR [ebx+12], 0
	je	$LN241@xmlValidat

; 6074 : 		xmlErrValidNode(ctxt, elem, XML_DTD_NOT_EMPTY,

	push	0
	push	0
	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0DE@KLKCMFPH@Element?5?$CFs?5was?5declared?5EMPTY?5t@
	push	528					; 00000210H
	push	ebx
	push	edi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 6075 : 	       "Element %s was declared EMPTY this one has content\n",
; 6076 : 	               elem->name, NULL, NULL);
; 6077 : 		ret = 0;

	xor	ecx, ecx
	mov	DWORD PTR _ret$1$[ebp], ecx

; 6078 : 	    }
; 6079 : 	    break;

	jmp	$LN82@xmlValidat
$LN51@xmlValidat:

; 6080 :         case XML_ELEMENT_TYPE_ANY:
; 6081 : 	    /* I don't think anything is required then */
; 6082 : 	    break;
; 6083 :         case XML_ELEMENT_TYPE_MIXED:
; 6084 : 
; 6085 : 	    /* simple case of declared as #PCDATA */
; 6086 : 	    if ((elemDecl->content != NULL) &&

	mov	esi, DWORD PTR _elemDecl$1$[ebp]
	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	$LN52@xmlValidat
	cmp	DWORD PTR [eax], 1
	jne	$LN52@xmlValidat

; 5560 :     if ((ctxt == NULL) || (doc == NULL) || (elem == NULL) ||

	cmp	DWORD PTR [ebx+4], 1
	mov	DWORD PTR _ret$1$[ebp], 1
	jne	$LN125@xmlValidat

; 5563 : 
; 5564 :     child = elem->children;
; 5565 : 
; 5566 :     cur = child;

	mov	esi, DWORD PTR [ebx+12]

; 5567 :     while (cur != NULL) {

	test	esi, esi
	je	$done$256
$LL118@xmlValidat:

; 5568 : 	switch (cur->type) {

	mov	eax, DWORD PTR [esi+4]
	add	eax, -3					; fffffffdH
	cmp	eax, 5
	ja	SHORT $LN129@xmlValidat
	jmp	DWORD PTR $LN255@xmlValidat[eax*4]
$LN126@xmlValidat:

; 5569 : 	    case XML_ENTITY_REF_NODE:
; 5570 : 		/*
; 5571 : 		 * Push the current node to be able to roll back
; 5572 : 		 * and process within the entity
; 5573 : 		 */
; 5574 : 		if ((cur->children != NULL) &&

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN127@xmlValidat
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN127@xmlValidat

; 5575 : 		    (cur->children->children != NULL)) {
; 5576 : 		    nodeVPush(ctxt, cur);

	push	esi
	push	edi
	call	_nodeVPush

; 5577 : 		    cur = cur->children->children;

	mov	eax, DWORD PTR [esi+12]
	add	esp, 8
	mov	esi, DWORD PTR [eax+12]
	test	esi, esi
	jne	SHORT $LL118@xmlValidat

; 5567 :     while (cur != NULL) {

	jmp	SHORT $done$256
$LN127@xmlValidat:

; 5588 : 		goto done;
; 5589 : 	}
; 5590 : 	/*
; 5591 : 	 * Switch to next element
; 5592 : 	 */
; 5593 : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]

; 5594 : 	while (cur == NULL) {

	test	esi, esi
	jne	SHORT $LL118@xmlValidat
	npad	4
$LL122@xmlValidat:

; 470  :     if (ctxt->nodeNr <= 0)

	mov	ecx, DWORD PTR [edi+16]
	test	ecx, ecx
	jle	SHORT $done$256

; 471  :         return (NULL);
; 472  :     ctxt->nodeNr--;

	dec	ecx
	mov	DWORD PTR [edi+16], ecx

; 473  :     if (ctxt->nodeNr > 0)

	test	ecx, ecx
	jle	SHORT $LN135@xmlValidat

; 474  :         ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];

	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN136@xmlValidat
$LN135@xmlValidat:

; 475  :     else
; 476  :         ctxt->node = NULL;

	xor	eax, eax
$LN136@xmlValidat:

; 477  :     ret = ctxt->nodeTab[ctxt->nodeNr];

	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+24]
	mov	esi, DWORD PTR [eax+ecx*4]

; 478  :     ctxt->nodeTab[ctxt->nodeNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 5596 : 	    if (cur == NULL)

	test	esi, esi
	je	SHORT $done$256

; 5597 : 		break;
; 5598 : 	    cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	je	SHORT $LL122@xmlValidat

; 5567 :     while (cur != NULL) {

	jmp	SHORT $LL118@xmlValidat
$LN129@xmlValidat:

; 5578 : 		    continue;
; 5579 : 		}
; 5580 : 		break;
; 5581 : 	    case XML_COMMENT_NODE:
; 5582 : 	    case XML_PI_NODE:
; 5583 : 	    case XML_TEXT_NODE:
; 5584 : 	    case XML_CDATA_SECTION_NODE:
; 5585 : 		break;
; 5586 : 	    default:
; 5587 : 		ret = 0;

	xor	eax, eax
	mov	DWORD PTR _ret$1$[ebp], eax
$done$256:

; 5599 : 	}
; 5600 :     }
; 5601 : done:
; 5602 :     ctxt->nodeMax = 0;
; 5603 :     ctxt->nodeNr = 0;
; 5604 :     if (ctxt->nodeTab != NULL) {

	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [edi+20], 0
	mov	DWORD PTR [edi+16], 0
	test	eax, eax
	je	SHORT $LN131@xmlValidat

; 5605 : 	xmlFree(ctxt->nodeTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 5606 : 	ctxt->nodeTab = NULL;

	mov	DWORD PTR [edi+24], 0
$LN131@xmlValidat:

; 6087 : 		(elemDecl->content->type == XML_ELEMENT_CONTENT_PCDATA)) {
; 6088 : 		ret = xmlValidateOneCdataElement(ctxt, doc, elem);
; 6089 : 		if (!ret) {

	mov	ecx, DWORD PTR _ret$1$[ebp]
	test	ecx, ecx
	jne	$LN82@xmlValidat
	jmp	SHORT $LN217@xmlValidat
$LN125@xmlValidat:

; 5562 : 	return(0);

	xor	eax, eax
	mov	DWORD PTR _ret$1$[ebp], eax
$LN217@xmlValidat:

; 6090 : 		    xmlErrValidNode(ctxt, elem, XML_DTD_NOT_PCDATA,

	push	0
	push	0
	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0DN@CFJCCMLK@Element?5?$CFs?5was?5declared?5?$CDPCDATA@
	push	529					; 00000211H
	push	ebx
	push	edi
	call	_xmlErrValidNode

; 6091 : 	       "Element %s was declared #PCDATA but contains non text nodes\n",
; 6092 : 			   elem->name, NULL, NULL);
; 6093 : 		}
; 6094 : 		break;

	mov	ecx, DWORD PTR _ret$1$[ebp]
	add	esp, 28					; 0000001cH
	jmp	$LN82@xmlValidat
$LN52@xmlValidat:

; 6095 : 	    }
; 6096 : 	    child = elem->children;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR _child$1$[ebp], eax

; 6097 : 	    /* Hum, this start to get messy */
; 6098 : 	    while (child != NULL) {

	test	eax, eax
	je	$LN241@xmlValidat
$LL6@xmlValidat:

; 6099 : 	        if (child->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [eax+4], 1
	jne	$LN242@xmlValidat

; 6100 : 		    name = child->name;

	mov	ecx, DWORD PTR [eax+8]

; 6101 : 		    if ((child->ns != NULL) && (child->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [eax+36]
	mov	DWORD PTR _name$1$[ebp], ecx
	test	eax, eax
	je	$LN66@xmlValidat
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	$LN66@xmlValidat

; 6102 : 			xmlChar fn[50];
; 6103 : 			xmlChar *fullname;
; 6104 : 
; 6105 : 			fullname = xmlBuildQName(child->name, child->ns->prefix,

	push	50					; 00000032H
	lea	edx, DWORD PTR _fn$1[ebp]
	push	edx
	push	eax
	push	ecx
	call	_xmlBuildQName
	mov	ecx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _fullname$1$[ebp], ecx

; 6106 : 				                 fn, 50);
; 6107 : 			if (fullname == NULL)

	test	ecx, ecx
	je	$LN167@xmlValidat

; 6108 : 			    return(0);
; 6109 : 			cont = elemDecl->content;

	mov	esi, DWORD PTR [esi+40]

; 6110 : 			while (cont != NULL) {

	test	esi, esi
	je	SHORT $LN144@xmlValidat
	npad	1
$LL8@xmlValidat:

; 6111 : 			    if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {

	mov	eax, DWORD PTR [esi]
	cmp	eax, 2
	jne	SHORT $LN57@xmlValidat

; 6112 : 				if (xmlStrEqual(cont->name, fullname))

	push	ecx
	push	DWORD PTR [esi+8]

; 6113 : 				    break;
; 6114 : 			    } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&

	jmp	SHORT $LN244@xmlValidat
$LN57@xmlValidat:

; 6115 : 			       (cont->c1 != NULL) &&

	cmp	eax, 4
	jne	SHORT $LN163@xmlValidat
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN163@xmlValidat
	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN218@xmlValidat

; 6116 : 			       (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){
; 6117 : 				if (xmlStrEqual(cont->c1->name, fullname))

	push	ecx
	push	DWORD PTR [eax+8]
$LN244@xmlValidat:

; 6121 : 				(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){
; 6122 : 				xmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,
; 6123 : 					"Internal: MIXED struct corrupted\n",
; 6124 : 					NULL);
; 6125 : 				break;
; 6126 : 			    }
; 6127 : 			    cont = cont->c2;

	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN144@xmlValidat
	mov	ecx, DWORD PTR _fullname$1$[ebp]
	jmp	SHORT $LN63@xmlValidat
$LN218@xmlValidat:

; 6118 : 				    break;
; 6119 : 			    } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||
; 6120 : 				(cont->c1 == NULL) ||

	test	eax, eax
	je	SHORT $LN163@xmlValidat
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN163@xmlValidat
$LN63@xmlValidat:

; 6121 : 				(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){
; 6122 : 				xmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,
; 6123 : 					"Internal: MIXED struct corrupted\n",
; 6124 : 					NULL);
; 6125 : 				break;
; 6126 : 			    }
; 6127 : 			    cont = cont->c2;

	mov	esi, DWORD PTR [esi+16]
	test	esi, esi
	jne	SHORT $LL8@xmlValidat

; 6311 : 		    if (xmlStrEqual(attr->name, ns->prefix)) {

	jmp	SHORT $LN144@xmlValidat
$LN163@xmlValidat:

; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0CC@LMJFIFCG@Internal?3?5MIXED?5struct?5corrupte@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	519					; 00000207H
	push	23					; 00000017H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN144@xmlValidat:

; 6128 : 			}
; 6129 : 			if ((fullname != fn) && (fullname != child->name))

	mov	eax, DWORD PTR _fullname$1$[ebp]
	lea	ecx, DWORD PTR _fn$1[ebp]
	cmp	eax, ecx
	je	SHORT $LN65@xmlValidat
	mov	ecx, DWORD PTR _child$1$[ebp]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN65@xmlValidat

; 6130 : 			    xmlFree(fullname);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN65@xmlValidat:

; 6131 : 			if (cont != NULL)

	test	esi, esi
	mov	esi, DWORD PTR _elemDecl$1$[ebp]
	jne	$LN226@xmlValidat
	mov	ecx, DWORD PTR _name$1$[ebp]
$LN66@xmlValidat:

; 6132 : 			    goto child_ok;
; 6133 : 		    }
; 6134 : 		    cont = elemDecl->content;

	mov	esi, DWORD PTR [esi+40]

; 6135 : 		    while (cont != NULL) {

	test	esi, esi
	je	SHORT $LN212@xmlValidat
	npad	7
$LL10@xmlValidat:

; 6136 : 		        if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {

	mov	eax, DWORD PTR [esi]
	cmp	eax, 2
	jne	SHORT $LN67@xmlValidat

; 6137 : 			    if (xmlStrEqual(cont->name, name)) break;

	push	ecx
	push	DWORD PTR [esi+8]

; 6138 : 			} else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&

	jmp	SHORT $LN251@xmlValidat
$LN67@xmlValidat:

; 6139 : 			   (cont->c1 != NULL) &&

	cmp	eax, 4
	jne	SHORT $LN166@xmlValidat
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN166@xmlValidat
	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN219@xmlValidat

; 6140 : 			   (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)) {
; 6141 : 			    if (xmlStrEqual(cont->c1->name, name)) break;

	push	ecx
	push	DWORD PTR [eax+8]
$LN251@xmlValidat:

; 6146 : 				    "Internal: MIXED struct corrupted\n",
; 6147 : 				    NULL);
; 6148 : 			    break;
; 6149 : 			}
; 6150 : 			cont = cont->c2;

	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN224@xmlValidat
	jmp	SHORT $LN73@xmlValidat
$LN219@xmlValidat:

; 6142 : 			} else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||
; 6143 : 			    (cont->c1 == NULL) ||

	test	eax, eax
	je	SHORT $LN166@xmlValidat
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN166@xmlValidat
$LN73@xmlValidat:

; 6146 : 				    "Internal: MIXED struct corrupted\n",
; 6147 : 				    NULL);
; 6148 : 			    break;
; 6149 : 			}
; 6150 : 			cont = cont->c2;

	mov	esi, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR _name$1$[ebp]
	test	esi, esi
	jne	SHORT $LL10@xmlValidat
$LN212@xmlValidat:

; 6151 : 		    }
; 6152 : 		    if (cont == NULL) {
; 6153 : 			xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_CHILD,

	push	0
	push	DWORD PTR [ebx+8]
	push	DWORD PTR _name$1$[ebp]
	push	OFFSET ??_C@_0DM@IPIENEI@Element?5?$CFs?5is?5not?5declared?5in?5?$CF@
	push	515					; 00000203H
	push	ebx
	push	edi
	call	_xmlErrValidNode
	mov	eax, DWORD PTR _child$1$[ebp]
	add	esp, 28					; 0000001cH
	mov	esi, DWORD PTR _elemDecl$1$[ebp]

; 6154 : 	       "Element %s is not declared in %s list of possible children\n",
; 6155 : 			       name, elem->name, NULL);
; 6156 : 			ret = 0;

	xor	ecx, ecx
	mov	DWORD PTR _ret$1$[ebp], ecx
	jmp	SHORT $child_ok$257
$LN166@xmlValidat:

; 6144 : 			    (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)) {
; 6145 : 			    xmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,

	push	0
	push	OFFSET ??_C@_0CC@LMJFIFCG@Internal?3?5MIXED?5struct?5corrupte@
	push	519					; 00000207H
	push	edi
	call	_xmlErrValid
	add	esp, 16					; 00000010H
$LN224@xmlValidat:

; 6157 : 		    }
; 6158 : 		}
; 6159 : child_ok:
; 6160 : 	        child = child->next;

	mov	esi, DWORD PTR _elemDecl$1$[ebp]
$LN226@xmlValidat:
	mov	eax, DWORD PTR _child$1$[ebp]
$LN242@xmlValidat:
	mov	ecx, DWORD PTR _ret$1$[ebp]
$child_ok$257:
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR _child$1$[ebp], eax
	test	eax, eax
	jne	$LL6@xmlValidat

; 6311 : 		    if (xmlStrEqual(attr->name, ns->prefix)) {

	jmp	$LN82@xmlValidat
$LN76@xmlValidat:

; 6161 : 	    }
; 6162 : 	    break;
; 6163 :         case XML_ELEMENT_TYPE_ELEMENT:
; 6164 : 	    if ((doc->standalone == 1) && (extsubset == 1)) {

	cmp	DWORD PTR [esi+40], 1
	jne	SHORT $LN222@xmlValidat
	cmp	DWORD PTR _extsubset$[ebp], 1
	jne	SHORT $LN222@xmlValidat

; 6165 : 		/*
; 6166 : 		 * VC: Standalone Document Declaration
; 6167 : 		 *     - element types with element content, if white space
; 6168 : 		 *       occurs directly within any instance of those types.
; 6169 : 		 */
; 6170 : 		child = elem->children;

	mov	edx, DWORD PTR [ebx+12]

; 6171 : 		while (child != NULL) {

	test	edx, edx
	je	SHORT $LN222@xmlValidat
$LL12@xmlValidat:

; 6172 : 		    if (child->type == XML_TEXT_NODE) {

	cmp	DWORD PTR [edx+4], 3
	jne	SHORT $LN81@xmlValidat

; 6173 : 			const xmlChar *content = child->content;

	mov	ecx, DWORD PTR [edx+40]
	npad	7
$LL14@xmlValidat:

; 6174 : 
; 6175 : 			while (IS_BLANK_CH(*content))

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN79@xmlValidat
	cmp	al, 9
	jb	SHORT $LN80@xmlValidat
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN79@xmlValidat
$LN80@xmlValidat:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN15@xmlValidat
$LN79@xmlValidat:

; 6176 : 			    content++;

	inc	ecx
	jmp	SHORT $LL14@xmlValidat
$LN15@xmlValidat:

; 6177 : 			if (*content == 0) {

	test	al, al
	je	SHORT $LN168@xmlValidat
$LN81@xmlValidat:

; 6183 : 			    break;
; 6184 : 			}
; 6185 : 		    }
; 6186 : 		    child =child->next;

	mov	edx, DWORD PTR [edx+24]
	test	edx, edx
	jne	SHORT $LL12@xmlValidat

; 6171 : 		while (child != NULL) {

	jmp	SHORT $LN222@xmlValidat
$LN168@xmlValidat:

; 6178 : 			    xmlErrValidNode(ctxt, elem,

	push	0
	push	0
	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0EM@LHPMEFBO@standalone?3?5?$CFs?5declared?5in?5the?5@
	push	532					; 00000214H
	push	ebx
	push	edi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 6179 : 			                    XML_DTD_STANDALONE_WHITE_SPACE,
; 6180 : "standalone: %s declared in the external subset contains white spaces nodes\n",
; 6181 : 				   elem->name, NULL, NULL);
; 6182 : 			    ret = 0;

	xor	eax, eax
	mov	DWORD PTR _ret$1$[ebp], eax
$LN222@xmlValidat:

; 6187 : 		}
; 6188 : 	    }
; 6189 : 	    child = elem->children;
; 6190 : 	    cont = elemDecl->content;
; 6191 : 	    tmp = xmlValidateElementContent(ctxt, child, elemDecl, 1, elem);

	push	ebx
	push	1
	push	DWORD PTR _elemDecl$1$[ebp]
	push	DWORD PTR [ebx+12]
	push	edi
	call	_xmlValidateElementContent

; 6192 : 	    if (tmp <= 0)

	mov	ecx, DWORD PTR _ret$1$[ebp]
	add	esp, 20					; 00000014H
	test	eax, eax
	cmovle	ecx, eax
	mov	DWORD PTR _ret$1$[ebp], ecx
	jmp	SHORT $LN82@xmlValidat
$LN241@xmlValidat:

; 6193 : 		ret = tmp;
; 6194 : 	    break;
; 6195 :     }
; 6196 :     } /* not continuous */
; 6197 : 
; 6198 :     /* [ VC: Required Attribute ] */
; 6199 :     attr = elemDecl->attributes;

	mov	ecx, 1
$LN82@xmlValidat:
	mov	ebx, DWORD PTR _elemDecl$1$[ebp]
	mov	ebx, DWORD PTR [ebx+44]

; 6200 :     while (attr != NULL) {

	test	ebx, ebx
	je	$LN17@xmlValidat
$LL16@xmlValidat:

; 6201 : 	if (attr->def == XML_ATTRIBUTE_REQUIRED) {

	mov	eax, DWORD PTR [ebx+44]
	cmp	eax, 2
	jne	$LN83@xmlValidat

; 6202 : 	    int qualified = -1;

	or	esi, -1

; 6203 : 
; 6204 : 	    if ((attr->prefix == NULL) &&

	cmp	DWORD PTR [ebx+56], 0
	jne	SHORT $LN220@xmlValidat
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN220@xmlValidat

; 6205 : 		(xmlStrEqual(attr->name, BAD_CAST "xmlns"))) {
; 6206 : 		xmlNsPtr ns;
; 6207 : 
; 6208 : 		ns = elem->nsDef;

	mov	eax, DWORD PTR _elem$[ebp]
	mov	eax, DWORD PTR [eax+48]

; 6209 : 		while (ns != NULL) {

	test	eax, eax
	je	SHORT $LN214@xmlValidat
	npad	9
$LL18@xmlValidat:

; 6210 : 		    if (ns->prefix == NULL)

	cmp	DWORD PTR [eax+12], 0
	je	$LN236@xmlValidat

; 6211 : 			goto found;
; 6212 : 		    ns = ns->next;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL18@xmlValidat
$LN214@xmlValidat:

; 6262 : 		if (attr->prefix == NULL) {

	mov	edi, DWORD PTR [ebx+56]

; 6263 : 		    xmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,
; 6264 : 		       "Element %s does not carry attribute %s\n",
; 6265 : 			   elem->name, attr->name, NULL);
; 6266 : 		    ret = 0;
; 6267 : 	        } else {
; 6268 : 		    xmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,
; 6269 : 		       "Element %s does not carry attribute %s:%s\n",
; 6270 : 			   elem->name, attr->prefix,attr->name);
; 6271 : 		    ret = 0;
; 6272 : 		}

	mov	eax, OFFSET ??_C@_0CI@KOGIECMM@Element?5?$CFs?5does?5not?5carry?5attri@
	test	edi, edi
	mov	esi, edi
	mov	edx, OFFSET ??_C@_0CL@IDAGHCGO@Element?5?$CFs?5does?5not?5carry?5attri@
	cmove	esi, DWORD PTR [ebx+8]
	xor	ecx, ecx
	test	edi, edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	cmovne	ecx, DWORD PTR [ebx+8]
	cmove	edx, eax
	push	ecx
	push	esi
	mov	esi, DWORD PTR _elem$[ebp]
	mov	eax, DWORD PTR [esi+8]
	push	eax
	push	edx
	push	518					; 00000206H
	push	esi
	push	edi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
	xor	ecx, ecx
	mov	DWORD PTR _ret$1$[ebp], ecx
	jmp	$found$258
$LN220@xmlValidat:

; 6213 : 		}
; 6214 : 	    } else if (xmlStrEqual(attr->prefix, BAD_CAST "xmlns")) {

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR [ebx+56]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	mov	eax, DWORD PTR _elem$[ebp]
	je	SHORT $LN88@xmlValidat

; 6215 : 		xmlNsPtr ns;
; 6216 : 
; 6217 : 		ns = elem->nsDef;

	mov	esi, DWORD PTR [eax+48]

; 6218 : 		while (ns != NULL) {

	test	esi, esi
	je	SHORT $LN214@xmlValidat
$LL20@xmlValidat:

; 6219 : 		    if (xmlStrEqual(attr->name, ns->prefix))

	push	DWORD PTR [esi+12]
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN236@xmlValidat

; 6220 : 			goto found;
; 6221 : 		    ns = ns->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL20@xmlValidat

; 6311 : 		    if (xmlStrEqual(attr->name, ns->prefix)) {

	jmp	$LN214@xmlValidat
$LN88@xmlValidat:

; 6222 : 		}
; 6223 : 	    } else {
; 6224 : 		xmlAttrPtr attrib;
; 6225 : 
; 6226 : 		attrib = elem->properties;

	mov	eax, DWORD PTR [eax+44]
	mov	DWORD PTR _attrib$1$[ebp], eax

; 6227 : 		while (attrib != NULL) {

	test	eax, eax
	je	$LN214@xmlValidat
$LL22@xmlValidat:

; 6228 : 		    if (xmlStrEqual(attrib->name, attr->name)) {

	push	DWORD PTR [ebx+8]
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN100@xmlValidat

; 6229 : 			if (attr->prefix != NULL) {

	mov	ecx, DWORD PTR [ebx+56]
	test	ecx, ecx
	je	SHORT $LN236@xmlValidat

; 6230 : 			    xmlNsPtr nameSpace = attrib->ns;

	mov	eax, DWORD PTR _attrib$1$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 6231 : 
; 6232 : 			    if (nameSpace == NULL)

	test	eax, eax
	jne	SHORT $LN95@xmlValidat

; 6233 : 				nameSpace = elem->ns;

	mov	eax, DWORD PTR _elem$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 6234 : 			    /*
; 6235 : 			     * qualified names handling is problematic, having a
; 6236 : 			     * different prefix should be possible but DTDs don't
; 6237 : 			     * allow to define the URI instead of the prefix :-(
; 6238 : 			     */
; 6239 : 			    if (nameSpace == NULL) {

	test	eax, eax
	jne	SHORT $LN95@xmlValidat

; 6240 : 				if (qualified < 0)
; 6241 : 				    qualified = 0;
; 6242 : 			    } else if (!xmlStrEqual(nameSpace->prefix,

	test	esi, esi
	cmovns	eax, esi
	mov	esi, eax
	jmp	SHORT $LN100@xmlValidat
$LN95@xmlValidat:
	push	ecx
	push	DWORD PTR [eax+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN236@xmlValidat

; 6243 : 						    attr->prefix)) {
; 6244 : 				if (qualified < 1)

	cmp	esi, 1
	mov	eax, 1
	cmovl	esi, eax
$LN100@xmlValidat:

; 6245 : 				    qualified = 1;
; 6246 : 			    } else
; 6247 : 				goto found;
; 6248 : 			} else {
; 6249 : 			    /*
; 6250 : 			     * We should allow applications to define namespaces
; 6251 : 			     * for their application even if the DTD doesn't
; 6252 : 			     * carry one, otherwise, basically we would always
; 6253 : 			     * break.
; 6254 : 			     */
; 6255 : 			    goto found;
; 6256 : 			}
; 6257 : 		    }
; 6258 : 		    attrib = attrib->next;

	mov	eax, DWORD PTR _attrib$1$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR _attrib$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LL22@xmlValidat

; 6259 : 		}
; 6260 : 	    }
; 6261 : 	    if (qualified == -1) {

	cmp	esi, -1
	je	$LN214@xmlValidat

; 6273 : 	    } else if (qualified == 0) {

	test	esi, esi
	jne	SHORT $LN105@xmlValidat

; 6274 : 		xmlErrValidWarning(ctxt, elem, XML_DTD_NO_PREFIX,

	push	DWORD PTR [ebx+8]
	mov	esi, DWORD PTR _elem$[ebp]
	push	DWORD PTR [ebx+56]
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0DD@KAGCOGBM@Element?5?$CFs?5required?5attribute?5?$CF@
	push	524					; 0000020cH
$LN248@xmlValidat:

; 6321 : 		}
; 6322 : 	    }
; 6323 : 	}
; 6324 : found:
; 6325 :         attr = attr->nexth;

	push	esi
	push	edi
	call	_xmlErrValidWarning
	add	esp, 28					; 0000001cH
$LN236@xmlValidat:
	mov	ecx, DWORD PTR _ret$1$[ebp]
$found$258:
	mov	ebx, DWORD PTR [ebx+36]
	test	ebx, ebx
	jne	$LL16@xmlValidat
$LN17@xmlValidat:
	pop	edi

; 6326 :     }
; 6327 :     return(ret);
; 6328 : }

	pop	esi
	mov	eax, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN105@xmlValidat:

; 6275 : 		   "Element %s required attribute %s:%s has no prefix\n",
; 6276 : 		       elem->name, attr->prefix, attr->name);
; 6277 : 	    } else if (qualified == 1) {

	cmp	esi, 1
	jne	SHORT $LN236@xmlValidat

; 6278 : 		xmlErrValidWarning(ctxt, elem, XML_DTD_DIFFERENT_PREFIX,

	push	DWORD PTR [ebx+8]
	mov	esi, DWORD PTR _elem$[ebp]
	push	DWORD PTR [ebx+56]
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0DK@IGLOKJLK@Element?5?$CFs?5required?5attribute?5?$CF@
	push	506					; 000001faH

; 6279 : 		   "Element %s required attribute %s:%s has different prefix\n",
; 6280 : 		       elem->name, attr->prefix, attr->name);
; 6281 : 	    }

	jmp	SHORT $LN248@xmlValidat
$LN83@xmlValidat:

; 6282 : 	} else if (attr->def == XML_ATTRIBUTE_FIXED) {

	cmp	eax, 4
	jne	SHORT $found$258

; 6283 : 	    /*
; 6284 : 	     * Special tests checking #FIXED namespace declarations
; 6285 : 	     * have the right value since this is not done as an
; 6286 : 	     * attribute checking
; 6287 : 	     */
; 6288 : 	    if ((attr->prefix == NULL) &&

	cmp	DWORD PTR [ebx+56], 0
	jne	SHORT $LN221@xmlValidat
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN221@xmlValidat

; 6289 : 		(xmlStrEqual(attr->name, BAD_CAST "xmlns"))) {
; 6290 : 		xmlNsPtr ns;
; 6291 : 
; 6292 : 		ns = elem->nsDef;

	mov	esi, DWORD PTR _elem$[ebp]
	mov	eax, DWORD PTR [esi+48]

; 6293 : 		while (ns != NULL) {

	test	eax, eax
	je	SHORT $LN236@xmlValidat
	npad	5
$LL24@xmlValidat:

; 6294 : 		    if (ns->prefix == NULL) {

	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN171@xmlValidat

; 6303 : 		    }
; 6304 : 		    ns = ns->next;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL24@xmlValidat

; 6311 : 		    if (xmlStrEqual(attr->name, ns->prefix)) {

	jmp	SHORT $LN236@xmlValidat
$LN171@xmlValidat:

; 6295 : 			if (!xmlStrEqual(attr->defaultValue, ns->href)) {

	push	DWORD PTR [eax+8]
	push	DWORD PTR [ebx+48]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN236@xmlValidat

; 6296 : 			    xmlErrValidNode(ctxt, elem,

	push	eax
	push	eax
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0EI@BIBADMEK@Element?5?$CFs?5namespace?5name?5for?5d@
	push	507					; 000001fbH
	push	esi
	push	edi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 6297 : 			           XML_DTD_ELEM_DEFAULT_NAMESPACE,
; 6298 :    "Element %s namespace name for default namespace does not match the DTD\n",
; 6299 : 				   elem->name, NULL, NULL);
; 6300 : 			    ret = 0;

	xor	ecx, ecx
	mov	DWORD PTR _ret$1$[ebp], ecx

; 6301 : 			}
; 6302 : 			goto found;

	jmp	$found$258
$LN221@xmlValidat:

; 6305 : 		}
; 6306 : 	    } else if (xmlStrEqual(attr->prefix, BAD_CAST "xmlns")) {

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR [ebx+56]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN236@xmlValidat

; 6307 : 		xmlNsPtr ns;
; 6308 : 
; 6309 : 		ns = elem->nsDef;

	mov	eax, DWORD PTR _elem$[ebp]
	mov	esi, DWORD PTR [eax+48]

; 6310 : 		while (ns != NULL) {

	test	esi, esi
	je	$LN236@xmlValidat
	npad	3
$LL26@xmlValidat:

; 6311 : 		    if (xmlStrEqual(attr->name, ns->prefix)) {

	push	DWORD PTR [esi+12]
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN172@xmlValidat

; 6317 : 			}
; 6318 : 			goto found;
; 6319 : 		    }
; 6320 : 		    ns = ns->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL26@xmlValidat

; 6311 : 		    if (xmlStrEqual(attr->name, ns->prefix)) {

	jmp	$LN236@xmlValidat
$LN172@xmlValidat:

; 6312 : 			if (!xmlStrEqual(attr->defaultValue, ns->href)) {

	push	DWORD PTR [esi+8]
	push	DWORD PTR [ebx+48]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN236@xmlValidat

; 6313 : 			    xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,

	push	eax
	push	DWORD PTR [esi+12]
	mov	eax, DWORD PTR _elem$[ebp]
	push	DWORD PTR [eax+8]
	push	OFFSET ??_C@_0DJ@DDNBGMLL@Element?5?$CFs?5namespace?5name?5for?5?$CF@
	push	508					; 000001fcH
	push	eax
	push	edi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 6314 : 		   "Element %s namespace name for %s does not match the DTD\n",
; 6315 : 				   elem->name, ns->prefix, NULL);
; 6316 : 			    ret = 0;

	xor	ecx, ecx
	mov	DWORD PTR _ret$1$[ebp], ecx
	jmp	$found$258
$LN44@xmlValidat:

; 6045 :         case XML_ELEMENT_NODE:
; 6046 : 	    break;
; 6047 : 	default:
; 6048 : 	    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BG@CJHPKHPI@unknown?5element?5type?6@
$LN249@xmlValidat:

; 6326 :     }
; 6327 :     return(ret);
; 6328 : }

	push	1
	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
$LN167@xmlValidat:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN253@xmlValidat:
	DD	$LN43@xmlValidat
	DD	$LN32@xmlValidat
	DD	$LN33@xmlValidat
	DD	$LN38@xmlValidat
	DD	$LN39@xmlValidat
	DD	$LN41@xmlValidat
	DD	$LN40@xmlValidat
	DD	$LN42@xmlValidat
	DD	$LN44@xmlValidat
$LN223@xmlValidat:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	3
	DB	4
	DB	3
	DB	3
	DB	5
	DB	5
	DB	5
	DB	6
	DB	7
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	3
	DB	3
$LN254@xmlValidat:
	DD	$LN47@xmlValidat
	DD	$LN48@xmlValidat
	DD	$LN241@xmlValidat
	DD	$LN51@xmlValidat
	DD	$LN76@xmlValidat
$LN255@xmlValidat:
	DD	$LN127@xmlValidat
	DD	$LN127@xmlValidat
	DD	$LN126@xmlValidat
	DD	$LN129@xmlValidat
	DD	$LN127@xmlValidat
	DD	$LN127@xmlValidat
_xmlValidateOneElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateElement
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_value$1$ = 16						; size = 4
_elem$ = 16						; size = 4
_xmlValidateElement PROC				; COMDAT

; 6409 : xmlValidateElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr elem) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _elem$[ebp]
	test	ebx, ebx
	je	$LN32@xmlValidat

; 6410 :     xmlNodePtr child;
; 6411 :     xmlAttrPtr attr;
; 6412 :     xmlNsPtr ns;
; 6413 :     const xmlChar *value;
; 6414 :     int ret = 1;
; 6415 : 
; 6416 :     if (elem == NULL) return(0);
; 6417 : 
; 6418 :     /*
; 6419 :      * XInclude elements were added after parsing in the infoset,
; 6420 :      * they don't really mean anything validation wise.
; 6421 :      */
; 6422 :     if ((elem->type == XML_XINCLUDE_START) ||
; 6423 : 	(elem->type == XML_XINCLUDE_END) ||

	mov	ecx, DWORD PTR [ebx+4]
	cmp	ecx, 19					; 00000013H
	je	$LN10@xmlValidat
	cmp	ecx, 20					; 00000014H
	je	$LN10@xmlValidat
	cmp	ecx, 18					; 00000012H
	je	$LN10@xmlValidat

; 6426 : 
; 6427 :     CHECK_DTD;

	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	je	$LN32@xmlValidat
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN13@xmlValidat
	cmp	DWORD PTR [eax+48], 0
	je	$LN32@xmlValidat
$LN13@xmlValidat:

; 6428 : 
; 6429 :     /*
; 6430 :      * Entities references have to be handled separately
; 6431 :      */
; 6432 :     if (elem->type == XML_ENTITY_REF_NODE) {

	cmp	ecx, 5
	je	$LN10@xmlValidat

; 6433 : 	return(1);
; 6434 :     }
; 6435 : 
; 6436 :     ret &= xmlValidateOneElement(ctxt, doc, elem);

	push	esi
	push	edi
	push	ebx
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlValidateOneElement
	mov	esi, eax
	add	esp, 12					; 0000000cH
	and	esi, 1

; 6437 :     if (elem->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [ebx+4], 1
	jne	SHORT $LN5@xmlValidat

; 6438 : 	attr = elem->properties;

	mov	edi, DWORD PTR [ebx+44]

; 6439 : 	while (attr != NULL) {

	test	edi, edi
	je	SHORT $LN3@xmlValidat
	npad	4
$LL2@xmlValidat:

; 6440 : 	    value = xmlNodeListGetString(doc, attr->children, 0);

	push	0
	push	DWORD PTR [edi+12]
	push	DWORD PTR _doc$[ebp]
	call	_xmlNodeListGetString

; 6441 : 	    ret &= xmlValidateOneAttribute(ctxt, doc, elem, attr, value);

	push	eax
	push	edi
	push	ebx
	push	DWORD PTR _doc$[ebp]
	mov	DWORD PTR _value$1$[ebp], eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlValidateOneAttribute
	and	esi, eax
	add	esp, 32					; 00000020H

; 6442 : 	    if (value != NULL)

	mov	eax, DWORD PTR _value$1$[ebp]
	test	eax, eax
	je	SHORT $LN16@xmlValidat

; 6443 : 		xmlFree((char *)value);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlValidat:

; 6444 : 	    attr= attr->next;

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	SHORT $LL2@xmlValidat
$LN3@xmlValidat:

; 6445 : 	}
; 6446 : 	ns = elem->nsDef;

	mov	edi, DWORD PTR [ebx+48]

; 6447 : 	while (ns != NULL) {

	test	edi, edi
	je	SHORT $LN5@xmlValidat
$LL4@xmlValidat:

; 6448 : 	    if (elem->ns == NULL)

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [ebx+36]
	push	ecx
	push	edi
	test	eax, eax
	jne	SHORT $LN17@xmlValidat

; 6449 : 		ret &= xmlValidateOneNamespace(ctxt, doc, elem, NULL,

	push	eax
	jmp	SHORT $LN33@xmlValidat
$LN17@xmlValidat:

; 6450 : 					       ns, ns->href);
; 6451 : 	    else
; 6452 : 		ret &= xmlValidateOneNamespace(ctxt, doc, elem,

	push	DWORD PTR [eax+12]
$LN33@xmlValidat:

; 6453 : 		                               elem->ns->prefix, ns, ns->href);
; 6454 : 	    ns = ns->next;

	push	ebx
	push	DWORD PTR _doc$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlValidateOneNamespace
	mov	edi, DWORD PTR [edi]
	add	esp, 24					; 00000018H
	and	esi, eax
	test	edi, edi
	jne	SHORT $LL4@xmlValidat
$LN5@xmlValidat:

; 6455 : 	}
; 6456 :     }
; 6457 :     child = elem->children;

	mov	edi, DWORD PTR [ebx+12]

; 6458 :     while (child != NULL) {

	test	edi, edi
	je	SHORT $LN7@xmlValidat
$LL6@xmlValidat:

; 6459 :         ret &= xmlValidateElement(ctxt, doc, child);

	push	edi
	push	DWORD PTR _doc$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlValidateElement

; 6460 :         child = child->next;

	mov	edi, DWORD PTR [edi+24]
	add	esp, 12					; 0000000cH
	and	esi, eax
	test	edi, edi
	jne	SHORT $LL6@xmlValidat
$LN7@xmlValidat:

; 6461 :     }
; 6462 : 
; 6463 :     return(ret);

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 6464 : }

	pop	ebp
	ret	0
$LN10@xmlValidat:

; 6424 : 	(elem->type == XML_NAMESPACE_DECL))
; 6425 : 	return(1);

	mov	eax, 1
	pop	ebx

; 6464 : }

	pop	ebp
	ret	0
$LN32@xmlValidat:

; 6426 : 
; 6427 :     CHECK_DTD;

	xor	eax, eax
	pop	ebx

; 6464 : }

	pop	ebp
	ret	0
_xmlValidateElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateDocument
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlValidateDocument PROC				; COMDAT

; 6844 : xmlValidateDocument(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _doc$[ebp]
	test	esi, esi
	je	SHORT $LN31@xmlValidat

; 6845 :     int ret;
; 6846 :     xmlNodePtr root;
; 6847 : 
; 6848 :     if (doc == NULL)
; 6849 :         return(0);
; 6850 :     if ((doc->intSubset == NULL) && (doc->extSubset == NULL)) {

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	jne	SHORT $LN30@xmlValidat
	cmp	DWORD PTR [esi+48], eax
	jne	$LN10@xmlValidat

; 104  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	xor	edx, edx
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN21@xmlValidat

; 105  :         channel = ctxt->error;
; 106  :         data = ctxt->userData;
; 107  : 	/* Use the special values to detect if it is part of a parsing
; 108  : 	   context */
; 109  : 	if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||

	mov	edi, DWORD PTR [eax+28]
	mov	esi, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	cmp	edi, -1412623820			; abcd1234H
	je	SHORT $LN20@xmlValidat
	cmp	edi, -1412623819			; abcd1235H
	jne	SHORT $LN21@xmlValidat
$LN20@xmlValidat:

; 110  : 	    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {
; 111  : 	    long delta = (char *) ctxt - (char *) ctxt->userData;

	sub	eax, ecx

; 112  : 	    if ((delta > 0) && (delta < 250))

	dec	eax
	cmp	eax, 248				; 000000f8H
	cmovbe	edx, ecx
$LN21@xmlValidat:

; 113  : 		pctxt = ctxt->userData;
; 114  : 	}
; 115  :     }
; 116  :     if (extra)
; 117  :         __xmlRaiseError(NULL, channel, data,
; 118  :                         pctxt, NULL, XML_FROM_VALID, error,
; 119  :                         XML_ERR_ERROR, NULL, 0, extra, NULL, NULL, 0, 0,
; 120  :                         msg, extra);
; 121  :     else
; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0P@GBEHLCJD@no?5DTD?5found?$CB?6@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	522					; 0000020aH
	push	23					; 00000017H
	push	0
	push	edx
	push	ecx
	push	esi
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN31@xmlValidat:
	pop	edi

; 6901 :     return(ret);
; 6902 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN30@xmlValidat:

; 6851 :         xmlErrValid(ctxt, XML_DTD_NO_DTD,
; 6852 : 	            "no DTD found!\n", NULL);
; 6853 : 	return(0);
; 6854 :     }
; 6855 :     if ((doc->intSubset != NULL) && ((doc->intSubset->SystemID != NULL) ||
; 6856 : 	(doc->intSubset->ExternalID != NULL)) && (doc->extSubset == NULL)) {

	mov	ecx, DWORD PTR [eax+56]
	test	ecx, ecx
	jne	SHORT $LN5@xmlValidat
	cmp	DWORD PTR [eax+52], ecx
	je	SHORT $LN10@xmlValidat
$LN5@xmlValidat:
	cmp	DWORD PTR [esi+48], 0
	jne	SHORT $LN10@xmlValidat

; 6857 : 	xmlChar *sysID;
; 6858 : 	if (doc->intSubset->SystemID != NULL) {

	test	ecx, ecx
	je	SHORT $LN6@xmlValidat

; 6859 : 	    sysID = xmlBuildURI(doc->intSubset->SystemID,

	push	DWORD PTR [esi+72]
	push	ecx
	call	_xmlBuildURI
	mov	edi, eax
	add	esp, 8
	mov	eax, DWORD PTR [esi+44]

; 6860 : 			doc->URL);
; 6861 : 	    if (sysID == NULL) {

	test	edi, edi
	jne	SHORT $LN7@xmlValidat

; 6862 : 	        xmlErrValid(ctxt, XML_DTD_LOAD_ERROR,

	push	DWORD PTR [eax+56]
	push	OFFSET ??_C@_0CO@FGGICOAP@Could?5not?5build?5URI?5for?5externa@
$LN32@xmlValidat:

; 6901 :     return(ret);
; 6902 : }

	push	517					; 00000205H
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValid
	add	esp, 16					; 00000010H
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlValidat:

; 6863 : 			"Could not build URI for external subset \"%s\"\n",
; 6864 : 			(const char *) doc->intSubset->SystemID);
; 6865 : 		return 0;
; 6866 : 	    }
; 6867 : 	} else
; 6868 : 	    sysID = NULL;

	xor	edi, edi
$LN7@xmlValidat:

; 6869 :         doc->extSubset = xmlParseDTD(doc->intSubset->ExternalID,

	push	edi
	push	DWORD PTR [eax+52]
	call	_xmlParseDTD
	add	esp, 8
	mov	DWORD PTR [esi+48], eax

; 6870 : 			(const xmlChar *)sysID);
; 6871 : 	if (sysID != NULL)

	test	edi, edi
	je	SHORT $LN9@xmlValidat

; 6872 : 	    xmlFree(sysID);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlValidat:

; 6873 :         if (doc->extSubset == NULL) {

	cmp	DWORD PTR [esi+48], 0
	jne	SHORT $LN10@xmlValidat

; 6874 : 	    if (doc->intSubset->SystemID != NULL) {

	mov	ecx, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [ecx+56]
	test	eax, eax
	jne	SHORT $LN12@xmlValidat

; 6875 : 		xmlErrValid(ctxt, XML_DTD_LOAD_ERROR,
; 6876 : 		       "Could not load the external subset \"%s\"\n",
; 6877 : 		       (const char *) doc->intSubset->SystemID);
; 6878 : 	    } else {
; 6879 : 		xmlErrValid(ctxt, XML_DTD_LOAD_ERROR,

	mov	eax, DWORD PTR [ecx+52]
$LN12@xmlValidat:

; 6880 : 		       "Could not load the external subset \"%s\"\n",
; 6881 : 		       (const char *) doc->intSubset->ExternalID);
; 6882 : 	    }
; 6883 : 	    return(0);

	push	eax
	push	OFFSET ??_C@_0CJ@BNOHLKCI@Could?5not?5load?5the?5external?5sub@
	jmp	SHORT $LN32@xmlValidat
$LN10@xmlValidat:

; 6884 : 	}
; 6885 :     }
; 6886 : 
; 6887 :     if (doc->ids != NULL) {

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN13@xmlValidat

; 2687 :     xmlHashFree(table, xmlFreeIDTableEntry);

	push	OFFSET _xmlFreeIDTableEntry
	push	eax
	call	_xmlHashFree
	add	esp, 8

; 6888 :           xmlFreeIDTable(doc->ids);
; 6889 :           doc->ids = NULL;

	mov	DWORD PTR [esi+64], 0
$LN13@xmlValidat:

; 6890 :     }
; 6891 :     if (doc->refs != NULL) {

	mov	eax, DWORD PTR [esi+68]
	test	eax, eax
	je	SHORT $LN14@xmlValidat

; 3029 :     xmlHashFree(table, xmlFreeRefTableEntry);

	push	OFFSET _xmlFreeRefTableEntry
	push	eax
	call	_xmlHashFree
	add	esp, 8

; 6892 :           xmlFreeRefTable(doc->refs);
; 6893 :           doc->refs = NULL;

	mov	DWORD PTR [esi+68], 0
$LN14@xmlValidat:

; 6894 :     }
; 6895 :     ret = xmlValidateDtdFinal(ctxt, doc);

	mov	edi, DWORD PTR _ctxt$[ebp]
	push	esi
	push	edi
	call	_xmlValidateDtdFinal

; 6896 :     if (!xmlValidateRoot(ctxt, doc)) return(0);

	push	esi
	push	edi
	mov	ebx, eax
	call	_xmlValidateRoot
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN31@xmlValidat

; 6897 : 
; 6898 :     root = xmlDocGetRootElement(doc);

	push	esi
	call	_xmlDocGetRootElement

; 6899 :     ret &= xmlValidateElement(ctxt, doc, root);

	push	eax
	push	esi
	push	edi
	call	_xmlValidateElement

; 6900 :     ret &= xmlValidateDocumentFinal(ctxt, doc);

	push	esi
	push	edi
	and	ebx, eax
	call	_xmlValidateDocumentFinal
	add	esp, 24					; 00000018H
	and	eax, ebx
	pop	edi

; 6901 :     return(ret);
; 6902 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlValidateDocument ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateDtdFinal
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlValidateDtdFinal PROC				; COMDAT

; 6798 : xmlValidateDtdFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	je	$LN3@xmlValidat

; 6799 :     xmlDtdPtr dtd;
; 6800 :     xmlAttributeTablePtr table;
; 6801 :     xmlEntitiesTablePtr entities;
; 6802 : 
; 6803 :     if ((doc == NULL) || (ctxt == NULL)) return(0);

	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN3@xmlValidat

; 6804 :     if ((doc->intSubset == NULL) && (doc->extSubset == NULL))

	cmp	DWORD PTR [edi+44], 0
	jne	SHORT $LN11@xmlValidat
	cmp	DWORD PTR [edi+48], 0
	je	SHORT $LN3@xmlValidat
$LN11@xmlValidat:
	push	ebx

; 6805 : 	return(0);
; 6806 :     ctxt->doc = doc;

	mov	DWORD PTR [esi+32], edi

; 6807 :     ctxt->valid = 1;

	mov	DWORD PTR [esi+36], 1

; 6808 :     dtd = doc->intSubset;

	mov	ebx, DWORD PTR [edi+44]

; 6809 :     if ((dtd != NULL) && (dtd->attributes != NULL)) {

	test	ebx, ebx
	je	SHORT $LN6@xmlValidat
	mov	eax, DWORD PTR [ebx+44]
	test	eax, eax
	je	SHORT $LN5@xmlValidat

; 6810 : 	table = (xmlAttributeTablePtr) dtd->attributes;
; 6811 : 	xmlHashScan(table, xmlValidateAttributeCallback, ctxt);

	push	esi
	push	OFFSET _xmlValidateAttributeCallback
	push	eax
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN5@xmlValidat:

; 6812 :     }
; 6813 :     if ((dtd != NULL) && (dtd->entities != NULL)) {

	mov	eax, DWORD PTR [ebx+48]
	test	eax, eax
	je	SHORT $LN6@xmlValidat

; 6814 : 	entities = (xmlEntitiesTablePtr) dtd->entities;
; 6815 : 	xmlHashScan(entities, xmlValidateNotationCallback, ctxt);

	push	esi
	push	OFFSET _xmlValidateNotationCallback
	push	eax
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN6@xmlValidat:

; 6816 :     }
; 6817 :     dtd = doc->extSubset;

	mov	edi, DWORD PTR [edi+48]

; 6818 :     if ((dtd != NULL) && (dtd->attributes != NULL)) {

	pop	ebx
	test	edi, edi
	je	SHORT $LN8@xmlValidat
	mov	eax, DWORD PTR [edi+44]
	test	eax, eax
	je	SHORT $LN7@xmlValidat

; 6819 : 	table = (xmlAttributeTablePtr) dtd->attributes;
; 6820 : 	xmlHashScan(table, xmlValidateAttributeCallback, ctxt);

	push	esi
	push	OFFSET _xmlValidateAttributeCallback
	push	eax
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN7@xmlValidat:

; 6821 :     }
; 6822 :     if ((dtd != NULL) && (dtd->entities != NULL)) {

	mov	eax, DWORD PTR [edi+48]
	test	eax, eax
	je	SHORT $LN8@xmlValidat

; 6823 : 	entities = (xmlEntitiesTablePtr) dtd->entities;
; 6824 : 	xmlHashScan(entities, xmlValidateNotationCallback, ctxt);

	push	esi
	push	OFFSET _xmlValidateNotationCallback
	push	eax
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN8@xmlValidat:

; 6825 :     }
; 6826 :     return(ctxt->valid);

	mov	eax, DWORD PTR [esi+36]
	pop	edi

; 6827 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlValidat:
	pop	edi

; 6799 :     xmlDtdPtr dtd;
; 6800 :     xmlAttributeTablePtr table;
; 6801 :     xmlEntitiesTablePtr entities;
; 6802 : 
; 6803 :     if ((doc == NULL) || (ctxt == NULL)) return(0);

	xor	eax, eax

; 6827 : }

	pop	esi
	pop	ebp
	ret	0
_xmlValidateDtdFinal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateDtd
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_oldInt$1$ = 16						; size = 4
_dtd$ = 16						; size = 4
_xmlValidateDtd PROC					; COMDAT

; 6654 : xmlValidateDtd(xmlValidCtxtPtr ctxt, xmlDocPtr doc, xmlDtdPtr dtd) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _dtd$[ebp]
	test	eax, eax
	je	$LN12@xmlValidat

; 6655 :     int ret;
; 6656 :     xmlDtdPtr oldExt, oldInt;
; 6657 :     xmlNodePtr root;
; 6658 : 
; 6659 :     if (dtd == NULL) return(0);
; 6660 :     if (doc == NULL) return(0);

	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	je	$LN12@xmlValidat

; 6661 :     oldExt = doc->extSubset;

	push	ebx
	mov	ebx, DWORD PTR [edi+48]
	push	esi

; 6662 :     oldInt = doc->intSubset;

	mov	esi, DWORD PTR [edi+44]

; 6663 :     doc->extSubset = dtd;
; 6664 :     doc->intSubset = NULL;
; 6665 :     ret = xmlValidateRoot(ctxt, doc);

	push	edi
	push	DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _oldInt$1$[ebp], esi
	mov	DWORD PTR [edi+48], eax
	mov	DWORD PTR [edi+44], 0
	call	_xmlValidateRoot
	add	esp, 8

; 6666 :     if (ret == 0) {

	test	eax, eax
	jne	SHORT $LN4@xmlValidat

; 6667 : 	doc->extSubset = oldExt;
; 6668 : 	doc->intSubset = oldInt;

	mov	DWORD PTR [edi+44], esi
	pop	esi
	mov	DWORD PTR [edi+48], ebx
	pop	ebx
	pop	edi

; 6685 : }

	pop	ebp
	ret	0
$LN4@xmlValidat:

; 6669 : 	return(ret);
; 6670 :     }
; 6671 :     if (doc->ids != NULL) {

	mov	eax, DWORD PTR [edi+64]
	test	eax, eax
	je	SHORT $LN5@xmlValidat

; 2687 :     xmlHashFree(table, xmlFreeIDTableEntry);

	push	OFFSET _xmlFreeIDTableEntry
	push	eax
	call	_xmlHashFree
	add	esp, 8

; 6672 :           xmlFreeIDTable(doc->ids);
; 6673 :           doc->ids = NULL;

	mov	DWORD PTR [edi+64], 0
$LN5@xmlValidat:

; 6674 :     }
; 6675 :     if (doc->refs != NULL) {

	mov	eax, DWORD PTR [edi+68]
	test	eax, eax
	je	SHORT $LN6@xmlValidat

; 3029 :     xmlHashFree(table, xmlFreeRefTableEntry);

	push	OFFSET _xmlFreeRefTableEntry
	push	eax
	call	_xmlHashFree
	add	esp, 8

; 6676 :           xmlFreeRefTable(doc->refs);
; 6677 :           doc->refs = NULL;

	mov	DWORD PTR [edi+68], 0
$LN6@xmlValidat:

; 6678 :     }
; 6679 :     root = xmlDocGetRootElement(doc);

	push	edi
	call	_xmlDocGetRootElement

; 6680 :     ret = xmlValidateElement(ctxt, doc, root);

	push	eax
	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlValidateElement

; 6681 :     ret &= xmlValidateDocumentFinal(ctxt, doc);

	push	edi
	push	DWORD PTR _ctxt$[ebp]
	mov	esi, eax
	call	_xmlValidateDocumentFinal
	add	esp, 24					; 00000018H

; 6682 :     doc->extSubset = oldExt;

	mov	DWORD PTR [edi+48], ebx
	and	esi, eax

; 6683 :     doc->intSubset = oldInt;

	mov	eax, DWORD PTR _oldInt$1$[ebp]
	mov	DWORD PTR [edi+44], eax

; 6684 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 6685 : }

	pop	ebp
	ret	0
$LN12@xmlValidat:

; 6655 :     int ret;
; 6656 :     xmlDtdPtr oldExt, oldInt;
; 6657 :     xmlNodePtr root;
; 6658 : 
; 6659 :     if (dtd == NULL) return(0);
; 6660 :     if (doc == NULL) return(0);

	xor	eax, eax
	pop	edi

; 6685 : }

	pop	ebp
	ret	0
_xmlValidateDtd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateNotationDecl
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_nota$ = 16						; size = 4
_xmlValidateNotationDecl PROC				; COMDAT
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, 1
	ret	0
_xmlValidateNotationDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateAttributeValue
_TEXT	SEGMENT
_type$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlValidateAttributeValue PROC				; COMDAT

; 3836 : xmlValidateAttributeValue(xmlAttributeType type, const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _type$[ebp]
	push	0
	call	_xmlValidateAttributeValueInternal
	add	esp, 12					; 0000000cH

; 3837 :     return(xmlValidateAttributeValueInternal(NULL, type, value));
; 3838 : }

	pop	ebp
	ret	0
_xmlValidateAttributeValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateAttributeDecl
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nbId$1 = 12						; size = 4
_doc$ = 12						; size = 4
_attr$ = 16						; size = 4
_xmlValidateAttributeDecl PROC				; COMDAT

; 4149 :                          xmlAttributePtr attr) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	mov	ebx, 1
	test	edi, edi
	je	$LN35@xmlValidat

; 4150 :     int ret = 1;
; 4151 :     int val;
; 4152 :     CHECK_DTD;

	cmp	DWORD PTR [edi+44], 0
	jne	SHORT $LN34@xmlValidat
	cmp	DWORD PTR [edi+48], 0
	je	$LN35@xmlValidat
$LN34@xmlValidat:
	push	esi

; 4153 :     if(attr == NULL) return(1);

	mov	esi, DWORD PTR _attr$[ebp]
	test	esi, esi
	je	$LN24@xmlValidat

; 4154 : 
; 4155 :     /* Attribute Default Legal */
; 4156 :     /* Enumeration */
; 4157 :     if (attr->defaultValue != NULL) {

	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN8@xmlValidat

; 4158 : 	val = xmlValidateAttributeValueInternal(doc, attr->atype,

	push	eax
	push	DWORD PTR [esi+40]
	push	edi
	call	_xmlValidateAttributeValueInternal
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 4159 : 	                                        attr->defaultValue);
; 4160 : 	if (val == 0) {

	test	ebx, ebx
	jne	SHORT $LN9@xmlValidat

; 4161 : 	    xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_DEFAULT,

	push	eax
	push	DWORD PTR [esi+60]
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0DN@MJLCEKEK@Syntax?5of?5default?5value?5for?5att@
	push	500					; 000001f4H
	push	esi
	push	eax
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
$LN9@xmlValidat:

; 4162 : 	       "Syntax of default value for attribute %s of %s is not valid\n",
; 4163 : 	           attr->name, attr->elem, NULL);
; 4164 : 	}
; 4165 :         ret &= val;

	and	ebx, 1
$LN8@xmlValidat:

; 4166 :     }
; 4167 : 
; 4168 :     /* ID Attribute Default */
; 4169 :     if ((attr->atype == XML_ATTRIBUTE_ID)&&
; 4170 :         (attr->def != XML_ATTRIBUTE_IMPLIED) &&

	mov	eax, DWORD PTR [esi+40]
	cmp	eax, 2
	jne	$LN21@xmlValidat
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 3
	je	SHORT $LN33@xmlValidat
	cmp	eax, 2
	je	SHORT $LN33@xmlValidat

; 4171 : 	(attr->def != XML_ATTRIBUTE_REQUIRED)) {
; 4172 : 	xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_FIXED,

	push	0
	push	DWORD PTR [esi+60]
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0EC@DNHDHDCI@ID?5attribute?5?$CFs?5of?5?$CFs?5is?5not?5va@
	push	512					; 00000200H
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode

; 4173 :           "ID attribute %s of %s is not valid must be #IMPLIED or #REQUIRED\n",
; 4174 : 	       attr->name, attr->elem, NULL);
; 4175 : 	ret = 0;

	mov	eax, DWORD PTR [esi+40]
	add	esp, 28					; 0000001cH
	xor	ebx, ebx

; 4176 :     }
; 4177 : 
; 4178 :     /* One ID per Element Type */
; 4179 :     if (attr->atype == XML_ATTRIBUTE_ID) {

	cmp	eax, 2
	jne	$LN21@xmlValidat
$LN33@xmlValidat:

; 4180 :         int nbId;
; 4181 : 
; 4182 : 	/* the trick is that we parse DtD as their own internal subset */
; 4183 :         xmlElementPtr elem = xmlGetDtdElementDesc(doc->intSubset,

	push	DWORD PTR [esi+60]
	push	DWORD PTR [edi+44]
	call	_xmlGetDtdElementDesc
	add	esp, 8

; 4184 : 	                                          attr->elem);
; 4185 : 	if (elem != NULL) {

	test	eax, eax
	je	SHORT $LN12@xmlValidat

; 4186 : 	    nbId = xmlScanIDAttributeDecl(NULL, elem, 0);

	push	0
	push	eax
	push	0
	call	_xmlScanIDAttributeDecl
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _nbId$1[ebp], eax

; 4187 : 	} else {

	jmp	SHORT $LN14@xmlValidat
$LN12@xmlValidat:

; 4188 : 	    xmlAttributeTablePtr table;
; 4189 : 
; 4190 : 	    /*
; 4191 : 	     * The attribute may be declared in the internal subset and the
; 4192 : 	     * element in the external subset.
; 4193 : 	     */
; 4194 : 	    nbId = 0;
; 4195 : 	    if (doc->intSubset != NULL) {

	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR _nbId$1[ebp], 0
	test	eax, eax
	je	SHORT $LN15@xmlValidat

; 4196 : 		table = (xmlAttributeTablePtr) doc->intSubset->attributes;
; 4197 : 		xmlHashScan3(table, NULL, NULL, attr->elem,

	lea	ecx, DWORD PTR _nbId$1[ebp]
	push	ecx
	push	OFFSET _xmlValidateAttributeIdCallback
	push	DWORD PTR [esi+60]
	push	0
	push	0
	push	DWORD PTR [eax+44]
	call	_xmlHashScan3
	mov	eax, DWORD PTR _nbId$1[ebp]
	add	esp, 24					; 00000018H
$LN14@xmlValidat:

; 4198 : 			     xmlValidateAttributeIdCallback, &nbId);
; 4199 : 	    }
; 4200 : 	}
; 4201 : 	if (nbId > 1) {

	cmp	eax, 1
	jle	SHORT $LN15@xmlValidat

; 4202 : 
; 4203 : 	    xmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,

	push	DWORD PTR [esi+8]
	push	eax
	push	DWORD PTR [esi+60]
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	OFFSET ??_C@_0EE@MLJMMKCM@Element?5?$CFs?5has?5?$CFd?5ID?5attribute?5@
	push	514					; 00000202H
	push	esi
	push	eax
	call	_xmlErrValidNodeNr
	jmp	SHORT $LN38@xmlValidat
$LN15@xmlValidat:

; 4204 :        "Element %s has %d ID attribute defined in the internal subset : %s\n",
; 4205 : 		   attr->elem, nbId, attr->name);
; 4206 : 	} else if (doc->extSubset != NULL) {

	mov	eax, DWORD PTR [edi+48]
	test	eax, eax
	je	SHORT $LN21@xmlValidat

; 4207 : 	    int extId = 0;
; 4208 : 	    elem = xmlGetDtdElementDesc(doc->extSubset, attr->elem);

	push	DWORD PTR [esi+60]
	xor	edi, edi
	push	eax
	call	_xmlGetDtdElementDesc
	add	esp, 8

; 4209 : 	    if (elem != NULL) {

	test	eax, eax
	je	SHORT $LN19@xmlValidat

; 4210 : 		extId = xmlScanIDAttributeDecl(NULL, elem, 0);

	push	edi
	push	eax
	push	edi
	call	_xmlScanIDAttributeDecl
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 4211 : 	    }
; 4212 : 	    if (extId > 1) {

	cmp	edi, 1
	jle	SHORT $LN19@xmlValidat

; 4213 : 		xmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,

	push	DWORD PTR [esi+8]
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	edi
	push	DWORD PTR [esi+60]
	push	OFFSET ??_C@_0EE@JDKHGIAG@Element?5?$CFs?5has?5?$CFd?5ID?5attribute?5@
	push	514					; 00000202H
	push	esi
	push	eax
	call	_xmlErrValidNodeNr
	jmp	SHORT $LN38@xmlValidat
$LN19@xmlValidat:

; 4214 :        "Element %s has %d ID attribute defined in the external subset : %s\n",
; 4215 : 		       attr->elem, extId, attr->name);
; 4216 : 	    } else if (extId + nbId > 1) {

	mov	eax, DWORD PTR _nbId$1[ebp]
	add	eax, edi
	cmp	eax, 1
	jle	SHORT $LN21@xmlValidat

; 4217 : 		xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	0
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+60]
	push	OFFSET ??_C@_0EP@CFLHEJLO@Element?5?$CFs?5has?5ID?5attributes?5de@
	push	514					; 00000202H
	push	esi
	push	eax
	call	_xmlErrValidNode
$LN38@xmlValidat:

; 4218 : "Element %s has ID attributes defined in the internal and external subset : %s\n",
; 4219 : 		       attr->elem, attr->name, NULL);
; 4220 : 	    }
; 4221 : 	}
; 4222 :     }
; 4223 : 
; 4224 :     /* Validity Constraint: Enumeration */
; 4225 :     if ((attr->defaultValue != NULL) && (attr->tree != NULL)) {

	add	esp, 28					; 0000001cH
$LN21@xmlValidat:
	cmp	DWORD PTR [esi+48], 0
	je	SHORT $LN24@xmlValidat
	mov	edi, DWORD PTR [esi+52]
	test	edi, edi
	je	SHORT $LN24@xmlValidat
	npad	5
$LL2@xmlValidat:

; 4226 :         xmlEnumerationPtr tree = attr->tree;
; 4227 : 	while (tree != NULL) {
; 4228 : 	    if (xmlStrEqual(tree->name, attr->defaultValue)) break;

	push	DWORD PTR [esi+48]
	push	DWORD PTR [edi+4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN24@xmlValidat

; 4229 : 	    tree = tree->next;

	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	SHORT $LL2@xmlValidat

; 4230 : 	}
; 4231 : 	if (tree == NULL) {
; 4232 : 	    xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_VALUE,

	push	DWORD PTR [esi+60]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+48]
	push	OFFSET ??_C@_0EL@MPNELAFE@Default?5value?5?$CC?$CFs?$CC?5for?5attribut@
	push	502					; 000001f6H
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 4233 : "Default value \"%s\" for attribute %s of %s is not among the enumerated set\n",
; 4234 : 		   attr->defaultValue, attr->name, attr->elem);
; 4235 : 	    ret = 0;

	xor	ebx, ebx
$LN24@xmlValidat:

; 4236 : 	}
; 4237 :     }
; 4238 : 
; 4239 :     return(ret);

	pop	esi
	pop	edi
	mov	eax, ebx

; 4240 : }

	pop	ebx
	pop	ebp
	ret	0
$LN35@xmlValidat:
	pop	edi

; 4150 :     int ret = 1;
; 4151 :     int val;
; 4152 :     CHECK_DTD;

	xor	eax, eax

; 4240 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlValidateAttributeDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidCtxtNormalizeAttributeValue
_TEXT	SEGMENT
_fn$1 = -56						; size = 50
_extsubset$1$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_ret$1$ = 12						; size = 4
_doc$ = 12						; size = 4
_elem$ = 16						; size = 4
_name$ = 20						; size = 4
_value$ = 24						; size = 4
_xmlValidCtxtNormalizeAttributeValue PROC		; COMDAT

; 3987 : 	     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	xor	esi, esi
	mov	DWORD PTR _extsubset$1$[ebp], esi
	test	edi, edi
	je	$LN42@xmlValidCt

; 3988 :     xmlChar *ret, *dst;
; 3989 :     const xmlChar *src;
; 3990 :     xmlAttributePtr attrDecl = NULL;
; 3991 :     int extsubset = 0;
; 3992 : 
; 3993 :     if (doc == NULL) return(NULL);
; 3994 :     if (elem == NULL) return(NULL);

	mov	ebx, DWORD PTR _elem$[ebp]
	test	ebx, ebx
	je	$LN42@xmlValidCt

; 3995 :     if (name == NULL) return(NULL);

	mov	ecx, DWORD PTR _name$[ebp]
	test	ecx, ecx
	je	$LN42@xmlValidCt

; 3996 :     if (value == NULL) return(NULL);

	cmp	DWORD PTR _value$[ebp], esi
	je	$LN42@xmlValidCt

; 3997 : 
; 3998 :     if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	je	$LN39@xmlValidCt
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN39@xmlValidCt

; 3999 : 	xmlChar fn[50];
; 4000 : 	xmlChar *fullname;
; 4001 : 
; 4002 : 	fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);

	push	50					; 00000032H
	lea	ecx, DWORD PTR _fn$1[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [ebx+8]
	call	_xmlBuildQName
	mov	edi, eax
	add	esp, 16					; 00000010H

; 4003 : 	if (fullname == NULL)

	test	edi, edi
	je	$LN42@xmlValidCt

; 4004 : 	    return(NULL);
; 4005 : 	attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name);

	push	DWORD PTR _name$[ebp]
	mov	eax, DWORD PTR _doc$[ebp]
	push	edi
	push	DWORD PTR [eax+44]
	call	_xmlGetDtdAttrDesc
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 4006 : 	if ((attrDecl == NULL) && (doc->extSubset != NULL)) {

	test	esi, esi
	jne	SHORT $LN15@xmlValidCt
	mov	eax, DWORD PTR _doc$[ebp]
	mov	eax, DWORD PTR [eax+48]
	test	eax, eax
	je	SHORT $LN15@xmlValidCt

; 4007 : 	    attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name);

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	edi
	push	eax
	call	_xmlGetDtdAttrDesc
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 4008 : 	    if (attrDecl != NULL)

	xor	eax, eax
	mov	ecx, 1
	test	esi, esi
	cmovne	eax, ecx
	mov	DWORD PTR _extsubset$1$[ebp], eax
$LN15@xmlValidCt:

; 4009 : 		extsubset = 1;
; 4010 : 	}
; 4011 : 	if ((fullname != fn) && (fullname != elem->name))

	lea	eax, DWORD PTR _fn$1[ebp]
	cmp	edi, eax
	je	SHORT $LN16@xmlValidCt
	cmp	edi, DWORD PTR [ebx+8]
	je	SHORT $LN16@xmlValidCt

; 4012 : 	    xmlFree(fullname);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlValidCt:

; 4013 :     }
; 4014 :     if ((attrDecl == NULL) && (doc->intSubset != NULL))

	mov	edi, DWORD PTR _doc$[ebp]
	test	esi, esi
	jne	SHORT $LN20@xmlValidCt
	mov	ecx, DWORD PTR _name$[ebp]
$LN39@xmlValidCt:
	mov	eax, DWORD PTR [edi+44]
	test	eax, eax
	je	SHORT $LN40@xmlValidCt

; 4015 : 	attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);

	push	ecx
	push	DWORD PTR [ebx+8]
	push	eax
	call	_xmlGetDtdAttrDesc
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 4016 :     if ((attrDecl == NULL) && (doc->extSubset != NULL)) {

	test	esi, esi
	jne	SHORT $LN20@xmlValidCt
$LN40@xmlValidCt:
	mov	eax, DWORD PTR [edi+48]
	test	eax, eax
	je	SHORT $LN19@xmlValidCt

; 4017 : 	attrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	DWORD PTR [ebx+8]
	push	eax
	call	_xmlGetDtdAttrDesc
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 4018 : 	if (attrDecl != NULL)

	test	esi, esi
	je	$LN42@xmlValidCt

; 4019 : 	    extsubset = 1;

	mov	DWORD PTR _extsubset$1$[ebp], 1
$LN19@xmlValidCt:

; 4020 :     }
; 4021 : 
; 4022 :     if (attrDecl == NULL)

	test	esi, esi
	je	$LN42@xmlValidCt
$LN20@xmlValidCt:

; 4023 : 	return(NULL);
; 4024 :     if (attrDecl->atype == XML_ATTRIBUTE_CDATA)

	cmp	DWORD PTR [esi+40], 1
	je	$LN42@xmlValidCt

; 4025 : 	return(NULL);
; 4026 : 
; 4027 :     ret = xmlStrdup(value);

	push	DWORD PTR _value$[ebp]
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _ret$1$[ebp], eax

; 4028 :     if (ret == NULL)

	test	eax, eax
	je	$LN42@xmlValidCt

; 4029 : 	return(NULL);
; 4030 :     src = value;

	mov	edx, DWORD PTR _value$[ebp]

; 4031 :     dst = ret;

	mov	esi, eax
	mov	ecx, edx

; 4032 :     while (*src == 0x20) src++;

	mov	dl, BYTE PTR [edx]
	cmp	dl, 32					; 00000020H
	jne	SHORT $LN29@xmlValidCt
	npad	7
$LL2@xmlValidCt:
	mov	dl, BYTE PTR [ecx+1]
	inc	ecx
	cmp	dl, 32					; 00000020H
	je	SHORT $LL2@xmlValidCt
$LN29@xmlValidCt:

; 4033 :     while (*src != 0) {

	test	dl, dl
	je	SHORT $LN5@xmlValidCt
	npad	3
$LL4@xmlValidCt:

; 4034 : 	if (*src == 0x20) {

	cmp	dl, 32					; 00000020H
	jne	SHORT $LN23@xmlValidCt
$LL6@xmlValidCt:

; 4035 : 	    while (*src == 0x20) src++;

	mov	al, BYTE PTR [ecx+1]
	mov	edx, ecx
	inc	ecx
	cmp	al, 32					; 00000020H
	je	SHORT $LL6@xmlValidCt

; 4036 : 	    if (*src != 0)

	test	al, al
	je	SHORT $LN24@xmlValidCt

; 4037 : 		*dst++ = 0x20;

	mov	BYTE PTR [esi], 32			; 00000020H

; 4038 : 	} else {

	jmp	SHORT $LN44@xmlValidCt
$LN23@xmlValidCt:

; 4039 : 	    *dst++ = *src++;

	mov	BYTE PTR [esi], dl
	mov	edx, ecx
$LN44@xmlValidCt:

; 4033 :     while (*src != 0) {

	inc	esi
$LN24@xmlValidCt:
	lea	ecx, DWORD PTR [edx+1]
	mov	dl, BYTE PTR [ecx]
	test	dl, dl
	jne	SHORT $LL4@xmlValidCt
	mov	eax, DWORD PTR _ret$1$[ebp]
$LN5@xmlValidCt:

; 4040 : 	}
; 4041 :     }
; 4042 :     *dst = 0;

	mov	BYTE PTR [esi], 0

; 4043 :     if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {

	cmp	DWORD PTR [edi+40], 0
	je	SHORT $LN26@xmlValidCt
	cmp	DWORD PTR _extsubset$1$[ebp], 1
	jne	SHORT $LN26@xmlValidCt
	push	eax
	push	DWORD PTR _value$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@xmlValidCt

; 4044 : 	xmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,

	mov	esi, DWORD PTR _ctxt$[ebp]
	push	eax
	push	DWORD PTR [ebx+8]
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0FG@CJEJIEOP@standalone?3?5?$CFs?5on?5?$CFs?5value?5had?5@
	push	530					; 00000212H
	push	ebx
	push	esi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 4045 : "standalone: %s on %s value had to be normalized based on external subset declaration\n",
; 4046 : 	       name, elem->name, NULL);
; 4047 : 	ctxt->valid = 0;

	mov	DWORD PTR [esi+36], 0
$LN26@xmlValidCt:

; 4048 :     }
; 4049 :     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 4050 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@xmlValidCt:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidCtxtNormalizeAttributeValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidNormalizeAttributeValue
_TEXT	SEGMENT
_fn$1 = -52						; size = 50
_doc$ = 8						; size = 4
_elem$ = 12						; size = 4
_name$ = 16						; size = 4
_value$ = 20						; size = 4
_xmlValidNormalizeAttributeValue PROC			; COMDAT

; 4073 : 			        const xmlChar *name, const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	ecx, OFFSET __56F63275_valid@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _doc$[ebp]
	test	ebx, ebx
	je	$LN35@xmlValidNo

; 4074 :     xmlChar *ret, *dst;
; 4075 :     const xmlChar *src;
; 4076 :     xmlAttributePtr attrDecl = NULL;
; 4077 : 
; 4078 :     if (doc == NULL) return(NULL);
; 4079 :     if (elem == NULL) return(NULL);

	mov	edi, DWORD PTR _elem$[ebp]
	test	edi, edi
	je	$LN35@xmlValidNo

; 4080 :     if (name == NULL) return(NULL);

	cmp	DWORD PTR _name$[ebp], 0
	je	$LN35@xmlValidNo

; 4081 :     if (value == NULL) return(NULL);

	mov	esi, DWORD PTR _value$[ebp]
	test	esi, esi
	je	$LN35@xmlValidNo

; 4082 : 
; 4083 :     if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN14@xmlValidNo
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN14@xmlValidNo

; 4084 : 	xmlChar fn[50];
; 4085 : 	xmlChar *fullname;
; 4086 : 
; 4087 : 	fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);

	push	50					; 00000032H
	lea	ecx, DWORD PTR _fn$1[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [edi+8]
	call	_xmlBuildQName
	add	esp, 16					; 00000010H

; 4088 : 	if (fullname == NULL)

	test	eax, eax
	je	$LN35@xmlValidNo

; 4089 : 	    return(NULL);
; 4090 : 	if ((fullname != fn) && (fullname != elem->name))

	lea	ecx, DWORD PTR _fn$1[ebp]
	cmp	eax, ecx
	je	SHORT $LN14@xmlValidNo
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN14@xmlValidNo

; 4091 : 	    xmlFree(fullname);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlValidNo:

; 4092 :     }
; 4093 :     attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [ebx+44]
	call	_xmlGetDtdAttrDesc
	add	esp, 12					; 0000000cH

; 4094 :     if ((attrDecl == NULL) && (doc->extSubset != NULL))

	test	eax, eax
	jne	SHORT $LN16@xmlValidNo
	mov	eax, DWORD PTR [ebx+48]
	test	eax, eax
	je	SHORT $LN35@xmlValidNo

; 4095 : 	attrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [edi+8]
	push	eax
	call	_xmlGetDtdAttrDesc
	add	esp, 12					; 0000000cH

; 4096 : 
; 4097 :     if (attrDecl == NULL)

	test	eax, eax
	je	SHORT $LN35@xmlValidNo
$LN16@xmlValidNo:

; 4098 : 	return(NULL);
; 4099 :     if (attrDecl->atype == XML_ATTRIBUTE_CDATA)

	cmp	DWORD PTR [eax+40], 1
	je	SHORT $LN35@xmlValidNo

; 4100 : 	return(NULL);
; 4101 : 
; 4102 :     ret = xmlStrdup(value);

	push	esi
	call	_xmlStrdup
	mov	edi, eax
	add	esp, 4

; 4103 :     if (ret == NULL)

	test	edi, edi
	je	SHORT $LN35@xmlValidNo

; 4104 : 	return(NULL);
; 4105 :     src = value;
; 4106 :     dst = ret;
; 4107 :     while (*src == 0x20) src++;

	mov	dl, BYTE PTR [esi]
	mov	ecx, edi
	cmp	dl, 32					; 00000020H
	jne	SHORT $LN24@xmlValidNo
	npad	7
$LL2@xmlValidNo:
	mov	dl, BYTE PTR [esi+1]
	inc	esi
	cmp	dl, 32					; 00000020H
	je	SHORT $LL2@xmlValidNo
$LN24@xmlValidNo:

; 4108 :     while (*src != 0) {

	test	dl, dl
	je	SHORT $LN5@xmlValidNo
	npad	3
$LL4@xmlValidNo:

; 4109 : 	if (*src == 0x20) {

	cmp	dl, 32					; 00000020H
	jne	SHORT $LN19@xmlValidNo
$LL6@xmlValidNo:

; 4110 : 	    while (*src == 0x20) src++;

	mov	al, BYTE PTR [esi+1]
	mov	edx, esi
	inc	esi
	cmp	al, 32					; 00000020H
	je	SHORT $LL6@xmlValidNo

; 4111 : 	    if (*src != 0)

	test	al, al
	je	SHORT $LN20@xmlValidNo

; 4112 : 		*dst++ = 0x20;

	mov	BYTE PTR [ecx], 32			; 00000020H

; 4113 : 	} else {

	jmp	SHORT $LN36@xmlValidNo
$LN19@xmlValidNo:

; 4114 : 	    *dst++ = *src++;

	mov	BYTE PTR [ecx], dl
	mov	edx, esi
$LN36@xmlValidNo:

; 4108 :     while (*src != 0) {

	inc	ecx
$LN20@xmlValidNo:
	lea	esi, DWORD PTR [edx+1]
	mov	dl, BYTE PTR [esi]
	test	dl, dl
	jne	SHORT $LL4@xmlValidNo
$LN5@xmlValidNo:

; 4115 : 	}
; 4116 :     }
; 4117 :     *dst = 0;
; 4118 :     return(ret);

	mov	eax, edi
	mov	BYTE PTR [ecx], 0
	pop	edi

; 4119 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@xmlValidNo:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidNormalizeAttributeValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateElementDecl
_TEXT	SEGMENT
_name$1$ = -8						; size = 4
_ret$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_elem$ = 16						; size = 4
_xmlValidateElementDecl PROC				; COMDAT

; 4260 :                        xmlElementPtr elem) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	ebx, 1
	mov	DWORD PTR _ret$1$[ebp], ebx
	test	ecx, ecx
	je	$LN43@xmlValidat

; 4261 :     int ret = 1;
; 4262 :     xmlElementPtr tst;
; 4263 : 
; 4264 :     CHECK_DTD;

	cmp	DWORD PTR [ecx+44], 0
	jne	SHORT $LN42@xmlValidat
	cmp	DWORD PTR [ecx+48], 0
	je	$LN43@xmlValidat
$LN42@xmlValidat:
	push	esi

; 4265 : 
; 4266 :     if (elem == NULL) return(1);

	mov	esi, DWORD PTR _elem$[ebp]
	test	esi, esi
	jne	SHORT $LN9@xmlValidat
	pop	esi
	mov	eax, ebx
	pop	ebx

; 4353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlValidat:

; 4267 : 
; 4268 : #if 0
; 4269 : #ifdef LIBXML_REGEXP_ENABLED
; 4270 :     /* Build the regexp associated to the content model */
; 4271 :     ret = xmlValidBuildContentModel(ctxt, elem);
; 4272 : #endif
; 4273 : #endif
; 4274 : 
; 4275 :     /* No Duplicate Types */
; 4276 :     if (elem->etype == XML_ELEMENT_TYPE_MIXED) {

	cmp	DWORD PTR [esi+36], 3
	push	edi
	jne	$LN33@xmlValidat

; 4277 : 	xmlElementContentPtr cur, next;
; 4278 :         const xmlChar *name;
; 4279 : 
; 4280 : 	cur = elem->content;

	mov	ebx, DWORD PTR [esi+40]

; 4281 : 	while (cur != NULL) {

	test	ebx, ebx
	je	$LN50@xmlValidat
	npad	6
$LL2@xmlValidat:

; 4282 : 	    if (cur->type != XML_ELEMENT_CONTENT_OR) break;

	cmp	DWORD PTR [ebx], 4
	jne	$LN44@xmlValidat

; 4283 : 	    if (cur->c1 == NULL) break;

	mov	edi, DWORD PTR [ebx+12]
	test	edi, edi
	je	$LN44@xmlValidat

; 4284 : 	    if (cur->c1->type == XML_ELEMENT_CONTENT_ELEMENT) {

	cmp	DWORD PTR [edi], 2
	jne	$LN15@xmlValidat

; 4285 : 		name = cur->c1->name;
; 4286 : 		next = cur->c2;

	mov	esi, DWORD PTR [ebx+16]
	mov	edi, DWORD PTR [edi+8]
	mov	DWORD PTR _name$1$[ebp], edi

; 4287 : 		while (next != NULL) {

	test	esi, esi
	je	$LN49@xmlValidat
	npad	2
$LL4@xmlValidat:

; 4288 : 		    if (next->type == XML_ELEMENT_CONTENT_ELEMENT) {

	cmp	DWORD PTR [esi], 2
	je	$LN30@xmlValidat

; 4301 : 			}
; 4302 : 			break;
; 4303 : 		    }
; 4304 : 		    if (next->c1 == NULL) break;

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	$LN49@xmlValidat

; 4305 : 		    if (next->c1->type != XML_ELEMENT_CONTENT_ELEMENT) break;

	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN49@xmlValidat

; 4306 : 		    if ((xmlStrEqual(next->c1->name, name)) &&

	push	edi
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlValidat
	mov	eax, DWORD PTR [ebx+12]
	push	DWORD PTR [eax+24]
	mov	eax, DWORD PTR [esi+12]
	push	DWORD PTR [eax+24]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlValidat

; 4307 : 		        (xmlStrEqual(next->c1->prefix, cur->c1->prefix))) {
; 4308 : 			if (cur->c1->prefix == NULL) {

	mov	eax, DWORD PTR [ebx+12]

; 4309 : 			    xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,
; 4310 : 	       "Definition of %s has duplicate references to %s\n",
; 4311 : 				   elem->name, name, NULL);
; 4312 : 			} else {
; 4313 : 			    xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,
; 4314 : 	       "Definition of %s has duplicate references to %s:%s\n",
; 4315 : 				   elem->name, cur->c1->prefix, name);
; 4316 : 			}
; 4317 : 			ret = 0;

	mov	ecx, OFFSET ??_C@_0DE@PAODFKFF@Definition?5of?5?$CFs?5has?5duplicate?5@
	mov	edx, DWORD PTR [eax+24]
	test	edx, edx
	mov	edi, edx
	cmove	edi, DWORD PTR _name$1$[ebp]
	xor	eax, eax
	test	edx, edx
	mov	edx, OFFSET ??_C@_0DB@HNLIHGKJ@Definition?5of?5?$CFs?5has?5duplicate?5@
	cmovne	eax, DWORD PTR _name$1$[ebp]
	cmove	ecx, edx
	mov	edx, DWORD PTR _elem$[ebp]
	push	eax
	push	edi
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	ecx
	push	503					; 000001f7H
	push	edx
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	mov	edi, DWORD PTR _name$1$[ebp]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret$1$[ebp], 0
$LN20@xmlValidat:

; 4318 : 		    }
; 4319 : 		    next = next->c2;

	mov	esi, DWORD PTR [esi+16]
	test	esi, esi
	jne	$LL4@xmlValidat
$LN49@xmlValidat:

; 4320 : 		}
; 4321 : 	    }
; 4322 : 	    cur = cur->c2;

	mov	esi, DWORD PTR _elem$[ebp]
$LN15@xmlValidat:
	mov	ebx, DWORD PTR [ebx+16]
	test	ebx, ebx
	jne	$LL2@xmlValidat
$LN44@xmlValidat:

; 4281 : 	while (cur != NULL) {

	mov	ebx, DWORD PTR _ret$1$[ebp]
	mov	ecx, DWORD PTR _doc$[ebp]
	jmp	SHORT $LN33@xmlValidat
$LN30@xmlValidat:

; 4289 : 		        if ((xmlStrEqual(next->name, name)) &&

	push	edi
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN49@xmlValidat
	mov	eax, DWORD PTR [ebx+12]
	push	DWORD PTR [eax+24]
	push	DWORD PTR [esi+24]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN49@xmlValidat

; 4290 : 			    (xmlStrEqual(next->prefix, cur->c1->prefix))) {
; 4291 : 			    if (cur->c1->prefix == NULL) {

	mov	eax, DWORD PTR [ebx+12]

; 4292 : 				xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,
; 4293 : 		   "Definition of %s has duplicate references of %s\n",
; 4294 : 				       elem->name, name, NULL);
; 4295 : 			    } else {
; 4296 : 				xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,
; 4297 : 		   "Definition of %s has duplicate references of %s:%s\n",
; 4298 : 				       elem->name, cur->c1->prefix, name);
; 4299 : 			    }
; 4300 : 			    ret = 0;

	mov	ecx, OFFSET ??_C@_0DE@IDAOJGBB@Definition?5of?5?$CFs?5has?5duplicate?5@
	mov	edx, DWORD PTR [eax+24]
	test	edx, edx
	mov	esi, edx
	cmove	esi, edi
	xor	eax, eax
	test	edx, edx
	mov	edx, OFFSET ??_C@_0DB@DPGOOPFF@Definition?5of?5?$CFs?5has?5duplicate?5@
	cmovne	eax, edi
	cmove	ecx, edx
	push	eax
	push	esi
	mov	esi, DWORD PTR _elem$[ebp]
	mov	eax, DWORD PTR [esi+8]
	push	eax
	push	ecx
	push	503					; 000001f7H
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret$1$[ebp], 0

; 4301 : 			}
; 4302 : 			break;
; 4303 : 		    }
; 4304 : 		    if (next->c1 == NULL) break;

	jmp	SHORT $LN15@xmlValidat
$LN50@xmlValidat:

; 4281 : 	while (cur != NULL) {

	mov	ebx, 1
$LN33@xmlValidat:

; 4323 : 	}
; 4324 :     }
; 4325 : 
; 4326 :     /* VC: Unique Element Type Declaration */
; 4327 :     tst = xmlGetDtdElementDesc(doc->intSubset, elem->name);

	push	DWORD PTR [esi+8]
	push	DWORD PTR [ecx+44]
	call	_xmlGetDtdElementDesc
	mov	edi, eax
	add	esp, 8

; 4328 :     if ((tst != NULL ) && (tst != elem) &&
; 4329 : 	((tst->prefix == elem->prefix) ||
; 4330 : 	 (xmlStrEqual(tst->prefix, elem->prefix))) &&

	test	edi, edi
	je	SHORT $LN23@xmlValidat
	cmp	edi, esi
	je	SHORT $LN23@xmlValidat
	mov	eax, DWORD PTR [edi+48]
	mov	ecx, DWORD PTR [esi+48]
	cmp	eax, ecx
	je	SHORT $LN24@xmlValidat
	push	ecx
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xmlValidat
$LN24@xmlValidat:
	cmp	DWORD PTR [edi+36], 0
	je	SHORT $LN23@xmlValidat

; 4331 : 	(tst->etype != XML_ELEMENT_TYPE_UNDEFINED)) {
; 4332 : 	xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_ELEM_REDEFINED,

	push	0
	push	0
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0BM@DLJMKEJ@Redefinition?5of?5element?5?$CFs?6@
	push	509					; 000001fdH
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 4333 : 	                "Redefinition of element %s\n",
; 4334 : 		       elem->name, NULL, NULL);
; 4335 : 	ret = 0;

	xor	ebx, ebx
$LN23@xmlValidat:

; 4336 :     }
; 4337 :     tst = xmlGetDtdElementDesc(doc->extSubset, elem->name);

	mov	eax, DWORD PTR _doc$[ebp]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [eax+48]
	call	_xmlGetDtdElementDesc
	mov	edi, eax
	add	esp, 8

; 4338 :     if ((tst != NULL ) && (tst != elem) &&
; 4339 : 	((tst->prefix == elem->prefix) ||
; 4340 : 	 (xmlStrEqual(tst->prefix, elem->prefix))) &&

	test	edi, edi
	je	SHORT $LN25@xmlValidat
	cmp	edi, esi
	je	SHORT $LN25@xmlValidat
	mov	eax, DWORD PTR [edi+48]
	mov	ecx, DWORD PTR [esi+48]
	cmp	eax, ecx
	je	SHORT $LN26@xmlValidat
	push	ecx
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlValidat
$LN26@xmlValidat:
	cmp	DWORD PTR [edi+36], 0
	je	SHORT $LN25@xmlValidat

; 4341 : 	(tst->etype != XML_ELEMENT_TYPE_UNDEFINED)) {
; 4342 : 	xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_ELEM_REDEFINED,

	push	0
	push	0
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0BM@DLJMKEJ@Redefinition?5of?5element?5?$CFs?6@
	push	509					; 000001fdH
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 4343 : 	                "Redefinition of element %s\n",
; 4344 : 		       elem->name, NULL, NULL);
; 4345 : 	ret = 0;

	xor	ebx, ebx
$LN25@xmlValidat:

; 4346 :     }
; 4347 :     /* One ID per Element Type
; 4348 :      * already done when registering the attribute
; 4349 :     if (xmlScanIDAttributeDecl(ctxt, elem) > 1) {
; 4350 : 	ret = 0;
; 4351 :     } */
; 4352 :     return(ret);

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx

; 4353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@xmlValidat:

; 4261 :     int ret = 1;
; 4262 :     xmlElementPtr tst;
; 4263 : 
; 4264 :     CHECK_DTD;

	xor	eax, eax
	pop	ebx

; 4353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidateElementDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlValidateRoot
_TEXT	SEGMENT
_fn$1 = -52						; size = 50
_ctxt$ = 8						; size = 4
_ret$1$ = 12						; size = 4
_doc$ = 12						; size = 4
_xmlValidateRoot PROC					; COMDAT

; 6345 : xmlValidateRoot(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	ecx, OFFSET __56F63275_valid@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlValidat

; 6346 :     xmlNodePtr root;
; 6347 :     int ret;
; 6348 : 
; 6349 :     if (doc == NULL) return(0);

	xor	eax, eax
	pop	edi

; 6394 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlValidat:
	push	esi

; 6350 : 
; 6351 :     root = xmlDocGetRootElement(doc);

	push	edi
	call	_xmlDocGetRootElement
	mov	esi, eax
	add	esp, 4

; 6352 :     if ((root == NULL) || (root->name == NULL)) {

	test	esi, esi
	je	$LN4@xmlValidat
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	$LN4@xmlValidat

; 6356 :     }
; 6357 : 
; 6358 :     /*
; 6359 :      * When doing post validation against a separate DTD, those may
; 6360 :      * no internal subset has been generated
; 6361 :      */
; 6362 :     if ((doc->intSubset != NULL) &&

	mov	ecx, DWORD PTR [edi+44]
	push	ebx
	test	ecx, ecx
	je	$name_ok$25
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	$name_ok$25

; 6363 : 	(doc->intSubset->name != NULL)) {
; 6364 : 	/*
; 6365 : 	 * Check first the document root against the NQName
; 6366 : 	 */
; 6367 : 	if (!xmlStrEqual(doc->intSubset->name, root->name)) {

	push	eax
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$name_ok$25

; 6368 : 	    if ((root->ns != NULL) && (root->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN10@xmlValidat
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN10@xmlValidat

; 6369 : 		xmlChar fn[50];
; 6370 : 		xmlChar *fullname;
; 6371 : 
; 6372 : 		fullname = xmlBuildQName(root->name, root->ns->prefix, fn, 50);

	push	50					; 00000032H
	lea	ecx, DWORD PTR _fn$1[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+8]
	call	_xmlBuildQName
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 6373 : 		if (fullname == NULL) {

	test	ebx, ebx
	jne	SHORT $LN8@xmlValidat

; 6374 : 		    xmlVErrMemory(ctxt, NULL);

	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlVErrMemory
	add	esp, 8

; 6375 : 		    return(0);

	xor	eax, eax
	pop	ebx
	pop	esi
	pop	edi

; 6394 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlValidat:

; 6376 : 		}
; 6377 : 		ret = xmlStrEqual(doc->intSubset->name, fullname);

	mov	eax, DWORD PTR [edi+44]
	push	ebx
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual

; 6378 : 		if ((fullname != fn) && (fullname != root->name))

	lea	ecx, DWORD PTR _fn$1[ebp]
	mov	DWORD PTR _ret$1$[ebp], eax
	add	esp, 8
	cmp	ebx, ecx
	je	SHORT $LN9@xmlValidat
	cmp	ebx, DWORD PTR [esi+8]
	je	SHORT $LN9@xmlValidat

; 6379 : 		    xmlFree(fullname);

	push	ebx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 4
$LN9@xmlValidat:

; 6380 : 		if (ret == 1)

	cmp	eax, 1
	je	SHORT $name_ok$25
$LN10@xmlValidat:

; 6381 : 		    goto name_ok;
; 6382 : 	    }
; 6383 : 	    if ((xmlStrEqual(doc->intSubset->name, BAD_CAST "HTML")) &&

	mov	eax, DWORD PTR [edi+44]
	push	OFFSET ??_C@_04DBLPJNAF@HTML@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlValidat
	push	OFFSET ??_C@_04PNIFHPHN@html@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $name_ok$25
$LN11@xmlValidat:

; 6384 : 		(xmlStrEqual(root->name, BAD_CAST "html")))
; 6385 : 		goto name_ok;
; 6386 : 	    xmlErrValidNode(ctxt, root, XML_DTD_ROOT_NAME,

	mov	eax, DWORD PTR [edi+44]
	push	0
	push	DWORD PTR [eax+8]
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0CO@PMJDAMAF@root?5and?5DTD?5name?5do?5not?5match?5@
	push	531					; 00000213H
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
	xor	eax, eax
	pop	ebx
	pop	esi
	pop	edi

; 6394 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$name_ok$25:
	pop	ebx
	pop	esi

; 6387 : 		   "root and DTD name do not match '%s' and '%s'\n",
; 6388 : 		   root->name, doc->intSubset->name, NULL);
; 6389 : 	    return(0);
; 6390 : 	}
; 6391 :     }
; 6392 : name_ok:
; 6393 :     return(1);

	mov	eax, 1
	pop	edi

; 6394 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlValidat:

; 104  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	xor	edx, edx
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN17@xmlValidat

; 105  :         channel = ctxt->error;
; 106  :         data = ctxt->userData;
; 107  : 	/* Use the special values to detect if it is part of a parsing
; 108  : 	   context */
; 109  : 	if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||

	mov	edi, DWORD PTR [eax+28]
	mov	esi, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	cmp	edi, -1412623820			; abcd1234H
	je	SHORT $LN16@xmlValidat
	cmp	edi, -1412623819			; abcd1235H
	jne	SHORT $LN17@xmlValidat
$LN16@xmlValidat:

; 110  : 	    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {
; 111  : 	    long delta = (char *) ctxt - (char *) ctxt->userData;

	sub	eax, ecx

; 112  : 	    if ((delta > 0) && (delta < 250))

	dec	eax
	cmp	eax, 248				; 000000f8H
	cmovbe	edx, ecx
$LN17@xmlValidat:

; 113  : 		pctxt = ctxt->userData;
; 114  : 	}
; 115  :     }
; 116  :     if (extra)
; 117  :         __xmlRaiseError(NULL, channel, data,
; 118  :                         pctxt, NULL, XML_FROM_VALID, error,
; 119  :                         XML_ERR_ERROR, NULL, 0, extra, NULL, NULL, 0, 0,
; 120  :                         msg, extra);
; 121  :     else
; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0BB@JNDFICHA@no?5root?5element?6@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	525					; 0000020dH
	push	23					; 00000017H
	push	0
	push	edx
	push	ecx
	push	esi
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 6353 : 	xmlErrValid(ctxt, XML_DTD_NO_ROOT,
; 6354 : 	            "no root element\n", NULL);
; 6355 :         return(0);

	xor	eax, eax
	pop	esi
	pop	edi

; 6394 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidateRoot ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeValidCtxt
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlFreeValidCtxt PROC					; COMDAT

; 900  : xmlFreeValidCtxt(xmlValidCtxtPtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN2@xmlFreeVal

; 901  :     if (cur->vstateTab != NULL)
; 902  :         xmlFree(cur->vstateTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlFreeVal:

; 903  :     if (cur->nodeTab != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN3@xmlFreeVal

; 904  :         xmlFree(cur->nodeTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlFreeVal:

; 905  :     xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi

; 906  : }

	pop	ebp
	ret	0
_xmlFreeValidCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlNewValidCtxt
_TEXT	SEGMENT
_xmlNewValidCtxt PROC					; COMDAT

; 880  : xmlValidCtxtPtr xmlNewValidCtxt(void) {

	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	64					; 00000040H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlNewVali

; 77   :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	eax
	push	eax
	push	3
	push	2
	push	23					; 00000017H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 881  :     xmlValidCtxtPtr ret;
; 882  : 
; 883  :     if ((ret = xmlMalloc(sizeof (xmlValidCtxt))) == NULL) {
; 884  : 	xmlVErrMemory(NULL, "malloc failed");
; 885  : 	return (NULL);

	xor	eax, eax
	pop	esi

; 891  : }

	ret	0
$LN2@xmlNewVali:

; 886  :     }
; 887  : 
; 888  :     (void) memset(ret, 0, sizeof (xmlValidCtxt));

	push	64					; 00000040H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 889  : 
; 890  :     return (ret);

	mov	eax, esi
	pop	esi

; 891  : }

	ret	0
_xmlNewValidCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlGetRefs
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_ID$ = 12						; size = 4
_xmlGetRefs PROC					; COMDAT

; 3141 : xmlGetRefs(xmlDocPtr doc, const xmlChar *ID) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlGetRefs

; 3142 :     xmlRefTablePtr table;
; 3143 : 
; 3144 :     if (doc == NULL) {
; 3145 :         return(NULL);
; 3146 :     }
; 3147 : 
; 3148 :     if (ID == NULL) {

	mov	ecx, DWORD PTR _ID$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@xmlGetRefs

; 3149 :         return(NULL);
; 3150 :     }
; 3151 : 
; 3152 :     table = (xmlRefTablePtr) doc->refs;

	mov	eax, DWORD PTR [eax+68]

; 3153 :     if (table == NULL)

	test	eax, eax
	je	SHORT $LN6@xmlGetRefs

; 3155 : 
; 3156 :     return (xmlHashLookup(table, ID));

	mov	DWORD PTR _ID$[ebp], ecx
	mov	DWORD PTR _doc$[ebp], eax

; 3157 : }

	pop	ebp

; 3155 : 
; 3156 :     return (xmlHashLookup(table, ID));

	jmp	_xmlHashLookup
$LN6@xmlGetRefs:

; 3154 :         return(NULL);

	xor	eax, eax

; 3157 : }

	pop	ebp
	ret	0
_xmlGetRefs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlRemoveRef
_TEXT	SEGMENT
_target$ = -8						; size = 8
_ref_list$1$ = 8					; size = 4
_doc$ = 8						; size = 4
_attr$ = 12						; size = 4
_xmlRemoveRef PROC					; COMDAT

; 3085 : xmlRemoveRef(xmlDocPtr doc, xmlAttrPtr attr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __56F63275_valid@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	je	SHORT $LN9@xmlRemoveR

; 3086 :     xmlListPtr ref_list;
; 3087 :     xmlRefTablePtr table;
; 3088 :     xmlChar *ID;
; 3089 :     xmlRemoveMemo target;
; 3090 : 
; 3091 :     if (doc == NULL) return(-1);
; 3092 :     if (attr == NULL) return(-1);

	mov	ebx, DWORD PTR _attr$[ebp]
	test	ebx, ebx
	je	SHORT $LN9@xmlRemoveR

; 3093 : 
; 3094 :     table = (xmlRefTablePtr) doc->refs;

	mov	edi, DWORD PTR [eax+68]

; 3095 :     if (table == NULL)

	test	edi, edi
	je	SHORT $LN9@xmlRemoveR

; 3096 :         return(-1);
; 3097 : 
; 3098 :     ID = xmlNodeListGetString(doc, attr->children, 1);

	push	1
	push	DWORD PTR [ebx+12]
	push	eax
	call	_xmlNodeListGetString
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 3099 :     if (ID == NULL)

	test	esi, esi
	je	SHORT $LN9@xmlRemoveR

; 3100 :         return(-1);
; 3101 : 
; 3102 :     ref_list = xmlHashLookup(table, ID);

	push	esi
	push	edi
	call	_xmlHashLookup
	add	esp, 8
	mov	DWORD PTR _ref_list$1$[ebp], eax

; 3103 :     if(ref_list == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlRemoveR

; 3104 :         xmlFree(ID);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlRemoveR:

; 3129 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlRemoveR:

; 3105 :         return (-1);
; 3106 :     }
; 3107 : 
; 3108 :     /* At this point, ref_list refers to a list of references which
; 3109 :      * have the same key as the supplied attr. Our list of references
; 3110 :      * is ordered by reference address and we don't have that information
; 3111 :      * here to use when removing. We'll have to walk the list and
; 3112 :      * check for a matching attribute, when we find one stop the walk
; 3113 :      * and remove the entry.
; 3114 :      * The list is ordered by reference, so that means we don't have the
; 3115 :      * key. Passing the list and the reference to the walker means we
; 3116 :      * will have enough data to be able to remove the entry.
; 3117 :      */
; 3118 :     target.l = ref_list;
; 3119 :     target.ap = attr;
; 3120 : 
; 3121 :     /* Remove the supplied attr from our list */
; 3122 :     xmlListWalk(ref_list, xmlWalkRemoveRef, &target);

	lea	ecx, DWORD PTR _target$[ebp]
	mov	DWORD PTR _target$[ebp], eax
	push	ecx
	push	OFFSET _xmlWalkRemoveRef
	push	eax
	mov	DWORD PTR _target$[ebp+4], ebx
	call	_xmlListWalk

; 3123 : 
; 3124 :     /*If the list is empty then remove the list entry in the hash */
; 3125 :     if (xmlListEmpty(ref_list))

	push	DWORD PTR _ref_list$1$[ebp]
	call	_xmlListEmpty
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN7@xmlRemoveR

; 3126 :         xmlHashUpdateEntry(table, ID, NULL, xmlFreeRefTableEntry);

	push	OFFSET _xmlFreeRefTableEntry
	push	0
	push	esi
	push	edi
	call	_xmlHashUpdateEntry
	add	esp, 16					; 00000010H
$LN7@xmlRemoveR:

; 3127 :     xmlFree(ID);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3128 :     return(0);

	xor	eax, eax
	pop	edi

; 3129 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRemoveRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlIsRef
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_elem$ = 12						; size = 4
_attr$ = 16						; size = 4
_xmlIsRef PROC						; COMDAT

; 3045 : xmlIsRef(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _attr$[ebp]
	test	edi, edi
	je	SHORT $LN11@xmlIsRef

; 3046 :     if (attr == NULL)
; 3047 :         return(0);
; 3048 :     if (doc == NULL) {

	mov	esi, DWORD PTR _doc$[ebp]
	test	esi, esi
	jne	SHORT $LN4@xmlIsRef

; 3049 :         doc = attr->doc;

	mov	esi, DWORD PTR [edi+32]

; 3050 : 	if (doc == NULL) return(0);

	test	esi, esi
	je	SHORT $LN11@xmlIsRef
$LN4@xmlIsRef:

; 3051 :     }
; 3052 : 
; 3053 :     if ((doc->intSubset == NULL) && (doc->extSubset == NULL)) {

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	jne	SHORT $LN16@xmlIsRef
	cmp	DWORD PTR [esi+48], eax
	je	SHORT $LN11@xmlIsRef
$LN16@xmlIsRef:

; 3054 :         return(0);
; 3055 :     } else if (doc->type == XML_HTML_DOCUMENT_NODE) {

	cmp	DWORD PTR [esi+4], 13			; 0000000dH
	je	SHORT $LN11@xmlIsRef

; 3056 :         /* TODO @@@ */
; 3057 :         return(0);
; 3058 :     } else {
; 3059 :         xmlAttributePtr attrDecl;
; 3060 : 
; 3061 :         if (elem == NULL) return(0);

	mov	ebx, DWORD PTR _elem$[ebp]
	test	ebx, ebx
	je	SHORT $LN11@xmlIsRef

; 3062 :         attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, attr->name);

	push	DWORD PTR [edi+8]
	push	DWORD PTR [ebx+8]
	push	eax
	call	_xmlGetDtdAttrDesc
	add	esp, 12					; 0000000cH

; 3063 :         if ((attrDecl == NULL) && (doc->extSubset != NULL))

	test	eax, eax
	jne	SHORT $LN15@xmlIsRef
	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN11@xmlIsRef

; 3064 :             attrDecl = xmlGetDtdAttrDesc(doc->extSubset,

	push	DWORD PTR [edi+8]
	push	DWORD PTR [ebx+8]
	push	eax
	call	_xmlGetDtdAttrDesc
	add	esp, 12					; 0000000cH

; 3065 : 		                         elem->name, attr->name);
; 3066 : 
; 3067 : 	if ((attrDecl != NULL) &&

	test	eax, eax
	je	SHORT $LN11@xmlIsRef
$LN15@xmlIsRef:
	mov	eax, DWORD PTR [eax+40]
	cmp	eax, 3
	je	SHORT $LN12@xmlIsRef
	cmp	eax, 4
	jne	SHORT $LN11@xmlIsRef
$LN12@xmlIsRef:
	pop	edi

; 3068 : 	    (attrDecl->atype == XML_ATTRIBUTE_IDREF ||
; 3069 : 	     attrDecl->atype == XML_ATTRIBUTE_IDREFS))
; 3070 : 	return(1);
; 3071 :     }
; 3072 :     return(0);
; 3073 : }

	pop	esi
	mov	eax, 1
	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlIsRef:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlIsRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeRefTable
_TEXT	SEGMENT
_table$ = 8						; size = 4
_xmlFreeRefTable PROC					; COMDAT

; 3028 : xmlFreeRefTable(xmlRefTablePtr table) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	OFFSET _xmlFreeRefTableEntry
	push	DWORD PTR _table$[ebp]
	call	_xmlHashFree
	add	esp, 8

; 3029 :     xmlHashFree(table, xmlFreeRefTableEntry);
; 3030 : }

	pop	ebp
	ret	0
_xmlFreeRefTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlAddRef
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_value$ = 16						; size = 4
_attr$ = 20						; size = 4
_xmlAddRef PROC						; COMDAT

; 2931 :     xmlAttrPtr attr) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _doc$[ebp]
	test	esi, esi
	je	$LN42@xmlAddRef

; 2932 :     xmlRefPtr ret;
; 2933 :     xmlRefTablePtr table;
; 2934 :     xmlListPtr ref_list;
; 2935 : 
; 2936 :     if (doc == NULL) {
; 2937 :         return(NULL);
; 2938 :     }
; 2939 :     if (value == NULL) {

	mov	ebx, DWORD PTR _value$[ebp]
	test	ebx, ebx
	je	$LN42@xmlAddRef

; 2940 :         return(NULL);
; 2941 :     }
; 2942 :     if (attr == NULL) {

	cmp	DWORD PTR _attr$[ebp], 0
	je	$LN42@xmlAddRef

; 2944 :     }
; 2945 : 
; 2946 :     /*
; 2947 :      * Create the Ref table if needed.
; 2948 :      */
; 2949 :     table = (xmlRefTablePtr) doc->refs;

	push	edi
	mov	edi, DWORD PTR [esi+68]

; 2950 :     if (table == NULL) {

	test	edi, edi
	jne	SHORT $LN6@xmlAddRef

; 2951 :         doc->refs = table = xmlHashCreateDict(0, doc->dict);

	push	DWORD PTR [esi+80]
	push	edi
	call	_xmlHashCreateDict
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR [esi+68], edi

; 2952 :     }
; 2953 :     if (table == NULL) {

	test	edi, edi
	jne	SHORT $LN6@xmlAddRef

; 2954 : 	xmlVErrMemory(ctxt,

	push	OFFSET ??_C@_0CD@JKLLCBGN@xmlAddRef?3?5Table?5creation?5faile@

; 2962 :         return(NULL);

	push	DWORD PTR _ctxt$[ebp]
	call	_xmlVErrMemory
	add	esp, 8
	xor	eax, eax
	pop	edi
	pop	esi

; 3017 :     }
; 3018 :     return(NULL);
; 3019 : }

	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlAddRef:

; 2955 :             "xmlAddRef: Table creation failed!\n");
; 2956 :         return(NULL);
; 2957 :     }
; 2958 : 
; 2959 :     ret = (xmlRefPtr) xmlMalloc(sizeof(xmlRef));

	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 2960 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN7@xmlAddRef

; 2961 : 	xmlVErrMemory(ctxt, "malloc failed");

	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@

; 2962 :         return(NULL);

	push	DWORD PTR _ctxt$[ebp]
	call	_xmlVErrMemory
	add	esp, 8
	xor	eax, eax
	pop	edi
	pop	esi

; 3017 :     }
; 3018 :     return(NULL);
; 3019 : }

	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlAddRef:

; 2963 :     }
; 2964 : 
; 2965 :     /*
; 2966 :      * fill the structure.
; 2967 :      */
; 2968 :     ret->value = xmlStrdup(value);

	push	ebx
	call	_xmlStrdup
	mov	DWORD PTR [esi+4], eax
	add	esp, 4

; 2969 :     if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN8@xmlAddRef
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN8@xmlAddRef

; 2970 : 	/*
; 2971 : 	 * Operating in streaming mode, attr is gonna disapear
; 2972 : 	 */
; 2973 : 	ret->name = xmlStrdup(attr->name);

	mov	eax, DWORD PTR _attr$[ebp]
	push	DWORD PTR [eax+8]
	call	_xmlStrdup
	add	esp, 4

; 2974 : 	ret->attr = NULL;

	mov	edx, eax

; 2975 :     } else {

	mov	eax, DWORD PTR _attr$[ebp]
	xor	ecx, ecx
	jmp	SHORT $LN9@xmlAddRef
$LN8@xmlAddRef:

; 2976 : 	ret->name = NULL;
; 2977 : 	ret->attr = attr;

	mov	eax, DWORD PTR _attr$[ebp]
	xor	edx, edx
	mov	ecx, eax
$LN9@xmlAddRef:

; 2978 :     }
; 2979 :     ret->lineno = xmlGetLineNo(attr->parent);

	mov	DWORD PTR [esi+12], edx
	mov	DWORD PTR [esi+8], ecx
	push	DWORD PTR [eax+20]
	call	_xmlGetLineNo

; 2980 : 
; 2981 :     /* To add a reference :-
; 2982 :      * References are maintained as a list of references,
; 2983 :      * Lookup the entry, if no entry create new nodelist
; 2984 :      * Add the owning node to the NodeList
; 2985 :      * Return the ref
; 2986 :      */
; 2987 : 
; 2988 :     if (NULL == (ref_list = xmlHashLookup(table, value))) {

	push	ebx
	push	edi
	mov	DWORD PTR [esi+16], eax
	call	_xmlHashLookup
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	test	ebx, ebx
	jne	SHORT $LN12@xmlAddRef

; 2989 :         if (NULL == (ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare))) {

	push	OFFSET _xmlDummyCompare
	push	OFFSET _xmlFreeRef
	call	_xmlListCreate
	mov	ebx, eax
	add	esp, 8
	test	ebx, ebx
	jne	SHORT $LN11@xmlAddRef

; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0CM@EILGCMCJ@xmlAddRef?3?5Reference?5list?5creat@

; 2990 : 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
; 2991 : 		    "xmlAddRef: Reference list creation failed!\n",
; 2992 : 		    NULL);
; 2993 : 	    goto failed;

	jmp	SHORT $LN44@xmlAddRef
$LN11@xmlAddRef:

; 2994 :         }
; 2995 :         if (xmlHashAddEntry(table, value, ref_list) < 0) {

	push	ebx
	push	DWORD PTR _value$[ebp]
	push	edi
	call	_xmlHashAddEntry
	add	esp, 12					; 0000000cH
	test	eax, eax
	jns	SHORT $LN12@xmlAddRef

; 2996 :             xmlListDelete(ref_list);

	push	ebx
	call	_xmlListDelete

; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0CN@CLGHPEIK@xmlAddRef?3?5Reference?5list?5inser@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1
	push	23					; 00000017H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 2997 : 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
; 2998 : 		    "xmlAddRef: Reference list insertion failed!\n",
; 2999 : 		    NULL);
; 3000 : 	    goto failed;

	jmp	SHORT $failed$48
$LN12@xmlAddRef:

; 3001 :         }
; 3002 :     }
; 3003 :     if (xmlListAppend(ref_list, ret) != 0) {

	push	esi
	push	ebx
	call	_xmlListAppend
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlAddRef

; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0CN@CLGHPEIK@xmlAddRef?3?5Reference?5list?5inser@
$LN44@xmlAddRef:

; 3010 : failed:
; 3011 :     if (ret != NULL) {
; 3012 :         if (ret->value != NULL)

	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1
	push	23					; 00000017H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$failed$48:
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN15@xmlAddRef

; 3013 : 	    xmlFree((char *)ret->value);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlAddRef:

; 3014 :         if (ret->name != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN16@xmlAddRef

; 3015 : 	    xmlFree((char *)ret->name);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlAddRef:

; 3016 :         xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi

; 3017 :     }
; 3018 :     return(NULL);
; 3019 : }

	pop	ebx
	pop	ebp
	ret	0
$LN13@xmlAddRef:
	pop	edi

; 3004 : 	xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
; 3005 : 		    "xmlAddRef: Reference list insertion failed!\n",
; 3006 : 		    NULL);
; 3007 :         goto failed;
; 3008 :     }
; 3009 :     return(ret);

	mov	eax, esi
	pop	esi

; 3017 :     }
; 3018 :     return(NULL);
; 3019 : }

	pop	ebx
	pop	ebp
	ret	0
$LN42@xmlAddRef:
	pop	esi

; 2943 :         return(NULL);

	xor	eax, eax

; 3017 :     }
; 3018 :     return(NULL);
; 3019 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlAddRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlRemoveID
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_attr$ = 12						; size = 4
_xmlRemoveID PROC					; COMDAT

; 2765 : xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	je	SHORT $LN9@xmlRemoveI

; 2766 :     xmlIDTablePtr table;
; 2767 :     xmlIDPtr id;
; 2768 :     xmlChar *ID;
; 2769 : 
; 2770 :     if (doc == NULL) return(-1);
; 2771 :     if (attr == NULL) return(-1);

	mov	edi, DWORD PTR _attr$[ebp]
	test	edi, edi
	je	SHORT $LN9@xmlRemoveI

; 2772 : 
; 2773 :     table = (xmlIDTablePtr) doc->ids;

	mov	ebx, DWORD PTR [eax+64]

; 2774 :     if (table == NULL)

	test	ebx, ebx
	je	SHORT $LN9@xmlRemoveI

; 2775 :         return(-1);
; 2776 : 
; 2777 :     ID = xmlNodeListGetString(doc, attr->children, 1);

	push	1
	push	DWORD PTR [edi+12]
	push	eax
	call	_xmlNodeListGetString
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 2778 :     if (ID == NULL)

	test	esi, esi
	je	SHORT $LN9@xmlRemoveI

; 2779 :         return(-1);
; 2780 : 
; 2781 :     id = xmlHashLookup(table, ID);

	push	esi
	push	ebx
	call	_xmlHashLookup
	add	esp, 8

; 2782 :     if (id == NULL || id->attr != attr) {

	test	eax, eax
	je	SHORT $LN7@xmlRemoveI
	cmp	DWORD PTR [eax+8], edi
	jne	SHORT $LN7@xmlRemoveI

; 2784 :         return(-1);
; 2785 :     }
; 2786 : 
; 2787 :     xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);

	push	OFFSET _xmlFreeIDTableEntry
	push	esi
	push	ebx
	call	_xmlHashRemoveEntry

; 2788 :     xmlFree(ID);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H

; 2789 :     attr->atype = 0;

	mov	DWORD PTR [edi+40], 0

; 2790 :     return(0);

	xor	eax, eax
	pop	edi

; 2791 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlRemoveI:

; 2783 :         xmlFree(ID);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlRemoveI:

; 2791 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
_xmlRemoveID ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlIsID
_TEXT	SEGMENT
_felem$1 = -108						; size = 50
_fattr$2 = -56						; size = 50
_attrDecl$1$ = -4					; size = 4
_doc$ = 8						; size = 4
_elem$ = 12						; size = 4
_attr$ = 16						; size = 4
_xmlIsID PROC						; COMDAT

; 2704 : xmlIsID(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	ecx, OFFSET __56F63275_valid@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _attr$[ebp]
	test	esi, esi
	je	$LN3@xmlIsID

; 2705 :     if ((attr == NULL) || (attr->name == NULL)) return(0);

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	$LN3@xmlIsID

; 2706 :     if ((attr->ns != NULL) && (attr->ns->prefix != NULL) &&
; 2707 :         (!strcmp((char *) attr->name, "id")) &&

	mov	edx, DWORD PTR [esi+36]
	test	edx, edx
	je	SHORT $LN4@xmlIsID
	mov	ecx, DWORD PTR [edx+12]
	test	ecx, ecx
	je	SHORT $LN4@xmlIsID
	mov	edx, OFFSET ??_C@_02EGCJHIOB@id@
	npad	4
$LL26@xmlIsID:
	mov	bl, BYTE PTR [eax]
	cmp	bl, BYTE PTR [edx]
	jne	SHORT $LN27@xmlIsID
	test	bl, bl
	je	SHORT $LN28@xmlIsID
	mov	bl, BYTE PTR [eax+1]
	cmp	bl, BYTE PTR [edx+1]
	jne	SHORT $LN27@xmlIsID
	add	eax, 2
	add	edx, 2
	test	bl, bl
	jne	SHORT $LL26@xmlIsID
$LN28@xmlIsID:
	xor	eax, eax
	jmp	SHORT $LN29@xmlIsID
$LN27@xmlIsID:
	sbb	eax, eax
	or	eax, 1
$LN29@xmlIsID:
	test	eax, eax
	jne	SHORT $LN38@xmlIsID
	mov	eax, OFFSET ??_C@_03PJHHNEEI@xml@
	npad	2
$LL30@xmlIsID:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN31@xmlIsID
	test	dl, dl
	je	SHORT $LN32@xmlIsID
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN31@xmlIsID
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL30@xmlIsID
$LN32@xmlIsID:
	xor	eax, eax
	jmp	SHORT $LN33@xmlIsID
$LN31@xmlIsID:
	sbb	eax, eax
	or	eax, 1
$LN33@xmlIsID:
	test	eax, eax
	je	$LN25@xmlIsID
$LN38@xmlIsID:

; 2708 :         (!strcmp((char *) attr->ns->prefix, "xml")))
; 2709 : 	return(1);
; 2710 :     if (doc == NULL) return(0);

	mov	eax, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+36]
$LN4@xmlIsID:
	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlIsID

; 2711 :     if ((doc->intSubset == NULL) && (doc->extSubset == NULL) &&

	cmp	DWORD PTR [edi+44], 0
	jne	SHORT $LN6@xmlIsID
	cmp	DWORD PTR [edi+48], 0
	jne	SHORT $LN6@xmlIsID
	cmp	DWORD PTR [edi+4], 13			; 0000000dH
	jne	SHORT $LN3@xmlIsID
$LN6@xmlIsID:

; 2712 :         (doc->type != XML_HTML_DOCUMENT_NODE)) {
; 2713 : 	return(0);
; 2714 :     } else if (doc->type == XML_HTML_DOCUMENT_NODE) {

	cmp	DWORD PTR [edi+4], 13			; 0000000dH
	jne	SHORT $LN8@xmlIsID

; 2715 :         if ((xmlStrEqual(BAD_CAST "id", attr->name)) ||

	push	eax
	push	OFFSET ??_C@_02EGCJHIOB@id@
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN25@xmlIsID
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@xmlIsID
	mov	eax, DWORD PTR _elem$[ebp]
	test	eax, eax
	je	$LN25@xmlIsID
	push	OFFSET ??_C@_01MCMALHOG@a@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN25@xmlIsID
$LN3@xmlIsID:
	pop	edi

; 2750 : 	    return(1);
; 2751 :     }
; 2752 :     return(0);
; 2753 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlIsID:

; 2716 : 	    ((xmlStrEqual(BAD_CAST "name", attr->name)) &&
; 2717 : 	    ((elem == NULL) || (xmlStrEqual(elem->name, BAD_CAST "a")))))
; 2718 : 	    return(1);
; 2719 : 	return(0);
; 2720 :     } else if (elem == NULL) {

	mov	eax, DWORD PTR _elem$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlIsID

; 2721 : 	return(0);
; 2722 :     } else {
; 2723 : 	xmlAttributePtr attrDecl = NULL;
; 2724 : 
; 2725 : 	xmlChar felem[50], fattr[50];
; 2726 : 	xmlChar *fullelemname, *fullattrname;
; 2727 : 
; 2728 : 	fullelemname = (elem->ns != NULL && elem->ns->prefix != NULL) ?

	mov	ecx, DWORD PTR [eax+36]
	test	ecx, ecx
	je	SHORT $LN21@xmlIsID
	mov	ecx, DWORD PTR [ecx+12]
	test	ecx, ecx
	je	SHORT $LN21@xmlIsID
	push	50					; 00000032H
	lea	edx, DWORD PTR _felem$1[ebp]
	push	edx
	push	ecx
	push	DWORD PTR [eax+8]
	call	_xmlBuildQName
	mov	edx, DWORD PTR [esi+36]
	add	esp, 16					; 00000010H
	mov	ebx, eax
	jmp	SHORT $LN22@xmlIsID
$LN21@xmlIsID:
	mov	ebx, DWORD PTR [eax+8]
$LN22@xmlIsID:

; 2729 : 	    xmlBuildQName(elem->name, elem->ns->prefix, felem, 50) :
; 2730 : 	    (xmlChar *)elem->name;
; 2731 : 
; 2732 : 	fullattrname = (attr->ns != NULL && attr->ns->prefix != NULL) ?

	test	edx, edx
	je	SHORT $LN23@xmlIsID
	mov	eax, DWORD PTR [edx+12]
	test	eax, eax
	je	SHORT $LN23@xmlIsID
	push	50					; 00000032H
	lea	ecx, DWORD PTR _fattr$2[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+8]
	call	_xmlBuildQName
	add	esp, 16					; 00000010H
	mov	esi, eax
	jmp	SHORT $LN24@xmlIsID
$LN23@xmlIsID:
	mov	esi, DWORD PTR [esi+8]
$LN24@xmlIsID:

; 2733 : 	    xmlBuildQName(attr->name, attr->ns->prefix, fattr, 50) :
; 2734 : 	    (xmlChar *)attr->name;
; 2735 : 
; 2736 : 	if (fullelemname != NULL && fullattrname != NULL) {

	test	ebx, ebx
	je	SHORT $LN34@xmlIsID
	test	esi, esi
	je	SHORT $LN34@xmlIsID

; 2737 : 	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullelemname,

	push	esi
	push	ebx
	push	DWORD PTR [edi+44]
	call	_xmlGetDtdAttrDesc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _attrDecl$1$[ebp], eax

; 2738 : 		                         fullattrname);
; 2739 : 	    if ((attrDecl == NULL) && (doc->extSubset != NULL))

	test	eax, eax
	jne	SHORT $LN37@xmlIsID
	mov	eax, DWORD PTR [edi+48]
	test	eax, eax
	je	SHORT $LN37@xmlIsID

; 2740 : 		attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullelemname,

	push	esi
	push	ebx
	push	eax
	call	_xmlGetDtdAttrDesc
	add	esp, 12					; 0000000cH
	mov	edi, eax
	jmp	SHORT $LN16@xmlIsID
$LN34@xmlIsID:

; 2741 : 					     fullattrname);
; 2742 : 	}
; 2743 : 
; 2744 : 	if ((fullattrname != fattr) && (fullattrname != attr->name))

	xor	edi, edi
	jmp	SHORT $LN16@xmlIsID
$LN37@xmlIsID:
	mov	edi, DWORD PTR _attrDecl$1$[ebp]
$LN16@xmlIsID:
	lea	eax, DWORD PTR _fattr$2[ebp]
	cmp	esi, eax
	je	SHORT $LN17@xmlIsID
	mov	eax, DWORD PTR _attr$[ebp]
	cmp	esi, DWORD PTR [eax+8]
	je	SHORT $LN17@xmlIsID

; 2745 : 	    xmlFree(fullattrname);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlIsID:

; 2746 : 	if ((fullelemname != felem) && (fullelemname != elem->name))

	lea	eax, DWORD PTR _felem$1[ebp]
	cmp	ebx, eax
	je	SHORT $LN18@xmlIsID
	mov	eax, DWORD PTR _elem$[ebp]
	cmp	ebx, DWORD PTR [eax+8]
	je	SHORT $LN18@xmlIsID

; 2747 : 	    xmlFree(fullelemname);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN18@xmlIsID:

; 2748 : 
; 2749 :         if ((attrDecl != NULL) && (attrDecl->atype == XML_ATTRIBUTE_ID))

	test	edi, edi
	je	$LN3@xmlIsID
	cmp	DWORD PTR [edi+40], 2
	jne	$LN3@xmlIsID
$LN25@xmlIsID:
	pop	edi

; 2750 : 	    return(1);
; 2751 :     }
; 2752 :     return(0);
; 2753 : }

	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlIsID ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlGetID
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_ID$ = 12						; size = 4
_xmlGetID PROC						; COMDAT

; 2803 : xmlGetID(xmlDocPtr doc, const xmlChar *ID) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _doc$[ebp]
	test	esi, esi
	je	SHORT $LN8@xmlGetID

; 2804 :     xmlIDTablePtr table;
; 2805 :     xmlIDPtr id;
; 2806 : 
; 2807 :     if (doc == NULL) {
; 2808 : 	return(NULL);
; 2809 :     }
; 2810 : 
; 2811 :     if (ID == NULL) {

	mov	eax, DWORD PTR _ID$[ebp]
	test	eax, eax
	je	SHORT $LN8@xmlGetID

; 2812 : 	return(NULL);
; 2813 :     }
; 2814 : 
; 2815 :     table = (xmlIDTablePtr) doc->ids;

	mov	ecx, DWORD PTR [esi+64]

; 2816 :     if (table == NULL)

	test	ecx, ecx
	je	SHORT $LN8@xmlGetID

; 2817 :         return(NULL);
; 2818 : 
; 2819 :     id = xmlHashLookup(table, ID);

	push	eax
	push	ecx
	call	_xmlHashLookup
	add	esp, 8

; 2820 :     if (id == NULL)

	test	eax, eax
	je	SHORT $LN8@xmlGetID

; 2822 :     if (id->attr == NULL) {

	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	cmove	eax, esi
	pop	esi

; 2823 : 	/*
; 2824 : 	 * We are operating on a stream, return a well known reference
; 2825 : 	 * since the attribute node doesn't exist anymore
; 2826 : 	 */
; 2827 : 	return((xmlAttrPtr) doc);
; 2828 :     }
; 2829 :     return(id->attr);
; 2830 : }

	pop	ebp
	ret	0
$LN8@xmlGetID:

; 2821 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 2823 : 	/*
; 2824 : 	 * We are operating on a stream, return a well known reference
; 2825 : 	 * since the attribute node doesn't exist anymore
; 2826 : 	 */
; 2827 : 	return((xmlAttrPtr) doc);
; 2828 :     }
; 2829 :     return(id->attr);
; 2830 : }

	pop	ebp
	ret	0
_xmlGetID ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeIDTable
_TEXT	SEGMENT
_table$ = 8						; size = 4
_xmlFreeIDTable PROC					; COMDAT

; 2686 : xmlFreeIDTable(xmlIDTablePtr table) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	OFFSET _xmlFreeIDTableEntry
	push	DWORD PTR _table$[ebp]
	call	_xmlHashFree
	add	esp, 8

; 2687 :     xmlHashFree(table, xmlFreeIDTableEntry);
; 2688 : }

	pop	ebp
	ret	0
_xmlFreeIDTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlAddID
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_table$1$ = 12						; size = 4
_doc$ = 12						; size = 4
_value$ = 16						; size = 4
_attr$ = 20						; size = 4
_xmlAddID PROC						; COMDAT

; 2603 :          xmlAttrPtr attr) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	je	SHORT $LN16@xmlAddID

; 2604 :     xmlIDPtr ret;
; 2605 :     xmlIDTablePtr table;
; 2606 : 
; 2607 :     if (doc == NULL) {
; 2608 : 	return(NULL);
; 2609 :     }
; 2610 :     if (value == NULL) {

	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN16@xmlAddID

; 2611 : 	return(NULL);
; 2612 :     }
; 2613 :     if (attr == NULL) {

	mov	ebx, DWORD PTR _attr$[ebp]
	test	ebx, ebx
	je	SHORT $LN16@xmlAddID

; 2614 : 	return(NULL);
; 2615 :     }
; 2616 : 
; 2617 :     /*
; 2618 :      * Create the ID table if needed.
; 2619 :      */
; 2620 :     table = (xmlIDTablePtr) doc->ids;

	mov	eax, DWORD PTR [edi+64]
	mov	DWORD PTR _table$1$[ebp], eax

; 2621 :     if (table == NULL)  {

	test	eax, eax
	jne	SHORT $LN6@xmlAddID

; 2622 :         doc->ids = table = xmlHashCreateDict(0, doc->dict);

	push	DWORD PTR [edi+80]
	push	eax
	call	_xmlHashCreateDict
	add	esp, 8
	mov	DWORD PTR _table$1$[ebp], eax
	mov	DWORD PTR [edi+64], eax

; 2623 :     }
; 2624 :     if (table == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlAddID

; 2625 : 	xmlVErrMemory(ctxt,

	push	OFFSET ??_C@_0CC@HPFDMDEK@xmlAddID?3?5Table?5creation?5failed@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlVErrMemory
	add	esp, 8
$LN16@xmlAddID:

; 2672 : }

	pop	edi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlAddID:
	push	esi

; 2626 : 		"xmlAddID: Table creation failed!\n");
; 2627 :         return(NULL);
; 2628 :     }
; 2629 : 
; 2630 :     ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));

	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 2631 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN7@xmlAddID

; 2632 : 	xmlVErrMemory(ctxt, "malloc failed");

	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlVErrMemory
	add	esp, 8

; 2633 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 2672 : }

	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlAddID:

; 2634 :     }
; 2635 : 
; 2636 :     /*
; 2637 :      * fill the structure.
; 2638 :      */
; 2639 :     ret->value = xmlStrdup(value);

	push	DWORD PTR _value$[ebp]
	call	_xmlStrdup
	mov	DWORD PTR [esi+4], eax
	add	esp, 4

; 2640 :     ret->doc = doc;
; 2641 :     if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [esi+20], edi
	test	eax, eax
	je	SHORT $LN8@xmlAddID
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN8@xmlAddID

; 2642 : 	/*
; 2643 : 	 * Operating in streaming mode, attr is gonna disapear
; 2644 : 	 */
; 2645 : 	if (doc->dict != NULL)

	mov	eax, DWORD PTR [edi+80]
	mov	ecx, DWORD PTR [ebx+8]
	test	eax, eax
	je	SHORT $LN10@xmlAddID

; 2646 : 	    ret->name = xmlDictLookup(doc->dict, attr->name, -1);

	push	-1
	push	ecx
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 2649 : 	ret->attr = NULL;

	mov	DWORD PTR [esi+12], eax
	xor	eax, eax

; 2650 :     } else {

	jmp	SHORT $LN9@xmlAddID
$LN10@xmlAddID:

; 2647 : 	else
; 2648 : 	    ret->name = xmlStrdup(attr->name);

	push	ecx
	call	_xmlStrdup
	add	esp, 4

; 2649 : 	ret->attr = NULL;

	mov	DWORD PTR [esi+12], eax
	xor	eax, eax

; 2650 :     } else {

	jmp	SHORT $LN9@xmlAddID
$LN8@xmlAddID:

; 2651 : 	ret->attr = attr;
; 2652 : 	ret->name = NULL;

	mov	DWORD PTR [esi+12], 0
	mov	eax, ebx
$LN9@xmlAddID:

; 2653 :     }
; 2654 :     ret->lineno = xmlGetLineNo(attr->parent);

	mov	DWORD PTR [esi+8], eax
	push	DWORD PTR [ebx+20]
	call	_xmlGetLineNo

; 2655 : 
; 2656 :     if (xmlHashAddEntry(table, value, ret) < 0) {

	mov	edi, DWORD PTR _value$[ebp]
	push	esi
	push	edi
	push	DWORD PTR _table$1$[ebp]
	mov	DWORD PTR [esi+16], eax
	call	_xmlHashAddEntry
	add	esp, 16					; 00000010H
	test	eax, eax
	jns	SHORT $LN12@xmlAddID

; 2657 : #ifdef LIBXML_VALID_ENABLED
; 2658 : 	/*
; 2659 : 	 * The id is already defined in this DTD.
; 2660 : 	 */
; 2661 : 	if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN13@xmlAddID

; 2662 : 	    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,

	push	0
	push	0
	push	edi
	push	OFFSET ??_C@_0BH@JKIFIOPN@ID?5?$CFs?5already?5defined?6@
	push	513					; 00000201H
	push	DWORD PTR [ebx+20]
	push	eax
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
$LN13@xmlAddID:

; 2663 : 			    "ID %s already defined\n", value, NULL, NULL);
; 2664 : 	}
; 2665 : #endif /* LIBXML_VALID_ENABLED */
; 2666 : 	xmlFreeID(ret);

	push	esi
	call	_xmlFreeID
	add	esp, 4
	xor	eax, eax
	pop	esi
	pop	edi

; 2672 : }

	pop	ebx
	pop	ebp
	ret	0
$LN12@xmlAddID:

; 2667 : 	return(NULL);
; 2668 :     }
; 2669 :     if (attr != NULL)
; 2670 : 	attr->atype = XML_ATTRIBUTE_ID;
; 2671 :     return(ret);

	mov	eax, esi
	mov	DWORD PTR [ebx+40], 2
	pop	esi
	pop	edi

; 2672 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlAddID ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlDumpAttributeDecl
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_attr$ = 12						; size = 4
_xmlDumpAttributeDecl PROC				; COMDAT

; 2227 : xmlDumpAttributeDecl(xmlBufferPtr buf, xmlAttributePtr attr) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	$LN7@xmlDumpAtt

; 2228 :     if ((buf == NULL) || (attr == NULL))

	push	edi
	mov	edi, DWORD PTR _attr$[ebp]
	test	edi, edi
	je	$LN43@xmlDumpAtt

; 2229 :         return;
; 2230 :     xmlBufferWriteChar(buf, "<!ATTLIST ");

	push	OFFSET ??_C@_0L@NDHICKFH@?$DM?$CBATTLIST?5@
	push	esi
	call	_xmlBufferWriteChar

; 2231 :     xmlBufferWriteCHAR(buf, attr->elem);

	push	DWORD PTR [edi+60]
	push	esi
	call	_xmlBufferWriteCHAR

; 2232 :     xmlBufferWriteChar(buf, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	esi
	call	_xmlBufferWriteChar

; 2233 :     if (attr->prefix != NULL) {

	mov	eax, DWORD PTR [edi+56]
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN8@xmlDumpAtt

; 2234 : 	xmlBufferWriteCHAR(buf, attr->prefix);

	push	eax
	push	esi
	call	_xmlBufferWriteCHAR

; 2235 : 	xmlBufferWriteChar(buf, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 16					; 00000010H
$LN8@xmlDumpAtt:

; 2236 :     }
; 2237 :     xmlBufferWriteCHAR(buf, attr->name);

	push	DWORD PTR [edi+8]
	push	esi
	call	_xmlBufferWriteCHAR

; 2238 :     switch (attr->atype) {

	mov	eax, DWORD PTR [edi+40]
	add	esp, 8
	dec	eax
	cmp	eax, 9
	ja	$LN19@xmlDumpAtt
	jmp	DWORD PTR $LN46@xmlDumpAtt[eax*4]
$LN9@xmlDumpAtt:

; 2239 : 	case XML_ATTRIBUTE_CDATA:
; 2240 : 	    xmlBufferWriteChar(buf, " CDATA");

	push	OFFSET ??_C@_06CIOOFICG@?5CDATA@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8

; 2241 : 	    break;

	jmp	$LN33@xmlDumpAtt
$LN10@xmlDumpAtt:

; 2242 : 	case XML_ATTRIBUTE_ID:
; 2243 : 	    xmlBufferWriteChar(buf, " ID");

	push	OFFSET ??_C@_03JFNHLDJD@?5ID@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8

; 2244 : 	    break;

	jmp	$LN33@xmlDumpAtt
$LN11@xmlDumpAtt:

; 2245 : 	case XML_ATTRIBUTE_IDREF:
; 2246 : 	    xmlBufferWriteChar(buf, " IDREF");

	push	OFFSET ??_C@_06JJHMNMLB@?5IDREF@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8

; 2247 : 	    break;

	jmp	$LN33@xmlDumpAtt
$LN12@xmlDumpAtt:

; 2248 : 	case XML_ATTRIBUTE_IDREFS:
; 2249 : 	    xmlBufferWriteChar(buf, " IDREFS");

	push	OFFSET ??_C@_07CNGJPBFB@?5IDREFS@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8

; 2250 : 	    break;

	jmp	$LN33@xmlDumpAtt
$LN13@xmlDumpAtt:

; 2251 : 	case XML_ATTRIBUTE_ENTITY:
; 2252 : 	    xmlBufferWriteChar(buf, " ENTITY");

	push	OFFSET ??_C@_07GLIJGNMP@?5ENTITY@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8

; 2253 : 	    break;

	jmp	$LN33@xmlDumpAtt
$LN14@xmlDumpAtt:

; 2254 : 	case XML_ATTRIBUTE_ENTITIES:
; 2255 : 	    xmlBufferWriteChar(buf, " ENTITIES");

	push	OFFSET ??_C@_09MILPKLMO@?5ENTITIES@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8

; 2256 : 	    break;

	jmp	SHORT $LN33@xmlDumpAtt
$LN15@xmlDumpAtt:

; 2257 : 	case XML_ATTRIBUTE_NMTOKEN:
; 2258 : 	    xmlBufferWriteChar(buf, " NMTOKEN");

	push	OFFSET ??_C@_08JLMONKHB@?5NMTOKEN@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8

; 2259 : 	    break;

	jmp	SHORT $LN33@xmlDumpAtt
$LN16@xmlDumpAtt:

; 2260 : 	case XML_ATTRIBUTE_NMTOKENS:
; 2261 : 	    xmlBufferWriteChar(buf, " NMTOKENS");

	push	OFFSET ??_C@_09LGAPIBOH@?5NMTOKENS@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8

; 2262 : 	    break;

	jmp	SHORT $LN33@xmlDumpAtt
$LN17@xmlDumpAtt:

; 2263 : 	case XML_ATTRIBUTE_ENUMERATION:
; 2264 : 	    xmlBufferWriteChar(buf, " (");

	push	OFFSET ??_C@_02GFKOMOKH@?5?$CI@
$LN44@xmlDumpAtt:

; 2271 : 	default:
; 2272 : 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
; 2273 : 		    "Internal: ATTRIBUTE struct corrupted invalid type\n",
; 2274 : 		    NULL);
; 2275 :     }
; 2276 :     switch (attr->def) {

	push	esi
	call	_xmlBufferWriteChar
	push	DWORD PTR [edi+52]
	push	esi
	call	_xmlDumpEnumeration
	add	esp, 16					; 00000010H
	jmp	SHORT $LN33@xmlDumpAtt
$LN18@xmlDumpAtt:

; 2265 : 	    xmlDumpEnumeration(buf, attr->tree);
; 2266 : 	    break;
; 2267 : 	case XML_ATTRIBUTE_NOTATION:
; 2268 : 	    xmlBufferWriteChar(buf, " NOTATION (");

	push	OFFSET ??_C@_0M@IGKIMAHJ@?5NOTATION?5?$CI@

; 2269 : 	    xmlDumpEnumeration(buf, attr->tree);
; 2270 : 	    break;

	jmp	SHORT $LN44@xmlDumpAtt
$LN19@xmlDumpAtt:

; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0DD@NLJCGIHL@Internal?3?5ATTRIBUTE?5struct?5corr@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1
	push	23					; 00000017H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN33@xmlDumpAtt:

; 2271 : 	default:
; 2272 : 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
; 2273 : 		    "Internal: ATTRIBUTE struct corrupted invalid type\n",
; 2274 : 		    NULL);
; 2275 :     }
; 2276 :     switch (attr->def) {

	mov	eax, DWORD PTR [edi+44]
	dec	eax
	cmp	eax, 3
	ja	SHORT $LN24@xmlDumpAtt
	jmp	DWORD PTR $LN47@xmlDumpAtt[eax*4]
$LN21@xmlDumpAtt:

; 2277 : 	case XML_ATTRIBUTE_NONE:
; 2278 : 	    break;
; 2279 : 	case XML_ATTRIBUTE_REQUIRED:
; 2280 : 	    xmlBufferWriteChar(buf, " #REQUIRED");

	push	OFFSET ??_C@_0L@IEBFJPBC@?5?$CDREQUIRED@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8

; 2281 : 	    break;

	jmp	SHORT $LN41@xmlDumpAtt
$LN22@xmlDumpAtt:

; 2282 : 	case XML_ATTRIBUTE_IMPLIED:
; 2283 : 	    xmlBufferWriteChar(buf, " #IMPLIED");

	push	OFFSET ??_C@_09GOIPIIGC@?5?$CDIMPLIED@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8

; 2284 : 	    break;

	jmp	SHORT $LN41@xmlDumpAtt
$LN23@xmlDumpAtt:

; 2285 : 	case XML_ATTRIBUTE_FIXED:
; 2286 : 	    xmlBufferWriteChar(buf, " #FIXED");

	push	OFFSET ??_C@_07PNOBFAOP@?5?$CDFIXED@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8

; 2287 : 	    break;

	jmp	SHORT $LN41@xmlDumpAtt
$LN24@xmlDumpAtt:

; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0DC@EJJFJDDL@Internal?3?5ATTRIBUTE?5struct?5corr@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1
	push	23					; 00000017H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN41@xmlDumpAtt:

; 2288 : 	default:
; 2289 : 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
; 2290 : 		    "Internal: ATTRIBUTE struct corrupted invalid def\n",
; 2291 : 		    NULL);
; 2292 :     }
; 2293 :     if (attr->defaultValue != NULL) {

	cmp	DWORD PTR [edi+48], 0
	je	SHORT $LN25@xmlDumpAtt

; 2294 : 	xmlBufferWriteChar(buf, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	esi
	call	_xmlBufferWriteChar

; 2295 : 	xmlBufferWriteQuotedString(buf, attr->defaultValue);

	push	DWORD PTR [edi+48]
	push	esi
	call	_xmlBufferWriteQuotedString
	add	esp, 16					; 00000010H
$LN25@xmlDumpAtt:

; 2296 :     }
; 2297 :     xmlBufferWriteChar(buf, ">\n");

	push	OFFSET ??_C@_02NEKEAGPN@?$DO?6@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8
$LN43@xmlDumpAtt:
	pop	edi
$LN7@xmlDumpAtt:
	pop	esi

; 2298 : }

	pop	ebp
	ret	0
	npad	3
$LN46@xmlDumpAtt:
	DD	$LN9@xmlDumpAtt
	DD	$LN10@xmlDumpAtt
	DD	$LN11@xmlDumpAtt
	DD	$LN12@xmlDumpAtt
	DD	$LN13@xmlDumpAtt
	DD	$LN14@xmlDumpAtt
	DD	$LN15@xmlDumpAtt
	DD	$LN16@xmlDumpAtt
	DD	$LN17@xmlDumpAtt
	DD	$LN18@xmlDumpAtt
$LN47@xmlDumpAtt:
	DD	$LN41@xmlDumpAtt
	DD	$LN21@xmlDumpAtt
	DD	$LN22@xmlDumpAtt
	DD	$LN23@xmlDumpAtt
_xmlDumpAttributeDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlDumpAttributeTable
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_table$ = 12						; size = 4
_xmlDumpAttributeTable PROC				; COMDAT

; 2321 : xmlDumpAttributeTable(xmlBufferPtr buf, xmlAttributeTablePtr table) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _buf$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlDumpAtt

; 2322 :     if ((buf == NULL) || (table == NULL))

	mov	eax, DWORD PTR _table$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlDumpAtt

; 2323 :         return;
; 2324 :     xmlHashScan(table, xmlDumpAttributeDeclScan, buf);

	push	ecx
	push	OFFSET _xmlDumpAttributeDeclScan
	push	eax
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN3@xmlDumpAtt:

; 2325 : }

	pop	ebp
	ret	0
_xmlDumpAttributeTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeAttributeTable
_TEXT	SEGMENT
_table$ = 8						; size = 4
_xmlFreeAttributeTable PROC				; COMDAT

; 2164 : xmlFreeAttributeTable(xmlAttributeTablePtr table) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	OFFSET _xmlFreeAttributeTableEntry
	push	DWORD PTR _table$[ebp]
	call	_xmlHashFree
	add	esp, 8

; 2165 :     xmlHashFree(table, xmlFreeAttributeTableEntry);
; 2166 : }

	pop	ebp
	ret	0
_xmlFreeAttributeTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlCopyAttributeTable
_TEXT	SEGMENT
_table$ = 8						; size = 4
_xmlCopyAttributeTable PROC				; COMDAT

; 2212 : xmlCopyAttributeTable(xmlAttributeTablePtr table) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	OFFSET _xmlCopyAttribute
	push	DWORD PTR _table$[ebp]
	call	_xmlHashCopy
	add	esp, 8

; 2213 :     return((xmlAttributeTablePtr) xmlHashCopy(table, xmlCopyAttribute));
; 2214 : }

	pop	ebp
	ret	0
_xmlCopyAttributeTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlAddAttributeDecl
_TEXT	SEGMENT
_table$1$ = -8						; size = 4
_dict$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_elemDef$1$ = 12					; size = 4
_defaultValue$1$ = 12					; size = 4
_dtd$ = 12						; size = 4
_elem$ = 16						; size = 4
_name$ = 20						; size = 4
_ns$ = 24						; size = 4
_type$ = 28						; size = 4
_def$ = 32						; size = 4
_defaultValue$ = 36					; size = 4
_tree$ = 40						; size = 4
_xmlAddAttributeDecl PROC				; COMDAT

; 1942 : 		    const xmlChar *defaultValue, xmlEnumerationPtr tree) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _dtd$[ebp]
	mov	DWORD PTR _dict$1$[ebp], 0
	test	ebx, ebx
	jne	SHORT $LN6@xmlAddAttr

; 1789 :     if (cur == NULL) return;

	mov	esi, DWORD PTR _tree$[ebp]
	test	esi, esi
	je	SHORT $LN47@xmlAddAttr

; 1790 : 
; 1791 :     if (cur->next != NULL) xmlFreeEnumeration(cur->next);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN49@xmlAddAttr
	push	eax
	call	_xmlFreeEnumeration
	add	esp, 4
$LN49@xmlAddAttr:

; 1792 : 
; 1793 :     if (cur->name != NULL) xmlFree((xmlChar *) cur->name);

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN50@xmlAddAttr
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN50@xmlAddAttr:

; 1794 :     xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN47@xmlAddAttr:
	pop	esi

; 1943 :     xmlAttributePtr ret;
; 1944 :     xmlAttributeTablePtr table;
; 1945 :     xmlElementPtr elemDef;
; 1946 :     xmlDictPtr dict = NULL;
; 1947 : 
; 1948 :     if (dtd == NULL) {
; 1949 : 	xmlFreeEnumeration(tree);
; 1950 : 	return(NULL);

	xor	eax, eax

; 2150 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlAddAttr:

; 1951 :     }
; 1952 :     if (name == NULL) {

	mov	ecx, DWORD PTR _name$[ebp]
	push	edi
	test	ecx, ecx
	je	$LN57@xmlAddAttr

; 1953 : 	xmlFreeEnumeration(tree);
; 1954 : 	return(NULL);
; 1955 :     }
; 1956 :     if (elem == NULL) {

	mov	esi, DWORD PTR _elem$[ebp]
	test	esi, esi
	je	$LN57@xmlAddAttr

; 1957 : 	xmlFreeEnumeration(tree);
; 1958 : 	return(NULL);
; 1959 :     }
; 1960 :     if (dtd->doc != NULL)

	mov	edx, DWORD PTR [ebx+32]
	test	edx, edx
	je	SHORT $LN9@xmlAddAttr

; 1961 : 	dict = dtd->doc->dict;

	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR _dict$1$[ebp], eax
$LN9@xmlAddAttr:

; 1962 : 
; 1963 : #ifdef LIBXML_VALID_ENABLED
; 1964 :     /*
; 1965 :      * Check the type and possibly the default value.
; 1966 :      */
; 1967 :     switch (type) {

	mov	eax, DWORD PTR _type$[ebp]
	dec	eax
	cmp	eax, 9
	ja	$LN20@xmlAddAttr
	movzx	eax, BYTE PTR $LN58@xmlAddAttr[eax]
	jmp	DWORD PTR $LN68@xmlAddAttr[eax*4]
$LN10@xmlAddAttr:

; 1993 : 	    return(NULL);
; 1994 :     }
; 1995 :     if ((defaultValue != NULL) &&

	mov	eax, DWORD PTR _defaultValue$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _defaultValue$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN22@xmlAddAttr
	push	eax
	push	DWORD PTR _type$[ebp]
	push	edx
	call	_xmlValidateAttributeValueInternal
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN60@xmlAddAttr

; 1996 :         (!xmlValidateAttributeValueInternal(dtd->doc, type, defaultValue))) {
; 1997 : 	xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_DEFAULT,

	mov	eax, DWORD PTR _defaultValue$1$[ebp]
	push	eax
	push	DWORD PTR _name$[ebp]
	push	esi
	push	OFFSET ??_C@_0CL@IHGCOODJ@Attribute?5?$CFs?5of?5?$CFs?3?5invalid?5def@
	push	500					; 000001f4H
	push	ebx
	push	edi
	call	_xmlErrValidNode

; 1998 : 	                "Attribute %s of %s: invalid default value\n",
; 1999 : 	                elem, name, defaultValue);
; 2000 : 	defaultValue = NULL;
; 2001 : 	if (ctxt != NULL)

	mov	ecx, DWORD PTR _name$[ebp]
	xor	eax, eax
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _defaultValue$1$[ebp], eax
	test	edi, edi
	je	SHORT $LN22@xmlAddAttr

; 2002 : 	    ctxt->valid = 0;

	mov	DWORD PTR [edi+36], eax
	jmp	SHORT $LN22@xmlAddAttr
$LN60@xmlAddAttr:

; 1993 : 	    return(NULL);
; 1994 :     }
; 1995 :     if ((defaultValue != NULL) &&

	mov	ecx, DWORD PTR _name$[ebp]
$LN22@xmlAddAttr:

; 2003 :     }
; 2004 : #endif /* LIBXML_VALID_ENABLED */
; 2005 : 
; 2006 :     /*
; 2007 :      * Check first that an attribute defined in the external subset wasn't
; 2008 :      * already defined in the internal subset
; 2009 :      */
; 2010 :     if ((dtd->doc != NULL) && (dtd->doc->extSubset == dtd) &&
; 2011 : 	(dtd->doc->intSubset != NULL) &&

	mov	eax, DWORD PTR [ebx+32]
	test	eax, eax
	je	SHORT $LN24@xmlAddAttr
	cmp	DWORD PTR [eax+48], ebx
	jne	SHORT $LN24@xmlAddAttr
	mov	eax, DWORD PTR [eax+44]
	test	eax, eax
	je	SHORT $LN24@xmlAddAttr
	mov	eax, DWORD PTR [eax+44]
	test	eax, eax
	je	SHORT $LN24@xmlAddAttr

; 2012 : 	(dtd->doc->intSubset->attributes != NULL)) {
; 2013 :         ret = xmlHashLookup3(dtd->doc->intSubset->attributes, name, ns, elem);

	push	esi
	push	DWORD PTR _ns$[ebp]
	push	ecx
	push	eax
	call	_xmlHashLookup3
	add	esp, 16					; 00000010H

; 2014 : 	if (ret != NULL) {

	test	eax, eax
	jne	$LN57@xmlAddAttr
$LN24@xmlAddAttr:

; 2017 : 	}
; 2018 :     }
; 2019 : 
; 2020 :     /*
; 2021 :      * Create the Attribute table if needed.
; 2022 :      */
; 2023 :     table = (xmlAttributeTablePtr) dtd->attributes;

	mov	eax, DWORD PTR [ebx+44]
	mov	DWORD PTR _table$1$[ebp], eax

; 2024 :     if (table == NULL) {

	test	eax, eax
	jne	SHORT $LN26@xmlAddAttr

; 2025 :         table = xmlHashCreateDict(0, dict);

	push	DWORD PTR _dict$1$[ebp]
	push	eax
	call	_xmlHashCreateDict
	add	esp, 8
	mov	DWORD PTR _table$1$[ebp], eax

; 2026 : 	dtd->attributes = (void *) table;

	mov	DWORD PTR [ebx+44], eax

; 2027 :     }
; 2028 :     if (table == NULL) {

	test	eax, eax
	jne	SHORT $LN26@xmlAddAttr

; 2029 : 	xmlVErrMemory(ctxt,

	push	OFFSET ??_C@_0CN@LFDBMMCB@xmlAddAttributeDecl?3?5Table?5crea@
$LN66@xmlAddAttr:

; 2016 : 	    return(NULL);

	push	edi
	call	_xmlVErrMemory
	push	DWORD PTR _tree$[ebp]
	call	_xmlFreeEnumeration
	add	esp, 12					; 0000000cH
	xor	eax, eax
	pop	edi
	pop	esi

; 2150 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlAddAttr:

; 2030 :             "xmlAddAttributeDecl: Table creation failed!\n");
; 2031 : 	xmlFreeEnumeration(tree);
; 2032 :         return(NULL);
; 2033 :     }
; 2034 : 
; 2035 : 
; 2036 :     ret = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));

	push	64					; 00000040H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 2037 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN27@xmlAddAttr

; 2038 : 	xmlVErrMemory(ctxt, "malloc failed");

	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@

; 2039 : 	xmlFreeEnumeration(tree);
; 2040 : 	return(NULL);

	jmp	SHORT $LN66@xmlAddAttr
$LN27@xmlAddAttr:

; 2041 :     }
; 2042 :     memset(ret, 0, sizeof(xmlAttribute));

	push	64					; 00000040H
	push	0
	push	esi
	call	_memset

; 2043 :     ret->type = XML_ATTRIBUTE_DECL;
; 2044 : 
; 2045 :     /*
; 2046 :      * fill the structure.
; 2047 :      */
; 2048 :     ret->atype = type;

	mov	eax, DWORD PTR _type$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+4], 16			; 00000010H

; 2049 :     /*
; 2050 :      * doc must be set before possible error causes call
; 2051 :      * to xmlFreeAttribute (because it's used to check on
; 2052 :      * dict use)
; 2053 :      */
; 2054 :     ret->doc = dtd->doc;

	mov	eax, DWORD PTR [ebx+32]
	mov	DWORD PTR [esi+32], eax

; 2055 :     if (dict) {

	mov	eax, DWORD PTR _dict$1$[ebp]
	test	eax, eax
	je	SHORT $LN28@xmlAddAttr

; 2056 : 	ret->name = xmlDictLookup(dict, name, -1);

	push	-1
	push	DWORD PTR _name$[ebp]
	push	eax
	call	_xmlDictLookup
	mov	DWORD PTR [esi+8], eax

; 2057 : 	ret->prefix = xmlDictLookup(dict, ns, -1);

	mov	eax, DWORD PTR _ns$[ebp]
	push	-1
	push	eax
	push	DWORD PTR _dict$1$[ebp]
	call	_xmlDictLookup

; 2058 : 	ret->elem = xmlDictLookup(dict, elem, -1);

	push	-1
	push	DWORD PTR _elem$[ebp]
	mov	DWORD PTR [esi+56], eax
	push	DWORD PTR _dict$1$[ebp]
	call	_xmlDictLookup
	add	esp, 36					; 00000024H

; 2059 :     } else {

	jmp	SHORT $LN29@xmlAddAttr
$LN28@xmlAddAttr:

; 2060 : 	ret->name = xmlStrdup(name);

	push	DWORD PTR _name$[ebp]
	call	_xmlStrdup
	mov	DWORD PTR [esi+8], eax

; 2061 : 	ret->prefix = xmlStrdup(ns);

	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	call	_xmlStrdup

; 2062 : 	ret->elem = xmlStrdup(elem);

	push	DWORD PTR _elem$[ebp]
	mov	DWORD PTR [esi+56], eax
	call	_xmlStrdup
	add	esp, 12					; 0000000cH
$LN29@xmlAddAttr:

; 2063 :     }
; 2064 :     ret->def = def;

	mov	DWORD PTR [esi+60], eax
	mov	eax, DWORD PTR _def$[ebp]
	mov	DWORD PTR [esi+44], eax

; 2065 :     ret->tree = tree;

	mov	eax, DWORD PTR _tree$[ebp]
	mov	DWORD PTR [esi+52], eax

; 2066 :     if (defaultValue != NULL) {

	mov	eax, DWORD PTR _defaultValue$1$[ebp]
	test	eax, eax
	je	SHORT $LN32@xmlAddAttr

; 2067 :         if (dict)

	mov	ecx, DWORD PTR _dict$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN31@xmlAddAttr

; 2068 : 	    ret->defaultValue = xmlDictLookup(dict, defaultValue, -1);

	push	-1
	push	eax
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN64@xmlAddAttr
$LN31@xmlAddAttr:

; 2069 : 	else
; 2070 : 	    ret->defaultValue = xmlStrdup(defaultValue);

	push	eax
	call	_xmlStrdup
	add	esp, 4
$LN64@xmlAddAttr:

; 2071 :     }
; 2072 : 
; 2073 :     /*
; 2074 :      * Validity Check:
; 2075 :      * Search the DTD for previous declarations of the ATTLIST
; 2076 :      */
; 2077 :     if (xmlHashAddEntry3(table, ret->name, ret->prefix, ret->elem, ret) < 0) {

	mov	DWORD PTR [esi+48], eax
$LN32@xmlAddAttr:
	push	esi
	push	DWORD PTR [esi+60]
	push	DWORD PTR [esi+56]
	push	DWORD PTR [esi+8]
	push	DWORD PTR _table$1$[ebp]
	call	_xmlHashAddEntry3
	add	esp, 20					; 00000014H
	test	eax, eax
	jns	SHORT $LN33@xmlAddAttr

; 2078 : #ifdef LIBXML_VALID_ENABLED
; 2079 : 	/*
; 2080 : 	 * The attribute is already defined in this DTD.
; 2081 : 	 */
; 2082 : 	xmlErrValidWarning(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_REDEFINED,

	push	0
	push	DWORD PTR _elem$[ebp]
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0CN@HJBCFPNE@Attribute?5?$CFs?5of?5element?5?$CFs?3?5alr@
	push	501					; 000001f5H
	push	ebx
	push	edi
	call	_xmlErrValidWarning

; 2083 : 		 "Attribute %s of element %s: already defined\n",
; 2084 : 		 name, elem, NULL);
; 2085 : #endif /* LIBXML_VALID_ENABLED */
; 2086 : 	xmlFreeAttribute(ret);

	push	esi
	call	_xmlFreeAttribute
	add	esp, 32					; 00000020H
	xor	eax, eax
	pop	edi
	pop	esi

; 2150 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@xmlAddAttr:

; 2087 : 	return(NULL);
; 2088 :     }
; 2089 : 
; 2090 :     /*
; 2091 :      * Validity Check:
; 2092 :      * Multiple ID per element
; 2093 :      */
; 2094 :     elemDef = xmlGetDtdElementDesc2(dtd, elem, 1);

	push	1
	push	DWORD PTR _elem$[ebp]
	push	ebx
	call	_xmlGetDtdElementDesc2
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _elemDef$1$[ebp], eax

; 2095 :     if (elemDef != NULL) {

	test	eax, eax
	je	$LN43@xmlAddAttr

; 2096 : 
; 2097 : #ifdef LIBXML_VALID_ENABLED
; 2098 :         if ((type == XML_ATTRIBUTE_ID) &&

	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN36@xmlAddAttr
	push	1
	push	eax
	push	0
	call	_xmlScanIDAttributeDecl
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN36@xmlAddAttr

; 2099 : 	    (xmlScanIDAttributeDecl(NULL, elemDef, 1) != 0)) {
; 2100 : 	    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_MULTIPLE_ID,

	push	0
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _elem$[ebp]
	push	OFFSET ??_C@_0DD@GEPJIIIF@Element?5?$CFs?5has?5too?5may?5ID?5attri@
	push	520					; 00000208H
	push	ebx
	push	edi
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH

; 2101 : 	   "Element %s has too may ID attributes defined : %s\n",
; 2102 : 		   elem, name, NULL);
; 2103 : 	    if (ctxt != NULL)

	test	edi, edi
	je	SHORT $LN36@xmlAddAttr

; 2104 : 		ctxt->valid = 0;

	mov	DWORD PTR [edi+36], 0
$LN36@xmlAddAttr:

; 2105 : 	}
; 2106 : #endif /* LIBXML_VALID_ENABLED */
; 2107 : 
; 2108 : 	/*
; 2109 : 	 * Insert namespace default def first they need to be
; 2110 : 	 * processed first.
; 2111 : 	 */
; 2112 : 	if ((xmlStrEqual(ret->name, BAD_CAST "xmlns")) ||

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN39@xmlAddAttr
	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN37@xmlAddAttr
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN39@xmlAddAttr
$LN37@xmlAddAttr:

; 2116 : 	    elemDef->attributes = ret;
; 2117 : 	} else {
; 2118 : 	    xmlAttributePtr tmp = elemDef->attributes;

	mov	ecx, DWORD PTR _elemDef$1$[ebp]
	mov	edi, DWORD PTR [ecx+44]

; 2119 : 
; 2120 : 	    while ((tmp != NULL) &&

	test	edi, edi
	je	SHORT $LN42@xmlAddAttr
$LL4@xmlAddAttr:
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN40@xmlAddAttr
	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN59@xmlAddAttr
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN59@xmlAddAttr
$LN40@xmlAddAttr:

; 2121 : 		   ((xmlStrEqual(tmp->name, BAD_CAST "xmlns")) ||
; 2122 : 		    ((ret->prefix != NULL &&
; 2123 : 		     (xmlStrEqual(ret->prefix, BAD_CAST "xmlns")))))) {
; 2124 : 		if (tmp->nexth == NULL)

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN59@xmlAddAttr

; 2125 : 		    break;
; 2126 : 		tmp = tmp->nexth;

	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL4@xmlAddAttr
$LN59@xmlAddAttr:
	mov	ecx, DWORD PTR _elemDef$1$[ebp]

; 2127 : 	    }
; 2128 : 	    if (tmp != NULL) {

	test	edi, edi
	je	SHORT $LN42@xmlAddAttr

; 2129 : 		ret->nexth = tmp->nexth;

	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [esi+36], eax

; 2130 : 	        tmp->nexth = ret;

	mov	DWORD PTR [edi+36], esi

; 2131 : 	    } else {

	jmp	SHORT $LN43@xmlAddAttr
$LN39@xmlAddAttr:

; 2113 : 	    ((ret->prefix != NULL &&
; 2114 : 	     (xmlStrEqual(ret->prefix, BAD_CAST "xmlns"))))) {
; 2115 : 	    ret->nexth = elemDef->attributes;

	mov	ecx, DWORD PTR _elemDef$1$[ebp]
$LN42@xmlAddAttr:

; 2132 : 		ret->nexth = elemDef->attributes;
; 2133 : 		elemDef->attributes = ret;
; 2134 : 	    }
; 2135 : 	}
; 2136 :     }
; 2137 : 
; 2138 :     /*
; 2139 :      * Link it to the DTD
; 2140 :      */
; 2141 :     ret->parent = dtd;

	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [ecx+44], esi
$LN43@xmlAddAttr:
	mov	DWORD PTR [esi+20], ebx

; 2142 :     if (dtd->last == NULL) {

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	jne	SHORT $LN44@xmlAddAttr

; 2143 : 	dtd->children = dtd->last = (xmlNodePtr) ret;

	mov	DWORD PTR [ebx+12], esi

; 2147 : 	dtd->last = (xmlNodePtr) ret;
; 2148 :     }
; 2149 :     return(ret);

	mov	eax, esi
	pop	edi
	mov	DWORD PTR [ebx+16], esi
	pop	esi

; 2150 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@xmlAddAttr:

; 2144 :     } else {
; 2145 :         dtd->last->next = (xmlNodePtr) ret;

	mov	DWORD PTR [eax+24], esi

; 2146 : 	ret->prev = dtd->last;

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR [esi+28], eax

; 2147 : 	dtd->last = (xmlNodePtr) ret;
; 2148 :     }
; 2149 :     return(ret);

	mov	eax, esi
	pop	edi
	mov	DWORD PTR [ebx+16], esi
	pop	esi

; 2150 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlAddAttr:

; 1968 :         case XML_ATTRIBUTE_CDATA:
; 1969 : 	    break;
; 1970 :         case XML_ATTRIBUTE_ID:
; 1971 : 	    break;
; 1972 :         case XML_ATTRIBUTE_IDREF:
; 1973 : 	    break;
; 1974 :         case XML_ATTRIBUTE_IDREFS:
; 1975 : 	    break;
; 1976 :         case XML_ATTRIBUTE_ENTITY:
; 1977 : 	    break;
; 1978 :         case XML_ATTRIBUTE_ENTITIES:
; 1979 : 	    break;
; 1980 :         case XML_ATTRIBUTE_NMTOKEN:
; 1981 : 	    break;
; 1982 :         case XML_ATTRIBUTE_NMTOKENS:
; 1983 : 	    break;
; 1984 :         case XML_ATTRIBUTE_ENUMERATION:
; 1985 : 	    break;
; 1986 :         case XML_ATTRIBUTE_NOTATION:
; 1987 : 	    break;
; 1988 : 	default:
; 1989 : 	    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,

	push	0
	push	OFFSET ??_C@_0DD@NLJCGIHL@Internal?3?5ATTRIBUTE?5struct?5corr@
	push	1
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValid

; 1990 : 		    "Internal: ATTRIBUTE struct corrupted invalid type\n",
; 1991 : 		    NULL);
; 1992 : 	    xmlFreeEnumeration(tree);

	push	DWORD PTR _tree$[ebp]
	call	_xmlFreeEnumeration
	add	esp, 20					; 00000014H

; 2016 : 	    return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 2150 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN57@xmlAddAttr:

; 2015 : 	    xmlFreeEnumeration(tree);

	push	DWORD PTR _tree$[ebp]
	call	_xmlFreeEnumeration
	add	esp, 4

; 2016 : 	    return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 2150 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN68@xmlAddAttr:
	DD	$LN10@xmlAddAttr
$LN58@xmlAddAttr:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
_xmlAddAttributeDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlCopyEnumeration
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlCopyEnumeration PROC				; COMDAT

; 1808 : xmlCopyEnumeration(xmlEnumerationPtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN7@xmlCopyEnu

; 1809 :     xmlEnumerationPtr ret;
; 1810 : 
; 1811 :     if (cur == NULL) return(NULL);
; 1812 :     ret = xmlCreateEnumeration((xmlChar *) cur->name);

	push	DWORD PTR [esi+4]
	call	_xmlCreateEnumeration
	mov	edi, eax
	add	esp, 4

; 1813 :     if (ret == NULL) return(NULL);

	test	edi, edi
	je	SHORT $LN7@xmlCopyEnu

; 1814 : 
; 1815 :     if (cur->next != NULL) ret->next = xmlCopyEnumeration(cur->next);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@xmlCopyEnu
	push	eax
	call	_xmlCopyEnumeration
	add	esp, 4

; 1817 : 
; 1818 :     return(ret);

	mov	DWORD PTR [edi], eax
	mov	eax, edi
	pop	edi

; 1819 : }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlCopyEnu:

; 1816 :     else ret->next = NULL;

	xor	eax, eax

; 1817 : 
; 1818 :     return(ret);

	mov	DWORD PTR [edi], eax
	mov	eax, edi
	pop	edi

; 1819 : }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlCopyEnu:
	pop	edi

; 1813 :     if (ret == NULL) return(NULL);

	xor	eax, eax

; 1819 : }

	pop	esi
	pop	ebp
	ret	0
_xmlCopyEnumeration ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeEnumeration
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlFreeEnumeration PROC				; COMDAT

; 1788 : xmlFreeEnumeration(xmlEnumerationPtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlFreeEnu

; 1789 :     if (cur == NULL) return;
; 1790 : 
; 1791 :     if (cur->next != NULL) xmlFreeEnumeration(cur->next);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@xmlFreeEnu
	push	eax
	call	_xmlFreeEnumeration
	add	esp, 4
$LN3@xmlFreeEnu:

; 1792 : 
; 1793 :     if (cur->name != NULL) xmlFree((xmlChar *) cur->name);

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@xmlFreeEnu
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlFreeEnu:

; 1794 :     xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreeEnu:
	pop	esi

; 1795 : }

	pop	ebp
	ret	0
_xmlFreeEnumeration ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlCreateEnumeration
_TEXT	SEGMENT
_name$ = 8						; size = 4
_xmlCreateEnumeration PROC				; COMDAT

; 1766 : xmlCreateEnumeration(const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	8
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlCreateE

; 77   :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	eax
	push	eax
	push	3
	push	2
	push	23					; 00000017H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1767 :     xmlEnumerationPtr ret;
; 1768 : 
; 1769 :     ret = (xmlEnumerationPtr) xmlMalloc(sizeof(xmlEnumeration));
; 1770 :     if (ret == NULL) {
; 1771 : 	xmlVErrMemory(NULL, "malloc failed");
; 1772 :         return(NULL);

	xor	eax, eax
	pop	esi

; 1779 : }

	pop	ebp
	ret	0
$LN2@xmlCreateE:

; 1773 :     }
; 1774 :     memset(ret, 0, sizeof(xmlEnumeration));
; 1775 : 
; 1776 :     if (name != NULL)

	mov	eax, DWORD PTR _name$[ebp]
	xorps	xmm0, xmm0
	movq	QWORD PTR [esi], xmm0
	test	eax, eax
	je	SHORT $LN3@xmlCreateE

; 1777 :         ret->name = xmlStrdup(name);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
$LN3@xmlCreateE:

; 1778 :     return(ret);

	mov	eax, esi
	pop	esi

; 1779 : }

	pop	ebp
	ret	0
_xmlCreateEnumeration ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlDumpElementDecl
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_elem$ = 12						; size = 4
_xmlDumpElementDecl PROC				; COMDAT

; 1676 : xmlDumpElementDecl(xmlBufferPtr buf, xmlElementPtr elem) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	$LN5@xmlDumpEle

; 1677 :     if ((buf == NULL) || (elem == NULL))

	push	edi
	mov	edi, DWORD PTR _elem$[ebp]
	test	edi, edi
	je	$LN24@xmlDumpEle

; 1678 :         return;
; 1679 :     switch (elem->etype) {

	mov	eax, DWORD PTR [edi+36]
	dec	eax
	cmp	eax, 3
	ja	$LN14@xmlDumpEle
	jmp	DWORD PTR $LN28@xmlDumpEle[eax*4]
$LN6@xmlDumpEle:

; 1680 : 	case XML_ELEMENT_TYPE_EMPTY:
; 1681 : 	    xmlBufferWriteChar(buf, "<!ELEMENT ");

	push	OFFSET ??_C@_0L@EMLMHHFJ@?$DM?$CBELEMENT?5@
	push	esi
	call	_xmlBufferWriteChar

; 1682 : 	    if (elem->prefix != NULL) {

	mov	eax, DWORD PTR [edi+48]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@xmlDumpEle

; 1683 : 		xmlBufferWriteCHAR(buf, elem->prefix);

	push	eax
	push	esi
	call	_xmlBufferWriteCHAR

; 1684 : 		xmlBufferWriteChar(buf, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 16					; 00000010H
$LN7@xmlDumpEle:

; 1685 : 	    }
; 1686 : 	    xmlBufferWriteCHAR(buf, elem->name);

	push	DWORD PTR [edi+8]
	push	esi
	call	_xmlBufferWriteCHAR

; 1687 : 	    xmlBufferWriteChar(buf, " EMPTY>\n");

	push	OFFSET ??_C@_08HMKELAAG@?5EMPTY?$DO?6@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi

; 1719 : 	    break;
; 1720 : 	default:
; 1721 : 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
; 1722 : 		    "Internal: ELEMENT struct corrupted invalid type\n",
; 1723 : 		    NULL);
; 1724 :     }
; 1725 : }

	pop	ebp
	ret	0
$LN8@xmlDumpEle:

; 1688 : 	    break;
; 1689 : 	case XML_ELEMENT_TYPE_ANY:
; 1690 : 	    xmlBufferWriteChar(buf, "<!ELEMENT ");

	push	OFFSET ??_C@_0L@EMLMHHFJ@?$DM?$CBELEMENT?5@
	push	esi
	call	_xmlBufferWriteChar

; 1691 : 	    if (elem->prefix != NULL) {

	mov	eax, DWORD PTR [edi+48]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlDumpEle

; 1692 : 		xmlBufferWriteCHAR(buf, elem->prefix);

	push	eax
	push	esi
	call	_xmlBufferWriteCHAR

; 1693 : 		xmlBufferWriteChar(buf, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 16					; 00000010H
$LN9@xmlDumpEle:

; 1694 : 	    }
; 1695 : 	    xmlBufferWriteCHAR(buf, elem->name);

	push	DWORD PTR [edi+8]
	push	esi
	call	_xmlBufferWriteCHAR

; 1696 : 	    xmlBufferWriteChar(buf, " ANY>\n");

	push	OFFSET ??_C@_06OMPGEGME@?5ANY?$DO?6@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi

; 1719 : 	    break;
; 1720 : 	default:
; 1721 : 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
; 1722 : 		    "Internal: ELEMENT struct corrupted invalid type\n",
; 1723 : 		    NULL);
; 1724 :     }
; 1725 : }

	pop	ebp
	ret	0
$LN12@xmlDumpEle:

; 1697 : 	    break;
; 1698 : 	case XML_ELEMENT_TYPE_MIXED:
; 1699 : 	    xmlBufferWriteChar(buf, "<!ELEMENT ");
; 1700 : 	    if (elem->prefix != NULL) {
; 1701 : 		xmlBufferWriteCHAR(buf, elem->prefix);
; 1702 : 		xmlBufferWriteChar(buf, ":");
; 1703 : 	    }
; 1704 : 	    xmlBufferWriteCHAR(buf, elem->name);
; 1705 : 	    xmlBufferWriteChar(buf, " ");
; 1706 : 	    xmlDumpElementContent(buf, elem->content, 1);
; 1707 : 	    xmlBufferWriteChar(buf, ">\n");
; 1708 : 	    break;
; 1709 : 	case XML_ELEMENT_TYPE_ELEMENT:
; 1710 : 	    xmlBufferWriteChar(buf, "<!ELEMENT ");
; 1711 : 	    if (elem->prefix != NULL) {
; 1712 : 		xmlBufferWriteCHAR(buf, elem->prefix);

	push	OFFSET ??_C@_0L@EMLMHHFJ@?$DM?$CBELEMENT?5@
	push	esi
	call	_xmlBufferWriteChar
	mov	eax, DWORD PTR [edi+48]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlDumpEle
	push	eax
	push	esi
	call	_xmlBufferWriteCHAR

; 1713 : 		xmlBufferWriteChar(buf, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 16					; 00000010H
$LN13@xmlDumpEle:

; 1714 : 	    }
; 1715 : 	    xmlBufferWriteCHAR(buf, elem->name);

	push	DWORD PTR [edi+8]
	push	esi
	call	_xmlBufferWriteCHAR

; 1716 : 	    xmlBufferWriteChar(buf, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	esi
	call	_xmlBufferWriteChar

; 1717 : 	    xmlDumpElementContent(buf, elem->content, 1);

	push	1
	push	DWORD PTR [edi+40]
	push	esi
	call	_xmlDumpElementContent

; 1718 : 	    xmlBufferWriteChar(buf, ">\n");

	push	OFFSET ??_C@_02NEKEAGPN@?$DO?6@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 36					; 00000024H
	pop	edi
	pop	esi

; 1719 : 	    break;
; 1720 : 	default:
; 1721 : 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
; 1722 : 		    "Internal: ELEMENT struct corrupted invalid type\n",
; 1723 : 		    NULL);
; 1724 :     }
; 1725 : }

	pop	ebp
	ret	0
$LN14@xmlDumpEle:

; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0DB@NFLGBMMC@Internal?3?5ELEMENT?5struct?5corrup@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1
	push	23					; 00000017H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN24@xmlDumpEle:
	pop	edi
$LN5@xmlDumpEle:
	pop	esi

; 1719 : 	    break;
; 1720 : 	default:
; 1721 : 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
; 1722 : 		    "Internal: ELEMENT struct corrupted invalid type\n",
; 1723 : 		    NULL);
; 1724 :     }
; 1725 : }

	pop	ebp
	ret	0
	npad	2
$LN28@xmlDumpEle:
	DD	$LN6@xmlDumpEle
	DD	$LN8@xmlDumpEle
	DD	$LN12@xmlDumpEle
	DD	$LN12@xmlDumpEle
_xmlDumpElementDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlDumpElementTable
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_table$ = 12						; size = 4
_xmlDumpElementTable PROC				; COMDAT

; 1749 : xmlDumpElementTable(xmlBufferPtr buf, xmlElementTablePtr table) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _buf$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlDumpEle

; 1750 :     if ((buf == NULL) || (table == NULL))

	mov	eax, DWORD PTR _table$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlDumpEle

; 1751 :         return;
; 1752 :     xmlHashScan(table, xmlDumpElementDeclScan, buf);

	push	ecx
	push	OFFSET _xmlDumpElementDeclScan
	push	eax
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN3@xmlDumpEle:

; 1753 : }

	pop	ebp
	ret	0
_xmlDumpElementTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeElementTable
_TEXT	SEGMENT
_table$ = 8						; size = 4
_xmlFreeElementTable PROC				; COMDAT

; 1612 : xmlFreeElementTable(xmlElementTablePtr table) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	OFFSET _xmlFreeElementTableEntry
	push	DWORD PTR _table$[ebp]
	call	_xmlHashFree
	add	esp, 8

; 1613 :     xmlHashFree(table, xmlFreeElementTableEntry);
; 1614 : }

	pop	ebp
	ret	0
_xmlFreeElementTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlCopyElementTable
_TEXT	SEGMENT
_table$ = 8						; size = 4
_xmlCopyElementTable PROC				; COMDAT

; 1661 : xmlCopyElementTable(xmlElementTablePtr table) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	OFFSET _xmlCopyElement
	push	DWORD PTR _table$[ebp]
	call	_xmlHashCopy
	add	esp, 8

; 1662 :     return((xmlElementTablePtr) xmlHashCopy(table, xmlCopyElement));
; 1663 : }

	pop	ebp
	ret	0
_xmlCopyElementTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlAddElementDecl
_TEXT	SEGMENT
_ret$1$ = -12						; size = 4
_oldAttributes$1$ = -8					; size = 4
_ns$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_table$1$ = 12						; size = 4
_dtd$ = 12						; size = 4
_name$ = 16						; size = 4
_type$ = 20						; size = 4
_content$ = 24						; size = 4
_xmlAddElementDecl PROC					; COMDAT

; 1390 : 		  xmlElementContentPtr content) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _dtd$[ebp]
	mov	DWORD PTR _oldAttributes$1$[ebp], 0
	test	ebx, ebx
	je	$LN36@xmlAddElem

; 1391 :     xmlElementPtr ret;
; 1392 :     xmlElementTablePtr table;
; 1393 :     xmlAttributePtr oldAttributes = NULL;
; 1394 :     xmlChar *ns, *uqname;
; 1395 : 
; 1396 :     if (dtd == NULL) {
; 1397 : 	return(NULL);
; 1398 :     }
; 1399 :     if (name == NULL) {

	mov	esi, DWORD PTR _name$[ebp]
	test	esi, esi
	je	$LN36@xmlAddElem

; 1400 : 	return(NULL);
; 1401 :     }
; 1402 : 
; 1403 :     switch (type) {

	mov	eax, DWORD PTR _type$[ebp]
	dec	eax
	cmp	eax, 3
	ja	$LN14@xmlAddElem
	jmp	DWORD PTR $LN59@xmlAddElem[eax*4]
$LN6@xmlAddElem:

; 1404 :         case XML_ELEMENT_TYPE_EMPTY:
; 1405 : 	    if (content != NULL) {

	cmp	DWORD PTR _content$[ebp], 0
	je	$LN13@xmlAddElem

; 1406 : 		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,

	push	0
	push	OFFSET ??_C@_0CO@BLBNCGCL@xmlAddElementDecl?3?5content?5?$CB?$DN?5N@
	push	1
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValid
	add	esp, 16					; 00000010H

; 1598 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlAddElem:

; 1407 : 		        "xmlAddElementDecl: content != NULL for EMPTY\n",
; 1408 : 			NULL);
; 1409 : 		return(NULL);
; 1410 : 	    }
; 1411 : 	    break;
; 1412 : 	case XML_ELEMENT_TYPE_ANY:
; 1413 : 	    if (content != NULL) {

	cmp	DWORD PTR _content$[ebp], 0
	je	SHORT $LN13@xmlAddElem

; 1414 : 		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,

	push	0
	push	OFFSET ??_C@_0CM@DBFKJMHA@xmlAddElementDecl?3?5content?5?$CB?$DN?5N@
	push	1
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValid
	add	esp, 16					; 00000010H

; 1598 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlAddElem:

; 1415 : 		        "xmlAddElementDecl: content != NULL for ANY\n",
; 1416 : 			NULL);
; 1417 : 		return(NULL);
; 1418 : 	    }
; 1419 : 	    break;
; 1420 : 	case XML_ELEMENT_TYPE_MIXED:
; 1421 : 	    if (content == NULL) {

	cmp	DWORD PTR _content$[ebp], 0
	jne	SHORT $LN13@xmlAddElem

; 1422 : 		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,

	push	0
	push	OFFSET ??_C@_0CO@IMMDEKCP@xmlAddElementDecl?3?5content?5?$DN?$DN?5N@
	push	1
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValid
	add	esp, 16					; 00000010H

; 1598 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlAddElem:

; 1423 : 		        "xmlAddElementDecl: content == NULL for MIXED\n",
; 1424 : 			NULL);
; 1425 : 		return(NULL);
; 1426 : 	    }
; 1427 : 	    break;
; 1428 : 	case XML_ELEMENT_TYPE_ELEMENT:
; 1429 : 	    if (content == NULL) {

	cmp	DWORD PTR _content$[ebp], 0
	jne	SHORT $LN13@xmlAddElem

; 1430 : 		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,

	push	0
	push	OFFSET ??_C@_0DA@CFDLEHAD@xmlAddElementDecl?3?5content?5?$DN?$DN?5N@
	push	1
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValid
	add	esp, 16					; 00000010H

; 1598 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlAddElem:

; 1431 : 		        "xmlAddElementDecl: content == NULL for ELEMENT\n",
; 1432 : 			NULL);
; 1433 : 		return(NULL);
; 1434 : 	    }
; 1435 : 	    break;
; 1436 : 	default:
; 1437 : 	    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
; 1438 : 		    "Internal: ELEMENT decl corrupted invalid type\n",
; 1439 : 		    NULL);
; 1440 : 	    return(NULL);
; 1441 :     }
; 1442 : 
; 1443 :     /*
; 1444 :      * check if name is a QName
; 1445 :      */
; 1446 :     uqname = xmlSplitQName2(name, &ns);

	lea	eax, DWORD PTR _ns$[ebp]
	push	eax
	push	esi
	call	_xmlSplitQName2
	mov	edi, eax
	add	esp, 8

; 1447 :     if (uqname != NULL)
; 1448 : 	name = uqname;
; 1449 : 
; 1450 :     /*
; 1451 :      * Create the Element table if needed.
; 1452 :      */
; 1453 :     table = (xmlElementTablePtr) dtd->elements;

	mov	eax, DWORD PTR [ebx+40]
	test	edi, edi
	mov	DWORD PTR _table$1$[ebp], eax
	cmovne	esi, edi
	mov	DWORD PTR _name$[ebp], esi

; 1454 :     if (table == NULL) {

	test	eax, eax
	jne	SHORT $LN18@xmlAddElem

; 1455 : 	xmlDictPtr dict = NULL;
; 1456 : 
; 1457 : 	if (dtd->doc != NULL)

	mov	eax, DWORD PTR [ebx+32]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN17@xmlAddElem

; 1458 : 	    dict = dtd->doc->dict;

	mov	ecx, DWORD PTR [eax+80]
$LN17@xmlAddElem:

; 1459 :         table = xmlHashCreateDict(0, dict);

	push	ecx
	push	0
	call	_xmlHashCreateDict
	add	esp, 8
	mov	DWORD PTR _table$1$[ebp], eax

; 1460 : 	dtd->elements = (void *) table;

	mov	DWORD PTR [ebx+40], eax

; 1461 :     }
; 1462 :     if (table == NULL) {

	test	eax, eax
	jne	SHORT $LN18@xmlAddElem

; 1463 : 	xmlVErrMemory(ctxt,

	push	OFFSET ??_C@_0CL@IICJECDN@xmlAddElementDecl?3?5Table?5creati@
	jmp	$LN56@xmlAddElem
$LN18@xmlAddElem:

; 1464 :             "xmlAddElementDecl: Table creation failed!\n");
; 1465 : 	if (uqname != NULL)
; 1466 : 	    xmlFree(uqname);
; 1467 : 	if (ns != NULL)
; 1468 : 	    xmlFree(ns);
; 1469 :         return(NULL);
; 1470 :     }
; 1471 : 
; 1472 :     /*
; 1473 :      * lookup old attributes inserted on an undefined element in the
; 1474 :      * internal subset.
; 1475 :      */
; 1476 :     if ((dtd->doc != NULL) && (dtd->doc->intSubset != NULL)) {

	mov	eax, DWORD PTR [ebx+32]
	test	eax, eax
	je	SHORT $LN22@xmlAddElem
	mov	eax, DWORD PTR [eax+44]
	test	eax, eax
	je	SHORT $LN22@xmlAddElem

; 1477 : 	ret = xmlHashLookup2(dtd->doc->intSubset->elements, name, ns);

	push	DWORD PTR _ns$[ebp]
	push	esi
	push	DWORD PTR [eax+40]
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$1$[ebp], eax

; 1478 : 	if ((ret != NULL) && (ret->etype == XML_ELEMENT_TYPE_UNDEFINED)) {

	test	eax, eax
	je	SHORT $LN22@xmlAddElem
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN22@xmlAddElem

; 1479 : 	    oldAttributes = ret->attributes;

	mov	ecx, DWORD PTR [eax+44]

; 1480 : 	    ret->attributes = NULL;

	mov	DWORD PTR [eax+44], 0

; 1481 : 	    xmlHashRemoveEntry2(dtd->doc->intSubset->elements, name, ns, NULL);

	mov	eax, DWORD PTR [ebx+32]
	push	0
	push	DWORD PTR _ns$[ebp]
	mov	DWORD PTR _oldAttributes$1$[ebp], ecx
	mov	eax, DWORD PTR [eax+44]
	push	esi
	push	DWORD PTR [eax+40]
	call	_xmlHashRemoveEntry2

; 1482 : 	    xmlFreeElement(ret);

	push	DWORD PTR _ret$1$[ebp]
	call	_xmlFreeElement
	add	esp, 20					; 00000014H
$LN22@xmlAddElem:

; 1483 : 	}
; 1484 :     }
; 1485 : 
; 1486 :     /*
; 1487 :      * The element may already be present if one of its attribute
; 1488 :      * was registered first
; 1489 :      */
; 1490 :     ret = xmlHashLookup2(table, name, ns);

	push	DWORD PTR _ns$[ebp]
	push	esi
	push	DWORD PTR _table$1$[ebp]
	call	_xmlHashLookup2
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 1491 :     if (ret != NULL) {

	test	esi, esi
	je	SHORT $LN23@xmlAddElem

; 1492 : 	if (ret->etype != XML_ELEMENT_TYPE_UNDEFINED) {

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN25@xmlAddElem

; 1493 : #ifdef LIBXML_VALID_ENABLED
; 1494 : 	    /*
; 1495 : 	     * The element is already defined in this DTD.
; 1496 : 	     */
; 1497 : 	    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,

	push	0
	push	0
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0BM@DLJMKEJ@Redefinition?5of?5element?5?$CFs?6@
	push	509					; 000001fdH
	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN57@xmlAddElem
$LN25@xmlAddElem:

; 1498 : 	                    "Redefinition of element %s\n",
; 1499 : 			    name, NULL, NULL);
; 1500 : #endif /* LIBXML_VALID_ENABLED */
; 1501 : 	    if (uqname != NULL)
; 1502 : 		xmlFree(uqname);
; 1503 :             if (ns != NULL)
; 1504 : 	        xmlFree(ns);
; 1505 : 	    return(NULL);
; 1506 : 	}
; 1507 : 	if (ns != NULL) {

	mov	eax, DWORD PTR _ns$[ebp]
	test	eax, eax
	je	$LN24@xmlAddElem

; 1508 : 	    xmlFree(ns);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1509 : 	    ns = NULL;

	mov	DWORD PTR _ns$[ebp], 0

; 1510 : 	}
; 1511 :     } else {

	jmp	$LN24@xmlAddElem
$LN23@xmlAddElem:

; 1512 : 	ret = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));

	push	56					; 00000038H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 1513 : 	if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN29@xmlAddElem

; 1514 : 	    xmlVErrMemory(ctxt, "malloc failed");

	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
$LN56@xmlAddElem:

; 1598 : }

	push	DWORD PTR _ctxt$[ebp]
	call	_xmlVErrMemory
	add	esp, 8
$LN57@xmlAddElem:
	test	edi, edi
	je	SHORT $LN30@xmlAddElem
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN30@xmlAddElem:
	mov	eax, DWORD PTR _ns$[ebp]
	test	eax, eax
	je	$LN36@xmlAddElem
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlAddElem:

; 1515 : 	    if (uqname != NULL)
; 1516 : 		xmlFree(uqname);
; 1517 :             if (ns != NULL)
; 1518 : 	        xmlFree(ns);
; 1519 : 	    return(NULL);
; 1520 : 	}
; 1521 : 	memset(ret, 0, sizeof(xmlElement));

	push	56					; 00000038H
	push	0
	push	esi
	call	_memset

; 1522 : 	ret->type = XML_ELEMENT_DECL;
; 1523 : 
; 1524 : 	/*
; 1525 : 	 * fill the structure.
; 1526 : 	 */
; 1527 : 	ret->name = xmlStrdup(name);

	push	DWORD PTR _name$[ebp]
	mov	DWORD PTR [esi+4], 15			; 0000000fH
	call	_xmlStrdup
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], eax

; 1528 : 	if (ret->name == NULL) {

	test	eax, eax
	jne	SHORT $LN32@xmlAddElem

; 1529 : 	    xmlVErrMemory(ctxt, "malloc failed");

	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlVErrMemory
	add	esp, 8

; 1530 : 	    if (uqname != NULL)

	test	edi, edi
	je	SHORT $LN33@xmlAddElem

; 1531 : 		xmlFree(uqname);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN33@xmlAddElem:

; 1532 :             if (ns != NULL)

	mov	eax, DWORD PTR _ns$[ebp]
	test	eax, eax
	je	SHORT $LN34@xmlAddElem

; 1533 : 	        xmlFree(ns);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN34@xmlAddElem:

; 1534 : 	    xmlFree(ret);

	push	esi

; 1598 : }

	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@xmlAddElem:

; 1535 : 	    return(NULL);
; 1536 : 	}
; 1537 : 	ret->prefix = ns;

	mov	eax, DWORD PTR _ns$[ebp]

; 1538 : 
; 1539 : 	/*
; 1540 : 	 * Validity Check:
; 1541 : 	 * Insertion must not fail
; 1542 : 	 */
; 1543 : 	if (xmlHashAddEntry2(table, name, ns, ret)) {

	push	esi
	mov	DWORD PTR [esi+48], eax
	push	DWORD PTR _ns$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _table$1$[ebp]
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN35@xmlAddElem

; 1544 : #ifdef LIBXML_VALID_ENABLED
; 1545 : 	    /*
; 1546 : 	     * The element is already defined in this DTD.
; 1547 : 	     */
; 1548 : 	    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,

	push	0
	push	0
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0BM@DLJMKEJ@Redefinition?5of?5element?5?$CFs?6@
	push	509					; 000001fdH
	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrValidNode

; 1549 : 	                    "Redefinition of element %s\n",
; 1550 : 			    name, NULL, NULL);
; 1551 : #endif /* LIBXML_VALID_ENABLED */
; 1552 : 	    xmlFreeElement(ret);

	push	esi
	call	_xmlFreeElement
	add	esp, 32					; 00000020H

; 1553 : 	    if (uqname != NULL)

	test	edi, edi
	je	$LN36@xmlAddElem

; 1554 : 		xmlFree(uqname);

	push	edi

; 1598 : }

	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@xmlAddElem:

; 1555 : 	    return(NULL);
; 1556 : 	}
; 1557 : 	/*
; 1558 : 	 * For new element, may have attributes from earlier
; 1559 : 	 * definition in internal subset
; 1560 : 	 */
; 1561 : 	ret->attributes = oldAttributes;

	mov	eax, DWORD PTR _oldAttributes$1$[ebp]
	mov	DWORD PTR [esi+44], eax
$LN24@xmlAddElem:

; 1562 :     }
; 1563 : 
; 1564 :     /*
; 1565 :      * Finish to fill the structure.
; 1566 :      */
; 1567 :     ret->etype = type;

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [esi+36], eax

; 1568 :     /*
; 1569 :      * Avoid a stupid copy when called by the parser
; 1570 :      * and flag it by setting a special parent value
; 1571 :      * so the parser doesn't unallocate it.
; 1572 :      */
; 1573 :     if ((ctxt != NULL) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN37@xmlAddElem
	mov	eax, DWORD PTR [eax+28]
	cmp	eax, -1412623820			; abcd1234H
	je	SHORT $LN39@xmlAddElem
	cmp	eax, -1412623819			; abcd1235H
	jne	SHORT $LN37@xmlAddElem
$LN39@xmlAddElem:

; 1574 :         ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||
; 1575 :          (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1))) {
; 1576 : 	ret->content = content;

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [esi+40], eax

; 1577 : 	if (content != NULL)

	test	eax, eax
	je	SHORT $LN38@xmlAddElem

; 1578 : 	    content->parent = (xmlElementContentPtr) 1;

	mov	DWORD PTR [eax+20], 1

; 1579 :     } else {

	jmp	SHORT $LN38@xmlAddElem
$LN37@xmlAddElem:

; 1580 : 	ret->content = xmlCopyDocElementContent(dtd->doc, content);

	push	DWORD PTR _content$[ebp]
	push	DWORD PTR [ebx+32]
	call	_xmlCopyDocElementContent
	add	esp, 8
	mov	DWORD PTR [esi+40], eax
$LN38@xmlAddElem:

; 1581 :     }
; 1582 : 
; 1583 :     /*
; 1584 :      * Link it to the DTD
; 1585 :      */
; 1586 :     ret->parent = dtd;

	mov	DWORD PTR [esi+20], ebx

; 1587 :     ret->doc = dtd->doc;

	mov	eax, DWORD PTR [ebx+32]
	mov	DWORD PTR [esi+32], eax

; 1588 :     if (dtd->last == NULL) {

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	jne	SHORT $LN41@xmlAddElem

; 1589 : 	dtd->children = dtd->last = (xmlNodePtr) ret;

	mov	DWORD PTR [ebx+12], esi

; 1590 :     } else {

	jmp	SHORT $LN42@xmlAddElem
$LN41@xmlAddElem:

; 1591 :         dtd->last->next = (xmlNodePtr) ret;

	mov	DWORD PTR [eax+24], esi

; 1592 : 	ret->prev = dtd->last;

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR [esi+28], eax
$LN42@xmlAddElem:

; 1593 : 	dtd->last = (xmlNodePtr) ret;
; 1594 :     }
; 1595 :     if (uqname != NULL)

	mov	DWORD PTR [ebx+16], esi
	test	edi, edi
	je	SHORT $LN43@xmlAddElem

; 1596 : 	xmlFree(uqname);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN43@xmlAddElem:

; 1597 :     return(ret);

	pop	edi
	mov	eax, esi

; 1598 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlAddElem:

; 104  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	xor	ecx, ecx
	xor	edx, edx
	test	eax, eax
	je	SHORT $LN49@xmlAddElem

; 105  :         channel = ctxt->error;
; 106  :         data = ctxt->userData;
; 107  : 	/* Use the special values to detect if it is part of a parsing
; 108  : 	   context */
; 109  : 	if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||

	mov	edi, DWORD PTR [eax+28]
	mov	esi, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	cmp	edi, -1412623820			; abcd1234H
	je	SHORT $LN48@xmlAddElem
	cmp	edi, -1412623819			; abcd1235H
	jne	SHORT $LN49@xmlAddElem
$LN48@xmlAddElem:

; 110  : 	    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {
; 111  : 	    long delta = (char *) ctxt - (char *) ctxt->userData;

	sub	eax, edx

; 112  : 	    if ((delta > 0) && (delta < 250))

	dec	eax
	cmp	eax, 248				; 000000f8H
	cmovbe	ecx, edx
$LN49@xmlAddElem:

; 113  : 		pctxt = ctxt->userData;
; 114  : 	}
; 115  :     }
; 116  :     if (extra)
; 117  :         __xmlRaiseError(NULL, channel, data,
; 118  :                         pctxt, NULL, XML_FROM_VALID, error,
; 119  :                         XML_ERR_ERROR, NULL, 0, extra, NULL, NULL, 0, 0,
; 120  :                         msg, extra);
; 121  :     else
; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0CP@HFIOBKAA@Internal?3?5ELEMENT?5decl?5corrupte@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1
	push	23					; 00000017H
	push	0
	push	ecx
	push	edx
	push	esi
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN36@xmlAddElem:
	pop	edi

; 1598 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN59@xmlAddElem:
	DD	$LN6@xmlAddElem
	DD	$LN8@xmlAddElem
	DD	$LN10@xmlAddElem
	DD	$LN12@xmlAddElem
_xmlAddElementDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlSprintfElementContent
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_content$ = 12						; size = 4
_englob$ = 16						; size = 4
_xmlSprintfElementContent PROC				; COMDAT
	mov	ecx, OFFSET __56F63275_valid@c
	jmp	@__CheckForDebuggerJustMyCode@4
_xmlSprintfElementContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlSnprintfElementContent
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_size$ = 12						; size = 4
_content$ = 16						; size = 4
_englob$ = 20						; size = 4
_xmlSnprintfElementContent PROC				; COMDAT

; 1254 : xmlSnprintfElementContent(char *buf, int size, xmlElementContentPtr content, int englob) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _content$[ebp]
	test	edx, edx
	je	$LN4@xmlSnprint

; 1255 :     int len;
; 1256 : 
; 1257 :     if (content == NULL) return;
; 1258 :     len = strlen(buf);

	push	ebx
	mov	ebx, DWORD PTR _buf$[ebp]
	mov	ecx, ebx
	push	esi
	lea	esi, DWORD PTR [ecx+1]
$LL41@xmlSnprint:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL41@xmlSnprint
	sub	ecx, esi

; 1259 :     if (size - len < 50) {

	mov	esi, DWORD PTR _size$[ebp]
	sub	esi, ecx
	cmp	esi, 50					; 00000032H
	jge	SHORT $LN7@xmlSnprint

; 1260 : 	if ((size - len > 4) && (buf[len - 1] != '.'))

	cmp	esi, 4
	jle	$LN65@xmlSnprint
	cmp	BYTE PTR [ecx+ebx-1], 46		; 0000002eH
	je	$LN65@xmlSnprint

; 1261 : 	    strcat(buf, " ...");

	dec	ebx
	npad	6
$LL42@xmlSnprint:
	mov	al, BYTE PTR [ebx+1]
	lea	ebx, DWORD PTR [ebx+1]
	test	al, al
	jne	SHORT $LL42@xmlSnprint
	mov	eax, DWORD PTR ??_C@_04IBCFJNCN@?5?4?4?4@
	mov	DWORD PTR [ebx], eax
	mov	al, BYTE PTR ??_C@_04IBCFJNCN@?5?4?4?4@+4
	pop	esi
	mov	BYTE PTR [ebx+4], al
	pop	ebx

; 1341 : 	    break;
; 1342 :     }
; 1343 : }

	pop	ebp
	ret	0
$LN7@xmlSnprint:

; 1262 : 	return;
; 1263 :     }
; 1264 :     if (englob) strcat(buf, "(");

	cmp	DWORD PTR _englob$[ebp], 0
	push	edi
	je	SHORT $LN9@xmlSnprint
	lea	edi, DWORD PTR [ebx-1]
$LL43@xmlSnprint:
	mov	al, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	test	al, al
	jne	SHORT $LL43@xmlSnprint
	mov	ax, WORD PTR ??_C@_01ODHLEDKK@?$CI@
	mov	WORD PTR [edi], ax
$LN9@xmlSnprint:

; 1265 :     switch (content->type) {

	mov	eax, DWORD PTR [edx]
	dec	eax
	cmp	eax, 3
	ja	$LN64@xmlSnprint
	jmp	DWORD PTR $LN70@xmlSnprint[eax*4]
$LN10@xmlSnprint:

; 1266 :         case XML_ELEMENT_CONTENT_PCDATA:
; 1267 :             strcat(buf, "#PCDATA");

	lea	ecx, DWORD PTR [ebx-1]
$LL44@xmlSnprint:
	mov	al, BYTE PTR [ecx+1]
	lea	ecx, DWORD PTR [ecx+1]
	test	al, al
	jne	SHORT $LL44@xmlSnprint
	mov	eax, DWORD PTR ??_C@_07ELDBONKP@?$CDPCDATA@
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ??_C@_07ELDBONKP@?$CDPCDATA@+4
	mov	DWORD PTR [ecx+4], eax

; 1268 : 	    break;

	jmp	$LN64@xmlSnprint
$LN11@xmlSnprint:

; 1269 : 	case XML_ELEMENT_CONTENT_ELEMENT: {
; 1270 :             int qnameLen = xmlStrlen(content->name);

	push	DWORD PTR [edx+8]
	call	_xmlStrlen

; 1271 : 
; 1272 : 	    if (content->prefix != NULL)

	mov	ecx, DWORD PTR _content$[ebp]
	mov	edi, eax
	add	esp, 4
	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	je	SHORT $LN12@xmlSnprint

; 1273 :                 qnameLen += xmlStrlen(content->prefix) + 1;

	push	eax
	call	_xmlStrlen
	mov	ecx, DWORD PTR _content$[ebp]
	inc	edi
	add	esp, 4
	add	edi, eax
$LN12@xmlSnprint:

; 1274 : 	    if (size - len < qnameLen + 10) {

	lea	eax, DWORD PTR [edi+10]
	cmp	esi, eax
	jge	SHORT $LN13@xmlSnprint

; 1275 : 		strcat(buf, " ...");

	dec	ebx
	npad	4
$LL45@xmlSnprint:
	mov	al, BYTE PTR [ebx+1]
	lea	ebx, DWORD PTR [ebx+1]
	test	al, al
	jne	SHORT $LL45@xmlSnprint
	mov	eax, DWORD PTR ??_C@_04IBCFJNCN@?5?4?4?4@
	mov	DWORD PTR [ebx], eax
	mov	al, BYTE PTR ??_C@_04IBCFJNCN@?5?4?4?4@+4
	pop	edi
	pop	esi
	mov	BYTE PTR [ebx+4], al
	pop	ebx

; 1341 : 	    break;
; 1342 :     }
; 1343 : }

	pop	ebp
	ret	0
$LN13@xmlSnprint:

; 1276 : 		return;
; 1277 : 	    }
; 1278 : 	    if (content->prefix != NULL) {

	mov	edx, DWORD PTR [ecx+24]
	test	edx, edx
	je	SHORT $LN14@xmlSnprint

; 1279 : 		strcat(buf, (char *) content->prefix);

	mov	esi, edx
$LL46@xmlSnprint:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL46@xmlSnprint
	sub	edx, esi
	lea	edi, DWORD PTR [ebx-1]
$LL47@xmlSnprint:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL47@xmlSnprint
	mov	ecx, edx
	shr	ecx, 2
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb

; 1280 : 		strcat(buf, ":");

	lea	edi, DWORD PTR [ebx-1]
	npad	4
$LL48@xmlSnprint:
	mov	al, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	test	al, al
	jne	SHORT $LL48@xmlSnprint
	mov	ax, WORD PTR ??_C@_01JLIPDDHJ@?3@
	mov	ecx, DWORD PTR _content$[ebp]
	mov	WORD PTR [edi], ax
$LN14@xmlSnprint:

; 1281 : 	    }
; 1282 : 	    if (content->name != NULL)

	mov	edx, DWORD PTR [ecx+8]
	test	edx, edx
	je	SHORT $LN62@xmlSnprint

; 1283 : 		strcat(buf, (char *) content->name);

	mov	esi, edx
	npad	1
$LL49@xmlSnprint:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL49@xmlSnprint
	sub	edx, esi
	lea	edi, DWORD PTR [ebx-1]
	npad	4
$LL50@xmlSnprint:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL50@xmlSnprint
	mov	ecx, edx
	shr	ecx, 2
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb
$LN62@xmlSnprint:

; 1325 : 	    break;
; 1326 :     }
; 1327 :     if (size - strlen(buf) <= 2) return;

	mov	edx, DWORD PTR _content$[ebp]
$LN64@xmlSnprint:
	mov	esi, DWORD PTR _size$[ebp]
$LN32@xmlSnprint:
	mov	ecx, ebx
	lea	edi, DWORD PTR [ecx+1]
$LL57@xmlSnprint:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL57@xmlSnprint
	sub	ecx, edi
	sub	esi, ecx
	cmp	esi, 2
	jbe	$LN67@xmlSnprint

; 1328 :     if (englob)

	cmp	DWORD PTR _englob$[ebp], 0
	je	SHORT $LN35@xmlSnprint

; 1329 :         strcat(buf, ")");

	lea	edi, DWORD PTR [ebx-1]
	npad	2
$LL58@xmlSnprint:
	mov	al, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	test	al, al
	jne	SHORT $LL58@xmlSnprint
	mov	ax, WORD PTR ??_C@_01PKGAHCOL@?$CJ@
	mov	WORD PTR [edi], ax
$LN35@xmlSnprint:

; 1330 :     switch (content->ocur) {

	mov	eax, DWORD PTR [edx+4]
	sub	eax, 2
	je	$LN37@xmlSnprint
	sub	eax, 1
	je	$LN38@xmlSnprint
	sub	eax, 1
	jne	$LN67@xmlSnprint

; 1338 : 	    break;
; 1339 :         case XML_ELEMENT_CONTENT_PLUS:
; 1340 : 	    strcat(buf, "+");

	dec	ebx
$LL59@xmlSnprint:
	mov	al, BYTE PTR [ebx+1]
	inc	ebx
	test	al, al
	jne	SHORT $LL59@xmlSnprint
	mov	ax, WORD PTR ??_C@_01MIFGBAGJ@?$CL@
	mov	edi, ebx
	mov	WORD PTR [edi], ax
	pop	edi
	pop	esi
	pop	ebx

; 1341 : 	    break;
; 1342 :     }
; 1343 : }

	pop	ebp
	ret	0
$LN16@xmlSnprint:

; 1284 : 	    break;
; 1285 :         }
; 1286 : 	case XML_ELEMENT_CONTENT_SEQ:
; 1287 : 	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||

	mov	ecx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, 4
	je	SHORT $LN19@xmlSnprint
	cmp	eax, 3
	je	SHORT $LN19@xmlSnprint

; 1290 : 	    else
; 1291 : 		xmlSnprintfElementContent(buf, size, content->c1, 0);

	xor	eax, eax
	jmp	SHORT $LN18@xmlSnprint
$LN19@xmlSnprint:

; 1288 : 	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
; 1289 : 		xmlSnprintfElementContent(buf, size, content->c1, 1);

	mov	eax, 1
$LN18@xmlSnprint:

; 1292 : 	    len = strlen(buf);

	mov	esi, DWORD PTR _size$[ebp]
	push	eax
	push	ecx
	push	esi
	push	ebx
	call	_xmlSnprintfElementContent
	mov	ecx, ebx
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [ecx+1]
$LL51@xmlSnprint:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL51@xmlSnprint
	sub	ecx, edx

; 1293 : 	    if (size - len < 50) {

	mov	eax, esi
	sub	eax, ecx
	cmp	eax, 50					; 00000032H
	jge	SHORT $LN20@xmlSnprint

; 1294 : 		if ((size - len > 4) && (buf[len - 1] != '.'))

	cmp	eax, 4
	jle	$LN67@xmlSnprint
	cmp	BYTE PTR [ecx+ebx-1], 46		; 0000002eH
	je	$LN67@xmlSnprint

; 1295 : 		    strcat(buf, " ...");

	dec	ebx
	npad	3
$LL52@xmlSnprint:
	mov	al, BYTE PTR [ebx+1]
	lea	ebx, DWORD PTR [ebx+1]
	test	al, al
	jne	SHORT $LL52@xmlSnprint
	mov	eax, DWORD PTR ??_C@_04IBCFJNCN@?5?4?4?4@
	mov	DWORD PTR [ebx], eax
	mov	al, BYTE PTR ??_C@_04IBCFJNCN@?5?4?4?4@+4
	pop	edi
	pop	esi
	mov	BYTE PTR [ebx+4], al
	pop	ebx

; 1341 : 	    break;
; 1342 :     }
; 1343 : }

	pop	ebp
	ret	0
$LN20@xmlSnprint:

; 1296 : 		return;
; 1297 : 	    }
; 1298 :             strcat(buf, " , ");

	lea	edi, DWORD PTR [ebx-1]
$LL53@xmlSnprint:
	mov	al, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	test	al, al
	jne	SHORT $LL53@xmlSnprint
	mov	eax, DWORD PTR ??_C@_03NKFKBEPL@?5?0?5@
	mov	DWORD PTR [edi], eax

; 1299 : 	    if (((content->c2->type == XML_ELEMENT_CONTENT_OR) ||
; 1300 : 		 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&

	mov	eax, DWORD PTR _content$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	je	SHORT $LN24@xmlSnprint
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN22@xmlSnprint
$LN24@xmlSnprint:
	cmp	ecx, 2
	je	SHORT $LN22@xmlSnprint

; 1301 : 		(content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))
; 1302 : 		xmlSnprintfElementContent(buf, size, content->c2, 1);

	mov	ecx, 1

; 1305 : 	    break;

	push	ecx
	push	eax
	push	esi
	push	ebx
	call	_xmlSnprintfElementContent
	mov	edx, DWORD PTR _content$[ebp]
	add	esp, 16					; 00000010H
	jmp	$LN32@xmlSnprint
$LN22@xmlSnprint:

; 1303 : 	    else
; 1304 : 		xmlSnprintfElementContent(buf, size, content->c2, 0);

	xor	ecx, ecx

; 1305 : 	    break;

	push	ecx
	push	eax
	push	esi
	push	ebx
	call	_xmlSnprintfElementContent
	mov	edx, DWORD PTR _content$[ebp]
	add	esp, 16					; 00000010H
	jmp	$LN32@xmlSnprint
$LN25@xmlSnprint:

; 1306 : 	case XML_ELEMENT_CONTENT_OR:
; 1307 : 	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||

	mov	ecx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, 4
	je	SHORT $LN28@xmlSnprint
	cmp	eax, 3
	je	SHORT $LN28@xmlSnprint

; 1310 : 	    else
; 1311 : 		xmlSnprintfElementContent(buf, size, content->c1, 0);

	xor	eax, eax
	jmp	SHORT $LN27@xmlSnprint
$LN28@xmlSnprint:

; 1308 : 	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
; 1309 : 		xmlSnprintfElementContent(buf, size, content->c1, 1);

	mov	eax, 1
$LN27@xmlSnprint:

; 1312 : 	    len = strlen(buf);

	mov	esi, DWORD PTR _size$[ebp]
	push	eax
	push	ecx
	push	esi
	push	ebx
	call	_xmlSnprintfElementContent
	mov	ecx, ebx
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [ecx+1]
$LL54@xmlSnprint:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL54@xmlSnprint
	sub	ecx, edx

; 1313 : 	    if (size - len < 50) {

	mov	eax, esi
	sub	eax, ecx
	cmp	eax, 50					; 00000032H
	jge	SHORT $LN29@xmlSnprint

; 1314 : 		if ((size - len > 4) && (buf[len - 1] != '.'))

	cmp	eax, 4
	jle	$LN67@xmlSnprint
	cmp	BYTE PTR [ecx+ebx-1], 46		; 0000002eH
	je	$LN67@xmlSnprint

; 1315 : 		    strcat(buf, " ...");

	dec	ebx
	npad	4
$LL55@xmlSnprint:
	mov	al, BYTE PTR [ebx+1]
	lea	ebx, DWORD PTR [ebx+1]
	test	al, al
	jne	SHORT $LL55@xmlSnprint
	mov	eax, DWORD PTR ??_C@_04IBCFJNCN@?5?4?4?4@
	mov	DWORD PTR [ebx], eax
	mov	al, BYTE PTR ??_C@_04IBCFJNCN@?5?4?4?4@+4
	pop	edi
	pop	esi
	mov	BYTE PTR [ebx+4], al
	pop	ebx

; 1341 : 	    break;
; 1342 :     }
; 1343 : }

	pop	ebp
	ret	0
$LN29@xmlSnprint:

; 1316 : 		return;
; 1317 : 	    }
; 1318 :             strcat(buf, " | ");

	lea	edi, DWORD PTR [ebx-1]
$LL56@xmlSnprint:
	mov	al, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	test	al, al
	jne	SHORT $LL56@xmlSnprint
	mov	eax, DWORD PTR ??_C@_03LGOGDKEL@?5?$HM?5@
	mov	DWORD PTR [edi], eax

; 1319 : 	    if (((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||
; 1320 : 		 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&

	mov	eax, DWORD PTR _content$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 3
	je	SHORT $LN33@xmlSnprint
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN31@xmlSnprint
$LN33@xmlSnprint:
	cmp	ecx, 2
	je	SHORT $LN31@xmlSnprint

; 1321 : 		(content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))
; 1322 : 		xmlSnprintfElementContent(buf, size, content->c2, 1);

	push	1
	push	eax
	push	esi
	push	ebx
	call	_xmlSnprintfElementContent
	mov	edx, DWORD PTR _content$[ebp]
	add	esp, 16					; 00000010H
	jmp	$LN32@xmlSnprint
$LN31@xmlSnprint:

; 1323 : 	    else
; 1324 : 		xmlSnprintfElementContent(buf, size, content->c2, 0);

	push	0
	push	eax
	push	esi
	push	ebx
	call	_xmlSnprintfElementContent
	mov	edx, DWORD PTR _content$[ebp]
	add	esp, 16					; 00000010H
	jmp	$LN32@xmlSnprint
$LN38@xmlSnprint:

; 1335 : 	    break;
; 1336 :         case XML_ELEMENT_CONTENT_MULT:
; 1337 : 	    strcat(buf, "*");

	dec	ebx
$LL60@xmlSnprint:
	mov	al, BYTE PTR [ebx+1]
	inc	ebx
	test	al, al
	jne	SHORT $LL60@xmlSnprint
	mov	ax, WORD PTR ??_C@_01NBENCBCI@?$CK@
	mov	edi, ebx
	mov	WORD PTR [edi], ax
	pop	edi
	pop	esi
	pop	ebx

; 1341 : 	    break;
; 1342 :     }
; 1343 : }

	pop	ebp
	ret	0
$LN37@xmlSnprint:

; 1331 :         case XML_ELEMENT_CONTENT_ONCE:
; 1332 : 	    break;
; 1333 :         case XML_ELEMENT_CONTENT_OPT:
; 1334 : 	    strcat(buf, "?");

	dec	ebx
	npad	2
$LL61@xmlSnprint:
	mov	al, BYTE PTR [ebx+1]
	inc	ebx
	test	al, al
	jne	SHORT $LL61@xmlSnprint
	mov	ax, WORD PTR ??_C@_01OGPIMHDM@?$DP@
	mov	edi, ebx
	mov	WORD PTR [edi], ax
$LN67@xmlSnprint:
	pop	edi
$LN65@xmlSnprint:
	pop	esi
	pop	ebx
$LN4@xmlSnprint:

; 1341 : 	    break;
; 1342 :     }
; 1343 : }

	pop	ebp
	ret	0
$LN70@xmlSnprint:
	DD	$LN10@xmlSnprint
	DD	$LN11@xmlSnprint
	DD	$LN16@xmlSnprint
	DD	$LN25@xmlSnprint
_xmlSnprintfElementContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeDocElementContent
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlFreeDocElementContent PROC				; COMDAT

; 1101 : xmlFreeDocElementContent(xmlDocPtr doc, xmlElementContentPtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _doc$[ebp]
	xor	edi, edi
	test	ecx, ecx
	je	SHORT $LN25@xmlFreeDoc

; 1102 :     xmlElementContentPtr next;
; 1103 :     xmlDictPtr dict = NULL;
; 1104 : 
; 1105 :     if (doc != NULL)
; 1106 :         dict = doc->dict;

	mov	edi, DWORD PTR [ecx+80]
$LN25@xmlFreeDoc:

; 1107 : 
; 1108 :     while (cur != NULL) {

	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN23@xmlFreeDoc
	push	ebx
$LL2@xmlFreeDoc:

; 1109 :         next = cur->c2;
; 1110 : 	switch (cur->type) {

	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR [esi+16]
	dec	eax
	cmp	eax, 3
	ja	$LN26@xmlFreeDoc

; 1111 : 	    case XML_ELEMENT_CONTENT_PCDATA:
; 1112 : 	    case XML_ELEMENT_CONTENT_ELEMENT:
; 1113 : 	    case XML_ELEMENT_CONTENT_SEQ:
; 1114 : 	    case XML_ELEMENT_CONTENT_OR:
; 1115 : 		break;
; 1116 : 	    default:
; 1117 : 		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
; 1118 : 			"Internal: ELEMENT content corrupted invalid type\n",
; 1119 : 			NULL);
; 1120 : 		return;
; 1121 : 	}
; 1122 : 	if (cur->c1 != NULL) xmlFreeDocElementContent(doc, cur->c1);

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN9@xmlFreeDoc
	push	eax
	push	ecx
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN9@xmlFreeDoc:

; 1123 : 	if (dict) {

	mov	eax, DWORD PTR [esi+8]
	test	edi, edi
	je	SHORT $LN10@xmlFreeDoc

; 1124 : 	    if ((cur->name != NULL) && (!xmlDictOwns(dict, cur->name)))

	test	eax, eax
	je	SHORT $LN12@xmlFreeDoc
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlFreeDoc

; 1125 : 	        xmlFree((xmlChar *) cur->name);

	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlFreeDoc:

; 1126 : 	    if ((cur->prefix != NULL) && (!xmlDictOwns(dict, cur->prefix)))

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN15@xmlFreeDoc
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN15@xmlFreeDoc

; 1127 : 	        xmlFree((xmlChar *) cur->prefix);

	push	DWORD PTR [esi+24]

; 1128 : 	} else {

	jmp	SHORT $LN31@xmlFreeDoc
$LN10@xmlFreeDoc:

; 1129 : 	    if (cur->name != NULL) xmlFree((xmlChar *) cur->name);

	test	eax, eax
	je	SHORT $LN14@xmlFreeDoc
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlFreeDoc:

; 1130 : 	    if (cur->prefix != NULL) xmlFree((xmlChar *) cur->prefix);

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN15@xmlFreeDoc
	push	eax
$LN31@xmlFreeDoc:

; 1131 : 	}
; 1132 : 	xmlFree(cur);

	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlFreeDoc:
	push	esi
	call	DWORD PTR _xmlFree
	mov	ecx, DWORD PTR _doc$[ebp]
	add	esp, 4

; 1133 : 	cur = next;

	mov	esi, ebx
	test	ebx, ebx
	jne	$LL2@xmlFreeDoc

; 1134 :     }
; 1135 : }

	pop	ebx
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN26@xmlFreeDoc:

; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0DC@GLPLFDD@Internal?3?5ELEMENT?5content?5corru@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1
	push	23					; 00000017H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	ebx
$LN23@xmlFreeDoc:
	pop	edi

; 1134 :     }
; 1135 : }

	pop	esi
	pop	ebp
	ret	0
_xmlFreeDocElementContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlCopyDocElementContent
_TEXT	SEGMENT
_prev$1$ = -4						; size = 4
_doc$ = 8						; size = 4
_ret$1$ = 12						; size = 4
_cur$ = 12						; size = 4
_xmlCopyDocElementContent PROC				; COMDAT

; 1008 : xmlCopyDocElementContent(xmlDocPtr doc, xmlElementContentPtr cur) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _cur$[ebp]
	xor	ebx, ebx
	test	edi, edi
	jne	SHORT $LN4@xmlCopyDoc

; 1009 :     xmlElementContentPtr ret = NULL, prev = NULL, tmp;
; 1010 :     xmlDictPtr dict = NULL;
; 1011 : 
; 1012 :     if (cur == NULL) return(NULL);

	pop	edi
	xor	eax, eax

; 1077 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlCopyDoc:

; 1013 : 
; 1014 :     if (doc != NULL)

	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlCopyDoc

; 1015 :         dict = doc->dict;

	mov	ebx, DWORD PTR [eax+80]
$LN5@xmlCopyDoc:
	push	esi

; 1016 : 
; 1017 :     ret = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));

	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _ret$1$[ebp], esi

; 1018 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN6@xmlCopyDoc

; 77   :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	eax
	push	eax
	push	3
	push	2
	push	23					; 00000017H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1019 : 	xmlVErrMemory(NULL, "malloc failed");
; 1020 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 1077 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlCopyDoc:
	xorps	xmm0, xmm0

; 1021 :     }
; 1022 :     memset(ret, 0, sizeof(xmlElementContent));

	movups	XMMWORD PTR [esi], xmm0
	movq	QWORD PTR [esi+16], xmm0
	mov	DWORD PTR [esi+24], 0

; 1023 :     ret->type = cur->type;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 1024 :     ret->ocur = cur->ocur;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax

; 1025 :     if (cur->name != NULL) {

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN9@xmlCopyDoc

; 1026 : 	if (dict)

	test	ebx, ebx
	je	SHORT $LN8@xmlCopyDoc

; 1027 : 	    ret->name = xmlDictLookup(dict, cur->name, -1);

	push	-1
	push	eax
	push	ebx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN48@xmlCopyDoc
$LN8@xmlCopyDoc:

; 1028 : 	else
; 1029 : 	    ret->name = xmlStrdup(cur->name);

	push	eax
	call	_xmlStrdup
	add	esp, 4
$LN48@xmlCopyDoc:

; 1030 :     }
; 1031 : 
; 1032 :     if (cur->prefix != NULL) {

	mov	DWORD PTR [esi+8], eax
$LN9@xmlCopyDoc:
	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN12@xmlCopyDoc

; 1033 : 	if (dict)

	test	ebx, ebx
	je	SHORT $LN11@xmlCopyDoc

; 1034 : 	    ret->prefix = xmlDictLookup(dict, cur->prefix, -1);

	push	-1
	push	eax
	push	ebx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN49@xmlCopyDoc
$LN11@xmlCopyDoc:

; 1035 : 	else
; 1036 : 	    ret->prefix = xmlStrdup(cur->prefix);

	push	eax
	call	_xmlStrdup
	add	esp, 4
$LN49@xmlCopyDoc:

; 1037 :     }
; 1038 :     if (cur->c1 != NULL)

	mov	DWORD PTR [esi+24], eax
$LN12@xmlCopyDoc:
	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN13@xmlCopyDoc

; 1039 :         ret->c1 = xmlCopyDocElementContent(doc, cur->c1);

	push	eax
	push	DWORD PTR _doc$[ebp]
	call	_xmlCopyDocElementContent
	add	esp, 8
	mov	DWORD PTR [esi+12], eax
$LN13@xmlCopyDoc:

; 1040 :     if (ret->c1 != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN14@xmlCopyDoc

; 1041 : 	ret->c1->parent = ret;

	mov	DWORD PTR [eax+20], esi
$LN14@xmlCopyDoc:

; 1042 :     if (cur->c2 != NULL) {

	mov	edi, DWORD PTR [edi+16]
	test	edi, edi
	je	$LN3@xmlCopyDoc

; 1043 :         prev = ret;

	mov	DWORD PTR _prev$1$[ebp], esi
$LL2@xmlCopyDoc:

; 1044 : 	cur = cur->c2;
; 1045 : 	while (cur != NULL) {
; 1046 : 	    tmp = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));

	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 1047 : 	    if (tmp == NULL) {

	test	esi, esi
	je	$LN43@xmlCopyDoc

; 1050 : 	    }
; 1051 : 	    memset(tmp, 0, sizeof(xmlElementContent));

	xorps	xmm0, xmm0
	movups	XMMWORD PTR [esi], xmm0
	movq	QWORD PTR [esi+16], xmm0
	mov	DWORD PTR [esi+24], 0

; 1052 : 	    tmp->type = cur->type;

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 1053 : 	    tmp->ocur = cur->ocur;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax

; 1054 : 	    prev->c2 = tmp;

	mov	eax, DWORD PTR _prev$1$[ebp]
	mov	DWORD PTR [eax+16], esi

; 1055 : 	    if (cur->name != NULL) {

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN19@xmlCopyDoc

; 1056 : 		if (dict)

	test	ebx, ebx
	je	SHORT $LN18@xmlCopyDoc

; 1057 : 		    tmp->name = xmlDictLookup(dict, cur->name, -1);

	push	-1
	push	eax
	push	ebx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN50@xmlCopyDoc
$LN18@xmlCopyDoc:

; 1058 : 		else
; 1059 : 		    tmp->name = xmlStrdup(cur->name);

	push	eax
	call	_xmlStrdup
	add	esp, 4
$LN50@xmlCopyDoc:

; 1060 : 	    }
; 1061 : 
; 1062 : 	    if (cur->prefix != NULL) {

	mov	DWORD PTR [esi+8], eax
$LN19@xmlCopyDoc:
	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN22@xmlCopyDoc

; 1063 : 		if (dict)

	test	ebx, ebx
	je	SHORT $LN21@xmlCopyDoc

; 1064 : 		    tmp->prefix = xmlDictLookup(dict, cur->prefix, -1);

	push	-1
	push	eax
	push	ebx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN51@xmlCopyDoc
$LN21@xmlCopyDoc:

; 1065 : 		else
; 1066 : 		    tmp->prefix = xmlStrdup(cur->prefix);

	push	eax
	call	_xmlStrdup
	add	esp, 4
$LN51@xmlCopyDoc:

; 1067 : 	    }
; 1068 : 	    if (cur->c1 != NULL)

	mov	DWORD PTR [esi+24], eax
$LN22@xmlCopyDoc:
	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN23@xmlCopyDoc

; 1069 : 	        tmp->c1 = xmlCopyDocElementContent(doc,cur->c1);

	push	eax
	push	DWORD PTR _doc$[ebp]
	call	_xmlCopyDocElementContent
	add	esp, 8
	mov	DWORD PTR [esi+12], eax
$LN23@xmlCopyDoc:

; 1070 : 	    if (tmp->c1 != NULL)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $LN24@xmlCopyDoc

; 1071 : 		tmp->c1->parent = ret;

	mov	eax, DWORD PTR _ret$1$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN24@xmlCopyDoc:

; 1072 : 	    prev = tmp;
; 1073 : 	    cur = cur->c2;

	mov	edi, DWORD PTR [edi+16]
	mov	DWORD PTR _prev$1$[ebp], esi
	test	edi, edi
	jne	$LL2@xmlCopyDoc

; 1047 : 	    if (tmp == NULL) {

	mov	esi, DWORD PTR _ret$1$[ebp]
$LN3@xmlCopyDoc:

; 1074 : 	}
; 1075 :     }
; 1076 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 1077 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@xmlCopyDoc:

; 77   :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	0
	push	0
	push	3
	push	2
	push	23					; 00000017H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError

; 1048 : 		xmlVErrMemory(NULL, "malloc failed");
; 1049 : 		return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]

; 77   :         __xmlRaiseError(NULL, channel, data,

	add	esp, 68					; 00000044H
	pop	esi
	pop	edi

; 1077 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCopyDocElementContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlNewDocElementContent
_TEXT	SEGMENT
_tmp$1$ = 8						; size = 4
_doc$ = 8						; size = 4
_name$ = 12						; size = 4
_l$1 = 16						; size = 4
_type$ = 16						; size = 4
_xmlNewDocElementContent PROC				; COMDAT

; 922  :                         xmlElementContentType type) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _doc$[ebp]
	xor	ebx, ebx
	test	eax, eax
	je	SHORT $LN4@xmlNewDocE

; 923  :     xmlElementContentPtr ret;
; 924  :     xmlDictPtr dict = NULL;
; 925  : 
; 926  :     if (doc != NULL)
; 927  :         dict = doc->dict;

	mov	ebx, DWORD PTR [eax+80]
$LN4@xmlNewDocE:

; 928  : 
; 929  :     switch(type) {

	mov	eax, DWORD PTR _type$[ebp]
	dec	eax
	cmp	eax, 3
	ja	$LN9@xmlNewDocE
	jmp	DWORD PTR $LN54@xmlNewDocE[eax*4]
$LN5@xmlNewDocE:

; 930  : 	case XML_ELEMENT_CONTENT_ELEMENT:
; 931  : 	    if (name == NULL) {

	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	jne	SHORT $LN33@xmlNewDocE

; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0CH@ODCBAOPP@xmlNewElementContent?5?3?5name?5?$DN?$DN?5@

; 932  : 	        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
; 933  : 			"xmlNewElementContent : name == NULL !\n",
; 934  : 			NULL);
; 935  : 	    }
; 936  : 	    break;

	jmp	SHORT $LN52@xmlNewDocE
$LN7@xmlNewDocE:

; 937  :         case XML_ELEMENT_CONTENT_PCDATA:
; 938  : 	case XML_ELEMENT_CONTENT_SEQ:
; 939  : 	case XML_ELEMENT_CONTENT_OR:
; 940  : 	    if (name != NULL) {

	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	je	SHORT $LN33@xmlNewDocE

; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0CH@EHMNFIPD@xmlNewElementContent?5?3?5name?5?$CB?$DN?5@
$LN52@xmlNewDocE:

; 951  :     }
; 952  :     ret = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));

	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1
	push	23					; 00000017H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN33@xmlNewDocE:
	push	esi
	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 953  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN10@xmlNewDocE

; 77   :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@
	push	eax
	push	eax
	push	3
	push	2
	push	23					; 00000017H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 954  : 	xmlVErrMemory(NULL, "malloc failed");
; 955  : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 981  : }

	pop	ebx
	pop	ebp
	ret	0
$LN10@xmlNewDocE:

; 956  :     }
; 957  :     memset(ret, 0, sizeof(xmlElementContent));

	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0

; 958  :     ret->type = type;

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [esi], eax

; 959  :     ret->ocur = XML_ELEMENT_CONTENT_ONCE;

	mov	DWORD PTR [esi+4], 1

; 960  :     if (name != NULL) {

	test	edi, edi
	je	$LN17@xmlNewDocE

; 961  :         int l;
; 962  : 	const xmlChar *tmp;
; 963  : 
; 964  : 	tmp = xmlSplitQName3(name, &l);

	lea	eax, DWORD PTR _l$1[ebp]
	push	eax
	push	edi
	call	_xmlSplitQName3
	add	esp, 8
	mov	DWORD PTR _tmp$1$[ebp], eax

; 965  : 	if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlNewDocE

; 966  : 	    if (dict == NULL)

	test	ebx, ebx
	jne	SHORT $LN14@xmlNewDocE

; 967  : 		ret->name = xmlStrdup(name);

	push	edi
	call	_xmlStrdup
	add	esp, 4

; 977  : 	    }
; 978  : 	}
; 979  :     }
; 980  :     return(ret);

	mov	DWORD PTR [esi+8], eax
	mov	eax, esi
	pop	esi
	pop	edi

; 981  : }

	pop	ebx
	pop	ebp
	ret	0
$LN14@xmlNewDocE:

; 968  : 	    else
; 969  : 	        ret->name = xmlDictLookup(dict, name, -1);

	push	-1
	push	edi
	push	ebx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 977  : 	    }
; 978  : 	}
; 979  :     }
; 980  :     return(ret);

	mov	DWORD PTR [esi+8], eax
	mov	eax, esi
	pop	esi
	pop	edi

; 981  : }

	pop	ebx
	pop	ebp
	ret	0
$LN12@xmlNewDocE:

; 970  : 	} else {
; 971  : 	    if (dict == NULL) {

	push	DWORD PTR _l$1[ebp]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN16@xmlNewDocE

; 972  : 		ret->prefix = xmlStrndup(name, l);

	call	_xmlStrndup

; 973  : 		ret->name = xmlStrdup(tmp);

	push	DWORD PTR _tmp$1$[ebp]
	mov	DWORD PTR [esi+24], eax
	call	_xmlStrdup
	add	esp, 12					; 0000000cH

; 977  : 	    }
; 978  : 	}
; 979  :     }
; 980  :     return(ret);

	mov	DWORD PTR [esi+8], eax
	mov	eax, esi
	pop	esi
	pop	edi

; 981  : }

	pop	ebx
	pop	ebp
	ret	0
$LN16@xmlNewDocE:

; 974  : 	    } else {
; 975  : 	        ret->prefix = xmlDictLookup(dict, name, l);

	push	ebx
	call	_xmlDictLookup

; 976  : 		ret->name = xmlDictLookup(dict, tmp, -1);

	push	-1
	push	DWORD PTR _tmp$1$[ebp]
	mov	DWORD PTR [esi+24], eax
	push	ebx
	call	_xmlDictLookup
	add	esp, 24					; 00000018H

; 977  : 	    }
; 978  : 	}
; 979  :     }
; 980  :     return(ret);

	mov	DWORD PTR [esi+8], eax
$LN17@xmlNewDocE:
	mov	eax, esi
	pop	esi
	pop	edi

; 981  : }

	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlNewDocE:

; 122  :         __xmlRaiseError(NULL, channel, data,

	push	OFFSET ??_C@_0DC@GLPLFDD@Internal?3?5ELEMENT?5content?5corru@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1
	push	23					; 00000017H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 941  : 	        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
; 942  : 			"xmlNewElementContent : name != NULL !\n",
; 943  : 			NULL);
; 944  : 	    }
; 945  : 	    break;
; 946  : 	default:
; 947  : 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
; 948  : 		    "Internal: ELEMENT content corrupted invalid type\n",
; 949  : 		    NULL);
; 950  : 	    return(NULL);

	xor	eax, eax
	pop	edi

; 981  : }

	pop	ebx
	pop	ebp
	ret	0
	npad	3
$LN54@xmlNewDocE:
	DD	$LN7@xmlNewDocE
	DD	$LN5@xmlNewDocE
	DD	$LN7@xmlNewDocE
	DD	$LN7@xmlNewDocE
_xmlNewDocElementContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeElementContent
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlFreeElementContent PROC				; COMDAT

; 1145 : xmlFreeElementContent(xmlElementContentPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _cur$[ebp]
	push	0
	call	_xmlFreeDocElementContent
	add	esp, 8

; 1146 :     xmlFreeDocElementContent(NULL, cur);
; 1147 : }

	pop	ebp
	ret	0
_xmlFreeElementContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlCopyElementContent
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlCopyElementContent PROC				; COMDAT

; 1089 : xmlCopyElementContent(xmlElementContentPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _cur$[ebp]
	push	0
	call	_xmlCopyDocElementContent
	add	esp, 8

; 1090 :     return(xmlCopyDocElementContent(NULL, cur));
; 1091 : }

	pop	ebp
	ret	0
_xmlCopyElementContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlNewElementContent
_TEXT	SEGMENT
_name$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlNewElementContent PROC				; COMDAT

; 994  : xmlNewElementContent(const xmlChar *name, xmlElementContentType type) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _type$[ebp]
	push	DWORD PTR _name$[ebp]
	push	0
	call	_xmlNewDocElementContent
	add	esp, 12					; 0000000cH

; 995  :     return(xmlNewDocElementContent(NULL, name, type));
; 996  : }

	pop	ebp
	ret	0
_xmlNewElementContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlDumpNotationTable
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_table$ = 12						; size = 4
_xmlDumpNotationTable PROC				; COMDAT

; 2543 : xmlDumpNotationTable(xmlBufferPtr buf, xmlNotationTablePtr table) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _buf$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlDumpNot

; 2544 :     if ((buf == NULL) || (table == NULL))

	mov	eax, DWORD PTR _table$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlDumpNot

; 2545 :         return;
; 2546 :     xmlHashScan(table, xmlDumpNotationDeclScan, buf);

	push	ecx
	push	OFFSET _xmlDumpNotationDeclScan
	push	eax
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN3@xmlDumpNot:

; 2547 : }

	pop	ebp
	ret	0
_xmlDumpNotationTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlDumpNotationDecl
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_nota$ = 12						; size = 4
_xmlDumpNotationDecl PROC				; COMDAT

; 2503 : xmlDumpNotationDecl(xmlBufferPtr buf, xmlNotationPtr nota) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlDumpNot

; 2504 :     if ((buf == NULL) || (nota == NULL))

	push	edi
	mov	edi, DWORD PTR _nota$[ebp]
	test	edi, edi
	je	SHORT $LN8@xmlDumpNot

; 2505 :         return;
; 2506 :     xmlBufferWriteChar(buf, "<!NOTATION ");

	push	OFFSET ??_C@_0M@IOFINGOM@?$DM?$CBNOTATION?5@
	push	esi
	call	_xmlBufferWriteChar

; 2507 :     xmlBufferWriteCHAR(buf, nota->name);

	push	DWORD PTR [edi]
	push	esi
	call	_xmlBufferWriteCHAR
	add	esp, 16					; 00000010H

; 2508 :     if (nota->PublicID != NULL) {

	cmp	DWORD PTR [edi+4], 0
	je	SHORT $LN4@xmlDumpNot

; 2509 : 	xmlBufferWriteChar(buf, " PUBLIC ");

	push	OFFSET ??_C@_08GBBLECIH@?5PUBLIC?5@
	push	esi
	call	_xmlBufferWriteChar

; 2510 : 	xmlBufferWriteQuotedString(buf, nota->PublicID);

	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlBufferWriteQuotedString
	add	esp, 16					; 00000010H

; 2511 : 	if (nota->SystemID != NULL) {

	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN5@xmlDumpNot

; 2512 : 	    xmlBufferWriteChar(buf, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@

; 2513 : 	    xmlBufferWriteQuotedString(buf, nota->SystemID);
; 2514 : 	}
; 2515 :     } else {

	jmp	SHORT $LN9@xmlDumpNot
$LN4@xmlDumpNot:

; 2516 : 	xmlBufferWriteChar(buf, " SYSTEM ");

	push	OFFSET ??_C@_08PAGGLANP@?5SYSTEM?5@
$LN9@xmlDumpNot:

; 2517 : 	xmlBufferWriteQuotedString(buf, nota->SystemID);
; 2518 :     }
; 2519 :     xmlBufferWriteChar(buf, " >\n");

	push	esi
	call	_xmlBufferWriteChar
	push	DWORD PTR [edi+8]
	push	esi
	call	_xmlBufferWriteQuotedString
	add	esp, 16					; 00000010H
$LN5@xmlDumpNot:
	push	OFFSET ??_C@_03KKJDKPMN@?5?$DO?6@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8
$LN8@xmlDumpNot:
	pop	edi
$LN3@xmlDumpNot:
	pop	esi

; 2520 : }

	pop	ebp
	ret	0
_xmlDumpNotationDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlFreeNotationTable
_TEXT	SEGMENT
_table$ = 8						; size = 4
_xmlFreeNotationTable PROC				; COMDAT

; 2442 : xmlFreeNotationTable(xmlNotationTablePtr table) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	OFFSET _xmlFreeNotationTableEntry
	push	DWORD PTR _table$[ebp]
	call	_xmlHashFree
	add	esp, 8

; 2443 :     xmlHashFree(table, xmlFreeNotationTableEntry);
; 2444 : }

	pop	ebp
	ret	0
_xmlFreeNotationTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlCopyNotationTable
_TEXT	SEGMENT
_table$ = 8						; size = 4
_xmlCopyNotationTable PROC				; COMDAT

; 2489 : xmlCopyNotationTable(xmlNotationTablePtr table) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	push	OFFSET _xmlCopyNotation
	push	DWORD PTR _table$[ebp]
	call	_xmlHashCopy
	add	esp, 8

; 2490 :     return((xmlNotationTablePtr) xmlHashCopy(table, xmlCopyNotation));
; 2491 : }

	pop	ebp
	ret	0
_xmlCopyNotationTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\valid.c
;	COMDAT _xmlAddNotationDecl
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_dtd$ = 12						; size = 4
_name$ = 16						; size = 4
_PublicID$ = 20						; size = 4
_SystemID$ = 24						; size = 4
_xmlAddNotationDecl PROC				; COMDAT

; 2367 :                    const xmlChar *PublicID, const xmlChar *SystemID) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __56F63275_valid@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _dtd$[ebp]
	test	esi, esi
	je	$LN13@xmlAddNota

; 2368 :     xmlNotationPtr ret;
; 2369 :     xmlNotationTablePtr table;
; 2370 : 
; 2371 :     if (dtd == NULL) {
; 2372 : 	return(NULL);
; 2373 :     }
; 2374 :     if (name == NULL) {

	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	je	$LN13@xmlAddNota

; 2375 : 	return(NULL);
; 2376 :     }
; 2377 :     if ((PublicID == NULL) && (SystemID == NULL)) {

	cmp	DWORD PTR _PublicID$[ebp], 0
	jne	SHORT $LN4@xmlAddNota
	cmp	DWORD PTR _SystemID$[ebp], 0
	je	$LN13@xmlAddNota
$LN4@xmlAddNota:
	push	ebx

; 2379 :     }
; 2380 : 
; 2381 :     /*
; 2382 :      * Create the Notation table if needed.
; 2383 :      */
; 2384 :     table = (xmlNotationTablePtr) dtd->notations;

	mov	ebx, DWORD PTR [esi+36]

; 2385 :     if (table == NULL) {

	test	ebx, ebx
	jne	SHORT $LN7@xmlAddNota

; 2386 : 	xmlDictPtr dict = NULL;
; 2387 : 	if (dtd->doc != NULL)

	mov	ecx, DWORD PTR [esi+32]
	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN6@xmlAddNota

; 2388 : 	    dict = dtd->doc->dict;

	mov	eax, DWORD PTR [ecx+80]
$LN6@xmlAddNota:

; 2389 : 
; 2390 :         dtd->notations = table = xmlHashCreateDict(0, dict);

	push	eax
	push	0
	call	_xmlHashCreateDict
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR [esi+36], ebx

; 2391 :     }
; 2392 :     if (table == NULL) {

	test	ebx, ebx
	jne	SHORT $LN7@xmlAddNota

; 2393 : 	xmlVErrMemory(ctxt,

	push	OFFSET ??_C@_0CM@PJBPJANJ@xmlAddNotationDecl?3?5Table?5creat@

; 2401 : 	return(NULL);

	push	DWORD PTR _ctxt$[ebp]
	call	_xmlVErrMemory
	add	esp, 8
	xor	eax, eax
	pop	ebx
	pop	edi

; 2428 : }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlAddNota:

; 2394 : 		"xmlAddNotationDecl: Table creation failed!\n");
; 2395 :         return(NULL);
; 2396 :     }
; 2397 : 
; 2398 :     ret = (xmlNotationPtr) xmlMalloc(sizeof(xmlNotation));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 2399 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN8@xmlAddNota

; 2400 : 	xmlVErrMemory(ctxt, "malloc failed");

	push	OFFSET ??_C@_0O@IMHFIAOC@malloc?5failed@

; 2401 : 	return(NULL);

	push	DWORD PTR _ctxt$[ebp]
	call	_xmlVErrMemory
	add	esp, 8
	xor	eax, eax
	pop	ebx
	pop	edi

; 2428 : }

	pop	esi
	pop	ebp
	ret	0
$LN8@xmlAddNota:
	xorps	xmm0, xmm0

; 2402 :     }
; 2403 :     memset(ret, 0, sizeof(xmlNotation));

	movq	QWORD PTR [esi], xmm0

; 2404 : 
; 2405 :     /*
; 2406 :      * fill the structure.
; 2407 :      */
; 2408 :     ret->name = xmlStrdup(name);

	push	edi
	mov	DWORD PTR [esi+8], 0
	call	_xmlStrdup
	mov	DWORD PTR [esi], eax
	add	esp, 4

; 2409 :     if (SystemID != NULL)

	mov	eax, DWORD PTR _SystemID$[ebp]
	test	eax, eax
	je	SHORT $LN9@xmlAddNota

; 2410 :         ret->SystemID = xmlStrdup(SystemID);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+8], eax
$LN9@xmlAddNota:

; 2411 :     if (PublicID != NULL)

	mov	eax, DWORD PTR _PublicID$[ebp]
	test	eax, eax
	je	SHORT $LN10@xmlAddNota

; 2412 :         ret->PublicID = xmlStrdup(PublicID);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
$LN10@xmlAddNota:

; 2413 : 
; 2414 :     /*
; 2415 :      * Validity Check:
; 2416 :      * Check the DTD for previous declarations of the ATTLIST
; 2417 :      */
; 2418 :     if (xmlHashAddEntry(table, name, ret)) {

	push	esi
	push	edi
	push	ebx
	call	_xmlHashAddEntry
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@xmlAddNota

; 2419 : #ifdef LIBXML_VALID_ENABLED
; 2420 : 	xmlErrValid(NULL, XML_DTD_NOTATION_REDEFINED,

	push	edi
	push	OFFSET ??_C@_0CI@HFJJKKEO@xmlAddNotationDecl?3?5?$CFs?5already?5@
	push	526					; 0000020eH
	push	0
	call	_xmlErrValid

; 2421 : 		    "xmlAddNotationDecl: %s already defined\n",
; 2422 : 		    (const char *) name);
; 2423 : #endif /* LIBXML_VALID_ENABLED */
; 2424 : 	xmlFreeNotation(ret);

	push	esi
	call	_xmlFreeNotation
	add	esp, 20					; 00000014H
	xor	eax, eax
	pop	ebx
	pop	edi

; 2428 : }

	pop	esi
	pop	ebp
	ret	0
$LN11@xmlAddNota:
	pop	ebx
	pop	edi

; 2425 : 	return(NULL);
; 2426 :     }
; 2427 :     return(ret);

	mov	eax, esi

; 2428 : }

	pop	esi
	pop	ebp
	ret	0
$LN13@xmlAddNota:
	pop	edi

; 2378 : 	return(NULL);

	xor	eax, eax

; 2428 : }

	pop	esi
	pop	ebp
	ret	0
_xmlAddNotationDecl ENDP
_TEXT	ENDS
END
