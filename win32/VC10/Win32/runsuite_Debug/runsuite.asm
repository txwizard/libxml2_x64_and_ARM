; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\runsuite.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__86261D59_stralign@h DB 01H
__6B9C2DC0_tchar@h DB 01H
__C0802A2B_corecrt_wtime@h DB 01H
__04AA828A_time@h DB 01H
__A40A425D_stat@h DB 01H
__ECEFD40B_runsuite@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_printf
PUBLIC	_snprintf
PUBLIC	_main
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_05GFOLEBJA@?$CFs?1?$CFs@			; `string'
PUBLIC	??_C@_0BP@MFIPDKLN@Exitting?5tests?5on?5fatal?5error?6@ ; `string'
PUBLIC	??_C@_0BL@OMNEBIPD@Too?5many?5entities?5defined?6@ ; `string'
PUBLIC	??_C@_0P@BFDMMPAI@?6?9?9?9?9?9?9?9?9?9?9?9?9?6@	; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_09DGPCOFBK@TestSuite@			; `string'
PUBLIC	??_C@_02FHFEMMFE@ts@				; `string'
PUBLIC	??_C@_0BN@GKPMOOH@http?3?1?1www?4w3?4org?11999?1xlink@ ; `string'
PUBLIC	??_C@_05HHOAKHHD@xlink@				; `string'
PUBLIC	??_C@_0BG@NHDHPLMD@Failed?5to?5compile?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0P@CKJJNHKD@?4?1incorrect?$FL1?$FN@	; `string'
PUBLIC	??_C@_03MCCMDFBL@?4?1?$CK@			; `string'
PUBLIC	??_C@_0CJ@BODPNGCB@Failed?5to?5find?5test?5in?5correct?5@ ; `string'
PUBLIC	??_C@_0BB@NKPLANIP@out?5of?5memory?5?$CB?6@	; `string'
PUBLIC	??_C@_0CI@DKMJCAPB@Failed?5to?5detect?5incorect?5RNG?5l@ ; `string'
PUBLIC	??_C@_0DB@KOEBBOFA@Validation?5of?5tests?5starting?5li@ ; `string'
PUBLIC	??_C@_0O@ONOBOMHP@string?$CI?$EAname?$CJ@	; `string'
PUBLIC	??_C@_0BP@DGMHDMIP@following?9sibling?3?3resource?$FL1?$FN@ ; `string'
PUBLIC	??_C@_0O@LNKGJPHN@?4?1resource?$FL1?$FN@	; `string'
PUBLIC	??_C@_08JGDDGDEM@?4?1dir?$FL1?$FN@		; `string'
PUBLIC	??_C@_0BK@JBEJBKGG@following?9sibling?3?3dir?$FL1?$FN@ ; `string'
PUBLIC	??_C@_0N@GHEABEGP@?4?1correct?$FL1?$FN@		; `string'
PUBLIC	??_C@_0CC@NJOGDFNA@Failed?5to?5parse?5RNGtest?5line?5?$CFl@ ; `string'
PUBLIC	??_C@_0BM@BOGBCHLM@following?9sibling?3?3valid?$FL1?$FN@ ; `string'
PUBLIC	??_C@_03DIJGCOJI@dtd@				; `string'
PUBLIC	??_C@_0CJ@OBKFIGCD@Failed?5to?5find?5test?5in?5?$DMvalid?$DO?5@ ; `string'
PUBLIC	??_C@_04CEJDCDCH@test@				; `string'
PUBLIC	??_C@_0CJ@HBAOOEGJ@Failed?5to?5parse?5valid?5instance?5@ ; `string'
PUBLIC	??_C@_0CM@HILILNIM@Failed?5to?5validate?5valid?5instan@ ; `string'
PUBLIC	??_C@_0CN@MNFDEAFF@Internal?5error?5validating?5insta@ ; `string'
PUBLIC	??_C@_0CL@CHMJIAMO@Validation?5of?5instance?5line?5?$CFld@ ; `string'
PUBLIC	??_C@_0BO@EOANKJHM@following?9sibling?3?3invalid?$FL1?$FN@ ; `string'
PUBLIC	??_C@_0CL@OLCIMLMA@Failed?5to?5find?5test?5in?5?$DMinvalid@ ; `string'
PUBLIC	??_C@_0CM@HLHCNDD@Failed?5to?5detect?5invalid?5instan@ ; `string'
PUBLIC	??_C@_0BG@IHDGFAMN@string?$CIdocumentation?$CJ@	; `string'
PUBLIC	??_C@_09IBKNLDJC@Suite?5?$CFs?6@		; `string'
PUBLIC	??_C@_0O@GKEMDIAD@?4?1testCase?$FL1?$FN@	; `string'
PUBLIC	??_C@_0BP@OBCNJLPB@following?9sibling?3?3testCase?$FL1?$FN@ ; `string'
PUBLIC	??_C@_0BO@MGGLCEJL@test?1xsdtest?1xsdtestsuite?4xml@ ; `string'
PUBLIC	??_C@_0BE@MIGLFCAE@Failed?5to?5parse?5?$CFs?6@	; `string'
PUBLIC	??_C@_0DG@ICOCCJHI@?$CD?$CD?5XML?5Schemas?5datatypes?5test?5s@ ; `string'
PUBLIC	??_C@_09HJKPOGMK@testSuite@			; `string'
PUBLIC	??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@	; `string'
PUBLIC	??_C@_0P@MCCEHCEB@?4?1testSuite?$FL1?$FN@	; `string'
PUBLIC	??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@ ; `string'
PUBLIC	??_C@_0BA@IFALBHJB@string?$CIsection?$CJ@	; `string'
PUBLIC	??_C@_0M@DACABIB@Section?5?$CFs?6@		; `string'
PUBLIC	??_C@_0CA@KKAOGFMP@test?1relaxng?1OASIS?1spectest?4xml@ ; `string'
PUBLIC	??_C@_0CJ@HIMBOBNB@?$CD?$CD?5Relax?5NG?5test?5suite?5from?5Jam@ ; `string'
PUBLIC	??_C@_0BL@INNHDNAD@test?1relaxng?1testsuite?4xml@ ; `string'
PUBLIC	??_C@_0CE@PPJGKGKI@?$CD?$CD?5Relax?5NG?5test?5suite?5for?5libx@ ; `string'
PUBLIC	??_C@_0CI@CMJHJDGI@string?$CIts?3instanceDocument?1?$EAxli@ ; `string'
PUBLIC	??_C@_0DD@HGOIGGEJ@testGroup?5line?5?$CFld?5misses?5href?5@ ; `string'
PUBLIC	??_C@_0DJ@ODKNMILE@Failed?5to?5build?5path?5to?5schemas@ ; `string'
PUBLIC	??_C@_0CP@OLLDHGKK@schemas?5for?5testGroup?5line?5?$CFld?5@ ; `string'
PUBLIC	??_C@_0BO@LLDGLFOO@string?$CIts?3expected?1?$EAvalidity?$CJ@ ; `string'
PUBLIC	??_C@_0DE@ELAIJGEI@instanceDocument?5line?5?$CFld?5misse@ ; `string'
PUBLIC	??_C@_0BM@MMDCFNIM@instance?5?$CFs?5fails?5to?5parse?6@ ; `string'
PUBLIC	??_C@_05HDPIMK@valid@				; `string'
PUBLIC	??_C@_0DB@MEJOFODP@valid?5instance?5?$CFs?5failed?5to?5val@ ; `string'
PUBLIC	??_C@_0DE@PEFCJFEE@valid?5instance?5?$CFs?5got?5internal?5@ ; `string'
PUBLIC	??_C@_07MALOAKCI@invalid@			; `string'
PUBLIC	??_C@_0DB@NHKLIBPD@Failed?5to?5detect?5invalid?5instan@ ; `string'
PUBLIC	??_C@_0DL@GJKHAOCE@instanceDocument?5line?5?$CFld?5has?5u@ ; `string'
PUBLIC	??_C@_0DE@ONCAFCLF@string?$CIts?3schemaTest?1ts?3schemaD@ ; `string'
PUBLIC	??_C@_0CM@KEHKFIFH@string?$CIts?3schemaTest?1ts?3expecte@ ; `string'
PUBLIC	??_C@_0CN@KBELDKMH@testGroup?5line?5?$CFld?5misses?5expec@ ; `string'
PUBLIC	??_C@_0CC@MDMCGIDK@valid?5schemas?5?$CFs?5failed?5to?5pars@ ; `string'
PUBLIC	??_C@_0N@MBLKFBIB@nimplemented@			; `string'
PUBLIC	??_C@_0CN@ELPOJJMN@valid?5schemas?5?$CFs?5hit?5an?5unimple@ ; `string'
PUBLIC	??_C@_0BF@KAPKJJJH@?4?1ts?3instanceTest?$FL1?$FN@ ; `string'
PUBLIC	??_C@_0CG@FCJJLOOA@following?9sibling?3?3ts?3instanceT@ ; `string'
PUBLIC	??_C@_0CG@PIGAEOBP@Failed?5to?5detect?5error?5in?5schem@ ; `string'
PUBLIC	??_C@_0CP@HIGMEMKG@invalid?5schemas?5?$CFs?5hit?5an?5unimp@ ; `string'
PUBLIC	??_C@_0DH@MPCAIJDE@testGroup?5line?5?$CFld?5misses?5unexp@ ; `string'
PUBLIC	??_C@_0CH@MEDDADMO@Processing?5test?5line?5?$CFld?5?$CFs?5lea@ ; `string'
PUBLIC	??_C@_07DGFKPAKL@testSet@			; `string'
PUBLIC	??_C@_0M@EECBLNBL@contributor@			; `string'
PUBLIC	??_C@_07NBCGADJA@Unknown@			; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_0CJ@PEBJNNOD@?$CD?$CD?5?$CFs?5test?5suite?5for?5Schemas?5ve@ ; `string'
PUBLIC	??_C@_0BC@LOBCMKNF@?4?1ts?3testGroup?$FL1?$FN@	; `string'
PUBLIC	??_C@_09EANEKJKI@testGroup@			; `string'
PUBLIC	??_C@_0CD@EPMPPHIO@following?9sibling?3?3ts?3testGroup@ ; `string'
PUBLIC	??_C@_0BF@CDOBHHMA@?$CFY?1?$CFm?1?$CFd?5?$CFH?3?$CFM?3?$CFS?5?$CFZ@ ; `string'
PUBLIC	??_C@_0BG@CBLCLCJH@?$CFY?1?$CFm?1?$CFd?5?$CFH?3?$CFM?3?$CFS?5UTC@ ; `string'
PUBLIC	??_C@_0CI@ECHHPCPC@Execution?5start?5time?3?5UTC?3?5?5?$DN?5?$CF@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0N@NKKOPKIL@runsuite?4log@		; `string'
PUBLIC	??_C@_0DG@NLJMPNNG@Could?5not?5open?5the?5log?5file?0?5ru@ ; `string'
PUBLIC	??_C@_02EJEOCNCO@?9v@				; `string'
PUBLIC	??_C@_0BJ@OIFNJJDH@Ran?5?$CFd?5tests?0?5no?5errors?6@ ; `string'
PUBLIC	??_C@_0CD@FKBFBNPO@Ran?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5lea@ ; `string'
PUBLIC	??_C@_0BF@JAEPBNCO@xstc?1Tests?1Metadata?1@	; `string'
PUBLIC	??_C@_0DD@EEANKDMB@xstc?1Tests?1Metadata?1NISTXMLSche@ ; `string'
PUBLIC	??_C@_0CH@EHPPMFBH@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5no?5@ ; `string'
PUBLIC	??_C@_0EA@PNDHDNOB@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0M@OKJBACOM@xstc?1Tests?1@		; `string'
PUBLIC	??_C@_0DF@OEALCOMO@xstc?1Tests?1Metadata?1SunXMLSchem@ ; `string'
PUBLIC	??_C@_0DE@CCIMICPD@xstc?1Tests?1Metadata?1MSXMLSchema@ ; `string'
PUBLIC	??_C@_0BL@HGPINOJF@Total?5?$CFd?5tests?0?5no?5errors?6@ ; `string'
PUBLIC	??_C@_0CF@BABBENFF@Total?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5l@ ; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_strstr:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__exit:PROC
EXTRN	__imp__FormatNowLocalA@8:PROC
EXTRN	__imp__FormatNowUTCA@8:PROC
EXTRN	__imp__ShowProgramInfoA@0:PROC
EXTRN	__imp___stat64i32:PROC
EXTRN	_xmlBufferCreate:PROC
EXTRN	_xmlBufferFree:PROC
EXTRN	_xmlBufferAdd:PROC
EXTRN	_xmlBufferEmpty:PROC
EXTRN	_xmlFreeDoc:PROC
EXTRN	_xmlGetLineNo:PROC
EXTRN	_xmlDocGetRootElement:PROC
EXTRN	_xmlGetProp:PROC
EXTRN	_xmlNodeDump:PROC
EXTRN	_xmlSetGenericErrorFunc:PROC
EXTRN	_xmlResetLastError:PROC
EXTRN	_xmlMemSetup:PROC
EXTRN	_xmlMemUsed:PROC
EXTRN	_xmlMemoryDump:PROC
EXTRN	_xmlMemMalloc:PROC
EXTRN	_xmlMemRealloc:PROC
EXTRN	_xmlMemFree:PROC
EXTRN	_xmlMemoryStrdup:PROC
EXTRN	___xmlGetWarningsDefaultValue:PROC
EXTRN	_xmlNoNetExternalEntityLoader:PROC
EXTRN	_xmlInitParser:PROC
EXTRN	_xmlCleanupParser:PROC
EXTRN	_xmlPedanticParserDefault:PROC
EXTRN	_xmlSetExternalEntityLoader:PROC
EXTRN	_xmlReadFile:PROC
EXTRN	_xmlReadMemory:PROC
EXTRN	_xmlNewStringInputStream:PROC
EXTRN	_xmlBuildURI:PROC
EXTRN	_xmlRelaxNGInitTypes:PROC
EXTRN	_xmlRelaxNGNewMemParserCtxt:PROC
EXTRN	_xmlRelaxNGFreeParserCtxt:PROC
EXTRN	_xmlRelaxNGSetParserErrors:PROC
EXTRN	_xmlRelaxNGParse:PROC
EXTRN	_xmlRelaxNGFree:PROC
EXTRN	_xmlRelaxNGSetValidErrors:PROC
EXTRN	_xmlRelaxNGNewValidCtxt:PROC
EXTRN	_xmlRelaxNGFreeValidCtxt:PROC
EXTRN	_xmlRelaxNGValidateDoc:PROC
EXTRN	_xmlSchemaNewParserCtxt:PROC
EXTRN	_xmlSchemaFreeParserCtxt:PROC
EXTRN	_xmlSchemaSetParserErrors:PROC
EXTRN	_xmlSchemaParse:PROC
EXTRN	_xmlSchemaFree:PROC
EXTRN	_xmlSchemaSetValidErrors:PROC
EXTRN	_xmlSchemaNewValidCtxt:PROC
EXTRN	_xmlSchemaFreeValidCtxt:PROC
EXTRN	_xmlSchemaValidateDoc:PROC
EXTRN	_xmlXPathFreeObject:PROC
EXTRN	_xmlXPathNewContext:PROC
EXTRN	_xmlXPathFreeContext:PROC
EXTRN	_xmlXPathContextSetCache:PROC
EXTRN	_xmlXPathCompile:PROC
EXTRN	_xmlXPathCompiledEval:PROC
EXTRN	_xmlXPathFreeCompExpr:PROC
EXTRN	_xmlXPathRegisterNs:PROC
EXTRN	_xmlSchemaInitTypes:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__imp__xmlFree:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_logfile DD	01H DUP (?)
_verbose DD	01H DUP (?)
_nb_tests DD	01H DUP (?)
_nb_errors DD	01H DUP (?)
_nb_internals DD 01H DUP (?)
_nb_schematas DD 01H DUP (?)
_nb_unimplemented DD 01H DUP (?)
_nb_leaks DD	01H DUP (?)
_extraMemoryFromResolver DD 01H DUP (?)
_testEntitiesName DD 014H DUP (?)
_testEntitiesValue DD 014H DUP (?)
_nb_entities DD	01H DUP (?)
_testErrors DB	08001H DUP (?)
	ALIGN	4

_testErrorsSize DD 01H DUP (?)
_ctxtXPath DD	01H DUP (?)
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CF@BABBENFF@Total?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5l@
CONST	SEGMENT
??_C@_0CF@BABBENFF@Total?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5l@ DB 'T'
	DB	'otal %d tests, %d errors, %d leaks', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HGPINOJF@Total?5?$CFd?5tests?0?5no?5errors?6@
CONST	SEGMENT
??_C@_0BL@HGPINOJF@Total?5?$CFd?5tests?0?5no?5errors?6@ DB 'Total %d test'
	DB	's, no errors', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@CCIMICPD@xstc?1Tests?1Metadata?1MSXMLSchema@
CONST	SEGMENT
??_C@_0DE@CCIMICPD@xstc?1Tests?1Metadata?1MSXMLSchema@ DB 'xstc/Tests/Met'
	DB	'adata/MSXMLSchema1-0-20020116.testSet', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@OEALCOMO@xstc?1Tests?1Metadata?1SunXMLSchem@
CONST	SEGMENT
??_C@_0DF@OEALCOMO@xstc?1Tests?1Metadata?1SunXMLSchem@ DB 'xstc/Tests/Met'
	DB	'adata/SunXMLSchema1-0-20020116.testSet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OKJBACOM@xstc?1Tests?1@
CONST	SEGMENT
??_C@_0M@OKJBACOM@xstc?1Tests?1@ DB 'xstc/Tests/', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@PNDHDNOB@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5?$CFd?5@
CONST	SEGMENT
??_C@_0EA@PNDHDNOB@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5?$CFd?5@ DB 'R'
	DB	'an %d tests (%d schemata), %d errors (%d internals), %d leaks'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EHPPMFBH@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5no?5@
CONST	SEGMENT
??_C@_0CH@EHPPMFBH@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5no?5@ DB 'R'
	DB	'an %d tests (%d schemata), no errors', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EEANKDMB@xstc?1Tests?1Metadata?1NISTXMLSche@
CONST	SEGMENT
??_C@_0DD@EEANKDMB@xstc?1Tests?1Metadata?1NISTXMLSche@ DB 'xstc/Tests/Met'
	DB	'adata/NISTXMLSchemaDatatypes.testSet', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JAEPBNCO@xstc?1Tests?1Metadata?1@
CONST	SEGMENT
??_C@_0BF@JAEPBNCO@xstc?1Tests?1Metadata?1@ DB 'xstc/Tests/Metadata/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FKBFBNPO@Ran?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5lea@
CONST	SEGMENT
??_C@_0CD@FKBFBNPO@Ran?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5lea@ DB 'R'
	DB	'an %d tests, %d errors, %d leaks', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OIFNJJDH@Ran?5?$CFd?5tests?0?5no?5errors?6@
CONST	SEGMENT
??_C@_0BJ@OIFNJJDH@Ran?5?$CFd?5tests?0?5no?5errors?6@ DB 'Ran %d tests, n'
	DB	'o errors', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02EJEOCNCO@?9v@
CONST	SEGMENT
??_C@_02EJEOCNCO@?9v@ DB '-v', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@NLJMPNNG@Could?5not?5open?5the?5log?5file?0?5ru@
CONST	SEGMENT
??_C@_0DG@NLJMPNNG@Could?5not?5open?5the?5log?5file?0?5ru@ DB 'Could not '
	DB	'open the log file, running in verbose mode', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NKKOPKIL@runsuite?4log@
CONST	SEGMENT
??_C@_0N@NKKOPKIL@runsuite?4log@ DB 'runsuite.log', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@ECHHPCPC@Execution?5start?5time?3?5UTC?3?5?5?$DN?5?$CF@
CONST	SEGMENT
??_C@_0CI@ECHHPCPC@Execution?5start?5time?3?5UTC?3?5?5?$DN?5?$CF@ DB 'Exe'
	DB	'cution start time: UTC:  = %s (%s)', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CBLCLCJH@?$CFY?1?$CFm?1?$CFd?5?$CFH?3?$CFM?3?$CFS?5UTC@
CONST	SEGMENT
??_C@_0BG@CBLCLCJH@?$CFY?1?$CFm?1?$CFd?5?$CFH?3?$CFM?3?$CFS?5UTC@ DB '%Y/'
	DB	'%m/%d %H:%M:%S UTC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CDOBHHMA@?$CFY?1?$CFm?1?$CFd?5?$CFH?3?$CFM?3?$CFS?5?$CFZ@
CONST	SEGMENT
??_C@_0BF@CDOBHHMA@?$CFY?1?$CFm?1?$CFd?5?$CFH?3?$CFM?3?$CFS?5?$CFZ@ DB '%'
	DB	'Y/%m/%d %H:%M:%S %Z', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EPMPPHIO@following?9sibling?3?3ts?3testGroup@
CONST	SEGMENT
??_C@_0CD@EPMPPHIO@following?9sibling?3?3ts?3testGroup@ DB 'following-sib'
	DB	'ling::ts:testGroup[1]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09EANEKJKI@testGroup@
CONST	SEGMENT
??_C@_09EANEKJKI@testGroup@ DB 'testGroup', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LOBCMKNF@?4?1ts?3testGroup?$FL1?$FN@
CONST	SEGMENT
??_C@_0BC@LOBCMKNF@?4?1ts?3testGroup?$FL1?$FN@ DB './ts:testGroup[1]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PEBJNNOD@?$CD?$CD?5?$CFs?5test?5suite?5for?5Schemas?5ve@
CONST	SEGMENT
??_C@_0CJ@PEBJNNOD@?$CD?$CD?5?$CFs?5test?5suite?5for?5Schemas?5ve@ DB '##'
	DB	' %s test suite for Schemas version %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown@ DB 'Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EECBLNBL@contributor@
CONST	SEGMENT
??_C@_0M@EECBLNBL@contributor@ DB 'contributor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DGFKPAKL@testSet@
CONST	SEGMENT
??_C@_07DGFKPAKL@testSet@ DB 'testSet', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MEDDADMO@Processing?5test?5line?5?$CFld?5?$CFs?5lea@
CONST	SEGMENT
??_C@_0CH@MEDDADMO@Processing?5test?5line?5?$CFld?5?$CFs?5lea@ DB 'Proces'
	DB	'sing test line %ld %s leaked %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@MPCAIJDE@testGroup?5line?5?$CFld?5misses?5unexp@
CONST	SEGMENT
??_C@_0DH@MPCAIJDE@testGroup?5line?5?$CFld?5misses?5unexp@ DB 'testGroup '
	DB	'line %ld misses unexpected validity value%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HIGMEMKG@invalid?5schemas?5?$CFs?5hit?5an?5unimp@
CONST	SEGMENT
??_C@_0CP@HIGMEMKG@invalid?5schemas?5?$CFs?5hit?5an?5unimp@ DB 'invalid s'
	DB	'chemas %s hit an unimplemented block', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PIGAEOBP@Failed?5to?5detect?5error?5in?5schem@
CONST	SEGMENT
??_C@_0CG@PIGAEOBP@Failed?5to?5detect?5error?5in?5schem@ DB 'Failed to de'
	DB	'tect error in schemas %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FCJJLOOA@following?9sibling?3?3ts?3instanceT@
CONST	SEGMENT
??_C@_0CG@FCJJLOOA@following?9sibling?3?3ts?3instanceT@ DB 'following-sib'
	DB	'ling::ts:instanceTest[1]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KAPKJJJH@?4?1ts?3instanceTest?$FL1?$FN@
CONST	SEGMENT
??_C@_0BF@KAPKJJJH@?4?1ts?3instanceTest?$FL1?$FN@ DB './ts:instanceTest[1'
	DB	']', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@ELPOJJMN@valid?5schemas?5?$CFs?5hit?5an?5unimple@
CONST	SEGMENT
??_C@_0CN@ELPOJJMN@valid?5schemas?5?$CFs?5hit?5an?5unimple@ DB 'valid sch'
	DB	'emas %s hit an unimplemented block', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MBLKFBIB@nimplemented@
CONST	SEGMENT
??_C@_0N@MBLKFBIB@nimplemented@ DB 'nimplemented', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MDMCGIDK@valid?5schemas?5?$CFs?5failed?5to?5pars@
CONST	SEGMENT
??_C@_0CC@MDMCGIDK@valid?5schemas?5?$CFs?5failed?5to?5pars@ DB 'valid sch'
	DB	'emas %s failed to parse', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KBELDKMH@testGroup?5line?5?$CFld?5misses?5expec@
CONST	SEGMENT
??_C@_0CN@KBELDKMH@testGroup?5line?5?$CFld?5misses?5expec@ DB 'testGroup '
	DB	'line %ld misses expected validity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@KEHKFIFH@string?$CIts?3schemaTest?1ts?3expecte@
CONST	SEGMENT
??_C@_0CM@KEHKFIFH@string?$CIts?3schemaTest?1ts?3expecte@ DB 'string(ts:s'
	DB	'chemaTest/ts:expected/@validity)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@ONCAFCLF@string?$CIts?3schemaTest?1ts?3schemaD@
CONST	SEGMENT
??_C@_0DE@ONCAFCLF@string?$CIts?3schemaTest?1ts?3schemaD@ DB 'string(ts:s'
	DB	'chemaTest/ts:schemaDocument/@xlink:href)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@GJKHAOCE@instanceDocument?5line?5?$CFld?5has?5u@
CONST	SEGMENT
??_C@_0DL@GJKHAOCE@instanceDocument?5line?5?$CFld?5has?5u@ DB 'instanceDo'
	DB	'cument line %ld has unexpected validity value%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@NHKLIBPD@Failed?5to?5detect?5invalid?5instan@
CONST	SEGMENT
??_C@_0DB@NHKLIBPD@Failed?5to?5detect?5invalid?5instan@ DB 'Failed to det'
	DB	'ect invalid instance %s against %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MALOAKCI@invalid@
CONST	SEGMENT
??_C@_07MALOAKCI@invalid@ DB 'invalid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PEFCJFEE@valid?5instance?5?$CFs?5got?5internal?5@
CONST	SEGMENT
??_C@_0DE@PEFCJFEE@valid?5instance?5?$CFs?5got?5internal?5@ DB 'valid ins'
	DB	'tance %s got internal error validating %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MEJOFODP@valid?5instance?5?$CFs?5failed?5to?5val@
CONST	SEGMENT
??_C@_0DB@MEJOFODP@valid?5instance?5?$CFs?5failed?5to?5val@ DB 'valid ins'
	DB	'tance %s failed to validate against %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05HDPIMK@valid@
CONST	SEGMENT
??_C@_05HDPIMK@valid@ DB 'valid', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MMDCFNIM@instance?5?$CFs?5fails?5to?5parse?6@
CONST	SEGMENT
??_C@_0BM@MMDCFNIM@instance?5?$CFs?5fails?5to?5parse?6@ DB 'instance %s f'
	DB	'ails to parse', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@ELAIJGEI@instanceDocument?5line?5?$CFld?5misse@
CONST	SEGMENT
??_C@_0DE@ELAIJGEI@instanceDocument?5line?5?$CFld?5misse@ DB 'instanceDoc'
	DB	'ument line %ld misses expected validity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LLDGLFOO@string?$CIts?3expected?1?$EAvalidity?$CJ@
CONST	SEGMENT
??_C@_0BO@LLDGLFOO@string?$CIts?3expected?1?$EAvalidity?$CJ@ DB 'string(t'
	DB	's:expected/@validity)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@OLLDHGKK@schemas?5for?5testGroup?5line?5?$CFld?5@
CONST	SEGMENT
??_C@_0CP@OLLDHGKK@schemas?5for?5testGroup?5line?5?$CFld?5@ DB 'schemas f'
	DB	'or testGroup line %ld is missing: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@ODKNMILE@Failed?5to?5build?5path?5to?5schemas@
CONST	SEGMENT
??_C@_0DJ@ODKNMILE@Failed?5to?5build?5path?5to?5schemas@ DB 'Failed to bu'
	DB	'ild path to schemas testGroup line %ld : %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@HGOIGGEJ@testGroup?5line?5?$CFld?5misses?5href?5@
CONST	SEGMENT
??_C@_0DD@HGOIGGEJ@testGroup?5line?5?$CFld?5misses?5href?5@ DB 'testGroup'
	DB	' line %ld misses href for schemaDocument', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CMJHJDGI@string?$CIts?3instanceDocument?1?$EAxli@
CONST	SEGMENT
??_C@_0CI@CMJHJDGI@string?$CIts?3instanceDocument?1?$EAxli@ DB 'string(ts'
	DB	':instanceDocument/@xlink:href)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PPJGKGKI@?$CD?$CD?5Relax?5NG?5test?5suite?5for?5libx@
CONST	SEGMENT
??_C@_0CE@PPJGKGKI@?$CD?$CD?5Relax?5NG?5test?5suite?5for?5libx@ DB '## Re'
	DB	'lax NG test suite for libxml2', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@INNHDNAD@test?1relaxng?1testsuite?4xml@
CONST	SEGMENT
??_C@_0BL@INNHDNAD@test?1relaxng?1testsuite?4xml@ DB 'test/relaxng/testsu'
	DB	'ite.xml', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HIMBOBNB@?$CD?$CD?5Relax?5NG?5test?5suite?5from?5Jam@
CONST	SEGMENT
??_C@_0CJ@HIMBOBNB@?$CD?$CD?5Relax?5NG?5test?5suite?5from?5Jam@ DB '## Re'
	DB	'lax NG test suite from James Clark', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KKAOGFMP@test?1relaxng?1OASIS?1spectest?4xml@
CONST	SEGMENT
??_C@_0CA@KKAOGFMP@test?1relaxng?1OASIS?1spectest?4xml@ DB 'test/relaxng/'
	DB	'OASIS/spectest.xml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DACABIB@Section?5?$CFs?6@
CONST	SEGMENT
??_C@_0M@DACABIB@Section?5?$CFs?6@ DB 'Section %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IFALBHJB@string?$CIsection?$CJ@
CONST	SEGMENT
??_C@_0BA@IFALBHJB@string?$CIsection?$CJ@ DB 'string(section)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@
CONST	SEGMENT
??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@ DB 'followin'
	DB	'g-sibling::testSuite[1]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MCCEHCEB@?4?1testSuite?$FL1?$FN@
CONST	SEGMENT
??_C@_0P@MCCEHCEB@?4?1testSuite?$FL1?$FN@ DB './testSuite[1]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@
CONST	SEGMENT
??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@ DB 'Unexpected format %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09HJKPOGMK@testSuite@
CONST	SEGMENT
??_C@_09HJKPOGMK@testSuite@ DB 'testSuite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@ICOCCJHI@?$CD?$CD?5XML?5Schemas?5datatypes?5test?5s@
CONST	SEGMENT
??_C@_0DG@ICOCCJHI@?$CD?$CD?5XML?5Schemas?5datatypes?5test?5s@ DB '## XML'
	DB	' Schemas datatypes test suite from James Clark', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MIGLFCAE@Failed?5to?5parse?5?$CFs?6@
CONST	SEGMENT
??_C@_0BE@MIGLFCAE@Failed?5to?5parse?5?$CFs?6@ DB 'Failed to parse %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MGGLCEJL@test?1xsdtest?1xsdtestsuite?4xml@
CONST	SEGMENT
??_C@_0BO@MGGLCEJL@test?1xsdtest?1xsdtestsuite?4xml@ DB 'test/xsdtest/xsd'
	DB	'testsuite.xml', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OBCNJLPB@following?9sibling?3?3testCase?$FL1?$FN@
CONST	SEGMENT
??_C@_0BP@OBCNJLPB@following?9sibling?3?3testCase?$FL1?$FN@ DB 'following'
	DB	'-sibling::testCase[1]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GKEMDIAD@?4?1testCase?$FL1?$FN@
CONST	SEGMENT
??_C@_0O@GKEMDIAD@?4?1testCase?$FL1?$FN@ DB './testCase[1]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IBKNLDJC@Suite?5?$CFs?6@
CONST	SEGMENT
??_C@_09IBKNLDJC@Suite?5?$CFs?6@ DB 'Suite %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IHDGFAMN@string?$CIdocumentation?$CJ@
CONST	SEGMENT
??_C@_0BG@IHDGFAMN@string?$CIdocumentation?$CJ@ DB 'string(documentation)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HLHCNDD@Failed?5to?5detect?5invalid?5instan@
CONST	SEGMENT
??_C@_0CM@HLHCNDD@Failed?5to?5detect?5invalid?5instan@ DB 'Failed to dete'
	DB	'ct invalid instance line %ld', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@OLCIMLMA@Failed?5to?5find?5test?5in?5?$DMinvalid@
CONST	SEGMENT
??_C@_0CL@OLCIMLMA@Failed?5to?5find?5test?5in?5?$DMinvalid@ DB 'Failed to'
	DB	' find test in <invalid> line %ld', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EOANKJHM@following?9sibling?3?3invalid?$FL1?$FN@
CONST	SEGMENT
??_C@_0BO@EOANKJHM@following?9sibling?3?3invalid?$FL1?$FN@ DB 'following-'
	DB	'sibling::invalid[1]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CHMJIAMO@Validation?5of?5instance?5line?5?$CFld@
CONST	SEGMENT
??_C@_0CL@CHMJIAMO@Validation?5of?5instance?5line?5?$CFld@ DB 'Validation'
	DB	' of instance line %ld leaked %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@MNFDEAFF@Internal?5error?5validating?5insta@
CONST	SEGMENT
??_C@_0CN@MNFDEAFF@Internal?5error?5validating?5insta@ DB 'Internal error'
	DB	' validating instance line %ld', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HILILNIM@Failed?5to?5validate?5valid?5instan@
CONST	SEGMENT
??_C@_0CM@HILILNIM@Failed?5to?5validate?5valid?5instan@ DB 'Failed to val'
	DB	'idate valid instance line %ld', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HBAOOEGJ@Failed?5to?5parse?5valid?5instance?5@
CONST	SEGMENT
??_C@_0CJ@HBAOOEGJ@Failed?5to?5parse?5valid?5instance?5@ DB 'Failed to pa'
	DB	'rse valid instance line %ld', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CEJDCDCH@test@
CONST	SEGMENT
??_C@_04CEJDCDCH@test@ DB 'test', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OBKFIGCD@Failed?5to?5find?5test?5in?5?$DMvalid?$DO?5@
CONST	SEGMENT
??_C@_0CJ@OBKFIGCD@Failed?5to?5find?5test?5in?5?$DMvalid?$DO?5@ DB 'Faile'
	DB	'd to find test in <valid> line %ld', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03DIJGCOJI@dtd@
CONST	SEGMENT
??_C@_03DIJGCOJI@dtd@ DB 'dtd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BOGBCHLM@following?9sibling?3?3valid?$FL1?$FN@
CONST	SEGMENT
??_C@_0BM@BOGBCHLM@following?9sibling?3?3valid?$FL1?$FN@ DB 'following-si'
	DB	'bling::valid[1]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NJOGDFNA@Failed?5to?5parse?5RNGtest?5line?5?$CFl@
CONST	SEGMENT
??_C@_0CC@NJOGDFNA@Failed?5to?5parse?5RNGtest?5line?5?$CFl@ DB 'Failed to'
	DB	' parse RNGtest line %ld', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GHEABEGP@?4?1correct?$FL1?$FN@
CONST	SEGMENT
??_C@_0N@GHEABEGP@?4?1correct?$FL1?$FN@ DB './correct[1]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JBEJBKGG@following?9sibling?3?3dir?$FL1?$FN@
CONST	SEGMENT
??_C@_0BK@JBEJBKGG@following?9sibling?3?3dir?$FL1?$FN@ DB 'following-sibl'
	DB	'ing::dir[1]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08JGDDGDEM@?4?1dir?$FL1?$FN@
CONST	SEGMENT
??_C@_08JGDDGDEM@?4?1dir?$FL1?$FN@ DB './dir[1]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LNKGJPHN@?4?1resource?$FL1?$FN@
CONST	SEGMENT
??_C@_0O@LNKGJPHN@?4?1resource?$FL1?$FN@ DB './resource[1]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DGMHDMIP@following?9sibling?3?3resource?$FL1?$FN@
CONST	SEGMENT
??_C@_0BP@DGMHDMIP@following?9sibling?3?3resource?$FL1?$FN@ DB 'following'
	DB	'-sibling::resource[1]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ONOBOMHP@string?$CI?$EAname?$CJ@
CONST	SEGMENT
??_C@_0O@ONOBOMHP@string?$CI?$EAname?$CJ@ DB 'string(@name)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KOEBBOFA@Validation?5of?5tests?5starting?5li@
CONST	SEGMENT
??_C@_0DB@KOEBBOFA@Validation?5of?5tests?5starting?5li@ DB 'Validation of'
	DB	' tests starting line %ld leaked %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DKMJCAPB@Failed?5to?5detect?5incorect?5RNG?5l@
CONST	SEGMENT
??_C@_0CI@DKMJCAPB@Failed?5to?5detect?5incorect?5RNG?5l@ DB 'Failed to de'
	DB	'tect incorect RNG line %ld', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NKPLANIP@out?5of?5memory?5?$CB?6@
CONST	SEGMENT
??_C@_0BB@NKPLANIP@out?5of?5memory?5?$CB?6@ DB 'out of memory !', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BODPNGCB@Failed?5to?5find?5test?5in?5correct?5@
CONST	SEGMENT
??_C@_0CJ@BODPNGCB@Failed?5to?5find?5test?5in?5correct?5@ DB 'Failed to f'
	DB	'ind test in correct line %ld', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCCMDFBL@?4?1?$CK@
CONST	SEGMENT
??_C@_03MCCMDFBL@?4?1?$CK@ DB './*', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CKJJNHKD@?4?1incorrect?$FL1?$FN@
CONST	SEGMENT
??_C@_0P@CKJJNHKD@?4?1incorrect?$FL1?$FN@ DB './incorrect[1]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NHDHPLMD@Failed?5to?5compile?5?$CFs?6@
CONST	SEGMENT
??_C@_0BG@NHDHPLMD@Failed?5to?5compile?5?$CFs?6@ DB 'Failed to compile %s'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05HHOAKHHD@xlink@
CONST	SEGMENT
??_C@_05HHOAKHHD@xlink@ DB 'xlink', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GKPMOOH@http?3?1?1www?4w3?4org?11999?1xlink@
CONST	SEGMENT
??_C@_0BN@GKPMOOH@http?3?1?1www?4w3?4org?11999?1xlink@ DB 'http://www.w3.'
	DB	'org/1999/xlink', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FHFEMMFE@ts@
CONST	SEGMENT
??_C@_02FHFEMMFE@ts@ DB 'ts', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DGPCOFBK@TestSuite@
CONST	SEGMENT
??_C@_09DGPCOFBK@TestSuite@ DB 'TestSuite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BFDMMPAI@?6?9?9?9?9?9?9?9?9?9?9?9?9?6@
CONST	SEGMENT
??_C@_0P@BFDMMPAI@?6?9?9?9?9?9?9?9?9?9?9?9?9?6@ DB 0aH, '------------', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OMNEBIPD@Too?5many?5entities?5defined?6@
CONST	SEGMENT
??_C@_0BL@OMNEBIPD@Too?5many?5entities?5defined?6@ DB 'Too many entities '
	DB	'defined', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MFIPDKLN@Exitting?5tests?5on?5fatal?5error?6@
CONST	SEGMENT
??_C@_0BP@MFIPDKLN@Exitting?5tests?5on?5fatal?5error?6@ DB 'Exitting test'
	DB	's on fatal error', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFOLEBJA@?$CFs?1?$CFs@
CONST	SEGMENT
??_C@_05GFOLEBJA@?$CFs?1?$CFs@ DB '%s/%s', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _main
_TEXT	SEGMENT
tv92 = -48						; size = 4
tv269 = -44						; size = 4
tv264 = -38						; size = 1
tv257 = -37						; size = 1
tv252 = -36						; size = 4
tv254 = -32						; size = 4
_lpFormattedStartTimeUTC$ = -28				; size = 4
_lpFormattedStartTimeLocal$ = -24			; size = 4
_lpszProgramName$ = -20					; size = 4
_old_leaks$ = -16					; size = 4
_old_tests$ = -12					; size = 4
_old_errors$ = -8					; size = 4
_ret$ = -4						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 1080 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 1081 : 	int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1082 : 	int old_errors , old_tests , old_leaks;
; 1083 : 
; 1084 : 	char *	lpszProgramName = ShowProgramInfo( );

	mov	esi, esp
	call	DWORD PTR __imp__ShowProgramInfoA@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lpszProgramName$[ebp], eax

; 1085 : 
; 1086 : 	char *  lpFormattedStartTimeLocal = FormatNowLocal( STRFTIME_DEFAULT_LOCAL_FORMAT ,

	mov	esi, esp
	push	0
	push	OFFSET ??_C@_0BF@CDOBHHMA@?$CFY?1?$CFm?1?$CFd?5?$CFH?3?$CFM?3?$CFS?5?$CFZ@
	call	DWORD PTR __imp__FormatNowLocalA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lpFormattedStartTimeLocal$[ebp], eax

; 1087 : 		                                                NULL );
; 1088 : 
; 1089 : 	if ( lpFormattedStartTimeLocal == NULL )

	cmp	DWORD PTR _lpFormattedStartTimeLocal$[ebp], 0
	jne	SHORT $LN2@main

; 1090 : 		return GetLastError( );

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN1@main
$LN2@main:

; 1091 : 
; 1092 : 	LPTSTR  lpFormattedStartTimeUTC = FormatNowUTC( STRFTIME_DEFAULT_UTC_FORMAT ,

	mov	esi, esp
	push	0
	push	OFFSET ??_C@_0BG@CBLCLCJH@?$CFY?1?$CFm?1?$CFd?5?$CFH?3?$CFM?3?$CFS?5UTC@
	call	DWORD PTR __imp__FormatNowUTCA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lpFormattedStartTimeUTC$[ebp], eax

; 1093 : 		                                             NULL );
; 1094 : 
; 1095 : 	if ( lpFormattedStartTimeUTC == NULL )

	cmp	DWORD PTR _lpFormattedStartTimeUTC$[ebp], 0
	jne	SHORT $LN3@main

; 1096 : 		return GetLastError( );

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN1@main
$LN3@main:

; 1097 : 
; 1098 : 	_tprintf( "Execution start time: UTC:  = %s (%s)\n\n" ,

	mov	eax, DWORD PTR _lpFormattedStartTimeUTC$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFormattedStartTimeLocal$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CI@ECHHPCPC@Execution?5start?5time?3?5UTC?3?5?5?$DN?5?$CF@
	call	_printf
	add	esp, 12					; 0000000cH

; 1099 : 		      lpFormattedStartTimeLocal ,
; 1100 : 		      lpFormattedStartTimeUTC );
; 1101 : 
; 1102 : 	logfile = fopen( LOGFILE ,

	mov	esi, esp
	push	OFFSET ??_C@_01NOFIACDB@w@
	push	OFFSET ??_C@_0N@NKKOPKIL@runsuite?4log@
	call	DWORD PTR __imp__fopen
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _logfile, eax

; 1103 : 		             "w" );
; 1104 : 	
; 1105 : 	if ( logfile == NULL )

	cmp	DWORD PTR _logfile, 0
	jne	SHORT $LN4@main

; 1106 : 	{
; 1107 : 		fprintf( stderr ,

	push	OFFSET ??_C@_0DG@NLJMPNNG@Could?5not?5open?5the?5log?5file?0?5ru@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1108 : 			     "Could not open the log file, running in verbose mode\n" );
; 1109 : 		verbose = 1;

	mov	DWORD PTR _verbose, 1
$LN4@main:

; 1110 : 	}	// if ( logfile == NULL )
; 1111 : 
; 1112 : 	initializeLibxml2( );

	call	_initializeLibxml2

; 1113 : 
; 1114 : 	if ( ( argc >= 2 ) && ( !strcmp( argv [ 1 ] , "-v" ) ) )

	cmp	DWORD PTR _argc$[ebp], 2
	jl	SHORT $LN5@main
	mov	DWORD PTR tv254[ebp], OFFSET ??_C@_02EJEOCNCO@?9v@
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR tv252[ebp], ecx
$LL22@main:
	mov	edx, DWORD PTR tv252[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv257[ebp], al
	mov	ecx, DWORD PTR tv254[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN23@main
	cmp	BYTE PTR tv257[ebp], 0
	je	SHORT $LN24@main
	mov	edx, DWORD PTR tv252[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv264[ebp], al
	mov	ecx, DWORD PTR tv254[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN23@main
	add	DWORD PTR tv252[ebp], 2
	add	DWORD PTR tv254[ebp], 2
	cmp	BYTE PTR tv264[ebp], 0
	jne	SHORT $LL22@main
$LN24@main:
	mov	DWORD PTR tv269[ebp], 0
	jmp	SHORT $LN25@main
$LN23@main:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv269[ebp], edx
$LN25@main:
	mov	eax, DWORD PTR tv269[ebp]
	mov	DWORD PTR tv92[ebp], eax
	cmp	DWORD PTR tv92[ebp], 0
	jne	SHORT $LN5@main

; 1115 : 		verbose = 1;

	mov	DWORD PTR _verbose, 1
$LN5@main:

; 1116 : 
; 1117 : 	old_errors = nb_errors;

	mov	ecx, DWORD PTR _nb_errors
	mov	DWORD PTR _old_errors$[ebp], ecx

; 1118 : 	old_tests = nb_tests;

	mov	edx, DWORD PTR _nb_tests
	mov	DWORD PTR _old_tests$[ebp], edx

; 1119 : 	old_leaks = nb_leaks;

	mov	eax, DWORD PTR _nb_leaks
	mov	DWORD PTR _old_leaks$[ebp], eax

; 1120 : 	xsdTest( );

	call	_xsdTest

; 1121 : 
; 1122 : 	if ( ( nb_errors == old_errors ) && ( nb_leaks == old_leaks ) )

	mov	ecx, DWORD PTR _nb_errors
	cmp	ecx, DWORD PTR _old_errors$[ebp]
	jne	SHORT $LN6@main
	mov	edx, DWORD PTR _nb_leaks
	cmp	edx, DWORD PTR _old_leaks$[ebp]
	jne	SHORT $LN6@main

; 1123 : 		printf( "Ran %d tests, no errors\n" ,

	mov	eax, DWORD PTR _nb_tests
	sub	eax, DWORD PTR _old_tests$[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@OIFNJJDH@Ran?5?$CFd?5tests?0?5no?5errors?6@
	call	_printf
	add	esp, 8
	jmp	SHORT $LN7@main
$LN6@main:

; 1124 : 			    nb_tests - old_tests );
; 1125 : 	else
; 1126 : 		printf( "Ran %d tests, %d errors, %d leaks\n" ,

	mov	ecx, DWORD PTR _nb_leaks
	sub	ecx, DWORD PTR _old_leaks$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nb_errors
	sub	edx, DWORD PTR _old_errors$[ebp]
	push	edx
	mov	eax, DWORD PTR _nb_tests
	sub	eax, DWORD PTR _old_tests$[ebp]
	push	eax
	push	OFFSET ??_C@_0CD@FKBFBNPO@Ran?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5lea@
	call	_printf
	add	esp, 16					; 00000010H
$LN7@main:

; 1127 : 			    nb_tests - old_tests ,
; 1128 : 			    nb_errors - old_errors ,
; 1129 : 			    nb_leaks - old_leaks );
; 1130 : 
; 1131 : 	old_errors = nb_errors;

	mov	ecx, DWORD PTR _nb_errors
	mov	DWORD PTR _old_errors$[ebp], ecx

; 1132 : 	old_tests = nb_tests;

	mov	edx, DWORD PTR _nb_tests
	mov	DWORD PTR _old_tests$[ebp], edx

; 1133 : 	old_leaks = nb_leaks;

	mov	eax, DWORD PTR _nb_leaks
	mov	DWORD PTR _old_leaks$[ebp], eax

; 1134 : 	rngTest1( );

	call	_rngTest1

; 1135 : 
; 1136 : 	if ( ( nb_errors == old_errors ) && ( nb_leaks == old_leaks ) )

	mov	ecx, DWORD PTR _nb_errors
	cmp	ecx, DWORD PTR _old_errors$[ebp]
	jne	SHORT $LN8@main
	mov	edx, DWORD PTR _nb_leaks
	cmp	edx, DWORD PTR _old_leaks$[ebp]
	jne	SHORT $LN8@main

; 1137 : 		printf( "Ran %d tests, no errors\n" ,

	mov	eax, DWORD PTR _nb_tests
	sub	eax, DWORD PTR _old_tests$[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@OIFNJJDH@Ran?5?$CFd?5tests?0?5no?5errors?6@
	call	_printf
	add	esp, 8
	jmp	SHORT $LN9@main
$LN8@main:

; 1138 : 			    nb_tests - old_tests );
; 1139 : 	else
; 1140 : 		printf( "Ran %d tests, %d errors, %d leaks\n" ,

	mov	ecx, DWORD PTR _nb_leaks
	sub	ecx, DWORD PTR _old_leaks$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nb_errors
	sub	edx, DWORD PTR _old_errors$[ebp]
	push	edx
	mov	eax, DWORD PTR _nb_tests
	sub	eax, DWORD PTR _old_tests$[ebp]
	push	eax
	push	OFFSET ??_C@_0CD@FKBFBNPO@Ran?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5lea@
	call	_printf
	add	esp, 16					; 00000010H
$LN9@main:

; 1141 : 			    nb_tests - old_tests ,
; 1142 : 			    nb_errors - old_errors ,
; 1143 : 			    nb_leaks - old_leaks );
; 1144 : 
; 1145 : 	old_errors = nb_errors;

	mov	ecx, DWORD PTR _nb_errors
	mov	DWORD PTR _old_errors$[ebp], ecx

; 1146 : 	old_tests = nb_tests;

	mov	edx, DWORD PTR _nb_tests
	mov	DWORD PTR _old_tests$[ebp], edx

; 1147 : 	old_leaks = nb_leaks;

	mov	eax, DWORD PTR _nb_leaks
	mov	DWORD PTR _old_leaks$[ebp], eax

; 1148 : 	rngTest2( );

	call	_rngTest2

; 1149 : 
; 1150 : 	if ( ( nb_errors == old_errors ) && ( nb_leaks == old_leaks ) )

	mov	ecx, DWORD PTR _nb_errors
	cmp	ecx, DWORD PTR _old_errors$[ebp]
	jne	SHORT $LN10@main
	mov	edx, DWORD PTR _nb_leaks
	cmp	edx, DWORD PTR _old_leaks$[ebp]
	jne	SHORT $LN10@main

; 1151 : 		printf( "Ran %d tests, no errors\n" ,

	mov	eax, DWORD PTR _nb_tests
	sub	eax, DWORD PTR _old_tests$[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@OIFNJJDH@Ran?5?$CFd?5tests?0?5no?5errors?6@
	call	_printf
	add	esp, 8
	jmp	SHORT $LN11@main
$LN10@main:

; 1152 : 			    nb_tests - old_tests );
; 1153 : 	else
; 1154 : 		printf( "Ran %d tests, %d errors, %d leaks\n" ,

	mov	ecx, DWORD PTR _nb_leaks
	sub	ecx, DWORD PTR _old_leaks$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nb_errors
	sub	edx, DWORD PTR _old_errors$[ebp]
	push	edx
	mov	eax, DWORD PTR _nb_tests
	sub	eax, DWORD PTR _old_tests$[ebp]
	push	eax
	push	OFFSET ??_C@_0CD@FKBFBNPO@Ran?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5lea@
	call	_printf
	add	esp, 16					; 00000010H
$LN11@main:

; 1155 : 			    nb_tests - old_tests ,
; 1156 : 			    nb_errors - old_errors ,
; 1157 : 			    nb_leaks - old_leaks );
; 1158 : 
; 1159 : 	old_errors = nb_errors;

	mov	ecx, DWORD PTR _nb_errors
	mov	DWORD PTR _old_errors$[ebp], ecx

; 1160 : 	old_tests = nb_tests;

	mov	edx, DWORD PTR _nb_tests
	mov	DWORD PTR _old_tests$[ebp], edx

; 1161 : 	old_leaks = nb_leaks;

	mov	eax, DWORD PTR _nb_leaks
	mov	DWORD PTR _old_leaks$[ebp], eax

; 1162 : 	nb_internals = 0;

	mov	DWORD PTR _nb_internals, 0

; 1163 : 	nb_schematas = 0;

	mov	DWORD PTR _nb_schematas, 0

; 1164 : 	xstcMetadata( "xstc/Tests/Metadata/NISTXMLSchemaDatatypes.testSet" ,

	push	OFFSET ??_C@_0BF@JAEPBNCO@xstc?1Tests?1Metadata?1@
	push	OFFSET ??_C@_0DD@EEANKDMB@xstc?1Tests?1Metadata?1NISTXMLSche@
	call	_xstcMetadata
	add	esp, 8

; 1165 : 		          "xstc/Tests/Metadata/" );
; 1166 : 
; 1167 : 	if ( ( nb_errors == old_errors ) && ( nb_leaks == old_leaks ) )

	mov	ecx, DWORD PTR _nb_errors
	cmp	ecx, DWORD PTR _old_errors$[ebp]
	jne	SHORT $LN12@main
	mov	edx, DWORD PTR _nb_leaks
	cmp	edx, DWORD PTR _old_leaks$[ebp]
	jne	SHORT $LN12@main

; 1168 : 		printf( "Ran %d tests (%d schemata), no errors\n" ,

	mov	eax, DWORD PTR _nb_schematas
	push	eax
	mov	ecx, DWORD PTR _nb_tests
	sub	ecx, DWORD PTR _old_tests$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CH@EHPPMFBH@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5no?5@
	call	_printf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN13@main
$LN12@main:

; 1169 : 			    nb_tests - old_tests ,
; 1170 : 			    nb_schematas );
; 1171 : 	else
; 1172 : 		printf( "Ran %d tests (%d schemata), %d errors (%d internals), %d leaks\n" ,

	mov	edx, DWORD PTR _nb_leaks
	sub	edx, DWORD PTR _old_leaks$[ebp]
	push	edx
	mov	eax, DWORD PTR _nb_internals
	push	eax
	mov	ecx, DWORD PTR _nb_errors
	sub	ecx, DWORD PTR _old_errors$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nb_schematas
	push	edx
	mov	eax, DWORD PTR _nb_tests
	sub	eax, DWORD PTR _old_tests$[ebp]
	push	eax
	push	OFFSET ??_C@_0EA@PNDHDNOB@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5?$CFd?5@
	call	_printf
	add	esp, 24					; 00000018H
$LN13@main:

; 1173 : 			    nb_tests - old_tests ,
; 1174 : 			    nb_schematas ,
; 1175 : 			    nb_errors - old_errors ,
; 1176 : 			    nb_internals ,
; 1177 : 			    nb_leaks - old_leaks );
; 1178 : 
; 1179 : 	old_errors = nb_errors;

	mov	ecx, DWORD PTR _nb_errors
	mov	DWORD PTR _old_errors$[ebp], ecx

; 1180 : 	old_tests = nb_tests;

	mov	edx, DWORD PTR _nb_tests
	mov	DWORD PTR _old_tests$[ebp], edx

; 1181 : 	old_leaks = nb_leaks;

	mov	eax, DWORD PTR _nb_leaks
	mov	DWORD PTR _old_leaks$[ebp], eax

; 1182 : 	nb_internals = 0;

	mov	DWORD PTR _nb_internals, 0

; 1183 : 	nb_schematas = 0;

	mov	DWORD PTR _nb_schematas, 0

; 1184 : 	xstcMetadata( "xstc/Tests/Metadata/SunXMLSchema1-0-20020116.testSet" ,

	push	OFFSET ??_C@_0M@OKJBACOM@xstc?1Tests?1@
	push	OFFSET ??_C@_0DF@OEALCOMO@xstc?1Tests?1Metadata?1SunXMLSchem@
	call	_xstcMetadata
	add	esp, 8

; 1185 : 		          "xstc/Tests/" );
; 1186 : 	
; 1187 : 	if ( ( nb_errors == old_errors ) && ( nb_leaks == old_leaks ) )

	mov	ecx, DWORD PTR _nb_errors
	cmp	ecx, DWORD PTR _old_errors$[ebp]
	jne	SHORT $LN14@main
	mov	edx, DWORD PTR _nb_leaks
	cmp	edx, DWORD PTR _old_leaks$[ebp]
	jne	SHORT $LN14@main

; 1188 : 		printf( "Ran %d tests (%d schemata), no errors\n" ,

	mov	eax, DWORD PTR _nb_schematas
	push	eax
	mov	ecx, DWORD PTR _nb_tests
	sub	ecx, DWORD PTR _old_tests$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CH@EHPPMFBH@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5no?5@
	call	_printf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN15@main
$LN14@main:

; 1189 : 			    nb_tests - old_tests ,
; 1190 : 			    nb_schematas );
; 1191 : 	else
; 1192 : 		printf( "Ran %d tests (%d schemata), %d errors (%d internals), %d leaks\n" ,

	mov	edx, DWORD PTR _nb_leaks
	sub	edx, DWORD PTR _old_leaks$[ebp]
	push	edx
	mov	eax, DWORD PTR _nb_internals
	push	eax
	mov	ecx, DWORD PTR _nb_errors
	sub	ecx, DWORD PTR _old_errors$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nb_schematas
	push	edx
	mov	eax, DWORD PTR _nb_tests
	sub	eax, DWORD PTR _old_tests$[ebp]
	push	eax
	push	OFFSET ??_C@_0EA@PNDHDNOB@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5?$CFd?5@
	call	_printf
	add	esp, 24					; 00000018H
$LN15@main:

; 1193 : 			    nb_tests - old_tests ,
; 1194 : 			    nb_schematas ,
; 1195 : 			    nb_errors - old_errors ,
; 1196 : 			    nb_internals ,
; 1197 : 			    nb_leaks - old_leaks );
; 1198 : 
; 1199 : 	old_errors = nb_errors;

	mov	ecx, DWORD PTR _nb_errors
	mov	DWORD PTR _old_errors$[ebp], ecx

; 1200 : 	old_tests = nb_tests;

	mov	edx, DWORD PTR _nb_tests
	mov	DWORD PTR _old_tests$[ebp], edx

; 1201 : 	old_leaks = nb_leaks;

	mov	eax, DWORD PTR _nb_leaks
	mov	DWORD PTR _old_leaks$[ebp], eax

; 1202 : 	nb_internals = 0;

	mov	DWORD PTR _nb_internals, 0

; 1203 : 	nb_schematas = 0;

	mov	DWORD PTR _nb_schematas, 0

; 1204 : 	xstcMetadata( "xstc/Tests/Metadata/MSXMLSchema1-0-20020116.testSet" ,

	push	OFFSET ??_C@_0M@OKJBACOM@xstc?1Tests?1@
	push	OFFSET ??_C@_0DE@CCIMICPD@xstc?1Tests?1Metadata?1MSXMLSchema@
	call	_xstcMetadata
	add	esp, 8

; 1205 : 		          "xstc/Tests/" );
; 1206 : 
; 1207 : 	if ( ( nb_errors == old_errors ) && ( nb_leaks == old_leaks ) )

	mov	ecx, DWORD PTR _nb_errors
	cmp	ecx, DWORD PTR _old_errors$[ebp]
	jne	SHORT $LN16@main
	mov	edx, DWORD PTR _nb_leaks
	cmp	edx, DWORD PTR _old_leaks$[ebp]
	jne	SHORT $LN16@main

; 1208 : 		printf( "Ran %d tests (%d schemata), no errors\n" ,

	mov	eax, DWORD PTR _nb_schematas
	push	eax
	mov	ecx, DWORD PTR _nb_tests
	sub	ecx, DWORD PTR _old_tests$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CH@EHPPMFBH@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5no?5@
	call	_printf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN17@main
$LN16@main:

; 1209 : 			    nb_tests - old_tests ,
; 1210 : 			    nb_schematas );
; 1211 : 	else
; 1212 : 		printf( "Ran %d tests (%d schemata), %d errors (%d internals), %d leaks\n" ,

	mov	edx, DWORD PTR _nb_leaks
	sub	edx, DWORD PTR _old_leaks$[ebp]
	push	edx
	mov	eax, DWORD PTR _nb_internals
	push	eax
	mov	ecx, DWORD PTR _nb_errors
	sub	ecx, DWORD PTR _old_errors$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nb_schematas
	push	edx
	mov	eax, DWORD PTR _nb_tests
	sub	eax, DWORD PTR _old_tests$[ebp]
	push	eax
	push	OFFSET ??_C@_0EA@PNDHDNOB@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5?$CFd?5@
	call	_printf
	add	esp, 24					; 00000018H
$LN17@main:

; 1213 : 			    nb_tests - old_tests ,
; 1214 : 			    nb_schematas ,
; 1215 : 			    nb_errors - old_errors ,
; 1216 : 			    nb_internals ,
; 1217 : 			    nb_leaks - old_leaks );
; 1218 : 
; 1219 : 	if ( ( nb_errors == 0 ) && ( nb_leaks == 0 ) )

	cmp	DWORD PTR _nb_errors, 0
	jne	SHORT $LN18@main
	cmp	DWORD PTR _nb_leaks, 0
	jne	SHORT $LN18@main

; 1220 : 	{
; 1221 : 		ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1222 : 		printf( "Total %d tests, no errors\n" ,

	mov	ecx, DWORD PTR _nb_tests
	push	ecx
	push	OFFSET ??_C@_0BL@HGPINOJF@Total?5?$CFd?5tests?0?5no?5errors?6@
	call	_printf
	add	esp, 8

; 1223 : 			    nb_tests );
; 1224 : 	}

	jmp	SHORT $LN19@main
$LN18@main:

; 1225 : 	else
; 1226 : 	{
; 1227 : 		ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 1228 : 		printf( "Total %d tests, %d errors, %d leaks\n" ,

	mov	edx, DWORD PTR _nb_leaks
	push	edx
	mov	eax, DWORD PTR _nb_errors
	push	eax
	mov	ecx, DWORD PTR _nb_tests
	push	ecx
	push	OFFSET ??_C@_0CF@BABBENFF@Total?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5l@
	call	_printf
	add	esp, 16					; 00000010H
$LN19@main:

; 1229 : 			    nb_tests ,
; 1230 : 			    nb_errors ,
; 1231 : 			    nb_leaks );
; 1232 : 	}	// if ( ( nb_errors == 0 ) && ( nb_leaks == 0 ) )
; 1233 : 
; 1234 : 	xmlXPathFreeContext( ctxtXPath );

	mov	edx, DWORD PTR _ctxtXPath
	push	edx
	call	_xmlXPathFreeContext
	add	esp, 4

; 1235 : 	xmlCleanupParser( );

	call	_xmlCleanupParser

; 1236 : 	xmlMemoryDump( );

	call	_xmlMemoryDump

; 1237 : 
; 1238 : 	if ( logfile != NULL )

	cmp	DWORD PTR _logfile, 0
	je	SHORT $LN20@main

; 1239 : 		fclose( logfile );

	mov	esi, esp
	mov	eax, DWORD PTR _logfile
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN20@main:

; 1240 : 
; 1241 : 	return( ret );

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@main:

; 1242 : }	// int main

	pop	edi
	pop	esi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _xstcMetadata
_TEXT	SEGMENT
_ret$ = -20						; size = 4
_name$ = -16						; size = 4
_contributor$ = -12					; size = 4
_cur$ = -8						; size = 4
_doc$ = -4						; size = 4
_metadata$ = 8						; size = 4
_base$ = 12						; size = 4
_xstcMetadata PROC					; COMDAT

; 1027 : xstcMetadata(const char *metadata, const char *base) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 1028 :     xmlDocPtr doc;
; 1029 :     xmlNodePtr cur;
; 1030 :     xmlChar *contributor;
; 1031 :     xmlChar *name;
; 1032 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1033 : 
; 1034 :     doc = xmlReadFile(metadata, NULL, XML_PARSE_NOENT);

	push	2
	push	0
	mov	eax, DWORD PTR _metadata$[ebp]
	push	eax
	call	_xmlReadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _doc$[ebp], eax

; 1035 :     if (doc == NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN4@xstcMetada

; 1036 :         fprintf(stderr, "Failed to parse %s\n", metadata);

	mov	ecx, DWORD PTR _metadata$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BE@MIGLFCAE@Failed?5to?5parse?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1037 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xstcMetada
$LN4@xstcMetada:

; 1038 :     }
; 1039 : 
; 1040 :     cur = xmlDocGetRootElement(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 1041 :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSet"))) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN6@xstcMetada
	push	OFFSET ??_C@_07DGFKPAKL@testSet@
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@xstcMetada
$LN6@xstcMetada:

; 1042 :         fprintf(stderr, "Unexpected format %s\n", metadata);

	mov	edx, DWORD PTR _metadata$[ebp]
	push	edx
	push	OFFSET ??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1043 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xstcMetada
$LN5@xstcMetada:

; 1044 :     }
; 1045 :     contributor = xmlGetProp(cur, BAD_CAST "contributor");

	push	OFFSET ??_C@_0M@EECBLNBL@contributor@
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _contributor$[ebp], eax

; 1046 :     if (contributor == NULL) {

	cmp	DWORD PTR _contributor$[ebp], 0
	jne	SHORT $LN7@xstcMetada

; 1047 :         contributor = xmlStrdup(BAD_CAST "Unknown");

	push	OFFSET ??_C@_07NBCGADJA@Unknown@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _contributor$[ebp], eax
$LN7@xstcMetada:

; 1048 :     }
; 1049 :     name = xmlGetProp(cur, BAD_CAST "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _name$[ebp], eax

; 1050 :     if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN8@xstcMetada

; 1051 :         name = xmlStrdup(BAD_CAST "Unknown");

	push	OFFSET ??_C@_07NBCGADJA@Unknown@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax
$LN8@xstcMetada:

; 1052 :     }
; 1053 :     printf("## %s test suite for Schemas version %s\n", contributor, name);

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _contributor$[ebp]
	push	eax
	push	OFFSET ??_C@_0CJ@PEBJNNOD@?$CD?$CD?5?$CFs?5test?5suite?5for?5Schemas?5ve@
	call	_printf
	add	esp, 12					; 0000000cH

; 1054 :     xmlFree(contributor);

	mov	esi, esp
	mov	ecx, DWORD PTR _contributor$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1055 :     xmlFree(name);

	mov	esi, esp
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1056 : 
; 1057 :     cur = getNext(cur, "./ts:testGroup[1]");

	push	OFFSET ??_C@_0BC@LOBCMKNF@?4?1ts?3testGroup?$FL1?$FN@
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1058 :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testGroup"))) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN10@xstcMetada
	push	OFFSET ??_C@_09EANEKJKI@testGroup@
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@xstcMetada
$LN10@xstcMetada:

; 1059 :         fprintf(stderr, "Unexpected format %s\n", metadata);

	mov	ecx, DWORD PTR _metadata$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1060 : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 1061 : 	goto done;

	jmp	SHORT $done$12
$LN2@xstcMetada:

; 1062 :     }
; 1063 :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $done$12

; 1064 :         xstcTestGroup(cur, base);

	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xstcTestGroup
	add	esp, 8

; 1065 : 	cur = getNext(cur, "following-sibling::ts:testGroup[1]");

	push	OFFSET ??_C@_0CD@EPMPPHIO@following?9sibling?3?3ts?3testGroup@
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1066 :     }

	jmp	SHORT $LN2@xstcMetada
$done$12:

; 1067 : 
; 1068 : done:
; 1069 :     xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 1070 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xstcMetada:

; 1071 : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xstcMetadata ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _xstcTestGroup
_TEXT	SEGMENT
_mem$ = -32						; size = 4
_ret$ = -28						; size = 4
_instance$ = -24					; size = 4
_ctxt$ = -20						; size = 4
_schemas$ = -16						; size = 4
_validity$ = -12					; size = 4
_path$ = -8						; size = 4
_href$ = -4						; size = 4
_cur$ = 8						; size = 4
_base$ = 12						; size = 4
_xstcTestGroup PROC					; COMDAT

; 905  : xstcTestGroup(xmlNodePtr cur, const char *base) {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 906  :     xmlChar *href = NULL;

	mov	DWORD PTR _href$[ebp], 0

; 907  :     xmlChar *path = NULL;

	mov	DWORD PTR _path$[ebp], 0

; 908  :     xmlChar *validity = NULL;

	mov	DWORD PTR _validity$[ebp], 0

; 909  :     xmlSchemaPtr schemas = NULL;

	mov	DWORD PTR _schemas$[ebp], 0

; 910  :     xmlSchemaParserCtxtPtr ctxt;
; 911  :     xmlNodePtr instance;
; 912  :     int ret = 0, mem;

	mov	DWORD PTR _ret$[ebp], 0

; 913  : 
; 914  :     xmlResetLastError();

	call	_xmlResetLastError

; 915  :     testErrorsSize = 0; testErrors[0] = 0;

	mov	DWORD PTR _testErrorsSize, 0
	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _testErrors[ecx], 0

; 916  :     mem = xmlMemUsed();

	call	_xmlMemUsed
	mov	DWORD PTR _mem$[ebp], eax

; 917  :     href = getString(cur,

	push	OFFSET ??_C@_0DE@ONCAFCLF@string?$CIts?3schemaTest?1ts?3schemaD@
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_getString
	add	esp, 8
	mov	DWORD PTR _href$[ebp], eax

; 918  :                      "string(ts:schemaTest/ts:schemaDocument/@xlink:href)");
; 919  :     if ((href == NULL) || (href[0] == 0)) {

	cmp	DWORD PTR _href$[ebp], 0
	je	SHORT $LN5@xstcTestGr
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _href$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN4@xstcTestGr
$LN5@xstcTestGr:

; 920  :         test_log("testGroup line %ld misses href for schemaDocument\n",

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DD@HGOIGGEJ@testGroup?5line?5?$CFld?5misses?5href?5@
	call	_test_log
	add	esp, 8

; 921  : 		    xmlGetLineNo(cur));
; 922  : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 923  : 	goto done;

	jmp	$done$25
$LN4@xstcTestGr:

; 924  :     }
; 925  :     path = xmlBuildURI(href, BAD_CAST base);

	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _href$[ebp]
	push	eax
	call	_xmlBuildURI
	add	esp, 8
	mov	DWORD PTR _path$[ebp], eax

; 926  :     if (path == NULL) {

	cmp	DWORD PTR _path$[ebp], 0
	jne	SHORT $LN6@xstcTestGr

; 927  : 	test_log("Failed to build path to schemas testGroup line %ld : %s\n",

	mov	ecx, DWORD PTR _href$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DJ@ODKNMILE@Failed?5to?5build?5path?5to?5schemas@
	call	_test_log
	add	esp, 12					; 0000000cH

; 928  : 		xmlGetLineNo(cur), href);
; 929  : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 930  : 	goto done;

	jmp	$done$25
$LN6@xstcTestGr:

; 931  :     }
; 932  :     if (checkTestFile((const char *) path) <= 0) {

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_checkTestFile
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN7@xstcTestGr

; 933  : 	test_log("schemas for testGroup line %ld is missing: %s\n",

	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CP@OLLDHGKK@schemas?5for?5testGroup?5line?5?$CFld?5@
	call	_test_log
	add	esp, 12					; 0000000cH

; 934  : 		xmlGetLineNo(cur), path);
; 935  : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 936  : 	goto done;

	jmp	$done$25
$LN7@xstcTestGr:

; 937  :     }
; 938  :     validity = getString(cur,

	push	OFFSET ??_C@_0CM@KEHKFIFH@string?$CIts?3schemaTest?1ts?3expecte@
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_getString
	add	esp, 8
	mov	DWORD PTR _validity$[ebp], eax

; 939  :                          "string(ts:schemaTest/ts:expected/@validity)");
; 940  :     if (validity == NULL) {

	cmp	DWORD PTR _validity$[ebp], 0
	jne	SHORT $LN8@xstcTestGr

; 941  :         test_log("testGroup line %ld misses expected validity\n",

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CN@KBELDKMH@testGroup?5line?5?$CFld?5misses?5expec@
	call	_test_log
	add	esp, 8

; 942  : 	        xmlGetLineNo(cur));
; 943  : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 944  : 	goto done;

	jmp	$done$25
$LN8@xstcTestGr:

; 945  :     }
; 946  :     nb_tests++;

	mov	edx, DWORD PTR _nb_tests
	add	edx, 1
	mov	DWORD PTR _nb_tests, edx

; 947  :     if (xmlStrEqual(validity, BAD_CAST "valid")) {

	push	OFFSET ??_C@_05HDPIMK@valid@
	mov	eax, DWORD PTR _validity$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN9@xstcTestGr

; 948  :         nb_schematas++;

	mov	ecx, DWORD PTR _nb_schematas
	add	ecx, 1
	mov	DWORD PTR _nb_schematas, ecx

; 949  : 	ctxt = xmlSchemaNewParserCtxt((const char *) path);

	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_xmlSchemaNewParserCtxt
	add	esp, 4
	mov	DWORD PTR _ctxt$[ebp], eax

; 950  : 	xmlSchemaSetParserErrors(ctxt,

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	push	OFFSET _testErrorHandler
	push	OFFSET _testErrorHandler
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSchemaSetParserErrors
	add	esp, 16					; 00000010H

; 951  : 	     (xmlSchemaValidityErrorFunc) testErrorHandler,
; 952  : 	     (xmlSchemaValidityWarningFunc) testErrorHandler,
; 953  : 	     ctxt);
; 954  : 	schemas = xmlSchemaParse(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSchemaParse
	add	esp, 4
	mov	DWORD PTR _schemas$[ebp], eax

; 955  : 	xmlSchemaFreeParserCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSchemaFreeParserCtxt
	add	esp, 4

; 956  : 	if (schemas == NULL) {

	cmp	DWORD PTR _schemas$[ebp], 0
	jne	SHORT $LN11@xstcTestGr

; 957  : 	    test_log("valid schemas %s failed to parse\n",

	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CC@MDMCGIDK@valid?5schemas?5?$CFs?5failed?5to?5pars@
	call	_test_log
	add	esp, 8

; 958  : 			path);
; 959  : 	    ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 960  : 	    nb_errors++;

	mov	edx, DWORD PTR _nb_errors
	add	edx, 1
	mov	DWORD PTR _nb_errors, edx
$LN11@xstcTestGr:

; 961  : 	}
; 962  : 	if ((ret == 0) && (strstr(testErrors, "nimplemented") != NULL)) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN12@xstcTestGr
	push	OFFSET ??_C@_0N@MBLKFBIB@nimplemented@
	push	OFFSET _testErrors
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xstcTestGr

; 963  : 	    test_log("valid schemas %s hit an unimplemented block\n",

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET ??_C@_0CN@ELPOJJMN@valid?5schemas?5?$CFs?5hit?5an?5unimple@
	call	_test_log
	add	esp, 8

; 964  : 			path);
; 965  : 	    ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 966  : 	    nb_unimplemented++;

	mov	ecx, DWORD PTR _nb_unimplemented
	add	ecx, 1
	mov	DWORD PTR _nb_unimplemented, ecx

; 967  : 	    nb_errors++;

	mov	edx, DWORD PTR _nb_errors
	add	edx, 1
	mov	DWORD PTR _nb_errors, edx
$LN12@xstcTestGr:

; 968  : 	}
; 969  : 	instance = getNext(cur, "./ts:instanceTest[1]");

	push	OFFSET ??_C@_0BF@KAPKJJJH@?4?1ts?3instanceTest?$FL1?$FN@
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _instance$[ebp], eax
$LN2@xstcTestGr:

; 970  : 	while (instance != NULL) {

	cmp	DWORD PTR _instance$[ebp], 0
	je	SHORT $LN3@xstcTestGr

; 971  : 	    if (schemas != NULL) {

	cmp	DWORD PTR _schemas$[ebp], 0
	je	SHORT $LN13@xstcTestGr

; 972  : 		xstcTestInstance(instance, schemas, path, base);

	mov	ecx, DWORD PTR _base$[ebp]
	push	ecx
	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	eax, DWORD PTR _schemas$[ebp]
	push	eax
	mov	ecx, DWORD PTR _instance$[ebp]
	push	ecx
	call	_xstcTestInstance
	add	esp, 16					; 00000010H

; 973  : 	    } else {

	jmp	SHORT $LN14@xstcTestGr
$LN13@xstcTestGr:

; 974  : 		/*
; 975  : 		* We'll automatically mark the instances as failed
; 976  : 		* if the schema was broken.
; 977  : 		*/
; 978  : 		nb_errors++;

	mov	edx, DWORD PTR _nb_errors
	add	edx, 1
	mov	DWORD PTR _nb_errors, edx
$LN14@xstcTestGr:

; 979  : 	    }
; 980  : 	    instance = getNext(instance,

	push	OFFSET ??_C@_0CG@FCJJLOOA@following?9sibling?3?3ts?3instanceT@
	mov	eax, DWORD PTR _instance$[ebp]
	push	eax
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _instance$[ebp], eax

; 981  : 		"following-sibling::ts:instanceTest[1]");
; 982  : 	}

	jmp	SHORT $LN2@xstcTestGr
$LN3@xstcTestGr:

; 983  :     } else if (xmlStrEqual(validity, BAD_CAST "invalid")) {

	jmp	$done$25
$LN9@xstcTestGr:
	push	OFFSET ??_C@_07MALOAKCI@invalid@
	mov	ecx, DWORD PTR _validity$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN15@xstcTestGr

; 984  :         nb_schematas++;

	mov	edx, DWORD PTR _nb_schematas
	add	edx, 1
	mov	DWORD PTR _nb_schematas, edx

; 985  : 	ctxt = xmlSchemaNewParserCtxt((const char *) path);

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_xmlSchemaNewParserCtxt
	add	esp, 4
	mov	DWORD PTR _ctxt$[ebp], eax

; 986  : 	xmlSchemaSetParserErrors(ctxt,

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	push	OFFSET _testErrorHandler
	push	OFFSET _testErrorHandler
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSchemaSetParserErrors
	add	esp, 16					; 00000010H

; 987  : 	     (xmlSchemaValidityErrorFunc) testErrorHandler,
; 988  : 	     (xmlSchemaValidityWarningFunc) testErrorHandler,
; 989  : 	     ctxt);
; 990  : 	schemas = xmlSchemaParse(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSchemaParse
	add	esp, 4
	mov	DWORD PTR _schemas$[ebp], eax

; 991  : 	xmlSchemaFreeParserCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSchemaFreeParserCtxt
	add	esp, 4

; 992  : 	if (schemas != NULL) {

	cmp	DWORD PTR _schemas$[ebp], 0
	je	SHORT $LN17@xstcTestGr

; 993  : 	    test_log("Failed to detect error in schemas %s\n",

	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	push	OFFSET ??_C@_0CG@PIGAEOBP@Failed?5to?5detect?5error?5in?5schem@
	call	_test_log
	add	esp, 8

; 994  : 			path);
; 995  : 	    nb_errors++;

	mov	eax, DWORD PTR _nb_errors
	add	eax, 1
	mov	DWORD PTR _nb_errors, eax

; 996  : 	    ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN17@xstcTestGr:

; 997  : 	}
; 998  : 	if ((ret == 0) && (strstr(testErrors, "nimplemented") != NULL)) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN18@xstcTestGr
	push	OFFSET ??_C@_0N@MBLKFBIB@nimplemented@
	push	OFFSET _testErrors
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xstcTestGr

; 999  : 	    nb_unimplemented++;

	mov	ecx, DWORD PTR _nb_unimplemented
	add	ecx, 1
	mov	DWORD PTR _nb_unimplemented, ecx

; 1000 : 	    test_log("invalid schemas %s hit an unimplemented block\n",

	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	push	OFFSET ??_C@_0CP@HIGMEMKG@invalid?5schemas?5?$CFs?5hit?5an?5unimp@
	call	_test_log
	add	esp, 8

; 1001 : 			path);
; 1002 : 	    ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 1003 : 	    nb_errors++;

	mov	eax, DWORD PTR _nb_errors
	add	eax, 1
	mov	DWORD PTR _nb_errors, eax
$LN18@xstcTestGr:

; 1004 : 	}
; 1005 :     } else {

	jmp	SHORT $done$25
$LN15@xstcTestGr:

; 1006 :         test_log("testGroup line %ld misses unexpected validity value%s\n",

	mov	ecx, DWORD PTR _validity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DH@MPCAIJDE@testGroup?5line?5?$CFld?5misses?5unexp@
	call	_test_log
	add	esp, 12					; 0000000cH

; 1007 : 	        xmlGetLineNo(cur), validity);
; 1008 : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1
$done$25:

; 1009 : 	goto done;
; 1010 :     }
; 1011 : 
; 1012 : done:
; 1013 :     if (href != NULL) xmlFree(href);

	cmp	DWORD PTR _href$[ebp], 0
	je	SHORT $LN19@xstcTestGr
	mov	esi, esp
	mov	eax, DWORD PTR _href$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	mov	edx, DWORD PTR [ecx]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN19@xstcTestGr:

; 1014 :     if (path != NULL) xmlFree(path);

	cmp	DWORD PTR _path$[ebp], 0
	je	SHORT $LN20@xstcTestGr
	mov	esi, esp
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	mov	edx, DWORD PTR [ecx]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN20@xstcTestGr:

; 1015 :     if (validity != NULL) xmlFree(validity);

	cmp	DWORD PTR _validity$[ebp], 0
	je	SHORT $LN21@xstcTestGr
	mov	esi, esp
	mov	eax, DWORD PTR _validity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	mov	edx, DWORD PTR [ecx]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN21@xstcTestGr:

; 1016 :     if (schemas != NULL) xmlSchemaFree(schemas);

	cmp	DWORD PTR _schemas$[ebp], 0
	je	SHORT $LN22@xstcTestGr
	mov	eax, DWORD PTR _schemas$[ebp]
	push	eax
	call	_xmlSchemaFree
	add	esp, 4
$LN22@xstcTestGr:

; 1017 :     xmlResetLastError();

	call	_xmlResetLastError

; 1018 :     if ((mem != xmlMemUsed()) && (extraMemoryFromResolver == 0)) {

	call	_xmlMemUsed
	cmp	DWORD PTR _mem$[ebp], eax
	je	SHORT $LN23@xstcTestGr
	cmp	DWORD PTR _extraMemoryFromResolver, 0
	jne	SHORT $LN23@xstcTestGr

; 1019 : 	test_log("Processing test line %ld %s leaked %d\n",

	call	_xmlMemUsed
	sub	eax, DWORD PTR _mem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CH@MEDDADMO@Processing?5test?5line?5?$CFld?5?$CFs?5lea@
	call	_test_log
	add	esp, 16					; 00000010H

; 1020 : 		xmlGetLineNo(cur), path, xmlMemUsed() - mem);
; 1021 : 	nb_leaks++;

	mov	eax, DWORD PTR _nb_leaks
	add	eax, 1
	mov	DWORD PTR _nb_leaks, eax
$LN23@xstcTestGr:

; 1022 :     }
; 1023 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]

; 1024 : }

	pop	esi
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xstcTestGroup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _xstcTestInstance
_TEXT	SEGMENT
_mem$ = -28						; size = 4
_ret$ = -24						; size = 4
_doc$ = -20						; size = 4
_ctxt$ = -16						; size = 4
_validity$ = -12					; size = 4
_path$ = -8						; size = 4
_href$ = -4						; size = 4
_cur$ = 8						; size = 4
_schemas$ = 12						; size = 4
_spath$ = 16						; size = 4
_base$ = 20						; size = 4
_xstcTestInstance PROC					; COMDAT

; 808  :                  const xmlChar *spath, const char *base) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 809  :     xmlChar *href = NULL;

	mov	DWORD PTR _href$[ebp], 0

; 810  :     xmlChar *path = NULL;

	mov	DWORD PTR _path$[ebp], 0

; 811  :     xmlChar *validity = NULL;

	mov	DWORD PTR _validity$[ebp], 0

; 812  :     xmlSchemaValidCtxtPtr ctxt = NULL;

	mov	DWORD PTR _ctxt$[ebp], 0

; 813  :     xmlDocPtr doc = NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 814  :     int ret = 0, mem;

	mov	DWORD PTR _ret$[ebp], 0

; 815  : 
; 816  :     xmlResetLastError();

	call	_xmlResetLastError

; 817  :     testErrorsSize = 0; testErrors[0] = 0;

	mov	DWORD PTR _testErrorsSize, 0
	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _testErrors[ecx], 0

; 818  :     mem = xmlMemUsed();

	call	_xmlMemUsed
	mov	DWORD PTR _mem$[ebp], eax

; 819  :     href = getString(cur,

	push	OFFSET ??_C@_0CI@CMJHJDGI@string?$CIts?3instanceDocument?1?$EAxli@
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_getString
	add	esp, 8
	mov	DWORD PTR _href$[ebp], eax

; 820  :                      "string(ts:instanceDocument/@xlink:href)");
; 821  :     if ((href == NULL) || (href[0] == 0)) {

	cmp	DWORD PTR _href$[ebp], 0
	je	SHORT $LN3@xstcTestIn
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _href$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN2@xstcTestIn
$LN3@xstcTestIn:

; 822  : 	test_log("testGroup line %ld misses href for schemaDocument\n",

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DD@HGOIGGEJ@testGroup?5line?5?$CFld?5misses?5href?5@
	call	_test_log
	add	esp, 8

; 823  : 		    xmlGetLineNo(cur));
; 824  : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 825  : 	goto done;

	jmp	$done$23
$LN2@xstcTestIn:

; 826  :     }
; 827  :     path = xmlBuildURI(href, BAD_CAST base);

	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _href$[ebp]
	push	eax
	call	_xmlBuildURI
	add	esp, 8
	mov	DWORD PTR _path$[ebp], eax

; 828  :     if (path == NULL) {

	cmp	DWORD PTR _path$[ebp], 0
	jne	SHORT $LN4@xstcTestIn

; 829  : 	fprintf(stderr,

	mov	ecx, DWORD PTR _href$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DJ@ODKNMILE@Failed?5to?5build?5path?5to?5schemas@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 830  : 	        "Failed to build path to schemas testGroup line %ld : %s\n",
; 831  : 		xmlGetLineNo(cur), href);
; 832  : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 833  : 	goto done;

	jmp	$done$23
$LN4@xstcTestIn:

; 834  :     }
; 835  :     if (checkTestFile((const char *) path) <= 0) {

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_checkTestFile
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN5@xstcTestIn

; 836  : 	test_log("schemas for testGroup line %ld is missing: %s\n",

	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CP@OLLDHGKK@schemas?5for?5testGroup?5line?5?$CFld?5@
	call	_test_log
	add	esp, 12					; 0000000cH

; 837  : 		xmlGetLineNo(cur), path);
; 838  : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 839  : 	goto done;

	jmp	$done$23
$LN5@xstcTestIn:

; 840  :     }
; 841  :     validity = getString(cur,

	push	OFFSET ??_C@_0BO@LLDGLFOO@string?$CIts?3expected?1?$EAvalidity?$CJ@
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_getString
	add	esp, 8
	mov	DWORD PTR _validity$[ebp], eax

; 842  :                          "string(ts:expected/@validity)");
; 843  :     if (validity == NULL) {

	cmp	DWORD PTR _validity$[ebp], 0
	jne	SHORT $LN6@xstcTestIn

; 844  :         fprintf(stderr, "instanceDocument line %ld misses expected validity\n",

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DE@ELAIJGEI@instanceDocument?5line?5?$CFld?5misse@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 845  : 	        xmlGetLineNo(cur));
; 846  : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 847  : 	goto done;

	jmp	$done$23
$LN6@xstcTestIn:

; 848  :     }
; 849  :     nb_tests++;

	mov	edx, DWORD PTR _nb_tests
	add	edx, 1
	mov	DWORD PTR _nb_tests, edx

; 850  :     doc = xmlReadFile((const char *) path, NULL, XML_PARSE_NOENT);

	push	2
	push	0
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_xmlReadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _doc$[ebp], eax

; 851  :     if (doc == NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN7@xstcTestIn

; 852  :         fprintf(stderr, "instance %s fails to parse\n", path);

	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BM@MMDCFNIM@instance?5?$CFs?5fails?5to?5parse?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 853  : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 854  : 	nb_errors++;

	mov	edx, DWORD PTR _nb_errors
	add	edx, 1
	mov	DWORD PTR _nb_errors, edx

; 855  : 	goto done;

	jmp	$done$23
$LN7@xstcTestIn:

; 856  :     }
; 857  : 
; 858  :     ctxt = xmlSchemaNewValidCtxt(schemas);

	mov	eax, DWORD PTR _schemas$[ebp]
	push	eax
	call	_xmlSchemaNewValidCtxt
	add	esp, 4
	mov	DWORD PTR _ctxt$[ebp], eax

; 859  :     xmlSchemaSetValidErrors(ctxt,

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	push	OFFSET _testErrorHandler
	push	OFFSET _testErrorHandler
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSchemaSetValidErrors
	add	esp, 16					; 00000010H

; 860  :          (xmlSchemaValidityErrorFunc) testErrorHandler,
; 861  :          (xmlSchemaValidityWarningFunc) testErrorHandler,
; 862  : 	 ctxt);
; 863  :     ret = xmlSchemaValidateDoc(ctxt, doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSchemaValidateDoc
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 864  : 
; 865  :     if (xmlStrEqual(validity, BAD_CAST "valid")) {

	push	OFFSET ??_C@_05HDPIMK@valid@
	mov	edx, DWORD PTR _validity$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xstcTestIn

; 866  : 	if (ret > 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jle	SHORT $LN10@xstcTestIn

; 867  : 	    test_log("valid instance %s failed to validate against %s\n",

	mov	eax, DWORD PTR _spath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DB@MEJOFODP@valid?5instance?5?$CFs?5failed?5to?5val@
	call	_test_log
	add	esp, 12					; 0000000cH

; 868  : 			path, spath);
; 869  : 	    nb_errors++;

	mov	edx, DWORD PTR _nb_errors
	add	edx, 1
	mov	DWORD PTR _nb_errors, edx
	jmp	SHORT $LN11@xstcTestIn
$LN10@xstcTestIn:

; 870  : 	} else if (ret < 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN11@xstcTestIn

; 871  : 	    test_log("valid instance %s got internal error validating %s\n",

	mov	eax, DWORD PTR _spath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DE@PEFCJFEE@valid?5instance?5?$CFs?5got?5internal?5@
	call	_test_log
	add	esp, 12					; 0000000cH

; 872  : 			path, spath);
; 873  : 	    nb_internals++;

	mov	edx, DWORD PTR _nb_internals
	add	edx, 1
	mov	DWORD PTR _nb_internals, edx

; 874  : 	    nb_errors++;

	mov	eax, DWORD PTR _nb_errors
	add	eax, 1
	mov	DWORD PTR _nb_errors, eax
$LN11@xstcTestIn:

; 875  : 	}

	jmp	SHORT $done$23
$LN8@xstcTestIn:

; 876  :     } else if (xmlStrEqual(validity, BAD_CAST "invalid")) {

	push	OFFSET ??_C@_07MALOAKCI@invalid@
	mov	ecx, DWORD PTR _validity$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xstcTestIn

; 877  : 	if (ret == 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN15@xstcTestIn

; 878  : 	    test_log("Failed to detect invalid instance %s against %s\n",

	mov	edx, DWORD PTR _spath$[ebp]
	push	edx
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET ??_C@_0DB@NHKLIBPD@Failed?5to?5detect?5invalid?5instan@
	call	_test_log
	add	esp, 12					; 0000000cH

; 879  : 			path, spath);
; 880  : 	    nb_errors++;

	mov	ecx, DWORD PTR _nb_errors
	add	ecx, 1
	mov	DWORD PTR _nb_errors, ecx
$LN15@xstcTestIn:

; 881  : 	}
; 882  :     } else {

	jmp	SHORT $done$23
$LN13@xstcTestIn:

; 883  :         test_log("instanceDocument line %ld has unexpected validity value%s\n",

	mov	edx, DWORD PTR _validity$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DL@GJKHAOCE@instanceDocument?5line?5?$CFld?5has?5u@
	call	_test_log
	add	esp, 12					; 0000000cH

; 884  : 	        xmlGetLineNo(cur), validity);
; 885  : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1
$done$23:

; 886  : 	goto done;
; 887  :     }
; 888  : 
; 889  : done:
; 890  :     if (href != NULL) xmlFree(href);

	cmp	DWORD PTR _href$[ebp], 0
	je	SHORT $LN16@xstcTestIn
	mov	esi, esp
	mov	ecx, DWORD PTR _href$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@xstcTestIn:

; 891  :     if (path != NULL) xmlFree(path);

	cmp	DWORD PTR _path$[ebp], 0
	je	SHORT $LN17@xstcTestIn
	mov	esi, esp
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@xstcTestIn:

; 892  :     if (validity != NULL) xmlFree(validity);

	cmp	DWORD PTR _validity$[ebp], 0
	je	SHORT $LN18@xstcTestIn
	mov	esi, esp
	mov	ecx, DWORD PTR _validity$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@xstcTestIn:

; 893  :     if (ctxt != NULL) xmlSchemaFreeValidCtxt(ctxt);

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN19@xstcTestIn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSchemaFreeValidCtxt
	add	esp, 4
$LN19@xstcTestIn:

; 894  :     if (doc != NULL) xmlFreeDoc(doc);

	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN20@xstcTestIn
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4
$LN20@xstcTestIn:

; 895  :     xmlResetLastError();

	call	_xmlResetLastError

; 896  :     if (mem != xmlMemUsed()) {

	call	_xmlMemUsed
	cmp	DWORD PTR _mem$[ebp], eax
	je	SHORT $LN21@xstcTestIn

; 897  : 	test_log("Validation of tests starting line %ld leaked %d\n",

	call	_xmlMemUsed
	sub	eax, DWORD PTR _mem$[ebp]
	push	eax
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DB@KOEBBOFA@Validation?5of?5tests?5starting?5li@
	call	_test_log
	add	esp, 12					; 0000000cH

; 898  : 		xmlGetLineNo(cur), xmlMemUsed() - mem);
; 899  : 	nb_leaks++;

	mov	ecx, DWORD PTR _nb_leaks
	add	ecx, 1
	mov	DWORD PTR _nb_leaks, ecx
$LN21@xstcTestIn:

; 900  :     }
; 901  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]

; 902  : }

	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xstcTestInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _rngTest2
_TEXT	SEGMENT
_ret$ = -16						; size = 4
_filename$ = -12					; size = 4
_cur$ = -8						; size = 4
_doc$ = -4						; size = 4
_rngTest2 PROC						; COMDAT

; 763  : rngTest2(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 764  :     xmlDocPtr doc;
; 765  :     xmlNodePtr cur;
; 766  :     const char *filename = "test/relaxng/testsuite.xml";

	mov	DWORD PTR _filename$[ebp], OFFSET ??_C@_0BL@INNHDNAD@test?1relaxng?1testsuite?4xml@

; 767  :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 768  : 
; 769  :     doc = xmlReadFile(filename, NULL, XML_PARSE_NOENT);

	push	2
	push	0
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlReadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _doc$[ebp], eax

; 770  :     if (doc == NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN4@rngTest2

; 771  :         fprintf(stderr, "Failed to parse %s\n", filename);

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BE@MIGLFCAE@Failed?5to?5parse?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 772  : 	return(-1);

	or	eax, -1
	jmp	$LN1@rngTest2
$LN4@rngTest2:

; 773  :     }
; 774  :     printf("## Relax NG test suite for libxml2\n");

	push	OFFSET ??_C@_0CE@PPJGKGKI@?$CD?$CD?5Relax?5NG?5test?5suite?5for?5libx@
	call	_printf
	add	esp, 4

; 775  : 
; 776  :     cur = xmlDocGetRootElement(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 777  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN6@rngTest2
	push	OFFSET ??_C@_09HJKPOGMK@testSuite@
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@rngTest2
$LN6@rngTest2:

; 778  :         fprintf(stderr, "Unexpected format %s\n", filename);

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET ??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 779  : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 780  : 	goto done;

	jmp	$done$11
$LN5@rngTest2:

; 781  :     }
; 782  : 
; 783  :     cur = getNext(cur, "./testSuite[1]");

	push	OFFSET ??_C@_0P@MCCEHCEB@?4?1testSuite?$FL1?$FN@
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 784  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN8@rngTest2
	push	OFFSET ??_C@_09HJKPOGMK@testSuite@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@rngTest2
$LN8@rngTest2:

; 785  :         fprintf(stderr, "Unexpected format %s\n", filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 786  : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 787  : 	goto done;

	jmp	SHORT $done$11
$LN2@rngTest2:

; 788  :     }
; 789  :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $done$11

; 790  :         xsdTestSuite(cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xsdTestSuite
	add	esp, 4

; 791  : 	cur = getNext(cur, "following-sibling::testSuite[1]");

	push	OFFSET ??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 792  :     }

	jmp	SHORT $LN2@rngTest2
$done$11:

; 793  : 
; 794  : done:
; 795  :     if (doc != NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN9@rngTest2

; 796  : 	xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN9@rngTest2:

; 797  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@rngTest2:

; 798  : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_rngTest2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _rngTest1
_TEXT	SEGMENT
_ret$ = -16						; size = 4
_filename$ = -12					; size = 4
_cur$ = -8						; size = 4
_doc$ = -4						; size = 4
_rngTest1 PROC						; COMDAT

; 725  : rngTest1(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 726  :     xmlDocPtr doc;
; 727  :     xmlNodePtr cur;
; 728  :     const char *filename = "test/relaxng/OASIS/spectest.xml";

	mov	DWORD PTR _filename$[ebp], OFFSET ??_C@_0CA@KKAOGFMP@test?1relaxng?1OASIS?1spectest?4xml@

; 729  :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 730  : 
; 731  :     doc = xmlReadFile(filename, NULL, XML_PARSE_NOENT);

	push	2
	push	0
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlReadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _doc$[ebp], eax

; 732  :     if (doc == NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN4@rngTest1

; 733  :         fprintf(stderr, "Failed to parse %s\n", filename);

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BE@MIGLFCAE@Failed?5to?5parse?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 734  : 	return(-1);

	or	eax, -1
	jmp	$LN1@rngTest1
$LN4@rngTest1:

; 735  :     }
; 736  :     printf("## Relax NG test suite from James Clark\n");

	push	OFFSET ??_C@_0CJ@HIMBOBNB@?$CD?$CD?5Relax?5NG?5test?5suite?5from?5Jam@
	call	_printf
	add	esp, 4

; 737  : 
; 738  :     cur = xmlDocGetRootElement(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 739  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN6@rngTest1
	push	OFFSET ??_C@_09HJKPOGMK@testSuite@
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@rngTest1
$LN6@rngTest1:

; 740  :         fprintf(stderr, "Unexpected format %s\n", filename);

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET ??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 741  : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 742  : 	goto done;

	jmp	$done$11
$LN5@rngTest1:

; 743  :     }
; 744  : 
; 745  :     cur = getNext(cur, "./testSuite[1]");

	push	OFFSET ??_C@_0P@MCCEHCEB@?4?1testSuite?$FL1?$FN@
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 746  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN8@rngTest1
	push	OFFSET ??_C@_09HJKPOGMK@testSuite@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@rngTest1
$LN8@rngTest1:

; 747  :         fprintf(stderr, "Unexpected format %s\n", filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 748  : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 749  : 	goto done;

	jmp	SHORT $done$11
$LN2@rngTest1:

; 750  :     }
; 751  :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $done$11

; 752  :         rngTestSuite(cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_rngTestSuite
	add	esp, 4

; 753  : 	cur = getNext(cur, "following-sibling::testSuite[1]");

	push	OFFSET ??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 754  :     }

	jmp	SHORT $LN2@rngTest1
$done$11:

; 755  : 
; 756  : done:
; 757  :     if (doc != NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN9@rngTest1

; 758  : 	xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN9@rngTest1:

; 759  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@rngTest1:

; 760  : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_rngTest1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _rngTestSuite
_TEXT	SEGMENT
_doc$1 = -4						; size = 4
_cur$ = 8						; size = 4
_rngTestSuite PROC					; COMDAT

; 700  : rngTestSuite(xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 701  :     if (verbose) {

	cmp	DWORD PTR _verbose, 0
	je	$LN4@rngTestSui

; 702  : 	xmlChar *doc = getString(cur, "string(documentation)");

	push	OFFSET ??_C@_0BG@IHDGFAMN@string?$CIdocumentation?$CJ@
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_getString
	add	esp, 8
	mov	DWORD PTR _doc$1[ebp], eax

; 703  : 
; 704  : 	if (doc != NULL) {

	cmp	DWORD PTR _doc$1[ebp], 0
	je	SHORT $LN5@rngTestSui

; 705  : 	    printf("Suite %s\n", doc);

	mov	ecx, DWORD PTR _doc$1[ebp]
	push	ecx
	push	OFFSET ??_C@_09IBKNLDJC@Suite?5?$CFs?6@
	call	_printf
	add	esp, 8

; 706  : 	    xmlFree(doc);

	mov	esi, esp
	mov	edx, DWORD PTR _doc$1[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 707  : 	} else {

	jmp	SHORT $LN4@rngTestSui
$LN5@rngTestSui:

; 708  : 	    doc = getString(cur, "string(section)");

	push	OFFSET ??_C@_0BA@IFALBHJB@string?$CIsection?$CJ@
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_getString
	add	esp, 8
	mov	DWORD PTR _doc$1[ebp], eax

; 709  : 	    if (doc != NULL) {

	cmp	DWORD PTR _doc$1[ebp], 0
	je	SHORT $LN4@rngTestSui

; 710  : 		printf("Section %s\n", doc);

	mov	eax, DWORD PTR _doc$1[ebp]
	push	eax
	push	OFFSET ??_C@_0M@DACABIB@Section?5?$CFs?6@
	call	_printf
	add	esp, 8

; 711  : 		xmlFree(doc);

	mov	esi, esp
	mov	ecx, DWORD PTR _doc$1[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@rngTestSui:

; 712  : 	    }
; 713  : 	}
; 714  :     }
; 715  :     cur = getNext(cur, "./testSuite[1]");

	push	OFFSET ??_C@_0P@MCCEHCEB@?4?1testSuite?$FL1?$FN@
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$LN2@rngTestSui:

; 716  :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@rngTestSui

; 717  :         xsdTestSuite(cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xsdTestSuite
	add	esp, 4

; 718  : 	cur = getNext(cur, "following-sibling::testSuite[1]");

	push	OFFSET ??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 719  :     }

	jmp	SHORT $LN2@rngTestSui
$LN3@rngTestSui:

; 720  : 
; 721  :     return(0);

	xor	eax, eax

; 722  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_rngTestSuite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _xsdTest
_TEXT	SEGMENT
_ret$ = -16						; size = 4
_filename$ = -12					; size = 4
_cur$ = -8						; size = 4
_doc$ = -4						; size = 4
_xsdTest PROC						; COMDAT

; 662  : xsdTest(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 663  :     xmlDocPtr doc;
; 664  :     xmlNodePtr cur;
; 665  :     const char *filename = "test/xsdtest/xsdtestsuite.xml";

	mov	DWORD PTR _filename$[ebp], OFFSET ??_C@_0BO@MGGLCEJL@test?1xsdtest?1xsdtestsuite?4xml@

; 666  :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 667  : 
; 668  :     doc = xmlReadFile(filename, NULL, XML_PARSE_NOENT);

	push	2
	push	0
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlReadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _doc$[ebp], eax

; 669  :     if (doc == NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN4@xsdTest

; 670  :         fprintf(stderr, "Failed to parse %s\n", filename);

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BE@MIGLFCAE@Failed?5to?5parse?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 671  : 	return(-1);

	or	eax, -1
	jmp	$LN1@xsdTest
$LN4@xsdTest:

; 672  :     }
; 673  :     printf("## XML Schemas datatypes test suite from James Clark\n");

	push	OFFSET ??_C@_0DG@ICOCCJHI@?$CD?$CD?5XML?5Schemas?5datatypes?5test?5s@
	call	_printf
	add	esp, 4

; 674  : 
; 675  :     cur = xmlDocGetRootElement(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 676  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN6@xsdTest
	push	OFFSET ??_C@_09HJKPOGMK@testSuite@
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@xsdTest
$LN6@xsdTest:

; 677  :         fprintf(stderr, "Unexpected format %s\n", filename);

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET ??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 678  : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 679  : 	goto done;

	jmp	$done$11
$LN5@xsdTest:

; 680  :     }
; 681  : 
; 682  :     cur = getNext(cur, "./testSuite[1]");

	push	OFFSET ??_C@_0P@MCCEHCEB@?4?1testSuite?$FL1?$FN@
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 683  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN8@xsdTest
	push	OFFSET ??_C@_09HJKPOGMK@testSuite@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@xsdTest
$LN8@xsdTest:

; 684  :         fprintf(stderr, "Unexpected format %s\n", filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 685  : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 686  : 	goto done;

	jmp	SHORT $done$11
$LN2@xsdTest:

; 687  :     }
; 688  :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $done$11

; 689  :         xsdTestSuite(cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xsdTestSuite
	add	esp, 4

; 690  : 	cur = getNext(cur, "following-sibling::testSuite[1]");

	push	OFFSET ??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 691  :     }

	jmp	SHORT $LN2@xsdTest
$done$11:

; 692  : 
; 693  : done:
; 694  :     if (doc != NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN9@xsdTest

; 695  : 	xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN9@xsdTest:

; 696  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xsdTest:

; 697  : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xsdTest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _xsdTestSuite
_TEXT	SEGMENT
_doc$1 = -4						; size = 4
_cur$ = 8						; size = 4
_xsdTestSuite PROC					; COMDAT

; 643  : xsdTestSuite(xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 644  :     if (verbose) {

	cmp	DWORD PTR _verbose, 0
	je	SHORT $LN4@xsdTestSui

; 645  : 	xmlChar *doc = getString(cur, "string(documentation)");

	push	OFFSET ??_C@_0BG@IHDGFAMN@string?$CIdocumentation?$CJ@
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_getString
	add	esp, 8
	mov	DWORD PTR _doc$1[ebp], eax

; 646  : 
; 647  : 	if (doc != NULL) {

	cmp	DWORD PTR _doc$1[ebp], 0
	je	SHORT $LN4@xsdTestSui

; 648  : 	    printf("Suite %s\n", doc);

	mov	ecx, DWORD PTR _doc$1[ebp]
	push	ecx
	push	OFFSET ??_C@_09IBKNLDJC@Suite?5?$CFs?6@
	call	_printf
	add	esp, 8

; 649  : 	    xmlFree(doc);

	mov	esi, esp
	mov	edx, DWORD PTR _doc$1[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xsdTestSui:

; 650  : 	}
; 651  :     }
; 652  :     cur = getNext(cur, "./testCase[1]");

	push	OFFSET ??_C@_0O@GKEMDIAD@?4?1testCase?$FL1?$FN@
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$LN2@xsdTestSui:

; 653  :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@xsdTestSui

; 654  :         xsdTestCase(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xsdTestCase
	add	esp, 4

; 655  : 	cur = getNext(cur, "following-sibling::testCase[1]");

	push	OFFSET ??_C@_0BP@OBCNJLPB@following?9sibling?3?3testCase?$FL1?$FN@
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 656  :     }

	jmp	SHORT $LN2@xsdTestSui
$LN3@xsdTestSui:

; 657  : 
; 658  :     return(0);

	xor	eax, eax

; 659  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xsdTestSuite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _xsdTestCase
_TEXT	SEGMENT
_dtd$ = -48						; size = 4
_memt$ = -44						; size = 4
_mem$ = -40						; size = 4
_ret$ = -36						; size = 4
_rng$ = -32						; size = 4
_ctxt$ = -28						; size = 4
_pctxt$ = -24						; size = 4
_doc$ = -20						; size = 4
_buf$ = -16						; size = 4
_cur$ = -12						; size = 4
_tmp$ = -8						; size = 4
_test$ = -4						; size = 4
_tst$ = 8						; size = 4
_xsdTestCase PROC					; COMDAT

; 450  : xsdTestCase(xmlNodePtr tst) {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 451  :     xmlNodePtr test, tmp, cur;
; 452  :     xmlBufferPtr buf;
; 453  :     xmlDocPtr doc = NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 454  :     xmlRelaxNGParserCtxtPtr pctxt;
; 455  :     xmlRelaxNGValidCtxtPtr ctxt;
; 456  :     xmlRelaxNGPtr rng = NULL;

	mov	DWORD PTR _rng$[ebp], 0

; 457  :     int ret = 0, mem, memt;

	mov	DWORD PTR _ret$[ebp], 0

; 458  :     xmlChar *dtd;
; 459  : 
; 460  :     resetEntities();

	call	_resetEntities

; 461  :     testErrorsSize = 0; testErrors[0] = 0;

	mov	DWORD PTR _testErrorsSize, 0
	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _testErrors[ecx], 0

; 462  : 
; 463  :     tmp = getNext(tst, "./dir[1]");

	push	OFFSET ??_C@_08JGDDGDEM@?4?1dir?$FL1?$FN@
	mov	edx, DWORD PTR _tst$[ebp]
	push	edx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _tmp$[ebp], eax

; 464  :     if (tmp != NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN6@xsdTestCas

; 465  :         installDirs(tmp, NULL);

	push	0
	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_installDirs
	add	esp, 8
$LN6@xsdTestCas:

; 466  :     }
; 467  :     tmp = getNext(tst, "./resource[1]");

	push	OFFSET ??_C@_0O@LNKGJPHN@?4?1resource?$FL1?$FN@
	mov	ecx, DWORD PTR _tst$[ebp]
	push	ecx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _tmp$[ebp], eax

; 468  :     if (tmp != NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN7@xsdTestCas

; 469  :         installResources(tmp, NULL);

	push	0
	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	call	_installResources
	add	esp, 8
$LN7@xsdTestCas:

; 470  :     }
; 471  : 
; 472  :     cur = getNext(tst, "./correct[1]");

	push	OFFSET ??_C@_0N@GHEABEGP@?4?1correct?$FL1?$FN@
	mov	eax, DWORD PTR _tst$[ebp]
	push	eax
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 473  :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN8@xsdTestCas

; 474  :         return(xsdIncorectTestCase(tst));

	mov	ecx, DWORD PTR _tst$[ebp]
	push	ecx
	call	_xsdIncorectTestCase
	add	esp, 4
	jmp	$LN1@xsdTestCas
$LN8@xsdTestCas:

; 475  :     }
; 476  : 
; 477  :     test = getNext(cur, "./*");

	push	OFFSET ??_C@_03MCCMDFBL@?4?1?$CK@
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _test$[ebp], eax

; 478  :     if (test == NULL) {

	cmp	DWORD PTR _test$[ebp], 0
	jne	SHORT $LN9@xsdTestCas

; 479  :         fprintf(stderr, "Failed to find test in correct line %ld\n",

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CJ@BODPNGCB@Failed?5to?5find?5test?5in?5correct?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 480  : 	        xmlGetLineNo(cur));
; 481  :         return(1);

	mov	eax, 1
	jmp	$LN1@xsdTestCas
$LN9@xsdTestCas:

; 482  :     }
; 483  : 
; 484  :     memt = xmlMemUsed();

	call	_xmlMemUsed
	mov	DWORD PTR _memt$[ebp], eax

; 485  :     extraMemoryFromResolver = 0;

	mov	DWORD PTR _extraMemoryFromResolver, 0

; 486  :     /*
; 487  :      * dump the schemas to a buffer, then reparse it and compile the schemas
; 488  :      */
; 489  :     buf = xmlBufferCreate();

	call	_xmlBufferCreate
	mov	DWORD PTR _buf$[ebp], eax

; 490  :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN10@xsdTestCas

; 491  :         fprintf(stderr, "out of memory !\n");

	push	OFFSET ??_C@_0BB@NKPLANIP@out?5of?5memory?5?$CB?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 492  : 	fatalError();

	call	_fatalError
$LN10@xsdTestCas:

; 493  :     }
; 494  :     xmlNodeDump(buf, test->doc, test, 0, 0);

	push	0
	push	0
	mov	ecx, DWORD PTR _test$[ebp]
	push	ecx
	mov	edx, DWORD PTR _test$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlNodeDump
	add	esp, 20					; 00000014H

; 495  :     pctxt = xmlRelaxNGNewMemParserCtxt((const char *)buf->content, buf->use);

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlRelaxNGNewMemParserCtxt
	add	esp, 8
	mov	DWORD PTR _pctxt$[ebp], eax

; 496  :     xmlRelaxNGSetParserErrors(pctxt,

	mov	eax, DWORD PTR _pctxt$[ebp]
	push	eax
	push	OFFSET _testErrorHandler
	push	OFFSET _testErrorHandler
	mov	ecx, DWORD PTR _pctxt$[ebp]
	push	ecx
	call	_xmlRelaxNGSetParserErrors
	add	esp, 16					; 00000010H

; 497  :          (xmlRelaxNGValidityErrorFunc) testErrorHandler,
; 498  :          (xmlRelaxNGValidityWarningFunc) testErrorHandler,
; 499  : 	 pctxt);
; 500  :     rng = xmlRelaxNGParse(pctxt);

	mov	edx, DWORD PTR _pctxt$[ebp]
	push	edx
	call	_xmlRelaxNGParse
	add	esp, 4
	mov	DWORD PTR _rng$[ebp], eax

; 501  :     xmlRelaxNGFreeParserCtxt(pctxt);

	mov	eax, DWORD PTR _pctxt$[ebp]
	push	eax
	call	_xmlRelaxNGFreeParserCtxt
	add	esp, 4

; 502  :     if (extraMemoryFromResolver)

	cmp	DWORD PTR _extraMemoryFromResolver, 0
	je	SHORT $LN11@xsdTestCas

; 503  :         memt = 0;

	mov	DWORD PTR _memt$[ebp], 0
$LN11@xsdTestCas:

; 504  : 
; 505  :     if (rng == NULL) {

	cmp	DWORD PTR _rng$[ebp], 0
	jne	SHORT $LN12@xsdTestCas

; 506  :         test_log("Failed to parse RNGtest line %ld\n",

	mov	ecx, DWORD PTR _test$[ebp]
	push	ecx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CC@NJOGDFNA@Failed?5to?5parse?5RNGtest?5line?5?$CFl@
	call	_test_log
	add	esp, 8

; 507  : 	        xmlGetLineNo(test));
; 508  : 	nb_errors++;

	mov	edx, DWORD PTR _nb_errors
	add	edx, 1
	mov	DWORD PTR _nb_errors, edx

; 509  :         ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 510  : 	goto done;

	jmp	$done$35
$LN12@xsdTestCas:

; 511  :     }
; 512  :     /*
; 513  :      * now scan all the siblings of correct to process the <valid> tests
; 514  :      */
; 515  :     tmp = getNext(cur, "following-sibling::valid[1]");

	push	OFFSET ??_C@_0BM@BOGBCHLM@following?9sibling?3?3valid?$FL1?$FN@
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _tmp$[ebp], eax
$LN2@xsdTestCas:

; 516  :     while (tmp != NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	je	$LN3@xsdTestCas

; 517  : 	dtd = xmlGetProp(tmp, BAD_CAST "dtd");

	push	OFFSET ??_C@_03DIJGCOJI@dtd@
	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _dtd$[ebp], eax

; 518  : 	test = getNext(tmp, "./*");

	push	OFFSET ??_C@_03MCCMDFBL@?4?1?$CK@
	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _test$[ebp], eax

; 519  : 	if (test == NULL) {

	cmp	DWORD PTR _test$[ebp], 0
	jne	SHORT $LN13@xsdTestCas

; 520  : 	    fprintf(stderr, "Failed to find test in <valid> line %ld\n",

	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CJ@OBKFIGCD@Failed?5to?5find?5test?5in?5?$DMvalid?$DO?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 521  : 		    xmlGetLineNo(tmp));
; 522  : 
; 523  : 	} else {

	jmp	$LN14@xsdTestCas
$LN13@xsdTestCas:

; 524  : 	    xmlBufferEmpty(buf);

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferEmpty
	add	esp, 4

; 525  : 	    if (dtd != NULL)

	cmp	DWORD PTR _dtd$[ebp], 0
	je	SHORT $LN15@xsdTestCas

; 526  : 		xmlBufferAdd(buf, dtd, -1);

	push	-1
	mov	edx, DWORD PTR _dtd$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferAdd
	add	esp, 12					; 0000000cH
$LN15@xsdTestCas:

; 527  : 	    xmlNodeDump(buf, test->doc, test, 0, 0);

	push	0
	push	0
	mov	ecx, DWORD PTR _test$[ebp]
	push	ecx
	mov	edx, DWORD PTR _test$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlNodeDump
	add	esp, 20					; 00000014H

; 528  : 
; 529  : 	    /*
; 530  : 	     * We are ready to run the test
; 531  : 	     */
; 532  : 	    mem = xmlMemUsed();

	call	_xmlMemUsed
	mov	DWORD PTR _mem$[ebp], eax

; 533  : 	    extraMemoryFromResolver = 0;

	mov	DWORD PTR _extraMemoryFromResolver, 0

; 534  :             doc = xmlReadMemory((const char *)buf->content, buf->use,

	push	0
	push	0
	push	OFFSET ??_C@_04CEJDCDCH@test@
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlReadMemory
	add	esp, 20					; 00000014H
	mov	DWORD PTR _doc$[ebp], eax

; 535  : 	                        "test", NULL, 0);
; 536  : 	    if (doc == NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN16@xsdTestCas

; 537  : 		test_log("Failed to parse valid instance line %ld\n",

	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CJ@HBAOOEGJ@Failed?5to?5parse?5valid?5instance?5@
	call	_test_log
	add	esp, 8

; 538  : 			xmlGetLineNo(tmp));
; 539  : 		nb_errors++;

	mov	ecx, DWORD PTR _nb_errors
	add	ecx, 1
	mov	DWORD PTR _nb_errors, ecx

; 540  : 	    } else {

	jmp	$LN17@xsdTestCas
$LN16@xsdTestCas:

; 541  : 		nb_tests++;

	mov	edx, DWORD PTR _nb_tests
	add	edx, 1
	mov	DWORD PTR _nb_tests, edx

; 542  : 	        ctxt = xmlRelaxNGNewValidCtxt(rng);

	mov	eax, DWORD PTR _rng$[ebp]
	push	eax
	call	_xmlRelaxNGNewValidCtxt
	add	esp, 4
	mov	DWORD PTR _ctxt$[ebp], eax

; 543  : 		xmlRelaxNGSetValidErrors(ctxt,

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	push	OFFSET _testErrorHandler
	push	OFFSET _testErrorHandler
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRelaxNGSetValidErrors
	add	esp, 16					; 00000010H

; 544  : 		     (xmlRelaxNGValidityErrorFunc) testErrorHandler,
; 545  : 		     (xmlRelaxNGValidityWarningFunc) testErrorHandler,
; 546  : 		     ctxt);
; 547  : 		ret = xmlRelaxNGValidateDoc(ctxt, doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRelaxNGValidateDoc
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 548  : 		xmlRelaxNGFreeValidCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRelaxNGFreeValidCtxt
	add	esp, 4

; 549  : 		if (ret > 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jle	SHORT $LN18@xsdTestCas

; 550  : 		    test_log("Failed to validate valid instance line %ld\n",

	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CM@HILILNIM@Failed?5to?5validate?5valid?5instan@
	call	_test_log
	add	esp, 8

; 551  : 				xmlGetLineNo(tmp));
; 552  : 		    nb_errors++;

	mov	ecx, DWORD PTR _nb_errors
	add	ecx, 1
	mov	DWORD PTR _nb_errors, ecx
	jmp	SHORT $LN19@xsdTestCas
$LN18@xsdTestCas:

; 553  : 		} else if (ret < 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN19@xsdTestCas

; 554  : 		    test_log("Internal error validating instance line %ld\n",

	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CN@MNFDEAFF@Internal?5error?5validating?5insta@
	call	_test_log
	add	esp, 8

; 555  : 			    xmlGetLineNo(tmp));
; 556  : 		    nb_errors++;

	mov	eax, DWORD PTR _nb_errors
	add	eax, 1
	mov	DWORD PTR _nb_errors, eax
$LN19@xsdTestCas:

; 557  : 		}
; 558  : 		xmlFreeDoc(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4
$LN17@xsdTestCas:

; 559  : 	    }
; 560  : 	    xmlResetLastError();

	call	_xmlResetLastError

; 561  : 	    if ((mem != xmlMemUsed()) && (extraMemoryFromResolver == 0)) {

	call	_xmlMemUsed
	cmp	DWORD PTR _mem$[ebp], eax
	je	SHORT $LN14@xsdTestCas
	cmp	DWORD PTR _extraMemoryFromResolver, 0
	jne	SHORT $LN14@xsdTestCas

; 562  : 	        test_log("Validation of instance line %ld leaked %d\n",

	call	_xmlMemUsed
	sub	eax, DWORD PTR _mem$[ebp]
	push	eax
	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CL@CHMJIAMO@Validation?5of?5instance?5line?5?$CFld@
	call	_test_log
	add	esp, 12					; 0000000cH

; 563  : 		        xmlGetLineNo(tmp), xmlMemUsed() - mem);
; 564  : 		xmlMemoryDump();

	call	_xmlMemoryDump

; 565  : 	        nb_leaks++;

	mov	eax, DWORD PTR _nb_leaks
	add	eax, 1
	mov	DWORD PTR _nb_leaks, eax
$LN14@xsdTestCas:

; 566  : 	    }
; 567  : 	}
; 568  : 	if (dtd != NULL)

	cmp	DWORD PTR _dtd$[ebp], 0
	je	SHORT $LN22@xsdTestCas

; 569  : 	    xmlFree(dtd);

	mov	esi, esp
	mov	ecx, DWORD PTR _dtd$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN22@xsdTestCas:

; 570  : 	tmp = getNext(tmp, "following-sibling::valid[1]");

	push	OFFSET ??_C@_0BM@BOGBCHLM@following?9sibling?3?3valid?$FL1?$FN@
	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _tmp$[ebp], eax

; 571  :     }

	jmp	$LN2@xsdTestCas
$LN3@xsdTestCas:

; 572  :     /*
; 573  :      * now scan all the siblings of correct to process the <invalid> tests
; 574  :      */
; 575  :     tmp = getNext(cur, "following-sibling::invalid[1]");

	push	OFFSET ??_C@_0BO@EOANKJHM@following?9sibling?3?3invalid?$FL1?$FN@
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _tmp$[ebp], eax
$LN4@xsdTestCas:

; 576  :     while (tmp != NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	je	$done$35

; 577  : 	test = getNext(tmp, "./*");

	push	OFFSET ??_C@_03MCCMDFBL@?4?1?$CK@
	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _test$[ebp], eax

; 578  : 	if (test == NULL) {

	cmp	DWORD PTR _test$[ebp], 0
	jne	SHORT $LN23@xsdTestCas

; 579  : 	    fprintf(stderr, "Failed to find test in <invalid> line %ld\n",

	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CL@OLCIMLMA@Failed?5to?5find?5test?5in?5?$DMinvalid@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 580  : 		    xmlGetLineNo(tmp));
; 581  : 
; 582  : 	} else {

	jmp	$LN24@xsdTestCas
$LN23@xsdTestCas:

; 583  : 	    xmlBufferEmpty(buf);

	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferEmpty
	add	esp, 4

; 584  : 	    xmlNodeDump(buf, test->doc, test, 0, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _test$[ebp]
	push	eax
	mov	ecx, DWORD PTR _test$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlNodeDump
	add	esp, 20					; 00000014H

; 585  : 
; 586  : 	    /*
; 587  : 	     * We are ready to run the test
; 588  : 	     */
; 589  : 	    mem = xmlMemUsed();

	call	_xmlMemUsed
	mov	DWORD PTR _mem$[ebp], eax

; 590  : 	    extraMemoryFromResolver = 0;

	mov	DWORD PTR _extraMemoryFromResolver, 0

; 591  :             doc = xmlReadMemory((const char *)buf->content, buf->use,

	push	0
	push	0
	push	OFFSET ??_C@_04CEJDCDCH@test@
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlReadMemory
	add	esp, 20					; 00000014H
	mov	DWORD PTR _doc$[ebp], eax

; 592  : 	                        "test", NULL, 0);
; 593  : 	    if (doc == NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN25@xsdTestCas

; 594  : 		test_log("Failed to parse valid instance line %ld\n",

	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CJ@HBAOOEGJ@Failed?5to?5parse?5valid?5instance?5@
	call	_test_log
	add	esp, 8

; 595  : 			xmlGetLineNo(tmp));
; 596  : 		nb_errors++;

	mov	eax, DWORD PTR _nb_errors
	add	eax, 1
	mov	DWORD PTR _nb_errors, eax

; 597  : 	    } else {

	jmp	$LN26@xsdTestCas
$LN25@xsdTestCas:

; 598  : 		nb_tests++;

	mov	ecx, DWORD PTR _nb_tests
	add	ecx, 1
	mov	DWORD PTR _nb_tests, ecx

; 599  : 	        ctxt = xmlRelaxNGNewValidCtxt(rng);

	mov	edx, DWORD PTR _rng$[ebp]
	push	edx
	call	_xmlRelaxNGNewValidCtxt
	add	esp, 4
	mov	DWORD PTR _ctxt$[ebp], eax

; 600  : 		xmlRelaxNGSetValidErrors(ctxt,

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	push	OFFSET _testErrorHandler
	push	OFFSET _testErrorHandler
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRelaxNGSetValidErrors
	add	esp, 16					; 00000010H

; 601  : 		     (xmlRelaxNGValidityErrorFunc) testErrorHandler,
; 602  : 		     (xmlRelaxNGValidityWarningFunc) testErrorHandler,
; 603  : 		     ctxt);
; 604  : 		ret = xmlRelaxNGValidateDoc(ctxt, doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRelaxNGValidateDoc
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 605  : 		xmlRelaxNGFreeValidCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRelaxNGFreeValidCtxt
	add	esp, 4

; 606  : 		if (ret == 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN27@xsdTestCas

; 607  : 		    test_log("Failed to detect invalid instance line %ld\n",

	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CM@HLHCNDD@Failed?5to?5detect?5invalid?5instan@
	call	_test_log
	add	esp, 8

; 608  : 				xmlGetLineNo(tmp));
; 609  : 		    nb_errors++;

	mov	eax, DWORD PTR _nb_errors
	add	eax, 1
	mov	DWORD PTR _nb_errors, eax
	jmp	SHORT $LN28@xsdTestCas
$LN27@xsdTestCas:

; 610  : 		} else if (ret < 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN28@xsdTestCas

; 611  : 		    test_log("Internal error validating instance line %ld\n",

	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CN@MNFDEAFF@Internal?5error?5validating?5insta@
	call	_test_log
	add	esp, 8

; 612  : 			    xmlGetLineNo(tmp));
; 613  : 		    nb_errors++;

	mov	edx, DWORD PTR _nb_errors
	add	edx, 1
	mov	DWORD PTR _nb_errors, edx
$LN28@xsdTestCas:

; 614  : 		}
; 615  : 		xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN26@xsdTestCas:

; 616  : 	    }
; 617  : 	    xmlResetLastError();

	call	_xmlResetLastError

; 618  : 	    if ((mem != xmlMemUsed()) && (extraMemoryFromResolver == 0)) {

	call	_xmlMemUsed
	cmp	DWORD PTR _mem$[ebp], eax
	je	SHORT $LN24@xsdTestCas
	cmp	DWORD PTR _extraMemoryFromResolver, 0
	jne	SHORT $LN24@xsdTestCas

; 619  : 	        test_log("Validation of instance line %ld leaked %d\n",

	call	_xmlMemUsed
	sub	eax, DWORD PTR _mem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CL@CHMJIAMO@Validation?5of?5instance?5line?5?$CFld@
	call	_test_log
	add	esp, 12					; 0000000cH

; 620  : 		        xmlGetLineNo(tmp), xmlMemUsed() - mem);
; 621  : 		xmlMemoryDump();

	call	_xmlMemoryDump

; 622  : 	        nb_leaks++;

	mov	edx, DWORD PTR _nb_leaks
	add	edx, 1
	mov	DWORD PTR _nb_leaks, edx
$LN24@xsdTestCas:

; 623  : 	    }
; 624  : 	}
; 625  : 	tmp = getNext(tmp, "following-sibling::invalid[1]");

	push	OFFSET ??_C@_0BO@EOANKJHM@following?9sibling?3?3invalid?$FL1?$FN@
	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _tmp$[ebp], eax

; 626  :     }

	jmp	$LN4@xsdTestCas
$done$35:

; 627  : 
; 628  : done:
; 629  :     if (buf != NULL)

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN31@xsdTestCas

; 630  : 	xmlBufferFree(buf);

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferFree
	add	esp, 4
$LN31@xsdTestCas:

; 631  :     if (rng != NULL)

	cmp	DWORD PTR _rng$[ebp], 0
	je	SHORT $LN32@xsdTestCas

; 632  :         xmlRelaxNGFree(rng);

	mov	edx, DWORD PTR _rng$[ebp]
	push	edx
	call	_xmlRelaxNGFree
	add	esp, 4
$LN32@xsdTestCas:

; 633  :     xmlResetLastError();

	call	_xmlResetLastError

; 634  :     if ((memt != xmlMemUsed()) && (memt != 0)) {

	call	_xmlMemUsed
	cmp	DWORD PTR _memt$[ebp], eax
	je	SHORT $LN33@xsdTestCas
	cmp	DWORD PTR _memt$[ebp], 0
	je	SHORT $LN33@xsdTestCas

; 635  : 	test_log("Validation of tests starting line %ld leaked %d\n",

	call	_xmlMemUsed
	sub	eax, DWORD PTR _memt$[ebp]
	push	eax
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DB@KOEBBOFA@Validation?5of?5tests?5starting?5li@
	call	_test_log
	add	esp, 12					; 0000000cH

; 636  : 		xmlGetLineNo(cur), xmlMemUsed() - memt);
; 637  : 	nb_leaks++;

	mov	ecx, DWORD PTR _nb_leaks
	add	ecx, 1
	mov	DWORD PTR _nb_leaks, ecx
$LN33@xsdTestCas:

; 638  :     }
; 639  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xsdTestCas:

; 640  : }

	pop	edi
	pop	esi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xsdTestCase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _installDirs
_TEXT	SEGMENT
_res$ = -12						; size = 4
_name$ = -8						; size = 4
_test$ = -4						; size = 4
_tst$ = 8						; size = 4
_base$ = 12						; size = 4
_installDirs PROC					; COMDAT

; 424  : installDirs(xmlNodePtr tst, const xmlChar *base) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 425  :     xmlNodePtr test;
; 426  :     xmlChar *name, *res;
; 427  : 
; 428  :     name = getString(tst, "string(@name)");

	push	OFFSET ??_C@_0O@ONOBOMHP@string?$CI?$EAname?$CJ@
	mov	eax, DWORD PTR _tst$[ebp]
	push	eax
	call	_getString
	add	esp, 8
	mov	DWORD PTR _name$[ebp], eax

; 429  :     if (name == NULL)

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN4@installDir

; 430  :         return;

	jmp	$LN1@installDir
$LN4@installDir:

; 431  :     res = composeDir(base, name);

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	call	_composeDir
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 432  :     xmlFree(name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	mov	edx, DWORD PTR [ecx]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 433  :     if (res == NULL) {

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN5@installDir

; 434  : 	return;

	jmp	$LN1@installDir
$LN5@installDir:

; 435  :     }
; 436  :     /* Now process resources and subdir recursively */
; 437  :     test = getNext(tst, "./resource[1]");

	push	OFFSET ??_C@_0O@LNKGJPHN@?4?1resource?$FL1?$FN@
	mov	eax, DWORD PTR _tst$[ebp]
	push	eax
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _test$[ebp], eax

; 438  :     if (test != NULL) {

	cmp	DWORD PTR _test$[ebp], 0
	je	SHORT $LN6@installDir

; 439  :         installResources(test, res);

	mov	ecx, DWORD PTR _res$[ebp]
	push	ecx
	mov	edx, DWORD PTR _test$[ebp]
	push	edx
	call	_installResources
	add	esp, 8
$LN6@installDir:

; 440  :     }
; 441  :     test = getNext(tst, "./dir[1]");

	push	OFFSET ??_C@_08JGDDGDEM@?4?1dir?$FL1?$FN@
	mov	eax, DWORD PTR _tst$[ebp]
	push	eax
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _test$[ebp], eax
$LN2@installDir:

; 442  :     while (test != NULL) {

	cmp	DWORD PTR _test$[ebp], 0
	je	SHORT $LN3@installDir

; 443  :         installDirs(test, res);

	mov	ecx, DWORD PTR _res$[ebp]
	push	ecx
	mov	edx, DWORD PTR _test$[ebp]
	push	edx
	call	_installDirs
	add	esp, 8

; 444  : 	test = getNext(test, "following-sibling::dir[1]");

	push	OFFSET ??_C@_0BK@JBEJBKGG@following?9sibling?3?3dir?$FL1?$FN@
	mov	eax, DWORD PTR _test$[ebp]
	push	eax
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _test$[ebp], eax

; 445  :     }

	jmp	SHORT $LN2@installDir
$LN3@installDir:

; 446  :     xmlFree(res);

	mov	esi, esp
	mov	ecx, DWORD PTR _res$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@installDir:

; 447  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_installDirs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _installResources
_TEXT	SEGMENT
_res$ = -20						; size = 4
_content$ = -16						; size = 4
_name$ = -12						; size = 4
_buf$ = -8						; size = 4
_test$ = -4						; size = 4
_tst$ = 8						; size = 4
_base$ = 12						; size = 4
_installResources PROC					; COMDAT

; 389  : installResources(xmlNodePtr tst, const xmlChar *base) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 390  :     xmlNodePtr test;
; 391  :     xmlBufferPtr buf;
; 392  :     xmlChar *name, *content, *res;
; 393  : 
; 394  :     buf = xmlBufferCreate();

	call	_xmlBufferCreate
	mov	DWORD PTR _buf$[ebp], eax

; 395  :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN4@installRes

; 396  :         fprintf(stderr, "out of memory !\n");

	push	OFFSET ??_C@_0BB@NKPLANIP@out?5of?5memory?5?$CB?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 397  : 	fatalError();

	call	_fatalError
$LN4@installRes:

; 398  :     }
; 399  :     xmlNodeDump(buf, tst->doc, tst, 0, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _tst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlNodeDump
	add	esp, 20					; 00000014H
$LN2@installRes:

; 400  : 
; 401  :     while (tst != NULL) {

	cmp	DWORD PTR _tst$[ebp], 0
	je	$LN3@installRes

; 402  : 	test = getNext(tst, "./*");

	push	OFFSET ??_C@_03MCCMDFBL@?4?1?$CK@
	mov	ecx, DWORD PTR _tst$[ebp]
	push	ecx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _test$[ebp], eax

; 403  : 	if (test != NULL) {

	cmp	DWORD PTR _test$[ebp], 0
	je	$LN5@installRes

; 404  : 	    xmlBufferEmpty(buf);

	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferEmpty
	add	esp, 4

; 405  : 	    xmlNodeDump(buf, test->doc, test, 0, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _test$[ebp]
	push	eax
	mov	ecx, DWORD PTR _test$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlNodeDump
	add	esp, 20					; 00000014H

; 406  : 	    name = getString(tst, "string(@name)");

	push	OFFSET ??_C@_0O@ONOBOMHP@string?$CI?$EAname?$CJ@
	mov	ecx, DWORD PTR _tst$[ebp]
	push	ecx
	call	_getString
	add	esp, 8
	mov	DWORD PTR _name$[ebp], eax

; 407  : 	    content = xmlStrdup(buf->content);

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _content$[ebp], eax

; 408  : 	    if ((name != NULL) && (content != NULL)) {

	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN6@installRes
	cmp	DWORD PTR _content$[ebp], 0
	je	SHORT $LN6@installRes

; 409  : 	        res = composeDir(base, name);

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	call	_composeDir
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 410  : 		xmlFree(name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	mov	edx, DWORD PTR [ecx]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 411  : 	        addEntity((char *) res, (char *) content);

	mov	eax, DWORD PTR _content$[ebp]
	push	eax
	mov	ecx, DWORD PTR _res$[ebp]
	push	ecx
	call	_addEntity
	add	esp, 8

; 412  : 	    } else {

	jmp	SHORT $LN5@installRes
$LN6@installRes:

; 413  : 	        if (name != NULL) xmlFree(name);

	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN8@installRes
	mov	esi, esp
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@installRes:

; 414  : 	        if (content != NULL) xmlFree(content);

	cmp	DWORD PTR _content$[ebp], 0
	je	SHORT $LN5@installRes
	mov	esi, esp
	mov	edx, DWORD PTR _content$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@installRes:

; 415  : 	    }
; 416  : 	}
; 417  : 	tst = getNext(tst, "following-sibling::resource[1]");

	push	OFFSET ??_C@_0BP@DGMHDMIP@following?9sibling?3?3resource?$FL1?$FN@
	mov	edx, DWORD PTR _tst$[ebp]
	push	edx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _tst$[ebp], eax

; 418  :     }

	jmp	$LN2@installRes
$LN3@installRes:

; 419  :     if (buf != NULL)

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN1@installRes

; 420  : 	xmlBufferFree(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferFree
	add	esp, 4
$LN1@installRes:

; 421  : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_installResources ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _xsdIncorectTestCase
_TEXT	SEGMENT
_memt$ = -24						; size = 4
_ret$ = -20						; size = 4
_rng$ = -16						; size = 4
_pctxt$ = -12						; size = 4
_buf$ = -8						; size = 4
_test$ = -4						; size = 4
_cur$ = 8						; size = 4
_xsdIncorectTestCase PROC				; COMDAT

; 330  : xsdIncorectTestCase(xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 331  :     xmlNodePtr test;
; 332  :     xmlBufferPtr buf;
; 333  :     xmlRelaxNGParserCtxtPtr pctxt;
; 334  :     xmlRelaxNGPtr rng = NULL;

	mov	DWORD PTR _rng$[ebp], 0

; 335  :     int ret = 0, memt;

	mov	DWORD PTR _ret$[ebp], 0

; 336  : 
; 337  :     cur = getNext(cur, "./incorrect[1]");

	push	OFFSET ??_C@_0P@CKJJNHKD@?4?1incorrect?$FL1?$FN@
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 338  :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xsdIncorec

; 339  :         return(0);

	xor	eax, eax
	jmp	$LN1@xsdIncorec
$LN2@xsdIncorec:

; 340  :     }
; 341  : 
; 342  :     test = getNext(cur, "./*");

	push	OFFSET ??_C@_03MCCMDFBL@?4?1?$CK@
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _test$[ebp], eax

; 343  :     if (test == NULL) {

	cmp	DWORD PTR _test$[ebp], 0
	jne	SHORT $LN3@xsdIncorec

; 344  :         test_log("Failed to find test in correct line %ld\n",

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CJ@BODPNGCB@Failed?5to?5find?5test?5in?5correct?5@
	call	_test_log
	add	esp, 8

; 345  : 	        xmlGetLineNo(cur));
; 346  :         return(1);

	mov	eax, 1
	jmp	$LN1@xsdIncorec
$LN3@xsdIncorec:

; 347  :     }
; 348  : 
; 349  :     memt = xmlMemUsed();

	call	_xmlMemUsed
	mov	DWORD PTR _memt$[ebp], eax

; 350  :     extraMemoryFromResolver = 0;

	mov	DWORD PTR _extraMemoryFromResolver, 0

; 351  :     /*
; 352  :      * dump the schemas to a buffer, then reparse it and compile the schemas
; 353  :      */
; 354  :     buf = xmlBufferCreate();

	call	_xmlBufferCreate
	mov	DWORD PTR _buf$[ebp], eax

; 355  :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN4@xsdIncorec

; 356  :         fprintf(stderr, "out of memory !\n");

	push	OFFSET ??_C@_0BB@NKPLANIP@out?5of?5memory?5?$CB?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 357  : 	fatalError();

	call	_fatalError
$LN4@xsdIncorec:

; 358  :     }
; 359  :     xmlNodeDump(buf, test->doc, test, 0, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _test$[ebp]
	push	eax
	mov	ecx, DWORD PTR _test$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlNodeDump
	add	esp, 20					; 00000014H

; 360  :     pctxt = xmlRelaxNGNewMemParserCtxt((const char *)buf->content, buf->use);

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlRelaxNGNewMemParserCtxt
	add	esp, 8
	mov	DWORD PTR _pctxt$[ebp], eax

; 361  :     xmlRelaxNGSetParserErrors(pctxt,

	mov	edx, DWORD PTR _pctxt$[ebp]
	push	edx
	push	OFFSET _testErrorHandler
	push	OFFSET _testErrorHandler
	mov	eax, DWORD PTR _pctxt$[ebp]
	push	eax
	call	_xmlRelaxNGSetParserErrors
	add	esp, 16					; 00000010H

; 362  :          (xmlRelaxNGValidityErrorFunc) testErrorHandler,
; 363  :          (xmlRelaxNGValidityWarningFunc) testErrorHandler,
; 364  : 	 pctxt);
; 365  :     rng = xmlRelaxNGParse(pctxt);

	mov	ecx, DWORD PTR _pctxt$[ebp]
	push	ecx
	call	_xmlRelaxNGParse
	add	esp, 4
	mov	DWORD PTR _rng$[ebp], eax

; 366  :     xmlRelaxNGFreeParserCtxt(pctxt);

	mov	edx, DWORD PTR _pctxt$[ebp]
	push	edx
	call	_xmlRelaxNGFreeParserCtxt
	add	esp, 4

; 367  :     if (rng != NULL) {

	cmp	DWORD PTR _rng$[ebp], 0
	je	SHORT $done$10

; 368  : 	test_log("Failed to detect incorect RNG line %ld\n",

	mov	eax, DWORD PTR _test$[ebp]
	push	eax
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CI@DKMJCAPB@Failed?5to?5detect?5incorect?5RNG?5l@
	call	_test_log
	add	esp, 8

; 369  : 		    xmlGetLineNo(test));
; 370  :         ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$done$10:

; 371  : 	goto done;
; 372  :     }
; 373  : 
; 374  : done:
; 375  :     if (buf != NULL)

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN6@xsdIncorec

; 376  : 	xmlBufferFree(buf);

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferFree
	add	esp, 4
$LN6@xsdIncorec:

; 377  :     if (rng != NULL)

	cmp	DWORD PTR _rng$[ebp], 0
	je	SHORT $LN7@xsdIncorec

; 378  :         xmlRelaxNGFree(rng);

	mov	edx, DWORD PTR _rng$[ebp]
	push	edx
	call	_xmlRelaxNGFree
	add	esp, 4
$LN7@xsdIncorec:

; 379  :     xmlResetLastError();

	call	_xmlResetLastError

; 380  :     if ((memt < xmlMemUsed()) && (extraMemoryFromResolver == 0)) {

	call	_xmlMemUsed
	cmp	DWORD PTR _memt$[ebp], eax
	jge	SHORT $LN8@xsdIncorec
	cmp	DWORD PTR _extraMemoryFromResolver, 0
	jne	SHORT $LN8@xsdIncorec

; 381  : 	test_log("Validation of tests starting line %ld leaked %d\n",

	call	_xmlMemUsed
	sub	eax, DWORD PTR _memt$[ebp]
	push	eax
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DB@KOEBBOFA@Validation?5of?5tests?5starting?5li@
	call	_test_log
	add	esp, 12					; 0000000cH

; 382  : 		xmlGetLineNo(cur), xmlMemUsed() - memt);
; 383  : 	nb_leaks++;

	mov	ecx, DWORD PTR _nb_leaks
	add	ecx, 1
	mov	DWORD PTR _nb_leaks, ecx
$LN8@xsdIncorec:

; 384  :     }
; 385  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xsdIncorec:

; 386  : }

	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xsdIncorectTestCase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _getString
_TEXT	SEGMENT
_comp$ = -12						; size = 4
_res$ = -8						; size = 4
_ret$ = -4						; size = 4
_cur$ = 8						; size = 4
_xpath$ = 12						; size = 4
_getString PROC						; COMDAT

; 297  : getString(xmlNodePtr cur, const char *xpath) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 298  :     xmlChar *ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 299  :     xmlXPathObjectPtr res;
; 300  :     xmlXPathCompExprPtr comp;
; 301  : 
; 302  :     if ((cur == NULL)  || (cur->doc == NULL) || (xpath == NULL))

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@getString
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN3@getString
	cmp	DWORD PTR _xpath$[ebp], 0
	jne	SHORT $LN2@getString
$LN3@getString:

; 303  :         return(NULL);

	xor	eax, eax
	jmp	$LN1@getString
$LN2@getString:

; 304  :     ctxtXPath->doc = cur->doc;

	mov	ecx, DWORD PTR _ctxtXPath
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx], eax

; 305  :     ctxtXPath->node = cur;

	mov	ecx, DWORD PTR _ctxtXPath
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 306  :     comp = xmlXPathCompile(BAD_CAST xpath);

	mov	eax, DWORD PTR _xpath$[ebp]
	push	eax
	call	_xmlXPathCompile
	add	esp, 4
	mov	DWORD PTR _comp$[ebp], eax

; 307  :     if (comp == NULL) {

	cmp	DWORD PTR _comp$[ebp], 0
	jne	SHORT $LN4@getString

; 308  :         fprintf(stderr, "Failed to compile %s\n", xpath);

	mov	ecx, DWORD PTR _xpath$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BG@NHDHPLMD@Failed?5to?5compile?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 309  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@getString
$LN4@getString:

; 310  :     }
; 311  :     res = xmlXPathCompiledEval(comp, ctxtXPath);

	mov	edx, DWORD PTR _ctxtXPath
	push	edx
	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	call	_xmlXPathCompiledEval
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 312  :     xmlXPathFreeCompExpr(comp);

	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	call	_xmlXPathFreeCompExpr
	add	esp, 4

; 313  :     if (res == NULL)

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN5@getString

; 314  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@getString
$LN5@getString:

; 315  :     if (res->type == XPATH_STRING) {

	mov	edx, DWORD PTR _res$[ebp]
	cmp	DWORD PTR [edx], 4
	jne	SHORT $LN6@getString

; 316  :         ret = res->stringval;

	mov	eax, DWORD PTR _res$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _ret$[ebp], ecx

; 317  : 	res->stringval = NULL;

	mov	edx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [edx+24], 0
$LN6@getString:

; 318  :     }
; 319  :     xmlXPathFreeObject(res);

	mov	eax, DWORD PTR _res$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 320  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@getString:

; 321  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_getString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _getNext
_TEXT	SEGMENT
_comp$ = -12						; size = 4
_res$ = -8						; size = 4
_ret$ = -4						; size = 4
_cur$ = 8						; size = 4
_xpath$ = 12						; size = 4
_getNext PROC						; COMDAT

; 269  : getNext(xmlNodePtr cur, const char *xpath) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 270  :     xmlNodePtr ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 271  :     xmlXPathObjectPtr res;
; 272  :     xmlXPathCompExprPtr comp;
; 273  : 
; 274  :     if ((cur == NULL)  || (cur->doc == NULL) || (xpath == NULL))

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@getNext
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN3@getNext
	cmp	DWORD PTR _xpath$[ebp], 0
	jne	SHORT $LN2@getNext
$LN3@getNext:

; 275  :         return(NULL);

	xor	eax, eax
	jmp	$LN1@getNext
$LN2@getNext:

; 276  :     ctxtXPath->doc = cur->doc;

	mov	ecx, DWORD PTR _ctxtXPath
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx], eax

; 277  :     ctxtXPath->node = cur;

	mov	ecx, DWORD PTR _ctxtXPath
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 278  :     comp = xmlXPathCompile(BAD_CAST xpath);

	mov	eax, DWORD PTR _xpath$[ebp]
	push	eax
	call	_xmlXPathCompile
	add	esp, 4
	mov	DWORD PTR _comp$[ebp], eax

; 279  :     if (comp == NULL) {

	cmp	DWORD PTR _comp$[ebp], 0
	jne	SHORT $LN4@getNext

; 280  :         fprintf(stderr, "Failed to compile %s\n", xpath);

	mov	ecx, DWORD PTR _xpath$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BG@NHDHPLMD@Failed?5to?5compile?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 281  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@getNext
$LN4@getNext:

; 282  :     }
; 283  :     res = xmlXPathCompiledEval(comp, ctxtXPath);

	mov	edx, DWORD PTR _ctxtXPath
	push	edx
	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	call	_xmlXPathCompiledEval
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 284  :     xmlXPathFreeCompExpr(comp);

	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	call	_xmlXPathFreeCompExpr
	add	esp, 4

; 285  :     if (res == NULL)

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN5@getNext

; 286  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@getNext
$LN5@getNext:

; 287  :     if ((res->type == XPATH_NODESET) &&
; 288  :         (res->nodesetval != NULL) &&
; 289  : 	(res->nodesetval->nodeNr > 0) &&

	mov	edx, DWORD PTR _res$[ebp]
	cmp	DWORD PTR [edx], 1
	jne	SHORT $LN6@getNext
	mov	eax, DWORD PTR _res$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN6@getNext
	mov	ecx, DWORD PTR _res$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN6@getNext
	mov	eax, DWORD PTR _res$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN6@getNext

; 290  : 	(res->nodesetval->nodeTab != NULL))
; 291  : 	ret = res->nodesetval->nodeTab[0];

	mov	edx, DWORD PTR _res$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [edx+eax]
	mov	DWORD PTR _ret$[ebp], ecx
$LN6@getNext:

; 292  :     xmlXPathFreeObject(res);

	mov	edx, DWORD PTR _res$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4

; 293  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@getNext:

; 294  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_getNext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _initializeLibxml2
_TEXT	SEGMENT
_initializeLibxml2 PROC					; COMDAT

; 239  : initializeLibxml2(void) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 240  :     xmlGetWarningsDefaultValue = 0;

	call	___xmlGetWarningsDefaultValue
	mov	DWORD PTR [eax], 0

; 241  :     xmlPedanticParserDefault(0);

	push	0
	call	_xmlPedanticParserDefault
	add	esp, 4

; 242  : 
; 243  :     xmlMemSetup(xmlMemFree, xmlMemMalloc, xmlMemRealloc, xmlMemoryStrdup);

	push	OFFSET _xmlMemoryStrdup
	push	OFFSET _xmlMemRealloc
	push	OFFSET _xmlMemMalloc
	push	OFFSET _xmlMemFree
	call	_xmlMemSetup
	add	esp, 16					; 00000010H

; 244  :     xmlInitParser();

	call	_xmlInitParser

; 245  :     xmlSetExternalEntityLoader(testExternalEntityLoader);

	push	OFFSET _testExternalEntityLoader
	call	_xmlSetExternalEntityLoader
	add	esp, 4

; 246  :     ctxtXPath = xmlXPathNewContext(NULL);

	push	0
	call	_xmlXPathNewContext
	add	esp, 4
	mov	DWORD PTR _ctxtXPath, eax

; 247  :     /*
; 248  :     * Deactivate the cache if created; otherwise we have to create/free it
; 249  :     * for every test, since it will confuse the memory leak detection.
; 250  :     * Note that normally this need not be done, since the cache is not
; 251  :     * created until set explicitely with xmlXPathContextSetCache();
; 252  :     * but for test purposes it is sometimes usefull to activate the
; 253  :     * cache by default for the whole library.
; 254  :     */
; 255  :     if (ctxtXPath->cache != NULL)

	mov	eax, DWORD PTR _ctxtXPath
	cmp	DWORD PTR [eax+200], 0
	je	SHORT $LN2@initialize

; 256  : 	xmlXPathContextSetCache(ctxtXPath, 0, -1, 0);

	push	0
	push	-1
	push	0
	mov	ecx, DWORD PTR _ctxtXPath
	push	ecx
	call	_xmlXPathContextSetCache
	add	esp, 16					; 00000010H
$LN2@initialize:

; 257  :     /* used as default nanemspace in xstc tests */
; 258  :     xmlXPathRegisterNs(ctxtXPath, BAD_CAST "ts", BAD_CAST "TestSuite");

	push	OFFSET ??_C@_09DGPCOFBK@TestSuite@
	push	OFFSET ??_C@_02FHFEMMFE@ts@
	mov	edx, DWORD PTR _ctxtXPath
	push	edx
	call	_xmlXPathRegisterNs
	add	esp, 12					; 0000000cH

; 259  :     xmlXPathRegisterNs(ctxtXPath, BAD_CAST "xlink",

	push	OFFSET ??_C@_0BN@GKPMOOH@http?3?1?1www?4w3?4org?11999?1xlink@
	push	OFFSET ??_C@_05HHOAKHHD@xlink@
	mov	eax, DWORD PTR _ctxtXPath
	push	eax
	call	_xmlXPathRegisterNs
	add	esp, 12					; 0000000cH

; 260  :                        BAD_CAST "http://www.w3.org/1999/xlink");
; 261  :     xmlSetGenericErrorFunc(NULL, testErrorHandler);

	push	OFFSET _testErrorHandler
	push	0
	call	_xmlSetGenericErrorFunc
	add	esp, 8

; 262  : #ifdef LIBXML_SCHEMAS_ENABLED
; 263  :     xmlSchemaInitTypes();

	call	_xmlSchemaInitTypes

; 264  :     xmlRelaxNGInitTypes();

	call	_xmlRelaxNGInitTypes

; 265  : #endif
; 266  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_initializeLibxml2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _testErrorHandler
_TEXT	SEGMENT
tv92 = -28						; size = 4
__Result$1 = -24					; size = 4
__Format$ = -20						; size = 4
__BufferCount$ = -16					; size = 4
__Buffer$ = -12						; size = 4
_res$ = -8						; size = 4
_args$ = -4						; size = 4
_ctx$ = 8						; size = 4
_msg$ = 12						; size = 4
_testErrorHandler PROC					; COMDAT

; 215  : testErrorHandler(void *ctx  ATTRIBUTE_UNUSED, const char *msg, ...) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 216  :     va_list args;
; 217  :     int res;
; 218  : 
; 219  :     if (testErrorsSize >= 32768)

	cmp	DWORD PTR _testErrorsSize, 32768	; 00008000H
	jl	SHORT $LN2@testErrorH

; 220  :         return;

	jmp	$LN1@testErrorH
$LN2@testErrorH:

; 221  :     va_start(args, msg);

	lea	eax, DWORD PTR _msg$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 222  :     res = vsnprintf(&testErrors[testErrorsSize],

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx
	mov	edx, 32768				; 00008000H
	sub	edx, DWORD PTR _testErrorsSize
	mov	DWORD PTR __BufferCount$[ebp], edx
	mov	eax, DWORD PTR _testErrorsSize
	add	eax, OFFSET _testErrors
	mov	DWORD PTR __Buffer$[ebp], eax
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 2
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$1[ebp], eax

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$1[ebp], 0
	jge	SHORT $LN8@testErrorH
	mov	DWORD PTR tv92[ebp], -1
	jmp	SHORT $LN6@testErrorH
$LN8@testErrorH:
	mov	ecx, DWORD PTR __Result$1[ebp]
	mov	DWORD PTR tv92[ebp], ecx
$LN6@testErrorH:
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c

; 222  :     res = vsnprintf(&testErrors[testErrorsSize],

	mov	edx, DWORD PTR tv92[ebp]
	mov	DWORD PTR _res$[ebp], edx

; 223  :                     32768 - testErrorsSize,
; 224  : 		    msg, args);
; 225  :     va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 226  :     if (testErrorsSize + res >= 32768) {

	mov	eax, DWORD PTR _testErrorsSize
	add	eax, DWORD PTR _res$[ebp]
	cmp	eax, 32768				; 00008000H
	jl	SHORT $LN3@testErrorH

; 227  :         /* buffer is full */
; 228  : 	testErrorsSize = 32768;

	mov	DWORD PTR _testErrorsSize, 32768	; 00008000H

; 229  : 	testErrors[testErrorsSize] = 0;

	mov	ecx, DWORD PTR _testErrorsSize
	mov	BYTE PTR _testErrors[ecx], 0

; 230  :     } else {

	jmp	SHORT $LN4@testErrorH
$LN3@testErrorH:

; 231  :         testErrorsSize += res;

	mov	edx, DWORD PTR _testErrorsSize
	add	edx, DWORD PTR _res$[ebp]
	mov	DWORD PTR _testErrorsSize, edx
$LN4@testErrorH:

; 232  :     }
; 233  :     testErrors[testErrorsSize] = 0;

	mov	eax, DWORD PTR _testErrorsSize
	mov	BYTE PTR _testErrors[eax], 0
$LN1@testErrorH:

; 234  : }

	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_testErrorHandler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _test_log
_TEXT	SEGMENT
__Format$ = -20						; size = 4
__Stream$ = -16						; size = 4
__Format$ = -12						; size = 4
__Stream$ = -8						; size = 4
_args$ = -4						; size = 4
_msg$ = 8						; size = 4
_test_log PROC						; COMDAT

; 197  : static void test_log(const char *msg, ...) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 198  :     va_list args;
; 199  :     if (logfile != NULL) {

	cmp	DWORD PTR _logfile, 0
	je	$LN2@test_log

; 200  :         fprintf(logfile, "\n------------\n");

	push	OFFSET ??_C@_0P@BFDMMPAI@?6?9?9?9?9?9?9?9?9?9?9?9?9?6@
	mov	eax, DWORD PTR _logfile
	push	eax
	call	_fprintf
	add	esp, 8

; 201  : 	va_start(args, msg);

	lea	ecx, DWORD PTR _msg$[ebp+4]
	mov	DWORD PTR _args$[ebp], ecx

; 202  : 	vfprintf(logfile, msg, args);

	mov	edx, DWORD PTR _msg$[ebp]
	mov	DWORD PTR __Format$[ebp], edx
	mov	eax, DWORD PTR _logfile
	mov	DWORD PTR __Stream$[ebp], eax
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c

; 203  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 204  : 	fprintf(logfile, "%s", testErrors);

	push	OFFSET _testErrors
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	mov	eax, DWORD PTR _logfile
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 205  : 	testErrorsSize = 0; testErrors[0] = 0;

	mov	DWORD PTR _testErrorsSize, 0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _testErrors[edx], 0
$LN2@test_log:

; 206  :     }
; 207  :     if (verbose) {

	cmp	DWORD PTR _verbose, 0
	je	SHORT $LN1@test_log

; 208  : 	va_start(args, msg);

	lea	eax, DWORD PTR _msg$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 209  : 	vfprintf(stderr, msg, args);

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Stream$[ebp], eax
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Stream$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c

; 210  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0
$LN1@test_log:

; 211  :     }
; 212  : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_test_log ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _testExternalEntityLoader
_TEXT	SEGMENT
tv71 = -32						; size = 4
tv153 = -28						; size = 4
tv148 = -22						; size = 1
tv141 = -21						; size = 1
tv135 = -20						; size = 4
tv137 = -16						; size = 4
_memused$1 = -12					; size = 4
_i$ = -8						; size = 4
_ret$ = -4						; size = 4
_URL$ = 8						; size = 4
_ID$ = 12						; size = 4
_ctxt$ = 16						; size = 4
_testExternalEntityLoader PROC				; COMDAT

; 159  : 			 xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 160  :     xmlParserInputPtr ret;
; 161  :     int i;
; 162  : 
; 163  :     for (i = 0;i < nb_entities;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@testExtern
$LN2@testExtern:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@testExtern:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _nb_entities
	jge	$LN3@testExtern

; 164  :         if (!strcmp(testEntitiesName[i], URL)) {

	mov	edx, DWORD PTR _URL$[ebp]
	mov	DWORD PTR tv137[ebp], edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _testEntitiesName[eax*4]
	mov	DWORD PTR tv135[ebp], ecx
$LL10@testExtern:
	mov	edx, DWORD PTR tv135[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv141[ebp], al
	mov	ecx, DWORD PTR tv137[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN11@testExtern
	cmp	BYTE PTR tv141[ebp], 0
	je	SHORT $LN12@testExtern
	mov	edx, DWORD PTR tv135[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv148[ebp], al
	mov	ecx, DWORD PTR tv137[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN11@testExtern
	add	DWORD PTR tv135[ebp], 2
	add	DWORD PTR tv137[ebp], 2
	cmp	BYTE PTR tv148[ebp], 0
	jne	SHORT $LL10@testExtern
$LN12@testExtern:
	mov	DWORD PTR tv153[ebp], 0
	jmp	SHORT $LN13@testExtern
$LN11@testExtern:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv153[ebp], edx
$LN13@testExtern:
	mov	eax, DWORD PTR tv153[ebp]
	mov	DWORD PTR tv71[ebp], eax
	cmp	DWORD PTR tv71[ebp], 0
	jne	SHORT $LN5@testExtern

; 165  : 	    ret = xmlNewStringInputStream(ctxt,

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _testEntitiesValue[ecx*4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNewStringInputStream
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 166  : 	                (const xmlChar *) testEntitiesValue[i]);
; 167  : 	    if (ret != NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN6@testExtern

; 168  : 	        ret->filename = (const char *)

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _testEntitiesName[ecx*4]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN6@testExtern:

; 169  : 		                xmlStrdup((xmlChar *)testEntitiesName[i]);
; 170  : 	    }
; 171  : 	    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@testExtern
$LN5@testExtern:

; 172  : 	}
; 173  :     }

	jmp	$LN2@testExtern
$LN3@testExtern:

; 174  :     if (checkTestFile(URL)) {

	mov	edx, DWORD PTR _URL$[ebp]
	push	edx
	call	_checkTestFile
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@testExtern

; 175  : 	ret = xmlNoNetExternalEntityLoader(URL, ID, ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _URL$[ebp]
	push	edx
	call	_xmlNoNetExternalEntityLoader
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 176  :     } else {

	jmp	SHORT $LN8@testExtern
$LN7@testExtern:

; 177  : 	int memused = xmlMemUsed();

	call	_xmlMemUsed
	mov	DWORD PTR _memused$1[ebp], eax

; 178  : 	ret = xmlNoNetExternalEntityLoader(URL, ID, ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _URL$[ebp]
	push	edx
	call	_xmlNoNetExternalEntityLoader
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 179  : 	extraMemoryFromResolver += xmlMemUsed() - memused;

	call	_xmlMemUsed
	sub	eax, DWORD PTR _memused$1[ebp]
	add	eax, DWORD PTR _extraMemoryFromResolver
	mov	DWORD PTR _extraMemoryFromResolver, eax
$LN8@testExtern:

; 180  :     }
; 181  : #if 0
; 182  :     if (ret == NULL) {
; 183  :         fprintf(stderr, "Failed to find resource %s\n", URL);
; 184  :     }
; 185  : #endif
; 186  : 
; 187  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@testExtern:

; 188  : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_testExternalEntityLoader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _addEntity
_TEXT	SEGMENT
_name$ = 8						; size = 4
_content$ = 12						; size = 4
_addEntity PROC						; COMDAT

; 141  : static int addEntity(char *name, char *content) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 142  :     if (nb_entities >= MAX_ENTITIES) {

	cmp	DWORD PTR _nb_entities, 20		; 00000014H
	jl	SHORT $LN2@addEntity

; 143  : 	fprintf(stderr, "Too many entities defined\n");

	push	OFFSET ??_C@_0BL@OMNEBIPD@Too?5many?5entities?5defined?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 144  : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@addEntity
$LN2@addEntity:

; 145  :     }
; 146  :     testEntitiesName[nb_entities] = name;

	mov	eax, DWORD PTR _nb_entities
	mov	ecx, DWORD PTR _name$[ebp]
	mov	DWORD PTR _testEntitiesName[eax*4], ecx

; 147  :     testEntitiesValue[nb_entities] = content;

	mov	edx, DWORD PTR _nb_entities
	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR _testEntitiesValue[edx*4], eax

; 148  :     nb_entities++;

	mov	ecx, DWORD PTR _nb_entities
	add	ecx, 1
	mov	DWORD PTR _nb_entities, ecx

; 149  :     return(0);

	xor	eax, eax
$LN1@addEntity:

; 150  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_addEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _resetEntities
_TEXT	SEGMENT
_i$ = -4						; size = 4
_resetEntities PROC					; COMDAT

; 130  : static void resetEntities(void) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 131  :     int i;
; 132  : 
; 133  :     for (i = 0;i < nb_entities;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@resetEntit
$LN2@resetEntit:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@resetEntit:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _nb_entities
	jge	SHORT $LN3@resetEntit

; 134  :         if (testEntitiesName[i] != NULL)

	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _testEntitiesName[edx*4], 0
	je	SHORT $LN5@resetEntit

; 135  : 	    xmlFree(testEntitiesName[i]);

	mov	esi, esp
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _testEntitiesName[eax*4]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@resetEntit:

; 136  :         if (testEntitiesValue[i] != NULL)

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _testEntitiesValue[ecx*4], 0
	je	SHORT $LN6@resetEntit

; 137  : 	    xmlFree(testEntitiesValue[i]);

	mov	esi, esp
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _testEntitiesValue[edx*4]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	mov	edx, DWORD PTR [ecx]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@resetEntit:

; 138  :     }

	jmp	SHORT $LN2@resetEntit
$LN3@resetEntit:

; 139  :     nb_entities = 0;

	mov	DWORD PTR _nb_entities, 0

; 140  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_resetEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _fatalError
_TEXT	SEGMENT
_fatalError PROC					; COMDAT

; 118  : fatalError(void) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 119  :     fprintf(stderr, "Exitting tests on fatal error\n");

	push	OFFSET ??_C@_0BP@MFIPDKLN@Exitting?5tests?5on?5fatal?5error?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 120  :     exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@fatalError:

; 121  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_fatalError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _composeDir
_TEXT	SEGMENT
_buf$ = -504						; size = 500
_dir$ = 8						; size = 4
_path$ = 12						; size = 4
_composeDir PROC					; COMDAT

; 93   : static xmlChar *composeDir(const xmlChar *dir, const xmlChar *path) {

	push	ebp
	mov	ebp, esp
	sub	esp, 508				; 000001fcH
	push	edi
	lea	edi, DWORD PTR [ebp-508]
	mov	ecx, 127				; 0000007fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4

; 94   :     char buf[500];
; 95   : 
; 96   :     if (dir == NULL) return(xmlStrdup(path));

	cmp	DWORD PTR _dir$[ebp], 0
	jne	SHORT $LN2@composeDir
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	jmp	SHORT $LN1@composeDir
$LN2@composeDir:

; 97   :     if (path == NULL) return(NULL);

	cmp	DWORD PTR _path$[ebp], 0
	jne	SHORT $LN3@composeDir
	xor	eax, eax
	jmp	SHORT $LN1@composeDir
$LN3@composeDir:

; 98   : 
; 99   :     snprintf(buf, 500, "%s/%s", (const char *) dir, (const char *) path);

	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dir$[ebp]
	push	edx
	push	OFFSET ??_C@_05GFOLEBJA@?$CFs?1?$CFs@
	push	500					; 000001f4H
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H

; 100  :     return(xmlStrdup((const xmlChar *) buf));

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
$LN1@composeDir:

; 101  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@composeDir
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 508				; 000001fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN7@composeDir:
	DD	1
	DD	$LN6@composeDir
$LN6@composeDir:
	DD	-504					; fffffe08H
	DD	500					; 000001f4H
	DD	$LN5@composeDir
$LN5@composeDir:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_composeDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\sys\stat.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _checkTestFile
_TEXT	SEGMENT
_buf$ = -52						; size = 48
_filename$ = 8						; size = 4
_checkTestFile PROC					; COMDAT

; 76   : static int checkTestFile(const char *filename) {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __ECEFD40B_runsuite@c
	call	@__CheckForDebuggerJustMyCode@4
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\sys\stat.h

; 242  :             return _stat64i32(_FileName, (struct _stat64i32*)_Stat);

	mov	esi, esp
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	DWORD PTR __imp___stat64i32
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c

; 79   :     if (stat(filename, &buf) == -1)

	cmp	eax, -1
	jne	SHORT $LN2@checkTestF

; 80   :         return(0);

	xor	eax, eax
	jmp	SHORT $LN1@checkTestF
$LN2@checkTestF:

; 81   : 
; 82   : #if defined(_WIN32) && !defined(__CYGWIN__)
; 83   :     if (!(buf.st_mode & _S_IFREG))

	movzx	edx, WORD PTR _buf$[ebp+6]
	and	edx, 32768				; 00008000H
	jne	SHORT $LN3@checkTestF

; 84   :         return(0);

	xor	eax, eax
	jmp	SHORT $LN1@checkTestF
$LN3@checkTestF:

; 85   : #else
; 86   :     if (!S_ISREG(buf.st_mode))
; 87   :         return(0);
; 88   : #endif
; 89   : 
; 90   :     return(1);

	mov	eax, 1
$LN1@checkTestF:

; 91   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@checkTestF
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN9@checkTestF:
	DD	1
	DD	$LN8@checkTestF
$LN8@checkTestF:
	DD	-52					; ffffffccH
	DD	48					; 00000030H
	DD	$LN7@checkTestF
$LN7@checkTestF:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_checkTestFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
tv81 = -20						; size = 4
__Result$1 = -16					; size = 4
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __BufferCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	edx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR [eax+4]
	push	edx
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$1[ebp], eax

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$1[ebp], 0
	jge	SHORT $LN5@snprintf
	mov	DWORD PTR tv81[ebp], -1
	jmp	SHORT $LN3@snprintf
$LN5@snprintf:
	mov	eax, DWORD PTR __Result$1[ebp]
	mov	DWORD PTR tv81[ebp], eax
$LN3@snprintf:

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 1954 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1955 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1956 :     }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = -16						; size = 4
__Stream$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx
	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Stream$[ebp], eax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Stream$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	DWORD PTR __Result$[ebp], eax

; 959  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 960  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 961  :     }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Stream$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 842  :     }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
