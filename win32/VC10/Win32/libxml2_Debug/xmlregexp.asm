; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xmlregexp.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_forbiddenExp
PUBLIC	_emptyExp
_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__F6DD4902_xmlregexp@c DB 01H
msvcjmc	ENDS
_DATA	SEGMENT
_forbiddenExp DD FLAT:_forbiddenExpNode
_emptyExp DD	FLAT:_emptyExpNode
_forbiddenExpNode DB 01H
	DB	00H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_emptyExpNode DB 00H
	DB	01H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_printf
PUBLIC	_snprintf
PUBLIC	_xmlRegexpCompile
PUBLIC	_xmlRegFreeRegexp
PUBLIC	_xmlRegexpExec
PUBLIC	_xmlRegexpPrint
PUBLIC	_xmlRegexpIsDeterminist
PUBLIC	_xmlRegNewExecCtxt
PUBLIC	_xmlRegFreeExecCtxt
PUBLIC	_xmlRegExecPushString
PUBLIC	_xmlRegExecPushString2
PUBLIC	_xmlRegExecNextValues
PUBLIC	_xmlRegExecErrInfo
PUBLIC	_xmlExpFreeCtxt
PUBLIC	_xmlExpNewCtxt
PUBLIC	_xmlExpCtxtNbNodes
PUBLIC	_xmlExpCtxtNbCons
PUBLIC	_xmlExpFree
PUBLIC	_xmlExpRef
PUBLIC	_xmlExpParse
PUBLIC	_xmlExpNewAtom
PUBLIC	_xmlExpNewOr
PUBLIC	_xmlExpNewSeq
PUBLIC	_xmlExpNewRange
PUBLIC	_xmlExpIsNillable
PUBLIC	_xmlExpMaxToken
PUBLIC	_xmlExpGetLanguage
PUBLIC	_xmlExpGetStart
PUBLIC	_xmlExpStringDerive
PUBLIC	_xmlExpExpDerive
PUBLIC	_xmlExpSubsume
PUBLIC	_xmlExpDump
PUBLIC	_xmlNewAutomata
PUBLIC	_xmlFreeAutomata
PUBLIC	_xmlAutomataGetInitState
PUBLIC	_xmlAutomataSetFinalState
PUBLIC	_xmlAutomataNewState
PUBLIC	_xmlAutomataNewTransition
PUBLIC	_xmlAutomataNewTransition2
PUBLIC	_xmlAutomataNewNegTrans
PUBLIC	_xmlAutomataNewCountTrans
PUBLIC	_xmlAutomataNewCountTrans2
PUBLIC	_xmlAutomataNewOnceTrans
PUBLIC	_xmlAutomataNewOnceTrans2
PUBLIC	_xmlAutomataNewAllTrans
PUBLIC	_xmlAutomataNewEpsilon
PUBLIC	_xmlAutomataNewCountedTrans
PUBLIC	_xmlAutomataNewCounterTrans
PUBLIC	_xmlAutomataNewCounter
PUBLIC	_xmlAutomataCompile
PUBLIC	_xmlAutomataIsDeterminist
PUBLIC	_xmlAutomataSetFlags
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BH@CFFLONMP@failed?5to?5compile?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BB@FJPDMDM@compiling?5regexp@		; `string'
PUBLIC	??_C@_0BB@PBEHJOM@allocating?5range@		; `string'
PUBLIC	??_C@_0BA@JCPCIFNM@allocating?5atom@		; `string'
PUBLIC	??_C@_0N@ECMBACNP@copying?5atom@		; `string'
PUBLIC	??_C@_0BB@CKELLPME@allocating?5state@		; `string'
PUBLIC	??_C@_08LJGDJFJP@epsilon?5@			; `string'
PUBLIC	??_C@_08DFHMJFEK@charval?5@			; `string'
PUBLIC	??_C@_07IPEOMBMH@ranges?5@			; `string'
PUBLIC	??_C@_08BABENLJO@subexpr?5@			; `string'
PUBLIC	??_C@_07HBAIICBM@string?5@			; `string'
PUBLIC	??_C@_08IIDGBAEF@anychar?5@			; `string'
PUBLIC	??_C@_09IFBFMEEE@anyspace?5@			; `string'
PUBLIC	??_C@_09PIGAJOFL@notspace?5@			; `string'
PUBLIC	??_C@_09PGNNJPMN@initname?5@			; `string'
PUBLIC	??_C@_0N@PKALLFNP@notinitname?5@		; `string'
PUBLIC	??_C@_09GMGKKJAH@namechar?5@			; `string'
PUBLIC	??_C@_0N@GALMIDBF@notnamechar?5@		; `string'
PUBLIC	??_C@_08CDKGKILA@decimal?5@			; `string'
PUBLIC	??_C@_0M@EDJHICHL@notdecimal?5@			; `string'
PUBLIC	??_C@_09MOCDMJPB@realchar?5@			; `string'
PUBLIC	??_C@_0N@MCPFODOD@notrealchar?5@		; `string'
PUBLIC	??_C@_07POCGPIHD@LETTER?5@			; `string'
PUBLIC	??_C@_0BC@KMHMCLHI@LETTER_UPPERCASE?5@		; `string'
PUBLIC	??_C@_0BC@MLADGGJK@LETTER_LOWERCASE?5@		; `string'
PUBLIC	??_C@_0BC@FGJDLGPN@LETTER_TITLECASE?5@		; `string'
PUBLIC	??_C@_0BB@MHDADLFE@LETTER_MODIFIER?5@		; `string'
PUBLIC	??_C@_0P@ONCGNHEJ@LETTER_OTHERS?5@		; `string'
PUBLIC	??_C@_05BACHLHLN@MARK?5@			; `string'
PUBLIC	??_C@_0BB@FIDLEIEL@MARK_NONSPACING?5@		; `string'
PUBLIC	??_C@_0BF@GJKDPMF@MARK_SPACECOMBINING?5@	; `string'
PUBLIC	??_C@_0BA@NNNPPLBP@MARK_ENCLOSING?5@		; `string'
PUBLIC	??_C@_07BAKEFCLB@NUMBER?5@			; `string'
PUBLIC	??_C@_0BA@JLEBGNKM@NUMBER_DECIMAL?5@		; `string'
PUBLIC	??_C@_0P@FJBLFHMA@NUMBER_LETTER?5@		; `string'
PUBLIC	??_C@_0P@PDKFLOJK@NUMBER_OTHERS?5@		; `string'
PUBLIC	??_C@_06INFGODEH@PUNCT?5@			; `string'
PUBLIC	??_C@_0BB@DCHADIII@PUNCT_CONNECTOR?5@		; `string'
PUBLIC	??_C@_0M@BBMKBPFM@PUNCT_DASH?5@			; `string'
PUBLIC	??_C@_0M@FHHCCFFM@PUNCT_OPEN?5@			; `string'
PUBLIC	??_C@_0N@OCGFHNOE@PUNCT_CLOSE?5@		; `string'
PUBLIC	??_C@_0BB@HJFINBLL@PUNCT_INITQUOTE?5@		; `string'
PUBLIC	??_C@_0BA@EBCHGEDF@PUNCT_FINQUOTE?5@		; `string'
PUBLIC	??_C@_0O@FIEDELON@PUNCT_OTHERS?5@		; `string'
PUBLIC	??_C@_06MODMGGJL@SEPAR?5@			; `string'
PUBLIC	??_C@_0N@CEDLANHM@SEPAR_SPACE?5@		; `string'
PUBLIC	??_C@_0M@GPNEEMIA@SEPAR_LINE?5@			; `string'
PUBLIC	??_C@_0M@DGHGIFFK@SEPAR_PARA?5@			; `string'
PUBLIC	??_C@_07EJLPHCCB@SYMBOL?5@			; `string'
PUBLIC	??_C@_0N@LBDJILGE@SYMBOL_MATH?5@		; `string'
PUBLIC	??_C@_0BB@MBFAMNND@SYMBOL_CURRENCY?5@		; `string'
PUBLIC	??_C@_0BB@CEPANLJE@SYMBOL_MODIFIER?5@		; `string'
PUBLIC	??_C@_0P@LKPECLCL@SYMBOL_OTHERS?5@		; `string'
PUBLIC	??_C@_06HJDKAKAL@OTHER?5@			; `string'
PUBLIC	??_C@_0P@FGFCBEPI@OTHER_CONTROL?5@		; `string'
PUBLIC	??_C@_0O@BACNFCMB@OTHER_FORMAT?5@		; `string'
PUBLIC	??_C@_0P@DEHNHHA@OTHER_PRIVATE?5@		; `string'
PUBLIC	??_C@_09NECDEFOF@OTHER_NA?5@			; `string'
PUBLIC	??_C@_06HDNEPAAO@BLOCK?5@			; `string'
PUBLIC	??_C@_05GDJGFPHL@once?5@			; `string'
PUBLIC	??_C@_02LKANKAOC@?$DP?5@			; `string'
PUBLIC	??_C@_02KAOAMBHJ@?$CK?5@			; `string'
PUBLIC	??_C@_02KBCCKLEO@?$CL?5@			; `string'
PUBLIC	??_C@_06IBKHBGID@range?5@			; `string'
PUBLIC	??_C@_09EPCGBNDN@onceonly?5@			; `string'
PUBLIC	??_C@_04DIDGAIEC@all?5@				; `string'
PUBLIC	??_C@_09LLABEBOE@?5?5range?3?5@			; `string'
PUBLIC	??_C@_09KDBNABJA@negative?5@			; `string'
PUBLIC	??_C@_08BNCIEJGK@?$CFc?5?9?5?$CFc?6@		; `string'
PUBLIC	??_C@_07LAIPMBOA@?5atom?3?5@			; `string'
PUBLIC	??_C@_05NJDBAOFA@NULL?6@			; `string'
PUBLIC	??_C@_04LKOGMCLF@not?5@				; `string'
PUBLIC	??_C@_06BIJEIIBB@?$CFd?9?$CFd?5@		; `string'
PUBLIC	??_C@_05IMLJLABD@?8?$CFs?8?5@			; `string'
PUBLIC	??_C@_08PCGOOLFO@char?5?$CFc?6@			; `string'
PUBLIC	??_C@_0M@BCDCHBAM@?$CFd?5entries?6@		; `string'
PUBLIC	??_C@_0BB@GBMGKEL@start?5?$CFd?5end?5?$CFd?6@	; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_09KCGMBGNH@?5?5trans?3?5@			; `string'
PUBLIC	??_C@_08IDDAKHFP@removed?6@			; `string'
PUBLIC	??_C@_0BH@PJNPIGKD@last?5not?5determinist?0?5@	; `string'
PUBLIC	??_C@_0BC@EKCPHBCA@not?5determinist?0?5@	; `string'
PUBLIC	??_C@_0N@NIIDMCG@counted?5?$CFd?0?5@		; `string'
PUBLIC	??_C@_0BB@CPMJDJHN@all?5transition?0?5@		; `string'
PUBLIC	??_C@_0BB@LHHOLMKP@count?5based?5?$CFd?0?5@	; `string'
PUBLIC	??_C@_0P@BEFDCDEN@epsilon?5to?5?$CFd?6@		; `string'
PUBLIC	??_C@_08JNAFCHHG@char?5?$CFc?5@			; `string'
PUBLIC	??_C@_0BA@DDAHGLMD@atom?5?$CFd?0?5to?5?$CFd?6@	; `string'
PUBLIC	??_C@_08NOIFNCJM@?5state?3?5@			; `string'
PUBLIC	??_C@_06BNBHINFE@START?5@			; `string'
PUBLIC	??_C@_06EFHALCBA@FINAL?5@			; `string'
PUBLIC	??_C@_0BF@NHMHHIIL@?$CFd?0?5?$CFd?5transitions?3?6@ ; `string'
PUBLIC	??_C@_0BI@MEBKNK@add?5range?3?5atom?5is?5NULL@	; `string'
PUBLIC	??_C@_0BO@PJJILLLG@add?5range?3?5atom?5is?5not?5ranges@ ; `string'
PUBLIC	??_C@_0O@INOJCFAI@adding?5ranges@		; `string'
PUBLIC	??_C@_0BD@OEINICOI@allocating?5counter@		; `string'
PUBLIC	??_C@_0BI@LIIKMBAE@atom?5push?3?5atom?5is?5NULL@ ; `string'
PUBLIC	??_C@_0N@PMKNEBIB@pushing?5atom@		; `string'
PUBLIC	??_C@_0BC@FHJHIDDF@adding?5transition@		; `string'
PUBLIC	??_C@_0BJ@KPILLGIF@add?5state?3?5state?5is?5NULL@ ; `string'
PUBLIC	??_C@_0BK@PPLNMJBI@add?5state?3?5target?5is?5NULL@ ; `string'
PUBLIC	??_C@_0N@NHLBLLB@adding?5state@			; `string'
PUBLIC	??_C@_0CB@LMLDANHN@genrate?5transition?3?5atom?5?$DN?$DN?5NUL@ ; `string'
PUBLIC	??_C@_0BJ@POCEJEIB@TODO?3?5XML_REGEXP_STRING?6@	; `string'
PUBLIC	??_C@_0O@PEGCJGLF@saving?5regexp@		; `string'
PUBLIC	??_C@_0BN@CPBANDJM@exec?5save?3?5allocation?5failed@ ; `string'
PUBLIC	??_C@_0P@IJHGICCJ@running?5regexp@		; `string'
PUBLIC	??_C@_0CE@CMNJHAKA@epsilon?5transition?5left?5at?5runt@ ; `string'
PUBLIC	??_C@_0BL@LMPHHOAL@creating?5execution?5context@ ; `string'
PUBLIC	??_C@_0BF@FEDDAGIG@pushing?5input?5string@	; `string'
PUBLIC	??_C@_0GL@GCGJPEPF@c?3?2users?2dag?2documents?2_clients@ ; `string'
PUBLIC	??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ ; `string'
PUBLIC	??_C@_0BA@KPLOEDJN@IsXXXX?5expected@		; `string'
PUBLIC	??_C@_0BG@ECFAFFBF@Unknown?5char?5property@	; `string'
PUBLIC	??_C@_0BO@BOFONOMH@Escaped?5sequence?3?5expecting?5?2@ ; `string'
PUBLIC	??_C@_0O@OGGGBIPE@Expecting?5?8?$HL?8@		; `string'
PUBLIC	??_C@_0O@OCOLGEEG@Expecting?5?8?$HN?8@		; `string'
PUBLIC	??_C@_0CP@BDPLJNDH@Wrong?5escape?5sequence?0?5misuse?5o@ ; `string'
PUBLIC	??_C@_0O@NKKGCCKG@Expecting?5?8?$FN?8@		; `string'
PUBLIC	??_C@_0BF@HOMDEKLG@Invalid?5escape?5value@	; `string'
PUBLIC	??_C@_0BH@LOJMKNAD@Expecting?5a?5char?5range@	; `string'
PUBLIC	??_C@_0CC@JHFKDBIP@Expecting?5the?5end?5of?5a?5char?5ran@ ; `string'
PUBLIC	??_C@_0CG@BKADGONK@End?5of?5range?5is?5before?5start?5of@ ; `string'
PUBLIC	??_C@_0BM@FJAEMPFO@charClassExpr?3?5?8?$FN?8?5expected@ ; `string'
PUBLIC	??_C@_0CC@FKLKCEIP@xmlFAParseCharClass?3?5?8?$FN?8?5expect@ ; `string'
PUBLIC	??_C@_0BE@PGBJEMPN@Improper?5quantifier@	; `string'
PUBLIC	??_C@_0BI@HKPFPPFN@Unterminated?5quantifier@	; `string'
PUBLIC	??_C@_0BO@CCFFKIJF@xmlFAParseAtom?3?5expecting?5?8?$CJ?8@ ; `string'
PUBLIC	??_C@_0BM@PFFMPGPF@internal?3?5no?5atom?5generated@ ; `string'
PUBLIC	??_C@_0BL@KAIMKABF@expecting?5a?5branch?5after?5?$HM@ ; `string'
PUBLIC	??_C@_09BNLLHCCB@?5regexp?3?5@			; `string'
PUBLIC	??_C@_0L@PLBJGPP@?$CFd?5atoms?3?6@		; `string'
PUBLIC	??_C@_06NLBGECGK@?5?$CF02d?5@			; `string'
PUBLIC	??_C@_0L@LDKKLMNF@?$CFd?5states?3@		; `string'
PUBLIC	??_C@_0O@EOOCDOKK@?$CFd?5counters?3?6@		; `string'
PUBLIC	??_C@_0BE@LNLBBGGH@?5?$CFd?3?5min?5?$CFd?5max?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0CD@GPPIOFAL@xmlFAParseRegExp?3?5extra?5charact@ ; `string'
PUBLIC	??_C@_06NGEMONLJ@not?5?$CFs@			; `string'
PUBLIC	??_C@_0BF@FNELPLND@unbalanced?5?8?$CI?8?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_01ODHLEDKK@?$CI@				; `string'
PUBLIC	??_C@_05LBJMNBOG@empty@				; `string'
PUBLIC	??_C@_09PDGFMGED@forbidden@			; `string'
PUBLIC	??_C@_03NKFKBEPL@?5?0?5@			; `string'
PUBLIC	??_C@_03LGOGDKEL@?5?$HM?5@			; `string'
PUBLIC	??_C@_04PFHMOCHH@?$HL?$CFd?$HN@			; `string'
PUBLIC	??_C@_08EMBBFCPF@?$HL?$CFd?0inf?$HN@		; `string'
PUBLIC	??_C@_07CDJFAPGJ@?$HL?$CFd?0?$CFd?$HN@		; `string'
PUBLIC	??_C@_0P@OCJKDKLA@Error?5in?5tree?6@		; `string'
PUBLIC	??_C@_01PKGAHCOL@?$CJ@				; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_xmlDictCreate:PROC
EXTRN	_xmlDictReference:PROC
EXTRN	_xmlDictFree:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlDictExists:PROC
EXTRN	_xmlBufferWriteCHAR:PROC
EXTRN	_xmlBufferWriteChar:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	_xmlCharInRange:PROC
EXTRN	_xmlStringCurrentChar:PROC
EXTRN	_xmlUCSIsBlock:PROC
EXTRN	_xmlUCSIsCatC:PROC
EXTRN	_xmlUCSIsCatCc:PROC
EXTRN	_xmlUCSIsCatCf:PROC
EXTRN	_xmlUCSIsCatCo:PROC
EXTRN	_xmlUCSIsCatL:PROC
EXTRN	_xmlUCSIsCatLl:PROC
EXTRN	_xmlUCSIsCatLm:PROC
EXTRN	_xmlUCSIsCatLo:PROC
EXTRN	_xmlUCSIsCatLt:PROC
EXTRN	_xmlUCSIsCatLu:PROC
EXTRN	_xmlUCSIsCatM:PROC
EXTRN	_xmlUCSIsCatMc:PROC
EXTRN	_xmlUCSIsCatMe:PROC
EXTRN	_xmlUCSIsCatMn:PROC
EXTRN	_xmlUCSIsCatN:PROC
EXTRN	_xmlUCSIsCatNd:PROC
EXTRN	_xmlUCSIsCatNl:PROC
EXTRN	_xmlUCSIsCatNo:PROC
EXTRN	_xmlUCSIsCatP:PROC
EXTRN	_xmlUCSIsCatPc:PROC
EXTRN	_xmlUCSIsCatPd:PROC
EXTRN	_xmlUCSIsCatPe:PROC
EXTRN	_xmlUCSIsCatPf:PROC
EXTRN	_xmlUCSIsCatPi:PROC
EXTRN	_xmlUCSIsCatPo:PROC
EXTRN	_xmlUCSIsCatPs:PROC
EXTRN	_xmlUCSIsCatS:PROC
EXTRN	_xmlUCSIsCatSc:PROC
EXTRN	_xmlUCSIsCatSk:PROC
EXTRN	_xmlUCSIsCatSm:PROC
EXTRN	_xmlUCSIsCatSo:PROC
EXTRN	_xmlUCSIsCatZ:PROC
EXTRN	_xmlUCSIsCatZl:PROC
EXTRN	_xmlUCSIsCatZp:PROC
EXTRN	_xmlUCSIsCatZs:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ@ DB ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OCJKDKLA@Error?5in?5tree?6@
CONST	SEGMENT
??_C@_0P@OCJKDKLA@Error?5in?5tree?6@ DB 'Error in tree', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CDJFAPGJ@?$HL?$CFd?0?$CFd?$HN@
CONST	SEGMENT
??_C@_07CDJFAPGJ@?$HL?$CFd?0?$CFd?$HN@ DB '{%d,%d}', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EMBBFCPF@?$HL?$CFd?0inf?$HN@
CONST	SEGMENT
??_C@_08EMBBFCPF@?$HL?$CFd?0inf?$HN@ DB '{%d,inf}', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFHMOCHH@?$HL?$CFd?$HN@
CONST	SEGMENT
??_C@_04PFHMOCHH@?$HL?$CFd?$HN@ DB '{%d}', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LGOGDKEL@?5?$HM?5@
CONST	SEGMENT
??_C@_03LGOGDKEL@?5?$HM?5@ DB ' | ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NKFKBEPL@?5?0?5@
CONST	SEGMENT
??_C@_03NKFKBEPL@?5?0?5@ DB ' , ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PDGFMGED@forbidden@
CONST	SEGMENT
??_C@_09PDGFMGED@forbidden@ DB 'forbidden', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LBJMNBOG@empty@
CONST	SEGMENT
??_C@_05LBJMNBOG@empty@ DB 'empty', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01ODHLEDKK@?$CI@
CONST	SEGMENT
??_C@_01ODHLEDKK@?$CI@ DB '(', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FNELPLND@unbalanced?5?8?$CI?8?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BF@FNELPLND@unbalanced?5?8?$CI?8?5?3?5?$CFs?6@ DB 'unbalanced ''('''
	DB	' : %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06NGEMONLJ@not?5?$CFs@
CONST	SEGMENT
??_C@_06NGEMONLJ@not?5?$CFs@ DB 'not %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GPPIOFAL@xmlFAParseRegExp?3?5extra?5charact@
CONST	SEGMENT
??_C@_0CD@GPPIOFAL@xmlFAParseRegExp?3?5extra?5charact@ DB 'xmlFAParseRegE'
	DB	'xp: extra characters', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LNLBBGGH@?5?$CFd?3?5min?5?$CFd?5max?5?$CFd?6@
CONST	SEGMENT
??_C@_0BE@LNLBBGGH@?5?$CFd?3?5min?5?$CFd?5max?5?$CFd?6@ DB ' %d: min %d m'
	DB	'ax %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EOOCDOKK@?$CFd?5counters?3?6@
CONST	SEGMENT
??_C@_0O@EOOCDOKK@?$CFd?5counters?3?6@ DB '%d counters:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LDKKLMNF@?$CFd?5states?3@
CONST	SEGMENT
??_C@_0L@LDKKLMNF@?$CFd?5states?3@ DB '%d states:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06NLBGECGK@?5?$CF02d?5@
CONST	SEGMENT
??_C@_06NLBGECGK@?5?$CF02d?5@ DB ' %02d ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PLBJGPP@?$CFd?5atoms?3?6@
CONST	SEGMENT
??_C@_0L@PLBJGPP@?$CFd?5atoms?3?6@ DB '%d atoms:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BNLLHCCB@?5regexp?3?5@
CONST	SEGMENT
??_C@_09BNLLHCCB@?5regexp?3?5@ DB ' regexp: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KAIMKABF@expecting?5a?5branch?5after?5?$HM@
CONST	SEGMENT
??_C@_0BL@KAIMKABF@expecting?5a?5branch?5after?5?$HM@ DB 'expecting a bra'
	DB	'nch after |', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PFFMPGPF@internal?3?5no?5atom?5generated@
CONST	SEGMENT
??_C@_0BM@PFFMPGPF@internal?3?5no?5atom?5generated@ DB 'internal: no atom'
	DB	' generated', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CCFFKIJF@xmlFAParseAtom?3?5expecting?5?8?$CJ?8@
CONST	SEGMENT
??_C@_0BO@CCFFKIJF@xmlFAParseAtom?3?5expecting?5?8?$CJ?8@ DB 'xmlFAParseA'
	DB	'tom: expecting '')''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HKPFPPFN@Unterminated?5quantifier@
CONST	SEGMENT
??_C@_0BI@HKPFPPFN@Unterminated?5quantifier@ DB 'Unterminated quantifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PGBJEMPN@Improper?5quantifier@
CONST	SEGMENT
??_C@_0BE@PGBJEMPN@Improper?5quantifier@ DB 'Improper quantifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FKLKCEIP@xmlFAParseCharClass?3?5?8?$FN?8?5expect@
CONST	SEGMENT
??_C@_0CC@FKLKCEIP@xmlFAParseCharClass?3?5?8?$FN?8?5expect@ DB 'xmlFAPars'
	DB	'eCharClass: '']'' expected', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FJAEMPFO@charClassExpr?3?5?8?$FN?8?5expected@
CONST	SEGMENT
??_C@_0BM@FJAEMPFO@charClassExpr?3?5?8?$FN?8?5expected@ DB 'charClassExpr'
	DB	': '']'' expected', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BKADGONK@End?5of?5range?5is?5before?5start?5of@
CONST	SEGMENT
??_C@_0CG@BKADGONK@End?5of?5range?5is?5before?5start?5of@ DB 'End of rang'
	DB	'e is before start of range', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JHFKDBIP@Expecting?5the?5end?5of?5a?5char?5ran@
CONST	SEGMENT
??_C@_0CC@JHFKDBIP@Expecting?5the?5end?5of?5a?5char?5ran@ DB 'Expecting t'
	DB	'he end of a char range', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LOJMKNAD@Expecting?5a?5char?5range@
CONST	SEGMENT
??_C@_0BH@LOJMKNAD@Expecting?5a?5char?5range@ DB 'Expecting a char range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HOMDEKLG@Invalid?5escape?5value@
CONST	SEGMENT
??_C@_0BF@HOMDEKLG@Invalid?5escape?5value@ DB 'Invalid escape value', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NKKGCCKG@Expecting?5?8?$FN?8@
CONST	SEGMENT
??_C@_0O@NKKGCCKG@Expecting?5?8?$FN?8@ DB 'Expecting '']''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BDPLJNDH@Wrong?5escape?5sequence?0?5misuse?5o@
CONST	SEGMENT
??_C@_0CP@BDPLJNDH@Wrong?5escape?5sequence?0?5misuse?5o@ DB 'Wrong escape'
	DB	' sequence, misuse of character ''\''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OCOLGEEG@Expecting?5?8?$HN?8@
CONST	SEGMENT
??_C@_0O@OCOLGEEG@Expecting?5?8?$HN?8@ DB 'Expecting ''}''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OGGGBIPE@Expecting?5?8?$HL?8@
CONST	SEGMENT
??_C@_0O@OGGGBIPE@Expecting?5?8?$HL?8@ DB 'Expecting ''{''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BOFONOMH@Escaped?5sequence?3?5expecting?5?2@
CONST	SEGMENT
??_C@_0BO@BOFONOMH@Escaped?5sequence?3?5expecting?5?2@ DB 'Escaped sequen'
	DB	'ce: expecting \', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ECFAFFBF@Unknown?5char?5property@
CONST	SEGMENT
??_C@_0BG@ECFAFFBF@Unknown?5char?5property@ DB 'Unknown char property', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KPLOEDJN@IsXXXX?5expected@
CONST	SEGMENT
??_C@_0BA@KPLOEDJN@IsXXXX?5expected@ DB 'IsXXXX expected', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
CONST	SEGMENT
??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ DB 'Unimplem'
	DB	'ented block at %s:%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GL@GCGJPEPF@c?3?2users?2dag?2documents?2_clients@
CONST	SEGMENT
??_C@_0GL@GCGJPEPF@c?3?2users?2dag?2documents?2_clients@ DB 'c:\users\dag'
	DB	'\documents\_clients\codeproject authors group\windows on arm\'
	DB	'libxml2\libxml2-2.9.9\xmlregexp.c', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FEDDAGIG@pushing?5input?5string@
CONST	SEGMENT
??_C@_0BF@FEDDAGIG@pushing?5input?5string@ DB 'pushing input string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LMPHHOAL@creating?5execution?5context@
CONST	SEGMENT
??_C@_0BL@LMPHHOAL@creating?5execution?5context@ DB 'creating execution c'
	DB	'ontext', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CMNJHAKA@epsilon?5transition?5left?5at?5runt@
CONST	SEGMENT
??_C@_0CE@CMNJHAKA@epsilon?5transition?5left?5at?5runt@ DB 'epsilon trans'
	DB	'ition left at runtime', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IJHGICCJ@running?5regexp@
CONST	SEGMENT
??_C@_0P@IJHGICCJ@running?5regexp@ DB 'running regexp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CPBANDJM@exec?5save?3?5allocation?5failed@
CONST	SEGMENT
??_C@_0BN@CPBANDJM@exec?5save?3?5allocation?5failed@ DB 'exec save: alloc'
	DB	'ation failed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PEGCJGLF@saving?5regexp@
CONST	SEGMENT
??_C@_0O@PEGCJGLF@saving?5regexp@ DB 'saving regexp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@POCEJEIB@TODO?3?5XML_REGEXP_STRING?6@
CONST	SEGMENT
??_C@_0BJ@POCEJEIB@TODO?3?5XML_REGEXP_STRING?6@ DB 'TODO: XML_REGEXP_STRI'
	DB	'NG', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LMLDANHN@genrate?5transition?3?5atom?5?$DN?$DN?5NUL@
CONST	SEGMENT
??_C@_0CB@LMLDANHN@genrate?5transition?3?5atom?5?$DN?$DN?5NUL@ DB 'genrat'
	DB	'e transition: atom == NULL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NHLBLLB@adding?5state@
CONST	SEGMENT
??_C@_0N@NHLBLLB@adding?5state@ DB 'adding state', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PPLNMJBI@add?5state?3?5target?5is?5NULL@
CONST	SEGMENT
??_C@_0BK@PPLNMJBI@add?5state?3?5target?5is?5NULL@ DB 'add state: target '
	DB	'is NULL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KPILLGIF@add?5state?3?5state?5is?5NULL@
CONST	SEGMENT
??_C@_0BJ@KPILLGIF@add?5state?3?5state?5is?5NULL@ DB 'add state: state is'
	DB	' NULL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FHJHIDDF@adding?5transition@
CONST	SEGMENT
??_C@_0BC@FHJHIDDF@adding?5transition@ DB 'adding transition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PMKNEBIB@pushing?5atom@
CONST	SEGMENT
??_C@_0N@PMKNEBIB@pushing?5atom@ DB 'pushing atom', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LIIKMBAE@atom?5push?3?5atom?5is?5NULL@
CONST	SEGMENT
??_C@_0BI@LIIKMBAE@atom?5push?3?5atom?5is?5NULL@ DB 'atom push: atom is N'
	DB	'ULL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OEINICOI@allocating?5counter@
CONST	SEGMENT
??_C@_0BD@OEINICOI@allocating?5counter@ DB 'allocating counter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@INOJCFAI@adding?5ranges@
CONST	SEGMENT
??_C@_0O@INOJCFAI@adding?5ranges@ DB 'adding ranges', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PJJILLLG@add?5range?3?5atom?5is?5not?5ranges@
CONST	SEGMENT
??_C@_0BO@PJJILLLG@add?5range?3?5atom?5is?5not?5ranges@ DB 'add range: at'
	DB	'om is not ranges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MEBKNK@add?5range?3?5atom?5is?5NULL@
CONST	SEGMENT
??_C@_0BI@MEBKNK@add?5range?3?5atom?5is?5NULL@ DB 'add range: atom is NUL'
	DB	'L', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NHMHHIIL@?$CFd?0?5?$CFd?5transitions?3?6@
CONST	SEGMENT
??_C@_0BF@NHMHHIIL@?$CFd?0?5?$CFd?5transitions?3?6@ DB '%d, %d transition'
	DB	's:', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06EFHALCBA@FINAL?5@
CONST	SEGMENT
??_C@_06EFHALCBA@FINAL?5@ DB 'FINAL ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BNBHINFE@START?5@
CONST	SEGMENT
??_C@_06BNBHINFE@START?5@ DB 'START ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NOIFNCJM@?5state?3?5@
CONST	SEGMENT
??_C@_08NOIFNCJM@?5state?3?5@ DB ' state: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DDAHGLMD@atom?5?$CFd?0?5to?5?$CFd?6@
CONST	SEGMENT
??_C@_0BA@DDAHGLMD@atom?5?$CFd?0?5to?5?$CFd?6@ DB 'atom %d, to %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JNAFCHHG@char?5?$CFc?5@
CONST	SEGMENT
??_C@_08JNAFCHHG@char?5?$CFc?5@ DB 'char %c ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BEFDCDEN@epsilon?5to?5?$CFd?6@
CONST	SEGMENT
??_C@_0P@BEFDCDEN@epsilon?5to?5?$CFd?6@ DB 'epsilon to %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LHHOLMKP@count?5based?5?$CFd?0?5@
CONST	SEGMENT
??_C@_0BB@LHHOLMKP@count?5based?5?$CFd?0?5@ DB 'count based %d, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CPMJDJHN@all?5transition?0?5@
CONST	SEGMENT
??_C@_0BB@CPMJDJHN@all?5transition?0?5@ DB 'all transition, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NIIDMCG@counted?5?$CFd?0?5@
CONST	SEGMENT
??_C@_0N@NIIDMCG@counted?5?$CFd?0?5@ DB 'counted %d, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EKCPHBCA@not?5determinist?0?5@
CONST	SEGMENT
??_C@_0BC@EKCPHBCA@not?5determinist?0?5@ DB 'not determinist, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PJNPIGKD@last?5not?5determinist?0?5@
CONST	SEGMENT
??_C@_0BH@PJNPIGKD@last?5not?5determinist?0?5@ DB 'last not determinist, '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDDAKHFP@removed?6@
CONST	SEGMENT
??_C@_08IDDAKHFP@removed?6@ DB 'removed', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KCGMBGNH@?5?5trans?3?5@
CONST	SEGMENT
??_C@_09KCGMBGNH@?5?5trans?3?5@ DB '  trans: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GBMGKEL@start?5?$CFd?5end?5?$CFd?6@
CONST	SEGMENT
??_C@_0BB@GBMGKEL@start?5?$CFd?5end?5?$CFd?6@ DB 'start %d end %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BCDCHBAM@?$CFd?5entries?6@
CONST	SEGMENT
??_C@_0M@BCDCHBAM@?$CFd?5entries?6@ DB '%d entries', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PCGOOLFO@char?5?$CFc?6@
CONST	SEGMENT
??_C@_08PCGOOLFO@char?5?$CFc?6@ DB 'char %c', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05IMLJLABD@?8?$CFs?8?5@
CONST	SEGMENT
??_C@_05IMLJLABD@?8?$CFs?8?5@ DB '''%s'' ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BIJEIIBB@?$CFd?9?$CFd?5@
CONST	SEGMENT
??_C@_06BIJEIIBB@?$CFd?9?$CFd?5@ DB '%d-%d ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04LKOGMCLF@not?5@
CONST	SEGMENT
??_C@_04LKOGMCLF@not?5@ DB 'not ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NJDBAOFA@NULL?6@
CONST	SEGMENT
??_C@_05NJDBAOFA@NULL?6@ DB 'NULL', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LAIPMBOA@?5atom?3?5@
CONST	SEGMENT
??_C@_07LAIPMBOA@?5atom?3?5@ DB ' atom: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BNCIEJGK@?$CFc?5?9?5?$CFc?6@
CONST	SEGMENT
??_C@_08BNCIEJGK@?$CFc?5?9?5?$CFc?6@ DB '%c - %c', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KDBNABJA@negative?5@
CONST	SEGMENT
??_C@_09KDBNABJA@negative?5@ DB 'negative ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LLABEBOE@?5?5range?3?5@
CONST	SEGMENT
??_C@_09LLABEBOE@?5?5range?3?5@ DB '  range: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DIDGAIEC@all?5@
CONST	SEGMENT
??_C@_04DIDGAIEC@all?5@ DB 'all ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09EPCGBNDN@onceonly?5@
CONST	SEGMENT
??_C@_09EPCGBNDN@onceonly?5@ DB 'onceonly ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IBKHBGID@range?5@
CONST	SEGMENT
??_C@_06IBKHBGID@range?5@ DB 'range ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KBCCKLEO@?$CL?5@
CONST	SEGMENT
??_C@_02KBCCKLEO@?$CL?5@ DB '+ ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAOAMBHJ@?$CK?5@
CONST	SEGMENT
??_C@_02KAOAMBHJ@?$CK?5@ DB '* ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LKANKAOC@?$DP?5@
CONST	SEGMENT
??_C@_02LKANKAOC@?$DP?5@ DB '? ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GDJGFPHL@once?5@
CONST	SEGMENT
??_C@_05GDJGFPHL@once?5@ DB 'once ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HDNEPAAO@BLOCK?5@
CONST	SEGMENT
??_C@_06HDNEPAAO@BLOCK?5@ DB 'BLOCK ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NECDEFOF@OTHER_NA?5@
CONST	SEGMENT
??_C@_09NECDEFOF@OTHER_NA?5@ DB 'OTHER_NA ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DEHNHHA@OTHER_PRIVATE?5@
CONST	SEGMENT
??_C@_0P@DEHNHHA@OTHER_PRIVATE?5@ DB 'OTHER_PRIVATE ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BACNFCMB@OTHER_FORMAT?5@
CONST	SEGMENT
??_C@_0O@BACNFCMB@OTHER_FORMAT?5@ DB 'OTHER_FORMAT ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FGFCBEPI@OTHER_CONTROL?5@
CONST	SEGMENT
??_C@_0P@FGFCBEPI@OTHER_CONTROL?5@ DB 'OTHER_CONTROL ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HJDKAKAL@OTHER?5@
CONST	SEGMENT
??_C@_06HJDKAKAL@OTHER?5@ DB 'OTHER ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LKPECLCL@SYMBOL_OTHERS?5@
CONST	SEGMENT
??_C@_0P@LKPECLCL@SYMBOL_OTHERS?5@ DB 'SYMBOL_OTHERS ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CEPANLJE@SYMBOL_MODIFIER?5@
CONST	SEGMENT
??_C@_0BB@CEPANLJE@SYMBOL_MODIFIER?5@ DB 'SYMBOL_MODIFIER ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MBFAMNND@SYMBOL_CURRENCY?5@
CONST	SEGMENT
??_C@_0BB@MBFAMNND@SYMBOL_CURRENCY?5@ DB 'SYMBOL_CURRENCY ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LBDJILGE@SYMBOL_MATH?5@
CONST	SEGMENT
??_C@_0N@LBDJILGE@SYMBOL_MATH?5@ DB 'SYMBOL_MATH ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EJLPHCCB@SYMBOL?5@
CONST	SEGMENT
??_C@_07EJLPHCCB@SYMBOL?5@ DB 'SYMBOL ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DGHGIFFK@SEPAR_PARA?5@
CONST	SEGMENT
??_C@_0M@DGHGIFFK@SEPAR_PARA?5@ DB 'SEPAR_PARA ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GPNEEMIA@SEPAR_LINE?5@
CONST	SEGMENT
??_C@_0M@GPNEEMIA@SEPAR_LINE?5@ DB 'SEPAR_LINE ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CEDLANHM@SEPAR_SPACE?5@
CONST	SEGMENT
??_C@_0N@CEDLANHM@SEPAR_SPACE?5@ DB 'SEPAR_SPACE ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MODMGGJL@SEPAR?5@
CONST	SEGMENT
??_C@_06MODMGGJL@SEPAR?5@ DB 'SEPAR ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FIEDELON@PUNCT_OTHERS?5@
CONST	SEGMENT
??_C@_0O@FIEDELON@PUNCT_OTHERS?5@ DB 'PUNCT_OTHERS ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EBCHGEDF@PUNCT_FINQUOTE?5@
CONST	SEGMENT
??_C@_0BA@EBCHGEDF@PUNCT_FINQUOTE?5@ DB 'PUNCT_FINQUOTE ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HJFINBLL@PUNCT_INITQUOTE?5@
CONST	SEGMENT
??_C@_0BB@HJFINBLL@PUNCT_INITQUOTE?5@ DB 'PUNCT_INITQUOTE ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OCGFHNOE@PUNCT_CLOSE?5@
CONST	SEGMENT
??_C@_0N@OCGFHNOE@PUNCT_CLOSE?5@ DB 'PUNCT_CLOSE ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FHHCCFFM@PUNCT_OPEN?5@
CONST	SEGMENT
??_C@_0M@FHHCCFFM@PUNCT_OPEN?5@ DB 'PUNCT_OPEN ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BBMKBPFM@PUNCT_DASH?5@
CONST	SEGMENT
??_C@_0M@BBMKBPFM@PUNCT_DASH?5@ DB 'PUNCT_DASH ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DCHADIII@PUNCT_CONNECTOR?5@
CONST	SEGMENT
??_C@_0BB@DCHADIII@PUNCT_CONNECTOR?5@ DB 'PUNCT_CONNECTOR ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06INFGODEH@PUNCT?5@
CONST	SEGMENT
??_C@_06INFGODEH@PUNCT?5@ DB 'PUNCT ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PDKFLOJK@NUMBER_OTHERS?5@
CONST	SEGMENT
??_C@_0P@PDKFLOJK@NUMBER_OTHERS?5@ DB 'NUMBER_OTHERS ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FJBLFHMA@NUMBER_LETTER?5@
CONST	SEGMENT
??_C@_0P@FJBLFHMA@NUMBER_LETTER?5@ DB 'NUMBER_LETTER ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JLEBGNKM@NUMBER_DECIMAL?5@
CONST	SEGMENT
??_C@_0BA@JLEBGNKM@NUMBER_DECIMAL?5@ DB 'NUMBER_DECIMAL ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BAKEFCLB@NUMBER?5@
CONST	SEGMENT
??_C@_07BAKEFCLB@NUMBER?5@ DB 'NUMBER ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NNNPPLBP@MARK_ENCLOSING?5@
CONST	SEGMENT
??_C@_0BA@NNNPPLBP@MARK_ENCLOSING?5@ DB 'MARK_ENCLOSING ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GJKDPMF@MARK_SPACECOMBINING?5@
CONST	SEGMENT
??_C@_0BF@GJKDPMF@MARK_SPACECOMBINING?5@ DB 'MARK_SPACECOMBINING ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FIDLEIEL@MARK_NONSPACING?5@
CONST	SEGMENT
??_C@_0BB@FIDLEIEL@MARK_NONSPACING?5@ DB 'MARK_NONSPACING ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05BACHLHLN@MARK?5@
CONST	SEGMENT
??_C@_05BACHLHLN@MARK?5@ DB 'MARK ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ONCGNHEJ@LETTER_OTHERS?5@
CONST	SEGMENT
??_C@_0P@ONCGNHEJ@LETTER_OTHERS?5@ DB 'LETTER_OTHERS ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MHDADLFE@LETTER_MODIFIER?5@
CONST	SEGMENT
??_C@_0BB@MHDADLFE@LETTER_MODIFIER?5@ DB 'LETTER_MODIFIER ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FGJDLGPN@LETTER_TITLECASE?5@
CONST	SEGMENT
??_C@_0BC@FGJDLGPN@LETTER_TITLECASE?5@ DB 'LETTER_TITLECASE ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MLADGGJK@LETTER_LOWERCASE?5@
CONST	SEGMENT
??_C@_0BC@MLADGGJK@LETTER_LOWERCASE?5@ DB 'LETTER_LOWERCASE ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KMHMCLHI@LETTER_UPPERCASE?5@
CONST	SEGMENT
??_C@_0BC@KMHMCLHI@LETTER_UPPERCASE?5@ DB 'LETTER_UPPERCASE ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07POCGPIHD@LETTER?5@
CONST	SEGMENT
??_C@_07POCGPIHD@LETTER?5@ DB 'LETTER ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MCPFODOD@notrealchar?5@
CONST	SEGMENT
??_C@_0N@MCPFODOD@notrealchar?5@ DB 'notrealchar ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MOCDMJPB@realchar?5@
CONST	SEGMENT
??_C@_09MOCDMJPB@realchar?5@ DB 'realchar ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EDJHICHL@notdecimal?5@
CONST	SEGMENT
??_C@_0M@EDJHICHL@notdecimal?5@ DB 'notdecimal ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CDKGKILA@decimal?5@
CONST	SEGMENT
??_C@_08CDKGKILA@decimal?5@ DB 'decimal ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GALMIDBF@notnamechar?5@
CONST	SEGMENT
??_C@_0N@GALMIDBF@notnamechar?5@ DB 'notnamechar ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GMGKKJAH@namechar?5@
CONST	SEGMENT
??_C@_09GMGKKJAH@namechar?5@ DB 'namechar ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PKALLFNP@notinitname?5@
CONST	SEGMENT
??_C@_0N@PKALLFNP@notinitname?5@ DB 'notinitname ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PGNNJPMN@initname?5@
CONST	SEGMENT
??_C@_09PGNNJPMN@initname?5@ DB 'initname ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PIGAJOFL@notspace?5@
CONST	SEGMENT
??_C@_09PIGAJOFL@notspace?5@ DB 'notspace ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IFBFMEEE@anyspace?5@
CONST	SEGMENT
??_C@_09IFBFMEEE@anyspace?5@ DB 'anyspace ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IIDGBAEF@anychar?5@
CONST	SEGMENT
??_C@_08IIDGBAEF@anychar?5@ DB 'anychar ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HBAIICBM@string?5@
CONST	SEGMENT
??_C@_07HBAIICBM@string?5@ DB 'string ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BABENLJO@subexpr?5@
CONST	SEGMENT
??_C@_08BABENLJO@subexpr?5@ DB 'subexpr ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IPEOMBMH@ranges?5@
CONST	SEGMENT
??_C@_07IPEOMBMH@ranges?5@ DB 'ranges ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DFHMJFEK@charval?5@
CONST	SEGMENT
??_C@_08DFHMJFEK@charval?5@ DB 'charval ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LJGDJFJP@epsilon?5@
CONST	SEGMENT
??_C@_08LJGDJFJP@epsilon?5@ DB 'epsilon ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CKELLPME@allocating?5state@
CONST	SEGMENT
??_C@_0BB@CKELLPME@allocating?5state@ DB 'allocating state', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ECMBACNP@copying?5atom@
CONST	SEGMENT
??_C@_0N@ECMBACNP@copying?5atom@ DB 'copying atom', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JCPCIFNM@allocating?5atom@
CONST	SEGMENT
??_C@_0BA@JCPCIFNM@allocating?5atom@ DB 'allocating atom', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PBEHJOM@allocating?5range@
CONST	SEGMENT
??_C@_0BB@PBEHJOM@allocating?5range@ DB 'allocating range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FJPDMDM@compiling?5regexp@
CONST	SEGMENT
??_C@_0BB@FJPDMDM@compiling?5regexp@ DB 'compiling regexp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFFLONMP@failed?5to?5compile?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@CFFLONMP@failed?5to?5compile?3?5?$CFs?6@ DB 'failed to compile:'
	DB	' %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ DB 'Memory al'
	DB	'location failed : %s', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpDumpInt
_TEXT	SEGMENT
tv70 = -56						; size = 4
_rep$1 = -48						; size = 40
_c$ = -4						; size = 4
_buf$ = 8						; size = 4
_expr$ = 12						; size = 4
_glob$ = 16						; size = 4
_xmlExpDumpInt PROC					; COMDAT

; 8043 : xmlExpDumpInt(xmlBufferPtr buf, xmlExpNodePtr expr, int glob) {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 8044 :     xmlExpNodePtr c;
; 8045 : 
; 8046 :     if (expr == NULL) return;

	cmp	DWORD PTR _expr$[ebp], 0
	jne	SHORT $LN4@xmlExpDump
	jmp	$LN1@xmlExpDump
$LN4@xmlExpDump:

; 8047 :     if (glob) xmlBufferWriteChar(buf, "(");

	cmp	DWORD PTR _glob$[ebp], 0
	je	SHORT $LN5@xmlExpDump
	push	OFFSET ??_C@_01ODHLEDKK@?$CI@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferWriteChar
	add	esp, 8
$LN5@xmlExpDump:

; 8048 :     switch (expr->type) {

	mov	ecx, DWORD PTR _expr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv70[ebp], edx
	cmp	DWORD PTR tv70[ebp], 5
	ja	$LN37@xmlExpDump
	mov	eax, DWORD PTR tv70[ebp]
	jmp	DWORD PTR $LN43@xmlExpDump[eax*4]
$LN6@xmlExpDump:

; 8049 :         case XML_EXP_EMPTY:
; 8050 : 	    xmlBufferWriteChar(buf, "empty");

	push	OFFSET ??_C@_05LBJMNBOG@empty@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferWriteChar
	add	esp, 8

; 8051 : 	    break;

	jmp	$LN2@xmlExpDump
$LN7@xmlExpDump:

; 8052 :         case XML_EXP_FORBID:
; 8053 : 	    xmlBufferWriteChar(buf, "forbidden");

	push	OFFSET ??_C@_09PDGFMGED@forbidden@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteChar
	add	esp, 8

; 8054 : 	    break;

	jmp	$LN2@xmlExpDump
$LN8@xmlExpDump:

; 8055 :         case XML_EXP_ATOM:
; 8056 : 	    xmlBufferWriteCHAR(buf, expr->exp_str);

	mov	eax, DWORD PTR _expr$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteCHAR
	add	esp, 8

; 8057 : 	    break;

	jmp	$LN2@xmlExpDump
$LN9@xmlExpDump:

; 8058 :         case XML_EXP_SEQ:
; 8059 : 	    c = expr->exp_left;

	mov	eax, DWORD PTR _expr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _c$[ebp], ecx

; 8060 : 	    if ((c->type == XML_EXP_SEQ) || (c->type == XML_EXP_OR))

	mov	edx, DWORD PTR _c$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 3
	je	SHORT $LN12@xmlExpDump
	mov	ecx, DWORD PTR _c$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 4
	jne	SHORT $LN10@xmlExpDump
$LN12@xmlExpDump:

; 8061 : 	        xmlExpDumpInt(buf, c, 1);

	push	1
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlExpDumpInt
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN11@xmlExpDump
$LN10@xmlExpDump:

; 8062 : 	    else
; 8063 : 	        xmlExpDumpInt(buf, c, 0);

	push	0
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlExpDumpInt
	add	esp, 12					; 0000000cH
$LN11@xmlExpDump:

; 8064 : 	    xmlBufferWriteChar(buf, " , ");

	push	OFFSET ??_C@_03NKFKBEPL@?5?0?5@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferWriteChar
	add	esp, 8

; 8065 : 	    c = expr->exp_right;

	mov	edx, DWORD PTR _expr$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _c$[ebp], eax

; 8066 : 	    if ((c->type == XML_EXP_SEQ) || (c->type == XML_EXP_OR))

	mov	ecx, DWORD PTR _c$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 3
	je	SHORT $LN15@xmlExpDump
	mov	eax, DWORD PTR _c$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 4
	jne	SHORT $LN13@xmlExpDump
$LN15@xmlExpDump:

; 8067 : 	        xmlExpDumpInt(buf, c, 1);

	push	1
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlExpDumpInt
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN14@xmlExpDump
$LN13@xmlExpDump:

; 8068 : 	    else
; 8069 : 	        xmlExpDumpInt(buf, c, 0);

	push	0
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlExpDumpInt
	add	esp, 12					; 0000000cH
$LN14@xmlExpDump:

; 8070 :             break;

	jmp	$LN2@xmlExpDump
$LN16@xmlExpDump:

; 8071 :         case XML_EXP_OR:
; 8072 : 	    c = expr->exp_left;

	mov	eax, DWORD PTR _expr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _c$[ebp], ecx

; 8073 : 	    if ((c->type == XML_EXP_SEQ) || (c->type == XML_EXP_OR))

	mov	edx, DWORD PTR _c$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 3
	je	SHORT $LN19@xmlExpDump
	mov	ecx, DWORD PTR _c$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 4
	jne	SHORT $LN17@xmlExpDump
$LN19@xmlExpDump:

; 8074 : 	        xmlExpDumpInt(buf, c, 1);

	push	1
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlExpDumpInt
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN18@xmlExpDump
$LN17@xmlExpDump:

; 8075 : 	    else
; 8076 : 	        xmlExpDumpInt(buf, c, 0);

	push	0
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlExpDumpInt
	add	esp, 12					; 0000000cH
$LN18@xmlExpDump:

; 8077 : 	    xmlBufferWriteChar(buf, " | ");

	push	OFFSET ??_C@_03LGOGDKEL@?5?$HM?5@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferWriteChar
	add	esp, 8

; 8078 : 	    c = expr->exp_right;

	mov	edx, DWORD PTR _expr$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _c$[ebp], eax

; 8079 : 	    if ((c->type == XML_EXP_SEQ) || (c->type == XML_EXP_OR))

	mov	ecx, DWORD PTR _c$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 3
	je	SHORT $LN22@xmlExpDump
	mov	eax, DWORD PTR _c$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 4
	jne	SHORT $LN20@xmlExpDump
$LN22@xmlExpDump:

; 8080 : 	        xmlExpDumpInt(buf, c, 1);

	push	1
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlExpDumpInt
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN21@xmlExpDump
$LN20@xmlExpDump:

; 8081 : 	    else
; 8082 : 	        xmlExpDumpInt(buf, c, 0);

	push	0
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlExpDumpInt
	add	esp, 12					; 0000000cH
$LN21@xmlExpDump:

; 8083 :             break;

	jmp	$LN2@xmlExpDump
$LN23@xmlExpDump:

; 8084 :         case XML_EXP_COUNT: {
; 8085 : 	    char rep[40];
; 8086 : 
; 8087 : 	    c = expr->exp_left;

	mov	eax, DWORD PTR _expr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _c$[ebp], ecx

; 8088 : 	    if ((c->type == XML_EXP_SEQ) || (c->type == XML_EXP_OR))

	mov	edx, DWORD PTR _c$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 3
	je	SHORT $LN26@xmlExpDump
	mov	ecx, DWORD PTR _c$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 4
	jne	SHORT $LN24@xmlExpDump
$LN26@xmlExpDump:

; 8089 : 	        xmlExpDumpInt(buf, c, 1);

	push	1
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlExpDumpInt
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN25@xmlExpDump
$LN24@xmlExpDump:

; 8090 : 	    else
; 8091 : 	        xmlExpDumpInt(buf, c, 0);

	push	0
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlExpDumpInt
	add	esp, 12					; 0000000cH
$LN25@xmlExpDump:

; 8092 : 	    if ((expr->exp_min == 0) && (expr->exp_max == 1)) {

	mov	ecx, DWORD PTR _expr$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN27@xmlExpDump
	mov	edx, DWORD PTR _expr$[ebp]
	cmp	DWORD PTR [edx+24], 1
	jne	SHORT $LN27@xmlExpDump

; 8093 : 		rep[0] = '?';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _rep$1[ebp+ecx], 63		; 0000003fH

; 8094 : 		rep[1] = 0;

	mov	edx, 1
	shl	edx, 0
	mov	BYTE PTR _rep$1[ebp+edx], 0
	jmp	$LN28@xmlExpDump
$LN27@xmlExpDump:

; 8095 : 	    } else if ((expr->exp_min == 0) && (expr->exp_max == -1)) {

	mov	eax, DWORD PTR _expr$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN29@xmlExpDump
	mov	ecx, DWORD PTR _expr$[ebp]
	cmp	DWORD PTR [ecx+24], -1
	jne	SHORT $LN29@xmlExpDump

; 8096 : 		rep[0] = '*';

	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _rep$1[ebp+eax], 42		; 0000002aH

; 8097 : 		rep[1] = 0;

	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR _rep$1[ebp+ecx], 0
	jmp	$LN28@xmlExpDump
$LN29@xmlExpDump:

; 8098 : 	    } else if ((expr->exp_min == 1) && (expr->exp_max == -1)) {

	mov	edx, DWORD PTR _expr$[ebp]
	cmp	DWORD PTR [edx+20], 1
	jne	SHORT $LN31@xmlExpDump
	mov	eax, DWORD PTR _expr$[ebp]
	cmp	DWORD PTR [eax+24], -1
	jne	SHORT $LN31@xmlExpDump

; 8099 : 		rep[0] = '+';

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _rep$1[ebp+edx], 43		; 0000002bH

; 8100 : 		rep[1] = 0;

	mov	eax, 1
	shl	eax, 0
	mov	BYTE PTR _rep$1[ebp+eax], 0
	jmp	SHORT $LN28@xmlExpDump
$LN31@xmlExpDump:

; 8101 : 	    } else if (expr->exp_max == expr->exp_min) {

	mov	ecx, DWORD PTR _expr$[ebp]
	mov	edx, DWORD PTR _expr$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+20]
	jne	SHORT $LN33@xmlExpDump

; 8102 : 	        snprintf(rep, 39, "{%d}", expr->exp_min);

	mov	ecx, DWORD PTR _expr$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	push	OFFSET ??_C@_04PFHMOCHH@?$HL?$CFd?$HN@
	push	39					; 00000027H
	lea	eax, DWORD PTR _rep$1[ebp]
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN28@xmlExpDump
$LN33@xmlExpDump:

; 8103 : 	    } else if (expr->exp_max < 0) {

	mov	ecx, DWORD PTR _expr$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jge	SHORT $LN35@xmlExpDump

; 8104 : 	        snprintf(rep, 39, "{%d,inf}", expr->exp_min);

	mov	edx, DWORD PTR _expr$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	push	OFFSET ??_C@_08EMBBFCPF@?$HL?$CFd?0inf?$HN@
	push	39					; 00000027H
	lea	ecx, DWORD PTR _rep$1[ebp]
	push	ecx
	call	_snprintf
	add	esp, 16					; 00000010H

; 8105 : 	    } else {

	jmp	SHORT $LN28@xmlExpDump
$LN35@xmlExpDump:

; 8106 : 	        snprintf(rep, 39, "{%d,%d}", expr->exp_min, expr->exp_max);

	mov	edx, DWORD PTR _expr$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _expr$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	push	OFFSET ??_C@_07CDJFAPGJ@?$HL?$CFd?0?$CFd?$HN@
	push	39					; 00000027H
	lea	eax, DWORD PTR _rep$1[ebp]
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H
$LN28@xmlExpDump:

; 8107 : 	    }
; 8108 : 	    rep[39] = 0;

	mov	ecx, 1
	imul	edx, ecx, 39
	mov	BYTE PTR _rep$1[ebp+edx], 0

; 8109 : 	    xmlBufferWriteChar(buf, rep);

	lea	eax, DWORD PTR _rep$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferWriteChar
	add	esp, 8

; 8110 : 	    break;

	jmp	SHORT $LN2@xmlExpDump
$LN37@xmlExpDump:

; 8111 : 	}
; 8112 : 	default:
; 8113 : 	    fprintf(stderr, "Error in tree\n");

	push	OFFSET ??_C@_0P@OCJKDKLA@Error?5in?5tree?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8
$LN2@xmlExpDump:

; 8114 :     }
; 8115 :     if (glob)

	cmp	DWORD PTR _glob$[ebp], 0
	je	SHORT $LN1@xmlExpDump

; 8116 :         xmlBufferWriteChar(buf, ")");

	push	OFFSET ??_C@_01PKGAHCOL@?$CJ@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteChar
	add	esp, 8
$LN1@xmlExpDump:

; 8117 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN42@xmlExpDump
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN42@xmlExpDump:
	DD	1
	DD	$LN41@xmlExpDump
$LN41@xmlExpDump:
	DD	-48					; ffffffd0H
	DD	40					; 00000028H
	DD	$LN40@xmlExpDump
$LN40@xmlExpDump:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	0
$LN43@xmlExpDump:
	DD	$LN6@xmlExpDump
	DD	$LN7@xmlExpDump
	DD	$LN8@xmlExpDump
	DD	$LN9@xmlExpDump
	DD	$LN16@xmlExpDump
	DD	$LN23@xmlExpDump
_xmlExpDumpInt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpParseSeq
_TEXT	SEGMENT
_right$ = -8						; size = 4
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlExpParseSeq PROC					; COMDAT

; 7970 : xmlExpParseSeq(xmlExpCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 7971 :     xmlExpNodePtr ret, right;
; 7972 : 
; 7973 :     ret = xmlExpParseOr(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpParseOr
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax
$LN2@xmlExpPars:

; 7974 :     SKIP_BLANKS

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN6@xmlExpPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN6@xmlExpPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN6@xmlExpPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jne	SHORT $LN4@xmlExpPars
$LN6@xmlExpPars:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+28], edx
	jmp	SHORT $LN2@xmlExpPars
$LN4@xmlExpPars:

; 7975 :     while (CUR == '|') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 124				; 0000007cH
	jne	SHORT $LN5@xmlExpPars

; 7976 :         NEXT

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+28], edx

; 7977 : 	right = xmlExpParseOr(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpParseOr
	add	esp, 4
	mov	DWORD PTR _right$[ebp], eax

; 7978 : 	if (right == NULL) {

	cmp	DWORD PTR _right$[ebp], 0
	jne	SHORT $LN7@xmlExpPars

; 7979 : 	    xmlExpFree(ctxt, ret);

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8

; 7980 : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpPars
$LN7@xmlExpPars:

; 7981 : 	}
; 7982 : 	ret = xmlExpHashGetEntry(ctxt, XML_EXP_OR, ret, right, NULL, 0, 0);

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _right$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret$[ebp], eax

; 7983 : 	if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN8@xmlExpPars

; 7984 : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpPars
$LN8@xmlExpPars:

; 7985 :     }

	jmp	SHORT $LN4@xmlExpPars
$LN5@xmlExpPars:

; 7986 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlExpPars:

; 7987 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpParseSeq ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpParseOr
_TEXT	SEGMENT
_max$1 = -20						; size = 4
_min$2 = -16						; size = 4
_val$ = -12						; size = 4
_ret$ = -8						; size = 4
_base$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlExpParseOr PROC					; COMDAT

; 7893 : xmlExpParseOr(xmlExpCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlExpPars:

; 7894 :     const char *base;
; 7895 :     xmlExpNodePtr ret;
; 7896 :     const xmlChar *val;
; 7897 : 
; 7898 :     SKIP_BLANKS

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN24@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN24@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN24@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jne	SHORT $LN3@xmlExpPars
$LN24@xmlExpPars:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+28], ecx
	jmp	SHORT $LN2@xmlExpPars
$LN3@xmlExpPars:

; 7899 :     base = ctxt->cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _base$[ebp], ecx

; 7900 :     if (*ctxt->cur == '(') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 40					; 00000028H
	jne	$LN8@xmlExpPars

; 7901 :         NEXT

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 7902 : 	ret = xmlExpParseExpr(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpParseExpr
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax
$LN4@xmlExpPars:

; 7903 : 	SKIP_BLANKS

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN26@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN26@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN26@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jne	SHORT $LN5@xmlExpPars
$LN26@xmlExpPars:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+28], ecx
	jmp	SHORT $LN4@xmlExpPars
$LN5@xmlExpPars:

; 7904 : 	if (*ctxt->cur != ')') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 41					; 00000029H
	je	SHORT $LN27@xmlExpPars

; 7905 : 	    fprintf(stderr, "unbalanced '(' : %s\n", base);

	mov	eax, DWORD PTR _base$[ebp]
	push	eax
	push	OFFSET ??_C@_0BF@FNELPLND@unbalanced?5?8?$CI?8?5?3?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 7906 : 	    xmlExpFree(ctxt, ret);

	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpFree
	add	esp, 8

; 7907 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpPars
$LN27@xmlExpPars:

; 7908 : 	}
; 7909 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+28], ecx
$LN6@xmlExpPars:

; 7910 : 	SKIP_BLANKS

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN28@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN28@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN28@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jne	SHORT $LN7@xmlExpPars
$LN28@xmlExpPars:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+28], ecx
	jmp	SHORT $LN6@xmlExpPars
$LN7@xmlExpPars:

; 7911 : 	goto parse_quantifier;

	jmp	$parse_quantifier$50
$LN8@xmlExpPars:

; 7912 :     }
; 7913 :     while ((CUR != 0) && (!(IS_BLANK(CUR))) && (CUR != '(') &&
; 7914 :            (CUR != ')') && (CUR != '|') && (CUR != ',') && (CUR != '{') &&
; 7915 : 	   (CUR != '*') && (CUR != '+') && (CUR != '?') && (CUR != '}'))

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN9@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	$LN9@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	$LN9@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	$LN9@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	je	$LN9@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 40					; 00000028H
	je	$LN9@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 41					; 00000029H
	je	SHORT $LN9@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 124				; 0000007cH
	je	SHORT $LN9@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	je	SHORT $LN9@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 123				; 0000007bH
	je	SHORT $LN9@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	je	SHORT $LN9@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 43					; 0000002bH
	je	SHORT $LN9@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 63					; 0000003fH
	je	SHORT $LN9@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 125				; 0000007dH
	je	SHORT $LN9@xmlExpPars

; 7916 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+28], ecx
	jmp	$LN8@xmlExpPars
$LN9@xmlExpPars:

; 7917 :     val = xmlDictLookup(ctxt->dict, BAD_CAST base, ctxt->cur - base);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	sub	ecx, DWORD PTR _base$[ebp]
	push	ecx
	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _val$[ebp], eax

; 7918 :     if (val == NULL)

	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN29@xmlExpPars

; 7919 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpPars
$LN29@xmlExpPars:

; 7920 :     ret = xmlExpHashGetEntry(ctxt, XML_EXP_ATOM, NULL, NULL, val, 0, 0);

	push	0
	push	0
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	push	0
	push	0
	push	2
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret$[ebp], eax

; 7921 :     if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN10@xmlExpPars

; 7922 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpPars
$LN10@xmlExpPars:

; 7923 :     SKIP_BLANKS

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN31@xmlExpPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN31@xmlExpPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN31@xmlExpPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jne	SHORT $parse_quantifier$50
$LN31@xmlExpPars:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+28], edx
	jmp	SHORT $LN10@xmlExpPars
$parse_quantifier$50:

; 7924 : parse_quantifier:
; 7925 :     if (CUR == '{') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 123				; 0000007bH
	jne	$LN32@xmlExpPars

; 7926 :         int min, max;
; 7927 : 
; 7928 :         NEXT

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+28], edx

; 7929 : 	min = xmlExpParseNumber(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpParseNumber
	add	esp, 4
	mov	DWORD PTR _min$2[ebp], eax

; 7930 : 	if (min < 0) {

	cmp	DWORD PTR _min$2[ebp], 0
	jge	SHORT $LN12@xmlExpPars

; 7931 : 	    xmlExpFree(ctxt, ret);

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8

; 7932 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpPars
$LN12@xmlExpPars:

; 7933 : 	}
; 7934 : 	SKIP_BLANKS

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN35@xmlExpPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN35@xmlExpPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN35@xmlExpPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jne	SHORT $LN13@xmlExpPars
$LN35@xmlExpPars:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+28], edx
	jmp	SHORT $LN12@xmlExpPars
$LN13@xmlExpPars:

; 7935 : 	if (CUR == ',') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN36@xmlExpPars

; 7936 : 	    NEXT

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+28], edx

; 7937 : 	    max = xmlExpParseNumber(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpParseNumber
	add	esp, 4
	mov	DWORD PTR _max$1[ebp], eax
$LN14@xmlExpPars:

; 7938 : 	    SKIP_BLANKS

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN38@xmlExpPars
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN38@xmlExpPars
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN38@xmlExpPars
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jne	SHORT $LN15@xmlExpPars
$LN38@xmlExpPars:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+28], eax
	jmp	SHORT $LN14@xmlExpPars
$LN15@xmlExpPars:

; 7939 : 	} else

	jmp	SHORT $LN37@xmlExpPars
$LN36@xmlExpPars:

; 7940 : 	    max = min;

	mov	edx, DWORD PTR _min$2[ebp]
	mov	DWORD PTR _max$1[ebp], edx
$LN37@xmlExpPars:

; 7941 : 	if (CUR != '}') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 125				; 0000007dH
	je	SHORT $LN39@xmlExpPars

; 7942 : 	    xmlExpFree(ctxt, ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8

; 7943 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpPars
$LN39@xmlExpPars:

; 7944 : 	}
; 7945 :         NEXT

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 7946 : 	ret = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, ret, NULL, NULL,

	mov	edx, DWORD PTR _max$1[ebp]
	push	edx
	mov	eax, DWORD PTR _min$2[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	push	5
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret$[ebp], eax
$LN16@xmlExpPars:

; 7947 : 	                         min, max);
; 7948 : 	SKIP_BLANKS

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN40@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN40@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN40@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jne	SHORT $LN17@xmlExpPars
$LN40@xmlExpPars:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+28], ecx
	jmp	SHORT $LN16@xmlExpPars
$LN17@xmlExpPars:

; 7949 :     } else if (CUR == '?') {

	jmp	$LN33@xmlExpPars
$LN32@xmlExpPars:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 63					; 0000003fH
	jne	SHORT $LN41@xmlExpPars

; 7950 :         NEXT

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 7951 : 	ret = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, ret, NULL, NULL,

	push	1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	push	5
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret$[ebp], eax
$LN18@xmlExpPars:

; 7952 : 	                         0, 1);
; 7953 : 	SKIP_BLANKS

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN43@xmlExpPars
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN43@xmlExpPars
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN43@xmlExpPars
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jne	SHORT $LN19@xmlExpPars
$LN43@xmlExpPars:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+28], eax
	jmp	SHORT $LN18@xmlExpPars
$LN19@xmlExpPars:

; 7954 :     } else if (CUR == '+') {

	jmp	$LN33@xmlExpPars
$LN41@xmlExpPars:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	jne	SHORT $LN44@xmlExpPars

; 7955 :         NEXT

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 7956 : 	ret = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, ret, NULL, NULL,

	push	-1
	push	1
	push	0
	push	0
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	push	5
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret$[ebp], eax
$LN20@xmlExpPars:

; 7957 : 	                         1, -1);
; 7958 : 	SKIP_BLANKS

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN46@xmlExpPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN46@xmlExpPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN46@xmlExpPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jne	SHORT $LN21@xmlExpPars
$LN46@xmlExpPars:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+28], edx
	jmp	SHORT $LN20@xmlExpPars
$LN21@xmlExpPars:

; 7959 :     } else if (CUR == '*') {

	jmp	$LN33@xmlExpPars
$LN44@xmlExpPars:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN33@xmlExpPars

; 7960 :         NEXT

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+28], edx

; 7961 : 	ret = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, ret, NULL, NULL,

	push	-1
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	push	5
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret$[ebp], eax
$LN22@xmlExpPars:

; 7962 : 	                         0, -1);
; 7963 : 	SKIP_BLANKS

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN48@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN48@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN48@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jne	SHORT $LN33@xmlExpPars
$LN48@xmlExpPars:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+28], ecx
	jmp	SHORT $LN22@xmlExpPars
$LN33@xmlExpPars:

; 7964 :     }
; 7965 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlExpPars:

; 7966 : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpParseOr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpParseNumber
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlExpParseNumber PROC					; COMDAT

; 7875 : xmlExpParseNumber(xmlExpCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 7876 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN2@xmlExpPars:

; 7877 : 
; 7878 :     SKIP_BLANKS

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN6@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN6@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN6@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jne	SHORT $LN3@xmlExpPars
$LN6@xmlExpPars:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+28], ecx
	jmp	SHORT $LN2@xmlExpPars
$LN3@xmlExpPars:

; 7879 :     if (CUR == '*') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	jne	SHORT $LN7@xmlExpPars

; 7880 : 	NEXT

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 7881 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlExpPars
$LN7@xmlExpPars:

; 7882 :     }
; 7883 :     if ((CUR < '0') || (CUR > '9'))

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN9@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN4@xmlExpPars
$LN9@xmlExpPars:

; 7884 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlExpPars
$LN4@xmlExpPars:

; 7885 :     while ((CUR >= '0') && (CUR <= '9')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN5@xmlExpPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jg	SHORT $LN5@xmlExpPars

; 7886 :         ret = ret * 10 + (CUR - '0');

	imul	eax, DWORD PTR _ret$[ebp], 10
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	ecx, BYTE PTR [edx]
	lea	edx, DWORD PTR [eax+ecx-48]
	mov	DWORD PTR _ret$[ebp], edx

; 7887 : 	NEXT

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 7888 :     }

	jmp	SHORT $LN4@xmlExpPars
$LN5@xmlExpPars:

; 7889 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlExpPars:

; 7890 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpParseNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpParseExpr
_TEXT	SEGMENT
_right$ = -8						; size = 4
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlExpParseExpr PROC					; COMDAT

; 7990 : xmlExpParseExpr(xmlExpCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 7991 :     xmlExpNodePtr ret, right;
; 7992 : 
; 7993 :     ret = xmlExpParseSeq(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpParseSeq
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax
$LN2@xmlExpPars:

; 7994 :     SKIP_BLANKS

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN6@xmlExpPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN6@xmlExpPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN6@xmlExpPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jne	SHORT $LN4@xmlExpPars
$LN6@xmlExpPars:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+28], edx
	jmp	SHORT $LN2@xmlExpPars
$LN4@xmlExpPars:

; 7995 :     while (CUR == ',') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN5@xmlExpPars

; 7996 :         NEXT

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+28], edx

; 7997 : 	right = xmlExpParseSeq(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpParseSeq
	add	esp, 4
	mov	DWORD PTR _right$[ebp], eax

; 7998 : 	if (right == NULL) {

	cmp	DWORD PTR _right$[ebp], 0
	jne	SHORT $LN7@xmlExpPars

; 7999 : 	    xmlExpFree(ctxt, ret);

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8

; 8000 : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpPars
$LN7@xmlExpPars:

; 8001 : 	}
; 8002 : 	ret = xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, ret, right, NULL, 0, 0);

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _right$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	push	3
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret$[ebp], eax

; 8003 : 	if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN8@xmlExpPars

; 8004 : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpPars
$LN8@xmlExpPars:

; 8005 :     }

	jmp	SHORT $LN4@xmlExpPars
$LN5@xmlExpPars:

; 8006 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlExpPars:

; 8007 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpParseExpr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpDivide
_TEXT	SEGMENT
_tmp2$ = -12						; size = 4
_tmp$ = -8						; size = 4
_i$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_sub$ = 16						; size = 4
_mult$ = 20						; size = 4
_remain$ = 24						; size = 4
_xmlExpDivide PROC					; COMDAT

; 7266 :              xmlExpNodePtr *mult, xmlExpNodePtr *remain) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 7267 :     int i;
; 7268 :     xmlExpNodePtr tmp, tmp2;
; 7269 : 
; 7270 :     if (mult != NULL) *mult = NULL;

	cmp	DWORD PTR _mult$[ebp], 0
	je	SHORT $LN5@xmlExpDivi
	mov	eax, DWORD PTR _mult$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@xmlExpDivi:

; 7271 :     if (remain != NULL) *remain = NULL;

	cmp	DWORD PTR _remain$[ebp], 0
	je	SHORT $LN6@xmlExpDivi
	mov	ecx, DWORD PTR _remain$[ebp]
	mov	DWORD PTR [ecx], 0
$LN6@xmlExpDivi:

; 7272 :     if (exp->c_max == -1) return(0);

	mov	edx, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [edx+8], -1
	jne	SHORT $LN7@xmlExpDivi
	xor	eax, eax
	jmp	$LN1@xmlExpDivi
$LN7@xmlExpDivi:

; 7273 :     if (IS_NILLABLE(exp) && (!IS_NILLABLE(sub))) return(0);

	mov	eax, DWORD PTR _exp$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	and	ecx, 1
	je	SHORT $LN8@xmlExpDivi
	mov	edx, DWORD PTR _sub$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	and	eax, 1
	jne	SHORT $LN8@xmlExpDivi
	xor	eax, eax
	jmp	$LN1@xmlExpDivi
$LN8@xmlExpDivi:

; 7274 : 
; 7275 :     for (i = 1;i <= exp->c_max;i++) {

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@xmlExpDivi
$LN2@xmlExpDivi:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlExpDivi:
	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jg	$LN3@xmlExpDivi

; 7276 :         sub->ref++;

	mov	ecx, DWORD PTR _sub$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _sub$[ebp]
	mov	DWORD PTR [eax+4], edx

; 7277 :         tmp = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT,

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _sub$[ebp]
	push	eax
	push	5
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tmp$[ebp], eax

; 7278 : 				 sub, NULL, NULL, i, i);
; 7279 : 	if (tmp == NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN9@xmlExpDivi

; 7280 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlExpDivi
$LN9@xmlExpDivi:

; 7281 : 	}
; 7282 : 	if (!xmlExpCheckCard(tmp, exp)) {

	mov	edx, DWORD PTR _exp$[ebp]
	push	edx
	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_xmlExpCheckCard
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@xmlExpDivi

; 7283 : 	    xmlExpFree(ctxt, tmp);

	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpFree
	add	esp, 8

; 7284 : 	    continue;

	jmp	SHORT $LN2@xmlExpDivi
$LN10@xmlExpDivi:

; 7285 : 	}
; 7286 : 	tmp2 = xmlExpExpDeriveInt(ctxt, tmp, exp);

	mov	eax, DWORD PTR _exp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp2$[ebp], eax

; 7287 : 	if (tmp2 == NULL) {

	cmp	DWORD PTR _tmp2$[ebp], 0
	jne	SHORT $LN11@xmlExpDivi

; 7288 : 	    xmlExpFree(ctxt, tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8

; 7289 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlExpDivi
$LN11@xmlExpDivi:

; 7290 : 	}
; 7291 : 	if ((tmp2 != forbiddenExp) && (IS_NILLABLE(tmp2))) {

	mov	edx, DWORD PTR _tmp2$[ebp]
	cmp	edx, DWORD PTR _forbiddenExp
	je	SHORT $LN12@xmlExpDivi
	mov	eax, DWORD PTR _tmp2$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	and	ecx, 1
	je	SHORT $LN12@xmlExpDivi

; 7292 : 	    if (remain != NULL)

	cmp	DWORD PTR _remain$[ebp], 0
	je	SHORT $LN13@xmlExpDivi

; 7293 : 	        *remain = tmp2;

	mov	edx, DWORD PTR _remain$[ebp]
	mov	eax, DWORD PTR _tmp2$[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN14@xmlExpDivi
$LN13@xmlExpDivi:

; 7294 : 	    else
; 7295 : 	        xmlExpFree(ctxt, tmp2);

	mov	ecx, DWORD PTR _tmp2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpFree
	add	esp, 8
$LN14@xmlExpDivi:

; 7296 : 	    if (mult != NULL)

	cmp	DWORD PTR _mult$[ebp], 0
	je	SHORT $LN15@xmlExpDivi

; 7297 : 	        *mult = tmp;

	mov	eax, DWORD PTR _mult$[ebp]
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN16@xmlExpDivi
$LN15@xmlExpDivi:

; 7298 : 	    else
; 7299 : 	        xmlExpFree(ctxt, tmp);

	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8
$LN16@xmlExpDivi:

; 7300 : #ifdef DEBUG_DERIV
; 7301 : 	    printf("Divide succeeded %d\n", i);
; 7302 : #endif
; 7303 : 	    return(i);

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@xmlExpDivi
$LN12@xmlExpDivi:

; 7304 : 	}
; 7305 : 	xmlExpFree(ctxt, tmp);

	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpFree
	add	esp, 8

; 7306 : 	xmlExpFree(ctxt, tmp2);

	mov	eax, DWORD PTR _tmp2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8

; 7307 :     }

	jmp	$LN2@xmlExpDivi
$LN3@xmlExpDivi:

; 7308 : #ifdef DEBUG_DERIV
; 7309 :     printf("Divide failed\n");
; 7310 : #endif
; 7311 :     return(0);

	xor	eax, eax
$LN1@xmlExpDivi:

; 7312 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpDivide ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpExpDeriveInt
_TEXT	SEGMENT
tv156 = -64						; size = 4
_temp$1 = -60						; size = 4
_mult$2 = -56						; size = 4
_max$3 = -52						; size = 4
_min$4 = -48						; size = 4
_max$5 = -44						; size = 4
_min$6 = -40						; size = 4
_i$ = -36						; size = 4
_len$ = -32						; size = 4
_tab$ = -28						; size = 4
_tmp3$ = -24						; size = 4
_tmp2$ = -20						; size = 4
_tmp$ = -12						; size = 4
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_sub$ = 16						; size = 4
_xmlExpExpDeriveInt PROC				; COMDAT

; 7326 : xmlExpExpDeriveInt(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp, xmlExpNodePtr sub) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 7327 :     xmlExpNodePtr ret, tmp, tmp2, tmp3;
; 7328 :     const xmlChar **tab;
; 7329 :     int len, i;
; 7330 : 
; 7331 :     /*
; 7332 :      * In case of equality and if the expression can only consume a finite
; 7333 :      * amount, then the derivation is empty
; 7334 :      */
; 7335 :     if ((exp == sub) && (exp->c_max >= 0)) {

	mov	eax, DWORD PTR _exp$[ebp]
	cmp	eax, DWORD PTR _sub$[ebp]
	jne	SHORT $LN9@xmlExpExpD
	mov	ecx, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jl	SHORT $LN9@xmlExpExpD

; 7336 : #ifdef DEBUG_DERIV
; 7337 :         printf("Equal(exp, sub) and finite -> Empty\n");
; 7338 : #endif
; 7339 :         return(emptyExp);

	mov	eax, DWORD PTR _emptyExp
	jmp	$LN1@xmlExpExpD
$LN9@xmlExpExpD:

; 7340 :     }
; 7341 :     /*
; 7342 :      * decompose sub sequence first
; 7343 :      */
; 7344 :     if (sub->type == XML_EXP_EMPTY) {

	mov	edx, DWORD PTR _sub$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN10@xmlExpExpD

; 7345 : #ifdef DEBUG_DERIV
; 7346 :         printf("Empty(sub) -> Empty\n");
; 7347 : #endif
; 7348 : 	exp->ref++;

	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _exp$[ebp]
	mov	DWORD PTR [eax+4], edx

; 7349 :         return(exp);

	mov	eax, DWORD PTR _exp$[ebp]
	jmp	$LN1@xmlExpExpD
$LN10@xmlExpExpD:

; 7350 :     }
; 7351 :     if (sub->type == XML_EXP_SEQ) {

	mov	ecx, DWORD PTR _sub$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 3
	jne	SHORT $LN11@xmlExpExpD

; 7352 : #ifdef DEBUG_DERIV
; 7353 :         printf("Seq(sub) -> decompose\n");
; 7354 : #endif
; 7355 :         tmp = xmlExpExpDeriveInt(ctxt, exp, sub->exp_left);

	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _exp$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp$[ebp], eax

; 7356 : 	if (tmp == NULL)

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN12@xmlExpExpD

; 7357 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpExpD
$LN12@xmlExpExpD:

; 7358 : 	if (tmp == forbiddenExp)

	mov	ecx, DWORD PTR _tmp$[ebp]
	cmp	ecx, DWORD PTR _forbiddenExp
	jne	SHORT $LN13@xmlExpExpD

; 7359 : 	    return(tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	jmp	$LN1@xmlExpExpD
$LN13@xmlExpExpD:

; 7360 : 	ret = xmlExpExpDeriveInt(ctxt, tmp, sub->exp_right);

	mov	edx, DWORD PTR _sub$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 7361 : 	xmlExpFree(ctxt, tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8

; 7362 : 	return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlExpExpD
$LN11@xmlExpExpD:

; 7363 :     }
; 7364 :     if (sub->type == XML_EXP_OR) {

	mov	edx, DWORD PTR _sub$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 4
	jne	$LN14@xmlExpExpD

; 7365 : #ifdef DEBUG_DERIV
; 7366 :         printf("Or(sub) -> decompose\n");
; 7367 : #endif
; 7368 :         tmp = xmlExpExpDeriveInt(ctxt, exp, sub->exp_left);

	mov	ecx, DWORD PTR _sub$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _exp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp$[ebp], eax

; 7369 : 	if (tmp == forbiddenExp)

	mov	edx, DWORD PTR _tmp$[ebp]
	cmp	edx, DWORD PTR _forbiddenExp
	jne	SHORT $LN15@xmlExpExpD

; 7370 : 	    return(tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	jmp	$LN1@xmlExpExpD
$LN15@xmlExpExpD:

; 7371 : 	if (tmp == NULL)

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN16@xmlExpExpD

; 7372 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpExpD
$LN16@xmlExpExpD:

; 7373 : 	ret = xmlExpExpDeriveInt(ctxt, exp, sub->exp_right);

	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _exp$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 7374 : 	if ((ret == NULL) || (ret == forbiddenExp)) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN18@xmlExpExpD
	mov	ecx, DWORD PTR _ret$[ebp]
	cmp	ecx, DWORD PTR _forbiddenExp
	jne	SHORT $LN17@xmlExpExpD
$LN18@xmlExpExpD:

; 7375 : 	    xmlExpFree(ctxt, tmp);

	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8

; 7376 : 	    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlExpExpD
$LN17@xmlExpExpD:

; 7377 : 	}
; 7378 : 	return(xmlExpHashGetEntry(ctxt, XML_EXP_OR, tmp, ret, NULL, 0, 0));

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	jmp	$LN1@xmlExpExpD
$LN14@xmlExpExpD:

; 7379 :     }
; 7380 :     if (!xmlExpCheckCard(exp, sub)) {

	mov	ecx, DWORD PTR _sub$[ebp]
	push	ecx
	mov	edx, DWORD PTR _exp$[ebp]
	push	edx
	call	_xmlExpCheckCard
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@xmlExpExpD

; 7381 : #ifdef DEBUG_DERIV
; 7382 :         printf("CheckCard(exp, sub) failed -> Forbid\n");
; 7383 : #endif
; 7384 :         return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpExpD
$LN19@xmlExpExpD:

; 7385 :     }
; 7386 :     switch (exp->type) {

	mov	eax, DWORD PTR _exp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv156[ebp], ecx
	cmp	DWORD PTR tv156[ebp], 5
	ja	$LN2@xmlExpExpD
	mov	edx, DWORD PTR tv156[ebp]
	jmp	DWORD PTR $LN107@xmlExpExpD[edx*4]
$LN20@xmlExpExpD:

; 7387 :         case XML_EXP_EMPTY:
; 7388 : 	    if (sub == emptyExp)

	mov	eax, DWORD PTR _sub$[ebp]
	cmp	eax, DWORD PTR _emptyExp
	jne	SHORT $LN21@xmlExpExpD

; 7389 : 	        return(emptyExp);

	mov	eax, DWORD PTR _emptyExp
	jmp	$LN1@xmlExpExpD
$LN21@xmlExpExpD:

; 7390 : #ifdef DEBUG_DERIV
; 7391 : 	    printf("Empty(exp) -> Forbid\n");
; 7392 : #endif
; 7393 : 	    return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpExpD
$LN22@xmlExpExpD:

; 7394 :         case XML_EXP_FORBID:
; 7395 : #ifdef DEBUG_DERIV
; 7396 : 	    printf("Forbid(exp) -> Forbid\n");
; 7397 : #endif
; 7398 : 	    return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpExpD
$LN23@xmlExpExpD:

; 7399 :         case XML_EXP_ATOM:
; 7400 : 	    if (sub->type == XML_EXP_ATOM) {

	mov	ecx, DWORD PTR _sub$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 2
	jne	SHORT $LN24@xmlExpExpD

; 7401 : 	        /* TODO: handle wildcards */
; 7402 : 	        if (exp->exp_str == sub->exp_str) {

	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR _sub$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN25@xmlExpExpD

; 7403 : #ifdef DEBUG_DERIV
; 7404 : 		    printf("Atom match -> Empty\n");
; 7405 : #endif
; 7406 : 		    return(emptyExp);

	mov	eax, DWORD PTR _emptyExp
	jmp	$LN1@xmlExpExpD
$LN25@xmlExpExpD:

; 7407 :                 }
; 7408 : #ifdef DEBUG_DERIV
; 7409 : 		printf("Atom mismatch -> Forbid\n");
; 7410 : #endif
; 7411 : 	        return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpExpD
$LN24@xmlExpExpD:

; 7412 : 	    }
; 7413 : 	    if ((sub->type == XML_EXP_COUNT) &&
; 7414 : 	        (sub->exp_max == 1) &&

	mov	eax, DWORD PTR _sub$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 5
	jne	SHORT $LN26@xmlExpExpD
	mov	edx, DWORD PTR _sub$[ebp]
	cmp	DWORD PTR [edx+24], 1
	jne	SHORT $LN26@xmlExpExpD
	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 2
	jne	SHORT $LN26@xmlExpExpD

; 7415 : 	        (sub->exp_left->type == XML_EXP_ATOM)) {
; 7416 : 	        /* TODO: handle wildcards */
; 7417 : 	        if (exp->exp_str == sub->exp_left->exp_str) {

	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cmp	eax, DWORD PTR [ecx+20]
	jne	SHORT $LN27@xmlExpExpD

; 7418 : #ifdef DEBUG_DERIV
; 7419 : 		    printf("Atom match -> Empty\n");
; 7420 : #endif
; 7421 : 		    return(emptyExp);

	mov	eax, DWORD PTR _emptyExp
	jmp	$LN1@xmlExpExpD
$LN27@xmlExpExpD:

; 7422 : 		}
; 7423 : #ifdef DEBUG_DERIV
; 7424 : 		printf("Atom mismatch -> Forbid\n");
; 7425 : #endif
; 7426 : 	        return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpExpD
$LN26@xmlExpExpD:

; 7427 : 	    }
; 7428 : #ifdef DEBUG_DERIV
; 7429 : 	    printf("Compex exp vs Atom -> Forbid\n");
; 7430 : #endif
; 7431 : 	    return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpExpD
$LN28@xmlExpExpD:

; 7432 :         case XML_EXP_SEQ:
; 7433 : 	    /* try to get the sequence consumed only if possible */
; 7434 : 	    if (xmlExpCheckCard(exp->exp_left, sub)) {

	mov	ecx, DWORD PTR _sub$[ebp]
	push	ecx
	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlExpCheckCard
	add	esp, 8
	test	eax, eax
	je	SHORT $LN29@xmlExpExpD

; 7435 : 		/* See if the sequence can be consumed directly */
; 7436 : #ifdef DEBUG_DERIV
; 7437 : 		printf("Seq trying left only\n");
; 7438 : #endif
; 7439 : 		ret = xmlExpExpDeriveInt(ctxt, exp->exp_left, sub);

	mov	ecx, DWORD PTR _sub$[ebp]
	push	ecx
	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 7440 : 		if ((ret != forbiddenExp) && (ret != NULL)) {

	mov	edx, DWORD PTR _ret$[ebp]
	cmp	edx, DWORD PTR _forbiddenExp
	je	SHORT $LN29@xmlExpExpD
	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN29@xmlExpExpD

; 7441 : #ifdef DEBUG_DERIV
; 7442 : 		    printf("Seq trying left only worked\n");
; 7443 : #endif
; 7444 : 		    /*
; 7445 : 		     * TODO: assumption here that we are determinist
; 7446 : 		     *       i.e. we won't get to a nillable exp left
; 7447 : 		     *       subset which could be matched by the right
; 7448 : 		     *       part too.
; 7449 : 		     * e.g.: (a | b)+,(a | c) and 'a+,a'
; 7450 : 		     */
; 7451 : 		    exp->exp_right->ref++;

	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+4], edx

; 7452 : 		    return(xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, ret,

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	push	3
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	jmp	$LN1@xmlExpExpD
$LN29@xmlExpExpD:

; 7453 : 					      exp->exp_right, NULL, 0, 0));
; 7454 : 		}
; 7455 : #ifdef DEBUG_DERIV
; 7456 : 	    } else {
; 7457 : 		printf("Seq: left too short\n");
; 7458 : #endif
; 7459 : 	    }
; 7460 : 	    /* Try instead to decompose */
; 7461 : 	    if (sub->type == XML_EXP_COUNT) {

	mov	eax, DWORD PTR _sub$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 5
	jne	$LN31@xmlExpExpD

; 7462 : 		int min, max;
; 7463 : 
; 7464 : #ifdef DEBUG_DERIV
; 7465 : 		printf("Seq: sub is a count\n");
; 7466 : #endif
; 7467 : 	        ret = xmlExpExpDeriveInt(ctxt, exp->exp_left, sub->exp_left);

	mov	edx, DWORD PTR _sub$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 7468 : 		if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN32@xmlExpExpD

; 7469 : 		    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpExpD
$LN32@xmlExpExpD:

; 7470 : 		if (ret != forbiddenExp) {

	mov	ecx, DWORD PTR _ret$[ebp]
	cmp	ecx, DWORD PTR _forbiddenExp
	je	$LN31@xmlExpExpD

; 7471 : #ifdef DEBUG_DERIV
; 7472 : 		    printf("Seq , Count match on left\n");
; 7473 : #endif
; 7474 : 		    if (sub->exp_max < 0)

	mov	edx, DWORD PTR _sub$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jge	SHORT $LN34@xmlExpExpD

; 7475 : 		        max = -1;

	mov	DWORD PTR _max$5[ebp], -1
	jmp	SHORT $LN35@xmlExpExpD
$LN34@xmlExpExpD:

; 7476 : 	            else
; 7477 : 		        max = sub->exp_max -1;

	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, 1
	mov	DWORD PTR _max$5[ebp], ecx
$LN35@xmlExpExpD:

; 7478 : 		    if (sub->exp_min > 0)

	mov	edx, DWORD PTR _sub$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jle	SHORT $LN36@xmlExpExpD

; 7479 : 		        min = sub->exp_min -1;

	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, 1
	mov	DWORD PTR _min$6[ebp], ecx
	jmp	SHORT $LN37@xmlExpExpD
$LN36@xmlExpExpD:

; 7480 : 		    else
; 7481 : 		        min = 0;

	mov	DWORD PTR _min$6[ebp], 0
$LN37@xmlExpExpD:

; 7482 : 		    exp->exp_right->ref++;

	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+4], ecx

; 7483 : 		    tmp = xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, ret,

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tmp$[ebp], eax

; 7484 : 		                             exp->exp_right, NULL, 0, 0);
; 7485 : 		    if (tmp == NULL)

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN38@xmlExpExpD

; 7486 : 		        return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpExpD
$LN38@xmlExpExpD:

; 7487 : 
; 7488 : 		    sub->exp_left->ref++;

	mov	edx, DWORD PTR _sub$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _sub$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+4], ecx

; 7489 : 		    tmp2 = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT,

	mov	ecx, DWORD PTR _max$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _min$6[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	5
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tmp2$[ebp], eax

; 7490 : 				      sub->exp_left, NULL, NULL, min, max);
; 7491 : 		    if (tmp2 == NULL) {

	cmp	DWORD PTR _tmp2$[ebp], 0
	jne	SHORT $LN39@xmlExpExpD

; 7492 : 		        xmlExpFree(ctxt, tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8

; 7493 : 			return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpExpD
$LN39@xmlExpExpD:

; 7494 : 		    }
; 7495 : 		    ret = xmlExpExpDeriveInt(ctxt, tmp, tmp2);

	mov	edx, DWORD PTR _tmp2$[ebp]
	push	edx
	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 7496 : 		    xmlExpFree(ctxt, tmp);

	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8

; 7497 : 		    xmlExpFree(ctxt, tmp2);

	mov	ecx, DWORD PTR _tmp2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpFree
	add	esp, 8

; 7498 : 		    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlExpExpD
$LN31@xmlExpExpD:

; 7499 : 		}
; 7500 : 	    }
; 7501 : 	    /* we made no progress on structured operations */
; 7502 : 	    break;

	jmp	$LN2@xmlExpExpD
$LN40@xmlExpExpD:

; 7503 :         case XML_EXP_OR:
; 7504 : #ifdef DEBUG_DERIV
; 7505 : 	    printf("Or , trying both side\n");
; 7506 : #endif
; 7507 : 	    ret = xmlExpExpDeriveInt(ctxt, exp->exp_left, sub);

	mov	eax, DWORD PTR _sub$[ebp]
	push	eax
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 7508 : 	    if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN41@xmlExpExpD

; 7509 : 	        return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpExpD
$LN41@xmlExpExpD:

; 7510 : 	    tmp = xmlExpExpDeriveInt(ctxt, exp->exp_right, sub);

	mov	ecx, DWORD PTR _sub$[ebp]
	push	ecx
	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp$[ebp], eax

; 7511 : 	    if (tmp == NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN42@xmlExpExpD

; 7512 : 		xmlExpFree(ctxt, ret);

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8

; 7513 : 	        return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpExpD
$LN42@xmlExpExpD:

; 7514 : 	    }
; 7515 : 	    return(xmlExpHashGetEntry(ctxt, XML_EXP_OR, ret, tmp, NULL, 0, 0));

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	jmp	$LN1@xmlExpExpD
$LN43@xmlExpExpD:

; 7516 :         case XML_EXP_COUNT: {
; 7517 : 	    int min, max;
; 7518 : 
; 7519 : 	    if (sub->type == XML_EXP_COUNT) {

	mov	ecx, DWORD PTR _sub$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 5
	jne	$LN44@xmlExpExpD

; 7520 : 	        /*
; 7521 : 		 * Try to see if the loop is completely subsumed
; 7522 : 		 */
; 7523 : 	        tmp = xmlExpExpDeriveInt(ctxt, exp->exp_left, sub->exp_left);

	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp$[ebp], eax

; 7524 : 		if (tmp == NULL)

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN45@xmlExpExpD

; 7525 : 		    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpExpD
$LN45@xmlExpExpD:

; 7526 : 		if (tmp == forbiddenExp) {

	mov	edx, DWORD PTR _tmp$[ebp]
	cmp	edx, DWORD PTR _forbiddenExp
	jne	$LN46@xmlExpExpD

; 7527 : 		    int mult;
; 7528 : 
; 7529 : #ifdef DEBUG_DERIV
; 7530 : 		    printf("Count, Count inner don't subsume\n");
; 7531 : #endif
; 7532 : 		    mult = xmlExpDivide(ctxt, sub->exp_left, exp->exp_left,

	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpDivide
	add	esp, 20					; 00000014H
	mov	DWORD PTR _mult$2[ebp], eax

; 7533 : 		                        NULL, &tmp);
; 7534 : 		    if (mult <= 0) {

	cmp	DWORD PTR _mult$2[ebp], 0
	jg	SHORT $LN48@xmlExpExpD

; 7535 : #ifdef DEBUG_DERIV
; 7536 : 			printf("Count, Count not multiple => forbidden\n");
; 7537 : #endif
; 7538 :                         return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpExpD
$LN48@xmlExpExpD:

; 7539 : 		    }
; 7540 : 		    if (sub->exp_max == -1) {

	mov	eax, DWORD PTR _sub$[ebp]
	cmp	DWORD PTR [eax+24], -1
	jne	SHORT $LN49@xmlExpExpD

; 7541 : 		        max = -1;

	mov	DWORD PTR _max$3[ebp], -1

; 7542 : 			if (exp->exp_max == -1) {

	mov	ecx, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [ecx+24], -1
	jne	SHORT $LN51@xmlExpExpD

; 7543 : 			    if (exp->exp_min <= sub->exp_min * mult)

	mov	edx, DWORD PTR _sub$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, DWORD PTR _mult$2[ebp]
	mov	ecx, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	jg	SHORT $LN53@xmlExpExpD

; 7544 : 			        min = 0;

	mov	DWORD PTR _min$4[ebp], 0
	jmp	SHORT $LN54@xmlExpExpD
$LN53@xmlExpExpD:

; 7545 : 			    else
; 7546 : 			        min = exp->exp_min - sub->exp_min * mult;

	mov	edx, DWORD PTR _sub$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, DWORD PTR _mult$2[ebp]
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, eax
	mov	DWORD PTR _min$4[ebp], edx
$LN54@xmlExpExpD:

; 7547 : 			} else {

	jmp	SHORT $LN52@xmlExpExpD
$LN51@xmlExpExpD:

; 7548 : #ifdef DEBUG_DERIV
; 7549 : 			    printf("Count, Count finite can't subsume infinite\n");
; 7550 : #endif
; 7551 :                             xmlExpFree(ctxt, tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8

; 7552 : 			    return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpExpD
$LN52@xmlExpExpD:

; 7553 : 			}
; 7554 : 		    } else {

	jmp	$LN50@xmlExpExpD
$LN49@xmlExpExpD:

; 7555 : 			if (exp->exp_max == -1) {

	mov	edx, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [edx+24], -1
	jne	SHORT $LN55@xmlExpExpD

; 7556 : #ifdef DEBUG_DERIV
; 7557 : 			    printf("Infinite loop consume mult finite loop\n");
; 7558 : #endif
; 7559 : 			    if (exp->exp_min > sub->exp_min * mult) {

	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, DWORD PTR _mult$2[ebp]
	mov	edx, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [edx+20], ecx
	jle	SHORT $LN57@xmlExpExpD

; 7560 : 				max = -1;

	mov	DWORD PTR _max$3[ebp], -1

; 7561 : 				min = exp->exp_min - sub->exp_min * mult;

	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, DWORD PTR _mult$2[ebp]
	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, ecx
	mov	DWORD PTR _min$4[ebp], eax

; 7562 : 			    } else {

	jmp	SHORT $LN58@xmlExpExpD
$LN57@xmlExpExpD:

; 7563 : 				max = -1;

	mov	DWORD PTR _max$3[ebp], -1

; 7564 : 				min = 0;

	mov	DWORD PTR _min$4[ebp], 0
$LN58@xmlExpExpD:

; 7565 : 			    }
; 7566 : 			} else {

	jmp	SHORT $LN50@xmlExpExpD
$LN55@xmlExpExpD:

; 7567 : 			    if (exp->exp_max < sub->exp_max * mult) {

	mov	ecx, DWORD PTR _sub$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	imul	edx, DWORD PTR _mult$2[ebp]
	mov	eax, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [eax+24], edx
	jge	SHORT $LN59@xmlExpExpD

; 7568 : #ifdef DEBUG_DERIV
; 7569 : 				printf("loops max mult mismatch => forbidden\n");
; 7570 : #endif
; 7571 : 				xmlExpFree(ctxt, tmp);

	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpFree
	add	esp, 8

; 7572 : 				return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpExpD
$LN59@xmlExpExpD:

; 7573 : 			    }
; 7574 : 			    if (sub->exp_max * mult > exp->exp_min)

	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	imul	ecx, DWORD PTR _mult$2[ebp]
	mov	edx, DWORD PTR _exp$[ebp]
	cmp	ecx, DWORD PTR [edx+20]
	jle	SHORT $LN60@xmlExpExpD

; 7575 : 				min = 0;

	mov	DWORD PTR _min$4[ebp], 0
	jmp	SHORT $LN61@xmlExpExpD
$LN60@xmlExpExpD:

; 7576 : 			    else
; 7577 : 				min = exp->exp_min - sub->exp_max * mult;

	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	imul	ecx, DWORD PTR _mult$2[ebp]
	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, ecx
	mov	DWORD PTR _min$4[ebp], eax
$LN61@xmlExpExpD:

; 7578 : 			    max = exp->exp_max - sub->exp_max * mult;

	mov	ecx, DWORD PTR _sub$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	imul	edx, DWORD PTR _mult$2[ebp]
	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, edx
	mov	DWORD PTR _max$3[ebp], ecx
$LN50@xmlExpExpD:

; 7579 : 			}
; 7580 : 		    }

	jmp	$LN47@xmlExpExpD
$LN46@xmlExpExpD:

; 7581 : 		} else if (!IS_NILLABLE(tmp)) {

	mov	edx, DWORD PTR _tmp$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	and	eax, 1
	jne	SHORT $LN62@xmlExpExpD

; 7582 : 		    /*
; 7583 : 		     * TODO: loop here to try to grow if working on finite
; 7584 : 		     *       blocks.
; 7585 : 		     */
; 7586 : #ifdef DEBUG_DERIV
; 7587 : 		    printf("Count, Count remain not nillable => forbidden\n");
; 7588 : #endif
; 7589 : 		    xmlExpFree(ctxt, tmp);

	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpFree
	add	esp, 8

; 7590 : 		    return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpExpD
	jmp	$LN47@xmlExpExpD
$LN62@xmlExpExpD:

; 7591 : 		} else if (sub->exp_max == -1) {

	mov	eax, DWORD PTR _sub$[ebp]
	cmp	DWORD PTR [eax+24], -1
	jne	SHORT $LN64@xmlExpExpD

; 7592 : 		    if (exp->exp_max == -1) {

	mov	ecx, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [ecx+24], -1
	jne	SHORT $LN66@xmlExpExpD

; 7593 : 		        if (exp->exp_min <= sub->exp_min) {

	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+20]
	jg	SHORT $LN68@xmlExpExpD

; 7594 : #ifdef DEBUG_DERIV
; 7595 : 			    printf("Infinite loops Okay => COUNT(0,Inf)\n");
; 7596 : #endif
; 7597 :                             max = -1;

	mov	DWORD PTR _max$3[ebp], -1

; 7598 : 			    min = 0;

	mov	DWORD PTR _min$4[ebp], 0

; 7599 : 			} else {

	jmp	SHORT $LN69@xmlExpExpD
$LN68@xmlExpExpD:

; 7600 : #ifdef DEBUG_DERIV
; 7601 : 			    printf("Infinite loops min => Count(X,Inf)\n");
; 7602 : #endif
; 7603 :                             max = -1;

	mov	DWORD PTR _max$3[ebp], -1

; 7604 : 			    min = exp->exp_min - sub->exp_min;

	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _min$4[ebp], ecx
$LN69@xmlExpExpD:

; 7605 : 			}

	jmp	SHORT $LN67@xmlExpExpD
$LN66@xmlExpExpD:

; 7606 : 		    } else if (exp->exp_min > sub->exp_min) {

	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+20]
	jle	SHORT $LN70@xmlExpExpD

; 7607 : #ifdef DEBUG_DERIV
; 7608 : 			printf("loops min mismatch 1 => forbidden ???\n");
; 7609 : #endif
; 7610 : 		        xmlExpFree(ctxt, tmp);

	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8

; 7611 : 		        return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpExpD

; 7612 : 		    } else {

	jmp	SHORT $LN67@xmlExpExpD
$LN70@xmlExpExpD:

; 7613 : 			max = -1;

	mov	DWORD PTR _max$3[ebp], -1

; 7614 : 			min = 0;

	mov	DWORD PTR _min$4[ebp], 0
$LN67@xmlExpExpD:

; 7615 : 		    }
; 7616 : 		} else {

	jmp	$LN47@xmlExpExpD
$LN64@xmlExpExpD:

; 7617 : 		    if (exp->exp_max == -1) {

	mov	ecx, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [ecx+24], -1
	jne	SHORT $LN72@xmlExpExpD

; 7618 : #ifdef DEBUG_DERIV
; 7619 : 			printf("Infinite loop consume finite loop\n");
; 7620 : #endif
; 7621 : 		        if (exp->exp_min > sub->exp_min) {

	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+20]
	jle	SHORT $LN74@xmlExpExpD

; 7622 : 			    max = -1;

	mov	DWORD PTR _max$3[ebp], -1

; 7623 : 			    min = exp->exp_min - sub->exp_min;

	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _min$4[ebp], ecx

; 7624 : 			} else {

	jmp	SHORT $LN75@xmlExpExpD
$LN74@xmlExpExpD:

; 7625 : 			    max = -1;

	mov	DWORD PTR _max$3[ebp], -1

; 7626 : 			    min = 0;

	mov	DWORD PTR _min$4[ebp], 0
$LN75@xmlExpExpD:

; 7627 : 			}
; 7628 : 		    } else {

	jmp	SHORT $LN47@xmlExpExpD
$LN72@xmlExpExpD:

; 7629 : 		        if (exp->exp_max < sub->exp_max) {

	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [eax+24]
	jge	SHORT $LN76@xmlExpExpD

; 7630 : #ifdef DEBUG_DERIV
; 7631 : 			    printf("loops max mismatch => forbidden\n");
; 7632 : #endif
; 7633 : 			    xmlExpFree(ctxt, tmp);

	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8

; 7634 : 			    return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpExpD
$LN76@xmlExpExpD:

; 7635 : 			}
; 7636 : 			if (sub->exp_max > exp->exp_min)

	mov	ecx, DWORD PTR _sub$[ebp]
	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+20]
	jle	SHORT $LN77@xmlExpExpD

; 7637 : 			    min = 0;

	mov	DWORD PTR _min$4[ebp], 0
	jmp	SHORT $LN78@xmlExpExpD
$LN77@xmlExpExpD:

; 7638 : 			else
; 7639 : 			    min = exp->exp_min - sub->exp_max;

	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR _sub$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _min$4[ebp], eax
$LN78@xmlExpExpD:

; 7640 : 			max = exp->exp_max - sub->exp_max;

	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR _sub$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	sub	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _max$3[ebp], eax
$LN47@xmlExpExpD:

; 7641 : 		    }
; 7642 : 		}
; 7643 : #ifdef DEBUG_DERIV
; 7644 : 		printf("loops match => SEQ(COUNT())\n");
; 7645 : #endif
; 7646 : 		exp->exp_left->ref++;

	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+4], eax

; 7647 : 		tmp2 = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, exp->exp_left,

	mov	eax, DWORD PTR _max$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _min$4[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	push	5
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tmp2$[ebp], eax

; 7648 : 		                          NULL, NULL, min, max);
; 7649 : 		if (tmp2 == NULL) {

	cmp	DWORD PTR _tmp2$[ebp], 0
	jne	SHORT $LN79@xmlExpExpD

; 7650 : 		    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpExpD
$LN79@xmlExpExpD:

; 7651 : 		}
; 7652 :                 ret = xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, tmp, tmp2,

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _tmp2$[ebp]
	push	edx
	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret$[ebp], eax

; 7653 : 		                         NULL, 0, 0);
; 7654 : 		return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlExpExpD
$LN44@xmlExpExpD:

; 7655 : 	    }
; 7656 : 	    tmp = xmlExpExpDeriveInt(ctxt, exp->exp_left, sub);

	mov	edx, DWORD PTR _sub$[ebp]
	push	edx
	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp$[ebp], eax

; 7657 : 	    if (tmp == NULL)

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN80@xmlExpExpD

; 7658 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpExpD
$LN80@xmlExpExpD:

; 7659 : 	    if (tmp == forbiddenExp) {

	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	eax, DWORD PTR _forbiddenExp
	jne	SHORT $LN81@xmlExpExpD

; 7660 : #ifdef DEBUG_DERIV
; 7661 : 		printf("loop mismatch => forbidden\n");
; 7662 : #endif
; 7663 : 		return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpExpD
$LN81@xmlExpExpD:

; 7664 : 	    }
; 7665 : 	    if (exp->exp_min > 0)

	mov	ecx, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	jle	SHORT $LN82@xmlExpExpD

; 7666 : 		min = exp->exp_min - 1;

	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, 1
	mov	DWORD PTR _min$4[ebp], eax
	jmp	SHORT $LN83@xmlExpExpD
$LN82@xmlExpExpD:

; 7667 : 	    else
; 7668 : 		min = 0;

	mov	DWORD PTR _min$4[ebp], 0
$LN83@xmlExpExpD:

; 7669 : 	    if (exp->exp_max < 0)

	mov	ecx, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jge	SHORT $LN84@xmlExpExpD

; 7670 : 		max = -1;

	mov	DWORD PTR _max$3[ebp], -1
	jmp	SHORT $LN85@xmlExpExpD
$LN84@xmlExpExpD:

; 7671 : 	    else
; 7672 : 		max = exp->exp_max - 1;

	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+24]
	sub	eax, 1
	mov	DWORD PTR _max$3[ebp], eax
$LN85@xmlExpExpD:

; 7673 : 
; 7674 : #ifdef DEBUG_DERIV
; 7675 : 	    printf("loop match => SEQ(COUNT())\n");
; 7676 : #endif
; 7677 : 	    exp->exp_left->ref++;

	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+4], eax

; 7678 : 	    tmp2 = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, exp->exp_left,

	mov	eax, DWORD PTR _max$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _min$4[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	push	5
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tmp2$[ebp], eax

; 7679 : 				      NULL, NULL, min, max);
; 7680 : 	    if (tmp2 == NULL)

	cmp	DWORD PTR _tmp2$[ebp], 0
	jne	SHORT $LN86@xmlExpExpD

; 7681 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpExpD
$LN86@xmlExpExpD:

; 7682 : 	    ret = xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, tmp, tmp2,

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _tmp2$[ebp]
	push	edx
	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret$[ebp], eax

; 7683 : 				     NULL, 0, 0);
; 7684 : 	    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlExpExpD
$LN2@xmlExpExpD:

; 7685 : 	}
; 7686 :     }
; 7687 : 
; 7688 : #ifdef DEBUG_DERIV
; 7689 :     printf("Fallback to derivative\n");
; 7690 : #endif
; 7691 :     if (IS_NILLABLE(sub)) {

	mov	edx, DWORD PTR _sub$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	and	eax, 1
	je	SHORT $LN87@xmlExpExpD

; 7692 :         if (!(IS_NILLABLE(exp)))

	mov	ecx, DWORD PTR _exp$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	and	edx, 1
	jne	SHORT $LN89@xmlExpExpD

; 7693 : 	    return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpExpD
	jmp	SHORT $LN90@xmlExpExpD
$LN89@xmlExpExpD:

; 7694 : 	else
; 7695 : 	    ret = emptyExp;

	mov	eax, DWORD PTR _emptyExp
	mov	DWORD PTR _ret$[ebp], eax
$LN90@xmlExpExpD:

; 7696 :     } else

	jmp	SHORT $LN88@xmlExpExpD
$LN87@xmlExpExpD:

; 7697 : 	ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0
$LN88@xmlExpExpD:

; 7698 :     /*
; 7699 :      * here the structured derivation made no progress so
; 7700 :      * we use the default token based derivation to force one more step
; 7701 :      */
; 7702 :     if (ctxt->tabSize == 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	jne	SHORT $LN91@xmlExpExpD

; 7703 :         ctxt->tabSize = 40;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+36], 40			; 00000028H
$LN91@xmlExpExpD:

; 7704 : 
; 7705 :     tab = (const xmlChar **) xmlMalloc(ctxt->tabSize *

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tab$[ebp], eax

; 7706 : 	                               sizeof(const xmlChar *));
; 7707 :     if (tab == NULL) {

	cmp	DWORD PTR _tab$[ebp], 0
	jne	SHORT $LN92@xmlExpExpD

; 7708 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpExpD
$LN92@xmlExpExpD:

; 7709 :     }
; 7710 : 
; 7711 :     /*
; 7712 :      * collect all the strings accepted by the subexpression on input
; 7713 :      */
; 7714 :     len = xmlExpGetStartInt(ctxt, sub, tab, ctxt->tabSize, 0);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _tab$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sub$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpGetStartInt
	add	esp, 20					; 00000014H
	mov	DWORD PTR _len$[ebp], eax
$LN4@xmlExpExpD:

; 7715 :     while (len < 0) {

	cmp	DWORD PTR _len$[ebp], 0
	jge	$LN5@xmlExpExpD

; 7716 :         const xmlChar **temp;
; 7717 : 	temp = (const xmlChar **) xmlRealloc((xmlChar **) tab, ctxt->tabSize * 2 *

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	shl	edx, 1
	shl	edx, 2
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _tab$[ebp]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _temp$1[ebp], eax

; 7718 : 	                                     sizeof(const xmlChar *));
; 7719 : 	if (temp == NULL) {

	cmp	DWORD PTR _temp$1[ebp], 0
	jne	SHORT $LN93@xmlExpExpD

; 7720 : 	    xmlFree((xmlChar **) tab);

	mov	esi, esp
	mov	ecx, DWORD PTR _tab$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7721 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpExpD
$LN93@xmlExpExpD:

; 7722 : 	}
; 7723 : 	tab = temp;

	mov	edx, DWORD PTR _temp$1[ebp]
	mov	DWORD PTR _tab$[ebp], edx

; 7724 : 	ctxt->tabSize *= 2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shl	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 7725 : 	len = xmlExpGetStartInt(ctxt, sub, tab, ctxt->tabSize, 0);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _tab$[ebp]
	push	edx
	mov	eax, DWORD PTR _sub$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpGetStartInt
	add	esp, 20					; 00000014H
	mov	DWORD PTR _len$[ebp], eax

; 7726 :     }

	jmp	$LN4@xmlExpExpD
$LN5@xmlExpExpD:

; 7727 :     for (i = 0;i < len;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@xmlExpExpD
$LN6@xmlExpExpD:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN8@xmlExpExpD:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _len$[ebp]
	jge	$LN7@xmlExpExpD

; 7728 :         tmp = xmlExpStringDeriveInt(ctxt, exp, tab[i]);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _tab$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _exp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpStringDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp$[ebp], eax

; 7729 : 	if ((tmp == NULL) || (tmp == forbiddenExp)) {

	cmp	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN95@xmlExpExpD
	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	eax, DWORD PTR _forbiddenExp
	jne	SHORT $LN94@xmlExpExpD
$LN95@xmlExpExpD:

; 7730 : 	    xmlExpFree(ctxt, ret);

	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpFree
	add	esp, 8

; 7731 : 	    xmlFree((xmlChar **) tab);

	mov	esi, esp
	mov	eax, DWORD PTR _tab$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7732 : 	    return(tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	jmp	$LN1@xmlExpExpD
$LN94@xmlExpExpD:

; 7733 : 	}
; 7734 : 	tmp2 = xmlExpStringDeriveInt(ctxt, sub, tab[i]);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _tab$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _sub$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpStringDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp2$[ebp], eax

; 7735 : 	if ((tmp2 == NULL) || (tmp2 == forbiddenExp)) {

	cmp	DWORD PTR _tmp2$[ebp], 0
	je	SHORT $LN97@xmlExpExpD
	mov	eax, DWORD PTR _tmp2$[ebp]
	cmp	eax, DWORD PTR _forbiddenExp
	jne	SHORT $LN96@xmlExpExpD
$LN97@xmlExpExpD:

; 7736 : 	    xmlExpFree(ctxt, tmp);

	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpFree
	add	esp, 8

; 7737 : 	    xmlExpFree(ctxt, ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8

; 7738 : 	    xmlFree((xmlChar **) tab);

	mov	esi, esp
	mov	edx, DWORD PTR _tab$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7739 : 	    return(tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	jmp	$LN1@xmlExpExpD
$LN96@xmlExpExpD:

; 7740 : 	}
; 7741 : 	tmp3 = xmlExpExpDeriveInt(ctxt, tmp, tmp2);

	mov	eax, DWORD PTR _tmp2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp3$[ebp], eax

; 7742 : 	xmlExpFree(ctxt, tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8

; 7743 : 	xmlExpFree(ctxt, tmp2);

	mov	edx, DWORD PTR _tmp2$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8

; 7744 : 
; 7745 : 	if ((tmp3 == NULL) || (tmp3 == forbiddenExp)) {

	cmp	DWORD PTR _tmp3$[ebp], 0
	je	SHORT $LN99@xmlExpExpD
	mov	ecx, DWORD PTR _tmp3$[ebp]
	cmp	ecx, DWORD PTR _forbiddenExp
	jne	SHORT $LN98@xmlExpExpD
$LN99@xmlExpExpD:

; 7746 : 	    xmlExpFree(ctxt, ret);

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8

; 7747 : 	    xmlFree((xmlChar **) tab);

	mov	esi, esp
	mov	ecx, DWORD PTR _tab$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7748 : 	    return(tmp3);

	mov	eax, DWORD PTR _tmp3$[ebp]
	jmp	SHORT $LN1@xmlExpExpD
$LN98@xmlExpExpD:

; 7749 : 	}
; 7750 : 
; 7751 : 	if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN100@xmlExpExpD

; 7752 : 	    ret = tmp3;

	mov	edx, DWORD PTR _tmp3$[ebp]
	mov	DWORD PTR _ret$[ebp], edx
	jmp	SHORT $LN101@xmlExpExpD
$LN100@xmlExpExpD:

; 7753 : 	else {
; 7754 : 	    ret = xmlExpHashGetEntry(ctxt, XML_EXP_OR, ret, tmp3, NULL, 0, 0);

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _tmp3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	push	4
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret$[ebp], eax

; 7755 : 	    if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN101@xmlExpExpD

; 7756 : 		xmlFree((xmlChar **) tab);

	mov	esi, esp
	mov	eax, DWORD PTR _tab$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7757 : 	        return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpExpD
$LN101@xmlExpExpD:

; 7758 : 	    }
; 7759 : 	}
; 7760 :     }

	jmp	$LN6@xmlExpExpD
$LN7@xmlExpExpD:

; 7761 :     xmlFree((xmlChar **) tab);

	mov	esi, esp
	mov	ecx, DWORD PTR _tab$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7762 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlExpExpD:

; 7763 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN106@xmlExpExpD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN106@xmlExpExpD:
	DD	1
	DD	$LN105@xmlExpExpD
$LN105@xmlExpExpD:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN104@xmlExpExpD
$LN104@xmlExpExpD:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
$LN107@xmlExpExpD:
	DD	$LN20@xmlExpExpD
	DD	$LN22@xmlExpExpD
	DD	$LN23@xmlExpExpD
	DD	$LN28@xmlExpExpD
	DD	$LN40@xmlExpExpD
	DD	$LN43@xmlExpExpD
_xmlExpExpDeriveInt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpCheckCard
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_exp$ = 8						; size = 4
_sub$ = 12						; size = 4
_xmlExpCheckCard PROC					; COMDAT

; 7231 : xmlExpCheckCard(xmlExpNodePtr exp, xmlExpNodePtr sub) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 7232 :     int ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 7233 : 
; 7234 :     if (sub->c_max == -1) {

	mov	eax, DWORD PTR _sub$[ebp]
	cmp	DWORD PTR [eax+8], -1
	jne	SHORT $LN2@xmlExpChec

; 7235 :         if (exp->c_max != -1)

	mov	ecx, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [ecx+8], -1
	je	SHORT $LN4@xmlExpChec

; 7236 : 	    ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN4@xmlExpChec:

; 7237 :     } else if ((exp->c_max >= 0) && (exp->c_max < sub->c_max)) {

	jmp	SHORT $LN3@xmlExpChec
$LN2@xmlExpChec:
	mov	edx, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jl	SHORT $LN3@xmlExpChec
	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR _sub$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $LN3@xmlExpChec

; 7238 :         ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN3@xmlExpChec:

; 7239 :     }
; 7240 : #if 0
; 7241 :     if ((IS_NILLABLE(sub)) && (!IS_NILLABLE(exp)))
; 7242 :         ret = 0;
; 7243 : #endif
; 7244 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]

; 7245 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpCheckCard ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpStringDeriveInt
_TEXT	SEGMENT
tv66 = -24						; size = 4
_tmp$1 = -20						; size = 4
_max$2 = -16						; size = 4
_min$3 = -12						; size = 4
_tmp$4 = -8						; size = 4
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_str$ = 16						; size = 4
_xmlExpStringDeriveInt PROC				; COMDAT

; 7091 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 7092 :     xmlExpNodePtr ret;
; 7093 : 
; 7094 :     switch (exp->type) {

	mov	eax, DWORD PTR _exp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 5
	ja	$LN2@xmlExpStri
	mov	edx, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN29@xmlExpStri[edx*4]
$LN4@xmlExpStri:

; 7095 : 	case XML_EXP_EMPTY:
; 7096 : 	    return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpStri
$LN5@xmlExpStri:

; 7097 : 	case XML_EXP_FORBID:
; 7098 : 	    return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpStri
$LN6@xmlExpStri:

; 7099 : 	case XML_EXP_ATOM:
; 7100 : 	    if (exp->exp_str == str) {

	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR _str$[ebp]
	jne	SHORT $LN7@xmlExpStri

; 7101 : #ifdef DEBUG_DERIV
; 7102 : 		printf("deriv atom: equal => Empty\n");
; 7103 : #endif
; 7104 : 	        ret = emptyExp;

	mov	edx, DWORD PTR _emptyExp
	mov	DWORD PTR _ret$[ebp], edx

; 7105 : 	    } else {

	jmp	SHORT $LN8@xmlExpStri
$LN7@xmlExpStri:

; 7106 : #ifdef DEBUG_DERIV
; 7107 : 		printf("deriv atom: mismatch => forbid\n");
; 7108 : #endif
; 7109 : 	        /* TODO wildcards here */
; 7110 : 		ret = forbiddenExp;

	mov	eax, DWORD PTR _forbiddenExp
	mov	DWORD PTR _ret$[ebp], eax
$LN8@xmlExpStri:

; 7111 : 	    }
; 7112 : 	    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlExpStri
$LN9@xmlExpStri:

; 7113 : 	case XML_EXP_OR: {
; 7114 : 	    xmlExpNodePtr tmp;
; 7115 : 
; 7116 : #ifdef DEBUG_DERIV
; 7117 : 	    printf("deriv or: => or(derivs)\n");
; 7118 : #endif
; 7119 : 	    tmp = xmlExpStringDeriveInt(ctxt, exp->exp_left, str);

	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpStringDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp$4[ebp], eax

; 7120 : 	    if (tmp == NULL) {

	cmp	DWORD PTR _tmp$4[ebp], 0
	jne	SHORT $LN10@xmlExpStri

; 7121 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpStri
$LN10@xmlExpStri:

; 7122 : 	    }
; 7123 : 	    ret = xmlExpStringDeriveInt(ctxt, exp->exp_right, str);

	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpStringDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 7124 : 	    if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN11@xmlExpStri

; 7125 : 	        xmlExpFree(ctxt, tmp);

	mov	eax, DWORD PTR _tmp$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8

; 7126 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpStri
$LN11@xmlExpStri:

; 7127 : 	    }
; 7128 :             ret = xmlExpHashGetEntry(ctxt, XML_EXP_OR, tmp, ret,

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	mov	eax, DWORD PTR _tmp$4[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret$[ebp], eax

; 7129 : 			     NULL, 0, 0);
; 7130 : 	    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlExpStri
$LN12@xmlExpStri:

; 7131 : 	}
; 7132 : 	case XML_EXP_SEQ:
; 7133 : #ifdef DEBUG_DERIV
; 7134 : 	    printf("deriv seq: starting with left\n");
; 7135 : #endif
; 7136 : 	    ret = xmlExpStringDeriveInt(ctxt, exp->exp_left, str);

	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpStringDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 7137 : 	    if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN13@xmlExpStri

; 7138 : 	        return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpStri
	jmp	SHORT $LN14@xmlExpStri
$LN13@xmlExpStri:

; 7139 : 	    } else if (ret == forbiddenExp) {

	mov	eax, DWORD PTR _ret$[ebp]
	cmp	eax, DWORD PTR _forbiddenExp
	jne	SHORT $LN15@xmlExpStri

; 7140 : 	        if (IS_NILLABLE(exp->exp_left)) {

	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, BYTE PTR [edx+1]
	and	eax, 1
	je	SHORT $LN17@xmlExpStri

; 7141 : #ifdef DEBUG_DERIV
; 7142 : 		    printf("deriv seq: left failed but nillable\n");
; 7143 : #endif
; 7144 : 		    ret = xmlExpStringDeriveInt(ctxt, exp->exp_right, str);

	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpStringDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax
$LN17@xmlExpStri:

; 7145 : 		}
; 7146 : 	    } else {

	jmp	SHORT $LN14@xmlExpStri
$LN15@xmlExpStri:

; 7147 : #ifdef DEBUG_DERIV
; 7148 : 		printf("deriv seq: left match => sequence\n");
; 7149 : #endif
; 7150 : 	        exp->exp_right->ref++;

	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+4], ecx

; 7151 : 	        ret = xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, ret, exp->exp_right,

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret$[ebp], eax
$LN14@xmlExpStri:

; 7152 : 		                         NULL, 0, 0);
; 7153 : 	    }
; 7154 : 	    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlExpStri
$LN18@xmlExpStri:

; 7155 : 	case XML_EXP_COUNT: {
; 7156 : 	    int min, max;
; 7157 : 	    xmlExpNodePtr tmp;
; 7158 : 
; 7159 : 	    if (exp->exp_max == 0)

	mov	edx, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN19@xmlExpStri

; 7160 : 		return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpStri
$LN19@xmlExpStri:

; 7161 : 	    ret = xmlExpStringDeriveInt(ctxt, exp->exp_left, str);

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpStringDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 7162 : 	    if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN20@xmlExpStri

; 7163 : 	        return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpStri
$LN20@xmlExpStri:

; 7164 : 	    if (ret == forbiddenExp) {

	mov	ecx, DWORD PTR _ret$[ebp]
	cmp	ecx, DWORD PTR _forbiddenExp
	jne	SHORT $LN21@xmlExpStri

; 7165 : #ifdef DEBUG_DERIV
; 7166 : 		printf("deriv count: pattern mismatch => forbid\n");
; 7167 : #endif
; 7168 : 	        return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlExpStri
$LN21@xmlExpStri:

; 7169 : 	    }
; 7170 : 	    if (exp->exp_max == 1)

	mov	edx, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [edx+24], 1
	jne	SHORT $LN22@xmlExpStri

; 7171 : 		return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlExpStri
$LN22@xmlExpStri:

; 7172 : 	    if (exp->exp_max < 0) /* unbounded */

	mov	eax, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jge	SHORT $LN23@xmlExpStri

; 7173 : 		max = -1;

	mov	DWORD PTR _max$2[ebp], -1
	jmp	SHORT $LN24@xmlExpStri
$LN23@xmlExpStri:

; 7174 : 	    else
; 7175 : 		max = exp->exp_max - 1;

	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	sub	edx, 1
	mov	DWORD PTR _max$2[ebp], edx
$LN24@xmlExpStri:

; 7176 : 	    if (exp->exp_min > 0)

	mov	eax, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jle	SHORT $LN25@xmlExpStri

; 7177 : 		min = exp->exp_min - 1;

	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, 1
	mov	DWORD PTR _min$3[ebp], edx
	jmp	SHORT $LN26@xmlExpStri
$LN25@xmlExpStri:

; 7178 : 	    else
; 7179 : 		min = 0;

	mov	DWORD PTR _min$3[ebp], 0
$LN26@xmlExpStri:

; 7180 : 	    exp->exp_left->ref++;

	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+4], edx

; 7181 : 	    tmp = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, exp->exp_left, NULL,

	mov	edx, DWORD PTR _max$2[ebp]
	push	edx
	mov	eax, DWORD PTR _min$3[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	push	5
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tmp$1[ebp], eax

; 7182 : 				     NULL, min, max);
; 7183 : 	    if (ret == emptyExp) {

	mov	ecx, DWORD PTR _ret$[ebp]
	cmp	ecx, DWORD PTR _emptyExp
	jne	SHORT $LN27@xmlExpStri

; 7184 : #ifdef DEBUG_DERIV
; 7185 : 		printf("deriv count: match to empty => new count\n");
; 7186 : #endif
; 7187 : 	        return(tmp);

	mov	eax, DWORD PTR _tmp$1[ebp]
	jmp	SHORT $LN1@xmlExpStri
$LN27@xmlExpStri:

; 7188 : 	    }
; 7189 : #ifdef DEBUG_DERIV
; 7190 : 	    printf("deriv count: match => sequence with new count\n");
; 7191 : #endif
; 7192 : 	    return(xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, ret, tmp,

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _tmp$1[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN1@xmlExpStri
$LN2@xmlExpStri:

; 7193 : 	                              NULL, 0, 0));
; 7194 : 	}
; 7195 :     }
; 7196 :     return(NULL);

	xor	eax, eax
$LN1@xmlExpStri:

; 7197 : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN29@xmlExpStri:
	DD	$LN4@xmlExpStri
	DD	$LN5@xmlExpStri
	DD	$LN6@xmlExpStri
	DD	$LN12@xmlExpStri
	DD	$LN9@xmlExpStri
	DD	$LN18@xmlExpStri
_xmlExpStringDeriveInt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpGetStartInt
_TEXT	SEGMENT
tv66 = -12						; size = 4
_tmp2$ = -8						; size = 4
_tmp$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_list$ = 16						; size = 4
_len$ = 20						; size = 4
_nb$ = 24						; size = 4
_xmlExpGetStartInt PROC					; COMDAT

; 7008 :                   const xmlChar**list, int len, int nb) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
$tail$22:

; 7009 :     int tmp, tmp2;
; 7010 : tail:
; 7011 :     switch (exp->type) {

	mov	eax, DWORD PTR _exp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 5
	ja	$LN2@xmlExpGetS
	mov	edx, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN21@xmlExpGetS[edx*4]
$LN7@xmlExpGetS:

; 7012 :         case XML_EXP_FORBID:
; 7013 : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlExpGetS
$LN8@xmlExpGetS:

; 7014 :         case XML_EXP_EMPTY:
; 7015 : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlExpGetS
$LN9@xmlExpGetS:

; 7016 :         case XML_EXP_ATOM:
; 7017 : 	    for (tmp = 0;tmp < nb;tmp++)

	mov	DWORD PTR _tmp$[ebp], 0
	jmp	SHORT $LN6@xmlExpGetS
$LN4@xmlExpGetS:
	mov	eax, DWORD PTR _tmp$[ebp]
	add	eax, 1
	mov	DWORD PTR _tmp$[ebp], eax
$LN6@xmlExpGetS:
	mov	ecx, DWORD PTR _tmp$[ebp]
	cmp	ecx, DWORD PTR _nb$[ebp]
	jge	SHORT $LN5@xmlExpGetS

; 7018 : 	        if (list[tmp] == exp->exp_str)

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN10@xmlExpGetS

; 7019 : 		    return(0);

	xor	eax, eax
	jmp	$LN1@xmlExpGetS
$LN10@xmlExpGetS:
	jmp	SHORT $LN4@xmlExpGetS
$LN5@xmlExpGetS:

; 7020 :             if (nb >= len)

	mov	eax, DWORD PTR _nb$[ebp]
	cmp	eax, DWORD PTR _len$[ebp]
	jl	SHORT $LN11@xmlExpGetS

; 7021 : 	        return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlExpGetS
$LN11@xmlExpGetS:

; 7022 : 	    list[nb] = exp->exp_str;

	mov	ecx, DWORD PTR _nb$[ebp]
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+ecx*4], eax

; 7023 : 	    return(1);

	mov	eax, 1
	jmp	$LN1@xmlExpGetS
$LN12@xmlExpGetS:

; 7024 :         case XML_EXP_COUNT:
; 7025 : 	    exp = exp->exp_left;

	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _exp$[ebp], edx

; 7026 : 	    goto tail;

	jmp	$tail$22
$LN13@xmlExpGetS:

; 7027 :         case XML_EXP_SEQ:
; 7028 : 	    tmp = xmlExpGetStartInt(ctxt, exp->exp_left, list, len, nb);

	mov	eax, DWORD PTR _nb$[ebp]
	push	eax
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _list$[ebp]
	push	edx
	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpGetStartInt
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tmp$[ebp], eax

; 7029 : 	    if (tmp < 0)

	cmp	DWORD PTR _tmp$[ebp], 0
	jge	SHORT $LN14@xmlExpGetS

; 7030 : 	        return(tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	jmp	$LN1@xmlExpGetS
$LN14@xmlExpGetS:

; 7031 : 	    if (IS_NILLABLE(exp->exp_left)) {

	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movzx	edx, BYTE PTR [ecx+1]
	and	edx, 1
	je	SHORT $LN15@xmlExpGetS

; 7032 : 		tmp2 = xmlExpGetStartInt(ctxt, exp->exp_right, list, len,

	mov	eax, DWORD PTR _nb$[ebp]
	add	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _list$[ebp]
	push	edx
	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpGetStartInt
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tmp2$[ebp], eax

; 7033 : 					    nb + tmp);
; 7034 : 		if (tmp2 < 0)

	cmp	DWORD PTR _tmp2$[ebp], 0
	jge	SHORT $LN16@xmlExpGetS

; 7035 : 		    return(tmp2);

	mov	eax, DWORD PTR _tmp2$[ebp]
	jmp	SHORT $LN1@xmlExpGetS
$LN16@xmlExpGetS:

; 7036 : 		tmp += tmp2;

	mov	eax, DWORD PTR _tmp$[ebp]
	add	eax, DWORD PTR _tmp2$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax
$LN15@xmlExpGetS:

; 7037 : 	    }
; 7038 :             return(tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	jmp	SHORT $LN1@xmlExpGetS
$LN17@xmlExpGetS:

; 7039 :         case XML_EXP_OR:
; 7040 : 	    tmp = xmlExpGetStartInt(ctxt, exp->exp_left, list, len, nb);

	mov	ecx, DWORD PTR _nb$[ebp]
	push	ecx
	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpGetStartInt
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tmp$[ebp], eax

; 7041 : 	    if (tmp < 0)

	cmp	DWORD PTR _tmp$[ebp], 0
	jge	SHORT $LN18@xmlExpGetS

; 7042 : 	        return(tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	jmp	SHORT $LN1@xmlExpGetS
$LN18@xmlExpGetS:

; 7043 : 	    tmp2 = xmlExpGetStartInt(ctxt, exp->exp_right, list, len,

	mov	ecx, DWORD PTR _nb$[ebp]
	add	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpGetStartInt
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tmp2$[ebp], eax

; 7044 : 	                                nb + tmp);
; 7045 : 	    if (tmp2 < 0)

	cmp	DWORD PTR _tmp2$[ebp], 0
	jge	SHORT $LN19@xmlExpGetS

; 7046 : 	        return(tmp2);

	mov	eax, DWORD PTR _tmp2$[ebp]
	jmp	SHORT $LN1@xmlExpGetS
$LN19@xmlExpGetS:

; 7047 :             return(tmp + tmp2);

	mov	eax, DWORD PTR _tmp$[ebp]
	add	eax, DWORD PTR _tmp2$[ebp]
	jmp	SHORT $LN1@xmlExpGetS
$LN2@xmlExpGetS:

; 7048 :     }
; 7049 :     return(-1);

	or	eax, -1
$LN1@xmlExpGetS:

; 7050 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlExpGetS:
	DD	$LN8@xmlExpGetS
	DD	$LN7@xmlExpGetS
	DD	$LN9@xmlExpGetS
	DD	$LN13@xmlExpGetS
	DD	$LN17@xmlExpGetS
	DD	$LN12@xmlExpGetS
_xmlExpGetStartInt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpGetLanguageInt
_TEXT	SEGMENT
tv66 = -12						; size = 4
_tmp2$ = -8						; size = 4
_tmp$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_list$ = 16						; size = 4
_len$ = 20						; size = 4
_nb$ = 24						; size = 4
_xmlExpGetLanguageInt PROC				; COMDAT

; 6955 :                      const xmlChar**list, int len, int nb) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
$tail$17:

; 6956 :     int tmp, tmp2;
; 6957 : tail:
; 6958 :     switch (exp->type) {

	mov	eax, DWORD PTR _exp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 5
	ja	$LN2@xmlExpGetL
	mov	edx, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN16@xmlExpGetL[edx*4]
$LN7@xmlExpGetL:

; 6959 :         case XML_EXP_EMPTY:
; 6960 : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlExpGetL
$LN8@xmlExpGetL:

; 6961 :         case XML_EXP_ATOM:
; 6962 : 	    for (tmp = 0;tmp < nb;tmp++)

	mov	DWORD PTR _tmp$[ebp], 0
	jmp	SHORT $LN6@xmlExpGetL
$LN4@xmlExpGetL:
	mov	eax, DWORD PTR _tmp$[ebp]
	add	eax, 1
	mov	DWORD PTR _tmp$[ebp], eax
$LN6@xmlExpGetL:
	mov	ecx, DWORD PTR _tmp$[ebp]
	cmp	ecx, DWORD PTR _nb$[ebp]
	jge	SHORT $LN5@xmlExpGetL

; 6963 : 	        if (list[tmp] == exp->exp_str)

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN9@xmlExpGetL

; 6964 : 		    return(0);

	xor	eax, eax
	jmp	$LN1@xmlExpGetL
$LN9@xmlExpGetL:
	jmp	SHORT $LN4@xmlExpGetL
$LN5@xmlExpGetL:

; 6965 :             if (nb >= len)

	mov	eax, DWORD PTR _nb$[ebp]
	cmp	eax, DWORD PTR _len$[ebp]
	jl	SHORT $LN10@xmlExpGetL

; 6966 : 	        return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlExpGetL
$LN10@xmlExpGetL:

; 6967 : 	    list[nb] = exp->exp_str;

	mov	ecx, DWORD PTR _nb$[ebp]
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+ecx*4], eax

; 6968 : 	    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlExpGetL
$LN11@xmlExpGetL:

; 6969 :         case XML_EXP_COUNT:
; 6970 : 	    exp = exp->exp_left;

	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _exp$[ebp], edx

; 6971 : 	    goto tail;

	jmp	$tail$17
$LN12@xmlExpGetL:

; 6972 :         case XML_EXP_SEQ:
; 6973 :         case XML_EXP_OR:
; 6974 : 	    tmp = xmlExpGetLanguageInt(ctxt, exp->exp_left, list, len, nb);

	mov	eax, DWORD PTR _nb$[ebp]
	push	eax
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _list$[ebp]
	push	edx
	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpGetLanguageInt
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tmp$[ebp], eax

; 6975 : 	    if (tmp < 0)

	cmp	DWORD PTR _tmp$[ebp], 0
	jge	SHORT $LN13@xmlExpGetL

; 6976 : 	        return(tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	jmp	SHORT $LN1@xmlExpGetL
$LN13@xmlExpGetL:

; 6977 : 	    tmp2 = xmlExpGetLanguageInt(ctxt, exp->exp_right, list, len,

	mov	eax, DWORD PTR _nb$[ebp]
	add	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _list$[ebp]
	push	edx
	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpGetLanguageInt
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tmp2$[ebp], eax

; 6978 : 	                                nb + tmp);
; 6979 : 	    if (tmp2 < 0)

	cmp	DWORD PTR _tmp2$[ebp], 0
	jge	SHORT $LN14@xmlExpGetL

; 6980 : 	        return(tmp2);

	mov	eax, DWORD PTR _tmp2$[ebp]
	jmp	SHORT $LN1@xmlExpGetL
$LN14@xmlExpGetL:

; 6981 :             return(tmp + tmp2);

	mov	eax, DWORD PTR _tmp$[ebp]
	add	eax, DWORD PTR _tmp2$[ebp]
	jmp	SHORT $LN1@xmlExpGetL
$LN2@xmlExpGetL:

; 6982 :     }
; 6983 :     return(-1);

	or	eax, -1
$LN1@xmlExpGetL:

; 6984 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN16@xmlExpGetL:
	DD	$LN7@xmlExpGetL
	DD	$LN2@xmlExpGetL
	DD	$LN8@xmlExpGetL
	DD	$LN12@xmlExpGetL
	DD	$LN12@xmlExpGetL
	DD	$LN11@xmlExpGetL
_xmlExpGetLanguageInt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpHashGetEntry
_TEXT	SEGMENT
_tmp$1 = -36						; size = 4
_tmp$2 = -32						; size = 4
_tmp$3 = -28						; size = 4
_tmp$4 = -24						; size = 4
_tmp$5 = -20						; size = 4
_insert$ = -16						; size = 4
_entry$ = -12						; size = 4
_key$ = -8						; size = 2
_kbase$ = -4						; size = 2
_ctxt$ = 8						; size = 4
_type$ = 12						; size = 4
_left$ = 16						; size = 4
_right$ = 20						; size = 4
_name$ = 24						; size = 4
_min$ = 28						; size = 4
_max$ = 32						; size = 4
_xmlExpHashGetEntry PROC				; COMDAT

; 6571 : 		   const xmlChar *name, int min, int max) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6572 :     unsigned short kbase, key;
; 6573 :     xmlExpNodePtr entry;
; 6574 :     xmlExpNodePtr insert;
; 6575 : 
; 6576 :     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN5@xmlExpHash

; 6577 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpHash
$LN5@xmlExpHash:

; 6578 : 
; 6579 :     /*
; 6580 :      * Check for duplicate and insertion location.
; 6581 :      */
; 6582 :     if (type == XML_EXP_ATOM) {

	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN6@xmlExpHash

; 6583 : 	kbase = xmlExpHashNameComputeKey(name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlExpHashNameComputeKey
	add	esp, 4
	mov	WORD PTR _kbase$[ebp], ax
	jmp	$LN7@xmlExpHash
$LN6@xmlExpHash:

; 6584 :     } else if (type == XML_EXP_COUNT) {

	cmp	DWORD PTR _type$[ebp], 5
	jne	$LN8@xmlExpHash

; 6585 :         /* COUNT reduction rule 1 */
; 6586 : 	/* a{1} -> a */
; 6587 : 	if (min == max) {

	mov	ecx, DWORD PTR _min$[ebp]
	cmp	ecx, DWORD PTR _max$[ebp]
	jne	SHORT $LN10@xmlExpHash

; 6588 : 	    if (min == 1) {

	cmp	DWORD PTR _min$[ebp], 1
	jne	SHORT $LN11@xmlExpHash

; 6589 : 		return(left);

	mov	eax, DWORD PTR _left$[ebp]
	jmp	$LN1@xmlExpHash
$LN11@xmlExpHash:

; 6590 : 	    }
; 6591 : 	    if (min == 0) {

	cmp	DWORD PTR _min$[ebp], 0
	jne	SHORT $LN10@xmlExpHash

; 6592 : 		xmlExpFree(ctxt, left);

	mov	edx, DWORD PTR _left$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8

; 6593 : 	        return(emptyExp);

	mov	eax, DWORD PTR _emptyExp
	jmp	$LN1@xmlExpHash
$LN10@xmlExpHash:

; 6594 : 	    }
; 6595 : 	}
; 6596 : 	if (min < 0) {

	cmp	DWORD PTR _min$[ebp], 0
	jge	SHORT $LN13@xmlExpHash

; 6597 : 	    xmlExpFree(ctxt, left);

	mov	ecx, DWORD PTR _left$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpFree
	add	esp, 8

; 6598 : 	    return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	$LN1@xmlExpHash
$LN13@xmlExpHash:

; 6599 : 	}
; 6600 :         if (max == -1)

	cmp	DWORD PTR _max$[ebp], -1
	jne	SHORT $LN14@xmlExpHash

; 6601 : 	    kbase = min + 79;

	mov	eax, DWORD PTR _min$[ebp]
	add	eax, 79					; 0000004fH
	mov	WORD PTR _kbase$[ebp], ax
	jmp	SHORT $LN15@xmlExpHash
$LN14@xmlExpHash:

; 6602 : 	else
; 6603 : 	    kbase = max - min;

	mov	ecx, DWORD PTR _max$[ebp]
	sub	ecx, DWORD PTR _min$[ebp]
	mov	WORD PTR _kbase$[ebp], cx
$LN15@xmlExpHash:

; 6604 : 	kbase += left->key;

	mov	edx, DWORD PTR _left$[ebp]
	movzx	eax, WORD PTR [edx+2]
	movzx	ecx, WORD PTR _kbase$[ebp]
	add	ecx, eax
	mov	WORD PTR _kbase$[ebp], cx
	jmp	$LN7@xmlExpHash
$LN8@xmlExpHash:

; 6605 :     } else if (type == XML_EXP_OR) {

	cmp	DWORD PTR _type$[ebp], 4
	jne	$LN16@xmlExpHash

; 6606 :         /* Forbid reduction rules */
; 6607 :         if (left->type == XML_EXP_FORBID) {

	mov	edx, DWORD PTR _left$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 1
	jne	SHORT $LN18@xmlExpHash

; 6608 : 	    xmlExpFree(ctxt, left);

	mov	ecx, DWORD PTR _left$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpFree
	add	esp, 8

; 6609 : 	    return(right);

	mov	eax, DWORD PTR _right$[ebp]
	jmp	$LN1@xmlExpHash
$LN18@xmlExpHash:

; 6610 : 	}
; 6611 :         if (right->type == XML_EXP_FORBID) {

	mov	eax, DWORD PTR _right$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN19@xmlExpHash

; 6612 : 	    xmlExpFree(ctxt, right);

	mov	edx, DWORD PTR _right$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8

; 6613 : 	    return(left);

	mov	eax, DWORD PTR _left$[ebp]
	jmp	$LN1@xmlExpHash
$LN19@xmlExpHash:

; 6614 : 	}
; 6615 : 
; 6616 :         /* OR reduction rule 1 */
; 6617 : 	/* a | a reduced to a */
; 6618 :         if (left == right) {

	mov	ecx, DWORD PTR _left$[ebp]
	cmp	ecx, DWORD PTR _right$[ebp]
	jne	SHORT $LN20@xmlExpHash

; 6619 : 	    left->ref--;

	mov	edx, DWORD PTR _left$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 6620 : 	    return(left);

	mov	eax, DWORD PTR _left$[ebp]
	jmp	$LN1@xmlExpHash
$LN20@xmlExpHash:

; 6621 : 	}
; 6622 :         /* OR canonicalization rule 1 */
; 6623 : 	/* linearize (a | b) | c into a | (b | c) */
; 6624 :         if ((left->type == XML_EXP_OR) && (right->type != XML_EXP_OR)) {

	mov	edx, DWORD PTR _left$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 4
	jne	SHORT $LN21@xmlExpHash
	mov	ecx, DWORD PTR _right$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 4
	je	SHORT $LN21@xmlExpHash

; 6625 : 	    xmlExpNodePtr tmp = left;

	mov	eax, DWORD PTR _left$[ebp]
	mov	DWORD PTR _tmp$5[ebp], eax

; 6626 :             left = right;

	mov	ecx, DWORD PTR _right$[ebp]
	mov	DWORD PTR _left$[ebp], ecx

; 6627 : 	    right = tmp;

	mov	edx, DWORD PTR _tmp$5[ebp]
	mov	DWORD PTR _right$[ebp], edx
$LN21@xmlExpHash:

; 6628 : 	}
; 6629 :         /* OR reduction rule 2 */
; 6630 : 	/* a | (a | b) and b | (a | b) are reduced to a | b */
; 6631 :         if (right->type == XML_EXP_OR) {

	mov	eax, DWORD PTR _right$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 4
	jne	SHORT $LN22@xmlExpHash

; 6632 : 	    if ((left == right->exp_left) ||

	mov	edx, DWORD PTR _right$[ebp]
	mov	eax, DWORD PTR _left$[ebp]
	cmp	eax, DWORD PTR [edx+12]
	je	SHORT $LN24@xmlExpHash
	mov	ecx, DWORD PTR _right$[ebp]
	mov	edx, DWORD PTR _left$[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN22@xmlExpHash
$LN24@xmlExpHash:

; 6633 : 	        (left == right->exp_right)) {
; 6634 : 		xmlExpFree(ctxt, left);

	mov	eax, DWORD PTR _left$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8

; 6635 : 		return(right);

	mov	eax, DWORD PTR _right$[ebp]
	jmp	$LN1@xmlExpHash
$LN22@xmlExpHash:

; 6636 : 	    }
; 6637 : 	}
; 6638 :         /* OR canonicalization rule 2 */
; 6639 : 	/* linearize (a | b) | c into a | (b | c) */
; 6640 :         if (left->type == XML_EXP_OR) {

	mov	edx, DWORD PTR _left$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 4
	jne	$LN25@xmlExpHash

; 6641 : 	    xmlExpNodePtr tmp;
; 6642 : 
; 6643 : 	    /* OR canonicalization rule 2 */
; 6644 : 	    if ((left->exp_right->type != XML_EXP_OR) &&

	mov	ecx, DWORD PTR _left$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 4
	je	SHORT $LN26@xmlExpHash
	mov	ecx, DWORD PTR _left$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	movzx	eax, WORD PTR [edx+2]
	mov	ecx, DWORD PTR _left$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	ecx, WORD PTR [edx+2]
	cmp	eax, ecx
	jge	SHORT $LN26@xmlExpHash

; 6645 : 	        (left->exp_right->key < left->exp_left->key)) {
; 6646 : 	        tmp = left->exp_right;

	mov	edx, DWORD PTR _left$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _tmp$4[ebp], eax

; 6647 : 		left->exp_right = left->exp_left;

	mov	ecx, DWORD PTR _left$[ebp]
	mov	edx, DWORD PTR _left$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+20], eax

; 6648 : 		left->exp_left = tmp;

	mov	ecx, DWORD PTR _left$[ebp]
	mov	edx, DWORD PTR _tmp$4[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN26@xmlExpHash:

; 6649 : 	    }
; 6650 : 	    left->exp_right->ref++;

	mov	eax, DWORD PTR _left$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _left$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+4], edx

; 6651 : 	    tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left->exp_right, right,

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _right$[ebp]
	push	edx
	mov	eax, DWORD PTR _left$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	4
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tmp$4[ebp], eax

; 6652 : 	                             NULL, 0, 0);
; 6653 : 	    left->exp_left->ref++;

	mov	eax, DWORD PTR _left$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _left$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+4], edx

; 6654 : 	    tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left->exp_left, tmp,

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _tmp$4[ebp]
	push	edx
	mov	eax, DWORD PTR _left$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	4
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tmp$4[ebp], eax

; 6655 : 	                             NULL, 0, 0);
; 6656 : 
; 6657 : 	    xmlExpFree(ctxt, left);

	mov	eax, DWORD PTR _left$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8

; 6658 : 	    return(tmp);

	mov	eax, DWORD PTR _tmp$4[ebp]
	jmp	$LN1@xmlExpHash
$LN25@xmlExpHash:

; 6659 : 	}
; 6660 : 	if (right->type == XML_EXP_OR) {

	mov	edx, DWORD PTR _right$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 4
	jne	$LN27@xmlExpHash

; 6661 : 	    /* Ordering in the tree */
; 6662 : 	    /* C | (A | B) -> A | (B | C) */
; 6663 : 	    if (left->key > right->exp_right->key) {

	mov	ecx, DWORD PTR _left$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	mov	eax, DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	movzx	eax, WORD PTR [ecx+2]
	cmp	edx, eax
	jle	$LN29@xmlExpHash

; 6664 : 		xmlExpNodePtr tmp;
; 6665 : 		right->exp_right->ref++;

	mov	ecx, DWORD PTR _right$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _right$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+4], eax

; 6666 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_right,

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _left$[ebp]
	push	eax
	mov	ecx, DWORD PTR _right$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	push	4
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tmp$3[ebp], eax

; 6667 : 		                         left, NULL, 0, 0);
; 6668 : 		right->exp_left->ref++;

	mov	ecx, DWORD PTR _right$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _right$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+4], eax

; 6669 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_left,

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _tmp$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _right$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	push	4
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tmp$3[ebp], eax

; 6670 : 		                         tmp, NULL, 0, 0);
; 6671 : 		xmlExpFree(ctxt, right);

	mov	ecx, DWORD PTR _right$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpFree
	add	esp, 8

; 6672 : 		return(tmp);

	mov	eax, DWORD PTR _tmp$3[ebp]
	jmp	$LN1@xmlExpHash
$LN29@xmlExpHash:

; 6673 : 	    }
; 6674 : 	    /* Ordering in the tree */
; 6675 : 	    /* B | (A | C) -> A | (B | C) */
; 6676 : 	    if (left->key > right->exp_left->key) {

	mov	eax, DWORD PTR _left$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR _right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	edx, WORD PTR [eax+2]
	cmp	ecx, edx
	jle	$LN30@xmlExpHash

; 6677 : 		xmlExpNodePtr tmp;
; 6678 : 		right->exp_right->ref++;

	mov	eax, DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+4], edx

; 6679 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left,

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _right$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _left$[ebp]
	push	ecx
	push	4
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tmp$2[ebp], eax

; 6680 : 		                         right->exp_right, NULL, 0, 0);
; 6681 : 		right->exp_left->ref++;

	mov	eax, DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+4], edx

; 6682 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_left,

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _tmp$2[ebp]
	push	edx
	mov	eax, DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	4
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tmp$2[ebp], eax

; 6683 : 		                         tmp, NULL, 0, 0);
; 6684 : 		xmlExpFree(ctxt, right);

	mov	eax, DWORD PTR _right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8

; 6685 : 		return(tmp);

	mov	eax, DWORD PTR _tmp$2[ebp]
	jmp	$LN1@xmlExpHash
$LN30@xmlExpHash:

; 6686 : 	    }
; 6687 : 	}

	jmp	SHORT $LN28@xmlExpHash
$LN27@xmlExpHash:

; 6688 : 	/* we know both types are != XML_EXP_OR here */
; 6689 :         else if (left->key > right->key) {

	mov	edx, DWORD PTR _left$[ebp]
	movzx	eax, WORD PTR [edx+2]
	mov	ecx, DWORD PTR _right$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	cmp	eax, edx
	jle	SHORT $LN28@xmlExpHash

; 6690 : 	    xmlExpNodePtr tmp = left;

	mov	eax, DWORD PTR _left$[ebp]
	mov	DWORD PTR _tmp$1[ebp], eax

; 6691 :             left = right;

	mov	ecx, DWORD PTR _right$[ebp]
	mov	DWORD PTR _left$[ebp], ecx

; 6692 : 	    right = tmp;

	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR _right$[ebp], edx
$LN28@xmlExpHash:

; 6693 : 	}
; 6694 : 	kbase = xmlExpHashComputeKey(type, left, right);

	mov	eax, DWORD PTR _right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _left$[ebp]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	call	_xmlExpHashComputeKey
	add	esp, 12					; 0000000cH
	mov	WORD PTR _kbase$[ebp], ax
	jmp	$LN7@xmlExpHash
$LN16@xmlExpHash:

; 6695 :     } else if (type == XML_EXP_SEQ) {

	cmp	DWORD PTR _type$[ebp], 3
	jne	$LN32@xmlExpHash

; 6696 :         /* Forbid reduction rules */
; 6697 :         if (left->type == XML_EXP_FORBID) {

	mov	eax, DWORD PTR _left$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN34@xmlExpHash

; 6698 : 	    xmlExpFree(ctxt, right);

	mov	edx, DWORD PTR _right$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8

; 6699 : 	    return(left);

	mov	eax, DWORD PTR _left$[ebp]
	jmp	$LN1@xmlExpHash
$LN34@xmlExpHash:

; 6700 : 	}
; 6701 :         if (right->type == XML_EXP_FORBID) {

	mov	ecx, DWORD PTR _right$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 1
	jne	SHORT $LN35@xmlExpHash

; 6702 : 	    xmlExpFree(ctxt, left);

	mov	eax, DWORD PTR _left$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8

; 6703 : 	    return(right);

	mov	eax, DWORD PTR _right$[ebp]
	jmp	$LN1@xmlExpHash
$LN35@xmlExpHash:

; 6704 : 	}
; 6705 :         /* Empty reduction rules */
; 6706 :         if (right->type == XML_EXP_EMPTY) {

	mov	edx, DWORD PTR _right$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN36@xmlExpHash

; 6707 : 	    return(left);

	mov	eax, DWORD PTR _left$[ebp]
	jmp	$LN1@xmlExpHash
$LN36@xmlExpHash:

; 6708 : 	}
; 6709 :         if (left->type == XML_EXP_EMPTY) {

	mov	ecx, DWORD PTR _left$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN37@xmlExpHash

; 6710 : 	    return(right);

	mov	eax, DWORD PTR _right$[ebp]
	jmp	$LN1@xmlExpHash
$LN37@xmlExpHash:

; 6711 : 	}
; 6712 : 	kbase = xmlExpHashComputeKey(type, left, right);

	mov	eax, DWORD PTR _right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _left$[ebp]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	call	_xmlExpHashComputeKey
	add	esp, 12					; 0000000cH
	mov	WORD PTR _kbase$[ebp], ax

; 6713 :     } else

	jmp	SHORT $LN7@xmlExpHash
$LN32@xmlExpHash:

; 6714 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpHash
$LN7@xmlExpHash:

; 6715 : 
; 6716 :     key = kbase % ctxt->size;

	movzx	eax, WORD PTR _kbase$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cdq
	idiv	DWORD PTR [ecx+8]
	mov	WORD PTR _key$[ebp], dx

; 6717 :     if (ctxt->table[key] != NULL) {

	movzx	edx, WORD PTR _key$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	$LN38@xmlExpHash

; 6718 : 	for (insert = ctxt->table[key]; insert != NULL;

	movzx	edx, WORD PTR _key$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _insert$[ebp], edx
	jmp	SHORT $LN4@xmlExpHash
$LN2@xmlExpHash:

; 6719 : 	     insert = insert->next) {

	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _insert$[ebp], ecx
$LN4@xmlExpHash:

; 6718 : 	for (insert = ctxt->table[key]; insert != NULL;

	cmp	DWORD PTR _insert$[ebp], 0
	je	$LN38@xmlExpHash

; 6720 : 	    if ((insert->key == kbase) &&

	mov	edx, DWORD PTR _insert$[ebp]
	movzx	eax, WORD PTR [edx+2]
	movzx	ecx, WORD PTR _kbase$[ebp]
	cmp	eax, ecx
	jne	$LN39@xmlExpHash
	mov	edx, DWORD PTR _insert$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, DWORD PTR _type$[ebp]
	jne	$LN39@xmlExpHash

; 6721 : 	        (insert->type == type)) {
; 6722 : 		if (type == XML_EXP_ATOM) {

	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN40@xmlExpHash

; 6723 : 		    if (name == insert->exp_str) {

	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR _name$[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN42@xmlExpHash

; 6724 : 			insert->ref++;

	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _insert$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 6725 : 			return(insert);

	mov	eax, DWORD PTR _insert$[ebp]
	jmp	$LN1@xmlExpHash
$LN42@xmlExpHash:

; 6726 : 		    }

	jmp	$LN39@xmlExpHash
$LN40@xmlExpHash:

; 6727 : 		} else if (type == XML_EXP_COUNT) {

	cmp	DWORD PTR _type$[ebp], 5
	jne	SHORT $LN43@xmlExpHash

; 6728 : 		    if ((insert->exp_min == min) && (insert->exp_max == max) &&

	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR _min$[ebp]
	jne	SHORT $LN45@xmlExpHash
	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	eax, DWORD PTR _max$[ebp]
	jne	SHORT $LN45@xmlExpHash
	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _left$[ebp]
	jne	SHORT $LN45@xmlExpHash

; 6729 : 		        (insert->exp_left == left)) {
; 6730 : 			insert->ref++;

	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _insert$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 6731 : 			left->ref--;

	mov	eax, DWORD PTR _left$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 6732 : 			return(insert);

	mov	eax, DWORD PTR _insert$[ebp]
	jmp	$LN1@xmlExpHash
$LN45@xmlExpHash:

; 6733 : 		    }

	jmp	SHORT $LN39@xmlExpHash
$LN43@xmlExpHash:

; 6734 : 		} else if ((insert->exp_left == left) &&

	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _left$[ebp]
	jne	SHORT $LN39@xmlExpHash
	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cmp	eax, DWORD PTR _right$[ebp]
	jne	SHORT $LN39@xmlExpHash

; 6735 : 			   (insert->exp_right == right)) {
; 6736 : 		    insert->ref++;

	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _insert$[ebp]
	mov	DWORD PTR [eax+4], edx

; 6737 : 		    left->ref--;

	mov	ecx, DWORD PTR _left$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _left$[ebp]
	mov	DWORD PTR [eax+4], edx

; 6738 : 		    right->ref--;

	mov	ecx, DWORD PTR _right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _right$[ebp]
	mov	DWORD PTR [eax+4], edx

; 6739 : 		    return(insert);

	mov	eax, DWORD PTR _insert$[ebp]
	jmp	$LN1@xmlExpHash
$LN39@xmlExpHash:

; 6740 : 		}
; 6741 : 	    }
; 6742 : 	}

	jmp	$LN2@xmlExpHash
$LN38@xmlExpHash:

; 6743 :     }
; 6744 : 
; 6745 :     entry = xmlExpNewNode(ctxt, type);

	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpNewNode
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 6746 :     if (entry == NULL)

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN47@xmlExpHash

; 6747 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpHash
$LN47@xmlExpHash:

; 6748 :     entry->key = kbase;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	cx, WORD PTR _kbase$[ebp]
	mov	WORD PTR [eax+2], cx

; 6749 :     if (type == XML_EXP_ATOM) {

	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN48@xmlExpHash

; 6750 : 	entry->exp_str = name;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR [edx+20], eax

; 6751 : 	entry->c_max = 1;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+8], 1
	jmp	$LN49@xmlExpHash
$LN48@xmlExpHash:

; 6752 :     } else if (type == XML_EXP_COUNT) {

	cmp	DWORD PTR _type$[ebp], 5
	jne	SHORT $LN50@xmlExpHash

; 6753 :         entry->exp_min = min;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _min$[ebp]
	mov	DWORD PTR [edx+20], eax

; 6754 :         entry->exp_max = max;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 6755 : 	entry->exp_left = left;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 6756 : 	if ((min == 0) || (IS_NILLABLE(left)))

	cmp	DWORD PTR _min$[ebp], 0
	je	SHORT $LN53@xmlExpHash
	mov	edx, DWORD PTR _left$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	and	eax, 1
	je	SHORT $LN52@xmlExpHash
$LN53@xmlExpHash:

; 6757 : 	    entry->info |= XML_EXP_NILABLE;

	mov	ecx, DWORD PTR _entry$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	or	edx, 1
	mov	eax, DWORD PTR _entry$[ebp]
	mov	BYTE PTR [eax+1], dl
$LN52@xmlExpHash:

; 6758 : 	if (max < 0)

	cmp	DWORD PTR _max$[ebp], 0
	jge	SHORT $LN54@xmlExpHash

; 6759 : 	    entry->c_max = -1;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+8], -1
	jmp	SHORT $LN55@xmlExpHash
$LN54@xmlExpHash:

; 6760 : 	else
; 6761 : 	    entry->c_max = max * entry->exp_left->c_max;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _max$[ebp]
	imul	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN55@xmlExpHash:

; 6762 :     } else {

	jmp	$LN49@xmlExpHash
$LN50@xmlExpHash:

; 6763 : 	entry->exp_left = left;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 6764 : 	entry->exp_right = right;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _right$[ebp]
	mov	DWORD PTR [edx+20], eax

; 6765 : 	if (type == XML_EXP_OR) {

	cmp	DWORD PTR _type$[ebp], 4
	jne	$LN56@xmlExpHash

; 6766 : 	    if ((IS_NILLABLE(left)) || (IS_NILLABLE(right)))

	mov	ecx, DWORD PTR _left$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	and	edx, 1
	jne	SHORT $LN59@xmlExpHash
	mov	eax, DWORD PTR _right$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	and	ecx, 1
	je	SHORT $LN58@xmlExpHash
$LN59@xmlExpHash:

; 6767 : 		entry->info |= XML_EXP_NILABLE;

	mov	edx, DWORD PTR _entry$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	or	eax, 1
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	BYTE PTR [ecx+1], al
$LN58@xmlExpHash:

; 6768 : 	    if ((entry->exp_left->c_max == -1) ||

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	DWORD PTR [eax+8], -1
	je	SHORT $LN62@xmlExpHash
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	DWORD PTR [edx+8], -1
	jne	SHORT $LN60@xmlExpHash
$LN62@xmlExpHash:

; 6769 : 	        (entry->exp_right->c_max == -1))
; 6770 : 		entry->c_max = -1;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+8], -1
	jmp	SHORT $LN61@xmlExpHash
$LN60@xmlExpHash:

; 6771 : 	    else if (entry->exp_left->c_max > entry->exp_right->c_max)

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [edx+8]
	cmp	edx, DWORD PTR [ecx+8]
	jle	SHORT $LN63@xmlExpHash

; 6772 : 	        entry->c_max = entry->exp_left->c_max;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN61@xmlExpHash
$LN63@xmlExpHash:

; 6773 : 	    else
; 6774 : 	        entry->c_max = entry->exp_right->c_max;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
$LN61@xmlExpHash:

; 6775 : 	} else {

	jmp	SHORT $LN49@xmlExpHash
$LN56@xmlExpHash:

; 6776 : 	    if ((IS_NILLABLE(left)) && (IS_NILLABLE(right)))

	mov	edx, DWORD PTR _left$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	and	eax, 1
	je	SHORT $LN65@xmlExpHash
	mov	ecx, DWORD PTR _right$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	and	edx, 1
	je	SHORT $LN65@xmlExpHash

; 6777 : 		entry->info |= XML_EXP_NILABLE;

	mov	eax, DWORD PTR _entry$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	or	ecx, 1
	mov	edx, DWORD PTR _entry$[ebp]
	mov	BYTE PTR [edx+1], cl
$LN65@xmlExpHash:

; 6778 : 	    if ((entry->exp_left->c_max == -1) ||

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	DWORD PTR [ecx+8], -1
	je	SHORT $LN68@xmlExpHash
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cmp	DWORD PTR [eax+8], -1
	jne	SHORT $LN66@xmlExpHash
$LN68@xmlExpHash:

; 6779 : 	        (entry->exp_right->c_max == -1))
; 6780 : 		entry->c_max = -1;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+8], -1
	jmp	SHORT $LN49@xmlExpHash
$LN66@xmlExpHash:

; 6781 : 	    else
; 6782 : 	        entry->c_max = entry->exp_left->c_max + entry->exp_right->c_max;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [eax+8]
	add	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN49@xmlExpHash:

; 6783 : 	}
; 6784 :     }
; 6785 :     entry->ref = 1;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+4], 1

; 6786 :     if (ctxt->table[key] != NULL)

	movzx	eax, WORD PTR _key$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN69@xmlExpHash

; 6787 :         entry->next = ctxt->table[key];

	movzx	eax, WORD PTR _key$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx+16], edx
$LN69@xmlExpHash:

; 6788 : 
; 6789 :     ctxt->table[key] = entry;

	movzx	eax, WORD PTR _key$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 6790 :     ctxt->nbElems++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 6791 : 
; 6792 :     return(entry);

	mov	eax, DWORD PTR _entry$[ebp]
$LN1@xmlExpHash:

; 6793 : }

	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpHashGetEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpHashComputeKey
_TEXT	SEGMENT
tv64 = -12						; size = 4
_ret$ = -8						; size = 2
_value$ = -4						; size = 4
_type$ = 8						; size = 4
_left$ = 12						; size = 4
_right$ = 16						; size = 4
_xmlExpHashComputeKey PROC				; COMDAT

; 6512 :                      xmlExpNodePtr right) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6513 :     unsigned long value;
; 6514 :     unsigned short ret;
; 6515 : 
; 6516 :     switch (type) {

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 3
	je	SHORT $LN4@xmlExpHash
	cmp	DWORD PTR tv64[ebp], 4
	je	SHORT $LN5@xmlExpHash
	cmp	DWORD PTR tv64[ebp], 5
	je	SHORT $LN6@xmlExpHash
	jmp	SHORT $LN7@xmlExpHash
$LN4@xmlExpHash:

; 6517 :         case XML_EXP_SEQ:
; 6518 : 	    value = left->key;

	mov	ecx, DWORD PTR _left$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR _value$[ebp], edx

; 6519 : 	    value += right->key;

	mov	eax, DWORD PTR _right$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	add	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx

; 6520 : 	    value *= 3;

	imul	edx, DWORD PTR _value$[ebp], 3
	mov	DWORD PTR _value$[ebp], edx

; 6521 : 	    ret = (unsigned short) value;

	mov	ax, WORD PTR _value$[ebp]
	mov	WORD PTR _ret$[ebp], ax

; 6522 : 	    break;

	jmp	SHORT $LN2@xmlExpHash
$LN5@xmlExpHash:

; 6523 :         case XML_EXP_OR:
; 6524 : 	    value = left->key;

	mov	ecx, DWORD PTR _left$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR _value$[ebp], edx

; 6525 : 	    value += right->key;

	mov	eax, DWORD PTR _right$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	add	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx

; 6526 : 	    value *= 7;

	imul	edx, DWORD PTR _value$[ebp], 7
	mov	DWORD PTR _value$[ebp], edx

; 6527 : 	    ret = (unsigned short) value;

	mov	ax, WORD PTR _value$[ebp]
	mov	WORD PTR _ret$[ebp], ax

; 6528 : 	    break;

	jmp	SHORT $LN2@xmlExpHash
$LN6@xmlExpHash:

; 6529 :         case XML_EXP_COUNT:
; 6530 : 	    value = left->key;

	mov	ecx, DWORD PTR _left$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR _value$[ebp], edx

; 6531 : 	    value += right->key;

	mov	eax, DWORD PTR _right$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	add	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx

; 6532 : 	    ret = (unsigned short) value;

	mov	dx, WORD PTR _value$[ebp]
	mov	WORD PTR _ret$[ebp], dx

; 6533 : 	    break;

	jmp	SHORT $LN2@xmlExpHash
$LN7@xmlExpHash:

; 6534 : 	default:
; 6535 : 	    ret = 0;

	xor	eax, eax
	mov	WORD PTR _ret$[ebp], ax
$LN2@xmlExpHash:

; 6536 :     }
; 6537 :     return(ret);

	mov	ax, WORD PTR _ret$[ebp]

; 6538 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpHashComputeKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpHashNameComputeKey
_TEXT	SEGMENT
tv74 = -16						; size = 4
tv73 = -12						; size = 4
_ch$ = -5						; size = 1
_value$ = -4						; size = 2
_name$ = 8						; size = 4
_xmlExpHashNameComputeKey PROC				; COMDAT

; 6493 : xmlExpHashNameComputeKey(const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6494 :     unsigned short value = 0L;

	xor	eax, eax
	mov	WORD PTR _value$[ebp], ax

; 6495 :     char ch;
; 6496 : 
; 6497 :     if (name != NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN4@xmlExpHash

; 6498 : 	value += 30 * (*name);

	mov	ecx, DWORD PTR _name$[ebp]
	movzx	edx, BYTE PTR [ecx]
	imul	eax, edx, 30
	movzx	ecx, WORD PTR _value$[ebp]
	add	ecx, eax
	mov	WORD PTR _value$[ebp], cx
$LN2@xmlExpHash:

; 6499 : 	while ((ch = *name++) != 0) {

	mov	edx, DWORD PTR _name$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _ch$[ebp], al
	movsx	ecx, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR _name$[ebp]
	add	edx, 1
	mov	DWORD PTR _name$[ebp], edx
	cmp	DWORD PTR tv73[ebp], 0
	je	SHORT $LN6@xmlExpHash
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN7@xmlExpHash
$LN6@xmlExpHash:
	mov	DWORD PTR tv74[ebp], 0
$LN7@xmlExpHash:
	cmp	DWORD PTR tv74[ebp], 0
	je	SHORT $LN4@xmlExpHash

; 6500 : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	movzx	eax, WORD PTR _value$[ebp]
	movzx	ecx, WORD PTR _value$[ebp]
	shl	ecx, 5
	movzx	edx, WORD PTR _value$[ebp]
	sar	edx, 3
	add	ecx, edx
	movsx	edx, BYTE PTR _ch$[ebp]
	add	ecx, edx
	xor	eax, ecx
	mov	WORD PTR _value$[ebp], ax

; 6501 : 	}

	jmp	SHORT $LN2@xmlExpHash
$LN4@xmlExpHash:

; 6502 :     }
; 6503 :     return (value);

	mov	ax, WORD PTR _value$[ebp]

; 6504 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpHashNameComputeKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpNewNode
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlExpNewNode PROC					; COMDAT

; 6542 : xmlExpNewNode(xmlExpCtxtPtr ctxt, xmlExpNodeType type) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6543 :     xmlExpNodePtr ret;
; 6544 : 
; 6545 :     if (ctxt->nb_nodes >= MAX_NODES)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+16], 10000		; 00002710H
	jl	SHORT $LN2@xmlExpNewN

; 6546 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpNewN
$LN2@xmlExpNewN:

; 6547 :     ret = (xmlExpNodePtr) xmlMalloc(sizeof(xmlExpNode));

	mov	esi, esp
	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 6548 :     if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN3@xmlExpNewN

; 6549 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpNewN
$LN3@xmlExpNewN:

; 6550 :     memset(ret, 0, sizeof(xmlExpNode));

	xor	ecx, ecx
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], ecx
	mov	DWORD PTR [edx+8], ecx
	mov	DWORD PTR [edx+12], ecx
	mov	DWORD PTR [edx+16], ecx
	mov	DWORD PTR [edx+20], ecx
	mov	DWORD PTR [edx+24], ecx

; 6551 :     ret->type = type;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	cl, BYTE PTR _type$[ebp]
	mov	BYTE PTR [eax], cl

; 6552 :     ret->next = NULL;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+16], 0

; 6553 :     ctxt->nb_nodes++;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 6554 :     ctxt->nb_cons++;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 6555 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlExpNewN:

; 6556 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpNewNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseBranch
_TEXT	SEGMENT
tv135 = -16						; size = 4
tv79 = -12						; size = 4
_ret$ = -8						; size = 4
_previous$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_to$ = 12						; size = 4
_xmlFAParseBranch PROC					; COMDAT

; 5344 : xmlFAParseBranch(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr to) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5345 :     xmlRegStatePtr previous;
; 5346 :     int ret;
; 5347 : 
; 5348 :     previous = ctxt->state;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _previous$[ebp], ecx

; 5349 :     ret = xmlFAParsePiece(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFAParsePiece
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 5350 :     if (ret != 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN2@xmlFAParse

; 5351 : 	if (xmlFAGenerateTransitions(ctxt, previous,
; 5352 : 	        (CUR=='|' || CUR==')') ? to : NULL, ctxt->atom) < 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 124				; 0000007cH
	je	SHORT $LN9@xmlFAParse
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 41					; 00000029H
	je	SHORT $LN9@xmlFAParse
	mov	DWORD PTR tv79[ebp], 0
	jmp	SHORT $LN10@xmlFAParse
$LN9@xmlFAParse:
	mov	eax, DWORD PTR _to$[ebp]
	mov	DWORD PTR tv79[ebp], eax
$LN10@xmlFAParse:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR tv79[ebp]
	push	eax
	mov	ecx, DWORD PTR _previous$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFAGenerateTransitions
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN5@xmlFAParse

; 5353 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlFAParse
$LN5@xmlFAParse:

; 5354 : 	previous = ctxt->state;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _previous$[ebp], ecx

; 5355 : 	ctxt->atom = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+28], 0
$LN2@xmlFAParse:

; 5356 :     }
; 5357 :     while ((ret != 0) && (ctxt->error == 0)) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	$LN3@xmlFAParse
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN3@xmlFAParse

; 5358 : 	ret = xmlFAParsePiece(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFAParsePiece
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 5359 : 	if (ret != 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN6@xmlFAParse

; 5360 : 	    if (xmlFAGenerateTransitions(ctxt, previous,
; 5361 : 	            (CUR=='|' || CUR==')') ? to : NULL, ctxt->atom) < 0)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 124				; 0000007cH
	je	SHORT $LN11@xmlFAParse
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 41					; 00000029H
	je	SHORT $LN11@xmlFAParse
	mov	DWORD PTR tv135[ebp], 0
	jmp	SHORT $LN12@xmlFAParse
$LN11@xmlFAParse:
	mov	edx, DWORD PTR _to$[ebp]
	mov	DWORD PTR tv135[ebp], edx
$LN12@xmlFAParse:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR tv135[ebp]
	push	edx
	mov	eax, DWORD PTR _previous$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFAGenerateTransitions
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN7@xmlFAParse

; 5362 : 		    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlFAParse
$LN7@xmlFAParse:

; 5363 : 	    previous = ctxt->state;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _previous$[ebp], eax

; 5364 : 	    ctxt->atom = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+28], 0
$LN6@xmlFAParse:

; 5365 : 	}
; 5366 :     }

	jmp	$LN2@xmlFAParse
$LN3@xmlFAParse:

; 5367 :     return(0);

	xor	eax, eax
$LN1@xmlFAParse:

; 5368 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFAParseBranch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParsePiece
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlFAParsePiece PROC					; COMDAT

; 5319 : xmlFAParsePiece(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5320 :     int ret;
; 5321 : 
; 5322 :     ctxt->atom = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+28], 0

; 5323 :     ret = xmlFAParseAtom(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFAParseAtom
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 5324 :     if (ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlFAParse

; 5325 : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlFAParse
$LN2@xmlFAParse:

; 5326 :     if (ctxt->atom == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+28], 0
	jne	SHORT $LN3@xmlFAParse

; 5327 : 	ERROR("internal: no atom generated");

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0BM@PFFMPGPF@internal?3?5no?5atom?5generated@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegexpErrCompile
	add	esp, 8
$LN3@xmlFAParse:

; 5328 :     }
; 5329 :     xmlFAParseQuantifier(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFAParseQuantifier
	add	esp, 4

; 5330 :     return(1);

	mov	eax, 1
$LN1@xmlFAParse:

; 5331 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFAParsePiece ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseAtom
_TEXT	SEGMENT
_start0$1 = -28						; size = 4
_oldend$2 = -24						; size = 4
_start$3 = -20						; size = 4
_len$ = -12						; size = 4
_codepoint$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_xmlFAParseAtom PROC					; COMDAT

; 5258 : xmlFAParseAtom(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5259 :     int codepoint, len;
; 5260 : 
; 5261 :     codepoint = xmlFAIsChar(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAIsChar
	add	esp, 4
	mov	DWORD PTR _codepoint$[ebp], eax

; 5262 :     if (codepoint > 0) {

	cmp	DWORD PTR _codepoint$[ebp], 0
	jle	SHORT $LN2@xmlFAParse

; 5263 : 	ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_CHARVAL);

	push	2
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegNewAtom
	add	esp, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+28], eax

; 5264 : 	if (ctxt->atom == NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN4@xmlFAParse

; 5265 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlFAParse
$LN4@xmlFAParse:

; 5266 : 	codepoint = CUR_SCHAR(ctxt->cur, len);

	lea	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _codepoint$[ebp], eax

; 5267 : 	ctxt->atom->codepoint = codepoint;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _codepoint$[ebp]
	mov	DWORD PTR [edx+32], eax

; 5268 : 	NEXTL(len);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+4], edx

; 5269 : 	return(1);

	mov	eax, 1
	jmp	$LN1@xmlFAParse
	jmp	$LN3@xmlFAParse
$LN2@xmlFAParse:

; 5270 :     } else if (CUR == '|') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 124				; 0000007cH
	jne	SHORT $LN5@xmlFAParse

; 5271 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlFAParse
	jmp	$LN3@xmlFAParse
$LN5@xmlFAParse:

; 5272 :     } else if (CUR == 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN7@xmlFAParse

; 5273 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlFAParse
	jmp	$LN3@xmlFAParse
$LN7@xmlFAParse:

; 5274 :     } else if (CUR == ')') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN9@xmlFAParse

; 5275 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlFAParse
	jmp	$LN3@xmlFAParse
$LN9@xmlFAParse:

; 5276 :     } else if (CUR == '(') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 40					; 00000028H
	jne	$LN11@xmlFAParse

; 5277 : 	xmlRegStatePtr start, oldend, start0;
; 5278 : 
; 5279 : 	NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+4], edx

; 5280 : 	/*
; 5281 : 	 * this extra Epsilon transition is needed if we count with 0 allowed
; 5282 : 	 * unfortunately this can't be known at that point
; 5283 : 	 */
; 5284 : 	xmlFAGenerateEpsilonTransition(ctxt, ctxt->state, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH

; 5285 : 	start0 = ctxt->state;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _start0$1[ebp], edx

; 5286 : 	xmlFAGenerateEpsilonTransition(ctxt, ctxt->state, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH

; 5287 : 	start = ctxt->state;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _start$3[ebp], ecx

; 5288 : 	oldend = ctxt->end;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _oldend$2[ebp], eax

; 5289 : 	ctxt->end = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 5290 : 	ctxt->atom = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+28], 0

; 5291 : 	xmlFAParseRegExp(ctxt, 0);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAParseRegExp
	add	esp, 8

; 5292 : 	if (CUR == ')') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN13@xmlFAParse

; 5293 : 	    NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+4], edx

; 5294 : 	} else {

	jmp	SHORT $LN14@xmlFAParse
$LN13@xmlFAParse:

; 5295 : 	    ERROR("xmlFAParseAtom: expecting ')'");

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0BO@CCFFKIJF@xmlFAParseAtom?3?5expecting?5?8?$CJ?8@
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegexpErrCompile
	add	esp, 8
$LN14@xmlFAParse:

; 5296 : 	}
; 5297 : 	ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_SUBREG);

	push	4
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegNewAtom
	add	esp, 8
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 5298 : 	if (ctxt->atom == NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+28], 0
	jne	SHORT $LN15@xmlFAParse

; 5299 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlFAParse
$LN15@xmlFAParse:

; 5300 : 	ctxt->atom->start = start;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _start$3[ebp]
	mov	DWORD PTR [ecx+36], edx

; 5301 : 	ctxt->atom->start0 = start0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _start0$1[ebp]
	mov	DWORD PTR [ecx+40], edx

; 5302 : 	ctxt->atom->stop = ctxt->state;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+44], eax

; 5303 : 	ctxt->end = oldend;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _oldend$2[ebp]
	mov	DWORD PTR [ecx+20], edx

; 5304 : 	return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlFAParse
	jmp	SHORT $LN3@xmlFAParse
$LN11@xmlFAParse:

; 5305 :     } else if ((CUR == '[') || (CUR == '\\') || (CUR == '.')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 91					; 0000005bH
	je	SHORT $LN17@xmlFAParse
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN17@xmlFAParse
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	jne	SHORT $LN3@xmlFAParse
$LN17@xmlFAParse:

; 5306 : 	xmlFAParseCharClass(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAParseCharClass
	add	esp, 4

; 5307 : 	return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlFAParse
$LN3@xmlFAParse:

; 5308 :     }
; 5309 :     return(0);

	xor	eax, eax
$LN1@xmlFAParse:

; 5310 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN21@xmlFAParse
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN21@xmlFAParse:
	DD	1
	DD	$LN20@xmlFAParse
$LN20@xmlFAParse:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN19@xmlFAParse
$LN19@xmlFAParse:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
_xmlFAParseAtom ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseQuantifier
_TEXT	SEGMENT
_max$1 = -12						; size = 4
_min$2 = -8						; size = 4
_cur$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlFAParseQuantifier PROC				; COMDAT

; 5198 : xmlFAParseQuantifier(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5199 :     int cur;
; 5200 : 
; 5201 :     cur = CUR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 5202 :     if ((cur == '?') || (cur == '*') || (cur == '+')) {

	cmp	DWORD PTR _cur$[ebp], 63		; 0000003fH
	je	SHORT $LN3@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 42		; 0000002aH
	je	SHORT $LN3@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 43		; 0000002bH
	jne	SHORT $LN2@xmlFAParse
$LN3@xmlFAParse:

; 5203 : 	if (ctxt->atom != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN4@xmlFAParse

; 5204 : 	    if (cur == '?')

	cmp	DWORD PTR _cur$[ebp], 63		; 0000003fH
	jne	SHORT $LN5@xmlFAParse

; 5205 : 		ctxt->atom->quant = XML_REGEXP_QUANT_OPT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [edx+8], 3
	jmp	SHORT $LN4@xmlFAParse
$LN5@xmlFAParse:

; 5206 : 	    else if (cur == '*')

	cmp	DWORD PTR _cur$[ebp], 42		; 0000002aH
	jne	SHORT $LN7@xmlFAParse

; 5207 : 		ctxt->atom->quant = XML_REGEXP_QUANT_MULT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+8], 4
	jmp	SHORT $LN4@xmlFAParse
$LN7@xmlFAParse:

; 5208 : 	    else if (cur == '+')

	cmp	DWORD PTR _cur$[ebp], 43		; 0000002bH
	jne	SHORT $LN4@xmlFAParse

; 5209 : 		ctxt->atom->quant = XML_REGEXP_QUANT_PLUS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [eax+8], 5
$LN4@xmlFAParse:

; 5210 : 	}
; 5211 : 	NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+4], edx

; 5212 : 	return(1);

	mov	eax, 1
	jmp	$LN1@xmlFAParse
$LN2@xmlFAParse:

; 5213 :     }
; 5214 :     if (cur == '{') {

	cmp	DWORD PTR _cur$[ebp], 123		; 0000007bH
	jne	$LN10@xmlFAParse

; 5215 : 	int min = 0, max = 0;

	mov	DWORD PTR _min$2[ebp], 0
	mov	DWORD PTR _max$1[ebp], 0

; 5216 : 
; 5217 : 	NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+4], edx

; 5218 : 	cur = xmlFAParseQuantExact(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFAParseQuantExact
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 5219 : 	if (cur >= 0)

	cmp	DWORD PTR _cur$[ebp], 0
	jl	SHORT $LN11@xmlFAParse

; 5220 : 	    min = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _min$2[ebp], edx
$LN11@xmlFAParse:

; 5221 : 	if (CUR == ',') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	jne	SHORT $LN12@xmlFAParse

; 5222 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 5223 : 	    if (CUR == '}')

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 125				; 0000007dH
	jne	SHORT $LN13@xmlFAParse

; 5224 : 	        max = INT_MAX;

	mov	DWORD PTR _max$1[ebp], 2147483647	; 7fffffffH
	jmp	SHORT $LN12@xmlFAParse
$LN13@xmlFAParse:

; 5225 : 	    else {
; 5226 : 	        cur = xmlFAParseQuantExact(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAParseQuantExact
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 5227 : 	        if (cur >= 0)

	cmp	DWORD PTR _cur$[ebp], 0
	jl	SHORT $LN15@xmlFAParse

; 5228 : 		    max = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _max$1[ebp], ecx
	jmp	SHORT $LN12@xmlFAParse
$LN15@xmlFAParse:

; 5229 : 		else {
; 5230 : 		    ERROR("Improper quantifier");

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0BE@PGBJEMPN@Improper?5quantifier@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrCompile
	add	esp, 8
$LN12@xmlFAParse:

; 5231 : 		}
; 5232 : 	    }
; 5233 : 	}
; 5234 : 	if (CUR == '}') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 125				; 0000007dH
	jne	SHORT $LN17@xmlFAParse

; 5235 : 	    NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+4], edx

; 5236 : 	} else {

	jmp	SHORT $LN18@xmlFAParse
$LN17@xmlFAParse:

; 5237 : 	    ERROR("Unterminated quantifier");

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0BI@HKPFPPFN@Unterminated?5quantifier@
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegexpErrCompile
	add	esp, 8
$LN18@xmlFAParse:

; 5238 : 	}
; 5239 : 	if (max == 0)

	cmp	DWORD PTR _max$1[ebp], 0
	jne	SHORT $LN19@xmlFAParse

; 5240 : 	    max = min;

	mov	eax, DWORD PTR _min$2[ebp]
	mov	DWORD PTR _max$1[ebp], eax
$LN19@xmlFAParse:

; 5241 : 	if (ctxt->atom != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN20@xmlFAParse

; 5242 : 	    ctxt->atom->quant = XML_REGEXP_QUANT_RANGE;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [eax+8], 8

; 5243 : 	    ctxt->atom->min = min;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _min$2[ebp]
	mov	DWORD PTR [edx+12], eax

; 5244 : 	    ctxt->atom->max = max;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _max$1[ebp]
	mov	DWORD PTR [edx+16], eax
$LN20@xmlFAParse:

; 5245 : 	}
; 5246 : 	return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlFAParse
$LN10@xmlFAParse:

; 5247 :     }
; 5248 :     return(0);

	xor	eax, eax
$LN1@xmlFAParse:

; 5249 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFAParseQuantifier ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseQuantExact
_TEXT	SEGMENT
_ok$ = -8						; size = 4
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlFAParseQuantExact PROC				; COMDAT

; 5172 : xmlFAParseQuantExact(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5173 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 5174 :     int ok = 0;

	mov	DWORD PTR _ok$[ebp], 0
$LN2@xmlFAParse:

; 5175 : 
; 5176 :     while ((CUR >= '0') && (CUR <= '9')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN3@xmlFAParse
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jg	SHORT $LN3@xmlFAParse

; 5177 : 	ret = ret * 10 + (CUR - '0');

	imul	eax, DWORD PTR _ret$[ebp], 10
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	ecx, BYTE PTR [edx]
	lea	edx, DWORD PTR [eax+ecx-48]
	mov	DWORD PTR _ret$[ebp], edx

; 5178 : 	ok = 1;

	mov	DWORD PTR _ok$[ebp], 1

; 5179 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 5180 :     }

	jmp	SHORT $LN2@xmlFAParse
$LN3@xmlFAParse:

; 5181 :     if (ok != 1) {

	cmp	DWORD PTR _ok$[ebp], 1
	je	SHORT $LN4@xmlFAParse

; 5182 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlFAParse
$LN4@xmlFAParse:

; 5183 :     }
; 5184 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlFAParse:

; 5185 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFAParseQuantExact ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseCharClass
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlFAParseCharClass PROC				; COMDAT

; 5146 : xmlFAParseCharClass(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5147 :     if (CUR == '[') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 91					; 0000005bH
	jne	SHORT $LN2@xmlFAParse

; 5148 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 5149 : 	ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_RANGES);

	push	3
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegNewAtom
	add	esp, 8
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 5150 : 	if (ctxt->atom == NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+28], 0
	jne	SHORT $LN4@xmlFAParse

; 5151 : 	    return;

	jmp	SHORT $LN1@xmlFAParse
$LN4@xmlFAParse:

; 5152 : 	xmlFAParseCharGroup(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAParseCharGroup
	add	esp, 4

; 5153 : 	if (CUR == ']') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 93					; 0000005dH
	jne	SHORT $LN5@xmlFAParse

; 5154 : 	    NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+4], edx

; 5155 : 	} else {

	jmp	SHORT $LN6@xmlFAParse
$LN5@xmlFAParse:

; 5156 : 	    ERROR("xmlFAParseCharClass: ']' expected");

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0CC@FKLKCEIP@xmlFAParseCharClass?3?5?8?$FN?8?5expect@
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegexpErrCompile
	add	esp, 8
$LN6@xmlFAParse:

; 5157 : 	}
; 5158 :     } else {

	jmp	SHORT $LN1@xmlFAParse
$LN2@xmlFAParse:

; 5159 : 	xmlFAParseCharClassEsc(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAParseCharClassEsc
	add	esp, 4
$LN1@xmlFAParse:

; 5160 :     }
; 5161 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFAParseCharClass ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseCharGroup
_TEXT	SEGMENT
tv83 = -16						; size = 4
_neg$1 = -12						; size = 4
_neg$2 = -8						; size = 4
_n$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlFAParseCharGroup PROC				; COMDAT

; 5107 : xmlFAParseCharGroup(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5108 :     int n = ctxt->neg;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _n$[ebp], ecx
$LN2@xmlFAParse:

; 5109 :     while ((CUR != ']') && (ctxt->error == 0)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 93					; 0000005dH
	je	$LN3@xmlFAParse
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	$LN3@xmlFAParse

; 5110 : 	if (CUR == '^') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 94					; 0000005eH
	jne	SHORT $LN4@xmlFAParse

; 5111 : 	    int neg = ctxt->neg;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _neg$2[ebp], ecx

; 5112 : 
; 5113 : 	    NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 5114 : 	    ctxt->neg = !ctxt->neg;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN12@xmlFAParse
	mov	DWORD PTR tv83[ebp], 1
	jmp	SHORT $LN13@xmlFAParse
$LN12@xmlFAParse:
	mov	DWORD PTR tv83[ebp], 0
$LN13@xmlFAParse:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR tv83[ebp]
	mov	DWORD PTR [eax+12], ecx

; 5115 : 	    xmlFAParsePosCharGroup(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFAParsePosCharGroup
	add	esp, 4

; 5116 : 	    ctxt->neg = neg;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _neg$2[ebp]
	mov	DWORD PTR [eax+12], ecx
	jmp	$LN5@xmlFAParse
$LN4@xmlFAParse:

; 5117 : 	} else if ((CUR == '-') && (NXT(1) == '[')) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	$LN6@xmlFAParse
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 91					; 0000005bH
	jne	$LN6@xmlFAParse

; 5118 : 	    int neg = ctxt->neg;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _neg$1[ebp], ecx

; 5119 : 	    ctxt->neg = 2;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+12], 2

; 5120 : 	    NEXT;	/* eat the '-' */

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 5121 : 	    NEXT;	/* eat the '[' */

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 5122 : 	    xmlFAParseCharGroup(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAParseCharGroup
	add	esp, 4

; 5123 : 	    if (CUR == ']') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 93					; 0000005dH
	jne	SHORT $LN8@xmlFAParse

; 5124 : 		NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+4], edx

; 5125 : 	    } else {

	jmp	SHORT $LN9@xmlFAParse
$LN8@xmlFAParse:

; 5126 : 		ERROR("charClassExpr: ']' expected");

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0BM@FJAEMPFO@charClassExpr?3?5?8?$FN?8?5expected@
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegexpErrCompile
	add	esp, 8

; 5127 : 		break;

	jmp	SHORT $LN3@xmlFAParse
$LN9@xmlFAParse:

; 5128 : 	    }
; 5129 : 	    ctxt->neg = neg;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _neg$1[ebp]
	mov	DWORD PTR [eax+12], ecx

; 5130 : 	    break;

	jmp	SHORT $LN3@xmlFAParse
	jmp	SHORT $LN5@xmlFAParse
$LN6@xmlFAParse:

; 5131 : 	} else if (CUR != ']') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 93					; 0000005dH
	je	SHORT $LN5@xmlFAParse

; 5132 : 	    xmlFAParsePosCharGroup(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFAParsePosCharGroup
	add	esp, 4
$LN5@xmlFAParse:

; 5133 : 	}
; 5134 :     }

	jmp	$LN2@xmlFAParse
$LN3@xmlFAParse:

; 5135 :     ctxt->neg = n;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 5136 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFAParseCharGroup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParsePosCharGroup
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlFAParsePosCharGroup PROC				; COMDAT

; 5086 : xmlFAParsePosCharGroup(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
$LN4@xmlFAParse:

; 5087 :     do {
; 5088 : 	if (CUR == '\\') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 92					; 0000005cH
	jne	SHORT $LN5@xmlFAParse

; 5089 : 	    xmlFAParseCharClassEsc(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAParseCharClassEsc
	add	esp, 4

; 5090 : 	} else {

	jmp	SHORT $LN2@xmlFAParse
$LN5@xmlFAParse:

; 5091 : 	    xmlFAParseCharRange(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFAParseCharRange
	add	esp, 4
$LN2@xmlFAParse:

; 5092 : 	}
; 5093 :     } while ((CUR != ']') && (CUR != '^') && (CUR != '-') &&
; 5094 :              (CUR != 0) && (ctxt->error == 0));

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 93					; 0000005dH
	je	SHORT $LN1@xmlFAParse
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 94					; 0000005eH
	je	SHORT $LN1@xmlFAParse
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN1@xmlFAParse
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@xmlFAParse
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN4@xmlFAParse
$LN1@xmlFAParse:

; 5095 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFAParsePosCharGroup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseCharRange
_TEXT	SEGMENT
tv185 = -32						; size = 4
tv82 = -28						; size = 4
_end$ = -24						; size = 4
_start$ = -20						; size = 4
_len$ = -12						; size = 4
_cur$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlFAParseCharRange PROC				; COMDAT

; 4994 : xmlFAParseCharRange(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 4995 :     int cur, len;
; 4996 :     int start = -1;

	mov	DWORD PTR _start$[ebp], -1

; 4997 :     int end = -1;

	mov	DWORD PTR _end$[ebp], -1

; 4998 : 
; 4999 :     if (CUR == '\0') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN6@xmlFAParse

; 5000 :         ERROR("Expecting ']'");

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0O@NKKGCCKG@Expecting?5?8?$FN?8@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegexpErrCompile
	add	esp, 8

; 5001 : 	return;

	jmp	$LN1@xmlFAParse
$LN6@xmlFAParse:

; 5002 :     }
; 5003 : 
; 5004 :     cur = CUR;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 5005 :     if (cur == '\\') {

	cmp	DWORD PTR _cur$[ebp], 92		; 0000005cH
	jne	$LN7@xmlFAParse

; 5006 : 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 5007 : 	cur = CUR;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 5008 : 	switch (cur) {

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR tv82[ebp], edx
	mov	eax, DWORD PTR tv82[ebp]
	sub	eax, 40					; 00000028H
	mov	DWORD PTR tv82[ebp], eax
	cmp	DWORD PTR tv82[ebp], 85			; 00000055H
	ja	SHORT $LN13@xmlFAParse
	mov	ecx, DWORD PTR tv82[ebp]
	movzx	edx, BYTE PTR $LN31@xmlFAParse[ecx]
	jmp	DWORD PTR $LN36@xmlFAParse[edx*4]
$LN9@xmlFAParse:

; 5009 : 	    case 'n': start = 0xA; break;

	mov	DWORD PTR _start$[ebp], 10		; 0000000aH
	jmp	SHORT $LN2@xmlFAParse
$LN10@xmlFAParse:

; 5010 : 	    case 'r': start = 0xD; break;

	mov	DWORD PTR _start$[ebp], 13		; 0000000dH
	jmp	SHORT $LN2@xmlFAParse
$LN11@xmlFAParse:

; 5011 : 	    case 't': start = 0x9; break;

	mov	DWORD PTR _start$[ebp], 9
	jmp	SHORT $LN2@xmlFAParse
$LN12@xmlFAParse:

; 5012 : 	    case '\\': case '|': case '.': case '-': case '^': case '?':
; 5013 : 	    case '*': case '+': case '{': case '}': case '(': case ')':
; 5014 : 	    case '[': case ']':
; 5015 : 		start = cur; break;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _start$[ebp], eax
	jmp	SHORT $LN2@xmlFAParse
$LN13@xmlFAParse:

; 5016 : 	    default:
; 5017 : 		ERROR("Invalid escape value");

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0BF@HOMDEKLG@Invalid?5escape?5value@
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegexpErrCompile
	add	esp, 8

; 5018 : 		return;

	jmp	$LN1@xmlFAParse
$LN2@xmlFAParse:

; 5019 : 	}
; 5020 : 	end = start;

	mov	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR _end$[ebp], eax

; 5021 :         len = 1;

	mov	DWORD PTR _len$[ebp], 1
	jmp	SHORT $LN8@xmlFAParse
$LN7@xmlFAParse:

; 5022 :     } else if ((cur != 0x5B) && (cur != 0x5D)) {

	cmp	DWORD PTR _cur$[ebp], 91		; 0000005bH
	je	SHORT $LN14@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 93		; 0000005dH
	je	SHORT $LN14@xmlFAParse

; 5023 :         end = start = CUR_SCHAR(ctxt->cur, len);

	lea	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _start$[ebp], eax
	mov	ecx, DWORD PTR _start$[ebp]
	mov	DWORD PTR _end$[ebp], ecx

; 5024 :     } else {

	jmp	SHORT $LN8@xmlFAParse
$LN14@xmlFAParse:

; 5025 : 	ERROR("Expecting a char range");

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0BH@LOJMKNAD@Expecting?5a?5char?5range@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrCompile
	add	esp, 8

; 5026 : 	return;

	jmp	$LN1@xmlFAParse
$LN8@xmlFAParse:

; 5027 :     }
; 5028 :     /*
; 5029 :      * Since we are "inside" a range, we can assume ctxt->cur is past
; 5030 :      * the start of ctxt->string, and PREV should be safe
; 5031 :      */
; 5032 :     if ((start == '-') && (NXT(1) != ']') && (PREV != '[') && (PREV != '^')) {

	cmp	DWORD PTR _start$[ebp], 45		; 0000002dH
	jne	SHORT $LN16@xmlFAParse
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 93					; 0000005dH
	je	SHORT $LN16@xmlFAParse
	mov	edx, 1
	imul	eax, edx, -1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx+eax]
	cmp	eax, 91					; 0000005bH
	je	SHORT $LN16@xmlFAParse
	mov	ecx, 1
	imul	edx, ecx, -1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 94					; 0000005eH
	je	SHORT $LN16@xmlFAParse

; 5033 : 	NEXTL(len);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 5034 : 	return;

	jmp	$LN1@xmlFAParse
$LN16@xmlFAParse:

; 5035 :     }
; 5036 :     NEXTL(len);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 5037 :     cur = CUR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 5038 :     if ((cur != '-') || (NXT(1) == ']')) {

	cmp	DWORD PTR _cur$[ebp], 45		; 0000002dH
	jne	SHORT $LN18@xmlFAParse
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx+eax]
	cmp	eax, 93					; 0000005dH
	jne	SHORT $LN17@xmlFAParse
$LN18@xmlFAParse:

; 5039 :         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,

	push	0
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegAtomAddRange
	add	esp, 28					; 0000001cH

; 5040 : 		              XML_REGEXP_CHARVAL, start, end, NULL);
; 5041 : 	return;

	jmp	$LN1@xmlFAParse
$LN17@xmlFAParse:

; 5042 :     }
; 5043 :     NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 5044 :     cur = CUR;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 5045 :     if (cur == '\\') {

	cmp	DWORD PTR _cur$[ebp], 92		; 0000005cH
	jne	$LN19@xmlFAParse

; 5046 : 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 5047 : 	cur = CUR;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 5048 : 	switch (cur) {

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR tv185[ebp], edx
	mov	eax, DWORD PTR tv185[ebp]
	sub	eax, 40					; 00000028H
	mov	DWORD PTR tv185[ebp], eax
	cmp	DWORD PTR tv185[ebp], 85		; 00000055H
	ja	SHORT $LN25@xmlFAParse
	mov	ecx, DWORD PTR tv185[ebp]
	movzx	edx, BYTE PTR $LN32@xmlFAParse[ecx]
	jmp	DWORD PTR $LN37@xmlFAParse[edx*4]
$LN21@xmlFAParse:

; 5049 : 	    case 'n': end = 0xA; break;

	mov	DWORD PTR _end$[ebp], 10		; 0000000aH
	jmp	SHORT $LN4@xmlFAParse
$LN22@xmlFAParse:

; 5050 : 	    case 'r': end = 0xD; break;

	mov	DWORD PTR _end$[ebp], 13		; 0000000dH
	jmp	SHORT $LN4@xmlFAParse
$LN23@xmlFAParse:

; 5051 : 	    case 't': end = 0x9; break;

	mov	DWORD PTR _end$[ebp], 9
	jmp	SHORT $LN4@xmlFAParse
$LN24@xmlFAParse:

; 5052 : 	    case '\\': case '|': case '.': case '-': case '^': case '?':
; 5053 : 	    case '*': case '+': case '{': case '}': case '(': case ')':
; 5054 : 	    case '[': case ']':
; 5055 : 		end = cur; break;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _end$[ebp], eax
	jmp	SHORT $LN4@xmlFAParse
$LN25@xmlFAParse:

; 5056 : 	    default:
; 5057 : 		ERROR("Invalid escape value");

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0BF@HOMDEKLG@Invalid?5escape?5value@
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegexpErrCompile
	add	esp, 8

; 5058 : 		return;

	jmp	$LN1@xmlFAParse
$LN4@xmlFAParse:

; 5059 : 	}
; 5060 :         len = 1;

	mov	DWORD PTR _len$[ebp], 1
	jmp	SHORT $LN20@xmlFAParse
$LN19@xmlFAParse:

; 5061 :     } else if ((cur != '\0') && (cur != 0x5B) && (cur != 0x5D)) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN26@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 91		; 0000005bH
	je	SHORT $LN26@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 93		; 0000005dH
	je	SHORT $LN26@xmlFAParse

; 5062 :         end = CUR_SCHAR(ctxt->cur, len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _end$[ebp], eax

; 5063 :     } else {

	jmp	SHORT $LN20@xmlFAParse
$LN26@xmlFAParse:

; 5064 : 	ERROR("Expecting the end of a char range");

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0CC@JHFKDBIP@Expecting?5the?5end?5of?5a?5char?5ran@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegexpErrCompile
	add	esp, 8

; 5065 : 	return;

	jmp	SHORT $LN1@xmlFAParse
$LN20@xmlFAParse:

; 5066 :     }
; 5067 : 
; 5068 :     /* TODO check that the values are acceptable character ranges for XML */
; 5069 :     if (end < start) {

	mov	edx, DWORD PTR _end$[ebp]
	cmp	edx, DWORD PTR _start$[ebp]
	jge	SHORT $LN28@xmlFAParse

; 5070 : 	ERROR("End of range is before start of range");

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0CG@BKADGONK@End?5of?5range?5is?5before?5start?5of@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegexpErrCompile
	add	esp, 8

; 5071 :     } else {

	jmp	SHORT $LN1@xmlFAParse
$LN28@xmlFAParse:

; 5072 :         NEXTL(len);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 5073 :         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,

	push	0
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegAtomAddRange
	add	esp, 28					; 0000001cH
$LN1@xmlFAParse:

; 5074 : 		           XML_REGEXP_CHARVAL, start, end, NULL);
; 5075 :     }
; 5076 :     return;
; 5077 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN35@xmlFAParse
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN35@xmlFAParse:
	DD	1
	DD	$LN34@xmlFAParse
$LN34@xmlFAParse:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN33@xmlFAParse
$LN33@xmlFAParse:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN36@xmlFAParse:
	DD	$LN12@xmlFAParse
	DD	$LN9@xmlFAParse
	DD	$LN10@xmlFAParse
	DD	$LN11@xmlFAParse
	DD	$LN13@xmlFAParse
$LN31@xmlFAParse:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	4
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	0
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	0
	DB	0
	npad	2
$LN37@xmlFAParse:
	DD	$LN24@xmlFAParse
	DD	$LN21@xmlFAParse
	DD	$LN22@xmlFAParse
	DD	$LN23@xmlFAParse
	DD	$LN25@xmlFAParse
$LN32@xmlFAParse:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	4
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	0
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	0
	DB	0
_xmlFAParseCharRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseCharClassEsc
_TEXT	SEGMENT
tv263 = -20						; size = 4
tv236 = -16						; size = 4
tv221 = -12						; size = 4
_type$1 = -8						; size = 4
_cur$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlFAParseCharClassEsc PROC				; COMDAT

; 4849 : xmlFAParseCharClassEsc(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 4850 :     int cur;
; 4851 : 
; 4852 :     if (CUR == '.') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	jne	SHORT $LN8@xmlFAParse

; 4853 : 	if (ctxt->atom == NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN9@xmlFAParse

; 4854 : 	    ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_ANYCHAR);

	push	6
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegNewAtom
	add	esp, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+28], eax
	jmp	SHORT $LN10@xmlFAParse
$LN9@xmlFAParse:

; 4855 : 	} else if (ctxt->atom->type == XML_REGEXP_RANGES) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx+4], 3
	jne	SHORT $LN10@xmlFAParse

; 4856 : 	    xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,

	push	0
	push	0
	push	0
	push	6
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegAtomAddRange
	add	esp, 28					; 0000001cH
$LN10@xmlFAParse:

; 4857 : 			       XML_REGEXP_ANYCHAR, 0, 0, NULL);
; 4858 : 	}
; 4859 : 	NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+4], edx

; 4860 : 	return;

	jmp	$LN1@xmlFAParse
$LN8@xmlFAParse:

; 4861 :     }
; 4862 :     if (CUR != '\\') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN12@xmlFAParse

; 4863 : 	ERROR("Escaped sequence: expecting \\");

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0BO@BOFONOMH@Escaped?5sequence?3?5expecting?5?2@
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegexpErrCompile
	add	esp, 8

; 4864 : 	return;

	jmp	$LN1@xmlFAParse
$LN12@xmlFAParse:

; 4865 :     }
; 4866 :     NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4867 :     cur = CUR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 4868 :     if (cur == 'p') {

	cmp	DWORD PTR _cur$[ebp], 112		; 00000070H
	jne	$LN13@xmlFAParse

; 4869 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4870 : 	if (CUR != '{') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 123				; 0000007bH
	je	SHORT $LN15@xmlFAParse

; 4871 : 	    ERROR("Expecting '{'");

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0O@OGGGBIPE@Expecting?5?8?$HL?8@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegexpErrCompile
	add	esp, 8

; 4872 : 	    return;

	jmp	$LN1@xmlFAParse
$LN15@xmlFAParse:

; 4873 : 	}
; 4874 : 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 4875 : 	xmlFAParseCharProp(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFAParseCharProp
	add	esp, 4

; 4876 : 	if (CUR != '}') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 125				; 0000007dH
	je	SHORT $LN16@xmlFAParse

; 4877 : 	    ERROR("Expecting '}'");

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0O@OCOLGEEG@Expecting?5?8?$HN?8@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegexpErrCompile
	add	esp, 8

; 4878 : 	    return;

	jmp	$LN1@xmlFAParse
$LN16@xmlFAParse:

; 4879 : 	}
; 4880 : 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+4], eax
	jmp	$LN1@xmlFAParse
$LN13@xmlFAParse:

; 4881 :     } else if (cur == 'P') {

	cmp	DWORD PTR _cur$[ebp], 80		; 00000050H
	jne	$LN17@xmlFAParse

; 4882 : 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 4883 : 	if (CUR != '{') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 123				; 0000007bH
	je	SHORT $LN19@xmlFAParse

; 4884 : 	    ERROR("Expecting '{'");

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0O@OGGGBIPE@Expecting?5?8?$HL?8@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrCompile
	add	esp, 8

; 4885 : 	    return;

	jmp	$LN1@xmlFAParse
$LN19@xmlFAParse:

; 4886 : 	}
; 4887 : 	NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+4], edx

; 4888 : 	xmlFAParseCharProp(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFAParseCharProp
	add	esp, 4

; 4889 :         if (ctxt->atom != NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN20@xmlFAParse

; 4890 : 	    ctxt->atom->neg = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+28], 1
$LN20@xmlFAParse:

; 4891 : 	if (CUR != '}') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 125				; 0000007dH
	je	SHORT $LN21@xmlFAParse

; 4892 : 	    ERROR("Expecting '}'");

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0O@OCOLGEEG@Expecting?5?8?$HN?8@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrCompile
	add	esp, 8

; 4893 : 	    return;

	jmp	$LN1@xmlFAParse
$LN21@xmlFAParse:

; 4894 : 	}
; 4895 : 	NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+4], edx

; 4896 :     } else if ((cur == 'n') || (cur == 'r') || (cur == 't') || (cur == '\\') ||

	jmp	$LN1@xmlFAParse
$LN17@xmlFAParse:

; 4897 : 	(cur == '|') || (cur == '.') || (cur == '?') || (cur == '*') ||
; 4898 : 	(cur == '+') || (cur == '(') || (cur == ')') || (cur == '{') ||
; 4899 : 	(cur == '}') || (cur == 0x2D) || (cur == 0x5B) || (cur == 0x5D) ||

	cmp	DWORD PTR _cur$[ebp], 110		; 0000006eH
	je	SHORT $LN24@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 114		; 00000072H
	je	SHORT $LN24@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 116		; 00000074H
	je	SHORT $LN24@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 92		; 0000005cH
	je	SHORT $LN24@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 124		; 0000007cH
	je	SHORT $LN24@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 46		; 0000002eH
	je	SHORT $LN24@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 63		; 0000003fH
	je	SHORT $LN24@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 42		; 0000002aH
	je	SHORT $LN24@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 43		; 0000002bH
	je	SHORT $LN24@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 40		; 00000028H
	je	SHORT $LN24@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 41		; 00000029H
	je	SHORT $LN24@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 123		; 0000007bH
	je	SHORT $LN24@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 125		; 0000007dH
	je	SHORT $LN24@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 45		; 0000002dH
	je	SHORT $LN24@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 91		; 0000005bH
	je	SHORT $LN24@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 93		; 0000005dH
	je	SHORT $LN24@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 94		; 0000005eH
	jne	$LN22@xmlFAParse
$LN24@xmlFAParse:

; 4900 : 	(cur == 0x5E)) {
; 4901 : 	if (ctxt->atom == NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $LN25@xmlFAParse

; 4902 : 	    ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_CHARVAL);

	push	2
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegNewAtom
	add	esp, 8
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 4903 : 	    if (ctxt->atom != NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN27@xmlFAParse

; 4904 : 	        switch (cur) {

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR tv221[ebp], eax
	cmp	DWORD PTR tv221[ebp], 110		; 0000006eH
	je	SHORT $LN28@xmlFAParse
	cmp	DWORD PTR tv221[ebp], 114		; 00000072H
	je	SHORT $LN29@xmlFAParse
	cmp	DWORD PTR tv221[ebp], 116		; 00000074H
	je	SHORT $LN30@xmlFAParse
	jmp	SHORT $LN31@xmlFAParse
$LN28@xmlFAParse:

; 4905 : 		    case 'n':
; 4906 : 		        ctxt->atom->codepoint = '\n';

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [edx+32], 10			; 0000000aH

; 4907 : 			break;

	jmp	SHORT $LN27@xmlFAParse
$LN29@xmlFAParse:

; 4908 : 		    case 'r':
; 4909 : 		        ctxt->atom->codepoint = '\r';

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+32], 13			; 0000000dH

; 4910 : 			break;

	jmp	SHORT $LN27@xmlFAParse
$LN30@xmlFAParse:

; 4911 : 		    case 't':
; 4912 : 		        ctxt->atom->codepoint = '\t';

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [eax+32], 9

; 4913 : 			break;

	jmp	SHORT $LN27@xmlFAParse
$LN31@xmlFAParse:

; 4914 : 		    default:
; 4915 : 			ctxt->atom->codepoint = cur;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+32], eax
$LN27@xmlFAParse:

; 4916 : 		}
; 4917 : 	    }

	jmp	SHORT $LN26@xmlFAParse
$LN25@xmlFAParse:

; 4918 : 	} else if (ctxt->atom->type == XML_REGEXP_RANGES) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	DWORD PTR [edx+4], 3
	jne	SHORT $LN26@xmlFAParse

; 4919 :             switch (cur) {

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR tv236[ebp], eax
	cmp	DWORD PTR tv236[ebp], 110		; 0000006eH
	je	SHORT $LN33@xmlFAParse
	cmp	DWORD PTR tv236[ebp], 114		; 00000072H
	je	SHORT $LN34@xmlFAParse
	cmp	DWORD PTR tv236[ebp], 116		; 00000074H
	je	SHORT $LN35@xmlFAParse
	jmp	SHORT $LN4@xmlFAParse
$LN33@xmlFAParse:

; 4920 :                 case 'n':
; 4921 :                     cur = '\n';

	mov	DWORD PTR _cur$[ebp], 10		; 0000000aH

; 4922 :                     break;

	jmp	SHORT $LN4@xmlFAParse
$LN34@xmlFAParse:

; 4923 :                 case 'r':
; 4924 :                     cur = '\r';

	mov	DWORD PTR _cur$[ebp], 13		; 0000000dH

; 4925 :                     break;

	jmp	SHORT $LN4@xmlFAParse
$LN35@xmlFAParse:

; 4926 :                 case 't':
; 4927 :                     cur = '\t';

	mov	DWORD PTR _cur$[ebp], 9
$LN4@xmlFAParse:

; 4928 :                     break;
; 4929 :             }
; 4930 : 	    xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,

	push	0
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegAtomAddRange
	add	esp, 28					; 0000001cH
$LN26@xmlFAParse:

; 4931 : 			       XML_REGEXP_CHARVAL, cur, cur, NULL);
; 4932 : 	}
; 4933 : 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 4934 :     } else if ((cur == 's') || (cur == 'S') || (cur == 'i') || (cur == 'I') ||

	jmp	$LN1@xmlFAParse
$LN22@xmlFAParse:

; 4935 : 	(cur == 'c') || (cur == 'C') || (cur == 'd') || (cur == 'D') ||
; 4936 : 	(cur == 'w') || (cur == 'W')) {

	cmp	DWORD PTR _cur$[ebp], 115		; 00000073H
	je	SHORT $LN38@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 83		; 00000053H
	je	SHORT $LN38@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 105		; 00000069H
	je	SHORT $LN38@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 73		; 00000049H
	je	SHORT $LN38@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 99		; 00000063H
	je	SHORT $LN38@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 67		; 00000043H
	je	SHORT $LN38@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 100		; 00000064H
	je	SHORT $LN38@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 68		; 00000044H
	je	SHORT $LN38@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 119		; 00000077H
	je	SHORT $LN38@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 87		; 00000057H
	jne	$LN36@xmlFAParse
$LN38@xmlFAParse:

; 4937 : 	xmlRegAtomType type = XML_REGEXP_ANYSPACE;

	mov	DWORD PTR _type$1[ebp], 7

; 4938 : 
; 4939 : 	switch (cur) {

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR tv263[ebp], edx
	mov	eax, DWORD PTR tv263[ebp]
	sub	eax, 67					; 00000043H
	mov	DWORD PTR tv263[ebp], eax
	cmp	DWORD PTR tv263[ebp], 52		; 00000034H
	ja	SHORT $LN6@xmlFAParse
	mov	ecx, DWORD PTR tv263[ebp]
	movzx	edx, BYTE PTR $LN53@xmlFAParse[ecx]
	jmp	DWORD PTR $LN54@xmlFAParse[edx*4]
$LN39@xmlFAParse:

; 4940 : 	    case 's':
; 4941 : 		type = XML_REGEXP_ANYSPACE;

	mov	DWORD PTR _type$1[ebp], 7

; 4942 : 		break;

	jmp	SHORT $LN6@xmlFAParse
$LN40@xmlFAParse:

; 4943 : 	    case 'S':
; 4944 : 		type = XML_REGEXP_NOTSPACE;

	mov	DWORD PTR _type$1[ebp], 8

; 4945 : 		break;

	jmp	SHORT $LN6@xmlFAParse
$LN41@xmlFAParse:

; 4946 : 	    case 'i':
; 4947 : 		type = XML_REGEXP_INITNAME;

	mov	DWORD PTR _type$1[ebp], 9

; 4948 : 		break;

	jmp	SHORT $LN6@xmlFAParse
$LN42@xmlFAParse:

; 4949 : 	    case 'I':
; 4950 : 		type = XML_REGEXP_NOTINITNAME;

	mov	DWORD PTR _type$1[ebp], 10		; 0000000aH

; 4951 : 		break;

	jmp	SHORT $LN6@xmlFAParse
$LN43@xmlFAParse:

; 4952 : 	    case 'c':
; 4953 : 		type = XML_REGEXP_NAMECHAR;

	mov	DWORD PTR _type$1[ebp], 11		; 0000000bH

; 4954 : 		break;

	jmp	SHORT $LN6@xmlFAParse
$LN44@xmlFAParse:

; 4955 : 	    case 'C':
; 4956 : 		type = XML_REGEXP_NOTNAMECHAR;

	mov	DWORD PTR _type$1[ebp], 12		; 0000000cH

; 4957 : 		break;

	jmp	SHORT $LN6@xmlFAParse
$LN45@xmlFAParse:

; 4958 : 	    case 'd':
; 4959 : 		type = XML_REGEXP_DECIMAL;

	mov	DWORD PTR _type$1[ebp], 13		; 0000000dH

; 4960 : 		break;

	jmp	SHORT $LN6@xmlFAParse
$LN46@xmlFAParse:

; 4961 : 	    case 'D':
; 4962 : 		type = XML_REGEXP_NOTDECIMAL;

	mov	DWORD PTR _type$1[ebp], 14		; 0000000eH

; 4963 : 		break;

	jmp	SHORT $LN6@xmlFAParse
$LN47@xmlFAParse:

; 4964 : 	    case 'w':
; 4965 : 		type = XML_REGEXP_REALCHAR;

	mov	DWORD PTR _type$1[ebp], 15		; 0000000fH

; 4966 : 		break;

	jmp	SHORT $LN6@xmlFAParse
$LN48@xmlFAParse:

; 4967 : 	    case 'W':
; 4968 : 		type = XML_REGEXP_NOTREALCHAR;

	mov	DWORD PTR _type$1[ebp], 16		; 00000010H
$LN6@xmlFAParse:

; 4969 : 		break;
; 4970 : 	}
; 4971 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4972 : 	if (ctxt->atom == NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN49@xmlFAParse

; 4973 : 	    ctxt->atom = xmlRegNewAtom(ctxt, type);

	mov	ecx, DWORD PTR _type$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegNewAtom
	add	esp, 8
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+28], eax
	jmp	SHORT $LN50@xmlFAParse
$LN49@xmlFAParse:

; 4974 : 	} else if (ctxt->atom->type == XML_REGEXP_RANGES) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	cmp	DWORD PTR [eax+4], 3
	jne	SHORT $LN50@xmlFAParse

; 4975 : 	    xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _type$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegAtomAddRange
	add	esp, 28					; 0000001cH
$LN50@xmlFAParse:

; 4976 : 			       type, 0, 0, NULL);
; 4977 : 	}
; 4978 :     } else {

	jmp	SHORT $LN1@xmlFAParse
$LN36@xmlFAParse:

; 4979 : 	ERROR("Wrong escape sequence, misuse of character '\\'");

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0CP@BDPLJNDH@Wrong?5escape?5sequence?0?5misuse?5o@
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegexpErrCompile
	add	esp, 8
$LN1@xmlFAParse:

; 4980 :     }
; 4981 : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@xmlFAParse:
	DD	$LN44@xmlFAParse
	DD	$LN46@xmlFAParse
	DD	$LN42@xmlFAParse
	DD	$LN40@xmlFAParse
	DD	$LN48@xmlFAParse
	DD	$LN43@xmlFAParse
	DD	$LN45@xmlFAParse
	DD	$LN41@xmlFAParse
	DD	$LN39@xmlFAParse
	DD	$LN47@xmlFAParse
	DD	$LN6@xmlFAParse
$LN53@xmlFAParse:
	DB	0
	DB	1
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	2
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	3
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	4
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	5
	DB	6
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	7
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	8
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	9
_xmlFAParseCharClassEsc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseCharProp
_TEXT	SEGMENT
_start$1 = -16						; size = 4
_blockName$ = -12					; size = 4
_type$ = -8						; size = 4
_cur$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlFAParseCharProp PROC				; COMDAT

; 4632 : xmlFAParseCharProp(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 4633 :     int cur;
; 4634 :     xmlRegAtomType type = (xmlRegAtomType) 0;

	mov	DWORD PTR _type$[ebp], 0

; 4635 :     xmlChar *blockName = NULL;

	mov	DWORD PTR _blockName$[ebp], 0

; 4636 : 
; 4637 :     cur = CUR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 4638 :     if (cur == 'L') {

	cmp	DWORD PTR _cur$[ebp], 76		; 0000004cH
	jne	$LN4@xmlFAParse

; 4639 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4640 : 	cur = CUR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 4641 : 	if (cur == 'u') {

	cmp	DWORD PTR _cur$[ebp], 117		; 00000075H
	jne	SHORT $LN6@xmlFAParse

; 4642 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4643 : 	    type = XML_REGEXP_LETTER_UPPERCASE;

	mov	DWORD PTR _type$[ebp], 101		; 00000065H
	jmp	SHORT $LN7@xmlFAParse
$LN6@xmlFAParse:

; 4644 : 	} else if (cur == 'l') {

	cmp	DWORD PTR _cur$[ebp], 108		; 0000006cH
	jne	SHORT $LN8@xmlFAParse

; 4645 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4646 : 	    type = XML_REGEXP_LETTER_LOWERCASE;

	mov	DWORD PTR _type$[ebp], 102		; 00000066H
	jmp	SHORT $LN7@xmlFAParse
$LN8@xmlFAParse:

; 4647 : 	} else if (cur == 't') {

	cmp	DWORD PTR _cur$[ebp], 116		; 00000074H
	jne	SHORT $LN10@xmlFAParse

; 4648 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4649 : 	    type = XML_REGEXP_LETTER_TITLECASE;

	mov	DWORD PTR _type$[ebp], 103		; 00000067H
	jmp	SHORT $LN7@xmlFAParse
$LN10@xmlFAParse:

; 4650 : 	} else if (cur == 'm') {

	cmp	DWORD PTR _cur$[ebp], 109		; 0000006dH
	jne	SHORT $LN12@xmlFAParse

; 4651 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4652 : 	    type = XML_REGEXP_LETTER_MODIFIER;

	mov	DWORD PTR _type$[ebp], 104		; 00000068H
	jmp	SHORT $LN7@xmlFAParse
$LN12@xmlFAParse:

; 4653 : 	} else if (cur == 'o') {

	cmp	DWORD PTR _cur$[ebp], 111		; 0000006fH
	jne	SHORT $LN14@xmlFAParse

; 4654 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4655 : 	    type = XML_REGEXP_LETTER_OTHERS;

	mov	DWORD PTR _type$[ebp], 105		; 00000069H

; 4656 : 	} else {

	jmp	SHORT $LN7@xmlFAParse
$LN14@xmlFAParse:

; 4657 : 	    type = XML_REGEXP_LETTER;

	mov	DWORD PTR _type$[ebp], 100		; 00000064H
$LN7@xmlFAParse:

; 4658 : 	}

	jmp	$LN5@xmlFAParse
$LN4@xmlFAParse:

; 4659 :     } else if (cur == 'M') {

	cmp	DWORD PTR _cur$[ebp], 77		; 0000004dH
	jne	$LN16@xmlFAParse

; 4660 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4661 : 	cur = CUR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 4662 : 	if (cur == 'n') {

	cmp	DWORD PTR _cur$[ebp], 110		; 0000006eH
	jne	SHORT $LN18@xmlFAParse

; 4663 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4664 : 	    /* nonspacing */
; 4665 : 	    type = XML_REGEXP_MARK_NONSPACING;

	mov	DWORD PTR _type$[ebp], 107		; 0000006bH
	jmp	SHORT $LN19@xmlFAParse
$LN18@xmlFAParse:

; 4666 : 	} else if (cur == 'c') {

	cmp	DWORD PTR _cur$[ebp], 99		; 00000063H
	jne	SHORT $LN20@xmlFAParse

; 4667 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4668 : 	    /* spacing combining */
; 4669 : 	    type = XML_REGEXP_MARK_SPACECOMBINING;

	mov	DWORD PTR _type$[ebp], 108		; 0000006cH
	jmp	SHORT $LN19@xmlFAParse
$LN20@xmlFAParse:

; 4670 : 	} else if (cur == 'e') {

	cmp	DWORD PTR _cur$[ebp], 101		; 00000065H
	jne	SHORT $LN22@xmlFAParse

; 4671 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4672 : 	    /* enclosing */
; 4673 : 	    type = XML_REGEXP_MARK_ENCLOSING;

	mov	DWORD PTR _type$[ebp], 109		; 0000006dH

; 4674 : 	} else {

	jmp	SHORT $LN19@xmlFAParse
$LN22@xmlFAParse:

; 4675 : 	    /* all marks */
; 4676 : 	    type = XML_REGEXP_MARK;

	mov	DWORD PTR _type$[ebp], 106		; 0000006aH
$LN19@xmlFAParse:

; 4677 : 	}

	jmp	$LN5@xmlFAParse
$LN16@xmlFAParse:

; 4678 :     } else if (cur == 'N') {

	cmp	DWORD PTR _cur$[ebp], 78		; 0000004eH
	jne	$LN24@xmlFAParse

; 4679 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4680 : 	cur = CUR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 4681 : 	if (cur == 'd') {

	cmp	DWORD PTR _cur$[ebp], 100		; 00000064H
	jne	SHORT $LN26@xmlFAParse

; 4682 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4683 : 	    /* digital */
; 4684 : 	    type = XML_REGEXP_NUMBER_DECIMAL;

	mov	DWORD PTR _type$[ebp], 111		; 0000006fH
	jmp	SHORT $LN27@xmlFAParse
$LN26@xmlFAParse:

; 4685 : 	} else if (cur == 'l') {

	cmp	DWORD PTR _cur$[ebp], 108		; 0000006cH
	jne	SHORT $LN28@xmlFAParse

; 4686 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4687 : 	    /* letter */
; 4688 : 	    type = XML_REGEXP_NUMBER_LETTER;

	mov	DWORD PTR _type$[ebp], 112		; 00000070H
	jmp	SHORT $LN27@xmlFAParse
$LN28@xmlFAParse:

; 4689 : 	} else if (cur == 'o') {

	cmp	DWORD PTR _cur$[ebp], 111		; 0000006fH
	jne	SHORT $LN30@xmlFAParse

; 4690 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4691 : 	    /* other */
; 4692 : 	    type = XML_REGEXP_NUMBER_OTHERS;

	mov	DWORD PTR _type$[ebp], 113		; 00000071H

; 4693 : 	} else {

	jmp	SHORT $LN27@xmlFAParse
$LN30@xmlFAParse:

; 4694 : 	    /* all numbers */
; 4695 : 	    type = XML_REGEXP_NUMBER;

	mov	DWORD PTR _type$[ebp], 110		; 0000006eH
$LN27@xmlFAParse:

; 4696 : 	}

	jmp	$LN5@xmlFAParse
$LN24@xmlFAParse:

; 4697 :     } else if (cur == 'P') {

	cmp	DWORD PTR _cur$[ebp], 80		; 00000050H
	jne	$LN32@xmlFAParse

; 4698 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4699 : 	cur = CUR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 4700 : 	if (cur == 'c') {

	cmp	DWORD PTR _cur$[ebp], 99		; 00000063H
	jne	SHORT $LN34@xmlFAParse

; 4701 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4702 : 	    /* connector */
; 4703 : 	    type = XML_REGEXP_PUNCT_CONNECTOR;

	mov	DWORD PTR _type$[ebp], 115		; 00000073H
	jmp	$LN35@xmlFAParse
$LN34@xmlFAParse:

; 4704 : 	} else if (cur == 'd') {

	cmp	DWORD PTR _cur$[ebp], 100		; 00000064H
	jne	SHORT $LN36@xmlFAParse

; 4705 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4706 : 	    /* dash */
; 4707 : 	    type = XML_REGEXP_PUNCT_DASH;

	mov	DWORD PTR _type$[ebp], 116		; 00000074H
	jmp	$LN35@xmlFAParse
$LN36@xmlFAParse:

; 4708 : 	} else if (cur == 's') {

	cmp	DWORD PTR _cur$[ebp], 115		; 00000073H
	jne	SHORT $LN38@xmlFAParse

; 4709 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4710 : 	    /* open */
; 4711 : 	    type = XML_REGEXP_PUNCT_OPEN;

	mov	DWORD PTR _type$[ebp], 117		; 00000075H
	jmp	SHORT $LN35@xmlFAParse
$LN38@xmlFAParse:

; 4712 : 	} else if (cur == 'e') {

	cmp	DWORD PTR _cur$[ebp], 101		; 00000065H
	jne	SHORT $LN40@xmlFAParse

; 4713 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4714 : 	    /* close */
; 4715 : 	    type = XML_REGEXP_PUNCT_CLOSE;

	mov	DWORD PTR _type$[ebp], 118		; 00000076H
	jmp	SHORT $LN35@xmlFAParse
$LN40@xmlFAParse:

; 4716 : 	} else if (cur == 'i') {

	cmp	DWORD PTR _cur$[ebp], 105		; 00000069H
	jne	SHORT $LN42@xmlFAParse

; 4717 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4718 : 	    /* initial quote */
; 4719 : 	    type = XML_REGEXP_PUNCT_INITQUOTE;

	mov	DWORD PTR _type$[ebp], 119		; 00000077H
	jmp	SHORT $LN35@xmlFAParse
$LN42@xmlFAParse:

; 4720 : 	} else if (cur == 'f') {

	cmp	DWORD PTR _cur$[ebp], 102		; 00000066H
	jne	SHORT $LN44@xmlFAParse

; 4721 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4722 : 	    /* final quote */
; 4723 : 	    type = XML_REGEXP_PUNCT_FINQUOTE;

	mov	DWORD PTR _type$[ebp], 120		; 00000078H
	jmp	SHORT $LN35@xmlFAParse
$LN44@xmlFAParse:

; 4724 : 	} else if (cur == 'o') {

	cmp	DWORD PTR _cur$[ebp], 111		; 0000006fH
	jne	SHORT $LN46@xmlFAParse

; 4725 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4726 : 	    /* other */
; 4727 : 	    type = XML_REGEXP_PUNCT_OTHERS;

	mov	DWORD PTR _type$[ebp], 121		; 00000079H

; 4728 : 	} else {

	jmp	SHORT $LN35@xmlFAParse
$LN46@xmlFAParse:

; 4729 : 	    /* all punctuation */
; 4730 : 	    type = XML_REGEXP_PUNCT;

	mov	DWORD PTR _type$[ebp], 114		; 00000072H
$LN35@xmlFAParse:

; 4731 : 	}

	jmp	$LN5@xmlFAParse
$LN32@xmlFAParse:

; 4732 :     } else if (cur == 'Z') {

	cmp	DWORD PTR _cur$[ebp], 90		; 0000005aH
	jne	$LN48@xmlFAParse

; 4733 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4734 : 	cur = CUR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 4735 : 	if (cur == 's') {

	cmp	DWORD PTR _cur$[ebp], 115		; 00000073H
	jne	SHORT $LN50@xmlFAParse

; 4736 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4737 : 	    /* space */
; 4738 : 	    type = XML_REGEXP_SEPAR_SPACE;

	mov	DWORD PTR _type$[ebp], 123		; 0000007bH
	jmp	SHORT $LN51@xmlFAParse
$LN50@xmlFAParse:

; 4739 : 	} else if (cur == 'l') {

	cmp	DWORD PTR _cur$[ebp], 108		; 0000006cH
	jne	SHORT $LN52@xmlFAParse

; 4740 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4741 : 	    /* line */
; 4742 : 	    type = XML_REGEXP_SEPAR_LINE;

	mov	DWORD PTR _type$[ebp], 124		; 0000007cH
	jmp	SHORT $LN51@xmlFAParse
$LN52@xmlFAParse:

; 4743 : 	} else if (cur == 'p') {

	cmp	DWORD PTR _cur$[ebp], 112		; 00000070H
	jne	SHORT $LN54@xmlFAParse

; 4744 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4745 : 	    /* paragraph */
; 4746 : 	    type = XML_REGEXP_SEPAR_PARA;

	mov	DWORD PTR _type$[ebp], 125		; 0000007dH

; 4747 : 	} else {

	jmp	SHORT $LN51@xmlFAParse
$LN54@xmlFAParse:

; 4748 : 	    /* all separators */
; 4749 : 	    type = XML_REGEXP_SEPAR;

	mov	DWORD PTR _type$[ebp], 122		; 0000007aH
$LN51@xmlFAParse:

; 4750 : 	}

	jmp	$LN5@xmlFAParse
$LN48@xmlFAParse:

; 4751 :     } else if (cur == 'S') {

	cmp	DWORD PTR _cur$[ebp], 83		; 00000053H
	jne	$LN56@xmlFAParse

; 4752 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4753 : 	cur = CUR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 4754 : 	if (cur == 'm') {

	cmp	DWORD PTR _cur$[ebp], 109		; 0000006dH
	jne	SHORT $LN58@xmlFAParse

; 4755 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4756 : 	    type = XML_REGEXP_SYMBOL_MATH;

	mov	DWORD PTR _type$[ebp], 127		; 0000007fH
	jmp	SHORT $LN59@xmlFAParse
$LN58@xmlFAParse:

; 4757 : 	    /* math */
; 4758 : 	} else if (cur == 'c') {

	cmp	DWORD PTR _cur$[ebp], 99		; 00000063H
	jne	SHORT $LN60@xmlFAParse

; 4759 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4760 : 	    type = XML_REGEXP_SYMBOL_CURRENCY;

	mov	DWORD PTR _type$[ebp], 128		; 00000080H
	jmp	SHORT $LN59@xmlFAParse
$LN60@xmlFAParse:

; 4761 : 	    /* currency */
; 4762 : 	} else if (cur == 'k') {

	cmp	DWORD PTR _cur$[ebp], 107		; 0000006bH
	jne	SHORT $LN62@xmlFAParse

; 4763 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4764 : 	    type = XML_REGEXP_SYMBOL_MODIFIER;

	mov	DWORD PTR _type$[ebp], 129		; 00000081H
	jmp	SHORT $LN59@xmlFAParse
$LN62@xmlFAParse:

; 4765 : 	    /* modifiers */
; 4766 : 	} else if (cur == 'o') {

	cmp	DWORD PTR _cur$[ebp], 111		; 0000006fH
	jne	SHORT $LN64@xmlFAParse

; 4767 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4768 : 	    type = XML_REGEXP_SYMBOL_OTHERS;

	mov	DWORD PTR _type$[ebp], 130		; 00000082H

; 4769 : 	    /* other */
; 4770 : 	} else {

	jmp	SHORT $LN59@xmlFAParse
$LN64@xmlFAParse:

; 4771 : 	    /* all symbols */
; 4772 : 	    type = XML_REGEXP_SYMBOL;

	mov	DWORD PTR _type$[ebp], 126		; 0000007eH
$LN59@xmlFAParse:

; 4773 : 	}

	jmp	$LN5@xmlFAParse
$LN56@xmlFAParse:

; 4774 :     } else if (cur == 'C') {

	cmp	DWORD PTR _cur$[ebp], 67		; 00000043H
	jne	$LN66@xmlFAParse

; 4775 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4776 : 	cur = CUR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 4777 : 	if (cur == 'c') {

	cmp	DWORD PTR _cur$[ebp], 99		; 00000063H
	jne	SHORT $LN68@xmlFAParse

; 4778 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4779 : 	    /* control */
; 4780 : 	    type = XML_REGEXP_OTHER_CONTROL;

	mov	DWORD PTR _type$[ebp], 132		; 00000084H
	jmp	SHORT $LN69@xmlFAParse
$LN68@xmlFAParse:

; 4781 : 	} else if (cur == 'f') {

	cmp	DWORD PTR _cur$[ebp], 102		; 00000066H
	jne	SHORT $LN70@xmlFAParse

; 4782 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4783 : 	    /* format */
; 4784 : 	    type = XML_REGEXP_OTHER_FORMAT;

	mov	DWORD PTR _type$[ebp], 133		; 00000085H
	jmp	SHORT $LN69@xmlFAParse
$LN70@xmlFAParse:

; 4785 : 	} else if (cur == 'o') {

	cmp	DWORD PTR _cur$[ebp], 111		; 0000006fH
	jne	SHORT $LN72@xmlFAParse

; 4786 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4787 : 	    /* private use */
; 4788 : 	    type = XML_REGEXP_OTHER_PRIVATE;

	mov	DWORD PTR _type$[ebp], 134		; 00000086H
	jmp	SHORT $LN69@xmlFAParse
$LN72@xmlFAParse:

; 4789 : 	} else if (cur == 'n') {

	cmp	DWORD PTR _cur$[ebp], 110		; 0000006eH
	jne	SHORT $LN74@xmlFAParse

; 4790 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4791 : 	    /* not assigned */
; 4792 : 	    type = XML_REGEXP_OTHER_NA;

	mov	DWORD PTR _type$[ebp], 135		; 00000087H

; 4793 : 	} else {

	jmp	SHORT $LN69@xmlFAParse
$LN74@xmlFAParse:

; 4794 : 	    /* all others */
; 4795 : 	    type = XML_REGEXP_OTHER;

	mov	DWORD PTR _type$[ebp], 131		; 00000083H
$LN69@xmlFAParse:

; 4796 : 	}

	jmp	$LN5@xmlFAParse
$LN66@xmlFAParse:

; 4797 :     } else if (cur == 'I') {

	cmp	DWORD PTR _cur$[ebp], 73		; 00000049H
	jne	$LN76@xmlFAParse

; 4798 : 	const xmlChar *start;
; 4799 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4800 : 	cur = CUR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 4801 : 	if (cur != 's') {

	cmp	DWORD PTR _cur$[ebp], 115		; 00000073H
	je	SHORT $LN78@xmlFAParse

; 4802 : 	    ERROR("IsXXXX expected");

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0BA@KPLOEDJN@IsXXXX?5expected@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegexpErrCompile
	add	esp, 8

; 4803 : 	    return;

	jmp	$LN1@xmlFAParse
$LN78@xmlFAParse:

; 4804 : 	}
; 4805 : 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 4806 : 	start = ctxt->cur;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _start$1[ebp], eax

; 4807 : 	cur = CUR;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _cur$[ebp], eax

; 4808 : 	if (((cur >= 'a') && (cur <= 'z')) ||
; 4809 : 	    ((cur >= 'A') && (cur <= 'Z')) ||
; 4810 : 	    ((cur >= '0') && (cur <= '9')) ||

	cmp	DWORD PTR _cur$[ebp], 97		; 00000061H
	jl	SHORT $LN81@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 122		; 0000007aH
	jle	SHORT $LN80@xmlFAParse
$LN81@xmlFAParse:
	cmp	DWORD PTR _cur$[ebp], 65		; 00000041H
	jl	SHORT $LN82@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 90		; 0000005aH
	jle	SHORT $LN80@xmlFAParse
$LN82@xmlFAParse:
	cmp	DWORD PTR _cur$[ebp], 48		; 00000030H
	jl	SHORT $LN83@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 57		; 00000039H
	jle	SHORT $LN80@xmlFAParse
$LN83@xmlFAParse:
	cmp	DWORD PTR _cur$[ebp], 45		; 0000002dH
	jne	SHORT $LN79@xmlFAParse
$LN80@xmlFAParse:

; 4811 : 	    (cur == 0x2D)) {
; 4812 : 	    NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+4], edx

; 4813 : 	    cur = CUR;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _cur$[ebp], eax
$LN2@xmlFAParse:

; 4814 : 	    while (((cur >= 'a') && (cur <= 'z')) ||
; 4815 : 		((cur >= 'A') && (cur <= 'Z')) ||
; 4816 : 		((cur >= '0') && (cur <= '9')) ||

	cmp	DWORD PTR _cur$[ebp], 97		; 00000061H
	jl	SHORT $LN85@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 122		; 0000007aH
	jle	SHORT $LN84@xmlFAParse
$LN85@xmlFAParse:
	cmp	DWORD PTR _cur$[ebp], 65		; 00000041H
	jl	SHORT $LN86@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 90		; 0000005aH
	jle	SHORT $LN84@xmlFAParse
$LN86@xmlFAParse:
	cmp	DWORD PTR _cur$[ebp], 48		; 00000030H
	jl	SHORT $LN87@xmlFAParse
	cmp	DWORD PTR _cur$[ebp], 57		; 00000039H
	jle	SHORT $LN84@xmlFAParse
$LN87@xmlFAParse:
	cmp	DWORD PTR _cur$[ebp], 45		; 0000002dH
	jne	SHORT $LN79@xmlFAParse
$LN84@xmlFAParse:

; 4817 : 		(cur == 0x2D)) {
; 4818 : 		NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+4], edx

; 4819 : 		cur = CUR;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _cur$[ebp], eax

; 4820 : 	    }

	jmp	SHORT $LN2@xmlFAParse
$LN79@xmlFAParse:

; 4821 : 	}
; 4822 : 	type = XML_REGEXP_BLOCK_NAME;

	mov	DWORD PTR _type$[ebp], 136		; 00000088H

; 4823 : 	blockName = xmlStrndup(start, ctxt->cur - start);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, DWORD PTR _start$1[ebp]
	push	edx
	mov	eax, DWORD PTR _start$1[ebp]
	push	eax
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR _blockName$[ebp], eax

; 4824 :     } else {

	jmp	SHORT $LN5@xmlFAParse
$LN76@xmlFAParse:

; 4825 : 	ERROR("Unknown char property");

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0BG@ECFAFFBF@Unknown?5char?5property@
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegexpErrCompile
	add	esp, 8

; 4826 : 	return;

	jmp	SHORT $LN1@xmlFAParse
$LN5@xmlFAParse:

; 4827 :     }
; 4828 :     if (ctxt->atom == NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN88@xmlFAParse

; 4829 : 	ctxt->atom = xmlRegNewAtom(ctxt, type);

	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegNewAtom
	add	esp, 8
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 4830 : 	if (ctxt->atom != NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN90@xmlFAParse

; 4831 : 	    ctxt->atom->valuep = blockName;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _blockName$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN90@xmlFAParse:

; 4832 :     } else if (ctxt->atom->type == XML_REGEXP_RANGES) {

	jmp	SHORT $LN1@xmlFAParse
$LN88@xmlFAParse:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx+4], 3
	jne	SHORT $LN1@xmlFAParse

; 4833 :         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,

	mov	edx, DWORD PTR _blockName$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegAtomAddRange
	add	esp, 28					; 0000001cH
$LN1@xmlFAParse:

; 4834 : 		           type, 0, 0, blockName);
; 4835 :     }
; 4836 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFAParseCharProp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAIsChar
_TEXT	SEGMENT
_len$ = -12						; size = 4
_cur$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlFAIsChar PROC					; COMDAT

; 4602 : xmlFAIsChar(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 4603 :     int cur;
; 4604 :     int len;
; 4605 : 
; 4606 :     cur = CUR_SCHAR(ctxt->cur, len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cur$[ebp], eax

; 4607 :     if ((cur == '.') || (cur == '\\') || (cur == '?') ||
; 4608 : 	(cur == '*') || (cur == '+') || (cur == '(') ||
; 4609 : 	(cur == ')') || (cur == '|') || (cur == 0x5B) ||
; 4610 : 	(cur == 0x5D) || (cur == 0))

	cmp	DWORD PTR _cur$[ebp], 46		; 0000002eH
	je	SHORT $LN3@xmlFAIsCha
	cmp	DWORD PTR _cur$[ebp], 92		; 0000005cH
	je	SHORT $LN3@xmlFAIsCha
	cmp	DWORD PTR _cur$[ebp], 63		; 0000003fH
	je	SHORT $LN3@xmlFAIsCha
	cmp	DWORD PTR _cur$[ebp], 42		; 0000002aH
	je	SHORT $LN3@xmlFAIsCha
	cmp	DWORD PTR _cur$[ebp], 43		; 0000002bH
	je	SHORT $LN3@xmlFAIsCha
	cmp	DWORD PTR _cur$[ebp], 40		; 00000028H
	je	SHORT $LN3@xmlFAIsCha
	cmp	DWORD PTR _cur$[ebp], 41		; 00000029H
	je	SHORT $LN3@xmlFAIsCha
	cmp	DWORD PTR _cur$[ebp], 124		; 0000007cH
	je	SHORT $LN3@xmlFAIsCha
	cmp	DWORD PTR _cur$[ebp], 91		; 0000005bH
	je	SHORT $LN3@xmlFAIsCha
	cmp	DWORD PTR _cur$[ebp], 93		; 0000005dH
	je	SHORT $LN3@xmlFAIsCha
	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlFAIsCha
$LN3@xmlFAIsCha:

; 4611 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlFAIsCha
$LN2@xmlFAIsCha:

; 4612 :     return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
$LN1@xmlFAIsCha:

; 4613 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@xmlFAIsCha
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@xmlFAIsCha:
	DD	1
	DD	$LN6@xmlFAIsCha
$LN6@xmlFAIsCha:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN5@xmlFAIsCha
$LN5@xmlFAIsCha:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
_xmlFAIsChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegExecGetValues
_TEXT	SEGMENT
_count$1 = -48						; size = 4
_counter$2 = -44					; size = 4
_state$3 = -40						; size = 4
_atom$4 = -36						; size = 4
_trans$5 = -32						; size = 4
_transno$6 = -28					; size = 4
_state$7 = -24						; size = 4
_i$8 = -20						; size = 4
_target$9 = -16						; size = 4
_comp$10 = -12						; size = 4
_nb$ = -8						; size = 4
_maxval$ = -4						; size = 4
_exec$ = 8						; size = 4
_err$ = 12						; size = 4
_nbval$ = 16						; size = 4
_nbneg$ = 20						; size = 4
_values$ = 24						; size = 4
_terminal$ = 28						; size = 4
_xmlRegExecGetValues PROC				; COMDAT

; 4221 : 		    xmlChar **values, int *terminal) {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 4222 :     int maxval;
; 4223 :     int nb = 0;

	mov	DWORD PTR _nb$[ebp], 0

; 4224 : 
; 4225 :     if ((exec == NULL) || (nbval == NULL) || (nbneg == NULL) ||
; 4226 :         (values == NULL) || (*nbval <= 0))

	cmp	DWORD PTR _exec$[ebp], 0
	je	SHORT $LN15@xmlRegExec
	cmp	DWORD PTR _nbval$[ebp], 0
	je	SHORT $LN15@xmlRegExec
	cmp	DWORD PTR _nbneg$[ebp], 0
	je	SHORT $LN15@xmlRegExec
	cmp	DWORD PTR _values$[ebp], 0
	je	SHORT $LN15@xmlRegExec
	mov	eax, DWORD PTR _nbval$[ebp]
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN14@xmlRegExec
$LN15@xmlRegExec:

; 4227 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlRegExec
$LN14@xmlRegExec:

; 4228 : 
; 4229 :     maxval = *nbval;

	mov	ecx, DWORD PTR _nbval$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _maxval$[ebp], edx

; 4230 :     *nbval = 0;

	mov	eax, DWORD PTR _nbval$[ebp]
	mov	DWORD PTR [eax], 0

; 4231 :     *nbneg = 0;

	mov	ecx, DWORD PTR _nbneg$[ebp]
	mov	DWORD PTR [ecx], 0

; 4232 :     if ((exec->comp != NULL) && (exec->comp->compact != NULL)) {

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	$LN16@xmlRegExec
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+40], 0
	je	$LN16@xmlRegExec

; 4233 :         xmlRegexpPtr comp;
; 4234 : 	int target, i, state;
; 4235 : 
; 4236 :         comp = exec->comp;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _comp$10[ebp], eax

; 4237 : 
; 4238 : 	if (err) {

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN18@xmlRegExec

; 4239 : 	    if (exec->errStateNo == -1) return(-1);

	mov	ecx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [ecx+72], -1
	jne	SHORT $LN20@xmlRegExec
	or	eax, -1
	jmp	$LN1@xmlRegExec
$LN20@xmlRegExec:

; 4240 : 	    state = exec->errStateNo;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR _state$7[ebp], eax

; 4241 : 	} else {

	jmp	SHORT $LN19@xmlRegExec
$LN18@xmlRegExec:

; 4242 : 	    state = exec->index;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR _state$7[ebp], edx
$LN19@xmlRegExec:

; 4243 : 	}
; 4244 : 	if (terminal != NULL) {

	cmp	DWORD PTR _terminal$[ebp], 0
	je	SHORT $LN21@xmlRegExec

; 4245 : 	    if (comp->compact[state * (comp->nbstrings + 1)] ==

	mov	eax, DWORD PTR _comp$10[ebp]
	mov	ecx, DWORD PTR [eax+48]
	add	ecx, 1
	imul	ecx, DWORD PTR _state$7[ebp]
	mov	edx, DWORD PTR _comp$10[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx*4], 2
	jne	SHORT $LN22@xmlRegExec

; 4246 : 	        XML_REGEXP_FINAL_STATE)
; 4247 : 		*terminal = 1;

	mov	ecx, DWORD PTR _terminal$[ebp]
	mov	DWORD PTR [ecx], 1
	jmp	SHORT $LN21@xmlRegExec
$LN22@xmlRegExec:

; 4248 : 	    else
; 4249 : 		*terminal = 0;

	mov	edx, DWORD PTR _terminal$[ebp]
	mov	DWORD PTR [edx], 0
$LN21@xmlRegExec:

; 4250 : 	}
; 4251 : 	for (i = 0;(i < comp->nbstrings) && (nb < maxval);i++) {

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN4@xmlRegExec
$LN2@xmlRegExec:
	mov	eax, DWORD PTR _i$8[ebp]
	add	eax, 1
	mov	DWORD PTR _i$8[ebp], eax
$LN4@xmlRegExec:
	mov	ecx, DWORD PTR _comp$10[ebp]
	mov	edx, DWORD PTR _i$8[ebp]
	cmp	edx, DWORD PTR [ecx+48]
	jge	$LN3@xmlRegExec
	mov	eax, DWORD PTR _nb$[ebp]
	cmp	eax, DWORD PTR _maxval$[ebp]
	jge	SHORT $LN3@xmlRegExec

; 4252 : 	    target = comp->compact[state * (comp->nbstrings + 1) + i + 1];

	mov	ecx, DWORD PTR _comp$10[ebp]
	mov	edx, DWORD PTR [ecx+48]
	add	edx, 1
	imul	edx, DWORD PTR _state$7[ebp]
	add	edx, DWORD PTR _i$8[ebp]
	mov	eax, DWORD PTR _comp$10[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+edx*4+4]
	mov	DWORD PTR _target$9[ebp], edx

; 4253 : 	    if ((target > 0) && (target <= comp->nbstates) &&

	cmp	DWORD PTR _target$9[ebp], 0
	jle	SHORT $LN24@xmlRegExec
	mov	eax, DWORD PTR _comp$10[ebp]
	mov	ecx, DWORD PTR _target$9[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jg	SHORT $LN24@xmlRegExec
	mov	edx, DWORD PTR _target$9[ebp]
	sub	edx, 1
	mov	eax, DWORD PTR _comp$10[ebp]
	mov	ecx, DWORD PTR [eax+48]
	add	ecx, 1
	imul	edx, ecx
	mov	eax, DWORD PTR _comp$10[ebp]
	mov	ecx, DWORD PTR [eax+40]
	cmp	DWORD PTR [ecx+edx*4], 4
	je	SHORT $LN24@xmlRegExec

; 4254 : 	        (comp->compact[(target - 1) * (comp->nbstrings + 1)] !=
; 4255 : 		 XML_REGEXP_SINK_STATE)) {
; 4256 : 	        values[nb++] = comp->stringMap[i];

	mov	edx, DWORD PTR _comp$10[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _nb$[ebp]
	mov	edx, DWORD PTR _values$[ebp]
	mov	esi, DWORD PTR _i$8[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _nb$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nb$[ebp], ecx

; 4257 : 		(*nbval)++;

	mov	edx, DWORD PTR _nbval$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _nbval$[ebp]
	mov	DWORD PTR [ecx], eax
$LN24@xmlRegExec:

; 4258 : 	    }
; 4259 : 	}

	jmp	$LN2@xmlRegExec
$LN3@xmlRegExec:

; 4260 : 	for (i = 0;(i < comp->nbstrings) && (nb < maxval);i++) {

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN7@xmlRegExec
$LN5@xmlRegExec:
	mov	edx, DWORD PTR _i$8[ebp]
	add	edx, 1
	mov	DWORD PTR _i$8[ebp], edx
$LN7@xmlRegExec:
	mov	eax, DWORD PTR _comp$10[ebp]
	mov	ecx, DWORD PTR _i$8[ebp]
	cmp	ecx, DWORD PTR [eax+48]
	jge	$LN6@xmlRegExec
	mov	edx, DWORD PTR _nb$[ebp]
	cmp	edx, DWORD PTR _maxval$[ebp]
	jge	SHORT $LN6@xmlRegExec

; 4261 : 	    target = comp->compact[state * (comp->nbstrings + 1) + i + 1];

	mov	eax, DWORD PTR _comp$10[ebp]
	mov	ecx, DWORD PTR [eax+48]
	add	ecx, 1
	imul	ecx, DWORD PTR _state$7[ebp]
	add	ecx, DWORD PTR _i$8[ebp]
	mov	edx, DWORD PTR _comp$10[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+ecx*4+4]
	mov	DWORD PTR _target$9[ebp], ecx

; 4262 : 	    if ((target > 0) && (target <= comp->nbstates) &&

	cmp	DWORD PTR _target$9[ebp], 0
	jle	SHORT $LN25@xmlRegExec
	mov	edx, DWORD PTR _comp$10[ebp]
	mov	eax, DWORD PTR _target$9[ebp]
	cmp	eax, DWORD PTR [edx+36]
	jg	SHORT $LN25@xmlRegExec
	mov	ecx, DWORD PTR _target$9[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _comp$10[ebp]
	mov	eax, DWORD PTR [edx+48]
	add	eax, 1
	imul	ecx, eax
	mov	edx, DWORD PTR _comp$10[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx*4], 4
	jne	SHORT $LN25@xmlRegExec

; 4263 : 	        (comp->compact[(target - 1) * (comp->nbstrings + 1)] ==
; 4264 : 		 XML_REGEXP_SINK_STATE)) {
; 4265 : 	        values[nb++] = comp->stringMap[i];

	mov	ecx, DWORD PTR _comp$10[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _nb$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	mov	esi, DWORD PTR _i$8[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _nb$[ebp]
	add	eax, 1
	mov	DWORD PTR _nb$[ebp], eax

; 4266 : 		(*nbneg)++;

	mov	ecx, DWORD PTR _nbneg$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _nbneg$[ebp]
	mov	DWORD PTR [eax], edx
$LN25@xmlRegExec:

; 4267 : 	    }
; 4268 : 	}

	jmp	$LN5@xmlRegExec
$LN6@xmlRegExec:

; 4269 :     } else {

	jmp	$LN17@xmlRegExec
$LN16@xmlRegExec:

; 4270 :         int transno;
; 4271 : 	xmlRegTransPtr trans;
; 4272 : 	xmlRegAtomPtr atom;
; 4273 : 	xmlRegStatePtr state;
; 4274 : 
; 4275 : 	if (terminal != NULL) {

	cmp	DWORD PTR _terminal$[ebp], 0
	je	SHORT $LN26@xmlRegExec

; 4276 : 	    if (exec->state->type == XML_REGEXP_FINAL_STATE)

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	DWORD PTR [edx], 2
	jne	SHORT $LN27@xmlRegExec

; 4277 : 		*terminal = 1;

	mov	eax, DWORD PTR _terminal$[ebp]
	mov	DWORD PTR [eax], 1
	jmp	SHORT $LN26@xmlRegExec
$LN27@xmlRegExec:

; 4278 : 	    else
; 4279 : 		*terminal = 0;

	mov	ecx, DWORD PTR _terminal$[ebp]
	mov	DWORD PTR [ecx], 0
$LN26@xmlRegExec:

; 4280 : 	}
; 4281 : 
; 4282 : 	if (err) {

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN29@xmlRegExec

; 4283 : 	    if (exec->errState == NULL) return(-1);

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+76], 0
	jne	SHORT $LN31@xmlRegExec
	or	eax, -1
	jmp	$LN1@xmlRegExec
$LN31@xmlRegExec:

; 4284 : 	    state = exec->errState;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR _state$3[ebp], ecx

; 4285 : 	} else {

	jmp	SHORT $LN30@xmlRegExec
$LN29@xmlRegExec:

; 4286 : 	    if (exec->state == NULL) return(-1);

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN32@xmlRegExec
	or	eax, -1
	jmp	$LN1@xmlRegExec
$LN32@xmlRegExec:

; 4287 : 	    state = exec->state;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _state$3[ebp], ecx
$LN30@xmlRegExec:

; 4288 : 	}
; 4289 : 	for (transno = 0;

	mov	DWORD PTR _transno$6[ebp], 0
	jmp	SHORT $LN10@xmlRegExec
$LN8@xmlRegExec:

; 4291 : 	     transno++) {

	mov	edx, DWORD PTR _transno$6[ebp]
	add	edx, 1
	mov	DWORD PTR _transno$6[ebp], edx
$LN10@xmlRegExec:

; 4290 : 	     (transno < state->nbTrans) && (nb < maxval);

	mov	eax, DWORD PTR _state$3[ebp]
	mov	ecx, DWORD PTR _transno$6[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	$LN9@xmlRegExec
	mov	edx, DWORD PTR _nb$[ebp]
	cmp	edx, DWORD PTR _maxval$[ebp]
	jge	$LN9@xmlRegExec

; 4292 : 	    trans = &state->trans[transno];

	imul	eax, DWORD PTR _transno$6[ebp], 20
	mov	ecx, DWORD PTR _state$3[ebp]
	add	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _trans$5[ebp], eax

; 4293 : 	    if (trans->to < 0)

	mov	edx, DWORD PTR _trans$5[ebp]
	cmp	DWORD PTR [edx+4], 0
	jge	SHORT $LN33@xmlRegExec

; 4294 : 		continue;

	jmp	SHORT $LN8@xmlRegExec
$LN33@xmlRegExec:

; 4295 : 	    atom = trans->atom;

	mov	eax, DWORD PTR _trans$5[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _atom$4[ebp], ecx

; 4296 : 	    if ((atom == NULL) || (atom->valuep == NULL))

	cmp	DWORD PTR _atom$4[ebp], 0
	je	SHORT $LN35@xmlRegExec
	mov	edx, DWORD PTR _atom$4[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN34@xmlRegExec
$LN35@xmlRegExec:

; 4297 : 		continue;

	jmp	SHORT $LN8@xmlRegExec
$LN34@xmlRegExec:

; 4298 : 	    if (trans->count == REGEXP_ALL_LAX_COUNTER) {

	mov	eax, DWORD PTR _trans$5[ebp]
	cmp	DWORD PTR [eax+12], 1193047		; 00123457H
	jne	SHORT $LN36@xmlRegExec

; 4299 : 	        /* this should not be reached but ... */
; 4300 : 	        TODO;

	mov	esi, esp
	push	4300					; 000010ccH
	push	OFFSET ??_C@_0GL@GCGJPEPF@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN37@xmlRegExec
$LN36@xmlRegExec:

; 4301 : 	    } else if (trans->count == REGEXP_ALL_COUNTER) {

	mov	eax, DWORD PTR _trans$5[ebp]
	cmp	DWORD PTR [eax+12], 1193046		; 00123456H
	jne	SHORT $LN38@xmlRegExec

; 4302 : 	        /* this should not be reached but ... */
; 4303 : 	        TODO;

	mov	esi, esp
	push	4303					; 000010cfH
	push	OFFSET ??_C@_0GL@GCGJPEPF@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN37@xmlRegExec
$LN38@xmlRegExec:

; 4304 : 	    } else if (trans->counter >= 0) {

	mov	eax, DWORD PTR _trans$5[ebp]
	cmp	DWORD PTR [eax+8], 0
	jl	$LN40@xmlRegExec

; 4305 : 		xmlRegCounterPtr counter = NULL;

	mov	DWORD PTR _counter$2[ebp], 0

; 4306 : 		int count;
; 4307 : 
; 4308 : 		if (err)

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN42@xmlRegExec

; 4309 : 		    count = exec->errCounts[trans->counter];

	mov	ecx, DWORD PTR _trans$5[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _count$1[ebp], edx
	jmp	SHORT $LN43@xmlRegExec
$LN42@xmlRegExec:

; 4310 : 		else
; 4311 : 		    count = exec->counts[trans->counter];

	mov	eax, DWORD PTR _trans$5[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _count$1[ebp], ecx
$LN43@xmlRegExec:

; 4312 : 		if (exec->comp != NULL)

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN44@xmlRegExec

; 4313 : 		    counter = &exec->comp->counters[trans->counter];

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _trans$5[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [ecx+24]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _counter$2[ebp], edx
$LN44@xmlRegExec:

; 4314 : 		if ((counter == NULL) || (count < counter->max)) {

	cmp	DWORD PTR _counter$2[ebp], 0
	je	SHORT $LN46@xmlRegExec
	mov	eax, DWORD PTR _counter$2[ebp]
	mov	ecx, DWORD PTR _count$1[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN45@xmlRegExec
$LN46@xmlRegExec:

; 4315 : 		    if (atom->neg)

	mov	edx, DWORD PTR _atom$4[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN47@xmlRegExec

; 4316 : 			values[nb++] = (xmlChar *) atom->valuep2;

	mov	eax, DWORD PTR _nb$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	mov	edx, DWORD PTR _atom$4[ebp]
	mov	edx, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _nb$[ebp]
	add	eax, 1
	mov	DWORD PTR _nb$[ebp], eax
	jmp	SHORT $LN48@xmlRegExec
$LN47@xmlRegExec:

; 4317 : 		    else
; 4318 : 			values[nb++] = (xmlChar *) atom->valuep;

	mov	ecx, DWORD PTR _nb$[ebp]
	mov	edx, DWORD PTR _values$[ebp]
	mov	eax, DWORD PTR _atom$4[ebp]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _nb$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nb$[ebp], ecx
$LN48@xmlRegExec:

; 4319 : 		    (*nbval)++;

	mov	edx, DWORD PTR _nbval$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _nbval$[ebp]
	mov	DWORD PTR [ecx], eax
$LN45@xmlRegExec:

; 4320 : 		}
; 4321 : 	    } else {

	jmp	SHORT $LN37@xmlRegExec
$LN40@xmlRegExec:

; 4322 :                 if ((exec->comp != NULL) && (exec->comp->states[trans->to] != NULL) &&

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN37@xmlRegExec
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _trans$5[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN37@xmlRegExec
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _trans$5[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+edx*4]
	cmp	DWORD PTR [ecx], 4
	je	SHORT $LN37@xmlRegExec

; 4323 : 		    (exec->comp->states[trans->to]->type !=
; 4324 : 		     XML_REGEXP_SINK_STATE)) {
; 4325 : 		    if (atom->neg)

	mov	edx, DWORD PTR _atom$4[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN50@xmlRegExec

; 4326 : 			values[nb++] = (xmlChar *) atom->valuep2;

	mov	eax, DWORD PTR _nb$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	mov	edx, DWORD PTR _atom$4[ebp]
	mov	edx, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _nb$[ebp]
	add	eax, 1
	mov	DWORD PTR _nb$[ebp], eax
	jmp	SHORT $LN51@xmlRegExec
$LN50@xmlRegExec:

; 4327 : 		    else
; 4328 : 			values[nb++] = (xmlChar *) atom->valuep;

	mov	ecx, DWORD PTR _nb$[ebp]
	mov	edx, DWORD PTR _values$[ebp]
	mov	eax, DWORD PTR _atom$4[ebp]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _nb$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nb$[ebp], ecx
$LN51@xmlRegExec:

; 4329 : 		    (*nbval)++;

	mov	edx, DWORD PTR _nbval$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _nbval$[ebp]
	mov	DWORD PTR [ecx], eax
$LN37@xmlRegExec:

; 4330 : 		}
; 4331 : 	    }
; 4332 : 	}

	jmp	$LN8@xmlRegExec
$LN9@xmlRegExec:

; 4333 : 	for (transno = 0;

	mov	DWORD PTR _transno$6[ebp], 0
	jmp	SHORT $LN13@xmlRegExec
$LN11@xmlRegExec:

; 4335 : 	     transno++) {

	mov	edx, DWORD PTR _transno$6[ebp]
	add	edx, 1
	mov	DWORD PTR _transno$6[ebp], edx
$LN13@xmlRegExec:

; 4334 : 	     (transno < state->nbTrans) && (nb < maxval);

	mov	eax, DWORD PTR _state$3[ebp]
	mov	ecx, DWORD PTR _transno$6[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	$LN17@xmlRegExec
	mov	edx, DWORD PTR _nb$[ebp]
	cmp	edx, DWORD PTR _maxval$[ebp]
	jge	$LN17@xmlRegExec

; 4336 : 	    trans = &state->trans[transno];

	imul	eax, DWORD PTR _transno$6[ebp], 20
	mov	ecx, DWORD PTR _state$3[ebp]
	add	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _trans$5[ebp], eax

; 4337 : 	    if (trans->to < 0)

	mov	edx, DWORD PTR _trans$5[ebp]
	cmp	DWORD PTR [edx+4], 0
	jge	SHORT $LN52@xmlRegExec

; 4338 : 		continue;

	jmp	SHORT $LN11@xmlRegExec
$LN52@xmlRegExec:

; 4339 : 	    atom = trans->atom;

	mov	eax, DWORD PTR _trans$5[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _atom$4[ebp], ecx

; 4340 : 	    if ((atom == NULL) || (atom->valuep == NULL))

	cmp	DWORD PTR _atom$4[ebp], 0
	je	SHORT $LN54@xmlRegExec
	mov	edx, DWORD PTR _atom$4[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN53@xmlRegExec
$LN54@xmlRegExec:

; 4341 : 		continue;

	jmp	SHORT $LN11@xmlRegExec
$LN53@xmlRegExec:

; 4342 : 	    if (trans->count == REGEXP_ALL_LAX_COUNTER) {

	mov	eax, DWORD PTR _trans$5[ebp]
	cmp	DWORD PTR [eax+12], 1193047		; 00123457H
	jne	SHORT $LN55@xmlRegExec

; 4343 : 	        continue;

	jmp	SHORT $LN11@xmlRegExec
	jmp	$LN56@xmlRegExec
$LN55@xmlRegExec:

; 4344 : 	    } else if (trans->count == REGEXP_ALL_COUNTER) {

	mov	ecx, DWORD PTR _trans$5[ebp]
	cmp	DWORD PTR [ecx+12], 1193046		; 00123456H
	jne	SHORT $LN57@xmlRegExec

; 4345 : 	        continue;

	jmp	SHORT $LN11@xmlRegExec
	jmp	$LN56@xmlRegExec
$LN57@xmlRegExec:

; 4346 : 	    } else if (trans->counter >= 0) {

	mov	edx, DWORD PTR _trans$5[ebp]
	cmp	DWORD PTR [edx+8], 0
	jl	SHORT $LN59@xmlRegExec

; 4347 : 	        continue;

	jmp	$LN11@xmlRegExec

; 4348 : 	    } else {

	jmp	SHORT $LN56@xmlRegExec
$LN59@xmlRegExec:

; 4349 :                 if ((exec->comp->states[trans->to] != NULL) &&

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _trans$5[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN56@xmlRegExec
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _trans$5[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+edx*4]
	cmp	DWORD PTR [ecx], 4
	jne	SHORT $LN56@xmlRegExec

; 4350 : 		    (exec->comp->states[trans->to]->type ==
; 4351 : 		     XML_REGEXP_SINK_STATE)) {
; 4352 : 		    if (atom->neg)

	mov	edx, DWORD PTR _atom$4[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN62@xmlRegExec

; 4353 : 			values[nb++] = (xmlChar *) atom->valuep2;

	mov	eax, DWORD PTR _nb$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	mov	edx, DWORD PTR _atom$4[ebp]
	mov	edx, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _nb$[ebp]
	add	eax, 1
	mov	DWORD PTR _nb$[ebp], eax
	jmp	SHORT $LN63@xmlRegExec
$LN62@xmlRegExec:

; 4354 : 		    else
; 4355 : 			values[nb++] = (xmlChar *) atom->valuep;

	mov	ecx, DWORD PTR _nb$[ebp]
	mov	edx, DWORD PTR _values$[ebp]
	mov	eax, DWORD PTR _atom$4[ebp]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _nb$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nb$[ebp], ecx
$LN63@xmlRegExec:

; 4356 : 		    (*nbneg)++;

	mov	edx, DWORD PTR _nbneg$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _nbneg$[ebp]
	mov	DWORD PTR [ecx], eax
$LN56@xmlRegExec:

; 4357 : 		}
; 4358 : 	    }
; 4359 : 	}

	jmp	$LN11@xmlRegExec
$LN17@xmlRegExec:

; 4360 :     }
; 4361 :     return(0);

	xor	eax, eax
$LN1@xmlRegExec:

; 4362 : }

	pop	edi
	pop	esi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegExecGetValues ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegExecPushStringInternal
_TEXT	SEGMENT
tv509 = -92						; size = 4
tv261 = -88						; size = 4
tv246 = -84						; size = 4
_state$1 = -80						; size = 4
_transno$2 = -76					; size = 4
_to$3 = -72						; size = 4
_count$4 = -68						; size = 4
_counter$5 = -64					; size = 4
_counter$6 = -60					; size = 4
_count$7 = -56						; size = 4
_counter$8 = -52					; size = 4
_t$9 = -48						; size = 4
_count$10 = -44						; size = 4
_i$11 = -40						; size = 4
_counter$12 = -36					; size = 4
_t$13 = -32						; size = 4
_count$14 = -28						; size = 4
_i$15 = -24						; size = 4
_progress$ = -20					; size = 4
_final$ = -16						; size = 4
_ret$ = -12						; size = 4
_atom$ = -8						; size = 4
_trans$ = -4						; size = 4
_exec$ = 8						; size = 4
_value$ = 12						; size = 4
_data$ = 16						; size = 4
_compound$ = 20						; size = 4
_xmlRegExecPushStringInternal PROC			; COMDAT

; 3784 : 	                     void *data, int compound) {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-92]
	mov	ecx, 23					; 00000017H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 3785 :     xmlRegTransPtr trans;
; 3786 :     xmlRegAtomPtr atom;
; 3787 :     int ret;
; 3788 :     int final = 0;

	mov	DWORD PTR _final$[ebp], 0

; 3789 :     int progress = 1;

	mov	DWORD PTR _progress$[ebp], 1

; 3790 : 
; 3791 :     if (exec == NULL)

	cmp	DWORD PTR _exec$[ebp], 0
	jne	SHORT $LN16@xmlRegExec

; 3792 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlRegExec
$LN16@xmlRegExec:

; 3793 :     if (exec->comp == NULL)

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN17@xmlRegExec

; 3794 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlRegExec
$LN17@xmlRegExec:

; 3795 :     if (exec->status != 0)

	mov	ecx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN18@xmlRegExec

; 3796 : 	return(exec->status);

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	$LN1@xmlRegExec
$LN18@xmlRegExec:

; 3797 : 
; 3798 :     if (exec->comp->compact != NULL)

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN19@xmlRegExec

; 3799 : 	return(xmlRegCompactPushString(exec, exec->comp, value, data));

	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _exec$[ebp]
	push	eax
	call	_xmlRegCompactPushString
	add	esp, 16					; 00000010H
	jmp	$LN1@xmlRegExec
$LN19@xmlRegExec:

; 3800 : 
; 3801 :     if (value == NULL) {

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN20@xmlRegExec

; 3802 :         if (exec->state->type == XML_REGEXP_FINAL_STATE)

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	DWORD PTR [edx], 2
	jne	SHORT $LN21@xmlRegExec

; 3803 : 	    return(1);

	mov	eax, 1
	jmp	$LN1@xmlRegExec
$LN21@xmlRegExec:

; 3804 : 	final = 1;

	mov	DWORD PTR _final$[ebp], 1
$LN20@xmlRegExec:

; 3805 :     }
; 3806 : 
; 3807 : #ifdef DEBUG_PUSH
; 3808 :     printf("value pushed: %s\n", value);
; 3809 : #endif
; 3810 :     /*
; 3811 :      * If we have an active rollback stack push the new value there
; 3812 :      * and get back to where we were left
; 3813 :      */
; 3814 :     if ((value != NULL) && (exec->inputStackNr > 0)) {

	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LL2@xmlRegExec
	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jle	SHORT $LL2@xmlRegExec

; 3815 : 	xmlFARegExecSaveInputString(exec, value, data);

	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _exec$[ebp]
	push	eax
	call	_xmlFARegExecSaveInputString
	add	esp, 12					; 0000000cH

; 3816 : 	value = exec->inputStack[exec->index].value;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	edx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _value$[ebp], edx

; 3817 : 	data = exec->inputStack[exec->index].data;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	ecx, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _data$[ebp], ecx
$LL2@xmlRegExec:

; 3818 : #ifdef DEBUG_PUSH
; 3819 : 	printf("value loaded: %s\n", value);
; 3820 : #endif
; 3821 :     }
; 3822 : 
; 3823 :     while ((exec->status == 0) &&

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	$LN3@xmlRegExec
	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN23@xmlRegExec
	cmp	DWORD PTR _final$[ebp], 1
	jne	$LN3@xmlRegExec
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	DWORD PTR [ecx], 2
	je	$LN3@xmlRegExec
$LN23@xmlRegExec:

; 3824 : 	   ((value != NULL) ||
; 3825 : 	    ((final == 1) &&
; 3826 : 	     (exec->state->type != XML_REGEXP_FINAL_STATE)))) {
; 3827 : 
; 3828 : 	/*
; 3829 : 	 * End of input on non-terminal state, rollback, however we may
; 3830 : 	 * still have epsilon like transition for counted transitions
; 3831 : 	 * on counters, in that case don't break too early.
; 3832 : 	 */
; 3833 : 	if ((value == NULL) && (exec->counts == NULL))

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN24@xmlRegExec
	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+44], 0
	jne	SHORT $LN24@xmlRegExec

; 3834 : 	    goto rollback;

	jmp	$rollback$92
$LN24@xmlRegExec:

; 3835 : 
; 3836 : 	exec->transcount = 0;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+28], 0

; 3837 : 	for (;exec->transno < exec->state->nbTrans;exec->transno++) {

	jmp	SHORT $LN6@xmlRegExec
$LN4@xmlRegExec:
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 1
	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+24], edx
$LN6@xmlRegExec:
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR [edx+24]
	jge	$LN5@xmlRegExec

; 3838 : 	    trans = &exec->state->trans[exec->transno];

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _exec$[ebp]
	imul	edx, DWORD PTR [ecx+24], 20
	add	edx, DWORD PTR [eax+28]
	mov	DWORD PTR _trans$[ebp], edx

; 3839 : 	    if (trans->to < 0)

	mov	eax, DWORD PTR _trans$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jge	SHORT $LN25@xmlRegExec

; 3840 : 		continue;

	jmp	SHORT $LN4@xmlRegExec
$LN25@xmlRegExec:

; 3841 : 	    atom = trans->atom;

	mov	ecx, DWORD PTR _trans$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _atom$[ebp], edx

; 3842 : 	    ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 3843 : 	    if (trans->count == REGEXP_ALL_LAX_COUNTER) {

	mov	eax, DWORD PTR _trans$[ebp]
	cmp	DWORD PTR [eax+12], 1193047		; 00123457H
	jne	$LN26@xmlRegExec

; 3844 : 		int i;
; 3845 : 		int count;
; 3846 : 		xmlRegTransPtr t;
; 3847 : 		xmlRegCounterPtr counter;
; 3848 : 
; 3849 : 		ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 3850 : 
; 3851 : #ifdef DEBUG_PUSH
; 3852 : 		printf("testing all lax %d\n", trans->count);
; 3853 : #endif
; 3854 : 		/*
; 3855 : 		 * Check all counted transitions from the current state
; 3856 : 		 */
; 3857 : 		if ((value == NULL) && (final)) {

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN28@xmlRegExec
	cmp	DWORD PTR _final$[ebp], 0
	je	SHORT $LN28@xmlRegExec

; 3858 : 		    ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
	jmp	$LN29@xmlRegExec
$LN28@xmlRegExec:

; 3859 : 		} else if (value != NULL) {

	cmp	DWORD PTR _value$[ebp], 0
	je	$LN29@xmlRegExec

; 3860 : 		    for (i = 0;i < exec->state->nbTrans;i++) {

	mov	DWORD PTR _i$15[ebp], 0
	jmp	SHORT $LN9@xmlRegExec
$LN7@xmlRegExec:
	mov	ecx, DWORD PTR _i$15[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$15[ebp], ecx
$LN9@xmlRegExec:
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _i$15[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	$LN29@xmlRegExec

; 3861 : 			t = &exec->state->trans[i];

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	ecx, DWORD PTR _i$15[ebp], 20
	add	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _t$13[ebp], ecx

; 3862 : 			if ((t->counter < 0) || (t == trans))

	mov	edx, DWORD PTR _t$13[ebp]
	cmp	DWORD PTR [edx+8], 0
	jl	SHORT $LN32@xmlRegExec
	mov	eax, DWORD PTR _t$13[ebp]
	cmp	eax, DWORD PTR _trans$[ebp]
	jne	SHORT $LN31@xmlRegExec
$LN32@xmlRegExec:

; 3863 : 			    continue;

	jmp	SHORT $LN7@xmlRegExec
$LN31@xmlRegExec:

; 3864 : 			counter = &exec->comp->counters[t->counter];

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _t$13[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [edx+24]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _counter$12[ebp], eax

; 3865 : 			count = exec->counts[t->counter];

	mov	ecx, DWORD PTR _t$13[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _count$14[ebp], edx

; 3866 : 			if ((count < counter->max) &&
; 3867 : 		            (t->atom != NULL) &&

	mov	eax, DWORD PTR _counter$12[ebp]
	mov	ecx, DWORD PTR _count$14[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN33@xmlRegExec
	mov	edx, DWORD PTR _t$13[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN33@xmlRegExec
	mov	eax, DWORD PTR _t$13[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@xmlRegExec

; 3868 : 			    (xmlStrEqual(value, t->atom->valuep))) {
; 3869 : 			    ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 3870 : 			    break;

	jmp	SHORT $LN29@xmlRegExec
$LN33@xmlRegExec:

; 3871 : 			}
; 3872 : 			if ((count >= counter->min) &&
; 3873 : 			    (count < counter->max) &&
; 3874 : 			    (t->atom != NULL) &&

	mov	ecx, DWORD PTR _counter$12[ebp]
	mov	edx, DWORD PTR _count$14[ebp]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN34@xmlRegExec
	mov	eax, DWORD PTR _counter$12[ebp]
	mov	ecx, DWORD PTR _count$14[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN34@xmlRegExec
	mov	edx, DWORD PTR _t$13[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN34@xmlRegExec
	mov	eax, DWORD PTR _t$13[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN34@xmlRegExec

; 3875 : 			    (xmlStrEqual(value, t->atom->valuep))) {
; 3876 : 			    ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 3877 : 			    break;

	jmp	SHORT $LN29@xmlRegExec
$LN34@xmlRegExec:

; 3878 : 			}
; 3879 : 		    }

	jmp	$LN7@xmlRegExec
$LN29@xmlRegExec:

; 3880 : 		}

	jmp	$LN27@xmlRegExec
$LN26@xmlRegExec:

; 3881 : 	    } else if (trans->count == REGEXP_ALL_COUNTER) {

	mov	ecx, DWORD PTR _trans$[ebp]
	cmp	DWORD PTR [ecx+12], 1193046		; 00123456H
	jne	$LN35@xmlRegExec

; 3882 : 		int i;
; 3883 : 		int count;
; 3884 : 		xmlRegTransPtr t;
; 3885 : 		xmlRegCounterPtr counter;
; 3886 : 
; 3887 : 		ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 3888 : 
; 3889 : #ifdef DEBUG_PUSH
; 3890 : 		printf("testing all %d\n", trans->count);
; 3891 : #endif
; 3892 : 		/*
; 3893 : 		 * Check all counted transitions from the current state
; 3894 : 		 */
; 3895 : 		for (i = 0;i < exec->state->nbTrans;i++) {

	mov	DWORD PTR _i$11[ebp], 0
	jmp	SHORT $LN12@xmlRegExec
$LN10@xmlRegExec:
	mov	edx, DWORD PTR _i$11[ebp]
	add	edx, 1
	mov	DWORD PTR _i$11[ebp], edx
$LN12@xmlRegExec:
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _i$11[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $LN11@xmlRegExec

; 3896 :                     t = &exec->state->trans[i];

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	edx, DWORD PTR _i$11[ebp], 20
	add	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _t$9[ebp], edx

; 3897 : 		    if ((t->counter < 0) || (t == trans))

	mov	eax, DWORD PTR _t$9[ebp]
	cmp	DWORD PTR [eax+8], 0
	jl	SHORT $LN38@xmlRegExec
	mov	ecx, DWORD PTR _t$9[ebp]
	cmp	ecx, DWORD PTR _trans$[ebp]
	jne	SHORT $LN37@xmlRegExec
$LN38@xmlRegExec:

; 3898 : 			continue;

	jmp	SHORT $LN10@xmlRegExec
$LN37@xmlRegExec:

; 3899 :                     counter = &exec->comp->counters[t->counter];

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _t$9[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+24]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _counter$8[ebp], ecx

; 3900 : 		    count = exec->counts[t->counter];

	mov	edx, DWORD PTR _t$9[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _count$10[ebp], eax

; 3901 : 		    if ((count < counter->min) || (count > counter->max)) {

	mov	ecx, DWORD PTR _counter$8[ebp]
	mov	edx, DWORD PTR _count$10[ebp]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN40@xmlRegExec
	mov	eax, DWORD PTR _counter$8[ebp]
	mov	ecx, DWORD PTR _count$10[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN39@xmlRegExec
$LN40@xmlRegExec:

; 3902 : 			ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 3903 : 			break;

	jmp	SHORT $LN11@xmlRegExec
$LN39@xmlRegExec:

; 3904 : 		    }
; 3905 : 		}

	jmp	$LN10@xmlRegExec
$LN11@xmlRegExec:

; 3906 : 	    } else if (trans->count >= 0) {

	jmp	$LN27@xmlRegExec
$LN35@xmlRegExec:
	mov	edx, DWORD PTR _trans$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jl	SHORT $LN41@xmlRegExec

; 3907 : 		int count;
; 3908 : 		xmlRegCounterPtr counter;
; 3909 : 
; 3910 : 		/*
; 3911 : 		 * A counted transition.
; 3912 : 		 */
; 3913 : 
; 3914 : 		count = exec->counts[trans->count];

	mov	eax, DWORD PTR _trans$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _count$7[ebp], ecx

; 3915 : 		counter = &exec->comp->counters[trans->count];

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _trans$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [eax+24]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _counter$6[ebp], ecx

; 3916 : #ifdef DEBUG_PUSH
; 3917 : 		printf("testing count %d: val %d, min %d, max %d\n",
; 3918 : 		       trans->count, count, counter->min,  counter->max);
; 3919 : #endif
; 3920 : 		ret = ((count >= counter->min) && (count <= counter->max));

	mov	edx, DWORD PTR _counter$6[ebp]
	mov	eax, DWORD PTR _count$7[ebp]
	cmp	eax, DWORD PTR [edx]
	jl	SHORT $LN83@xmlRegExec
	mov	ecx, DWORD PTR _counter$6[ebp]
	mov	edx, DWORD PTR _count$7[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jg	SHORT $LN83@xmlRegExec
	mov	DWORD PTR tv246[ebp], 1
	jmp	SHORT $LN84@xmlRegExec
$LN83@xmlRegExec:
	mov	DWORD PTR tv246[ebp], 0
$LN84@xmlRegExec:
	mov	eax, DWORD PTR tv246[ebp]
	mov	DWORD PTR _ret$[ebp], eax
	jmp	$LN27@xmlRegExec
$LN41@xmlRegExec:

; 3921 : 	    } else if (atom == NULL) {

	cmp	DWORD PTR _atom$[ebp], 0
	jne	SHORT $LN43@xmlRegExec

; 3922 : 		fprintf(stderr, "epsilon transition left at runtime\n");

	push	OFFSET ??_C@_0CE@CMNJHAKA@epsilon?5transition?5left?5at?5runt@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 3923 : 		exec->status = -2;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx], -2			; fffffffeH

; 3924 : 		break;

	jmp	$LN5@xmlRegExec
	jmp	$LN27@xmlRegExec
$LN43@xmlRegExec:

; 3925 : 	    } else if (value != NULL) {

	cmp	DWORD PTR _value$[ebp], 0
	je	$LN27@xmlRegExec

; 3926 : 		ret = xmlRegStrEqualWildcard(atom->valuep, value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_xmlRegStrEqualWildcard
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 3927 : 		if (atom->neg) {

	mov	edx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN46@xmlRegExec

; 3928 : 		    ret = !ret;

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN85@xmlRegExec
	mov	DWORD PTR tv261[ebp], 1
	jmp	SHORT $LN86@xmlRegExec
$LN85@xmlRegExec:
	mov	DWORD PTR tv261[ebp], 0
$LN86@xmlRegExec:
	mov	eax, DWORD PTR tv261[ebp]
	mov	DWORD PTR _ret$[ebp], eax

; 3929 : 		    if (!compound)

	cmp	DWORD PTR _compound$[ebp], 0
	jne	SHORT $LN46@xmlRegExec

; 3930 : 		        ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN46@xmlRegExec:

; 3931 : 		}
; 3932 : 		if ((ret == 1) && (trans->counter >= 0)) {

	cmp	DWORD PTR _ret$[ebp], 1
	jne	SHORT $LN48@xmlRegExec
	mov	ecx, DWORD PTR _trans$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jl	SHORT $LN48@xmlRegExec

; 3933 : 		    xmlRegCounterPtr counter;
; 3934 : 		    int count;
; 3935 : 
; 3936 : 		    count = exec->counts[trans->counter];

	mov	edx, DWORD PTR _trans$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _count$4[ebp], eax

; 3937 : 		    counter = &exec->comp->counters[trans->counter];

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _trans$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [edx+24]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _counter$5[ebp], eax

; 3938 : 		    if (count >= counter->max)

	mov	ecx, DWORD PTR _counter$5[ebp]
	mov	edx, DWORD PTR _count$4[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LN48@xmlRegExec

; 3939 : 			ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN48@xmlRegExec:

; 3940 : 		}
; 3941 : 
; 3942 : 		if ((ret == 1) && (atom->min > 0) && (atom->max > 0)) {

	cmp	DWORD PTR _ret$[ebp], 1
	jne	$LN27@xmlRegExec
	mov	eax, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jle	$LN27@xmlRegExec
	mov	ecx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jle	$LN27@xmlRegExec

; 3943 : 		    xmlRegStatePtr to = exec->comp->states[trans->to];

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _trans$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _to$3[ebp], ecx

; 3944 : 
; 3945 : 		    /*
; 3946 : 		     * this is a multiple input sequence
; 3947 : 		     */
; 3948 : 		    if (exec->state->nbTrans > exec->transno + 1) {

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 1
	cmp	DWORD PTR [eax+24], edx
	jle	SHORT $LN51@xmlRegExec

; 3949 : 			if (exec->inputStackNr <= 0) {

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jg	SHORT $LN52@xmlRegExec

; 3950 : 			    xmlFARegExecSaveInputString(exec, value, data);

	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _exec$[ebp]
	push	eax
	call	_xmlFARegExecSaveInputString
	add	esp, 12					; 0000000cH
$LN52@xmlRegExec:

; 3951 : 			}
; 3952 : 			xmlFARegExecSave(exec);

	mov	ecx, DWORD PTR _exec$[ebp]
	push	ecx
	call	_xmlFARegExecSave
	add	esp, 4
$LN51@xmlRegExec:

; 3953 : 		    }
; 3954 : 		    exec->transcount = 1;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+28], 1
$LL15@xmlRegExec:

; 3955 : 		    do {
; 3956 : 			/*
; 3957 : 			 * Try to progress as much as possible on the input
; 3958 : 			 */
; 3959 : 			if (exec->transcount == atom->max) {

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [eax+28]
	cmp	edx, DWORD PTR [ecx+16]
	jne	SHORT $LN53@xmlRegExec

; 3960 : 			    break;

	jmp	$LN14@xmlRegExec
$LN53@xmlRegExec:

; 3961 : 			}
; 3962 : 			exec->index++;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	add	ecx, 1
	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+56], ecx

; 3963 : 			value = exec->inputStack[exec->index].value;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR _value$[ebp], ecx

; 3964 : 			data = exec->inputStack[exec->index].data;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR _data$[ebp], eax

; 3965 : #ifdef DEBUG_PUSH
; 3966 : 			printf("value loaded: %s\n", value);
; 3967 : #endif
; 3968 : 
; 3969 : 			/*
; 3970 : 			 * End of input: stop here
; 3971 : 			 */
; 3972 : 			if (value == NULL) {

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN54@xmlRegExec

; 3973 : 			    exec->index --;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	sub	edx, 1
	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+56], edx

; 3974 : 			    break;

	jmp	$LN14@xmlRegExec
$LN54@xmlRegExec:

; 3975 : 			}
; 3976 : 			if (exec->transcount >= atom->min) {

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [ecx+28]
	cmp	eax, DWORD PTR [edx+12]
	jl	SHORT $LN55@xmlRegExec

; 3977 : 			    int transno = exec->transno;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _transno$2[ebp], edx

; 3978 : 			    xmlRegStatePtr state = exec->state;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _state$1[ebp], ecx

; 3979 : 
; 3980 : 			    /*
; 3981 : 			     * The transition is acceptable save it
; 3982 : 			     */
; 3983 : 			    exec->transno = -1; /* trick */

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+24], -1

; 3984 : 			    exec->state = to;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR _to$3[ebp]
	mov	DWORD PTR [eax+20], ecx

; 3985 : 			    if (exec->inputStackNr <= 0) {

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+52], 0
	jg	SHORT $LN56@xmlRegExec

; 3986 : 				xmlFARegExecSaveInputString(exec, value, data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _exec$[ebp]
	push	edx
	call	_xmlFARegExecSaveInputString
	add	esp, 12					; 0000000cH
$LN56@xmlRegExec:

; 3987 : 			    }
; 3988 : 			    xmlFARegExecSave(exec);

	mov	eax, DWORD PTR _exec$[ebp]
	push	eax
	call	_xmlFARegExecSave
	add	esp, 4

; 3989 : 			    exec->transno = transno;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR _transno$2[ebp]
	mov	DWORD PTR [ecx+24], edx

; 3990 : 			    exec->state = state;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR _state$1[ebp]
	mov	DWORD PTR [eax+20], ecx
$LN55@xmlRegExec:

; 3991 : 			}
; 3992 : 			ret = xmlStrEqual(value, atom->valuep);

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 3993 : 			exec->transcount++;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 3994 : 		    } while (ret == 1);

	cmp	DWORD PTR _ret$[ebp], 1
	je	$LL15@xmlRegExec
$LN14@xmlRegExec:

; 3995 : 		    if (exec->transcount < atom->min)

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $LN57@xmlRegExec

; 3996 : 			ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN57@xmlRegExec:

; 3997 : 
; 3998 : 		    /*
; 3999 : 		     * If the last check failed but one transition was found
; 4000 : 		     * possible, rollback
; 4001 : 		     */
; 4002 : 		    if (ret < 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN58@xmlRegExec

; 4003 : 			ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN58@xmlRegExec:

; 4004 : 		    if (ret == 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN27@xmlRegExec

; 4005 : 			goto rollback;

	jmp	$rollback$92
$LN27@xmlRegExec:

; 4006 : 		    }
; 4007 : 		}
; 4008 : 	    }
; 4009 : 	    if (ret == 1) {

	cmp	DWORD PTR _ret$[ebp], 1
	jne	$LN60@xmlRegExec

; 4010 : 		if ((exec->callback != NULL) && (atom != NULL) &&

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN62@xmlRegExec
	cmp	DWORD PTR _atom$[ebp], 0
	je	SHORT $LN62@xmlRegExec
	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN62@xmlRegExec

; 4011 : 			(data != NULL)) {
; 4012 : 		    exec->callback(exec->data, atom->valuep,

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	call	edx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN62@xmlRegExec:

; 4013 : 			           atom->data, data);
; 4014 : 		}
; 4015 : 		if (exec->state->nbTrans > exec->transno + 1) {

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, 1
	cmp	DWORD PTR [ecx+24], eax
	jle	SHORT $LN63@xmlRegExec

; 4016 : 		    if (exec->inputStackNr <= 0) {

	mov	ecx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	jg	SHORT $LN64@xmlRegExec

; 4017 : 			xmlFARegExecSaveInputString(exec, value, data);

	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _exec$[ebp]
	push	ecx
	call	_xmlFARegExecSaveInputString
	add	esp, 12					; 0000000cH
$LN64@xmlRegExec:

; 4018 : 		    }
; 4019 : 		    xmlFARegExecSave(exec);

	mov	edx, DWORD PTR _exec$[ebp]
	push	edx
	call	_xmlFARegExecSave
	add	esp, 4
$LN63@xmlRegExec:

; 4020 : 		}
; 4021 : 		if (trans->counter >= 0) {

	mov	eax, DWORD PTR _trans$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jl	SHORT $LN65@xmlRegExec

; 4022 : #ifdef DEBUG_PUSH
; 4023 : 		    printf("Increasing count %d\n", trans->counter);
; 4024 : #endif
; 4025 : 		    exec->counts[trans->counter]++;

	mov	ecx, DWORD PTR _trans$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+edx*4]
	add	edx, 1
	mov	eax, DWORD PTR _trans$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	DWORD PTR [eax+ecx*4], edx
$LN65@xmlRegExec:

; 4026 : 		}
; 4027 : 		if ((trans->count >= 0) &&

	mov	ecx, DWORD PTR _trans$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jl	SHORT $LN66@xmlRegExec
	mov	edx, DWORD PTR _trans$[ebp]
	cmp	DWORD PTR [edx+12], 1193046		; 00123456H
	jge	SHORT $LN66@xmlRegExec

; 4028 : 		    (trans->count < REGEXP_ALL_COUNTER)) {
; 4029 : #ifdef DEBUG_REGEXP_EXEC
; 4030 : 		    printf("resetting count %d on transition\n",
; 4031 : 		           trans->count);
; 4032 : #endif
; 4033 : 		    exec->counts[trans->count] = 0;

	mov	eax, DWORD PTR _trans$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [eax+ecx*4], 0
$LN66@xmlRegExec:

; 4034 : 		}
; 4035 : #ifdef DEBUG_PUSH
; 4036 : 		printf("entering state %d\n", trans->to);
; 4037 : #endif
; 4038 :                 if ((exec->comp->states[trans->to] != NULL) &&

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _trans$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx+8]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $LN67@xmlRegExec
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _trans$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR [edx], 4
	jne	SHORT $LN67@xmlRegExec

; 4039 : 		    (exec->comp->states[trans->to]->type ==
; 4040 : 		     XML_REGEXP_SINK_STATE)) {
; 4041 : 		    /*
; 4042 : 		     * entering a sink state, save the current state as error
; 4043 : 		     * state.
; 4044 : 		     */
; 4045 : 		    if (exec->errString != NULL)

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN68@xmlRegExec

; 4046 : 			xmlFree(exec->errString);

	mov	esi, esp
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN68@xmlRegExec:

; 4047 : 		    exec->errString = xmlStrdup(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+80], eax

; 4048 : 		    exec->errState = exec->state;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+76], ecx

; 4049 : 		    memcpy(exec->errCounts, exec->counts,

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+20]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN67@xmlRegExec:

; 4050 : 			   exec->comp->nbCounters * sizeof(int));
; 4051 : 		}
; 4052 : 		exec->state = exec->comp->states[trans->to];

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _trans$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+20], eax

; 4053 : 		exec->transno = 0;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 4054 : 		if (trans->atom != NULL) {

	mov	edx, DWORD PTR _trans$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN69@xmlRegExec

; 4055 : 		    if (exec->inputStack != NULL) {

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN70@xmlRegExec

; 4056 : 			exec->index++;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	add	edx, 1
	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+56], edx

; 4057 : 			if (exec->index < exec->inputStackNr) {

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [ecx+56]
	cmp	eax, DWORD PTR [edx+52]
	jge	SHORT $LN72@xmlRegExec

; 4058 : 			    value = exec->inputStack[exec->index].value;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	edx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _value$[ebp], edx

; 4059 : 			    data = exec->inputStack[exec->index].data;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	ecx, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _data$[ebp], ecx

; 4060 : #ifdef DEBUG_PUSH
; 4061 : 			    printf("value loaded: %s\n", value);
; 4062 : #endif
; 4063 : 			} else {

	jmp	SHORT $LN73@xmlRegExec
$LN72@xmlRegExec:

; 4064 : 			    value = NULL;

	mov	DWORD PTR _value$[ebp], 0

; 4065 : 			    data = NULL;

	mov	DWORD PTR _data$[ebp], 0
$LN73@xmlRegExec:

; 4066 : #ifdef DEBUG_PUSH
; 4067 : 			    printf("end of input\n");
; 4068 : #endif
; 4069 : 			}
; 4070 : 		    } else {

	jmp	SHORT $LN69@xmlRegExec
$LN70@xmlRegExec:

; 4071 : 			value = NULL;

	mov	DWORD PTR _value$[ebp], 0

; 4072 : 			data = NULL;

	mov	DWORD PTR _data$[ebp], 0
$LN69@xmlRegExec:

; 4073 : #ifdef DEBUG_PUSH
; 4074 : 			printf("end of input\n");
; 4075 : #endif
; 4076 : 		    }
; 4077 : 		}
; 4078 : 		goto progress;

	jmp	$progress$93
	jmp	SHORT $LN61@xmlRegExec
$LN60@xmlRegExec:

; 4079 : 	    } else if (ret < 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN61@xmlRegExec

; 4080 : 		exec->status = -4;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx], -4			; fffffffcH

; 4081 : 		break;

	jmp	SHORT $LN5@xmlRegExec
$LN61@xmlRegExec:

; 4082 : 	    }
; 4083 : 	}

	jmp	$LN4@xmlRegExec
$LN5@xmlRegExec:

; 4084 : 	if ((exec->transno != 0) || (exec->state->nbTrans == 0)) {

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $rollback$92
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	DWORD PTR [edx+24], 0
	jne	$LN75@xmlRegExec
$rollback$92:

; 4085 : rollback:
; 4086 :             /*
; 4087 : 	     * if we didn't yet rollback on the current input
; 4088 : 	     * store the current state as the error state.
; 4089 : 	     */
; 4090 : 	    if ((progress) && (exec->state != NULL) &&

	cmp	DWORD PTR _progress$[ebp], 0
	je	$LN77@xmlRegExec
	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	$LN77@xmlRegExec
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	DWORD PTR [edx], 4
	je	SHORT $LN77@xmlRegExec

; 4091 : 	        (exec->state->type != XML_REGEXP_SINK_STATE)) {
; 4092 : 	        progress = 0;

	mov	DWORD PTR _progress$[ebp], 0

; 4093 : 		if (exec->errString != NULL)

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN78@xmlRegExec

; 4094 : 		    xmlFree(exec->errString);

	mov	esi, esp
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN78@xmlRegExec:

; 4095 : 		exec->errString = xmlStrdup(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+80], eax

; 4096 : 		exec->errState = exec->state;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+76], ecx

; 4097 :                 if (exec->comp->nbCounters)

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN77@xmlRegExec

; 4098 :                     memcpy(exec->errCounts, exec->counts,

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+20]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN77@xmlRegExec:

; 4099 :                            exec->comp->nbCounters * sizeof(int));
; 4100 : 	    }
; 4101 : 
; 4102 : 	    /*
; 4103 : 	     * Failed to find a way out
; 4104 : 	     */
; 4105 : 	    exec->determinist = 0;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+4], 0

; 4106 : 	    xmlFARegExecRollBack(exec);

	mov	eax, DWORD PTR _exec$[ebp]
	push	eax
	call	_xmlFARegExecRollBack
	add	esp, 4

; 4107 : 	    if ((exec->inputStack != NULL ) && (exec->status == 0)) {

	mov	ecx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [ecx+68], 0
	je	SHORT $LN75@xmlRegExec
	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN75@xmlRegExec

; 4108 : 		value = exec->inputStack[exec->index].value;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR _value$[ebp], ecx

; 4109 : 		data = exec->inputStack[exec->index].data;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR _data$[ebp], eax
$LN75@xmlRegExec:

; 4110 : #ifdef DEBUG_PUSH
; 4111 : 		printf("value loaded: %s\n", value);
; 4112 : #endif
; 4113 : 	    }
; 4114 : 	}
; 4115 : 	continue;

	jmp	$LL2@xmlRegExec
$progress$93:

; 4116 : progress:
; 4117 :         progress = 1;

	mov	DWORD PTR _progress$[ebp], 1

; 4118 : 	continue;

	jmp	$LL2@xmlRegExec

; 4119 :     }

	jmp	$LL2@xmlRegExec
$LN3@xmlRegExec:

; 4120 :     if (exec->status == 0) {

	mov	ecx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN81@xmlRegExec

; 4121 :         return(exec->state->type == XML_REGEXP_FINAL_STATE);

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN87@xmlRegExec
	mov	DWORD PTR tv509[ebp], 1
	jmp	SHORT $LN88@xmlRegExec
$LN87@xmlRegExec:
	mov	DWORD PTR tv509[ebp], 0
$LN88@xmlRegExec:
	mov	eax, DWORD PTR tv509[ebp]
	jmp	SHORT $LN1@xmlRegExec
$LN81@xmlRegExec:

; 4122 :     }
; 4123 : #ifdef DEBUG_ERR
; 4124 :     if (exec->status < 0) {
; 4125 : 	testerr(exec);
; 4126 :     }
; 4127 : #endif
; 4128 :     return(exec->status);

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [ecx]
$LN1@xmlRegExec:

; 4129 : }

	pop	edi
	pop	esi
	add	esp, 92					; 0000005cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegExecPushStringInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegCompactPushString
_TEXT	SEGMENT
_target$ = -12						; size = 4
_i$ = -8						; size = 4
_state$ = -4						; size = 4
_exec$ = 8						; size = 4
_comp$ = 12						; size = 4
_value$ = 16						; size = 4
_data$ = 20						; size = 4
_xmlRegCompactPushString PROC				; COMDAT

; 3703 : 	                void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 3704 :     int state = exec->index;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR _state$[ebp], ecx

; 3705 :     int i, target;
; 3706 : 
; 3707 :     if ((comp == NULL) || (comp->compact == NULL) || (comp->stringMap == NULL))

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN6@xmlRegComp
	mov	edx, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN6@xmlRegComp
	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	SHORT $LN5@xmlRegComp
$LN6@xmlRegComp:

; 3708 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlRegComp
$LN5@xmlRegComp:

; 3709 : 
; 3710 :     if (value == NULL) {

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN7@xmlRegComp

; 3711 : 	/*
; 3712 : 	 * are we at a final state ?
; 3713 : 	 */
; 3714 : 	if (comp->compact[state * (comp->nbstrings + 1)] ==

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	add	edx, 1
	imul	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	cmp	DWORD PTR [ecx+edx*4], 2
	jne	SHORT $LN8@xmlRegComp

; 3715 :             XML_REGEXP_FINAL_STATE)
; 3716 : 	    return(1);

	mov	eax, 1
	jmp	$LN1@xmlRegComp
$LN8@xmlRegComp:

; 3717 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlRegComp
$LN7@xmlRegComp:

; 3718 :     }
; 3719 : 
; 3720 : #ifdef DEBUG_PUSH
; 3721 :     printf("value pushed: %s\n", value);
; 3722 : #endif
; 3723 : 
; 3724 :     /*
; 3725 :      * Examine all outside transitions from current state
; 3726 :      */
; 3727 :     for (i = 0;i < comp->nbstrings;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlRegComp
$LN2@xmlRegComp:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@xmlRegComp:
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+48]
	jge	$error$16

; 3728 : 	target = comp->compact[state * (comp->nbstrings + 1) + i + 1];

	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+48]
	add	eax, 1
	imul	eax, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [edx+eax*4+4]
	mov	DWORD PTR _target$[ebp], eax

; 3729 : 	if ((target > 0) && (target <= comp->nbstates)) {

	cmp	DWORD PTR _target$[ebp], 0
	jle	$LN9@xmlRegComp
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR _target$[ebp]
	cmp	edx, DWORD PTR [ecx+36]
	jg	$LN9@xmlRegComp

; 3730 : 	    target--; /* to avoid 0 */

	mov	eax, DWORD PTR _target$[ebp]
	sub	eax, 1
	mov	DWORD PTR _target$[ebp], eax

; 3731 : 	    if (xmlRegStrEqualWildcard(comp->stringMap[i], value)) {

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_xmlRegStrEqualWildcard
	add	esp, 8
	test	eax, eax
	je	$LN9@xmlRegComp

; 3732 : 		exec->index = target;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR _target$[ebp]
	mov	DWORD PTR [eax+56], ecx

; 3733 : 		if ((exec->callback != NULL) && (comp->transdata != NULL)) {

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN11@xmlRegComp
	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN11@xmlRegComp

; 3734 : 		    exec->callback(exec->data, value,

	mov	esi, esp
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	imul	eax, DWORD PTR [edx+48]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+eax*4]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	call	edx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlRegComp:

; 3735 : 			  comp->transdata[state * comp->nbstrings + i], data);
; 3736 : 		}
; 3737 : #ifdef DEBUG_PUSH
; 3738 : 		printf("entering state %d\n", target);
; 3739 : #endif
; 3740 : 		if (comp->compact[target * (comp->nbstrings + 1)] ==

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	add	ecx, 1
	imul	ecx, DWORD PTR _target$[ebp]
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx*4], 4
	jne	SHORT $LN12@xmlRegComp

; 3741 : 		    XML_REGEXP_SINK_STATE)
; 3742 : 		    goto error;

	jmp	SHORT $error$16
$LN12@xmlRegComp:

; 3743 : 
; 3744 : 		if (comp->compact[target * (comp->nbstrings + 1)] ==

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	add	edx, 1
	imul	edx, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	cmp	DWORD PTR [ecx+edx*4], 2
	jne	SHORT $LN13@xmlRegComp

; 3745 : 		    XML_REGEXP_FINAL_STATE)
; 3746 : 		    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlRegComp
$LN13@xmlRegComp:

; 3747 : 		return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlRegComp
$LN9@xmlRegComp:

; 3748 : 	    }
; 3749 : 	}
; 3750 :     }

	jmp	$LN2@xmlRegComp
$error$16:

; 3751 :     /*
; 3752 :      * Failed to find an exit transition out from current state for the
; 3753 :      * current token
; 3754 :      */
; 3755 : #ifdef DEBUG_PUSH
; 3756 :     printf("failed to find a transition for %s on state %d\n", value, state);
; 3757 : #endif
; 3758 : error:
; 3759 :     if (exec->errString != NULL)

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+80], 0
	je	SHORT $LN14@xmlRegComp

; 3760 :         xmlFree(exec->errString);

	mov	esi, esp
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@xmlRegComp:

; 3761 :     exec->errString = xmlStrdup(value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+80], eax

; 3762 :     exec->errStateNo = state;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+72], eax

; 3763 :     exec->status = -1;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx], -1

; 3764 : #ifdef DEBUG_ERR
; 3765 :     testerr(exec);
; 3766 : #endif
; 3767 :     return(-1);

	or	eax, -1
$LN1@xmlRegComp:

; 3768 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegCompactPushString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFARegExecSaveInputString
_TEXT	SEGMENT
_tmp$1 = -4						; size = 4
_exec$ = 8						; size = 4
_value$ = 12						; size = 4
_data$ = 16						; size = 4
_xmlFARegExecSaveInputString PROC			; COMDAT

; 3604 : 	                    void *data) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 3605 : #ifdef DEBUG_PUSH
; 3606 :     printf("saving value: %d:%s\n", exec->inputStackNr, value);
; 3607 : #endif
; 3608 :     if (exec->inputStackMax == 0) {

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN2@xmlFARegEx

; 3609 : 	exec->inputStackMax = 4;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+48], 4

; 3610 : 	exec->inputStack = (xmlRegInputTokenPtr)

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+48]
	shl	eax, 3
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+68], eax

; 3611 : 	    xmlMalloc(exec->inputStackMax * sizeof(xmlRegInputToken));
; 3612 : 	if (exec->inputStack == NULL) {

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+68], 0
	jne	SHORT $LN4@xmlFARegEx

; 3613 : 	    xmlRegexpErrMemory(NULL, "pushing input string");

	push	OFFSET ??_C@_0BF@FEDDAGIG@pushing?5input?5string@
	push	0
	call	_xmlRegexpErrMemory
	add	esp, 8

; 3614 : 	    exec->inputStackMax = 0;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+48], 0

; 3615 : 	    return;

	jmp	$LN1@xmlFARegEx
$LN4@xmlFARegEx:

; 3616 : 	}

	jmp	SHORT $LN3@xmlFARegEx
$LN2@xmlFARegEx:

; 3617 :     } else if (exec->inputStackNr + 1 >= exec->inputStackMax) {

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	add	edx, 1
	mov	eax, DWORD PTR _exec$[ebp]
	cmp	edx, DWORD PTR [eax+48]
	jl	SHORT $LN3@xmlFARegEx

; 3618 : 	xmlRegInputTokenPtr tmp;
; 3619 : 
; 3620 : 	exec->inputStackMax *= 2;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	shl	edx, 1
	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+48], edx

; 3621 : 	tmp = (xmlRegInputTokenPtr) xmlRealloc(exec->inputStack,

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	shl	edx, 3
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 3622 : 			exec->inputStackMax * sizeof(xmlRegInputToken));
; 3623 : 	if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN6@xmlFARegEx

; 3624 : 	    xmlRegexpErrMemory(NULL, "pushing input string");

	push	OFFSET ??_C@_0BF@FEDDAGIG@pushing?5input?5string@
	push	0
	call	_xmlRegexpErrMemory
	add	esp, 8

; 3625 : 	    exec->inputStackMax /= 2;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+48]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 3626 : 	    return;

	jmp	SHORT $LN1@xmlFARegEx
$LN6@xmlFARegEx:

; 3627 : 	}
; 3628 : 	exec->inputStack = tmp;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [edx+68], eax
$LN3@xmlFARegEx:

; 3629 :     }
; 3630 :     exec->inputStack[exec->inputStackNr].value = xmlStrdup(value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [edx+68]
	mov	DWORD PTR [edx+ecx*8], eax

; 3631 :     exec->inputStack[exec->inputStackNr].data = data;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	edx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+ecx*8+4], edx

; 3632 :     exec->inputStackNr++;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, 1
	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+52], ecx

; 3633 :     exec->inputStack[exec->inputStackNr].value = NULL;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR [eax+ecx*8], 0

; 3634 :     exec->inputStack[exec->inputStackNr].data = NULL;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR [ecx+edx*8+4], 0
$LN1@xmlFARegEx:

; 3635 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFARegExecSaveInputString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFARegExec
_TEXT	SEGMENT
tv205 = -172						; size = 4
_i$1 = -168						; size = 4
_counter$2 = -164					; size = 4
_state$3 = -160						; size = 4
_transno$4 = -156					; size = 4
_counter$5 = -152					; size = 4
_to$6 = -148						; size = 4
_counter$7 = -144					; size = 4
_count$8 = -140						; size = 4
_atom$9 = -136						; size = 4
_trans$10 = -132					; size = 4
_deter$ = -128						; size = 4
_len$ = -120						; size = 4
_codepoint$ = -112					; size = 4
_ret$ = -108						; size = 4
_exec$ = -104						; size = 4
_execval$ = -96						; size = 92
_comp$ = 8						; size = 4
_content$ = 12						; size = 4
_xmlFARegExec PROC					; COMDAT

; 3194 : xmlFARegExec(xmlRegexpPtr comp, const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-172]
	mov	ecx, 43					; 0000002bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 3195 :     xmlRegExecCtxt execval;
; 3196 :     xmlRegExecCtxtPtr exec = &execval;

	lea	eax, DWORD PTR _execval$[ebp]
	mov	DWORD PTR _exec$[ebp], eax

; 3197 :     int ret, codepoint = 0, len, deter;

	mov	DWORD PTR _codepoint$[ebp], 0

; 3198 : 
; 3199 :     exec->inputString = content;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [ecx+64], edx

; 3200 :     exec->index = 0;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+56], 0

; 3201 :     exec->nbPush = 0;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+88], 0

; 3202 :     exec->determinist = 1;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+4], 1

; 3203 :     exec->maxRollbacks = 0;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+32], 0

; 3204 :     exec->nbRollbacks = 0;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 3205 :     exec->rollbacks = NULL;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+40], 0

; 3206 :     exec->status = 0;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax], 0

; 3207 :     exec->comp = comp;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 3208 :     exec->state = comp->states[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR [edx+20], eax

; 3209 :     exec->transno = 0;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 3210 :     exec->transcount = 0;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+28], 0

; 3211 :     exec->inputStack = NULL;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+68], 0

; 3212 :     exec->inputStackMax = 0;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 3213 :     if (comp->nbCounters > 0) {

	mov	edx, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jle	SHORT $LN13@xmlFARegEx

; 3214 : 	exec->counts = (int *) xmlMalloc(comp->nbCounters * sizeof(int));

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+44], eax

; 3215 : 	if (exec->counts == NULL) {

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN15@xmlFARegEx

; 3216 : 	    xmlRegexpErrMemory(NULL, "running regexp");

	push	OFFSET ??_C@_0P@IJHGICCJ@running?5regexp@
	push	0
	call	_xmlRegexpErrMemory
	add	esp, 8

; 3217 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlFARegEx
$LN15@xmlFARegEx:

; 3218 : 	}
; 3219 :         memset(exec->counts, 0, comp->nbCounters * sizeof(int));

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 3220 :     } else

	jmp	SHORT $LL2@xmlFARegEx
$LN13@xmlFARegEx:

; 3221 : 	exec->counts = NULL;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+44], 0
$LL2@xmlFARegEx:

; 3222 :     while ((exec->status == 0) && (exec->state != NULL) &&

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$error$80
	mov	ecx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	$error$80
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	movzx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	jne	SHORT $LN16@xmlFARegEx
	mov	ecx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	$error$80
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cmp	DWORD PTR [eax], 2
	je	$error$80
$LN16@xmlFARegEx:

; 3223 : 	   ((exec->inputString[exec->index] != 0) ||
; 3224 : 	    ((exec->state != NULL) &&
; 3225 : 	     (exec->state->type != XML_REGEXP_FINAL_STATE)))) {
; 3226 : 	xmlRegTransPtr trans;
; 3227 : 	xmlRegAtomPtr atom;
; 3228 : 
; 3229 : 	/*
; 3230 : 	 * If end of input on non-terminal state, rollback, however we may
; 3231 : 	 * still have epsilon like transition for counted transitions
; 3232 : 	 * on counters, in that case don't break too early.  Additionally,
; 3233 : 	 * if we are working on a range like "AB{0,2}", where B is not present,
; 3234 : 	 * we don't want to break.
; 3235 : 	 */
; 3236 : 	len = 1;

	mov	DWORD PTR _len$[ebp], 1

; 3237 : 	if ((exec->inputString[exec->index] == 0) && (exec->counts == NULL)) {

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	movzx	edx, BYTE PTR [ecx+edx]
	test	edx, edx
	jne	SHORT $LN17@xmlFARegEx
	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN17@xmlFARegEx

; 3238 : 	    /*
; 3239 : 	     * if there is a transition, we must check if
; 3240 : 	     *  atom allows minOccurs of 0
; 3241 : 	     */
; 3242 : 	    if (exec->transno < exec->state->nbTrans) {

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR [edx+24]
	jge	SHORT $LN18@xmlFARegEx

; 3243 : 	        trans = &exec->state->trans[exec->transno];

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _exec$[ebp]
	imul	edx, DWORD PTR [ecx+24], 20
	add	edx, DWORD PTR [eax+28]
	mov	DWORD PTR _trans$10[ebp], edx

; 3244 : 		if (trans->to >=0) {

	mov	eax, DWORD PTR _trans$10[ebp]
	cmp	DWORD PTR [eax+4], 0
	jl	SHORT $LN20@xmlFARegEx

; 3245 : 		    atom = trans->atom;

	mov	ecx, DWORD PTR _trans$10[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _atom$9[ebp], edx

; 3246 : 		    if (!((atom->min == 0) && (atom->max > 0)))

	mov	eax, DWORD PTR _atom$9[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN22@xmlFARegEx
	mov	ecx, DWORD PTR _atom$9[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jg	SHORT $LN20@xmlFARegEx
$LN22@xmlFARegEx:

; 3247 : 		        goto rollback;

	jmp	$rollback$81
$LN20@xmlFARegEx:

; 3248 : 		}
; 3249 : 	    } else

	jmp	SHORT $LN17@xmlFARegEx
$LN18@xmlFARegEx:

; 3250 : 	        goto rollback;

	jmp	$rollback$81
$LN17@xmlFARegEx:

; 3251 : 	}
; 3252 : 
; 3253 : 	exec->transcount = 0;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+28], 0

; 3254 : 	for (;exec->transno < exec->state->nbTrans;exec->transno++) {

	jmp	SHORT $LN6@xmlFARegEx
$LN4@xmlFARegEx:
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+24], ecx
$LN6@xmlFARegEx:
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	eax, DWORD PTR [ecx+24]
	jge	$LN5@xmlFARegEx

; 3255 : 	    trans = &exec->state->trans[exec->transno];

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _exec$[ebp]
	imul	ecx, DWORD PTR [eax+24], 20
	add	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR _trans$10[ebp], ecx

; 3256 : 	    if (trans->to < 0)

	mov	edx, DWORD PTR _trans$10[ebp]
	cmp	DWORD PTR [edx+4], 0
	jge	SHORT $LN23@xmlFARegEx

; 3257 : 		continue;

	jmp	SHORT $LN4@xmlFARegEx
$LN23@xmlFARegEx:

; 3258 : 	    atom = trans->atom;

	mov	eax, DWORD PTR _trans$10[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _atom$9[ebp], ecx

; 3259 : 	    ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 3260 : 	    deter = 1;

	mov	DWORD PTR _deter$[ebp], 1

; 3261 : 	    if (trans->count >= 0) {

	mov	edx, DWORD PTR _trans$10[ebp]
	cmp	DWORD PTR [edx+12], 0
	jl	$LN24@xmlFARegEx

; 3262 : 		int count;
; 3263 : 		xmlRegCounterPtr counter;
; 3264 : 
; 3265 : 		if (exec->counts == NULL) {

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN26@xmlFARegEx

; 3266 : 		    exec->status = -1;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx], -1

; 3267 : 		    goto error;

	jmp	$error$80
$LN26@xmlFARegEx:

; 3268 : 		}
; 3269 : 		/*
; 3270 : 		 * A counted transition.
; 3271 : 		 */
; 3272 : 
; 3273 : 		count = exec->counts[trans->count];

	mov	edx, DWORD PTR _trans$10[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _count$8[ebp], eax

; 3274 : 		counter = &exec->comp->counters[trans->count];

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _trans$10[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [edx+24]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _counter$7[ebp], eax

; 3275 : #ifdef DEBUG_REGEXP_EXEC
; 3276 : 		printf("testing count %d: val %d, min %d, max %d\n",
; 3277 : 		       trans->count, count, counter->min,  counter->max);
; 3278 : #endif
; 3279 : 		ret = ((count >= counter->min) && (count <= counter->max));

	mov	ecx, DWORD PTR _counter$7[ebp]
	mov	edx, DWORD PTR _count$8[ebp]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN72@xmlFARegEx
	mov	eax, DWORD PTR _counter$7[ebp]
	mov	ecx, DWORD PTR _count$8[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN72@xmlFARegEx
	mov	DWORD PTR tv205[ebp], 1
	jmp	SHORT $LN73@xmlFARegEx
$LN72@xmlFARegEx:
	mov	DWORD PTR tv205[ebp], 0
$LN73@xmlFARegEx:
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR _ret$[ebp], edx

; 3280 : 		if ((ret) && (counter->min != counter->max))

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN27@xmlFARegEx
	mov	eax, DWORD PTR _counter$7[ebp]
	mov	ecx, DWORD PTR _counter$7[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN27@xmlFARegEx

; 3281 : 		    deter = 0;

	mov	DWORD PTR _deter$[ebp], 0
$LN27@xmlFARegEx:

; 3282 : 	    } else if (atom == NULL) {

	jmp	$LN25@xmlFARegEx
$LN24@xmlFARegEx:
	cmp	DWORD PTR _atom$9[ebp], 0
	jne	SHORT $LN28@xmlFARegEx

; 3283 : 		fprintf(stderr, "epsilon transition left at runtime\n");

	push	OFFSET ??_C@_0CE@CMNJHAKA@epsilon?5transition?5left?5at?5runt@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 3284 : 		exec->status = -2;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax], -2			; fffffffeH

; 3285 : 		break;

	jmp	$LN5@xmlFARegEx
	jmp	$LN25@xmlFARegEx
$LN28@xmlFARegEx:

; 3286 : 	    } else if (exec->inputString[exec->index] != 0) {

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	movzx	edx, BYTE PTR [ecx+edx]
	test	edx, edx
	je	$LN30@xmlFARegEx

; 3287 :                 codepoint = CUR_SCHAR(&(exec->inputString[exec->index]), len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _exec$[ebp]
	add	edx, DWORD PTR [eax+56]
	push	edx
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _codepoint$[ebp], eax

; 3288 : 		ret = xmlRegCheckCharacter(atom, codepoint);

	mov	ecx, DWORD PTR _codepoint$[ebp]
	push	ecx
	mov	edx, DWORD PTR _atom$9[ebp]
	push	edx
	call	_xmlRegCheckCharacter
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 3289 : 		if ((ret == 1) && (atom->min >= 0) && (atom->max > 0)) {

	cmp	DWORD PTR _ret$[ebp], 1
	jne	$LN32@xmlFARegEx
	mov	eax, DWORD PTR _atom$9[ebp]
	cmp	DWORD PTR [eax+12], 0
	jl	$LN32@xmlFARegEx
	mov	ecx, DWORD PTR _atom$9[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jle	$LN32@xmlFARegEx

; 3290 : 		    xmlRegStatePtr to = comp->states[trans->to];

	mov	edx, DWORD PTR _trans$10[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _to$6[ebp], eax

; 3291 : 
; 3292 : 		    /*
; 3293 : 		     * this is a multiple input sequence
; 3294 : 		     * If there is a counter associated increment it now.
; 3295 : 		     * before potentially saving and rollback
; 3296 : 		     * do not increment if the counter is already over the
; 3297 : 		     * maximum limit in which case get to next transition
; 3298 : 		     */
; 3299 : 		    if (trans->counter >= 0) {

	mov	ecx, DWORD PTR _trans$10[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jl	$LN34@xmlFARegEx

; 3300 : 			xmlRegCounterPtr counter;
; 3301 : 
; 3302 : 			if ((exec->counts == NULL) ||
; 3303 : 			    (exec->comp == NULL) ||

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN36@xmlFARegEx
	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN36@xmlFARegEx
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN35@xmlFARegEx
$LN36@xmlFARegEx:

; 3304 : 			    (exec->comp->counters == NULL)) {
; 3305 : 			    exec->status = -1;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax], -1

; 3306 : 			    goto error;

	jmp	$error$80
$LN35@xmlFARegEx:

; 3307 : 			}
; 3308 : 			counter = &exec->comp->counters[trans->counter];

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _trans$10[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [edx+24]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _counter$5[ebp], eax

; 3309 : 			if (exec->counts[trans->counter] >= counter->max)

	mov	ecx, DWORD PTR _trans$10[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _counter$5[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN37@xmlFARegEx

; 3310 : 			    continue; /* for loop on transitions */

	jmp	$LN4@xmlFARegEx
$LN37@xmlFARegEx:

; 3311 : 
; 3312 : #ifdef DEBUG_REGEXP_EXEC
; 3313 : 			printf("Increasing count %d\n", trans->counter);
; 3314 : #endif
; 3315 : 			exec->counts[trans->counter]++;

	mov	edx, DWORD PTR _trans$10[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+eax*4]
	add	eax, 1
	mov	ecx, DWORD PTR _trans$10[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [ecx+44]
	mov	DWORD PTR [ecx+edx*4], eax
$LN34@xmlFARegEx:

; 3316 : 		    }
; 3317 : 		    if (exec->state->nbTrans > exec->transno + 1) {

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 1
	cmp	DWORD PTR [eax+24], edx
	jle	SHORT $LN38@xmlFARegEx

; 3318 : 			xmlFARegExecSave(exec);

	mov	eax, DWORD PTR _exec$[ebp]
	push	eax
	call	_xmlFARegExecSave
	add	esp, 4
$LN38@xmlFARegEx:

; 3319 : 		    }
; 3320 : 		    exec->transcount = 1;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+28], 1
$LL9@xmlFARegEx:

; 3321 : 		    do {
; 3322 : 			/*
; 3323 : 			 * Try to progress as much as possible on the input
; 3324 : 			 */
; 3325 : 			if (exec->transcount == atom->max) {

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR _atom$9[ebp]
	mov	ecx, DWORD PTR [edx+28]
	cmp	ecx, DWORD PTR [eax+16]
	jne	SHORT $LN39@xmlFARegEx

; 3326 : 			    break;

	jmp	$LN8@xmlFARegEx
$LN39@xmlFARegEx:

; 3327 : 			}
; 3328 : 			exec->index += len;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+56]
	add	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+56], eax

; 3329 : 			/*
; 3330 : 			 * End of input: stop here
; 3331 : 			 */
; 3332 : 			if (exec->inputString[exec->index] == 0) {

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	movzx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	jne	SHORT $LN40@xmlFARegEx

; 3333 : 			    exec->index -= len;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	sub	edx, DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+56], edx

; 3334 : 			    break;

	jmp	$LN8@xmlFARegEx
$LN40@xmlFARegEx:

; 3335 : 			}
; 3336 : 			if (exec->transcount >= atom->min) {

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR _atom$9[ebp]
	mov	eax, DWORD PTR [ecx+28]
	cmp	eax, DWORD PTR [edx+12]
	jl	SHORT $LN41@xmlFARegEx

; 3337 : 			    int transno = exec->transno;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _transno$4[ebp], edx

; 3338 : 			    xmlRegStatePtr state = exec->state;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _state$3[ebp], ecx

; 3339 : 
; 3340 : 			    /*
; 3341 : 			     * The transition is acceptable save it
; 3342 : 			     */
; 3343 : 			    exec->transno = -1; /* trick */

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+24], -1

; 3344 : 			    exec->state = to;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR _to$6[ebp]
	mov	DWORD PTR [eax+20], ecx

; 3345 : 			    xmlFARegExecSave(exec);

	mov	edx, DWORD PTR _exec$[ebp]
	push	edx
	call	_xmlFARegExecSave
	add	esp, 4

; 3346 : 			    exec->transno = transno;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR _transno$4[ebp]
	mov	DWORD PTR [eax+24], ecx

; 3347 : 			    exec->state = state;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR _state$3[ebp]
	mov	DWORD PTR [edx+20], eax
$LN41@xmlFARegEx:

; 3348 : 			}
; 3349 : 			codepoint = CUR_SCHAR(&(exec->inputString[exec->index]),

	lea	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	ecx, DWORD PTR _exec$[ebp]
	add	eax, DWORD PTR [ecx+56]
	push	eax
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _codepoint$[ebp], eax

; 3350 : 				              len);
; 3351 : 			ret = xmlRegCheckCharacter(atom, codepoint);

	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	mov	eax, DWORD PTR _atom$9[ebp]
	push	eax
	call	_xmlRegCheckCharacter
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 3352 : 			exec->transcount++;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+28], edx

; 3353 : 		    } while (ret == 1);

	cmp	DWORD PTR _ret$[ebp], 1
	je	$LL9@xmlFARegEx
$LN8@xmlFARegEx:

; 3354 : 		    if (exec->transcount < atom->min)

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR _atom$9[ebp]
	mov	eax, DWORD PTR [ecx+28]
	cmp	eax, DWORD PTR [edx+12]
	jge	SHORT $LN42@xmlFARegEx

; 3355 : 			ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN42@xmlFARegEx:

; 3356 : 
; 3357 : 		    /*
; 3358 : 		     * If the last check failed but one transition was found
; 3359 : 		     * possible, rollback
; 3360 : 		     */
; 3361 : 		    if (ret < 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN43@xmlFARegEx

; 3362 : 			ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN43@xmlFARegEx:

; 3363 : 		    if (ret == 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN44@xmlFARegEx

; 3364 : 			goto rollback;

	jmp	$rollback$81
$LN44@xmlFARegEx:

; 3365 : 		    }
; 3366 : 		    if (trans->counter >= 0) {

	mov	ecx, DWORD PTR _trans$10[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jl	SHORT $LN45@xmlFARegEx

; 3367 : 			if (exec->counts == NULL) {

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+44], 0
	jne	SHORT $LN46@xmlFARegEx

; 3368 : 			    exec->status = -1;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax], -1

; 3369 : 			    goto error;

	jmp	$error$80
$LN46@xmlFARegEx:

; 3370 : 			}
; 3371 : #ifdef DEBUG_REGEXP_EXEC
; 3372 : 			printf("Decreasing count %d\n", trans->counter);
; 3373 : #endif
; 3374 : 			exec->counts[trans->counter]--;

	mov	ecx, DWORD PTR _trans$10[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+edx*4]
	sub	edx, 1
	mov	eax, DWORD PTR _trans$10[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	DWORD PTR [eax+ecx*4], edx
$LN45@xmlFARegEx:

; 3375 : 		    }

	jmp	SHORT $LN33@xmlFARegEx
$LN32@xmlFARegEx:

; 3376 : 		} else if ((ret == 0) && (atom->min == 0) && (atom->max > 0)) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN33@xmlFARegEx
	mov	ecx, DWORD PTR _atom$9[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN33@xmlFARegEx
	mov	edx, DWORD PTR _atom$9[ebp]
	cmp	DWORD PTR [edx+16], 0
	jle	SHORT $LN33@xmlFARegEx

; 3377 : 		    /*
; 3378 : 		     * we don't match on the codepoint, but minOccurs of 0
; 3379 : 		     * says that's ok.  Setting len to 0 inhibits stepping
; 3380 : 		     * over the codepoint.
; 3381 : 		     */
; 3382 : 		    exec->transcount = 1;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+28], 1

; 3383 : 		    len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 3384 : 		    ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN33@xmlFARegEx:

; 3385 : 		}

	jmp	SHORT $LN25@xmlFARegEx
$LN30@xmlFARegEx:

; 3386 : 	    } else if ((atom->min == 0) && (atom->max > 0)) {

	mov	ecx, DWORD PTR _atom$9[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN25@xmlFARegEx
	mov	edx, DWORD PTR _atom$9[ebp]
	cmp	DWORD PTR [edx+16], 0
	jle	SHORT $LN25@xmlFARegEx

; 3387 : 	        /* another spot to match when minOccurs is 0 */
; 3388 : 		exec->transcount = 1;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+28], 1

; 3389 : 		len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 3390 : 		ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN25@xmlFARegEx:

; 3391 : 	    }
; 3392 : 	    if (ret == 1) {

	cmp	DWORD PTR _ret$[ebp], 1
	jne	$LN49@xmlFARegEx

; 3393 : 		if ((trans->nd == 1) ||

	mov	ecx, DWORD PTR _trans$10[ebp]
	cmp	DWORD PTR [ecx+16], 1
	je	SHORT $LN52@xmlFARegEx
	mov	edx, DWORD PTR _trans$10[ebp]
	cmp	DWORD PTR [edx+12], 0
	jl	SHORT $LN51@xmlFARegEx
	cmp	DWORD PTR _deter$[ebp], 0
	jne	SHORT $LN51@xmlFARegEx
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, 1
	cmp	DWORD PTR [ecx+24], eax
	jle	SHORT $LN51@xmlFARegEx
$LN52@xmlFARegEx:

; 3394 : 		    ((trans->count >= 0) && (deter == 0) &&
; 3395 : 		     (exec->state->nbTrans > exec->transno + 1))) {
; 3396 : #ifdef DEBUG_REGEXP_EXEC
; 3397 : 		    if (trans->nd == 1)
; 3398 : 		        printf("Saving on nd transition atom %d for %c at %d\n",
; 3399 : 			       trans->atom->no, codepoint, exec->index);
; 3400 : 		    else
; 3401 : 		        printf("Saving on counted transition count %d for %c at %d\n",
; 3402 : 			       trans->count, codepoint, exec->index);
; 3403 : #endif
; 3404 : 		    xmlFARegExecSave(exec);

	mov	ecx, DWORD PTR _exec$[ebp]
	push	ecx
	call	_xmlFARegExecSave
	add	esp, 4
$LN51@xmlFARegEx:

; 3405 : 		}
; 3406 : 		if (trans->counter >= 0) {

	mov	edx, DWORD PTR _trans$10[ebp]
	cmp	DWORD PTR [edx+8], 0
	jl	$LN53@xmlFARegEx

; 3407 : 		    xmlRegCounterPtr counter;
; 3408 : 
; 3409 :                     /* make sure we don't go over the counter maximum value */
; 3410 : 		    if ((exec->counts == NULL) ||
; 3411 : 			(exec->comp == NULL) ||

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN55@xmlFARegEx
	mov	ecx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN55@xmlFARegEx
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN54@xmlFARegEx
$LN55@xmlFARegEx:

; 3412 : 			(exec->comp->counters == NULL)) {
; 3413 : 			exec->status = -1;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx], -1

; 3414 : 			goto error;

	jmp	$error$80
$LN54@xmlFARegEx:

; 3415 : 		    }
; 3416 : 		    counter = &exec->comp->counters[trans->counter];

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _trans$10[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+24]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _counter$2[ebp], ecx

; 3417 : 		    if (exec->counts[trans->counter] >= counter->max)

	mov	edx, DWORD PTR _trans$10[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _counter$2[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LN56@xmlFARegEx

; 3418 : 			continue; /* for loop on transitions */

	jmp	$LN4@xmlFARegEx
$LN56@xmlFARegEx:

; 3419 : #ifdef DEBUG_REGEXP_EXEC
; 3420 : 		    printf("Increasing count %d\n", trans->counter);
; 3421 : #endif
; 3422 : 		    exec->counts[trans->counter]++;

	mov	eax, DWORD PTR _trans$10[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 1
	mov	edx, DWORD PTR _trans$10[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [edx+44]
	mov	DWORD PTR [edx+eax*4], ecx
$LN53@xmlFARegEx:

; 3423 : 		}
; 3424 : 		if ((trans->count >= 0) &&

	mov	eax, DWORD PTR _trans$10[ebp]
	cmp	DWORD PTR [eax+12], 0
	jl	SHORT $LN57@xmlFARegEx
	mov	ecx, DWORD PTR _trans$10[ebp]
	cmp	DWORD PTR [ecx+12], 1193046		; 00123456H
	jge	SHORT $LN57@xmlFARegEx

; 3425 : 		    (trans->count < REGEXP_ALL_COUNTER)) {
; 3426 : 		    if (exec->counts == NULL) {

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+44], 0
	jne	SHORT $LN58@xmlFARegEx

; 3427 : 		        exec->status = -1;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax], -1

; 3428 : 			goto error;

	jmp	$error$80
$LN58@xmlFARegEx:

; 3429 : 		    }
; 3430 : #ifdef DEBUG_REGEXP_EXEC
; 3431 : 		    printf("resetting count %d on transition\n",
; 3432 : 		           trans->count);
; 3433 : #endif
; 3434 : 		    exec->counts[trans->count] = 0;

	mov	ecx, DWORD PTR _trans$10[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [ecx+edx*4], 0
$LN57@xmlFARegEx:

; 3435 : 		}
; 3436 : #ifdef DEBUG_REGEXP_EXEC
; 3437 : 		printf("entering state %d\n", trans->to);
; 3438 : #endif
; 3439 : 		exec->state = comp->states[trans->to];

	mov	edx, DWORD PTR _trans$10[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx+20], edx

; 3440 : 		exec->transno = 0;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+24], 0

; 3441 : 		if (trans->atom != NULL) {

	mov	ecx, DWORD PTR _trans$10[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN59@xmlFARegEx

; 3442 : 		    exec->index += len;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+56]
	add	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+56], eax
$LN59@xmlFARegEx:

; 3443 : 		}
; 3444 : 		goto progress;

	jmp	SHORT $progress$82
	jmp	SHORT $LN50@xmlFARegEx
$LN49@xmlFARegEx:

; 3445 : 	    } else if (ret < 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN50@xmlFARegEx

; 3446 : 		exec->status = -4;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx], -4			; fffffffcH

; 3447 : 		break;

	jmp	SHORT $LN5@xmlFARegEx
$LN50@xmlFARegEx:

; 3448 : 	    }
; 3449 : 	}

	jmp	$LN4@xmlFARegEx
$LN5@xmlFARegEx:

; 3450 : 	if ((exec->transno != 0) || (exec->state->nbTrans == 0)) {

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $rollback$81
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $progress$82
$rollback$81:

; 3451 : rollback:
; 3452 : 	    /*
; 3453 : 	     * Failed to find a way out
; 3454 : 	     */
; 3455 : 	    exec->determinist = 0;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+4], 0

; 3456 : #ifdef DEBUG_REGEXP_EXEC
; 3457 : 	    printf("rollback from state %d on %d:%c\n", exec->state->no,
; 3458 : 	           codepoint,codepoint);
; 3459 : #endif
; 3460 : 	    xmlFARegExecRollBack(exec);

	mov	ecx, DWORD PTR _exec$[ebp]
	push	ecx
	call	_xmlFARegExecRollBack
	add	esp, 4
$progress$82:

; 3461 : 	}
; 3462 : progress:
; 3463 : 	continue;

	jmp	$LL2@xmlFARegEx

; 3464 :     }

	jmp	$LL2@xmlFARegEx
$error$80:

; 3465 : error:
; 3466 :     if (exec->rollbacks != NULL) {

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	$LN63@xmlFARegEx

; 3467 : 	if (exec->counts != NULL) {

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN64@xmlFARegEx

; 3468 : 	    int i;
; 3469 : 
; 3470 : 	    for (i = 0;i < exec->maxRollbacks;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN12@xmlFARegEx
$LN10@xmlFARegEx:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN12@xmlFARegEx:
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR [edx+32]
	jge	SHORT $LN64@xmlFARegEx

; 3471 : 		if (exec->rollbacks[i].counts != NULL)

	mov	ecx, DWORD PTR _i$1[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+12], 0
	je	SHORT $LN65@xmlFARegEx

; 3472 : 		    xmlFree(exec->rollbacks[i].counts);

	mov	ecx, DWORD PTR _i$1[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+ecx+12]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN65@xmlFARegEx:
	jmp	SHORT $LN10@xmlFARegEx
$LN64@xmlFARegEx:

; 3473 : 	}
; 3474 : 	xmlFree(exec->rollbacks);

	mov	esi, esp
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN63@xmlFARegEx:

; 3475 :     }
; 3476 :     if (exec->state == NULL)

	mov	ecx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN66@xmlFARegEx

; 3477 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlFARegEx
$LN66@xmlFARegEx:

; 3478 :     if (exec->counts != NULL)

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN67@xmlFARegEx

; 3479 : 	xmlFree(exec->counts);

	mov	esi, esp
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN67@xmlFARegEx:

; 3480 :     if (exec->status == 0)

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN68@xmlFARegEx

; 3481 : 	return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlFARegEx
$LN68@xmlFARegEx:

; 3482 :     if (exec->status == -1) {

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN69@xmlFARegEx

; 3483 : 	if (exec->nbPush > MAX_PUSH)

	mov	ecx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [ecx+88], 10000000		; 00989680H
	jle	SHORT $LN70@xmlFARegEx

; 3484 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlFARegEx
$LN70@xmlFARegEx:

; 3485 : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlFARegEx
$LN69@xmlFARegEx:

; 3486 :     }
; 3487 :     return(exec->status);

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx]
$LN1@xmlFARegEx:

; 3488 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN79@xmlFARegEx
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 172				; 000000acH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN79@xmlFARegEx:
	DD	2
	DD	$LN78@xmlFARegEx
$LN78@xmlFARegEx:
	DD	-96					; ffffffa0H
	DD	92					; 0000005cH
	DD	$LN76@xmlFARegEx
	DD	-120					; ffffff88H
	DD	4
	DD	$LN77@xmlFARegEx
$LN77@xmlFARegEx:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN76@xmlFARegEx:
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
_xmlFARegExec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFARegExecRollBack
_TEXT	SEGMENT
_exec$ = 8						; size = 4
_xmlFARegExecRollBack PROC				; COMDAT

; 3157 : xmlFARegExecRollBack(xmlRegExecCtxtPtr exec) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 3158 :     if (exec->nbRollbacks <= 0) {

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jg	SHORT $LN2@xmlFARegEx

; 3159 : 	exec->status = -1;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx], -1

; 3160 : #ifdef DEBUG_REGEXP_EXEC
; 3161 : 	printf("rollback failed on empty stack\n");
; 3162 : #endif
; 3163 : 	return;

	jmp	$LN1@xmlFARegEx
$LN2@xmlFARegEx:

; 3164 :     }
; 3165 :     exec->nbRollbacks--;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+36]
	sub	eax, 1
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 3166 :     exec->state = exec->rollbacks[exec->nbRollbacks].state;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shl	eax, 4
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+20], edx

; 3167 :     exec->index = exec->rollbacks[exec->nbRollbacks].index;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shl	ecx, 4
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [eax+ecx+4]
	mov	DWORD PTR [edx+56], eax

; 3168 :     exec->transno = exec->rollbacks[exec->nbRollbacks].nextbranch;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	shl	edx, 4
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR [eax+24], ecx

; 3169 :     if (exec->comp->nbCounters > 0) {

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+20], 0
	jle	SHORT $LN1@xmlFARegEx

; 3170 : 	if (exec->rollbacks[exec->nbRollbacks].counts == NULL) {

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	shl	edx, 4
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	cmp	DWORD PTR [ecx+edx+12], 0
	jne	SHORT $LN4@xmlFARegEx

; 3171 : 	    fprintf(stderr, "exec save: allocation failed");

	push	OFFSET ??_C@_0BN@CPBANDJM@exec?5save?3?5allocation?5failed@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 3172 : 	    exec->status = -6;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx], -6			; fffffffaH

; 3173 : 	    return;

	jmp	SHORT $LN1@xmlFARegEx
$LN4@xmlFARegEx:

; 3174 : 	}
; 3175 : 	if (exec->counts) {

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN1@xmlFARegEx

; 3176 : 	    memcpy(exec->counts, exec->rollbacks[exec->nbRollbacks].counts,

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+20]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	shl	edx, 4
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+edx+12]
	push	edx
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@xmlFARegEx:

; 3177 : 	       exec->comp->nbCounters * sizeof(int));
; 3178 : 	}
; 3179 :     }
; 3180 : 
; 3181 : #ifdef DEBUG_REGEXP_EXEC
; 3182 :     printf("restored ");
; 3183 :     xmlFARegDebugExec(exec);
; 3184 : #endif
; 3185 : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFARegExecRollBack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFARegExecSave
_TEXT	SEGMENT
_len$1 = -8						; size = 4
_tmp$2 = -4						; size = 4
_exec$ = 8						; size = 4
_xmlFARegExecSave PROC					; COMDAT

; 3096 : xmlFARegExecSave(xmlRegExecCtxtPtr exec) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 3097 : #ifdef DEBUG_REGEXP_EXEC
; 3098 :     printf("saving ");
; 3099 :     exec->transno++;
; 3100 :     xmlFARegDebugExec(exec);
; 3101 :     exec->transno--;
; 3102 : #endif
; 3103 : #ifdef MAX_PUSH
; 3104 :     if (exec->nbPush > MAX_PUSH) {

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+88], 10000000		; 00989680H
	jle	SHORT $LN2@xmlFARegEx

; 3105 :         return;

	jmp	$LN1@xmlFARegEx
$LN2@xmlFARegEx:

; 3106 :     }
; 3107 :     exec->nbPush++;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	add	edx, 1
	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+88], edx

; 3108 : #endif
; 3109 : 
; 3110 :     if (exec->maxRollbacks == 0) {

	mov	ecx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN3@xmlFARegEx

; 3111 : 	exec->maxRollbacks = 4;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+32], 4

; 3112 : 	exec->rollbacks = (xmlRegExecRollback *) xmlMalloc(exec->maxRollbacks *

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	shl	ecx, 4
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+40], eax

; 3113 : 		                             sizeof(xmlRegExecRollback));
; 3114 : 	if (exec->rollbacks == NULL) {

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN5@xmlFARegEx

; 3115 : 	    xmlRegexpErrMemory(NULL, "saving regexp");

	push	OFFSET ??_C@_0O@PEGCJGLF@saving?5regexp@
	push	0
	call	_xmlRegexpErrMemory
	add	esp, 8

; 3116 : 	    exec->maxRollbacks = 0;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 3117 : 	    return;

	jmp	$LN1@xmlFARegEx
$LN5@xmlFARegEx:

; 3118 : 	}
; 3119 : 	memset(exec->rollbacks, 0,

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+32]
	shl	eax, 4
	push	eax
	push	0
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	$LN4@xmlFARegEx
$LN3@xmlFARegEx:

; 3120 : 	       exec->maxRollbacks * sizeof(xmlRegExecRollback));
; 3121 :     } else if (exec->nbRollbacks >= exec->maxRollbacks) {

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [eax+36]
	cmp	edx, DWORD PTR [ecx+32]
	jl	$LN4@xmlFARegEx

; 3122 : 	xmlRegExecRollback *tmp;
; 3123 : 	int len = exec->maxRollbacks;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _len$1[ebp], ecx

; 3124 : 
; 3125 : 	exec->maxRollbacks *= 2;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+32]
	shl	eax, 1
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 3126 : 	tmp = (xmlRegExecRollback *) xmlRealloc(exec->rollbacks,

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+32]
	shl	eax, 4
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$2[ebp], eax

; 3127 : 			exec->maxRollbacks * sizeof(xmlRegExecRollback));
; 3128 : 	if (tmp == NULL) {

	cmp	DWORD PTR _tmp$2[ebp], 0
	jne	SHORT $LN7@xmlFARegEx

; 3129 : 	    xmlRegexpErrMemory(NULL, "saving regexp");

	push	OFFSET ??_C@_0O@PEGCJGLF@saving?5regexp@
	push	0
	call	_xmlRegexpErrMemory
	add	esp, 8

; 3130 : 	    exec->maxRollbacks /= 2;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [eax+32]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 3131 : 	    return;

	jmp	$LN1@xmlFARegEx
$LN7@xmlFARegEx:

; 3132 : 	}
; 3133 : 	exec->rollbacks = tmp;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR _tmp$2[ebp]
	mov	DWORD PTR [edx+40], eax

; 3134 : 	tmp = &exec->rollbacks[len];

	mov	ecx, DWORD PTR _len$1[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _exec$[ebp]
	add	ecx, DWORD PTR [edx+40]
	mov	DWORD PTR _tmp$2[ebp], ecx

; 3135 : 	memset(tmp, 0, (exec->maxRollbacks - len) * sizeof(xmlRegExecRollback));

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	sub	ecx, DWORD PTR _len$1[ebp]
	shl	ecx, 4
	push	ecx
	push	0
	mov	edx, DWORD PTR _tmp$2[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN4@xmlFARegEx:

; 3136 :     }
; 3137 :     exec->rollbacks[exec->nbRollbacks].state = exec->state;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shl	ecx, 4
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+ecx], edx

; 3138 :     exec->rollbacks[exec->nbRollbacks].index = exec->index;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shl	ecx, 4
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [edx+56]
	mov	DWORD PTR [eax+ecx+4], edx

; 3139 :     exec->rollbacks[exec->nbRollbacks].nextbranch = exec->transno + 1;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shl	eax, 4
	mov	edx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [edx+40]
	mov	DWORD PTR [edx+eax+8], ecx

; 3140 :     if (exec->comp->nbCounters > 0) {

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+20], 0
	jle	$LN8@xmlFARegEx

; 3141 : 	if (exec->rollbacks[exec->nbRollbacks].counts == NULL) {

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shl	eax, 4
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	cmp	DWORD PTR [edx+eax+12], 0
	jne	SHORT $LN9@xmlFARegEx

; 3142 : 	    exec->rollbacks[exec->nbRollbacks].counts = (int *)

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+20]
	shl	edx, 2
	mov	esi, esp
	push	edx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	shl	edx, 4
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	DWORD PTR [ecx+edx+12], eax

; 3143 : 		xmlMalloc(exec->comp->nbCounters * sizeof(int));
; 3144 : 	    if (exec->rollbacks[exec->nbRollbacks].counts == NULL) {

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shl	eax, 4
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	cmp	DWORD PTR [edx+eax+12], 0
	jne	SHORT $LN9@xmlFARegEx

; 3145 : 		xmlRegexpErrMemory(NULL, "saving regexp");

	push	OFFSET ??_C@_0O@PEGCJGLF@saving?5regexp@
	push	0
	call	_xmlRegexpErrMemory
	add	esp, 8

; 3146 : 		exec->status = -5;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax], -5			; fffffffbH

; 3147 : 		return;

	jmp	SHORT $LN1@xmlFARegEx
$LN9@xmlFARegEx:

; 3148 : 	    }
; 3149 : 	}
; 3150 : 	memcpy(exec->rollbacks[exec->nbRollbacks].counts, exec->counts,

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+20]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shl	ecx, 4
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+ecx+12]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN8@xmlFARegEx:

; 3151 : 	       exec->comp->nbCounters * sizeof(int));
; 3152 :     }
; 3153 :     exec->nbRollbacks++;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, 1
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN1@xmlFARegEx:

; 3154 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFARegExecSave ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFARecurseDeterminism
_TEXT	SEGMENT
_deep$ = -24						; size = 4
_t1$ = -20						; size = 4
_nbTrans$ = -16						; size = 4
_transnr$ = -12						; size = 4
_res$ = -8						; size = 4
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_state$ = 12						; size = 4
_to$ = 16						; size = 4
_atom$ = 20						; size = 4
_xmlFARecurseDeterminism PROC				; COMDAT

; 2589 : 	                 int to, xmlRegAtomPtr atom) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 2590 :     int ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 2591 :     int res;
; 2592 :     int transnr, nbTrans;
; 2593 :     xmlRegTransPtr t1;
; 2594 :     int deep = 1;

	mov	DWORD PTR _deep$[ebp], 1

; 2595 : 
; 2596 :     if (state == NULL)

	cmp	DWORD PTR _state$[ebp], 0
	jne	SHORT $LN5@xmlFARecur

; 2597 : 	return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlFARecur
$LN5@xmlFARecur:

; 2598 :     if (state->markd == XML_REGEXP_MARK_VISITED)

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+8], 2
	jne	SHORT $LN6@xmlFARecur

; 2599 : 	return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlFARecur
$LN6@xmlFARecur:

; 2600 : 
; 2601 :     if (ctxt->flags & AM_AUTOMATA_RNG)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	and	edx, 1
	je	SHORT $LN7@xmlFARecur

; 2602 :         deep = 0;

	mov	DWORD PTR _deep$[ebp], 0
$LN7@xmlFARecur:

; 2603 : 
; 2604 :     /*
; 2605 :      * don't recurse on transitions potentially added in the course of
; 2606 :      * the elimination.
; 2607 :      */
; 2608 :     nbTrans = state->nbTrans;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _nbTrans$[ebp], ecx

; 2609 :     for (transnr = 0;transnr < nbTrans;transnr++) {

	mov	DWORD PTR _transnr$[ebp], 0
	jmp	SHORT $LN4@xmlFARecur
$LN2@xmlFARecur:
	mov	edx, DWORD PTR _transnr$[ebp]
	add	edx, 1
	mov	DWORD PTR _transnr$[ebp], edx
$LN4@xmlFARecur:
	mov	eax, DWORD PTR _transnr$[ebp]
	cmp	eax, DWORD PTR _nbTrans$[ebp]
	jge	$LN3@xmlFARecur

; 2610 : 	t1 = &(state->trans[transnr]);

	imul	ecx, DWORD PTR _transnr$[ebp], 20
	mov	edx, DWORD PTR _state$[ebp]
	add	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR _t1$[ebp], ecx

; 2611 : 	/*
; 2612 : 	 * check transitions conflicting with the one looked at
; 2613 : 	 */
; 2614 : 	if (t1->atom == NULL) {

	mov	eax, DWORD PTR _t1$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN8@xmlFARecur

; 2615 : 	    if (t1->to < 0)

	mov	ecx, DWORD PTR _t1$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jge	SHORT $LN9@xmlFARecur

; 2616 : 		continue;

	jmp	SHORT $LN2@xmlFARecur
$LN9@xmlFARecur:

; 2617 : 	    state->markd = XML_REGEXP_MARK_VISITED;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+8], 2

; 2618 : 	    res = xmlFARecurseDeterminism(ctxt, ctxt->states[t1->to],

	mov	eax, DWORD PTR _atom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _t1$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [edx+eax*4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFARecurseDeterminism
	add	esp, 16					; 00000010H
	mov	DWORD PTR _res$[ebp], eax

; 2619 : 		                           to, atom);
; 2620 : 	    state->markd = 0;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+8], 0

; 2621 : 	    if (res == 0) {

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN10@xmlFARecur

; 2622 : 	        ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN10@xmlFARecur:

; 2623 : 		/* t1->nd = 1; */
; 2624 : 	    }
; 2625 : 	    continue;

	jmp	SHORT $LN2@xmlFARecur
$LN8@xmlFARecur:

; 2626 : 	}
; 2627 : 	if (t1->to != to)

	mov	eax, DWORD PTR _t1$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _to$[ebp]
	je	SHORT $LN11@xmlFARecur

; 2628 : 	    continue;

	jmp	$LN2@xmlFARecur
$LN11@xmlFARecur:

; 2629 : 	if (xmlFACompareAtoms(t1->atom, atom, deep)) {

	mov	edx, DWORD PTR _deep$[ebp]
	push	edx
	mov	eax, DWORD PTR _atom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t1$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlFACompareAtoms
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN12@xmlFARecur

; 2630 : 	    ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 2631 : 	    /* mark the transition as non-deterministic */
; 2632 : 	    t1->nd = 1;

	mov	eax, DWORD PTR _t1$[ebp]
	mov	DWORD PTR [eax+16], 1
$LN12@xmlFARecur:

; 2633 : 	}
; 2634 :     }

	jmp	$LN2@xmlFARecur
$LN3@xmlFARecur:

; 2635 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlFARecur:

; 2636 : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFARecurseDeterminism ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFACompareAtoms
_TEXT	SEGMENT
tv163 = -44						; size = 4
tv132 = -40						; size = 4
tv89 = -36						; size = 4
tv84 = -32						; size = 4
_r2$1 = -28						; size = 4
_r1$2 = -24						; size = 4
_res$3 = -20						; size = 4
_j$4 = -16						; size = 4
_i$5 = -12						; size = 4
_tmp$6 = -8						; size = 4
_ret$ = -4						; size = 4
_atom1$ = 8						; size = 4
_atom2$ = 12						; size = 4
_deep$ = 16						; size = 4
_xmlFACompareAtoms PROC					; COMDAT

; 2501 : xmlFACompareAtoms(xmlRegAtomPtr atom1, xmlRegAtomPtr atom2, int deep) {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	edi
	lea	edi, DWORD PTR [ebp-44]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 2502 :     int ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 2503 : 
; 2504 :     if (atom1 == atom2)

	mov	eax, DWORD PTR _atom1$[ebp]
	cmp	eax, DWORD PTR _atom2$[ebp]
	jne	SHORT $LN10@xmlFACompa

; 2505 : 	return(1);

	mov	eax, 1
	jmp	$LN1@xmlFACompa
$LN10@xmlFACompa:

; 2506 :     if ((atom1 == NULL) || (atom2 == NULL))

	cmp	DWORD PTR _atom1$[ebp], 0
	je	SHORT $LN12@xmlFACompa
	cmp	DWORD PTR _atom2$[ebp], 0
	jne	SHORT $LN11@xmlFACompa
$LN12@xmlFACompa:

; 2507 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlFACompa
$LN11@xmlFACompa:

; 2508 : 
; 2509 :     if ((atom1->type == XML_REGEXP_ANYCHAR) ||

	mov	ecx, DWORD PTR _atom1$[ebp]
	cmp	DWORD PTR [ecx+4], 6
	je	SHORT $LN14@xmlFACompa
	mov	edx, DWORD PTR _atom2$[ebp]
	cmp	DWORD PTR [edx+4], 6
	jne	SHORT $LN13@xmlFACompa
$LN14@xmlFACompa:

; 2510 :         (atom2->type == XML_REGEXP_ANYCHAR))
; 2511 : 	return(1);

	mov	eax, 1
	jmp	$LN1@xmlFACompa
$LN13@xmlFACompa:

; 2512 : 
; 2513 :     if (atom1->type > atom2->type) {

	mov	eax, DWORD PTR _atom1$[ebp]
	mov	ecx, DWORD PTR _atom2$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN15@xmlFACompa

; 2514 : 	xmlRegAtomPtr tmp;
; 2515 : 	tmp = atom1;

	mov	eax, DWORD PTR _atom1$[ebp]
	mov	DWORD PTR _tmp$6[ebp], eax

; 2516 : 	atom1 = atom2;

	mov	ecx, DWORD PTR _atom2$[ebp]
	mov	DWORD PTR _atom1$[ebp], ecx

; 2517 : 	atom2 = tmp;

	mov	edx, DWORD PTR _tmp$6[ebp]
	mov	DWORD PTR _atom2$[ebp], edx
$LN15@xmlFACompa:

; 2518 :     }
; 2519 :     if (atom1->type != atom2->type) {

	mov	eax, DWORD PTR _atom1$[ebp]
	mov	ecx, DWORD PTR _atom2$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN16@xmlFACompa

; 2520 :         ret = xmlFACompareAtomTypes(atom1->type, atom2->type);

	mov	eax, DWORD PTR _atom2$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _atom1$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_xmlFACompareAtomTypes
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2521 : 	/* if they can't intersect at the type level break now */
; 2522 : 	if (ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN16@xmlFACompa

; 2523 : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlFACompa
$LN16@xmlFACompa:

; 2524 :     }
; 2525 :     switch (atom1->type) {

	mov	ecx, DWORD PTR _atom1$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv84[ebp], edx
	cmp	DWORD PTR tv84[ebp], 2
	je	SHORT $LN22@xmlFACompa
	cmp	DWORD PTR tv84[ebp], 3
	je	$LN26@xmlFACompa
	cmp	DWORD PTR tv84[ebp], 5
	je	SHORT $LN18@xmlFACompa
	jmp	$LN29@xmlFACompa
$LN18@xmlFACompa:

; 2526 :         case XML_REGEXP_STRING:
; 2527 :             if (!deep)

	cmp	DWORD PTR _deep$[ebp], 0
	jne	SHORT $LN19@xmlFACompa

; 2528 :                 ret = (atom1->valuep != atom2->valuep);

	mov	eax, DWORD PTR _atom1$[ebp]
	mov	ecx, DWORD PTR _atom2$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+20]
	je	SHORT $LN33@xmlFACompa
	mov	DWORD PTR tv89[ebp], 1
	jmp	SHORT $LN34@xmlFACompa
$LN33@xmlFACompa:
	mov	DWORD PTR tv89[ebp], 0
$LN34@xmlFACompa:
	mov	eax, DWORD PTR tv89[ebp]
	mov	DWORD PTR _ret$[ebp], eax
	jmp	SHORT $LN20@xmlFACompa
$LN19@xmlFACompa:

; 2529 :             else
; 2530 :                 ret = xmlRegStrEqualWildcard((xmlChar *)atom1->valuep,

	mov	ecx, DWORD PTR _atom2$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _atom1$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_xmlRegStrEqualWildcard
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
$LN20@xmlFACompa:

; 2531 :                                              (xmlChar *)atom2->valuep);
; 2532 : 	    break;

	jmp	$done$39

; 2533 :         case XML_REGEXP_EPSILON:
; 2534 : 	    goto not_determinist;

	jmp	$not_determinist$40
$LN22@xmlFACompa:

; 2535 :         case XML_REGEXP_CHARVAL:
; 2536 : 	    if (atom2->type == XML_REGEXP_CHARVAL) {

	mov	edx, DWORD PTR _atom2$[ebp]
	cmp	DWORD PTR [edx+4], 2
	jne	SHORT $LN23@xmlFACompa

; 2537 : 		ret = (atom1->codepoint == atom2->codepoint);

	mov	eax, DWORD PTR _atom1$[ebp]
	mov	ecx, DWORD PTR _atom2$[ebp]
	mov	edx, DWORD PTR [eax+32]
	cmp	edx, DWORD PTR [ecx+32]
	jne	SHORT $LN35@xmlFACompa
	mov	DWORD PTR tv132[ebp], 1
	jmp	SHORT $LN36@xmlFACompa
$LN35@xmlFACompa:
	mov	DWORD PTR tv132[ebp], 0
$LN36@xmlFACompa:
	mov	eax, DWORD PTR tv132[ebp]
	mov	DWORD PTR _ret$[ebp], eax

; 2538 : 	    } else {

	jmp	SHORT $LN24@xmlFACompa
$LN23@xmlFACompa:

; 2539 : 	        ret = xmlRegCheckCharacter(atom2, atom1->codepoint);

	mov	ecx, DWORD PTR _atom1$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _atom2$[ebp]
	push	eax
	call	_xmlRegCheckCharacter
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2540 : 		if (ret < 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN24@xmlFACompa

; 2541 : 		    ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN24@xmlFACompa:

; 2542 : 	    }
; 2543 : 	    break;

	jmp	$done$39
$LN26@xmlFACompa:

; 2544 :         case XML_REGEXP_RANGES:
; 2545 : 	    if (atom2->type == XML_REGEXP_RANGES) {

	mov	ecx, DWORD PTR _atom2$[ebp]
	cmp	DWORD PTR [ecx+4], 3
	jne	$LN27@xmlFACompa

; 2546 : 	        int i, j, res;
; 2547 : 		xmlRegRangePtr r1, r2;
; 2548 : 
; 2549 : 		/*
; 2550 : 		 * need to check that none of the ranges eventually matches
; 2551 : 		 */
; 2552 : 		for (i = 0;i < atom1->nbRanges;i++) {

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN6@xmlFACompa
$LN4@xmlFACompa:
	mov	edx, DWORD PTR _i$5[ebp]
	add	edx, 1
	mov	DWORD PTR _i$5[ebp], edx
$LN6@xmlFACompa:
	mov	eax, DWORD PTR _atom1$[ebp]
	mov	ecx, DWORD PTR _i$5[ebp]
	cmp	ecx, DWORD PTR [eax+52]
	jge	SHORT $LN5@xmlFACompa

; 2553 : 		    for (j = 0;j < atom2->nbRanges;j++) {

	mov	DWORD PTR _j$4[ebp], 0
	jmp	SHORT $LN9@xmlFACompa
$LN7@xmlFACompa:
	mov	edx, DWORD PTR _j$4[ebp]
	add	edx, 1
	mov	DWORD PTR _j$4[ebp], edx
$LN9@xmlFACompa:
	mov	eax, DWORD PTR _atom2$[ebp]
	mov	ecx, DWORD PTR _j$4[ebp]
	cmp	ecx, DWORD PTR [eax+52]
	jge	SHORT $LN8@xmlFACompa

; 2554 : 			r1 = atom1->ranges[i];

	mov	edx, DWORD PTR _atom1$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _i$5[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _r1$2[ebp], edx

; 2555 : 			r2 = atom2->ranges[j];

	mov	eax, DWORD PTR _atom2$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _j$4[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _r2$1[ebp], eax

; 2556 : 			res = xmlFACompareRanges(r1, r2);

	mov	ecx, DWORD PTR _r2$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _r1$2[ebp]
	push	edx
	call	_xmlFACompareRanges
	add	esp, 8
	mov	DWORD PTR _res$3[ebp], eax

; 2557 : 			if (res == 1) {

	cmp	DWORD PTR _res$3[ebp], 1
	jne	SHORT $LN28@xmlFACompa

; 2558 : 			    ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 2559 : 			    goto done;

	jmp	SHORT $done$39
$LN28@xmlFACompa:

; 2560 : 			}
; 2561 : 		    }

	jmp	SHORT $LN7@xmlFACompa
$LN8@xmlFACompa:

; 2562 : 		}

	jmp	SHORT $LN4@xmlFACompa
$LN5@xmlFACompa:

; 2563 : 		ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN27@xmlFACompa:

; 2564 : 	    }
; 2565 : 	    break;

	jmp	SHORT $done$39
$LN29@xmlFACompa:

; 2566 : 	default:
; 2567 : 	    goto not_determinist;

	jmp	SHORT $not_determinist$40
$done$39:

; 2568 :     }
; 2569 : done:
; 2570 :     if (atom1->neg != atom2->neg) {

	mov	eax, DWORD PTR _atom1$[ebp]
	mov	ecx, DWORD PTR _atom2$[ebp]
	mov	edx, DWORD PTR [eax+28]
	cmp	edx, DWORD PTR [ecx+28]
	je	SHORT $LN30@xmlFACompa

; 2571 :         ret = !ret;

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN37@xmlFACompa
	mov	DWORD PTR tv163[ebp], 1
	jmp	SHORT $LN38@xmlFACompa
$LN37@xmlFACompa:
	mov	DWORD PTR tv163[ebp], 0
$LN38@xmlFACompa:
	mov	eax, DWORD PTR tv163[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN30@xmlFACompa:

; 2572 :     }
; 2573 :     if (ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $not_determinist$40

; 2574 :         return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlFACompa
$not_determinist$40:

; 2575 : not_determinist:
; 2576 :     return(1);

	mov	eax, 1
$LN1@xmlFACompa:

; 2577 : }

	pop	edi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFACompareAtoms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAEqualAtoms
_TEXT	SEGMENT
tv85 = -16						; size = 4
tv76 = -12						; size = 4
tv71 = -8						; size = 4
_ret$ = -4						; size = 4
_atom1$ = 8						; size = 4
_atom2$ = 12						; size = 4
_deep$ = 16						; size = 4
_xmlFAEqualAtoms PROC					; COMDAT

; 2456 : xmlFAEqualAtoms(xmlRegAtomPtr atom1, xmlRegAtomPtr atom2, int deep) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 2457 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 2458 : 
; 2459 :     if (atom1 == atom2)

	mov	eax, DWORD PTR _atom1$[ebp]
	cmp	eax, DWORD PTR _atom2$[ebp]
	jne	SHORT $LN4@xmlFAEqual

; 2460 : 	return(1);

	mov	eax, 1
	jmp	$LN1@xmlFAEqual
$LN4@xmlFAEqual:

; 2461 :     if ((atom1 == NULL) || (atom2 == NULL))

	cmp	DWORD PTR _atom1$[ebp], 0
	je	SHORT $LN6@xmlFAEqual
	cmp	DWORD PTR _atom2$[ebp], 0
	jne	SHORT $LN5@xmlFAEqual
$LN6@xmlFAEqual:

; 2462 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlFAEqual
$LN5@xmlFAEqual:

; 2463 : 
; 2464 :     if (atom1->type != atom2->type)

	mov	ecx, DWORD PTR _atom1$[ebp]
	mov	edx, DWORD PTR _atom2$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	je	SHORT $LN7@xmlFAEqual

; 2465 :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlFAEqual
$LN7@xmlFAEqual:

; 2466 :     switch (atom1->type) {

	mov	ecx, DWORD PTR _atom1$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv71[ebp], edx
	mov	eax, DWORD PTR tv71[ebp]
	sub	eax, 1
	mov	DWORD PTR tv71[ebp], eax
	cmp	DWORD PTR tv71[ebp], 4
	ja	$LN2@xmlFAEqual
	mov	ecx, DWORD PTR tv71[ebp]
	jmp	DWORD PTR $LN20@xmlFAEqual[ecx*4]
$LN8@xmlFAEqual:

; 2467 :         case XML_REGEXP_EPSILON:
; 2468 : 	    ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 2469 : 	    break;

	jmp	SHORT $LN2@xmlFAEqual
$LN9@xmlFAEqual:

; 2470 :         case XML_REGEXP_STRING:
; 2471 :             if (!deep)

	cmp	DWORD PTR _deep$[ebp], 0
	jne	SHORT $LN10@xmlFAEqual

; 2472 :                 ret = (atom1->valuep == atom2->valuep);

	mov	edx, DWORD PTR _atom1$[ebp]
	mov	eax, DWORD PTR _atom2$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN16@xmlFAEqual
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN17@xmlFAEqual
$LN16@xmlFAEqual:
	mov	DWORD PTR tv76[ebp], 0
$LN17@xmlFAEqual:
	mov	edx, DWORD PTR tv76[ebp]
	mov	DWORD PTR _ret$[ebp], edx
	jmp	SHORT $LN11@xmlFAEqual
$LN10@xmlFAEqual:

; 2473 :             else
; 2474 :                 ret = xmlStrEqual((xmlChar *)atom1->valuep,

	mov	eax, DWORD PTR _atom2$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _atom1$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
$LN11@xmlFAEqual:

; 2475 :                                   (xmlChar *)atom2->valuep);
; 2476 : 	    break;

	jmp	SHORT $LN2@xmlFAEqual
$LN12@xmlFAEqual:

; 2477 :         case XML_REGEXP_CHARVAL:
; 2478 : 	    ret = (atom1->codepoint == atom2->codepoint);

	mov	ecx, DWORD PTR _atom1$[ebp]
	mov	edx, DWORD PTR _atom2$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	cmp	eax, DWORD PTR [edx+32]
	jne	SHORT $LN18@xmlFAEqual
	mov	DWORD PTR tv85[ebp], 1
	jmp	SHORT $LN19@xmlFAEqual
$LN18@xmlFAEqual:
	mov	DWORD PTR tv85[ebp], 0
$LN19@xmlFAEqual:
	mov	ecx, DWORD PTR tv85[ebp]
	mov	DWORD PTR _ret$[ebp], ecx

; 2479 : 	    break;

	jmp	SHORT $LN2@xmlFAEqual
$LN13@xmlFAEqual:

; 2480 : 	case XML_REGEXP_RANGES:
; 2481 : 	    /* too hard to do in the general case */
; 2482 : 	    ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN2@xmlFAEqual:

; 2483 : 	default:
; 2484 : 	    break;
; 2485 :     }
; 2486 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlFAEqual:

; 2487 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN20@xmlFAEqual:
	DD	$LN8@xmlFAEqual
	DD	$LN12@xmlFAEqual
	DD	$LN13@xmlFAEqual
	DD	$LN2@xmlFAEqual
	DD	$LN9@xmlFAEqual
_xmlFAEqualAtoms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFACompareAtomTypes
_TEXT	SEGMENT
tv78 = -8						; size = 4
_tmp$1 = -4						; size = 4
_type1$ = 8						; size = 4
_type2$ = 12						; size = 4
_xmlFACompareAtomTypes PROC				; COMDAT

; 2254 : xmlFACompareAtomTypes(xmlRegAtomType type1, xmlRegAtomType type2) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 2255 :     if ((type1 == XML_REGEXP_EPSILON) ||
; 2256 :         (type1 == XML_REGEXP_CHARVAL) ||
; 2257 : 	(type1 == XML_REGEXP_RANGES) ||
; 2258 : 	(type1 == XML_REGEXP_SUBREG) ||
; 2259 : 	(type1 == XML_REGEXP_STRING) ||

	cmp	DWORD PTR _type1$[ebp], 1
	je	SHORT $LN5@xmlFACompa
	cmp	DWORD PTR _type1$[ebp], 2
	je	SHORT $LN5@xmlFACompa
	cmp	DWORD PTR _type1$[ebp], 3
	je	SHORT $LN5@xmlFACompa
	cmp	DWORD PTR _type1$[ebp], 4
	je	SHORT $LN5@xmlFACompa
	cmp	DWORD PTR _type1$[ebp], 5
	je	SHORT $LN5@xmlFACompa
	cmp	DWORD PTR _type1$[ebp], 6
	jne	SHORT $LN4@xmlFACompa
$LN5@xmlFACompa:

; 2260 : 	(type1 == XML_REGEXP_ANYCHAR))
; 2261 : 	return(1);

	mov	eax, 1
	jmp	$LN1@xmlFACompa
$LN4@xmlFACompa:

; 2262 :     if ((type2 == XML_REGEXP_EPSILON) ||
; 2263 :         (type2 == XML_REGEXP_CHARVAL) ||
; 2264 : 	(type2 == XML_REGEXP_RANGES) ||
; 2265 : 	(type2 == XML_REGEXP_SUBREG) ||
; 2266 : 	(type2 == XML_REGEXP_STRING) ||

	cmp	DWORD PTR _type2$[ebp], 1
	je	SHORT $LN7@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 2
	je	SHORT $LN7@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 3
	je	SHORT $LN7@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 4
	je	SHORT $LN7@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 5
	je	SHORT $LN7@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 6
	jne	SHORT $LN6@xmlFACompa
$LN7@xmlFACompa:

; 2267 : 	(type2 == XML_REGEXP_ANYCHAR))
; 2268 : 	return(1);

	mov	eax, 1
	jmp	$LN1@xmlFACompa
$LN6@xmlFACompa:

; 2269 : 
; 2270 :     if (type1 == type2) return(1);

	mov	eax, DWORD PTR _type1$[ebp]
	cmp	eax, DWORD PTR _type2$[ebp]
	jne	SHORT $LN8@xmlFACompa
	mov	eax, 1
	jmp	$LN1@xmlFACompa
$LN8@xmlFACompa:

; 2271 : 
; 2272 :     /* simplify subsequent compares by making sure type1 < type2 */
; 2273 :     if (type1 > type2) {

	mov	ecx, DWORD PTR _type1$[ebp]
	cmp	ecx, DWORD PTR _type2$[ebp]
	jle	SHORT $LN9@xmlFACompa

; 2274 :         xmlRegAtomType tmp = type1;

	mov	edx, DWORD PTR _type1$[ebp]
	mov	DWORD PTR _tmp$1[ebp], edx

; 2275 : 	type1 = type2;

	mov	eax, DWORD PTR _type2$[ebp]
	mov	DWORD PTR _type1$[ebp], eax

; 2276 : 	type2 = tmp;

	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR _type2$[ebp], ecx
$LN9@xmlFACompa:

; 2277 :     }
; 2278 :     switch (type1) {

	mov	edx, DWORD PTR _type1$[ebp]
	mov	DWORD PTR tv78[ebp], edx
	mov	eax, DWORD PTR tv78[ebp]
	sub	eax, 7
	mov	DWORD PTR tv78[ebp], eax
	cmp	DWORD PTR tv78[ebp], 128		; 00000080H
	ja	$LN2@xmlFACompa
	mov	ecx, DWORD PTR tv78[ebp]
	movzx	edx, BYTE PTR $LN75@xmlFACompa[ecx]
	jmp	DWORD PTR $LN76@xmlFACompa[edx*4]
$LN10@xmlFACompa:

; 2279 :         case XML_REGEXP_ANYSPACE: /* \s */
; 2280 : 	    /* can't be a letter, number, mark, pontuation, symbol */
; 2281 : 	    if ((type2 == XML_REGEXP_NOTSPACE) ||
; 2282 : 		((type2 >= XML_REGEXP_LETTER) &&
; 2283 : 		 (type2 <= XML_REGEXP_LETTER_OTHERS)) ||
; 2284 : 	        ((type2 >= XML_REGEXP_NUMBER) &&
; 2285 : 		 (type2 <= XML_REGEXP_NUMBER_OTHERS)) ||
; 2286 : 	        ((type2 >= XML_REGEXP_MARK) &&
; 2287 : 		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
; 2288 : 	        ((type2 >= XML_REGEXP_PUNCT) &&
; 2289 : 		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||

	cmp	DWORD PTR _type2$[ebp], 8
	je	SHORT $LN12@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 100		; 00000064H
	jl	SHORT $LN13@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 105		; 00000069H
	jle	SHORT $LN12@xmlFACompa
$LN13@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 110		; 0000006eH
	jl	SHORT $LN14@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 113		; 00000071H
	jle	SHORT $LN12@xmlFACompa
$LN14@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 106		; 0000006aH
	jl	SHORT $LN15@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 109		; 0000006dH
	jle	SHORT $LN12@xmlFACompa
$LN15@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 114		; 00000072H
	jl	SHORT $LN16@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 121		; 00000079H
	jle	SHORT $LN12@xmlFACompa
$LN16@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 126		; 0000007eH
	jl	SHORT $LN11@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 130		; 00000082H
	jg	SHORT $LN11@xmlFACompa
$LN12@xmlFACompa:

; 2290 : 	        ((type2 >= XML_REGEXP_SYMBOL) &&
; 2291 : 		 (type2 <= XML_REGEXP_SYMBOL_OTHERS))
; 2292 : 	        ) return(0);

	xor	eax, eax
	jmp	$LN1@xmlFACompa
$LN11@xmlFACompa:

; 2293 : 	    break;

	jmp	$LN2@xmlFACompa

; 2294 :         case XML_REGEXP_NOTSPACE: /* \S */
; 2295 : 	    break;

	jmp	$LN2@xmlFACompa
$LN18@xmlFACompa:

; 2296 :         case XML_REGEXP_INITNAME: /* \l */
; 2297 : 	    /* can't be a number, mark, separator, pontuation, symbol or other */
; 2298 : 	    if ((type2 == XML_REGEXP_NOTINITNAME) ||
; 2299 : 	        ((type2 >= XML_REGEXP_NUMBER) &&
; 2300 : 		 (type2 <= XML_REGEXP_NUMBER_OTHERS)) ||
; 2301 : 	        ((type2 >= XML_REGEXP_MARK) &&
; 2302 : 		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
; 2303 : 	        ((type2 >= XML_REGEXP_SEPAR) &&
; 2304 : 		 (type2 <= XML_REGEXP_SEPAR_PARA)) ||
; 2305 : 	        ((type2 >= XML_REGEXP_PUNCT) &&
; 2306 : 		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
; 2307 : 	        ((type2 >= XML_REGEXP_SYMBOL) &&
; 2308 : 		 (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||

	cmp	DWORD PTR _type2$[ebp], 10		; 0000000aH
	je	SHORT $LN20@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 110		; 0000006eH
	jl	SHORT $LN21@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 113		; 00000071H
	jle	SHORT $LN20@xmlFACompa
$LN21@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 106		; 0000006aH
	jl	SHORT $LN22@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 109		; 0000006dH
	jle	SHORT $LN20@xmlFACompa
$LN22@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 122		; 0000007aH
	jl	SHORT $LN23@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 125		; 0000007dH
	jle	SHORT $LN20@xmlFACompa
$LN23@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 114		; 00000072H
	jl	SHORT $LN24@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 121		; 00000079H
	jle	SHORT $LN20@xmlFACompa
$LN24@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 126		; 0000007eH
	jl	SHORT $LN25@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 130		; 00000082H
	jle	SHORT $LN20@xmlFACompa
$LN25@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 131		; 00000083H
	jl	SHORT $LN19@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 135		; 00000087H
	jg	SHORT $LN19@xmlFACompa
$LN20@xmlFACompa:

; 2309 : 	        ((type2 >= XML_REGEXP_OTHER) &&
; 2310 : 		 (type2 <= XML_REGEXP_OTHER_NA))
; 2311 : 		) return(0);

	xor	eax, eax
	jmp	$LN1@xmlFACompa
$LN19@xmlFACompa:

; 2312 : 	    break;

	jmp	$LN2@xmlFACompa

; 2313 :         case XML_REGEXP_NOTINITNAME: /* \L */
; 2314 : 	    break;

	jmp	$LN2@xmlFACompa
$LN27@xmlFACompa:

; 2315 :         case XML_REGEXP_NAMECHAR: /* \c */
; 2316 : 	    /* can't be a mark, separator, pontuation, symbol or other */
; 2317 : 	    if ((type2 == XML_REGEXP_NOTNAMECHAR) ||
; 2318 : 	        ((type2 >= XML_REGEXP_MARK) &&
; 2319 : 		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
; 2320 : 	        ((type2 >= XML_REGEXP_PUNCT) &&
; 2321 : 		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
; 2322 : 	        ((type2 >= XML_REGEXP_SEPAR) &&
; 2323 : 		 (type2 <= XML_REGEXP_SEPAR_PARA)) ||
; 2324 : 	        ((type2 >= XML_REGEXP_SYMBOL) &&
; 2325 : 		 (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||

	cmp	DWORD PTR _type2$[ebp], 12		; 0000000cH
	je	SHORT $LN29@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 106		; 0000006aH
	jl	SHORT $LN30@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 109		; 0000006dH
	jle	SHORT $LN29@xmlFACompa
$LN30@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 114		; 00000072H
	jl	SHORT $LN31@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 121		; 00000079H
	jle	SHORT $LN29@xmlFACompa
$LN31@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 122		; 0000007aH
	jl	SHORT $LN32@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 125		; 0000007dH
	jle	SHORT $LN29@xmlFACompa
$LN32@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 126		; 0000007eH
	jl	SHORT $LN33@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 130		; 00000082H
	jle	SHORT $LN29@xmlFACompa
$LN33@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 131		; 00000083H
	jl	SHORT $LN28@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 135		; 00000087H
	jg	SHORT $LN28@xmlFACompa
$LN29@xmlFACompa:

; 2326 : 	        ((type2 >= XML_REGEXP_OTHER) &&
; 2327 : 		 (type2 <= XML_REGEXP_OTHER_NA))
; 2328 : 		) return(0);

	xor	eax, eax
	jmp	$LN1@xmlFACompa
$LN28@xmlFACompa:

; 2329 : 	    break;

	jmp	$LN2@xmlFACompa

; 2330 :         case XML_REGEXP_NOTNAMECHAR: /* \C */
; 2331 : 	    break;

	jmp	$LN2@xmlFACompa
$LN35@xmlFACompa:

; 2332 :         case XML_REGEXP_DECIMAL: /* \d */
; 2333 : 	    /* can't be a letter, mark, separator, pontuation, symbol or other */
; 2334 : 	    if ((type2 == XML_REGEXP_NOTDECIMAL) ||
; 2335 : 	        (type2 == XML_REGEXP_REALCHAR) ||
; 2336 : 		((type2 >= XML_REGEXP_LETTER) &&
; 2337 : 		 (type2 <= XML_REGEXP_LETTER_OTHERS)) ||
; 2338 : 	        ((type2 >= XML_REGEXP_MARK) &&
; 2339 : 		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
; 2340 : 	        ((type2 >= XML_REGEXP_PUNCT) &&
; 2341 : 		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
; 2342 : 	        ((type2 >= XML_REGEXP_SEPAR) &&
; 2343 : 		 (type2 <= XML_REGEXP_SEPAR_PARA)) ||
; 2344 : 	        ((type2 >= XML_REGEXP_SYMBOL) &&
; 2345 : 		 (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||

	cmp	DWORD PTR _type2$[ebp], 14		; 0000000eH
	je	SHORT $LN37@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 15		; 0000000fH
	je	SHORT $LN37@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 100		; 00000064H
	jl	SHORT $LN38@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 105		; 00000069H
	jle	SHORT $LN37@xmlFACompa
$LN38@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 106		; 0000006aH
	jl	SHORT $LN39@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 109		; 0000006dH
	jle	SHORT $LN37@xmlFACompa
$LN39@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 114		; 00000072H
	jl	SHORT $LN40@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 121		; 00000079H
	jle	SHORT $LN37@xmlFACompa
$LN40@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 122		; 0000007aH
	jl	SHORT $LN41@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 125		; 0000007dH
	jle	SHORT $LN37@xmlFACompa
$LN41@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 126		; 0000007eH
	jl	SHORT $LN42@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 130		; 00000082H
	jle	SHORT $LN37@xmlFACompa
$LN42@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 131		; 00000083H
	jl	SHORT $LN36@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 135		; 00000087H
	jg	SHORT $LN36@xmlFACompa
$LN37@xmlFACompa:

; 2346 : 	        ((type2 >= XML_REGEXP_OTHER) &&
; 2347 : 		 (type2 <= XML_REGEXP_OTHER_NA))
; 2348 : 		)return(0);

	xor	eax, eax
	jmp	$LN1@xmlFACompa
$LN36@xmlFACompa:

; 2349 : 	    break;

	jmp	$LN2@xmlFACompa

; 2350 :         case XML_REGEXP_NOTDECIMAL: /* \D */
; 2351 : 	    break;

	jmp	$LN2@xmlFACompa
$LN44@xmlFACompa:

; 2352 :         case XML_REGEXP_REALCHAR: /* \w */
; 2353 : 	    /* can't be a mark, separator, pontuation, symbol or other */
; 2354 : 	    if ((type2 == XML_REGEXP_NOTDECIMAL) ||
; 2355 : 	        ((type2 >= XML_REGEXP_MARK) &&
; 2356 : 		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
; 2357 : 	        ((type2 >= XML_REGEXP_PUNCT) &&
; 2358 : 		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
; 2359 : 	        ((type2 >= XML_REGEXP_SEPAR) &&
; 2360 : 		 (type2 <= XML_REGEXP_SEPAR_PARA)) ||
; 2361 : 	        ((type2 >= XML_REGEXP_SYMBOL) &&
; 2362 : 		 (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||

	cmp	DWORD PTR _type2$[ebp], 14		; 0000000eH
	je	SHORT $LN46@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 106		; 0000006aH
	jl	SHORT $LN47@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 109		; 0000006dH
	jle	SHORT $LN46@xmlFACompa
$LN47@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 114		; 00000072H
	jl	SHORT $LN48@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 121		; 00000079H
	jle	SHORT $LN46@xmlFACompa
$LN48@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 122		; 0000007aH
	jl	SHORT $LN49@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 125		; 0000007dH
	jle	SHORT $LN46@xmlFACompa
$LN49@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 126		; 0000007eH
	jl	SHORT $LN50@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 130		; 00000082H
	jle	SHORT $LN46@xmlFACompa
$LN50@xmlFACompa:
	cmp	DWORD PTR _type2$[ebp], 131		; 00000083H
	jl	SHORT $LN45@xmlFACompa
	cmp	DWORD PTR _type2$[ebp], 135		; 00000087H
	jg	SHORT $LN45@xmlFACompa
$LN46@xmlFACompa:

; 2363 : 	        ((type2 >= XML_REGEXP_OTHER) &&
; 2364 : 		 (type2 <= XML_REGEXP_OTHER_NA))
; 2365 : 		)return(0);

	xor	eax, eax
	jmp	$LN1@xmlFACompa
$LN45@xmlFACompa:

; 2366 : 	    break;

	jmp	$LN2@xmlFACompa

; 2367 :         case XML_REGEXP_NOTREALCHAR: /* \W */
; 2368 : 	    break;

	jmp	$LN2@xmlFACompa
$LN52@xmlFACompa:

; 2369 : 	/*
; 2370 : 	 * at that point we know both type 1 and type2 are from
; 2371 : 	 * character categories are ordered and are different,
; 2372 : 	 * it becomes simple because this is a partition
; 2373 : 	 */
; 2374 :         case XML_REGEXP_LETTER:
; 2375 : 	    if (type2 <= XML_REGEXP_LETTER_OTHERS)

	cmp	DWORD PTR _type2$[ebp], 105		; 00000069H
	jg	SHORT $LN53@xmlFACompa

; 2376 : 	        return(1);

	mov	eax, 1
	jmp	$LN1@xmlFACompa
$LN53@xmlFACompa:

; 2377 : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlFACompa
$LN54@xmlFACompa:

; 2378 :         case XML_REGEXP_LETTER_UPPERCASE:
; 2379 :         case XML_REGEXP_LETTER_LOWERCASE:
; 2380 :         case XML_REGEXP_LETTER_TITLECASE:
; 2381 :         case XML_REGEXP_LETTER_MODIFIER:
; 2382 :         case XML_REGEXP_LETTER_OTHERS:
; 2383 : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlFACompa
$LN55@xmlFACompa:

; 2384 :         case XML_REGEXP_MARK:
; 2385 : 	    if (type2 <= XML_REGEXP_MARK_ENCLOSING)

	cmp	DWORD PTR _type2$[ebp], 109		; 0000006dH
	jg	SHORT $LN56@xmlFACompa

; 2386 : 	        return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlFACompa
$LN56@xmlFACompa:

; 2387 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlFACompa
$LN57@xmlFACompa:

; 2388 :         case XML_REGEXP_MARK_NONSPACING:
; 2389 :         case XML_REGEXP_MARK_SPACECOMBINING:
; 2390 :         case XML_REGEXP_MARK_ENCLOSING:
; 2391 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlFACompa
$LN58@xmlFACompa:

; 2392 :         case XML_REGEXP_NUMBER:
; 2393 : 	    if (type2 <= XML_REGEXP_NUMBER_OTHERS)

	cmp	DWORD PTR _type2$[ebp], 113		; 00000071H
	jg	SHORT $LN59@xmlFACompa

; 2394 : 	        return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlFACompa
$LN59@xmlFACompa:

; 2395 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlFACompa
$LN60@xmlFACompa:

; 2396 :         case XML_REGEXP_NUMBER_DECIMAL:
; 2397 :         case XML_REGEXP_NUMBER_LETTER:
; 2398 :         case XML_REGEXP_NUMBER_OTHERS:
; 2399 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlFACompa
$LN61@xmlFACompa:

; 2400 :         case XML_REGEXP_PUNCT:
; 2401 : 	    if (type2 <= XML_REGEXP_PUNCT_OTHERS)

	cmp	DWORD PTR _type2$[ebp], 121		; 00000079H
	jg	SHORT $LN62@xmlFACompa

; 2402 : 	        return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlFACompa
$LN62@xmlFACompa:

; 2403 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlFACompa
$LN63@xmlFACompa:

; 2404 :         case XML_REGEXP_PUNCT_CONNECTOR:
; 2405 :         case XML_REGEXP_PUNCT_DASH:
; 2406 :         case XML_REGEXP_PUNCT_OPEN:
; 2407 :         case XML_REGEXP_PUNCT_CLOSE:
; 2408 :         case XML_REGEXP_PUNCT_INITQUOTE:
; 2409 :         case XML_REGEXP_PUNCT_FINQUOTE:
; 2410 :         case XML_REGEXP_PUNCT_OTHERS:
; 2411 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlFACompa
$LN64@xmlFACompa:

; 2412 :         case XML_REGEXP_SEPAR:
; 2413 : 	    if (type2 <= XML_REGEXP_SEPAR_PARA)

	cmp	DWORD PTR _type2$[ebp], 125		; 0000007dH
	jg	SHORT $LN65@xmlFACompa

; 2414 : 	        return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlFACompa
$LN65@xmlFACompa:

; 2415 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlFACompa
$LN66@xmlFACompa:

; 2416 :         case XML_REGEXP_SEPAR_SPACE:
; 2417 :         case XML_REGEXP_SEPAR_LINE:
; 2418 :         case XML_REGEXP_SEPAR_PARA:
; 2419 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlFACompa
$LN67@xmlFACompa:

; 2420 :         case XML_REGEXP_SYMBOL:
; 2421 : 	    if (type2 <= XML_REGEXP_SYMBOL_OTHERS)

	cmp	DWORD PTR _type2$[ebp], 130		; 00000082H
	jg	SHORT $LN68@xmlFACompa

; 2422 : 	        return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlFACompa
$LN68@xmlFACompa:

; 2423 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlFACompa
$LN69@xmlFACompa:

; 2424 :         case XML_REGEXP_SYMBOL_MATH:
; 2425 :         case XML_REGEXP_SYMBOL_CURRENCY:
; 2426 :         case XML_REGEXP_SYMBOL_MODIFIER:
; 2427 :         case XML_REGEXP_SYMBOL_OTHERS:
; 2428 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlFACompa
$LN70@xmlFACompa:

; 2429 :         case XML_REGEXP_OTHER:
; 2430 : 	    if (type2 <= XML_REGEXP_OTHER_NA)

	cmp	DWORD PTR _type2$[ebp], 135		; 00000087H
	jg	SHORT $LN71@xmlFACompa

; 2431 : 	        return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlFACompa
$LN71@xmlFACompa:

; 2432 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlFACompa
$LN72@xmlFACompa:

; 2433 :         case XML_REGEXP_OTHER_CONTROL:
; 2434 :         case XML_REGEXP_OTHER_FORMAT:
; 2435 :         case XML_REGEXP_OTHER_PRIVATE:
; 2436 :         case XML_REGEXP_OTHER_NA:
; 2437 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlFACompa
$LN2@xmlFACompa:

; 2438 : 	default:
; 2439 : 	    break;
; 2440 :     }
; 2441 :     return(1);

	mov	eax, 1
$LN1@xmlFACompa:

; 2442 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN76@xmlFACompa:
	DD	$LN10@xmlFACompa
	DD	$LN18@xmlFACompa
	DD	$LN27@xmlFACompa
	DD	$LN35@xmlFACompa
	DD	$LN44@xmlFACompa
	DD	$LN52@xmlFACompa
	DD	$LN54@xmlFACompa
	DD	$LN55@xmlFACompa
	DD	$LN57@xmlFACompa
	DD	$LN58@xmlFACompa
	DD	$LN60@xmlFACompa
	DD	$LN61@xmlFACompa
	DD	$LN63@xmlFACompa
	DD	$LN64@xmlFACompa
	DD	$LN66@xmlFACompa
	DD	$LN67@xmlFACompa
	DD	$LN69@xmlFACompa
	DD	$LN70@xmlFACompa
	DD	$LN72@xmlFACompa
	DD	$LN2@xmlFACompa
$LN75@xmlFACompa:
	DB	0
	DB	19					; 00000013H
	DB	1
	DB	19					; 00000013H
	DB	2
	DB	19					; 00000013H
	DB	3
	DB	19					; 00000013H
	DB	4
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	5
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	7
	DB	8
	DB	8
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
_xmlFACompareAtomTypes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFACompareRanges
_TEXT	SEGMENT
tv269 = -24						; size = 4
tv197 = -20						; size = 4
_neg$1 = -16						; size = 4
_codepoint$2 = -12					; size = 4
_tmp$3 = -8						; size = 4
_ret$ = -4						; size = 4
_range1$ = 8						; size = 4
_range2$ = 12						; size = 4
_xmlFACompareRanges PROC				; COMDAT

; 2081 : xmlFACompareRanges(xmlRegRangePtr range1, xmlRegRangePtr range2) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 2082 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 2083 : 
; 2084 :     if ((range1->type == XML_REGEXP_RANGES) ||
; 2085 :         (range2->type == XML_REGEXP_RANGES) ||
; 2086 :         (range2->type == XML_REGEXP_SUBREG) ||
; 2087 :         (range1->type == XML_REGEXP_SUBREG) ||
; 2088 :         (range1->type == XML_REGEXP_STRING) ||

	mov	eax, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [eax+4], 3
	je	SHORT $LN8@xmlFACompa
	mov	ecx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [ecx+4], 3
	je	SHORT $LN8@xmlFACompa
	mov	edx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [edx+4], 4
	je	SHORT $LN8@xmlFACompa
	mov	eax, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [eax+4], 4
	je	SHORT $LN8@xmlFACompa
	mov	ecx, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [ecx+4], 5
	je	SHORT $LN8@xmlFACompa
	mov	edx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [edx+4], 5
	jne	SHORT $LN7@xmlFACompa
$LN8@xmlFACompa:

; 2089 :         (range2->type == XML_REGEXP_STRING))
; 2090 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlFACompa
$LN7@xmlFACompa:

; 2091 : 
; 2092 :     /* put them in order */
; 2093 :     if (range1->type > range2->type) {

	mov	eax, DWORD PTR _range1$[ebp]
	mov	ecx, DWORD PTR _range2$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN9@xmlFACompa

; 2094 :         xmlRegRangePtr tmp;
; 2095 : 
; 2096 : 	tmp = range1;

	mov	eax, DWORD PTR _range1$[ebp]
	mov	DWORD PTR _tmp$3[ebp], eax

; 2097 : 	range1 = range2;

	mov	ecx, DWORD PTR _range2$[ebp]
	mov	DWORD PTR _range1$[ebp], ecx

; 2098 : 	range2 = tmp;

	mov	edx, DWORD PTR _tmp$3[ebp]
	mov	DWORD PTR _range2$[ebp], edx
$LN9@xmlFACompa:

; 2099 :     }
; 2100 :     if ((range1->type == XML_REGEXP_ANYCHAR) ||

	mov	eax, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [eax+4], 6
	je	SHORT $LN12@xmlFACompa
	mov	ecx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [ecx+4], 6
	jne	SHORT $LN10@xmlFACompa
$LN12@xmlFACompa:

; 2101 :         (range2->type == XML_REGEXP_ANYCHAR)) {
; 2102 : 	ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
	jmp	$LN11@xmlFACompa
$LN10@xmlFACompa:

; 2103 :     } else if ((range1->type == XML_REGEXP_EPSILON) ||

	mov	edx, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [edx+4], 1
	je	SHORT $LN15@xmlFACompa
	mov	eax, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN13@xmlFACompa
$LN15@xmlFACompa:

; 2104 :                (range2->type == XML_REGEXP_EPSILON)) {
; 2105 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlFACompa
	jmp	$LN11@xmlFACompa
$LN13@xmlFACompa:

; 2106 :     } else if (range1->type == range2->type) {

	mov	ecx, DWORD PTR _range1$[ebp]
	mov	edx, DWORD PTR _range2$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN16@xmlFACompa

; 2107 :         if (range1->type != XML_REGEXP_CHARVAL)

	mov	ecx, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [ecx+4], 2
	je	SHORT $LN18@xmlFACompa

; 2108 :             ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
	jmp	SHORT $LN19@xmlFACompa
$LN18@xmlFACompa:

; 2109 :         else if ((range1->end < range2->start) ||

	mov	edx, DWORD PTR _range1$[ebp]
	mov	eax, DWORD PTR _range2$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $LN22@xmlFACompa
	mov	edx, DWORD PTR _range2$[ebp]
	mov	eax, DWORD PTR _range1$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+8]
	jge	SHORT $LN20@xmlFACompa
$LN22@xmlFACompa:

; 2110 : 	         (range2->end < range1->start))
; 2111 : 	    ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
	jmp	SHORT $LN19@xmlFACompa
$LN20@xmlFACompa:

; 2112 : 	else
; 2113 : 	    ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN19@xmlFACompa:

; 2114 :     } else if (range1->type == XML_REGEXP_CHARVAL) {

	jmp	$LN11@xmlFACompa
$LN16@xmlFACompa:
	mov	edx, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [edx+4], 2
	jne	$LN23@xmlFACompa

; 2115 :         int codepoint;
; 2116 : 	int neg = 0;

	mov	DWORD PTR _neg$1[ebp], 0

; 2117 : 
; 2118 : 	/*
; 2119 : 	 * just check all codepoints in the range for acceptance,
; 2120 : 	 * this is usually way cheaper since done only once at
; 2121 : 	 * compilation than testing over and over at runtime or
; 2122 : 	 * pushing too many states when evaluating.
; 2123 : 	 */
; 2124 : 	if (((range1->neg == 0) && (range2->neg != 0)) ||

	mov	eax, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN27@xmlFACompa
	mov	ecx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN26@xmlFACompa
$LN27@xmlFACompa:
	mov	edx, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN25@xmlFACompa
	mov	eax, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN25@xmlFACompa
$LN26@xmlFACompa:

; 2125 : 	    ((range1->neg != 0) && (range2->neg == 0)))
; 2126 : 	    neg = 1;

	mov	DWORD PTR _neg$1[ebp], 1
$LN25@xmlFACompa:

; 2127 : 
; 2128 : 	for (codepoint = range1->start;codepoint <= range1->end ;codepoint++) {

	mov	ecx, DWORD PTR _range1$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _codepoint$2[ebp], edx
	jmp	SHORT $LN4@xmlFACompa
$LN2@xmlFACompa:
	mov	eax, DWORD PTR _codepoint$2[ebp]
	add	eax, 1
	mov	DWORD PTR _codepoint$2[ebp], eax
$LN4@xmlFACompa:
	mov	ecx, DWORD PTR _range1$[ebp]
	mov	edx, DWORD PTR _codepoint$2[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jg	SHORT $LN3@xmlFACompa

; 2129 : 	    ret = xmlRegCheckCharacterRange(range2->type, codepoint,

	mov	eax, DWORD PTR _range2$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _range2$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _range2$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	0
	mov	eax, DWORD PTR _codepoint$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _range2$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlRegCheckCharacterRange
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ret$[ebp], eax

; 2130 : 					    0, range2->start, range2->end,
; 2131 : 					    range2->blockName);
; 2132 : 	    if (ret < 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN28@xmlFACompa

; 2133 : 	        return(-1);

	or	eax, -1
	jmp	$LN1@xmlFACompa
$LN28@xmlFACompa:

; 2134 : 	    if (((neg == 1) && (ret == 0)) ||

	cmp	DWORD PTR _neg$1[ebp], 1
	jne	SHORT $LN31@xmlFACompa
	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN30@xmlFACompa
$LN31@xmlFACompa:
	cmp	DWORD PTR _neg$1[ebp], 0
	jne	SHORT $LN29@xmlFACompa
	cmp	DWORD PTR _ret$[ebp], 1
	jne	SHORT $LN29@xmlFACompa
$LN30@xmlFACompa:

; 2135 : 	        ((neg == 0) && (ret == 1)))
; 2136 : 		return(1);

	mov	eax, 1
	jmp	$LN1@xmlFACompa
$LN29@xmlFACompa:

; 2137 : 	}

	jmp	SHORT $LN2@xmlFACompa
$LN3@xmlFACompa:

; 2138 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlFACompa
	jmp	$LN11@xmlFACompa
$LN23@xmlFACompa:

; 2139 :     } else if ((range1->type == XML_REGEXP_BLOCK_NAME) ||

	mov	eax, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [eax+4], 136			; 00000088H
	je	SHORT $LN34@xmlFACompa
	mov	ecx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [ecx+4], 136			; 00000088H
	jne	SHORT $LN32@xmlFACompa
$LN34@xmlFACompa:

; 2140 :                (range2->type == XML_REGEXP_BLOCK_NAME)) {
; 2141 : 	if (range1->type == range2->type) {

	mov	edx, DWORD PTR _range1$[ebp]
	mov	eax, DWORD PTR _range2$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN35@xmlFACompa

; 2142 : 	    ret = xmlStrEqual(range1->blockName, range2->blockName);

	mov	edx, DWORD PTR _range2$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _range1$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2143 : 	} else {

	jmp	SHORT $LN36@xmlFACompa
$LN35@xmlFACompa:

; 2144 : 	    /*
; 2145 : 	     * comparing a block range with anything else is way
; 2146 : 	     * too costly, and maintining the table is like too much
; 2147 : 	     * memory too, so let's force the automata to save state
; 2148 : 	     * here.
; 2149 : 	     */
; 2150 : 	    return(1);

	mov	eax, 1
	jmp	$LN1@xmlFACompa
$LN36@xmlFACompa:

; 2151 : 	}

	jmp	$LN11@xmlFACompa
$LN32@xmlFACompa:

; 2152 :     } else if ((range1->type < XML_REGEXP_LETTER) ||

	mov	eax, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [eax+4], 100			; 00000064H
	jl	SHORT $LN39@xmlFACompa
	mov	ecx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [ecx+4], 100			; 00000064H
	jge	$LN37@xmlFACompa
$LN39@xmlFACompa:

; 2153 :                (range2->type < XML_REGEXP_LETTER)) {
; 2154 : 	if ((range1->type == XML_REGEXP_ANYSPACE) &&

	mov	edx, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [edx+4], 7
	jne	SHORT $LN40@xmlFACompa
	mov	eax, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [eax+4], 8
	jne	SHORT $LN40@xmlFACompa

; 2155 : 	    (range2->type == XML_REGEXP_NOTSPACE))
; 2156 : 	    ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
	jmp	SHORT $LN41@xmlFACompa
$LN40@xmlFACompa:

; 2157 : 	else if ((range1->type == XML_REGEXP_INITNAME) &&

	mov	ecx, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [ecx+4], 9
	jne	SHORT $LN42@xmlFACompa
	mov	edx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [edx+4], 10			; 0000000aH
	jne	SHORT $LN42@xmlFACompa

; 2158 : 	         (range2->type == XML_REGEXP_NOTINITNAME))
; 2159 : 	    ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
	jmp	SHORT $LN41@xmlFACompa
$LN42@xmlFACompa:

; 2160 : 	else if ((range1->type == XML_REGEXP_NAMECHAR) &&

	mov	eax, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [eax+4], 11			; 0000000bH
	jne	SHORT $LN44@xmlFACompa
	mov	ecx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [ecx+4], 12			; 0000000cH
	jne	SHORT $LN44@xmlFACompa

; 2161 : 	         (range2->type == XML_REGEXP_NOTNAMECHAR))
; 2162 : 	    ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
	jmp	SHORT $LN41@xmlFACompa
$LN44@xmlFACompa:

; 2163 : 	else if ((range1->type == XML_REGEXP_DECIMAL) &&

	mov	edx, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [edx+4], 13			; 0000000dH
	jne	SHORT $LN46@xmlFACompa
	mov	eax, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [eax+4], 14			; 0000000eH
	jne	SHORT $LN46@xmlFACompa

; 2164 : 	         (range2->type == XML_REGEXP_NOTDECIMAL))
; 2165 : 	    ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
	jmp	SHORT $LN41@xmlFACompa
$LN46@xmlFACompa:

; 2166 : 	else if ((range1->type == XML_REGEXP_REALCHAR) &&

	mov	ecx, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [ecx+4], 15			; 0000000fH
	jne	SHORT $LN48@xmlFACompa
	mov	edx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [edx+4], 16			; 00000010H
	jne	SHORT $LN48@xmlFACompa

; 2167 : 	         (range2->type == XML_REGEXP_NOTREALCHAR))
; 2168 : 	    ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
	jmp	SHORT $LN41@xmlFACompa
$LN48@xmlFACompa:

; 2169 : 	else {
; 2170 : 	    /* same thing to limit complexity */
; 2171 : 	    return(1);

	mov	eax, 1
	jmp	$LN1@xmlFACompa
$LN41@xmlFACompa:

; 2172 : 	}
; 2173 :     } else {

	jmp	$LN11@xmlFACompa
$LN37@xmlFACompa:

; 2174 :         ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 2175 :         /* range1->type < range2->type here */
; 2176 :         switch (range1->type) {

	mov	eax, DWORD PTR _range1$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv197[ebp], ecx
	mov	edx, DWORD PTR tv197[ebp]
	sub	edx, 100				; 00000064H
	mov	DWORD PTR tv197[ebp], edx
	cmp	DWORD PTR tv197[ebp], 31		; 0000001fH
	ja	$LN71@xmlFACompa
	mov	eax, DWORD PTR tv197[ebp]
	movzx	ecx, BYTE PTR $LN80@xmlFACompa[eax]
	jmp	DWORD PTR $LN81@xmlFACompa[ecx*4]
$LN50@xmlFACompa:

; 2177 : 	    case XML_REGEXP_LETTER:
; 2178 : 	         /* all disjoint except in the subgroups */
; 2179 : 	         if ((range2->type == XML_REGEXP_LETTER_UPPERCASE) ||
; 2180 : 		     (range2->type == XML_REGEXP_LETTER_LOWERCASE) ||
; 2181 : 		     (range2->type == XML_REGEXP_LETTER_TITLECASE) ||
; 2182 : 		     (range2->type == XML_REGEXP_LETTER_MODIFIER) ||

	mov	edx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [edx+4], 101			; 00000065H
	je	SHORT $LN52@xmlFACompa
	mov	eax, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [eax+4], 102			; 00000066H
	je	SHORT $LN52@xmlFACompa
	mov	ecx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [ecx+4], 103			; 00000067H
	je	SHORT $LN52@xmlFACompa
	mov	edx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [edx+4], 104			; 00000068H
	je	SHORT $LN52@xmlFACompa
	mov	eax, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [eax+4], 105			; 00000069H
	jne	SHORT $LN51@xmlFACompa
$LN52@xmlFACompa:

; 2183 : 		     (range2->type == XML_REGEXP_LETTER_OTHERS))
; 2184 : 		     ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN51@xmlFACompa:

; 2185 : 		 break;

	jmp	$LN11@xmlFACompa
$LN53@xmlFACompa:

; 2186 : 	    case XML_REGEXP_MARK:
; 2187 : 	         if ((range2->type == XML_REGEXP_MARK_NONSPACING) ||
; 2188 : 		     (range2->type == XML_REGEXP_MARK_SPACECOMBINING) ||

	mov	ecx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [ecx+4], 107			; 0000006bH
	je	SHORT $LN55@xmlFACompa
	mov	edx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [edx+4], 108			; 0000006cH
	je	SHORT $LN55@xmlFACompa
	mov	eax, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [eax+4], 109			; 0000006dH
	jne	SHORT $LN54@xmlFACompa
$LN55@xmlFACompa:

; 2189 : 		     (range2->type == XML_REGEXP_MARK_ENCLOSING))
; 2190 : 		     ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN54@xmlFACompa:

; 2191 : 		 break;

	jmp	$LN11@xmlFACompa
$LN56@xmlFACompa:

; 2192 : 	    case XML_REGEXP_NUMBER:
; 2193 : 	         if ((range2->type == XML_REGEXP_NUMBER_DECIMAL) ||
; 2194 : 		     (range2->type == XML_REGEXP_NUMBER_LETTER) ||

	mov	ecx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [ecx+4], 111			; 0000006fH
	je	SHORT $LN58@xmlFACompa
	mov	edx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [edx+4], 112			; 00000070H
	je	SHORT $LN58@xmlFACompa
	mov	eax, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [eax+4], 113			; 00000071H
	jne	SHORT $LN57@xmlFACompa
$LN58@xmlFACompa:

; 2195 : 		     (range2->type == XML_REGEXP_NUMBER_OTHERS))
; 2196 : 		     ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN57@xmlFACompa:

; 2197 : 		 break;

	jmp	$LN11@xmlFACompa
$LN59@xmlFACompa:

; 2198 : 	    case XML_REGEXP_PUNCT:
; 2199 : 	         if ((range2->type == XML_REGEXP_PUNCT_CONNECTOR) ||
; 2200 : 		     (range2->type == XML_REGEXP_PUNCT_DASH) ||
; 2201 : 		     (range2->type == XML_REGEXP_PUNCT_OPEN) ||
; 2202 : 		     (range2->type == XML_REGEXP_PUNCT_CLOSE) ||
; 2203 : 		     (range2->type == XML_REGEXP_PUNCT_INITQUOTE) ||
; 2204 : 		     (range2->type == XML_REGEXP_PUNCT_FINQUOTE) ||

	mov	ecx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [ecx+4], 115			; 00000073H
	je	SHORT $LN61@xmlFACompa
	mov	edx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [edx+4], 116			; 00000074H
	je	SHORT $LN61@xmlFACompa
	mov	eax, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [eax+4], 117			; 00000075H
	je	SHORT $LN61@xmlFACompa
	mov	ecx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [ecx+4], 118			; 00000076H
	je	SHORT $LN61@xmlFACompa
	mov	edx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [edx+4], 119			; 00000077H
	je	SHORT $LN61@xmlFACompa
	mov	eax, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [eax+4], 120			; 00000078H
	je	SHORT $LN61@xmlFACompa
	mov	ecx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [ecx+4], 121			; 00000079H
	jne	SHORT $LN60@xmlFACompa
$LN61@xmlFACompa:

; 2205 : 		     (range2->type == XML_REGEXP_PUNCT_OTHERS))
; 2206 : 		     ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN60@xmlFACompa:

; 2207 : 		 break;

	jmp	$LN11@xmlFACompa
$LN62@xmlFACompa:

; 2208 : 	    case XML_REGEXP_SEPAR:
; 2209 : 	         if ((range2->type == XML_REGEXP_SEPAR_SPACE) ||
; 2210 : 		     (range2->type == XML_REGEXP_SEPAR_LINE) ||

	mov	edx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [edx+4], 123			; 0000007bH
	je	SHORT $LN64@xmlFACompa
	mov	eax, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [eax+4], 124			; 0000007cH
	je	SHORT $LN64@xmlFACompa
	mov	ecx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [ecx+4], 125			; 0000007dH
	jne	SHORT $LN63@xmlFACompa
$LN64@xmlFACompa:

; 2211 : 		     (range2->type == XML_REGEXP_SEPAR_PARA))
; 2212 : 		     ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN63@xmlFACompa:

; 2213 : 		 break;

	jmp	$LN11@xmlFACompa
$LN65@xmlFACompa:

; 2214 : 	    case XML_REGEXP_SYMBOL:
; 2215 : 	         if ((range2->type == XML_REGEXP_SYMBOL_MATH) ||
; 2216 : 		     (range2->type == XML_REGEXP_SYMBOL_CURRENCY) ||
; 2217 : 		     (range2->type == XML_REGEXP_SYMBOL_MODIFIER) ||

	mov	edx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [edx+4], 127			; 0000007fH
	je	SHORT $LN67@xmlFACompa
	mov	eax, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [eax+4], 128			; 00000080H
	je	SHORT $LN67@xmlFACompa
	mov	ecx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [ecx+4], 129			; 00000081H
	je	SHORT $LN67@xmlFACompa
	mov	edx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [edx+4], 130			; 00000082H
	jne	SHORT $LN66@xmlFACompa
$LN67@xmlFACompa:

; 2218 : 		     (range2->type == XML_REGEXP_SYMBOL_OTHERS))
; 2219 : 		     ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN66@xmlFACompa:

; 2220 : 		 break;

	jmp	SHORT $LN11@xmlFACompa
$LN68@xmlFACompa:

; 2221 : 	    case XML_REGEXP_OTHER:
; 2222 : 	         if ((range2->type == XML_REGEXP_OTHER_CONTROL) ||
; 2223 : 		     (range2->type == XML_REGEXP_OTHER_FORMAT) ||

	mov	eax, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [eax+4], 132			; 00000084H
	je	SHORT $LN70@xmlFACompa
	mov	ecx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [ecx+4], 133			; 00000085H
	je	SHORT $LN70@xmlFACompa
	mov	edx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [edx+4], 134			; 00000086H
	jne	SHORT $LN69@xmlFACompa
$LN70@xmlFACompa:

; 2224 : 		     (range2->type == XML_REGEXP_OTHER_PRIVATE))
; 2225 : 		     ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN69@xmlFACompa:

; 2226 : 		 break;

	jmp	SHORT $LN11@xmlFACompa
$LN71@xmlFACompa:

; 2227 :             default:
; 2228 : 	         if ((range2->type >= XML_REGEXP_LETTER) &&

	mov	eax, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [eax+4], 100			; 00000064H
	jl	SHORT $LN72@xmlFACompa
	mov	ecx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [ecx+4], 136			; 00000088H
	jge	SHORT $LN72@xmlFACompa

; 2229 : 		     (range2->type < XML_REGEXP_BLOCK_NAME))
; 2230 : 		     ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
	jmp	SHORT $LN11@xmlFACompa
$LN72@xmlFACompa:

; 2231 : 		 else {
; 2232 : 		     /* safety net ! */
; 2233 : 		     return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlFACompa
$LN11@xmlFACompa:

; 2234 : 		 }
; 2235 : 	}
; 2236 :     }
; 2237 :     if (((range1->neg == 0) && (range2->neg != 0)) ||

	mov	edx, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN76@xmlFACompa
	mov	eax, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN75@xmlFACompa
$LN76@xmlFACompa:
	mov	ecx, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN74@xmlFACompa
	mov	edx, DWORD PTR _range2$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN74@xmlFACompa
$LN75@xmlFACompa:

; 2238 :         ((range1->neg != 0) && (range2->neg == 0)))
; 2239 : 	ret = !ret;

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN78@xmlFACompa
	mov	DWORD PTR tv269[ebp], 1
	jmp	SHORT $LN79@xmlFACompa
$LN78@xmlFACompa:
	mov	DWORD PTR tv269[ebp], 0
$LN79@xmlFACompa:
	mov	eax, DWORD PTR tv269[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN74@xmlFACompa:

; 2240 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlFACompa:

; 2241 : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN81@xmlFACompa:
	DD	$LN50@xmlFACompa
	DD	$LN53@xmlFACompa
	DD	$LN56@xmlFACompa
	DD	$LN59@xmlFACompa
	DD	$LN62@xmlFACompa
	DD	$LN65@xmlFACompa
	DD	$LN68@xmlFACompa
	DD	$LN71@xmlFACompa
$LN80@xmlFACompa:
	DB	0
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	1
	DB	7
	DB	7
	DB	7
	DB	2
	DB	7
	DB	7
	DB	7
	DB	3
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	4
	DB	7
	DB	7
	DB	7
	DB	5
	DB	7
	DB	7
	DB	7
	DB	7
	DB	6
_xmlFACompareRanges ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAEliminateEpsilonTransitions
_TEXT	SEGMENT
_newto$1 = -32						; size = 4
_target$2 = -28						; size = 4
_trans$3 = -24						; size = 4
_newto$4 = -20						; size = 4
_has_epsilon$ = -16					; size = 4
_state$ = -12						; size = 4
_transnr$ = -8						; size = 4
_statenr$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlFAEliminateEpsilonTransitions PROC			; COMDAT

; 1929 : xmlFAEliminateEpsilonTransitions(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1930 :     int statenr, transnr;
; 1931 :     xmlRegStatePtr state;
; 1932 :     int has_epsilon;
; 1933 : 
; 1934 :     if (ctxt->states == NULL) return;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	SHORT $LN31@xmlFAElimi
	jmp	$LN1@xmlFAElimi
$LN31@xmlFAElimi:

; 1935 : 
; 1936 :     /*
; 1937 :      * Eliminate simple epsilon transition and the associated unreachable
; 1938 :      * states.
; 1939 :      */
; 1940 :     xmlFAEliminateSimpleEpsilonTransitions(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFAEliminateSimpleEpsilonTransitions
	add	esp, 4

; 1941 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	mov	DWORD PTR _statenr$[ebp], 0
	jmp	SHORT $LN4@xmlFAElimi
$LN2@xmlFAElimi:
	mov	edx, DWORD PTR _statenr$[ebp]
	add	edx, 1
	mov	DWORD PTR _statenr$[ebp], edx
$LN4@xmlFAElimi:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _statenr$[ebp]
	cmp	ecx, DWORD PTR [eax+48]
	jge	SHORT $LN3@xmlFAElimi

; 1942 : 	state = ctxt->states[statenr];

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _statenr$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _state$[ebp], edx

; 1943 : 	if ((state != NULL) && (state->type == XML_REGEXP_UNREACH_STATE)) {

	cmp	DWORD PTR _state$[ebp], 0
	je	SHORT $LN32@xmlFAElimi
	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax], 5
	jne	SHORT $LN32@xmlFAElimi

; 1944 : #ifdef DEBUG_REGEXP_GRAPH
; 1945 : 	    printf("Removed unreachable state %d\n", statenr);
; 1946 : #endif
; 1947 : 	    xmlRegFreeState(state);

	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xmlRegFreeState
	add	esp, 4

; 1948 : 	    ctxt->states[statenr] = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _statenr$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0
$LN32@xmlFAElimi:

; 1949 : 	}
; 1950 :     }

	jmp	SHORT $LN2@xmlFAElimi
$LN3@xmlFAElimi:

; 1951 : 
; 1952 :     has_epsilon = 0;

	mov	DWORD PTR _has_epsilon$[ebp], 0

; 1953 : 
; 1954 :     /*
; 1955 :      * Build the completed transitions bypassing the epsilons
; 1956 :      * Use a marking algorithm to avoid loops
; 1957 :      * Mark sink states too.
; 1958 :      * Process from the latests states backward to the start when
; 1959 :      * there is long cascading epsilon chains this minimize the
; 1960 :      * recursions and transition compares when adding the new ones
; 1961 :      */
; 1962 :     for (statenr = ctxt->nbStates - 1;statenr >= 0;statenr--) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+48]
	sub	eax, 1
	mov	DWORD PTR _statenr$[ebp], eax
	jmp	SHORT $LN7@xmlFAElimi
$LN5@xmlFAElimi:
	mov	ecx, DWORD PTR _statenr$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _statenr$[ebp], ecx
$LN7@xmlFAElimi:
	cmp	DWORD PTR _statenr$[ebp], 0
	jl	$LN6@xmlFAElimi

; 1963 : 	state = ctxt->states[statenr];

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _statenr$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _state$[ebp], edx

; 1964 : 	if (state == NULL)

	cmp	DWORD PTR _state$[ebp], 0
	jne	SHORT $LN33@xmlFAElimi

; 1965 : 	    continue;

	jmp	SHORT $LN5@xmlFAElimi
$LN33@xmlFAElimi:

; 1966 : 	if ((state->nbTrans == 0) &&

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN34@xmlFAElimi
	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx], 2
	je	SHORT $LN34@xmlFAElimi

; 1967 : 	    (state->type != XML_REGEXP_FINAL_STATE)) {
; 1968 : 	    state->type = XML_REGEXP_SINK_STATE;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx], 4
$LN34@xmlFAElimi:

; 1969 : 	}
; 1970 : 	for (transnr = 0;transnr < state->nbTrans;transnr++) {

	mov	DWORD PTR _transnr$[ebp], 0
	jmp	SHORT $LN10@xmlFAElimi
$LN8@xmlFAElimi:
	mov	eax, DWORD PTR _transnr$[ebp]
	add	eax, 1
	mov	DWORD PTR _transnr$[ebp], eax
$LN10@xmlFAElimi:
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR _transnr$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	$LN9@xmlFAElimi

; 1971 : 	    if ((state->trans[transnr].atom == NULL) &&

	imul	eax, DWORD PTR _transnr$[ebp], 20
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	DWORD PTR [edx+eax], 0
	jne	$LN35@xmlFAElimi
	imul	eax, DWORD PTR _transnr$[ebp], 20
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	DWORD PTR [edx+eax+4], 0
	jl	$LN35@xmlFAElimi

; 1972 : 		(state->trans[transnr].to >= 0)) {
; 1973 : 		if (state->trans[transnr].to == statenr) {

	imul	eax, DWORD PTR _transnr$[ebp], 20
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+eax+4]
	cmp	eax, DWORD PTR _statenr$[ebp]
	jne	SHORT $LN36@xmlFAElimi

; 1974 : 		    state->trans[transnr].to = -1;

	imul	ecx, DWORD PTR _transnr$[ebp], 20
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [eax+ecx+4], -1
	jmp	SHORT $LN35@xmlFAElimi
$LN36@xmlFAElimi:

; 1975 : #ifdef DEBUG_REGEXP_GRAPH
; 1976 : 		    printf("Removed loopback epsilon trans %d on %d\n",
; 1977 : 			   transnr, statenr);
; 1978 : #endif
; 1979 : 		} else if (state->trans[transnr].count < 0) {

	imul	ecx, DWORD PTR _transnr$[ebp], 20
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+28]
	cmp	DWORD PTR [eax+ecx+12], 0
	jge	SHORT $LN35@xmlFAElimi

; 1980 : 		    int newto = state->trans[transnr].to;

	imul	ecx, DWORD PTR _transnr$[ebp], 20
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+ecx+4]
	mov	DWORD PTR _newto$4[ebp], ecx

; 1981 : 
; 1982 : #ifdef DEBUG_REGEXP_GRAPH
; 1983 : 		    printf("Found epsilon trans %d from %d to %d\n",
; 1984 : 			   transnr, statenr, newto);
; 1985 : #endif
; 1986 : 		    has_epsilon = 1;

	mov	DWORD PTR _has_epsilon$[ebp], 1

; 1987 : 		    state->trans[transnr].to = -2;

	imul	edx, DWORD PTR _transnr$[ebp], 20
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+edx+4], -2		; fffffffeH

; 1988 : 		    state->mark = XML_REGEXP_MARK_START;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+4], 1

; 1989 : 		    xmlFAReduceEpsilonTransitions(ctxt, statenr,

	imul	eax, DWORD PTR _transnr$[ebp], 20
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+eax+8]
	push	eax
	mov	ecx, DWORD PTR _newto$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _statenr$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAReduceEpsilonTransitions
	add	esp, 16					; 00000010H

; 1990 : 				      newto, state->trans[transnr].counter);
; 1991 : 		    state->mark = XML_REGEXP_MARK_NORMAL;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN35@xmlFAElimi:

; 1992 : #ifdef DEBUG_REGEXP_GRAPH
; 1993 : 		} else {
; 1994 : 		    printf("Found counted transition %d on %d\n",
; 1995 : 			   transnr, statenr);
; 1996 : #endif
; 1997 : 	        }
; 1998 : 	    }
; 1999 : 	}

	jmp	$LN8@xmlFAElimi
$LN9@xmlFAElimi:

; 2000 :     }

	jmp	$LN5@xmlFAElimi
$LN6@xmlFAElimi:

; 2001 :     /*
; 2002 :      * Eliminate the epsilon transitions
; 2003 :      */
; 2004 :     if (has_epsilon) {

	cmp	DWORD PTR _has_epsilon$[ebp], 0
	je	$LN39@xmlFAElimi

; 2005 : 	for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	mov	DWORD PTR _statenr$[ebp], 0
	jmp	SHORT $LN13@xmlFAElimi
$LN11@xmlFAElimi:
	mov	edx, DWORD PTR _statenr$[ebp]
	add	edx, 1
	mov	DWORD PTR _statenr$[ebp], edx
$LN13@xmlFAElimi:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _statenr$[ebp]
	cmp	ecx, DWORD PTR [eax+48]
	jge	SHORT $LN39@xmlFAElimi

; 2006 : 	    state = ctxt->states[statenr];

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _statenr$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _state$[ebp], edx

; 2007 : 	    if (state == NULL)

	cmp	DWORD PTR _state$[ebp], 0
	jne	SHORT $LN40@xmlFAElimi

; 2008 : 		continue;

	jmp	SHORT $LN11@xmlFAElimi
$LN40@xmlFAElimi:

; 2009 : 	    for (transnr = 0;transnr < state->nbTrans;transnr++) {

	mov	DWORD PTR _transnr$[ebp], 0
	jmp	SHORT $LN16@xmlFAElimi
$LN14@xmlFAElimi:
	mov	eax, DWORD PTR _transnr$[ebp]
	add	eax, 1
	mov	DWORD PTR _transnr$[ebp], eax
$LN16@xmlFAElimi:
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR _transnr$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $LN15@xmlFAElimi

; 2010 : 		xmlRegTransPtr trans = &(state->trans[transnr]);

	imul	eax, DWORD PTR _transnr$[ebp], 20
	mov	ecx, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _trans$3[ebp], eax

; 2011 : 		if ((trans->atom == NULL) &&
; 2012 : 		    (trans->count < 0) &&

	mov	edx, DWORD PTR _trans$3[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN41@xmlFAElimi
	mov	eax, DWORD PTR _trans$3[ebp]
	cmp	DWORD PTR [eax+12], 0
	jge	SHORT $LN41@xmlFAElimi
	mov	ecx, DWORD PTR _trans$3[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jl	SHORT $LN41@xmlFAElimi

; 2013 : 		    (trans->to >= 0)) {
; 2014 : 		    trans->to = -1;

	mov	edx, DWORD PTR _trans$3[ebp]
	mov	DWORD PTR [edx+4], -1
$LN41@xmlFAElimi:

; 2015 : 		}
; 2016 : 	    }

	jmp	SHORT $LN14@xmlFAElimi
$LN15@xmlFAElimi:

; 2017 : 	}

	jmp	SHORT $LN11@xmlFAElimi
$LN39@xmlFAElimi:

; 2018 :     }
; 2019 : 
; 2020 :     /*
; 2021 :      * Use this pass to detect unreachable states too
; 2022 :      */
; 2023 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	mov	DWORD PTR _statenr$[ebp], 0
	jmp	SHORT $LN19@xmlFAElimi
$LN17@xmlFAElimi:
	mov	eax, DWORD PTR _statenr$[ebp]
	add	eax, 1
	mov	DWORD PTR _statenr$[ebp], eax
$LN19@xmlFAElimi:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _statenr$[ebp]
	cmp	edx, DWORD PTR [ecx+48]
	jge	SHORT $LN18@xmlFAElimi

; 2024 : 	state = ctxt->states[statenr];

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _statenr$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _state$[ebp], eax

; 2025 : 	if (state != NULL)

	cmp	DWORD PTR _state$[ebp], 0
	je	SHORT $LN42@xmlFAElimi

; 2026 : 	    state->reached = XML_REGEXP_MARK_NORMAL;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+12], 0
$LN42@xmlFAElimi:

; 2027 :     }

	jmp	SHORT $LN17@xmlFAElimi
$LN18@xmlFAElimi:

; 2028 :     state = ctxt->states[0];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [eax+edx]
	mov	DWORD PTR _state$[ebp], eax

; 2029 :     if (state != NULL)

	cmp	DWORD PTR _state$[ebp], 0
	je	SHORT $LN20@xmlFAElimi

; 2030 : 	state->reached = XML_REGEXP_MARK_START;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+12], 1
$LN20@xmlFAElimi:

; 2031 :     while (state != NULL) {

	cmp	DWORD PTR _state$[ebp], 0
	je	$LN21@xmlFAElimi

; 2032 : 	xmlRegStatePtr target = NULL;

	mov	DWORD PTR _target$2[ebp], 0

; 2033 : 	state->reached = XML_REGEXP_MARK_VISITED;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+12], 2

; 2034 : 	/*
; 2035 : 	 * Mark all states reachable from the current reachable state
; 2036 : 	 */
; 2037 : 	for (transnr = 0;transnr < state->nbTrans;transnr++) {

	mov	DWORD PTR _transnr$[ebp], 0
	jmp	SHORT $LN24@xmlFAElimi
$LN22@xmlFAElimi:
	mov	eax, DWORD PTR _transnr$[ebp]
	add	eax, 1
	mov	DWORD PTR _transnr$[ebp], eax
$LN24@xmlFAElimi:
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR _transnr$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	$LN23@xmlFAElimi

; 2038 : 	    if ((state->trans[transnr].to >= 0) &&

	imul	eax, DWORD PTR _transnr$[ebp], 20
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	DWORD PTR [edx+eax+4], 0
	jl	SHORT $LN44@xmlFAElimi
	imul	eax, DWORD PTR _transnr$[ebp], 20
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	DWORD PTR [edx+eax], 0
	jne	SHORT $LN45@xmlFAElimi
	imul	eax, DWORD PTR _transnr$[ebp], 20
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	DWORD PTR [edx+eax+12], 0
	jl	SHORT $LN44@xmlFAElimi
$LN45@xmlFAElimi:

; 2039 : 		((state->trans[transnr].atom != NULL) ||
; 2040 : 		 (state->trans[transnr].count >= 0))) {
; 2041 : 		int newto = state->trans[transnr].to;

	imul	eax, DWORD PTR _transnr$[ebp], 20
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+eax+4]
	mov	DWORD PTR _newto$1[ebp], eax

; 2042 : 
; 2043 : 		if (ctxt->states[newto] == NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _newto$1[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	jne	SHORT $LN46@xmlFAElimi

; 2044 : 		    continue;

	jmp	SHORT $LN22@xmlFAElimi
$LN46@xmlFAElimi:

; 2045 : 		if (ctxt->states[newto]->reached == XML_REGEXP_MARK_NORMAL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _newto$1[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN44@xmlFAElimi

; 2046 : 		    ctxt->states[newto]->reached = XML_REGEXP_MARK_START;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _newto$1[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx+12], 1

; 2047 : 		    target = ctxt->states[newto];

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _newto$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _target$2[ebp], eax
$LN44@xmlFAElimi:

; 2048 : 		}
; 2049 : 	    }
; 2050 : 	}

	jmp	$LN22@xmlFAElimi
$LN23@xmlFAElimi:

; 2051 : 
; 2052 : 	/*
; 2053 : 	 * find the next accessible state not explored
; 2054 : 	 */
; 2055 : 	if (target == NULL) {

	cmp	DWORD PTR _target$2[ebp], 0
	jne	SHORT $LN48@xmlFAElimi

; 2056 : 	    for (statenr = 1;statenr < ctxt->nbStates;statenr++) {

	mov	DWORD PTR _statenr$[ebp], 1
	jmp	SHORT $LN27@xmlFAElimi
$LN25@xmlFAElimi:
	mov	ecx, DWORD PTR _statenr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _statenr$[ebp], ecx
$LN27@xmlFAElimi:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _statenr$[ebp]
	cmp	eax, DWORD PTR [edx+48]
	jge	SHORT $LN48@xmlFAElimi

; 2057 : 		state = ctxt->states[statenr];

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _statenr$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _state$[ebp], ecx

; 2058 : 		if ((state != NULL) && (state->reached ==

	cmp	DWORD PTR _state$[ebp], 0
	je	SHORT $LN49@xmlFAElimi
	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+12], 1
	jne	SHORT $LN49@xmlFAElimi

; 2059 : 			XML_REGEXP_MARK_START)) {
; 2060 : 		    target = state;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR _target$2[ebp], eax

; 2061 : 		    break;

	jmp	SHORT $LN48@xmlFAElimi
$LN49@xmlFAElimi:

; 2062 : 		}
; 2063 : 	    }

	jmp	SHORT $LN25@xmlFAElimi
$LN48@xmlFAElimi:

; 2064 : 	}
; 2065 : 	state = target;

	mov	ecx, DWORD PTR _target$2[ebp]
	mov	DWORD PTR _state$[ebp], ecx

; 2066 :     }

	jmp	$LN20@xmlFAElimi
$LN21@xmlFAElimi:

; 2067 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	mov	DWORD PTR _statenr$[ebp], 0
	jmp	SHORT $LN30@xmlFAElimi
$LN28@xmlFAElimi:
	mov	edx, DWORD PTR _statenr$[ebp]
	add	edx, 1
	mov	DWORD PTR _statenr$[ebp], edx
$LN30@xmlFAElimi:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _statenr$[ebp]
	cmp	ecx, DWORD PTR [eax+48]
	jge	SHORT $LN1@xmlFAElimi

; 2068 : 	state = ctxt->states[statenr];

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _statenr$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _state$[ebp], edx

; 2069 : 	if ((state != NULL) && (state->reached == XML_REGEXP_MARK_NORMAL)) {

	cmp	DWORD PTR _state$[ebp], 0
	je	SHORT $LN50@xmlFAElimi
	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN50@xmlFAElimi

; 2070 : #ifdef DEBUG_REGEXP_GRAPH
; 2071 : 	    printf("Removed unreachable state %d\n", statenr);
; 2072 : #endif
; 2073 : 	    xmlRegFreeState(state);

	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xmlRegFreeState
	add	esp, 4

; 2074 : 	    ctxt->states[statenr] = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _statenr$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0
$LN50@xmlFAElimi:

; 2075 : 	}
; 2076 :     }

	jmp	SHORT $LN28@xmlFAElimi
$LN1@xmlFAElimi:

; 2077 : 
; 2078 : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFAEliminateEpsilonTransitions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAEliminateSimpleEpsilonTransitions
_TEXT	SEGMENT
_tmp$ = -24						; size = 4
_state$ = -20						; size = 4
_newto$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_statenr$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlFAEliminateSimpleEpsilonTransitions PROC		; COMDAT

; 1865 : xmlFAEliminateSimpleEpsilonTransitions(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1866 :     int statenr, i, j, newto;
; 1867 :     xmlRegStatePtr state, tmp;
; 1868 : 
; 1869 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	mov	DWORD PTR _statenr$[ebp], 0
	jmp	SHORT $LN4@xmlFAElimi
$LN2@xmlFAElimi:
	mov	eax, DWORD PTR _statenr$[ebp]
	add	eax, 1
	mov	DWORD PTR _statenr$[ebp], eax
$LN4@xmlFAElimi:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _statenr$[ebp]
	cmp	edx, DWORD PTR [ecx+48]
	jge	$LN1@xmlFAElimi

; 1870 : 	state = ctxt->states[statenr];

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _statenr$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _state$[ebp], eax

; 1871 : 	if (state == NULL)

	cmp	DWORD PTR _state$[ebp], 0
	jne	SHORT $LN11@xmlFAElimi

; 1872 : 	    continue;

	jmp	SHORT $LN2@xmlFAElimi
$LN11@xmlFAElimi:

; 1873 : 	if (state->nbTrans != 1)

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+24], 1
	je	SHORT $LN12@xmlFAElimi

; 1874 : 	    continue;

	jmp	SHORT $LN2@xmlFAElimi
$LN12@xmlFAElimi:

; 1875 : 	if (state->type == XML_REGEXP_UNREACH_STATE)

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx], 5
	jne	SHORT $LN13@xmlFAElimi

; 1876 : 	    continue;

	jmp	SHORT $LN2@xmlFAElimi
$LN13@xmlFAElimi:

; 1877 : 	/* is the only transition out a basic transition */
; 1878 : 	if ((state->trans[0].atom == NULL) &&
; 1879 : 	    (state->trans[0].to >= 0) &&
; 1880 : 	    (state->trans[0].to != statenr) &&
; 1881 : 	    (state->trans[0].counter < 0) &&

	mov	eax, 20					; 00000014H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+28]
	cmp	DWORD PTR [eax+ecx], 0
	jne	$LN14@xmlFAElimi
	mov	ecx, 20					; 00000014H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx+edx+4], 0
	jl	$LN14@xmlFAElimi
	mov	edx, 20					; 00000014H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+eax+4]
	cmp	eax, DWORD PTR _statenr$[ebp]
	je	$LN14@xmlFAElimi
	mov	ecx, 20					; 00000014H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx+edx+8], 0
	jge	$LN14@xmlFAElimi
	mov	edx, 20					; 00000014H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	DWORD PTR [edx+eax+12], 0
	jge	$LN14@xmlFAElimi

; 1882 : 	    (state->trans[0].count < 0)) {
; 1883 : 	    newto = state->trans[0].to;

	mov	eax, 20					; 00000014H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+ecx+4]
	mov	DWORD PTR _newto$[ebp], ecx

; 1884 : 
; 1885 :             if (state->type == XML_REGEXP_START_STATE) {

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx], 1
	jne	SHORT $LN15@xmlFAElimi

; 1886 : #ifdef DEBUG_REGEXP_GRAPH
; 1887 : 		printf("Found simple epsilon trans from start %d to %d\n",
; 1888 : 		       statenr, newto);
; 1889 : #endif
; 1890 :             } else {

	jmp	$LN14@xmlFAElimi
$LN15@xmlFAElimi:

; 1891 : #ifdef DEBUG_REGEXP_GRAPH
; 1892 : 		printf("Found simple epsilon trans from %d to %d\n",
; 1893 : 		       statenr, newto);
; 1894 : #endif
; 1895 : 	        for (i = 0;i < state->nbTransTo;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@xmlFAElimi
$LN5@xmlFAElimi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@xmlFAElimi:
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+36]
	jge	$LN6@xmlFAElimi

; 1896 : 		    tmp = ctxt->states[state->transTo[i]];

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _tmp$[ebp], eax

; 1897 : 		    for (j = 0;j < tmp->nbTrans;j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@xmlFAElimi
$LN8@xmlFAElimi:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN10@xmlFAElimi:
	mov	edx, DWORD PTR _tmp$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jge	SHORT $LN9@xmlFAElimi

; 1898 : 			if (tmp->trans[j].to == statenr) {

	imul	ecx, DWORD PTR _j$[ebp], 20
	mov	edx, DWORD PTR _tmp$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+ecx+4]
	cmp	ecx, DWORD PTR _statenr$[ebp]
	jne	SHORT $LN17@xmlFAElimi

; 1899 : #ifdef DEBUG_REGEXP_GRAPH
; 1900 : 			    printf("Changed transition %d on %d to go to %d\n",
; 1901 : 				   j, tmp->no, newto);
; 1902 : #endif
; 1903 : 			    tmp->trans[j].to = -1;

	imul	edx, DWORD PTR _j$[ebp], 20
	mov	eax, DWORD PTR _tmp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+edx+4], -1

; 1904 : 			    xmlRegStateAddTrans(ctxt, tmp, tmp->trans[j].atom,

	imul	edx, DWORD PTR _j$[ebp], 20
	mov	eax, DWORD PTR _tmp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+edx+12]
	push	edx
	imul	eax, DWORD PTR _j$[ebp], 20
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+eax+8]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _newto$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	imul	edx, DWORD PTR _j$[ebp], 20
	mov	eax, DWORD PTR _tmp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+edx]
	push	edx
	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H
$LN17@xmlFAElimi:

; 1905 : 						ctxt->states[newto],
; 1906 : 					        tmp->trans[j].counter,
; 1907 : 						tmp->trans[j].count);
; 1908 : 			}
; 1909 : 		    }

	jmp	$LN8@xmlFAElimi
$LN9@xmlFAElimi:

; 1910 : 		}

	jmp	$LN5@xmlFAElimi
$LN6@xmlFAElimi:

; 1911 : 		if (state->type == XML_REGEXP_FINAL_STATE)

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx], 2
	jne	SHORT $LN18@xmlFAElimi

; 1912 : 		    ctxt->states[newto]->type = XML_REGEXP_FINAL_STATE;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _newto$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [eax], 2
$LN18@xmlFAElimi:

; 1913 : 		/* eliminate the transition completely */
; 1914 : 		state->nbTrans = 0;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 1915 : 
; 1916 :                 state->type = XML_REGEXP_UNREACH_STATE;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx], 5
$LN14@xmlFAElimi:

; 1917 : 
; 1918 : 	    }
; 1919 : 
; 1920 : 	}
; 1921 :     }

	jmp	$LN2@xmlFAElimi
$LN1@xmlFAElimi:

; 1922 : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFAEliminateSimpleEpsilonTransitions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAReduceEpsilonTransitions
_TEXT	SEGMENT
_newto$1 = -20						; size = 4
_newto$2 = -16						; size = 4
_to$ = -12						; size = 4
_from$ = -8						; size = 4
_transnr$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_fromnr$ = 12						; size = 4
_tonr$ = 16						; size = 4
_counter$ = 20						; size = 4
_xmlFAReduceEpsilonTransitions PROC			; COMDAT

; 1777 : 	                      int tonr, int counter) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1778 :     int transnr;
; 1779 :     xmlRegStatePtr from;
; 1780 :     xmlRegStatePtr to;
; 1781 : 
; 1782 : #ifdef DEBUG_REGEXP_GRAPH
; 1783 :     printf("xmlFAReduceEpsilonTransitions(%d, %d)\n", fromnr, tonr);
; 1784 : #endif
; 1785 :     from = ctxt->states[fromnr];

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _fromnr$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _from$[ebp], eax

; 1786 :     if (from == NULL)

	cmp	DWORD PTR _from$[ebp], 0
	jne	SHORT $LN5@xmlFAReduc

; 1787 : 	return;

	jmp	$LN1@xmlFAReduc
$LN5@xmlFAReduc:

; 1788 :     to = ctxt->states[tonr];

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _tonr$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _to$[ebp], ecx

; 1789 :     if (to == NULL)

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN6@xmlFAReduc

; 1790 : 	return;

	jmp	$LN1@xmlFAReduc
$LN6@xmlFAReduc:

; 1791 :     if ((to->mark == XML_REGEXP_MARK_START) ||

	mov	edx, DWORD PTR _to$[ebp]
	cmp	DWORD PTR [edx+4], 1
	je	SHORT $LN8@xmlFAReduc
	mov	eax, DWORD PTR _to$[ebp]
	cmp	DWORD PTR [eax+4], 2
	jne	SHORT $LN7@xmlFAReduc
$LN8@xmlFAReduc:

; 1792 : 	(to->mark == XML_REGEXP_MARK_VISITED))
; 1793 : 	return;

	jmp	$LN1@xmlFAReduc
$LN7@xmlFAReduc:

; 1794 : 
; 1795 :     to->mark = XML_REGEXP_MARK_VISITED;

	mov	ecx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [ecx+4], 2

; 1796 :     if (to->type == XML_REGEXP_FINAL_STATE) {

	mov	edx, DWORD PTR _to$[ebp]
	cmp	DWORD PTR [edx], 2
	jne	SHORT $LN9@xmlFAReduc

; 1797 : #ifdef DEBUG_REGEXP_GRAPH
; 1798 : 	printf("State %d is final, so %d becomes final\n", tonr, fromnr);
; 1799 : #endif
; 1800 : 	from->type = XML_REGEXP_FINAL_STATE;

	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], 2
$LN9@xmlFAReduc:

; 1801 :     }
; 1802 :     for (transnr = 0;transnr < to->nbTrans;transnr++) {

	mov	DWORD PTR _transnr$[ebp], 0
	jmp	SHORT $LN4@xmlFAReduc
$LN2@xmlFAReduc:
	mov	ecx, DWORD PTR _transnr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _transnr$[ebp], ecx
$LN4@xmlFAReduc:
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR _transnr$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jge	$LN3@xmlFAReduc

; 1803 :         if (to->trans[transnr].to < 0)

	imul	ecx, DWORD PTR _transnr$[ebp], 20
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+28]
	cmp	DWORD PTR [eax+ecx+4], 0
	jge	SHORT $LN10@xmlFAReduc

; 1804 : 	    continue;

	jmp	SHORT $LN2@xmlFAReduc
$LN10@xmlFAReduc:

; 1805 : 	if (to->trans[transnr].atom == NULL) {

	imul	ecx, DWORD PTR _transnr$[ebp], 20
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+28]
	cmp	DWORD PTR [eax+ecx], 0
	jne	$LN11@xmlFAReduc

; 1806 : 	    /*
; 1807 : 	     * Don't remove counted transitions
; 1808 : 	     * Don't loop either
; 1809 : 	     */
; 1810 : 	    if (to->trans[transnr].to != fromnr) {

	imul	ecx, DWORD PTR _transnr$[ebp], 20
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+ecx+4]
	cmp	ecx, DWORD PTR _fromnr$[ebp]
	je	$LN13@xmlFAReduc

; 1811 : 		if (to->trans[transnr].count >= 0) {

	imul	edx, DWORD PTR _transnr$[ebp], 20
	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx+edx+12], 0
	jl	SHORT $LN14@xmlFAReduc

; 1812 : 		    int newto = to->trans[transnr].to;

	imul	edx, DWORD PTR _transnr$[ebp], 20
	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+edx+4]
	mov	DWORD PTR _newto$2[ebp], edx

; 1813 : 
; 1814 : 		    xmlRegStateAddTrans(ctxt, from, NULL,

	imul	eax, DWORD PTR _transnr$[ebp], 20
	mov	ecx, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+eax+12]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _newto$2[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	push	0
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H

; 1815 : 					ctxt->states[newto],
; 1816 : 					-1, to->trans[transnr].count);
; 1817 : 		} else {

	jmp	SHORT $LN13@xmlFAReduc
$LN14@xmlFAReduc:

; 1818 : #ifdef DEBUG_REGEXP_GRAPH
; 1819 : 		    printf("Found epsilon trans %d from %d to %d\n",
; 1820 : 			   transnr, tonr, to->trans[transnr].to);
; 1821 : #endif
; 1822 : 		    if (to->trans[transnr].counter >= 0) {

	imul	ecx, DWORD PTR _transnr$[ebp], 20
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+28]
	cmp	DWORD PTR [eax+ecx+8], 0
	jl	SHORT $LN16@xmlFAReduc

; 1823 : 			xmlFAReduceEpsilonTransitions(ctxt, fromnr,

	imul	ecx, DWORD PTR _transnr$[ebp], 20
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+ecx+8]
	push	ecx
	imul	edx, DWORD PTR _transnr$[ebp], 20
	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+edx+4]
	push	edx
	mov	eax, DWORD PTR _fromnr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFAReduceEpsilonTransitions
	add	esp, 16					; 00000010H

; 1824 : 					      to->trans[transnr].to,
; 1825 : 					      to->trans[transnr].counter);
; 1826 : 		    } else {

	jmp	SHORT $LN13@xmlFAReduc
$LN16@xmlFAReduc:

; 1827 : 			xmlFAReduceEpsilonTransitions(ctxt, fromnr,

	mov	edx, DWORD PTR _counter$[ebp]
	push	edx
	imul	eax, DWORD PTR _transnr$[ebp], 20
	mov	ecx, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+eax+4]
	push	eax
	mov	ecx, DWORD PTR _fromnr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFAReduceEpsilonTransitions
	add	esp, 16					; 00000010H
$LN13@xmlFAReduc:

; 1828 : 					      to->trans[transnr].to,
; 1829 : 					      counter);
; 1830 : 		    }
; 1831 : 		}
; 1832 : 	    }
; 1833 : 	} else {

	jmp	$LN12@xmlFAReduc
$LN11@xmlFAReduc:

; 1834 : 	    int newto = to->trans[transnr].to;

	imul	eax, DWORD PTR _transnr$[ebp], 20
	mov	ecx, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+eax+4]
	mov	DWORD PTR _newto$1[ebp], eax

; 1835 : 
; 1836 : 	    if (to->trans[transnr].counter >= 0) {

	imul	ecx, DWORD PTR _transnr$[ebp], 20
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+28]
	cmp	DWORD PTR [eax+ecx+8], 0
	jl	SHORT $LN18@xmlFAReduc

; 1837 : 		xmlRegStateAddTrans(ctxt, from, to->trans[transnr].atom,

	push	-1
	imul	ecx, DWORD PTR _transnr$[ebp], 20
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+ecx+8]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _newto$1[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	imul	eax, DWORD PTR _transnr$[ebp], 20
	mov	ecx, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+eax]
	push	eax
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H

; 1838 : 				    ctxt->states[newto],
; 1839 : 				    to->trans[transnr].counter, -1);
; 1840 : 	    } else {

	jmp	SHORT $LN12@xmlFAReduc
$LN18@xmlFAReduc:

; 1841 : 		xmlRegStateAddTrans(ctxt, from, to->trans[transnr].atom,

	push	-1
	mov	eax, DWORD PTR _counter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _newto$1[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	imul	edx, DWORD PTR _transnr$[ebp], 20
	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+edx]
	push	edx
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H
$LN12@xmlFAReduc:

; 1842 : 				    ctxt->states[newto], counter, -1);
; 1843 : 	    }
; 1844 : 	}
; 1845 :     }

	jmp	$LN2@xmlFAReduc
$LN3@xmlFAReduc:

; 1846 :     to->mark = XML_REGEXP_MARK_NORMAL;

	mov	edx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [edx+4], 0
$LN1@xmlFAReduc:

; 1847 : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFAReduceEpsilonTransitions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAGenerateTransitions
_TEXT	SEGMENT
tv294 = -36						; size = 4
tv84 = -32						; size = 4
_tmp$1 = -28						; size = 4
_copy$2 = -24						; size = 4
_newstate$3 = -20					; size = 4
_inter$4 = -16						; size = 4
_counter$5 = -12					; size = 4
_nullable$ = -8						; size = 4
_end$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_atom$ = 20						; size = 4
_xmlFAGenerateTransitions PROC				; COMDAT

; 1545 : 	                 xmlRegStatePtr to, xmlRegAtomPtr atom) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1546 :     xmlRegStatePtr end;
; 1547 :     int nullable = 0;

	mov	DWORD PTR _nullable$[ebp], 0

; 1548 : 
; 1549 :     if (atom == NULL) {

	cmp	DWORD PTR _atom$[ebp], 0
	jne	SHORT $LN6@xmlFAGener

; 1550 : 	ERROR("genrate transition: atom == NULL");

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0CB@LMLDANHN@genrate?5transition?3?5atom?5?$DN?$DN?5NUL@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegexpErrCompile
	add	esp, 8

; 1551 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlFAGener
$LN6@xmlFAGener:

; 1552 :     }
; 1553 :     if (atom->type == XML_REGEXP_SUBREG) {

	mov	edx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [edx+4], 4
	jne	$LN7@xmlFAGener

; 1554 : 	/*
; 1555 : 	 * this is a subexpression handling one should not need to
; 1556 : 	 * create a new node except for XML_REGEXP_QUANT_RANGE.
; 1557 : 	 */
; 1558 : 	if (xmlRegAtomPush(ctxt, atom) < 0) {

	mov	eax, DWORD PTR _atom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegAtomPush
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN8@xmlFAGener

; 1559 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlFAGener
$LN8@xmlFAGener:

; 1560 : 	}
; 1561 : 	if ((to != NULL) && (atom->stop != to) &&

	cmp	DWORD PTR _to$[ebp], 0
	je	SHORT $LN9@xmlFAGener
	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, DWORD PTR _to$[ebp]
	je	SHORT $LN9@xmlFAGener
	mov	ecx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [ecx+8], 8
	je	SHORT $LN9@xmlFAGener

; 1562 : 	    (atom->quant != XML_REGEXP_QUANT_RANGE)) {
; 1563 : 	    /*
; 1564 : 	     * Generate an epsilon transition to link to the target
; 1565 : 	     */
; 1566 : 	    xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);

	mov	edx, DWORD PTR _to$[ebp]
	push	edx
	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH
$LN9@xmlFAGener:

; 1567 : #ifdef DV
; 1568 : 	} else if ((to == NULL) && (atom->quant != XML_REGEXP_QUANT_RANGE) &&
; 1569 : 		   (atom->quant != XML_REGEXP_QUANT_ONCE)) {
; 1570 : 	    to = xmlRegNewState(ctxt);
; 1571 : 	    xmlRegStatePush(ctxt, to);
; 1572 : 	    ctxt->state = to;
; 1573 : 	    xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);
; 1574 : #endif
; 1575 : 	}
; 1576 : 	switch (atom->quant) {

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv84[ebp], ecx
	mov	edx, DWORD PTR tv84[ebp]
	sub	edx, 3
	mov	DWORD PTR tv84[ebp], edx
	cmp	DWORD PTR tv84[ebp], 5
	ja	$LN2@xmlFAGener
	mov	eax, DWORD PTR tv84[ebp]
	jmp	DWORD PTR $LN45@xmlFAGener[eax*4]
$LN10@xmlFAGener:

; 1577 : 	    case XML_REGEXP_QUANT_OPT:
; 1578 : 		atom->quant = XML_REGEXP_QUANT_ONCE;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [ecx+8], 2

; 1579 : 		/*
; 1580 : 		 * transition done to the state after end of atom.
; 1581 : 		 *      1. set transition from atom start to new state
; 1582 : 		 *      2. set transition from atom end to this state.
; 1583 : 		 */
; 1584 :                 if (to == NULL) {

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN11@xmlFAGener

; 1585 :                     xmlFAGenerateEpsilonTransition(ctxt, atom->start, 0);

	push	0
	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH

; 1586 :                     xmlFAGenerateEpsilonTransition(ctxt, atom->stop,

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH

; 1587 :                                                    ctxt->state);
; 1588 :                 } else {

	jmp	SHORT $LN12@xmlFAGener
$LN11@xmlFAGener:

; 1589 :                     xmlFAGenerateEpsilonTransition(ctxt, atom->start, to);

	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH
$LN12@xmlFAGener:

; 1590 :                 }
; 1591 : 		break;

	jmp	$LN2@xmlFAGener
$LN13@xmlFAGener:

; 1592 : 	    case XML_REGEXP_QUANT_MULT:
; 1593 : 		atom->quant = XML_REGEXP_QUANT_ONCE;

	mov	edx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [edx+8], 2

; 1594 : 		xmlFAGenerateEpsilonTransition(ctxt, atom->start, atom->stop);

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH

; 1595 : 		xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH

; 1596 : 		break;

	jmp	$LN2@xmlFAGener
$LN14@xmlFAGener:

; 1597 : 	    case XML_REGEXP_QUANT_PLUS:
; 1598 : 		atom->quant = XML_REGEXP_QUANT_ONCE;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [ecx+8], 2

; 1599 : 		xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH

; 1600 : 		break;

	jmp	$LN2@xmlFAGener
$LN15@xmlFAGener:

; 1601 : 	    case XML_REGEXP_QUANT_RANGE: {
; 1602 : 		int counter;
; 1603 : 		xmlRegStatePtr inter, newstate;
; 1604 : 
; 1605 : 		/*
; 1606 : 		 * create the final state now if needed
; 1607 : 		 */
; 1608 : 		if (to != NULL) {

	cmp	DWORD PTR _to$[ebp], 0
	je	SHORT $LN16@xmlFAGener

; 1609 : 		    newstate = to;

	mov	ecx, DWORD PTR _to$[ebp]
	mov	DWORD PTR _newstate$3[ebp], ecx

; 1610 : 		} else {

	jmp	SHORT $LN17@xmlFAGener
$LN16@xmlFAGener:

; 1611 : 		    newstate = xmlRegNewState(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegNewState
	add	esp, 4
	mov	DWORD PTR _newstate$3[ebp], eax

; 1612 : 		    xmlRegStatePush(ctxt, newstate);

	mov	eax, DWORD PTR _newstate$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegStatePush
	add	esp, 8
$LN17@xmlFAGener:

; 1613 : 		}
; 1614 : 
; 1615 : 		/*
; 1616 : 		 * The principle here is to use counted transition
; 1617 : 		 * to avoid explosion in the number of states in the
; 1618 : 		 * graph. This is clearly more complex but should not
; 1619 : 		 * be exploitable at runtime.
; 1620 : 		 */
; 1621 : 		if ((atom->min == 0) && (atom->start0 == NULL)) {

	mov	edx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	$LN18@xmlFAGener
	mov	eax, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	$LN18@xmlFAGener

; 1622 : 		    xmlRegAtomPtr copy;
; 1623 : 		    /*
; 1624 : 		     * duplicate a transition based on atom to count next
; 1625 : 		     * occurences after 1. We cannot loop to atom->start
; 1626 : 		     * directly because we need an epsilon transition to
; 1627 : 		     * newstate.
; 1628 : 		     */
; 1629 : 		     /* ???? For some reason it seems we never reach that
; 1630 : 		        case, I suppose this got optimized out before when
; 1631 : 			building the automata */
; 1632 : 		    copy = xmlRegCopyAtom(ctxt, atom);

	mov	ecx, DWORD PTR _atom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegCopyAtom
	add	esp, 8
	mov	DWORD PTR _copy$2[ebp], eax

; 1633 : 		    if (copy == NULL)

	cmp	DWORD PTR _copy$2[ebp], 0
	jne	SHORT $LN20@xmlFAGener

; 1634 : 		        return(-1);

	or	eax, -1
	jmp	$LN1@xmlFAGener
$LN20@xmlFAGener:

; 1635 : 		    copy->quant = XML_REGEXP_QUANT_ONCE;

	mov	eax, DWORD PTR _copy$2[ebp]
	mov	DWORD PTR [eax+8], 2

; 1636 : 		    copy->min = 0;

	mov	ecx, DWORD PTR _copy$2[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1637 : 		    copy->max = 0;

	mov	edx, DWORD PTR _copy$2[ebp]
	mov	DWORD PTR [edx+16], 0

; 1638 : 
; 1639 : 		    if (xmlFAGenerateTransitions(ctxt, atom->start, NULL, copy)
; 1640 : 		        < 0)

	mov	eax, DWORD PTR _copy$2[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAGenerateTransitions
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN21@xmlFAGener

; 1641 : 			return(-1);

	or	eax, -1
	jmp	$LN1@xmlFAGener
$LN21@xmlFAGener:

; 1642 : 		    inter = ctxt->state;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _inter$4[ebp], edx

; 1643 : 		    counter = xmlRegGetCounter(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegGetCounter
	add	esp, 4
	mov	DWORD PTR _counter$5[ebp], eax

; 1644 : 		    ctxt->counters[counter].min = atom->min - 1;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	eax, DWORD PTR _counter$5[ebp]
	mov	DWORD PTR [ecx+eax*8], edx

; 1645 : 		    ctxt->counters[counter].max = atom->max - 1;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	eax, DWORD PTR _counter$5[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 1646 : 		    /* count the number of times we see it again */
; 1647 : 		    xmlFAGenerateCountedEpsilonTransition(ctxt, inter,

	mov	ecx, DWORD PTR _counter$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _inter$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFAGenerateCountedEpsilonTransition
	add	esp, 16					; 00000010H

; 1648 : 						   atom->stop, counter);
; 1649 : 		    /* allow a way out based on the count */
; 1650 : 		    xmlFAGenerateCountedTransition(ctxt, inter,

	mov	eax, DWORD PTR _counter$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _newstate$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _inter$4[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAGenerateCountedTransition
	add	esp, 16					; 00000010H

; 1651 : 			                           newstate, counter);
; 1652 : 		    /* and also allow a direct exit for 0 */
; 1653 : 		    xmlFAGenerateEpsilonTransition(ctxt, atom->start,

	mov	ecx, DWORD PTR _newstate$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH

; 1654 : 		                                   newstate);
; 1655 : 		} else {

	jmp	$LN19@xmlFAGener
$LN18@xmlFAGener:

; 1656 : 		    /*
; 1657 : 		     * either we need the atom at least once or there
; 1658 : 		     * is an atom->start0 allowing to easilly plug the
; 1659 : 		     * epsilon transition.
; 1660 : 		     */
; 1661 : 		    counter = xmlRegGetCounter(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegGetCounter
	add	esp, 4
	mov	DWORD PTR _counter$5[ebp], eax

; 1662 : 		    ctxt->counters[counter].min = atom->min - 1;

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	edx, DWORD PTR _counter$5[ebp]
	mov	DWORD PTR [eax+edx*8], ecx

; 1663 : 		    ctxt->counters[counter].max = atom->max - 1;

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	edx, DWORD PTR _counter$5[ebp]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 1664 : 		    /* count the number of times we see it again */
; 1665 : 		    xmlFAGenerateCountedEpsilonTransition(ctxt, atom->stop,

	mov	eax, DWORD PTR _counter$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFAGenerateCountedEpsilonTransition
	add	esp, 16					; 00000010H

; 1666 : 						   atom->start, counter);
; 1667 : 		    /* allow a way out based on the count */
; 1668 : 		    xmlFAGenerateCountedTransition(ctxt, atom->stop,

	mov	eax, DWORD PTR _counter$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _newstate$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFAGenerateCountedTransition
	add	esp, 16					; 00000010H

; 1669 : 			                           newstate, counter);
; 1670 : 		    /* and if needed allow a direct exit for 0 */
; 1671 : 		    if (atom->min == 0)

	mov	edx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN19@xmlFAGener

; 1672 : 			xmlFAGenerateEpsilonTransition(ctxt, atom->start0,

	mov	eax, DWORD PTR _newstate$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH
$LN19@xmlFAGener:

; 1673 : 						       newstate);
; 1674 : 
; 1675 : 		}
; 1676 : 		atom->min = 0;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1677 : 		atom->max = 0;

	mov	edx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [edx+16], 0

; 1678 : 		atom->quant = XML_REGEXP_QUANT_ONCE;

	mov	eax, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [eax+8], 2

; 1679 : 		ctxt->state = newstate;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _newstate$3[ebp]
	mov	DWORD PTR [ecx+24], edx
$LN2@xmlFAGener:

; 1680 : 	    }
; 1681 : 	    default:
; 1682 : 		break;
; 1683 : 	}
; 1684 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlFAGener
$LN7@xmlFAGener:

; 1685 :     }
; 1686 :     if ((atom->min == 0) && (atom->max == 0) &&

	mov	eax, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN24@xmlFAGener
	mov	ecx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN24@xmlFAGener
	mov	edx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [edx+8], 8
	jne	SHORT $LN24@xmlFAGener

; 1687 :                (atom->quant == XML_REGEXP_QUANT_RANGE)) {
; 1688 :         /*
; 1689 : 	 * we can discard the atom and generate an epsilon transition instead
; 1690 : 	 */
; 1691 : 	if (to == NULL) {

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN25@xmlFAGener

; 1692 : 	    to = xmlRegNewState(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegNewState
	add	esp, 4
	mov	DWORD PTR _to$[ebp], eax

; 1693 : 	    if (to != NULL)

	cmp	DWORD PTR _to$[ebp], 0
	je	SHORT $LN26@xmlFAGener

; 1694 : 		xmlRegStatePush(ctxt, to);

	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegStatePush
	add	esp, 8
	jmp	SHORT $LN25@xmlFAGener
$LN26@xmlFAGener:

; 1695 : 	    else {
; 1696 : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlFAGener
$LN25@xmlFAGener:

; 1697 : 	    }
; 1698 : 	}
; 1699 : 	xmlFAGenerateEpsilonTransition(ctxt, from, to);

	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH

; 1700 : 	ctxt->state = to;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 1701 : 	xmlRegFreeAtom(atom);

	mov	edx, DWORD PTR _atom$[ebp]
	push	edx
	call	_xmlRegFreeAtom
	add	esp, 4

; 1702 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlFAGener
$LN24@xmlFAGener:

; 1703 :     }
; 1704 :     if (to == NULL) {

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN28@xmlFAGener

; 1705 : 	to = xmlRegNewState(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegNewState
	add	esp, 4
	mov	DWORD PTR _to$[ebp], eax

; 1706 : 	if (to != NULL)

	cmp	DWORD PTR _to$[ebp], 0
	je	SHORT $LN29@xmlFAGener

; 1707 : 	    xmlRegStatePush(ctxt, to);

	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegStatePush
	add	esp, 8
	jmp	SHORT $LN28@xmlFAGener
$LN29@xmlFAGener:

; 1708 : 	else {
; 1709 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlFAGener
$LN28@xmlFAGener:

; 1710 : 	}
; 1711 :     }
; 1712 :     end = to;

	mov	eax, DWORD PTR _to$[ebp]
	mov	DWORD PTR _end$[ebp], eax

; 1713 :     if ((atom->quant == XML_REGEXP_QUANT_MULT) ||

	mov	ecx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [ecx+8], 4
	je	SHORT $LN32@xmlFAGener
	mov	edx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [edx+8], 5
	jne	SHORT $LN31@xmlFAGener
$LN32@xmlFAGener:

; 1714 :         (atom->quant == XML_REGEXP_QUANT_PLUS)) {
; 1715 : 	/*
; 1716 : 	 * Do not pollute the target state by adding transitions from
; 1717 : 	 * it as it is likely to be the shared target of multiple branches.
; 1718 : 	 * So isolate with an epsilon transition.
; 1719 : 	 */
; 1720 :         xmlRegStatePtr tmp;
; 1721 : 
; 1722 : 	tmp = xmlRegNewState(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegNewState
	add	esp, 4
	mov	DWORD PTR _tmp$1[ebp], eax

; 1723 : 	if (tmp != NULL)

	cmp	DWORD PTR _tmp$1[ebp], 0
	je	SHORT $LN33@xmlFAGener

; 1724 : 	    xmlRegStatePush(ctxt, tmp);

	mov	ecx, DWORD PTR _tmp$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegStatePush
	add	esp, 8
	jmp	SHORT $LN34@xmlFAGener
$LN33@xmlFAGener:

; 1725 : 	else {
; 1726 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlFAGener
$LN34@xmlFAGener:

; 1727 : 	}
; 1728 : 	xmlFAGenerateEpsilonTransition(ctxt, tmp, to);

	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmp$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH

; 1729 : 	to = tmp;

	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR _to$[ebp], eax
$LN31@xmlFAGener:

; 1730 :     }
; 1731 :     if (xmlRegAtomPush(ctxt, atom) < 0) {

	mov	ecx, DWORD PTR _atom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegAtomPush
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN35@xmlFAGener

; 1732 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlFAGener
$LN35@xmlFAGener:

; 1733 :     }
; 1734 :     if ((atom->quant == XML_REGEXP_QUANT_RANGE) &&
; 1735 :         (atom->min == 0) && (atom->max > 0)) {

	mov	eax, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [eax+8], 8
	jne	SHORT $LN36@xmlFAGener
	mov	ecx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN36@xmlFAGener
	mov	edx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jle	SHORT $LN36@xmlFAGener

; 1736 : 	nullable = 1;

	mov	DWORD PTR _nullable$[ebp], 1

; 1737 : 	atom->min = 1;

	mov	eax, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [eax+12], 1

; 1738 :         if (atom->max == 1)

	mov	ecx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [ecx+16], 1
	jne	SHORT $LN36@xmlFAGener

; 1739 : 	    atom->quant = XML_REGEXP_QUANT_OPT;

	mov	edx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [edx+8], 3
$LN36@xmlFAGener:

; 1740 :     }
; 1741 :     xmlRegStateAddTrans(ctxt, from, atom, to, -1, -1);

	push	-1
	push	-1
	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _atom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H

; 1742 :     ctxt->state = end;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _end$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 1743 :     switch (atom->quant) {

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv294[ebp], ecx
	mov	edx, DWORD PTR tv294[ebp]
	sub	edx, 3
	mov	DWORD PTR tv294[ebp], edx
	cmp	DWORD PTR tv294[ebp], 5
	ja	$LN4@xmlFAGener
	mov	eax, DWORD PTR tv294[ebp]
	jmp	DWORD PTR $LN46@xmlFAGener[eax*4]
$LN38@xmlFAGener:

; 1744 : 	case XML_REGEXP_QUANT_OPT:
; 1745 : 	    atom->quant = XML_REGEXP_QUANT_ONCE;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [ecx+8], 2

; 1746 : 	    xmlFAGenerateEpsilonTransition(ctxt, from, to);

	mov	edx, DWORD PTR _to$[ebp]
	push	edx
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH

; 1747 : 	    break;

	jmp	SHORT $LN4@xmlFAGener
$LN39@xmlFAGener:

; 1748 : 	case XML_REGEXP_QUANT_MULT:
; 1749 : 	    atom->quant = XML_REGEXP_QUANT_ONCE;

	mov	edx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [edx+8], 2

; 1750 : 	    xmlFAGenerateEpsilonTransition(ctxt, from, to);

	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH

; 1751 : 	    xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);

	push	-1
	push	-1
	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _atom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _to$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H

; 1752 : 	    break;

	jmp	SHORT $LN4@xmlFAGener
$LN40@xmlFAGener:

; 1753 : 	case XML_REGEXP_QUANT_PLUS:
; 1754 : 	    atom->quant = XML_REGEXP_QUANT_ONCE;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [ecx+8], 2

; 1755 : 	    xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);

	push	-1
	push	-1
	mov	edx, DWORD PTR _to$[ebp]
	push	edx
	mov	eax, DWORD PTR _atom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H

; 1756 : 	    break;

	jmp	SHORT $LN4@xmlFAGener
$LN41@xmlFAGener:

; 1757 : 	case XML_REGEXP_QUANT_RANGE:
; 1758 : 	    if (nullable)

	cmp	DWORD PTR _nullable$[ebp], 0
	je	SHORT $LN4@xmlFAGener

; 1759 : 		xmlFAGenerateEpsilonTransition(ctxt, from, to);

	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH
$LN4@xmlFAGener:

; 1760 : 	    break;
; 1761 : 	default:
; 1762 : 	    break;
; 1763 :     }
; 1764 :     return(0);

	xor	eax, eax
$LN1@xmlFAGener:

; 1765 : }

	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN45@xmlFAGener:
	DD	$LN10@xmlFAGener
	DD	$LN13@xmlFAGener
	DD	$LN14@xmlFAGener
	DD	$LN2@xmlFAGener
	DD	$LN2@xmlFAGener
	DD	$LN15@xmlFAGener
$LN46@xmlFAGener:
	DD	$LN38@xmlFAGener
	DD	$LN39@xmlFAGener
	DD	$LN40@xmlFAGener
	DD	$LN4@xmlFAGener
	DD	$LN4@xmlFAGener
	DD	$LN41@xmlFAGener
_xmlFAGenerateTransitions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAGenerateCountedTransition
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_counter$ = 20						; size = 4
_xmlFAGenerateCountedTransition PROC			; COMDAT

; 1525 : 	    xmlRegStatePtr from, xmlRegStatePtr to, int counter) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1526 :     if (to == NULL) {

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN2@xmlFAGener

; 1527 : 	to = xmlRegNewState(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegNewState
	add	esp, 4
	mov	DWORD PTR _to$[ebp], eax

; 1528 : 	xmlRegStatePush(ctxt, to);

	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegStatePush
	add	esp, 8

; 1529 : 	ctxt->state = to;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [eax+24], ecx
$LN2@xmlFAGener:

; 1530 :     }
; 1531 :     xmlRegStateAddTrans(ctxt, from, NULL, to, -1, counter);

	mov	edx, DWORD PTR _counter$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H

; 1532 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFAGenerateCountedTransition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAGenerateCountedEpsilonTransition
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_counter$ = 20						; size = 4
_xmlFAGenerateCountedEpsilonTransition PROC		; COMDAT

; 1506 : 	    xmlRegStatePtr from, xmlRegStatePtr to, int counter) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1507 :     if (to == NULL) {

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN2@xmlFAGener

; 1508 : 	to = xmlRegNewState(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegNewState
	add	esp, 4
	mov	DWORD PTR _to$[ebp], eax

; 1509 : 	xmlRegStatePush(ctxt, to);

	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegStatePush
	add	esp, 8

; 1510 : 	ctxt->state = to;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [eax+24], ecx
$LN2@xmlFAGener:

; 1511 :     }
; 1512 :     xmlRegStateAddTrans(ctxt, from, NULL, to, counter, -1);

	push	-1
	mov	edx, DWORD PTR _counter$[ebp]
	push	edx
	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H

; 1513 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFAGenerateCountedEpsilonTransition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAGenerateEpsilonTransition
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_xmlFAGenerateEpsilonTransition PROC			; COMDAT

; 1487 : 			       xmlRegStatePtr from, xmlRegStatePtr to) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1488 :     if (to == NULL) {

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN2@xmlFAGener

; 1489 : 	to = xmlRegNewState(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegNewState
	add	esp, 4
	mov	DWORD PTR _to$[ebp], eax

; 1490 : 	xmlRegStatePush(ctxt, to);

	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegStatePush
	add	esp, 8

; 1491 : 	ctxt->state = to;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [eax+24], ecx
$LN2@xmlFAGener:

; 1492 :     }
; 1493 :     xmlRegStateAddTrans(ctxt, from, NULL, to, -1, -1);

	push	-1
	push	-1
	mov	edx, DWORD PTR _to$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H

; 1494 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFAGenerateEpsilonTransition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAGenerateAllTransition
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_lax$ = 20						; size = 4
_xmlFAGenerateAllTransition PROC			; COMDAT

; 1466 : 			   int lax) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1467 :     if (to == NULL) {

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN2@xmlFAGener

; 1468 : 	to = xmlRegNewState(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegNewState
	add	esp, 4
	mov	DWORD PTR _to$[ebp], eax

; 1469 : 	xmlRegStatePush(ctxt, to);

	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegStatePush
	add	esp, 8

; 1470 : 	ctxt->state = to;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [eax+24], ecx
$LN2@xmlFAGener:

; 1471 :     }
; 1472 :     if (lax)

	cmp	DWORD PTR _lax$[ebp], 0
	je	SHORT $LN3@xmlFAGener

; 1473 : 	xmlRegStateAddTrans(ctxt, from, NULL, to, -1, REGEXP_ALL_LAX_COUNTER);

	push	1193047					; 00123457H
	push	-1
	mov	edx, DWORD PTR _to$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H
	jmp	SHORT $LN1@xmlFAGener
$LN3@xmlFAGener:

; 1474 :     else
; 1475 : 	xmlRegStateAddTrans(ctxt, from, NULL, to, -1, REGEXP_ALL_COUNTER);

	push	1193046					; 00123456H
	push	-1
	mov	edx, DWORD PTR _to$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H
$LN1@xmlFAGener:

; 1476 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFAGenerateAllTransition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegStatePush
_TEXT	SEGMENT
_tmp$1 = -4						; size = 4
_ctxt$ = 8						; size = 4
_state$ = 12						; size = 4
_xmlRegStatePush PROC					; COMDAT

; 1427 : xmlRegStatePush(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr state) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1428 :     if (state == NULL) return(-1);

	cmp	DWORD PTR _state$[ebp], 0
	jne	SHORT $LN2@xmlRegStat
	or	eax, -1
	jmp	$LN1@xmlRegStat
$LN2@xmlRegStat:

; 1429 :     if (ctxt->maxStates == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN3@xmlRegStat

; 1430 : 	ctxt->maxStates = 4;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+44], 4

; 1431 : 	ctxt->states = (xmlRegStatePtr *) xmlMalloc(ctxt->maxStates *

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+44]
	shl	eax, 2
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 1432 : 		                             sizeof(xmlRegStatePtr));
; 1433 : 	if (ctxt->states == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+52], 0
	jne	SHORT $LN5@xmlRegStat

; 1434 : 	    xmlRegexpErrMemory(ctxt, "adding state");

	push	OFFSET ??_C@_0N@NHLBLLB@adding?5state@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1435 : 	    ctxt->maxStates = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+44], 0

; 1436 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlRegStat
$LN5@xmlRegStat:

; 1437 : 	}

	jmp	SHORT $LN4@xmlRegStat
$LN3@xmlRegStat:

; 1438 :     } else if (ctxt->nbStates >= ctxt->maxStates) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	cmp	ecx, DWORD PTR [eax+44]
	jl	SHORT $LN4@xmlRegStat

; 1439 : 	xmlRegStatePtr *tmp;
; 1440 : 	ctxt->maxStates *= 2;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+44]
	shl	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 1441 : 	tmp = (xmlRegStatePtr *) xmlRealloc(ctxt->states, ctxt->maxStates *

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+44]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 1442 : 		                             sizeof(xmlRegStatePtr));
; 1443 : 	if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN7@xmlRegStat

; 1444 : 	    xmlRegexpErrMemory(ctxt, "adding state");

	push	OFFSET ??_C@_0N@NHLBLLB@adding?5state@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1445 : 	    ctxt->maxStates /= 2;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+44]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+44], eax

; 1446 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlRegStat
$LN7@xmlRegStat:

; 1447 : 	}
; 1448 : 	ctxt->states = tmp;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [eax+52], ecx
$LN4@xmlRegStat:

; 1449 :     }
; 1450 :     state->no = ctxt->nbStates;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+16], ecx

; 1451 :     ctxt->states[ctxt->nbStates++] = state;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+48]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 1452 :     return(0);

	xor	eax, eax
$LN1@xmlRegStat:

; 1453 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegStatePush ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegStateAddTrans
_TEXT	SEGMENT
_tmp$1 = -12						; size = 4
_trans$2 = -8						; size = 4
_nrtrans$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_state$ = 12						; size = 4
_atom$ = 16						; size = 4
_target$ = 20						; size = 4
_counter$ = 24						; size = 4
_count$ = 28						; size = 4
_xmlRegStateAddTrans PROC				; COMDAT

; 1350 : 		    int counter, int count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1351 : 
; 1352 :     int nrtrans;
; 1353 : 
; 1354 :     if (state == NULL) {

	cmp	DWORD PTR _state$[ebp], 0
	jne	SHORT $LN5@xmlRegStat

; 1355 : 	ERROR("add state: state is NULL");

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0BJ@KPILLGIF@add?5state?3?5state?5is?5NULL@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegexpErrCompile
	add	esp, 8

; 1356 : 	return;

	jmp	$LN1@xmlRegStat
$LN5@xmlRegStat:

; 1357 :     }
; 1358 :     if (target == NULL) {

	cmp	DWORD PTR _target$[ebp], 0
	jne	SHORT $LN6@xmlRegStat

; 1359 : 	ERROR("add state: target is NULL");

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0BK@PPLNMJBI@add?5state?3?5target?5is?5NULL@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrCompile
	add	esp, 8

; 1360 : 	return;

	jmp	$LN1@xmlRegStat
$LN6@xmlRegStat:

; 1361 :     }
; 1362 :     /*
; 1363 :      * Other routines follow the philosophy 'When in doubt, add a transition'
; 1364 :      * so we check here whether such a transition is already present and, if
; 1365 :      * so, silently ignore this request.
; 1366 :      */
; 1367 : 
; 1368 :     for (nrtrans = state->nbTrans - 1; nrtrans >= 0; nrtrans--) {

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	sub	edx, 1
	mov	DWORD PTR _nrtrans$[ebp], edx
	jmp	SHORT $LN4@xmlRegStat
$LN2@xmlRegStat:
	mov	eax, DWORD PTR _nrtrans$[ebp]
	sub	eax, 1
	mov	DWORD PTR _nrtrans$[ebp], eax
$LN4@xmlRegStat:
	cmp	DWORD PTR _nrtrans$[ebp], 0
	jl	SHORT $LN3@xmlRegStat

; 1369 : 	xmlRegTransPtr trans = &(state->trans[nrtrans]);

	imul	ecx, DWORD PTR _nrtrans$[ebp], 20
	mov	edx, DWORD PTR _state$[ebp]
	add	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR _trans$2[ebp], ecx

; 1370 : 	if ((trans->atom == atom) &&
; 1371 : 	    (trans->to == target->no) &&
; 1372 : 	    (trans->counter == counter) &&

	mov	eax, DWORD PTR _trans$2[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _atom$[ebp]
	jne	SHORT $LN7@xmlRegStat
	mov	edx, DWORD PTR _trans$2[ebp]
	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+16]
	jne	SHORT $LN7@xmlRegStat
	mov	edx, DWORD PTR _trans$2[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _counter$[ebp]
	jne	SHORT $LN7@xmlRegStat
	mov	ecx, DWORD PTR _trans$2[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _count$[ebp]
	jne	SHORT $LN7@xmlRegStat

; 1373 : 	    (trans->count == count)) {
; 1374 : #ifdef DEBUG_REGEXP_GRAPH
; 1375 : 	    printf("Ignoring duplicate transition from %d to %d\n",
; 1376 : 		    state->no, target->no);
; 1377 : #endif
; 1378 : 	    return;

	jmp	$LN1@xmlRegStat
$LN7@xmlRegStat:

; 1379 : 	}
; 1380 :     }

	jmp	SHORT $LN2@xmlRegStat
$LN3@xmlRegStat:

; 1381 : 
; 1382 :     if (state->maxTrans == 0) {

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN8@xmlRegStat

; 1383 : 	state->maxTrans = 8;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+20], 8

; 1384 : 	state->trans = (xmlRegTrans *) xmlMalloc(state->maxTrans *

	mov	edx, DWORD PTR _state$[ebp]
	imul	eax, DWORD PTR [edx+20], 20
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 1385 : 		                             sizeof(xmlRegTrans));
; 1386 : 	if (state->trans == NULL) {

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+28], 0
	jne	SHORT $LN10@xmlRegStat

; 1387 : 	    xmlRegexpErrMemory(ctxt, "adding transition");

	push	OFFSET ??_C@_0BC@FHJHIDDF@adding?5transition@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1388 : 	    state->maxTrans = 0;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 1389 : 	    return;

	jmp	$LN1@xmlRegStat
$LN10@xmlRegStat:

; 1390 : 	}

	jmp	SHORT $LN9@xmlRegStat
$LN8@xmlRegStat:

; 1391 :     } else if (state->nbTrans >= state->maxTrans) {

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [eax+20]
	jl	SHORT $LN9@xmlRegStat

; 1392 : 	xmlRegTrans *tmp;
; 1393 : 	state->maxTrans *= 2;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shl	eax, 1
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 1394 : 	tmp = (xmlRegTrans *) xmlRealloc(state->trans, state->maxTrans *

	mov	edx, DWORD PTR _state$[ebp]
	imul	eax, DWORD PTR [edx+20], 20
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 1395 : 		                             sizeof(xmlRegTrans));
; 1396 : 	if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN12@xmlRegStat

; 1397 : 	    xmlRegexpErrMemory(ctxt, "adding transition");

	push	OFFSET ??_C@_0BC@FHJHIDDF@adding?5transition@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1398 : 	    state->maxTrans /= 2;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+20], eax

; 1399 : 	    return;

	jmp	$LN1@xmlRegStat
$LN12@xmlRegStat:

; 1400 : 	}
; 1401 : 	state->trans = tmp;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [eax+28], ecx
$LN9@xmlRegStat:

; 1402 :     }
; 1403 : #ifdef DEBUG_REGEXP_GRAPH
; 1404 :     printf("Add trans from %d to %d ", state->no, target->no);
; 1405 :     if (count == REGEXP_ALL_COUNTER)
; 1406 : 	printf("all transition\n");
; 1407 :     else if (count >= 0)
; 1408 : 	printf("count based %d\n", count);
; 1409 :     else if (counter >= 0)
; 1410 : 	printf("counted %d\n", counter);
; 1411 :     else if (atom == NULL)
; 1412 : 	printf("epsilon transition\n");
; 1413 :     else if (atom != NULL)
; 1414 :         xmlRegPrintAtom(stdout, atom);
; 1415 : #endif
; 1416 : 
; 1417 :     state->trans[state->nbTrans].atom = atom;

	mov	edx, DWORD PTR _state$[ebp]
	imul	eax, DWORD PTR [edx+24], 20
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [edx+eax], ecx

; 1418 :     state->trans[state->nbTrans].to = target->no;

	mov	edx, DWORD PTR _state$[ebp]
	imul	eax, DWORD PTR [edx+24], 20
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+eax+4], ecx

; 1419 :     state->trans[state->nbTrans].counter = counter;

	mov	edx, DWORD PTR _state$[ebp]
	imul	eax, DWORD PTR [edx+24], 20
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR _counter$[ebp]
	mov	DWORD PTR [edx+eax+8], ecx

; 1420 :     state->trans[state->nbTrans].count = count;

	mov	edx, DWORD PTR _state$[ebp]
	imul	eax, DWORD PTR [edx+24], 20
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [edx+eax+12], ecx

; 1421 :     state->trans[state->nbTrans].nd = 0;

	mov	edx, DWORD PTR _state$[ebp]
	imul	eax, DWORD PTR [edx+24], 20
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [edx+eax+16], 0

; 1422 :     state->nbTrans++;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 1423 :     xmlRegStateAddTransTo(ctxt, target, state->no);

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _target$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegStateAddTransTo
	add	esp, 12					; 0000000cH
$LN1@xmlRegStat:

; 1424 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegStateAddTrans ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegStateAddTransTo
_TEXT	SEGMENT
_tmp$1 = -4						; size = 4
_ctxt$ = 8						; size = 4
_target$ = 12						; size = 4
_from$ = 16						; size = 4
_xmlRegStateAddTransTo PROC				; COMDAT

; 1321 :                       int from) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1322 :     if (target->maxTransTo == 0) {

	mov	eax, DWORD PTR _target$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN2@xmlRegStat

; 1323 : 	target->maxTransTo = 8;

	mov	ecx, DWORD PTR _target$[ebp]
	mov	DWORD PTR [ecx+32], 8

; 1324 : 	target->transTo = (int *) xmlMalloc(target->maxTransTo *

	mov	edx, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR [edx+32]
	shl	eax, 2
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _target$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 1325 : 		                             sizeof(int));
; 1326 : 	if (target->transTo == NULL) {

	mov	edx, DWORD PTR _target$[ebp]
	cmp	DWORD PTR [edx+40], 0
	jne	SHORT $LN4@xmlRegStat

; 1327 : 	    xmlRegexpErrMemory(ctxt, "adding transition");

	push	OFFSET ??_C@_0BC@FHJHIDDF@adding?5transition@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1328 : 	    target->maxTransTo = 0;

	mov	ecx, DWORD PTR _target$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 1329 : 	    return;

	jmp	$LN1@xmlRegStat
$LN4@xmlRegStat:

; 1330 : 	}

	jmp	SHORT $LN3@xmlRegStat
$LN2@xmlRegStat:

; 1331 :     } else if (target->nbTransTo >= target->maxTransTo) {

	mov	edx, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	cmp	ecx, DWORD PTR [eax+32]
	jl	SHORT $LN3@xmlRegStat

; 1332 : 	int *tmp;
; 1333 : 	target->maxTransTo *= 2;

	mov	edx, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR [edx+32]
	shl	eax, 1
	mov	ecx, DWORD PTR _target$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 1334 : 	tmp = (int *) xmlRealloc(target->transTo, target->maxTransTo *

	mov	edx, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR [edx+32]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 1335 : 		                             sizeof(int));
; 1336 : 	if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN6@xmlRegStat

; 1337 : 	    xmlRegexpErrMemory(ctxt, "adding transition");

	push	OFFSET ??_C@_0BC@FHJHIDDF@adding?5transition@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1338 : 	    target->maxTransTo /= 2;

	mov	ecx, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _target$[ebp]
	mov	DWORD PTR [edx+32], eax

; 1339 : 	    return;

	jmp	SHORT $LN1@xmlRegStat
$LN6@xmlRegStat:

; 1340 : 	}
; 1341 : 	target->transTo = tmp;

	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [eax+40], ecx
$LN3@xmlRegStat:

; 1342 :     }
; 1343 :     target->transTo[target->nbTransTo] = from;

	mov	edx, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _target$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 1344 :     target->nbTransTo++;

	mov	edx, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, 1
	mov	ecx, DWORD PTR _target$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN1@xmlRegStat:

; 1345 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegStateAddTransTo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegAtomPush
_TEXT	SEGMENT
_tmp$1 = -4						; size = 4
_ctxt$ = 8						; size = 4
_atom$ = 12						; size = 4
_xmlRegAtomPush PROC					; COMDAT

; 1288 : xmlRegAtomPush(xmlRegParserCtxtPtr ctxt, xmlRegAtomPtr atom) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1289 :     if (atom == NULL) {

	cmp	DWORD PTR _atom$[ebp], 0
	jne	SHORT $LN2@xmlRegAtom

; 1290 : 	ERROR("atom push: atom is NULL");

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0BI@LIIKMBAE@atom?5push?3?5atom?5is?5NULL@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegexpErrCompile
	add	esp, 8

; 1291 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlRegAtom
$LN2@xmlRegAtom:

; 1292 :     }
; 1293 :     if (ctxt->maxAtoms == 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $LN3@xmlRegAtom

; 1294 : 	ctxt->maxAtoms = 4;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+32], 4

; 1295 : 	ctxt->atoms = (xmlRegAtomPtr *) xmlMalloc(ctxt->maxAtoms *

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	shl	edx, 2
	mov	esi, esp
	push	edx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 1296 : 		                             sizeof(xmlRegAtomPtr));
; 1297 : 	if (ctxt->atoms == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+40], 0
	jne	SHORT $LN5@xmlRegAtom

; 1298 : 	    xmlRegexpErrMemory(ctxt, "pushing atom");

	push	OFFSET ??_C@_0N@PMKNEBIB@pushing?5atom@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1299 : 	    ctxt->maxAtoms = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 1300 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlRegAtom
$LN5@xmlRegAtom:

; 1301 : 	}

	jmp	SHORT $LN4@xmlRegAtom
$LN3@xmlRegAtom:

; 1302 :     } else if (ctxt->nbAtoms >= ctxt->maxAtoms) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	cmp	ecx, DWORD PTR [eax+32]
	jl	SHORT $LN4@xmlRegAtom

; 1303 : 	xmlRegAtomPtr *tmp;
; 1304 : 	ctxt->maxAtoms *= 2;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	shl	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 1305 : 	tmp = (xmlRegAtomPtr *) xmlRealloc(ctxt->atoms, ctxt->maxAtoms *

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 1306 : 		                             sizeof(xmlRegAtomPtr));
; 1307 : 	if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN7@xmlRegAtom

; 1308 : 	    xmlRegexpErrMemory(ctxt, "allocating counter");

	push	OFFSET ??_C@_0BD@OEINICOI@allocating?5counter@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1309 : 	    ctxt->maxAtoms /= 2;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+32], eax

; 1310 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlRegAtom
$LN7@xmlRegAtom:

; 1311 : 	}
; 1312 : 	ctxt->atoms = tmp;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [eax+40], ecx
$LN4@xmlRegAtom:

; 1313 :     }
; 1314 :     atom->no = ctxt->nbAtoms;

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx], ecx

; 1315 :     ctxt->atoms[ctxt->nbAtoms++] = atom;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 1316 :     return(0);

	xor	eax, eax
$LN1@xmlRegAtom:

; 1317 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegAtomPush ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegGetCounter
_TEXT	SEGMENT
tv142 = -8						; size = 4
_tmp$1 = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlRegGetCounter PROC					; COMDAT

; 1260 : xmlRegGetCounter(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1261 :     if (ctxt->maxCounters == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN2@xmlRegGetC

; 1262 : 	ctxt->maxCounters = 4;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+56], 4

; 1263 : 	ctxt->counters = (xmlRegCounter *) xmlMalloc(ctxt->maxCounters *

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+56]
	shl	eax, 3
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 1264 : 		                             sizeof(xmlRegCounter));
; 1265 : 	if (ctxt->counters == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+64], 0
	jne	SHORT $LN4@xmlRegGetC

; 1266 : 	    xmlRegexpErrMemory(ctxt, "allocating counter");

	push	OFFSET ??_C@_0BD@OEINICOI@allocating?5counter@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1267 : 	    ctxt->maxCounters = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 1268 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlRegGetC
$LN4@xmlRegGetC:

; 1269 : 	}

	jmp	SHORT $LN3@xmlRegGetC
$LN2@xmlRegGetC:

; 1270 :     } else if (ctxt->nbCounters >= ctxt->maxCounters) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	cmp	ecx, DWORD PTR [eax+56]
	jl	SHORT $LN3@xmlRegGetC

; 1271 : 	xmlRegCounter *tmp;
; 1272 : 	ctxt->maxCounters *= 2;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+56]
	shl	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+56], eax

; 1273 : 	tmp = (xmlRegCounter *) xmlRealloc(ctxt->counters, ctxt->maxCounters *

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+56]
	shl	eax, 3
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 1274 : 		                           sizeof(xmlRegCounter));
; 1275 : 	if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN6@xmlRegGetC

; 1276 : 	    xmlRegexpErrMemory(ctxt, "allocating counter");

	push	OFFSET ??_C@_0BD@OEINICOI@allocating?5counter@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1277 : 	    ctxt->maxCounters /= 2;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+56]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+56], eax

; 1278 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlRegGetC
$LN6@xmlRegGetC:

; 1279 : 	}
; 1280 : 	ctxt->counters = tmp;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [eax+64], ecx
$LN3@xmlRegGetC:

; 1281 :     }
; 1282 :     ctxt->counters[ctxt->nbCounters].min = -1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [edx+eax*8], -1

; 1283 :     ctxt->counters[ctxt->nbCounters].max = -1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR [eax+ecx*8+4], -1

; 1284 :     return(ctxt->nbCounters++);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR tv142[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+60], ecx
	mov	eax, DWORD PTR tv142[ebp]
$LN1@xmlRegGetC:

; 1285 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegGetCounter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegAtomAddRange
_TEXT	SEGMENT
_tmp$1 = -8						; size = 4
_range$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_atom$ = 12						; size = 4
_neg$ = 16						; size = 4
_type$ = 20						; size = 4
_start$ = 24						; size = 4
_end$ = 28						; size = 4
_blockName$ = 32					; size = 4
_xmlRegAtomAddRange PROC				; COMDAT

; 1219 : 		   xmlChar *blockName) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1220 :     xmlRegRangePtr range;
; 1221 : 
; 1222 :     if (atom == NULL) {

	cmp	DWORD PTR _atom$[ebp], 0
	jne	SHORT $LN2@xmlRegAtom

; 1223 : 	ERROR("add range: atom is NULL");

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0BI@MEBKNK@add?5range?3?5atom?5is?5NULL@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegexpErrCompile
	add	esp, 8

; 1224 : 	return;

	jmp	$LN1@xmlRegAtom
$LN2@xmlRegAtom:

; 1225 :     }
; 1226 :     if (atom->type != XML_REGEXP_RANGES) {

	mov	edx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [edx+4], 3
	je	SHORT $LN3@xmlRegAtom

; 1227 : 	ERROR("add range: atom is not ranges");

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0BO@PJJILLLG@add?5range?3?5atom?5is?5not?5ranges@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegexpErrCompile
	add	esp, 8

; 1228 : 	return;

	jmp	$LN1@xmlRegAtom
$LN3@xmlRegAtom:

; 1229 :     }
; 1230 :     if (atom->maxRanges == 0) {

	mov	edx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [edx+48], 0
	jne	SHORT $LN4@xmlRegAtom

; 1231 : 	atom->maxRanges = 4;

	mov	eax, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [eax+48], 4

; 1232 : 	atom->ranges = (xmlRegRangePtr *) xmlMalloc(atom->maxRanges *

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	shl	edx, 2
	mov	esi, esp
	push	edx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [ecx+56], eax

; 1233 : 		                             sizeof(xmlRegRangePtr));
; 1234 : 	if (atom->ranges == NULL) {

	mov	edx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN6@xmlRegAtom

; 1235 : 	    xmlRegexpErrMemory(ctxt, "adding ranges");

	push	OFFSET ??_C@_0O@INOJCFAI@adding?5ranges@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1236 : 	    atom->maxRanges = 0;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 1237 : 	    return;

	jmp	$LN1@xmlRegAtom
$LN6@xmlRegAtom:

; 1238 : 	}

	jmp	SHORT $LN5@xmlRegAtom
$LN4@xmlRegAtom:

; 1239 :     } else if (atom->nbRanges >= atom->maxRanges) {

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	cmp	ecx, DWORD PTR [eax+48]
	jl	SHORT $LN5@xmlRegAtom

; 1240 : 	xmlRegRangePtr *tmp;
; 1241 : 	atom->maxRanges *= 2;

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+48]
	shl	eax, 1
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 1242 : 	tmp = (xmlRegRangePtr *) xmlRealloc(atom->ranges, atom->maxRanges *

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+48]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 1243 : 		                             sizeof(xmlRegRangePtr));
; 1244 : 	if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN8@xmlRegAtom

; 1245 : 	    xmlRegexpErrMemory(ctxt, "adding ranges");

	push	OFFSET ??_C@_0O@INOJCFAI@adding?5ranges@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1246 : 	    atom->maxRanges /= 2;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [edx+48], eax

; 1247 : 	    return;

	jmp	SHORT $LN1@xmlRegAtom
$LN8@xmlRegAtom:

; 1248 : 	}
; 1249 : 	atom->ranges = tmp;

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [eax+56], ecx
$LN5@xmlRegAtom:

; 1250 :     }
; 1251 :     range = xmlRegNewRange(ctxt, neg, type, start, end);

	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _neg$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegNewRange
	add	esp, 20					; 00000014H
	mov	DWORD PTR _range$[ebp], eax

; 1252 :     if (range == NULL)

	cmp	DWORD PTR _range$[ebp], 0
	jne	SHORT $LN9@xmlRegAtom

; 1253 : 	return;

	jmp	SHORT $LN1@xmlRegAtom
$LN9@xmlRegAtom:

; 1254 :     range->blockName = blockName;

	mov	ecx, DWORD PTR _range$[ebp]
	mov	edx, DWORD PTR _blockName$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1255 :     atom->ranges[atom->nbRanges++] = range;

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	edx, DWORD PTR _range$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, 1
	mov	edx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [edx+52], ecx
$LN1@xmlRegAtom:

; 1256 : 
; 1257 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegAtomAddRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegPrintState
_TEXT	SEGMENT
_i$ = -4						; size = 4
_output$ = 8						; size = 4
_state$ = 12						; size = 4
_xmlRegPrintState PROC					; COMDAT

; 1149 : xmlRegPrintState(FILE *output, xmlRegStatePtr state) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1150 :     int i;
; 1151 : 
; 1152 :     fprintf(output, " state: ");

	push	OFFSET ??_C@_08NOIFNCJM@?5state?3?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8

; 1153 :     if (state == NULL) {

	cmp	DWORD PTR _state$[ebp], 0
	jne	SHORT $LN5@xmlRegPrin

; 1154 : 	fprintf(output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8

; 1155 : 	return;

	jmp	$LN1@xmlRegPrin
$LN5@xmlRegPrin:

; 1156 :     }
; 1157 :     if (state->type == XML_REGEXP_START_STATE)

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx], 1
	jne	SHORT $LN6@xmlRegPrin

; 1158 : 	fprintf(output, "START ");

	push	OFFSET ??_C@_06BNBHINFE@START?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
$LN6@xmlRegPrin:

; 1159 :     if (state->type == XML_REGEXP_FINAL_STATE)

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx], 2
	jne	SHORT $LN7@xmlRegPrin

; 1160 : 	fprintf(output, "FINAL ");

	push	OFFSET ??_C@_06EFHALCBA@FINAL?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
$LN7@xmlRegPrin:

; 1161 : 
; 1162 :     fprintf(output, "%d, %d transitions:\n", state->no, state->nbTrans);

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	OFFSET ??_C@_0BF@NHMHHIIL@?$CFd?0?5?$CFd?5transitions?3?6@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 16					; 00000010H

; 1163 :     for (i = 0;i < state->nbTrans; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlRegPrin
$LN2@xmlRegPrin:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@xmlRegPrin:
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	SHORT $LN1@xmlRegPrin

; 1164 : 	xmlRegPrintTrans(output, &(state->trans[i]));

	imul	edx, DWORD PTR _i$[ebp], 20
	mov	eax, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR [eax+28]
	push	edx
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_xmlRegPrintTrans
	add	esp, 8

; 1165 :     }

	jmp	SHORT $LN2@xmlRegPrin
$LN1@xmlRegPrin:

; 1166 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegPrintState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegPrintTrans
_TEXT	SEGMENT
_output$ = 8						; size = 4
_trans$ = 12						; size = 4
_xmlRegPrintTrans PROC					; COMDAT

; 1115 : xmlRegPrintTrans(FILE *output, xmlRegTransPtr trans) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1116 :     fprintf(output, "  trans: ");

	push	OFFSET ??_C@_09KCGMBGNH@?5?5trans?3?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8

; 1117 :     if (trans == NULL) {

	cmp	DWORD PTR _trans$[ebp], 0
	jne	SHORT $LN2@xmlRegPrin

; 1118 : 	fprintf(output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8

; 1119 : 	return;

	jmp	$LN1@xmlRegPrin
$LN2@xmlRegPrin:

; 1120 :     }
; 1121 :     if (trans->to < 0) {

	mov	edx, DWORD PTR _trans$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jge	SHORT $LN3@xmlRegPrin

; 1122 : 	fprintf(output, "removed\n");

	push	OFFSET ??_C@_08IDDAKHFP@removed?6@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8

; 1123 : 	return;

	jmp	$LN1@xmlRegPrin
$LN3@xmlRegPrin:

; 1124 :     }
; 1125 :     if (trans->nd != 0) {

	mov	ecx, DWORD PTR _trans$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN4@xmlRegPrin

; 1126 : 	if (trans->nd == 2)

	mov	edx, DWORD PTR _trans$[ebp]
	cmp	DWORD PTR [edx+16], 2
	jne	SHORT $LN5@xmlRegPrin

; 1127 : 	    fprintf(output, "last not determinist, ");

	push	OFFSET ??_C@_0BH@PJNPIGKD@last?5not?5determinist?0?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN4@xmlRegPrin
$LN5@xmlRegPrin:

; 1128 : 	else
; 1129 : 	    fprintf(output, "not determinist, ");

	push	OFFSET ??_C@_0BC@EKCPHBCA@not?5determinist?0?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN4@xmlRegPrin:

; 1130 :     }
; 1131 :     if (trans->counter >= 0) {

	mov	edx, DWORD PTR _trans$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jl	SHORT $LN7@xmlRegPrin

; 1132 : 	fprintf(output, "counted %d, ", trans->counter);

	mov	eax, DWORD PTR _trans$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_0N@NIIDMCG@counted?5?$CFd?0?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN7@xmlRegPrin:

; 1133 :     }
; 1134 :     if (trans->count == REGEXP_ALL_COUNTER) {

	mov	eax, DWORD PTR _trans$[ebp]
	cmp	DWORD PTR [eax+12], 1193046		; 00123456H
	jne	SHORT $LN8@xmlRegPrin

; 1135 : 	fprintf(output, "all transition, ");

	push	OFFSET ??_C@_0BB@CPMJDJHN@all?5transition?0?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN9@xmlRegPrin
$LN8@xmlRegPrin:

; 1136 :     } else if (trans->count >= 0) {

	mov	edx, DWORD PTR _trans$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jl	SHORT $LN9@xmlRegPrin

; 1137 : 	fprintf(output, "count based %d, ", trans->count);

	mov	eax, DWORD PTR _trans$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	OFFSET ??_C@_0BB@LHHOLMKP@count?5based?5?$CFd?0?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN9@xmlRegPrin:

; 1138 :     }
; 1139 :     if (trans->atom == NULL) {

	mov	eax, DWORD PTR _trans$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN11@xmlRegPrin

; 1140 : 	fprintf(output, "epsilon to %d\n", trans->to);

	mov	ecx, DWORD PTR _trans$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	OFFSET ??_C@_0P@BEFDCDEN@epsilon?5to?5?$CFd?6@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1141 : 	return;

	jmp	SHORT $LN1@xmlRegPrin
$LN11@xmlRegPrin:

; 1142 :     }
; 1143 :     if (trans->atom->type == XML_REGEXP_CHARVAL)

	mov	ecx, DWORD PTR _trans$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+4], 2
	jne	SHORT $LN12@xmlRegPrin

; 1144 : 	fprintf(output, "char %c ", trans->atom->codepoint);

	mov	eax, DWORD PTR _trans$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	push	OFFSET ??_C@_08JNAFCHHG@char?5?$CFc?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN12@xmlRegPrin:

; 1145 :     fprintf(output, "atom %d, to %d\n", trans->atom->no, trans->to);

	mov	ecx, DWORD PTR _trans$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _trans$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0BA@DDAHGLMD@atom?5?$CFd?0?5to?5?$CFd?6@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H
$LN1@xmlRegPrin:

; 1146 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlRegPrintTrans ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegPrintAtom
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_output$ = 8						; size = 4
_atom$ = 12						; size = 4
_xmlRegPrintAtom PROC					; COMDAT

; 1086 : xmlRegPrintAtom(FILE *output, xmlRegAtomPtr atom) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1087 :     fprintf(output, " atom: ");

	push	OFFSET ??_C@_07LAIPMBOA@?5atom?3?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8

; 1088 :     if (atom == NULL) {

	cmp	DWORD PTR _atom$[ebp], 0
	jne	SHORT $LN5@xmlRegPrin

; 1089 : 	fprintf(output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8

; 1090 : 	return;

	jmp	$LN1@xmlRegPrin
$LN5@xmlRegPrin:

; 1091 :     }
; 1092 :     if (atom->neg)

	mov	edx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN6@xmlRegPrin

; 1093 :         fprintf(output, "not ");

	push	OFFSET ??_C@_04LKOGMCLF@not?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
$LN6@xmlRegPrin:

; 1094 :     xmlRegPrintAtomType(output, atom->type);

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_xmlRegPrintAtomType
	add	esp, 8

; 1095 :     xmlRegPrintQuantType(output, atom->quant);

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_xmlRegPrintQuantType
	add	esp, 8

; 1096 :     if (atom->quant == XML_REGEXP_QUANT_RANGE)

	mov	ecx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [ecx+8], 8
	jne	SHORT $LN7@xmlRegPrin

; 1097 : 	fprintf(output, "%d-%d ", atom->min, atom->max);

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	push	OFFSET ??_C@_06BIJEIIBB@?$CFd?9?$CFd?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H
$LN7@xmlRegPrin:

; 1098 :     if (atom->type == XML_REGEXP_STRING)

	mov	ecx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [ecx+4], 5
	jne	SHORT $LN8@xmlRegPrin

; 1099 : 	fprintf(output, "'%s' ", (char *) atom->valuep);

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	push	OFFSET ??_C@_05IMLJLABD@?8?$CFs?8?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN8@xmlRegPrin:

; 1100 :     if (atom->type == XML_REGEXP_CHARVAL)

	mov	edx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [edx+4], 2
	jne	SHORT $LN9@xmlRegPrin

; 1101 : 	fprintf(output, "char %c\n", atom->codepoint);

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	push	OFFSET ??_C@_08PCGOOLFO@char?5?$CFc?6@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	$LN1@xmlRegPrin
$LN9@xmlRegPrin:

; 1102 :     else if (atom->type == XML_REGEXP_RANGES) {

	mov	eax, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [eax+4], 3
	jne	SHORT $LN11@xmlRegPrin

; 1103 : 	int i;
; 1104 : 	fprintf(output, "%d entries\n", atom->nbRanges);

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	push	OFFSET ??_C@_0M@BCDCHBAM@?$CFd?5entries?6@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1105 : 	for (i = 0; i < atom->nbRanges;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@xmlRegPrin
$LN2@xmlRegPrin:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN4@xmlRegPrin:
	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR [edx+52]
	jge	SHORT $LN3@xmlRegPrin

; 1106 : 	    xmlRegPrintRange(output, atom->ranges[i]);

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_xmlRegPrintRange
	add	esp, 8
	jmp	SHORT $LN2@xmlRegPrin
$LN3@xmlRegPrin:

; 1107 :     } else if (atom->type == XML_REGEXP_SUBREG) {

	jmp	SHORT $LN1@xmlRegPrin
$LN11@xmlRegPrin:
	mov	eax, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [eax+4], 4
	jne	SHORT $LN13@xmlRegPrin

; 1108 : 	fprintf(output, "start %d end %d\n", atom->start->no, atom->stop->no);

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	OFFSET ??_C@_0BB@GBMGKEL@start?5?$CFd?5end?5?$CFd?6@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 16					; 00000010H

; 1109 :     } else {

	jmp	SHORT $LN1@xmlRegPrin
$LN13@xmlRegPrin:

; 1110 : 	fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
$LN1@xmlRegPrin:

; 1111 :     }
; 1112 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegPrintAtom ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegPrintRange
_TEXT	SEGMENT
_output$ = 8						; size = 4
_range$ = 12						; size = 4
_xmlRegPrintRange PROC					; COMDAT

; 1077 : xmlRegPrintRange(FILE *output, xmlRegRangePtr range) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1078 :     fprintf(output, "  range: ");

	push	OFFSET ??_C@_09LLABEBOE@?5?5range?3?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8

; 1079 :     if (range->neg)

	mov	ecx, DWORD PTR _range$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN2@xmlRegPrin

; 1080 : 	fprintf(output, "negative ");

	push	OFFSET ??_C@_09KDBNABJA@negative?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
$LN2@xmlRegPrin:

; 1081 :     xmlRegPrintAtomType(output, range->type);

	mov	eax, DWORD PTR _range$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_xmlRegPrintAtomType
	add	esp, 8

; 1082 :     fprintf(output, "%c - %c\n", range->start, range->end);

	mov	eax, DWORD PTR _range$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _range$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	OFFSET ??_C@_08BNCIEJGK@?$CFc?5?9?5?$CFc?6@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 16					; 00000010H

; 1083 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlRegPrintRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegPrintQuantType
_TEXT	SEGMENT
tv64 = -4						; size = 4
_output$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlRegPrintQuantType PROC				; COMDAT

; 1056 : xmlRegPrintQuantType(FILE *output, xmlRegQuantType type) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1057 :     switch (type) {

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 7
	ja	$LN1@xmlRegPrin
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN13@xmlRegPrin[edx*4]
$LN4@xmlRegPrin:

; 1058 :         case XML_REGEXP_QUANT_EPSILON:
; 1059 : 	    fprintf(output, "epsilon "); break;

	push	OFFSET ??_C@_08LJGDJFJP@epsilon?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN5@xmlRegPrin:

; 1060 :         case XML_REGEXP_QUANT_ONCE:
; 1061 : 	    fprintf(output, "once "); break;

	push	OFFSET ??_C@_05GDJGFPHL@once?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN1@xmlRegPrin
$LN6@xmlRegPrin:

; 1062 :         case XML_REGEXP_QUANT_OPT:
; 1063 : 	    fprintf(output, "? "); break;

	push	OFFSET ??_C@_02LKANKAOC@?$DP?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN1@xmlRegPrin
$LN7@xmlRegPrin:

; 1064 :         case XML_REGEXP_QUANT_MULT:
; 1065 : 	    fprintf(output, "* "); break;

	push	OFFSET ??_C@_02KAOAMBHJ@?$CK?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN1@xmlRegPrin
$LN8@xmlRegPrin:

; 1066 :         case XML_REGEXP_QUANT_PLUS:
; 1067 : 	    fprintf(output, "+ "); break;

	push	OFFSET ??_C@_02KBCCKLEO@?$CL?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN1@xmlRegPrin
$LN9@xmlRegPrin:

; 1068 : 	case XML_REGEXP_QUANT_RANGE:
; 1069 : 	    fprintf(output, "range "); break;

	push	OFFSET ??_C@_06IBKHBGID@range?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN1@xmlRegPrin
$LN10@xmlRegPrin:

; 1070 : 	case XML_REGEXP_QUANT_ONCEONLY:
; 1071 : 	    fprintf(output, "onceonly "); break;

	push	OFFSET ??_C@_09EPCGBNDN@onceonly?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN1@xmlRegPrin
$LN11@xmlRegPrin:

; 1072 : 	case XML_REGEXP_QUANT_ALL:
; 1073 : 	    fprintf(output, "all "); break;

	push	OFFSET ??_C@_04DIDGAIEC@all?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN1@xmlRegPrin:

; 1074 :     }
; 1075 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN13@xmlRegPrin:
	DD	$LN4@xmlRegPrin
	DD	$LN5@xmlRegPrin
	DD	$LN6@xmlRegPrin
	DD	$LN7@xmlRegPrin
	DD	$LN8@xmlRegPrin
	DD	$LN10@xmlRegPrin
	DD	$LN11@xmlRegPrin
	DD	$LN9@xmlRegPrin
_xmlRegPrintQuantType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegPrintAtomType
_TEXT	SEGMENT
tv64 = -4						; size = 4
_output$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlRegPrintAtomType PROC				; COMDAT

; 944  : xmlRegPrintAtomType(FILE *output, xmlRegAtomType type) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 945  :     switch (type) {

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 135		; 00000087H
	ja	$LN1@xmlRegPrin
	mov	edx, DWORD PTR tv64[ebp]
	movzx	eax, BYTE PTR $LN58@xmlRegPrin[edx]
	jmp	DWORD PTR $LN59@xmlRegPrin[eax*4]
$LN4@xmlRegPrin:

; 946  :         case XML_REGEXP_EPSILON:
; 947  : 	    fprintf(output, "epsilon "); break;

	push	OFFSET ??_C@_08LJGDJFJP@epsilon?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN5@xmlRegPrin:

; 948  :         case XML_REGEXP_CHARVAL:
; 949  : 	    fprintf(output, "charval "); break;

	push	OFFSET ??_C@_08DFHMJFEK@charval?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN6@xmlRegPrin:

; 950  :         case XML_REGEXP_RANGES:
; 951  : 	    fprintf(output, "ranges "); break;

	push	OFFSET ??_C@_07IPEOMBMH@ranges?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN7@xmlRegPrin:

; 952  :         case XML_REGEXP_SUBREG:
; 953  : 	    fprintf(output, "subexpr "); break;

	push	OFFSET ??_C@_08BABENLJO@subexpr?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN8@xmlRegPrin:

; 954  :         case XML_REGEXP_STRING:
; 955  : 	    fprintf(output, "string "); break;

	push	OFFSET ??_C@_07HBAIICBM@string?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN9@xmlRegPrin:

; 956  :         case XML_REGEXP_ANYCHAR:
; 957  : 	    fprintf(output, "anychar "); break;

	push	OFFSET ??_C@_08IIDGBAEF@anychar?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN10@xmlRegPrin:

; 958  :         case XML_REGEXP_ANYSPACE:
; 959  : 	    fprintf(output, "anyspace "); break;

	push	OFFSET ??_C@_09IFBFMEEE@anyspace?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN11@xmlRegPrin:

; 960  :         case XML_REGEXP_NOTSPACE:
; 961  : 	    fprintf(output, "notspace "); break;

	push	OFFSET ??_C@_09PIGAJOFL@notspace?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN12@xmlRegPrin:

; 962  :         case XML_REGEXP_INITNAME:
; 963  : 	    fprintf(output, "initname "); break;

	push	OFFSET ??_C@_09PGNNJPMN@initname?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN13@xmlRegPrin:

; 964  :         case XML_REGEXP_NOTINITNAME:
; 965  : 	    fprintf(output, "notinitname "); break;

	push	OFFSET ??_C@_0N@PKALLFNP@notinitname?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN14@xmlRegPrin:

; 966  :         case XML_REGEXP_NAMECHAR:
; 967  : 	    fprintf(output, "namechar "); break;

	push	OFFSET ??_C@_09GMGKKJAH@namechar?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN15@xmlRegPrin:

; 968  :         case XML_REGEXP_NOTNAMECHAR:
; 969  : 	    fprintf(output, "notnamechar "); break;

	push	OFFSET ??_C@_0N@GALMIDBF@notnamechar?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN16@xmlRegPrin:

; 970  :         case XML_REGEXP_DECIMAL:
; 971  : 	    fprintf(output, "decimal "); break;

	push	OFFSET ??_C@_08CDKGKILA@decimal?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN17@xmlRegPrin:

; 972  :         case XML_REGEXP_NOTDECIMAL:
; 973  : 	    fprintf(output, "notdecimal "); break;

	push	OFFSET ??_C@_0M@EDJHICHL@notdecimal?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN18@xmlRegPrin:

; 974  :         case XML_REGEXP_REALCHAR:
; 975  : 	    fprintf(output, "realchar "); break;

	push	OFFSET ??_C@_09MOCDMJPB@realchar?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN19@xmlRegPrin:

; 976  :         case XML_REGEXP_NOTREALCHAR:
; 977  : 	    fprintf(output, "notrealchar "); break;

	push	OFFSET ??_C@_0N@MCPFODOD@notrealchar?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN20@xmlRegPrin:

; 978  :         case XML_REGEXP_LETTER:
; 979  :             fprintf(output, "LETTER "); break;

	push	OFFSET ??_C@_07POCGPIHD@LETTER?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN21@xmlRegPrin:

; 980  :         case XML_REGEXP_LETTER_UPPERCASE:
; 981  :             fprintf(output, "LETTER_UPPERCASE "); break;

	push	OFFSET ??_C@_0BC@KMHMCLHI@LETTER_UPPERCASE?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN22@xmlRegPrin:

; 982  :         case XML_REGEXP_LETTER_LOWERCASE:
; 983  :             fprintf(output, "LETTER_LOWERCASE "); break;

	push	OFFSET ??_C@_0BC@MLADGGJK@LETTER_LOWERCASE?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN23@xmlRegPrin:

; 984  :         case XML_REGEXP_LETTER_TITLECASE:
; 985  :             fprintf(output, "LETTER_TITLECASE "); break;

	push	OFFSET ??_C@_0BC@FGJDLGPN@LETTER_TITLECASE?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN24@xmlRegPrin:

; 986  :         case XML_REGEXP_LETTER_MODIFIER:
; 987  :             fprintf(output, "LETTER_MODIFIER "); break;

	push	OFFSET ??_C@_0BB@MHDADLFE@LETTER_MODIFIER?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN25@xmlRegPrin:

; 988  :         case XML_REGEXP_LETTER_OTHERS:
; 989  :             fprintf(output, "LETTER_OTHERS "); break;

	push	OFFSET ??_C@_0P@ONCGNHEJ@LETTER_OTHERS?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN26@xmlRegPrin:

; 990  :         case XML_REGEXP_MARK:
; 991  :             fprintf(output, "MARK "); break;

	push	OFFSET ??_C@_05BACHLHLN@MARK?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN27@xmlRegPrin:

; 992  :         case XML_REGEXP_MARK_NONSPACING:
; 993  :             fprintf(output, "MARK_NONSPACING "); break;

	push	OFFSET ??_C@_0BB@FIDLEIEL@MARK_NONSPACING?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN28@xmlRegPrin:

; 994  :         case XML_REGEXP_MARK_SPACECOMBINING:
; 995  :             fprintf(output, "MARK_SPACECOMBINING "); break;

	push	OFFSET ??_C@_0BF@GJKDPMF@MARK_SPACECOMBINING?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN29@xmlRegPrin:

; 996  :         case XML_REGEXP_MARK_ENCLOSING:
; 997  :             fprintf(output, "MARK_ENCLOSING "); break;

	push	OFFSET ??_C@_0BA@NNNPPLBP@MARK_ENCLOSING?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN30@xmlRegPrin:

; 998  :         case XML_REGEXP_NUMBER:
; 999  :             fprintf(output, "NUMBER "); break;

	push	OFFSET ??_C@_07BAKEFCLB@NUMBER?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN31@xmlRegPrin:

; 1000 :         case XML_REGEXP_NUMBER_DECIMAL:
; 1001 :             fprintf(output, "NUMBER_DECIMAL "); break;

	push	OFFSET ??_C@_0BA@JLEBGNKM@NUMBER_DECIMAL?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN32@xmlRegPrin:

; 1002 :         case XML_REGEXP_NUMBER_LETTER:
; 1003 :             fprintf(output, "NUMBER_LETTER "); break;

	push	OFFSET ??_C@_0P@FJBLFHMA@NUMBER_LETTER?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN33@xmlRegPrin:

; 1004 :         case XML_REGEXP_NUMBER_OTHERS:
; 1005 :             fprintf(output, "NUMBER_OTHERS "); break;

	push	OFFSET ??_C@_0P@PDKFLOJK@NUMBER_OTHERS?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN34@xmlRegPrin:

; 1006 :         case XML_REGEXP_PUNCT:
; 1007 :             fprintf(output, "PUNCT "); break;

	push	OFFSET ??_C@_06INFGODEH@PUNCT?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN35@xmlRegPrin:

; 1008 :         case XML_REGEXP_PUNCT_CONNECTOR:
; 1009 :             fprintf(output, "PUNCT_CONNECTOR "); break;

	push	OFFSET ??_C@_0BB@DCHADIII@PUNCT_CONNECTOR?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN36@xmlRegPrin:

; 1010 :         case XML_REGEXP_PUNCT_DASH:
; 1011 :             fprintf(output, "PUNCT_DASH "); break;

	push	OFFSET ??_C@_0M@BBMKBPFM@PUNCT_DASH?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN37@xmlRegPrin:

; 1012 :         case XML_REGEXP_PUNCT_OPEN:
; 1013 :             fprintf(output, "PUNCT_OPEN "); break;

	push	OFFSET ??_C@_0M@FHHCCFFM@PUNCT_OPEN?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN38@xmlRegPrin:

; 1014 :         case XML_REGEXP_PUNCT_CLOSE:
; 1015 :             fprintf(output, "PUNCT_CLOSE "); break;

	push	OFFSET ??_C@_0N@OCGFHNOE@PUNCT_CLOSE?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN39@xmlRegPrin:

; 1016 :         case XML_REGEXP_PUNCT_INITQUOTE:
; 1017 :             fprintf(output, "PUNCT_INITQUOTE "); break;

	push	OFFSET ??_C@_0BB@HJFINBLL@PUNCT_INITQUOTE?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN40@xmlRegPrin:

; 1018 :         case XML_REGEXP_PUNCT_FINQUOTE:
; 1019 :             fprintf(output, "PUNCT_FINQUOTE "); break;

	push	OFFSET ??_C@_0BA@EBCHGEDF@PUNCT_FINQUOTE?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN41@xmlRegPrin:

; 1020 :         case XML_REGEXP_PUNCT_OTHERS:
; 1021 :             fprintf(output, "PUNCT_OTHERS "); break;

	push	OFFSET ??_C@_0O@FIEDELON@PUNCT_OTHERS?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN42@xmlRegPrin:

; 1022 :         case XML_REGEXP_SEPAR:
; 1023 :             fprintf(output, "SEPAR "); break;

	push	OFFSET ??_C@_06MODMGGJL@SEPAR?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN43@xmlRegPrin:

; 1024 :         case XML_REGEXP_SEPAR_SPACE:
; 1025 :             fprintf(output, "SEPAR_SPACE "); break;

	push	OFFSET ??_C@_0N@CEDLANHM@SEPAR_SPACE?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN44@xmlRegPrin:

; 1026 :         case XML_REGEXP_SEPAR_LINE:
; 1027 :             fprintf(output, "SEPAR_LINE "); break;

	push	OFFSET ??_C@_0M@GPNEEMIA@SEPAR_LINE?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN45@xmlRegPrin:

; 1028 :         case XML_REGEXP_SEPAR_PARA:
; 1029 :             fprintf(output, "SEPAR_PARA "); break;

	push	OFFSET ??_C@_0M@DGHGIFFK@SEPAR_PARA?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN46@xmlRegPrin:

; 1030 :         case XML_REGEXP_SYMBOL:
; 1031 :             fprintf(output, "SYMBOL "); break;

	push	OFFSET ??_C@_07EJLPHCCB@SYMBOL?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN47@xmlRegPrin:

; 1032 :         case XML_REGEXP_SYMBOL_MATH:
; 1033 :             fprintf(output, "SYMBOL_MATH "); break;

	push	OFFSET ??_C@_0N@LBDJILGE@SYMBOL_MATH?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN48@xmlRegPrin:

; 1034 :         case XML_REGEXP_SYMBOL_CURRENCY:
; 1035 :             fprintf(output, "SYMBOL_CURRENCY "); break;

	push	OFFSET ??_C@_0BB@MBFAMNND@SYMBOL_CURRENCY?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN49@xmlRegPrin:

; 1036 :         case XML_REGEXP_SYMBOL_MODIFIER:
; 1037 :             fprintf(output, "SYMBOL_MODIFIER "); break;

	push	OFFSET ??_C@_0BB@CEPANLJE@SYMBOL_MODIFIER?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN1@xmlRegPrin
$LN50@xmlRegPrin:

; 1038 :         case XML_REGEXP_SYMBOL_OTHERS:
; 1039 :             fprintf(output, "SYMBOL_OTHERS "); break;

	push	OFFSET ??_C@_0P@LKPECLCL@SYMBOL_OTHERS?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN1@xmlRegPrin
$LN51@xmlRegPrin:

; 1040 :         case XML_REGEXP_OTHER:
; 1041 :             fprintf(output, "OTHER "); break;

	push	OFFSET ??_C@_06HJDKAKAL@OTHER?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN1@xmlRegPrin
$LN52@xmlRegPrin:

; 1042 :         case XML_REGEXP_OTHER_CONTROL:
; 1043 :             fprintf(output, "OTHER_CONTROL "); break;

	push	OFFSET ??_C@_0P@FGFCBEPI@OTHER_CONTROL?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN1@xmlRegPrin
$LN53@xmlRegPrin:

; 1044 :         case XML_REGEXP_OTHER_FORMAT:
; 1045 :             fprintf(output, "OTHER_FORMAT "); break;

	push	OFFSET ??_C@_0O@BACNFCMB@OTHER_FORMAT?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN1@xmlRegPrin
$LN54@xmlRegPrin:

; 1046 :         case XML_REGEXP_OTHER_PRIVATE:
; 1047 :             fprintf(output, "OTHER_PRIVATE "); break;

	push	OFFSET ??_C@_0P@DEHNHHA@OTHER_PRIVATE?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN1@xmlRegPrin
$LN55@xmlRegPrin:

; 1048 :         case XML_REGEXP_OTHER_NA:
; 1049 :             fprintf(output, "OTHER_NA "); break;

	push	OFFSET ??_C@_09NECDEFOF@OTHER_NA?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN1@xmlRegPrin
$LN56@xmlRegPrin:

; 1050 :         case XML_REGEXP_BLOCK_NAME:
; 1051 : 	    fprintf(output, "BLOCK "); break;

	push	OFFSET ??_C@_06HDNEPAAO@BLOCK?5@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
$LN1@xmlRegPrin:

; 1052 :     }
; 1053 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN59@xmlRegPrin:
	DD	$LN4@xmlRegPrin
	DD	$LN5@xmlRegPrin
	DD	$LN6@xmlRegPrin
	DD	$LN7@xmlRegPrin
	DD	$LN8@xmlRegPrin
	DD	$LN9@xmlRegPrin
	DD	$LN10@xmlRegPrin
	DD	$LN11@xmlRegPrin
	DD	$LN12@xmlRegPrin
	DD	$LN13@xmlRegPrin
	DD	$LN14@xmlRegPrin
	DD	$LN15@xmlRegPrin
	DD	$LN16@xmlRegPrin
	DD	$LN17@xmlRegPrin
	DD	$LN18@xmlRegPrin
	DD	$LN19@xmlRegPrin
	DD	$LN20@xmlRegPrin
	DD	$LN21@xmlRegPrin
	DD	$LN22@xmlRegPrin
	DD	$LN23@xmlRegPrin
	DD	$LN24@xmlRegPrin
	DD	$LN25@xmlRegPrin
	DD	$LN26@xmlRegPrin
	DD	$LN27@xmlRegPrin
	DD	$LN28@xmlRegPrin
	DD	$LN29@xmlRegPrin
	DD	$LN30@xmlRegPrin
	DD	$LN31@xmlRegPrin
	DD	$LN32@xmlRegPrin
	DD	$LN33@xmlRegPrin
	DD	$LN34@xmlRegPrin
	DD	$LN35@xmlRegPrin
	DD	$LN36@xmlRegPrin
	DD	$LN37@xmlRegPrin
	DD	$LN38@xmlRegPrin
	DD	$LN39@xmlRegPrin
	DD	$LN40@xmlRegPrin
	DD	$LN41@xmlRegPrin
	DD	$LN42@xmlRegPrin
	DD	$LN43@xmlRegPrin
	DD	$LN44@xmlRegPrin
	DD	$LN45@xmlRegPrin
	DD	$LN46@xmlRegPrin
	DD	$LN47@xmlRegPrin
	DD	$LN48@xmlRegPrin
	DD	$LN49@xmlRegPrin
	DD	$LN50@xmlRegPrin
	DD	$LN51@xmlRegPrin
	DD	$LN52@xmlRegPrin
	DD	$LN53@xmlRegPrin
	DD	$LN54@xmlRegPrin
	DD	$LN55@xmlRegPrin
	DD	$LN56@xmlRegPrin
	DD	$LN1@xmlRegPrin
$LN58@xmlRegPrin:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	39					; 00000027H
	DB	40					; 00000028H
	DB	41					; 00000029H
	DB	42					; 0000002aH
	DB	43					; 0000002bH
	DB	44					; 0000002cH
	DB	45					; 0000002dH
	DB	46					; 0000002eH
	DB	47					; 0000002fH
	DB	48					; 00000030H
	DB	49					; 00000031H
	DB	50					; 00000032H
	DB	51					; 00000033H
	DB	52					; 00000034H
_xmlRegPrintAtomType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegFreeParserCtxt
_TEXT	SEGMENT
_i$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlRegFreeParserCtxt PROC				; COMDAT

; 915  : xmlRegFreeParserCtxt(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 916  :     int i;
; 917  :     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN8@xmlRegFree

; 918  : 	return;

	jmp	$LN1@xmlRegFree
$LN8@xmlRegFree:

; 919  : 
; 920  :     if (ctxt->string != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@xmlRegFree

; 921  : 	xmlFree(ctxt->string);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@xmlRegFree:

; 922  :     if (ctxt->states != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN10@xmlRegFree

; 923  : 	for (i = 0;i < ctxt->nbStates;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlRegFree
$LN2@xmlRegFree:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlRegFree:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+48]
	jge	SHORT $LN3@xmlRegFree

; 924  : 	    xmlRegFreeState(ctxt->states[i]);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_xmlRegFreeState
	add	esp, 4
	jmp	SHORT $LN2@xmlRegFree
$LN3@xmlRegFree:

; 925  : 	xmlFree(ctxt->states);

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@xmlRegFree:

; 926  :     }
; 927  :     if (ctxt->atoms != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN11@xmlRegFree

; 928  : 	for (i = 0;i < ctxt->nbAtoms;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@xmlRegFree
$LN5@xmlRegFree:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@xmlRegFree:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jge	SHORT $LN6@xmlRegFree

; 929  : 	    xmlRegFreeAtom(ctxt->atoms[i]);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_xmlRegFreeAtom
	add	esp, 4
	jmp	SHORT $LN5@xmlRegFree
$LN6@xmlRegFree:

; 930  : 	xmlFree(ctxt->atoms);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlRegFree:

; 931  :     }
; 932  :     if (ctxt->counters != NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+64], 0
	je	SHORT $LN12@xmlRegFree

; 933  : 	xmlFree(ctxt->counters);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlRegFree:

; 934  :     xmlFree(ctxt);

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlRegFree:

; 935  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegFreeParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegNewState
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlRegNewState PROC					; COMDAT

; 876  : xmlRegNewState(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 877  :     xmlRegStatePtr ret;
; 878  : 
; 879  :     ret = (xmlRegStatePtr) xmlMalloc(sizeof(xmlRegState));

	mov	esi, esp
	push	44					; 0000002cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 880  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlRegNewS

; 881  : 	xmlRegexpErrMemory(ctxt, "allocating state");

	push	OFFSET ??_C@_0BB@CKELLPME@allocating?5state@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 882  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlRegNewS
$LN2@xmlRegNewS:

; 883  :     }
; 884  :     memset(ret, 0, sizeof(xmlRegState));

	push	44					; 0000002cH
	push	0
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 885  :     ret->type = XML_REGEXP_TRANS_STATE;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx], 3

; 886  :     ret->mark = XML_REGEXP_MARK_NORMAL;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+4], 0

; 887  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlRegNewS:

; 888  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegNewState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegCopyAtom
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_atom$ = 12						; size = 4
_xmlRegCopyAtom PROC					; COMDAT

; 839  : xmlRegCopyAtom(xmlRegParserCtxtPtr ctxt, xmlRegAtomPtr atom) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 840  :     xmlRegAtomPtr ret;
; 841  : 
; 842  :     ret = (xmlRegAtomPtr) xmlMalloc(sizeof(xmlRegAtom));

	mov	esi, esp
	push	64					; 00000040H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 843  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN5@xmlRegCopy

; 844  : 	xmlRegexpErrMemory(ctxt, "copying atom");

	push	OFFSET ??_C@_0N@ECMBACNP@copying?5atom@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 845  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlRegCopy
$LN5@xmlRegCopy:

; 846  :     }
; 847  :     memset(ret, 0, sizeof(xmlRegAtom));

	push	64					; 00000040H
	push	0
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 848  :     ret->type = atom->type;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 849  :     ret->quant = atom->quant;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx

; 850  :     ret->min = atom->min;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx

; 851  :     ret->max = atom->max;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx

; 852  :     if (atom->nbRanges > 0) {

	mov	edx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [edx+52], 0
	jle	$LN6@xmlRegCopy

; 853  :         int i;
; 854  : 
; 855  :         ret->ranges = (xmlRegRangePtr *) xmlMalloc(sizeof(xmlRegRangePtr) *

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+56], eax

; 856  : 	                                           atom->nbRanges);
; 857  : 	if (ret->ranges == NULL) {

	mov	eax, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN7@xmlRegCopy

; 858  : 	    xmlRegexpErrMemory(ctxt, "copying atom");

	push	OFFSET ??_C@_0N@ECMBACNP@copying?5atom@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegexpErrMemory
	add	esp, 8

; 859  : 	    goto error;

	jmp	SHORT $error$10
$LN7@xmlRegCopy:

; 860  : 	}
; 861  : 	for (i = 0;i < atom->nbRanges;i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@xmlRegCopy
$LN2@xmlRegCopy:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN4@xmlRegCopy:
	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax+52]
	jge	SHORT $LN6@xmlRegCopy

; 862  : 	    ret->ranges[i] = xmlRegCopyRange(ctxt, atom->ranges[i]);

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegCopyRange
	add	esp, 8
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR _i$1[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 863  : 	    if (ret->ranges[i] == NULL)

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	jne	SHORT $LN8@xmlRegCopy

; 864  : 	        goto error;

	jmp	SHORT $error$10
$LN8@xmlRegCopy:

; 865  : 	    ret->nbRanges = i + 1;

	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+52], edx

; 866  : 	}

	jmp	SHORT $LN2@xmlRegCopy
$LN6@xmlRegCopy:

; 867  :     }
; 868  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlRegCopy
$error$10:

; 869  : 
; 870  : error:
; 871  :     xmlRegFreeAtom(ret);

	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlRegFreeAtom
	add	esp, 4

; 872  :     return(NULL);

	xor	eax, eax
$LN1@xmlRegCopy:

; 873  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegCopyAtom ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegNewAtom
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlRegNewAtom PROC					; COMDAT

; 787  : xmlRegNewAtom(xmlRegParserCtxtPtr ctxt, xmlRegAtomType type) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 788  :     xmlRegAtomPtr ret;
; 789  : 
; 790  :     ret = (xmlRegAtomPtr) xmlMalloc(sizeof(xmlRegAtom));

	mov	esi, esp
	push	64					; 00000040H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 791  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlRegNewA

; 792  : 	xmlRegexpErrMemory(ctxt, "allocating atom");

	push	OFFSET ??_C@_0BA@JCPCIFNM@allocating?5atom@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 793  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlRegNewA
$LN2@xmlRegNewA:

; 794  :     }
; 795  :     memset(ret, 0, sizeof(xmlRegAtom));

	push	64					; 00000040H
	push	0
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 796  :     ret->type = type;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [edx+4], eax

; 797  :     ret->quant = XML_REGEXP_QUANT_ONCE;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+8], 2

; 798  :     ret->min = 0;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+12], 0

; 799  :     ret->max = 0;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+16], 0

; 800  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlRegNewA:

; 801  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegNewAtom ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegCopyRange
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_range$ = 12						; size = 4
_xmlRegCopyRange PROC					; COMDAT

; 756  : xmlRegCopyRange(xmlRegParserCtxtPtr ctxt, xmlRegRangePtr range) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 757  :     xmlRegRangePtr ret;
; 758  : 
; 759  :     if (range == NULL)

	cmp	DWORD PTR _range$[ebp], 0
	jne	SHORT $LN2@xmlRegCopy

; 760  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlRegCopy
$LN2@xmlRegCopy:

; 761  : 
; 762  :     ret = xmlRegNewRange(ctxt, range->neg, range->type, range->start,

	mov	eax, DWORD PTR _range$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _range$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _range$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _range$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegNewRange
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret$[ebp], eax

; 763  :                          range->end);
; 764  :     if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN3@xmlRegCopy

; 765  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlRegCopy
$LN3@xmlRegCopy:

; 766  :     if (range->blockName != NULL) {

	mov	eax, DWORD PTR _range$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN4@xmlRegCopy

; 767  : 	ret->blockName = xmlStrdup(range->blockName);

	mov	ecx, DWORD PTR _range$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 768  : 	if (ret->blockName == NULL) {

	mov	edx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN4@xmlRegCopy

; 769  : 	    xmlRegexpErrMemory(ctxt, "allocating range");

	push	OFFSET ??_C@_0BB@PBEHJOM@allocating?5range@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 770  : 	    xmlRegFreeRange(ret);

	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlRegFreeRange
	add	esp, 4

; 771  : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlRegCopy
$LN4@xmlRegCopy:

; 772  : 	}
; 773  :     }
; 774  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlRegCopy:

; 775  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegCopyRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegFreeRange
_TEXT	SEGMENT
_range$ = 8						; size = 4
_xmlRegFreeRange PROC					; COMDAT

; 738  : xmlRegFreeRange(xmlRegRangePtr range) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 739  :     if (range == NULL)

	cmp	DWORD PTR _range$[ebp], 0
	jne	SHORT $LN2@xmlRegFree

; 740  : 	return;

	jmp	SHORT $LN1@xmlRegFree
$LN2@xmlRegFree:

; 741  : 
; 742  :     if (range->blockName != NULL)

	mov	eax, DWORD PTR _range$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN3@xmlRegFree

; 743  : 	xmlFree(range->blockName);

	mov	esi, esp
	mov	ecx, DWORD PTR _range$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlRegFree:

; 744  :     xmlFree(range);

	mov	esi, esp
	mov	eax, DWORD PTR _range$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlRegFree:

; 745  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlRegFreeRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegNewRange
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_neg$ = 12						; size = 4
_type$ = 16						; size = 4
_start$ = 20						; size = 4
_end$ = 24						; size = 4
_xmlRegNewRange PROC					; COMDAT

; 716  : 	       int neg, xmlRegAtomType type, int start, int end) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 717  :     xmlRegRangePtr ret;
; 718  : 
; 719  :     ret = (xmlRegRangePtr) xmlMalloc(sizeof(xmlRegRange));

	mov	esi, esp
	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 720  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlRegNewR

; 721  : 	xmlRegexpErrMemory(ctxt, "allocating range");

	push	OFFSET ??_C@_0BB@PBEHJOM@allocating?5range@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 722  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlRegNewR
$LN2@xmlRegNewR:

; 723  :     }
; 724  :     ret->neg = neg;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _neg$[ebp]
	mov	DWORD PTR [ecx], edx

; 725  :     ret->type = type;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 726  :     ret->start = start;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR [edx+8], eax

; 727  :     ret->end = end;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _end$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 728  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlRegNewR:

; 729  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegNewRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegNewParserCtxt
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_string$ = 8						; size = 4
_xmlRegNewParserCtxt PROC				; COMDAT

; 685  : xmlRegNewParserCtxt(const xmlChar *string) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 686  :     xmlRegParserCtxtPtr ret;
; 687  : 
; 688  :     ret = (xmlRegParserCtxtPtr) xmlMalloc(sizeof(xmlRegParserCtxt));

	mov	esi, esp
	push	80					; 00000050H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 689  :     if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlRegNewP

; 690  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlRegNewP
$LN2@xmlRegNewP:

; 691  :     memset(ret, 0, sizeof(xmlRegParserCtxt));

	push	80					; 00000050H
	push	0
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 692  :     if (string != NULL)

	cmp	DWORD PTR _string$[ebp], 0
	je	SHORT $LN3@xmlRegNewP

; 693  : 	ret->string = xmlStrdup(string);

	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx], eax
$LN3@xmlRegNewP:

; 694  :     ret->cur = ret->string;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 695  :     ret->neg = 0;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+12], 0

; 696  :     ret->negs = 0;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+72], 0

; 697  :     ret->error = 0;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+8], 0

; 698  :     ret->determinist = -1;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+68], -1

; 699  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlRegNewP:

; 700  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegNewParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegEpxFromParse
_TEXT	SEGMENT
_trans$1 = -68						; size = 4
_state$2 = -64						; size = 4
_prev$3 = -60						; size = 4
_targetno$4 = -56					; size = 4
_atomno$5 = -52						; size = 4
_stateno$6 = -48					; size = 4
_value$7 = -44						; size = 4
_stringMap$8 = -40					; size = 4
_transdata$9 = -36					; size = 4
_transitions$10 = -32					; size = 4
_stringRemap$11 = -28					; size = 4
_stateRemap$12 = -24					; size = 4
_nbatoms$13 = -20					; size = 4
_nbstates$14 = -16					; size = 4
_j$15 = -12						; size = 4
_i$16 = -8						; size = 4
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlRegEpxFromParse PROC				; COMDAT

; 430  : xmlRegEpxFromParse(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 17					; 00000011H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 431  :     xmlRegexpPtr ret;
; 432  : 
; 433  :     ret = (xmlRegexpPtr) xmlMalloc(sizeof(xmlRegexp));

	mov	esi, esp
	push	56					; 00000038H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 434  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN32@xmlRegEpxF

; 435  : 	xmlRegexpErrMemory(ctxt, "compiling regexp");

	push	OFFSET ??_C@_0BB@FJPDMDM@compiling?5regexp@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrMemory
	add	esp, 8

; 436  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlRegEpxF
$LN32@xmlRegEpxF:

; 437  :     }
; 438  :     memset(ret, 0, sizeof(xmlRegexp));

	push	56					; 00000038H
	push	0
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 439  :     ret->string = ctxt->string;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 440  :     ret->nbStates = ctxt->nbStates;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+4], ecx

; 441  :     ret->states = ctxt->states;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [edx+8], ecx

; 442  :     ret->nbAtoms = ctxt->nbAtoms;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+12], ecx

; 443  :     ret->atoms = ctxt->atoms;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+16], ecx

; 444  :     ret->nbCounters = ctxt->nbCounters;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx+20], ecx

; 445  :     ret->counters = ctxt->counters;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR [edx+24], ecx

; 446  :     ret->determinist = ctxt->determinist;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR [edx+28], ecx

; 447  :     ret->flags = ctxt->flags;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR [edx+32], ecx

; 448  :     if (ret->determinist == -1) {

	mov	edx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [edx+28], -1
	jne	SHORT $LN33@xmlRegEpxF

; 449  :         xmlRegexpIsDeterminist(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlRegexpIsDeterminist
	add	esp, 4
$LN33@xmlRegEpxF:

; 450  :     }
; 451  : 
; 452  :     if ((ret->determinist != 0) &&
; 453  : 	(ret->nbCounters == 0) &&
; 454  : 	(ctxt->negs == 0) &&
; 455  : 	(ret->atoms != NULL) &&
; 456  : 	(ret->atoms[0] != NULL) &&

	mov	ecx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	$not_determ$60
	mov	edx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	$not_determ$60
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+72], 0
	jne	$not_determ$60
	mov	ecx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	$not_determ$60
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	DWORD PTR [eax+edx], 0
	je	$not_determ$60
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+ecx]
	cmp	DWORD PTR [ecx+4], 5
	jne	$not_determ$60

; 457  : 	(ret->atoms[0]->type == XML_REGEXP_STRING)) {
; 458  : 	int i, j, nbstates = 0, nbatoms = 0;

	mov	DWORD PTR _nbstates$14[ebp], 0
	mov	DWORD PTR _nbatoms$13[ebp], 0

; 459  : 	int *stateRemap;
; 460  : 	int *stringRemap;
; 461  : 	int *transitions;
; 462  : 	void **transdata;
; 463  : 	xmlChar **stringMap;
; 464  :         xmlChar *value;
; 465  : 
; 466  : 	/*
; 467  : 	 * Switch to a compact representation
; 468  : 	 * 1/ counting the effective number of states left
; 469  : 	 * 2/ counting the unique number of atoms, and check that
; 470  : 	 *    they are all of the string type
; 471  : 	 * 3/ build a table state x atom for the transitions
; 472  : 	 */
; 473  : 
; 474  : 	stateRemap = xmlMalloc(ret->nbStates * sizeof(int));

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 2
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _stateRemap$12[ebp], eax

; 475  : 	if (stateRemap == NULL) {

	cmp	DWORD PTR _stateRemap$12[ebp], 0
	jne	SHORT $LN35@xmlRegEpxF

; 476  : 	    xmlRegexpErrMemory(ctxt, "compiling regexp");

	push	OFFSET ??_C@_0BB@FJPDMDM@compiling?5regexp@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegexpErrMemory
	add	esp, 8

; 477  : 	    xmlFree(ret);

	mov	esi, esp
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 478  : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlRegEpxF
$LN35@xmlRegEpxF:

; 479  : 	}
; 480  : 	for (i = 0;i < ret->nbStates;i++) {

	mov	DWORD PTR _i$16[ebp], 0
	jmp	SHORT $LN4@xmlRegEpxF
$LN2@xmlRegEpxF:
	mov	eax, DWORD PTR _i$16[ebp]
	add	eax, 1
	mov	DWORD PTR _i$16[ebp], eax
$LN4@xmlRegEpxF:
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _i$16[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jge	SHORT $LN3@xmlRegEpxF

; 481  : 	    if (ret->states[i] != NULL) {

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$16[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN36@xmlRegEpxF

; 482  : 		stateRemap[i] = nbstates;

	mov	eax, DWORD PTR _i$16[ebp]
	mov	ecx, DWORD PTR _stateRemap$12[ebp]
	mov	edx, DWORD PTR _nbstates$14[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 483  : 		nbstates++;

	mov	eax, DWORD PTR _nbstates$14[ebp]
	add	eax, 1
	mov	DWORD PTR _nbstates$14[ebp], eax

; 484  : 	    } else {

	jmp	SHORT $LN37@xmlRegEpxF
$LN36@xmlRegEpxF:

; 485  : 		stateRemap[i] = -1;

	mov	ecx, DWORD PTR _i$16[ebp]
	mov	edx, DWORD PTR _stateRemap$12[ebp]
	mov	DWORD PTR [edx+ecx*4], -1
$LN37@xmlRegEpxF:

; 486  : 	    }
; 487  : 	}

	jmp	SHORT $LN2@xmlRegEpxF
$LN3@xmlRegEpxF:

; 488  : #ifdef DEBUG_COMPACTION
; 489  : 	printf("Final: %d states\n", nbstates);
; 490  : #endif
; 491  : 	stringMap = xmlMalloc(ret->nbAtoms * sizeof(char *));

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _stringMap$8[ebp], eax

; 492  : 	if (stringMap == NULL) {

	cmp	DWORD PTR _stringMap$8[ebp], 0
	jne	SHORT $LN38@xmlRegEpxF

; 493  : 	    xmlRegexpErrMemory(ctxt, "compiling regexp");

	push	OFFSET ??_C@_0BB@FJPDMDM@compiling?5regexp@
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegexpErrMemory
	add	esp, 8

; 494  : 	    xmlFree(stateRemap);

	mov	esi, esp
	mov	eax, DWORD PTR _stateRemap$12[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 495  : 	    xmlFree(ret);

	mov	esi, esp
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 496  : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlRegEpxF
$LN38@xmlRegEpxF:

; 497  : 	}
; 498  : 	stringRemap = xmlMalloc(ret->nbAtoms * sizeof(int));

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shl	eax, 2
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _stringRemap$11[ebp], eax

; 499  : 	if (stringRemap == NULL) {

	cmp	DWORD PTR _stringRemap$11[ebp], 0
	jne	SHORT $LN39@xmlRegEpxF

; 500  : 	    xmlRegexpErrMemory(ctxt, "compiling regexp");

	push	OFFSET ??_C@_0BB@FJPDMDM@compiling?5regexp@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegexpErrMemory
	add	esp, 8

; 501  : 	    xmlFree(stringMap);

	mov	esi, esp
	mov	edx, DWORD PTR _stringMap$8[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 502  : 	    xmlFree(stateRemap);

	mov	esi, esp
	mov	eax, DWORD PTR _stateRemap$12[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 503  : 	    xmlFree(ret);

	mov	esi, esp
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 504  : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlRegEpxF
$LN39@xmlRegEpxF:

; 505  : 	}
; 506  : 	for (i = 0;i < ret->nbAtoms;i++) {

	mov	DWORD PTR _i$16[ebp], 0
	jmp	SHORT $LN7@xmlRegEpxF
$LN5@xmlRegEpxF:
	mov	edx, DWORD PTR _i$16[ebp]
	add	edx, 1
	mov	DWORD PTR _i$16[ebp], edx
$LN7@xmlRegEpxF:
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _i$16[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	$LN6@xmlRegEpxF

; 507  : 	    if ((ret->atoms[i]->type == XML_REGEXP_STRING) &&

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$16[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+4], 5
	jne	$LN40@xmlRegEpxF
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$16[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	DWORD PTR [eax+8], 2
	jne	$LN40@xmlRegEpxF

; 508  : 		(ret->atoms[i]->quant == XML_REGEXP_QUANT_ONCE)) {
; 509  : 		value = ret->atoms[i]->valuep;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$16[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _value$7[ebp], edx

; 510  :                 for (j = 0;j < nbatoms;j++) {

	mov	DWORD PTR _j$15[ebp], 0
	jmp	SHORT $LN10@xmlRegEpxF
$LN8@xmlRegEpxF:
	mov	eax, DWORD PTR _j$15[ebp]
	add	eax, 1
	mov	DWORD PTR _j$15[ebp], eax
$LN10@xmlRegEpxF:
	mov	ecx, DWORD PTR _j$15[ebp]
	cmp	ecx, DWORD PTR _nbatoms$13[ebp]
	jge	SHORT $LN9@xmlRegEpxF

; 511  : 		    if (xmlStrEqual(stringMap[j], value)) {

	mov	edx, DWORD PTR _value$7[ebp]
	push	edx
	mov	eax, DWORD PTR _j$15[ebp]
	mov	ecx, DWORD PTR _stringMap$8[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN42@xmlRegEpxF

; 512  : 			stringRemap[i] = j;

	mov	eax, DWORD PTR _i$16[ebp]
	mov	ecx, DWORD PTR _stringRemap$11[ebp]
	mov	edx, DWORD PTR _j$15[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 513  : 			break;

	jmp	SHORT $LN9@xmlRegEpxF
$LN42@xmlRegEpxF:

; 514  : 		    }
; 515  : 		}

	jmp	SHORT $LN8@xmlRegEpxF
$LN9@xmlRegEpxF:

; 516  : 		if (j >= nbatoms) {

	mov	eax, DWORD PTR _j$15[ebp]
	cmp	eax, DWORD PTR _nbatoms$13[ebp]
	jl	$LN43@xmlRegEpxF

; 517  : 		    stringRemap[i] = nbatoms;

	mov	ecx, DWORD PTR _i$16[ebp]
	mov	edx, DWORD PTR _stringRemap$11[ebp]
	mov	eax, DWORD PTR _nbatoms$13[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 518  : 		    stringMap[nbatoms] = xmlStrdup(value);

	mov	ecx, DWORD PTR _value$7[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _nbatoms$13[ebp]
	mov	ecx, DWORD PTR _stringMap$8[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 519  : 		    if (stringMap[nbatoms] == NULL) {

	mov	edx, DWORD PTR _nbatoms$13[ebp]
	mov	eax, DWORD PTR _stringMap$8[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	$LN44@xmlRegEpxF

; 520  : 			for (i = 0;i < nbatoms;i++)

	mov	DWORD PTR _i$16[ebp], 0
	jmp	SHORT $LN13@xmlRegEpxF
$LN11@xmlRegEpxF:
	mov	ecx, DWORD PTR _i$16[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$16[ebp], ecx
$LN13@xmlRegEpxF:
	mov	edx, DWORD PTR _i$16[ebp]
	cmp	edx, DWORD PTR _nbatoms$13[ebp]
	jge	SHORT $LN12@xmlRegEpxF

; 521  : 			    xmlFree(stringMap[i]);

	mov	esi, esp
	mov	eax, DWORD PTR _i$16[ebp]
	mov	ecx, DWORD PTR _stringMap$8[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN11@xmlRegEpxF
$LN12@xmlRegEpxF:

; 522  : 			xmlFree(stringRemap);

	mov	esi, esp
	mov	eax, DWORD PTR _stringRemap$11[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 523  : 			xmlFree(stringMap);

	mov	esi, esp
	mov	ecx, DWORD PTR _stringMap$8[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 524  : 			xmlFree(stateRemap);

	mov	esi, esp
	mov	edx, DWORD PTR _stateRemap$12[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 525  : 			xmlFree(ret);

	mov	esi, esp
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 526  : 			return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlRegEpxF
$LN44@xmlRegEpxF:

; 527  : 		    }
; 528  : 		    nbatoms++;

	mov	ecx, DWORD PTR _nbatoms$13[ebp]
	add	ecx, 1
	mov	DWORD PTR _nbatoms$13[ebp], ecx
$LN43@xmlRegEpxF:

; 529  : 		}
; 530  : 	    } else {

	jmp	$LN41@xmlRegEpxF
$LN40@xmlRegEpxF:

; 531  : 		xmlFree(stateRemap);

	mov	esi, esp
	mov	edx, DWORD PTR _stateRemap$12[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 532  : 		xmlFree(stringRemap);

	mov	esi, esp
	mov	eax, DWORD PTR _stringRemap$11[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 533  : 		for (i = 0;i < nbatoms;i++)

	mov	DWORD PTR _i$16[ebp], 0
	jmp	SHORT $LN16@xmlRegEpxF
$LN14@xmlRegEpxF:
	mov	ecx, DWORD PTR _i$16[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$16[ebp], ecx
$LN16@xmlRegEpxF:
	mov	edx, DWORD PTR _i$16[ebp]
	cmp	edx, DWORD PTR _nbatoms$13[ebp]
	jge	SHORT $LN15@xmlRegEpxF

; 534  : 		    xmlFree(stringMap[i]);

	mov	esi, esp
	mov	eax, DWORD PTR _i$16[ebp]
	mov	ecx, DWORD PTR _stringMap$8[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN14@xmlRegEpxF
$LN15@xmlRegEpxF:

; 535  : 		xmlFree(stringMap);

	mov	esi, esp
	mov	eax, DWORD PTR _stringMap$8[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 536  : 		xmlFree(ret);

	mov	esi, esp
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 537  : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlRegEpxF
$LN41@xmlRegEpxF:

; 538  : 	    }
; 539  : 	}

	jmp	$LN5@xmlRegEpxF
$LN6@xmlRegEpxF:

; 540  : #ifdef DEBUG_COMPACTION
; 541  : 	printf("Final: %d atoms\n", nbatoms);
; 542  : #endif
; 543  : 	transitions = (int *) xmlMalloc((nbstates + 1) *

	mov	edx, DWORD PTR _nbstates$14[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _nbatoms$13[ebp]
	add	eax, 1
	imul	edx, eax
	shl	edx, 2
	mov	esi, esp
	push	edx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _transitions$10[ebp], eax

; 544  : 	                                (nbatoms + 1) * sizeof(int));
; 545  : 	if (transitions == NULL) {

	cmp	DWORD PTR _transitions$10[ebp], 0
	jne	SHORT $LN45@xmlRegEpxF

; 546  : 	    xmlFree(stateRemap);

	mov	esi, esp
	mov	ecx, DWORD PTR _stateRemap$12[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 547  : 	    xmlFree(stringRemap);

	mov	esi, esp
	mov	edx, DWORD PTR _stringRemap$11[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 548  : 	    xmlFree(stringMap);

	mov	esi, esp
	mov	eax, DWORD PTR _stringMap$8[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 549  : 	    xmlFree(ret);

	mov	esi, esp
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 550  : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlRegEpxF
$LN45@xmlRegEpxF:

; 551  : 	}
; 552  : 	memset(transitions, 0, (nbstates + 1) * (nbatoms + 1) * sizeof(int));

	mov	edx, DWORD PTR _nbstates$14[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _nbatoms$13[ebp]
	add	eax, 1
	imul	edx, eax
	shl	edx, 2
	push	edx
	push	0
	mov	ecx, DWORD PTR _transitions$10[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 553  : 
; 554  : 	/*
; 555  : 	 * Allocate the transition table. The first entry for each
; 556  : 	 * state corresponds to the state type.
; 557  : 	 */
; 558  : 	transdata = NULL;

	mov	DWORD PTR _transdata$9[ebp], 0

; 559  : 
; 560  : 	for (i = 0;i < ret->nbStates;i++) {

	mov	DWORD PTR _i$16[ebp], 0
	jmp	SHORT $LN19@xmlRegEpxF
$LN17@xmlRegEpxF:
	mov	edx, DWORD PTR _i$16[ebp]
	add	edx, 1
	mov	DWORD PTR _i$16[ebp], edx
$LN19@xmlRegEpxF:
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _i$16[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	$LN18@xmlRegEpxF

; 561  : 	    int stateno, atomno, targetno, prev;
; 562  : 	    xmlRegStatePtr state;
; 563  : 	    xmlRegTransPtr trans;
; 564  : 
; 565  : 	    stateno = stateRemap[i];

	mov	edx, DWORD PTR _i$16[ebp]
	mov	eax, DWORD PTR _stateRemap$12[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _stateno$6[ebp], ecx

; 566  : 	    if (stateno == -1)

	cmp	DWORD PTR _stateno$6[ebp], -1
	jne	SHORT $LN46@xmlRegEpxF

; 567  : 		continue;

	jmp	SHORT $LN17@xmlRegEpxF
$LN46@xmlRegEpxF:

; 568  : 	    state = ret->states[i];

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _i$16[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _state$2[ebp], edx

; 569  : 
; 570  : 	    transitions[stateno * (nbatoms + 1)] = state->type;

	mov	eax, DWORD PTR _nbatoms$13[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _stateno$6[ebp]
	mov	ecx, DWORD PTR _transitions$10[ebp]
	mov	edx, DWORD PTR _state$2[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax*4], edx

; 571  : 
; 572  : 	    for (j = 0;j < state->nbTrans;j++) {

	mov	DWORD PTR _j$15[ebp], 0
	jmp	SHORT $LN22@xmlRegEpxF
$LN20@xmlRegEpxF:
	mov	eax, DWORD PTR _j$15[ebp]
	add	eax, 1
	mov	DWORD PTR _j$15[ebp], eax
$LN22@xmlRegEpxF:
	mov	ecx, DWORD PTR _state$2[ebp]
	mov	edx, DWORD PTR _j$15[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	$LN21@xmlRegEpxF

; 573  : 		trans = &(state->trans[j]);

	imul	eax, DWORD PTR _j$15[ebp], 20
	mov	ecx, DWORD PTR _state$2[ebp]
	add	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _trans$1[ebp], eax

; 574  : 		if ((trans->to == -1) || (trans->atom == NULL))

	mov	edx, DWORD PTR _trans$1[ebp]
	cmp	DWORD PTR [edx+4], -1
	je	SHORT $LN48@xmlRegEpxF
	mov	eax, DWORD PTR _trans$1[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN47@xmlRegEpxF
$LN48@xmlRegEpxF:

; 575  : 		    continue;

	jmp	SHORT $LN20@xmlRegEpxF
$LN47@xmlRegEpxF:

; 576  :                 atomno = stringRemap[trans->atom->no];

	mov	ecx, DWORD PTR _trans$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _stringRemap$11[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _atomno$5[ebp], edx

; 577  : 		if ((trans->atom->data != NULL) && (transdata == NULL)) {

	mov	eax, DWORD PTR _trans$1[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+60], 0
	je	SHORT $LN49@xmlRegEpxF
	cmp	DWORD PTR _transdata$9[ebp], 0
	jne	SHORT $LN49@xmlRegEpxF

; 578  : 		    transdata = (void **) xmlMalloc(nbstates * nbatoms *

	mov	edx, DWORD PTR _nbstates$14[ebp]
	imul	edx, DWORD PTR _nbatoms$13[ebp]
	shl	edx, 2
	mov	esi, esp
	push	edx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _transdata$9[ebp], eax

; 579  : 			                            sizeof(void *));
; 580  : 		    if (transdata != NULL)

	cmp	DWORD PTR _transdata$9[ebp], 0
	je	SHORT $LN50@xmlRegEpxF

; 581  : 			memset(transdata, 0,

	mov	eax, DWORD PTR _nbstates$14[ebp]
	imul	eax, DWORD PTR _nbatoms$13[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _transdata$9[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN49@xmlRegEpxF
$LN50@xmlRegEpxF:

; 582  : 			       nbstates * nbatoms * sizeof(void *));
; 583  : 		    else {
; 584  : 			xmlRegexpErrMemory(ctxt, "compiling regexp");

	push	OFFSET ??_C@_0BB@FJPDMDM@compiling?5regexp@
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegexpErrMemory
	add	esp, 8

; 585  : 			break;

	jmp	$LN21@xmlRegEpxF
$LN49@xmlRegEpxF:

; 586  : 		    }
; 587  : 		}
; 588  : 		targetno = stateRemap[trans->to];

	mov	eax, DWORD PTR _trans$1[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _stateRemap$12[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _targetno$4[ebp], eax

; 589  : 		/*
; 590  : 		 * if the same atom can generate transitions to 2 different
; 591  : 		 * states then it means the automata is not determinist and
; 592  : 		 * the compact form can't be used !
; 593  : 		 */
; 594  : 		prev = transitions[stateno * (nbatoms + 1) + atomno + 1];

	mov	ecx, DWORD PTR _nbatoms$13[ebp]
	add	ecx, 1
	imul	ecx, DWORD PTR _stateno$6[ebp]
	add	ecx, DWORD PTR _atomno$5[ebp]
	mov	edx, DWORD PTR _transitions$10[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4]
	mov	DWORD PTR _prev$3[ebp], eax

; 595  : 		if (prev != 0) {

	cmp	DWORD PTR _prev$3[ebp], 0
	je	$LN52@xmlRegEpxF

; 596  : 		    if (prev != targetno + 1) {

	mov	ecx, DWORD PTR _targetno$4[ebp]
	add	ecx, 1
	cmp	DWORD PTR _prev$3[ebp], ecx
	je	$LN54@xmlRegEpxF

; 597  : 			ret->determinist = 0;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+28], 0

; 598  : #ifdef DEBUG_COMPACTION
; 599  : 			printf("Indet: state %d trans %d, atom %d to %d : %d to %d\n",
; 600  : 			       i, j, trans->atom->no, trans->to, atomno, targetno);
; 601  : 			printf("       previous to is %d\n", prev);
; 602  : #endif
; 603  : 			if (transdata != NULL)

	cmp	DWORD PTR _transdata$9[ebp], 0
	je	SHORT $LN55@xmlRegEpxF

; 604  : 			    xmlFree(transdata);

	mov	esi, esp
	mov	eax, DWORD PTR _transdata$9[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN55@xmlRegEpxF:

; 605  : 			xmlFree(transitions);

	mov	esi, esp
	mov	ecx, DWORD PTR _transitions$10[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 606  : 			xmlFree(stateRemap);

	mov	esi, esp
	mov	edx, DWORD PTR _stateRemap$12[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 607  : 			xmlFree(stringRemap);

	mov	esi, esp
	mov	eax, DWORD PTR _stringRemap$11[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 608  : 			for (i = 0;i < nbatoms;i++)

	mov	DWORD PTR _i$16[ebp], 0
	jmp	SHORT $LN25@xmlRegEpxF
$LN23@xmlRegEpxF:
	mov	ecx, DWORD PTR _i$16[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$16[ebp], ecx
$LN25@xmlRegEpxF:
	mov	edx, DWORD PTR _i$16[ebp]
	cmp	edx, DWORD PTR _nbatoms$13[ebp]
	jge	SHORT $LN24@xmlRegEpxF

; 609  : 			    xmlFree(stringMap[i]);

	mov	esi, esp
	mov	eax, DWORD PTR _i$16[ebp]
	mov	ecx, DWORD PTR _stringMap$8[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN23@xmlRegEpxF
$LN24@xmlRegEpxF:

; 610  : 			xmlFree(stringMap);

	mov	esi, esp
	mov	eax, DWORD PTR _stringMap$8[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 611  : 			goto not_determ;

	jmp	$not_determ$60
$LN54@xmlRegEpxF:

; 612  : 		    }
; 613  : 		} else {

	jmp	SHORT $LN53@xmlRegEpxF
$LN52@xmlRegEpxF:

; 614  : #if 0
; 615  : 		    printf("State %d trans %d: atom %d to %d : %d to %d\n",
; 616  : 			   i, j, trans->atom->no, trans->to, atomno, targetno);
; 617  : #endif
; 618  : 		    transitions[stateno * (nbatoms + 1) + atomno + 1] =

	mov	ecx, DWORD PTR _targetno$4[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _nbatoms$13[ebp]
	add	edx, 1
	imul	edx, DWORD PTR _stateno$6[ebp]
	add	edx, DWORD PTR _atomno$5[ebp]
	mov	eax, DWORD PTR _transitions$10[ebp]
	mov	DWORD PTR [eax+edx*4+4], ecx

; 619  : 			targetno + 1; /* to avoid 0 */
; 620  : 		    if (transdata != NULL)

	cmp	DWORD PTR _transdata$9[ebp], 0
	je	SHORT $LN53@xmlRegEpxF

; 621  : 			transdata[stateno * nbatoms + atomno] =

	mov	ecx, DWORD PTR _trans$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _stateno$6[ebp]
	imul	eax, DWORD PTR _nbatoms$13[ebp]
	add	eax, DWORD PTR _atomno$5[ebp]
	mov	ecx, DWORD PTR _transdata$9[ebp]
	mov	edx, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+eax*4], edx
$LN53@xmlRegEpxF:

; 622  : 			    trans->atom->data;
; 623  : 		}
; 624  : 	    }

	jmp	$LN20@xmlRegEpxF
$LN21@xmlRegEpxF:

; 625  : 	}

	jmp	$LN17@xmlRegEpxF
$LN18@xmlRegEpxF:

; 626  : 	ret->determinist = 1;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+28], 1

; 627  : #ifdef DEBUG_COMPACTION
; 628  : 	/*
; 629  : 	 * Debug
; 630  : 	 */
; 631  : 	for (i = 0;i < nbstates;i++) {
; 632  : 	    for (j = 0;j < nbatoms + 1;j++) {
; 633  :                 printf("%02d ", transitions[i * (nbatoms + 1) + j]);
; 634  : 	    }
; 635  : 	    printf("\n");
; 636  : 	}
; 637  : 	printf("\n");
; 638  : #endif
; 639  : 	/*
; 640  : 	 * Cleanup of the old data
; 641  : 	 */
; 642  : 	if (ret->states != NULL) {

	mov	ecx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN57@xmlRegEpxF

; 643  : 	    for (i = 0;i < ret->nbStates;i++)

	mov	DWORD PTR _i$16[ebp], 0
	jmp	SHORT $LN28@xmlRegEpxF
$LN26@xmlRegEpxF:
	mov	edx, DWORD PTR _i$16[ebp]
	add	edx, 1
	mov	DWORD PTR _i$16[ebp], edx
$LN28@xmlRegEpxF:
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _i$16[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN27@xmlRegEpxF

; 644  : 		xmlRegFreeState(ret->states[i]);

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _i$16[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_xmlRegFreeState
	add	esp, 4
	jmp	SHORT $LN26@xmlRegEpxF
$LN27@xmlRegEpxF:

; 645  : 	    xmlFree(ret->states);

	mov	esi, esp
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN57@xmlRegEpxF:

; 646  : 	}
; 647  : 	ret->states = NULL;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+8], 0

; 648  : 	ret->nbStates = 0;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+4], 0

; 649  : 	if (ret->atoms != NULL) {

	mov	ecx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN58@xmlRegEpxF

; 650  : 	    for (i = 0;i < ret->nbAtoms;i++)

	mov	DWORD PTR _i$16[ebp], 0
	jmp	SHORT $LN31@xmlRegEpxF
$LN29@xmlRegEpxF:
	mov	edx, DWORD PTR _i$16[ebp]
	add	edx, 1
	mov	DWORD PTR _i$16[ebp], edx
$LN31@xmlRegEpxF:
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _i$16[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $LN30@xmlRegEpxF

; 651  : 		xmlRegFreeAtom(ret->atoms[i]);

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$16[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_xmlRegFreeAtom
	add	esp, 4
	jmp	SHORT $LN29@xmlRegEpxF
$LN30@xmlRegEpxF:

; 652  : 	    xmlFree(ret->atoms);

	mov	esi, esp
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN58@xmlRegEpxF:

; 653  : 	}
; 654  : 	ret->atoms = NULL;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+16], 0

; 655  : 	ret->nbAtoms = 0;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+12], 0

; 656  : 
; 657  : 	ret->compact = transitions;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _transitions$10[ebp]
	mov	DWORD PTR [ecx+40], edx

; 658  : 	ret->transdata = transdata;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _transdata$9[ebp]
	mov	DWORD PTR [eax+44], ecx

; 659  : 	ret->stringMap = stringMap;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _stringMap$8[ebp]
	mov	DWORD PTR [edx+52], eax

; 660  : 	ret->nbstrings = nbatoms;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _nbatoms$13[ebp]
	mov	DWORD PTR [ecx+48], edx

; 661  : 	ret->nbstates = nbstates;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _nbstates$14[ebp]
	mov	DWORD PTR [eax+36], ecx

; 662  : 	xmlFree(stateRemap);

	mov	esi, esp
	mov	edx, DWORD PTR _stateRemap$12[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 663  : 	xmlFree(stringRemap);

	mov	esi, esp
	mov	eax, DWORD PTR _stringRemap$11[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$not_determ$60:

; 664  :     }
; 665  : not_determ:
; 666  :     ctxt->string = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], 0

; 667  :     ctxt->nbStates = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+48], 0

; 668  :     ctxt->states = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+52], 0

; 669  :     ctxt->nbAtoms = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 670  :     ctxt->atoms = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+40], 0

; 671  :     ctxt->nbCounters = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+60], 0

; 672  :     ctxt->counters = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+64], 0

; 673  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlRegEpxF:

; 674  : }

	pop	edi
	pop	esi
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegEpxFromParse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAComputesDeterminism
_TEXT	SEGMENT
_deep$ = -36						; size = 4
_ret$ = -32						; size = 4
_i$ = -28						; size = 4
_last$ = -24						; size = 4
_t2$ = -20						; size = 4
_t1$ = -16						; size = 4
_state$ = -12						; size = 4
_transnr$ = -8						; size = 4
_statenr$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlFAComputesDeterminism PROC				; COMDAT

; 2647 : xmlFAComputesDeterminism(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 2648 :     int statenr, transnr;
; 2649 :     xmlRegStatePtr state;
; 2650 :     xmlRegTransPtr t1, t2, last;
; 2651 :     int i;
; 2652 :     int ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 2653 :     int deep = 1;

	mov	DWORD PTR _deep$[ebp], 1

; 2654 : 
; 2655 : #ifdef DEBUG_REGEXP_GRAPH
; 2656 :     printf("xmlFAComputesDeterminism\n");
; 2657 :     xmlRegPrintCtxt(stdout, ctxt);
; 2658 : #endif
; 2659 :     if (ctxt->determinist != -1)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+68], -1
	je	SHORT $LN20@xmlFACompu

; 2660 : 	return(ctxt->determinist);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+68]
	jmp	$LN1@xmlFACompu
$LN20@xmlFACompu:

; 2661 : 
; 2662 :     if (ctxt->flags & AM_AUTOMATA_RNG)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+76]
	and	eax, 1
	je	SHORT $LN21@xmlFACompu

; 2663 :         deep = 0;

	mov	DWORD PTR _deep$[ebp], 0
$LN21@xmlFACompu:

; 2664 : 
; 2665 :     /*
; 2666 :      * First cleanup the automata removing cancelled transitions
; 2667 :      */
; 2668 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	mov	DWORD PTR _statenr$[ebp], 0
	jmp	SHORT $LN4@xmlFACompu
$LN2@xmlFACompu:
	mov	ecx, DWORD PTR _statenr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _statenr$[ebp], ecx
$LN4@xmlFACompu:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _statenr$[ebp]
	cmp	eax, DWORD PTR [edx+48]
	jge	$LN3@xmlFACompu

; 2669 : 	state = ctxt->states[statenr];

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _statenr$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _state$[ebp], ecx

; 2670 : 	if (state == NULL)

	cmp	DWORD PTR _state$[ebp], 0
	jne	SHORT $LN22@xmlFACompu

; 2671 : 	    continue;

	jmp	SHORT $LN2@xmlFACompu
$LN22@xmlFACompu:

; 2672 : 	if (state->nbTrans < 2)

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+24], 2
	jge	SHORT $LN23@xmlFACompu

; 2673 : 	    continue;

	jmp	SHORT $LN2@xmlFACompu
$LN23@xmlFACompu:

; 2674 : 	for (transnr = 0;transnr < state->nbTrans;transnr++) {

	mov	DWORD PTR _transnr$[ebp], 0
	jmp	SHORT $LN7@xmlFACompu
$LN5@xmlFACompu:
	mov	eax, DWORD PTR _transnr$[ebp]
	add	eax, 1
	mov	DWORD PTR _transnr$[ebp], eax
$LN7@xmlFACompu:
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR _transnr$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	$LN6@xmlFACompu

; 2675 : 	    t1 = &(state->trans[transnr]);

	imul	eax, DWORD PTR _transnr$[ebp], 20
	mov	ecx, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _t1$[ebp], eax

; 2676 : 	    /*
; 2677 : 	     * Determinism checks in case of counted or all transitions
; 2678 : 	     * will have to be handled separately
; 2679 : 	     */
; 2680 : 	    if (t1->atom == NULL) {

	mov	edx, DWORD PTR _t1$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN24@xmlFACompu

; 2681 : 		/* t1->nd = 1; */
; 2682 : 		continue;

	jmp	SHORT $LN5@xmlFACompu
$LN24@xmlFACompu:

; 2683 : 	    }
; 2684 : 	    if (t1->to == -1) /* eliminated */

	mov	eax, DWORD PTR _t1$[ebp]
	cmp	DWORD PTR [eax+4], -1
	jne	SHORT $LN25@xmlFACompu

; 2685 : 		continue;

	jmp	SHORT $LN5@xmlFACompu
$LN25@xmlFACompu:

; 2686 : 	    for (i = 0;i < transnr;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@xmlFACompu
$LN8@xmlFACompu:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN10@xmlFACompu:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _transnr$[ebp]
	jge	SHORT $LN9@xmlFACompu

; 2687 : 		t2 = &(state->trans[i]);

	imul	eax, DWORD PTR _i$[ebp], 20
	mov	ecx, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _t2$[ebp], eax

; 2688 : 		if (t2->to == -1) /* eliminated */

	mov	edx, DWORD PTR _t2$[ebp]
	cmp	DWORD PTR [edx+4], -1
	jne	SHORT $LN26@xmlFACompu

; 2689 : 		    continue;

	jmp	SHORT $LN8@xmlFACompu
$LN26@xmlFACompu:

; 2690 : 		if (t2->atom != NULL) {

	mov	eax, DWORD PTR _t2$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN27@xmlFACompu

; 2691 : 		    if (t1->to == t2->to) {

	mov	ecx, DWORD PTR _t1$[ebp]
	mov	edx, DWORD PTR _t2$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN27@xmlFACompu

; 2692 :                         /*
; 2693 :                          * Here we use deep because we want to keep the
; 2694 :                          * transitions which indicate a conflict
; 2695 :                          */
; 2696 : 			if (xmlFAEqualAtoms(t1->atom, t2->atom, deep) &&
; 2697 :                             (t1->counter == t2->counter) &&

	mov	ecx, DWORD PTR _deep$[ebp]
	push	ecx
	mov	edx, DWORD PTR _t2$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _t1$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlFAEqualAtoms
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN27@xmlFACompu
	mov	eax, DWORD PTR _t1$[ebp]
	mov	ecx, DWORD PTR _t2$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN27@xmlFACompu
	mov	eax, DWORD PTR _t1$[ebp]
	mov	ecx, DWORD PTR _t2$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN27@xmlFACompu

; 2698 :                             (t1->count == t2->count))
; 2699 : 			    t2->to = -1; /* eliminated */

	mov	eax, DWORD PTR _t2$[ebp]
	mov	DWORD PTR [eax+4], -1
$LN27@xmlFACompu:

; 2700 : 		    }
; 2701 : 		}
; 2702 : 	    }

	jmp	$LN8@xmlFACompu
$LN9@xmlFACompu:

; 2703 : 	}

	jmp	$LN5@xmlFACompu
$LN6@xmlFACompu:

; 2704 :     }

	jmp	$LN2@xmlFACompu
$LN3@xmlFACompu:

; 2705 : 
; 2706 :     /*
; 2707 :      * Check for all states that there aren't 2 transitions
; 2708 :      * with the same atom and a different target.
; 2709 :      */
; 2710 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	mov	DWORD PTR _statenr$[ebp], 0
	jmp	SHORT $LN13@xmlFACompu
$LN11@xmlFACompu:
	mov	ecx, DWORD PTR _statenr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _statenr$[ebp], ecx
$LN13@xmlFACompu:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _statenr$[ebp]
	cmp	eax, DWORD PTR [edx+48]
	jge	$LN12@xmlFACompu

; 2711 : 	state = ctxt->states[statenr];

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _statenr$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _state$[ebp], ecx

; 2712 : 	if (state == NULL)

	cmp	DWORD PTR _state$[ebp], 0
	jne	SHORT $LN30@xmlFACompu

; 2713 : 	    continue;

	jmp	SHORT $LN11@xmlFACompu
$LN30@xmlFACompu:

; 2714 : 	if (state->nbTrans < 2)

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+24], 2
	jge	SHORT $LN31@xmlFACompu

; 2715 : 	    continue;

	jmp	SHORT $LN11@xmlFACompu
$LN31@xmlFACompu:

; 2716 : 	last = NULL;

	mov	DWORD PTR _last$[ebp], 0

; 2717 : 	for (transnr = 0;transnr < state->nbTrans;transnr++) {

	mov	DWORD PTR _transnr$[ebp], 0
	jmp	SHORT $LN16@xmlFACompu
$LN14@xmlFACompu:
	mov	eax, DWORD PTR _transnr$[ebp]
	add	eax, 1
	mov	DWORD PTR _transnr$[ebp], eax
$LN16@xmlFACompu:
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR _transnr$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	$LN15@xmlFACompu

; 2718 : 	    t1 = &(state->trans[transnr]);

	imul	eax, DWORD PTR _transnr$[ebp], 20
	mov	ecx, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _t1$[ebp], eax

; 2719 : 	    /*
; 2720 : 	     * Determinism checks in case of counted or all transitions
; 2721 : 	     * will have to be handled separately
; 2722 : 	     */
; 2723 : 	    if (t1->atom == NULL) {

	mov	edx, DWORD PTR _t1$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN32@xmlFACompu

; 2724 : 		continue;

	jmp	SHORT $LN14@xmlFACompu
$LN32@xmlFACompu:

; 2725 : 	    }
; 2726 : 	    if (t1->to == -1) /* eliminated */

	mov	eax, DWORD PTR _t1$[ebp]
	cmp	DWORD PTR [eax+4], -1
	jne	SHORT $LN33@xmlFACompu

; 2727 : 		continue;

	jmp	SHORT $LN14@xmlFACompu
$LN33@xmlFACompu:

; 2728 : 	    for (i = 0;i < transnr;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN19@xmlFACompu
$LN17@xmlFACompu:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN19@xmlFACompu:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _transnr$[ebp]
	jge	$LN18@xmlFACompu

; 2729 : 		t2 = &(state->trans[i]);

	imul	eax, DWORD PTR _i$[ebp], 20
	mov	ecx, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _t2$[ebp], eax

; 2730 : 		if (t2->to == -1) /* eliminated */

	mov	edx, DWORD PTR _t2$[ebp]
	cmp	DWORD PTR [edx+4], -1
	jne	SHORT $LN34@xmlFACompu

; 2731 : 		    continue;

	jmp	SHORT $LN17@xmlFACompu
$LN34@xmlFACompu:

; 2732 : 		if (t2->atom != NULL) {

	mov	eax, DWORD PTR _t2$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN35@xmlFACompu

; 2733 :                     /*
; 2734 :                      * But here we don't use deep because we want to
; 2735 :                      * find transitions which indicate a conflict
; 2736 :                      */
; 2737 : 		    if (xmlFACompareAtoms(t1->atom, t2->atom, 1)) {

	push	1
	mov	ecx, DWORD PTR _t2$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _t1$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlFACompareAtoms
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN37@xmlFACompu

; 2738 : 			ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 2739 : 			/* mark the transitions as non-deterministic ones */
; 2740 : 			t1->nd = 1;

	mov	edx, DWORD PTR _t1$[ebp]
	mov	DWORD PTR [edx+16], 1

; 2741 : 			t2->nd = 1;

	mov	eax, DWORD PTR _t2$[ebp]
	mov	DWORD PTR [eax+16], 1

; 2742 : 			last = t1;

	mov	ecx, DWORD PTR _t1$[ebp]
	mov	DWORD PTR _last$[ebp], ecx
$LN37@xmlFACompu:

; 2743 : 		    }

	jmp	SHORT $LN36@xmlFACompu
$LN35@xmlFACompu:

; 2744 : 		} else if (t1->to != -1) {

	mov	edx, DWORD PTR _t1$[ebp]
	cmp	DWORD PTR [edx+4], -1
	je	SHORT $LN36@xmlFACompu

; 2745 : 		    /*
; 2746 : 		     * do the closure in case of remaining specific
; 2747 : 		     * epsilon transitions like choices or all
; 2748 : 		     */
; 2749 : 		    ret = xmlFARecurseDeterminism(ctxt, ctxt->states[t1->to],

	mov	eax, DWORD PTR _t2$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _t2$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _t1$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFARecurseDeterminism
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 2750 : 						   t2->to, t2->atom);
; 2751 : 		    /* don't shortcut the computation so all non deterministic
; 2752 : 		       transition get marked down
; 2753 : 		    if (ret == 0)
; 2754 : 			return(0);
; 2755 : 		     */
; 2756 : 		    if (ret == 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN36@xmlFACompu

; 2757 : 			t1->nd = 1;

	mov	ecx, DWORD PTR _t1$[ebp]
	mov	DWORD PTR [ecx+16], 1

; 2758 : 			/* t2->nd = 1; */
; 2759 : 			last = t1;

	mov	edx, DWORD PTR _t1$[ebp]
	mov	DWORD PTR _last$[ebp], edx
$LN36@xmlFACompu:

; 2760 : 		    }
; 2761 : 		}
; 2762 : 	    }

	jmp	$LN17@xmlFACompu
$LN18@xmlFACompu:

; 2763 : 	    /* don't shortcut the computation so all non deterministic
; 2764 : 	       transition get marked down
; 2765 : 	    if (ret == 0)
; 2766 : 		break; */
; 2767 : 	}

	jmp	$LN14@xmlFACompu
$LN15@xmlFACompu:

; 2768 : 
; 2769 : 	/*
; 2770 : 	 * mark specifically the last non-deterministic transition
; 2771 : 	 * from a state since there is no need to set-up rollback
; 2772 : 	 * from it
; 2773 : 	 */
; 2774 : 	if (last != NULL) {

	cmp	DWORD PTR _last$[ebp], 0
	je	SHORT $LN40@xmlFACompu

; 2775 : 	    last->nd = 2;

	mov	eax, DWORD PTR _last$[ebp]
	mov	DWORD PTR [eax+16], 2
$LN40@xmlFACompu:

; 2776 : 	}
; 2777 : 
; 2778 : 	/* don't shortcut the computation so all non deterministic
; 2779 : 	   transition get marked down
; 2780 : 	if (ret == 0)
; 2781 : 	    break; */
; 2782 :     }

	jmp	$LN11@xmlFACompu
$LN12@xmlFACompu:

; 2783 : 
; 2784 :     ctxt->determinist = ret;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+68], edx

; 2785 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlFACompu:

; 2786 : }

	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFAComputesDeterminism ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegexpErrCompile
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_regexp$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlRegexpErrCompile PROC				; COMDAT

; 399  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 400  :     const char *regexp = NULL;

	mov	DWORD PTR _regexp$[ebp], 0

; 401  :     int idx = 0;

	mov	DWORD PTR _idx$[ebp], 0

; 402  : 
; 403  :     if (ctxt != NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN2@xmlRegexpE

; 404  :         regexp = (const char *) ctxt->string;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _regexp$[ebp], ecx

; 405  : 	idx = ctxt->cur - ctxt->string;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	sub	ecx, DWORD PTR [eax]
	mov	DWORD PTR _idx$[ebp], ecx

; 406  : 	ctxt->error = XML_REGEXP_COMPILE_ERROR;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1450			; 000005aaH
$LN2@xmlRegexpE:

; 407  :     }
; 408  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@CFFLONMP@failed?5to?5compile?3?5?$CFs?6@
	push	0
	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _regexp$[ebp]
	push	edx
	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	0
	push	0
	push	3
	push	1450					; 000005aaH
	push	14					; 0000000eH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 409  : 		    XML_REGEXP_COMPILE_ERROR, XML_ERR_FATAL, NULL, 0, extra,
; 410  : 		    regexp, NULL, idx, 0,
; 411  : 		    "failed to compile: %s\n", extra);
; 412  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegexpErrCompile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegexpErrMemory
_TEXT	SEGMENT
_regexp$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlRegexpErrMemory PROC				; COMDAT

; 379  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 380  :     const char *regexp = NULL;

	mov	DWORD PTR _regexp$[ebp], 0

; 381  :     if (ctxt != NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN2@xmlRegexpE

; 382  :         regexp = (const char *) ctxt->string;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _regexp$[ebp], ecx

; 383  : 	ctxt->error = XML_ERR_NO_MEMORY;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 2
$LN2@xmlRegexpE:

; 384  :     }
; 385  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _regexp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _extra$[ebp]
	push	edx
	push	0
	push	0
	push	3
	push	2
	push	14					; 0000000eH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 386  : 		    XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,
; 387  : 		    regexp, NULL, 0, 0,
; 388  : 		    "Memory allocation failed : %s\n", extra);
; 389  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegexpErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataSetFlags
_TEXT	SEGMENT
_am$ = 8						; size = 4
_flags$ = 12						; size = 4
_xmlAutomataSetFlags PROC				; COMDAT

; 5661 : xmlAutomataSetFlags(xmlAutomataPtr am, int flags) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5662 :     if (am == NULL)

	cmp	DWORD PTR _am$[ebp], 0
	jne	SHORT $LN2@xmlAutomat

; 5663 : 	return;

	jmp	SHORT $LN1@xmlAutomat
$LN2@xmlAutomat:

; 5664 :     am->flags |= flags;

	mov	eax, DWORD PTR _am$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	or	ecx, DWORD PTR _flags$[ebp]
	mov	edx, DWORD PTR _am$[ebp]
	mov	DWORD PTR [edx+76], ecx
$LN1@xmlAutomat:

; 5665 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlAutomataSetFlags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegCheckCharacterRange
_TEXT	SEGMENT
tv286 = -104						; size = 4
tv200 = -100						; size = 4
tv196 = -96						; size = 4
tv194 = -92						; size = 4
tv192 = -88						; size = 4
tv191 = -84						; size = 4
tv184 = -80						; size = 4
tv174 = -76						; size = 4
tv173 = -72						; size = 4
tv163 = -68						; size = 4
tv164 = -64						; size = 4
tv156 = -60						; size = 4
tv155 = -56						; size = 4
tv141 = -52						; size = 4
tv139 = -48						; size = 4
tv133 = -44						; size = 4
tv134 = -40						; size = 4
tv94 = -36						; size = 4
tv93 = -32						; size = 4
tv79 = -28						; size = 4
tv77 = -24						; size = 4
tv72 = -20						; size = 4
tv70 = -16						; size = 4
tv67 = -12						; size = 4
tv64 = -8						; size = 4
_ret$ = -4						; size = 4
_type$ = 8						; size = 4
_codepoint$ = 12					; size = 4
_neg$ = 16						; size = 4
_start$ = 20						; size = 4
_end$ = 24						; size = 4
_blockName$ = 28					; size = 4
_xmlRegCheckCharacterRange PROC				; COMDAT

; 2796 : 	                  int start, int end, const xmlChar *blockName) {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	edi
	lea	edi, DWORD PTR [ebp-104]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 2797 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 2798 : 
; 2799 :     switch (type) {

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 135		; 00000087H
	ja	$LN2@xmlRegChec
	mov	edx, DWORD PTR tv64[ebp]
	movzx	eax, BYTE PTR $LN118@xmlRegChec[edx]
	jmp	DWORD PTR $LN119@xmlRegChec[eax*4]
$LN4@xmlRegChec:

; 2800 :         case XML_REGEXP_STRING:
; 2801 :         case XML_REGEXP_SUBREG:
; 2802 :         case XML_REGEXP_RANGES:
; 2803 :         case XML_REGEXP_EPSILON:
; 2804 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlRegChec
$LN5@xmlRegChec:

; 2805 :         case XML_REGEXP_ANYCHAR:
; 2806 : 	    ret = ((codepoint != '\n') && (codepoint != '\r'));

	cmp	DWORD PTR _codepoint$[ebp], 10		; 0000000aH
	je	SHORT $LN58@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 13		; 0000000dH
	je	SHORT $LN58@xmlRegChec
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN59@xmlRegChec
$LN58@xmlRegChec:
	mov	DWORD PTR tv67[ebp], 0
$LN59@xmlRegChec:
	mov	ecx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _ret$[ebp], ecx

; 2807 : 	    break;

	jmp	$LN2@xmlRegChec
$LN6@xmlRegChec:

; 2808 :         case XML_REGEXP_CHARVAL:
; 2809 : 	    ret = ((codepoint >= start) && (codepoint <= end));

	mov	edx, DWORD PTR _codepoint$[ebp]
	cmp	edx, DWORD PTR _start$[ebp]
	jl	SHORT $LN60@xmlRegChec
	mov	eax, DWORD PTR _codepoint$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	jg	SHORT $LN60@xmlRegChec
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN61@xmlRegChec
$LN60@xmlRegChec:
	mov	DWORD PTR tv70[ebp], 0
$LN61@xmlRegChec:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _ret$[ebp], ecx

; 2810 : 	    break;

	jmp	$LN2@xmlRegChec
$LN7@xmlRegChec:

; 2811 :         case XML_REGEXP_NOTSPACE:
; 2812 : 	    neg = !neg;

	cmp	DWORD PTR _neg$[ebp], 0
	jne	SHORT $LN62@xmlRegChec
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN63@xmlRegChec
$LN62@xmlRegChec:
	mov	DWORD PTR tv72[ebp], 0
$LN63@xmlRegChec:
	mov	edx, DWORD PTR tv72[ebp]
	mov	DWORD PTR _neg$[ebp], edx
$LN8@xmlRegChec:

; 2813 :             /* Falls through. */
; 2814 :         case XML_REGEXP_ANYSPACE:
; 2815 : 	    ret = ((codepoint == '\n') || (codepoint == '\r') ||

	cmp	DWORD PTR _codepoint$[ebp], 10		; 0000000aH
	je	SHORT $LN64@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 13		; 0000000dH
	je	SHORT $LN64@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 9
	je	SHORT $LN64@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 32		; 00000020H
	je	SHORT $LN64@xmlRegChec
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN65@xmlRegChec
$LN64@xmlRegChec:
	mov	DWORD PTR tv77[ebp], 1
$LN65@xmlRegChec:
	mov	eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR _ret$[ebp], eax

; 2816 : 		   (codepoint == '\t') || (codepoint == ' '));
; 2817 : 	    break;

	jmp	$LN2@xmlRegChec
$LN9@xmlRegChec:

; 2818 :         case XML_REGEXP_NOTINITNAME:
; 2819 : 	    neg = !neg;

	cmp	DWORD PTR _neg$[ebp], 0
	jne	SHORT $LN66@xmlRegChec
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN67@xmlRegChec
$LN66@xmlRegChec:
	mov	DWORD PTR tv79[ebp], 0
$LN67@xmlRegChec:
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR _neg$[ebp], ecx
$LN10@xmlRegChec:

; 2820 :             /* Falls through. */
; 2821 :         case XML_REGEXP_INITNAME:
; 2822 : 	    ret = (IS_LETTER(codepoint) ||

	cmp	DWORD PTR _codepoint$[ebp], 256		; 00000100H
	jge	SHORT $LN74@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 65		; 00000041H
	jl	SHORT $LN68@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 90		; 0000005aH
	jle	SHORT $LN70@xmlRegChec
$LN68@xmlRegChec:
	cmp	DWORD PTR _codepoint$[ebp], 97		; 00000061H
	jl	SHORT $LN69@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 122		; 0000007aH
	jle	SHORT $LN70@xmlRegChec
$LN69@xmlRegChec:
	cmp	DWORD PTR _codepoint$[ebp], 192		; 000000c0H
	jl	SHORT $LN71@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 214		; 000000d6H
	jle	SHORT $LN70@xmlRegChec
$LN71@xmlRegChec:
	cmp	DWORD PTR _codepoint$[ebp], 216		; 000000d8H
	jl	SHORT $LN72@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 246		; 000000f6H
	jle	SHORT $LN70@xmlRegChec
$LN72@xmlRegChec:
	cmp	DWORD PTR _codepoint$[ebp], 248		; 000000f8H
	jge	SHORT $LN70@xmlRegChec
	mov	DWORD PTR tv93[ebp], 0
	jmp	SHORT $LN73@xmlRegChec
$LN70@xmlRegChec:
	mov	DWORD PTR tv93[ebp], 1
$LN73@xmlRegChec:
	mov	edx, DWORD PTR tv93[ebp]
	mov	DWORD PTR tv94[ebp], edx
	jmp	SHORT $LN75@xmlRegChec
$LN74@xmlRegChec:
	push	OFFSET _xmlIsBaseCharGroup
	mov	eax, DWORD PTR _codepoint$[ebp]
	push	eax
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv94[ebp], eax
$LN75@xmlRegChec:
	cmp	DWORD PTR tv94[ebp], 0
	jne	SHORT $LN82@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 256		; 00000100H
	jge	SHORT $LN80@xmlRegChec
	mov	DWORD PTR tv134[ebp], 0
	jmp	SHORT $LN81@xmlRegChec
$LN80@xmlRegChec:
	cmp	DWORD PTR _codepoint$[ebp], 19968	; 00004e00H
	jl	SHORT $LN76@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 40869	; 00009fa5H
	jle	SHORT $LN77@xmlRegChec
$LN76@xmlRegChec:
	cmp	DWORD PTR _codepoint$[ebp], 12295	; 00003007H
	je	SHORT $LN77@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 12321	; 00003021H
	jl	SHORT $LN78@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 12329	; 00003029H
	jle	SHORT $LN77@xmlRegChec
$LN78@xmlRegChec:
	mov	DWORD PTR tv133[ebp], 0
	jmp	SHORT $LN79@xmlRegChec
$LN77@xmlRegChec:
	mov	DWORD PTR tv133[ebp], 1
$LN79@xmlRegChec:
	mov	ecx, DWORD PTR tv133[ebp]
	mov	DWORD PTR tv134[ebp], ecx
$LN81@xmlRegChec:
	cmp	DWORD PTR tv134[ebp], 0
	jne	SHORT $LN82@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 95		; 0000005fH
	je	SHORT $LN82@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 58		; 0000003aH
	je	SHORT $LN82@xmlRegChec
	mov	DWORD PTR tv139[ebp], 0
	jmp	SHORT $LN83@xmlRegChec
$LN82@xmlRegChec:
	mov	DWORD PTR tv139[ebp], 1
$LN83@xmlRegChec:
	mov	edx, DWORD PTR tv139[ebp]
	mov	DWORD PTR _ret$[ebp], edx

; 2823 : 		   (codepoint == '_') || (codepoint == ':'));
; 2824 : 	    break;

	jmp	$LN2@xmlRegChec
$LN11@xmlRegChec:

; 2825 :         case XML_REGEXP_NOTNAMECHAR:
; 2826 : 	    neg = !neg;

	cmp	DWORD PTR _neg$[ebp], 0
	jne	SHORT $LN84@xmlRegChec
	mov	DWORD PTR tv141[ebp], 1
	jmp	SHORT $LN85@xmlRegChec
$LN84@xmlRegChec:
	mov	DWORD PTR tv141[ebp], 0
$LN85@xmlRegChec:
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR _neg$[ebp], eax
$LN12@xmlRegChec:

; 2827 :             /* Falls through. */
; 2828 :         case XML_REGEXP_NAMECHAR:
; 2829 : 	    ret = (IS_LETTER(codepoint) || IS_DIGIT(codepoint) ||

	cmp	DWORD PTR _codepoint$[ebp], 256		; 00000100H
	jge	SHORT $LN92@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 65		; 00000041H
	jl	SHORT $LN86@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 90		; 0000005aH
	jle	SHORT $LN88@xmlRegChec
$LN86@xmlRegChec:
	cmp	DWORD PTR _codepoint$[ebp], 97		; 00000061H
	jl	SHORT $LN87@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 122		; 0000007aH
	jle	SHORT $LN88@xmlRegChec
$LN87@xmlRegChec:
	cmp	DWORD PTR _codepoint$[ebp], 192		; 000000c0H
	jl	SHORT $LN89@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 214		; 000000d6H
	jle	SHORT $LN88@xmlRegChec
$LN89@xmlRegChec:
	cmp	DWORD PTR _codepoint$[ebp], 216		; 000000d8H
	jl	SHORT $LN90@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 246		; 000000f6H
	jle	SHORT $LN88@xmlRegChec
$LN90@xmlRegChec:
	cmp	DWORD PTR _codepoint$[ebp], 248		; 000000f8H
	jge	SHORT $LN88@xmlRegChec
	mov	DWORD PTR tv155[ebp], 0
	jmp	SHORT $LN91@xmlRegChec
$LN88@xmlRegChec:
	mov	DWORD PTR tv155[ebp], 1
$LN91@xmlRegChec:
	mov	ecx, DWORD PTR tv155[ebp]
	mov	DWORD PTR tv156[ebp], ecx
	jmp	SHORT $LN93@xmlRegChec
$LN92@xmlRegChec:
	push	OFFSET _xmlIsBaseCharGroup
	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv156[ebp], eax
$LN93@xmlRegChec:
	cmp	DWORD PTR tv156[ebp], 0
	jne	$LN100@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 256		; 00000100H
	jge	SHORT $LN98@xmlRegChec
	mov	DWORD PTR tv164[ebp], 0
	jmp	SHORT $LN99@xmlRegChec
$LN98@xmlRegChec:
	cmp	DWORD PTR _codepoint$[ebp], 19968	; 00004e00H
	jl	SHORT $LN94@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 40869	; 00009fa5H
	jle	SHORT $LN95@xmlRegChec
$LN94@xmlRegChec:
	cmp	DWORD PTR _codepoint$[ebp], 12295	; 00003007H
	je	SHORT $LN95@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 12321	; 00003021H
	jl	SHORT $LN96@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 12329	; 00003029H
	jle	SHORT $LN95@xmlRegChec
$LN96@xmlRegChec:
	mov	DWORD PTR tv163[ebp], 0
	jmp	SHORT $LN97@xmlRegChec
$LN95@xmlRegChec:
	mov	DWORD PTR tv163[ebp], 1
$LN97@xmlRegChec:
	mov	eax, DWORD PTR tv163[ebp]
	mov	DWORD PTR tv164[ebp], eax
$LN99@xmlRegChec:
	cmp	DWORD PTR tv164[ebp], 0
	jne	$LN100@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 256		; 00000100H
	jge	SHORT $LN103@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 48		; 00000030H
	jl	SHORT $LN101@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 57		; 00000039H
	jg	SHORT $LN101@xmlRegChec
	mov	DWORD PTR tv173[ebp], 1
	jmp	SHORT $LN102@xmlRegChec
$LN101@xmlRegChec:
	mov	DWORD PTR tv173[ebp], 0
$LN102@xmlRegChec:
	mov	ecx, DWORD PTR tv173[ebp]
	mov	DWORD PTR tv174[ebp], ecx
	jmp	SHORT $LN104@xmlRegChec
$LN103@xmlRegChec:
	push	OFFSET _xmlIsDigitGroup
	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv174[ebp], eax
$LN104@xmlRegChec:
	cmp	DWORD PTR tv174[ebp], 0
	jne	$LN100@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 46		; 0000002eH
	je	$LN100@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 45		; 0000002dH
	je	$LN100@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 95		; 0000005fH
	je	SHORT $LN100@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 58		; 0000003aH
	je	SHORT $LN100@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 256		; 00000100H
	jge	SHORT $LN105@xmlRegChec
	mov	DWORD PTR tv184[ebp], 0
	jmp	SHORT $LN106@xmlRegChec
$LN105@xmlRegChec:
	push	OFFSET _xmlIsCombiningGroup
	mov	eax, DWORD PTR _codepoint$[ebp]
	push	eax
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv184[ebp], eax
$LN106@xmlRegChec:
	cmp	DWORD PTR tv184[ebp], 0
	jne	SHORT $LN100@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 256		; 00000100H
	jge	SHORT $LN109@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 183		; 000000b7H
	jne	SHORT $LN107@xmlRegChec
	mov	DWORD PTR tv191[ebp], 1
	jmp	SHORT $LN108@xmlRegChec
$LN107@xmlRegChec:
	mov	DWORD PTR tv191[ebp], 0
$LN108@xmlRegChec:
	mov	ecx, DWORD PTR tv191[ebp]
	mov	DWORD PTR tv192[ebp], ecx
	jmp	SHORT $LN110@xmlRegChec
$LN109@xmlRegChec:
	push	OFFSET _xmlIsExtenderGroup
	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv192[ebp], eax
$LN110@xmlRegChec:
	cmp	DWORD PTR tv192[ebp], 0
	jne	SHORT $LN100@xmlRegChec
	mov	DWORD PTR tv194[ebp], 0
	jmp	SHORT $LN111@xmlRegChec
$LN100@xmlRegChec:
	mov	DWORD PTR tv194[ebp], 1
$LN111@xmlRegChec:
	mov	eax, DWORD PTR tv194[ebp]
	mov	DWORD PTR _ret$[ebp], eax

; 2830 : 		   (codepoint == '.') || (codepoint == '-') ||
; 2831 : 		   (codepoint == '_') || (codepoint == ':') ||
; 2832 : 		   IS_COMBINING(codepoint) || IS_EXTENDER(codepoint));
; 2833 : 	    break;

	jmp	$LN2@xmlRegChec
$LN13@xmlRegChec:

; 2834 :         case XML_REGEXP_NOTDECIMAL:
; 2835 : 	    neg = !neg;

	cmp	DWORD PTR _neg$[ebp], 0
	jne	SHORT $LN112@xmlRegChec
	mov	DWORD PTR tv196[ebp], 1
	jmp	SHORT $LN113@xmlRegChec
$LN112@xmlRegChec:
	mov	DWORD PTR tv196[ebp], 0
$LN113@xmlRegChec:
	mov	ecx, DWORD PTR tv196[ebp]
	mov	DWORD PTR _neg$[ebp], ecx
$LN14@xmlRegChec:

; 2836 :             /* Falls through. */
; 2837 :         case XML_REGEXP_DECIMAL:
; 2838 : 	    ret = xmlUCSIsCatNd(codepoint);

	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	call	_xmlUCSIsCatNd
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2839 : 	    break;

	jmp	$LN2@xmlRegChec
$LN15@xmlRegChec:

; 2840 :         case XML_REGEXP_REALCHAR:
; 2841 : 	    neg = !neg;

	cmp	DWORD PTR _neg$[ebp], 0
	jne	SHORT $LN114@xmlRegChec
	mov	DWORD PTR tv200[ebp], 1
	jmp	SHORT $LN115@xmlRegChec
$LN114@xmlRegChec:
	mov	DWORD PTR tv200[ebp], 0
$LN115@xmlRegChec:
	mov	eax, DWORD PTR tv200[ebp]
	mov	DWORD PTR _neg$[ebp], eax
$LN16@xmlRegChec:

; 2842 :             /* Falls through. */
; 2843 :         case XML_REGEXP_NOTREALCHAR:
; 2844 : 	    ret = xmlUCSIsCatP(codepoint);

	mov	ecx, DWORD PTR _codepoint$[ebp]
	push	ecx
	call	_xmlUCSIsCatP
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2845 : 	    if (ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN17@xmlRegChec

; 2846 : 		ret = xmlUCSIsCatZ(codepoint);

	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	call	_xmlUCSIsCatZ
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax
$LN17@xmlRegChec:

; 2847 : 	    if (ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN18@xmlRegChec

; 2848 : 		ret = xmlUCSIsCatC(codepoint);

	mov	eax, DWORD PTR _codepoint$[ebp]
	push	eax
	call	_xmlUCSIsCatC
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax
$LN18@xmlRegChec:

; 2849 : 	    break;

	jmp	$LN2@xmlRegChec
$LN19@xmlRegChec:

; 2850 :         case XML_REGEXP_LETTER:
; 2851 : 	    ret = xmlUCSIsCatL(codepoint);

	mov	ecx, DWORD PTR _codepoint$[ebp]
	push	ecx
	call	_xmlUCSIsCatL
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2852 : 	    break;

	jmp	$LN2@xmlRegChec
$LN20@xmlRegChec:

; 2853 :         case XML_REGEXP_LETTER_UPPERCASE:
; 2854 : 	    ret = xmlUCSIsCatLu(codepoint);

	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	call	_xmlUCSIsCatLu
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2855 : 	    break;

	jmp	$LN2@xmlRegChec
$LN21@xmlRegChec:

; 2856 :         case XML_REGEXP_LETTER_LOWERCASE:
; 2857 : 	    ret = xmlUCSIsCatLl(codepoint);

	mov	eax, DWORD PTR _codepoint$[ebp]
	push	eax
	call	_xmlUCSIsCatLl
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2858 : 	    break;

	jmp	$LN2@xmlRegChec
$LN22@xmlRegChec:

; 2859 :         case XML_REGEXP_LETTER_TITLECASE:
; 2860 : 	    ret = xmlUCSIsCatLt(codepoint);

	mov	ecx, DWORD PTR _codepoint$[ebp]
	push	ecx
	call	_xmlUCSIsCatLt
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2861 : 	    break;

	jmp	$LN2@xmlRegChec
$LN23@xmlRegChec:

; 2862 :         case XML_REGEXP_LETTER_MODIFIER:
; 2863 : 	    ret = xmlUCSIsCatLm(codepoint);

	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	call	_xmlUCSIsCatLm
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2864 : 	    break;

	jmp	$LN2@xmlRegChec
$LN24@xmlRegChec:

; 2865 :         case XML_REGEXP_LETTER_OTHERS:
; 2866 : 	    ret = xmlUCSIsCatLo(codepoint);

	mov	eax, DWORD PTR _codepoint$[ebp]
	push	eax
	call	_xmlUCSIsCatLo
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2867 : 	    break;

	jmp	$LN2@xmlRegChec
$LN25@xmlRegChec:

; 2868 :         case XML_REGEXP_MARK:
; 2869 : 	    ret = xmlUCSIsCatM(codepoint);

	mov	ecx, DWORD PTR _codepoint$[ebp]
	push	ecx
	call	_xmlUCSIsCatM
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2870 : 	    break;

	jmp	$LN2@xmlRegChec
$LN26@xmlRegChec:

; 2871 :         case XML_REGEXP_MARK_NONSPACING:
; 2872 : 	    ret = xmlUCSIsCatMn(codepoint);

	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	call	_xmlUCSIsCatMn
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2873 : 	    break;

	jmp	$LN2@xmlRegChec
$LN27@xmlRegChec:

; 2874 :         case XML_REGEXP_MARK_SPACECOMBINING:
; 2875 : 	    ret = xmlUCSIsCatMc(codepoint);

	mov	eax, DWORD PTR _codepoint$[ebp]
	push	eax
	call	_xmlUCSIsCatMc
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2876 : 	    break;

	jmp	$LN2@xmlRegChec
$LN28@xmlRegChec:

; 2877 :         case XML_REGEXP_MARK_ENCLOSING:
; 2878 : 	    ret = xmlUCSIsCatMe(codepoint);

	mov	ecx, DWORD PTR _codepoint$[ebp]
	push	ecx
	call	_xmlUCSIsCatMe
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2879 : 	    break;

	jmp	$LN2@xmlRegChec
$LN29@xmlRegChec:

; 2880 :         case XML_REGEXP_NUMBER:
; 2881 : 	    ret = xmlUCSIsCatN(codepoint);

	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	call	_xmlUCSIsCatN
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2882 : 	    break;

	jmp	$LN2@xmlRegChec
$LN30@xmlRegChec:

; 2883 :         case XML_REGEXP_NUMBER_DECIMAL:
; 2884 : 	    ret = xmlUCSIsCatNd(codepoint);

	mov	eax, DWORD PTR _codepoint$[ebp]
	push	eax
	call	_xmlUCSIsCatNd
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2885 : 	    break;

	jmp	$LN2@xmlRegChec
$LN31@xmlRegChec:

; 2886 :         case XML_REGEXP_NUMBER_LETTER:
; 2887 : 	    ret = xmlUCSIsCatNl(codepoint);

	mov	ecx, DWORD PTR _codepoint$[ebp]
	push	ecx
	call	_xmlUCSIsCatNl
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2888 : 	    break;

	jmp	$LN2@xmlRegChec
$LN32@xmlRegChec:

; 2889 :         case XML_REGEXP_NUMBER_OTHERS:
; 2890 : 	    ret = xmlUCSIsCatNo(codepoint);

	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	call	_xmlUCSIsCatNo
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2891 : 	    break;

	jmp	$LN2@xmlRegChec
$LN33@xmlRegChec:

; 2892 :         case XML_REGEXP_PUNCT:
; 2893 : 	    ret = xmlUCSIsCatP(codepoint);

	mov	eax, DWORD PTR _codepoint$[ebp]
	push	eax
	call	_xmlUCSIsCatP
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2894 : 	    break;

	jmp	$LN2@xmlRegChec
$LN34@xmlRegChec:

; 2895 :         case XML_REGEXP_PUNCT_CONNECTOR:
; 2896 : 	    ret = xmlUCSIsCatPc(codepoint);

	mov	ecx, DWORD PTR _codepoint$[ebp]
	push	ecx
	call	_xmlUCSIsCatPc
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2897 : 	    break;

	jmp	$LN2@xmlRegChec
$LN35@xmlRegChec:

; 2898 :         case XML_REGEXP_PUNCT_DASH:
; 2899 : 	    ret = xmlUCSIsCatPd(codepoint);

	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	call	_xmlUCSIsCatPd
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2900 : 	    break;

	jmp	$LN2@xmlRegChec
$LN36@xmlRegChec:

; 2901 :         case XML_REGEXP_PUNCT_OPEN:
; 2902 : 	    ret = xmlUCSIsCatPs(codepoint);

	mov	eax, DWORD PTR _codepoint$[ebp]
	push	eax
	call	_xmlUCSIsCatPs
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2903 : 	    break;

	jmp	$LN2@xmlRegChec
$LN37@xmlRegChec:

; 2904 :         case XML_REGEXP_PUNCT_CLOSE:
; 2905 : 	    ret = xmlUCSIsCatPe(codepoint);

	mov	ecx, DWORD PTR _codepoint$[ebp]
	push	ecx
	call	_xmlUCSIsCatPe
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2906 : 	    break;

	jmp	$LN2@xmlRegChec
$LN38@xmlRegChec:

; 2907 :         case XML_REGEXP_PUNCT_INITQUOTE:
; 2908 : 	    ret = xmlUCSIsCatPi(codepoint);

	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	call	_xmlUCSIsCatPi
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2909 : 	    break;

	jmp	$LN2@xmlRegChec
$LN39@xmlRegChec:

; 2910 :         case XML_REGEXP_PUNCT_FINQUOTE:
; 2911 : 	    ret = xmlUCSIsCatPf(codepoint);

	mov	eax, DWORD PTR _codepoint$[ebp]
	push	eax
	call	_xmlUCSIsCatPf
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2912 : 	    break;

	jmp	$LN2@xmlRegChec
$LN40@xmlRegChec:

; 2913 :         case XML_REGEXP_PUNCT_OTHERS:
; 2914 : 	    ret = xmlUCSIsCatPo(codepoint);

	mov	ecx, DWORD PTR _codepoint$[ebp]
	push	ecx
	call	_xmlUCSIsCatPo
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2915 : 	    break;

	jmp	$LN2@xmlRegChec
$LN41@xmlRegChec:

; 2916 :         case XML_REGEXP_SEPAR:
; 2917 : 	    ret = xmlUCSIsCatZ(codepoint);

	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	call	_xmlUCSIsCatZ
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2918 : 	    break;

	jmp	$LN2@xmlRegChec
$LN42@xmlRegChec:

; 2919 :         case XML_REGEXP_SEPAR_SPACE:
; 2920 : 	    ret = xmlUCSIsCatZs(codepoint);

	mov	eax, DWORD PTR _codepoint$[ebp]
	push	eax
	call	_xmlUCSIsCatZs
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2921 : 	    break;

	jmp	$LN2@xmlRegChec
$LN43@xmlRegChec:

; 2922 :         case XML_REGEXP_SEPAR_LINE:
; 2923 : 	    ret = xmlUCSIsCatZl(codepoint);

	mov	ecx, DWORD PTR _codepoint$[ebp]
	push	ecx
	call	_xmlUCSIsCatZl
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2924 : 	    break;

	jmp	$LN2@xmlRegChec
$LN44@xmlRegChec:

; 2925 :         case XML_REGEXP_SEPAR_PARA:
; 2926 : 	    ret = xmlUCSIsCatZp(codepoint);

	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	call	_xmlUCSIsCatZp
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2927 : 	    break;

	jmp	$LN2@xmlRegChec
$LN45@xmlRegChec:

; 2928 :         case XML_REGEXP_SYMBOL:
; 2929 : 	    ret = xmlUCSIsCatS(codepoint);

	mov	eax, DWORD PTR _codepoint$[ebp]
	push	eax
	call	_xmlUCSIsCatS
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2930 : 	    break;

	jmp	$LN2@xmlRegChec
$LN46@xmlRegChec:

; 2931 :         case XML_REGEXP_SYMBOL_MATH:
; 2932 : 	    ret = xmlUCSIsCatSm(codepoint);

	mov	ecx, DWORD PTR _codepoint$[ebp]
	push	ecx
	call	_xmlUCSIsCatSm
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2933 : 	    break;

	jmp	$LN2@xmlRegChec
$LN47@xmlRegChec:

; 2934 :         case XML_REGEXP_SYMBOL_CURRENCY:
; 2935 : 	    ret = xmlUCSIsCatSc(codepoint);

	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	call	_xmlUCSIsCatSc
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2936 : 	    break;

	jmp	$LN2@xmlRegChec
$LN48@xmlRegChec:

; 2937 :         case XML_REGEXP_SYMBOL_MODIFIER:
; 2938 : 	    ret = xmlUCSIsCatSk(codepoint);

	mov	eax, DWORD PTR _codepoint$[ebp]
	push	eax
	call	_xmlUCSIsCatSk
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2939 : 	    break;

	jmp	SHORT $LN2@xmlRegChec
$LN49@xmlRegChec:

; 2940 :         case XML_REGEXP_SYMBOL_OTHERS:
; 2941 : 	    ret = xmlUCSIsCatSo(codepoint);

	mov	ecx, DWORD PTR _codepoint$[ebp]
	push	ecx
	call	_xmlUCSIsCatSo
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2942 : 	    break;

	jmp	SHORT $LN2@xmlRegChec
$LN50@xmlRegChec:

; 2943 :         case XML_REGEXP_OTHER:
; 2944 : 	    ret = xmlUCSIsCatC(codepoint);

	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	call	_xmlUCSIsCatC
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2945 : 	    break;

	jmp	SHORT $LN2@xmlRegChec
$LN51@xmlRegChec:

; 2946 :         case XML_REGEXP_OTHER_CONTROL:
; 2947 : 	    ret = xmlUCSIsCatCc(codepoint);

	mov	eax, DWORD PTR _codepoint$[ebp]
	push	eax
	call	_xmlUCSIsCatCc
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2948 : 	    break;

	jmp	SHORT $LN2@xmlRegChec
$LN52@xmlRegChec:

; 2949 :         case XML_REGEXP_OTHER_FORMAT:
; 2950 : 	    ret = xmlUCSIsCatCf(codepoint);

	mov	ecx, DWORD PTR _codepoint$[ebp]
	push	ecx
	call	_xmlUCSIsCatCf
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2951 : 	    break;

	jmp	SHORT $LN2@xmlRegChec
$LN53@xmlRegChec:

; 2952 :         case XML_REGEXP_OTHER_PRIVATE:
; 2953 : 	    ret = xmlUCSIsCatCo(codepoint);

	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	call	_xmlUCSIsCatCo
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2954 : 	    break;

	jmp	SHORT $LN2@xmlRegChec
$LN54@xmlRegChec:

; 2955 :         case XML_REGEXP_OTHER_NA:
; 2956 : 	    /* ret = xmlUCSIsCatCn(codepoint); */
; 2957 : 	    /* Seems it doesn't exist anymore in recent Unicode releases */
; 2958 : 	    ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 2959 : 	    break;

	jmp	SHORT $LN2@xmlRegChec
$LN55@xmlRegChec:

; 2960 :         case XML_REGEXP_BLOCK_NAME:
; 2961 : 	    ret = xmlUCSIsBlock(codepoint, (const char *) blockName);

	mov	eax, DWORD PTR _blockName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _codepoint$[ebp]
	push	ecx
	call	_xmlUCSIsBlock
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
$LN2@xmlRegChec:

; 2962 : 	    break;
; 2963 :     }
; 2964 :     if (neg)

	cmp	DWORD PTR _neg$[ebp], 0
	je	SHORT $LN56@xmlRegChec

; 2965 : 	return(!ret);

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN116@xmlRegChec
	mov	DWORD PTR tv286[ebp], 1
	jmp	SHORT $LN117@xmlRegChec
$LN116@xmlRegChec:
	mov	DWORD PTR tv286[ebp], 0
$LN117@xmlRegChec:
	mov	eax, DWORD PTR tv286[ebp]
	jmp	SHORT $LN1@xmlRegChec
$LN56@xmlRegChec:

; 2966 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlRegChec:

; 2967 : }

	pop	edi
	add	esp, 104				; 00000068H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN119@xmlRegChec:
	DD	$LN4@xmlRegChec
	DD	$LN6@xmlRegChec
	DD	$LN5@xmlRegChec
	DD	$LN8@xmlRegChec
	DD	$LN7@xmlRegChec
	DD	$LN10@xmlRegChec
	DD	$LN9@xmlRegChec
	DD	$LN12@xmlRegChec
	DD	$LN11@xmlRegChec
	DD	$LN14@xmlRegChec
	DD	$LN13@xmlRegChec
	DD	$LN15@xmlRegChec
	DD	$LN16@xmlRegChec
	DD	$LN19@xmlRegChec
	DD	$LN20@xmlRegChec
	DD	$LN21@xmlRegChec
	DD	$LN22@xmlRegChec
	DD	$LN23@xmlRegChec
	DD	$LN24@xmlRegChec
	DD	$LN25@xmlRegChec
	DD	$LN26@xmlRegChec
	DD	$LN27@xmlRegChec
	DD	$LN28@xmlRegChec
	DD	$LN29@xmlRegChec
	DD	$LN30@xmlRegChec
	DD	$LN31@xmlRegChec
	DD	$LN32@xmlRegChec
	DD	$LN33@xmlRegChec
	DD	$LN34@xmlRegChec
	DD	$LN35@xmlRegChec
	DD	$LN36@xmlRegChec
	DD	$LN37@xmlRegChec
	DD	$LN38@xmlRegChec
	DD	$LN39@xmlRegChec
	DD	$LN40@xmlRegChec
	DD	$LN41@xmlRegChec
	DD	$LN42@xmlRegChec
	DD	$LN43@xmlRegChec
	DD	$LN44@xmlRegChec
	DD	$LN45@xmlRegChec
	DD	$LN46@xmlRegChec
	DD	$LN47@xmlRegChec
	DD	$LN48@xmlRegChec
	DD	$LN49@xmlRegChec
	DD	$LN50@xmlRegChec
	DD	$LN51@xmlRegChec
	DD	$LN52@xmlRegChec
	DD	$LN53@xmlRegChec
	DD	$LN54@xmlRegChec
	DD	$LN55@xmlRegChec
	DD	$LN2@xmlRegChec
$LN118@xmlRegChec:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	50					; 00000032H
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	39					; 00000027H
	DB	40					; 00000028H
	DB	41					; 00000029H
	DB	42					; 0000002aH
	DB	43					; 0000002bH
	DB	44					; 0000002cH
	DB	45					; 0000002dH
	DB	46					; 0000002eH
	DB	47					; 0000002fH
	DB	48					; 00000030H
	DB	49					; 00000031H
_xmlRegCheckCharacterRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegCheckCharacter
_TEXT	SEGMENT
tv176 = -40						; size = 4
tv84 = -36						; size = 4
tv81 = -32						; size = 4
tv76 = -28						; size = 4
tv78 = -24						; size = 4
tv77 = -20						; size = 4
_accept$1 = -16						; size = 4
_range$ = -12						; size = 4
_ret$ = -8						; size = 4
_i$ = -4						; size = 4
_atom$ = 8						; size = 4
_codepoint$ = 12					; size = 4
_xmlRegCheckCharacter PROC				; COMDAT

; 2970 : xmlRegCheckCharacter(xmlRegAtomPtr atom, int codepoint) {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 2971 :     int i, ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 2972 :     xmlRegRangePtr range;
; 2973 : 
; 2974 :     if ((atom == NULL) || (!IS_CHAR(codepoint)))

	cmp	DWORD PTR _atom$[ebp], 0
	je	$LN8@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 256		; 00000100H
	jge	SHORT $LN32@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 9
	jl	SHORT $LN24@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 10		; 0000000aH
	jle	SHORT $LN25@xmlRegChec
$LN24@xmlRegChec:
	cmp	DWORD PTR _codepoint$[ebp], 13		; 0000000dH
	je	SHORT $LN25@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 32		; 00000020H
	jge	SHORT $LN25@xmlRegChec
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN31@xmlRegChec
$LN25@xmlRegChec:
	mov	DWORD PTR tv77[ebp], 1
$LN31@xmlRegChec:
	mov	eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN33@xmlRegChec
$LN32@xmlRegChec:
	cmp	DWORD PTR _codepoint$[ebp], 256		; 00000100H
	jl	SHORT $LN26@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 55295	; 0000d7ffH
	jle	SHORT $LN28@xmlRegChec
$LN26@xmlRegChec:
	cmp	DWORD PTR _codepoint$[ebp], 57344	; 0000e000H
	jl	SHORT $LN27@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 65533	; 0000fffdH
	jle	SHORT $LN28@xmlRegChec
$LN27@xmlRegChec:
	cmp	DWORD PTR _codepoint$[ebp], 65536	; 00010000H
	jl	SHORT $LN29@xmlRegChec
	cmp	DWORD PTR _codepoint$[ebp], 1114111	; 0010ffffH
	jle	SHORT $LN28@xmlRegChec
$LN29@xmlRegChec:
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN30@xmlRegChec
$LN28@xmlRegChec:
	mov	DWORD PTR tv76[ebp], 1
$LN30@xmlRegChec:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR tv78[ebp], ecx
$LN33@xmlRegChec:
	cmp	DWORD PTR tv78[ebp], 0
	jne	SHORT $LN7@xmlRegChec
$LN8@xmlRegChec:

; 2975 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlRegChec
$LN7@xmlRegChec:

; 2976 : 
; 2977 :     switch (atom->type) {

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv81[ebp], eax
	mov	ecx, DWORD PTR tv81[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv81[ebp], ecx
	cmp	DWORD PTR tv81[ebp], 135		; 00000087H
	ja	$LN2@xmlRegChec
	mov	edx, DWORD PTR tv81[ebp]
	movzx	eax, BYTE PTR $LN38@xmlRegChec[edx]
	jmp	DWORD PTR $LN39@xmlRegChec[eax*4]
$LN9@xmlRegChec:

; 2978 :         case XML_REGEXP_SUBREG:
; 2979 :         case XML_REGEXP_EPSILON:
; 2980 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlRegChec
$LN10@xmlRegChec:

; 2981 :         case XML_REGEXP_CHARVAL:
; 2982 :             return(codepoint == atom->codepoint);

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR _codepoint$[ebp]
	cmp	edx, DWORD PTR [ecx+32]
	jne	SHORT $LN34@xmlRegChec
	mov	DWORD PTR tv84[ebp], 1
	jmp	SHORT $LN35@xmlRegChec
$LN34@xmlRegChec:
	mov	DWORD PTR tv84[ebp], 0
$LN35@xmlRegChec:
	mov	eax, DWORD PTR tv84[ebp]
	jmp	$LN1@xmlRegChec
$LN11@xmlRegChec:

; 2983 :         case XML_REGEXP_RANGES: {
; 2984 : 	    int accept = 0;

	mov	DWORD PTR _accept$1[ebp], 0

; 2985 : 
; 2986 : 	    for (i = 0;i < atom->nbRanges;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@xmlRegChec
$LN4@xmlRegChec:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@xmlRegChec:
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+52]
	jge	$LN5@xmlRegChec

; 2987 : 		range = atom->ranges[i];

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _range$[ebp], eax

; 2988 : 		if (range->neg == 2) {

	mov	ecx, DWORD PTR _range$[ebp]
	cmp	DWORD PTR [ecx], 2
	jne	SHORT $LN12@xmlRegChec

; 2989 : 		    ret = xmlRegCheckCharacterRange(range->type, codepoint,

	mov	edx, DWORD PTR _range$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _range$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _range$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	mov	eax, DWORD PTR _range$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_xmlRegCheckCharacterRange
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ret$[ebp], eax

; 2990 : 						0, range->start, range->end,
; 2991 : 						range->blockName);
; 2992 : 		    if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN14@xmlRegChec

; 2993 : 			return(0); /* excluded char */

	xor	eax, eax
	jmp	$LN1@xmlRegChec
$LN14@xmlRegChec:

; 2994 : 		} else if (range->neg) {

	jmp	$LN13@xmlRegChec
$LN12@xmlRegChec:
	mov	edx, DWORD PTR _range$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN15@xmlRegChec

; 2995 : 		    ret = xmlRegCheckCharacterRange(range->type, codepoint,

	mov	eax, DWORD PTR _range$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _range$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _range$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	0
	mov	eax, DWORD PTR _codepoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _range$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlRegCheckCharacterRange
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ret$[ebp], eax

; 2996 : 						0, range->start, range->end,
; 2997 : 						range->blockName);
; 2998 : 		    if (ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN17@xmlRegChec

; 2999 : 		        accept = 1;

	mov	DWORD PTR _accept$1[ebp], 1
	jmp	SHORT $LN18@xmlRegChec
$LN17@xmlRegChec:

; 3000 : 		    else
; 3001 : 		        return(0);

	xor	eax, eax
	jmp	$LN1@xmlRegChec
$LN18@xmlRegChec:

; 3002 : 		} else {

	jmp	SHORT $LN13@xmlRegChec
$LN15@xmlRegChec:

; 3003 : 		    ret = xmlRegCheckCharacterRange(range->type, codepoint,

	mov	eax, DWORD PTR _range$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _range$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _range$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	0
	mov	eax, DWORD PTR _codepoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _range$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlRegCheckCharacterRange
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ret$[ebp], eax

; 3004 : 						0, range->start, range->end,
; 3005 : 						range->blockName);
; 3006 : 		    if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN13@xmlRegChec

; 3007 : 			accept = 1; /* might still be excluded */

	mov	DWORD PTR _accept$1[ebp], 1
$LN13@xmlRegChec:

; 3008 : 		}
; 3009 : 	    }

	jmp	$LN4@xmlRegChec
$LN5@xmlRegChec:

; 3010 : 	    return(accept);

	mov	eax, DWORD PTR _accept$1[ebp]
	jmp	SHORT $LN1@xmlRegChec
$LN20@xmlRegChec:

; 3011 : 	}
; 3012 :         case XML_REGEXP_STRING:
; 3013 : 	    printf("TODO: XML_REGEXP_STRING\n");

	push	OFFSET ??_C@_0BJ@POCEJEIB@TODO?3?5XML_REGEXP_STRING?6@
	call	_printf
	add	esp, 4

; 3014 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlRegChec
$LN21@xmlRegChec:

; 3015 :         case XML_REGEXP_ANYCHAR:
; 3016 :         case XML_REGEXP_ANYSPACE:
; 3017 :         case XML_REGEXP_NOTSPACE:
; 3018 :         case XML_REGEXP_INITNAME:
; 3019 :         case XML_REGEXP_NOTINITNAME:
; 3020 :         case XML_REGEXP_NAMECHAR:
; 3021 :         case XML_REGEXP_NOTNAMECHAR:
; 3022 :         case XML_REGEXP_DECIMAL:
; 3023 :         case XML_REGEXP_NOTDECIMAL:
; 3024 :         case XML_REGEXP_REALCHAR:
; 3025 :         case XML_REGEXP_NOTREALCHAR:
; 3026 :         case XML_REGEXP_LETTER:
; 3027 :         case XML_REGEXP_LETTER_UPPERCASE:
; 3028 :         case XML_REGEXP_LETTER_LOWERCASE:
; 3029 :         case XML_REGEXP_LETTER_TITLECASE:
; 3030 :         case XML_REGEXP_LETTER_MODIFIER:
; 3031 :         case XML_REGEXP_LETTER_OTHERS:
; 3032 :         case XML_REGEXP_MARK:
; 3033 :         case XML_REGEXP_MARK_NONSPACING:
; 3034 :         case XML_REGEXP_MARK_SPACECOMBINING:
; 3035 :         case XML_REGEXP_MARK_ENCLOSING:
; 3036 :         case XML_REGEXP_NUMBER:
; 3037 :         case XML_REGEXP_NUMBER_DECIMAL:
; 3038 :         case XML_REGEXP_NUMBER_LETTER:
; 3039 :         case XML_REGEXP_NUMBER_OTHERS:
; 3040 :         case XML_REGEXP_PUNCT:
; 3041 :         case XML_REGEXP_PUNCT_CONNECTOR:
; 3042 :         case XML_REGEXP_PUNCT_DASH:
; 3043 :         case XML_REGEXP_PUNCT_OPEN:
; 3044 :         case XML_REGEXP_PUNCT_CLOSE:
; 3045 :         case XML_REGEXP_PUNCT_INITQUOTE:
; 3046 :         case XML_REGEXP_PUNCT_FINQUOTE:
; 3047 :         case XML_REGEXP_PUNCT_OTHERS:
; 3048 :         case XML_REGEXP_SEPAR:
; 3049 :         case XML_REGEXP_SEPAR_SPACE:
; 3050 :         case XML_REGEXP_SEPAR_LINE:
; 3051 :         case XML_REGEXP_SEPAR_PARA:
; 3052 :         case XML_REGEXP_SYMBOL:
; 3053 :         case XML_REGEXP_SYMBOL_MATH:
; 3054 :         case XML_REGEXP_SYMBOL_CURRENCY:
; 3055 :         case XML_REGEXP_SYMBOL_MODIFIER:
; 3056 :         case XML_REGEXP_SYMBOL_OTHERS:
; 3057 :         case XML_REGEXP_OTHER:
; 3058 :         case XML_REGEXP_OTHER_CONTROL:
; 3059 :         case XML_REGEXP_OTHER_FORMAT:
; 3060 :         case XML_REGEXP_OTHER_PRIVATE:
; 3061 :         case XML_REGEXP_OTHER_NA:
; 3062 : 	case XML_REGEXP_BLOCK_NAME:
; 3063 : 	    ret = xmlRegCheckCharacterRange(atom->type, codepoint, 0, 0, 0,

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _codepoint$[ebp]
	push	edx
	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_xmlRegCheckCharacterRange
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ret$[ebp], eax

; 3064 : 		                            (const xmlChar *)atom->valuep);
; 3065 : 	    if (atom->neg)

	mov	edx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN2@xmlRegChec

; 3066 : 		ret = !ret;

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN36@xmlRegChec
	mov	DWORD PTR tv176[ebp], 1
	jmp	SHORT $LN37@xmlRegChec
$LN36@xmlRegChec:
	mov	DWORD PTR tv176[ebp], 0
$LN37@xmlRegChec:
	mov	eax, DWORD PTR tv176[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN2@xmlRegChec:

; 3067 : 	    break;
; 3068 :     }
; 3069 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlRegChec:

; 3070 : }

	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN39@xmlRegChec:
	DD	$LN9@xmlRegChec
	DD	$LN10@xmlRegChec
	DD	$LN11@xmlRegChec
	DD	$LN20@xmlRegChec
	DD	$LN21@xmlRegChec
	DD	$LN2@xmlRegChec
$LN38@xmlRegChec:
	DB	0
	DB	1
	DB	2
	DB	0
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
_xmlRegCheckCharacter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegStrEqualWildcard
_TEXT	SEGMENT
tv80 = -12						; size = 4
tv79 = -8						; size = 4
_tmp$1 = -4						; size = 4
_expStr$ = 8						; size = 4
_valStr$ = 12						; size = 4
_xmlRegStrEqualWildcard PROC				; COMDAT

; 3651 : xmlRegStrEqualWildcard(const xmlChar *expStr, const xmlChar *valStr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 3652 :     if (expStr == valStr) return(1);

	mov	eax, DWORD PTR _expStr$[ebp]
	cmp	eax, DWORD PTR _valStr$[ebp]
	jne	SHORT $LN8@xmlRegStrE
	mov	eax, 1
	jmp	$LN1@xmlRegStrE
$LN8@xmlRegStrE:

; 3653 :     if (expStr == NULL) return(0);

	cmp	DWORD PTR _expStr$[ebp], 0
	jne	SHORT $LN9@xmlRegStrE
	xor	eax, eax
	jmp	$LN1@xmlRegStrE
$LN9@xmlRegStrE:

; 3654 :     if (valStr == NULL) return(0);

	cmp	DWORD PTR _valStr$[ebp], 0
	jne	SHORT $LN4@xmlRegStrE
	xor	eax, eax
	jmp	$LN1@xmlRegStrE
$LN4@xmlRegStrE:

; 3655 :     do {
; 3656 : 	/*
; 3657 : 	* Eval if we have a wildcard for the current item.
; 3658 : 	*/
; 3659 :         if (*expStr != *valStr) {

	mov	ecx, DWORD PTR _expStr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _valStr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	je	$LN11@xmlRegStrE

; 3660 : 	    /* if one of them starts with a wildcard make valStr be it */
; 3661 : 	    if (*valStr == '*') {

	mov	edx, DWORD PTR _valStr$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN12@xmlRegStrE

; 3662 : 	        const xmlChar *tmp;
; 3663 : 
; 3664 : 		tmp = valStr;

	mov	ecx, DWORD PTR _valStr$[ebp]
	mov	DWORD PTR _tmp$1[ebp], ecx

; 3665 : 		valStr = expStr;

	mov	edx, DWORD PTR _expStr$[ebp]
	mov	DWORD PTR _valStr$[ebp], edx

; 3666 : 		expStr = tmp;

	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR _expStr$[ebp], eax
$LN12@xmlRegStrE:

; 3667 : 	    }
; 3668 : 	    if ((*valStr != 0) && (*expStr != 0) && (*expStr++ == '*')) {

	mov	ecx, DWORD PTR _valStr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN13@xmlRegStrE
	mov	eax, DWORD PTR _expStr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN13@xmlRegStrE
	mov	edx, DWORD PTR _expStr$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv79[ebp], eax
	mov	ecx, DWORD PTR _expStr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _expStr$[ebp], ecx
	cmp	DWORD PTR tv79[ebp], 42			; 0000002aH
	jne	SHORT $LN19@xmlRegStrE
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN20@xmlRegStrE
$LN19@xmlRegStrE:
	mov	DWORD PTR tv80[ebp], 0
$LN20@xmlRegStrE:
	cmp	DWORD PTR tv80[ebp], 0
	je	SHORT $LN13@xmlRegStrE
$LN7@xmlRegStrE:

; 3669 : 		do {
; 3670 : 		    if (*valStr == XML_REG_STRING_SEPARATOR)

	mov	edx, DWORD PTR _valStr$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 124				; 0000007cH
	jne	SHORT $LN15@xmlRegStrE

; 3671 : 			break;

	jmp	SHORT $LN6@xmlRegStrE
$LN15@xmlRegStrE:

; 3672 : 		    valStr++;

	mov	ecx, DWORD PTR _valStr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _valStr$[ebp], ecx

; 3673 : 		} while (*valStr != 0);

	mov	edx, DWORD PTR _valStr$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN7@xmlRegStrE
$LN6@xmlRegStrE:

; 3674 : 		continue;

	jmp	SHORT $LN2@xmlRegStrE

; 3675 : 	    } else

	jmp	SHORT $LN11@xmlRegStrE
$LN13@xmlRegStrE:

; 3676 : 		return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlRegStrE
$LN11@xmlRegStrE:

; 3677 : 	}
; 3678 : 	expStr++;

	mov	ecx, DWORD PTR _expStr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _expStr$[ebp], ecx

; 3679 : 	valStr++;

	mov	edx, DWORD PTR _valStr$[ebp]
	add	edx, 1
	mov	DWORD PTR _valStr$[ebp], edx
$LN2@xmlRegStrE:

; 3680 :     } while (*valStr != 0);

	mov	eax, DWORD PTR _valStr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	$LN4@xmlRegStrE

; 3681 :     if (*expStr != 0)

	mov	edx, DWORD PTR _expStr$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN16@xmlRegStrE

; 3682 : 	return (0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlRegStrE
	jmp	SHORT $LN1@xmlRegStrE
$LN16@xmlRegStrE:

; 3683 :     else
; 3684 : 	return (1);

	mov	eax, 1
$LN1@xmlRegStrE:

; 3685 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegStrEqualWildcard ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegFreeAtom
_TEXT	SEGMENT
_i$ = -4						; size = 4
_atom$ = 8						; size = 4
_xmlRegFreeAtom PROC					; COMDAT

; 810  : xmlRegFreeAtom(xmlRegAtomPtr atom) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 811  :     int i;
; 812  : 
; 813  :     if (atom == NULL)

	cmp	DWORD PTR _atom$[ebp], 0
	jne	SHORT $LN5@xmlRegFree

; 814  : 	return;

	jmp	$LN1@xmlRegFree
$LN5@xmlRegFree:

; 815  : 
; 816  :     for (i = 0;i < atom->nbRanges;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlRegFree
$LN2@xmlRegFree:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlRegFree:
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+52]
	jge	SHORT $LN3@xmlRegFree

; 817  : 	xmlRegFreeRange(atom->ranges[i]);

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_xmlRegFreeRange
	add	esp, 4
	jmp	SHORT $LN2@xmlRegFree
$LN3@xmlRegFree:

; 818  :     if (atom->ranges != NULL)

	mov	ecx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [ecx+56], 0
	je	SHORT $LN6@xmlRegFree

; 819  : 	xmlFree(atom->ranges);

	mov	esi, esp
	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@xmlRegFree:

; 820  :     if ((atom->type == XML_REGEXP_STRING) && (atom->valuep != NULL))

	mov	ecx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [ecx+4], 5
	jne	SHORT $LN7@xmlRegFree
	mov	edx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN7@xmlRegFree

; 821  : 	xmlFree(atom->valuep);

	mov	esi, esp
	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlRegFree:

; 822  :     if ((atom->type == XML_REGEXP_STRING) && (atom->valuep2 != NULL))

	mov	edx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [edx+4], 5
	jne	SHORT $LN8@xmlRegFree
	mov	eax, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN8@xmlRegFree

; 823  : 	xmlFree(atom->valuep2);

	mov	esi, esp
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@xmlRegFree:

; 824  :     if ((atom->type == XML_REGEXP_BLOCK_NAME) && (atom->valuep != NULL))

	mov	eax, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [eax+4], 136			; 00000088H
	jne	SHORT $LN9@xmlRegFree
	mov	ecx, DWORD PTR _atom$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN9@xmlRegFree

; 825  : 	xmlFree(atom->valuep);

	mov	esi, esp
	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@xmlRegFree:

; 826  :     xmlFree(atom);

	mov	esi, esp
	mov	ecx, DWORD PTR _atom$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlRegFree:

; 827  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegFreeAtom ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegFreeState
_TEXT	SEGMENT
_state$ = 8						; size = 4
_xmlRegFreeState PROC					; COMDAT

; 897  : xmlRegFreeState(xmlRegStatePtr state) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 898  :     if (state == NULL)

	cmp	DWORD PTR _state$[ebp], 0
	jne	SHORT $LN2@xmlRegFree

; 899  : 	return;

	jmp	SHORT $LN1@xmlRegFree
$LN2@xmlRegFree:

; 900  : 
; 901  :     if (state->trans != NULL)

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN3@xmlRegFree

; 902  : 	xmlFree(state->trans);

	mov	esi, esp
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlRegFree:

; 903  :     if (state->transTo != NULL)

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN4@xmlRegFree

; 904  : 	xmlFree(state->transTo);

	mov	esi, esp
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlRegFree:

; 905  :     xmlFree(state);

	mov	esi, esp
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlRegFree:

; 906  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlRegFreeState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseRegExp
_TEXT	SEGMENT
_end$ = -8						; size = 4
_start$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_top$ = 12						; size = 4
_xmlFAParseRegExp PROC					; COMDAT

; 5378 : xmlFAParseRegExp(xmlRegParserCtxtPtr ctxt, int top) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5379 :     xmlRegStatePtr start, end;
; 5380 : 
; 5381 :     /* if not top start should have been generated by an epsilon trans */
; 5382 :     start = ctxt->state;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _start$[ebp], ecx

; 5383 :     ctxt->end = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+20], 0

; 5384 :     xmlFAParseBranch(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAParseBranch
	add	esp, 8

; 5385 :     if (top) {

	cmp	DWORD PTR _top$[ebp], 0
	je	SHORT $LN4@xmlFAParse

; 5386 : #ifdef DEBUG_REGEXP_GRAPH
; 5387 : 	printf("State %d is final\n", ctxt->state->no);
; 5388 : #endif
; 5389 : 	ctxt->state->type = XML_REGEXP_FINAL_STATE;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx], 2
$LN4@xmlFAParse:

; 5390 :     }
; 5391 :     if (CUR != '|') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 124				; 0000007cH
	je	SHORT $LN5@xmlFAParse

; 5392 : 	ctxt->end = ctxt->state;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+20], edx

; 5393 : 	return;

	jmp	$LN1@xmlFAParse
$LN5@xmlFAParse:

; 5394 :     }
; 5395 :     end = ctxt->state;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _end$[ebp], ecx
$LN2@xmlFAParse:

; 5396 :     while ((CUR == '|') && (ctxt->error == 0)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 124				; 0000007cH
	jne	SHORT $LN3@xmlFAParse
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN3@xmlFAParse

; 5397 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 5398 : 	if (CUR == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN6@xmlFAParse

; 5399 : 	    ERROR("expecting a branch after |")

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0BL@KAIMKABF@expecting?5a?5branch?5after?5?$HM@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegexpErrCompile
	add	esp, 8

; 5400 : 	    return;

	jmp	SHORT $LN1@xmlFAParse
$LN6@xmlFAParse:

; 5401 : 	}
; 5402 : 	ctxt->state = start;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR [edx+24], eax

; 5403 : 	ctxt->end = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 5404 : 	xmlFAParseBranch(ctxt, end);

	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFAParseBranch
	add	esp, 8

; 5405 :     }

	jmp	SHORT $LN2@xmlFAParse
$LN3@xmlFAParse:

; 5406 :     if (!top) {

	cmp	DWORD PTR _top$[ebp], 0
	jne	SHORT $LN1@xmlFAParse

; 5407 : 	ctxt->state = end;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _end$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 5408 : 	ctxt->end = end;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _end$[ebp]
	mov	DWORD PTR [eax+20], ecx
$LN1@xmlFAParse:

; 5409 :     }
; 5410 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFAParseRegExp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataIsDeterminist
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_am$ = 8						; size = 4
_xmlAutomataIsDeterminist PROC				; COMDAT

; 6322 : xmlAutomataIsDeterminist(xmlAutomataPtr am) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6323 :     int ret;
; 6324 : 
; 6325 :     if (am == NULL)

	cmp	DWORD PTR _am$[ebp], 0
	jne	SHORT $LN2@xmlAutomat

; 6326 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlAutomat
$LN2@xmlAutomat:

; 6327 : 
; 6328 :     ret = xmlFAComputesDeterminism(am);

	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlFAComputesDeterminism
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 6329 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlAutomat:

; 6330 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAutomataIsDeterminist ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataCompile
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_am$ = 8						; size = 4
_xmlAutomataCompile PROC				; COMDAT

; 6302 : xmlAutomataCompile(xmlAutomataPtr am) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6303 :     xmlRegexpPtr ret;
; 6304 : 
; 6305 :     if ((am == NULL) || (am->error != 0)) return(NULL);

	cmp	DWORD PTR _am$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	mov	eax, DWORD PTR _am$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN2@xmlAutomat
$LN3@xmlAutomat:
	xor	eax, eax
	jmp	SHORT $LN1@xmlAutomat
$LN2@xmlAutomat:

; 6306 :     xmlFAEliminateEpsilonTransitions(am);

	mov	ecx, DWORD PTR _am$[ebp]
	push	ecx
	call	_xmlFAEliminateEpsilonTransitions
	add	esp, 4

; 6307 :     /* xmlFAComputesDeterminism(am); */
; 6308 :     ret = xmlRegEpxFromParse(am);

	mov	edx, DWORD PTR _am$[ebp]
	push	edx
	call	_xmlRegEpxFromParse
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 6309 : 
; 6310 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlAutomat:

; 6311 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAutomataCompile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewCounter
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_am$ = 8						; size = 4
_min$ = 12						; size = 4
_max$ = 16						; size = 4
_xmlAutomataNewCounter PROC				; COMDAT

; 6230 : xmlAutomataNewCounter(xmlAutomataPtr am, int min, int max) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6231 :     int ret;
; 6232 : 
; 6233 :     if (am == NULL)

	cmp	DWORD PTR _am$[ebp], 0
	jne	SHORT $LN2@xmlAutomat

; 6234 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlAutomat
$LN2@xmlAutomat:

; 6235 : 
; 6236 :     ret = xmlRegGetCounter(am);

	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlRegGetCounter
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 6237 :     if (ret < 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN3@xmlAutomat

; 6238 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlAutomat
$LN3@xmlAutomat:

; 6239 :     am->counters[ret].min = min;

	mov	ecx, DWORD PTR _am$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _min$[ebp]
	mov	DWORD PTR [edx+eax*8], ecx

; 6240 :     am->counters[ret].max = max;

	mov	edx, DWORD PTR _am$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [eax+ecx*8+4], edx

; 6241 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlAutomat:

; 6242 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAutomataNewCounter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewCounterTrans
_TEXT	SEGMENT
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_counter$ = 20						; size = 4
_xmlAutomataNewCounterTrans PROC			; COMDAT

; 6283 : 		xmlAutomataStatePtr to, int counter) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6284 :     if ((am == NULL) || (from == NULL) || (counter < 0))

	cmp	DWORD PTR _am$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _from$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _counter$[ebp], 0
	jge	SHORT $LN2@xmlAutomat
$LN3@xmlAutomat:

; 6285 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAutomat
$LN2@xmlAutomat:

; 6286 :     xmlFAGenerateCountedTransition(am, from, to, counter);

	mov	eax, DWORD PTR _counter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlFAGenerateCountedTransition
	add	esp, 16					; 00000010H

; 6287 :     if (to == NULL)

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN4@xmlAutomat

; 6288 : 	return(am->state);

	mov	ecx, DWORD PTR _am$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	jmp	SHORT $LN1@xmlAutomat
$LN4@xmlAutomat:

; 6289 :     return(to);

	mov	eax, DWORD PTR _to$[ebp]
$LN1@xmlAutomat:

; 6290 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlAutomataNewCounterTrans ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewCountedTrans
_TEXT	SEGMENT
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_counter$ = 20						; size = 4
_xmlAutomataNewCountedTrans PROC			; COMDAT

; 6259 : 		xmlAutomataStatePtr to, int counter) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6260 :     if ((am == NULL) || (from == NULL) || (counter < 0))

	cmp	DWORD PTR _am$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _from$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _counter$[ebp], 0
	jge	SHORT $LN2@xmlAutomat
$LN3@xmlAutomat:

; 6261 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAutomat
$LN2@xmlAutomat:

; 6262 :     xmlFAGenerateCountedEpsilonTransition(am, from, to, counter);

	mov	eax, DWORD PTR _counter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlFAGenerateCountedEpsilonTransition
	add	esp, 16					; 00000010H

; 6263 :     if (to == NULL)

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN4@xmlAutomat

; 6264 : 	return(am->state);

	mov	ecx, DWORD PTR _am$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	jmp	SHORT $LN1@xmlAutomat
$LN4@xmlAutomat:

; 6265 :     return(to);

	mov	eax, DWORD PTR _to$[ebp]
$LN1@xmlAutomat:

; 6266 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlAutomataNewCountedTrans ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewEpsilon
_TEXT	SEGMENT
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_xmlAutomataNewEpsilon PROC				; COMDAT

; 6185 : 		      xmlAutomataStatePtr to) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6186 :     if ((am == NULL) || (from == NULL))

	cmp	DWORD PTR _am$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _from$[ebp], 0
	jne	SHORT $LN2@xmlAutomat
$LN3@xmlAutomat:

; 6187 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAutomat
$LN2@xmlAutomat:

; 6188 :     xmlFAGenerateEpsilonTransition(am, from, to);

	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	mov	edx, DWORD PTR _am$[ebp]
	push	edx
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH

; 6189 :     if (to == NULL)

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN4@xmlAutomat

; 6190 : 	return(am->state);

	mov	eax, DWORD PTR _am$[ebp]
	mov	eax, DWORD PTR [eax+24]
	jmp	SHORT $LN1@xmlAutomat
$LN4@xmlAutomat:

; 6191 :     return(to);

	mov	eax, DWORD PTR _to$[ebp]
$LN1@xmlAutomat:

; 6192 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlAutomataNewEpsilon ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewAllTrans
_TEXT	SEGMENT
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_lax$ = 20						; size = 4
_xmlAutomataNewAllTrans PROC				; COMDAT

; 6210 : 		       xmlAutomataStatePtr to, int lax) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6211 :     if ((am == NULL) || (from == NULL))

	cmp	DWORD PTR _am$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _from$[ebp], 0
	jne	SHORT $LN2@xmlAutomat
$LN3@xmlAutomat:

; 6212 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAutomat
$LN2@xmlAutomat:

; 6213 :     xmlFAGenerateAllTransition(am, from, to, lax);

	mov	eax, DWORD PTR _lax$[ebp]
	push	eax
	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlFAGenerateAllTransition
	add	esp, 16					; 00000010H

; 6214 :     if (to == NULL)

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN4@xmlAutomat

; 6215 : 	return(am->state);

	mov	ecx, DWORD PTR _am$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	jmp	SHORT $LN1@xmlAutomat
$LN4@xmlAutomat:

; 6216 :     return(to);

	mov	eax, DWORD PTR _to$[ebp]
$LN1@xmlAutomat:

; 6217 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlAutomataNewAllTrans ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewOnceTrans2
_TEXT	SEGMENT
tv85 = -52						; size = 4
tv203 = -45						; size = 1
tv200 = -44						; size = 4
tv197 = -40						; size = 4
tv82 = -36						; size = 4
tv191 = -29						; size = 1
tv188 = -28						; size = 4
tv185 = -24						; size = 4
_str$1 = -20						; size = 4
_lenp$2 = -16						; size = 4
_lenn$3 = -12						; size = 4
_counter$ = -8						; size = 4
_atom$ = -4						; size = 4
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_token$ = 20						; size = 4
_token2$ = 24						; size = 4
_min$ = 28						; size = 4
_max$ = 32						; size = 4
_data$ = 36						; size = 4
_xmlAutomataNewOnceTrans2 PROC				; COMDAT

; 6037 : 			 int min, int max, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6038 :     xmlRegAtomPtr atom;
; 6039 :     int counter;
; 6040 : 
; 6041 :     if ((am == NULL) || (from == NULL) || (token == NULL))

	cmp	DWORD PTR _am$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _from$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _token$[ebp], 0
	jne	SHORT $LN2@xmlAutomat
$LN3@xmlAutomat:

; 6042 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN2@xmlAutomat:

; 6043 :     if (min < 1)

	cmp	DWORD PTR _min$[ebp], 1
	jge	SHORT $LN4@xmlAutomat

; 6044 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN4@xmlAutomat:

; 6045 :     if ((max < min) || (max < 1))

	mov	eax, DWORD PTR _max$[ebp]
	cmp	eax, DWORD PTR _min$[ebp]
	jl	SHORT $LN6@xmlAutomat
	cmp	DWORD PTR _max$[ebp], 1
	jge	SHORT $LN5@xmlAutomat
$LN6@xmlAutomat:

; 6046 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN5@xmlAutomat:

; 6047 :     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);

	push	5
	mov	ecx, DWORD PTR _am$[ebp]
	push	ecx
	call	_xmlRegNewAtom
	add	esp, 8
	mov	DWORD PTR _atom$[ebp], eax

; 6048 :     if (atom == NULL)

	cmp	DWORD PTR _atom$[ebp], 0
	jne	SHORT $LN7@xmlAutomat

; 6049 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN7@xmlAutomat:

; 6050 :     if ((token2 == NULL) || (*token2 == 0)) {

	cmp	DWORD PTR _token2$[ebp], 0
	je	SHORT $LN10@xmlAutomat
	mov	edx, DWORD PTR _token2$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN8@xmlAutomat
$LN10@xmlAutomat:

; 6051 : 	atom->valuep = xmlStrdup(token);

	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [edx+20], eax

; 6052 :     } else {

	jmp	$LN9@xmlAutomat
$LN8@xmlAutomat:

; 6053 : 	int lenn, lenp;
; 6054 : 	xmlChar *str;
; 6055 : 
; 6056 : 	lenn = strlen((char *) token2);

	mov	eax, DWORD PTR _token2$[ebp]
	mov	DWORD PTR tv185[ebp], eax
	mov	ecx, DWORD PTR tv185[ebp]
	add	ecx, 1
	mov	DWORD PTR tv188[ebp], ecx
$LL14@xmlAutomat:
	mov	edx, DWORD PTR tv185[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv191[ebp], al
	add	DWORD PTR tv185[ebp], 1
	cmp	BYTE PTR tv191[ebp], 0
	jne	SHORT $LL14@xmlAutomat
	mov	ecx, DWORD PTR tv185[ebp]
	sub	ecx, DWORD PTR tv188[ebp]
	mov	DWORD PTR tv82[ebp], ecx
	mov	edx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _lenn$3[ebp], edx

; 6057 : 	lenp = strlen((char *) token);

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR tv197[ebp], eax
	mov	ecx, DWORD PTR tv197[ebp]
	add	ecx, 1
	mov	DWORD PTR tv200[ebp], ecx
$LL15@xmlAutomat:
	mov	edx, DWORD PTR tv197[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv203[ebp], al
	add	DWORD PTR tv197[ebp], 1
	cmp	BYTE PTR tv203[ebp], 0
	jne	SHORT $LL15@xmlAutomat
	mov	ecx, DWORD PTR tv197[ebp]
	sub	ecx, DWORD PTR tv200[ebp]
	mov	DWORD PTR tv85[ebp], ecx
	mov	edx, DWORD PTR tv85[ebp]
	mov	DWORD PTR _lenp$2[ebp], edx

; 6058 : 
; 6059 : 	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);

	mov	eax, DWORD PTR _lenp$2[ebp]
	mov	ecx, DWORD PTR _lenn$3[ebp]
	lea	edx, DWORD PTR [ecx+eax+2]
	mov	esi, esp
	push	edx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _str$1[ebp], eax

; 6060 : 	if (str == NULL) {

	cmp	DWORD PTR _str$1[ebp], 0
	jne	SHORT $LN11@xmlAutomat

; 6061 : 	    xmlRegFreeAtom(atom);

	mov	eax, DWORD PTR _atom$[ebp]
	push	eax
	call	_xmlRegFreeAtom
	add	esp, 4

; 6062 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN11@xmlAutomat:

; 6063 : 	}
; 6064 : 	memcpy(&str[0], token, lenp);

	mov	ecx, DWORD PTR _lenp$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _token$[ebp]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _str$1[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6065 : 	str[lenp] = '|';

	mov	edx, DWORD PTR _str$1[ebp]
	add	edx, DWORD PTR _lenp$2[ebp]
	mov	BYTE PTR [edx], 124			; 0000007cH

; 6066 : 	memcpy(&str[lenp + 1], token2, lenn);

	mov	eax, DWORD PTR _lenn$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _token2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lenp$2[ebp]
	mov	eax, DWORD PTR _str$1[ebp]
	lea	ecx, DWORD PTR [eax+edx+1]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6067 : 	str[lenn + lenp + 1] = 0;

	mov	edx, DWORD PTR _lenn$3[ebp]
	add	edx, DWORD PTR _lenp$2[ebp]
	mov	eax, DWORD PTR _str$1[ebp]
	mov	BYTE PTR [eax+edx+1], 0

; 6068 : 
; 6069 : 	atom->valuep = str;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR _str$1[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN9@xmlAutomat:

; 6070 :     }
; 6071 :     atom->data = data;

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+60], ecx

; 6072 :     atom->quant = XML_REGEXP_QUANT_ONCEONLY;

	mov	edx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [edx+8], 6

; 6073 :     atom->min = min;

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR _min$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 6074 :     atom->max = max;

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR _max$[ebp]
	mov	DWORD PTR [edx+16], eax

; 6075 :     /*
; 6076 :      * associate a counter to the transition.
; 6077 :      */
; 6078 :     counter = xmlRegGetCounter(am);

	mov	ecx, DWORD PTR _am$[ebp]
	push	ecx
	call	_xmlRegGetCounter
	add	esp, 4
	mov	DWORD PTR _counter$[ebp], eax

; 6079 :     am->counters[counter].min = 1;

	mov	edx, DWORD PTR _am$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	ecx, DWORD PTR _counter$[ebp]
	mov	DWORD PTR [eax+ecx*8], 1

; 6080 :     am->counters[counter].max = 1;

	mov	edx, DWORD PTR _am$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	ecx, DWORD PTR _counter$[ebp]
	mov	DWORD PTR [eax+ecx*8+4], 1

; 6081 : 
; 6082 :     /* xmlFAGenerateTransitions(am, from, to, atom); */
; 6083 :     if (to == NULL) {

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN12@xmlAutomat

; 6084 : 	to = xmlRegNewState(am);

	mov	edx, DWORD PTR _am$[ebp]
	push	edx
	call	_xmlRegNewState
	add	esp, 4
	mov	DWORD PTR _to$[ebp], eax

; 6085 : 	xmlRegStatePush(am, to);

	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _am$[ebp]
	push	ecx
	call	_xmlRegStatePush
	add	esp, 8
$LN12@xmlAutomat:

; 6086 :     }
; 6087 :     xmlRegStateAddTrans(am, from, atom, to, counter, -1);

	push	-1
	mov	edx, DWORD PTR _counter$[ebp]
	push	edx
	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _atom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H

; 6088 :     xmlRegAtomPush(am, atom);

	mov	ecx, DWORD PTR _atom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _am$[ebp]
	push	edx
	call	_xmlRegAtomPush
	add	esp, 8

; 6089 :     am->state = to;

	mov	eax, DWORD PTR _am$[ebp]
	mov	ecx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 6090 :     return(to);

	mov	eax, DWORD PTR _to$[ebp]
$LN1@xmlAutomat:

; 6091 : }

	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAutomataNewOnceTrans2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewOnceTrans
_TEXT	SEGMENT
_counter$ = -8						; size = 4
_atom$ = -4						; size = 4
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_token$ = 20						; size = 4
_min$ = 24						; size = 4
_max$ = 28						; size = 4
_data$ = 32						; size = 4
_xmlAutomataNewOnceTrans PROC				; COMDAT

; 6116 : 			 int min, int max, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6117 :     xmlRegAtomPtr atom;
; 6118 :     int counter;
; 6119 : 
; 6120 :     if ((am == NULL) || (from == NULL) || (token == NULL))

	cmp	DWORD PTR _am$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _from$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _token$[ebp], 0
	jne	SHORT $LN2@xmlAutomat
$LN3@xmlAutomat:

; 6121 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN2@xmlAutomat:

; 6122 :     if (min < 1)

	cmp	DWORD PTR _min$[ebp], 1
	jge	SHORT $LN4@xmlAutomat

; 6123 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN4@xmlAutomat:

; 6124 :     if ((max < min) || (max < 1))

	mov	eax, DWORD PTR _max$[ebp]
	cmp	eax, DWORD PTR _min$[ebp]
	jl	SHORT $LN6@xmlAutomat
	cmp	DWORD PTR _max$[ebp], 1
	jge	SHORT $LN5@xmlAutomat
$LN6@xmlAutomat:

; 6125 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN5@xmlAutomat:

; 6126 :     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);

	push	5
	mov	ecx, DWORD PTR _am$[ebp]
	push	ecx
	call	_xmlRegNewAtom
	add	esp, 8
	mov	DWORD PTR _atom$[ebp], eax

; 6127 :     if (atom == NULL)

	cmp	DWORD PTR _atom$[ebp], 0
	jne	SHORT $LN7@xmlAutomat

; 6128 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN7@xmlAutomat:

; 6129 :     atom->valuep = xmlStrdup(token);

	mov	edx, DWORD PTR _token$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 6130 :     atom->data = data;

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+60], eax

; 6131 :     atom->quant = XML_REGEXP_QUANT_ONCEONLY;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [ecx+8], 6

; 6132 :     atom->min = min;

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR _min$[ebp]
	mov	DWORD PTR [edx+12], eax

; 6133 :     atom->max = max;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 6134 :     /*
; 6135 :      * associate a counter to the transition.
; 6136 :      */
; 6137 :     counter = xmlRegGetCounter(am);

	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlRegGetCounter
	add	esp, 4
	mov	DWORD PTR _counter$[ebp], eax

; 6138 :     am->counters[counter].min = 1;

	mov	ecx, DWORD PTR _am$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _counter$[ebp]
	mov	DWORD PTR [edx+eax*8], 1

; 6139 :     am->counters[counter].max = 1;

	mov	ecx, DWORD PTR _am$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _counter$[ebp]
	mov	DWORD PTR [edx+eax*8+4], 1

; 6140 : 
; 6141 :     /* xmlFAGenerateTransitions(am, from, to, atom); */
; 6142 :     if (to == NULL) {

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN8@xmlAutomat

; 6143 : 	to = xmlRegNewState(am);

	mov	ecx, DWORD PTR _am$[ebp]
	push	ecx
	call	_xmlRegNewState
	add	esp, 4
	mov	DWORD PTR _to$[ebp], eax

; 6144 : 	xmlRegStatePush(am, to);

	mov	edx, DWORD PTR _to$[ebp]
	push	edx
	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlRegStatePush
	add	esp, 8
$LN8@xmlAutomat:

; 6145 :     }
; 6146 :     xmlRegStateAddTrans(am, from, atom, to, counter, -1);

	push	-1
	mov	ecx, DWORD PTR _counter$[ebp]
	push	ecx
	mov	edx, DWORD PTR _to$[ebp]
	push	edx
	mov	eax, DWORD PTR _atom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	mov	edx, DWORD PTR _am$[ebp]
	push	edx
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H

; 6147 :     xmlRegAtomPush(am, atom);

	mov	eax, DWORD PTR _atom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _am$[ebp]
	push	ecx
	call	_xmlRegAtomPush
	add	esp, 8

; 6148 :     am->state = to;

	mov	edx, DWORD PTR _am$[ebp]
	mov	eax, DWORD PTR _to$[ebp]
	mov	DWORD PTR [edx+24], eax

; 6149 :     return(to);

	mov	eax, DWORD PTR _to$[ebp]
$LN1@xmlAutomat:

; 6150 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAutomataNewOnceTrans ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewCountTrans2
_TEXT	SEGMENT
tv85 = -52						; size = 4
tv211 = -45						; size = 1
tv208 = -44						; size = 4
tv205 = -40						; size = 4
tv82 = -36						; size = 4
tv199 = -29						; size = 1
tv196 = -28						; size = 4
tv193 = -24						; size = 4
_str$1 = -20						; size = 4
_lenp$2 = -16						; size = 4
_lenn$3 = -12						; size = 4
_counter$ = -8						; size = 4
_atom$ = -4						; size = 4
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_token$ = 20						; size = 4
_token2$ = 24						; size = 4
_min$ = 28						; size = 4
_max$ = 32						; size = 4
_data$ = 36						; size = 4
_xmlAutomataNewCountTrans2 PROC				; COMDAT

; 5882 : 			 int min, int max, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5883 :     xmlRegAtomPtr atom;
; 5884 :     int counter;
; 5885 : 
; 5886 :     if ((am == NULL) || (from == NULL) || (token == NULL))

	cmp	DWORD PTR _am$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _from$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _token$[ebp], 0
	jne	SHORT $LN2@xmlAutomat
$LN3@xmlAutomat:

; 5887 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN2@xmlAutomat:

; 5888 :     if (min < 0)

	cmp	DWORD PTR _min$[ebp], 0
	jge	SHORT $LN4@xmlAutomat

; 5889 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN4@xmlAutomat:

; 5890 :     if ((max < min) || (max < 1))

	mov	eax, DWORD PTR _max$[ebp]
	cmp	eax, DWORD PTR _min$[ebp]
	jl	SHORT $LN6@xmlAutomat
	cmp	DWORD PTR _max$[ebp], 1
	jge	SHORT $LN5@xmlAutomat
$LN6@xmlAutomat:

; 5891 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN5@xmlAutomat:

; 5892 :     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);

	push	5
	mov	ecx, DWORD PTR _am$[ebp]
	push	ecx
	call	_xmlRegNewAtom
	add	esp, 8
	mov	DWORD PTR _atom$[ebp], eax

; 5893 :     if (atom == NULL)

	cmp	DWORD PTR _atom$[ebp], 0
	jne	SHORT $LN7@xmlAutomat

; 5894 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN7@xmlAutomat:

; 5895 :     if ((token2 == NULL) || (*token2 == 0)) {

	cmp	DWORD PTR _token2$[ebp], 0
	je	SHORT $LN10@xmlAutomat
	mov	edx, DWORD PTR _token2$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN8@xmlAutomat
$LN10@xmlAutomat:

; 5896 : 	atom->valuep = xmlStrdup(token);

	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [edx+20], eax

; 5897 :     } else {

	jmp	$LN9@xmlAutomat
$LN8@xmlAutomat:

; 5898 : 	int lenn, lenp;
; 5899 : 	xmlChar *str;
; 5900 : 
; 5901 : 	lenn = strlen((char *) token2);

	mov	eax, DWORD PTR _token2$[ebp]
	mov	DWORD PTR tv193[ebp], eax
	mov	ecx, DWORD PTR tv193[ebp]
	add	ecx, 1
	mov	DWORD PTR tv196[ebp], ecx
$LL19@xmlAutomat:
	mov	edx, DWORD PTR tv193[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv199[ebp], al
	add	DWORD PTR tv193[ebp], 1
	cmp	BYTE PTR tv199[ebp], 0
	jne	SHORT $LL19@xmlAutomat
	mov	ecx, DWORD PTR tv193[ebp]
	sub	ecx, DWORD PTR tv196[ebp]
	mov	DWORD PTR tv82[ebp], ecx
	mov	edx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _lenn$3[ebp], edx

; 5902 : 	lenp = strlen((char *) token);

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR tv205[ebp], eax
	mov	ecx, DWORD PTR tv205[ebp]
	add	ecx, 1
	mov	DWORD PTR tv208[ebp], ecx
$LL20@xmlAutomat:
	mov	edx, DWORD PTR tv205[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv211[ebp], al
	add	DWORD PTR tv205[ebp], 1
	cmp	BYTE PTR tv211[ebp], 0
	jne	SHORT $LL20@xmlAutomat
	mov	ecx, DWORD PTR tv205[ebp]
	sub	ecx, DWORD PTR tv208[ebp]
	mov	DWORD PTR tv85[ebp], ecx
	mov	edx, DWORD PTR tv85[ebp]
	mov	DWORD PTR _lenp$2[ebp], edx

; 5903 : 
; 5904 : 	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);

	mov	eax, DWORD PTR _lenp$2[ebp]
	mov	ecx, DWORD PTR _lenn$3[ebp]
	lea	edx, DWORD PTR [ecx+eax+2]
	mov	esi, esp
	push	edx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _str$1[ebp], eax

; 5905 : 	if (str == NULL) {

	cmp	DWORD PTR _str$1[ebp], 0
	jne	SHORT $LN11@xmlAutomat

; 5906 : 	    xmlRegFreeAtom(atom);

	mov	eax, DWORD PTR _atom$[ebp]
	push	eax
	call	_xmlRegFreeAtom
	add	esp, 4

; 5907 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN11@xmlAutomat:

; 5908 : 	}
; 5909 : 	memcpy(&str[0], token, lenp);

	mov	ecx, DWORD PTR _lenp$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _token$[ebp]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _str$1[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5910 : 	str[lenp] = '|';

	mov	edx, DWORD PTR _str$1[ebp]
	add	edx, DWORD PTR _lenp$2[ebp]
	mov	BYTE PTR [edx], 124			; 0000007cH

; 5911 : 	memcpy(&str[lenp + 1], token2, lenn);

	mov	eax, DWORD PTR _lenn$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _token2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lenp$2[ebp]
	mov	eax, DWORD PTR _str$1[ebp]
	lea	ecx, DWORD PTR [eax+edx+1]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5912 : 	str[lenn + lenp + 1] = 0;

	mov	edx, DWORD PTR _lenn$3[ebp]
	add	edx, DWORD PTR _lenp$2[ebp]
	mov	eax, DWORD PTR _str$1[ebp]
	mov	BYTE PTR [eax+edx+1], 0

; 5913 : 
; 5914 : 	atom->valuep = str;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR _str$1[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN9@xmlAutomat:

; 5915 :     }
; 5916 :     atom->data = data;

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+60], ecx

; 5917 :     if (min == 0)

	cmp	DWORD PTR _min$[ebp], 0
	jne	SHORT $LN12@xmlAutomat

; 5918 : 	atom->min = 1;

	mov	edx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [edx+12], 1
	jmp	SHORT $LN13@xmlAutomat
$LN12@xmlAutomat:

; 5919 :     else
; 5920 : 	atom->min = min;

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR _min$[ebp]
	mov	DWORD PTR [eax+12], ecx
$LN13@xmlAutomat:

; 5921 :     atom->max = max;

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR _max$[ebp]
	mov	DWORD PTR [edx+16], eax

; 5922 : 
; 5923 :     /*
; 5924 :      * associate a counter to the transition.
; 5925 :      */
; 5926 :     counter = xmlRegGetCounter(am);

	mov	ecx, DWORD PTR _am$[ebp]
	push	ecx
	call	_xmlRegGetCounter
	add	esp, 4
	mov	DWORD PTR _counter$[ebp], eax

; 5927 :     am->counters[counter].min = min;

	mov	edx, DWORD PTR _am$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	ecx, DWORD PTR _counter$[ebp]
	mov	edx, DWORD PTR _min$[ebp]
	mov	DWORD PTR [eax+ecx*8], edx

; 5928 :     am->counters[counter].max = max;

	mov	eax, DWORD PTR _am$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _counter$[ebp]
	mov	eax, DWORD PTR _max$[ebp]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 5929 : 
; 5930 :     /* xmlFAGenerateTransitions(am, from, to, atom); */
; 5931 :     if (to == NULL) {

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN14@xmlAutomat

; 5932 :         to = xmlRegNewState(am);

	mov	ecx, DWORD PTR _am$[ebp]
	push	ecx
	call	_xmlRegNewState
	add	esp, 4
	mov	DWORD PTR _to$[ebp], eax

; 5933 : 	xmlRegStatePush(am, to);

	mov	edx, DWORD PTR _to$[ebp]
	push	edx
	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlRegStatePush
	add	esp, 8
$LN14@xmlAutomat:

; 5934 :     }
; 5935 :     xmlRegStateAddTrans(am, from, atom, to, counter, -1);

	push	-1
	mov	ecx, DWORD PTR _counter$[ebp]
	push	ecx
	mov	edx, DWORD PTR _to$[ebp]
	push	edx
	mov	eax, DWORD PTR _atom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	mov	edx, DWORD PTR _am$[ebp]
	push	edx
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H

; 5936 :     xmlRegAtomPush(am, atom);

	mov	eax, DWORD PTR _atom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _am$[ebp]
	push	ecx
	call	_xmlRegAtomPush
	add	esp, 8

; 5937 :     am->state = to;

	mov	edx, DWORD PTR _am$[ebp]
	mov	eax, DWORD PTR _to$[ebp]
	mov	DWORD PTR [edx+24], eax

; 5938 : 
; 5939 :     if (to == NULL)

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN15@xmlAutomat

; 5940 : 	to = am->state;

	mov	ecx, DWORD PTR _am$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _to$[ebp], edx
$LN15@xmlAutomat:

; 5941 :     if (to == NULL)

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN16@xmlAutomat

; 5942 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAutomat
$LN16@xmlAutomat:

; 5943 :     if (min == 0)

	cmp	DWORD PTR _min$[ebp], 0
	jne	SHORT $LN17@xmlAutomat

; 5944 : 	xmlFAGenerateEpsilonTransition(am, from, to);

	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	mov	edx, DWORD PTR _am$[ebp]
	push	edx
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH
$LN17@xmlAutomat:

; 5945 :     return(to);

	mov	eax, DWORD PTR _to$[ebp]
$LN1@xmlAutomat:

; 5946 : }

	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAutomataNewCountTrans2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewCountTrans
_TEXT	SEGMENT
_counter$ = -8						; size = 4
_atom$ = -4						; size = 4
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_token$ = 20						; size = 4
_min$ = 24						; size = 4
_max$ = 28						; size = 4
_data$ = 32						; size = 4
_xmlAutomataNewCountTrans PROC				; COMDAT

; 5968 : 			 int min, int max, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5969 :     xmlRegAtomPtr atom;
; 5970 :     int counter;
; 5971 : 
; 5972 :     if ((am == NULL) || (from == NULL) || (token == NULL))

	cmp	DWORD PTR _am$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _from$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _token$[ebp], 0
	jne	SHORT $LN2@xmlAutomat
$LN3@xmlAutomat:

; 5973 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN2@xmlAutomat:

; 5974 :     if (min < 0)

	cmp	DWORD PTR _min$[ebp], 0
	jge	SHORT $LN4@xmlAutomat

; 5975 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN4@xmlAutomat:

; 5976 :     if ((max < min) || (max < 1))

	mov	eax, DWORD PTR _max$[ebp]
	cmp	eax, DWORD PTR _min$[ebp]
	jl	SHORT $LN6@xmlAutomat
	cmp	DWORD PTR _max$[ebp], 1
	jge	SHORT $LN5@xmlAutomat
$LN6@xmlAutomat:

; 5977 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN5@xmlAutomat:

; 5978 :     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);

	push	5
	mov	ecx, DWORD PTR _am$[ebp]
	push	ecx
	call	_xmlRegNewAtom
	add	esp, 8
	mov	DWORD PTR _atom$[ebp], eax

; 5979 :     if (atom == NULL)

	cmp	DWORD PTR _atom$[ebp], 0
	jne	SHORT $LN7@xmlAutomat

; 5980 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN7@xmlAutomat:

; 5981 :     atom->valuep = xmlStrdup(token);

	mov	edx, DWORD PTR _token$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 5982 :     atom->data = data;

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+60], eax

; 5983 :     if (min == 0)

	cmp	DWORD PTR _min$[ebp], 0
	jne	SHORT $LN8@xmlAutomat

; 5984 : 	atom->min = 1;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [ecx+12], 1
	jmp	SHORT $LN9@xmlAutomat
$LN8@xmlAutomat:

; 5985 :     else
; 5986 : 	atom->min = min;

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR _min$[ebp]
	mov	DWORD PTR [edx+12], eax
$LN9@xmlAutomat:

; 5987 :     atom->max = max;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 5988 : 
; 5989 :     /*
; 5990 :      * associate a counter to the transition.
; 5991 :      */
; 5992 :     counter = xmlRegGetCounter(am);

	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlRegGetCounter
	add	esp, 4
	mov	DWORD PTR _counter$[ebp], eax

; 5993 :     am->counters[counter].min = min;

	mov	ecx, DWORD PTR _am$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _counter$[ebp]
	mov	ecx, DWORD PTR _min$[ebp]
	mov	DWORD PTR [edx+eax*8], ecx

; 5994 :     am->counters[counter].max = max;

	mov	edx, DWORD PTR _am$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	ecx, DWORD PTR _counter$[ebp]
	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [eax+ecx*8+4], edx

; 5995 : 
; 5996 :     /* xmlFAGenerateTransitions(am, from, to, atom); */
; 5997 :     if (to == NULL) {

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN10@xmlAutomat

; 5998 :         to = xmlRegNewState(am);

	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlRegNewState
	add	esp, 4
	mov	DWORD PTR _to$[ebp], eax

; 5999 : 	xmlRegStatePush(am, to);

	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _am$[ebp]
	push	edx
	call	_xmlRegStatePush
	add	esp, 8
$LN10@xmlAutomat:

; 6000 :     }
; 6001 :     xmlRegStateAddTrans(am, from, atom, to, counter, -1);

	push	-1
	mov	eax, DWORD PTR _counter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _atom$[ebp]
	push	edx
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _am$[ebp]
	push	ecx
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H

; 6002 :     xmlRegAtomPush(am, atom);

	mov	edx, DWORD PTR _atom$[ebp]
	push	edx
	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlRegAtomPush
	add	esp, 8

; 6003 :     am->state = to;

	mov	ecx, DWORD PTR _am$[ebp]
	mov	edx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 6004 : 
; 6005 :     if (to == NULL)

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN11@xmlAutomat

; 6006 : 	to = am->state;

	mov	eax, DWORD PTR _am$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _to$[ebp], ecx
$LN11@xmlAutomat:

; 6007 :     if (to == NULL)

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN12@xmlAutomat

; 6008 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAutomat
$LN12@xmlAutomat:

; 6009 :     if (min == 0)

	cmp	DWORD PTR _min$[ebp], 0
	jne	SHORT $LN13@xmlAutomat

; 6010 : 	xmlFAGenerateEpsilonTransition(am, from, to);

	mov	edx, DWORD PTR _to$[ebp]
	push	edx
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _am$[ebp]
	push	ecx
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH
$LN13@xmlAutomat:

; 6011 :     return(to);

	mov	eax, DWORD PTR _to$[ebp]
$LN1@xmlAutomat:

; 6012 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAutomataNewCountTrans ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewNegTrans
_TEXT	SEGMENT
tv84 = -256						; size = 4
tv196 = -249						; size = 1
tv193 = -248						; size = 4
tv190 = -244						; size = 4
tv81 = -240						; size = 4
tv184 = -233						; size = 1
tv181 = -232						; size = 4
tv178 = -228						; size = 4
_str$1 = -224						; size = 4
_lenp$2 = -220						; size = 4
_lenn$3 = -216						; size = 4
_err_msg$ = -208					; size = 200
_atom$ = -4						; size = 4
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_token$ = 20						; size = 4
_token2$ = 24						; size = 4
_data$ = 28						; size = 4
_xmlAutomataNewNegTrans PROC				; COMDAT

; 5814 : 		       const xmlChar *token2, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5815 :     xmlRegAtomPtr atom;
; 5816 :     xmlChar err_msg[200];
; 5817 : 
; 5818 :     if ((am == NULL) || (from == NULL) || (token == NULL))

	cmp	DWORD PTR _am$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _from$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _token$[ebp], 0
	jne	SHORT $LN2@xmlAutomat
$LN3@xmlAutomat:

; 5819 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN2@xmlAutomat:

; 5820 :     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);

	push	5
	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlRegNewAtom
	add	esp, 8
	mov	DWORD PTR _atom$[ebp], eax

; 5821 :     if (atom == NULL)

	cmp	DWORD PTR _atom$[ebp], 0
	jne	SHORT $LN4@xmlAutomat

; 5822 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN4@xmlAutomat:

; 5823 :     atom->data = data;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [ecx+60], edx

; 5824 :     atom->neg = 1;

	mov	eax, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [eax+28], 1

; 5825 :     if ((token2 == NULL) || (*token2 == 0)) {

	cmp	DWORD PTR _token2$[ebp], 0
	je	SHORT $LN7@xmlAutomat
	mov	ecx, DWORD PTR _token2$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN5@xmlAutomat
$LN7@xmlAutomat:

; 5826 : 	atom->valuep = xmlStrdup(token);

	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 5827 :     } else {

	jmp	$LN6@xmlAutomat
$LN5@xmlAutomat:

; 5828 : 	int lenn, lenp;
; 5829 : 	xmlChar *str;
; 5830 : 
; 5831 : 	lenn = strlen((char *) token2);

	mov	edx, DWORD PTR _token2$[ebp]
	mov	DWORD PTR tv178[ebp], edx
	mov	eax, DWORD PTR tv178[ebp]
	add	eax, 1
	mov	DWORD PTR tv181[ebp], eax
$LL12@xmlAutomat:
	mov	ecx, DWORD PTR tv178[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv184[ebp], dl
	add	DWORD PTR tv178[ebp], 1
	cmp	BYTE PTR tv184[ebp], 0
	jne	SHORT $LL12@xmlAutomat
	mov	eax, DWORD PTR tv178[ebp]
	sub	eax, DWORD PTR tv181[ebp]
	mov	DWORD PTR tv81[ebp], eax
	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _lenn$3[ebp], ecx

; 5832 : 	lenp = strlen((char *) token);

	mov	edx, DWORD PTR _token$[ebp]
	mov	DWORD PTR tv190[ebp], edx
	mov	eax, DWORD PTR tv190[ebp]
	add	eax, 1
	mov	DWORD PTR tv193[ebp], eax
$LL13@xmlAutomat:
	mov	ecx, DWORD PTR tv190[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv196[ebp], dl
	add	DWORD PTR tv190[ebp], 1
	cmp	BYTE PTR tv196[ebp], 0
	jne	SHORT $LL13@xmlAutomat
	mov	eax, DWORD PTR tv190[ebp]
	sub	eax, DWORD PTR tv193[ebp]
	mov	DWORD PTR tv84[ebp], eax
	mov	ecx, DWORD PTR tv84[ebp]
	mov	DWORD PTR _lenp$2[ebp], ecx

; 5833 : 
; 5834 : 	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);

	mov	edx, DWORD PTR _lenp$2[ebp]
	mov	eax, DWORD PTR _lenn$3[ebp]
	lea	ecx, DWORD PTR [eax+edx+2]
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _str$1[ebp], eax

; 5835 : 	if (str == NULL) {

	cmp	DWORD PTR _str$1[ebp], 0
	jne	SHORT $LN8@xmlAutomat

; 5836 : 	    xmlRegFreeAtom(atom);

	mov	edx, DWORD PTR _atom$[ebp]
	push	edx
	call	_xmlRegFreeAtom
	add	esp, 4

; 5837 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN8@xmlAutomat:

; 5838 : 	}
; 5839 : 	memcpy(&str[0], token, lenp);

	mov	eax, DWORD PTR _lenp$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 0
	add	eax, DWORD PTR _str$1[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5840 : 	str[lenp] = '|';

	mov	ecx, DWORD PTR _str$1[ebp]
	add	ecx, DWORD PTR _lenp$2[ebp]
	mov	BYTE PTR [ecx], 124			; 0000007cH

; 5841 : 	memcpy(&str[lenp + 1], token2, lenn);

	mov	edx, DWORD PTR _lenn$3[ebp]
	push	edx
	mov	eax, DWORD PTR _token2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lenp$2[ebp]
	mov	edx, DWORD PTR _str$1[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5842 : 	str[lenn + lenp + 1] = 0;

	mov	ecx, DWORD PTR _lenn$3[ebp]
	add	ecx, DWORD PTR _lenp$2[ebp]
	mov	edx, DWORD PTR _str$1[ebp]
	mov	BYTE PTR [edx+ecx+1], 0

; 5843 : 
; 5844 : 	atom->valuep = str;

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR _str$1[ebp]
	mov	DWORD PTR [eax+20], ecx
$LN6@xmlAutomat:

; 5845 :     }
; 5846 :     snprintf((char *) err_msg, 199, "not %s", (const char *) atom->valuep);

	mov	edx, DWORD PTR _atom$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	push	OFFSET ??_C@_06NGEMONLJ@not?5?$CFs@
	push	199					; 000000c7H
	lea	ecx, DWORD PTR _err_msg$[ebp]
	push	ecx
	call	_snprintf
	add	esp, 16					; 00000010H

; 5847 :     err_msg[199] = 0;

	mov	edx, 1
	imul	eax, edx, 199
	mov	BYTE PTR _err_msg$[ebp+eax], 0

; 5848 :     atom->valuep2 = xmlStrdup(err_msg);

	lea	ecx, DWORD PTR _err_msg$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [edx+24], eax

; 5849 : 
; 5850 :     if (xmlFAGenerateTransitions(am, from, to, atom) < 0) {

	mov	eax, DWORD PTR _atom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlFAGenerateTransitions
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN9@xmlAutomat

; 5851 :         xmlRegFreeAtom(atom);

	mov	ecx, DWORD PTR _atom$[ebp]
	push	ecx
	call	_xmlRegFreeAtom
	add	esp, 4

; 5852 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAutomat
$LN9@xmlAutomat:

; 5853 :     }
; 5854 :     am->negs++;

	mov	edx, DWORD PTR _am$[ebp]
	mov	eax, DWORD PTR [edx+72]
	add	eax, 1
	mov	ecx, DWORD PTR _am$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 5855 :     if (to == NULL)

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN10@xmlAutomat

; 5856 : 	return(am->state);

	mov	edx, DWORD PTR _am$[ebp]
	mov	eax, DWORD PTR [edx+24]
	jmp	SHORT $LN1@xmlAutomat
$LN10@xmlAutomat:

; 5857 :     return(to);

	mov	eax, DWORD PTR _to$[ebp]
$LN1@xmlAutomat:

; 5858 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@xmlAutomat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN16@xmlAutomat:
	DD	1
	DD	$LN15@xmlAutomat
$LN15@xmlAutomat:
	DD	-208					; ffffff30H
	DD	200					; 000000c8H
	DD	$LN14@xmlAutomat
$LN14@xmlAutomat:
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	115					; 00000073H
	DB	103					; 00000067H
	DB	0
_xmlAutomataNewNegTrans ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewTransition2
_TEXT	SEGMENT
tv83 = -48						; size = 4
tv179 = -41						; size = 1
tv176 = -40						; size = 4
tv173 = -36						; size = 4
tv80 = -32						; size = 4
tv167 = -25						; size = 1
tv164 = -24						; size = 4
tv161 = -20						; size = 4
_str$1 = -16						; size = 4
_lenp$2 = -12						; size = 4
_lenn$3 = -8						; size = 4
_atom$ = -4						; size = 4
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_token$ = 20						; size = 4
_token2$ = 24						; size = 4
_data$ = 28						; size = 4
_xmlAutomataNewTransition2 PROC				; COMDAT

; 5754 : 			  const xmlChar *token2, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5755 :     xmlRegAtomPtr atom;
; 5756 : 
; 5757 :     if ((am == NULL) || (from == NULL) || (token == NULL))

	cmp	DWORD PTR _am$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _from$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _token$[ebp], 0
	jne	SHORT $LN2@xmlAutomat
$LN3@xmlAutomat:

; 5758 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN2@xmlAutomat:

; 5759 :     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);

	push	5
	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlRegNewAtom
	add	esp, 8
	mov	DWORD PTR _atom$[ebp], eax

; 5760 :     if (atom == NULL)

	cmp	DWORD PTR _atom$[ebp], 0
	jne	SHORT $LN4@xmlAutomat

; 5761 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN4@xmlAutomat:

; 5762 :     atom->data = data;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [ecx+60], edx

; 5763 :     if ((token2 == NULL) || (*token2 == 0)) {

	cmp	DWORD PTR _token2$[ebp], 0
	je	SHORT $LN7@xmlAutomat
	mov	eax, DWORD PTR _token2$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@xmlAutomat
$LN7@xmlAutomat:

; 5764 : 	atom->valuep = xmlStrdup(token);

	mov	edx, DWORD PTR _token$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 5765 :     } else {

	jmp	$LN6@xmlAutomat
$LN5@xmlAutomat:

; 5766 : 	int lenn, lenp;
; 5767 : 	xmlChar *str;
; 5768 : 
; 5769 : 	lenn = strlen((char *) token2);

	mov	edx, DWORD PTR _token2$[ebp]
	mov	DWORD PTR tv161[ebp], edx
	mov	eax, DWORD PTR tv161[ebp]
	add	eax, 1
	mov	DWORD PTR tv164[ebp], eax
$LL12@xmlAutomat:
	mov	ecx, DWORD PTR tv161[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv167[ebp], dl
	add	DWORD PTR tv161[ebp], 1
	cmp	BYTE PTR tv167[ebp], 0
	jne	SHORT $LL12@xmlAutomat
	mov	eax, DWORD PTR tv161[ebp]
	sub	eax, DWORD PTR tv164[ebp]
	mov	DWORD PTR tv80[ebp], eax
	mov	ecx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _lenn$3[ebp], ecx

; 5770 : 	lenp = strlen((char *) token);

	mov	edx, DWORD PTR _token$[ebp]
	mov	DWORD PTR tv173[ebp], edx
	mov	eax, DWORD PTR tv173[ebp]
	add	eax, 1
	mov	DWORD PTR tv176[ebp], eax
$LL13@xmlAutomat:
	mov	ecx, DWORD PTR tv173[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv179[ebp], dl
	add	DWORD PTR tv173[ebp], 1
	cmp	BYTE PTR tv179[ebp], 0
	jne	SHORT $LL13@xmlAutomat
	mov	eax, DWORD PTR tv173[ebp]
	sub	eax, DWORD PTR tv176[ebp]
	mov	DWORD PTR tv83[ebp], eax
	mov	ecx, DWORD PTR tv83[ebp]
	mov	DWORD PTR _lenp$2[ebp], ecx

; 5771 : 
; 5772 : 	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);

	mov	edx, DWORD PTR _lenp$2[ebp]
	mov	eax, DWORD PTR _lenn$3[ebp]
	lea	ecx, DWORD PTR [eax+edx+2]
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _str$1[ebp], eax

; 5773 : 	if (str == NULL) {

	cmp	DWORD PTR _str$1[ebp], 0
	jne	SHORT $LN8@xmlAutomat

; 5774 : 	    xmlRegFreeAtom(atom);

	mov	edx, DWORD PTR _atom$[ebp]
	push	edx
	call	_xmlRegFreeAtom
	add	esp, 4

; 5775 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAutomat
$LN8@xmlAutomat:

; 5776 : 	}
; 5777 : 	memcpy(&str[0], token, lenp);

	mov	eax, DWORD PTR _lenp$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 0
	add	eax, DWORD PTR _str$1[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5778 : 	str[lenp] = '|';

	mov	ecx, DWORD PTR _str$1[ebp]
	add	ecx, DWORD PTR _lenp$2[ebp]
	mov	BYTE PTR [ecx], 124			; 0000007cH

; 5779 : 	memcpy(&str[lenp + 1], token2, lenn);

	mov	edx, DWORD PTR _lenn$3[ebp]
	push	edx
	mov	eax, DWORD PTR _token2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lenp$2[ebp]
	mov	edx, DWORD PTR _str$1[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5780 : 	str[lenn + lenp + 1] = 0;

	mov	ecx, DWORD PTR _lenn$3[ebp]
	add	ecx, DWORD PTR _lenp$2[ebp]
	mov	edx, DWORD PTR _str$1[ebp]
	mov	BYTE PTR [edx+ecx+1], 0

; 5781 : 
; 5782 : 	atom->valuep = str;

	mov	eax, DWORD PTR _atom$[ebp]
	mov	ecx, DWORD PTR _str$1[ebp]
	mov	DWORD PTR [eax+20], ecx
$LN6@xmlAutomat:

; 5783 :     }
; 5784 : 
; 5785 :     if (xmlFAGenerateTransitions(am, from, to, atom) < 0) {

	mov	edx, DWORD PTR _atom$[ebp]
	push	edx
	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	mov	edx, DWORD PTR _am$[ebp]
	push	edx
	call	_xmlFAGenerateTransitions
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN9@xmlAutomat

; 5786 :         xmlRegFreeAtom(atom);

	mov	eax, DWORD PTR _atom$[ebp]
	push	eax
	call	_xmlRegFreeAtom
	add	esp, 4

; 5787 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAutomat
$LN9@xmlAutomat:

; 5788 :     }
; 5789 :     if (to == NULL)

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN10@xmlAutomat

; 5790 : 	return(am->state);

	mov	ecx, DWORD PTR _am$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	jmp	SHORT $LN1@xmlAutomat
$LN10@xmlAutomat:

; 5791 :     return(to);

	mov	eax, DWORD PTR _to$[ebp]
$LN1@xmlAutomat:

; 5792 : }

	pop	edi
	pop	esi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAutomataNewTransition2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewTransition
_TEXT	SEGMENT
_atom$ = -4						; size = 4
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_token$ = 20						; size = 4
_data$ = 24						; size = 4
_xmlAutomataNewTransition PROC				; COMDAT

; 5716 : 			 void *data) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5717 :     xmlRegAtomPtr atom;
; 5718 : 
; 5719 :     if ((am == NULL) || (from == NULL) || (token == NULL))

	cmp	DWORD PTR _am$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _from$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _token$[ebp], 0
	jne	SHORT $LN2@xmlAutomat
$LN3@xmlAutomat:

; 5720 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAutomat
$LN2@xmlAutomat:

; 5721 :     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);

	push	5
	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlRegNewAtom
	add	esp, 8
	mov	DWORD PTR _atom$[ebp], eax

; 5722 :     if (atom == NULL)

	cmp	DWORD PTR _atom$[ebp], 0
	jne	SHORT $LN4@xmlAutomat

; 5723 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAutomat
$LN4@xmlAutomat:

; 5724 :     atom->data = data;

	mov	ecx, DWORD PTR _atom$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [ecx+60], edx

; 5725 :     atom->valuep = xmlStrdup(token);

	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 5726 : 
; 5727 :     if (xmlFAGenerateTransitions(am, from, to, atom) < 0) {

	mov	edx, DWORD PTR _atom$[ebp]
	push	edx
	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	mov	edx, DWORD PTR _am$[ebp]
	push	edx
	call	_xmlFAGenerateTransitions
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN5@xmlAutomat

; 5728 :         xmlRegFreeAtom(atom);

	mov	eax, DWORD PTR _atom$[ebp]
	push	eax
	call	_xmlRegFreeAtom
	add	esp, 4

; 5729 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAutomat
$LN5@xmlAutomat:

; 5730 :     }
; 5731 :     if (to == NULL)

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN6@xmlAutomat

; 5732 : 	return(am->state);

	mov	ecx, DWORD PTR _am$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	jmp	SHORT $LN1@xmlAutomat
$LN6@xmlAutomat:

; 5733 :     return(to);

	mov	eax, DWORD PTR _to$[ebp]
$LN1@xmlAutomat:

; 5734 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAutomataNewTransition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewState
_TEXT	SEGMENT
_to$ = -4						; size = 4
_am$ = 8						; size = 4
_xmlAutomataNewState PROC				; COMDAT

; 6161 : xmlAutomataNewState(xmlAutomataPtr am) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6162 :     xmlAutomataStatePtr to;
; 6163 : 
; 6164 :     if (am == NULL)

	cmp	DWORD PTR _am$[ebp], 0
	jne	SHORT $LN2@xmlAutomat

; 6165 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAutomat
$LN2@xmlAutomat:

; 6166 :     to = xmlRegNewState(am);

	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlRegNewState
	add	esp, 4
	mov	DWORD PTR _to$[ebp], eax

; 6167 :     xmlRegStatePush(am, to);

	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _am$[ebp]
	push	edx
	call	_xmlRegStatePush
	add	esp, 8

; 6168 :     return(to);

	mov	eax, DWORD PTR _to$[ebp]
$LN1@xmlAutomat:

; 6169 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAutomataNewState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataSetFinalState
_TEXT	SEGMENT
_am$ = 8						; size = 4
_state$ = 12						; size = 4
_xmlAutomataSetFinalState PROC				; COMDAT

; 5692 : xmlAutomataSetFinalState(xmlAutomataPtr am, xmlAutomataStatePtr state) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5693 :     if ((am == NULL) || (state == NULL))

	cmp	DWORD PTR _am$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _state$[ebp], 0
	jne	SHORT $LN2@xmlAutomat
$LN3@xmlAutomat:

; 5694 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlAutomat
$LN2@xmlAutomat:

; 5695 :     state->type = XML_REGEXP_FINAL_STATE;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax], 2

; 5696 :     return(0);

	xor	eax, eax
$LN1@xmlAutomat:

; 5697 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlAutomataSetFinalState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataGetInitState
_TEXT	SEGMENT
_am$ = 8						; size = 4
_xmlAutomataGetInitState PROC				; COMDAT

; 5676 : xmlAutomataGetInitState(xmlAutomataPtr am) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5677 :     if (am == NULL)

	cmp	DWORD PTR _am$[ebp], 0
	jne	SHORT $LN2@xmlAutomat

; 5678 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAutomat
$LN2@xmlAutomat:

; 5679 :     return(am->start);

	mov	eax, DWORD PTR _am$[ebp]
	mov	eax, DWORD PTR [eax+16]
$LN1@xmlAutomat:

; 5680 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlAutomataGetInitState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFreeAutomata
_TEXT	SEGMENT
_am$ = 8						; size = 4
_xmlFreeAutomata PROC					; COMDAT

; 5647 : xmlFreeAutomata(xmlAutomataPtr am) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5648 :     if (am == NULL)

	cmp	DWORD PTR _am$[ebp], 0
	jne	SHORT $LN2@xmlFreeAut

; 5649 : 	return;

	jmp	SHORT $LN1@xmlFreeAut
$LN2@xmlFreeAut:

; 5650 :     xmlRegFreeParserCtxt(am);

	mov	eax, DWORD PTR _am$[ebp]
	push	eax
	call	_xmlRegFreeParserCtxt
	add	esp, 4
$LN1@xmlFreeAut:

; 5651 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFreeAutomata ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlNewAutomata
_TEXT	SEGMENT
tv70 = -8						; size = 4
_ctxt$ = -4						; size = 4
_xmlNewAutomata PROC					; COMDAT

; 5615 : xmlNewAutomata(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5616 :     xmlAutomataPtr ctxt;
; 5617 : 
; 5618 :     ctxt = xmlRegNewParserCtxt(NULL);

	push	0
	call	_xmlRegNewParserCtxt
	add	esp, 4
	mov	DWORD PTR _ctxt$[ebp], eax

; 5619 :     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlNewAuto

; 5620 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNewAuto
$LN2@xmlNewAuto:

; 5621 : 
; 5622 :     /* initialize the parser */
; 5623 :     ctxt->end = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+20], 0

; 5624 :     ctxt->start = ctxt->state = xmlRegNewState(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegNewState
	add	esp, 4
	mov	DWORD PTR tv70[ebp], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR tv70[ebp]
	mov	DWORD PTR [edx+24], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR tv70[ebp]
	mov	DWORD PTR [ecx+16], edx

; 5625 :     if (ctxt->start == NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN3@xmlNewAuto

; 5626 : 	xmlFreeAutomata(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFreeAutomata
	add	esp, 4

; 5627 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNewAuto
$LN3@xmlNewAuto:

; 5628 :     }
; 5629 :     ctxt->start->type = XML_REGEXP_START_STATE;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [eax], 1

; 5630 :     if (xmlRegStatePush(ctxt, ctxt->start) < 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegStatePush
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN4@xmlNewAuto

; 5631 :         xmlRegFreeState(ctxt->start);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlRegFreeState
	add	esp, 4

; 5632 : 	xmlFreeAutomata(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFreeAutomata
	add	esp, 4

; 5633 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNewAuto
$LN4@xmlNewAuto:

; 5634 :     }
; 5635 :     ctxt->flags = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+76], 0

; 5636 : 
; 5637 :     return(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
$LN1@xmlNewAuto:

; 5638 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNewAutomata ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpDump
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_expr$ = 12						; size = 4
_xmlExpDump PROC					; COMDAT

; 8126 : xmlExpDump(xmlBufferPtr buf, xmlExpNodePtr expr) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 8127 :     if ((buf == NULL) || (expr == NULL))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlExpDump
	cmp	DWORD PTR _expr$[ebp], 0
	jne	SHORT $LN2@xmlExpDump
$LN3@xmlExpDump:

; 8128 :         return;

	jmp	SHORT $LN1@xmlExpDump
$LN2@xmlExpDump:

; 8129 :     xmlExpDumpInt(buf, expr, 0);

	push	0
	mov	eax, DWORD PTR _expr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlExpDumpInt
	add	esp, 12					; 0000000cH
$LN1@xmlExpDump:

; 8130 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlExpDump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpSubsume
_TEXT	SEGMENT
_tmp$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_sub$ = 16						; size = 4
_xmlExpSubsume PROC					; COMDAT

; 7814 : xmlExpSubsume(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp, xmlExpNodePtr sub) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 7815 :     xmlExpNodePtr tmp;
; 7816 : 
; 7817 :     if ((exp == NULL) || (ctxt == NULL) || (sub == NULL))

	cmp	DWORD PTR _exp$[ebp], 0
	je	SHORT $LN3@xmlExpSubs
	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlExpSubs
	cmp	DWORD PTR _sub$[ebp], 0
	jne	SHORT $LN2@xmlExpSubs
$LN3@xmlExpSubs:

; 7818 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlExpSubs
$LN2@xmlExpSubs:

; 7819 : 
; 7820 :     /*
; 7821 :      * TODO: speedup by checking the language of sub is a subset of the
; 7822 :      *       language of exp
; 7823 :      */
; 7824 :     /*
; 7825 :      * O(1) speedups
; 7826 :      */
; 7827 :     if (IS_NILLABLE(sub) && (!IS_NILLABLE(exp))) {

	mov	eax, DWORD PTR _sub$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	and	ecx, 1
	je	SHORT $LN4@xmlExpSubs
	mov	edx, DWORD PTR _exp$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	and	eax, 1
	jne	SHORT $LN4@xmlExpSubs

; 7828 : #ifdef DEBUG_DERIV
; 7829 : 	printf("Sub nillable and not exp : can't subsume\n");
; 7830 : #endif
; 7831 :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlExpSubs
$LN4@xmlExpSubs:

; 7832 :     }
; 7833 :     if (xmlExpCheckCard(exp, sub) == 0) {

	mov	ecx, DWORD PTR _sub$[ebp]
	push	ecx
	mov	edx, DWORD PTR _exp$[ebp]
	push	edx
	call	_xmlExpCheckCard
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@xmlExpSubs

; 7834 : #ifdef DEBUG_DERIV
; 7835 : 	printf("sub generate longuer sequances than exp : can't subsume\n");
; 7836 : #endif
; 7837 :         return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpSubs
$LN5@xmlExpSubs:

; 7838 :     }
; 7839 :     tmp = xmlExpExpDeriveInt(ctxt, exp, sub);

	mov	eax, DWORD PTR _sub$[ebp]
	push	eax
	mov	ecx, DWORD PTR _exp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp$[ebp], eax

; 7840 : #ifdef DEBUG_DERIV
; 7841 :     printf("Result derivation :\n");
; 7842 :     PRINT_EXP(tmp);
; 7843 : #endif
; 7844 :     if (tmp == NULL)

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN6@xmlExpSubs

; 7845 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlExpSubs
$LN6@xmlExpSubs:

; 7846 :     if (tmp == forbiddenExp)

	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	eax, DWORD PTR _forbiddenExp
	jne	SHORT $LN7@xmlExpSubs

; 7847 : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpSubs
$LN7@xmlExpSubs:

; 7848 :     if (tmp == emptyExp)

	mov	ecx, DWORD PTR _tmp$[ebp]
	cmp	ecx, DWORD PTR _emptyExp
	jne	SHORT $LN8@xmlExpSubs

; 7849 : 	return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlExpSubs
$LN8@xmlExpSubs:

; 7850 :     if ((tmp != NULL) && (IS_NILLABLE(tmp))) {

	cmp	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN9@xmlExpSubs
	mov	edx, DWORD PTR _tmp$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	and	eax, 1
	je	SHORT $LN9@xmlExpSubs

; 7851 :         xmlExpFree(ctxt, tmp);

	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpFree
	add	esp, 8

; 7852 :         return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlExpSubs
$LN9@xmlExpSubs:

; 7853 :     }
; 7854 :     xmlExpFree(ctxt, tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8

; 7855 :     return(0);

	xor	eax, eax
$LN1@xmlExpSubs:

; 7856 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpSubsume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpExpDerive
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_sub$ = 16						; size = 4
_xmlExpExpDerive PROC					; COMDAT

; 7780 : xmlExpExpDerive(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp, xmlExpNodePtr sub) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 7781 :     if ((exp == NULL) || (ctxt == NULL) || (sub == NULL))

	cmp	DWORD PTR _exp$[ebp], 0
	je	SHORT $LN3@xmlExpExpD
	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlExpExpD
	cmp	DWORD PTR _sub$[ebp], 0
	jne	SHORT $LN2@xmlExpExpD
$LN3@xmlExpExpD:

; 7782 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpExpD
$LN2@xmlExpExpD:

; 7783 : 
; 7784 :     /*
; 7785 :      * O(1) speedups
; 7786 :      */
; 7787 :     if (IS_NILLABLE(sub) && (!IS_NILLABLE(exp))) {

	mov	eax, DWORD PTR _sub$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	and	ecx, 1
	je	SHORT $LN4@xmlExpExpD
	mov	edx, DWORD PTR _exp$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	and	eax, 1
	jne	SHORT $LN4@xmlExpExpD

; 7788 : #ifdef DEBUG_DERIV
; 7789 : 	printf("Sub nillable and not exp : can't subsume\n");
; 7790 : #endif
; 7791 :         return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	SHORT $LN1@xmlExpExpD
$LN4@xmlExpExpD:

; 7792 :     }
; 7793 :     if (xmlExpCheckCard(exp, sub) == 0) {

	mov	ecx, DWORD PTR _sub$[ebp]
	push	ecx
	mov	edx, DWORD PTR _exp$[ebp]
	push	edx
	call	_xmlExpCheckCard
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@xmlExpExpD

; 7794 : #ifdef DEBUG_DERIV
; 7795 : 	printf("sub generate longuer sequances than exp : can't subsume\n");
; 7796 : #endif
; 7797 :         return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	SHORT $LN1@xmlExpExpD
$LN5@xmlExpExpD:

; 7798 :     }
; 7799 :     return(xmlExpExpDeriveInt(ctxt, exp, sub));

	mov	eax, DWORD PTR _sub$[ebp]
	push	eax
	mov	ecx, DWORD PTR _exp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
$LN1@xmlExpExpD:

; 7800 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlExpExpDerive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpStringDerive
_TEXT	SEGMENT
_input$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_str$ = 16						; size = 4
_len$ = 20						; size = 4
_xmlExpStringDerive PROC				; COMDAT

; 7213 :                    const xmlChar *str, int len) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 7214 :     const xmlChar *input;
; 7215 : 
; 7216 :     if ((exp == NULL) || (ctxt == NULL) || (str == NULL)) {

	cmp	DWORD PTR _exp$[ebp], 0
	je	SHORT $LN3@xmlExpStri
	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlExpStri
	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN2@xmlExpStri
$LN3@xmlExpStri:

; 7217 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpStri
$LN2@xmlExpStri:

; 7218 :     }
; 7219 :     /*
; 7220 :      * check the string is in the dictionary, if yes use an interned
; 7221 :      * copy, otherwise we know it's not an acceptable input
; 7222 :      */
; 7223 :     input = xmlDictExists(ctxt->dict, str, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_xmlDictExists
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _input$[ebp], eax

; 7224 :     if (input == NULL) {

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN4@xmlExpStri

; 7225 :         return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	jmp	SHORT $LN1@xmlExpStri
$LN4@xmlExpStri:

; 7226 :     }
; 7227 :     return(xmlExpStringDeriveInt(ctxt, exp, input));

	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	mov	edx, DWORD PTR _exp$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpStringDeriveInt
	add	esp, 12					; 0000000cH
$LN1@xmlExpStri:

; 7228 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpStringDerive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpGetStart
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_tokList$ = 16						; size = 4
_len$ = 20						; size = 4
_xmlExpGetStart PROC					; COMDAT

; 7068 :                const xmlChar**tokList, int len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 7069 :     if ((ctxt == NULL) || (exp == NULL) || (tokList == NULL) || (len <= 0))

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlExpGetS
	cmp	DWORD PTR _exp$[ebp], 0
	je	SHORT $LN3@xmlExpGetS
	cmp	DWORD PTR _tokList$[ebp], 0
	je	SHORT $LN3@xmlExpGetS
	cmp	DWORD PTR _len$[ebp], 0
	jg	SHORT $LN2@xmlExpGetS
$LN3@xmlExpGetS:

; 7070 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlExpGetS
$LN2@xmlExpGetS:

; 7071 :     return(xmlExpGetStartInt(ctxt, exp, tokList, len, 0));

	push	0
	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tokList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _exp$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpGetStartInt
	add	esp, 20					; 00000014H
$LN1@xmlExpGetS:

; 7072 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlExpGetStart ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpGetLanguage
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_langList$ = 16						; size = 4
_len$ = 20						; size = 4
_xmlExpGetLanguage PROC					; COMDAT

; 7000 :                   const xmlChar**langList, int len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 7001 :     if ((ctxt == NULL) || (exp == NULL) || (langList == NULL) || (len <= 0))

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlExpGetL
	cmp	DWORD PTR _exp$[ebp], 0
	je	SHORT $LN3@xmlExpGetL
	cmp	DWORD PTR _langList$[ebp], 0
	je	SHORT $LN3@xmlExpGetL
	cmp	DWORD PTR _len$[ebp], 0
	jg	SHORT $LN2@xmlExpGetL
$LN3@xmlExpGetL:

; 7002 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlExpGetL
$LN2@xmlExpGetL:

; 7003 :     return(xmlExpGetLanguageInt(ctxt, exp, langList, len, 0));

	push	0
	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _langList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _exp$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpGetLanguageInt
	add	esp, 20					; 00000014H
$LN1@xmlExpGetL:

; 7004 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlExpGetLanguage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpMaxToken
_TEXT	SEGMENT
_expr$ = 8						; size = 4
_xmlExpMaxToken PROC					; COMDAT

; 8141 : xmlExpMaxToken(xmlExpNodePtr expr) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 8142 :     if (expr == NULL)

	cmp	DWORD PTR _expr$[ebp], 0
	jne	SHORT $LN2@xmlExpMaxT

; 8143 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlExpMaxT
$LN2@xmlExpMaxT:

; 8144 :     return(expr->c_max);

	mov	eax, DWORD PTR _expr$[ebp]
	mov	eax, DWORD PTR [eax+8]
$LN1@xmlExpMaxT:

; 8145 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlExpMaxToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpIsNillable
_TEXT	SEGMENT
tv69 = -4						; size = 4
_exp$ = 8						; size = 4
_xmlExpIsNillable PROC					; COMDAT

; 7083 : xmlExpIsNillable(xmlExpNodePtr exp) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 7084 :     if (exp == NULL)

	cmp	DWORD PTR _exp$[ebp], 0
	jne	SHORT $LN2@xmlExpIsNi

; 7085 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlExpIsNi
$LN2@xmlExpIsNi:

; 7086 :     return(IS_NILLABLE(exp) != 0);

	mov	eax, DWORD PTR _exp$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	and	ecx, 1
	je	SHORT $LN4@xmlExpIsNi
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN5@xmlExpIsNi
$LN4@xmlExpIsNi:
	mov	DWORD PTR tv69[ebp], 0
$LN5@xmlExpIsNi:
	mov	eax, DWORD PTR tv69[ebp]
$LN1@xmlExpIsNi:

; 7087 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpIsNillable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpNewRange
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_subset$ = 12						; size = 4
_min$ = 16						; size = 4
_max$ = 20						; size = 4
_xmlExpNewRange PROC					; COMDAT

; 6935 : xmlExpNewRange(xmlExpCtxtPtr ctxt, xmlExpNodePtr subset, int min, int max) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6936 :     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlExpNewR

; 6937 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpNewR
$LN2@xmlExpNewR:

; 6938 :     if ((subset == NULL) || (min < 0) || (max < -1) ||

	cmp	DWORD PTR _subset$[ebp], 0
	je	SHORT $LN4@xmlExpNewR
	cmp	DWORD PTR _min$[ebp], 0
	jl	SHORT $LN4@xmlExpNewR
	cmp	DWORD PTR _max$[ebp], -1
	jl	SHORT $LN4@xmlExpNewR
	cmp	DWORD PTR _max$[ebp], 0
	jl	SHORT $LN3@xmlExpNewR
	mov	eax, DWORD PTR _min$[ebp]
	cmp	eax, DWORD PTR _max$[ebp]
	jle	SHORT $LN3@xmlExpNewR
$LN4@xmlExpNewR:

; 6939 :         ((max >= 0) && (min > max))) {
; 6940 : 	xmlExpFree(ctxt, subset);

	mov	ecx, DWORD PTR _subset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpFree
	add	esp, 8

; 6941 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpNewR
$LN3@xmlExpNewR:

; 6942 :     }
; 6943 :     return(xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, subset,

	mov	eax, DWORD PTR _max$[ebp]
	push	eax
	mov	ecx, DWORD PTR _min$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _subset$[ebp]
	push	edx
	push	5
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
$LN1@xmlExpNewR:

; 6944 :                               NULL, NULL, min, max));
; 6945 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlExpNewRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpNewSeq
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_left$ = 12						; size = 4
_right$ = 16						; size = 4
_xmlExpNewSeq PROC					; COMDAT

; 6909 : xmlExpNewSeq(xmlExpCtxtPtr ctxt, xmlExpNodePtr left, xmlExpNodePtr right) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6910 :     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlExpNewS

; 6911 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpNewS
$LN2@xmlExpNewS:

; 6912 :     if ((left == NULL) || (right == NULL)) {

	cmp	DWORD PTR _left$[ebp], 0
	je	SHORT $LN4@xmlExpNewS
	cmp	DWORD PTR _right$[ebp], 0
	jne	SHORT $LN3@xmlExpNewS
$LN4@xmlExpNewS:

; 6913 :         xmlExpFree(ctxt, left);

	mov	eax, DWORD PTR _left$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8

; 6914 :         xmlExpFree(ctxt, right);

	mov	edx, DWORD PTR _right$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8

; 6915 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpNewS
$LN3@xmlExpNewS:

; 6916 :     }
; 6917 :     return(xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, left, right, NULL, 0, 0));

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _right$[ebp]
	push	ecx
	mov	edx, DWORD PTR _left$[ebp]
	push	edx
	push	3
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
$LN1@xmlExpNewS:

; 6918 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlExpNewSeq ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpNewOr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_left$ = 12						; size = 4
_right$ = 16						; size = 4
_xmlExpNewOr PROC					; COMDAT

; 6884 : xmlExpNewOr(xmlExpCtxtPtr ctxt, xmlExpNodePtr left, xmlExpNodePtr right) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6885 :     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlExpNewO

; 6886 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpNewO
$LN2@xmlExpNewO:

; 6887 :     if ((left == NULL) || (right == NULL)) {

	cmp	DWORD PTR _left$[ebp], 0
	je	SHORT $LN4@xmlExpNewO
	cmp	DWORD PTR _right$[ebp], 0
	jne	SHORT $LN3@xmlExpNewO
$LN4@xmlExpNewO:

; 6888 :         xmlExpFree(ctxt, left);

	mov	eax, DWORD PTR _left$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8

; 6889 :         xmlExpFree(ctxt, right);

	mov	edx, DWORD PTR _right$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8

; 6890 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpNewO
$LN3@xmlExpNewO:

; 6891 :     }
; 6892 :     return(xmlExpHashGetEntry(ctxt, XML_EXP_OR, left, right, NULL, 0, 0));

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _right$[ebp]
	push	ecx
	mov	edx, DWORD PTR _left$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
$LN1@xmlExpNewO:

; 6893 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlExpNewOr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpNewAtom
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlExpNewAtom PROC					; COMDAT

; 6861 : xmlExpNewAtom(xmlExpCtxtPtr ctxt, const xmlChar *name, int len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6862 :     if ((ctxt == NULL) || (name == NULL))

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlExpNewA
	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN2@xmlExpNewA
$LN3@xmlExpNewA:

; 6863 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpNewA
$LN2@xmlExpNewA:

; 6864 :     name = xmlDictLookup(ctxt->dict, name, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _name$[ebp], eax

; 6865 :     if (name == NULL)

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN4@xmlExpNewA

; 6866 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpNewA
$LN4@xmlExpNewA:

; 6867 :     return(xmlExpHashGetEntry(ctxt, XML_EXP_ATOM, NULL, NULL, name, 0, 0));

	push	0
	push	0
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	0
	push	0
	push	2
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
$LN1@xmlExpNewA:

; 6868 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlExpNewAtom ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpParse
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_expr$ = 12						; size = 4
_xmlExpParse PROC					; COMDAT

; 8027 : xmlExpParse(xmlExpCtxtPtr ctxt, const char *expr) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 8028 :     xmlExpNodePtr ret;
; 8029 : 
; 8030 :     ctxt->expr = expr;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _expr$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 8031 :     ctxt->cur = expr;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _expr$[ebp]
	mov	DWORD PTR [edx+28], eax

; 8032 : 
; 8033 :     ret = xmlExpParseExpr(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpParseExpr
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax
$LN2@xmlExpPars:

; 8034 :     SKIP_BLANKS

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN4@xmlExpPars
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN4@xmlExpPars
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN4@xmlExpPars
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jne	SHORT $LN3@xmlExpPars
$LN4@xmlExpPars:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+28], eax
	jmp	SHORT $LN2@xmlExpPars
$LN3@xmlExpPars:

; 8035 :     if (*ctxt->cur != 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@xmlExpPars

; 8036 :         xmlExpFree(ctxt, ret);

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8

; 8037 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpPars
$LN5@xmlExpPars:

; 8038 :     }
; 8039 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlExpPars:

; 8040 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpParse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpRef
_TEXT	SEGMENT
_exp$ = 8						; size = 4
_xmlExpRef PROC						; COMDAT

; 6845 : xmlExpRef(xmlExpNodePtr exp) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6846 :     if (exp != NULL)

	cmp	DWORD PTR _exp$[ebp], 0
	je	SHORT $LN1@xmlExpRef

; 6847 :         exp->ref++;

	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _exp$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN1@xmlExpRef:

; 6848 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlExpRef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpFree
_TEXT	SEGMENT
_tmp$1 = -8						; size = 4
_key$2 = -4						; size = 2
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_xmlExpFree PROC					; COMDAT

; 6803 : xmlExpFree(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6804 :     if ((exp == NULL) || (exp == forbiddenExp) || (exp == emptyExp))

	cmp	DWORD PTR _exp$[ebp], 0
	je	SHORT $LN5@xmlExpFree
	mov	eax, DWORD PTR _exp$[ebp]
	cmp	eax, DWORD PTR _forbiddenExp
	je	SHORT $LN5@xmlExpFree
	mov	ecx, DWORD PTR _exp$[ebp]
	cmp	ecx, DWORD PTR _emptyExp
	jne	SHORT $LN4@xmlExpFree
$LN5@xmlExpFree:

; 6805 :         return;

	jmp	$LN1@xmlExpFree
$LN4@xmlExpFree:

; 6806 :     exp->ref--;

	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 6807 :     if (exp->ref == 0) {

	mov	edx, DWORD PTR _exp$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	$LN1@xmlExpFree

; 6808 :         unsigned short key;
; 6809 : 
; 6810 :         /* Unlink it first from the hash table */
; 6811 : 	key = exp->key % ctxt->size;

	mov	eax, DWORD PTR _exp$[ebp]
	movzx	eax, WORD PTR [eax+2]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cdq
	idiv	DWORD PTR [ecx+8]
	mov	WORD PTR _key$2[ebp], dx

; 6812 : 	if (ctxt->table[key] == exp) {

	movzx	edx, WORD PTR _key$2[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	cmp	edx, DWORD PTR _exp$[ebp]
	jne	SHORT $LN7@xmlExpFree

; 6813 : 	    ctxt->table[key] = exp->next;

	movzx	eax, WORD PTR _key$2[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+eax*4], ecx

; 6814 : 	} else {

	jmp	SHORT $LN8@xmlExpFree
$LN7@xmlExpFree:

; 6815 : 	    xmlExpNodePtr tmp;
; 6816 : 
; 6817 : 	    tmp = ctxt->table[key];

	movzx	edx, WORD PTR _key$2[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _tmp$1[ebp], edx
$LN2@xmlExpFree:

; 6818 : 	    while (tmp != NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	je	SHORT $LN8@xmlExpFree

; 6819 : 	        if (tmp->next == exp) {

	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _exp$[ebp]
	jne	SHORT $LN9@xmlExpFree

; 6820 : 		    tmp->next = exp->next;

	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	eax, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx

; 6821 : 		    break;

	jmp	SHORT $LN8@xmlExpFree
$LN9@xmlExpFree:

; 6822 : 		}
; 6823 : 	        tmp = tmp->next;

	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _tmp$1[ebp], eax

; 6824 : 	    }

	jmp	SHORT $LN2@xmlExpFree
$LN8@xmlExpFree:

; 6825 : 	}
; 6826 : 
; 6827 :         if ((exp->type == XML_EXP_SEQ) || (exp->type == XML_EXP_OR)) {

	mov	ecx, DWORD PTR _exp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 3
	je	SHORT $LN12@xmlExpFree
	mov	eax, DWORD PTR _exp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 4
	jne	SHORT $LN10@xmlExpFree
$LN12@xmlExpFree:

; 6828 : 	    xmlExpFree(ctxt, exp->exp_left);

	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8

; 6829 : 	    xmlExpFree(ctxt, exp->exp_right);

	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlExpFree
	add	esp, 8
	jmp	SHORT $LN11@xmlExpFree
$LN10@xmlExpFree:

; 6830 : 	} else if (exp->type == XML_EXP_COUNT) {

	mov	edx, DWORD PTR _exp$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 5
	jne	SHORT $LN11@xmlExpFree

; 6831 : 	    xmlExpFree(ctxt, exp->exp_left);

	mov	ecx, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree
	add	esp, 8
$LN11@xmlExpFree:

; 6832 : 	}
; 6833 :         xmlFree(exp);

	mov	esi, esp
	mov	ecx, DWORD PTR _exp$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6834 : 	ctxt->nb_nodes--;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN1@xmlExpFree:

; 6835 :     }
; 6836 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpCtxtNbCons
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlExpCtxtNbCons PROC					; COMDAT

; 8171 : xmlExpCtxtNbCons(xmlExpCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 8172 :     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlExpCtxt

; 8173 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlExpCtxt
$LN2@xmlExpCtxt:

; 8174 :     return(ctxt->nb_cons);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [eax+32]
$LN1@xmlExpCtxt:

; 8175 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlExpCtxtNbCons ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpCtxtNbNodes
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlExpCtxtNbNodes PROC					; COMDAT

; 8156 : xmlExpCtxtNbNodes(xmlExpCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 8157 :     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlExpCtxt

; 8158 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlExpCtxt
$LN2@xmlExpCtxt:

; 8159 :     return(ctxt->nb_nodes);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [eax+16]
$LN1@xmlExpCtxt:

; 8160 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlExpCtxtNbNodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpNewCtxt
_TEXT	SEGMENT
_size$ = -8						; size = 4
_ret$ = -4						; size = 4
_maxNodes$ = 8						; size = 4
_dict$ = 12						; size = 4
_xmlExpNewCtxt PROC					; COMDAT

; 6368 : xmlExpNewCtxt(int maxNodes, xmlDictPtr dict) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6369 :     xmlExpCtxtPtr ret;
; 6370 :     int size = 256;

	mov	DWORD PTR _size$[ebp], 256		; 00000100H

; 6371 : 
; 6372 :     if (maxNodes <= 4096)

	cmp	DWORD PTR _maxNodes$[ebp], 4096		; 00001000H
	jg	SHORT $LN2@xmlExpNewC

; 6373 :         maxNodes = 4096;

	mov	DWORD PTR _maxNodes$[ebp], 4096		; 00001000H
$LN2@xmlExpNewC:

; 6374 : 
; 6375 :     ret = (xmlExpCtxtPtr) xmlMalloc(sizeof(xmlExpCtxt));

	mov	esi, esp
	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 6376 :     if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN3@xmlExpNewC

; 6377 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlExpNewC
$LN3@xmlExpNewC:

; 6378 :     memset(ret, 0, sizeof(xmlExpCtxt));

	xor	eax, eax
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], eax
	mov	DWORD PTR [ecx+32], eax
	mov	DWORD PTR [ecx+36], eax

; 6379 :     ret->size = size;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx+8], eax

; 6380 :     ret->nbElems = 0;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 6381 :     ret->maxNodes = maxNodes;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _maxNodes$[ebp]
	mov	DWORD PTR [edx+20], eax

; 6382 :     ret->table = xmlMalloc(size * sizeof(xmlExpNodePtr));

	mov	ecx, DWORD PTR _size$[ebp]
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+4], eax

; 6383 :     if (ret->table == NULL) {

	mov	eax, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN4@xmlExpNewC

; 6384 :         xmlFree(ret);

	mov	esi, esp
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6385 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpNewC
$LN4@xmlExpNewC:

; 6386 :     }
; 6387 :     memset(ret->table, 0, size * sizeof(xmlExpNodePtr));

	mov	edx, DWORD PTR _size$[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 6388 :     if (dict == NULL) {

	cmp	DWORD PTR _dict$[ebp], 0
	jne	SHORT $LN5@xmlExpNewC

; 6389 :         ret->dict = xmlDictCreate();

	call	_xmlDictCreate
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx], eax

; 6390 : 	if (ret->dict == NULL) {

	mov	eax, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@xmlExpNewC

; 6391 : 	    xmlFree(ret->table);

	mov	esi, esp
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6392 : 	    xmlFree(ret);

	mov	esi, esp
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6393 : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlExpNewC
$LN7@xmlExpNewC:

; 6394 : 	}
; 6395 :     } else {

	jmp	SHORT $LN6@xmlExpNewC
$LN5@xmlExpNewC:

; 6396 :         ret->dict = dict;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [ecx], edx

; 6397 : 	xmlDictReference(ret->dict);

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlDictReference
	add	esp, 4
$LN6@xmlExpNewC:

; 6398 :     }
; 6399 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlExpNewC:

; 6400 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpNewCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpFreeCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlExpFreeCtxt PROC					; COMDAT

; 6409 : xmlExpFreeCtxt(xmlExpCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 6410 :     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlExpFree

; 6411 :         return;

	jmp	SHORT $LN1@xmlExpFree
$LN2@xmlExpFree:

; 6412 :     xmlDictFree(ctxt->dict);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlDictFree
	add	esp, 4

; 6413 :     if (ctxt->table != NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN3@xmlExpFree

; 6414 : 	xmlFree(ctxt->table);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlExpFree:

; 6415 :     xmlFree(ctxt);

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlExpFree:

; 6416 : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlExpFreeCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegExecErrInfo
_TEXT	SEGMENT
_exec$ = 8						; size = 4
_string$ = 12						; size = 4
_nbval$ = 16						; size = 4
_nbneg$ = 20						; size = 4
_values$ = 24						; size = 4
_terminal$ = 28						; size = 4
_xmlRegExecErrInfo PROC					; COMDAT

; 4408 :                   int *nbval, int *nbneg, xmlChar **values, int *terminal) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 4409 :     if (exec == NULL)

	cmp	DWORD PTR _exec$[ebp], 0
	jne	SHORT $LN2@xmlRegExec

; 4410 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlRegExec
$LN2@xmlRegExec:

; 4411 :     if (string != NULL) {

	cmp	DWORD PTR _string$[ebp], 0
	je	SHORT $LN3@xmlRegExec

; 4412 :         if (exec->status != 0)

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@xmlRegExec

; 4413 : 	    *string = exec->errString;

	mov	ecx, DWORD PTR _string$[ebp]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN3@xmlRegExec
$LN4@xmlRegExec:

; 4414 : 	else
; 4415 : 	    *string = NULL;

	mov	ecx, DWORD PTR _string$[ebp]
	mov	DWORD PTR [ecx], 0
$LN3@xmlRegExec:

; 4416 :     }
; 4417 :     return(xmlRegExecGetValues(exec, 1, nbval, nbneg, values, terminal));

	mov	edx, DWORD PTR _terminal$[ebp]
	push	edx
	mov	eax, DWORD PTR _values$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nbneg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nbval$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _exec$[ebp]
	push	eax
	call	_xmlRegExecGetValues
	add	esp, 24					; 00000018H
$LN1@xmlRegExec:

; 4418 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlRegExecErrInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegExecNextValues
_TEXT	SEGMENT
_exec$ = 8						; size = 4
_nbval$ = 12						; size = 4
_nbneg$ = 16						; size = 4
_values$ = 20						; size = 4
_terminal$ = 24						; size = 4
_xmlRegExecNextValues PROC				; COMDAT

; 4383 :                      xmlChar **values, int *terminal) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 4384 :     return(xmlRegExecGetValues(exec, 0, nbval, nbneg, values, terminal));

	mov	eax, DWORD PTR _terminal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _values$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nbneg$[ebp]
	push	edx
	mov	eax, DWORD PTR _nbval$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _exec$[ebp]
	push	ecx
	call	_xmlRegExecGetValues
	add	esp, 24					; 00000018H

; 4385 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlRegExecNextValues ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegExecPushString2
_TEXT	SEGMENT
tv80 = -208						; size = 4
tv187 = -201						; size = 1
tv184 = -200						; size = 4
tv181 = -196						; size = 4
tv77 = -192						; size = 4
tv175 = -185						; size = 1
tv172 = -184						; size = 4
tv169 = -180						; size = 4
_str$ = -176						; size = 4
_ret$ = -172						; size = 4
_lenp$ = -168						; size = 4
_lenn$ = -164						; size = 4
_buf$ = -156						; size = 150
_exec$ = 8						; size = 4
_value$ = 12						; size = 4
_value2$ = 16						; size = 4
_data$ = 20						; size = 4
_xmlRegExecPushString2 PROC				; COMDAT

; 4162 :                       const xmlChar *value2, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 4163 :     xmlChar buf[150];
; 4164 :     int lenn, lenp, ret;
; 4165 :     xmlChar *str;
; 4166 : 
; 4167 :     if (exec == NULL)

	cmp	DWORD PTR _exec$[ebp], 0
	jne	SHORT $LN2@xmlRegExec

; 4168 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlRegExec
$LN2@xmlRegExec:

; 4169 :     if (exec->comp == NULL)

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN3@xmlRegExec

; 4170 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlRegExec
$LN3@xmlRegExec:

; 4171 :     if (exec->status != 0)

	mov	ecx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN4@xmlRegExec

; 4172 : 	return(exec->status);

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	$LN1@xmlRegExec
$LN4@xmlRegExec:

; 4173 : 
; 4174 :     if (value2 == NULL)

	cmp	DWORD PTR _value2$[ebp], 0
	jne	SHORT $LN5@xmlRegExec

; 4175 :         return(xmlRegExecPushString(exec, value, data));

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _exec$[ebp]
	push	edx
	call	_xmlRegExecPushString
	add	esp, 12					; 0000000cH
	jmp	$LN1@xmlRegExec
$LN5@xmlRegExec:

; 4176 : 
; 4177 :     lenn = strlen((char *) value2);

	mov	eax, DWORD PTR _value2$[ebp]
	mov	DWORD PTR tv169[ebp], eax
	mov	ecx, DWORD PTR tv169[ebp]
	add	ecx, 1
	mov	DWORD PTR tv172[ebp], ecx
$LL13@xmlRegExec:
	mov	edx, DWORD PTR tv169[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv175[ebp], al
	add	DWORD PTR tv169[ebp], 1
	cmp	BYTE PTR tv175[ebp], 0
	jne	SHORT $LL13@xmlRegExec
	mov	ecx, DWORD PTR tv169[ebp]
	sub	ecx, DWORD PTR tv172[ebp]
	mov	DWORD PTR tv77[ebp], ecx
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _lenn$[ebp], edx

; 4178 :     lenp = strlen((char *) value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR tv181[ebp], eax
	mov	ecx, DWORD PTR tv181[ebp]
	add	ecx, 1
	mov	DWORD PTR tv184[ebp], ecx
$LL14@xmlRegExec:
	mov	edx, DWORD PTR tv181[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv187[ebp], al
	add	DWORD PTR tv181[ebp], 1
	cmp	BYTE PTR tv187[ebp], 0
	jne	SHORT $LL14@xmlRegExec
	mov	ecx, DWORD PTR tv181[ebp]
	sub	ecx, DWORD PTR tv184[ebp]
	mov	DWORD PTR tv80[ebp], ecx
	mov	edx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _lenp$[ebp], edx

; 4179 : 
; 4180 :     if (150 < lenn + lenp + 2) {

	mov	eax, DWORD PTR _lenp$[ebp]
	mov	ecx, DWORD PTR _lenn$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2]
	cmp	edx, 150				; 00000096H
	jle	SHORT $LN6@xmlRegExec

; 4181 : 	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);

	mov	eax, DWORD PTR _lenp$[ebp]
	mov	ecx, DWORD PTR _lenn$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2]
	mov	esi, esp
	push	edx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _str$[ebp], eax

; 4182 : 	if (str == NULL) {

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN8@xmlRegExec

; 4183 : 	    exec->status = -1;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax], -1

; 4184 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlRegExec
$LN8@xmlRegExec:

; 4185 : 	}
; 4186 :     } else {

	jmp	SHORT $LN7@xmlRegExec
$LN6@xmlRegExec:

; 4187 : 	str = buf;

	lea	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _str$[ebp], ecx
$LN7@xmlRegExec:

; 4188 :     }
; 4189 :     memcpy(&str[0], value, lenp);

	mov	edx, DWORD PTR _lenp$[ebp]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	add	edx, DWORD PTR _str$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 4190 :     str[lenp] = XML_REG_STRING_SEPARATOR;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _lenp$[ebp]
	mov	BYTE PTR [eax], 124			; 0000007cH

; 4191 :     memcpy(&str[lenp + 1], value2, lenn);

	mov	ecx, DWORD PTR _lenn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _value2$[ebp]
	push	edx
	mov	eax, DWORD PTR _lenp$[ebp]
	mov	ecx, DWORD PTR _str$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 4192 :     str[lenn + lenp + 1] = 0;

	mov	eax, DWORD PTR _lenn$[ebp]
	add	eax, DWORD PTR _lenp$[ebp]
	mov	ecx, DWORD PTR _str$[ebp]
	mov	BYTE PTR [ecx+eax+1], 0

; 4193 : 
; 4194 :     if (exec->comp->compact != NULL)

	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN9@xmlRegExec

; 4195 : 	ret = xmlRegCompactPushString(exec, exec->comp, str, data);

	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _exec$[ebp]
	push	edx
	call	_xmlRegCompactPushString
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax
	jmp	SHORT $LN10@xmlRegExec
$LN9@xmlRegExec:

; 4196 :     else
; 4197 :         ret = xmlRegExecPushStringInternal(exec, str, data, 1);

	push	1
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _exec$[ebp]
	push	edx
	call	_xmlRegExecPushStringInternal
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax
$LN10@xmlRegExec:

; 4198 : 
; 4199 :     if (str != buf)

	lea	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR _str$[ebp], eax
	je	SHORT $LN11@xmlRegExec

; 4200 :         xmlFree(str);

	mov	esi, esp
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlRegExec:

; 4201 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlRegExec:

; 4202 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@xmlRegExec
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN17@xmlRegExec:
	DD	1
	DD	$LN16@xmlRegExec
$LN16@xmlRegExec:
	DD	-156					; ffffff64H
	DD	150					; 00000096H
	DD	$LN15@xmlRegExec
$LN15@xmlRegExec:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_xmlRegExecPushString2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegExecPushString
_TEXT	SEGMENT
_exec$ = 8						; size = 4
_value$ = 12						; size = 4
_data$ = 16						; size = 4
_xmlRegExecPushString PROC				; COMDAT

; 4144 : 	             void *data) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 4145 :     return(xmlRegExecPushStringInternal(exec, value, data, 0));

	push	0
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _exec$[ebp]
	push	edx
	call	_xmlRegExecPushStringInternal
	add	esp, 16					; 00000010H

; 4146 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlRegExecPushString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegFreeExecCtxt
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_i$2 = -4						; size = 4
_exec$ = 8						; size = 4
_xmlRegFreeExecCtxt PROC				; COMDAT

; 3572 : xmlRegFreeExecCtxt(xmlRegExecCtxtPtr exec) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 3573 :     if (exec == NULL)

	cmp	DWORD PTR _exec$[ebp], 0
	jne	SHORT $LN8@xmlRegFree

; 3574 : 	return;

	jmp	$LN1@xmlRegFree
$LN8@xmlRegFree:

; 3575 : 
; 3576 :     if (exec->rollbacks != NULL) {

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN9@xmlRegFree

; 3577 : 	if (exec->counts != NULL) {

	mov	ecx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [ecx+44], 0
	je	SHORT $LN10@xmlRegFree

; 3578 : 	    int i;
; 3579 : 
; 3580 : 	    for (i = 0;i < exec->maxRollbacks;i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@xmlRegFree
$LN2@xmlRegFree:
	mov	edx, DWORD PTR _i$2[ebp]
	add	edx, 1
	mov	DWORD PTR _i$2[ebp], edx
$LN4@xmlRegFree:
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	SHORT $LN10@xmlRegFree

; 3581 : 		if (exec->rollbacks[i].counts != NULL)

	mov	edx, DWORD PTR _i$2[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	cmp	DWORD PTR [ecx+edx+12], 0
	je	SHORT $LN11@xmlRegFree

; 3582 : 		    xmlFree(exec->rollbacks[i].counts);

	mov	edx, DWORD PTR _i$2[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	esi, esp
	mov	edx, DWORD PTR [ecx+edx+12]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlRegFree:
	jmp	SHORT $LN2@xmlRegFree
$LN10@xmlRegFree:

; 3583 : 	}
; 3584 : 	xmlFree(exec->rollbacks);

	mov	esi, esp
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@xmlRegFree:

; 3585 :     }
; 3586 :     if (exec->counts != NULL)

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN12@xmlRegFree

; 3587 : 	xmlFree(exec->counts);

	mov	esi, esp
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlRegFree:

; 3588 :     if (exec->inputStack != NULL) {

	mov	edx, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [edx+68], 0
	je	SHORT $LN13@xmlRegFree

; 3589 : 	int i;
; 3590 : 
; 3591 : 	for (i = 0;i < exec->inputStackNr;i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN7@xmlRegFree
$LN5@xmlRegFree:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN7@xmlRegFree:
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	cmp	edx, DWORD PTR [ecx+52]
	jge	SHORT $LN6@xmlRegFree

; 3592 : 	    if (exec->inputStack[i].value != NULL)

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	edx, DWORD PTR _i$1[ebp]
	cmp	DWORD PTR [ecx+edx*8], 0
	je	SHORT $LN14@xmlRegFree

; 3593 : 		xmlFree(exec->inputStack[i].value);

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	esi, esp
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@xmlRegFree:

; 3594 : 	}

	jmp	SHORT $LN5@xmlRegFree
$LN6@xmlRegFree:

; 3595 : 	xmlFree(exec->inputStack);

	mov	esi, esp
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@xmlRegFree:

; 3596 :     }
; 3597 :     if (exec->errString != NULL)

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN15@xmlRegFree

; 3598 :         xmlFree(exec->errString);

	mov	esi, esp
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@xmlRegFree:

; 3599 :     xmlFree(exec);

	mov	esi, esp
	mov	eax, DWORD PTR _exec$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlRegFree:

; 3600 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegFreeExecCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegNewExecCtxt
_TEXT	SEGMENT
_exec$ = -4						; size = 4
_comp$ = 8						; size = 4
_callback$ = 12						; size = 4
_data$ = 16						; size = 4
_xmlRegNewExecCtxt PROC					; COMDAT

; 3511 : xmlRegNewExecCtxt(xmlRegexpPtr comp, xmlRegExecCallbacks callback, void *data) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 3512 :     xmlRegExecCtxtPtr exec;
; 3513 : 
; 3514 :     if (comp == NULL)

	cmp	DWORD PTR _comp$[ebp], 0
	jne	SHORT $LN2@xmlRegNewE

; 3515 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlRegNewE
$LN2@xmlRegNewE:

; 3516 :     if ((comp->compact == NULL) && (comp->states == NULL))

	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN3@xmlRegNewE
	mov	ecx, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN3@xmlRegNewE

; 3517 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlRegNewE
$LN3@xmlRegNewE:

; 3518 :     exec = (xmlRegExecCtxtPtr) xmlMalloc(sizeof(xmlRegExecCtxt));

	mov	esi, esp
	push	92					; 0000005cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _exec$[ebp], eax

; 3519 :     if (exec == NULL) {

	cmp	DWORD PTR _exec$[ebp], 0
	jne	SHORT $LN4@xmlRegNewE

; 3520 : 	xmlRegexpErrMemory(NULL, "creating execution context");

	push	OFFSET ??_C@_0BL@LMPHHOAL@creating?5execution?5context@
	push	0
	call	_xmlRegexpErrMemory
	add	esp, 8

; 3521 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlRegNewE
$LN4@xmlRegNewE:

; 3522 :     }
; 3523 :     memset(exec, 0, sizeof(xmlRegExecCtxt));

	push	92					; 0000005cH
	push	0
	mov	edx, DWORD PTR _exec$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 3524 :     exec->inputString = NULL;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+64], 0

; 3525 :     exec->index = 0;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 3526 :     exec->determinist = 1;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+4], 1

; 3527 :     exec->maxRollbacks = 0;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+32], 0

; 3528 :     exec->nbRollbacks = 0;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 3529 :     exec->rollbacks = NULL;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+40], 0

; 3530 :     exec->status = 0;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax], 0

; 3531 :     exec->comp = comp;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 3532 :     if (comp->compact == NULL)

	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN5@xmlRegNewE

; 3533 : 	exec->state = comp->states[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [eax+20], ecx
$LN5@xmlRegNewE:

; 3534 :     exec->transno = 0;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+24], 0

; 3535 :     exec->transcount = 0;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+28], 0

; 3536 :     exec->callback = callback;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR _callback$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 3537 :     exec->data = data;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 3538 :     if (comp->nbCounters > 0) {

	mov	edx, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jle	$LN6@xmlRegNewE

; 3539 :         /*
; 3540 : 	 * For error handling, exec->counts is allocated twice the size
; 3541 : 	 * the second half is used to store the data in case of rollback
; 3542 : 	 */
; 3543 : 	exec->counts = (int *) xmlMalloc(comp->nbCounters * sizeof(int)

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	shl	ecx, 2
	shl	ecx, 1
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+44], eax

; 3544 : 	                                 * 2);
; 3545 : 	if (exec->counts == NULL) {

	mov	eax, DWORD PTR _exec$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN8@xmlRegNewE

; 3546 : 	    xmlRegexpErrMemory(NULL, "creating execution context");

	push	OFFSET ??_C@_0BL@LMPHHOAL@creating?5execution?5context@
	push	0
	call	_xmlRegexpErrMemory
	add	esp, 8

; 3547 : 	    xmlFree(exec);

	mov	esi, esp
	mov	ecx, DWORD PTR _exec$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3548 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlRegNewE
$LN8@xmlRegNewE:

; 3549 : 	}
; 3550 :         memset(exec->counts, 0, comp->nbCounters * sizeof(int) * 2);

	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shl	eax, 2
	shl	eax, 1
	push	eax
	push	0
	mov	ecx, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 3551 : 	exec->errCounts = &exec->counts[comp->nbCounters];

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [edx+44]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+84], ecx

; 3552 :     } else {

	jmp	SHORT $LN7@xmlRegNewE
$LN6@xmlRegNewE:

; 3553 : 	exec->counts = NULL;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+44], 0

; 3554 : 	exec->errCounts = NULL;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+84], 0
$LN7@xmlRegNewE:

; 3555 :     }
; 3556 :     exec->inputStackMax = 0;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+48], 0

; 3557 :     exec->inputStackNr = 0;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+52], 0

; 3558 :     exec->inputStack = NULL;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 3559 :     exec->errStateNo = -1;

	mov	edx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [edx+72], -1

; 3560 :     exec->errString = NULL;

	mov	eax, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [eax+80], 0

; 3561 :     exec->nbPush = 0;

	mov	ecx, DWORD PTR _exec$[ebp]
	mov	DWORD PTR [ecx+88], 0

; 3562 :     return(exec);

	mov	eax, DWORD PTR _exec$[ebp]
$LN1@xmlRegNewE:

; 3563 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegNewExecCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegexpIsDeterminist
_TEXT	SEGMENT
_i$1 = -12						; size = 4
_ret$ = -8						; size = 4
_am$ = -4						; size = 4
_comp$ = 8						; size = 4
_xmlRegexpIsDeterminist PROC				; COMDAT

; 5530 : xmlRegexpIsDeterminist(xmlRegexpPtr comp) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5531 :     xmlAutomataPtr am;
; 5532 :     int ret;
; 5533 : 
; 5534 :     if (comp == NULL)

	cmp	DWORD PTR _comp$[ebp], 0
	jne	SHORT $LN5@xmlRegexpI

; 5535 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlRegexpI
$LN5@xmlRegexpI:

; 5536 :     if (comp->determinist != -1)

	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+28], -1
	je	SHORT $LN6@xmlRegexpI

; 5537 : 	return(comp->determinist);

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [ecx+28]
	jmp	$LN1@xmlRegexpI
$LN6@xmlRegexpI:

; 5538 : 
; 5539 :     am = xmlNewAutomata();

	call	_xmlNewAutomata
	mov	DWORD PTR _am$[ebp], eax

; 5540 :     if (am->states != NULL) {

	mov	edx, DWORD PTR _am$[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $LN7@xmlRegexpI

; 5541 : 	int i;
; 5542 : 
; 5543 : 	for (i = 0;i < am->nbStates;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@xmlRegexpI
$LN2@xmlRegexpI:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@xmlRegexpI:
	mov	ecx, DWORD PTR _am$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	cmp	edx, DWORD PTR [ecx+48]
	jge	SHORT $LN3@xmlRegexpI

; 5544 : 	    xmlRegFreeState(am->states[i]);

	mov	eax, DWORD PTR _am$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_xmlRegFreeState
	add	esp, 4
	jmp	SHORT $LN2@xmlRegexpI
$LN3@xmlRegexpI:

; 5545 : 	xmlFree(am->states);

	mov	esi, esp
	mov	ecx, DWORD PTR _am$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlRegexpI:

; 5546 :     }
; 5547 :     am->nbAtoms = comp->nbAtoms;

	mov	eax, DWORD PTR _am$[ebp]
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+36], edx

; 5548 :     am->atoms = comp->atoms;

	mov	eax, DWORD PTR _am$[ebp]
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+40], edx

; 5549 :     am->nbStates = comp->nbStates;

	mov	eax, DWORD PTR _am$[ebp]
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+48], edx

; 5550 :     am->states = comp->states;

	mov	eax, DWORD PTR _am$[ebp]
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+52], edx

; 5551 :     am->determinist = -1;

	mov	eax, DWORD PTR _am$[ebp]
	mov	DWORD PTR [eax+68], -1

; 5552 :     am->flags = comp->flags;

	mov	ecx, DWORD PTR _am$[ebp]
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+76], eax

; 5553 :     ret = xmlFAComputesDeterminism(am);

	mov	ecx, DWORD PTR _am$[ebp]
	push	ecx
	call	_xmlFAComputesDeterminism
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 5554 :     am->atoms = NULL;

	mov	edx, DWORD PTR _am$[ebp]
	mov	DWORD PTR [edx+40], 0

; 5555 :     am->states = NULL;

	mov	eax, DWORD PTR _am$[ebp]
	mov	DWORD PTR [eax+52], 0

; 5556 :     xmlFreeAutomata(am);

	mov	ecx, DWORD PTR _am$[ebp]
	push	ecx
	call	_xmlFreeAutomata
	add	esp, 4

; 5557 :     comp->determinist = ret;

	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+28], eax

; 5558 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlRegexpI:

; 5559 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegexpIsDeterminist ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegexpPrint
_TEXT	SEGMENT
_i$ = -4						; size = 4
_output$ = 8						; size = 4
_regexp$ = 12						; size = 4
_xmlRegexpPrint PROC					; COMDAT

; 5426 : xmlRegexpPrint(FILE *output, xmlRegexpPtr regexp) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5427 :     int i;
; 5428 : 
; 5429 :     if (output == NULL)

	cmp	DWORD PTR _output$[ebp], 0
	jne	SHORT $LN11@xmlRegexpP

; 5430 :         return;

	jmp	$LN1@xmlRegexpP
$LN11@xmlRegexpP:

; 5431 :     fprintf(output, " regexp: ");

	push	OFFSET ??_C@_09BNLLHCCB@?5regexp?3?5@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8

; 5432 :     if (regexp == NULL) {

	cmp	DWORD PTR _regexp$[ebp], 0
	jne	SHORT $LN12@xmlRegexpP

; 5433 : 	fprintf(output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8

; 5434 : 	return;

	jmp	$LN1@xmlRegexpP
$LN12@xmlRegexpP:

; 5435 :     }
; 5436 :     fprintf(output, "'%s' ", regexp->string);

	mov	edx, DWORD PTR _regexp$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_05IMLJLABD@?8?$CFs?8?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 5437 :     fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8

; 5438 :     fprintf(output, "%d atoms:\n", regexp->nbAtoms);

	mov	eax, DWORD PTR _regexp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	OFFSET ??_C@_0L@PLBJGPP@?$CFd?5atoms?3?6@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 5439 :     for (i = 0;i < regexp->nbAtoms; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlRegexpP
$LN2@xmlRegexpP:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlRegexpP:
	mov	ecx, DWORD PTR _regexp$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jge	SHORT $LN3@xmlRegexpP

; 5440 : 	fprintf(output, " %02d ", i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_06NLBGECGK@?5?$CF02d?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 5441 : 	xmlRegPrintAtom(output, regexp->atoms[i]);

	mov	edx, DWORD PTR _regexp$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_xmlRegPrintAtom
	add	esp, 8

; 5442 :     }

	jmp	SHORT $LN2@xmlRegexpP
$LN3@xmlRegexpP:

; 5443 :     fprintf(output, "%d states:", regexp->nbStates);

	mov	ecx, DWORD PTR _regexp$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	OFFSET ??_C@_0L@LDKKLMNF@?$CFd?5states?3@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 5444 :     fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8

; 5445 :     for (i = 0;i < regexp->nbStates; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@xmlRegexpP
$LN5@xmlRegexpP:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@xmlRegexpP:
	mov	eax, DWORD PTR _regexp$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN6@xmlRegexpP

; 5446 : 	xmlRegPrintState(output, regexp->states[i]);

	mov	edx, DWORD PTR _regexp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_xmlRegPrintState
	add	esp, 8

; 5447 :     }

	jmp	SHORT $LN5@xmlRegexpP
$LN6@xmlRegexpP:

; 5448 :     fprintf(output, "%d counters:\n", regexp->nbCounters);

	mov	ecx, DWORD PTR _regexp$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	push	OFFSET ??_C@_0O@EOOCDOKK@?$CFd?5counters?3?6@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 5449 :     for (i = 0;i < regexp->nbCounters; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@xmlRegexpP
$LN8@xmlRegexpP:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN10@xmlRegexpP:
	mov	edx, DWORD PTR _regexp$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jge	SHORT $LN1@xmlRegexpP

; 5450 : 	fprintf(output, " %d: min %d max %d\n", i, regexp->counters[i].min,

	mov	ecx, DWORD PTR _regexp$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*8+4]
	push	ecx
	mov	edx, DWORD PTR _regexp$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0BE@LNLBBGGH@?5?$CFd?3?5min?5?$CFd?5max?5?$CFd?6@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 20					; 00000014H

; 5451 : 		                                regexp->counters[i].max);
; 5452 :     }

	jmp	SHORT $LN8@xmlRegexpP
$LN1@xmlRegexpP:

; 5453 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegexpPrint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegexpExec
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_content$ = 12						; size = 4
_xmlRegexpExec PROC					; COMDAT

; 5515 : xmlRegexpExec(xmlRegexpPtr comp, const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5516 :     if ((comp == NULL) || (content == NULL))

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN3@xmlRegexpE
	cmp	DWORD PTR _content$[ebp], 0
	jne	SHORT $LN2@xmlRegexpE
$LN3@xmlRegexpE:

; 5517 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlRegexpE
$LN2@xmlRegexpE:

; 5518 :     return(xmlFARegExec(comp, content));

	mov	eax, DWORD PTR _content$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	call	_xmlFARegExec
	add	esp, 8
$LN1@xmlRegexpE:

; 5519 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlRegexpExec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegFreeRegexp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_regexp$ = 8						; size = 4
_xmlRegFreeRegexp PROC					; COMDAT

; 5568 : xmlRegFreeRegexp(xmlRegexpPtr regexp) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5569 :     int i;
; 5570 :     if (regexp == NULL)

	cmp	DWORD PTR _regexp$[ebp], 0
	jne	SHORT $LN11@xmlRegFree

; 5571 : 	return;

	jmp	$LN1@xmlRegFree
$LN11@xmlRegFree:

; 5572 : 
; 5573 :     if (regexp->string != NULL)

	mov	eax, DWORD PTR _regexp$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN12@xmlRegFree

; 5574 : 	xmlFree(regexp->string);

	mov	esi, esp
	mov	ecx, DWORD PTR _regexp$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlRegFree:

; 5575 :     if (regexp->states != NULL) {

	mov	eax, DWORD PTR _regexp$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN13@xmlRegFree

; 5576 : 	for (i = 0;i < regexp->nbStates;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlRegFree
$LN2@xmlRegFree:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlRegFree:
	mov	edx, DWORD PTR _regexp$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jge	SHORT $LN3@xmlRegFree

; 5577 : 	    xmlRegFreeState(regexp->states[i]);

	mov	ecx, DWORD PTR _regexp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_xmlRegFreeState
	add	esp, 4
	jmp	SHORT $LN2@xmlRegFree
$LN3@xmlRegFree:

; 5578 : 	xmlFree(regexp->states);

	mov	esi, esp
	mov	edx, DWORD PTR _regexp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@xmlRegFree:

; 5579 :     }
; 5580 :     if (regexp->atoms != NULL) {

	mov	ecx, DWORD PTR _regexp$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN14@xmlRegFree

; 5581 : 	for (i = 0;i < regexp->nbAtoms;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@xmlRegFree
$LN5@xmlRegFree:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@xmlRegFree:
	mov	eax, DWORD PTR _regexp$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $LN6@xmlRegFree

; 5582 : 	    xmlRegFreeAtom(regexp->atoms[i]);

	mov	edx, DWORD PTR _regexp$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_xmlRegFreeAtom
	add	esp, 4
	jmp	SHORT $LN5@xmlRegFree
$LN6@xmlRegFree:

; 5583 : 	xmlFree(regexp->atoms);

	mov	esi, esp
	mov	eax, DWORD PTR _regexp$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@xmlRegFree:

; 5584 :     }
; 5585 :     if (regexp->counters != NULL)

	mov	edx, DWORD PTR _regexp$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN15@xmlRegFree

; 5586 : 	xmlFree(regexp->counters);

	mov	esi, esp
	mov	eax, DWORD PTR _regexp$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@xmlRegFree:

; 5587 :     if (regexp->compact != NULL)

	mov	edx, DWORD PTR _regexp$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN16@xmlRegFree

; 5588 : 	xmlFree(regexp->compact);

	mov	esi, esp
	mov	eax, DWORD PTR _regexp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@xmlRegFree:

; 5589 :     if (regexp->transdata != NULL)

	mov	edx, DWORD PTR _regexp$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN17@xmlRegFree

; 5590 : 	xmlFree(regexp->transdata);

	mov	esi, esp
	mov	eax, DWORD PTR _regexp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@xmlRegFree:

; 5591 :     if (regexp->stringMap != NULL) {

	mov	edx, DWORD PTR _regexp$[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $LN18@xmlRegFree

; 5592 : 	for (i = 0; i < regexp->nbstrings;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@xmlRegFree
$LN8@xmlRegFree:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@xmlRegFree:
	mov	ecx, DWORD PTR _regexp$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+48]
	jge	SHORT $LN9@xmlRegFree

; 5593 : 	    xmlFree(regexp->stringMap[i]);

	mov	eax, DWORD PTR _regexp$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	esi, esp
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN8@xmlRegFree
$LN9@xmlRegFree:

; 5594 : 	xmlFree(regexp->stringMap);

	mov	esi, esp
	mov	ecx, DWORD PTR _regexp$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@xmlRegFree:

; 5595 :     }
; 5596 : 
; 5597 :     xmlFree(regexp);

	mov	esi, esp
	mov	eax, DWORD PTR _regexp$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlRegFree:

; 5598 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegFreeRegexp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegexpCompile
_TEXT	SEGMENT
tv70 = -12						; size = 4
_ctxt$ = -8						; size = 4
_ret$ = -4						; size = 4
_regexp$ = 8						; size = 4
_xmlRegexpCompile PROC					; COMDAT

; 5466 : xmlRegexpCompile(const xmlChar *regexp) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 5467 :     xmlRegexpPtr ret;
; 5468 :     xmlRegParserCtxtPtr ctxt;
; 5469 : 
; 5470 :     ctxt = xmlRegNewParserCtxt(regexp);

	mov	eax, DWORD PTR _regexp$[ebp]
	push	eax
	call	_xmlRegNewParserCtxt
	add	esp, 4
	mov	DWORD PTR _ctxt$[ebp], eax

; 5471 :     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlRegexpC

; 5472 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlRegexpC
$LN2@xmlRegexpC:

; 5473 : 
; 5474 :     /* initialize the parser */
; 5475 :     ctxt->end = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 5476 :     ctxt->start = ctxt->state = xmlRegNewState(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegNewState
	add	esp, 4
	mov	DWORD PTR tv70[ebp], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR tv70[ebp]
	mov	DWORD PTR [edx+16], eax

; 5477 :     xmlRegStatePush(ctxt, ctxt->start);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegStatePush
	add	esp, 8

; 5478 : 
; 5479 :     /* parse the expression building an automata */
; 5480 :     xmlFAParseRegExp(ctxt, 1);

	push	1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFAParseRegExp
	add	esp, 8

; 5481 :     if (CUR != 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@xmlRegexpC

; 5482 : 	ERROR("xmlFAParseRegExp: extra characters");

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1450			; 000005aaH
	push	OFFSET ??_C@_0CD@GPPIOFAL@xmlFAParseRegExp?3?5extra?5charact@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegexpErrCompile
	add	esp, 8
$LN3@xmlRegexpC:

; 5483 :     }
; 5484 :     if (ctxt->error != 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN4@xmlRegexpC

; 5485 : 	xmlRegFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegFreeParserCtxt
	add	esp, 4

; 5486 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlRegexpC
$LN4@xmlRegexpC:

; 5487 :     }
; 5488 :     ctxt->end = ctxt->state;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+20], edx

; 5489 :     ctxt->start->type = XML_REGEXP_START_STATE;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx], 1

; 5490 :     ctxt->end->type = XML_REGEXP_FINAL_STATE;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [eax], 2

; 5491 : 
; 5492 :     /* remove the Epsilon except for counted transitions */
; 5493 :     xmlFAEliminateEpsilonTransitions(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFAEliminateEpsilonTransitions
	add	esp, 4

; 5494 : 
; 5495 : 
; 5496 :     if (ctxt->error != 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN5@xmlRegexpC

; 5497 : 	xmlRegFreeParserCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRegFreeParserCtxt
	add	esp, 4

; 5498 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlRegexpC
$LN5@xmlRegexpC:

; 5499 :     }
; 5500 :     ret = xmlRegEpxFromParse(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRegEpxFromParse
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 5501 :     xmlRegFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRegFreeParserCtxt
	add	esp, 4

; 5502 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlRegexpC:

; 5503 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegexpCompile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
tv81 = -20						; size = 4
__Result$1 = -16					; size = 4
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __BufferCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	edx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR [eax+4]
	push	edx
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$1[ebp], eax

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$1[ebp], 0
	jge	SHORT $LN5@snprintf
	mov	DWORD PTR tv81[ebp], -1
	jmp	SHORT $LN3@snprintf
$LN5@snprintf:
	mov	eax, DWORD PTR __Result$1[ebp]
	mov	DWORD PTR tv81[ebp], eax
$LN3@snprintf:

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 1954 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1955 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1956 :     }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = -16						; size = 4
__Stream$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx
	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Stream$[ebp], eax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Stream$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	DWORD PTR __Result$[ebp], eax

; 959  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 960  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 961  :     }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Stream$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 842  :     }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
