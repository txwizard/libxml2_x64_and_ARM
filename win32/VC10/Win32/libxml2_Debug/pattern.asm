; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\pattern.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__69230394_pattern@c DB 01H
msvcjmc	ENDS
PUBLIC	_xmlFreePattern
PUBLIC	_xmlFreePatternList
PUBLIC	_xmlPatterncompile
PUBLIC	_xmlPatternMatch
PUBLIC	_xmlPatternStreamable
PUBLIC	_xmlPatternMaxDepth
PUBLIC	_xmlPatternMinDepth
PUBLIC	_xmlPatternFromRoot
PUBLIC	_xmlPatternGetStreamCtxt
PUBLIC	_xmlFreeStreamCtxt
PUBLIC	_xmlStreamPushNode
PUBLIC	_xmlStreamPush
PUBLIC	_xmlStreamPushAttr
PUBLIC	_xmlStreamPop
PUBLIC	_xmlStreamWantsAnyNode
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ ; `string'
PUBLIC	??_C@_05GPGNDLEK@child@				; `string'
PUBLIC	??_C@_09HGIEBAJ@attribute@			; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlDictReference:PROC
EXTRN	_xmlDictFree:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlCharInRange:PROC
EXTRN	_xmlStringCurrentChar:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_09HGIEBAJ@attribute@
CONST	SEGMENT
??_C@_09HGIEBAJ@attribute@ DB 'attribute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GPGNDLEK@child@
CONST	SEGMENT
??_C@_05GPGNDLEK@child@ DB 'child', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
CONST	SEGMENT
??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ DB 'http://ww'
	DB	'w.w3.org/XML/1998/namespace', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamPushInternal
_TEXT	SEGMENT
tv317 = -80						; size = 4
tv318 = -76						; size = 4
tv231 = -72						; size = 4
tv232 = -68						; size = 4
_step$ = -60						; size = 16
_comp$ = -40						; size = 4
_desc$ = -36						; size = 4
_stepNr$ = -32						; size = 4
_match$ = -28						; size = 4
_m$ = -24						; size = 4
_i$ = -20						; size = 4
_tmp$ = -16						; size = 4
_final$ = -12						; size = 4
_err$ = -8						; size = 4
_ret$ = -4						; size = 4
_stream$ = 8						; size = 4
_name$ = 12						; size = 4
_ns$ = 16						; size = 4
_nodeType$ = 20						; size = 4
_xmlStreamPushInternal PROC				; COMDAT

; 1860 : 		      int nodeType) {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	edi
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 1861 :     int ret = 0, err = 0, final = 0, tmp, i, m, match, stepNr, desc;

	mov	DWORD PTR _ret$[ebp], 0
	mov	DWORD PTR _err$[ebp], 0
	mov	DWORD PTR _final$[ebp], 0

; 1862 :     xmlStreamCompPtr comp;
; 1863 :     xmlStreamStep step;
; 1864 : #ifdef DEBUG_STREAMING
; 1865 :     xmlStreamCtxtPtr orig = stream;
; 1866 : #endif
; 1867 : 
; 1868 :     if ((stream == NULL) || (stream->nbState < 0))

	cmp	DWORD PTR _stream$[ebp], 0
	je	SHORT $LN7@xmlStreamP
	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jge	SHORT $LN2@xmlStreamP
$LN7@xmlStreamP:

; 1869 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlStreamP
$LN2@xmlStreamP:

; 1870 : 
; 1871 :     while (stream != NULL) {

	cmp	DWORD PTR _stream$[ebp], 0
	je	$LN3@xmlStreamP

; 1872 : 	comp = stream->comp;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _comp$[ebp], edx

; 1873 : 
; 1874 : 	if ((nodeType == XML_ELEMENT_NODE) &&
; 1875 : 	    (name == NULL) && (ns == NULL)) {

	cmp	DWORD PTR _nodeType$[ebp], 1
	jne	$LN8@xmlStreamP
	cmp	DWORD PTR _name$[ebp], 0
	jne	$LN8@xmlStreamP
	cmp	DWORD PTR _ns$[ebp], 0
	jne	$LN8@xmlStreamP

; 1876 : 	    /* We have a document node here (or a reset). */
; 1877 : 	    stream->nbState = 0;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1878 : 	    stream->level = 0;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 1879 : 	    stream->blockLevel = -1;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+28], -1

; 1880 : 	    if (comp->flags & XML_STREAM_FROM_ROOT) {

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 32768				; 00008000H
	je	$LN9@xmlStreamP

; 1881 : 		if (comp->nbStep == 0) {

	mov	edx, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN10@xmlStreamP

; 1882 : 		    /* TODO: We have a "/." here? */
; 1883 : 		    ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 1884 : 		} else {

	jmp	SHORT $LN9@xmlStreamP
$LN10@xmlStreamP:

; 1885 : 		    if ((comp->nbStep == 1) &&
; 1886 : 			(comp->steps[0].nodeType == XML_STREAM_ANY_NODE) &&

	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN12@xmlStreamP
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	DWORD PTR [ecx+edx+12], 100		; 00000064H
	jne	SHORT $LN12@xmlStreamP
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+eax]
	and	eax, 1
	je	SHORT $LN12@xmlStreamP

; 1887 : 			(comp->steps[0].flags & XML_STREAM_STEP_DESC))
; 1888 : 		    {
; 1889 : 			/*
; 1890 : 			* In the case of "//." the document node will match
; 1891 : 			* as well.
; 1892 : 			*/
; 1893 : 			ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
	jmp	SHORT $LN9@xmlStreamP
$LN12@xmlStreamP:

; 1894 : 		    } else if (comp->steps[0].flags & XML_STREAM_STEP_ROOT) {

	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+edx]
	and	edx, 4
	je	SHORT $LN9@xmlStreamP

; 1895 : 			/* TODO: Do we need this ? */
; 1896 : 			tmp = xmlStreamCtxtAddState(stream, 0, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	_xmlStreamCtxtAddState
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp$[ebp], eax

; 1897 : 			if (tmp < 0)

	cmp	DWORD PTR _tmp$[ebp], 0
	jge	SHORT $LN9@xmlStreamP

; 1898 : 			    err++;

	mov	ecx, DWORD PTR _err$[ebp]
	add	ecx, 1
	mov	DWORD PTR _err$[ebp], ecx
$LN9@xmlStreamP:

; 1899 : 		    }
; 1900 : 		}
; 1901 : 	    }
; 1902 : 	    stream = stream->next;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _stream$[ebp], eax

; 1903 : 	    continue; /* while */

	jmp	$LN2@xmlStreamP
$LN8@xmlStreamP:

; 1904 : 	}
; 1905 : 
; 1906 : 	/*
; 1907 : 	* Fast check for ".".
; 1908 : 	*/
; 1909 : 	if (comp->nbStep == 0) {

	mov	ecx, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN16@xmlStreamP

; 1910 : 	    /*
; 1911 : 	     * / and . are handled at the XPath node set creation
; 1912 : 	     * level by checking min depth
; 1913 : 	     */
; 1914 : 	    if (stream->flags & XML_PATTERN_XPATH) {

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, 1
	je	SHORT $LN17@xmlStreamP

; 1915 : 		stream = stream->next;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _stream$[ebp], edx

; 1916 : 		continue; /* while */

	jmp	$LN2@xmlStreamP
$LN17@xmlStreamP:

; 1917 : 	    }
; 1918 : 	    /*
; 1919 : 	    * For non-pattern like evaluation like XML Schema IDCs
; 1920 : 	    * or traditional XPath expressions, this will match if
; 1921 : 	    * we are at the first level only, otherwise on every level.
; 1922 : 	    */
; 1923 : 	    if ((nodeType != XML_ATTRIBUTE_NODE) &&

	cmp	DWORD PTR _nodeType$[ebp], 2
	je	SHORT $LN18@xmlStreamP
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, 7
	je	SHORT $LN19@xmlStreamP
	mov	edx, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN18@xmlStreamP
$LN19@xmlStreamP:

; 1924 : 		(((stream->flags & XML_PATTERN_NOTPATTERN) == 0) ||
; 1925 : 		(stream->level == 0))) {
; 1926 : 		    ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN18@xmlStreamP:

; 1927 : 	    }
; 1928 : 	    stream->level++;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1929 : 	    goto stream_next;

	jmp	$stream_next$93
$LN16@xmlStreamP:

; 1930 : 	}
; 1931 : 	if (stream->blockLevel != -1) {

	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax+28], -1
	je	SHORT $LN20@xmlStreamP

; 1932 : 	    /*
; 1933 : 	    * Skip blocked expressions.
; 1934 : 	    */
; 1935 : 	    stream->level++;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 1
	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+16], edx

; 1936 : 	    goto stream_next;

	jmp	$stream_next$93
$LN20@xmlStreamP:

; 1937 : 	}
; 1938 : 
; 1939 : 	if ((nodeType != XML_ELEMENT_NODE) &&
; 1940 : 	    (nodeType != XML_ATTRIBUTE_NODE) &&

	cmp	DWORD PTR _nodeType$[ebp], 1
	je	SHORT $LN21@xmlStreamP
	cmp	DWORD PTR _nodeType$[ebp], 2
	je	SHORT $LN21@xmlStreamP
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, 16384				; 00004000H
	jne	SHORT $LN21@xmlStreamP

; 1941 : 	    ((comp->flags & XML_STREAM_FINAL_IS_ANY_NODE) == 0)) {
; 1942 : 	    /*
; 1943 : 	    * No need to process nodes of other types if we don't
; 1944 : 	    * resolve to those types.
; 1945 : 	    * TODO: Do we need to block the context here?
; 1946 : 	    */
; 1947 : 	    stream->level++;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1948 : 	    goto stream_next;

	jmp	$stream_next$93
$LN21@xmlStreamP:

; 1949 : 	}
; 1950 : 
; 1951 : 	/*
; 1952 : 	 * Check evolution of existing states
; 1953 : 	 */
; 1954 : 	i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 1955 : 	m = stream->nbState;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _m$[ebp], ecx
$LN4@xmlStreamP:

; 1956 : 	while (i < m) {

	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _m$[ebp]
	jge	$LN5@xmlStreamP

; 1957 : 	    if ((comp->flags & XML_STREAM_DESC) == 0) {

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 65536				; 00010000H
	jne	SHORT $LN22@xmlStreamP

; 1958 : 		/*
; 1959 : 		* If there is no "//", then only the last
; 1960 : 		* added state is of interest.
; 1961 : 		*/
; 1962 : 		stepNr = stream->states[2 * (stream->nbState -1)];

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [eax+eax-2]
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _stepNr$[ebp], ecx

; 1963 : 		/*
; 1964 : 		* TODO: Security check, should not happen, remove it.
; 1965 : 		*/
; 1966 : 		if (stream->states[(2 * (stream->nbState -1)) + 1] <

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [eax+eax-2]
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4+4]
	cmp	eax, DWORD PTR [edx+16]
	jge	SHORT $LN24@xmlStreamP

; 1967 : 		    stream->level) {
; 1968 : 		    return (-1);

	or	eax, -1
	jmp	$LN1@xmlStreamP
$LN24@xmlStreamP:

; 1969 : 		}
; 1970 : 		desc = 0;

	mov	DWORD PTR _desc$[ebp], 0

; 1971 : 		/* loop-stopper */
; 1972 : 		i = m;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR _i$[ebp], ecx

; 1973 : 	    } else {

	jmp	SHORT $LN23@xmlStreamP
$LN22@xmlStreamP:

; 1974 : 		/*
; 1975 : 		* If there are "//", then we need to process every "//"
; 1976 : 		* occuring in the states, plus any other state for this
; 1977 : 		* level.
; 1978 : 		*/
; 1979 : 		stepNr = stream->states[2 * i];

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _stepNr$[ebp], edx

; 1980 : 
; 1981 : 		/* TODO: should not happen anymore: dead states */
; 1982 : 		if (stepNr < 0)

	cmp	DWORD PTR _stepNr$[ebp], 0
	jge	SHORT $LN25@xmlStreamP

; 1983 : 		    goto next_state;

	jmp	$next_state$94
$LN25@xmlStreamP:

; 1984 : 
; 1985 : 		tmp = stream->states[(2 * i) + 1];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+eax*4+4]
	mov	DWORD PTR _tmp$[ebp], eax

; 1986 : 
; 1987 : 		/* skip new states just added */
; 1988 : 		if (tmp > stream->level)

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR _tmp$[ebp]
	cmp	edx, DWORD PTR [ecx+16]
	jle	SHORT $LN26@xmlStreamP

; 1989 : 		    goto next_state;

	jmp	$next_state$94
$LN26@xmlStreamP:

; 1990 : 
; 1991 : 		/* skip states at ancestor levels, except if "//" */
; 1992 : 		desc = comp->steps[stepNr].flags & XML_STREAM_STEP_DESC;

	mov	eax, DWORD PTR _stepNr$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+eax]
	and	eax, 1
	mov	DWORD PTR _desc$[ebp], eax

; 1993 : 		if ((tmp < stream->level) && (!desc))

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR _tmp$[ebp]
	cmp	edx, DWORD PTR [ecx+16]
	jge	SHORT $LN23@xmlStreamP
	cmp	DWORD PTR _desc$[ebp], 0
	jne	SHORT $LN23@xmlStreamP

; 1994 : 		    goto next_state;

	jmp	$next_state$94
$LN23@xmlStreamP:

; 1995 : 	    }
; 1996 : 	    /*
; 1997 : 	    * Check for correct node-type.
; 1998 : 	    */
; 1999 : 	    step = comp->steps[stepNr];

	mov	eax, DWORD PTR _stepNr$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _step$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _step$[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _step$[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _step$[ebp+12], ecx

; 2000 : 	    if (step.nodeType != nodeType) {

	mov	edx, DWORD PTR _step$[ebp+12]
	cmp	edx, DWORD PTR _nodeType$[ebp]
	je	SHORT $LN28@xmlStreamP

; 2001 : 		if (step.nodeType == XML_ATTRIBUTE_NODE) {

	cmp	DWORD PTR _step$[ebp+12], 2
	jne	SHORT $LN29@xmlStreamP

; 2002 : 		    /*
; 2003 : 		    * Block this expression for deeper evaluation.
; 2004 : 		    */
; 2005 : 		    if ((comp->flags & XML_STREAM_DESC) == 0)

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 65536				; 00010000H
	jne	SHORT $LN31@xmlStreamP

; 2006 : 			stream->blockLevel = stream->level +1;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+28], eax
$LN31@xmlStreamP:

; 2007 : 		    goto next_state;

	jmp	$next_state$94
	jmp	SHORT $LN28@xmlStreamP
$LN29@xmlStreamP:

; 2008 : 		} else if (step.nodeType != XML_STREAM_ANY_NODE)

	cmp	DWORD PTR _step$[ebp+12], 100		; 00000064H
	je	SHORT $LN28@xmlStreamP

; 2009 : 		    goto next_state;

	jmp	$next_state$94
$LN28@xmlStreamP:

; 2010 : 	    }
; 2011 : 	    /*
; 2012 : 	    * Compare local/namespace-name.
; 2013 : 	    */
; 2014 : 	    match = 0;

	mov	DWORD PTR _match$[ebp], 0

; 2015 : 	    if (step.nodeType == XML_STREAM_ANY_NODE) {

	cmp	DWORD PTR _step$[ebp+12], 100		; 00000064H
	jne	SHORT $LN33@xmlStreamP

; 2016 : 		match = 1;

	mov	DWORD PTR _match$[ebp], 1
	jmp	$LN34@xmlStreamP
$LN33@xmlStreamP:

; 2017 : 	    } else if (step.name == NULL) {

	cmp	DWORD PTR _step$[ebp+4], 0
	jne	SHORT $LN35@xmlStreamP

; 2018 : 		if (step.ns == NULL) {

	cmp	DWORD PTR _step$[ebp+8], 0
	jne	SHORT $LN37@xmlStreamP

; 2019 : 		    /*
; 2020 : 		    * This lets through all elements/attributes.
; 2021 : 		    */
; 2022 : 		    match = 1;

	mov	DWORD PTR _match$[ebp], 1
	jmp	SHORT $LN38@xmlStreamP
$LN37@xmlStreamP:

; 2023 : 		} else if (ns != NULL)

	cmp	DWORD PTR _ns$[ebp], 0
	je	SHORT $LN38@xmlStreamP

; 2024 : 		    match = xmlStrEqual(step.ns, ns);

	mov	edx, DWORD PTR _ns$[ebp]
	push	edx
	mov	eax, DWORD PTR _step$[ebp+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	mov	DWORD PTR _match$[ebp], eax
$LN38@xmlStreamP:

; 2025 : 	    } else if (((step.ns != NULL) == (ns != NULL)) &&

	jmp	$LN34@xmlStreamP
$LN35@xmlStreamP:

; 2026 : 		(name != NULL) &&
; 2027 : 		(step.name[0] == name[0]) &&
; 2028 : 		xmlStrEqual(step.name, name) &&

	cmp	DWORD PTR _step$[ebp+8], 0
	je	SHORT $LN82@xmlStreamP
	mov	DWORD PTR tv232[ebp], 1
	jmp	SHORT $LN83@xmlStreamP
$LN82@xmlStreamP:
	mov	DWORD PTR tv232[ebp], 0
$LN83@xmlStreamP:
	cmp	DWORD PTR _ns$[ebp], 0
	je	SHORT $LN80@xmlStreamP
	mov	DWORD PTR tv231[ebp], 1
	jmp	SHORT $LN81@xmlStreamP
$LN80@xmlStreamP:
	mov	DWORD PTR tv231[ebp], 0
$LN81@xmlStreamP:
	mov	ecx, DWORD PTR tv232[ebp]
	cmp	ecx, DWORD PTR tv231[ebp]
	jne	SHORT $LN34@xmlStreamP
	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN34@xmlStreamP
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _step$[ebp+4]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _name$[ebp]
	movzx	ecx, BYTE PTR [eax+ecx]
	cmp	edx, ecx
	jne	SHORT $LN34@xmlStreamP
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _step$[ebp+4]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN34@xmlStreamP
	mov	ecx, DWORD PTR _step$[ebp+8]
	cmp	ecx, DWORD PTR _ns$[ebp]
	je	SHORT $LN41@xmlStreamP
	mov	edx, DWORD PTR _ns$[ebp]
	push	edx
	mov	eax, DWORD PTR _step$[ebp+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN34@xmlStreamP
$LN41@xmlStreamP:

; 2029 : 		((step.ns == ns) || xmlStrEqual(step.ns, ns)))
; 2030 : 	    {
; 2031 : 		match = 1;

	mov	DWORD PTR _match$[ebp], 1
$LN34@xmlStreamP:

; 2032 : 	    }
; 2033 : #if 0
; 2034 : /*
; 2035 : * TODO: Pointer comparison won't work, since not guaranteed that the given
; 2036 : *  values are in the same dict; especially if it's the namespace name,
; 2037 : *  normally coming from ns->href. We need a namespace dict mechanism !
; 2038 : */
; 2039 : 	    } else if (comp->dict) {
; 2040 : 		if (step.name == NULL) {
; 2041 : 		    if (step.ns == NULL)
; 2042 : 			match = 1;
; 2043 : 		    else
; 2044 : 			match = (step.ns == ns);
; 2045 : 		} else {
; 2046 : 		    match = ((step.name == name) && (step.ns == ns));
; 2047 : 		}
; 2048 : #endif /* if 0 ------------------------------------------------------- */
; 2049 : 	    if (match) {

	cmp	DWORD PTR _match$[ebp], 0
	je	SHORT $LN42@xmlStreamP

; 2050 : 		final = step.flags & XML_STREAM_STEP_FINAL;

	mov	ecx, DWORD PTR _step$[ebp]
	and	ecx, 2
	mov	DWORD PTR _final$[ebp], ecx

; 2051 : 		if (desc) {

	cmp	DWORD PTR _desc$[ebp], 0
	je	SHORT $LN43@xmlStreamP

; 2052 : 		    if (final) {

	cmp	DWORD PTR _final$[ebp], 0
	je	SHORT $LN45@xmlStreamP

; 2053 : 			ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 2054 : 		    } else {

	jmp	SHORT $LN46@xmlStreamP
$LN45@xmlStreamP:

; 2055 : 			/* descending match create a new state */
; 2056 : 			xmlStreamCtxtAddState(stream, stepNr + 1,

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _stepNr$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	_xmlStreamCtxtAddState
	add	esp, 12					; 0000000cH
$LN46@xmlStreamP:

; 2057 : 			                      stream->level + 1);
; 2058 : 		    }
; 2059 : 		} else {

	jmp	SHORT $LN44@xmlStreamP
$LN43@xmlStreamP:

; 2060 : 		    if (final) {

	cmp	DWORD PTR _final$[ebp], 0
	je	SHORT $LN47@xmlStreamP

; 2061 : 			ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 2062 : 		    } else {

	jmp	SHORT $LN44@xmlStreamP
$LN47@xmlStreamP:

; 2063 : 			xmlStreamCtxtAddState(stream, stepNr + 1,

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _stepNr$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	_xmlStreamCtxtAddState
	add	esp, 12					; 0000000cH
$LN44@xmlStreamP:

; 2064 : 			                      stream->level + 1);
; 2065 : 		    }
; 2066 : 		}
; 2067 : 		if ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {

	cmp	DWORD PTR _ret$[ebp], 1
	je	SHORT $LN42@xmlStreamP
	mov	ecx, DWORD PTR _step$[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN42@xmlStreamP

; 2068 : 		    /*
; 2069 : 		    * Check if we have a special case like "foo/bar//.", where
; 2070 : 		    * "foo" is selected as well.
; 2071 : 		    */
; 2072 : 		    ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN42@xmlStreamP:

; 2073 : 		}
; 2074 : 	    }
; 2075 : 	    if (((comp->flags & XML_STREAM_DESC) == 0) &&

	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+16]
	and	eax, 65536				; 00010000H
	jne	SHORT $next_state$94
	cmp	DWORD PTR _match$[ebp], 0
	je	SHORT $LN51@xmlStreamP
	cmp	DWORD PTR _final$[ebp], 0
	je	SHORT $next_state$94
$LN51@xmlStreamP:

; 2076 : 		((! match) || final))  {
; 2077 : 		/*
; 2078 : 		* Mark this expression as blocked for any evaluation at
; 2079 : 		* deeper levels. Note that this includes "/foo"
; 2080 : 		* expressions if the *pattern* behaviour is used.
; 2081 : 		*/
; 2082 : 		stream->blockLevel = stream->level +1;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 1
	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+28], edx
$next_state$94:

; 2083 : 	    }
; 2084 : next_state:
; 2085 : 	    i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 2086 : 	}

	jmp	$LN4@xmlStreamP
$LN5@xmlStreamP:

; 2087 : 
; 2088 : 	stream->level++;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 2089 : 
; 2090 : 	/*
; 2091 : 	* Re/enter the expression.
; 2092 : 	* Don't reenter if it's an absolute expression like "/foo",
; 2093 : 	*   except "//foo".
; 2094 : 	*/
; 2095 : 	step = comp->steps[0];

	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _step$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _step$[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _step$[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _step$[ebp+12], ecx

; 2096 : 	if (step.flags & XML_STREAM_STEP_ROOT)

	mov	edx, DWORD PTR _step$[ebp]
	and	edx, 4
	je	SHORT $LN52@xmlStreamP

; 2097 : 	    goto stream_next;

	jmp	$stream_next$93
$LN52@xmlStreamP:

; 2098 : 
; 2099 : 	desc = step.flags & XML_STREAM_STEP_DESC;

	mov	eax, DWORD PTR _step$[ebp]
	and	eax, 1
	mov	DWORD PTR _desc$[ebp], eax

; 2100 : 	if (stream->flags & XML_PATTERN_NOTPATTERN) {

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	and	edx, 7
	je	SHORT $compare$95

; 2101 : 	    /*
; 2102 : 	    * Re/enter the expression if it is a "descendant" one,
; 2103 : 	    * or if we are at the 1st level of evaluation.
; 2104 : 	    */
; 2105 : 
; 2106 : 	    if (stream->level == 1) {

	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax+16], 1
	jne	SHORT $LN54@xmlStreamP

; 2107 : 		if (XML_STREAM_XS_IDC(stream)) {

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	and	edx, 6
	je	SHORT $LN55@xmlStreamP

; 2108 : 		    /*
; 2109 : 		    * XS-IDC: The missing "self::node()" will always
; 2110 : 		    * match the first given node.
; 2111 : 		    */
; 2112 : 		    goto stream_next;

	jmp	$stream_next$93

; 2113 : 		} else

	jmp	SHORT $LN54@xmlStreamP
$LN55@xmlStreamP:

; 2114 : 		    goto compare;

	jmp	SHORT $compare$95
$LN54@xmlStreamP:

; 2115 : 	    }
; 2116 : 	    /*
; 2117 : 	    * A "//" is always reentrant.
; 2118 : 	    */
; 2119 : 	    if (desc)

	cmp	DWORD PTR _desc$[ebp], 0
	je	SHORT $LN57@xmlStreamP

; 2120 : 		goto compare;

	jmp	SHORT $compare$95
$LN57@xmlStreamP:

; 2121 : 
; 2122 : 	    /*
; 2123 : 	    * XS-IDC: Process the 2nd level, since the missing
; 2124 : 	    * "self::node()" is responsible for the 2nd level being
; 2125 : 	    * the real start level.
; 2126 : 	    */
; 2127 : 	    if ((stream->level == 2) && XML_STREAM_XS_IDC(stream))

	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax+16], 2
	jne	SHORT $LN58@xmlStreamP
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	and	edx, 6
	je	SHORT $LN58@xmlStreamP

; 2128 : 		goto compare;

	jmp	SHORT $compare$95
$LN58@xmlStreamP:

; 2129 : 
; 2130 : 	    goto stream_next;

	jmp	$stream_next$93
$compare$95:

; 2131 : 	}
; 2132 : 
; 2133 : compare:
; 2134 : 	/*
; 2135 : 	* Check expected node-type.
; 2136 : 	*/
; 2137 : 	if (step.nodeType != nodeType) {

	mov	eax, DWORD PTR _step$[ebp+12]
	cmp	eax, DWORD PTR _nodeType$[ebp]
	je	SHORT $LN59@xmlStreamP

; 2138 : 	    if (nodeType == XML_ATTRIBUTE_NODE)

	cmp	DWORD PTR _nodeType$[ebp], 2
	jne	SHORT $LN60@xmlStreamP

; 2139 : 		goto stream_next;

	jmp	$stream_next$93
	jmp	SHORT $LN59@xmlStreamP
$LN60@xmlStreamP:

; 2140 : 	    else if (step.nodeType != XML_STREAM_ANY_NODE)

	cmp	DWORD PTR _step$[ebp+12], 100		; 00000064H
	je	SHORT $LN59@xmlStreamP

; 2141 : 		goto stream_next;

	jmp	$stream_next$93
$LN59@xmlStreamP:

; 2142 : 	}
; 2143 : 	/*
; 2144 : 	* Compare local/namespace-name.
; 2145 : 	*/
; 2146 : 	match = 0;

	mov	DWORD PTR _match$[ebp], 0

; 2147 : 	if (step.nodeType == XML_STREAM_ANY_NODE) {

	cmp	DWORD PTR _step$[ebp+12], 100		; 00000064H
	jne	SHORT $LN63@xmlStreamP

; 2148 : 	    match = 1;

	mov	DWORD PTR _match$[ebp], 1
	jmp	$LN64@xmlStreamP
$LN63@xmlStreamP:

; 2149 : 	} else if (step.name == NULL) {

	cmp	DWORD PTR _step$[ebp+4], 0
	jne	SHORT $LN65@xmlStreamP

; 2150 : 	    if (step.ns == NULL) {

	cmp	DWORD PTR _step$[ebp+8], 0
	jne	SHORT $LN67@xmlStreamP

; 2151 : 		/*
; 2152 : 		* This lets through all elements/attributes.
; 2153 : 		*/
; 2154 : 		match = 1;

	mov	DWORD PTR _match$[ebp], 1
	jmp	SHORT $LN68@xmlStreamP
$LN67@xmlStreamP:

; 2155 : 	    } else if (ns != NULL)

	cmp	DWORD PTR _ns$[ebp], 0
	je	SHORT $LN68@xmlStreamP

; 2156 : 		match = xmlStrEqual(step.ns, ns);

	mov	ecx, DWORD PTR _ns$[ebp]
	push	ecx
	mov	edx, DWORD PTR _step$[ebp+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	mov	DWORD PTR _match$[ebp], eax
$LN68@xmlStreamP:

; 2157 : 	} else if (((step.ns != NULL) == (ns != NULL)) &&

	jmp	$LN64@xmlStreamP
$LN65@xmlStreamP:

; 2158 : 	    (name != NULL) &&
; 2159 : 	    (step.name[0] == name[0]) &&
; 2160 : 	    xmlStrEqual(step.name, name) &&

	cmp	DWORD PTR _step$[ebp+8], 0
	je	SHORT $LN86@xmlStreamP
	mov	DWORD PTR tv318[ebp], 1
	jmp	SHORT $LN87@xmlStreamP
$LN86@xmlStreamP:
	mov	DWORD PTR tv318[ebp], 0
$LN87@xmlStreamP:
	cmp	DWORD PTR _ns$[ebp], 0
	je	SHORT $LN84@xmlStreamP
	mov	DWORD PTR tv317[ebp], 1
	jmp	SHORT $LN85@xmlStreamP
$LN84@xmlStreamP:
	mov	DWORD PTR tv317[ebp], 0
$LN85@xmlStreamP:
	mov	eax, DWORD PTR tv318[ebp]
	cmp	eax, DWORD PTR tv317[ebp]
	jne	SHORT $LN64@xmlStreamP
	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN64@xmlStreamP
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _step$[ebp+4]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _name$[ebp]
	movzx	eax, BYTE PTR [edx+eax]
	cmp	ecx, eax
	jne	SHORT $LN64@xmlStreamP
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _step$[ebp+4]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN64@xmlStreamP
	mov	eax, DWORD PTR _step$[ebp+8]
	cmp	eax, DWORD PTR _ns$[ebp]
	je	SHORT $LN71@xmlStreamP
	mov	ecx, DWORD PTR _ns$[ebp]
	push	ecx
	mov	edx, DWORD PTR _step$[ebp+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN64@xmlStreamP
$LN71@xmlStreamP:

; 2161 : 	    ((step.ns == ns) || xmlStrEqual(step.ns, ns)))
; 2162 : 	{
; 2163 : 	    match = 1;

	mov	DWORD PTR _match$[ebp], 1
$LN64@xmlStreamP:

; 2164 : 	}
; 2165 : 	final = step.flags & XML_STREAM_STEP_FINAL;

	mov	eax, DWORD PTR _step$[ebp]
	and	eax, 2
	mov	DWORD PTR _final$[ebp], eax

; 2166 : 	if (match) {

	cmp	DWORD PTR _match$[ebp], 0
	je	SHORT $LN72@xmlStreamP

; 2167 : 	    if (final)

	cmp	DWORD PTR _final$[ebp], 0
	je	SHORT $LN73@xmlStreamP

; 2168 : 		ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
	jmp	SHORT $LN74@xmlStreamP
$LN73@xmlStreamP:

; 2169 : 	    else
; 2170 : 		xmlStreamCtxtAddState(stream, 1, stream->level);

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	1
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	_xmlStreamCtxtAddState
	add	esp, 12					; 0000000cH
$LN74@xmlStreamP:

; 2171 : 	    if ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {

	cmp	DWORD PTR _ret$[ebp], 1
	je	SHORT $LN72@xmlStreamP
	mov	ecx, DWORD PTR _step$[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN72@xmlStreamP

; 2172 : 		/*
; 2173 : 		* Check if we have a special case like "foo//.", where
; 2174 : 		* "foo" is selected as well.
; 2175 : 		*/
; 2176 : 		ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN72@xmlStreamP:

; 2177 : 	    }
; 2178 : 	}
; 2179 : 	if (((comp->flags & XML_STREAM_DESC) == 0) &&

	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+16]
	and	eax, 65536				; 00010000H
	jne	SHORT $stream_next$93
	cmp	DWORD PTR _match$[ebp], 0
	je	SHORT $LN77@xmlStreamP
	cmp	DWORD PTR _final$[ebp], 0
	je	SHORT $stream_next$93
$LN77@xmlStreamP:

; 2180 : 	    ((! match) || final))  {
; 2181 : 	    /*
; 2182 : 	    * Mark this expression as blocked for any evaluation at
; 2183 : 	    * deeper levels.
; 2184 : 	    */
; 2185 : 	    stream->blockLevel = stream->level;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+28], eax
$stream_next$93:

; 2186 : 	}
; 2187 : 
; 2188 : stream_next:
; 2189 :         stream = stream->next;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _stream$[ebp], edx

; 2190 :     } /* while stream != NULL */

	jmp	$LN2@xmlStreamP
$LN3@xmlStreamP:

; 2191 : 
; 2192 :     if (err > 0)

	cmp	DWORD PTR _err$[ebp], 0
	jle	SHORT $LN78@xmlStreamP

; 2193 :         ret = -1;

	mov	DWORD PTR _ret$[ebp], -1
$LN78@xmlStreamP:

; 2194 : #ifdef DEBUG_STREAMING
; 2195 :     xmlDebugStreamCtxt(orig, ret);
; 2196 : #endif
; 2197 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlStreamP:

; 2198 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN92@xmlStreamP
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN92@xmlStreamP:
	DD	1
	DD	$LN91@xmlStreamP
$LN91@xmlStreamP:
	DD	-60					; ffffffc4H
	DD	16					; 00000010H
	DD	$LN90@xmlStreamP
$LN90@xmlStreamP:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	0
_xmlStreamPushInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamCtxtAddState
_TEXT	SEGMENT
_cur$1 = -8						; size = 4
_i$ = -4						; size = 4
_comp$ = 8						; size = 4
_idx$ = 12						; size = 4
_level$ = 16						; size = 4
_xmlStreamCtxtAddState PROC				; COMDAT

; 1814 : xmlStreamCtxtAddState(xmlStreamCtxtPtr comp, int idx, int level) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 1815 :     int i;
; 1816 :     for (i = 0;i < comp->nbState;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlStreamC
$LN2@xmlStreamC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlStreamC:
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $LN3@xmlStreamC

; 1817 :         if (comp->states[2 * i] < 0) {

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	DWORD PTR [edx+eax*4], 0
	jge	SHORT $LN5@xmlStreamC

; 1818 : 	    comp->states[2 * i] = idx;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _idx$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 1819 : 	    comp->states[2 * i + 1] = level;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _level$[ebp]
	mov	DWORD PTR [ecx+edx*4+4], eax

; 1820 : 	    return(i);

	mov	eax, DWORD PTR _i$[ebp]
	jmp	$LN1@xmlStreamC
$LN5@xmlStreamC:

; 1821 : 	}
; 1822 :     }

	jmp	SHORT $LN2@xmlStreamC
$LN3@xmlStreamC:

; 1823 :     if (comp->nbState >= comp->maxState) {

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+12]
	jl	SHORT $LN6@xmlStreamC

; 1824 :         int *cur;
; 1825 : 
; 1826 : 	cur = (int *) xmlRealloc(comp->states,

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shl	edx, 2
	shl	edx, 2
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cur$1[ebp], eax

; 1827 : 				 comp->maxState * 4 * sizeof(int));
; 1828 : 	if (cur == NULL) {

	cmp	DWORD PTR _cur$1[ebp], 0
	jne	SHORT $LN7@xmlStreamC

; 1829 : 	    ERROR(NULL, NULL, NULL,
; 1830 : 		  "xmlNewStreamCtxt: malloc failed\n");
; 1831 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlStreamC
$LN7@xmlStreamC:

; 1832 : 	}
; 1833 : 	comp->states = cur;

	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR _cur$1[ebp]
	mov	DWORD PTR [edx+20], eax

; 1834 :         comp->maxState *= 2;

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shl	edx, 1
	mov	eax, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN6@xmlStreamC:

; 1835 :     }
; 1836 :     comp->states[2 * comp->nbState] = idx;

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _idx$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1837 :     comp->states[2 * comp->nbState++ + 1] = level;

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _level$[ebp]
	mov	DWORD PTR [ecx+edx*4+4], eax
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1838 :     return(comp->nbState - 1);

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, 1
$LN1@xmlStreamC:

; 1839 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStreamCtxtAddState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlNewStreamCtxt
_TEXT	SEGMENT
_cur$ = -4						; size = 4
_stream$ = 8						; size = 4
_xmlNewStreamCtxt PROC					; COMDAT

; 1760 : xmlNewStreamCtxt(xmlStreamCompPtr stream) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 1761 :     xmlStreamCtxtPtr cur;
; 1762 : 
; 1763 :     cur = (xmlStreamCtxtPtr) xmlMalloc(sizeof(xmlStreamCtxt));

	mov	esi, esp
	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cur$[ebp], eax

; 1764 :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlNewStre

; 1765 : 	ERROR(NULL, NULL, NULL,
; 1766 : 		"xmlNewStreamCtxt: malloc failed\n");
; 1767 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNewStre
$LN2@xmlNewStre:

; 1768 :     }
; 1769 :     memset(cur, 0, sizeof(xmlStreamCtxt));

	xor	eax, eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], eax

; 1770 :     cur->states = (int *) xmlMalloc(4 * 2 * sizeof(int));

	mov	esi, esp
	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+20], eax

; 1771 :     if (cur->states == NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN3@xmlNewStre

; 1772 : 	xmlFree(cur);

	mov	esi, esp
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1773 : 	ERROR(NULL, NULL, NULL,
; 1774 : 	      "xmlNewStreamCtxt: malloc failed\n");
; 1775 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNewStre
$LN3@xmlNewStre:

; 1776 :     }
; 1777 :     cur->nbState = 0;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+8], 0

; 1778 :     cur->maxState = 4;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+12], 4

; 1779 :     cur->level = 0;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 1780 :     cur->comp = stream;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1781 :     cur->blockLevel = -1;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+28], -1

; 1782 :     return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
$LN1@xmlNewStre:

; 1783 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNewStreamCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamCompile
_TEXT	SEGMENT
tv148 = -48						; size = 4
_step$ = -40						; size = 12
_prevs$ = -24						; size = 4
_flags$ = -20						; size = 4
_root$ = -16						; size = 4
_s$ = -12						; size = 4
_i$ = -8						; size = 4
_stream$ = -4						; size = 4
_comp$ = 8						; size = 4
_xmlStreamCompile PROC					; COMDAT

; 1578 : xmlStreamCompile(xmlPatternPtr comp) {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 1579 :     xmlStreamCompPtr stream;
; 1580 :     int i, s = 0, root = 0, flags = 0, prevs = -1;

	mov	DWORD PTR _s$[ebp], 0
	mov	DWORD PTR _root$[ebp], 0
	mov	DWORD PTR _flags$[ebp], 0
	mov	DWORD PTR _prevs$[ebp], -1

; 1581 :     xmlStepOp step;
; 1582 : 
; 1583 :     if ((comp == NULL) || (comp->steps == NULL))

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN8@xmlStreamC
	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN7@xmlStreamC
$LN8@xmlStreamC:

; 1584 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlStreamC
$LN7@xmlStreamC:

; 1585 :     /*
; 1586 :      * special case for .
; 1587 :      */
; 1588 :     if ((comp->nbStep == 1) &&
; 1589 :         (comp->steps[0].op == XML_OP_ELEM) &&
; 1590 : 	(comp->steps[0].value == NULL) &&

	mov	ecx, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [ecx+20], 1
	jne	SHORT $LN9@xmlStreamC
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	DWORD PTR [edx+eax], 2
	jne	SHORT $LN9@xmlStreamC
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+28]
	cmp	DWORD PTR [eax+ecx+4], 0
	jne	SHORT $LN9@xmlStreamC
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx+edx+8], 0
	jne	SHORT $LN9@xmlStreamC

; 1591 : 	(comp->steps[0].value2 == NULL)) {
; 1592 : 	stream = xmlNewStreamComp(0);

	push	0
	call	_xmlNewStreamComp
	add	esp, 4
	mov	DWORD PTR _stream$[ebp], eax

; 1593 : 	if (stream == NULL)

	cmp	DWORD PTR _stream$[ebp], 0
	jne	SHORT $LN10@xmlStreamC

; 1594 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlStreamC
$LN10@xmlStreamC:

; 1595 : 	/* Note that the stream will have no steps in this case. */
; 1596 : 	stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+16]
	or	eax, 16384				; 00004000H
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1597 : 	comp->stream = stream;

	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+32], eax

; 1598 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlStreamC
$LN9@xmlStreamC:

; 1599 :     }
; 1600 : 
; 1601 :     stream = xmlNewStreamComp((comp->nbStep / 2) + 1);

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, 1
	push	eax
	call	_xmlNewStreamComp
	add	esp, 4
	mov	DWORD PTR _stream$[ebp], eax

; 1602 :     if (stream == NULL)

	cmp	DWORD PTR _stream$[ebp], 0
	jne	SHORT $LN11@xmlStreamC

; 1603 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlStreamC
$LN11@xmlStreamC:

; 1604 :     if (comp->dict != NULL) {

	mov	edx, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN12@xmlStreamC

; 1605 :         stream->dict = comp->dict;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 1606 : 	xmlDictReference(stream->dict);

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlDictReference
	add	esp, 4
$LN12@xmlStreamC:

; 1607 :     }
; 1608 : 
; 1609 :     i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 1610 :     if (comp->flags & PAT_FROM_ROOT)

	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+16]
	and	eax, 256				; 00000100H
	je	SHORT $LN13@xmlStreamC

; 1611 : 	stream->flags |= XML_STREAM_FROM_ROOT;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	or	edx, 32768				; 00008000H
	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+16], edx
$LN13@xmlStreamC:

; 1612 : 
; 1613 :     for (;i < comp->nbStep;i++) {

	jmp	SHORT $LN4@xmlStreamC
$LN2@xmlStreamC:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlStreamC:
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jge	$LN3@xmlStreamC

; 1614 : 	step = comp->steps[i];

	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _step$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _step$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _step$[ebp+8], eax

; 1615 :         switch (step.op) {

	mov	ecx, DWORD PTR _step$[ebp]
	mov	DWORD PTR tv148[ebp], ecx
	mov	edx, DWORD PTR tv148[ebp]
	sub	edx, 1
	mov	DWORD PTR tv148[ebp], edx
	cmp	DWORD PTR tv148[ebp], 7
	ja	$LN5@xmlStreamC
	mov	eax, DWORD PTR tv148[ebp]
	jmp	DWORD PTR $LN47@xmlStreamC[eax*4]

; 1616 : 	    case XML_OP_END:
; 1617 : 	        break;

	jmp	$LN5@xmlStreamC
$LN15@xmlStreamC:

; 1618 : 	    case XML_OP_ROOT:
; 1619 : 	        if (i != 0)

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN16@xmlStreamC

; 1620 : 		    goto error;

	jmp	$error$48
$LN16@xmlStreamC:

; 1621 : 		root = 1;

	mov	DWORD PTR _root$[ebp], 1

; 1622 : 		break;

	jmp	$LN5@xmlStreamC
$LN17@xmlStreamC:

; 1623 : 	    case XML_OP_NS:
; 1624 : 		s = xmlStreamCompAddStep(stream, NULL, step.value,

	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _step$[ebp+4]
	push	edx
	push	0
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	_xmlStreamCompAddStep
	add	esp, 20					; 00000014H
	mov	DWORD PTR _s$[ebp], eax

; 1625 : 		    XML_ELEMENT_NODE, flags);
; 1626 : 		if (s < 0)

	cmp	DWORD PTR _s$[ebp], 0
	jge	SHORT $LN18@xmlStreamC

; 1627 : 		    goto error;

	jmp	$error$48
$LN18@xmlStreamC:

; 1628 : 		prevs = s;

	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR _prevs$[ebp], ecx

; 1629 : 		flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 1630 : 		break;

	jmp	$LN5@xmlStreamC
$LN19@xmlStreamC:

; 1631 : 	    case XML_OP_ATTR:
; 1632 : 		flags |= XML_STREAM_STEP_ATTR;

	mov	edx, DWORD PTR _flags$[ebp]
	or	edx, 8
	mov	DWORD PTR _flags$[ebp], edx

; 1633 : 		prevs = -1;

	mov	DWORD PTR _prevs$[ebp], -1

; 1634 : 		s = xmlStreamCompAddStep(stream,

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _step$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _step$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	_xmlStreamCompAddStep
	add	esp, 20					; 00000014H
	mov	DWORD PTR _s$[ebp], eax

; 1635 : 		    step.value, step.value2, XML_ATTRIBUTE_NODE, flags);
; 1636 : 		flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 1637 : 		if (s < 0)

	cmp	DWORD PTR _s$[ebp], 0
	jge	SHORT $LN20@xmlStreamC

; 1638 : 		    goto error;

	jmp	$error$48
$LN20@xmlStreamC:

; 1639 : 		break;

	jmp	$LN5@xmlStreamC
$LN21@xmlStreamC:

; 1640 : 	    case XML_OP_ELEM:
; 1641 : 	        if ((step.value == NULL) && (step.value2 == NULL)) {

	cmp	DWORD PTR _step$[ebp+4], 0
	jne	$LN22@xmlStreamC
	cmp	DWORD PTR _step$[ebp+8], 0
	jne	$LN22@xmlStreamC

; 1642 : 		    /*
; 1643 : 		    * We have a "." or "self::node()" here.
; 1644 : 		    * Eliminate redundant self::node() tests like in "/./."
; 1645 : 		    * or "//./"
; 1646 : 		    * The only case we won't eliminate is "//.", i.e. if
; 1647 : 		    * self::node() is the last node test and we had
; 1648 : 		    * continuation somewhere beforehand.
; 1649 : 		    */
; 1650 : 		    if ((comp->nbStep == i + 1) &&

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [edx+20], ecx
	jne	$LN23@xmlStreamC
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	$LN23@xmlStreamC

; 1651 : 			(flags & XML_STREAM_STEP_DESC)) {
; 1652 : 			/*
; 1653 : 			* Mark the special case where the expression resolves
; 1654 : 			* to any type of node.
; 1655 : 			*/
; 1656 : 			if (comp->nbStep == i + 1) {

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [edx+20], ecx
	jne	SHORT $LN25@xmlStreamC

; 1657 : 			    stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	or	ecx, 16384				; 00004000H
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+16], ecx
$LN25@xmlStreamC:

; 1658 : 			}
; 1659 : 			flags |= XML_STREAM_STEP_NODE;

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 16					; 00000010H
	mov	DWORD PTR _flags$[ebp], eax

; 1660 : 			s = xmlStreamCompAddStep(stream, NULL, NULL,

	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	push	100					; 00000064H
	push	0
	push	0
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	_xmlStreamCompAddStep
	add	esp, 20					; 00000014H
	mov	DWORD PTR _s$[ebp], eax

; 1661 : 			    XML_STREAM_ANY_NODE, flags);
; 1662 : 			if (s < 0)

	cmp	DWORD PTR _s$[ebp], 0
	jge	SHORT $LN26@xmlStreamC

; 1663 : 			    goto error;

	jmp	$error$48
$LN26@xmlStreamC:

; 1664 : 			flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 1665 : 			/*
; 1666 : 			* If there was a previous step, mark it to be added to
; 1667 : 			* the result node-set; this is needed since only
; 1668 : 			* the last step will be marked as "final" and only
; 1669 : 			* "final" nodes are added to the resulting set.
; 1670 : 			*/
; 1671 : 			if (prevs != -1) {

	cmp	DWORD PTR _prevs$[ebp], -1
	je	SHORT $LN27@xmlStreamC

; 1672 : 			    stream->steps[prevs].flags |= XML_STREAM_STEP_IN_SET;

	mov	eax, DWORD PTR _prevs$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+eax]
	or	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _prevs$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [edx+ecx], eax

; 1673 : 			    prevs = -1;

	mov	DWORD PTR _prevs$[ebp], -1
$LN27@xmlStreamC:

; 1674 : 			}
; 1675 : 			break;

	jmp	$LN5@xmlStreamC

; 1676 : 
; 1677 : 		    } else {

	jmp	SHORT $LN22@xmlStreamC
$LN23@xmlStreamC:

; 1678 : 			/* Just skip this one. */
; 1679 : 			continue;

	jmp	$LN2@xmlStreamC
$LN22@xmlStreamC:

; 1680 : 		    }
; 1681 : 		}
; 1682 : 		/* An element node. */
; 1683 : 	        s = xmlStreamCompAddStep(stream, step.value, step.value2,

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _step$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _step$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	_xmlStreamCompAddStep
	add	esp, 20					; 00000014H
	mov	DWORD PTR _s$[ebp], eax

; 1684 : 		    XML_ELEMENT_NODE, flags);
; 1685 : 		if (s < 0)

	cmp	DWORD PTR _s$[ebp], 0
	jge	SHORT $LN28@xmlStreamC

; 1686 : 		    goto error;

	jmp	$error$48
$LN28@xmlStreamC:

; 1687 : 		prevs = s;

	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR _prevs$[ebp], ecx

; 1688 : 		flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 1689 : 		break;

	jmp	$LN5@xmlStreamC
$LN29@xmlStreamC:

; 1690 : 	    case XML_OP_CHILD:
; 1691 : 		/* An element node child. */
; 1692 : 	        s = xmlStreamCompAddStep(stream, step.value, step.value2,

	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _step$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _step$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	_xmlStreamCompAddStep
	add	esp, 20					; 00000014H
	mov	DWORD PTR _s$[ebp], eax

; 1693 : 		    XML_ELEMENT_NODE, flags);
; 1694 : 		if (s < 0)

	cmp	DWORD PTR _s$[ebp], 0
	jge	SHORT $LN30@xmlStreamC

; 1695 : 		    goto error;

	jmp	$error$48
$LN30@xmlStreamC:

; 1696 : 		prevs = s;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _prevs$[ebp], eax

; 1697 : 		flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 1698 : 		break;

	jmp	SHORT $LN5@xmlStreamC
$LN31@xmlStreamC:

; 1699 : 	    case XML_OP_ALL:
; 1700 : 	        s = xmlStreamCompAddStep(stream, NULL, NULL,

	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	push	1
	push	0
	push	0
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	_xmlStreamCompAddStep
	add	esp, 20					; 00000014H
	mov	DWORD PTR _s$[ebp], eax

; 1701 : 		    XML_ELEMENT_NODE, flags);
; 1702 : 		if (s < 0)

	cmp	DWORD PTR _s$[ebp], 0
	jge	SHORT $LN32@xmlStreamC

; 1703 : 		    goto error;

	jmp	$error$48
$LN32@xmlStreamC:

; 1704 : 		prevs = s;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _prevs$[ebp], eax

; 1705 : 		flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 1706 : 		break;

	jmp	SHORT $LN5@xmlStreamC

; 1707 : 	    case XML_OP_PARENT:
; 1708 : 	        break;

	jmp	SHORT $LN5@xmlStreamC
$LN34@xmlStreamC:

; 1709 : 	    case XML_OP_ANCESTOR:
; 1710 : 		/* Skip redundant continuations. */
; 1711 : 		if (flags & XML_STREAM_STEP_DESC)

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 1
	je	SHORT $LN35@xmlStreamC

; 1712 : 		    break;

	jmp	SHORT $LN5@xmlStreamC
$LN35@xmlStreamC:

; 1713 : 	        flags |= XML_STREAM_STEP_DESC;

	mov	edx, DWORD PTR _flags$[ebp]
	or	edx, 1
	mov	DWORD PTR _flags$[ebp], edx

; 1714 : 		/*
; 1715 : 		* Mark the expression as having "//".
; 1716 : 		*/
; 1717 : 		if ((stream->flags & XML_STREAM_DESC) == 0)

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 65536				; 00010000H
	jne	SHORT $LN5@xmlStreamC

; 1718 : 		    stream->flags |= XML_STREAM_DESC;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+16]
	or	eax, 65536				; 00010000H
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN5@xmlStreamC:

; 1719 : 		break;
; 1720 : 	}
; 1721 :     }

	jmp	$LN2@xmlStreamC
$LN3@xmlStreamC:

; 1722 :     if ((! root) && (comp->flags & XML_PATTERN_NOTPATTERN) == 0) {

	cmp	DWORD PTR _root$[ebp], 0
	jne	SHORT $LN37@xmlStreamC
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+16]
	and	eax, 7
	jne	SHORT $LN37@xmlStreamC

; 1723 : 	/*
; 1724 : 	* If this should behave like a real pattern, we will mark
; 1725 : 	* the first step as having "//", to be reentrant on every
; 1726 : 	* tree level.
; 1727 : 	*/
; 1728 : 	if ((stream->flags & XML_STREAM_DESC) == 0)

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, 65536				; 00010000H
	jne	SHORT $LN38@xmlStreamC

; 1729 : 	    stream->flags |= XML_STREAM_DESC;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	or	ecx, 65536				; 00010000H
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+16], ecx
$LN38@xmlStreamC:

; 1730 : 
; 1731 : 	if (stream->nbStep > 0) {

	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jle	SHORT $LN37@xmlStreamC

; 1732 : 	    if ((stream->steps[0].flags & XML_STREAM_STEP_DESC) == 0)

	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+edx]
	and	edx, 1
	jne	SHORT $LN37@xmlStreamC

; 1733 : 		stream->steps[0].flags |= XML_STREAM_STEP_DESC;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+ecx]
	or	ecx, 1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	mov	edx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [edx+eax], ecx
$LN37@xmlStreamC:

; 1734 : 	}
; 1735 :     }
; 1736 :     if (stream->nbStep <= s)

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _s$[ebp]
	jg	SHORT $LN41@xmlStreamC

; 1737 : 	goto error;

	jmp	SHORT $error$48
$LN41@xmlStreamC:

; 1738 :     stream->steps[s].flags |= XML_STREAM_STEP_FINAL;

	mov	edx, DWORD PTR _s$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+edx]
	or	edx, 2
	mov	eax, DWORD PTR _s$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+eax], edx

; 1739 :     if (root)

	cmp	DWORD PTR _root$[ebp], 0
	je	SHORT $LN42@xmlStreamC

; 1740 : 	stream->steps[0].flags |= XML_STREAM_STEP_ROOT;

	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+eax]
	or	eax, 4
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+edx], eax
$LN42@xmlStreamC:

; 1741 : #ifdef DEBUG_STREAMING
; 1742 :     xmlDebugStreamComp(stream);
; 1743 : #endif
; 1744 :     comp->stream = stream;

	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+32], eax

; 1745 :     return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlStreamC
$error$48:

; 1746 : error:
; 1747 :     xmlFreeStreamComp(stream);

	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	_xmlFreeStreamComp
	add	esp, 4

; 1748 :     return(0);

	xor	eax, eax
$LN1@xmlStreamC:

; 1749 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN46@xmlStreamC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN46@xmlStreamC:
	DD	1
	DD	$LN45@xmlStreamC
$LN45@xmlStreamC:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN44@xmlStreamC
$LN44@xmlStreamC:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	0
	npad	3
$LN47@xmlStreamC:
	DD	$LN15@xmlStreamC
	DD	$LN21@xmlStreamC
	DD	$LN29@xmlStreamC
	DD	$LN19@xmlStreamC
	DD	$LN5@xmlStreamC
	DD	$LN34@xmlStreamC
	DD	$LN17@xmlStreamC
	DD	$LN31@xmlStreamC
_xmlStreamCompile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamCompAddStep
_TEXT	SEGMENT
_cur$ = -4						; size = 4
_comp$ = 8						; size = 4
_name$ = 12						; size = 4
_ns$ = 16						; size = 4
_nodeType$ = 20						; size = 4
_flags$ = 24						; size = 4
_xmlStreamCompAddStep PROC				; COMDAT

; 1547 :                      const xmlChar *ns, int nodeType, int flags) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 1548 :     xmlStreamStepPtr cur;
; 1549 : 
; 1550 :     if (comp->nbStep >= comp->maxStep) {

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jl	SHORT $LN2@xmlStreamC

; 1551 : 	cur = (xmlStreamStepPtr) xmlRealloc(comp->steps,

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	shl	ecx, 4
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cur$[ebp], eax

; 1552 : 				 comp->maxStep * 2 * sizeof(xmlStreamStep));
; 1553 : 	if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN3@xmlStreamC

; 1554 : 	    ERROR(NULL, NULL, NULL,
; 1555 : 		  "xmlNewStreamComp: malloc failed\n");
; 1556 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlStreamC
$LN3@xmlStreamC:

; 1557 : 	}
; 1558 : 	comp->steps = cur;

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 1559 :         comp->maxStep *= 2;

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN2@xmlStreamC:

; 1560 :     }
; 1561 :     cur = &comp->steps[comp->nbStep++];

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	mov	edx, DWORD PTR _comp$[ebp]
	add	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$[ebp], ecx
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1562 :     cur->flags = flags;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [eax], ecx

; 1563 :     cur->name = name;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1564 :     cur->ns = ns;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _ns$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1565 :     cur->nodeType = nodeType;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _nodeType$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 1566 :     return(comp->nbStep - 1);

	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
$LN1@xmlStreamC:

; 1567 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStreamCompAddStep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlNewStreamComp
_TEXT	SEGMENT
_cur$ = -4						; size = 4
_size$ = 8						; size = 4
_xmlNewStreamComp PROC					; COMDAT

; 1492 : xmlNewStreamComp(int size) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 1493 :     xmlStreamCompPtr cur;
; 1494 : 
; 1495 :     if (size < 4)

	cmp	DWORD PTR _size$[ebp], 4
	jge	SHORT $LN2@xmlNewStre

; 1496 :         size  = 4;

	mov	DWORD PTR _size$[ebp], 4
$LN2@xmlNewStre:

; 1497 : 
; 1498 :     cur = (xmlStreamCompPtr) xmlMalloc(sizeof(xmlStreamComp));

	mov	esi, esp
	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cur$[ebp], eax

; 1499 :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN3@xmlNewStre

; 1500 : 	ERROR(NULL, NULL, NULL,
; 1501 : 		"xmlNewStreamComp: malloc failed\n");
; 1502 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNewStre
$LN3@xmlNewStre:

; 1503 :     }
; 1504 :     memset(cur, 0, sizeof(xmlStreamComp));

	xor	eax, eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], eax

; 1505 :     cur->steps = (xmlStreamStepPtr) xmlMalloc(size * sizeof(xmlStreamStep));

	mov	edx, DWORD PTR _size$[ebp]
	shl	edx, 4
	mov	esi, esp
	push	edx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1506 :     if (cur->steps == NULL) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN4@xmlNewStre

; 1507 : 	xmlFree(cur);

	mov	esi, esp
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1508 : 	ERROR(NULL, NULL, NULL,
; 1509 : 	      "xmlNewStreamComp: malloc failed\n");
; 1510 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNewStre
$LN4@xmlNewStre:

; 1511 :     }
; 1512 :     cur->nbStep = 0;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 1513 :     cur->maxStep = size;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1514 :     return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
$LN1@xmlNewStre:

; 1515 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNewStreamComp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlCompileIDCXPathPath
_TEXT	SEGMENT
tv371 = -40						; size = 4
tv345 = -36						; size = 4
tv323 = -32						; size = 4
tv290 = -28						; size = 4
tv264 = -24						; size = 4
tv222 = -20						; size = 4
tv196 = -16						; size = 4
tv170 = -12						; size = 4
tv144 = -8						; size = 4
tv89 = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlCompileIDCXPathPath PROC				; COMDAT

; 1330 : xmlCompileIDCXPathPath(xmlPatParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlCompile:

; 1331 :     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN17@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN18@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN17@xmlCompile
$LN18@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN3@xmlCompile
$LN17@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN47@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv89[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN48@xmlCompile
$LN47@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv89[ebp], eax
$LN48@xmlCompile:
	jmp	SHORT $LN2@xmlCompile
$LN3@xmlCompile:

; 1332 :     if (CUR == '/') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN19@xmlCompile

; 1333 : 	ERROR5(NULL, NULL, NULL,
; 1334 : 	    "Unexpected selection of the document root in '%s'.\n",
; 1335 : 	    ctxt->base);
; 1336 : 	goto error;

	jmp	$error$67
$LN19@xmlCompile:

; 1337 :     }
; 1338 :     ctxt->comp->flags |= PAT_FROM_CUR;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+16]
	or	eax, 512				; 00000200H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax

; 1339 : 
; 1340 :     if (CUR == '.') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	jne	$LN12@xmlCompile

; 1341 : 	/* "." - "self::node()" */
; 1342 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN49@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv144[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN4@xmlCompile
$LN49@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv144[ebp], eax
$LN4@xmlCompile:

; 1343 : 	SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN21@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN22@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN21@xmlCompile
$LN22@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN5@xmlCompile
$LN21@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN51@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv170[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN52@xmlCompile
$LN51@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv170[ebp], ecx
$LN52@xmlCompile:
	jmp	SHORT $LN4@xmlCompile
$LN5@xmlCompile:

; 1344 : 	if (CUR == 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN23@xmlCompile

; 1345 : 	    /*
; 1346 : 	    * Selection of the context node.
; 1347 : 	    */
; 1348 : 	    PUSH(XML_OP_ELEM, NULL, NULL);

	push	0
	push	0
	push	2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN24@xmlCompile
	jmp	$error$67
$LN24@xmlCompile:

; 1349 : 	    return;

	jmp	$LN1@xmlCompile
$LN23@xmlCompile:

; 1350 : 	}
; 1351 : 	if (CUR != '/') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN25@xmlCompile

; 1352 : 	    /* TODO: A more meaningful error message. */
; 1353 : 	    ERROR5(NULL, NULL, NULL,
; 1354 : 	    "Unexpected token after '.' in '%s'.\n", ctxt->base);
; 1355 : 	    goto error;

	jmp	$error$67
$LN25@xmlCompile:

; 1356 : 	}
; 1357 : 	/* "./" - "self::node()/" */
; 1358 : 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN53@xmlCompile
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv196[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN6@xmlCompile
$LN53@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv196[ebp], edx
$LN6@xmlCompile:

; 1359 : 	SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN26@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN27@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN26@xmlCompile
$LN27@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN7@xmlCompile
$LN26@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN55@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv222[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN56@xmlCompile
$LN55@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv222[ebp], eax
$LN56@xmlCompile:
	jmp	SHORT $LN6@xmlCompile
$LN7@xmlCompile:

; 1360 : 	if (CUR == '/') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	$LN28@xmlCompile

; 1361 : 	    if (IS_BLANK_CH(PEEKPREV(1))) {

	mov	ecx, 1
	imul	edx, ecx, -1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN30@xmlCompile
	mov	eax, 1
	imul	ecx, eax, -1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 9
	jl	SHORT $LN31@xmlCompile
	mov	edx, 1
	imul	eax, edx, -1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+eax]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN30@xmlCompile
$LN31@xmlCompile:
	mov	ecx, 1
	imul	edx, ecx, -1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN29@xmlCompile
$LN30@xmlCompile:

; 1362 : 		/*
; 1363 : 		* Disallow "./ /"
; 1364 : 		*/
; 1365 : 		ERROR5(NULL, NULL, NULL,
; 1366 : 		    "Unexpected '/' token in '%s'.\n", ctxt->base);
; 1367 : 		goto error;

	jmp	$error$67
$LN29@xmlCompile:

; 1368 : 	    }
; 1369 : 	    /* ".//" - "self:node()/descendant-or-self::node()/" */
; 1370 : 	    PUSH(XML_OP_ANCESTOR, NULL, NULL);

	push	0
	push	0
	push	6
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN32@xmlCompile
	jmp	$error$67
$LN32@xmlCompile:

; 1371 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN57@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv264[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN8@xmlCompile
$LN57@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv264[ebp], eax
$LN8@xmlCompile:

; 1372 : 	    SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN33@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN34@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN33@xmlCompile
$LN34@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN28@xmlCompile
$LN33@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN59@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv290[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN60@xmlCompile
$LN59@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv290[ebp], ecx
$LN60@xmlCompile:
	jmp	SHORT $LN8@xmlCompile
$LN28@xmlCompile:

; 1373 : 	}
; 1374 : 	if (CUR == 0)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN12@xmlCompile

; 1375 : 	    goto error_unfinished;

	jmp	$error_unfinished$68
$LN12@xmlCompile:

; 1376 :     }
; 1377 :     /*
; 1378 :     * Process steps.
; 1379 :     */
; 1380 :     do {
; 1381 : 	xmlCompileStepPattern(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCompileStepPattern
	add	esp, 4

; 1382 : 	if (ctxt->error != 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN13@xmlCompile

; 1383 : 	    goto error;

	jmp	$error$67
$LN13@xmlCompile:

; 1384 : 	SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN37@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN38@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN37@xmlCompile
$LN38@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN14@xmlCompile
$LN37@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN61@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv323[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN62@xmlCompile
$LN61@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv323[ebp], ecx
$LN62@xmlCompile:
	jmp	SHORT $LN13@xmlCompile
$LN14@xmlCompile:

; 1385 : 	if (CUR != '/')

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN39@xmlCompile

; 1386 : 	    break;

	jmp	$LN11@xmlCompile
$LN39@xmlCompile:

; 1387 : 	PUSH(XML_OP_PARENT, NULL, NULL);

	push	0
	push	0
	push	5
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN40@xmlCompile
	jmp	$error$67
$LN40@xmlCompile:

; 1388 : 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN63@xmlCompile
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv345[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN15@xmlCompile
$LN63@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv345[ebp], edx
$LN15@xmlCompile:

; 1389 : 	SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN41@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN42@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN41@xmlCompile
$LN42@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN16@xmlCompile
$LN41@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN65@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv371[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN66@xmlCompile
$LN65@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv371[ebp], eax
$LN66@xmlCompile:
	jmp	SHORT $LN15@xmlCompile
$LN16@xmlCompile:

; 1390 : 	if (CUR == '/') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN43@xmlCompile

; 1391 : 	    /*
; 1392 : 	    * Disallow subsequent '//'.
; 1393 : 	    */
; 1394 : 	    ERROR5(NULL, NULL, NULL,
; 1395 : 		"Unexpected subsequent '//' in '%s'.\n",
; 1396 : 		ctxt->base);
; 1397 : 	    goto error;

	jmp	SHORT $error$67
$LN43@xmlCompile:

; 1398 : 	}
; 1399 : 	if (CUR == 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN10@xmlCompile

; 1400 : 	    goto error_unfinished;

	jmp	SHORT $error_unfinished$68
$LN10@xmlCompile:

; 1401 : 
; 1402 :     } while (CUR != 0);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	$LN12@xmlCompile
$LN11@xmlCompile:

; 1403 : 
; 1404 :     if (CUR != 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN45@xmlCompile

; 1405 : 	ERROR5(NULL, NULL, NULL,
; 1406 : 	    "Failed to compile expression '%s'.\n", ctxt->base);
; 1407 : 	ctxt->error = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN45@xmlCompile:

; 1408 :     }
; 1409 :     return;

	jmp	SHORT $LN1@xmlCompile
$error$67:

; 1410 : error:
; 1411 :     ctxt->error = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1

; 1412 :     return;

	jmp	SHORT $LN1@xmlCompile
$error_unfinished$68:

; 1413 : 
; 1414 : error_unfinished:
; 1415 :     ctxt->error = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN1@xmlCompile:

; 1416 :     ERROR5(NULL, NULL, NULL,
; 1417 : 	"Unfinished expression '%s'.\n", ctxt->base);
; 1418 :     return;
; 1419 : }

	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCompileIDCXPathPath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlCompilePathPattern
_TEXT	SEGMENT
tv503 = -68						; size = 4
tv477 = -64						; size = 4
tv456 = -60						; size = 4
tv430 = -56						; size = 4
tv420 = -52						; size = 4
tv393 = -48						; size = 4
tv359 = -44						; size = 4
tv333 = -40						; size = 4
tv304 = -36						; size = 4
tv277 = -32						; size = 4
tv258 = -28						; size = 4
tv232 = -24						; size = 4
tv222 = -20						; size = 4
tv212 = -16						; size = 4
tv180 = -12						; size = 4
tv170 = -8						; size = 4
tv89 = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlCompilePathPattern PROC				; COMDAT

; 1233 : xmlCompilePathPattern(xmlPatParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	edi
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 17					; 00000011H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlCompile:

; 1234 :     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN18@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN19@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN18@xmlCompile
$LN19@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN3@xmlCompile
$LN18@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN59@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv89[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN60@xmlCompile
$LN59@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv89[ebp], eax
$LN60@xmlCompile:
	jmp	SHORT $LN2@xmlCompile
$LN3@xmlCompile:

; 1235 :     if (CUR == '/') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN20@xmlCompile

; 1236 :         ctxt->comp->flags |= PAT_FROM_ROOT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+16]
	or	eax, 256				; 00000100H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	jmp	SHORT $LN21@xmlCompile
$LN20@xmlCompile:

; 1237 :     } else if ((CUR == '.') || (ctxt->comp->flags & XML_PATTERN_NOTPATTERN)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	je	SHORT $LN23@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, 7
	je	SHORT $LN21@xmlCompile
$LN23@xmlCompile:

; 1238 :         ctxt->comp->flags |= PAT_FROM_CUR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+16]
	or	edx, 512				; 00000200H
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
$LN21@xmlCompile:

; 1239 :     }
; 1240 : 
; 1241 :     if ((CUR == '/') && (NXT(1) == '/')) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	$LN24@xmlCompile
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN24@xmlCompile

; 1242 : 	PUSH(XML_OP_ANCESTOR, NULL, NULL);

	push	0
	push	0
	push	6
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN26@xmlCompile
	jmp	$error$93
$LN26@xmlCompile:

; 1243 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN61@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv170[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN62@xmlCompile
$LN61@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv170[ebp], eax
$LN62@xmlCompile:

; 1244 : 	NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN63@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv180[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN64@xmlCompile
$LN63@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv180[ebp], ecx
$LN64@xmlCompile:

; 1245 :     } else if ((CUR == '.') && (NXT(1) == '/') && (NXT(2) == '/')) {

	jmp	$LN25@xmlCompile
$LN24@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	jne	$LN25@xmlCompile
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 47					; 0000002fH
	jne	$LN25@xmlCompile
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+eax]
	cmp	eax, 47					; 0000002fH
	jne	$LN25@xmlCompile

; 1246 : 	PUSH(XML_OP_ANCESTOR, NULL, NULL);

	push	0
	push	0
	push	6
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN28@xmlCompile
	jmp	$error$93
$LN28@xmlCompile:

; 1247 : 	NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN65@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv212[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN66@xmlCompile
$LN65@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv212[ebp], ecx
$LN66@xmlCompile:

; 1248 : 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN67@xmlCompile
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv222[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN68@xmlCompile
$LN67@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv222[ebp], edx
$LN68@xmlCompile:

; 1249 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN69@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv232[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN4@xmlCompile
$LN69@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv232[ebp], eax
$LN4@xmlCompile:

; 1250 : 	/* Check for incompleteness. */
; 1251 : 	SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN29@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN30@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN29@xmlCompile
$LN30@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN5@xmlCompile
$LN29@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN71@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv258[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN72@xmlCompile
$LN71@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv258[ebp], ecx
$LN72@xmlCompile:
	jmp	SHORT $LN4@xmlCompile
$LN5@xmlCompile:

; 1252 : 	if (CUR == 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN25@xmlCompile

; 1253 : 	    ERROR5(NULL, NULL, NULL,
; 1254 : 	       "Incomplete expression '%s'.\n", ctxt->base);
; 1255 : 	    ctxt->error = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1

; 1256 : 	    goto error;

	jmp	$error$93
$LN25@xmlCompile:

; 1257 : 	}
; 1258 :     }
; 1259 :     if (CUR == '@') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 64					; 00000040H
	jne	$LN32@xmlCompile

; 1260 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN73@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv277[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN74@xmlCompile
$LN73@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv277[ebp], eax
$LN74@xmlCompile:

; 1261 : 	xmlCompileAttributeTest(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCompileAttributeTest
	add	esp, 4
$LN6@xmlCompile:

; 1262 : 	SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN34@xmlCompile
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN35@xmlCompile
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN34@xmlCompile
$LN35@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN7@xmlCompile
$LN34@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN75@xmlCompile
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv304[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN76@xmlCompile
$LN75@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv304[ebp], edx
$LN76@xmlCompile:
	jmp	SHORT $LN6@xmlCompile
$LN7@xmlCompile:

; 1263 : 	/* TODO: check for incompleteness */
; 1264 : 	if (CUR != 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN36@xmlCompile

; 1265 : 	    xmlCompileStepPattern(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCompileStepPattern
	add	esp, 4

; 1266 : 	    if (ctxt->error != 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN36@xmlCompile

; 1267 : 		goto error;

	jmp	$error$93
$LN36@xmlCompile:

; 1268 : 	}
; 1269 :     } else {

	jmp	$LN33@xmlCompile
$LN32@xmlCompile:

; 1270 :         if (CUR == '/') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	$LN38@xmlCompile

; 1271 : 	    PUSH(XML_OP_ROOT, NULL, NULL);

	push	0
	push	0
	push	1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN39@xmlCompile
	jmp	$error$93
$LN39@xmlCompile:

; 1272 : 	    NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN77@xmlCompile
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv333[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN8@xmlCompile
$LN77@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv333[ebp], edx
$LN8@xmlCompile:

; 1273 : 	    /* Check for incompleteness. */
; 1274 : 	    SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN40@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN41@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN40@xmlCompile
$LN41@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN9@xmlCompile
$LN40@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN79@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv359[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN80@xmlCompile
$LN79@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv359[ebp], eax
$LN80@xmlCompile:
	jmp	SHORT $LN8@xmlCompile
$LN9@xmlCompile:

; 1275 : 	    if (CUR == 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN38@xmlCompile

; 1276 : 		ERROR5(NULL, NULL, NULL,
; 1277 : 		    "Incomplete expression '%s'.\n", ctxt->base);
; 1278 : 		ctxt->error = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 1

; 1279 : 		goto error;

	jmp	$error$93
$LN38@xmlCompile:

; 1280 : 	    }
; 1281 : 	}
; 1282 : 	xmlCompileStepPattern(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCompileStepPattern
	add	esp, 4

; 1283 : 	if (ctxt->error != 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN10@xmlCompile

; 1284 : 	    goto error;

	jmp	$error$93
$LN10@xmlCompile:

; 1285 : 	SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN44@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN45@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN44@xmlCompile
$LN45@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN12@xmlCompile
$LN44@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN81@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv393[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN82@xmlCompile
$LN81@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv393[ebp], ecx
$LN82@xmlCompile:
	jmp	SHORT $LN10@xmlCompile
$LN12@xmlCompile:

; 1286 : 	while (CUR == '/') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	$LN33@xmlCompile

; 1287 : 	    if (NXT(1) == '/') {

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 47					; 0000002fH
	jne	$LN46@xmlCompile

; 1288 : 	        PUSH(XML_OP_ANCESTOR, NULL, NULL);

	push	0
	push	0
	push	6
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN48@xmlCompile
	jmp	$error$93
$LN48@xmlCompile:

; 1289 : 		NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN83@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv420[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN84@xmlCompile
$LN83@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv420[ebp], eax
$LN84@xmlCompile:

; 1290 : 		NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN85@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv430[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN14@xmlCompile
$LN85@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv430[ebp], ecx
$LN14@xmlCompile:

; 1291 : 		SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN49@xmlCompile
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN50@xmlCompile
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN49@xmlCompile
$LN50@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN15@xmlCompile
$LN49@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN87@xmlCompile
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv456[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN88@xmlCompile
$LN87@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv456[ebp], edx
$LN88@xmlCompile:
	jmp	SHORT $LN14@xmlCompile
$LN15@xmlCompile:

; 1292 : 		xmlCompileStepPattern(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCompileStepPattern
	add	esp, 4

; 1293 : 		if (ctxt->error != 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN51@xmlCompile

; 1294 : 		    goto error;

	jmp	$error$93
$LN51@xmlCompile:

; 1295 : 	    } else {

	jmp	$LN47@xmlCompile
$LN46@xmlCompile:

; 1296 : 	        PUSH(XML_OP_PARENT, NULL, NULL);

	push	0
	push	0
	push	5
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN52@xmlCompile
	jmp	$error$93
$LN52@xmlCompile:

; 1297 : 		NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN89@xmlCompile
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv477[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN16@xmlCompile
$LN89@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv477[ebp], edx
$LN16@xmlCompile:

; 1298 : 		SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN53@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN54@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN53@xmlCompile
$LN54@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN17@xmlCompile
$LN53@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN91@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv503[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN92@xmlCompile
$LN91@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv503[ebp], eax
$LN92@xmlCompile:
	jmp	SHORT $LN16@xmlCompile
$LN17@xmlCompile:

; 1299 : 		if (CUR == 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN55@xmlCompile

; 1300 : 		    ERROR5(NULL, NULL, NULL,
; 1301 : 		    "Incomplete expression '%s'.\n", ctxt->base);
; 1302 : 		    ctxt->error = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 1

; 1303 : 		    goto error;

	jmp	SHORT $error$93
$LN55@xmlCompile:

; 1304 : 		}
; 1305 : 		xmlCompileStepPattern(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCompileStepPattern
	add	esp, 4

; 1306 : 		if (ctxt->error != 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN47@xmlCompile

; 1307 : 		    goto error;

	jmp	SHORT $error$93
$LN47@xmlCompile:

; 1308 : 	    }
; 1309 : 	}

	jmp	$LN12@xmlCompile
$LN33@xmlCompile:

; 1310 :     }
; 1311 :     if (CUR != 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $error$93

; 1312 : 	ERROR5(NULL, NULL, NULL,
; 1313 : 	       "Failed to compile pattern %s\n", ctxt->base);
; 1314 : 	ctxt->error = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 1
$error$93:

; 1315 :     }
; 1316 : error:
; 1317 :     return;
; 1318 : }

	pop	edi
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCompilePathPattern ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlCompileStepPattern
_TEXT	SEGMENT
tv583 = -80						; size = 4
tv525 = -76						; size = 4
tv426 = -72						; size = 4
tv403 = -68						; size = 4
tv378 = -64						; size = 4
tv351 = -60						; size = 4
tv247 = -56						; size = 4
tv233 = -52						; size = 4
tv182 = -48						; size = 4
tv162 = -44						; size = 4
tv135 = -40						; size = 4
tv89 = -36						; size = 4
_i$1 = -32						; size = 4
_prefix$2 = -28						; size = 4
_i$3 = -24						; size = 4
_prefix$4 = -20						; size = 4
_hasBlanks$ = -16					; size = 4
_URL$ = -12						; size = 4
_name$ = -8						; size = 4
_token$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlCompileStepPattern PROC				; COMDAT

; 1014 : xmlCompileStepPattern(xmlPatParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 1015 :     xmlChar *token = NULL;

	mov	DWORD PTR _token$[ebp], 0

; 1016 :     xmlChar *name = NULL;

	mov	DWORD PTR _name$[ebp], 0

; 1017 :     xmlChar *URL = NULL;

	mov	DWORD PTR _URL$[ebp], 0

; 1018 :     int hasBlanks = 0;

	mov	DWORD PTR _hasBlanks$[ebp], 0
$LN2@xmlCompile:

; 1019 : 
; 1020 :     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN12@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN13@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN12@xmlCompile
$LN13@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN3@xmlCompile
$LN12@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN96@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv89[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN97@xmlCompile
$LN96@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv89[ebp], eax
$LN97@xmlCompile:
	jmp	SHORT $LN2@xmlCompile
$LN3@xmlCompile:

; 1021 :     if (CUR == '.') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN14@xmlCompile

; 1022 : 	/*
; 1023 : 	* Context node.
; 1024 : 	*/
; 1025 : 	NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN98@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv135[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN99@xmlCompile
$LN98@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv135[ebp], ecx
$LN99@xmlCompile:

; 1026 : 	PUSH(XML_OP_ELEM, NULL, NULL);

	push	0
	push	0
	push	2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN15@xmlCompile
	jmp	$error$120
$LN15@xmlCompile:

; 1027 : 	return;

	jmp	$LN1@xmlCompile
$LN14@xmlCompile:

; 1028 :     }
; 1029 :     if (CUR == '@') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 64					; 00000040H
	jne	SHORT $LN16@xmlCompile

; 1030 : 	/*
; 1031 : 	* Attribute test.
; 1032 : 	*/
; 1033 : 	if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 2
	je	SHORT $LN17@xmlCompile

; 1034 : 	    ERROR5(NULL, NULL, NULL,
; 1035 : 		"Unexpected attribute axis in '%s'.\n", ctxt->base);
; 1036 : 	    ctxt->error = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1

; 1037 : 	    return;

	jmp	$LN1@xmlCompile
$LN17@xmlCompile:

; 1038 : 	}
; 1039 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN100@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv162[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN101@xmlCompile
$LN100@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv162[ebp], eax
$LN101@xmlCompile:

; 1040 : 	xmlCompileAttributeTest(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCompileAttributeTest
	add	esp, 4

; 1041 : 	if (ctxt->error != 0)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN18@xmlCompile

; 1042 : 	    goto error;

	jmp	$error$120
$LN18@xmlCompile:

; 1043 : 	return;

	jmp	$LN1@xmlCompile
$LN16@xmlCompile:

; 1044 :     }
; 1045 :     name = xmlPatScanNCName(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlPatScanNCName
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 1046 :     if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN19@xmlCompile

; 1047 : 	if (CUR == '*') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN20@xmlCompile

; 1048 : 	    NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN102@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv182[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN103@xmlCompile
$LN102@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv182[ebp], ecx
$LN103@xmlCompile:

; 1049 : 	    PUSH(XML_OP_ALL, NULL, NULL);

	push	0
	push	0
	push	8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN22@xmlCompile
	jmp	$error$120
$LN22@xmlCompile:

; 1050 : 	    return;

	jmp	$LN1@xmlCompile

; 1051 : 	} else {

	jmp	SHORT $LN19@xmlCompile
$LN20@xmlCompile:

; 1052 : 	    ERROR(NULL, NULL, NULL,
; 1053 : 		    "xmlCompileStepPattern : Name expected\n");
; 1054 : 	    ctxt->error = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1

; 1055 : 	    return;

	jmp	$LN1@xmlCompile
$LN19@xmlCompile:

; 1056 : 	}
; 1057 :     }
; 1058 :     if (IS_BLANK_CH(CUR)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN24@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN25@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN24@xmlCompile
$LN25@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN23@xmlCompile
$LN24@xmlCompile:

; 1059 : 	hasBlanks = 1;

	mov	DWORD PTR _hasBlanks$[ebp], 1
$LN4@xmlCompile:

; 1060 : 	SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN26@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN27@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN26@xmlCompile
$LN27@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN23@xmlCompile
$LN26@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN104@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv233[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN105@xmlCompile
$LN104@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv233[ebp], eax
$LN105@xmlCompile:
	jmp	SHORT $LN4@xmlCompile
$LN23@xmlCompile:

; 1061 :     }
; 1062 :     if (CUR == ':') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	jne	$LN28@xmlCompile

; 1063 : 	NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN106@xmlCompile
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv247[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN107@xmlCompile
$LN106@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv247[ebp], ecx
$LN107@xmlCompile:

; 1064 : 	if (CUR != ':') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	je	$LN30@xmlCompile

; 1065 : 	    xmlChar *prefix = name;

	mov	edx, DWORD PTR _name$[ebp]
	mov	DWORD PTR _prefix$4[ebp], edx

; 1066 : 	    int i;
; 1067 : 
; 1068 : 	    if (hasBlanks || IS_BLANK_CH(CUR)) {

	cmp	DWORD PTR _hasBlanks$[ebp], 0
	jne	SHORT $LN33@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN33@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN35@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN33@xmlCompile
$LN35@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN32@xmlCompile
$LN33@xmlCompile:

; 1069 : 		ERROR5(NULL, NULL, NULL, "Invalid QName.\n", NULL);
; 1070 : 		ctxt->error = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1

; 1071 : 		goto error;

	jmp	$error$120
$LN32@xmlCompile:

; 1072 : 	    }
; 1073 : 	    /*
; 1074 : 	     * This is a namespace match
; 1075 : 	     */
; 1076 : 	    token = xmlPatScanName(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatScanName
	add	esp, 4
	mov	DWORD PTR _token$[ebp], eax

; 1077 : 	    if ((prefix[0] == 'x') &&
; 1078 : 		(prefix[1] == 'm') &&
; 1079 : 		(prefix[2] == 'l') &&

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _prefix$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 120				; 00000078H
	jne	SHORT $LN36@xmlCompile
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _prefix$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 109				; 0000006dH
	jne	SHORT $LN36@xmlCompile
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _prefix$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 108				; 0000006cH
	jne	SHORT $LN36@xmlCompile
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _prefix$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN36@xmlCompile

; 1080 : 		(prefix[3] == 0))
; 1081 : 	    {
; 1082 : 		XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN38@xmlCompile
	push	-1
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _URL$[ebp], eax
	jmp	SHORT $LN39@xmlCompile
$LN38@xmlCompile:
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _URL$[ebp], eax
$LN39@xmlCompile:

; 1083 : 	    } else {

	jmp	$LN37@xmlCompile
$LN36@xmlCompile:

; 1084 : 		for (i = 0;i < ctxt->nb_namespaces;i++) {

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN8@xmlCompile
$LN6@xmlCompile:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN8@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _i$3[ebp]
	cmp	edx, DWORD PTR [ecx+28]
	jge	SHORT $LN7@xmlCompile

; 1085 : 		    if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {

	mov	eax, DWORD PTR _prefix$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$3[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [eax+ecx*4+4]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN40@xmlCompile

; 1086 : 			XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN41@xmlCompile
	push	-1
	mov	ecx, DWORD PTR _i$3[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _URL$[ebp], eax
	jmp	SHORT $LN42@xmlCompile
$LN41@xmlCompile:
	mov	edx, DWORD PTR _i$3[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _URL$[ebp], eax
$LN42@xmlCompile:

; 1087 : 			break;

	jmp	SHORT $LN7@xmlCompile
$LN40@xmlCompile:

; 1088 : 		    }
; 1089 : 		}

	jmp	$LN6@xmlCompile
$LN7@xmlCompile:

; 1090 : 		if (i >= ctxt->nb_namespaces) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jl	SHORT $LN37@xmlCompile

; 1091 : 		    ERROR5(NULL, NULL, NULL,
; 1092 : 			"xmlCompileStepPattern : no namespace bound to prefix %s\n",
; 1093 : 			prefix);
; 1094 : 		    ctxt->error = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1

; 1095 : 		    goto error;

	jmp	$error$120
$LN37@xmlCompile:

; 1096 : 		}
; 1097 : 	    }
; 1098 : 	    XML_PAT_FREE_STRING(ctxt, prefix);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN44@xmlCompile
	mov	esi, esp
	mov	edx, DWORD PTR _prefix$4[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN44@xmlCompile:

; 1099 : 	    name = NULL;

	mov	DWORD PTR _name$[ebp], 0

; 1100 : 	    if (token == NULL) {

	cmp	DWORD PTR _token$[ebp], 0
	jne	SHORT $LN45@xmlCompile

; 1101 : 		if (CUR == '*') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	jne	SHORT $LN47@xmlCompile

; 1102 : 		    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN108@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv351[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN109@xmlCompile
$LN108@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv351[ebp], eax
$LN109@xmlCompile:

; 1103 : 		    PUSH(XML_OP_NS, URL, NULL);

	push	0
	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	push	7
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN49@xmlCompile
	jmp	$error$120
$LN49@xmlCompile:

; 1104 : 		} else {

	jmp	SHORT $LN48@xmlCompile
$LN47@xmlCompile:

; 1105 : 		    ERROR(NULL, NULL, NULL,
; 1106 : 			    "xmlCompileStepPattern : Name expected\n");
; 1107 : 		    ctxt->error = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1

; 1108 : 		    goto error;

	jmp	$error$120
$LN48@xmlCompile:

; 1109 : 		}
; 1110 : 	    } else {

	jmp	SHORT $LN46@xmlCompile
$LN45@xmlCompile:

; 1111 : 		PUSH(XML_OP_ELEM, token, URL);

	mov	eax, DWORD PTR _URL$[ebp]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN46@xmlCompile
	jmp	$error$120
$LN46@xmlCompile:

; 1112 : 	    }
; 1113 : 	} else {

	jmp	$LN31@xmlCompile
$LN30@xmlCompile:

; 1114 : 	    NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN110@xmlCompile
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv378[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN111@xmlCompile
$LN110@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv378[ebp], edx
$LN111@xmlCompile:

; 1115 : 	    if (xmlStrEqual(name, (const xmlChar *) "child")) {

	push	OFFSET ??_C@_05GPGNDLEK@child@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN51@xmlCompile

; 1116 : 		XML_PAT_FREE_STRING(ctxt, name);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN53@xmlCompile
	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN53@xmlCompile:

; 1117 : 		name = xmlPatScanName(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatScanName
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 1118 : 		if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN54@xmlCompile

; 1119 : 		    if (CUR == '*') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $LN55@xmlCompile

; 1120 : 			NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN112@xmlCompile
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv403[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN113@xmlCompile
$LN112@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv403[ebp], edx
$LN113@xmlCompile:

; 1121 : 			PUSH(XML_OP_ALL, NULL, NULL);

	push	0
	push	0
	push	8
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN57@xmlCompile
	jmp	$error$120
$LN57@xmlCompile:

; 1122 : 			return;

	jmp	$LN1@xmlCompile

; 1123 : 		    } else {

	jmp	SHORT $LN54@xmlCompile
$LN55@xmlCompile:

; 1124 : 			ERROR(NULL, NULL, NULL,
; 1125 : 			    "xmlCompileStepPattern : QName expected\n");
; 1126 : 			ctxt->error = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1

; 1127 : 			goto error;

	jmp	$error$120
$LN54@xmlCompile:

; 1128 : 		    }
; 1129 : 		}
; 1130 : 		if (CUR == ':') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	jne	$LN58@xmlCompile

; 1131 : 		    xmlChar *prefix = name;

	mov	ecx, DWORD PTR _name$[ebp]
	mov	DWORD PTR _prefix$2[ebp], ecx

; 1132 : 		    int i;
; 1133 : 
; 1134 : 		    NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN114@xmlCompile
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv426[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN115@xmlCompile
$LN114@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv426[ebp], edx
$LN115@xmlCompile:

; 1135 : 		    if (IS_BLANK_CH(CUR)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN61@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN62@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN61@xmlCompile
$LN62@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN60@xmlCompile
$LN61@xmlCompile:

; 1136 : 			ERROR5(NULL, NULL, NULL, "Invalid QName.\n", NULL);
; 1137 : 			ctxt->error = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1

; 1138 : 			goto error;

	jmp	$error$120
$LN60@xmlCompile:

; 1139 : 		    }
; 1140 : 		    /*
; 1141 : 		    * This is a namespace match
; 1142 : 		    */
; 1143 : 		    token = xmlPatScanName(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatScanName
	add	esp, 4
	mov	DWORD PTR _token$[ebp], eax

; 1144 : 		    if ((prefix[0] == 'x') &&
; 1145 : 			(prefix[1] == 'm') &&
; 1146 : 			(prefix[2] == 'l') &&

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _prefix$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 120				; 00000078H
	jne	SHORT $LN63@xmlCompile
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _prefix$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 109				; 0000006dH
	jne	SHORT $LN63@xmlCompile
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _prefix$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 108				; 0000006cH
	jne	SHORT $LN63@xmlCompile
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _prefix$2[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN63@xmlCompile

; 1147 : 			(prefix[3] == 0))
; 1148 : 		    {
; 1149 : 			XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN65@xmlCompile
	push	-1
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _URL$[ebp], eax
	jmp	SHORT $LN66@xmlCompile
$LN65@xmlCompile:
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _URL$[ebp], eax
$LN66@xmlCompile:

; 1150 : 		    } else {

	jmp	$LN64@xmlCompile
$LN63@xmlCompile:

; 1151 : 			for (i = 0;i < ctxt->nb_namespaces;i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN11@xmlCompile
$LN9@xmlCompile:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN11@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	cmp	edx, DWORD PTR [ecx+28]
	jge	SHORT $LN10@xmlCompile

; 1152 : 			    if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {

	mov	eax, DWORD PTR _prefix$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$1[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [eax+ecx*4+4]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN67@xmlCompile

; 1153 : 				XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN68@xmlCompile
	push	-1
	mov	ecx, DWORD PTR _i$1[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _URL$[ebp], eax
	jmp	SHORT $LN69@xmlCompile
$LN68@xmlCompile:
	mov	edx, DWORD PTR _i$1[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _URL$[ebp], eax
$LN69@xmlCompile:

; 1154 : 				break;

	jmp	SHORT $LN10@xmlCompile
$LN67@xmlCompile:

; 1155 : 			    }
; 1156 : 			}

	jmp	$LN9@xmlCompile
$LN10@xmlCompile:

; 1157 : 			if (i >= ctxt->nb_namespaces) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jl	SHORT $LN64@xmlCompile

; 1158 : 			    ERROR5(NULL, NULL, NULL,
; 1159 : 				"xmlCompileStepPattern : no namespace bound "
; 1160 : 				"to prefix %s\n", prefix);
; 1161 : 			    ctxt->error = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1

; 1162 : 			    goto error;

	jmp	$error$120
$LN64@xmlCompile:

; 1163 : 			}
; 1164 : 		    }
; 1165 : 		    XML_PAT_FREE_STRING(ctxt, prefix);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN71@xmlCompile
	mov	esi, esp
	mov	edx, DWORD PTR _prefix$2[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN71@xmlCompile:

; 1166 : 		    name = NULL;

	mov	DWORD PTR _name$[ebp], 0

; 1167 : 		    if (token == NULL) {

	cmp	DWORD PTR _token$[ebp], 0
	jne	SHORT $LN72@xmlCompile

; 1168 : 			if (CUR == '*') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	jne	SHORT $LN74@xmlCompile

; 1169 : 			    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN116@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv525[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN117@xmlCompile
$LN116@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv525[ebp], eax
$LN117@xmlCompile:

; 1170 : 			    PUSH(XML_OP_NS, URL, NULL);

	push	0
	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	push	7
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN76@xmlCompile
	jmp	$error$120
$LN76@xmlCompile:

; 1171 : 			} else {

	jmp	SHORT $LN75@xmlCompile
$LN74@xmlCompile:

; 1172 : 			    ERROR(NULL, NULL, NULL,
; 1173 : 				"xmlCompileStepPattern : Name expected\n");
; 1174 : 			    ctxt->error = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1

; 1175 : 			    goto error;

	jmp	$error$120
$LN75@xmlCompile:

; 1176 : 			}
; 1177 : 		    } else {

	jmp	SHORT $LN73@xmlCompile
$LN72@xmlCompile:

; 1178 : 			PUSH(XML_OP_CHILD, token, URL);

	mov	eax, DWORD PTR _URL$[ebp]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	push	3
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN73@xmlCompile
	jmp	$error$120
$LN73@xmlCompile:

; 1179 : 		    }
; 1180 : 		} else

	jmp	SHORT $LN59@xmlCompile
$LN58@xmlCompile:

; 1181 : 		    PUSH(XML_OP_CHILD, name, NULL);

	push	0
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	3
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN59@xmlCompile
	jmp	$error$120
$LN59@xmlCompile:

; 1182 : 		return;

	jmp	$LN1@xmlCompile
	jmp	$LN31@xmlCompile
$LN51@xmlCompile:

; 1183 : 	    } else if (xmlStrEqual(name, (const xmlChar *) "attribute")) {

	push	OFFSET ??_C@_09HGIEBAJ@attribute@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN79@xmlCompile

; 1184 : 		XML_PAT_FREE_STRING(ctxt, name)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN81@xmlCompile
	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN81@xmlCompile:

; 1185 : 		name = NULL;

	mov	DWORD PTR _name$[ebp], 0

; 1186 : 		if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+16]
	and	eax, 2
	je	SHORT $LN82@xmlCompile

; 1187 : 		    ERROR5(NULL, NULL, NULL,
; 1188 : 			"Unexpected attribute axis in '%s'.\n", ctxt->base);
; 1189 : 		    ctxt->error = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 1

; 1190 : 		    goto error;

	jmp	$error$120
$LN82@xmlCompile:

; 1191 : 		}
; 1192 : 		xmlCompileAttributeTest(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCompileAttributeTest
	add	esp, 4

; 1193 : 		if (ctxt->error != 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN83@xmlCompile

; 1194 : 		    goto error;

	jmp	$error$120
$LN83@xmlCompile:

; 1195 : 		return;

	jmp	$LN1@xmlCompile

; 1196 : 	    } else {

	jmp	SHORT $LN31@xmlCompile
$LN79@xmlCompile:

; 1197 : 		ERROR5(NULL, NULL, NULL,
; 1198 : 		    "The 'element' or 'attribute' axis is expected.\n", NULL);
; 1199 : 		ctxt->error = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 1

; 1200 : 		goto error;

	jmp	$error$120
$LN31@xmlCompile:

; 1201 : 	    }
; 1202 : 	}

	jmp	$LN29@xmlCompile
$LN28@xmlCompile:

; 1203 :     } else if (CUR == '*') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $LN84@xmlCompile

; 1204 :         if (name != NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN86@xmlCompile

; 1205 : 	    ctxt->error = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1

; 1206 : 	    goto error;

	jmp	SHORT $error$120
$LN86@xmlCompile:

; 1207 : 	}
; 1208 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN118@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv583[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN119@xmlCompile
$LN118@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv583[ebp], eax
$LN119@xmlCompile:

; 1209 : 	PUSH(XML_OP_ALL, token, NULL);

	push	0
	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	push	8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN87@xmlCompile
	jmp	SHORT $error$120
$LN87@xmlCompile:

; 1210 :     } else {

	jmp	SHORT $LN29@xmlCompile
$LN84@xmlCompile:

; 1211 : 	PUSH(XML_OP_ELEM, name, NULL);

	push	0
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN29@xmlCompile
	jmp	SHORT $error$120
$LN29@xmlCompile:

; 1212 :     }
; 1213 :     return;

	jmp	SHORT $LN1@xmlCompile
$error$120:

; 1214 : error:
; 1215 :     if (URL != NULL)

	cmp	DWORD PTR _URL$[ebp], 0
	je	SHORT $LN89@xmlCompile

; 1216 : 	XML_PAT_FREE_STRING(ctxt, URL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN89@xmlCompile
	mov	esi, esp
	mov	edx, DWORD PTR _URL$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN89@xmlCompile:

; 1217 :     if (token != NULL)

	cmp	DWORD PTR _token$[ebp], 0
	je	SHORT $LN91@xmlCompile

; 1218 : 	XML_PAT_FREE_STRING(ctxt, token)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN91@xmlCompile
	mov	esi, esp
	mov	edx, DWORD PTR _token$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN91@xmlCompile:

; 1219 :     if (name != NULL)

	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN1@xmlCompile

; 1220 : 	XML_PAT_FREE_STRING(ctxt, name)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN1@xmlCompile
	mov	esi, esp
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlCompile:

; 1221 : }

	pop	edi
	pop	esi
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCompileStepPattern ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlCompileAttributeTest
_TEXT	SEGMENT
tv268 = -36						; size = 4
tv161 = -32						; size = 4
tv146 = -28						; size = 4
tv89 = -24						; size = 4
_prefix$1 = -20						; size = 4
_i$2 = -16						; size = 4
_URL$ = -12						; size = 4
_name$ = -8						; size = 4
_token$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlCompileAttributeTest PROC				; COMDAT

; 921  : xmlCompileAttributeTest(xmlPatParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 922  :     xmlChar *token = NULL;

	mov	DWORD PTR _token$[ebp], 0

; 923  :     xmlChar *name = NULL;

	mov	DWORD PTR _name$[ebp], 0

; 924  :     xmlChar *URL = NULL;

	mov	DWORD PTR _URL$[ebp], 0
$LN2@xmlCompile:

; 925  : 
; 926  :     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN7@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN8@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN7@xmlCompile
$LN8@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN3@xmlCompile
$LN7@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN41@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv89[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN42@xmlCompile
$LN41@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv89[ebp], eax
$LN42@xmlCompile:
	jmp	SHORT $LN2@xmlCompile
$LN3@xmlCompile:

; 927  :     name = xmlPatScanNCName(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatScanNCName
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 928  :     if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN9@xmlCompile

; 929  : 	if (CUR == '*') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $LN10@xmlCompile

; 930  : 	    PUSH(XML_OP_ATTR, NULL, NULL);

	push	0
	push	0
	push	4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN12@xmlCompile
	jmp	$error$49
$LN12@xmlCompile:

; 931  : 	    NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN43@xmlCompile
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv146[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN44@xmlCompile
$LN43@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv146[ebp], edx
$LN44@xmlCompile:

; 932  : 	} else {

	jmp	SHORT $LN11@xmlCompile
$LN10@xmlCompile:

; 933  : 	    ERROR(NULL, NULL, NULL,
; 934  : 		"xmlCompileAttributeTest : Name expected\n");
; 935  : 	    ctxt->error = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN11@xmlCompile:

; 936  : 	}
; 937  : 	return;

	jmp	$LN1@xmlCompile
$LN9@xmlCompile:

; 938  :     }
; 939  :     if (CUR == ':') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	jne	$LN13@xmlCompile

; 940  : 	int i;
; 941  : 	xmlChar *prefix = name;

	mov	ecx, DWORD PTR _name$[ebp]
	mov	DWORD PTR _prefix$1[ebp], ecx

; 942  : 
; 943  : 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN45@xmlCompile
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv161[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN46@xmlCompile
$LN45@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv161[ebp], edx
$LN46@xmlCompile:

; 944  : 
; 945  : 	if (IS_BLANK_CH(CUR)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN16@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN17@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN16@xmlCompile
$LN17@xmlCompile:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN15@xmlCompile
$LN16@xmlCompile:

; 946  : 	    ERROR5(NULL, NULL, NULL, "Invalid QName.\n", NULL);
; 947  : 	    XML_PAT_FREE_STRING(ctxt, prefix);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN18@xmlCompile
	mov	esi, esp
	mov	edx, DWORD PTR _prefix$1[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@xmlCompile:

; 948  : 	    ctxt->error = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 1

; 949  : 	    goto error;

	jmp	$error$49
$LN15@xmlCompile:

; 950  : 	}
; 951  : 	/*
; 952  : 	* This is a namespace match
; 953  : 	*/
; 954  : 	token = xmlPatScanName(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatScanName
	add	esp, 4
	mov	DWORD PTR _token$[ebp], eax

; 955  : 	if ((prefix[0] == 'x') &&
; 956  : 	    (prefix[1] == 'm') &&
; 957  : 	    (prefix[2] == 'l') &&

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _prefix$1[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 120				; 00000078H
	jne	SHORT $LN19@xmlCompile
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _prefix$1[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 109				; 0000006dH
	jne	SHORT $LN19@xmlCompile
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _prefix$1[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 108				; 0000006cH
	jne	SHORT $LN19@xmlCompile
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _prefix$1[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN19@xmlCompile

; 958  : 	    (prefix[3] == 0))
; 959  : 	{
; 960  : 	    XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN21@xmlCompile
	push	-1
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _URL$[ebp], eax
	jmp	SHORT $LN22@xmlCompile
$LN21@xmlCompile:
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _URL$[ebp], eax
$LN22@xmlCompile:

; 961  : 	} else {

	jmp	$LN20@xmlCompile
$LN19@xmlCompile:

; 962  : 	    for (i = 0;i < ctxt->nb_namespaces;i++) {

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN6@xmlCompile
$LN4@xmlCompile:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN6@xmlCompile:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _i$2[ebp]
	cmp	edx, DWORD PTR [ecx+28]
	jge	SHORT $LN5@xmlCompile

; 963  : 		if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {

	mov	eax, DWORD PTR _prefix$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$2[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [eax+ecx*4+4]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xmlCompile

; 964  : 		    XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN24@xmlCompile
	push	-1
	mov	ecx, DWORD PTR _i$2[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _URL$[ebp], eax
	jmp	SHORT $LN25@xmlCompile
$LN24@xmlCompile:
	mov	edx, DWORD PTR _i$2[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _URL$[ebp], eax
$LN25@xmlCompile:

; 965  : 		    break;

	jmp	SHORT $LN5@xmlCompile
$LN23@xmlCompile:

; 966  : 		}
; 967  : 	    }

	jmp	$LN4@xmlCompile
$LN5@xmlCompile:

; 968  : 	    if (i >= ctxt->nb_namespaces) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jl	SHORT $LN20@xmlCompile

; 969  : 		ERROR5(NULL, NULL, NULL,
; 970  : 		    "xmlCompileAttributeTest : no namespace bound to prefix %s\n",
; 971  : 		    prefix);
; 972  : 	        XML_PAT_FREE_STRING(ctxt, prefix);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN27@xmlCompile
	mov	esi, esp
	mov	ecx, DWORD PTR _prefix$1[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN27@xmlCompile:

; 973  : 		ctxt->error = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1

; 974  : 		goto error;

	jmp	$error$49
$LN20@xmlCompile:

; 975  : 	    }
; 976  : 	}
; 977  : 	XML_PAT_FREE_STRING(ctxt, prefix);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN28@xmlCompile
	mov	esi, esp
	mov	edx, DWORD PTR _prefix$1[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN28@xmlCompile:

; 978  : 	if (token == NULL) {

	cmp	DWORD PTR _token$[ebp], 0
	jne	SHORT $LN29@xmlCompile

; 979  : 	    if (CUR == '*') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	jne	SHORT $LN31@xmlCompile

; 980  : 		NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN47@xmlCompile
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv268[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN48@xmlCompile
$LN47@xmlCompile:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv268[ebp], eax
$LN48@xmlCompile:

; 981  : 		PUSH(XML_OP_ATTR, NULL, URL);

	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	push	0
	push	4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN33@xmlCompile
	jmp	SHORT $error$49
$LN33@xmlCompile:

; 982  : 	    } else {

	jmp	SHORT $LN32@xmlCompile
$LN31@xmlCompile:

; 983  : 		ERROR(NULL, NULL, NULL,
; 984  : 		    "xmlCompileAttributeTest : Name expected\n");
; 985  : 		ctxt->error = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 1

; 986  : 		goto error;

	jmp	SHORT $error$49
$LN32@xmlCompile:

; 987  : 	    }
; 988  : 	} else {

	jmp	SHORT $LN30@xmlCompile
$LN29@xmlCompile:

; 989  : 	    PUSH(XML_OP_ATTR, token, URL);

	mov	eax, DWORD PTR _URL$[ebp]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	push	4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN30@xmlCompile
	jmp	SHORT $error$49
$LN30@xmlCompile:

; 990  : 	}
; 991  :     } else {

	jmp	SHORT $LN14@xmlCompile
$LN13@xmlCompile:

; 992  : 	PUSH(XML_OP_ATTR, name, NULL);

	push	0
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlPatternAdd
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN14@xmlCompile
	jmp	SHORT $error$49
$LN14@xmlCompile:

; 993  :     }
; 994  :     return;

	jmp	SHORT $LN1@xmlCompile
$error$49:

; 995  : error:
; 996  :     if (URL != NULL)

	cmp	DWORD PTR _URL$[ebp], 0
	je	SHORT $LN36@xmlCompile

; 997  : 	XML_PAT_FREE_STRING(ctxt, URL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN36@xmlCompile
	mov	esi, esp
	mov	edx, DWORD PTR _URL$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN36@xmlCompile:

; 998  :     if (token != NULL)

	cmp	DWORD PTR _token$[ebp], 0
	je	SHORT $LN1@xmlCompile

; 999  : 	XML_PAT_FREE_STRING(ctxt, token);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN1@xmlCompile
	mov	esi, esp
	mov	edx, DWORD PTR _token$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlCompile:

; 1000 : }

	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCompileAttributeTest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatScanNCName
_TEXT	SEGMENT
tv202 = -84						; size = 4
tv201 = -80						; size = 4
tv194 = -76						; size = 4
tv185 = -72						; size = 4
tv184 = -68						; size = 4
tv175 = -64						; size = 4
tv176 = -60						; size = 4
tv167 = -56						; size = 4
tv166 = -52						; size = 4
tv149 = -48						; size = 4
tv150 = -44						; size = 4
tv141 = -40						; size = 4
tv140 = -36						; size = 4
tv89 = -32						; size = 4
_len$ = -24						; size = 4
_val$ = -16						; size = 4
_ret$ = -12						; size = 4
_cur$ = -8						; size = 4
_q$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlPatScanNCName PROC					; COMDAT

; 860  : xmlPatScanNCName(xmlPatParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	edi
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 21					; 00000015H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 861  :     const xmlChar *q, *cur;
; 862  :     xmlChar *ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0
$LN2@xmlPatScan:

; 863  :     int val, len;
; 864  : 
; 865  :     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN6@xmlPatScan
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN7@xmlPatScan
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN6@xmlPatScan
$LN7@xmlPatScan:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN3@xmlPatScan
$LN6@xmlPatScan:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN13@xmlPatScan
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv89[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN14@xmlPatScan
$LN13@xmlPatScan:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv89[ebp], eax
$LN14@xmlPatScan:
	jmp	SHORT $LN2@xmlPatScan
$LN3@xmlPatScan:

; 866  : 
; 867  :     cur = q = CUR_PTR;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _q$[ebp], edx
	mov	eax, DWORD PTR _q$[ebp]
	mov	DWORD PTR _cur$[ebp], eax

; 868  :     val = xmlStringCurrentChar(NULL, cur, &len);

	lea	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _val$[ebp], eax

; 869  :     if (!IS_LETTER(val) && (val != '_'))

	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jge	SHORT $LN21@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 65		; 00000041H
	jl	SHORT $LN15@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 90		; 0000005aH
	jle	SHORT $LN17@xmlPatScan
$LN15@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 97		; 00000061H
	jl	SHORT $LN16@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 122		; 0000007aH
	jle	SHORT $LN17@xmlPatScan
$LN16@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 192		; 000000c0H
	jl	SHORT $LN18@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 214		; 000000d6H
	jle	SHORT $LN17@xmlPatScan
$LN18@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 216		; 000000d8H
	jl	SHORT $LN19@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 246		; 000000f6H
	jle	SHORT $LN17@xmlPatScan
$LN19@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 248		; 000000f8H
	jge	SHORT $LN17@xmlPatScan
	mov	DWORD PTR tv140[ebp], 0
	jmp	SHORT $LN20@xmlPatScan
$LN17@xmlPatScan:
	mov	DWORD PTR tv140[ebp], 1
$LN20@xmlPatScan:
	mov	eax, DWORD PTR tv140[ebp]
	mov	DWORD PTR tv141[ebp], eax
	jmp	SHORT $LN22@xmlPatScan
$LN21@xmlPatScan:
	push	OFFSET _xmlIsBaseCharGroup
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv141[ebp], eax
$LN22@xmlPatScan:
	cmp	DWORD PTR tv141[ebp], 0
	jne	SHORT $LN4@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jge	SHORT $LN27@xmlPatScan
	mov	DWORD PTR tv150[ebp], 0
	jmp	SHORT $LN28@xmlPatScan
$LN27@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 19968		; 00004e00H
	jl	SHORT $LN23@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 40869		; 00009fa5H
	jle	SHORT $LN24@xmlPatScan
$LN23@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 12295		; 00003007H
	je	SHORT $LN24@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 12321		; 00003021H
	jl	SHORT $LN25@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 12329		; 00003029H
	jle	SHORT $LN24@xmlPatScan
$LN25@xmlPatScan:
	mov	DWORD PTR tv149[ebp], 0
	jmp	SHORT $LN26@xmlPatScan
$LN24@xmlPatScan:
	mov	DWORD PTR tv149[ebp], 1
$LN26@xmlPatScan:
	mov	edx, DWORD PTR tv149[ebp]
	mov	DWORD PTR tv150[ebp], edx
$LN28@xmlPatScan:
	cmp	DWORD PTR tv150[ebp], 0
	jne	SHORT $LN4@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 95		; 0000005fH
	je	SHORT $LN4@xmlPatScan

; 870  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlPatScan
$LN4@xmlPatScan:

; 871  : 
; 872  :     while ((IS_LETTER(val)) || (IS_DIGIT(val)) ||
; 873  :            (val == '.') || (val == '-') ||
; 874  : 	   (val == '_') ||
; 875  : 	   (IS_COMBINING(val)) ||

	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jge	SHORT $LN35@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 65		; 00000041H
	jl	SHORT $LN29@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 90		; 0000005aH
	jle	SHORT $LN31@xmlPatScan
$LN29@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 97		; 00000061H
	jl	SHORT $LN30@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 122		; 0000007aH
	jle	SHORT $LN31@xmlPatScan
$LN30@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 192		; 000000c0H
	jl	SHORT $LN32@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 214		; 000000d6H
	jle	SHORT $LN31@xmlPatScan
$LN32@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 216		; 000000d8H
	jl	SHORT $LN33@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 246		; 000000f6H
	jle	SHORT $LN31@xmlPatScan
$LN33@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 248		; 000000f8H
	jge	SHORT $LN31@xmlPatScan
	mov	DWORD PTR tv166[ebp], 0
	jmp	SHORT $LN34@xmlPatScan
$LN31@xmlPatScan:
	mov	DWORD PTR tv166[ebp], 1
$LN34@xmlPatScan:
	mov	eax, DWORD PTR tv166[ebp]
	mov	DWORD PTR tv167[ebp], eax
	jmp	SHORT $LN36@xmlPatScan
$LN35@xmlPatScan:
	push	OFFSET _xmlIsBaseCharGroup
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv167[ebp], eax
$LN36@xmlPatScan:
	cmp	DWORD PTR tv167[ebp], 0
	jne	$LN9@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jge	SHORT $LN41@xmlPatScan
	mov	DWORD PTR tv176[ebp], 0
	jmp	SHORT $LN42@xmlPatScan
$LN41@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 19968		; 00004e00H
	jl	SHORT $LN37@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 40869		; 00009fa5H
	jle	SHORT $LN38@xmlPatScan
$LN37@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 12295		; 00003007H
	je	SHORT $LN38@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 12321		; 00003021H
	jl	SHORT $LN39@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 12329		; 00003029H
	jle	SHORT $LN38@xmlPatScan
$LN39@xmlPatScan:
	mov	DWORD PTR tv175[ebp], 0
	jmp	SHORT $LN40@xmlPatScan
$LN38@xmlPatScan:
	mov	DWORD PTR tv175[ebp], 1
$LN40@xmlPatScan:
	mov	edx, DWORD PTR tv175[ebp]
	mov	DWORD PTR tv176[ebp], edx
$LN42@xmlPatScan:
	cmp	DWORD PTR tv176[ebp], 0
	jne	$LN9@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jge	SHORT $LN45@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 48		; 00000030H
	jl	SHORT $LN43@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 57		; 00000039H
	jg	SHORT $LN43@xmlPatScan
	mov	DWORD PTR tv184[ebp], 1
	jmp	SHORT $LN44@xmlPatScan
$LN43@xmlPatScan:
	mov	DWORD PTR tv184[ebp], 0
$LN44@xmlPatScan:
	mov	eax, DWORD PTR tv184[ebp]
	mov	DWORD PTR tv185[ebp], eax
	jmp	SHORT $LN46@xmlPatScan
$LN45@xmlPatScan:
	push	OFFSET _xmlIsDigitGroup
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv185[ebp], eax
$LN46@xmlPatScan:
	cmp	DWORD PTR tv185[ebp], 0
	jne	$LN9@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 46		; 0000002eH
	je	SHORT $LN9@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 45		; 0000002dH
	je	SHORT $LN9@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 95		; 0000005fH
	je	SHORT $LN9@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jge	SHORT $LN47@xmlPatScan
	mov	DWORD PTR tv194[ebp], 0
	jmp	SHORT $LN48@xmlPatScan
$LN47@xmlPatScan:
	push	OFFSET _xmlIsCombiningGroup
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv194[ebp], eax
$LN48@xmlPatScan:
	cmp	DWORD PTR tv194[ebp], 0
	jne	SHORT $LN9@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jge	SHORT $LN51@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 183		; 000000b7H
	jne	SHORT $LN49@xmlPatScan
	mov	DWORD PTR tv201[ebp], 1
	jmp	SHORT $LN50@xmlPatScan
$LN49@xmlPatScan:
	mov	DWORD PTR tv201[ebp], 0
$LN50@xmlPatScan:
	mov	eax, DWORD PTR tv201[ebp]
	mov	DWORD PTR tv202[ebp], eax
	jmp	SHORT $LN52@xmlPatScan
$LN51@xmlPatScan:
	push	OFFSET _xmlIsExtenderGroup
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv202[ebp], eax
$LN52@xmlPatScan:
	cmp	DWORD PTR tv202[ebp], 0
	je	SHORT $LN5@xmlPatScan
$LN9@xmlPatScan:

; 876  : 	   (IS_EXTENDER(val))) {
; 877  : 	cur += len;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _cur$[ebp], edx

; 878  : 	val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _val$[ebp], eax

; 879  :     }

	jmp	$LN4@xmlPatScan
$LN5@xmlPatScan:

; 880  :     if (ctxt->dict)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN10@xmlPatScan

; 881  : 	ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);

	mov	eax, DWORD PTR _cur$[ebp]
	sub	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax
	jmp	SHORT $LN11@xmlPatScan
$LN10@xmlPatScan:

; 882  :     else
; 883  : 	ret = xmlStrndup(q, cur - q);

	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, DWORD PTR _q$[ebp]
	push	ecx
	mov	edx, DWORD PTR _q$[ebp]
	push	edx
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
$LN11@xmlPatScan:

; 884  :     CUR_PTR = cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 885  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlPatScan:

; 886  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN55@xmlPatScan
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN55@xmlPatScan:
	DD	1
	DD	$LN54@xmlPatScan
$LN54@xmlPatScan:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN53@xmlPatScan
$LN53@xmlPatScan:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
_xmlPatScanNCName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatScanName
_TEXT	SEGMENT
tv203 = -84						; size = 4
tv202 = -80						; size = 4
tv195 = -76						; size = 4
tv186 = -72						; size = 4
tv185 = -68						; size = 4
tv176 = -64						; size = 4
tv177 = -60						; size = 4
tv168 = -56						; size = 4
tv167 = -52						; size = 4
tv149 = -48						; size = 4
tv150 = -44						; size = 4
tv141 = -40						; size = 4
tv140 = -36						; size = 4
tv89 = -32						; size = 4
_len$ = -24						; size = 4
_val$ = -16						; size = 4
_ret$ = -12						; size = 4
_cur$ = -8						; size = 4
_q$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlPatScanName PROC					; COMDAT

; 822  : xmlPatScanName(xmlPatParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	edi
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 21					; 00000015H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 823  :     const xmlChar *q, *cur;
; 824  :     xmlChar *ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0
$LN2@xmlPatScan:

; 825  :     int val, len;
; 826  : 
; 827  :     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN6@xmlPatScan
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN7@xmlPatScan
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN6@xmlPatScan
$LN7@xmlPatScan:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN3@xmlPatScan
$LN6@xmlPatScan:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN13@xmlPatScan
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv89[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN14@xmlPatScan
$LN13@xmlPatScan:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv89[ebp], eax
$LN14@xmlPatScan:
	jmp	SHORT $LN2@xmlPatScan
$LN3@xmlPatScan:

; 828  : 
; 829  :     cur = q = CUR_PTR;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _q$[ebp], edx
	mov	eax, DWORD PTR _q$[ebp]
	mov	DWORD PTR _cur$[ebp], eax

; 830  :     val = xmlStringCurrentChar(NULL, cur, &len);

	lea	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _val$[ebp], eax

; 831  :     if (!IS_LETTER(val) && (val != '_') && (val != ':'))

	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jge	SHORT $LN21@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 65		; 00000041H
	jl	SHORT $LN15@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 90		; 0000005aH
	jle	SHORT $LN17@xmlPatScan
$LN15@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 97		; 00000061H
	jl	SHORT $LN16@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 122		; 0000007aH
	jle	SHORT $LN17@xmlPatScan
$LN16@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 192		; 000000c0H
	jl	SHORT $LN18@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 214		; 000000d6H
	jle	SHORT $LN17@xmlPatScan
$LN18@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 216		; 000000d8H
	jl	SHORT $LN19@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 246		; 000000f6H
	jle	SHORT $LN17@xmlPatScan
$LN19@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 248		; 000000f8H
	jge	SHORT $LN17@xmlPatScan
	mov	DWORD PTR tv140[ebp], 0
	jmp	SHORT $LN20@xmlPatScan
$LN17@xmlPatScan:
	mov	DWORD PTR tv140[ebp], 1
$LN20@xmlPatScan:
	mov	eax, DWORD PTR tv140[ebp]
	mov	DWORD PTR tv141[ebp], eax
	jmp	SHORT $LN22@xmlPatScan
$LN21@xmlPatScan:
	push	OFFSET _xmlIsBaseCharGroup
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv141[ebp], eax
$LN22@xmlPatScan:
	cmp	DWORD PTR tv141[ebp], 0
	jne	SHORT $LN4@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jge	SHORT $LN27@xmlPatScan
	mov	DWORD PTR tv150[ebp], 0
	jmp	SHORT $LN28@xmlPatScan
$LN27@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 19968		; 00004e00H
	jl	SHORT $LN23@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 40869		; 00009fa5H
	jle	SHORT $LN24@xmlPatScan
$LN23@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 12295		; 00003007H
	je	SHORT $LN24@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 12321		; 00003021H
	jl	SHORT $LN25@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 12329		; 00003029H
	jle	SHORT $LN24@xmlPatScan
$LN25@xmlPatScan:
	mov	DWORD PTR tv149[ebp], 0
	jmp	SHORT $LN26@xmlPatScan
$LN24@xmlPatScan:
	mov	DWORD PTR tv149[ebp], 1
$LN26@xmlPatScan:
	mov	edx, DWORD PTR tv149[ebp]
	mov	DWORD PTR tv150[ebp], edx
$LN28@xmlPatScan:
	cmp	DWORD PTR tv150[ebp], 0
	jne	SHORT $LN4@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 95		; 0000005fH
	je	SHORT $LN4@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 58		; 0000003aH
	je	SHORT $LN4@xmlPatScan

; 832  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlPatScan
$LN4@xmlPatScan:

; 833  : 
; 834  :     while ((IS_LETTER(val)) || (IS_DIGIT(val)) ||
; 835  :            (val == '.') || (val == '-') ||
; 836  : 	   (val == '_') ||
; 837  : 	   (IS_COMBINING(val)) ||

	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jge	SHORT $LN35@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 65		; 00000041H
	jl	SHORT $LN29@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 90		; 0000005aH
	jle	SHORT $LN31@xmlPatScan
$LN29@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 97		; 00000061H
	jl	SHORT $LN30@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 122		; 0000007aH
	jle	SHORT $LN31@xmlPatScan
$LN30@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 192		; 000000c0H
	jl	SHORT $LN32@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 214		; 000000d6H
	jle	SHORT $LN31@xmlPatScan
$LN32@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 216		; 000000d8H
	jl	SHORT $LN33@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 246		; 000000f6H
	jle	SHORT $LN31@xmlPatScan
$LN33@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 248		; 000000f8H
	jge	SHORT $LN31@xmlPatScan
	mov	DWORD PTR tv167[ebp], 0
	jmp	SHORT $LN34@xmlPatScan
$LN31@xmlPatScan:
	mov	DWORD PTR tv167[ebp], 1
$LN34@xmlPatScan:
	mov	eax, DWORD PTR tv167[ebp]
	mov	DWORD PTR tv168[ebp], eax
	jmp	SHORT $LN36@xmlPatScan
$LN35@xmlPatScan:
	push	OFFSET _xmlIsBaseCharGroup
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv168[ebp], eax
$LN36@xmlPatScan:
	cmp	DWORD PTR tv168[ebp], 0
	jne	$LN9@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jge	SHORT $LN41@xmlPatScan
	mov	DWORD PTR tv177[ebp], 0
	jmp	SHORT $LN42@xmlPatScan
$LN41@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 19968		; 00004e00H
	jl	SHORT $LN37@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 40869		; 00009fa5H
	jle	SHORT $LN38@xmlPatScan
$LN37@xmlPatScan:
	cmp	DWORD PTR _val$[ebp], 12295		; 00003007H
	je	SHORT $LN38@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 12321		; 00003021H
	jl	SHORT $LN39@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 12329		; 00003029H
	jle	SHORT $LN38@xmlPatScan
$LN39@xmlPatScan:
	mov	DWORD PTR tv176[ebp], 0
	jmp	SHORT $LN40@xmlPatScan
$LN38@xmlPatScan:
	mov	DWORD PTR tv176[ebp], 1
$LN40@xmlPatScan:
	mov	edx, DWORD PTR tv176[ebp]
	mov	DWORD PTR tv177[ebp], edx
$LN42@xmlPatScan:
	cmp	DWORD PTR tv177[ebp], 0
	jne	$LN9@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jge	SHORT $LN45@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 48		; 00000030H
	jl	SHORT $LN43@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 57		; 00000039H
	jg	SHORT $LN43@xmlPatScan
	mov	DWORD PTR tv185[ebp], 1
	jmp	SHORT $LN44@xmlPatScan
$LN43@xmlPatScan:
	mov	DWORD PTR tv185[ebp], 0
$LN44@xmlPatScan:
	mov	eax, DWORD PTR tv185[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN46@xmlPatScan
$LN45@xmlPatScan:
	push	OFFSET _xmlIsDigitGroup
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv186[ebp], eax
$LN46@xmlPatScan:
	cmp	DWORD PTR tv186[ebp], 0
	jne	$LN9@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 46		; 0000002eH
	je	SHORT $LN9@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 45		; 0000002dH
	je	SHORT $LN9@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 95		; 0000005fH
	je	SHORT $LN9@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jge	SHORT $LN47@xmlPatScan
	mov	DWORD PTR tv195[ebp], 0
	jmp	SHORT $LN48@xmlPatScan
$LN47@xmlPatScan:
	push	OFFSET _xmlIsCombiningGroup
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv195[ebp], eax
$LN48@xmlPatScan:
	cmp	DWORD PTR tv195[ebp], 0
	jne	SHORT $LN9@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jge	SHORT $LN51@xmlPatScan
	cmp	DWORD PTR _val$[ebp], 183		; 000000b7H
	jne	SHORT $LN49@xmlPatScan
	mov	DWORD PTR tv202[ebp], 1
	jmp	SHORT $LN50@xmlPatScan
$LN49@xmlPatScan:
	mov	DWORD PTR tv202[ebp], 0
$LN50@xmlPatScan:
	mov	eax, DWORD PTR tv202[ebp]
	mov	DWORD PTR tv203[ebp], eax
	jmp	SHORT $LN52@xmlPatScan
$LN51@xmlPatScan:
	push	OFFSET _xmlIsExtenderGroup
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv203[ebp], eax
$LN52@xmlPatScan:
	cmp	DWORD PTR tv203[ebp], 0
	je	SHORT $LN5@xmlPatScan
$LN9@xmlPatScan:

; 838  : 	   (IS_EXTENDER(val))) {
; 839  : 	cur += len;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _cur$[ebp], edx

; 840  : 	val = xmlStringCurrentChar(NULL, cur, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _val$[ebp], eax

; 841  :     }

	jmp	$LN4@xmlPatScan
$LN5@xmlPatScan:

; 842  :     if (ctxt->dict)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN10@xmlPatScan

; 843  : 	ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);

	mov	eax, DWORD PTR _cur$[ebp]
	sub	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax
	jmp	SHORT $LN11@xmlPatScan
$LN10@xmlPatScan:

; 844  :     else
; 845  : 	ret = xmlStrndup(q, cur - q);

	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, DWORD PTR _q$[ebp]
	push	ecx
	mov	edx, DWORD PTR _q$[ebp]
	push	edx
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
$LN11@xmlPatScan:

; 846  :     CUR_PTR = cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 847  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlPatScan:

; 848  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN55@xmlPatScan
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN55@xmlPatScan:
	DD	1
	DD	$LN54@xmlPatScan
$LN54@xmlPatScan:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN53@xmlPatScan
$LN53@xmlPatScan:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
_xmlPatScanName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatMatch
_TEXT	SEGMENT
tv73 = -36						; size = 4
_lst$1 = -32						; size = 4
_states$ = -24						; size = 12
_step$ = -8						; size = 4
_i$ = -4						; size = 4
_comp$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlPatMatch PROC					; COMDAT

; 498  : xmlPatMatch(xmlPatternPtr comp, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 499  :     int i;
; 500  :     xmlStepOpPtr step;
; 501  :     xmlStepStates states = {0, 0, NULL}; /* // may require backtrack */

	mov	DWORD PTR _states$[ebp], 0
	mov	DWORD PTR _states$[ebp+4], 0
	mov	DWORD PTR _states$[ebp+8], 0

; 502  : 
; 503  :     if ((comp == NULL) || (node == NULL)) return(-1);

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN12@xmlPatMatc
	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN11@xmlPatMatc
$LN12@xmlPatMatc:
	or	eax, -1
	jmp	$LN1@xmlPatMatc
$LN11@xmlPatMatc:

; 504  :     i = 0;

	mov	DWORD PTR _i$[ebp], 0
$restart$92:

; 505  : restart:
; 506  :     for (;i < comp->nbStep;i++) {

	jmp	SHORT $LN4@xmlPatMatc
$LN2@xmlPatMatc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlPatMatc:
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$found$93

; 507  : 	step = &comp->steps[i];

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _comp$[ebp]
	add	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _step$[ebp], eax

; 508  : 	switch (step->op) {

	mov	edx, DWORD PTR _step$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv73[ebp], eax
	cmp	DWORD PTR tv73[ebp], 8
	ja	$LN5@xmlPatMatc
	mov	ecx, DWORD PTR tv73[ebp]
	jmp	DWORD PTR $LN91@xmlPatMatc[ecx*4]
$LN13@xmlPatMatc:

; 509  :             case XML_OP_END:
; 510  : 		goto found;

	jmp	$found$93
$LN14@xmlPatMatc:

; 511  :             case XML_OP_ROOT:
; 512  : 		if (node->type == XML_NAMESPACE_DECL)

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 18			; 00000012H
	jne	SHORT $LN15@xmlPatMatc

; 513  : 		    goto rollback;

	jmp	$rollback$94
$LN15@xmlPatMatc:

; 514  : 		node = node->parent;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _node$[ebp], ecx

; 515  : 		if ((node->type == XML_DOCUMENT_NODE) ||
; 516  : #ifdef LIBXML_DOCB_ENABLED
; 517  : 		    (node->type == XML_DOCB_DOCUMENT_NODE) ||

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 9
	je	SHORT $LN17@xmlPatMatc
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 21			; 00000015H
	je	SHORT $LN17@xmlPatMatc
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	jne	SHORT $LN16@xmlPatMatc
$LN17@xmlPatMatc:

; 518  : #endif
; 519  : 		    (node->type == XML_HTML_DOCUMENT_NODE))
; 520  : 		    continue;

	jmp	SHORT $LN2@xmlPatMatc
$LN16@xmlPatMatc:

; 521  : 		goto rollback;

	jmp	$rollback$94
$LN18@xmlPatMatc:

; 522  :             case XML_OP_ELEM:
; 523  : 		if (node->type != XML_ELEMENT_NODE)

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 1
	je	SHORT $LN19@xmlPatMatc

; 524  : 		    goto rollback;

	jmp	$rollback$94
$LN19@xmlPatMatc:

; 525  : 		if (step->value == NULL)

	mov	eax, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN20@xmlPatMatc

; 526  : 		    continue;

	jmp	$LN2@xmlPatMatc
$LN20@xmlPatMatc:

; 527  : 		if (step->value[0] != node->name[0])

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _step$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+edx]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+8]
	movzx	ecx, BYTE PTR [eax+ecx]
	cmp	edx, ecx
	je	SHORT $LN21@xmlPatMatc

; 528  : 		    goto rollback;

	jmp	$rollback$94
$LN21@xmlPatMatc:

; 529  : 		if (!xmlStrEqual(step->value, node->name))

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _step$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN22@xmlPatMatc

; 530  : 		    goto rollback;

	jmp	$rollback$94
$LN22@xmlPatMatc:

; 531  : 
; 532  : 		/* Namespace test */
; 533  : 		if (node->ns == NULL) {

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN23@xmlPatMatc

; 534  : 		    if (step->value2 != NULL)

	mov	ecx, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN25@xmlPatMatc

; 535  : 			goto rollback;

	jmp	$rollback$94
$LN25@xmlPatMatc:

; 536  : 		} else if (node->ns->href != NULL) {

	jmp	SHORT $LN24@xmlPatMatc
$LN23@xmlPatMatc:
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN24@xmlPatMatc

; 537  : 		    if (step->value2 == NULL)

	mov	ecx, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN27@xmlPatMatc

; 538  : 			goto rollback;

	jmp	$rollback$94
$LN27@xmlPatMatc:

; 539  : 		    if (!xmlStrEqual(step->value2, node->ns->href))

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _step$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN24@xmlPatMatc

; 540  : 			goto rollback;

	jmp	$rollback$94
$LN24@xmlPatMatc:

; 541  : 		}
; 542  : 		continue;

	jmp	$LN2@xmlPatMatc
$LN29@xmlPatMatc:

; 543  :             case XML_OP_CHILD: {
; 544  : 		xmlNodePtr lst;
; 545  : 
; 546  : 		if ((node->type != XML_ELEMENT_NODE) &&
; 547  : 		    (node->type != XML_DOCUMENT_NODE) &&
; 548  : #ifdef LIBXML_DOCB_ENABLED
; 549  : 		    (node->type != XML_DOCB_DOCUMENT_NODE) &&

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 1
	je	SHORT $LN30@xmlPatMatc
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 9
	je	SHORT $LN30@xmlPatMatc
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 21			; 00000015H
	je	SHORT $LN30@xmlPatMatc
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	je	SHORT $LN30@xmlPatMatc

; 550  : #endif
; 551  : 		    (node->type != XML_HTML_DOCUMENT_NODE))
; 552  : 		    goto rollback;

	jmp	$rollback$94
$LN30@xmlPatMatc:

; 553  : 
; 554  : 		lst = node->children;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _lst$1[ebp], eax

; 555  : 
; 556  : 		if (step->value != NULL) {

	mov	ecx, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN31@xmlPatMatc
$LN7@xmlPatMatc:

; 557  : 		    while (lst != NULL) {

	cmp	DWORD PTR _lst$1[ebp], 0
	je	SHORT $LN8@xmlPatMatc

; 558  : 			if ((lst->type == XML_ELEMENT_NODE) &&
; 559  : 			    (step->value[0] == lst->name[0]) &&

	mov	edx, DWORD PTR _lst$1[ebp]
	cmp	DWORD PTR [edx+4], 1
	jne	SHORT $LN32@xmlPatMatc
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _step$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax+ecx]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _lst$1[ebp]
	mov	edx, DWORD PTR [edx+8]
	movzx	eax, BYTE PTR [edx+eax]
	cmp	ecx, eax
	jne	SHORT $LN32@xmlPatMatc
	mov	ecx, DWORD PTR _lst$1[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _step$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN32@xmlPatMatc

; 560  : 			    (xmlStrEqual(step->value, lst->name)))
; 561  : 			    break;

	jmp	SHORT $LN8@xmlPatMatc
$LN32@xmlPatMatc:

; 562  : 			lst = lst->next;

	mov	edx, DWORD PTR _lst$1[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _lst$1[ebp], eax

; 563  : 		    }

	jmp	SHORT $LN7@xmlPatMatc
$LN8@xmlPatMatc:

; 564  : 		    if (lst != NULL)

	cmp	DWORD PTR _lst$1[ebp], 0
	je	SHORT $LN31@xmlPatMatc

; 565  : 			continue;

	jmp	$LN2@xmlPatMatc
$LN31@xmlPatMatc:

; 566  : 		}
; 567  : 		goto rollback;

	jmp	$rollback$94
$LN34@xmlPatMatc:

; 568  : 	    }
; 569  :             case XML_OP_ATTR:
; 570  : 		if (node->type != XML_ATTRIBUTE_NODE)

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 2
	je	SHORT $LN35@xmlPatMatc

; 571  : 		    goto rollback;

	jmp	$rollback$94
$LN35@xmlPatMatc:

; 572  : 		if (step->value != NULL) {

	mov	edx, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN36@xmlPatMatc

; 573  : 		    if (step->value[0] != node->name[0])

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _step$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax+ecx]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [edx+8]
	movzx	eax, BYTE PTR [edx+eax]
	cmp	ecx, eax
	je	SHORT $LN37@xmlPatMatc

; 574  : 			goto rollback;

	jmp	$rollback$94
$LN37@xmlPatMatc:

; 575  : 		    if (!xmlStrEqual(step->value, node->name))

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _step$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN36@xmlPatMatc

; 576  : 			goto rollback;

	jmp	$rollback$94
$LN36@xmlPatMatc:

; 577  : 		}
; 578  : 		/* Namespace test */
; 579  : 		if (node->ns == NULL) {

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jne	SHORT $LN39@xmlPatMatc

; 580  : 		    if (step->value2 != NULL)

	mov	eax, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN41@xmlPatMatc

; 581  : 			goto rollback;

	jmp	$rollback$94
$LN41@xmlPatMatc:

; 582  : 		} else if (step->value2 != NULL) {

	jmp	SHORT $LN40@xmlPatMatc
$LN39@xmlPatMatc:
	mov	ecx, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN40@xmlPatMatc

; 583  : 		    if (!xmlStrEqual(step->value2, node->ns->href))

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _step$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN40@xmlPatMatc

; 584  : 			goto rollback;

	jmp	$rollback$94
$LN40@xmlPatMatc:

; 585  : 		}
; 586  : 		continue;

	jmp	$LN2@xmlPatMatc
$LN44@xmlPatMatc:

; 587  :             case XML_OP_PARENT:
; 588  : 		if ((node->type == XML_DOCUMENT_NODE) ||
; 589  : 		    (node->type == XML_HTML_DOCUMENT_NODE) ||
; 590  : #ifdef LIBXML_DOCB_ENABLED
; 591  : 		    (node->type == XML_DOCB_DOCUMENT_NODE) ||

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 9
	je	SHORT $LN46@xmlPatMatc
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 13			; 0000000dH
	je	SHORT $LN46@xmlPatMatc
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 21			; 00000015H
	je	SHORT $LN46@xmlPatMatc
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	jne	SHORT $LN45@xmlPatMatc
$LN46@xmlPatMatc:

; 592  : #endif
; 593  : 		    (node->type == XML_NAMESPACE_DECL))
; 594  : 		    goto rollback;

	jmp	$rollback$94
$LN45@xmlPatMatc:

; 595  : 		node = node->parent;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _node$[ebp], eax

; 596  : 		if (node == NULL)

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN47@xmlPatMatc

; 597  : 		    goto rollback;

	jmp	$rollback$94
$LN47@xmlPatMatc:

; 598  : 		if (step->value == NULL)

	mov	ecx, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN48@xmlPatMatc

; 599  : 		    continue;

	jmp	$LN2@xmlPatMatc
$LN48@xmlPatMatc:

; 600  : 		if (step->value[0] != node->name[0])

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _step$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx+eax]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	movzx	edx, BYTE PTR [ecx+edx]
	cmp	eax, edx
	je	SHORT $LN49@xmlPatMatc

; 601  : 		    goto rollback;

	jmp	$rollback$94
$LN49@xmlPatMatc:

; 602  : 		if (!xmlStrEqual(step->value, node->name))

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _step$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN50@xmlPatMatc

; 603  : 		    goto rollback;

	jmp	$rollback$94
$LN50@xmlPatMatc:

; 604  : 		/* Namespace test */
; 605  : 		if (node->ns == NULL) {

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	jne	SHORT $LN51@xmlPatMatc

; 606  : 		    if (step->value2 != NULL)

	mov	edx, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN53@xmlPatMatc

; 607  : 			goto rollback;

	jmp	$rollback$94
$LN53@xmlPatMatc:

; 608  : 		} else if (node->ns->href != NULL) {

	jmp	SHORT $LN52@xmlPatMatc
$LN51@xmlPatMatc:
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN52@xmlPatMatc

; 609  : 		    if (step->value2 == NULL)

	mov	edx, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN55@xmlPatMatc

; 610  : 			goto rollback;

	jmp	$rollback$94
$LN55@xmlPatMatc:

; 611  : 		    if (!xmlStrEqual(step->value2, node->ns->href))

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _step$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN52@xmlPatMatc

; 612  : 			goto rollback;

	jmp	$rollback$94
$LN52@xmlPatMatc:

; 613  : 		}
; 614  : 		continue;

	jmp	$LN2@xmlPatMatc
$LN57@xmlPatMatc:

; 615  :             case XML_OP_ANCESTOR:
; 616  : 		/* TODO: implement coalescing of ANCESTOR/NODE ops */
; 617  : 		if (step->value == NULL) {

	mov	edx, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN58@xmlPatMatc

; 618  : 		    i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 619  : 		    step = &comp->steps[i];

	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, DWORD PTR _comp$[ebp]
	add	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR _step$[ebp], ecx

; 620  : 		    if (step->op == XML_OP_ROOT)

	mov	eax, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN59@xmlPatMatc

; 621  : 			goto found;

	jmp	$found$93
$LN59@xmlPatMatc:

; 622  : 		    if (step->op != XML_OP_ELEM)

	mov	ecx, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [ecx], 2
	je	SHORT $LN60@xmlPatMatc

; 623  : 			goto rollback;

	jmp	$rollback$94
$LN60@xmlPatMatc:

; 624  : 		    if (step->value == NULL)

	mov	edx, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN58@xmlPatMatc

; 625  : 			return(-1);

	or	eax, -1
	jmp	$LN1@xmlPatMatc
$LN58@xmlPatMatc:

; 626  : 		}
; 627  : 		if (node == NULL)

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN62@xmlPatMatc

; 628  : 		    goto rollback;

	jmp	$rollback$94
$LN62@xmlPatMatc:

; 629  : 		if ((node->type == XML_DOCUMENT_NODE) ||
; 630  : 		    (node->type == XML_HTML_DOCUMENT_NODE) ||
; 631  : #ifdef LIBXML_DOCB_ENABLED
; 632  : 		    (node->type == XML_DOCB_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 9
	je	SHORT $LN64@xmlPatMatc
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	je	SHORT $LN64@xmlPatMatc
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 21			; 00000015H
	je	SHORT $LN64@xmlPatMatc
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN63@xmlPatMatc
$LN64@xmlPatMatc:

; 633  : #endif
; 634  : 		    (node->type == XML_NAMESPACE_DECL))
; 635  : 		    goto rollback;

	jmp	$rollback$94
$LN63@xmlPatMatc:

; 636  : 		node = node->parent;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _node$[ebp], edx
$LN9@xmlPatMatc:

; 637  : 		while (node != NULL) {

	cmp	DWORD PTR _node$[ebp], 0
	je	$LN10@xmlPatMatc

; 638  : 		    if ((node->type == XML_ELEMENT_NODE) &&
; 639  : 			(step->value[0] == node->name[0]) &&

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	$LN65@xmlPatMatc
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _step$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+edx]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+8]
	movzx	ecx, BYTE PTR [eax+ecx]
	cmp	edx, ecx
	jne	SHORT $LN65@xmlPatMatc
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _step$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN65@xmlPatMatc

; 640  : 			(xmlStrEqual(step->value, node->name))) {
; 641  : 			/* Namespace test */
; 642  : 			if (node->ns == NULL) {

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN66@xmlPatMatc

; 643  : 			    if (step->value2 == NULL)

	mov	ecx, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN68@xmlPatMatc

; 644  : 				break;

	jmp	SHORT $LN10@xmlPatMatc
$LN68@xmlPatMatc:

; 645  : 			} else if (node->ns->href != NULL) {

	jmp	SHORT $LN65@xmlPatMatc
$LN66@xmlPatMatc:
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN65@xmlPatMatc

; 646  : 			    if ((step->value2 != NULL) &&

	mov	ecx, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN65@xmlPatMatc
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _step$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN65@xmlPatMatc

; 647  : 			        (xmlStrEqual(step->value2, node->ns->href)))
; 648  : 				break;

	jmp	SHORT $LN10@xmlPatMatc
$LN65@xmlPatMatc:

; 649  : 			}
; 650  : 		    }
; 651  : 		    node = node->parent;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _node$[ebp], edx

; 652  : 		}

	jmp	$LN9@xmlPatMatc
$LN10@xmlPatMatc:

; 653  : 		if (node == NULL)

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN71@xmlPatMatc

; 654  : 		    goto rollback;

	jmp	$rollback$94
$LN71@xmlPatMatc:

; 655  : 		/*
; 656  : 		 * prepare a potential rollback from here
; 657  : 		 * for ancestors of that node.
; 658  : 		 */
; 659  : 		if (step->op == XML_OP_ANCESTOR)

	mov	eax, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [eax], 6
	jne	SHORT $LN72@xmlPatMatc

; 660  : 		    xmlPatPushState(&states, i, node);

	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	lea	eax, DWORD PTR _states$[ebp]
	push	eax
	call	_xmlPatPushState
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN73@xmlPatMatc
$LN72@xmlPatMatc:

; 661  : 		else
; 662  : 		    xmlPatPushState(&states, i - 1, node);

	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	push	edx
	lea	eax, DWORD PTR _states$[ebp]
	push	eax
	call	_xmlPatPushState
	add	esp, 12					; 0000000cH
$LN73@xmlPatMatc:

; 663  : 		continue;

	jmp	$LN2@xmlPatMatc
$LN74@xmlPatMatc:

; 664  :             case XML_OP_NS:
; 665  : 		if (node->type != XML_ELEMENT_NODE)

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 1
	je	SHORT $LN75@xmlPatMatc

; 666  : 		    goto rollback;

	jmp	$rollback$94
$LN75@xmlPatMatc:

; 667  : 		if (node->ns == NULL) {

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jne	SHORT $LN76@xmlPatMatc

; 668  : 		    if (step->value != NULL)

	mov	eax, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN78@xmlPatMatc

; 669  : 			goto rollback;

	jmp	SHORT $rollback$94
$LN78@xmlPatMatc:

; 670  : 		} else if (node->ns->href != NULL) {

	jmp	SHORT $LN77@xmlPatMatc
$LN76@xmlPatMatc:
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN77@xmlPatMatc

; 671  : 		    if (step->value == NULL)

	mov	eax, DWORD PTR _step$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN80@xmlPatMatc

; 672  : 			goto rollback;

	jmp	SHORT $rollback$94
$LN80@xmlPatMatc:

; 673  : 		    if (!xmlStrEqual(step->value, node->ns->href))

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _step$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN77@xmlPatMatc

; 674  : 			goto rollback;

	jmp	SHORT $rollback$94
$LN77@xmlPatMatc:

; 675  : 		}
; 676  : 		break;

	jmp	SHORT $LN5@xmlPatMatc
$LN82@xmlPatMatc:

; 677  :             case XML_OP_ALL:
; 678  : 		if (node->type != XML_ELEMENT_NODE)

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN5@xmlPatMatc

; 679  : 		    goto rollback;

	jmp	SHORT $rollback$94
$LN5@xmlPatMatc:

; 680  : 		break;
; 681  : 	}
; 682  :     }

	jmp	$LN2@xmlPatMatc
$found$93:

; 683  : found:
; 684  :     if (states.states != NULL) {

	cmp	DWORD PTR _states$[ebp+8], 0
	je	SHORT $LN84@xmlPatMatc

; 685  :         /* Free the rollback states */
; 686  : 	xmlFree(states.states);

	mov	esi, esp
	mov	ecx, DWORD PTR _states$[ebp+8]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN84@xmlPatMatc:

; 687  :     }
; 688  :     return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlPatMatc
$rollback$94:

; 689  : rollback:
; 690  :     /* got an error try to rollback */
; 691  :     if (states.states == NULL)

	cmp	DWORD PTR _states$[ebp+8], 0
	jne	SHORT $LN85@xmlPatMatc

; 692  : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlPatMatc
$LN85@xmlPatMatc:

; 693  :     if (states.nbstates <= 0) {

	cmp	DWORD PTR _states$[ebp], 0
	jg	SHORT $LN86@xmlPatMatc

; 694  : 	xmlFree(states.states);

	mov	esi, esp
	mov	edx, DWORD PTR _states$[ebp+8]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 695  : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlPatMatc
$LN86@xmlPatMatc:

; 696  :     }
; 697  :     states.nbstates--;

	mov	eax, DWORD PTR _states$[ebp]
	sub	eax, 1
	mov	DWORD PTR _states$[ebp], eax

; 698  :     i = states.states[states.nbstates].step;

	mov	ecx, DWORD PTR _states$[ebp]
	mov	edx, DWORD PTR _states$[ebp+8]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _i$[ebp], eax

; 699  :     node = states.states[states.nbstates].node;

	mov	ecx, DWORD PTR _states$[ebp]
	mov	edx, DWORD PTR _states$[ebp+8]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	mov	DWORD PTR _node$[ebp], eax

; 700  : #if 0
; 701  :     fprintf(stderr, "Pop: %d, %s\n", i, node->name);
; 702  : #endif
; 703  :     goto restart;

	jmp	$restart$92
$LN1@xmlPatMatc:

; 704  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN90@xmlPatMatc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN90@xmlPatMatc:
	DD	1
	DD	$LN89@xmlPatMatc
$LN89@xmlPatMatc:
	DD	-24					; ffffffe8H
	DD	12					; 0000000cH
	DD	$LN88@xmlPatMatc
$LN88@xmlPatMatc:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
	npad	1
$LN91@xmlPatMatc:
	DD	$LN13@xmlPatMatc
	DD	$LN14@xmlPatMatc
	DD	$LN18@xmlPatMatc
	DD	$LN29@xmlPatMatc
	DD	$LN34@xmlPatMatc
	DD	$LN44@xmlPatMatc
	DD	$LN57@xmlPatMatc
	DD	$LN74@xmlPatMatc
	DD	$LN82@xmlPatMatc
_xmlPatMatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatPushState
_TEXT	SEGMENT
_tmp$1 = -4						; size = 4
_states$ = 8						; size = 4
_step$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlPatPushState PROC					; COMDAT

; 464  : xmlPatPushState(xmlStepStates *states, int step, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 465  :     if ((states->states == NULL) || (states->maxstates <= 0)) {

	mov	eax, DWORD PTR _states$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN4@xmlPatPush
	mov	ecx, DWORD PTR _states$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jg	SHORT $LN2@xmlPatPush
$LN4@xmlPatPush:

; 466  :         states->maxstates = 4;

	mov	edx, DWORD PTR _states$[ebp]
	mov	DWORD PTR [edx+4], 4

; 467  : 	states->nbstates = 0;

	mov	eax, DWORD PTR _states$[ebp]
	mov	DWORD PTR [eax], 0

; 468  : 	states->states = xmlMalloc(4 * sizeof(xmlStepState));

	mov	esi, esp
	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _states$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 469  :     }

	jmp	SHORT $LN3@xmlPatPush
$LN2@xmlPatPush:

; 470  :     else if (states->maxstates <= states->nbstates) {

	mov	edx, DWORD PTR _states$[ebp]
	mov	eax, DWORD PTR _states$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jg	SHORT $LN3@xmlPatPush

; 471  :         xmlStepState *tmp;
; 472  : 
; 473  : 	tmp = (xmlStepStatePtr) xmlRealloc(states->states,

	mov	edx, DWORD PTR _states$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 1
	shl	eax, 3
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _states$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 474  : 			       2 * states->maxstates * sizeof(xmlStepState));
; 475  : 	if (tmp == NULL)

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN6@xmlPatPush

; 476  : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlPatPush
$LN6@xmlPatPush:

; 477  : 	states->states = tmp;

	mov	eax, DWORD PTR _states$[ebp]
	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [eax+8], ecx

; 478  : 	states->maxstates *= 2;

	mov	edx, DWORD PTR _states$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 1
	mov	ecx, DWORD PTR _states$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN3@xmlPatPush:

; 479  :     }
; 480  :     states->states[states->nbstates].step = step;

	mov	edx, DWORD PTR _states$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _states$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _step$[ebp]
	mov	DWORD PTR [edx+eax*8], ecx

; 481  :     states->states[states->nbstates++].node = node;

	mov	edx, DWORD PTR _states$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _states$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edx+eax*8+4], ecx
	mov	edx, DWORD PTR _states$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _states$[ebp]
	mov	DWORD PTR [ecx], eax

; 482  : #if 0
; 483  :     fprintf(stderr, "Push: %d, %s\n", step, node->name);
; 484  : #endif
; 485  :     return(0);

	xor	eax, eax
$LN1@xmlPatPush:

; 486  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlPatPushState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlReversePattern
_TEXT	SEGMENT
_op$1 = -20						; size = 4
_tmp$2 = -16						; size = 4
_temp$3 = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_comp$ = 8						; size = 4
_xmlReversePattern PROC					; COMDAT

; 408  : xmlReversePattern(xmlPatternPtr comp) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 409  :     int i, j;
; 410  : 
; 411  :     /*
; 412  :      * remove the leading // for //a or .//a
; 413  :      */
; 414  :     if ((comp->nbStep > 0) && (comp->steps[0].op == XML_OP_ANCESTOR)) {

	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jle	$LN7@xmlReverse
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx+edx], 6
	jne	$LN7@xmlReverse

; 415  :         for (i = 0, j = 1;j < comp->nbStep;i++,j++) {

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN4@xmlReverse
$LN2@xmlReverse:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@xmlReverse:
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	SHORT $LN3@xmlReverse

; 416  : 	    comp->steps[i].value = comp->steps[j].value;

	imul	eax, DWORD PTR _j$[ebp], 12
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	esi, DWORD PTR _comp$[ebp]
	mov	esi, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [edx+eax+4]
	mov	DWORD PTR [esi+ecx+4], edx

; 417  : 	    comp->steps[i].value2 = comp->steps[j].value2;

	imul	eax, DWORD PTR _j$[ebp], 12
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	esi, DWORD PTR _comp$[ebp]
	mov	esi, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [edx+eax+8]
	mov	DWORD PTR [esi+ecx+8], edx

; 418  : 	    comp->steps[i].op = comp->steps[j].op;

	imul	eax, DWORD PTR _j$[ebp], 12
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	esi, DWORD PTR _comp$[ebp]
	mov	esi, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [esi+ecx], edx

; 419  : 	}

	jmp	SHORT $LN2@xmlReverse
$LN3@xmlReverse:

; 420  : 	comp->nbStep--;

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, 1
	mov	edx, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [edx+20], ecx
$LN7@xmlReverse:

; 421  :     }
; 422  :     if (comp->nbStep >= comp->maxStep) {

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+24]
	jl	SHORT $LN8@xmlReverse

; 423  :         xmlStepOpPtr temp;
; 424  : 	temp = (xmlStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shl	ecx, 1
	imul	edx, ecx, 12
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _temp$3[ebp], eax

; 425  : 	                                 sizeof(xmlStepOp));
; 426  :         if (temp == NULL) {

	cmp	DWORD PTR _temp$3[ebp], 0
	jne	SHORT $LN9@xmlReverse

; 427  : 	    ERROR(ctxt, NULL, NULL,
; 428  : 			     "xmlReversePattern: realloc failed\n");
; 429  : 	    return (-1);

	or	eax, -1
	jmp	$LN1@xmlReverse
$LN9@xmlReverse:

; 430  : 	}
; 431  : 	comp->steps = temp;

	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR _temp$3[ebp]
	mov	DWORD PTR [edx+28], eax

; 432  : 	comp->maxStep *= 2;

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	shl	edx, 1
	mov	eax, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [eax+24], edx
$LN8@xmlReverse:

; 433  :     }
; 434  :     i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 435  :     j = comp->nbStep - 1;

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN5@xmlReverse:

; 436  :     while (j > i) {

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	jle	$LN6@xmlReverse

; 437  : 	register const xmlChar *tmp;
; 438  : 	register xmlPatOp op;
; 439  : 	tmp = comp->steps[i].value;

	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+ecx+4]
	mov	DWORD PTR _tmp$2[ebp], ecx

; 440  : 	comp->steps[i].value = comp->steps[j].value;

	imul	edx, DWORD PTR _j$[ebp], 12
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	esi, DWORD PTR _comp$[ebp]
	mov	esi, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [ecx+edx+4]
	mov	DWORD PTR [esi+eax+4], ecx

; 441  : 	comp->steps[j].value = tmp;

	imul	edx, DWORD PTR _j$[ebp], 12
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _tmp$2[ebp]
	mov	DWORD PTR [ecx+edx+4], eax

; 442  : 	tmp = comp->steps[i].value2;

	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR _tmp$2[ebp], ecx

; 443  : 	comp->steps[i].value2 = comp->steps[j].value2;

	imul	edx, DWORD PTR _j$[ebp], 12
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	esi, DWORD PTR _comp$[ebp]
	mov	esi, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR [esi+eax+8], ecx

; 444  : 	comp->steps[j].value2 = tmp;

	imul	edx, DWORD PTR _j$[ebp], 12
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _tmp$2[ebp]
	mov	DWORD PTR [ecx+edx+8], eax

; 445  : 	op = comp->steps[i].op;

	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _op$1[ebp], ecx

; 446  : 	comp->steps[i].op = comp->steps[j].op;

	imul	edx, DWORD PTR _j$[ebp], 12
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	esi, DWORD PTR _comp$[ebp]
	mov	esi, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [esi+eax], ecx

; 447  : 	comp->steps[j].op = op;

	imul	edx, DWORD PTR _j$[ebp], 12
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _op$1[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 448  : 	j--;

	mov	ecx, DWORD PTR _j$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 449  : 	i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 450  :     }

	jmp	$LN5@xmlReverse
$LN6@xmlReverse:

; 451  :     comp->steps[comp->nbStep].value = NULL;

	mov	eax, DWORD PTR _comp$[ebp]
	imul	ecx, DWORD PTR [eax+20], 12
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [eax+ecx+4], 0

; 452  :     comp->steps[comp->nbStep].value2 = NULL;

	mov	ecx, DWORD PTR _comp$[ebp]
	imul	edx, DWORD PTR [ecx+20], 12
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+edx+8], 0

; 453  :     comp->steps[comp->nbStep++].op = XML_OP_END;

	mov	edx, DWORD PTR _comp$[ebp]
	imul	eax, DWORD PTR [edx+20], 12
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [edx+eax], 0
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 454  :     return(0);

	xor	eax, eax
$LN1@xmlReverse:

; 455  : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlReversePattern ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatternAdd
_TEXT	SEGMENT
_temp$1 = -4						; size = 4
_ctxt$ = 8						; size = 4
_comp$ = 12						; size = 4
_op$ = 16						; size = 4
_value$ = 20						; size = 4
_value2$ = 24						; size = 4
_xmlPatternAdd PROC					; COMDAT

; 350  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 351  :     if (comp->nbStep >= comp->maxStep) {

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+24]
	jl	SHORT $LN2@xmlPattern

; 352  :         xmlStepOpPtr temp;
; 353  : 	temp = (xmlStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shl	ecx, 1
	imul	edx, ecx, 12
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _temp$1[ebp], eax

; 354  : 	                                 sizeof(xmlStepOp));
; 355  :         if (temp == NULL) {

	cmp	DWORD PTR _temp$1[ebp], 0
	jne	SHORT $LN3@xmlPattern

; 356  : 	    ERROR(ctxt, NULL, NULL,
; 357  : 			     "xmlPatternAdd: realloc failed\n");
; 358  : 	    return (-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlPattern
$LN3@xmlPattern:

; 359  : 	}
; 360  : 	comp->steps = temp;

	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR _temp$1[ebp]
	mov	DWORD PTR [edx+28], eax

; 361  : 	comp->maxStep *= 2;

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	shl	edx, 1
	mov	eax, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [eax+24], edx
$LN2@xmlPattern:

; 362  :     }
; 363  :     comp->steps[comp->nbStep].op = op;

	mov	ecx, DWORD PTR _comp$[ebp]
	imul	edx, DWORD PTR [ecx+20], 12
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _op$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 364  :     comp->steps[comp->nbStep].value = value;

	mov	ecx, DWORD PTR _comp$[ebp]
	imul	edx, DWORD PTR [ecx+20], 12
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx+edx+4], eax

; 365  :     comp->steps[comp->nbStep].value2 = value2;

	mov	ecx, DWORD PTR _comp$[ebp]
	imul	edx, DWORD PTR [ecx+20], 12
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _value2$[ebp]
	mov	DWORD PTR [ecx+edx+8], eax

; 366  :     comp->nbStep++;

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, 1
	mov	eax, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [eax+20], edx

; 367  :     return (0);

	xor	eax, eax
$LN1@xmlPattern:

; 368  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlPatternAdd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlFreePatParserContext
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlFreePatParserContext PROC				; COMDAT

; 328  : xmlFreePatParserContext(xmlPatParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 329  :     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlFreePat

; 330  : 	return;

	jmp	SHORT $LN1@xmlFreePat
$LN2@xmlFreePat:

; 331  :     memset(ctxt, -1, sizeof(xmlPatParserContext));

	or	eax, -1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], eax

; 332  :     xmlFree(ctxt);

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlFreePat:

; 333  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFreePatParserContext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlNewPatParserContext
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_cur$ = -4						; size = 4
_pattern$ = 8						; size = 4
_dict$ = 12						; size = 4
_namespaces$ = 16					; size = 4
_xmlNewPatParserContext PROC				; COMDAT

; 293  :                        const xmlChar **namespaces) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 294  :     xmlPatParserContextPtr cur;
; 295  : 
; 296  :     if (pattern == NULL)

	cmp	DWORD PTR _pattern$[ebp], 0
	jne	SHORT $LN5@xmlNewPatP

; 297  :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNewPatP
$LN5@xmlNewPatP:

; 298  : 
; 299  :     cur = (xmlPatParserContextPtr) xmlMalloc(sizeof(xmlPatParserContext));

	mov	esi, esp
	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cur$[ebp], eax

; 300  :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN6@xmlNewPatP

; 301  : 	ERROR(NULL, NULL, NULL,
; 302  : 		"xmlNewPatParserContext : malloc failed\n");
; 303  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNewPatP
$LN6@xmlNewPatP:

; 304  :     }
; 305  :     memset(cur, 0, sizeof(xmlPatParserContext));

	xor	eax, eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], eax

; 306  :     cur->dict = dict;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [edx+12], eax

; 307  :     cur->cur = pattern;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _pattern$[ebp]
	mov	DWORD PTR [ecx], edx

; 308  :     cur->base = pattern;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _pattern$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 309  :     if (namespaces != NULL) {

	cmp	DWORD PTR _namespaces$[ebp], 0
	je	SHORT $LN7@xmlNewPatP

; 310  :         int i;
; 311  :         for (i = 0;namespaces[2 * i] != NULL;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@xmlNewPatP
$LN2@xmlNewPatP:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN4@xmlNewPatP:
	mov	eax, DWORD PTR _i$1[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _namespaces$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN3@xmlNewPatP

; 312  :             ;

	jmp	SHORT $LN2@xmlNewPatP
$LN3@xmlNewPatP:

; 313  :         cur->nb_namespaces = i;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR _i$1[ebp]
	mov	DWORD PTR [edx+28], eax

; 314  :     } else {

	jmp	SHORT $LN8@xmlNewPatP
$LN7@xmlNewPatP:

; 315  :         cur->nb_namespaces = 0;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+28], 0
$LN8@xmlNewPatP:

; 316  :     }
; 317  :     cur->namespaces = namespaces;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR _namespaces$[ebp]
	mov	DWORD PTR [edx+24], eax

; 318  :     return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
$LN1@xmlNewPatP:

; 319  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNewPatParserContext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlNewPattern
_TEXT	SEGMENT
_cur$ = -4						; size = 4
_xmlNewPattern PROC					; COMDAT

; 203  : xmlNewPattern(void) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 204  :     xmlPatternPtr cur;
; 205  : 
; 206  :     cur = (xmlPatternPtr) xmlMalloc(sizeof(xmlPattern));

	mov	esi, esp
	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cur$[ebp], eax

; 207  :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlNewPatt

; 208  : 	ERROR(NULL, NULL, NULL,
; 209  : 		"xmlNewPattern : malloc failed\n");
; 210  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNewPatt
$LN2@xmlNewPatt:

; 211  :     }
; 212  :     memset(cur, 0, sizeof(xmlPattern));

	xor	eax, eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], eax
	mov	DWORD PTR [ecx+32], eax

; 213  :     cur->maxStep = 10;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+24], 10			; 0000000aH

; 214  :     cur->steps = (xmlStepOpPtr) xmlMalloc(cur->maxStep * sizeof(xmlStepOp));

	mov	eax, DWORD PTR _cur$[ebp]
	imul	ecx, DWORD PTR [eax+24], 12
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+28], eax

; 215  :     if (cur->steps == NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN3@xmlNewPatt

; 216  :         xmlFree(cur);

	mov	esi, esp
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 217  : 	ERROR(NULL, NULL, NULL,
; 218  : 		"xmlNewPattern : malloc failed\n");
; 219  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNewPatt
$LN3@xmlNewPatt:

; 220  :     }
; 221  :     return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
$LN1@xmlNewPatt:

; 222  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNewPattern ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlFreeStreamComp
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_xmlFreeStreamComp PROC					; COMDAT

; 1524 : xmlFreeStreamComp(xmlStreamCompPtr comp) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 1525 :     if (comp != NULL) {

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN1@xmlFreeStr

; 1526 :         if (comp->steps != NULL)

	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN3@xmlFreeStr

; 1527 : 	    xmlFree(comp->steps);

	mov	esi, esp
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlFreeStr:

; 1528 : 	if (comp->dict != NULL)

	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@xmlFreeStr

; 1529 : 	    xmlDictFree(comp->dict);

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlDictFree
	add	esp, 4
$LN4@xmlFreeStr:

; 1530 :         xmlFree(comp);

	mov	esi, esp
	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlFreeStr:

; 1531 :     }
; 1532 : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFreeStreamComp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamWantsAnyNode
_TEXT	SEGMENT
_streamCtxt$ = 8					; size = 4
_xmlStreamWantsAnyNode PROC				; COMDAT

; 2330 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 2331 :     if (streamCtxt == NULL)

	cmp	DWORD PTR _streamCtxt$[ebp], 0
	jne	SHORT $LN2@xmlStreamW

; 2332 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlStreamW
$LN2@xmlStreamW:

; 2333 :     while (streamCtxt != NULL) {

	cmp	DWORD PTR _streamCtxt$[ebp], 0
	je	SHORT $LN3@xmlStreamW

; 2334 : 	if (streamCtxt->comp->flags & XML_STREAM_FINAL_IS_ANY_NODE)

	mov	eax, DWORD PTR _streamCtxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, 16384				; 00004000H
	je	SHORT $LN5@xmlStreamW

; 2335 : 	    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlStreamW
$LN5@xmlStreamW:

; 2336 : 	streamCtxt = streamCtxt->next;

	mov	eax, DWORD PTR _streamCtxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _streamCtxt$[ebp], ecx

; 2337 :     }

	jmp	SHORT $LN2@xmlStreamW
$LN3@xmlStreamW:

; 2338 :     return(0);

	xor	eax, eax
$LN1@xmlStreamW:

; 2339 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlStreamWantsAnyNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamPop
_TEXT	SEGMENT
_lev$ = -8						; size = 4
_i$ = -4						; size = 4
_stream$ = 8						; size = 4
_xmlStreamPop PROC					; COMDAT

; 2281 : xmlStreamPop(xmlStreamCtxtPtr stream) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 2282 :     int i, lev;
; 2283 : 
; 2284 :     if (stream == NULL)

	cmp	DWORD PTR _stream$[ebp], 0
	jne	SHORT $LN2@xmlStreamP

; 2285 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlStreamP
$LN2@xmlStreamP:

; 2286 :     while (stream != NULL) {

	cmp	DWORD PTR _stream$[ebp], 0
	je	$LN3@xmlStreamP

; 2287 : 	/*
; 2288 : 	* Reset block-level.
; 2289 : 	*/
; 2290 : 	if (stream->blockLevel == stream->level)

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [eax+28]
	cmp	edx, DWORD PTR [ecx+16]
	jne	SHORT $LN8@xmlStreamP

; 2291 : 	    stream->blockLevel = -1;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+28], -1
$LN8@xmlStreamP:

; 2292 : 
; 2293 : 	/*
; 2294 : 	 *  stream->level can be zero when XML_FINAL_IS_ANY_NODE is set
; 2295 : 	 *  (see the thread at
; 2296 : 	 *  http://mail.gnome.org/archives/xslt/2008-July/msg00027.html)
; 2297 : 	 */
; 2298 : 	if (stream->level)

	mov	ecx, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN9@xmlStreamP

; 2299 : 	    stream->level--;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@xmlStreamP:

; 2300 : 	/*
; 2301 : 	 * Check evolution of existing states
; 2302 : 	 */
; 2303 : 	for (i = stream->nbState -1; i >= 0; i--) {

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN6@xmlStreamP
$LN4@xmlStreamP:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@xmlStreamP:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN5@xmlStreamP

; 2304 : 	    /* discard obsoleted states */
; 2305 : 	    lev = stream->states[(2 * i) + 1];

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+edx*4+4]
	mov	DWORD PTR _lev$[ebp], edx

; 2306 : 	    if (lev > stream->level)

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _lev$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jle	SHORT $LN10@xmlStreamP

; 2307 : 		stream->nbState--;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN10@xmlStreamP:

; 2308 : 	    if (lev <= stream->level)

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR _lev$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jg	SHORT $LN11@xmlStreamP

; 2309 : 		break;

	jmp	SHORT $LN5@xmlStreamP
$LN11@xmlStreamP:

; 2310 : 	}

	jmp	SHORT $LN4@xmlStreamP
$LN5@xmlStreamP:

; 2311 : 	stream = stream->next;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _stream$[ebp], edx

; 2312 :     }

	jmp	$LN2@xmlStreamP
$LN3@xmlStreamP:

; 2313 :     return(0);

	xor	eax, eax
$LN1@xmlStreamP:

; 2314 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStreamPop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamPushAttr
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_name$ = 12						; size = 4
_ns$ = 16						; size = 4
_xmlStreamPushAttr PROC					; COMDAT

; 2268 : 		  const xmlChar *name, const xmlChar *ns) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 2269 :     return (xmlStreamPushInternal(stream, name, ns, (int) XML_ATTRIBUTE_NODE));

	push	2
	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	_xmlStreamPushInternal
	add	esp, 16					; 00000010H

; 2270 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlStreamPushAttr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamPush
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_name$ = 12						; size = 4
_ns$ = 16						; size = 4
_xmlStreamPush PROC					; COMDAT

; 2218 :               const xmlChar *name, const xmlChar *ns) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 2219 :     return (xmlStreamPushInternal(stream, name, ns, (int) XML_ELEMENT_NODE));

	push	1
	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	_xmlStreamPushInternal
	add	esp, 16					; 00000010H

; 2220 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlStreamPush ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlStreamPushNode
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_name$ = 12						; size = 4
_ns$ = 16						; size = 4
_nodeType$ = 20						; size = 4
_xmlStreamPushNode PROC					; COMDAT

; 2245 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 2246 :     return (xmlStreamPushInternal(stream, name, ns,

	mov	eax, DWORD PTR _nodeType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ns$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	_xmlStreamPushInternal
	add	esp, 16					; 00000010H

; 2247 : 	nodeType));
; 2248 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlStreamPushNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlFreeStreamCtxt
_TEXT	SEGMENT
_next$ = -4						; size = 4
_stream$ = 8						; size = 4
_xmlFreeStreamCtxt PROC					; COMDAT

; 1792 : xmlFreeStreamCtxt(xmlStreamCtxtPtr stream) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlFreeStr:

; 1793 :     xmlStreamCtxtPtr next;
; 1794 : 
; 1795 :     while (stream != NULL) {

	cmp	DWORD PTR _stream$[ebp], 0
	je	SHORT $LN1@xmlFreeStr

; 1796 :         next = stream->next;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _next$[ebp], ecx

; 1797 :         if (stream->states != NULL)

	mov	edx, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN4@xmlFreeStr

; 1798 : 	    xmlFree(stream->states);

	mov	esi, esp
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlFreeStr:

; 1799 :         xmlFree(stream);

	mov	esi, esp
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1800 : 	stream = next;

	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _stream$[ebp], eax

; 1801 :     }

	jmp	SHORT $LN2@xmlFreeStr
$LN1@xmlFreeStr:

; 1802 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFreeStreamCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatternGetStreamCtxt
_TEXT	SEGMENT
_cur$ = -8						; size = 4
_ret$ = -4						; size = 4
_comp$ = 8						; size = 4
_xmlPatternGetStreamCtxt PROC				; COMDAT

; 2491 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 2492 :     xmlStreamCtxtPtr ret = NULL, cur;

	mov	DWORD PTR _ret$[ebp], 0

; 2493 : 
; 2494 :     if ((comp == NULL) || (comp->stream == NULL))

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN5@xmlPattern
	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN2@xmlPattern
$LN5@xmlPattern:

; 2495 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlPattern
$LN2@xmlPattern:

; 2496 : 
; 2497 :     while (comp != NULL) {

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN3@xmlPattern

; 2498 :         if (comp->stream == NULL)

	mov	ecx, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN6@xmlPattern

; 2499 : 	    goto failed;

	jmp	SHORT $failed$11
$LN6@xmlPattern:

; 2500 : 	cur = xmlNewStreamCtxt(comp->stream);

	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_xmlNewStreamCtxt
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 2501 : 	if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN7@xmlPattern

; 2502 : 	    goto failed;

	jmp	SHORT $failed$11
$LN7@xmlPattern:

; 2503 : 	if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN8@xmlPattern

; 2504 : 	    ret = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _ret$[ebp], ecx
	jmp	SHORT $LN9@xmlPattern
$LN8@xmlPattern:

; 2505 : 	else {
; 2506 : 	    cur->next = ret->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 2507 : 	    ret->next = cur;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx], eax
$LN9@xmlPattern:

; 2508 : 	}
; 2509 : 	cur->flags = comp->flags;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+24], eax

; 2510 : 	comp = comp->next;

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _comp$[ebp], edx

; 2511 :     }

	jmp	SHORT $LN2@xmlPattern
$LN3@xmlPattern:

; 2512 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlPattern
$failed$11:

; 2513 : failed:
; 2514 :     xmlFreeStreamCtxt(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlFreeStreamCtxt
	add	esp, 4

; 2515 :     return(NULL);

	xor	eax, eax
$LN1@xmlPattern:

; 2516 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlPatternGetStreamCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatternFromRoot
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_xmlPatternFromRoot PROC				; COMDAT

; 2602 : xmlPatternFromRoot(xmlPatternPtr comp) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 2603 :     if (comp == NULL)

	cmp	DWORD PTR _comp$[ebp], 0
	jne	SHORT $LN2@xmlPattern

; 2604 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlPattern
$LN2@xmlPattern:

; 2605 :     while (comp != NULL) {

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN3@xmlPattern

; 2606 :         if (comp->stream == NULL)

	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN5@xmlPattern

; 2607 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlPattern
$LN5@xmlPattern:

; 2608 : 	if (comp->flags & PAT_FROM_ROOT)

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, 256				; 00000100H
	je	SHORT $LN6@xmlPattern

; 2609 : 	    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlPattern
$LN6@xmlPattern:

; 2610 : 	comp = comp->next;

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _comp$[ebp], ecx

; 2611 :     }

	jmp	SHORT $LN2@xmlPattern
$LN3@xmlPattern:

; 2612 :     return(0);

	xor	eax, eax
$LN1@xmlPattern:

; 2613 : 
; 2614 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlPatternFromRoot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatternMinDepth
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_comp$ = 8						; size = 4
_xmlPatternMinDepth PROC				; COMDAT

; 2577 : xmlPatternMinDepth(xmlPatternPtr comp) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 2578 :     int ret = 12345678;

	mov	DWORD PTR _ret$[ebp], 12345678		; 00bc614eH

; 2579 :     if (comp == NULL)

	cmp	DWORD PTR _comp$[ebp], 0
	jne	SHORT $LN2@xmlPattern

; 2580 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlPattern
$LN2@xmlPattern:

; 2581 :     while (comp != NULL) {

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN3@xmlPattern

; 2582 :         if (comp->stream == NULL)

	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN5@xmlPattern

; 2583 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlPattern
$LN5@xmlPattern:

; 2584 : 	if (comp->stream->nbStep < ret)

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _ret$[ebp]
	jge	SHORT $LN6@xmlPattern

; 2585 : 	    ret = comp->stream->nbStep;

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _ret$[ebp], eax
$LN6@xmlPattern:

; 2586 : 	if (ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN7@xmlPattern

; 2587 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlPattern
$LN7@xmlPattern:

; 2588 : 	comp = comp->next;

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _comp$[ebp], edx

; 2589 :     }

	jmp	SHORT $LN2@xmlPattern
$LN3@xmlPattern:

; 2590 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlPattern:

; 2591 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlPatternMinDepth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatternMaxDepth
_TEXT	SEGMENT
_i$ = -8						; size = 4
_ret$ = -4						; size = 4
_comp$ = 8						; size = 4
_xmlPatternMaxDepth PROC				; COMDAT

; 2549 : xmlPatternMaxDepth(xmlPatternPtr comp) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 2550 :     int ret = 0, i;

	mov	DWORD PTR _ret$[ebp], 0

; 2551 :     if (comp == NULL)

	cmp	DWORD PTR _comp$[ebp], 0
	jne	SHORT $LN2@xmlPattern

; 2552 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlPattern
$LN2@xmlPattern:

; 2553 :     while (comp != NULL) {

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN3@xmlPattern

; 2554 :         if (comp->stream == NULL)

	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN8@xmlPattern

; 2555 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlPattern
$LN8@xmlPattern:

; 2556 : 	for (i = 0;i < comp->stream->nbStep;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@xmlPattern
$LN4@xmlPattern:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@xmlPattern:
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN5@xmlPattern

; 2557 : 	    if (comp->stream->steps[i].flags & XML_STREAM_STEP_DESC)

	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [edx+ecx]
	and	eax, 1
	je	SHORT $LN9@xmlPattern

; 2558 : 	        return(-2);

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN1@xmlPattern
$LN9@xmlPattern:
	jmp	SHORT $LN4@xmlPattern
$LN5@xmlPattern:

; 2559 : 	if (comp->stream->nbStep > ret)

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _ret$[ebp]
	jle	SHORT $LN10@xmlPattern

; 2560 : 	    ret = comp->stream->nbStep;

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _ret$[ebp], eax
$LN10@xmlPattern:

; 2561 : 	comp = comp->next;

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _comp$[ebp], edx

; 2562 :     }

	jmp	SHORT $LN2@xmlPattern
$LN3@xmlPattern:

; 2563 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlPattern:

; 2564 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlPatternMaxDepth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatternStreamable
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_xmlPatternStreamable PROC				; COMDAT

; 2528 : xmlPatternStreamable(xmlPatternPtr comp) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 2529 :     if (comp == NULL)

	cmp	DWORD PTR _comp$[ebp], 0
	jne	SHORT $LN2@xmlPattern

; 2530 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlPattern
$LN2@xmlPattern:

; 2531 :     while (comp != NULL) {

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN3@xmlPattern

; 2532 :         if (comp->stream == NULL)

	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN5@xmlPattern

; 2533 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlPattern
$LN5@xmlPattern:

; 2534 : 	comp = comp->next;

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _comp$[ebp], edx

; 2535 :     }

	jmp	SHORT $LN2@xmlPattern
$LN3@xmlPattern:

; 2536 :     return(1);

	mov	eax, 1
$LN1@xmlPattern:

; 2537 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlPatternStreamable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatternMatch
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_comp$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlPatternMatch PROC					; COMDAT

; 2465 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 2466 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 2467 : 
; 2468 :     if ((comp == NULL) || (node == NULL))

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN5@xmlPattern
	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN2@xmlPattern
$LN5@xmlPattern:

; 2469 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlPattern
$LN2@xmlPattern:

; 2470 : 
; 2471 :     while (comp != NULL) {

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN3@xmlPattern

; 2472 :         ret = xmlPatMatch(comp, node);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	call	_xmlPatMatch
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2473 : 	if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN6@xmlPattern

; 2474 : 	    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlPattern
$LN6@xmlPattern:

; 2475 : 	comp = comp->next;

	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _comp$[ebp], eax

; 2476 :     }

	jmp	SHORT $LN2@xmlPattern
$LN3@xmlPattern:

; 2477 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlPattern:

; 2478 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlPatternMatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlPatterncompile
_TEXT	SEGMENT
_streamable$ = -32					; size = 4
_type$ = -28						; size = 4
_tmp$ = -24						; size = 4
_start$ = -20						; size = 4
_or$ = -16						; size = 4
_ctxt$ = -12						; size = 4
_cur$ = -8						; size = 4
_ret$ = -4						; size = 4
_pattern$ = 8						; size = 4
_dict$ = 12						; size = 4
_flags$ = 16						; size = 4
_namespaces$ = 20					; size = 4
_xmlPatterncompile PROC					; COMDAT

; 2360 :                   const xmlChar **namespaces) {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 2361 :     xmlPatternPtr ret = NULL, cur;

	mov	DWORD PTR _ret$[ebp], 0

; 2362 :     xmlPatParserContextPtr ctxt = NULL;

	mov	DWORD PTR _ctxt$[ebp], 0

; 2363 :     const xmlChar *or, *start;
; 2364 :     xmlChar *tmp = NULL;

	mov	DWORD PTR _tmp$[ebp], 0

; 2365 :     int type = 0;

	mov	DWORD PTR _type$[ebp], 0

; 2366 :     int streamable = 1;

	mov	DWORD PTR _streamable$[ebp], 1

; 2367 : 
; 2368 :     if (pattern == NULL)

	cmp	DWORD PTR _pattern$[ebp], 0
	jne	SHORT $LN8@xmlPattern

; 2369 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlPattern
$LN8@xmlPattern:

; 2370 : 
; 2371 :     start = pattern;

	mov	eax, DWORD PTR _pattern$[ebp]
	mov	DWORD PTR _start$[ebp], eax

; 2372 :     or = start;

	mov	ecx, DWORD PTR _start$[ebp]
	mov	DWORD PTR _or$[ebp], ecx
$LN2@xmlPattern:

; 2373 :     while (*or != 0) {

	mov	edx, DWORD PTR _or$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN3@xmlPattern

; 2374 : 	tmp = NULL;

	mov	DWORD PTR _tmp$[ebp], 0
$LN4@xmlPattern:

; 2375 : 	while ((*or != 0) && (*or != '|')) or++;

	mov	ecx, DWORD PTR _or$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN5@xmlPattern
	mov	eax, DWORD PTR _or$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 124				; 0000007cH
	je	SHORT $LN5@xmlPattern
	mov	edx, DWORD PTR _or$[ebp]
	add	edx, 1
	mov	DWORD PTR _or$[ebp], edx
	jmp	SHORT $LN4@xmlPattern
$LN5@xmlPattern:

; 2376 :         if (*or == 0)

	mov	eax, DWORD PTR _or$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN9@xmlPattern

; 2377 : 	    ctxt = xmlNewPatParserContext(start, dict, namespaces);

	mov	edx, DWORD PTR _namespaces$[ebp]
	push	edx
	mov	eax, DWORD PTR _dict$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	call	_xmlNewPatParserContext
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ctxt$[ebp], eax
	jmp	SHORT $LN10@xmlPattern
$LN9@xmlPattern:

; 2378 : 	else {
; 2379 : 	    tmp = xmlStrndup(start, or - start);

	mov	edx, DWORD PTR _or$[ebp]
	sub	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR _tmp$[ebp], eax

; 2380 : 	    if (tmp != NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN11@xmlPattern

; 2381 : 		ctxt = xmlNewPatParserContext(tmp, dict, namespaces);

	mov	ecx, DWORD PTR _namespaces$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dict$[ebp]
	push	edx
	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_xmlNewPatParserContext
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ctxt$[ebp], eax
$LN11@xmlPattern:

; 2382 : 	    }
; 2383 : 	    or++;

	mov	ecx, DWORD PTR _or$[ebp]
	add	ecx, 1
	mov	DWORD PTR _or$[ebp], ecx
$LN10@xmlPattern:

; 2384 : 	}
; 2385 : 	if (ctxt == NULL) goto error;

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN12@xmlPattern
	jmp	$error$37
$LN12@xmlPattern:

; 2386 : 	cur = xmlNewPattern();

	call	_xmlNewPattern
	mov	DWORD PTR _cur$[ebp], eax

; 2387 : 	if (cur == NULL) goto error;

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN13@xmlPattern
	jmp	$error$37
$LN13@xmlPattern:

; 2388 : 	/*
; 2389 : 	* Assign string dict.
; 2390 : 	*/
; 2391 : 	if (dict) {

	cmp	DWORD PTR _dict$[ebp], 0
	je	SHORT $LN14@xmlPattern

; 2392 : 	    cur->dict = dict;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [edx+4], eax

; 2393 : 	    xmlDictReference(dict);

	mov	ecx, DWORD PTR _dict$[ebp]
	push	ecx
	call	_xmlDictReference
	add	esp, 4
$LN14@xmlPattern:

; 2394 : 	}
; 2395 : 	if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN15@xmlPattern

; 2396 : 	    ret = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _ret$[ebp], edx
	jmp	SHORT $LN16@xmlPattern
$LN15@xmlPattern:

; 2397 : 	else {
; 2398 : 	    cur->next = ret->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 2399 : 	    ret->next = cur;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN16@xmlPattern:

; 2400 : 	}
; 2401 : 	cur->flags = flags;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [edx+16], eax

; 2402 : 	ctxt->comp = cur;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 2403 : 
; 2404 : 	if (XML_STREAM_XS_IDC(cur))

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 6
	je	SHORT $LN17@xmlPattern

; 2405 : 	    xmlCompileIDCXPathPath(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCompileIDCXPathPath
	add	esp, 4
	jmp	SHORT $LN18@xmlPattern
$LN17@xmlPattern:

; 2406 : 	else
; 2407 : 	    xmlCompilePathPattern(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCompilePathPattern
	add	esp, 4
$LN18@xmlPattern:

; 2408 : 	if (ctxt->error != 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN19@xmlPattern

; 2409 : 	    goto error;

	jmp	$error$37
$LN19@xmlPattern:

; 2410 : 	xmlFreePatParserContext(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreePatParserContext
	add	esp, 4

; 2411 : 	ctxt = NULL;

	mov	DWORD PTR _ctxt$[ebp], 0

; 2412 : 
; 2413 : 
; 2414 :         if (streamable) {

	cmp	DWORD PTR _streamable$[ebp], 0
	je	SHORT $LN20@xmlPattern

; 2415 : 	    if (type == 0) {

	cmp	DWORD PTR _type$[ebp], 0
	jne	SHORT $LN21@xmlPattern

; 2416 : 	        type = cur->flags & (PAT_FROM_ROOT | PAT_FROM_CUR);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 768				; 00000300H
	mov	DWORD PTR _type$[ebp], ecx
	jmp	SHORT $LN20@xmlPattern
$LN21@xmlPattern:

; 2417 : 	    } else if (type == PAT_FROM_ROOT) {

	cmp	DWORD PTR _type$[ebp], 256		; 00000100H
	jne	SHORT $LN23@xmlPattern

; 2418 : 	        if (cur->flags & PAT_FROM_CUR)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+16]
	and	eax, 512				; 00000200H
	je	SHORT $LN25@xmlPattern

; 2419 : 		    streamable = 0;

	mov	DWORD PTR _streamable$[ebp], 0
$LN25@xmlPattern:

; 2420 : 	    } else if (type == PAT_FROM_CUR) {

	jmp	SHORT $LN20@xmlPattern
$LN23@xmlPattern:
	cmp	DWORD PTR _type$[ebp], 512		; 00000200H
	jne	SHORT $LN20@xmlPattern

; 2421 : 	        if (cur->flags & PAT_FROM_ROOT)

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, 256				; 00000100H
	je	SHORT $LN20@xmlPattern

; 2422 : 		    streamable = 0;

	mov	DWORD PTR _streamable$[ebp], 0
$LN20@xmlPattern:

; 2423 : 	    }
; 2424 : 	}
; 2425 : 	if (streamable)

	cmp	DWORD PTR _streamable$[ebp], 0
	je	SHORT $LN28@xmlPattern

; 2426 : 	    xmlStreamCompile(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlStreamCompile
	add	esp, 4
$LN28@xmlPattern:

; 2427 : 	if (xmlReversePattern(cur) < 0)

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlReversePattern
	add	esp, 4
	test	eax, eax
	jge	SHORT $LN29@xmlPattern

; 2428 : 	    goto error;

	jmp	SHORT $error$37
$LN29@xmlPattern:

; 2429 : 	if (tmp != NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN30@xmlPattern

; 2430 : 	    xmlFree(tmp);

	mov	esi, esp
	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2431 : 	    tmp = NULL;

	mov	DWORD PTR _tmp$[ebp], 0
$LN30@xmlPattern:

; 2432 : 	}
; 2433 : 	start = or;

	mov	eax, DWORD PTR _or$[ebp]
	mov	DWORD PTR _start$[ebp], eax

; 2434 :     }

	jmp	$LN2@xmlPattern
$LN3@xmlPattern:

; 2435 :     if (streamable == 0) {

	cmp	DWORD PTR _streamable$[ebp], 0
	jne	SHORT $LN31@xmlPattern

; 2436 :         cur = ret;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx
$LN6@xmlPattern:

; 2437 : 	while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN31@xmlPattern

; 2438 : 	    if (cur->stream != NULL) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN32@xmlPattern

; 2439 : 		xmlFreeStreamComp(cur->stream);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_xmlFreeStreamComp
	add	esp, 4

; 2440 : 		cur->stream = NULL;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+32], 0
$LN32@xmlPattern:

; 2441 : 	    }
; 2442 : 	    cur = cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _cur$[ebp], ecx

; 2443 : 	}

	jmp	SHORT $LN6@xmlPattern
$LN31@xmlPattern:

; 2444 :     }
; 2445 : 
; 2446 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlPattern
$error$37:

; 2447 : error:
; 2448 :     if (ctxt != NULL) xmlFreePatParserContext(ctxt);

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN33@xmlPattern
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreePatParserContext
	add	esp, 4
$LN33@xmlPattern:

; 2449 :     if (ret != NULL) xmlFreePattern(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN34@xmlPattern
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlFreePattern
	add	esp, 4
$LN34@xmlPattern:

; 2450 :     if (tmp != NULL) xmlFree(tmp);

	cmp	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN35@xmlPattern
	mov	esi, esp
	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN35@xmlPattern:

; 2451 :     return(NULL);

	xor	eax, eax
$LN1@xmlPattern:

; 2452 : }

	pop	esi
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlPatterncompile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlFreePatternList
_TEXT	SEGMENT
_cur$ = -4						; size = 4
_comp$ = 8						; size = 4
_xmlFreePatternList PROC				; COMDAT

; 269  : xmlFreePatternList(xmlPatternPtr comp) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlFreePat:

; 270  :     xmlPatternPtr cur;
; 271  : 
; 272  :     while (comp != NULL) {

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN1@xmlFreePat

; 273  : 	cur = comp;

	mov	eax, DWORD PTR _comp$[ebp]
	mov	DWORD PTR _cur$[ebp], eax

; 274  : 	comp = comp->next;

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _comp$[ebp], edx

; 275  : 	cur->next = NULL;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+8], 0

; 276  : 	xmlFreePattern(cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlFreePattern
	add	esp, 4

; 277  :     }

	jmp	SHORT $LN2@xmlFreePat
$LN1@xmlFreePat:

; 278  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFreePatternList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\pattern.c
;	COMDAT _xmlFreePattern
_TEXT	SEGMENT
_i$ = -8						; size = 4
_op$ = -4						; size = 4
_comp$ = 8						; size = 4
_xmlFreePattern PROC					; COMDAT

; 231  : xmlFreePattern(xmlPatternPtr comp) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __69230394_pattern@c
	call	@__CheckForDebuggerJustMyCode@4

; 232  :     xmlStepOpPtr op;
; 233  :     int i;
; 234  : 
; 235  :     if (comp == NULL)

	cmp	DWORD PTR _comp$[ebp], 0
	jne	SHORT $LN5@xmlFreePat

; 236  : 	return;

	jmp	$LN1@xmlFreePat
$LN5@xmlFreePat:

; 237  :     if (comp->next != NULL)

	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN6@xmlFreePat

; 238  :         xmlFreePattern(comp->next);

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlFreePattern
	add	esp, 4
$LN6@xmlFreePat:

; 239  :     if (comp->stream != NULL)

	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN7@xmlFreePat

; 240  :         xmlFreeStreamComp(comp->stream);

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_xmlFreeStreamComp
	add	esp, 4
$LN7@xmlFreePat:

; 241  :     if (comp->pattern != NULL)

	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN8@xmlFreePat

; 242  : 	xmlFree((xmlChar *)comp->pattern);

	mov	esi, esp
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@xmlFreePat:

; 243  :     if (comp->steps != NULL) {

	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	$LN9@xmlFreePat

; 244  :         if (comp->dict == NULL) {

	mov	ecx, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN10@xmlFreePat

; 245  : 	    for (i = 0;i < comp->nbStep;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlFreePat
$LN2@xmlFreePat:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@xmlFreePat:
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jge	SHORT $LN10@xmlFreePat

; 246  : 		op = &comp->steps[i];

	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, DWORD PTR _comp$[ebp]
	add	edx, DWORD PTR [eax+28]
	mov	DWORD PTR _op$[ebp], edx

; 247  : 		if (op->value != NULL)

	mov	ecx, DWORD PTR _op$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN11@xmlFreePat

; 248  : 		    xmlFree((xmlChar *) op->value);

	mov	esi, esp
	mov	edx, DWORD PTR _op$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlFreePat:

; 249  : 		if (op->value2 != NULL)

	mov	ecx, DWORD PTR _op$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN12@xmlFreePat

; 250  : 		    xmlFree((xmlChar *) op->value2);

	mov	esi, esp
	mov	edx, DWORD PTR _op$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlFreePat:

; 251  : 	    }

	jmp	SHORT $LN2@xmlFreePat
$LN10@xmlFreePat:

; 252  : 	}
; 253  : 	xmlFree(comp->steps);

	mov	esi, esp
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@xmlFreePat:

; 254  :     }
; 255  :     if (comp->dict != NULL)

	mov	eax, DWORD PTR _comp$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN13@xmlFreePat

; 256  :         xmlDictFree(comp->dict);

	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlDictFree
	add	esp, 4
$LN13@xmlFreePat:

; 257  : 
; 258  :     memset(comp, -1, sizeof(xmlPattern));

	or	eax, -1
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], eax
	mov	DWORD PTR [ecx+32], eax

; 259  :     xmlFree(comp);

	mov	esi, esp
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlFreePat:

; 260  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFreePattern ENDP
_TEXT	ENDS
END
