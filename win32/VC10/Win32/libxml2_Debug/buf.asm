; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\buf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__7B7A869E_ctype@h DB 01H
__4FDA1B3E_buf@c DB 01H
msvcjmc	ENDS
PUBLIC	_xmlBufContent
PUBLIC	_xmlBufEnd
PUBLIC	_xmlBufUse
PUBLIC	_xmlBufShrink
PUBLIC	_xmlBufCreate
PUBLIC	_xmlBufCreateSize
PUBLIC	_xmlBufCreateStatic
PUBLIC	_xmlBufSetAllocationScheme
PUBLIC	_xmlBufGetAllocationScheme
PUBLIC	_xmlBufFree
PUBLIC	_xmlBufEmpty
PUBLIC	_xmlBufGrow
PUBLIC	_xmlBufInflate
PUBLIC	_xmlBufResize
PUBLIC	_xmlBufAdd
PUBLIC	_xmlBufAddHead
PUBLIC	_xmlBufCat
PUBLIC	_xmlBufCCat
PUBLIC	_xmlBufWriteCHAR
PUBLIC	_xmlBufWriteChar
PUBLIC	_xmlBufWriteQuotedString
PUBLIC	_xmlBufAvail
PUBLIC	_xmlBufLength
PUBLIC	_xmlBufIsEmpty
PUBLIC	_xmlBufAddLen
PUBLIC	_xmlBufErase
PUBLIC	_xmlBufDetach
PUBLIC	_xmlBufDump
PUBLIC	_xmlBufFromBuffer
PUBLIC	_xmlBufBackToBuffer
PUBLIC	_xmlBufMergeBuffer
PUBLIC	_xmlBufResetInput
PUBLIC	_xmlBufGetInputBase
PUBLIC	_xmlBufSetInputBaseCur
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BA@GIGPFFIA@creating?5buffer@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BN@GFPONKGI@buffer?5error?3?5text?5too?5long?6@ ; `string'
PUBLIC	??_C@_0P@LKGMENGP@growing?5buffer@		; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC@				; `string'
PUBLIC	??_C@_06DDLNFFBN@?$CGquot?$DL@			; `string'
PUBLIC	??_C@_01GEODFPGF@?8@				; `string'
PUBLIC	??_C@_0CA@IHEGKOED@Used?5size?5too?5big?5for?5xmlBuffer@ ; `string'
PUBLIC	??_C@_0CF@HDAKMICL@Allocated?5size?5too?5big?5for?5xmlB@ ; `string'
PUBLIC	??_C@_0CG@MJEMBJAO@Input?5reference?5outside?5of?5the?5@ ; `string'
EXTRN	_xmlStrchr:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	_xmlBufferFree:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	___xmlBufferAllocScheme:PROC
EXTRN	___xmlDefaultBufferSize:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CG@MJEMBJAO@Input?5reference?5outside?5of?5the?5@
CONST	SEGMENT
??_C@_0CG@MJEMBJAO@Input?5reference?5outside?5of?5the?5@ DB 'Input refere'
	DB	'nce outside of the buffer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HDAKMICL@Allocated?5size?5too?5big?5for?5xmlB@
CONST	SEGMENT
??_C@_0CF@HDAKMICL@Allocated?5size?5too?5big?5for?5xmlB@ DB 'Allocated si'
	DB	'ze too big for xmlBuffer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IHEGKOED@Used?5size?5too?5big?5for?5xmlBuffer@
CONST	SEGMENT
??_C@_0CA@IHEGKOED@Used?5size?5too?5big?5for?5xmlBuffer@ DB 'Used size to'
	DB	'o big for xmlBuffer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8@
CONST	SEGMENT
??_C@_01GEODFPGF@?8@ DB '''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DDLNFFBN@?$CGquot?$DL@
CONST	SEGMENT
??_C@_06DDLNFFBN@?$CGquot?$DL@ DB '&quot;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LKGMENGP@growing?5buffer@
CONST	SEGMENT
??_C@_0P@LKGMENGP@growing?5buffer@ DB 'growing buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GFPONKGI@buffer?5error?3?5text?5too?5long?6@
CONST	SEGMENT
??_C@_0BN@GFPONKGI@buffer?5error?3?5text?5too?5long?6@ DB 'buffer error: '
	DB	'text too long', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GIGPFFIA@creating?5buffer@
CONST	SEGMENT
??_C@_0BA@GIGPFFIA@creating?5buffer@ DB 'creating buffer', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufGrowInternal
_TEXT	SEGMENT
_start_buf$1 = -12					; size = 4
_newbuf$ = -8						; size = 4
_size$ = -4						; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlBufGrowInternal PROC				; COMDAT

; 437  : xmlBufGrowInternal(xmlBufPtr buf, size_t len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 438  :     size_t size;
; 439  :     xmlChar *newbuf;
; 440  : 
; 441  :     if ((buf == NULL) || (buf->error != 0)) return(0);

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufGrow
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufGrow
$LN3@xmlBufGrow:
	xor	eax, eax
	jmp	$LN1@xmlBufGrow
$LN2@xmlBufGrow:

; 442  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufGrow
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufGrow
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufGrow:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufGrow
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufGrow
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufGrow:

; 443  : 
; 444  :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return(0);

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+12], 2
	jne	SHORT $LN8@xmlBufGrow
	xor	eax, eax
	jmp	$LN1@xmlBufGrow
$LN8@xmlBufGrow:

; 445  :     if (buf->use + len < buf->size)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	edx, DWORD PTR [eax+24]
	jae	SHORT $LN9@xmlBufGrow

; 446  :         return(buf->size - buf->use);

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	sub	eax, DWORD PTR [edx+20]
	jmp	$LN1@xmlBufGrow
$LN9@xmlBufGrow:

; 447  : 
; 448  :     /*
; 449  :      * Windows has a BIG problem on realloc timing, so we try to double
; 450  :      * the buffer size (if that's enough) (bug 146697)
; 451  :      * Apparently BSD too, and it's probably best for linux too
; 452  :      * On an embedded system this may be something to change
; 453  :      */
; 454  : #if 1
; 455  :     if (buf->size > (size_t) len)

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR _len$[ebp]
	jbe	SHORT $LN10@xmlBufGrow

; 456  :         size = buf->size * 2;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shl	eax, 1
	mov	DWORD PTR _size$[ebp], eax
	jmp	SHORT $LN11@xmlBufGrow
$LN10@xmlBufGrow:

; 457  :     else
; 458  :         size = buf->use + len + 100;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _len$[ebp]
	lea	ecx, DWORD PTR [edx+eax+100]
	mov	DWORD PTR _size$[ebp], ecx
$LN11@xmlBufGrow:

; 459  : #else
; 460  :     size = buf->use + len + 100;
; 461  : #endif
; 462  : 
; 463  :     if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {

	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+12], 5
	jne	SHORT $LN12@xmlBufGrow

; 464  :         /*
; 465  : 	 * Used to provide parsing limits
; 466  : 	 */
; 467  :         if ((buf->use + len >= XML_MAX_TEXT_LENGTH) ||

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, 10000000				; 00989680H
	jae	SHORT $LN14@xmlBufGrow
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+24], 10000000		; 00989680H
	jb	SHORT $LN13@xmlBufGrow
$LN14@xmlBufGrow:

; 468  : 	    (buf->size >= XML_MAX_TEXT_LENGTH)) {
; 469  : 	    xmlBufMemoryError(buf, "buffer error: text too long\n");

	push	OFFSET ??_C@_0BN@GFPONKGI@buffer?5error?3?5text?5too?5long?6@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufMemoryError
	add	esp, 8

; 470  : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlBufGrow
$LN13@xmlBufGrow:

; 471  : 	}
; 472  : 	if (size >= XML_MAX_TEXT_LENGTH)

	cmp	DWORD PTR _size$[ebp], 10000000		; 00989680H
	jb	SHORT $LN12@xmlBufGrow

; 473  : 	    size = XML_MAX_TEXT_LENGTH;

	mov	DWORD PTR _size$[ebp], 10000000		; 00989680H
$LN12@xmlBufGrow:

; 474  :     }
; 475  :     if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {

	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+12], 3
	jne	SHORT $LN16@xmlBufGrow
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN16@xmlBufGrow

; 476  :         size_t start_buf = buf->content - buf->contentIO;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _start_buf$1[ebp], edx

; 477  : 
; 478  : 	newbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);

	mov	eax, DWORD PTR _start_buf$1[ebp]
	add	eax, DWORD PTR _size$[ebp]
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _newbuf$[ebp], eax

; 479  : 	if (newbuf == NULL) {

	cmp	DWORD PTR _newbuf$[ebp], 0
	jne	SHORT $LN18@xmlBufGrow

; 480  : 	    xmlBufMemoryError(buf, "growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufMemoryError
	add	esp, 8

; 481  : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlBufGrow
$LN18@xmlBufGrow:

; 482  : 	}
; 483  : 	buf->contentIO = newbuf;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _newbuf$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 484  : 	buf->content = newbuf + start_buf;

	mov	eax, DWORD PTR _newbuf$[ebp]
	add	eax, DWORD PTR _start_buf$1[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx], eax

; 485  :     } else {

	jmp	SHORT $LN17@xmlBufGrow
$LN16@xmlBufGrow:

; 486  : 	newbuf = (xmlChar *) xmlRealloc(buf->content, size);

	mov	esi, esp
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _newbuf$[ebp], eax

; 487  : 	if (newbuf == NULL) {

	cmp	DWORD PTR _newbuf$[ebp], 0
	jne	SHORT $LN19@xmlBufGrow

; 488  : 	    xmlBufMemoryError(buf, "growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufMemoryError
	add	esp, 8

; 489  : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlBufGrow
$LN19@xmlBufGrow:

; 490  : 	}
; 491  : 	buf->content = newbuf;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _newbuf$[ebp]
	mov	DWORD PTR [eax], ecx
$LN17@xmlBufGrow:

; 492  :     }
; 493  :     buf->size = size;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx+24], eax

; 494  :     UPDATE_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+24], 2147483647		; 7fffffffH
	jae	SHORT $LN20@xmlBufGrow
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN21@xmlBufGrow
$LN20@xmlBufGrow:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+8], 2147483647		; 7fffffffH
$LN21@xmlBufGrow:
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+20], 2147483647		; 7fffffffH
	jae	SHORT $LN22@xmlBufGrow
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN23@xmlBufGrow
$LN22@xmlBufGrow:
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+4], 2147483647		; 7fffffffH
$LN23@xmlBufGrow:

; 495  :     return(buf->size - buf->use);

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	sub	ecx, DWORD PTR [eax+20]
	mov	eax, ecx
$LN1@xmlBufGrow:

; 496  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufGrowInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufOverflowError
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlBufOverflowError PROC				; COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 109  :     __xmlSimpleError(XML_FROM_BUFFER, XML_BUF_OVERFLOW, NULL, NULL, extra);

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	0
	push	0
	push	7000					; 00001b58H
	push	29					; 0000001dH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 110  :     if ((buf) && (buf->error == 0))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN1@xmlBufOver
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN1@xmlBufOver

; 111  :         buf->error = XML_BUF_OVERFLOW;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+32], 7000		; 00001b58H
$LN1@xmlBufOver:

; 112  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufOverflowError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufMemoryError
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlBufMemoryError PROC					; COMDAT

; 93   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 94   :     __xmlSimpleError(XML_FROM_BUFFER, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	0
	push	0
	push	2
	push	29					; 0000001dH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 95   :     if ((buf) && (buf->error == 0))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN1@xmlBufMemo
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN1@xmlBufMemo

; 96   :         buf->error = XML_ERR_NO_MEMORY;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+32], 2
$LN1@xmlBufMemo:

; 97   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufMemoryError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufSetInputBaseCur
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_input$ = 12						; size = 4
_base$ = 16						; size = 4
_cur$ = 20						; size = 4
_xmlBufSetInputBaseCur PROC				; COMDAT

; 1334 :                       size_t base, size_t cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 1335 :     if ((input == NULL) || (buf == NULL) || (buf->error))

	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN3@xmlBufSetI
	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufSetI
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufSetI
$LN3@xmlBufSetI:

; 1336 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlBufSetI
$LN2@xmlBufSetI:

; 1337 :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufSetI
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufSetI
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufSetI:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufSetI
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufSetI
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufSetI:

; 1338 :     input->base = &buf->content[base];

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _base$[ebp]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 1339 :     input->cur = input->base + cur;

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1340 :     input->end = &buf->content[buf->use];

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR [edx+20]
	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 1341 :     return(0);

	xor	eax, eax
$LN1@xmlBufSetI:

; 1342 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufSetInputBaseCur ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufGetInputBase
_TEXT	SEGMENT
_base$ = -4						; size = 4
_buf$ = 8						; size = 4
_input$ = 12						; size = 4
_xmlBufGetInputBase PROC				; COMDAT

; 1302 : xmlBufGetInputBase(xmlBufPtr buf, xmlParserInputPtr input) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 1303 :     size_t base;
; 1304 : 
; 1305 :     if ((input == NULL) || (buf == NULL) || (buf->error))

	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN3@xmlBufGetI
	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufGetI
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufGetI
$LN3@xmlBufGetI:

; 1306 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlBufGetI
$LN2@xmlBufGetI:

; 1307 :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufGetI
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufGetI
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufGetI:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufGetI
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufGetI
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufGetI:

; 1308 :     base = input->base - buf->content;

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR _base$[ebp], edx

; 1309 :     /*
; 1310 :      * We could do some pointer arythmetic checks but that's probably
; 1311 :      * sufficient.
; 1312 :      */
; 1313 :     if (base > buf->size) {

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _base$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jbe	SHORT $LN8@xmlBufGetI

; 1314 :         xmlBufOverflowError(buf, "Input reference outside of the buffer");

	push	OFFSET ??_C@_0CG@MJEMBJAO@Input?5reference?5outside?5of?5the?5@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufOverflowError
	add	esp, 8

; 1315 :         base = 0;

	mov	DWORD PTR _base$[ebp], 0
$LN8@xmlBufGetI:

; 1316 :     }
; 1317 :     return(base);

	mov	eax, DWORD PTR _base$[ebp]
$LN1@xmlBufGetI:

; 1318 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufGetInputBase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufResetInput
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_input$ = 12						; size = 4
_xmlBufResetInput PROC					; COMDAT

; 1283 : xmlBufResetInput(xmlBufPtr buf, xmlParserInputPtr input) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 1284 :     if ((input == NULL) || (buf == NULL) || (buf->error))

	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN3@xmlBufRese
	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufRese
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufRese
$LN3@xmlBufRese:

; 1285 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlBufRese
$LN2@xmlBufRese:

; 1286 :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufRese
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufRese
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufRese:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufRese
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufRese
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufRese:

; 1287 :     input->base = input->cur = buf->content;

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+12], edx

; 1288 :     input->end = &buf->content[buf->use];

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR [edx+20]
	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 1289 :     return(0);

	xor	eax, eax
$LN1@xmlBufRese:

; 1290 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufResetInput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufMergeBuffer
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_buf$ = 8						; size = 4
_buffer$ = 12						; size = 4
_xmlBufMergeBuffer PROC					; COMDAT

; 1257 : xmlBufMergeBuffer(xmlBufPtr buf, xmlBufferPtr buffer) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 1258 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1259 : 
; 1260 :     if ((buf == NULL) || (buf->error)) {

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufMerg
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufMerg
$LN3@xmlBufMerg:

; 1261 : 	xmlBufferFree(buffer);

	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_xmlBufferFree
	add	esp, 4

; 1262 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlBufMerg
$LN2@xmlBufMerg:

; 1263 :     }
; 1264 :     CHECK_COMPAT(buf)

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN4@xmlBufMerg
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufMerg
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+24], edx
$LN4@xmlBufMerg:
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN6@xmlBufMerg
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufMerg
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+20], eax
$LN6@xmlBufMerg:

; 1265 :     if ((buffer != NULL) && (buffer->content != NULL) &&

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN8@xmlBufMerg
	mov	ecx, DWORD PTR _buffer$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN8@xmlBufMerg
	mov	edx, DWORD PTR _buffer$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jbe	SHORT $LN8@xmlBufMerg

; 1266 :              (buffer->use > 0)) {
; 1267 :         ret = xmlBufAdd(buf, buffer->content, buffer->use);

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax
$LN8@xmlBufMerg:

; 1268 :     }
; 1269 :     xmlBufferFree(buffer);

	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_xmlBufferFree
	add	esp, 4

; 1270 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlBufMerg:

; 1271 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufMergeBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufBackToBuffer
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_buf$ = 8						; size = 4
_xmlBufBackToBuffer PROC				; COMDAT

; 1204 : xmlBufBackToBuffer(xmlBufPtr buf) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 1205 :     xmlBufferPtr ret;
; 1206 : 
; 1207 :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufBack
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufBack
$LN3@xmlBufBack:

; 1208 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlBufBack
$LN2@xmlBufBack:

; 1209 :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufBack
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufBack
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufBack:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufBack
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufBack
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufBack:

; 1210 :     if (buf->buffer == NULL) {

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN8@xmlBufBack

; 1211 :         xmlBufFree(buf);

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufFree
	add	esp, 4

; 1212 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlBufBack
$LN8@xmlBufBack:

; 1213 :     }
; 1214 : 
; 1215 :     ret = buf->buffer;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _ret$[ebp], eax

; 1216 :     /*
; 1217 :      * What to do in case of error in the buffer ???
; 1218 :      */
; 1219 :     if (buf->use > INT_MAX) {

	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+20], 2147483647		; 7fffffffH
	jbe	SHORT $LN9@xmlBufBack

; 1220 :         /*
; 1221 :          * Worse case, we really allocated and used more than the
; 1222 :          * maximum allowed memory for an xmlBuffer on this architecture.
; 1223 :          * Keep the buffer but provide a truncated size value.
; 1224 :          */
; 1225 :         xmlBufOverflowError(buf, "Used size too big for xmlBuffer");

	push	OFFSET ??_C@_0CA@IHEGKOED@Used?5size?5too?5big?5for?5xmlBuffer@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufOverflowError
	add	esp, 8

; 1226 :         ret->use = INT_MAX;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+4], 2147483647		; 7fffffffH

; 1227 :         ret->size = INT_MAX;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jmp	SHORT $LN10@xmlBufBack
$LN9@xmlBufBack:

; 1228 :     } else if (buf->size > INT_MAX) {

	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+24], 2147483647		; 7fffffffH
	jbe	SHORT $LN10@xmlBufBack

; 1229 :         /*
; 1230 :          * milder case, we allocated more than the maximum allowed memory
; 1231 :          * for an xmlBuffer on this architecture, but used less than the
; 1232 :          * limit.
; 1233 :          * Keep the buffer but provide a truncated size value.
; 1234 :          */
; 1235 :         xmlBufOverflowError(buf, "Allocated size too big for xmlBuffer");

	push	OFFSET ??_C@_0CF@HDAKMICL@Allocated?5size?5too?5big?5for?5xmlB@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufOverflowError
	add	esp, 8

; 1236 :         ret->size = INT_MAX;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
$LN10@xmlBufBack:

; 1237 :     }
; 1238 :     ret->use = (int) buf->use;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+4], ecx

; 1239 :     ret->size = (int) buf->size;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+8], ecx

; 1240 :     ret->alloc = buf->alloc;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx

; 1241 :     ret->content = buf->content;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 1242 :     ret->contentIO = buf->contentIO;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx

; 1243 :     xmlFree(buf);

	mov	esi, esp
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1244 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlBufBack:

; 1245 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufBackToBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufFromBuffer
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_buffer$ = 8						; size = 4
_xmlBufFromBuffer PROC					; COMDAT

; 1167 : xmlBufFromBuffer(xmlBufferPtr buffer) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 1168 :     xmlBufPtr ret;
; 1169 : 
; 1170 :     if (buffer == NULL)

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN2@xmlBufFrom

; 1171 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlBufFrom
$LN2@xmlBufFrom:

; 1172 : 
; 1173 :     ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));

	mov	esi, esp
	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 1174 :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN3@xmlBufFrom

; 1175 : 	xmlBufMemoryError(NULL, "creating buffer");

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	0
	call	_xmlBufMemoryError
	add	esp, 8

; 1176 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlBufFrom
$LN3@xmlBufFrom:

; 1177 :     }
; 1178 :     ret->use = buffer->use;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx

; 1179 :     ret->size = buffer->size;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+24], edx

; 1180 :     ret->compat_use = buffer->use;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1181 :     ret->compat_size = buffer->size;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 1182 :     ret->error = 0;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+32], 0

; 1183 :     ret->buffer = buffer;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [ecx+28], edx

; 1184 :     ret->alloc = buffer->alloc;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 1185 :     ret->content = buffer->content;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1186 :     ret->contentIO = buffer->contentIO;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 1187 : 
; 1188 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlBufFrom:

; 1189 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufFromBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufDump
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_xmlBufDump PROC					; COMDAT

; 548  : xmlBufDump(FILE *file, xmlBufPtr buf) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 549  :     size_t ret;
; 550  : 
; 551  :     if ((buf == NULL) || (buf->error != 0)) {

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufDump
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufDump
$LN3@xmlBufDump:

; 552  : #ifdef DEBUG_BUFFER
; 553  :         xmlGenericError(xmlGenericErrorContext,
; 554  : 		"xmlBufDump: buf == NULL or in error\n");
; 555  : #endif
; 556  : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlBufDump
$LN2@xmlBufDump:

; 557  :     }
; 558  :     if (buf->content == NULL) {

	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN4@xmlBufDump

; 559  : #ifdef DEBUG_BUFFER
; 560  :         xmlGenericError(xmlGenericErrorContext,
; 561  : 		"xmlBufDump: buf->content == NULL\n");
; 562  : #endif
; 563  : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlBufDump
$LN4@xmlBufDump:

; 564  :     }
; 565  :     CHECK_COMPAT(buf)

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN5@xmlBufDump
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN5@xmlBufDump
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+24], edx
$LN5@xmlBufDump:
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN7@xmlBufDump
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+4], 2147483647		; 7fffffffH
	jae	SHORT $LN7@xmlBufDump
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+20], eax
$LN7@xmlBufDump:

; 566  :     if (file == NULL)

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN9@xmlBufDump

; 567  : 	file = stdout;

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _file$[ebp], eax
$LN9@xmlBufDump:

; 568  :     ret = fwrite(buf->content, sizeof(xmlChar), buf->use, file);

	mov	esi, esp
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	push	1
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 569  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlBufDump:

; 570  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufDump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufDetach
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_buf$ = 8						; size = 4
_xmlBufDetach PROC					; COMDAT

; 196  : xmlBufDetach(xmlBufPtr buf) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 197  :     xmlChar *ret;
; 198  : 
; 199  :     if (buf == NULL)

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN2@xmlBufDeta

; 200  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlBufDeta
$LN2@xmlBufDeta:

; 201  :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE)

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+12], 2
	jne	SHORT $LN3@xmlBufDeta

; 202  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlBufDeta
$LN3@xmlBufDeta:

; 203  :     if (buf->buffer != NULL)

	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN4@xmlBufDeta

; 204  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlBufDeta
$LN4@xmlBufDeta:

; 205  :     if (buf->error)

	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN5@xmlBufDeta

; 206  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlBufDeta
$LN5@xmlBufDeta:

; 207  : 
; 208  :     ret = buf->content;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ret$[ebp], ecx

; 209  :     buf->content = NULL;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx], 0

; 210  :     buf->size = 0;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax+24], 0

; 211  :     buf->use = 0;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 212  :     buf->compat_use = 0;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+4], 0

; 213  :     buf->compat_size = 0;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax+8], 0

; 214  : 
; 215  :     return ret;

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlBufDeta:

; 216  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufDetach ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufErase
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlBufErase PROC					; COMDAT

; 646  : xmlBufErase(xmlBufPtr buf, size_t len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 647  :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufEras
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufEras
$LN3@xmlBufEras:

; 648  :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlBufEras
$LN2@xmlBufEras:

; 649  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufEras
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufEras
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufEras:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufEras
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufEras
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufEras:

; 650  :     if (len > buf->use)

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jbe	SHORT $LN8@xmlBufEras

; 651  :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlBufEras
$LN8@xmlBufEras:

; 652  :     buf->use -= len;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 653  :     buf->content[buf->use] = 0;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+eax], 0

; 654  :     UPDATE_COMPAT(buf)

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+24], 2147483647		; 7fffffffH
	jae	SHORT $LN9@xmlBufEras
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN10@xmlBufEras
$LN9@xmlBufEras:
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
$LN10@xmlBufEras:
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+20], 2147483647		; 7fffffffH
	jae	SHORT $LN11@xmlBufEras
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN12@xmlBufEras
$LN11@xmlBufEras:
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax+4], 2147483647		; 7fffffffH
$LN12@xmlBufEras:

; 655  :     return(0);

	xor	eax, eax
$LN1@xmlBufEras:

; 656  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufErase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufAddLen
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlBufAddLen PROC					; COMDAT

; 621  : xmlBufAddLen(xmlBufPtr buf, size_t len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 622  :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufAddL
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufAddL
$LN3@xmlBufAddL:

; 623  :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlBufAddL
$LN2@xmlBufAddL:

; 624  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufAddL
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufAddL
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufAddL:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufAddL
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufAddL
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufAddL:

; 625  :     if (len > (buf->size - buf->use))

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [eax+24]
	sub	edx, DWORD PTR [ecx+20]
	cmp	DWORD PTR _len$[ebp], edx
	jbe	SHORT $LN8@xmlBufAddL

; 626  :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlBufAddL
$LN8@xmlBufAddL:

; 627  :     buf->use += len;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 628  :     UPDATE_COMPAT(buf)

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+24], 2147483647		; 7fffffffH
	jae	SHORT $LN9@xmlBufAddL
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN10@xmlBufAddL
$LN9@xmlBufAddL:
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
$LN10@xmlBufAddL:
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+20], 2147483647		; 7fffffffH
	jae	SHORT $LN11@xmlBufAddL
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN12@xmlBufAddL
$LN11@xmlBufAddL:
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax+4], 2147483647		; 7fffffffH
$LN12@xmlBufAddL:

; 629  :     if (buf->size > buf->use)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+20]
	jbe	SHORT $LN13@xmlBufAddL

; 630  :         buf->content[buf->use] = 0;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+edx], 0
	jmp	SHORT $LN14@xmlBufAddL
$LN13@xmlBufAddL:

; 631  :     else
; 632  :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlBufAddL
$LN14@xmlBufAddL:

; 633  :     return(0);

	xor	eax, eax
$LN1@xmlBufAddL:

; 634  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufAddLen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufIsEmpty
_TEXT	SEGMENT
tv83 = -4						; size = 4
_buf$ = 8						; size = 4
_xmlBufIsEmpty PROC					; COMDAT

; 727  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 728  :     if ((!buf) || (buf->error))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufIsEm
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufIsEm
$LN3@xmlBufIsEm:

; 729  :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlBufIsEm
$LN2@xmlBufIsEm:

; 730  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufIsEm
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufIsEm
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufIsEm:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufIsEm
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufIsEm
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufIsEm:

; 731  : 
; 732  :     return(buf->use == 0);

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN9@xmlBufIsEm
	mov	DWORD PTR tv83[ebp], 1
	jmp	SHORT $LN10@xmlBufIsEm
$LN9@xmlBufIsEm:
	mov	DWORD PTR tv83[ebp], 0
$LN10@xmlBufIsEm:
	mov	eax, DWORD PTR tv83[ebp]
$LN1@xmlBufIsEm:

; 733  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufIsEmpty ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufLength
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufLength PROC					; COMDAT

; 669  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 670  :     if ((!buf) || (buf->error))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufLeng
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufLeng
$LN3@xmlBufLeng:

; 671  :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@xmlBufLeng
$LN2@xmlBufLeng:

; 672  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufLeng
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufLeng
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufLeng:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufLeng
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufLeng
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufLeng:

; 673  : 
; 674  :     return(buf->use);

	mov	eax, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [eax+20]
$LN1@xmlBufLeng:

; 675  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufAvail
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufAvail PROC					; COMDAT

; 709  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 710  :     if ((!buf) || (buf->error))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufAvai
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufAvai
$LN3@xmlBufAvai:

; 711  :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@xmlBufAvai
$LN2@xmlBufAvai:

; 712  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufAvai
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufAvai
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufAvai:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufAvai
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufAvai
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufAvai:

; 713  : 
; 714  :     return(buf->size - buf->use);

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [eax+24]
	sub	eax, DWORD PTR [ecx+20]
$LN1@xmlBufAvai:

; 715  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufAvail ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufWriteQuotedString
_TEXT	SEGMENT
_base$ = -8						; size = 4
_cur$ = -4						; size = 4
_buf$ = 8						; size = 4
_string$ = 12						; size = 4
_xmlBufWriteQuotedString PROC				; COMDAT

; 1111 : xmlBufWriteQuotedString(xmlBufPtr buf, const xmlChar *string) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 1112 :     const xmlChar *cur, *base;
; 1113 :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN5@xmlBufWrit
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN4@xmlBufWrit
$LN5@xmlBufWrit:

; 1114 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlBufWrit
$LN4@xmlBufWrit:

; 1115 :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN6@xmlBufWrit
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufWrit
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN6@xmlBufWrit:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN8@xmlBufWrit
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN8@xmlBufWrit
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN8@xmlBufWrit:

; 1116 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE)

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+12], 2
	jne	SHORT $LN10@xmlBufWrit

; 1117 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlBufWrit
$LN10@xmlBufWrit:

; 1118 :     if (xmlStrchr(string, '\"')) {

	push	34					; 00000022H
	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	$LN11@xmlBufWrit

; 1119 :         if (xmlStrchr(string, '\'')) {

	push	39					; 00000027H
	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	$LN13@xmlBufWrit

; 1120 : #ifdef DEBUG_BUFFER
; 1121 : 	    xmlGenericError(xmlGenericErrorContext,
; 1122 :  "xmlBufWriteQuotedString: string contains quote and double-quotes !\n");
; 1123 : #endif
; 1124 : 	    xmlBufCCat(buf, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufCCat
	add	esp, 8

; 1125 :             base = cur = string;

	mov	ecx, DWORD PTR _string$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _base$[ebp], edx
$LN2@xmlBufWrit:

; 1126 :             while(*cur != 0){

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@xmlBufWrit

; 1127 :                 if(*cur == '"'){

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN15@xmlBufWrit

; 1128 :                     if (base != cur)

	mov	ecx, DWORD PTR _base$[ebp]
	cmp	ecx, DWORD PTR _cur$[ebp]
	je	SHORT $LN17@xmlBufWrit

; 1129 :                         xmlBufAdd(buf, base, cur - base);

	mov	edx, DWORD PTR _cur$[ebp]
	sub	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _base$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN17@xmlBufWrit:

; 1130 :                     xmlBufAdd(buf, BAD_CAST "&quot;", 6);

	push	6
	push	OFFSET ??_C@_06DDLNFFBN@?$CGquot?$DL@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 1131 :                     cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 1132 :                     base = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _base$[ebp], ecx

; 1133 :                 }

	jmp	SHORT $LN16@xmlBufWrit
$LN15@xmlBufWrit:

; 1134 :                 else {
; 1135 :                     cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
$LN16@xmlBufWrit:

; 1136 :                 }
; 1137 :             }

	jmp	SHORT $LN2@xmlBufWrit
$LN3@xmlBufWrit:

; 1138 :             if (base != cur)

	mov	eax, DWORD PTR _base$[ebp]
	cmp	eax, DWORD PTR _cur$[ebp]
	je	SHORT $LN18@xmlBufWrit

; 1139 :                 xmlBufAdd(buf, base, cur - base);

	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, DWORD PTR _base$[ebp]
	push	ecx
	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN18@xmlBufWrit:

; 1140 : 	    xmlBufCCat(buf, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufCCat
	add	esp, 8

; 1141 : 	}

	jmp	SHORT $LN14@xmlBufWrit
$LN13@xmlBufWrit:

; 1142 :         else{
; 1143 : 	    xmlBufCCat(buf, "\'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufCCat
	add	esp, 8

; 1144 :             xmlBufCat(buf, string);

	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufCat
	add	esp, 8

; 1145 : 	    xmlBufCCat(buf, "\'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufCCat
	add	esp, 8
$LN14@xmlBufWrit:

; 1146 :         }
; 1147 :     } else {

	jmp	SHORT $LN12@xmlBufWrit
$LN11@xmlBufWrit:

; 1148 :         xmlBufCCat(buf, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufCCat
	add	esp, 8

; 1149 :         xmlBufCat(buf, string);

	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufCat
	add	esp, 8

; 1150 :         xmlBufCCat(buf, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufCCat
	add	esp, 8
$LN12@xmlBufWrit:

; 1151 :     }
; 1152 :     return(0);

	xor	eax, eax
$LN1@xmlBufWrit:

; 1153 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufWriteQuotedString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufWriteChar
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_string$ = 12						; size = 4
_xmlBufWriteChar PROC					; COMDAT

; 1088 : xmlBufWriteChar(xmlBufPtr buf, const char *string) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 1089 :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufWrit
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufWrit
$LN3@xmlBufWrit:

; 1090 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlBufWrit
$LN2@xmlBufWrit:

; 1091 :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufWrit
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufWrit
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufWrit:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufWrit
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufWrit
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufWrit:

; 1092 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE)

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+12], 2
	jne	SHORT $LN8@xmlBufWrit

; 1093 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlBufWrit
$LN8@xmlBufWrit:

; 1094 :     return(xmlBufCCat(buf, string));

	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufCCat
	add	esp, 8
$LN1@xmlBufWrit:

; 1095 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufWriteChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufWriteCHAR
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_string$ = 12						; size = 4
_xmlBufWriteCHAR PROC					; COMDAT

; 1067 : xmlBufWriteCHAR(xmlBufPtr buf, const xmlChar *string) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 1068 :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufWrit
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufWrit
$LN3@xmlBufWrit:

; 1069 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlBufWrit
$LN2@xmlBufWrit:

; 1070 :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufWrit
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufWrit
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufWrit:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufWrit
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufWrit
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufWrit:

; 1071 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE)

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+12], 2
	jne	SHORT $LN8@xmlBufWrit

; 1072 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlBufWrit
$LN8@xmlBufWrit:

; 1073 :     return(xmlBufCat(buf, string));

	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufCat
	add	esp, 8
$LN1@xmlBufWrit:

; 1074 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufWriteCHAR ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufCCat
_TEXT	SEGMENT
_cur$ = -4						; size = 4
_buf$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlBufCCat PROC					; COMDAT

; 1027 : xmlBufCCat(xmlBufPtr buf, const char *str) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 1028 :     const char *cur;
; 1029 : 
; 1030 :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN6@xmlBufCCat
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN5@xmlBufCCat
$LN6@xmlBufCCat:

; 1031 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlBufCCat
$LN5@xmlBufCCat:

; 1032 :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN7@xmlBufCCat
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN7@xmlBufCCat
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN7@xmlBufCCat:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN9@xmlBufCCat
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN9@xmlBufCCat
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN9@xmlBufCCat:

; 1033 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+12], 2
	jne	SHORT $LN11@xmlBufCCat
	or	eax, -1
	jmp	$LN1@xmlBufCCat
$LN11@xmlBufCCat:

; 1034 :     if (str == NULL) {

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN12@xmlBufCCat

; 1035 : #ifdef DEBUG_BUFFER
; 1036 :         xmlGenericError(xmlGenericErrorContext,
; 1037 : 		"xmlBufCCat: str == NULL\n");
; 1038 : #endif
; 1039 : 	return -1;

	or	eax, -1
	jmp	$LN1@xmlBufCCat
$LN12@xmlBufCCat:

; 1040 :     }
; 1041 :     for (cur = str;*cur != 0;cur++) {

	mov	ecx, DWORD PTR _str$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	SHORT $LN4@xmlBufCCat
$LN2@xmlBufCCat:
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
$LN4@xmlBufCCat:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@xmlBufCCat

; 1042 :         if (buf->use  + 10 >= buf->size) {

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	eax, DWORD PTR [ecx+24]
	jb	SHORT $LN13@xmlBufCCat

; 1043 :             if (!xmlBufResize(buf, buf->use+10)){

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufResize
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlBufCCat

; 1044 : 		xmlBufMemoryError(buf, "growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufMemoryError
	add	esp, 8

; 1045 :                 return XML_ERR_NO_MEMORY;

	mov	eax, 2
	jmp	SHORT $LN1@xmlBufCCat
$LN13@xmlBufCCat:

; 1046 :             }
; 1047 :         }
; 1048 :         buf->content[buf->use++] = *cur;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	dl, BYTE PTR [edx]
	mov	BYTE PTR [eax+ecx], dl
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1049 :     }

	jmp	SHORT $LN2@xmlBufCCat
$LN3@xmlBufCCat:

; 1050 :     buf->content[buf->use] = 0;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+ecx], 0

; 1051 :     UPDATE_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+24], 2147483647		; 7fffffffH
	jae	SHORT $LN15@xmlBufCCat
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN16@xmlBufCCat
$LN15@xmlBufCCat:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+8], 2147483647		; 7fffffffH
$LN16@xmlBufCCat:
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+20], 2147483647		; 7fffffffH
	jae	SHORT $LN17@xmlBufCCat
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN18@xmlBufCCat
$LN17@xmlBufCCat:
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+4], 2147483647		; 7fffffffH
$LN18@xmlBufCCat:

; 1052 :     return 0;

	xor	eax, eax
$LN1@xmlBufCCat:

; 1053 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufCCat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufCat
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlBufCat PROC						; COMDAT

; 1007 : xmlBufCat(xmlBufPtr buf, const xmlChar *str) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 1008 :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufCat
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufCat
$LN3@xmlBufCat:

; 1009 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlBufCat
$LN2@xmlBufCat:

; 1010 :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufCat
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufCat
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufCat:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufCat
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufCat
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufCat:

; 1011 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+12], 2
	jne	SHORT $LN8@xmlBufCat
	or	eax, -1
	jmp	SHORT $LN1@xmlBufCat
$LN8@xmlBufCat:

; 1012 :     if (str == NULL) return -1;

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN9@xmlBufCat
	or	eax, -1
	jmp	SHORT $LN1@xmlBufCat
$LN9@xmlBufCat:

; 1013 :     return xmlBufAdd(buf, str, -1);

	push	-1
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN1@xmlBufCat:

; 1014 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufCat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufAddHead
_TEXT	SEGMENT
_start_buf$1 = -8					; size = 4
_needSize$ = -4						; size = 4
_buf$ = 8						; size = 4
_str$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlBufAddHead PROC					; COMDAT

; 928  : xmlBufAddHead(xmlBufPtr buf, const xmlChar *str, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 929  :     unsigned int needSize;
; 930  : 
; 931  :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufAddH
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufAddH
$LN3@xmlBufAddH:

; 932  :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlBufAddH
$LN2@xmlBufAddH:

; 933  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufAddH
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufAddH
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufAddH:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufAddH
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufAddH
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufAddH:

; 934  :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+12], 2
	jne	SHORT $LN8@xmlBufAddH
	or	eax, -1
	jmp	$LN1@xmlBufAddH
$LN8@xmlBufAddH:

; 935  :     if (str == NULL) {

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN9@xmlBufAddH

; 936  : #ifdef DEBUG_BUFFER
; 937  :         xmlGenericError(xmlGenericErrorContext,
; 938  : 		"xmlBufAddHead: str == NULL\n");
; 939  : #endif
; 940  : 	return -1;

	or	eax, -1
	jmp	$LN1@xmlBufAddH
$LN9@xmlBufAddH:

; 941  :     }
; 942  :     if (len < -1) {

	cmp	DWORD PTR _len$[ebp], -1
	jge	SHORT $LN10@xmlBufAddH

; 943  : #ifdef DEBUG_BUFFER
; 944  :         xmlGenericError(xmlGenericErrorContext,
; 945  : 		"xmlBufAddHead: len < 0\n");
; 946  : #endif
; 947  : 	return -1;

	or	eax, -1
	jmp	$LN1@xmlBufAddH
$LN10@xmlBufAddH:

; 948  :     }
; 949  :     if (len == 0) return 0;

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN11@xmlBufAddH
	xor	eax, eax
	jmp	$LN1@xmlBufAddH
$LN11@xmlBufAddH:

; 950  : 
; 951  :     if (len < 0)

	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN12@xmlBufAddH

; 952  :         len = xmlStrlen(str);

	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax
$LN12@xmlBufAddH:

; 953  : 
; 954  :     if (len <= 0) return -1;

	cmp	DWORD PTR _len$[ebp], 0
	jg	SHORT $LN13@xmlBufAddH
	or	eax, -1
	jmp	$LN1@xmlBufAddH
$LN13@xmlBufAddH:

; 955  : 
; 956  :     if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {

	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+12], 3
	jne	$LN14@xmlBufAddH
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	$LN14@xmlBufAddH

; 957  :         size_t start_buf = buf->content - buf->contentIO;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _start_buf$1[ebp], eax

; 958  : 
; 959  : 	if (start_buf > (unsigned int) len) {

	mov	ecx, DWORD PTR _start_buf$1[ebp]
	cmp	ecx, DWORD PTR _len$[ebp]
	jbe	$LN14@xmlBufAddH

; 960  : 	    /*
; 961  : 	     * We can add it in the space previously shrinked
; 962  : 	     */
; 963  : 	    buf->content -= len;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx], eax

; 964  :             memmove(&buf->content[0], str, len);

	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 965  : 	    buf->use += len;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax+20], edx

; 966  : 	    buf->size += len;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax+24], edx

; 967  : 	    UPDATE_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+24], 2147483647		; 7fffffffH
	jae	SHORT $LN16@xmlBufAddH
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN17@xmlBufAddH
$LN16@xmlBufAddH:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+8], 2147483647		; 7fffffffH
$LN17@xmlBufAddH:
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+20], 2147483647		; 7fffffffH
	jae	SHORT $LN18@xmlBufAddH
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN19@xmlBufAddH
$LN18@xmlBufAddH:
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+4], 2147483647		; 7fffffffH
$LN19@xmlBufAddH:

; 968  : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlBufAddH
$LN14@xmlBufAddH:

; 969  : 	}
; 970  :     }
; 971  :     needSize = buf->use + len + 2;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _len$[ebp]
	lea	edx, DWORD PTR [eax+ecx+2]
	mov	DWORD PTR _needSize$[ebp], edx

; 972  :     if (needSize > buf->size){

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _needSize$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jbe	SHORT $LN20@xmlBufAddH

; 973  : 	if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {

	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+12], 5
	jne	SHORT $LN21@xmlBufAddH

; 974  : 	    /*
; 975  : 	     * Used to provide parsing limits
; 976  : 	     */
; 977  : 	    if (needSize >= XML_MAX_TEXT_LENGTH) {

	cmp	DWORD PTR _needSize$[ebp], 10000000	; 00989680H
	jb	SHORT $LN21@xmlBufAddH

; 978  : 		xmlBufMemoryError(buf, "buffer error: text too long\n");

	push	OFFSET ??_C@_0BN@GFPONKGI@buffer?5error?3?5text?5too?5long?6@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufMemoryError
	add	esp, 8

; 979  : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlBufAddH
$LN21@xmlBufAddH:

; 980  : 	    }
; 981  : 	}
; 982  :         if (!xmlBufResize(buf, needSize)){

	mov	ecx, DWORD PTR _needSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufResize
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@xmlBufAddH

; 983  : 	    xmlBufMemoryError(buf, "growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufMemoryError
	add	esp, 8

; 984  :             return XML_ERR_NO_MEMORY;

	mov	eax, 2
	jmp	$LN1@xmlBufAddH
$LN20@xmlBufAddH:

; 985  :         }
; 986  :     }
; 987  : 
; 988  :     memmove(&buf->content[len], &buf->content[0], buf->use);

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _len$[ebp]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 989  :     memmove(&buf->content[0], str, len);

	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 990  :     buf->use += len;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax+20], edx

; 991  :     buf->content[buf->use] = 0;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+edx], 0

; 992  :     UPDATE_COMPAT(buf)

	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+24], 2147483647		; 7fffffffH
	jae	SHORT $LN24@xmlBufAddH
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN25@xmlBufAddH
$LN24@xmlBufAddH:
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax+8], 2147483647		; 7fffffffH
$LN25@xmlBufAddH:
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+20], 2147483647		; 7fffffffH
	jae	SHORT $LN26@xmlBufAddH
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN27@xmlBufAddH
$LN26@xmlBufAddH:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+4], 2147483647		; 7fffffffH
$LN27@xmlBufAddH:

; 993  :     return 0;

	xor	eax, eax
$LN1@xmlBufAddH:

; 994  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufAddHead ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufAdd
_TEXT	SEGMENT
_needSize$ = -4						; size = 4
_buf$ = 8						; size = 4
_str$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlBufAdd PROC						; COMDAT

; 868  : xmlBufAdd(xmlBufPtr buf, const xmlChar *str, int len) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 869  :     unsigned int needSize;
; 870  : 
; 871  :     if ((str == NULL) || (buf == NULL) || (buf->error))

	cmp	DWORD PTR _str$[ebp], 0
	je	SHORT $LN3@xmlBufAdd
	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufAdd
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufAdd
$LN3@xmlBufAdd:

; 872  : 	return -1;

	or	eax, -1
	jmp	$LN1@xmlBufAdd
$LN2@xmlBufAdd:

; 873  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufAdd
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufAdd
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufAdd:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufAdd
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufAdd
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufAdd:

; 874  : 
; 875  :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+12], 2
	jne	SHORT $LN8@xmlBufAdd
	or	eax, -1
	jmp	$LN1@xmlBufAdd
$LN8@xmlBufAdd:

; 876  :     if (len < -1) {

	cmp	DWORD PTR _len$[ebp], -1
	jge	SHORT $LN9@xmlBufAdd

; 877  : #ifdef DEBUG_BUFFER
; 878  :         xmlGenericError(xmlGenericErrorContext,
; 879  : 		"xmlBufAdd: len < 0\n");
; 880  : #endif
; 881  : 	return -1;

	or	eax, -1
	jmp	$LN1@xmlBufAdd
$LN9@xmlBufAdd:

; 882  :     }
; 883  :     if (len == 0) return 0;

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN10@xmlBufAdd
	xor	eax, eax
	jmp	$LN1@xmlBufAdd
$LN10@xmlBufAdd:

; 884  : 
; 885  :     if (len < 0)

	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN11@xmlBufAdd

; 886  :         len = xmlStrlen(str);

	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax
$LN11@xmlBufAdd:

; 887  : 
; 888  :     if (len < 0) return -1;

	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN12@xmlBufAdd
	or	eax, -1
	jmp	$LN1@xmlBufAdd
$LN12@xmlBufAdd:

; 889  :     if (len == 0) return 0;

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN13@xmlBufAdd
	xor	eax, eax
	jmp	$LN1@xmlBufAdd
$LN13@xmlBufAdd:

; 890  : 
; 891  :     needSize = buf->use + len + 2;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _len$[ebp]
	lea	edx, DWORD PTR [eax+ecx+2]
	mov	DWORD PTR _needSize$[ebp], edx

; 892  :     if (needSize > buf->size){

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _needSize$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jbe	SHORT $LN14@xmlBufAdd

; 893  : 	if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {

	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+12], 5
	jne	SHORT $LN15@xmlBufAdd

; 894  : 	    /*
; 895  : 	     * Used to provide parsing limits
; 896  : 	     */
; 897  : 	    if (needSize >= XML_MAX_TEXT_LENGTH) {

	cmp	DWORD PTR _needSize$[ebp], 10000000	; 00989680H
	jb	SHORT $LN15@xmlBufAdd

; 898  : 		xmlBufMemoryError(buf, "buffer error: text too long\n");

	push	OFFSET ??_C@_0BN@GFPONKGI@buffer?5error?3?5text?5too?5long?6@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufMemoryError
	add	esp, 8

; 899  : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlBufAdd
$LN15@xmlBufAdd:

; 900  : 	    }
; 901  : 	}
; 902  :         if (!xmlBufResize(buf, needSize)){

	mov	ecx, DWORD PTR _needSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufResize
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlBufAdd

; 903  : 	    xmlBufMemoryError(buf, "growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufMemoryError
	add	esp, 8

; 904  :             return XML_ERR_NO_MEMORY;

	mov	eax, 2
	jmp	$LN1@xmlBufAdd
$LN14@xmlBufAdd:

; 905  :         }
; 906  :     }
; 907  : 
; 908  :     memmove(&buf->content[buf->use], str, len*sizeof(xmlChar));

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR [edx+20]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 909  :     buf->use += len;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 910  :     buf->content[buf->use] = 0;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+ecx], 0

; 911  :     UPDATE_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+24], 2147483647		; 7fffffffH
	jae	SHORT $LN18@xmlBufAdd
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN19@xmlBufAdd
$LN18@xmlBufAdd:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+8], 2147483647		; 7fffffffH
$LN19@xmlBufAdd:
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+20], 2147483647		; 7fffffffH
	jae	SHORT $LN20@xmlBufAdd
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN21@xmlBufAdd
$LN20@xmlBufAdd:
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+4], 2147483647		; 7fffffffH
$LN21@xmlBufAdd:

; 912  :     return 0;

	xor	eax, eax
$LN1@xmlBufAdd:

; 913  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufAdd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufResize
_TEXT	SEGMENT
tv129 = -20						; size = 4
tv91 = -16						; size = 4
_start_buf$ = -12					; size = 4
_rebuf$ = -8						; size = 4
_newSize$ = -4						; size = 4
_buf$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlBufResize PROC					; COMDAT

; 746  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 747  :     unsigned int newSize;
; 748  :     xmlChar* rebuf = NULL;

	mov	DWORD PTR _rebuf$[ebp], 0

; 749  :     size_t start_buf;
; 750  : 
; 751  :     if ((buf == NULL) || (buf->error))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN9@xmlBufResi
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN8@xmlBufResi
$LN9@xmlBufResi:

; 752  :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlBufResi
$LN8@xmlBufResi:

; 753  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN10@xmlBufResi
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN10@xmlBufResi
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN10@xmlBufResi:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN12@xmlBufResi
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN12@xmlBufResi
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN12@xmlBufResi:

; 754  : 
; 755  :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return(0);

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+12], 2
	jne	SHORT $LN14@xmlBufResi
	xor	eax, eax
	jmp	$LN1@xmlBufResi
$LN14@xmlBufResi:

; 756  :     if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {

	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+12], 5
	jne	SHORT $LN15@xmlBufResi

; 757  :         /*
; 758  : 	 * Used to provide parsing limits
; 759  : 	 */
; 760  :         if (size >= XML_MAX_TEXT_LENGTH) {

	cmp	DWORD PTR _size$[ebp], 10000000		; 00989680H
	jb	SHORT $LN15@xmlBufResi

; 761  : 	    xmlBufMemoryError(buf, "buffer error: text too long\n");

	push	OFFSET ??_C@_0BN@GFPONKGI@buffer?5error?3?5text?5too?5long?6@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufMemoryError
	add	esp, 8

; 762  : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlBufResi
$LN15@xmlBufResi:

; 763  : 	}
; 764  :     }
; 765  : 
; 766  :     /* Don't resize if we don't have to */
; 767  :     if (size < buf->size)

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jae	SHORT $LN17@xmlBufResi

; 768  :         return 1;

	mov	eax, 1
	jmp	$LN1@xmlBufResi
$LN17@xmlBufResi:

; 769  : 
; 770  :     /* figure out new size */
; 771  :     switch (buf->alloc){

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv91[ebp], eax
	cmp	DWORD PTR tv91[ebp], 4
	ja	$LN25@xmlBufResi
	mov	ecx, DWORD PTR tv91[ebp]
	jmp	DWORD PTR $LN44@xmlBufResi[ecx*4]
$LN18@xmlBufResi:

; 772  : 	case XML_BUFFER_ALLOC_IO:
; 773  : 	case XML_BUFFER_ALLOC_DOUBLEIT:
; 774  : 	    /*take care of empty case*/
; 775  : 	    newSize = (buf->size ? buf->size*2 : size + 10);

	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN42@xmlBufResi
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shl	ecx, 1
	mov	DWORD PTR tv129[ebp], ecx
	jmp	SHORT $LN43@xmlBufResi
$LN42@xmlBufResi:
	mov	edx, DWORD PTR _size$[ebp]
	add	edx, 10					; 0000000aH
	mov	DWORD PTR tv129[ebp], edx
$LN43@xmlBufResi:
	mov	eax, DWORD PTR tv129[ebp]
	mov	DWORD PTR _newSize$[ebp], eax
$LN4@xmlBufResi:

; 776  : 	    while (size > newSize) {

	mov	ecx, DWORD PTR _size$[ebp]
	cmp	ecx, DWORD PTR _newSize$[ebp]
	jbe	SHORT $LN5@xmlBufResi

; 777  : 	        if (newSize > UINT_MAX / 2) {

	cmp	DWORD PTR _newSize$[ebp], 2147483647	; 7fffffffH
	jbe	SHORT $LN19@xmlBufResi

; 778  : 	            xmlBufMemoryError(buf, "growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufMemoryError
	add	esp, 8

; 779  : 	            return 0;

	xor	eax, eax
	jmp	$LN1@xmlBufResi
$LN19@xmlBufResi:

; 780  : 	        }
; 781  : 	        newSize *= 2;

	mov	eax, DWORD PTR _newSize$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newSize$[ebp], eax

; 782  : 	    }

	jmp	SHORT $LN4@xmlBufResi
$LN5@xmlBufResi:

; 783  : 	    break;

	jmp	SHORT $LN2@xmlBufResi
$LN20@xmlBufResi:

; 784  : 	case XML_BUFFER_ALLOC_EXACT:
; 785  : 	    newSize = size+10;

	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR _newSize$[ebp], ecx

; 786  : 	    break;

	jmp	SHORT $LN2@xmlBufResi
$LN21@xmlBufResi:

; 787  :         case XML_BUFFER_ALLOC_HYBRID:
; 788  :             if (buf->use < BASE_BUFFER_SIZE)

	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+20], 4096		; 00001000H
	jae	SHORT $LN22@xmlBufResi

; 789  :                 newSize = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _newSize$[ebp], eax
	jmp	SHORT $LN23@xmlBufResi
$LN22@xmlBufResi:

; 790  :             else {
; 791  :                 newSize = buf->size * 2;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	shl	edx, 1
	mov	DWORD PTR _newSize$[ebp], edx
$LN6@xmlBufResi:

; 792  :                 while (size > newSize) {

	mov	eax, DWORD PTR _size$[ebp]
	cmp	eax, DWORD PTR _newSize$[ebp]
	jbe	SHORT $LN23@xmlBufResi

; 793  :                     if (newSize > UINT_MAX / 2) {

	cmp	DWORD PTR _newSize$[ebp], 2147483647	; 7fffffffH
	jbe	SHORT $LN24@xmlBufResi

; 794  :                         xmlBufMemoryError(buf, "growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufMemoryError
	add	esp, 8

; 795  :                         return 0;

	xor	eax, eax
	jmp	$LN1@xmlBufResi
$LN24@xmlBufResi:

; 796  :                     }
; 797  :                     newSize *= 2;

	mov	edx, DWORD PTR _newSize$[ebp]
	shl	edx, 1
	mov	DWORD PTR _newSize$[ebp], edx

; 798  :                 }

	jmp	SHORT $LN6@xmlBufResi
$LN23@xmlBufResi:

; 799  :             }
; 800  :             break;

	jmp	SHORT $LN2@xmlBufResi
$LN25@xmlBufResi:

; 801  : 
; 802  : 	default:
; 803  : 	    newSize = size+10;

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 10					; 0000000aH
	mov	DWORD PTR _newSize$[ebp], eax
$LN2@xmlBufResi:

; 804  : 	    break;
; 805  :     }
; 806  : 
; 807  :     if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {

	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+12], 3
	jne	$LN26@xmlBufResi
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	$LN26@xmlBufResi

; 808  :         start_buf = buf->content - buf->contentIO;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _start_buf$[ebp], edx

; 809  : 
; 810  :         if (start_buf > newSize) {

	mov	eax, DWORD PTR _start_buf$[ebp]
	cmp	eax, DWORD PTR _newSize$[ebp]
	jbe	SHORT $LN28@xmlBufResi

; 811  : 	    /* move data back to start */
; 812  : 	    memmove(buf->contentIO, buf->content, buf->use);

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 813  : 	    buf->content = buf->contentIO;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx], eax

; 814  : 	    buf->content[buf->use] = 0;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+edx], 0

; 815  : 	    buf->size += start_buf;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, DWORD PTR _start_buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 816  : 	} else {

	jmp	SHORT $LN29@xmlBufResi
$LN28@xmlBufResi:

; 817  : 	    rebuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + newSize);

	mov	edx, DWORD PTR _start_buf$[ebp]
	add	edx, DWORD PTR _newSize$[ebp]
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _rebuf$[ebp], eax

; 818  : 	    if (rebuf == NULL) {

	cmp	DWORD PTR _rebuf$[ebp], 0
	jne	SHORT $LN30@xmlBufResi

; 819  : 		xmlBufMemoryError(buf, "growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufMemoryError
	add	esp, 8

; 820  : 		return 0;

	xor	eax, eax
	jmp	$LN1@xmlBufResi
$LN30@xmlBufResi:

; 821  : 	    }
; 822  : 	    buf->contentIO = rebuf;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _rebuf$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 823  : 	    buf->content = rebuf + start_buf;

	mov	edx, DWORD PTR _rebuf$[ebp]
	add	edx, DWORD PTR _start_buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax], edx
$LN29@xmlBufResi:

; 824  : 	}
; 825  :     } else {

	jmp	$LN27@xmlBufResi
$LN26@xmlBufResi:

; 826  : 	if (buf->content == NULL) {

	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN31@xmlBufResi

; 827  : 	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);

	mov	esi, esp
	mov	edx, DWORD PTR _newSize$[ebp]
	push	edx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _rebuf$[ebp], eax
	jmp	$LN32@xmlBufResi
$LN31@xmlBufResi:

; 828  : 	} else if (buf->size - buf->use < 100) {

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [eax+24]
	sub	edx, DWORD PTR [ecx+20]
	cmp	edx, 100				; 00000064H
	jae	SHORT $LN33@xmlBufResi

; 829  : 	    rebuf = (xmlChar *) xmlRealloc(buf->content, newSize);

	mov	esi, esp
	mov	eax, DWORD PTR _newSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _rebuf$[ebp], eax

; 830  :         } else {

	jmp	SHORT $LN32@xmlBufResi
$LN33@xmlBufResi:

; 831  : 	    /*
; 832  : 	     * if we are reallocating a buffer far from being full, it's
; 833  : 	     * better to make a new allocation and copy only the used range
; 834  : 	     * and free the old one.
; 835  : 	     */
; 836  : 	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);

	mov	esi, esp
	mov	eax, DWORD PTR _newSize$[ebp]
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _rebuf$[ebp], eax

; 837  : 	    if (rebuf != NULL) {

	cmp	DWORD PTR _rebuf$[ebp], 0
	je	SHORT $LN32@xmlBufResi

; 838  : 		memcpy(rebuf, buf->content, buf->use);

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _rebuf$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 839  : 		xmlFree(buf->content);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 840  : 		rebuf[buf->use] = 0;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _rebuf$[ebp]
	mov	BYTE PTR [ecx+eax], 0
$LN32@xmlBufResi:

; 841  : 	    }
; 842  : 	}
; 843  : 	if (rebuf == NULL) {

	cmp	DWORD PTR _rebuf$[ebp], 0
	jne	SHORT $LN36@xmlBufResi

; 844  : 	    xmlBufMemoryError(buf, "growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufMemoryError
	add	esp, 8

; 845  : 	    return 0;

	xor	eax, eax
	jmp	SHORT $LN1@xmlBufResi
$LN36@xmlBufResi:

; 846  : 	}
; 847  : 	buf->content = rebuf;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _rebuf$[ebp]
	mov	DWORD PTR [eax], ecx
$LN27@xmlBufResi:

; 848  :     }
; 849  :     buf->size = newSize;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _newSize$[ebp]
	mov	DWORD PTR [edx+24], eax

; 850  :     UPDATE_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+24], 2147483647		; 7fffffffH
	jae	SHORT $LN37@xmlBufResi
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN38@xmlBufResi
$LN37@xmlBufResi:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+8], 2147483647		; 7fffffffH
$LN38@xmlBufResi:
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+20], 2147483647		; 7fffffffH
	jae	SHORT $LN39@xmlBufResi
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN40@xmlBufResi
$LN39@xmlBufResi:
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+4], 2147483647		; 7fffffffH
$LN40@xmlBufResi:

; 851  : 
; 852  :     return 1;

	mov	eax, 1
$LN1@xmlBufResi:

; 853  : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN44@xmlBufResi:
	DD	$LN18@xmlBufResi
	DD	$LN20@xmlBufResi
	DD	$LN25@xmlBufResi
	DD	$LN18@xmlBufResi
	DD	$LN21@xmlBufResi
_xmlBufResize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufInflate
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlBufInflate PROC					; COMDAT

; 531  : xmlBufInflate(xmlBufPtr buf, size_t len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 532  :     if (buf == NULL) return(-1);

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN2@xmlBufInfl
	or	eax, -1
	jmp	SHORT $LN1@xmlBufInfl
$LN2@xmlBufInfl:

; 533  :     xmlBufGrowInternal(buf, len + buf->size);

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufGrowInternal
	add	esp, 8

; 534  :     if (buf->error)

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN3@xmlBufInfl

; 535  :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlBufInfl
$LN3@xmlBufInfl:

; 536  :     return(0);

	xor	eax, eax
$LN1@xmlBufInfl:

; 537  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufInflate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufGrow
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlBufGrow PROC					; COMDAT

; 509  : xmlBufGrow(xmlBufPtr buf, int len) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 510  :     size_t ret;
; 511  : 
; 512  :     if ((buf == NULL) || (len < 0)) return(-1);

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufGrow
	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN2@xmlBufGrow
$LN3@xmlBufGrow:
	or	eax, -1
	jmp	SHORT $LN1@xmlBufGrow
$LN2@xmlBufGrow:

; 513  :     if (len == 0)

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN4@xmlBufGrow

; 514  :         return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlBufGrow
$LN4@xmlBufGrow:

; 515  :     ret = xmlBufGrowInternal(buf, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufGrowInternal
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 516  :     if (buf->error != 0)

	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN5@xmlBufGrow

; 517  :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlBufGrow
$LN5@xmlBufGrow:

; 518  :     return((int) ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlBufGrow:

; 519  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufGrow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufEmpty
_TEXT	SEGMENT
_start_buf$1 = -4					; size = 4
_buf$ = 8						; size = 4
_xmlBufEmpty PROC					; COMDAT

; 355  : xmlBufEmpty(xmlBufPtr buf) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 356  :     if ((buf == NULL) || (buf->error != 0)) return;

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufEmpt
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufEmpt
$LN3@xmlBufEmpt:
	jmp	$LN1@xmlBufEmpt
$LN2@xmlBufEmpt:

; 357  :     if (buf->content == NULL) return;

	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN4@xmlBufEmpt
	jmp	$LN1@xmlBufEmpt
$LN4@xmlBufEmpt:

; 358  :     CHECK_COMPAT(buf)

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN5@xmlBufEmpt
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN5@xmlBufEmpt
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+24], edx
$LN5@xmlBufEmpt:
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN7@xmlBufEmpt
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+4], 2147483647		; 7fffffffH
	jae	SHORT $LN7@xmlBufEmpt
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+20], eax
$LN7@xmlBufEmpt:

; 359  :     buf->use = 0;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 360  :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) {

	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+12], 2
	jne	SHORT $LN9@xmlBufEmpt

; 361  :         buf->content = BAD_CAST "";

	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN10@xmlBufEmpt
$LN9@xmlBufEmpt:

; 362  :     } else if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&

	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+12], 3
	jne	SHORT $LN11@xmlBufEmpt
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN11@xmlBufEmpt

; 363  :                (buf->contentIO != NULL)) {
; 364  :         size_t start_buf = buf->content - buf->contentIO;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _start_buf$1[ebp], edx

; 365  : 
; 366  : 	buf->size += start_buf;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, DWORD PTR _start_buf$1[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 367  :         buf->content = buf->contentIO;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax], edx

; 368  :         buf->content[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [ecx+eax], 0

; 369  :     } else {

	jmp	SHORT $LN10@xmlBufEmpt
$LN11@xmlBufEmpt:

; 370  :         buf->content[0] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [edx+ecx], 0
$LN10@xmlBufEmpt:

; 371  :     }
; 372  :     UPDATE_COMPAT(buf)

	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+24], 2147483647		; 7fffffffH
	jae	SHORT $LN13@xmlBufEmpt
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN14@xmlBufEmpt
$LN13@xmlBufEmpt:
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax+8], 2147483647		; 7fffffffH
$LN14@xmlBufEmpt:
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+20], 2147483647		; 7fffffffH
	jae	SHORT $LN15@xmlBufEmpt
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN1@xmlBufEmpt
$LN15@xmlBufEmpt:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+4], 2147483647		; 7fffffffH
$LN1@xmlBufEmpt:

; 373  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufEmpty ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufFree
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufFree PROC					; COMDAT

; 329  : xmlBufFree(xmlBufPtr buf) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 330  :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN2@xmlBufFree

; 331  : #ifdef DEBUG_BUFFER
; 332  :         xmlGenericError(xmlGenericErrorContext,
; 333  : 		"xmlBufFree: buf == NULL\n");
; 334  : #endif
; 335  : 	return;

	jmp	SHORT $LN1@xmlBufFree
$LN2@xmlBufFree:

; 336  :     }
; 337  : 
; 338  :     if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+12], 3
	jne	SHORT $LN3@xmlBufFree
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN3@xmlBufFree

; 339  :         (buf->contentIO != NULL)) {
; 340  :         xmlFree(buf->contentIO);

	mov	esi, esp
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN4@xmlBufFree
$LN3@xmlBufFree:

; 341  :     } else if ((buf->content != NULL) &&

	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN4@xmlBufFree
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+12], 2
	je	SHORT $LN4@xmlBufFree

; 342  :         (buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE)) {
; 343  :         xmlFree(buf->content);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlBufFree:

; 344  :     }
; 345  :     xmlFree(buf);

	mov	esi, esp
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlBufFree:

; 346  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufGetAllocationScheme
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufGetAllocationScheme PROC				; COMDAT

; 267  : xmlBufGetAllocationScheme(xmlBufPtr buf) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 268  :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN2@xmlBufGetA

; 269  : #ifdef DEBUG_BUFFER
; 270  :         xmlGenericError(xmlGenericErrorContext,
; 271  : 		"xmlBufGetAllocationScheme: buf == NULL\n");
; 272  : #endif
; 273  :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlBufGetA
$LN2@xmlBufGetA:

; 274  :     }
; 275  :     return(buf->alloc);

	mov	eax, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [eax+12]
$LN1@xmlBufGetA:

; 276  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufGetAllocationScheme ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufSetAllocationScheme
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_scheme$ = 12						; size = 4
_xmlBufSetAllocationScheme PROC				; COMDAT

; 289  :                           xmlBufferAllocationScheme scheme) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 290  :     if ((buf == NULL) || (buf->error != 0)) {

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufSetA
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufSetA
$LN3@xmlBufSetA:

; 291  : #ifdef DEBUG_BUFFER
; 292  :         xmlGenericError(xmlGenericErrorContext,
; 293  : 		"xmlBufSetAllocationScheme: buf == NULL or in error\n");
; 294  : #endif
; 295  :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlBufSetA
$LN2@xmlBufSetA:

; 296  :     }
; 297  :     if ((buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) ||

	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+12], 2
	je	SHORT $LN5@xmlBufSetA
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+12], 3
	jne	SHORT $LN4@xmlBufSetA
$LN5@xmlBufSetA:

; 298  :         (buf->alloc == XML_BUFFER_ALLOC_IO))
; 299  :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlBufSetA
$LN4@xmlBufSetA:

; 300  :     if ((scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||
; 301  :         (scheme == XML_BUFFER_ALLOC_EXACT) ||
; 302  :         (scheme == XML_BUFFER_ALLOC_HYBRID) ||
; 303  :         (scheme == XML_BUFFER_ALLOC_IMMUTABLE) ||

	cmp	DWORD PTR _scheme$[ebp], 0
	je	SHORT $LN7@xmlBufSetA
	cmp	DWORD PTR _scheme$[ebp], 1
	je	SHORT $LN7@xmlBufSetA
	cmp	DWORD PTR _scheme$[ebp], 4
	je	SHORT $LN7@xmlBufSetA
	cmp	DWORD PTR _scheme$[ebp], 2
	je	SHORT $LN7@xmlBufSetA
	cmp	DWORD PTR _scheme$[ebp], 5
	jne	SHORT $LN6@xmlBufSetA
$LN7@xmlBufSetA:

; 304  : 	(scheme == XML_BUFFER_ALLOC_BOUNDED)) {
; 305  : 	buf->alloc = scheme;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _scheme$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 306  :         if (buf->buffer)

	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN8@xmlBufSetA

; 307  :             buf->buffer->alloc = scheme;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _scheme$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN8@xmlBufSetA:

; 308  :         return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlBufSetA
$LN6@xmlBufSetA:

; 309  :     }
; 310  :     /*
; 311  :      * Switching a buffer ALLOC_IO has the side effect of initializing
; 312  :      * the contentIO field with the current content
; 313  :      */
; 314  :     if (scheme == XML_BUFFER_ALLOC_IO) {

	cmp	DWORD PTR _scheme$[ebp], 3
	jne	SHORT $LN9@xmlBufSetA

; 315  :         buf->alloc = XML_BUFFER_ALLOC_IO;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax+12], 3

; 316  :         buf->contentIO = buf->content;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+16], eax
$LN9@xmlBufSetA:

; 317  :     }
; 318  :     return(-1);

	or	eax, -1
$LN1@xmlBufSetA:

; 319  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufSetAllocationScheme ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufCreateStatic
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_mem$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlBufCreateStatic PROC				; COMDAT

; 231  : xmlBufCreateStatic(void *mem, size_t size) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 232  :     xmlBufPtr ret;
; 233  : 
; 234  :     if (mem == NULL)

	cmp	DWORD PTR _mem$[ebp], 0
	jne	SHORT $LN2@xmlBufCrea

; 235  :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlBufCrea
$LN2@xmlBufCrea:

; 236  : 
; 237  :     ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));

	mov	esi, esp
	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 238  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN3@xmlBufCrea

; 239  : 	xmlBufMemoryError(NULL, "creating buffer");

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	0
	call	_xmlBufMemoryError
	add	esp, 8

; 240  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlBufCrea
$LN3@xmlBufCrea:

; 241  :     }
; 242  :     if (size < INT_MAX) {

	cmp	DWORD PTR _size$[ebp], 2147483647	; 7fffffffH
	jae	SHORT $LN4@xmlBufCrea

; 243  :         ret->compat_use = size;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 244  :         ret->compat_size = size;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx+8], eax

; 245  :     } else {

	jmp	SHORT $LN5@xmlBufCrea
$LN4@xmlBufCrea:

; 246  :         ret->compat_use = INT_MAX;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+4], 2147483647		; 7fffffffH

; 247  :         ret->compat_size = INT_MAX;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+8], 2147483647		; 7fffffffH
$LN5@xmlBufCrea:

; 248  :     }
; 249  :     ret->use = size;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 250  :     ret->size = size;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx+24], eax

; 251  :     ret->alloc = XML_BUFFER_ALLOC_IMMUTABLE;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+12], 2

; 252  :     ret->content = (xmlChar *) mem;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [edx], eax

; 253  :     ret->error = 0;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 254  :     ret->buffer = NULL;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+28], 0

; 255  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlBufCrea:

; 256  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufCreateStatic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufCreateSize
_TEXT	SEGMENT
tv78 = -8						; size = 4
_ret$ = -4						; size = 4
_size$ = 8						; size = 4
_xmlBufCreateSize PROC					; COMDAT

; 156  : xmlBufCreateSize(size_t size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 157  :     xmlBufPtr ret;
; 158  : 
; 159  :     ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));

	mov	esi, esp
	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 160  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlBufCrea

; 161  : 	xmlBufMemoryError(NULL, "creating buffer");

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	0
	call	_xmlBufMemoryError
	add	esp, 8

; 162  :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlBufCrea
$LN2@xmlBufCrea:

; 163  :     }
; 164  :     ret->compat_use = 0;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+4], 0

; 165  :     ret->use = 0;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 166  :     ret->error = 0;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+32], 0

; 167  :     ret->buffer = NULL;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+28], 0

; 168  :     ret->alloc = xmlBufferAllocScheme;

	call	___xmlBufferAllocScheme
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+12], edx

; 169  :     ret->size = (size ? size+2 : 0);         /* +1 for ending null */

	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN7@xmlBufCrea
	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 2
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN8@xmlBufCrea
$LN7@xmlBufCrea:
	mov	DWORD PTR tv78[ebp], 0
$LN8@xmlBufCrea:
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR [ecx+24], edx

; 170  :     ret->compat_size = (int) ret->size;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+8], edx

; 171  :     if (ret->size){

	mov	eax, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN3@xmlBufCrea

; 172  :         ret->content = (xmlChar *) xmlMallocAtomic(ret->size * sizeof(xmlChar));

	mov	esi, esp
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx], eax

; 173  :         if (ret->content == NULL) {

	mov	edx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN5@xmlBufCrea

; 174  : 	    xmlBufMemoryError(ret, "creating buffer");

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlBufMemoryError
	add	esp, 8

; 175  :             xmlFree(ret);

	mov	esi, esp
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 176  :             return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlBufCrea
$LN5@xmlBufCrea:

; 177  :         }
; 178  :         ret->content[0] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [eax+edx], 0

; 179  :     } else

	jmp	SHORT $LN4@xmlBufCrea
$LN3@xmlBufCrea:

; 180  : 	ret->content = NULL;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax], 0
$LN4@xmlBufCrea:

; 181  :     ret->contentIO = NULL;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 182  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlBufCrea:

; 183  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufCreateSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufCreate
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_xmlBufCreate PROC					; COMDAT

; 122  : xmlBufCreate(void) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 123  :     xmlBufPtr ret;
; 124  : 
; 125  :     ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));

	mov	esi, esp
	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 126  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlBufCrea

; 127  : 	xmlBufMemoryError(NULL, "creating buffer");

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	0
	call	_xmlBufMemoryError
	add	esp, 8

; 128  :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlBufCrea
$LN2@xmlBufCrea:

; 129  :     }
; 130  :     ret->compat_use = 0;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+4], 0

; 131  :     ret->use = 0;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 132  :     ret->error = 0;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+32], 0

; 133  :     ret->buffer = NULL;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+28], 0

; 134  :     ret->size = xmlDefaultBufferSize;

	call	___xmlDefaultBufferSize
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+24], edx

; 135  :     ret->compat_size = xmlDefaultBufferSize;

	call	___xmlDefaultBufferSize
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+8], edx

; 136  :     ret->alloc = xmlBufferAllocScheme;

	call	___xmlBufferAllocScheme
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+12], edx

; 137  :     ret->content = (xmlChar *) xmlMallocAtomic(ret->size * sizeof(xmlChar));

	mov	esi, esp
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx], eax

; 138  :     if (ret->content == NULL) {

	mov	eax, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@xmlBufCrea

; 139  : 	xmlBufMemoryError(ret, "creating buffer");

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlBufMemoryError
	add	esp, 8

; 140  : 	xmlFree(ret);

	mov	esi, esp
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 141  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlBufCrea
$LN3@xmlBufCrea:

; 142  :     }
; 143  :     ret->content[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [ecx+eax], 0

; 144  :     ret->contentIO = NULL;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 145  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlBufCrea:

; 146  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufCreate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufShrink
_TEXT	SEGMENT
_start_buf$1 = -4					; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlBufShrink PROC					; COMDAT

; 388  : xmlBufShrink(xmlBufPtr buf, size_t len) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 389  :     if ((buf == NULL) || (buf->error != 0)) return(0);

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufShri
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufShri
$LN3@xmlBufShri:
	xor	eax, eax
	jmp	$LN1@xmlBufShri
$LN2@xmlBufShri:

; 390  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufShri
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufShri
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufShri:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufShri
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufShri
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufShri:

; 391  :     if (len == 0) return(0);

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN8@xmlBufShri
	xor	eax, eax
	jmp	$LN1@xmlBufShri
$LN8@xmlBufShri:

; 392  :     if (len > buf->use) return(0);

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jbe	SHORT $LN9@xmlBufShri
	xor	eax, eax
	jmp	$LN1@xmlBufShri
$LN9@xmlBufShri:

; 393  : 
; 394  :     buf->use -= len;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 395  :     if ((buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) ||

	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+12], 2
	je	SHORT $LN12@xmlBufShri
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+12], 3
	jne	$LN10@xmlBufShri
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	$LN10@xmlBufShri
$LN12@xmlBufShri:

; 396  :         ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL))) {
; 397  : 	/*
; 398  : 	 * we just move the content pointer, but also make sure
; 399  : 	 * the perceived buffer size has shrinked accordingly
; 400  : 	 */
; 401  :         buf->content += len;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx], eax

; 402  : 	buf->size -= len;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+24]
	sub	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 403  : 
; 404  :         /*
; 405  : 	 * sometimes though it maybe be better to really shrink
; 406  : 	 * on IO buffers
; 407  : 	 */
; 408  : 	if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {

	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+12], 3
	jne	SHORT $LN13@xmlBufShri
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN13@xmlBufShri

; 409  : 	    size_t start_buf = buf->content - buf->contentIO;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _start_buf$1[ebp], eax

; 410  : 	    if (start_buf >= buf->size) {

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _start_buf$1[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jb	SHORT $LN13@xmlBufShri

; 411  : 		memmove(buf->contentIO, &buf->content[0], buf->use);

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 412  : 		buf->content = buf->contentIO;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx], eax

; 413  : 		buf->content[buf->use] = 0;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+edx], 0

; 414  : 		buf->size += start_buf;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, DWORD PTR _start_buf$1[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN13@xmlBufShri:

; 415  : 	    }
; 416  : 	}
; 417  :     } else {

	jmp	SHORT $LN11@xmlBufShri
$LN10@xmlBufShri:

; 418  : 	memmove(buf->content, &buf->content[len], buf->use);

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 419  : 	buf->content[buf->use] = 0;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+eax], 0
$LN11@xmlBufShri:

; 420  :     }
; 421  :     UPDATE_COMPAT(buf)

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+24], 2147483647		; 7fffffffH
	jae	SHORT $LN15@xmlBufShri
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN16@xmlBufShri
$LN15@xmlBufShri:
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
$LN16@xmlBufShri:
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+20], 2147483647		; 7fffffffH
	jae	SHORT $LN17@xmlBufShri
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN18@xmlBufShri
$LN17@xmlBufShri:
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax+4], 2147483647		; 7fffffffH
$LN18@xmlBufShri:

; 422  :     return(len);

	mov	eax, DWORD PTR _len$[ebp]
$LN1@xmlBufShri:

; 423  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufShrink ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufUse
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufUse PROC						; COMDAT

; 688  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 689  :     if ((!buf) || (buf->error))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufUse
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufUse
$LN3@xmlBufUse:

; 690  :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@xmlBufUse
$LN2@xmlBufUse:

; 691  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufUse
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufUse
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufUse:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufUse
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufUse
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufUse:

; 692  : 
; 693  :     return(buf->use);

	mov	eax, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [eax+20]
$LN1@xmlBufUse:

; 694  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufUse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufEnd
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufEnd PROC						; COMDAT

; 601  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 602  :     if ((!buf) || (buf->error))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufEnd
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufEnd
$LN3@xmlBufEnd:

; 603  :         return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@xmlBufEnd
$LN2@xmlBufEnd:

; 604  :     CHECK_COMPAT(buf)

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN4@xmlBufEnd
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+8], 2147483647		; 7fffffffH
	jae	SHORT $LN4@xmlBufEnd
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+24], ecx
$LN4@xmlBufEnd:
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN6@xmlBufEnd
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+4], 2147483647		; 7fffffffH
	jae	SHORT $LN6@xmlBufEnd
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
$LN6@xmlBufEnd:

; 605  : 
; 606  :     return(&buf->content[buf->use]);

	mov	eax, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR [ecx+20]
$LN1@xmlBufEnd:

; 607  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufEnd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\buf.c
;	COMDAT _xmlBufContent
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufContent PROC					; COMDAT

; 583  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4FDA1B3E_buf@c
	call	@__CheckForDebuggerJustMyCode@4

; 584  :     if ((!buf) || (buf->error))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlBufCont
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@xmlBufCont
$LN3@xmlBufCont:

; 585  :         return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@xmlBufCont
$LN2@xmlBufCont:

; 586  : 
; 587  :     return(buf->content);

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [ecx]
$LN1@xmlBufCont:

; 588  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBufContent ENDP
_TEXT	ENDS
END
