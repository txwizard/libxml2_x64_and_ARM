; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xmlsave.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__BAD788A4_xmlsave@c DB 01H
msvcjmc	ENDS
PUBLIC	_xmlAttrSerializeTxtContent
PUBLIC	_xmlDocDumpFormatMemory
PUBLIC	_xmlDocDumpMemory
PUBLIC	_xmlDocDumpMemoryEnc
PUBLIC	_xmlDocDumpFormatMemoryEnc
PUBLIC	_xmlDocFormatDump
PUBLIC	_xmlDocDump
PUBLIC	_xmlElemDump
PUBLIC	_xmlSaveFile
PUBLIC	_xmlSaveFormatFile
PUBLIC	_xmlBufNodeDump
PUBLIC	_xmlNodeDump
PUBLIC	_xmlSaveFileTo
PUBLIC	_xmlSaveFormatFileTo
PUBLIC	_xmlNodeDumpOutput
PUBLIC	_xmlSaveFormatFileEnc
PUBLIC	_xmlSaveFileEnc
PUBLIC	_xmlIsXHTML
PUBLIC	_xmlSaveToFd
PUBLIC	_xmlSaveToFilename
PUBLIC	_xmlSaveToBuffer
PUBLIC	_xmlSaveToIO
PUBLIC	_xmlSaveDoc
PUBLIC	_xmlSaveTree
PUBLIC	_xmlSaveFlush
PUBLIC	_xmlSaveClose
PUBLIC	_xmlSaveSetEscape
PUBLIC	_xmlSaveSetAttrEscape
PUBLIC	_xmlBufAttrSerializeTxtContent
PUBLIC	_xmlBufDumpNotationTable
PUBLIC	_xmlBufDumpElementDecl
PUBLIC	_xmlBufDumpAttributeDecl
PUBLIC	_xmlBufDumpEntityDecl
PUBLIC	_xmlNsListDumpOutput
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0CB@LIHKBLCO@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Strict?1?1E@ ; `string'
PUBLIC	??_C@_0CD@EONGLKJJ@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Frameset?1@ ; `string'
PUBLIC	??_C@_0CH@FHDGMIJF@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Transitio@ ; `string'
PUBLIC	??_C@_0DC@BHABDBDI@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@ ; `string'
PUBLIC	??_C@_0DE@CCGEPDJH@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@ ; `string'
PUBLIC	??_C@_0DI@KKENBPON@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@ ; `string'
PUBLIC	??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@ ; `string'
PUBLIC	??_C@_0BJ@HMEJBBPL@invalid?5character?5value?6@	; `string'
PUBLIC	??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BJ@OKGKFHLI@document?5has?5no?5DOCTYPE?6@ ; `string'
PUBLIC	??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@	; `string'
PUBLIC	??_C@_0CH@EAFIMPAL@xmlEscapeEntities?5?3?5char?5out?5of@ ; `string'
PUBLIC	??_C@_0BI@FGAKHCKD@creating?5saving?5context@	; `string'
PUBLIC	??_C@_01HNPIGOCE@?$CG@				; `string'
PUBLIC	??_C@_01ICJEACDI@?$DL@				; `string'
PUBLIC	??_C@_0BJ@ICFHKFLM@creating?5encoding?5buffer@	; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_03PJHHNEEI@xml@				; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_06PNFLLAEF@xmlns?3@			; `string'
PUBLIC	??_C@_05PPEFOGKI@xmlns@				; `string'
PUBLIC	??_C@_01NEMOKFLO@?$DN@				; `string'
PUBLIC	??_C@_0L@JKHDJBPI@?$DM?$CBDOCTYPE?5@		; `string'
PUBLIC	??_C@_08GBBLECIH@?5PUBLIC?5@			; `string'
PUBLIC	??_C@_08PAGGLANP@?5SYSTEM?5@			; `string'
PUBLIC	??_C@_01PPODPGHN@?$DO@				; `string'
PUBLIC	??_C@_03OEIPKGAG@?5?$FL?6@			; `string'
PUBLIC	??_C@_02CFBPIAHD@?$FN?$DO@			; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_02ILLPBGAO@?$DN?$CC@			; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC@				; `string'
PUBLIC	??_C@_04DBLPJNAF@HTML@				; `string'
PUBLIC	??_C@_02HFBBBACF@?$DM?$DP@			; `string'
PUBLIC	??_C@_02GOEMJPDN@?$DP?$DO@			; `string'
PUBLIC	??_C@_04FFDNBKGC@?$DM?$CB?9?9@			; `string'
PUBLIC	??_C@_03PNLDJJMO@?9?9?$DO@			; `string'
PUBLIC	??_C@_0N@OGBMJHND@?$DM?$CB?$FLCDATA?$FL?$FN?$FN?$DO@ ; `string'
PUBLIC	??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@		; `string'
PUBLIC	??_C@_03MCHNFBAC@?$FN?$FN?$DO@			; `string'
PUBLIC	??_C@_01MNNFJEPP@?$DM@				; `string'
PUBLIC	??_C@_02HCGKDMEN@?1?$DO@			; `string'
PUBLIC	??_C@_02DPNDACHE@?$DM?1@			; `string'
PUBLIC	??_C@_0P@CNJADHFP@?$DM?$DPxml?5version?$DN@	; `string'
PUBLIC	??_C@_05FLCMBAOK@?$CC1?40?$CC@			; `string'
PUBLIC	??_C@_0L@GJNPICMJ@?5encoding?$DN@		; `string'
PUBLIC	??_C@_0BB@FFDPHLPI@?5standalone?$DN?$CCno?$CC@	; `string'
PUBLIC	??_C@_0BC@MEICOMAE@?5standalone?$DN?$CCyes?$CC@	; `string'
PUBLIC	??_C@_03KCOJOIAE@?$DP?$DO?6@			; `string'
PUBLIC	??_C@_0BN@BMFLMPPL@http?3?1?1www?4w3?4org?11999?1xhtml@ ; `string'
PUBLIC	??_C@_04GOEDGNCF@area@				; `string'
PUBLIC	??_C@_02FGOECCNH@br@				; `string'
PUBLIC	??_C@_04BHIIPFEC@base@				; `string'
PUBLIC	??_C@_08IOLGIJGJ@basefont@			; `string'
PUBLIC	??_C@_03HNOLNALI@col@				; `string'
PUBLIC	??_C@_05MIJNFGED@frame@				; `string'
PUBLIC	??_C@_02FLHDKHAB@hr@				; `string'
PUBLIC	??_C@_03PCCGDNHJ@img@				; `string'
PUBLIC	??_C@_05DFJCHPDH@input@				; `string'
PUBLIC	??_C@_07JMLOFMGP@isindex@			; `string'
PUBLIC	??_C@_04OHHBHOGB@link@				; `string'
PUBLIC	??_C@_04HLJJCGEF@meta@				; `string'
PUBLIC	??_C@_05LJDNNBIK@param@				; `string'
PUBLIC	??_C@_02EGCJHIOB@id@				; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_04IOHABJIC@lang@				; `string'
PUBLIC	??_C@_01MCMALHOG@a@				; `string'
PUBLIC	??_C@_01JBBJJEPG@p@				; `string'
PUBLIC	??_C@_03FEJMGOGI@div@				; `string'
PUBLIC	??_C@_03HBNNNHNM@map@				; `string'
PUBLIC	??_C@_06MJBNHHFM@applet@			; `string'
PUBLIC	??_C@_04MLMMMEIO@form@				; `string'
PUBLIC	??_C@_06PKBNCBKI@iframe@			; `string'
PUBLIC	??_C@_05OCPGBOOB@?5id?$DN?$CC@			; `string'
PUBLIC	??_C@_0M@NGPFCPAA@?5xml?3lang?$DN?$CC@		; `string'
PUBLIC	??_C@_07OHOHIONL@?5lang?$DN?$CC@		; `string'
PUBLIC	??_C@_04PNIFHPHN@html@				; `string'
PUBLIC	??_C@_0CG@NOKOIAPK@?5xmlns?$DN?$CChttp?3?1?1www?4w3?4org?11999?1@ ; `string'
PUBLIC	??_C@_04NEODDMOL@head@				; `string'
PUBLIC	??_C@_0L@NALBGOHO@http?9equiv@			; `string'
PUBLIC	??_C@_0N@LAFFMKKA@Content?9Type@		; `string'
PUBLIC	??_C@_03MFNJFHN@?5?1?$DO@			; `string'
PUBLIC	??_C@_0DN@ILJMDLKG@?$DMmeta?5http?9equiv?$DN?$CCContent?9Type?$CC@ ; `string'
PUBLIC	??_C@_05EGJIMALK@UTF?98@			; `string'
PUBLIC	??_C@_04FADKMBBI@?$CC?5?1?$DO@			; `string'
PUBLIC	??_C@_05EJOHHIMP@?$CG?$CD10?$DL@		; `string'
PUBLIC	??_C@_05ELKBMGJG@?$CG?$CD13?$DL@		; `string'
PUBLIC	??_C@_04NCNDODLB@?$CG?$CD9?$DL@			; `string'
PUBLIC	??_C@_06DDLNFFBN@?$CGquot?$DL@			; `string'
PUBLIC	??_C@_04GJOGLFEJ@?$CGlt?$DL@			; `string'
PUBLIC	??_C@_04LOOHDCEI@?$CGgt?$DL@			; `string'
PUBLIC	??_C@_05JKJFEODM@?$CGamp?$DL@			; `string'
PUBLIC	??_C@_0BA@GIGPFFIA@creating?5buffer@		; `string'
PUBLIC	??_C@_0BA@CMJGPMBH@creating?5output@		; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrcasecmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlBufContent:PROC
EXTRN	_xmlBufUse:PROC
EXTRN	_xmlBufferCreate:PROC
EXTRN	_xmlGetIntSubset:PROC
EXTRN	_xmlNewText:PROC
EXTRN	_xmlFreeNode:PROC
EXTRN	_xmlGetProp:PROC
EXTRN	_xmlGetCompressMode:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	_xmlDumpNotationTable:PROC
EXTRN	_xmlDumpElementDecl:PROC
EXTRN	_xmlDumpAttributeDecl:PROC
EXTRN	_xmlDumpEntityDecl:PROC
EXTRN	_xmlFindCharEncodingHandler:PROC
EXTRN	_xmlParseCharEncoding:PROC
EXTRN	_xmlCharEncCloseFunc:PROC
EXTRN	_xmlAllocOutputBuffer:PROC
EXTRN	_xmlOutputBufferCreateFilename:PROC
EXTRN	_xmlOutputBufferCreateFile:PROC
EXTRN	_xmlOutputBufferCreateBuffer:PROC
EXTRN	_xmlOutputBufferCreateFd:PROC
EXTRN	_xmlOutputBufferCreateIO:PROC
EXTRN	_xmlOutputBufferWrite:PROC
EXTRN	_xmlOutputBufferWriteString:PROC
EXTRN	_xmlOutputBufferWriteEscape:PROC
EXTRN	_xmlOutputBufferFlush:PROC
EXTRN	_xmlOutputBufferClose:PROC
EXTRN	_xmlInitParser:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	___xmlIndentTreeOutput:PROC
EXTRN	___xmlTreeIndentString:PROC
EXTRN	___xmlSaveNoEmptyTags:PROC
EXTRN	_htmlGetMetaEncoding:PROC
EXTRN	_htmlSetMetaEncoding:PROC
EXTRN	_htmlNodeDumpFormatOutput:PROC
EXTRN	_htmlDocContentDumpFormatOutput:PROC
EXTRN	_htmlNodeDumpOutput:PROC
EXTRN	_htmlIsBooleanAttr:PROC
EXTRN	_xmlBufCreate:PROC
EXTRN	_xmlBufSetAllocationScheme:PROC
EXTRN	_xmlBufGetAllocationScheme:PROC
EXTRN	_xmlBufFree:PROC
EXTRN	_xmlBufAdd:PROC
EXTRN	_xmlBufWriteQuotedString:PROC
EXTRN	_xmlBufFromBuffer:PROC
EXTRN	_xmlBufBackToBuffer:PROC
EXTRN	_xmlBufMergeBuffer:PROC
EXTRN	_xmlCharEncOutput:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_xmlStringText:BYTE
EXTRN	_xmlStringTextNoenc:BYTE
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BA@CMJGPMBH@creating?5output@
CONST	SEGMENT
??_C@_0BA@CMJGPMBH@creating?5output@ DB 'creating output', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GIGPFFIA@creating?5buffer@
CONST	SEGMENT
??_C@_0BA@GIGPFFIA@creating?5buffer@ DB 'creating buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKJFEODM@?$CGamp?$DL@
CONST	SEGMENT
??_C@_05JKJFEODM@?$CGamp?$DL@ DB '&amp;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOOHDCEI@?$CGgt?$DL@
CONST	SEGMENT
??_C@_04LOOHDCEI@?$CGgt?$DL@ DB '&gt;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GJOGLFEJ@?$CGlt?$DL@
CONST	SEGMENT
??_C@_04GJOGLFEJ@?$CGlt?$DL@ DB '&lt;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DDLNFFBN@?$CGquot?$DL@
CONST	SEGMENT
??_C@_06DDLNFFBN@?$CGquot?$DL@ DB '&quot;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NCNDODLB@?$CG?$CD9?$DL@
CONST	SEGMENT
??_C@_04NCNDODLB@?$CG?$CD9?$DL@ DB '&#9;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ELKBMGJG@?$CG?$CD13?$DL@
CONST	SEGMENT
??_C@_05ELKBMGJG@?$CG?$CD13?$DL@ DB '&#13;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05EJOHHIMP@?$CG?$CD10?$DL@
CONST	SEGMENT
??_C@_05EJOHHIMP@?$CG?$CD10?$DL@ DB '&#10;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04FADKMBBI@?$CC?5?1?$DO@
CONST	SEGMENT
??_C@_04FADKMBBI@?$CC?5?1?$DO@ DB '" />', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EGJIMALK@UTF?98@
CONST	SEGMENT
??_C@_05EGJIMALK@UTF?98@ DB 'UTF-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@ILJMDLKG@?$DMmeta?5http?9equiv?$DN?$CCContent?9Type?$CC@
CONST	SEGMENT
??_C@_0DN@ILJMDLKG@?$DMmeta?5http?9equiv?$DN?$CCContent?9Type?$CC@ DB '<m'
	DB	'eta http-equiv="Content-Type" content="text/html; charset=', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03MFNJFHN@?5?1?$DO@
CONST	SEGMENT
??_C@_03MFNJFHN@?5?1?$DO@ DB ' />', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LAFFMKKA@Content?9Type@
CONST	SEGMENT
??_C@_0N@LAFFMKKA@Content?9Type@ DB 'Content-Type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NALBGOHO@http?9equiv@
CONST	SEGMENT
??_C@_0L@NALBGOHO@http?9equiv@ DB 'http-equiv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04NEODDMOL@head@
CONST	SEGMENT
??_C@_04NEODDMOL@head@ DB 'head', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NOKOIAPK@?5xmlns?$DN?$CChttp?3?1?1www?4w3?4org?11999?1@
CONST	SEGMENT
??_C@_0CG@NOKOIAPK@?5xmlns?$DN?$CChttp?3?1?1www?4w3?4org?11999?1@ DB ' xm'
	DB	'lns="http://www.w3.org/1999/xhtml"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNIFHPHN@html@
CONST	SEGMENT
??_C@_04PNIFHPHN@html@ DB 'html', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07OHOHIONL@?5lang?$DN?$CC@
CONST	SEGMENT
??_C@_07OHOHIONL@?5lang?$DN?$CC@ DB ' lang="', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NGPFCPAA@?5xml?3lang?$DN?$CC@
CONST	SEGMENT
??_C@_0M@NGPFCPAA@?5xml?3lang?$DN?$CC@ DB ' xml:lang="', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OCPGBOOB@?5id?$DN?$CC@
CONST	SEGMENT
??_C@_05OCPGBOOB@?5id?$DN?$CC@ DB ' id="', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PKBNCBKI@iframe@
CONST	SEGMENT
??_C@_06PKBNCBKI@iframe@ DB 'iframe', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLMMMEIO@form@
CONST	SEGMENT
??_C@_04MLMMMEIO@form@ DB 'form', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06MJBNHHFM@applet@
CONST	SEGMENT
??_C@_06MJBNHHFM@applet@ DB 'applet', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HBNNNHNM@map@
CONST	SEGMENT
??_C@_03HBNNNHNM@map@ DB 'map', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FEJMGOGI@div@
CONST	SEGMENT
??_C@_03FEJMGOGI@div@ DB 'div', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JBBJJEPG@p@
CONST	SEGMENT
??_C@_01JBBJJEPG@p@ DB 'p', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a@
CONST	SEGMENT
??_C@_01MCMALHOG@a@ DB 'a', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04IOHABJIC@lang@
CONST	SEGMENT
??_C@_04IOHABJIC@lang@ DB 'lang', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGCJHIOB@id@
CONST	SEGMENT
??_C@_02EGCJHIOB@id@ DB 'id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LJDNNBIK@param@
CONST	SEGMENT
??_C@_05LJDNNBIK@param@ DB 'param', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HLJJCGEF@meta@
CONST	SEGMENT
??_C@_04HLJJCGEF@meta@ DB 'meta', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHHBHOGB@link@
CONST	SEGMENT
??_C@_04OHHBHOGB@link@ DB 'link', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07JMLOFMGP@isindex@
CONST	SEGMENT
??_C@_07JMLOFMGP@isindex@ DB 'isindex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DFJCHPDH@input@
CONST	SEGMENT
??_C@_05DFJCHPDH@input@ DB 'input', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PCCGDNHJ@img@
CONST	SEGMENT
??_C@_03PCCGDNHJ@img@ DB 'img', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FLHDKHAB@hr@
CONST	SEGMENT
??_C@_02FLHDKHAB@hr@ DB 'hr', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MIJNFGED@frame@
CONST	SEGMENT
??_C@_05MIJNFGED@frame@ DB 'frame', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HNOLNALI@col@
CONST	SEGMENT
??_C@_03HNOLNALI@col@ DB 'col', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08IOLGIJGJ@basefont@
CONST	SEGMENT
??_C@_08IOLGIJGJ@basefont@ DB 'basefont', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BHIIPFEC@base@
CONST	SEGMENT
??_C@_04BHIIPFEC@base@ DB 'base', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FGOECCNH@br@
CONST	SEGMENT
??_C@_02FGOECCNH@br@ DB 'br', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GOEDGNCF@area@
CONST	SEGMENT
??_C@_04GOEDGNCF@area@ DB 'area', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BMFLMPPL@http?3?1?1www?4w3?4org?11999?1xhtml@
CONST	SEGMENT
??_C@_0BN@BMFLMPPL@http?3?1?1www?4w3?4org?11999?1xhtml@ DB 'http://www.w3'
	DB	'.org/1999/xhtml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KCOJOIAE@?$DP?$DO?6@
CONST	SEGMENT
??_C@_03KCOJOIAE@?$DP?$DO?6@ DB '?>', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MEICOMAE@?5standalone?$DN?$CCyes?$CC@
CONST	SEGMENT
??_C@_0BC@MEICOMAE@?5standalone?$DN?$CCyes?$CC@ DB ' standalone="yes"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FFDPHLPI@?5standalone?$DN?$CCno?$CC@
CONST	SEGMENT
??_C@_0BB@FFDPHLPI@?5standalone?$DN?$CCno?$CC@ DB ' standalone="no"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GJNPICMJ@?5encoding?$DN@
CONST	SEGMENT
??_C@_0L@GJNPICMJ@?5encoding?$DN@ DB ' encoding=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FLCMBAOK@?$CC1?40?$CC@
CONST	SEGMENT
??_C@_05FLCMBAOK@?$CC1?40?$CC@ DB '"1.0"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CNJADHFP@?$DM?$DPxml?5version?$DN@
CONST	SEGMENT
??_C@_0P@CNJADHFP@?$DM?$DPxml?5version?$DN@ DB '<?xml version=', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPNDACHE@?$DM?1@
CONST	SEGMENT
??_C@_02DPNDACHE@?$DM?1@ DB '</', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HCGKDMEN@?1?$DO@
CONST	SEGMENT
??_C@_02HCGKDMEN@?1?$DO@ DB '/>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01MNNFJEPP@?$DM@
CONST	SEGMENT
??_C@_01MNNFJEPP@?$DM@ DB '<', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCHNFBAC@?$FN?$FN?$DO@
CONST	SEGMENT
??_C@_03MCHNFBAC@?$FN?$FN?$DO@ DB ']]>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@
CONST	SEGMENT
??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@ DB '<![CDATA[', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OGBMJHND@?$DM?$CB?$FLCDATA?$FL?$FN?$FN?$DO@
CONST	SEGMENT
??_C@_0N@OGBMJHND@?$DM?$CB?$FLCDATA?$FL?$FN?$FN?$DO@ DB '<![CDATA[]]>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03PNLDJJMO@?9?9?$DO@
CONST	SEGMENT
??_C@_03PNLDJJMO@?9?9?$DO@ DB '-->', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FFDNBKGC@?$DM?$CB?9?9@
CONST	SEGMENT
??_C@_04FFDNBKGC@?$DM?$CB?9?9@ DB '<!--', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GOEMJPDN@?$DP?$DO@
CONST	SEGMENT
??_C@_02GOEMJPDN@?$DP?$DO@ DB '?>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HFBBBACF@?$DM?$DP@
CONST	SEGMENT
??_C@_02HFBBBACF@?$DM?$DP@ DB '<?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DBLPJNAF@HTML@
CONST	SEGMENT
??_C@_04DBLPJNAF@HTML@ DB 'HTML', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ILLPBGAO@?$DN?$CC@
CONST	SEGMENT
??_C@_02ILLPBGAO@?$DN?$CC@ DB '="', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CFBPIAHD@?$FN?$DO@
CONST	SEGMENT
??_C@_02CFBPIAHD@?$FN?$DO@ DB ']>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OEIPKGAG@?5?$FL?6@
CONST	SEGMENT
??_C@_03OEIPKGAG@?5?$FL?6@ DB ' [', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01PPODPGHN@?$DO@
CONST	SEGMENT
??_C@_01PPODPGHN@?$DO@ DB '>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08PAGGLANP@?5SYSTEM?5@
CONST	SEGMENT
??_C@_08PAGGLANP@?5SYSTEM?5@ DB ' SYSTEM ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GBBLECIH@?5PUBLIC?5@
CONST	SEGMENT
??_C@_08GBBLECIH@?5PUBLIC?5@ DB ' PUBLIC ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JKHDJBPI@?$DM?$CBDOCTYPE?5@
CONST	SEGMENT
??_C@_0L@JKHDJBPI@?$DM?$CBDOCTYPE?5@ DB '<!DOCTYPE ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NEMOKFLO@?$DN@
CONST	SEGMENT
??_C@_01NEMOKFLO@?$DN@ DB '=', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPEFOGKI@xmlns@
CONST	SEGMENT
??_C@_05PPEFOGKI@xmlns@ DB 'xmlns', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06PNFLLAEF@xmlns?3@
CONST	SEGMENT
??_C@_06PNFLLAEF@xmlns?3@ DB 'xmlns:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJHHNEEI@xml@
CONST	SEGMENT
??_C@_03PJHHNEEI@xml@ DB 'xml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ICFHKFLM@creating?5encoding?5buffer@
CONST	SEGMENT
??_C@_0BJ@ICFHKFLM@creating?5encoding?5buffer@ DB 'creating encoding buff'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01ICJEACDI@?$DL@
CONST	SEGMENT
??_C@_01ICJEACDI@?$DL@ DB ';', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HNPIGOCE@?$CG@
CONST	SEGMENT
??_C@_01HNPIGOCE@?$CG@ DB '&', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FGAKHCKD@creating?5saving?5context@
CONST	SEGMENT
??_C@_0BI@FGAKHCKD@creating?5saving?5context@ DB 'creating saving context'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EAFIMPAL@xmlEscapeEntities?5?3?5char?5out?5of@
CONST	SEGMENT
??_C@_0CH@EAFIMPAL@xmlEscapeEntities?5?3?5char?5out?5of@ DB 'xmlEscapeEnt'
	DB	'ities : char out of range', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@
CONST	SEGMENT
??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@ DB 'unexpected error numb'
	DB	'er', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OKGKFHLI@document?5has?5no?5DOCTYPE?6@
CONST	SEGMENT
??_C@_0BJ@OKGKFHLI@document?5has?5no?5DOCTYPE?6@ DB 'document has no DOCT'
	DB	'YPE', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@
CONST	SEGMENT
??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@ DB 'unknown encoding %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HMEJBBPL@invalid?5character?5value?6@
CONST	SEGMENT
??_C@_0BJ@HMEJBBPL@invalid?5character?5value?6@ DB 'invalid character val'
	DB	'ue', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@
CONST	SEGMENT
??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@ DB 'string is not in UT'
	DB	'F-8', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@KKENBPON@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@
CONST	SEGMENT
??_C@_0DI@KKENBPON@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@ DB 'http://ww'
	DB	'w.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@CCGEPDJH@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@
CONST	SEGMENT
??_C@_0DE@CCGEPDJH@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@ DB 'http://ww'
	DB	'w.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@BHABDBDI@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@
CONST	SEGMENT
??_C@_0DC@BHABDBDI@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@ DB 'http://ww'
	DB	'w.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FHDGMIJF@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Transitio@
CONST	SEGMENT
??_C@_0CH@FHDGMIJF@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Transitio@ DB '-//W3C//'
	DB	'DTD XHTML 1.0 Transitional//EN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EONGLKJJ@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Frameset?1@
CONST	SEGMENT
??_C@_0CD@EONGLKJJ@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Frameset?1@ DB '-//W3C/'
	DB	'/DTD XHTML 1.0 Frameset//EN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LIHKBLCO@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Strict?1?1E@
CONST	SEGMENT
??_C@_0CB@LIHKBLCO@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Strict?1?1E@ DB '-//W3C'
	DB	'//DTD XHTML 1.0 Strict//EN', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xhtmlNodeListDumpOutput
_TEXT	SEGMENT
tv82 = -8						; size = 4
_buf$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xhtmlNodeListDumpOutput PROC				; COMDAT

; 1417 : xhtmlNodeListDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 1418 :     xmlOutputBufferPtr buf;
; 1419 : 
; 1420 :     if (cur == NULL) return;

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN4@xhtmlNodeL
	jmp	$LN1@xhtmlNodeL
$LN4@xhtmlNodeL:

; 1421 :     buf = ctxt->buf;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _buf$[ebp], ecx
$LN2@xhtmlNodeL:

; 1422 :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN1@xhtmlNodeL

; 1423 : 	if ((ctxt->format == 1) && (xmlIndentTreeOutput) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+40], 1
	jne	SHORT $LN5@xhtmlNodeL
	call	___xmlIndentTreeOutput
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@xhtmlNodeL
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN5@xhtmlNodeL

; 1424 : 	    (cur->type == XML_ELEMENT_NODE))
; 1425 : 	    xmlOutputBufferWrite(buf, ctxt->indent_size *

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+36]
	cmp	eax, DWORD PTR [edx+108]
	jle	SHORT $LN8@xhtmlNodeL
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR tv82[ebp], edx
	jmp	SHORT $LN9@xhtmlNodeL
$LN8@xhtmlNodeL:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR tv82[ebp], ecx
$LN9@xhtmlNodeL:
	mov	edx, DWORD PTR _ctxt$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	imul	ecx, DWORD PTR tv82[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN5@xhtmlNodeL:

; 1426 : 	                         (ctxt->level > ctxt->indent_nr ?
; 1427 : 				  ctxt->indent_nr : ctxt->level),
; 1428 : 				 ctxt->indent);
; 1429 :         xhtmlNodeDumpOutput(ctxt, cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xhtmlNodeDumpOutput
	add	esp, 8

; 1430 : 	if (ctxt->format == 1) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+40], 1
	jne	SHORT $LN6@xhtmlNodeL

; 1431 : 	    xmlOutputBufferWrite(buf, 1, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	1
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN6@xhtmlNodeL:

; 1432 : 	}
; 1433 : 	cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$[ebp], edx

; 1434 :     }

	jmp	$LN2@xhtmlNodeL
$LN1@xhtmlNodeL:

; 1435 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xhtmlNodeListDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xhtmlAttrListDumpOutput
_TEXT	SEGMENT
_buf$ = -24						; size = 4
_parent$ = -20						; size = 4
_id$ = -16						; size = 4
_name$ = -12						; size = 4
_lang$ = -8						; size = 4
_xml_lang$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xhtmlAttrListDumpOutput PROC				; COMDAT

; 1331 : xhtmlAttrListDumpOutput(xmlSaveCtxtPtr ctxt, xmlAttrPtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 1332 :     xmlAttrPtr xml_lang = NULL;

	mov	DWORD PTR _xml_lang$[ebp], 0

; 1333 :     xmlAttrPtr lang = NULL;

	mov	DWORD PTR _lang$[ebp], 0

; 1334 :     xmlAttrPtr name = NULL;

	mov	DWORD PTR _name$[ebp], 0

; 1335 :     xmlAttrPtr id = NULL;

	mov	DWORD PTR _id$[ebp], 0

; 1336 :     xmlNodePtr parent;
; 1337 :     xmlOutputBufferPtr buf;
; 1338 : 
; 1339 :     if (cur == NULL) return;

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN4@xhtmlAttrL
	jmp	$LN1@xhtmlAttrL
$LN4@xhtmlAttrL:

; 1340 :     buf = ctxt->buf;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _buf$[ebp], ecx

; 1341 :     parent = cur->parent;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _parent$[ebp], eax
$LN2@xhtmlAttrL:

; 1342 :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN3@xhtmlAttrL

; 1343 : 	if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST "id")))

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	jne	SHORT $LN5@xhtmlAttrL
	push	OFFSET ??_C@_02EGCJHIOB@id@
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xhtmlAttrL

; 1344 : 	    id = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _id$[ebp], ecx
	jmp	$LN6@xhtmlAttrL
$LN5@xhtmlAttrL:

; 1345 : 	else
; 1346 : 	if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST "name")))

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jne	SHORT $LN7@xhtmlAttrL
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@xhtmlAttrL

; 1347 : 	    name = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _name$[ebp], edx
	jmp	$LN6@xhtmlAttrL
$LN7@xhtmlAttrL:

; 1348 : 	else
; 1349 : 	if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST "lang")))

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN9@xhtmlAttrL
	push	OFFSET ??_C@_04IOHABJIC@lang@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xhtmlAttrL

; 1350 : 	    lang = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _lang$[ebp], eax
	jmp	$LN6@xhtmlAttrL
$LN9@xhtmlAttrL:

; 1351 : 	else
; 1352 : 	if ((cur->ns != NULL) && (xmlStrEqual(cur->name, BAD_CAST "lang")) &&

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN11@xhtmlAttrL
	push	OFFSET ??_C@_04IOHABJIC@lang@
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xhtmlAttrL
	push	OFFSET ??_C@_03PJHHNEEI@xml@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xhtmlAttrL

; 1353 : 	    (xmlStrEqual(cur->ns->prefix, BAD_CAST "xml")))
; 1354 : 	    xml_lang = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _xml_lang$[ebp], ecx
	jmp	$LN6@xhtmlAttrL
$LN11@xhtmlAttrL:

; 1355 : 	else if ((cur->ns == NULL) &&
; 1356 : 		 ((cur->children == NULL) ||
; 1357 : 		  (cur->children->content == NULL) ||
; 1358 : 		  (cur->children->content[0] == 0)) &&

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jne	$LN6@xhtmlAttrL
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN14@xhtmlAttrL
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN14@xhtmlAttrL
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+40]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN6@xhtmlAttrL
$LN14@xhtmlAttrL:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_htmlIsBooleanAttr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@xhtmlAttrL

; 1359 : 		 (htmlIsBooleanAttr(cur->name))) {
; 1360 : 	    if (cur->children != NULL)

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN15@xhtmlAttrL

; 1361 : 		xmlFreeNode(cur->children);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_xmlFreeNode
	add	esp, 4
$LN15@xhtmlAttrL:

; 1362 : 	    cur->children = xmlNewText(cur->name);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlNewText
	add	esp, 4
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1363 : 	    if (cur->children != NULL)

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN6@xhtmlAttrL

; 1364 : 		cur->children->parent = (xmlNodePtr) cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN6@xhtmlAttrL:

; 1365 : 	}
; 1366 :         xmlAttrDumpOutput(ctxt, cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlAttrDumpOutput
	add	esp, 8

; 1367 : 	cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _cur$[ebp], eax

; 1368 :     }

	jmp	$LN2@xhtmlAttrL
$LN3@xhtmlAttrL:

; 1369 :     /*
; 1370 :      * C.8
; 1371 :      */
; 1372 :     if ((name != NULL) && (id == NULL)) {

	cmp	DWORD PTR _name$[ebp], 0
	je	$LN17@xhtmlAttrL
	cmp	DWORD PTR _id$[ebp], 0
	jne	$LN17@xhtmlAttrL

; 1373 : 	if ((parent != NULL) && (parent->name != NULL) &&

	cmp	DWORD PTR _parent$[ebp], 0
	je	$LN17@xhtmlAttrL
	mov	ecx, DWORD PTR _parent$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	$LN17@xhtmlAttrL
	push	OFFSET ??_C@_01MCMALHOG@a@
	mov	edx, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN19@xhtmlAttrL
	push	OFFSET ??_C@_01JBBJJEPG@p@
	mov	ecx, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN19@xhtmlAttrL
	push	OFFSET ??_C@_03FEJMGOGI@div@
	mov	eax, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN19@xhtmlAttrL
	push	OFFSET ??_C@_03PCCGDNHJ@img@
	mov	edx, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@xhtmlAttrL
	push	OFFSET ??_C@_03HBNNNHNM@map@
	mov	ecx, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@xhtmlAttrL
	push	OFFSET ??_C@_06MJBNHHFM@applet@
	mov	eax, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@xhtmlAttrL
	push	OFFSET ??_C@_04MLMMMEIO@form@
	mov	edx, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@xhtmlAttrL
	push	OFFSET ??_C@_05MIJNFGED@frame@
	mov	ecx, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@xhtmlAttrL
	push	OFFSET ??_C@_06PKBNCBKI@iframe@
	mov	eax, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xhtmlAttrL
$LN19@xhtmlAttrL:

; 1374 : 	    ((xmlStrEqual(parent->name, BAD_CAST "a")) ||
; 1375 : 	     (xmlStrEqual(parent->name, BAD_CAST "p")) ||
; 1376 : 	     (xmlStrEqual(parent->name, BAD_CAST "div")) ||
; 1377 : 	     (xmlStrEqual(parent->name, BAD_CAST "img")) ||
; 1378 : 	     (xmlStrEqual(parent->name, BAD_CAST "map")) ||
; 1379 : 	     (xmlStrEqual(parent->name, BAD_CAST "applet")) ||
; 1380 : 	     (xmlStrEqual(parent->name, BAD_CAST "form")) ||
; 1381 : 	     (xmlStrEqual(parent->name, BAD_CAST "frame")) ||
; 1382 : 	     (xmlStrEqual(parent->name, BAD_CAST "iframe")))) {
; 1383 : 	    xmlOutputBufferWrite(buf, 5, " id=\"");

	push	OFFSET ??_C@_05OCPGBOOB@?5id?$DN?$CC@
	push	5
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1384 : 	    xmlAttrSerializeContent(buf, name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlAttrSerializeContent
	add	esp, 8

; 1385 : 	    xmlOutputBufferWrite(buf, 1, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	1
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN17@xhtmlAttrL:

; 1386 : 	}
; 1387 :     }
; 1388 :     /*
; 1389 :      * C.7.
; 1390 :      */
; 1391 :     if ((lang != NULL) && (xml_lang == NULL)) {

	cmp	DWORD PTR _lang$[ebp], 0
	je	SHORT $LN20@xhtmlAttrL
	cmp	DWORD PTR _xml_lang$[ebp], 0
	jne	SHORT $LN20@xhtmlAttrL

; 1392 : 	xmlOutputBufferWrite(buf, 11, " xml:lang=\"");

	push	OFFSET ??_C@_0M@NGPFCPAA@?5xml?3lang?$DN?$CC@
	push	11					; 0000000bH
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1393 : 	xmlAttrSerializeContent(buf, lang);

	mov	ecx, DWORD PTR _lang$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlAttrSerializeContent
	add	esp, 8

; 1394 : 	xmlOutputBufferWrite(buf, 1, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	1
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1395 :     } else

	jmp	SHORT $LN1@xhtmlAttrL
$LN20@xhtmlAttrL:

; 1396 :     if ((xml_lang != NULL) && (lang == NULL)) {

	cmp	DWORD PTR _xml_lang$[ebp], 0
	je	SHORT $LN1@xhtmlAttrL
	cmp	DWORD PTR _lang$[ebp], 0
	jne	SHORT $LN1@xhtmlAttrL

; 1397 : 	xmlOutputBufferWrite(buf, 7, " lang=\"");

	push	OFFSET ??_C@_07OHOHIONL@?5lang?$DN?$CC@
	push	7
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1398 : 	xmlAttrSerializeContent(buf, xml_lang);

	mov	edx, DWORD PTR _xml_lang$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlAttrSerializeContent
	add	esp, 8

; 1399 : 	xmlOutputBufferWrite(buf, 1, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	1
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN1@xhtmlAttrL:

; 1400 :     }
; 1401 : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xhtmlAttrListDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xhtmlIsEmpty
_TEXT	SEGMENT
tv81 = -4						; size = 4
_node$ = 8						; size = 4
_xhtmlIsEmpty PROC					; COMDAT

; 1266 : xhtmlIsEmpty(xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 1267 :     if (node == NULL)

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN4@xhtmlIsEmp

; 1268 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xhtmlIsEmp
$LN4@xhtmlIsEmp:

; 1269 :     if (node->type != XML_ELEMENT_NODE)

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN5@xhtmlIsEmp

; 1270 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xhtmlIsEmp
$LN5@xhtmlIsEmp:

; 1271 :     if ((node->ns != NULL) && (!xmlStrEqual(node->ns->href, XHTML_NS_NAME)))

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN6@xhtmlIsEmp
	push	OFFSET ??_C@_0BN@BMFLMPPL@http?3?1?1www?4w3?4org?11999?1xhtml@
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@xhtmlIsEmp

; 1272 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xhtmlIsEmp
$LN6@xhtmlIsEmp:

; 1273 :     if (node->children != NULL)

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN7@xhtmlIsEmp

; 1274 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xhtmlIsEmp
$LN7@xhtmlIsEmp:

; 1275 :     switch (node->name[0]) {

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+ecx]
	mov	DWORD PTR tv81[ebp], ecx
	mov	edx, DWORD PTR tv81[ebp]
	sub	edx, 97					; 00000061H
	mov	DWORD PTR tv81[ebp], edx
	cmp	DWORD PTR tv81[ebp], 15			; 0000000fH
	ja	$LN2@xhtmlIsEmp
	mov	eax, DWORD PTR tv81[ebp]
	jmp	DWORD PTR $LN31@xhtmlIsEmp[eax*4]
$LN8@xhtmlIsEmp:

; 1276 : 	case 'a':
; 1277 : 	    if (xmlStrEqual(node->name, BAD_CAST "area"))

	push	OFFSET ??_C@_04GOEDGNCF@area@
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xhtmlIsEmp

; 1278 : 		return(1);

	mov	eax, 1
	jmp	$LN1@xhtmlIsEmp
$LN9@xhtmlIsEmp:

; 1279 : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xhtmlIsEmp
$LN10@xhtmlIsEmp:

; 1280 : 	case 'b':
; 1281 : 	    if (xmlStrEqual(node->name, BAD_CAST "br"))

	push	OFFSET ??_C@_02FGOECCNH@br@
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xhtmlIsEmp

; 1282 : 		return(1);

	mov	eax, 1
	jmp	$LN1@xhtmlIsEmp
$LN11@xhtmlIsEmp:

; 1283 : 	    if (xmlStrEqual(node->name, BAD_CAST "base"))

	push	OFFSET ??_C@_04BHIIPFEC@base@
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xhtmlIsEmp

; 1284 : 		return(1);

	mov	eax, 1
	jmp	$LN1@xhtmlIsEmp
$LN12@xhtmlIsEmp:

; 1285 : 	    if (xmlStrEqual(node->name, BAD_CAST "basefont"))

	push	OFFSET ??_C@_08IOLGIJGJ@basefont@
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xhtmlIsEmp

; 1286 : 		return(1);

	mov	eax, 1
	jmp	$LN1@xhtmlIsEmp
$LN13@xhtmlIsEmp:

; 1287 : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xhtmlIsEmp
$LN14@xhtmlIsEmp:

; 1288 : 	case 'c':
; 1289 : 	    if (xmlStrEqual(node->name, BAD_CAST "col"))

	push	OFFSET ??_C@_03HNOLNALI@col@
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xhtmlIsEmp

; 1290 : 		return(1);

	mov	eax, 1
	jmp	$LN1@xhtmlIsEmp
$LN15@xhtmlIsEmp:

; 1291 : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xhtmlIsEmp
$LN16@xhtmlIsEmp:

; 1292 : 	case 'f':
; 1293 : 	    if (xmlStrEqual(node->name, BAD_CAST "frame"))

	push	OFFSET ??_C@_05MIJNFGED@frame@
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xhtmlIsEmp

; 1294 : 		return(1);

	mov	eax, 1
	jmp	$LN1@xhtmlIsEmp
$LN17@xhtmlIsEmp:

; 1295 : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xhtmlIsEmp
$LN18@xhtmlIsEmp:

; 1296 : 	case 'h':
; 1297 : 	    if (xmlStrEqual(node->name, BAD_CAST "hr"))

	push	OFFSET ??_C@_02FLHDKHAB@hr@
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@xhtmlIsEmp

; 1298 : 		return(1);

	mov	eax, 1
	jmp	$LN1@xhtmlIsEmp
$LN19@xhtmlIsEmp:

; 1299 : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xhtmlIsEmp
$LN20@xhtmlIsEmp:

; 1300 : 	case 'i':
; 1301 : 	    if (xmlStrEqual(node->name, BAD_CAST "img"))

	push	OFFSET ??_C@_03PCCGDNHJ@img@
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@xhtmlIsEmp

; 1302 : 		return(1);

	mov	eax, 1
	jmp	$LN1@xhtmlIsEmp
$LN21@xhtmlIsEmp:

; 1303 : 	    if (xmlStrEqual(node->name, BAD_CAST "input"))

	push	OFFSET ??_C@_05DFJCHPDH@input@
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@xhtmlIsEmp

; 1304 : 		return(1);

	mov	eax, 1
	jmp	$LN1@xhtmlIsEmp
$LN22@xhtmlIsEmp:

; 1305 : 	    if (xmlStrEqual(node->name, BAD_CAST "isindex"))

	push	OFFSET ??_C@_07JMLOFMGP@isindex@
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xhtmlIsEmp

; 1306 : 		return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xhtmlIsEmp
$LN23@xhtmlIsEmp:

; 1307 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xhtmlIsEmp
$LN24@xhtmlIsEmp:

; 1308 : 	case 'l':
; 1309 : 	    if (xmlStrEqual(node->name, BAD_CAST "link"))

	push	OFFSET ??_C@_04OHHBHOGB@link@
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xhtmlIsEmp

; 1310 : 		return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xhtmlIsEmp
$LN25@xhtmlIsEmp:

; 1311 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xhtmlIsEmp
$LN26@xhtmlIsEmp:

; 1312 : 	case 'm':
; 1313 : 	    if (xmlStrEqual(node->name, BAD_CAST "meta"))

	push	OFFSET ??_C@_04HLJJCGEF@meta@
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@xhtmlIsEmp

; 1314 : 		return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xhtmlIsEmp
$LN27@xhtmlIsEmp:

; 1315 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xhtmlIsEmp
$LN28@xhtmlIsEmp:

; 1316 : 	case 'p':
; 1317 : 	    if (xmlStrEqual(node->name, BAD_CAST "param"))

	push	OFFSET ??_C@_05LJDNNBIK@param@
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN29@xhtmlIsEmp

; 1318 : 		return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xhtmlIsEmp
$LN29@xhtmlIsEmp:

; 1319 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xhtmlIsEmp
$LN2@xhtmlIsEmp:

; 1320 :     }
; 1321 :     return(0);

	xor	eax, eax
$LN1@xhtmlIsEmp:

; 1322 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN31@xhtmlIsEmp:
	DD	$LN8@xhtmlIsEmp
	DD	$LN10@xhtmlIsEmp
	DD	$LN14@xhtmlIsEmp
	DD	$LN2@xhtmlIsEmp
	DD	$LN2@xhtmlIsEmp
	DD	$LN16@xhtmlIsEmp
	DD	$LN2@xhtmlIsEmp
	DD	$LN18@xhtmlIsEmp
	DD	$LN20@xhtmlIsEmp
	DD	$LN2@xhtmlIsEmp
	DD	$LN2@xhtmlIsEmp
	DD	$LN24@xhtmlIsEmp
	DD	$LN26@xhtmlIsEmp
	DD	$LN2@xhtmlIsEmp
	DD	$LN2@xhtmlIsEmp
	DD	$LN28@xhtmlIsEmp
_xhtmlIsEmpty ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _htmlNodeDumpOutputInternal
_TEXT	SEGMENT
_doc$ = -24						; size = 4
_switched_encoding$ = -20				; size = 4
_buf$ = -16						; size = 4
_encoding$ = -12					; size = 4
_oldctxtenc$ = -8					; size = 4
_oldenc$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_htmlNodeDumpOutputInternal PROC			; COMDAT

; 841  : htmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 842  :     const xmlChar *oldenc = NULL;

	mov	DWORD PTR _oldenc$[ebp], 0

; 843  :     const xmlChar *oldctxtenc = ctxt->encoding;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _oldctxtenc$[ebp], ecx

; 844  :     const xmlChar *encoding = ctxt->encoding;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _encoding$[ebp], eax

; 845  :     xmlOutputBufferPtr buf = ctxt->buf;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _buf$[ebp], edx

; 846  :     int switched_encoding = 0;

	mov	DWORD PTR _switched_encoding$[ebp], 0

; 847  :     xmlDocPtr doc;
; 848  : 
; 849  :     xmlInitParser();

	call	_xmlInitParser

; 850  : 
; 851  :     doc = cur->doc;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _doc$[ebp], ecx

; 852  :     if (doc != NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN2@htmlNodeDu

; 853  :         oldenc = doc->encoding;

	mov	edx, DWORD PTR _doc$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR _oldenc$[ebp], eax

; 854  : 	if (ctxt->encoding != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN3@htmlNodeDu

; 855  : 	    doc->encoding = BAD_CAST ctxt->encoding;

	mov	edx, DWORD PTR _doc$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+60], ecx
	jmp	SHORT $LN2@htmlNodeDu
$LN3@htmlNodeDu:

; 856  : 	} else if (doc->encoding != NULL) {

	mov	edx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [edx+60], 0
	je	SHORT $LN2@htmlNodeDu

; 857  : 	    encoding = doc->encoding;

	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _encoding$[ebp], ecx
$LN2@htmlNodeDu:

; 858  : 	}
; 859  :     }
; 860  : 
; 861  :     if ((encoding != NULL) && (doc != NULL))

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN6@htmlNodeDu
	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN6@htmlNodeDu

; 862  : 	htmlSetMetaEncoding(doc, (const xmlChar *) encoding);

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_htmlSetMetaEncoding
	add	esp, 8
$LN6@htmlNodeDu:

; 863  :     if ((encoding == NULL) && (doc != NULL))

	cmp	DWORD PTR _encoding$[ebp], 0
	jne	SHORT $LN7@htmlNodeDu
	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN7@htmlNodeDu

; 864  : 	encoding = htmlGetMetaEncoding(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_htmlGetMetaEncoding
	add	esp, 4
	mov	DWORD PTR _encoding$[ebp], eax
$LN7@htmlNodeDu:

; 865  :     if (encoding == NULL)

	cmp	DWORD PTR _encoding$[ebp], 0
	jne	SHORT $LN8@htmlNodeDu

; 866  : 	encoding = BAD_CAST "HTML";

	mov	DWORD PTR _encoding$[ebp], OFFSET ??_C@_04DBLPJNAF@HTML@
$LN8@htmlNodeDu:

; 867  :     if ((encoding != NULL) && (oldctxtenc == NULL) &&
; 868  : 	(buf->encoder == NULL) && (buf->conv == NULL)) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN9@htmlNodeDu
	cmp	DWORD PTR _oldctxtenc$[ebp], 0
	jne	SHORT $LN9@htmlNodeDu
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN9@htmlNodeDu
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN9@htmlNodeDu

; 869  : 	if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSaveSwitchEncoding
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN10@htmlNodeDu

; 870  : 	    doc->encoding = oldenc;

	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR _oldenc$[ebp]
	mov	DWORD PTR [eax+60], ecx

; 871  : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@htmlNodeDu
$LN10@htmlNodeDu:

; 872  : 	}
; 873  : 	switched_encoding = 1;

	mov	DWORD PTR _switched_encoding$[ebp], 1
$LN9@htmlNodeDu:

; 874  :     }
; 875  :     if (ctxt->options & XML_SAVE_FORMAT)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 1
	je	SHORT $LN11@htmlNodeDu

; 876  : 	htmlNodeDumpFormatOutput(buf, doc, cur,

	push	1
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_htmlNodeDumpFormatOutput
	add	esp, 20					; 00000014H
	jmp	SHORT $LN12@htmlNodeDu
$LN11@htmlNodeDu:

; 877  : 				       (const char *)encoding, 1);
; 878  :     else
; 879  : 	htmlNodeDumpFormatOutput(buf, doc, cur,

	push	0
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_htmlNodeDumpFormatOutput
	add	esp, 20					; 00000014H
$LN12@htmlNodeDu:

; 880  : 				       (const char *)encoding, 0);
; 881  :     /*
; 882  :      * Restore the state of the saving context at the end of the document
; 883  :      */
; 884  :     if ((switched_encoding) && (oldctxtenc == NULL)) {

	cmp	DWORD PTR _switched_encoding$[ebp], 0
	je	SHORT $LN13@htmlNodeDu
	cmp	DWORD PTR _oldctxtenc$[ebp], 0
	jne	SHORT $LN13@htmlNodeDu

; 885  : 	xmlSaveClearEncoding(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSaveClearEncoding
	add	esp, 4
$LN13@htmlNodeDu:

; 886  :     }
; 887  :     if (doc != NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN14@htmlNodeDu

; 888  : 	doc->encoding = oldenc;

	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR _oldenc$[ebp]
	mov	DWORD PTR [ecx+60], edx
$LN14@htmlNodeDu:

; 889  :     return(0);

	xor	eax, eax
$LN1@htmlNodeDu:

; 890  : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_htmlNodeDumpOutputInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlAttrListDumpOutput
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlAttrListDumpOutput PROC				; COMDAT

; 794  : xmlAttrListDumpOutput(xmlSaveCtxtPtr ctxt, xmlAttrPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 795  :     if (cur == NULL) return;

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlAttrLis
	jmp	SHORT $LN1@xmlAttrLis
$LN2@xmlAttrLis:

; 796  :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@xmlAttrLis

; 797  :         xmlAttrDumpOutput(ctxt, cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlAttrDumpOutput
	add	esp, 8

; 798  : 	cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _cur$[ebp], eax

; 799  :     }

	jmp	SHORT $LN2@xmlAttrLis
$LN1@xmlAttrLis:

; 800  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlAttrListDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlAttrDumpOutput
_TEXT	SEGMENT
_buf$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlAttrDumpOutput PROC					; COMDAT

; 764  : xmlAttrDumpOutput(xmlSaveCtxtPtr ctxt, xmlAttrPtr cur) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 765  :     xmlOutputBufferPtr buf;
; 766  : 
; 767  :     if (cur == NULL) return;

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlAttrDum
	jmp	$LN1@xmlAttrDum
$LN2@xmlAttrDum:

; 768  :     buf = ctxt->buf;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _buf$[ebp], ecx

; 769  :     if (buf == NULL) return;

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN3@xmlAttrDum
	jmp	$LN1@xmlAttrDum
$LN3@xmlAttrDum:

; 770  :     if (ctxt->format == 2)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+40], 2
	jne	SHORT $LN4@xmlAttrDum

; 771  :         xmlOutputBufferWriteWSNonSig(ctxt, 2);

	push	2
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlOutputBufferWriteWSNonSig
	add	esp, 8
	jmp	SHORT $LN5@xmlAttrDum
$LN4@xmlAttrDum:

; 772  :     else
; 773  :         xmlOutputBufferWrite(buf, 1, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	1
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN5@xmlAttrDum:

; 774  :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN6@xmlAttrDum
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN6@xmlAttrDum

; 775  :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 776  : 	xmlOutputBufferWrite(buf, 1, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	1
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN6@xmlAttrDum:

; 777  :     }
; 778  :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 779  :     xmlOutputBufferWrite(buf, 2, "=\"");

	push	OFFSET ??_C@_02ILLPBGAO@?$DN?$CC@
	push	2
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 780  :     xmlAttrSerializeContent(buf, cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlAttrSerializeContent
	add	esp, 8

; 781  :     xmlOutputBufferWrite(buf, 1, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	1
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN1@xmlAttrDum:

; 782  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAttrDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlDtdDumpOutput
_TEXT	SEGMENT
_doc$ = -16						; size = 4
_level$ = -12						; size = 4
_format$ = -8						; size = 4
_buf$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_dtd$ = 12						; size = 4
_xmlDtdDumpOutput PROC					; COMDAT

; 707  : xmlDtdDumpOutput(xmlSaveCtxtPtr ctxt, xmlDtdPtr dtd) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 708  :     xmlOutputBufferPtr buf;
; 709  :     int format, level;
; 710  :     xmlDocPtr doc;
; 711  : 
; 712  :     if (dtd == NULL) return;

	cmp	DWORD PTR _dtd$[ebp], 0
	jne	SHORT $LN2@xmlDtdDump
	jmp	$LN1@xmlDtdDump
$LN2@xmlDtdDump:

; 713  :     if ((ctxt == NULL) || (ctxt->buf == NULL))

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN4@xmlDtdDump
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN3@xmlDtdDump
$LN4@xmlDtdDump:

; 714  :         return;

	jmp	$LN1@xmlDtdDump
$LN3@xmlDtdDump:

; 715  :     buf = ctxt->buf;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _buf$[ebp], edx

; 716  :     xmlOutputBufferWrite(buf, 10, "<!DOCTYPE ");

	push	OFFSET ??_C@_0L@JKHDJBPI@?$DM?$CBDOCTYPE?5@
	push	10					; 0000000aH
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 717  :     xmlOutputBufferWriteString(buf, (const char *)dtd->name);

	mov	ecx, DWORD PTR _dtd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 718  :     if (dtd->ExternalID != NULL) {

	mov	ecx, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	je	SHORT $LN5@xmlDtdDump

; 719  : 	xmlOutputBufferWrite(buf, 8, " PUBLIC ");

	push	OFFSET ??_C@_08GBBLECIH@?5PUBLIC?5@
	push	8
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 720  : 	xmlBufWriteQuotedString(buf->buffer, dtd->ExternalID);

	mov	eax, DWORD PTR _dtd$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufWriteQuotedString
	add	esp, 8

; 721  : 	xmlOutputBufferWrite(buf, 1, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	1
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 722  : 	xmlBufWriteQuotedString(buf->buffer, dtd->SystemID);

	mov	edx, DWORD PTR _dtd$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufWriteQuotedString
	add	esp, 8
	jmp	SHORT $LN6@xmlDtdDump
$LN5@xmlDtdDump:

; 723  :     }  else if (dtd->SystemID != NULL) {

	mov	eax, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN6@xmlDtdDump

; 724  : 	xmlOutputBufferWrite(buf, 8, " SYSTEM ");

	push	OFFSET ??_C@_08PAGGLANP@?5SYSTEM?5@
	push	8
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 725  : 	xmlBufWriteQuotedString(buf->buffer, dtd->SystemID);

	mov	edx, DWORD PTR _dtd$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufWriteQuotedString
	add	esp, 8
$LN6@xmlDtdDump:

; 726  :     }
; 727  :     if ((dtd->entities == NULL) && (dtd->elements == NULL) &&
; 728  :         (dtd->attributes == NULL) && (dtd->notations == NULL) &&

	mov	eax, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN8@xmlDtdDump
	mov	ecx, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN8@xmlDtdDump
	mov	edx, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [edx+44], 0
	jne	SHORT $LN8@xmlDtdDump
	mov	eax, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN8@xmlDtdDump
	mov	ecx, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [ecx+60], 0
	jne	SHORT $LN8@xmlDtdDump

; 729  : 	(dtd->pentities == NULL)) {
; 730  : 	xmlOutputBufferWrite(buf, 1, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	1
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 731  : 	return;

	jmp	$LN1@xmlDtdDump
$LN8@xmlDtdDump:

; 732  :     }
; 733  :     xmlOutputBufferWrite(buf, 3, " [\n");

	push	OFFSET ??_C@_03OEIPKGAG@?5?$FL?6@
	push	3
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 734  :     /*
; 735  :      * Dump the notations first they are not in the DTD children list
; 736  :      * Do this only on a standalone DTD or on the internal subset though.
; 737  :      */
; 738  :     if ((dtd->notations != NULL) && ((dtd->doc == NULL) ||

	mov	ecx, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN9@xmlDtdDump
	mov	edx, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN10@xmlDtdDump
	mov	eax, DWORD PTR _dtd$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+44]
	cmp	edx, DWORD PTR _dtd$[ebp]
	jne	SHORT $LN9@xmlDtdDump
$LN10@xmlDtdDump:

; 739  :         (dtd->doc->intSubset == dtd))) {
; 740  :         xmlBufDumpNotationTable(buf->buffer,

	mov	eax, DWORD PTR _dtd$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufDumpNotationTable
	add	esp, 8
$LN9@xmlDtdDump:

; 741  :                                 (xmlNotationTablePtr) dtd->notations);
; 742  :     }
; 743  :     format = ctxt->format;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _format$[ebp], edx

; 744  :     level = ctxt->level;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _level$[ebp], ecx

; 745  :     doc = ctxt->doc;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _doc$[ebp], eax

; 746  :     ctxt->format = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+40], 0

; 747  :     ctxt->level = -1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+36], -1

; 748  :     ctxt->doc = dtd->doc;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _dtd$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+28], edx

; 749  :     xmlNodeListDumpOutput(ctxt, dtd->children);

	mov	eax, DWORD PTR _dtd$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNodeListDumpOutput
	add	esp, 8

; 750  :     ctxt->format = format;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _format$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 751  :     ctxt->level = level;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _level$[ebp]
	mov	DWORD PTR [edx+36], eax

; 752  :     ctxt->doc = doc;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [ecx+28], edx

; 753  :     xmlOutputBufferWrite(buf, 2, "]>");

	push	OFFSET ??_C@_02CFBPIAHD@?$FN?$DO@
	push	2
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN1@xmlDtdDump:

; 754  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDtdDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNsListDumpOutputCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlNsListDumpOutputCtxt PROC				; COMDAT

; 676  : xmlNsListDumpOutputCtxt(xmlSaveCtxtPtr ctxt, xmlNsPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlNsListD:

; 677  :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@xmlNsListD

; 678  :         xmlNsDumpOutput(ctxt->buf, cur, ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_xmlNsDumpOutput
	add	esp, 12					; 0000000cH

; 679  : 	cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 680  :     }

	jmp	SHORT $LN2@xmlNsListD
$LN1@xmlNsListD:

; 681  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlNsListDumpOutputCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNsDumpOutputCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlNsDumpOutputCtxt PROC				; COMDAT

; 663  : xmlNsDumpOutputCtxt(xmlSaveCtxtPtr ctxt, xmlNsPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 664  :     xmlNsDumpOutput(ctxt->buf, cur, ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_xmlNsDumpOutput
	add	esp, 12					; 0000000cH

; 665  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlNsDumpOutputCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNsDumpOutput
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_cur$ = 12						; size = 4
_ctxt$ = 16						; size = 4
_xmlNsDumpOutput PROC					; COMDAT

; 632  : xmlNsDumpOutput(xmlOutputBufferPtr buf, xmlNsPtr cur, xmlSaveCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 633  :     if ((cur == NULL) || (buf == NULL)) return;

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@xmlNsDumpO
	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN2@xmlNsDumpO
$LN3@xmlNsDumpO:
	jmp	$LN1@xmlNsDumpO
$LN2@xmlNsDumpO:

; 634  :     if ((cur->type == XML_LOCAL_NAMESPACE) && (cur->href != NULL)) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	$LN1@xmlNsDumpO
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	$LN1@xmlNsDumpO

; 635  : 	if (xmlStrEqual(cur->prefix, BAD_CAST "xml"))

	push	OFFSET ??_C@_03PJHHNEEI@xml@
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlNsDumpO

; 636  : 	    return;

	jmp	$LN1@xmlNsDumpO
$LN5@xmlNsDumpO:

; 637  : 
; 638  : 	if (ctxt != NULL && ctxt->format == 2)

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN6@xmlNsDumpO
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+40], 2
	jne	SHORT $LN6@xmlNsDumpO

; 639  : 	    xmlOutputBufferWriteWSNonSig(ctxt, 2);

	push	2
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlOutputBufferWriteWSNonSig
	add	esp, 8
	jmp	SHORT $LN7@xmlNsDumpO
$LN6@xmlNsDumpO:

; 640  : 	else
; 641  : 	    xmlOutputBufferWrite(buf, 1, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	1
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN7@xmlNsDumpO:

; 642  : 
; 643  :         /* Within the context of an element attributes */
; 644  : 	if (cur->prefix != NULL) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN8@xmlNsDumpO

; 645  : 	    xmlOutputBufferWrite(buf, 6, "xmlns:");

	push	OFFSET ??_C@_06PNFLLAEF@xmlns?3@
	push	6
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 646  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->prefix);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 647  : 	} else

	jmp	SHORT $LN9@xmlNsDumpO
$LN8@xmlNsDumpO:

; 648  : 	    xmlOutputBufferWrite(buf, 5, "xmlns");

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	5
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN9@xmlNsDumpO:

; 649  : 	xmlOutputBufferWrite(buf, 1, "=");

	push	OFFSET ??_C@_01NEMOKFLO@?$DN@
	push	1
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 650  : 	xmlBufWriteQuotedString(buf->buffer, cur->href);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufWriteQuotedString
	add	esp, 8
$LN1@xmlNsDumpO:

; 651  :     }
; 652  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlNsDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlOutputBufferWriteWSNonSig
_TEXT	SEGMENT
tv89 = -8						; size = 4
_i$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlOutputBufferWriteWSNonSig PROC			; COMDAT

; 608  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 609  :     int i;
; 610  :     if ((ctxt == NULL) || (ctxt->buf == NULL))

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN6@xmlOutputB
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN5@xmlOutputB
$LN6@xmlOutputB:

; 611  :         return;

	jmp	$LN1@xmlOutputB
$LN5@xmlOutputB:

; 612  :     xmlOutputBufferWrite(ctxt->buf, 1, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 613  :     for (i = 0; i < (ctxt->level + extra); i += ctxt->indent_nr) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlOutputB
$LN2@xmlOutputB:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlOutputB:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, DWORD PTR _extra$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN1@xmlOutputB

; 614  :         xmlOutputBufferWrite(ctxt->buf, ctxt->indent_size *

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, DWORD PTR _extra$[ebp]
	sub	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	edx, DWORD PTR [eax+108]
	jle	SHORT $LN8@xmlOutputB
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR tv89[ebp], edx
	jmp	SHORT $LN9@xmlOutputB
$LN8@xmlOutputB:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	add	ecx, DWORD PTR _extra$[ebp]
	sub	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv89[ebp], ecx
$LN9@xmlOutputB:
	mov	edx, DWORD PTR _ctxt$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	imul	ecx, DWORD PTR tv89[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 615  :                 ((ctxt->level + extra - i) > ctxt->indent_nr ?
; 616  :                  ctxt->indent_nr : (ctxt->level + extra - i)),
; 617  :                 ctxt->indent);
; 618  :     }

	jmp	SHORT $LN2@xmlOutputB
$LN1@xmlOutputB:

; 619  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlOutputBufferWriteWSNonSig ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlDocContentDumpOutput
_TEXT	SEGMENT
tv212 = -48						; size = 4
_child$1 = -44						; size = 4
_switched_encoding$ = -40				; size = 4
_enc$ = -36						; size = 4
_buf$ = -32						; size = 4
_oldescapeAttr$ = -28					; size = 4
_oldescape$ = -24					; size = 4
_encoding$ = -20					; size = 4
_oldctxtenc$ = -16					; size = 4
_oldenc$ = -12						; size = 4
_is_xhtml$ = -8						; size = 4
_dtd$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlDocContentDumpOutput PROC				; COMDAT

; 1102 : xmlDocContentDumpOutput(xmlSaveCtxtPtr ctxt, xmlDocPtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 1103 : #ifdef LIBXML_HTML_ENABLED
; 1104 :     xmlDtdPtr dtd;
; 1105 :     int is_xhtml = 0;

	mov	DWORD PTR _is_xhtml$[ebp], 0

; 1106 : #endif
; 1107 :     const xmlChar *oldenc = cur->encoding;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _oldenc$[ebp], ecx

; 1108 :     const xmlChar *oldctxtenc = ctxt->encoding;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _oldctxtenc$[ebp], eax

; 1109 :     const xmlChar *encoding = ctxt->encoding;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _encoding$[ebp], edx

; 1110 :     xmlCharEncodingOutputFunc oldescape = ctxt->escape;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR _oldescape$[ebp], ecx

; 1111 :     xmlCharEncodingOutputFunc oldescapeAttr = ctxt->escapeAttr;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	DWORD PTR _oldescapeAttr$[ebp], eax

; 1112 :     xmlOutputBufferPtr buf = ctxt->buf;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _buf$[ebp], edx

; 1113 :     xmlCharEncoding enc;
; 1114 :     int switched_encoding = 0;

	mov	DWORD PTR _switched_encoding$[ebp], 0

; 1115 : 
; 1116 :     xmlInitParser();

	call	_xmlInitParser

; 1117 : 
; 1118 :     if ((cur->type != XML_HTML_DOCUMENT_NODE) &&

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 13			; 0000000dH
	je	SHORT $LN6@xmlDocCont
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 9
	je	SHORT $LN6@xmlDocCont

; 1119 :         (cur->type != XML_DOCUMENT_NODE))
; 1120 : 	 return(-1);

	or	eax, -1
	jmp	$LN1@xmlDocCont
$LN6@xmlDocCont:

; 1121 : 
; 1122 :     if (ctxt->encoding != NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN7@xmlDocCont

; 1123 :         cur->encoding = BAD_CAST ctxt->encoding;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+60], edx
	jmp	SHORT $LN8@xmlDocCont
$LN7@xmlDocCont:

; 1124 :     } else if (cur->encoding != NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+60], 0
	je	SHORT $LN8@xmlDocCont

; 1125 : 	encoding = cur->encoding;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR _encoding$[ebp], edx
$LN8@xmlDocCont:

; 1126 :     }
; 1127 : 
; 1128 :     if (((cur->type == XML_HTML_DOCUMENT_NODE) &&
; 1129 :          ((ctxt->options & XML_SAVE_AS_XML) == 0) &&
; 1130 :          ((ctxt->options & XML_SAVE_XHTML) == 0)) ||

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 13			; 0000000dH
	jne	SHORT $LN13@xmlDocCont
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 32					; 00000020H
	jne	SHORT $LN13@xmlDocCont
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 16					; 00000010H
	je	SHORT $LN12@xmlDocCont
$LN13@xmlDocCont:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 64					; 00000040H
	je	$LN10@xmlDocCont
$LN12@xmlDocCont:

; 1131 :         (ctxt->options & XML_SAVE_AS_HTML)) {
; 1132 : #ifdef LIBXML_HTML_ENABLED
; 1133 :         if (encoding != NULL)

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN14@xmlDocCont

; 1134 : 	    htmlSetMetaEncoding(cur, (const xmlChar *) encoding);

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_htmlSetMetaEncoding
	add	esp, 8
$LN14@xmlDocCont:

; 1135 :         if (encoding == NULL)

	cmp	DWORD PTR _encoding$[ebp], 0
	jne	SHORT $LN15@xmlDocCont

; 1136 : 	    encoding = htmlGetMetaEncoding(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_htmlGetMetaEncoding
	add	esp, 4
	mov	DWORD PTR _encoding$[ebp], eax
$LN15@xmlDocCont:

; 1137 :         if (encoding == NULL)

	cmp	DWORD PTR _encoding$[ebp], 0
	jne	SHORT $LN16@xmlDocCont

; 1138 : 	    encoding = BAD_CAST "HTML";

	mov	DWORD PTR _encoding$[ebp], OFFSET ??_C@_04DBLPJNAF@HTML@
$LN16@xmlDocCont:

; 1139 : 	if ((encoding != NULL) && (oldctxtenc == NULL) &&
; 1140 : 	    (buf->encoder == NULL) && (buf->conv == NULL)) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN17@xmlDocCont
	cmp	DWORD PTR _oldctxtenc$[ebp], 0
	jne	SHORT $LN17@xmlDocCont
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN17@xmlDocCont
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN17@xmlDocCont

; 1141 : 	    if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSaveSwitchEncoding
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN17@xmlDocCont

; 1142 : 		cur->encoding = oldenc;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR _oldenc$[ebp]
	mov	DWORD PTR [edx+60], eax

; 1143 : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlDocCont
$LN17@xmlDocCont:

; 1144 : 	    }
; 1145 : 	}
; 1146 :         if (ctxt->options & XML_SAVE_FORMAT)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 1
	je	SHORT $LN19@xmlDocCont

; 1147 : 	    htmlDocContentDumpFormatOutput(buf, cur,

	push	1
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_htmlDocContentDumpFormatOutput
	add	esp, 16					; 00000010H
	jmp	SHORT $LN20@xmlDocCont
$LN19@xmlDocCont:

; 1148 : 	                                   (const char *)encoding, 1);
; 1149 : 	else
; 1150 : 	    htmlDocContentDumpFormatOutput(buf, cur,

	push	0
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_htmlDocContentDumpFormatOutput
	add	esp, 16					; 00000010H
$LN20@xmlDocCont:

; 1151 : 	                                   (const char *)encoding, 0);
; 1152 : 	if (ctxt->encoding != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN21@xmlDocCont

; 1153 : 	    cur->encoding = oldenc;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _oldenc$[ebp]
	mov	DWORD PTR [ecx+60], edx
$LN21@xmlDocCont:

; 1154 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlDocCont

; 1155 : #else
; 1156 :         return(-1);
; 1157 : #endif
; 1158 :     } else if ((cur->type == XML_DOCUMENT_NODE) ||

	jmp	$LN11@xmlDocCont
$LN10@xmlDocCont:

; 1159 :                (ctxt->options & XML_SAVE_AS_XML) ||

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 9
	je	SHORT $LN23@xmlDocCont
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 32					; 00000020H
	jne	SHORT $LN23@xmlDocCont
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 16					; 00000010H
	je	$LN11@xmlDocCont
$LN23@xmlDocCont:

; 1160 :                (ctxt->options & XML_SAVE_XHTML)) {
; 1161 : 	enc = xmlParseCharEncoding((const char*) encoding);

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	call	_xmlParseCharEncoding
	add	esp, 4
	mov	DWORD PTR _enc$[ebp], eax

; 1162 : 	if ((encoding != NULL) && (oldctxtenc == NULL) &&
; 1163 : 	    (buf->encoder == NULL) && (buf->conv == NULL) &&

	cmp	DWORD PTR _encoding$[ebp], 0
	je	$LN24@xmlDocCont
	cmp	DWORD PTR _oldctxtenc$[ebp], 0
	jne	$LN24@xmlDocCont
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN24@xmlDocCont
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN24@xmlDocCont
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 2
	jne	SHORT $LN24@xmlDocCont

; 1164 : 	    ((ctxt->options & XML_SAVE_NO_DECL) == 0)) {
; 1165 : 	    if ((enc != XML_CHAR_ENCODING_UTF8) &&
; 1166 : 		(enc != XML_CHAR_ENCODING_NONE) &&

	cmp	DWORD PTR _enc$[ebp], 1
	je	SHORT $LN25@xmlDocCont
	cmp	DWORD PTR _enc$[ebp], 0
	je	SHORT $LN25@xmlDocCont
	cmp	DWORD PTR _enc$[ebp], 22		; 00000016H
	je	SHORT $LN25@xmlDocCont

; 1167 : 		(enc != XML_CHAR_ENCODING_ASCII)) {
; 1168 : 		/*
; 1169 : 		 * we need to switch to this encoding but just for this
; 1170 : 		 * document since we output the XMLDecl the conversion
; 1171 : 		 * must be done to not generate not well formed documents.
; 1172 : 		 */
; 1173 : 		if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSaveSwitchEncoding
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN26@xmlDocCont

; 1174 : 		    cur->encoding = oldenc;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _oldenc$[ebp]
	mov	DWORD PTR [eax+60], ecx

; 1175 : 		    return(-1);

	or	eax, -1
	jmp	$LN1@xmlDocCont
$LN26@xmlDocCont:

; 1176 : 		}
; 1177 : 		switched_encoding = 1;

	mov	DWORD PTR _switched_encoding$[ebp], 1
$LN25@xmlDocCont:

; 1178 : 	    }
; 1179 : 	    if (ctxt->escape == xmlEscapeEntities)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+116], OFFSET _xmlEscapeEntities
	jne	SHORT $LN27@xmlDocCont

; 1180 : 		ctxt->escape = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+116], 0
$LN27@xmlDocCont:

; 1181 : 	    if (ctxt->escapeAttr == xmlEscapeEntities)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+120], OFFSET _xmlEscapeEntities
	jne	SHORT $LN24@xmlDocCont

; 1182 : 		ctxt->escapeAttr = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+120], 0
$LN24@xmlDocCont:

; 1183 : 	}
; 1184 : 
; 1185 : 
; 1186 : 	/*
; 1187 : 	 * Save the XML declaration
; 1188 : 	 */
; 1189 : 	if ((ctxt->options & XML_SAVE_NO_DECL) == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 2
	jne	$LN29@xmlDocCont

; 1190 : 	    xmlOutputBufferWrite(buf, 14, "<?xml version=");

	push	OFFSET ??_C@_0P@CNJADHFP@?$DM?$DPxml?5version?$DN@
	push	14					; 0000000eH
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1191 : 	    if (cur->version != NULL)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN30@xmlDocCont

; 1192 : 		xmlBufWriteQuotedString(buf->buffer, cur->version);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufWriteQuotedString
	add	esp, 8
	jmp	SHORT $LN31@xmlDocCont
$LN30@xmlDocCont:

; 1193 : 	    else
; 1194 : 		xmlOutputBufferWrite(buf, 5, "\"1.0\"");

	push	OFFSET ??_C@_05FLCMBAOK@?$CC1?40?$CC@
	push	5
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN31@xmlDocCont:

; 1195 : 	    if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN32@xmlDocCont

; 1196 : 		xmlOutputBufferWrite(buf, 10, " encoding=");

	push	OFFSET ??_C@_0L@GJNPICMJ@?5encoding?$DN@
	push	10					; 0000000aH
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1197 : 		xmlBufWriteQuotedString(buf->buffer, (xmlChar *) encoding);

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufWriteQuotedString
	add	esp, 8
$LN32@xmlDocCont:

; 1198 : 	    }
; 1199 : 	    switch (cur->standalone) {

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR tv212[ebp], edx
	cmp	DWORD PTR tv212[ebp], 0
	je	SHORT $LN33@xmlDocCont
	cmp	DWORD PTR tv212[ebp], 1
	je	SHORT $LN34@xmlDocCont
	jmp	SHORT $LN2@xmlDocCont
$LN33@xmlDocCont:

; 1200 : 		case 0:
; 1201 : 		    xmlOutputBufferWrite(buf, 16, " standalone=\"no\"");

	push	OFFSET ??_C@_0BB@FFDPHLPI@?5standalone?$DN?$CCno?$CC@
	push	16					; 00000010H
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1202 : 		    break;

	jmp	SHORT $LN2@xmlDocCont
$LN34@xmlDocCont:

; 1203 : 		case 1:
; 1204 : 		    xmlOutputBufferWrite(buf, 17, " standalone=\"yes\"");

	push	OFFSET ??_C@_0BC@MEICOMAE@?5standalone?$DN?$CCyes?$CC@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN2@xmlDocCont:

; 1205 : 		    break;
; 1206 : 	    }
; 1207 : 	    xmlOutputBufferWrite(buf, 3, "?>\n");

	push	OFFSET ??_C@_03KCOJOIAE@?$DP?$DO?6@
	push	3
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN29@xmlDocCont:

; 1208 : 	}
; 1209 : 
; 1210 : #ifdef LIBXML_HTML_ENABLED
; 1211 :         if (ctxt->options & XML_SAVE_XHTML)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 16					; 00000010H
	je	SHORT $LN35@xmlDocCont

; 1212 :             is_xhtml = 1;

	mov	DWORD PTR _is_xhtml$[ebp], 1
$LN35@xmlDocCont:

; 1213 : 	if ((ctxt->options & XML_SAVE_NO_XHTML) == 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 8
	jne	SHORT $LN36@xmlDocCont

; 1214 : 	    dtd = xmlGetIntSubset(cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlGetIntSubset
	add	esp, 4
	mov	DWORD PTR _dtd$[ebp], eax

; 1215 : 	    if (dtd != NULL) {

	cmp	DWORD PTR _dtd$[ebp], 0
	je	SHORT $LN36@xmlDocCont

; 1216 : 		is_xhtml = xmlIsXHTML(dtd->SystemID, dtd->ExternalID);

	mov	edx, DWORD PTR _dtd$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _dtd$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	_xmlIsXHTML
	add	esp, 8
	mov	DWORD PTR _is_xhtml$[ebp], eax

; 1217 : 		if (is_xhtml < 0) is_xhtml = 0;

	cmp	DWORD PTR _is_xhtml$[ebp], 0
	jge	SHORT $LN36@xmlDocCont
	mov	DWORD PTR _is_xhtml$[ebp], 0
$LN36@xmlDocCont:

; 1218 : 	    }
; 1219 : 	}
; 1220 : #endif
; 1221 : 	if (cur->children != NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN11@xmlDocCont

; 1222 : 	    xmlNodePtr child = cur->children;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _child$1[ebp], edx
$LN4@xmlDocCont:

; 1223 : 
; 1224 : 	    while (child != NULL) {

	cmp	DWORD PTR _child$1[ebp], 0
	je	SHORT $LN11@xmlDocCont

; 1225 : 		ctxt->level = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+36], 0

; 1226 : #ifdef LIBXML_HTML_ENABLED
; 1227 : 		if (is_xhtml)

	cmp	DWORD PTR _is_xhtml$[ebp], 0
	je	SHORT $LN40@xmlDocCont

; 1228 : 		    xhtmlNodeDumpOutput(ctxt, child);

	mov	ecx, DWORD PTR _child$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xhtmlNodeDumpOutput
	add	esp, 8
	jmp	SHORT $LN41@xmlDocCont
$LN40@xmlDocCont:

; 1229 : 		else
; 1230 : #endif
; 1231 : 		    xmlNodeDumpOutputInternal(ctxt, child);

	mov	eax, DWORD PTR _child$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNodeDumpOutputInternal
	add	esp, 8
$LN41@xmlDocCont:

; 1232 : 		xmlOutputBufferWrite(buf, 1, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	1
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1233 : 		child = child->next;

	mov	eax, DWORD PTR _child$1[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _child$1[ebp], ecx

; 1234 : 	    }

	jmp	SHORT $LN4@xmlDocCont
$LN11@xmlDocCont:

; 1235 : 	}
; 1236 :     }
; 1237 : 
; 1238 :     /*
; 1239 :      * Restore the state of the saving context at the end of the document
; 1240 :      */
; 1241 :     if ((switched_encoding) && (oldctxtenc == NULL)) {

	cmp	DWORD PTR _switched_encoding$[ebp], 0
	je	SHORT $LN42@xmlDocCont
	cmp	DWORD PTR _oldctxtenc$[ebp], 0
	jne	SHORT $LN42@xmlDocCont

; 1242 : 	xmlSaveClearEncoding(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSaveClearEncoding
	add	esp, 4

; 1243 : 	ctxt->escape = oldescape;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _oldescape$[ebp]
	mov	DWORD PTR [eax+116], ecx

; 1244 : 	ctxt->escapeAttr = oldescapeAttr;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _oldescapeAttr$[ebp]
	mov	DWORD PTR [edx+120], eax
$LN42@xmlDocCont:

; 1245 :     }
; 1246 :     cur->encoding = oldenc;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _oldenc$[ebp]
	mov	DWORD PTR [ecx+60], edx

; 1247 :     return(0);

	xor	eax, eax
$LN1@xmlDocCont:

; 1248 : }

	pop	edi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDocContentDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNsListDumpOutput
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlNsListDumpOutput PROC				; COMDAT

; 692  : xmlNsListDumpOutput(xmlOutputBufferPtr buf, xmlNsPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlNsListD:

; 693  :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@xmlNsListD

; 694  :         xmlNsDumpOutput(buf, cur, NULL);

	push	0
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlNsDumpOutput
	add	esp, 12					; 0000000cH

; 695  : 	cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _cur$[ebp], eax

; 696  :     }

	jmp	SHORT $LN2@xmlNsListD
$LN1@xmlNsListD:

; 697  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlNsListDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNodeDumpOutputInternal
_TEXT	SEGMENT
tv387 = -24						; size = 4
_buf$ = -20						; size = 4
_end$ = -16						; size = 4
_start$ = -12						; size = 4
_tmp$ = -8						; size = 4
_format$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlNodeDumpOutputInternal PROC				; COMDAT

; 900  : xmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 901  :     int format;
; 902  :     xmlNodePtr tmp;
; 903  :     xmlChar *start, *end;
; 904  :     xmlOutputBufferPtr buf;
; 905  : 
; 906  :     if (cur == NULL) return;

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN6@xmlNodeDum
	jmp	$LN1@xmlNodeDum
$LN6@xmlNodeDum:

; 907  :     buf = ctxt->buf;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _buf$[ebp], ecx

; 908  :     if (cur->type == XML_XINCLUDE_START)

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 19			; 00000013H
	jne	SHORT $LN7@xmlNodeDum

; 909  : 	return;

	jmp	$LN1@xmlNodeDum
$LN7@xmlNodeDum:

; 910  :     if (cur->type == XML_XINCLUDE_END)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 20			; 00000014H
	jne	SHORT $LN8@xmlNodeDum

; 911  : 	return;

	jmp	$LN1@xmlNodeDum
$LN8@xmlNodeDum:

; 912  :     if ((cur->type == XML_DOCUMENT_NODE) ||

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 9
	je	SHORT $LN10@xmlNodeDum
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 13			; 0000000dH
	jne	SHORT $LN9@xmlNodeDum
$LN10@xmlNodeDum:

; 913  :         (cur->type == XML_HTML_DOCUMENT_NODE)) {
; 914  : 	xmlDocContentDumpOutput(ctxt, (xmlDocPtr) cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDocContentDumpOutput
	add	esp, 8

; 915  : 	return;

	jmp	$LN1@xmlNodeDum
$LN9@xmlNodeDum:

; 916  :     }
; 917  : #ifdef LIBXML_HTML_ENABLED
; 918  :     if (ctxt->options & XML_SAVE_XHTML) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 16					; 00000010H
	je	SHORT $LN11@xmlNodeDum

; 919  :         xhtmlNodeDumpOutput(ctxt, cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xhtmlNodeDumpOutput
	add	esp, 8

; 920  :         return;

	jmp	$LN1@xmlNodeDum
$LN11@xmlNodeDum:

; 921  :     }
; 922  :     if (((cur->type != XML_NAMESPACE_DECL) && (cur->doc != NULL) &&
; 923  :          (cur->doc->type == XML_HTML_DOCUMENT_NODE) &&
; 924  :          ((ctxt->options & XML_SAVE_AS_XML) == 0)) ||

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	SHORT $LN14@xmlNodeDum
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	je	SHORT $LN14@xmlNodeDum
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+32]
	cmp	DWORD PTR [eax+4], 13			; 0000000dH
	jne	SHORT $LN14@xmlNodeDum
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 32					; 00000020H
	je	SHORT $LN13@xmlNodeDum
$LN14@xmlNodeDum:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 64					; 00000040H
	je	SHORT $LN12@xmlNodeDum
$LN13@xmlNodeDum:

; 925  :         (ctxt->options & XML_SAVE_AS_HTML)) {
; 926  : 	htmlNodeDumpOutputInternal(ctxt, cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_htmlNodeDumpOutputInternal
	add	esp, 8

; 927  : 	return;

	jmp	$LN1@xmlNodeDum
$LN12@xmlNodeDum:

; 928  :     }
; 929  : #endif
; 930  :     if (cur->type == XML_DTD_NODE) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 14			; 0000000eH
	jne	SHORT $LN15@xmlNodeDum

; 931  :         xmlDtdDumpOutput(ctxt, (xmlDtdPtr) cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDtdDumpOutput
	add	esp, 8

; 932  : 	return;

	jmp	$LN1@xmlNodeDum
$LN15@xmlNodeDum:

; 933  :     }
; 934  :     if (cur->type == XML_DOCUMENT_FRAG_NODE) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 11			; 0000000bH
	jne	SHORT $LN16@xmlNodeDum

; 935  :         xmlNodeListDumpOutput(ctxt, cur->children);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNodeListDumpOutput
	add	esp, 8

; 936  : 	return;

	jmp	$LN1@xmlNodeDum
$LN16@xmlNodeDum:

; 937  :     }
; 938  :     if (cur->type == XML_ELEMENT_DECL) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 15			; 0000000fH
	jne	SHORT $LN17@xmlNodeDum

; 939  :         xmlBufDumpElementDecl(buf->buffer, (xmlElementPtr) cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufDumpElementDecl
	add	esp, 8

; 940  : 	return;

	jmp	$LN1@xmlNodeDum
$LN17@xmlNodeDum:

; 941  :     }
; 942  :     if (cur->type == XML_ATTRIBUTE_DECL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 16			; 00000010H
	jne	SHORT $LN18@xmlNodeDum

; 943  :         xmlBufDumpAttributeDecl(buf->buffer, (xmlAttributePtr) cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufDumpAttributeDecl
	add	esp, 8

; 944  : 	return;

	jmp	$LN1@xmlNodeDum
$LN18@xmlNodeDum:

; 945  :     }
; 946  :     if (cur->type == XML_ENTITY_DECL) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 17			; 00000011H
	jne	SHORT $LN19@xmlNodeDum

; 947  :         xmlBufDumpEntityDecl(buf->buffer, (xmlEntityPtr) cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufDumpEntityDecl
	add	esp, 8

; 948  : 	return;

	jmp	$LN1@xmlNodeDum
$LN19@xmlNodeDum:

; 949  :     }
; 950  :     if (cur->type == XML_TEXT_NODE) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 3
	jne	SHORT $LN20@xmlNodeDum

; 951  : 	if (cur->content != NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN21@xmlNodeDum

; 952  : 	    if (cur->name != xmlStringTextNoenc) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+8], OFFSET _xmlStringTextNoenc
	je	SHORT $LN22@xmlNodeDum

; 953  :                 xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+116]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteEscape
	add	esp, 12					; 0000000cH

; 954  : 	    } else {

	jmp	SHORT $LN21@xmlNodeDum
$LN22@xmlNodeDum:

; 955  : 		/*
; 956  : 		 * Disable escaping, needed for XSLT
; 957  : 		 */
; 958  : 		xmlOutputBufferWriteString(buf, (const char *) cur->content);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN21@xmlNodeDum:

; 959  : 	    }
; 960  : 	}
; 961  : 
; 962  : 	return;

	jmp	$LN1@xmlNodeDum
$LN20@xmlNodeDum:

; 963  :     }
; 964  :     if (cur->type == XML_PI_NODE) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 7
	jne	$LN24@xmlNodeDum

; 965  : 	if (cur->content != NULL) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	$LN25@xmlNodeDum

; 966  : 	    xmlOutputBufferWrite(buf, 2, "<?");

	push	OFFSET ??_C@_02HFBBBACF@?$DM?$DP@
	push	2
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 967  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 968  : 	    if (cur->content != NULL) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN27@xmlNodeDum

; 969  : 	        if (ctxt->format == 2)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+40], 2
	jne	SHORT $LN28@xmlNodeDum

; 970  : 	            xmlOutputBufferWriteWSNonSig(ctxt, 0);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlOutputBufferWriteWSNonSig
	add	esp, 8
	jmp	SHORT $LN29@xmlNodeDum
$LN28@xmlNodeDum:

; 971  : 	        else
; 972  : 	            xmlOutputBufferWrite(buf, 1, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	1
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN29@xmlNodeDum:

; 973  : 		xmlOutputBufferWriteString(buf, (const char *)cur->content);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN27@xmlNodeDum:

; 974  : 	    }
; 975  : 	    xmlOutputBufferWrite(buf, 2, "?>");

	push	OFFSET ??_C@_02GOEMJPDN@?$DP?$DO@
	push	2
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 976  : 	} else {

	jmp	SHORT $LN26@xmlNodeDum
$LN25@xmlNodeDum:

; 977  : 	    xmlOutputBufferWrite(buf, 2, "<?");

	push	OFFSET ??_C@_02HFBBBACF@?$DM?$DP@
	push	2
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 978  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 979  : 	    if (ctxt->format == 2)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+40], 2
	jne	SHORT $LN30@xmlNodeDum

; 980  : 	        xmlOutputBufferWriteWSNonSig(ctxt, 0);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlOutputBufferWriteWSNonSig
	add	esp, 8
$LN30@xmlNodeDum:

; 981  : 	    xmlOutputBufferWrite(buf, 2, "?>");

	push	OFFSET ??_C@_02GOEMJPDN@?$DP?$DO@
	push	2
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN26@xmlNodeDum:

; 982  : 	}
; 983  : 	return;

	jmp	$LN1@xmlNodeDum
$LN24@xmlNodeDum:

; 984  :     }
; 985  :     if (cur->type == XML_COMMENT_NODE) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 8
	jne	SHORT $LN31@xmlNodeDum

; 986  : 	if (cur->content != NULL) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN32@xmlNodeDum

; 987  : 	    xmlOutputBufferWrite(buf, 4, "<!--");

	push	OFFSET ??_C@_04FFDNBKGC@?$DM?$CB?9?9@
	push	4
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 988  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->content);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 989  : 	    xmlOutputBufferWrite(buf, 3, "-->");

	push	OFFSET ??_C@_03PNLDJJMO@?9?9?$DO@
	push	3
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN32@xmlNodeDum:

; 990  : 	}
; 991  : 	return;

	jmp	$LN1@xmlNodeDum
$LN31@xmlNodeDum:

; 992  :     }
; 993  :     if (cur->type == XML_ENTITY_REF_NODE) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 5
	jne	SHORT $LN33@xmlNodeDum

; 994  :         xmlOutputBufferWrite(buf, 1, "&");

	push	OFFSET ??_C@_01HNPIGOCE@?$CG@
	push	1
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 995  : 	xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 996  :         xmlOutputBufferWrite(buf, 1, ";");

	push	OFFSET ??_C@_01ICJEACDI@?$DL@
	push	1
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 997  : 	return;

	jmp	$LN1@xmlNodeDum
$LN33@xmlNodeDum:

; 998  :     }
; 999  :     if (cur->type == XML_CDATA_SECTION_NODE) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 4
	jne	$LN34@xmlNodeDum

; 1000 : 	if (cur->content == NULL || *cur->content == '\0') {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN37@xmlNodeDum
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN35@xmlNodeDum
$LN37@xmlNodeDum:

; 1001 : 	    xmlOutputBufferWrite(buf, 12, "<![CDATA[]]>");

	push	OFFSET ??_C@_0N@OGBMJHND@?$DM?$CB?$FLCDATA?$FL?$FN?$FN?$DO@
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1002 : 	} else {

	jmp	$LN36@xmlNodeDum
$LN35@xmlNodeDum:

; 1003 : 	    start = end = cur->content;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _end$[ebp], eax
	mov	ecx, DWORD PTR _end$[ebp]
	mov	DWORD PTR _start$[ebp], ecx
$LN2@xmlNodeDum:

; 1004 : 	    while (*end != '\0') {

	mov	edx, DWORD PTR _end$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN3@xmlNodeDum

; 1005 : 		if ((*end == ']') && (*(end + 1) == ']') &&

	mov	ecx, DWORD PTR _end$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 93					; 0000005dH
	jne	SHORT $LN38@xmlNodeDum
	mov	eax, DWORD PTR _end$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 93					; 0000005dH
	jne	SHORT $LN38@xmlNodeDum
	mov	edx, DWORD PTR _end$[ebp]
	movzx	eax, BYTE PTR [edx+2]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN38@xmlNodeDum

; 1006 : 		    (*(end + 2) == '>')) {
; 1007 : 		    end = end + 2;

	mov	ecx, DWORD PTR _end$[ebp]
	add	ecx, 2
	mov	DWORD PTR _end$[ebp], ecx

; 1008 : 		    xmlOutputBufferWrite(buf, 9, "<![CDATA[");

	push	OFFSET ??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@
	push	9
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1009 : 		    xmlOutputBufferWrite(buf, end - start, (const char *)start);

	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	sub	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1010 : 		    xmlOutputBufferWrite(buf, 3, "]]>");

	push	OFFSET ??_C@_03MCHNFBAC@?$FN?$FN?$DO@
	push	3
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1011 : 		    start = end;

	mov	ecx, DWORD PTR _end$[ebp]
	mov	DWORD PTR _start$[ebp], ecx
$LN38@xmlNodeDum:

; 1012 : 		}
; 1013 : 		end++;

	mov	edx, DWORD PTR _end$[ebp]
	add	edx, 1
	mov	DWORD PTR _end$[ebp], edx

; 1014 : 	    }

	jmp	$LN2@xmlNodeDum
$LN3@xmlNodeDum:

; 1015 : 	    if (start != end) {

	mov	eax, DWORD PTR _start$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	je	SHORT $LN36@xmlNodeDum

; 1016 : 		xmlOutputBufferWrite(buf, 9, "<![CDATA[");

	push	OFFSET ??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@
	push	9
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1017 : 		xmlOutputBufferWriteString(buf, (const char *)start);

	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1018 : 		xmlOutputBufferWrite(buf, 3, "]]>");

	push	OFFSET ??_C@_03MCHNFBAC@?$FN?$FN?$DO@
	push	3
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN36@xmlNodeDum:

; 1019 : 	    }
; 1020 : 	}
; 1021 : 	return;

	jmp	$LN1@xmlNodeDum
$LN34@xmlNodeDum:

; 1022 :     }
; 1023 :     if (cur->type == XML_ATTRIBUTE_NODE) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 2
	jne	SHORT $LN40@xmlNodeDum

; 1024 : 	xmlAttrDumpOutput(ctxt, (xmlAttrPtr) cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlAttrDumpOutput
	add	esp, 8

; 1025 : 	return;

	jmp	$LN1@xmlNodeDum
$LN40@xmlNodeDum:

; 1026 :     }
; 1027 :     if (cur->type == XML_NAMESPACE_DECL) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 18			; 00000012H
	jne	SHORT $LN41@xmlNodeDum

; 1028 : 	xmlNsDumpOutputCtxt(ctxt, (xmlNsPtr) cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNsDumpOutputCtxt
	add	esp, 8

; 1029 : 	return;

	jmp	$LN1@xmlNodeDum
$LN41@xmlNodeDum:

; 1030 :     }
; 1031 : 
; 1032 :     format = ctxt->format;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _format$[ebp], eax

; 1033 :     if (format == 1) {

	cmp	DWORD PTR _format$[ebp], 1
	jne	SHORT $LN42@xmlNodeDum

; 1034 : 	tmp = cur->children;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _tmp$[ebp], edx
$LN4@xmlNodeDum:

; 1035 : 	while (tmp != NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN42@xmlNodeDum

; 1036 : 	    if ((tmp->type == XML_TEXT_NODE) ||
; 1037 : 		(tmp->type == XML_CDATA_SECTION_NODE) ||

	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	DWORD PTR [eax+4], 3
	je	SHORT $LN44@xmlNodeDum
	mov	ecx, DWORD PTR _tmp$[ebp]
	cmp	DWORD PTR [ecx+4], 4
	je	SHORT $LN44@xmlNodeDum
	mov	edx, DWORD PTR _tmp$[ebp]
	cmp	DWORD PTR [edx+4], 5
	jne	SHORT $LN43@xmlNodeDum
$LN44@xmlNodeDum:

; 1038 : 		(tmp->type == XML_ENTITY_REF_NODE)) {
; 1039 : 		ctxt->format = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+40], 0

; 1040 : 		break;

	jmp	SHORT $LN42@xmlNodeDum
$LN43@xmlNodeDum:

; 1041 : 	    }
; 1042 : 	    tmp = tmp->next;

	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _tmp$[ebp], edx

; 1043 : 	}

	jmp	SHORT $LN4@xmlNodeDum
$LN42@xmlNodeDum:

; 1044 :     }
; 1045 :     xmlOutputBufferWrite(buf, 1, "<");

	push	OFFSET ??_C@_01MNNFJEPP@?$DM@
	push	1
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1046 :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN45@xmlNodeDum
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN45@xmlNodeDum

; 1047 :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1048 : 	xmlOutputBufferWrite(buf, 1, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	1
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN45@xmlNodeDum:

; 1049 :     }
; 1050 : 
; 1051 :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1052 :     if (cur->nsDef)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN46@xmlNodeDum

; 1053 :         xmlNsListDumpOutputCtxt(ctxt, cur->nsDef);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNsListDumpOutputCtxt
	add	esp, 8
$LN46@xmlNodeDum:

; 1054 :     if (cur->properties != NULL)

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+44], 0
	je	SHORT $LN47@xmlNodeDum

; 1055 :         xmlAttrListDumpOutput(ctxt, cur->properties);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlAttrListDumpOutput
	add	esp, 8
$LN47@xmlNodeDum:

; 1056 : 
; 1057 :     if (((cur->type == XML_ELEMENT_NODE) || (cur->content == NULL)) &&
; 1058 : 	(cur->children == NULL) && ((ctxt->options & XML_SAVE_NO_EMPTY) == 0)) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 1
	je	SHORT $LN49@xmlNodeDum
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN48@xmlNodeDum
$LN49@xmlNodeDum:
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN48@xmlNodeDum
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 4
	jne	SHORT $LN48@xmlNodeDum

; 1059 :         if (ctxt->format == 2)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+40], 2
	jne	SHORT $LN50@xmlNodeDum

; 1060 :             xmlOutputBufferWriteWSNonSig(ctxt, 0);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlOutputBufferWriteWSNonSig
	add	esp, 8
$LN50@xmlNodeDum:

; 1061 :         xmlOutputBufferWrite(buf, 2, "/>");

	push	OFFSET ??_C@_02HCGKDMEN@?1?$DO@
	push	2
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1062 : 	ctxt->format = format;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _format$[ebp]
	mov	DWORD PTR [ecx+40], edx

; 1063 : 	return;

	jmp	$LN1@xmlNodeDum
$LN48@xmlNodeDum:

; 1064 :     }
; 1065 :     if (ctxt->format == 2)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+40], 2
	jne	SHORT $LN51@xmlNodeDum

; 1066 :         xmlOutputBufferWriteWSNonSig(ctxt, 1);

	push	1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteWSNonSig
	add	esp, 8
$LN51@xmlNodeDum:

; 1067 :     xmlOutputBufferWrite(buf, 1, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	1
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1068 :     if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL)) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN52@xmlNodeDum
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN52@xmlNodeDum

; 1069 : 	xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+116]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteEscape
	add	esp, 12					; 0000000cH
$LN52@xmlNodeDum:

; 1070 :     }
; 1071 :     if (cur->children != NULL) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	$LN53@xmlNodeDum

; 1072 : 	if (ctxt->format == 1) xmlOutputBufferWrite(buf, 1, "\n");

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+40], 1
	jne	SHORT $LN54@xmlNodeDum
	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	1
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN54@xmlNodeDum:

; 1073 : 	if (ctxt->level >= 0) ctxt->level++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	jl	SHORT $LN55@xmlNodeDum
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN55@xmlNodeDum:

; 1074 : 	xmlNodeListDumpOutput(ctxt, cur->children);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNodeListDumpOutput
	add	esp, 8

; 1075 : 	if (ctxt->level > 0) ctxt->level--;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jle	SHORT $LN56@xmlNodeDum
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	sub	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+36], ecx
$LN56@xmlNodeDum:

; 1076 : 	if ((xmlIndentTreeOutput) && (ctxt->format == 1))

	call	___xmlIndentTreeOutput
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN53@xmlNodeDum
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+40], 1
	jne	SHORT $LN53@xmlNodeDum

; 1077 : 	    xmlOutputBufferWrite(buf, ctxt->indent_size *

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+36]
	cmp	eax, DWORD PTR [edx+108]
	jle	SHORT $LN61@xmlNodeDum
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR tv387[ebp], edx
	jmp	SHORT $LN62@xmlNodeDum
$LN61@xmlNodeDum:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR tv387[ebp], ecx
$LN62@xmlNodeDum:
	mov	edx, DWORD PTR _ctxt$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	imul	ecx, DWORD PTR tv387[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN53@xmlNodeDum:

; 1078 : 	                         (ctxt->level > ctxt->indent_nr ?
; 1079 : 				  ctxt->indent_nr : ctxt->level),
; 1080 : 				 ctxt->indent);
; 1081 :     }
; 1082 :     xmlOutputBufferWrite(buf, 2, "</");

	push	OFFSET ??_C@_02DPNDACHE@?$DM?1@
	push	2
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1083 :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN58@xmlNodeDum
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN58@xmlNodeDum

; 1084 :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1085 : 	xmlOutputBufferWrite(buf, 1, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	1
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN58@xmlNodeDum:

; 1086 :     }
; 1087 : 
; 1088 :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1089 :     if (ctxt->format == 2)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+40], 2
	jne	SHORT $LN59@xmlNodeDum

; 1090 :         xmlOutputBufferWriteWSNonSig(ctxt, 0);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteWSNonSig
	add	esp, 8
$LN59@xmlNodeDum:

; 1091 :     xmlOutputBufferWrite(buf, 1, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	1
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1092 :     ctxt->format = format;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _format$[ebp]
	mov	DWORD PTR [eax+40], ecx
$LN1@xmlNodeDum:

; 1093 : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNodeDumpOutputInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNodeListDumpOutput
_TEXT	SEGMENT
tv86 = -8						; size = 4
_buf$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlNodeListDumpOutput PROC				; COMDAT

; 811  : xmlNodeListDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 812  :     xmlOutputBufferPtr buf;
; 813  : 
; 814  :     if (cur == NULL) return;

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN4@xmlNodeLis
	jmp	$LN1@xmlNodeLis
$LN4@xmlNodeLis:

; 815  :     buf = ctxt->buf;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _buf$[ebp], ecx
$LN2@xmlNodeLis:

; 816  :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN1@xmlNodeLis

; 817  : 	if ((ctxt->format == 1) && (xmlIndentTreeOutput) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+40], 1
	jne	SHORT $LN5@xmlNodeLis
	call	___xmlIndentTreeOutput
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@xmlNodeLis
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN6@xmlNodeLis
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 8
	je	SHORT $LN6@xmlNodeLis
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 7
	jne	SHORT $LN5@xmlNodeLis
$LN6@xmlNodeLis:

; 818  : 	    ((cur->type == XML_ELEMENT_NODE) ||
; 819  : 	     (cur->type == XML_COMMENT_NODE) ||
; 820  : 	     (cur->type == XML_PI_NODE)))
; 821  : 	    xmlOutputBufferWrite(buf, ctxt->indent_size *

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax+36]
	cmp	edx, DWORD PTR [ecx+108]
	jle	SHORT $LN9@xmlNodeLis
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN10@xmlNodeLis
$LN9@xmlNodeLis:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR tv86[ebp], eax
$LN10@xmlNodeLis:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+112]
	imul	eax, DWORD PTR tv86[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN5@xmlNodeLis:

; 822  : 	                         (ctxt->level > ctxt->indent_nr ?
; 823  : 				  ctxt->indent_nr : ctxt->level),
; 824  : 				 ctxt->indent);
; 825  :         xmlNodeDumpOutputInternal(ctxt, cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNodeDumpOutputInternal
	add	esp, 8

; 826  : 	if (ctxt->format == 1) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+40], 1
	jne	SHORT $LN7@xmlNodeLis

; 827  : 	    xmlOutputBufferWrite(buf, 1, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	1
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN7@xmlNodeLis:

; 828  : 	}
; 829  : 	cur = cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$[ebp], ecx

; 830  :     }

	jmp	$LN2@xmlNodeLis
$LN1@xmlNodeLis:

; 831  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNodeListDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xhtmlNodeDumpOutput
_TEXT	SEGMENT
tv505 = -44						; size = 4
tv444 = -40						; size = 4
tv377 = -36						; size = 4
_indent$1 = -32						; size = 4
_httpequiv$2 = -28					; size = 4
_buf$ = -24						; size = 4
_end$ = -20						; size = 4
_start$ = -16						; size = 4
_tmp$ = -12						; size = 4
_addmeta$ = -8						; size = 4
_format$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xhtmlNodeDumpOutput PROC				; COMDAT

; 1449 : xhtmlNodeDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-44]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 1450 :     int format, addmeta = 0;

	mov	DWORD PTR _addmeta$[ebp], 0

; 1451 :     xmlNodePtr tmp;
; 1452 :     xmlChar *start, *end;
; 1453 :     xmlOutputBufferPtr buf;
; 1454 : 
; 1455 :     if (cur == NULL) return;

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN8@xhtmlNodeD
	jmp	$LN1@xhtmlNodeD
$LN8@xhtmlNodeD:

; 1456 :     if ((cur->type == XML_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 9
	je	SHORT $LN10@xhtmlNodeD
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	jne	SHORT $LN9@xhtmlNodeD
$LN10@xhtmlNodeD:

; 1457 :         (cur->type == XML_HTML_DOCUMENT_NODE)) {
; 1458 :         xmlDocContentDumpOutput(ctxt, (xmlDocPtr) cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDocContentDumpOutput
	add	esp, 8

; 1459 : 	return;

	jmp	$LN1@xhtmlNodeD
$LN9@xhtmlNodeD:

; 1460 :     }
; 1461 :     if (cur->type == XML_XINCLUDE_START)

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 19			; 00000013H
	jne	SHORT $LN11@xhtmlNodeD

; 1462 : 	return;

	jmp	$LN1@xhtmlNodeD
$LN11@xhtmlNodeD:

; 1463 :     if (cur->type == XML_XINCLUDE_END)

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 20			; 00000014H
	jne	SHORT $LN12@xhtmlNodeD

; 1464 : 	return;

	jmp	$LN1@xhtmlNodeD
$LN12@xhtmlNodeD:

; 1465 :     if (cur->type == XML_NAMESPACE_DECL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN13@xhtmlNodeD

; 1466 : 	xmlNsDumpOutputCtxt(ctxt, (xmlNsPtr) cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNsDumpOutputCtxt
	add	esp, 8

; 1467 : 	return;

	jmp	$LN1@xhtmlNodeD
$LN13@xhtmlNodeD:

; 1468 :     }
; 1469 :     if (cur->type == XML_DTD_NODE) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 14			; 0000000eH
	jne	SHORT $LN14@xhtmlNodeD

; 1470 :         xmlDtdDumpOutput(ctxt, (xmlDtdPtr) cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDtdDumpOutput
	add	esp, 8

; 1471 : 	return;

	jmp	$LN1@xhtmlNodeD
$LN14@xhtmlNodeD:

; 1472 :     }
; 1473 :     if (cur->type == XML_DOCUMENT_FRAG_NODE) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 11			; 0000000bH
	jne	SHORT $LN15@xhtmlNodeD

; 1474 :         xhtmlNodeListDumpOutput(ctxt, cur->children);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xhtmlNodeListDumpOutput
	add	esp, 8

; 1475 : 	return;

	jmp	$LN1@xhtmlNodeD
$LN15@xhtmlNodeD:

; 1476 :     }
; 1477 :     buf = ctxt->buf;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _buf$[ebp], edx

; 1478 :     if (cur->type == XML_ELEMENT_DECL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 15			; 0000000fH
	jne	SHORT $LN16@xhtmlNodeD

; 1479 :         xmlBufDumpElementDecl(buf->buffer, (xmlElementPtr) cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufDumpElementDecl
	add	esp, 8

; 1480 : 	return;

	jmp	$LN1@xhtmlNodeD
$LN16@xhtmlNodeD:

; 1481 :     }
; 1482 :     if (cur->type == XML_ATTRIBUTE_DECL) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 16			; 00000010H
	jne	SHORT $LN17@xhtmlNodeD

; 1483 :         xmlBufDumpAttributeDecl(buf->buffer, (xmlAttributePtr) cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufDumpAttributeDecl
	add	esp, 8

; 1484 : 	return;

	jmp	$LN1@xhtmlNodeD
$LN17@xhtmlNodeD:

; 1485 :     }
; 1486 :     if (cur->type == XML_ENTITY_DECL) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 17			; 00000011H
	jne	SHORT $LN18@xhtmlNodeD

; 1487 :         xmlBufDumpEntityDecl(buf->buffer, (xmlEntityPtr) cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufDumpEntityDecl
	add	esp, 8

; 1488 : 	return;

	jmp	$LN1@xhtmlNodeD
$LN18@xhtmlNodeD:

; 1489 :     }
; 1490 :     if (cur->type == XML_TEXT_NODE) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 3
	jne	SHORT $LN19@xhtmlNodeD

; 1491 : 	if (cur->content != NULL) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN20@xhtmlNodeD

; 1492 : 	    if ((cur->name == xmlStringText) ||

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+8], OFFSET _xmlStringText
	je	SHORT $LN23@xhtmlNodeD
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+8], OFFSET _xmlStringTextNoenc
	je	SHORT $LN21@xhtmlNodeD
$LN23@xhtmlNodeD:

; 1493 : 		(cur->name != xmlStringTextNoenc)) {
; 1494 :                 xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteEscape
	add	esp, 12					; 0000000cH

; 1495 : 	    } else {

	jmp	SHORT $LN20@xhtmlNodeD
$LN21@xhtmlNodeD:

; 1496 : 		/*
; 1497 : 		 * Disable escaping, needed for XSLT
; 1498 : 		 */
; 1499 : 		xmlOutputBufferWriteString(buf, (const char *) cur->content);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN20@xhtmlNodeD:

; 1500 : 	    }
; 1501 : 	}
; 1502 : 
; 1503 : 	return;

	jmp	$LN1@xhtmlNodeD
$LN19@xhtmlNodeD:

; 1504 :     }
; 1505 :     if (cur->type == XML_PI_NODE) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 7
	jne	$LN24@xhtmlNodeD

; 1506 : 	if (cur->content != NULL) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN25@xhtmlNodeD

; 1507 : 	    xmlOutputBufferWrite(buf, 2, "<?");

	push	OFFSET ??_C@_02HFBBBACF@?$DM?$DP@
	push	2
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1508 : 	    xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1509 : 	    if (cur->content != NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN27@xhtmlNodeD

; 1510 : 		xmlOutputBufferWrite(buf, 1, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	1
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1511 : 		xmlOutputBufferWriteString(buf, (const char *)cur->content);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN27@xhtmlNodeD:

; 1512 : 	    }
; 1513 : 	    xmlOutputBufferWrite(buf, 2, "?>");

	push	OFFSET ??_C@_02GOEMJPDN@?$DP?$DO@
	push	2
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1514 : 	} else {

	jmp	SHORT $LN26@xhtmlNodeD
$LN25@xhtmlNodeD:

; 1515 : 	    xmlOutputBufferWrite(buf, 2, "<?");

	push	OFFSET ??_C@_02HFBBBACF@?$DM?$DP@
	push	2
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1516 : 	    xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1517 : 	    xmlOutputBufferWrite(buf, 2, "?>");

	push	OFFSET ??_C@_02GOEMJPDN@?$DP?$DO@
	push	2
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN26@xhtmlNodeD:

; 1518 : 	}
; 1519 : 	return;

	jmp	$LN1@xhtmlNodeD
$LN24@xhtmlNodeD:

; 1520 :     }
; 1521 :     if (cur->type == XML_COMMENT_NODE) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 8
	jne	SHORT $LN28@xhtmlNodeD

; 1522 : 	if (cur->content != NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN29@xhtmlNodeD

; 1523 : 	    xmlOutputBufferWrite(buf, 4, "<!--");

	push	OFFSET ??_C@_04FFDNBKGC@?$DM?$CB?9?9@
	push	4
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1524 : 	    xmlOutputBufferWriteString(buf, (const char *)cur->content);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1525 : 	    xmlOutputBufferWrite(buf, 3, "-->");

	push	OFFSET ??_C@_03PNLDJJMO@?9?9?$DO@
	push	3
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN29@xhtmlNodeD:

; 1526 : 	}
; 1527 : 	return;

	jmp	$LN1@xhtmlNodeD
$LN28@xhtmlNodeD:

; 1528 :     }
; 1529 :     if (cur->type == XML_ENTITY_REF_NODE) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 5
	jne	SHORT $LN30@xhtmlNodeD

; 1530 :         xmlOutputBufferWrite(buf, 1, "&");

	push	OFFSET ??_C@_01HNPIGOCE@?$CG@
	push	1
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1531 : 	xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1532 :         xmlOutputBufferWrite(buf, 1, ";");

	push	OFFSET ??_C@_01ICJEACDI@?$DL@
	push	1
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1533 : 	return;

	jmp	$LN1@xhtmlNodeD
$LN30@xhtmlNodeD:

; 1534 :     }
; 1535 :     if (cur->type == XML_CDATA_SECTION_NODE) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 4
	jne	$LN31@xhtmlNodeD

; 1536 : 	if (cur->content == NULL || *cur->content == '\0') {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN34@xhtmlNodeD
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN32@xhtmlNodeD
$LN34@xhtmlNodeD:

; 1537 : 	    xmlOutputBufferWrite(buf, 12, "<![CDATA[]]>");

	push	OFFSET ??_C@_0N@OGBMJHND@?$DM?$CB?$FLCDATA?$FL?$FN?$FN?$DO@
	push	12					; 0000000cH
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1538 : 	} else {

	jmp	$LN33@xhtmlNodeD
$LN32@xhtmlNodeD:

; 1539 : 	    start = end = cur->content;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _end$[ebp], ecx
	mov	edx, DWORD PTR _end$[ebp]
	mov	DWORD PTR _start$[ebp], edx
$LN2@xhtmlNodeD:

; 1540 : 	    while (*end != '\0') {

	mov	eax, DWORD PTR _end$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@xhtmlNodeD

; 1541 : 		if (*end == ']' && *(end + 1) == ']' && *(end + 2) == '>') {

	mov	edx, DWORD PTR _end$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 93					; 0000005dH
	jne	SHORT $LN35@xhtmlNodeD
	mov	ecx, DWORD PTR _end$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 93					; 0000005dH
	jne	SHORT $LN35@xhtmlNodeD
	mov	eax, DWORD PTR _end$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 62					; 0000003eH
	jne	SHORT $LN35@xhtmlNodeD

; 1542 : 		    end = end + 2;

	mov	edx, DWORD PTR _end$[ebp]
	add	edx, 2
	mov	DWORD PTR _end$[ebp], edx

; 1543 : 		    xmlOutputBufferWrite(buf, 9, "<![CDATA[");

	push	OFFSET ??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@
	push	9
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1544 : 		    xmlOutputBufferWrite(buf, end - start, (const char *)start);

	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	sub	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1545 : 		    xmlOutputBufferWrite(buf, 3, "]]>");

	push	OFFSET ??_C@_03MCHNFBAC@?$FN?$FN?$DO@
	push	3
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1546 : 		    start = end;

	mov	edx, DWORD PTR _end$[ebp]
	mov	DWORD PTR _start$[ebp], edx
$LN35@xhtmlNodeD:

; 1547 : 		}
; 1548 : 		end++;

	mov	eax, DWORD PTR _end$[ebp]
	add	eax, 1
	mov	DWORD PTR _end$[ebp], eax

; 1549 : 	    }

	jmp	$LN2@xhtmlNodeD
$LN3@xhtmlNodeD:

; 1550 : 	    if (start != end) {

	mov	ecx, DWORD PTR _start$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	je	SHORT $LN33@xhtmlNodeD

; 1551 : 		xmlOutputBufferWrite(buf, 9, "<![CDATA[");

	push	OFFSET ??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@
	push	9
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1552 : 		xmlOutputBufferWriteString(buf, (const char *)start);

	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1553 : 		xmlOutputBufferWrite(buf, 3, "]]>");

	push	OFFSET ??_C@_03MCHNFBAC@?$FN?$FN?$DO@
	push	3
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN33@xhtmlNodeD:

; 1554 : 	    }
; 1555 : 	}
; 1556 : 	return;

	jmp	$LN1@xhtmlNodeD
$LN31@xhtmlNodeD:

; 1557 :     }
; 1558 :     if (cur->type == XML_ATTRIBUTE_NODE) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 2
	jne	SHORT $LN37@xhtmlNodeD

; 1559 :         xmlAttrDumpOutput(ctxt, (xmlAttrPtr) cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlAttrDumpOutput
	add	esp, 8

; 1560 : 	return;

	jmp	$LN1@xhtmlNodeD
$LN37@xhtmlNodeD:

; 1561 :     }
; 1562 : 
; 1563 :     format = ctxt->format;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _format$[ebp], ecx

; 1564 :     if (format == 1) {

	cmp	DWORD PTR _format$[ebp], 1
	jne	SHORT $LN38@xhtmlNodeD

; 1565 : 	tmp = cur->children;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _tmp$[ebp], eax
$LN4@xhtmlNodeD:

; 1566 : 	while (tmp != NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN38@xhtmlNodeD

; 1567 : 	    if ((tmp->type == XML_TEXT_NODE) ||

	mov	ecx, DWORD PTR _tmp$[ebp]
	cmp	DWORD PTR [ecx+4], 3
	je	SHORT $LN40@xhtmlNodeD
	mov	edx, DWORD PTR _tmp$[ebp]
	cmp	DWORD PTR [edx+4], 5
	jne	SHORT $LN39@xhtmlNodeD
$LN40@xhtmlNodeD:

; 1568 : 		(tmp->type == XML_ENTITY_REF_NODE)) {
; 1569 : 		format = 0;

	mov	DWORD PTR _format$[ebp], 0

; 1570 : 		break;

	jmp	SHORT $LN38@xhtmlNodeD
$LN39@xhtmlNodeD:

; 1571 : 	    }
; 1572 : 	    tmp = tmp->next;

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _tmp$[ebp], ecx

; 1573 : 	}

	jmp	SHORT $LN4@xhtmlNodeD
$LN38@xhtmlNodeD:

; 1574 :     }
; 1575 :     xmlOutputBufferWrite(buf, 1, "<");

	push	OFFSET ??_C@_01MNNFJEPP@?$DM@
	push	1
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1576 :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN41@xhtmlNodeD
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN41@xhtmlNodeD

; 1577 :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1578 : 	xmlOutputBufferWrite(buf, 1, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	1
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN41@xhtmlNodeD:

; 1579 :     }
; 1580 : 
; 1581 :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1582 :     if (cur->nsDef)

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN42@xhtmlNodeD

; 1583 :         xmlNsListDumpOutputCtxt(ctxt, cur->nsDef);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNsListDumpOutputCtxt
	add	esp, 8
$LN42@xhtmlNodeD:

; 1584 :     if ((xmlStrEqual(cur->name, BAD_CAST "html") &&
; 1585 : 	(cur->ns == NULL) && (cur->nsDef == NULL))) {

	push	OFFSET ??_C@_04PNIFHPHN@html@
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN43@xhtmlNodeD
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jne	SHORT $LN43@xhtmlNodeD
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN43@xhtmlNodeD

; 1586 : 	/*
; 1587 : 	 * 3.1.1. Strictly Conforming Documents A.3.1.1 3/
; 1588 : 	 */
; 1589 : 	xmlOutputBufferWriteString(buf,

	push	OFFSET ??_C@_0CG@NOKOIAPK@?5xmlns?$DN?$CChttp?3?1?1www?4w3?4org?11999?1@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN43@xhtmlNodeD:

; 1590 : 		" xmlns=\"http://www.w3.org/1999/xhtml\"");
; 1591 :     }
; 1592 :     if (cur->properties != NULL)

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN44@xhtmlNodeD

; 1593 :         xhtmlAttrListDumpOutput(ctxt, cur->properties);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xhtmlAttrListDumpOutput
	add	esp, 8
$LN44@xhtmlNodeD:

; 1594 : 
; 1595 :     if ((cur->type == XML_ELEMENT_NODE) &&
; 1596 :         (cur->parent != NULL) &&
; 1597 :         (cur->parent->parent == (xmlNodePtr) cur->doc) &&
; 1598 :         xmlStrEqual(cur->name, BAD_CAST"head") &&

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	$LN45@xhtmlNodeD
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	$LN45@xhtmlNodeD
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+32]
	jne	$LN45@xhtmlNodeD
	push	OFFSET ??_C@_04NEODDMOL@head@
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN45@xhtmlNodeD
	push	OFFSET ??_C@_04PNIFHPHN@html@
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN45@xhtmlNodeD

; 1599 :         xmlStrEqual(cur->parent->name, BAD_CAST"html")) {
; 1600 : 
; 1601 :         tmp = cur->children;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _tmp$[ebp], eax
$LN6@xhtmlNodeD:

; 1602 :         while (tmp != NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	je	$LN7@xhtmlNodeD

; 1603 :             if (xmlStrEqual(tmp->name, BAD_CAST"meta")) {

	push	OFFSET ??_C@_04HLJJCGEF@meta@
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN46@xhtmlNodeD

; 1604 :                 xmlChar *httpequiv;
; 1605 : 
; 1606 :                 httpequiv = xmlGetProp(tmp, BAD_CAST"http-equiv");

	push	OFFSET ??_C@_0L@NALBGOHO@http?9equiv@
	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _httpequiv$2[ebp], eax

; 1607 :                 if (httpequiv != NULL) {

	cmp	DWORD PTR _httpequiv$2[ebp], 0
	je	SHORT $LN46@xhtmlNodeD

; 1608 :                     if (xmlStrcasecmp(httpequiv, BAD_CAST"Content-Type") == 0) {

	push	OFFSET ??_C@_0N@LAFFMKKA@Content?9Type@
	mov	ecx, DWORD PTR _httpequiv$2[ebp]
	push	ecx
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN48@xhtmlNodeD

; 1609 :                         xmlFree(httpequiv);

	mov	esi, esp
	mov	edx, DWORD PTR _httpequiv$2[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1610 :                         break;

	jmp	SHORT $LN7@xhtmlNodeD
$LN48@xhtmlNodeD:

; 1611 :                     }
; 1612 :                     xmlFree(httpequiv);

	mov	esi, esp
	mov	eax, DWORD PTR _httpequiv$2[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN46@xhtmlNodeD:

; 1613 :                 }
; 1614 :             }
; 1615 :             tmp = tmp->next;

	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _tmp$[ebp], edx

; 1616 :         }

	jmp	$LN6@xhtmlNodeD
$LN7@xhtmlNodeD:

; 1617 :         if (tmp == NULL)

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN45@xhtmlNodeD

; 1618 :             addmeta = 1;

	mov	DWORD PTR _addmeta$[ebp], 1
$LN45@xhtmlNodeD:

; 1619 :     }
; 1620 : 
; 1621 :     if ((cur->type == XML_ELEMENT_NODE) && (cur->children == NULL)) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	$LN50@xhtmlNodeD
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	$LN50@xhtmlNodeD

; 1622 : 	if (((cur->ns == NULL) || (cur->ns->prefix == NULL)) &&

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN53@xhtmlNodeD
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN51@xhtmlNodeD
$LN53@xhtmlNodeD:
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xhtmlIsEmpty
	add	esp, 4
	cmp	eax, 1
	jne	SHORT $LN51@xhtmlNodeD
	cmp	DWORD PTR _addmeta$[ebp], 0
	jne	SHORT $LN51@xhtmlNodeD

; 1623 : 	    ((xhtmlIsEmpty(cur) == 1) && (addmeta == 0))) {
; 1624 : 	    /*
; 1625 : 	     * C.2. Empty Elements
; 1626 : 	     */
; 1627 : 	    xmlOutputBufferWrite(buf, 3, " />");

	push	OFFSET ??_C@_03MFNJFHN@?5?1?$DO@
	push	3
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1628 : 	} else {

	jmp	$LN52@xhtmlNodeD
$LN51@xhtmlNodeD:

; 1629 : 		if (addmeta == 1) {

	cmp	DWORD PTR _addmeta$[ebp], 1
	jne	$LN54@xhtmlNodeD

; 1630 : 			xmlOutputBufferWrite(buf, 1, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	1
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1631 : 			if (ctxt->format == 1) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+40], 1
	jne	SHORT $LN56@xhtmlNodeD

; 1632 : 				xmlOutputBufferWrite(buf, 1, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	1
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1633 : 				if (xmlIndentTreeOutput)

	call	___xmlIndentTreeOutput
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN56@xhtmlNodeD

; 1634 : 					xmlOutputBufferWrite(buf, ctxt->indent_size *

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	edx, DWORD PTR [eax+108]
	jle	SHORT $LN75@xhtmlNodeD
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR tv377[ebp], edx
	jmp	SHORT $LN76@xhtmlNodeD
$LN75@xhtmlNodeD:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	add	ecx, 1
	mov	DWORD PTR tv377[ebp], ecx
$LN76@xhtmlNodeD:
	mov	edx, DWORD PTR _ctxt$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	imul	ecx, DWORD PTR tv377[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN56@xhtmlNodeD:

; 1635 : 					(ctxt->level + 1 > ctxt->indent_nr ?
; 1636 : 					ctxt->indent_nr : ctxt->level + 1), ctxt->indent);
; 1637 : 			}
; 1638 : 			xmlOutputBufferWriteString(buf,

	push	OFFSET ??_C@_0DN@ILJMDLKG@?$DMmeta?5http?9equiv?$DN?$CCContent?9Type?$CC@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1639 : 				"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=");
; 1640 : 			if (ctxt->encoding) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN58@xhtmlNodeD

; 1641 : 				xmlOutputBufferWriteString(buf, (const char *)ctxt->encoding);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1642 : 			} else {

	jmp	SHORT $LN59@xhtmlNodeD
$LN58@xhtmlNodeD:

; 1643 : 				xmlOutputBufferWrite(buf, 5, "UTF-8");

	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	push	5
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN59@xhtmlNodeD:

; 1644 : 			}
; 1645 : 			xmlOutputBufferWrite(buf, 4, "\" />");

	push	OFFSET ??_C@_04FADKMBBI@?$CC?5?1?$DO@
	push	4
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1646 : 			if (ctxt->format == 1)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+40], 1
	jne	SHORT $LN60@xhtmlNodeD

; 1647 : 				xmlOutputBufferWrite(buf, 1, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	1
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN60@xhtmlNodeD:

; 1648 : 		} else {

	jmp	SHORT $LN55@xhtmlNodeD
$LN54@xhtmlNodeD:

; 1649 : 			xmlOutputBufferWrite(buf, 1, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	1
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN55@xhtmlNodeD:

; 1650 : 		}
; 1651 : 	    /*
; 1652 : 	     * C.3. Element Minimization and Empty Element Content
; 1653 : 	     */
; 1654 : 	    xmlOutputBufferWrite(buf, 2, "</");

	push	OFFSET ??_C@_02DPNDACHE@?$DM?1@
	push	2
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1655 : 	    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN61@xhtmlNodeD
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN61@xhtmlNodeD

; 1656 : 		xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1657 : 		xmlOutputBufferWrite(buf, 1, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	1
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN61@xhtmlNodeD:

; 1658 : 	    }
; 1659 : 	    xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1660 : 	    xmlOutputBufferWrite(buf, 1, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	1
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN52@xhtmlNodeD:

; 1661 : 	}
; 1662 : 	return;

	jmp	$LN1@xhtmlNodeD
$LN50@xhtmlNodeD:

; 1663 :     }
; 1664 :     xmlOutputBufferWrite(buf, 1, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	1
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1665 : 	if (addmeta == 1) {

	cmp	DWORD PTR _addmeta$[ebp], 1
	jne	$LN62@xhtmlNodeD

; 1666 : 		if (ctxt->format == 1) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+40], 1
	jne	SHORT $LN63@xhtmlNodeD

; 1667 : 			xmlOutputBufferWrite(buf, 1, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	1
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1668 : 			if (xmlIndentTreeOutput)

	call	___xmlIndentTreeOutput
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN63@xhtmlNodeD

; 1669 : 				xmlOutputBufferWrite(buf, ctxt->indent_size *

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	eax, DWORD PTR [ecx+108]
	jle	SHORT $LN77@xhtmlNodeD
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR tv444[ebp], eax
	jmp	SHORT $LN78@xhtmlNodeD
$LN77@xhtmlNodeD:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, 1
	mov	DWORD PTR tv444[ebp], edx
$LN78@xhtmlNodeD:
	mov	eax, DWORD PTR _ctxt$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	imul	edx, DWORD PTR tv444[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN63@xhtmlNodeD:

; 1670 : 				(ctxt->level + 1 > ctxt->indent_nr ?
; 1671 : 				ctxt->indent_nr : ctxt->level + 1), ctxt->indent);
; 1672 : 		}
; 1673 : 		xmlOutputBufferWriteString(buf,

	push	OFFSET ??_C@_0DN@ILJMDLKG@?$DMmeta?5http?9equiv?$DN?$CCContent?9Type?$CC@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1674 : 			"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=");
; 1675 : 		if (ctxt->encoding) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN65@xhtmlNodeD

; 1676 : 			xmlOutputBufferWriteString(buf, (const char *)ctxt->encoding);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1677 : 		} else {

	jmp	SHORT $LN66@xhtmlNodeD
$LN65@xhtmlNodeD:

; 1678 : 			xmlOutputBufferWrite(buf, 5, "UTF-8");

	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	push	5
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN66@xhtmlNodeD:

; 1679 : 		}
; 1680 : 		xmlOutputBufferWrite(buf, 4, "\" />");

	push	OFFSET ??_C@_04FADKMBBI@?$CC?5?1?$DO@
	push	4
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN62@xhtmlNodeD:

; 1681 : 	}
; 1682 :     if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL)) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 1
	je	SHORT $LN67@xhtmlNodeD
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN67@xhtmlNodeD

; 1683 : 	xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteEscape
	add	esp, 12					; 0000000cH
$LN67@xhtmlNodeD:

; 1684 :     }
; 1685 : 
; 1686 : #if 0
; 1687 :     /*
; 1688 :     * This was removed due to problems with HTML processors.
; 1689 :     * See bug #345147.
; 1690 :     */
; 1691 :     /*
; 1692 :      * 4.8. Script and Style elements
; 1693 :      */
; 1694 :     if ((cur->type == XML_ELEMENT_NODE) &&
; 1695 : 	((xmlStrEqual(cur->name, BAD_CAST "script")) ||
; 1696 : 	 (xmlStrEqual(cur->name, BAD_CAST "style"))) &&
; 1697 : 	((cur->ns == NULL) ||
; 1698 : 	 (xmlStrEqual(cur->ns->href, XHTML_NS_NAME)))) {
; 1699 : 	xmlNodePtr child = cur->children;
; 1700 : 
; 1701 : 	while (child != NULL) {
; 1702 : 	    if (child->type == XML_TEXT_NODE) {
; 1703 : 		if ((xmlStrchr(child->content, '<') == NULL) &&
; 1704 : 		    (xmlStrchr(child->content, '&') == NULL) &&
; 1705 : 		    (xmlStrstr(child->content, BAD_CAST "]]>") == NULL)) {
; 1706 : 		    /* Nothing to escape, so just output as is... */
; 1707 : 		    /* FIXME: Should we do something about "--" also? */
; 1708 : 		    int level = ctxt->level;
; 1709 : 		    int indent = ctxt->format;
; 1710 : 
; 1711 : 		    ctxt->level = 0;
; 1712 : 		    ctxt->format = 0;
; 1713 : 		    xmlOutputBufferWriteString(buf, (const char *) child->content);
; 1714 : 		    /* (We cannot use xhtmlNodeDumpOutput() here because
; 1715 : 		     * we wish to leave '>' unescaped!) */
; 1716 : 		    ctxt->level = level;
; 1717 : 		    ctxt->format = indent;
; 1718 : 		} else {
; 1719 : 		    /* We must use a CDATA section.  Unfortunately,
; 1720 : 		     * this will break CSS and JavaScript when read by
; 1721 : 		     * a browser in HTML4-compliant mode. :-( */
; 1722 : 		    start = end = child->content;
; 1723 : 		    while (*end != '\0') {
; 1724 : 			if (*end == ']' &&
; 1725 : 			    *(end + 1) == ']' &&
; 1726 : 			    *(end + 2) == '>') {
; 1727 : 			    end = end + 2;
; 1728 : 			    xmlOutputBufferWrite(buf, 9, "<![CDATA[");
; 1729 : 			    xmlOutputBufferWrite(buf, end - start,
; 1730 : 						 (const char *)start);
; 1731 : 			    xmlOutputBufferWrite(buf, 3, "]]>");
; 1732 : 			    start = end;
; 1733 : 			}
; 1734 : 			end++;
; 1735 : 		    }
; 1736 : 		    if (start != end) {
; 1737 : 			xmlOutputBufferWrite(buf, 9, "<![CDATA[");
; 1738 : 			xmlOutputBufferWrite(buf, end - start,
; 1739 : 			                     (const char *)start);
; 1740 : 			xmlOutputBufferWrite(buf, 3, "]]>");
; 1741 : 		    }
; 1742 : 		}
; 1743 : 	    } else {
; 1744 : 		int level = ctxt->level;
; 1745 : 		int indent = ctxt->format;
; 1746 : 
; 1747 : 		ctxt->level = 0;
; 1748 : 		ctxt->format = 0;
; 1749 : 		xhtmlNodeDumpOutput(ctxt, child);
; 1750 : 		ctxt->level = level;
; 1751 : 		ctxt->format = indent;
; 1752 : 	    }
; 1753 : 	    child = child->next;
; 1754 : 	}
; 1755 :     }
; 1756 : #endif
; 1757 : 
; 1758 :     if (cur->children != NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	$LN68@xhtmlNodeD

; 1759 : 	int indent = ctxt->format;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _indent$1[ebp], edx

; 1760 : 
; 1761 : 	if (format == 1) xmlOutputBufferWrite(buf, 1, "\n");

	cmp	DWORD PTR _format$[ebp], 1
	jne	SHORT $LN69@xhtmlNodeD
	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	1
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN69@xhtmlNodeD:

; 1762 : 	if (ctxt->level >= 0) ctxt->level++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	jl	SHORT $LN70@xhtmlNodeD
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN70@xhtmlNodeD:

; 1763 : 	ctxt->format = format;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _format$[ebp]
	mov	DWORD PTR [edx+40], eax

; 1764 : 	xhtmlNodeListDumpOutput(ctxt, cur->children);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xhtmlNodeListDumpOutput
	add	esp, 8

; 1765 : 	if (ctxt->level > 0) ctxt->level--;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	jle	SHORT $LN71@xhtmlNodeD
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	sub	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN71@xhtmlNodeD:

; 1766 : 	ctxt->format = indent;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _indent$1[ebp]
	mov	DWORD PTR [edx+40], eax

; 1767 : 	if ((xmlIndentTreeOutput) && (format == 1))

	call	___xmlIndentTreeOutput
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN68@xhtmlNodeD
	cmp	DWORD PTR _format$[ebp], 1
	jne	SHORT $LN68@xhtmlNodeD

; 1768 : 	    xmlOutputBufferWrite(buf, ctxt->indent_size *

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+36]
	cmp	eax, DWORD PTR [edx+108]
	jle	SHORT $LN79@xhtmlNodeD
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR tv505[ebp], edx
	jmp	SHORT $LN80@xhtmlNodeD
$LN79@xhtmlNodeD:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR tv505[ebp], ecx
$LN80@xhtmlNodeD:
	mov	edx, DWORD PTR _ctxt$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	imul	ecx, DWORD PTR tv505[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN68@xhtmlNodeD:

; 1769 : 	                         (ctxt->level > ctxt->indent_nr ?
; 1770 : 				  ctxt->indent_nr : ctxt->level),
; 1771 : 				 ctxt->indent);
; 1772 :     }
; 1773 :     xmlOutputBufferWrite(buf, 2, "</");

	push	OFFSET ??_C@_02DPNDACHE@?$DM?1@
	push	2
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1774 :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN73@xhtmlNodeD
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN73@xhtmlNodeD

; 1775 :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1776 : 	xmlOutputBufferWrite(buf, 1, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	1
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN73@xhtmlNodeD:

; 1777 :     }
; 1778 : 
; 1779 :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1780 :     xmlOutputBufferWrite(buf, 1, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	1
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN1@xhtmlNodeD:

; 1781 : }

	pop	edi
	pop	esi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xhtmlNodeDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveClearEncoding
_TEXT	SEGMENT
_buf$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlSaveClearEncoding PROC				; COMDAT

; 580  : static int xmlSaveClearEncoding(xmlSaveCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 581  :     xmlOutputBufferPtr buf = ctxt->buf;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _buf$[ebp], ecx

; 582  :     xmlOutputBufferFlush(buf);

	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferFlush
	add	esp, 4

; 583  :     xmlCharEncCloseFunc(buf->encoder);

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_xmlCharEncCloseFunc
	add	esp, 4

; 584  :     xmlBufFree(buf->conv);

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_xmlBufFree
	add	esp, 4

; 585  :     buf->encoder = NULL;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 586  :     buf->conv = NULL;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+20], 0

; 587  :     return(0);

	xor	eax, eax

; 588  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSaveClearEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveSwitchEncoding
_TEXT	SEGMENT
_buf$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_encoding$ = 12						; size = 4
_xmlSaveSwitchEncoding PROC				; COMDAT

; 556  : static int xmlSaveSwitchEncoding(xmlSaveCtxtPtr ctxt, const char *encoding) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 557  :     xmlOutputBufferPtr buf = ctxt->buf;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _buf$[ebp], ecx

; 558  : 
; 559  :     if ((encoding != NULL) && (buf->encoder == NULL) && (buf->conv == NULL)) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	$LN2@xmlSaveSwi
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN2@xmlSaveSwi
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN2@xmlSaveSwi

; 560  : 	buf->encoder = xmlFindCharEncodingHandler((const char *)encoding);

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+12], eax

; 561  : 	if (buf->encoder == NULL) {

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@xmlSaveSwi

; 562  : 	    xmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL,

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	push	0
	push	1403					; 0000057bH
	call	_xmlSaveErr
	add	esp, 12					; 0000000cH

; 563  : 		       (const char *)encoding);
; 564  : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSaveSwi
$LN3@xmlSaveSwi:

; 565  : 	}
; 566  : 	buf->conv = xmlBufCreate();

	call	_xmlBufCreate
	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+20], eax

; 567  : 	if (buf->conv == NULL) {

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN4@xmlSaveSwi

; 568  : 	    xmlCharEncCloseFunc(buf->encoder);

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_xmlCharEncCloseFunc
	add	esp, 4

; 569  : 	    xmlSaveErrMemory("creating encoding buffer");

	push	OFFSET ??_C@_0BJ@ICFHKFLM@creating?5encoding?5buffer@
	call	_xmlSaveErrMemory
	add	esp, 4

; 570  : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSaveSwi
$LN4@xmlSaveSwi:

; 571  : 	}
; 572  : 	/*
; 573  : 	 * initialize the state, e.g. if outputting a BOM
; 574  : 	 */
; 575  :         xmlCharEncOutput(buf, 1);

	push	1
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlCharEncOutput
	add	esp, 8
$LN2@xmlSaveSwi:

; 576  :     }
; 577  :     return(0);

	xor	eax, eax
$LN1@xmlSaveSwi:

; 578  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSaveSwitchEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlAttrSerializeContent
_TEXT	SEGMENT
tv67 = -8						; size = 4
_children$ = -4						; size = 4
_buf$ = 8						; size = 4
_attr$ = 12						; size = 4
_xmlAttrSerializeContent PROC				; COMDAT

; 436  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 437  :     xmlNodePtr children;
; 438  : 
; 439  :     children = attr->children;

	mov	eax, DWORD PTR _attr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _children$[ebp], ecx
$LN2@xmlAttrSer:

; 440  :     while (children != NULL) {

	cmp	DWORD PTR _children$[ebp], 0
	je	$LN1@xmlAttrSer

; 441  :         switch (children->type) {

	mov	edx, DWORD PTR _children$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv67[ebp], eax
	cmp	DWORD PTR tv67[ebp], 3
	je	SHORT $LN6@xmlAttrSer
	cmp	DWORD PTR tv67[ebp], 5
	je	SHORT $LN7@xmlAttrSer
	jmp	SHORT $LN4@xmlAttrSer
$LN6@xmlAttrSer:

; 442  :             case XML_TEXT_NODE:
; 443  : 	        xmlBufAttrSerializeTxtContent(buf->buffer, attr->doc,

	mov	ecx, DWORD PTR _children$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _attr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _attr$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufAttrSerializeTxtContent
	add	esp, 16					; 00000010H

; 444  : 		                              attr, children->content);
; 445  : 		break;

	jmp	SHORT $LN4@xmlAttrSer
$LN7@xmlAttrSer:

; 446  :             case XML_ENTITY_REF_NODE:
; 447  :                 xmlBufAdd(buf->buffer, BAD_CAST "&", 1);

	push	1
	push	OFFSET ??_C@_01HNPIGOCE@?$CG@
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 448  :                 xmlBufAdd(buf->buffer, children->name,

	mov	ecx, DWORD PTR _children$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrlen
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _children$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 449  :                              xmlStrlen(children->name));
; 450  :                 xmlBufAdd(buf->buffer, BAD_CAST ";", 1);

	push	1
	push	OFFSET ??_C@_01ICJEACDI@?$DL@
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN4@xmlAttrSer:

; 451  :                 break;
; 452  :             default:
; 453  :                 /* should not happen unless we have a badly built tree */
; 454  :                 break;
; 455  :         }
; 456  :         children = children->next;

	mov	eax, DWORD PTR _children$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _children$[ebp], ecx

; 457  :     }

	jmp	$LN2@xmlAttrSer
$LN1@xmlAttrSer:

; 458  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAttrSerializeContent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNewSaveCtxt
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_encoding$ = 8						; size = 4
_options$ = 12						; size = 4
_xmlNewSaveCtxt PROC					; COMDAT

; 381  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 382  :     xmlSaveCtxtPtr ret;
; 383  : 
; 384  :     ret = (xmlSaveCtxtPtr) xmlMalloc(sizeof(xmlSaveCtxt));

	mov	esi, esp
	push	124					; 0000007cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 385  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlNewSave

; 386  : 	xmlSaveErrMemory("creating saving context");

	push	OFFSET ??_C@_0BI@FGAKHCKD@creating?5saving?5context@
	call	_xmlSaveErrMemory
	add	esp, 4

; 387  : 	return ( NULL );

	xor	eax, eax
	jmp	$LN1@xmlNewSave
$LN2@xmlNewSave:

; 388  :     }
; 389  :     memset(ret, 0, sizeof(xmlSaveCtxt));

	push	124					; 0000007cH
	push	0
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 390  : 
; 391  :     if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN3@xmlNewSave

; 392  :         ret->handler = xmlFindCharEncodingHandler(encoding);

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+20], eax

; 393  : 	if (ret->handler == NULL) {

	mov	eax, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN4@xmlNewSave

; 394  : 	    xmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	push	0
	push	1403					; 0000057bH
	call	_xmlSaveErr
	add	esp, 12					; 0000000cH

; 395  :             xmlFreeSaveCtxt(ret);

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlFreeSaveCtxt
	add	esp, 4

; 396  : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNewSave
$LN4@xmlNewSave:

; 397  : 	}
; 398  :         ret->encoding = xmlStrdup((const xmlChar *)encoding);

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 399  : 	ret->escape = NULL;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+116], 0
$LN3@xmlNewSave:

; 400  :     }
; 401  :     xmlSaveCtxtInit(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlSaveCtxtInit
	add	esp, 4

; 402  : 
; 403  :     /*
; 404  :      * Use the options
; 405  :      */
; 406  : 
; 407  :     /* Re-check this option as it may already have been set */
; 408  :     if ((ret->options & XML_SAVE_NO_EMPTY) && ! (options & XML_SAVE_NO_EMPTY)) {

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 4
	je	SHORT $LN5@xmlNewSave
	mov	eax, DWORD PTR _options$[ebp]
	and	eax, 4
	jne	SHORT $LN5@xmlNewSave

; 409  : 	options |= XML_SAVE_NO_EMPTY;

	mov	ecx, DWORD PTR _options$[ebp]
	or	ecx, 4
	mov	DWORD PTR _options$[ebp], ecx
$LN5@xmlNewSave:

; 410  :     }
; 411  : 
; 412  :     ret->options = options;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _options$[ebp]
	mov	DWORD PTR [edx+32], eax

; 413  :     if (options & XML_SAVE_FORMAT)

	mov	ecx, DWORD PTR _options$[ebp]
	and	ecx, 1
	je	SHORT $LN6@xmlNewSave

; 414  :         ret->format = 1;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+40], 1
	jmp	SHORT $LN7@xmlNewSave
$LN6@xmlNewSave:

; 415  :     else if (options & XML_SAVE_WSNONSIG)

	mov	eax, DWORD PTR _options$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN7@xmlNewSave

; 416  :         ret->format = 2;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+40], 2
$LN7@xmlNewSave:

; 417  : 
; 418  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlNewSave:

; 419  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNewSaveCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlFreeSaveCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlFreeSaveCtxt PROC					; COMDAT

; 363  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 364  :     if (ctxt == NULL) return;

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlFreeSav
	jmp	SHORT $LN1@xmlFreeSav
$LN2@xmlFreeSav:

; 365  :     if (ctxt->encoding != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN3@xmlFreeSav

; 366  :         xmlFree((char *) ctxt->encoding);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlFreeSav:

; 367  :     if (ctxt->buf != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN4@xmlFreeSav

; 368  :         xmlOutputBufferClose(ctxt->buf);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_xmlOutputBufferClose
	add	esp, 4
$LN4@xmlFreeSav:

; 369  :     xmlFree(ctxt);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlFreeSav:

; 370  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFreeSaveCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveCtxtInit
_TEXT	SEGMENT
_len$ = -8						; size = 4
_i$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlSaveCtxtInit PROC					; COMDAT

; 332  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 333  :     int i;
; 334  :     int len;
; 335  : 
; 336  :     if (ctxt == NULL) return;

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN5@xmlSaveCtx
	jmp	$LN1@xmlSaveCtx
$LN5@xmlSaveCtx:

; 337  :     if ((ctxt->encoding == NULL) && (ctxt->escape == NULL))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN6@xmlSaveCtx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+116], 0
	jne	SHORT $LN6@xmlSaveCtx

; 338  :         ctxt->escape = xmlEscapeEntities;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+116], OFFSET _xmlEscapeEntities
$LN6@xmlSaveCtx:

; 339  :     len = xmlStrlen((xmlChar *)xmlTreeIndentString);

	call	___xmlTreeIndentString
	mov	eax, DWORD PTR [eax]
	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 340  :     if ((xmlTreeIndentString == NULL) || (len == 0)) {

	call	___xmlTreeIndentString
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@xmlSaveCtx
	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN7@xmlSaveCtx
$LN9@xmlSaveCtx:

; 341  :         memset(&ctxt->indent[0], 0, MAX_INDENT + 1);

	push	61					; 0000003dH
	push	0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ctxt$[ebp]
	lea	ecx, DWORD PTR [eax+edx+44]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 342  :     } else {

	jmp	SHORT $LN8@xmlSaveCtx
$LN7@xmlSaveCtx:

; 343  : 	ctxt->indent_size = len;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR [edx+112], eax

; 344  : 	ctxt->indent_nr = MAX_INDENT / ctxt->indent_size;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	eax, 60					; 0000003cH
	cdq
	idiv	DWORD PTR [ecx+112]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+108], eax

; 345  : 	for (i = 0;i < ctxt->indent_nr;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlSaveCtx
$LN2@xmlSaveCtx:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlSaveCtx:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+108]
	jge	SHORT $LN3@xmlSaveCtx

; 346  : 	    memcpy(&ctxt->indent[i * ctxt->indent_size], xmlTreeIndentString,

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	push	ecx
	call	___xmlTreeIndentString
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, DWORD PTR [eax+112]
	mov	edx, DWORD PTR _ctxt$[ebp]
	lea	eax, DWORD PTR [edx+ecx+44]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@xmlSaveCtx
$LN3@xmlSaveCtx:

; 347  : 		   ctxt->indent_size);
; 348  :         ctxt->indent[ctxt->indent_nr * ctxt->indent_size] = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+108]
	imul	eax, DWORD PTR [edx+112]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	BYTE PTR [ecx+eax+44], 0
$LN8@xmlSaveCtx:

; 349  :     }
; 350  : 
; 351  :     if (xmlSaveNoEmptyTags) {

	call	___xmlSaveNoEmptyTags
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@xmlSaveCtx

; 352  : 	ctxt->options |= XML_SAVE_NO_EMPTY;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	or	eax, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+32], eax
$LN1@xmlSaveCtx:

; 353  :     }
; 354  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSaveCtxtInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlEscapeEntities
_TEXT	SEGMENT
tv249 = -33						; size = 1
tv226 = -32						; size = 4
tv228 = -28						; size = 4
tv227 = -24						; size = 4
_val$ = -20						; size = 4
_inend$ = -16						; size = 4
_outend$ = -12						; size = 4
_base$ = -8						; size = 4
_outstart$ = -4						; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_xmlEscapeEntities PROC					; COMDAT

; 209  :                  const xmlChar* in, int *inlen) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 210  :     unsigned char* outstart = out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _outstart$[ebp], eax

; 211  :     const unsigned char* base = in;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _base$[ebp], ecx

; 212  :     unsigned char* outend = out + *outlen;

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _outend$[ebp], eax

; 213  :     const unsigned char* inend;
; 214  :     int val;
; 215  : 
; 216  :     inend = in + (*inlen);

	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _inend$[ebp], edx
$LN2@xmlEscapeE:

; 217  : 
; 218  :     while ((in < inend) && (out < outend)) {

	mov	eax, DWORD PTR _in$[ebp]
	cmp	eax, DWORD PTR _inend$[ebp]
	jae	$LN3@xmlEscapeE
	mov	ecx, DWORD PTR _out$[ebp]
	cmp	ecx, DWORD PTR _outend$[ebp]
	jae	$LN3@xmlEscapeE

; 219  : 	if (*in == '<') {

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN4@xmlEscapeE

; 220  : 	    if (outend - out < 4) break;

	mov	ecx, DWORD PTR _outend$[ebp]
	sub	ecx, DWORD PTR _out$[ebp]
	cmp	ecx, 4
	jge	SHORT $LN6@xmlEscapeE
	jmp	$LN3@xmlEscapeE
$LN6@xmlEscapeE:

; 221  : 	    *out++ = '&';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 38			; 00000026H
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 222  : 	    *out++ = 'l';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 108			; 0000006cH
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 223  : 	    *out++ = 't';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 116			; 00000074H
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 224  : 	    *out++ = ';';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 59			; 0000003bH
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 225  : 	    in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 226  : 	    continue;

	jmp	SHORT $LN2@xmlEscapeE
	jmp	$LN5@xmlEscapeE
$LN4@xmlEscapeE:

; 227  : 	} else if (*in == '>') {

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN7@xmlEscapeE

; 228  : 	    if (outend - out < 4) break;

	mov	ecx, DWORD PTR _outend$[ebp]
	sub	ecx, DWORD PTR _out$[ebp]
	cmp	ecx, 4
	jge	SHORT $LN9@xmlEscapeE
	jmp	$LN3@xmlEscapeE
$LN9@xmlEscapeE:

; 229  : 	    *out++ = '&';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 38			; 00000026H
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 230  : 	    *out++ = 'g';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 103			; 00000067H
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 231  : 	    *out++ = 't';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 116			; 00000074H
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 232  : 	    *out++ = ';';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 59			; 0000003bH
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 233  : 	    in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 234  : 	    continue;

	jmp	$LN2@xmlEscapeE
	jmp	$LN5@xmlEscapeE
$LN7@xmlEscapeE:

; 235  : 	} else if (*in == '&') {

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN10@xmlEscapeE

; 236  : 	    if (outend - out < 5) break;

	mov	ecx, DWORD PTR _outend$[ebp]
	sub	ecx, DWORD PTR _out$[ebp]
	cmp	ecx, 5
	jge	SHORT $LN12@xmlEscapeE
	jmp	$LN3@xmlEscapeE
$LN12@xmlEscapeE:

; 237  : 	    *out++ = '&';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 38			; 00000026H
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 238  : 	    *out++ = 'a';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 97			; 00000061H
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 239  : 	    *out++ = 'm';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 109			; 0000006dH
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 240  : 	    *out++ = 'p';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 112			; 00000070H
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 241  : 	    *out++ = ';';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 59			; 0000003bH
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 242  : 	    in++;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 243  : 	    continue;

	jmp	$LN2@xmlEscapeE

; 244  : 	} else if (((*in >= 0x20) && (*in < 0x80)) ||

	jmp	$LN5@xmlEscapeE
$LN10@xmlEscapeE:

; 245  : 	           (*in == '\n') || (*in == '\t')) {

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jl	SHORT $LN16@xmlEscapeE
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 128				; 00000080H
	jl	SHORT $LN15@xmlEscapeE
$LN16@xmlEscapeE:
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN15@xmlEscapeE
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jne	SHORT $LN13@xmlEscapeE
$LN15@xmlEscapeE:

; 246  : 	    /*
; 247  : 	     * default case, just copy !
; 248  : 	     */
; 249  : 	    *out++ = *in++;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 250  : 	    continue;

	jmp	$LN2@xmlEscapeE
	jmp	$LN5@xmlEscapeE
$LN13@xmlEscapeE:

; 251  : 	} else if (*in >= 0x80) {

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 128				; 00000080H
	jl	$LN17@xmlEscapeE

; 252  : 	    /*
; 253  : 	     * We assume we have UTF-8 input.
; 254  : 	     */
; 255  : 	    if (outend - out < 11) break;

	mov	ecx, DWORD PTR _outend$[ebp]
	sub	ecx, DWORD PTR _out$[ebp]
	cmp	ecx, 11					; 0000000bH
	jge	SHORT $LN19@xmlEscapeE
	jmp	$LN3@xmlEscapeE
$LN19@xmlEscapeE:

; 256  : 
; 257  : 	    if (*in < 0xC0) {

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 192				; 000000c0H
	jge	SHORT $LN20@xmlEscapeE

; 258  : 		xmlSaveErr(XML_SAVE_NOT_UTF8, NULL, NULL);

	push	0
	push	0
	push	1400					; 00000578H
	call	_xmlSaveErr
	add	esp, 12					; 0000000cH

; 259  : 		in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 260  : 		goto error;

	jmp	$error$52
	jmp	$LN21@xmlEscapeE
$LN20@xmlEscapeE:

; 261  : 	    } else if (*in < 0xE0) {

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 224				; 000000e0H
	jge	SHORT $LN22@xmlEscapeE

; 262  : 		if (inend - in < 2) break;

	mov	ecx, DWORD PTR _inend$[ebp]
	sub	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, 2
	jge	SHORT $LN24@xmlEscapeE
	jmp	$LN3@xmlEscapeE
$LN24@xmlEscapeE:

; 263  : 		val = (in[0]) & 0x1F;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 31					; 0000001fH
	mov	DWORD PTR _val$[ebp], edx

; 264  : 		val <<= 6;

	mov	eax, DWORD PTR _val$[ebp]
	shl	eax, 6
	mov	DWORD PTR _val$[ebp], eax

; 265  : 		val |= (in[1]) & 0x3F;

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 63					; 0000003fH
	or	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], eax

; 266  : 		in += 2;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in$[ebp], ecx
	jmp	$LN21@xmlEscapeE
$LN22@xmlEscapeE:

; 267  : 	    } else if (*in < 0xF0) {

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 240				; 000000f0H
	jge	SHORT $LN25@xmlEscapeE

; 268  : 		if (inend - in < 3) break;

	mov	ecx, DWORD PTR _inend$[ebp]
	sub	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, 3
	jge	SHORT $LN27@xmlEscapeE
	jmp	$LN3@xmlEscapeE
$LN27@xmlEscapeE:

; 269  : 		val = (in[0]) & 0x0F;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 15					; 0000000fH
	mov	DWORD PTR _val$[ebp], edx

; 270  : 		val <<= 6;

	mov	eax, DWORD PTR _val$[ebp]
	shl	eax, 6
	mov	DWORD PTR _val$[ebp], eax

; 271  : 		val |= (in[1]) & 0x3F;

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 63					; 0000003fH
	or	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], eax

; 272  : 		val <<= 6;

	mov	ecx, DWORD PTR _val$[ebp]
	shl	ecx, 6
	mov	DWORD PTR _val$[ebp], ecx

; 273  : 		val |= (in[2]) & 0x3F;

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 63					; 0000003fH
	or	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], ecx

; 274  : 		in += 3;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 3
	mov	DWORD PTR _in$[ebp], edx
	jmp	$LN21@xmlEscapeE
$LN25@xmlEscapeE:

; 275  : 	    } else if (*in < 0xF8) {

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 248				; 000000f8H
	jge	$LN28@xmlEscapeE

; 276  : 		if (inend - in < 4) break;

	mov	edx, DWORD PTR _inend$[ebp]
	sub	edx, DWORD PTR _in$[ebp]
	cmp	edx, 4
	jge	SHORT $LN30@xmlEscapeE
	jmp	$LN3@xmlEscapeE
$LN30@xmlEscapeE:

; 277  : 		val = (in[0]) & 0x07;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 7
	mov	DWORD PTR _val$[ebp], eax

; 278  : 		val <<= 6;

	mov	ecx, DWORD PTR _val$[ebp]
	shl	ecx, 6
	mov	DWORD PTR _val$[ebp], ecx

; 279  : 		val |= (in[1]) & 0x3F;

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 63					; 0000003fH
	or	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], ecx

; 280  : 		val <<= 6;

	mov	edx, DWORD PTR _val$[ebp]
	shl	edx, 6
	mov	DWORD PTR _val$[ebp], edx

; 281  : 		val |= (in[2]) & 0x3F;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	or	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], edx

; 282  : 		val <<= 6;

	mov	eax, DWORD PTR _val$[ebp]
	shl	eax, 6
	mov	DWORD PTR _val$[ebp], eax

; 283  : 		val |= (in[3]) & 0x3F;

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 63					; 0000003fH
	or	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], ecx

; 284  : 		in += 4;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 4
	mov	DWORD PTR _in$[ebp], edx

; 285  : 	    } else {

	jmp	SHORT $LN21@xmlEscapeE
$LN28@xmlEscapeE:

; 286  : 		xmlSaveErr(XML_SAVE_CHAR_INVALID, NULL, NULL);

	push	0
	push	0
	push	1401					; 00000579H
	call	_xmlSaveErr
	add	esp, 12					; 0000000cH

; 287  : 		in++;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 288  : 		goto error;

	jmp	$error$52
$LN21@xmlEscapeE:

; 289  : 	    }
; 290  : 	    if (!IS_CHAR(val)) {

	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jge	SHORT $LN46@xmlEscapeE
	cmp	DWORD PTR _val$[ebp], 9
	jl	SHORT $LN38@xmlEscapeE
	cmp	DWORD PTR _val$[ebp], 10		; 0000000aH
	jle	SHORT $LN39@xmlEscapeE
$LN38@xmlEscapeE:
	cmp	DWORD PTR _val$[ebp], 13		; 0000000dH
	je	SHORT $LN39@xmlEscapeE
	cmp	DWORD PTR _val$[ebp], 32		; 00000020H
	jge	SHORT $LN39@xmlEscapeE
	mov	DWORD PTR tv227[ebp], 0
	jmp	SHORT $LN45@xmlEscapeE
$LN39@xmlEscapeE:
	mov	DWORD PTR tv227[ebp], 1
$LN45@xmlEscapeE:
	mov	ecx, DWORD PTR tv227[ebp]
	mov	DWORD PTR tv228[ebp], ecx
	jmp	SHORT $LN47@xmlEscapeE
$LN46@xmlEscapeE:
	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jl	SHORT $LN40@xmlEscapeE
	cmp	DWORD PTR _val$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN42@xmlEscapeE
$LN40@xmlEscapeE:
	cmp	DWORD PTR _val$[ebp], 57344		; 0000e000H
	jl	SHORT $LN41@xmlEscapeE
	cmp	DWORD PTR _val$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN42@xmlEscapeE
$LN41@xmlEscapeE:
	cmp	DWORD PTR _val$[ebp], 65536		; 00010000H
	jl	SHORT $LN43@xmlEscapeE
	cmp	DWORD PTR _val$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN42@xmlEscapeE
$LN43@xmlEscapeE:
	mov	DWORD PTR tv226[ebp], 0
	jmp	SHORT $LN44@xmlEscapeE
$LN42@xmlEscapeE:
	mov	DWORD PTR tv226[ebp], 1
$LN44@xmlEscapeE:
	mov	edx, DWORD PTR tv226[ebp]
	mov	DWORD PTR tv228[ebp], edx
$LN47@xmlEscapeE:
	cmp	DWORD PTR tv228[ebp], 0
	jne	SHORT $LN31@xmlEscapeE

; 291  : 		xmlSaveErr(XML_SAVE_CHAR_INVALID, NULL, NULL);

	push	0
	push	0
	push	1401					; 00000579H
	call	_xmlSaveErr
	add	esp, 12					; 0000000cH

; 292  : 		in++;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 293  : 		goto error;

	jmp	$error$52
$LN31@xmlEscapeE:

; 294  : 	    }
; 295  : 
; 296  : 	    /*
; 297  : 	     * We could do multiple things here. Just save as a char ref
; 298  : 	     */
; 299  : 	    out = xmlSerializeHexCharRef(out, val);

	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_xmlSerializeHexCharRef
	add	esp, 8
	mov	DWORD PTR _out$[ebp], eax
	jmp	$LN5@xmlEscapeE
$LN17@xmlEscapeE:

; 300  : 	} else if (IS_BYTE_CHAR(*in)) {

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN35@xmlEscapeE
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN34@xmlEscapeE
$LN35@xmlEscapeE:
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN34@xmlEscapeE
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN32@xmlEscapeE
$LN34@xmlEscapeE:

; 301  : 	    if (outend - out < 6) break;

	mov	edx, DWORD PTR _outend$[ebp]
	sub	edx, DWORD PTR _out$[ebp]
	cmp	edx, 6
	jge	SHORT $LN36@xmlEscapeE
	jmp	SHORT $LN3@xmlEscapeE
$LN36@xmlEscapeE:

; 302  : 	    out = xmlSerializeHexCharRef(out, *in++);

	mov	eax, DWORD PTR _in$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv249[ebp], cl
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 1
	mov	DWORD PTR _in$[ebp], edx
	movzx	eax, BYTE PTR tv249[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_xmlSerializeHexCharRef
	add	esp, 8
	mov	DWORD PTR _out$[ebp], eax

; 303  : 	} else {

	jmp	SHORT $LN5@xmlEscapeE
$LN32@xmlEscapeE:

; 304  : 	    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CH@EAFIMPAL@xmlEscapeEntities?5?3?5char?5out?5of@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 305  : 		"xmlEscapeEntities : char out of range\n");
; 306  : 	    in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 307  : 	    goto error;

	jmp	SHORT $error$52
$LN5@xmlEscapeE:

; 308  : 	}
; 309  :     }

	jmp	$LN2@xmlEscapeE
$LN3@xmlEscapeE:

; 310  :     *outlen = out - outstart;

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _outstart$[ebp]
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], edx

; 311  :     *inlen = in - base;

	mov	ecx, DWORD PTR _in$[ebp]
	sub	ecx, DWORD PTR _base$[ebp]
	mov	edx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 312  :     return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlEscapeE
$error$52:

; 313  : error:
; 314  :     *outlen = out - outstart;

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 315  :     *inlen = in - base;

	mov	edx, DWORD PTR _in$[ebp]
	sub	edx, DWORD PTR _base$[ebp]
	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [eax], edx

; 316  :     return(-1);

	or	eax, -1
$LN1@xmlEscapeE:

; 317  : }

	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlEscapeEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSerializeHexCharRef
_TEXT	SEGMENT
tv80 = -8						; size = 4
_ptr$ = -4						; size = 4
_out$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlSerializeHexCharRef PROC				; COMDAT

; 152  : xmlSerializeHexCharRef(unsigned char *out, int val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 153  :     unsigned char *ptr;
; 154  : 
; 155  :     *out++ = '&';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 156  :     *out++ = '#';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 35			; 00000023H
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 157  :     *out++ = 'x';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 120			; 00000078H
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 158  :     if (val < 0x10) ptr = out;

	cmp	DWORD PTR _val$[ebp], 16		; 00000010H
	jge	SHORT $LN6@xmlSeriali
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax
	jmp	SHORT $LN7@xmlSeriali
$LN6@xmlSeriali:

; 159  :     else if (val < 0x100) ptr = out + 1;

	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jge	SHORT $LN8@xmlSeriali
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx
	jmp	SHORT $LN7@xmlSeriali
$LN8@xmlSeriali:

; 160  :     else if (val < 0x1000) ptr = out + 2;

	cmp	DWORD PTR _val$[ebp], 4096		; 00001000H
	jge	SHORT $LN10@xmlSeriali
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 2
	mov	DWORD PTR _ptr$[ebp], edx
	jmp	SHORT $LN7@xmlSeriali
$LN10@xmlSeriali:

; 161  :     else if (val < 0x10000) ptr = out + 3;

	cmp	DWORD PTR _val$[ebp], 65536		; 00010000H
	jge	SHORT $LN12@xmlSeriali
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 3
	mov	DWORD PTR _ptr$[ebp], eax
	jmp	SHORT $LN7@xmlSeriali
$LN12@xmlSeriali:

; 162  :     else if (val < 0x100000) ptr = out + 4;

	cmp	DWORD PTR _val$[ebp], 1048576		; 00100000H
	jge	SHORT $LN14@xmlSeriali
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 4
	mov	DWORD PTR _ptr$[ebp], ecx
	jmp	SHORT $LN7@xmlSeriali
$LN14@xmlSeriali:

; 163  :     else ptr = out + 5;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 5
	mov	DWORD PTR _ptr$[ebp], edx
$LN7@xmlSeriali:

; 164  :     out = ptr + 1;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
$LN2@xmlSeriali:

; 165  :     while (val > 0) {

	cmp	DWORD PTR _val$[ebp], 0
	jle	$LN3@xmlSeriali

; 166  : 	switch (val & 0xF) {

	mov	ecx, DWORD PTR _val$[ebp]
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR tv80[ebp], ecx
	cmp	DWORD PTR tv80[ebp], 15			; 0000000fH
	ja	$LN32@xmlSeriali
	mov	edx, DWORD PTR tv80[ebp]
	jmp	DWORD PTR $LN34@xmlSeriali[edx*4]
$LN16@xmlSeriali:

; 167  : 	    case 0: *ptr-- = '0'; break;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [eax], 48			; 00000030H
	mov	ecx, DWORD PTR _ptr$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx
	jmp	$LN4@xmlSeriali
$LN17@xmlSeriali:

; 168  : 	    case 1: *ptr-- = '1'; break;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [edx], 49			; 00000031H
	mov	eax, DWORD PTR _ptr$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax
	jmp	$LN4@xmlSeriali
$LN18@xmlSeriali:

; 169  : 	    case 2: *ptr-- = '2'; break;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [ecx], 50			; 00000032H
	mov	edx, DWORD PTR _ptr$[ebp]
	sub	edx, 1
	mov	DWORD PTR _ptr$[ebp], edx
	jmp	$LN4@xmlSeriali
$LN19@xmlSeriali:

; 170  : 	    case 3: *ptr-- = '3'; break;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [eax], 51			; 00000033H
	mov	ecx, DWORD PTR _ptr$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx
	jmp	$LN4@xmlSeriali
$LN20@xmlSeriali:

; 171  : 	    case 4: *ptr-- = '4'; break;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [edx], 52			; 00000034H
	mov	eax, DWORD PTR _ptr$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax
	jmp	$LN4@xmlSeriali
$LN21@xmlSeriali:

; 172  : 	    case 5: *ptr-- = '5'; break;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [ecx], 53			; 00000035H
	mov	edx, DWORD PTR _ptr$[ebp]
	sub	edx, 1
	mov	DWORD PTR _ptr$[ebp], edx
	jmp	$LN4@xmlSeriali
$LN22@xmlSeriali:

; 173  : 	    case 6: *ptr-- = '6'; break;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [eax], 54			; 00000036H
	mov	ecx, DWORD PTR _ptr$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx
	jmp	$LN4@xmlSeriali
$LN23@xmlSeriali:

; 174  : 	    case 7: *ptr-- = '7'; break;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [edx], 55			; 00000037H
	mov	eax, DWORD PTR _ptr$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax
	jmp	$LN4@xmlSeriali
$LN24@xmlSeriali:

; 175  : 	    case 8: *ptr-- = '8'; break;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [ecx], 56			; 00000038H
	mov	edx, DWORD PTR _ptr$[ebp]
	sub	edx, 1
	mov	DWORD PTR _ptr$[ebp], edx
	jmp	$LN4@xmlSeriali
$LN25@xmlSeriali:

; 176  : 	    case 9: *ptr-- = '9'; break;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [eax], 57			; 00000039H
	mov	ecx, DWORD PTR _ptr$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx
	jmp	SHORT $LN4@xmlSeriali
$LN26@xmlSeriali:

; 177  : 	    case 0xA: *ptr-- = 'A'; break;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [edx], 65			; 00000041H
	mov	eax, DWORD PTR _ptr$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax
	jmp	SHORT $LN4@xmlSeriali
$LN27@xmlSeriali:

; 178  : 	    case 0xB: *ptr-- = 'B'; break;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [ecx], 66			; 00000042H
	mov	edx, DWORD PTR _ptr$[ebp]
	sub	edx, 1
	mov	DWORD PTR _ptr$[ebp], edx
	jmp	SHORT $LN4@xmlSeriali
$LN28@xmlSeriali:

; 179  : 	    case 0xC: *ptr-- = 'C'; break;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [eax], 67			; 00000043H
	mov	ecx, DWORD PTR _ptr$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx
	jmp	SHORT $LN4@xmlSeriali
$LN29@xmlSeriali:

; 180  : 	    case 0xD: *ptr-- = 'D'; break;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [edx], 68			; 00000044H
	mov	eax, DWORD PTR _ptr$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax
	jmp	SHORT $LN4@xmlSeriali
$LN30@xmlSeriali:

; 181  : 	    case 0xE: *ptr-- = 'E'; break;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [ecx], 69			; 00000045H
	mov	edx, DWORD PTR _ptr$[ebp]
	sub	edx, 1
	mov	DWORD PTR _ptr$[ebp], edx
	jmp	SHORT $LN4@xmlSeriali
$LN31@xmlSeriali:

; 182  : 	    case 0xF: *ptr-- = 'F'; break;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [eax], 70			; 00000046H
	mov	ecx, DWORD PTR _ptr$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx
	jmp	SHORT $LN4@xmlSeriali
$LN32@xmlSeriali:

; 183  : 	    default: *ptr-- = '0'; break;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [edx], 48			; 00000030H
	mov	eax, DWORD PTR _ptr$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax
$LN4@xmlSeriali:

; 184  : 	}
; 185  : 	val >>= 4;

	mov	ecx, DWORD PTR _val$[ebp]
	sar	ecx, 4
	mov	DWORD PTR _val$[ebp], ecx

; 186  :     }

	jmp	$LN2@xmlSeriali
$LN3@xmlSeriali:

; 187  :     *out++ = ';';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 59			; 0000003bH
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 188  :     *out = 0;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 0

; 189  :     return(out);

	mov	eax, DWORD PTR _out$[ebp]

; 190  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xmlSeriali:
	DD	$LN16@xmlSeriali
	DD	$LN17@xmlSeriali
	DD	$LN18@xmlSeriali
	DD	$LN19@xmlSeriali
	DD	$LN20@xmlSeriali
	DD	$LN21@xmlSeriali
	DD	$LN22@xmlSeriali
	DD	$LN23@xmlSeriali
	DD	$LN24@xmlSeriali
	DD	$LN25@xmlSeriali
	DD	$LN26@xmlSeriali
	DD	$LN27@xmlSeriali
	DD	$LN28@xmlSeriali
	DD	$LN29@xmlSeriali
	DD	$LN30@xmlSeriali
	DD	$LN31@xmlSeriali
_xmlSerializeHexCharRef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveErr
_TEXT	SEGMENT
tv64 = -8						; size = 4
_msg$ = -4						; size = 4
_code$ = 8						; size = 4
_node$ = 12						; size = 4
_extra$ = 16						; size = 4
_xmlSaveErr PROC					; COMDAT

; 124  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 125  :     const char *msg = NULL;

	mov	DWORD PTR _msg$[ebp], 0

; 126  : 
; 127  :     switch(code) {

	mov	eax, DWORD PTR _code$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1400				; 00000578H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 3
	ja	SHORT $LN8@xmlSaveErr
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN10@xmlSaveErr[edx*4]
$LN4@xmlSaveErr:

; 128  :         case XML_SAVE_NOT_UTF8:
; 129  : 	    msg = "string is not in UTF-8\n";

	mov	DWORD PTR _msg$[ebp], OFFSET ??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@

; 130  : 	    break;

	jmp	SHORT $LN2@xmlSaveErr
$LN5@xmlSaveErr:

; 131  : 	case XML_SAVE_CHAR_INVALID:
; 132  : 	    msg = "invalid character value\n";

	mov	DWORD PTR _msg$[ebp], OFFSET ??_C@_0BJ@HMEJBBPL@invalid?5character?5value?6@

; 133  : 	    break;

	jmp	SHORT $LN2@xmlSaveErr
$LN6@xmlSaveErr:

; 134  : 	case XML_SAVE_UNKNOWN_ENCODING:
; 135  : 	    msg = "unknown encoding %s\n";

	mov	DWORD PTR _msg$[ebp], OFFSET ??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@

; 136  : 	    break;

	jmp	SHORT $LN2@xmlSaveErr
$LN7@xmlSaveErr:

; 137  : 	case XML_SAVE_NO_DOCTYPE:
; 138  : 	    msg = "document has no DOCTYPE\n";

	mov	DWORD PTR _msg$[ebp], OFFSET ??_C@_0BJ@OKGKFHLI@document?5has?5no?5DOCTYPE?6@

; 139  : 	    break;

	jmp	SHORT $LN2@xmlSaveErr
$LN8@xmlSaveErr:

; 140  : 	default:
; 141  : 	    msg = "unexpected error number\n";

	mov	DWORD PTR _msg$[ebp], OFFSET ??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@
$LN2@xmlSaveErr:

; 142  :     }
; 143  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _code$[ebp]
	push	eax
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 144  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@xmlSaveErr:
	DD	$LN4@xmlSaveErr
	DD	$LN5@xmlSaveErr
	DD	$LN7@xmlSaveErr
	DD	$LN6@xmlSaveErr
_xmlSaveErr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlSaveErrMemory PROC					; COMDAT

; 110  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 111  :     __xmlSimpleError(XML_FROM_OUTPUT, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	0
	push	0
	push	2
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 112  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSaveErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlBufDumpEntityDecl
_TEXT	SEGMENT
_buffer$ = -4						; size = 4
_buf$ = 8						; size = 4
_ent$ = 12						; size = 4
_xmlBufDumpEntityDecl PROC				; COMDAT

; 536  : xmlBufDumpEntityDecl(xmlBufPtr buf, xmlEntityPtr ent) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 537  :     xmlBufferPtr buffer;
; 538  : 
; 539  :     buffer = xmlBufferCreate();

	call	_xmlBufferCreate
	mov	DWORD PTR _buffer$[ebp], eax

; 540  :     if (buffer == NULL) {

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN2@xmlBufDump

; 541  :         /*
; 542  :          * TODO set the error in buf
; 543  :          */
; 544  :         return;

	jmp	SHORT $LN1@xmlBufDump
$LN2@xmlBufDump:

; 545  :     }
; 546  :     xmlDumpEntityDecl(buffer, ent);

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_xmlDumpEntityDecl
	add	esp, 8

; 547  :     xmlBufMergeBuffer(buf, buffer);

	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufMergeBuffer
	add	esp, 8
$LN1@xmlBufDump:

; 548  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufDumpEntityDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlBufDumpAttributeDecl
_TEXT	SEGMENT
_buffer$ = -4						; size = 4
_buf$ = 8						; size = 4
_attr$ = 12						; size = 4
_xmlBufDumpAttributeDecl PROC				; COMDAT

; 514  : xmlBufDumpAttributeDecl(xmlBufPtr buf, xmlAttributePtr attr) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 515  :     xmlBufferPtr buffer;
; 516  : 
; 517  :     buffer = xmlBufferCreate();

	call	_xmlBufferCreate
	mov	DWORD PTR _buffer$[ebp], eax

; 518  :     if (buffer == NULL) {

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN2@xmlBufDump

; 519  :         /*
; 520  :          * TODO set the error in buf
; 521  :          */
; 522  :         return;

	jmp	SHORT $LN1@xmlBufDump
$LN2@xmlBufDump:

; 523  :     }
; 524  :     xmlDumpAttributeDecl(buffer, attr);

	mov	eax, DWORD PTR _attr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_xmlDumpAttributeDecl
	add	esp, 8

; 525  :     xmlBufMergeBuffer(buf, buffer);

	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufMergeBuffer
	add	esp, 8
$LN1@xmlBufDump:

; 526  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufDumpAttributeDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlBufDumpElementDecl
_TEXT	SEGMENT
_buffer$ = -4						; size = 4
_buf$ = 8						; size = 4
_elem$ = 12						; size = 4
_xmlBufDumpElementDecl PROC				; COMDAT

; 491  : xmlBufDumpElementDecl(xmlBufPtr buf, xmlElementPtr elem) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 492  :     xmlBufferPtr buffer;
; 493  : 
; 494  :     buffer = xmlBufferCreate();

	call	_xmlBufferCreate
	mov	DWORD PTR _buffer$[ebp], eax

; 495  :     if (buffer == NULL) {

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN2@xmlBufDump

; 496  :         /*
; 497  :          * TODO set the error in buf
; 498  :          */
; 499  :         return;

	jmp	SHORT $LN1@xmlBufDump
$LN2@xmlBufDump:

; 500  :     }
; 501  :     xmlDumpElementDecl(buffer, elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_xmlDumpElementDecl
	add	esp, 8

; 502  :     xmlBufMergeBuffer(buf, buffer);

	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufMergeBuffer
	add	esp, 8
$LN1@xmlBufDump:

; 503  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufDumpElementDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlBufDumpNotationTable
_TEXT	SEGMENT
_buffer$ = -4						; size = 4
_buf$ = 8						; size = 4
_table$ = 12						; size = 4
_xmlBufDumpNotationTable PROC				; COMDAT

; 468  : xmlBufDumpNotationTable(xmlBufPtr buf, xmlNotationTablePtr table) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 469  :     xmlBufferPtr buffer;
; 470  : 
; 471  :     buffer = xmlBufferCreate();

	call	_xmlBufferCreate
	mov	DWORD PTR _buffer$[ebp], eax

; 472  :     if (buffer == NULL) {

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN2@xmlBufDump

; 473  :         /*
; 474  :          * TODO set the error in buf
; 475  :          */
; 476  :         return;

	jmp	SHORT $LN1@xmlBufDump
$LN2@xmlBufDump:

; 477  :     }
; 478  :     xmlDumpNotationTable(buffer, table);

	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_xmlDumpNotationTable
	add	esp, 8

; 479  :     xmlBufMergeBuffer(buf, buffer);

	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufMergeBuffer
	add	esp, 8
$LN1@xmlBufDump:

; 480  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufDumpNotationTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlBufAttrSerializeTxtContent
_TEXT	SEGMENT
tv280 = -48						; size = 4
tv282 = -44						; size = 4
tv281 = -40						; size = 4
_l$1 = -36						; size = 4
_val$2 = -32						; size = 4
_tmp$3 = -24						; size = 12
_cur$ = -8						; size = 4
_base$ = -4						; size = 4
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_attr$ = 16						; size = 4
_string$ = 20						; size = 4
_xmlBufAttrSerializeTxtContent PROC			; COMDAT

; 2048 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2049 :     xmlChar *base, *cur;
; 2050 : 
; 2051 :     if (string == NULL)

	cmp	DWORD PTR _string$[ebp], 0
	jne	SHORT $LN4@xmlBufAttr

; 2052 :         return;

	jmp	$LN1@xmlBufAttr
$LN4@xmlBufAttr:

; 2053 :     base = cur = (xmlChar *) string;

	mov	eax, DWORD PTR _string$[ebp]
	mov	DWORD PTR _cur$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _base$[ebp], ecx
$LN2@xmlBufAttr:

; 2054 :     while (*cur != 0) {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN3@xmlBufAttr

; 2055 :         if (*cur == '\n') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN5@xmlBufAttr

; 2056 :             if (base != cur)

	mov	eax, DWORD PTR _base$[ebp]
	cmp	eax, DWORD PTR _cur$[ebp]
	je	SHORT $LN7@xmlBufAttr

; 2057 :                 xmlBufAdd(buf, base, cur - base);

	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, DWORD PTR _base$[ebp]
	push	ecx
	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN7@xmlBufAttr:

; 2058 :             xmlBufAdd(buf, BAD_CAST "&#10;", 5);

	push	5
	push	OFFSET ??_C@_05EJOHHIMP@?$CG?$CD10?$DL@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2059 :             cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 2060 :             base = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _base$[ebp], eax
	jmp	$LN6@xmlBufAttr
$LN5@xmlBufAttr:

; 2061 :         } else if (*cur == '\r') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN8@xmlBufAttr

; 2062 :             if (base != cur)

	mov	eax, DWORD PTR _base$[ebp]
	cmp	eax, DWORD PTR _cur$[ebp]
	je	SHORT $LN10@xmlBufAttr

; 2063 :                 xmlBufAdd(buf, base, cur - base);

	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, DWORD PTR _base$[ebp]
	push	ecx
	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN10@xmlBufAttr:

; 2064 :             xmlBufAdd(buf, BAD_CAST "&#13;", 5);

	push	5
	push	OFFSET ??_C@_05ELKBMGJG@?$CG?$CD13?$DL@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2065 :             cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 2066 :             base = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _base$[ebp], eax
	jmp	$LN6@xmlBufAttr
$LN8@xmlBufAttr:

; 2067 :         } else if (*cur == '\t') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jne	SHORT $LN11@xmlBufAttr

; 2068 :             if (base != cur)

	mov	eax, DWORD PTR _base$[ebp]
	cmp	eax, DWORD PTR _cur$[ebp]
	je	SHORT $LN13@xmlBufAttr

; 2069 :                 xmlBufAdd(buf, base, cur - base);

	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, DWORD PTR _base$[ebp]
	push	ecx
	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN13@xmlBufAttr:

; 2070 :             xmlBufAdd(buf, BAD_CAST "&#9;", 4);

	push	4
	push	OFFSET ??_C@_04NCNDODLB@?$CG?$CD9?$DL@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2071 :             cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 2072 :             base = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _base$[ebp], eax
	jmp	$LN6@xmlBufAttr
$LN11@xmlBufAttr:

; 2073 :         } else if (*cur == '"') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 34					; 00000022H
	jne	SHORT $LN14@xmlBufAttr

; 2074 :             if (base != cur)

	mov	eax, DWORD PTR _base$[ebp]
	cmp	eax, DWORD PTR _cur$[ebp]
	je	SHORT $LN16@xmlBufAttr

; 2075 :                 xmlBufAdd(buf, base, cur - base);

	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, DWORD PTR _base$[ebp]
	push	ecx
	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN16@xmlBufAttr:

; 2076 :             xmlBufAdd(buf, BAD_CAST "&quot;", 6);

	push	6
	push	OFFSET ??_C@_06DDLNFFBN@?$CGquot?$DL@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2077 :             cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 2078 :             base = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _base$[ebp], eax
	jmp	$LN6@xmlBufAttr
$LN14@xmlBufAttr:

; 2079 :         } else if (*cur == '<') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 60					; 0000003cH
	jne	SHORT $LN17@xmlBufAttr

; 2080 :             if (base != cur)

	mov	eax, DWORD PTR _base$[ebp]
	cmp	eax, DWORD PTR _cur$[ebp]
	je	SHORT $LN19@xmlBufAttr

; 2081 :                 xmlBufAdd(buf, base, cur - base);

	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, DWORD PTR _base$[ebp]
	push	ecx
	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN19@xmlBufAttr:

; 2082 :             xmlBufAdd(buf, BAD_CAST "&lt;", 4);

	push	4
	push	OFFSET ??_C@_04GJOGLFEJ@?$CGlt?$DL@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2083 :             cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 2084 :             base = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _base$[ebp], eax
	jmp	$LN6@xmlBufAttr
$LN17@xmlBufAttr:

; 2085 :         } else if (*cur == '>') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 62					; 0000003eH
	jne	SHORT $LN20@xmlBufAttr

; 2086 :             if (base != cur)

	mov	eax, DWORD PTR _base$[ebp]
	cmp	eax, DWORD PTR _cur$[ebp]
	je	SHORT $LN22@xmlBufAttr

; 2087 :                 xmlBufAdd(buf, base, cur - base);

	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, DWORD PTR _base$[ebp]
	push	ecx
	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN22@xmlBufAttr:

; 2088 :             xmlBufAdd(buf, BAD_CAST "&gt;", 4);

	push	4
	push	OFFSET ??_C@_04LOOHDCEI@?$CGgt?$DL@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2089 :             cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 2090 :             base = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _base$[ebp], eax
	jmp	$LN6@xmlBufAttr
$LN20@xmlBufAttr:

; 2091 :         } else if (*cur == '&') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 38					; 00000026H
	jne	SHORT $LN23@xmlBufAttr

; 2092 :             if (base != cur)

	mov	eax, DWORD PTR _base$[ebp]
	cmp	eax, DWORD PTR _cur$[ebp]
	je	SHORT $LN25@xmlBufAttr

; 2093 :                 xmlBufAdd(buf, base, cur - base);

	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, DWORD PTR _base$[ebp]
	push	ecx
	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN25@xmlBufAttr:

; 2094 :             xmlBufAdd(buf, BAD_CAST "&amp;", 5);

	push	5
	push	OFFSET ??_C@_05JKJFEODM@?$CGamp?$DL@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2095 :             cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 2096 :             base = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _base$[ebp], eax
	jmp	$LN6@xmlBufAttr
$LN23@xmlBufAttr:

; 2097 :         } else if ((*cur >= 0x80) && (cur[1] != 0) &&

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 128				; 00000080H
	jl	$LN26@xmlBufAttr
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	$LN26@xmlBufAttr
	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN28@xmlBufAttr
	mov	eax, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [eax+60], 0
	jne	$LN26@xmlBufAttr
$LN28@xmlBufAttr:

; 2098 : 	           ((doc == NULL) || (doc->encoding == NULL))) {
; 2099 :             /*
; 2100 :              * We assume we have UTF-8 content.
; 2101 :              */
; 2102 :             unsigned char tmp[12];
; 2103 :             int val = 0, l = 1;

	mov	DWORD PTR _val$2[ebp], 0
	mov	DWORD PTR _l$1[ebp], 1

; 2104 : 
; 2105 :             if (base != cur)

	mov	ecx, DWORD PTR _base$[ebp]
	cmp	ecx, DWORD PTR _cur$[ebp]
	je	SHORT $LN29@xmlBufAttr

; 2106 :                 xmlBufAdd(buf, base, cur - base);

	mov	edx, DWORD PTR _cur$[ebp]
	sub	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _base$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN29@xmlBufAttr:

; 2107 :             if (*cur < 0xC0) {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 192				; 000000c0H
	jge	SHORT $LN30@xmlBufAttr

; 2108 :                 xmlSaveErr(XML_SAVE_NOT_UTF8, (xmlNodePtr) attr, NULL);

	push	0
	mov	ecx, DWORD PTR _attr$[ebp]
	push	ecx
	push	1400					; 00000578H
	call	_xmlSaveErr
	add	esp, 12					; 0000000cH

; 2109 : 		xmlSerializeHexCharRef(tmp, *cur);

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _tmp$3[ebp]
	push	ecx
	call	_xmlSerializeHexCharRef
	add	esp, 8

; 2110 :                 xmlBufAdd(buf, (xmlChar *) tmp, -1);

	push	-1
	lea	edx, DWORD PTR _tmp$3[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2111 :                 cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 2112 :                 base = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _base$[ebp], edx

; 2113 :                 continue;

	jmp	$LN2@xmlBufAttr
	jmp	$LN31@xmlBufAttr
$LN30@xmlBufAttr:

; 2114 :             } else if (*cur < 0xE0) {

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 224				; 000000e0H
	jge	SHORT $LN32@xmlBufAttr

; 2115 :                 val = (cur[0]) & 0x1F;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 31					; 0000001fH
	mov	DWORD PTR _val$2[ebp], edx

; 2116 :                 val <<= 6;

	mov	eax, DWORD PTR _val$2[ebp]
	shl	eax, 6
	mov	DWORD PTR _val$2[ebp], eax

; 2117 :                 val |= (cur[1]) & 0x3F;

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 63					; 0000003fH
	or	eax, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], eax

; 2118 :                 l = 2;

	mov	DWORD PTR _l$1[ebp], 2
	jmp	$LN31@xmlBufAttr
$LN32@xmlBufAttr:

; 2119 :             } else if ((*cur < 0xF0) && (cur [2] != 0)) {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 240				; 000000f0H
	jge	SHORT $LN34@xmlBufAttr
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN34@xmlBufAttr

; 2120 :                 val = (cur[0]) & 0x0F;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _val$2[ebp], eax

; 2121 :                 val <<= 6;

	mov	ecx, DWORD PTR _val$2[ebp]
	shl	ecx, 6
	mov	DWORD PTR _val$2[ebp], ecx

; 2122 :                 val |= (cur[1]) & 0x3F;

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 63					; 0000003fH
	or	ecx, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], ecx

; 2123 :                 val <<= 6;

	mov	edx, DWORD PTR _val$2[ebp]
	shl	edx, 6
	mov	DWORD PTR _val$2[ebp], edx

; 2124 :                 val |= (cur[2]) & 0x3F;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	or	edx, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], edx

; 2125 :                 l = 3;

	mov	DWORD PTR _l$1[ebp], 3
	jmp	$LN31@xmlBufAttr
$LN34@xmlBufAttr:

; 2126 :             } else if ((*cur < 0xF8) && (cur [2] != 0) && (cur[3] != 0)) {

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 248				; 000000f8H
	jge	$LN31@xmlBufAttr
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	$LN31@xmlBufAttr
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN31@xmlBufAttr

; 2127 :                 val = (cur[0]) & 0x07;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 7
	mov	DWORD PTR _val$2[ebp], eax

; 2128 :                 val <<= 6;

	mov	ecx, DWORD PTR _val$2[ebp]
	shl	ecx, 6
	mov	DWORD PTR _val$2[ebp], ecx

; 2129 :                 val |= (cur[1]) & 0x3F;

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 63					; 0000003fH
	or	ecx, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], ecx

; 2130 :                 val <<= 6;

	mov	edx, DWORD PTR _val$2[ebp]
	shl	edx, 6
	mov	DWORD PTR _val$2[ebp], edx

; 2131 :                 val |= (cur[2]) & 0x3F;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	or	edx, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], edx

; 2132 :                 val <<= 6;

	mov	eax, DWORD PTR _val$2[ebp]
	shl	eax, 6
	mov	DWORD PTR _val$2[ebp], eax

; 2133 :                 val |= (cur[3]) & 0x3F;

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 63					; 0000003fH
	or	ecx, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], ecx

; 2134 :                 l = 4;

	mov	DWORD PTR _l$1[ebp], 4
$LN31@xmlBufAttr:

; 2135 :             }
; 2136 :             if ((l == 1) || (!IS_CHAR(val))) {

	cmp	DWORD PTR _l$1[ebp], 1
	je	$LN38@xmlBufAttr
	cmp	DWORD PTR _val$2[ebp], 256		; 00000100H
	jge	SHORT $LN49@xmlBufAttr
	cmp	DWORD PTR _val$2[ebp], 9
	jl	SHORT $LN41@xmlBufAttr
	cmp	DWORD PTR _val$2[ebp], 10		; 0000000aH
	jle	SHORT $LN42@xmlBufAttr
$LN41@xmlBufAttr:
	cmp	DWORD PTR _val$2[ebp], 13		; 0000000dH
	je	SHORT $LN42@xmlBufAttr
	cmp	DWORD PTR _val$2[ebp], 32		; 00000020H
	jge	SHORT $LN42@xmlBufAttr
	mov	DWORD PTR tv281[ebp], 0
	jmp	SHORT $LN48@xmlBufAttr
$LN42@xmlBufAttr:
	mov	DWORD PTR tv281[ebp], 1
$LN48@xmlBufAttr:
	mov	edx, DWORD PTR tv281[ebp]
	mov	DWORD PTR tv282[ebp], edx
	jmp	SHORT $LN50@xmlBufAttr
$LN49@xmlBufAttr:
	cmp	DWORD PTR _val$2[ebp], 256		; 00000100H
	jl	SHORT $LN43@xmlBufAttr
	cmp	DWORD PTR _val$2[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN45@xmlBufAttr
$LN43@xmlBufAttr:
	cmp	DWORD PTR _val$2[ebp], 57344		; 0000e000H
	jl	SHORT $LN44@xmlBufAttr
	cmp	DWORD PTR _val$2[ebp], 65533		; 0000fffdH
	jle	SHORT $LN45@xmlBufAttr
$LN44@xmlBufAttr:
	cmp	DWORD PTR _val$2[ebp], 65536		; 00010000H
	jl	SHORT $LN46@xmlBufAttr
	cmp	DWORD PTR _val$2[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN45@xmlBufAttr
$LN46@xmlBufAttr:
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN47@xmlBufAttr
$LN45@xmlBufAttr:
	mov	DWORD PTR tv280[ebp], 1
$LN47@xmlBufAttr:
	mov	eax, DWORD PTR tv280[ebp]
	mov	DWORD PTR tv282[ebp], eax
$LN50@xmlBufAttr:
	cmp	DWORD PTR tv282[ebp], 0
	jne	SHORT $LN37@xmlBufAttr
$LN38@xmlBufAttr:

; 2137 :                 xmlSaveErr(XML_SAVE_CHAR_INVALID, (xmlNodePtr) attr, NULL);

	push	0
	mov	ecx, DWORD PTR _attr$[ebp]
	push	ecx
	push	1401					; 00000579H
	call	_xmlSaveErr
	add	esp, 12					; 0000000cH

; 2138 : 		xmlSerializeHexCharRef(tmp, *cur);

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _tmp$3[ebp]
	push	ecx
	call	_xmlSerializeHexCharRef
	add	esp, 8

; 2139 :                 xmlBufAdd(buf, (xmlChar *) tmp, -1);

	push	-1
	lea	edx, DWORD PTR _tmp$3[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2140 :                 cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 2141 :                 base = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _base$[ebp], edx

; 2142 :                 continue;

	jmp	$LN2@xmlBufAttr
$LN37@xmlBufAttr:

; 2143 :             }
; 2144 :             /*
; 2145 :              * We could do multiple things here. Just save
; 2146 :              * as a char ref
; 2147 :              */
; 2148 : 	    xmlSerializeHexCharRef(tmp, val);

	mov	eax, DWORD PTR _val$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmp$3[ebp]
	push	ecx
	call	_xmlSerializeHexCharRef
	add	esp, 8

; 2149 :             xmlBufAdd(buf, (xmlChar *) tmp, -1);

	push	-1
	lea	edx, DWORD PTR _tmp$3[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2150 :             cur += l;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, DWORD PTR _l$1[ebp]
	mov	DWORD PTR _cur$[ebp], ecx

; 2151 :             base = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _base$[ebp], edx

; 2152 :         } else {

	jmp	SHORT $LN6@xmlBufAttr
$LN26@xmlBufAttr:

; 2153 :             cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
$LN6@xmlBufAttr:

; 2154 :         }
; 2155 :     }

	jmp	$LN2@xmlBufAttr
$LN3@xmlBufAttr:

; 2156 :     if (base != cur)

	mov	ecx, DWORD PTR _base$[ebp]
	cmp	ecx, DWORD PTR _cur$[ebp]
	je	SHORT $LN1@xmlBufAttr

; 2157 :         xmlBufAdd(buf, base, cur - base);

	mov	edx, DWORD PTR _cur$[ebp]
	sub	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _base$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN1@xmlBufAttr:

; 2158 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN55@xmlBufAttr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN55@xmlBufAttr:
	DD	1
	DD	$LN54@xmlBufAttr
$LN54@xmlBufAttr:
	DD	-24					; ffffffe8H
	DD	12					; 0000000cH
	DD	$LN53@xmlBufAttr
$LN53@xmlBufAttr:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_xmlBufAttrSerializeTxtContent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveSetAttrEscape
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_escape$ = 12						; size = 4
_xmlSaveSetAttrEscape PROC				; COMDAT

; 2024 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2025 :     if (ctxt == NULL) return(-1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlSaveSet
	or	eax, -1
	jmp	SHORT $LN1@xmlSaveSet
$LN2@xmlSaveSet:

; 2026 :     ctxt->escapeAttr = escape;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _escape$[ebp]
	mov	DWORD PTR [eax+120], ecx

; 2027 :     return(0);

	xor	eax, eax
$LN1@xmlSaveSet:

; 2028 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSaveSetAttrEscape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveSetEscape
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_escape$ = 12						; size = 4
_xmlSaveSetEscape PROC					; COMDAT

; 2007 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2008 :     if (ctxt == NULL) return(-1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlSaveSet
	or	eax, -1
	jmp	SHORT $LN1@xmlSaveSet
$LN2@xmlSaveSet:

; 2009 :     ctxt->escape = escape;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _escape$[ebp]
	mov	DWORD PTR [eax+116], ecx

; 2010 :     return(0);

	xor	eax, eax
$LN1@xmlSaveSet:

; 2011 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSaveSetEscape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveClose
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlSaveClose PROC					; COMDAT

; 1987 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 1988 :     int ret;
; 1989 : 
; 1990 :     if (ctxt == NULL) return(-1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlSaveClo
	or	eax, -1
	jmp	SHORT $LN1@xmlSaveClo
$LN2@xmlSaveClo:

; 1991 :     ret = xmlSaveFlush(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSaveFlush
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 1992 :     xmlFreeSaveCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFreeSaveCtxt
	add	esp, 4

; 1993 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSaveClo:

; 1994 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSaveClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveFlush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSaveFlush PROC					; COMDAT

; 1970 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 1971 :     if (ctxt == NULL) return(-1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlSaveFlu
	or	eax, -1
	jmp	SHORT $LN1@xmlSaveFlu
$LN2@xmlSaveFlu:

; 1972 :     if (ctxt->buf == NULL) return(-1);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN3@xmlSaveFlu
	or	eax, -1
	jmp	SHORT $LN1@xmlSaveFlu
$LN3@xmlSaveFlu:

; 1973 :     return(xmlOutputBufferFlush(ctxt->buf));

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_xmlOutputBufferFlush
	add	esp, 4
$LN1@xmlSaveFlu:

; 1974 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSaveFlush ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveTree
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlSaveTree PROC					; COMDAT

; 1951 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 1952 :     long ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1953 : 
; 1954 :     if ((ctxt == NULL) || (node == NULL)) return(-1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlSaveTre
	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN2@xmlSaveTre
$LN3@xmlSaveTre:
	or	eax, -1
	jmp	SHORT $LN1@xmlSaveTre
$LN2@xmlSaveTre:

; 1955 :     xmlNodeDumpOutputInternal(ctxt, node);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNodeDumpOutputInternal
	add	esp, 8

; 1956 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSaveTre:

; 1957 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSaveTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveDoc
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlSaveDoc PROC					; COMDAT

; 1929 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 1930 :     long ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1931 : 
; 1932 :     if ((ctxt == NULL) || (doc == NULL)) return(-1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlSaveDoc
	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN2@xmlSaveDoc
$LN3@xmlSaveDoc:
	or	eax, -1
	jmp	SHORT $LN1@xmlSaveDoc
$LN2@xmlSaveDoc:

; 1933 :     if (xmlDocContentDumpOutput(ctxt, doc) < 0)

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDocContentDumpOutput
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN4@xmlSaveDoc

; 1934 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSaveDoc
$LN4@xmlSaveDoc:

; 1935 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSaveDoc:

; 1936 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSaveDoc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveToIO
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_iowrite$ = 8						; size = 4
_ioclose$ = 12						; size = 4
_ioctx$ = 16						; size = 4
_encoding$ = 20						; size = 4
_options$ = 24						; size = 4
_xmlSaveToIO PROC					; COMDAT

; 1903 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 1904 :     xmlSaveCtxtPtr ret;
; 1905 : 
; 1906 :     ret = xmlNewSaveCtxt(encoding, options);

	mov	eax, DWORD PTR _options$[ebp]
	push	eax
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	call	_xmlNewSaveCtxt
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1907 :     if (ret == NULL) return(NULL);

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlSaveToI
	xor	eax, eax
	jmp	SHORT $LN1@xmlSaveToI
$LN2@xmlSaveToI:

; 1908 :     ret->buf = xmlOutputBufferCreateIO(iowrite, ioclose, ioctx, ret->handler);

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _ioctx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ioclose$[ebp]
	push	edx
	mov	eax, DWORD PTR _iowrite$[ebp]
	push	eax
	call	_xmlOutputBufferCreateIO
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1909 :     if (ret->buf == NULL) {

	mov	edx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN3@xmlSaveToI

; 1910 : 	xmlFreeSaveCtxt(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlFreeSaveCtxt
	add	esp, 4

; 1911 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSaveToI
$LN3@xmlSaveToI:

; 1912 :     }
; 1913 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSaveToI:

; 1914 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSaveToIO ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveToBuffer
_TEXT	SEGMENT
_handler$ = -12						; size = 4
_out_buff$ = -8						; size = 4
_ret$ = -4						; size = 4
_buffer$ = 8						; size = 4
_encoding$ = 12						; size = 4
_options$ = 16						; size = 4
_xmlSaveToBuffer PROC					; COMDAT

; 1859 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 1860 :     xmlSaveCtxtPtr ret;
; 1861 :     xmlOutputBufferPtr out_buff;
; 1862 :     xmlCharEncodingHandlerPtr handler;
; 1863 : 
; 1864 :     ret = xmlNewSaveCtxt(encoding, options);

	mov	eax, DWORD PTR _options$[ebp]
	push	eax
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	call	_xmlNewSaveCtxt
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1865 :     if (ret == NULL) return(NULL);

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlSaveToB
	xor	eax, eax
	jmp	$LN1@xmlSaveToB
$LN2@xmlSaveToB:

; 1866 : 
; 1867 :     if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN3@xmlSaveToB

; 1868 :         handler = xmlFindCharEncodingHandler(encoding);

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1869 :         if (handler == NULL) {

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN5@xmlSaveToB

; 1870 :             xmlFree(ret);

	mov	esi, esp
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1871 :             return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSaveToB
$LN5@xmlSaveToB:

; 1872 :         }
; 1873 :     } else

	jmp	SHORT $LN4@xmlSaveToB
$LN3@xmlSaveToB:

; 1874 :         handler = NULL;

	mov	DWORD PTR _handler$[ebp], 0
$LN4@xmlSaveToB:

; 1875 :     out_buff = xmlOutputBufferCreateBuffer(buffer, handler);

	mov	ecx, DWORD PTR _handler$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_xmlOutputBufferCreateBuffer
	add	esp, 8
	mov	DWORD PTR _out_buff$[ebp], eax

; 1876 :     if (out_buff == NULL) {

	cmp	DWORD PTR _out_buff$[ebp], 0
	jne	SHORT $LN6@xmlSaveToB

; 1877 :         xmlFree(ret);

	mov	esi, esp
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1878 :         if (handler) xmlCharEncCloseFunc(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN7@xmlSaveToB
	mov	ecx, DWORD PTR _handler$[ebp]
	push	ecx
	call	_xmlCharEncCloseFunc
	add	esp, 4
$LN7@xmlSaveToB:

; 1879 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSaveToB
$LN6@xmlSaveToB:

; 1880 :     }
; 1881 : 
; 1882 :     ret->buf = out_buff;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _out_buff$[ebp]
	mov	DWORD PTR [edx+24], eax

; 1883 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSaveToB:

; 1884 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSaveToBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveToFilename
_TEXT	SEGMENT
_compression$ = -8					; size = 4
_ret$ = -4						; size = 4
_filename$ = 8						; size = 4
_encoding$ = 12						; size = 4
_options$ = 16						; size = 4
_xmlSaveToFilename PROC					; COMDAT

; 1830 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 1831 :     xmlSaveCtxtPtr ret;
; 1832 :     int compression = 0; /* TODO handle compression option */

	mov	DWORD PTR _compression$[ebp], 0

; 1833 : 
; 1834 :     ret = xmlNewSaveCtxt(encoding, options);

	mov	eax, DWORD PTR _options$[ebp]
	push	eax
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	call	_xmlNewSaveCtxt
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1835 :     if (ret == NULL) return(NULL);

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlSaveToF
	xor	eax, eax
	jmp	SHORT $LN1@xmlSaveToF
$LN2@xmlSaveToF:

; 1836 :     ret->buf = xmlOutputBufferCreateFilename(filename, ret->handler,

	mov	edx, DWORD PTR _compression$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_xmlOutputBufferCreateFilename
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1837 :                                              compression);
; 1838 :     if (ret->buf == NULL) {

	mov	edx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN3@xmlSaveToF

; 1839 : 	xmlFreeSaveCtxt(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlFreeSaveCtxt
	add	esp, 4

; 1840 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSaveToF
$LN3@xmlSaveToF:

; 1841 :     }
; 1842 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSaveToF:

; 1843 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSaveToFilename ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveToFd
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_fd$ = 8						; size = 4
_encoding$ = 12						; size = 4
_options$ = 16						; size = 4
_xmlSaveToFd PROC					; COMDAT

; 1803 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 1804 :     xmlSaveCtxtPtr ret;
; 1805 : 
; 1806 :     ret = xmlNewSaveCtxt(encoding, options);

	mov	eax, DWORD PTR _options$[ebp]
	push	eax
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	call	_xmlNewSaveCtxt
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1807 :     if (ret == NULL) return(NULL);

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlSaveToF
	xor	eax, eax
	jmp	SHORT $LN1@xmlSaveToF
$LN2@xmlSaveToF:

; 1808 :     ret->buf = xmlOutputBufferCreateFd(fd, ret->handler);

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	_xmlOutputBufferCreateFd
	add	esp, 8
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+24], eax

; 1809 :     if (ret->buf == NULL) {

	mov	eax, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN3@xmlSaveToF

; 1810 : 	xmlFreeSaveCtxt(ret);

	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlFreeSaveCtxt
	add	esp, 4

; 1811 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSaveToF
$LN3@xmlSaveToF:

; 1812 :     }
; 1813 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSaveToF:

; 1814 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSaveToFd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlIsXHTML
_TEXT	SEGMENT
_systemID$ = 8						; size = 4
_publicID$ = 12						; size = 4
_xmlIsXHTML PROC					; COMDAT

; 55   : xmlIsXHTML(const xmlChar *systemID, const xmlChar *publicID) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 56   :     if ((systemID == NULL) && (publicID == NULL))

	cmp	DWORD PTR _systemID$[ebp], 0
	jne	SHORT $LN2@xmlIsXHTML
	cmp	DWORD PTR _publicID$[ebp], 0
	jne	SHORT $LN2@xmlIsXHTML

; 57   : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlIsXHTML
$LN2@xmlIsXHTML:

; 58   :     if (publicID != NULL) {

	cmp	DWORD PTR _publicID$[ebp], 0
	je	SHORT $LN3@xmlIsXHTML

; 59   : 	if (xmlStrEqual(publicID, XHTML_STRICT_PUBLIC_ID)) return(1);

	push	OFFSET ??_C@_0CB@LIHKBLCO@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Strict?1?1E@
	mov	eax, DWORD PTR _publicID$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@xmlIsXHTML
	mov	eax, 1
	jmp	$LN1@xmlIsXHTML
$LN4@xmlIsXHTML:

; 60   : 	if (xmlStrEqual(publicID, XHTML_FRAME_PUBLIC_ID)) return(1);

	push	OFFSET ??_C@_0CD@EONGLKJJ@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Frameset?1@
	mov	ecx, DWORD PTR _publicID$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlIsXHTML
	mov	eax, 1
	jmp	SHORT $LN1@xmlIsXHTML
$LN5@xmlIsXHTML:

; 61   : 	if (xmlStrEqual(publicID, XHTML_TRANS_PUBLIC_ID)) return(1);

	push	OFFSET ??_C@_0CH@FHDGMIJF@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Transitio@
	mov	edx, DWORD PTR _publicID$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@xmlIsXHTML
	mov	eax, 1
	jmp	SHORT $LN1@xmlIsXHTML
$LN3@xmlIsXHTML:

; 62   :     }
; 63   :     if (systemID != NULL) {

	cmp	DWORD PTR _systemID$[ebp], 0
	je	SHORT $LN7@xmlIsXHTML

; 64   : 	if (xmlStrEqual(systemID, XHTML_STRICT_SYSTEM_ID)) return(1);

	push	OFFSET ??_C@_0DC@BHABDBDI@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@
	mov	eax, DWORD PTR _systemID$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlIsXHTML
	mov	eax, 1
	jmp	SHORT $LN1@xmlIsXHTML
$LN8@xmlIsXHTML:

; 65   : 	if (xmlStrEqual(systemID, XHTML_FRAME_SYSTEM_ID)) return(1);

	push	OFFSET ??_C@_0DE@CCGEPDJH@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@
	mov	ecx, DWORD PTR _systemID$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlIsXHTML
	mov	eax, 1
	jmp	SHORT $LN1@xmlIsXHTML
$LN9@xmlIsXHTML:

; 66   : 	if (xmlStrEqual(systemID, XHTML_TRANS_SYSTEM_ID)) return(1);

	push	OFFSET ??_C@_0DI@KKENBPON@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@
	mov	edx, DWORD PTR _systemID$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@xmlIsXHTML
	mov	eax, 1
	jmp	SHORT $LN1@xmlIsXHTML
$LN7@xmlIsXHTML:

; 67   :     }
; 68   :     return(0);

	xor	eax, eax
$LN1@xmlIsXHTML:

; 69   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlIsXHTML ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveFileEnc
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_cur$ = 12						; size = 4
_encoding$ = 16						; size = 4
_xmlSaveFileEnc PROC					; COMDAT

; 2739 : xmlSaveFileEnc(const char *filename, xmlDocPtr cur, const char *encoding) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2740 :     return ( xmlSaveFormatFileEnc( filename, cur, encoding, 0 ) );

	push	0
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_xmlSaveFormatFileEnc
	add	esp, 16					; 00000010H

; 2741 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSaveFileEnc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveFormatFileEnc
_TEXT	SEGMENT
tv85 = -148						; size = 4
_ret$ = -144						; size = 4
_handler$ = -140					; size = 4
_buf$ = -136						; size = 4
_ctxt$ = -128						; size = 124
_filename$ = 8						; size = 4
_cur$ = 12						; size = 4
_encoding$ = 16						; size = 4
_format$ = 20						; size = 4
_xmlSaveFormatFileEnc PROC				; COMDAT

; 2685 : 			const char * encoding, int format ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	edi
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2686 :     xmlSaveCtxt ctxt;
; 2687 :     xmlOutputBufferPtr buf;
; 2688 :     xmlCharEncodingHandlerPtr handler = NULL;

	mov	DWORD PTR _handler$[ebp], 0

; 2689 :     int ret;
; 2690 : 
; 2691 :     if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlSaveFor

; 2692 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlSaveFor
$LN2@xmlSaveFor:

; 2693 : 
; 2694 :     if (encoding == NULL)

	cmp	DWORD PTR _encoding$[ebp], 0
	jne	SHORT $LN3@xmlSaveFor

; 2695 : 	encoding = (const char *) cur->encoding;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _encoding$[ebp], ecx
$LN3@xmlSaveFor:

; 2696 : 
; 2697 :     if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN4@xmlSaveFor

; 2698 : 
; 2699 : 	    handler = xmlFindCharEncodingHandler(encoding);

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 2700 : 	    if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN4@xmlSaveFor

; 2701 : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlSaveFor
$LN4@xmlSaveFor:

; 2702 :     }
; 2703 : 
; 2704 : #ifdef LIBXML_ZLIB_ENABLED
; 2705 :     if (cur->compression < 0) cur->compression = xmlGetCompressMode();

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jge	SHORT $LN6@xmlSaveFor
	call	_xmlGetCompressMode
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN6@xmlSaveFor:

; 2706 : #endif
; 2707 :     /*
; 2708 :      * save the content to a temp buffer.
; 2709 :      */
; 2710 :     buf = xmlOutputBufferCreateFilename(filename, handler, cur->compression);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _handler$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_xmlOutputBufferCreateFilename
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buf$[ebp], eax

; 2711 :     if (buf == NULL) return(-1);

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN7@xmlSaveFor
	or	eax, -1
	jmp	$LN1@xmlSaveFor
$LN7@xmlSaveFor:

; 2712 :     memset(&ctxt, 0, sizeof(ctxt));

	push	124					; 0000007cH
	push	0
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2713 :     ctxt.doc = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _ctxt$[ebp+28], ecx

; 2714 :     ctxt.buf = buf;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _ctxt$[ebp+24], edx

; 2715 :     ctxt.level = 0;

	mov	DWORD PTR _ctxt$[ebp+36], 0

; 2716 :     ctxt.format = format ? 1 : 0;

	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN9@xmlSaveFor
	mov	DWORD PTR tv85[ebp], 1
	jmp	SHORT $LN10@xmlSaveFor
$LN9@xmlSaveFor:
	mov	DWORD PTR tv85[ebp], 0
$LN10@xmlSaveFor:
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR _ctxt$[ebp+40], eax

; 2717 :     ctxt.encoding = (const xmlChar *) encoding;

	mov	ecx, DWORD PTR _encoding$[ebp]
	mov	DWORD PTR _ctxt$[ebp+16], ecx

; 2718 :     xmlSaveCtxtInit(&ctxt);

	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSaveCtxtInit
	add	esp, 4

; 2719 :     ctxt.options |= XML_SAVE_AS_XML;

	mov	eax, DWORD PTR _ctxt$[ebp+32]
	or	eax, 32					; 00000020H
	mov	DWORD PTR _ctxt$[ebp+32], eax

; 2720 : 
; 2721 :     xmlDocContentDumpOutput(&ctxt, cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDocContentDumpOutput
	add	esp, 8

; 2722 : 
; 2723 :     ret = xmlOutputBufferClose(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferClose
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2724 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSaveFor:

; 2725 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@xmlSaveFor
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 148				; 00000094H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN13@xmlSaveFor:
	DD	1
	DD	$LN12@xmlSaveFor
$LN12@xmlSaveFor:
	DD	-128					; ffffff80H
	DD	124					; 0000007cH
	DD	$LN11@xmlSaveFor
$LN11@xmlSaveFor:
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_xmlSaveFormatFileEnc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNodeDumpOutput
_TEXT	SEGMENT
tv71 = -144						; size = 4
_is_xhtml$ = -140					; size = 4
_dtd$ = -136						; size = 4
_ctxt$ = -128						; size = 124
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_level$ = 20						; size = 4
_format$ = 24						; size = 4
_encoding$ = 28						; size = 4
_xmlNodeDumpOutput PROC					; COMDAT

; 2348 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	edi
	lea	edi, DWORD PTR [ebp-144]
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2349 :     xmlSaveCtxt ctxt;
; 2350 : #ifdef LIBXML_HTML_ENABLED
; 2351 :     xmlDtdPtr dtd;
; 2352 :     int is_xhtml = 0;

	mov	DWORD PTR _is_xhtml$[ebp], 0

; 2353 : #endif
; 2354 : 
; 2355 :     xmlInitParser();

	call	_xmlInitParser

; 2356 : 
; 2357 :     if ((buf == NULL) || (cur == NULL)) return;

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlNodeDum
	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlNodeDum
$LN3@xmlNodeDum:
	jmp	$LN1@xmlNodeDum
$LN2@xmlNodeDum:

; 2358 : 
; 2359 :     if (encoding == NULL)

	cmp	DWORD PTR _encoding$[ebp], 0
	jne	SHORT $LN4@xmlNodeDum

; 2360 :         encoding = "UTF-8";

	mov	DWORD PTR _encoding$[ebp], OFFSET ??_C@_05EGJIMALK@UTF?98@
$LN4@xmlNodeDum:

; 2361 : 
; 2362 :     memset(&ctxt, 0, sizeof(ctxt));

	push	124					; 0000007cH
	push	0
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2363 :     ctxt.doc = doc;

	mov	ecx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR _ctxt$[ebp+28], ecx

; 2364 :     ctxt.buf = buf;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _ctxt$[ebp+24], edx

; 2365 :     ctxt.level = level;

	mov	eax, DWORD PTR _level$[ebp]
	mov	DWORD PTR _ctxt$[ebp+36], eax

; 2366 :     ctxt.format = format ? 1 : 0;

	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN10@xmlNodeDum
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN11@xmlNodeDum
$LN10@xmlNodeDum:
	mov	DWORD PTR tv71[ebp], 0
$LN11@xmlNodeDum:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _ctxt$[ebp+40], ecx

; 2367 :     ctxt.encoding = (const xmlChar *) encoding;

	mov	edx, DWORD PTR _encoding$[ebp]
	mov	DWORD PTR _ctxt$[ebp+16], edx

; 2368 :     xmlSaveCtxtInit(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSaveCtxtInit
	add	esp, 4

; 2369 :     ctxt.options |= XML_SAVE_AS_XML;

	mov	ecx, DWORD PTR _ctxt$[ebp+32]
	or	ecx, 32					; 00000020H
	mov	DWORD PTR _ctxt$[ebp+32], ecx

; 2370 : 
; 2371 : #ifdef LIBXML_HTML_ENABLED
; 2372 :     dtd = xmlGetIntSubset(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlGetIntSubset
	add	esp, 4
	mov	DWORD PTR _dtd$[ebp], eax

; 2373 :     if (dtd != NULL) {

	cmp	DWORD PTR _dtd$[ebp], 0
	je	SHORT $LN5@xmlNodeDum

; 2374 : 	is_xhtml = xmlIsXHTML(dtd->SystemID, dtd->ExternalID);

	mov	eax, DWORD PTR _dtd$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _dtd$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	_xmlIsXHTML
	add	esp, 8
	mov	DWORD PTR _is_xhtml$[ebp], eax

; 2375 : 	if (is_xhtml < 0)

	cmp	DWORD PTR _is_xhtml$[ebp], 0
	jge	SHORT $LN5@xmlNodeDum

; 2376 : 	    is_xhtml = 0;

	mov	DWORD PTR _is_xhtml$[ebp], 0
$LN5@xmlNodeDum:

; 2377 :     }
; 2378 : 
; 2379 :     if (is_xhtml)

	cmp	DWORD PTR _is_xhtml$[ebp], 0
	je	SHORT $LN7@xmlNodeDum

; 2380 :         xhtmlNodeDumpOutput(&ctxt, cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xhtmlNodeDumpOutput
	add	esp, 8
	jmp	SHORT $LN1@xmlNodeDum
$LN7@xmlNodeDum:

; 2381 :     else
; 2382 : #endif
; 2383 :         xmlNodeDumpOutputInternal(&ctxt, cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNodeDumpOutputInternal
	add	esp, 8
$LN1@xmlNodeDum:

; 2384 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@xmlNodeDum
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 144				; 00000090H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN14@xmlNodeDum:
	DD	1
	DD	$LN13@xmlNodeDum
$LN13@xmlNodeDum:
	DD	-128					; ffffff80H
	DD	124					; 0000007cH
	DD	$LN12@xmlNodeDum
$LN12@xmlNodeDum:
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_xmlNodeDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveFormatFileTo
_TEXT	SEGMENT
tv75 = -140						; size = 4
_ret$ = -136						; size = 4
_ctxt$ = -128						; size = 124
_buf$ = 8						; size = 4
_cur$ = 12						; size = 4
_encoding$ = 16						; size = 4
_format$ = 20						; size = 4
_xmlSaveFormatFileTo PROC				; COMDAT

; 2646 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	edi
	lea	edi, DWORD PTR [ebp-140]
	mov	ecx, 35					; 00000023H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2647 :     xmlSaveCtxt ctxt;
; 2648 :     int ret;
; 2649 : 
; 2650 :     if (buf == NULL) return(-1);

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN2@xmlSaveFor
	or	eax, -1
	jmp	$LN1@xmlSaveFor
$LN2@xmlSaveFor:

; 2651 :     if ((cur == NULL) ||

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN4@xmlSaveFor
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 9
	je	SHORT $LN3@xmlSaveFor
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	je	SHORT $LN3@xmlSaveFor
$LN4@xmlSaveFor:

; 2652 :         ((cur->type != XML_DOCUMENT_NODE) &&
; 2653 : 	 (cur->type != XML_HTML_DOCUMENT_NODE))) {
; 2654 :         xmlOutputBufferClose(buf);

	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferClose
	add	esp, 4

; 2655 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlSaveFor
$LN3@xmlSaveFor:

; 2656 :     }
; 2657 :     memset(&ctxt, 0, sizeof(ctxt));

	push	124					; 0000007cH
	push	0
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2658 :     ctxt.doc = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _ctxt$[ebp+28], ecx

; 2659 :     ctxt.buf = buf;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _ctxt$[ebp+24], edx

; 2660 :     ctxt.level = 0;

	mov	DWORD PTR _ctxt$[ebp+36], 0

; 2661 :     ctxt.format = format ? 1 : 0;

	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN6@xmlSaveFor
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN7@xmlSaveFor
$LN6@xmlSaveFor:
	mov	DWORD PTR tv75[ebp], 0
$LN7@xmlSaveFor:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR _ctxt$[ebp+40], eax

; 2662 :     ctxt.encoding = (const xmlChar *) encoding;

	mov	ecx, DWORD PTR _encoding$[ebp]
	mov	DWORD PTR _ctxt$[ebp+16], ecx

; 2663 :     xmlSaveCtxtInit(&ctxt);

	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSaveCtxtInit
	add	esp, 4

; 2664 :     ctxt.options |= XML_SAVE_AS_XML;

	mov	eax, DWORD PTR _ctxt$[ebp+32]
	or	eax, 32					; 00000020H
	mov	DWORD PTR _ctxt$[ebp+32], eax

; 2665 :     xmlDocContentDumpOutput(&ctxt, cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDocContentDumpOutput
	add	esp, 8

; 2666 :     ret = xmlOutputBufferClose(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferClose
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2667 :     return (ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSaveFor:

; 2668 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@xmlSaveFor
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 140				; 0000008cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@xmlSaveFor:
	DD	1
	DD	$LN9@xmlSaveFor
$LN9@xmlSaveFor:
	DD	-128					; ffffff80H
	DD	124					; 0000007cH
	DD	$LN8@xmlSaveFor
$LN8@xmlSaveFor:
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_xmlSaveFormatFileTo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveFileTo
_TEXT	SEGMENT
_ret$ = -136						; size = 4
_ctxt$ = -128						; size = 124
_buf$ = 8						; size = 4
_cur$ = 12						; size = 4
_encoding$ = 16						; size = 4
_xmlSaveFileTo PROC					; COMDAT

; 2608 : xmlSaveFileTo(xmlOutputBufferPtr buf, xmlDocPtr cur, const char *encoding) {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	edi
	lea	edi, DWORD PTR [ebp-136]
	mov	ecx, 34					; 00000022H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2609 :     xmlSaveCtxt ctxt;
; 2610 :     int ret;
; 2611 : 
; 2612 :     if (buf == NULL) return(-1);

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN2@xmlSaveFil
	or	eax, -1
	jmp	$LN1@xmlSaveFil
$LN2@xmlSaveFil:

; 2613 :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN3@xmlSaveFil

; 2614 :         xmlOutputBufferClose(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferClose
	add	esp, 4

; 2615 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSaveFil
$LN3@xmlSaveFil:

; 2616 :     }
; 2617 :     memset(&ctxt, 0, sizeof(ctxt));

	push	124					; 0000007cH
	push	0
	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2618 :     ctxt.doc = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _ctxt$[ebp+28], edx

; 2619 :     ctxt.buf = buf;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _ctxt$[ebp+24], eax

; 2620 :     ctxt.level = 0;

	mov	DWORD PTR _ctxt$[ebp+36], 0

; 2621 :     ctxt.format = 0;

	mov	DWORD PTR _ctxt$[ebp+40], 0

; 2622 :     ctxt.encoding = (const xmlChar *) encoding;

	mov	ecx, DWORD PTR _encoding$[ebp]
	mov	DWORD PTR _ctxt$[ebp+16], ecx

; 2623 :     xmlSaveCtxtInit(&ctxt);

	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSaveCtxtInit
	add	esp, 4

; 2624 :     ctxt.options |= XML_SAVE_AS_XML;

	mov	eax, DWORD PTR _ctxt$[ebp+32]
	or	eax, 32					; 00000020H
	mov	DWORD PTR _ctxt$[ebp+32], eax

; 2625 :     xmlDocContentDumpOutput(&ctxt, cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDocContentDumpOutput
	add	esp, 8

; 2626 :     ret = xmlOutputBufferClose(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferClose
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2627 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSaveFil:

; 2628 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@xmlSaveFil
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 136				; 00000088H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN7@xmlSaveFil:
	DD	1
	DD	$LN6@xmlSaveFil
$LN6@xmlSaveFil:
	DD	-128					; ffffff80H
	DD	124					; 0000007cH
	DD	$LN5@xmlSaveFil
$LN5@xmlSaveFil:
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_xmlSaveFileTo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNodeDump
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_buffer$ = -4						; size = 4
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_level$ = 20						; size = 4
_format$ = 24						; size = 4
_xmlNodeDump PROC					; COMDAT

; 2203 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2204 :     xmlBufPtr buffer;
; 2205 :     int ret;
; 2206 : 
; 2207 :     if ((buf == NULL) || (cur == NULL))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlNodeDum
	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlNodeDum
$LN3@xmlNodeDum:

; 2208 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlNodeDum
$LN2@xmlNodeDum:

; 2209 :     buffer = xmlBufFromBuffer(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufFromBuffer
	add	esp, 4
	mov	DWORD PTR _buffer$[ebp], eax

; 2210 :     if (buffer == NULL)

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN4@xmlNodeDum

; 2211 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlNodeDum
$LN4@xmlNodeDum:

; 2212 :     ret = xmlBufNodeDump(buffer, doc, cur, level, format);

	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	mov	edx, DWORD PTR _level$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_xmlBufNodeDump
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret$[ebp], eax

; 2213 :     xmlBufBackToBuffer(buffer);

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_xmlBufBackToBuffer
	add	esp, 4

; 2214 :     if (ret > INT_MAX)

	cmp	DWORD PTR _ret$[ebp], 2147483647	; 7fffffffH
	jle	SHORT $LN5@xmlNodeDum

; 2215 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlNodeDum
$LN5@xmlNodeDum:

; 2216 :     return((int) ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlNodeDum:

; 2217 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNodeDump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlBufNodeDump
_TEXT	SEGMENT
_oldalloc$ = -16					; size = 4
_outbuf$ = -12						; size = 4
_ret$ = -8						; size = 4
_use$ = -4						; size = 4
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_level$ = 20						; size = 4
_format$ = 24						; size = 4
_xmlBufNodeDump PROC					; COMDAT

; 2238 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2239 :     size_t use;
; 2240 :     int ret;
; 2241 :     xmlOutputBufferPtr outbuf;
; 2242 :     int oldalloc;
; 2243 : 
; 2244 :     xmlInitParser();

	call	_xmlInitParser

; 2245 : 
; 2246 :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlBufNode

; 2247 : #ifdef DEBUG_TREE
; 2248 :         xmlGenericError(xmlGenericErrorContext,
; 2249 :                         "xmlNodeDump : node == NULL\n");
; 2250 : #endif
; 2251 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlBufNode
$LN2@xmlBufNode:

; 2252 :     }
; 2253 :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN3@xmlBufNode

; 2254 : #ifdef DEBUG_TREE
; 2255 :         xmlGenericError(xmlGenericErrorContext,
; 2256 :                         "xmlNodeDump : buf == NULL\n");
; 2257 : #endif
; 2258 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlBufNode
$LN3@xmlBufNode:

; 2259 :     }
; 2260 :     outbuf = (xmlOutputBufferPtr) xmlMalloc(sizeof(xmlOutputBuffer));

	mov	esi, esp
	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _outbuf$[ebp], eax

; 2261 :     if (outbuf == NULL) {

	cmp	DWORD PTR _outbuf$[ebp], 0
	jne	SHORT $LN4@xmlBufNode

; 2262 :         xmlSaveErrMemory("creating buffer");

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	call	_xmlSaveErrMemory
	add	esp, 4

; 2263 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlBufNode
$LN4@xmlBufNode:

; 2264 :     }
; 2265 :     memset(outbuf, 0, (size_t) sizeof(xmlOutputBuffer));

	xor	eax, eax
	mov	ecx, DWORD PTR _outbuf$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], eax

; 2266 :     outbuf->buffer = buf;

	mov	edx, DWORD PTR _outbuf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+16], eax

; 2267 :     outbuf->encoder = NULL;

	mov	ecx, DWORD PTR _outbuf$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 2268 :     outbuf->writecallback = NULL;

	mov	edx, DWORD PTR _outbuf$[ebp]
	mov	DWORD PTR [edx+4], 0

; 2269 :     outbuf->closecallback = NULL;

	mov	eax, DWORD PTR _outbuf$[ebp]
	mov	DWORD PTR [eax+8], 0

; 2270 :     outbuf->context = NULL;

	mov	ecx, DWORD PTR _outbuf$[ebp]
	mov	DWORD PTR [ecx], 0

; 2271 :     outbuf->written = 0;

	mov	edx, DWORD PTR _outbuf$[ebp]
	mov	DWORD PTR [edx+24], 0

; 2272 : 
; 2273 :     use = xmlBufUse(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufUse
	add	esp, 4
	mov	DWORD PTR _use$[ebp], eax

; 2274 :     oldalloc = xmlBufGetAllocationScheme(buf);

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufGetAllocationScheme
	add	esp, 4
	mov	DWORD PTR _oldalloc$[ebp], eax

; 2275 :     xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);

	push	0
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufSetAllocationScheme
	add	esp, 8

; 2276 :     xmlNodeDumpOutput(outbuf, doc, cur, level, format, NULL);

	push	0
	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	mov	ecx, DWORD PTR _level$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outbuf$[ebp]
	push	ecx
	call	_xmlNodeDumpOutput
	add	esp, 24					; 00000018H

; 2277 :     xmlBufSetAllocationScheme(buf, oldalloc);

	mov	edx, DWORD PTR _oldalloc$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufSetAllocationScheme
	add	esp, 8

; 2278 :     xmlFree(outbuf);

	mov	esi, esp
	mov	ecx, DWORD PTR _outbuf$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2279 :     ret = xmlBufUse(buf) - use;

	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufUse
	add	esp, 4
	sub	eax, DWORD PTR _use$[ebp]
	mov	DWORD PTR _ret$[ebp], eax

; 2280 :     return (ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlBufNode:

; 2281 : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufNodeDump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveFormatFile
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_cur$ = 12						; size = 4
_format$ = 16						; size = 4
_xmlSaveFormatFile PROC					; COMDAT

; 2758 : xmlSaveFormatFile(const char *filename, xmlDocPtr cur, int format) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2759 :     return ( xmlSaveFormatFileEnc( filename, cur, NULL, format ) );

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_xmlSaveFormatFileEnc
	add	esp, 16					; 00000010H

; 2760 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSaveFormatFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveFile
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlSaveFile PROC					; COMDAT

; 2773 : xmlSaveFile(const char *filename, xmlDocPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2774 :     return(xmlSaveFormatFileEnc(filename, cur, NULL, 0));

	push	0
	push	0
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_xmlSaveFormatFileEnc
	add	esp, 16					; 00000010H

; 2775 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSaveFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlElemDump
_TEXT	SEGMENT
_outbuf$ = -4						; size = 4
_f$ = 8							; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_xmlElemDump PROC					; COMDAT

; 2293 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2294 :     xmlOutputBufferPtr outbuf;
; 2295 : 
; 2296 :     xmlInitParser();

	call	_xmlInitParser

; 2297 : 
; 2298 :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlElemDum

; 2299 : #ifdef DEBUG_TREE
; 2300 :         xmlGenericError(xmlGenericErrorContext,
; 2301 :                         "xmlElemDump : cur == NULL\n");
; 2302 : #endif
; 2303 :         return;

	jmp	SHORT $LN1@xmlElemDum
$LN2@xmlElemDum:

; 2304 :     }
; 2305 : #ifdef DEBUG_TREE
; 2306 :     if (doc == NULL) {
; 2307 :         xmlGenericError(xmlGenericErrorContext,
; 2308 :                         "xmlElemDump : doc == NULL\n");
; 2309 :     }
; 2310 : #endif
; 2311 : 
; 2312 :     outbuf = xmlOutputBufferCreateFile(f, NULL);

	push	0
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_xmlOutputBufferCreateFile
	add	esp, 8
	mov	DWORD PTR _outbuf$[ebp], eax

; 2313 :     if (outbuf == NULL)

	cmp	DWORD PTR _outbuf$[ebp], 0
	jne	SHORT $LN3@xmlElemDum

; 2314 :         return;

	jmp	SHORT $LN1@xmlElemDum
$LN3@xmlElemDum:

; 2315 :     if ((doc != NULL) && (doc->type == XML_HTML_DOCUMENT_NODE)) {

	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN4@xmlElemDum
	mov	ecx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	jne	SHORT $LN4@xmlElemDum

; 2316 : #ifdef LIBXML_HTML_ENABLED
; 2317 :         htmlNodeDumpOutput(outbuf, doc, cur, NULL);

	push	0
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outbuf$[ebp]
	push	ecx
	call	_htmlNodeDumpOutput
	add	esp, 16					; 00000010H

; 2318 : #else
; 2319 : 	xmlSaveErr(XML_ERR_INTERNAL_ERROR, cur, "HTML support not compiled in\n");
; 2320 : #endif /* LIBXML_HTML_ENABLED */
; 2321 :     } else

	jmp	SHORT $LN5@xmlElemDum
$LN4@xmlElemDum:

; 2322 :         xmlNodeDumpOutput(outbuf, doc, cur, 0, 1, NULL);

	push	0
	push	1
	push	0
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outbuf$[ebp]
	push	ecx
	call	_xmlNodeDumpOutput
	add	esp, 24					; 00000018H
$LN5@xmlElemDum:

; 2323 :     xmlOutputBufferClose(outbuf);

	mov	edx, DWORD PTR _outbuf$[ebp]
	push	edx
	call	_xmlOutputBufferClose
	add	esp, 4
$LN1@xmlElemDum:

; 2324 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlElemDump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlDocDump
_TEXT	SEGMENT
_f$ = 8							; size = 4
_cur$ = 12						; size = 4
_xmlDocDump PROC					; COMDAT

; 2591 : xmlDocDump(FILE *f, xmlDocPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2592 :     return(xmlDocFormatDump (f, cur, 0));

	push	0
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_xmlDocFormatDump
	add	esp, 12					; 0000000cH

; 2593 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlDocDump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlDocFormatDump
_TEXT	SEGMENT
tv81 = -152						; size = 4
_ret$ = -148						; size = 4
_handler$ = -144					; size = 4
_encoding$ = -140					; size = 4
_buf$ = -136						; size = 4
_ctxt$ = -128						; size = 124
_f$ = 8							; size = 4
_cur$ = 12						; size = 4
_format$ = 16						; size = 4
_xmlDocFormatDump PROC					; COMDAT

; 2541 : xmlDocFormatDump(FILE *f, xmlDocPtr cur, int format) {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-152]
	mov	ecx, 38					; 00000026H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2542 :     xmlSaveCtxt ctxt;
; 2543 :     xmlOutputBufferPtr buf;
; 2544 :     const char * encoding;
; 2545 :     xmlCharEncodingHandlerPtr handler = NULL;

	mov	DWORD PTR _handler$[ebp], 0

; 2546 :     int ret;
; 2547 : 
; 2548 :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlDocForm

; 2549 : #ifdef DEBUG_TREE
; 2550 :         xmlGenericError(xmlGenericErrorContext,
; 2551 : 		"xmlDocDump : document == NULL\n");
; 2552 : #endif
; 2553 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlDocForm
$LN2@xmlDocForm:

; 2554 :     }
; 2555 :     encoding = (const char *) cur->encoding;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _encoding$[ebp], ecx

; 2556 : 
; 2557 :     if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN3@xmlDocForm

; 2558 : 	handler = xmlFindCharEncodingHandler(encoding);

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 2559 : 	if (handler == NULL) {

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN3@xmlDocForm

; 2560 : 	    xmlFree((char *) cur->encoding);

	mov	esi, esp
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2561 : 	    cur->encoding = NULL;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+60], 0

; 2562 : 	    encoding = NULL;

	mov	DWORD PTR _encoding$[ebp], 0
$LN3@xmlDocForm:

; 2563 : 	}
; 2564 :     }
; 2565 :     buf = xmlOutputBufferCreateFile(f, handler);

	mov	eax, DWORD PTR _handler$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_xmlOutputBufferCreateFile
	add	esp, 8
	mov	DWORD PTR _buf$[ebp], eax

; 2566 :     if (buf == NULL) return(-1);

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN5@xmlDocForm
	or	eax, -1
	jmp	$LN1@xmlDocForm
$LN5@xmlDocForm:

; 2567 :     memset(&ctxt, 0, sizeof(ctxt));

	push	124					; 0000007cH
	push	0
	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 2568 :     ctxt.doc = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _ctxt$[ebp+28], eax

; 2569 :     ctxt.buf = buf;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _ctxt$[ebp+24], ecx

; 2570 :     ctxt.level = 0;

	mov	DWORD PTR _ctxt$[ebp+36], 0

; 2571 :     ctxt.format = format ? 1 : 0;

	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN7@xmlDocForm
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN8@xmlDocForm
$LN7@xmlDocForm:
	mov	DWORD PTR tv81[ebp], 0
$LN8@xmlDocForm:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _ctxt$[ebp+40], edx

; 2572 :     ctxt.encoding = (const xmlChar *) encoding;

	mov	eax, DWORD PTR _encoding$[ebp]
	mov	DWORD PTR _ctxt$[ebp+16], eax

; 2573 :     xmlSaveCtxtInit(&ctxt);

	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSaveCtxtInit
	add	esp, 4

; 2574 :     ctxt.options |= XML_SAVE_AS_XML;

	mov	edx, DWORD PTR _ctxt$[ebp+32]
	or	edx, 32					; 00000020H
	mov	DWORD PTR _ctxt$[ebp+32], edx

; 2575 :     xmlDocContentDumpOutput(&ctxt, cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDocContentDumpOutput
	add	esp, 8

; 2576 : 
; 2577 :     ret = xmlOutputBufferClose(buf);

	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferClose
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2578 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlDocForm:

; 2579 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@xmlDocForm
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 152				; 00000098H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN11@xmlDocForm:
	DD	1
	DD	$LN10@xmlDocForm
$LN10@xmlDocForm:
	DD	-128					; ffffff80H
	DD	124					; 0000007cH
	DD	$LN9@xmlDocForm
$LN9@xmlDocForm:
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_xmlDocFormatDump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlDocDumpFormatMemoryEnc
_TEXT	SEGMENT
tv84 = -156						; size = 4
_conv_hdlr$ = -152					; size = 4
_out_buff$ = -148					; size = 4
_dummy$ = -140						; size = 4
_ctxt$ = -128						; size = 124
_out_doc$ = 8						; size = 4
_doc_txt_ptr$ = 12					; size = 4
_doc_txt_len$ = 16					; size = 4
_txt_encoding$ = 20					; size = 4
_format$ = 24						; size = 4
_xmlDocDumpFormatMemoryEnc PROC				; COMDAT

; 2404 : 		int format) {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	push	edi
	lea	edi, DWORD PTR [ebp-156]
	mov	ecx, 39					; 00000027H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2405 :     xmlSaveCtxt ctxt;
; 2406 :     int                         dummy = 0;

	mov	DWORD PTR _dummy$[ebp], 0

; 2407 :     xmlOutputBufferPtr          out_buff = NULL;

	mov	DWORD PTR _out_buff$[ebp], 0

; 2408 :     xmlCharEncodingHandlerPtr   conv_hdlr = NULL;

	mov	DWORD PTR _conv_hdlr$[ebp], 0

; 2409 : 
; 2410 :     if (doc_txt_len == NULL) {

	cmp	DWORD PTR _doc_txt_len$[ebp], 0
	jne	SHORT $LN2@xmlDocDump

; 2411 :         doc_txt_len = &dummy;   /*  Continue, caller just won't get length */

	lea	eax, DWORD PTR _dummy$[ebp]
	mov	DWORD PTR _doc_txt_len$[ebp], eax
$LN2@xmlDocDump:

; 2412 :     }
; 2413 : 
; 2414 :     if (doc_txt_ptr == NULL) {

	cmp	DWORD PTR _doc_txt_ptr$[ebp], 0
	jne	SHORT $LN3@xmlDocDump

; 2415 :         *doc_txt_len = 0;

	mov	ecx, DWORD PTR _doc_txt_len$[ebp]
	mov	DWORD PTR [ecx], 0

; 2416 :         return;

	jmp	$LN1@xmlDocDump
$LN3@xmlDocDump:

; 2417 :     }
; 2418 : 
; 2419 :     *doc_txt_ptr = NULL;

	mov	edx, DWORD PTR _doc_txt_ptr$[ebp]
	mov	DWORD PTR [edx], 0

; 2420 :     *doc_txt_len = 0;

	mov	eax, DWORD PTR _doc_txt_len$[ebp]
	mov	DWORD PTR [eax], 0

; 2421 : 
; 2422 :     if (out_doc == NULL) {

	cmp	DWORD PTR _out_doc$[ebp], 0
	jne	SHORT $LN4@xmlDocDump

; 2423 :         /*  No document, no output  */
; 2424 :         return;

	jmp	$LN1@xmlDocDump
$LN4@xmlDocDump:

; 2425 :     }
; 2426 : 
; 2427 :     /*
; 2428 :      *  Validate the encoding value, if provided.
; 2429 :      *  This logic is copied from xmlSaveFileEnc.
; 2430 :      */
; 2431 : 
; 2432 :     if (txt_encoding == NULL)

	cmp	DWORD PTR _txt_encoding$[ebp], 0
	jne	SHORT $LN5@xmlDocDump

; 2433 : 	txt_encoding = (const char *) out_doc->encoding;

	mov	ecx, DWORD PTR _out_doc$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR _txt_encoding$[ebp], edx
$LN5@xmlDocDump:

; 2434 :     if (txt_encoding != NULL) {

	cmp	DWORD PTR _txt_encoding$[ebp], 0
	je	SHORT $LN6@xmlDocDump

; 2435 : 	conv_hdlr = xmlFindCharEncodingHandler(txt_encoding);

	mov	eax, DWORD PTR _txt_encoding$[ebp]
	push	eax
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _conv_hdlr$[ebp], eax

; 2436 : 	if ( conv_hdlr == NULL ) {

	cmp	DWORD PTR _conv_hdlr$[ebp], 0
	jne	SHORT $LN6@xmlDocDump

; 2437 : 	    xmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, (xmlNodePtr) out_doc,

	mov	ecx, DWORD PTR _txt_encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out_doc$[ebp]
	push	edx
	push	1403					; 0000057bH
	call	_xmlSaveErr
	add	esp, 12					; 0000000cH

; 2438 : 		       txt_encoding);
; 2439 : 	    return;

	jmp	$LN1@xmlDocDump
$LN6@xmlDocDump:

; 2440 : 	}
; 2441 :     }
; 2442 : 
; 2443 :     if ((out_buff = xmlAllocOutputBuffer(conv_hdlr)) == NULL ) {

	mov	eax, DWORD PTR _conv_hdlr$[ebp]
	push	eax
	call	_xmlAllocOutputBuffer
	add	esp, 4
	mov	DWORD PTR _out_buff$[ebp], eax
	cmp	DWORD PTR _out_buff$[ebp], 0
	jne	SHORT $LN8@xmlDocDump

; 2444 :         xmlSaveErrMemory("creating buffer");

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	call	_xmlSaveErrMemory
	add	esp, 4

; 2445 :         return;

	jmp	$LN1@xmlDocDump
$LN8@xmlDocDump:

; 2446 :     }
; 2447 : 
; 2448 :     memset(&ctxt, 0, sizeof(ctxt));

	push	124					; 0000007cH
	push	0
	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2449 :     ctxt.doc = out_doc;

	mov	edx, DWORD PTR _out_doc$[ebp]
	mov	DWORD PTR _ctxt$[ebp+28], edx

; 2450 :     ctxt.buf = out_buff;

	mov	eax, DWORD PTR _out_buff$[ebp]
	mov	DWORD PTR _ctxt$[ebp+24], eax

; 2451 :     ctxt.level = 0;

	mov	DWORD PTR _ctxt$[ebp+36], 0

; 2452 :     ctxt.format = format ? 1 : 0;

	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN13@xmlDocDump
	mov	DWORD PTR tv84[ebp], 1
	jmp	SHORT $LN14@xmlDocDump
$LN13@xmlDocDump:
	mov	DWORD PTR tv84[ebp], 0
$LN14@xmlDocDump:
	mov	ecx, DWORD PTR tv84[ebp]
	mov	DWORD PTR _ctxt$[ebp+40], ecx

; 2453 :     ctxt.encoding = (const xmlChar *) txt_encoding;

	mov	edx, DWORD PTR _txt_encoding$[ebp]
	mov	DWORD PTR _ctxt$[ebp+16], edx

; 2454 :     xmlSaveCtxtInit(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSaveCtxtInit
	add	esp, 4

; 2455 :     ctxt.options |= XML_SAVE_AS_XML;

	mov	ecx, DWORD PTR _ctxt$[ebp+32]
	or	ecx, 32					; 00000020H
	mov	DWORD PTR _ctxt$[ebp+32], ecx

; 2456 :     xmlDocContentDumpOutput(&ctxt, out_doc);

	mov	edx, DWORD PTR _out_doc$[ebp]
	push	edx
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDocContentDumpOutput
	add	esp, 8

; 2457 :     xmlOutputBufferFlush(out_buff);

	mov	ecx, DWORD PTR _out_buff$[ebp]
	push	ecx
	call	_xmlOutputBufferFlush
	add	esp, 4

; 2458 :     if (out_buff->conv != NULL) {

	mov	edx, DWORD PTR _out_buff$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN9@xmlDocDump

; 2459 : 	*doc_txt_len = xmlBufUse(out_buff->conv);

	mov	eax, DWORD PTR _out_buff$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_xmlBufUse
	add	esp, 4
	mov	edx, DWORD PTR _doc_txt_len$[ebp]
	mov	DWORD PTR [edx], eax

; 2460 : 	*doc_txt_ptr = xmlStrndup(xmlBufContent(out_buff->conv), *doc_txt_len);

	mov	eax, DWORD PTR _doc_txt_len$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _out_buff$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_xmlBufContent
	add	esp, 4
	push	eax
	call	_xmlStrndup
	add	esp, 8
	mov	ecx, DWORD PTR _doc_txt_ptr$[ebp]
	mov	DWORD PTR [ecx], eax

; 2461 :     } else {

	jmp	SHORT $LN10@xmlDocDump
$LN9@xmlDocDump:

; 2462 : 	*doc_txt_len = xmlBufUse(out_buff->buffer);

	mov	edx, DWORD PTR _out_buff$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufUse
	add	esp, 4
	mov	ecx, DWORD PTR _doc_txt_len$[ebp]
	mov	DWORD PTR [ecx], eax

; 2463 : 	*doc_txt_ptr = xmlStrndup(xmlBufContent(out_buff->buffer),*doc_txt_len);

	mov	edx, DWORD PTR _doc_txt_len$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _out_buff$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufContent
	add	esp, 4
	push	eax
	call	_xmlStrndup
	add	esp, 8
	mov	ecx, DWORD PTR _doc_txt_ptr$[ebp]
	mov	DWORD PTR [ecx], eax
$LN10@xmlDocDump:

; 2464 :     }
; 2465 :     (void)xmlOutputBufferClose(out_buff);

	mov	edx, DWORD PTR _out_buff$[ebp]
	push	edx
	call	_xmlOutputBufferClose
	add	esp, 4

; 2466 : 
; 2467 :     if ((*doc_txt_ptr == NULL) && (*doc_txt_len > 0)) {

	mov	eax, DWORD PTR _doc_txt_ptr$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@xmlDocDump
	mov	ecx, DWORD PTR _doc_txt_len$[ebp]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN1@xmlDocDump

; 2468 :         *doc_txt_len = 0;

	mov	edx, DWORD PTR _doc_txt_len$[ebp]
	mov	DWORD PTR [edx], 0

; 2469 :         xmlSaveErrMemory("creating output");

	push	OFFSET ??_C@_0BA@CMJGPMBH@creating?5output@
	call	_xmlSaveErrMemory
	add	esp, 4
$LN1@xmlDocDump:

; 2470 :     }
; 2471 : 
; 2472 :     return;
; 2473 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@xmlDocDump
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 156				; 0000009cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN18@xmlDocDump:
	DD	2
	DD	$LN17@xmlDocDump
$LN17@xmlDocDump:
	DD	-128					; ffffff80H
	DD	124					; 0000007cH
	DD	$LN15@xmlDocDump
	DD	-140					; ffffff74H
	DD	4
	DD	$LN16@xmlDocDump
$LN16@xmlDocDump:
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	121					; 00000079H
	DB	0
$LN15@xmlDocDump:
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_xmlDocDumpFormatMemoryEnc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlDocDumpMemoryEnc
_TEXT	SEGMENT
_out_doc$ = 8						; size = 4
_doc_txt_ptr$ = 12					; size = 4
_doc_txt_len$ = 16					; size = 4
_txt_encoding$ = 20					; size = 4
_xmlDocDumpMemoryEnc PROC				; COMDAT

; 2523 : 	            int * doc_txt_len, const char * txt_encoding) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2524 :     xmlDocDumpFormatMemoryEnc(out_doc, doc_txt_ptr, doc_txt_len,

	push	0
	mov	eax, DWORD PTR _txt_encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc_txt_len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc_txt_ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _out_doc$[ebp]
	push	eax
	call	_xmlDocDumpFormatMemoryEnc
	add	esp, 20					; 00000014H

; 2525 : 	                      txt_encoding, 0);
; 2526 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlDocDumpMemoryEnc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlDocDumpMemory
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_mem$ = 12						; size = 4
_size$ = 16						; size = 4
_xmlDocDumpMemory PROC					; COMDAT

; 2487 : xmlDocDumpMemory(xmlDocPtr cur, xmlChar**mem, int *size) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2488 :     xmlDocDumpFormatMemoryEnc(cur, mem, size, NULL, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlDocDumpFormatMemoryEnc
	add	esp, 20					; 00000014H

; 2489 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlDocDumpMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlDocDumpFormatMemory
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_mem$ = 12						; size = 4
_size$ = 16						; size = 4
_format$ = 20						; size = 4
_xmlDocDumpFormatMemory PROC				; COMDAT

; 2505 : xmlDocDumpFormatMemory(xmlDocPtr cur, xmlChar**mem, int *size, int format) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2506 :     xmlDocDumpFormatMemoryEnc(cur, mem, size, NULL, format);

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlDocDumpFormatMemoryEnc
	add	esp, 20					; 00000014H

; 2507 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlDocDumpFormatMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlAttrSerializeTxtContent
_TEXT	SEGMENT
_buffer$ = -4						; size = 4
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_attr$ = 16						; size = 4
_string$ = 20						; size = 4
_xmlAttrSerializeTxtContent PROC			; COMDAT

; 2172 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4

; 2173 :     xmlBufPtr buffer;
; 2174 : 
; 2175 :     if ((buf == NULL) || (string == NULL))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlAttrSer
	cmp	DWORD PTR _string$[ebp], 0
	jne	SHORT $LN2@xmlAttrSer
$LN3@xmlAttrSer:

; 2176 :         return;

	jmp	SHORT $LN1@xmlAttrSer
$LN2@xmlAttrSer:

; 2177 :     buffer = xmlBufFromBuffer(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufFromBuffer
	add	esp, 4
	mov	DWORD PTR _buffer$[ebp], eax

; 2178 :     if (buffer == NULL)

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN4@xmlAttrSer

; 2179 :         return;

	jmp	SHORT $LN1@xmlAttrSer
$LN4@xmlAttrSer:

; 2180 :     xmlBufAttrSerializeTxtContent(buffer, doc, attr, string);

	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	mov	edx, DWORD PTR _attr$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_xmlBufAttrSerializeTxtContent
	add	esp, 16					; 00000010H

; 2181 :     xmlBufBackToBuffer(buffer);

	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_xmlBufBackToBuffer
	add	esp, 4
$LN1@xmlAttrSer:

; 2182 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAttrSerializeTxtContent ENDP
_TEXT	ENDS
END
