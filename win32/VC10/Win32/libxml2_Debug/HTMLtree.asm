; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\HTMLtree.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_07FJOBMBFC@checked@			; `string'
PUBLIC	??_C@_07HGKHBOGE@compact@			; `string'
PUBLIC	??_C@_07JDFLJJH@declare@			; `string'
PUBLIC	??_C@_05MBNCFBEN@defer@				; `string'
PUBLIC	??_C@_08BEHKFNNO@disabled@			; `string'
PUBLIC	??_C@_05HANCGNOO@ismap@				; `string'
PUBLIC	??_C@_08CKJFGDBG@multiple@			; `string'
PUBLIC	??_C@_06FFHHDLMH@nohref@			; `string'
PUBLIC	??_C@_08BOOCAMGJ@noresize@			; `string'
PUBLIC	??_C@_07NCHIIBII@noshade@			; `string'
PUBLIC	??_C@_06KMFGCGJP@nowrap@			; `string'
PUBLIC	??_C@_08JOKHDEJH@readonly@			; `string'
PUBLIC	??_C@_08CJLOJPNI@selected@			; `string'
_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__7B7A869E_ctype@h DB 01H
__E0C87F61_htmltree@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_08CJLOJPNI@selected@
CONST	SEGMENT
??_C@_08CJLOJPNI@selected@ DB 'selected', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JOKHDEJH@readonly@
CONST	SEGMENT
??_C@_08JOKHDEJH@readonly@ DB 'readonly', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KMFGCGJP@nowrap@
CONST	SEGMENT
??_C@_06KMFGCGJP@nowrap@ DB 'nowrap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NCHIIBII@noshade@
CONST	SEGMENT
??_C@_07NCHIIBII@noshade@ DB 'noshade', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BOOCAMGJ@noresize@
CONST	SEGMENT
??_C@_08BOOCAMGJ@noresize@ DB 'noresize', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFHHDLMH@nohref@
CONST	SEGMENT
??_C@_06FFHHDLMH@nohref@ DB 'nohref', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CKJFGDBG@multiple@
CONST	SEGMENT
??_C@_08CKJFGDBG@multiple@ DB 'multiple', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HANCGNOO@ismap@
CONST	SEGMENT
??_C@_05HANCGNOO@ismap@ DB 'ismap', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08BEHKFNNO@disabled@
CONST	SEGMENT
??_C@_08BEHKFNNO@disabled@ DB 'disabled', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MBNCFBEN@defer@
CONST	SEGMENT
??_C@_05MBNCFBEN@defer@ DB 'defer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07JDFLJJH@declare@
CONST	SEGMENT
??_C@_07JDFLJJH@declare@ DB 'declare', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HGKHBOGE@compact@
CONST	SEGMENT
??_C@_07HGKHBOGE@compact@ DB 'compact', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FJOBMBFC@checked@
CONST	SEGMENT
??_C@_07FJOBMBFC@checked@ DB 'checked', 00H		; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_snprintf
PUBLIC	_htmlGetMetaEncoding
PUBLIC	_htmlSetMetaEncoding
PUBLIC	_htmlDocDumpMemory
PUBLIC	_htmlDocDumpMemoryFormat
PUBLIC	_htmlDocDump
PUBLIC	_htmlSaveFile
PUBLIC	_htmlNodeDump
PUBLIC	_htmlNodeDumpFile
PUBLIC	_htmlNodeDumpFileFormat
PUBLIC	_htmlSaveFileEnc
PUBLIC	_htmlSaveFileFormat
PUBLIC	_htmlNodeDumpFormatOutput
PUBLIC	_htmlDocContentDumpOutput
PUBLIC	_htmlDocContentDumpFormatOutput
PUBLIC	_htmlNodeDumpOutput
PUBLIC	_htmlIsBooleanAttr
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_04PNIFHPHN@html@				; `string'
PUBLIC	??_C@_04NEODDMOL@head@				; `string'
PUBLIC	??_C@_04HLJJCGEF@meta@				; `string'
PUBLIC	??_C@_0L@NALBGOHO@http?9equiv@			; `string'
PUBLIC	??_C@_0N@LAFFMKKA@Content?9Type@		; `string'
PUBLIC	??_C@_07ICAJMOAO@content@			; `string'
PUBLIC	??_C@_08JPKHBDLJ@charset?$DN@			; `string'
PUBLIC	??_C@_08BNFGJBBK@Charset?$DN@			; `string'
PUBLIC	??_C@_08HFIPAJDM@CHARSET?$DN@			; `string'
PUBLIC	??_C@_09MMDENEKG@charset?5?$DN@			; `string'
PUBLIC	??_C@_09IDGJNHHG@Charset?5?$DN@			; `string'
PUBLIC	??_C@_09FBAMILBD@CHARSET?5?$DN@			; `string'
PUBLIC	??_C@_0BG@HLDJIGE@text?1html?$DL?5charset?$DN?$CFs@ ; `string'
PUBLIC	??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@ ; `string'
PUBLIC	??_C@_0BJ@HMEJBBPL@invalid?5character?5value?6@	; `string'
PUBLIC	??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BF@DMLFPEHI@HTML?5has?5no?5DOCTYPE?6@	; `string'
PUBLIC	??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@	; `string'
PUBLIC	??_C@_0BO@IIMAGFKO@allocating?5HTML?5output?5buffer@ ; `string'
PUBLIC	??_C@_04DBLPJNAF@HTML@				; `string'
PUBLIC	??_C@_05OJENGABA@ascii@				; `string'
PUBLIC	??_C@_0L@JKHDJBPI@?$DM?$CBDOCTYPE?5@		; `string'
PUBLIC	??_C@_08GBBLECIH@?5PUBLIC?5@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_0BE@LDMALNEE@about?3legacy?9compat@	; `string'
PUBLIC	??_C@_08PAGGLANP@?5SYSTEM?5@			; `string'
PUBLIC	??_C@_02NEKEAGPN@?$DO?6@			; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_01NEMOKFLO@?$DN@				; `string'
PUBLIC	??_C@_04CMBCJJJD@href@				; `string'
PUBLIC	??_C@_06DDLLCOJG@action@			; `string'
PUBLIC	??_C@_03LOJEKLML@src@				; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_01MCMALHOG@a@				; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC@				; `string'
PUBLIC	??_C@_04FFDNBKGC@?$DM?$CB?9?9@			; `string'
PUBLIC	??_C@_03PNLDJJMO@?9?9?$DO@			; `string'
PUBLIC	??_C@_0M@LNGMBFJP@?$EA?1?3?$DN?$DP?$DL?$CD?$CF?$CG?0?$CL@ ; `string'
PUBLIC	??_C@_03EAIBNEDB@?$DN?$CC?$CC@			; `string'
PUBLIC	??_C@_06OLONEIEH@script@			; `string'
PUBLIC	??_C@_05IAKJCFIM@style@				; `string'
PUBLIC	??_C@_02HFBBBACF@?$DM?$DP@			; `string'
PUBLIC	??_C@_01PPODPGHN@?$DO@				; `string'
PUBLIC	??_C@_01HNPIGOCE@?$CG@				; `string'
PUBLIC	??_C@_01ICJEACDI@?$DL@				; `string'
PUBLIC	??_C@_01MNNFJEPP@?$DM@				; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_04IEJGKNJ@body@				; `string'
PUBLIC	??_C@_03PBCCILOI@?$DO?$DM?1@			; `string'
PUBLIC	??_C@_02DPNDACHE@?$DM?1@			; `string'
PUBLIC	??_C@_05EGJIMALK@UTF?98@			; `string'
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrstr:PROC
EXTRN	_xmlStrcasestr:PROC
EXTRN	_xmlStrcmp:PROC
EXTRN	_xmlStrcasecmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_xmlBufContent:PROC
EXTRN	_xmlBufUse:PROC
EXTRN	_xmlNewProp:PROC
EXTRN	_xmlNewDocNode:PROC
EXTRN	_xmlAddChild:PROC
EXTRN	_xmlAddPrevSibling:PROC
EXTRN	_xmlUnlinkNode:PROC
EXTRN	_xmlFreeNode:PROC
EXTRN	_xmlSetProp:PROC
EXTRN	_xmlNodeListGetString:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	_xmlEncodeEntitiesReentrant:PROC
EXTRN	_xmlFindCharEncodingHandler:PROC
EXTRN	_xmlParseCharEncoding:PROC
EXTRN	_xmlOutputBufferCreateFilename:PROC
EXTRN	_xmlOutputBufferCreateFile:PROC
EXTRN	_xmlOutputBufferWriteString:PROC
EXTRN	_xmlOutputBufferFlush:PROC
EXTRN	_xmlOutputBufferClose:PROC
EXTRN	_xmlInitParser:PROC
EXTRN	_htmlTagLookup:PROC
EXTRN	_xmlURIEscapeStr:PROC
EXTRN	_xmlBufCat:PROC
EXTRN	_xmlBufCCat:PROC
EXTRN	_xmlBufWriteQuotedString:PROC
EXTRN	_xmlBufFromBuffer:PROC
EXTRN	_xmlBufBackToBuffer:PROC
EXTRN	_xmlAllocOutputBufferInternal:PROC
EXTRN	_xmlNsListDumpOutput:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_xmlStringText:BYTE
EXTRN	_xmlStringTextNoenc:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_05EGJIMALK@UTF?98@
CONST	SEGMENT
??_C@_05EGJIMALK@UTF?98@ DB 'UTF-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPNDACHE@?$DM?1@
CONST	SEGMENT
??_C@_02DPNDACHE@?$DM?1@ DB '</', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PBCCILOI@?$DO?$DM?1@
CONST	SEGMENT
??_C@_03PBCCILOI@?$DO?$DM?1@ DB '></', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IEJGKNJ@body@
CONST	SEGMENT
??_C@_04IEJGKNJ@body@ DB 'body', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01MNNFJEPP@?$DM@
CONST	SEGMENT
??_C@_01MNNFJEPP@?$DM@ DB '<', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01ICJEACDI@?$DL@
CONST	SEGMENT
??_C@_01ICJEACDI@?$DL@ DB ';', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HNPIGOCE@?$CG@
CONST	SEGMENT
??_C@_01HNPIGOCE@?$CG@ DB '&', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01PPODPGHN@?$DO@
CONST	SEGMENT
??_C@_01PPODPGHN@?$DO@ DB '>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HFBBBACF@?$DM?$DP@
CONST	SEGMENT
??_C@_02HFBBBACF@?$DM?$DP@ DB '<?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IAKJCFIM@style@
CONST	SEGMENT
??_C@_05IAKJCFIM@style@ DB 'style', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06OLONEIEH@script@
CONST	SEGMENT
??_C@_06OLONEIEH@script@ DB 'script', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EAIBNEDB@?$DN?$CC?$CC@
CONST	SEGMENT
??_C@_03EAIBNEDB@?$DN?$CC?$CC@ DB '=""', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LNGMBFJP@?$EA?1?3?$DN?$DP?$DL?$CD?$CF?$CG?0?$CL@
CONST	SEGMENT
??_C@_0M@LNGMBFJP@?$EA?1?3?$DN?$DP?$DL?$CD?$CF?$CG?0?$CL@ DB '@/:=?;#%&,+'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03PNLDJJMO@?9?9?$DO@
CONST	SEGMENT
??_C@_03PNLDJJMO@?9?9?$DO@ DB '-->', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FFDNBKGC@?$DM?$CB?9?9@
CONST	SEGMENT
??_C@_04FFDNBKGC@?$DM?$CB?9?9@ DB '<!--', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a@
CONST	SEGMENT
??_C@_01MCMALHOG@a@ DB 'a', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LOJEKLML@src@
CONST	SEGMENT
??_C@_03LOJEKLML@src@ DB 'src', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DDLLCOJG@action@
CONST	SEGMENT
??_C@_06DDLLCOJG@action@ DB 'action', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CMBCJJJD@href@
CONST	SEGMENT
??_C@_04CMBCJJJD@href@ DB 'href', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01NEMOKFLO@?$DN@
CONST	SEGMENT
??_C@_01NEMOKFLO@?$DN@ DB '=', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NEKEAGPN@?$DO?6@
CONST	SEGMENT
??_C@_02NEKEAGPN@?$DO?6@ DB '>', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PAGGLANP@?5SYSTEM?5@
CONST	SEGMENT
??_C@_08PAGGLANP@?5SYSTEM?5@ DB ' SYSTEM ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LDMALNEE@about?3legacy?9compat@
CONST	SEGMENT
??_C@_0BE@LDMALNEE@about?3legacy?9compat@ DB 'about:legacy-compat', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08GBBLECIH@?5PUBLIC?5@
CONST	SEGMENT
??_C@_08GBBLECIH@?5PUBLIC?5@ DB ' PUBLIC ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JKHDJBPI@?$DM?$CBDOCTYPE?5@
CONST	SEGMENT
??_C@_0L@JKHDJBPI@?$DM?$CBDOCTYPE?5@ DB '<!DOCTYPE ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OJENGABA@ascii@
CONST	SEGMENT
??_C@_05OJENGABA@ascii@ DB 'ascii', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DBLPJNAF@HTML@
CONST	SEGMENT
??_C@_04DBLPJNAF@HTML@ DB 'HTML', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IIMAGFKO@allocating?5HTML?5output?5buffer@
CONST	SEGMENT
??_C@_0BO@IIMAGFKO@allocating?5HTML?5output?5buffer@ DB 'allocating HTML '
	DB	'output buffer', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@
CONST	SEGMENT
??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@ DB 'unexpected error numb'
	DB	'er', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DMLFPEHI@HTML?5has?5no?5DOCTYPE?6@
CONST	SEGMENT
??_C@_0BF@DMLFPEHI@HTML?5has?5no?5DOCTYPE?6@ DB 'HTML has no DOCTYPE', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@
CONST	SEGMENT
??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@ DB 'unknown encoding %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HMEJBBPL@invalid?5character?5value?6@
CONST	SEGMENT
??_C@_0BJ@HMEJBBPL@invalid?5character?5value?6@ DB 'invalid character val'
	DB	'ue', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@
CONST	SEGMENT
??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@ DB 'string is not in UT'
	DB	'F-8', 0aH, 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
_htmlBooleanAttrs DD FLAT:??_C@_07FJOBMBFC@checked@
	DD	FLAT:??_C@_07HGKHBOGE@compact@
	DD	FLAT:??_C@_07JDFLJJH@declare@
	DD	FLAT:??_C@_05MBNCFBEN@defer@
	DD	FLAT:??_C@_08BEHKFNNO@disabled@
	DD	FLAT:??_C@_05HANCGNOO@ismap@
	DD	FLAT:??_C@_08CKJFGDBG@multiple@
	DD	FLAT:??_C@_06FFHHDLMH@nohref@
	DD	FLAT:??_C@_08BOOCAMGJ@noresize@
	DD	FLAT:??_C@_07NCHIIBII@noshade@
	DD	FLAT:??_C@_06KMFGCGJP@nowrap@
	DD	FLAT:??_C@_08JOKHDEJH@readonly@
	DD	FLAT:??_C@_08CJLOJPNI@selected@
	DD	00H
_DATA	ENDS
;	COMDAT ??_C@_0BG@HLDJIGE@text?1html?$DL?5charset?$DN?$CFs@
CONST	SEGMENT
??_C@_0BG@HLDJIGE@text?1html?$DL?5charset?$DN?$CFs@ DB 'text/html; charse'
	DB	't=%s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09FBAMILBD@CHARSET?5?$DN@
CONST	SEGMENT
??_C@_09FBAMILBD@CHARSET?5?$DN@ DB 'CHARSET =', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IDGJNHHG@Charset?5?$DN@
CONST	SEGMENT
??_C@_09IDGJNHHG@Charset?5?$DN@ DB 'Charset =', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MMDENEKG@charset?5?$DN@
CONST	SEGMENT
??_C@_09MMDENEKG@charset?5?$DN@ DB 'charset =', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HFIPAJDM@CHARSET?$DN@
CONST	SEGMENT
??_C@_08HFIPAJDM@CHARSET?$DN@ DB 'CHARSET=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BNFGJBBK@Charset?$DN@
CONST	SEGMENT
??_C@_08BNFGJBBK@Charset?$DN@ DB 'Charset=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JPKHBDLJ@charset?$DN@
CONST	SEGMENT
??_C@_08JPKHBDLJ@charset?$DN@ DB 'charset=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07ICAJMOAO@content@
CONST	SEGMENT
??_C@_07ICAJMOAO@content@ DB 'content', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LAFFMKKA@Content?9Type@
CONST	SEGMENT
??_C@_0N@LAFFMKKA@Content?9Type@ DB 'Content-Type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NALBGOHO@http?9equiv@
CONST	SEGMENT
??_C@_0L@NALBGOHO@http?9equiv@ DB 'http-equiv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HLJJCGEF@meta@
CONST	SEGMENT
??_C@_04HLJJCGEF@meta@ DB 'meta', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NEODDMOL@head@
CONST	SEGMENT
??_C@_04NEODDMOL@head@ DB 'head', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNIFHPHN@html@
CONST	SEGMENT
??_C@_04PNIFHPHN@html@ DB 'html', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlNodeListDumpOutput
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_encoding$ = 20						; size = 4
_format$ = 24						; size = 4
_htmlNodeListDumpOutput PROC				; COMDAT

; 796  : 	               xmlNodePtr cur, const char *encoding, int format) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 797  :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@htmlNodeLi

; 798  : 	return;

	jmp	SHORT $LN1@htmlNodeLi
$LN2@htmlNodeLi:

; 799  :     }
; 800  :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@htmlNodeLi

; 801  :         htmlNodeDumpFormatOutput(buf, doc, cur, encoding, format);

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_htmlNodeDumpFormatOutput
	add	esp, 20					; 00000014H

; 802  : 	cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _cur$[ebp], eax

; 803  :     }

	jmp	SHORT $LN2@htmlNodeLi
$LN1@htmlNodeLi:

; 804  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_htmlNodeListDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlAttrListDumpOutput
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_encoding$ = 20						; size = 4
_htmlAttrListDumpOutput PROC				; COMDAT

; 772  : htmlAttrListDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlAttrPtr cur, const char *encoding) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 773  :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@htmlAttrLi

; 774  : 	return;

	jmp	SHORT $LN1@htmlAttrLi
$LN2@htmlAttrLi:

; 775  :     }
; 776  :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@htmlAttrLi

; 777  :         htmlAttrDumpOutput(buf, doc, cur, encoding);

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_htmlAttrDumpOutput
	add	esp, 16					; 00000010H

; 778  : 	cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$[ebp], edx

; 779  :     }

	jmp	SHORT $LN2@htmlAttrLi
$LN1@htmlAttrLi:

; 780  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_htmlAttrListDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlAttrDumpOutput
_TEXT	SEGMENT
_start$1 = -24						; size = 4
_end$2 = -20						; size = 4
_endChar$3 = -13					; size = 1
_escaped$4 = -12					; size = 4
_tmp$5 = -8						; size = 4
_value$ = -4						; size = 4
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_encoding$ = 20						; size = 4
_htmlAttrDumpOutput PROC				; COMDAT

; 679  : 	           const char *encoding ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 680  :     xmlChar *value;
; 681  : 
; 682  :     /*
; 683  :      * The html output method should not escape a & character
; 684  :      * occurring in an attribute value immediately followed by
; 685  :      * a { character (see Section B.7.1 of the HTML 4.0 Recommendation).
; 686  :      * This is implemented in xmlEncodeEntitiesReentrant
; 687  :      */
; 688  : 
; 689  :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN7@htmlAttrDu

; 690  : 	return;

	jmp	$LN1@htmlAttrDu
$LN7@htmlAttrDu:

; 691  :     }
; 692  :     xmlOutputBufferWriteString(buf, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 693  :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN8@htmlAttrDu
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN8@htmlAttrDu

; 694  :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 695  : 	xmlOutputBufferWriteString(buf, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN8@htmlAttrDu:

; 696  :     }
; 697  :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 698  :     if ((cur->children != NULL) && (!htmlIsBooleanAttr(cur->name))) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	$LN1@htmlAttrDu
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_htmlIsBooleanAttr
	add	esp, 4
	test	eax, eax
	jne	$LN1@htmlAttrDu

; 699  : 	value = xmlNodeListGetString(doc, cur->children, 0);

	push	0
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _value$[ebp], eax

; 700  : 	if (value) {

	cmp	DWORD PTR _value$[ebp], 0
	je	$LN10@htmlAttrDu

; 701  : 	    xmlOutputBufferWriteString(buf, "=");

	push	OFFSET ??_C@_01NEMOKFLO@?$DN@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 702  : 	    if ((cur->ns == NULL) && (cur->parent != NULL) &&
; 703  : 		(cur->parent->ns == NULL) &&

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	jne	$LN12@htmlAttrDu
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	$LN12@htmlAttrDu
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	DWORD PTR [ecx+36], 0
	jne	$LN12@htmlAttrDu
	push	OFFSET ??_C@_04CMBCJJJD@href@
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@htmlAttrDu
	push	OFFSET ??_C@_06DDLLCOJG@action@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@htmlAttrDu
	push	OFFSET ??_C@_03LOJEKLML@src@
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@htmlAttrDu
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	$LN12@htmlAttrDu
	push	OFFSET ??_C@_01MCMALHOG@a@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	$LN12@htmlAttrDu
$LN14@htmlAttrDu:

; 704  : 		((!xmlStrcasecmp(cur->name, BAD_CAST "href")) ||
; 705  : 	         (!xmlStrcasecmp(cur->name, BAD_CAST "action")) ||
; 706  : 		 (!xmlStrcasecmp(cur->name, BAD_CAST "src")) ||
; 707  : 		 ((!xmlStrcasecmp(cur->name, BAD_CAST "name")) &&
; 708  : 		  (!xmlStrcasecmp(cur->parent->name, BAD_CAST "a"))))) {
; 709  : 		xmlChar *tmp = value;

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _tmp$5[ebp], ecx

; 710  : 		/* xmlURIEscapeStr() escapes '"' so it can be safely used. */
; 711  : 		xmlBufCCat(buf->buffer, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufCCat
	add	esp, 8
$LN2@htmlAttrDu:

; 712  : 
; 713  : 		while (IS_BLANK_CH(*tmp)) tmp++;

	mov	ecx, DWORD PTR _tmp$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN15@htmlAttrDu
	mov	eax, DWORD PTR _tmp$5[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN16@htmlAttrDu
	mov	edx, DWORD PTR _tmp$5[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN15@htmlAttrDu
$LN16@htmlAttrDu:
	mov	ecx, DWORD PTR _tmp$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN6@htmlAttrDu
$LN15@htmlAttrDu:
	mov	eax, DWORD PTR _tmp$5[ebp]
	add	eax, 1
	mov	DWORD PTR _tmp$5[ebp], eax
	jmp	SHORT $LN2@htmlAttrDu
$LN6@htmlAttrDu:

; 714  : 
; 715  : 		/* URI Escape everything, except server side includes. */
; 716  : 		for ( ; ; ) {
; 717  : 		    xmlChar *escaped;
; 718  : 		    xmlChar endChar;
; 719  : 		    xmlChar *end = NULL;

	mov	DWORD PTR _end$2[ebp], 0

; 720  : 		    xmlChar *start = (xmlChar *)xmlStrstr(tmp, BAD_CAST "<!--");

	push	OFFSET ??_C@_04FFDNBKGC@?$DM?$CB?9?9@
	mov	ecx, DWORD PTR _tmp$5[ebp]
	push	ecx
	call	_xmlStrstr
	add	esp, 8
	mov	DWORD PTR _start$1[ebp], eax

; 721  : 		    if (start != NULL) {

	cmp	DWORD PTR _start$1[ebp], 0
	je	SHORT $LN17@htmlAttrDu

; 722  : 			end = (xmlChar *)xmlStrstr(tmp, BAD_CAST "-->");

	push	OFFSET ??_C@_03PNLDJJMO@?9?9?$DO@
	mov	edx, DWORD PTR _tmp$5[ebp]
	push	edx
	call	_xmlStrstr
	add	esp, 8
	mov	DWORD PTR _end$2[ebp], eax

; 723  : 			if (end != NULL) {

	cmp	DWORD PTR _end$2[ebp], 0
	je	SHORT $LN17@htmlAttrDu

; 724  : 			    *start = '\0';

	mov	eax, DWORD PTR _start$1[ebp]
	mov	BYTE PTR [eax], 0
$LN17@htmlAttrDu:

; 725  : 			}
; 726  : 		    }
; 727  : 
; 728  : 		    /* Escape the whole string, or until start (set to '\0'). */
; 729  : 		    escaped = xmlURIEscapeStr(tmp, BAD_CAST"@/:=?;#%&,+");

	push	OFFSET ??_C@_0M@LNGMBFJP@?$EA?1?3?$DN?$DP?$DL?$CD?$CF?$CG?0?$CL@
	mov	ecx, DWORD PTR _tmp$5[ebp]
	push	ecx
	call	_xmlURIEscapeStr
	add	esp, 8
	mov	DWORD PTR _escaped$4[ebp], eax

; 730  : 		    if (escaped != NULL) {

	cmp	DWORD PTR _escaped$4[ebp], 0
	je	SHORT $LN19@htmlAttrDu

; 731  : 		        xmlBufCat(buf->buffer, escaped);

	mov	edx, DWORD PTR _escaped$4[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufCat
	add	esp, 8

; 732  : 		        xmlFree(escaped);

	mov	esi, esp
	mov	edx, DWORD PTR _escaped$4[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 733  : 		    } else {

	jmp	SHORT $LN20@htmlAttrDu
$LN19@htmlAttrDu:

; 734  : 		        xmlBufCat(buf->buffer, tmp);

	mov	eax, DWORD PTR _tmp$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufCat
	add	esp, 8
$LN20@htmlAttrDu:

; 735  : 		    }
; 736  : 
; 737  : 		    if (end == NULL) { /* Everything has been written. */

	cmp	DWORD PTR _end$2[ebp], 0
	jne	SHORT $LN21@htmlAttrDu

; 738  : 			break;

	jmp	SHORT $LN5@htmlAttrDu
$LN21@htmlAttrDu:

; 739  : 		    }
; 740  : 
; 741  : 		    /* Do not escape anything within server side includes. */
; 742  : 		    *start = '<'; /* Restore the first character of "<!--". */

	mov	eax, DWORD PTR _start$1[ebp]
	mov	BYTE PTR [eax], 60			; 0000003cH

; 743  : 		    end += 3; /* strlen("-->") */

	mov	ecx, DWORD PTR _end$2[ebp]
	add	ecx, 3
	mov	DWORD PTR _end$2[ebp], ecx

; 744  : 		    endChar = *end;

	mov	edx, DWORD PTR _end$2[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _endChar$3[ebp], al

; 745  : 		    *end = '\0';

	mov	ecx, DWORD PTR _end$2[ebp]
	mov	BYTE PTR [ecx], 0

; 746  : 		    xmlBufCat(buf->buffer, start);

	mov	edx, DWORD PTR _start$1[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufCat
	add	esp, 8

; 747  : 		    *end = endChar;

	mov	edx, DWORD PTR _end$2[ebp]
	mov	al, BYTE PTR _endChar$3[ebp]
	mov	BYTE PTR [edx], al

; 748  : 		    tmp = end;

	mov	ecx, DWORD PTR _end$2[ebp]
	mov	DWORD PTR _tmp$5[ebp], ecx

; 749  : 		}

	jmp	$LN6@htmlAttrDu
$LN5@htmlAttrDu:

; 750  : 
; 751  : 		xmlBufCCat(buf->buffer, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufCCat
	add	esp, 8

; 752  : 	    } else {

	jmp	SHORT $LN13@htmlAttrDu
$LN12@htmlAttrDu:

; 753  : 		xmlBufWriteQuotedString(buf->buffer, value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufWriteQuotedString
	add	esp, 8
$LN13@htmlAttrDu:

; 754  : 	    }
; 755  : 	    xmlFree(value);

	mov	esi, esp
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 756  : 	} else  {

	jmp	SHORT $LN1@htmlAttrDu
$LN10@htmlAttrDu:

; 757  : 	    xmlOutputBufferWriteString(buf, "=\"\"");

	push	OFFSET ??_C@_03EAIBNEDB@?$DN?$CC?$CC@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN1@htmlAttrDu:

; 758  : 	}
; 759  :     }
; 760  : }

	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_htmlAttrDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlDtdDumpOutput
_TEXT	SEGMENT
_cur$ = -4						; size = 4
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_encoding$ = 16						; size = 4
_htmlDtdDumpOutput PROC					; COMDAT

; 644  : 	          const char *encoding ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 645  :     xmlDtdPtr cur = doc->intSubset;

	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _cur$[ebp], ecx

; 646  : 
; 647  :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@htmlDtdDum

; 648  : 	htmlSaveErr(XML_SAVE_NO_DOCTYPE, (xmlNodePtr) doc, NULL);

	push	0
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	push	1402					; 0000057aH
	call	_htmlSaveErr
	add	esp, 12					; 0000000cH

; 649  : 	return;

	jmp	$LN1@htmlDtdDum
$LN2@htmlDtdDum:

; 650  :     }
; 651  :     xmlOutputBufferWriteString(buf, "<!DOCTYPE ");

	push	OFFSET ??_C@_0L@JKHDJBPI@?$DM?$CBDOCTYPE?5@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 652  :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 653  :     if (cur->ExternalID != NULL) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	je	SHORT $LN3@htmlDtdDum

; 654  : 	xmlOutputBufferWriteString(buf, " PUBLIC ");

	push	OFFSET ??_C@_08GBBLECIH@?5PUBLIC?5@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 655  : 	xmlBufWriteQuotedString(buf->buffer, cur->ExternalID);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufWriteQuotedString
	add	esp, 8

; 656  : 	if (cur->SystemID != NULL) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+56], 0
	je	SHORT $LN5@htmlDtdDum

; 657  : 	    xmlOutputBufferWriteString(buf, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 658  : 	    xmlBufWriteQuotedString(buf->buffer, cur->SystemID);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufWriteQuotedString
	add	esp, 8
$LN5@htmlDtdDum:

; 659  : 	}

	jmp	SHORT $LN4@htmlDtdDum
$LN3@htmlDtdDum:

; 660  :     } else if (cur->SystemID != NULL &&

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+56], 0
	je	SHORT $LN4@htmlDtdDum
	push	OFFSET ??_C@_0BE@LDMALNEE@about?3legacy?9compat@
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@htmlDtdDum

; 661  : 	       xmlStrcmp(cur->SystemID, BAD_CAST "about:legacy-compat")) {
; 662  : 	xmlOutputBufferWriteString(buf, " SYSTEM ");

	push	OFFSET ??_C@_08PAGGLANP@?5SYSTEM?5@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 663  : 	xmlBufWriteQuotedString(buf->buffer, cur->SystemID);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufWriteQuotedString
	add	esp, 8
$LN4@htmlDtdDum:

; 664  :     }
; 665  :     xmlOutputBufferWriteString(buf, ">\n");

	push	OFFSET ??_C@_02NEKEAGPN@?$DO?6@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN1@htmlDtdDum:

; 666  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_htmlDtdDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlBufNodeDumpFormat
_TEXT	SEGMENT
_outbuf$ = -12						; size = 4
_ret$ = -8						; size = 4
_use$ = -4						; size = 4
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_format$ = 20						; size = 4
_htmlBufNodeDumpFormat PROC				; COMDAT

; 409  : 	           int format) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 410  :     size_t use;
; 411  :     int ret;
; 412  :     xmlOutputBufferPtr outbuf;
; 413  : 
; 414  :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@htmlBufNod

; 415  : 	return (-1);

	or	eax, -1
	jmp	$LN1@htmlBufNod
$LN2@htmlBufNod:

; 416  :     }
; 417  :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN3@htmlBufNod

; 418  : 	return (-1);

	or	eax, -1
	jmp	$LN1@htmlBufNod
$LN3@htmlBufNod:

; 419  :     }
; 420  :     outbuf = (xmlOutputBufferPtr) xmlMalloc(sizeof(xmlOutputBuffer));

	mov	esi, esp
	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _outbuf$[ebp], eax

; 421  :     if (outbuf == NULL) {

	cmp	DWORD PTR _outbuf$[ebp], 0
	jne	SHORT $LN4@htmlBufNod

; 422  :         htmlSaveErrMemory("allocating HTML output buffer");

	push	OFFSET ??_C@_0BO@IIMAGFKO@allocating?5HTML?5output?5buffer@
	call	_htmlSaveErrMemory
	add	esp, 4

; 423  : 	return (-1);

	or	eax, -1
	jmp	$LN1@htmlBufNod
$LN4@htmlBufNod:

; 424  :     }
; 425  :     memset(outbuf, 0, (size_t) sizeof(xmlOutputBuffer));

	xor	eax, eax
	mov	ecx, DWORD PTR _outbuf$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], eax

; 426  :     outbuf->buffer = buf;

	mov	edx, DWORD PTR _outbuf$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+16], eax

; 427  :     outbuf->encoder = NULL;

	mov	ecx, DWORD PTR _outbuf$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 428  :     outbuf->writecallback = NULL;

	mov	edx, DWORD PTR _outbuf$[ebp]
	mov	DWORD PTR [edx+4], 0

; 429  :     outbuf->closecallback = NULL;

	mov	eax, DWORD PTR _outbuf$[ebp]
	mov	DWORD PTR [eax+8], 0

; 430  :     outbuf->context = NULL;

	mov	ecx, DWORD PTR _outbuf$[ebp]
	mov	DWORD PTR [ecx], 0

; 431  :     outbuf->written = 0;

	mov	edx, DWORD PTR _outbuf$[ebp]
	mov	DWORD PTR [edx+24], 0

; 432  : 
; 433  :     use = xmlBufUse(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufUse
	add	esp, 4
	mov	DWORD PTR _use$[ebp], eax

; 434  :     htmlNodeDumpFormatOutput(outbuf, doc, cur, NULL, format);

	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outbuf$[ebp]
	push	ecx
	call	_htmlNodeDumpFormatOutput
	add	esp, 20					; 00000014H

; 435  :     xmlFree(outbuf);

	mov	esi, esp
	mov	edx, DWORD PTR _outbuf$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 436  :     ret = xmlBufUse(buf) - use;

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufUse
	add	esp, 4
	sub	eax, DWORD PTR _use$[ebp]
	mov	DWORD PTR _ret$[ebp], eax

; 437  :     return (ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@htmlBufNod:

; 438  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_htmlBufNodeDumpFormat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlSaveErr
_TEXT	SEGMENT
tv64 = -8						; size = 4
_msg$ = -4						; size = 4
_code$ = 8						; size = 4
_node$ = 12						; size = 4
_extra$ = 16						; size = 4
_htmlSaveErr PROC					; COMDAT

; 368  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 369  :     const char *msg = NULL;

	mov	DWORD PTR _msg$[ebp], 0

; 370  : 
; 371  :     switch(code) {

	mov	eax, DWORD PTR _code$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1400				; 00000578H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 3
	ja	SHORT $LN8@htmlSaveEr
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN10@htmlSaveEr[edx*4]
$LN4@htmlSaveEr:

; 372  :         case XML_SAVE_NOT_UTF8:
; 373  : 	    msg = "string is not in UTF-8\n";

	mov	DWORD PTR _msg$[ebp], OFFSET ??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@

; 374  : 	    break;

	jmp	SHORT $LN2@htmlSaveEr
$LN5@htmlSaveEr:

; 375  : 	case XML_SAVE_CHAR_INVALID:
; 376  : 	    msg = "invalid character value\n";

	mov	DWORD PTR _msg$[ebp], OFFSET ??_C@_0BJ@HMEJBBPL@invalid?5character?5value?6@

; 377  : 	    break;

	jmp	SHORT $LN2@htmlSaveEr
$LN6@htmlSaveEr:

; 378  : 	case XML_SAVE_UNKNOWN_ENCODING:
; 379  : 	    msg = "unknown encoding %s\n";

	mov	DWORD PTR _msg$[ebp], OFFSET ??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@

; 380  : 	    break;

	jmp	SHORT $LN2@htmlSaveEr
$LN7@htmlSaveEr:

; 381  : 	case XML_SAVE_NO_DOCTYPE:
; 382  : 	    msg = "HTML has no DOCTYPE\n";

	mov	DWORD PTR _msg$[ebp], OFFSET ??_C@_0BF@DMLFPEHI@HTML?5has?5no?5DOCTYPE?6@

; 383  : 	    break;

	jmp	SHORT $LN2@htmlSaveEr
$LN8@htmlSaveEr:

; 384  : 	default:
; 385  : 	    msg = "unexpected error number\n";

	mov	DWORD PTR _msg$[ebp], OFFSET ??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@
$LN2@htmlSaveEr:

; 386  :     }
; 387  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _code$[ebp]
	push	eax
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 388  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@htmlSaveEr:
	DD	$LN4@htmlSaveEr
	DD	$LN5@htmlSaveEr
	DD	$LN7@htmlSaveEr
	DD	$LN6@htmlSaveEr
_htmlSaveErr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlSaveErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_htmlSaveErrMemory PROC					; COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 355  :     __xmlSimpleError(XML_FROM_OUTPUT, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	0
	push	0
	push	2
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 356  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_htmlSaveErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlIsBooleanAttr
_TEXT	SEGMENT
_i$ = -4						; size = 4
_name$ = 8						; size = 4
_htmlIsBooleanAttr PROC					; COMDAT

; 324  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 325  :     int i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN2@htmlIsBool:

; 326  : 
; 327  :     while (htmlBooleanAttrs[i] != NULL) {

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _htmlBooleanAttrs[eax*4], 0
	je	SHORT $LN3@htmlIsBool

; 328  :         if (xmlStrcasecmp((const xmlChar *)htmlBooleanAttrs[i], name) == 0)

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _htmlBooleanAttrs[edx*4]
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@htmlIsBool

; 329  :             return 1;

	mov	eax, 1
	jmp	SHORT $LN1@htmlIsBool
$LN4@htmlIsBool:

; 330  :         i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 331  :     }

	jmp	SHORT $LN2@htmlIsBool
$LN3@htmlIsBool:

; 332  :     return 0;

	xor	eax, eax
$LN1@htmlIsBool:

; 333  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_htmlIsBooleanAttr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlNodeDumpOutput
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_encoding$ = 20						; size = 4
_htmlNodeDumpOutput PROC				; COMDAT

; 1007 : 	           xmlNodePtr cur, const char *encoding) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 1008 :     htmlNodeDumpFormatOutput(buf, doc, cur, encoding, 1);

	push	1
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_htmlNodeDumpFormatOutput
	add	esp, 20					; 00000014H

; 1009 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_htmlNodeDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlDocContentDumpFormatOutput
_TEXT	SEGMENT
_type$ = -4						; size = 4
_buf$ = 8						; size = 4
_cur$ = 12						; size = 4
_encoding$ = 16						; size = 4
_format$ = 20						; size = 4
_htmlDocContentDumpFormatOutput PROC			; COMDAT

; 1022 : 	                       const char *encoding, int format) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 1023 :     int type;
; 1024 : 
; 1025 :     xmlInitParser();

	call	_xmlInitParser

; 1026 : 
; 1027 :     if ((buf == NULL) || (cur == NULL))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@htmlDocCon
	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@htmlDocCon
$LN3@htmlDocCon:

; 1028 :         return;

	jmp	SHORT $LN1@htmlDocCon
$LN2@htmlDocCon:

; 1029 : 
; 1030 :     /*
; 1031 :      * force to output the stuff as HTML, especially for entities
; 1032 :      */
; 1033 :     type = cur->type;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _type$[ebp], ecx

; 1034 :     cur->type = XML_HTML_DOCUMENT_NODE;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+4], 13			; 0000000dH

; 1035 :     if (cur->intSubset != NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN4@htmlDocCon

; 1036 :         htmlDtdDumpOutput(buf, cur, NULL);

	push	0
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_htmlDtdDumpOutput
	add	esp, 12					; 0000000cH
$LN4@htmlDocCon:

; 1037 :     }
; 1038 :     if (cur->children != NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN5@htmlDocCon

; 1039 :         htmlNodeListDumpOutput(buf, cur, cur->children, encoding, format);

	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_htmlNodeListDumpOutput
	add	esp, 20					; 00000014H
$LN5@htmlDocCon:

; 1040 :     }
; 1041 :     xmlOutputBufferWriteString(buf, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1042 :     cur->type = (xmlElementType) type;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [edx+4], eax
$LN1@htmlDocCon:

; 1043 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_htmlDocContentDumpFormatOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlDocContentDumpOutput
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_cur$ = 12						; size = 4
_encoding$ = 16						; size = 4
_htmlDocContentDumpOutput PROC				; COMDAT

; 1055 : 	                 const char *encoding) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 1056 :     htmlDocContentDumpFormatOutput(buf, cur, encoding, 1);

	push	1
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_htmlDocContentDumpFormatOutput
	add	esp, 16					; 00000010H

; 1057 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_htmlDocContentDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlNodeDumpFormatOutput
_TEXT	SEGMENT
_buffer$1 = -8						; size = 4
_info$ = -4						; size = 4
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_encoding$ = 20						; size = 4
_format$ = 24						; size = 4
_htmlNodeDumpFormatOutput PROC				; COMDAT

; 818  : 	                 xmlNodePtr cur, const char *encoding, int format) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 819  :     const htmlElemDesc * info;
; 820  : 
; 821  :     xmlInitParser();

	call	_xmlInitParser

; 822  : 
; 823  :     if ((cur == NULL) || (buf == NULL)) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@htmlNodeDu
	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN2@htmlNodeDu
$LN3@htmlNodeDu:

; 824  : 	return;

	jmp	$LN1@htmlNodeDu
$LN2@htmlNodeDu:

; 825  :     }
; 826  :     /*
; 827  :      * Special cases.
; 828  :      */
; 829  :     if (cur->type == XML_DTD_NODE)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 14			; 0000000eH
	jne	SHORT $LN4@htmlNodeDu

; 830  : 	return;

	jmp	$LN1@htmlNodeDu
$LN4@htmlNodeDu:

; 831  :     if ((cur->type == XML_HTML_DOCUMENT_NODE) ||

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	je	SHORT $LN6@htmlNodeDu
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 9
	jne	SHORT $LN5@htmlNodeDu
$LN6@htmlNodeDu:

; 832  :         (cur->type == XML_DOCUMENT_NODE)){
; 833  : 	htmlDocContentDumpOutput(buf, (xmlDocPtr) cur, encoding);

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_htmlDocContentDumpOutput
	add	esp, 12					; 0000000cH

; 834  : 	return;

	jmp	$LN1@htmlNodeDu
$LN5@htmlNodeDu:

; 835  :     }
; 836  :     if (cur->type == XML_ATTRIBUTE_NODE) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 2
	jne	SHORT $LN7@htmlNodeDu

; 837  :         htmlAttrDumpOutput(buf, doc, (xmlAttrPtr) cur, encoding);

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_htmlAttrDumpOutput
	add	esp, 16					; 00000010H

; 838  : 	return;

	jmp	$LN1@htmlNodeDu
$LN7@htmlNodeDu:

; 839  :     }
; 840  :     if (cur->type == HTML_TEXT_NODE) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 3
	jne	$LN8@htmlNodeDu

; 841  : 	if (cur->content != NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	$LN9@htmlNodeDu

; 842  : 	    if (((cur->name == (const xmlChar *)xmlStringText) ||
; 843  : 		 (cur->name != (const xmlChar *)xmlStringTextNoenc)) &&

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+8], OFFSET _xmlStringText
	je	SHORT $LN12@htmlNodeDu
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+8], OFFSET _xmlStringTextNoenc
	je	$LN10@htmlNodeDu
$LN12@htmlNodeDu:
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN13@htmlNodeDu
	push	OFFSET ??_C@_06OLONEIEH@script@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@htmlNodeDu
	push	OFFSET ??_C@_05IAKJCFIM@style@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@htmlNodeDu
$LN13@htmlNodeDu:

; 844  : 		((cur->parent == NULL) ||
; 845  : 		 ((xmlStrcasecmp(cur->parent->name, BAD_CAST "script")) &&
; 846  : 		  (xmlStrcasecmp(cur->parent->name, BAD_CAST "style"))))) {
; 847  : 		xmlChar *buffer;
; 848  : 
; 849  : 		buffer = xmlEncodeEntitiesReentrant(doc, cur->content);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlEncodeEntitiesReentrant
	add	esp, 8
	mov	DWORD PTR _buffer$1[ebp], eax

; 850  : 		if (buffer != NULL) {

	cmp	DWORD PTR _buffer$1[ebp], 0
	je	SHORT $LN14@htmlNodeDu

; 851  : 		    xmlOutputBufferWriteString(buf, (const char *)buffer);

	mov	ecx, DWORD PTR _buffer$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 852  : 		    xmlFree(buffer);

	mov	esi, esp
	mov	eax, DWORD PTR _buffer$1[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@htmlNodeDu:

; 853  : 		}
; 854  : 	    } else {

	jmp	SHORT $LN9@htmlNodeDu
$LN10@htmlNodeDu:

; 855  : 		xmlOutputBufferWriteString(buf, (const char *)cur->content);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN9@htmlNodeDu:

; 856  : 	    }
; 857  : 	}
; 858  : 	return;

	jmp	$LN1@htmlNodeDu
$LN8@htmlNodeDu:

; 859  :     }
; 860  :     if (cur->type == HTML_COMMENT_NODE) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 8
	jne	SHORT $LN15@htmlNodeDu

; 861  : 	if (cur->content != NULL) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN16@htmlNodeDu

; 862  : 	    xmlOutputBufferWriteString(buf, "<!--");

	push	OFFSET ??_C@_04FFDNBKGC@?$DM?$CB?9?9@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 863  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->content);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 864  : 	    xmlOutputBufferWriteString(buf, "-->");

	push	OFFSET ??_C@_03PNLDJJMO@?9?9?$DO@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN16@htmlNodeDu:

; 865  : 	}
; 866  : 	return;

	jmp	$LN1@htmlNodeDu
$LN15@htmlNodeDu:

; 867  :     }
; 868  :     if (cur->type == HTML_PI_NODE) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 7
	jne	SHORT $LN17@htmlNodeDu

; 869  : 	if (cur->name == NULL)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN18@htmlNodeDu

; 870  : 	    return;

	jmp	$LN1@htmlNodeDu
$LN18@htmlNodeDu:

; 871  : 	xmlOutputBufferWriteString(buf, "<?");

	push	OFFSET ??_C@_02HFBBBACF@?$DM?$DP@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 872  : 	xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 873  : 	if (cur->content != NULL) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN19@htmlNodeDu

; 874  : 	    xmlOutputBufferWriteString(buf, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 875  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->content);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN19@htmlNodeDu:

; 876  : 	}
; 877  : 	xmlOutputBufferWriteString(buf, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 878  : 	return;

	jmp	$LN1@htmlNodeDu
$LN17@htmlNodeDu:

; 879  :     }
; 880  :     if (cur->type == HTML_ENTITY_REF_NODE) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 5
	jne	SHORT $LN20@htmlNodeDu

; 881  :         xmlOutputBufferWriteString(buf, "&");

	push	OFFSET ??_C@_01HNPIGOCE@?$CG@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 882  : 	xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 883  :         xmlOutputBufferWriteString(buf, ";");

	push	OFFSET ??_C@_01ICJEACDI@?$DL@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 884  : 	return;

	jmp	$LN1@htmlNodeDu
$LN20@htmlNodeDu:

; 885  :     }
; 886  :     if (cur->type == HTML_PRESERVE_NODE) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 4
	jne	SHORT $LN21@htmlNodeDu

; 887  : 	if (cur->content != NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN22@htmlNodeDu

; 888  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->content);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN22@htmlNodeDu:

; 889  : 	}
; 890  : 	return;

	jmp	$LN1@htmlNodeDu
$LN21@htmlNodeDu:

; 891  :     }
; 892  : 
; 893  :     /*
; 894  :      * Get specific HTML info for that node.
; 895  :      */
; 896  :     if (cur->ns == NULL)

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	jne	SHORT $LN23@htmlNodeDu

; 897  : 	info = htmlTagLookup(cur->name);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_htmlTagLookup
	add	esp, 4
	mov	DWORD PTR _info$[ebp], eax
	jmp	SHORT $LN24@htmlNodeDu
$LN23@htmlNodeDu:

; 898  :     else
; 899  : 	info = NULL;

	mov	DWORD PTR _info$[ebp], 0
$LN24@htmlNodeDu:

; 900  : 
; 901  :     xmlOutputBufferWriteString(buf, "<");

	push	OFFSET ??_C@_01MNNFJEPP@?$DM@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 902  :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN25@htmlNodeDu
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN25@htmlNodeDu

; 903  :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 904  : 	xmlOutputBufferWriteString(buf, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN25@htmlNodeDu:

; 905  :     }
; 906  :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 907  :     if (cur->nsDef)

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN26@htmlNodeDu

; 908  : 	xmlNsListDumpOutput(buf, cur->nsDef);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlNsListDumpOutput
	add	esp, 8
$LN26@htmlNodeDu:

; 909  :     if (cur->properties != NULL)

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN27@htmlNodeDu

; 910  :         htmlAttrListDumpOutput(buf, doc, cur->properties, encoding);

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_htmlAttrListDumpOutput
	add	esp, 16					; 00000010H
$LN27@htmlNodeDu:

; 911  : 
; 912  :     if ((info != NULL) && (info->empty)) {

	cmp	DWORD PTR _info$[ebp], 0
	je	$LN28@htmlNodeDu
	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, BYTE PTR [edx+7]
	test	eax, eax
	je	$LN28@htmlNodeDu

; 913  :         xmlOutputBufferWriteString(buf, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 914  : 	if ((format) && (!info->isinline) && (cur->next != NULL)) {

	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN29@htmlNodeDu
	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	test	eax, eax
	jne	SHORT $LN29@htmlNodeDu
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN29@htmlNodeDu

; 915  : 	    if ((cur->next->type != HTML_TEXT_NODE) &&
; 916  : 		(cur->next->type != HTML_ENTITY_REF_NODE) &&
; 917  : 		(cur->parent != NULL) &&
; 918  : 		(cur->parent->name != NULL) &&

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	DWORD PTR [eax+4], 3
	je	SHORT $LN29@htmlNodeDu
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	DWORD PTR [edx+4], 5
	je	SHORT $LN29@htmlNodeDu
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN29@htmlNodeDu
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN29@htmlNodeDu
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+8]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 112				; 00000070H
	je	SHORT $LN29@htmlNodeDu

; 919  : 		(cur->parent->name[0] != 'p')) /* p, pre, param */
; 920  : 		xmlOutputBufferWriteString(buf, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN29@htmlNodeDu:

; 921  : 	}
; 922  : 	return;

	jmp	$LN1@htmlNodeDu
$LN28@htmlNodeDu:

; 923  :     }
; 924  :     if (((cur->type == XML_ELEMENT_NODE) || (cur->content == NULL)) &&

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 1
	je	SHORT $LN32@htmlNodeDu
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+40], 0
	jne	$LN31@htmlNodeDu
$LN32@htmlNodeDu:
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	$LN31@htmlNodeDu

; 925  : 	(cur->children == NULL)) {
; 926  :         if ((info != NULL) && (info->saveEndTag != 0) &&
; 927  : 	    (xmlStrcmp(BAD_CAST info->name, BAD_CAST "html")) &&

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN33@htmlNodeDu
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	test	edx, edx
	je	SHORT $LN33@htmlNodeDu
	push	OFFSET ??_C@_04PNIFHPHN@html@
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@htmlNodeDu
	push	OFFSET ??_C@_04IEJGKNJ@body@
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@htmlNodeDu

; 928  : 	    (xmlStrcmp(BAD_CAST info->name, BAD_CAST "body"))) {
; 929  : 	    xmlOutputBufferWriteString(buf, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 930  : 	} else {

	jmp	SHORT $LN34@htmlNodeDu
$LN33@htmlNodeDu:

; 931  : 	    xmlOutputBufferWriteString(buf, "></");

	push	OFFSET ??_C@_03PBCCILOI@?$DO?$DM?1@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 932  :             if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN35@htmlNodeDu
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN35@htmlNodeDu

; 933  :                 xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 934  :                 xmlOutputBufferWriteString(buf, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN35@htmlNodeDu:

; 935  :             }
; 936  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 937  : 	    xmlOutputBufferWriteString(buf, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN34@htmlNodeDu:

; 938  : 	}
; 939  : 	if ((format) && (cur->next != NULL) &&
; 940  :             (info != NULL) && (!info->isinline)) {

	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN36@htmlNodeDu
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN36@htmlNodeDu
	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN36@htmlNodeDu
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	test	edx, edx
	jne	SHORT $LN36@htmlNodeDu

; 941  : 	    if ((cur->next->type != HTML_TEXT_NODE) &&
; 942  : 		(cur->next->type != HTML_ENTITY_REF_NODE) &&
; 943  : 		(cur->parent != NULL) &&
; 944  : 		(cur->parent->name != NULL) &&

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	DWORD PTR [ecx+4], 3
	je	SHORT $LN36@htmlNodeDu
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	DWORD PTR [eax+4], 5
	je	SHORT $LN36@htmlNodeDu
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN36@htmlNodeDu
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN36@htmlNodeDu
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+8]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 112				; 00000070H
	je	SHORT $LN36@htmlNodeDu

; 945  : 		(cur->parent->name[0] != 'p')) /* p, pre, param */
; 946  : 		xmlOutputBufferWriteString(buf, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN36@htmlNodeDu:

; 947  : 	}
; 948  : 	return;

	jmp	$LN1@htmlNodeDu
$LN31@htmlNodeDu:

; 949  :     }
; 950  :     xmlOutputBufferWriteString(buf, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 951  :     if ((cur->type != XML_ELEMENT_NODE) &&

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN38@htmlNodeDu
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN38@htmlNodeDu

; 952  : 	(cur->content != NULL)) {
; 953  : 	    /*
; 954  : 	     * Uses the OutputBuffer property to automatically convert
; 955  : 	     * invalids to charrefs
; 956  : 	     */
; 957  : 
; 958  :             xmlOutputBufferWriteString(buf, (const char *) cur->content);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN38@htmlNodeDu:

; 959  :     }
; 960  :     if (cur->children != NULL) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	$LN39@htmlNodeDu

; 961  :         if ((format) && (info != NULL) && (!info->isinline) &&
; 962  : 	    (cur->children->type != HTML_TEXT_NODE) &&
; 963  : 	    (cur->children->type != HTML_ENTITY_REF_NODE) &&
; 964  : 	    (cur->children != cur->last) &&
; 965  : 	    (cur->name != NULL) &&

	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN40@htmlNodeDu
	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN40@htmlNodeDu
	mov	eax, DWORD PTR _info$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	test	ecx, ecx
	jne	SHORT $LN40@htmlNodeDu
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	DWORD PTR [eax+4], 3
	je	SHORT $LN40@htmlNodeDu
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	DWORD PTR [edx+4], 5
	je	SHORT $LN40@htmlNodeDu
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+16]
	je	SHORT $LN40@htmlNodeDu
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN40@htmlNodeDu
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movzx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 112				; 00000070H
	je	SHORT $LN40@htmlNodeDu

; 966  : 	    (cur->name[0] != 'p')) /* p, pre, param */
; 967  : 	    xmlOutputBufferWriteString(buf, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN40@htmlNodeDu:

; 968  : 	htmlNodeListDumpOutput(buf, doc, cur->children, encoding, format);

	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_htmlNodeListDumpOutput
	add	esp, 20					; 00000014H

; 969  :         if ((format) && (info != NULL) && (!info->isinline) &&
; 970  : 	    (cur->last->type != HTML_TEXT_NODE) &&
; 971  : 	    (cur->last->type != HTML_ENTITY_REF_NODE) &&
; 972  : 	    (cur->children != cur->last) &&
; 973  : 	    (cur->name != NULL) &&

	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN39@htmlNodeDu
	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN39@htmlNodeDu
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	test	edx, edx
	jne	SHORT $LN39@htmlNodeDu
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+4], 3
	je	SHORT $LN39@htmlNodeDu
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+4], 5
	je	SHORT $LN39@htmlNodeDu
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx+16]
	je	SHORT $LN39@htmlNodeDu
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN39@htmlNodeDu
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movzx	eax, BYTE PTR [edx+eax]
	cmp	eax, 112				; 00000070H
	je	SHORT $LN39@htmlNodeDu

; 974  : 	    (cur->name[0] != 'p')) /* p, pre, param */
; 975  : 	    xmlOutputBufferWriteString(buf, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN39@htmlNodeDu:

; 976  :     }
; 977  :     xmlOutputBufferWriteString(buf, "</");

	push	OFFSET ??_C@_02DPNDACHE@?$DM?1@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 978  :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN42@htmlNodeDu
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN42@htmlNodeDu

; 979  :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 980  : 	xmlOutputBufferWriteString(buf, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN42@htmlNodeDu:

; 981  :     }
; 982  :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 983  :     xmlOutputBufferWriteString(buf, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 984  :     if ((format) && (info != NULL) && (!info->isinline) &&

	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN1@htmlNodeDu
	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN1@htmlNodeDu
	mov	eax, DWORD PTR _info$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	test	ecx, ecx
	jne	SHORT $LN1@htmlNodeDu
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN1@htmlNodeDu

; 985  : 	(cur->next != NULL)) {
; 986  :         if ((cur->next->type != HTML_TEXT_NODE) &&
; 987  : 	    (cur->next->type != HTML_ENTITY_REF_NODE) &&
; 988  : 	    (cur->parent != NULL) &&
; 989  : 	    (cur->parent->name != NULL) &&

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	DWORD PTR [ecx+4], 3
	je	SHORT $LN1@htmlNodeDu
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	DWORD PTR [eax+4], 5
	je	SHORT $LN1@htmlNodeDu
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN1@htmlNodeDu
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@htmlNodeDu
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+8]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 112				; 00000070H
	je	SHORT $LN1@htmlNodeDu

; 990  : 	    (cur->parent->name[0] != 'p')) /* p, pre, param */
; 991  : 	    xmlOutputBufferWriteString(buf, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN1@htmlNodeDu:

; 992  :     }
; 993  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_htmlNodeDumpFormatOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlSaveFileFormat
_TEXT	SEGMENT
_enc$1 = -16						; size = 4
_ret$ = -12						; size = 4
_handler$ = -8						; size = 4
_buf$ = -4						; size = 4
_filename$ = 8						; size = 4
_cur$ = 12						; size = 4
_encoding$ = 16						; size = 4
_format$ = 20						; size = 4
_htmlSaveFileFormat PROC				; COMDAT

; 1183 : 	           const char *encoding, int format) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 1184 :     xmlOutputBufferPtr buf;
; 1185 :     xmlCharEncodingHandlerPtr handler = NULL;

	mov	DWORD PTR _handler$[ebp], 0

; 1186 :     int ret;
; 1187 : 
; 1188 :     if ((cur == NULL) || (filename == NULL))

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@htmlSaveFi
	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN2@htmlSaveFi
$LN3@htmlSaveFi:

; 1189 :         return(-1);

	or	eax, -1
	jmp	$LN1@htmlSaveFi
$LN2@htmlSaveFi:

; 1190 : 
; 1191 :     xmlInitParser();

	call	_xmlInitParser

; 1192 : 
; 1193 :     if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN4@htmlSaveFi

; 1194 : 	xmlCharEncoding enc;
; 1195 : 
; 1196 : 	enc = xmlParseCharEncoding(encoding);

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	call	_xmlParseCharEncoding
	add	esp, 4
	mov	DWORD PTR _enc$1[ebp], eax

; 1197 : 	if (enc != XML_CHAR_ENCODING_UTF8) {

	cmp	DWORD PTR _enc$1[ebp], 1
	je	SHORT $LN6@htmlSaveFi

; 1198 : 	    handler = xmlFindCharEncodingHandler(encoding);

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1199 : 	    if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN6@htmlSaveFi

; 1200 : 		htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	push	0
	push	1403					; 0000057bH
	call	_htmlSaveErr
	add	esp, 12					; 0000000cH
$LN6@htmlSaveFi:

; 1201 : 	}
; 1202 :         htmlSetMetaEncoding(cur, (const xmlChar *) encoding);

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_htmlSetMetaEncoding
	add	esp, 8

; 1203 :     } else {

	jmp	SHORT $LN5@htmlSaveFi
$LN4@htmlSaveFi:

; 1204 : 	htmlSetMetaEncoding(cur, (const xmlChar *) "UTF-8");

	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_htmlSetMetaEncoding
	add	esp, 8

; 1205 : 
; 1206 :         /*
; 1207 :          * Fallback to HTML or ASCII when the encoding is unspecified
; 1208 :          */
; 1209 :         if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN8@htmlSaveFi

; 1210 :             handler = xmlFindCharEncodingHandler("HTML");

	push	OFFSET ??_C@_04DBLPJNAF@HTML@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax
$LN8@htmlSaveFi:

; 1211 :         if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN5@htmlSaveFi

; 1212 :             handler = xmlFindCharEncodingHandler("ascii");

	push	OFFSET ??_C@_05OJENGABA@ascii@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax
$LN5@htmlSaveFi:

; 1213 :     }
; 1214 : 
; 1215 :     /*
; 1216 :      * save the content to a temp buffer.
; 1217 :      */
; 1218 :     buf = xmlOutputBufferCreateFilename(filename, handler, 0);

	push	0
	mov	eax, DWORD PTR _handler$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_xmlOutputBufferCreateFilename
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buf$[ebp], eax

; 1219 :     if (buf == NULL) return(0);

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN10@htmlSaveFi
	xor	eax, eax
	jmp	SHORT $LN1@htmlSaveFi
$LN10@htmlSaveFi:

; 1220 : 
; 1221 :     htmlDocContentDumpFormatOutput(buf, cur, encoding, format);

	mov	edx, DWORD PTR _format$[ebp]
	push	edx
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_htmlDocContentDumpFormatOutput
	add	esp, 16					; 00000010H

; 1222 : 
; 1223 :     ret = xmlOutputBufferClose(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferClose
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 1224 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@htmlSaveFi:

; 1225 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_htmlSaveFileFormat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlSaveFileEnc
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_cur$ = 12						; size = 4
_encoding$ = 16						; size = 4
_htmlSaveFileEnc PROC					; COMDAT

; 1239 : htmlSaveFileEnc(const char *filename, xmlDocPtr cur, const char *encoding) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 1240 :     return(htmlSaveFileFormat(filename, cur, encoding, 1));

	push	1
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_htmlSaveFileFormat
	add	esp, 16					; 00000010H

; 1241 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_htmlSaveFileEnc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlNodeDumpFileFormat
_TEXT	SEGMENT
_enc$1 = -16						; size = 4
_ret$ = -12						; size = 4
_handler$ = -8						; size = 4
_buf$ = -4						; size = 4
_out$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_encoding$ = 20						; size = 4
_format$ = 24						; size = 4
_htmlNodeDumpFileFormat PROC				; COMDAT

; 489  : 	               xmlNodePtr cur, const char *encoding, int format) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 490  :     xmlOutputBufferPtr buf;
; 491  :     xmlCharEncodingHandlerPtr handler = NULL;

	mov	DWORD PTR _handler$[ebp], 0

; 492  :     int ret;
; 493  : 
; 494  :     xmlInitParser();

	call	_xmlInitParser

; 495  : 
; 496  :     if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN2@htmlNodeDu

; 497  : 	xmlCharEncoding enc;
; 498  : 
; 499  : 	enc = xmlParseCharEncoding(encoding);

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	call	_xmlParseCharEncoding
	add	esp, 4
	mov	DWORD PTR _enc$1[ebp], eax

; 500  : 	if (enc != XML_CHAR_ENCODING_UTF8) {

	cmp	DWORD PTR _enc$1[ebp], 1
	je	SHORT $LN4@htmlNodeDu

; 501  : 	    handler = xmlFindCharEncodingHandler(encoding);

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 502  : 	    if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN4@htmlNodeDu

; 503  : 		htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	push	0
	push	1403					; 0000057bH
	call	_htmlSaveErr
	add	esp, 12					; 0000000cH
$LN4@htmlNodeDu:

; 504  : 	}
; 505  :     } else {

	jmp	SHORT $LN3@htmlNodeDu
$LN2@htmlNodeDu:

; 506  :         /*
; 507  :          * Fallback to HTML or ASCII when the encoding is unspecified
; 508  :          */
; 509  :         if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN6@htmlNodeDu

; 510  :             handler = xmlFindCharEncodingHandler("HTML");

	push	OFFSET ??_C@_04DBLPJNAF@HTML@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax
$LN6@htmlNodeDu:

; 511  :         if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN3@htmlNodeDu

; 512  :             handler = xmlFindCharEncodingHandler("ascii");

	push	OFFSET ??_C@_05OJENGABA@ascii@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax
$LN3@htmlNodeDu:

; 513  :     }
; 514  : 
; 515  :     /*
; 516  :      * save the content to a temp buffer.
; 517  :      */
; 518  :     buf = xmlOutputBufferCreateFile(out, handler);

	mov	eax, DWORD PTR _handler$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_xmlOutputBufferCreateFile
	add	esp, 8
	mov	DWORD PTR _buf$[ebp], eax

; 519  :     if (buf == NULL) return(0);

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN8@htmlNodeDu
	xor	eax, eax
	jmp	SHORT $LN1@htmlNodeDu
$LN8@htmlNodeDu:

; 520  : 
; 521  :     htmlNodeDumpFormatOutput(buf, doc, cur, encoding, format);

	mov	edx, DWORD PTR _format$[ebp]
	push	edx
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_htmlNodeDumpFormatOutput
	add	esp, 20					; 00000014H

; 522  : 
; 523  :     ret = xmlOutputBufferClose(buf);

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferClose
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 524  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@htmlNodeDu:

; 525  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_htmlNodeDumpFileFormat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlNodeDumpFile
_TEXT	SEGMENT
_out$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_htmlNodeDumpFile PROC					; COMDAT

; 537  : htmlNodeDumpFile(FILE *out, xmlDocPtr doc, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 538  :     htmlNodeDumpFileFormat(out, doc, cur, NULL, 1);

	push	1
	push	0
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_htmlNodeDumpFileFormat
	add	esp, 20					; 00000014H

; 539  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_htmlNodeDumpFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlNodeDump
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_buffer$ = -4						; size = 4
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_htmlNodeDump PROC					; COMDAT

; 452  : htmlNodeDump(xmlBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 453  :     xmlBufPtr buffer;
; 454  :     size_t ret;
; 455  : 
; 456  :     if ((buf == NULL) || (cur == NULL))

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@htmlNodeDu
	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@htmlNodeDu
$LN3@htmlNodeDu:

; 457  :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@htmlNodeDu
$LN2@htmlNodeDu:

; 458  : 
; 459  :     xmlInitParser();

	call	_xmlInitParser

; 460  :     buffer = xmlBufFromBuffer(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufFromBuffer
	add	esp, 4
	mov	DWORD PTR _buffer$[ebp], eax

; 461  :     if (buffer == NULL)

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN4@htmlNodeDu

; 462  :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@htmlNodeDu
$LN4@htmlNodeDu:

; 463  : 
; 464  :     ret = htmlBufNodeDumpFormat(buffer, doc, cur, 1);

	push	1
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_htmlBufNodeDumpFormat
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 465  : 
; 466  :     xmlBufBackToBuffer(buffer);

	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_xmlBufBackToBuffer
	add	esp, 4

; 467  : 
; 468  :     if (ret > INT_MAX)

	cmp	DWORD PTR _ret$[ebp], 2147483647	; 7fffffffH
	jbe	SHORT $LN5@htmlNodeDu

; 469  :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@htmlNodeDu
$LN5@htmlNodeDu:

; 470  :     return((int) ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@htmlNodeDu:

; 471  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_htmlNodeDump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlSaveFile
_TEXT	SEGMENT
_enc$1 = -20						; size = 4
_ret$ = -16						; size = 4
_encoding$ = -12					; size = 4
_handler$ = -8						; size = 4
_buf$ = -4						; size = 4
_filename$ = 8						; size = 4
_cur$ = 12						; size = 4
_htmlSaveFile PROC					; COMDAT

; 1126 : htmlSaveFile(const char *filename, xmlDocPtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 1127 :     xmlOutputBufferPtr buf;
; 1128 :     xmlCharEncodingHandlerPtr handler = NULL;

	mov	DWORD PTR _handler$[ebp], 0

; 1129 :     const char *encoding;
; 1130 :     int ret;
; 1131 : 
; 1132 :     if ((cur == NULL) || (filename == NULL))

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@htmlSaveFi
	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN2@htmlSaveFi
$LN3@htmlSaveFi:

; 1133 :         return(-1);

	or	eax, -1
	jmp	$LN1@htmlSaveFi
$LN2@htmlSaveFi:

; 1134 : 
; 1135 :     xmlInitParser();

	call	_xmlInitParser

; 1136 : 
; 1137 :     encoding = (const char *) htmlGetMetaEncoding(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_htmlGetMetaEncoding
	add	esp, 4
	mov	DWORD PTR _encoding$[ebp], eax

; 1138 : 
; 1139 :     if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN4@htmlSaveFi

; 1140 : 	xmlCharEncoding enc;
; 1141 : 
; 1142 : 	enc = xmlParseCharEncoding(encoding);

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	call	_xmlParseCharEncoding
	add	esp, 4
	mov	DWORD PTR _enc$1[ebp], eax

; 1143 : 	if (enc != XML_CHAR_ENCODING_UTF8) {

	cmp	DWORD PTR _enc$1[ebp], 1
	je	SHORT $LN6@htmlSaveFi

; 1144 : 	    handler = xmlFindCharEncodingHandler(encoding);

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1145 : 	    if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN6@htmlSaveFi

; 1146 : 		htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	push	0
	push	1403					; 0000057bH
	call	_htmlSaveErr
	add	esp, 12					; 0000000cH
$LN6@htmlSaveFi:

; 1147 : 	}
; 1148 :     } else {

	jmp	SHORT $LN5@htmlSaveFi
$LN4@htmlSaveFi:

; 1149 :         /*
; 1150 :          * Fallback to HTML or ASCII when the encoding is unspecified
; 1151 :          */
; 1152 :         if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN8@htmlSaveFi

; 1153 :             handler = xmlFindCharEncodingHandler("HTML");

	push	OFFSET ??_C@_04DBLPJNAF@HTML@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax
$LN8@htmlSaveFi:

; 1154 :         if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN5@htmlSaveFi

; 1155 :             handler = xmlFindCharEncodingHandler("ascii");

	push	OFFSET ??_C@_05OJENGABA@ascii@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax
$LN5@htmlSaveFi:

; 1156 :     }
; 1157 : 
; 1158 :     /*
; 1159 :      * save the content to a temp buffer.
; 1160 :      */
; 1161 :     buf = xmlOutputBufferCreateFilename(filename, handler, cur->compression);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _handler$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_xmlOutputBufferCreateFilename
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buf$[ebp], eax

; 1162 :     if (buf == NULL) return(0);

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN10@htmlSaveFi
	xor	eax, eax
	jmp	SHORT $LN1@htmlSaveFi
$LN10@htmlSaveFi:

; 1163 : 
; 1164 :     htmlDocContentDumpOutput(buf, cur, NULL);

	push	0
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_htmlDocContentDumpOutput
	add	esp, 12					; 0000000cH

; 1165 : 
; 1166 :     ret = xmlOutputBufferClose(buf);

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlOutputBufferClose
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 1167 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@htmlSaveFi:

; 1168 : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_htmlSaveFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlDocDump
_TEXT	SEGMENT
_enc$1 = -20						; size = 4
_ret$ = -16						; size = 4
_encoding$ = -12					; size = 4
_handler$ = -8						; size = 4
_buf$ = -4						; size = 4
_f$ = 8							; size = 4
_cur$ = 12						; size = 4
_htmlDocDump PROC					; COMDAT

; 1075 : htmlDocDump(FILE *f, xmlDocPtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 1076 :     xmlOutputBufferPtr buf;
; 1077 :     xmlCharEncodingHandlerPtr handler = NULL;

	mov	DWORD PTR _handler$[ebp], 0

; 1078 :     const char *encoding;
; 1079 :     int ret;
; 1080 : 
; 1081 :     xmlInitParser();

	call	_xmlInitParser

; 1082 : 
; 1083 :     if ((cur == NULL) || (f == NULL)) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@htmlDocDum
	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@htmlDocDum
$LN3@htmlDocDum:

; 1084 : 	return(-1);

	or	eax, -1
	jmp	$LN1@htmlDocDum
$LN2@htmlDocDum:

; 1085 :     }
; 1086 : 
; 1087 :     encoding = (const char *) htmlGetMetaEncoding(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_htmlGetMetaEncoding
	add	esp, 4
	mov	DWORD PTR _encoding$[ebp], eax

; 1088 : 
; 1089 :     if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN4@htmlDocDum

; 1090 : 	xmlCharEncoding enc;
; 1091 : 
; 1092 : 	enc = xmlParseCharEncoding(encoding);

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	call	_xmlParseCharEncoding
	add	esp, 4
	mov	DWORD PTR _enc$1[ebp], eax

; 1093 : 	if (enc != XML_CHAR_ENCODING_UTF8) {

	cmp	DWORD PTR _enc$1[ebp], 1
	je	SHORT $LN6@htmlDocDum

; 1094 : 	    handler = xmlFindCharEncodingHandler(encoding);

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1095 : 	    if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN6@htmlDocDum

; 1096 : 		htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	push	0
	push	1403					; 0000057bH
	call	_htmlSaveErr
	add	esp, 12					; 0000000cH
$LN6@htmlDocDum:

; 1097 : 	}
; 1098 :     } else {

	jmp	SHORT $LN5@htmlDocDum
$LN4@htmlDocDum:

; 1099 :         /*
; 1100 :          * Fallback to HTML or ASCII when the encoding is unspecified
; 1101 :          */
; 1102 :         if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN8@htmlDocDum

; 1103 :             handler = xmlFindCharEncodingHandler("HTML");

	push	OFFSET ??_C@_04DBLPJNAF@HTML@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax
$LN8@htmlDocDum:

; 1104 :         if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN5@htmlDocDum

; 1105 :             handler = xmlFindCharEncodingHandler("ascii");

	push	OFFSET ??_C@_05OJENGABA@ascii@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax
$LN5@htmlDocDum:

; 1106 :     }
; 1107 : 
; 1108 :     buf = xmlOutputBufferCreateFile(f, handler);

	mov	ecx, DWORD PTR _handler$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_xmlOutputBufferCreateFile
	add	esp, 8
	mov	DWORD PTR _buf$[ebp], eax

; 1109 :     if (buf == NULL) return(-1);

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN10@htmlDocDum
	or	eax, -1
	jmp	SHORT $LN1@htmlDocDum
$LN10@htmlDocDum:

; 1110 :     htmlDocContentDumpOutput(buf, cur, NULL);

	push	0
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_htmlDocContentDumpOutput
	add	esp, 12					; 0000000cH

; 1111 : 
; 1112 :     ret = xmlOutputBufferClose(buf);

	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferClose
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 1113 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@htmlDocDum:

; 1114 : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_htmlDocDump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlDocDumpMemoryFormat
_TEXT	SEGMENT
_enc$1 = -16						; size = 4
_encoding$ = -12					; size = 4
_handler$ = -8						; size = 4
_buf$ = -4						; size = 4
_cur$ = 8						; size = 4
_mem$ = 12						; size = 4
_size$ = 16						; size = 4
_format$ = 20						; size = 4
_htmlDocDumpMemoryFormat PROC				; COMDAT

; 552  : htmlDocDumpMemoryFormat(xmlDocPtr cur, xmlChar**mem, int *size, int format) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 553  :     xmlOutputBufferPtr buf;
; 554  :     xmlCharEncodingHandlerPtr handler = NULL;

	mov	DWORD PTR _handler$[ebp], 0

; 555  :     const char *encoding;
; 556  : 
; 557  :     xmlInitParser();

	call	_xmlInitParser

; 558  : 
; 559  :     if ((mem == NULL) || (size == NULL))

	cmp	DWORD PTR _mem$[ebp], 0
	je	SHORT $LN3@htmlDocDum
	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN2@htmlDocDum
$LN3@htmlDocDum:

; 560  :         return;

	jmp	$LN1@htmlDocDum
$LN2@htmlDocDum:

; 561  :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN4@htmlDocDum

; 562  : 	*mem = NULL;

	mov	eax, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [eax], 0

; 563  : 	*size = 0;

	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [ecx], 0

; 564  : 	return;

	jmp	$LN1@htmlDocDum
$LN4@htmlDocDum:

; 565  :     }
; 566  : 
; 567  :     encoding = (const char *) htmlGetMetaEncoding(cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_htmlGetMetaEncoding
	add	esp, 4
	mov	DWORD PTR _encoding$[ebp], eax

; 568  : 
; 569  :     if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN5@htmlDocDum

; 570  : 	xmlCharEncoding enc;
; 571  : 
; 572  : 	enc = xmlParseCharEncoding(encoding);

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	call	_xmlParseCharEncoding
	add	esp, 4
	mov	DWORD PTR _enc$1[ebp], eax

; 573  : 	if (enc != XML_CHAR_ENCODING_UTF8) {

	cmp	DWORD PTR _enc$1[ebp], 1
	je	SHORT $LN7@htmlDocDum

; 574  : 	    handler = xmlFindCharEncodingHandler(encoding);

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 575  : 	    if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN7@htmlDocDum

; 576  :                 htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	push	0
	push	1403					; 0000057bH
	call	_htmlSaveErr
	add	esp, 12					; 0000000cH
$LN7@htmlDocDum:

; 577  : 
; 578  : 	}
; 579  :     } else {

	jmp	SHORT $LN6@htmlDocDum
$LN5@htmlDocDum:

; 580  :         /*
; 581  :          * Fallback to HTML or ASCII when the encoding is unspecified
; 582  :          */
; 583  :         if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN9@htmlDocDum

; 584  :             handler = xmlFindCharEncodingHandler("HTML");

	push	OFFSET ??_C@_04DBLPJNAF@HTML@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax
$LN9@htmlDocDum:

; 585  :         if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN6@htmlDocDum

; 586  :             handler = xmlFindCharEncodingHandler("ascii");

	push	OFFSET ??_C@_05OJENGABA@ascii@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax
$LN6@htmlDocDum:

; 587  :     }
; 588  : 
; 589  :     buf = xmlAllocOutputBufferInternal(handler);

	mov	eax, DWORD PTR _handler$[ebp]
	push	eax
	call	_xmlAllocOutputBufferInternal
	add	esp, 4
	mov	DWORD PTR _buf$[ebp], eax

; 590  :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN11@htmlDocDum

; 591  : 	*mem = NULL;

	mov	ecx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [ecx], 0

; 592  : 	*size = 0;

	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx], 0

; 593  : 	return;

	jmp	$LN1@htmlDocDum
$LN11@htmlDocDum:

; 594  :     }
; 595  : 
; 596  :     htmlDocContentDumpFormatOutput(buf, cur, NULL, format);

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_htmlDocContentDumpFormatOutput
	add	esp, 16					; 00000010H

; 597  : 
; 598  :     xmlOutputBufferFlush(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlOutputBufferFlush
	add	esp, 4

; 599  :     if (buf->conv != NULL) {

	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN12@htmlDocDum

; 600  : 	*size = xmlBufUse(buf->conv);

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_xmlBufUse
	add	esp, 4
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 	*mem = xmlStrndup(xmlBufContent(buf->conv), *size);

	mov	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_xmlBufContent
	add	esp, 4
	push	eax
	call	_xmlStrndup
	add	esp, 8
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [ecx], eax

; 602  :     } else {

	jmp	SHORT $LN13@htmlDocDum
$LN12@htmlDocDum:

; 603  : 	*size = xmlBufUse(buf->buffer);

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufUse
	add	esp, 4
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [ecx], eax

; 604  : 	*mem = xmlStrndup(xmlBufContent(buf->buffer), *size);

	mov	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufContent
	add	esp, 4
	push	eax
	call	_xmlStrndup
	add	esp, 8
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [ecx], eax
$LN13@htmlDocDum:

; 605  :     }
; 606  :     (void)xmlOutputBufferClose(buf);

	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlOutputBufferClose
	add	esp, 4
$LN1@htmlDocDum:

; 607  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_htmlDocDumpMemoryFormat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlDocDumpMemory
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_mem$ = 12						; size = 4
_size$ = 16						; size = 4
_htmlDocDumpMemory PROC					; COMDAT

; 619  : htmlDocDumpMemory(xmlDocPtr cur, xmlChar**mem, int *size) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 620  : 	htmlDocDumpMemoryFormat(cur, mem, size, 1);

	push	1
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_htmlDocDumpMemoryFormat
	add	esp, 16					; 00000010H

; 621  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_htmlDocDumpMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlSetMetaEncoding
_TEXT	SEGMENT
_value$1 = -136						; size = 4
_http$2 = -132						; size = 4
_attr$3 = -128						; size = 4
_newcontent$ = -120					; size = 100
_content$ = -16						; size = 4
_head$ = -12						; size = 4
_meta$ = -8						; size = 4
_cur$ = -4						; size = 4
_doc$ = 8						; size = 4
_encoding$ = 12						; size = 4
_htmlSetMetaEncoding PROC				; COMDAT

; 164  : htmlSetMetaEncoding(htmlDocPtr doc, const xmlChar *encoding) {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	edi
	lea	edi, DWORD PTR [ebp-136]
	mov	ecx, 34					; 00000022H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 165  :     htmlNodePtr cur, meta = NULL, head = NULL;

	mov	DWORD PTR _meta$[ebp], 0
	mov	DWORD PTR _head$[ebp], 0

; 166  :     const xmlChar *content = NULL;

	mov	DWORD PTR _content$[ebp], 0

; 167  :     char newcontent[100];
; 168  : 
; 169  :     newcontent[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _newcontent$[ebp+ecx], 0

; 170  : 
; 171  :     if (doc == NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN10@htmlSetMet

; 172  : 	return(-1);

	or	eax, -1
	jmp	$LN1@htmlSetMet
$LN10@htmlSetMet:

; 173  : 
; 174  :     /* html isn't a real encoding it's just libxml2 way to get entities */
; 175  :     if (!xmlStrcasecmp(encoding, BAD_CAST "html"))

	push	OFFSET ??_C@_04PNIFHPHN@html@
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@htmlSetMet

; 176  :         return(-1);

	or	eax, -1
	jmp	$LN1@htmlSetMet
$LN11@htmlSetMet:

; 177  : 
; 178  :     if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN12@htmlSetMet

; 179  : 	snprintf(newcontent, sizeof(newcontent), "text/html; charset=%s",

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	push	OFFSET ??_C@_0BG@HLDJIGE@text?1html?$DL?5charset?$DN?$CFs@
	push	100					; 00000064H
	lea	ecx, DWORD PTR _newcontent$[ebp]
	push	ecx
	call	_snprintf
	add	esp, 16					; 00000010H

; 180  :                 (char *)encoding);
; 181  : 	newcontent[sizeof(newcontent) - 1] = 0;

	mov	edx, 1
	imul	eax, edx, 99
	mov	BYTE PTR _newcontent$[ebp+eax], 0
$LN12@htmlSetMet:

; 182  :     }
; 183  : 
; 184  :     cur = doc->children;

	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx
$LN2@htmlSetMet:

; 185  : 
; 186  :     /*
; 187  :      * Search the html
; 188  :      */
; 189  :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@htmlSetMet

; 190  : 	if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN13@htmlSetMet
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN13@htmlSetMet

; 191  : 	    if (xmlStrcasecmp(cur->name, BAD_CAST"html") == 0)

	push	OFFSET ??_C@_04PNIFHPHN@html@
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@htmlSetMet

; 192  : 		break;

	jmp	SHORT $LN3@htmlSetMet
$LN14@htmlSetMet:

; 193  : 	    if (xmlStrcasecmp(cur->name, BAD_CAST"head") == 0)

	push	OFFSET ??_C@_04NEODDMOL@head@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN15@htmlSetMet

; 194  : 		goto found_head;

	jmp	$found_head$43
$LN15@htmlSetMet:

; 195  : 	    if (xmlStrcasecmp(cur->name, BAD_CAST"meta") == 0)

	push	OFFSET ??_C@_04HLJJCGEF@meta@
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@htmlSetMet

; 196  : 		goto found_meta;

	jmp	$found_meta$44
$LN13@htmlSetMet:

; 197  : 	}
; 198  : 	cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _cur$[ebp], eax

; 199  :     }

	jmp	SHORT $LN2@htmlSetMet
$LN3@htmlSetMet:

; 200  :     if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN17@htmlSetMet

; 201  : 	return(-1);

	or	eax, -1
	jmp	$LN1@htmlSetMet
$LN17@htmlSetMet:

; 202  :     cur = cur->children;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx
$LN4@htmlSetMet:

; 203  : 
; 204  :     /*
; 205  :      * Search the head
; 206  :      */
; 207  :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN5@htmlSetMet

; 208  : 	if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN18@htmlSetMet
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN18@htmlSetMet

; 209  : 	    if (xmlStrcasecmp(cur->name, BAD_CAST"head") == 0)

	push	OFFSET ??_C@_04NEODDMOL@head@
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@htmlSetMet

; 210  : 		break;

	jmp	SHORT $LN5@htmlSetMet
$LN19@htmlSetMet:

; 211  : 	    if (xmlStrcasecmp(cur->name, BAD_CAST"meta") == 0) {

	push	OFFSET ??_C@_04HLJJCGEF@meta@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN18@htmlSetMet

; 212  :                 head = cur->parent;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _head$[ebp], ecx

; 213  : 		goto found_meta;

	jmp	SHORT $found_meta$44
$LN18@htmlSetMet:

; 214  :             }
; 215  : 	}
; 216  : 	cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _cur$[ebp], eax

; 217  :     }

	jmp	SHORT $LN4@htmlSetMet
$LN5@htmlSetMet:

; 218  :     if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $found_head$43

; 219  : 	return(-1);

	or	eax, -1
	jmp	$LN1@htmlSetMet
$found_head$43:

; 220  : found_head:
; 221  :     head = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _head$[ebp], ecx

; 222  :     if (cur->children == NULL)

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN22@htmlSetMet

; 223  :         goto create;

	jmp	$create$45
$LN22@htmlSetMet:

; 224  :     cur = cur->children;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _cur$[ebp], ecx
$found_meta$44:

; 225  : 
; 226  : found_meta:
; 227  :     /*
; 228  :      * Search and update all the remaining the meta elements carrying
; 229  :      * encoding informations
; 230  :      */
; 231  :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$create$45

; 232  : 	if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 1
	jne	$LN23@htmlSetMet
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	$LN23@htmlSetMet

; 233  : 	    if (xmlStrcasecmp(cur->name, BAD_CAST"meta") == 0) {

	push	OFFSET ??_C@_04HLJJCGEF@meta@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	$LN23@htmlSetMet

; 234  : 		xmlAttrPtr attr = cur->properties;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _attr$3[ebp], ecx

; 235  : 		int http;
; 236  : 		const xmlChar *value;
; 237  : 
; 238  : 		content = NULL;

	mov	DWORD PTR _content$[ebp], 0

; 239  : 		http = 0;

	mov	DWORD PTR _http$2[ebp], 0
$LN8@htmlSetMet:

; 240  : 		while (attr != NULL) {

	cmp	DWORD PTR _attr$3[ebp], 0
	je	$LN9@htmlSetMet

; 241  : 		    if ((attr->children != NULL) &&
; 242  : 		        (attr->children->type == XML_TEXT_NODE) &&

	mov	edx, DWORD PTR _attr$3[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	$LN25@htmlSetMet
	mov	eax, DWORD PTR _attr$3[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	DWORD PTR [ecx+4], 3
	jne	$LN25@htmlSetMet
	mov	edx, DWORD PTR _attr$3[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	DWORD PTR [eax+24], 0
	jne	$LN25@htmlSetMet

; 243  : 		        (attr->children->next == NULL)) {
; 244  : 			value = attr->children->content;

	mov	ecx, DWORD PTR _attr$3[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _value$1[ebp], eax

; 245  : 			if ((!xmlStrcasecmp(attr->name, BAD_CAST"http-equiv"))
; 246  : 			 && (!xmlStrcasecmp(value, BAD_CAST"Content-Type")))

	push	OFFSET ??_C@_0L@NALBGOHO@http?9equiv@
	mov	ecx, DWORD PTR _attr$3[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@htmlSetMet
	push	OFFSET ??_C@_0N@LAFFMKKA@Content?9Type@
	mov	eax, DWORD PTR _value$1[ebp]
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@htmlSetMet

; 247  : 			    http = 1;

	mov	DWORD PTR _http$2[ebp], 1
	jmp	SHORT $LN27@htmlSetMet
$LN26@htmlSetMet:

; 248  : 			else
; 249  :                         {
; 250  :                            if ((value != NULL) &&

	cmp	DWORD PTR _value$1[ebp], 0
	je	SHORT $LN27@htmlSetMet
	push	OFFSET ??_C@_07ICAJMOAO@content@
	mov	ecx, DWORD PTR _attr$3[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@htmlSetMet

; 251  :                                (!xmlStrcasecmp(attr->name, BAD_CAST"content")))
; 252  : 			       content = value;

	mov	eax, DWORD PTR _value$1[ebp]
	mov	DWORD PTR _content$[ebp], eax
$LN27@htmlSetMet:

; 253  :                         }
; 254  : 		        if ((http != 0) && (content != NULL))

	cmp	DWORD PTR _http$2[ebp], 0
	je	SHORT $LN25@htmlSetMet
	cmp	DWORD PTR _content$[ebp], 0
	je	SHORT $LN25@htmlSetMet

; 255  : 			    break;

	jmp	SHORT $LN9@htmlSetMet
$LN25@htmlSetMet:

; 256  : 		    }
; 257  : 		    attr = attr->next;

	mov	ecx, DWORD PTR _attr$3[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _attr$3[ebp], edx

; 258  : 		}

	jmp	$LN8@htmlSetMet
$LN9@htmlSetMet:

; 259  : 		if ((http != 0) && (content != NULL)) {

	cmp	DWORD PTR _http$2[ebp], 0
	je	SHORT $LN23@htmlSetMet
	cmp	DWORD PTR _content$[ebp], 0
	je	SHORT $LN23@htmlSetMet

; 260  : 		    meta = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _meta$[ebp], eax

; 261  : 		    break;

	jmp	SHORT $create$45
$LN23@htmlSetMet:

; 262  : 		}
; 263  : 
; 264  : 	    }
; 265  : 	}
; 266  : 	cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$[ebp], edx

; 267  :     }

	jmp	$found_meta$44
$create$45:

; 268  : create:
; 269  :     if (meta == NULL) {

	cmp	DWORD PTR _meta$[ebp], 0
	jne	SHORT $LN31@htmlSetMet

; 270  :         if ((encoding != NULL) && (head != NULL)) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN33@htmlSetMet
	cmp	DWORD PTR _head$[ebp], 0
	je	SHORT $LN33@htmlSetMet

; 271  :             /*
; 272  :              * Create a new Meta element with the right attributes
; 273  :              */
; 274  : 
; 275  :             meta = xmlNewDocNode(doc, NULL, BAD_CAST"meta", NULL);

	push	0
	push	OFFSET ??_C@_04HLJJCGEF@meta@
	push	0
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _meta$[ebp], eax

; 276  :             if (head->children == NULL)

	mov	ecx, DWORD PTR _head$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN34@htmlSetMet

; 277  :                 xmlAddChild(head, meta);

	mov	edx, DWORD PTR _meta$[ebp]
	push	edx
	mov	eax, DWORD PTR _head$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	jmp	SHORT $LN35@htmlSetMet
$LN34@htmlSetMet:

; 278  :             else
; 279  :                 xmlAddPrevSibling(head->children, meta);

	mov	ecx, DWORD PTR _meta$[ebp]
	push	ecx
	mov	edx, DWORD PTR _head$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlAddPrevSibling
	add	esp, 8
$LN35@htmlSetMet:

; 280  :             xmlNewProp(meta, BAD_CAST"http-equiv", BAD_CAST"Content-Type");

	push	OFFSET ??_C@_0N@LAFFMKKA@Content?9Type@
	push	OFFSET ??_C@_0L@NALBGOHO@http?9equiv@
	mov	ecx, DWORD PTR _meta$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 281  :             xmlNewProp(meta, BAD_CAST"content", BAD_CAST newcontent);

	lea	edx, DWORD PTR _newcontent$[ebp]
	push	edx
	push	OFFSET ??_C@_07ICAJMOAO@content@
	mov	eax, DWORD PTR _meta$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$LN33@htmlSetMet:

; 282  :         }
; 283  :     } else {

	jmp	SHORT $LN32@htmlSetMet
$LN31@htmlSetMet:

; 284  :         /* remove the meta tag if NULL is passed */
; 285  :         if (encoding == NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	jne	SHORT $LN36@htmlSetMet

; 286  :             xmlUnlinkNode(meta);

	mov	ecx, DWORD PTR _meta$[ebp]
	push	ecx
	call	_xmlUnlinkNode
	add	esp, 4

; 287  :             xmlFreeNode(meta);

	mov	edx, DWORD PTR _meta$[ebp]
	push	edx
	call	_xmlFreeNode
	add	esp, 4

; 288  :         }

	jmp	SHORT $LN32@htmlSetMet
$LN36@htmlSetMet:

; 289  :         /* change the document only if there is a real encoding change */
; 290  :         else if (xmlStrcasestr(content, encoding) == NULL) {

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _content$[ebp]
	push	ecx
	call	_xmlStrcasestr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN32@htmlSetMet

; 291  :             xmlSetProp(meta, BAD_CAST"content", BAD_CAST newcontent);

	lea	edx, DWORD PTR _newcontent$[ebp]
	push	edx
	push	OFFSET ??_C@_07ICAJMOAO@content@
	mov	eax, DWORD PTR _meta$[ebp]
	push	eax
	call	_xmlSetProp
	add	esp, 12					; 0000000cH
$LN32@htmlSetMet:

; 292  :         }
; 293  :     }
; 294  : 
; 295  : 
; 296  :     return(0);

	xor	eax, eax
$LN1@htmlSetMet:

; 297  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN42@htmlSetMet
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 136				; 00000088H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@htmlSetMet:
	DD	1
	DD	$LN41@htmlSetMet
$LN41@htmlSetMet:
	DD	-120					; ffffff88H
	DD	100					; 00000064H
	DD	$LN40@htmlSetMet
$LN40@htmlSetMet:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
_htmlSetMetaEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlGetMetaEncoding
_TEXT	SEGMENT
_value$1 = -24						; size = 4
_http$2 = -20						; size = 4
_attr$3 = -16						; size = 4
_encoding$ = -12					; size = 4
_content$ = -8						; size = 4
_cur$ = -4						; size = 4
_doc$ = 8						; size = 4
_htmlGetMetaEncoding PROC				; COMDAT

; 50   : htmlGetMetaEncoding(htmlDocPtr doc) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 51   :     htmlNodePtr cur;
; 52   :     const xmlChar *content;
; 53   :     const xmlChar *encoding;
; 54   : 
; 55   :     if (doc == NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN12@htmlGetMet

; 56   : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@htmlGetMet
$LN12@htmlGetMet:

; 57   :     cur = doc->children;

	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _cur$[ebp], ecx
$LN2@htmlGetMet:

; 58   : 
; 59   :     /*
; 60   :      * Search the html
; 61   :      */
; 62   :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@htmlGetMet

; 63   : 	if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 1
	jne	SHORT $LN13@htmlGetMet
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN13@htmlGetMet

; 64   : 	    if (xmlStrEqual(cur->name, BAD_CAST"html"))

	push	OFFSET ??_C@_04PNIFHPHN@html@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@htmlGetMet

; 65   : 		break;

	jmp	SHORT $LN3@htmlGetMet
$LN14@htmlGetMet:

; 66   : 	    if (xmlStrEqual(cur->name, BAD_CAST"head"))

	push	OFFSET ??_C@_04NEODDMOL@head@
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@htmlGetMet

; 67   : 		goto found_head;

	jmp	$found_head$39
$LN15@htmlGetMet:

; 68   : 	    if (xmlStrEqual(cur->name, BAD_CAST"meta"))

	push	OFFSET ??_C@_04HLJJCGEF@meta@
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@htmlGetMet

; 69   : 		goto found_meta;

	jmp	$found_meta$40
$LN13@htmlGetMet:

; 70   : 	}
; 71   : 	cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$[ebp], edx

; 72   :     }

	jmp	SHORT $LN2@htmlGetMet
$LN3@htmlGetMet:

; 73   :     if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN17@htmlGetMet

; 74   : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@htmlGetMet
$LN17@htmlGetMet:

; 75   :     cur = cur->children;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _cur$[ebp], ecx
$LN4@htmlGetMet:

; 76   : 
; 77   :     /*
; 78   :      * Search the head
; 79   :      */
; 80   :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN5@htmlGetMet

; 81   : 	if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 1
	jne	SHORT $LN18@htmlGetMet
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN18@htmlGetMet

; 82   : 	    if (xmlStrEqual(cur->name, BAD_CAST"head"))

	push	OFFSET ??_C@_04NEODDMOL@head@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@htmlGetMet

; 83   : 		break;

	jmp	SHORT $LN5@htmlGetMet
$LN19@htmlGetMet:

; 84   : 	    if (xmlStrEqual(cur->name, BAD_CAST"meta"))

	push	OFFSET ??_C@_04HLJJCGEF@meta@
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@htmlGetMet

; 85   : 		goto found_meta;

	jmp	SHORT $found_meta$40
$LN18@htmlGetMet:

; 86   : 	}
; 87   : 	cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _cur$[ebp], eax

; 88   :     }

	jmp	SHORT $LN4@htmlGetMet
$LN5@htmlGetMet:

; 89   :     if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $found_head$39

; 90   : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@htmlGetMet
$found_head$39:

; 91   : found_head:
; 92   :     cur = cur->children;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx
$found_meta$40:

; 93   : 
; 94   :     /*
; 95   :      * Search the meta elements
; 96   :      */
; 97   : found_meta:
; 98   :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN7@htmlGetMet

; 99   : 	if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	$LN22@htmlGetMet
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	$LN22@htmlGetMet

; 100  : 	    if (xmlStrEqual(cur->name, BAD_CAST"meta")) {

	push	OFFSET ??_C@_04HLJJCGEF@meta@
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN22@htmlGetMet

; 101  : 		xmlAttrPtr attr = cur->properties;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _attr$3[ebp], edx

; 102  : 		int http;
; 103  : 		const xmlChar *value;
; 104  : 
; 105  : 		content = NULL;

	mov	DWORD PTR _content$[ebp], 0

; 106  : 		http = 0;

	mov	DWORD PTR _http$2[ebp], 0
$LN8@htmlGetMet:

; 107  : 		while (attr != NULL) {

	cmp	DWORD PTR _attr$3[ebp], 0
	je	$LN22@htmlGetMet

; 108  : 		    if ((attr->children != NULL) &&
; 109  : 		        (attr->children->type == XML_TEXT_NODE) &&

	mov	eax, DWORD PTR _attr$3[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	$LN24@htmlGetMet
	mov	ecx, DWORD PTR _attr$3[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	DWORD PTR [edx+4], 3
	jne	$LN24@htmlGetMet
	mov	eax, DWORD PTR _attr$3[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN24@htmlGetMet

; 110  : 		        (attr->children->next == NULL)) {
; 111  : 			value = attr->children->content;

	mov	edx, DWORD PTR _attr$3[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _value$1[ebp], ecx

; 112  : 			if ((!xmlStrcasecmp(attr->name, BAD_CAST"http-equiv"))
; 113  : 			 && (!xmlStrcasecmp(value, BAD_CAST"Content-Type")))

	push	OFFSET ??_C@_0L@NALBGOHO@http?9equiv@
	mov	edx, DWORD PTR _attr$3[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@htmlGetMet
	push	OFFSET ??_C@_0N@LAFFMKKA@Content?9Type@
	mov	ecx, DWORD PTR _value$1[ebp]
	push	ecx
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@htmlGetMet

; 114  : 			    http = 1;

	mov	DWORD PTR _http$2[ebp], 1
	jmp	SHORT $LN26@htmlGetMet
$LN25@htmlGetMet:

; 115  : 			else if ((value != NULL)
; 116  : 			 && (!xmlStrcasecmp(attr->name, BAD_CAST"content")))

	cmp	DWORD PTR _value$1[ebp], 0
	je	SHORT $LN26@htmlGetMet
	push	OFFSET ??_C@_07ICAJMOAO@content@
	mov	edx, DWORD PTR _attr$3[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@htmlGetMet

; 117  : 			    content = value;

	mov	ecx, DWORD PTR _value$1[ebp]
	mov	DWORD PTR _content$[ebp], ecx
$LN26@htmlGetMet:

; 118  : 			if ((http != 0) && (content != NULL))

	cmp	DWORD PTR _http$2[ebp], 0
	je	SHORT $LN24@htmlGetMet
	cmp	DWORD PTR _content$[ebp], 0
	je	SHORT $LN24@htmlGetMet

; 119  : 			    goto found_content;

	jmp	SHORT $found_content$41
$LN24@htmlGetMet:

; 120  : 		    }
; 121  : 		    attr = attr->next;

	mov	edx, DWORD PTR _attr$3[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _attr$3[ebp], eax

; 122  : 		}

	jmp	$LN8@htmlGetMet
$LN22@htmlGetMet:

; 123  : 	    }
; 124  : 	}
; 125  : 	cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$[ebp], edx

; 126  :     }

	jmp	$found_meta$40
$LN7@htmlGetMet:

; 127  :     return(NULL);

	xor	eax, eax
	jmp	$LN1@htmlGetMet
$found_content$41:

; 128  : 
; 129  : found_content:
; 130  :     encoding = xmlStrstr(content, BAD_CAST"charset=");

	push	OFFSET ??_C@_08JPKHBDLJ@charset?$DN@
	mov	eax, DWORD PTR _content$[ebp]
	push	eax
	call	_xmlStrstr
	add	esp, 8
	mov	DWORD PTR _encoding$[ebp], eax

; 131  :     if (encoding == NULL)

	cmp	DWORD PTR _encoding$[ebp], 0
	jne	SHORT $LN29@htmlGetMet

; 132  : 	encoding = xmlStrstr(content, BAD_CAST"Charset=");

	push	OFFSET ??_C@_08BNFGJBBK@Charset?$DN@
	mov	ecx, DWORD PTR _content$[ebp]
	push	ecx
	call	_xmlStrstr
	add	esp, 8
	mov	DWORD PTR _encoding$[ebp], eax
$LN29@htmlGetMet:

; 133  :     if (encoding == NULL)

	cmp	DWORD PTR _encoding$[ebp], 0
	jne	SHORT $LN30@htmlGetMet

; 134  : 	encoding = xmlStrstr(content, BAD_CAST"CHARSET=");

	push	OFFSET ??_C@_08HFIPAJDM@CHARSET?$DN@
	mov	edx, DWORD PTR _content$[ebp]
	push	edx
	call	_xmlStrstr
	add	esp, 8
	mov	DWORD PTR _encoding$[ebp], eax
$LN30@htmlGetMet:

; 135  :     if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN31@htmlGetMet

; 136  : 	encoding += 8;

	mov	eax, DWORD PTR _encoding$[ebp]
	add	eax, 8
	mov	DWORD PTR _encoding$[ebp], eax

; 137  :     } else {

	jmp	SHORT $LN32@htmlGetMet
$LN31@htmlGetMet:

; 138  : 	encoding = xmlStrstr(content, BAD_CAST"charset =");

	push	OFFSET ??_C@_09MMDENEKG@charset?5?$DN@
	mov	ecx, DWORD PTR _content$[ebp]
	push	ecx
	call	_xmlStrstr
	add	esp, 8
	mov	DWORD PTR _encoding$[ebp], eax

; 139  : 	if (encoding == NULL)

	cmp	DWORD PTR _encoding$[ebp], 0
	jne	SHORT $LN33@htmlGetMet

; 140  : 	    encoding = xmlStrstr(content, BAD_CAST"Charset =");

	push	OFFSET ??_C@_09IDGJNHHG@Charset?5?$DN@
	mov	edx, DWORD PTR _content$[ebp]
	push	edx
	call	_xmlStrstr
	add	esp, 8
	mov	DWORD PTR _encoding$[ebp], eax
$LN33@htmlGetMet:

; 141  : 	if (encoding == NULL)

	cmp	DWORD PTR _encoding$[ebp], 0
	jne	SHORT $LN34@htmlGetMet

; 142  : 	    encoding = xmlStrstr(content, BAD_CAST"CHARSET =");

	push	OFFSET ??_C@_09FBAMILBD@CHARSET?5?$DN@
	mov	eax, DWORD PTR _content$[ebp]
	push	eax
	call	_xmlStrstr
	add	esp, 8
	mov	DWORD PTR _encoding$[ebp], eax
$LN34@htmlGetMet:

; 143  : 	if (encoding != NULL)

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN32@htmlGetMet

; 144  : 	    encoding += 9;

	mov	ecx, DWORD PTR _encoding$[ebp]
	add	ecx, 9
	mov	DWORD PTR _encoding$[ebp], ecx
$LN32@htmlGetMet:

; 145  :     }
; 146  :     if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN36@htmlGetMet
$LN10@htmlGetMet:

; 147  : 	while ((*encoding == ' ') || (*encoding == '\t')) encoding++;

	mov	edx, DWORD PTR _encoding$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN37@htmlGetMet
	mov	ecx, DWORD PTR _encoding$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jne	SHORT $LN36@htmlGetMet
$LN37@htmlGetMet:
	mov	eax, DWORD PTR _encoding$[ebp]
	add	eax, 1
	mov	DWORD PTR _encoding$[ebp], eax
	jmp	SHORT $LN10@htmlGetMet
$LN36@htmlGetMet:

; 148  :     }
; 149  :     return(encoding);

	mov	eax, DWORD PTR _encoding$[ebp]
$LN1@htmlGetMet:

; 150  : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_htmlGetMetaEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
tv81 = -20						; size = 4
__Result$1 = -16					; size = 4
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __BufferCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	edx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR [eax+4]
	push	edx
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$1[ebp], eax

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$1[ebp], 0
	jge	SHORT $LN5@snprintf
	mov	DWORD PTR tv81[ebp], -1
	jmp	SHORT $LN3@snprintf
$LN5@snprintf:
	mov	eax, DWORD PTR __Result$1[ebp]
	mov	DWORD PTR tv81[ebp], eax
$LN3@snprintf:

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 1954 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1955 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1956 :     }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
