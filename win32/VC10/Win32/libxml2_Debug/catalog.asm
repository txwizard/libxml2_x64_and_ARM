; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\catalog.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__A40A425D_stat@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__0FC738B4_catalog@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_snprintf
PUBLIC	_xmlNewCatalog
PUBLIC	_xmlLoadACatalog
PUBLIC	_xmlLoadSGMLSuperCatalog
PUBLIC	_xmlConvertSGMLCatalog
PUBLIC	_xmlACatalogAdd
PUBLIC	_xmlACatalogRemove
PUBLIC	_xmlACatalogResolve
PUBLIC	_xmlACatalogResolveSystem
PUBLIC	_xmlACatalogResolvePublic
PUBLIC	_xmlACatalogResolveURI
PUBLIC	_xmlACatalogDump
PUBLIC	_xmlFreeCatalog
PUBLIC	_xmlCatalogIsEmpty
PUBLIC	_xmlInitializeCatalog
PUBLIC	_xmlLoadCatalog
PUBLIC	_xmlLoadCatalogs
PUBLIC	_xmlCatalogCleanup
PUBLIC	_xmlCatalogDump
PUBLIC	_xmlCatalogResolve
PUBLIC	_xmlCatalogResolveSystem
PUBLIC	_xmlCatalogResolvePublic
PUBLIC	_xmlCatalogResolveURI
PUBLIC	_xmlCatalogAdd
PUBLIC	_xmlCatalogRemove
PUBLIC	_xmlParseCatalogFile
PUBLIC	_xmlCatalogConvert
PUBLIC	_xmlCatalogFreeLocal
PUBLIC	_xmlCatalogAddLocal
PUBLIC	_xmlCatalogLocalResolve
PUBLIC	_xmlCatalogLocalResolveURI
PUBLIC	_xmlCatalogSetDebug
PUBLIC	_xmlCatalogSetDefaultPrefer
PUBLIC	_xmlCatalogSetDefaults
PUBLIC	_xmlCatalogGetDefaults
PUBLIC	_xmlCatalogGetSystem
PUBLIC	_xmlCatalogGetPublic
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BJ@BLANILEA@allocating?5catalog?5entry@	; `string'
PUBLIC	??_C@_0BH@BGJCBBBD@Free?5catalog?5entry?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BE@GJGIKNJC@Free?5catalog?5entry?6@	; `string'
PUBLIC	??_C@_0BD@FCDBKBHD@allocating?5catalog@		; `string'
PUBLIC	??_C@_07JPOODLIK@ENTITY?5@			; `string'
PUBLIC	??_C@_09KGBCFCOH@ENTITY?5?$CF?$CF@		; `string'
PUBLIC	??_C@_08JFBCIFIP@DOCTYPE?5@			; `string'
PUBLIC	??_C@_09BKBNLHNH@LINKTYPE?5@			; `string'
PUBLIC	??_C@_09EADGFDGH@NOTATION?5@			; `string'
PUBLIC	??_C@_07GAMBALOD@PUBLIC?5@			; `string'
PUBLIC	??_C@_07PBLMPJLL@SYSTEM?5@			; `string'
PUBLIC	??_C@_09KHFEEDDG@DELEGATE?5@			; `string'
PUBLIC	??_C@_05FDFDEPAH@BASE?5@			; `string'
PUBLIC	??_C@_08LGGFEAEJ@CATALOG?5@			; `string'
PUBLIC	??_C@_09PKNPLMNA@DOCUMENT?5@			; `string'
PUBLIC	??_C@_09KEOJDEKL@SGMLDECL?5@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_04OEDFLLKD@?$CC?$CFs?$CC@			; `string'
PUBLIC	??_C@_05JEHJOICL@?5?$CC?$CFs?$CC@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0M@IKOOEBPK@nextCatalog@			; `string'
PUBLIC	??_C@_07MFFOOIHD@catalog@			; `string'
PUBLIC	??_C@_05MGJOOGAJ@group@				; `string'
PUBLIC	??_C@_02EGCJHIOB@id@				; `string'
PUBLIC	??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ ; `string'
PUBLIC	??_C@_04BHIIPFEC@base@				; `string'
PUBLIC	??_C@_06EOMAMIIF@public@			; `string'
PUBLIC	??_C@_06NEJLBODN@prefer@			; `string'
PUBLIC	??_C@_06FHFOAHML@system@			; `string'
PUBLIC	??_C@_08KNJBHAKA@publicId@			; `string'
PUBLIC	??_C@_03GBBABMJN@uri@				; `string'
PUBLIC	??_C@_08MILANEJE@systemId@			; `string'
PUBLIC	??_C@_0O@CCMDBGLO@rewriteSystem@		; `string'
PUBLIC	??_C@_0BE@DMCACPJB@systemIdStartString@		; `string'
PUBLIC	??_C@_0O@FCPDBOKG@rewritePrefix@		; `string'
PUBLIC	??_C@_0P@FNMIEEAK@delegatePublic@		; `string'
PUBLIC	??_C@_0BE@JKBIFJL@publicIdStartString@		; `string'
PUBLIC	??_C@_0P@EEFGILEE@delegateSystem@		; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_0L@BCFABNDK@rewriteURI@			; `string'
PUBLIC	??_C@_0P@HNKDCBAK@uriStartString@		; `string'
PUBLIC	??_C@_0M@NHAMNMJD@delegateURI@			; `string'
PUBLIC	??_C@_0EE@FEMHHJKG@http?3?1?1www?4oasis?9open?4org?1commi@ ; `string'
PUBLIC	??_C@_0DF@EBMIELJJ@?9?1?1OASIS?1?1DTD?5Entity?5Resolution@ ; `string'
PUBLIC	??_C@_0CM@FMEFCNGF@urn?3oasis?3names?3tc?3entity?3xmlns@ ; `string'
PUBLIC	??_C@_0CA@PPIGJEMK@Converting?5SGML?5catalog?5to?5XML?6@ ; `string'
PUBLIC	??_C@_0O@NOBDOKAH@urn?3publicid?3@		; `string'
PUBLIC	??_C@_0P@PCJPAHLM@out?5of?5memory?6@		; `string'
PUBLIC	??_C@_0BI@CBBLIKLJ@allocating?5catalog?5data@	; `string'
PUBLIC	??_C@_0BF@JJKMCIOA@?$CFs?5entry?5lacks?5?8?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0BF@BGILJEII@Found?5?$CFs?3?5?8?$CFs?8?5?8?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0BA@FJAJBNGG@Found?5?$CFs?3?5?8?$CFs?8?6@	; `string'
PUBLIC	??_C@_0BM@NDOJAICK@?$CFs?5entry?5?8?$CFs?8?5broken?5?$DP?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CA@KIJKHIJM@Invalid?5value?5for?5prefer?3?5?8?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0BM@BEDEBNKA@Failed?5to?5parse?5catalog?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BH@HBOEOPJE@?$CFd?5Parsing?5catalog?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BP@DJPOHLHG@File?5?$CFs?5is?5not?5an?5XML?5Catalog?6@ ; `string'
PUBLIC	??_C@_0BH@CAELNCCF@Found?5?$CFs?5in?5file?5hash?6@ ; `string'
PUBLIC	??_C@_0BL@NEIEMMME@?$CFs?5not?5found?5in?5file?5hash?6@ ; `string'
PUBLIC	??_C@_0BH@KIEODICD@?$CFs?5added?5to?5file?5hash?6@ ; `string'
PUBLIC	??_C@_0CN@LDFDKPIL@Failed?5to?5add?5unknown?5element?5?$CF@ ; `string'
PUBLIC	??_C@_0CA@DFBONGAG@Updating?5element?5?$CFs?5to?5catalog?6@ ; `string'
PUBLIC	??_C@_0BO@CBJLKDGJ@Adding?5element?5?$CFs?5to?5catalog?6@ ; `string'
PUBLIC	??_C@_0CC@LGDNIPOE@Removing?5element?5?$CFs?5from?5catalo@ ; `string'
PUBLIC	??_C@_0CC@DACKBEAO@Detected?5recursion?5in?5catalog?5?$CF@ ; `string'
PUBLIC	??_C@_0CB@ONCPCECG@Found?5system?5match?5?$CFs?0?5using?5?$CFs@ ; `string'
PUBLIC	??_C@_0BJ@CPNLKDBD@Using?5rewriting?5rule?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BL@MIEFLOCA@Trying?5system?5delegate?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BH@IJBOMLNL@Found?5public?5match?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BL@PNMEBECK@Trying?5public?5delegate?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BE@BBLLMFBP@Found?5URI?5match?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BI@FMDOMGLN@Trying?5URI?5delegate?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CD@CFKEBFJH@Public?5URN?5ID?5?$CFs?5expanded?5to?5NU@ ; `string'
PUBLIC	??_C@_0BO@PMAINHBC@Public?5URN?5ID?5expanded?5to?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CD@CPPNJIKG@System?5URN?5ID?5?$CFs?5expanded?5to?5NU@ ; `string'
PUBLIC	??_C@_0BO@PPGKEABI@System?5URN?5ID?5expanded?5to?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BM@FKFGGIIN@URN?5ID?5?$CFs?5expanded?5to?5NULL?6@ ; `string'
PUBLIC	??_C@_0BH@CIFAIMNL@URN?5ID?5expanded?5to?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BF@DLNFLLPI@allocating?5public?5ID@	; `string'
PUBLIC	??_C@_06FDHFNJBJ@SYSTEM@			; `string'
PUBLIC	??_C@_06EKOLBGFH@PUBLIC@			; `string'
PUBLIC	??_C@_08IALHHCM@DELEGATE@			; `string'
PUBLIC	??_C@_06GKLBAPIO@ENTITY@			; `string'
PUBLIC	??_C@_07JGKBCNAA@DOCTYPE@			; `string'
PUBLIC	??_C@_08PMANIKNM@LINKTYPE@			; `string'
PUBLIC	??_C@_08NCDGCBCC@NOTATION@			; `string'
PUBLIC	??_C@_08DJOOGKO@SGMLDECL@			; `string'
PUBLIC	??_C@_08OLOPJDNG@DOCUMENT@			; `string'
PUBLIC	??_C@_07DIADFEPH@CATALOG@			; `string'
PUBLIC	??_C@_04NLLCBHDK@BASE@				; `string'
PUBLIC	??_C@_08ICLDDLKE@OVERRIDE@			; `string'
PUBLIC	??_C@_0BC@DIJHIPPB@Resolve?5sysID?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BC@IFIFPGFD@Resolve?5pubID?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BM@EMMNBONF@Resolve?3?5pubID?5?$CFs?5sysID?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BD@JDBJIPCK@Resolve?3?5pubID?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BD@COALPGII@Resolve?3?5sysID?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BA@GHNHNPIN@Resolve?5URI?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BC@FJHLJCPJ@XML_DEBUG_CATALOG@		; `string'
PUBLIC	??_C@_0BC@LLNJEHMH@XML_CATALOG_FILES@		; `string'
PUBLIC	??_C@_0M@BAPINHKH@libxml2?4dll@			; `string'
PUBLIC	??_C@_0BA@IDHJNFKC@?2?4?4?2etc?2catalog@	; `string'
PUBLIC	??_C@_0BC@BLLDGNNC@Catalogs?5cleanup?6@		; `string'
PUBLIC	??_C@_0BJ@DJLGHJPH@Disabling?5catalog?5usage?6@	; `string'
PUBLIC	??_C@_0BP@JNJOABOL@Allowing?5only?5global?5catalogs?6@ ; `string'
PUBLIC	??_C@_0CK@GBNCHLDL@Allowing?5only?5catalogs?5from?5the@ ; `string'
PUBLIC	??_C@_0BH@NEFJFIDI@Allowing?5all?5catalogs?6@	; `string'
PUBLIC	??_C@_0CG@PBIOHMMD@Setting?5catalog?5preference?5to?5P@ ; `string'
PUBLIC	??_C@_0CG@GAPDIOJL@Setting?5catalog?5preference?5to?5S@ ; `string'
PUBLIC	??_C@_0BM@KJMHHCDF@Adding?5document?5catalog?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CC@EFNIHKEA@Local?5Resolve?3?5pubID?5?$CFs?5sysID?5?$CF@ ; `string'
PUBLIC	??_C@_0BJ@JNLHMJMH@Local?5Resolve?3?5pubID?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BJ@CAKFLAGF@Local?5Resolve?3?5sysID?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CO@JOIDOAAA@Use?5of?5deprecated?5xmlCatalogGet@ ; `string'
PUBLIC	??_C@_0CO@NCFNFNHN@Use?5of?5deprecated?5xmlCatalogGet@ ; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrncmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlStrcat:PROC
EXTRN	__imp__close:PROC
EXTRN	__imp__open:PROC
EXTRN	__imp__read:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp___stat64i32:PROC
EXTRN	__imp__getenv:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	_xmlNewDtd:PROC
EXTRN	_xmlNewNs:PROC
EXTRN	_xmlFreeNs:PROC
EXTRN	_xmlNewDoc:PROC
EXTRN	_xmlFreeDoc:PROC
EXTRN	_xmlNewDocNode:PROC
EXTRN	_xmlDocGetRootElement:PROC
EXTRN	_xmlAddChild:PROC
EXTRN	_xmlSearchNsByHref:PROC
EXTRN	_xmlSetProp:PROC
EXTRN	_xmlSetNsProp:PROC
EXTRN	_xmlGetProp:PROC
EXTRN	_xmlGetNsProp:PROC
EXTRN	_xmlNodeGetBase:PROC
EXTRN	_xmlSaveFormatFileTo:PROC
EXTRN	_xmlHashCreate:PROC
EXTRN	_xmlHashFree:PROC
EXTRN	_xmlHashAddEntry:PROC
EXTRN	_xmlHashRemoveEntry:PROC
EXTRN	_xmlHashLookup:PROC
EXTRN	_xmlHashSize:PROC
EXTRN	_xmlHashScan:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	_xmlParserInputBufferCreateFilename:PROC
EXTRN	_xmlParserGetDirectory:PROC
EXTRN	_xmlOutputBufferCreateFile:PROC
EXTRN	_xmlParseDocument:PROC
EXTRN	_xmlNewParserCtxt:PROC
EXTRN	_xmlFreeParserCtxt:PROC
EXTRN	___xmlDefaultSAXHandler:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	_xmlNewRMutex:PROC
EXTRN	_xmlRMutexLock:PROC
EXTRN	_xmlRMutexUnlock:PROC
EXTRN	_xmlFreeRMutex:PROC
EXTRN	_xmlGetThreadId:PROC
EXTRN	_xmlBuildURI:PROC
EXTRN	_xmlCanonicPath:PROC
EXTRN	_xmlCharInRange:PROC
EXTRN	_xmlNewInputStream:PROC
EXTRN	_inputPush:PROC
EXTRN	_xmlBufResetInput:PROC
EXTRN	_GetModuleHandleA@4:PROC
EXTRN	_GetModuleFileNameA@12:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_xmlDebugCatalogs DD 01H DUP (?)
_xmlCatalogXMLFiles DD 01H DUP (?)
_xmlDefaultCatalog DD 01H DUP (?)
_xmlCatalogMutex DD 01H DUP (?)
_xmlCatalogInitialized DD 01H DUP (?)
?result@?1??xmlCatalogGetSystem@@9@9 DB 03e8H DUP (?)	; `xmlCatalogGetSystem'::`2'::result
?msg@?1??xmlCatalogGetSystem@@9@9 DD 01H DUP (?)	; `xmlCatalogGetSystem'::`2'::msg
?result@?1??xmlCatalogGetPublic@@9@9 DB 03e8H DUP (?)	; `xmlCatalogGetPublic'::`2'::result
?msg@?1??xmlCatalogGetPublic@@9@9 DD 01H DUP (?)	; `xmlCatalogGetPublic'::`2'::msg
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CO@NCFNFNHN@Use?5of?5deprecated?5xmlCatalogGet@
CONST	SEGMENT
??_C@_0CO@NCFNFNHN@Use?5of?5deprecated?5xmlCatalogGet@ DB 'Use of depreca'
	DB	'ted xmlCatalogGetPublic() call', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JOIDOAAA@Use?5of?5deprecated?5xmlCatalogGet@
CONST	SEGMENT
??_C@_0CO@JOIDOAAA@Use?5of?5deprecated?5xmlCatalogGet@ DB 'Use of depreca'
	DB	'ted xmlCatalogGetSystem() call', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CAKFLAGF@Local?5Resolve?3?5sysID?5?$CFs?6@
CONST	SEGMENT
??_C@_0BJ@CAKFLAGF@Local?5Resolve?3?5sysID?5?$CFs?6@ DB 'Local Resolve: s'
	DB	'ysID %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JNLHMJMH@Local?5Resolve?3?5pubID?5?$CFs?6@
CONST	SEGMENT
??_C@_0BJ@JNLHMJMH@Local?5Resolve?3?5pubID?5?$CFs?6@ DB 'Local Resolve: p'
	DB	'ubID %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@EFNIHKEA@Local?5Resolve?3?5pubID?5?$CFs?5sysID?5?$CF@
CONST	SEGMENT
??_C@_0CC@EFNIHKEA@Local?5Resolve?3?5pubID?5?$CFs?5sysID?5?$CF@ DB 'Local'
	DB	' Resolve: pubID %s sysID %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KJMHHCDF@Adding?5document?5catalog?5?$CFs?6@
CONST	SEGMENT
??_C@_0BM@KJMHHCDF@Adding?5document?5catalog?5?$CFs?6@ DB 'Adding documen'
	DB	't catalog %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GAPDIOJL@Setting?5catalog?5preference?5to?5S@
CONST	SEGMENT
??_C@_0CG@GAPDIOJL@Setting?5catalog?5preference?5to?5S@ DB 'Setting catal'
	DB	'og preference to SYSTEM', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PBIOHMMD@Setting?5catalog?5preference?5to?5P@
CONST	SEGMENT
??_C@_0CG@PBIOHMMD@Setting?5catalog?5preference?5to?5P@ DB 'Setting catal'
	DB	'og preference to PUBLIC', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NEFJFIDI@Allowing?5all?5catalogs?6@
CONST	SEGMENT
??_C@_0BH@NEFJFIDI@Allowing?5all?5catalogs?6@ DB 'Allowing all catalogs', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GBNCHLDL@Allowing?5only?5catalogs?5from?5the@
CONST	SEGMENT
??_C@_0CK@GBNCHLDL@Allowing?5only?5catalogs?5from?5the@ DB 'Allowing only'
	DB	' catalogs from the document', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JNJOABOL@Allowing?5only?5global?5catalogs?6@
CONST	SEGMENT
??_C@_0BP@JNJOABOL@Allowing?5only?5global?5catalogs?6@ DB 'Allowing only '
	DB	'global catalogs', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DJLGHJPH@Disabling?5catalog?5usage?6@
CONST	SEGMENT
??_C@_0BJ@DJLGHJPH@Disabling?5catalog?5usage?6@ DB 'Disabling catalog usa'
	DB	'ge', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BLLDGNNC@Catalogs?5cleanup?6@
CONST	SEGMENT
??_C@_0BC@BLLDGNNC@Catalogs?5cleanup?6@ DB 'Catalogs cleanup', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IDHJNFKC@?2?4?4?2etc?2catalog@
CONST	SEGMENT
??_C@_0BA@IDHJNFKC@?2?4?4?2etc?2catalog@ DB '\..\etc\catalog', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BAPINHKH@libxml2?4dll@
CONST	SEGMENT
??_C@_0M@BAPINHKH@libxml2?4dll@ DB 'libxml2.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LLNJEHMH@XML_CATALOG_FILES@
CONST	SEGMENT
??_C@_0BC@LLNJEHMH@XML_CATALOG_FILES@ DB 'XML_CATALOG_FILES', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FJHLJCPJ@XML_DEBUG_CATALOG@
CONST	SEGMENT
??_C@_0BC@FJHLJCPJ@XML_DEBUG_CATALOG@ DB 'XML_DEBUG_CATALOG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GHNHNPIN@Resolve?5URI?5?$CFs?6@
CONST	SEGMENT
??_C@_0BA@GHNHNPIN@Resolve?5URI?5?$CFs?6@ DB 'Resolve URI %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@COALPGII@Resolve?3?5sysID?5?$CFs?6@
CONST	SEGMENT
??_C@_0BD@COALPGII@Resolve?3?5sysID?5?$CFs?6@ DB 'Resolve: sysID %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JDBJIPCK@Resolve?3?5pubID?5?$CFs?6@
CONST	SEGMENT
??_C@_0BD@JDBJIPCK@Resolve?3?5pubID?5?$CFs?6@ DB 'Resolve: pubID %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EMMNBONF@Resolve?3?5pubID?5?$CFs?5sysID?5?$CFs?6@
CONST	SEGMENT
??_C@_0BM@EMMNBONF@Resolve?3?5pubID?5?$CFs?5sysID?5?$CFs?6@ DB 'Resolve: '
	DB	'pubID %s sysID %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IFIFPGFD@Resolve?5pubID?5?$CFs?6@
CONST	SEGMENT
??_C@_0BC@IFIFPGFD@Resolve?5pubID?5?$CFs?6@ DB 'Resolve pubID %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DIJHIPPB@Resolve?5sysID?5?$CFs?6@
CONST	SEGMENT
??_C@_0BC@DIJHIPPB@Resolve?5sysID?5?$CFs?6@ DB 'Resolve sysID %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08ICLDDLKE@OVERRIDE@
CONST	SEGMENT
??_C@_08ICLDDLKE@OVERRIDE@ DB 'OVERRIDE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NLLCBHDK@BASE@
CONST	SEGMENT
??_C@_04NLLCBHDK@BASE@ DB 'BASE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DIADFEPH@CATALOG@
CONST	SEGMENT
??_C@_07DIADFEPH@CATALOG@ DB 'CATALOG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OLOPJDNG@DOCUMENT@
CONST	SEGMENT
??_C@_08OLOPJDNG@DOCUMENT@ DB 'DOCUMENT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DJOOGKO@SGMLDECL@
CONST	SEGMENT
??_C@_08DJOOGKO@SGMLDECL@ DB 'SGMLDECL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NCDGCBCC@NOTATION@
CONST	SEGMENT
??_C@_08NCDGCBCC@NOTATION@ DB 'NOTATION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PMANIKNM@LINKTYPE@
CONST	SEGMENT
??_C@_08PMANIKNM@LINKTYPE@ DB 'LINKTYPE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JGKBCNAA@DOCTYPE@
CONST	SEGMENT
??_C@_07JGKBCNAA@DOCTYPE@ DB 'DOCTYPE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GKLBAPIO@ENTITY@
CONST	SEGMENT
??_C@_06GKLBAPIO@ENTITY@ DB 'ENTITY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IALHHCM@DELEGATE@
CONST	SEGMENT
??_C@_08IALHHCM@DELEGATE@ DB 'DELEGATE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EKOLBGFH@PUBLIC@
CONST	SEGMENT
??_C@_06EKOLBGFH@PUBLIC@ DB 'PUBLIC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FDHFNJBJ@SYSTEM@
CONST	SEGMENT
??_C@_06FDHFNJBJ@SYSTEM@ DB 'SYSTEM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DLNFLLPI@allocating?5public?5ID@
CONST	SEGMENT
??_C@_0BF@DLNFLLPI@allocating?5public?5ID@ DB 'allocating public ID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CIFAIMNL@URN?5ID?5expanded?5to?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@CIFAIMNL@URN?5ID?5expanded?5to?5?$CFs?6@ DB 'URN ID expanded to'
	DB	' %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FKFGGIIN@URN?5ID?5?$CFs?5expanded?5to?5NULL?6@
CONST	SEGMENT
??_C@_0BM@FKFGGIIN@URN?5ID?5?$CFs?5expanded?5to?5NULL?6@ DB 'URN ID %s ex'
	DB	'panded to NULL', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PPGKEABI@System?5URN?5ID?5expanded?5to?5?$CFs?6@
CONST	SEGMENT
??_C@_0BO@PPGKEABI@System?5URN?5ID?5expanded?5to?5?$CFs?6@ DB 'System URN'
	DB	' ID expanded to %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CPPNJIKG@System?5URN?5ID?5?$CFs?5expanded?5to?5NU@
CONST	SEGMENT
??_C@_0CD@CPPNJIKG@System?5URN?5ID?5?$CFs?5expanded?5to?5NU@ DB 'System U'
	DB	'RN ID %s expanded to NULL', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PMAINHBC@Public?5URN?5ID?5expanded?5to?5?$CFs?6@
CONST	SEGMENT
??_C@_0BO@PMAINHBC@Public?5URN?5ID?5expanded?5to?5?$CFs?6@ DB 'Public URN'
	DB	' ID expanded to %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CFKEBFJH@Public?5URN?5ID?5?$CFs?5expanded?5to?5NU@
CONST	SEGMENT
??_C@_0CD@CFKEBFJH@Public?5URN?5ID?5?$CFs?5expanded?5to?5NU@ DB 'Public U'
	DB	'RN ID %s expanded to NULL', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FMDOMGLN@Trying?5URI?5delegate?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@FMDOMGLN@Trying?5URI?5delegate?5?$CFs?6@ DB 'Trying URI delegat'
	DB	'e %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BBLLMFBP@Found?5URI?5match?5?$CFs?6@
CONST	SEGMENT
??_C@_0BE@BBLLMFBP@Found?5URI?5match?5?$CFs?6@ DB 'Found URI match %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PNMEBECK@Trying?5public?5delegate?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@PNMEBECK@Trying?5public?5delegate?5?$CFs?6@ DB 'Trying public d'
	DB	'elegate %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IJBOMLNL@Found?5public?5match?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@IJBOMLNL@Found?5public?5match?5?$CFs?6@ DB 'Found public match '
	DB	'%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MIEFLOCA@Trying?5system?5delegate?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@MIEFLOCA@Trying?5system?5delegate?5?$CFs?6@ DB 'Trying system d'
	DB	'elegate %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CPNLKDBD@Using?5rewriting?5rule?5?$CFs?6@
CONST	SEGMENT
??_C@_0BJ@CPNLKDBD@Using?5rewriting?5rule?5?$CFs?6@ DB 'Using rewriting r'
	DB	'ule %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@ONCPCECG@Found?5system?5match?5?$CFs?0?5using?5?$CFs@
CONST	SEGMENT
??_C@_0CB@ONCPCECG@Found?5system?5match?5?$CFs?0?5using?5?$CFs@ DB 'Found'
	DB	' system match %s, using %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DACKBEAO@Detected?5recursion?5in?5catalog?5?$CF@
CONST	SEGMENT
??_C@_0CC@DACKBEAO@Detected?5recursion?5in?5catalog?5?$CF@ DB 'Detected r'
	DB	'ecursion in catalog %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LGDNIPOE@Removing?5element?5?$CFs?5from?5catalo@
CONST	SEGMENT
??_C@_0CC@LGDNIPOE@Removing?5element?5?$CFs?5from?5catalo@ DB 'Removing e'
	DB	'lement %s from catalog', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CBJLKDGJ@Adding?5element?5?$CFs?5to?5catalog?6@
CONST	SEGMENT
??_C@_0BO@CBJLKDGJ@Adding?5element?5?$CFs?5to?5catalog?6@ DB 'Adding elem'
	DB	'ent %s to catalog', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DFBONGAG@Updating?5element?5?$CFs?5to?5catalog?6@
CONST	SEGMENT
??_C@_0CA@DFBONGAG@Updating?5element?5?$CFs?5to?5catalog?6@ DB 'Updating '
	DB	'element %s to catalog', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LDFDKPIL@Failed?5to?5add?5unknown?5element?5?$CF@
CONST	SEGMENT
??_C@_0CN@LDFDKPIL@Failed?5to?5add?5unknown?5element?5?$CF@ DB 'Failed to'
	DB	' add unknown element %s to catalog', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KIEODICD@?$CFs?5added?5to?5file?5hash?6@
CONST	SEGMENT
??_C@_0BH@KIEODICD@?$CFs?5added?5to?5file?5hash?6@ DB '%s added to file h'
	DB	'ash', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NEIEMMME@?$CFs?5not?5found?5in?5file?5hash?6@
CONST	SEGMENT
??_C@_0BL@NEIEMMME@?$CFs?5not?5found?5in?5file?5hash?6@ DB '%s not found '
	DB	'in file hash', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CAELNCCF@Found?5?$CFs?5in?5file?5hash?6@
CONST	SEGMENT
??_C@_0BH@CAELNCCF@Found?5?$CFs?5in?5file?5hash?6@ DB 'Found %s in file h'
	DB	'ash', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJPOHLHG@File?5?$CFs?5is?5not?5an?5XML?5Catalog?6@
CONST	SEGMENT
??_C@_0BP@DJPOHLHG@File?5?$CFs?5is?5not?5an?5XML?5Catalog?6@ DB 'File %s '
	DB	'is not an XML Catalog', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HBOEOPJE@?$CFd?5Parsing?5catalog?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@HBOEOPJE@?$CFd?5Parsing?5catalog?5?$CFs?6@ DB '%d Parsing catal'
	DB	'og %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BEDEBNKA@Failed?5to?5parse?5catalog?5?$CFs?6@
CONST	SEGMENT
??_C@_0BM@BEDEBNKA@Failed?5to?5parse?5catalog?5?$CFs?6@ DB 'Failed to par'
	DB	'se catalog %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KIJKHIJM@Invalid?5value?5for?5prefer?3?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0CA@KIJKHIJM@Invalid?5value?5for?5prefer?3?5?8?$CFs?8?6@ DB 'Invali'
	DB	'd value for prefer: ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NDOJAICK@?$CFs?5entry?5?8?$CFs?8?5broken?5?$DP?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BM@NDOJAICK@?$CFs?5entry?5?8?$CFs?8?5broken?5?$DP?3?5?$CFs?6@ DB '%'
	DB	's entry ''%s'' broken ?: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FJAJBNGG@Found?5?$CFs?3?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BA@FJAJBNGG@Found?5?$CFs?3?5?8?$CFs?8?6@ DB 'Found %s: ''%s''', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BGILJEII@Found?5?$CFs?3?5?8?$CFs?8?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BF@BGILJEII@Found?5?$CFs?3?5?8?$CFs?8?5?8?$CFs?8?6@ DB 'Found %s: '
	DB	'''%s'' ''%s''', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JJKMCIOA@?$CFs?5entry?5lacks?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BF@JJKMCIOA@?$CFs?5entry?5lacks?5?8?$CFs?8?6@ DB '%s entry lacks '''
	DB	'%s''', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CBBLIKLJ@allocating?5catalog?5data@
CONST	SEGMENT
??_C@_0BI@CBBLIKLJ@allocating?5catalog?5data@ DB 'allocating catalog data'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PCJPAHLM@out?5of?5memory?6@
CONST	SEGMENT
??_C@_0P@PCJPAHLM@out?5of?5memory?6@ DB 'out of memory', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NOBDOKAH@urn?3publicid?3@
CONST	SEGMENT
??_C@_0O@NOBDOKAH@urn?3publicid?3@ DB 'urn:publicid:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PPIGJEMK@Converting?5SGML?5catalog?5to?5XML?6@
CONST	SEGMENT
??_C@_0CA@PPIGJEMK@Converting?5SGML?5catalog?5to?5XML?6@ DB 'Converting S'
	DB	'GML catalog to XML', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FMEFCNGF@urn?3oasis?3names?3tc?3entity?3xmlns@
CONST	SEGMENT
??_C@_0CM@FMEFCNGF@urn?3oasis?3names?3tc?3entity?3xmlns@ DB 'urn:oasis:na'
	DB	'mes:tc:entity:xmlns:xml:catalog', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EBMIELJJ@?9?1?1OASIS?1?1DTD?5Entity?5Resolution@
CONST	SEGMENT
??_C@_0DF@EBMIELJJ@?9?1?1OASIS?1?1DTD?5Entity?5Resolution@ DB '-//OASIS//'
	DB	'DTD Entity Resolution XML Catalog V1.0//EN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@FEMHHJKG@http?3?1?1www?4oasis?9open?4org?1commi@
CONST	SEGMENT
??_C@_0EE@FEMHHJKG@http?3?1?1www?4oasis?9open?4org?1commi@ DB 'http://www'
	DB	'.oasis-open.org/committees/entity/release/1.0/catalog.dtd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NHAMNMJD@delegateURI@
CONST	SEGMENT
??_C@_0M@NHAMNMJD@delegateURI@ DB 'delegateURI', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HNKDCBAK@uriStartString@
CONST	SEGMENT
??_C@_0P@HNKDCBAK@uriStartString@ DB 'uriStartString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BCFABNDK@rewriteURI@
CONST	SEGMENT
??_C@_0L@BCFABNDK@rewriteURI@ DB 'rewriteURI', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EEFGILEE@delegateSystem@
CONST	SEGMENT
??_C@_0P@EEFGILEE@delegateSystem@ DB 'delegateSystem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JKBIFJL@publicIdStartString@
CONST	SEGMENT
??_C@_0BE@JKBIFJL@publicIdStartString@ DB 'publicIdStartString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FNMIEEAK@delegatePublic@
CONST	SEGMENT
??_C@_0P@FNMIEEAK@delegatePublic@ DB 'delegatePublic', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FCPDBOKG@rewritePrefix@
CONST	SEGMENT
??_C@_0O@FCPDBOKG@rewritePrefix@ DB 'rewritePrefix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DMCACPJB@systemIdStartString@
CONST	SEGMENT
??_C@_0BE@DMCACPJB@systemIdStartString@ DB 'systemIdStartString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CCMDBGLO@rewriteSystem@
CONST	SEGMENT
??_C@_0O@CCMDBGLO@rewriteSystem@ DB 'rewriteSystem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MILANEJE@systemId@
CONST	SEGMENT
??_C@_08MILANEJE@systemId@ DB 'systemId', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GBBABMJN@uri@
CONST	SEGMENT
??_C@_03GBBABMJN@uri@ DB 'uri', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08KNJBHAKA@publicId@
CONST	SEGMENT
??_C@_08KNJBHAKA@publicId@ DB 'publicId', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system@
CONST	SEGMENT
??_C@_06FHFOAHML@system@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NEJLBODN@prefer@
CONST	SEGMENT
??_C@_06NEJLBODN@prefer@ DB 'prefer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EOMAMIIF@public@
CONST	SEGMENT
??_C@_06EOMAMIIF@public@ DB 'public', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BHIIPFEC@base@
CONST	SEGMENT
??_C@_04BHIIPFEC@base@ DB 'base', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
CONST	SEGMENT
??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ DB 'http://ww'
	DB	'w.w3.org/XML/1998/namespace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGCJHIOB@id@
CONST	SEGMENT
??_C@_02EGCJHIOB@id@ DB 'id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MGJOOGAJ@group@
CONST	SEGMENT
??_C@_05MGJOOGAJ@group@ DB 'group', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MFFOOIHD@catalog@
CONST	SEGMENT
??_C@_07MFFOOIHD@catalog@ DB 'catalog', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IKOOEBPK@nextCatalog@
CONST	SEGMENT
??_C@_0M@IKOOEBPK@nextCatalog@ DB 'nextCatalog', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05JEHJOICL@?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_05JEHJOICL@?5?$CC?$CFs?$CC@ DB ' "%s"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04OEDFLLKD@?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_04OEDFLLKD@?$CC?$CFs?$CC@ DB '"%s"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09KEOJDEKL@SGMLDECL?5@
CONST	SEGMENT
??_C@_09KEOJDEKL@SGMLDECL?5@ DB 'SGMLDECL ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKNPLMNA@DOCUMENT?5@
CONST	SEGMENT
??_C@_09PKNPLMNA@DOCUMENT?5@ DB 'DOCUMENT ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LGGFEAEJ@CATALOG?5@
CONST	SEGMENT
??_C@_08LGGFEAEJ@CATALOG?5@ DB 'CATALOG ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FDFDEPAH@BASE?5@
CONST	SEGMENT
??_C@_05FDFDEPAH@BASE?5@ DB 'BASE ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KHFEEDDG@DELEGATE?5@
CONST	SEGMENT
??_C@_09KHFEEDDG@DELEGATE?5@ DB 'DELEGATE ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PBLMPJLL@SYSTEM?5@
CONST	SEGMENT
??_C@_07PBLMPJLL@SYSTEM?5@ DB 'SYSTEM ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GAMBALOD@PUBLIC?5@
CONST	SEGMENT
??_C@_07GAMBALOD@PUBLIC?5@ DB 'PUBLIC ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EADGFDGH@NOTATION?5@
CONST	SEGMENT
??_C@_09EADGFDGH@NOTATION?5@ DB 'NOTATION ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BKBNLHNH@LINKTYPE?5@
CONST	SEGMENT
??_C@_09BKBNLHNH@LINKTYPE?5@ DB 'LINKTYPE ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JFBCIFIP@DOCTYPE?5@
CONST	SEGMENT
??_C@_08JFBCIFIP@DOCTYPE?5@ DB 'DOCTYPE ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KGBCFCOH@ENTITY?5?$CF?$CF@
CONST	SEGMENT
??_C@_09KGBCFCOH@ENTITY?5?$CF?$CF@ DB 'ENTITY %%', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JPOODLIK@ENTITY?5@
CONST	SEGMENT
??_C@_07JPOODLIK@ENTITY?5@ DB 'ENTITY ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FCDBKBHD@allocating?5catalog@
CONST	SEGMENT
??_C@_0BD@FCDBKBHD@allocating?5catalog@ DB 'allocating catalog', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GJGIKNJC@Free?5catalog?5entry?6@
CONST	SEGMENT
??_C@_0BE@GJGIKNJC@Free?5catalog?5entry?6@ DB 'Free catalog entry', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BGJCBBBD@Free?5catalog?5entry?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@BGJCBBBD@Free?5catalog?5entry?5?$CFs?6@ DB 'Free catalog entry '
	DB	'%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLANILEA@allocating?5catalog?5entry@
CONST	SEGMENT
??_C@_0BJ@BLANILEA@allocating?5catalog?5entry@ DB 'allocating catalog ent'
	DB	'ry', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ DB 'Memory al'
	DB	'location failed : %s', 0aH, 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_XML_XML_DEFAULT_CATALOG DB 'file:///etc/xml/catalog', 00H
	ORG $+232
_xmlCatalogDefaultAllow DD 03H
_xmlCatalogDefaultPrefer DD 01H
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlInitializeCatalogData
_TEXT	SEGMENT
_xmlInitializeCatalogData PROC				; COMDAT

; 3090 : xmlInitializeCatalogData(void) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3091 :     if (xmlCatalogInitialized != 0)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	je	SHORT $LN2@xmlInitial

; 3092 : 	return;

	jmp	SHORT $LN1@xmlInitial
$LN2@xmlInitial:

; 3093 : 
; 3094 :     if (getenv("XML_DEBUG_CATALOG"))

	mov	esi, esp
	push	OFFSET ??_C@_0BC@FJHLJCPJ@XML_DEBUG_CATALOG@
	call	DWORD PTR __imp__getenv
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN3@xmlInitial

; 3095 : 	xmlDebugCatalogs = 1;

	mov	DWORD PTR _xmlDebugCatalogs, 1
$LN3@xmlInitial:

; 3096 :     xmlCatalogMutex = xmlNewRMutex();

	call	_xmlNewRMutex
	mov	DWORD PTR _xmlCatalogMutex, eax

; 3097 : 
; 3098 :     xmlCatalogInitialized = 1;

	mov	DWORD PTR _xmlCatalogInitialized, 1
$LN1@xmlInitial:

; 3099 : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlInitializeCatalogData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogSGMLResolve
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_catal$ = 8						; size = 4
_pubID$ = 12						; size = 4
_sysID$ = 16						; size = 4
_xmlCatalogSGMLResolve PROC				; COMDAT

; 2614 : 	              const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2615 :     const xmlChar *ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 2616 : 
; 2617 :     if (catal->sgml == NULL)

	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	SHORT $LN2@xmlCatalog

; 2618 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCatalog
$LN2@xmlCatalog:

; 2619 : 
; 2620 :     if (pubID != NULL)

	cmp	DWORD PTR _pubID$[ebp], 0
	je	SHORT $LN3@xmlCatalog

; 2621 : 	ret = xmlCatalogGetSGMLPublic(catal->sgml, pubID);

	mov	ecx, DWORD PTR _pubID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_xmlCatalogGetSGMLPublic
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
$LN3@xmlCatalog:

; 2622 :     if (ret != NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN4@xmlCatalog

; 2623 : 	return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlCatalog
$LN4@xmlCatalog:

; 2624 :     if (sysID != NULL)

	cmp	DWORD PTR _sysID$[ebp], 0
	je	SHORT $LN5@xmlCatalog

; 2625 : 	ret = xmlCatalogGetSGMLSystem(catal->sgml, sysID);

	mov	ecx, DWORD PTR _sysID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_xmlCatalogGetSGMLSystem
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
$LN5@xmlCatalog:

; 2626 :     if (ret != NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN6@xmlCatalog

; 2627 : 	return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlCatalog
$LN6@xmlCatalog:

; 2628 :     return(NULL);

	xor	eax, eax
$LN1@xmlCatalog:

; 2629 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogSGMLResolve ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogGetSGMLSystem
_TEXT	SEGMENT
_entry$ = -4						; size = 4
_catal$ = 8						; size = 4
_sysID$ = 12						; size = 4
_xmlCatalogGetSGMLSystem PROC				; COMDAT

; 2588 : xmlCatalogGetSGMLSystem(xmlHashTablePtr catal, const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2589 :     xmlCatalogEntryPtr entry;
; 2590 : 
; 2591 :     if (catal == NULL)

	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN2@xmlCatalog

; 2592 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCatalog
$LN2@xmlCatalog:

; 2593 : 
; 2594 :     entry = (xmlCatalogEntryPtr) xmlHashLookup(catal, sysID);

	mov	eax, DWORD PTR _sysID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _catal$[ebp]
	push	ecx
	call	_xmlHashLookup
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 2595 :     if (entry == NULL)

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN3@xmlCatalog

; 2596 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCatalog
$LN3@xmlCatalog:

; 2597 :     if (entry->type == SGML_CATA_SYSTEM)

	mov	edx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [edx+12], 13			; 0000000dH
	jne	SHORT $LN4@xmlCatalog

; 2598 : 	return(entry->URL);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [eax+24]
	jmp	SHORT $LN1@xmlCatalog
$LN4@xmlCatalog:

; 2599 :     return(NULL);

	xor	eax, eax
$LN1@xmlCatalog:

; 2600 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogGetSGMLSystem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogGetSGMLPublic
_TEXT	SEGMENT
tv70 = -12						; size = 4
_normid$ = -8						; size = 4
_entry$ = -4						; size = 4
_catal$ = 8						; size = 4
_pubID$ = 12						; size = 4
_xmlCatalogGetSGMLPublic PROC				; COMDAT

; 2551 : xmlCatalogGetSGMLPublic(xmlHashTablePtr catal, const xmlChar *pubID) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2552 :     xmlCatalogEntryPtr entry;
; 2553 :     xmlChar *normid;
; 2554 : 
; 2555 :     if (catal == NULL)

	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN2@xmlCatalog

; 2556 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCatalog
$LN2@xmlCatalog:

; 2557 : 
; 2558 :     normid = xmlCatalogNormalizePublic(pubID);

	mov	eax, DWORD PTR _pubID$[ebp]
	push	eax
	call	_xmlCatalogNormalizePublic
	add	esp, 4
	mov	DWORD PTR _normid$[ebp], eax

; 2559 :     if (normid != NULL)

	cmp	DWORD PTR _normid$[ebp], 0
	je	SHORT $LN3@xmlCatalog

; 2560 :         pubID = (*normid != 0 ? normid : NULL);

	mov	ecx, DWORD PTR _normid$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN10@xmlCatalog
	mov	eax, DWORD PTR _normid$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN11@xmlCatalog
$LN10@xmlCatalog:
	mov	DWORD PTR tv70[ebp], 0
$LN11@xmlCatalog:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _pubID$[ebp], ecx
$LN3@xmlCatalog:

; 2561 : 
; 2562 :     entry = (xmlCatalogEntryPtr) xmlHashLookup(catal, pubID);

	mov	edx, DWORD PTR _pubID$[ebp]
	push	edx
	mov	eax, DWORD PTR _catal$[ebp]
	push	eax
	call	_xmlHashLookup
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 2563 :     if (entry == NULL) {

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN4@xmlCatalog

; 2564 : 	if (normid != NULL)

	cmp	DWORD PTR _normid$[ebp], 0
	je	SHORT $LN5@xmlCatalog

; 2565 : 	    xmlFree(normid);

	mov	esi, esp
	mov	ecx, DWORD PTR _normid$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@xmlCatalog:

; 2566 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCatalog
$LN4@xmlCatalog:

; 2567 :     }
; 2568 :     if (entry->type == SGML_CATA_PUBLIC) {

	mov	edx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [edx+12], 14			; 0000000eH
	jne	SHORT $LN6@xmlCatalog

; 2569 : 	if (normid != NULL)

	cmp	DWORD PTR _normid$[ebp], 0
	je	SHORT $LN7@xmlCatalog

; 2570 : 	    xmlFree(normid);

	mov	esi, esp
	mov	eax, DWORD PTR _normid$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlCatalog:

; 2571 : 	return(entry->URL);

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	jmp	SHORT $LN1@xmlCatalog
$LN6@xmlCatalog:

; 2572 :     }
; 2573 :     if (normid != NULL)

	cmp	DWORD PTR _normid$[ebp], 0
	je	SHORT $LN8@xmlCatalog

; 2574 :         xmlFree(normid);

	mov	esi, esp
	mov	edx, DWORD PTR _normid$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@xmlCatalog:

; 2575 :     return(NULL);

	xor	eax, eax
$LN1@xmlCatalog:

; 2576 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogGetSGMLPublic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseSGMLCatalog
_TEXT	SEGMENT
tv205 = -64						; size = 4
_filename$1 = -60					; size = 4
_entry$2 = -56						; size = 4
_entry$3 = -52						; size = 4
_filename$4 = -48					; size = 4
_normid$5 = -44						; size = 4
_type$6 = -40						; size = 4
_name$7 = -32						; size = 4
_sysid$8 = -20						; size = 4
_res$ = -12						; size = 4
_base$ = -8						; size = 4
_cur$ = -4						; size = 4
_catal$ = 8						; size = 4
_value$ = 12						; size = 4
_file$ = 16						; size = 4
_super$ = 20						; size = 4
_xmlParseSGMLCatalog PROC				; COMDAT

; 2331 : 	            const char *file, int super) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2332 :     const xmlChar *cur = value;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _cur$[ebp], eax

; 2333 :     xmlChar *base = NULL;

	mov	DWORD PTR _base$[ebp], 0

; 2334 :     int res;
; 2335 : 
; 2336 :     if ((cur == NULL) || (file == NULL))

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN15@xmlParseSG
	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN14@xmlParseSG
$LN15@xmlParseSG:

; 2337 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseSG
$LN14@xmlParseSG:

; 2338 :     base = xmlStrdup((const xmlChar *) file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _base$[ebp], eax
$LN2@xmlParseSG:

; 2339 : 
; 2340 :     while ((cur != NULL) && (cur[0] != 0)) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN3@xmlParseSG
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	$LN3@xmlParseSG
$LN4@xmlParseSG:

; 2341 : 	SKIP_BLANKS;

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN16@xmlParseSG
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN17@xmlParseSG
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN16@xmlParseSG
$LN17@xmlParseSG:
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN5@xmlParseSG
$LN16@xmlParseSG:
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN4@xmlParseSG
$LN5@xmlParseSG:

; 2342 : 	if (cur[0] == 0)

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN18@xmlParseSG

; 2343 : 	    break;

	jmp	$LN3@xmlParseSG
$LN18@xmlParseSG:

; 2344 : 	if ((cur[0] == '-') && (cur[1] == '-')) {

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN19@xmlParseSG
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN19@xmlParseSG

; 2345 : 	    cur = xmlParseSGMLCatalogComment(cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlParseSGMLCatalogComment
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 2346 : 	    if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN21@xmlParseSG

; 2347 : 		/* error */
; 2348 : 		break;

	jmp	$LN3@xmlParseSG
$LN21@xmlParseSG:

; 2349 : 	    }
; 2350 : 	} else {

	jmp	$LN20@xmlParseSG
$LN19@xmlParseSG:

; 2351 : 	    xmlChar *sysid = NULL;

	mov	DWORD PTR _sysid$8[ebp], 0

; 2352 : 	    xmlChar *name = NULL;

	mov	DWORD PTR _name$7[ebp], 0

; 2353 : 	    xmlCatalogEntryType type = XML_CATA_NONE;

	mov	DWORD PTR _type$6[ebp], 0

; 2354 : 
; 2355 : 	    cur = xmlParseSGMLCatalogName(cur, &name);

	lea	eax, DWORD PTR _name$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlParseSGMLCatalogName
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 2356 : 	    if (name == NULL) {

	cmp	DWORD PTR _name$7[ebp], 0
	jne	SHORT $LN22@xmlParseSG

; 2357 : 		/* error */
; 2358 : 		break;

	jmp	$LN3@xmlParseSG
$LN22@xmlParseSG:

; 2359 : 	    }
; 2360 : 	    if (!IS_BLANK_CH(*cur)) {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN6@xmlParseSG
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN24@xmlParseSG
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN6@xmlParseSG
$LN24@xmlParseSG:
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN6@xmlParseSG

; 2361 : 		/* error */
; 2362 : 		break;

	jmp	$LN3@xmlParseSG
$LN6@xmlParseSG:

; 2363 : 	    }
; 2364 : 	    SKIP_BLANKS;

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN25@xmlParseSG
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN26@xmlParseSG
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN25@xmlParseSG
$LN26@xmlParseSG:
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN7@xmlParseSG
$LN25@xmlParseSG:
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN6@xmlParseSG
$LN7@xmlParseSG:

; 2365 : 	    if (xmlStrEqual(name, (const xmlChar *) "SYSTEM"))

	push	OFFSET ??_C@_06FDHFNJBJ@SYSTEM@
	mov	ecx, DWORD PTR _name$7[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@xmlParseSG

; 2366 :                 type = SGML_CATA_SYSTEM;

	mov	DWORD PTR _type$6[ebp], 13		; 0000000dH
	jmp	$LN28@xmlParseSG
$LN27@xmlParseSG:

; 2367 : 	    else if (xmlStrEqual(name, (const xmlChar *) "PUBLIC"))

	push	OFFSET ??_C@_06EKOLBGFH@PUBLIC@
	mov	edx, DWORD PTR _name$7[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN29@xmlParseSG

; 2368 :                 type = SGML_CATA_PUBLIC;

	mov	DWORD PTR _type$6[ebp], 14		; 0000000eH
	jmp	$LN28@xmlParseSG
$LN29@xmlParseSG:

; 2369 : 	    else if (xmlStrEqual(name, (const xmlChar *) "DELEGATE"))

	push	OFFSET ??_C@_08IALHHCM@DELEGATE@
	mov	eax, DWORD PTR _name$7[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN31@xmlParseSG

; 2370 :                 type = SGML_CATA_DELEGATE;

	mov	DWORD PTR _type$6[ebp], 20		; 00000014H
	jmp	$LN28@xmlParseSG
$LN31@xmlParseSG:

; 2371 : 	    else if (xmlStrEqual(name, (const xmlChar *) "ENTITY"))

	push	OFFSET ??_C@_06GKLBAPIO@ENTITY@
	mov	ecx, DWORD PTR _name$7[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@xmlParseSG

; 2372 :                 type = SGML_CATA_ENTITY;

	mov	DWORD PTR _type$6[ebp], 15		; 0000000fH
	jmp	$LN28@xmlParseSG
$LN33@xmlParseSG:

; 2373 : 	    else if (xmlStrEqual(name, (const xmlChar *) "DOCTYPE"))

	push	OFFSET ??_C@_07JGKBCNAA@DOCTYPE@
	mov	edx, DWORD PTR _name$7[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN35@xmlParseSG

; 2374 :                 type = SGML_CATA_DOCTYPE;

	mov	DWORD PTR _type$6[ebp], 17		; 00000011H
	jmp	$LN28@xmlParseSG
$LN35@xmlParseSG:

; 2375 : 	    else if (xmlStrEqual(name, (const xmlChar *) "LINKTYPE"))

	push	OFFSET ??_C@_08PMANIKNM@LINKTYPE@
	mov	eax, DWORD PTR _name$7[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN37@xmlParseSG

; 2376 :                 type = SGML_CATA_LINKTYPE;

	mov	DWORD PTR _type$6[ebp], 18		; 00000012H
	jmp	$LN28@xmlParseSG
$LN37@xmlParseSG:

; 2377 : 	    else if (xmlStrEqual(name, (const xmlChar *) "NOTATION"))

	push	OFFSET ??_C@_08NCDGCBCC@NOTATION@
	mov	ecx, DWORD PTR _name$7[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN39@xmlParseSG

; 2378 :                 type = SGML_CATA_NOTATION;

	mov	DWORD PTR _type$6[ebp], 19		; 00000013H
	jmp	$LN28@xmlParseSG
$LN39@xmlParseSG:

; 2379 : 	    else if (xmlStrEqual(name, (const xmlChar *) "SGMLDECL"))

	push	OFFSET ??_C@_08DJOOGKO@SGMLDECL@
	mov	edx, DWORD PTR _name$7[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN41@xmlParseSG

; 2380 :                 type = SGML_CATA_SGMLDECL;

	mov	DWORD PTR _type$6[ebp], 24		; 00000018H
	jmp	$LN28@xmlParseSG
$LN41@xmlParseSG:

; 2381 : 	    else if (xmlStrEqual(name, (const xmlChar *) "DOCUMENT"))

	push	OFFSET ??_C@_08OLOPJDNG@DOCUMENT@
	mov	eax, DWORD PTR _name$7[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN43@xmlParseSG

; 2382 :                 type = SGML_CATA_DOCUMENT;

	mov	DWORD PTR _type$6[ebp], 23		; 00000017H
	jmp	$LN28@xmlParseSG
$LN43@xmlParseSG:

; 2383 : 	    else if (xmlStrEqual(name, (const xmlChar *) "CATALOG"))

	push	OFFSET ??_C@_07DIADFEPH@CATALOG@
	mov	ecx, DWORD PTR _name$7[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN45@xmlParseSG

; 2384 :                 type = SGML_CATA_CATALOG;

	mov	DWORD PTR _type$6[ebp], 22		; 00000016H
	jmp	$LN28@xmlParseSG
$LN45@xmlParseSG:

; 2385 : 	    else if (xmlStrEqual(name, (const xmlChar *) "BASE"))

	push	OFFSET ??_C@_04NLLCBHDK@BASE@
	mov	edx, DWORD PTR _name$7[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN47@xmlParseSG

; 2386 :                 type = SGML_CATA_BASE;

	mov	DWORD PTR _type$6[ebp], 21		; 00000015H
	jmp	SHORT $LN28@xmlParseSG
$LN47@xmlParseSG:

; 2387 : 	    else if (xmlStrEqual(name, (const xmlChar *) "OVERRIDE")) {

	push	OFFSET ??_C@_08ICLDDLKE@OVERRIDE@
	mov	eax, DWORD PTR _name$7[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN28@xmlParseSG

; 2388 : 		xmlFree(name);

	mov	esi, esp
	mov	ecx, DWORD PTR _name$7[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2389 : 		cur = xmlParseSGMLCatalogName(cur, &name);

	lea	edx, DWORD PTR _name$7[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlParseSGMLCatalogName
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 2390 : 		if (name == NULL) {

	cmp	DWORD PTR _name$7[ebp], 0
	jne	SHORT $LN50@xmlParseSG

; 2391 : 		    /* error */
; 2392 : 		    break;

	jmp	$LN3@xmlParseSG
$LN50@xmlParseSG:

; 2393 : 		}
; 2394 : 		xmlFree(name);

	mov	esi, esp
	mov	ecx, DWORD PTR _name$7[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2395 : 		continue;

	jmp	$LN2@xmlParseSG
$LN28@xmlParseSG:

; 2396 : 	    }
; 2397 : 	    xmlFree(name);

	mov	esi, esp
	mov	edx, DWORD PTR _name$7[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2398 : 	    name = NULL;

	mov	DWORD PTR _name$7[ebp], 0

; 2399 : 
; 2400 : 	    switch(type) {

	mov	eax, DWORD PTR _type$6[ebp]
	mov	DWORD PTR tv205[ebp], eax
	mov	ecx, DWORD PTR tv205[ebp]
	sub	ecx, 13					; 0000000dH
	mov	DWORD PTR tv205[ebp], ecx
	cmp	DWORD PTR tv205[ebp], 11		; 0000000bH
	ja	$LN8@xmlParseSG
	mov	edx, DWORD PTR tv205[ebp]
	movzx	eax, BYTE PTR $LN98@xmlParseSG[edx]
	jmp	DWORD PTR $LN103@xmlParseSG[eax*4]
$LN51@xmlParseSG:

; 2401 : 		case SGML_CATA_ENTITY:
; 2402 : 		    if (*cur == '%')

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 37					; 00000025H
	jne	SHORT $LN53@xmlParseSG

; 2403 : 			type = SGML_CATA_PENTITY;

	mov	DWORD PTR _type$6[ebp], 16		; 00000010H
$LN53@xmlParseSG:

; 2404 :                     /* Falls through. */
; 2405 : 		case SGML_CATA_PENTITY:
; 2406 : 		case SGML_CATA_DOCTYPE:
; 2407 : 		case SGML_CATA_LINKTYPE:
; 2408 : 		case SGML_CATA_NOTATION:
; 2409 : 		    cur = xmlParseSGMLCatalogName(cur, &name);

	lea	eax, DWORD PTR _name$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlParseSGMLCatalogName
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 2410 : 		    if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN54@xmlParseSG

; 2411 : 			/* error */
; 2412 : 			break;

	jmp	$LN8@xmlParseSG
$LN54@xmlParseSG:

; 2413 : 		    }
; 2414 : 		    if (!IS_BLANK_CH(*cur)) {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN10@xmlParseSG
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN56@xmlParseSG
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN10@xmlParseSG
$LN56@xmlParseSG:
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN10@xmlParseSG

; 2415 : 			/* error */
; 2416 : 			break;

	jmp	$LN8@xmlParseSG
$LN10@xmlParseSG:

; 2417 : 		    }
; 2418 : 		    SKIP_BLANKS;

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN57@xmlParseSG
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN58@xmlParseSG
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN57@xmlParseSG
$LN58@xmlParseSG:
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN11@xmlParseSG
$LN57@xmlParseSG:
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN10@xmlParseSG
$LN11@xmlParseSG:

; 2419 : 		    cur = xmlParseSGMLCatalogPubid(cur, &sysid);

	lea	ecx, DWORD PTR _sysid$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlParseSGMLCatalogPubid
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 2420 : 		    if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN59@xmlParseSG

; 2421 : 			/* error */
; 2422 : 			break;

	jmp	$LN8@xmlParseSG
$LN59@xmlParseSG:

; 2423 : 		    }
; 2424 : 		    break;

	jmp	$LN8@xmlParseSG
$LN60@xmlParseSG:

; 2425 : 		case SGML_CATA_PUBLIC:
; 2426 : 		case SGML_CATA_SYSTEM:
; 2427 : 		case SGML_CATA_DELEGATE:
; 2428 : 		    cur = xmlParseSGMLCatalogPubid(cur, &name);

	lea	eax, DWORD PTR _name$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlParseSGMLCatalogPubid
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 2429 : 		    if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN61@xmlParseSG

; 2430 : 			/* error */
; 2431 : 			break;

	jmp	$LN8@xmlParseSG
$LN61@xmlParseSG:

; 2432 : 		    }
; 2433 : 		    if (type != SGML_CATA_SYSTEM) {

	cmp	DWORD PTR _type$6[ebp], 13		; 0000000dH
	je	SHORT $LN62@xmlParseSG

; 2434 : 		        xmlChar *normid;
; 2435 : 
; 2436 : 		        normid = xmlCatalogNormalizePublic(name);

	mov	edx, DWORD PTR _name$7[ebp]
	push	edx
	call	_xmlCatalogNormalizePublic
	add	esp, 4
	mov	DWORD PTR _normid$5[ebp], eax

; 2437 : 		        if (normid != NULL) {

	cmp	DWORD PTR _normid$5[ebp], 0
	je	SHORT $LN62@xmlParseSG

; 2438 : 		            if (name != NULL)

	cmp	DWORD PTR _name$7[ebp], 0
	je	SHORT $LN64@xmlParseSG

; 2439 : 		                xmlFree(name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$7[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN64@xmlParseSG:

; 2440 : 		            if (*normid != 0)

	mov	ecx, DWORD PTR _normid$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN65@xmlParseSG

; 2441 : 		                name = normid;

	mov	eax, DWORD PTR _normid$5[ebp]
	mov	DWORD PTR _name$7[ebp], eax
	jmp	SHORT $LN62@xmlParseSG
$LN65@xmlParseSG:

; 2442 : 		            else {
; 2443 : 		                xmlFree(normid);

	mov	esi, esp
	mov	ecx, DWORD PTR _normid$5[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2444 : 		                name = NULL;

	mov	DWORD PTR _name$7[ebp], 0
$LN62@xmlParseSG:

; 2445 : 		            }
; 2446 : 		        }
; 2447 : 		    }
; 2448 : 		    if (!IS_BLANK_CH(*cur)) {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN12@xmlParseSG
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN68@xmlParseSG
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN12@xmlParseSG
$LN68@xmlParseSG:
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN12@xmlParseSG

; 2449 : 			/* error */
; 2450 : 			break;

	jmp	SHORT $LN8@xmlParseSG
$LN12@xmlParseSG:

; 2451 : 		    }
; 2452 : 		    SKIP_BLANKS;

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN69@xmlParseSG
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN70@xmlParseSG
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN69@xmlParseSG
$LN70@xmlParseSG:
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN13@xmlParseSG
$LN69@xmlParseSG:
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN12@xmlParseSG
$LN13@xmlParseSG:

; 2453 : 		    cur = xmlParseSGMLCatalogPubid(cur, &sysid);

	lea	ecx, DWORD PTR _sysid$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlParseSGMLCatalogPubid
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 2454 : 		    if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN71@xmlParseSG

; 2455 : 			/* error */
; 2456 : 			break;

	jmp	SHORT $LN8@xmlParseSG
$LN71@xmlParseSG:

; 2457 : 		    }
; 2458 : 		    break;

	jmp	SHORT $LN8@xmlParseSG
$LN72@xmlParseSG:

; 2459 : 		case SGML_CATA_BASE:
; 2460 : 		case SGML_CATA_CATALOG:
; 2461 : 		case SGML_CATA_DOCUMENT:
; 2462 : 		case SGML_CATA_SGMLDECL:
; 2463 : 		    cur = xmlParseSGMLCatalogPubid(cur, &sysid);

	lea	eax, DWORD PTR _sysid$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlParseSGMLCatalogPubid
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$LN8@xmlParseSG:

; 2464 : 		    if (cur == NULL) {
; 2465 : 			/* error */
; 2466 : 			break;
; 2467 : 		    }
; 2468 : 		    break;
; 2469 : 		default:
; 2470 : 		    break;
; 2471 : 	    }
; 2472 : 	    if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN75@xmlParseSG

; 2473 : 		if (name != NULL)

	cmp	DWORD PTR _name$7[ebp], 0
	je	SHORT $LN77@xmlParseSG

; 2474 : 		    xmlFree(name);

	mov	esi, esp
	mov	edx, DWORD PTR _name$7[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN77@xmlParseSG:

; 2475 : 		if (sysid != NULL)

	cmp	DWORD PTR _sysid$8[ebp], 0
	je	SHORT $LN78@xmlParseSG

; 2476 : 		    xmlFree(sysid);

	mov	esi, esp
	mov	eax, DWORD PTR _sysid$8[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN78@xmlParseSG:

; 2477 : 		break;

	jmp	$LN3@xmlParseSG
	jmp	$LN76@xmlParseSG
$LN75@xmlParseSG:

; 2478 : 	    } else if (type == SGML_CATA_BASE) {

	cmp	DWORD PTR _type$6[ebp], 21		; 00000015H
	jne	SHORT $LN79@xmlParseSG

; 2479 : 		if (base != NULL)

	cmp	DWORD PTR _base$[ebp], 0
	je	SHORT $LN81@xmlParseSG

; 2480 : 		    xmlFree(base);

	mov	esi, esp
	mov	ecx, DWORD PTR _base$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN81@xmlParseSG:

; 2481 : 		base = xmlStrdup(sysid);

	mov	edx, DWORD PTR _sysid$8[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _base$[ebp], eax
	jmp	$LN76@xmlParseSG
$LN79@xmlParseSG:

; 2482 : 	    } else if ((type == SGML_CATA_PUBLIC) ||

	cmp	DWORD PTR _type$6[ebp], 14		; 0000000eH
	je	SHORT $LN84@xmlParseSG
	cmp	DWORD PTR _type$6[ebp], 13		; 0000000dH
	jne	SHORT $LN82@xmlParseSG
$LN84@xmlParseSG:

; 2483 : 		       (type == SGML_CATA_SYSTEM)) {
; 2484 : 		xmlChar *filename;
; 2485 : 
; 2486 : 		filename = xmlBuildURI(sysid, base);

	mov	eax, DWORD PTR _base$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sysid$8[ebp]
	push	ecx
	call	_xmlBuildURI
	add	esp, 8
	mov	DWORD PTR _filename$4[ebp], eax

; 2487 : 		if (filename != NULL) {

	cmp	DWORD PTR _filename$4[ebp], 0
	je	SHORT $LN85@xmlParseSG

; 2488 : 		    xmlCatalogEntryPtr entry;
; 2489 : 
; 2490 : 		    entry = xmlNewCatalogEntry(type, name, filename,

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _filename$4[ebp]
	push	edx
	mov	eax, DWORD PTR _name$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$6[ebp]
	push	ecx
	call	_xmlNewCatalogEntry
	add	esp, 24					; 00000018H
	mov	DWORD PTR _entry$3[ebp], eax

; 2491 : 			                       NULL, XML_CATA_PREFER_NONE, NULL);
; 2492 : 		    res = xmlHashAddEntry(catal->sgml, name, entry);

	mov	edx, DWORD PTR _entry$3[ebp]
	push	edx
	mov	eax, DWORD PTR _name$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_xmlHashAddEntry
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _res$[ebp], eax

; 2493 : 		    if (res < 0) {

	cmp	DWORD PTR _res$[ebp], 0
	jge	SHORT $LN86@xmlParseSG

; 2494 : 			xmlFreeCatalogEntry(entry, NULL);

	push	0
	mov	eax, DWORD PTR _entry$3[ebp]
	push	eax
	call	_xmlFreeCatalogEntry
	add	esp, 8
$LN86@xmlParseSG:

; 2495 : 		    }
; 2496 : 		    xmlFree(filename);

	mov	esi, esp
	mov	ecx, DWORD PTR _filename$4[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN85@xmlParseSG:

; 2497 : 		}

	jmp	$LN76@xmlParseSG
$LN82@xmlParseSG:

; 2498 : 
; 2499 : 	    } else if (type == SGML_CATA_CATALOG) {

	cmp	DWORD PTR _type$6[ebp], 22		; 00000016H
	jne	$LN76@xmlParseSG

; 2500 : 		if (super) {

	cmp	DWORD PTR _super$[ebp], 0
	je	SHORT $LN88@xmlParseSG

; 2501 : 		    xmlCatalogEntryPtr entry;
; 2502 : 
; 2503 : 		    entry = xmlNewCatalogEntry(type, sysid, NULL, NULL,

	push	0
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _sysid$8[ebp]
	push	edx
	mov	eax, DWORD PTR _type$6[ebp]
	push	eax
	call	_xmlNewCatalogEntry
	add	esp, 24					; 00000018H
	mov	DWORD PTR _entry$2[ebp], eax

; 2504 : 			                       XML_CATA_PREFER_NONE, NULL);
; 2505 : 		    res = xmlHashAddEntry(catal->sgml, sysid, entry);

	mov	ecx, DWORD PTR _entry$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _sysid$8[ebp]
	push	edx
	mov	eax, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	_xmlHashAddEntry
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _res$[ebp], eax

; 2506 : 		    if (res < 0) {

	cmp	DWORD PTR _res$[ebp], 0
	jge	SHORT $LN90@xmlParseSG

; 2507 : 			xmlFreeCatalogEntry(entry, NULL);

	push	0
	mov	edx, DWORD PTR _entry$2[ebp]
	push	edx
	call	_xmlFreeCatalogEntry
	add	esp, 8
$LN90@xmlParseSG:

; 2508 : 		    }
; 2509 : 		} else {

	jmp	SHORT $LN76@xmlParseSG
$LN88@xmlParseSG:

; 2510 : 		    xmlChar *filename;
; 2511 : 
; 2512 : 		    filename = xmlBuildURI(sysid, base);

	mov	eax, DWORD PTR _base$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sysid$8[ebp]
	push	ecx
	call	_xmlBuildURI
	add	esp, 8
	mov	DWORD PTR _filename$1[ebp], eax

; 2513 : 		    if (filename != NULL) {

	cmp	DWORD PTR _filename$1[ebp], 0
	je	SHORT $LN76@xmlParseSG

; 2514 : 			xmlExpandCatalog(catal, (const char *)filename);

	mov	edx, DWORD PTR _filename$1[ebp]
	push	edx
	mov	eax, DWORD PTR _catal$[ebp]
	push	eax
	call	_xmlExpandCatalog
	add	esp, 8

; 2515 : 			xmlFree(filename);

	mov	esi, esp
	mov	ecx, DWORD PTR _filename$1[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN76@xmlParseSG:

; 2516 : 		    }
; 2517 : 		}
; 2518 : 	    }
; 2519 : 	    /*
; 2520 : 	     * drop anything else we won't handle it
; 2521 : 	     */
; 2522 : 	    if (name != NULL)

	cmp	DWORD PTR _name$7[ebp], 0
	je	SHORT $LN92@xmlParseSG

; 2523 : 		xmlFree(name);

	mov	esi, esp
	mov	edx, DWORD PTR _name$7[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN92@xmlParseSG:

; 2524 : 	    if (sysid != NULL)

	cmp	DWORD PTR _sysid$8[ebp], 0
	je	SHORT $LN20@xmlParseSG

; 2525 : 		xmlFree(sysid);

	mov	esi, esp
	mov	eax, DWORD PTR _sysid$8[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN20@xmlParseSG:

; 2526 : 	}
; 2527 :     }

	jmp	$LN2@xmlParseSG
$LN3@xmlParseSG:

; 2528 :     if (base != NULL)

	cmp	DWORD PTR _base$[ebp], 0
	je	SHORT $LN94@xmlParseSG

; 2529 : 	xmlFree(base);

	mov	esi, esp
	mov	ecx, DWORD PTR _base$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN94@xmlParseSG:

; 2530 :     if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN95@xmlParseSG

; 2531 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlParseSG
$LN95@xmlParseSG:

; 2532 :     return(0);

	xor	eax, eax
$LN1@xmlParseSG:

; 2533 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN102@xmlParseSG
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN102@xmlParseSG:
	DD	2
	DD	$LN101@xmlParseSG
$LN101@xmlParseSG:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN99@xmlParseSG
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN100@xmlParseSG
$LN100@xmlParseSG:
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$LN99@xmlParseSG:
	DB	115					; 00000073H
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
	npad	1
$LN103@xmlParseSG:
	DD	$LN60@xmlParseSG
	DD	$LN51@xmlParseSG
	DD	$LN53@xmlParseSG
	DD	$LN72@xmlParseSG
$LN98@xmlParseSG:
	DB	0
	DB	0
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
_xmlParseSGMLCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlGetSGMLCatalogEntryType
_TEXT	SEGMENT
_type$ = -4						; size = 4
_name$ = 8						; size = 4
_xmlGetSGMLCatalogEntryType PROC			; COMDAT

; 2289 : xmlGetSGMLCatalogEntryType(const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2290 :     xmlCatalogEntryType type = XML_CATA_NONE;

	mov	DWORD PTR _type$[ebp], 0

; 2291 :     if (xmlStrEqual(name, (const xmlChar *) "SYSTEM"))

	push	OFFSET ??_C@_06FDHFNJBJ@SYSTEM@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@xmlGetSGML

; 2292 : 	type = SGML_CATA_SYSTEM;

	mov	DWORD PTR _type$[ebp], 13		; 0000000dH
	jmp	$LN3@xmlGetSGML
$LN2@xmlGetSGML:

; 2293 :     else if (xmlStrEqual(name, (const xmlChar *) "PUBLIC"))

	push	OFFSET ??_C@_06EKOLBGFH@PUBLIC@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@xmlGetSGML

; 2294 : 	type = SGML_CATA_PUBLIC;

	mov	DWORD PTR _type$[ebp], 14		; 0000000eH
	jmp	$LN3@xmlGetSGML
$LN4@xmlGetSGML:

; 2295 :     else if (xmlStrEqual(name, (const xmlChar *) "DELEGATE"))

	push	OFFSET ??_C@_08IALHHCM@DELEGATE@
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlGetSGML

; 2296 : 	type = SGML_CATA_DELEGATE;

	mov	DWORD PTR _type$[ebp], 20		; 00000014H
	jmp	$LN3@xmlGetSGML
$LN6@xmlGetSGML:

; 2297 :     else if (xmlStrEqual(name, (const xmlChar *) "ENTITY"))

	push	OFFSET ??_C@_06GKLBAPIO@ENTITY@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlGetSGML

; 2298 : 	type = SGML_CATA_ENTITY;

	mov	DWORD PTR _type$[ebp], 15		; 0000000fH
	jmp	$LN3@xmlGetSGML
$LN8@xmlGetSGML:

; 2299 :     else if (xmlStrEqual(name, (const xmlChar *) "DOCTYPE"))

	push	OFFSET ??_C@_07JGKBCNAA@DOCTYPE@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlGetSGML

; 2300 : 	type = SGML_CATA_DOCTYPE;

	mov	DWORD PTR _type$[ebp], 17		; 00000011H
	jmp	$LN3@xmlGetSGML
$LN10@xmlGetSGML:

; 2301 :     else if (xmlStrEqual(name, (const xmlChar *) "LINKTYPE"))

	push	OFFSET ??_C@_08PMANIKNM@LINKTYPE@
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlGetSGML

; 2302 : 	type = SGML_CATA_LINKTYPE;

	mov	DWORD PTR _type$[ebp], 18		; 00000012H
	jmp	$LN3@xmlGetSGML
$LN12@xmlGetSGML:

; 2303 :     else if (xmlStrEqual(name, (const xmlChar *) "NOTATION"))

	push	OFFSET ??_C@_08NCDGCBCC@NOTATION@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlGetSGML

; 2304 : 	type = SGML_CATA_NOTATION;

	mov	DWORD PTR _type$[ebp], 19		; 00000013H
	jmp	SHORT $LN3@xmlGetSGML
$LN14@xmlGetSGML:

; 2305 :     else if (xmlStrEqual(name, (const xmlChar *) "SGMLDECL"))

	push	OFFSET ??_C@_08DJOOGKO@SGMLDECL@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlGetSGML

; 2306 : 	type = SGML_CATA_SGMLDECL;

	mov	DWORD PTR _type$[ebp], 24		; 00000018H
	jmp	SHORT $LN3@xmlGetSGML
$LN16@xmlGetSGML:

; 2307 :     else if (xmlStrEqual(name, (const xmlChar *) "DOCUMENT"))

	push	OFFSET ??_C@_08OLOPJDNG@DOCUMENT@
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlGetSGML

; 2308 : 	type = SGML_CATA_DOCUMENT;

	mov	DWORD PTR _type$[ebp], 23		; 00000017H
	jmp	SHORT $LN3@xmlGetSGML
$LN18@xmlGetSGML:

; 2309 :     else if (xmlStrEqual(name, (const xmlChar *) "CATALOG"))

	push	OFFSET ??_C@_07DIADFEPH@CATALOG@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlGetSGML

; 2310 : 	type = SGML_CATA_CATALOG;

	mov	DWORD PTR _type$[ebp], 22		; 00000016H
	jmp	SHORT $LN3@xmlGetSGML
$LN20@xmlGetSGML:

; 2311 :     else if (xmlStrEqual(name, (const xmlChar *) "BASE"))

	push	OFFSET ??_C@_04NLLCBHDK@BASE@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@xmlGetSGML

; 2312 : 	type = SGML_CATA_BASE;

	mov	DWORD PTR _type$[ebp], 21		; 00000015H
$LN3@xmlGetSGML:

; 2313 :     return(type);

	mov	eax, DWORD PTR _type$[ebp]

; 2314 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlGetSGMLCatalogEntryType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseSGMLCatalogName
_TEXT	SEGMENT
tv156 = -164						; size = 4
tv155 = -160						; size = 4
tv146 = -156						; size = 4
tv147 = -152						; size = 4
tv138 = -148						; size = 4
tv137 = -144						; size = 4
tv87 = -140						; size = 4
tv88 = -136						; size = 4
tv79 = -132						; size = 4
tv78 = -128						; size = 4
_c$ = -124						; size = 4
_len$ = -120						; size = 4
_buf$ = -112						; size = 105
_cur$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlParseSGMLCatalogName PROC				; COMDAT

; 2252 : xmlParseSGMLCatalogName(const xmlChar *cur, xmlChar **name) {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	push	edi
	lea	edi, DWORD PTR [ebp-164]
	mov	ecx, 41					; 00000029H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2253 :     xmlChar buf[XML_MAX_NAMELEN + 5];
; 2254 :     int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 2255 :     int c;
; 2256 : 
; 2257 :     *name = NULL;

	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR [eax], 0

; 2258 : 
; 2259 :     /*
; 2260 :      * Handler for more complex cases
; 2261 :      */
; 2262 :     c = *cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _c$[ebp], edx

; 2263 :     if ((!IS_LETTER(c) && (c != '_') && (c != ':'))) {

	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN14@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 65			; 00000041H
	jl	SHORT $LN8@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 90			; 0000005aH
	jle	SHORT $LN10@xmlParseSG
$LN8@xmlParseSG:
	cmp	DWORD PTR _c$[ebp], 97			; 00000061H
	jl	SHORT $LN9@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 122			; 0000007aH
	jle	SHORT $LN10@xmlParseSG
$LN9@xmlParseSG:
	cmp	DWORD PTR _c$[ebp], 192			; 000000c0H
	jl	SHORT $LN11@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 214			; 000000d6H
	jle	SHORT $LN10@xmlParseSG
$LN11@xmlParseSG:
	cmp	DWORD PTR _c$[ebp], 216			; 000000d8H
	jl	SHORT $LN12@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 246			; 000000f6H
	jle	SHORT $LN10@xmlParseSG
$LN12@xmlParseSG:
	cmp	DWORD PTR _c$[ebp], 248			; 000000f8H
	jge	SHORT $LN10@xmlParseSG
	mov	DWORD PTR tv78[ebp], 0
	jmp	SHORT $LN13@xmlParseSG
$LN10@xmlParseSG:
	mov	DWORD PTR tv78[ebp], 1
$LN13@xmlParseSG:
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN15@xmlParseSG
$LN14@xmlParseSG:
	push	OFFSET _xmlIsBaseCharGroup
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv79[ebp], eax
$LN15@xmlParseSG:
	cmp	DWORD PTR tv79[ebp], 0
	jne	$LN2@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN20@xmlParseSG
	mov	DWORD PTR tv88[ebp], 0
	jmp	SHORT $LN21@xmlParseSG
$LN20@xmlParseSG:
	cmp	DWORD PTR _c$[ebp], 19968		; 00004e00H
	jl	SHORT $LN16@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 40869		; 00009fa5H
	jle	SHORT $LN17@xmlParseSG
$LN16@xmlParseSG:
	cmp	DWORD PTR _c$[ebp], 12295		; 00003007H
	je	SHORT $LN17@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 12321		; 00003021H
	jl	SHORT $LN18@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 12329		; 00003029H
	jle	SHORT $LN17@xmlParseSG
$LN18@xmlParseSG:
	mov	DWORD PTR tv87[ebp], 0
	jmp	SHORT $LN19@xmlParseSG
$LN17@xmlParseSG:
	mov	DWORD PTR tv87[ebp], 1
$LN19@xmlParseSG:
	mov	edx, DWORD PTR tv87[ebp]
	mov	DWORD PTR tv88[ebp], edx
$LN21@xmlParseSG:
	cmp	DWORD PTR tv88[ebp], 0
	jne	SHORT $LN2@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 95			; 0000005fH
	je	SHORT $LN2@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 58			; 0000003aH
	je	SHORT $LN2@xmlParseSG

; 2264 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSG
$LN2@xmlParseSG:

; 2265 :     }
; 2266 : 
; 2267 :     while (((IS_LETTER(c)) || (IS_DIGIT(c)) ||
; 2268 :             (c == '.') || (c == '-') ||
; 2269 : 	    (c == '_') || (c == ':'))) {

	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN28@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 65			; 00000041H
	jl	SHORT $LN22@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 90			; 0000005aH
	jle	SHORT $LN24@xmlParseSG
$LN22@xmlParseSG:
	cmp	DWORD PTR _c$[ebp], 97			; 00000061H
	jl	SHORT $LN23@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 122			; 0000007aH
	jle	SHORT $LN24@xmlParseSG
$LN23@xmlParseSG:
	cmp	DWORD PTR _c$[ebp], 192			; 000000c0H
	jl	SHORT $LN25@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 214			; 000000d6H
	jle	SHORT $LN24@xmlParseSG
$LN25@xmlParseSG:
	cmp	DWORD PTR _c$[ebp], 216			; 000000d8H
	jl	SHORT $LN26@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 246			; 000000f6H
	jle	SHORT $LN24@xmlParseSG
$LN26@xmlParseSG:
	cmp	DWORD PTR _c$[ebp], 248			; 000000f8H
	jge	SHORT $LN24@xmlParseSG
	mov	DWORD PTR tv137[ebp], 0
	jmp	SHORT $LN27@xmlParseSG
$LN24@xmlParseSG:
	mov	DWORD PTR tv137[ebp], 1
$LN27@xmlParseSG:
	mov	eax, DWORD PTR tv137[ebp]
	mov	DWORD PTR tv138[ebp], eax
	jmp	SHORT $LN29@xmlParseSG
$LN28@xmlParseSG:
	push	OFFSET _xmlIsBaseCharGroup
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv138[ebp], eax
$LN29@xmlParseSG:
	cmp	DWORD PTR tv138[ebp], 0
	jne	$LN5@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN34@xmlParseSG
	mov	DWORD PTR tv147[ebp], 0
	jmp	SHORT $LN35@xmlParseSG
$LN34@xmlParseSG:
	cmp	DWORD PTR _c$[ebp], 19968		; 00004e00H
	jl	SHORT $LN30@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 40869		; 00009fa5H
	jle	SHORT $LN31@xmlParseSG
$LN30@xmlParseSG:
	cmp	DWORD PTR _c$[ebp], 12295		; 00003007H
	je	SHORT $LN31@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 12321		; 00003021H
	jl	SHORT $LN32@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 12329		; 00003029H
	jle	SHORT $LN31@xmlParseSG
$LN32@xmlParseSG:
	mov	DWORD PTR tv146[ebp], 0
	jmp	SHORT $LN33@xmlParseSG
$LN31@xmlParseSG:
	mov	DWORD PTR tv146[ebp], 1
$LN33@xmlParseSG:
	mov	edx, DWORD PTR tv146[ebp]
	mov	DWORD PTR tv147[ebp], edx
$LN35@xmlParseSG:
	cmp	DWORD PTR tv147[ebp], 0
	jne	SHORT $LN5@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN38@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 48			; 00000030H
	jl	SHORT $LN36@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 57			; 00000039H
	jg	SHORT $LN36@xmlParseSG
	mov	DWORD PTR tv155[ebp], 1
	jmp	SHORT $LN37@xmlParseSG
$LN36@xmlParseSG:
	mov	DWORD PTR tv155[ebp], 0
$LN37@xmlParseSG:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR tv156[ebp], eax
	jmp	SHORT $LN39@xmlParseSG
$LN38@xmlParseSG:
	push	OFFSET _xmlIsDigitGroup
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv156[ebp], eax
$LN39@xmlParseSG:
	cmp	DWORD PTR tv156[ebp], 0
	jne	SHORT $LN5@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 46			; 0000002eH
	je	SHORT $LN5@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 45			; 0000002dH
	je	SHORT $LN5@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 95			; 0000005fH
	je	SHORT $LN5@xmlParseSG
	cmp	DWORD PTR _c$[ebp], 58			; 0000003aH
	jne	SHORT $LN3@xmlParseSG
$LN5@xmlParseSG:

; 2270 : 	buf[len++] = c;

	mov	edx, DWORD PTR _len$[ebp]
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR _buf$[ebp+edx], al
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 2271 : 	cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 2272 : 	c = *cur;

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx

; 2273 : 	if (len >= XML_MAX_NAMELEN)

	cmp	DWORD PTR _len$[ebp], 100		; 00000064H
	jl	SHORT $LN6@xmlParseSG

; 2274 : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseSG
$LN6@xmlParseSG:

; 2275 :     }

	jmp	$LN2@xmlParseSG
$LN3@xmlParseSG:

; 2276 :     *name = xmlStrndup(buf, len);

	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlStrndup
	add	esp, 8
	mov	ecx, DWORD PTR _name$[ebp]
	mov	DWORD PTR [ecx], eax

; 2277 :     return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
$LN1@xmlParseSG:

; 2278 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN42@xmlParseSG
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 164				; 000000a4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN42@xmlParseSG:
	DD	1
	DD	$LN41@xmlParseSG
$LN41@xmlParseSG:
	DD	-112					; ffffff90H
	DD	105					; 00000069H
	DD	$LN40@xmlParseSG
$LN40@xmlParseSG:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_xmlParseSGMLCatalogName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseSGMLCatalogPubid
_TEXT	SEGMENT
_count$ = -24						; size = 4
_stop$ = -17						; size = 1
_size$ = -16						; size = 4
_len$ = -12						; size = 4
_tmp$ = -8						; size = 4
_buf$ = -4						; size = 4
_cur$ = 8						; size = 4
_id$ = 12						; size = 4
_xmlParseSGMLCatalogPubid PROC				; COMDAT

; 2183 : xmlParseSGMLCatalogPubid(const xmlChar *cur, xmlChar **id) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2184 :     xmlChar *buf = NULL, *tmp;

	mov	DWORD PTR _buf$[ebp], 0

; 2185 :     int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 2186 :     int size = 50;

	mov	DWORD PTR _size$[ebp], 50		; 00000032H

; 2187 :     xmlChar stop;
; 2188 :     int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 2189 : 
; 2190 :     *id = NULL;

	mov	eax, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax], 0

; 2191 : 
; 2192 :     if (RAW == '"') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 34					; 00000022H
	jne	SHORT $LN4@xmlParseSG

; 2193 :         NEXT;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 2194 : 	stop = '"';

	mov	BYTE PTR _stop$[ebp], 34		; 00000022H
	jmp	SHORT $LN5@xmlParseSG
$LN4@xmlParseSG:

; 2195 :     } else if (RAW == '\'') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 39					; 00000027H
	jne	SHORT $LN6@xmlParseSG

; 2196 :         NEXT;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 2197 : 	stop = '\'';

	mov	BYTE PTR _stop$[ebp], 39		; 00000027H

; 2198 :     } else {

	jmp	SHORT $LN5@xmlParseSG
$LN6@xmlParseSG:

; 2199 : 	stop = ' ';

	mov	BYTE PTR _stop$[ebp], 32		; 00000020H
$LN5@xmlParseSG:

; 2200 :     }
; 2201 :     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	mov	esi, esp
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buf$[ebp], eax

; 2202 :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN2@xmlParseSG

; 2203 :         xmlCatalogErrMemory("allocating public ID");

	push	OFFSET ??_C@_0BF@DLNFLLPI@allocating?5public?5ID@
	call	_xmlCatalogErrMemory
	add	esp, 4

; 2204 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSG
$LN2@xmlParseSG:

; 2205 :     }
; 2206 :     while (IS_PUBIDCHAR_CH(*cur) || (*cur == '?')) {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	movzx	ecx, BYTE PTR _xmlIsPubidChar_tab[eax]
	test	ecx, ecx
	jne	SHORT $LN9@xmlParseSG
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 63					; 0000003fH
	jne	$LN3@xmlParseSG
$LN9@xmlParseSG:

; 2207 : 	if ((*cur == stop) && (stop != ' '))

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	eax, BYTE PTR _stop$[ebp]
	cmp	edx, eax
	jne	SHORT $LN10@xmlParseSG
	movzx	ecx, BYTE PTR _stop$[ebp]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN10@xmlParseSG

; 2208 : 	    break;

	jmp	$LN3@xmlParseSG
$LN10@xmlParseSG:

; 2209 : 	if ((stop == ' ') && (IS_BLANK_CH(*cur)))

	movzx	edx, BYTE PTR _stop$[ebp]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN11@xmlParseSG
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN12@xmlParseSG
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN13@xmlParseSG
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN12@xmlParseSG
$LN13@xmlParseSG:
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN11@xmlParseSG
$LN12@xmlParseSG:

; 2210 : 	    break;

	jmp	$LN3@xmlParseSG
$LN11@xmlParseSG:

; 2211 : 	if (len + 1 >= size) {

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	cmp	edx, DWORD PTR _size$[ebp]
	jl	SHORT $LN14@xmlParseSG

; 2212 : 	    size *= 2;

	mov	eax, DWORD PTR _size$[ebp]
	shl	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 2213 : 	    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));

	mov	esi, esp
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$[ebp], eax

; 2214 : 	    if (tmp == NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN15@xmlParseSG

; 2215 : 		xmlCatalogErrMemory("allocating public ID");

	push	OFFSET ??_C@_0BF@DLNFLLPI@allocating?5public?5ID@
	call	_xmlCatalogErrMemory
	add	esp, 4

; 2216 : 		xmlFree(buf);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2217 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSG
$LN15@xmlParseSG:

; 2218 : 	    }
; 2219 : 	    buf = tmp;

	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _buf$[ebp], ecx
$LN14@xmlParseSG:

; 2220 : 	}
; 2221 : 	buf[len++] = *cur;

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 2222 : 	count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 2223 : 	NEXT;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 2224 :     }

	jmp	$LN2@xmlParseSG
$LN3@xmlParseSG:

; 2225 :     buf[len] = 0;

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 0

; 2226 :     if (stop == ' ') {

	movzx	eax, BYTE PTR _stop$[ebp]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN16@xmlParseSG

; 2227 : 	if (!IS_BLANK_CH(*cur)) {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN18@xmlParseSG
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN19@xmlParseSG
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN18@xmlParseSG
$LN19@xmlParseSG:
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN18@xmlParseSG

; 2228 : 	    xmlFree(buf);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2229 : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseSG
$LN18@xmlParseSG:

; 2230 : 	}
; 2231 :     } else {

	jmp	SHORT $LN17@xmlParseSG
$LN16@xmlParseSG:

; 2232 : 	if (*cur != stop) {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	eax, BYTE PTR _stop$[ebp]
	cmp	edx, eax
	je	SHORT $LN20@xmlParseSG

; 2233 : 	    xmlFree(buf);

	mov	esi, esp
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2234 : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseSG
$LN20@xmlParseSG:

; 2235 : 	}
; 2236 : 	NEXT;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
$LN17@xmlParseSG:

; 2237 :     }
; 2238 :     *id = buf;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax], ecx

; 2239 :     return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
$LN1@xmlParseSG:

; 2240 : }

	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseSGMLCatalogPubid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseSGMLCatalogComment
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlParseSGMLCatalogComment PROC			; COMDAT

; 2161 : xmlParseSGMLCatalogComment(const xmlChar *cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2162 :     if ((cur[0] != '-') || (cur[1] != '-'))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN5@xmlParseSG
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN4@xmlParseSG
$LN5@xmlParseSG:

; 2163 : 	return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	jmp	SHORT $LN1@xmlParseSG
$LN4@xmlParseSG:

; 2164 :     SKIP(2);

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 2
	mov	DWORD PTR _cur$[ebp], ecx
$LN2@xmlParseSG:

; 2165 :     while ((cur[0] != 0) && ((cur[0] != '-') || ((cur[1] != '-'))))

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN3@xmlParseSG
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN6@xmlParseSG
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN3@xmlParseSG
$LN6@xmlParseSG:

; 2166 : 	NEXT;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	SHORT $LN2@xmlParseSG
$LN3@xmlParseSG:

; 2167 :     if (cur[0] == 0) {

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN7@xmlParseSG

; 2168 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseSG
$LN7@xmlParseSG:

; 2169 :     }
; 2170 :     return(cur + 2);

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 2
$LN1@xmlParseSG:

; 2171 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlParseSGMLCatalogComment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogXMLResolveURI
_TEXT	SEGMENT
tv78 = -248						; size = 4
_i$1 = -244						; size = 4
_nbList$2 = -240					; size = 4
_delegates$3 = -232					; size = 200
_len$ = -28						; size = 4
_lenrewrite$ = -24					; size = 4
_rewrite$ = -20						; size = 4
_haveNext$ = -16					; size = 4
_haveDelegate$ = -12					; size = 4
_cur$ = -8						; size = 4
_ret$ = -4						; size = 4
_catal$ = 8						; size = 4
_URI$ = 12						; size = 4
_xmlCatalogXMLResolveURI PROC				; COMDAT

; 1865 : xmlCatalogXMLResolveURI(xmlCatalogEntryPtr catal, const xmlChar *URI) {

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 1866 :     xmlChar *ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 1867 :     xmlCatalogEntryPtr cur;
; 1868 :     int haveDelegate = 0;

	mov	DWORD PTR _haveDelegate$[ebp], 0

; 1869 :     int haveNext = 0;

	mov	DWORD PTR _haveNext$[ebp], 0

; 1870 :     xmlCatalogEntryPtr rewrite = NULL;

	mov	DWORD PTR _rewrite$[ebp], 0

; 1871 :     int lenrewrite = 0, len;

	mov	DWORD PTR _lenrewrite$[ebp], 0

; 1872 : 
; 1873 :     if (catal == NULL)

	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN13@xmlCatalog

; 1874 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCatalog
$LN13@xmlCatalog:

; 1875 : 
; 1876 :     if (URI == NULL)

	cmp	DWORD PTR _URI$[ebp], 0
	jne	SHORT $LN14@xmlCatalog

; 1877 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCatalog
$LN14@xmlCatalog:

; 1878 : 
; 1879 :     if (catal->depth > MAX_CATAL_DEPTH) {

	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax+36], 50			; 00000032H
	jle	SHORT $LN15@xmlCatalog

; 1880 : 	xmlCatalogErr(catal, NULL, XML_CATALOG_RECURSION,

	push	0
	push	0
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	OFFSET ??_C@_0CC@DACKBEAO@Detected?5recursion?5in?5catalog?5?$CF@
	push	1654					; 00000676H
	push	0
	mov	eax, DWORD PTR _catal$[ebp]
	push	eax
	call	_xmlCatalogErr
	add	esp, 28					; 0000001cH

; 1881 : 		      "Detected recursion in catalog %s\n",
; 1882 : 		      catal->name, NULL, NULL);
; 1883 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCatalog
$LN15@xmlCatalog:

; 1884 :     }
; 1885 : 
; 1886 :     /*
; 1887 :      * First tries steps 2/ 3/ 4/ if a system ID is provided.
; 1888 :      */
; 1889 :     cur = catal;

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx

; 1890 :     haveDelegate = 0;

	mov	DWORD PTR _haveDelegate$[ebp], 0
$LN2@xmlCatalog:

; 1891 :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN3@xmlCatalog

; 1892 : 	switch (cur->type) {

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv78[ebp], eax
	mov	ecx, DWORD PTR tv78[ebp]
	sub	ecx, 3
	mov	DWORD PTR tv78[ebp], ecx
	cmp	DWORD PTR tv78[ebp], 9
	ja	$LN4@xmlCatalog
	mov	edx, DWORD PTR tv78[ebp]
	movzx	eax, BYTE PTR $LN45@xmlCatalog[edx]
	jmp	DWORD PTR $LN49@xmlCatalog[eax*4]
$LN16@xmlCatalog:

; 1893 : 	    case XML_CATA_URI:
; 1894 : 		if (xmlStrEqual(URI, cur->name)) {

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _URI$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlCatalog

; 1895 : 		    if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN18@xmlCatalog

; 1896 : 			xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	OFFSET ??_C@_0BE@BBLLMFBP@Found?5URI?5match?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@xmlCatalog:

; 1897 : 				"Found URI match %s\n", cur->name);
; 1898 : 		    return(xmlStrdup(cur->URL));

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	jmp	$LN1@xmlCatalog
$LN17@xmlCatalog:

; 1899 : 		}
; 1900 : 		break;

	jmp	SHORT $LN4@xmlCatalog
$LN19@xmlCatalog:

; 1901 : 	    case XML_CATA_REWRITE_URI:
; 1902 : 		len = xmlStrlen(cur->name);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 1903 : 		if ((len > lenrewrite) &&

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _lenrewrite$[ebp]
	jle	SHORT $LN20@xmlCatalog
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN20@xmlCatalog

; 1904 : 		    (!xmlStrncmp(URI, cur->name, len))) {
; 1905 : 		    lenrewrite = len;

	mov	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _lenrewrite$[ebp], edx

; 1906 : 		    rewrite = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _rewrite$[ebp], eax
$LN20@xmlCatalog:

; 1907 : 		}
; 1908 : 		break;

	jmp	SHORT $LN4@xmlCatalog
$LN21@xmlCatalog:

; 1909 : 	    case XML_CATA_DELEGATE_URI:
; 1910 : 		if (!xmlStrncmp(URI, cur->name, xmlStrlen(cur->name)))

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlStrlen
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _URI$[ebp]
	push	edx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN22@xmlCatalog

; 1911 : 		    haveDelegate++;

	mov	eax, DWORD PTR _haveDelegate$[ebp]
	add	eax, 1
	mov	DWORD PTR _haveDelegate$[ebp], eax
$LN22@xmlCatalog:

; 1912 : 		break;

	jmp	SHORT $LN4@xmlCatalog
$LN23@xmlCatalog:

; 1913 : 	    case XML_CATA_NEXT_CATALOG:
; 1914 : 		haveNext++;

	mov	ecx, DWORD PTR _haveNext$[ebp]
	add	ecx, 1
	mov	DWORD PTR _haveNext$[ebp], ecx
$LN4@xmlCatalog:

; 1915 : 		break;
; 1916 : 	    default:
; 1917 : 		break;
; 1918 : 	}
; 1919 : 	cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _cur$[ebp], eax

; 1920 :     }

	jmp	$LN2@xmlCatalog
$LN3@xmlCatalog:

; 1921 :     if (rewrite != NULL) {

	cmp	DWORD PTR _rewrite$[ebp], 0
	je	SHORT $LN25@xmlCatalog

; 1922 : 	if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN26@xmlCatalog

; 1923 : 	    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _rewrite$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	OFFSET ??_C@_0BJ@CPNLKDBD@Using?5rewriting?5rule?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN26@xmlCatalog:

; 1924 : 		    "Using rewriting rule %s\n", rewrite->name);
; 1925 : 	ret = xmlStrdup(rewrite->URL);

	mov	edx, DWORD PTR _rewrite$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 1926 : 	if (ret != NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN27@xmlCatalog

; 1927 : 	    ret = xmlStrcat(ret, &URI[lenrewrite]);

	mov	ecx, DWORD PTR _URI$[ebp]
	add	ecx, DWORD PTR _lenrewrite$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
$LN27@xmlCatalog:

; 1928 : 	return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlCatalog
$LN25@xmlCatalog:

; 1929 :     }
; 1930 :     if (haveDelegate) {

	cmp	DWORD PTR _haveDelegate$[ebp], 0
	je	$LN28@xmlCatalog

; 1931 : 	const xmlChar *delegates[MAX_DELEGATE];
; 1932 : 	int nbList = 0, i;

	mov	DWORD PTR _nbList$2[ebp], 0

; 1933 : 
; 1934 : 	/*
; 1935 : 	 * Assume the entries have been sorted by decreasing substring
; 1936 : 	 * matches when the list was produced.
; 1937 : 	 */
; 1938 : 	cur = catal;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	DWORD PTR _cur$[ebp], eax
$LN6@xmlCatalog:

; 1939 : 	while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN7@xmlCatalog

; 1940 : 	    if (((cur->type == XML_CATA_DELEGATE_SYSTEM) ||
; 1941 : 	         (cur->type == XML_CATA_DELEGATE_URI)) &&

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+12], 9
	je	SHORT $LN30@xmlCatalog
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+12], 12			; 0000000cH
	jne	$LN29@xmlCatalog
$LN30@xmlCatalog:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlStrlen
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN29@xmlCatalog

; 1942 : 		(!xmlStrncmp(URI, cur->name, xmlStrlen(cur->name)))) {
; 1943 : 		for (i = 0;i < nbList;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN10@xmlCatalog
$LN8@xmlCatalog:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN10@xmlCatalog:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _nbList$2[ebp]
	jge	SHORT $LN9@xmlCatalog

; 1944 : 		    if (xmlStrEqual(cur->URL, delegates[i]))

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR _delegates$3[ebp+ecx*4]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN31@xmlCatalog

; 1945 : 			break;

	jmp	SHORT $LN9@xmlCatalog
$LN31@xmlCatalog:
	jmp	SHORT $LN8@xmlCatalog
$LN9@xmlCatalog:

; 1946 : 		if (i < nbList) {

	mov	edx, DWORD PTR _i$1[ebp]
	cmp	edx, DWORD PTR _nbList$2[ebp]
	jge	SHORT $LN32@xmlCatalog

; 1947 : 		    cur = cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 1948 : 		    continue;

	jmp	$LN6@xmlCatalog
$LN32@xmlCatalog:

; 1949 : 		}
; 1950 : 		if (nbList < MAX_DELEGATE)

	cmp	DWORD PTR _nbList$2[ebp], 50		; 00000032H
	jge	SHORT $LN33@xmlCatalog

; 1951 : 		    delegates[nbList++] = cur->URL;

	mov	edx, DWORD PTR _nbList$2[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _delegates$3[ebp+edx*4], ecx
	mov	edx, DWORD PTR _nbList$2[ebp]
	add	edx, 1
	mov	DWORD PTR _nbList$2[ebp], edx
$LN33@xmlCatalog:

; 1952 : 
; 1953 : 		if (cur->children == NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN34@xmlCatalog

; 1954 : 		    xmlFetchXMLCatalogFile(cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlFetchXMLCatalogFile
	add	esp, 4
$LN34@xmlCatalog:

; 1955 : 		}
; 1956 : 		if (cur->children != NULL) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN29@xmlCatalog

; 1957 : 		    if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN36@xmlCatalog

; 1958 : 			xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	OFFSET ??_C@_0BI@FMDOMGLN@Trying?5URI?5delegate?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN36@xmlCatalog:

; 1959 : 				"Trying URI delegate %s\n", cur->URL);
; 1960 : 		    ret = xmlCatalogListXMLResolveURI(

	mov	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlCatalogListXMLResolveURI
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1961 : 			    cur->children, URI);
; 1962 : 		    if (ret != NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN29@xmlCatalog

; 1963 : 			return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlCatalog
$LN29@xmlCatalog:

; 1964 : 		}
; 1965 : 	    }
; 1966 : 	    cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 1967 : 	}

	jmp	$LN6@xmlCatalog
$LN7@xmlCatalog:

; 1968 : 	/*
; 1969 : 	 * Apply the cut algorithm explained in 4/
; 1970 : 	 */
; 1971 : 	return(XML_CATAL_BREAK);

	or	eax, -1
	jmp	SHORT $LN1@xmlCatalog
$LN28@xmlCatalog:

; 1972 :     }
; 1973 :     if (haveNext) {

	cmp	DWORD PTR _haveNext$[ebp], 0
	je	SHORT $LN38@xmlCatalog

; 1974 : 	cur = catal;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	DWORD PTR _cur$[ebp], eax
$LN11@xmlCatalog:

; 1975 : 	while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN38@xmlCatalog

; 1976 : 	    if (cur->type == XML_CATA_NEXT_CATALOG) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+12], 3
	jne	SHORT $LN39@xmlCatalog

; 1977 : 		if (cur->children == NULL) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN40@xmlCatalog

; 1978 : 		    xmlFetchXMLCatalogFile(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlFetchXMLCatalogFile
	add	esp, 4
$LN40@xmlCatalog:

; 1979 : 		}
; 1980 : 		if (cur->children != NULL) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN39@xmlCatalog

; 1981 : 		    ret = xmlCatalogListXMLResolveURI(cur->children, URI);

	mov	edx, DWORD PTR _URI$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlCatalogListXMLResolveURI
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1982 : 		    if (ret != NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN39@xmlCatalog

; 1983 : 			return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlCatalog
$LN39@xmlCatalog:

; 1984 : 		}
; 1985 : 	    }
; 1986 : 	    cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _cur$[ebp], eax

; 1987 : 	}

	jmp	SHORT $LN11@xmlCatalog
$LN38@xmlCatalog:

; 1988 :     }
; 1989 : 
; 1990 :     return(NULL);

	xor	eax, eax
$LN1@xmlCatalog:

; 1991 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN48@xmlCatalog
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@xmlCatalog:
	DD	1
	DD	$LN47@xmlCatalog
$LN47@xmlCatalog:
	DD	-232					; ffffff18H
	DD	200					; 000000c8H
	DD	$LN46@xmlCatalog
$LN46@xmlCatalog:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	103					; 00000067H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
	npad	2
$LN49@xmlCatalog:
	DD	$LN23@xmlCatalog
	DD	$LN16@xmlCatalog
	DD	$LN19@xmlCatalog
	DD	$LN21@xmlCatalog
	DD	$LN4@xmlCatalog
$LN45@xmlCatalog:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	3
_xmlCatalogXMLResolveURI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogXMLResolve
_TEXT	SEGMENT
tv239 = -468						; size = 4
tv81 = -464						; size = 4
_i$1 = -460						; size = 4
_nbList$2 = -456					; size = 4
_delegates$3 = -448					; size = 200
_i$4 = -244						; size = 4
_nbList$5 = -240					; size = 4
_delegates$6 = -232					; size = 200
_len$7 = -28						; size = 4
_lenrewrite$8 = -24					; size = 4
_rewrite$9 = -20					; size = 4
_haveNext$ = -16					; size = 4
_haveDelegate$ = -12					; size = 4
_cur$ = -8						; size = 4
_ret$ = -4						; size = 4
_catal$ = 8						; size = 4
_pubID$ = 12						; size = 4
_sysID$ = 16						; size = 4
_xmlCatalogXMLResolve PROC				; COMDAT

; 1633 : 	              const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	sub	esp, 468				; 000001d4H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-468]
	mov	ecx, 117				; 00000075H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 1634 :     xmlChar *ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 1635 :     xmlCatalogEntryPtr cur;
; 1636 :     int haveDelegate = 0;

	mov	DWORD PTR _haveDelegate$[ebp], 0

; 1637 :     int haveNext = 0;

	mov	DWORD PTR _haveNext$[ebp], 0

; 1638 : 
; 1639 :     /*
; 1640 :      * protection against loops
; 1641 :      */
; 1642 :     if (catal->depth > MAX_CATAL_DEPTH) {

	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax+36], 50			; 00000032H
	jle	SHORT $LN22@xmlCatalog

; 1643 : 	xmlCatalogErr(catal, NULL, XML_CATALOG_RECURSION,

	push	0
	push	0
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	OFFSET ??_C@_0CC@DACKBEAO@Detected?5recursion?5in?5catalog?5?$CF@
	push	1654					; 00000676H
	push	0
	mov	eax, DWORD PTR _catal$[ebp]
	push	eax
	call	_xmlCatalogErr
	add	esp, 28					; 0000001cH

; 1644 : 		      "Detected recursion in catalog %s\n",
; 1645 : 		      catal->name, NULL, NULL);
; 1646 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCatalog
$LN22@xmlCatalog:

; 1647 :     }
; 1648 :     catal->depth++;

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, 1
	mov	eax, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [eax+36], edx

; 1649 : 
; 1650 :     /*
; 1651 :      * First tries steps 2/ 3/ 4/ if a system ID is provided.
; 1652 :      */
; 1653 :     if (sysID != NULL) {

	cmp	DWORD PTR _sysID$[ebp], 0
	je	$LN23@xmlCatalog

; 1654 : 	xmlCatalogEntryPtr rewrite = NULL;

	mov	DWORD PTR _rewrite$9[ebp], 0

; 1655 : 	int lenrewrite = 0, len;

	mov	DWORD PTR _lenrewrite$8[ebp], 0

; 1656 : 	cur = catal;

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx

; 1657 : 	haveDelegate = 0;

	mov	DWORD PTR _haveDelegate$[ebp], 0
$LN2@xmlCatalog:

; 1658 : 	while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN3@xmlCatalog

; 1659 : 	    switch (cur->type) {

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv81[ebp], eax
	mov	ecx, DWORD PTR tv81[ebp]
	sub	ecx, 3
	mov	DWORD PTR tv81[ebp], ecx
	cmp	DWORD PTR tv81[ebp], 6
	ja	$LN4@xmlCatalog
	mov	edx, DWORD PTR tv81[ebp]
	jmp	DWORD PTR $LN77@xmlCatalog[edx*4]
$LN24@xmlCatalog:

; 1660 : 		case XML_CATA_SYSTEM:
; 1661 : 		    if (xmlStrEqual(sysID, cur->name)) {

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _sysID$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlCatalog

; 1662 : 			if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN26@xmlCatalog

; 1663 : 			    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	OFFSET ??_C@_0CB@ONCPCECG@Found?5system?5match?5?$CFs?0?5using?5?$CFs@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN26@xmlCatalog:

; 1664 : 				    "Found system match %s, using %s\n",
; 1665 : 				            cur->name, cur->URL);
; 1666 : 			catal->depth--;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	sub	ecx, 1
	mov	edx, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 1667 : 			return(xmlStrdup(cur->URL));

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	jmp	$LN1@xmlCatalog
$LN25@xmlCatalog:

; 1668 : 		    }
; 1669 : 		    break;

	jmp	SHORT $LN4@xmlCatalog
$LN27@xmlCatalog:

; 1670 : 		case XML_CATA_REWRITE_SYSTEM:
; 1671 : 		    len = xmlStrlen(cur->name);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$7[ebp], eax

; 1672 : 		    if ((len > lenrewrite) &&

	mov	ecx, DWORD PTR _len$7[ebp]
	cmp	ecx, DWORD PTR _lenrewrite$8[ebp]
	jle	SHORT $LN28@xmlCatalog
	mov	edx, DWORD PTR _len$7[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _sysID$[ebp]
	push	edx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN28@xmlCatalog

; 1673 : 			(!xmlStrncmp(sysID, cur->name, len))) {
; 1674 : 			lenrewrite = len;

	mov	eax, DWORD PTR _len$7[ebp]
	mov	DWORD PTR _lenrewrite$8[ebp], eax

; 1675 : 			rewrite = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _rewrite$9[ebp], ecx
$LN28@xmlCatalog:

; 1676 : 		    }
; 1677 : 		    break;

	jmp	SHORT $LN4@xmlCatalog
$LN29@xmlCatalog:

; 1678 : 		case XML_CATA_DELEGATE_SYSTEM:
; 1679 : 		    if (!xmlStrncmp(sysID, cur->name, xmlStrlen(cur->name)))

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlStrlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _sysID$[ebp]
	push	eax
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN30@xmlCatalog

; 1680 : 			haveDelegate++;

	mov	ecx, DWORD PTR _haveDelegate$[ebp]
	add	ecx, 1
	mov	DWORD PTR _haveDelegate$[ebp], ecx
$LN30@xmlCatalog:

; 1681 : 		    break;

	jmp	SHORT $LN4@xmlCatalog
$LN31@xmlCatalog:

; 1682 : 		case XML_CATA_NEXT_CATALOG:
; 1683 : 		    haveNext++;

	mov	edx, DWORD PTR _haveNext$[ebp]
	add	edx, 1
	mov	DWORD PTR _haveNext$[ebp], edx
$LN4@xmlCatalog:

; 1684 : 		    break;
; 1685 : 		default:
; 1686 : 		    break;
; 1687 : 	    }
; 1688 : 	    cur = cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 1689 : 	}

	jmp	$LN2@xmlCatalog
$LN3@xmlCatalog:

; 1690 : 	if (rewrite != NULL) {

	cmp	DWORD PTR _rewrite$9[ebp], 0
	je	SHORT $LN33@xmlCatalog

; 1691 : 	    if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN34@xmlCatalog

; 1692 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	edx, DWORD PTR _rewrite$9[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	OFFSET ??_C@_0BJ@CPNLKDBD@Using?5rewriting?5rule?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN34@xmlCatalog:

; 1693 : 			"Using rewriting rule %s\n", rewrite->name);
; 1694 : 	    ret = xmlStrdup(rewrite->URL);

	mov	eax, DWORD PTR _rewrite$9[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 1695 : 	    if (ret != NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN35@xmlCatalog

; 1696 : 		ret = xmlStrcat(ret, &sysID[lenrewrite]);

	mov	edx, DWORD PTR _sysID$[ebp]
	add	edx, DWORD PTR _lenrewrite$8[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
$LN35@xmlCatalog:

; 1697 : 	    catal->depth--;

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	sub	edx, 1
	mov	eax, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [eax+36], edx

; 1698 : 	    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlCatalog
$LN33@xmlCatalog:

; 1699 : 	}
; 1700 : 	if (haveDelegate) {

	cmp	DWORD PTR _haveDelegate$[ebp], 0
	je	$LN23@xmlCatalog

; 1701 : 	    const xmlChar *delegates[MAX_DELEGATE];
; 1702 : 	    int nbList = 0, i;

	mov	DWORD PTR _nbList$5[ebp], 0

; 1703 : 
; 1704 : 	    /*
; 1705 : 	     * Assume the entries have been sorted by decreasing substring
; 1706 : 	     * matches when the list was produced.
; 1707 : 	     */
; 1708 : 	    cur = catal;

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx
$LN6@xmlCatalog:

; 1709 : 	    while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN7@xmlCatalog

; 1710 : 		if ((cur->type == XML_CATA_DELEGATE_SYSTEM) &&

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+12], 9
	jne	$LN37@xmlCatalog
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlStrlen
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _sysID$[ebp]
	push	ecx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN37@xmlCatalog

; 1711 : 		    (!xmlStrncmp(sysID, cur->name, xmlStrlen(cur->name)))) {
; 1712 : 		    for (i = 0;i < nbList;i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN10@xmlCatalog
$LN8@xmlCatalog:
	mov	edx, DWORD PTR _i$4[ebp]
	add	edx, 1
	mov	DWORD PTR _i$4[ebp], edx
$LN10@xmlCatalog:
	mov	eax, DWORD PTR _i$4[ebp]
	cmp	eax, DWORD PTR _nbList$5[ebp]
	jge	SHORT $LN9@xmlCatalog

; 1713 : 			if (xmlStrEqual(cur->URL, delegates[i]))

	mov	ecx, DWORD PTR _i$4[ebp]
	mov	edx, DWORD PTR _delegates$6[ebp+ecx*4]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN38@xmlCatalog

; 1714 : 			    break;

	jmp	SHORT $LN9@xmlCatalog
$LN38@xmlCatalog:
	jmp	SHORT $LN8@xmlCatalog
$LN9@xmlCatalog:

; 1715 : 		    if (i < nbList) {

	mov	edx, DWORD PTR _i$4[ebp]
	cmp	edx, DWORD PTR _nbList$5[ebp]
	jge	SHORT $LN39@xmlCatalog

; 1716 : 			cur = cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 1717 : 			continue;

	jmp	$LN6@xmlCatalog
$LN39@xmlCatalog:

; 1718 : 		    }
; 1719 : 		    if (nbList < MAX_DELEGATE)

	cmp	DWORD PTR _nbList$5[ebp], 50		; 00000032H
	jge	SHORT $LN40@xmlCatalog

; 1720 : 			delegates[nbList++] = cur->URL;

	mov	edx, DWORD PTR _nbList$5[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _delegates$6[ebp+edx*4], ecx
	mov	edx, DWORD PTR _nbList$5[ebp]
	add	edx, 1
	mov	DWORD PTR _nbList$5[ebp], edx
$LN40@xmlCatalog:

; 1721 : 
; 1722 : 		    if (cur->children == NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN41@xmlCatalog

; 1723 : 			xmlFetchXMLCatalogFile(cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlFetchXMLCatalogFile
	add	esp, 4
$LN41@xmlCatalog:

; 1724 : 		    }
; 1725 : 		    if (cur->children != NULL) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN37@xmlCatalog

; 1726 : 			if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN43@xmlCatalog

; 1727 : 			    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	OFFSET ??_C@_0BL@MIEFLOCA@Trying?5system?5delegate?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN43@xmlCatalog:

; 1728 : 				    "Trying system delegate %s\n", cur->URL);
; 1729 : 			ret = xmlCatalogListXMLResolve(

	mov	ecx, DWORD PTR _sysID$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 1730 : 				cur->children, NULL, sysID);
; 1731 : 			if (ret != NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN37@xmlCatalog

; 1732 : 			    catal->depth--;

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	sub	edx, 1
	mov	eax, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [eax+36], edx

; 1733 : 			    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlCatalog
$LN37@xmlCatalog:

; 1734 : 			}
; 1735 : 		    }
; 1736 : 		}
; 1737 : 		cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 1738 : 	    }

	jmp	$LN6@xmlCatalog
$LN7@xmlCatalog:

; 1739 : 	    /*
; 1740 : 	     * Apply the cut algorithm explained in 4/
; 1741 : 	     */
; 1742 : 	    catal->depth--;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	sub	ecx, 1
	mov	edx, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 1743 : 	    return(XML_CATAL_BREAK);

	or	eax, -1
	jmp	$LN1@xmlCatalog
$LN23@xmlCatalog:

; 1744 : 	}
; 1745 :     }
; 1746 :     /*
; 1747 :      * Then tries 5/ 6/ if a public ID is provided
; 1748 :      */
; 1749 :     if (pubID != NULL) {

	cmp	DWORD PTR _pubID$[ebp], 0
	je	$LN45@xmlCatalog

; 1750 : 	cur = catal;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	DWORD PTR _cur$[ebp], eax

; 1751 : 	haveDelegate = 0;

	mov	DWORD PTR _haveDelegate$[ebp], 0
$LN11@xmlCatalog:

; 1752 : 	while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN12@xmlCatalog

; 1753 : 	    switch (cur->type) {

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv239[ebp], edx
	cmp	DWORD PTR tv239[ebp], 3
	je	$LN51@xmlCatalog
	cmp	DWORD PTR tv239[ebp], 5
	je	SHORT $LN46@xmlCatalog
	cmp	DWORD PTR tv239[ebp], 8
	je	SHORT $LN49@xmlCatalog
	jmp	$LN13@xmlCatalog
$LN46@xmlCatalog:

; 1754 : 		case XML_CATA_PUBLIC:
; 1755 : 		    if (xmlStrEqual(pubID, cur->name)) {

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _pubID$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN47@xmlCatalog

; 1756 : 			if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN48@xmlCatalog

; 1757 : 			    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	OFFSET ??_C@_0BH@IJBOMLNL@Found?5public?5match?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN48@xmlCatalog:

; 1758 : 				    "Found public match %s\n", cur->name);
; 1759 : 			catal->depth--;

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	sub	edx, 1
	mov	eax, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [eax+36], edx

; 1760 : 			return(xmlStrdup(cur->URL));

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	jmp	$LN1@xmlCatalog
$LN47@xmlCatalog:

; 1761 : 		    }
; 1762 : 		    break;

	jmp	SHORT $LN13@xmlCatalog
$LN49@xmlCatalog:

; 1763 : 		case XML_CATA_DELEGATE_PUBLIC:
; 1764 : 		    if (!xmlStrncmp(pubID, cur->name, xmlStrlen(cur->name)) &&

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlStrlen
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _pubID$[ebp]
	push	ecx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN50@xmlCatalog
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+28], 1
	jne	SHORT $LN50@xmlCatalog

; 1765 : 			(cur->prefer == XML_CATA_PREFER_PUBLIC))
; 1766 : 			haveDelegate++;

	mov	eax, DWORD PTR _haveDelegate$[ebp]
	add	eax, 1
	mov	DWORD PTR _haveDelegate$[ebp], eax
$LN50@xmlCatalog:

; 1767 : 		    break;

	jmp	SHORT $LN13@xmlCatalog
$LN51@xmlCatalog:

; 1768 : 		case XML_CATA_NEXT_CATALOG:
; 1769 : 		    if (sysID == NULL)

	cmp	DWORD PTR _sysID$[ebp], 0
	jne	SHORT $LN13@xmlCatalog

; 1770 : 			haveNext++;

	mov	ecx, DWORD PTR _haveNext$[ebp]
	add	ecx, 1
	mov	DWORD PTR _haveNext$[ebp], ecx
$LN13@xmlCatalog:

; 1771 : 		    break;
; 1772 : 		default:
; 1773 : 		    break;
; 1774 : 	    }
; 1775 : 	    cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _cur$[ebp], eax

; 1776 : 	}

	jmp	$LN11@xmlCatalog
$LN12@xmlCatalog:

; 1777 : 	if (haveDelegate) {

	cmp	DWORD PTR _haveDelegate$[ebp], 0
	je	$LN45@xmlCatalog

; 1778 : 	    const xmlChar *delegates[MAX_DELEGATE];
; 1779 : 	    int nbList = 0, i;

	mov	DWORD PTR _nbList$2[ebp], 0

; 1780 : 
; 1781 : 	    /*
; 1782 : 	     * Assume the entries have been sorted by decreasing substring
; 1783 : 	     * matches when the list was produced.
; 1784 : 	     */
; 1785 : 	    cur = catal;

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx
$LN15@xmlCatalog:

; 1786 : 	    while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN16@xmlCatalog

; 1787 : 		if ((cur->type == XML_CATA_DELEGATE_PUBLIC) &&
; 1788 : 		    (cur->prefer == XML_CATA_PREFER_PUBLIC) &&

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+12], 8
	jne	$LN55@xmlCatalog
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+28], 1
	jne	$LN55@xmlCatalog
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlStrlen
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _pubID$[ebp]
	push	edx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN55@xmlCatalog

; 1789 : 		    (!xmlStrncmp(pubID, cur->name, xmlStrlen(cur->name)))) {
; 1790 : 
; 1791 : 		    for (i = 0;i < nbList;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN19@xmlCatalog
$LN17@xmlCatalog:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN19@xmlCatalog:
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR _nbList$2[ebp]
	jge	SHORT $LN18@xmlCatalog

; 1792 : 			if (xmlStrEqual(cur->URL, delegates[i]))

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _delegates$3[ebp+edx*4]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN56@xmlCatalog

; 1793 : 			    break;

	jmp	SHORT $LN18@xmlCatalog
$LN56@xmlCatalog:
	jmp	SHORT $LN17@xmlCatalog
$LN18@xmlCatalog:

; 1794 : 		    if (i < nbList) {

	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _nbList$2[ebp]
	jge	SHORT $LN57@xmlCatalog

; 1795 : 			cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 1796 : 			continue;

	jmp	$LN15@xmlCatalog
$LN57@xmlCatalog:

; 1797 : 		    }
; 1798 : 		    if (nbList < MAX_DELEGATE)

	cmp	DWORD PTR _nbList$2[ebp], 50		; 00000032H
	jge	SHORT $LN58@xmlCatalog

; 1799 : 			delegates[nbList++] = cur->URL;

	mov	eax, DWORD PTR _nbList$2[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _delegates$3[ebp+eax*4], edx
	mov	eax, DWORD PTR _nbList$2[ebp]
	add	eax, 1
	mov	DWORD PTR _nbList$2[ebp], eax
$LN58@xmlCatalog:

; 1800 : 
; 1801 : 		    if (cur->children == NULL) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN59@xmlCatalog

; 1802 : 			xmlFetchXMLCatalogFile(cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlFetchXMLCatalogFile
	add	esp, 4
$LN59@xmlCatalog:

; 1803 : 		    }
; 1804 : 		    if (cur->children != NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN55@xmlCatalog

; 1805 : 			if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN61@xmlCatalog

; 1806 : 			    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	OFFSET ??_C@_0BL@PNMEBECK@Trying?5public?5delegate?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN61@xmlCatalog:

; 1807 : 				    "Trying public delegate %s\n", cur->URL);
; 1808 : 			ret = xmlCatalogListXMLResolve(

	push	0
	mov	edx, DWORD PTR _pubID$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 1809 : 				cur->children, pubID, NULL);
; 1810 : 			if (ret != NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN55@xmlCatalog

; 1811 : 			    catal->depth--;

	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+36]
	sub	eax, 1
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 1812 : 			    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlCatalog
$LN55@xmlCatalog:

; 1813 : 			}
; 1814 : 		    }
; 1815 : 		}
; 1816 : 		cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _cur$[ebp], eax

; 1817 : 	    }

	jmp	$LN15@xmlCatalog
$LN16@xmlCatalog:

; 1818 : 	    /*
; 1819 : 	     * Apply the cut algorithm explained in 4/
; 1820 : 	     */
; 1821 : 	    catal->depth--;

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	sub	edx, 1
	mov	eax, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [eax+36], edx

; 1822 : 	    return(XML_CATAL_BREAK);

	or	eax, -1
	jmp	$LN1@xmlCatalog
$LN45@xmlCatalog:

; 1823 : 	}
; 1824 :     }
; 1825 :     if (haveNext) {

	cmp	DWORD PTR _haveNext$[ebp], 0
	je	$LN63@xmlCatalog

; 1826 : 	cur = catal;

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx
$LN20@xmlCatalog:

; 1827 : 	while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN63@xmlCatalog

; 1828 : 	    if (cur->type == XML_CATA_NEXT_CATALOG) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+12], 3
	jne	SHORT $LN64@xmlCatalog

; 1829 : 		if (cur->children == NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN65@xmlCatalog

; 1830 : 		    xmlFetchXMLCatalogFile(cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlFetchXMLCatalogFile
	add	esp, 4
$LN65@xmlCatalog:

; 1831 : 		}
; 1832 : 		if (cur->children != NULL) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN64@xmlCatalog

; 1833 : 		    ret = xmlCatalogListXMLResolve(cur->children, pubID, sysID);

	mov	eax, DWORD PTR _sysID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pubID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 1834 : 		    if (ret != NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN67@xmlCatalog

; 1835 : 			catal->depth--;

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	sub	edx, 1
	mov	eax, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [eax+36], edx

; 1836 : 			return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlCatalog
	jmp	SHORT $LN64@xmlCatalog
$LN67@xmlCatalog:

; 1837 : 		    } else if (catal->depth > MAX_CATAL_DEPTH) {

	mov	ecx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [ecx+36], 50			; 00000032H
	jle	SHORT $LN64@xmlCatalog

; 1838 : 		        return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCatalog
$LN64@xmlCatalog:

; 1839 : 		    }
; 1840 : 		}
; 1841 : 	    }
; 1842 : 	    cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _cur$[ebp], eax

; 1843 : 	}

	jmp	SHORT $LN20@xmlCatalog
$LN63@xmlCatalog:

; 1844 :     }
; 1845 : 
; 1846 :     catal->depth--;

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	sub	edx, 1
	mov	eax, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [eax+36], edx

; 1847 :     return(NULL);

	xor	eax, eax
$LN1@xmlCatalog:

; 1848 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN76@xmlCatalog
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 468				; 000001d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN76@xmlCatalog:
	DD	2
	DD	$LN75@xmlCatalog
$LN75@xmlCatalog:
	DD	-232					; ffffff18H
	DD	200					; 000000c8H
	DD	$LN73@xmlCatalog
	DD	-448					; fffffe40H
	DD	200					; 000000c8H
	DD	$LN74@xmlCatalog
$LN74@xmlCatalog:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	103					; 00000067H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN73@xmlCatalog:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	103					; 00000067H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN77@xmlCatalog:
	DD	$LN31@xmlCatalog
	DD	$LN4@xmlCatalog
	DD	$LN4@xmlCatalog
	DD	$LN24@xmlCatalog
	DD	$LN27@xmlCatalog
	DD	$LN4@xmlCatalog
	DD	$LN29@xmlCatalog
_xmlCatalogXMLResolve ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlDelXMLCatalog
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_cur$ = -4						; size = 4
_catal$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlDelXMLCatalog PROC					; COMDAT

; 1581 : xmlDelXMLCatalog(xmlCatalogEntryPtr catal, const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 1582 :     xmlCatalogEntryPtr cur;
; 1583 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1584 : 
; 1585 :     if ((catal == NULL) ||

	cmp	DWORD PTR _catal$[ebp], 0
	je	SHORT $LN5@xmlDelXMLC
	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax+12], 1
	je	SHORT $LN4@xmlDelXMLC
	mov	ecx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [ecx+12], 2
	je	SHORT $LN4@xmlDelXMLC
$LN5@xmlDelXMLC:

; 1586 : 	((catal->type != XML_CATA_CATALOG) &&
; 1587 : 	 (catal->type != XML_CATA_BROKEN_CATALOG)))
; 1588 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlDelXMLC
$LN4@xmlDelXMLC:

; 1589 :     if (value == NULL)

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN6@xmlDelXMLC

; 1590 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlDelXMLC
$LN6@xmlDelXMLC:

; 1591 :     if (catal->children == NULL) {

	mov	edx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN7@xmlDelXMLC

; 1592 : 	xmlFetchXMLCatalogFile(catal);

	mov	eax, DWORD PTR _catal$[ebp]
	push	eax
	call	_xmlFetchXMLCatalogFile
	add	esp, 4
$LN7@xmlDelXMLC:

; 1593 :     }
; 1594 : 
; 1595 :     /*
; 1596 :      * Scan the children
; 1597 :      */
; 1598 :     cur = catal->children;

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx
$LN2@xmlDelXMLC:

; 1599 :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN3@xmlDelXMLC

; 1600 : 	if (((cur->name != NULL) && (xmlStrEqual(value, cur->name))) ||

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN10@xmlDelXMLC
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlDelXMLC
$LN10@xmlDelXMLC:
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlDelXMLC
$LN9@xmlDelXMLC:

; 1601 : 	    (xmlStrEqual(value, cur->value))) {
; 1602 : 	    if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN11@xmlDelXMLC

; 1603 : 		if (cur->name != NULL)

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN12@xmlDelXMLC

; 1604 : 		    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	OFFSET ??_C@_0CC@LGDNIPOE@Removing?5element?5?$CFs?5from?5catalo@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN11@xmlDelXMLC
$LN12@xmlDelXMLC:

; 1605 : 			    "Removing element %s from catalog\n", cur->name);
; 1606 : 		else
; 1607 : 		    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	OFFSET ??_C@_0CC@LGDNIPOE@Removing?5element?5?$CFs?5from?5catalo@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlDelXMLC:

; 1608 : 			    "Removing element %s from catalog\n", cur->value);
; 1609 : 	    }
; 1610 : 	    cur->type = XML_CATA_REMOVED;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+12], -1
$LN8@xmlDelXMLC:

; 1611 : 	}
; 1612 : 	cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _cur$[ebp], eax

; 1613 :     }

	jmp	$LN2@xmlDelXMLC
$LN3@xmlDelXMLC:

; 1614 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlDelXMLC:

; 1615 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDelXMLCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlAddXMLCatalog
_TEXT	SEGMENT
_doregister$ = -12					; size = 4
_typ$ = -8						; size = 4
_cur$ = -4						; size = 4
_catal$ = 8						; size = 4
_type$ = 12						; size = 4
_orig$ = 16						; size = 4
_replace$ = 20						; size = 4
_xmlAddXMLCatalog PROC					; COMDAT

; 1504 : 	      const xmlChar *orig, const xmlChar *replace) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 1505 :     xmlCatalogEntryPtr cur;
; 1506 :     xmlCatalogEntryType typ;
; 1507 :     int doregister = 0;

	mov	DWORD PTR _doregister$[ebp], 0

; 1508 : 
; 1509 :     if ((catal == NULL) ||

	cmp	DWORD PTR _catal$[ebp], 0
	je	SHORT $LN5@xmlAddXMLC
	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax+12], 1
	je	SHORT $LN4@xmlAddXMLC
	mov	ecx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [ecx+12], 2
	je	SHORT $LN4@xmlAddXMLC
$LN5@xmlAddXMLC:

; 1510 : 	((catal->type != XML_CATA_CATALOG) &&
; 1511 : 	 (catal->type != XML_CATA_BROKEN_CATALOG)))
; 1512 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlAddXMLC
$LN4@xmlAddXMLC:

; 1513 :     if (catal->children == NULL) {

	mov	edx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN6@xmlAddXMLC

; 1514 : 	xmlFetchXMLCatalogFile(catal);

	mov	eax, DWORD PTR _catal$[ebp]
	push	eax
	call	_xmlFetchXMLCatalogFile
	add	esp, 4
$LN6@xmlAddXMLC:

; 1515 :     }
; 1516 :     if (catal->children == NULL)

	mov	ecx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN7@xmlAddXMLC

; 1517 : 	doregister = 1;

	mov	DWORD PTR _doregister$[ebp], 1
$LN7@xmlAddXMLC:

; 1518 : 
; 1519 :     typ = xmlGetXMLCatalogEntryType(type);

	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	call	_xmlGetXMLCatalogEntryType
	add	esp, 4
	mov	DWORD PTR _typ$[ebp], eax

; 1520 :     if (typ == XML_CATA_NONE) {

	cmp	DWORD PTR _typ$[ebp], 0
	jne	SHORT $LN8@xmlAddXMLC

; 1521 : 	if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN9@xmlAddXMLC

; 1522 : 	    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	push	OFFSET ??_C@_0CN@LDFDKPIL@Failed?5to?5add?5unknown?5element?5?$CF@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@xmlAddXMLC:

; 1523 : 		    "Failed to add unknown element %s to catalog\n", type);
; 1524 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlAddXMLC
$LN8@xmlAddXMLC:

; 1525 :     }
; 1526 : 
; 1527 :     cur = catal->children;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _cur$[ebp], ecx

; 1528 :     /*
; 1529 :      * Might be a simple "update in place"
; 1530 :      */
; 1531 :     if (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN10@xmlAddXMLC
$LN2@xmlAddXMLC:

; 1532 : 	while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN10@xmlAddXMLC

; 1533 : 	    if ((orig != NULL) && (cur->type == typ) &&

	cmp	DWORD PTR _orig$[ebp], 0
	je	$LN11@xmlAddXMLC
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _typ$[ebp]
	jne	$LN11@xmlAddXMLC
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _orig$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN11@xmlAddXMLC

; 1534 : 		(xmlStrEqual(orig, cur->name))) {
; 1535 : 		if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN12@xmlAddXMLC

; 1536 : 		    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CA@DFBONGAG@Updating?5element?5?$CFs?5to?5catalog?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlAddXMLC:

; 1537 : 			    "Updating element %s to catalog\n", type);
; 1538 : 		if (cur->value != NULL)

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN13@xmlAddXMLC

; 1539 : 		    xmlFree(cur->value);

	mov	esi, esp
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@xmlAddXMLC:

; 1540 : 		if (cur->URL != NULL)

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN14@xmlAddXMLC

; 1541 : 		    xmlFree(cur->URL);

	mov	esi, esp
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@xmlAddXMLC:

; 1542 : 		cur->value = xmlStrdup(replace);

	mov	ecx, DWORD PTR _replace$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+20], eax

; 1543 : 		cur->URL = xmlStrdup(replace);

	mov	eax, DWORD PTR _replace$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1544 : 		return(0);

	xor	eax, eax
	jmp	$LN1@xmlAddXMLC
$LN11@xmlAddXMLC:

; 1545 : 	    }
; 1546 : 	    if (cur->next == NULL)

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN15@xmlAddXMLC

; 1547 : 		break;

	jmp	SHORT $LN10@xmlAddXMLC
$LN15@xmlAddXMLC:

; 1548 : 	    cur = cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 1549 : 	}

	jmp	$LN2@xmlAddXMLC
$LN10@xmlAddXMLC:

; 1550 :     }
; 1551 :     if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN16@xmlAddXMLC

; 1552 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	push	OFFSET ??_C@_0BO@CBJLKDGJ@Adding?5element?5?$CFs?5to?5catalog?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@xmlAddXMLC:

; 1553 : 		"Adding element %s to catalog\n", type);
; 1554 :     if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN17@xmlAddXMLC

; 1555 : 	catal->children = xmlNewCatalogEntry(typ, orig, replace,

	push	0
	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	push	0
	mov	ecx, DWORD PTR _replace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _orig$[ebp]
	push	edx
	mov	eax, DWORD PTR _typ$[ebp]
	push	eax
	call	_xmlNewCatalogEntry
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN18@xmlAddXMLC
$LN17@xmlAddXMLC:

; 1556 : 		                             NULL, catal->prefer, NULL);
; 1557 :     else
; 1558 : 	cur->next = xmlNewCatalogEntry(typ, orig, replace,

	push	0
	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	push	0
	mov	ecx, DWORD PTR _replace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _orig$[ebp]
	push	edx
	mov	eax, DWORD PTR _typ$[ebp]
	push	eax
	call	_xmlNewCatalogEntry
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], eax
$LN18@xmlAddXMLC:

; 1559 : 		                       NULL, catal->prefer, NULL);
; 1560 :     if (doregister) {

	cmp	DWORD PTR _doregister$[ebp], 0
	je	SHORT $LN19@xmlAddXMLC

; 1561 :         catal->type = XML_CATA_CATALOG;

	mov	edx, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1562 : 	cur = (xmlCatalogEntryPtr)xmlHashLookup(xmlCatalogXMLFiles, catal->URL);

	mov	eax, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _xmlCatalogXMLFiles
	push	edx
	call	_xmlHashLookup
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1563 : 	if (cur != NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN19@xmlAddXMLC

; 1564 : 	    cur->children = catal->children;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
$LN19@xmlAddXMLC:

; 1565 :     }
; 1566 : 
; 1567 :     return(0);

	xor	eax, eax
$LN1@xmlAddXMLC:

; 1568 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAddXMLCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlFetchXMLCatalogFile
_TEXT	SEGMENT
_doc$ = -4						; size = 4
_catal$ = 8						; size = 4
_xmlFetchXMLCatalogFile PROC				; COMDAT

; 1414 : xmlFetchXMLCatalogFile(xmlCatalogEntryPtr catal) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 1415 :     xmlCatalogEntryPtr doc;
; 1416 : 
; 1417 :     if (catal == NULL)

	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN2@xmlFetchXM

; 1418 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlFetchXM
$LN2@xmlFetchXM:

; 1419 :     if (catal->URL == NULL)

	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN3@xmlFetchXM

; 1420 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlFetchXM
$LN3@xmlFetchXM:

; 1421 : 
; 1422 :     /*
; 1423 :      * lock the whole catalog for modification
; 1424 :      */
; 1425 :     xmlRMutexLock(xmlCatalogMutex);

	mov	ecx, DWORD PTR _xmlCatalogMutex
	push	ecx
	call	_xmlRMutexLock
	add	esp, 4

; 1426 :     if (catal->children != NULL) {

	mov	edx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN4@xmlFetchXM

; 1427 : 	/* Okay someone else did it in the meantime */
; 1428 : 	xmlRMutexUnlock(xmlCatalogMutex);

	mov	eax, DWORD PTR _xmlCatalogMutex
	push	eax
	call	_xmlRMutexUnlock
	add	esp, 4

; 1429 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlFetchXM
$LN4@xmlFetchXM:

; 1430 :     }
; 1431 : 
; 1432 :     if (xmlCatalogXMLFiles != NULL) {

	cmp	DWORD PTR _xmlCatalogXMLFiles, 0
	je	$LN5@xmlFetchXM

; 1433 : 	doc = (xmlCatalogEntryPtr)

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _xmlCatalogXMLFiles
	push	eax
	call	_xmlHashLookup
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 1434 : 	    xmlHashLookup(xmlCatalogXMLFiles, catal->URL);
; 1435 : 	if (doc != NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN6@xmlFetchXM

; 1436 : 	    if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN7@xmlFetchXM

; 1437 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	OFFSET ??_C@_0BH@CAELNCCF@Found?5?$CFs?5in?5file?5hash?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlFetchXM:

; 1438 : 		    "Found %s in file hash\n", catal->URL);
; 1439 : 
; 1440 : 	    if (catal->type == XML_CATA_CATALOG)

	mov	edx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [edx+12], 1
	jne	SHORT $LN8@xmlFetchXM

; 1441 : 		catal->children = doc->children;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN9@xmlFetchXM
$LN8@xmlFetchXM:

; 1442 : 	    else
; 1443 : 		catal->children = doc;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN9@xmlFetchXM:

; 1444 : 	    catal->dealloc = 0;

	mov	edx, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [edx+32], 0

; 1445 : 	    xmlRMutexUnlock(xmlCatalogMutex);

	mov	eax, DWORD PTR _xmlCatalogMutex
	push	eax
	call	_xmlRMutexUnlock
	add	esp, 4

; 1446 : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlFetchXM
$LN6@xmlFetchXM:

; 1447 : 	}
; 1448 : 	if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN5@xmlFetchXM

; 1449 : 	    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	OFFSET ??_C@_0BL@NEIEMMME@?$CFs?5not?5found?5in?5file?5hash?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@xmlFetchXM:

; 1450 : 		"%s not found in file hash\n", catal->URL);
; 1451 :     }
; 1452 : 
; 1453 :     /*
; 1454 :      * Fetch and parse. Note that xmlParseXMLCatalogFile does not
; 1455 :      * use the existing catalog, there is no recursion allowed at
; 1456 :      * that level.
; 1457 :      */
; 1458 :     doc = xmlParseXMLCatalogFile(catal->prefer, catal->URL);

	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	_xmlParseXMLCatalogFile
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 1459 :     if (doc == NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN11@xmlFetchXM

; 1460 : 	catal->type = XML_CATA_BROKEN_CATALOG;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [eax+12], 2

; 1461 : 	xmlRMutexUnlock(xmlCatalogMutex);

	mov	ecx, DWORD PTR _xmlCatalogMutex
	push	ecx
	call	_xmlRMutexUnlock
	add	esp, 4

; 1462 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlFetchXM
$LN11@xmlFetchXM:

; 1463 :     }
; 1464 : 
; 1465 :     if (catal->type == XML_CATA_CATALOG)

	mov	edx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [edx+12], 1
	jne	SHORT $LN12@xmlFetchXM

; 1466 : 	catal->children = doc->children;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN13@xmlFetchXM
$LN12@xmlFetchXM:

; 1467 :     else
; 1468 : 	catal->children = doc;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN13@xmlFetchXM:

; 1469 : 
; 1470 :     doc->dealloc = 1;

	mov	edx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [edx+32], 1

; 1471 : 
; 1472 :     if (xmlCatalogXMLFiles == NULL)

	cmp	DWORD PTR _xmlCatalogXMLFiles, 0
	jne	SHORT $LN14@xmlFetchXM

; 1473 : 	xmlCatalogXMLFiles = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR _xmlCatalogXMLFiles, eax
$LN14@xmlFetchXM:

; 1474 :     if (xmlCatalogXMLFiles != NULL) {

	cmp	DWORD PTR _xmlCatalogXMLFiles, 0
	je	SHORT $LN15@xmlFetchXM

; 1475 : 	if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN16@xmlFetchXM

; 1476 : 	    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	OFFSET ??_C@_0BH@KIEODICD@?$CFs?5added?5to?5file?5hash?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@xmlFetchXM:

; 1477 : 		"%s added to file hash\n", catal->URL);
; 1478 : 	xmlHashAddEntry(xmlCatalogXMLFiles, catal->URL, doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _xmlCatalogXMLFiles
	push	ecx
	call	_xmlHashAddEntry
	add	esp, 12					; 0000000cH
$LN15@xmlFetchXM:

; 1479 :     }
; 1480 :     xmlRMutexUnlock(xmlCatalogMutex);

	mov	edx, DWORD PTR _xmlCatalogMutex
	push	edx
	call	_xmlRMutexUnlock
	add	esp, 4

; 1481 :     return(0);

	xor	eax, eax
$LN1@xmlFetchXM:

; 1482 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFetchXMLCatalogFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseXMLCatalogNode
_TEXT	SEGMENT
_prev$1 = -20						; size = 4
_pref$2 = -16						; size = 4
_prop$3 = -12						; size = 4
_entry$ = -8						; size = 4
_base$ = -4						; size = 4
_cur$ = 8						; size = 4
_prefer$ = 12						; size = 4
_parent$ = 16						; size = 4
_cgroup$ = 20						; size = 4
_xmlParseXMLCatalogNode PROC				; COMDAT

; 1222 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 1223 :     xmlChar *base = NULL;

	mov	DWORD PTR _base$[ebp], 0

; 1224 :     xmlCatalogEntryPtr entry = NULL;

	mov	DWORD PTR _entry$[ebp], 0

; 1225 : 
; 1226 :     if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN4@xmlParseXM

; 1227 :         return;

	jmp	$LN1@xmlParseXM
$LN4@xmlParseXM:

; 1228 :     if (xmlStrEqual(cur->name, BAD_CAST "group")) {

	push	OFFSET ??_C@_05MGJOOGAJ@group@
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN5@xmlParseXM

; 1229 :         xmlChar *prop;
; 1230 : 	xmlCatalogPrefer pref = XML_CATA_PREFER_NONE;

	mov	DWORD PTR _pref$2[ebp], 0

; 1231 : 
; 1232 :         prop = xmlGetProp(cur, BAD_CAST "prefer");

	push	OFFSET ??_C@_06NEJLBODN@prefer@
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _prop$3[ebp], eax

; 1233 :         if (prop != NULL) {

	cmp	DWORD PTR _prop$3[ebp], 0
	je	SHORT $LN7@xmlParseXM

; 1234 :             if (xmlStrEqual(prop, BAD_CAST "system")) {

	push	OFFSET ??_C@_06FHFOAHML@system@
	mov	eax, DWORD PTR _prop$3[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlParseXM

; 1235 :                 prefer = XML_CATA_PREFER_SYSTEM;

	mov	DWORD PTR _prefer$[ebp], 2
	jmp	SHORT $LN9@xmlParseXM
$LN8@xmlParseXM:

; 1236 :             } else if (xmlStrEqual(prop, BAD_CAST "public")) {

	push	OFFSET ??_C@_06EOMAMIIF@public@
	mov	ecx, DWORD PTR _prop$3[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlParseXM

; 1237 :                 prefer = XML_CATA_PREFER_PUBLIC;

	mov	DWORD PTR _prefer$[ebp], 1

; 1238 :             } else {

	jmp	SHORT $LN9@xmlParseXM
$LN10@xmlParseXM:

; 1239 : 		xmlCatalogErr(parent, cur, XML_CATALOG_PREFER_VALUE,

	push	0
	push	0
	mov	edx, DWORD PTR _prop$3[ebp]
	push	edx
	push	OFFSET ??_C@_0CA@KIJKHIJM@Invalid?5value?5for?5prefer?3?5?8?$CFs?8?6@
	push	1652					; 00000674H
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlCatalogErr
	add	esp, 28					; 0000001cH
$LN9@xmlParseXM:

; 1240 :                               "Invalid value for prefer: '%s'\n",
; 1241 : 			      prop, NULL, NULL);
; 1242 :             }
; 1243 :             xmlFree(prop);

	mov	esi, esp
	mov	edx, DWORD PTR _prop$3[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1244 : 	    pref = prefer;

	mov	eax, DWORD PTR _prefer$[ebp]
	mov	DWORD PTR _pref$2[ebp], eax
$LN7@xmlParseXM:

; 1245 :         }
; 1246 : 	prop = xmlGetProp(cur, BAD_CAST "id");

	push	OFFSET ??_C@_02EGCJHIOB@id@
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _prop$3[ebp], eax

; 1247 : 	base = xmlGetNsProp(cur, BAD_CAST "base", XML_XML_NAMESPACE);

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	OFFSET ??_C@_04BHIIPFEC@base@
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlGetNsProp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _base$[ebp], eax

; 1248 : 	entry = xmlNewCatalogEntry(XML_CATA_GROUP, prop, base, NULL, pref, cgroup);

	mov	eax, DWORD PTR _cgroup$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pref$2[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _prop$3[ebp]
	push	eax
	push	4
	call	_xmlNewCatalogEntry
	add	esp, 24					; 00000018H
	mov	DWORD PTR _entry$[ebp], eax

; 1249 : 	xmlFree(prop);

	mov	esi, esp
	mov	ecx, DWORD PTR _prop$3[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN6@xmlParseXM
$LN5@xmlParseXM:

; 1250 :     } else if (xmlStrEqual(cur->name, BAD_CAST "public")) {

	push	OFFSET ??_C@_06EOMAMIIF@public@
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlParseXM

; 1251 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_PUBLIC,

	mov	ecx, DWORD PTR _cgroup$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefer$[ebp]
	push	edx
	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	OFFSET ??_C@_08KNJBHAKA@publicId@
	push	OFFSET ??_C@_06EOMAMIIF@public@
	push	5
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlParseXMLCatalogOneNode
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _entry$[ebp], eax
	jmp	$LN6@xmlParseXM
$LN12@xmlParseXM:

; 1252 : 		BAD_CAST "public", BAD_CAST "publicId", BAD_CAST "uri", prefer, cgroup);
; 1253 :     } else if (xmlStrEqual(cur->name, BAD_CAST "system")) {

	push	OFFSET ??_C@_06FHFOAHML@system@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlParseXM

; 1254 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_SYSTEM,

	mov	eax, DWORD PTR _cgroup$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefer$[ebp]
	push	ecx
	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	OFFSET ??_C@_08MILANEJE@systemId@
	push	OFFSET ??_C@_06FHFOAHML@system@
	push	6
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlParseXMLCatalogOneNode
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _entry$[ebp], eax
	jmp	$LN6@xmlParseXM
$LN14@xmlParseXM:

; 1255 : 		BAD_CAST "system", BAD_CAST "systemId", BAD_CAST "uri", prefer, cgroup);
; 1256 :     } else if (xmlStrEqual(cur->name, BAD_CAST "rewriteSystem")) {

	push	OFFSET ??_C@_0O@CCMDBGLO@rewriteSystem@
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlParseXM

; 1257 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_REWRITE_SYSTEM,

	mov	edx, DWORD PTR _cgroup$[ebp]
	push	edx
	mov	eax, DWORD PTR _prefer$[ebp]
	push	eax
	push	OFFSET ??_C@_0O@FCPDBOKG@rewritePrefix@
	push	OFFSET ??_C@_0BE@DMCACPJB@systemIdStartString@
	push	OFFSET ??_C@_0O@CCMDBGLO@rewriteSystem@
	push	7
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlParseXMLCatalogOneNode
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _entry$[ebp], eax
	jmp	$LN6@xmlParseXM
$LN16@xmlParseXM:

; 1258 : 		BAD_CAST "rewriteSystem", BAD_CAST "systemIdStartString",
; 1259 : 		BAD_CAST "rewritePrefix", prefer, cgroup);
; 1260 :     } else if (xmlStrEqual(cur->name, BAD_CAST "delegatePublic")) {

	push	OFFSET ??_C@_0P@FNMIEEAK@delegatePublic@
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlParseXM

; 1261 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_DELEGATE_PUBLIC,

	mov	ecx, DWORD PTR _cgroup$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefer$[ebp]
	push	edx
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	OFFSET ??_C@_0BE@JKBIFJL@publicIdStartString@
	push	OFFSET ??_C@_0P@FNMIEEAK@delegatePublic@
	push	8
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlParseXMLCatalogOneNode
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _entry$[ebp], eax
	jmp	$LN6@xmlParseXM
$LN18@xmlParseXM:

; 1262 : 		BAD_CAST "delegatePublic", BAD_CAST "publicIdStartString",
; 1263 : 		BAD_CAST "catalog", prefer, cgroup);
; 1264 :     } else if (xmlStrEqual(cur->name, BAD_CAST "delegateSystem")) {

	push	OFFSET ??_C@_0P@EEFGILEE@delegateSystem@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlParseXM

; 1265 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_DELEGATE_SYSTEM,

	mov	eax, DWORD PTR _cgroup$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefer$[ebp]
	push	ecx
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	OFFSET ??_C@_0BE@DMCACPJB@systemIdStartString@
	push	OFFSET ??_C@_0P@EEFGILEE@delegateSystem@
	push	9
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlParseXMLCatalogOneNode
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _entry$[ebp], eax
	jmp	$LN6@xmlParseXM
$LN20@xmlParseXM:

; 1266 : 		BAD_CAST "delegateSystem", BAD_CAST "systemIdStartString",
; 1267 : 		BAD_CAST "catalog", prefer, cgroup);
; 1268 :     } else if (xmlStrEqual(cur->name, BAD_CAST "uri")) {

	push	OFFSET ??_C@_03GBBABMJN@uri@
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@xmlParseXM

; 1269 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_URI,

	mov	edx, DWORD PTR _cgroup$[ebp]
	push	edx
	mov	eax, DWORD PTR _prefer$[ebp]
	push	eax
	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlParseXMLCatalogOneNode
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _entry$[ebp], eax
	jmp	$LN6@xmlParseXM
$LN22@xmlParseXM:

; 1270 : 		BAD_CAST "uri", BAD_CAST "name",
; 1271 : 		BAD_CAST "uri", prefer, cgroup);
; 1272 :     } else if (xmlStrEqual(cur->name, BAD_CAST "rewriteURI")) {

	push	OFFSET ??_C@_0L@BCFABNDK@rewriteURI@
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@xmlParseXM

; 1273 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_REWRITE_URI,

	mov	ecx, DWORD PTR _cgroup$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefer$[ebp]
	push	edx
	push	OFFSET ??_C@_0O@FCPDBOKG@rewritePrefix@
	push	OFFSET ??_C@_0P@HNKDCBAK@uriStartString@
	push	OFFSET ??_C@_0L@BCFABNDK@rewriteURI@
	push	11					; 0000000bH
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlParseXMLCatalogOneNode
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _entry$[ebp], eax
	jmp	SHORT $LN6@xmlParseXM
$LN24@xmlParseXM:

; 1274 : 		BAD_CAST "rewriteURI", BAD_CAST "uriStartString",
; 1275 : 		BAD_CAST "rewritePrefix", prefer, cgroup);
; 1276 :     } else if (xmlStrEqual(cur->name, BAD_CAST "delegateURI")) {

	push	OFFSET ??_C@_0M@NHAMNMJD@delegateURI@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN26@xmlParseXM

; 1277 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_DELEGATE_URI,

	mov	eax, DWORD PTR _cgroup$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefer$[ebp]
	push	ecx
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	OFFSET ??_C@_0P@HNKDCBAK@uriStartString@
	push	OFFSET ??_C@_0M@NHAMNMJD@delegateURI@
	push	12					; 0000000cH
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlParseXMLCatalogOneNode
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _entry$[ebp], eax
	jmp	SHORT $LN6@xmlParseXM
$LN26@xmlParseXM:

; 1278 : 		BAD_CAST "delegateURI", BAD_CAST "uriStartString",
; 1279 : 		BAD_CAST "catalog", prefer, cgroup);
; 1280 :     } else if (xmlStrEqual(cur->name, BAD_CAST "nextCatalog")) {

	push	OFFSET ??_C@_0M@IKOOEBPK@nextCatalog@
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlParseXM

; 1281 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_NEXT_CATALOG,

	mov	edx, DWORD PTR _cgroup$[ebp]
	push	edx
	mov	eax, DWORD PTR _prefer$[ebp]
	push	eax
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	0
	push	OFFSET ??_C@_0M@IKOOEBPK@nextCatalog@
	push	3
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlParseXMLCatalogOneNode
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _entry$[ebp], eax
$LN6@xmlParseXM:

; 1282 : 		BAD_CAST "nextCatalog", NULL,
; 1283 : 		BAD_CAST "catalog", prefer, cgroup);
; 1284 :     }
; 1285 :     if (entry != NULL) {

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN29@xmlParseXM

; 1286 :         if (parent != NULL) {

	cmp	DWORD PTR _parent$[ebp], 0
	je	SHORT $LN30@xmlParseXM

; 1287 : 	    entry->parent = parent;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _parent$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1288 : 	    if (parent->children == NULL)

	mov	ecx, DWORD PTR _parent$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN31@xmlParseXM

; 1289 : 		parent->children = entry;

	mov	edx, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN30@xmlParseXM
$LN31@xmlParseXM:

; 1290 : 	    else {
; 1291 : 		xmlCatalogEntryPtr prev;
; 1292 : 
; 1293 : 		prev = parent->children;

	mov	ecx, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _prev$1[ebp], edx
$LN2@xmlParseXM:

; 1294 : 		while (prev->next != NULL)

	mov	eax, DWORD PTR _prev$1[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@xmlParseXM

; 1295 : 		    prev = prev->next;

	mov	ecx, DWORD PTR _prev$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _prev$1[ebp], edx
	jmp	SHORT $LN2@xmlParseXM
$LN3@xmlParseXM:

; 1296 : 		prev->next = entry;

	mov	eax, DWORD PTR _prev$1[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax], ecx
$LN30@xmlParseXM:

; 1297 : 	    }
; 1298 : 	}
; 1299 : 	if (entry->type == XML_CATA_GROUP) {

	mov	edx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [edx+12], 4
	jne	SHORT $LN29@xmlParseXM

; 1300 : 	    /*
; 1301 : 	     * Recurse to propagate prefer to the subtree
; 1302 : 	     * (xml:base handling is automated)
; 1303 : 	     */
; 1304 :             xmlParseXMLCatalogNodeList(cur->children, prefer, parent, entry);

	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefer$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_xmlParseXMLCatalogNodeList
	add	esp, 16					; 00000010H
$LN29@xmlParseXM:

; 1305 : 	}
; 1306 :     }
; 1307 :     if (base != NULL)

	cmp	DWORD PTR _base$[ebp], 0
	je	SHORT $LN1@xmlParseXM

; 1308 : 	xmlFree(base);

	mov	esi, esp
	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlParseXM:

; 1309 : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseXMLCatalogNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseXMLCatalogOneNode
_TEXT	SEGMENT
_ret$ = -24						; size = 4
_URL$ = -20						; size = 4
_base$ = -16						; size = 4
_nameValue$ = -12					; size = 4
_uriValue$ = -8						; size = 4
_ok$ = -4						; size = 4
_cur$ = 8						; size = 4
_type$ = 12						; size = 4
_name$ = 16						; size = 4
_attrName$ = 20						; size = 4
_uriAttrName$ = 24					; size = 4
_prefer$ = 28						; size = 4
_cgroup$ = 32						; size = 4
_xmlParseXMLCatalogOneNode PROC				; COMDAT

; 1151 : 			  xmlCatalogEntryPtr cgroup) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 1152 :     int ok = 1;

	mov	DWORD PTR _ok$[ebp], 1

; 1153 :     xmlChar *uriValue;
; 1154 :     xmlChar *nameValue = NULL;

	mov	DWORD PTR _nameValue$[ebp], 0

; 1155 :     xmlChar *base = NULL;

	mov	DWORD PTR _base$[ebp], 0

; 1156 :     xmlChar *URL = NULL;

	mov	DWORD PTR _URL$[ebp], 0

; 1157 :     xmlCatalogEntryPtr ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 1158 : 
; 1159 :     if (attrName != NULL) {

	cmp	DWORD PTR _attrName$[ebp], 0
	je	SHORT $LN2@xmlParseXM

; 1160 : 	nameValue = xmlGetProp(cur, attrName);

	mov	eax, DWORD PTR _attrName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _nameValue$[ebp], eax

; 1161 : 	if (nameValue == NULL) {

	cmp	DWORD PTR _nameValue$[ebp], 0
	jne	SHORT $LN2@xmlParseXM

; 1162 : 	    xmlCatalogErr(ret, cur, XML_CATALOG_MISSING_ATTR,

	push	0
	mov	edx, DWORD PTR _attrName$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BF@JJKMCIOA@?$CFs?5entry?5lacks?5?8?$CFs?8?6@
	push	1650					; 00000672H
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlCatalogErr
	add	esp, 28					; 0000001cH

; 1163 : 			  "%s entry lacks '%s'\n", name, attrName, NULL);
; 1164 : 	    ok = 0;

	mov	DWORD PTR _ok$[ebp], 0
$LN2@xmlParseXM:

; 1165 : 	}
; 1166 :     }
; 1167 :     uriValue = xmlGetProp(cur, uriAttrName);

	mov	eax, DWORD PTR _uriAttrName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _uriValue$[ebp], eax

; 1168 :     if (uriValue == NULL) {

	cmp	DWORD PTR _uriValue$[ebp], 0
	jne	SHORT $LN4@xmlParseXM

; 1169 : 	xmlCatalogErr(ret, cur, XML_CATALOG_MISSING_ATTR,

	push	0
	mov	edx, DWORD PTR _uriAttrName$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BF@JJKMCIOA@?$CFs?5entry?5lacks?5?8?$CFs?8?6@
	push	1650					; 00000672H
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlCatalogErr
	add	esp, 28					; 0000001cH

; 1170 : 		"%s entry lacks '%s'\n", name, uriAttrName, NULL);
; 1171 : 	ok = 0;

	mov	DWORD PTR _ok$[ebp], 0
$LN4@xmlParseXM:

; 1172 :     }
; 1173 :     if (!ok) {

	cmp	DWORD PTR _ok$[ebp], 0
	jne	SHORT $LN5@xmlParseXM

; 1174 : 	if (nameValue != NULL)

	cmp	DWORD PTR _nameValue$[ebp], 0
	je	SHORT $LN6@xmlParseXM

; 1175 : 	    xmlFree(nameValue);

	mov	esi, esp
	mov	eax, DWORD PTR _nameValue$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@xmlParseXM:

; 1176 : 	if (uriValue != NULL)

	cmp	DWORD PTR _uriValue$[ebp], 0
	je	SHORT $LN7@xmlParseXM

; 1177 : 	    xmlFree(uriValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _uriValue$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlParseXM:

; 1178 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseXM
$LN5@xmlParseXM:

; 1179 :     }
; 1180 : 
; 1181 :     base = xmlNodeGetBase(cur->doc, cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_xmlNodeGetBase
	add	esp, 8
	mov	DWORD PTR _base$[ebp], eax

; 1182 :     URL = xmlBuildURI(uriValue, base);

	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _uriValue$[ebp]
	push	eax
	call	_xmlBuildURI
	add	esp, 8
	mov	DWORD PTR _URL$[ebp], eax

; 1183 :     if (URL != NULL) {

	cmp	DWORD PTR _URL$[ebp], 0
	je	$LN8@xmlParseXM

; 1184 : 	if (xmlDebugCatalogs > 1) {

	cmp	DWORD PTR _xmlDebugCatalogs, 1
	jle	SHORT $LN10@xmlParseXM

; 1185 : 	    if (nameValue != NULL)

	cmp	DWORD PTR _nameValue$[ebp], 0
	je	SHORT $LN11@xmlParseXM

; 1186 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nameValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BF@BGILJEII@Found?5?$CFs?3?5?8?$CFs?8?5?8?$CFs?8?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN10@xmlParseXM
$LN11@xmlParseXM:

; 1187 : 			"Found %s: '%s' '%s'\n", name, nameValue, URL);
; 1188 : 	    else
; 1189 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _URL$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BA@FJAJBNGG@Found?5?$CFs?3?5?8?$CFs?8?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@xmlParseXM:

; 1190 : 			"Found %s: '%s'\n", name, URL);
; 1191 : 	}
; 1192 : 	ret = xmlNewCatalogEntry(type, nameValue, uriValue, URL, prefer, cgroup);

	mov	ecx, DWORD PTR _cgroup$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefer$[ebp]
	push	edx
	mov	eax, DWORD PTR _URL$[ebp]
	push	eax
	mov	ecx, DWORD PTR _uriValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nameValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	call	_xmlNewCatalogEntry
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ret$[ebp], eax

; 1193 :     } else {

	jmp	SHORT $LN9@xmlParseXM
$LN8@xmlParseXM:

; 1194 : 	xmlCatalogErr(ret, cur, XML_CATALOG_ENTRY_BROKEN,

	mov	ecx, DWORD PTR _uriValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uriAttrName$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BM@NDOJAICK@?$CFs?5entry?5?8?$CFs?8?5broken?5?$DP?3?5?$CFs?6@
	push	1651					; 00000673H
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlCatalogErr
	add	esp, 28					; 0000001cH
$LN9@xmlParseXM:

; 1195 : 		"%s entry '%s' broken ?: %s\n", name, uriAttrName, uriValue);
; 1196 :     }
; 1197 :     if (nameValue != NULL)

	cmp	DWORD PTR _nameValue$[ebp], 0
	je	SHORT $LN13@xmlParseXM

; 1198 : 	xmlFree(nameValue);

	mov	esi, esp
	mov	eax, DWORD PTR _nameValue$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@xmlParseXM:

; 1199 :     if (uriValue != NULL)

	cmp	DWORD PTR _uriValue$[ebp], 0
	je	SHORT $LN14@xmlParseXM

; 1200 : 	xmlFree(uriValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _uriValue$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@xmlParseXM:

; 1201 :     if (base != NULL)

	cmp	DWORD PTR _base$[ebp], 0
	je	SHORT $LN15@xmlParseXM

; 1202 : 	xmlFree(base);

	mov	esi, esp
	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@xmlParseXM:

; 1203 :     if (URL != NULL)

	cmp	DWORD PTR _URL$[ebp], 0
	je	SHORT $LN16@xmlParseXM

; 1204 : 	xmlFree(URL);

	mov	esi, esp
	mov	eax, DWORD PTR _URL$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@xmlParseXM:

; 1205 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlParseXM:

; 1206 : }

	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseXMLCatalogOneNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlGetXMLCatalogEntryType
_TEXT	SEGMENT
_type$ = -4						; size = 4
_name$ = 8						; size = 4
_xmlGetXMLCatalogEntryType PROC				; COMDAT

; 1107 : xmlGetXMLCatalogEntryType(const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 1108 :     xmlCatalogEntryType type = XML_CATA_NONE;

	mov	DWORD PTR _type$[ebp], 0

; 1109 :     if (xmlStrEqual(name, (const xmlChar *) "system"))

	push	OFFSET ??_C@_06FHFOAHML@system@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@xmlGetXMLC

; 1110 : 	type = XML_CATA_SYSTEM;

	mov	DWORD PTR _type$[ebp], 6
	jmp	$LN3@xmlGetXMLC
$LN2@xmlGetXMLC:

; 1111 :     else if (xmlStrEqual(name, (const xmlChar *) "public"))

	push	OFFSET ??_C@_06EOMAMIIF@public@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@xmlGetXMLC

; 1112 : 	type = XML_CATA_PUBLIC;

	mov	DWORD PTR _type$[ebp], 5
	jmp	$LN3@xmlGetXMLC
$LN4@xmlGetXMLC:

; 1113 :     else if (xmlStrEqual(name, (const xmlChar *) "rewriteSystem"))

	push	OFFSET ??_C@_0O@CCMDBGLO@rewriteSystem@
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlGetXMLC

; 1114 : 	type = XML_CATA_REWRITE_SYSTEM;

	mov	DWORD PTR _type$[ebp], 7
	jmp	$LN3@xmlGetXMLC
$LN6@xmlGetXMLC:

; 1115 :     else if (xmlStrEqual(name, (const xmlChar *) "delegatePublic"))

	push	OFFSET ??_C@_0P@FNMIEEAK@delegatePublic@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlGetXMLC

; 1116 : 	type = XML_CATA_DELEGATE_PUBLIC;

	mov	DWORD PTR _type$[ebp], 8
	jmp	$LN3@xmlGetXMLC
$LN8@xmlGetXMLC:

; 1117 :     else if (xmlStrEqual(name, (const xmlChar *) "delegateSystem"))

	push	OFFSET ??_C@_0P@EEFGILEE@delegateSystem@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlGetXMLC

; 1118 : 	type = XML_CATA_DELEGATE_SYSTEM;

	mov	DWORD PTR _type$[ebp], 9
	jmp	$LN3@xmlGetXMLC
$LN10@xmlGetXMLC:

; 1119 :     else if (xmlStrEqual(name, (const xmlChar *) "uri"))

	push	OFFSET ??_C@_03GBBABMJN@uri@
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlGetXMLC

; 1120 : 	type = XML_CATA_URI;

	mov	DWORD PTR _type$[ebp], 10		; 0000000aH
	jmp	SHORT $LN3@xmlGetXMLC
$LN12@xmlGetXMLC:

; 1121 :     else if (xmlStrEqual(name, (const xmlChar *) "rewriteURI"))

	push	OFFSET ??_C@_0L@BCFABNDK@rewriteURI@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlGetXMLC

; 1122 : 	type = XML_CATA_REWRITE_URI;

	mov	DWORD PTR _type$[ebp], 11		; 0000000bH
	jmp	SHORT $LN3@xmlGetXMLC
$LN14@xmlGetXMLC:

; 1123 :     else if (xmlStrEqual(name, (const xmlChar *) "delegateURI"))

	push	OFFSET ??_C@_0M@NHAMNMJD@delegateURI@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlGetXMLC

; 1124 : 	type = XML_CATA_DELEGATE_URI;

	mov	DWORD PTR _type$[ebp], 12		; 0000000cH
	jmp	SHORT $LN3@xmlGetXMLC
$LN16@xmlGetXMLC:

; 1125 :     else if (xmlStrEqual(name, (const xmlChar *) "nextCatalog"))

	push	OFFSET ??_C@_0M@IKOOEBPK@nextCatalog@
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlGetXMLC

; 1126 : 	type = XML_CATA_NEXT_CATALOG;

	mov	DWORD PTR _type$[ebp], 3
	jmp	SHORT $LN3@xmlGetXMLC
$LN18@xmlGetXMLC:

; 1127 :     else if (xmlStrEqual(name, (const xmlChar *) "catalog"))

	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@xmlGetXMLC

; 1128 : 	type = XML_CATA_CATALOG;

	mov	DWORD PTR _type$[ebp], 1
$LN3@xmlGetXMLC:

; 1129 :     return(type);

	mov	eax, DWORD PTR _type$[ebp]

; 1130 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlGetXMLCatalogEntryType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogListXMLResolveURI
_TEXT	SEGMENT
_urnID$ = -8						; size = 4
_ret$ = -4						; size = 4
_catal$ = 8						; size = 4
_URI$ = 12						; size = 4
_xmlCatalogListXMLResolveURI PROC			; COMDAT

; 2099 : xmlCatalogListXMLResolveURI(xmlCatalogEntryPtr catal, const xmlChar *URI) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2100 :     xmlChar *ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 2101 :     xmlChar *urnID = NULL;

	mov	DWORD PTR _urnID$[ebp], 0

; 2102 : 
; 2103 :     if (catal == NULL)

	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN4@xmlCatalog

; 2104 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCatalog
$LN4@xmlCatalog:

; 2105 :     if (URI == NULL)

	cmp	DWORD PTR _URI$[ebp], 0
	jne	SHORT $LN5@xmlCatalog

; 2106 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCatalog
$LN5@xmlCatalog:

; 2107 : 
; 2108 :     if (!xmlStrncmp(URI, BAD_CAST XML_URN_PUBID, sizeof(XML_URN_PUBID) - 1)) {

	push	13					; 0000000dH
	push	OFFSET ??_C@_0O@NOBDOKAH@urn?3publicid?3@
	mov	eax, DWORD PTR _URI$[ebp]
	push	eax
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN2@xmlCatalog

; 2109 : 	urnID = xmlCatalogUnWrapURN(URI);

	mov	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	call	_xmlCatalogUnWrapURN
	add	esp, 4
	mov	DWORD PTR _urnID$[ebp], eax

; 2110 : 	if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN7@xmlCatalog

; 2111 : 	    if (urnID == NULL)

	cmp	DWORD PTR _urnID$[ebp], 0
	jne	SHORT $LN8@xmlCatalog

; 2112 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	edx, DWORD PTR _URI$[ebp]
	push	edx
	push	OFFSET ??_C@_0BM@FKFGGIIN@URN?5ID?5?$CFs?5expanded?5to?5NULL?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN7@xmlCatalog
$LN8@xmlCatalog:

; 2113 : 			"URN ID %s expanded to NULL\n", URI);
; 2114 : 	    else
; 2115 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	edx, DWORD PTR _urnID$[ebp]
	push	edx
	push	OFFSET ??_C@_0BH@CIFAIMNL@URN?5ID?5expanded?5to?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlCatalog:

; 2116 : 			"URN ID expanded to %s\n", urnID);
; 2117 : 	}
; 2118 : 	ret = xmlCatalogListXMLResolve(catal, urnID, NULL);

	push	0
	mov	edx, DWORD PTR _urnID$[ebp]
	push	edx
	mov	eax, DWORD PTR _catal$[ebp]
	push	eax
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 2119 : 	if (urnID != NULL)

	cmp	DWORD PTR _urnID$[ebp], 0
	je	SHORT $LN10@xmlCatalog

; 2120 : 	    xmlFree(urnID);

	mov	esi, esp
	mov	ecx, DWORD PTR _urnID$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@xmlCatalog:

; 2121 : 	return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlCatalog
$LN2@xmlCatalog:

; 2122 :     }
; 2123 :     while (catal != NULL) {

	cmp	DWORD PTR _catal$[ebp], 0
	je	SHORT $LN3@xmlCatalog

; 2124 : 	if (catal->type == XML_CATA_CATALOG) {

	mov	edx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [edx+12], 1
	jne	SHORT $LN11@xmlCatalog

; 2125 : 	    if (catal->children == NULL) {

	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN12@xmlCatalog

; 2126 : 		xmlFetchXMLCatalogFile(catal);

	mov	ecx, DWORD PTR _catal$[ebp]
	push	ecx
	call	_xmlFetchXMLCatalogFile
	add	esp, 4
$LN12@xmlCatalog:

; 2127 : 	    }
; 2128 : 	    if (catal->children != NULL) {

	mov	edx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN11@xmlCatalog

; 2129 : 		ret = xmlCatalogXMLResolveURI(catal->children, URI);

	mov	eax, DWORD PTR _URI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlCatalogXMLResolveURI
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2130 : 		if (ret != NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN11@xmlCatalog

; 2131 : 		    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlCatalog
$LN11@xmlCatalog:

; 2132 : 	    }
; 2133 : 	}
; 2134 : 	catal = catal->next;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _catal$[ebp], ecx

; 2135 :     }

	jmp	SHORT $LN2@xmlCatalog
$LN3@xmlCatalog:

; 2136 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlCatalog:

; 2137 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogListXMLResolveURI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogListXMLResolve
_TEXT	SEGMENT
tv72 = -16						; size = 4
_normid$ = -12						; size = 4
_urnID$ = -8						; size = 4
_ret$ = -4						; size = 4
_catal$ = 8						; size = 4
_pubID$ = 12						; size = 4
_sysID$ = 16						; size = 4
_xmlCatalogListXMLResolve PROC				; COMDAT

; 2009 : 	              const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2010 :     xmlChar *ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 2011 :     xmlChar *urnID = NULL;

	mov	DWORD PTR _urnID$[ebp], 0

; 2012 :     xmlChar *normid;
; 2013 : 
; 2014 :     if (catal == NULL)

	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN4@xmlCatalog

; 2015 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCatalog
$LN4@xmlCatalog:

; 2016 :     if ((pubID == NULL) && (sysID == NULL))

	cmp	DWORD PTR _pubID$[ebp], 0
	jne	SHORT $LN5@xmlCatalog
	cmp	DWORD PTR _sysID$[ebp], 0
	jne	SHORT $LN5@xmlCatalog

; 2017 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCatalog
$LN5@xmlCatalog:

; 2018 : 
; 2019 :     normid = xmlCatalogNormalizePublic(pubID);

	mov	eax, DWORD PTR _pubID$[ebp]
	push	eax
	call	_xmlCatalogNormalizePublic
	add	esp, 4
	mov	DWORD PTR _normid$[ebp], eax

; 2020 :     if (normid != NULL)

	cmp	DWORD PTR _normid$[ebp], 0
	je	SHORT $LN6@xmlCatalog

; 2021 :         pubID = (*normid != 0 ? normid : NULL);

	mov	ecx, DWORD PTR _normid$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN31@xmlCatalog
	mov	eax, DWORD PTR _normid$[ebp]
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN32@xmlCatalog
$LN31@xmlCatalog:
	mov	DWORD PTR tv72[ebp], 0
$LN32@xmlCatalog:
	mov	ecx, DWORD PTR tv72[ebp]
	mov	DWORD PTR _pubID$[ebp], ecx
$LN6@xmlCatalog:

; 2022 : 
; 2023 :     if (!xmlStrncmp(pubID, BAD_CAST XML_URN_PUBID, sizeof(XML_URN_PUBID) - 1)) {

	push	13					; 0000000dH
	push	OFFSET ??_C@_0O@NOBDOKAH@urn?3publicid?3@
	mov	edx, DWORD PTR _pubID$[ebp]
	push	edx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN7@xmlCatalog

; 2024 : 	urnID = xmlCatalogUnWrapURN(pubID);

	mov	eax, DWORD PTR _pubID$[ebp]
	push	eax
	call	_xmlCatalogUnWrapURN
	add	esp, 4
	mov	DWORD PTR _urnID$[ebp], eax

; 2025 : 	if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN8@xmlCatalog

; 2026 : 	    if (urnID == NULL)

	cmp	DWORD PTR _urnID$[ebp], 0
	jne	SHORT $LN9@xmlCatalog

; 2027 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _pubID$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CD@CFKEBFJH@Public?5URN?5ID?5?$CFs?5expanded?5to?5NU@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN8@xmlCatalog
$LN9@xmlCatalog:

; 2028 : 			"Public URN ID %s expanded to NULL\n", pubID);
; 2029 : 	    else
; 2030 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _urnID$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BO@PMAINHBC@Public?5URN?5ID?5expanded?5to?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@xmlCatalog:

; 2031 : 			"Public URN ID expanded to %s\n", urnID);
; 2032 : 	}
; 2033 : 	ret = xmlCatalogListXMLResolve(catal, urnID, sysID);

	mov	ecx, DWORD PTR _sysID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _urnID$[ebp]
	push	edx
	mov	eax, DWORD PTR _catal$[ebp]
	push	eax
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 2034 : 	if (urnID != NULL)

	cmp	DWORD PTR _urnID$[ebp], 0
	je	SHORT $LN11@xmlCatalog

; 2035 : 	    xmlFree(urnID);

	mov	esi, esp
	mov	ecx, DWORD PTR _urnID$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlCatalog:

; 2036 : 	if (normid != NULL)

	cmp	DWORD PTR _normid$[ebp], 0
	je	SHORT $LN12@xmlCatalog

; 2037 : 	    xmlFree(normid);

	mov	esi, esp
	mov	edx, DWORD PTR _normid$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlCatalog:

; 2038 : 	return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlCatalog
$LN7@xmlCatalog:

; 2039 :     }
; 2040 :     if (!xmlStrncmp(sysID, BAD_CAST XML_URN_PUBID, sizeof(XML_URN_PUBID) - 1)) {

	push	13					; 0000000dH
	push	OFFSET ??_C@_0O@NOBDOKAH@urn?3publicid?3@
	mov	eax, DWORD PTR _sysID$[ebp]
	push	eax
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN2@xmlCatalog

; 2041 : 	urnID = xmlCatalogUnWrapURN(sysID);

	mov	ecx, DWORD PTR _sysID$[ebp]
	push	ecx
	call	_xmlCatalogUnWrapURN
	add	esp, 4
	mov	DWORD PTR _urnID$[ebp], eax

; 2042 : 	if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN14@xmlCatalog

; 2043 : 	    if (urnID == NULL)

	cmp	DWORD PTR _urnID$[ebp], 0
	jne	SHORT $LN15@xmlCatalog

; 2044 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	edx, DWORD PTR _sysID$[ebp]
	push	edx
	push	OFFSET ??_C@_0CD@CPPNJIKG@System?5URN?5ID?5?$CFs?5expanded?5to?5NU@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN14@xmlCatalog
$LN15@xmlCatalog:

; 2045 : 			"System URN ID %s expanded to NULL\n", sysID);
; 2046 : 	    else
; 2047 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	edx, DWORD PTR _urnID$[ebp]
	push	edx
	push	OFFSET ??_C@_0BO@PPGKEABI@System?5URN?5ID?5expanded?5to?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@xmlCatalog:

; 2048 : 			"System URN ID expanded to %s\n", urnID);
; 2049 : 	}
; 2050 : 	if (pubID == NULL)

	cmp	DWORD PTR _pubID$[ebp], 0
	jne	SHORT $LN17@xmlCatalog

; 2051 : 	    ret = xmlCatalogListXMLResolve(catal, urnID, NULL);

	push	0
	mov	edx, DWORD PTR _urnID$[ebp]
	push	edx
	mov	eax, DWORD PTR _catal$[ebp]
	push	eax
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax
	jmp	SHORT $LN18@xmlCatalog
$LN17@xmlCatalog:

; 2052 : 	else if (xmlStrEqual(pubID, urnID))

	mov	ecx, DWORD PTR _urnID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pubID$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@xmlCatalog

; 2053 : 	    ret = xmlCatalogListXMLResolve(catal, pubID, NULL);

	push	0
	mov	eax, DWORD PTR _pubID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _catal$[ebp]
	push	ecx
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax
	jmp	SHORT $LN18@xmlCatalog
$LN19@xmlCatalog:

; 2054 : 	else {
; 2055 : 	    ret = xmlCatalogListXMLResolve(catal, pubID, urnID);

	mov	edx, DWORD PTR _urnID$[ebp]
	push	edx
	mov	eax, DWORD PTR _pubID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _catal$[ebp]
	push	ecx
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax
$LN18@xmlCatalog:

; 2056 : 	}
; 2057 : 	if (urnID != NULL)

	cmp	DWORD PTR _urnID$[ebp], 0
	je	SHORT $LN21@xmlCatalog

; 2058 : 	    xmlFree(urnID);

	mov	esi, esp
	mov	edx, DWORD PTR _urnID$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN21@xmlCatalog:

; 2059 : 	if (normid != NULL)

	cmp	DWORD PTR _normid$[ebp], 0
	je	SHORT $LN22@xmlCatalog

; 2060 : 	    xmlFree(normid);

	mov	esi, esp
	mov	eax, DWORD PTR _normid$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN22@xmlCatalog:

; 2061 : 	return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlCatalog
$LN2@xmlCatalog:

; 2062 :     }
; 2063 :     while (catal != NULL) {

	cmp	DWORD PTR _catal$[ebp], 0
	je	SHORT $LN3@xmlCatalog

; 2064 : 	if (catal->type == XML_CATA_CATALOG) {

	mov	ecx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [ecx+12], 1
	jne	SHORT $LN23@xmlCatalog

; 2065 : 	    if (catal->children == NULL) {

	mov	edx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN24@xmlCatalog

; 2066 : 		xmlFetchXMLCatalogFile(catal);

	mov	eax, DWORD PTR _catal$[ebp]
	push	eax
	call	_xmlFetchXMLCatalogFile
	add	esp, 4
$LN24@xmlCatalog:

; 2067 : 	    }
; 2068 : 	    if (catal->children != NULL) {

	mov	ecx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN23@xmlCatalog

; 2069 : 		ret = xmlCatalogXMLResolve(catal->children, pubID, sysID);

	mov	edx, DWORD PTR _sysID$[ebp]
	push	edx
	mov	eax, DWORD PTR _pubID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlCatalogXMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 2070 : 		if (ret != NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN26@xmlCatalog

; 2071 : 		    break;

	jmp	SHORT $LN3@xmlCatalog
	jmp	SHORT $LN23@xmlCatalog
$LN26@xmlCatalog:

; 2072 :                 } else if ((catal->children != NULL) &&

	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN23@xmlCatalog
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+36], 50			; 00000032H
	jle	SHORT $LN23@xmlCatalog

; 2073 : 		           (catal->children->depth > MAX_CATAL_DEPTH)) {
; 2074 : 	            ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 2075 : 		    break;

	jmp	SHORT $LN3@xmlCatalog
$LN23@xmlCatalog:

; 2076 : 	        }
; 2077 : 	    }
; 2078 : 	}
; 2079 : 	catal = catal->next;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _catal$[ebp], ecx

; 2080 :     }

	jmp	SHORT $LN2@xmlCatalog
$LN3@xmlCatalog:

; 2081 :     if (normid != NULL)

	cmp	DWORD PTR _normid$[ebp], 0
	je	SHORT $LN29@xmlCatalog

; 2082 : 	xmlFree(normid);

	mov	esi, esp
	mov	edx, DWORD PTR _normid$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN29@xmlCatalog:

; 2083 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlCatalog:

; 2084 : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogListXMLResolve ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseXMLCatalogNodeList
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_prefer$ = 12						; size = 4
_parent$ = 16						; size = 4
_cgroup$ = 20						; size = 4
_xmlParseXMLCatalogNodeList PROC			; COMDAT

; 1324 : 	                   xmlCatalogEntryPtr parent, xmlCatalogEntryPtr cgroup) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlParseXM:

; 1325 :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@xmlParseXM

; 1326 : 	if ((cur->ns != NULL) && (cur->ns->href != NULL) &&

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN4@xmlParseXM
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN4@xmlParseXM
	push	OFFSET ??_C@_0CM@FMEFCNGF@urn?3oasis?3names?3tc?3entity?3xmlns@
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@xmlParseXM

; 1327 : 	    (xmlStrEqual(cur->ns->href, XML_CATALOGS_NAMESPACE))) {
; 1328 : 	    xmlParseXMLCatalogNode(cur, prefer, parent, cgroup);

	mov	eax, DWORD PTR _cgroup$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefer$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlParseXMLCatalogNode
	add	esp, 16					; 00000010H
$LN4@xmlParseXM:

; 1329 : 	}
; 1330 : 	cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$[ebp], edx

; 1331 :     }

	jmp	SHORT $LN2@xmlParseXM
$LN1@xmlParseXM:

; 1332 :     /* TODO: sort the list according to REWRITE lengths and prefer value */
; 1333 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlParseXMLCatalogNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseXMLCatalogFile
_TEXT	SEGMENT
_parent$ = -16						; size = 4
_prop$ = -12						; size = 4
_cur$ = -8						; size = 4
_doc$ = -4						; size = 4
_prefer$ = 8						; size = 4
_filename$ = 12						; size = 4
_xmlParseXMLCatalogFile PROC				; COMDAT

; 1346 : xmlParseXMLCatalogFile(xmlCatalogPrefer prefer, const xmlChar *filename) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 1347 :     xmlDocPtr doc;
; 1348 :     xmlNodePtr cur;
; 1349 :     xmlChar *prop;
; 1350 :     xmlCatalogEntryPtr parent = NULL;

	mov	DWORD PTR _parent$[ebp], 0

; 1351 : 
; 1352 :     if (filename == NULL)

	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN2@xmlParseXM

; 1353 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseXM
$LN2@xmlParseXM:

; 1354 : 
; 1355 :     doc = xmlParseCatalogFile((const char *) filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlParseCatalogFile
	add	esp, 4
	mov	DWORD PTR _doc$[ebp], eax

; 1356 :     if (doc == NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN3@xmlParseXM

; 1357 : 	if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN4@xmlParseXM

; 1358 : 	    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BM@BEDEBNKA@Failed?5to?5parse?5catalog?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlParseXM:

; 1359 : 		    "Failed to parse catalog %s\n", filename);
; 1360 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseXM
$LN3@xmlParseXM:

; 1361 :     }
; 1362 : 
; 1363 :     if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN5@xmlParseXM

; 1364 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_xmlGetThreadId
	push	eax
	push	OFFSET ??_C@_0BH@HBOEOPJE@?$CFd?5Parsing?5catalog?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@xmlParseXM:

; 1365 : 		"%d Parsing catalog %s\n", xmlGetThreadId(), filename);
; 1366 : 
; 1367 :     cur = xmlDocGetRootElement(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 1368 :     if ((cur != NULL) && (xmlStrEqual(cur->name, BAD_CAST "catalog")) &&
; 1369 : 	(cur->ns != NULL) && (cur->ns->href != NULL) &&

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN6@xmlParseXM
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN6@xmlParseXM
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	$LN6@xmlParseXM
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax+8], 0
	je	$LN6@xmlParseXM
	push	OFFSET ??_C@_0CM@FMEFCNGF@urn?3oasis?3names?3tc?3entity?3xmlns@
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN6@xmlParseXM

; 1370 : 	(xmlStrEqual(cur->ns->href, XML_CATALOGS_NAMESPACE))) {
; 1371 : 
; 1372 : 	parent = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,

	push	0
	mov	ecx, DWORD PTR _prefer$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	0
	push	1
	call	_xmlNewCatalogEntry
	add	esp, 24					; 00000018H
	mov	DWORD PTR _parent$[ebp], eax

; 1373 : 				    (const xmlChar *)filename, NULL, prefer, NULL);
; 1374 :         if (parent == NULL) {

	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN8@xmlParseXM

; 1375 : 	    xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 1376 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseXM
$LN8@xmlParseXM:

; 1377 : 	}
; 1378 : 
; 1379 : 	prop = xmlGetProp(cur, BAD_CAST "prefer");

	push	OFFSET ??_C@_06NEJLBODN@prefer@
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _prop$[ebp], eax

; 1380 : 	if (prop != NULL) {

	cmp	DWORD PTR _prop$[ebp], 0
	je	SHORT $LN9@xmlParseXM

; 1381 : 	    if (xmlStrEqual(prop, BAD_CAST "system")) {

	push	OFFSET ??_C@_06FHFOAHML@system@
	mov	edx, DWORD PTR _prop$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlParseXM

; 1382 : 		prefer = XML_CATA_PREFER_SYSTEM;

	mov	DWORD PTR _prefer$[ebp], 2
	jmp	SHORT $LN11@xmlParseXM
$LN10@xmlParseXM:

; 1383 : 	    } else if (xmlStrEqual(prop, BAD_CAST "public")) {

	push	OFFSET ??_C@_06EOMAMIIF@public@
	mov	eax, DWORD PTR _prop$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlParseXM

; 1384 : 		prefer = XML_CATA_PREFER_PUBLIC;

	mov	DWORD PTR _prefer$[ebp], 1

; 1385 : 	    } else {

	jmp	SHORT $LN11@xmlParseXM
$LN12@xmlParseXM:

; 1386 : 		xmlCatalogErr(NULL, cur, XML_CATALOG_PREFER_VALUE,

	push	0
	push	0
	mov	ecx, DWORD PTR _prop$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CA@KIJKHIJM@Invalid?5value?5for?5prefer?3?5?8?$CFs?8?6@
	push	1652					; 00000674H
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	push	0
	call	_xmlCatalogErr
	add	esp, 28					; 0000001cH
$LN11@xmlParseXM:

; 1387 : 			      "Invalid value for prefer: '%s'\n",
; 1388 : 			      prop, NULL, NULL);
; 1389 : 	    }
; 1390 : 	    xmlFree(prop);

	mov	esi, esp
	mov	eax, DWORD PTR _prop$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@xmlParseXM:

; 1391 : 	}
; 1392 : 	cur = cur->children;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx

; 1393 : 	xmlParseXMLCatalogNodeList(cur, prefer, parent, NULL);

	push	0
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlParseXMLCatalogNodeList
	add	esp, 16					; 00000010H

; 1394 :     } else {

	jmp	SHORT $LN7@xmlParseXM
$LN6@xmlParseXM:

; 1395 : 	xmlCatalogErr(NULL, (xmlNodePtr) doc, XML_CATALOG_NOT_CATALOG,

	push	0
	push	0
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@DJPOHLHG@File?5?$CFs?5is?5not?5an?5XML?5Catalog?6@
	push	1653					; 00000675H
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	push	0
	call	_xmlCatalogErr
	add	esp, 28					; 0000001cH

; 1396 : 		      "File %s is not an XML Catalog\n",
; 1397 : 		      filename, NULL, NULL);
; 1398 : 	xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 1399 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseXM
$LN7@xmlParseXM:

; 1400 :     }
; 1401 :     xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 1402 :     return(parent);

	mov	eax, DWORD PTR _parent$[ebp]
$LN1@xmlParseXM:

; 1403 : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseXMLCatalogFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\sys\stat.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlLoadFileContent
_TEXT	SEGMENT
_content$ = -72						; size = 4
_info$ = -64						; size = 48
_size$ = -12						; size = 4
_len$ = -8						; size = 4
_fd$ = -4						; size = 4
_filename$ = 8						; size = 4
_xmlLoadFileContent PROC				; COMDAT

; 961  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 962  : #ifdef HAVE_STAT
; 963  :     int fd;
; 964  : #else
; 965  :     FILE *fd;
; 966  : #endif
; 967  :     int len;
; 968  :     long size;
; 969  : 
; 970  : #ifdef HAVE_STAT
; 971  :     struct stat info;
; 972  : #endif
; 973  :     xmlChar *content;
; 974  : 
; 975  :     if (filename == NULL)

	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN8@xmlLoadFil

; 976  :         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlLoadFil
$LN8@xmlLoadFil:
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\sys\stat.h

; 242  :             return _stat64i32(_FileName, (struct _stat64i32*)_Stat);

	mov	esi, esp
	lea	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	DWORD PTR __imp___stat64i32
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c

; 979  :     if (stat(filename, &info) < 0)

	test	eax, eax
	jge	SHORT $LN3@xmlLoadFil

; 980  :         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlLoadFil
$LN3@xmlLoadFil:

; 981  : #endif
; 982  : 
; 983  : #ifdef HAVE_STAT
; 984  :     if ((fd = open(filename, O_RDONLY)) < 0)

	mov	esi, esp
	push	0
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	DWORD PTR __imp__open
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _fd$[ebp], eax
	cmp	DWORD PTR _fd$[ebp], 0
	jge	SHORT $LN4@xmlLoadFil

; 985  : #else
; 986  :     if ((fd = fopen(filename, "rb")) == NULL)
; 987  : #endif
; 988  :     {
; 989  :         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlLoadFil
$LN4@xmlLoadFil:

; 990  :     }
; 991  : #ifdef HAVE_STAT
; 992  :     size = info.st_size;

	mov	eax, DWORD PTR _info$[ebp+20]
	mov	DWORD PTR _size$[ebp], eax

; 993  : #else
; 994  :     if (fseek(fd, 0, SEEK_END) || (size = ftell(fd)) == EOF || fseek(fd, 0, SEEK_SET)) {        /* File operations denied? ok, just close and return failure */
; 995  :         fclose(fd);
; 996  :         return (NULL);
; 997  :     }
; 998  : #endif
; 999  :     content = (xmlChar*)xmlMallocAtomic(size + 10);

	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, 10					; 0000000aH
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _content$[ebp], eax

; 1000 :     if (content == NULL) {

	cmp	DWORD PTR _content$[ebp], 0
	jne	SHORT $LN5@xmlLoadFil

; 1001 :         xmlCatalogErrMemory("allocating catalog data");

	push	OFFSET ??_C@_0BI@CBBLIKLJ@allocating?5catalog?5data@
	call	_xmlCatalogErrMemory
	add	esp, 4

; 1002 : #ifdef HAVE_STAT
; 1003 : 	close(fd);

	mov	esi, esp
	mov	edx, DWORD PTR _fd$[ebp]
	push	edx
	call	DWORD PTR __imp__close
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1004 : #else
; 1005 : 	fclose(fd);
; 1006 : #endif
; 1007 :         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlLoadFil
$LN5@xmlLoadFil:

; 1008 :     }
; 1009 : #ifdef HAVE_STAT
; 1010 :     len = read(fd, content, size);

	mov	esi, esp
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _content$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fd$[ebp]
	push	edx
	call	DWORD PTR __imp__read
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _len$[ebp], eax

; 1011 :     close(fd);

	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	call	DWORD PTR __imp__close
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1012 : #else
; 1013 :     len = fread(content, 1, size, fd);
; 1014 :     fclose(fd);
; 1015 : #endif
; 1016 :     if (len < 0) {

	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN6@xmlLoadFil

; 1017 :         xmlFree(content);

	mov	esi, esp
	mov	ecx, DWORD PTR _content$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1018 :         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlLoadFil
$LN6@xmlLoadFil:

; 1019 :     }
; 1020 :     content[len] = 0;

	mov	edx, DWORD PTR _content$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 0

; 1021 : 
; 1022 :     return(content);

	mov	eax, DWORD PTR _content$[ebp]
$LN1@xmlLoadFil:

; 1023 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@xmlLoadFil
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 72					; 00000048H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN12@xmlLoadFil:
	DD	1
	DD	$LN11@xmlLoadFil
$LN11@xmlLoadFil:
	DD	-64					; ffffffc0H
	DD	48					; 00000030H
	DD	$LN10@xmlLoadFil
$LN10@xmlLoadFil:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
_xmlLoadFileContent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogUnWrapURN
_TEXT	SEGMENT
_i$ = -2012						; size = 4
_result$ = -2004					; size = 2000
_urn$ = 8						; size = 4
_xmlCatalogUnWrapURN PROC				; COMDAT

; 827  : xmlCatalogUnWrapURN(const xmlChar *urn) {

	push	ebp
	mov	ebp, esp
	sub	esp, 2012				; 000007dcH
	push	edi
	lea	edi, DWORD PTR [ebp-2012]
	mov	ecx, 503				; 000001f7H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 828  :     xmlChar result[2000];
; 829  :     unsigned int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 830  : 
; 831  :     if (xmlStrncmp(urn, BAD_CAST XML_URN_PUBID, sizeof(XML_URN_PUBID) - 1))

	push	13					; 0000000dH
	push	OFFSET ??_C@_0O@NOBDOKAH@urn?3publicid?3@
	mov	eax, DWORD PTR _urn$[ebp]
	push	eax
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@xmlCatalog

; 832  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCatalog
$LN4@xmlCatalog:

; 833  :     urn += sizeof(XML_URN_PUBID) - 1;

	mov	ecx, DWORD PTR _urn$[ebp]
	add	ecx, 13					; 0000000dH
	mov	DWORD PTR _urn$[ebp], ecx
$LN2@xmlCatalog:

; 834  : 
; 835  :     while (*urn != 0) {

	mov	edx, DWORD PTR _urn$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN3@xmlCatalog

; 836  : 	if (i > sizeof(result) - 4)

	cmp	DWORD PTR _i$[ebp], 1996		; 000007ccH
	jbe	SHORT $LN5@xmlCatalog

; 837  : 	    break;

	jmp	$LN3@xmlCatalog
$LN5@xmlCatalog:

; 838  : 	if (*urn == '+') {

	mov	ecx, DWORD PTR _urn$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN6@xmlCatalog

; 839  : 	    result[i++] = ' ';

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _result$[ebp+eax], 32		; 00000020H
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 840  : 	    urn++;

	mov	edx, DWORD PTR _urn$[ebp]
	add	edx, 1
	mov	DWORD PTR _urn$[ebp], edx
	jmp	$LN7@xmlCatalog
$LN6@xmlCatalog:

; 841  : 	} else if (*urn == ':') {

	mov	eax, DWORD PTR _urn$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN8@xmlCatalog

; 842  : 	    result[i++] = '/';

	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _result$[ebp+edx], 47		; 0000002fH
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 843  : 	    result[i++] = '/';

	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _result$[ebp+ecx], 47		; 0000002fH
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 844  : 	    urn++;

	mov	eax, DWORD PTR _urn$[ebp]
	add	eax, 1
	mov	DWORD PTR _urn$[ebp], eax
	jmp	$LN7@xmlCatalog
$LN8@xmlCatalog:

; 845  : 	} else if (*urn == ';') {

	mov	ecx, DWORD PTR _urn$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 59					; 0000003bH
	jne	SHORT $LN10@xmlCatalog

; 846  : 	    result[i++] = ':';

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _result$[ebp+eax], 58		; 0000003aH
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 847  : 	    result[i++] = ':';

	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _result$[ebp+edx], 58		; 0000003aH
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 848  : 	    urn++;

	mov	ecx, DWORD PTR _urn$[ebp]
	add	ecx, 1
	mov	DWORD PTR _urn$[ebp], ecx
	jmp	$LN7@xmlCatalog
$LN10@xmlCatalog:

; 849  : 	} else if (*urn == '%') {

	mov	edx, DWORD PTR _urn$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 37					; 00000025H
	jne	$LN12@xmlCatalog

; 850  : 	    if ((urn[1] == '2') && (urn[2] == 'B'))

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _urn$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 50					; 00000032H
	jne	SHORT $LN14@xmlCatalog
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _urn$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 66					; 00000042H
	jne	SHORT $LN14@xmlCatalog

; 851  : 		result[i++] = '+';

	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _result$[ebp+ecx], 43		; 0000002bH
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	$LN15@xmlCatalog
$LN14@xmlCatalog:

; 852  : 	    else if ((urn[1] == '3') && (urn[2] == 'A'))

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _urn$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 51					; 00000033H
	jne	SHORT $LN16@xmlCatalog
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _urn$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 65					; 00000041H
	jne	SHORT $LN16@xmlCatalog

; 853  : 		result[i++] = ':';

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _result$[ebp+eax], 58		; 0000003aH
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	$LN15@xmlCatalog
$LN16@xmlCatalog:

; 854  : 	    else if ((urn[1] == '2') && (urn[2] == 'F'))

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _urn$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 50					; 00000032H
	jne	SHORT $LN18@xmlCatalog
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _urn$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 70					; 00000046H
	jne	SHORT $LN18@xmlCatalog

; 855  : 		result[i++] = '/';

	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _result$[ebp+edx], 47		; 0000002fH
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	$LN15@xmlCatalog
$LN18@xmlCatalog:

; 856  : 	    else if ((urn[1] == '3') && (urn[2] == 'B'))

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _urn$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 51					; 00000033H
	jne	SHORT $LN20@xmlCatalog
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _urn$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 66					; 00000042H
	jne	SHORT $LN20@xmlCatalog

; 857  : 		result[i++] = ';';

	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _result$[ebp+ecx], 59		; 0000003bH
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	$LN15@xmlCatalog
$LN20@xmlCatalog:

; 858  : 	    else if ((urn[1] == '2') && (urn[2] == '7'))

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _urn$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 50					; 00000032H
	jne	SHORT $LN22@xmlCatalog
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _urn$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 55					; 00000037H
	jne	SHORT $LN22@xmlCatalog

; 859  : 		result[i++] = '\'';

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _result$[ebp+eax], 39		; 00000027H
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	$LN15@xmlCatalog
$LN22@xmlCatalog:

; 860  : 	    else if ((urn[1] == '3') && (urn[2] == 'F'))

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _urn$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 51					; 00000033H
	jne	SHORT $LN24@xmlCatalog
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _urn$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 70					; 00000046H
	jne	SHORT $LN24@xmlCatalog

; 861  : 		result[i++] = '?';

	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _result$[ebp+edx], 63		; 0000003fH
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	$LN15@xmlCatalog
$LN24@xmlCatalog:

; 862  : 	    else if ((urn[1] == '2') && (urn[2] == '3'))

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _urn$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 50					; 00000032H
	jne	SHORT $LN26@xmlCatalog
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _urn$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 51					; 00000033H
	jne	SHORT $LN26@xmlCatalog

; 863  : 		result[i++] = '#';

	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _result$[ebp+ecx], 35		; 00000023H
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN15@xmlCatalog
$LN26@xmlCatalog:

; 864  : 	    else if ((urn[1] == '2') && (urn[2] == '5'))

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _urn$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 50					; 00000032H
	jne	SHORT $LN28@xmlCatalog
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _urn$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 53					; 00000035H
	jne	SHORT $LN28@xmlCatalog

; 865  : 		result[i++] = '%';

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _result$[ebp+eax], 37		; 00000025H
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN15@xmlCatalog
$LN28@xmlCatalog:

; 866  : 	    else {
; 867  : 		result[i++] = *urn;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _urn$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _result$[ebp+edx], cl
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 868  : 		urn++;

	mov	eax, DWORD PTR _urn$[ebp]
	add	eax, 1
	mov	DWORD PTR _urn$[ebp], eax

; 869  : 		continue;

	jmp	$LN2@xmlCatalog
$LN15@xmlCatalog:

; 870  : 	    }
; 871  : 	    urn += 3;

	mov	ecx, DWORD PTR _urn$[ebp]
	add	ecx, 3
	mov	DWORD PTR _urn$[ebp], ecx

; 872  : 	} else {

	jmp	SHORT $LN7@xmlCatalog
$LN12@xmlCatalog:

; 873  : 	    result[i++] = *urn;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _urn$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _result$[ebp+edx], cl
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 874  : 	    urn++;

	mov	eax, DWORD PTR _urn$[ebp]
	add	eax, 1
	mov	DWORD PTR _urn$[ebp], eax
$LN7@xmlCatalog:

; 875  : 	}
; 876  :     }

	jmp	$LN2@xmlCatalog
$LN3@xmlCatalog:

; 877  :     result[i] = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _result$[ebp+ecx], 0

; 878  : 
; 879  :     return(xmlStrdup(result));

	lea	edx, DWORD PTR _result$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
$LN1@xmlCatalog:

; 880  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN34@xmlCatalog
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 2012				; 000007dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xmlCatalog:
	DD	1
	DD	$LN33@xmlCatalog
$LN33@xmlCatalog:
	DD	-2004					; fffff82cH
	DD	2000					; 000007d0H
	DD	$LN32@xmlCatalog
$LN32@xmlCatalog:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
_xmlCatalogUnWrapURN ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogConvertEntry
_TEXT	SEGMENT
tv71 = -16						; size = 4
_prev$1 = -12						; size = 4
_catal$ = -8						; size = 4
_entry$ = -4						; size = 4
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlCatalogConvertEntry PROC				; COMDAT

; 732  :                        const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 733  :     xmlCatalogEntryPtr entry = (xmlCatalogEntryPtr) payload;

	mov	eax, DWORD PTR _payload$[ebp]
	mov	DWORD PTR _entry$[ebp], eax

; 734  :     xmlCatalogPtr catal = (xmlCatalogPtr) data;

	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR _catal$[ebp], ecx

; 735  :     if ((entry == NULL) || (catal == NULL) || (catal->sgml == NULL) ||

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN7@xmlCatalog
	cmp	DWORD PTR _catal$[ebp], 0
	je	SHORT $LN7@xmlCatalog
	mov	edx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $LN7@xmlCatalog
	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax+60], 0
	jne	SHORT $LN6@xmlCatalog
$LN7@xmlCatalog:

; 736  : 	(catal->xml == NULL))
; 737  : 	return;

	jmp	$LN1@xmlCatalog
$LN6@xmlCatalog:

; 738  :     switch (entry->type) {

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv71[ebp], edx
	mov	eax, DWORD PTR tv71[ebp]
	sub	eax, 13					; 0000000dH
	mov	DWORD PTR tv71[ebp], eax
	cmp	DWORD PTR tv71[ebp], 9
	ja	SHORT $LN17@xmlCatalog
	mov	ecx, DWORD PTR tv71[ebp]
	jmp	DWORD PTR $LN21@xmlCatalog[ecx*4]
$LN8@xmlCatalog:

; 739  : 	case SGML_CATA_ENTITY:
; 740  : 	    entry->type = XML_CATA_PUBLIC;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+12], 5

; 741  : 	    break;

	jmp	SHORT $LN2@xmlCatalog
$LN9@xmlCatalog:

; 742  : 	case SGML_CATA_PENTITY:
; 743  : 	    entry->type = XML_CATA_PUBLIC;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+12], 5

; 744  : 	    break;

	jmp	SHORT $LN2@xmlCatalog
$LN10@xmlCatalog:

; 745  : 	case SGML_CATA_DOCTYPE:
; 746  : 	    entry->type = XML_CATA_PUBLIC;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+12], 5

; 747  : 	    break;

	jmp	SHORT $LN2@xmlCatalog
$LN11@xmlCatalog:

; 748  : 	case SGML_CATA_LINKTYPE:
; 749  : 	    entry->type = XML_CATA_PUBLIC;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+12], 5

; 750  : 	    break;

	jmp	SHORT $LN2@xmlCatalog
$LN12@xmlCatalog:

; 751  : 	case SGML_CATA_NOTATION:
; 752  : 	    entry->type = XML_CATA_PUBLIC;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+12], 5

; 753  : 	    break;

	jmp	SHORT $LN2@xmlCatalog
$LN13@xmlCatalog:

; 754  : 	case SGML_CATA_PUBLIC:
; 755  : 	    entry->type = XML_CATA_PUBLIC;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+12], 5

; 756  : 	    break;

	jmp	SHORT $LN2@xmlCatalog
$LN14@xmlCatalog:

; 757  : 	case SGML_CATA_SYSTEM:
; 758  : 	    entry->type = XML_CATA_SYSTEM;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+12], 6

; 759  : 	    break;

	jmp	SHORT $LN2@xmlCatalog
$LN15@xmlCatalog:

; 760  : 	case SGML_CATA_DELEGATE:
; 761  : 	    entry->type = XML_CATA_DELEGATE_PUBLIC;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+12], 8

; 762  : 	    break;

	jmp	SHORT $LN2@xmlCatalog
$LN16@xmlCatalog:

; 763  : 	case SGML_CATA_CATALOG:
; 764  : 	    entry->type = XML_CATA_CATALOG;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 765  : 	    break;

	jmp	SHORT $LN2@xmlCatalog
$LN17@xmlCatalog:

; 766  : 	default:
; 767  : 	    xmlHashRemoveEntry(catal->sgml, entry->name, xmlFreeCatalogEntry);

	push	OFFSET _xmlFreeCatalogEntry
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_xmlHashRemoveEntry
	add	esp, 12					; 0000000cH

; 768  : 	    return;

	jmp	SHORT $LN1@xmlCatalog
$LN2@xmlCatalog:

; 769  :     }
; 770  :     /*
; 771  :      * Conversion successful, remove from the SGML catalog
; 772  :      * and add it to the default XML one
; 773  :      */
; 774  :     xmlHashRemoveEntry(catal->sgml, entry->name, NULL);

	push	0
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_xmlHashRemoveEntry
	add	esp, 12					; 0000000cH

; 775  :     entry->parent = catal->xml;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+4], eax

; 776  :     entry->next = NULL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx], 0

; 777  :     if (catal->xml->children == NULL)

	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+60]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN18@xmlCatalog

; 778  : 	catal->xml->children = entry;

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN1@xmlCatalog
$LN18@xmlCatalog:

; 779  :     else {
; 780  : 	xmlCatalogEntryPtr prev;
; 781  : 
; 782  : 	prev = catal->xml->children;

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _prev$1[ebp], eax
$LN4@xmlCatalog:

; 783  : 	while (prev->next != NULL)

	mov	ecx, DWORD PTR _prev$1[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN5@xmlCatalog

; 784  : 	    prev = prev->next;

	mov	edx, DWORD PTR _prev$1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _prev$1[ebp], eax
	jmp	SHORT $LN4@xmlCatalog
$LN5@xmlCatalog:

; 785  : 	prev->next = entry;

	mov	ecx, DWORD PTR _prev$1[ebp]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx], edx
$LN1@xmlCatalog:

; 786  :     }
; 787  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN21@xmlCatalog:
	DD	$LN14@xmlCatalog
	DD	$LN13@xmlCatalog
	DD	$LN8@xmlCatalog
	DD	$LN9@xmlCatalog
	DD	$LN10@xmlCatalog
	DD	$LN11@xmlCatalog
	DD	$LN12@xmlCatalog
	DD	$LN15@xmlCatalog
	DD	$LN17@xmlCatalog
	DD	$LN16@xmlCatalog
_xmlCatalogConvertEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlDumpXMLCatalog
_TEXT	SEGMENT
_buf$ = -24						; size = 4
_catalog$ = -20						; size = 4
_dtd$ = -16						; size = 4
_ns$ = -12						; size = 4
_doc$ = -8						; size = 4
_ret$ = -4						; size = 4
_out$ = 8						; size = 4
_catal$ = 12						; size = 4
_xmlDumpXMLCatalog PROC					; COMDAT

; 662  : xmlDumpXMLCatalog(FILE *out, xmlCatalogEntryPtr catal) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 663  :     int ret;
; 664  :     xmlDocPtr doc;
; 665  :     xmlNsPtr ns;
; 666  :     xmlDtdPtr dtd;
; 667  :     xmlNodePtr catalog;
; 668  :     xmlOutputBufferPtr buf;
; 669  : 
; 670  :     /*
; 671  :      * Rebuild a catalog
; 672  :      */
; 673  :     doc = xmlNewDoc(NULL);

	push	0
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR _doc$[ebp], eax

; 674  :     if (doc == NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN2@xmlDumpXML

; 675  : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlDumpXML
$LN2@xmlDumpXML:

; 676  :     dtd = xmlNewDtd(doc, BAD_CAST "catalog",

	push	OFFSET ??_C@_0EE@FEMHHJKG@http?3?1?1www?4oasis?9open?4org?1commi@
	push	OFFSET ??_C@_0DF@EBMIELJJ@?9?1?1OASIS?1?1DTD?5Entity?5Resolution@
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNewDtd
	add	esp, 16					; 00000010H
	mov	DWORD PTR _dtd$[ebp], eax

; 677  : 	       BAD_CAST "-//OASIS//DTD Entity Resolution XML Catalog V1.0//EN",
; 678  : BAD_CAST "http://www.oasis-open.org/committees/entity/release/1.0/catalog.dtd");
; 679  : 
; 680  :     xmlAddChild((xmlNodePtr) doc, (xmlNodePtr) dtd);

	mov	ecx, DWORD PTR _dtd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8

; 681  : 
; 682  :     ns = xmlNewNs(NULL, XML_CATALOGS_NAMESPACE, NULL);

	push	0
	push	OFFSET ??_C@_0CM@FMEFCNGF@urn?3oasis?3names?3tc?3entity?3xmlns@
	push	0
	call	_xmlNewNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ns$[ebp], eax

; 683  :     if (ns == NULL) {

	cmp	DWORD PTR _ns$[ebp], 0
	jne	SHORT $LN3@xmlDumpXML

; 684  : 	xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 685  : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlDumpXML
$LN3@xmlDumpXML:

; 686  :     }
; 687  :     catalog = xmlNewDocNode(doc, ns, BAD_CAST "catalog", NULL);

	push	0
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	mov	ecx, DWORD PTR _ns$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _catalog$[ebp], eax

; 688  :     if (catalog == NULL) {

	cmp	DWORD PTR _catalog$[ebp], 0
	jne	SHORT $LN4@xmlDumpXML

; 689  : 	xmlFreeNs(ns);

	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	call	_xmlFreeNs
	add	esp, 4

; 690  : 	xmlFreeDoc(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 691  : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlDumpXML
$LN4@xmlDumpXML:

; 692  :     }
; 693  :     catalog->nsDef = ns;

	mov	edx, DWORD PTR _catalog$[ebp]
	mov	eax, DWORD PTR _ns$[ebp]
	mov	DWORD PTR [edx+48], eax

; 694  :     xmlAddChild((xmlNodePtr) doc, catalog);

	mov	ecx, DWORD PTR _catalog$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8

; 695  : 
; 696  :     xmlDumpXMLCatalogNode(catal, catalog, doc, ns, NULL);

	push	0
	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catalog$[ebp]
	push	edx
	mov	eax, DWORD PTR _catal$[ebp]
	push	eax
	call	_xmlDumpXMLCatalogNode
	add	esp, 20					; 00000014H

; 697  : 
; 698  :     /*
; 699  :      * reserialize it
; 700  :      */
; 701  :     buf = xmlOutputBufferCreateFile(out, NULL);

	push	0
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_xmlOutputBufferCreateFile
	add	esp, 8
	mov	DWORD PTR _buf$[ebp], eax

; 702  :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN5@xmlDumpXML

; 703  : 	xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 704  : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlDumpXML
$LN5@xmlDumpXML:

; 705  :     }
; 706  :     ret = xmlSaveFormatFileTo(buf, doc, NULL, 1);

	push	1
	push	0
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlSaveFormatFileTo
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 707  : 
; 708  :     /*
; 709  :      * Free it
; 710  :      */
; 711  :     xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 712  : 
; 713  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlDumpXML:

; 714  : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDumpXMLCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlDumpXMLCatalogNode
_TEXT	SEGMENT
tv136 = -20						; size = 4
tv68 = -16						; size = 4
_xns$1 = -12						; size = 4
_cur$ = -8						; size = 4
_node$ = -4						; size = 4
_catal$ = 8						; size = 4
_catalog$ = 12						; size = 4
_doc$ = 16						; size = 4
_ns$ = 20						; size = 4
_cgroup$ = 24						; size = 4
_xmlDumpXMLCatalogNode PROC				; COMDAT

; 545  : 		    xmlDocPtr doc, xmlNsPtr ns, xmlCatalogEntryPtr cgroup) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 546  :     xmlNodePtr node;
; 547  :     xmlCatalogEntryPtr cur;
; 548  :     /*
; 549  :      * add all the catalog entries
; 550  :      */
; 551  :     cur = catal;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	DWORD PTR _cur$[ebp], eax
$LN2@xmlDumpXML:

; 552  :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN1@xmlDumpXML

; 553  :         if (cur->group == cgroup) {

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	cmp	edx, DWORD PTR _cgroup$[ebp]
	jne	$LN8@xmlDumpXML

; 554  : 	    switch (cur->type) {

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR tv68[ebp], ecx
	mov	edx, DWORD PTR tv68[ebp]
	sub	edx, 1
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 11			; 0000000bH
	ja	$LN8@xmlDumpXML
	mov	eax, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN31@xmlDumpXML[eax*4]

; 555  : 	        case XML_CATA_REMOVED:
; 556  : 		    break;

	jmp	$LN8@xmlDumpXML
$LN10@xmlDumpXML:

; 557  : 	        case XML_CATA_BROKEN_CATALOG:
; 558  : 	        case XML_CATA_CATALOG:
; 559  : 		    if (cur == catal) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	ecx, DWORD PTR _catal$[ebp]
	jne	SHORT $LN11@xmlDumpXML

; 560  : 			cur = cur->children;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _cur$[ebp], eax

; 561  : 		        continue;

	jmp	SHORT $LN2@xmlDumpXML
$LN11@xmlDumpXML:

; 562  : 		    }
; 563  : 		    break;

	jmp	$LN8@xmlDumpXML
$LN12@xmlDumpXML:

; 564  : 		case XML_CATA_NEXT_CATALOG:
; 565  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "nextCatalog", NULL);

	push	0
	push	OFFSET ??_C@_0M@IKOOEBPK@nextCatalog@
	mov	ecx, DWORD PTR _ns$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _node$[ebp], eax

; 566  : 		    xmlSetProp(node, BAD_CAST "catalog", cur->value);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 567  : 		    xmlAddChild(catalog, node);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _catalog$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8

; 568  :                     break;

	jmp	$LN8@xmlDumpXML

; 569  : 		case XML_CATA_NONE:
; 570  : 		    break;

	jmp	$LN8@xmlDumpXML
$LN14@xmlDumpXML:

; 571  : 		case XML_CATA_GROUP:
; 572  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "group", NULL);

	push	0
	push	OFFSET ??_C@_05MGJOOGAJ@group@
	mov	edx, DWORD PTR _ns$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _node$[ebp], eax

; 573  : 		    xmlSetProp(node, BAD_CAST "id", cur->name);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	OFFSET ??_C@_02EGCJHIOB@id@
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 574  : 		    if (cur->value != NULL) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN15@xmlDumpXML

; 575  : 		        xmlNsPtr xns;
; 576  : 			xns = xmlSearchNsByHref(doc, node, XML_XML_NAMESPACE);

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlSearchNsByHref
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xns$1[ebp], eax

; 577  : 			if (xns != NULL)

	cmp	DWORD PTR _xns$1[ebp], 0
	je	SHORT $LN15@xmlDumpXML

; 578  : 			    xmlSetNsProp(node, xns, BAD_CAST "base",

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	push	OFFSET ??_C@_04BHIIPFEC@base@
	mov	eax, DWORD PTR _xns$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	_xmlSetNsProp
	add	esp, 16					; 00000010H
$LN15@xmlDumpXML:

; 579  : 					 cur->value);
; 580  : 		    }
; 581  : 		    switch (cur->prefer) {

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR tv136[ebp], eax
	cmp	DWORD PTR tv136[ebp], 1
	je	SHORT $LN18@xmlDumpXML
	cmp	DWORD PTR tv136[ebp], 2
	je	SHORT $LN19@xmlDumpXML
	jmp	SHORT $LN6@xmlDumpXML

; 582  : 			case XML_CATA_PREFER_NONE:
; 583  : 		            break;

	jmp	SHORT $LN6@xmlDumpXML
$LN18@xmlDumpXML:

; 584  : 			case XML_CATA_PREFER_PUBLIC:
; 585  : 		            xmlSetProp(node, BAD_CAST "prefer", BAD_CAST "public");

	push	OFFSET ??_C@_06EOMAMIIF@public@
	push	OFFSET ??_C@_06NEJLBODN@prefer@
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 586  : 			    break;

	jmp	SHORT $LN6@xmlDumpXML
$LN19@xmlDumpXML:

; 587  : 			case XML_CATA_PREFER_SYSTEM:
; 588  : 		            xmlSetProp(node, BAD_CAST "prefer", BAD_CAST "system");

	push	OFFSET ??_C@_06FHFOAHML@system@
	push	OFFSET ??_C@_06NEJLBODN@prefer@
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	call	_xmlSetProp
	add	esp, 12					; 0000000cH
$LN6@xmlDumpXML:

; 589  : 			    break;
; 590  : 		    }
; 591  : 		    xmlDumpXMLCatalogNode(cur->next, node, doc, ns, cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ns$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlDumpXMLCatalogNode
	add	esp, 20					; 00000014H

; 592  : 		    xmlAddChild(catalog, node);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _catalog$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8

; 593  : 	            break;

	jmp	$LN8@xmlDumpXML
$LN20@xmlDumpXML:

; 594  : 		case XML_CATA_PUBLIC:
; 595  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "public", NULL);

	push	0
	push	OFFSET ??_C@_06EOMAMIIF@public@
	mov	edx, DWORD PTR _ns$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _node$[ebp], eax

; 596  : 		    xmlSetProp(node, BAD_CAST "publicId", cur->name);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	OFFSET ??_C@_08KNJBHAKA@publicId@
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 597  : 		    xmlSetProp(node, BAD_CAST "uri", cur->value);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	push	OFFSET ??_C@_03GBBABMJN@uri@
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 598  : 		    xmlAddChild(catalog, node);

	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catalog$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8

; 599  : 		    break;

	jmp	$LN8@xmlDumpXML
$LN21@xmlDumpXML:

; 600  : 		case XML_CATA_SYSTEM:
; 601  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "system", NULL);

	push	0
	push	OFFSET ??_C@_06FHFOAHML@system@
	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _node$[ebp], eax

; 602  : 		    xmlSetProp(node, BAD_CAST "systemId", cur->name);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	OFFSET ??_C@_08MILANEJE@systemId@
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 603  : 		    xmlSetProp(node, BAD_CAST "uri", cur->value);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	push	OFFSET ??_C@_03GBBABMJN@uri@
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 604  : 		    xmlAddChild(catalog, node);

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _catalog$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8

; 605  : 		    break;

	jmp	$LN8@xmlDumpXML
$LN22@xmlDumpXML:

; 606  : 		case XML_CATA_REWRITE_SYSTEM:
; 607  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "rewriteSystem", NULL);

	push	0
	push	OFFSET ??_C@_0O@CCMDBGLO@rewriteSystem@
	mov	ecx, DWORD PTR _ns$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _node$[ebp], eax

; 608  : 		    xmlSetProp(node, BAD_CAST "systemIdStartString", cur->name);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	OFFSET ??_C@_0BE@DMCACPJB@systemIdStartString@
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 609  : 		    xmlSetProp(node, BAD_CAST "rewritePrefix", cur->value);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	OFFSET ??_C@_0O@FCPDBOKG@rewritePrefix@
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 610  : 		    xmlAddChild(catalog, node);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _catalog$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8

; 611  : 		    break;

	jmp	$LN8@xmlDumpXML
$LN23@xmlDumpXML:

; 612  : 		case XML_CATA_DELEGATE_PUBLIC:
; 613  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "delegatePublic", NULL);

	push	0
	push	OFFSET ??_C@_0P@FNMIEEAK@delegatePublic@
	mov	edx, DWORD PTR _ns$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _node$[ebp], eax

; 614  : 		    xmlSetProp(node, BAD_CAST "publicIdStartString", cur->name);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	OFFSET ??_C@_0BE@JKBIFJL@publicIdStartString@
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 615  : 		    xmlSetProp(node, BAD_CAST "catalog", cur->value);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 616  : 		    xmlAddChild(catalog, node);

	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catalog$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8

; 617  : 		    break;

	jmp	$LN8@xmlDumpXML
$LN24@xmlDumpXML:

; 618  : 		case XML_CATA_DELEGATE_SYSTEM:
; 619  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "delegateSystem", NULL);

	push	0
	push	OFFSET ??_C@_0P@EEFGILEE@delegateSystem@
	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _node$[ebp], eax

; 620  : 		    xmlSetProp(node, BAD_CAST "systemIdStartString", cur->name);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	OFFSET ??_C@_0BE@DMCACPJB@systemIdStartString@
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 621  : 		    xmlSetProp(node, BAD_CAST "catalog", cur->value);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 622  : 		    xmlAddChild(catalog, node);

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _catalog$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8

; 623  : 		    break;

	jmp	$LN8@xmlDumpXML
$LN25@xmlDumpXML:

; 624  : 		case XML_CATA_URI:
; 625  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "uri", NULL);

	push	0
	push	OFFSET ??_C@_03GBBABMJN@uri@
	mov	ecx, DWORD PTR _ns$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _node$[ebp], eax

; 626  : 		    xmlSetProp(node, BAD_CAST "name", cur->name);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 627  : 		    xmlSetProp(node, BAD_CAST "uri", cur->value);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	OFFSET ??_C@_03GBBABMJN@uri@
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 628  : 		    xmlAddChild(catalog, node);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _catalog$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8

; 629  : 		    break;

	jmp	$LN8@xmlDumpXML
$LN26@xmlDumpXML:

; 630  : 		case XML_CATA_REWRITE_URI:
; 631  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "rewriteURI", NULL);

	push	0
	push	OFFSET ??_C@_0L@BCFABNDK@rewriteURI@
	mov	edx, DWORD PTR _ns$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _node$[ebp], eax

; 632  : 		    xmlSetProp(node, BAD_CAST "uriStartString", cur->name);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	OFFSET ??_C@_0P@HNKDCBAK@uriStartString@
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 633  : 		    xmlSetProp(node, BAD_CAST "rewritePrefix", cur->value);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	push	OFFSET ??_C@_0O@FCPDBOKG@rewritePrefix@
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 634  : 		    xmlAddChild(catalog, node);

	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catalog$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8

; 635  : 		    break;

	jmp	SHORT $LN8@xmlDumpXML
$LN27@xmlDumpXML:

; 636  : 		case XML_CATA_DELEGATE_URI:
; 637  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "delegateURI", NULL);

	push	0
	push	OFFSET ??_C@_0M@NHAMNMJD@delegateURI@
	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _node$[ebp], eax

; 638  : 		    xmlSetProp(node, BAD_CAST "uriStartString", cur->name);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	OFFSET ??_C@_0P@HNKDCBAK@uriStartString@
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 639  : 		    xmlSetProp(node, BAD_CAST "catalog", cur->value);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 640  : 		    xmlAddChild(catalog, node);

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _catalog$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
$LN8@xmlDumpXML:

; 641  : 		    break;
; 642  : 		case SGML_CATA_SYSTEM:
; 643  : 		case SGML_CATA_PUBLIC:
; 644  : 		case SGML_CATA_ENTITY:
; 645  : 		case SGML_CATA_PENTITY:
; 646  : 		case SGML_CATA_DOCTYPE:
; 647  : 		case SGML_CATA_LINKTYPE:
; 648  : 		case SGML_CATA_NOTATION:
; 649  : 		case SGML_CATA_DELEGATE:
; 650  : 		case SGML_CATA_BASE:
; 651  : 		case SGML_CATA_CATALOG:
; 652  : 		case SGML_CATA_DOCUMENT:
; 653  : 		case SGML_CATA_SGMLDECL:
; 654  : 		    break;
; 655  : 	    }
; 656  :         }
; 657  : 	cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 658  :     }

	jmp	$LN2@xmlDumpXML
$LN1@xmlDumpXML:

; 659  : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlDumpXML:
	DD	$LN10@xmlDumpXML
	DD	$LN10@xmlDumpXML
	DD	$LN12@xmlDumpXML
	DD	$LN14@xmlDumpXML
	DD	$LN20@xmlDumpXML
	DD	$LN21@xmlDumpXML
	DD	$LN22@xmlDumpXML
	DD	$LN23@xmlDumpXML
	DD	$LN24@xmlDumpXML
	DD	$LN25@xmlDumpXML
	DD	$LN26@xmlDumpXML
	DD	$LN27@xmlDumpXML
_xmlDumpXMLCatalogNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogDumpEntry
_TEXT	SEGMENT
tv139 = -20						; size = 4
tv95 = -16						; size = 4
tv67 = -12						; size = 4
_out$ = -8						; size = 4
_entry$ = -4						; size = 4
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlCatalogDumpEntry PROC				; COMDAT

; 466  :                     const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 467  :     xmlCatalogEntryPtr entry = (xmlCatalogEntryPtr) payload;

	mov	eax, DWORD PTR _payload$[ebp]
	mov	DWORD PTR _entry$[ebp], eax

; 468  :     FILE *out = (FILE *) data;

	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR _out$[ebp], ecx

; 469  :     if ((entry == NULL) || (out == NULL))

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN9@xmlCatalog
	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN8@xmlCatalog
$LN9@xmlCatalog:

; 470  : 	return;

	jmp	$LN1@xmlCatalog
$LN8@xmlCatalog:

; 471  :     switch (entry->type) {

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv67[ebp], eax
	mov	ecx, DWORD PTR tv67[ebp]
	sub	ecx, 13					; 0000000dH
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 11			; 0000000bH
	ja	$LN22@xmlCatalog
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN30@xmlCatalog[edx*4]
$LN10@xmlCatalog:

; 472  : 	case SGML_CATA_ENTITY:
; 473  : 	    fprintf(out, "ENTITY "); break;

	push	OFFSET ??_C@_07JPOODLIK@ENTITY?5@
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN2@xmlCatalog
$LN11@xmlCatalog:

; 474  : 	case SGML_CATA_PENTITY:
; 475  : 	    fprintf(out, "ENTITY %%"); break;

	push	OFFSET ??_C@_09KGBCFCOH@ENTITY?5?$CF?$CF@
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN2@xmlCatalog
$LN12@xmlCatalog:

; 476  : 	case SGML_CATA_DOCTYPE:
; 477  : 	    fprintf(out, "DOCTYPE "); break;

	push	OFFSET ??_C@_08JFBCIFIP@DOCTYPE?5@
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	$LN2@xmlCatalog
$LN13@xmlCatalog:

; 478  : 	case SGML_CATA_LINKTYPE:
; 479  : 	    fprintf(out, "LINKTYPE "); break;

	push	OFFSET ??_C@_09BKBNLHNH@LINKTYPE?5@
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN2@xmlCatalog
$LN14@xmlCatalog:

; 480  : 	case SGML_CATA_NOTATION:
; 481  : 	    fprintf(out, "NOTATION "); break;

	push	OFFSET ??_C@_09EADGFDGH@NOTATION?5@
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN2@xmlCatalog
$LN15@xmlCatalog:

; 482  : 	case SGML_CATA_PUBLIC:
; 483  : 	    fprintf(out, "PUBLIC "); break;

	push	OFFSET ??_C@_07GAMBALOD@PUBLIC?5@
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN2@xmlCatalog
$LN16@xmlCatalog:

; 484  : 	case SGML_CATA_SYSTEM:
; 485  : 	    fprintf(out, "SYSTEM "); break;

	push	OFFSET ??_C@_07PBLMPJLL@SYSTEM?5@
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN2@xmlCatalog
$LN17@xmlCatalog:

; 486  : 	case SGML_CATA_DELEGATE:
; 487  : 	    fprintf(out, "DELEGATE "); break;

	push	OFFSET ??_C@_09KHFEEDDG@DELEGATE?5@
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN2@xmlCatalog
$LN18@xmlCatalog:

; 488  : 	case SGML_CATA_BASE:
; 489  : 	    fprintf(out, "BASE "); break;

	push	OFFSET ??_C@_05FDFDEPAH@BASE?5@
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN2@xmlCatalog
$LN19@xmlCatalog:

; 490  : 	case SGML_CATA_CATALOG:
; 491  : 	    fprintf(out, "CATALOG "); break;

	push	OFFSET ??_C@_08LGGFEAEJ@CATALOG?5@
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN2@xmlCatalog
$LN20@xmlCatalog:

; 492  : 	case SGML_CATA_DOCUMENT:
; 493  : 	    fprintf(out, "DOCUMENT "); break;

	push	OFFSET ??_C@_09PKNPLMNA@DOCUMENT?5@
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN2@xmlCatalog
$LN21@xmlCatalog:

; 494  : 	case SGML_CATA_SGMLDECL:
; 495  : 	    fprintf(out, "SGMLDECL "); break;

	push	OFFSET ??_C@_09KEOJDEKL@SGMLDECL?5@
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN2@xmlCatalog
$LN22@xmlCatalog:

; 496  : 	default:
; 497  : 	    return;

	jmp	$LN1@xmlCatalog
$LN2@xmlCatalog:

; 498  :     }
; 499  :     switch (entry->type) {

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR tv95[ebp], ecx
	mov	edx, DWORD PTR tv95[ebp]
	sub	edx, 13					; 0000000dH
	mov	DWORD PTR tv95[ebp], edx
	cmp	DWORD PTR tv95[ebp], 11			; 0000000bH
	ja	SHORT $LN4@xmlCatalog
	mov	eax, DWORD PTR tv95[ebp]
	movzx	ecx, BYTE PTR $LN29@xmlCatalog[eax]
	jmp	DWORD PTR $LN31@xmlCatalog[ecx*4]
$LN23@xmlCatalog:

; 500  : 	case SGML_CATA_ENTITY:
; 501  : 	case SGML_CATA_PENTITY:
; 502  : 	case SGML_CATA_DOCTYPE:
; 503  : 	case SGML_CATA_LINKTYPE:
; 504  : 	case SGML_CATA_NOTATION:
; 505  : 	    fprintf(out, "%s", (const char *) entry->name); break;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN4@xmlCatalog
$LN24@xmlCatalog:

; 506  : 	case SGML_CATA_PUBLIC:
; 507  : 	case SGML_CATA_SYSTEM:
; 508  : 	case SGML_CATA_SGMLDECL:
; 509  : 	case SGML_CATA_DOCUMENT:
; 510  : 	case SGML_CATA_CATALOG:
; 511  : 	case SGML_CATA_BASE:
; 512  : 	case SGML_CATA_DELEGATE:
; 513  : 	    fprintf(out, "\"%s\"", entry->name); break;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	OFFSET ??_C@_04OEDFLLKD@?$CC?$CFs?$CC@
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN4@xmlCatalog:

; 514  : 	default:
; 515  : 	    break;
; 516  :     }
; 517  :     switch (entry->type) {

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv139[ebp], eax
	cmp	DWORD PTR tv139[ebp], 13		; 0000000dH
	jl	SHORT $LN6@xmlCatalog
	cmp	DWORD PTR tv139[ebp], 20		; 00000014H
	jle	SHORT $LN26@xmlCatalog
	jmp	SHORT $LN6@xmlCatalog
$LN26@xmlCatalog:

; 518  : 	case SGML_CATA_ENTITY:
; 519  : 	case SGML_CATA_PENTITY:
; 520  : 	case SGML_CATA_DOCTYPE:
; 521  : 	case SGML_CATA_LINKTYPE:
; 522  : 	case SGML_CATA_NOTATION:
; 523  : 	case SGML_CATA_PUBLIC:
; 524  : 	case SGML_CATA_SYSTEM:
; 525  : 	case SGML_CATA_DELEGATE:
; 526  : 	    fprintf(out, " \"%s\"", entry->value); break;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	push	OFFSET ??_C@_05JEHJOICL@?5?$CC?$CFs?$CC@
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN6@xmlCatalog:

; 527  : 	default:
; 528  : 	    break;
; 529  :     }
; 530  :     fprintf(out, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN1@xmlCatalog:

; 531  : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@xmlCatalog:
	DD	$LN16@xmlCatalog
	DD	$LN15@xmlCatalog
	DD	$LN10@xmlCatalog
	DD	$LN11@xmlCatalog
	DD	$LN12@xmlCatalog
	DD	$LN13@xmlCatalog
	DD	$LN14@xmlCatalog
	DD	$LN17@xmlCatalog
	DD	$LN18@xmlCatalog
	DD	$LN19@xmlCatalog
	DD	$LN20@xmlCatalog
	DD	$LN21@xmlCatalog
$LN31@xmlCatalog:
	DD	$LN24@xmlCatalog
	DD	$LN23@xmlCatalog
$LN29@xmlCatalog:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
_xmlCatalogDumpEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCreateNewCatalog
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_type$ = 8						; size = 4
_prefer$ = 12						; size = 4
_xmlCreateNewCatalog PROC				; COMDAT

; 415  : xmlCreateNewCatalog(xmlCatalogType type, xmlCatalogPrefer prefer) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 416  :     xmlCatalogPtr ret;
; 417  : 
; 418  :     ret = (xmlCatalogPtr) xmlMalloc(sizeof(xmlCatalog));

	mov	esi, esp
	push	64					; 00000040H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 419  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlCreateN

; 420  :         xmlCatalogErrMemory("allocating catalog");

	push	OFFSET ??_C@_0BD@FCDBKBHD@allocating?5catalog@
	call	_xmlCatalogErrMemory
	add	esp, 4

; 421  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCreateN
$LN2@xmlCreateN:

; 422  :     }
; 423  :     memset(ret, 0, sizeof(xmlCatalog));

	push	64					; 00000040H
	push	0
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 424  :     ret->type = type;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [ecx], edx

; 425  :     ret->catalNr = 0;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+44], 0

; 426  :     ret->catalMax = XML_MAX_SGML_CATA_DEPTH;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+48], 10			; 0000000aH

; 427  :     ret->prefer = prefer;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _prefer$[ebp]
	mov	DWORD PTR [edx+56], eax

; 428  :     if (ret->type == XML_SGML_CATALOG_TYPE)

	mov	ecx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [ecx], 2
	jne	SHORT $LN3@xmlCreateN

; 429  : 	ret->sgml = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	add	esp, 4
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+52], eax
$LN3@xmlCreateN:

; 430  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlCreateN:

; 431  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCreateNewCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlFreeCatalogHashEntryList
_TEXT	SEGMENT
_next$ = -12						; size = 4
_children$ = -8						; size = 4
_catal$ = -4						; size = 4
_payload$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlFreeCatalogHashEntryList PROC			; COMDAT

; 385  :                             const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 386  :     xmlCatalogEntryPtr catal = (xmlCatalogEntryPtr) payload;

	mov	eax, DWORD PTR _payload$[ebp]
	mov	DWORD PTR _catal$[ebp], eax

; 387  :     xmlCatalogEntryPtr children, next;
; 388  : 
; 389  :     if (catal == NULL)

	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN4@xmlFreeCat

; 390  : 	return;

	jmp	SHORT $LN1@xmlFreeCat
$LN4@xmlFreeCat:

; 391  : 
; 392  :     children = catal->children;

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _children$[ebp], edx
$LN2@xmlFreeCat:

; 393  :     while (children != NULL) {

	cmp	DWORD PTR _children$[ebp], 0
	je	SHORT $LN3@xmlFreeCat

; 394  : 	next = children->next;

	mov	eax, DWORD PTR _children$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _next$[ebp], ecx

; 395  : 	children->dealloc = 0;

	mov	edx, DWORD PTR _children$[ebp]
	mov	DWORD PTR [edx+32], 0

; 396  : 	children->children = NULL;

	mov	eax, DWORD PTR _children$[ebp]
	mov	DWORD PTR [eax+8], 0

; 397  : 	xmlFreeCatalogEntry(children, NULL);

	push	0
	mov	ecx, DWORD PTR _children$[ebp]
	push	ecx
	call	_xmlFreeCatalogEntry
	add	esp, 8

; 398  : 	children = next;

	mov	edx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _children$[ebp], edx

; 399  :     }

	jmp	SHORT $LN2@xmlFreeCat
$LN3@xmlFreeCat:

; 400  :     catal->dealloc = 0;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [eax+32], 0

; 401  :     xmlFreeCatalogEntry(catal, NULL);

	push	0
	mov	ecx, DWORD PTR _catal$[ebp]
	push	ecx
	call	_xmlFreeCatalogEntry
	add	esp, 8
$LN1@xmlFreeCat:

; 402  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFreeCatalogHashEntryList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlFreeCatalogEntry
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_payload$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlFreeCatalogEntry PROC				; COMDAT

; 327  : xmlFreeCatalogEntry(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 328  :     xmlCatalogEntryPtr ret = (xmlCatalogEntryPtr) payload;

	mov	eax, DWORD PTR _payload$[ebp]
	mov	DWORD PTR _ret$[ebp], eax

; 329  :     if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlFreeCat

; 330  : 	return;

	jmp	$LN1@xmlFreeCat
$LN2@xmlFreeCat:

; 331  :     /*
; 332  :      * Entries stored in the file hash must be deallocated
; 333  :      * only by the file hash cleaner !
; 334  :      */
; 335  :     if (ret->dealloc == 1)

	mov	ecx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [ecx+32], 1
	jne	SHORT $LN3@xmlFreeCat

; 336  : 	return;

	jmp	$LN1@xmlFreeCat
$LN3@xmlFreeCat:

; 337  : 
; 338  :     if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	$LN4@xmlFreeCat

; 339  : 	if (ret->name != NULL)

	mov	edx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN5@xmlFreeCat

; 340  : 	    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	OFFSET ??_C@_0BH@BGJCBBBD@Free?5catalog?5entry?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN4@xmlFreeCat
$LN5@xmlFreeCat:

; 341  : 		    "Free catalog entry %s\n", ret->name);
; 342  : 	else if (ret->value != NULL)

	mov	ecx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN7@xmlFreeCat

; 343  : 	    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	push	OFFSET ??_C@_0BH@BGJCBBBD@Free?5catalog?5entry?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN4@xmlFreeCat
$LN7@xmlFreeCat:

; 344  : 		    "Free catalog entry %s\n", ret->value);
; 345  : 	else
; 346  : 	    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0BE@GJGIKNJC@Free?5catalog?5entry?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlFreeCat:

; 347  : 		    "Free catalog entry\n");
; 348  :     }
; 349  : 
; 350  :     if (ret->name != NULL)

	mov	edx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN9@xmlFreeCat

; 351  : 	xmlFree(ret->name);

	mov	esi, esp
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@xmlFreeCat:

; 352  :     if (ret->value != NULL)

	mov	edx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN10@xmlFreeCat

; 353  : 	xmlFree(ret->value);

	mov	esi, esp
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@xmlFreeCat:

; 354  :     if (ret->URL != NULL)

	mov	edx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN11@xmlFreeCat

; 355  : 	xmlFree(ret->URL);

	mov	esi, esp
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlFreeCat:

; 356  :     xmlFree(ret);

	mov	esi, esp
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlFreeCat:

; 357  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFreeCatalogEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlFreeCatalogEntryList
_TEXT	SEGMENT
_next$ = -4						; size = 4
_ret$ = 8						; size = 4
_xmlFreeCatalogEntryList PROC				; COMDAT

; 366  : xmlFreeCatalogEntryList(xmlCatalogEntryPtr ret) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlFreeCat:

; 367  :     xmlCatalogEntryPtr next;
; 368  : 
; 369  :     while (ret != NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN1@xmlFreeCat

; 370  : 	next = ret->next;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _next$[ebp], ecx

; 371  : 	xmlFreeCatalogEntry(ret, NULL);

	push	0
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlFreeCatalogEntry
	add	esp, 8

; 372  : 	ret = next;

	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _ret$[ebp], eax

; 373  :     }

	jmp	SHORT $LN2@xmlFreeCat
$LN1@xmlFreeCat:

; 374  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFreeCatalogEntryList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlNewCatalogEntry
_TEXT	SEGMENT
tv79 = -12						; size = 4
_normid$ = -8						; size = 4
_ret$ = -4						; size = 4
_type$ = 8						; size = 4
_name$ = 12						; size = 4
_value$ = 16						; size = 4
_URL$ = 20						; size = 4
_prefer$ = 24						; size = 4
_group$ = 28						; size = 4
_xmlNewCatalogEntry PROC				; COMDAT

; 276  : 	   xmlCatalogEntryPtr group) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 277  :     xmlCatalogEntryPtr ret;
; 278  :     xmlChar *normid = NULL;

	mov	DWORD PTR _normid$[ebp], 0

; 279  : 
; 280  :     ret = (xmlCatalogEntryPtr) xmlMalloc(sizeof(xmlCatalogEntry));

	mov	esi, esp
	push	44					; 0000002cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 281  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlNewCata

; 282  :         xmlCatalogErrMemory("allocating catalog entry");

	push	OFFSET ??_C@_0BJ@BLANILEA@allocating?5catalog?5entry@
	call	_xmlCatalogErrMemory
	add	esp, 4

; 283  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNewCata
$LN2@xmlNewCata:

; 284  :     }
; 285  :     ret->next = NULL;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax], 0

; 286  :     ret->parent = NULL;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 287  :     ret->children = NULL;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+8], 0

; 288  :     ret->type = type;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 289  :     if (type == XML_CATA_PUBLIC || type == XML_CATA_DELEGATE_PUBLIC) {

	cmp	DWORD PTR _type$[ebp], 5
	je	SHORT $LN4@xmlNewCata
	cmp	DWORD PTR _type$[ebp], 8
	jne	SHORT $LN3@xmlNewCata
$LN4@xmlNewCata:

; 290  :         normid = xmlCatalogNormalizePublic(name);

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlCatalogNormalizePublic
	add	esp, 4
	mov	DWORD PTR _normid$[ebp], eax

; 291  :         if (normid != NULL)

	cmp	DWORD PTR _normid$[ebp], 0
	je	SHORT $LN3@xmlNewCata

; 292  :             name = (*normid != 0 ? normid : NULL);

	mov	eax, DWORD PTR _normid$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN15@xmlNewCata
	mov	edx, DWORD PTR _normid$[ebp]
	mov	DWORD PTR tv79[ebp], edx
	jmp	SHORT $LN16@xmlNewCata
$LN15@xmlNewCata:
	mov	DWORD PTR tv79[ebp], 0
$LN16@xmlNewCata:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR _name$[ebp], eax
$LN3@xmlNewCata:

; 293  :     }
; 294  :     if (name != NULL)

	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN6@xmlNewCata

; 295  : 	ret->name = xmlStrdup(name);

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	SHORT $LN7@xmlNewCata
$LN6@xmlNewCata:

; 296  :     else
; 297  : 	ret->name = NULL;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+16], 0
$LN7@xmlNewCata:

; 298  :     if (normid != NULL)

	cmp	DWORD PTR _normid$[ebp], 0
	je	SHORT $LN8@xmlNewCata

; 299  :         xmlFree(normid);

	mov	esi, esp
	mov	ecx, DWORD PTR _normid$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@xmlNewCata:

; 300  :     if (value != NULL)

	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN9@xmlNewCata

; 301  : 	ret->value = xmlStrdup(value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+20], eax
	jmp	SHORT $LN10@xmlNewCata
$LN9@xmlNewCata:

; 302  :     else
; 303  : 	ret->value = NULL;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+20], 0
$LN10@xmlNewCata:

; 304  :     if (URL == NULL)

	cmp	DWORD PTR _URL$[ebp], 0
	jne	SHORT $LN11@xmlNewCata

; 305  : 	URL = value;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _URL$[ebp], eax
$LN11@xmlNewCata:

; 306  :     if (URL != NULL)

	cmp	DWORD PTR _URL$[ebp], 0
	je	SHORT $LN12@xmlNewCata

; 307  : 	ret->URL = xmlStrdup(URL);

	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+24], eax
	jmp	SHORT $LN13@xmlNewCata
$LN12@xmlNewCata:

; 308  :     else
; 309  : 	ret->URL = NULL;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+24], 0
$LN13@xmlNewCata:

; 310  :     ret->prefer = prefer;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _prefer$[ebp]
	mov	DWORD PTR [ecx+28], edx

; 311  :     ret->dealloc = 0;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+32], 0

; 312  :     ret->depth = 0;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 313  :     ret->group = group;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _group$[ebp]
	mov	DWORD PTR [edx+40], eax

; 314  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlNewCata:

; 315  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNewCatalogEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogErr
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_node$ = 12						; size = 4
_error$ = 16						; size = 4
_msg$ = 20						; size = 4
_str1$ = 24						; size = 4
_str2$ = 28						; size = 4
_str3$ = 32						; size = 4
_xmlCatalogErr PROC					; COMDAT

; 245  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 246  :     __xmlRaiseError(NULL, NULL, NULL, catal, node, XML_FROM_CATALOG,

	mov	eax, DWORD PTR _str3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _str1$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _str3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _str2$[ebp]
	push	edx
	mov	eax, DWORD PTR _str1$[ebp]
	push	eax
	push	0
	push	0
	push	2
	mov	ecx, DWORD PTR _error$[ebp]
	push	ecx
	push	20					; 00000014H
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _catal$[ebp]
	push	eax
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH

; 247  :                     error, XML_ERR_ERROR, NULL, 0,
; 248  : 		    (const char *) str1, (const char *) str2,
; 249  : 		    (const char *) str3, 0, 0,
; 250  : 		    msg, str1, str2, str3);
; 251  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCatalogErr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlCatalogErrMemory PROC				; COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 226  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_CATALOG,

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _extra$[ebp]
	push	ecx
	push	0
	push	0
	push	2
	push	2
	push	20					; 00000014H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 227  :                     XML_ERR_NO_MEMORY, XML_ERR_ERROR, NULL, 0,
; 228  : 		    extra, NULL, NULL, 0, 0,
; 229  : 		    "Memory allocation failed : %s\n", extra);
; 230  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCatalogErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlExpandCatalog
_TEXT	SEGMENT
_cur$1 = -16						; size = 4
_tmp$2 = -12						; size = 4
_content$3 = -8						; size = 4
_ret$ = -4						; size = 4
_catal$ = 8						; size = 4
_filename$ = 12						; size = 4
_xmlExpandCatalog PROC					; COMDAT

; 2741 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2742 :     int ret;
; 2743 : 
; 2744 :     if ((catal == NULL) || (filename == NULL))

	cmp	DWORD PTR _catal$[ebp], 0
	je	SHORT $LN5@xmlExpandC
	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN4@xmlExpandC
$LN5@xmlExpandC:

; 2745 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlExpandC
$LN4@xmlExpandC:

; 2746 : 
; 2747 : 
; 2748 :     if (catal->type == XML_SGML_CATALOG_TYPE) {

	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN6@xmlExpandC

; 2749 : 	xmlChar *content;
; 2750 : 
; 2751 : 	content = xmlLoadFileContent(filename);

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_xmlLoadFileContent
	add	esp, 4
	mov	DWORD PTR _content$3[ebp], eax

; 2752 : 	if (content == NULL)

	cmp	DWORD PTR _content$3[ebp], 0
	jne	SHORT $LN8@xmlExpandC

; 2753 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlExpandC
$LN8@xmlExpandC:

; 2754 : 
; 2755 :         ret = xmlParseSGMLCatalog(catal, content, filename, 0);

	push	0
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	mov	eax, DWORD PTR _content$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _catal$[ebp]
	push	ecx
	call	_xmlParseSGMLCatalog
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 2756 : 	if (ret < 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN9@xmlExpandC

; 2757 : 	    xmlFree(content);

	mov	esi, esp
	mov	edx, DWORD PTR _content$3[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2758 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlExpandC
$LN9@xmlExpandC:

; 2759 : 	}
; 2760 : 	xmlFree(content);

	mov	esi, esp
	mov	eax, DWORD PTR _content$3[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2761 :     } else {

	jmp	SHORT $LN7@xmlExpandC
$LN6@xmlExpandC:

; 2762 : 	xmlCatalogEntryPtr tmp, cur;
; 2763 : 	tmp = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,

	push	0
	mov	ecx, DWORD PTR _xmlCatalogDefaultPrefer
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	0
	push	0
	push	1
	call	_xmlNewCatalogEntry
	add	esp, 24					; 00000018H
	mov	DWORD PTR _tmp$2[ebp], eax

; 2764 : 		       NULL, BAD_CAST filename, xmlCatalogDefaultPrefer, NULL);
; 2765 : 
; 2766 : 	cur = catal->xml;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _cur$1[ebp], ecx

; 2767 : 	if (cur == NULL) {

	cmp	DWORD PTR _cur$1[ebp], 0
	jne	SHORT $LN2@xmlExpandC

; 2768 : 	    catal->xml = tmp;

	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR _tmp$2[ebp]
	mov	DWORD PTR [edx+60], eax

; 2769 : 	} else {

	jmp	SHORT $LN7@xmlExpandC
$LN2@xmlExpandC:

; 2770 : 	    while (cur->next != NULL) cur = cur->next;

	mov	ecx, DWORD PTR _cur$1[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@xmlExpandC
	mov	edx, DWORD PTR _cur$1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _cur$1[ebp], eax
	jmp	SHORT $LN2@xmlExpandC
$LN3@xmlExpandC:

; 2771 : 	    cur->next = tmp;

	mov	ecx, DWORD PTR _cur$1[ebp]
	mov	edx, DWORD PTR _tmp$2[ebp]
	mov	DWORD PTR [ecx], edx
$LN7@xmlExpandC:

; 2772 : 	}
; 2773 :     }
; 2774 :     return (0);

	xor	eax, eax
$LN1@xmlExpandC:

; 2775 : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpandCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogNormalizePublic
_TEXT	SEGMENT
_q$ = -20						; size = 4
_ret$ = -16						; size = 4
_p$ = -12						; size = 4
_white$ = -8						; size = 4
_ok$ = -4						; size = 4
_pubID$ = 8						; size = 4
_xmlCatalogNormalizePublic PROC				; COMDAT

; 1039 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 1040 :     int ok = 1;

	mov	DWORD PTR _ok$[ebp], 1

; 1041 :     int white;
; 1042 :     const xmlChar *p;
; 1043 :     xmlChar *ret;
; 1044 :     xmlChar *q;
; 1045 : 
; 1046 :     if (pubID == NULL)

	cmp	DWORD PTR _pubID$[ebp], 0
	jne	SHORT $LN8@xmlCatalog

; 1047 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCatalog
$LN8@xmlCatalog:

; 1048 : 
; 1049 :     white = 1;

	mov	DWORD PTR _white$[ebp], 1

; 1050 :     for (p = pubID;*p != 0 && ok;p++) {

	mov	eax, DWORD PTR _pubID$[ebp]
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@xmlCatalog
$LN2@xmlCatalog:
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx
$LN4@xmlCatalog:
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN3@xmlCatalog
	cmp	DWORD PTR _ok$[ebp], 0
	je	SHORT $LN3@xmlCatalog

; 1051 :         if (!xmlIsBlank_ch(*p))

	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN9@xmlCatalog
	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN11@xmlCatalog
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN9@xmlCatalog
$LN11@xmlCatalog:
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN9@xmlCatalog

; 1052 :             white = 0;

	mov	DWORD PTR _white$[ebp], 0
	jmp	SHORT $LN10@xmlCatalog
$LN9@xmlCatalog:

; 1053 :         else if (*p == 0x20 && !white)

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN12@xmlCatalog
	cmp	DWORD PTR _white$[ebp], 0
	jne	SHORT $LN12@xmlCatalog

; 1054 :             white = 1;

	mov	DWORD PTR _white$[ebp], 1
	jmp	SHORT $LN10@xmlCatalog
$LN12@xmlCatalog:

; 1055 :         else
; 1056 :             ok = 0;

	mov	DWORD PTR _ok$[ebp], 0
$LN10@xmlCatalog:

; 1057 :     }

	jmp	SHORT $LN2@xmlCatalog
$LN3@xmlCatalog:

; 1058 :     if (ok && !white)	/* is normalized */

	cmp	DWORD PTR _ok$[ebp], 0
	je	SHORT $LN14@xmlCatalog
	cmp	DWORD PTR _white$[ebp], 0
	jne	SHORT $LN14@xmlCatalog

; 1059 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCatalog
$LN14@xmlCatalog:

; 1060 : 
; 1061 :     ret = xmlStrdup(pubID);

	mov	edx, DWORD PTR _pubID$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 1062 :     q = ret;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _q$[ebp], eax

; 1063 :     white = 0;

	mov	DWORD PTR _white$[ebp], 0

; 1064 :     for (p = pubID;*p != 0;p++) {

	mov	ecx, DWORD PTR _pubID$[ebp]
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN7@xmlCatalog
$LN5@xmlCatalog:
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx
$LN7@xmlCatalog:
	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@xmlCatalog

; 1065 :         if (xmlIsBlank_ch(*p)) {

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN17@xmlCatalog
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN18@xmlCatalog
	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN17@xmlCatalog
$LN18@xmlCatalog:
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN15@xmlCatalog
$LN17@xmlCatalog:

; 1066 :             if (q != ret)

	mov	ecx, DWORD PTR _q$[ebp]
	cmp	ecx, DWORD PTR _ret$[ebp]
	je	SHORT $LN19@xmlCatalog

; 1067 :                 white = 1;

	mov	DWORD PTR _white$[ebp], 1
$LN19@xmlCatalog:

; 1068 :         } else {

	jmp	SHORT $LN16@xmlCatalog
$LN15@xmlCatalog:

; 1069 :             if (white) {

	cmp	DWORD PTR _white$[ebp], 0
	je	SHORT $LN20@xmlCatalog

; 1070 :                 *(q++) = 0x20;

	mov	edx, DWORD PTR _q$[ebp]
	mov	BYTE PTR [edx], 32			; 00000020H
	mov	eax, DWORD PTR _q$[ebp]
	add	eax, 1
	mov	DWORD PTR _q$[ebp], eax

; 1071 :                 white = 0;

	mov	DWORD PTR _white$[ebp], 0
$LN20@xmlCatalog:

; 1072 :             }
; 1073 :             *(q++) = *p;

	mov	ecx, DWORD PTR _q$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _q$[ebp]
	add	ecx, 1
	mov	DWORD PTR _q$[ebp], ecx
$LN16@xmlCatalog:

; 1074 :         }
; 1075 :     }

	jmp	$LN5@xmlCatalog
$LN6@xmlCatalog:

; 1076 :     *q = 0;

	mov	edx, DWORD PTR _q$[ebp]
	mov	BYTE PTR [edx], 0

; 1077 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlCatalog:

; 1078 : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogNormalizePublic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogGetPublic
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_pubID$ = 8						; size = 4
_xmlCatalogGetPublic PROC				; COMDAT

; 3792 : xmlCatalogGetPublic(const xmlChar *pubID) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3793 :     xmlChar *ret;
; 3794 :     static xmlChar result[1000];
; 3795 :     static int msg = 0;
; 3796 : 
; 3797 :     if (!xmlCatalogInitialized)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3798 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3799 : 
; 3800 :     if (msg == 0) {

	cmp	DWORD PTR ?msg@?1??xmlCatalogGetPublic@@9@9, 0
	jne	SHORT $LN3@xmlCatalog

; 3801 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CO@NCFNFNHN@Use?5of?5deprecated?5xmlCatalogGet@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3802 : 		"Use of deprecated xmlCatalogGetPublic() call\n");
; 3803 : 	msg++;

	mov	edx, DWORD PTR ?msg@?1??xmlCatalogGetPublic@@9@9
	add	edx, 1
	mov	DWORD PTR ?msg@?1??xmlCatalogGetPublic@@9@9, edx
$LN3@xmlCatalog:

; 3804 :     }
; 3805 : 
; 3806 :     if (pubID == NULL)

	cmp	DWORD PTR _pubID$[ebp], 0
	jne	SHORT $LN4@xmlCatalog

; 3807 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCatalog
$LN4@xmlCatalog:

; 3808 : 
; 3809 :     /*
; 3810 :      * Check first the XML catalogs
; 3811 :      */
; 3812 :     if (xmlDefaultCatalog != NULL) {

	cmp	DWORD PTR _xmlDefaultCatalog, 0
	je	SHORT $LN5@xmlCatalog

; 3813 : 	ret = xmlCatalogListXMLResolve(xmlDefaultCatalog->xml, pubID, NULL);

	push	0
	mov	eax, DWORD PTR _pubID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xmlDefaultCatalog
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 3814 : 	if ((ret != NULL) && (ret != XML_CATAL_BREAK)) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN5@xmlCatalog
	cmp	DWORD PTR _ret$[ebp], -1
	je	SHORT $LN5@xmlCatalog

; 3815 : 	    snprintf((char *) result, sizeof(result) - 1, "%s", (char *) ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	999					; 000003e7H
	push	OFFSET ?result@?1??xmlCatalogGetPublic@@9@9
	call	_snprintf
	add	esp, 16					; 00000010H

; 3816 : 	    result[sizeof(result) - 1] = 0;

	mov	ecx, 1
	imul	edx, ecx, 999
	mov	BYTE PTR ?result@?1??xmlCatalogGetPublic@@9@9[edx], 0

; 3817 : 	    return(result);

	mov	eax, OFFSET ?result@?1??xmlCatalogGetPublic@@9@9
	jmp	SHORT $LN1@xmlCatalog
$LN5@xmlCatalog:

; 3818 : 	}
; 3819 :     }
; 3820 : 
; 3821 :     if (xmlDefaultCatalog != NULL)

	cmp	DWORD PTR _xmlDefaultCatalog, 0
	je	SHORT $LN7@xmlCatalog

; 3822 : 	return(xmlCatalogGetSGMLPublic(xmlDefaultCatalog->sgml, pubID));

	mov	eax, DWORD PTR _pubID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xmlDefaultCatalog
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_xmlCatalogGetSGMLPublic
	add	esp, 8
	jmp	SHORT $LN1@xmlCatalog
$LN7@xmlCatalog:

; 3823 :     return(NULL);

	xor	eax, eax
$LN1@xmlCatalog:

; 3824 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogGetPublic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogGetSystem
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_sysID$ = 8						; size = 4
_xmlCatalogGetSystem PROC				; COMDAT

; 3748 : xmlCatalogGetSystem(const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3749 :     xmlChar *ret;
; 3750 :     static xmlChar result[1000];
; 3751 :     static int msg = 0;
; 3752 : 
; 3753 :     if (!xmlCatalogInitialized)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3754 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3755 : 
; 3756 :     if (msg == 0) {

	cmp	DWORD PTR ?msg@?1??xmlCatalogGetSystem@@9@9, 0
	jne	SHORT $LN3@xmlCatalog

; 3757 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CO@JOIDOAAA@Use?5of?5deprecated?5xmlCatalogGet@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3758 : 		"Use of deprecated xmlCatalogGetSystem() call\n");
; 3759 : 	msg++;

	mov	edx, DWORD PTR ?msg@?1??xmlCatalogGetSystem@@9@9
	add	edx, 1
	mov	DWORD PTR ?msg@?1??xmlCatalogGetSystem@@9@9, edx
$LN3@xmlCatalog:

; 3760 :     }
; 3761 : 
; 3762 :     if (sysID == NULL)

	cmp	DWORD PTR _sysID$[ebp], 0
	jne	SHORT $LN4@xmlCatalog

; 3763 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCatalog
$LN4@xmlCatalog:

; 3764 : 
; 3765 :     /*
; 3766 :      * Check first the XML catalogs
; 3767 :      */
; 3768 :     if (xmlDefaultCatalog != NULL) {

	cmp	DWORD PTR _xmlDefaultCatalog, 0
	je	SHORT $LN5@xmlCatalog

; 3769 : 	ret = xmlCatalogListXMLResolve(xmlDefaultCatalog->xml, NULL, sysID);

	mov	eax, DWORD PTR _sysID$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _xmlDefaultCatalog
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 3770 : 	if ((ret != NULL) && (ret != XML_CATAL_BREAK)) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN5@xmlCatalog
	cmp	DWORD PTR _ret$[ebp], -1
	je	SHORT $LN5@xmlCatalog

; 3771 : 	    snprintf((char *) result, sizeof(result) - 1, "%s", (char *) ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	999					; 000003e7H
	push	OFFSET ?result@?1??xmlCatalogGetSystem@@9@9
	call	_snprintf
	add	esp, 16					; 00000010H

; 3772 : 	    result[sizeof(result) - 1] = 0;

	mov	ecx, 1
	imul	edx, ecx, 999
	mov	BYTE PTR ?result@?1??xmlCatalogGetSystem@@9@9[edx], 0

; 3773 : 	    return(result);

	mov	eax, OFFSET ?result@?1??xmlCatalogGetSystem@@9@9
	jmp	SHORT $LN1@xmlCatalog
$LN5@xmlCatalog:

; 3774 : 	}
; 3775 :     }
; 3776 : 
; 3777 :     if (xmlDefaultCatalog != NULL)

	cmp	DWORD PTR _xmlDefaultCatalog, 0
	je	SHORT $LN7@xmlCatalog

; 3778 : 	return(xmlCatalogGetSGMLSystem(xmlDefaultCatalog->sgml, sysID));

	mov	eax, DWORD PTR _sysID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xmlDefaultCatalog
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_xmlCatalogGetSGMLSystem
	add	esp, 8
	jmp	SHORT $LN1@xmlCatalog
$LN7@xmlCatalog:

; 3779 :     return(NULL);

	xor	eax, eax
$LN1@xmlCatalog:

; 3780 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogGetSystem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogGetDefaults
_TEXT	SEGMENT
_xmlCatalogGetDefaults PROC				; COMDAT

; 3498 : xmlCatalogGetDefaults(void) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3499 :     return(xmlCatalogDefaultAllow);

	mov	eax, DWORD PTR _xmlCatalogDefaultAllow

; 3500 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCatalogGetDefaults ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogSetDefaults
_TEXT	SEGMENT
tv65 = -4						; size = 4
_allow$ = 8						; size = 4
_xmlCatalogSetDefaults PROC				; COMDAT

; 3510 : xmlCatalogSetDefaults(xmlCatalogAllow allow) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3511 :     if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	$LN4@xmlCatalog

; 3512 : 	switch (allow) {

	mov	eax, DWORD PTR _allow$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 3
	ja	$LN4@xmlCatalog
	mov	ecx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN10@xmlCatalog[ecx*4]
$LN5@xmlCatalog:

; 3513 : 	    case XML_CATA_ALLOW_NONE:
; 3514 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0BJ@DJLGHJPH@Disabling?5catalog?5usage?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3515 : 			"Disabling catalog usage\n");
; 3516 : 		break;

	jmp	SHORT $LN4@xmlCatalog
$LN6@xmlCatalog:

; 3517 : 	    case XML_CATA_ALLOW_GLOBAL:
; 3518 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0BP@JNJOABOL@Allowing?5only?5global?5catalogs?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3519 : 			"Allowing only global catalogs\n");
; 3520 : 		break;

	jmp	SHORT $LN4@xmlCatalog
$LN7@xmlCatalog:

; 3521 : 	    case XML_CATA_ALLOW_DOCUMENT:
; 3522 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CK@GBNCHLDL@Allowing?5only?5catalogs?5from?5the@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3523 : 			"Allowing only catalogs from the document\n");
; 3524 : 		break;

	jmp	SHORT $LN4@xmlCatalog
$LN8@xmlCatalog:

; 3525 : 	    case XML_CATA_ALLOW_ALL:
; 3526 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0BH@NEFJFIDI@Allowing?5all?5catalogs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlCatalog:

; 3527 : 			"Allowing all catalogs\n");
; 3528 : 		break;
; 3529 : 	}
; 3530 :     }
; 3531 :     xmlCatalogDefaultAllow = allow;

	mov	ecx, DWORD PTR _allow$[ebp]
	mov	DWORD PTR _xmlCatalogDefaultAllow, ecx

; 3532 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN10@xmlCatalog:
	DD	$LN5@xmlCatalog
	DD	$LN6@xmlCatalog
	DD	$LN7@xmlCatalog
	DD	$LN8@xmlCatalog
_xmlCatalogSetDefaults ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogSetDefaultPrefer
_TEXT	SEGMENT
tv66 = -8						; size = 4
_ret$ = -4						; size = 4
_prefer$ = 8						; size = 4
_xmlCatalogSetDefaultPrefer PROC			; COMDAT

; 3545 : xmlCatalogSetDefaultPrefer(xmlCatalogPrefer prefer) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3546 :     xmlCatalogPrefer ret = xmlCatalogDefaultPrefer;

	mov	eax, DWORD PTR _xmlCatalogDefaultPrefer
	mov	DWORD PTR _ret$[ebp], eax

; 3547 : 
; 3548 :     if (prefer == XML_CATA_PREFER_NONE)

	cmp	DWORD PTR _prefer$[ebp], 0
	jne	SHORT $LN4@xmlCatalog

; 3549 : 	return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlCatalog
$LN4@xmlCatalog:

; 3550 : 
; 3551 :     if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN5@xmlCatalog

; 3552 : 	switch (prefer) {

	mov	ecx, DWORD PTR _prefer$[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN6@xmlCatalog
	cmp	DWORD PTR tv66[ebp], 2
	je	SHORT $LN7@xmlCatalog
	jmp	SHORT $LN8@xmlCatalog
$LN6@xmlCatalog:

; 3553 : 	    case XML_CATA_PREFER_PUBLIC:
; 3554 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CG@PBIOHMMD@Setting?5catalog?5preference?5to?5P@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3555 : 			"Setting catalog preference to PUBLIC\n");
; 3556 : 		break;

	jmp	SHORT $LN5@xmlCatalog
$LN7@xmlCatalog:

; 3557 : 	    case XML_CATA_PREFER_SYSTEM:
; 3558 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CG@GAPDIOJL@Setting?5catalog?5preference?5to?5S@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3559 : 			"Setting catalog preference to SYSTEM\n");
; 3560 : 		break;

	jmp	SHORT $LN5@xmlCatalog
$LN8@xmlCatalog:

; 3561 : 	    default:
; 3562 : 		return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlCatalog
$LN5@xmlCatalog:

; 3563 : 	}
; 3564 :     }
; 3565 :     xmlCatalogDefaultPrefer = prefer;

	mov	eax, DWORD PTR _prefer$[ebp]
	mov	DWORD PTR _xmlCatalogDefaultPrefer, eax

; 3566 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlCatalog:

; 3567 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogSetDefaultPrefer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogSetDebug
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_level$ = 8						; size = 4
_xmlCatalogSetDebug PROC				; COMDAT

; 3579 : xmlCatalogSetDebug(int level) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3580 :     int ret = xmlDebugCatalogs;

	mov	eax, DWORD PTR _xmlDebugCatalogs
	mov	DWORD PTR _ret$[ebp], eax

; 3581 : 
; 3582 :     if (level <= 0)

	cmp	DWORD PTR _level$[ebp], 0
	jg	SHORT $LN2@xmlCatalog

; 3583 :         xmlDebugCatalogs = 0;

	mov	DWORD PTR _xmlDebugCatalogs, 0
	jmp	SHORT $LN3@xmlCatalog
$LN2@xmlCatalog:

; 3584 :     else
; 3585 : 	xmlDebugCatalogs = level;

	mov	ecx, DWORD PTR _level$[ebp]
	mov	DWORD PTR _xmlDebugCatalogs, ecx
$LN3@xmlCatalog:

; 3586 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]

; 3587 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogSetDebug ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogLocalResolveURI
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_catal$ = -4						; size = 4
_catalogs$ = 8						; size = 4
_URI$ = 12						; size = 4
_xmlCatalogLocalResolveURI PROC				; COMDAT

; 3710 : xmlCatalogLocalResolveURI(void *catalogs, const xmlChar *URI) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3711 :     xmlCatalogEntryPtr catal;
; 3712 :     xmlChar *ret;
; 3713 : 
; 3714 :     if (!xmlCatalogInitialized)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3715 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3716 : 
; 3717 :     if (URI == NULL)

	cmp	DWORD PTR _URI$[ebp], 0
	jne	SHORT $LN3@xmlCatalog

; 3718 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCatalog
$LN3@xmlCatalog:

; 3719 : 
; 3720 :     if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN4@xmlCatalog

; 3721 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _URI$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@GHNHNPIN@Resolve?5URI?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlCatalog:

; 3722 : 		"Resolve URI %s\n", URI);
; 3723 : 
; 3724 :     catal = (xmlCatalogEntryPtr) catalogs;

	mov	eax, DWORD PTR _catalogs$[ebp]
	mov	DWORD PTR _catal$[ebp], eax

; 3725 :     if (catal == NULL)

	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN5@xmlCatalog

; 3726 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCatalog
$LN5@xmlCatalog:

; 3727 :     ret = xmlCatalogListXMLResolveURI(catal, URI);

	mov	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catal$[ebp]
	push	edx
	call	_xmlCatalogListXMLResolveURI
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 3728 :     if ((ret != NULL) && (ret != XML_CATAL_BREAK))

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN6@xmlCatalog
	cmp	DWORD PTR _ret$[ebp], -1
	je	SHORT $LN6@xmlCatalog

; 3729 : 	return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlCatalog
$LN6@xmlCatalog:

; 3730 :     return(NULL);

	xor	eax, eax
$LN1@xmlCatalog:

; 3731 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogLocalResolveURI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogLocalResolve
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_catal$ = -4						; size = 4
_catalogs$ = 8						; size = 4
_pubID$ = 12						; size = 4
_sysID$ = 16						; size = 4
_xmlCatalogLocalResolve PROC				; COMDAT

; 3666 : 	               const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3667 :     xmlCatalogEntryPtr catal;
; 3668 :     xmlChar *ret;
; 3669 : 
; 3670 :     if (!xmlCatalogInitialized)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3671 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3672 : 
; 3673 :     if ((pubID == NULL) && (sysID == NULL))

	cmp	DWORD PTR _pubID$[ebp], 0
	jne	SHORT $LN3@xmlCatalog
	cmp	DWORD PTR _sysID$[ebp], 0
	jne	SHORT $LN3@xmlCatalog

; 3674 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCatalog
$LN3@xmlCatalog:

; 3675 : 
; 3676 :     if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	$LN4@xmlCatalog

; 3677 :         if ((pubID != NULL) && (sysID != NULL)) {

	cmp	DWORD PTR _pubID$[ebp], 0
	je	SHORT $LN5@xmlCatalog
	cmp	DWORD PTR _sysID$[ebp], 0
	je	SHORT $LN5@xmlCatalog

; 3678 :             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _sysID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pubID$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CC@EFNIHKEA@Local?5Resolve?3?5pubID?5?$CFs?5sysID?5?$CF@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN4@xmlCatalog
$LN5@xmlCatalog:

; 3679 :                             "Local Resolve: pubID %s sysID %s\n", pubID, sysID);
; 3680 :         } else if (pubID != NULL) {

	cmp	DWORD PTR _pubID$[ebp], 0
	je	SHORT $LN7@xmlCatalog

; 3681 :             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _pubID$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BJ@JNLHMJMH@Local?5Resolve?3?5pubID?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3682 :                             "Local Resolve: pubID %s\n", pubID);
; 3683 :         } else {

	jmp	SHORT $LN4@xmlCatalog
$LN7@xmlCatalog:

; 3684 :             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _sysID$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BJ@CAKFLAGF@Local?5Resolve?3?5sysID?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlCatalog:

; 3685 :                             "Local Resolve: sysID %s\n", sysID);
; 3686 :         }
; 3687 :     }
; 3688 : 
; 3689 :     catal = (xmlCatalogEntryPtr) catalogs;

	mov	ecx, DWORD PTR _catalogs$[ebp]
	mov	DWORD PTR _catal$[ebp], ecx

; 3690 :     if (catal == NULL)

	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN9@xmlCatalog

; 3691 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCatalog
$LN9@xmlCatalog:

; 3692 :     ret = xmlCatalogListXMLResolve(catal, pubID, sysID);

	mov	edx, DWORD PTR _sysID$[ebp]
	push	edx
	mov	eax, DWORD PTR _pubID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _catal$[ebp]
	push	ecx
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 3693 :     if ((ret != NULL) && (ret != XML_CATAL_BREAK))

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN10@xmlCatalog
	cmp	DWORD PTR _ret$[ebp], -1
	je	SHORT $LN10@xmlCatalog

; 3694 : 	return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlCatalog
$LN10@xmlCatalog:

; 3695 :     return(NULL);

	xor	eax, eax
$LN1@xmlCatalog:

; 3696 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogLocalResolve ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogAddLocal
_TEXT	SEGMENT
_add$ = -8						; size = 4
_catal$ = -4						; size = 4
_catalogs$ = 8						; size = 4
_URL$ = 12						; size = 4
_xmlCatalogAddLocal PROC				; COMDAT

; 3624 : xmlCatalogAddLocal(void *catalogs, const xmlChar *URL) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3625 :     xmlCatalogEntryPtr catal, add;
; 3626 : 
; 3627 :     if (!xmlCatalogInitialized)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN4@xmlCatalog

; 3628 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN4@xmlCatalog:

; 3629 : 
; 3630 :     if (URL == NULL)

	cmp	DWORD PTR _URL$[ebp], 0
	jne	SHORT $LN5@xmlCatalog

; 3631 : 	return(catalogs);

	mov	eax, DWORD PTR _catalogs$[ebp]
	jmp	$LN1@xmlCatalog
$LN5@xmlCatalog:

; 3632 : 
; 3633 :     if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN6@xmlCatalog

; 3634 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _URL$[ebp]
	push	eax
	push	OFFSET ??_C@_0BM@KJMHHCDF@Adding?5document?5catalog?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@xmlCatalog:

; 3635 : 		"Adding document catalog %s\n", URL);
; 3636 : 
; 3637 :     add = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL, URL, NULL,

	push	0
	mov	eax, DWORD PTR _xmlCatalogDefaultPrefer
	push	eax
	push	0
	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	push	0
	push	1
	call	_xmlNewCatalogEntry
	add	esp, 24					; 00000018H
	mov	DWORD PTR _add$[ebp], eax

; 3638 : 	                     xmlCatalogDefaultPrefer, NULL);
; 3639 :     if (add == NULL)

	cmp	DWORD PTR _add$[ebp], 0
	jne	SHORT $LN7@xmlCatalog

; 3640 : 	return(catalogs);

	mov	eax, DWORD PTR _catalogs$[ebp]
	jmp	SHORT $LN1@xmlCatalog
$LN7@xmlCatalog:

; 3641 : 
; 3642 :     catal = (xmlCatalogEntryPtr) catalogs;

	mov	edx, DWORD PTR _catalogs$[ebp]
	mov	DWORD PTR _catal$[ebp], edx

; 3643 :     if (catal == NULL)

	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN2@xmlCatalog

; 3644 : 	return((void *) add);

	mov	eax, DWORD PTR _add$[ebp]
	jmp	SHORT $LN1@xmlCatalog
$LN2@xmlCatalog:

; 3645 : 
; 3646 :     while (catal->next != NULL)

	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@xmlCatalog

; 3647 : 	catal = catal->next;

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _catal$[ebp], edx
	jmp	SHORT $LN2@xmlCatalog
$LN3@xmlCatalog:

; 3648 :     catal->next = add;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR _add$[ebp]
	mov	DWORD PTR [eax], ecx

; 3649 :     return(catalogs);

	mov	eax, DWORD PTR _catalogs$[ebp]
$LN1@xmlCatalog:

; 3650 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogAddLocal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogFreeLocal
_TEXT	SEGMENT
_catal$ = -4						; size = 4
_catalogs$ = 8						; size = 4
_xmlCatalogFreeLocal PROC				; COMDAT

; 3602 : xmlCatalogFreeLocal(void *catalogs) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3603 :     xmlCatalogEntryPtr catal;
; 3604 : 
; 3605 :     if (!xmlCatalogInitialized)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3606 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3607 : 
; 3608 :     catal = (xmlCatalogEntryPtr) catalogs;

	mov	eax, DWORD PTR _catalogs$[ebp]
	mov	DWORD PTR _catal$[ebp], eax

; 3609 :     if (catal != NULL)

	cmp	DWORD PTR _catal$[ebp], 0
	je	SHORT $LN1@xmlCatalog

; 3610 : 	xmlFreeCatalogEntryList(catal);

	mov	ecx, DWORD PTR _catal$[ebp]
	push	ecx
	call	_xmlFreeCatalogEntryList
	add	esp, 4
$LN1@xmlCatalog:

; 3611 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogFreeLocal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogConvert
_TEXT	SEGMENT
_res$ = -4						; size = 4
_xmlCatalogConvert PROC					; COMDAT

; 3471 : xmlCatalogConvert(void) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3472 :     int res = -1;

	mov	DWORD PTR _res$[ebp], -1

; 3473 : 
; 3474 :     if (!xmlCatalogInitialized)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3475 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3476 : 
; 3477 :     xmlRMutexLock(xmlCatalogMutex);

	mov	eax, DWORD PTR _xmlCatalogMutex
	push	eax
	call	_xmlRMutexLock
	add	esp, 4

; 3478 :     res = xmlConvertSGMLCatalog(xmlDefaultCatalog);

	mov	ecx, DWORD PTR _xmlDefaultCatalog
	push	ecx
	call	_xmlConvertSGMLCatalog
	add	esp, 4
	mov	DWORD PTR _res$[ebp], eax

; 3479 :     xmlRMutexUnlock(xmlCatalogMutex);

	mov	edx, DWORD PTR _xmlCatalogMutex
	push	edx
	call	_xmlRMutexUnlock
	add	esp, 4

; 3480 :     return(res);

	mov	eax, DWORD PTR _res$[ebp]

; 3481 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogConvert ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseCatalogFile
_TEXT	SEGMENT
_buf$ = -20						; size = 4
_inputStream$ = -16					; size = 4
_directory$ = -12					; size = 4
_ctxt$ = -8						; size = 4
_ret$ = -4						; size = 4
_filename$ = 8						; size = 4
_xmlParseCatalogFile PROC				; COMDAT

; 893  : xmlParseCatalogFile(const char *filename) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 894  :     xmlDocPtr ret;
; 895  :     xmlParserCtxtPtr ctxt;
; 896  :     char *directory = NULL;

	mov	DWORD PTR _directory$[ebp], 0

; 897  :     xmlParserInputPtr inputStream;
; 898  :     xmlParserInputBufferPtr buf;
; 899  : 
; 900  :     ctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	DWORD PTR _ctxt$[ebp], eax

; 901  :     if (ctxt == NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlParseCa

; 902  : #ifdef LIBXML_SAX1_ENABLED
; 903  : 	if (xmlDefaultSAXHandler.error != NULL) {

	call	___xmlDefaultSAXHandler
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $LN3@xmlParseCa

; 904  : 	    xmlDefaultSAXHandler.error(NULL, "out of memory\n");

	mov	esi, esp
	push	OFFSET ??_C@_0P@PCJPAHLM@out?5of?5memory?6@
	push	0
	call	___xmlDefaultSAXHandler
	mov	eax, DWORD PTR [eax+88]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlParseCa:

; 905  : 	}
; 906  : #endif
; 907  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseCa
$LN2@xmlParseCa:

; 908  :     }
; 909  : 
; 910  :     buf = xmlParserInputBufferCreateFilename(filename, XML_CHAR_ENCODING_NONE);

	push	0
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_xmlParserInputBufferCreateFilename
	add	esp, 8
	mov	DWORD PTR _buf$[ebp], eax

; 911  :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN4@xmlParseCa

; 912  : 	xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 913  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseCa
$LN4@xmlParseCa:

; 914  :     }
; 915  : 
; 916  :     inputStream = xmlNewInputStream(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNewInputStream
	add	esp, 4
	mov	DWORD PTR _inputStream$[ebp], eax

; 917  :     if (inputStream == NULL) {

	cmp	DWORD PTR _inputStream$[ebp], 0
	jne	SHORT $LN5@xmlParseCa

; 918  : 	xmlFreeParserCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 919  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseCa
$LN5@xmlParseCa:

; 920  :     }
; 921  : 
; 922  :     inputStream->filename = (char *) xmlCanonicPath((const xmlChar *)filename);

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_xmlCanonicPath
	add	esp, 4
	mov	ecx, DWORD PTR _inputStream$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 923  :     inputStream->buf = buf;

	mov	edx, DWORD PTR _inputStream$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx], eax

; 924  :     xmlBufResetInput(buf->buffer, inputStream);

	mov	ecx, DWORD PTR _inputStream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufResetInput
	add	esp, 8

; 925  : 
; 926  :     inputPush(ctxt, inputStream);

	mov	ecx, DWORD PTR _inputStream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_inputPush
	add	esp, 8

; 927  :     if ((ctxt->directory == NULL) && (directory == NULL))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+180], 0
	jne	SHORT $LN6@xmlParseCa
	cmp	DWORD PTR _directory$[ebp], 0
	jne	SHORT $LN6@xmlParseCa

; 928  :         directory = xmlParserGetDirectory(filename);

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_xmlParserGetDirectory
	add	esp, 4
	mov	DWORD PTR _directory$[ebp], eax
$LN6@xmlParseCa:

; 929  :     if ((ctxt->directory == NULL) && (directory != NULL))

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+180], 0
	jne	SHORT $LN7@xmlParseCa
	cmp	DWORD PTR _directory$[ebp], 0
	je	SHORT $LN7@xmlParseCa

; 930  :         ctxt->directory = directory;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _directory$[ebp]
	mov	DWORD PTR [eax+180], ecx
$LN7@xmlParseCa:

; 931  :     ctxt->valid = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+100], 0

; 932  :     ctxt->validate = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+104], 0

; 933  :     ctxt->loadsubset = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+276], 0

; 934  :     ctxt->pedantic = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+268], 0

; 935  :     ctxt->dictNames = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+364], 1

; 936  : 
; 937  :     xmlParseDocument(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseDocument
	add	esp, 4

; 938  : 
; 939  :     if (ctxt->wellFormed)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN8@xmlParseCa

; 940  : 	ret = ctxt->myDoc;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _ret$[ebp], ecx
	jmp	SHORT $LN9@xmlParseCa
$LN8@xmlParseCa:

; 941  :     else {
; 942  :         ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 943  :         xmlFreeDoc(ctxt->myDoc);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 944  :         ctxt->myDoc = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN9@xmlParseCa:

; 945  :     }
; 946  :     xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 947  : 
; 948  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlParseCa:

; 949  : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseCatalogFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogRemove
_TEXT	SEGMENT
_res$ = -4						; size = 4
_value$ = 8						; size = 4
_xmlCatalogRemove PROC					; COMDAT

; 3451 : xmlCatalogRemove(const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3452 :     int res;
; 3453 : 
; 3454 :     if (!xmlCatalogInitialized)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3455 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3456 : 
; 3457 :     xmlRMutexLock(xmlCatalogMutex);

	mov	eax, DWORD PTR _xmlCatalogMutex
	push	eax
	call	_xmlRMutexLock
	add	esp, 4

; 3458 :     res = xmlACatalogRemove(xmlDefaultCatalog, value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _xmlDefaultCatalog
	push	edx
	call	_xmlACatalogRemove
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 3459 :     xmlRMutexUnlock(xmlCatalogMutex);

	mov	eax, DWORD PTR _xmlCatalogMutex
	push	eax
	call	_xmlRMutexUnlock
	add	esp, 4

; 3460 :     return(res);

	mov	eax, DWORD PTR _res$[ebp]

; 3461 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogRemove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogAdd
_TEXT	SEGMENT
_res$ = -4						; size = 4
_type$ = 8						; size = 4
_orig$ = 12						; size = 4
_replace$ = 16						; size = 4
_xmlCatalogAdd PROC					; COMDAT

; 3415 : xmlCatalogAdd(const xmlChar *type, const xmlChar *orig, const xmlChar *replace) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3416 :     int res = -1;

	mov	DWORD PTR _res$[ebp], -1

; 3417 : 
; 3418 :     if (!xmlCatalogInitialized)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3419 : 	xmlInitializeCatalogData();

	call	_xmlInitializeCatalogData
$LN2@xmlCatalog:

; 3420 : 
; 3421 :     xmlRMutexLock(xmlCatalogMutex);

	mov	eax, DWORD PTR _xmlCatalogMutex
	push	eax
	call	_xmlRMutexLock
	add	esp, 4

; 3422 :     /*
; 3423 :      * Specific case where one want to override the default catalog
; 3424 :      * put in place by xmlInitializeCatalog();
; 3425 :      */
; 3426 :     if ((xmlDefaultCatalog == NULL) &&

	cmp	DWORD PTR _xmlDefaultCatalog, 0
	jne	SHORT $LN3@xmlCatalog
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@xmlCatalog

; 3427 : 	(xmlStrEqual(type, BAD_CAST "catalog"))) {
; 3428 : 	xmlDefaultCatalog = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE,

	mov	edx, DWORD PTR _xmlCatalogDefaultPrefer
	push	edx
	push	1
	call	_xmlCreateNewCatalog
	add	esp, 8
	mov	DWORD PTR _xmlDefaultCatalog, eax

; 3429 : 		                          xmlCatalogDefaultPrefer);
; 3430 : 	xmlDefaultCatalog->xml = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,

	push	0
	mov	eax, DWORD PTR _xmlCatalogDefaultPrefer
	push	eax
	push	0
	mov	ecx, DWORD PTR _orig$[ebp]
	push	ecx
	push	0
	push	1
	call	_xmlNewCatalogEntry
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _xmlDefaultCatalog
	mov	DWORD PTR [edx+60], eax

; 3431 : 				    orig, NULL,  xmlCatalogDefaultPrefer, NULL);
; 3432 : 
; 3433 : 	xmlRMutexUnlock(xmlCatalogMutex);

	mov	eax, DWORD PTR _xmlCatalogMutex
	push	eax
	call	_xmlRMutexUnlock
	add	esp, 4

; 3434 : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCatalog
$LN3@xmlCatalog:

; 3435 :     }
; 3436 : 
; 3437 :     res = xmlACatalogAdd(xmlDefaultCatalog, type, orig, replace);

	mov	ecx, DWORD PTR _replace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _orig$[ebp]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xmlDefaultCatalog
	push	ecx
	call	_xmlACatalogAdd
	add	esp, 16					; 00000010H
	mov	DWORD PTR _res$[ebp], eax

; 3438 :     xmlRMutexUnlock(xmlCatalogMutex);

	mov	edx, DWORD PTR _xmlCatalogMutex
	push	edx
	call	_xmlRMutexUnlock
	add	esp, 4

; 3439 :     return(res);

	mov	eax, DWORD PTR _res$[ebp]
$LN1@xmlCatalog:

; 3440 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogAdd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogResolveURI
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_URI$ = 8						; size = 4
_xmlCatalogResolveURI PROC				; COMDAT

; 3372 : xmlCatalogResolveURI(const xmlChar *URI) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3373 :     xmlChar *ret;
; 3374 : 
; 3375 :     if (!xmlCatalogInitialized)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3376 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3377 : 
; 3378 :     ret = xmlACatalogResolveURI(xmlDefaultCatalog, URI);

	mov	eax, DWORD PTR _URI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xmlDefaultCatalog
	push	ecx
	call	_xmlACatalogResolveURI
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 3379 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]

; 3380 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogResolveURI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogResolvePublic
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_pubID$ = 8						; size = 4
_xmlCatalogResolvePublic PROC				; COMDAT

; 3331 : xmlCatalogResolvePublic(const xmlChar *pubID) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3332 :     xmlChar *ret;
; 3333 : 
; 3334 :     if (!xmlCatalogInitialized)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3335 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3336 : 
; 3337 :     ret = xmlACatalogResolvePublic(xmlDefaultCatalog, pubID);

	mov	eax, DWORD PTR _pubID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xmlDefaultCatalog
	push	ecx
	call	_xmlACatalogResolvePublic
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 3338 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]

; 3339 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogResolvePublic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogResolveSystem
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_sysID$ = 8						; size = 4
_xmlCatalogResolveSystem PROC				; COMDAT

; 3311 : xmlCatalogResolveSystem(const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3312 :     xmlChar *ret;
; 3313 : 
; 3314 :     if (!xmlCatalogInitialized)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3315 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3316 : 
; 3317 :     ret = xmlACatalogResolveSystem(xmlDefaultCatalog, sysID);

	mov	eax, DWORD PTR _sysID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xmlDefaultCatalog
	push	ecx
	call	_xmlACatalogResolveSystem
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 3318 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]

; 3319 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogResolveSystem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogResolve
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_pubID$ = 8						; size = 4
_sysID$ = 12						; size = 4
_xmlCatalogResolve PROC					; COMDAT

; 3352 : xmlCatalogResolve(const xmlChar *pubID, const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3353 :     xmlChar *ret;
; 3354 : 
; 3355 :     if (!xmlCatalogInitialized)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3356 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3357 : 
; 3358 :     ret = xmlACatalogResolve(xmlDefaultCatalog, pubID, sysID);

	mov	eax, DWORD PTR _sysID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pubID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _xmlDefaultCatalog
	push	edx
	call	_xmlACatalogResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 3359 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]

; 3360 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogResolve ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogDump
_TEXT	SEGMENT
_out$ = 8						; size = 4
_xmlCatalogDump PROC					; COMDAT

; 3390 : xmlCatalogDump(FILE *out) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3391 :     if (out == NULL)

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN2@xmlCatalog

; 3392 : 	return;

	jmp	SHORT $LN1@xmlCatalog
$LN2@xmlCatalog:

; 3393 : 
; 3394 :     if (!xmlCatalogInitialized)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN3@xmlCatalog

; 3395 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN3@xmlCatalog:

; 3396 : 
; 3397 :     xmlACatalogDump(xmlDefaultCatalog, out);

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xmlDefaultCatalog
	push	ecx
	call	_xmlACatalogDump
	add	esp, 8
$LN1@xmlCatalog:

; 3398 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCatalogDump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogCleanup
_TEXT	SEGMENT
_xmlCatalogCleanup PROC					; COMDAT

; 3281 : xmlCatalogCleanup(void) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3282 :     if (xmlCatalogInitialized == 0)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3283 :         return;

	jmp	$LN1@xmlCatalog
$LN2@xmlCatalog:

; 3284 : 
; 3285 :     xmlRMutexLock(xmlCatalogMutex);

	mov	eax, DWORD PTR _xmlCatalogMutex
	push	eax
	call	_xmlRMutexLock
	add	esp, 4

; 3286 :     if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN3@xmlCatalog

; 3287 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0BC@BLLDGNNC@Catalogs?5cleanup?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlCatalog:

; 3288 : 		"Catalogs cleanup\n");
; 3289 :     if (xmlCatalogXMLFiles != NULL)

	cmp	DWORD PTR _xmlCatalogXMLFiles, 0
	je	SHORT $LN4@xmlCatalog

; 3290 : 	xmlHashFree(xmlCatalogXMLFiles, xmlFreeCatalogHashEntryList);

	push	OFFSET _xmlFreeCatalogHashEntryList
	mov	eax, DWORD PTR _xmlCatalogXMLFiles
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN4@xmlCatalog:

; 3291 :     xmlCatalogXMLFiles = NULL;

	mov	DWORD PTR _xmlCatalogXMLFiles, 0

; 3292 :     if (xmlDefaultCatalog != NULL)

	cmp	DWORD PTR _xmlDefaultCatalog, 0
	je	SHORT $LN5@xmlCatalog

; 3293 : 	xmlFreeCatalog(xmlDefaultCatalog);

	mov	ecx, DWORD PTR _xmlDefaultCatalog
	push	ecx
	call	_xmlFreeCatalog
	add	esp, 4
$LN5@xmlCatalog:

; 3294 :     xmlDefaultCatalog = NULL;

	mov	DWORD PTR _xmlDefaultCatalog, 0

; 3295 :     xmlDebugCatalogs = 0;

	mov	DWORD PTR _xmlDebugCatalogs, 0

; 3296 :     xmlCatalogInitialized = 0;

	mov	DWORD PTR _xmlCatalogInitialized, 0

; 3297 :     xmlRMutexUnlock(xmlCatalogMutex);

	mov	edx, DWORD PTR _xmlCatalogMutex
	push	edx
	call	_xmlRMutexUnlock
	add	esp, 4

; 3298 :     xmlFreeRMutex(xmlCatalogMutex);

	mov	eax, DWORD PTR _xmlCatalogMutex
	push	eax
	call	_xmlFreeRMutex
	add	esp, 4
$LN1@xmlCatalog:

; 3299 : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCatalogCleanup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlLoadCatalogs
_TEXT	SEGMENT
tv129 = -36						; size = 4
tv171 = -29						; size = 1
tv168 = -28						; size = 4
tv165 = -24						; size = 4
_iLen$ = -20						; size = 4
_i$ = -16						; size = 4
_path$ = -12						; size = 4
_paths$ = -8						; size = 4
_cur$ = -4						; size = 4
_pathss$ = 8						; size = 4
_xmlLoadCatalogs PROC					; COMDAT

; 3238 : xmlLoadCatalogs(const char *pathss) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3239 :     const char *cur;
; 3240 :     const char *paths;
; 3241 :     xmlChar *path;
; 3242 : #ifdef _WIN32
; 3243 :     int i, iLen;
; 3244 : #endif
; 3245 : 
; 3246 :     if (pathss == NULL)

	cmp	DWORD PTR _pathss$[ebp], 0
	jne	SHORT $LN13@xmlLoadCat

; 3247 : 	return;

	jmp	$LN1@xmlLoadCat
$LN13@xmlLoadCat:

; 3248 : 
; 3249 :     cur = pathss;

	mov	eax, DWORD PTR _pathss$[ebp]
	mov	DWORD PTR _cur$[ebp], eax
$LN2@xmlLoadCat:

; 3250 :     while (*cur != 0) {

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN1@xmlLoadCat
$LN4@xmlLoadCat:

; 3251 : 	while (xmlIsBlank_ch(*cur)) cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN14@xmlLoadCat
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN15@xmlLoadCat
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN14@xmlLoadCat
$LN15@xmlLoadCat:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN5@xmlLoadCat
$LN14@xmlLoadCat:
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN4@xmlLoadCat
$LN5@xmlLoadCat:

; 3252 : 	if (*cur != 0) {

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN11@xmlLoadCat

; 3253 : 	    paths = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _paths$[ebp], edx
$LN6@xmlLoadCat:

; 3254 : 	    while ((*cur != 0) && (*cur != PATH_SEPARATOR) && (!xmlIsBlank_ch(*cur)))

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN7@xmlLoadCat
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 59					; 0000003bH
	je	SHORT $LN7@xmlLoadCat
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN7@xmlLoadCat
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN17@xmlLoadCat
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN7@xmlLoadCat
$LN17@xmlLoadCat:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN7@xmlLoadCat

; 3255 : 		cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN6@xmlLoadCat
$LN7@xmlLoadCat:

; 3256 : 	    path = xmlStrndup((const xmlChar *)paths, cur - paths);

	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, DWORD PTR _paths$[ebp]
	push	ecx
	mov	edx, DWORD PTR _paths$[ebp]
	push	edx
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR _path$[ebp], eax

; 3257 : #ifdef _WIN32
; 3258 :         iLen = strlen((const char*)path);

	mov	eax, DWORD PTR _path$[ebp]
	mov	DWORD PTR tv165[ebp], eax
	mov	ecx, DWORD PTR tv165[ebp]
	add	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
$LL21@xmlLoadCat:
	mov	edx, DWORD PTR tv165[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv171[ebp], al
	add	DWORD PTR tv165[ebp], 1
	cmp	BYTE PTR tv171[ebp], 0
	jne	SHORT $LL21@xmlLoadCat
	mov	ecx, DWORD PTR tv165[ebp]
	sub	ecx, DWORD PTR tv168[ebp]
	mov	DWORD PTR tv129[ebp], ecx
	mov	edx, DWORD PTR tv129[ebp]
	mov	DWORD PTR _iLen$[ebp], edx

; 3259 :         for(i = 0; i < iLen; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@xmlLoadCat
$LN8@xmlLoadCat:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@xmlLoadCat:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _iLen$[ebp]
	jge	SHORT $LN9@xmlLoadCat

; 3260 :             if(path[i] == '\\') {

	mov	edx, DWORD PTR _path$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN18@xmlLoadCat

; 3261 :                 path[i] = '/';

	mov	ecx, DWORD PTR _path$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx], 47			; 0000002fH
$LN18@xmlLoadCat:

; 3262 :             }
; 3263 :         }

	jmp	SHORT $LN8@xmlLoadCat
$LN9@xmlLoadCat:

; 3264 : #endif
; 3265 : 	    if (path != NULL) {

	cmp	DWORD PTR _path$[ebp], 0
	je	SHORT $LN11@xmlLoadCat

; 3266 : 		xmlLoadCatalog((const char *) path);

	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_xmlLoadCatalog
	add	esp, 4

; 3267 : 		xmlFree(path);

	mov	esi, esp
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlLoadCat:

; 3268 : 	    }
; 3269 : 	}
; 3270 : 	while (*cur == PATH_SEPARATOR)

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 59					; 0000003bH
	jne	SHORT $LN12@xmlLoadCat

; 3271 : 	    cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN11@xmlLoadCat
$LN12@xmlLoadCat:

; 3272 :     }

	jmp	$LN2@xmlLoadCat
$LN1@xmlLoadCat:

; 3273 : }

	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlLoadCatalogs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlLoadCatalog
_TEXT	SEGMENT
_catal$ = -8						; size = 4
_ret$ = -4						; size = 4
_filename$ = 8						; size = 4
_xmlLoadCatalog PROC					; COMDAT

; 3202 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3203 :     int ret;
; 3204 :     xmlCatalogPtr catal;
; 3205 : 
; 3206 :     if (!xmlCatalogInitialized)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlLoadCat

; 3207 : 	xmlInitializeCatalogData();

	call	_xmlInitializeCatalogData
$LN2@xmlLoadCat:

; 3208 : 
; 3209 :     xmlRMutexLock(xmlCatalogMutex);

	mov	eax, DWORD PTR _xmlCatalogMutex
	push	eax
	call	_xmlRMutexLock
	add	esp, 4

; 3210 : 
; 3211 :     if (xmlDefaultCatalog == NULL) {

	cmp	DWORD PTR _xmlDefaultCatalog, 0
	jne	SHORT $LN3@xmlLoadCat

; 3212 : 	catal = xmlLoadACatalog(filename);

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_xmlLoadACatalog
	add	esp, 4
	mov	DWORD PTR _catal$[ebp], eax

; 3213 : 	if (catal == NULL) {

	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN4@xmlLoadCat

; 3214 : 	    xmlRMutexUnlock(xmlCatalogMutex);

	mov	edx, DWORD PTR _xmlCatalogMutex
	push	edx
	call	_xmlRMutexUnlock
	add	esp, 4

; 3215 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlLoadCat
$LN4@xmlLoadCat:

; 3216 : 	}
; 3217 : 
; 3218 : 	xmlDefaultCatalog = catal;

	mov	eax, DWORD PTR _catal$[ebp]
	mov	DWORD PTR _xmlDefaultCatalog, eax

; 3219 : 	xmlRMutexUnlock(xmlCatalogMutex);

	mov	ecx, DWORD PTR _xmlCatalogMutex
	push	ecx
	call	_xmlRMutexUnlock
	add	esp, 4

; 3220 : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlLoadCat
$LN3@xmlLoadCat:

; 3221 :     }
; 3222 : 
; 3223 :     ret = xmlExpandCatalog(xmlDefaultCatalog, filename);

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	mov	eax, DWORD PTR _xmlDefaultCatalog
	push	eax
	call	_xmlExpandCatalog
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 3224 :     xmlRMutexUnlock(xmlCatalogMutex);

	mov	ecx, DWORD PTR _xmlCatalogMutex
	push	ecx
	call	_xmlRMutexUnlock
	add	esp, 4

; 3225 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlLoadCat:

; 3226 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlLoadCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlInitializeCatalog
_TEXT	SEGMENT
_uri$1 = -304						; size = 4
_p$2 = -300						; size = 4
_len$3 = -296						; size = 4
_buf$4 = -288						; size = 256
_hmodule$5 = -28					; size = 4
_nextent$6 = -24					; size = 4
_catal$7 = -20						; size = 4
_paths$8 = -16						; size = 4
_cur$9 = -12						; size = 4
_path$10 = -8						; size = 4
_catalogs$11 = -4					; size = 4
_xmlInitializeCatalog PROC				; COMDAT

; 3108 : xmlInitializeCatalog(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-304]
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3109 :     if (xmlCatalogInitialized != 0)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	je	SHORT $LN10@xmlInitial

; 3110 : 	return;

	jmp	$LN1@xmlInitial
$LN10@xmlInitial:

; 3111 : 
; 3112 :     xmlInitializeCatalogData();

	call	_xmlInitializeCatalogData

; 3113 :     xmlRMutexLock(xmlCatalogMutex);

	mov	eax, DWORD PTR _xmlCatalogMutex
	push	eax
	call	_xmlRMutexLock
	add	esp, 4

; 3114 : 
; 3115 :     if (getenv("XML_DEBUG_CATALOG"))

	mov	esi, esp
	push	OFFSET ??_C@_0BC@FJHLJCPJ@XML_DEBUG_CATALOG@
	call	DWORD PTR __imp__getenv
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN11@xmlInitial

; 3116 : 	xmlDebugCatalogs = 1;

	mov	DWORD PTR _xmlDebugCatalogs, 1
$LN11@xmlInitial:

; 3117 : 
; 3118 :     if (xmlDefaultCatalog == NULL) {

	cmp	DWORD PTR _xmlDefaultCatalog, 0
	jne	$LN12@xmlInitial

; 3119 : 	const char *catalogs;
; 3120 : 	char *path;
; 3121 : 	const char *cur, *paths;
; 3122 : 	xmlCatalogPtr catal;
; 3123 : 	xmlCatalogEntryPtr *nextent;
; 3124 : 
; 3125 : 	catalogs = (const char *) getenv("XML_CATALOG_FILES");

	mov	esi, esp
	push	OFFSET ??_C@_0BC@LLNJEHMH@XML_CATALOG_FILES@
	call	DWORD PTR __imp__getenv
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _catalogs$11[ebp], eax

; 3126 : 	if (catalogs == NULL)

	cmp	DWORD PTR _catalogs$11[ebp], 0
	jne	$LN13@xmlInitial

; 3127 : #if defined(_WIN32) && defined(_MSC_VER)
; 3128 :     {
; 3129 : 		void* hmodule;
; 3130 : 		hmodule = GetModuleHandleA("libxml2.dll");

	push	OFFSET ??_C@_0M@BAPINHKH@libxml2?4dll@
	call	_GetModuleHandleA@4
	mov	DWORD PTR _hmodule$5[ebp], eax

; 3131 : 		if (hmodule == NULL)

	cmp	DWORD PTR _hmodule$5[ebp], 0
	jne	SHORT $LN14@xmlInitial

; 3132 : 			hmodule = GetModuleHandleA(NULL);

	push	0
	call	_GetModuleHandleA@4
	mov	DWORD PTR _hmodule$5[ebp], eax
$LN14@xmlInitial:

; 3133 : 		if (hmodule != NULL) {

	cmp	DWORD PTR _hmodule$5[ebp], 0
	je	$LN15@xmlInitial

; 3134 : 			char buf[256];
; 3135 : 			unsigned long len = GetModuleFileNameA(hmodule, buf, 255);

	push	255					; 000000ffH
	lea	ecx, DWORD PTR _buf$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _hmodule$5[ebp]
	push	edx
	call	_GetModuleFileNameA@12
	mov	DWORD PTR _len$3[ebp], eax

; 3136 : 			if (len != 0) {

	cmp	DWORD PTR _len$3[ebp], 0
	je	$LN15@xmlInitial

; 3137 : 				char* p = &(buf[len]);

	mov	eax, DWORD PTR _len$3[ebp]
	lea	ecx, DWORD PTR _buf$4[ebp+eax]
	mov	DWORD PTR _p$2[ebp], ecx
$LN2@xmlInitial:

; 3138 : 				while (*p != '\\' && p > buf)

	mov	edx, DWORD PTR _p$2[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN3@xmlInitial
	lea	ecx, DWORD PTR _buf$4[ebp]
	cmp	DWORD PTR _p$2[ebp], ecx
	jbe	SHORT $LN3@xmlInitial

; 3139 : 					p--;

	mov	edx, DWORD PTR _p$2[ebp]
	sub	edx, 1
	mov	DWORD PTR _p$2[ebp], edx
	jmp	SHORT $LN2@xmlInitial
$LN3@xmlInitial:

; 3140 : 				if (p != buf) {

	lea	eax, DWORD PTR _buf$4[ebp]
	cmp	DWORD PTR _p$2[ebp], eax
	je	$LN15@xmlInitial

; 3141 : 					xmlChar* uri;
; 3142 : 					strncpy(p, "\\..\\etc\\catalog", 255 - (p - buf));

	mov	ecx, DWORD PTR _p$2[ebp]
	lea	edx, DWORD PTR _buf$4[ebp]
	sub	ecx, edx
	mov	eax, 255				; 000000ffH
	sub	eax, ecx
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0BA@IDHJNFKC@?2?4?4?2etc?2catalog@
	mov	ecx, DWORD PTR _p$2[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3143 : 					uri = xmlCanonicPath((const xmlChar*)buf);

	lea	edx, DWORD PTR _buf$4[ebp]
	push	edx
	call	_xmlCanonicPath
	add	esp, 4
	mov	DWORD PTR _uri$1[ebp], eax

; 3144 : 					if (uri != NULL) {

	cmp	DWORD PTR _uri$1[ebp], 0
	je	SHORT $LN15@xmlInitial

; 3145 : 						strncpy(XML_XML_DEFAULT_CATALOG, uri, 255);

	mov	esi, esp
	push	255					; 000000ffH
	mov	eax, DWORD PTR _uri$1[ebp]
	push	eax
	push	OFFSET _XML_XML_DEFAULT_CATALOG
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3146 : 						xmlFree(uri);

	mov	esi, esp
	mov	ecx, DWORD PTR _uri$1[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@xmlInitial:

; 3147 : 					}
; 3148 : 				}
; 3149 : 			}
; 3150 : 		}
; 3151 : 		catalogs = XML_XML_DEFAULT_CATALOG;

	mov	DWORD PTR _catalogs$11[ebp], OFFSET _XML_XML_DEFAULT_CATALOG
$LN13@xmlInitial:

; 3152 :     }
; 3153 : #else
; 3154 : 	    catalogs = XML_XML_DEFAULT_CATALOG;
; 3155 : #endif
; 3156 : 
; 3157 : 	catal = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE,

	mov	edx, DWORD PTR _xmlCatalogDefaultPrefer
	push	edx
	push	1
	call	_xmlCreateNewCatalog
	add	esp, 8
	mov	DWORD PTR _catal$7[ebp], eax

; 3158 : 		xmlCatalogDefaultPrefer);
; 3159 : 	if (catal != NULL) {

	cmp	DWORD PTR _catal$7[ebp], 0
	je	$LN12@xmlInitial

; 3160 : 	    /* the XML_CATALOG_FILES envvar is allowed to contain a
; 3161 : 	       space-separated list of entries. */
; 3162 : 	    cur = catalogs;

	mov	eax, DWORD PTR _catalogs$11[ebp]
	mov	DWORD PTR _cur$9[ebp], eax

; 3163 : 	    nextent = &catal->xml;

	mov	ecx, DWORD PTR _catal$7[ebp]
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR _nextent$6[ebp], ecx
$LN4@xmlInitial:

; 3164 : 	    while (*cur != '\0') {

	mov	edx, DWORD PTR _cur$9[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN5@xmlInitial
$LN6@xmlInitial:

; 3165 : 		while (xmlIsBlank_ch(*cur))

	mov	ecx, DWORD PTR _cur$9[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN20@xmlInitial
	mov	eax, DWORD PTR _cur$9[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN21@xmlInitial
	mov	edx, DWORD PTR _cur$9[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN20@xmlInitial
$LN21@xmlInitial:
	mov	ecx, DWORD PTR _cur$9[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN7@xmlInitial
$LN20@xmlInitial:

; 3166 : 		    cur++;

	mov	eax, DWORD PTR _cur$9[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$9[ebp], eax
	jmp	SHORT $LN6@xmlInitial
$LN7@xmlInitial:

; 3167 : 		if (*cur != 0) {

	mov	ecx, DWORD PTR _cur$9[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN22@xmlInitial

; 3168 : 		    paths = cur;

	mov	eax, DWORD PTR _cur$9[ebp]
	mov	DWORD PTR _paths$8[ebp], eax
$LN8@xmlInitial:

; 3169 : 		    while ((*cur != 0) && (!xmlIsBlank_ch(*cur)))

	mov	ecx, DWORD PTR _cur$9[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN9@xmlInitial
	mov	eax, DWORD PTR _cur$9[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN9@xmlInitial
	mov	edx, DWORD PTR _cur$9[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN23@xmlInitial
	mov	ecx, DWORD PTR _cur$9[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN9@xmlInitial
$LN23@xmlInitial:
	mov	eax, DWORD PTR _cur$9[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN9@xmlInitial

; 3170 : 			cur++;

	mov	edx, DWORD PTR _cur$9[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$9[ebp], edx
	jmp	SHORT $LN8@xmlInitial
$LN9@xmlInitial:

; 3171 : 		    path = (char *) xmlStrndup((const xmlChar *)paths, cur - paths);

	mov	eax, DWORD PTR _cur$9[ebp]
	sub	eax, DWORD PTR _paths$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _paths$8[ebp]
	push	ecx
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR _path$10[ebp], eax

; 3172 : 		    if (path != NULL) {

	cmp	DWORD PTR _path$10[ebp], 0
	je	SHORT $LN22@xmlInitial

; 3173 : 			*nextent = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,

	push	0
	mov	edx, DWORD PTR _xmlCatalogDefaultPrefer
	push	edx
	mov	eax, DWORD PTR _path$10[ebp]
	push	eax
	push	0
	push	0
	push	1
	call	_xmlNewCatalogEntry
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _nextent$6[ebp]
	mov	DWORD PTR [ecx], eax

; 3174 : 				NULL, BAD_CAST path, xmlCatalogDefaultPrefer, NULL);
; 3175 : 			if (*nextent != NULL)

	mov	edx, DWORD PTR _nextent$6[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN25@xmlInitial

; 3176 : 			    nextent = &((*nextent)->next);

	mov	eax, DWORD PTR _nextent$6[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nextent$6[ebp], ecx
$LN25@xmlInitial:

; 3177 : 			xmlFree(path);

	mov	esi, esp
	mov	edx, DWORD PTR _path$10[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN22@xmlInitial:

; 3178 : 		    }
; 3179 : 		}
; 3180 : 	    }

	jmp	$LN4@xmlInitial
$LN5@xmlInitial:

; 3181 : 	    xmlDefaultCatalog = catal;

	mov	eax, DWORD PTR _catal$7[ebp]
	mov	DWORD PTR _xmlDefaultCatalog, eax
$LN12@xmlInitial:

; 3182 : 	}
; 3183 :     }
; 3184 : 
; 3185 :     xmlRMutexUnlock(xmlCatalogMutex);

	mov	ecx, DWORD PTR _xmlCatalogMutex
	push	ecx
	call	_xmlRMutexUnlock
	add	esp, 4
$LN1@xmlInitial:

; 3186 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN29@xmlInitial
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN29@xmlInitial:
	DD	1
	DD	$LN28@xmlInitial
$LN28@xmlInitial:
	DD	-288					; fffffee0H
	DD	256					; 00000100H
	DD	$LN27@xmlInitial
$LN27@xmlInitial:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_xmlInitializeCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogIsEmpty
_TEXT	SEGMENT
_res$1 = -4						; size = 4
_catal$ = 8						; size = 4
_xmlCatalogIsEmpty PROC					; COMDAT

; 3048 : xmlCatalogIsEmpty(xmlCatalogPtr catal) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3049 :     if (catal == NULL)

	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN2@xmlCatalog

; 3050 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlCatalog
$LN2@xmlCatalog:

; 3051 : 
; 3052 :     if (catal->type == XML_XML_CATALOG_TYPE) {

	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN3@xmlCatalog

; 3053 : 	if (catal->xml == NULL)

	mov	ecx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [ecx+60], 0
	jne	SHORT $LN5@xmlCatalog

; 3054 : 	    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlCatalog
$LN5@xmlCatalog:

; 3055 : 	if ((catal->xml->type != XML_CATA_CATALOG) &&

	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+60]
	cmp	DWORD PTR [eax+12], 1
	je	SHORT $LN6@xmlCatalog
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	cmp	DWORD PTR [edx+12], 2
	je	SHORT $LN6@xmlCatalog

; 3056 : 	    (catal->xml->type != XML_CATA_BROKEN_CATALOG))
; 3057 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlCatalog
$LN6@xmlCatalog:

; 3058 : 	if (catal->xml->children == NULL)

	mov	eax, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN7@xmlCatalog

; 3059 : 	    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlCatalog
$LN7@xmlCatalog:

; 3060 :         return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCatalog

; 3061 :     } else {

	jmp	SHORT $LN4@xmlCatalog
$LN3@xmlCatalog:

; 3062 : 	int res;
; 3063 : 
; 3064 : 	if (catal->sgml == NULL)

	mov	edx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [edx+52], 0
	jne	SHORT $LN8@xmlCatalog

; 3065 : 	    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlCatalog
$LN8@xmlCatalog:

; 3066 : 	res = xmlHashSize(catal->sgml);

	mov	eax, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	_xmlHashSize
	add	esp, 4
	mov	DWORD PTR _res$1[ebp], eax

; 3067 : 	if (res == 0)

	cmp	DWORD PTR _res$1[ebp], 0
	jne	SHORT $LN9@xmlCatalog

; 3068 : 	    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlCatalog
$LN9@xmlCatalog:

; 3069 : 	if (res < 0)

	cmp	DWORD PTR _res$1[ebp], 0
	jge	SHORT $LN4@xmlCatalog

; 3070 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlCatalog
$LN4@xmlCatalog:

; 3071 :     }
; 3072 :     return(0);

	xor	eax, eax
$LN1@xmlCatalog:

; 3073 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogIsEmpty ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlFreeCatalog
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_xmlFreeCatalog PROC					; COMDAT

; 440  : xmlFreeCatalog(xmlCatalogPtr catal) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 441  :     if (catal == NULL)

	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN2@xmlFreeCat

; 442  : 	return;

	jmp	SHORT $LN1@xmlFreeCat
$LN2@xmlFreeCat:

; 443  :     if (catal->xml != NULL)

	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax+60], 0
	je	SHORT $LN3@xmlFreeCat

; 444  : 	xmlFreeCatalogEntryList(catal->xml);

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	call	_xmlFreeCatalogEntryList
	add	esp, 4
$LN3@xmlFreeCat:

; 445  :     if (catal->sgml != NULL)

	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN4@xmlFreeCat

; 446  : 	xmlHashFree(catal->sgml, xmlFreeCatalogEntry);

	push	OFFSET _xmlFreeCatalogEntry
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_xmlHashFree
	add	esp, 8
$LN4@xmlFreeCat:

; 447  :     xmlFree(catal);

	mov	esi, esp
	mov	eax, DWORD PTR _catal$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlFreeCat:

; 448  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFreeCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlACatalogDump
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_out$ = 12						; size = 4
_xmlACatalogDump PROC					; COMDAT

; 2938 : xmlACatalogDump(xmlCatalogPtr catal, FILE *out) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2939 :     if ((out == NULL) || (catal == NULL))

	cmp	DWORD PTR _out$[ebp], 0
	je	SHORT $LN3@xmlACatalo
	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN2@xmlACatalo
$LN3@xmlACatalo:

; 2940 : 	return;

	jmp	SHORT $LN1@xmlACatalo
$LN2@xmlACatalo:

; 2941 : 
; 2942 :     if (catal->type == XML_XML_CATALOG_TYPE) {

	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN4@xmlACatalo

; 2943 : 	xmlDumpXMLCatalog(out, catal->xml);

	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_xmlDumpXMLCatalog
	add	esp, 8

; 2944 :     } else {

	jmp	SHORT $LN1@xmlACatalo
$LN4@xmlACatalo:

; 2945 : 	xmlHashScan(catal->sgml, xmlCatalogDumpEntry, out);

	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	push	OFFSET _xmlCatalogDumpEntry
	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN1@xmlACatalo:

; 2946 :     }
; 2947 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlACatalogDump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlACatalogResolveURI
_TEXT	SEGMENT
_sgml$1 = -8						; size = 4
_ret$ = -4						; size = 4
_catal$ = 8						; size = 4
_URI$ = 12						; size = 4
_xmlACatalogResolveURI PROC				; COMDAT

; 2905 : xmlACatalogResolveURI(xmlCatalogPtr catal, const xmlChar *URI) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2906 :     xmlChar *ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 2907 : 
; 2908 :     if ((URI == NULL) || (catal == NULL))

	cmp	DWORD PTR _URI$[ebp], 0
	je	SHORT $LN3@xmlACatalo
	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN2@xmlACatalo
$LN3@xmlACatalo:

; 2909 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlACatalo
$LN2@xmlACatalo:

; 2910 : 
; 2911 :     if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN4@xmlACatalo

; 2912 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _URI$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@GHNHNPIN@Resolve?5URI?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlACatalo:

; 2913 : 		"Resolve URI %s\n", URI);
; 2914 : 
; 2915 :     if (catal->type == XML_XML_CATALOG_TYPE) {

	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN5@xmlACatalo

; 2916 : 	ret = xmlCatalogListXMLResolveURI(catal->xml, URI);

	mov	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+60]
	push	eax
	call	_xmlCatalogListXMLResolveURI
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2917 : 	if (ret == XML_CATAL_BREAK)

	cmp	DWORD PTR _ret$[ebp], -1
	jne	SHORT $LN7@xmlACatalo

; 2918 : 	    ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0
$LN7@xmlACatalo:

; 2919 :     } else {

	jmp	SHORT $LN6@xmlACatalo
$LN5@xmlACatalo:

; 2920 : 	const xmlChar *sgml;
; 2921 : 
; 2922 : 	sgml = xmlCatalogSGMLResolve(catal, NULL, URI);

	mov	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _catal$[ebp]
	push	edx
	call	_xmlCatalogSGMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sgml$1[ebp], eax

; 2923 : 	if (sgml != NULL)

	cmp	DWORD PTR _sgml$1[ebp], 0
	je	SHORT $LN6@xmlACatalo

; 2924 :             ret = xmlStrdup(sgml);

	mov	eax, DWORD PTR _sgml$1[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax
$LN6@xmlACatalo:

; 2925 :     }
; 2926 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlACatalo:

; 2927 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlACatalogResolveURI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlACatalogResolvePublic
_TEXT	SEGMENT
_sgml$1 = -8						; size = 4
_ret$ = -4						; size = 4
_catal$ = 8						; size = 4
_pubID$ = 12						; size = 4
_xmlACatalogResolvePublic PROC				; COMDAT

; 2823 : xmlACatalogResolvePublic(xmlCatalogPtr catal, const xmlChar *pubID) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2824 :     xmlChar *ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 2825 : 
; 2826 :     if ((pubID == NULL) || (catal == NULL))

	cmp	DWORD PTR _pubID$[ebp], 0
	je	SHORT $LN3@xmlACatalo
	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN2@xmlACatalo
$LN3@xmlACatalo:

; 2827 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlACatalo
$LN2@xmlACatalo:

; 2828 : 
; 2829 :     if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN4@xmlACatalo

; 2830 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _pubID$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@IFIFPGFD@Resolve?5pubID?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlACatalo:

; 2831 : 		"Resolve pubID %s\n", pubID);
; 2832 : 
; 2833 :     if (catal->type == XML_XML_CATALOG_TYPE) {

	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN5@xmlACatalo

; 2834 : 	ret = xmlCatalogListXMLResolve(catal->xml, pubID, NULL);

	push	0
	mov	ecx, DWORD PTR _pubID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+60]
	push	eax
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 2835 : 	if (ret == XML_CATAL_BREAK)

	cmp	DWORD PTR _ret$[ebp], -1
	jne	SHORT $LN7@xmlACatalo

; 2836 : 	    ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0
$LN7@xmlACatalo:

; 2837 :     } else {

	jmp	SHORT $LN6@xmlACatalo
$LN5@xmlACatalo:

; 2838 : 	const xmlChar *sgml;
; 2839 : 
; 2840 : 	sgml = xmlCatalogGetSGMLPublic(catal->sgml, pubID);

	mov	ecx, DWORD PTR _pubID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_xmlCatalogGetSGMLPublic
	add	esp, 8
	mov	DWORD PTR _sgml$1[ebp], eax

; 2841 : 	if (sgml != NULL)

	cmp	DWORD PTR _sgml$1[ebp], 0
	je	SHORT $LN6@xmlACatalo

; 2842 : 	    ret = xmlStrdup(sgml);

	mov	ecx, DWORD PTR _sgml$1[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax
$LN6@xmlACatalo:

; 2843 :     }
; 2844 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlACatalo:

; 2845 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlACatalogResolvePublic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlACatalogResolveSystem
_TEXT	SEGMENT
_sgml$1 = -8						; size = 4
_ret$ = -4						; size = 4
_catal$ = 8						; size = 4
_sysID$ = 12						; size = 4
_xmlACatalogResolveSystem PROC				; COMDAT

; 2788 : xmlACatalogResolveSystem(xmlCatalogPtr catal, const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2789 :     xmlChar *ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 2790 : 
; 2791 :     if ((sysID == NULL) || (catal == NULL))

	cmp	DWORD PTR _sysID$[ebp], 0
	je	SHORT $LN3@xmlACatalo
	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN2@xmlACatalo
$LN3@xmlACatalo:

; 2792 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlACatalo
$LN2@xmlACatalo:

; 2793 : 
; 2794 :     if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN4@xmlACatalo

; 2795 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _sysID$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@DIJHIPPB@Resolve?5sysID?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlACatalo:

; 2796 : 		"Resolve sysID %s\n", sysID);
; 2797 : 
; 2798 :     if (catal->type == XML_XML_CATALOG_TYPE) {

	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN5@xmlACatalo

; 2799 : 	ret = xmlCatalogListXMLResolve(catal->xml, NULL, sysID);

	mov	ecx, DWORD PTR _sysID$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+60]
	push	eax
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 2800 : 	if (ret == XML_CATAL_BREAK)

	cmp	DWORD PTR _ret$[ebp], -1
	jne	SHORT $LN7@xmlACatalo

; 2801 : 	    ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0
$LN7@xmlACatalo:

; 2802 :     } else {

	jmp	SHORT $LN6@xmlACatalo
$LN5@xmlACatalo:

; 2803 : 	const xmlChar *sgml;
; 2804 : 
; 2805 : 	sgml = xmlCatalogGetSGMLSystem(catal->sgml, sysID);

	mov	ecx, DWORD PTR _sysID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_xmlCatalogGetSGMLSystem
	add	esp, 8
	mov	DWORD PTR _sgml$1[ebp], eax

; 2806 : 	if (sgml != NULL)

	cmp	DWORD PTR _sgml$1[ebp], 0
	je	SHORT $LN6@xmlACatalo

; 2807 : 	    ret = xmlStrdup(sgml);

	mov	ecx, DWORD PTR _sgml$1[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax
$LN6@xmlACatalo:

; 2808 :     }
; 2809 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlACatalo:

; 2810 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlACatalogResolveSystem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlACatalogResolve
_TEXT	SEGMENT
_sgml$1 = -8						; size = 4
_ret$ = -4						; size = 4
_catal$ = 8						; size = 4
_pubID$ = 12						; size = 4
_sysID$ = 16						; size = 4
_xmlACatalogResolve PROC				; COMDAT

; 2861 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2862 :     xmlChar *ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 2863 : 
; 2864 :     if (((pubID == NULL) && (sysID == NULL)) || (catal == NULL))

	cmp	DWORD PTR _pubID$[ebp], 0
	jne	SHORT $LN4@xmlACatalo
	cmp	DWORD PTR _sysID$[ebp], 0
	je	SHORT $LN3@xmlACatalo
$LN4@xmlACatalo:
	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN2@xmlACatalo
$LN3@xmlACatalo:

; 2865 :         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlACatalo
$LN2@xmlACatalo:

; 2866 : 
; 2867 :     if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	$LN5@xmlACatalo

; 2868 :          if ((pubID != NULL) && (sysID != NULL)) {

	cmp	DWORD PTR _pubID$[ebp], 0
	je	SHORT $LN6@xmlACatalo
	cmp	DWORD PTR _sysID$[ebp], 0
	je	SHORT $LN6@xmlACatalo

; 2869 :              xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _sysID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pubID$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BM@EMMNBONF@Resolve?3?5pubID?5?$CFs?5sysID?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN5@xmlACatalo
$LN6@xmlACatalo:

; 2870 :                              "Resolve: pubID %s sysID %s\n", pubID, sysID);
; 2871 :          } else if (pubID != NULL) {

	cmp	DWORD PTR _pubID$[ebp], 0
	je	SHORT $LN8@xmlACatalo

; 2872 :              xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _pubID$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BD@JDBJIPCK@Resolve?3?5pubID?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2873 :                              "Resolve: pubID %s\n", pubID);
; 2874 :          } else {

	jmp	SHORT $LN5@xmlACatalo
$LN8@xmlACatalo:

; 2875 :              xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _sysID$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BD@COALPGII@Resolve?3?5sysID?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@xmlACatalo:

; 2876 :                              "Resolve: sysID %s\n", sysID);
; 2877 :          }
; 2878 :     }
; 2879 : 
; 2880 :     if (catal->type == XML_XML_CATALOG_TYPE) {

	mov	ecx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN10@xmlACatalo

; 2881 :         ret = xmlCatalogListXMLResolve(catal->xml, pubID, sysID);

	mov	edx, DWORD PTR _sysID$[ebp]
	push	edx
	mov	eax, DWORD PTR _pubID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 2882 : 	if (ret == XML_CATAL_BREAK)

	cmp	DWORD PTR _ret$[ebp], -1
	jne	SHORT $LN12@xmlACatalo

; 2883 : 	    ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0
$LN12@xmlACatalo:

; 2884 :     } else {

	jmp	SHORT $LN11@xmlACatalo
$LN10@xmlACatalo:

; 2885 :         const xmlChar *sgml;
; 2886 : 
; 2887 :         sgml = xmlCatalogSGMLResolve(catal, pubID, sysID);

	mov	eax, DWORD PTR _sysID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pubID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catal$[ebp]
	push	edx
	call	_xmlCatalogSGMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sgml$1[ebp], eax

; 2888 :         if (sgml != NULL)

	cmp	DWORD PTR _sgml$1[ebp], 0
	je	SHORT $LN11@xmlACatalo

; 2889 :             ret = xmlStrdup(sgml);

	mov	eax, DWORD PTR _sgml$1[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax
$LN11@xmlACatalo:

; 2890 :     }
; 2891 :     return (ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlACatalo:

; 2892 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlACatalogResolve ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlACatalogRemove
_TEXT	SEGMENT
_res$ = -4						; size = 4
_catal$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlACatalogRemove PROC					; COMDAT

; 3000 : xmlACatalogRemove(xmlCatalogPtr catal, const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3001 :     int res = -1;

	mov	DWORD PTR _res$[ebp], -1

; 3002 : 
; 3003 :     if ((catal == NULL) || (value == NULL))

	cmp	DWORD PTR _catal$[ebp], 0
	je	SHORT $LN3@xmlACatalo
	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN2@xmlACatalo
$LN3@xmlACatalo:

; 3004 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlACatalo
$LN2@xmlACatalo:

; 3005 : 
; 3006 :     if (catal->type == XML_XML_CATALOG_TYPE) {

	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN4@xmlACatalo

; 3007 : 	res = xmlDelXMLCatalog(catal->xml, value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+60]
	push	eax
	call	_xmlDelXMLCatalog
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 3008 :     } else {

	jmp	SHORT $LN5@xmlACatalo
$LN4@xmlACatalo:

; 3009 : 	res = xmlHashRemoveEntry(catal->sgml, value, xmlFreeCatalogEntry);

	push	OFFSET _xmlFreeCatalogEntry
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_xmlHashRemoveEntry
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _res$[ebp], eax

; 3010 : 	if (res == 0)

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN5@xmlACatalo

; 3011 : 	    res = 1;

	mov	DWORD PTR _res$[ebp], 1
$LN5@xmlACatalo:

; 3012 :     }
; 3013 :     return(res);

	mov	eax, DWORD PTR _res$[ebp]
$LN1@xmlACatalo:

; 3014 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlACatalogRemove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlACatalogAdd
_TEXT	SEGMENT
_entry$1 = -12						; size = 4
_cattype$2 = -8						; size = 4
_res$ = -4						; size = 4
_catal$ = 8						; size = 4
_type$ = 12						; size = 4
_orig$ = 16						; size = 4
_replace$ = 20						; size = 4
_xmlACatalogAdd PROC					; COMDAT

; 2965 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2966 :     int res = -1;

	mov	DWORD PTR _res$[ebp], -1

; 2967 : 
; 2968 :     if (catal == NULL)

	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN2@xmlACatalo

; 2969 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlACatalo
$LN2@xmlACatalo:

; 2970 : 
; 2971 :     if (catal->type == XML_XML_CATALOG_TYPE) {

	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN3@xmlACatalo

; 2972 :         res = xmlAddXMLCatalog(catal->xml, type, orig, replace);

	mov	ecx, DWORD PTR _replace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _orig$[ebp]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	call	_xmlAddXMLCatalog
	add	esp, 16					; 00000010H
	mov	DWORD PTR _res$[ebp], eax

; 2973 :     } else {

	jmp	SHORT $LN4@xmlACatalo
$LN3@xmlACatalo:

; 2974 :         xmlCatalogEntryType cattype;
; 2975 : 
; 2976 :         cattype = xmlGetSGMLCatalogEntryType(type);

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	call	_xmlGetSGMLCatalogEntryType
	add	esp, 4
	mov	DWORD PTR _cattype$2[ebp], eax

; 2977 :         if (cattype != XML_CATA_NONE) {

	cmp	DWORD PTR _cattype$2[ebp], 0
	je	SHORT $LN4@xmlACatalo

; 2978 :             xmlCatalogEntryPtr entry;
; 2979 : 
; 2980 :             entry = xmlNewCatalogEntry(cattype, orig, replace, NULL,

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _replace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _orig$[ebp]
	push	edx
	mov	eax, DWORD PTR _cattype$2[ebp]
	push	eax
	call	_xmlNewCatalogEntry
	add	esp, 24					; 00000018H
	mov	DWORD PTR _entry$1[ebp], eax

; 2981 :                                        XML_CATA_PREFER_NONE, NULL);
; 2982 : 	    if (catal->sgml == NULL)

	mov	ecx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	jne	SHORT $LN6@xmlACatalo

; 2983 : 		catal->sgml = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	add	esp, 4
	mov	edx, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [edx+52], eax
$LN6@xmlACatalo:

; 2984 :             res = xmlHashAddEntry(catal->sgml, orig, entry);

	mov	eax, DWORD PTR _entry$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _orig$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catal$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_xmlHashAddEntry
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _res$[ebp], eax
$LN4@xmlACatalo:

; 2985 :         }
; 2986 :     }
; 2987 :     return (res);

	mov	eax, DWORD PTR _res$[ebp]
$LN1@xmlACatalo:

; 2988 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlACatalogAdd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlConvertSGMLCatalog
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_xmlConvertSGMLCatalog PROC				; COMDAT

; 798  : xmlConvertSGMLCatalog(xmlCatalogPtr catal) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 799  : 
; 800  :     if ((catal == NULL) || (catal->type != XML_SGML_CATALOG_TYPE))

	cmp	DWORD PTR _catal$[ebp], 0
	je	SHORT $LN3@xmlConvert
	mov	eax, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [eax], 2
	je	SHORT $LN2@xmlConvert
$LN3@xmlConvert:

; 801  : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlConvert
$LN2@xmlConvert:

; 802  : 
; 803  :     if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN4@xmlConvert

; 804  : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CA@PPIGJEMK@Converting?5SGML?5catalog?5to?5XML?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlConvert:

; 805  : 		"Converting SGML catalog to XML\n");
; 806  :     }
; 807  :     xmlHashScan(catal->sgml, xmlCatalogConvertEntry, &catal);

	lea	eax, DWORD PTR _catal$[ebp]
	push	eax
	push	OFFSET _xmlCatalogConvertEntry
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_xmlHashScan
	add	esp, 12					; 0000000cH

; 808  :     return(0);

	xor	eax, eax
$LN1@xmlConvert:

; 809  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlConvertSGMLCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlLoadSGMLSuperCatalog
_TEXT	SEGMENT
_ret$ = -12						; size = 4
_catal$ = -8						; size = 4
_content$ = -4						; size = 4
_filename$ = 8						; size = 4
_xmlLoadSGMLSuperCatalog PROC				; COMDAT

; 2649 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2650 :     xmlChar *content;
; 2651 :     xmlCatalogPtr catal;
; 2652 :     int ret;
; 2653 : 
; 2654 :     content = xmlLoadFileContent(filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlLoadFileContent
	add	esp, 4
	mov	DWORD PTR _content$[ebp], eax

; 2655 :     if (content == NULL)

	cmp	DWORD PTR _content$[ebp], 0
	jne	SHORT $LN2@xmlLoadSGM

; 2656 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlLoadSGM
$LN2@xmlLoadSGM:

; 2657 : 
; 2658 :     catal = xmlCreateNewCatalog(XML_SGML_CATALOG_TYPE, xmlCatalogDefaultPrefer);

	mov	ecx, DWORD PTR _xmlCatalogDefaultPrefer
	push	ecx
	push	2
	call	_xmlCreateNewCatalog
	add	esp, 8
	mov	DWORD PTR _catal$[ebp], eax

; 2659 :     if (catal == NULL) {

	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN3@xmlLoadSGM

; 2660 : 	xmlFree(content);

	mov	esi, esp
	mov	edx, DWORD PTR _content$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2661 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlLoadSGM
$LN3@xmlLoadSGM:

; 2662 :     }
; 2663 : 
; 2664 :     ret = xmlParseSGMLCatalog(catal, content, filename, 1);

	push	1
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _content$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catal$[ebp]
	push	edx
	call	_xmlParseSGMLCatalog
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 2665 :     xmlFree(content);

	mov	esi, esp
	mov	eax, DWORD PTR _content$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2666 :     if (ret < 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN4@xmlLoadSGM

; 2667 : 	xmlFreeCatalog(catal);

	mov	ecx, DWORD PTR _catal$[ebp]
	push	ecx
	call	_xmlFreeCatalog
	add	esp, 4

; 2668 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlLoadSGM
$LN4@xmlLoadSGM:

; 2669 :     }
; 2670 :     return (catal);

	mov	eax, DWORD PTR _catal$[ebp]
$LN1@xmlLoadSGM:

; 2671 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlLoadSGMLSuperCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlLoadACatalog
_TEXT	SEGMENT
_ret$ = -16						; size = 4
_catal$ = -12						; size = 4
_first$ = -8						; size = 4
_content$ = -4						; size = 4
_filename$ = 8						; size = 4
_xmlLoadACatalog PROC					; COMDAT

; 2686 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 2687 :     xmlChar *content;
; 2688 :     xmlChar *first;
; 2689 :     xmlCatalogPtr catal;
; 2690 :     int ret;
; 2691 : 
; 2692 :     content = xmlLoadFileContent(filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlLoadFileContent
	add	esp, 4
	mov	DWORD PTR _content$[ebp], eax

; 2693 :     if (content == NULL)

	cmp	DWORD PTR _content$[ebp], 0
	jne	SHORT $LN4@xmlLoadACa

; 2694 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlLoadACa
$LN4@xmlLoadACa:

; 2695 : 
; 2696 : 
; 2697 :     first = content;

	mov	ecx, DWORD PTR _content$[ebp]
	mov	DWORD PTR _first$[ebp], ecx
$LN2@xmlLoadACa:

; 2698 : 
; 2699 :     while ((*first != 0) && (*first != '-') && (*first != '<') &&

	mov	edx, DWORD PTR _first$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN3@xmlLoadACa
	mov	ecx, DWORD PTR _first$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	je	SHORT $LN3@xmlLoadACa
	mov	eax, DWORD PTR _first$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 60					; 0000003cH
	je	SHORT $LN3@xmlLoadACa
	mov	edx, DWORD PTR _first$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN5@xmlLoadACa
	mov	ecx, DWORD PTR _first$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 90					; 0000005aH
	jle	SHORT $LN3@xmlLoadACa
$LN5@xmlLoadACa:
	mov	eax, DWORD PTR _first$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN6@xmlLoadACa
	mov	edx, DWORD PTR _first$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 122				; 0000007aH
	jle	SHORT $LN3@xmlLoadACa
$LN6@xmlLoadACa:

; 2700 : 	   (!(((*first >= 'A') && (*first <= 'Z')) ||
; 2701 : 	      ((*first >= 'a') && (*first <= 'z')))))
; 2702 : 	first++;

	mov	ecx, DWORD PTR _first$[ebp]
	add	ecx, 1
	mov	DWORD PTR _first$[ebp], ecx
	jmp	SHORT $LN2@xmlLoadACa
$LN3@xmlLoadACa:

; 2703 : 
; 2704 :     if (*first != '<') {

	mov	edx, DWORD PTR _first$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN7@xmlLoadACa

; 2705 : 	catal = xmlCreateNewCatalog(XML_SGML_CATALOG_TYPE, xmlCatalogDefaultPrefer);

	mov	ecx, DWORD PTR _xmlCatalogDefaultPrefer
	push	ecx
	push	2
	call	_xmlCreateNewCatalog
	add	esp, 8
	mov	DWORD PTR _catal$[ebp], eax

; 2706 : 	if (catal == NULL) {

	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN9@xmlLoadACa

; 2707 : 	    xmlFree(content);

	mov	esi, esp
	mov	edx, DWORD PTR _content$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2708 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlLoadACa
$LN9@xmlLoadACa:

; 2709 : 	}
; 2710 :         ret = xmlParseSGMLCatalog(catal, content, filename, 0);

	push	0
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _content$[ebp]
	push	ecx
	mov	edx, DWORD PTR _catal$[ebp]
	push	edx
	call	_xmlParseSGMLCatalog
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 2711 : 	if (ret < 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN10@xmlLoadACa

; 2712 : 	    xmlFreeCatalog(catal);

	mov	eax, DWORD PTR _catal$[ebp]
	push	eax
	call	_xmlFreeCatalog
	add	esp, 4

; 2713 : 	    xmlFree(content);

	mov	esi, esp
	mov	ecx, DWORD PTR _content$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2714 : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlLoadACa
$LN10@xmlLoadACa:

; 2715 : 	}
; 2716 :     } else {

	jmp	SHORT $LN8@xmlLoadACa
$LN7@xmlLoadACa:

; 2717 : 	catal = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE, xmlCatalogDefaultPrefer);

	mov	edx, DWORD PTR _xmlCatalogDefaultPrefer
	push	edx
	push	1
	call	_xmlCreateNewCatalog
	add	esp, 8
	mov	DWORD PTR _catal$[ebp], eax

; 2718 : 	if (catal == NULL) {

	cmp	DWORD PTR _catal$[ebp], 0
	jne	SHORT $LN11@xmlLoadACa

; 2719 : 	    xmlFree(content);

	mov	esi, esp
	mov	eax, DWORD PTR _content$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2720 : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlLoadACa
$LN11@xmlLoadACa:

; 2721 : 	}
; 2722 :         catal->xml = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,

	push	0
	mov	ecx, DWORD PTR _xmlCatalogDefaultPrefer
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	0
	push	0
	push	1
	call	_xmlNewCatalogEntry
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [ecx+60], eax
$LN8@xmlLoadACa:

; 2723 : 		       NULL, BAD_CAST filename, xmlCatalogDefaultPrefer, NULL);
; 2724 :     }
; 2725 :     xmlFree(content);

	mov	esi, esp
	mov	edx, DWORD PTR _content$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2726 :     return (catal);

	mov	eax, DWORD PTR _catal$[ebp]
$LN1@xmlLoadACa:

; 2727 : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlLoadACatalog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlNewCatalog
_TEXT	SEGMENT
_catal$ = -4						; size = 4
_sgml$ = 8						; size = 4
_xmlNewCatalog PROC					; COMDAT

; 3025 : xmlNewCatalog(int sgml) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 3026 :     xmlCatalogPtr catal = NULL;

	mov	DWORD PTR _catal$[ebp], 0

; 3027 : 
; 3028 :     if (sgml) {

	cmp	DWORD PTR _sgml$[ebp], 0
	je	SHORT $LN2@xmlNewCata

; 3029 : 	catal = xmlCreateNewCatalog(XML_SGML_CATALOG_TYPE,

	mov	eax, DWORD PTR _xmlCatalogDefaultPrefer
	push	eax
	push	2
	call	_xmlCreateNewCatalog
	add	esp, 8
	mov	DWORD PTR _catal$[ebp], eax

; 3030 : 		                    xmlCatalogDefaultPrefer);
; 3031 :         if ((catal != NULL) && (catal->sgml == NULL))

	cmp	DWORD PTR _catal$[ebp], 0
	je	SHORT $LN4@xmlNewCata
	mov	ecx, DWORD PTR _catal$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	jne	SHORT $LN4@xmlNewCata

; 3032 : 	    catal->sgml = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	add	esp, 4
	mov	edx, DWORD PTR _catal$[ebp]
	mov	DWORD PTR [edx+52], eax
$LN4@xmlNewCata:

; 3033 :     } else

	jmp	SHORT $LN3@xmlNewCata
$LN2@xmlNewCata:

; 3034 : 	catal = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE,

	mov	eax, DWORD PTR _xmlCatalogDefaultPrefer
	push	eax
	push	1
	call	_xmlCreateNewCatalog
	add	esp, 8
	mov	DWORD PTR _catal$[ebp], eax
$LN3@xmlNewCata:

; 3035 : 		                    xmlCatalogDefaultPrefer);
; 3036 :     return(catal);

	mov	eax, DWORD PTR _catal$[ebp]

; 3037 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNewCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
tv81 = -20						; size = 4
__Result$1 = -16					; size = 4
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __BufferCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	edx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR [eax+4]
	push	edx
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$1[ebp], eax

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$1[ebp], 0
	jge	SHORT $LN5@snprintf
	mov	DWORD PTR tv81[ebp], -1
	jmp	SHORT $LN3@snprintf
$LN5@snprintf:
	mov	eax, DWORD PTR __Result$1[ebp]
	mov	DWORD PTR tv81[ebp], eax
$LN3@snprintf:

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 1954 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1955 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1956 :     }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Stream$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 842  :     }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
