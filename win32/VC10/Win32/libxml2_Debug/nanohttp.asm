; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\nanohttp.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__194286D1_winsock2@h DB 01H
__D940C302_ws2ipdef@h DB 01H
__6E172A35_ws2tcpip@h DB 01H
__331E732B_malloc@h DB 01H
__D1B760F5_wspiapi@h DB 01H
__BDFA7347_nanohttp@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf_s
PUBLIC	_snprintf
PUBLIC	_WspiapiStrdup@4
PUBLIC	_WspiapiParseV4Address@8
PUBLIC	_WspiapiNewAddrInfo@16
PUBLIC	_WspiapiQueryDNS@24
PUBLIC	_WspiapiLookupNode@24
PUBLIC	_WspiapiClone@8
PUBLIC	_WspiapiLegacyFreeAddrInfo@4
PUBLIC	_WspiapiLegacyGetAddrInfo@16
PUBLIC	_WspiapiLegacyGetNameInfo@28
PUBLIC	_WspiapiLoad@4
PUBLIC	_xmlNanoHTTPInit
PUBLIC	_xmlNanoHTTPCleanup
PUBLIC	_xmlNanoHTTPScanProxy
PUBLIC	_xmlNanoHTTPFetch
PUBLIC	_xmlNanoHTTPMethod
PUBLIC	_xmlNanoHTTPMethodRedir
PUBLIC	_xmlNanoHTTPOpen
PUBLIC	_xmlNanoHTTPOpenRedir
PUBLIC	_xmlNanoHTTPReturnCode
PUBLIC	_xmlNanoHTTPAuthHeader
PUBLIC	_xmlNanoHTTPRedir
PUBLIC	_xmlNanoHTTPContentLength
PUBLIC	_xmlNanoHTTPEncoding
PUBLIC	_xmlNanoHTTPMimeType
PUBLIC	_xmlNanoHTTPRead
PUBLIC	_xmlNanoHTTPSave
PUBLIC	_xmlNanoHTTPClose
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_03OCLLGKEH@udp@				; `string'
PUBLIC	??_C@_03FPEIBLKH@tcp@				; `string'
PUBLIC	??_C@_05LGDGBMPG@65535@				; `string'
PUBLIC	??_C@_02GMHACPFF@?$CFu@				; `string'
PUBLIC	?bInitialized@?1??WspiapiLoad@@9@9		; `WspiapiLoad'::`2'::bInitialized
PUBLIC	?rgtGlobal@?1??WspiapiLoad@@9@9			; `WspiapiLoad'::`2'::rgtGlobal
PUBLIC	?iNumGlobal@?1??WspiapiLoad@@9@9		; `WspiapiLoad'::`2'::iNumGlobal
PUBLIC	??_C@_0M@MBIPAJOD@getaddrinfo@			; `string'
PUBLIC	??_C@_0M@NNJNLPKG@getnameinfo@			; `string'
PUBLIC	??_C@_0N@EHOPPMLH@freeaddrinfo@			; `string'
PUBLIC	??_C@_07LPPPKMHP@?2ws2_32@			; `string'
PUBLIC	??_C@_07OKMCKPF@?2wship6@			; `string'
PUBLIC	?pfGetAddrInfo@?1??WspiapiGetAddrInfo@@9@9	; `WspiapiGetAddrInfo'::`2'::pfGetAddrInfo
PUBLIC	?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9	; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
PUBLIC	??_C@_08BOGLDIEC@no_proxy@			; `string'
PUBLIC	??_C@_0L@BKCFCEPH@http_proxy@			; `string'
PUBLIC	??_C@_0L@GDPFKPEL@HTTP_PROXY@			; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_04IAFLKNP@http@				; `string'
PUBLIC	??_C@_0O@FGOLBKPK@Syntax?5Error?6@		; `string'
PUBLIC	??_C@_0BD@NMNFIMM@allocating?5context@		; `string'
PUBLIC	??_C@_0N@OOKOIPEM@send?5failed?6@		; `string'
PUBLIC	??_C@_0BB@BIOIGIMH@allocating?5input@		; `string'
PUBLIC	??_C@_0BI@IFIOEEDJ@allocating?5input?5buffer@	; `string'
PUBLIC	??_C@_0N@NLPHEKBL@recv?5failed?6@		; `string'
PUBLIC	??_C@_05FKGKDBHO@HTTP?1@			; `string'
PUBLIC	??_C@_0O@PDMPCIFL@Content?9Type?3@		; `string'
PUBLIC	??_C@_08JPKHBDLJ@charset?$DN@			; `string'
PUBLIC	??_C@_0N@PPOPBCJG@ContentType?3@		; `string'
PUBLIC	??_C@_09GILIFLDG@Location?3@			; `string'
PUBLIC	??_C@_07FGAOOBMN@http?3?1?1@			; `string'
PUBLIC	??_C@_0BC@EALNDOCH@WWW?9Authenticate?3@		; `string'
PUBLIC	??_C@_0BE@EKBPAAMO@Proxy?9Authenticate?3@	; `string'
PUBLIC	??_C@_0BC@FGDKEGD@Content?9Encoding?3@		; `string'
PUBLIC	??_C@_04HOHEGKBO@gzip@				; `string'
PUBLIC	??_C@_06CJNJFBNP@1?42?411@			; `string'
PUBLIC	??_C@_0BA@DIGAFIOK@Content?9Length?3@		; `string'
PUBLIC	??_C@_0P@KCNIDCEL@socket?5failed?6@		; `string'
PUBLIC	??_C@_0CA@IEPMFIHD@error?5connecting?5to?5HTTP?5server@ ; `string'
PUBLIC	??_C@_0BK@JJCGCHLC@Connect?5attempt?5timed?5out@ ; `string'
PUBLIC	??_C@_0P@NCGOJFHC@Connect?5failed@		; `string'
PUBLIC	??_C@_0BD@MBFEIJEJ@getsockopt?5failed?6@	; `string'
PUBLIC	??_C@_0CA@PJNEJIM@Error?5connecting?5to?5remote?5host@ ; `string'
PUBLIC	??_C@_0P@FGBLCELI@select?5failed?6@		; `string'
PUBLIC	??_C@_0BE@NABACEGA@getaddrinfo?5failed?6@	; `string'
PUBLIC	??_C@_0BH@OIBPAKHE@address?5size?5mismatch?6@	; `string'
PUBLIC	??_C@_03HAPOJHBM@GET@				; `string'
PUBLIC	??_C@_0BF@ECOHPMPM@Not?5a?5valid?5HTTP?5URI@	; `string'
PUBLIC	??_C@_0BP@DMGJEOPF@Failed?5to?5identify?5host?5in?5URI@ ; `string'
PUBLIC	??_C@_0BJ@BDBNHHKN@allocating?5header?5buffer@	; `string'
PUBLIC	??_C@_0BC@EGOHMPNF@?$CFs?5http?3?1?1?$CFs?3?$CFd?$CFs@ ; `string'
PUBLIC	??_C@_0P@EIIHMMMN@?$CFs?5http?3?1?1?$CFs?$CFs@	; `string'
PUBLIC	??_C@_05DNIIFBMG@?$CFs?5?$CFs@			; `string'
PUBLIC	??_C@_03EMGHGGCK@?$DP?$CFs@			; `string'
PUBLIC	??_C@_0BG@EGNPFNEM@?5HTTP?11?40?$AN?6Host?3?5?$CFs?$AN?6@ ; `string'
PUBLIC	??_C@_0BJ@HMGEAMPD@?5HTTP?11?40?$AN?6Host?3?5?$CFs?3?$CFd?$AN?6@ ; `string'
PUBLIC	??_C@_0BI@DHMFONHP@Accept?9Encoding?3?5gzip?$AN?6@ ; `string'
PUBLIC	??_C@_0BD@KBHMLOB@Content?9Type?3?5?$CFs?$AN?6@	; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0BH@HJCMLCON@Content?9Length?3?5?$CFd?$AN?6?$AN?6@ ; `string'
PUBLIC	??_C@_02PCIJFNDE@?$AN?6@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlCharStrndup:PROC
EXTRN	_xmlStrstr:PROC
EXTRN	_xmlStrncasecmp:PROC
EXTRN	_xmlStrcat:PROC
EXTRN	__imp__close:PROC
EXTRN	__imp__open:PROC
EXTRN	__imp__write:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp____stdio_common_vsprintf_s:PROC
EXTRN	___xmlIOErr:PROC
EXTRN	__imp___errno:PROC
EXTRN	_strchr:PROC
EXTRN	__imp__strcpy_s:PROC
EXTRN	__imp__strcat_s:PROC
EXTRN	__imp__strncpy_s:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__strtol:PROC
EXTRN	__imp__strtoul:PROC
EXTRN	__imp__getenv:PROC
EXTRN	__imp__GetSystemDirectoryA@8:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	_inflate@8:PROC
EXTRN	_inflateEnd@4:PROC
EXTRN	_inflateInit2_@16:PROC
EXTRN	___WSAFDIsSet@8:PROC
EXTRN	__imp__closesocket@4:PROC
EXTRN	__imp__connect@12:PROC
EXTRN	__imp__ioctlsocket@12:PROC
EXTRN	__imp__getsockopt@20:PROC
EXTRN	__imp__htonl@4:PROC
EXTRN	__imp__htons@4:PROC
EXTRN	__imp__inet_addr@4:PROC
EXTRN	__imp__inet_ntoa@4:PROC
EXTRN	__imp__ntohs@4:PROC
EXTRN	__imp__recv@16:PROC
EXTRN	__imp__select@20:PROC
EXTRN	__imp__send@16:PROC
EXTRN	__imp__socket@12:PROC
EXTRN	__imp__gethostbyaddr@12:PROC
EXTRN	__imp__gethostbyname@4:PROC
EXTRN	__imp__getservbyport@8:PROC
EXTRN	__imp__getservbyname@8:PROC
EXTRN	__imp__WSAStartup@8:PROC
EXTRN	__imp__WSACleanup@0:PROC
EXTRN	__imp__WSASetLastError@4:PROC
EXTRN	__imp__WSAGetLastError@0:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	_xmlParseURIRaw:PROC
EXTRN	_xmlFreeURI:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT ?bInitialized@?1??WspiapiLoad@@9@9
_BSS	SEGMENT
?bInitialized@?1??WspiapiLoad@@9@9 DD 01H DUP (?)	; `WspiapiLoad'::`2'::bInitialized
_BSS	ENDS
;	COMDAT ?pfGetAddrInfo@?1??WspiapiGetAddrInfo@@9@9
_BSS	SEGMENT
?pfGetAddrInfo@?1??WspiapiGetAddrInfo@@9@9 DD 01H DUP (?) ; `WspiapiGetAddrInfo'::`2'::pfGetAddrInfo
_BSS	ENDS
;	COMDAT ?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9
_BSS	SEGMENT
?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9 DD 01H DUP (?) ; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
_BSS	ENDS
_BSS	SEGMENT
_initialized DD	01H DUP (?)
_proxy	DD	01H DUP (?)
_proxyPort DD	01H DUP (?)
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HJCMLCON@Content?9Length?3?5?$CFd?$AN?6?$AN?6@
CONST	SEGMENT
??_C@_0BH@HJCMLCON@Content?9Length?3?5?$CFd?$AN?6?$AN?6@ DB 'Content-Leng'
	DB	'th: %d', 0dH, 0aH, 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KBHMLOB@Content?9Type?3?5?$CFs?$AN?6@
CONST	SEGMENT
??_C@_0BD@KBHMLOB@Content?9Type?3?5?$CFs?$AN?6@ DB 'Content-Type: %s', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DHMFONHP@Accept?9Encoding?3?5gzip?$AN?6@
CONST	SEGMENT
??_C@_0BI@DHMFONHP@Accept?9Encoding?3?5gzip?$AN?6@ DB 'Accept-Encoding: g'
	DB	'zip', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HMGEAMPD@?5HTTP?11?40?$AN?6Host?3?5?$CFs?3?$CFd?$AN?6@
CONST	SEGMENT
??_C@_0BJ@HMGEAMPD@?5HTTP?11?40?$AN?6Host?3?5?$CFs?3?$CFd?$AN?6@ DB ' HTT'
	DB	'P/1.0', 0dH, 0aH, 'Host: %s:%d', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EGNPFNEM@?5HTTP?11?40?$AN?6Host?3?5?$CFs?$AN?6@
CONST	SEGMENT
??_C@_0BG@EGNPFNEM@?5HTTP?11?40?$AN?6Host?3?5?$CFs?$AN?6@ DB ' HTTP/1.0', 0dH
	DB	0aH, 'Host: %s', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EMGHGGCK@?$DP?$CFs@
CONST	SEGMENT
??_C@_03EMGHGGCK@?$DP?$CFs@ DB '?%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DNIIFBMG@?$CFs?5?$CFs@
CONST	SEGMENT
??_C@_05DNIIFBMG@?$CFs?5?$CFs@ DB '%s %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EIIHMMMN@?$CFs?5http?3?1?1?$CFs?$CFs@
CONST	SEGMENT
??_C@_0P@EIIHMMMN@?$CFs?5http?3?1?1?$CFs?$CFs@ DB '%s http://%s%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EGOHMPNF@?$CFs?5http?3?1?1?$CFs?3?$CFd?$CFs@
CONST	SEGMENT
??_C@_0BC@EGOHMPNF@?$CFs?5http?3?1?1?$CFs?3?$CFd?$CFs@ DB '%s http://%s:%'
	DB	'd%s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BDBNHHKN@allocating?5header?5buffer@
CONST	SEGMENT
??_C@_0BJ@BDBNHHKN@allocating?5header?5buffer@ DB 'allocating header buff'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DMGJEOPF@Failed?5to?5identify?5host?5in?5URI@
CONST	SEGMENT
??_C@_0BP@DMGJEOPF@Failed?5to?5identify?5host?5in?5URI@ DB 'Failed to ide'
	DB	'ntify host in URI', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ECOHPMPM@Not?5a?5valid?5HTTP?5URI@
CONST	SEGMENT
??_C@_0BF@ECOHPMPM@Not?5a?5valid?5HTTP?5URI@ DB 'Not a valid HTTP URI', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HAPOJHBM@GET@
CONST	SEGMENT
??_C@_03HAPOJHBM@GET@ DB 'GET', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OIBPAKHE@address?5size?5mismatch?6@
CONST	SEGMENT
??_C@_0BH@OIBPAKHE@address?5size?5mismatch?6@ DB 'address size mismatch', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NABACEGA@getaddrinfo?5failed?6@
CONST	SEGMENT
??_C@_0BE@NABACEGA@getaddrinfo?5failed?6@ DB 'getaddrinfo failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FGBLCELI@select?5failed?6@
CONST	SEGMENT
??_C@_0P@FGBLCELI@select?5failed?6@ DB 'select failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PJNEJIM@Error?5connecting?5to?5remote?5host@
CONST	SEGMENT
??_C@_0CA@PJNEJIM@Error?5connecting?5to?5remote?5host@ DB 'Error connecti'
	DB	'ng to remote host', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MBFEIJEJ@getsockopt?5failed?6@
CONST	SEGMENT
??_C@_0BD@MBFEIJEJ@getsockopt?5failed?6@ DB 'getsockopt failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NCGOJFHC@Connect?5failed@
CONST	SEGMENT
??_C@_0P@NCGOJFHC@Connect?5failed@ DB 'Connect failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JJCGCHLC@Connect?5attempt?5timed?5out@
CONST	SEGMENT
??_C@_0BK@JJCGCHLC@Connect?5attempt?5timed?5out@ DB 'Connect attempt time'
	DB	'd out', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IEPMFIHD@error?5connecting?5to?5HTTP?5server@
CONST	SEGMENT
??_C@_0CA@IEPMFIHD@error?5connecting?5to?5HTTP?5server@ DB 'error connect'
	DB	'ing to HTTP server', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KCNIDCEL@socket?5failed?6@
CONST	SEGMENT
??_C@_0P@KCNIDCEL@socket?5failed?6@ DB 'socket failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DIGAFIOK@Content?9Length?3@
CONST	SEGMENT
??_C@_0BA@DIGAFIOK@Content?9Length?3@ DB 'Content-Length:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CJNJFBNP@1?42?411@
CONST	SEGMENT
??_C@_06CJNJFBNP@1?42?411@ DB '1.2.11', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HOHEGKBO@gzip@
CONST	SEGMENT
??_C@_04HOHEGKBO@gzip@ DB 'gzip', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FGDKEGD@Content?9Encoding?3@
CONST	SEGMENT
??_C@_0BC@FGDKEGD@Content?9Encoding?3@ DB 'Content-Encoding:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EKBPAAMO@Proxy?9Authenticate?3@
CONST	SEGMENT
??_C@_0BE@EKBPAAMO@Proxy?9Authenticate?3@ DB 'Proxy-Authenticate:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EALNDOCH@WWW?9Authenticate?3@
CONST	SEGMENT
??_C@_0BC@EALNDOCH@WWW?9Authenticate?3@ DB 'WWW-Authenticate:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FGAOOBMN@http?3?1?1@
CONST	SEGMENT
??_C@_07FGAOOBMN@http?3?1?1@ DB 'http://', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GILIFLDG@Location?3@
CONST	SEGMENT
??_C@_09GILIFLDG@Location?3@ DB 'Location:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PPOPBCJG@ContentType?3@
CONST	SEGMENT
??_C@_0N@PPOPBCJG@ContentType?3@ DB 'ContentType:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JPKHBDLJ@charset?$DN@
CONST	SEGMENT
??_C@_08JPKHBDLJ@charset?$DN@ DB 'charset=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PDMPCIFL@Content?9Type?3@
CONST	SEGMENT
??_C@_0O@PDMPCIFL@Content?9Type?3@ DB 'Content-Type:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKGKDBHO@HTTP?1@
CONST	SEGMENT
??_C@_05FKGKDBHO@HTTP?1@ DB 'HTTP/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NLPHEKBL@recv?5failed?6@
CONST	SEGMENT
??_C@_0N@NLPHEKBL@recv?5failed?6@ DB 'recv failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IFIOEEDJ@allocating?5input?5buffer@
CONST	SEGMENT
??_C@_0BI@IFIOEEDJ@allocating?5input?5buffer@ DB 'allocating input buffer'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BIOIGIMH@allocating?5input@
CONST	SEGMENT
??_C@_0BB@BIOIGIMH@allocating?5input@ DB 'allocating input', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OOKOIPEM@send?5failed?6@
CONST	SEGMENT
??_C@_0N@OOKOIPEM@send?5failed?6@ DB 'send failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NMNFIMM@allocating?5context@
CONST	SEGMENT
??_C@_0BD@NMNFIMM@allocating?5context@ DB 'allocating context', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FGOLBKPK@Syntax?5Error?6@
CONST	SEGMENT
??_C@_0O@FGOLBKPK@Syntax?5Error?6@ DB 'Syntax Error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IAFLKNP@http@
CONST	SEGMENT
??_C@_04IAFLKNP@http@ DB 'http', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GDPFKPEL@HTTP_PROXY@
CONST	SEGMENT
??_C@_0L@GDPFKPEL@HTTP_PROXY@ DB 'HTTP_PROXY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BKCFCEPH@http_proxy@
CONST	SEGMENT
??_C@_0L@BKCFCEPH@http_proxy@ DB 'http_proxy', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BOGLDIEC@no_proxy@
CONST	SEGMENT
??_C@_08BOGLDIEC@no_proxy@ DB 'no_proxy', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_timeout DD	03cH
_DATA	ENDS
;	COMDAT ??_C@_07OKMCKPF@?2wship6@
CONST	SEGMENT
??_C@_07OKMCKPF@?2wship6@ DB '\wship6', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LPPPKMHP@?2ws2_32@
CONST	SEGMENT
??_C@_07LPPPKMHP@?2ws2_32@ DB '\ws2_32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EHOPPMLH@freeaddrinfo@
CONST	SEGMENT
??_C@_0N@EHOPPMLH@freeaddrinfo@ DB 'freeaddrinfo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NNJNLPKG@getnameinfo@
CONST	SEGMENT
??_C@_0M@NNJNLPKG@getnameinfo@ DB 'getnameinfo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MBIPAJOD@getaddrinfo@
CONST	SEGMENT
??_C@_0M@MBIPAJOD@getaddrinfo@ DB 'getaddrinfo', 00H	; `string'
CONST	ENDS
;	COMDAT ?iNumGlobal@?1??WspiapiLoad@@9@9
CONST	SEGMENT
?iNumGlobal@?1??WspiapiLoad@@9@9 DD 03H			; `WspiapiLoad'::`2'::iNumGlobal
CONST	ENDS
;	COMDAT ?rgtGlobal@?1??WspiapiLoad@@9@9
_DATA	SEGMENT
?rgtGlobal@?1??WspiapiLoad@@9@9 DD FLAT:??_C@_0M@MBIPAJOD@getaddrinfo@ ; `WspiapiLoad'::`2'::rgtGlobal
	DD	FLAT:_WspiapiLegacyGetAddrInfo@16
	DD	FLAT:??_C@_0M@NNJNLPKG@getnameinfo@
	DD	FLAT:_WspiapiLegacyGetNameInfo@28
	DD	FLAT:??_C@_0N@EHOPPMLH@freeaddrinfo@
	DD	FLAT:_WspiapiLegacyFreeAddrInfo@4
_DATA	ENDS
;	COMDAT ??_C@_02GMHACPFF@?$CFu@
CONST	SEGMENT
??_C@_02GMHACPFF@?$CFu@ DB '%u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LGDGBMPG@65535@
CONST	SEGMENT
??_C@_05LGDGBMPG@65535@ DB '65535', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FPEIBLKH@tcp@
CONST	SEGMENT
??_C@_03FPEIBLKH@tcp@ DB 'tcp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OCLLGKEH@udp@
CONST	SEGMENT
??_C@_03OCLLGKEH@udp@ DB 'udp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPConnectHost
_TEXT	SEGMENT
_ai$ = -100						; size = 4
_ai$ = -96						; size = 4
_ai$ = -92						; size = 4
_iError$1 = -88						; size = 4
_result$2 = -84						; size = 4
_res$3 = -80						; size = 4
_hints$4 = -72						; size = 32
_status$5 = -36						; size = 4
_s$ = -32						; size = 4
_sockin$ = -24						; size = 16
_addr$ = -4						; size = 4
_host$ = 8						; size = 4
_port$ = 12						; size = 4
_xmlNanoHTTPConnectHost PROC				; COMDAT

; 1047 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-100]
	mov	ecx, 25					; 00000019H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1048 :     struct sockaddr *addr = NULL;

	mov	DWORD PTR _addr$[ebp], 0

; 1049 :     struct sockaddr_in sockin;
; 1050 : 
; 1051 : #ifdef SUPPORT_IP6
; 1052 :     struct in6_addr ia6;
; 1053 :     struct sockaddr_in6 sockin6;
; 1054 : #endif
; 1055 :     SOCKET s;
; 1056 : 
; 1057 :     memset (&sockin, 0, sizeof(sockin));

	xor	eax, eax
	mov	DWORD PTR _sockin$[ebp], eax
	mov	DWORD PTR _sockin$[ebp+4], eax
	mov	DWORD PTR _sockin$[ebp+8], eax
	mov	DWORD PTR _sockin$[ebp+12], eax

; 1058 : #ifdef SUPPORT_IP6
; 1059 :     memset (&sockin6, 0, sizeof(sockin6));
; 1060 : #endif
; 1061 : 
; 1062 : #if !defined(HAVE_GETADDRINFO) && defined(SUPPORT_IP6) && defined(RES_USE_INET6)
; 1063 :     if (have_ipv6 ())
; 1064 :     {
; 1065 : 	if (!(_res.options & RES_INIT))
; 1066 : 	    res_init();
; 1067 : 	_res.options |= RES_USE_INET6;
; 1068 :     }
; 1069 : #endif
; 1070 : 
; 1071 : #if defined(HAVE_GETADDRINFO) && defined(SUPPORT_IP6) && !defined(_WIN32)
; 1072 :     if (have_ipv6 ())
; 1073 : #endif
; 1074 : #if defined(HAVE_GETADDRINFO) && (defined(SUPPORT_IP6) || defined(_WIN32))
; 1075 :     {
; 1076 : 	int status;
; 1077 : 	struct addrinfo hints, *res, *result;
; 1078 : 
; 1079 : 	result = NULL;

	mov	DWORD PTR _result$2[ebp], 0

; 1080 : 	memset (&hints, 0,sizeof(hints));

	xor	ecx, ecx
	mov	DWORD PTR _hints$4[ebp], ecx
	mov	DWORD PTR _hints$4[ebp+4], ecx
	mov	DWORD PTR _hints$4[ebp+8], ecx
	mov	DWORD PTR _hints$4[ebp+12], ecx
	mov	DWORD PTR _hints$4[ebp+16], ecx
	mov	DWORD PTR _hints$4[ebp+20], ecx
	mov	DWORD PTR _hints$4[ebp+24], ecx
	mov	DWORD PTR _hints$4[ebp+28], ecx

; 1081 : 	hints.ai_socktype = SOCK_STREAM;

	mov	DWORD PTR _hints$4[ebp+8], 1
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h

; 1018 :     if (!pfGetAddrInfo)

	cmp	DWORD PTR ?pfGetAddrInfo@?1??WspiapiGetAddrInfo@@9@9, 0 ; `WspiapiGetAddrInfo'::`2'::pfGetAddrInfo
	jne	SHORT $LN13@xmlNanoHTT

; 1019 :         pfGetAddrInfo   = (WSPIAPI_PGETADDRINFO) WspiapiLoad(0);

	push	0
	call	_WspiapiLoad@4
	mov	DWORD PTR ?pfGetAddrInfo@?1??WspiapiGetAddrInfo@@9@9, eax ; `WspiapiGetAddrInfo'::`2'::pfGetAddrInfo
$LN13@xmlNanoHTT:

; 1020 : 
; 1021 :     iError = (*pfGetAddrInfo)(nodename, servname, hints, res);

	mov	esi, esp
	lea	edx, DWORD PTR _result$2[ebp]
	push	edx
	lea	eax, DWORD PTR _hints$4[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _host$[ebp]
	push	ecx
	call	DWORD PTR ?pfGetAddrInfo@?1??WspiapiGetAddrInfo@@9@9 ; `WspiapiGetAddrInfo'::`2'::pfGetAddrInfo
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _iError$1[ebp], eax

; 1022 :     WSASetLastError(iError);

	mov	esi, esp
	mov	edx, DWORD PTR _iError$1[ebp]
	push	edx
	call	DWORD PTR __imp__WSASetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c

; 1083 : 	status = getaddrinfo (host, NULL, &hints, &result);

	mov	eax, DWORD PTR _iError$1[ebp]
	mov	DWORD PTR _status$5[ebp], eax

; 1084 : 	if (status) {

	cmp	DWORD PTR _status$5[ebp], 0
	je	SHORT $LN5@xmlNanoHTT

; 1085 : 	    __xmlIOErr(XML_FROM_HTTP, 0, "getaddrinfo failed\n");

	push	OFFSET ??_C@_0BE@NABACEGA@getaddrinfo?5failed?6@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1086 : 	    return INVALID_SOCKET;

	or	eax, -1
	jmp	$LN1@xmlNanoHTT
$LN5@xmlNanoHTT:

; 1087 : 	}
; 1088 : 
; 1089 : 	for (res = result; res; res = res->ai_next) {

	mov	ecx, DWORD PTR _result$2[ebp]
	mov	DWORD PTR _res$3[ebp], ecx
	jmp	SHORT $LN4@xmlNanoHTT
$LN2@xmlNanoHTT:
	mov	edx, DWORD PTR _res$3[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _res$3[ebp], eax
$LN4@xmlNanoHTT:
	cmp	DWORD PTR _res$3[ebp], 0
	je	$LN3@xmlNanoHTT

; 1090 : 	    if (res->ai_family == AF_INET) {

	mov	ecx, DWORD PTR _res$3[ebp]
	cmp	DWORD PTR [ecx+4], 2
	jne	$LN6@xmlNanoHTT

; 1091 : 		if ((size_t)res->ai_addrlen > sizeof(sockin)) {

	mov	edx, DWORD PTR _res$3[ebp]
	cmp	DWORD PTR [edx+16], 16			; 00000010H
	jbe	SHORT $LN8@xmlNanoHTT

; 1092 : 		    __xmlIOErr(XML_FROM_HTTP, 0, "address size mismatch\n");

	push	OFFSET ??_C@_0BH@OIBPAKHE@address?5size?5mismatch?6@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1093 : 		    freeaddrinfo (result);

	mov	eax, DWORD PTR _result$2[ebp]
	mov	DWORD PTR _ai$[ebp], eax
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h

; 1061 :     if (!pfFreeAddrInfo)

	cmp	DWORD PTR ?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9, 0 ; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
	jne	SHORT $LN16@xmlNanoHTT

; 1062 :         pfFreeAddrInfo  = (WSPIAPI_PFREEADDRINFO) WspiapiLoad(2);

	push	2
	call	_WspiapiLoad@4
	mov	DWORD PTR ?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9, eax ; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
$LN16@xmlNanoHTT:

; 1063 :     (*pfFreeAddrInfo)(ai);

	mov	esi, esp
	mov	ecx, DWORD PTR _ai$[ebp]
	push	ecx
	call	DWORD PTR ?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9 ; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
	cmp	esi, esp
	call	__RTC_CheckEsp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c

; 1094 : 		    return INVALID_SOCKET;

	or	eax, -1
	jmp	$LN1@xmlNanoHTT
$LN8@xmlNanoHTT:

; 1095 : 		}
; 1096 : 		memcpy (&sockin, res->ai_addr, res->ai_addrlen);

	mov	edx, DWORD PTR _res$3[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _res$3[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	lea	eax, DWORD PTR _sockin$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1097 : 		sockin.sin_port = htons (port);

	mov	esi, esp
	movzx	ecx, WORD PTR _port$[ebp]
	push	ecx
	call	DWORD PTR __imp__htons@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	WORD PTR _sockin$[ebp+2], ax

; 1098 : 		addr = (struct sockaddr *)&sockin;

	lea	edx, DWORD PTR _sockin$[ebp]
	mov	DWORD PTR _addr$[ebp], edx

; 1099 : #ifdef SUPPORT_IP6
; 1100 : 	    } else if (have_ipv6 () && (res->ai_family == AF_INET6)) {
; 1101 : 		if ((size_t)res->ai_addrlen > sizeof(sockin6)) {
; 1102 : 		    __xmlIOErr(XML_FROM_HTTP, 0, "address size mismatch\n");
; 1103 : 		    freeaddrinfo (result);
; 1104 : 		    return INVALID_SOCKET;
; 1105 : 		}
; 1106 : 		memcpy (&sockin6, res->ai_addr, res->ai_addrlen);
; 1107 : 		sockin6.sin6_port = htons (port);
; 1108 : 		addr = (struct sockaddr *)&sockin6;
; 1109 : #endif
; 1110 : 	    } else

	jmp	SHORT $LN7@xmlNanoHTT
$LN6@xmlNanoHTT:

; 1111 : 		continue;              /* for */

	jmp	$LN2@xmlNanoHTT
$LN7@xmlNanoHTT:

; 1112 : 
; 1113 : 	    s = xmlNanoHTTPConnectAttempt (addr);

	mov	eax, DWORD PTR _addr$[ebp]
	push	eax
	call	_xmlNanoHTTPConnectAttempt
	add	esp, 4
	mov	DWORD PTR _s$[ebp], eax

; 1114 : 	    if (s != INVALID_SOCKET) {

	cmp	DWORD PTR _s$[ebp], -1
	je	SHORT $LN9@xmlNanoHTT

; 1115 : 		freeaddrinfo (result);

	mov	ecx, DWORD PTR _result$2[ebp]
	mov	DWORD PTR _ai$[ebp], ecx
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h

; 1061 :     if (!pfFreeAddrInfo)

	cmp	DWORD PTR ?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9, 0 ; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
	jne	SHORT $LN43@xmlNanoHTT

; 1062 :         pfFreeAddrInfo  = (WSPIAPI_PFREEADDRINFO) WspiapiLoad(2);

	push	2
	call	_WspiapiLoad@4
	mov	DWORD PTR ?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9, eax ; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
$LN43@xmlNanoHTT:

; 1063 :     (*pfFreeAddrInfo)(ai);

	mov	esi, esp
	mov	edx, DWORD PTR _ai$[ebp]
	push	edx
	call	DWORD PTR ?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9 ; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
	cmp	esi, esp
	call	__RTC_CheckEsp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c

; 1116 : 		return (s);

	mov	eax, DWORD PTR _s$[ebp]
	jmp	SHORT $LN1@xmlNanoHTT
$LN9@xmlNanoHTT:

; 1117 : 	    }
; 1118 : 	}

	jmp	$LN2@xmlNanoHTT
$LN3@xmlNanoHTT:

; 1119 : 
; 1120 : 	if (result)

	cmp	DWORD PTR _result$2[ebp], 0
	je	SHORT $LN10@xmlNanoHTT

; 1121 : 	    freeaddrinfo (result);

	mov	eax, DWORD PTR _result$2[ebp]
	mov	DWORD PTR _ai$[ebp], eax
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h

; 1061 :     if (!pfFreeAddrInfo)

	cmp	DWORD PTR ?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9, 0 ; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
	jne	SHORT $LN70@xmlNanoHTT

; 1062 :         pfFreeAddrInfo  = (WSPIAPI_PFREEADDRINFO) WspiapiLoad(2);

	push	2
	call	_WspiapiLoad@4
	mov	DWORD PTR ?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9, eax ; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
$LN70@xmlNanoHTT:

; 1063 :     (*pfFreeAddrInfo)(ai);

	mov	esi, esp
	mov	ecx, DWORD PTR _ai$[ebp]
	push	ecx
	call	DWORD PTR ?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9 ; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@xmlNanoHTT:
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c

; 1217 :     return INVALID_SOCKET;

	or	eax, -1
$LN1@xmlNanoHTT:

; 1218 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN99@xmlNanoHTT
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 100				; 00000064H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN99@xmlNanoHTT:
	DD	2
	DD	$LN98@xmlNanoHTT
$LN98@xmlNanoHTT:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN96@xmlNanoHTT
	DD	-72					; ffffffb8H
	DD	32					; 00000020H
	DD	$LN97@xmlNanoHTT
$LN97@xmlNanoHTT:
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$LN96@xmlNanoHTT:
	DB	115					; 00000073H
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	0
_xmlNanoHTTPConnectHost ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPConnectAttempt
_TEXT	SEGMENT
tv152 = -616						; size = 4
tv84 = -612						; size = 4
tv77 = -608						; size = 4
_len$1 = -600						; size = 4
___i$2 = -592						; size = 4
___i$3 = -588						; size = 4
_one$4 = -580						; size = 4
_s$ = -572						; size = 4
_addrlen$ = -568					; size = 4
_status$ = -560						; size = 4
_tv$ = -548						; size = 8
_xfd$ = -532						; size = 260
_wfd$ = -264						; size = 260
_addr$ = 8						; size = 4
_xmlNanoHTTPConnectAttempt PROC				; COMDAT

; 859  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 616				; 00000268H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-616]
	mov	ecx, 154				; 0000009aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 860  : #ifndef HAVE_POLL_H
; 861  :     fd_set wfd;
; 862  : #ifdef _WINSOCKAPI_
; 863  :     fd_set xfd;
; 864  : #endif
; 865  :     struct timeval tv;
; 866  : #else /* !HAVE_POLL_H */
; 867  :     struct pollfd p;
; 868  : #endif /* !HAVE_POLL_H */
; 869  :     int status;
; 870  : 
; 871  :     int addrlen;
; 872  : 
; 873  :     SOCKET s;
; 874  : 
; 875  : #ifdef SUPPORT_IP6
; 876  :     if (addr->sa_family == AF_INET6) {
; 877  :         s = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);
; 878  :         addrlen = sizeof(struct sockaddr_in6);
; 879  :     } else
; 880  : #endif
; 881  :     {
; 882  :         s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);

	mov	esi, esp
	push	6
	push	1
	push	2
	call	DWORD PTR __imp__socket@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _s$[ebp], eax

; 883  :         addrlen = sizeof(struct sockaddr_in);

	mov	DWORD PTR _addrlen$[ebp], 16		; 00000010H

; 884  :     }
; 885  :     if (s == INVALID_SOCKET) {

	cmp	DWORD PTR _s$[ebp], -1
	jne	SHORT $LN18@xmlNanoHTT

; 886  : #ifdef DEBUG_HTTP
; 887  :         perror("socket");
; 888  : #endif
; 889  :         __xmlIOErr(XML_FROM_HTTP, 0, "socket failed\n");

	push	OFFSET ??_C@_0P@KCNIDCEL@socket?5failed?6@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 890  :         return INVALID_SOCKET;

	or	eax, -1
	jmp	$LN1@xmlNanoHTT
$LN18@xmlNanoHTT:

; 891  :     }
; 892  : #ifdef _WINSOCKAPI_
; 893  :     {
; 894  :         u_long one = 1;

	mov	DWORD PTR _one$4[ebp], 1

; 895  : 
; 896  :         status = ioctlsocket(s, FIONBIO, &one) == SOCKET_ERROR ? -1 : 0;

	mov	esi, esp
	lea	eax, DWORD PTR _one$4[ebp]
	push	eax
	push	-2147195266				; 8004667eH
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__ioctlsocket@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, -1
	jne	SHORT $LN36@xmlNanoHTT
	mov	DWORD PTR tv77[ebp], -1
	jmp	SHORT $LN37@xmlNanoHTT
$LN36@xmlNanoHTT:
	mov	DWORD PTR tv77[ebp], 0
$LN37@xmlNanoHTT:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _status$[ebp], edx

; 897  :     }
; 898  : #else /* _WINSOCKAPI_ */
; 899  : #if defined(VMS)
; 900  :     {
; 901  :         int enable = 1;
; 902  : 
; 903  :         status = ioctl(s, FIONBIO, &enable);
; 904  :     }
; 905  : #else /* VMS */
; 906  : #if defined(__BEOS__) && !defined(__HAIKU__)
; 907  :     {
; 908  :         bool noblock = true;
; 909  : 
; 910  :         status =
; 911  :             setsockopt(s, SOL_SOCKET, SO_NONBLOCK, &noblock,
; 912  :                        sizeof(noblock));
; 913  :     }
; 914  : #else /* __BEOS__ */
; 915  :     if ((status = fcntl(s, F_GETFL, 0)) != -1) {
; 916  : #ifdef O_NONBLOCK
; 917  :         status |= O_NONBLOCK;
; 918  : #else /* O_NONBLOCK */
; 919  : #ifdef F_NDELAY
; 920  :         status |= F_NDELAY;
; 921  : #endif /* F_NDELAY */
; 922  : #endif /* !O_NONBLOCK */
; 923  :         status = fcntl(s, F_SETFL, status);
; 924  :     }
; 925  :     if (status < 0) {
; 926  : #ifdef DEBUG_HTTP
; 927  :         perror("nonblocking");
; 928  : #endif
; 929  :         __xmlIOErr(XML_FROM_HTTP, 0, "error setting non-blocking IO\n");
; 930  :         closesocket(s);
; 931  :         return INVALID_SOCKET;
; 932  :     }
; 933  : #endif /* !__BEOS__ */
; 934  : #endif /* !VMS */
; 935  : #endif /* !_WINSOCKAPI_ */
; 936  : 
; 937  :     if (connect(s, addr, addrlen) == -1) {

	mov	esi, esp
	mov	eax, DWORD PTR _addrlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _addr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	DWORD PTR __imp__connect@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, -1
	jne	SHORT $LN19@xmlNanoHTT

; 938  :         switch (socket_errno()) {

	call	_socket_errno
	mov	DWORD PTR tv84[ebp], eax
	cmp	DWORD PTR tv84[ebp], 112		; 00000070H
	je	SHORT $LN20@xmlNanoHTT
	cmp	DWORD PTR tv84[ebp], 140		; 0000008cH
	je	SHORT $LN20@xmlNanoHTT
	jmp	SHORT $LN21@xmlNanoHTT
$LN20@xmlNanoHTT:

; 939  :             case EINPROGRESS:
; 940  :             case EWOULDBLOCK:
; 941  :                 break;

	jmp	SHORT $LN19@xmlNanoHTT
$LN21@xmlNanoHTT:

; 942  :             default:
; 943  :                 __xmlIOErr(XML_FROM_HTTP, 0,

	push	OFFSET ??_C@_0CA@IEPMFIHD@error?5connecting?5to?5HTTP?5server@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 944  :                            "error connecting to HTTP server");
; 945  :                 closesocket(s);

	mov	esi, esp
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	DWORD PTR __imp__closesocket@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 946  :                 return INVALID_SOCKET;

	or	eax, -1
	jmp	$LN1@xmlNanoHTT
$LN19@xmlNanoHTT:

; 947  :         }
; 948  :     }
; 949  : #ifndef HAVE_POLL_H
; 950  :     tv.tv_sec = timeout;

	mov	ecx, DWORD PTR _timeout
	mov	DWORD PTR _tv$[ebp], ecx

; 951  :     tv.tv_usec = 0;

	mov	DWORD PTR _tv$[ebp+4], 0

; 952  : 
; 953  : #ifdef _MSC_VER
; 954  : #pragma warning(push)
; 955  : #pragma warning(disable: 4018)
; 956  : #endif
; 957  : #ifndef _WINSOCKAPI_
; 958  :     if (s > FD_SETSIZE)
; 959  :         return INVALID_SOCKET;
; 960  : #endif
; 961  :     FD_ZERO(&wfd);

	mov	DWORD PTR _wfd$[ebp], 0
$LN6@xmlNanoHTT:

; 962  :     FD_SET(s, &wfd);

	mov	DWORD PTR ___i$3[ebp], 0
	jmp	SHORT $LN9@xmlNanoHTT
$LN7@xmlNanoHTT:
	mov	edx, DWORD PTR ___i$3[ebp]
	add	edx, 1
	mov	DWORD PTR ___i$3[ebp], edx
$LN9@xmlNanoHTT:
	mov	eax, DWORD PTR ___i$3[ebp]
	cmp	eax, DWORD PTR _wfd$[ebp]
	jae	SHORT $LN8@xmlNanoHTT
	mov	ecx, DWORD PTR ___i$3[ebp]
	mov	edx, DWORD PTR _wfd$[ebp+ecx*4+4]
	cmp	edx, DWORD PTR _s$[ebp]
	jne	SHORT $LN22@xmlNanoHTT
	jmp	SHORT $LN8@xmlNanoHTT
$LN22@xmlNanoHTT:
	jmp	SHORT $LN7@xmlNanoHTT
$LN8@xmlNanoHTT:
	mov	eax, DWORD PTR ___i$3[ebp]
	cmp	eax, DWORD PTR _wfd$[ebp]
	jne	SHORT $LN4@xmlNanoHTT
	cmp	DWORD PTR _wfd$[ebp], 64		; 00000040H
	jae	SHORT $LN4@xmlNanoHTT
	mov	ecx, DWORD PTR ___i$3[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR _wfd$[ebp+ecx*4+4], edx
	mov	eax, DWORD PTR _wfd$[ebp]
	add	eax, 1
	mov	DWORD PTR _wfd$[ebp], eax
$LN4@xmlNanoHTT:
	xor	ecx, ecx
	jne	SHORT $LN6@xmlNanoHTT

; 963  : 
; 964  : #ifdef _WINSOCKAPI_
; 965  :     FD_ZERO(&xfd);

	mov	DWORD PTR _xfd$[ebp], 0
$LN12@xmlNanoHTT:

; 966  :     FD_SET(s, &xfd);

	mov	DWORD PTR ___i$2[ebp], 0
	jmp	SHORT $LN15@xmlNanoHTT
$LN13@xmlNanoHTT:
	mov	edx, DWORD PTR ___i$2[ebp]
	add	edx, 1
	mov	DWORD PTR ___i$2[ebp], edx
$LN15@xmlNanoHTT:
	mov	eax, DWORD PTR ___i$2[ebp]
	cmp	eax, DWORD PTR _xfd$[ebp]
	jae	SHORT $LN14@xmlNanoHTT
	mov	ecx, DWORD PTR ___i$2[ebp]
	mov	edx, DWORD PTR _xfd$[ebp+ecx*4+4]
	cmp	edx, DWORD PTR _s$[ebp]
	jne	SHORT $LN25@xmlNanoHTT
	jmp	SHORT $LN14@xmlNanoHTT
$LN25@xmlNanoHTT:
	jmp	SHORT $LN13@xmlNanoHTT
$LN14@xmlNanoHTT:
	mov	eax, DWORD PTR ___i$2[ebp]
	cmp	eax, DWORD PTR _xfd$[ebp]
	jne	SHORT $LN10@xmlNanoHTT
	cmp	DWORD PTR _xfd$[ebp], 64		; 00000040H
	jae	SHORT $LN10@xmlNanoHTT
	mov	ecx, DWORD PTR ___i$2[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR _xfd$[ebp+ecx*4+4], edx
	mov	eax, DWORD PTR _xfd$[ebp]
	add	eax, 1
	mov	DWORD PTR _xfd$[ebp], eax
$LN10@xmlNanoHTT:
	xor	ecx, ecx
	jne	SHORT $LN12@xmlNanoHTT

; 967  : 
; 968  :     switch (select(s + 1, NULL, &wfd, &xfd, &tv))

	mov	esi, esp
	lea	edx, DWORD PTR _tv$[ebp]
	push	edx
	lea	eax, DWORD PTR _xfd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wfd$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp__select@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv152[ebp], eax
	cmp	DWORD PTR tv152[ebp], -1
	je	SHORT $LN29@xmlNanoHTT
	cmp	DWORD PTR tv152[ebp], 0
	je	SHORT $LN28@xmlNanoHTT
	jmp	SHORT $LN16@xmlNanoHTT
$LN28@xmlNanoHTT:

; 969  : #else
; 970  :     switch (select(s + 1, NULL, &wfd, NULL, &tv))
; 971  : #endif
; 972  : #ifdef _MSC_VER
; 973  : #pragma warning(pop)
; 974  : #endif
; 975  : 
; 976  : #else /* !HAVE_POLL_H */
; 977  :     p.fd = s;
; 978  :     p.events = POLLOUT;
; 979  :     switch (poll(&p, 1, timeout * 1000))
; 980  : #endif /* !HAVE_POLL_H */
; 981  : 
; 982  :     {
; 983  :         case 0:
; 984  :             /* Time out */
; 985  :             __xmlIOErr(XML_FROM_HTTP, 0, "Connect attempt timed out");

	push	OFFSET ??_C@_0BK@JJCGCHLC@Connect?5attempt?5timed?5out@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 986  :             closesocket(s);

	mov	esi, esp
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	DWORD PTR __imp__closesocket@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 987  :             return INVALID_SOCKET;

	or	eax, -1
	jmp	$LN1@xmlNanoHTT
$LN29@xmlNanoHTT:

; 988  :         case -1:
; 989  :             /* Ermm.. ?? */
; 990  :             __xmlIOErr(XML_FROM_HTTP, 0, "Connect failed");

	push	OFFSET ??_C@_0P@NCGOJFHC@Connect?5failed@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 991  :             closesocket(s);

	mov	esi, esp
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__closesocket@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 992  :             return INVALID_SOCKET;

	or	eax, -1
	jmp	$LN1@xmlNanoHTT
$LN16@xmlNanoHTT:

; 993  :     }
; 994  : 
; 995  : #ifndef HAVE_POLL_H
; 996  :     if (FD_ISSET(s, &wfd)
; 997  : #ifdef _WINSOCKAPI_
; 998  :         || FD_ISSET(s, &xfd)

	lea	edx, DWORD PTR _wfd$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	___WSAFDIsSet@8
	test	eax, eax
	jne	SHORT $LN32@xmlNanoHTT
	lea	ecx, DWORD PTR _xfd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	___WSAFDIsSet@8
	test	eax, eax
	je	$LN30@xmlNanoHTT
$LN32@xmlNanoHTT:

; 999  : #endif
; 1000 :         )
; 1001 : #else /* !HAVE_POLL_H */
; 1002 :     if (p.revents == POLLOUT)
; 1003 : #endif /* !HAVE_POLL_H */
; 1004 :     {
; 1005 :         XML_SOCKLEN_T len;
; 1006 : 
; 1007 :         len = sizeof(status);

	mov	DWORD PTR _len$1[ebp], 4

; 1008 : #ifdef SO_ERROR
; 1009 :         if (getsockopt(s, SOL_SOCKET, SO_ERROR, (char *) &status, &len) <

	mov	esi, esp
	lea	eax, DWORD PTR _len$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _status$[ebp]
	push	ecx
	push	4103					; 00001007H
	push	65535					; 0000ffffH
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	DWORD PTR __imp__getsockopt@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jge	SHORT $LN33@xmlNanoHTT

; 1010 :             0) {
; 1011 :             /* Solaris error code */
; 1012 :             __xmlIOErr(XML_FROM_HTTP, 0, "getsockopt failed\n");

	push	OFFSET ??_C@_0BD@MBFEIJEJ@getsockopt?5failed?6@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1013 :             closesocket(s);

	mov	esi, esp
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	DWORD PTR __imp__closesocket@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1014 :             return INVALID_SOCKET;

	or	eax, -1
	jmp	$LN1@xmlNanoHTT
$LN33@xmlNanoHTT:

; 1015 :         }
; 1016 : #endif
; 1017 :         if (status) {

	cmp	DWORD PTR _status$[ebp], 0
	je	SHORT $LN34@xmlNanoHTT

; 1018 :             __xmlIOErr(XML_FROM_HTTP, 0,

	push	OFFSET ??_C@_0CA@PJNEJIM@Error?5connecting?5to?5remote?5host@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1019 :                        "Error connecting to remote host");
; 1020 :             closesocket(s);

	mov	esi, esp
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__closesocket@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1021 :             errno = status;

	mov	esi, esp
	call	DWORD PTR __imp___errno
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax], edx

; 1022 :             return INVALID_SOCKET;

	or	eax, -1
	jmp	SHORT $LN1@xmlNanoHTT
$LN34@xmlNanoHTT:

; 1023 :         }
; 1024 :     } else {

	jmp	SHORT $LN31@xmlNanoHTT
$LN30@xmlNanoHTT:

; 1025 :         /* pbm */
; 1026 :         __xmlIOErr(XML_FROM_HTTP, 0, "select failed\n");

	push	OFFSET ??_C@_0P@FGBLCELI@select?5failed?6@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1027 :         closesocket(s);

	mov	esi, esp
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	DWORD PTR __imp__closesocket@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1028 :         return INVALID_SOCKET;

	or	eax, -1
	jmp	SHORT $LN1@xmlNanoHTT
$LN31@xmlNanoHTT:

; 1029 :     }
; 1030 : 
; 1031 :     return (s);

	mov	eax, DWORD PTR _s$[ebp]
$LN1@xmlNanoHTT:

; 1032 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN45@xmlNanoHTT
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 616				; 00000268H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN45@xmlNanoHTT:
	DD	6
	DD	$LN44@xmlNanoHTT
$LN44@xmlNanoHTT:
	DD	-264					; fffffef8H
	DD	260					; 00000104H
	DD	$LN38@xmlNanoHTT
	DD	-532					; fffffdecH
	DD	260					; 00000104H
	DD	$LN39@xmlNanoHTT
	DD	-548					; fffffddcH
	DD	8
	DD	$LN40@xmlNanoHTT
	DD	-560					; fffffdd0H
	DD	4
	DD	$LN41@xmlNanoHTT
	DD	-580					; fffffdbcH
	DD	4
	DD	$LN42@xmlNanoHTT
	DD	-600					; fffffda8H
	DD	4
	DD	$LN43@xmlNanoHTT
$LN43@xmlNanoHTT:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN42@xmlNanoHTT:
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	0
$LN41@xmlNanoHTT:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	0
$LN40@xmlNanoHTT:
	DB	116					; 00000074H
	DB	118					; 00000076H
	DB	0
$LN39@xmlNanoHTT:
	DB	120					; 00000078H
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
$LN38@xmlNanoHTT:
	DB	119					; 00000077H
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
_xmlNanoHTTPConnectAttempt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPScanAnswer
_TEXT	SEGMENT
_tmp_loc$1 = -44					; size = 4
_tmp_http$2 = -40					; size = 4
_mime$3 = -36						; size = 4
_last$4 = -32						; size = 4
_charset$5 = -28					; size = 4
_mime$6 = -24						; size = 4
_last$7 = -20						; size = 4
_charset$8 = -16					; size = 4
_ret$9 = -12						; size = 4
_version$10 = -8					; size = 4
_cur$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_line$ = 12						; size = 4
_xmlNanoHTTPScanAnswer PROC				; COMDAT

; 706  : xmlNanoHTTPScanAnswer(xmlNanoHTTPCtxtPtr ctxt, const char *line) {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-44]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 707  :     const char *cur = line;

	mov	eax, DWORD PTR _line$[ebp]
	mov	DWORD PTR _cur$[ebp], eax

; 708  : 
; 709  :     if (line == NULL) return;

	cmp	DWORD PTR _line$[ebp], 0
	jne	SHORT $LN30@xmlNanoHTT
	jmp	$LN1@xmlNanoHTT
$LN30@xmlNanoHTT:

; 710  : 
; 711  :     if (!strncmp(line, "HTTP/", 5)) {

	mov	esi, esp
	push	5
	push	OFFSET ??_C@_05FKGKDBHO@HTTP?1@
	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	$LN31@xmlNanoHTT

; 712  :         int version = 0;

	mov	DWORD PTR _version$10[ebp], 0

; 713  : 	int ret = 0;

	mov	DWORD PTR _ret$9[ebp], 0

; 714  : 
; 715  : 	cur += 5;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 5
	mov	DWORD PTR _cur$[ebp], edx
$LN2@xmlNanoHTT:

; 716  : 	while ((*cur >= '0') && (*cur <= '9')) {

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN3@xmlNanoHTT
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN3@xmlNanoHTT

; 717  : 	    version *= 10;

	imul	ecx, DWORD PTR _version$10[ebp], 10
	mov	DWORD PTR _version$10[ebp], ecx

; 718  : 	    version += *cur - '0';

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _version$10[ebp]
	lea	edx, DWORD PTR [ecx+eax-48]
	mov	DWORD PTR _version$10[ebp], edx

; 719  : 	    cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 720  : 	}

	jmp	SHORT $LN2@xmlNanoHTT
$LN3@xmlNanoHTT:

; 721  : 	if (*cur == '.') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	jne	SHORT $LN33@xmlNanoHTT

; 722  : 	    cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 723  : 	    if ((*cur >= '0') && (*cur <= '9')) {

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN4@xmlNanoHTT
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN4@xmlNanoHTT

; 724  : 		version *= 10;

	imul	edx, DWORD PTR _version$10[ebp], 10
	mov	DWORD PTR _version$10[ebp], edx

; 725  : 		version += *cur - '0';

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _version$10[ebp]
	lea	eax, DWORD PTR [edx+ecx-48]
	mov	DWORD PTR _version$10[ebp], eax

; 726  : 		cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
$LN4@xmlNanoHTT:

; 727  : 	    }
; 728  : 	    while ((*cur >= '0') && (*cur <= '9'))

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN5@xmlNanoHTT
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jg	SHORT $LN5@xmlNanoHTT

; 729  : 		cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN4@xmlNanoHTT
$LN5@xmlNanoHTT:

; 730  : 	} else

	jmp	SHORT $LN34@xmlNanoHTT
$LN33@xmlNanoHTT:

; 731  : 	    version *= 10;

	imul	ecx, DWORD PTR _version$10[ebp], 10
	mov	DWORD PTR _version$10[ebp], ecx
$LN34@xmlNanoHTT:

; 732  : 	if ((*cur != ' ') && (*cur != '\t')) return;

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN6@xmlNanoHTT
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	je	SHORT $LN6@xmlNanoHTT
	jmp	$LN1@xmlNanoHTT
$LN6@xmlNanoHTT:

; 733  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN37@xmlNanoHTT
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jne	SHORT $LN7@xmlNanoHTT
$LN37@xmlNanoHTT:
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	SHORT $LN6@xmlNanoHTT
$LN7@xmlNanoHTT:

; 734  : 	if ((*cur < '0') || (*cur > '9')) return;

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN39@xmlNanoHTT
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN8@xmlNanoHTT
$LN39@xmlNanoHTT:
	jmp	$LN1@xmlNanoHTT
$LN8@xmlNanoHTT:

; 735  : 	while ((*cur >= '0') && (*cur <= '9')) {

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN9@xmlNanoHTT
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN9@xmlNanoHTT

; 736  : 	    ret *= 10;

	imul	ecx, DWORD PTR _ret$9[ebp], 10
	mov	DWORD PTR _ret$9[ebp], ecx

; 737  : 	    ret += *cur - '0';

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _ret$9[ebp]
	lea	edx, DWORD PTR [ecx+eax-48]
	mov	DWORD PTR _ret$9[ebp], edx

; 738  : 	    cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 739  : 	}

	jmp	SHORT $LN8@xmlNanoHTT
$LN9@xmlNanoHTT:

; 740  : 	if ((*cur != 0) && (*cur != ' ') && (*cur != '\t')) return;

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN40@xmlNanoHTT
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN40@xmlNanoHTT
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 9
	je	SHORT $LN40@xmlNanoHTT
	jmp	$LN1@xmlNanoHTT
$LN40@xmlNanoHTT:

; 741  : 	ctxt->returnValue = ret;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ret$9[ebp]
	mov	DWORD PTR [ecx+60], edx

; 742  :         ctxt->version = version;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _version$10[ebp]
	mov	DWORD PTR [eax+64], ecx
	jmp	$LN1@xmlNanoHTT
$LN31@xmlNanoHTT:

; 743  :     } else if (!xmlStrncasecmp(BAD_CAST line, BAD_CAST"Content-Type:", 13)) {

	push	13					; 0000000dH
	push	OFFSET ??_C@_0O@PDMPCIFL@Content?9Type?3@
	mov	edx, DWORD PTR _line$[ebp]
	push	edx
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN41@xmlNanoHTT

; 744  :         const xmlChar *charset, *last, *mime;
; 745  :         cur += 13;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 13					; 0000000dH
	mov	DWORD PTR _cur$[ebp], eax
$LN10@xmlNanoHTT:

; 746  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN43@xmlNanoHTT
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jne	SHORT $LN11@xmlNanoHTT
$LN43@xmlNanoHTT:
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN10@xmlNanoHTT
$LN11@xmlNanoHTT:

; 747  : 	if (ctxt->contentType != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+72], 0
	je	SHORT $LN44@xmlNanoHTT

; 748  : 	    xmlFree(ctxt->contentType);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN44@xmlNanoHTT:

; 749  : 	ctxt->contentType = xmlMemStrdup(cur);

	mov	esi, esp
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 750  : 	mime = (const xmlChar *) cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _mime$6[ebp], edx

; 751  : 	last = mime;

	mov	eax, DWORD PTR _mime$6[ebp]
	mov	DWORD PTR _last$7[ebp], eax
$LN12@xmlNanoHTT:

; 752  : 	while ((*last != 0) && (*last != ' ') && (*last != '\t') &&
; 753  : 	       (*last != ';') && (*last != ','))

	mov	ecx, DWORD PTR _last$7[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN13@xmlNanoHTT
	mov	eax, DWORD PTR _last$7[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN13@xmlNanoHTT
	mov	edx, DWORD PTR _last$7[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	je	SHORT $LN13@xmlNanoHTT
	mov	ecx, DWORD PTR _last$7[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 59					; 0000003bH
	je	SHORT $LN13@xmlNanoHTT
	mov	eax, DWORD PTR _last$7[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 44					; 0000002cH
	je	SHORT $LN13@xmlNanoHTT

; 754  : 	    last++;

	mov	edx, DWORD PTR _last$7[ebp]
	add	edx, 1
	mov	DWORD PTR _last$7[ebp], edx
	jmp	SHORT $LN12@xmlNanoHTT
$LN13@xmlNanoHTT:

; 755  : 	if (ctxt->mimeType != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $LN45@xmlNanoHTT

; 756  : 	    xmlFree(ctxt->mimeType);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN45@xmlNanoHTT:

; 757  : 	ctxt->mimeType = (char *) xmlStrndup(mime, last - mime);

	mov	eax, DWORD PTR _last$7[ebp]
	sub	eax, DWORD PTR _mime$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _mime$6[ebp]
	push	ecx
	call	_xmlStrndup
	add	esp, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+88], eax

; 758  : 	charset = xmlStrstr(BAD_CAST ctxt->contentType, BAD_CAST "charset=");

	push	OFFSET ??_C@_08JPKHBDLJ@charset?$DN@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	call	_xmlStrstr
	add	esp, 8
	mov	DWORD PTR _charset$8[ebp], eax

; 759  : 	if (charset != NULL) {

	cmp	DWORD PTR _charset$8[ebp], 0
	je	$LN46@xmlNanoHTT

; 760  : 	    charset += 8;

	mov	edx, DWORD PTR _charset$8[ebp]
	add	edx, 8
	mov	DWORD PTR _charset$8[ebp], edx

; 761  : 	    last = charset;

	mov	eax, DWORD PTR _charset$8[ebp]
	mov	DWORD PTR _last$7[ebp], eax
$LN14@xmlNanoHTT:

; 762  : 	    while ((*last != 0) && (*last != ' ') && (*last != '\t') &&
; 763  : 	           (*last != ';') && (*last != ','))

	mov	ecx, DWORD PTR _last$7[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN15@xmlNanoHTT
	mov	eax, DWORD PTR _last$7[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN15@xmlNanoHTT
	mov	edx, DWORD PTR _last$7[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	je	SHORT $LN15@xmlNanoHTT
	mov	ecx, DWORD PTR _last$7[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 59					; 0000003bH
	je	SHORT $LN15@xmlNanoHTT
	mov	eax, DWORD PTR _last$7[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 44					; 0000002cH
	je	SHORT $LN15@xmlNanoHTT

; 764  : 		last++;

	mov	edx, DWORD PTR _last$7[ebp]
	add	edx, 1
	mov	DWORD PTR _last$7[ebp], edx
	jmp	SHORT $LN14@xmlNanoHTT
$LN15@xmlNanoHTT:

; 765  : 	    if (ctxt->encoding != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN47@xmlNanoHTT

; 766  : 	        xmlFree(ctxt->encoding);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN47@xmlNanoHTT:

; 767  : 	    ctxt->encoding = (char *) xmlStrndup(charset, last - charset);

	mov	eax, DWORD PTR _last$7[ebp]
	sub	eax, DWORD PTR _charset$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _charset$8[ebp]
	push	ecx
	call	_xmlStrndup
	add	esp, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+84], eax
$LN46@xmlNanoHTT:

; 768  : 	}

	jmp	$LN1@xmlNanoHTT
$LN41@xmlNanoHTT:

; 769  :     } else if (!xmlStrncasecmp(BAD_CAST line, BAD_CAST"ContentType:", 12)) {

	push	12					; 0000000cH
	push	OFFSET ??_C@_0N@PPOPBCJG@ContentType?3@
	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN48@xmlNanoHTT

; 770  :         const xmlChar *charset, *last, *mime;
; 771  :         cur += 12;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _cur$[ebp], ecx

; 772  : 	if (ctxt->contentType != NULL) return;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+72], 0
	je	SHORT $LN16@xmlNanoHTT
	jmp	$LN1@xmlNanoHTT
$LN16@xmlNanoHTT:

; 773  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN51@xmlNanoHTT
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jne	SHORT $LN17@xmlNanoHTT
$LN51@xmlNanoHTT:
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	SHORT $LN16@xmlNanoHTT
$LN17@xmlNanoHTT:

; 774  : 	ctxt->contentType = xmlMemStrdup(cur);

	mov	esi, esp
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 775  : 	mime = (const xmlChar *) cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _mime$3[ebp], edx

; 776  : 	last = mime;

	mov	eax, DWORD PTR _mime$3[ebp]
	mov	DWORD PTR _last$4[ebp], eax
$LN18@xmlNanoHTT:

; 777  : 	while ((*last != 0) && (*last != ' ') && (*last != '\t') &&
; 778  : 	       (*last != ';') && (*last != ','))

	mov	ecx, DWORD PTR _last$4[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN19@xmlNanoHTT
	mov	eax, DWORD PTR _last$4[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN19@xmlNanoHTT
	mov	edx, DWORD PTR _last$4[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	je	SHORT $LN19@xmlNanoHTT
	mov	ecx, DWORD PTR _last$4[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 59					; 0000003bH
	je	SHORT $LN19@xmlNanoHTT
	mov	eax, DWORD PTR _last$4[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 44					; 0000002cH
	je	SHORT $LN19@xmlNanoHTT

; 779  : 	    last++;

	mov	edx, DWORD PTR _last$4[ebp]
	add	edx, 1
	mov	DWORD PTR _last$4[ebp], edx
	jmp	SHORT $LN18@xmlNanoHTT
$LN19@xmlNanoHTT:

; 780  : 	if (ctxt->mimeType != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $LN52@xmlNanoHTT

; 781  : 	    xmlFree(ctxt->mimeType);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN52@xmlNanoHTT:

; 782  : 	ctxt->mimeType = (char *) xmlStrndup(mime, last - mime);

	mov	eax, DWORD PTR _last$4[ebp]
	sub	eax, DWORD PTR _mime$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _mime$3[ebp]
	push	ecx
	call	_xmlStrndup
	add	esp, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+88], eax

; 783  : 	charset = xmlStrstr(BAD_CAST ctxt->contentType, BAD_CAST "charset=");

	push	OFFSET ??_C@_08JPKHBDLJ@charset?$DN@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	call	_xmlStrstr
	add	esp, 8
	mov	DWORD PTR _charset$5[ebp], eax

; 784  : 	if (charset != NULL) {

	cmp	DWORD PTR _charset$5[ebp], 0
	je	$LN53@xmlNanoHTT

; 785  : 	    charset += 8;

	mov	edx, DWORD PTR _charset$5[ebp]
	add	edx, 8
	mov	DWORD PTR _charset$5[ebp], edx

; 786  : 	    last = charset;

	mov	eax, DWORD PTR _charset$5[ebp]
	mov	DWORD PTR _last$4[ebp], eax
$LN20@xmlNanoHTT:

; 787  : 	    while ((*last != 0) && (*last != ' ') && (*last != '\t') &&
; 788  : 	           (*last != ';') && (*last != ','))

	mov	ecx, DWORD PTR _last$4[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN21@xmlNanoHTT
	mov	eax, DWORD PTR _last$4[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN21@xmlNanoHTT
	mov	edx, DWORD PTR _last$4[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	je	SHORT $LN21@xmlNanoHTT
	mov	ecx, DWORD PTR _last$4[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 59					; 0000003bH
	je	SHORT $LN21@xmlNanoHTT
	mov	eax, DWORD PTR _last$4[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 44					; 0000002cH
	je	SHORT $LN21@xmlNanoHTT

; 789  : 		last++;

	mov	edx, DWORD PTR _last$4[ebp]
	add	edx, 1
	mov	DWORD PTR _last$4[ebp], edx
	jmp	SHORT $LN20@xmlNanoHTT
$LN21@xmlNanoHTT:

; 790  : 	    if (ctxt->encoding != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN54@xmlNanoHTT

; 791  : 	        xmlFree(ctxt->encoding);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN54@xmlNanoHTT:

; 792  : 	    ctxt->encoding = (char *) xmlStrndup(charset, last - charset);

	mov	eax, DWORD PTR _last$4[ebp]
	sub	eax, DWORD PTR _charset$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _charset$5[ebp]
	push	ecx
	call	_xmlStrndup
	add	esp, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+84], eax
$LN53@xmlNanoHTT:

; 793  : 	}

	jmp	$LN1@xmlNanoHTT
$LN48@xmlNanoHTT:

; 794  :     } else if (!xmlStrncasecmp(BAD_CAST line, BAD_CAST"Location:", 9)) {

	push	9
	push	OFFSET ??_C@_09GILIFLDG@Location?3@
	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN55@xmlNanoHTT

; 795  :         cur += 9;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 9
	mov	DWORD PTR _cur$[ebp], ecx
$LN22@xmlNanoHTT:

; 796  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN57@xmlNanoHTT
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jne	SHORT $LN23@xmlNanoHTT
$LN57@xmlNanoHTT:
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN22@xmlNanoHTT
$LN23@xmlNanoHTT:

; 797  : 	if (ctxt->location != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+76], 0
	je	SHORT $LN58@xmlNanoHTT

; 798  : 	    xmlFree(ctxt->location);

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN58@xmlNanoHTT:

; 799  : 	if (*cur == '/') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN59@xmlNanoHTT

; 800  : 	    xmlChar *tmp_http = xmlStrdup(BAD_CAST "http://");

	push	OFFSET ??_C@_07FGAOOBMN@http?3?1?1@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _tmp_http$2[ebp], eax

; 801  : 	    xmlChar *tmp_loc =

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _tmp_http$2[ebp]
	push	edx
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _tmp_loc$1[ebp], eax

; 802  : 	        xmlStrcat(tmp_http, (const xmlChar *) ctxt->hostname);
; 803  : 	    ctxt->location =

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmp_loc$1[ebp]
	push	ecx
	call	_xmlStrcat
	add	esp, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+76], eax

; 804  : 	        (char *) xmlStrcat (tmp_loc, (const xmlChar *) cur);
; 805  : 	} else {

	jmp	SHORT $LN60@xmlNanoHTT
$LN59@xmlNanoHTT:

; 806  : 	    ctxt->location = xmlMemStrdup(cur);

	mov	esi, esp
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+76], eax
$LN60@xmlNanoHTT:

; 807  : 	}

	jmp	$LN1@xmlNanoHTT
$LN55@xmlNanoHTT:

; 808  :     } else if (!xmlStrncasecmp(BAD_CAST line, BAD_CAST"WWW-Authenticate:", 17)) {

	push	17					; 00000011H
	push	OFFSET ??_C@_0BC@EALNDOCH@WWW?9Authenticate?3@
	mov	edx, DWORD PTR _line$[ebp]
	push	edx
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN61@xmlNanoHTT

; 809  :         cur += 17;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 17					; 00000011H
	mov	DWORD PTR _cur$[ebp], eax
$LN24@xmlNanoHTT:

; 810  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN63@xmlNanoHTT
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jne	SHORT $LN25@xmlNanoHTT
$LN63@xmlNanoHTT:
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN24@xmlNanoHTT
$LN25@xmlNanoHTT:

; 811  : 	if (ctxt->authHeader != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN64@xmlNanoHTT

; 812  : 	    xmlFree(ctxt->authHeader);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN64@xmlNanoHTT:

; 813  : 	ctxt->authHeader = xmlMemStrdup(cur);

	mov	esi, esp
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+80], eax
	jmp	$LN1@xmlNanoHTT
$LN61@xmlNanoHTT:

; 814  :     } else if (!xmlStrncasecmp(BAD_CAST line, BAD_CAST"Proxy-Authenticate:", 19)) {

	push	19					; 00000013H
	push	OFFSET ??_C@_0BE@EKBPAAMO@Proxy?9Authenticate?3@
	mov	edx, DWORD PTR _line$[ebp]
	push	edx
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN65@xmlNanoHTT

; 815  :         cur += 19;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 19					; 00000013H
	mov	DWORD PTR _cur$[ebp], eax
$LN26@xmlNanoHTT:

; 816  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN67@xmlNanoHTT
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jne	SHORT $LN27@xmlNanoHTT
$LN67@xmlNanoHTT:
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN26@xmlNanoHTT
$LN27@xmlNanoHTT:

; 817  : 	if (ctxt->authHeader != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN68@xmlNanoHTT

; 818  : 	    xmlFree(ctxt->authHeader);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN68@xmlNanoHTT:

; 819  : 	ctxt->authHeader = xmlMemStrdup(cur);

	mov	esi, esp
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+80], eax
	jmp	$LN1@xmlNanoHTT
$LN65@xmlNanoHTT:

; 820  : #ifdef LIBXML_ZLIB_ENABLED
; 821  :     } else if ( !xmlStrncasecmp( BAD_CAST line, BAD_CAST"Content-Encoding:", 17) ) {

	push	17					; 00000011H
	push	OFFSET ??_C@_0BC@FGDKEGD@Content?9Encoding?3@
	mov	edx, DWORD PTR _line$[ebp]
	push	edx
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN69@xmlNanoHTT

; 822  : 	cur += 17;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 17					; 00000011H
	mov	DWORD PTR _cur$[ebp], eax
$LN28@xmlNanoHTT:

; 823  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN71@xmlNanoHTT
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jne	SHORT $LN29@xmlNanoHTT
$LN71@xmlNanoHTT:
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN28@xmlNanoHTT
$LN29@xmlNanoHTT:

; 824  : 	if ( !xmlStrncasecmp( BAD_CAST cur, BAD_CAST"gzip", 4) ) {

	push	4
	push	OFFSET ??_C@_04HOHEGKBO@gzip@
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN72@xmlNanoHTT

; 825  : 	    ctxt->usesGzip = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+96], 1

; 826  : 
; 827  : 	    ctxt->strm = xmlMalloc(sizeof(z_stream));

	mov	esi, esp
	push	56					; 00000038H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+92], eax

; 828  : 
; 829  : 	    if (ctxt->strm != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN72@xmlNanoHTT

; 830  : 		ctxt->strm->zalloc = Z_NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [edx+32], 0

; 831  : 		ctxt->strm->zfree = Z_NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR [ecx+36], 0

; 832  : 		ctxt->strm->opaque = Z_NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	DWORD PTR [eax+40], 0

; 833  : 		ctxt->strm->avail_in = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [edx+4], 0

; 834  : 		ctxt->strm->next_in = Z_NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR [ecx], 0

; 835  : 
; 836  : 		inflateInit2( ctxt->strm, 31 );

	push	56					; 00000038H
	push	OFFSET ??_C@_06CJNJFBNP@1?42?411@
	push	31					; 0000001fH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+92]
	push	eax
	call	_inflateInit2_@16
$LN72@xmlNanoHTT:

; 837  : 	    }
; 838  : 	}

	jmp	SHORT $LN1@xmlNanoHTT
$LN69@xmlNanoHTT:

; 839  : #endif
; 840  :     } else if ( !xmlStrncasecmp( BAD_CAST line, BAD_CAST"Content-Length:", 15) ) {

	push	15					; 0000000fH
	push	OFFSET ??_C@_0BA@DIGAFIOK@Content?9Length?3@
	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@xmlNanoHTT

; 841  : 	cur += 15;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 15					; 0000000fH
	mov	DWORD PTR _cur$[ebp], edx

; 842  : 	ctxt->ContentLength = strtol( cur, NULL, 10 );

	mov	esi, esp
	push	10					; 0000000aH
	push	0
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+68], eax
$LN1@xmlNanoHTT:

; 843  :     }
; 844  : }

	pop	edi
	pop	esi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPScanAnswer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPReadLine
_TEXT	SEGMENT
_rc$ = -4112						; size = 4
_bp$ = -4108						; size = 4
_buf$ = -4100						; size = 4096
_ctxt$ = 8						; size = 4
_xmlNanoHTTPReadLine PROC				; COMDAT

; 660  : xmlNanoHTTPReadLine(xmlNanoHTTPCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	eax, 4112				; 00001010H
	call	__chkstk
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-4112]
	mov	ecx, 1028				; 00000404H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 661  :     char buf[4096];
; 662  :     char *bp = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _bp$[ebp], eax
$LN2@xmlNanoHTT:

; 663  :     int	rc;
; 664  : 
; 665  :     while (bp - buf < 4095) {

	mov	ecx, DWORD PTR _bp$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	sub	ecx, edx
	cmp	ecx, 4095				; 00000fffH
	jge	$LN3@xmlNanoHTT

; 666  : 	if (ctxt->inrptr == ctxt->inptr) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax+48]
	cmp	edx, DWORD PTR [ecx+44]
	jne	SHORT $LN4@xmlNanoHTT

; 667  : 	    if ( (rc = xmlNanoHTTPRecv(ctxt)) == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNanoHTTPRecv
	add	esp, 4
	mov	DWORD PTR _rc$[ebp], eax
	cmp	DWORD PTR _rc$[ebp], 0
	jne	SHORT $LN5@xmlNanoHTT

; 668  : 		if (bp == buf)

	lea	ecx, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR _bp$[ebp], ecx
	jne	SHORT $LN7@xmlNanoHTT

; 669  : 		    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNanoHTT
	jmp	SHORT $LN8@xmlNanoHTT
$LN7@xmlNanoHTT:

; 670  : 		else
; 671  : 		    *bp = 0;

	mov	edx, DWORD PTR _bp$[ebp]
	mov	BYTE PTR [edx], 0
$LN8@xmlNanoHTT:

; 672  : 		return(xmlMemStrdup(buf));

	mov	esi, esp
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN1@xmlNanoHTT

; 673  : 	    }

	jmp	SHORT $LN4@xmlNanoHTT
$LN5@xmlNanoHTT:

; 674  : 	    else if ( rc == -1 ) {

	cmp	DWORD PTR _rc$[ebp], -1
	jne	SHORT $LN4@xmlNanoHTT

; 675  : 	        return ( NULL );

	xor	eax, eax
	jmp	$LN1@xmlNanoHTT
$LN4@xmlNanoHTT:

; 676  : 	    }
; 677  : 	}
; 678  : 	*bp = *ctxt->inrptr++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _bp$[ebp]
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+48]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 679  : 	if (*bp == '\n') {

	mov	edx, DWORD PTR _bp$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN10@xmlNanoHTT

; 680  : 	    *bp = 0;

	mov	ecx, DWORD PTR _bp$[ebp]
	mov	BYTE PTR [ecx], 0

; 681  : 	    return(xmlMemStrdup(buf));

	mov	esi, esp
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN1@xmlNanoHTT
$LN10@xmlNanoHTT:

; 682  : 	}
; 683  : 	if (*bp != '\r')

	mov	eax, DWORD PTR _bp$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN11@xmlNanoHTT

; 684  : 	    bp++;

	mov	edx, DWORD PTR _bp$[ebp]
	add	edx, 1
	mov	DWORD PTR _bp$[ebp], edx
$LN11@xmlNanoHTT:

; 685  :     }

	jmp	$LN2@xmlNanoHTT
$LN3@xmlNanoHTT:

; 686  :     buf[4095] = 0;

	mov	eax, 1
	imul	ecx, eax, 4095
	mov	BYTE PTR _buf$[ebp+ecx], 0

; 687  :     return(xmlMemStrdup(buf));

	mov	esi, esp
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlNanoHTT:

; 688  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@xmlNanoHTT
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 4112				; 00001010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN15@xmlNanoHTT:
	DD	1
	DD	$LN14@xmlNanoHTT
$LN14@xmlNanoHTT:
	DD	-4100					; ffffeffcH
	DD	4096					; 00001000H
	DD	$LN13@xmlNanoHTT
$LN13@xmlNanoHTT:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_xmlNanoHTTPReadLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPRecv
_TEXT	SEGMENT
tv197 = -316						; size = 4
___i$1 = -312						; size = 4
_tmp_ptr$2 = -308					; size = 4
_d_inrptr$3 = -304					; size = 4
_d_content$4 = -300					; size = 4
_d_inptr$5 = -296					; size = 4
_len$6 = -292						; size = 4
_delta$7 = -288						; size = 4
_tv$ = -280						; size = 8
_rfd$ = -264						; size = 260
_ctxt$ = 8						; size = 4
_xmlNanoHTTPRecv PROC					; COMDAT

; 534  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlNanoHTT:

; 535  : #ifdef HAVE_POLL_H
; 536  :     struct pollfd p;
; 537  : #else
; 538  :     fd_set rfd;
; 539  :     struct timeval tv;
; 540  : #endif
; 541  : 
; 542  : 
; 543  :     while (ctxt->state & XML_NANO_HTTP_READ) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, 2
	je	$LN3@xmlNanoHTT

; 544  :         if (ctxt->in == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jne	SHORT $LN12@xmlNanoHTT

; 545  :             ctxt->in = (char *) xmlMallocAtomic(65000 * sizeof(char));

	mov	esi, esp
	push	65000					; 0000fde8H
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 546  :             if (ctxt->in == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jne	SHORT $LN13@xmlNanoHTT

; 547  :                 xmlHTTPErrMemory("allocating input");

	push	OFFSET ??_C@_0BB@BIOIGIMH@allocating?5input@
	call	_xmlHTTPErrMemory
	add	esp, 4

; 548  :                 ctxt->last = -1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+56], -1

; 549  :                 return (-1);

	or	eax, -1
	jmp	$LN1@xmlNanoHTT
$LN13@xmlNanoHTT:

; 550  :             }
; 551  :             ctxt->inlen = 65000;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+52], 65000		; 0000fde8H

; 552  :             ctxt->inptr = ctxt->content = ctxt->inrptr = ctxt->in;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+48], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+40], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+44], ecx
$LN12@xmlNanoHTT:

; 553  :         }
; 554  :         if (ctxt->inrptr > ctxt->in + XML_NANO_HTTP_CHUNK) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, 4096				; 00001000H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+48], eax
	jbe	SHORT $LN14@xmlNanoHTT

; 555  :             int delta = ctxt->inrptr - ctxt->in;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	sub	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _delta$7[ebp], ecx

; 556  :             int len = ctxt->inptr - ctxt->inrptr;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	sub	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _len$6[ebp], ecx

; 557  : 
; 558  :             memmove(ctxt->in, ctxt->inrptr, len);

	mov	edx, DWORD PTR _len$6[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 559  :             ctxt->inrptr -= delta;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	sub	edx, DWORD PTR _delta$7[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+48], edx

; 560  :             ctxt->content -= delta;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, DWORD PTR _delta$7[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+40], edx

; 561  :             ctxt->inptr -= delta;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	sub	edx, DWORD PTR _delta$7[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+44], edx
$LN14@xmlNanoHTT:

; 562  :         }
; 563  :         if ((ctxt->in + ctxt->inlen) < (ctxt->inptr + XML_NANO_HTTP_CHUNK)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	add	edx, DWORD PTR [eax+52]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+44]
	add	eax, 4096				; 00001000H
	cmp	edx, eax
	jae	$LN15@xmlNanoHTT

; 564  :             int d_inptr = ctxt->inptr - ctxt->in;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+44]
	sub	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _d_inptr$5[ebp], eax

; 565  :             int d_content = ctxt->content - ctxt->in;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+40]
	sub	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _d_content$4[ebp], eax

; 566  :             int d_inrptr = ctxt->inrptr - ctxt->in;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	sub	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _d_inrptr$3[ebp], eax

; 567  :             char *tmp_ptr = ctxt->in;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _tmp_ptr$2[ebp], edx

; 568  : 
; 569  :             ctxt->inlen *= 2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	shl	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+52], ecx

; 570  :             ctxt->in = (char *) xmlRealloc(tmp_ptr, ctxt->inlen);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _tmp_ptr$2[ebp]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 571  :             if (ctxt->in == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jne	SHORT $LN16@xmlNanoHTT

; 572  :                 xmlHTTPErrMemory("allocating input buffer");

	push	OFFSET ??_C@_0BI@IFIOEEDJ@allocating?5input?5buffer@
	call	_xmlHTTPErrMemory
	add	esp, 4

; 573  :                 xmlFree(tmp_ptr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmp_ptr$2[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 574  :                 ctxt->last = -1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+56], -1

; 575  :                 return (-1);

	or	eax, -1
	jmp	$LN1@xmlNanoHTT
$LN16@xmlNanoHTT:

; 576  :             }
; 577  :             ctxt->inptr = ctxt->in + d_inptr;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, DWORD PTR _d_inptr$5[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 578  :             ctxt->content = ctxt->in + d_content;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, DWORD PTR _d_content$4[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 579  :             ctxt->inrptr = ctxt->in + d_inrptr;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, DWORD PTR _d_inrptr$3[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+48], eax
$LN15@xmlNanoHTT:

; 580  :         }
; 581  :         ctxt->last = recv(ctxt->fd, ctxt->inptr, XML_NANO_HTTP_CHUNK, 0);

	mov	esi, esp
	push	0
	push	4096					; 00001000H
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	DWORD PTR __imp__recv@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+56], eax

; 582  :         if (ctxt->last > 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+56], 0
	jle	SHORT $LN17@xmlNanoHTT

; 583  :             ctxt->inptr += ctxt->last;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _ctxt$[ebp]
	add	ecx, DWORD PTR [edx+56]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 584  :             return (ctxt->last);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+56]
	jmp	$LN1@xmlNanoHTT
$LN17@xmlNanoHTT:

; 585  :         }
; 586  :         if (ctxt->last == 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN18@xmlNanoHTT

; 587  :             return (0);

	xor	eax, eax
	jmp	$LN1@xmlNanoHTT
$LN18@xmlNanoHTT:

; 588  :         }
; 589  :         if (ctxt->last == -1) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+56], -1
	jne	SHORT $LN19@xmlNanoHTT

; 590  :             switch (socket_errno()) {

	call	_socket_errno
	mov	DWORD PTR tv197[ebp], eax
	cmp	DWORD PTR tv197[ebp], 112		; 00000070H
	jg	SHORT $LN28@xmlNanoHTT
	cmp	DWORD PTR tv197[ebp], 112		; 00000070H
	je	SHORT $LN20@xmlNanoHTT
	cmp	DWORD PTR tv197[ebp], 11		; 0000000bH
	je	SHORT $LN20@xmlNanoHTT
	cmp	DWORD PTR tv197[ebp], 108		; 0000006cH
	je	SHORT $LN21@xmlNanoHTT
	jmp	SHORT $LN22@xmlNanoHTT
$LN28@xmlNanoHTT:
	cmp	DWORD PTR tv197[ebp], 140		; 0000008cH
	je	SHORT $LN20@xmlNanoHTT
	cmp	DWORD PTR tv197[ebp], 10058		; 0000274aH
	je	SHORT $LN21@xmlNanoHTT
	jmp	SHORT $LN22@xmlNanoHTT
$LN20@xmlNanoHTT:

; 591  :                 case EINPROGRESS:
; 592  :                 case EWOULDBLOCK:
; 593  : #if defined(EAGAIN) && EAGAIN != EWOULDBLOCK
; 594  :                 case EAGAIN:
; 595  : #endif
; 596  :                     break;

	jmp	SHORT $LN19@xmlNanoHTT
$LN21@xmlNanoHTT:

; 597  : 
; 598  :                 case ECONNRESET:
; 599  :                 case ESHUTDOWN:
; 600  :                     return (0);

	xor	eax, eax
	jmp	$LN1@xmlNanoHTT
$LN22@xmlNanoHTT:

; 601  : 
; 602  :                 default:
; 603  :                     __xmlIOErr(XML_FROM_HTTP, 0, "recv failed\n");

	push	OFFSET ??_C@_0N@NLPHEKBL@recv?5failed?6@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 604  :                     return (-1);

	or	eax, -1
	jmp	$LN1@xmlNanoHTT
$LN19@xmlNanoHTT:

; 605  :             }
; 606  :         }
; 607  : #ifdef HAVE_POLL_H
; 608  :         p.fd = ctxt->fd;
; 609  :         p.events = POLLIN;
; 610  :         if ((poll(&p, 1, timeout * 1000) < 1)
; 611  : #if defined(EINTR)
; 612  :             && (errno != EINTR)
; 613  : #endif
; 614  :             )
; 615  :             return (0);
; 616  : #else /* !HAVE_POLL_H */
; 617  : #ifndef _WINSOCKAPI_
; 618  :         if (ctxt->fd > FD_SETSIZE)
; 619  :             return 0;
; 620  : #endif
; 621  : 
; 622  :         tv.tv_sec = timeout;

	mov	ecx, DWORD PTR _timeout
	mov	DWORD PTR _tv$[ebp], ecx

; 623  :         tv.tv_usec = 0;

	mov	DWORD PTR _tv$[ebp+4], 0

; 624  :         FD_ZERO(&rfd);

	mov	DWORD PTR _rfd$[ebp], 0
$LN8@xmlNanoHTT:

; 625  : 
; 626  : #ifdef _MSC_VER
; 627  : #pragma warning(push)
; 628  : #pragma warning(disable: 4018)
; 629  : #endif
; 630  : 
; 631  :         FD_SET(ctxt->fd, &rfd);

	mov	DWORD PTR ___i$1[ebp], 0
	jmp	SHORT $LN11@xmlNanoHTT
$LN9@xmlNanoHTT:
	mov	edx, DWORD PTR ___i$1[ebp]
	add	edx, 1
	mov	DWORD PTR ___i$1[ebp], edx
$LN11@xmlNanoHTT:
	mov	eax, DWORD PTR ___i$1[ebp]
	cmp	eax, DWORD PTR _rfd$[ebp]
	jae	SHORT $LN10@xmlNanoHTT
	mov	ecx, DWORD PTR ___i$1[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _rfd$[ebp+ecx*4+4]
	cmp	eax, DWORD PTR [edx+20]
	jne	SHORT $LN23@xmlNanoHTT
	jmp	SHORT $LN10@xmlNanoHTT
$LN23@xmlNanoHTT:
	jmp	SHORT $LN9@xmlNanoHTT
$LN10@xmlNanoHTT:
	mov	ecx, DWORD PTR ___i$1[ebp]
	cmp	ecx, DWORD PTR _rfd$[ebp]
	jne	SHORT $LN6@xmlNanoHTT
	cmp	DWORD PTR _rfd$[ebp], 64		; 00000040H
	jae	SHORT $LN6@xmlNanoHTT
	mov	edx, DWORD PTR ___i$1[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _rfd$[ebp+edx*4+4], ecx
	mov	edx, DWORD PTR _rfd$[ebp]
	add	edx, 1
	mov	DWORD PTR _rfd$[ebp], edx
$LN6@xmlNanoHTT:
	xor	eax, eax
	jne	SHORT $LN8@xmlNanoHTT

; 632  : 
; 633  : #ifdef _MSC_VER
; 634  : #pragma warning(pop)
; 635  : #endif
; 636  : 
; 637  :         if ((select(ctxt->fd + 1, &rfd, NULL, NULL, &tv) < 1)
; 638  : #if defined(EINTR)
; 639  :             && (socket_errno() != EINTR)

	mov	esi, esp
	lea	ecx, DWORD PTR _tv$[ebp]
	push	ecx
	push	0
	push	0
	lea	edx, DWORD PTR _rfd$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp__select@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jge	SHORT $LN26@xmlNanoHTT
	call	_socket_errno
	cmp	eax, 4
	je	SHORT $LN26@xmlNanoHTT

; 640  : #endif
; 641  :             )
; 642  :             return (0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNanoHTT
$LN26@xmlNanoHTT:

; 643  : #endif /* !HAVE_POLL_H */
; 644  :     }

	jmp	$LN2@xmlNanoHTT
$LN3@xmlNanoHTT:

; 645  :     return (0);

	xor	eax, eax
$LN1@xmlNanoHTT:

; 646  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN32@xmlNanoHTT
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN32@xmlNanoHTT:
	DD	2
	DD	$LN31@xmlNanoHTT
$LN31@xmlNanoHTT:
	DD	-264					; fffffef8H
	DD	260					; 00000104H
	DD	$LN29@xmlNanoHTT
	DD	-280					; fffffee8H
	DD	8
	DD	$LN30@xmlNanoHTT
$LN30@xmlNanoHTT:
	DB	116					; 00000074H
	DB	118					; 00000076H
	DB	0
$LN29@xmlNanoHTT:
	DB	114					; 00000072H
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
_xmlNanoHTTPRecv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPSend
_TEXT	SEGMENT
___i$1 = -296						; size = 4
_nsent$2 = -292						; size = 4
_wfd$ = -284						; size = 260
_tv$ = -16						; size = 8
_total_sent$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_xmt_ptr$ = 12						; size = 4
_outlen$ = 16						; size = 4
_xmlNanoHTTPSend PROC					; COMDAT

; 460  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-296]
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 461  :     int total_sent = 0;

	mov	DWORD PTR _total_sent$[ebp], 0

; 462  : #ifdef HAVE_POLL_H
; 463  :     struct pollfd p;
; 464  : #else
; 465  :     struct timeval tv;
; 466  :     fd_set wfd;
; 467  : #endif
; 468  : 
; 469  :     if ((ctxt->state & XML_NANO_HTTP_WRITE) && (xmt_ptr != NULL)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, 1
	je	$LN10@xmlNanoHTT
	cmp	DWORD PTR _xmt_ptr$[ebp], 0
	je	$LN10@xmlNanoHTT
$LN2@xmlNanoHTT:

; 470  :         while (total_sent < outlen) {

	mov	edx, DWORD PTR _total_sent$[ebp]
	cmp	edx, DWORD PTR _outlen$[ebp]
	jge	$LN10@xmlNanoHTT

; 471  :             int nsent = send(ctxt->fd, SEND_ARG2_CAST (xmt_ptr + total_sent),

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _outlen$[ebp]
	sub	eax, DWORD PTR _total_sent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xmt_ptr$[ebp]
	add	ecx, DWORD PTR _total_sent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	DWORD PTR __imp__send@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nsent$2[ebp], eax

; 472  :                              outlen - total_sent, 0);
; 473  : 
; 474  :             if (nsent > 0)

	cmp	DWORD PTR _nsent$2[ebp], 0
	jle	SHORT $LN11@xmlNanoHTT

; 475  :                 total_sent += nsent;

	mov	ecx, DWORD PTR _total_sent$[ebp]
	add	ecx, DWORD PTR _nsent$2[ebp]
	mov	DWORD PTR _total_sent$[ebp], ecx
	jmp	$LN12@xmlNanoHTT
$LN11@xmlNanoHTT:

; 476  :             else if ((nsent == -1) &&
; 477  : #if defined(EAGAIN) && EAGAIN != EWOULDBLOCK
; 478  :                      (socket_errno() != EAGAIN) &&

	cmp	DWORD PTR _nsent$2[ebp], -1
	jne	SHORT $LN13@xmlNanoHTT
	call	_socket_errno
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN13@xmlNanoHTT
	call	_socket_errno
	cmp	eax, 140				; 0000008cH
	je	SHORT $LN13@xmlNanoHTT

; 479  : #endif
; 480  :                      (socket_errno() != EWOULDBLOCK)) {
; 481  :                 __xmlIOErr(XML_FROM_HTTP, 0, "send failed\n");

	push	OFFSET ??_C@_0N@OOKOIPEM@send?5failed?6@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 482  :                 if (total_sent == 0)

	cmp	DWORD PTR _total_sent$[ebp], 0
	jne	SHORT $LN15@xmlNanoHTT

; 483  :                     total_sent = -1;

	mov	DWORD PTR _total_sent$[ebp], -1
$LN15@xmlNanoHTT:

; 484  :                 break;

	jmp	$LN10@xmlNanoHTT

; 485  :             } else {

	jmp	$LN12@xmlNanoHTT
$LN13@xmlNanoHTT:

; 486  :                 /*
; 487  :                  * No data sent
; 488  :                  * Since non-blocking sockets are used, wait for
; 489  :                  * socket to be writable or default timeout prior
; 490  :                  * to retrying.
; 491  :                  */
; 492  : #ifndef HAVE_POLL_H
; 493  : #ifndef _WINSOCKAPI_
; 494  :                 if (ctxt->fd > FD_SETSIZE)
; 495  :                     return -1;
; 496  : #endif
; 497  : 
; 498  :                 tv.tv_sec = timeout;

	mov	edx, DWORD PTR _timeout
	mov	DWORD PTR _tv$[ebp], edx

; 499  :                 tv.tv_usec = 0;

	mov	DWORD PTR _tv$[ebp+4], 0

; 500  :                 FD_ZERO(&wfd);

	mov	DWORD PTR _wfd$[ebp], 0
$LN6@xmlNanoHTT:

; 501  : #ifdef _MSC_VER
; 502  : #pragma warning(push)
; 503  : #pragma warning(disable: 4018)
; 504  : #endif
; 505  :                 FD_SET(ctxt->fd, &wfd);

	mov	DWORD PTR ___i$1[ebp], 0
	jmp	SHORT $LN9@xmlNanoHTT
$LN7@xmlNanoHTT:
	mov	eax, DWORD PTR ___i$1[ebp]
	add	eax, 1
	mov	DWORD PTR ___i$1[ebp], eax
$LN9@xmlNanoHTT:
	mov	ecx, DWORD PTR ___i$1[ebp]
	cmp	ecx, DWORD PTR _wfd$[ebp]
	jae	SHORT $LN8@xmlNanoHTT
	mov	edx, DWORD PTR ___i$1[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _wfd$[ebp+edx*4+4]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN16@xmlNanoHTT
	jmp	SHORT $LN8@xmlNanoHTT
$LN16@xmlNanoHTT:
	jmp	SHORT $LN7@xmlNanoHTT
$LN8@xmlNanoHTT:
	mov	edx, DWORD PTR ___i$1[ebp]
	cmp	edx, DWORD PTR _wfd$[ebp]
	jne	SHORT $LN4@xmlNanoHTT
	cmp	DWORD PTR _wfd$[ebp], 64		; 00000040H
	jae	SHORT $LN4@xmlNanoHTT
	mov	eax, DWORD PTR ___i$1[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _wfd$[ebp+eax*4+4], edx
	mov	eax, DWORD PTR _wfd$[ebp]
	add	eax, 1
	mov	DWORD PTR _wfd$[ebp], eax
$LN4@xmlNanoHTT:
	xor	ecx, ecx
	jne	SHORT $LN6@xmlNanoHTT

; 506  : #ifdef _MSC_VER
; 507  : #pragma warning(pop)
; 508  : #endif
; 509  :                 (void) select(ctxt->fd + 1, NULL, &wfd, NULL, &tv);

	mov	esi, esp
	lea	edx, DWORD PTR _tv$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _wfd$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp__select@20
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlNanoHTT:

; 510  : #else
; 511  :                 p.fd = ctxt->fd;
; 512  :                 p.events = POLLOUT;
; 513  :                 (void) poll(&p, 1, timeout * 1000);
; 514  : #endif /* !HAVE_POLL_H */
; 515  :             }
; 516  :         }

	jmp	$LN2@xmlNanoHTT
$LN10@xmlNanoHTT:

; 517  :     }
; 518  : 
; 519  :     return total_sent;

	mov	eax, DWORD PTR _total_sent$[ebp]

; 520  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@xmlNanoHTT
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 296				; 00000128H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN23@xmlNanoHTT:
	DD	2
	DD	$LN22@xmlNanoHTT
$LN22@xmlNanoHTT:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN20@xmlNanoHTT
	DD	-284					; fffffee4H
	DD	260					; 00000104H
	DD	$LN21@xmlNanoHTT
$LN21@xmlNanoHTT:
	DB	119					; 00000077H
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
$LN20@xmlNanoHTT:
	DB	116					; 00000074H
	DB	118					; 00000076H
	DB	0
_xmlNanoHTTPSend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPFreeCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlNanoHTTPFreeCtxt PROC				; COMDAT

; 424  : xmlNanoHTTPFreeCtxt(xmlNanoHTTPCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 425  :     if (ctxt == NULL) return;

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlNanoHTT
	jmp	$LN1@xmlNanoHTT
$LN2@xmlNanoHTT:

; 426  :     if (ctxt->hostname != NULL) xmlFree(ctxt->hostname);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@xmlNanoHTT
	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlNanoHTT:

; 427  :     if (ctxt->protocol != NULL) xmlFree(ctxt->protocol);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@xmlNanoHTT
	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlNanoHTT:

; 428  :     if (ctxt->path != NULL) xmlFree(ctxt->path);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN5@xmlNanoHTT
	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@xmlNanoHTT:

; 429  :     if (ctxt->query != NULL) xmlFree(ctxt->query);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN6@xmlNanoHTT
	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@xmlNanoHTT:

; 430  :     if (ctxt->out != NULL) xmlFree(ctxt->out);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN7@xmlNanoHTT
	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlNanoHTT:

; 431  :     if (ctxt->in != NULL) xmlFree(ctxt->in);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN8@xmlNanoHTT
	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@xmlNanoHTT:

; 432  :     if (ctxt->contentType != NULL) xmlFree(ctxt->contentType);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+72], 0
	je	SHORT $LN9@xmlNanoHTT
	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@xmlNanoHTT:

; 433  :     if (ctxt->encoding != NULL) xmlFree(ctxt->encoding);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN10@xmlNanoHTT
	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@xmlNanoHTT:

; 434  :     if (ctxt->mimeType != NULL) xmlFree(ctxt->mimeType);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $LN11@xmlNanoHTT
	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlNanoHTT:

; 435  :     if (ctxt->location != NULL) xmlFree(ctxt->location);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	SHORT $LN12@xmlNanoHTT
	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlNanoHTT:

; 436  :     if (ctxt->authHeader != NULL) xmlFree(ctxt->authHeader);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN13@xmlNanoHTT
	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@xmlNanoHTT:

; 437  : #ifdef LIBXML_ZLIB_ENABLED
; 438  :     if (ctxt->strm != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN14@xmlNanoHTT

; 439  : 	inflateEnd(ctxt->strm);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	push	edx
	call	_inflateEnd@4

; 440  : 	xmlFree(ctxt->strm);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@xmlNanoHTT:

; 441  :     }
; 442  : #endif
; 443  : 
; 444  :     ctxt->state = XML_NANO_HTTP_NONE;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+24], 4

; 445  :     if (ctxt->fd != INVALID_SOCKET) closesocket(ctxt->fd);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+20], -1
	je	SHORT $LN15@xmlNanoHTT
	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	DWORD PTR __imp__closesocket@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@xmlNanoHTT:

; 446  :     ctxt->fd = INVALID_SOCKET;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+20], -1

; 447  :     xmlFree(ctxt);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlNanoHTT:

; 448  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlNanoHTTPFreeCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPNewCtxt
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_URL$ = 8						; size = 4
_xmlNanoHTTPNewCtxt PROC				; COMDAT

; 396  : xmlNanoHTTPNewCtxt(const char *URL) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 397  :     xmlNanoHTTPCtxtPtr ret;
; 398  : 
; 399  :     ret = (xmlNanoHTTPCtxtPtr) xmlMalloc(sizeof(xmlNanoHTTPCtxt));

	mov	esi, esp
	push	100					; 00000064H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 400  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlNanoHTT

; 401  :         xmlHTTPErrMemory("allocating context");

	push	OFFSET ??_C@_0BD@NMNFIMM@allocating?5context@
	call	_xmlHTTPErrMemory
	add	esp, 4

; 402  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNanoHTT
$LN2@xmlNanoHTT:

; 403  :     }
; 404  : 
; 405  :     memset(ret, 0, sizeof(xmlNanoHTTPCtxt));

	push	100					; 00000064H
	push	0
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 406  :     ret->port = 80;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+8], 80			; 00000050H

; 407  :     ret->returnValue = 0;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+60], 0

; 408  :     ret->fd = INVALID_SOCKET;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+20], -1

; 409  :     ret->ContentLength = -1;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+68], -1

; 410  : 
; 411  :     xmlNanoHTTPScanURL(ret, URL);

	mov	edx, DWORD PTR _URL$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlNanoHTTPScanURL
	add	esp, 8

; 412  : 
; 413  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlNanoHTT:

; 414  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPNewCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPScanURL
_TEXT	SEGMENT
tv139 = -24						; size = 4
tv230 = -17						; size = 1
tv227 = -16						; size = 4
tv224 = -12						; size = 4
_len$ = -8						; size = 4
_uri$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_URL$ = 12						; size = 4
_xmlNanoHTTPScanURL PROC				; COMDAT

; 284  : xmlNanoHTTPScanURL(xmlNanoHTTPCtxtPtr ctxt, const char *URL) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 285  :     xmlURIPtr uri;
; 286  :     int len;
; 287  : 
; 288  :     /*
; 289  :      * Clear any existing data from the context
; 290  :      */
; 291  :     if (ctxt->protocol != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@xmlNanoHTT

; 292  :         xmlFree(ctxt->protocol);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 293  : 	ctxt->protocol = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@xmlNanoHTT:

; 294  :     }
; 295  :     if (ctxt->hostname != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN3@xmlNanoHTT

; 296  :         xmlFree(ctxt->hostname);

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 297  : 	ctxt->hostname = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN3@xmlNanoHTT:

; 298  :     }
; 299  :     if (ctxt->path != NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN4@xmlNanoHTT

; 300  :         xmlFree(ctxt->path);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 301  : 	ctxt->path = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+12], 0
$LN4@xmlNanoHTT:

; 302  :     }
; 303  :     if (ctxt->query != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN5@xmlNanoHTT

; 304  :         xmlFree(ctxt->query);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 305  : 	ctxt->query = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+16], 0
$LN5@xmlNanoHTT:

; 306  :     }
; 307  :     if (URL == NULL) return;

	cmp	DWORD PTR _URL$[ebp], 0
	jne	SHORT $LN6@xmlNanoHTT
	jmp	$LN1@xmlNanoHTT
$LN6@xmlNanoHTT:

; 308  : 
; 309  :     uri = xmlParseURIRaw(URL, 1);

	push	1
	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	call	_xmlParseURIRaw
	add	esp, 8
	mov	DWORD PTR _uri$[ebp], eax

; 310  :     if (uri == NULL)

	cmp	DWORD PTR _uri$[ebp], 0
	jne	SHORT $LN7@xmlNanoHTT

; 311  : 	return;

	jmp	$LN1@xmlNanoHTT
$LN7@xmlNanoHTT:

; 312  : 
; 313  :     if ((uri->scheme == NULL) || (uri->server == NULL)) {

	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN9@xmlNanoHTT
	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN8@xmlNanoHTT
$LN9@xmlNanoHTT:

; 314  : 	xmlFreeURI(uri);

	mov	ecx, DWORD PTR _uri$[ebp]
	push	ecx
	call	_xmlFreeURI
	add	esp, 4

; 315  : 	return;

	jmp	$LN1@xmlNanoHTT
$LN8@xmlNanoHTT:

; 316  :     }
; 317  : 
; 318  :     ctxt->protocol = xmlMemStrdup(uri->scheme);

	mov	esi, esp
	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax

; 319  :     /* special case of IPv6 addresses, the [] need to be removed */
; 320  :     if ((uri->server != NULL) && (*uri->server == '[')) {

	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	$LN10@xmlNanoHTT
	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 91					; 0000005bH
	jne	$LN10@xmlNanoHTT

; 321  :         len = strlen(uri->server);

	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR tv224[ebp], ecx
	mov	edx, DWORD PTR tv224[ebp]
	add	edx, 1
	mov	DWORD PTR tv227[ebp], edx
$LL19@xmlNanoHTT:
	mov	eax, DWORD PTR tv224[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv230[ebp], cl
	add	DWORD PTR tv224[ebp], 1
	cmp	BYTE PTR tv230[ebp], 0
	jne	SHORT $LL19@xmlNanoHTT
	mov	edx, DWORD PTR tv224[ebp]
	sub	edx, DWORD PTR tv227[ebp]
	mov	DWORD PTR tv139[ebp], edx
	mov	eax, DWORD PTR tv139[ebp]
	mov	DWORD PTR _len$[ebp], eax

; 322  : 	if ((len > 2) && (uri->server[len - 1] == ']')) {

	cmp	DWORD PTR _len$[ebp], 2
	jle	SHORT $LN12@xmlNanoHTT
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _len$[ebp]
	movsx	ecx, BYTE PTR [edx+eax-1]
	cmp	ecx, 93					; 0000005dH
	jne	SHORT $LN12@xmlNanoHTT

; 323  : 	    ctxt->hostname = (char *) xmlCharStrndup(uri->server + 1, len -2);

	mov	edx, DWORD PTR _len$[ebp]
	sub	edx, 2
	push	edx
	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	push	ecx
	call	_xmlCharStrndup
	add	esp, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], eax

; 324  : 	} else

	jmp	SHORT $LN13@xmlNanoHTT
$LN12@xmlNanoHTT:

; 325  : 	    ctxt->hostname = xmlMemStrdup(uri->server);

	mov	esi, esp
	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], eax
$LN13@xmlNanoHTT:

; 326  :     } else

	jmp	SHORT $LN11@xmlNanoHTT
$LN10@xmlNanoHTT:

; 327  : 	ctxt->hostname = xmlMemStrdup(uri->server);

	mov	esi, esp
	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], eax
$LN11@xmlNanoHTT:

; 328  :     if (uri->path != NULL)

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN14@xmlNanoHTT

; 329  : 	ctxt->path = xmlMemStrdup(uri->path);

	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN15@xmlNanoHTT
$LN14@xmlNanoHTT:

; 330  :     else
; 331  : 	ctxt->path = xmlMemStrdup("/");

	mov	esi, esp
	push	OFFSET ??_C@_01KMDKNFGN@?1@
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+12], eax
$LN15@xmlNanoHTT:

; 332  :     if (uri->query != NULL)

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN16@xmlNanoHTT

; 333  : 	ctxt->query = xmlMemStrdup(uri->query);

	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN16@xmlNanoHTT:

; 334  :     if (uri->port != 0)

	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN17@xmlNanoHTT

; 335  : 	ctxt->port = uri->port;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+8], edx
$LN17@xmlNanoHTT:

; 336  : 
; 337  :     xmlFreeURI(uri);

	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlFreeURI
	add	esp, 4
$LN1@xmlNanoHTT:

; 338  : }

	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPScanURL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _socket_errno
_TEXT	SEGMENT
tv65 = -8						; size = 4
_err$ = -4						; size = 4
_socket_errno PROC					; COMDAT

; 176  : static int socket_errno(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 177  : #ifdef _WINSOCKAPI_
; 178  :     int err = WSAGetLastError();

	mov	esi, esp
	call	DWORD PTR __imp__WSAGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$[ebp], eax

; 179  :     switch(err) {

	mov	eax, DWORD PTR _err$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 10004				; 00002714H
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 54			; 00000036H
	ja	SHORT $LN9@socket_err
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $LN11@socket_err[edx]
	jmp	DWORD PTR $LN12@socket_err[eax*4]
$LN4@socket_err:

; 180  :         case WSAECONNRESET:
; 181  :             return(ECONNRESET);

	mov	eax, 108				; 0000006cH
	jmp	SHORT $LN1@socket_err
$LN5@socket_err:

; 182  :         case WSAEINPROGRESS:
; 183  :             return(EINPROGRESS);

	mov	eax, 112				; 00000070H
	jmp	SHORT $LN1@socket_err
$LN6@socket_err:

; 184  :         case WSAEINTR:
; 185  :             return(EINTR);

	mov	eax, 4
	jmp	SHORT $LN1@socket_err
$LN7@socket_err:

; 186  :         case WSAESHUTDOWN:
; 187  :             return(ESHUTDOWN);

	mov	eax, 10058				; 0000274aH
	jmp	SHORT $LN1@socket_err
$LN8@socket_err:

; 188  :         case WSAEWOULDBLOCK:
; 189  :             return(EWOULDBLOCK);

	mov	eax, 140				; 0000008cH
	jmp	SHORT $LN1@socket_err
$LN9@socket_err:

; 190  :         default:
; 191  :             return(err);

	mov	eax, DWORD PTR _err$[ebp]
$LN1@socket_err:

; 192  :     }
; 193  : #else
; 194  :     return(errno);
; 195  : #endif
; 196  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN12@socket_err:
	DD	$LN6@socket_err
	DD	$LN8@socket_err
	DD	$LN5@socket_err
	DD	$LN4@socket_err
	DD	$LN7@socket_err
	DD	$LN9@socket_err
$LN11@socket_err:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	4
_socket_errno ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlHTTPErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlHTTPErrMemory PROC					; COMDAT

; 169  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 170  :     __xmlSimpleError(XML_FROM_HTTP, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	0
	push	0
	push	2
	push	10					; 0000000aH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 171  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlHTTPErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPFetchContent
_TEXT	SEGMENT
_dummy_ptr$ = -36					; size = 4
_dummy_int$ = -24					; size = 4
_rcvd_lgth$ = -16					; size = 4
_cur_lgth$ = -12					; size = 4
_rc$ = -8						; size = 4
_ctxt$ = -4						; size = 4
_ctx$ = 8						; size = 4
_ptr$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlNanoHTTPFetchContent PROC				; COMDAT

; 1822 : xmlNanoHTTPFetchContent( void * ctx, char ** ptr, int * len ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1823 :     xmlNanoHTTPCtxtPtr	ctxt = (xmlNanoHTTPCtxtPtr)ctx;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR _ctxt$[ebp], eax

; 1824 : 
; 1825 :     int			rc = 0;

	mov	DWORD PTR _rc$[ebp], 0

; 1826 :     int			cur_lgth;
; 1827 :     int			rcvd_lgth;
; 1828 :     int			dummy_int;
; 1829 :     char *		dummy_ptr = NULL;

	mov	DWORD PTR _dummy_ptr$[ebp], 0

; 1830 : 
; 1831 :     /*  Dummy up return input parameters if not provided  */
; 1832 : 
; 1833 :     if ( len == NULL )

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN4@xmlNanoHTT

; 1834 :         len = &dummy_int;

	lea	ecx, DWORD PTR _dummy_int$[ebp]
	mov	DWORD PTR _len$[ebp], ecx
$LN4@xmlNanoHTT:

; 1835 : 
; 1836 :     if ( ptr == NULL )

	cmp	DWORD PTR _ptr$[ebp], 0
	jne	SHORT $LN5@xmlNanoHTT

; 1837 :         ptr = &dummy_ptr;

	lea	edx, DWORD PTR _dummy_ptr$[ebp]
	mov	DWORD PTR _ptr$[ebp], edx
$LN5@xmlNanoHTT:

; 1838 : 
; 1839 :     /*  But can't work without the context pointer  */
; 1840 : 
; 1841 :     if ( ( ctxt == NULL ) || ( ctxt->content == NULL ) ) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN7@xmlNanoHTT
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN6@xmlNanoHTT
$LN7@xmlNanoHTT:

; 1842 :         *len = 0;

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [ecx], 0

; 1843 : 	*ptr = NULL;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [edx], 0

; 1844 : 	return ( -1 );

	or	eax, -1
	jmp	$LN1@xmlNanoHTT
$LN6@xmlNanoHTT:

; 1845 :     }
; 1846 : 
; 1847 :     rcvd_lgth = ctxt->inptr - ctxt->content;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax+44]
	sub	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _rcvd_lgth$[ebp], edx
$LN2@xmlNanoHTT:

; 1848 : 
; 1849 :     while ( (cur_lgth = xmlNanoHTTPRecv( ctxt )) > 0 ) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNanoHTTPRecv
	add	esp, 4
	mov	DWORD PTR _cur_lgth$[ebp], eax
	cmp	DWORD PTR _cur_lgth$[ebp], 0
	jle	SHORT $LN3@xmlNanoHTT

; 1850 : 
; 1851 : 	rcvd_lgth += cur_lgth;

	mov	ecx, DWORD PTR _rcvd_lgth$[ebp]
	add	ecx, DWORD PTR _cur_lgth$[ebp]
	mov	DWORD PTR _rcvd_lgth$[ebp], ecx

; 1852 : 	if ( (ctxt->ContentLength > 0) && (rcvd_lgth >= ctxt->ContentLength) )

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+68], 0
	jle	SHORT $LN8@xmlNanoHTT
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _rcvd_lgth$[ebp]
	cmp	ecx, DWORD PTR [eax+68]
	jl	SHORT $LN8@xmlNanoHTT

; 1853 : 	    break;

	jmp	SHORT $LN3@xmlNanoHTT
$LN8@xmlNanoHTT:

; 1854 :     }

	jmp	SHORT $LN2@xmlNanoHTT
$LN3@xmlNanoHTT:

; 1855 : 
; 1856 :     *ptr = ctxt->content;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx], ecx

; 1857 :     *len = rcvd_lgth;

	mov	edx, DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR _rcvd_lgth$[ebp]
	mov	DWORD PTR [edx], eax

; 1858 : 
; 1859 :     if ( ( ctxt->ContentLength > 0 ) && ( rcvd_lgth < ctxt->ContentLength ) )

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+68], 0
	jle	SHORT $LN9@xmlNanoHTT
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _rcvd_lgth$[ebp]
	cmp	eax, DWORD PTR [edx+68]
	jge	SHORT $LN9@xmlNanoHTT

; 1860 :         rc = -1;

	mov	DWORD PTR _rc$[ebp], -1
	jmp	SHORT $LN10@xmlNanoHTT
$LN9@xmlNanoHTT:

; 1861 :     else if ( rcvd_lgth == 0 )

	cmp	DWORD PTR _rcvd_lgth$[ebp], 0
	jne	SHORT $LN10@xmlNanoHTT

; 1862 : 	rc = -1;

	mov	DWORD PTR _rc$[ebp], -1
$LN10@xmlNanoHTT:

; 1863 : 
; 1864 :     return ( rc );

	mov	eax, DWORD PTR _rc$[ebp]
$LN1@xmlNanoHTT:

; 1865 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@xmlNanoHTT
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN16@xmlNanoHTT:
	DD	2
	DD	$LN15@xmlNanoHTT
$LN15@xmlNanoHTT:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN13@xmlNanoHTT
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN14@xmlNanoHTT
$LN14@xmlNanoHTT:
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	121					; 00000079H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN13@xmlNanoHTT:
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	121					; 00000079H
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
_xmlNanoHTTPFetchContent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPClose
_TEXT	SEGMENT
_ctxt$ = -4						; size = 4
_ctx$ = 8						; size = 4
_xmlNanoHTTPClose PROC					; COMDAT

; 1329 : xmlNanoHTTPClose(void *ctx) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1330 :     xmlNanoHTTPCtxtPtr ctxt = (xmlNanoHTTPCtxtPtr) ctx;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR _ctxt$[ebp], eax

; 1331 : 
; 1332 :     if (ctx == NULL) return;

	cmp	DWORD PTR _ctx$[ebp], 0
	jne	SHORT $LN2@xmlNanoHTT
	jmp	SHORT $LN1@xmlNanoHTT
$LN2@xmlNanoHTT:

; 1333 : 
; 1334 :     xmlNanoHTTPFreeCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNanoHTTPFreeCtxt
	add	esp, 4
$LN1@xmlNanoHTT:

; 1335 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPSave
_TEXT	SEGMENT
tv69 = -52						; size = 4
tv139 = -48						; size = 4
tv134 = -42						; size = 1
tv95 = -41						; size = 1
tv90 = -40						; size = 4
tv92 = -36						; size = 4
_ret$ = -32						; size = 4
_len$ = -24						; size = 4
_fd$ = -16						; size = 4
_buf$ = -8						; size = 4
_ctxt$ = 8						; size = 4
_filename$ = 12						; size = 4
_xmlNanoHTTPSave PROC					; COMDAT

; 1681 : xmlNanoHTTPSave(void *ctxt, const char *filename) {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1682 :     char *buf = NULL;

	mov	DWORD PTR _buf$[ebp], 0

; 1683 :     int fd;
; 1684 :     int len;
; 1685 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1686 : 
; 1687 :     if ((ctxt == NULL) || (filename == NULL)) return(-1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlNanoHTT
	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN2@xmlNanoHTT
$LN3@xmlNanoHTT:
	or	eax, -1
	jmp	$LN1@xmlNanoHTT
$LN2@xmlNanoHTT:

; 1688 : 
; 1689 :     if (!strcmp(filename, "-"))

	mov	DWORD PTR tv92[ebp], OFFSET ??_C@_01JOAMLHOP@?9@
	mov	eax, DWORD PTR _filename$[ebp]
	mov	DWORD PTR tv90[ebp], eax
$LL10@xmlNanoHTT:
	mov	ecx, DWORD PTR tv90[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv95[ebp], dl
	mov	eax, DWORD PTR tv92[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN11@xmlNanoHTT
	cmp	BYTE PTR tv95[ebp], 0
	je	SHORT $LN12@xmlNanoHTT
	mov	ecx, DWORD PTR tv90[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv134[ebp], dl
	mov	eax, DWORD PTR tv92[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN11@xmlNanoHTT
	add	DWORD PTR tv90[ebp], 2
	add	DWORD PTR tv92[ebp], 2
	cmp	BYTE PTR tv134[ebp], 0
	jne	SHORT $LL10@xmlNanoHTT
$LN12@xmlNanoHTT:
	mov	DWORD PTR tv139[ebp], 0
	jmp	SHORT $LN13@xmlNanoHTT
$LN11@xmlNanoHTT:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv139[ebp], ecx
$LN13@xmlNanoHTT:
	mov	edx, DWORD PTR tv139[ebp]
	mov	DWORD PTR tv69[ebp], edx
	cmp	DWORD PTR tv69[ebp], 0
	jne	SHORT $LN4@xmlNanoHTT

; 1690 :         fd = 0;

	mov	DWORD PTR _fd$[ebp], 0
	jmp	SHORT $LN5@xmlNanoHTT
$LN4@xmlNanoHTT:

; 1691 :     else {
; 1692 :         fd = open(filename, O_CREAT | O_WRONLY, 0666);

	mov	esi, esp
	push	438					; 000001b6H
	push	257					; 00000101H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	DWORD PTR __imp__open
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _fd$[ebp], eax

; 1693 : 	if (fd < 0) {

	cmp	DWORD PTR _fd$[ebp], 0
	jge	SHORT $LN5@xmlNanoHTT

; 1694 : 	    xmlNanoHTTPClose(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNanoHTTPClose
	add	esp, 4

; 1695 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlNanoHTT
$LN5@xmlNanoHTT:

; 1696 : 	}
; 1697 :     }
; 1698 : 
; 1699 :     xmlNanoHTTPFetchContent( ctxt, &buf, &len );

	lea	edx, DWORD PTR _len$[ebp]
	push	edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNanoHTTPFetchContent
	add	esp, 12					; 0000000cH

; 1700 :     if ( len > 0 ) {

	cmp	DWORD PTR _len$[ebp], 0
	jle	SHORT $LN7@xmlNanoHTT

; 1701 : 	if (write(fd, buf, len) == -1) {

	mov	esi, esp
	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	DWORD PTR __imp__write
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, -1
	jne	SHORT $LN7@xmlNanoHTT

; 1702 : 	    ret = -1;

	mov	DWORD PTR _ret$[ebp], -1
$LN7@xmlNanoHTT:

; 1703 : 	}
; 1704 :     }
; 1705 : 
; 1706 :     xmlNanoHTTPClose(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNanoHTTPClose
	add	esp, 4

; 1707 :     close(fd);

	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	call	DWORD PTR __imp__close
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1708 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlNanoHTT:

; 1709 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@xmlNanoHTT
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN17@xmlNanoHTT:
	DD	2
	DD	$LN16@xmlNanoHTT
$LN16@xmlNanoHTT:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN14@xmlNanoHTT
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN15@xmlNanoHTT
$LN15@xmlNanoHTT:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN14@xmlNanoHTT:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_xmlNanoHTTPSave ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPRead
_TEXT	SEGMENT
tv94 = -20						; size = 4
_z_ret$ = -16						; size = 4
_orig_avail_in$ = -12					; size = 4
_bytes_read$ = -8					; size = 4
_ctxt$ = -4						; size = 4
_ctx$ = 8						; size = 4
_dest$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlNanoHTTPRead PROC					; COMDAT

; 1274 : xmlNanoHTTPRead(void *ctx, void *dest, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1275 :     xmlNanoHTTPCtxtPtr ctxt = (xmlNanoHTTPCtxtPtr) ctx;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR _ctxt$[ebp], eax

; 1276 : #ifdef LIBXML_ZLIB_ENABLED
; 1277 :     int bytes_read = 0;

	mov	DWORD PTR _bytes_read$[ebp], 0

; 1278 :     int orig_avail_in;
; 1279 :     int z_ret;
; 1280 : #endif
; 1281 : 
; 1282 :     if (ctx == NULL) return(-1);

	cmp	DWORD PTR _ctx$[ebp], 0
	jne	SHORT $LN6@xmlNanoHTT
	or	eax, -1
	jmp	$LN1@xmlNanoHTT
$LN6@xmlNanoHTT:

; 1283 :     if (dest == NULL) return(-1);

	cmp	DWORD PTR _dest$[ebp], 0
	jne	SHORT $LN7@xmlNanoHTT
	or	eax, -1
	jmp	$LN1@xmlNanoHTT
$LN7@xmlNanoHTT:

; 1284 :     if (len <= 0) return(0);

	cmp	DWORD PTR _len$[ebp], 0
	jg	SHORT $LN8@xmlNanoHTT
	xor	eax, eax
	jmp	$LN1@xmlNanoHTT
$LN8@xmlNanoHTT:

; 1285 : 
; 1286 : #ifdef LIBXML_ZLIB_ENABLED
; 1287 :     if (ctxt->usesGzip == 1) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+96], 1
	jne	$LN4@xmlNanoHTT

; 1288 :         if (ctxt->strm == NULL) return(0);

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+92], 0
	jne	SHORT $LN10@xmlNanoHTT
	xor	eax, eax
	jmp	$LN1@xmlNanoHTT
$LN10@xmlNanoHTT:

; 1289 : 
; 1290 :         ctxt->strm->next_out = dest;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 1291 :         ctxt->strm->avail_out = len;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1292 : 	ctxt->strm->avail_in = ctxt->inptr - ctxt->inrptr;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax+44]
	sub	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR [ecx+4], edx
$LN2@xmlNanoHTT:

; 1293 : 
; 1294 :         while (ctxt->strm->avail_out > 0 &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+92]
	cmp	DWORD PTR [eax+16], 0
	jbe	$LN3@xmlNanoHTT
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	cmp	DWORD PTR [edx+4], 0
	ja	SHORT $LN11@xmlNanoHTT
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNanoHTTPRecv
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN3@xmlNanoHTT
$LN11@xmlNanoHTT:

; 1295 : 	       (ctxt->strm->avail_in > 0 || xmlNanoHTTPRecv(ctxt) > 0)) {
; 1296 :             orig_avail_in = ctxt->strm->avail_in =

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+44]
	sub	eax, DWORD PTR [edx+48]
	sub	eax, DWORD PTR _bytes_read$[ebp]
	mov	DWORD PTR tv94[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR tv94[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR tv94[ebp]
	mov	DWORD PTR _orig_avail_in$[ebp], ecx

; 1297 : 			    ctxt->inptr - ctxt->inrptr - bytes_read;
; 1298 :             ctxt->strm->next_in = BAD_CAST (ctxt->inrptr + bytes_read);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+48]
	add	eax, DWORD PTR _bytes_read$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [edx], eax

; 1299 : 
; 1300 :             z_ret = inflate(ctxt->strm, Z_NO_FLUSH);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	push	ecx
	call	_inflate@8
	mov	DWORD PTR _z_ret$[ebp], eax

; 1301 :             bytes_read += orig_avail_in - ctxt->strm->avail_in;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR _orig_avail_in$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _bytes_read$[ebp]
	mov	DWORD PTR _bytes_read$[ebp], ecx

; 1302 : 
; 1303 :             if (z_ret != Z_OK) break;

	cmp	DWORD PTR _z_ret$[ebp], 0
	je	SHORT $LN12@xmlNanoHTT
	jmp	SHORT $LN3@xmlNanoHTT
$LN12@xmlNanoHTT:

; 1304 : 	}

	jmp	$LN2@xmlNanoHTT
$LN3@xmlNanoHTT:

; 1305 : 
; 1306 :         ctxt->inrptr += bytes_read;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+48]
	add	eax, DWORD PTR _bytes_read$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 1307 :         return(len - ctxt->strm->avail_out);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, DWORD PTR [eax+16]
	mov	eax, ecx
	jmp	SHORT $LN1@xmlNanoHTT
$LN4@xmlNanoHTT:

; 1308 :     }
; 1309 : #endif
; 1310 : 
; 1311 :     while (ctxt->inptr - ctxt->inrptr < len) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	sub	ecx, DWORD PTR [eax+48]
	cmp	ecx, DWORD PTR _len$[ebp]
	jge	SHORT $LN5@xmlNanoHTT

; 1312 :         if (xmlNanoHTTPRecv(ctxt) <= 0) break;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNanoHTTPRecv
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN13@xmlNanoHTT
	jmp	SHORT $LN5@xmlNanoHTT
$LN13@xmlNanoHTT:

; 1313 :     }

	jmp	SHORT $LN4@xmlNanoHTT
$LN5@xmlNanoHTT:

; 1314 :     if (ctxt->inptr - ctxt->inrptr < len)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax+44]
	sub	edx, DWORD PTR [ecx+48]
	cmp	edx, DWORD PTR _len$[ebp]
	jge	SHORT $LN14@xmlNanoHTT

; 1315 :         len = ctxt->inptr - ctxt->inrptr;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax+44]
	sub	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR _len$[ebp], edx
$LN14@xmlNanoHTT:

; 1316 :     memcpy(dest, ctxt->inrptr, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1317 :     ctxt->inrptr += len;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	add	edx, DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+48], edx

; 1318 :     return(len);

	mov	eax, DWORD PTR _len$[ebp]
$LN1@xmlNanoHTT:

; 1319 : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPRead ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPMimeType
_TEXT	SEGMENT
tv66 = -8						; size = 4
_ctxt$ = -4						; size = 4
_ctx$ = 8						; size = 4
_xmlNanoHTTPMimeType PROC				; COMDAT

; 1803 : xmlNanoHTTPMimeType( void * ctx ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1804 :     xmlNanoHTTPCtxtPtr	ctxt = (xmlNanoHTTPCtxtPtr)ctx;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR _ctxt$[ebp], eax

; 1805 : 
; 1806 :     return ( ( ctxt == NULL ) ? NULL : ctxt->mimeType );

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN3@xmlNanoHTT
	mov	DWORD PTR tv66[ebp], 0
	jmp	SHORT $LN4@xmlNanoHTT
$LN3@xmlNanoHTT:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR tv66[ebp], edx
$LN4@xmlNanoHTT:
	mov	eax, DWORD PTR tv66[ebp]

; 1807 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPMimeType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPEncoding
_TEXT	SEGMENT
tv66 = -8						; size = 4
_ctxt$ = -4						; size = 4
_ctx$ = 8						; size = 4
_xmlNanoHTTPEncoding PROC				; COMDAT

; 1788 : xmlNanoHTTPEncoding( void * ctx ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1789 :     xmlNanoHTTPCtxtPtr	ctxt = (xmlNanoHTTPCtxtPtr)ctx;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR _ctxt$[ebp], eax

; 1790 : 
; 1791 :     return ( ( ctxt == NULL ) ? NULL : ctxt->encoding );

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN3@xmlNanoHTT
	mov	DWORD PTR tv66[ebp], 0
	jmp	SHORT $LN4@xmlNanoHTT
$LN3@xmlNanoHTT:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR tv66[ebp], edx
$LN4@xmlNanoHTT:
	mov	eax, DWORD PTR tv66[ebp]

; 1792 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPContentLength
_TEXT	SEGMENT
tv66 = -8						; size = 4
_ctxt$ = -4						; size = 4
_ctx$ = 8						; size = 4
_xmlNanoHTTPContentLength PROC				; COMDAT

; 1758 : xmlNanoHTTPContentLength( void * ctx ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1759 :     xmlNanoHTTPCtxtPtr	ctxt = (xmlNanoHTTPCtxtPtr)ctx;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR _ctxt$[ebp], eax

; 1760 : 
; 1761 :     return ( ( ctxt == NULL ) ? -1 : ctxt->ContentLength );

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN3@xmlNanoHTT
	mov	DWORD PTR tv66[ebp], -1
	jmp	SHORT $LN4@xmlNanoHTT
$LN3@xmlNanoHTT:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR tv66[ebp], edx
$LN4@xmlNanoHTT:
	mov	eax, DWORD PTR tv66[ebp]

; 1762 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPContentLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPRedir
_TEXT	SEGMENT
tv66 = -8						; size = 4
_ctxt$ = -4						; size = 4
_ctx$ = 8						; size = 4
_xmlNanoHTTPRedir PROC					; COMDAT

; 1773 : xmlNanoHTTPRedir( void * ctx ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1774 :     xmlNanoHTTPCtxtPtr	ctxt = (xmlNanoHTTPCtxtPtr)ctx;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR _ctxt$[ebp], eax

; 1775 : 
; 1776 :     return ( ( ctxt == NULL ) ? NULL : ctxt->location );

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN3@xmlNanoHTT
	mov	DWORD PTR tv66[ebp], 0
	jmp	SHORT $LN4@xmlNanoHTT
$LN3@xmlNanoHTT:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR tv66[ebp], edx
$LN4@xmlNanoHTT:
	mov	eax, DWORD PTR tv66[ebp]

; 1777 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPRedir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPAuthHeader
_TEXT	SEGMENT
_ctxt$ = -4						; size = 4
_ctx$ = 8						; size = 4
_xmlNanoHTTPAuthHeader PROC				; COMDAT

; 1739 : xmlNanoHTTPAuthHeader(void *ctx) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1740 :     xmlNanoHTTPCtxtPtr ctxt = (xmlNanoHTTPCtxtPtr) ctx;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR _ctxt$[ebp], eax

; 1741 : 
; 1742 :     if (ctxt == NULL) return(NULL);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlNanoHTT
	xor	eax, eax
	jmp	SHORT $LN1@xmlNanoHTT
$LN2@xmlNanoHTT:

; 1743 : 
; 1744 :     return(ctxt->authHeader);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+80]
$LN1@xmlNanoHTT:

; 1745 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPAuthHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPReturnCode
_TEXT	SEGMENT
_ctxt$ = -4						; size = 4
_ctx$ = 8						; size = 4
_xmlNanoHTTPReturnCode PROC				; COMDAT

; 1721 : xmlNanoHTTPReturnCode(void *ctx) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1722 :     xmlNanoHTTPCtxtPtr ctxt = (xmlNanoHTTPCtxtPtr) ctx;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR _ctxt$[ebp], eax

; 1723 : 
; 1724 :     if (ctxt == NULL) return(-1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlNanoHTT
	or	eax, -1
	jmp	SHORT $LN1@xmlNanoHTT
$LN2@xmlNanoHTT:

; 1725 : 
; 1726 :     return(ctxt->returnValue);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+60]
$LN1@xmlNanoHTT:

; 1727 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPReturnCode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPOpenRedir
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_contentType$ = 12					; size = 4
_redir$ = 16						; size = 4
_xmlNanoHTTPOpenRedir PROC				; COMDAT

; 1255 : xmlNanoHTTPOpenRedir(const char *URL, char **contentType, char **redir) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1256 :     if (contentType != NULL) *contentType = NULL;

	cmp	DWORD PTR _contentType$[ebp], 0
	je	SHORT $LN2@xmlNanoHTT
	mov	eax, DWORD PTR _contentType$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@xmlNanoHTT:

; 1257 :     if (redir != NULL) *redir = NULL;

	cmp	DWORD PTR _redir$[ebp], 0
	je	SHORT $LN3@xmlNanoHTT
	mov	ecx, DWORD PTR _redir$[ebp]
	mov	DWORD PTR [ecx], 0
$LN3@xmlNanoHTT:

; 1258 :     return(xmlNanoHTTPMethodRedir(URL, NULL, NULL, contentType, redir, NULL,0));

	push	0
	push	0
	mov	edx, DWORD PTR _redir$[ebp]
	push	edx
	mov	eax, DWORD PTR _contentType$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	call	_xmlNanoHTTPMethodRedir
	add	esp, 28					; 0000001cH

; 1259 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlNanoHTTPOpenRedir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPOpen
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_contentType$ = 12					; size = 4
_xmlNanoHTTPOpen PROC					; COMDAT

; 1235 : xmlNanoHTTPOpen(const char *URL, char **contentType) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1236 :     if (contentType != NULL) *contentType = NULL;

	cmp	DWORD PTR _contentType$[ebp], 0
	je	SHORT $LN2@xmlNanoHTT
	mov	eax, DWORD PTR _contentType$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@xmlNanoHTT:

; 1237 :     return(xmlNanoHTTPMethod(URL, NULL, NULL, contentType, NULL, 0));

	push	0
	push	0
	mov	ecx, DWORD PTR _contentType$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _URL$[ebp]
	push	edx
	call	_xmlNanoHTTPMethod
	add	esp, 24					; 00000018H

; 1238 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlNanoHTTPOpen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPMethodRedir
_TEXT	SEGMENT
tv314 = -176						; size = 4
tv620 = -169						; size = 1
tv617 = -168						; size = 4
tv614 = -164						; size = 4
tv183 = -160						; size = 4
tv517 = -153						; size = 1
tv514 = -152						; size = 4
tv511 = -148						; size = 4
tv179 = -144						; size = 4
tv505 = -137						; size = 1
tv502 = -136						; size = 4
tv499 = -132						; size = 4
tv174 = -128						; size = 4
tv492 = -121						; size = 1
tv489 = -120						; size = 4
tv486 = -116						; size = 4
tv166 = -112						; size = 4
tv477 = -105						; size = 1
tv474 = -104						; size = 4
tv471 = -100						; size = 4
tv159 = -96						; size = 4
tv462 = -89						; size = 1
tv459 = -88						; size = 4
tv456 = -84						; size = 4
tv143 = -80						; size = 4
tv437 = -73						; size = 1
tv434 = -72						; size = 4
tv431 = -68						; size = 4
tv134 = -64						; size = 4
tv421 = -57						; size = 1
tv418 = -56						; size = 4
tv415 = -52						; size = 4
tv82 = -48						; size = 4
tv398 = -44						; size = 4
tv393 = -38						; size = 1
tv386 = -37						; size = 1
tv381 = -36						; size = 4
tv383 = -32						; size = 4
_redirURL$ = -28					; size = 4
_nbRedirects$ = -24					; size = 4
_ret$ = -20						; size = 4
_blen$ = -16						; size = 4
_p$ = -12						; size = 4
_bp$ = -8						; size = 4
_ctxt$ = -4						; size = 4
_URL$ = 8						; size = 4
_method$ = 12						; size = 4
_input$ = 16						; size = 4
_contentType$ = 20					; size = 4
_redir$ = 24						; size = 4
_headers$ = 28						; size = 4
_ilen$ = 32						; size = 4
_xmlNanoHTTPMethodRedir PROC				; COMDAT

; 1358 : 		  const char *headers, int ilen ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-176]
	mov	ecx, 44					; 0000002cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1359 :     xmlNanoHTTPCtxtPtr ctxt;
; 1360 :     char *bp, *p;
; 1361 :     int blen;
; 1362 :     SOCKET ret;
; 1363 :     int nbRedirects = 0;

	mov	DWORD PTR _nbRedirects$[ebp], 0

; 1364 :     char *redirURL = NULL;

	mov	DWORD PTR _redirURL$[ebp], 0

; 1365 : #ifdef DEBUG_HTTP
; 1366 :     int xmt_bytes;
; 1367 : #endif
; 1368 : 
; 1369 :     if (URL == NULL) return(NULL);

	cmp	DWORD PTR _URL$[ebp], 0
	jne	SHORT $LN6@xmlNanoHTT
	xor	eax, eax
	jmp	$LN1@xmlNanoHTT
$LN6@xmlNanoHTT:

; 1370 :     if (method == NULL) method = "GET";

	cmp	DWORD PTR _method$[ebp], 0
	jne	SHORT $LN7@xmlNanoHTT
	mov	DWORD PTR _method$[ebp], OFFSET ??_C@_03HAPOJHBM@GET@
$LN7@xmlNanoHTT:

; 1371 :     xmlNanoHTTPInit();

	call	_xmlNanoHTTPInit
$retry$67:

; 1372 : 
; 1373 : retry:
; 1374 :     if (redirURL == NULL) {

	cmp	DWORD PTR _redirURL$[ebp], 0
	jne	SHORT $LN8@xmlNanoHTT

; 1375 : 	ctxt = xmlNanoHTTPNewCtxt(URL);

	mov	eax, DWORD PTR _URL$[ebp]
	push	eax
	call	_xmlNanoHTTPNewCtxt
	add	esp, 4
	mov	DWORD PTR _ctxt$[ebp], eax

; 1376 : 	if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN10@xmlNanoHTT

; 1377 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNanoHTT
$LN10@xmlNanoHTT:

; 1378 :     } else {

	jmp	SHORT $LN9@xmlNanoHTT
$LN8@xmlNanoHTT:

; 1379 : 	ctxt = xmlNanoHTTPNewCtxt(redirURL);

	mov	ecx, DWORD PTR _redirURL$[ebp]
	push	ecx
	call	_xmlNanoHTTPNewCtxt
	add	esp, 4
	mov	DWORD PTR _ctxt$[ebp], eax

; 1380 : 	if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN11@xmlNanoHTT

; 1381 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNanoHTT
$LN11@xmlNanoHTT:

; 1382 : 	ctxt->location = xmlMemStrdup(redirURL);

	mov	esi, esp
	mov	edx, DWORD PTR _redirURL$[ebp]
	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+76], eax
$LN9@xmlNanoHTT:

; 1383 :     }
; 1384 : 
; 1385 :     if ((ctxt->protocol == NULL) || (strcmp(ctxt->protocol, "http"))) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN13@xmlNanoHTT
	mov	DWORD PTR tv383[ebp], OFFSET ??_C@_04IAFLKNP@http@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv381[ebp], ecx
$LL55@xmlNanoHTT:
	mov	edx, DWORD PTR tv381[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv386[ebp], al
	mov	ecx, DWORD PTR tv383[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN56@xmlNanoHTT
	cmp	BYTE PTR tv386[ebp], 0
	je	SHORT $LN57@xmlNanoHTT
	mov	edx, DWORD PTR tv381[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv393[ebp], al
	mov	ecx, DWORD PTR tv383[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN56@xmlNanoHTT
	add	DWORD PTR tv381[ebp], 2
	add	DWORD PTR tv383[ebp], 2
	cmp	BYTE PTR tv393[ebp], 0
	jne	SHORT $LL55@xmlNanoHTT
$LN57@xmlNanoHTT:
	mov	DWORD PTR tv398[ebp], 0
	jmp	SHORT $LN58@xmlNanoHTT
$LN56@xmlNanoHTT:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv398[ebp], edx
$LN58@xmlNanoHTT:
	mov	eax, DWORD PTR tv398[ebp]
	mov	DWORD PTR tv82[ebp], eax
	cmp	DWORD PTR tv82[ebp], 0
	je	SHORT $LN12@xmlNanoHTT
$LN13@xmlNanoHTT:

; 1386 : 	__xmlIOErr(XML_FROM_HTTP, XML_HTTP_URL_SYNTAX, "Not a valid HTTP URI");

	push	OFFSET ??_C@_0BF@ECOHPMPM@Not?5a?5valid?5HTTP?5URI@
	push	2020					; 000007e4H
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1387 :         xmlNanoHTTPFreeCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNanoHTTPFreeCtxt
	add	esp, 4

; 1388 : 	if (redirURL != NULL) xmlFree(redirURL);

	cmp	DWORD PTR _redirURL$[ebp], 0
	je	SHORT $LN14@xmlNanoHTT
	mov	esi, esp
	mov	edx, DWORD PTR _redirURL$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@xmlNanoHTT:

; 1389 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNanoHTT
$LN12@xmlNanoHTT:

; 1390 :     }
; 1391 :     if (ctxt->hostname == NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN15@xmlNanoHTT

; 1392 : 	__xmlIOErr(XML_FROM_HTTP, XML_HTTP_UNKNOWN_HOST,

	push	OFFSET ??_C@_0BP@DMGJEOPF@Failed?5to?5identify?5host?5in?5URI@
	push	2022					; 000007e6H
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1393 : 	           "Failed to identify host in URI");
; 1394 :         xmlNanoHTTPFreeCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNanoHTTPFreeCtxt
	add	esp, 4

; 1395 : 	if (redirURL != NULL) xmlFree(redirURL);

	cmp	DWORD PTR _redirURL$[ebp], 0
	je	SHORT $LN16@xmlNanoHTT
	mov	esi, esp
	mov	edx, DWORD PTR _redirURL$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@xmlNanoHTT:

; 1396 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNanoHTT
$LN15@xmlNanoHTT:

; 1397 :     }
; 1398 :     if (proxy) {

	cmp	DWORD PTR _proxy, 0
	je	SHORT $LN17@xmlNanoHTT

; 1399 : 	blen = strlen(ctxt->hostname) * 2 + 16;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv415[ebp], ecx
	mov	edx, DWORD PTR tv415[ebp]
	add	edx, 1
	mov	DWORD PTR tv418[ebp], edx
$LL59@xmlNanoHTT:
	mov	eax, DWORD PTR tv415[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv421[ebp], cl
	add	DWORD PTR tv415[ebp], 1
	cmp	BYTE PTR tv421[ebp], 0
	jne	SHORT $LL59@xmlNanoHTT
	mov	edx, DWORD PTR tv415[ebp]
	sub	edx, DWORD PTR tv418[ebp]
	mov	DWORD PTR tv134[ebp], edx
	mov	eax, DWORD PTR tv134[ebp]
	lea	ecx, DWORD PTR [eax+eax+16]
	mov	DWORD PTR _blen$[ebp], ecx

; 1400 : 	ret = xmlNanoHTTPConnectHost(proxy, proxyPort);

	mov	edx, DWORD PTR _proxyPort
	push	edx
	mov	eax, DWORD PTR _proxy
	push	eax
	call	_xmlNanoHTTPConnectHost
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1401 :     }

	jmp	SHORT $LN18@xmlNanoHTT
$LN17@xmlNanoHTT:

; 1402 :     else {
; 1403 : 	blen = strlen(ctxt->hostname);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv431[ebp], edx
	mov	eax, DWORD PTR tv431[ebp]
	add	eax, 1
	mov	DWORD PTR tv434[ebp], eax
$LL60@xmlNanoHTT:
	mov	ecx, DWORD PTR tv431[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv437[ebp], dl
	add	DWORD PTR tv431[ebp], 1
	cmp	BYTE PTR tv437[ebp], 0
	jne	SHORT $LL60@xmlNanoHTT
	mov	eax, DWORD PTR tv431[ebp]
	sub	eax, DWORD PTR tv434[ebp]
	mov	DWORD PTR tv143[ebp], eax
	mov	ecx, DWORD PTR tv143[ebp]
	mov	DWORD PTR _blen$[ebp], ecx

; 1404 : 	ret = xmlNanoHTTPConnectHost(ctxt->hostname, ctxt->port);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlNanoHTTPConnectHost
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
$LN18@xmlNanoHTT:

; 1405 :     }
; 1406 :     if (ret == INVALID_SOCKET) {

	cmp	DWORD PTR _ret$[ebp], -1
	jne	SHORT $LN19@xmlNanoHTT

; 1407 :         xmlNanoHTTPFreeCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNanoHTTPFreeCtxt
	add	esp, 4

; 1408 : 	if (redirURL != NULL) xmlFree(redirURL);

	cmp	DWORD PTR _redirURL$[ebp], 0
	je	SHORT $LN20@xmlNanoHTT
	mov	esi, esp
	mov	ecx, DWORD PTR _redirURL$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN20@xmlNanoHTT:

; 1409 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNanoHTT
$LN19@xmlNanoHTT:

; 1410 :     }
; 1411 :     ctxt->fd = ret;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+20], eax

; 1412 : 
; 1413 :     if (input == NULL)

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN21@xmlNanoHTT

; 1414 : 	ilen = 0;

	mov	DWORD PTR _ilen$[ebp], 0
	jmp	SHORT $LN22@xmlNanoHTT
$LN21@xmlNanoHTT:

; 1415 :     else
; 1416 : 	blen += 36;

	mov	ecx, DWORD PTR _blen$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR _blen$[ebp], ecx
$LN22@xmlNanoHTT:

; 1417 : 
; 1418 :     if (headers != NULL)

	cmp	DWORD PTR _headers$[ebp], 0
	je	SHORT $LN23@xmlNanoHTT

; 1419 : 	blen += strlen(headers) + 2;

	mov	edx, DWORD PTR _headers$[ebp]
	mov	DWORD PTR tv456[ebp], edx
	mov	eax, DWORD PTR tv456[ebp]
	add	eax, 1
	mov	DWORD PTR tv459[ebp], eax
$LL61@xmlNanoHTT:
	mov	ecx, DWORD PTR tv456[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv462[ebp], dl
	add	DWORD PTR tv456[ebp], 1
	cmp	BYTE PTR tv462[ebp], 0
	jne	SHORT $LL61@xmlNanoHTT
	mov	eax, DWORD PTR tv456[ebp]
	sub	eax, DWORD PTR tv459[ebp]
	mov	DWORD PTR tv159[ebp], eax
	mov	ecx, DWORD PTR tv159[ebp]
	mov	edx, DWORD PTR _blen$[ebp]
	lea	eax, DWORD PTR [edx+ecx+2]
	mov	DWORD PTR _blen$[ebp], eax
$LN23@xmlNanoHTT:

; 1420 :     if (contentType && *contentType)

	cmp	DWORD PTR _contentType$[ebp], 0
	je	SHORT $LN24@xmlNanoHTT
	mov	ecx, DWORD PTR _contentType$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN24@xmlNanoHTT

; 1421 : 	/* reserve for string plus 'Content-Type: \r\n" */
; 1422 : 	blen += strlen(*contentType) + 16;

	mov	edx, DWORD PTR _contentType$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv471[ebp], eax
	mov	ecx, DWORD PTR tv471[ebp]
	add	ecx, 1
	mov	DWORD PTR tv474[ebp], ecx
$LL62@xmlNanoHTT:
	mov	edx, DWORD PTR tv471[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv477[ebp], al
	add	DWORD PTR tv471[ebp], 1
	cmp	BYTE PTR tv477[ebp], 0
	jne	SHORT $LL62@xmlNanoHTT
	mov	ecx, DWORD PTR tv471[ebp]
	sub	ecx, DWORD PTR tv474[ebp]
	mov	DWORD PTR tv166[ebp], ecx
	mov	edx, DWORD PTR tv166[ebp]
	mov	eax, DWORD PTR _blen$[ebp]
	lea	ecx, DWORD PTR [eax+edx+16]
	mov	DWORD PTR _blen$[ebp], ecx
$LN24@xmlNanoHTT:

; 1423 :     if (ctxt->query != NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN25@xmlNanoHTT

; 1424 : 	/* 1 for '?' */
; 1425 : 	blen += strlen(ctxt->query) + 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv486[ebp], ecx
	mov	edx, DWORD PTR tv486[ebp]
	add	edx, 1
	mov	DWORD PTR tv489[ebp], edx
$LL63@xmlNanoHTT:
	mov	eax, DWORD PTR tv486[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv492[ebp], cl
	add	DWORD PTR tv486[ebp], 1
	cmp	BYTE PTR tv492[ebp], 0
	jne	SHORT $LL63@xmlNanoHTT
	mov	edx, DWORD PTR tv486[ebp]
	sub	edx, DWORD PTR tv489[ebp]
	mov	DWORD PTR tv174[ebp], edx
	mov	eax, DWORD PTR tv174[ebp]
	mov	ecx, DWORD PTR _blen$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _blen$[ebp], edx
$LN25@xmlNanoHTT:

; 1426 :     blen += strlen(method) + strlen(ctxt->path) + 24;

	mov	eax, DWORD PTR _method$[ebp]
	mov	DWORD PTR tv499[ebp], eax
	mov	ecx, DWORD PTR tv499[ebp]
	add	ecx, 1
	mov	DWORD PTR tv502[ebp], ecx
$LL64@xmlNanoHTT:
	mov	edx, DWORD PTR tv499[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv505[ebp], al
	add	DWORD PTR tv499[ebp], 1
	cmp	BYTE PTR tv505[ebp], 0
	jne	SHORT $LL64@xmlNanoHTT
	mov	ecx, DWORD PTR tv499[ebp]
	sub	ecx, DWORD PTR tv502[ebp]
	mov	DWORD PTR tv179[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv511[ebp], eax
	mov	ecx, DWORD PTR tv511[ebp]
	add	ecx, 1
	mov	DWORD PTR tv514[ebp], ecx
$LL65@xmlNanoHTT:
	mov	edx, DWORD PTR tv511[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv517[ebp], al
	add	DWORD PTR tv511[ebp], 1
	cmp	BYTE PTR tv517[ebp], 0
	jne	SHORT $LL65@xmlNanoHTT
	mov	ecx, DWORD PTR tv511[ebp]
	sub	ecx, DWORD PTR tv514[ebp]
	mov	DWORD PTR tv183[ebp], ecx
	mov	edx, DWORD PTR tv179[ebp]
	add	edx, DWORD PTR tv183[ebp]
	mov	eax, DWORD PTR _blen$[ebp]
	lea	ecx, DWORD PTR [eax+edx+24]
	mov	DWORD PTR _blen$[ebp], ecx

; 1427 : #ifdef LIBXML_ZLIB_ENABLED
; 1428 :     /* reserve for possible 'Accept-Encoding: gzip' string */
; 1429 :     blen += 23;

	mov	edx, DWORD PTR _blen$[ebp]
	add	edx, 23					; 00000017H
	mov	DWORD PTR _blen$[ebp], edx

; 1430 : #endif
; 1431 :     if (ctxt->port != 80) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 80			; 00000050H
	je	SHORT $LN26@xmlNanoHTT

; 1432 : 	/* reserve space for ':xxxxx', incl. potential proxy */
; 1433 : 	if (proxy)

	cmp	DWORD PTR _proxy, 0
	je	SHORT $LN27@xmlNanoHTT

; 1434 : 	    blen += 17;

	mov	ecx, DWORD PTR _blen$[ebp]
	add	ecx, 17					; 00000011H
	mov	DWORD PTR _blen$[ebp], ecx
	jmp	SHORT $LN26@xmlNanoHTT
$LN27@xmlNanoHTT:

; 1435 : 	else
; 1436 : 	    blen += 11;

	mov	edx, DWORD PTR _blen$[ebp]
	add	edx, 11					; 0000000bH
	mov	DWORD PTR _blen$[ebp], edx
$LN26@xmlNanoHTT:

; 1437 :     }
; 1438 :     bp = (char*)xmlMallocAtomic(blen);

	mov	esi, esp
	mov	eax, DWORD PTR _blen$[ebp]
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bp$[ebp], eax

; 1439 :     if ( bp == NULL ) {

	cmp	DWORD PTR _bp$[ebp], 0
	jne	SHORT $LN29@xmlNanoHTT

; 1440 :         xmlNanoHTTPFreeCtxt( ctxt );

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNanoHTTPFreeCtxt
	add	esp, 4

; 1441 : 	xmlHTTPErrMemory("allocating header buffer");

	push	OFFSET ??_C@_0BJ@BDBNHHKN@allocating?5header?5buffer@
	call	_xmlHTTPErrMemory
	add	esp, 4

; 1442 : 	return ( NULL );

	xor	eax, eax
	jmp	$LN1@xmlNanoHTT
$LN29@xmlNanoHTT:

; 1443 :     }
; 1444 : 
; 1445 :     p = bp;

	mov	edx, DWORD PTR _bp$[ebp]
	mov	DWORD PTR _p$[ebp], edx

; 1446 : 
; 1447 :     if (proxy) {

	cmp	DWORD PTR _proxy, 0
	je	SHORT $LN30@xmlNanoHTT

; 1448 : 	if (ctxt->port != 80) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 80			; 00000050H
	je	SHORT $LN32@xmlNanoHTT

; 1449 : 	    p += snprintf( p, blen - (p - bp), "%s http://%s:%d%s",

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _method$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BC@EGOHMPNF@?$CFs?5http?3?1?1?$CFs?3?$CFd?$CFs@
	mov	edx, DWORD PTR _p$[ebp]
	sub	edx, DWORD PTR _bp$[ebp]
	mov	eax, DWORD PTR _blen$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_snprintf
	add	esp, 28					; 0000001cH
	add	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 1450 : 			method, ctxt->hostname,
; 1451 : 			ctxt->port, ctxt->path );
; 1452 : 	}

	jmp	SHORT $LN33@xmlNanoHTT
$LN32@xmlNanoHTT:

; 1453 : 	else
; 1454 : 	    p += snprintf( p, blen - (p - bp), "%s http://%s%s", method,

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _method$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@EIIHMMMN@?$CFs?5http?3?1?1?$CFs?$CFs@
	mov	ecx, DWORD PTR _p$[ebp]
	sub	ecx, DWORD PTR _bp$[ebp]
	mov	edx, DWORD PTR _blen$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_snprintf
	add	esp, 24					; 00000018H
	add	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN33@xmlNanoHTT:

; 1455 : 			ctxt->hostname, ctxt->path);
; 1456 :     }

	jmp	SHORT $LN31@xmlNanoHTT
$LN30@xmlNanoHTT:

; 1457 :     else
; 1458 : 	p += snprintf( p, blen - (p - bp), "%s %s", method, ctxt->path);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _method$[ebp]
	push	eax
	push	OFFSET ??_C@_05DNIIFBMG@?$CFs?5?$CFs@
	mov	ecx, DWORD PTR _p$[ebp]
	sub	ecx, DWORD PTR _bp$[ebp]
	mov	edx, DWORD PTR _blen$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H
	add	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN31@xmlNanoHTT:

; 1459 : 
; 1460 :     if (ctxt->query != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN34@xmlNanoHTT

; 1461 : 	p += snprintf( p, blen - (p - bp), "?%s", ctxt->query);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	OFFSET ??_C@_03EMGHGGCK@?$DP?$CFs@
	mov	ecx, DWORD PTR _p$[ebp]
	sub	ecx, DWORD PTR _bp$[ebp]
	mov	edx, DWORD PTR _blen$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN34@xmlNanoHTT:

; 1462 : 
; 1463 :     if (ctxt->port == 80) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+8], 80			; 00000050H
	jne	SHORT $LN35@xmlNanoHTT

; 1464 :         p += snprintf( p, blen - (p - bp), " HTTP/1.0\r\nHost: %s\r\n",

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET ??_C@_0BG@EGNPFNEM@?5HTTP?11?40?$AN?6Host?3?5?$CFs?$AN?6@
	mov	ecx, DWORD PTR _p$[ebp]
	sub	ecx, DWORD PTR _bp$[ebp]
	mov	edx, DWORD PTR _blen$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 1465 : 		    ctxt->hostname);
; 1466 :     } else {

	jmp	SHORT $LN36@xmlNanoHTT
$LN35@xmlNanoHTT:

; 1467 :         p += snprintf( p, blen - (p - bp), " HTTP/1.0\r\nHost: %s:%d\r\n",

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ??_C@_0BJ@HMGEAMPD@?5HTTP?11?40?$AN?6Host?3?5?$CFs?3?$CFd?$AN?6@
	mov	edx, DWORD PTR _p$[ebp]
	sub	edx, DWORD PTR _bp$[ebp]
	mov	eax, DWORD PTR _blen$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_snprintf
	add	esp, 20					; 00000014H
	add	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN36@xmlNanoHTT:

; 1468 : 		    ctxt->hostname, ctxt->port);
; 1469 :     }
; 1470 : 
; 1471 : #ifdef LIBXML_ZLIB_ENABLED
; 1472 :     p += snprintf(p, blen - (p - bp), "Accept-Encoding: gzip\r\n");

	push	OFFSET ??_C@_0BI@DHMFONHP@Accept?9Encoding?3?5gzip?$AN?6@
	mov	edx, DWORD PTR _p$[ebp]
	sub	edx, DWORD PTR _bp$[ebp]
	mov	eax, DWORD PTR _blen$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_snprintf
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 1473 : #endif
; 1474 : 
; 1475 :     if (contentType != NULL && *contentType)

	cmp	DWORD PTR _contentType$[ebp], 0
	je	SHORT $LN37@xmlNanoHTT
	mov	edx, DWORD PTR _contentType$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN37@xmlNanoHTT

; 1476 : 	p += snprintf(p, blen - (p - bp), "Content-Type: %s\r\n", *contentType);

	mov	eax, DWORD PTR _contentType$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0BD@KBHMLOB@Content?9Type?3?5?$CFs?$AN?6@
	mov	edx, DWORD PTR _p$[ebp]
	sub	edx, DWORD PTR _bp$[ebp]
	mov	eax, DWORD PTR _blen$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_snprintf
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN37@xmlNanoHTT:

; 1477 : 
; 1478 :     if (headers != NULL)

	cmp	DWORD PTR _headers$[ebp], 0
	je	SHORT $LN38@xmlNanoHTT

; 1479 : 	p += snprintf( p, blen - (p - bp), "%s", headers );

	mov	edx, DWORD PTR _headers$[ebp]
	push	edx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	mov	eax, DWORD PTR _p$[ebp]
	sub	eax, DWORD PTR _bp$[ebp]
	mov	ecx, DWORD PTR _blen$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_snprintf
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN38@xmlNanoHTT:

; 1480 : 
; 1481 :     if (input != NULL)

	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN39@xmlNanoHTT

; 1482 : 	snprintf(p, blen - (p - bp), "Content-Length: %d\r\n\r\n", ilen );

	mov	eax, DWORD PTR _ilen$[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@HJCMLCON@Content?9Length?3?5?$CFd?$AN?6?$AN?6@
	mov	ecx, DWORD PTR _p$[ebp]
	sub	ecx, DWORD PTR _bp$[ebp]
	mov	edx, DWORD PTR _blen$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN40@xmlNanoHTT
$LN39@xmlNanoHTT:

; 1483 :     else
; 1484 : 	snprintf(p, blen - (p - bp), "\r\n");

	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6@
	mov	ecx, DWORD PTR _p$[ebp]
	sub	ecx, DWORD PTR _bp$[ebp]
	mov	edx, DWORD PTR _blen$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_snprintf
	add	esp, 12					; 0000000cH
$LN40@xmlNanoHTT:

; 1485 : 
; 1486 : #ifdef DEBUG_HTTP
; 1487 :     xmlGenericError(xmlGenericErrorContext,
; 1488 : 	    "-> %s%s", proxy? "(Proxy) " : "", bp);
; 1489 :     if ((blen -= strlen(bp)+1) < 0)
; 1490 : 	xmlGenericError(xmlGenericErrorContext,
; 1491 : 		"ERROR: overflowed buffer by %d bytes\n", -blen);
; 1492 : #endif
; 1493 :     ctxt->outptr = ctxt->out = bp;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _bp$[ebp]
	mov	DWORD PTR [ecx+28], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _bp$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 1494 :     ctxt->state = XML_NANO_HTTP_WRITE;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+24], 1

; 1495 :     blen = strlen( ctxt->out );

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR tv614[ebp], ecx
	mov	edx, DWORD PTR tv614[ebp]
	add	edx, 1
	mov	DWORD PTR tv617[ebp], edx
$LL66@xmlNanoHTT:
	mov	eax, DWORD PTR tv614[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv620[ebp], cl
	add	DWORD PTR tv614[ebp], 1
	cmp	BYTE PTR tv620[ebp], 0
	jne	SHORT $LL66@xmlNanoHTT
	mov	edx, DWORD PTR tv614[ebp]
	sub	edx, DWORD PTR tv617[ebp]
	mov	DWORD PTR tv314[ebp], edx
	mov	eax, DWORD PTR tv314[ebp]
	mov	DWORD PTR _blen$[ebp], eax

; 1496 : #ifdef DEBUG_HTTP
; 1497 :     xmt_bytes = xmlNanoHTTPSend(ctxt, ctxt->out, blen );
; 1498 :     if ( xmt_bytes != blen )
; 1499 :         xmlGenericError( xmlGenericErrorContext,
; 1500 : 			"xmlNanoHTTPMethodRedir:  Only %d of %d %s %s\n",
; 1501 : 			xmt_bytes, blen,
; 1502 : 			"bytes of HTTP headers sent to host",
; 1503 : 			ctxt->hostname );
; 1504 : #else
; 1505 :     xmlNanoHTTPSend(ctxt, ctxt->out, blen );

	mov	ecx, DWORD PTR _blen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNanoHTTPSend
	add	esp, 12					; 0000000cH

; 1506 : #endif
; 1507 : 
; 1508 :     if ( input != NULL ) {

	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN41@xmlNanoHTT

; 1509 : #ifdef DEBUG_HTTP
; 1510 :         xmt_bytes = xmlNanoHTTPSend( ctxt, input, ilen );
; 1511 : 
; 1512 : 	if ( xmt_bytes != ilen )
; 1513 : 	    xmlGenericError( xmlGenericErrorContext,
; 1514 : 			"xmlNanoHTTPMethodRedir:  Only %d of %d %s %s\n",
; 1515 : 			xmt_bytes, ilen,
; 1516 : 			"bytes of HTTP content sent to host",
; 1517 : 			ctxt->hostname );
; 1518 : #else
; 1519 : 	xmlNanoHTTPSend( ctxt, input, ilen );

	mov	edx, DWORD PTR _ilen$[ebp]
	push	edx
	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNanoHTTPSend
	add	esp, 12					; 0000000cH
$LN41@xmlNanoHTT:

; 1520 : #endif
; 1521 :     }
; 1522 : 
; 1523 :     ctxt->state = XML_NANO_HTTP_READ;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+24], 2
$LN2@xmlNanoHTT:

; 1524 : 
; 1525 :     while ((p = xmlNanoHTTPReadLine(ctxt)) != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNanoHTTPReadLine
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@xmlNanoHTT

; 1526 :         if (*p == 0) {

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN42@xmlNanoHTT

; 1527 : 	    ctxt->content = ctxt->inrptr;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+40], edx

; 1528 : 	    xmlFree(p);

	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1529 : 	    break;

	jmp	SHORT $LN3@xmlNanoHTT
$LN42@xmlNanoHTT:

; 1530 : 	}
; 1531 : 	xmlNanoHTTPScanAnswer(ctxt, p);

	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNanoHTTPScanAnswer
	add	esp, 8

; 1532 : 
; 1533 : #ifdef DEBUG_HTTP
; 1534 : 	xmlGenericError(xmlGenericErrorContext, "<- %s\n", p);
; 1535 : #endif
; 1536 :         xmlFree(p);

	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1537 :     }

	jmp	SHORT $LN2@xmlNanoHTT
$LN3@xmlNanoHTT:

; 1538 : 
; 1539 :     if ((ctxt->location != NULL) && (ctxt->returnValue >= 300) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+76], 0
	je	$LN43@xmlNanoHTT
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+60], 300			; 0000012cH
	jl	$LN43@xmlNanoHTT
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+60], 400			; 00000190H
	jge	$LN43@xmlNanoHTT
$LN4@xmlNanoHTT:

; 1540 :         (ctxt->returnValue < 400)) {
; 1541 : #ifdef DEBUG_HTTP
; 1542 : 	xmlGenericError(xmlGenericErrorContext,
; 1543 : 		"\nRedirect to: %s\n", ctxt->location);
; 1544 : #endif
; 1545 : 	while ( xmlNanoHTTPRecv(ctxt) > 0 )

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNanoHTTPRecv
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN5@xmlNanoHTT

; 1546 :             ;

	jmp	SHORT $LN4@xmlNanoHTT
$LN5@xmlNanoHTT:

; 1547 :         if (nbRedirects < XML_NANO_HTTP_MAX_REDIR) {

	cmp	DWORD PTR _nbRedirects$[ebp], 10	; 0000000aH
	jge	SHORT $LN44@xmlNanoHTT

; 1548 : 	    nbRedirects++;

	mov	edx, DWORD PTR _nbRedirects$[ebp]
	add	edx, 1
	mov	DWORD PTR _nbRedirects$[ebp], edx

; 1549 : 	    if (redirURL != NULL)

	cmp	DWORD PTR _redirURL$[ebp], 0
	je	SHORT $LN45@xmlNanoHTT

; 1550 : 		xmlFree(redirURL);

	mov	esi, esp
	mov	eax, DWORD PTR _redirURL$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN45@xmlNanoHTT:

; 1551 : 	    redirURL = xmlMemStrdup(ctxt->location);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _redirURL$[ebp], eax

; 1552 : 	    xmlNanoHTTPFreeCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNanoHTTPFreeCtxt
	add	esp, 4

; 1553 : 	    goto retry;

	jmp	$retry$67
$LN44@xmlNanoHTT:

; 1554 : 	}
; 1555 : 	xmlNanoHTTPFreeCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNanoHTTPFreeCtxt
	add	esp, 4

; 1556 : 	if (redirURL != NULL) xmlFree(redirURL);

	cmp	DWORD PTR _redirURL$[ebp], 0
	je	SHORT $LN46@xmlNanoHTT
	mov	esi, esp
	mov	edx, DWORD PTR _redirURL$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN46@xmlNanoHTT:

; 1557 : #ifdef DEBUG_HTTP
; 1558 : 	xmlGenericError(xmlGenericErrorContext,
; 1559 : 		"xmlNanoHTTPMethodRedir: Too many redirects, aborting ...\n");
; 1560 : #endif
; 1561 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNanoHTT
$LN43@xmlNanoHTT:

; 1562 :     }
; 1563 : 
; 1564 :     if (contentType != NULL) {

	cmp	DWORD PTR _contentType$[ebp], 0
	je	SHORT $LN47@xmlNanoHTT

; 1565 : 	if (ctxt->contentType != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+72], 0
	je	SHORT $LN48@xmlNanoHTT

; 1566 : 	    *contentType = xmlMemStrdup(ctxt->contentType);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _contentType$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN47@xmlNanoHTT
$LN48@xmlNanoHTT:

; 1567 : 	else
; 1568 : 	    *contentType = NULL;

	mov	edx, DWORD PTR _contentType$[ebp]
	mov	DWORD PTR [edx], 0
$LN47@xmlNanoHTT:

; 1569 :     }
; 1570 : 
; 1571 :     if ((redir != NULL) && (redirURL != NULL)) {

	cmp	DWORD PTR _redir$[ebp], 0
	je	SHORT $LN50@xmlNanoHTT
	cmp	DWORD PTR _redirURL$[ebp], 0
	je	SHORT $LN50@xmlNanoHTT

; 1572 : 	*redir = redirURL;

	mov	eax, DWORD PTR _redir$[ebp]
	mov	ecx, DWORD PTR _redirURL$[ebp]
	mov	DWORD PTR [eax], ecx

; 1573 :     } else {

	jmp	SHORT $LN51@xmlNanoHTT
$LN50@xmlNanoHTT:

; 1574 : 	if (redirURL != NULL)

	cmp	DWORD PTR _redirURL$[ebp], 0
	je	SHORT $LN52@xmlNanoHTT

; 1575 : 	    xmlFree(redirURL);

	mov	esi, esp
	mov	edx, DWORD PTR _redirURL$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN52@xmlNanoHTT:

; 1576 : 	if (redir != NULL)

	cmp	DWORD PTR _redir$[ebp], 0
	je	SHORT $LN51@xmlNanoHTT

; 1577 : 	    *redir = NULL;

	mov	eax, DWORD PTR _redir$[ebp]
	mov	DWORD PTR [eax], 0
$LN51@xmlNanoHTT:

; 1578 :     }
; 1579 : 
; 1580 : #ifdef DEBUG_HTTP
; 1581 :     if (ctxt->contentType != NULL)
; 1582 : 	xmlGenericError(xmlGenericErrorContext,
; 1583 : 		"\nCode %d, content-type '%s'\n\n",
; 1584 : 	       ctxt->returnValue, ctxt->contentType);
; 1585 :     else
; 1586 : 	xmlGenericError(xmlGenericErrorContext,
; 1587 : 		"\nCode %d, no content-type\n\n",
; 1588 : 	       ctxt->returnValue);
; 1589 : #endif
; 1590 : 
; 1591 :     return((void *) ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
$LN1@xmlNanoHTT:

; 1592 : }

	pop	edi
	pop	esi
	add	esp, 176				; 000000b0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPMethodRedir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPMethod
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_method$ = 12						; size = 4
_input$ = 16						; size = 4
_contentType$ = 20					; size = 4
_headers$ = 24						; size = 4
_ilen$ = 28						; size = 4
_xmlNanoHTTPMethod PROC					; COMDAT

; 1613 :                   char **contentType, const char *headers, int ilen) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1614 :     return(xmlNanoHTTPMethodRedir(URL, method, input, contentType,

	mov	eax, DWORD PTR _ilen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _headers$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _contentType$[ebp]
	push	edx
	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	mov	ecx, DWORD PTR _method$[ebp]
	push	ecx
	mov	edx, DWORD PTR _URL$[ebp]
	push	edx
	call	_xmlNanoHTTPMethodRedir
	add	esp, 28					; 0000001cH

; 1615 : 		                  NULL, headers, ilen));
; 1616 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlNanoHTTPMethod ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPFetch
_TEXT	SEGMENT
tv72 = -56						; size = 4
tv149 = -52						; size = 4
tv144 = -46						; size = 1
tv137 = -45						; size = 1
tv132 = -44						; size = 4
tv134 = -40						; size = 4
_ret$ = -36						; size = 4
_len$ = -28						; size = 4
_fd$ = -20						; size = 4
_buf$ = -12						; size = 4
_ctxt$ = -4						; size = 4
_URL$ = 8						; size = 4
_filename$ = 12						; size = 4
_contentType$ = 16					; size = 4
_xmlNanoHTTPFetch PROC					; COMDAT

; 1632 : xmlNanoHTTPFetch(const char *URL, const char *filename, char **contentType) {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 1633 :     void *ctxt = NULL;

	mov	DWORD PTR _ctxt$[ebp], 0

; 1634 :     char *buf = NULL;

	mov	DWORD PTR _buf$[ebp], 0

; 1635 :     int fd;
; 1636 :     int len;
; 1637 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1638 : 
; 1639 :     if (filename == NULL) return(-1);

	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN2@xmlNanoHTT
	or	eax, -1
	jmp	$LN1@xmlNanoHTT
$LN2@xmlNanoHTT:

; 1640 :     ctxt = xmlNanoHTTPOpen(URL, contentType);

	mov	eax, DWORD PTR _contentType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	call	_xmlNanoHTTPOpen
	add	esp, 8
	mov	DWORD PTR _ctxt$[ebp], eax

; 1641 :     if (ctxt == NULL) return(-1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN3@xmlNanoHTT
	or	eax, -1
	jmp	$LN1@xmlNanoHTT
$LN3@xmlNanoHTT:

; 1642 : 
; 1643 :     if (!strcmp(filename, "-"))

	mov	DWORD PTR tv134[ebp], OFFSET ??_C@_01JOAMLHOP@?9@
	mov	edx, DWORD PTR _filename$[ebp]
	mov	DWORD PTR tv132[ebp], edx
$LL11@xmlNanoHTT:
	mov	eax, DWORD PTR tv132[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv137[ebp], cl
	mov	edx, DWORD PTR tv134[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN12@xmlNanoHTT
	cmp	BYTE PTR tv137[ebp], 0
	je	SHORT $LN13@xmlNanoHTT
	mov	eax, DWORD PTR tv132[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv144[ebp], cl
	mov	edx, DWORD PTR tv134[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN12@xmlNanoHTT
	add	DWORD PTR tv132[ebp], 2
	add	DWORD PTR tv134[ebp], 2
	cmp	BYTE PTR tv144[ebp], 0
	jne	SHORT $LL11@xmlNanoHTT
$LN13@xmlNanoHTT:
	mov	DWORD PTR tv149[ebp], 0
	jmp	SHORT $LN14@xmlNanoHTT
$LN12@xmlNanoHTT:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv149[ebp], eax
$LN14@xmlNanoHTT:
	mov	ecx, DWORD PTR tv149[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	cmp	DWORD PTR tv72[ebp], 0
	jne	SHORT $LN4@xmlNanoHTT

; 1644 :         fd = 0;

	mov	DWORD PTR _fd$[ebp], 0
	jmp	SHORT $LN5@xmlNanoHTT
$LN4@xmlNanoHTT:

; 1645 :     else {
; 1646 :         fd = open(filename, O_CREAT | O_WRONLY, 00644);

	mov	esi, esp
	push	420					; 000001a4H
	push	257					; 00000101H
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	DWORD PTR __imp__open
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _fd$[ebp], eax

; 1647 : 	if (fd < 0) {

	cmp	DWORD PTR _fd$[ebp], 0
	jge	SHORT $LN5@xmlNanoHTT

; 1648 : 	    xmlNanoHTTPClose(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNanoHTTPClose
	add	esp, 4

; 1649 : 	    if ((contentType != NULL) && (*contentType != NULL)) {

	cmp	DWORD PTR _contentType$[ebp], 0
	je	SHORT $LN7@xmlNanoHTT
	mov	ecx, DWORD PTR _contentType$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN7@xmlNanoHTT

; 1650 : 	        xmlFree(*contentType);

	mov	esi, esp
	mov	edx, DWORD PTR _contentType$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1651 : 		*contentType = NULL;

	mov	ecx, DWORD PTR _contentType$[ebp]
	mov	DWORD PTR [ecx], 0
$LN7@xmlNanoHTT:

; 1652 : 	    }
; 1653 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlNanoHTT
$LN5@xmlNanoHTT:

; 1654 : 	}
; 1655 :     }
; 1656 : 
; 1657 :     xmlNanoHTTPFetchContent( ctxt, &buf, &len );

	lea	edx, DWORD PTR _len$[ebp]
	push	edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNanoHTTPFetchContent
	add	esp, 12					; 0000000cH

; 1658 :     if ( len > 0 ) {

	cmp	DWORD PTR _len$[ebp], 0
	jle	SHORT $LN8@xmlNanoHTT

; 1659 : 	if (write(fd, buf, len) == -1) {

	mov	esi, esp
	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	DWORD PTR __imp__write
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, -1
	jne	SHORT $LN8@xmlNanoHTT

; 1660 : 	    ret = -1;

	mov	DWORD PTR _ret$[ebp], -1
$LN8@xmlNanoHTT:

; 1661 : 	}
; 1662 :     }
; 1663 : 
; 1664 :     xmlNanoHTTPClose(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNanoHTTPClose
	add	esp, 4

; 1665 :     close(fd);

	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	call	DWORD PTR __imp__close
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1666 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlNanoHTT:

; 1667 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@xmlNanoHTT
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN18@xmlNanoHTT:
	DD	2
	DD	$LN17@xmlNanoHTT
$LN17@xmlNanoHTT:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN15@xmlNanoHTT
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN16@xmlNanoHTT
$LN16@xmlNanoHTT:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN15@xmlNanoHTT:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_xmlNanoHTTPFetch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPScanProxy
_TEXT	SEGMENT
tv77 = -24						; size = 4
tv150 = -20						; size = 4
tv145 = -14						; size = 1
tv138 = -13						; size = 1
tv133 = -12						; size = 4
tv135 = -8						; size = 4
_uri$ = -4						; size = 4
_URL$ = 8						; size = 4
_xmlNanoHTTPScanProxy PROC				; COMDAT

; 351  : xmlNanoHTTPScanProxy(const char *URL) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 352  :     xmlURIPtr uri;
; 353  : 
; 354  :     if (proxy != NULL) {

	cmp	DWORD PTR _proxy, 0
	je	SHORT $LN2@xmlNanoHTT

; 355  :         xmlFree(proxy);

	mov	esi, esp
	mov	eax, DWORD PTR _proxy
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 356  : 	proxy = NULL;

	mov	DWORD PTR _proxy, 0
$LN2@xmlNanoHTT:

; 357  :     }
; 358  :     proxyPort = 0;

	mov	DWORD PTR _proxyPort, 0

; 359  : 
; 360  : #ifdef DEBUG_HTTP
; 361  :     if (URL == NULL)
; 362  : 	xmlGenericError(xmlGenericErrorContext,
; 363  : 		"Removing HTTP proxy info\n");
; 364  :     else
; 365  : 	xmlGenericError(xmlGenericErrorContext,
; 366  : 		"Using HTTP proxy %s\n", URL);
; 367  : #endif
; 368  :     if (URL == NULL) return;

	cmp	DWORD PTR _URL$[ebp], 0
	jne	SHORT $LN3@xmlNanoHTT
	jmp	$LN1@xmlNanoHTT
$LN3@xmlNanoHTT:

; 369  : 
; 370  :     uri = xmlParseURIRaw(URL, 1);

	push	1
	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	call	_xmlParseURIRaw
	add	esp, 8
	mov	DWORD PTR _uri$[ebp], eax

; 371  :     if ((uri == NULL) || (uri->scheme == NULL) ||
; 372  : 	(strcmp(uri->scheme, "http")) || (uri->server == NULL)) {

	cmp	DWORD PTR _uri$[ebp], 0
	je	SHORT $LN5@xmlNanoHTT
	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN5@xmlNanoHTT
	mov	DWORD PTR tv135[ebp], OFFSET ??_C@_04IAFLKNP@http@
	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv133[ebp], ecx
$LL9@xmlNanoHTT:
	mov	edx, DWORD PTR tv133[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv138[ebp], al
	mov	ecx, DWORD PTR tv135[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN10@xmlNanoHTT
	cmp	BYTE PTR tv138[ebp], 0
	je	SHORT $LN11@xmlNanoHTT
	mov	edx, DWORD PTR tv133[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv145[ebp], al
	mov	ecx, DWORD PTR tv135[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN10@xmlNanoHTT
	add	DWORD PTR tv133[ebp], 2
	add	DWORD PTR tv135[ebp], 2
	cmp	BYTE PTR tv145[ebp], 0
	jne	SHORT $LL9@xmlNanoHTT
$LN11@xmlNanoHTT:
	mov	DWORD PTR tv150[ebp], 0
	jmp	SHORT $LN12@xmlNanoHTT
$LN10@xmlNanoHTT:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv150[ebp], edx
$LN12@xmlNanoHTT:
	mov	eax, DWORD PTR tv150[ebp]
	mov	DWORD PTR tv77[ebp], eax
	cmp	DWORD PTR tv77[ebp], 0
	jne	SHORT $LN5@xmlNanoHTT
	mov	ecx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN4@xmlNanoHTT
$LN5@xmlNanoHTT:

; 373  : 	__xmlIOErr(XML_FROM_HTTP, XML_HTTP_URL_SYNTAX, "Syntax Error\n");

	push	OFFSET ??_C@_0O@FGOLBKPK@Syntax?5Error?6@
	push	2020					; 000007e4H
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 374  : 	if (uri != NULL)

	cmp	DWORD PTR _uri$[ebp], 0
	je	SHORT $LN6@xmlNanoHTT

; 375  : 	    xmlFreeURI(uri);

	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlFreeURI
	add	esp, 4
$LN6@xmlNanoHTT:

; 376  : 	return;

	jmp	SHORT $LN1@xmlNanoHTT
$LN4@xmlNanoHTT:

; 377  :     }
; 378  : 
; 379  :     proxy = xmlMemStrdup(uri->server);

	mov	esi, esp
	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _proxy, eax

; 380  :     if (uri->port != 0)

	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN7@xmlNanoHTT

; 381  : 	proxyPort = uri->port;

	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _proxyPort, ecx
$LN7@xmlNanoHTT:

; 382  : 
; 383  :     xmlFreeURI(uri);

	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlFreeURI
	add	esp, 4
$LN1@xmlNanoHTT:

; 384  : }

	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPScanProxy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPCleanup
_TEXT	SEGMENT
_xmlNanoHTTPCleanup PROC				; COMDAT

; 261  : xmlNanoHTTPCleanup(void) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 262  :     if (proxy != NULL) {

	cmp	DWORD PTR _proxy, 0
	je	SHORT $LN2@xmlNanoHTT

; 263  : 	xmlFree(proxy);

	mov	esi, esp
	mov	eax, DWORD PTR _proxy
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 264  : 	proxy = NULL;

	mov	DWORD PTR _proxy, 0
$LN2@xmlNanoHTT:

; 265  :     }
; 266  : #ifdef _WINSOCKAPI_
; 267  :     if (initialized)

	cmp	DWORD PTR _initialized, 0
	je	SHORT $LN3@xmlNanoHTT

; 268  : 	WSACleanup();

	mov	esi, esp
	call	DWORD PTR __imp__WSACleanup@0
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlNanoHTT:

; 269  : #endif
; 270  :     initialized = 0;

	mov	DWORD PTR _initialized, 0

; 271  :     return;
; 272  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlNanoHTTPCleanup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPInit
_TEXT	SEGMENT
_wsaData$ = -408					; size = 400
_env$ = -4						; size = 4
_xmlNanoHTTPInit PROC					; COMDAT

; 220  : xmlNanoHTTPInit(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 412				; 0000019cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-412]
	mov	ecx, 103				; 00000067H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 221  :     const char *env;
; 222  : #ifdef _WINSOCKAPI_
; 223  :     WSADATA wsaData;
; 224  : #endif
; 225  : 
; 226  :     if (initialized)

	cmp	DWORD PTR _initialized, 0
	je	SHORT $LN2@xmlNanoHTT

; 227  : 	return;

	jmp	$LN1@xmlNanoHTT
$LN2@xmlNanoHTT:

; 228  : 
; 229  : #ifdef _WINSOCKAPI_
; 230  :     if (WSAStartup(MAKEWORD(1, 1), &wsaData) != 0)

	mov	esi, esp
	lea	eax, DWORD PTR _wsaData$[ebp]
	push	eax
	push	257					; 00000101H
	call	DWORD PTR __imp__WSAStartup@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN3@xmlNanoHTT

; 231  : 	return;

	jmp	$LN1@xmlNanoHTT
$LN3@xmlNanoHTT:

; 232  : #endif
; 233  : 
; 234  :     if (proxy == NULL) {

	cmp	DWORD PTR _proxy, 0
	jne	$done$12

; 235  : 	proxyPort = 80;

	mov	DWORD PTR _proxyPort, 80		; 00000050H

; 236  : 	env = getenv("no_proxy");

	mov	esi, esp
	push	OFFSET ??_C@_08BOGLDIEC@no_proxy@
	call	DWORD PTR __imp__getenv
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _env$[ebp], eax

; 237  : 	if (env && ((env[0] == '*') && (env[1] == 0)))

	cmp	DWORD PTR _env$[ebp], 0
	je	SHORT $LN5@xmlNanoHTT
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _env$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $LN5@xmlNanoHTT
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _env$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN5@xmlNanoHTT

; 238  : 	    goto done;

	jmp	SHORT $done$12
$LN5@xmlNanoHTT:

; 239  : 	env = getenv("http_proxy");

	mov	esi, esp
	push	OFFSET ??_C@_0L@BKCFCEPH@http_proxy@
	call	DWORD PTR __imp__getenv
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _env$[ebp], eax

; 240  : 	if (env != NULL) {

	cmp	DWORD PTR _env$[ebp], 0
	je	SHORT $LN6@xmlNanoHTT

; 241  : 	    xmlNanoHTTPScanProxy(env);

	mov	edx, DWORD PTR _env$[ebp]
	push	edx
	call	_xmlNanoHTTPScanProxy
	add	esp, 4

; 242  : 	    goto done;

	jmp	SHORT $done$12
$LN6@xmlNanoHTT:

; 243  : 	}
; 244  : 	env = getenv("HTTP_PROXY");

	mov	esi, esp
	push	OFFSET ??_C@_0L@GDPFKPEL@HTTP_PROXY@
	call	DWORD PTR __imp__getenv
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _env$[ebp], eax

; 245  : 	if (env != NULL) {

	cmp	DWORD PTR _env$[ebp], 0
	je	SHORT $done$12

; 246  : 	    xmlNanoHTTPScanProxy(env);

	mov	eax, DWORD PTR _env$[ebp]
	push	eax
	call	_xmlNanoHTTPScanProxy
	add	esp, 4
$done$12:

; 247  : 	    goto done;
; 248  : 	}
; 249  :     }
; 250  : done:
; 251  :     initialized = 1;

	mov	DWORD PTR _initialized, 1
$LN1@xmlNanoHTT:

; 252  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@xmlNanoHTT
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 412				; 0000019cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN11@xmlNanoHTT:
	DD	1
	DD	$LN10@xmlNanoHTT
$LN10@xmlNanoHTT:
	DD	-408					; fffffe68H
	DD	400					; 00000190H
	DD	$LN9@xmlNanoHTT
$LN9@xmlNanoHTT:
	DB	119					; 00000077H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
_xmlNanoHTTPInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiLoad@4
_TEXT	SEGMENT
_Path$1 = -588						; size = 268
_SystemDir$2 = -312					; size = 261
_i$ = -44						; size = 4
_fScratch$ = -40					; size = 4
_rgtLocal$ = -32					; size = 24
_hLibrary$ = -4						; size = 4
_wFunction$ = 8						; size = 2
_WspiapiLoad@4 PROC					; COMDAT

; 907  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 592				; 00000250H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-592]
	mov	ecx, 148				; 00000094H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4

; 908  :     HMODULE                 hLibrary        = NULL;

	mov	DWORD PTR _hLibrary$[ebp], 0

; 909  : 
; 910  :     // these static variables store state across calls, across threads.
; 911  :     static BOOL             bInitialized    = FALSE;
; 912  :     static WSPIAPI_FUNCTION rgtGlobal[]     = WSPIAPI_FUNCTION_ARRAY;
; 913  :     static const int        iNumGlobal      = (sizeof(rgtGlobal) /
; 914  :                                                sizeof(WSPIAPI_FUNCTION));
; 915  :     
; 916  :     // we overwrite rgtGlobal only if all routines exist in library.
; 917  :     WSPIAPI_FUNCTION        rgtLocal[]      = WSPIAPI_FUNCTION_ARRAY;

	mov	DWORD PTR _rgtLocal$[ebp], OFFSET ??_C@_0M@MBIPAJOD@getaddrinfo@
	mov	DWORD PTR _rgtLocal$[ebp+4], OFFSET _WspiapiLegacyGetAddrInfo@16
	mov	DWORD PTR _rgtLocal$[ebp+8], OFFSET ??_C@_0M@NNJNLPKG@getnameinfo@
	mov	DWORD PTR _rgtLocal$[ebp+12], OFFSET _WspiapiLegacyGetNameInfo@28
	mov	DWORD PTR _rgtLocal$[ebp+16], OFFSET ??_C@_0N@EHOPPMLH@freeaddrinfo@
	mov	DWORD PTR _rgtLocal$[ebp+20], OFFSET _WspiapiLegacyFreeAddrInfo@4
$LN2@WspiapiLoa:

; 918  :     __analysis_assume((sizeof(rgtLocal)/sizeof(WSPIAPI_FUNCTION)) == iNumGlobal);

	xor	eax, eax
	jne	SHORT $LN2@WspiapiLoa

; 919  :     FARPROC                 fScratch        = NULL;

	mov	DWORD PTR _fScratch$[ebp], 0

; 920  :     int                     i               = 0;

	mov	DWORD PTR _i$[ebp], 0

; 921  :     
; 922  :     
; 923  :     if (bInitialized)           // WspiapiLoad has already been called once

	cmp	DWORD PTR ?bInitialized@?1??WspiapiLoad@@9@9, 0 ; `WspiapiLoad'::`2'::bInitialized
	je	SHORT $LN7@WspiapiLoa

; 924  :         return (rgtGlobal[wFunction].pfAddress);

	movzx	ecx, WORD PTR _wFunction$[ebp]
	mov	eax, DWORD PTR ?rgtGlobal@?1??WspiapiLoad@@9@9[ecx*8+4]
	jmp	$LN1@WspiapiLoa
$LN7@WspiapiLoa:

; 925  : 
; 926  :     for (;;)                    // breakout loop
; 927  :     {
; 928  :         CHAR SystemDir[MAX_PATH + 1];
; 929  :         CHAR Path[MAX_PATH + 8];
; 930  : 
; 931  :         if (GetSystemDirectoryA(SystemDir, MAX_PATH) == 0) 

	mov	esi, esp
	push	260					; 00000104H
	lea	edx, DWORD PTR _SystemDir$2[ebp]
	push	edx
	call	DWORD PTR __imp__GetSystemDirectoryA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN15@WspiapiLoa

; 932  :         {
; 933  :             break;

	jmp	$LN6@WspiapiLoa
$LN15@WspiapiLoa:

; 934  :         }
; 935  : 
; 936  :         // in Whistler and beyond...
; 937  :         // the routines are present in the WinSock 2 library (ws2_32.dll).
; 938  :         // printf("Looking in ws2_32 for getaddrinfo...\n");
; 939  :         _WSPIAPI_STRCPY_S(Path, _WSPIAPI_COUNTOF(Path), SystemDir);

	mov	esi, esp
	lea	eax, DWORD PTR _SystemDir$2[ebp]
	push	eax
	push	268					; 0000010cH
	lea	ecx, DWORD PTR _Path$1[ebp]
	push	ecx
	call	DWORD PTR __imp__strcpy_s
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 940  :         _WSPIAPI_STRCAT_S(Path, _WSPIAPI_COUNTOF(Path), "\\ws2_32");

	mov	esi, esp
	push	OFFSET ??_C@_07LPPPKMHP@?2ws2_32@
	push	268					; 0000010cH
	lea	edx, DWORD PTR _Path$1[ebp]
	push	edx
	call	DWORD PTR __imp__strcat_s
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 941  :         hLibrary = LoadLibraryA(Path);

	mov	esi, esp
	lea	eax, DWORD PTR _Path$1[ebp]
	push	eax
	call	DWORD PTR __imp__LoadLibraryA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hLibrary$[ebp], eax

; 942  :         if (hLibrary != NULL)

	cmp	DWORD PTR _hLibrary$[ebp], 0
	je	SHORT $LN16@WspiapiLoa

; 943  :         {
; 944  :             fScratch = GetProcAddress(hLibrary, "getaddrinfo");

	mov	esi, esp
	push	OFFSET ??_C@_0M@MBIPAJOD@getaddrinfo@
	mov	ecx, DWORD PTR _hLibrary$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetProcAddress@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _fScratch$[ebp], eax

; 945  :             if (fScratch == NULL)

	cmp	DWORD PTR _fScratch$[ebp], 0
	jne	SHORT $LN16@WspiapiLoa

; 946  :             {
; 947  :                 FreeLibrary(hLibrary);

	mov	esi, esp
	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	call	DWORD PTR __imp__FreeLibrary@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 948  :                 hLibrary = NULL;

	mov	DWORD PTR _hLibrary$[ebp], 0
$LN16@WspiapiLoa:

; 949  :             }
; 950  :         }
; 951  :         if (hLibrary != NULL)

	cmp	DWORD PTR _hLibrary$[ebp], 0
	je	SHORT $LN18@WspiapiLoa

; 952  :             break;

	jmp	$LN6@WspiapiLoa
$LN18@WspiapiLoa:

; 953  :         
; 954  : 
; 955  :         // in the IPv6 Technology Preview...        
; 956  :         // the routines are present in the IPv6 WinSock library (wship6.dll).
; 957  :         // printf("Looking in wship6 for getaddrinfo...\n");
; 958  :         _WSPIAPI_STRCPY_S(Path, _WSPIAPI_COUNTOF(Path), SystemDir);

	mov	esi, esp
	lea	eax, DWORD PTR _SystemDir$2[ebp]
	push	eax
	push	268					; 0000010cH
	lea	ecx, DWORD PTR _Path$1[ebp]
	push	ecx
	call	DWORD PTR __imp__strcpy_s
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 959  :         _WSPIAPI_STRCAT_S(Path, _WSPIAPI_COUNTOF(Path), "\\wship6");

	mov	esi, esp
	push	OFFSET ??_C@_07OKMCKPF@?2wship6@
	push	268					; 0000010cH
	lea	edx, DWORD PTR _Path$1[ebp]
	push	edx
	call	DWORD PTR __imp__strcat_s
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 960  :         hLibrary = LoadLibraryA(Path);

	mov	esi, esp
	lea	eax, DWORD PTR _Path$1[ebp]
	push	eax
	call	DWORD PTR __imp__LoadLibraryA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hLibrary$[ebp], eax

; 961  :         if (hLibrary != NULL)

	cmp	DWORD PTR _hLibrary$[ebp], 0
	je	SHORT $LN19@WspiapiLoa

; 962  :         {
; 963  :             fScratch = GetProcAddress(hLibrary, "getaddrinfo");

	mov	esi, esp
	push	OFFSET ??_C@_0M@MBIPAJOD@getaddrinfo@
	mov	ecx, DWORD PTR _hLibrary$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetProcAddress@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _fScratch$[ebp], eax

; 964  :             if (fScratch == NULL)

	cmp	DWORD PTR _fScratch$[ebp], 0
	jne	SHORT $LN19@WspiapiLoa

; 965  :             {
; 966  :                 FreeLibrary(hLibrary);

	mov	esi, esp
	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	call	DWORD PTR __imp__FreeLibrary@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 967  :                 hLibrary = NULL;

	mov	DWORD PTR _hLibrary$[ebp], 0
$LN19@WspiapiLoa:

; 968  :             }
; 969  :         }
; 970  : 
; 971  :         break;

	jmp	SHORT $LN6@WspiapiLoa

; 972  :     }

	jmp	$LN7@WspiapiLoa
$LN6@WspiapiLoa:

; 973  : 
; 974  : 
; 975  :     if (hLibrary != NULL)

	cmp	DWORD PTR _hLibrary$[ebp], 0
	je	$LN21@WspiapiLoa

; 976  :     {
; 977  :         // use routines from this library...
; 978  :         // since getaddrinfo is here, we expect all routines to be here,
; 979  :         // but will fall back to IPv4-only if any of them is missing.
; 980  :         for (i = 0; i < iNumGlobal; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@WspiapiLoa
$LN8@WspiapiLoa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@WspiapiLoa:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?iNumGlobal@?1??WspiapiLoad@@9@9 ; `WspiapiLoad'::`2'::iNumGlobal
	jge	SHORT $LN9@WspiapiLoa

; 981  :         {
; 982  :             rgtLocal[i].pfAddress
; 983  :                 = GetProcAddress(hLibrary, rgtLocal[i].pszName);

	mov	esi, esp
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _rgtLocal$[ebp+edx*8]
	push	eax
	mov	ecx, DWORD PTR _hLibrary$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetProcAddress@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _rgtLocal$[ebp+edx*8+4], eax

; 984  :             if (rgtLocal[i].pfAddress == NULL)

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _rgtLocal$[ebp+eax*8+4], 0
	jne	SHORT $LN22@WspiapiLoa

; 985  :             {
; 986  :                 FreeLibrary(hLibrary);

	mov	esi, esp
	mov	ecx, DWORD PTR _hLibrary$[ebp]
	push	ecx
	call	DWORD PTR __imp__FreeLibrary@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 987  :                 hLibrary = NULL;

	mov	DWORD PTR _hLibrary$[ebp], 0

; 988  :                 break;

	jmp	SHORT $LN9@WspiapiLoa
$LN22@WspiapiLoa:

; 989  :             }
; 990  :         }

	jmp	SHORT $LN8@WspiapiLoa
$LN9@WspiapiLoa:

; 991  : 
; 992  :         if (hLibrary != NULL)

	cmp	DWORD PTR _hLibrary$[ebp], 0
	je	SHORT $LN21@WspiapiLoa

; 993  :         {
; 994  :             // printf("found!\n");
; 995  :             for (i = 0; i < iNumGlobal; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@WspiapiLoa
$LN11@WspiapiLoa:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN13@WspiapiLoa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?iNumGlobal@?1??WspiapiLoad@@9@9 ; `WspiapiLoad'::`2'::iNumGlobal
	jge	SHORT $LN21@WspiapiLoa

; 996  :                 rgtGlobal[i].pfAddress = rgtLocal[i].pfAddress;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _rgtLocal$[ebp+edx*8+4]
	mov	DWORD PTR ?rgtGlobal@?1??WspiapiLoad@@9@9[ecx*8+4], eax
	jmp	SHORT $LN11@WspiapiLoa
$LN21@WspiapiLoa:

; 997  :         }
; 998  :     }
; 999  :     
; 1000 :     bInitialized = TRUE;

	mov	DWORD PTR ?bInitialized@?1??WspiapiLoad@@9@9, 1 ; `WspiapiLoad'::`2'::bInitialized

; 1001 :     return (rgtGlobal[wFunction].pfAddress);

	movzx	ecx, WORD PTR _wFunction$[ebp]
	mov	eax, DWORD PTR ?rgtGlobal@?1??WspiapiLoad@@9@9[ecx*8+4]
$LN1@WspiapiLoa:

; 1002 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN29@WspiapiLoa
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 592				; 00000250H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN29@WspiapiLoa:
	DD	3
	DD	$LN28@WspiapiLoa
$LN28@WspiapiLoa:
	DD	-32					; ffffffe0H
	DD	24					; 00000018H
	DD	$LN25@WspiapiLoa
	DD	-312					; fffffec8H
	DD	261					; 00000105H
	DD	$LN26@WspiapiLoa
	DD	-588					; fffffdb4H
	DD	268					; 0000010cH
	DD	$LN27@WspiapiLoa
$LN27@WspiapiLoa:
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN26@WspiapiLoa:
	DB	83					; 00000053H
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	0
$LN25@WspiapiLoa:
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
_WspiapiLoad@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiLegacyGetNameInfo@28
_TEXT	SEGMENT
tv185 = -92						; size = 4
tv282 = -85						; size = 1
tv279 = -84						; size = 4
tv276 = -80						; size = 4
tv177 = -76						; size = 4
tv147 = -72						; size = 4
tv235 = -65						; size = 1
tv232 = -64						; size = 4
tv229 = -60						; size = 4
tv130 = -56						; size = 4
_pc$ = -52						; size = 4
_pszNode$ = -48						; size = 4
_tAddress$ = -40					; size = 4
_ptHost$ = -32						; size = 4
_pszService$ = -28					; size = 4
_szBuffer$ = -20					; size = 6
_wPort$ = -8						; size = 2
_ptService$ = -4					; size = 4
_ptSocketAddress$ = 8					; size = 4
_tSocketLength$ = 12					; size = 4
_pszNodeName$ = 16					; size = 4
_tNodeLength$ = 20					; size = 4
_pszServiceName$ = 24					; size = 4
_tServiceLength$ = 28					; size = 4
_iFlags$ = 32						; size = 4
_WspiapiLegacyGetNameInfo@28 PROC			; COMDAT

; 736  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-92]
	mov	ecx, 23					; 00000017H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4

; 737  :     struct servent  *ptService;
; 738  :     WORD            wPort;    
; 739  :     char            szBuffer[]  = "65535";

	mov	eax, DWORD PTR ??_C@_05LGDGBMPG@65535@
	mov	DWORD PTR _szBuffer$[ebp], eax
	mov	cx, WORD PTR ??_C@_05LGDGBMPG@65535@+4
	mov	WORD PTR _szBuffer$[ebp+4], cx

; 740  :     char            *pszService = szBuffer;

	lea	edx, DWORD PTR _szBuffer$[ebp]
	mov	DWORD PTR _pszService$[ebp], edx

; 741  : 
; 742  :     struct hostent  *ptHost;
; 743  :     struct in_addr  tAddress;
; 744  :     char            *pszNode    = NULL;

	mov	DWORD PTR _pszNode$[ebp], 0

; 745  :     char            *pc         = NULL;

	mov	DWORD PTR _pc$[ebp], 0

; 746  :     
; 747  : 
; 748  :     // sanity check ptSocketAddress and tSocketLength.
; 749  :     if ((!ptSocketAddress) || (tSocketLength < sizeof(struct sockaddr)))

	cmp	DWORD PTR _ptSocketAddress$[ebp], 0
	je	SHORT $LN5@WspiapiLeg
	cmp	DWORD PTR _tSocketLength$[ebp], 16	; 00000010H
	jae	SHORT $LN4@WspiapiLeg
$LN5@WspiapiLeg:

; 750  :         return EAI_FAIL;

	mov	eax, 11003				; 00002afbH
	jmp	$LN1@WspiapiLeg
$LN4@WspiapiLeg:

; 751  :     
; 752  :     if (ptSocketAddress->sa_family != AF_INET)

	mov	eax, DWORD PTR _ptSocketAddress$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 2
	je	SHORT $LN6@WspiapiLeg

; 753  :         return EAI_FAMILY;

	mov	eax, 10047				; 0000273fH
	jmp	$LN1@WspiapiLeg
$LN6@WspiapiLeg:

; 754  : 
; 755  :     if (tSocketLength < sizeof(struct sockaddr_in))

	cmp	DWORD PTR _tSocketLength$[ebp], 16	; 00000010H
	jae	SHORT $LN7@WspiapiLeg

; 756  :         return EAI_FAIL;

	mov	eax, 11003				; 00002afbH
	jmp	$LN1@WspiapiLeg
$LN7@WspiapiLeg:

; 757  :     
; 758  :     if (!(pszNodeName && tNodeLength) &&

	cmp	DWORD PTR _pszNodeName$[ebp], 0
	je	SHORT $LN9@WspiapiLeg
	cmp	DWORD PTR _tNodeLength$[ebp], 0
	jne	SHORT $LN8@WspiapiLeg
$LN9@WspiapiLeg:
	cmp	DWORD PTR _pszServiceName$[ebp], 0
	je	SHORT $LN10@WspiapiLeg
	cmp	DWORD PTR _tServiceLength$[ebp], 0
	jne	SHORT $LN8@WspiapiLeg
$LN10@WspiapiLeg:

; 759  :         !(pszServiceName && tServiceLength))
; 760  :     {
; 761  :         return EAI_NONAME;    

	mov	eax, 11001				; 00002af9H
	jmp	$LN1@WspiapiLeg
$LN8@WspiapiLeg:

; 762  :     }
; 763  : 
; 764  :     // the draft has the "bad flags" error code, so presumably we
; 765  :     // should check something here.  insisting that there aren't
; 766  :     // any unspecified flags set would break forward compatibility,
; 767  :     // however.  so we just check for non-sensical combinations.
; 768  :     if ((iFlags & NI_NUMERICHOST) && (iFlags & NI_NAMEREQD))

	mov	edx, DWORD PTR _iFlags$[ebp]
	and	edx, 2
	je	SHORT $LN11@WspiapiLeg
	mov	eax, DWORD PTR _iFlags$[ebp]
	and	eax, 4
	je	SHORT $LN11@WspiapiLeg

; 769  :     {                                                                       
; 770  :         return EAI_BADFLAGS;

	mov	eax, 10022				; 00002726H
	jmp	$LN1@WspiapiLeg
$LN11@WspiapiLeg:

; 771  :     }
; 772  :         
; 773  :     // translate the port to a service name (if requested).
; 774  :     if (pszServiceName && tServiceLength)

	cmp	DWORD PTR _pszServiceName$[ebp], 0
	je	$LN12@WspiapiLeg
	cmp	DWORD PTR _tServiceLength$[ebp], 0
	je	$LN12@WspiapiLeg

; 775  :     {
; 776  :         wPort = ((struct sockaddr_in *) ptSocketAddress)->sin_port;

	mov	ecx, DWORD PTR _ptSocketAddress$[ebp]
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR _wPort$[ebp], dx

; 777  :         
; 778  :         if (iFlags & NI_NUMERICSERV)

	mov	eax, DWORD PTR _iFlags$[ebp]
	and	eax, 8
	je	SHORT $LN13@WspiapiLeg

; 779  :         {
; 780  :             // return numeric form of the address.
; 781  :             _WSPIAPI_SPRINTF_S_1(szBuffer, _WSPIAPI_COUNTOF(szBuffer), "%u", ntohs(wPort));

	mov	esi, esp
	movzx	ecx, WORD PTR _wPort$[ebp]
	push	ecx
	call	DWORD PTR __imp__ntohs@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	edx, ax
	push	edx
	push	OFFSET ??_C@_02GMHACPFF@?$CFu@
	push	6
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	call	_sprintf_s
	add	esp, 16					; 00000010H

; 782  :         }

	jmp	SHORT $LN14@WspiapiLeg
$LN13@WspiapiLeg:

; 783  :         else
; 784  :         {
; 785  :             // return service name corresponding to port.
; 786  :             ptService = getservbyport(wPort,

	mov	ecx, DWORD PTR _iFlags$[ebp]
	and	ecx, 16					; 00000010H
	je	SHORT $LN34@WspiapiLeg
	mov	DWORD PTR tv130[ebp], OFFSET ??_C@_03OCLLGKEH@udp@
	jmp	SHORT $LN35@WspiapiLeg
$LN34@WspiapiLeg:
	mov	DWORD PTR tv130[ebp], 0
$LN35@WspiapiLeg:
	mov	esi, esp
	mov	edx, DWORD PTR tv130[ebp]
	push	edx
	movzx	eax, WORD PTR _wPort$[ebp]
	push	eax
	call	DWORD PTR __imp__getservbyport@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ptService$[ebp], eax

; 787  :                                       (iFlags & NI_DGRAM) ? "udp" : NULL);
; 788  :             if (ptService && ptService->s_name)

	cmp	DWORD PTR _ptService$[ebp], 0
	je	SHORT $LN15@WspiapiLeg
	mov	ecx, DWORD PTR _ptService$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN15@WspiapiLeg

; 789  :             {
; 790  :                 // lookup successful.
; 791  :                 pszService = ptService->s_name;

	mov	edx, DWORD PTR _ptService$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pszService$[ebp], eax

; 792  :             }

	jmp	SHORT $LN14@WspiapiLeg
$LN15@WspiapiLeg:

; 793  :             else
; 794  :             {
; 795  :                 // DRAFT: return numeric form of the port!
; 796  :                 _WSPIAPI_SPRINTF_S_1(szBuffer, _WSPIAPI_COUNTOF(szBuffer), "%u", ntohs(wPort));

	mov	esi, esp
	movzx	ecx, WORD PTR _wPort$[ebp]
	push	ecx
	call	DWORD PTR __imp__ntohs@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	edx, ax
	push	edx
	push	OFFSET ??_C@_02GMHACPFF@?$CFu@
	push	6
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	call	_sprintf_s
	add	esp, 16					; 00000010H
$LN14@WspiapiLeg:

; 797  :             }
; 798  :         }
; 799  :         
; 800  :         
; 801  :         if (tServiceLength > strlen(pszService))

	mov	ecx, DWORD PTR _pszService$[ebp]
	mov	DWORD PTR tv229[ebp], ecx
	mov	edx, DWORD PTR tv229[ebp]
	add	edx, 1
	mov	DWORD PTR tv232[ebp], edx
$LL36@WspiapiLeg:
	mov	eax, DWORD PTR tv229[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv235[ebp], cl
	add	DWORD PTR tv229[ebp], 1
	cmp	BYTE PTR tv235[ebp], 0
	jne	SHORT $LL36@WspiapiLeg
	mov	edx, DWORD PTR tv229[ebp]
	sub	edx, DWORD PTR tv232[ebp]
	mov	DWORD PTR tv147[ebp], edx
	mov	eax, DWORD PTR _tServiceLength$[ebp]
	cmp	eax, DWORD PTR tv147[ebp]
	jbe	SHORT $LN17@WspiapiLeg

; 802  :             _WSPIAPI_STRCPY_S(pszServiceName, tServiceLength, pszService);

	mov	esi, esp
	mov	ecx, DWORD PTR _pszService$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tServiceLength$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszServiceName$[ebp]
	push	eax
	call	DWORD PTR __imp__strcpy_s
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN12@WspiapiLeg
$LN17@WspiapiLeg:

; 803  :         else
; 804  :             return EAI_FAIL;

	mov	eax, 11003				; 00002afbH
	jmp	$LN1@WspiapiLeg
$LN12@WspiapiLeg:

; 805  :     }
; 806  : 
; 807  :     
; 808  :     // translate the address to a node name (if requested).
; 809  :     if (pszNodeName && tNodeLength)

	cmp	DWORD PTR _pszNodeName$[ebp], 0
	je	$LN19@WspiapiLeg
	cmp	DWORD PTR _tNodeLength$[ebp], 0
	je	$LN19@WspiapiLeg

; 810  :     {    
; 811  :         // this is the IPv4-only version, so we have an IPv4 address.
; 812  :         tAddress = ((struct sockaddr_in *) ptSocketAddress)->sin_addr;

	mov	ecx, DWORD PTR _ptSocketAddress$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _tAddress$[ebp], edx

; 813  : 
; 814  :         if (iFlags & NI_NUMERICHOST)

	mov	eax, DWORD PTR _iFlags$[ebp]
	and	eax, 2
	je	SHORT $LN20@WspiapiLeg

; 815  :         {
; 816  :             // return numeric form of the address.
; 817  : #pragma warning(suppress: 4996)
; 818  :             pszNode  = inet_ntoa(tAddress);

	mov	esi, esp
	mov	ecx, DWORD PTR _tAddress$[ebp]
	push	ecx
	call	DWORD PTR __imp__inet_ntoa@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pszNode$[ebp], eax

; 819  :         }

	jmp	$LN21@WspiapiLeg
$LN20@WspiapiLeg:

; 820  :         else
; 821  :         {
; 822  :             // return node name corresponding to address.
; 823  : #pragma warning(suppress: 4996 38026)
; 824  :             ptHost = gethostbyaddr((char *) &tAddress, sizeof(struct in_addr), AF_INET);

	mov	esi, esp
	push	2
	push	4
	lea	edx, DWORD PTR _tAddress$[ebp]
	push	edx
	call	DWORD PTR __imp__gethostbyaddr@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ptHost$[ebp], eax

; 825  :             if (ptHost && ptHost->h_name)

	cmp	DWORD PTR _ptHost$[ebp], 0
	je	SHORT $LN22@WspiapiLeg
	mov	eax, DWORD PTR _ptHost$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN22@WspiapiLeg

; 826  :             {
; 827  :                 // DNS lookup successful.
; 828  :                 // stop copying at a "." if NI_NOFQDN is specified.
; 829  :                 pszNode = ptHost->h_name;

	mov	ecx, DWORD PTR _ptHost$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pszNode$[ebp], edx

; 830  :                 if ((iFlags & NI_NOFQDN) &&

	mov	eax, DWORD PTR _iFlags$[ebp]
	and	eax, 1
	je	SHORT $LN24@WspiapiLeg
	push	46					; 0000002eH
	mov	ecx, DWORD PTR _pszNode$[ebp]
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _pc$[ebp], eax
	cmp	DWORD PTR _pc$[ebp], 0
	je	SHORT $LN24@WspiapiLeg

; 831  :                     ((pc = strchr(pszNode, '.')) != NULL))
; 832  :                     *pc = '\0';

	mov	edx, DWORD PTR _pc$[ebp]
	mov	BYTE PTR [edx], 0
$LN24@WspiapiLeg:

; 833  :             }

	jmp	SHORT $LN21@WspiapiLeg
$LN22@WspiapiLeg:

; 834  :             else
; 835  :             {
; 836  :                 // DNS lookup failed.  return numeric form of the address.
; 837  :                 if (iFlags & NI_NAMEREQD)

	mov	eax, DWORD PTR _iFlags$[ebp]
	and	eax, 4
	je	SHORT $LN25@WspiapiLeg

; 838  :                 {
; 839  :                     switch (WSAGetLastError())

	mov	esi, esp
	call	DWORD PTR __imp__WSAGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv177[ebp], eax
	cmp	DWORD PTR tv177[ebp], 11001		; 00002af9H
	je	SHORT $LN27@WspiapiLeg
	cmp	DWORD PTR tv177[ebp], 11002		; 00002afaH
	je	SHORT $LN28@WspiapiLeg
	cmp	DWORD PTR tv177[ebp], 11003		; 00002afbH
	je	SHORT $LN29@WspiapiLeg
	jmp	SHORT $LN30@WspiapiLeg
$LN27@WspiapiLeg:

; 840  :                     {
; 841  :                         case WSAHOST_NOT_FOUND: return EAI_NONAME;

	mov	eax, 11001				; 00002af9H
	jmp	$LN1@WspiapiLeg
$LN28@WspiapiLeg:

; 842  :                         case WSATRY_AGAIN:      return EAI_AGAIN;

	mov	eax, 11002				; 00002afaH
	jmp	$LN1@WspiapiLeg
$LN29@WspiapiLeg:

; 843  :                         case WSANO_RECOVERY:    return EAI_FAIL;

	mov	eax, 11003				; 00002afbH
	jmp	SHORT $LN1@WspiapiLeg
$LN30@WspiapiLeg:

; 844  :                         default:                return EAI_NONAME;

	mov	eax, 11001				; 00002af9H
	jmp	SHORT $LN1@WspiapiLeg

; 845  :                     }
; 846  :                 }

	jmp	SHORT $LN21@WspiapiLeg
$LN25@WspiapiLeg:

; 847  :                 else
; 848  : #pragma warning(suppress: 4996)
; 849  :                     pszNode  = inet_ntoa(tAddress);

	mov	esi, esp
	mov	ecx, DWORD PTR _tAddress$[ebp]
	push	ecx
	call	DWORD PTR __imp__inet_ntoa@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pszNode$[ebp], eax
$LN21@WspiapiLeg:

; 850  :             }
; 851  :         }
; 852  : 
; 853  :         if (tNodeLength > strlen(pszNode))

	mov	edx, DWORD PTR _pszNode$[ebp]
	mov	DWORD PTR tv276[ebp], edx
	mov	eax, DWORD PTR tv276[ebp]
	add	eax, 1
	mov	DWORD PTR tv279[ebp], eax
$LL37@WspiapiLeg:
	mov	ecx, DWORD PTR tv276[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv282[ebp], dl
	add	DWORD PTR tv276[ebp], 1
	cmp	BYTE PTR tv282[ebp], 0
	jne	SHORT $LL37@WspiapiLeg
	mov	eax, DWORD PTR tv276[ebp]
	sub	eax, DWORD PTR tv279[ebp]
	mov	DWORD PTR tv185[ebp], eax
	mov	ecx, DWORD PTR _tNodeLength$[ebp]
	cmp	ecx, DWORD PTR tv185[ebp]
	jbe	SHORT $LN31@WspiapiLeg

; 854  :             _WSPIAPI_STRCPY_S(pszNodeName, tNodeLength, pszNode);

	mov	esi, esp
	mov	edx, DWORD PTR _pszNode$[ebp]
	push	edx
	mov	eax, DWORD PTR _tNodeLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszNodeName$[ebp]
	push	ecx
	call	DWORD PTR __imp__strcpy_s
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN19@WspiapiLeg
$LN31@WspiapiLeg:

; 855  :         else
; 856  :             return EAI_FAIL;

	mov	eax, 11003				; 00002afbH
	jmp	SHORT $LN1@WspiapiLeg
$LN19@WspiapiLeg:

; 857  :     }
; 858  : 
; 859  :     return 0;

	xor	eax, eax
$LN1@WspiapiLeg:

; 860  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN41@WspiapiLeg
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 92					; 0000005cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
	npad	1
$LN41@WspiapiLeg:
	DD	2
	DD	$LN40@WspiapiLeg
$LN40@WspiapiLeg:
	DD	-20					; ffffffecH
	DD	6
	DD	$LN38@WspiapiLeg
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN39@WspiapiLeg
$LN39@WspiapiLeg:
	DB	116					; 00000074H
	DB	65					; 00000041H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN38@WspiapiLeg:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_WspiapiLegacyGetNameInfo@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiLegacyGetAddrInfo@16
_TEXT	SEGMENT
tv167 = -64						; size = 4
tv157 = -60						; size = 4
tv152 = -56						; size = 4
tv148 = -52						; size = 4
_wUdpPort$ = -48					; size = 2
_wTcpPort$ = -44					; size = 2
_bClone$ = -40						; size = 4
_pc$ = -36						; size = 4
_ptService$ = -32					; size = 4
_dwAddress$ = -28					; size = 4
_wPort$ = -24						; size = 2
_iProtocol$ = -20					; size = 4
_iSocketType$ = -16					; size = 4
_iFamily$ = -12						; size = 4
_iFlags$ = -8						; size = 4
_iError$ = -4						; size = 4
_pszNodeName$ = 8					; size = 4
_pszServiceName$ = 12					; size = 4
_ptHints$ = 16						; size = 4
_pptResult$ = 20					; size = 4
_WspiapiLegacyGetAddrInfo@16 PROC			; COMDAT

; 511  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4

; 512  :     int                 iError      = 0;

	mov	DWORD PTR _iError$[ebp], 0

; 513  :     int                 iFlags      = 0;

	mov	DWORD PTR _iFlags$[ebp], 0

; 514  :     int                 iFamily     = PF_UNSPEC;

	mov	DWORD PTR _iFamily$[ebp], 0

; 515  :     int                 iSocketType = 0;

	mov	DWORD PTR _iSocketType$[ebp], 0

; 516  :     int                 iProtocol   = 0;

	mov	DWORD PTR _iProtocol$[ebp], 0

; 517  :     WORD                wPort       = 0;

	xor	eax, eax
	mov	WORD PTR _wPort$[ebp], ax

; 518  :     DWORD               dwAddress   = 0;

	mov	DWORD PTR _dwAddress$[ebp], 0

; 519  : 
; 520  :     struct servent      *ptService  = NULL;

	mov	DWORD PTR _ptService$[ebp], 0

; 521  :     char                *pc         = NULL;

	mov	DWORD PTR _pc$[ebp], 0

; 522  :     BOOL                bClone      = FALSE;

	mov	DWORD PTR _bClone$[ebp], 0

; 523  :     WORD                wTcpPort    = 0;

	xor	ecx, ecx
	mov	WORD PTR _wTcpPort$[ebp], cx

; 524  :     WORD                wUdpPort    = 0;

	xor	edx, edx
	mov	WORD PTR _wUdpPort$[ebp], dx

; 525  :     
; 526  :     
; 527  :     // initialize pptResult with default return value.
; 528  :     *pptResult  = NULL;

	mov	eax, DWORD PTR _pptResult$[ebp]
	mov	DWORD PTR [eax], 0

; 529  : 
; 530  : 
; 531  :     ////////////////////////////////////////
; 532  :     // validate arguments...
; 533  :     //
; 534  :     
; 535  :     // both the node name and the service name can't be NULL.
; 536  :     if ((!pszNodeName) && (!pszServiceName))

	cmp	DWORD PTR _pszNodeName$[ebp], 0
	jne	SHORT $LN2@WspiapiLeg
	cmp	DWORD PTR _pszServiceName$[ebp], 0
	jne	SHORT $LN2@WspiapiLeg

; 537  :         return EAI_NONAME;

	mov	eax, 11001				; 00002af9H
	jmp	$LN1@WspiapiLeg
$LN2@WspiapiLeg:

; 538  : 
; 539  :     // validate hints.
; 540  :     if (ptHints)

	cmp	DWORD PTR _ptHints$[ebp], 0
	je	$LN3@WspiapiLeg

; 541  :     {
; 542  :         // all members other than ai_flags, ai_family, ai_socktype
; 543  :         // and ai_protocol must be zero or a null pointer.
; 544  :         if ((ptHints->ai_addrlen    != 0)       ||
; 545  :             (ptHints->ai_canonname  != NULL)    ||
; 546  :             (ptHints->ai_addr       != NULL)    ||

	mov	ecx, DWORD PTR _ptHints$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN5@WspiapiLeg
	mov	edx, DWORD PTR _ptHints$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN5@WspiapiLeg
	mov	eax, DWORD PTR _ptHints$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN5@WspiapiLeg
	mov	ecx, DWORD PTR _ptHints$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN4@WspiapiLeg
$LN5@WspiapiLeg:

; 547  :             (ptHints->ai_next       != NULL))
; 548  :         {
; 549  :             return EAI_FAIL;

	mov	eax, 11003				; 00002afbH
	jmp	$LN1@WspiapiLeg
$LN4@WspiapiLeg:

; 550  :         }
; 551  :         
; 552  :         // the spec has the "bad flags" error code, so presumably we
; 553  :         // should check something here.  insisting that there aren't
; 554  :         // any unspecified flags set would break forward compatibility,
; 555  :         // however.  so we just check for non-sensical combinations.
; 556  :         //
; 557  :         // we cannot come up with a canonical name given a null node name.
; 558  :         iFlags      = ptHints->ai_flags;

	mov	edx, DWORD PTR _ptHints$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iFlags$[ebp], eax

; 559  :         if ((iFlags & AI_CANONNAME) && !pszNodeName)

	mov	ecx, DWORD PTR _iFlags$[ebp]
	and	ecx, 2
	je	SHORT $LN6@WspiapiLeg
	cmp	DWORD PTR _pszNodeName$[ebp], 0
	jne	SHORT $LN6@WspiapiLeg

; 560  :             return EAI_BADFLAGS;

	mov	eax, 10022				; 00002726H
	jmp	$LN1@WspiapiLeg
$LN6@WspiapiLeg:

; 561  : 
; 562  :         // we only support a limited number of protocol families.
; 563  :         iFamily     = ptHints->ai_family;

	mov	edx, DWORD PTR _ptHints$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _iFamily$[ebp], eax

; 564  :         if ((iFamily != PF_UNSPEC) && (iFamily != PF_INET))

	cmp	DWORD PTR _iFamily$[ebp], 0
	je	SHORT $LN7@WspiapiLeg
	cmp	DWORD PTR _iFamily$[ebp], 2
	je	SHORT $LN7@WspiapiLeg

; 565  :             return EAI_FAMILY;

	mov	eax, 10047				; 0000273fH
	jmp	$LN1@WspiapiLeg
$LN7@WspiapiLeg:

; 566  : 
; 567  :         // we only support only these socket types.
; 568  :         iSocketType = ptHints->ai_socktype;

	mov	ecx, DWORD PTR _ptHints$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _iSocketType$[ebp], edx

; 569  :         if ((iSocketType != 0)                  &&
; 570  :             (iSocketType != SOCK_STREAM)        &&
; 571  :             (iSocketType != SOCK_DGRAM)         &&

	cmp	DWORD PTR _iSocketType$[ebp], 0
	je	SHORT $LN8@WspiapiLeg
	cmp	DWORD PTR _iSocketType$[ebp], 1
	je	SHORT $LN8@WspiapiLeg
	cmp	DWORD PTR _iSocketType$[ebp], 2
	je	SHORT $LN8@WspiapiLeg
	cmp	DWORD PTR _iSocketType$[ebp], 3
	je	SHORT $LN8@WspiapiLeg

; 572  :             (iSocketType != SOCK_RAW))
; 573  :             return EAI_SOCKTYPE;

	mov	eax, 10044				; 0000273cH
	jmp	$LN1@WspiapiLeg
$LN8@WspiapiLeg:

; 574  : 
; 575  :         // REVIEW: What if ai_socktype and ai_protocol are at odds?
; 576  :         iProtocol   = ptHints->ai_protocol;

	mov	eax, DWORD PTR _ptHints$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _iProtocol$[ebp], ecx
$LN3@WspiapiLeg:

; 577  :     }
; 578  : 
; 579  : 
; 580  :     ////////////////////////////////////////
; 581  :     // do service lookup...
; 582  : 
; 583  :     if (pszServiceName)

	cmp	DWORD PTR _pszServiceName$[ebp], 0
	je	$LN9@WspiapiLeg

; 584  :     {
; 585  :         wPort = (WORD) strtoul(pszServiceName, &pc, 10);

	mov	esi, esp
	push	10					; 0000000aH
	lea	edx, DWORD PTR _pc$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszServiceName$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	WORD PTR _wPort$[ebp], ax

; 586  :         if (*pc == '\0')        // numeric port string

	mov	ecx, DWORD PTR _pc$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN10@WspiapiLeg

; 587  :         {
; 588  :             wPort = wTcpPort = wUdpPort = htons(wPort);

	mov	esi, esp
	movzx	eax, WORD PTR _wPort$[ebp]
	push	eax
	call	DWORD PTR __imp__htons@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	WORD PTR _wUdpPort$[ebp], ax
	mov	cx, WORD PTR _wUdpPort$[ebp]
	mov	WORD PTR _wTcpPort$[ebp], cx
	mov	dx, WORD PTR _wTcpPort$[ebp]
	mov	WORD PTR _wPort$[ebp], dx

; 589  :             if (iSocketType == 0)

	cmp	DWORD PTR _iSocketType$[ebp], 0
	jne	SHORT $LN12@WspiapiLeg

; 590  :             {
; 591  :                 bClone      = TRUE;

	mov	DWORD PTR _bClone$[ebp], 1

; 592  :                 iSocketType = SOCK_STREAM;

	mov	DWORD PTR _iSocketType$[ebp], 1
$LN12@WspiapiLeg:

; 593  :             }
; 594  :         }

	jmp	$LN9@WspiapiLeg
$LN10@WspiapiLeg:

; 595  :         else                    // non numeric port string
; 596  :         {
; 597  :             if ((iSocketType == 0) || (iSocketType == SOCK_DGRAM))

	cmp	DWORD PTR _iSocketType$[ebp], 0
	je	SHORT $LN14@WspiapiLeg
	cmp	DWORD PTR _iSocketType$[ebp], 2
	jne	SHORT $LN13@WspiapiLeg
$LN14@WspiapiLeg:

; 598  :             {
; 599  :                 ptService = getservbyname(pszServiceName, "udp");

	mov	esi, esp
	push	OFFSET ??_C@_03OCLLGKEH@udp@
	mov	eax, DWORD PTR _pszServiceName$[ebp]
	push	eax
	call	DWORD PTR __imp__getservbyname@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ptService$[ebp], eax

; 600  :                 if (ptService)

	cmp	DWORD PTR _ptService$[ebp], 0
	je	SHORT $LN13@WspiapiLeg

; 601  :                     wPort = wUdpPort = ptService->s_port;

	mov	ecx, DWORD PTR _ptService$[ebp]
	mov	dx, WORD PTR [ecx+8]
	mov	WORD PTR _wUdpPort$[ebp], dx
	mov	ax, WORD PTR _wUdpPort$[ebp]
	mov	WORD PTR _wPort$[ebp], ax
$LN13@WspiapiLeg:

; 602  :             }
; 603  : 
; 604  :             if ((iSocketType == 0) || (iSocketType == SOCK_STREAM))

	cmp	DWORD PTR _iSocketType$[ebp], 0
	je	SHORT $LN17@WspiapiLeg
	cmp	DWORD PTR _iSocketType$[ebp], 1
	jne	SHORT $LN16@WspiapiLeg
$LN17@WspiapiLeg:

; 605  :             {
; 606  :                 ptService = getservbyname(pszServiceName, "tcp");

	mov	esi, esp
	push	OFFSET ??_C@_03FPEIBLKH@tcp@
	mov	ecx, DWORD PTR _pszServiceName$[ebp]
	push	ecx
	call	DWORD PTR __imp__getservbyname@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ptService$[ebp], eax

; 607  :                 if (ptService)

	cmp	DWORD PTR _ptService$[ebp], 0
	je	SHORT $LN16@WspiapiLeg

; 608  :                     wPort = wTcpPort = ptService->s_port;

	mov	edx, DWORD PTR _ptService$[ebp]
	mov	ax, WORD PTR [edx+8]
	mov	WORD PTR _wTcpPort$[ebp], ax
	mov	cx, WORD PTR _wTcpPort$[ebp]
	mov	WORD PTR _wPort$[ebp], cx
$LN16@WspiapiLeg:

; 609  :             }
; 610  :             
; 611  :             // assumes 0 is an invalid service port...
; 612  :             if (wPort == 0)     // no service exists

	movzx	edx, WORD PTR _wPort$[ebp]
	test	edx, edx
	jne	SHORT $LN19@WspiapiLeg

; 613  :                 return (iSocketType ? EAI_SERVICE : EAI_NONAME);

	cmp	DWORD PTR _iSocketType$[ebp], 0
	je	SHORT $LN34@WspiapiLeg
	mov	DWORD PTR tv148[ebp], 10109		; 0000277dH
	jmp	SHORT $LN35@WspiapiLeg
$LN34@WspiapiLeg:
	mov	DWORD PTR tv148[ebp], 11001		; 00002af9H
$LN35@WspiapiLeg:
	mov	eax, DWORD PTR tv148[ebp]
	jmp	$LN1@WspiapiLeg
$LN19@WspiapiLeg:

; 614  : 
; 615  :             if (iSocketType == 0)

	cmp	DWORD PTR _iSocketType$[ebp], 0
	jne	SHORT $LN9@WspiapiLeg

; 616  :             {
; 617  :                 // if both tcp and udp, process tcp now & clone udp later.
; 618  :                 iSocketType = (wTcpPort) ? SOCK_STREAM : SOCK_DGRAM;

	movzx	eax, WORD PTR _wTcpPort$[ebp]
	test	eax, eax
	je	SHORT $LN36@WspiapiLeg
	mov	DWORD PTR tv152[ebp], 1
	jmp	SHORT $LN37@WspiapiLeg
$LN36@WspiapiLeg:
	mov	DWORD PTR tv152[ebp], 2
$LN37@WspiapiLeg:
	mov	ecx, DWORD PTR tv152[ebp]
	mov	DWORD PTR _iSocketType$[ebp], ecx

; 619  :                 bClone      = (wTcpPort && wUdpPort); 

	movzx	edx, WORD PTR _wTcpPort$[ebp]
	test	edx, edx
	je	SHORT $LN38@WspiapiLeg
	movzx	eax, WORD PTR _wUdpPort$[ebp]
	test	eax, eax
	je	SHORT $LN38@WspiapiLeg
	mov	DWORD PTR tv157[ebp], 1
	jmp	SHORT $LN39@WspiapiLeg
$LN38@WspiapiLeg:
	mov	DWORD PTR tv157[ebp], 0
$LN39@WspiapiLeg:
	mov	ecx, DWORD PTR tv157[ebp]
	mov	DWORD PTR _bClone$[ebp], ecx
$LN9@WspiapiLeg:

; 620  :             }
; 621  :         }
; 622  :     }
; 623  :     
; 624  : 
; 625  : 
; 626  :     ////////////////////////////////////////
; 627  :     // do node name lookup...
; 628  : 
; 629  :     // if we weren't given a node name,
; 630  :     // return the wildcard or loopback address (depending on AI_PASSIVE).
; 631  :     //
; 632  :     // if we have a numeric host address string,
; 633  :     // return the binary address.
; 634  :     //
; 635  :     if ((!pszNodeName) || (WspiapiParseV4Address(pszNodeName, &dwAddress)))

	cmp	DWORD PTR _pszNodeName$[ebp], 0
	je	SHORT $LN23@WspiapiLeg
	lea	edx, DWORD PTR _dwAddress$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszNodeName$[ebp]
	push	eax
	call	_WspiapiParseV4Address@8
	test	eax, eax
	je	$LN21@WspiapiLeg
$LN23@WspiapiLeg:

; 636  :     {
; 637  :         if (!pszNodeName)

	cmp	DWORD PTR _pszNodeName$[ebp], 0
	jne	SHORT $LN24@WspiapiLeg

; 638  :         {
; 639  :             dwAddress = htonl((iFlags & AI_PASSIVE)

	mov	ecx, DWORD PTR _iFlags$[ebp]
	and	ecx, 1
	je	SHORT $LN40@WspiapiLeg
	mov	DWORD PTR tv167[ebp], 0
	jmp	SHORT $LN41@WspiapiLeg
$LN40@WspiapiLeg:
	mov	DWORD PTR tv167[ebp], 2130706433	; 7f000001H
$LN41@WspiapiLeg:
	mov	esi, esp
	mov	edx, DWORD PTR tv167[ebp]
	push	edx
	call	DWORD PTR __imp__htonl@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwAddress$[ebp], eax
$LN24@WspiapiLeg:

; 640  :                               ? INADDR_ANY
; 641  :                               : INADDR_LOOPBACK);
; 642  :         }
; 643  :         
; 644  :         // create an addrinfo structure...
; 645  :         *pptResult =

	mov	eax, DWORD PTR _dwAddress$[ebp]
	push	eax
	movzx	ecx, WORD PTR _wPort$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iProtocol$[ebp]
	push	edx
	mov	eax, DWORD PTR _iSocketType$[ebp]
	push	eax
	call	_WspiapiNewAddrInfo@16
	mov	ecx, DWORD PTR _pptResult$[ebp]
	mov	DWORD PTR [ecx], eax

; 646  :             WspiapiNewAddrInfo(iSocketType, iProtocol, wPort, dwAddress);
; 647  :         if (!(*pptResult))

	mov	edx, DWORD PTR _pptResult$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN25@WspiapiLeg

; 648  :             iError = EAI_MEMORY;

	mov	DWORD PTR _iError$[ebp], 8
$LN25@WspiapiLeg:

; 649  :         
; 650  :         if (!iError && pszNodeName)

	cmp	DWORD PTR _iError$[ebp], 0
	jne	SHORT $LN26@WspiapiLeg
	cmp	DWORD PTR _pszNodeName$[ebp], 0
	je	SHORT $LN26@WspiapiLeg

; 651  :         {
; 652  :             // implementation specific behavior: set AI_NUMERICHOST
; 653  :             // to indicate that we got a numeric host address string.
; 654  :             (*pptResult)->ai_flags |= AI_NUMERICHOST;

	mov	eax, DWORD PTR _pptResult$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	or	edx, 4
	mov	eax, DWORD PTR _pptResult$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 655  :             
; 656  :             // return the numeric address string as the canonical name
; 657  :             if (iFlags & AI_CANONNAME)

	mov	edx, DWORD PTR _iFlags$[ebp]
	and	edx, 2
	je	SHORT $LN26@WspiapiLeg

; 658  :             {
; 659  :                 (*pptResult)->ai_canonname =

	mov	esi, esp
	mov	eax, DWORD PTR _dwAddress$[ebp]
	push	eax
	call	DWORD PTR __imp__inet_ntoa@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_WspiapiStrdup@4
	mov	ecx, DWORD PTR _pptResult$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+20], eax

; 660  : #pragma warning(suppress: 4996)
; 661  :                     WspiapiStrdup(inet_ntoa(*((struct in_addr *) &dwAddress)));
; 662  :                 if (!(*pptResult)->ai_canonname)        

	mov	eax, DWORD PTR _pptResult$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN26@WspiapiLeg

; 663  :                     iError = EAI_MEMORY;

	mov	DWORD PTR _iError$[ebp], 8
$LN26@WspiapiLeg:

; 664  :             }
; 665  :         }
; 666  :     }

	jmp	SHORT $LN22@WspiapiLeg
$LN21@WspiapiLeg:

; 667  : 
; 668  : 
; 669  :     // if we do not have a numeric host address string and
; 670  :     // AI_NUMERICHOST flag is set, return an error!
; 671  :     else if (iFlags & AI_NUMERICHOST)

	mov	edx, DWORD PTR _iFlags$[ebp]
	and	edx, 4
	je	SHORT $LN29@WspiapiLeg

; 672  :     {
; 673  :         iError = EAI_NONAME;

	mov	DWORD PTR _iError$[ebp], 11001		; 00002af9H

; 674  :     }

	jmp	SHORT $LN22@WspiapiLeg
$LN29@WspiapiLeg:

; 675  :     
; 676  : 
; 677  :     // since we have a non-numeric node name,
; 678  :     // we have to do a regular node name lookup.
; 679  :     else
; 680  :     {
; 681  :         iError = WspiapiLookupNode(pszNodeName,

	mov	eax, DWORD PTR _pptResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iFlags$[ebp]
	and	ecx, 2
	push	ecx
	movzx	edx, WORD PTR _wPort$[ebp]
	push	edx
	mov	eax, DWORD PTR _iProtocol$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iSocketType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszNodeName$[ebp]
	push	edx
	call	_WspiapiLookupNode@24
	mov	DWORD PTR _iError$[ebp], eax
$LN22@WspiapiLeg:

; 682  :                                    iSocketType,
; 683  :                                    iProtocol,
; 684  :                                    wPort,
; 685  :                                    (iFlags & AI_CANONNAME),
; 686  :                                    pptResult);
; 687  :     }
; 688  : 
; 689  :     if (!iError && bClone)

	cmp	DWORD PTR _iError$[ebp], 0
	jne	SHORT $LN31@WspiapiLeg
	cmp	DWORD PTR _bClone$[ebp], 0
	je	SHORT $LN31@WspiapiLeg

; 690  :     {
; 691  :         iError = WspiapiClone(wUdpPort, *pptResult);

	mov	eax, DWORD PTR _pptResult$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	movzx	edx, WORD PTR _wUdpPort$[ebp]
	push	edx
	call	_WspiapiClone@8
	mov	DWORD PTR _iError$[ebp], eax
$LN31@WspiapiLeg:

; 692  :     }
; 693  : 
; 694  :     if (iError)

	cmp	DWORD PTR _iError$[ebp], 0
	je	SHORT $LN32@WspiapiLeg

; 695  :     {
; 696  :         WspiapiLegacyFreeAddrInfo(*pptResult);

	mov	eax, DWORD PTR _pptResult$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_WspiapiLegacyFreeAddrInfo@4

; 697  :         *pptResult  = NULL;        

	mov	edx, DWORD PTR _pptResult$[ebp]
	mov	DWORD PTR [edx], 0
$LN32@WspiapiLeg:

; 698  :     }
; 699  : 
; 700  :     return (iError);

	mov	eax, DWORD PTR _iError$[ebp]
$LN1@WspiapiLeg:

; 701  : }

	pop	edi
	pop	esi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_WspiapiLegacyGetAddrInfo@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiLegacyFreeAddrInfo@4
_TEXT	SEGMENT
_ptNext$ = -4						; size = 4
_ptHead$ = 8						; size = 4
_WspiapiLegacyFreeAddrInfo@4 PROC			; COMDAT

; 468  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4

; 469  :     struct addrinfo *ptNext;    // next strcture to free
; 470  : 
; 471  :     for (ptNext = ptHead; ptNext != NULL; ptNext = ptHead)

	mov	eax, DWORD PTR _ptHead$[ebp]
	mov	DWORD PTR _ptNext$[ebp], eax
	jmp	SHORT $LN4@WspiapiLeg
$LN2@WspiapiLeg:
	mov	ecx, DWORD PTR _ptHead$[ebp]
	mov	DWORD PTR _ptNext$[ebp], ecx
$LN4@WspiapiLeg:
	cmp	DWORD PTR _ptNext$[ebp], 0
	je	SHORT $LN1@WspiapiLeg

; 472  :     {
; 473  :         if (ptNext->ai_canonname)

	mov	edx, DWORD PTR _ptNext$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN5@WspiapiLeg

; 474  :             WspiapiFree(ptNext->ai_canonname);

	mov	esi, esp
	mov	eax, DWORD PTR _ptNext$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@WspiapiLeg:

; 475  :         
; 476  :         if (ptNext->ai_addr)

	mov	edx, DWORD PTR _ptNext$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN6@WspiapiLeg

; 477  :             WspiapiFree(ptNext->ai_addr);

	mov	esi, esp
	mov	eax, DWORD PTR _ptNext$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@WspiapiLeg:

; 478  : 
; 479  :         ptHead = ptNext->ai_next;

	mov	edx, DWORD PTR _ptNext$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _ptHead$[ebp], eax

; 480  :         WspiapiFree(ptNext);

	mov	esi, esp
	mov	ecx, DWORD PTR _ptNext$[ebp]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 481  :     }

	jmp	SHORT $LN2@WspiapiLeg
$LN1@WspiapiLeg:

; 482  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_WspiapiLegacyFreeAddrInfo@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiClone@8
_TEXT	SEGMENT
_ptNew$ = -8						; size = 4
_ptNext$ = -4						; size = 4
_wPort$ = 8						; size = 2
_ptResult$ = 12						; size = 4
_WspiapiClone@8 PROC					; COMDAT

; 424  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4

; 425  :     struct addrinfo *ptNext = NULL;

	mov	DWORD PTR _ptNext$[ebp], 0

; 426  :     struct addrinfo *ptNew  = NULL;

	mov	DWORD PTR _ptNew$[ebp], 0

; 427  : 
; 428  :     for (ptNext = ptResult; ptNext != NULL; )

	mov	eax, DWORD PTR _ptResult$[ebp]
	mov	DWORD PTR _ptNext$[ebp], eax
$LN4@WspiapiClo:
	cmp	DWORD PTR _ptNext$[ebp], 0
	je	SHORT $LN3@WspiapiClo

; 429  :     {
; 430  :         // create an addrinfo structure...
; 431  :         ptNew = WspiapiNewAddrInfo(

	mov	ecx, DWORD PTR _ptNext$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	movzx	ecx, WORD PTR _wPort$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptNext$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	push	2
	call	_WspiapiNewAddrInfo@16
	mov	DWORD PTR _ptNew$[ebp], eax

; 432  :             SOCK_DGRAM,
; 433  :             ptNext->ai_protocol,
; 434  :             wPort,
; 435  :             ((struct sockaddr_in *) ptNext->ai_addr)->sin_addr.s_addr);
; 436  :         if (!ptNew)

	cmp	DWORD PTR _ptNew$[ebp], 0
	jne	SHORT $LN5@WspiapiClo

; 437  :             break;

	jmp	SHORT $LN3@WspiapiClo
$LN5@WspiapiClo:

; 438  : 
; 439  :         // link the cloned addrinfo
; 440  :         ptNew->ai_next  = ptNext->ai_next;

	mov	ecx, DWORD PTR _ptNew$[ebp]
	mov	edx, DWORD PTR _ptNext$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax

; 441  :         ptNext->ai_next = ptNew;

	mov	ecx, DWORD PTR _ptNext$[ebp]
	mov	edx, DWORD PTR _ptNew$[ebp]
	mov	DWORD PTR [ecx+28], edx

; 442  :         ptNext          = ptNew->ai_next;

	mov	eax, DWORD PTR _ptNew$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _ptNext$[ebp], ecx

; 443  :     }

	jmp	SHORT $LN4@WspiapiClo
$LN3@WspiapiClo:

; 444  : 
; 445  :     if (ptNext != NULL)

	cmp	DWORD PTR _ptNext$[ebp], 0
	je	SHORT $LN6@WspiapiClo

; 446  :         return EAI_MEMORY;

	mov	eax, 8
	jmp	SHORT $LN1@WspiapiClo
$LN6@WspiapiClo:

; 447  :     
; 448  :     return 0;

	xor	eax, eax
$LN1@WspiapiClo:

; 449  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_WspiapiClone@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiLookupNode@24
_TEXT	SEGMENT
tv132 = -2128						; size = 4
tv236 = -2124						; size = 4
tv231 = -2118						; size = 1
tv186 = -2117						; size = 1
tv224 = -2116						; size = 4
tv190 = -2112						; size = 4
tv95 = -2108						; size = 4
tv228 = -2101						; size = 1
tv145 = -2100						; size = 4
tv148 = -2096						; size = 4
_pszScratch$ = -2092					; size = 4
_pszAlias$ = -2088					; size = 4
_pszName$ = -2084					; size = 4
_szFQDN2$ = -2076					; size = 1025
_szFQDN1$ = -1040					; size = 1025
_iAliasCount$ = -8					; size = 4
_iError$ = -4						; size = 4
_pszNodeName$ = 8					; size = 4
_iSocketType$ = 12					; size = 4
_iProtocol$ = 16					; size = 4
_wPort$ = 20						; size = 2
_bAI_CANONNAME$ = 24					; size = 4
_pptResult$ = 28					; size = 4
_WspiapiLookupNode@24 PROC				; COMDAT

; 351  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2128				; 00000850H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-2128]
	mov	ecx, 532				; 00000214H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4

; 352  :     int     iError              = 0;

	mov	DWORD PTR _iError$[ebp], 0

; 353  :     int     iAliasCount         = 0;

	mov	DWORD PTR _iAliasCount$[ebp], 0

; 354  : 
; 355  :     char    szFQDN1[NI_MAXHOST] = "";

	mov	al, BYTE PTR ??_C@_00CNPNBAHC@@
	mov	BYTE PTR _szFQDN1$[ebp], al
	push	1024					; 00000400H
	push	0
	lea	ecx, DWORD PTR _szFQDN1$[ebp+1]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 356  :     char    szFQDN2[NI_MAXHOST] = "";

	mov	dl, BYTE PTR ??_C@_00CNPNBAHC@@
	mov	BYTE PTR _szFQDN2$[ebp], dl
	push	1024					; 00000400H
	push	0
	lea	eax, DWORD PTR _szFQDN2$[ebp+1]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 357  :     char    *pszName            = szFQDN1;

	lea	ecx, DWORD PTR _szFQDN1$[ebp]
	mov	DWORD PTR _pszName$[ebp], ecx

; 358  :     char    *pszAlias           = szFQDN2;

	lea	edx, DWORD PTR _szFQDN2$[ebp]
	mov	DWORD PTR _pszAlias$[ebp], edx

; 359  :     char    *pszScratch         = NULL;

	mov	DWORD PTR _pszScratch$[ebp], 0

; 360  :     _WSPIAPI_STRNCPY_S(pszName, NI_MAXHOST, pszNodeName, NI_MAXHOST - 1);

	mov	esi, esp
	push	1024					; 00000400H
	mov	eax, DWORD PTR _pszNodeName$[ebp]
	push	eax
	push	1025					; 00000401H
	mov	ecx, DWORD PTR _pszName$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy_s
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@WspiapiLoo:

; 361  :     
; 362  :     for (;;)
; 363  :     {
; 364  :         iError = WspiapiQueryDNS(pszNodeName,

	mov	edx, DWORD PTR _pptResult$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszAlias$[ebp]
	push	eax
	movzx	ecx, WORD PTR _wPort$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iProtocol$[ebp]
	push	edx
	mov	eax, DWORD PTR _iSocketType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszNodeName$[ebp]
	push	ecx
	call	_WspiapiQueryDNS@24
	mov	DWORD PTR _iError$[ebp], eax

; 365  :                                  iSocketType,
; 366  :                                  iProtocol,
; 367  :                                  wPort,
; 368  :                                  pszAlias,
; 369  :                                  pptResult);
; 370  :         if (iError)

	cmp	DWORD PTR _iError$[ebp], 0
	je	SHORT $LN5@WspiapiLoo

; 371  :             break;

	jmp	$LN3@WspiapiLoo
$LN5@WspiapiLoo:

; 372  : 
; 373  :         // if we found addresses, then we are done.
; 374  :         if (*pptResult)

	mov	edx, DWORD PTR _pptResult$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN6@WspiapiLoo

; 375  :             break;

	jmp	$LN3@WspiapiLoo
$LN6@WspiapiLoo:

; 376  : 
; 377  :         // stop infinite loops due to DNS misconfiguration.  there appears
; 378  :         // to be no particular recommended limit in RFCs 1034 and 1035.
; 379  :         if ((!strlen(pszAlias))             ||
; 380  :             (!strcmp(pszName, pszAlias))    ||

	mov	eax, DWORD PTR _pszAlias$[ebp]
	mov	DWORD PTR tv148[ebp], eax
	mov	ecx, DWORD PTR tv148[ebp]
	add	ecx, 1
	mov	DWORD PTR tv145[ebp], ecx
$LL35@WspiapiLoo:
	mov	edx, DWORD PTR tv148[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv228[ebp], al
	add	DWORD PTR tv148[ebp], 1
	cmp	BYTE PTR tv228[ebp], 0
	jne	SHORT $LL35@WspiapiLoo
	mov	ecx, DWORD PTR tv148[ebp]
	sub	ecx, DWORD PTR tv145[ebp]
	mov	DWORD PTR tv95[ebp], ecx
	je	$LN8@WspiapiLoo
	mov	edx, DWORD PTR _pszAlias$[ebp]
	mov	DWORD PTR tv190[ebp], edx
	mov	eax, DWORD PTR _pszName$[ebp]
	mov	DWORD PTR tv224[ebp], eax
$LL36@WspiapiLoo:
	mov	ecx, DWORD PTR tv224[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv186[ebp], dl
	mov	eax, DWORD PTR tv190[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN37@WspiapiLoo
	cmp	BYTE PTR tv186[ebp], 0
	je	SHORT $LN38@WspiapiLoo
	mov	ecx, DWORD PTR tv224[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv231[ebp], dl
	mov	eax, DWORD PTR tv190[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN37@WspiapiLoo
	add	DWORD PTR tv224[ebp], 2
	add	DWORD PTR tv190[ebp], 2
	cmp	BYTE PTR tv231[ebp], 0
	jne	SHORT $LL36@WspiapiLoo
$LN38@WspiapiLoo:
	mov	DWORD PTR tv236[ebp], 0
	jmp	SHORT $LN39@WspiapiLoo
$LN37@WspiapiLoo:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv236[ebp], ecx
$LN39@WspiapiLoo:
	mov	edx, DWORD PTR tv236[ebp]
	mov	DWORD PTR tv132[ebp], edx
	cmp	DWORD PTR tv132[ebp], 0
	je	SHORT $LN8@WspiapiLoo
	mov	eax, DWORD PTR _iAliasCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _iAliasCount$[ebp], eax
	cmp	DWORD PTR _iAliasCount$[ebp], 16	; 00000010H
	jne	SHORT $LN7@WspiapiLoo
$LN8@WspiapiLoo:

; 381  :             (++iAliasCount == 16))
; 382  :         {
; 383  :             iError = EAI_FAIL;

	mov	DWORD PTR _iError$[ebp], 11003		; 00002afbH

; 384  :             break;

	jmp	SHORT $LN3@WspiapiLoo
$LN7@WspiapiLoo:

; 385  :         }
; 386  : 
; 387  :         // there was a new CNAME, look again.
; 388  :         WspiapiSwap(pszName, pszAlias, pszScratch);

	mov	ecx, DWORD PTR _pszName$[ebp]
	mov	DWORD PTR _pszScratch$[ebp], ecx
	mov	edx, DWORD PTR _pszAlias$[ebp]
	mov	DWORD PTR _pszName$[ebp], edx
	mov	eax, DWORD PTR _pszScratch$[ebp]
	mov	DWORD PTR _pszAlias$[ebp], eax

; 389  :     }

	jmp	$LN4@WspiapiLoo
$LN3@WspiapiLoo:

; 390  : 
; 391  :     if (!iError && bAI_CANONNAME)

	cmp	DWORD PTR _iError$[ebp], 0
	jne	SHORT $LN9@WspiapiLoo
	cmp	DWORD PTR _bAI_CANONNAME$[ebp], 0
	je	SHORT $LN9@WspiapiLoo

; 392  :     {
; 393  :         (*pptResult)->ai_canonname = WspiapiStrdup(pszAlias);

	mov	ecx, DWORD PTR _pszAlias$[ebp]
	push	ecx
	call	_WspiapiStrdup@4
	mov	edx, DWORD PTR _pptResult$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+20], eax

; 394  :         if (!(*pptResult)->ai_canonname)

	mov	edx, DWORD PTR _pptResult$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN9@WspiapiLoo

; 395  :             iError = EAI_MEMORY;

	mov	DWORD PTR _iError$[ebp], 8
$LN9@WspiapiLoo:

; 396  :     }
; 397  : 
; 398  :     return iError;

	mov	eax, DWORD PTR _iError$[ebp]

; 399  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN43@WspiapiLoo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 2128				; 00000850H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN43@WspiapiLoo:
	DD	2
	DD	$LN42@WspiapiLoo
$LN42@WspiapiLoo:
	DD	-1040					; fffffbf0H
	DD	1025					; 00000401H
	DD	$LN40@WspiapiLoo
	DD	-2076					; fffff7e4H
	DD	1025					; 00000401H
	DD	$LN41@WspiapiLoo
$LN41@WspiapiLoo:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	70					; 00000046H
	DB	81					; 00000051H
	DB	68					; 00000044H
	DB	78					; 0000004eH
	DB	50					; 00000032H
	DB	0
$LN40@WspiapiLoo:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	70					; 00000046H
	DB	81					; 00000051H
	DB	68					; 00000044H
	DB	78					; 0000004eH
	DB	49					; 00000031H
	DB	0
_WspiapiLookupNode@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiQueryDNS@24
_TEXT	SEGMENT
tv92 = -16						; size = 4
_ppAddresses$ = -12					; size = 4
_ptHost$ = -8						; size = 4
_pptNext$ = -4						; size = 4
_pszNodeName$ = 8					; size = 4
_iSocketType$ = 12					; size = 4
_iProtocol$ = 16					; size = 4
_wPort$ = 20						; size = 2
_pszAlias$ = 24						; size = 4
_pptResult$ = 28					; size = 4
_WspiapiQueryDNS@24 PROC				; COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4

; 270  :     struct addrinfo **pptNext   = pptResult;

	mov	eax, DWORD PTR _pptResult$[ebp]
	mov	DWORD PTR _pptNext$[ebp], eax

; 271  :     struct hostent  *ptHost     = NULL;

	mov	DWORD PTR _ptHost$[ebp], 0

; 272  :     char            **ppAddresses;
; 273  : 
; 274  :     *pptNext    = NULL;

	mov	ecx, DWORD PTR _pptNext$[ebp]
	mov	DWORD PTR [ecx], 0

; 275  :     pszAlias[0] = '\0';

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pszAlias$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 276  : 
; 277  : #pragma warning(suppress: 4996 38026)
; 278  :     ptHost = gethostbyname(pszNodeName);

	mov	esi, esp
	mov	edx, DWORD PTR _pszNodeName$[ebp]
	push	edx
	call	DWORD PTR __imp__gethostbyname@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ptHost$[ebp], eax

; 279  :     if (ptHost)

	cmp	DWORD PTR _ptHost$[ebp], 0
	je	$LN7@WspiapiQue

; 280  :     {
; 281  :         if ((ptHost->h_addrtype == AF_INET)     &&

	mov	eax, DWORD PTR _ptHost$[ebp]
	movsx	ecx, WORD PTR [eax+8]
	cmp	ecx, 2
	jne	SHORT $LN8@WspiapiQue
	mov	edx, DWORD PTR _ptHost$[ebp]
	movsx	eax, WORD PTR [edx+10]
	cmp	eax, 4
	jne	SHORT $LN8@WspiapiQue

; 282  :             (ptHost->h_length   == sizeof(struct in_addr)))
; 283  :         {
; 284  :             for (ppAddresses    = ptHost->h_addr_list;

	mov	ecx, DWORD PTR _ptHost$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _ppAddresses$[ebp], edx
	jmp	SHORT $LN4@WspiapiQue
$LN2@WspiapiQue:

; 286  :                  ppAddresses++)

	mov	eax, DWORD PTR _ppAddresses$[ebp]
	add	eax, 4
	mov	DWORD PTR _ppAddresses$[ebp], eax
$LN4@WspiapiQue:

; 285  :                  *ppAddresses   != NULL;

	mov	ecx, DWORD PTR _ppAddresses$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN8@WspiapiQue

; 287  :             {
; 288  :                 // create an addrinfo structure...
; 289  :                 *pptNext = WspiapiNewAddrInfo(

	mov	edx, DWORD PTR _ppAddresses$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	movzx	edx, WORD PTR _wPort$[ebp]
	push	edx
	mov	eax, DWORD PTR _iProtocol$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iSocketType$[ebp]
	push	ecx
	call	_WspiapiNewAddrInfo@16
	mov	edx, DWORD PTR _pptNext$[ebp]
	mov	DWORD PTR [edx], eax

; 290  :                     iSocketType,
; 291  :                     iProtocol,
; 292  :                     wPort,
; 293  :                     ((struct in_addr *) *ppAddresses)->s_addr);
; 294  :                 if (!*pptNext)

	mov	eax, DWORD PTR _pptNext$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN9@WspiapiQue

; 295  :                     return EAI_MEMORY;

	mov	eax, 8
	jmp	$LN1@WspiapiQue
$LN9@WspiapiQue:

; 296  : 
; 297  :                 pptNext = &((*pptNext)->ai_next);

	mov	ecx, DWORD PTR _pptNext$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR _pptNext$[ebp], edx

; 298  :             }

	jmp	SHORT $LN2@WspiapiQue
$LN8@WspiapiQue:

; 299  :         }
; 300  : 
; 301  :         // pick up the canonical name.
; 302  :         _WSPIAPI_STRNCPY_S(pszAlias, NI_MAXHOST, ptHost->h_name, NI_MAXHOST - 1);

	mov	esi, esp
	push	1024					; 00000400H
	mov	eax, DWORD PTR _ptHost$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1025					; 00000401H
	mov	edx, DWORD PTR _pszAlias$[ebp]
	push	edx
	call	DWORD PTR __imp__strncpy_s
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 303  :         
; 304  :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@WspiapiQue
$LN7@WspiapiQue:

; 305  :     }
; 306  :     
; 307  :     switch (WSAGetLastError())

	mov	esi, esp
	call	DWORD PTR __imp__WSAGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv92[ebp], eax
	mov	eax, DWORD PTR tv92[ebp]
	sub	eax, 11001				; 00002af9H
	mov	DWORD PTR tv92[ebp], eax
	cmp	DWORD PTR tv92[ebp], 3
	ja	SHORT $LN14@WspiapiQue
	mov	ecx, DWORD PTR tv92[ebp]
	jmp	DWORD PTR $LN20@WspiapiQue[ecx*4]
$LN10@WspiapiQue:

; 308  :     {
; 309  :         case WSAHOST_NOT_FOUND: return EAI_NONAME;

	mov	eax, 11001				; 00002af9H
	jmp	SHORT $LN1@WspiapiQue
$LN11@WspiapiQue:

; 310  :         case WSATRY_AGAIN:      return EAI_AGAIN;

	mov	eax, 11002				; 00002afaH
	jmp	SHORT $LN1@WspiapiQue
$LN12@WspiapiQue:

; 311  :         case WSANO_RECOVERY:    return EAI_FAIL;

	mov	eax, 11003				; 00002afbH
	jmp	SHORT $LN1@WspiapiQue
$LN13@WspiapiQue:

; 312  :         case WSANO_DATA:        return EAI_NODATA;

	mov	eax, 11001				; 00002af9H
	jmp	SHORT $LN1@WspiapiQue
$LN14@WspiapiQue:

; 313  :         default:                return EAI_NONAME;

	mov	eax, 11001				; 00002af9H
$LN1@WspiapiQue:

; 314  :     }
; 315  : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	2
$LN20@WspiapiQue:
	DD	$LN10@WspiapiQue
	DD	$LN11@WspiapiQue
	DD	$LN12@WspiapiQue
	DD	$LN13@WspiapiQue
_WspiapiQueryDNS@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiNewAddrInfo@16
_TEXT	SEGMENT
_ptAddress$ = -8					; size = 4
_ptNew$ = -4						; size = 4
_iSocketType$ = 8					; size = 4
_iProtocol$ = 12					; size = 4
_wPort$ = 16						; size = 2
_dwAddress$ = 20					; size = 4
_WspiapiNewAddrInfo@16 PROC				; COMDAT

; 206  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4

; 207  :     struct addrinfo     *ptNew;
; 208  :     struct sockaddr_in  *ptAddress;
; 209  : 
; 210  :     // allocate a new addrinfo structure.
; 211  :     ptNew       =

	mov	esi, esp
	push	32					; 00000020H
	push	1
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ptNew$[ebp], eax

; 212  :         (struct addrinfo *) WspiapiMalloc(sizeof(struct addrinfo));
; 213  :     if (!ptNew)

	cmp	DWORD PTR _ptNew$[ebp], 0
	jne	SHORT $LN2@WspiapiNew

; 214  :         return NULL;

	xor	eax, eax
	jmp	$LN1@WspiapiNew
$LN2@WspiapiNew:

; 215  : 
; 216  :     ptAddress   =

	mov	esi, esp
	push	16					; 00000010H
	push	1
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ptAddress$[ebp], eax

; 217  :         (struct sockaddr_in *) WspiapiMalloc(sizeof(struct sockaddr_in));
; 218  :     if (!ptAddress)

	cmp	DWORD PTR _ptAddress$[ebp], 0
	jne	SHORT $LN3@WspiapiNew

; 219  :     {
; 220  : #pragma warning(suppress: 6280)
; 221  :         WspiapiFree(ptNew);

	mov	esi, esp
	mov	eax, DWORD PTR _ptNew$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 222  :         return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@WspiapiNew
$LN3@WspiapiNew:

; 223  :     }
; 224  :     ptAddress->sin_family       = AF_INET;

	mov	ecx, 2
	mov	edx, DWORD PTR _ptAddress$[ebp]
	mov	WORD PTR [edx], cx

; 225  :     ptAddress->sin_port         = wPort;

	mov	eax, DWORD PTR _ptAddress$[ebp]
	mov	cx, WORD PTR _wPort$[ebp]
	mov	WORD PTR [eax+2], cx

; 226  :     ptAddress->sin_addr.s_addr  = dwAddress;

	mov	edx, DWORD PTR _ptAddress$[ebp]
	mov	eax, DWORD PTR _dwAddress$[ebp]
	mov	DWORD PTR [edx+4], eax

; 227  :     
; 228  :     // fill in the fields...
; 229  :     ptNew->ai_family            = PF_INET;

	mov	ecx, DWORD PTR _ptNew$[ebp]
	mov	DWORD PTR [ecx+4], 2

; 230  :     ptNew->ai_socktype          = iSocketType;

	mov	edx, DWORD PTR _ptNew$[ebp]
	mov	eax, DWORD PTR _iSocketType$[ebp]
	mov	DWORD PTR [edx+8], eax

; 231  :     ptNew->ai_protocol          = iProtocol;

	mov	ecx, DWORD PTR _ptNew$[ebp]
	mov	edx, DWORD PTR _iProtocol$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 232  :     ptNew->ai_addrlen           = sizeof(struct sockaddr_in);

	mov	eax, DWORD PTR _ptNew$[ebp]
	mov	DWORD PTR [eax+16], 16			; 00000010H

; 233  :     ptNew->ai_addr              = (struct sockaddr *) ptAddress;

	mov	ecx, DWORD PTR _ptNew$[ebp]
	mov	edx, DWORD PTR _ptAddress$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 234  : 
; 235  :     return ptNew;

	mov	eax, DWORD PTR _ptNew$[ebp]
$LN1@WspiapiNew:

; 236  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_WspiapiNewAddrInfo@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiParseV4Address@8
_TEXT	SEGMENT
_iCount$ = -12						; size = 4
_pcNext$ = -8						; size = 4
_dwAddress$ = -4					; size = 4
_pszAddress$ = 8					; size = 4
_pdwAddress$ = 12					; size = 4
_WspiapiParseV4Address@8 PROC				; COMDAT

; 157  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4

; 158  :     DWORD       dwAddress   = 0;

	mov	DWORD PTR _dwAddress$[ebp], 0

; 159  :     const char  *pcNext     = NULL;

	mov	DWORD PTR _pcNext$[ebp], 0

; 160  :     int         iCount      = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 161  : 
; 162  :     // ensure there are 3 '.' (periods)
; 163  :     for (pcNext = pszAddress; *pcNext != '\0'; pcNext++)

	mov	eax, DWORD PTR _pszAddress$[ebp]
	mov	DWORD PTR _pcNext$[ebp], eax
	jmp	SHORT $LN4@WspiapiPar
$LN2@WspiapiPar:
	mov	ecx, DWORD PTR _pcNext$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pcNext$[ebp], ecx
$LN4@WspiapiPar:
	mov	edx, DWORD PTR _pcNext$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN3@WspiapiPar

; 164  :         if (*pcNext == '.')

	mov	ecx, DWORD PTR _pcNext$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	jne	SHORT $LN5@WspiapiPar

; 165  :             iCount++;

	mov	eax, DWORD PTR _iCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCount$[ebp], eax
$LN5@WspiapiPar:
	jmp	SHORT $LN2@WspiapiPar
$LN3@WspiapiPar:

; 166  :     if (iCount != 3)

	cmp	DWORD PTR _iCount$[ebp], 3
	je	SHORT $LN6@WspiapiPar

; 167  :         return FALSE;

	xor	eax, eax
	jmp	SHORT $LN1@WspiapiPar
$LN6@WspiapiPar:

; 168  : 
; 169  :     // return an error if dwAddress is INADDR_NONE (255.255.255.255)
; 170  :     // since this is never a valid argument to getaddrinfo.
; 171  : #pragma warning(suppress: 4996)
; 172  :     dwAddress = inet_addr(pszAddress);

	mov	esi, esp
	mov	ecx, DWORD PTR _pszAddress$[ebp]
	push	ecx
	call	DWORD PTR __imp__inet_addr@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwAddress$[ebp], eax

; 173  :     if (dwAddress == INADDR_NONE)

	cmp	DWORD PTR _dwAddress$[ebp], -1
	jne	SHORT $LN7@WspiapiPar

; 174  :         return FALSE;

	xor	eax, eax
	jmp	SHORT $LN1@WspiapiPar
$LN7@WspiapiPar:

; 175  : 
; 176  :     *pdwAddress = dwAddress;

	mov	edx, DWORD PTR _pdwAddress$[ebp]
	mov	eax, DWORD PTR _dwAddress$[ebp]
	mov	DWORD PTR [edx], eax

; 177  :     return TRUE;

	mov	eax, 1
$LN1@WspiapiPar:

; 178  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_WspiapiParseV4Address@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiStrdup@4
_TEXT	SEGMENT
tv67 = -24						; size = 4
tv88 = -17						; size = 1
tv85 = -16						; size = 4
tv82 = -12						; size = 4
_cchMemory$ = -8					; size = 4
_pszMemory$ = -4					; size = 4
_pszString$ = 8						; size = 4
_WspiapiStrdup@4 PROC					; COMDAT

; 119  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4

; 120  :     char    *pszMemory;
; 121  :     size_t  cchMemory;
; 122  : 
; 123  :     if (!pszString)

	cmp	DWORD PTR _pszString$[ebp], 0
	jne	SHORT $LN2@WspiapiStr

; 124  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@WspiapiStr
$LN2@WspiapiStr:

; 125  : 
; 126  :     cchMemory = strlen(pszString) + 1;

	mov	eax, DWORD PTR _pszString$[ebp]
	mov	DWORD PTR tv82[ebp], eax
	mov	ecx, DWORD PTR tv82[ebp]
	add	ecx, 1
	mov	DWORD PTR tv85[ebp], ecx
$LL5@WspiapiStr:
	mov	edx, DWORD PTR tv82[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv88[ebp], al
	add	DWORD PTR tv82[ebp], 1
	cmp	BYTE PTR tv88[ebp], 0
	jne	SHORT $LL5@WspiapiStr
	mov	ecx, DWORD PTR tv82[ebp]
	sub	ecx, DWORD PTR tv85[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	mov	edx, DWORD PTR tv67[ebp]
	add	edx, 1
	mov	DWORD PTR _cchMemory$[ebp], edx

; 127  :     pszMemory = (char *) WspiapiMalloc(cchMemory);

	mov	esi, esp
	mov	eax, DWORD PTR _cchMemory$[ebp]
	push	eax
	push	1
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pszMemory$[ebp], eax

; 128  :     if (!pszMemory)

	cmp	DWORD PTR _pszMemory$[ebp], 0
	jne	SHORT $LN3@WspiapiStr

; 129  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@WspiapiStr
$LN3@WspiapiStr:

; 130  : 
; 131  :     _WSPIAPI_STRCPY_S(pszMemory, cchMemory, pszString);

	mov	esi, esp
	mov	ecx, DWORD PTR _pszString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cchMemory$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszMemory$[ebp]
	push	eax
	call	DWORD PTR __imp__strcpy_s
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 132  :     return pszMemory;

	mov	eax, DWORD PTR _pszMemory$[ebp]
$LN1@WspiapiStr:

; 133  : }

	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_WspiapiStrdup@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
tv81 = -20						; size = 4
__Result$1 = -16					; size = 4
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __BufferCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	edx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR [eax+4]
	push	edx
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$1[ebp], eax

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$1[ebp], 0
	jge	SHORT $LN5@snprintf
	mov	DWORD PTR tv81[ebp], -1
	jmp	SHORT $LN3@snprintf
$LN5@snprintf:
	mov	eax, DWORD PTR __Result$1[ebp]
	mov	DWORD PTR tv81[ebp], eax
$LN3@snprintf:

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 1954 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1955 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1956 :     }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
tv81 = -20						; size = 4
__Result$1 = -16					; size = 4
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1841 :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1842 :             int _Result;
; 1843 :             va_list _ArgList;
; 1844 :             __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1845 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 1498 :         int const _Result = __stdio_common_vsprintf_s(

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __BufferCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	edx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf_s
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$1[ebp], eax

; 1499 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1500 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1501 : 
; 1502 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$1[ebp], 0
	jge	SHORT $LN5@sprintf_s
	mov	DWORD PTR tv81[ebp], -1
	jmp	SHORT $LN3@sprintf_s
$LN5@sprintf_s:
	mov	eax, DWORD PTR __Result$1[ebp]
	mov	DWORD PTR tv81[ebp], eax
$LN3@sprintf_s:

; 1845 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 1846 :             __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1847 :             return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1848 :         }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
